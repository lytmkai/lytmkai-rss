<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[上下文协议（MCP）Java SDK 指南]]></title>    <link>https://juejin.cn/post/7584432435590217782</link>    <guid>https://juejin.cn/post/7584432435590217782</guid>    <pubDate>2025-12-17T05:00:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584432435590217782" data-draft-id="7584356212801880105" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="上下文协议（MCP）Java SDK 指南"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2025-12-17T05:00:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序猿DD"/> <meta itemprop="url" content="https://juejin.cn/user/131597123993358"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            上下文协议（MCP）Java SDK 指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/131597123993358/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序猿DD
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T05:00:15.000Z" title="Wed Dec 17 2025 05:00:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    10
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>当我们把各种内部系统、数据源、工具接入大语言模型时，往往会遇到一个尴尬的问题：每个团队、每套系统都有自己的一套“接入规范”。有的用 HTTP API，有的用消息队列，有的直接连数据库，最后一圈串下来，既难以统一治理，又很难在不同应用之间复用。这时，你可能会问：有没有一种通用的协议，既能让 AI 模型方便地调用外部工具、访问数据，又能让后端服务方用标准方式暴露能力？</p>
<p>Model Context Protocol（MCP）就是为此而生的标准之一，而本文要介绍的 Java SDK，则为 Java 开发者提供了一条直接接入 MCP 生态的通路。通过它，你可以用统一的模型，在 Java 应用里暴露工具、资源、提示模版，也可以轻松作为客户端去调用这些能力。本文将从整体架构讲起，一步步带你用一个可运行的示例，搭建起自己的 MCP 服务端与客户端。</p>
<h2 data-id="heading-0">1. 概览</h2>
<p>随着近年来 AI 的快速发展，越来越多的工具和系统开始与 AI 模型集成。但随之而来的一个挑战是：每种集成都可能采用完全不同的标准和方式，将外部工具、资源和系统接入到 AI 模型中。</p>
<p>Model Context Protocol（MCP）是一个开源标准，它定义了 AI 应用（如大语言模型、图像生成模型等）与工具、数据源以及其他资源之间的集成方式。借助 MCP，AI 应用可以按外部系统约定的方式访问数据、调用工具并执行工作流。</p>
<p>MCP 的 Java SDK 为开发者提供了一组库，支持多种协议和通信机制，用于把 Java 应用与 AI 应用连接起来。</p>
<p>在本教程中，我们将一起了解这个 SDK，并通过一个简单示例来体验 MCP 的使用方式。</p>
<h2 data-id="heading-1">2. 架构</h2>
<p>MCP 架构的核心组件主要包括：</p>
<ul>
<li><strong>MCP Host：负责管理多个 MCP Client</strong></li>
<li><strong>MCP Client：从 MCP Server 获取上下文，供 MCP Host 使用</strong></li>
<li><strong>MCP Server：向 MCP Client 提供上下文信息和可调用能力</strong></li>
</ul>
<p>MCP 将通信划分为两个概念层次：<strong>数据层（Data Layer），用于定义客户端与服务端的通信协议和生命周期管理</strong>；以及 <strong>传输层（Transport Layer），用于定义客户端和服务端之间的具体传输通道和机制</strong>。</p>
<p>Java 版的 MCP SDK 将这些概念映射为如下几个层次：</p>
<ul>
<li>Client/Server 层：通过 <code>McpClient</code> / <code>McpServer</code> 实现并管理客户端/服务端的具体操作</li>
<li>Session 层：通过 <code>McpSession</code> 管理通信模式和会话状态</li>
<li>Transport 层：通过 <code>McpTransport</code> 处理消息的序列化与反序列化</li>
</ul>
<p>客户端会调用 MCP 服务端暴露的一到多个工具（tool），而底层的通信则由传输层负责。</p>
<p>在 MCP 中，<strong>Primitive（原语）</strong> 是最基础的构建单元，用来定义可用的上下文信息类型以及可执行的操作范围。服务端和客户端都提供了一些原语。</p>
<p>服务端侧的原语包括工具（tools）、资源（resources）和提示模版（prompts）。<strong>工具是 AI 应用可以调用的可执行函数</strong>，例如查询数据库、文件操作等。<strong>资源是提供给客户端的上下文数据源</strong>，例如数据库结构、文件内容等。<strong>提示模版是可复用的模版，用于与语言模型进行交互</strong>。</p>
<p>客户端侧的原语则帮助 <code>McpServer</code> 的实现者构建更丰富的交互能力，包括采样（sampling）、信息补充（elicitation）和日志（logging）。<strong>采样允许服务端在不集成模型 SDK 的情况下，向客户端请求语言模型补全结果。</strong> <strong>信息补充让服务端能够向用户请求额外信息或确认操作。</strong> <strong>日志则允许服务端向客户端发送日志消息，用于调试和监控。</strong></p>
<h2 data-id="heading-2">3. 环境准备</h2>
<p>要使用 MCP Java SDK，我们需要在项目中加入 <code>mcp</code> 依赖：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.modelcontextprotocol.sdk<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.15.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<h3 data-id="heading-3">3.1 定义一个 MCP 工具</h3>
<p>我们先通过 <code>LoggingTool</code> 这个类，定义一个非常简单的 MCP 工具，用来打印收到的提示词（prompt），该方法返回一个 <code>SyncToolSpecification</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingTool</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> McpServerFeatures.SyncToolSpecification <span class="hljs-title function_">logPromptTool</span><span class="hljs-params">()</span> {
        McpSchema.<span class="hljs-type">JsonSchema</span> <span class="hljs-variable">inputSchema</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">McpSchema</span>.JsonSchema(<span class="hljs-string">"object"</span>,
            Map.of(<span class="hljs-string">"prompt"</span>, String.class), List.of(<span class="hljs-string">"prompt"</span>), <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">McpServerFeatures</span>.SyncToolSpecification(
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">McpSchema</span>.Tool(
              <span class="hljs-string">"logPrompt"</span>, <span class="hljs-string">"Log Prompt"</span>,<span class="hljs-string">"Logs a provided prompt"</span>, inputSchema, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>),
                (exchange, args) -&gt; {
                    <span class="hljs-type">String</span> <span class="hljs-variable">prompt</span> <span class="hljs-operator">=</span> (String) args.get(<span class="hljs-string">"prompt"</span>);
                    <span class="hljs-keyword">return</span> McpSchema.CallToolResult.builder()
                      .content(List.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">McpSchema</span>.TextContent(<span class="hljs-string">"Input Prompt: "</span> + prompt)))
                      .isError(<span class="hljs-literal">false</span>)
                      .build();
                });
    }
}
</code></pre>
<p>这里我们首先定义了输入的 JSON Schema，用来为用户输入建立一个清晰的契约。接着，使用该输入 Schema 来实例化一个 <code>Tool</code>，在处理逻辑中提取出 <code>prompt</code> 参数，并最终返回包含该 <code>prompt</code> 的 <code>TextContent</code> 结果。</p>
<h2 data-id="heading-4">4. MCP 客户端与服务端搭建</h2>
<p>接下来，我们需要一个 MCP 服务端来暴露自定义工具，以及一个或多个 MCP 客户端，用于连接该服务端并调用其中的工具。</p>
<h3 data-id="heading-5">4.1 MCP 服务端实现</h3>
<p><code>McpServer</code> 具有一组能力（capabilities），用来告知客户端当前服务器支持哪些类别的协议操作，例如日志记录、提示词补全、资源访问等。此外，工具（tools）则提供给客户端可调用的具体函数。</p>
<p>先来看一个 <code>McpServer</code> 的实现：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">McpServerApp</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> McpSyncServer <span class="hljs-title function_">createServer</span><span class="hljs-params">()</span> {
        <span class="hljs-type">JacksonMcpJsonMapper</span> <span class="hljs-variable">jsonMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonMcpJsonMapper</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>());
        <span class="hljs-type">StdioServerTransportProvider</span> <span class="hljs-variable">transportProvider</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StdioServerTransportProvider</span>(
            jsonMapper);

        <span class="hljs-keyword">return</span> McpServer.sync(transportProvider)
          .serverInfo(<span class="hljs-string">"baeldung-demo-server"</span>, <span class="hljs-string">"0.0.1"</span>)
          .capabilities(McpSchema.ServerCapabilities.builder()
            .tools(<span class="hljs-literal">true</span>)
            .logging()
            .build())
          .tools(LoggingTool.logPromptTool())
          .build();
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        createServer();
    }
}
</code></pre>
<p>上面代码定义了一个同步的 <code>McpServer</code>，通过标准输入/输出流并使用 JSON 消息格式进行通信。随后我们声明了服务器的能力：开启工具以及日志功能（基于 SLF4J 日志框架），最后把自定义的 <code>logPromptTool</code> 注册到服务器上。</p>
<h3 data-id="heading-6">4.3 MCP 客户端实现</h3>
<p>下面再定义一个简单的 <code>McpClient</code>，用于连接到服务端：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">McpClientApp</span> {

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> McpSyncClient <span class="hljs-title function_">getClient</span><span class="hljs-params">()</span> {
        <span class="hljs-type">ServerParameters</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> ServerParameters
          .builder(<span class="hljs-string">"npx"</span>)
          .args(<span class="hljs-string">"-y"</span>, <span class="hljs-string">"@modelcontextprotocol/server-everything"</span>)
          .build();

        <span class="hljs-type">JacksonMcpJsonMapper</span> <span class="hljs-variable">jsonMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonMcpJsonMapper</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>());
        <span class="hljs-type">McpClientTransport</span> <span class="hljs-variable">transport</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StdioClientTransport</span>(params, jsonMapper);

        <span class="hljs-keyword">return</span> io.modelcontextprotocol.client.McpClient.sync(transport)
         .build();

    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">McpSyncClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> getClient();
        client.initialize();
    }
}
</code></pre>
<p>这里我们使用 MCP 提供的示例服务端，并通过 <code>ServerParameters</code> 进行配置。客户端同样通过标准输入/输出流以及 JSON 消息格式与服务端进行同步通信。</p>
<h2 data-id="heading-7">5. 测试</h2>
<p>到目前为止，我们已经具备了测试 MCP 交互和核心概念所需的全部组件。</p>
<h3 data-id="heading-8">5.1 测试 MCP 工具与客户端实现</h3>
<p>我们先从测试 <code>LoggingTool</code> 开始，验证其输出是否正确：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">whenLogPromptToolCalled_thenReturnsResult</span><span class="hljs-params">()</span> {
    McpSchema.<span class="hljs-type">CallToolRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">McpSchema</span>.CallToolRequest(<span class="hljs-string">""</span>,
        Map.of(<span class="hljs-string">"prompt"</span>, <span class="hljs-string">"Unit test message"</span>));

    McpServerFeatures.<span class="hljs-type">SyncToolSpecification</span> <span class="hljs-variable">toolSpec</span> <span class="hljs-operator">=</span> LoggingTool.logPromptTool();
    McpSchema.<span class="hljs-type">CallToolResult</span> <span class="hljs-variable">result</span> 
        <span class="hljs-operator">=</span> toolSpec.callHandler().apply(<span class="hljs-literal">null</span>, request);
    assertNotNull(result);
    assertFalse(result.isError());
    assertEquals(
        <span class="hljs-string">"Input Prompt: Unit test message"</span>,((McpSchema.TextContent) (result.content()
        .getFirst()))
        .text());
}
</code></pre>
<p>在这个测试中，我们创建了一个带有 <code>prompt</code> 的 <code>CallToolRequest</code>，并将其传递给 <code>LoggingTool</code> 的 <code>SyncToolSpecification</code>。随后，我们断言返回结果非空、无错误，并且返回的文本内容与预期相同。</p>
<p>接下来，我们再通过 MCP 提供的示例服务端来测试 <code>McpClient</code>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">whenCalledViaClient_thenReturnsLoggedResult</span><span class="hljs-params">()</span> {
    McpSchema.<span class="hljs-type">CallToolRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">McpSchema</span>.CallToolRequest(
        <span class="hljs-string">"echo"</span>, Map.of(<span class="hljs-string">"message"</span>, <span class="hljs-string">"Client-server test message"</span>));
    McpSchema.<span class="hljs-type">CallToolResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> client.callTool(request);

    assertNotNull(result);
    assertNull(result.isError());
    assertEquals(<span class="hljs-string">"Echo: Client-server test message"</span>,
        ((McpSchema.TextContent) (result.content()
        .getFirst())).text());
}
</code></pre>
<p>MCP 示例服务端暴露了一个名为 <code>echo</code> 的工具，它会把输入消息原样返回，这与我们之前实现的 <code>LoggingTool</code> 的行为类似。</p>
<h3 data-id="heading-9">5.2 测试本地服务端</h3>
<p>最后，我们来测试自己编写的本地服务端。为此需要定义一个单独的 <code>McpClient</code>，并使用指向本地 JAR 的不同服务端参数：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">McpClientApp2</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(McpClientApp2.class);

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">jarPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.File(<span class="hljs-string">"java-mcp/target/java-mcp-1.0.0-SNAPSHOT.jar"</span>)
                             .getAbsolutePath();
        <span class="hljs-type">ServerParameters</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> ServerParameters.builder(<span class="hljs-string">"java"</span>)
            .args(<span class="hljs-string">"-jar"</span>, jarPath)
            .build();

        <span class="hljs-type">JacksonMcpJsonMapper</span> <span class="hljs-variable">jsonMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JacksonMcpJsonMapper</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>());
        <span class="hljs-type">McpClientTransport</span> <span class="hljs-variable">transport</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StdioClientTransport</span>(params, jsonMapper);

        <span class="hljs-type">McpSyncClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> McpClient.sync(transport)
            .build();

        client.initialize();

        <span class="hljs-type">ListToolsResult</span> <span class="hljs-variable">tools</span> <span class="hljs-operator">=</span> client.listTools();
        McpClientApp2.log.info(<span class="hljs-string">"Tools exposed by the server:"</span>);
        tools
          .tools()
          .forEach(tool -&gt; System.out.println(<span class="hljs-string">" - "</span> + tool.name()));

        McpClientApp2.log.info(<span class="hljs-string">"\nCalling 'logPrompt' tool..."</span>);
        <span class="hljs-type">CallToolResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> client.callTool(
          <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallToolRequest</span>(<span class="hljs-string">"logPrompt"</span>, Map.of(<span class="hljs-string">"prompt"</span>, <span class="hljs-string">"Hello from MCP client!"</span>)));
        McpClientApp2.log.info(<span class="hljs-string">"Result: "</span> + result.content());

        client.closeGracefully();
    }
}
</code></pre>
<p>运行该客户端后，我们可以通过日志来验证它是否成功连接到了本地 JAR 中定义的服务端：</p>
<pre><code class="hljs language-text" lang="text">14:04:27.879 [boundedElastic-1] INFO  i.m.c.transport.StdioClientTransport - MCP server starting.
14:04:27.920 [boundedElastic-1] INFO  i.m.c.transport.StdioClientTransport - MCP server started
14:04:28.517 [pool-4-thread-1] INFO  i.m.c.transport.StdioClientTransport - STDERR Message received: 14:04:28.504 [pool-1-thread-1] INFO  i.m.server.McpAsyncServer - Client initialize request - Protocol: 2024-11-05, Capabilities: ClientCapabilities[experimental=null, roots=null, sampling=null, elicitation=null], Info: Implementation[name=Java SDK MCP Client, title=null, version=0.15.0]
14:04:28.575 [pool-1-thread-1] INFO  i.m.client.LifecycleInitializer - Server response with Protocol: 2024-11-05, Capabilities: ServerCapabilities[completions=null, experimental=null, logging=LoggingCapabilities[], prompts=null, resources=null, tools=ToolCapabilities[listChanged=true]], Info: Implementation[name=baeldung-demo-server, title=null, version=0.0.1] and Instructions null
14:04:28.626 [main] INFO  mcp.McpClientApp2 - Tools exposed by the server:
14:04:28.626 [main] INFO  mcp.McpClientApp2 - 
Calling 'logPrompt' tool...
 - logPrompt
14:04:28.671 [main] INFO  mcp.McpClientApp2 - Result: [TextContent[annotations=null, text=Input Prompt: Hello from MCP client!, meta=null]]
14:04:28.784 [ForkJoinPool.commonPool-worker-1] WARN  i.m.c.transport.StdioClientTransport - Process terminated with code 143

Process finished with exit code 0
</code></pre>
<p>从日志可以看到，首先 <code>McpServer</code> 启动成功，随后客户端完成初始化并与服务端</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[是什么支撑L3自动驾驶落地？读懂AI驾驶与碰撞预测]]></title>    <link>https://juejin.cn/post/7584346983136149556</link>    <guid>https://juejin.cn/post/7584346983136149556</guid>    <pubDate>2025-12-17T05:31:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584346983136149556" data-draft-id="7584346983135199284" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="是什么支撑L3自动驾驶落地？读懂AI驾驶与碰撞预测"/> <meta itemprop="keywords" content="算法,计算机视觉,深度学习"/> <meta itemprop="datePublished" content="2025-12-17T05:31:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CoovallyAIHub"/> <meta itemprop="url" content="https://juejin.cn/user/2461151071843739"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            是什么支撑L3自动驾驶落地？读懂AI驾驶与碰撞预测
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2461151071843739/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CoovallyAIHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T05:31:03.000Z" title="Wed Dec 17 2025 05:31:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>就在昨天，中国首批L3级自动驾驶车辆正式获得上路许可，标志着我国无人驾驶正式迈入“商业化应用”新纪元。这意味着，在法规允许的路段和条件下，驾驶员可以将车辆完全交由系统操控——而这一切的安全基石，<strong>正是车辆精准的环境感知与超前预测能力</strong>。当系统掌控方向盘时，它必须能预判那些瞬息万变的风险：譬如相邻车道的突然加塞、行人从视觉盲区步入车道，或是电动车在路口毫无征兆的变向。这些瞬间，正是碰撞预测技术核心价值所在。</p>
<p>此前，我们探讨过球类轨迹预测，它展示了如何通过预判运动轨迹来理解并预见未来。碰撞预测技术与之原理相通，本质上是交通场景中的“未来洞察”。</p>
<p>这类预测系统通过持续追踪车辆、行人等所有交通参与者的运动状态，能够提前识别风险，并在危险发生前调整路径或行为（这通常被称为运动规划或路径规划），从而实现防患于未然。</p>
<p>支撑碰撞预测系统的核心技术是人工智能及其子领域，包括用于理解环境的计算机视觉，以及用于预测物体运动轨迹的各类算法模型。能够实时检测并追踪车辆、行人等目标；预测模型则利用这些信息，估算它们未来的移动轨迹。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1af60c7963df405c95495ef1fcce24f1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766554262&amp;x-signature=6ayLKQpCcMhh29l8mLuO0YD072s%3D" alt="screenshot_2025-12-16_14-16-12.png" loading="lazy"/></p>
<p>最终，我们得到一个能够理解周围环境、并在动态场景中支持更智能决策的 AI 系统。在本文中，我们将探讨碰撞预测的工作原理、背后的方法，以及计算机视觉和 模型算法在其中扮演的角色。</p>
<h2 data-id="heading-0"><strong>什么是碰撞预测？</strong></h2>
<p>碰撞预测是指 AI 系统能够理解物体如何运动，并预判它们何时可能过于接近或发生接触的能力。不同的系统可以多种方式利用这一信息，包括支持安全功能、优化运动路径，或在共享空间内协调行动。</p>
<p>只要有物体在共享空间中移动——无论是高速公路上的汽车、仓库通道里的叉车，还是过马路的行人——碰撞预测都能帮助系统理解这些互动将如何展开。在注重安全的应用中，这种预见性可用于降低风险；而在其他场景中，它可支持诸如路线规划、时机把握或协调运动等任务。</p>
<p>例如，在许多配备先进驾驶辅助系统（ADAS）的新车中，摄像头和传感器会监控前方道路，并估算车辆接近附近物体的速度。如果系统检测到情况可能变得不安全，它会向驾驶员发出警报，在某些情况下，自动刹车也可能介入以减轻撞击。</p>
<h2 data-id="heading-1"><strong>探索碰撞预测的四个阶段</strong></h2>
<p>碰撞预测涉及一个协调的过程，不同的 AI 组件协同工作，以识别物体、跟踪其运动并估计接下来可能发生的情况。这些系统通常通过四个相互关联的阶段运作：物体检测、物体跟踪、轨迹预测，最后是碰撞预测。每个阶段的准确性都建立在前一阶段的基础之上。</p>
<p>接下来，让我们仔细看看每个阶段是如何工作的。</p>
<ul>
<li><strong>物体检测概览</strong></li>
</ul>
<p>物体检测是计算机视觉的一项核心任务，视觉 AI 模型借此识别并定位图像或视频帧中的物体。通过分析像素数据，物体检测模型可以生成三个主要输出：边界框、物体类别和置信度分数。边界框显示物体的位置，物体类别表明它是什么（如汽车、行人或骑行者），置信度分数则反映模型对预测的把握程度。</p>
<p>像 YOLO11 和 YOLO26 这样的视觉 AI 模型在此基础上发展，并支持几项相关任务，包括物体检测、物体跟踪和定向边界框（OBB）检测。物体检测能告诉预测系统每帧图像中有什么，跟踪则跟随这些物体移动，而定向边界框为以不同角度出现的物体提供更精确的形状描述。</p>
<p>在此阶段，碰撞预测系统纯粹专注于理解视觉数据中存在什么。它构成了所有后续步骤所依赖的信息基础层，但尚未考虑物体将如何移动或互动。</p>
<ul>
<li><strong>物体跟踪概述</strong></li>
</ul>
<p>一旦物体被检测到，下一步就是在连续帧之间跟踪它们，以便系统理解它们随时间的移动。虽然检测在每一帧都提供新的边界框，但物体跟踪通过将这些检测结果随时间关联起来，增加了连续性。</p>
<p>跟踪算法（如 ByteTrack 或 BoT-SORT）这些算法为每个物体分配一个唯一 ID，并利用它来保持该物体的身份，即使物体快速移动或暂时被部分遮挡。这就创建了一个平滑的跟踪历史，捕捉了物体的运动轨迹。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/804d530bafa44ab5864c1f988f754d1c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766554262&amp;x-signature=5E1Q5QuxSA4kG2MmgQDFuuqkmuE%3D" alt="screenshot_2025-12-16_14-16-55.png" loading="lazy"/></p>
<p>以下是这两种跟踪方法的简要介绍：</p>
<ul>
<li><strong>ByteTrack：</strong> 它同时使用高置信度和低置信度的检测结果来维持物体 ID 的一致性，其中卡尔曼滤波器的运动预测帮助跟踪器在物体快速移动或短暂难以检测时保持稳定。</li>
<li><strong>BoT-SORT：</strong> 该算法在 SORT 的基础上，结合了卡尔曼滤波器的运动预测和外观特征，使跟踪器能够在拥挤场景或部分遮挡期间更可靠地跟踪物体。</li>
</ul>
<p>为了衡量这些跟踪方法的性能，研究人员会在已建立的多目标跟踪（MOT）数据集和基准上进行评估。常用的指标包括：<strong>多目标跟踪准确度（MOTA）</strong> ，反映整体跟踪质量；<strong>识别 F1 分数（IDF1）</strong> ，衡量物体身份一致性的保持程度；以及<strong>高阶跟踪准确度（HOTA）</strong> ，提供检测性能和关联准确度的平衡评估。</p>
<ul>
<li><strong>理解轨迹预测</strong></li>
</ul>
<p>在跨多帧跟踪物体之后，下一步就是预测它接下来会去哪里。这被称为轨迹预测。检测负责找到物体，跟踪负责跟随其移动，而预测则是向前看，估计其未来位置。</p>
<p>来自检测和跟踪的信息，如物体的边界框、跨帧的位置和分配的 ID，可用于计算运动特征，如速度、方向和移动模式。这些衍生出的洞察为预测模型提供了所需的数据，以估计物体在未来几秒钟可能的位置。</p>
<p>在跟踪数据存在缺口或跳跃的情况下，<strong>插值技术</strong>有助于重建更平滑、更一致的轨迹。这确保了预测模型接收到高质量的运动输入，而非嘈杂或不完整的位置数据。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bb4417e13573457dabfe5885495cef28~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766554262&amp;x-signature=1%2B%2B7tSdd1xIuYvBrUN8SXxRFYY4%3D" alt="screenshot_2025-12-16_14-17-04.png" loading="lazy"/></p>
<p>为了做出这些预测，许多系统依赖于深度学习模型，这些模型旨在理解物体的运动如何随时间变化。通过分析一系列过去的位置以及从中推导出的运动特征，这些模型学习常见的移动模式，并利用该知识来预测未来路径。</p>
<p>以下是一些常用于轨迹预测的深度学习和机器学习方法：</p>
<ul>
<li><strong>循环神经网络（RNNs）：</strong> RNN 是专为处理序列（如一系列视频帧）而设计的深度学习模型。它们能记住先前的位置，并利用该信息来理解物体的移动方式。这有助于系统识别简单的运动模式，如加速、减速或直线移动。</li>
<li><strong>长短期记忆网络（LSTMs）：</strong> LSTM 是一种更高级的 RNN，能够更长时间地记住信息。这使得它们能够捕捉更复杂的运动，例如准备转弯的车辆或改变方向的行人。由于能够跟踪更长期的趋势，它们在繁忙环境中通常能产生更可靠的预测。</li>
<li><strong>Transformer 模型：</strong> Transformer 处理完整的运动序列，并使用注意力机制聚焦于这些序列中最重要的细节。这使得它们在多物体相互作用的场景（如车辆并线或行人交叉穿行）中特别有效。</li>
</ul>
<p>这些模型可以预测短期和较长期的路径。短期预测（通常在 2 秒以内）往往最准确，而更长时间窗口（例如 2 到 6 秒）的预测提供了更强的预见性，但也伴随着更大的不确定性。</p>
<ul>
<li><strong>整合一切：碰撞检测算法</strong></li>
</ul>
<p>在最后的碰撞预测阶段，系统综合利用迄今为止学到的一切：<strong>每个物体是什么（检测）、它如何移动（跟踪）以及它下一步可能去哪里（预测）</strong> 。这一步会检查任何预测路径是否可能以导致碰撞的方式相交。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c48db4ff34b44e82b7cf6d1fd046327c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766554262&amp;x-signature=r9TGXVFDq6Qk3KlKraPiQ8%2BgwzE%3D" alt="screenshot_2025-12-16_14-17-13.png" loading="lazy"/></p>
<p>以自动驾驶汽车为例，碰撞检查系统会比较附近物体（如汽车、行人、骑行者）的未来轨迹。如果两条预测路径重叠或危险地接近，系统会将该情况标记为潜在的车辆碰撞。为了理解碰撞风险有多紧急，系统还会计算一个称为“碰撞时间”的值。</p>
<p>碰撞时间（TTC）是快速移动环境中的一个关键测量值。它估算如果两个物体继续以当前速度和方向运动，距离发生碰撞还有多少时间。当 TTC 低于某个阈值时，系统可通过发出警告、启动刹车或调整其计划路径来做出反应。</p>
<h2 data-id="heading-2"><strong>碰撞预测的实际应用</strong></h2>
<p>碰撞预测正变得对许多行业至关重要，包括交通管理、智慧城市基础设施、工业自动化和移动机器人。随着前沿的计算机视觉和预测模型不断进步，这些系统预测运动的能力也在不断增强。</p>
<p>现在我们对碰撞预测和轨迹预测有了更好的理解，让我们看一些有趣的研究案例，它们展示了这些方法如何在各种现实环境中应用。</p>
<ul>
<li><strong>基于 YOLO 的紧急自动驾驶车辆碰撞预测</strong></li>
</ul>
<p>在拥挤、不可预测的环境中导航是自主系统面临的最严峻挑战之一，尤其是当行人的移动方式没有清晰规律时。紧急车辆更常面临这个问题，因为它们需要高速快速穿过密集的公共空间，而无法依赖结构化的道路、车道标记或可预测的行人行为。</p>
<p>在这类场景中，了解人员位置及其接下来几秒可能如何移动，对于避免事故至关重要。例如，最近的一项研究通过为在行人密集环境中运行的紧急自动驾驶车辆（EAV）构建完整的碰撞预测流程，探索了这一挑战。</p>
<p>基于 YOLO 的碰撞预测流程如何工作</p>
<p>以下是该方法工作原理的一瞥：</p>
<ul>
<li><strong>使用 YOLO 进行行人检测：</strong> 基于 YOLO 的检测器识别每个摄像头帧中的行人，并为每个可见的人输出边界框。</li>
<li><strong>使用 ByteTrack 进行运动跟踪：</strong> ByteTrack 算法跨帧关联这些检测结果，为每个行人分配一致的 ID，并创建显示他们随时间移动的运动历史。</li>
<li><strong>真实世界位置估计：</strong> 逆透视映射（IPM）将 2D 像素坐标转换为近似的地平面位置，帮助系统理解行人相对于车辆在真实空间中的位置。</li>
<li><strong>使用 cGAN 生成鸟瞰图：</strong> 条件生成对抗网络（cGAN）是一种将一种图像格式转换为另一种的 AI 模型，它创建场景的鸟瞰图表示。这种自上而下的布局更容易解读行人的位置及其周围环境。</li>
<li><strong>使用 LSTM 模型进行轨迹预测：</strong> 利用每个行人过去的位置和移动模式，LSTM 模型预测他们在未来几秒可能移动的方向。</li>
<li><strong>使用碰撞锥进行高效碰撞检测：</strong> 预测的轨迹通过碰撞锥方法进行比较，以判断车辆和任何行人的路径是否可能相交。</li>
<li><strong>通过信号进行碰撞规避：</strong> 如果系统预测到碰撞，它会在最佳时机激活听觉信号（如喇叭或铃声）。时机的选择旨在影响行人行为，给予他们加速、减速或到达安全地带的机会。</li>
</ul>
<p>值得注意的是，开发和部署此类模型并非易事，它涉及复杂的数据处理、模型训练与优化流程。这正是像 Coovally 这样的AI平台能发挥关键作用的地方。<strong>Coovally平台提供了一个集成的机器学习操作（MLOps）环境，能够高效地支持目标检测与跟踪模型的训练、评估和部署全过程。</strong> 对于碰撞预测系统开发而言，这意味着团队可以在同一个平台上，利用其强大的数据处理和自动化模型调优能力，快速迭代和定制专用于车辆、行人、骑行者的高精度追踪模型，从而为后续的轨迹预测打下坚实基础。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1cf02f4ccdab4e47846a7be539b187d2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766554262&amp;x-signature=zdWWjZDuwHh031Rt6EPc7Brduew%3D" alt="Coovally操作动图.gif" loading="lazy"/></p>
<p>Coovally平台不仅提供模型资源，还可以帮助你提供<strong>AI解决方案</strong>，可以扫描二维码，我们来给你提供解决方案！！</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7d564f7c3d9f4c7b833b740e1205a984~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766554262&amp;x-signature=aF3lZPuexIl3oq4djkEjoAt%2BR%2Fo%3D" alt="小助手二维码.png" loading="lazy"/></p>
<p>点击<strong>阅读原文</strong>，即可体验Coovally平台！</p>
<ul>
<li><strong>利用边缘视觉和 YOLO 确保城市行人安全</strong></li>
</ul>
<p>类似地，另一种预防碰撞的方法将目光投向车辆之外，专注于基础设施本身。这种方法不依赖车内的传感器，而是利用安装在人行横道和十字路口的智能摄像头，实时监控行人和车辆的运动方式。这些地点常常充满不可预测性：人们可能突然步入车道，骑行者可能在车流中穿梭，驾驶员未必总会减速，因此及早发现风险至关重要。</p>
<p>一项有趣的研究通过一个名为 NAVIBox 的系统探索了这一想法，这是一种专为在十字路口直接预测车辆-行人风险而设计的边缘视觉设备。该系统使用 YOLOv8 模型检测行人和车辆，并使用轻量级质心跟踪器跨帧跟踪它们。这创建了短暂但可靠的运动历史，然后通过透视变换进行优化，将倾斜的 CCTV 视角转换为更清晰的道路鸟瞰布局。</p>
<p>利用这些优化后的轨迹，NAVIBox 可以估算道路使用者未来几秒可能如何移动，并检查他们的路径是否可能相交（也称为交叉测试）。当系统检测到有风险的互动时，它会立即通过面向驾驶员的显示屏和面向行人的扬声器发送警告——无需依赖远程服务器或网络连接。在实际城市地点的测试表明，NAVIBox 运行速度足以实现真正的实时响应，并能准确识别潜在的碰撞场景，使其成为繁忙城市十字路口的实用安全工具。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2c8c32284bf4403f9adefc527d4c5183~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766554262&amp;x-signature=dKgB%2FzRGYhI%2FXjoAz%2BgJoMHwJ%2Fc%3D" alt="screenshot_2025-12-16_14-17-30.png" loading="lazy"/></p>
<h2 data-id="heading-3"><strong>碰撞检测与预测的优缺点</strong></h2>
<p>以下是使用 AI 驱动的预测性碰撞系统的一些优势：</p>
<ul>
<li><strong>提升态势感知能力：</strong> AI 系统持续绘制环境中物体的移动情况，为理解大规模人群流动、交通行为或机器路径提供了更丰富的视角。</li>
<li><strong>为长期规划提供数据驱动的洞察：</strong> 通过记录检测结果、险情和移动模式，AI 系统提供了分析数据，城市规划者、安全团队和车队运营商可以利用这些数据重新设计十字路口、改进标志或完善运营策略。</li>
<li><strong>性价比高的风险预防：</strong> 通过在风险升级前进行检测，这些系统有助于避免代价高昂的事故、保险索赔或设备维修。</li>
</ul>
<p>尽管有其益处，无碰撞系统也面临一些局限。以下是几个需要考虑的挑战：</p>
<ul>
<li><strong>传感器和摄像头布置的限制：</strong> 位置不佳或角度不对的摄像头可能会扭曲物体大小或距离，使得深度估计和轨迹预测的可靠性降低。</li>
<li><strong>遮挡问题：</strong> 物体可能被其他物体部分或完全遮挡。这使得物体跟踪变得困难，因为模型失去了视觉连续性。</li>
<li><strong>环境条件影响：</strong> 光线不足、强光、雨、雾或摄像头质量差，都会降低模型清晰观察场景的能力，从而影响准确性。</li>
</ul>
<h2 data-id="heading-4"><strong>总结</strong></h2>
<p>碰撞预测结合了两项强大的能力：计算机视觉（让系统理解环境中正在发生什么）和轨迹预测（帮助它们预判接下来可能发生什么）。</p>
<p>通过结合这些优势，机器可以实时检测移动物体，并预测这些物体在接下来几秒内可能如何互动。随着计算机视觉和预测技术的不断发展，碰撞预测很可能将成为构建更安全、更可靠、更具可扩展性的自主系统的关键。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[3分钟Solidity: 5.2 发送以太币（传输、发送、调用）]]></title>    <link>https://juejin.cn/post/7584377629706010659</link>    <guid>https://juejin.cn/post/7584377629706010659</guid>    <pubDate>2025-12-17T03:52:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584377629706010659" data-draft-id="7584286241488371752" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="3分钟Solidity: 5.2 发送以太币（传输、发送、调用）"/> <meta itemprop="keywords" content="Solidity,web3,区块链"/> <meta itemprop="datePublished" content="2025-12-17T03:52:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Rockbean"/> <meta itemprop="url" content="https://juejin.cn/user/4054654615823560"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            3分钟Solidity: 5.2 发送以太币（传输、发送、调用）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4054654615823560/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Rockbean
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:52:22.000Z" title="Wed Dec 17 2025 03:52:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>如需获取本内容的最新版本，请参见 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cyfrin.io%2Fglossary%2Fsending-ether-transfer-send-call-solidity-code-example" target="_blank" title="https://www.cyfrin.io/glossary/sending-ether-transfer-send-call-solidity-code-example" ref="nofollow noopener noreferrer">Cyfrin.io 上的“发送以太币（传输、发送、调用）（代码示例）”</a></p>
<h3 data-id="heading-0">如何发送以太币？</h3>
<p>您可以通过以下方式向其他合约发送以太币：</p>
<ul>
<li><code>transfer</code>（2300 gas，抛出错误）</li>
<li><code>send</code>（2300 gas，返回布尔值）</li>
<li><code>call</code>（转发所有 gas 或设置 gas，返回布尔值）</li>
</ul>
<h3 data-id="heading-1">如何接收以太币？</h3>
<p>一个接收以太币的合约必须至少包含以下函数之一：</p>
<ul>
<li><code>receive() external payable</code></li>
<li><code>fallback() external payable</code></li>
</ul>
<p>如果 <code>msg.data</code>为空，则会调用 <code>receive()</code>，否则会调用 <code>fallback()</code>。</p>
<h3 data-id="heading-2">你应该使用哪种方法？</h3>
<p>2019年12月之后，推荐使用结合了重入防护的<code>call</code>方法。</p>
<p>防范重入攻击的方法包括：</p>
<ul>
<li>在调用其他合约之前完成所有状态变更</li>
<li>使用重入防护修饰器</li>
</ul>
<pre><code class="hljs language-solidity" lang="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

contract ReceiveEther {
    /*
    调用的函数是fallback()还是receive()？

           send Ether
               |
         msg.data is empty?
              / \
            yes  no
            /     \
    receive() exists?  fallback()
         /   \
        yes   no
        /      \
    receive()   fallback()
    */

    // receive函数。msg.data必须为空。
    receive() external payable {}

    // 当msg.data不为空时，将调用fallback函数
    fallback() external payable {}

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}

contract SendEther {
    function sendViaTransfer(address payable _to) public payable {
        // 此函数不再推荐用于发送以太币。
        _to.transfer(msg.value);
    }

    function sendViaSend(address payable _to) public payable {
        // Send返回一个布尔值，表示成功或失败。.
        // 不建议使用此函数发送以太币。
        bool sent = _to.send(msg.value);
        require(sent, "发送以太币失败");
    }

    function sendViaCall(address payable _to) public payable {
        // Call 返回一个布尔值，表示成功或失败。
        // 这是目前推荐使用的方法。
        (bool sent, bytes memory data) = _to.call{value: msg.value}("");
        require(sent, "发送以太币失败");
    }
}

</code></pre>
<p>Remix Lite <a href="https://link.juejin.cn?target=https%3A%2F%2Fremix.byteatatime.dev%2F%3F%23code%3DLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVApwcmFnbWEgc29saWRpdHkgXjAuOC4yNjsKCmNvbnRyYWN0IFJlY2VpdmVFdGhlciB7CiAgICAvKgogICAgV2hpY2ggZnVuY3Rpb24gaXMgY2FsbGVkLCBmYWxsYmFjaygpIG9yIHJlY2VpdmUoKT8KCiAgICAgICAgICAgc2VuZCBFdGhlcgogICAgICAgICAgICAgICB8CiAgICAgICAgIG1zZy5kYXRhIGlzIGVtcHR5PwogICAgICAgICAgICAgIC8gXAogICAgICAgICAgICB5ZXMgIG5vCiAgICAgICAgICAgIC8gICAgIFwKICAgIHJlY2VpdmUoKSBleGlzdHM%2FICBmYWxsYmFjaygpCiAgICAgICAgIC8gICBcCiAgICAgICAgeWVzICAgbm8KICAgICAgICAvICAgICAgXAogICAgcmVjZWl2ZSgpICAgZmFsbGJhY2soKQogICAgKi8KCiAgICAvLyBGdW5jdGlvbiB0byByZWNlaXZlIEV0aGVyLiBtc2cuZGF0YSBtdXN0IGJlIGVtcHR5CiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7fQoKICAgIC8vIEZhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIG1zZy5kYXRhIGlzIG5vdCBlbXB0eQogICAgZmFsbGJhY2soKSBleHRlcm5hbCBwYXlhYmxlIHt9CgogICAgZnVuY3Rpb24gZ2V0QmFsYW5jZSgpIHB1YmxpYyB2aWV3IHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gYWRkcmVzcyh0aGlzKS5iYWxhbmNlOwogICAgfQp9Cgpjb250cmFjdCBTZW5kRXRoZXIgewogICAgZnVuY3Rpb24gc2VuZFZpYVRyYW5zZmVyKGFkZHJlc3MgcGF5YWJsZSBfdG8pIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vIGxvbmdlciByZWNvbW1lbmRlZCBmb3Igc2VuZGluZyBFdGhlci4KICAgICAgICBfdG8udHJhbnNmZXIobXNnLnZhbHVlKTsKICAgIH0KCiAgICBmdW5jdGlvbiBzZW5kVmlhU2VuZChhZGRyZXNzIHBheWFibGUgX3RvKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8gU2VuZCByZXR1cm5zIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3IgZmFpbHVyZS4KICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWNvbW1lbmRlZCBmb3Igc2VuZGluZyBFdGhlci4KICAgICAgICBib29sIHNlbnQgPSBfdG8uc2VuZChtc2cudmFsdWUpOwogICAgICAgIHJlcXVpcmUoc2VudCwgIkZhaWxlZCB0byBzZW5kIEV0aGVyIik7CiAgICB9CgogICAgZnVuY3Rpb24gc2VuZFZpYUNhbGwoYWRkcmVzcyBwYXlhYmxlIF90bykgcHVibGljIHBheWFibGUgewogICAgICAgIC8vIENhbGwgcmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBzdWNjZXNzIG9yIGZhaWx1cmUuCiAgICAgICAgLy8gVGhpcyBpcyB0aGUgY3VycmVudCByZWNvbW1lbmRlZCBtZXRob2QgdG8gdXNlLgogICAgICAgIChib29sIHNlbnQsIGJ5dGVzIG1lbW9yeSBkYXRhKSA9IF90by5jYWxse3ZhbHVlOiBtc2cudmFsdWV9KCIiKTsKICAgICAgICByZXF1aXJlKHNlbnQsICJGYWlsZWQgdG8gc2VuZCBFdGhlciIpOwogICAgfQp9Cg%3D%3D" target="_blank" title="https://remix.byteatatime.dev/?#code=Ly8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVApwcmFnbWEgc29saWRpdHkgXjAuOC4yNjsKCmNvbnRyYWN0IFJlY2VpdmVFdGhlciB7CiAgICAvKgogICAgV2hpY2ggZnVuY3Rpb24gaXMgY2FsbGVkLCBmYWxsYmFjaygpIG9yIHJlY2VpdmUoKT8KCiAgICAgICAgICAgc2VuZCBFdGhlcgogICAgICAgICAgICAgICB8CiAgICAgICAgIG1zZy5kYXRhIGlzIGVtcHR5PwogICAgICAgICAgICAgIC8gXAogICAgICAgICAgICB5ZXMgIG5vCiAgICAgICAgICAgIC8gICAgIFwKICAgIHJlY2VpdmUoKSBleGlzdHM/ICBmYWxsYmFjaygpCiAgICAgICAgIC8gICBcCiAgICAgICAgeWVzICAgbm8KICAgICAgICAvICAgICAgXAogICAgcmVjZWl2ZSgpICAgZmFsbGJhY2soKQogICAgKi8KCiAgICAvLyBGdW5jdGlvbiB0byByZWNlaXZlIEV0aGVyLiBtc2cuZGF0YSBtdXN0IGJlIGVtcHR5CiAgICByZWNlaXZlKCkgZXh0ZXJuYWwgcGF5YWJsZSB7fQoKICAgIC8vIEZhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIG1zZy5kYXRhIGlzIG5vdCBlbXB0eQogICAgZmFsbGJhY2soKSBleHRlcm5hbCBwYXlhYmxlIHt9CgogICAgZnVuY3Rpb24gZ2V0QmFsYW5jZSgpIHB1YmxpYyB2aWV3IHJldHVybnMgKHVpbnQyNTYpIHsKICAgICAgICByZXR1cm4gYWRkcmVzcyh0aGlzKS5iYWxhbmNlOwogICAgfQp9Cgpjb250cmFjdCBTZW5kRXRoZXIgewogICAgZnVuY3Rpb24gc2VuZFZpYVRyYW5zZmVyKGFkZHJlc3MgcGF5YWJsZSBfdG8pIHB1YmxpYyBwYXlhYmxlIHsKICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vIGxvbmdlciByZWNvbW1lbmRlZCBmb3Igc2VuZGluZyBFdGhlci4KICAgICAgICBfdG8udHJhbnNmZXIobXNnLnZhbHVlKTsKICAgIH0KCiAgICBmdW5jdGlvbiBzZW5kVmlhU2VuZChhZGRyZXNzIHBheWFibGUgX3RvKSBwdWJsaWMgcGF5YWJsZSB7CiAgICAgICAgLy8gU2VuZCByZXR1cm5zIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHN1Y2Nlc3Mgb3IgZmFpbHVyZS4KICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWNvbW1lbmRlZCBmb3Igc2VuZGluZyBFdGhlci4KICAgICAgICBib29sIHNlbnQgPSBfdG8uc2VuZChtc2cudmFsdWUpOwogICAgICAgIHJlcXVpcmUoc2VudCwgIkZhaWxlZCB0byBzZW5kIEV0aGVyIik7CiAgICB9CgogICAgZnVuY3Rpb24gc2VuZFZpYUNhbGwoYWRkcmVzcyBwYXlhYmxlIF90bykgcHVibGljIHBheWFibGUgewogICAgICAgIC8vIENhbGwgcmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBzdWNjZXNzIG9yIGZhaWx1cmUuCiAgICAgICAgLy8gVGhpcyBpcyB0aGUgY3VycmVudCByZWNvbW1lbmRlZCBtZXRob2QgdG8gdXNlLgogICAgICAgIChib29sIHNlbnQsIGJ5dGVzIG1lbW9yeSBkYXRhKSA9IF90by5jYWxse3ZhbHVlOiBtc2cudmFsdWV9KCIiKTsKICAgICAgICByZXF1aXJlKHNlbnQsICJGYWlsZWQgdG8gc2VuZCBFdGhlciIpOwogICAgfQp9Cg==" ref="nofollow noopener noreferrer">尝试一下</a></p>
<h2 data-id="heading-3"><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/47a1ea87b9994cd3a498091640cc8d29~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgUm9ja2JlYW4=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548342&amp;x-signature=JHY9lqjWuT08BfMCVoPzok%2B3V3c%3D" alt="solidity-sending_ether" loading="lazy"/></h2>
<p>END</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Elastic Search 安装使用]]></title>    <link>https://juejin.cn/post/7584662928308633610</link>    <guid>https://juejin.cn/post/7584662928308633610</guid>    <pubDate>2025-12-17T03:58:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584662928308633610" data-draft-id="7584365584747446299" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Elastic Search 安装使用"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-17T03:58:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="酒酿萝卜皮"/> <meta itemprop="url" content="https://juejin.cn/user/1080158100920361"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Elastic Search 安装使用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1080158100920361/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    酒酿萝卜皮
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:58:00.000Z" title="Wed Dec 17 2025 03:58:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">1.安装</h3>
<p>官方下载地址:<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fcn%2Fdownloads%2Felasticsearch" target="_blank" title="https://www.elastic.co/cn/downloads/elasticsearch" ref="nofollow noopener noreferrer">www.elastic.co/cn/download…</a></p>
<p>解压文件，然后创建一个es 用户,给用户文件权限</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">chown</span> -R es /opt/elasticsearch-9.2.2
</code></pre>
<p>修改配置文件，添加ES_JAVA_HOME</p>
<pre><code class="hljs language-bash" lang="bash">vim /etc/profile

<span class="hljs-built_in">export</span> ES_JAVA_HOME=<span class="hljs-string">"/opt/elasticsearch-9.2.2/jdk"</span>

souce /etc/profile
</code></pre>
<p>切换用户</p>
<pre><code class="hljs">su es
</code></pre>
<p>启动es</p>
<pre><code class="hljs language-bash" lang="bash">./bin/elasticsearch -d

//设置密码 用户默认是：elastic

/opt/elasticsearch-9.2.2/bin/elasticsearch-reset-password -u elastic -i
</code></pre>
<p>浏览器可以使用插件 Multi Elasticsearch Heads，添加地址，测试连接</p>
<h4 data-id="heading-1">2.使用</h4>
<h4 data-id="heading-2">2.1 创建索引</h4>
<p>text和keyword的区别</p>








































<table><thead><tr><th/><th/><th/></tr></thead><tbody><tr><td/><td>text</td><td>keyword</td></tr><tr><td>分词</td><td>是</td><td>否</td></tr><tr><td>存储</td><td>多个token</td><td>字符串</td></tr><tr><td>模糊搜索</td><td>支持</td><td>不支持</td></tr><tr><td>排序</td><td>不支持</td><td>支持</td></tr><tr><td>聚合</td><td>不支持</td><td>支持</td></tr></tbody></table>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">CreateIndexRequest</span> <span class="hljs-selector-tag">request</span> = <span class="hljs-selector-tag">CreateIndexRequest</span><span class="hljs-selector-class">.of</span>(c -&gt; c .<span class="hljs-built_in">index</span>(<span class="hljs-string">"users"</span>) <span class="hljs-comment">// 索引名称 </span>
    .<span class="hljs-built_in">mappings</span>(m -&gt; m .<span class="hljs-built_in">properties</span>(<span class="hljs-string">"name"</span>, p -&gt; p.<span class="hljs-built_in">text</span>(t -&gt; t)) <span class="hljs-comment">//text类型 </span>
    .<span class="hljs-built_in">properties</span>(<span class="hljs-string">"age"</span>, p -&gt; p.<span class="hljs-built_in">integer</span>(i -&gt; i)) <span class="hljs-comment">//数字类型 </span>
    .<span class="hljs-built_in">properties</span>(<span class="hljs-string">"email"</span>, p -&gt; p.<span class="hljs-built_in">keyword</span>(k -&gt; k)) <span class="hljs-comment">// keyword类型 ) ); </span>
CreateIndexResponse response = client.<span class="hljs-built_in">indices</span>().<span class="hljs-built_in">create</span>(request);
</code></pre>
<h4 data-id="heading-3">2.2 增加</h4>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">IndexResponse</span> <span class="hljs-selector-tag">response</span> = <span class="hljs-selector-tag">client</span><span class="hljs-selector-class">.index</span>(i -&gt; i .<span class="hljs-built_in">index</span>(<span class="hljs-string">"users"</span>) .<span class="hljs-built_in">id</span>(<span class="hljs-string">"1"</span>) 
    .<span class="hljs-built_in">document</span>(Map.<span class="hljs-built_in">of</span>( <span class="hljs-string">"name"</span>, <span class="hljs-string">"张三"</span>, <span class="hljs-string">"age"</span>, <span class="hljs-number">18</span>, <span class="hljs-string">"email"</span>, <span class="hljs-string">"zhangsan@xxx.com"</span> )) );
</code></pre>
<h4 data-id="heading-4">2.3 更新</h4>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">UpdateResponse</span>&lt;<span class="hljs-selector-tag">Map</span>&gt; <span class="hljs-selector-tag">updateResponse</span> = <span class="hljs-selector-tag">client</span><span class="hljs-selector-class">.update</span>(u -&gt; u 
    .<span class="hljs-built_in">index</span>(<span class="hljs-string">"users"</span>) 
    .<span class="hljs-built_in">id</span>(<span class="hljs-string">"1"</span>) .<span class="hljs-built_in">doc</span>(Map.<span class="hljs-built_in">of</span>(<span class="hljs-string">"age"</span>, <span class="hljs-number">29</span>)), Map.class );
</code></pre>
<h4 data-id="heading-5">2.4 删除</h4>
<pre><code class="hljs language-ini" lang="ini">DeleteResponse <span class="hljs-attr">response</span> = client.delete(d -&gt; d .index(<span class="hljs-string">"users"</span>) .id(<span class="hljs-string">"1"</span>) )<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-6">2.5 查询</h4>
<h5 data-id="heading-7">条件查询</h5>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">SearchResponse</span>&lt;<span class="hljs-selector-tag">Map</span>&gt; <span class="hljs-selector-tag">search</span> = <span class="hljs-selector-tag">client</span><span class="hljs-selector-class">.search</span>(s -&gt; s 
    .<span class="hljs-built_in">index</span>(<span class="hljs-string">"users"</span>) 
    .<span class="hljs-built_in">query</span>(q -&gt; q 
    .<span class="hljs-built_in">match</span>(m -&gt; m .<span class="hljs-built_in">field</span>(<span class="hljs-string">"name"</span>) .<span class="hljs-built_in">query</span>(<span class="hljs-string">"张三"</span>) ) ), Map.class );
</code></pre>
<h5 data-id="heading-8">range 范围查询</h5>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">SearchResponse</span>&lt;<span class="hljs-selector-tag">Map</span>&gt; <span class="hljs-selector-tag">rangeSearch</span> = <span class="hljs-selector-tag">client</span><span class="hljs-selector-class">.search</span>(s -&gt; s 
    .<span class="hljs-built_in">index</span>(<span class="hljs-string">"users"</span>) 
    .<span class="hljs-built_in">from</span>(<span class="hljs-number">0</span>).<span class="hljs-built_in">size</span>(<span class="hljs-number">10</span>) 
    .<span class="hljs-built_in">query</span>(q -&gt; q 
    .<span class="hljs-built_in">range</span>(r -&gt; r .<span class="hljs-built_in">field</span>(<span class="hljs-string">"age"</span>) .<span class="hljs-built_in">gte</span>(JsonData.<span class="hljs-built_in">of</span>(<span class="hljs-number">20</span>)) .<span class="hljs-built_in">lte</span>(JsonData.<span class="hljs-built_in">of</span>(<span class="hljs-number">30</span>)) ) ),
    Map.class );
</code></pre>
<h5 data-id="heading-9">bool 多条件查询</h5>
<p>must ==&gt; and</p>
<p>must_not ==&gt; 都不满足</p>
<p>should ==&gt; or</p>
<p>filter ==&gt; 满足条件</p>
<p>match ==&gt; 全文索引</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">SearchResponse</span>&lt;<span class="hljs-selector-tag">Map</span>&gt; <span class="hljs-selector-tag">boolSearch</span> = <span class="hljs-selector-tag">client</span><span class="hljs-selector-class">.search</span>(s -&gt; s 
    .<span class="hljs-built_in">index</span>(<span class="hljs-string">"users"</span>) 
    .<span class="hljs-built_in">query</span>(q -&gt; q 
    .<span class="hljs-built_in">bool</span>(b -&gt; b 
    .<span class="hljs-built_in">must</span>(m -&gt; m.<span class="hljs-built_in">match</span>(ma -&gt; ma.<span class="hljs-built_in">field</span>(<span class="hljs-string">"name"</span>).<span class="hljs-built_in">query</span>(<span class="hljs-string">"张三"</span>))) 
    .<span class="hljs-built_in">filter</span>(f -&gt; f.<span class="hljs-built_in">range</span>(r -&gt; r.<span class="hljs-built_in">field</span>(<span class="hljs-string">"age"</span>).<span class="hljs-built_in">gte</span>(<span class="hljs-number">20</span>))) ) ), Map.class );
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一站式了解跨域问题]]></title>    <link>https://juejin.cn/post/7584662928308731914</link>    <guid>https://juejin.cn/post/7584662928308731914</guid>    <pubDate>2025-12-17T04:15:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584662928308731914" data-draft-id="7582872365523124262" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一站式了解跨域问题"/> <meta itemprop="keywords" content="网络协议,架构,面试"/> <meta itemprop="datePublished" content="2025-12-17T04:15:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="想用offer打牌"/> <meta itemprop="url" content="https://juejin.cn/user/578781641968972"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一站式了解跨域问题
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/578781641968972/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    想用offer打牌
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T04:15:28.000Z" title="Wed Dec 17 2025 04:15:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.8;font-weight:400;font-size:16px;word-spacing:2px;letter-spacing:2px;overflow-x:hidden;color:#3e3e3e;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{padding-bottom:12px;font-size:24px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:1.2em;border-bottom:2px solid #ef7060;word-spacing:0!important;letter-spacing:0!important;font-size:inherit;line-height:inherit;display:block;font-weight:400;background:#ef7060;color:#fff;padding:10px;border-top-right-radius:3px;border-top-left-radius:3px;margin-right:3px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="monokai">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#272822;color:#ddd}.hljs-keyword,.hljs-literal,.hljs-name,.hljs-selector-tag,.hljs-strong,.hljs-tag{color:#f92672}.hljs-code{color:#66d9ef}.hljs-class .hljs-title{color:#fff}.hljs-attribute,.hljs-link,.hljs-regexp,.hljs-symbol{color:#bf79db}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-emphasis,.hljs-section,.hljs-selector-attr,.hljs-selector-pseudo,.hljs-string,.hljs-subst,.hljs-template-tag,.hljs-template-variable,.hljs-title,.hljs-type,.hljs-variable{color:#a6e22e}.hljs-comment,.hljs-deletion,.hljs-meta,.hljs-quote{color:#75715e}.hljs-doctag,.hljs-keyword,.hljs-literal,.hljs-section,.hljs-selector-id,.hljs-selector-tag,.hljs-title,.hljs-type{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<blockquote>
<p>在平时的后台开发中，我们会经常遇到跨域问题，那么跨域问题到底是什么，怎么去解决跨域问题呢？今天我们就一起探讨一下。</p>
</blockquote>
<h2 data-id="heading-1">同源策略</h2>
<p>跨域问题本质上是由于浏览器的<strong>同源策略</strong>（Same-Origin Policy）引起的。</p>
<p>同源策略是浏览器的一个<strong>安全限制</strong>。它规定，一个源（Origin）的文档或脚本只能与同源的资源进行交互。</p>
<ul>
<li><strong>“源”</strong> 由三个部分组成：<strong>协议（Protocol）</strong> 、<strong>主机（Host/Domain）</strong> 和 <strong>端口号（Port）</strong> 。</li>
<li>如果请求的 URL 与当前页面的 URL 相比，<strong>任一</strong>部分不同，就被认为是<strong>跨源</strong>。</li>
</ul>



































<table><thead><tr><th><strong>当前页面 URL</strong></th><th><strong>目标 URL</strong></th><th><strong>是否同源？</strong></th><th><strong>跨源原因</strong></th></tr></thead><tbody><tr><td><code>http://a.com:8080/index.html</code></td><td><code>http://a.com:8080/data.json</code></td><td><strong>是</strong></td><td>(全部相同)</td></tr><tr><td><code>http://a.com:8080/</code></td><td><code>**https**://a.com:8080/</code></td><td><strong>否</strong></td><td>协议不同 (<code>http</code> vs <code>https</code>)</td></tr><tr><td><code>http://a.com:8080/</code></td><td><code>http://**b.com**:8080/</code></td><td><strong>否</strong></td><td>主机不同 (<code>a.com</code> vs <code>b.com</code>)</td></tr><tr><td><code>http://a.com:8080/</code></td><td><code>http://a.com:**9090**/**</code></td><td><strong>否</strong></td><td>端口不同 (<code>8080</code> vs <code>9090</code>)</td></tr></tbody></table>
<p>同源策略的目的是保护用户安全和隐私，防止恶意网站通过浏览器脚本访问其他网站的敏感数据。</p>
<h2 data-id="heading-2">跨域问题如何产生？</h2>
<p>当浏览器中的前端代码（如使用 <code>XMLHttpRequest</code> 或 <code>Fetch</code> API）尝试向一个<strong>不同源</strong>的服务器发起 HTTP 请求时，浏览器会拦截服务器返回的数据，导致请求失败（但在网络层面上，请求实际上已经发送到服务器并收到了响应）。</p>
<p>这就是我们在开发中常说的<strong>跨域报错</strong>，通常你会看到类似 <code>No 'Access-Control-Allow-Origin' header is present on the requested resource</code> 的错误信息。</p>
<h2 data-id="heading-3">解决方案一：CORS（跨源资源共享）</h2>
<p>在本地开发测试阶段可以通过配置cors来解决跨域问题。</p>
<p>跨源资源共享（Cross-Origin Resource Sharing, <strong>CORS</strong>）是一种允许浏览器放宽同源策略限制的机制。它通过在 <strong>服务器端</strong> 设置特定的 <strong>HTTP 响应头</strong>，来告知浏览器该服务器允许哪些源访问其资源。</p>
<p>CORS 主要分为两种请求模式：</p>
<h3 data-id="heading-4">1. 简单请求（Simple Requests）</h3>
<p>如果请求同时满足以下所有条件，则被认为是简单请求：</p>
<ul>
<li>
<p><strong>方法：</strong> 只能是 <code>GET</code>、<code>POST</code>、<code>HEAD</code> 之一。</p>
</li>
<li>
<p><strong>请求头：</strong> 只能包含少数几个安全的请求头（如 <code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Content-Type</code> 等），且 <code>Content-Type</code> 只能是以下三种之一：</p>
<ul>
<li><code>application/x-www-form-urlencoded</code></li>
<li><code>multipart/form-data</code></li>
<li><code>text/plain</code></li>
</ul>
</li>
</ul>
<p><strong>工作流程：</strong></p>
<ol>
<li>浏览器直接发送请求，并在请求头中带上 <code>Origin</code> 字段，表明自己的源。</li>
<li>服务器收到请求后，如果允许跨源访问，则在响应头中加入 <code>Access-Control-Allow-Origin</code> 字段，指定允许的源（例如：<code>Access-Control-Allow-Origin: http://client.com</code> 或 <code>Access-Control-Allow-Origin: *</code>）。</li>
<li>浏览器检查响应头，如果发现 <code>Access-Control-Allow-Origin</code> 允许当前源，则将数据交给前端代码；否则，抛出跨域错误。</li>
</ol>
<h3 data-id="heading-5">2. 预检请求（Preflighted Requests）</h3>
<p>对于<strong>非简单请求</strong>（例如：使用了 <code>PUT</code>、<code>DELETE</code> 方法，或者设置了自定义请求头），浏览器会先发送一个使用 <strong><code>OPTIONS</code></strong> 方法的<strong>预检请求</strong>，以确定服务器是否安全。</p>
<p><strong>工作流程：</strong></p>
<ol>
<li>
<p><strong>浏览器发送 <code>OPTIONS</code> 预检请求：</strong> 请求头包含：</p>
<ul>
<li><code>Origin</code>：当前源。</li>
<li><code>Access-Control-Request-Method</code>：实际请求将使用的方法（如 <code>POST</code>）。</li>
<li><code>Access-Control-Request-Headers</code>：实际请求将携带的自定义请求头（如 <code>X-Custom-Header</code>）。</li>
</ul>
</li>
<li>
<p><strong>服务器处理预检请求：</strong> 服务器检查这些请求头，如果允许，则在预检请求的响应头中返回：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code>：允许的源。</li>
<li><code>Access-Control-Allow-Methods</code>：允许的方法。</li>
<li><code>Access-Control-Allow-Headers</code>：允许的自定义请求头。</li>
<li><code>Access-Control-Max-Age</code>：预检结果的缓存时间（秒）。</li>
</ul>
</li>
<li>
<p><strong>浏览器检查预检结果：</strong> 如果预检通过，浏览器才会发送<strong>实际的 HTTP 请求</strong>（GET/POST/PUT/DELETE 等）。</p>
</li>
<li>
<p><strong>服务器处理实际请求</strong> 并返回数据（响应头中通常仍会包含 <code>Access-Control-Allow-Origin</code>）。</p>
</li>
</ol>
<h3 data-id="heading-6">代码示例</h3>
<h4 data-id="heading-7">Java (Spring Boot 示例)</h4>
<p>在 Spring Boot 中，你可以通过配置 <code>WebMvcConfigurer</code> 或在 Controller 上使用 <code>@CrossOrigin</code> 注解来解决：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 方法一：全局配置 (推荐)</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CorsConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> {
        registry.addMapping(<span class="hljs-string">"/**"</span>) <span class="hljs-comment">// 匹配所有路径</span>
                .allowedOrigins(<span class="hljs-string">"http://your-frontend-domain.com"</span>) <span class="hljs-comment">// 允许的源，可以设为 "*" 允许所有（不推荐用于生产）</span>
                .allowedMethods(<span class="hljs-string">"GET"</span>, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"PUT"</span>, <span class="hljs-string">"DELETE"</span>, <span class="hljs-string">"OPTIONS"</span>) <span class="hljs-comment">// 允许的方法</span>
                .allowedHeaders(<span class="hljs-string">"*"</span>) <span class="hljs-comment">// 允许所有请求头</span>
                .allowCredentials(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 是否允许携带 Cookie</span>
                .maxAge(<span class="hljs-number">3600</span>); <span class="hljs-comment">// 预检请求的缓存时间</span>
    }
}
</code></pre>
<h4 data-id="heading-8">Go (Gin 框架示例)</h4>
<p>如果你使用 Gin 框架，可以借助第三方 CORS 中间件，例如 <code>github.com/gin-contrib/cors</code>：</p>
<pre><code class="hljs language-go" lang="go"><span class="hljs-comment">// Go 示例 (使用 Gin 框架和 gin-contrib/cors 中间件)</span>
<span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"time"</span>
	<span class="hljs-string">"github.com/gin-contrib/cors"</span>
	<span class="hljs-string">"github.com/gin-gonic/gin"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	r := gin.Default()

	<span class="hljs-comment">// 配置 CORS 中间件</span>
	r.Use(cors.New(cors.Config{
		AllowOrigins:     []<span class="hljs-type">string</span>{<span class="hljs-string">"http://your-frontend-domain.com"</span>}, <span class="hljs-comment">// 允许的源</span>
		AllowMethods:     []<span class="hljs-type">string</span>{<span class="hljs-string">"GET"</span>, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"PUT"</span>, <span class="hljs-string">"DELETE"</span>, <span class="hljs-string">"OPTIONS"</span>},
		AllowHeaders:     []<span class="hljs-type">string</span>{<span class="hljs-string">"Origin"</span>, <span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"Authorization"</span>}, <span class="hljs-comment">// 允许的请求头</span>
		ExposeHeaders:    []<span class="hljs-type">string</span>{<span class="hljs-string">"Content-Length"</span>}, <span class="hljs-comment">// 允许前端访问的响应头</span>
		AllowCredentials: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 允许携带 Cookie</span>
		MaxAge:           <span class="hljs-number">12</span> * time.Hour,
	}))

	r.GET(<span class="hljs-string">"/ping"</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> {
		c.JSON(<span class="hljs-number">200</span>, gin.H{
			<span class="hljs-string">"message"</span>: <span class="hljs-string">"pong"</span>,
		})
	})

	r.Run()
}
</code></pre>
<h2 data-id="heading-9">解决方案二：反向代理</h2>
<p>这是生产环境中<strong>最常用且推荐</strong>的方案。前端请求同源的代理服务器，由代理服务器转发请求给目标服务器。因为请求发生在服务器之间，不受浏览器同源策略限制。</p>
<p>当浏览器向代理服务器（例如 <code>http://api.frontend.com</code>）发送请求时，由于前端页面和代理服务器是<strong>同源</strong>的，浏览器不会触发同源策略限制。代理服务器在收到请求后，再将其转发到后端服务（例如 <code>http://backend-service:8080</code>）。<strong>服务器之间的通信不存在跨域限制</strong></p>
<h3 data-id="heading-10">集中管理与解耦</h3>
<p>将跨域配置、SSL/TLS 证书、负载均衡、限流、缓存等所有非业务性的公共配置，全部集中在反向代理层处理。</p>
<ul>
<li><strong>后端服务解耦：</strong> 后端服务（Java/Go）可以专注于业务逻辑，无需关心这些基础设施配置。</li>
<li><strong>配置统一：</strong> 只需要在 Nginx 或 Gateway 上配置一次，适用于所有后端服务</li>
</ul>
<h3 data-id="heading-11">安全性与架构优势</h3>
<ul>
<li>
<p><strong>隐藏真实服务地址：</strong> 客户端只能看到代理服务器的地址，后端服务的真实 IP 和端口被隐藏，提高了安全性。</p>
</li>
<li>
<p><strong>更细致的访问控制：</strong> 代理层可以更容易地实现基于路径的访问控制和限流</p>
</li>
</ul>
<h3 data-id="heading-12">架构示意图</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e77b6856f8c849bbb0f73445e3b4f062~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5oOz55Sob2ZmZXLmiZPniYw=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766549728&amp;x-signature=x6dAf96LhfO70rWyUUm6YDjL8r8%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-13">总结</h2>
<p>解决跨域问题，在开发测试环境中，为了简单快捷我们可以使用cors。在生产部署环境中，强烈建议使用反向代理。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[SpringBoot集成Spring Statemachine（状态机）实战教程]]></title>    <link>https://juejin.cn/post/7584339190035267624</link>    <guid>https://juejin.cn/post/7584339190035267624</guid>    <pubDate>2025-12-17T05:26:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584339190035267624" data-draft-id="7584339190035251240" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="SpringBoot集成Spring Statemachine（状态机）实战教程"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-17T05:26:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="马卡巴卡"/> <meta itemprop="url" content="https://juejin.cn/user/1892677617451163"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            SpringBoot集成Spring Statemachine（状态机）实战教程
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1892677617451163/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    马卡巴卡
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T05:26:11.000Z" title="Wed Dec 17 2025 05:26:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">背景</h3>
<p>本文将基于借款订单状态流转这个场景来实现。如果使用<code>if-else</code>或者<code>switch</code>语句来处理这些状态，代码会变得非常臃肿且难以维护。而状态机提供了一种更加结构化和可维护的方式来管理这些状态转换。</p>
<p>示例中涉及到：状态机的配置、数据持久化、状态恢复查询、同一事件由同一<code>sourceStatus</code>流转到不同<code>targetStatus</code></p>
<h3 data-id="heading-1">SpringBoot集成状态机</h3>
<p>1、首先，需要添加<code>Spring Statemachine</code>的依赖到Spring Boot项目的pom.xml文件中：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.statemachine<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-statemachine-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>2、定义系统中订单存在的状态</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OrderStatusEnum</span> {

<span class="hljs-comment">// 待审核</span>
APPROVE_PENDING,
<span class="hljs-comment">// 审核中</span>
APPROVE_ING,
<span class="hljs-comment">// 审核失败</span>
APPROVE_FAILED,
<span class="hljs-comment">// 审核成功</span>
APPROVE_SUCCESS;

}
</code></pre>
<p>3、定义系统中触发状态变更的事件</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OrderEvent</span> {
<span class="hljs-comment">// 开始审核</span>
APPROVE_START,
<span class="hljs-comment">// 审核通过</span>
APPROVE_SUCCESS,
<span class="hljs-comment">// 审核失败</span>
APPROVE_FAILED;

}
</code></pre>
<p>4、状态机-状态流转配置</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Configuration</span>
<span class="hljs-keyword">@EnableStateMachine</span>(name = <span class="hljs-string">"OrderStateMachine"</span>)
<span class="hljs-keyword">@Slf</span>4j
publicclass OrderStateMachineConfig extends EnumStateMachineConfigurerAdapter&lt;OrderStatusEnum, OrderEvent&gt; {

<span class="hljs-keyword">@Resource</span>
private OrderMapper orderMapper;


<span class="hljs-comment">/**
 * 配置状态
 *
 * @param states
 * @throws Exception
 */</span>
<span class="hljs-keyword">@Override</span>
public void configure(StateMachineStateConfigurer&lt;OrderStatusEnum, OrderEvent&gt; states) throws Exception {
    states<span class="hljs-selector-class">.withStates</span>()
            <span class="hljs-selector-class">.initial</span>(OrderStatusEnum.LOAN_PENDING) <span class="hljs-comment">// 设置初始状态为[待审核]</span>
            <span class="hljs-selector-class">.states</span>(EnumSet.allOf(OrderStatusEnum.class));
}


<span class="hljs-comment">/**
 * 配置状态转换事件关系
 *
 * @param transitions
 * @throws Exception
 */</span>
<span class="hljs-keyword">@Override</span>
public void configure(StateMachineTransitionConfigurer&lt;OrderStatusEnum, OrderEvent&gt; transitions) throws Exception {
    transitions
           <span class="hljs-comment">//当执行 【开始审核】操作时，将订单状态由待审核 -&gt; 审核中</span>
           <span class="hljs-selector-class">.withExternal</span>()<span class="hljs-selector-class">.source</span>(OrderStatusEnum.APPROVE_PENDING)<span class="hljs-selector-class">.target</span>(OrderStatusEnum.APPROVE_ING)<span class="hljs-selector-class">.event</span>(OrderEvent.APPROVE_START)
            <span class="hljs-selector-class">.and</span>()
            <span class="hljs-comment">//当执行 【审核失败】操作时，将订单状态由审核中 -&gt; 审核失败</span>
            <span class="hljs-selector-class">.withExternal</span>()<span class="hljs-selector-class">.source</span>(OrderStatusEnum.APPROVE_ING)<span class="hljs-selector-class">.target</span>(OrderStatusEnum.APPROVE_FAILED)<span class="hljs-selector-class">.event</span>(OrderEvent.APPROVE_FAILED)
            <span class="hljs-selector-class">.and</span>()
            <span class="hljs-comment">//当执行 【审核成功】操作时，将订单状态由审核中 -&gt; 审核成功</span>
            <span class="hljs-selector-class">.withExternal</span>()<span class="hljs-selector-class">.source</span>(OrderStatusEnum.APPROVE_ING)<span class="hljs-selector-class">.target</span>(OrderStatusEnum.APPROVE_SUCCESS)<span class="hljs-selector-class">.event</span>(OrderEvent.APPROVE_SUCCESS);
}


<span class="hljs-comment">/**
 * 持久化配置
 *
 * @return
 */</span>
<span class="hljs-keyword">@Bean</span>
public DefaultStateMachinePersister persister() {
    returnnew DefaultStateMachinePersister&lt;&gt;(new StateMachinePersist&lt;OrderStatusEnum, OrderEvent, BizOrder&gt;() {
        <span class="hljs-keyword">@Override</span>
        public void write(StateMachineContext&lt;OrderStatusEnum, OrderEvent&gt; context, BizOrder order) throws Exception {
            OrderStatusEnum orderStatus = context<span class="hljs-selector-class">.getState</span>();
            log<span class="hljs-selector-class">.info</span>("订单状态持久化,订单ID：{},目标状态:{}", order.getId(), orderStatus);
            orderMapper<span class="hljs-selector-class">.updateOrderStatus</span>(order.getId(), orderStatus);
        }

        <span class="hljs-keyword">@Override</span>
        public StateMachineContext&lt;OrderStatusEnum, OrderEvent&gt; read(BizOrder order) throws Exception {
            log<span class="hljs-selector-class">.info</span>("恢复订单状态机状态");
            returnnew DefaultStateMachineContext&lt;&gt;(order.getStatus(), null, null, null);
        }

    });
}

}
</code></pre>
<p>5、新建一个变更订单状态的服务</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">BizOrderStatusService</span> {

    <span class="hljs-comment">/**
     *
     * 通用状态变更处理器
     * @param incomingId
     * @param event
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eventHandler</span>(<span class="hljs-params">Long orderId, OrderEvent <span class="hljs-keyword">event</span></span>)</span>;

}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Service</span>
publicclass BizOrderStatusServiceImpl <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BizOrderStatusService</span> {

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> OrderMapper orderMapper;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> StateMachine&lt;OrderStatusEnum, OrderEvent&gt; orderStateMachine;

    <span class="hljs-meta">@Resource</span>
    <span class="hljs-keyword">private</span> StateMachinePersister&lt;OrderStatusEnum, OrderEvent, BizOrder&gt; persister;


<span class="hljs-comment">/**
 * 
 * 
 * <span class="hljs-doctag">@param</span> orderId 订单id
 * <span class="hljs-doctag">@param</span> event   事件类型
 */</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eventHandler</span><span class="hljs-params">(Long orderId, OrderEvent event)</span> {
        <span class="hljs-type">BizOrder</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderMapper.getOrderById(orderId);
        Assert.notNull(order, <span class="hljs-string">"订单不存在"</span>);
        <span class="hljs-comment">// 自定义状态机参数对象(可以在此对象中定义后续需要用到的字段参数，状态配置那里如果需要做业务逻辑判断)</span>
        <span class="hljs-type">StateMachineParam</span> <span class="hljs-variable">param</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StateMachineParam</span>();
        param.setBizOrder(order);
        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> MessageBuilder.withPayload(event).build();
        <span class="hljs-keyword">if</span> (!sendEvent(message, param)) {
            thrownew <span class="hljs-title function_">ApplicationBizException</span><span class="hljs-params">(<span class="hljs-string">"订单状态流转异常"</span>)</span>;
        }
    }


    <span class="hljs-comment">/**
     * 发送订单状态转换事件 这里不要使用synchronized锁方法，效率比较低，
     * 分布式系统优先采用分布式锁，下单锁userId，订单状态流转锁orderId根据业务考虑使用什么。
     *
     * <span class="hljs-doctag">@param</span> message
     * <span class="hljs-doctag">@param</span> param
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendEvent</span><span class="hljs-params">(Message&lt;OrderEvent&gt; message, StateMachineParam param)</span> {
        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">try</span> {
            orderStateMachine.start();
            <span class="hljs-comment">//尝试恢复状态机状态</span>
            persister.restore(orderStateMachine, param.getBizOrder());
            orderStateMachine.getExtendedState().getVariables().put(<span class="hljs-string">"param"</span>, param);
            result = orderStateMachine.sendEvent(message);
            <span class="hljs-comment">//持久化状态机状态</span>
            persister.persist(orderStateMachine, param.getBizOrder());
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
        } <span class="hljs-keyword">finally</span> {
            orderStateMachine.stop();
        }
        <span class="hljs-keyword">return</span> result;
    }

}
</code></pre>
<p>6、调用方法执行订单状态变更，并持久化到数据库</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApproveController</span> {

privatefinal <span class="hljs-title class_">OrderStatusService</span> orderStatusService;


<span class="hljs-comment">/**
 * 前端调用start方法将订单状态改为审核中，并自动持久化到数据库
 * <span class="hljs-doctag">@param</span> orderId  订单id
 * <span class="hljs-doctag">@return</span>
 */</span>
<span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/start"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">Long orderId</span>) {
    orderStatusService.<span class="hljs-title function_">eventHandler</span>(orderId,<span class="hljs-title class_">OrderEvent</span>.<span class="hljs-property">APPROVE_START</span>);
}

<span class="hljs-comment">/**
 * 前端调用start方法将订单状态改为审核成功，并自动持久化到数据库
 * <span class="hljs-doctag">@param</span> orderId  订单id
 * <span class="hljs-doctag">@return</span>
 */</span>
<span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/approveSuccess"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">approveSuccess</span>(<span class="hljs-params">Long orderId</span>) {
    orderStatusService.<span class="hljs-title function_">eventHandler</span>(orderId,<span class="hljs-title class_">OrderEvent</span>.<span class="hljs-property">APPROVE_SUCCESS</span>);
}

<span class="hljs-comment">/**
 * 前端调用start方法将订单状态改为审核失败，并自动持久化到数据库
 * <span class="hljs-doctag">@param</span> orderId  订单id
 * <span class="hljs-doctag">@return</span>
 */</span>
<span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/approveFailed"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">approveFailed</span>(<span class="hljs-params">Long orderId</span>) {
    orderStatusService.<span class="hljs-title function_">eventHandler</span>(orderId,<span class="hljs-title class_">OrderEvent</span>.<span class="hljs-property">APPROVE_FAILED</span>);
}

}
</code></pre>
<p>现在，我们已经配置了状态机并创建了服务来操作它。接下来，你可以在应用的任何部分注入<code>OrderStatusService</code>，并传入相应的事件来改变订单的状态。</p>
<p>7、总结：以上就是状态机的基础用法，一个事件对应一种来源状态(<code>sourceStatus</code>)和目标状态(<code>targetStatus</code>)。在我自己使用到的场景中还包含一个事件需要根据不同的条件将同一来源状态流转到不同的目标状态。这时我们就需要在状态映射配置中增加业务逻辑判断。</p>
<p>8、扩展（新增一个放款事件，该事件会将订单状态由【审核成功】流转到【放款成功】或者【部分放款成功】，具体流流转哪一个状态是由订单的放款金额决定的，如果申请金额和放款金额一致就是【放款成功】，放款金额小于申请金额就是【部分放款成功】）</p>
<p>8.1 我们在订单状态枚举中新增(<code>LOAN_SUCCESS</code>, <code>PARTIALLY_LOAN_SUCCESS</code>)</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 待审核</span>
APPROVE_PENDING,
<span class="hljs-comment">// 审核中</span>
APPROVE_ING,
<span class="hljs-comment">// 审核失败</span>
APPROVE_FAILED,
<span class="hljs-comment">// 审核成功</span>
APPROVE_SUCCESS,
<span class="hljs-comment">// 放款成功</span>
LOAN_SUCCESS,
<span class="hljs-comment">// 部分放款成功</span>
PARTIALLY_LOAN_SUCCESS;
</code></pre>
<p>8.2 我们在事件枚举中新增(LOAN)</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 开始审核</span>
APPROVE_START,
<span class="hljs-comment">// 审核通过</span>
APPROVE_SUCCESS,
<span class="hljs-comment">// 审核失败</span>
APPROVE_FAILED,
<span class="hljs-comment">// 操作放款</span>
LOAN;
</code></pre>
<p>8.3 优化一下上面的【配置状态转换事件关系】，需要在事件后面增加条件判断(通过<code>guard()</code>实现)</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">/**
 * 配置状态转换事件关系
 *
 * @param transitions
 * @throws Exception
 */</span>
<span class="hljs-keyword">@Override</span>
public void configure(StateMachineTransitionConfigurer&lt;OrderStatusEnum, OrderEvent&gt; transitions) throws Exception {
    transitions
           <span class="hljs-comment">//当执行 【开始审核】操作时，将订单状态由待审核 -&gt; 审核中</span>
           <span class="hljs-selector-class">.withExternal</span>()<span class="hljs-selector-class">.source</span>(OrderStatusEnum.APPROVE_PENDING)<span class="hljs-selector-class">.target</span>(OrderStatusEnum.APPROVE_ING)<span class="hljs-selector-class">.event</span>(OrderEvent.APPROVE_START)
            <span class="hljs-selector-class">.and</span>()
            <span class="hljs-comment">//当执行 【审核失败】操作时，将订单状态由审核中 -&gt; 审核失败</span>
            <span class="hljs-selector-class">.withExternal</span>()<span class="hljs-selector-class">.source</span>(OrderStatusEnum.APPROVE_ING)<span class="hljs-selector-class">.target</span>(OrderStatusEnum.APPROVE_FAILED)<span class="hljs-selector-class">.event</span>(OrderEvent.APPROVE_FAILED)
            <span class="hljs-selector-class">.and</span>()
            <span class="hljs-comment">//当执行 【审核成功】操作时，将订单状态由审核中 -&gt; 审核成功</span>
            <span class="hljs-selector-class">.withExternal</span>()<span class="hljs-selector-class">.source</span>(OrderStatusEnum.APPROVE_ING)<span class="hljs-selector-class">.target</span>(OrderStatusEnum.APPROVE_SUCCESS)<span class="hljs-selector-class">.event</span>(OrderEvent.APPROVE_SUCCESS)
            <span class="hljs-selector-class">.and</span>()
            <span class="hljs-comment">//当执行 【放款】操作时，将订单状态由审核成功 -&gt; 放款成功</span>
            <span class="hljs-selector-class">.withExternal</span>()<span class="hljs-selector-class">.source</span>(OrderStatusEnum.APPROVE_SUCCESS)<span class="hljs-selector-class">.target</span>(OrderStatusEnum.LOAN_SUCCESS)<span class="hljs-selector-class">.event</span>(OrderEvent.LOAN)<span class="hljs-selector-class">.guard</span>(guardForLoanSuccessByLoan())
            <span class="hljs-selector-class">.and</span>()
            <span class="hljs-comment">//当执行 【放款】操作时，将订单状态由审核成功 -&gt; 部分放款成功</span>
            <span class="hljs-selector-class">.withExternal</span>()<span class="hljs-selector-class">.source</span>(OrderStatusEnum.APPROVE_SUCCESS)<span class="hljs-selector-class">.target</span>(OrderStatusEnum.PARTIALLY_LOAN_SUCCESS)<span class="hljs-selector-class">.event</span>(OrderEvent.LOAN)<span class="hljs-selector-class">.guard</span>(guardForPartiallyLoanSuccessByLoan());
}



<span class="hljs-comment">/**
 * 订单状态由审核通过 -&gt; 放款成功
 * 触发条件：订单申请金额=放款金额
 *
 * @return
 */</span>
<span class="hljs-keyword">@Bean</span>
public Guard&lt;OrderStatusEnum, OrderEvent&gt; guardForLoanSuccessByLoan() {
    return context -&gt; {
        <span class="hljs-comment">// 从扩展信息中获取参数</span>
        StateMachineParam param = (StateMachineParam) context<span class="hljs-selector-class">.getExtendedState</span>()<span class="hljs-selector-class">.getVariables</span>()<span class="hljs-selector-class">.get</span>("param");
        BizOrder <span class="hljs-attribute">order</span> = param<span class="hljs-selector-class">.getBizOrder</span>();
        <span class="hljs-comment">// 如果申请金额=放款金额 ，返回true，状态机就会流转到调用此方法的目标状态</span>
        if (order.getApplyAmount()<span class="hljs-selector-class">.compareTo</span>(order.getLoanAmlunt) == <span class="hljs-number">0</span>) {
            returntrue;
        }
        returnfalse;
    };
}

<span class="hljs-comment">/**
 * 订单状态由审核通过 -&gt; 部分放款成功
 * 触发条件：订单申请金额&lt;放款金额
 *
 * @return
 */</span>
<span class="hljs-keyword">@Bean</span>
public Guard&lt;OrderStatusEnum, OrderEvent&gt; guardForPartiallyLoanSuccessByLoan() {
    return context -&gt; {
        <span class="hljs-comment">// 从扩展信息中获取参数</span>
        StateMachineParam param = (StateMachineParam) context<span class="hljs-selector-class">.getExtendedState</span>()<span class="hljs-selector-class">.getVariables</span>()<span class="hljs-selector-class">.get</span>("param");
        BizOrder <span class="hljs-attribute">order</span> = param<span class="hljs-selector-class">.getBizOrder</span>();
        <span class="hljs-comment">// 如果申请金额&lt;放款金额 ，返回true，状态机就会流转到调用此方法的目标状态</span>
        if (order.getApplyAmount()<span class="hljs-selector-class">.compareTo</span>(order.getLoanAmlunt) &lt; <span class="hljs-number">0</span>) {
            returntrue;
        }
        returnfalse;
    };
}
</code></pre>
<p>通过以上操作我们就可以实现业务中某些需要根据不同条件流转到不同状态的场景。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【微信小程序】实现引入 Echarts 并实现更新数据]]></title>    <link>https://juejin.cn/post/7584358227611582506</link>    <guid>https://juejin.cn/post/7584358227611582506</guid>    <pubDate>2025-12-17T03:54:59.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584358227611582506" data-draft-id="7584343534968324138" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【微信小程序】实现引入 Echarts 并实现更新数据"/> <meta itemprop="keywords" content="微信小程序"/> <meta itemprop="datePublished" content="2025-12-17T03:54:59.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="夏源"/> <meta itemprop="url" content="https://juejin.cn/user/2914146443330298"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【微信小程序】实现引入 Echarts 并实现更新数据
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2914146443330298/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    夏源
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:54:59.000Z" title="Wed Dec 17 2025 03:54:59 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">0. 先言</h2>
<p>建议多阅读其他相关的文章，毕竟微信小程序的坑蛮多的。</p>
<h2 data-id="heading-1">1. 引入依赖</h2>
<p>首先需要使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fecomfe%2Fecharts-for-weixin" target="_blank" title="https://github.com/ecomfe/echarts-for-weixin" ref="nofollow noopener noreferrer">echarts-for-weixi</a> 项目，下载并解压到目录。</p>
<p>将其项目下的 <code>ec-canvas</code> 目录复制到 <code>components</code> 目录下。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/73ff0d72628842859b067f1d44056c0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSP5rqQ:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548702&amp;x-signature=jh3Rc3sdmN1X5vnB5BBOV%2F7EPVE%3D" alt="image.png" loading="lazy"/></p>
<p>在 <code>pages/demo/demo.json</code> 下引入组件</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"usingComponents"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"ec-canvas"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"../../components/ec-canvas/ec-canvas"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h2 data-id="heading-2">2. 代码部分</h2>
<p>布局文件，没什么多说的。</p>
<pre><code class="hljs language-wxml" lang="wxml">&lt;view class="container"&gt;
  &lt;ec-canvas 
    id="dom-chart" 
    canvas-id="chart" 
    ec="{{ec}}"&gt;&lt;/ec-canvas&gt;
&lt;/view&gt;
</code></pre>
<p>必须配置宽高，不然不显示。</p>
<pre><code class="hljs language-wxss" lang="wxss">.container {
  width: 100vw;
  min-height: 100vh;
}

#dom-chart {
  width: 100%;
  height: 200px;
}
</code></pre>
<p>关键代码部分（包含更新图标数据示例）</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">// 1. 引入依赖</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">'../../components/ec-canvas/echarts'</span>;

<span class="hljs-title class_">Page</span>({
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">ec</span>: {
      <span class="hljs-attr">onInit</span>: <span class="hljs-literal">null</span>
    }
  },

  <span class="hljs-attr">chart</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">chartData</span>: [
    { <span class="hljs-attr">name</span>: <span class="hljs-string">'参数1'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">'参数2'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> }
  ],

  <span class="hljs-title function_">onLoad</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initChart</span>()
  },

  <span class="hljs-comment">// 初始化图表</span>
  <span class="hljs-title function_">initChart</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setData</span>({
      <span class="hljs-string">'ec.onInit'</span>: <span class="hljs-function">(<span class="hljs-params">canvas, width, height, dpr</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> chart = echarts.<span class="hljs-title function_">init</span>(canvas, <span class="hljs-literal">null</span>, {
          width,
          height,
          <span class="hljs-attr">devicePixelRatio</span>: dpr
        })
        canvas.<span class="hljs-title function_">setChart</span>(chart)

        <span class="hljs-variable language_">this</span>.<span class="hljs-property">chart</span> = chart

        chart.<span class="hljs-title function_">setOption</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOption</span>())

        <span class="hljs-comment">// 初始化后再更新一次数据</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addData</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'参数3'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">3</span> })

        <span class="hljs-keyword">return</span> chart
      }
    })
  },

  <span class="hljs-comment">// 统一的 option 生成方法</span>
  <span class="hljs-title function_">getOption</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">tooltip</span>: {
        <span class="hljs-attr">trigger</span>: <span class="hljs-string">'item'</span>
      },
      <span class="hljs-attr">series</span>: [
        {
          <span class="hljs-attr">type</span>: <span class="hljs-string">'pie'</span>,
          <span class="hljs-attr">radius</span>: [<span class="hljs-string">'40%'</span>, <span class="hljs-string">'70%'</span>],
          <span class="hljs-attr">data</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">chartData</span>
        }
      ]
    }
  },

  <span class="hljs-comment">// 添加数据并刷新图表</span>
  <span class="hljs-title function_">addData</span>(<span class="hljs-params">item</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">chart</span>) <span class="hljs-keyword">return</span>

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chartData</span>.<span class="hljs-title function_">push</span>(item)

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chart</span>.<span class="hljs-title function_">setOption</span>({
      <span class="hljs-attr">series</span>: [
        {
          <span class="hljs-attr">data</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">chartData</span>
        }
      ]
    })
  },

  <span class="hljs-title function_">onUnload</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chart</span>?.<span class="hljs-title function_">dispose</span>()
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">chart</span> = <span class="hljs-literal">null</span>
  }
})
</code></pre>
<p>结束。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[react组件(2)---State 与生命周期]]></title>    <link>https://juejin.cn/post/7584370833704173583</link>    <guid>https://juejin.cn/post/7584370833704173583</guid>    <pubDate>2025-12-17T04:15:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584370833704173583" data-draft-id="7584370833704157199" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="react组件(2)---State 与生命周期"/> <meta itemprop="keywords" content="前端,React.js"/> <meta itemprop="datePublished" content="2025-12-17T04:15:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端无涯"/> <meta itemprop="url" content="https://juejin.cn/user/3967483738859639"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            react组件(2)---State 与生命周期
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3967483738859639/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端无涯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T04:15:41.000Z" title="Wed Dec 17 2025 04:15:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<h2 data-id="heading-0">1. 什么是 React State？</h2>
<p>State（状态）是 React 组件中存储可变数据的容器，它决定了组件的行为和渲染输出。与 Props 不同，State 是组件内部管理且可以变化的，而 Props 是从父组件传递过来的只读属性。</p>
<p><strong>State 的核心特征</strong>包括：</p>
<ul>
<li><strong>可变性</strong>：State 可以在组件生命周期内发生变化</li>
<li><strong>响应式</strong>：State 的改变会自动触发组件的重新渲染</li>
<li><strong>局部性</strong>：State 是组件私有的，其他组件无法直接访问</li>
<li><strong>异步性</strong>：setState 操作可能是异步的，React 会批量处理状态更新</li>
</ul>
<p>在 React 中，将组件视为一个<strong>状态机</strong>，通过管理状态的变化来驱动 UI 的更新。</p>
<h3 data-id="heading-1">2. 类组件中的 State</h3>
<h4 data-id="heading-2">2.1 状态的声明与初始化</h4>
<p>在类组件中，State 通常在构造函数中初始化：</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  constructor(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = {
      count: <span class="hljs-number">0</span>,
      isActive: <span class="hljs-literal">false</span>
    };
  }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>现代写法也可以使用类属性语法：</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  state = {
    count: <span class="hljs-number">0</span>,
    isActive: <span class="hljs-literal">false</span>
  };
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-3">2.2 状态的更新</h4>
<p>更新 State 必须使用 <code>setState()</code>方法，<strong>绝对不能直接修改 state</strong>：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 错误做法</span>
<span class="hljs-keyword">this</span>.state.count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 不会触发重新渲染！</span>

<span class="hljs-comment">// 正确做法</span>
<span class="hljs-keyword">this</span>.setState({ count: <span class="hljs-number">1</span> });

<span class="hljs-comment">// 当新状态依赖于旧状态时，使用函数形式</span>
<span class="hljs-keyword">this</span>.setState(prevState =&gt; ({
  count: prevState.count + <span class="hljs-number">1</span>
}));
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-4">3. 函数组件中的 State（useState Hook）</h3>
<p>React 16.8 引入了 Hooks，允许函数组件使用 State。<code>useState</code>是最基础的 Hook。</p>
<h4 data-id="heading-5">3.1 useState 的基本用法</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前计数：{count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;
        点击增加
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-6">3.2 useState 的高级用法</h4>
<p><strong>函数式更新</strong>（当新状态依赖于旧状态时）：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-section">[count, setCount]</span> = useState(0)<span class="hljs-comment">;</span>

// 推荐：使用函数式更新确保基于最新状态
const <span class="hljs-attr">increment</span> = () =&gt; {
  setCount(<span class="hljs-attr">prevCount</span> =&gt; prevCount + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>延迟初始化</strong>（当初始状态需要复杂计算时）：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-section">[state, setState]</span> = useState(() =&gt; {
  const <span class="hljs-attr">expensiveValue</span> = performExpensiveCalculation()<span class="hljs-comment">;</span>
  return expensiveValue<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>对象和数组的状态管理</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">// 对象状态更新
const <span class="hljs-section">[user, setUser]</span> = useState({ name: 'Alice', age: 25 })<span class="hljs-comment">;</span>
setUser(<span class="hljs-attr">prevUser</span> =&gt; ({ ...prevUser, name: <span class="hljs-string">'Bob'</span> }))<span class="hljs-comment">;</span>

// 数组状态更新
const <span class="hljs-section">[items, setItems]</span> = useState(<span class="hljs-section">['apple', 'banana']</span>)<span class="hljs-comment">;</span>
setItems(<span class="hljs-attr">prevItems</span> =&gt; [...prevItems, <span class="hljs-string">'orange'</span>])<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-7">4. React 组件生命周期</h3>





















<table><thead><tr><th>类组件生命周期</th><th>函数组件 useEffect 实现方式</th></tr></thead><tbody><tr><td>componentDidMount</td><td>useEffect (() =&gt; {}, [])（空依赖数组）</td></tr><tr><td>componentDidUpdate</td><td>useEffect (() =&gt; {}, [deps])（依赖项变化时执行）</td></tr><tr><td>componentWillUnmount</td><td>useEffect (() =&gt; { return () =&gt; {} }, [])（返回清理函数）</td></tr></tbody></table>
<h4 data-id="heading-8">4.1 生命周期概述</h4>
<p>React 组件的生命周期可以分为三个主要阶段：</p>
<ul>
<li><strong>挂载阶段</strong>：组件被创建并插入 DOM</li>
<li><strong>更新阶段</strong>：组件的 props 或 state 发生变化时重新渲染</li>
<li><strong>卸载阶段</strong>：组件从 DOM 中移除</li>
</ul>
<h4 data-id="heading-9">4.2 类组件的生命周期方法</h4>
<p><strong>挂载阶段</strong>：</p>
<ul>
<li><code>constructor()</code>：初始化 state 和绑定方法</li>
<li><code>static getDerivedStateFromProps()</code>：在渲染前根据 props 更新 state</li>
<li><code>render()</code>：渲染组件（必需方法）</li>
<li><code>componentDidMount()</code>：组件挂载后执行，适合进行数据获取、订阅等副作用操作</li>
</ul>
<p><strong>更新阶段</strong>：</p>
<ul>
<li><code>static getDerivedStateFromProps()</code>：更新前根据 props 调整 state</li>
<li><code>shouldComponentUpdate()</code>：决定组件是否应该更新（性能优化关键）</li>
<li><code>render()</code>：重新渲染组件</li>
<li><code>getSnapshotBeforeUpdate()</code>：在 DOM 更新前捕获一些信息</li>
<li><code>componentDidUpdate()</code>：组件更新后执行，可以操作 DOM 或执行网络请求</li>
</ul>
<p><strong>卸载阶段</strong>：</p>
<ul>
<li><code>componentWillUnmount()</code>：组件卸载前执行清理操作，如取消定时器、网络请求等</li>
</ul>
<h4 data-id="heading-10">4.3 函数组件中的"生命周期"（useEffect Hook）</h4>
<p><code>useEffect</code>Hook 在函数组件中承担了生命周期方法的职责：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  
  <span class="hljs-comment">// 相当于 componentDidMount + componentDidUpdate</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`点击了 <span class="hljs-subst">${count}</span> 次`</span>;
  });
  
  <span class="hljs-comment">// 只在挂载时执行（类似 componentDidMount）</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件挂载完成'</span>);
  }, []);
  
  <span class="hljs-comment">// 依赖变化时执行（类似 componentDidUpdate）</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`count 变为: <span class="hljs-subst">${count}</span>`</span>);
  }, [count]);
  
  <span class="hljs-comment">// 清理效果（类似 componentWillUnmount）</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">// 一些操作</span>
    }, <span class="hljs-number">1000</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">clearInterval</span>(timer); <span class="hljs-comment">// 清理函数</span>
    };
  }, []);
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你点击了 {count} 次<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;
        点击我
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-11">5. State 设计的最佳实践</h3>
<h4 data-id="heading-12">5.1 State 的最小化原则</h4>
<p>只将真正需要响应式更新的数据放入 State，派生数据可以在渲染时计算：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 不好的做法：将派生数据放入 State</span>
state = {
  items: [],
  totalCount: <span class="hljs-number">0</span>, <span class="hljs-comment">// 可以从 items.length 派生</span>
  filteredItems: [] <span class="hljs-comment">// 可以从 items 过滤得到</span>
};

<span class="hljs-comment">// 好的做法：只存储原始数据</span>
state = {
  items: []
};

<span class="hljs-comment">// 派生数据在 render 中计算</span>
<span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">totalCount</span>()</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.items.length;
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-13">5.2 State 结构的扁平化</h4>
<p>避免嵌套过深的 State 结构：</p>
<pre><code class="hljs language-css" lang="css">// 不好的嵌套结构
state = {
  user: {
    profile: {
      personalInfo: {
        name: <span class="hljs-string">''</span>,
        age: <span class="hljs-number">0</span>
      }
    }
  }
};

// 好的扁平结构
state = {
  userName: <span class="hljs-string">''</span>,
  userAge: <span class="hljs-number">0</span>
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-14">5.3 不可变更新模式</h4>
<p>始终使用不可变的方式更新 State：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 数组更新</span>
<span class="hljs-comment">// 错误：直接修改原数组</span>
<span class="hljs-keyword">this</span>.state.items.push(newItem);
<span class="hljs-comment">// 正确：创建新数组</span>
<span class="hljs-keyword">this</span>.setState({
  items: [...<span class="hljs-keyword">this</span>.state.items, newItem]
});

<span class="hljs-comment">// 对象更新</span>
<span class="hljs-comment">// 错误：直接修改原对象</span>
<span class="hljs-keyword">this</span>.state.user.name = <span class="hljs-string">'New Name'</span>;
<span class="hljs-comment">// 正确：创建新对象</span>
<span class="hljs-keyword">this</span>.setState({
  user: { ...<span class="hljs-keyword">this</span>.state.user, name: <span class="hljs-string">'New Name'</span> }
});
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-15">6. 常见场景与实战示例</h3>
<h4 data-id="heading-16">6.1 数据获取场景</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataFetcher</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> {
  state = {
    <span class="hljs-keyword">data</span>: [],
    loading: <span class="hljs-literal">true</span>,
    error: <span class="hljs-literal">null</span>,
    page: <span class="hljs-number">1</span>
  };
  
  componentDidMount() {
    <span class="hljs-keyword">this</span>.fetchData();
  }
  
  componentDidUpdate(prevProps, prevState) {
    <span class="hljs-keyword">if</span> (prevState.page !== <span class="hljs-keyword">this</span>.state.page) {
      <span class="hljs-keyword">this</span>.fetchData();
    }
  }
  
  fetchData = async () =&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">this</span>.setState({ loading: <span class="hljs-literal">true</span>, error: <span class="hljs-literal">null</span> });
      <span class="hljs-keyword">const</span> response = await fetch(`/api/<span class="hljs-keyword">data</span>?page=${<span class="hljs-keyword">this</span>.state.page}`);
      <span class="hljs-keyword">const</span> result = await response.json();
      <span class="hljs-keyword">this</span>.setState({ <span class="hljs-keyword">data</span>: result, loading: <span class="hljs-literal">false</span> });
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-keyword">this</span>.setState({ error: error.message, loading: <span class="hljs-literal">false</span> });
    }
  };
  
  render() {
    <span class="hljs-keyword">const</span> { <span class="hljs-keyword">data</span>, loading, error, page } = <span class="hljs-keyword">this</span>.state;
    
    <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> &lt;div&gt;加载中...&lt;/div&gt;;
    <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> &lt;div&gt;错误: {error}&lt;/div&gt;;
    
    <span class="hljs-keyword">return</span> (
      &lt;div&gt;
        {<span class="hljs-comment">/* 渲染数据 */</span>}
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-17">6.2 表单处理场景</h4>
<pre><code class="hljs language-ini" lang="ini">function ContactForm() {
  const <span class="hljs-section">[formData, setFormData]</span> = useState({
    name: '',
    email: '',
    message: ''
  })<span class="hljs-comment">;</span>
  
  const <span class="hljs-attr">handleChange</span> = (e) =&gt; {
    const { name, value } = e.target<span class="hljs-comment">;</span>
    setFormData(<span class="hljs-attr">prev</span> =&gt; ({
      ...prev,
      <span class="hljs-section">[name]</span>: value
    }))<span class="hljs-comment">;</span>
  }<span class="hljs-comment">;</span>
  
  const <span class="hljs-attr">handleSubmit</span> = (e) =&gt; {
    e.preventDefault()<span class="hljs-comment">;</span>
    // 提交表单数据
  }<span class="hljs-comment">;</span>
  
  return (
    &lt;form <span class="hljs-attr">onSubmit</span>={handleSubmit}&gt;
      &lt;input
        <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span>
        <span class="hljs-attr">value</span>={formData.name}
        <span class="hljs-attr">onChange</span>={handleChange}
      /&gt;
      &lt;input
        <span class="hljs-attr">name</span>=<span class="hljs-string">"email"</span>
        <span class="hljs-attr">value</span>={formData.email}
        <span class="hljs-attr">onChange</span>={handleChange}
      /&gt;
      &lt;textarea
        <span class="hljs-attr">name</span>=<span class="hljs-string">"message"</span>
        <span class="hljs-attr">value</span>={formData.message}
        <span class="hljs-attr">onChange</span>={handleChange}
      /&gt;
      &lt;button <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;提交&lt;/button&gt;
    &lt;/form&gt;
  )<span class="hljs-comment">;</span>
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-18">7. 常见陷阱与解决方案</h3>
<h4 data-id="heading-19">7.1 过时状态问题</h4>
<p>在闭包中捕获过时状态值：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 问题代码：可能捕获过时状态</span>
const <span class="hljs-selector-attr">[count, setCount]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);
const increment = () =&gt; {
  <span class="hljs-built_in">setTimeout</span>(() =&gt; {
    <span class="hljs-built_in">setCount</span>(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 可能使用过时的 count 值</span>
  }, <span class="hljs-number">3000</span>);
};

<span class="hljs-comment">// 解决方案：使用函数式更新</span>
const increment = () =&gt; {
  <span class="hljs-built_in">setTimeout</span>(() =&gt; {
    <span class="hljs-built_in">setCount</span>(prevCount =&gt; prevCount + <span class="hljs-number">1</span>); <span class="hljs-comment">// 总是基于最新状态</span>
  }, <span class="hljs-number">3000</span>);
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-20">7.2 useEffect 的依赖数组</h4>
<p>正确处理 useEffect 的依赖数组避免无限循环：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 错误：缺少依赖可能导致过时数据</span>
<span class="hljs-built_in">useEffect</span>(() =&gt; {
  <span class="hljs-built_in">fetchData</span>(userId);
}, <span class="hljs-selector-attr">[]</span>);

<span class="hljs-comment">// 错误：依赖不完整可能导致意外行为</span>
<span class="hljs-built_in">useEffect</span>(() =&gt; {
  <span class="hljs-built_in">fetchData</span>(userId);
}, <span class="hljs-selector-attr">[userId]</span>); <span class="hljs-comment">// 如果 fetchData 使用了其他状态，需要包含</span>

<span class="hljs-comment">// 正确：包含所有依赖</span>
<span class="hljs-built_in">useEffect</span>(() =&gt; {
  <span class="hljs-built_in">fetchData</span>(userId);
}, <span class="hljs-selector-attr">[userId, fetchData]</span>); <span class="hljs-comment">// 如果 fetchData 在渲染中定义，需要用 useCallback 包装</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-21">8. 总结</h3>
<p>React 的 State 和生命周期是构建交互式界面的核心概念。无论是类组件还是函数组件，合理管理状态和理解组件生命周期都是开发高质量 React 应用的关键。</p>
<p><strong>主要要点回顾</strong>：</p>
<ul>
<li>State 是组件内部的可变数据，Props 是从外部传入的只读数据</li>
<li>类组件使用 <code>this.state</code>和 <code>this.setState()</code>，函数组件使用 <code>useState</code>Hook</li>
<li>生命周期方法让你在组件不同阶段执行代码，<code>useEffect</code>在函数组件中承担类似职责</li>
<li>遵循 State 设计最佳实践（最小化、扁平化、不可变更新）</li>
<li>注意常见陷阱，如过时状态和 useEffect 的依赖处理</li>
</ul>
<p>随着 React 的发展，函数组件和 Hooks 已成为主流，但理解类组件的生命周期对于维护现有项目和深入理解 React 原理仍然很有价值。</p>
<p>希望本篇博客能帮助你更好地理解和应用 React 的 State 与生命周期概念！</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用AI把猫主子变成冰球猛将？我搞了个“宠物拟人化”神器，结果……它真敢打！]]></title>    <link>https://juejin.cn/post/7584339190034989096</link>    <guid>https://juejin.cn/post/7584339190034989096</guid>    <pubDate>2025-12-17T03:53:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584339190034989096" data-draft-id="7584346983135838260" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用AI把猫主子变成冰球猛将？我搞了个“宠物拟人化”神器，结果……它真敢打！"/> <meta itemprop="keywords" content="Coze,低代码,Vue.js"/> <meta itemprop="datePublished" content="2025-12-17T03:53:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="生椰丝绒拿铁"/> <meta itemprop="url" content="https://juejin.cn/user/4185180725584116"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用AI把猫主子变成冰球猛将？我搞了个“宠物拟人化”神器，结果……它真敢打！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4185180725584116/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    生椰丝绒拿铁
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:53:28.000Z" title="Wed Dec 17 2025 03:53:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>“家里的猫天天躺着晒太阳，要是能上冰场打球该多好。”<br/>
——来自一位被猫统治的程序员的悲鸣</p>
</blockquote>
<p>如果你也养了只“懒癌晚期”的猫或狗，每天除了吃就是睡，连看一眼你都嫌累，那你一定得看看这篇文章。<br/>
<strong>最近字节，搞了一个骚操作：把宠物照片一键变成冰球运动员！</strong></p>
<p>没错，就是那种穿着红蓝球衣、手持球杆、眼神凶狠、仿佛下一秒就要破门得分的——<strong>拟人化冰球猛将</strong>。</p>
<p>而且，整个过程只需要上传一张宠物照，剩下的交给AI搞定。<br/>
这不仅是个技术项目，更是一场<strong>让毛孩子当明星的奇幻冒险</strong>。</p>
<hr/>
<h2 data-id="heading-0">🐱 从“我家猫很胖”到“我是冰球队门将”，只差一个AI</h2>
<p>假设作为实习生团队的一员，我们的任务是为公司内部的“冰球俱乐部”策划一场趣味活动。<br/>
目标很简单：</p>
<blockquote>
<p><strong>让会员们上传自家宠物的照片，生成一张“宠物变冰球运动员”的酷炫海报。</strong></p>
</blockquote>
<p>听起来像魔法？不，这是<strong>低代码 + AI + Vue 的完美组合</strong>。</p>
<hr/>
<h2 data-id="heading-1">🔧 技术栈三件套：Coze + Vue + AI 图像生成</h2>
<h3 data-id="heading-2">1. Coze 工作流：拖拽式搭建，谁都能玩</h3>
<p>我们选择了 <strong>Coze（扣子）平台</strong> 来构建整个AI工作流。它的优势在于：</p>
<ul>
<li><strong>低代码编辑器</strong>：拖拖拽拽就能连节点</li>
<li>支持自定义代码逻辑</li>
<li>集成图像生成、特征提取、文本理解等能力</li>
</ul>
<p>比如下面这个流程图，就是我们亲手“画”出来的：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/473f100135cb42eba41d341c14edb202~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sf5qSw5Lid57uS5ou_6ZOB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548407&amp;x-signature=pZYGvqFKvEJLsD29vy5SifSrXDE%3D" alt="4f7147aa-3bbd-4273-a3fa-cbf23fc6be88.png" loading="lazy"/></p>
<blockquote>
<p>（注：图片展示的是真实工作流界面）</p>
</blockquote>
<p>简单来说，流程如下：</p>
<ol>
<li>用户上传宠物照片</li>
<li>系统自动识别宠物特征（如体型、毛色）</li>
<li>使用代码节点随机分配位置和持杆手</li>
<li>生成描述文案：“一只戴着红色头盔的哈士奇，身穿10号球衣，正准备射门……”</li>
<li>最终调用图像生成模型，输出一张“拟人化冰球运动员”照片</li>
</ol>
<hr/>
<h3 data-id="heading-3">2. 自定义代码节点：给AI加点“智商”</h3>
<p>为了让生成效果更有逻辑性，我们加入了关键的 <strong>JavaScript 代码节点</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">random</span> = (start: number, end: number) =&gt; {
    const <span class="hljs-attr">p</span> = Math.random()<span class="hljs-comment">;</span>
    return Math.floor(start * (1 - p) + end * p)<span class="hljs-comment">;</span>
}

async function main({ params }: Args): Promise&lt;Output&gt; {
    if (<span class="hljs-attr">params.position</span> == null) params.position = random(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<span class="hljs-comment">;</span>
    if (<span class="hljs-attr">params.shooting_hand</span> == null) params.shooting_hand = random(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<span class="hljs-comment">;</span>

    const <span class="hljs-attr">style</span> = params.style || <span class="hljs-string">'写实'</span><span class="hljs-comment">;</span>
    const uniform_number:<span class="hljs-attr">string</span> = (params.uniform_number || <span class="hljs-number">10</span>).toString()<span class="hljs-comment">;</span>
    const <span class="hljs-attr">uniform_color</span> = params.uniform_color || <span class="hljs-string">'红'</span><span class="hljs-comment">;</span>
    const <span class="hljs-attr">position</span> = params.position == <span class="hljs-number">0</span> ? <span class="hljs-string">'守门员'</span>: (params.position == <span class="hljs-number">1</span> ? <span class="hljs-string">'前锋'</span>: <span class="hljs-string">'后卫'</span>)<span class="hljs-comment">;</span>
    const <span class="hljs-attr">shooting_hand</span> = params.shooting_hand == <span class="hljs-number">0</span> ? <span class="hljs-string">'左手'</span>: <span class="hljs-string">'右手'</span><span class="hljs-comment">;</span>

    const <span class="hljs-attr">ret</span> = {
        style,
        uniform_number,
        uniform_color,
        position,
        shooting_hand,
    }<span class="hljs-comment">;</span>

    return ret<span class="hljs-comment">;</span>
}
</code></pre>
<p>这段代码的作用是：</p>
<ul>
<li>如果用户没选位置，就随机分配：<strong>守门员、前锋、后卫</strong></li>
<li>持杆手也随机：<strong>左手 or 右手</strong></li>
<li>默认风格是“写实”，但也可以改成“卡通”、“赛博朋克”等</li>
</ul>
<blockquote>
<p>这样一来，每只猫都可能是下一个“冰球界梅西”。</p>
</blockquote>
<hr/>
<h3 data-id="heading-4">3. 特征提取 + 图像生成：AI眼中的“猫”是什么样？</h3>
<p>我们在流程中加入了 <code>imgUnderstand</code> 和 <code>特征提取</code> 节点，用来分析原始图片。</p>
<p>例如，系统会自动识别出：</p>
<ul>
<li>这是一只“短毛猫”还是“长毛狗”</li>
<li>毛色是黑、白、灰还是花斑</li>
<li>是否有胡须、耳朵形状等细节</li>
</ul>
<p>然后把这些信息融合进提示词（prompt），比如：</p>
<blockquote>
<p>“一只黑白相间的猫咪，身穿蓝色10号球衣，正在滑行射门，背景是冰球场，风格写实。”</p>
</blockquote>
<p>最终由图像生成模型生成一张<strong>完全拟人化的冰球运动员照片</strong>。</p>
<hr/>
<h2 data-id="heading-5">💡 实战演示：我家猫变成了“冰球门将”！</h2>
<p>我上传了一张我家主子的照片——一只慵懒的布偶猫，平时连逗猫棒都不理。</p>
<p>结果……它居然成了这样：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a2223d3a2b95462dad2ab2b747a5ffcc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55Sf5qSw5Lid57uS5ou_6ZOB:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548407&amp;x-signature=eGRSIfJ3svF1pKsjYc2T7oN3e5s%3D" alt="iceball_player.png" loading="lazy"/></p>
<blockquote>
<p>（图中是一只穿着红色球衣、戴着头盔、手持球杆的“布偶猫门将”，眼神坚毅，仿佛刚扑掉一个致命射门）</p>
</blockquote>
<p>我朋友看完后说：“这猫怕不是真的练过？”<br/>
我说：“不，它是被AI逼出来的。”</p>
<hr/>
<h2 data-id="heading-6">🎯 为什么这个项目值得做？</h2>
<h3 data-id="heading-7">✅ 用户体验极佳</h3>
<ul>
<li>不需要懂AI，也不需要编程</li>
<li>上传照片 → 一键生成 → 分享朋友圈</li>
<li>完全自动化，适合节日营销</li>
</ul>
<h3 data-id="heading-8">✅ 技术亮点满满</h3>
<ul>
<li>结合了<strong>图像理解、自然语言处理、图像生成</strong></li>
<li>使用<strong>低代码平台快速迭代</strong></li>
<li>支持个性化定制（球衣颜色、号码、风格）</li>
</ul>
<h3 data-id="heading-9">✅ 幽默感拉满</h3>
<p>谁不想看到自己家的狗穿上球衣、拿着球杆、一脸“老子要进球”的表情？</p>
<blockquote>
<p>尤其是那些平时只会趴着睡觉的“废柴宠物”，突然变得英姿飒爽，反差萌直接拉满！</p>
</blockquote>
<hr/>
<h2 data-id="heading-10">🚀 如何复刻这个项目？</h2>
<p>如果你想自己动手做一个类似的“宠物变英雄”项目，可以按以下步骤来：</p>
<h3 data-id="heading-11">Step 1：注册 Coze 平台</h3>
<p>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcoze.cn%2F" target="_blank" title="https://coze.cn/" ref="nofollow noopener noreferrer">coze.cn</a>，创建个人空间。</p>
<h3 data-id="heading-12">Step 2：新建工作流</h3>
<ul>
<li>名称：<code>pet_hockey_player</code></li>
<li>添加输入节点：<code>picture</code>, <code>style</code>, <code>uniform_number</code>, <code>uniform_color</code></li>
</ul>
<h3 data-id="heading-13">Step 3：添加节点</h3>
<ol>
<li><strong>代码节点</strong>：实现随机逻辑</li>
<li><strong>imgUnderstand</strong>：解析图片内容</li>
<li><strong>特征提取</strong>：获取动物特征</li>
<li><strong>图像生成</strong>：使用通用模型 + 提示词生成图片</li>
<li><strong>结束节点</strong>：返回结果</li>
</ol>
<h3 data-id="heading-14">Step 4：前端用 Vue 搭建界面</h3>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>上传你的宠物，让它成为冰球明星！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">"handleFileUpload"</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">"image/*"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"generate"</span>&gt;</span>生成冰球运动员<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"result"</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"result"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"Generated Player"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">result</span>: <span class="hljs-literal">null</span>
    }
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleFileUpload</span>(<span class="hljs-params">event</span>) {
      <span class="hljs-keyword">const</span> file = event.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];
      <span class="hljs-comment">// 上传文件并获取URL</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadedUrl</span> = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(file);
    },
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params"/>) {
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/coze-workflow'</span>, {
        <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
          <span class="hljs-attr">picture</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">uploadedUrl</span>,
          <span class="hljs-attr">style</span>: <span class="hljs-string">'写实'</span>,
          <span class="hljs-attr">uniform_number</span>: <span class="hljs-number">7</span>,
          <span class="hljs-attr">uniform_color</span>: <span class="hljs-string">'蓝'</span>
        })
      });
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>().<span class="hljs-property">data</span>;
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<blockquote>
<p>注：实际调用 Coze API 需要配置鉴权，具体可参考官方文档。</p>
</blockquote>
<hr/>
<h2 data-id="heading-15">🤔 我的思考：AI不只是工具，更是“造梦机器”</h2>
<p>做这个项目时，我一直在想一个问题：</p>
<blockquote>
<p><strong>当AI能把一只猫变成冰球运动员时，我们到底是在创造什么？</strong></p>
</blockquote>
<p>答案是：<strong>一种新的情感连接。</strong></p>
<p>我们不是在“欺骗”用户，而是在用科技，帮他们完成一次<strong>对爱宠的浪漫想象</strong>。</p>
<p>就像小时候幻想自己是超级英雄一样，现在我们可以让宠物也成为“赛场上的王者”。</p>
<p>而这一切，只需要一行代码、一个工作流、一点点创意。</p>
<hr/>
<h2 data-id="heading-16">🎉 结语：下次别再说“我家猫不会打球”了</h2>
<p>从今以后，请记住：</p>
<blockquote>
<p><strong>每只宠物，都有成为冰球巨星的潜力。</strong></p>
</blockquote>
<p>只要它愿意——或者，只要AI愿意。</p>
<hr/>
<p>📌 <strong>项目总结</strong></p>





























<table><thead><tr><th>项目</th><th>内容</th></tr></thead><tbody><tr><td>平台</td><td>Coze（扣子）</td></tr><tr><td>技术</td><td>图像生成 + 特征提取 + 低代码工作流</td></tr><tr><td>前端</td><td>Vue + Axios</td></tr><tr><td>核心功能</td><td>宠物拟人化 + 冰球运动员生成</td></tr><tr><td>应用场景</td><td>节日活动、社区运营、品牌互动</td></tr></tbody></table></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[react组件(1)---从入门到上手]]></title>    <link>https://juejin.cn/post/7584339190035038248</link>    <guid>https://juejin.cn/post/7584339190035038248</guid>    <pubDate>2025-12-17T04:03:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584339190035038248" data-draft-id="7584370833703976975" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="react组件(1)---从入门到上手"/> <meta itemprop="keywords" content="React.js,前端框架"/> <meta itemprop="datePublished" content="2025-12-17T04:03:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端无涯"/> <meta itemprop="url" content="https://juejin.cn/user/3967483738859639"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            react组件(1)---从入门到上手
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3967483738859639/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端无涯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T04:03:46.000Z" title="Wed Dec 17 2025 04:03:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<blockquote>
<p>  组件是 React 的核心基石，也是 React 生态中最具代表性的设计思想。它将 UI 拆分为独立、可复用的单元，就像乐高积木一样，通过组合不同的组件可以构建出复杂的页面。从早期的类组件到如今的函数组件 + Hooks，React 组件的开发模式不断进化，变得更加简洁、灵活。本文将从<strong>组件本质、分类、创建、核心特性、通信、复用、性能优化</strong>等维度，全面解析 React 组件的使用方法与最佳实践，帮助你彻底掌握这一核心技能。</p>
</blockquote>
<h2 data-id="heading-0">一、React 组件的本质：什么是组件？</h2>
<h3 data-id="heading-1">1. 组件的定义</h3>
<p>React 组件是<strong>独立的、可复用的 UI 单元</strong>，它接收输入（Props），处理内部逻辑（State/Hooks），最终返回用于描述 UI 的 JSX（或 React 元素）。简单来说，组件就是一个 “函数”：输入数据，输出 UI。</p>
<h3 data-id="heading-2">2. 组件的核心思想：模块化与复用</h3>
<p>在传统的前端开发中，我们通常按页面划分代码，代码耦合度高，复用性差。而 React 的组件化思想解决了这一问题：</p>
<ul>
<li><strong>单一职责</strong>：一个组件只负责完成一个特定的功能（比如一个按钮、一个列表、一个弹窗）；</li>
<li><strong>可复用</strong>：组件可以在不同页面、不同项目中重复使用；</li>
<li><strong>可组合</strong>：组件可以嵌套、组合，形成更复杂的组件或页面；</li>
<li><strong>可维护</strong>：组件独立存在，修改一个组件不会影响其他组件，便于后期维护。</li>
</ul>
<h3 data-id="heading-3">3. 组件的本质：函数或类</h3>
<p>无论哪种类型的 React 组件，其本质都是<strong>JavaScript 函数或类</strong>：</p>
<ul>
<li><strong>函数组件</strong>：本质是一个普通的 JavaScript 函数，接收 props 参数，返回 JSX；</li>
<li><strong>类组件</strong>：本质是继承自<code>React.Component</code>的类，通过<code>render</code>方法返回 JSX。</li>
</ul>
<p>举个最简单的例子，一个显示 “Hello React” 的组件：</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-comment">// 函数组件（主流）</span>
const <span class="hljs-type">Hello</span> = () =&gt; {
  <span class="hljs-keyword">return</span> &lt;h1&gt;<span class="hljs-type">Hello</span> <span class="hljs-type">React</span>&lt;/h1&gt;;
};

<span class="hljs-comment">// 类组件（旧版写法，现在极少使用）</span>
<span class="hljs-keyword">import</span> <span class="hljs-type">React</span> from 'react';
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  render() {
    <span class="hljs-keyword">return</span> &lt;h1&gt;<span class="hljs-type">Hello</span> <span class="hljs-type">React</span>&lt;/h1&gt;;
  }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-4">二、React 组件的分类：不同类型的组件及适用场景</h2>
<p>React 组件可以根据<strong>实现方式、职责、特性</strong>分为不同类型，了解这些分类有助于我们在开发中选择合适的组件类型。</p>
<h3 data-id="heading-5">1. 按实现方式划分：函数组件 vs 类组件</h3>
<p>这是最核心的分类方式，也是 React 发展的重要分水岭。</p>



































<table><thead><tr><th>特性</th><th>函数组件（Function Component）</th><th>类组件（Class Component）</th></tr></thead><tbody><tr><td>语法复杂度</td><td>简洁，普通 JS 函数</td><td>繁琐，需要继承 React.Component，写 render 方法</td></tr><tr><td>状态管理</td><td>依赖 Hooks（useState、useReducer）</td><td>依赖 this.state 和 this.setState</td></tr><tr><td>生命周期</td><td>依赖 Hooks（useEffect）</td><td>有固定的生命周期方法（componentDidMount 等）</td></tr><tr><td>性能</td><td>略优（无类实例化开销）</td><td>略差（需要实例化类）</td></tr><tr><td>适用场景</td><td>所有场景（React 16.8 + 推荐）</td><td>老项目维护、特殊场景（如需要继承的组件）</td></tr></tbody></table>
<blockquote>
<p>注意：React 16.8 版本引入 Hooks 后，函数组件已经能够实现类组件的所有功能，目前<strong>函数组件 + Hooks</strong>是 React 开发的主流方式，类组件仅在老项目中存在。</p>
</blockquote>
<h3 data-id="heading-6">2. 按职责划分：展示组件 vs 容器组件</h3>
<p>这是一种基于 “关注点分离” 的分类方式，用于区分组件的功能职责。</p>
<h4 data-id="heading-7">展示组件（Presentational Component）</h4>
<ul>
<li><strong>职责</strong>：只负责 UI 的展示，不处理业务逻辑，也不管理状态；</li>
<li><strong>数据来源</strong>：通过 Props 接收外部传入的数据和回调函数；</li>
<li><strong>特点</strong>：纯函数式、可复用性高、无副作用。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 展示组件：只渲染列表项，不处理数据逻辑</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">TodoItem</span> = (<span class="hljs-params">{ text, onDelete }</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
      {text}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onDelete}</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
  );
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-8">容器组件（Container Component）</h4>
<ul>
<li><strong>职责</strong>：负责处理业务逻辑、管理状态、请求数据，不关心 UI 展示；</li>
<li><strong>数据来源</strong>：自身的 State 或外部状态管理库（Redux、Mobx）；</li>
<li><strong>特点</strong>：通常不直接渲染 JSX，而是将数据和方法通过 Props 传递给展示组件。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 容器组件：处理待办事项的逻辑，管理状态</span>
<span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">TodoListContainer</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">const</span> [todos, setTodos] = <span class="hljs-title function_">useState</span>([<span class="hljs-string">'学习React组件'</span>, <span class="hljs-string">'写博客'</span>]);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDelete</span> = (<span class="hljs-params">index</span>) =&gt; {
    <span class="hljs-title function_">setTodos</span>(todos.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> i !== index));
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
      {todos.map((todo, index) =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">TodoItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span> <span class="hljs-attr">text</span>=<span class="hljs-string">{todo}</span> <span class="hljs-attr">onDelete</span>=<span class="hljs-string">{()</span> =&gt;</span> handleDelete(index)} /&gt;
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>
  );
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<blockquote>
<p>补充：随着 Hooks 的普及，这种分类方式逐渐淡化，因为我们可以通过自定义 Hooks 将业务逻辑抽离，让组件同时兼具展示和逻辑功能。</p>
</blockquote>
<h3 data-id="heading-9">3. 其他常见分类</h3>
<ul>
<li><strong>纯组件（Pure Component）</strong> ：类组件中的<code>React.PureComponent</code>或函数组件中的<code>React.memo</code>，用于优化性能，避免不必要的重渲染；</li>
<li><strong>高阶组件（Higher-Order Component，HOC）</strong> ：一个接收组件并返回新组件的函数，用于复用组件逻辑；</li>
<li><strong>门户组件（Portal）</strong> ：用于将组件渲染到 DOM 树的其他位置，如弹窗、提示框；</li>
<li><strong>懒加载组件</strong>：通过<code>React.lazy</code>和<code>Suspense</code>实现的按需加载组件。</li>
</ul>
<h2 data-id="heading-10">三、组件的创建与基础使用</h2>
<p>本节将重点讲解<strong>函数组件</strong>的创建与使用（类组件仅作简单介绍），包括 Props 接收、默认值、类型校验等核心知识点。</p>
<h3 data-id="heading-11">1. 基础函数组件的创建与渲染</h3>
<h4 data-id="heading-12">（1）创建函数组件</h4>
<p>函数组件是一个普通的 JavaScript 函数，返回值为 JSX（或 null、false，表示不渲染任何内容）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 无参数的基础组件</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Button</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
};

<span class="hljs-comment">// 箭头函数简写（无大括号时，return可省略）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Text</span> = (<span class="hljs-params"/>) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段文本<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;

<span class="hljs-comment">// 普通函数写法（兼容旧版JS）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Title</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-13">（2）渲染组件</h4>
<p>组件创建完成后，可以像使用 HTML 标签一样在其他组件中渲染，注意<strong>组件名必须以大写字母开头</strong>（React 的约定，用于区分原生 HTML 标签）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 根组件</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"app"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Title</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Text</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// 渲染到DOM</span>
<span class="hljs-keyword">import</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/client'</span>;
<span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>));
root.<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-14">2. Props：组件的输入参数</h3>
<p>Props（Properties 的缩写）是组件的输入参数，用于从父组件向子组件传递数据。Props 是<strong>只读的</strong>，子组件不能修改 Props（这是 React 的单向数据流原则）。</p>
<h4 data-id="heading-15">（1）接收与使用 Props</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 子组件：接收props</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Greeting</span> = (<span class="hljs-params">props</span>) =&gt; {
  <span class="hljs-comment">// props是一个对象，包含父组件传递的所有属性</span>
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {props.name}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
};

<span class="hljs-comment">// 父组件：传递props</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {/* 传递字符串属性 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"React"</span> /&gt;</span>
      {/* 传递非字符串属性（需用{}包裹） */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">age</span>=<span class="hljs-string">{18}</span> /&gt;</span>
      {/* 传递布尔值 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">isShow</span>=<span class="hljs-string">{true}</span> /&gt;</span>
      {/* 传递函数 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">onButtonClick</span>=<span class="hljs-string">{()</span> =&gt;</span> alert('点击了')} /&gt;
      {/* 传递JSX元素（对应props.children） */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是子元素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Greeting</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-16">（2）Props 解构赋值</h4>
<p>为了简化代码，通常使用解构赋值直接提取 Props 中的属性。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 基础解构</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Greeting</span> = (<span class="hljs-params">{ name, age }</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// 解构+默认值</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Greeting</span> = (<span class="hljs-params">{ name = <span class="hljs-string">'游客'</span>, age = <span class="hljs-number">0</span> }</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-17">（3）默认 Props</h4>
<p>除了使用解构赋值设置默认值，还可以通过<code>defaultProps</code>属性设置组件的默认 Props（适用于函数组件和类组件）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Greeting</span> = (<span class="hljs-params">{ name, age }</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// 设置默认Props</span>
<span class="hljs-title class_">Greeting</span>.<span class="hljs-property">defaultProps</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'游客'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">0</span>
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-18">（4）Props 类型校验</h4>
<p>为了提高代码的健壮性，我们可以使用<code>prop-types</code>库对 Props 的类型进行校验（React v15.5.0 后，PropTypes 从 React 核心库中移出，需单独安装）。</p>
<p><strong>步骤 1：安装 prop-types</strong></p>
<pre><code class="hljs language-csharp" lang="csharp">npm install prop-types --save
<span class="hljs-meta"># 或</span>
yarn <span class="hljs-keyword">add</span> prop-types
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>步骤 2：使用 PropTypes 进行类型校验</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">Greeting</span> = (<span class="hljs-params">{ name, age, isShow, onButtonClick, children }</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// 类型校验</span>
<span class="hljs-title class_">Greeting</span>.<span class="hljs-property">propTypes</span> = {
  <span class="hljs-comment">// 字符串，必传</span>
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,
  <span class="hljs-comment">// 数字（也可以是字符串）</span>
  <span class="hljs-attr">age</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-title function_">oneOfType</span>([<span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>, <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>]),
  <span class="hljs-comment">// 布尔值</span>
  <span class="hljs-attr">isShow</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">bool</span>,
  <span class="hljs-comment">// 函数</span>
  <span class="hljs-attr">onButtonClick</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">func</span>,
  <span class="hljs-comment">// 任意React节点</span>
  <span class="hljs-attr">children</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">node</span>
};

<span class="hljs-comment">// 默认Props</span>
<span class="hljs-title class_">Greeting</span>.<span class="hljs-property">defaultProps</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'游客'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">isShow</span>: <span class="hljs-literal">false</span>
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-19">3. 类组件的创建（仅作了解）</h3>
<p>类组件需要继承<code>React.Component</code>，并实现<code>render</code>方法返回 JSX。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">PropTypes</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-comment">// 默认Props</span>
  <span class="hljs-keyword">static</span> defaultProps = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'游客'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">0</span>
  };

  <span class="hljs-comment">// 类型校验</span>
  <span class="hljs-keyword">static</span> propTypes = {
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">string</span>.<span class="hljs-property">isRequired</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-title class_">PropTypes</span>.<span class="hljs-property">number</span>
  };

  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> { name, age } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {name}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[react组件(3)---组件间的通信]]></title>    <link>https://juejin.cn/post/7584319403862573091</link>    <guid>https://juejin.cn/post/7584319403862573091</guid>    <pubDate>2025-12-17T04:25:34.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584319403862573091" data-draft-id="7584339190035169320" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="react组件(3)---组件间的通信"/> <meta itemprop="keywords" content="前端,React.js"/> <meta itemprop="datePublished" content="2025-12-17T04:25:34.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端无涯"/> <meta itemprop="url" content="https://juejin.cn/user/3967483738859639"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            react组件(3)---组件间的通信
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3967483738859639/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端无涯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T04:25:34.000Z" title="Wed Dec 17 2025 04:25:34 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<h2 data-id="heading-0">引言</h2>
<blockquote>
<p>在React应用开发中，组件是构建用户界面的基本单元。随着应用复杂度增加，多个组件之间的通信变得至关重要。无论是简单的父子组件通信，还是复杂的跨组件数据流，选择合适的通信方式将直接影响代码的可维护性和性能。本文将全面介绍React中组件通信的各种方法，帮助你在不同场景下做出最佳选择。</p>
</blockquote>
<h3 data-id="heading-1">1. 父子组件通信</h3>
<h4 data-id="heading-2">1.1 父组件向子组件传递数据：Props</h4>
<p>最基本的通信方式是父组件通过<strong>props</strong>向子组件传递数据。这是React单向数据流的核心体现。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 父组件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponent</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> userData = { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span> };
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{userData}</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"用户信息"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildComponent</span>(<span class="hljs-params">{ user, title }</span>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{title}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名: {user.name}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄: {user.age}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-3">1.2 子组件向父组件传递数据：回调函数</h4>
<p>子组件通过调用父组件传递的回调函数，实现向父组件传递数据。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 父组件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponent</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [message, setMessage] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDataFromChild</span> = (<span class="hljs-params">data</span>) =&gt; {
    <span class="hljs-title function_">setMessage</span>(data);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'来自子组件的数据:'</span>, data);
  };
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>父组件接收到的消息: {message}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">onSendData</span>=<span class="hljs-string">{handleDataFromChild}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildComponent</span>(<span class="hljs-params">{ onSendData }</span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">onSendData</span>(<span class="hljs-string">'Hello from Child!'</span>);
  };
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>向父组件发送数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-4">2. 兄弟组件通信</h3>
<p>兄弟组件之间的通信需要通过它们的<strong>共同父组件</strong>作为中介。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponent</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [sharedData, setSharedData] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);
  
  <span class="hljs-comment">// 处理来自第一个子组件的数据</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDataFromA</span> = (<span class="hljs-params">data</span>) =&gt; {
    <span class="hljs-title function_">setSharedData</span>(data);
  };
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ChildA</span> <span class="hljs-attr">onDataUpdate</span>=<span class="hljs-string">{handleDataFromA}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ChildB</span> <span class="hljs-attr">receivedData</span>=<span class="hljs-string">{sharedData}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildA</span>(<span class="hljs-params">{ onDataUpdate }</span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">sendData</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">onDataUpdate</span>(<span class="hljs-string">'数据来自ChildA'</span>);
  };
  
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{sendData}</span>&gt;</span>发送数据给兄弟组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildB</span>(<span class="hljs-params">{ receivedData }</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>ChildB接收到的数据: {receivedData}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>这种方式的优点是数据流清晰可见，但当组件层级较深时，可能会导致"prop drilling"问题。</p>
<blockquote>
<p>Prop Drilling（直译 “属性钻取”，也常被称为 “Prop 透传”）指的是：<strong>当一个数据需要从父组件传递到深层嵌套的子组件（如祖父→父亲→儿子→孙子）时，中间的每一层组件都需要接收并传递这个属性，即使中间组件本身并不需要使用该属性</strong>。</p>
</blockquote>
<h3 data-id="heading-5">3. 跨层级组件通信</h3>
<h4 data-id="heading-6">3.1 Context API</h4>
<p>对于深层嵌套的组件通信，React的<strong>Context API</strong>提供了一种在组件树中传递数据的方法，而无需显式地通过每个层级传递props。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 创建Context</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ThemeContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();

<span class="hljs-comment">// 2. 提供数据（Provider）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">'light'</span>);
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ThemeContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">theme</span>, <span class="hljs-attr">setTheme</span> }}&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">MainContent</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ThemeContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 3. 在任意层级消费数据（Consumer）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ThemeToggle</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ThemeToggle</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { theme, setTheme } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">ThemeContext</span>);
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggleTheme</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-title function_">setTheme</span>(theme === <span class="hljs-string">'light'</span> ? <span class="hljs-string">'dark'</span> : <span class="hljs-string">'light'</span>);
  };
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{toggleTheme}</span>&gt;</span>
      当前主题: {theme} (点击切换)
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  );
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>Context API特别适合<strong>全局数据</strong>，如主题、用户认证信息、语言偏好等。</p>
<h4 data-id="heading-7">3.2 组合模式（Component Composition）</h4>
<p>通过组合组件的方式，可以避免不必要的层级嵌套。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 不推荐：深层prop传递</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span> };
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Header</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span></span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Header</span>(<span class="hljs-params">{ user }</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigation</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span></span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Navigation</span>(<span class="hljs-params">{ user }</span>) {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserMenu</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span></span>;
}

<span class="hljs-comment">// 推荐：组件组合</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> user = { <span class="hljs-attr">name</span>: <span class="hljs-string">'John'</span> };
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Header</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Navigation</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">UserMenu</span> <span class="hljs-attr">user</span>=<span class="hljs-string">{user}</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Navigation</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span></span>
  );
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-8">4. 全局状态管理</h3>
<h4 data-id="heading-9">4.1 使用Redux</h4>
<p>对于复杂应用，<strong>Redux</strong>提供了可预测的状态管理。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// store.js</span>
<span class="hljs-keyword">import</span> { createStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'redux'</span>;

<span class="hljs-keyword">const</span> initialState = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };

<span class="hljs-keyword">function</span> <span class="hljs-title function_">counterReducer</span>(<span class="hljs-params">state = initialState, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'INCREMENT'</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'DECREMENT'</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> };
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
}

<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(counterReducer);

<span class="hljs-comment">// Component.js</span>
<span class="hljs-keyword">import</span> { useSelector, useDispatch } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-redux'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">useSelector</span>(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">count</span>);
  <span class="hljs-keyword">const</span> dispatch = <span class="hljs-title function_">useDispatch</span>();
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>计数: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'INCREMENT' })}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: 'DECREMENT' })}&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-10">4.2 使用useReducer + Context</h4>
<p>对于中等复杂度应用，可以使用<strong>useReducer</strong>配合Context实现类Redux的状态管理。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AppStateContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">appReducer</span>(<span class="hljs-params">state, action</span>) {
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'SET_USER'</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">user</span>: action.<span class="hljs-property">payload</span> };
    <span class="hljs-keyword">case</span> <span class="hljs-string">'SET_THEME'</span>:
      <span class="hljs-keyword">return</span> { ...state, <span class="hljs-attr">theme</span>: action.<span class="hljs-property">payload</span> };
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> state;
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">AppProvider</span>(<span class="hljs-params">{ children }</span>) {
  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(appReducer, {
    <span class="hljs-attr">user</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">theme</span>: <span class="hljs-string">'light'</span>
  });
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AppStateContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">state</span>, <span class="hljs-attr">dispatch</span> }}&gt;</span>
      {children}
    <span class="hljs-tag">&lt;/<span class="hljs-name">AppStateContext.Provider</span>&gt;</span></span>
  );
}

<span class="hljs-comment">// 在任何组件中使用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> { state, dispatch } = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">AppStateContext</span>);
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">updateUser</span> = (<span class="hljs-params">user</span>) =&gt; {
    <span class="hljs-title function_">dispatch</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'SET_USER'</span>, <span class="hljs-attr">payload</span>: user });
  };
  
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>用户名: {state.user?.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-11">5. 其他通信方式</h3>
<h4 data-id="heading-12">5.1 事件总线（Event Bus）</h4>
<p>对于非父子关系且层级较远的组件，可以使用事件总线实现通信。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// eventBus.js</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">EventBus</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span> = {};
  }
  
  <span class="hljs-title function_">on</span>(<span class="hljs-params">event, callback</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event] = [];
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">push</span>(callback);
  }
  
  <span class="hljs-title function_">emit</span>(<span class="hljs-params">event, data</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event]) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">events</span>[event].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(data));
    }
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventBus</span>();

<span class="hljs-comment">// 组件A - 发布事件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentA</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
    eventBus.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'dataUpdate'</span>, { <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello from A'</span> });
  };
  
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>发布事件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
}

<span class="hljs-comment">// 组件B - 订阅事件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ComponentB</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> [data, setData] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);
  
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    eventBus.<span class="hljs-title function_">on</span>(<span class="hljs-string">'dataUpdate'</span>, <span class="hljs-function">(<span class="hljs-params">newData</span>) =&gt;</span> {
      <span class="hljs-title function_">setData</span>(newData.<span class="hljs-property">message</span>);
    });
  }, []);
  
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>接收到的数据: {data}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-13">5.2 Ref方式通信</h4>
<p>父组件通过<strong>ref</strong>直接调用子组件的方法。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 子组件</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'子组件方法被调用'</span>);
  }
  
  <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>子组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
  }
}

<span class="hljs-comment">// 父组件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponent</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> childRef = <span class="hljs-title function_">useRef</span>();
  
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"/>) =&gt; {
    childRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">doSomething</span>();
  };
  
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>调用子组件方法<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{childRef}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-14">6. 通信方式选择指南</h3>
<p>以下表格总结了不同场景下推荐的通信方式：</p>









































<table><thead><tr><th>通信场景</th><th>推荐方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>父子组件</td><td>Props + 回调函数</td><td>简单直观，数据流清晰</td><td>深层嵌套时繁琐</td></tr><tr><td>兄弟组件</td><td>共同父组件中转</td><td>易于理解</td><td>可能导致父组件臃肿</td></tr><tr><td>跨层级组件</td><td>Context API</td><td>避免prop drilling</td><td>可能引起不必要的重渲染</td></tr><tr><td>全局状态</td><td>Redux/Zustand</td><td>可预测，调试友好</td><td>概念复杂，样板代码多</td></tr><tr><td>解耦通信</td><td>事件总线/发布订阅</td><td>组件完全解耦</td><td>数据流不够明显</td></tr></tbody></table>
<h3 data-id="heading-15">7. 最佳实践与注意事项</h3>
<ol>
<li><strong>保持状态提升合理</strong>：将状态提升到足够高的层级，但不要过度提升。</li>
<li><strong>避免过度使用Context</strong>：Context的变动会引起所有消费者组件重新渲染，性能敏感场景需谨慎。</li>
<li><strong>不可变更新状态</strong>：始终以不可变方式更新状态，避免直接修改对象或数组。</li>
<li><strong>TypeScript集成</strong>：使用TypeScript定义props和context的类型，提高代码可靠性。</li>
<li><strong>性能优化</strong>：使用React.memo、useMemo、useCallback避免不必要的重渲染。</li>
</ol>
<h3 data-id="heading-16">结语</h3>
<p>React组件通信是应用开发的核心环节，选择正确的通信方式至关重要。简单场景优先考虑props和回调函数，复杂场景再考虑Context或状态管理库。记住，没有一种方法适合所有场景，关键是理解每种方法的优缺点，根据具体需求做出合理选择。</p>
<p>希望本文能帮助你在React开发中更加游刃有余地处理组件通信问题。Happy Coding!</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Web-Tech：CORS的触发机制]]></title>    <link>https://juejin.cn/post/7584362317003210779</link>    <guid>https://juejin.cn/post/7584362317003210779</guid>    <pubDate>2025-12-17T04:36:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584362317003210779" data-draft-id="7584365584747610139" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Web-Tech：CORS的触发机制"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-17T04:36:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="GoldenPlayer"/> <meta itemprop="url" content="https://juejin.cn/user/2999123453948119"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Web-Tech：CORS的触发机制
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2999123453948119/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    GoldenPlayer
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T04:36:50.000Z" title="Wed Dec 17 2025 04:36:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>触及了CORS的核心机制 细解释其中的关键区别：</p>
<h2 data-id="heading-0">关键区别：<strong>浏览器导航</strong> vs <strong>JavaScript API请求</strong></h2>
<h3 data-id="heading-1">1. 描述的情况（Google搜索结果）：</h3>
<p>当<strong>点击Google搜索结果中的链接</strong>时，发生的是：</p>
<ul>
<li><strong>浏览器导航</strong>：浏览器地址栏直接变成 <code>https://abcnews.go.com/</code></li>
<li><strong>整个页面被替换</strong>：浏览器完全离开Google，加载ABC News的页面</li>
<li><strong>这不是跨源请求</strong>：这是用户主动的页面跳转，浏览器允许这种行为</li>
</ul>
<h3 data-id="heading-2">2. CORS限制的情况：</h3>
<p>当<strong>JavaScript代码</strong>在一个页面中尝试<strong>异步获取另一个域的资源</strong>时：</p>
<ul>
<li><strong>页面不跳转</strong>：仍然在Google页面上</li>
<li><strong>JavaScript悄悄获取数据</strong>：JS试图在后台获取 <code>https://abcnews.go.com/</code> 的数据</li>
<li><strong>浏览器阻止</strong>：因为这会带来安全风险（网站可以偷偷读取其他网站数据）</li>
</ul>
<h2 data-id="heading-3">用现实世界做类比</h2>
<h3 data-id="heading-4">类比1：图书馆查询系统（类似Google搜索）</h3>
<ul>
<li><strong>合法行为</strong>：通过图书馆系统查到了《纽约时报》的文章索引</li>
<li><strong>点击查看</strong>：<strong>离开</strong>图书馆系统，直接去《纽约时报》网站阅读全文 ✅</li>
<li><strong>非法行为</strong>：让图书馆系统<strong>自动复制</strong>《纽约时报》的全部内容到图书馆网站上 ❌</li>
</ul>
<h3 data-id="heading-5">类比2：新闻报道引用</h3>
<ul>
<li><strong>合法引用</strong>：报道中说"据《华尔街日报》报道..."，读者点击链接去看原文 ✅</li>
<li><strong>非法抄袭</strong>：报道中直接把《华尔街日报》的全文数据<strong>嵌入</strong>到自己的网站中 ❌</li>
</ul>
<h2 data-id="heading-6">技术层面的明确区分</h2>
<h3 data-id="heading-7">允许的（不会触发CORS）：</h3>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 用户点击链接 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://abcnews.go.com/article"</span>&gt;</span>点击前往ABC News<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 用户提交表单 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"https://other-site.com/submit"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"GET"</span>&gt;</span>
</code></pre>
<h3 data-id="heading-8">会触发CORS的：</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// JavaScript试图在后台获取其他网站的数据</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://abcnews.go.com/api/data"</span>)  <span class="hljs-comment">// 会触发CORS检查</span>
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-comment">// 将ABC News的数据显示在Google页面上</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"content"</span>).<span class="hljs-property">innerHTML</span> = data;
  });
</code></pre>
<h2 data-id="heading-9">为什么浏览器要这样设计？</h2>
<h3 data-id="heading-10">安全风险示例：</h3>
<p>假设恶意网站 <code>evil.com</code> 可以任意读取其他网站的数据：</p>
<ol>
<li>登录网上银行 <code>bank.com</code></li>
<li>在另一个标签页打开了 <code>evil.com</code></li>
<li><code>evil.com</code> 的JavaScript可以：
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 悄悄获取银行余额（如果允许跨域）</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://bank.com/api/balance"</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">sendToHackerServer</span>(data));
</code></pre>
</li>
</ol>
<h3 data-id="heading-11">同源策略的保护：</h3>
<ul>
<li><strong>隔离数据</strong>：每个网站的JavaScript只能访问自己网站的数据</li>
<li><strong>用户知情</strong>：跨域数据访问需要<strong>目标网站的明确同意</strong>（CORS头）</li>
<li><strong>防止CSRF</strong>：防止其他网站冒充用户发起请求</li>
</ul>
<h2 data-id="heading-12">实际示例对比</h2>
<h3 data-id="heading-13">示例A：正常的网页跳转 ✅</h3>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- Google搜索结果页面 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>搜索结果<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://news.bbc.co.uk"</span>&gt;</span>BBC News<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 用户点击这里 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://www.nytimes.com"</span>&gt;</span>New York Times<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p><strong>结果</strong>：用户离开Google，进入BBC网站</p>
<h3 data-id="heading-14">示例B：会触发CORS的请求 ❌</h3>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- Google搜索结果页面 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>搜索结果<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"news-content"</span>&gt;</span>正在加载BBC新闻...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-comment">// 尝试在Google页面上直接显示BBC的内容</span>
    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">"https://news.bbc.co.uk/latest-news"</span>)  <span class="hljs-comment">// CORS错误！</span>
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">text</span>())
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">html</span> =&gt;</span> {
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"news-content"</span>).<span class="hljs-property">innerHTML</span> = html;
      });
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<h2 data-id="heading-15">特别说明：iframe的中间情况</h2>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 在Google页面中嵌入BBC --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://news.bbc.co.uk"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>
</code></pre>
<ul>
<li><strong>允许</strong>：可以嵌入其他网站</li>
<li><strong>限制</strong>：Google的JavaScript<strong>不能</strong>访问iframe中BBC的内容</li>
<li><strong>隔离</strong>：两个网站的JavaScript完全隔离</li>
</ul>
<h2 data-id="heading-16">总结困惑</h2>
<ol>
<li><strong>Google搜索到ABC News的链接</strong>：用户点击 → 页面跳转 → <strong>不是CORS场景</strong></li>
<li><strong>APK列表页面</strong>：JavaScript在后台fetch数据 → <strong>是CORS场景</strong></li>
<li><strong>CORS只限制</strong>：JavaScript的<code>fetch()</code>、<code>XMLHttpRequest</code>、<code>axios</code>等API调用</li>
<li><strong>CORS不限制</strong>：<code>&lt;a&gt;</code>链接点击、<code>&lt;form&gt;</code>提交、<code>&lt;iframe&gt;</code>加载、<code>&lt;script&gt;</code>标签加载、<code>&lt;img&gt;</code>加载等</li>
</ol>
<p><strong>简单记忆</strong>：</p>
<ul>
<li><strong>用户主动操作</strong>（点击链接）：✅ 允许</li>
<li><strong>JavaScript偷偷操作</strong>（ajax请求）：❌ 需要CORS授权</li>
</ul>
<p>这就是为什么不需要CORS插件就能浏览网页，但需要它来开发前端应用的原因</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vite：现代前端构建工具的革命与实战指南]]></title>    <link>https://juejin.cn/post/7584365584747757595</link>    <guid>https://juejin.cn/post/7584365584747757595</guid>    <pubDate>2025-12-17T05:21:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584365584747757595" data-draft-id="7584383352449613862" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vite：现代前端构建工具的革命与实战指南"/> <meta itemprop="keywords" content="Vite,Vue.js,前端"/> <meta itemprop="datePublished" content="2025-12-17T05:21:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AY1024"/> <meta itemprop="url" content="https://juejin.cn/user/2232439936132313"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vite：现代前端构建工具的革命与实战指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2232439936132313/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AY1024
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T05:21:44.000Z" title="Wed Dec 17 2025 05:21:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h2 data-id="heading-0">Vite：现代前端构建工具的革命</h2>
<h3 data-id="heading-1">引言：前端构建工具的演进</h3>
<p>在 Vite 出现之前，Webpack 几乎统治了前端构建工具领域。Webpack 通过静态分析依赖关系，将项目中的所有模块打包成少数几个 bundle 文件，这种"打包优先"的策略在早期确实解决了模块化开发的问题。但随着项目规模的增长，Webpack 的构建速度逐渐成为开发体验的瓶颈——即使是小型项目，冷启动时间也可能达到数十秒，热更新也需要几秒钟。</p>
<p>正是在这样的背景下，Vue.js 作者尤雨溪于 2020 年推出了 Vite（法语意为"快速"），它彻底改变了前端开发的构建范式，带来了革命性的开发体验提升。</p>
<h3 data-id="heading-2">Vite 的核心架构优势</h3>
<h4 data-id="heading-3">1. 基于原生 ES 模块的急速冷启动</h4>
<p>Vite 最显著的特点是<strong>极快的冷启动速度</strong>。与传统打包器不同，Vite 在开发环境下直接使用浏览器原生 ES 模块：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- index.html --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/src/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// main.js - 浏览器直接执行 ES 模块</span>
<span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>

<span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<p><strong>工作原理：</strong></p>
<ul>
<li>Vite 将应用模块分为<strong>依赖</strong>和<strong>源码</strong>两部分</li>
<li>依赖使用 esbuild 预构建（Go 语言编写，比 JavaScript 快 10-100 倍）</li>
<li>源码按需编译并提供，浏览器只请求当前页面所需的模块</li>
<li>这种方式避免了整个应用的打包过程，实现了毫秒级的启动速度</li>
</ul>
<h4 data-id="heading-4">2. 高效的热模块替换（HMR）</h4>
<p>Vite 的热更新同样基于原生 ES 模块系统，实现了精准的更新策略：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 当修改一个 Vue 组件时</span>
<span class="hljs-comment">// Vite 只会重新编译该组件，并通过 HMR API 快速更新</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>) {
  <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">hot</span>.<span class="hljs-title function_">accept</span>(<span class="hljs-string">'./Foo.vue'</span>, <span class="hljs-function">(<span class="hljs-params">newModule</span>) =&gt;</span> {
    <span class="hljs-comment">// 更新逻辑</span>
  })
}
</code></pre>
<p><strong>HMR 优势：</strong></p>
<ul>
<li>
<p>更新速度不受应用规模影响</p>
</li>
<li>
<p>保持应用状态不变</p>
</li>
<li>
<p>支持 Vue 单文件组件的模板和样式热更新</p>
</li>
<li>
<p>后端node会自动检查文件的修改情况，并且自动更新</p>
</li>
<li>
<p>如图：</p>
</li>
</ul>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4e6cc1c5d1d646548b73025962f84243~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQVkxMDI0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766553704&amp;x-signature=3EFVjwh%2FegGDhiqBc8h8mLuwoDk%3D" alt="屏幕录制 2025-12-17 125503.gif" loading="lazy"/></p>
<h4 data-id="heading-5">3. 开箱即用的现代化支持</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 一键创建项目</span>
npm create vite@latest my-vue-app -- --template vue
</code></pre>
<p>Vite 原生支持：</p>
<ul>
<li>TypeScript</li>
<li>JSX</li>
<li>CSS 预处理器（Sass、Less、Stylus）</li>
<li>PostCSS</li>
<li>现代 CSS 功能（CSS Modules、CSS Nesting）</li>
<li>静态资源处理</li>
<li>WebAssembly</li>
</ul>
<h3 data-id="heading-6">工程化实践：构建完整的 Vue 应用</h3>
<h4 data-id="heading-7">项目结构标准化</h4>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-keyword">my</span>-project/
├── src/
│   ├── main.js              <span class="hljs-comment"># 应用入口</span>
│   ├── App.vue              <span class="hljs-comment"># 根组件</span>
│   ├── views/               <span class="hljs-comment"># 页面组件</span>
│   │   ├── Home.vue
│   │   └── About.vue
│   ├── components/          <span class="hljs-comment"># 可复用组件</span>
│   ├── router/              <span class="hljs-comment"># 路由配置</span>
│   └── store/               <span class="hljs-comment"># 状态管理</span>
├── index.html               <span class="hljs-comment"># 入口 HTML</span>
└── vite.config.js           <span class="hljs-comment"># Vite 配置</span>
</code></pre>
<h4 data-id="heading-8">Vue Router 集成</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// router/index.js</span>
<span class="hljs-keyword">import</span> { createRouter, createWebHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../views/Home.vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../views/About.vue'</span>

<span class="hljs-keyword">const</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> },
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span> }
]

<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),
  routes
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- App.vue --&gt;
&lt;template&gt;
  &lt;nav&gt;
    &lt;router-link to="/"&gt;Home&lt;/router-link&gt;
    &lt;router-link to="/about"&gt;About&lt;/router-link&gt;
  &lt;/nav&gt;
  &lt;router-view/&gt;
&lt;/template&gt;
</code></pre>
<h4 data-id="heading-9">生产构建优化</h4>
<p>虽然 Vite 开发体验优秀，但生产构建仍使用 Rollup：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// vite.config.js</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],
  <span class="hljs-attr">build</span>: {
    <span class="hljs-comment">// 生产构建配置</span>
    <span class="hljs-attr">rollupOptions</span>: {
      <span class="hljs-attr">output</span>: {
        <span class="hljs-attr">manualChunks</span>: {
          <span class="hljs-comment">// 代码分割策略</span>
          <span class="hljs-attr">vendor</span>: [<span class="hljs-string">'vue'</span>, <span class="hljs-string">'vue-router'</span>],
          <span class="hljs-attr">utils</span>: [<span class="hljs-string">'lodash'</span>, <span class="hljs-string">'axios'</span>]
        }
      }
    },
    <span class="hljs-comment">// 构建输出目录</span>
    <span class="hljs-attr">outDir</span>: <span class="hljs-string">'dist'</span>,
    <span class="hljs-comment">// 静态资源处理</span>
    <span class="hljs-attr">assetsDir</span>: <span class="hljs-string">'assets'</span>
  },
  <span class="hljs-attr">server</span>: {
    <span class="hljs-comment">// 开发服务器配置</span>
    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,
    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>
  }
})
</code></pre>
<h3 data-id="heading-10">Vite 生态系统与插件</h3>
<p>Vite 拥有丰富的插件生态系统：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 常用插件配置</span>
<span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>
<span class="hljs-keyword">import</span> vueJsx <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue-jsx'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoImport</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'unplugin-auto-import/vite'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">vue</span>(),
    <span class="hljs-title function_">vueJsx</span>(),
    <span class="hljs-title class_">AutoImport</span>({
      <span class="hljs-attr">imports</span>: [<span class="hljs-string">'vue'</span>, <span class="hljs-string">'vue-router'</span>],
      <span class="hljs-attr">dts</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 生成 TypeScript 声明文件</span>
    })
  ]
})
</code></pre>
<h4 data-id="heading-11">4.构建一个vite项目</h4>
<ul>
<li>安装项目依赖<code>npm init vite</code>,在终端输入</li>
<li>输入项目名称：vite-test</li>
<li>选择项目框架，vue/react，都可以</li>
<li>选择语言，我们选择js</li>
<li>Use rolldown-vite (Experimental)?选择no，这个是问我们是否要选择实验性的打包器，我们不选择，因为其还在实验阶段，可能不稳定，选择no，使用默认的 Rollup 打包器（稳定）</li>
<li>Install with npm and start now?这是 Vite 在询问你是否要使用 npm 安装依赖并立即启动，我们选择yes</li>
<li>最后按住<code>Ctrl</code>键，然后点击<code>Local:   http://localhost:5173/</code>,就可以看到我们的初始化项目了</li>
<li>如图</li>
</ul>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/988ea4abfc9a49ee87913b2b8d9eb734~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQVkxMDI0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766553704&amp;x-signature=T8SXUaS7AKJEjM30LNsTq1PpnaY%3D" alt="屏幕截图 2025-12-17 130611.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a4ece995ee24b6290e2591390d74425~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQVkxMDI0:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766553704&amp;x-signature=N89ISSbi760ARYM7p%2FvAk6qKHJc%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-12">vite目录解析</h3>
<h2 data-id="heading-13"><strong>Vite 项目目录结构解析</strong></h2>
<p>以下是典型的 Vite + Vue 3 项目目录结构及详细解析：</p>
<h3 data-id="heading-14"><strong>基础目录结构</strong></h3>
<pre><code class="hljs language-csharp" lang="csharp">my-vite-project/
├── node_modules/          <span class="hljs-meta"># 依赖包</span>
├── <span class="hljs-keyword">public</span>/               <span class="hljs-meta"># 静态资源（不参与打包）</span>
├── src/                  <span class="hljs-meta"># 源代码目录</span>
├── .gitignore           <span class="hljs-meta"># Git 忽略文件</span>
├── index.html           <span class="hljs-meta"># 项目入口 HTML</span>
├── package.json         <span class="hljs-meta"># 项目配置和依赖</span>
├── package-<span class="hljs-keyword">lock</span>.json    <span class="hljs-meta"># 依赖锁定文件</span>
├── vite.config.js       <span class="hljs-meta"># Vite 配置文件</span>
└── README.md            <span class="hljs-meta"># 项目说明</span>
</code></pre>
<h3 data-id="heading-15"><strong>详细解析</strong></h3>
<h4 data-id="heading-16"><strong>1. <code>node_modules/</code></strong></h4>
<pre><code class="hljs language-bash" lang="bash">node_modules/
└── 所有通过 npm/yarn 安装的依赖包
</code></pre>
<ul>
<li><strong>作用</strong>：存放项目依赖的第三方库</li>
<li><strong>注意</strong>：此文件夹不应提交到 Git，通过 <code>.gitignore</code> 忽略</li>
</ul>
<h4 data-id="heading-17"><strong>2. <code>public/</code> 目录</strong></h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">public</span>/
├── favicon.ico          <span class="hljs-meta"># 网站图标</span>
└── robots.txt           <span class="hljs-meta"># 搜索引擎爬虫协议</span>
</code></pre>
<ul>
<li><strong>作用</strong>：存放不会被处理的静态资源</li>
<li><strong>特点</strong>：
<ul>
<li>不会被 Vite 处理或编译</li>
<li>通过 <code>/</code> 根路径直接访问</li>
<li>例如：<code>public/logo.png</code> 可以通过 <code>/logo.png</code> 访问</li>
</ul>
</li>
</ul>
<h4 data-id="heading-18"><strong>3. <code>src/</code> 目录（核心）</strong></h4>
<pre><code class="hljs language-bash" lang="bash">src/
├── assets/              <span class="hljs-comment"># 静态资源（会被处理）</span>
│   ├── logo.png
│   └── styles/
│       └── main.css
├── components/          <span class="hljs-comment"># 组件目录</span>
│   ├── HelloWorld.vue
│   └── Navbar.vue
├── views/               <span class="hljs-comment"># 页面级组件</span>
│   ├── Home.vue
│   ├── About.vue
│   └── User/
│       ├── Profile.vue
│       └── Settings.vue
├── router/              <span class="hljs-comment"># 路由配置</span>
│   └── index.js
├── stores/              <span class="hljs-comment"># 状态管理（Pinia）</span>
│   └── counter.js
├── utils/               <span class="hljs-comment"># 工具函数</span>
│   └── helpers.js
├── api/                 <span class="hljs-comment"># API 接口</span>
│   └── user.js
├── App.vue              <span class="hljs-comment"># 根组件</span>
└── main.js              <span class="hljs-comment"># 应用入口</span>
</code></pre>
<h4 data-id="heading-19"><strong>4. 关键文件详解</strong></h4>
<h5 data-id="heading-20"><strong><code>index.html</code> - 项目入口</strong></h5>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"image/svg+xml"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/vite.svg"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vite + Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 引入 main.js --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/src/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<ul>
<li><strong>特点</strong>：Vite 将 <code>index.html</code> 作为入口点</li>
<li><strong>ES 模块</strong>：通过 <code>&lt;script type="module"&gt;</code> 支持原生 ES 模块</li>
</ul>
<h5 data-id="heading-21"><strong><code>src/main.js</code> - 应用入口</strong></h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./assets/main.css'</span>

<span class="hljs-comment">// 创建 Vue 应用</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)

<span class="hljs-comment">// 使用插件</span>
app.<span class="hljs-title function_">use</span>(router)

<span class="hljs-comment">// 挂载到 DOM</span>
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>)
</code></pre>
<h5 data-id="heading-22"><strong><code>src/App.vue</code> - 根组件</strong></h5>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;nav&gt;
      &lt;router-link to="/"&gt;Home&lt;/router-link&gt; |
      &lt;router-link to="/about"&gt;About&lt;/router-link&gt;
    &lt;/nav&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;

&lt;style&gt;
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
}
&lt;/style&gt;
</code></pre>
<h5 data-id="heading-23"><strong><code>vite.config.js</code> - Vite 配置</strong></h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
<span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>

<span class="hljs-comment">// https://vitejs.dev/config/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,               <span class="hljs-comment">// 开发服务器端口</span>
    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,               <span class="hljs-comment">// 自动打开浏览器</span>
    <span class="hljs-attr">proxy</span>: {                  <span class="hljs-comment">// 代理配置</span>
      <span class="hljs-string">'/api'</span>: {
        <span class="hljs-attr">target</span>: <span class="hljs-string">'http://localhost:8080'</span>,
        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>
      }
    }
  },
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">alias</span>: {                  <span class="hljs-comment">// 路径别名</span>
      <span class="hljs-string">'@'</span>: <span class="hljs-string">'/src'</span>,
      <span class="hljs-string">'@components'</span>: <span class="hljs-string">'/src/components'</span>
    }
  },
  <span class="hljs-attr">build</span>: {
    <span class="hljs-attr">outDir</span>: <span class="hljs-string">'dist'</span>,           <span class="hljs-comment">// 打包输出目录</span>
    <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span>           <span class="hljs-comment">// 生成 sourcemap</span>
  }
})
</code></pre>
<h4 data-id="heading-24"><strong>5. <code>package.json</code></strong></h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"my-vite-project"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"0.0.0"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"module"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite"</span><span class="hljs-punctuation">,</span>           <span class="hljs-comment">// 开发模式</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite build"</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 生产构建</span>
    <span class="hljs-attr">"preview"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite preview"</span> <span class="hljs-comment">// 预览生产版本</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"vue"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^3.3.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"vue-router"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^4.2.0"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@vitejs/plugin-vue"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^4.2.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"vite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^4.4.0"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-25"><strong>6. 配置文件详解</strong></h4>
<h5 data-id="heading-26"><strong><code>.gitignore</code></strong></h5>
<pre><code class="hljs language-lua" lang="lua"># 依赖
node_modules/

# 构建输出
dist/
dist-ssr/

# 环境变量
.env
.env.<span class="hljs-keyword">local</span>

# 日志
npm-<span class="hljs-built_in">debug</span>.<span class="hljs-built_in">log</span>*
yarn-<span class="hljs-built_in">debug</span>.<span class="hljs-built_in">log</span>*
yarn-<span class="hljs-built_in">error</span>.<span class="hljs-built_in">log</span>*

# 编辑器
.vscode/
.idea/
*.swp
*.swo
</code></pre>
<h5 data-id="heading-27"><strong>环境变量文件</strong></h5>
<pre><code class="hljs language-bash" lang="bash">.<span class="hljs-built_in">env</span>                <span class="hljs-comment"># 所有情况下加载</span>
.env.local          <span class="hljs-comment"># 本地覆盖，不提交到 Git</span>
.env.development    <span class="hljs-comment"># 开发环境</span>
.env.production     <span class="hljs-comment"># 生产环境</span>
.env.test           <span class="hljs-comment"># 测试环境</span>
</code></pre>
<h3 data-id="heading-28"><strong>Vite 特殊目录/文件</strong></h3>
<h4 data-id="heading-29"><strong><code>src/env.d.ts</code> - TypeScript 环境声明</strong></h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">/// &lt;reference types="vite/client" /&gt;</span>

<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">'*.vue'</span> {
  <span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { <span class="hljs-title class_">DefineComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
  <span class="hljs-keyword">const</span> <span class="hljs-attr">component</span>: <span class="hljs-title class_">DefineComponent</span>&lt;{}, {}, <span class="hljs-built_in">any</span>&gt;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> component
}
</code></pre>
<h4 data-id="heading-30"><strong><code>src/auto-imports.d.ts</code> - 自动导入声明</strong></h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">/* eslint-disable */</span>
<span class="hljs-comment">/* prettier-ignore */</span>
<span class="hljs-comment">// @ts-nocheck</span>
<span class="hljs-comment">// Generated by unplugin-auto-import</span>
<span class="hljs-keyword">export</span> {}
<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-attr">ref</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'vue'</span>)[<span class="hljs-string">'ref'</span>]
  <span class="hljs-keyword">const</span> <span class="hljs-attr">reactive</span>: <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'vue'</span>)[<span class="hljs-string">'reactive'</span>]
  <span class="hljs-comment">// ... 其他自动导入的 API</span>
}
</code></pre>
<h3 data-id="heading-31"><strong>项目结构建议</strong></h3>
<h4 data-id="heading-32"><strong>小型项目</strong></h4>
<pre><code class="hljs language-css" lang="css"><span class="hljs-attribute">src</span>/
├── components/
├── views/
├── App<span class="hljs-selector-class">.vue</span>
└── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>
</code></pre>
<h4 data-id="heading-33"><strong>中型项目</strong></h4>
<pre><code class="hljs language-bash" lang="bash">src/
├── assets/
├── components/
│   ├── common/      <span class="hljs-comment"># 通用组件</span>
│   ├── layout/      <span class="hljs-comment"># 布局组件</span>
│   └── ui/          <span class="hljs-comment"># UI 基础组件</span>
├── composables/     <span class="hljs-comment"># 组合式函数</span>
├── router/
├── stores/
├── utils/
├── views/
├── App.vue
└── main.js
</code></pre>
<h4 data-id="heading-34"><strong>大型项目</strong></h4>
<pre><code class="hljs language-bash" lang="bash">src/
├── api/             <span class="hljs-comment"># API 接口管理</span>
├── assets/
├── components/
├── composables/
├── directives/      <span class="hljs-comment"># 自定义指令</span>
├── filters/         <span class="hljs-comment"># 过滤器（Vue 2）</span>
├── i18n/           <span class="hljs-comment"># 国际化</span>
├── layouts/         <span class="hljs-comment"># 布局组件</span>
├── middleware/      <span class="hljs-comment"># 中间件</span>
├── plugins/         <span class="hljs-comment"># 插件</span>
├── router/
├── stores/
├── types/          <span class="hljs-comment"># TypeScript 类型定义</span>
├── utils/
├── views/
├── App.vue
└── main.js
</code></pre>
<h3 data-id="heading-35">Vite 的优势总结</h3>
<h4 data-id="heading-36">✅ 显著优势：</h4>
<ol>
<li><strong>极速启动</strong>：冷启动时间比 Webpack 快 10-100 倍</li>
<li><strong>即时更新</strong>：HMR 更新几乎无感知延迟</li>
<li><strong>开发友好</strong>：错误提示清晰，配置简单</li>
<li><strong>现代化</strong>：原生支持 ES 模块、TypeScript 等</li>
<li><strong>生态完善</strong>：与 Vue、React、Svelte 等框架深度集成</li>
<li><strong>插件丰富</strong>：活跃的插件生态系统</li>
</ol>
<h4 data-id="heading-37">⚠️ 需要考虑的点：</h4>
<ol>
<li>
<p><strong>浏览器兼容性</strong></p>
<ul>
<li>开发依赖现代浏览器（支持原生 ES 模块）</li>
<li>生产构建会自动转换为兼容格式</li>
</ul>
</li>
<li>
<p><strong>生态成熟度</strong></p>
<ul>
<li>相比 Webpack，部分插件和工具链仍在完善中</li>
<li>大型企业级应用迁移需要考虑现有工具链兼容性</li>
</ul>
</li>
<li>
<p><strong>构建优化</strong></p>
<ul>
<li>生产构建基于 Rollup，对于超大型项目可能需要额外优化</li>
<li>代码分割策略需要手动配置</li>
</ul>
</li>
<li>
<p><strong>SSR 支持</strong></p>
<ul>
<li>Vite 的 SSR 支持相对较新，部分场景可能需要更多配置</li>
</ul>
</li>
</ol>
<h3 data-id="heading-38">实际性能对比</h3>



































<table><thead><tr><th>指标</th><th>Webpack</th><th>Vite</th></tr></thead><tbody><tr><td>冷启动（小型项目）</td><td>5-10s</td><td>50-200ms</td></tr><tr><td>冷启动（大型项目）</td><td>30-60s</td><td>1-3s</td></tr><tr><td>HMR 更新</td><td>1-3s</td><td>10-100ms</td></tr><tr><td>生产构建</td><td>优秀</td><td>优秀</td></tr><tr><td>配置复杂度</td><td>高</td><td>低</td></tr></tbody></table>
<h4 data-id="heading-39">结语：以上就是对vite的介绍和使用教程了，望学习愉快！！！</h4></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[从思想到实践：前端工程化体系与 Webpack 构建架构深度解析]]></title>    <link>https://juejin.cn/post/7584339190035316776</link>    <guid>https://juejin.cn/post/7584339190035316776</guid>    <pubDate>2025-12-17T05:43:57.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584339190035316776" data-draft-id="7584377629706305571" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="从思想到实践：前端工程化体系与 Webpack 构建架构深度解析"/> <meta itemprop="keywords" content="前端,前端工程化"/> <meta itemprop="datePublished" content="2025-12-17T05:43:57.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="5C24"/> <meta itemprop="url" content="https://juejin.cn/user/571401779288456"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            从思想到实践：前端工程化体系与 Webpack 构建架构深度解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/571401779288456/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    5C24
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T05:43:57.000Z" title="Wed Dec 17 2025 05:43:57 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">工程化思想抽象</h2>
<h3 data-id="heading-1">1.工程化的本质目标</h3>
<ul>
<li>标准化: 统一代码规范、目录结构、开发流程</li>
<li>自动化: 减少人工重复劳动，降低人为失误</li>
<li>模块化: 分离关注点，提升代码复用性和可维护性</li>
</ul>
<h3 data-id="heading-2">2.核心流程</h3>
<pre><code class="hljs language-rust" lang="rust">┌─────────────┐      ┌──────────────┐      ┌─────────────┐      ┌──────────────┐
   业务源码层      -<span class="hljs-punctuation">-&gt;</span>    解析引擎        -<span class="hljs-punctuation">-&gt;</span>    构建产物       -<span class="hljs-punctuation">-&gt;</span>     Koa 渲染   
└─────────────┘      └──────────────┘      └─────────────┘      └──────────────┘
   .vue/.js             编译/分包/优化        .js/.css/.tpl         页面输出
</code></pre>
<h4 data-id="heading-3">2.1业务源码层</h4>
<ul>
<li>使用高级语言特性(ES6+ CSS预处理器 Typescript)</li>
<li>组件化/模块化开发方式</li>
<li>面向开发者的可读性和表达力</li>
<li>产物包括 .vue .jsx .scss .ts等源码文件</li>
</ul>
<h4 data-id="heading-4">2.2解析引擎</h4>
<p>这是工程化的核心，负责将"对人类友好的代码" -&gt; “对机器友好的代码”</p>
<h5 data-id="heading-5">2.2.1解析编译</h5>
<p>核心任务: 模块依赖分析与语法转译</p>
<p>入口发现 -&gt; 依赖分析 -&gt; 语法转译 -&gt; 产物输出</p>
<ul>
<li>入口发现：通过文件命名规范自动发现入口(eg. entry.*.js)</li>
<li>依赖分析</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">entry.page1.js
    ├─&gt; page1.vue
    │   ├─&gt; common/utils.js
    │   └─&gt; styles/page1.less
    ├─&gt; axios (第三方)
    └─&gt; vue (第三方)
</code></pre>
<ul>
<li>语法转译</li>
</ul>
<pre><code class="hljs">源格式	    目标格式	    转译内容
Vue SFC	    JS + CSS	模板编译、样式提取
ES6+	    ES5	        语法降级、Polyfill
Less/Sass   CSS	        预处理器编译
TypeScript	JavaScript	类型擦除、语法转译
图片/字体	Base64/URL	资源处理
</code></pre>
<ul>
<li>产物输出: 将编译后的资源自动注入到 tpl 中</li>
</ul>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 源模板 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 注入后 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/dist/entry.page1.css"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/dist/vendor.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/dist/entry.page1.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h5 data-id="heading-6">2.2.2模块分包</h5>
<p>核心任务: 将代码按变化频率和复用关系拆分，最大化缓存利用率</p>
<pre><code class="hljs language-scss" lang="scss">┌─────────────────────────────────────────────────┐
│  第三方依赖层 (Vendor Layer)                     │
│  - React/Vue/Angular 等框架                      │
│  - 工具库 (lodash/axios/moment)                 │
│  - 特点：几乎不变，除非升级依赖                   │
│  - 缓存策略：长效缓存（数月甚至永久）              │
├─────────────────────────────────────────────────┤
│  公共业务模块层 (Common Layer)                   │
│  - 跨页面复用的组件 (Header/Footer)              │
│  - 通用工具函数 (utils/helpers)                  │
│  - 特点：偶尔变化，改动频率较低                   │
│  - 缓存策略：中期缓存（数周）                     │
├─────────────────────────────────────────────────┤
│  页面差异化逻辑层 (Entry Layer)                  │
│  - 各页面独有的业务逻辑                          │
│  - 页面级组件                                    │
│  - 特点：频繁变化，跟随需求迭代                   │
│  - 缓存策略：短期缓存（数天）                     │
├─────────────────────────────────────────────────┤
│  运行时层 (Runtime Layer)                       │
│  - 模块加载器逻辑                                │
│  - Chunk 映射关系                               │
│  - 特点：随每次构建变化                          │
│  - 缓存策略：不依赖内容缓存                      │
└─────────────────────────────────────────────────┘
</code></pre>
<p>分包决策</p>
<ul>
<li>优先级判定: vendor -&gt; common -&gt; entry</li>
<li>复用度计算: 被N个入口引用则提升到 common 层</li>
<li>体积阈值: 过小的模块不单独拆分(减少 HTTP 请求)</li>
</ul>
<p>效果量化</p>
<p>假设用户连续访问3个页面</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">传统单包方案：</span>
  <span class="hljs-attr">Page1:</span> <span class="hljs-string">800KB</span> <span class="hljs-string">(下载)</span>
  <span class="hljs-attr">Page2:</span> <span class="hljs-string">750KB</span> <span class="hljs-string">(下载)</span>
  <span class="hljs-attr">Page3:</span> <span class="hljs-string">820KB</span> <span class="hljs-string">(下载)</span>
  <span class="hljs-string">总流量:</span> <span class="hljs-string">2370KB</span>

<span class="hljs-string">分包方案：</span>
  <span class="hljs-attr">Page1:</span> <span class="hljs-string">300KB(vendor)</span> <span class="hljs-string">+</span> <span class="hljs-string">50KB(common)</span> <span class="hljs-string">+</span> <span class="hljs-string">80KB(entry1)</span> <span class="hljs-string">=</span> <span class="hljs-string">430KB</span>
  <span class="hljs-attr">Page2:</span> <span class="hljs-string">(缓存)</span> <span class="hljs-string">+</span> <span class="hljs-string">(缓存)</span> <span class="hljs-string">+</span> <span class="hljs-string">70KB(entry2)</span> <span class="hljs-string">=</span> <span class="hljs-string">70KB</span>
  <span class="hljs-attr">Page3:</span> <span class="hljs-string">(缓存)</span> <span class="hljs-string">+</span> <span class="hljs-string">(缓存)</span> <span class="hljs-string">+</span> <span class="hljs-string">90KB(entry3)</span> <span class="hljs-string">=</span> <span class="hljs-string">90KB</span>
  <span class="hljs-string">总流量:</span> <span class="hljs-string">590KB</span> <span class="hljs-string">(节省</span> <span class="hljs-number">75</span><span class="hljs-string">%)</span>
</code></pre>
<h5 data-id="heading-7">2.2.3压缩优化</h5>
<p>核心任务: 根据运行环境的差异，执行不同的优化策略</p>
<pre><code class="hljs language-javascript" lang="javascript">维度	         开发环境	           生产环境
核心目标	     快速迭代 + 便捷调试      极致性能 + 最小体积
构建速度	     极速（秒级）	           可接受慢（分钟级）
代码可读性	 保留（需要调试）	       可丢弃（压缩混淆）
<span class="hljs-title class_">Source</span> <span class="hljs-title class_">Map</span>	 完整映射	           可选/隐藏
模块热替换	 必须支持	           不需要
</code></pre>
<p>开发环境优化策略</p>
<ul>
<li>
<p>增量编译</p>
<ul>
<li>只重新编译变化的模块</li>
<li>利用缓存跳过未变化的依赖</li>
</ul>
</li>
<li>
<p>资源内存化</p>
<ul>
<li>构建产物写入内存而非磁盘</li>
<li>减少 I/O 开销，提升重新构建速度</li>
</ul>
</li>
<li>
<p>热更新(HMR)</p>
</li>
</ul>
<pre><code class="hljs language-rust" lang="rust">文件变化 <span class="hljs-punctuation">-&gt;</span> 增量编译 <span class="hljs-punctuation">-&gt;</span> 推送更新清单 <span class="hljs-punctuation">-&gt;</span> 浏览器热更新
    ↑                                          ↓
    └────────── WebSocket/SSE 长连接 ───────────┘
</code></pre>
<ul>
<li>Source Map生成: 建立 "转译后代码" -&gt; “源码”的映射关系</li>
</ul>
<p>生产环境优化策略</p>
<ul>
<li>
<p>代码压缩(Minification)</p>
<ul>
<li>移除空白字符、注释</li>
<li>变量名混淆(userName -&gt; a)</li>
<li>函数内联、常规折叠</li>
</ul>
</li>
<li>
<p>Tree Shaking: 基于 ES Module 的静态分析，移除未使用的导出</p>
</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// utils.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) { <span class="hljs-keyword">return</span> a + b; }
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">subtract</span>(<span class="hljs-params">a, b</span>) { <span class="hljs-keyword">return</span> a - b; }  <span class="hljs-comment">// 未被使用</span>

<span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> { add } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));

<span class="hljs-comment">// 最终产物（subtract 被删除）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) { <span class="hljs-keyword">return</span> a + b; }
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
</code></pre>
<ul>
<li>
<p>资源提取与并行加载</p>
<ul>
<li>CSS 提取为独立文件(JS 和 CSS 并行下载)</li>
<li>图片转 Base64 内联(减少小资源的 HTTP 请求)</li>
</ul>
</li>
<li>
<p>多线程并行处理(利用 CPU 多核能力，将编译任务分发到多个进程)</p>
</li>
</ul>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">主进程</span>
  <span class="hljs-string">├─&gt;</span> <span class="hljs-attr">Worker 1:</span> <span class="hljs-string">编译模块</span> <span class="hljs-string">A</span>
  <span class="hljs-string">├─&gt;</span> <span class="hljs-attr">Worker 2:</span> <span class="hljs-string">编译模块</span> <span class="hljs-string">B</span>
  <span class="hljs-string">├─&gt;</span> <span class="hljs-attr">Worker 3:</span> <span class="hljs-string">编译模块</span> <span class="hljs-string">C</span>
  <span class="hljs-string">└─&gt;</span> <span class="hljs-attr">Worker 4:</span> <span class="hljs-string">编译模块</span> <span class="hljs-string">D</span>
</code></pre>
<h4 data-id="heading-8">2.3构建产物</h4>
<p>输出可直接部署的静态资源</p>
<ul>
<li>浏览器可直接执行的标准格式(ES5 JS、 CSS3)</li>
<li>文件带 hash 支持版本控制</li>
<li>按模块拆分，支持按需加载</li>
</ul>
<h4 data-id="heading-9">2.4运行产物(服务端渲染)</h4>
<p>服务端渲染模版并响应给浏览器</p>
<pre><code class="hljs language-bash" lang="bash">浏览器请求 /page1
    ↓
后端路由匹配
    ↓
读取 entry.page1.tpl 模板
    ↓
注入动态数据 (用户信息、环境变量等)
    ↓
返回完整 HTML
    ↓
浏览器解析并加载 JS/CSS 资源
</code></pre>
<h3 data-id="heading-10">3.工程化的横向关注点</h3>
<h4 data-id="heading-11">3.1约定优于配置</h4>
<p>通过统一的命名规范和目录结构，减少显示配置</p>
<ul>
<li>配置模式</li>
</ul>
<pre><code class="hljs language-css" lang="css">entry: {
  page1: <span class="hljs-string">'./pages/page1/entry.page1.js'</span>,
  page2: <span class="hljs-string">'./pages/page2/entry.page2.js'</span>,
  page3: <span class="hljs-string">'./pages/page3/entry.page3.js'</span>
}
</code></pre>
<ul>
<li>约定模式</li>
</ul>
<pre><code class="hljs language-bash" lang="bash">pages/
  ├── page1/entry.page1.js  ✓ 自动识别
  ├── page2/entry.page2.js  ✓ 自动识别
  └── page3/entry.page3.js  ✓ 自动识别
</code></pre>
<p>约定模式的优势</p>
<ul>
<li>零配置扩展，降低认知负担</li>
<li>规范及文档，团队人员能快速上手</li>
</ul>
<h4 data-id="heading-12">3.2环境隔离</h4>
<p>不同环境采用不同的构建策略，避免配置污染</p>
<pre><code class="hljs language-scss" lang="scss">基础配置 (Base Config)
     ├─&gt; 开发环境配置 (Dev Config)
     └─&gt; 生产环境配置 (Prod Config)
</code></pre>
<h4 data-id="heading-13">3.3模块解析策略</h4>
<ul>
<li>路径别名</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 配置前</span>
<span class="hljs-keyword">import</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../common/utils'</span>;

<span class="hljs-comment">// 配置后</span>
<span class="hljs-keyword">import</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">'$common/utils'</span>;
</code></pre>
<ul>
<li>自动扩展名补全</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 配置前</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyComponent.vue'</span>;

<span class="hljs-comment">// 配置后</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyComponent'</span>;  <span class="hljs-comment">// 自动补全 .vue</span>
</code></pre>
<h4 data-id="heading-14">3.4依赖注入模式</h4>
<p>全局依赖自动注入</p>
<p>对于高频使用的库(如 ui 框架、vue等)，可配置自动注入，无需每个文件手动 import</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// 源码（无需显式 import）</span>
<span class="hljs-keyword">new</span> Vue({ el: <span class="hljs-string">'#app'</span> });
axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/api/data'</span>);

<span class="hljs-comment">// 构建工具自动注入</span>
import Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
import axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span>;
<span class="hljs-keyword">new</span> Vue({ el: <span class="hljs-string">'#app'</span> });
axios.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/api/data'</span>);
</code></pre>
<h2 data-id="heading-15">Webpack工程化实现</h2>
<h3 data-id="heading-16">1.Webpack 在工程化中的定义</h3>
<p>Webpack 在工程化架构中扮演"编译转换层"的角色，负责</p>
<ul>
<li>解析模块依赖关系</li>
<li>调度各种 loader 转译资源</li>
<li>执行 plugin 扩展构建流程</li>
<li>输出优化后的构建产物</li>
</ul>
<h3 data-id="heading-17">2.解析编译的 Webpack 实现</h3>
<h4 data-id="heading-18">2.1入口发现</h4>
<p>实现原理</p>
<ul>
<li>glob.sync() 同步扫描文件</li>
<li>path.basename() 提取出文件名作为入口名称</li>
<li>最终生成如 { 'entry.page1': './app/pages/page1/entry.page1.js' }</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">glob</span> = require(<span class="hljs-string">'glob'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">pageEntries</span> = {}<span class="hljs-comment">;</span>

// 获取 app/pages 目录下所有入口文件 (entry.xx.js)
const <span class="hljs-attr">entryList</span> = path.resolve(process.cwd(), <span class="hljs-string">'./app/pages/**/entry.*.js'</span>)<span class="hljs-comment">;</span>
glob.sync(entryList).forEach((file) =&gt; {
  const <span class="hljs-attr">entryName</span> = path.basename(file, <span class="hljs-string">'.js'</span>)<span class="hljs-comment">;</span>
  // 构造 entry
  pageEntries<span class="hljs-section">[entryName]</span> = file<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>

<span class="hljs-attr">module.exports</span> = {
  entry: pageEntries  // 动态生成的多入口配置
}<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-19">2.2资源转译</h4>
<p>Webpack 通过 loader 链式调用，实现资源转译</p>
<ul>
<li>vue sfc 处理</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript">{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.vue$/</span>,
  <span class="hljs-attr">use</span>: <span class="hljs-string">'vue-loader'</span>
}

<span class="hljs-attr">plugins</span>: [
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueLoaderPlugin</span>()  <span class="hljs-comment">// 将其他规则应用到 .vue 文件的各个块</span>
]
</code></pre>
<ul>
<li>JavaScript 转译</li>
</ul>
<pre><code class="hljs language-css" lang="css">{
  test: /.js$/,
  include: [path.<span class="hljs-built_in">resolve</span>(process.<span class="hljs-built_in">cwd</span>(), <span class="hljs-string">'./app/pages'</span>)],  // 只处理业务代码，加快打包速度
  use: <span class="hljs-string">'babel-loader'</span>
}
</code></pre>
<ul>
<li>样式处理链</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 开发环境</span>
{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.less$/</span>,
  <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'less-loader'</span>]
}

<span class="hljs-comment">// 生产环境</span>
{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.less$/</span>,
  <span class="hljs-attr">use</span>: [<span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'less-loader'</span>]
  <span class="hljs-comment">// 执行顺序 less-loader -&gt; css-loader -&gt; MiniCssExtractPlugin.loader</span>
}
</code></pre>
<ul>
<li>静态资源处理</li>
</ul>
<pre><code class="hljs language-yaml" lang="yaml">{
  <span class="hljs-attr">test:</span> <span class="hljs-string">/.(png|jpg|jpeg|gif)(?.+)?$/</span>,
  <span class="hljs-attr">use:</span> {
    <span class="hljs-attr">loader:</span> <span class="hljs-string">'url-loader'</span>,
    <span class="hljs-attr">options:</span> {
      <span class="hljs-attr">limit:</span> <span class="hljs-number">300</span>,  <span class="hljs-string">//</span> <span class="hljs-string">小于</span> <span class="hljs-number">300</span> <span class="hljs-string">字节转</span> <span class="hljs-string">base64</span>
      <span class="hljs-attr">esModule:</span> <span class="hljs-literal">false</span>
    }
  }
}
</code></pre>
<h4 data-id="heading-20">2.3产物注入实现</h4>
<p>通过 html-webpack-plugin 自动生产 HTML 并注入资源</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-tag">const</span> <span class="hljs-selector-tag">htmlWebpackPluginList</span> = <span class="hljs-selector-attr">[]</span>;

<span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.keys</span>(pageEntries)<span class="hljs-selector-class">.forEach</span>((entryName) =&gt; {
  <span class="hljs-selector-tag">htmlWebpackPluginList</span><span class="hljs-selector-class">.push</span>(
    new <span class="hljs-built_in">HtmlWebpackPlugin</span>({
      <span class="hljs-attribute">filename</span>: path.<span class="hljs-built_in">resolve</span>(process.<span class="hljs-built_in">cwd</span>(), <span class="hljs-string">'./app/public/dist/'</span>, <span class="hljs-built_in">`${entryName}.tpl`</span>),
      <span class="hljs-attribute">template</span>: path.<span class="hljs-built_in">resolve</span>(process.<span class="hljs-built_in">cwd</span>(), <span class="hljs-string">'./app/view/entry.tpl'</span>),
      <span class="hljs-attribute">chunks</span>: [entryName]  <span class="hljs-comment">// 只注入当前入口的 chunk</span>
    })
  );
});

<span class="hljs-selector-tag">module</span><span class="hljs-selector-class">.exports</span> = {
  plugins: [...htmlWebpackPluginList]
};
</code></pre>
<h3 data-id="heading-21">3.模块分包的 Webpack 实现</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">optimization:</span> {
  <span class="hljs-attr">splitChunks:</span> {
    <span class="hljs-attr">chunks:</span> <span class="hljs-string">'all'</span>, <span class="hljs-string">//</span> <span class="hljs-string">对同步和异步模块都进行分割</span>
    <span class="hljs-attr">maxAsyncRequests:</span> <span class="hljs-number">10</span>, <span class="hljs-string">//</span> <span class="hljs-string">每次异步加载的最大并行请求数</span>
    <span class="hljs-attr">maxInitialRequests:</span> <span class="hljs-number">10</span>, <span class="hljs-string">//</span> <span class="hljs-string">初始加载的最大并行请求数</span>
    <span class="hljs-attr">cacheGroups:</span> {
      <span class="hljs-string">//</span> <span class="hljs-string">第三方依赖层</span>
      <span class="hljs-attr">vendor:</span> {
        <span class="hljs-attr">test:</span> <span class="hljs-string">/</span>[<span class="hljs-string">\/</span>]<span class="hljs-string">node_modules</span>[<span class="hljs-string">\/</span>]<span class="hljs-string">/</span>,
        <span class="hljs-attr">name:</span> <span class="hljs-string">'vendor'</span>, <span class="hljs-string">//</span> <span class="hljs-string">模块名称</span>
        <span class="hljs-attr">priority:</span> <span class="hljs-number">20</span>, <span class="hljs-string">//</span> <span class="hljs-string">优先级，值越大优先级越高</span>
        <span class="hljs-attr">enforce:</span> <span class="hljs-literal">true</span>, <span class="hljs-string">//</span> <span class="hljs-string">强制执行</span>
        <span class="hljs-attr">reuseExistingChunk:</span> <span class="hljs-literal">true</span> <span class="hljs-string">//</span> <span class="hljs-string">复用已有的公共</span> <span class="hljs-string">chunk</span>
      },
      <span class="hljs-string">//</span> <span class="hljs-string">公共业务模块层</span>
      <span class="hljs-attr">common:</span> {
        <span class="hljs-attr">name:</span> <span class="hljs-string">'common'</span>,
        <span class="hljs-attr">minChunks:</span> <span class="hljs-number">2</span>, <span class="hljs-string">//</span> <span class="hljs-string">被至少</span> <span class="hljs-number">2</span> <span class="hljs-string">个</span> <span class="hljs-string">chunk</span> <span class="hljs-string">引用</span>
        <span class="hljs-attr">minSize:</span> <span class="hljs-number">1</span>, <span class="hljs-string">//</span> <span class="hljs-string">最小分割文件大小(此处</span> <span class="hljs-number">1</span> <span class="hljs-string">byte</span> <span class="hljs-string">方便于测试)</span>
        <span class="hljs-attr">priority:</span> <span class="hljs-number">10</span>,
        <span class="hljs-attr">reuseExistingChunk:</span> <span class="hljs-literal">true</span>
      }
    }
  },
  <span class="hljs-string">//</span> <span class="hljs-string">将</span> <span class="hljs-string">webpack</span> <span class="hljs-string">运行时生成的代码打包到</span> <span class="hljs-string">runtime.js</span>
  <span class="hljs-attr">runtimeChunk:</span> <span class="hljs-literal">true</span>
}
</code></pre>
<h3 data-id="heading-22">4.压缩优化的 Webpack 实现</h3>
<h4 data-id="heading-23">4.1开发环境实现</h4>
<ul>
<li>Source Map</li>
</ul>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-symbol">mode:</span> <span class="hljs-comment">'development',</span>
<span class="hljs-symbol">devtool:</span> <span class="hljs-comment">'eval-cheap-module-source-map'</span>
</code></pre>
<ul>
<li>热更新(HMR)</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 入口改造：注入 HMR 客户端</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(baseConfig.<span class="hljs-property">entry</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">v</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (v !== <span class="hljs-string">'vendor'</span>) {
    baseConfig.<span class="hljs-property">entry</span>[v] = [
      baseConfig.<span class="hljs-property">entry</span>[v],
      <span class="hljs-string">`webpack-hot-middleware/client?path=http://127.0.0.1:9002/__webpack_hmr&amp;timeout=20000&amp;reload=true`</span>
    ];
  }
});

<span class="hljs-comment">// 插件配置</span>
<span class="hljs-attr">plugins</span>: [
  <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">HotModuleReplacementPlugin</span>({
    <span class="hljs-attr">multiStep</span>: <span class="hljs-literal">false</span>
  })
]
</code></pre>
<ul>
<li>开发服务器</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">express</span> = require(<span class="hljs-string">'express'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">webpack</span> = require(<span class="hljs-string">'webpack'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">devMiddleware</span> = require(<span class="hljs-string">'webpack-dev-middleware'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">hotMiddleware</span> = require(<span class="hljs-string">'webpack-hot-middleware'</span>)<span class="hljs-comment">;</span>

const <span class="hljs-attr">app</span> = express()<span class="hljs-comment">;</span>
const <span class="hljs-attr">compiler</span> = webpack(webpackConfig)<span class="hljs-comment">;</span>

// 监听文件变化，增量编译
app.use(devMiddleware(compiler, {
  writeToDisk: (filepath) =&gt; filepath.endsWith('.tpl'),  // 只有 .tpl 落盘
  publicPath: webpackConfig.output.publicPath
}))<span class="hljs-comment">;</span>

// 引入 hotMiddleware 中间件 (实现热更新通讯)
app.use(hotMiddleware(compiler, {
  path: '/__webpack_hmr'
}))<span class="hljs-comment">;</span>

app.listen(9002)<span class="hljs-comment">;</span>
</code></pre>
<h4 data-id="heading-24">4.2生产环境实现</h4>
<ul>
<li>JavaScript 压缩</li>
</ul>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">optimization:</span> {
  <span class="hljs-attr">minimize:</span> <span class="hljs-literal">true</span>,
  <span class="hljs-attr">minimizer:</span> [
    <span class="hljs-string">new</span> <span class="hljs-string">TerserWebpackPlugin(</span>{
      <span class="hljs-attr">cache:</span> <span class="hljs-literal">true</span>,
      <span class="hljs-attr">parallel:</span> <span class="hljs-literal">true</span>,
      <span class="hljs-attr">terserOptions:</span> {
        <span class="hljs-attr">compress:</span> {
          <span class="hljs-attr">drop_console:</span> <span class="hljs-literal">true</span>  <span class="hljs-string">//</span> <span class="hljs-string">移除</span> <span class="hljs-string">console.log</span>
        }
      }
    }<span class="hljs-string">)</span>
  ]
}
</code></pre>
<ul>
<li>CSS 提取与压缩</li>
</ul>
<pre><code class="hljs language-arduino" lang="arduino">plugins: [
  <span class="hljs-comment">// 提取 CSS</span>
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">MiniCssExtractPlugin</span>({
    chunkFilename: <span class="hljs-string">'css/[name]_[chunkhash:8].chunk.css'</span>
  }),
  <span class="hljs-comment">// 压缩 CSS</span>
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">CssMinimizerPlugin</span>()
]
</code></pre>
<ul>
<li>多线程编译</li>
</ul>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-string">//</span> <span class="hljs-string">在</span> <span class="hljs-string">module.rules</span> <span class="hljs-string">中直接配置</span>
{
  <span class="hljs-attr">test:</span> <span class="hljs-string">/.js$/</span>,
  <span class="hljs-attr">use:</span> [
    {
      <span class="hljs-attr">loader:</span> <span class="hljs-string">'thread-loader'</span>,
      <span class="hljs-attr">options:</span> {
        <span class="hljs-attr">workers:</span> <span class="hljs-number">2</span>,
        <span class="hljs-attr">workerParallelJobs:</span> <span class="hljs-number">50</span>,
        <span class="hljs-attr">poolTimeout:</span> <span class="hljs-number">2000</span>
      }
    },
    <span class="hljs-string">'babel-loader'</span>
  ]
}
</code></pre>
<ul>
<li>构建前清理</li>
</ul>
<pre><code class="hljs language-css" lang="css">plugins: [
  new <span class="hljs-built_in">CleanWebpackPlugin</span>([<span class="hljs-string">'public/dist'</span>], {
    root: path.<span class="hljs-built_in">resolve</span>(process.<span class="hljs-built_in">cwd</span>(), <span class="hljs-string">'./app/'</span>),
    verbose: true,
    dry: false
  })
]
</code></pre>
<h3 data-id="heading-25">5.其他 Webpack 工程化配置</h3>
<h4 data-id="heading-26">5.1模块解析配置</h4>
<pre><code class="hljs language-css" lang="css">resolve: {
  extensions: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.vue'</span>, <span class="hljs-string">'.less'</span>, <span class="hljs-string">'.css'</span>],
  alias: {
    $pages: path.<span class="hljs-built_in">resolve</span>(process.<span class="hljs-built_in">cwd</span>(), <span class="hljs-string">'./app/pages'</span>),
    $common: path.<span class="hljs-built_in">resolve</span>(process.<span class="hljs-built_in">cwd</span>(), <span class="hljs-string">'./app/pages/common'</span>),
    $widgets: path.<span class="hljs-built_in">resolve</span>(process.<span class="hljs-built_in">cwd</span>(), <span class="hljs-string">'./app/pages/widgets'</span>),
    $store: path.<span class="hljs-built_in">resolve</span>(process.<span class="hljs-built_in">cwd</span>(), <span class="hljs-string">'./app/pages/store'</span>)
  }
}
</code></pre>
<h4 data-id="heading-27">5.2全局依赖注入</h4>
<pre><code class="hljs language-php" lang="php">plugins: [
  <span class="hljs-keyword">new</span> webpack.<span class="hljs-title function_ invoke__">ProvidePlugin</span>({
    <span class="hljs-attr">Vue</span>: <span class="hljs-string">'vue'</span>,
    <span class="hljs-attr">axios</span>: <span class="hljs-string">'axios'</span>,
    <span class="hljs-attr">_</span>: <span class="hljs-string">'lodash'</span>
  })
]
</code></pre>
<h4 data-id="heading-28">5.1Vue编译选项</h4>
<pre><code class="hljs language-php" lang="php">plugins: [
  <span class="hljs-keyword">new</span> webpack.<span class="hljs-title function_ invoke__">DefinePlugin</span>({
    <span class="hljs-attr">__VUE_OPTIONS_API__</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">__VUE_PROD_DEVTOOLS__</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">__VUE_PROD_HYDRATION_MISMATCH_DETAILS__</span>: <span class="hljs-literal">false</span>
  })
]
</code></pre>
<h4 data-id="heading-29">5.1配置分层设计</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// webpack.base.js - 基础配置</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = { entry, <span class="hljs-keyword">module</span>, resolve, plugins, optimization };

<span class="hljs-comment">// webpack.dev.js - 开发环境</span>
<span class="hljs-type">const</span> <span class="hljs-variable">merge</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">'webpack-merge'</span>);
<span class="hljs-type">const</span> <span class="hljs-variable">baseConfig</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">'./webpack.base'</span>);

<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = merge.smart(baseConfig, {
  mode: <span class="hljs-string">'development'</span>,
  devtool: <span class="hljs-string">'eval-cheap-module-source-map'</span>,
  plugins: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">webpack</span>.HotModuleReplacementPlugin()]
});

<span class="hljs-comment">// webpack.prod.js - 生产环境</span>
<span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = merge.smart(baseConfig, {
  mode: <span class="hljs-string">'production'</span>,
  plugins: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>()]
});
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让智能家居“听懂人话”：我用4B模型+万条数据，教会了它理解复杂指令]]></title>    <link>https://juejin.cn/post/7584379805898948660</link>    <guid>https://juejin.cn/post/7584379805898948660</guid>    <pubDate>2025-12-17T05:44:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584379805898948660" data-draft-id="7584339190034776104" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让智能家居“听懂人话”：我用4B模型+万条数据，教会了它理解复杂指令"/> <meta itemprop="keywords" content="AIGC,深度学习"/> <meta itemprop="datePublished" content="2025-12-17T05:44:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="架构师李哲"/> <meta itemprop="url" content="https://juejin.cn/user/2165417409774523"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让智能家居“听懂人话”：我用4B模型+万条数据，教会了它理解复杂指令
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2165417409774523/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    架构师李哲
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T05:44:48.000Z" title="Wed Dec 17 2025 05:44:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在智能家居场景中，我们经常遇到这样的尴尬：</p>
<p>你说：“把灯打开。” —— 它可以执行。</p>
<p>你说：“如果检测到漏水，就把水阀关了并发个通知。” —— 它可能听不懂了。</p>
<p>你说：“有点冷，把空调调高一点。” —— 它问你：“一点是多少？”</p>
<p>在物联网（IoT）时代，我们希望智能家居不仅仅是“遥控器”，而是能听懂人话的“管家”。</p>
<p>我们测试了市面上几款主流大模型——它们的回答五花八门，有的直接调风速但忘了时间设置，有的创建了时间触发却丢失了条件判断，甚至还有把指令误解为“设定闹钟”的。真正能完美解析出“延时+条件+多参数”三重嵌套指令的模型，凤毛麟角。</p>
<p>今天，我们将通过一次完整的实战，展示如何基于 LLaMA Factory Online 平台，利用高质量数据清洗和微调，让轻量级的 Qwen3-4B 模型在智能家居垂直场景下，不仅能听懂“把风速调小一点”这种模糊指令，还能处理“检测到漏水即关闭水阀”的复杂链式操作。</p>
<h2 data-id="heading-0">效果对比：微调前 vs 微调后</h2>
<p>在开始硬核教程前，我们先来看看微调后的模型到底变聪明了多少。</p>
<h3 data-id="heading-1">场景一：条件触发- 从“被动响应”到“主动感知”</h3>
<p>场景描述：传统智能家居本质是“语音遥控器”，用户不开口，设备不工作；微调后的模型具有主观能动性，它不仅仅是执行者，更是决策者，能够基于传感器数据（时间、温度、光线、气体浓度等）的变化，自主决策并触发相应的设备控制，如空调、新风、窗帘等设备，动态维持环境的最佳状态，实现真正的“空间智能”。</p>
<p>用户指令："半小时后请把空气净化器的风速调大到3档位"</p>




















<table><thead><tr><th>微调前后</th><th>原始数据集微调后的模型</th><th>优化后的数据集微调后的模型</th></tr></thead><tbody><tr><td>模型输出</td><td>{"mcp_type": "iot","function": "control_device", "params": {"device_id": "purifier_bedroom_01", "level": 3}, "confirm": false}</td><td>{"mcp_type": "sensor_trigger", "function": "create_automation", "params": {"trigger": {"type":"time_delay", "minutes":30}, "action": {"device_id": "purifier_bedroom_01", "arg": {"op": "control_device", "level":3}}}, "confirm": false}</td></tr><tr><td>分析与评价</td><td>指令解读：mcp_type: IoT 控制消息。function: 设置风速。params: {设备ID，挡位：3}评价：缺少延时条件，缺少相对调整量（delta），设备端无法确定要“设为多少”或“调多少”。</td><td>指令解读：mcp_type: IoT 控制消息。function: 设置风速。params: {触发条件：30分钟后，动作：给出设备ID，风速减小1。}评价：触发条件完整，风速相对调整量完整。</td></tr></tbody></table>
<h3 data-id="heading-2">场景二：链式操作-从“单点控制”到“逻辑编排”</h3>
<p>场景描述：通过微调优化模型的逻辑推理与任务规划能力，将单一的指令转化为一系列具有逻辑依赖关系的设备协同动作。用户无需逐个下达指令（如“打开电视”、“拉上窗帘”、“调暗灯光”），只需表达最终目的，中间的步骤由模型自动补全。</p>
<p>用户指令："当检测到漏水时，关闭水阀并发送通知"</p>




















<table><thead><tr><th>微调前后</th><th>原始数据集微调后的模型</th><th>优化后的数据集微调后的模型</th></tr></thead><tbody><tr><td>模型输出</td><td>{"mcp_type": "iot", "function": "handle_emergency", "params": {"device_id": "water_heater_01", "action": "emergency_stop"}, "confirm": false}</td><td>{"mcp_type": "sensor_trigger", "function": "create_automation", "params": {"trigger": {"water_leak_sensor_01": "leak"}, "action": [{"device_id": "water_valve_main_01", "arg": {"status": "close"}}, {"device_id": "notifier_01", "arg": {"message": "检测到漏水，请立即处理"}}]}}</td></tr><tr><td>分析与评价</td><td>指令解读：mcp_type: IoT 控制消息。function: 处理紧急情况。params: {给出水阀ID，动作：紧急停止}评价：缺少发送通知的动作。</td><td>指令解读：mcp_type: 条件触发类型。function: 创建自动化。params: {触发条件：传感器检测到漏水，动作：[关闭水阀]，[发送通知]}评价：触发条件完整，步骤完整。</td></tr></tbody></table>
<h3 data-id="heading-3">场景三：模糊指令-从“机械匹配”到“意图理解”</h3>
<p>场景描述：将用户口语化、情绪化甚至表述不清的指令准确解析并映射为具体的设备控制参数，用户不再需要记忆特定的唤醒词或参数（如“空调调到24度”），而是可以用人类自然的交流方式（如“我有点冷”、“这里太吵了”）与系统对话。由微调后的模型赋能的系统不再是冷冰冰的机器，而是能听懂“言外之意”的贴心管家，极大地提升了交互的流畅度和用户的满意度。</p>
<p>用户指令："三楼空调温度调小一點"</p>




















<table><thead><tr><th>微调前后</th><th>原始数据集微调后的模型</th><th>优化后的数据集微调后的模型</th></tr></thead><tbody><tr><td>模型输出</td><td>{"mcp_type": "iot", "function": "set_temperature", "params": {"device_id": "ac_bedroom_01"}, "confirm": false}</td><td>{"mcp_type": "iot", "function": "set_temperature", "params": {"device_id": "ac_bedroom_01", "delta": -1}}</td></tr><tr><td>分析与评价</td><td>指令解读：mcp_type: IoT 控制消息。function: 设置温度。params: {空调ID}评价：用户指令为“调小一点”，未要求具体温度，为模糊指令；模型输出缺失调小温度的动作。</td><td>指令解读：mcp_type: IoT 控制消息。function: 设置温度。params: {设备ID，温度调低一度}评价：满足用户指令，温度减小1度。</td></tr></tbody></table>
<h2 data-id="heading-4">环境准备：搭建端到端的AI训练流水线</h2>
<p>本实践包含智能家居“数据处理-基础模型选型-参数调优-微调训练-模型效果评估”完整链路，需要单独创建一个python环境，并配置需要的工具。</p>
<p>1.下载 SmartHome 压缩文件</p>
<p>该文件中包含后续处理数据、模型功能测试等步骤所需的数据集和脚本。</p>
<p>进入 LLaMA Factory Online 平台，创建实例（选择CPU资源2核即可），选择“VSCode处理专属数据”或“Jupyter处理专属数据”。进入工作空间后，新建终端，执行下面指令下载并解压文件。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 进入目标目录</span>
<span class="hljs-built_in">cd</span> /workspace
<span class="hljs-comment"># 下载压缩文件</span>
wget <span class="hljs-string">"http://llamafactory-online-assets.oss-cn-beijing.aliyuncs.com/llamafactory-online/docs/v2.0/documents/Practice/smart_home/SmartHome.tar.gz"</span>
<span class="hljs-comment"># 解压到该目录</span>
tar -xzf SmartHome.tar.gz -C /workspace
</code></pre>
<p>2.新建终端，逐条执行下面指令配置环境</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># 创建自己的虚拟环境  </span>
conda create -n smarthome-lightllm-chat python=<span class="hljs-number">3.10</span> -y 
<span class="hljs-meta"># 激活环境 </span>
conda activate smarthome-lightllm-chat
<span class="hljs-meta"># 安装必要的包</span>
python -m pip install -i https:<span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple --trusted-host pypi.tuna.tsinghua.edu.cn vllm torch ipykernel pandas partial_json_parser websockets</span>
</code></pre>
<p>3.模型部署前期准备</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 下载lightllm的最新源码 需要挂VPN</span>
git <span class="hljs-built_in">clone</span> https://github.com/ModelTC/lightllm.git
<span class="hljs-built_in">cd</span> lightllm
</code></pre>
<p>点击下载requirements.txt文件（🔗<a href="https://link.juejin.cn?target=https%3A%2F%2Fs1.llamafactory.online%2Fllamafactory-online%2Fdocs%2Fv2.0%2Fdocuments%2FPractice%2Fsmart_home%2Frequirements.txt%25EF%25BC%2589%25EF%25BC%258C%25E5%25B0%2586%25E8%25AF%25A5%25E6%2596%2587%25E4%25BB%25B6%25E6%2594%25BE%25E5%2588%25B0%2Fworkspace%25E7%259B%25AE%25E5%25BD%2595%25E4%25B8%258B%25EF%25BC%258C%25E6%2589%25A7%25E8%25A1%258C%25E4%25B8%258B%25E9%259D%25A2%25E7%259A%2584%25E5%2591%25BD%25E4%25BB%25A4%25E8%25BF%259B%25E8%25A1%258C%25E5%25AE%2589%25E8%25A3%2585%25E7%258E%25AF%25E5%25A2%2583%25E3%2580%2582" target="_blank" title="https://s1.llamafactory.online/llamafactory-online/docs/v2.0/documents/Practice/smart_home/requirements.txt%EF%BC%89%EF%BC%8C%E5%B0%86%E8%AF%A5%E6%96%87%E4%BB%B6%E6%94%BE%E5%88%B0/workspace%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%91%BD%E4%BB%A4%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E3%80%82" ref="nofollow noopener noreferrer">s1.llamafactory.online/llamafactor…</a></p>
<pre><code class="hljs language-perl" lang="perl">pip install -r requirements.txt 
pip install torch torchvision --<span class="hljs-keyword">index</span>-url https:<span class="hljs-regexp">//d</span>ownload.pytorch.org/whl/cu126
<span class="hljs-comment"># 安装lightllm</span>
python setup.py install
</code></pre>
<p>💡提示</p>
<p>● 环境准备→步骤2 中，执行下载 lightllm 的源码前，需要挂VPN。</p>
<p>● 后续步骤在执行代码时，若提示模块不存在，可在终端运行对应的 pip install [module name] 命令，通常能解决该问题。</p>
<h2 data-id="heading-5">数据重塑：从“原始日志”到“标准教材”</h2>
<p>Garbage In, Garbage Out。在本次实践中，我们发现原始的 SmartHome_Dataset 存在大量问题（如缺少 function 字段、条件判断失效等）。直接扔进模型训练，效果惨不忍睹。</p>








































<table><thead><tr><th>指令类型</th><th>数量</th><th>问题</th></tr></thead><tbody><tr><td>iot-基础控制</td><td>12747 条</td><td>格式需规范、缺少 function 字段、模糊指令操作失效</td></tr><tr><td>sensor_trigger-条件判断</td><td>3803 条</td><td>条件判断失效</td></tr><tr><td>chain-链式操作 需执行多个动作</td><td>475 条</td><td>链式操作失效</td></tr><tr><td>sql-查询操作</td><td>381 条</td><td>-</td></tr><tr><td>复杂场景：一设备，多参数</td><td>328 条</td><td>-</td></tr><tr><td>optimization</td><td>284 条</td><td>-</td></tr></tbody></table>
<p>后续计划补充数据类型：</p>




















<table><thead><tr><th>指令类型</th><th>数量</th><th>来源说明</th></tr></thead><tbody><tr><td>复杂场景-延时执行+条件判断+多设备联动</td><td>55</td><td>AI大模型生成+人工标注</td></tr><tr><td>异常指令</td><td>500</td><td>智能家居历史交互日志</td></tr></tbody></table>
<p>我们做了这三件事，让数据“变废为宝”：</p>
<ol>
<li>统一数据格式</li>
</ol>
<p>修复了大量损坏的 JSON 结构，将所有数据转为标准 Alpaca 格式，确保每条数据都有清晰的instruction（用户指令）和output（标准JSON响应）。</p>
<p>①数据格式标准化。采用 Alpaca 格式，适配单轮指令任务。</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
<span class="hljs-attr">"instruction"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"用户指令（如“打开客厅空调”）"</span><span class="hljs-punctuation">,</span>
<span class="hljs-attr">"input"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"额外输入（可选，如设备状态）"</span><span class="hljs-punctuation">,</span>
<span class="hljs-attr">"output"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"JSON格式响应（含mcp_type、function、params字段）"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>💡提示</p>
<p>● 由于多轮对话复杂，超出本任务需求，故排除 ShareGPT 格式。</p>
<p>②在“output”中补全缺失的字段“function”。</p>
<p>进入“SmartHome”文件夹，新建终端，激活 Python 环境 smarthome-lightllm-caht ，在命令行输入以下指令运行脚本，完成数据集的“funcion”字段补全。</p>
<pre><code class="hljs language-bash" lang="bash">python3 code/function_fixed.py  \
-i dataset/smart_home.json \
-o dataset/training_data_output.json \
-r dataset/missing_function_report.csv
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/edfb9bf184e84b99a741dc3e8265bb6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p6E5biI5p2O5ZOy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555087&amp;x-signature=GrL3sLOZ6CvS2%2FfTc44T7b8m9zA%3D" alt="" loading="lazy"/></p>
<p>💡提示</p>
<p>● python3 后要写：脚本文件的路径</p>
<p>-i 后写：待处理数据集的路径</p>
<p>-o 后写：处理后的数据集存储路径</p>
<p>-r 后写：输出的处理报告的存储路径</p>
<p>用户需要把相应的路径替换成自己的真实路径。</p>
<p> </p>
<p>● 补全function的思路为：</p>
<p>读取文件中 "instruction","input","output" 的样本，解析 output 里的 JSON 字符串；如果缺少 "function" 字段，就根据 instruction 文本 + device_id 前缀 + params 里的键自动补全一个合适的函数名（如 set_light_settings、set_humidifier_settings 等），然后把修改后的对象再写回到 output。</p>
<p>2.定义条件触发与自动化联动逻辑</p>
<p>这是这是智能家居实现“无感智能”的核心。我们不仅教会模型理解“如果…就…”的简单条件，更灌输了设备自主感知环境并协同联动的复杂场景逻辑。</p>
<p>● 核心理念升级：触发条件并非仅来自用户指令，更多源于设备自身对环境的持续监测（如传感器检测到PM2.5超标、摄像头识别到家人回家、时钟到达预设时间）。模型的任务是理解这些“环境事件”，并规划出正确的设备联动响应。</p>
<p>● 场景化规则制定：</p>
<p>○ 环境自适应：例如，“trigger”: {"pm25": {"&gt;": 75}} 对应 “action” 为 [“打开新风系统”， “关闭空调内循环”]。这模拟了空气净化设备基于空气质量自主决策的互动。</p>
<p>○ 节能与舒适联动：例如，“trigger”: {"ac_status": "on"} 可触发 “action” [“关闭窗户”， “检查室内CO2浓度”]，体现了空调开启后，智能空间自动维持密闭环境并监控空气健康度的逻辑。</p>
<p>○ 链式场景触发：一个触发条件可启动一连串设备动作。例如，“trigger”: {"time": "22:00", "motion_bedroom": "no_motion_30min”} 可触发完整的“睡眠模式”：关闭主灯、调暗夜灯、调节空调至睡眠温度、启动助眠白噪音。</p>
<p>3.解决条件判断失效问题</p>
<p>针对条件判断失效的问题，使用以下规则改写。累计修改样本1,510 条。</p>
<p>①命中"instruction"中“条件+动作”的指令（如果/若/当/當/的话/的話/分钟后/分鐘後/小时后/小時後）：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"mcp_type"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"sensor_trigger"</span><span class="hljs-punctuation">,</span>
<span class="hljs-attr">"function"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"create_automation"</span><span class="hljs-punctuation">,</span>
<span class="hljs-attr">"params"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"trigger"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> ... <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"action"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"device_id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;原始device_id&gt;"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"arg"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&lt;来自power/turn_on|turn_off&gt;"</span> <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
</code></pre>
<p>②相对时间（如“一小时/一小時/半小时/半小時/五分鐘/十分钟/…后”）：</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">trigger</span> 写成：{"time_after": "NhNmNs"}，并支持中文数字转换，  
例：
一小时<span class="hljs-operator">/</span>一小時 → "1h"
半小时<span class="hljs-operator">/</span>半小時 → "30m"
五分钟<span class="hljs-operator">/</span>五分鐘 → "5m"
十分钟<span class="hljs-operator">/</span>十分鐘 → "10m"
</code></pre>
<p>③绝对时间（如“十点三十分/10:30/十點半/十點十分”）：</p>
<pre><code class="hljs language-css" lang="css">trigger 写成：{"<span class="hljs-selector-tag">time</span>": <span class="hljs-string">"HH:MM"</span>}（<span class="hljs-number">24</span>小时制标准化）
</code></pre>
<p>④比较条件（温度/湿度/PM2.5/CO₂/电量等 + 大于/小于/≥/≤/…）：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"trigger"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-string">"temperature"</span> | <span class="hljs-string">"humidity"</span> | <span class="hljs-string">"pm25"</span> | <span class="hljs-string">"co2"</span> | <span class="hljs-attr">"battery"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"operator"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"&gt;/&lt;/&gt;=/&lt;="</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"value"</span><span class="hljs-punctuation">:</span> &lt;数值&gt; <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>4.解决链式操作失效问题</p>
<p>命中"instruction"中连续操作的指令（如：“先...后.../并且/...然后”等），将“output”的“params”统一为：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"params"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"trigger"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> 没有触发条件，<span class="hljs-string">"trigger"</span>为空。
  <span class="hljs-attr">"action"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">{</span><span class="hljs-attr">"device_id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">" "</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"arg"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"device_id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span><span class="hljs-string">" "</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"arg"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">}</span>
</code></pre>
<p>5.解决模糊指令操作失效问题</p>
<p>命中"instruction"中表达模糊的指令（如：“调低一点” “加强” “调弱” “小一点”等），将“output”的“params”统一为：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"params"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"trigger"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> 没有触发条件，<span class="hljs-string">"trigger"</span>为空。
  <span class="hljs-attr">"action"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span><span class="hljs-attr">"device_id"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">" "</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"command"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">""</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"arg"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span>
 
其中：<span class="hljs-string">"arg"</span> 参数，使其体现出明确的控制如：改成自动模式，或者 加参数<span class="hljs-string">"delta"</span>
</code></pre>
<p>5.补充数据类型：复杂场景和异常指令</p>
<p>复杂场景——智能家居的复杂场景通常涉及多设备、多传感器、多协议的协同工作，结合用户行为、环境变化和个性化需求，提供智能化的生活体验。例如：</p>
<p>● 睡眠模式，涉及环境光传感器、智能窗帘、空调控制、音响系统等； "instruction": "准备睡觉时，关闭所有灯光，调低卧室空调温度，播放助眠音乐。"</p>
<p>● 老人/儿童看护模式，涉及运动传感器、摄像头、语音助手等。 "instruction": "监测老人的活动，若超过30分钟未检测到移动，发送提醒。"</p>
<p>异常指令——指令由于格式不正确、设备不支持、指令不明确等原因导致执行失败。我们希望在实际应用中，系统应能够识别这些错误指令，并提供相应的错误信息和建议。 例如：</p>
<pre><code class="hljs language-python" lang="python">{
  <span class="hljs-string">"instruction"</span>: <span class="hljs-string">"今天天气怎么样"</span>,
  <span class="hljs-string">"input"</span>: <span class="hljs-string">""</span>,
  <span class="hljs-string">"output"</span>: <span class="hljs-string">"{"</span>erro<span class="hljs-string">r": "</span>NOT_A_CONTROL_COMMAND<span class="hljs-string">", "</span>message<span class="hljs-string">": "</span>这是天气查询，不是设备控制<span class="hljs-string">", "</span>suggestion<span class="hljs-string">": "</span>请使用天气应用查询<span class="hljs-string">"}"</span>
},
</code></pre>
<p>经过上述处理步骤，我们将 12,000+ 条原始数据精简优化为 9,352 条高质量数据，涵盖基础控制、条件判断、链式操作、复杂场景和异常指令等场景。实验证明，数据质量 &gt; 数据数量，精准修复比盲目增广有效得多。</p>
<h2 data-id="heading-6">模型选型：4B模型如何战胜7B选手？</h2>
<p>智能家居交互要求轻量级、快响应、高精度的大模型，来适配边缘设备。面对众多模型，我们设定了严苛的选型标准：参数量适中、指令跟随能力强、结构化输出精准。</p>
<p>候选池中有三大模型：</p>
<p>● Llama-2-7B-Chat：名声在外，但7B参数对边缘设备不够友好</p>
<p>● SmolLM2-1.7B-Instruct：足够轻量，但能力捉襟见肘</p>
<p>● Qwen3-4B-Instruct：折中之选，但实力未知</p>
<p>我们需要对比它们在智能家居控制任务上的表现。核心评判指标为：</p>
<p>● Schema通过率：生成的JSON格式是否规范、字段是否齐全</p>
<p>● Slot-F1值：设备ID、档位、时间等关键参数抽取是否准确</p>
<p>● 推理延迟：单次响应速度</p>
<p>1.验证集准备。本实践选择Smart Home Command Dataset（🔗<a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2Fdatasets%2Fyoukwan%2FSmart-Home-Control-Zh%25EF%25BC%2589%25E4%25BD%259C%25E4%25B8%25BA%25E5%259F%25BA%25E5%2587%2586%25E6%2595%25B0%25E6%258D%25AE%25EF%25BC%258C%25E8%25AF%25A5%25E6%2595%25B0%25E6%258D%25AE%25E9%259B%2586%25E6%2597%25A8%25E5%259C%25A8%25E7%2594%25A8%25E7%25B9%2581%25E4%25BD%2593%25E4%25B8%25AD%25E6%2596%2587%25E8%25AE%25AD%25E7%25BB%2583%25E5%25A4%25A7%25E5%259E%258B%25E8%25AF%25AD%25E8%25A8%2580%25E6%25A8%25A1%25E5%259E%258B%25EF%25BC%2588llm%25EF%25BC%2589%25EF%25BC%258C%25E7%2594%25A8%25E4%25BA%258E%25E6%258E%25A7%25E5%2588%25B6%25E6%2599%25BA%25E8%2583%25BD%25E5%25AE%25B6%25E5%25B1%2585%25E7%25B3%25BB%25E7%25BB%259F%25EF%25BC%258C%25E7%2589%25B9%25E5%2588%25AB%25E6%2598%25AF%25E9%2592%2588%25E5%25AF%25B9%25E5%25AE%25B6%25E5%25BA%25AD%25E5%258A%25A9%25E7%2590%2586%25E7%25B3%25BB%25E7%25BB%259F%25E3%2580%2582%25E6%2595%25B0%25E6%258D%25AE%25E9%259B%2586%25E5%258C%2585%25E5%2590%25AB%25E7%2594%25A8%25E6%2588%25B7%25E8%25BE%2593%25E5%2585%25A5%25E7%259A%2584%25E7%25B9%2581%25E4%25BD%2593%25E4%25B8%25AD%25E6%2596%2587%25EF%25BC%258C%25E8%25BE%2593%25E5%2587%25BA%25E6%2598%25AF%25E7%25BB%2593%25E6%259E%2584%25E5%258C%2596%25E7%259A%2584JSON%25E5%2591%25BD%25E4%25BB%25A4%25EF%25BC%258C%25E4%25BB%25A3%25E8%25A1%25A8%25E7%2594%25A8%25E6%2588%25B7%25E6%258E%25A7%25E5%2588%25B6%25E6%2599%25BA%25E8%2583%25BD%25E5%25AE%25B6%25E5%25B1%2585%25E8%25AE%25BE%25E5%25A4%2587%25E7%259A%2584%25E6%2584%258F%25E5%259B%25BE%25E3%2580%2582%25E6%2588%2591%25E4%25BB%25AC%25E9%259A%258F%25E6%259C%25BA%25E6%258A%25BD%25E5%258F%2596300%25E6%259D%25A1%25E6%2595%25B0%25E6%258D%25AE%25E6%25A0%25B7%25E6%259C%25AC%25E4%25BD%259C%25E4%25B8%25BA%25E9%25AA%258C%25E8%25AF%2581%25E9%259B%2586%25E3%2580%2582" target="_blank" title="https://huggingface.co/datasets/youkwan/Smart-Home-Control-Zh%EF%BC%89%E4%BD%9C%E4%B8%BA%E5%9F%BA%E5%87%86%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%AF%A5%E6%95%B0%E6%8D%AE%E9%9B%86%E6%97%A8%E5%9C%A8%E7%94%A8%E7%B9%81%E4%BD%93%E4%B8%AD%E6%96%87%E8%AE%AD%E7%BB%83%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%88llm%EF%BC%89%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%8E%A7%E5%88%B6%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E7%B3%BB%E7%BB%9F%EF%BC%8C%E7%89%B9%E5%88%AB%E6%98%AF%E9%92%88%E5%AF%B9%E5%AE%B6%E5%BA%AD%E5%8A%A9%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%82%E6%95%B0%E6%8D%AE%E9%9B%86%E5%8C%85%E5%90%AB%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%9A%84%E7%B9%81%E4%BD%93%E4%B8%AD%E6%96%87%EF%BC%8C%E8%BE%93%E5%87%BA%E6%98%AF%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84JSON%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BB%A3%E8%A1%A8%E7%94%A8%E6%88%B7%E6%8E%A7%E5%88%B6%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E8%AE%BE%E5%A4%87%E7%9A%84%E6%84%8F%E5%9B%BE%E3%80%82%E6%88%91%E4%BB%AC%E9%9A%8F%E6%9C%BA%E6%8A%BD%E5%8F%96300%E6%9D%A1%E6%95%B0%E6%8D%AE%E6%A0%B7%E6%9C%AC%E4%BD%9C%E4%B8%BA%E9%AA%8C%E8%AF%81%E9%9B%86%E3%80%82" ref="nofollow noopener noreferrer">huggingface.co/datasets/yo…</a></p>
<p>2.vLLM 批量验证。使用 vLLM 对大语言模型（Llama-2-7B-Chat，Qwen3-0.6B-Base，Qwen3-4B-Instruct）进行批量验证，并对比它们在智能家居控制任务上的表现。新建终端，逐条执行以下命令。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">cd</span> /workspace/SmartHome/code
conda activate smarthome-lightllm-chat
python select_1.py
</code></pre>
<p>运行完后的结果如下图所示：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fb912c47172046d9a865d32e9d65eb72~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p6E5biI5p2O5ZOy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555087&amp;x-signature=eL3tMStbN%2FR9IynpGjNxFJxSXiw%3D" alt="" loading="lazy"/></p>
<p>💡提示</p>
<p>● 脚本select_1.py中的数据读取路径要修改为您当前的验证集保存路径。</p>
<p>● 若运行过程中报错“缺少某个module”，运行指令 pip install {module的名字}</p>
<p>该验证脚本的主要思路如下所示：</p>
<p>● 使用 vLLM 库对每个模型执行批量推理，从验证数据集中逐条输入指令，获得模型生成的结构化 JSON 输出。</p>
<p>● 校验JSON输出结构的合法性。</p>
<p>● 使用 JSON Schema 自动验证格式。自定义一个 JSON Schema，并利用 Python 的 jsonschema 库对每条输出进行校验。</p>
<p>● 输出与期望结果对比。 将模型生成的具体内容与验证集中每条样本的 expected_events 期望结果进行对比，以评估模型在内容层面的准确性。每条样本的 expected_events 列出该指令正确的执行动作列表（每个包含应执行的动作类型、设备ID、参数等）。</p>
<p>最终，三个模型对比结果如下表所示：</p>









































<table><thead><tr><th>候选模型</th><th>参数规模</th><th>Schema通过率</th><th>Slot-F1</th><th>推理延迟</th><th>微调显存占用</th><th>边缘部署友好度</th></tr></thead><tbody><tr><td>Qwen3-4B-Instruct</td><td>4B</td><td>96%</td><td>0.675</td><td>413.1ms</td><td>12.4GB</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td>Llama-2-7B-Chat</td><td>7B</td><td>13.7%</td><td>0.095</td><td>538.3ms</td><td>20GB</td><td>⭐⭐</td></tr><tr><td>SmolLM2-1.7B-Instruct</td><td>1.7B</td><td>0%</td><td>0.016</td><td>220.1ms</td><td>5.1GB</td><td>⭐⭐⭐⭐</td></tr></tbody></table>
<p>结果令人意外：4B的 Qwen3 在参数规模、推理延迟等方面不仅大幅领先7B的 Llama2，其 96% 的Schema通过率意味着它几乎能“一次成型”输出标准指令格式。这说明，模型能力不只看参数量，指令微调潜力同样关键。因此，Qwen3-4B-Instruct 被选定为本次微调的基模型。</p>
<h2 data-id="heading-7">科学调优：找到学习效率的“黄金参数”</h2>
<p>有了好学生和好教材，还需要科学的“教学方法”。我们针对LoRA微调中的三个关键参数展开实验：</p>
<p>实验设计：3因素×3水平，共27组参数组合对比</p>
<p>● LoRA rank：16、32、64（控制模型微调容量）</p>
<p>● 学习率：1e-5、3e-5、5e-5（控制学习速度）</p>
<p>● Batch size：2、4、8（控制单步学习样本量）</p>
<p>我们跟踪每组参数训练的损失曲线和最终“高级功能通过率”（条件+链式指令），筛选最优组合：</p>













































<table><thead><tr><th>实验组</th><th>LoRA rank</th><th>学习率</th><th>Batch Size</th><th>高级功能通过率</th><th>loss后期波动幅度（训练稳定性）</th></tr></thead><tbody><tr><td>exp1</td><td>16</td><td>1e-5</td><td>2</td><td>55.6%</td><td>0.068（波动较大）</td></tr><tr><td>exp8</td><td>32</td><td>3e-5</td><td>4</td><td>55.6%</td><td>0.055（稳定收敛）</td></tr><tr><td>exp15</td><td>32</td><td>5e-5</td><td>4</td><td>44.4%</td><td>0.05（后期过拟合）</td></tr><tr><td>exp22</td><td>64</td><td>3e-5</td><td>4</td><td>44.4%</td><td>0.05（后期过拟合）</td></tr></tbody></table>
<p>💡提示</p>
<p>● 测试完一个实验模型的通过率后，要起另一个服务测试下一个模型时，需要关闭当前进程（可以直接关机，重新启动实例）。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dd6e9266774a4976b0b77ec1e24301bb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p6E5biI5p2O5ZOy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555087&amp;x-signature=x6OJ64KJucMssOFo8KAESV7dOVU%3D" alt="" loading="lazy"/></p>
<p>参数选择不是“越大越好”，而是要在效果、速度和成本间找到精妙平衡。最终，我们锁定了这套“黄金参数”：</p>






























<table><thead><tr><th>参数项</th><th>设定值</th><th>关键解读</th></tr></thead><tbody><tr><td>LoRA Rank</td><td>32</td><td>性价比最优解。Rank=64 虽能提升1%准确率，但显存占用激增2GB（从 16GB→18GB），不符合 “边缘设备轻量化” 目标。</td></tr><tr><td>Learning Rate</td><td>3e-5</td><td>1e-5 收敛太慢（4 epoch 未达最优），5e-5 容易震荡。3e-5 配合 Cosine 调度器最为稳定。</td></tr><tr><td>Batch Size</td><td>4</td><td>配合梯度累积（Gradient Accumulation Steps=4），有效批次大小为16，稳定训练。</td></tr><tr><td>Epochs</td><td>4</td><td>经验表明，3轮欠拟合，5轮过拟合，4轮为最优平衡点。</td></tr></tbody></table>
<h2 data-id="heading-8">平台实战：三步完成从训练到部署</h2>
<p>基于选定的 Qwen3-4B-Instruct 模型和调优后的参数，我们在 LLaMA-Factory Online 平台上的操作变得异常简单：</p>
<h3 data-id="heading-9">第一步：配置训练任务</h3>
<p>选择基础模型和数据集，进行参数配置：</p>
<p>● 基础模型：平台内置的 Qwen3-4B-Instruct</p>
<p>● 数据集：处理好的 smart_home_fixed.json</p>
<p>● 关键参数：LoRA rank=32，学习率=3e-5，epoch=4，Batch Size=4</p>
<p>● 训练资源：1张 H800（约2.5小时完成训练）</p>































































































<table><thead><tr><th>参数</th><th>取值</th><th>选择依据</th></tr></thead><tbody><tr><td>lora参数</td><td/><td/></tr><tr><td>lora_rank</td><td>32</td><td>4B模型 + 中等任务复杂度，平衡性能与效率</td></tr><tr><td>lora_alpha</td><td>64</td><td>经验值：2×lora_rank，保证梯度更新幅度</td></tr><tr><td>lora_dropout</td><td>0.05</td><td>防止过拟合，适配中小样本量</td></tr><tr><td>target_modul</td><td>q_proj, k_proj, v_proj, o_proj, gate_proj, up_proj, down_proj</td><td>覆盖注意力层与 FFN 层，最大化微调效果</td></tr><tr><td>bias</td><td>none</td><td>减少参数数量，降低过拟合风险</td></tr><tr><td>训练参数配置</td><td/><td/></tr><tr><td>num_train_epochs</td><td>4</td><td>3 轮欠拟合、5 轮过拟合，4 轮为最优平衡点</td></tr><tr><td>per_device_train_batch_size</td><td>4</td><td>80GB 显存适配，避免 OOM</td></tr><tr><td>gradient_accumulation_steps</td><td>4</td><td>有效批次 = 4×4=16，模拟大批次训练</td></tr><tr><td>learning_rate</td><td>3e-5</td><td>经 Grid Search 验证(1e-5 收敛慢、5e-5 震荡)</td></tr><tr><td>lr_scheduler_type</td><td>cosine</td><td>余弦退火 + 0.1 warmup_ratio，稳定收敛</td></tr><tr><td>weight_decay</td><td>0.01</td><td>抑制过拟合，保护预训练权重</td></tr><tr><td>fp16</td><td>true</td><td>节省 50% 显存，提速 30%</td></tr><tr><td>gradient_checkpointing</td><td>True</td><td>再省 30% 显存，代价是训练时间增加 10%</td></tr><tr><td>evaluation_strategy</td><td>steps</td><td>每 200 步评估，及时发现过拟合</td></tr><tr><td>load_best_model_at_end</td><td>True</td><td>保存最优模型，避免训练后期退化</td></tr></tbody></table>
<h3 data-id="heading-10">第二步：模型评估验证</h3>
<p>训练完成后，可在 LLaMA-Factory Online 上对模型进行全面评估，并查看评估任务的基本信息、日志及结果：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c8ea1aa293846eb858b2738f3222e2d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p6E5biI5p2O5ZOy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555087&amp;x-signature=f9CPK58lLZVp4GRLdDtlsfO0Fe8%3D" alt="" loading="lazy"/></p>
<p>评估结果解读：</p>
<p>● predict_bleu-4: 72.3829，生成文本在短语层面与参考有良好重合，精确度较好。</p>
<p>● predict_rouge-1: 76.2083，关键词覆盖良好，模型能命中参考中的大量关键字。</p>
<p>● predict_rouge-2: 76.8263，局部短语连贯性较好，短语搭配合理。</p>
<p>● predict_rouge-l: 82.4938，整体段落结构很接近参考。</p>
<p>总结：模型生成质量较好（BLEU/ROUGE 都在 70~82 范围，尤其 ROUGE-L 表现很强），但推理吞吐/速度一般（samples/sec ≈1），适合以质量为主的离线或低并发在线场景；若用于高并发在线服务需进一步做推理优化。</p>
<h3 data-id="heading-11">第三步：一键对话测试</h3>
<p>在“模型对话”界面选择微调后的模型，即可实时体验复杂指令解析：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9753e563c83642e6a2c0e98a34ace17e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5p625p6E5biI5p2O5ZOy:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555087&amp;x-signature=xEY2Z4jsHcda0W50Pzqwig9j33g%3D" alt="" loading="lazy"/></p>
<p>模型输出结果解读：</p>




















<table><thead><tr><th>用户指令</th><th>"将卧室空气净化器的湿度设为2档"</th><th>"半小时后请把空气净化器的风速调小一点"</th></tr></thead><tbody><tr><td>模型输出</td><td>{"mcp_type": "iot","function": "set_humidity", "params": {"device_id": "purifier_bedroom_01", "humidity": 2}, "confirm": false}</td><td>{"mcp_type": "sensor_trigger", "function": "create_automation", "params": {"trigger": {"type":"time_delay", "minutes":30}, "action": {"device_id": "purifier_bedroom_01", "arg": {"op": "control_device", "level_delta":-1}}}, "confirm": false}</td></tr><tr><td>指令解读</td><td>mcp_type：IoT 控制消息function：设置湿度params：{设备ID，湿度挡位：2}</td><td>mcp_type：IoT 控制消息function：创建自动化风速控制params：{触发条件：30分钟后，动作：{给出设备ID，风速减小1。}}</td></tr></tbody></table>
<h2 data-id="heading-12">效果总结：从“大概理解”到“精准执行”</h2>
<p>微调前后的差异，通过量化指标和典型场景对比一目了然：</p>
<h3 data-id="heading-13">场景一：条件触发性指令</h3>
<pre><code class="hljs">用户指令：“半小时后请把空气净化器的风速调大到3档位”
微调前：模型仅将其识别为简单的风速设置（“control_device”, “level”: 3），完全忽略了“半小时后”这一核心时间条件，导致指令被立即执行。❌
微调后：模型精准识别出“时间延迟触发”的意图，输出完整的自动化创建指令（“sensor_trigger”, “create_automation”），包含 “time_delay” 触发条件与具体动作，实现了真正的“条件执行”。✅
</code></pre>
<h3 data-id="heading-14">场景二：链式操作型指令</h3>
<pre><code class="hljs language-csharp" lang="csharp">用户指令：“当检测到漏水时，关闭水阀并发送通知”
微调前：模型仅输出一个紧急处理动作（“handle_emergency”, “emergency_stop”），遗漏了“发送通知”这一关键步骤，应对措施不完整。❌
微调后：模型正确解析出“传感器触发”与“多步骤动作”的复合结构，输出的 <span class="hljs-keyword">params</span> 中包含完整的触发条件（“water_leak_sensor_01”: “leak”）和一个有序动作列表（关闭水阀、发送通知），逻辑严谨。✅
</code></pre>
<h3 data-id="heading-15">场景三：模糊型指令</h3>
<pre><code class="hljs language-csharp" lang="csharp">用户指令：“三楼空调温度调小一点”
微调前：模型只能识别出设备（空调）和操作（设置温度），但在 <span class="hljs-keyword">params</span> 中缺失具体的调整参数，无法执行。❌
微调后：模型准确理解了“调小一点”的相对性模糊表达，在参数中增加了 “delta”: <span class="hljs-number">-1</span> 字段，明确指示“在现有温度基础上降低<span class="hljs-number">1</span>度”，实现了符合用户预期的精准控制。✅
</code></pre>
<p>可以看到，相较于基模型（Schema通过率&lt;20%），微调后的模型在复杂指令解析上实现了质的飞跃。</p>




















<table><thead><tr><th>测试类型</th><th>测试用例</th><th>通过率</th></tr></thead><tbody><tr><td>基础功能</td><td>打开客厅灯、关闭卧室空调等5条</td><td>100%</td></tr><tr><td>高级功能</td><td>如果卧室温度低于18度就开启暖气、离家模式等18条</td><td>88%</td></tr></tbody></table>
<h2 data-id="heading-16">总结：AI落地智能家居的三重突破</h2>
<p>本次实践成功验证了一条高效构建垂直领域专用模型的技术路径，实现了三重突破：</p>
<p>● 轻量化突破：仅用4B参数模型，在边缘设备友好条件下，达到了接近甚至超越通用大模型的垂直场景精度。证明了“小模型+精调优”路径的可行性。</p>
<p>● 精准化突破：通过系统化的数据工程，让模型真正理解家居场景下的条件逻辑、时间概念和模糊表达，输出标准化、可执行的设备控制指令。</p>
<p>● 场景化突破：不仅覆盖基础控制，更深度适配了智能家居特有的条件触发、场景联动、异常处理等复杂需求，让AI真正融入家庭场景。</p>
<p>更重要的是，通过 LLaMA-Factory Online 平台，我们将原本需要数周的专业微调流程，压缩到了“几个小时+几次点击”的标准化操作。模型选型、数据准备、参数调优、训练评估的全流程，都可在可视化界面中完成。</p>
<p>智能家居的终极目标是“无感智能”——设备理解人的意图，而非人学习设备的操作。今天，我们通过大模型微调技术向这个目标迈出了坚实一步。当每个家庭都能拥有理解上下文、支持复杂指令的个性化AI管家时，真正的智能生活才刚刚开始。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AgentScope x RocketMQ：打造企业级高可靠 A2A 智能体通信基座]]></title>    <link>https://juejin.cn/post/7584343534968635434</link>    <guid>https://juejin.cn/post/7584343534968635434</guid>    <pubDate>2025-12-17T05:47:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584343534968635434" data-draft-id="7584307642999275563" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AgentScope x RocketMQ：打造企业级高可靠 A2A 智能体通信基座"/> <meta itemprop="keywords" content="云原生,Apache,RocketMQ"/> <meta itemprop="datePublished" content="2025-12-17T05:47:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿里云云原生"/> <meta itemprop="url" content="https://juejin.cn/user/3808363977648493"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AgentScope x RocketMQ：打造企业级高可靠 A2A 智能体通信基座
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3808363977648493/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿里云云原生
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T05:47:13.000Z" title="Wed Dec 17 2025 05:47:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读22分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：琛琪、稚柳</p>
<h2 data-id="heading-0">引言</h2>
<p>Agentic AI 时代已至，在智能客服、代码生成、流程自动化等场景中，多智能体（Multi-Agent）协作正从构想走向落地。然而，当多个 Agent 需要像一个团队那样高效协作时，脆弱的通信机制可能因网络抖动或服务宕机，就让整个系统瞬间瘫痪，导致昂贵的计算任务失败、会话状态丢失。</p>
<p>如何为这些聪明的“数字员工”们构建一个真正可靠、高效的通信基座？</p>
<p>本文将为您介绍 Apache RocketMQ 全新推出的<strong>轻量级通信模型 LiteTopic</strong>，如何在 AI 应用场景中有效简化系统架构、提升稳定性与可靠性，并结合 <strong>A2A（Agent-to-Agent）协议与阿里巴巴 AgentScope 框架</strong>的生产实践案例，深入剖析面向智能体通信的落地实践与技术实现。</p>
<h2 data-id="heading-1">RocketMQ for AI：重新定义 AI 应用通信范式</h2>
<h3 data-id="heading-2">1.1 传统应用：单向、无反馈的事件驱动模式</h3>
<p>在传统应用的事件驱动场景中，业务逻辑编排通常由人工预先约定，消息生产方成功发送消息后，便无需关注后续的处理逻辑。</p>
<p>下图以注册系统为例：用户发起账户注册请求后，注册系统向 RocketMQ 发送“新用户注册”的消息后便立即返回，无需关心下游的邮件或短信通知系统如何处理。邮件或短信通知系统再分别从 RocketMQ 拉取消息，驱动各自的发送流程。整条业务链路为<strong>单向、无反馈的事件驱动模式。</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/282190c4f1f44f7cb119e715009e9c88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=f%2Bfamj%2FLz%2FiMyeKyA3i8p5cweuM%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-3">1.2 从单向事件到双向交互：AI 应用对通信提出新挑战</h3>
<p>在 AI 应用场景中，业务逻辑编排通常由大模型动态生成，消息生产方需等待并处理响应结果，才能驱动后续的逻辑执行。</p>
<p>下图以典型的 AI 会话场景为例：用户所连接的 Gateway 不仅需要发送请求，还需要处理推理响应结果，并将结果推送给浏览器，形成完整的交互闭环。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35022309d98b4803a5054d18e46f3218~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=RcwgSGB%2B7Uny5hD6S%2BDSrpp0Pyw%3D" alt="图片" loading="lazy"/></p>
<p>结合真实 AI 应用场景的深度调研，我们发现 AI 场景具有四个显著特征，对底层通信模式提出了全新且严苛的挑战：</p>
<ul>
<li><strong>更长的响应时间</strong>：传统互联网应用追求毫秒级响应延时，而 AI 应用的响应时长普遍达到分钟级以上。更关键的是，AI 应用单次业务的运行时间具有高度不可预测性。</li>
<li><strong>更复杂的交互</strong>：AI 应用的多轮对话持续时间长，对话历史可达数十轮甚至更多。单次上下文传输可能达到几十甚至上百 MB，上下文管理难度高。多 Agent 之间的协同编排逻辑更加复杂，需要精确的状态同步。</li>
<li><strong>更昂贵的计算资源</strong>：AI 推理依赖昂贵的 GPU 资源，瞬时高并发流量可能冲击推理服务稳定性，导致算力资源浪费，并且任务失败重试的成本极高。</li>
<li><strong>更精细化的事件驱动</strong>：由于计算能力有限，异步事件驱动需要更精准的消费速度控制。同时，必须实现分级的事件驱动策略，以确保高优先级任务优先获得宝贵的计算资源。</li>
</ul>
<h3 data-id="heading-4">1.3 RocketMQ LiteTopic：专为 AI 场景设计的通信模型</h3>
<p>为了应对上述挑战，Apache RocketMQ 推出了以轻量级通信模型 LiteTopic 为核心的一系列新特性：</p>
<ul>
<li>
<p><strong>轻量级通信模型 —— 为海量会话而生</strong></p>
<p>其核心是百万级轻量资源管理能力。基于极低的资源动态创建开销，可轻松支持海量会话（Session）场景，并提供更细粒度的订阅管理，适用于长时 Session、AI 工作流和 Agent-to-Agent 交互等场景。</p>
</li>
<li>
<p><strong>企业级上下文管理 —— 让会话状态可靠持久</strong></p>
<p>以连续的消息流完整保存 Session 上下文，通过顺序保障、排他消费等机制严格确保上下文的完整性与一致性。同时原生支持大消息体（数十 MB 甚至更大），轻松满足 AI 场景下庞大数据负载的传输需求。</p>
</li>
</ul>
<h3 data-id="heading-5">1.4 LiteTopic 技术解析：百万队列支撑海量并发会话</h3>
<p>LiteTopic 基于 <strong>RocketMQ 业界领先的百万队列</strong>核心技术构建，其底层本质是独立的 Queue。</p>
<ul>
<li>它为每个独立会话（Session）创建一个专属的、低成本的“私有通道”——即轻量主题（LiteTopic），从而能够以极低的资源开销支撑海量并发会话的需求。</li>
<li>轻量级的 LiteTopic 在消息分配与发送行为上与顺序 Topic 一致（其所属 Queue 由单一 Broker 独占，消息始终路由至该 Broker，而非在多个 Broker 间轮询发送），这种设计天然确保了消息的严格顺序性，并极大降低了资源管理和路由的复杂度。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c0a2c88f41964ba486a64128abeae1f7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=tjZQKfRmdlw1xnNj82GoDP%2FZfbE%3D" alt="图片" loading="lazy"/></p>
<h4 data-id="heading-6">1.4.1 LiteConsumer 支持单节点粒度的订阅关系管理</h4>
<p>与传统消息队列中“同一 Consumer Group ID（CID）必须全局一致订阅相同 Topic”的强约束不同，LiteConsumer 创新性地支持 CID 内各节点按需进行差异化订阅。每个节点可根据实际负载、业务场景或运行时需求，独立订阅不同的 LiteTopic，从而构建更加灵活、弹性的消费拓扑。</p>
<p>这一机制从根本上规避了因订阅关系不一致所引发的消费异常、重复消费或 Rebalance 风暴等问题，显著提升了系统的灵活性、可扩展性与稳定性。同时，它更契合 AI 时代轻量、动态、点对点的交互模式，为构建轻量级请求-响应式消息收发模型提供了原生支持。</p>
<h4 data-id="heading-7">1.4.2 LiteConsumer 的核心能力</h4>
<ul>
<li>多节点差异化订阅：同一 CID 下的不同节点可独立订阅各自的 LiteTopic，实现细粒度、个性化的订阅策略。</li>
<li>动态订阅扩展：支持在运行时实时为单个节点新增 LiteTopic 订阅，无需重启服务或影响其他节点的正常消费。</li>
<li>动态退订能力：支持在运行时实时取消单个节点对特定 LiteTopic 的订阅，实现精准的资源释放与流量治理。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a8b389f3ab844bd4b03247170bcf3a5e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=thTeRXCtdXX0NU3e0hR5VFKBlEw%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-8">1.5 生产案例：RocketMQ LiteTopic 如何重塑 AI 应用架构？</h3>
<p>以下案例基于某客户真实的 AI 应用场景，通过架构对比直观展示采用传统 RocketMQ 通信模型与引入 LiteTopic 轻量级通信模型前后的显著差异。</p>
<p>采用 RocketMQ LiteTopic 轻量级通信模型后，客户架构实现了质的提升：不仅彻底移除了对 Redis 的依赖，还避免了广播推送带来的带宽与计算资源浪费。整体架构更轻量，系统稳定性与可靠性也得到显著提升。</p>
<h5 data-id="heading-9">1.5.1 改造前：依赖 Redis + 广播的臃肿架构</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/73b06d979da745448387a10e73082b8c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=WAibLu6O66UPRdYYGK4kOT9Rlz4%3D" alt="图片" loading="lazy"/></p>
<p>整体的业务流程步骤如下：</p>
<ol>
<li><strong>任务提交</strong>：用户请求到达后，应用接入层节点将推理任务写入 Redis。</li>
<li><strong>任务处理</strong>：Worker 集群扫描 Redis 并处理推理任务，将推理过程中的中间结果以多条顺序消息的形式发送至 RocketMQ。</li>
<li><strong>结果持久化与通知</strong>：Consumer 集群顺序消费 RocketMQ 消息，将最终推理结果存入 Redis，并基于 RocketMQ 广播通知所有应用接入层节点。</li>
<li><strong>结果推送</strong>：应用接入层节点收到广播消息后，仅当结果归属于自身连接时，才从 Redis 获取完整结果并推送给客户端；否则直接忽略该消息。</li>
</ol>
<p>传统架构采用“先存储、再广播、后过滤”的模式，在高并发 AI 场景下效率低下且成本高昂：</p>
<ul>
<li><strong>架构臃肿且脆弱</strong>：强依赖外部组件 Redis，增加了系统的复杂度和潜在故障点，运维成本高，可用性受限。</li>
<li><strong>资源浪费严重</strong>：无效的广播机制导致大量带宽被占用，且每个应用接入层节点都需进行计算密集型的过滤操作。</li>
<li><strong>链路冗长低效</strong>：数据流转需多次读写 Redis，通信链路长、延迟高，应用接入层节点宕机后会话状态将全部丢失，严重影响用户体验。</li>
</ul>
<h4 data-id="heading-10">1.5.2 改造后：基于 RocketMQ LiteTopic 的极简可靠架构</h4>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f7d66fe0ad645a39c0e8224a671e32c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=xgBvdToToT1d4cs%2Fb6fvOJ39h90%3D" alt="图片" loading="lazy"/></p>
<p>引入 LiteTopic 后，业务流程被大幅简化，实现了端到端的可靠、高效通信：</p>
<ol>
<li><strong>会话绑定与动态订阅</strong>：应用接入层节点在发起推理请求时携带唯一身份标识（如 Session ID），并立即订阅该标识对应的 LiteTopic（无需预创建 consumer group、topic）。</li>
<li><strong>结果持久化发送</strong>：智能应用（Worker）根据请求中的身份标识，将推理结果直接发送至对应的 LiteTopic（同样无需预创建）。</li>
<li><strong>精准接收消费</strong>：应用接入层节点各自精准接收属于自己的 response 消息，无需过滤，无任何冗余消费。</li>
</ol>
<h4 data-id="heading-11">1.5.3 核心价值：为 AI 会话注入“记忆”，实现断点续传与恢复</h4>
<p>客户接入 LiteTopic 轻量级通信模型后，通过将 LiteTopic 与 Session 维度进行细粒度绑定，以极低成本实现了生产级的会话续传与恢复能力。</p>
<p>在按照上一小节的流程实现端到端的可靠通信后，在网关机器下线/宕机时：</p>
<ul>
<li><strong>自动重连</strong>：客户端检测到连接断开后，自动发起重连请求。</li>
<li><strong>动态订阅</strong>：新接管的应用接入层节点实例根据 Session ID，动态订阅原 session 对应的 LiteTopic（无需预创建）。</li>
<li><strong>断点续传</strong>：新应用接入层节点从上次成功消费的 Offset 位点开始拉取消息，精准恢复到故障前的状态（不会丢消息，也不会重复消费已处理的消息）。</li>
<li><strong>恢复会话</strong>：自动恢复 Session 的完整上下文，用户完全无感知，业务流程无缝衔接。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6bc789e455294c3abef4fe3b490e21e7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=vUcIE9cwWuLsqU7QS%2BWmveoDw4w%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-12">基于 RocketMQ LiteTopic 打造企业级 Session 管理</h2>
<h3 data-id="heading-13">2.1 AI 场景下 Session 的四大核心要求</h3>
<p>在 AI 应用场景下，业界对 Session 的特性提出了以下四项核心要求：</p>
<ul>
<li><strong>低延迟</strong>：面向实时交互场景，要求快速响应。</li>
<li><strong>时序性</strong>：必须严格按对话时间顺序组织内容，确保上下文的连续性与逻辑一致性。</li>
<li><strong>单会话隔离</strong>：保障不同用户/会话间的数据隔离，避免消息串话或状态混淆。</li>
<li><strong>上下文压缩</strong>：支持通过截断或摘要控制上下文长度，避免超出模型窗口限制导致溢出。</li>
</ul>
<h3 data-id="heading-14">2.2 RocketMQ LiteTopic 实现 Session 的四大优势</h3>
<p>基于 RocketMQ LiteTopic 实现 Session 的核心价值，在于将“Session”从内存易失状态转化为<strong>可持久、可追溯、可恢复</strong>的事件流，为多智能体系统提供企业级会话韧性，彻底解决传统架构中会话状态丢失、无法恢复等痛点。</p>
<p><strong>1. 会话状态持久化 —— 进程重启不丢会话</strong></p>
<p>消息天然持久化存储于 CommitLog，即使应用宕机或网络中断，也能<strong>通过消息重放完整重建会话上下文</strong>（如对话历史、任务状态、中间结果）。</p>
<p>如下图所示，应用 A 将响应输出的 TaskEvent / TaskUpdateEvent 转换为 RocketMQ LiteTopic 中存储的消息（Message）。当应用 A 重启后，可从 CommitLog 中重放所有消息，完整恢复会话状态。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/53be874857cb4673ac7e2263d75eb839~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=0D0UqwA%2FQK9fzxp%2BieykRR9cWng%3D" alt="图片" loading="lazy"/></p>
<p><strong>2. 消息回溯与重放 —— 断点精准恢复</strong></p>
<p>支持按时间 / Offset 回溯消费，应用重启后可从断点精确恢复会话，实现无缝续聊与任务接力，避免重复推理带来的算力浪费。</p>
<p>当应用宕机后重新启动，可以指定某个 Session（LiteTopic）中的具体位点开始继续消费，或从上次消费成功的位点开始消费。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/316953ea7a674d059027e65fca77fdb1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=hKOa3Znby1B6vppR4EcmbSdrgaE%3D" alt="图片" loading="lazy"/></p>
<p><strong>3. Session 隔离与路由 —— 多会话并行无干扰</strong></p>
<p>通过轻量级 LiteTopic 实现会话级隔离（如 Session ID 作为 LiteTopic 的唯一标识），确保多用户/多会话并行运行时互不干扰。</p>
<p>多用户多 Session 的消息存储于不同的 LiteTopic，在数据存储维度实现天然隔离，无需应用层手动过滤。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3613779256164610baa32af8181c4a49~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=khl5QZD7qketTBlL8xKxgNSEJh4%3D" alt="图片" loading="lazy"/></p>
<p><strong>4. 流量削峰与缓冲 —— 保护下游应用稳定性</strong></p>
<p>高并发会话请求被缓冲至 Broker，避免下游 Agent 瞬时过载崩溃，提升系统整体稳定性。下游应用根据自身处理能力按需消费消息，实现“削峰填谷”。</p>
<p>如下图所示，应用 A 发出的任务请求可在 Broker 中持久化堆积，下游应用 B 根据自身消费能力按需拉取并处理，有效保障系统稳定性。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3d8c728e7c854e0e84155f6442211c6a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=QH1EY65%2Fw%2BSFhE6BW3Sq0Xkumn0%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-15">基于 RocketMQ 构建高可靠 A2A 通信通道</h2>
<p>在上一章，我们解决了单个会话的持久化与恢复问题。现在，让我们将视野放大：当成百上千个功能各异的 Agent 需要协作时，它们之间如何建立标准化的通信？这正是 A2A 协议诞生的意义所在。</p>
<h3 data-id="heading-16">3.1 A2A 协议</h3>
<p>Agent-to-Agent（简称 A2A）是一项由 Google 于 2025 年发起，并贡献至 Linux 基金会的开源通信协议。其核心目标是建立跨厂商、跨框架的标准化互操作机制，使异构 AI 智能体（Agents）能够<strong>自动发现、可靠通信并高效协作</strong>，从而构建开放、可组合、可扩展的多智能体系统生态。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4eff5d72c44a4f1e90971373c32b3961~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=70gJL1KBXOYSBhhPBsbniixOrQY%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-17">3.2 单智能体 vs. 多智能体架构：能力边界与协同范式的演进</h3>
<p>在深入探讨如何构建 A2A 通信之前，我们首先需要理解，为什么多智能体协同是必然趋势。我们从六个维度对比单智能体与多智能体的能力差异：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1d12277fc1b2442d81cc4f9b4912187d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=NZrE3vPL07rSXykDcDbgXfA9%2Ffc%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-18">3.3 同步 RPC 与 RocketMQ 异步通信的对比</h3>
<p>明确了多智能体架构的优势后，下一个关键问题是：如何实现 Agent 之间的通信？</p>
<p>A2A 协议原生支持的同步 RPC 协议包括 JSON-RPC、gRPC 和 REST。然而，在企业级的复杂场景下，这些同步协议面临诸多挑战。下表从多个维度对比同步 RPC 与 RocketMQ 异步通信模型的差异：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31d4c90bace346df9f116ed7f7f80bdb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=Hg5CcfZd2jx0h78t8RAeu0Wlowc%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-19">3.4 开箱即用：基于 RocketMQ 的 A2A 协议实现</h3>
<p>为加速 A2A 协议在异步通信场景的落地，我们基于 RocketMQ SDK 实现了 A2A 协议的 ClientTransport 接口。该实现旨在帮助用户在搭建多智能体应用时，能够专注于自身业务逻辑，快速构建高可靠、开箱即用的 A2A 通信方案。</p>
<pre><code class="hljs language-less" lang="less">发送普通同步请求：
<span class="hljs-selector-tag">EventKind</span> <span class="hljs-selector-tag">sendMessage</span>(MessageSendParams request, <span class="hljs-variable">@Nullable</span> ClientCallContext context)
发送<span class="hljs-selector-tag">Stream</span>请求：
<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">sendMessageStreaming</span>(MessageSendParams request, Consumer&lt;StreamingEventKind&gt; eventConsumer…)
重订订阅任务数据：
<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">resubscribe</span>(TaskIdParams request, Consumer&lt;StreamingEventKind&gt; eventConsumer, Consumer&lt;Throwable&gt; errorConsumer
查询任务完成状态：
Task <span class="hljs-built_in">getTask</span>(TaskQueryParams request, <span class="hljs-variable">@Nullable</span> ClientCallContext context)
取消任务执行
Task <span class="hljs-built_in">cancelTask</span>(TaskIdParams request, <span class="hljs-variable">@Nullable</span> ClientCallContext context)
以及其他方法
</code></pre>
<h4 data-id="heading-20">开源项目地址</h4>
<p>基于 RocketMQ 实现的 A2A 通信 RocketMQTransport 部分代码现已开源，欢迎关注！</p>
<p>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Frocketmq-a2a" target="_blank" title="https://github.com/apache/rocketmq-a2a" ref="nofollow noopener noreferrer">github.com/apache/rock…</a></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c89a7bbf097743fd9ed367626086e875~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=BpcA53gGy%2FH8UCPO7SJh2qL0AhI%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-21">3.5 架构解析：如何通过 RocketMQ 实现 Agent 间通信？</h3>
<p>在一个典型的多智能体协作架构中，通信流程如下：</p>
<ul>
<li>应用 A 扮演 Supervisor 角色，负责对用户输入的需求进行任务分解，并将拆分后的子任务分别发送至应用 B 的业务 Topic（Normal Topic1）和应用 C 的业务 Topic（Normal Topic2）。</li>
<li>应用 B 集群从 Normal Topic1 拉取消息并执行相应逻辑处理，随后将结果发布到应用 A 订阅的 LiteTopic。</li>
<li>应用 C 集群则从 Normal Topic2 拉取消息进行处理，并同样将结果写入该 LiteTopic。</li>
<li>应用 A 集群通过拉取 LiteTopic 中的消息，汇聚各子任务的响应结果，进而驱动后续的业务逻辑编排。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9a15b8ea06504744a31d8e1dd13dd97d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=S4gLb%2FgMMBGGbEhK4FmDU%2BJLLr4%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-22">AgentScope × RocketMQ：构建多智能体应用的最佳组合</h2>
<p>理论与架构已经铺垫完毕，接下来，让我们结合一个完整的实战案例，看看如何将这套强大的通信基座，与顶尖的智能体开发框架 AgentScope 相结合，构建一个真正可用的多智能体应用。</p>
<h3 data-id="heading-23">4.1 AgentScope：面向多智能体的开发者友好框架</h3>
<p>AgentScope 是阿里巴巴继 AI 模型社区 ModelScope 后，在 Agent 领域的又一战略级开源力作。它以“开发者为中心”，专注于提供智能体开发的开源框架，为构建复杂的多智能体应用提供了从设计、开发到调试的全套解决方案。它具备以下核心优势：</p>
<ul>
<li><strong>对开发者透明</strong>：拒绝隐式魔法，所有环节（提示、API、智能体、工作流）可见、可控。</li>
<li><strong>实时可介入</strong>：原生支持运行时中断与自定义处理。</li>
<li><strong>更智能</strong>：内置工具管理、长期记忆、智能 RAG 等能力。</li>
<li><strong>模型无关</strong>：一次编写，无缝适配各类大模型。</li>
<li><strong>乐高式构建</strong>：模块化设计，组件解耦、自由组合。</li>
<li><strong>面向多智能体</strong>：显式消息传递与工作流编排，专为协作场景打造。</li>
<li><strong>高度可定制</strong>：全面开放工具、提示、智能体、工作流及可视化扩展，鼓励深度定制。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a684ba44178140249064b42294204941~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=2aHxEIkyawevWm5bxna3MdJXYe4%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-24">4.2 AgentScope x RocketMQ 的集成架构与合作展望</h3>
<p>在明确了 AgentScope 的功能定位与应用价值之后，我们将进一步探讨其通信层与 RocketMQ 的现有集成机制，并展望双方在技术协同与生态共建方面的未来合作方向。</p>
<h4 data-id="heading-25">4.2.1 AgentScope 与 RocketMQ 集成架构</h4>
<p>当 AgentScope 作为 Agent 应用服务提供者时，其内部支持符合 A2A（Agent-to-Agent）协议的多种通信方式，包括基于 JSONRPC 的 WebService 和 RocketMQ Service，用于接收并处理来自其他 Agent 的 A2A 协议请求。同时，AgentScope 通过 well-known 服务接口向外标准化地透出其所承载 Agent 的核心能力信息，包括但不限于：</p>
<ul>
<li>
<p>name（名称） </p>
</li>
<li>
<p>description（描述） </p>
</li>
<li>
<p>capabilities（能力列表） </p>
</li>
<li>
<p>additionalInterfaces（额外支持的接口或协议）</p>
</li>
</ul>
<p>这些元数据使调用方能够清晰识别该 Agent 提供的主要功能、所支持的通信协议及其对应的接入方式。</p>
<p>当 AgentScope 作为 Agent 应用服务的调用者时，它首先通过访问目标 Agent 暴露的 well-known 服务，动态获取其详细的能力描述、支持的协议类型及对应的服务接入点（如 JSONRPC 端点或 RocketMQ Topic 信息）。随后，在通信层，AgentScope 利用 A2A 协议定义的传输客户端（如 <code>JSONRPCTransport</code> 或 <code>RocketMQTransport</code>）发起请求，并对返回的响应结果进行统一解析与处理，从而实现跨 Agent 的标准化、可互操作的协同调用。</p>
<p><strong>1. 基于 RocketMQ 协议通信架构图</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c6a2fd8b33d940afa883e53af6914f24~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=FKtz1vv5VAp75BcQQ1intljYlrg%3D" alt="图片" loading="lazy"/></p>
<p><strong>2. 基于 JSONRPC 协议通信架构图</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dfe842b856034302bbba12941397b17d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=cHJFty0PqTzsfNfw1ZOZk66KAhE%3D" alt="图片" loading="lazy"/></p>
<h4 data-id="heading-26">4.2.2 合作展望</h4>
<p>随着人工智能与分布式系统技术的深度融合，消息中间件与智能体（Agent）平台的协同正成为构建下一代智能分布式应用的关键路径。作为 Apache 软件基金会顶级项目，RocketMQ 凭借高吞吐、低延迟和高可靠等核心特性，已成为全球广泛采用的分布式消息队列，在金融、电商、物联网等关键领域积累了深厚的技术积淀，并于近期推出了轻量级通信模型 LiteTopic，进一步拓展了其在 AI 应用场景中的适用性。与此同时，AgentScope 作为新兴的智能体编排与运行平台，专注于为多智能体系统提供统一的调度、通信与治理能力。二者在技术理念与应用场景上高度契合，展现出广阔的合作前景与协同创新潜力。</p>
<p><strong>1. 技术互补：构建“消息驱动 + 智能决策”的新型架构</strong></p>
<p>RocketMQ 提供了强大的异步通信、事件驱动和流式处理能力。AgentScope 则聚焦于智能体生命周期管理、任务分解、上下文感知与自主协作。未来，二者可深度融合，形成“消息即事件、事件触发智能体行为”的新型架构：</p>
<ul>
<li>智能体间通信的标准化通道：利用 RocketMQ 作为 AgentScope 内部或跨集群智能体之间的可靠通信总线，保障高并发、有序、可追溯的消息传递，提升多智能体系统的鲁棒性与扩展性。</li>
</ul>
<p><strong>2. 生态共建：推动开源与标准协同发展</strong></p>
<p>双方可基于开源社区开展深度合作：</p>
<ul>
<li><strong>集成适配器开发</strong>：共同开发 RocketMQ 与 AgentScope 的官方集成插件，简化开发者接入流程。</li>
<li><strong>联合参考架构发布</strong>：推出面向典型场景（如智能客服等场景）的联合解决方案模板，加速行业落地。</li>
<li><strong>参与标准制定</strong>：在事件驱动架构（EDA）、智能体通信协议等领域协同推进开放标准，促进生态互操作性。</li>
</ul>
<h3 data-id="heading-27">4.3 场景案例：用 AgentScope 与 RocketMQ 打造“智能旅行助手”</h3>
<p>本案例以 AgentScope 作为 AI 智能体应用开发框架，构建了三个智能体：</p>
<ul>
<li>SupervisorAgent（总控）：负责与用户交互，任务分解与逻辑编排。</li>
<li>WeatherAgent（天气专家）：负责查询天气信息。</li>
<li>TravelAgent（旅行专家）：负责依据天气进行用户的行程规划。</li>
</ul>
<p>SupervisorAgent 应用具有如下逻辑：</p>
<ul>
<li>如果用户只查询天气情况，则直接请求 WeatherAgent 进行天气信息查询；</li>
<li>如果用户希望做出行程规划，则先向 WeatherAgent 发出天气查询请求，获取对应天气信息后，再带着天气信息向 TravelAgent 发出行程规划请求，TravelAgent 对行程结果进行规划后将响应结果发送至 SupervisorAgent 订阅的 LiteTopic，SupervisorAgent 应用将结果发送至用户侧。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c2e5b3b374ba476abdc5ba4a0e8879ed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=2UKv%2B5v26qhfWgiS6nd5z6BUSX8%3D" alt="图片" loading="lazy"/></p>
<h2 data-id="heading-28">实战演练：三步构建高可靠多智能体应用</h2>
<p>阿里云官网现已提供免费试用、一键部署的《<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzUzNzYxNjAzMg%3D%3D%26mid%3D2247579154%26idx%3D1%26sn%3D04bf8e31f323ee5121430a55737d863f%26scene%3D21%23wechat_redirect" target="_blank" title="https://mp.weixin.qq.com/s?__biz=MzUzNzYxNjAzMg==&amp;mid=2247579154&amp;idx=1&amp;sn=04bf8e31f323ee5121430a55737d863f&amp;scene=21#wechat_redirect" ref="nofollow noopener noreferrer">RocketMQ for AI：企业级 AI 应用集成的异步通信方案</a>》，带您亲手搭建并运行一个多智能体应用，并基于 RocketMQ LiteTopic 实现多智能体异步通信能力——具备持久化、高可靠、可追溯等特性，显著提升 AI 应用交互的稳定性与可观测性。</p>
<h3 data-id="heading-29">5.1 方案概览：技术架构与云资源</h3>
<p>本方案将带领您搭建一个多智能体（Multi-Agent）系统，能够根据用户的需求查询天气信息并制定行程规划。</p>
<p>为简化部署过程，我们将在 1 台云服务器 ECS 上部署 3 个独立的 Agent（SupervisorAgent，WeatherAgent 和 TravelAgent，具体功能可参考 4.3），并且通过 RocketMQ 消息服务实现 Agent 之间的异步通信。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75af0113392647a2b423cf0f75f7b606~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=dtWb9L%2FYKvqqKcsogdS6tYmvUVI%3D" alt="图片" loading="lazy"/></p>
<p>本方案的技术架构包含构建一个完整多智能体应用所需的所有云资源：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6aad2a8735dc4339903454150d864d45~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=Drj1XQCCcNGTG34TQbRskkUapvs%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-30">5.2 三步体验：从创建资源到部署 Agent</h3>
<p><strong>1. 免费一键部署资源</strong></p>
<p>访问体验方案页面，点击“免费试用”，进入实验操作界面后，点击“立即试用”即可领取免费试用点，自动开始创建资源。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d2c57e24927d44a1882461c4abaaad9a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=cMxjDRgl205XB4v%2BTkBkR%2F5yr8E%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d131df62cf964543beea7fca62e29444~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=xvVrbazq7YrW%2Fl2FBM0qlxLBbfg%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/648c67b5c158409d83295e64d7dec6b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=j%2BMX4Tl5Fqk%2F59IP71qQRTR1uRI%3D" alt="图片" loading="lazy"/></p>
<p><strong>2. 创建 Topic 和 Group</strong></p>
<p>共创建 3 个 Topic，配置参数见下表，其余参数保持默认。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ec17a2697eff44c3bdfdadb7b48d6d7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=M7AlEqrTgAGWizQU9sEGBZ3H8S8%3D" alt="图片" loading="lazy"/></p>
<p>共创建 3 个 Group，配置参数见下表，其余参数保持默认。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c618a463420e4bf89ae576ba6cfecf1a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=ab39UGHY7GTGF9L%2Bv%2FEyTywwpbg%3D" alt="图片" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/de3018d657414c1ba048a91d381ff842~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=opB%2B%2B6FU9Ri3MQDd0NuS0r%2FOGzw%3D" alt="图片" loading="lazy"/></p>
<p><strong>3. 创建部署智能体应用</strong></p>
<p>在阿里云百炼的应用管理页面，根据示例文档中提供的模型参数和提示词，分别创建并发布两个智能体应用（天气助手 Agent、行程助手 Agent）。</p>
<p>远程连接云服务器 ECS 根据提供的执行脚本部署示例应用程序。等待应用启动完毕，大约需要 3~5 分钟，直到终端显示 You &gt; 提示符，便可直接在终端中输入信息与智能体交互。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/98d9e8330c1e4e0e8683b83577fbcba8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=wm40Vqv0OvXDAnhbntqqHbKPk9c%3D" alt="图片" loading="lazy"/></p>
<h3 data-id="heading-31">5.3 结果验证：任务执行与消息轨迹追踪</h3>
<ol>
<li>
<p>在 <code>You &gt;</code> 提示符后，输入 <code>帮我做一个下周三到下周日杭州周边自驾游方案</code> 并回车。</p>
</li>
<li>
<p>等待智能体执行任务，最终会返回结合天气信息的行程规划内容，过程如下：</p>
</li>
</ol>
<p>a. SupervisorAgent 接收用户输入，向消息队列发送一条消息 <code>杭州下周三到周日的天气情况怎么样?</code>。</p>
<p>b. WeatherAgent 监听到上述消息，执行天气查询，并将结果发往消息队列。</p>
<p>c. SupervisorAgent 监听到上述消息，获取了天气查询结果，然后向消息队列发送一条消息 <code>杭州下周三至周日天气已知，天气为***，请基于此制定一份从杭州出发的周边2人3天4晚自驾游行程规划（下周三出发，周日返回），包含住宿、餐饮与景点推荐</code>。</p>
<p>d. TravelAgent 监听到上述消息，执行行程规划，并将结果发往消息队列。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/56af97fcd20f4f48a6ca2f19453430f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=8yPpuccH%2BnmnUyuKg%2FwMXeA5TN0%3D" alt="图片" loading="lazy"/></p>
<ol start="3">
<li>查看消息轨迹：在云消息队列 RocketMQ 版实例详情页，可以按 Topic 或按 LiteTopic 查询到相关的消息轨迹。</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/95efbdef966e4a0db3eac9d2613da9cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_6YeM5LqR5LqR5Y6f55Sf:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555233&amp;x-signature=MgVNMiQfDIZUsbFB2EuyElrtUZQ%3D" alt="图片" loading="lazy"/></p>
<p>目前，该解决方案已在阿里云官网上线，欢迎点击<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.aliyun.com%2Fsolution%2Ftech-solution%2Frocketmq-for-multi-agent-communication" target="_blank" title="https://www.aliyun.com/solution/tech-solution/rocketmq-for-multi-agent-communication" ref="nofollow noopener noreferrer">此处</a>即可部署体验～</p>
<p>邀请您钉钉搜索群号：110085036316，加入 RocketMQ for AI 用户交流群，探索更多产品功能与应用场景，与我们共建 AI MQ 的未来！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[小米不仅造车，还造模型？309B参数全开源，深度思考完胜DeepSeek 🐒🐒🐒]]></title>    <link>https://juejin.cn/post/7584377629706453027</link>    <guid>https://juejin.cn/post/7584377629706453027</guid>    <pubDate>2025-12-17T05:55:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584377629706453027" data-draft-id="7584379805899014196" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="小米不仅造车，还造模型？309B参数全开源，深度思考完胜DeepSeek 🐒🐒🐒"/> <meta itemprop="keywords" content="前端,后端,人工智能"/> <meta itemprop="datePublished" content="2025-12-17T05:55:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Moment"/> <meta itemprop="url" content="https://juejin.cn/user/3782764966460398"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            小米不仅造车，还造模型？309B参数全开源，深度思考完胜DeepSeek 🐒🐒🐒
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3782764966460398/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Moment
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T05:55:16.000Z" title="Wed Dec 17 2025 05:55:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><blockquote>
<p>我正在开发 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxun082%2FDocFlow" target="_blank" title="https://github.com/xun082/DocFlow" ref="nofollow noopener noreferrer">DocFlow</a>，它是一个完整的 AI 全栈协同文档平台。该项目融合了多个技术栈，包括基于 <code>Tiptap</code> 的富文本编辑器、<code>NestJs</code> 后端服务、<code>AI</code> 集成功能和实时协作。在开发过程中，我积累了丰富的实战经验，涵盖了 <code>Tiptap</code> 的深度定制、性能优化和协作功能的实现等核心难点。</p>
</blockquote>
<p>如果你对 AI 全栈开发、Tiptap 富文本编辑器定制或 DocFlow 项目的完整技术方案感兴趣，欢迎加我微信 <code>yunmz777</code> 进行私聊咨询，获取详细的技术分享和最佳实践。</p>
<p>小米不仅造车，还造模型？</p>
<p>2024 年 12 月，当所有人还在关注小米汽车的时候，小米却悄然开源了一款震撼整个 AI 界的大语言模型——<code>MiMo-V2-Flash</code>。这款拥有 <code>309B总参数</code>、<code>15B激活参数</code> 的超大规模模型，不仅在性能上达到了世界顶尖水平，更在深度思考能力上完胜 <code>DeepSeek</code>，重新定义了 AI 模型的效率天花板。</p>
<p>本文将详细介绍这款模型的技术特点、性能表现以及使用方式。</p>
<h2 data-id="heading-0">MiMo-V2-Flash</h2>
<p><code>MiMo-V2-Flash</code> 是一个混合专家（<code>MoE</code>）语言模型，拥有 <code>309B总参数</code> 和 <code>15B激活参数</code>。专为高速推理和智能体工作流设计，它采用了新颖的混合注意力架构和多 Token 预测（<code>MTP</code>）技术，在显著降低推理成本的同时实现了最先进的性能。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5acce908590d4e3aac5d72e211e4d57a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555715&amp;x-signature=5eY4IFO%2F5tdajGvKoLS1qrZ03a8%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-1">1. 介绍</h2>
<p>MiMo-V2-Flash 在长上下文建模能力和推理效率之间创造了新的平衡。主要特性包括：</p>
<ul>
<li>混合注意力架构：以 5:1 的比例交织滑动窗口注意力（<code>SWA</code>）和全局注意力（<code>GA</code>），采用激进的 128-token 窗口。通过可学习的 <code>attention sink bias</code>（注意力沉降偏置），在保持长上下文性能的同时，将 <code>KV缓存</code> 存储减少了近 6 倍。</li>
<li>多 Token 预测（<code>MTP</code>）：配备了轻量级 <code>MTP</code> 模块（每块 0.33B 参数），使用密集 <code>FFN</code>。这将推理期间的输出速度提升了 3 倍，并有助于加速 <code>RL</code> 训练中的 <code>rollout</code>。</li>
<li>高效预训练：使用 <code>FP8</code> 混合精度在 27T token 上训练，原生 32k 序列长度。上下文窗口支持最长 256k。</li>
<li>智能体能力：后训练利用多教师在线策略蒸馏（<code>MOPD</code>）和大规模智能体 <code>RL</code>，在 <code>SWE-Bench</code> 和复杂推理任务上实现了卓越性能。</li>
</ul>
<h2 data-id="heading-2">2. 模型下载</h2>


























<table><thead><tr><th align="left">模型</th><th align="center">总参数</th><th align="center">激活参数</th><th align="center">上下文长度</th><th align="center">下载地址</th></tr></thead><tbody><tr><td align="left">MiMo-V2-Flash-Base</td><td align="center">309B</td><td align="center">15B</td><td align="center">256k</td><td align="center"><a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2FXiaomiMiMo%2FMiMo-V2-Flash-Base" target="_blank" title="https://huggingface.co/XiaomiMiMo/MiMo-V2-Flash-Base" ref="nofollow noopener noreferrer">🤗 HuggingFace</a></td></tr><tr><td align="left">MiMo-V2-Flash</td><td align="center">309B</td><td align="center">15B</td><td align="center">256k</td><td align="center"><a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2FXiaomiMiMo%2FMiMo-V2-Flash" target="_blank" title="https://huggingface.co/XiaomiMiMo/MiMo-V2-Flash" ref="nofollow noopener noreferrer">🤗 HuggingFace</a></td></tr></tbody></table>
<blockquote>
<p>重要提示：我们还开源了 3 层 <code>MTP</code> 权重，以促进社区研究。</p>
</blockquote>
<h2 data-id="heading-3">3. 评估结果</h2>
<h3 data-id="heading-4">基础模型评估</h3>
<p>MiMo-V2-Flash-Base 在标准基准测试中展现出强大的性能，超越了参数量显著更大的模型。</p>




































































































































































































































































































































































<table><thead><tr><th align="left">类别</th><th align="left">基准测试</th><th align="left">设置/长度</th><th align="center">MiMo-V2-Flash Base</th><th align="center">Kimi-K2 Base</th><th align="center">DeepSeek-V3.1 Base</th><th align="center">DeepSeek-V3.2 Exp Base</th></tr></thead><tbody><tr><td align="left">参数</td><td align="left">激活参数 / 总参数</td><td align="left">-</td><td align="center">15B / 309B</td><td align="center">32B / 1043B</td><td align="center">37B / 671B</td><td align="center">37B / 671B</td></tr><tr><td align="left">通用</td><td align="left">BBH</td><td align="left">3-shot</td><td align="center">88.5</td><td align="center">88.7</td><td align="center">88.2</td><td align="center">88.7</td></tr><tr><td align="left"/><td align="left">MMLU</td><td align="left">5-shot</td><td align="center">86.7</td><td align="center">87.8</td><td align="center">87.4</td><td align="center">87.8</td></tr><tr><td align="left"/><td align="left">MMLU-Redux</td><td align="left">5-shot</td><td align="center">90.6</td><td align="center">90.2</td><td align="center">90.0</td><td align="center">90.4</td></tr><tr><td align="left"/><td align="left">MMLU-Pro</td><td align="left">5-shot</td><td align="center">73.2</td><td align="center">69.2</td><td align="center">58.8</td><td align="center">62.1</td></tr><tr><td align="left"/><td align="left">DROP</td><td align="left">3-shot</td><td align="center">84.7</td><td align="center">83.6</td><td align="center">86.3</td><td align="center">86.6</td></tr><tr><td align="left"/><td align="left">ARC-Challenge</td><td align="left">25-shot</td><td align="center">95.9</td><td align="center">96.2</td><td align="center">95.6</td><td align="center">95.5</td></tr><tr><td align="left"/><td align="left">HellaSwag</td><td align="left">10-shot</td><td align="center">88.5</td><td align="center">94.6</td><td align="center">89.2</td><td align="center">89.4</td></tr><tr><td align="left"/><td align="left">WinoGrande</td><td align="left">5-shot</td><td align="center">83.8</td><td align="center">85.3</td><td align="center">85.9</td><td align="center">85.6</td></tr><tr><td align="left"/><td align="left">TriviaQA</td><td align="left">5-shot</td><td align="center">80.3</td><td align="center">85.1</td><td align="center">83.5</td><td align="center">83.9</td></tr><tr><td align="left"/><td align="left">GPQA-Diamond</td><td align="left">5-shot</td><td align="center">55.1</td><td align="center">48.1</td><td align="center">51.0</td><td align="center">52.0</td></tr><tr><td align="left"/><td align="left">SuperGPQA</td><td align="left">5-shot</td><td align="center">41.1</td><td align="center">44.7</td><td align="center">42.3</td><td align="center">43.6</td></tr><tr><td align="left"/><td align="left">SimpleQA</td><td align="left">5-shot</td><td align="center">20.6</td><td align="center">35.3</td><td align="center">26.3</td><td align="center">27.0</td></tr><tr><td align="left">数学</td><td align="left">GSM8K</td><td align="left">8-shot</td><td align="center">92.3</td><td align="center">92.1</td><td align="center">91.4</td><td align="center">91.1</td></tr><tr><td align="left"/><td align="left">MATH</td><td align="left">4-shot</td><td align="center">71.0</td><td align="center">70.2</td><td align="center">62.6</td><td align="center">62.5</td></tr><tr><td align="left"/><td align="left">AIME 24&amp;25</td><td align="left">2-shot</td><td align="center">35.3</td><td align="center">31.6</td><td align="center">21.6</td><td align="center">24.8</td></tr><tr><td align="left">代码</td><td align="left">HumanEval+</td><td align="left">1-shot</td><td align="center">70.7</td><td align="center">84.8</td><td align="center">64.6</td><td align="center">67.7</td></tr><tr><td align="left"/><td align="left">MBPP+</td><td align="left">3-shot</td><td align="center">71.4</td><td align="center">73.8</td><td align="center">72.2</td><td align="center">69.8</td></tr><tr><td align="left"/><td align="left">CRUXEval-I</td><td align="left">1-shot</td><td align="center">67.5</td><td align="center">74.0</td><td align="center">62.1</td><td align="center">63.9</td></tr><tr><td align="left"/><td align="left">CRUXEval-O</td><td align="left">1-shot</td><td align="center">79.1</td><td align="center">83.5</td><td align="center">76.4</td><td align="center">74.9</td></tr><tr><td align="left"/><td align="left">MultiPL-E HumanEval</td><td align="left">0-shot</td><td align="center">59.5</td><td align="center">60.5</td><td align="center">45.9</td><td align="center">45.7</td></tr><tr><td align="left"/><td align="left">MultiPL-E MBPP</td><td align="left">0-shot</td><td align="center">56.7</td><td align="center">58.8</td><td align="center">52.5</td><td align="center">50.6</td></tr><tr><td align="left"/><td align="left">BigCodeBench</td><td align="left">0-shot</td><td align="center">70.1</td><td align="center">61.7</td><td align="center">63.0</td><td align="center">62.9</td></tr><tr><td align="left"/><td align="left">LiveCodeBench v6</td><td align="left">1-shot</td><td align="center">30.8</td><td align="center">26.3</td><td align="center">24.8</td><td align="center">24.9</td></tr><tr><td align="left"/><td align="left">SWE-Bench (AgentLess)</td><td align="left">3-shot</td><td align="center">30.8</td><td align="center">28.2</td><td align="center">24.8</td><td align="center">9.4*</td></tr><tr><td align="left">中文</td><td align="left">C-Eval</td><td align="left">5-shot</td><td align="center">87.9</td><td align="center">92.5</td><td align="center">90.0</td><td align="center">91.0</td></tr><tr><td align="left"/><td align="left">CMMLU</td><td align="left">5-shot</td><td align="center">87.4</td><td align="center">90.9</td><td align="center">88.8</td><td align="center">88.9</td></tr><tr><td align="left"/><td align="left">C-SimpleQA</td><td align="left">5-shot</td><td align="center">61.5</td><td align="center">77.6</td><td align="center">70.9</td><td align="center">68.0</td></tr><tr><td align="left">多语言</td><td align="left">GlobalMMLU</td><td align="left">5-shot</td><td align="center">76.6</td><td align="center">80.7</td><td align="center">81.9</td><td align="center">82.0</td></tr><tr><td align="left"/><td align="left">INCLUDE</td><td align="left">5-shot</td><td align="center">71.4</td><td align="center">75.3</td><td align="center">77.2</td><td align="center">77.2</td></tr><tr><td align="left">长上下文</td><td align="left">NIAH-Multi</td><td align="left">32K</td><td align="center">99.3</td><td align="center">99.8</td><td align="center">99.7</td><td align="center">85.6</td></tr><tr><td align="left"/><td align="left"/><td align="left">64K</td><td align="center">99.9</td><td align="center">100.0</td><td align="center">98.6</td><td align="center">85.9</td></tr><tr><td align="left"/><td align="left"/><td align="left">128K</td><td align="center">98.6</td><td align="center">99.5</td><td align="center">97.2</td><td align="center">94.3</td></tr><tr><td align="left"/><td align="left"/><td align="left">256K</td><td align="center">96.7</td><td align="center">-</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left"/><td align="left">GSM-Infinite Hard</td><td align="left">16K</td><td align="center">37.7</td><td align="center">34.6</td><td align="center">41.5</td><td align="center">50.4</td></tr><tr><td align="left"/><td align="left"/><td align="left">32K</td><td align="center">33.7</td><td align="center">26.1</td><td align="center">38.8</td><td align="center">45.2</td></tr><tr><td align="left"/><td align="left"/><td align="left">64K</td><td align="center">31.5</td><td align="center">16.0</td><td align="center">34.7</td><td align="center">32.6</td></tr><tr><td align="left"/><td align="left"/><td align="left">128K</td><td align="center">29.0</td><td align="center">8.8</td><td align="center">28.7</td><td align="center">25.7</td></tr></tbody></table>
<blockquote>
<ul>
<li>表示模型可能无法遵循提示或格式。</li>
</ul>
</blockquote>
<h3 data-id="heading-5">后训练模型评估</h3>
<p>通过采用 <code>MOPD</code> 和智能体 <code>RL</code> 的后训练范式，模型在推理和智能体性能上达到了最先进水平。</p>




















































































































































































































<table><thead><tr><th align="left">基准测试</th><th align="center">MiMo-V2 Flash</th><th align="center">Kimi-K2 Thinking</th><th align="center">DeepSeek-V3.2 Thinking</th><th align="center">Gemini-3.0 Pro</th><th align="center">Claude Sonnet 4.5</th><th align="center">GPT-5 High</th></tr></thead><tbody><tr><td align="left">推理</td><td align="center"/><td align="center"/><td align="center"/><td align="center"/><td align="center"/><td align="center"/></tr><tr><td align="left">MMLU-Pro</td><td align="center">84.9</td><td align="center">84.6</td><td align="center">85.0</td><td align="center">90.1</td><td align="center">88.2</td><td align="center">87.5</td></tr><tr><td align="left">GPQA-Diamond</td><td align="center">83.7</td><td align="center">84.5</td><td align="center">82.4</td><td align="center">91.9</td><td align="center">83.4</td><td align="center">85.7</td></tr><tr><td align="left">HLE (无工具)</td><td align="center">22.1</td><td align="center">23.9</td><td align="center">25.1</td><td align="center">37.5</td><td align="center">13.7</td><td align="center">26.3</td></tr><tr><td align="left">AIME 2025</td><td align="center">94.1</td><td align="center">94.5</td><td align="center">93.1</td><td align="center">95.0</td><td align="center">87.0</td><td align="center">94.6</td></tr><tr><td align="left">HMMT Feb. 2025</td><td align="center">84.4</td><td align="center">89.4</td><td align="center">92.5</td><td align="center">97.5</td><td align="center">79.2</td><td align="center">88.3</td></tr><tr><td align="left">LiveCodeBench-v6</td><td align="center">80.6</td><td align="center">83.1</td><td align="center">83.3</td><td align="center">90.7</td><td align="center">64.0</td><td align="center">84.5</td></tr><tr><td align="left">通用写作</td><td align="center"/><td align="center"/><td align="center"/><td align="center"/><td align="center"/><td align="center"/></tr><tr><td align="left">Arena-Hard (困难提示)</td><td align="center">54.1</td><td align="center">71.9</td><td align="center">53.4</td><td align="center">72.6</td><td align="center">63.3</td><td align="center">71.9</td></tr><tr><td align="left">Arena-Hard (创意写作)</td><td align="center">86.2</td><td align="center">80.1</td><td align="center">88.8</td><td align="center">93.6</td><td align="center">76.7</td><td align="center">92.2</td></tr><tr><td align="left">长上下文</td><td align="center"/><td align="center"/><td align="center"/><td align="center"/><td align="center"/><td align="center"/></tr><tr><td align="left">LongBench V2</td><td align="center">60.6</td><td align="center">45.1</td><td align="center">58.4</td><td align="center">65.6</td><td align="center">61.8</td><td align="center">-</td></tr><tr><td align="left">MRCR</td><td align="center">45.7</td><td align="center">44.2</td><td align="center">55.5</td><td align="center">89.7</td><td align="center">55.4</td><td align="center">-</td></tr><tr><td align="left">代码智能体</td><td align="center"/><td align="center"/><td align="center"/><td align="center"/><td align="center"/><td align="center"/></tr><tr><td align="left">SWE-Bench Verified</td><td align="center">73.4</td><td align="center">71.3</td><td align="center">73.1</td><td align="center">76.2</td><td align="center">77.2</td><td align="center">74.9</td></tr><tr><td align="left">SWE-Bench Multilingual</td><td align="center">71.7</td><td align="center">61.1</td><td align="center">70.2</td><td align="center">-</td><td align="center">68.0</td><td align="center">55.3</td></tr><tr><td align="left">Terminal-Bench Hard</td><td align="center">30.5</td><td align="center">30.6</td><td align="center">35.4</td><td align="center">39.0</td><td align="center">33.3</td><td align="center">30.5</td></tr><tr><td align="left">Terminal-Bench 2.0</td><td align="center">38.5</td><td align="center">35.7</td><td align="center">46.4</td><td align="center">54.2</td><td align="center">42.8</td><td align="center">35.2</td></tr><tr><td align="left">通用智能体</td><td align="center"/><td align="center"/><td align="center"/><td align="center"/><td align="center"/><td align="center"/></tr><tr><td align="left">BrowseComp</td><td align="center">45.4</td><td align="center">-</td><td align="center">51.4</td><td align="center">-</td><td align="center">24.1</td><td align="center">54.9</td></tr><tr><td align="left">BrowseComp (带上下文管理)</td><td align="center">58.3</td><td align="center">60.2</td><td align="center">67.6</td><td align="center">59.2</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="left">τ²-Bench</td><td align="center">80.3</td><td align="center">74.3</td><td align="center">80.3</td><td align="center">85.4</td><td align="center">84.7</td><td align="center">80.2</td></tr></tbody></table>
<h2 data-id="heading-6">4. 模型架构</h2>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/27fdcb35527c4e21865d50489f9eaca9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555715&amp;x-signature=%2FwxDZSC9yLXjfcss3JTqkhzNa0k%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-7">混合滑动窗口注意力</h3>
<p>MiMo-V2-Flash 通过交织局部滑动窗口注意力（<code>SWA</code>）和全局注意力（<code>GA</code>）来解决长上下文的平方复杂度问题。</p>
<ul>
<li>配置：M=8 个混合块的堆叠。每个块包含 N=5 个 <code>SWA</code> 层，之后是 1 个 <code>GA</code> 层。</li>
<li>效率：<code>SWA</code> 层使用 128 个 token 的窗口大小，显著减少了 <code>KV缓存</code>。</li>
<li>沉降偏置：应用可学习的注意力沉降偏置，即使在激进的窗口大小下也能保持性能。</li>
</ul>
<h3 data-id="heading-8">轻量级多 Token 预测（MTP）</h3>
<p>与传统的推测解码不同，我们的 <code>MTP</code> 模块原生集成用于训练和推理。</p>
<ul>
<li>结构：使用密集 <code>FFN</code>（而非 <code>MoE</code>）和 <code>SWA</code>（而非 <code>GA</code>）来保持较低的参数量（每块 0.33B）。</li>
<li>性能：促进自推测解码，将生成速度提升 3 倍，并缓解小批量 <code>RL</code> 训练期间的 <code>GPU</code> 空闲问题。</li>
</ul>
<h2 data-id="heading-9">5. 后训练技术亮点</h2>
<p>MiMo-V2-Flash 利用专门设计的后训练流程，通过创新的蒸馏和强化学习策略最大化推理和智能体能力。</p>
<h3 data-id="heading-10">5.1 多教师在线策略蒸馏（MOPD）</h3>
<p>我们引入了 <code>多教师在线策略蒸馏（MOPD）</code>，这是一种将知识蒸馏重新定义为强化学习过程的新范式。</p>
<ul>
<li>密集 Token 级指导：与依赖稀疏序列级反馈的方法不同，<code>MOPD</code> 利用领域特定的专家模型（教师）在每个 token 位置提供监督。</li>
<li>在线策略优化：学生模型从自己生成的响应中学习，而不是从固定数据集学习。这消除了暴露偏差，并确保更小、更稳定的梯度更新。</li>
<li>固有的奖励鲁棒性：奖励源于学生和教师之间的分布差异，使该过程天然抵抗奖励黑客攻击。</li>
</ul>
<h3 data-id="heading-11">5.2 扩展智能体强化学习</h3>
<p>我们大幅扩展了智能体训练环境，以提高智能和泛化能力。</p>
<ul>
<li>大规模代码智能体环境：我们利用真实世界的 GitHub 问题创建了超过 100,000 个可验证任务。我们的自动化流程维护着一个能够运行超过 10,000 个并发 pod 的 <code>Kubernetes</code> 集群，环境设置成功率达 70%。</li>
<li>Web 开发的多模态验证器：对于 Web 开发任务，我们采用基于视觉的验证器，通过录制的视频而非静态截图来评估代码执行。这减少了视觉幻觉并确保功能正确性。</li>
<li>跨域泛化：我们的实验表明，在代码智能体上的大规模 <code>RL</code> 训练能有效泛化到其他领域，提升数学和通用智能体任务的性能。</li>
</ul>
<h3 data-id="heading-12">5.3 先进的强化学习基础设施</h3>
<p>为了支持大规模 <code>MoE</code> 模型的高吞吐量 <code>RL</code> 训练，我们在 <code>SGLang</code> 和 <code>Megatron-LM</code> 基础上实现了多项基础设施优化。</p>
<ul>
<li>Rollout 路由重放（<code>R3</code>）：解决 <code>MoE</code> 路由在推理和训练之间的数值精度不一致问题。<code>R3</code> 在训练阶段重用 <code>rollout</code> 中的确切路由专家，以可忽略的开销确保一致性。</li>
<li>请求级前缀缓存：在多轮智能体训练中，此缓存存储先前轮次的 <code>KV</code> 状态和路由专家。它避免了重新计算，并确保跨轮次的采样一致性。</li>
<li>细粒度数据调度器：我们扩展了 <code>rollout</code> 引擎以调度细粒度序列而非微批次。结合部分 <code>rollout</code>，这显著减少了长尾任务导致的 <code>GPU</code> 空闲。</li>
<li>工具箱和工具管理器：使用 <code>Ray actor</code> 池的两层设计来处理资源争用。它消除了工具执行的冷启动延迟，并将任务逻辑与系统策略隔离。</li>
</ul>
<h2 data-id="heading-13">6. 推理与部署</h2>
<p>MiMo-V2-Flash 支持 <code>FP8</code> 混合精度推理。我们推荐使用 <code>SGLang</code> 以获得最佳性能。</p>
<p>使用建议：我们推荐将采样参数设置为 <code>temperature=0.8, top_p=0.95</code>。</p>
<h3 data-id="heading-14">使用 SGLang 快速开始</h3>
<pre><code class="hljs language-bash" lang="bash">pip install sglang

<span class="hljs-comment"># 启动服务器</span>
python3 -m sglang.launch_server \
        --model-path XiaomiMiMo/MiMo-V2-Flash \
        --served-model-name mimo-v2-flash \
        --pp-size 1 \
        --dp-size 2 \
        --enable-dp-attention \
        --tp-size 8 \
        --moe-a2a-backend deepep \
        --page-size 1 \
        --host 0.0.0.0 \
        --port 9001 \
        --trust-remote-code \
        --mem-fraction-static 0.75 \
        --max-running-requests 128 \
        --chunked-prefill-size 16384 \
        --reasoning-parser qwen3 \
        --tool-call-parser mimo \
        --context-length 262144 \
        --attention-backend fa3 \
        --speculative-algorithm EAGLE \
        --speculative-num-steps 3 \
        --speculative-eagle-topk 1 \
        --speculative-num-draft-tokens 4 \
        --enable-mtp

<span class="hljs-comment"># 发送请求</span>
curl -i http://localhost:9001/v1/chat/completions \
    -H <span class="hljs-string">'Content-Type:application/json'</span> \
    -d  <span class="hljs-string">'{
            "messages" : [{
                "role": "user",
                "content": "Nice to meet you MiMo"
            }],
            "model": "mimo-v2-flash",
            "max_tokens": 4096,
            "temperature": 0.8,
            "top_p": 0.95,
            "stream": true,
            "chat_template_kwargs": {
                "enable_thinking": true
            }
        }'</span>
</code></pre>
<h3 data-id="heading-15">注意事项</h3>
<blockquote>
<p>重要提示：在带有多轮工具调用的思考模式中，模型会在 <code>tool_calls</code> 旁边返回一个 <code>reasoning_content</code> 字段。要继续对话，用户必须在每个后续请求的 <code>messages</code> 数组中保留所有历史 <code>reasoning_content</code>。</p>
</blockquote>
<blockquote>
<p>重要提示：强烈推荐使用以下系统提示，请从英文和中文版本中选择。</p>
</blockquote>
<p>英文版本</p>
<pre><code class="hljs language-plaintext" lang="plaintext">You are MiMo, an AI assistant developed by Xiaomi.

Today's date: {date} {week}. Your knowledge cutoff date is December 2024.
</code></pre>
<p>中文版本</p>
<pre><code class="hljs language-plaintext" lang="plaintext">你是MiMo（中文名称也是MiMo），是小米公司研发的AI智能助手。

今天的日期：{date} {week}，你的知识截止日期是2024年12月。
</code></pre>
<h2 data-id="heading-16">7. 引用</h2>
<p>如果您觉得我们的工作有帮助，请引用我们的技术报告：</p>
<pre><code class="hljs language-bibtex" lang="bibtex">@misc{mimo2025flash,
  title={MiMo-V2-Flash Technical Report},
  author={LLM-Core Xiaomi},
  year={2025},
  url={https://github.com/XiaomiMiMo/MiMo-V2-Flash/paper.pdf}
}
</code></pre>
<h2 data-id="heading-17">8. 相关链接</h2>
<ul>
<li>🤗 <a href="https://link.juejin.cn?target=https%3A%2F%2Fhuggingface.co%2FXiaomiMiMo%2FMiMo-V2-Flash" target="_blank" title="https://huggingface.co/XiaomiMiMo/MiMo-V2-Flash" ref="nofollow noopener noreferrer">HuggingFace 模型页面</a></li>
<li>📔 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FXiaomiMiMo%2FMiMo-V2-Flash%2Fblob%2Fmain%2Fpaper.pdf" target="_blank" title="https://github.com/XiaomiMiMo/MiMo-V2-Flash/blob/main/paper.pdf" ref="nofollow noopener noreferrer">技术报告</a></li>
<li>📰 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmimo.xiaomi.com%2Fblog%2Fmimo-v2-flash" target="_blank" title="https://mimo.xiaomi.com/blog/mimo-v2-flash" ref="nofollow noopener noreferrer">官方博客</a></li>
<li>🗨️ <a href="https://link.juejin.cn?target=https%3A%2F%2Faistudio.xiaomimimo.com" target="_blank" title="https://aistudio.xiaomimimo.com" ref="nofollow noopener noreferrer">在线体验 - Xiaomi MiMo Studio</a></li>
<li>🎨 <a href="https://link.juejin.cn?target=https%3A%2F%2Fplatform.xiaomimimo.com%2F" target="_blank" title="https://platform.xiaomimimo.com/" ref="nofollow noopener noreferrer">API 平台</a></li>
<li>💻 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FXiaomiMiMo%2FMiMo-V2-Flash" target="_blank" title="https://github.com/XiaomiMiMo/MiMo-V2-Flash" ref="nofollow noopener noreferrer">GitHub 仓库</a></li>
</ul>
<h2 data-id="heading-18">9. 结论</h2>
<p><code>MiMo-V2-Flash</code> 不仅在基准测试中展现出卓越的性能，更在实际应用场景中展现出独特的优势。特别是在深度思考能力方面，通过对比测试可以明显看出，在基本相同的输出结果质量下，小米 <code>MiMo-V2-Flash</code> 的深度思考功能相比 <code>DeepSeek</code> 具有显著优势。</p>
<p>这一优势体现在多个方面：</p>
<ul>
<li><strong>思考深度</strong>：<code>MiMo-V2-Flash</code> 能够进行更深入、更系统的思考，展现出更强的逻辑推理能力</li>
<li><strong>思考效率</strong>：在保证输出质量的前提下，能够更快速地完成深度思考过程</li>
<li><strong>思考质量</strong>：思考过程更加结构化、条理清晰，能够更好地展现推理路径</li>
</ul>
<p>这种深度思考能力的优势，使得 <code>MiMo-V2-Flash</code> 在复杂推理任务、学术研究、代码分析等需要深度思考的场景中，能够为用户提供更高质量、更可靠的智能服务。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/79f5bd57844044449d9ebccc43b0cf74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555715&amp;x-signature=dVQBQXkEG4JlMFoLLh024eZjiMk%3D" alt="深度思考对比测试 1" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/335d7c3c3a4a466b910f8c9ab9eaad83~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTW9tZW50:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766555715&amp;x-signature=dI%2FKbIB7uaTUbbTrJNb%2FAU4ckZA%3D" alt="深度思考对比测试 2" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[为什么玩游戏需要独立显卡？——GPU与CPU的分工协作]]></title>    <link>https://juejin.cn/post/7584370833704632335</link>    <guid>https://juejin.cn/post/7584370833704632335</guid>    <pubDate>2025-12-17T06:00:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584370833704632335" data-draft-id="7584370833704599567" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="为什么玩游戏需要独立显卡？——GPU与CPU的分工协作 "/> <meta itemprop="keywords" content="后端,程序员"/> <meta itemprop="datePublished" content="2025-12-17T06:00:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="无限大6"/> <meta itemprop="url" content="https://juejin.cn/user/2865758605422890"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            为什么玩游戏需要独立显卡？——GPU与CPU的分工协作 
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2865758605422890/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    无限大6
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T06:00:50.000Z" title="Wed Dec 17 2025 06:00:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎮 为什么玩游戏需要独立显卡？——GPU与CPU的分工协作 🔧</h2>
<blockquote>
<p>大家好，我是无限大，欢迎收看十万个为什么系列文章</p>
</blockquote>
<p>今天咱们来聊聊游戏玩家最关心的话题之一——显卡！不管你是硬核游戏玩家还是刚入门的小白，相信这篇文章都能让你对显卡有更深入的了解</p>
<p>想象一下，你正在餐厅吃饭：</p>
<ul>
<li>服务员（CPU）负责点餐、传菜、结账等各种杂活</li>
<li>厨师（GPU）专门负责做饭，而且是个超级大厨，能同时炒几十道菜</li>
</ul>
<p>电脑玩游戏也一样！CPU就像服务员，处理各种杂务；而GPU就像超级大厨，专门负责图形渲染。今天咱们就来揭开显卡的神秘面纱！</p>
<h3 data-id="heading-1">🤔 核心问题：为什么游戏不能只用CPU？</h3>
<p>很多人可能会问："我的电脑有CPU，为什么还要独立显卡？CPU不能玩游戏吗？"</p>
<p>答案是：<strong>能玩，但玩不好！</strong> 就像你让服务员去做饭，他可能会做，但速度慢、味道差，还会耽误其他工作。</p>
<h4 data-id="heading-2">举个例子：</h4>
<ul>
<li>用CPU玩《原神》：可能只有10-20帧，画面卡顿得像PPT</li>
<li>用独立显卡玩《原神》：轻松跑到60帧以上，画面流畅得像看电影</li>
</ul>
<p>这就是为什么游戏玩家都追求高性能显卡的原因！</p>
<h3 data-id="heading-3">📜 显卡的"进化史"：从集成到独立的革命</h3>
<h4 data-id="heading-4">1. 📺 集成显卡时代："能看就行"</h4>
<p>早期的电脑，显卡是集成在主板或CPU里的。那时候的显卡只能处理简单的2D图形，就像用蜡笔在纸上画画，勉强能看，但没什么细节。</p>
<p>想象一下，用集成显卡玩游戏，画面就像这样：</p>
<ul>
<li>人物是方块脸，没有表情</li>
<li>场景是简单的几何图形</li>
<li>没有光影效果，像黑白电影</li>
</ul>
<p>这就是20世纪90年代的游戏画面，是不是很简陋？🎮</p>
<h4 data-id="heading-5">2. 🚀 独立显卡诞生："画质革命"</h4>
<p>1999年，NVIDIA推出了GeForce 256，这是世界上第一块真正的独立显卡！它支持硬件T&amp;L（变换与光照），能实时计算3D图形的光影效果。</p>
<p>独立显卡的出现，就像给电脑装了一个"图形加速引擎"，游戏画面发生了质的飞跃：</p>
<ul>
<li>人物有了表情和细节</li>
<li>场景有了真实的光影效果</li>
<li>游戏变得更加流畅</li>
</ul>
<h4 data-id="heading-6">3. 💡 可编程着色器时代："艺术家的画笔"</h4>
<p>2001年，NVIDIA和ATI（后来被AMD收购）推出了支持可编程着色器的显卡。这意味着游戏开发者可以像艺术家一样，用"着色器语言"编写各种特效。</p>
<p>可编程着色器的出现，让游戏画面进入了"好莱坞级别"：</p>
<ul>
<li>真实的水面反射</li>
<li>动态的天气效果</li>
<li>细腻的皮肤质感</li>
<li>震撼的爆炸特效</li>
</ul>
<h3 data-id="heading-7">🔧 技术原理：GPU为什么这么牛？</h3>
<h4 data-id="heading-8">1. 🔄 并行计算架构："千手观音"</h4>
<p>CPU是"串行计算专家"，擅长处理复杂的逻辑问题，但只能同时做几件事。就像一个人同时做10道数学题，速度很慢。</p>
<p>GPU是"并行计算专家"，擅长处理简单的重复任务，能同时做成千上万件事。就像1000个人同时做1000道简单的加法题，速度飞快！</p>






























<table><thead><tr><th>特性</th><th>CPU</th><th>GPU</th></tr></thead><tbody><tr><td>核心数量</td><td>4-32个（少而精）</td><td>数千个（多而简）</td></tr><tr><td>擅长任务</td><td>复杂逻辑、串行计算</td><td>简单重复、并行计算</td></tr><tr><td>频率</td><td>3-5GHz</td><td>1-2GHz</td></tr><tr><td>缓存大小</td><td>16-64MB</td><td>几MB到几十MB</td></tr></tbody></table>
<h4 data-id="heading-9">2. 🎨 图形渲染流水线："流水线作业"</h4>
<p>玩游戏时，GPU需要完成一系列复杂的工作，就像工厂的流水线：</p>
<ol>
<li><strong>顶点处理</strong>：计算3D模型的顶点位置</li>
<li><strong>光栅化</strong>：将3D模型转换为2D像素</li>
<li><strong>片元着色</strong>：计算每个像素的颜色和特效</li>
<li><strong>纹理映射</strong>：给像素贴上纹理图片</li>
<li><strong>深度测试</strong>：处理物体的前后关系</li>
<li><strong>输出合并</strong>：将最终像素写入显存</li>
</ol>
<p>GPU的并行架构特别适合这种流水线作业，每个步骤都能同时处理大量数据！</p>
<h3 data-id="heading-10">💪 数据支撑：GPU到底有多强？</h3>
<ul>
<li><strong>RTX 4090</strong>：16384个CUDA核心，每秒可渲染300帧4K游戏</li>
<li><strong>RTX 3090</strong>：10496个CUDA核心，4K游戏可达60-120帧</li>
<li><strong>AMD RX 7900 XTX</strong>：6144个流处理器，性能与RTX 4080相当</li>
<li><strong>集成显卡</strong>：只有几十个CUDA核心，只能玩简单游戏</li>
</ul>
<h3 data-id="heading-11">🎯 趣味对比：CPU vs GPU的任务分工</h3>



































<table><thead><tr><th>任务类型</th><th>谁更适合？</th><th>原因</th></tr></thead><tbody><tr><td>玩3A游戏</td><td>GPU</td><td>游戏需要大量并行计算，GPU的千核心架构更适合</td></tr><tr><td>编辑文档</td><td>CPU</td><td>文档编辑是串行任务，CPU的高频率更适合</td></tr><tr><td>视频渲染</td><td>GPU</td><td>视频渲染是并行任务，GPU渲染速度比CPU快10-20倍</td></tr><tr><td>编程开发</td><td>CPU</td><td>编译代码是串行任务，CPU的复杂逻辑处理更适合</td></tr><tr><td>挖矿</td><td>GPU</td><td>挖矿是简单重复计算，GPU的并行架构效率更高</td></tr></tbody></table>
<h3 data-id="heading-12">💻 代码实例：GPU的并行计算能力</h3>
<p>咱们来用Python和NumPy模拟一下CPU和GPU的计算差异：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># 创建一个大数组</span>
size = <span class="hljs-number">100000000</span>
arr = np.random.rand(size)

<span class="hljs-comment"># CPU计算：串行求和</span>
start_time = time.time()
cpu_result = np.<span class="hljs-built_in">sum</span>(arr)
cpu_time = time.time() - start_time
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"CPU求和耗时：<span class="hljs-subst">{cpu_time:<span class="hljs-number">.2</span>f}</span>秒"</span>)

<span class="hljs-comment"># 模拟GPU计算：并行求和（实际需要CUDA支持）</span>
<span class="hljs-comment"># 这里只是模拟，真实GPU计算需要使用CUDA或OpenCL</span>
start_time = time.time()
<span class="hljs-comment"># 模拟并行计算：将数组分成1000份，同时计算</span>
chunk_size = size // <span class="hljs-number">1000</span>
chunks = [arr[i:i+chunk_size] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, size, chunk_size)]
gpu_result = <span class="hljs-built_in">sum</span>(np.<span class="hljs-built_in">sum</span>(chunk) <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> chunks)
gpu_time = time.time() - start_time
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"模拟GPU求和耗时：<span class="hljs-subst">{gpu_time:<span class="hljs-number">.2</span>f}</span>秒"</span>)

<span class="hljs-built_in">print</span>(<span class="hljs-string">f"GPU比CPU快<span class="hljs-subst">{cpu_time/gpu_time:<span class="hljs-number">.1</span>f}</span>倍！"</span>)
</code></pre>
<p><strong>运行结果（模拟）</strong>：</p>
<ul>
<li>CPU求和耗时：1.23秒</li>
<li>模拟GPU求和耗时：0.15秒</li>
<li>GPU比CPU快8.2倍！</li>
</ul>
<h3 data-id="heading-13">⚠️ 误区纠正：显卡不是越贵越好</h3>
<p>很多人认为"显卡越贵，游戏性能越好"，其实这并不完全正确！</p>
<h4 data-id="heading-14">选显卡的正确姿势：</h4>
<ol>
<li>看你的游戏需求：1080P游戏用RTX 3060就行，4K游戏才需要RTX 4090</li>
<li>看CPU搭配：CPU太差的话，高端显卡也发挥不出全部性能</li>
<li>看电源容量：高端显卡需要大功率电源（RTX 4090需要850W以上）</li>
<li>看散热条件：显卡发热大，需要良好的机箱散热</li>
</ol>
<h3 data-id="heading-15">🔮 未来展望：GPU的发展趋势</h3>
<h4 data-id="heading-16">1. 🚀 更强大的并行计算</h4>
<p>未来的GPU会有更多的核心，更高的频率，更强的性能！</p>
<h4 data-id="heading-17">2. 🧠 AI与图形渲染结合</h4>
<p>NVIDIA的DLSS技术已经证明了AI可以提升游戏画质和性能。未来，AI会在图形渲染中发挥更大作用！</p>
<h4 data-id="heading-18">3. 💡 光追技术普及</h4>
<p>光线追踪技术能让游戏画面更真实，未来会成为游戏的标配！</p>
<h4 data-id="heading-19">4. 📱 移动端GPU崛起</h4>
<p>随着手机游戏的发展，移动端GPU也会越来越强，未来可能和桌面GPU媲美！</p>
<h3 data-id="heading-20">🎓 互动小测验：你答对了吗？</h3>



































<table><thead><tr><th>问题</th><th>答案</th><th>你答对了吗？</th></tr></thead><tbody><tr><td>世界上第一块独立显卡是什么？</td><td>GeForce 256</td><td>✅/❌</td></tr><tr><td>GPU的核心数量一般是多少？</td><td>数千个</td><td>✅/❌</td></tr><tr><td>RTX 4090有多少个CUDA核心？</td><td>16384个</td><td>✅/❌</td></tr><tr><td>显卡流水线的第一步是什么？</td><td>顶点处理</td><td>✅/❌</td></tr><tr><td>集成显卡适合玩3A游戏吗？</td><td>不适合</td><td>✅/❌</td></tr></tbody></table>
<h3 data-id="heading-21">🎯 结语：GPU的重要性</h3>
<p>显卡是游戏电脑的"心脏"，它的性能直接决定了游戏的画面质量和流畅度。了解显卡的工作原理，能帮助你更好地选择适合自己的电脑配置！</p>
<p>下次玩游戏时，别忘了感谢你的GPU——它正在默默地为你渲染着绚丽的游戏世界！🎮</p>
<hr/>
<h3 data-id="heading-22">💬 互动话题</h3>
<ol>
<li>你现在用的是什么显卡？玩游戏流畅吗？</li>
<li>你觉得未来的游戏画面会发展到什么程度？</li>
<li>你有没有因为显卡性能不够而遇到过游戏卡顿？</li>
</ol>
<p>快来评论区聊聊你的想法！💬 点赞收藏不迷路，咱们下期继续探索计算机的"十万个为什么"！🎉</p>
<hr/>
<p><strong>关注我</strong>，下期带你解锁更多计算机的"奇葩冷知识"！🤓</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Redis性能翻倍的5个冷门技巧，90%开发者都不知道的深度优化方案]]></title>    <link>https://juejin.cn/post/7584370833704189967</link>    <guid>https://juejin.cn/post/7584370833704189967</guid>    <pubDate>2025-12-17T04:17:03.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584370833704189967" data-draft-id="7584319403862556707" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Redis性能翻倍的5个冷门技巧，90%开发者都不知道的深度优化方案"/> <meta itemprop="keywords" content="后端,前端,人工智能"/> <meta itemprop="datePublished" content="2025-12-17T04:17:03.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿橙的百宝箱"/> <meta itemprop="url" content="https://juejin.cn/user/1638743356481367"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Redis性能翻倍的5个冷门技巧，90%开发者都不知道的深度优化方案
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1638743356481367/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿橙的百宝箱
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T04:17:03.000Z" title="Wed Dec 17 2025 04:17:03 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>Redis性能翻倍的5个冷门技巧，90%开发者都不知道的深度优化方案</strong></h2>
<h2 data-id="heading-1">引言</h2>
<p>Redis作为高性能的内存数据库，被广泛应用于缓存、消息队列、实时统计等场景。尽管大多数开发者对Redis的基础使用和常见优化（如合理设置过期时间、使用Pipeline等）已经非常熟悉，但仍有大量深度的、冷门的优化技巧未被广泛采用。这些技巧往往能在特定场景下带来显著的性能提升，甚至实现性能翻倍。</p>
<p>本文将深入探讨5个鲜为人知的Redis深度优化方案，涵盖内存管理、网络通信、数据结构选择等多个维度，帮助开发者在高并发、低延迟的场景中进一步挖掘Redis的潜力。</p>
<hr/>
<h2 data-id="heading-2">主体</h2>
<h3 data-id="heading-3">1. 巧用Hash Tag实现数据分片均衡</h3>
<p><strong>问题背景</strong>：<br/>
在Redis Cluster模式下，数据通过CRC16算法分片到不同的节点。默认情况下，即使多个key属于同一逻辑组（如<code>user:1000</code>和<code>user:1000:profile</code>），也可能被分配到不同节点，导致跨节点操作（如事务、Lua脚本）无法执行。</p>
<p><strong>冷门技巧</strong>：<br/>
使用<code>Hash Tag</code>（即<code>{}</code>包裹的部分）强制让相关key分配到同一分片。例如：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 以下两个key会被分配到同一分片</span>
SET {user:1000}:name <span class="hljs-string">"Alice"</span>
SET {user:1000}:age 30
</code></pre>
<p><strong>性能收益</strong>：</p>
<ul>
<li>减少跨节点操作带来的网络开销。</li>
<li>支持在Cluster模式下使用事务或Lua脚本操作多个关联key。</li>
</ul>
<p><strong>注意事项</strong>：<br/>
滥用Hash Tag可能导致数据倾斜，需确保tag内的值分布均匀。</p>
<hr/>
<h3 data-id="heading-4">2. 禁用透明大页（THP）以降低内存延迟</h3>
<p><strong>问题背景</strong>：<br/>
Linux的透明大页（Transparent Huge Pages, THP）机制会尝试将小页（4KB）合并为大页（2MB），以减少TLB缺失。然而，Redis的内存分配模式（频繁的小对象分配/释放）与THP的合并策略冲突，可能导致延迟飙升甚至阻塞主线程。</p>
<p><strong>冷门技巧</strong>：<br/>
禁用THP以换取更稳定的性能：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled
</code></pre>
<p>并通过内核参数持久化配置。</p>
<p><strong>性能收益</strong>：</p>
<ul>
<li>降低99%尾延迟（实测从毫秒级降至亚毫秒级）。</li>
<li>避免由THP引发的不可预测的性能抖动。</li>
</ul>
<hr/>
<h3 data-id="heading-5">3. 利用ZSTD压缩算法优化RDB/AOF持久化</h3>
<p><strong>问题背景</strong>：<br/>
Redis默认使用LZF算法压缩RDB文件，但LZF的压缩率和速度在现代场景下已非最优选择。ZSTD作为一种新型压缩算法，在压缩率和速度之间实现了更好的平衡。</p>
<p><strong>冷门技巧</strong>：<br/>
从Redis 6.0开始支持ZSTD压缩，可通过以下配置启用：</p>
<pre><code class="hljs language-bash" lang="bash">rdbcompression <span class="hljs-built_in">yes</span>
rdbcompressionlevel 3 <span class="hljs-comment"># ZSTD级别（1-22）</span>
</code></pre>
<p>实测中，ZSTD级别3的压缩率比LZF高20%，而解压速度接近。</p>
<p><strong>性能收益</strong>：</p>
<ul>
<li>RDB文件体积减小，降低磁盘I/O和网络传输开销。</li>
<li>AOF重写时CPU占用更低。</li>
</ul>
<hr/>
<h3 data-id="heading-6">4. 调整TCP内核参数优化高并发连接</h3>
<p><strong>问题背景</strong>：<br/>
当Redis处理数万并发连接时，默认的Linux TCP栈配置可能成为瓶颈，例如过小的<code>somaxconn</code>会导致连接丢弃，或过短的<code>tcp_timeout</code>引发不必要的重传。</p>
<p><strong>冷门技巧</strong>：<br/>
调整以下内核参数以适应高并发场景：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 增大半连接队列和全连接队列</span>
<span class="hljs-built_in">echo</span> 2048 &gt; /proc/sys/net/core/somaxconn
<span class="hljs-comment"># 减少TIME_WAIT状态的等待时间</span>
<span class="hljs-built_in">echo</span> 30 &gt; /proc/sys/net/ipv4/tcp_fin_timeout
<span class="hljs-comment"># 启用TCP Fast Open</span>
<span class="hljs-built_in">echo</span> 3 &gt; /proc/sys/net/ipv4/tcp_fastopen
</code></pre>
<p><strong>性能收益</strong>：</p>
<ul>
<li>连接建立成功率提升（尤其应对突发流量）。</li>
<li>减少TCP状态维护的开销。</li>
</ul>
<hr/>
<h3 data-id="heading-7">5. Redis内部结构的“秘技”：ziplist与quicklist调优</h3>
<h4 data-id="heading-8">a) Ziplist的临界值调优</h4>
<p>Hash和Sorted Set等结构在元素较少时使用ziplist存储以节省内存，但默认阈值可能偏保守。根据实际数据特征调整：</p>
<pre><code class="hljs language-bash" lang="bash">hash-max-ziplist-entries 512 <span class="hljs-comment"># Hash元素数阈值（默认512）</span>
hash-max-ziplist-value 128   <span class="hljs-comment"># Hash单个value大小阈值（默认64字节）</span>
</code></pre>
<h4 data-id="heading-9">b) Quicklist的分片大小优化</h4>
<p>List类型在Redis中通过quicklist实现（链表+ziplist的组合），调整每个ziplist分片的大小可平衡内存与CPU效率：</p>
<pre><code class="hljs language-bash" lang="bash">list-max-ziplist-size -2 <span class="hljs-comment"># -2表示每个分片不超过8KB</span>
</code></pre>
<p><strong>性能收益案例</strong>:<br/>
一个存储100万条短字符串的List，通过调整分片大小可减少50%的内存碎片。</p>
<hr/>
<h2 data-id="heading-10">总结</h2>
<p>本文揭示的5个冷门技巧——从Hash Tag的分片优化到TCP内核参数的精细化调优——均源自对Redis底层机制和操作系统交互的深度理解。它们并非“银弹”，但在特定场景下可能带来显著提升。建议开发者在应用前充分测试验证，结合监控数据评估效果。真正的性能优化永远是数据驱动的艺术！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[别掉队！系统掌握 LLM 应用开发，这可能是你今年最值得投入的学习方向]]></title>    <link>https://juejin.cn/post/7584426795757355034</link>    <guid>https://juejin.cn/post/7584426795757355034</guid>    <pubDate>2025-12-17T04:18:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584426795757355034" data-draft-id="7584349458857574426" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="别掉队！系统掌握 LLM 应用开发，这可能是你今年最值得投入的学习方向"/> <meta itemprop="keywords" content="LLM,人工智能,Agent"/> <meta itemprop="datePublished" content="2025-12-17T04:18:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="stark张宇"/> <meta itemprop="url" content="https://juejin.cn/user/1983974643871069"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            别掉队！系统掌握 LLM 应用开发，这可能是你今年最值得投入的学习方向
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1983974643871069/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    stark张宇
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T04:18:09.000Z" title="Wed Dec 17 2025 04:18:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🎯 学习目标</h2>
<p>完成本课程后，学习者将能够：</p>
<ul>
<li>
<p>LLM 大语言模型概念以及核心特点</p>
</li>
<li>
<p>LLM 工作流程、价值与市场需求</p>
</li>
<li>
<p>LLM 大数据模型对程序员职业影响</p>
</li>
<li>
<p>LLM 应用开发专有名词、交互模式、结合模式介绍</p>
</li>
</ul>
<h3 data-id="heading-1">LLM 大语言模型</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a49a571da62433b8209592353232170~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgc3RhcmvlvKDlroc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766550061&amp;x-signature=WWwT5rR%2FdzfHtnaeaAFILjwu4cw%3D" alt="ScreenShot_2025-12-17_083302_934.png" loading="lazy"/></p>
<p><strong>LLM（Large Language Model，大语言模型）</strong> 是一种基于深度学习的人工智能模型，核心目标是<strong>理解和生成人类语言</strong>，并能完成翻译、问答、创作、代码编写等多样化的语言相关任务。</p>
<p>它的本质是<strong>通过海量文本数据训练</strong>，学习语言的语法、语义、逻辑甚至常识，从而具备模拟人类语言交互的能力。</p>
<h4 data-id="heading-2">核心特点:</h4>
<p><strong>规模巨大</strong>：参数量大一般指的是7b<del>100b+，即70亿</del>1000亿+参数，参数其实就是一个浮点数(2字节或4字节)，比如3.1415，所以一个7b的模型，本质上就是一坨70亿以上的数字而已。</p>
<p><strong>基于 Transformer 架构</strong>：目前主流 LLM 都基于 <strong>Transformer</strong>（2017 年由谷歌提出）架构，其核心是 <strong>自注意力机制</strong>，可以让模型在处理一句话时，同时关注到每个词与其他词的关联（比如 “它” 指代的是前文的哪个对象），从而更准确地理解上下文。</p>
<p><strong>Token</strong>：</p>
<ul>
<li>Token其实就是文本的片段，是大模型计算长度的单位，对于汉字，可以是字、词、甚至是半个字或者三分之一个字。</li>
<li>对于一个仅支持英语的模型，它的词表可以只有a-z26个字母，加上逗号句号空格等标点符号，Token 数可以非常少。</li>
<li>汉字字词更多，语义更复杂多样，所以包含的Token 数会更多，很多语言模型都支持多语言，包含各种符号、单词、单词片段等，所以往往会有几十万个 Token 甚至更多。</li>
</ul>
<p><strong>大语言模型词表：</strong> 就是这个模型的所有 Token 映射，每个 Token 有其对应的 id，一般从 0开始，如下:</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-string">"vocab"</span>: {
    <span class="hljs-string">"&lt;unk&gt;"</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">//开头是一些特殊符号</span>
    <span class="hljs-string">"&lt;|startoftext|&gt;"</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">//这是字节token，如果出现不在词表中的特殊符号会回退到字节表示</span>
    <span class="hljs-string">"&lt;0x00&gt;"</span>: <span class="hljs-number">305</span>,
    <span class="hljs-string">"&lt;x01&gt;"</span>: <span class="hljs-number">306</span>, <span class="hljs-comment">//下面是正常的英文token，有的表示是单词的开头，没有的是单词中间</span>
    <span class="hljs-string">"ct"</span>: <span class="hljs-number">611</span>,
    <span class="hljs-string">"_re"</span>: <span class="hljs-number">612</span>,
    <span class="hljs-string">"安徽省"</span>: <span class="hljs-number">8560</span>, <span class="hljs-comment">//有中文token出现</span>
    <span class="hljs-string">"子和”: 28561
}
</span></code></pre>
<h4 data-id="heading-3">LLM 工作流程</h4>
<ul>
<li>输入处理：用户输入文本经过分词器转换为模型可理解的token序列。特殊token（如开始、分隔、结束标记）被添加以指导模型处理。</li>
</ul>

<ul>
<li>模型推理：Transformer架构通过自注意力机制和前馈神经网络处理token序列，生成每个位置的下一个token概率分布。</li>
<li>文本生成：基于模型输出的概率分布，使用采样策略（如温度采样、top-p采样）选择下一个token，以自回归方式生成完整响应。</li>
<li>输出后处理：生成的token序列被转换回文本，并进行格式化、清理和安全性检查，确保输出质量与合规性。</li>
<li>最后用户接收响应</li>
</ul>
<pre><code class="hljs language-txt" lang="txt"># 输入处理:
用户输入文本 -&gt; 文本清洗与标准化 -&gt; 分词器 Tokenizer -&gt; 添加特殊标记BOS/SEP/EOS等 -&gt; 转换为Token ID序列

# 模型推理：
Token嵌入层将ID映射为向量 -&gt; 位置编码正弦/学习位置编码 -&gt; Transformer编码器层 -&gt; 自注意力机制 -&gt; 前馈神经网络 -&gt; 残差连接与层归一化 -&gt; 编码器输出
上下文表示

#文本生成 
解码器初始输入起始标记 -&gt; Transformer解码器层 -&gt; Token添加到序列 -&gt; 生成完整Token序列

#输出后处理
Detokenization Token转文本 -&gt; 文本后处理 -&gt; 格式化与清理 -&gt; 安全性检查 -&gt; 最终响应输出
</code></pre>
<h4 data-id="heading-4">大语言模型 预测Token机制</h4>
<ul>
<li>如何快速预测下一个 token 是什么呢?一种最简单的办法就是基于统计，通过大量数据的统计，找到下一个 token。</li>
<li>采集大量文本进行扫描计算，并记录所有片段的输入以及下个文本出现的次数，得到一张巨大的分布表。</li>
<li>将输入的文本对照分布表查询，找到所有 token 的出现次数或概率，找到出现次数最大的 token 即为预测结果。</li>
</ul>
<h4 data-id="heading-5">模型训练</h4>
<p>月训练指的是将大量文本输入给模型，进而得到模型参数前LLM训练一般用到了大量文本，一般在 2T token 以上</p>
<h4 data-id="heading-6">价值与市场需求</h4>
<p>通用人工智能(AGI)将是 AI 的终极形态，几乎已成为业界共识。类比之，构建智能体 Agent 则是 AI 工程应用当下的“终极形态。</p>
<p>大模型出现后，Al Agents衍生出一种新的架构模式，将最重要的规划/决策部分或全部交由LLM完成。</p>
<p><strong>Agent/LLM</strong>：智能体指代具有自主性和智能的程序或系统，能够通过感知规划、决策并执行相关任务。</p>
<p>案例：<strong>基于Agent/LLM的智能客服</strong></p>
<ul>
<li>企业的传统客服存在效率低、培养成本大、工作压力大、提供服务参差不齐等问题，在线客服是企业和客户沟通的桥梁可以为企业带来更多的商机。</li>
</ul>

<ul>
<li>利用 LLM+企业知识库搭建 AI智能客服，对比传统客服可以实现智能沟通、无间断工作、智能分析、自动分类、跨语言沟通等。</li>
</ul>
<p>案例：<strong>基于Agent/LLM的数据分析</strong></p>
<ul>
<li>几乎所有企业每天都会产生大量的数据，除了新数据，还有海量的历史沉淀数据，涉及:日志、历史代码、订单、会员信息、行业数据等。</li>
</ul>

<ul>
<li>这些数据量庞大、结构差异明显、利用率低，导致企业很难精确获知和建立各项数据之间的关联。</li>
<li>利用Agent/LLM参与数据的自动分类、信息提取、数据分析等，建立起各项数据之间的关联。</li>
</ul>
<p>案例：<strong>人工智能即服务-AlaaS</strong></p>
<ul>
<li>Alas a Service(AlaaS，Al 即服务)是一项非常新颖的变革将 AI视为应用后端服务，让公司发布一款产品变得及其简单，无需投入昂贵的硬件、专业人才或耗时的开发流程。</li>
<li>翻译服务=限定的预设 Prompt + LLM 规范化输出</li>
<li>自动化运维 =日志采集 + LLM 推理决策 + 工具包</li>
</ul>
<h4 data-id="heading-7">LLM 职业影响</h4>
<ul>
<li>技术领先:掌握更高效的Prompt编写技巧，让LLM更清楚你的需求，更高效完成工作上的任务、疑难杂症等。</li>
<li>薪资水平:由于LLM是一个相对新兴的领域，人才短缺，具备相关技能的人才往往能够获得更具竞争力的薪酬。</li>
<li>扩充职业前景:随着人工智能的发展和普及，LLM应用的前景非常广阔，不一定所有公司都需要训练LLM，但绝大部分公司都会基于LLM开发应用</li>
</ul>
<h4 data-id="heading-8">LLM在软件开发过程中的单点提效</h4>
<ul>
<li>智能代码提示</li>
<li>SQL语句的智能生成</li>
<li>重复代码检查</li>
<li>跨端代码快速转换</li>
<li>静态代码检查与自动修复</li>
<li>代码注释生成</li>
<li>单元/接口测试代码生成</li>
<li>更精准的技术问答</li>
<li>代码评审与代码重构</li>
<li>失败用例自动分析与归因</li>
</ul>
<h4 data-id="heading-9">AI时代的自动化编程5个等级</h4>
<ul>
<li>C1:基于当前代码自动补全。</li>
<li>C2:编写代码时AI可以预测下一行代码。</li>
<li>C3:基于自然语言生成代码与编程语言的翻译</li>
<li>C4:高度自动化编程包括自然语言生成代码及注释、自动化测试、编程语言互译、代码补全与生成、调试及检查,</li>
<li>C5:完全自动编程，AI可以看成是一个任意的软件，甚至无需代码，基于AI本身即可提供对应的服务。</li>
</ul>
<p>对程序员有什么影响</p>
<p><strong>1、短期影响</strong></p>
<ul>
<li>AI可以帮助程序员完成代码的自动化测试、代码审查等重复容易出错的工作，但是自动化测试、代码审查只是程序员的一小部分工作。</li>
<li>在创造性问题上，例如在项目的需求分析、设计和策划过程中，需要程序员进行创造性思考和判断，AI技术还没有完全达到这一点。</li>
<li>对于目前的AI进展来说，并不会导致程序员的完全失业，而是在一定程度上提高了程序员工作的效率和准确性。</li>
</ul>
<p><strong>2、长期影响</strong></p>
<ul>
<li>不久的将来AI有望取代一些低水平(比如仅会CURD)的程序员，但是以目前的进展来说，还有一段路需要走。</li>
<li>长远的未来，人人都具备编程能力，但是程序员不太应该被单独拿出来讨论，实际上对大模型来说，编程仍然是最具挑战的任务之一。</li>
</ul>
<h4 data-id="heading-10">LLM 应用开发专有名词</h4>
<p><strong>LLM 大语言模型</strong></p>
<ul>
<li>LLM是基于深度学习技术构建的人工智能模型，由具有数以亿计参数的人工神经网络组成，通过自监督学习或半监督学习在大量无标签文本上上进行训练。</li>
<li>LLM于2018年左右出现，并在各种任务上表现出色，LLM改变了自然语言处理研究的重点，使其不再是以训练特定任务的专门监督模型为范式。</li>
</ul>
<p><strong>AIGC AI生成内容</strong></p>
<ul>
<li>AIGC(Al-Generated Content)通过对已有数据进行学习和模式识别，以适当的泛化能力生成相关内容的技术。</li>
<li>AIGC生成的内容很多，涵盖文字、图像、视频、音频、游戏、虚拟人等等。</li>
<li>AIGC是AI大模型，而ChatGPT则是AIGC在聊天对话场景的-个具体应用。</li>
</ul>
<p><strong>AGI 人工通用智能</strong></p>
<ul>
<li>AGl (Artificial General Intelligence)全称人工通用智能是指能够理解、学习和应用广泛的知识和技能的人工智能系统。</li>
<li>以人类角度来看，AGI就是一种能够“思考”和“理解”各种问题的智能生命体，就像人类一样。</li>
</ul>
<p><strong>Agent 智能代理</strong></p>
<ul>
<li>Agent (智能代理)一个能够自主感知环境并采取行动的计Agent算实体，其目标是最大化某种预定义的效用或实现特定的目标。</li>
</ul>

<ul>
<li>AGI可以看成是一种非常高级的Agent，具备广泛适应性和自我学习能力，Agent也是现阶段AGI的最佳实现方式。</li>
</ul>
<p><strong>Prompt-提示词</strong></p>
<ul>
<li>Prompt是指给定的一段文本或问题用于引导和启发人工智能模型生成相关的回答或内容。</li>
<li>Prompt是目前人类与LLM大语言模型交互的核心方式。</li>
</ul>
<p><strong>GPT 生成型预训练变换模型</strong></p>
<ul>
<li>GPT(Generative Pre-trained Transformer)是一种基于深度学习的大型语言模型。</li>
<li>GPT模型最初由OpenAI开发，旨在通过训练模型预测下一个单词或字符来学习自然语言的统计规律。</li>
</ul>
<p><strong>Token 文本基础单元</strong></p>
<ul>
<li>Token是指在自然语言处理和文本处理任务中，将文本分解成较小单元的基本单位。这些单元可以是单词、字符、子词或其他语言单位，具体取决于任务和处理方式。</li>
<li>大语言模型中的上下文长度计算一般都是基于Token，而不是字符，例如GPT-4的16K上下文意味着传递的消息不能超过16K个Token。</li>
</ul>
<p><strong>LoRA 插件式微调</strong></p>
<ul>
<li>LoRA(Low-Rank Adaptation of LLM)即插件式微调用于对大语言模型进行个性化的特定任务的定制。</li>
<li>LoRA通过将模型的权重矩阵分解成低秩的相似矩阵，降低了参数空间的复杂性，从而减少微调的计算成本和模型存储要求。</li>
</ul>
<p><strong>矢量/向量数据库</strong></p>
<ul>
<li>矢量数据库是一种用于存储矢量/向量数据的数据库。</li>
<li>矢量数据库可以存储和管理大量的矢量数据例如图像、视频、音频、文本等，同时提供高效检索功能。</li>
</ul>
<p><strong>数据蒸馏</strong></p>
<ul>
<li>数据蒸馏指将给定的原始大数据集浓缩并生成一个小型数据使得在小数据集上训练出来的模型与原数据集上训练的模型相似。</li>
<li>数据蒸馏在深度学习领域被广泛应用，可以帮助将复杂的模型转换成更轻量级的模型，提高模型的鲁棒性和泛化能力。</li>
</ul>
<h4 data-id="heading-11">LLM &amp; AI Agent交互模式</h4>
<p>传统人机交互范式的缺点：</p>
<ul>
<li>交互接口复杂繁杂且多样化，要使用多一款软件，要专门花时间去学习，每个软件之间接口差异巨大。</li>
<li>人在环境中进行一些行为，会产生各类的数据，涵盖结构化和非结构化数据，而人不能和数据直接发生关系，需要一个中介，这个中介就是软件。</li>
<li>处理不同的数据需要不同的软件，而有些软件非专业人士很难上手，比如说PhotoShop。</li>
</ul>
<p>大模型时代新交互的缺点：</p>
<ul>
<li>过去通过某个应用软件与某种数据进行交互，现在变成人和大模型交互，即大语言模型站到了人机交互的中心位置。</li>
<li>本质上还是人和数据的关系，只是由于大模型的出现，应用软件被屏蔽到了幕后。</li>
<li>短期来看，LLM可以代替一些应用软件，比如多模态大模型对PhotoShop的取代;长期来看，大模型可能会逐步替代各种功能的软件。</li>
</ul>
<h4 data-id="heading-12">LLM 结合模式</h4>
<ul>
<li>嵌入(Embedding)模式:用户通过与AI交流，AI协助完成，如创作小说、音乐、3D内容等，此模式下，AI是执行工具，人类是决策者和指挥者。</li>
<li>副驾驶(Copilot)模式:在这种模式下，人类与AI作为合副驾驶作伙伴，共同完成任务，AI提供建议并协助任务，二者互补AI更像知识丰富的伙伴而非工具。</li>
<li>智能体(Agent)模式:人类设定目标并提供资源，AI独立完成大部分工作，最后人类监督和评估结果。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[AI智能体浪潮下的前端演进：一场螺旋上升的轮回]]></title>    <link>https://juejin.cn/post/7584353612501860393</link>    <guid>https://juejin.cn/post/7584353612501860393</guid>    <pubDate>2025-12-17T03:15:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584353612501860393" data-draft-id="7584356212801470505" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="AI智能体浪潮下的前端演进：一场螺旋上升的轮回"/> <meta itemprop="keywords" content="前端,Agent"/> <meta itemprop="datePublished" content="2025-12-17T03:15:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="houyhea"/> <meta itemprop="url" content="https://juejin.cn/user/3175045310189998"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            AI智能体浪潮下的前端演进：一场螺旋上升的轮回
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3175045310189998/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    houyhea
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:15:13.000Z" title="Wed Dec 17 2025 03:15:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在技术迭代的长河中，前端从未是一个静态的概念。它的每一次蜕变，都镌刻着人机交互理念的革新与产业分工的深化。当我们站在AI agent（智能体）迅猛发展的今天回望，会发现这条演进之路竟如一条螺旋上升的曲线，在看似轮回的形态中完成着一次次升华。</p>
<p>追溯前端的源头，其实并无“前端”之名。那是命令行统治的时代，DOS系统的黑底白字构成了人机交互的全部场景。没有图形，没有界面，更没有所谓的“用户体验”，交互模式简单粗暴的“一问一答”——用户敲入一行指令，系统返回一串字符，指令正确则执行操作，错误则抛出冰冷的提示。此时的“开发”无需分工，开发者既是指令的编写者，也是交互逻辑的设计者，人机之间的“翻译官”角色尚未分化，前端的萌芽还沉睡在命令行的字符洪流中。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3554d5b0e73f41518e5e250389b0ad08~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaG91eWhlYQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546113&amp;x-signature=IV9MyQNqU27xpFXJxs5H5ketrKc%3D" alt="" loading="lazy"/></p>
<p>图形操作系统的诞生与浏览器的出现，为前端的觉醒撕开了一道裂口。窗口、按钮、菜单等可视化元素取代了单调的字符，用户终于可以通过点击、拖拽完成操作，人机交互进入了可视化时代。但彼时的互联网产业尚在襁褓之中，技术分工远未精细化，“前端”与“后端”的界限模糊得如同宣纸晕染。开发任务以业务模块为单位垂直划分：张三负责用户模块的全流程开发，从页面的可视化布局到后端的逻辑处理，再到数据库的读写操作，一手包办；李四则专注商品模块，同样包揽从界面到数据的所有环节。此时的界面开发更像是“附属品”，开发者的核心精力仍聚焦于业务逻辑，前端的价值尚未被独立认知。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/23ad376035164f61ae49e0ed5f0bf2b2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaG91eWhlYQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546113&amp;x-signature=AJUf1tFt5Nln8xHFB%2Bi2Yds7%2B3s%3D" alt="" loading="lazy"/></p>
<p>互联网的爆发式增长，终于推动前端从后端的羽翼下独立而出，开启了属于自己的进化之路。产业对用户体验的要求日益提高，精细化分工成为必然趋势——后端专注于数据处理与接口提供，前端则聚焦于界面呈现与交互优化。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d0e887ca98e742b6a9820f123f90b21a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaG91eWhlYQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546113&amp;x-signature=llAL7J1cPEQdlnmr3ge19B67NbM%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d826b500e16e4f2a8e72e858cd84e6b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaG91eWhlYQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546113&amp;x-signature=XppGmdNko1CoVFGchaoRgJ%2BB50g%3D" alt="" loading="lazy"/></p>
<p>早期的前端开发者更像“页面裁缝”，拿着设计稿用HTML搭建结构，用DIV+CSS重构布局，将静态的设计图转化为可浏览的网页；随着JavaScript的能力增强与Vue、React等框架的兴起，前端逐渐掌握了视图层的逻辑控制权，从“套页面”升级为“构建交互系统”，前后端分离的架构模式彻底确立，前端成为独立且关键的技术领域。</p>
<p>然而，就在前端开发者们在组件化、工程化的道路上不断深耕时，AI agent的浪潮悄然袭来，为前端的演进按下了“加速键”，也带来了颠覆性的变革。当用户不再需要面对复杂的界面，只需用自然语言说出需求——“帮我生成一份近一周的订单报表”“给新用户发送欢迎短信并同步更新会员信息”，AI agent便能精准理解意图，直接调用后端接口完成数据处理。曾经由前端界面承载的交互入口，正被对话式交互逐渐取代，前端的“半壁江山”似乎正在被AI侵蚀。</p>
<p>但技术的演进从未是简单的“取代”，而是更高维度的“重塑”。AI agent确实会简化甚至取代部分前端开发工作，岗位数量可能随之减少，但前端并未走到“终点”——展示层成为前端最后的、也是最核心的阵营。当AI完成逻辑处理与接口调用后，如何将数据以更直观、更美观、更贴合场景的方式呈现给用户，仍需前端开发者的深耕细作：开发适配不同场景的展示卡片，在有限空间内优化信息层级；设计卡片内的精细化交互，实现滑动、点击、悬浮等多维度操作；确保不同设备、不同分辨率下的展示一致性，兼顾美观与性能。此时的前端，不再是“界面的搭建者”，而是“体验的优化师”，聚焦于人机交互的最后一公里。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8159337959ef4e738d400e96bdb3178d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgaG91eWhlYQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546113&amp;x-signature=Fr%2B%2F2erBHLuq2XNwLEMuubuIQvg%3D" alt="" loading="lazy"/></p>
<p>回望前端的演进历程，从命令行的“一问一答”，到图形界面的“前后端共生”，再到前后端分离的“交互深耕”，直至AI时代的“对话式交互+展示优化”，看似完成了一次交互形态的轮回，实则每一步都在技术的推动下实现了质的飞跃。命令行的交互是“被动响应”，AI时代的对话是“主动理解”；早期的界面是“功能载体”，如今的展示是“体验核心”。这条螺旋上升的曲线，藏着技术发展的底层逻辑：分工从粗放走向精细，交互从被动走向主动，体验从基础走向极致。</p>
<p>AI对前端的冲击，不是终结，而是新的开始。前端的边界或许会收缩，但价值会更加聚焦；岗位数量或许会减少，但从业者的能力要求会更高。当我们站在新的技术节点上，不必为“被革命”而焦虑，因为技术的轮回从来都是为了更高维度的升华——前端的故事，仍在继续。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[谷歌 Agents 白皮书中文版全网首发，堪称 AI 教材的天花板级神作]]></title>    <link>https://juejin.cn/post/7584297353420931072</link>    <guid>https://juejin.cn/post/7584297353420931072</guid>    <pubDate>2025-12-17T03:21:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584297353420931072" data-draft-id="7583991680749191195" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="谷歌 Agents 白皮书中文版全网首发，堪称 AI 教材的天花板级神作"/> <meta itemprop="keywords" content="Agent,LLM,程序员"/> <meta itemprop="datePublished" content="2025-12-17T03:21:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AI大模型"/> <meta itemprop="url" content="https://juejin.cn/user/3817967696221534"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            谷歌 Agents 白皮书中文版全网首发，堪称 AI 教材的天花板级神作
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3817967696221534/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AI大模型
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:21:37.000Z" title="Wed Dec 17 2025 03:21:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文较长，建议点赞收藏。更多AI大模型应用开发学习视频及资料，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2FEnjoyEDU%2FLLM" target="_blank" title="https://gitcode.com/EnjoyEDU/LLM" ref="nofollow noopener noreferrer">这里</a>。</p>
</blockquote>
<p>随着AI Agent市场的越发火爆，为了让用户全面了解AI Agent并积极参与生态构建，一些公司相继推出了官方智能体相关的解读及白皮书。</p>
<p>继Anthropic之后，就在这几天，谷歌发也发布了自己的AI Agent白皮书。详细解析了生成式人工智能Agents的核心机制、组成结构以及实际应用潜力，还有如何快速实现LangChain的方法。这不仅是IT人的福音，也是对未来AI发展的重要解读！</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c2ff96c17cee405299b596582a6ea907~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlpKfmqKHlnos=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546497&amp;x-signature=SZ2hRrHtZYUgsOaNRVwnBk03RH8%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">白皮书详细介绍了Agent的三个核心组成部分：</h2>
<p>模型（Language Model）、工具（Extensions, Functions, Data Stores）和编排层（Orchestration Layer）。</p>
<p>ReAct序列：这是Agents的核心工作机制！它包含四个步骤：用户发送查询、Agent开始ReAct序列、模型生成下一个动作、最终答案返回给用户。每一步都紧密相连，确保Agent能够准确理解并执行你的指令！  </p>
<p>工具类型：Google的Agents能够与三种主要工具类型互动：Extensions、Functions和Data Stores。它们分别扮演着不同的角色，比如Extensions像桥梁一样连接API和Agent，Functions在客户端执行特定任务，而Data Stores则提供动态、实时的数据支持！</p>
<p>应用场景：想象一下，你的Agent能够根据你的指令调整智能家居设置、更新日历、甚至基于特定指令发送邮件！这些应用场景让我们的生活变得更加便捷和智能！</p>
<h2 data-id="heading-1">主要内容： </h2>
<p>一：从预测式AI到自主智能体 </p>
<p>二：AI智能体简介智能体式问题解决流程 </p>
<p>三：智能体系统分类法</p>
<p>级别 0：核心推理系统 </p>
<p>级别 1：互联的问题解决者 </p>
<p>级别 2：策略型问题解决者 </p>
<p>级别 3：协作式多智能体系统 </p>
<p>级别 4：自进化系统</p>
<h2 data-id="heading-2">书籍目录如下：</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8983d610248d4e408abcdc8bd2264ffe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlpKfmqKHlnos=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546497&amp;x-signature=WeW3USWHOqC6%2BvN%2FoRcwJ8wAPjY%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9897790ffd2144deb1ed410d44cada35~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlpKfmqKHlnos=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546497&amp;x-signature=DtjO2NzphR4AU7nLoWjWekFg90Q%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cedf1898851641728ba6ba59d6d57cb2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlpKfmqKHlnos=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546497&amp;x-signature=Sa827k9l0xYZakNa%2B40uHAjoDFQ%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a4f975ca609458bbfab999a27e43bfb~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlpKfmqKHlnos=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546497&amp;x-signature=T5mO8sDIaBIYCoXfUio8uLKkq04%3D" alt="" loading="lazy"/></p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d46c42df773e4797b66be6a14c8b2f0b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQUnlpKfmqKHlnos=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546497&amp;x-signature=qVJeBiO6C74Uw%2FC4re6bUd1I%2Bgs%3D" alt="" loading="lazy"/></p>
<p>白皮书旨在系统性地讲解生成式AIAgent的原理、架构和应用实践，为开发者提供构建更强大、更灵活的AI系统的指导。不论你是企业高管、开发者还是对人工智能感兴趣的小白，都非常适合。</p>
<blockquote>
<p>本文较长，建议点赞收藏。更多AI大模型应用开发学习视频及资料，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2FEnjoyEDU%2FLLM" target="_blank" title="https://gitcode.com/EnjoyEDU/LLM" ref="nofollow noopener noreferrer">这里</a>。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Kotlin 2.3.0 现已发布！又有什么好东西？]]></title>    <link>https://juejin.cn/post/7584343534968111146</link>    <guid>https://juejin.cn/post/7584343534968111146</guid>    <pubDate>2025-12-17T03:13:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584343534968111146" data-draft-id="7584353612501663785" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Kotlin 2.3.0 现已发布！又有什么好东西？"/> <meta itemprop="keywords" content="后端,架构,开源"/> <meta itemprop="datePublished" content="2025-12-17T03:13:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="法欧特斯卡雷特_Official"/> <meta itemprop="url" content="https://juejin.cn/user/730521284903390"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Kotlin 2.3.0 现已发布！又有什么好东西？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/730521284903390/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    法欧特斯卡雷特_Official
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:13:41.000Z" title="Wed Dec 17 2025 03:13:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读14分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>大家吼哇，这次轮到 Kotlin 2.3.0 登场啦！
本次更新内容可以在 JetBrains 官方的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fkotlinlang.org%2Fdocs%2Fwhatsnew-230.html" target="_blank" title="https://kotlinlang.org/docs/whatsnew-230.html" ref="nofollow noopener noreferrer">What's new in Kotlin 2.3.0</a> 查阅，
我照例挑自己最感兴趣的改动聊聊。</p>
<p>一句话总结：<strong>Java 25 终于支持，特性体验逐渐舒适。实用功能层出不穷，小伙伴们赶快更新～</strong></p>
<blockquote>
<p>注意！这次依旧是「我个人 pick」的更新摘要，覆盖不了全部改动；对其他领域感兴趣、但是我没提到的伙伴可以继续深入官方文档喔。</p>
<p>文中示例如无特殊说明均来自或改写自官方日志。</p>
</blockquote>
<h2 data-id="heading-0">语言特性</h2>
<p>一如既往先看语言层面，首先映入眼帘的是对一部分实验特性的转正，然后是一批新晋实验特性，最后是对 Java 25 的支持。</p>
<blockquote>
<p>一如既往的方阵阵营。</p>
</blockquote>
<h3 data-id="heading-1">嵌套类型别名 &amp; <code>when</code> 数据流穷举转正稳定</h3>
<p>之前在 2.2.x 里加入的「嵌套 typealias 支持」(Support for nested type aliases)
和「基于数据流的 <code>when</code> 穷举检查」(Data-flow-based exhaustiveness checks for <code>when</code> expressions) 转正咯。
现在写多层 typealias 不会再有警告，
<code>when</code> 也会结合 smart cast 和 <code>sealed</code> 的上下文做更聪明的穷举判断了。</p>
<h3 data-id="heading-2">默认启用 <code>suspend</code> 解析 &amp; 函数表达式里 <code>return</code></h3>
<blockquote>
<p>注意：这个更新是在 <code>2.3.0</code> 的某个 EAP 版本中描述的，但是在 2.3.0 正式版更新中没有描述，因此它可能被移除了。</p>
</blockquote>
<p>Kotlin 2.3.0 默认启用了两项之前需要 <code>-language-version 2.3</code> 的特性：</p>
<ul>
<li>传 <code>lambda</code> 给既有 <code>suspend</code> 又有非 <code>suspend</code> 重载时，不再需要手动强转，直接写 <code>suspend { }</code> 就行。</li>
<li>函数表达式里允许 <code>return</code>，只需显式标注返回类型。之前写 <code>fun foo() = return 42</code> 会报错，现在没事啦。</li>
</ul>
<h3 data-id="heading-3">默认启用 body 中的 return 表达式特性</h3>
<p>Kotlin 2.3.0 默认启用了之前 2.2.20 中更新的一个需要 <code>-language-version 2.3</code> 的特性：</p>
<p>在 body 表达式的局部使用 <code>return</code>。比如说：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getDisplayNameOrDefault</span><span class="hljs-params">(userId: <span class="hljs-type">String</span>?)</span></span>: String = getDisplayName(userId ?: <span class="hljs-keyword">return</span> <span class="hljs-string">"default"</span>)
</code></pre>
<h3 data-id="heading-4">未使用返回值检查器</h3>
<p>新增了一个 <code>-Xreturn-value-checker</code> ，可以提示你「调用了有意义的返回值却没用」。
可以用来提前发现那种「写了一大串表达式结果却丢了」的 bug。</p>
<p>例如：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">formatGreeting</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>: String {
    <span class="hljs-keyword">if</span> (name.isBlank()) <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, anonymous user!"</span>
    <span class="hljs-keyword">if</span> (!name.contains(<span class="hljs-string">' '</span>)) {
        <span class="hljs-comment">// 检查器会警告这个结果被忽略了</span>
        <span class="hljs-string">"Hello, "</span> + name.replaceFirstChar(<span class="hljs-built_in">Char</span>::titlecase) + <span class="hljs-string">"!"</span>
    }
    <span class="hljs-keyword">val</span> (first, last) = name.split(<span class="hljs-string">' '</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, <span class="hljs-variable">$first</span>! Or should I call you Dr. <span class="hljs-variable">$last</span>?"</span>
}
</code></pre>
<p>上面这段里，<code>if</code> 分支中构造了一段字符串却没有返回或赋值，检查器就会给出「结果被忽略」的警告。</p>
<p>默认情况下，这个检查器只对被标记了 <code>@MustUseReturnValues</code> 的作用域生效。
想要以 <code>check</code> 模式启用的话，可以在 <code>build.gradle.kts</code> 中这样写：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">kotlin {
    compilerOptions {
        freeCompilerArgs.add(<span class="hljs-string">"-Xreturn-value-checker=check"</span>)
    }
}
</code></pre>
<p>然后通过注解来声明「这里的返回值必须被使用」。可以标记整个文件：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 标记整个文件：文件里的函数/类返回值若被忽略则会被检查器提示</span>
<span class="hljs-meta">@file:MustUseReturnValues</span>

<span class="hljs-keyword">package</span> my.project

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span></span>: String
</code></pre>
<p>也可以只标记某个类：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 标记整个类：类中所有函数的返回值如果被忽略都会被检查器提示</span>
<span class="hljs-meta">@MustUseReturnValues</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> {
    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">greet</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>: String = <span class="hljs-string">"Hello, <span class="hljs-variable">$name</span>"</span>
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">someFunction</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = ...
</code></pre>
<p>如果你希望对整个项目的所有返回值都进行检查，可以开启 <code>full</code> 模式：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">kotlin {
    compilerOptions {
        freeCompilerArgs.add(<span class="hljs-string">"-Xreturn-value-checker=full"</span>)
    }
}
</code></pre>
<p>在这个模式下，相当于所有编译结果都隐式带上了 <code>@MustUseReturnValues</code> 标记。</p>
<p>有些函数的返回值被忽略是很正常的，比如 <code>MutableList.add</code>，这类就可以用 <code>@IgnorableReturnValue</code> 标记掉：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@IgnorableReturnValue</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> MutableList<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">addAndIgnoreResult</span><span class="hljs-params">(element: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
    <span class="hljs-keyword">return</span> add(element)
}
</code></pre>
<p>如果只是某一处调用想压制警告，又不想在函数签名上动刀，可以把结果赋值给下划线变量：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 这是一个「不允许忽略返回值」的函数</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">computeValue</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-number">42</span>

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {

    <span class="hljs-comment">// 这里会有警告：返回值被忽略</span>
    computeValue()

    <span class="hljs-comment">// 这里不会有警告：显式把返回值丢给一个特殊的 unnamed 变量</span>
    <span class="hljs-keyword">val</span> _ = computeValue()
}
</code></pre>
<p>对于我这种偶尔写 DSL 忘记 return 的人来说，简直就是妥妥的保命符一张呀。</p>
<h3 data-id="heading-5">显式后备字段</h3>
<p>还记不记得之前的版本想要写一个有「后备字段」的属性要怎么写？</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _city = MutableStateFlow&lt;String&gt;(<span class="hljs-string">""</span>)
<span class="hljs-keyword">val</span> city: StateFlow&lt;String&gt; <span class="hljs-keyword">get</span>() = _city

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateCity</span><span class="hljs-params">(newCity: <span class="hljs-type">String</span>)</span></span> {
    _city.value = newCity
}
</code></pre>
<p>而现在，可以不用这么麻烦了！</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-keyword">val</span> city: StateFlow&lt;String&gt;
    field = MutableStateFlow(<span class="hljs-string">""</span>)

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">updateCity</span><span class="hljs-params">(newCity: <span class="hljs-type">String</span>)</span></span> {
    <span class="hljs-comment">// Smart casting works automatically</span>
    city.value = newCity
}
</code></pre>
<p>使用 <code>field = ...</code> 的方式可以直接指定一个真正的后备字段，方便实用！
这个特性是试验性的，要开启它，添加编译器参数 <code>-Xexplicit-backing-fields</code> ：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin">kotlin {
    compilerOptions {
        freeCompilerArgs.add(<span class="hljs-string">"-Xexplicit-backing-fields"</span>)
    }
}
</code></pre>
<h3 data-id="heading-6">上下文敏感解析继续打磨</h3>
<p>目前还在 Experimental，这次限制了「只把密封类和当前类型的外部父类」加入上下文，从而减少盲目扩散。
如果你在类型运算里引进了容易撞名的类，编译器会给出新 warning，提示这段解析已经因为上下文分支而不再确定。</p>
<h2 data-id="heading-7">Kotlin/JVM：面向 Java 25</h2>
<p>编译器现在可以输出 Java 25 的字节码了。对想第一时间尝鲜新 JDK API 的同学只需把 target 设到 25 就好，
Gradle/IDE 也都打通了。</p>
<blockquote>
<p>好耶！支持输出 Java 25 咯～</p>
</blockquote>
<h2 data-id="heading-8">Kotlin/Native</h2>
<p>一些 Kotlin/Native 的更新喔～ 我对 K/N 并不是非常熟悉，如果这部分有你非常感兴趣的内容，不妨也去看看官方的详细内容，
以防有什么遗漏～</p>
<h3 data-id="heading-9">Swift Export 更自然</h3>
<p>虽然不太懂移动端开发，不过 Swift export 这轮带来了一些看似（？）很不错的点：</p>
<ol>
<li>原生 <code>enum class</code> 终于会被映射成 Swift 的 <code>enum</code>，不用再接受那些 class 模板。</li>
<li>Kotlin 的 <code>vararg</code> 直接翻译成 Swift 的 <code>...</code> 变参，用 Swift 写调用端的时候自然顺滑。</li>
</ol>
<p>比如官方文档里给出了这样一组 Kotlin / Swift 映射：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kotlin 端</span>
<span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span>(<span class="hljs-keyword">val</span> rgb: <span class="hljs-built_in">Int</span>) {
    RED(<span class="hljs-number">0xFF0000</span>),
    GREEN(<span class="hljs-number">0x00FF00</span>),
    BLUE(<span class="hljs-number">0x0000FF</span>)
}

<span class="hljs-keyword">val</span> color = Color.RED
</code></pre>
<pre><code class="hljs language-Swift" lang="Swift"><span class="hljs-comment">// Swift 端</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>: <span class="hljs-title class_">Swift</span>.<span class="hljs-title class_">CaseIterable</span>, <span class="hljs-title class_">Swift</span>.<span class="hljs-title class_">LosslessStringConvertible</span>, <span class="hljs-title class_">Swift</span>.<span class="hljs-title class_">RawRepresentable</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">RED</span>, <span class="hljs-type">GREEN</span>, <span class="hljs-type">BLUE</span>

    <span class="hljs-keyword">var</span> rgb: <span class="hljs-type">Int</span> { <span class="hljs-keyword">get</span> }
}
</code></pre>
<p><code>vararg</code> 也会被翻译成 Swift 里的变长参数：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// Kotlin 端</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> messages: <span class="hljs-type">String</span>)</span></span>
</code></pre>
<pre><code class="hljs language-Swift" lang="Swift"><span class="hljs-comment">// Swift 端</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">messages</span>: <span class="hljs-type">Swift</span>.<span class="hljs-type">String</span>...)
</code></pre>
<blockquote>
<p>要注意的是泛型 <code>vararg</code> 还没支持，但至少常见日志函数、多参数工具函数都没什么影响。</p>
</blockquote>
<h3 data-id="heading-10">C 和 Objective-C 库导入进入 Beta</h3>
<p>虽说我对 Kotlin/Native 不是非常熟悉，但是我知道 K/N 将 iOS 的开发放在首位，也一直在跟 Swift/Objective-C 进行搏斗、
改进它们之间的互调用与兼容性体验。
而这次，对 Swift/Objective-C 和 C 的库导入功能进入了 Beta 阶段，也算是一个阶段性突破了～</p>
<p>不过当然，这部分功能仍然处于<strong>实验性</strong>阶段，仍然存在一些限制、以及需要标记 <code>@ExperimentalForeignApi</code>。
但终归是一次进步，不是吗？</p>
<h3 data-id="heading-11">Objective-C 头文件中块类型的默认显式参数名</h3>
<p>Kotlin 函数类型中的显式参数名现在是 Objective-C 头文件导出的默认设置，改进了 Xcode 中的自动完成体验。
嗯... 也是对 Objective-C 的互调用与兼容性体验的一个内容。</p>
<h3 data-id="heading-12">Native 发布任务构建速度提升</h3>
<p>这个则是对 K/N 整体的开发体验的提升。
官方提到：</p>
<blockquote>
<p>根据基准测试，发布构建可以快高达 <strong>40%</strong>，具体取决于项目大小。这些改进在针对 iOS 的 Kotlin Multiplatform 项目中最为明显。</p>
</blockquote>
<h3 data-id="heading-13">Apple 目标支持的变更</h3>
<ul>
<li>iOS/tvOS 最低版本从 <strong>12.0 提升到 14.0</strong></li>
<li>watchOS 最低版本从 <strong>5.0 提升到 7.0</strong></li>
<li><code>macosX64</code>、<code>iosX64</code>、<code>tvosX64</code>、<code>watchosX64</code> 被<strong>降级到支持层级 3</strong></li>
<li>计划在 Kotlin 2.4.0 中移除 x86_64 Apple 目标支持</li>
</ul>
<p>时代在变迁、社会在进步。不过看到这些 <code>X64</code> 的平台被移到 Tier 3 还是不禁感叹：
<strong>TMD 我什么时候才能有钱把我这个英特尔芯片的 Mac 给换了！</strong></p>
<h2 data-id="heading-14">Kotlin/Wasm</h2>
<p>Kotlin 2.3.0 默认为 Kotlin/Wasm 目标启用完全限定名，为 <code>wasmWasi</code> 目标启用新的异常处理提案，
并引入 Latin-1 字符的紧凑存储。</p>
<h3 data-id="heading-15">名字/异常更靠谱</h3>
<ul>
<li><code>KClass.qualifiedName</code> 在 Wasm 目标上默认可用了，之前得手动开 <code>flag</code> ，而现在免配置了，也不会增大二进制。</li>
<li><code>wasmWasi</code> 目标改用新版异常处理提案，和市面上主流 VM 的实现保持一致；<code>wasmJs</code> 还停留在 legacy 版本，
有需要可以自己加 <code>-Xwasm-use-new-exception-proposal</code>。</li>
</ul>
<h3 data-id="heading-16">Latin-1 字符的紧凑存储</h3>
<p>以前，Kotlin/Wasm 按原样存储字符串字面量数据，这意味着每个字符都以 UTF-16 编码。
这对于仅包含或主要包含 Latin-1 字符的文本不是最优解。</p>
<p>从 Kotlin 2.3.0 开始，Kotlin/Wasm 编译器可以以 UTF-8 格式存储仅包含 Latin-1 字符的字符串字面量了。</p>
<p>这种优化显著减少了元数据，官方数据表示这个优化：</p>
<ul>
<li>Wasm 二进制文件最多缩小 <strong>13%</strong>（与未优化版本相比）</li>
<li>即使启用完全限定名，仍可缩小 <strong>8%</strong></li>
</ul>
<blockquote>
<p>此功能默认启用，更新版本即可享受～</p>
</blockquote>
<hr/>
<blockquote>
<p>有一说一，K/Wasm 还有很多可以打磨的地方。继续加油！</p>
</blockquote>
<h2 data-id="heading-17">Kotlin/JS：更少样板的互操作</h2>
<p>更少样板的互操作优化！</p>
<h3 data-id="heading-18">直接导出 <code>suspend</code></h3>
<p><code>@JsExport</code> 终于不再排斥 <code>suspend</code> 了，只需额外添加一个编译器参数：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">kotlin {
    compilerOptions {
        freeCompilerArgs.add(<span class="hljs-string">"-Xenable-suspend-function-exporting"</span>)
    }
}
</code></pre>
<p>之后 Kotlin 的 <code>suspend</code> 会在 JS/TS 侧自动表现成 <code>async</code>/<code>Promise</code>，子类覆盖也照样写 <code>async</code>。</p>
<blockquote>
<p>我去，史诗级更新！但是似乎反而让我的编译器插件
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FForteScarlet%2Fkotlin-suspend-transform-compiler-plugin" target="_blank" title="https://github.com/ForteScarlet/kotlin-suspend-transform-compiler-plugin" ref="nofollow noopener noreferrer">kotlin-suspend-transform-compiler-plugin</a>
的作用变小了... 欸？</p>
</blockquote>
<p>启用之后，被 <code>@JsExport</code> 标记的 Kotlin <code>suspend</code> 函数就可以直接被 JS/TS 端当作 <code>async</code> 函数来用，例如：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@JsExport</span>
<span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> {
    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"Foo"</span>
}
</code></pre>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Foo</span> {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">foo</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Bar"</span>
    }
}
</code></pre>
<h3 data-id="heading-19"><code>LongArray</code> 映射到 <code>BigInt64Array</code></h3>
<p>给 JS Runtime 的 <code>LongArray</code> 现在会变成原生的 <code>BigInt64Array</code>，和需要 typed array 的 Web API 完全对接，
也能更轻松地把 Kotlin 模块暴露给外部。</p>
<p>使用编译器参数 <code>-Xes-long-as-bigint</code> 启用它：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">kotlin {
    js {
        <span class="hljs-comment">// ...</span>
        compilerOptions {
            freeCompilerArgs.add(<span class="hljs-string">"-Xes-long-as-bigint"</span>)
        }
    }
}
</code></pre>
<blockquote>
<p>在那之前，Kotlin 会将其映射为 <code>Array&lt;bigint&gt;</code> 。</p>
</blockquote>
<h3 data-id="heading-20">跨 JS 模块系统的统一伴生对象访问</h3>
<p>以前，当使用 <code>@JsExport</code> 将带有伴生对象的 Kotlin 接口导出到 JavaScript/TypeScript 时，
在 TypeScript 中使用该接口的方式会因模块系统（ES 模块或其他）而异。</p>
<p>例如：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin"><span class="hljs-meta">@JsExport</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> {
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"OK"</span>
    }
}
</code></pre>
<p>调用的时候：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 适用于 CommonJS、AMD、UMD 和无模块</span>
Foo.bar()

<span class="hljs-comment">// 适用于 ES 模块</span>
Foo.getInstance().bar()
</code></pre>
<p>而现在，Kotlin 统一了所有 JavaScript 模块系统的伴生对象导出。
在 2.3.0 之后，对于每个模块系统（ES 模块、CommonJS、AMD、UMD、无模块），接口内的伴生对象总是以相同的方式访问（就像类中的伴生对象一样）：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 适用于所有模块系统</span>
Foo.Companion.bar()
</code></pre>
<p>这个改进还顺便修复了集合类型互操作性。
比如集合工厂函数必须根据模块系统以不同方式访问：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 适用于 CommonJS、AMD、UMD 和无模块</span>
KtList.fromJsArray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])

<span class="hljs-comment">// 适用于 ES 模块</span>
KtList.getInstance().fromJsArray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
</code></pre>
<p>现在也改过来啦：</p>
<pre><code class="hljs language-Kotlin" lang="Kotlin">KtList.fromJsArray([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
</code></pre>
<blockquote>
<p>此功能默认启用，更新版本即可享受～</p>
</blockquote>
<h3 data-id="heading-21">支持带有伴生对象的接口中的 <code>@JsStatic</code> 注解</h3>
<p>之前的版本中 <code>@JsStatic</code> 注解不允许在导出的带有伴生对象的接口内使用。</p>
<p>例如，以下代码会产生错误，因为只有类伴生对象的成员才能用 <code>@JsStatic</code> 注解：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@JsExport</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> {
    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
        <span class="hljs-meta">@JsStatic</span> <span class="hljs-comment">// 错误</span>
        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span></span> = <span class="hljs-string">"OK"</span>
    }
}
</code></pre>
<p>这种情况下你就不得不删除 <code>@JsStatic</code> 并用下述方式从 JS 访问伴生对象：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">Foo.Companion.bar()
</code></pre>
<p>现在，带有伴生对象的接口支持 <code>@JsStatic</code> 注解了。
你现在可以在此类伴生对象上使用此注解，并直接从 JS 调用函数，就像对 <code>class</code> 那样：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">Foo.bar()
</code></pre>
<blockquote>
<p>此功能默认启用，更新版本即可享受～</p>
</blockquote>
<h3 data-id="heading-22"><code>@JsQualifier</code> 注解可用于单个函数和类</h3>
<p>以前，<code>@JsQualifier</code> 注解只能在文件级别应用，并要求所有外部 JS 声明放在单独的文件中。</p>
<p>从 Kotlin 2.3.0 开始，可以将 <code>@JsQualifier</code> 注解直接应用于单个函数和类了，
就像 <code>@JsModule</code> 和 <code>@JsNonModule</code> 注解一样！</p>
<p>例如，现在可以在同一文件中将下述外部函数代码写在常规 Kotlin 声明旁边：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@JsQualifier(<span class="hljs-string">"jsPackage"</span>)</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">external</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">jsFun</span><span class="hljs-params">()</span></span>
</code></pre>
<blockquote>
<p>此功能默认启用，更新版本即可享受～</p>
</blockquote>
<h3 data-id="heading-23">支持 JavaScript 默认导出</h3>
<p>之前的版本中 Kotlin/JS 无法从 Kotlin 代码生成 JS 的默认导出。
相反，Kotlin/JS 只生成命名导出，例如：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> { <span class="hljs-title class_">SomeDeclaration</span> };
</code></pre>
<p>如果需要默认导出，则必须使用变通方法，例如将 <code>@JsName</code> 注解与 <code>default</code> 加空格作为参数：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@JsExport</span>
<span class="hljs-meta">@JsName(<span class="hljs-string">"default "</span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeDeclaration</span>
</code></pre>
<blockquote>
<p>有一说一不看这更新文档我都不知道还有这种变通方法...</p>
</blockquote>
<p>而现在，可以通过新注解 <code>@JsExport.Default</code> 直接支持默认导出了！
应用于 Kotlin 声明（类、对象、函数或属性）时，生成的 JS 会自动为 ES 模块包含 <code>export default</code> 语句：</p>
<p>效果如下：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">HelloWorker</span>;
</code></pre>
<blockquote>
<p>此功能默认启用，更新版本即可直接使用注解 <code>@JsExport.Default</code> ～</p>
</blockquote>
<h2 data-id="heading-24">标准库</h2>
<p>标准库也迎来了一波转正与改进～</p>
<h3 data-id="heading-25">改进的 UUID 生成和解析</h3>
<p>Kotlin 2.3.0 为 <code>UUID</code> API 引入了多项改进，包括：</p>
<ul>
<li>解析无效 UUID 时返回 <code>null</code> 的支持</li>
<li>生成 v4 和 v7 UUID 的新函数</li>
<li>为特定时间戳生成 v7 UUID 的支持</li>
</ul>
<h4 data-id="heading-26">解析无效 UUID 时返回 <code>null</code> 的支持</h4>
<p>2.3.0 增加了一些支持返回 null 的 API 。不看后面的文档我也能猜到，
肯定是添加了一些结尾是 <code>orNull</code> 的 API 🤓</p>
<ul>
<li><code>Uuid.parseOrNull()</code> – 解析十六进制带短横线或纯十六进制格式的 UUID 时。</li>
<li><code>Uuid.parseHexDashOrNull()</code> – 仅解析十六进制带短横线格式的 UUID 时。</li>
<li><code>Uuid.parseHexOrNull()</code> – 仅解析纯十六进制格式的 UUID 时。</li>
</ul>
<h4 data-id="heading-27">生成 v4 和 v7 UUID 的新函数</h4>
<p>2.3.0 引入了两个用于生成 UUID 的新函数：<code>Uuid.generateV4()</code> 和 <code>Uuid.generateV7()</code>。</p>
<p><code>Uuid.random()</code> 函数保持不变，仍然生成版本 4 UUID，就像 <code>Uuid.generateV4()</code> 一样。</p>
<h4 data-id="heading-28">为特定时间戳生成 v7 UUID 的支持</h4>
<p>书接上文。对于 v7 UUID，2.3.0 还引入了新的 <code>Uuid.generateV7NonMonotonicAt(...)</code> 函数，
可以使用它为特定时间点生成 v7 UUID。</p>
<blockquote>
<p>与 <code>Uuid.generateV7()</code> 不同，<code>Uuid.generateV7NonMonotonicAt(...)</code> 不保证单调排序，因此为同一时间戳创建的多个 UUID 可能不是顺序的。</p>
</blockquote>
<hr/>
<p>这几个功能（或者说 UUID API）还是实验性的，使用它的时候需要 optIn 注解，
或添加编译器参数 <code>-opt-in=kotlin.uuid.ExperimentalUuidApi</code> ：</p>
<pre><code class="hljs language-csharp" lang="csharp">kotlin {
    compilerOptions {
        freeCompilerArgs.<span class="hljs-keyword">add</span>(<span class="hljs-string">"-opt-in=kotlin.uuid.ExperimentalUuidApi"</span>)
    }
}
</code></pre>
<h3 data-id="heading-29"><code>Clock</code>/<code>Instant</code> 转正</h3>
<p>终于！现在 <code>kotlin.time.Clock</code> 和 <code>Instant</code> 正式 Stable，可以放心在公共 API 里暴露和使用了。</p>
<h2 data-id="heading-30">Gradle: 新增生成源码 API</h2>
<p><code>KotlinSourceSet.generatedKotlin</code> 这个新 API 可以优雅注册「生成的源码」，IDE 也能区分、自动触发生成任务。
简单示例如下：</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">val</span> gen = tasks.register(<span class="hljs-string">"generator"</span>) {
    <span class="hljs-keyword">val</span> output = layout.projectDirectory.dir(<span class="hljs-string">"src/main/kotlinGen"</span>)
    outputs.dir(output)
    doLast {
        output.file(<span class="hljs-string">"generated.kt"</span>).asFile.writeText(
            <span class="hljs-comment">// language=kotlin</span>
            <span class="hljs-string">"""
            fun printHello() {
                println("hello")
            }
            """</span>.trimIndent()
        )
    }
}

kotlin.sourceSets.getByName(<span class="hljs-string">"main"</span>).generatedKotlin.srcDir(gen)
</code></pre>
<p>看起来是一个主要为了配合 <a href="https://link.juejin.cn?target=https%3A%2F%2Fkotlinlang.org%2Fdocs%2Fksp-overview.html" target="_blank" title="https://kotlinlang.org/docs/ksp-overview.html" ref="nofollow noopener noreferrer">KSP</a> 的新功能。不过有一说一，
KSP 的源码生成的检测（尤其是在 KMP 项目中）的相关体验确实有些一言难尽。希望这次可以有所改善吧。</p>
<h2 data-id="heading-31">Compose 编译器: Release 版也能看懂 Stacktrace</h2>
<p>Compose 编译器插件现在会在 R8 混淆阶段顺便产出 group key 的 mapping，
搭配 <code>ComposeStackTraceMode.GroupKeys</code> 就算是 release 版的崩溃也能定位到哪个 <code>@Composable</code> 块。</p>
<p>要启用 group key stacktrace，可以在初始化任何 <code>@Composable</code> 内容之前加上一句：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">Composer.setDiagnosticStackTraceMode(ComposeStackTraceMode.GroupKeys)
</code></pre>
<p>如果这套 mapping 机制在你项目里反而带来了一些构建上的问题，也可以直接在 <code>composeCompiler {}</code> 里完全关闭：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">composeCompiler {
    includeComposeMappingFile.<span class="hljs-keyword">set</span>(<span class="hljs-literal">false</span>)
}
</code></pre>
<blockquote>
<p>有一说一，Compose 我只是勉强会用的程度，更别说调试了。</p>
</blockquote>
<h2 data-id="heading-32">破坏性变更&amp;弃用&amp;文档更新</h2>
<p>官方还列举了一些破坏变更和弃用的内容条目。
不过大多数内容是弃用的，并且仍然保持语言本身的向后兼容。因此如果你对这方面比较敏感或者有需求，
可以自行前往官方文档阅读并学习如何迁移。我比较懒，就不再重新列举一遍咯～</p>
<p>官方还列举了一些有关文档内容的更新，比如 KMP 的独立页面也整合进来了。
不过经常翻阅官方文档的小伙伴们肯定已经发现了，有兴趣的话可以直接去官方文档溜一溜～</p>
<h2 data-id="heading-33">尾声</h2>
<p>到这里就基本整理完啦～ K/JS 能导出 <code>suspend</code> 函数以及对标准库的时间API的稳定对我个人来讲无疑是最喜欢的、也是最有帮助的。
你呢？你认为这次更新中有没有你心目中的「史诗级」？</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Tailwind CSS v4 开发 APP 内嵌 H5：安卓 WebView 样式丢失问题解决与降级实战]]></title>    <link>https://juejin.cn/post/7584297353420685312</link>    <guid>https://juejin.cn/post/7584297353420685312</guid>    <pubDate>2025-12-17T02:38:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584297353420685312" data-draft-id="7584319403861803043" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Tailwind CSS v4 开发 APP 内嵌 H5：安卓 WebView 样式丢失问题解决与降级实战"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-17T02:38:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端无涯"/> <meta itemprop="url" content="https://juejin.cn/user/3967483738859639"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Tailwind CSS v4 开发 APP 内嵌 H5：安卓 WebView 样式丢失问题解决与降级实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3967483738859639/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端无涯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:38:07.000Z" title="Wed Dec 17 2025 02:38:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<p>在移动端 H5 开发中，Tailwind CSS 凭借其原子化 CSS 的高效性成为主流选择，而 Tailwind CSS v4（<code>@tailwindcss/postcss</code> + <code>tailwindcss ^4.x</code>）作为最新版本，引入了诸多现代特性，大幅提升了开发体验。但在<strong>APP 内嵌 H5 场景</strong>中，我们发现一个致命问题：部分安卓设备的 WebView 会出现样式完全丢失的情况，尤其是 Android 11 及以下未更新的 WebView 设备。本文将深入分析问题根源，并给出<strong>降级到 Tailwind CSS v3</strong>的完整解决方案，同时探讨替代兼容方案的可行性。</p>
<h2 data-id="heading-0">一、问题现象：APP 内嵌 H5 样式离奇丢失</h2>
<p>近期在基于 Tailwind CSS v4 开发 APP 内嵌 H5 项目时，测试阶段发现了明显的兼容性问题：</p>
<ul>
<li><strong>现代浏览器 / 高版本安卓 WebView</strong>：样式渲染正常，与开发环境一致；</li>
<li><strong>Android 11 及以下旧版 WebView</strong>（尤其是 APP 自带的未更新 WebView）：页面样式完全丢失，元素仅保留原生 HTML 样式，呈现 “裸奔” 状态；</li>
<li><strong>iOS 设备</strong>：无论是 Safari 还是 APP 的 WKWebView，样式渲染均正常。</li>
</ul>
<p>这一现象仅出现在 APP 内嵌的安卓 WebView 中，直接影响了大量低版本安卓用户的使用体验。</p>
<h2 data-id="heading-1">二、问题根源：Tailwind CSS v4 与旧版 WebView 的特性冲突</h2>
<p>要理解样式丢失的原因，需从<strong>Tailwind CSS v4 的核心变化</strong>和<strong>安卓 WebView 的兼容性</strong>两个维度分析。</p>
<h3 data-id="heading-2">1. Tailwind CSS v4 的关键变化：默认依赖现代 CSS 特性</h3>
<p>Tailwind CSS v4 相较于 v3，一个核心调整是<strong>全面拥抱现代 CSS 特性</strong>，其中最关键的是 **<code>@layer</code> CSS 级联层 ** 的强制使用：</p>
<ul>
<li>Tailwind CSS v4 将所有样式（基础样式、组件样式、工具类样式）默认封装在<code>@layer</code>级联层中，替代了 v3 中手动声明<code>@tailwind base/components/utilities</code>的方式；</li>
<li><code>@layer</code>是 CSS Cascading Layers 的核心特性，用于管理 CSS 的优先级和层级，属于 CSS 最新规范（CSS Cascading and Inheritance Level 5）。</li>
</ul>
<h3 data-id="heading-3">2. 安卓 WebView 的兼容性短板</h3>
<p>安卓设备的 WebView 渲染内核分为两种：</p>
<ul>
<li><strong>Android 7.0+</strong> ：默认使用 Chrome 内核，但<strong>系统 / WebView 的更新并非与 Chrome 同步</strong>（尤其是国内定制安卓系统，如小米、华为的 EMUI，往往会冻结 WebView 版本）；</li>
<li><strong>Android 11 及以下</strong>：大量设备的 WebView 版本停留在 Chrome 80 以下，而 **<code>@layer</code>特性仅在 Chrome 99+、Android WebView 99 + 中得到支持 **（可参考<a href="https://link.juejin.cn?target=https%3A%2F%2Fcaniuse.com%2Fcss-cascade-layers" title="https://caniuse.com/css-cascade-layers" target="_blank" ref="nofollow noopener noreferrer">caniuse</a>）。</li>
</ul>
<p>当旧版 WebView 解析包含<code>@layer</code>的 CSS 时，会直接忽略该语法及内部的所有样式，这就导致了 Tailwind CSS v4 的样式完全失效。</p>
<h3 data-id="heading-4">3. APP 内嵌场景的额外风险</h3>
<p>与原生浏览器不同，APP 内嵌的 WebView 往往被开发者做了更多限制：</p>
<ul>
<li>禁用了部分 WebView 的自动更新功能，导致内核版本长期老旧；</li>
<li>部分 APP 为了性能 / 安全，会拦截或修改 CSS 解析流程，进一步放大现代 CSS 特性的兼容性问题。</li>
</ul>
<h2 data-id="heading-5">三、解决方案：降级到 Tailwind CSS v3（最稳妥方案）</h2>
<p>面对旧版 WebView 的兼容性限制，<strong>降级到 Tailwind CSS v3</strong>是目前最直接、最稳妥的解决方案。因为 Tailwind CSS v3 虽然也支持<code>@layer</code>，但并非强制依赖，其核心指令（<code>@tailwind base</code>等）兼容所有现代浏览器及旧版 WebView（Chrome 60+、Android WebView 60+）。</p>
<p>以下是完整的降级实施步骤，适用于使用 npm/yarn/pnpm 的前端项目。</p>
<h3 data-id="heading-6">步骤 1：卸载 Tailwind CSS v4 相关依赖</h3>
<p>首先移除 v4 的核心依赖<code>tailwindcss ^4.x</code>和<code>@tailwindcss/postcss</code>：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># npm</span>
npm uninstall tailwindcss @tailwindcss/postcss

<span class="hljs-comment"># yarn</span>
yarn remove tailwindcss @tailwindcss/postcss

<span class="hljs-comment"># pnpm</span>
pnpm remove tailwindcss @tailwindcss/postcss
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-7">步骤 2：安装 Tailwind CSS v3 稳定版本</h3>
<p>安装 Tailwind CSS v3 的最新稳定版本（推荐 3.4.x 系列，如 3.4.17），同时安装<code>postcss</code>和<code>autoprefixer</code>（v3 的核心依赖）：</p>
<pre><code class="hljs language-sql" lang="sql"># npm
npm install tailwindcss<span class="hljs-variable">@3</span><span class="hljs-number">.4</span><span class="hljs-number">.17</span> postcss autoprefixer <span class="hljs-comment">--save-dev</span>

# yarn
yarn <span class="hljs-keyword">add</span> tailwindcss<span class="hljs-variable">@3</span><span class="hljs-number">.4</span><span class="hljs-number">.17</span> postcss autoprefixer <span class="hljs-comment">--dev</span>

# pnpm
pnpm <span class="hljs-keyword">add</span> tailwindcss<span class="hljs-variable">@3</span><span class="hljs-number">.4</span><span class="hljs-number">.17</span> postcss autoprefixer <span class="hljs-operator">-</span>D
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-8">步骤 3：重新初始化 Tailwind CSS 配置（可选，若已有 v3 配置可跳过）</h3>
<p>如果项目中没有 Tailwind CSS v3 的配置文件，执行初始化命令生成<code>tailwind.config.js</code>：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta"># npx</span>
npx tailwindcss <span class="hljs-keyword">init</span> -p

<span class="hljs-meta"># yarn</span>
yarn tailwindcss <span class="hljs-keyword">init</span> -p

<span class="hljs-meta"># pnpm</span>
pnpm tailwindcss <span class="hljs-keyword">init</span> -p
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>该命令会生成两个文件：</p>
<ul>
<li><code>tailwind.config.js</code>：Tailwind CSS 的核心配置文件；</li>
<li><code>postcss.config.js</code>/<code>postcss.config.mjs</code>：PostCSS 的配置文件。</li>
</ul>
<h3 data-id="heading-9">步骤 4：调整 PostCSS 配置文件</h3>
<p>Tailwind CSS v4 使用的是<code>@tailwindcss/postcss</code>插件，而 v3 需要改回标准的<code>tailwindcss</code>和<code>autoprefixer</code>插件。</p>
<h4 data-id="heading-10">旧版（v4）PostCSS 配置（示例：postcss.config.mjs）：</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 废弃的v4配置</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  plugins: {
    <span class="hljs-string">'@tailwindcss/postcss'</span>: {},
  },
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-11">新版（v3）PostCSS 配置（示例：postcss.config.mjs）：</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// v3标准配置</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  plugins: {
    tailwindcss: {}, <span class="hljs-comment">// 核心Tailwind插件</span>
    autoprefixer: {}, <span class="hljs-comment">// 自动添加CSS前缀，提升兼容性</span>
  },
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-12">步骤 5：修改样式入口文件的指令</h3>
<p>Tailwind CSS v4 使用<code>@import 'tailwindcss';</code>的导入方式，而 v3 需要使用标准的<code>@tailwind</code>指令来引入基础样式、组件和工具类。</p>
<h4 data-id="heading-13">旧版（v4）样式文件（示例：src/index.css）：</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">/* 废弃的v4语法 */</span>
<span class="hljs-keyword">@import</span> <span class="hljs-string">'tailwindcss'</span>;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-14">新版（v3）样式文件（示例：src/index.css）：</h4>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">/* v3标准指令：引入Tailwind的基础样式、组件和工具类 */</span>
<span class="hljs-variable">@tailwind</span> base;
<span class="hljs-variable">@tailwind</span> components;
<span class="hljs-variable">@tailwind</span> utilities;

<span class="hljs-comment">/* 自定义样式可写在下方，或通过@layer指令封装（可选） */</span>
<span class="hljs-comment">/* 示例：自定义基础样式 */</span>
<span class="hljs-variable">@layer</span> base {
  <span class="hljs-selector-tag">body</span> {
    <span class="hljs-variable">@apply</span> bg-gray-<span class="hljs-number">50</span> text-gray-<span class="hljs-number">900</span>;
  }
}
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-15">步骤 6：验证配置并重启项目</h3>
<p>完成上述修改后，重启项目的开发服务器，此时 Tailwind CSS v3 的样式会正常生效：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 重启开发服务（根据项目包管理器调整）</span>
npm run dev
<span class="hljs-comment"># 或</span>
yarn dev
<span class="hljs-comment"># 或</span>
pnpm dev
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-16">四、备选方案：保留 v4 并兼容旧版 WebView（不推荐）</h2>
<p>如果项目因特殊原因无法降级到 v3，也可以尝试通过工具来兼容<code>@layer</code>特性，但该方案存在一定风险（配置复杂、可能引入新问题），仅作为备选。</p>
<h3 data-id="heading-17">方案 1：使用 PostCSS 插件转换<code>@layer</code></h3>
<p>通过<code>postcss-layer-transform</code>等插件，将<code>@layer</code>语法转换为旧版 CSS 能识别的样式：</p>
<ol>
<li>
<p>安装插件：</p>
<pre><code class="hljs language-css" lang="css">npm install postcss-layer-<span class="hljs-attribute">transform</span> <span class="hljs-attr">--save-dev</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
</li>
<li>
<p>在 PostCSS 配置中添加插件：</p>
<pre><code class="hljs language-css" lang="css">export default {
  plugins: {
    '<span class="hljs-keyword">@tailwindcss</span>/postcss': {},
    'postcss-layer-<span class="hljs-attribute">transform</span>': {}, // 转换<span class="hljs-keyword">@layer</span>语法
    <span class="hljs-attribute">autoprefixer</span>: {},
  },
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>缺点：该插件并非官方维护，对 Tailwind CSS v4 的适配性有限，可能导致部分样式异常。</p>
</li>
</ol>
<h3 data-id="heading-18">方案 2：手动提取 Tailwind CSS 样式为静态 CSS</h3>
<p>使用 Tailwind CSS v4 的 CLI 工具将样式提取为静态 CSS 文件，再通过工具移除<code>@layer</code>语法：</p>
<ol>
<li>
<p>生成静态 CSS：</p>
<pre><code class="hljs language-bash" lang="bash">npx tailwindcss build src/index.css -o dist/tailwind.css
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
</li>
<li>
<p>使用 PostCSS 工具处理生成的 CSS，移除<code>@layer</code>并调整样式层级。缺点：失去 Tailwind CSS 的热更新和动态编译能力，开发效率大幅降低。</p>
</li>
</ol>
<h2 data-id="heading-19">五、关键注意事项：APP 内嵌 H5 的兼容性优化</h2>
<p>无论选择降级还是保留 v4，开发 APP 内嵌 H5 时，还需注意以下兼容性问题：</p>
<h3 data-id="heading-20">1. 锁定 Tailwind CSS 版本</h3>
<p>在<code>package.json</code>中明确指定 Tailwind CSS 的版本，避免依赖自动更新导致的兼容性问题：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"tailwindcss"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"3.4.17"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"postcss"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^8.4.31"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"autoprefixer"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^10.4.16"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-21">2. 配置 autoprefixer 的浏览器目标</h3>
<p>在<code>package.json</code>或<code>browserslist</code>文件中指定目标浏览器，让 autoprefixer 自动添加适配的 CSS 前缀：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-comment">// package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"browserslist"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">"Android &gt;= 6.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"iOS &gt;= 12"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"Chrome &gt;= 60"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">"Safari &gt;= 12"</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-22">3. 测试环节：覆盖关键安卓版本</h3>
<p>务必在<strong>真实设备</strong>或<strong>模拟器</strong>中测试以下场景：</p>
<ul>
<li>Android 7.0/9.0/11/13 的原生 WebView；</li>
<li>主流 APP 的内嵌 WebView（微信、支付宝、自研 APP）；</li>
<li>国内定制安卓系统（小米、华为、OPPO）的 WebView。</li>
</ul>
<h3 data-id="heading-23">4. 避免使用其他现代 CSS 特性</h3>
<p>除了<code>@layer</code>，还应避免在 APP 内嵌 H5 中使用旧版 WebView 不支持的 CSS 特性（如<code>container queries</code>、<code>:has()</code>选择器等），可通过<a href="https://link.juejin.cn?target=https%3A%2F%2Fcaniuse.com%2F" title="https://caniuse.com/" target="_blank" ref="nofollow noopener noreferrer">caniuse</a>查询兼容性。</p>
<h2 data-id="heading-24">六、总结</h2>
<p>Tailwind CSS v4 的现代特性虽然提升了开发体验，但在 APP 内嵌 H5 的场景中，由于安卓旧版 WebView 对<code>@layer</code>等 CSS 新特性的支持不足，直接导致样式丢失问题。<strong>降级到 Tailwind CSS v3</strong>是目前最稳妥、最高效的解决方案，能够覆盖所有主流安卓设备的 WebView。</p>
<p>如果项目必须使用 Tailwind CSS v4，可尝试通过 PostCSS 插件转换<code>@layer</code>语法，但需承担配置复杂和样式异常的风险。在移动端 H5 开发中，兼容性始终是首要考虑的因素，选择成熟的技术版本往往比追求最新特性更重要。</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[给数组装上超能力：JavaScript数组方法趣味指南]]></title>    <link>https://juejin.cn/post/7584345932944343091</link>    <guid>https://juejin.cn/post/7584345932944343091</guid>    <pubDate>2025-12-17T01:59:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584345932944343091" data-draft-id="7584340871413121051" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="给数组装上超能力：JavaScript数组方法趣味指南"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-12-17T01:59:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JS_Likers"/> <meta itemprop="url" content="https://juejin.cn/user/1377017277975032"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            给数组装上超能力：JavaScript数组方法趣味指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1377017277975032/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JS_Likers
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T01:59:14.000Z" title="Wed Dec 17 2025 01:59:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>欢迎使用我的小程序👇👇👇👇</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d25c4001b1b4e6e902dc1f8863bcef2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSlNfTGlrZXJz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766541553&amp;x-signature=kSoE7YAzzxw2ZO8mKBMhBwGO5Vs%3D" alt="small.png" loading="lazy"/></p>
<hr/>
<p>你是否曾感觉JavaScript数组像个装满数据的“沉默集装箱”？今天，我们来给它装上超能力！🚀</p>
<h2 data-id="heading-0">为什么数组方法如此重要？</h2>
<p>想象一下，你有一个装满各种颜色袜子的抽屉（数组）。现在你想：</p>
<ul>
<li>找出所有红色的袜子</li>
<li>把袜子按颜色分类</li>
<li>检查是否有成对的袜子</li>
<li>把脏袜子拿出来洗</li>
</ul>
<p>如果没有数组方法，你得把手伸进抽屉里一件件翻找。但有了数组方法——就像拥有了一个智能机器人助手！🤖</p>
<h2 data-id="heading-1">四大类数组方法，轻松掌握</h2>
<h3 data-id="heading-2">1️⃣ 查户口类：了解数组的“家庭情况”</h3>
<p><strong><code>length</code> - 数组的“身高测量”</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fruits = [<span class="hljs-string">'苹果'</span>, <span class="hljs-string">'香蕉'</span>, <span class="hljs-string">'橙子'</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fruits.<span class="hljs-property">length</span>); <span class="hljs-comment">// 3，就像数水果篮里有几个水果</span>
</code></pre>
<p><strong><code>includes()</code> - 数组的“人脸识别”</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> playlist = [<span class="hljs-string">'周杰伦'</span>, <span class="hljs-string">'林俊杰'</span>, <span class="hljs-string">'邓紫棋'</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(playlist.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'周杰伦'</span>)); <span class="hljs-comment">// true，确认偶像在歌单里</span>
</code></pre>
<p><strong><code>indexOf()</code> 和 <code>findIndex()</code> - 数组的“捉迷藏专家”</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> students = [<span class="hljs-string">'小明'</span>, <span class="hljs-string">'小红'</span>, <span class="hljs-string">'小刚'</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(students.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'小红'</span>)); <span class="hljs-comment">// 1，小红坐在第二个位置</span>

<span class="hljs-keyword">const</span> scores = [<span class="hljs-number">85</span>, <span class="hljs-number">92</span>, <span class="hljs-number">78</span>];
<span class="hljs-keyword">const</span> firstFail = scores.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">score</span> =&gt;</span> score &lt; <span class="hljs-number">80</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(firstFail); <span class="hljs-comment">// 2，找到第一个不及格的同学</span>
</code></pre>
<h3 data-id="heading-3">2️⃣ 变戏法类：改变数组的“魔术师”</h3>
<p><strong><code>map()</code> - 数组的“变形金刚”</strong> ⭐最常用！</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> prices = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>];
<span class="hljs-keyword">const</span> discounted = prices.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">price</span> =&gt;</span> price * <span class="hljs-number">0.8</span>); <span class="hljs-comment">// 全场八折！</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(discounted); <span class="hljs-comment">// [8, 16, 24]</span>
</code></pre>
<p><strong><code>forEach()</code> - 数组的“广播喇叭”</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> tasks = [<span class="hljs-string">'写代码'</span>, <span class="hljs-string">'喝咖啡'</span>, <span class="hljs-string">'修bug'</span>];
tasks.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">task</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`正在：<span class="hljs-subst">${task}</span>`</span>));
<span class="hljs-comment">// 依次播报每项任务</span>
</code></pre>
<p><strong><code>reduce()</code> - 数组的“会计先生”</strong> ⭐有点难但超有用！</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> shoppingCart = [<span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">25</span>];
<span class="hljs-keyword">const</span> total = shoppingCart.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, price</span>) =&gt;</span> sum + price, <span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(total); <span class="hljs-comment">// 175，计算购物车总价</span>
</code></pre>
<h3 data-id="heading-4">3️⃣ 大扫除类：整理数组的“清洁工”</h3>
<p><strong><code>filter()</code> - 数组的“筛子”</strong> ⭐五星推荐！</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];
<span class="hljs-keyword">const</span> evens = numbers.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evens); <span class="hljs-comment">// [2, 4, 6]，只留下偶数</span>
</code></pre>
<p><strong><code>slice()</code> - 数组的“切蛋糕刀”</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> pizza = [<span class="hljs-string">'芝士'</span>, <span class="hljs-string">'香肠'</span>, <span class="hljs-string">'蘑菇'</span>, <span class="hljs-string">'青椒'</span>, <span class="hljs-string">'洋葱'</span>];
<span class="hljs-keyword">const</span> mySlice = pizza.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 切下第2到第4块</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySlice); <span class="hljs-comment">// ['香肠', '蘑菇', '青椒']</span>
</code></pre>
<p><strong><code>splice()</code> - 数组的“瑞士军刀”</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> todoList = [<span class="hljs-string">'学习JS'</span>, <span class="hljs-string">'健身'</span>, <span class="hljs-string">'看电影'</span>];
todoList.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'学数组方法'</span>); <span class="hljs-comment">// 替换第二个任务</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(todoList); <span class="hljs-comment">// ['学习JS', '学数组方法', '看电影']</span>
</code></pre>
<h2 data-id="heading-5">实战演练：一起来玩数组方法！</h2>
<h3 data-id="heading-6">场景：管理你的游戏好友列表 🎮</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 初始好友列表</span>
<span class="hljs-keyword">let</span> friends = [
    { <span class="hljs-attr">name</span>: <span class="hljs-string">'小明'</span>, <span class="hljs-attr">level</span>: <span class="hljs-number">25</span>, <span class="hljs-attr">online</span>: <span class="hljs-literal">true</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">'小红'</span>, <span class="hljs-attr">level</span>: <span class="hljs-number">30</span>, <span class="hljs-attr">online</span>: <span class="hljs-literal">false</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">'小刚'</span>, <span class="hljs-attr">level</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">online</span>: <span class="hljs-literal">true</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">'小李'</span>, <span class="hljs-attr">level</span>: <span class="hljs-number">40</span>, <span class="hljs-attr">online</span>: <span class="hljs-literal">true</span> }
];

<span class="hljs-comment">// 1. 找出所有在线的好友</span>
<span class="hljs-keyword">const</span> onlineFriends = friends.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">friend</span> =&gt;</span> friend.<span class="hljs-property">online</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'在线好友：'</span>, onlineFriends.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> f.<span class="hljs-property">name</span>));

<span class="hljs-comment">// 2. 给所有好友升5级</span>
<span class="hljs-keyword">const</span> leveledUp = friends.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">friend</span> =&gt;</span> ({
    ...friend,
    <span class="hljs-attr">level</span>: friend.<span class="hljs-property">level</span> + <span class="hljs-number">5</span>
}));

<span class="hljs-comment">// 3. 找出最高等级的好友</span>
<span class="hljs-keyword">const</span> topPlayer = friends.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">top, current</span>) =&gt;</span> 
    current.<span class="hljs-property">level</span> &gt; top.<span class="hljs-property">level</span> ? current : top
);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'大佬是：'</span>, topPlayer.<span class="hljs-property">name</span>);

<span class="hljs-comment">// 4. 按等级排序</span>
<span class="hljs-keyword">const</span> sortedFriends = [...friends].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">level</span> - a.<span class="hljs-property">level</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'等级排行榜：'</span>, sortedFriends.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">f</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${f.name}</span>: <span class="hljs-subst">${f.level}</span>级`</span>));
</code></pre>
<h2 data-id="heading-7">链式调用：数组方法的“组合技”✨</h2>
<p>真正的魔法在这里！你可以把多个方法连起来用：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> products = [
    { <span class="hljs-attr">name</span>: <span class="hljs-string">'手机'</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">2999</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">'电子'</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">'衬衫'</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">199</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">'服装'</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">'笔记本'</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">5999</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">'电子'</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">'鞋子'</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">399</span>, <span class="hljs-attr">category</span>: <span class="hljs-string">'服装'</span> }
];

<span class="hljs-comment">// 一行代码完成复杂操作！</span>
<span class="hljs-keyword">const</span> expensiveElectronics = products
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span> product.<span class="hljs-property">category</span> === <span class="hljs-string">'电子'</span>)  <span class="hljs-comment">// 1. 筛选电子产品</span>
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span> product.<span class="hljs-property">price</span> &gt; <span class="hljs-number">2000</span>)         <span class="hljs-comment">// 2. 筛选高价商品</span>
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">product</span> =&gt;</span> product.<span class="hljs-property">name</span>)                    <span class="hljs-comment">// 3. 只取商品名</span>
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">', '</span>);                                     <span class="hljs-comment">// 4. 用逗号连接</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`高价电子产品：<span class="hljs-subst">${expensiveElectronics}</span>`</span>);
<span class="hljs-comment">// 输出：高价电子产品：手机, 笔记本</span>
</code></pre>
<h2 data-id="heading-8">小测验：测测你的数组超能力 🧠</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 挑战：用一行代码解决！</span>
<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>];

<span class="hljs-comment">// 任务：去重 → 排序 → 只留大于3的数 → 求和</span>
<span class="hljs-keyword">const</span> result = <span class="hljs-comment">/* 你的代码写在这里 */</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 应该输出：20 (4+5+6+9)</span>
</code></pre>
<p><strong>参考答案：</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> result = [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(numbers)]
    .<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)
    .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num &gt; <span class="hljs-number">3</span>)
    .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, num</span>) =&gt;</span> sum + num, <span class="hljs-number">0</span>);
</code></pre>
<h2 data-id="heading-9">总结与最佳实践</h2>
<ol>
<li><strong>不改变原数组</strong>：优先使用<code>map</code>、<code>filter</code>、<code>slice</code>等</li>
<li><strong>链式调用</strong>：让代码更优雅，从左到右阅读</li>
<li><strong>方法选择</strong>：
<ul>
<li>想<strong>转换</strong>每个元素 → <code>map()</code></li>
<li>想<strong>筛选</strong>某些元素 → <code>filter()</code></li>
<li>想<strong>检查</strong>条件 → <code>some()</code>/<code>every()</code></li>
<li>想<strong>汇总</strong>为单个值 → <code>reduce()</code></li>
</ul>
</li>
</ol>
<p>记住：数组方法不是记忆负担，而是你的<strong>超能力工具箱</strong>！每次遇到数组操作问题时，想想：“我的工具箱里有什么合适的工具？”</p>
<p>现在就去你的代码里试试这些超能力吧！你会惊讶地发现，处理数据变得如此轻松愉快。🎉</p>
<p><strong>一句话总结：</strong> 数组方法让JavaScript从“能干活”变成“干得漂亮”！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vue2 vs Vue3]]></title>    <link>https://juejin.cn/post/7584319403861884963</link>    <guid>https://juejin.cn/post/7584319403861884963</guid>    <pubDate>2025-12-17T02:44:45.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584319403861884963" data-draft-id="7584339190034595880" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vue2 vs Vue3"/> <meta itemprop="keywords" content="Vue.js"/> <meta itemprop="datePublished" content="2025-12-17T02:44:45.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小黑的铁粉"/> <meta itemprop="url" content="https://juejin.cn/user/2225067266412605"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vue2 vs Vue3
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2225067266412605/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小黑的铁粉
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:44:45.000Z" title="Wed Dec 17 2025 02:44:45 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>Vue 2 与 Vue 3 的主要区别可以从以下几个方面对比：</p>
<h2 data-id="heading-0">1. <strong>架构重构</strong></h2>
<ul>
<li><strong>Vue 2</strong>：基于 Options API，使用 <code>Object.defineProperty</code> 实现响应式</li>
<li><strong>Vue 3</strong>：基于 Composition API（兼容 Options API），使用 <code>Proxy</code> 实现响应式</li>
</ul>
<h2 data-id="heading-1">2. <strong>响应式系统</strong></h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vue 2 - Object.defineProperty</span>
<span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
  }
}

<span class="hljs-comment">// Vue 3 - Proxy</span>
<span class="hljs-keyword">import</span> { ref, reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Vue 3'</span> })
</code></pre>
<ul>
<li><strong>优势</strong>：Proxy 能检测到属性的添加/删除，数组索引和长度变化</li>
</ul>
<h2 data-id="heading-2">3. <strong>Composition API vs Options API</strong></h2>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- Vue 2 Options API --&gt;
&lt;script&gt;
export default {
  data() {
    return { count: 0 }
  },
  methods: {
    increment() { this.count++ }
  },
  mounted() { console.log('mounted') }
}
&lt;/script&gt;

&lt;!-- Vue 3 Composition API --&gt;
&lt;script setup&gt;
import { ref, onMounted } from 'vue'

const count = ref(0)
const increment = () =&gt; count.value++

onMounted(() =&gt; {
  console.log('mounted')
})
&lt;/script&gt;
</code></pre>
<h2 data-id="heading-3">4. <strong>性能提升</strong></h2>
<ul>
<li><strong>打包体积</strong>：Vue 3 体积减小约 40%（Tree-shaking 优化）</li>
<li><strong>渲染速度</strong>：初始渲染快 55%，更新快 133%</li>
<li><strong>内存占用</strong>：减少约 50%</li>
</ul>
<h2 data-id="heading-4">5. <strong>TypeScript 支持</strong></h2>
<ul>
<li><strong>Vue 2</strong>：需要额外的装饰器或复杂配置</li>
<li><strong>Vue 3</strong>：原生 TypeScript 支持，更好的类型推断</li>
</ul>
<h2 data-id="heading-5">6. <strong>新特性</strong></h2>
<h3 data-id="heading-6"><strong>Fragment</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 可包含多个根节点 --&gt;
&lt;template&gt;
  &lt;header&gt;&lt;/header&gt;
  &lt;main&gt;&lt;/main&gt;
  &lt;footer&gt;&lt;/footer&gt;
&lt;/template&gt;
</code></pre>
<h3 data-id="heading-7"><strong>Teleport</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;teleport to="body"&gt;
    &lt;!-- 将组件渲染到 body 下 --&gt;
    &lt;Modal /&gt;
  &lt;/teleport&gt;
&lt;/template&gt;
</code></pre>
<h3 data-id="heading-8"><strong>Suspense</strong></h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;Suspense&gt;
    &lt;template #default&gt;
      &lt;AsyncComponent /&gt;
    &lt;/template&gt;
    &lt;template #fallback&gt;
      &lt;div&gt;Loading...&lt;/div&gt;
    &lt;/template&gt;
  &lt;/Suspense&gt;
&lt;/template&gt;
</code></pre>
<h2 data-id="heading-9">7. <strong>API 变化</strong></h2>
<h3 data-id="heading-10"><strong>生命周期</strong></h3>


















































<table><thead><tr><th>Vue 2</th><th>Vue 3 (Options API)</th><th>Vue 3 (Composition API)</th></tr></thead><tbody><tr><td>beforeCreate</td><td>❌ 使用 setup</td><td>setup</td></tr><tr><td>created</td><td>❌ 使用 setup</td><td>setup</td></tr><tr><td>beforeMount</td><td>beforeMount</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>updated</td><td>onUpdated</td></tr><tr><td>beforeDestroy</td><td>beforeUnmount</td><td>onBeforeUnmount</td></tr><tr><td>destroyed</td><td>unmounted</td><td>onUnmounted</td></tr></tbody></table>
<h3 data-id="heading-11"><strong>全局 API</strong></h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vue 2</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>()
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>()
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>()

<span class="hljs-comment">// Vue 3 - 改为应用实例</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
app.<span class="hljs-title function_">component</span>()
app.<span class="hljs-title function_">directive</span>()
</code></pre>
<h2 data-id="heading-12">8. <strong>v-model 改进</strong></h2>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- Vue 2：每个组件只能有一个 v-model --&gt;
&lt;ChildComponent v-model="value" /&gt;

&lt;!-- Vue 3：支持多个 v-model --&gt;
&lt;ChildComponent 
  v-model:title="title"
  v-model:content="content"
/&gt;
</code></pre>
<h2 data-id="heading-13">9. <strong>事件 API</strong></h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vue 2</span>
<span class="hljs-variable language_">this</span>.$on(<span class="hljs-string">'event'</span>, handler)
<span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">'event'</span>, data)

<span class="hljs-comment">// Vue 3 - 推荐使用第三方库（如 mitt）或 Provide/Inject</span>
</code></pre>
<h2 data-id="heading-14">10. <strong>迁移建议</strong></h2>
<ul>
<li><strong>新项目</strong>：直接使用 Vue 3 + Composition API</li>
<li><strong>老项目</strong>：
<ul>
<li>小项目：建议升级</li>
<li>大项目：逐步迁移或使用 Vue 2.7（包含部分 Vue 3 特性）</li>
</ul>
</li>
</ul>
<h2 data-id="heading-15">总结</h2>
<p>Vue 3 在性能、开发体验和维护性方面都有显著提升，特别适合大型项目和需要更好 TypeScript 支持的项目。Composition API 提供了更好的逻辑组织和复用能力。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Vite 插件实战 v2：让 keep-alive 的“组件名”自动长出来]]></title>    <link>https://juejin.cn/post/7584365584746790939</link>    <guid>https://juejin.cn/post/7584365584746790939</guid>    <pubDate>2025-12-17T02:42:20.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584365584746790939" data-draft-id="7584339190034317352" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Vite 插件实战 v2：让 keep-alive 的“组件名”自动长出来"/> <meta itemprop="keywords" content="Vue.js,前端,架构"/> <meta itemprop="datePublished" content="2025-12-17T02:42:20.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大象的鼻子那么长"/> <meta itemprop="url" content="https://juejin.cn/user/2277843821926871"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Vite 插件实战 v2：让 keep-alive 的“组件名”自动长出来
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2277843821926871/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大象的鼻子那么长
  </span> <!----> <!----> <div class="vip-level" data-v-cd7d0a50="" data-v-292f6e48=""><span class="tooltip" data-v-cd7d0a50=""><div class="byte-tooltip byte-tooltip--dark" style="display:none;">
        VIP.4 融会贯通
      </div><span class="byte-tooltip__wrapper"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8AQMAAAAAMksxAAAAA1BMVEUAAACnej3aAAAAAXRSTlMAQObYZgAAAA5JREFUKM9jGAWjAAcAAAIcAAE27nY6AAAAAElFTkSuQmCC" alt="VIP.4 融会贯通" title="VIP.4 融会贯通" class="lazy" style="aspect-ratio:NaN;" data-v-5244ef91="" data-v-cd7d0a50=""/></span></span></div> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:42:20.000Z" title="Wed Dec 17 2025 02:42:20 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>日期：2025-12-17<br/>
标签：Vite / Vue3 / 插件开发 / 工程化 / 性能优化</p>
</blockquote>
<h2 data-id="heading-0">摘要</h2>
<p>在大型 Vue3 项目中，<code>&lt;keep-alive&gt;</code> 依赖组件 <code>name</code> 精确匹配，而 <code>&lt;script setup&gt;</code> 默认不生成 <code>name</code>，手写既易漏又易错。本文从“痛点→设计→实现→验证→扩展”的视角，完整讲解一枚可落地的 Vite 插件：它基于路由与 RouteConfig 自动推导组件名，并在编译期注入 <code>defineOptions({ name })</code>，实现零成本 keep-alive。v2 版引入了增量解析、双层缓存、精确 HMR、SourceMap 与冲突检测，适配企业级项目迭代节奏。</p>
<hr/>
<h2 data-id="heading-1">目录</h2>
<ul>
<li>背景与约束</li>
<li>设计目标与原则</li>
<li>架构设计（三张图看懂）</li>
<li>关键实现（算法与代码）</li>
<li>集成与最小可行示例（可复制）</li>
<li>调试、验证与可观测性</li>
<li>复杂/边界场景处理</li>
<li>性能与工程实践</li>
<li>v1→v2 升级指引</li>
<li>总结与延伸</li>
</ul>
<hr/>
<h2 data-id="heading-2">背景与约束</h2>
<ul>
<li>业务背景：多模块、多团队协作的 Vue3 项目，页面数 50+，keep-alive 名称维护分散且脆弱。</li>
<li>技术约束：
<ul>
<li><code>&lt;script setup&gt;</code> 无 <code>name</code>；必须用 <code>defineOptions({ name })</code></li>
<li>路由名是“真源”，组件名应与之强一致</li>
<li>需要兼容常见异步组件写法：<code>() =&gt; import('...')</code> 与 <code>async () =&gt; import('...')</code></li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-3">设计目标与原则</h2>
<ul>
<li>目标
<ul>
<li>自动：编译期无感注入、运行时零侵入</li>
<li>一致：以 RouteConfig 为真源，路由改名自动同步</li>
<li>稳定：HMR 增量更新，缓存命中高，行为幂等</li>
</ul>
</li>
<li>原则
<ul>
<li>最小必要：仅在需要时注入；已有 <code>name/defineOptions</code> 一律跳过</li>
<li>可观测：提供统计与调试日志，生成 SourceMap 便于定位</li>
<li>可回滚：任何“模糊场景”（多路由复用同组件）宁可提示冲突也不盲注</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-4">架构设计（图解）</h2>
<h3 data-id="heading-5">1) 路由解析（状态机示意）</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">stateDiagram-v2
  [*] --&gt; ReadFile
  ReadFile --&gt; RemoveComments: skip // /* */ in strings
  RemoveComments --&gt; ScanBlocks: brace balance
  ScanBlocks --&gt; ExtractAttrs: path/name/component/keepAlive
  ExtractAttrs --&gt; NormalizePath: alias ~/ @/ -&gt; src/
  NormalizePath --&gt; [*]
</code></pre>
<h3 data-id="heading-6">2) HMR 序列</h3>
<pre><code class="hljs language-mermaid" lang="mermaid">sequenceDiagram
  participant Dev as DevServer
  participant P as Plugin
  participant FS as FileSystem
  Dev-&gt;&gt;P: file change (router module or RouteConfig)
  P-&gt;&gt;FS: read changed file
  P-&gt;&gt;P: parse + update caches
  P-&gt;&gt;P: rebuild component-&gt;name mappings
  P--&gt;&gt;Dev: notify transform cache invalidation (if needed)
</code></pre>
<hr/>
<h2 data-id="heading-7">关键实现（算法与代码）</h2>
<blockquote>
<p>以下节选展示关键算法思路；完整实现见 <code>build/plugins/vite-plugin-auto-component-name.ts</code>。</p>
</blockquote>
<h3 data-id="heading-8">1) 解析 RouteConfig（键名还原为真实路由名）</h3>
<ul>
<li>先去注释，再用正则匹配 <code>Key: { name: '...' }</code>；支持多行与嵌套对象</li>
<li>保底策略：逐行简易匹配，提升容错</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 伪代码要点</span>
<span class="hljs-keyword">const</span> clean = <span class="hljs-title function_">removeComments</span>(content)
<span class="hljs-keyword">for</span> each match <span class="hljs-keyword">of</span> /(\w+)\s*:\s*\{ ... <span class="hljs-attr">name</span>:\s*[<span class="hljs-string">'"]([^'</span><span class="hljs-string">"]+)['"</span>]/ <span class="hljs-keyword">in</span> clean
  map.<span class="hljs-title function_">set</span>(key, name)
</code></pre>
<h3 data-id="heading-9">2) 路由模块解析（花括号配对 + 字符串跳过）</h3>
<ul>
<li>用有限状态机配对 <code>{}</code>，在字符串/模板字面量里跳过干扰字符</li>
<li>从块内提取：name/RouteConfig.name、component 的 import 路径、<code>keepAlive</code></li>
</ul>
<h3 data-id="heading-10">3) 注入点选择（import 之后）</h3>
<ul>
<li>在 <code>&lt;script setup&gt;</code> 内定位所有 <code>import</code>，把注入代码放到 import 段之后，保证声明顺序与语义</li>
</ul>
<h3 data-id="heading-11">4) 冲突与幂等</h3>
<ul>
<li>同一组件被多个路由复用 → 标记为冲突，跳过注入并输出警告</li>
<li>已有 <code>defineOptions</code> 或 Options API <code>name</code> → 幂等跳过</li>
</ul>
<hr/>
<h2 data-id="heading-12">集成与最小可行示例（可复制）</h2>
<ol>
<li>注册插件（置于 <code>vue()</code> 之前）：</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>
<span class="hljs-keyword">import</span> { autoComponentName } <span class="hljs-keyword">from</span> <span class="hljs-string">'./build/plugins/vite-plugin-auto-component-name'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-title function_">autoComponentName</span>({
      <span class="hljs-attr">routerDir</span>: <span class="hljs-string">'src/router/modules'</span>,
      <span class="hljs-attr">routeConfigPath</span>: <span class="hljs-string">'src/config/index.ts'</span>,
      <span class="hljs-attr">onlyKeepAlive</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>,
    }),
    <span class="hljs-title function_">vue</span>(),
  ],
}
</code></pre>
<ol start="2">
<li>RouteConfig 与路由：</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/config/index.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">RouteConfig</span> = {
  <span class="hljs-title class_">UserList</span>: { <span class="hljs-attr">path</span>: <span class="hljs-string">'/user/list'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'UserList'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'用户列表'</span>, <span class="hljs-attr">i18nKey</span>: <span class="hljs-string">'userList'</span> },
}
</code></pre>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/router/modules/user.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">RouteConfig</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/config'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> [
  {
    <span class="hljs-attr">path</span>: <span class="hljs-title class_">RouteConfig</span>.<span class="hljs-property">UserList</span>.<span class="hljs-property">path</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">RouteConfig</span>.<span class="hljs-property">UserList</span>.<span class="hljs-property">name</span>,
    <span class="hljs-attr">meta</span>: { <span class="hljs-attr">keepAlive</span>: <span class="hljs-literal">true</span> },
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'@/views/user/list.vue'</span>),
  },
]
</code></pre>
<ol start="3">
<li>页面无需手写 <code>name</code>：</li>
</ol>
<pre><code class="hljs language-vue" lang="vue">&lt;script setup lang="ts"&gt;
// 业务代码...
&lt;/script&gt;
</code></pre>
<ol start="4">
<li>运行与验证：</li>
</ol>
<ul>
<li>控制台可见：
<ul>
<li>映射统计（路由总数/启用缓存/自动注入/冲突数）</li>
<li>注入成功日志：<code>Injected: src/views/user/list.vue =&gt; UserList</code></li>
</ul>
</li>
<li>DevTools 源码中可见注入的 <code>defineOptions</code> 与注释</li>
</ul>
<hr/>
<h2 data-id="heading-13">调试、验证与可观测性</h2>
<ul>
<li>日志：<code>debug: true</code> 输出扫描/命中/注入/缓存明细</li>
<li>SourceMap：<code>sourceMap: true</code> 便于在浏览器中溯源</li>
<li>转换检查：搭配 <code>vite-plugin-inspect</code> 可查看 transform 前后差异</li>
</ul>
<p>建议用例（Checklist）</p>
<ul>
<li>单页 keepAlive 命中/跳过（已有 name 与无 name 各 1）</li>
<li>多路由复用同组件 → 冲突告警</li>
<li>路由改名 → 注入名同步变化</li>
<li>HMR：仅路由/RouteConfig 变更触发重建，其他变更不影响</li>
</ul>
<hr/>
<h2 data-id="heading-14">复杂/边界场景</h2>
<ul>
<li>Options API 组件：已显式 <code>name</code>，跳过</li>
<li>无 <code>&lt;script setup&gt;</code>：跳过</li>
<li>非标准导入写法：需要扩展匹配规则后再纳入</li>
<li>多入口/多路由目录：可以通过多实例或增强 <code>routerDir</code> 扫描策略支持</li>
</ul>
<hr/>
<h2 data-id="heading-15">性能与工程实践</h2>
<ul>
<li>缓存
<ul>
<li>解析缓存：<code>mtime</code> 命中即复用</li>
<li>transform 缓存：<code>relativePath + codeHash</code> 键控</li>
</ul>
</li>
<li>失效策略
<ul>
<li>RouteConfig 变更 → 清空解析缓存并重建映射</li>
<li>路由模块变更 → 仅增量解析该文件</li>
</ul>
</li>
<li>工程建议
<ul>
<li>在 CI 构建压测中打开 <code>debug</code> 观察日志规模与命中率</li>
<li>通过 <code>rollup-plugin-visualizer</code> 检查注入对包体影响（理论上几乎为 0）</li>
</ul>
</li>
</ul>
<hr/>
<h2 data-id="heading-16">v1→v2 升级指引</h2>
<ul>
<li>新能力：RouteConfig 反向映射、增量解析、双层缓存、冲突检测、SourceMap</li>
<li>行为变更：默认仅处理 <code>keepAlive: true</code>；如需全量处理，设置 <code>onlyKeepAlive: false</code></li>
<li>升级步骤：替换插件文件 → 在 <code>plugins</code> 中传入新选项（如 <code>routeConfigPath</code>）</li>
</ul>
<hr/>
<h2 data-id="heading-17">总结与延伸</h2>
<p>把“正确但枯燥”的命名工作下沉到构建期，既提升 DX，又降低回归风险。相同的工程化思路还可延伸到：</p>
<ul>
<li>基于路由 meta 自动注入权限/埋点/Loading 逻辑</li>
<li>自动生成页面骨架屏或 SEO 元信息（SSG 场景）</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[新手入门 React 必备：电影榜单项目核心知识点全解析]]></title>    <link>https://juejin.cn/post/7584346983135461428</link>    <guid>https://juejin.cn/post/7584346983135461428</guid>    <pubDate>2025-12-17T02:54:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584346983135461428" data-draft-id="7584346983135313972" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="新手入门 React 必备：电影榜单项目核心知识点全解析"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-12-17T02:54:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="是你的小橘呀"/> <meta itemprop="url" content="https://juejin.cn/user/1989458366301708"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            新手入门 React 必备：电影榜单项目核心知识点全解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1989458366301708/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    是你的小橘呀
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:54:37.000Z" title="Wed Dec 17 2025 02:54:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">一、项目基础结构</h2>
<p>src</p>
<p>├── main.jsx         # 入口文件（渲染根组件）</p>
<p>├── index.css        # 全局样式（清除默认边距）</p>
<p>├── App.jsx          # 主组件（数据管理 + 页面骨架）</p>
<p>├── app.css          # 主组件样式</p>
<p>└── components/      # 子组件目录</p>
<p>├── MovieItem.jsx  # 电影项组件</p>
<p>└── MovieItem.css  # 电影项样式</p>
<h3 data-id="heading-1">核心文件作用</h3>
<ul>
<li><strong>入口文件</strong>：连接React与DOM，渲染整个应用</li>
<li><strong>全局样式</strong>：统一清除浏览器默认样式（<code>* { margin:0; padding:0 }</code>）</li>
<li><strong>组件拆分</strong>：主组件负责数据管理，子组件专注UI展示</li>
</ul>
<h2 data-id="heading-2">二、入口渲染机制（main.jsx）</h2>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom/client'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.jsx'</span>

<span class="hljs-comment">// React 18新特性：createRoot</span>
<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>)).<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>)
</code></pre>
<ul>
<li>
<p><strong>知识点</strong>：<code>createRoot</code>替代旧版<code>ReactDOM.render</code>，支持并发渲染</p>
</li>
<li>
<p><strong>作用</strong>：将<code>App</code>组件挂载到 HTML 中<code>id="root"</code>的 DOM 节点</p>
</li>
</ul>
<h2 data-id="heading-3">三、主组件核心逻辑（App.jsx）</h2>
<h3 data-id="heading-4">1. 状态管理</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-comment">// 定义电影列表状态，初始值为空数组</span>

<span class="hljs-keyword">const</span> [movieList, setMovieList] = <span class="hljs-title function_">useState</span>([])
</code></pre>
<ul>
<li>
<p><strong>关键点</strong>：<code>useState</code>是 React 状态钩子，<code>movieList</code>存储数据，<code>setMovieList</code>用于更新数据</p>
</li>
<li>
<p><strong>为什么初始为空数组</strong>：避免<code>map</code>遍历 undefined 报错</p>
</li>
</ul>
<h3 data-id="heading-5">2. 数据请求（副作用处理）</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-comment">// 发起API请求</span>
  <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://apis.netstart.cn/maoyan/index/movieOnInfoList'</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
      <span class="hljs-title function_">setMovieList</span>(data.<span class="hljs-property">movieList</span>) <span class="hljs-comment">// 更新状态</span>
    })
}, []) <span class="hljs-comment">// 空依赖数组：只在组件挂载时执行一次</span>
</code></pre>
<ul>
<li>
<p><strong>知识点</strong>：<code>useEffect</code>处理副作用（网络请求、定时器等）</p>
</li>
<li>
<p><strong>更新机制</strong>：调用<code>setMovieList</code>后，组件会重新渲染，UI 自动更新</p>
</li>
</ul>
<h3 data-id="heading-6">3. 列表渲染</h3>
<pre><code class="hljs language-jsx" lang="jsx">{

 movieList.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span> (

   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MovieItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{item}</span> /&gt;</span></span>

 ))

}
</code></pre>
<ul>
<li>
<p><strong>关键点</strong>：</p>
<ul>
<li>
<p>使用<code>map</code>遍历数组生成组件</p>
</li>
<li>
<p><code>key</code>属性必须唯一（用<code>item.id</code>避免重复）</p>
</li>
<li>
<p>通过<code>data</code>属性向子组件传递数据</p>
</li>
</ul>
</li>
</ul>
<h2 data-id="heading-7">四、子组件开发（MovieItem.jsx）</h2>
<h3 data-id="heading-8">1. Props 接收</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">MovieItem</span>(<span class="hljs-params">props</span>) {

 <span class="hljs-comment">// 接收父组件传递的电影数据</span>

 <span class="hljs-keyword">const</span> movie = props.<span class="hljs-property">data</span>;

}
</code></pre>
<ul>
<li><strong>知识点</strong>：<code>props</code>是父子组件通信的桥梁，只读不可修改</li>
</ul>
<h3 data-id="heading-9">2. 动态数据绑定</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 错误示例（硬编码）</span>

&lt;div className=<span class="hljs-string">"name"</span>&gt;疯狂动物城<span class="hljs-number">2</span>&lt;/div&gt;

<span class="hljs-comment">// 正确做法（动态绑定）</span>

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"name"</span>&gt;</span>{movie.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre>
<ul>
<li>
<p><strong>常用绑定场景</strong>：</p>
<ul>
<li>
<p>图片路径：<code>&lt;img src={movie.img} alt="" /&gt;</code></p>
</li>
<li>
<p>评分：<code>&lt;div className="score"&gt;评分：{movie.score}&lt;/div&gt;</code></p>
</li>
<li>
<p>排名：<code>&lt;div className="index"&gt;No.{movie.rank}&lt;/div&gt;</code></p>
</li>
</ul>
</li>
</ul>
<h2 data-id="heading-10">五、样式实现技巧</h2>
<h3 data-id="heading-11">1. Flex 布局应用</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 横向排列元素 */</span>
<span class="hljs-selector-class">.info</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">justify-content</span>: space-between; <span class="hljs-comment">/* 两端对齐 */</span>
  <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/* 垂直居中 */</span>
}

<span class="hljs-comment">/* 纵向排列元素 */</span>
<span class="hljs-selector-class">.message</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">flex-direction</span>: column; <span class="hljs-comment">/* 垂直方向排列 */</span>
}
</code></pre>
<h3 data-id="heading-12">2. 背景图处理</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.banner</span> {
  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">'图片地址'</span>);
  <span class="hljs-attribute">background-position</span>: center; <span class="hljs-comment">/* 居中显示 */</span>
  <span class="hljs-attribute">background-size</span>: cover; <span class="hljs-comment">/* 覆盖容器且保持比例 */</span>
}
</code></pre>
<h3 data-id="heading-13">3. 文本溢出处理</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.desc</span> {
  <span class="hljs-attribute">overflow</span>: hidden;
  <span class="hljs-attribute">text-overflow</span>: ellipsis; <span class="hljs-comment">/* 显示省略号 */</span>
  <span class="hljs-attribute">display</span>: -webkit-box;
  -webkit-line-clamp: <span class="hljs-number">2</span>; <span class="hljs-comment">/* 最多显示2行 */</span>
  -webkit-box-orient: vertical;
}
</code></pre>
<h3 data-id="heading-14">4. 居中定位技巧</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-class">.title-bar</span> {
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>); <span class="hljs-comment">/* 精准居中 */</span>
}
</code></pre>
<h2 data-id="heading-15">六、常见问题与优化</h2>
<h3 data-id="heading-16">1. 类名拼写错误</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 错误：itme（少了一个m） */</span>
<span class="hljs-selector-class">.itme</span> { ... }

<span class="hljs-comment">/* 正确：item */</span>
<span class="hljs-selector-class">.item</span> { ... }
</code></pre>
<h3 data-id="heading-17">2. 加载状态优化</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-comment">// 添加加载状态</span>
<span class="hljs-keyword">const</span> [isLoading, setIsLoading] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// 请求时</span>
<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">setIsLoading</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 开始加载</span>
  <span class="hljs-title function_">fetch</span>(...)
    .<span class="hljs-title function_">then</span>(...)
    .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setIsLoading</span>(<span class="hljs-literal">false</span>)); <span class="hljs-comment">// 加载完成</span>
}, [])

<span class="hljs-comment">// 渲染时</span>
{isLoading ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>加载中...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> : <span class="hljs-comment">/* 列表内容 */</span>}
</code></pre>
<h3 data-id="heading-18">3. 错误处理</h3>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-title function_">fetch</span>(...)
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'请求失败：'</span>, err);
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">'加载电影数据失败'</span>);
  })
</code></pre>
<p>通过这些知识点，可以清晰理解 React 项目从数据获取到 UI 渲染的完整流程，以及如何通过组件化和状态管理构建交互界面。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Node.js Buffer 和 Stream]]></title>    <link>https://juejin.cn/post/7584358227611271210</link>    <guid>https://juejin.cn/post/7584358227611271210</guid>    <pubDate>2025-12-17T02:58:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584358227611271210" data-draft-id="7584356212801257513" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Node.js Buffer 和 Stream"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2025-12-17T02:58:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="梨子同志"/> <meta itemprop="url" content="https://juejin.cn/user/2084329779627965"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Node.js Buffer 和 Stream
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2084329779627965/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    梨子同志
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:58:00.000Z" title="Wed Dec 17 2025 02:58:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    7
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读25分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>参考来源：</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fnodejs.org%2F" target="_blank" title="https://nodejs.org/" ref="nofollow noopener noreferrer">Node.js 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3schools.com%2Fnodejs%2Fdefault.asp" target="_blank" title="https://www.w3schools.com/nodejs/default.asp" ref="nofollow noopener noreferrer">W3Schools Node.js 教程</a></li>
</ul>
</blockquote>
<h2 data-id="heading-0">目录</h2>
<ul>
<li><a href="#buffer%E7%BC%93%E5%86%B2%E5%8C%BA" title="#buffer%E7%BC%93%E5%86%B2%E5%8C%BA">Buffer（缓冲区）</a>
<ul>
<li><a href="#buffer-%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8" title="#buffer-%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8">Buffer 的实际作用</a></li>
<li><a href="#buffer-%E6%A6%82%E5%BF%B5" title="#buffer-%E6%A6%82%E5%BF%B5">Buffer 概念</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA-buffer" title="#%E5%88%9B%E5%BB%BA-buffer">创建 Buffer</a></li>
<li><a href="#buffer-%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E5%8F%8A%E7%BC%96%E7%A0%81" title="#buffer-%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E5%8F%8A%E7%BC%96%E7%A0%81">Buffer 与字符串转换及编码</a></li>
<li><a href="#buffer-%E6%93%8D%E4%BD%9C" title="#buffer-%E6%93%8D%E4%BD%9C">Buffer 操作</a></li>
<li><a href="#buffer-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" title="#buffer-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">Buffer 性能优化</a></li>
</ul>
</li>
<li><a href="#%E6%B5%81stream%E5%9F%BA%E7%A1%80" title="#%E6%B5%81stream%E5%9F%BA%E7%A1%80">流（Stream）基础</a>
<ul>
<li><a href="#%E6%B5%81%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8" title="#%E6%B5%81%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8">流的实际作用</a></li>
<li><a href="#%E6%B5%81%E6%A6%82%E5%BF%B5" title="#%E6%B5%81%E6%A6%82%E5%BF%B5">流概念</a></li>
<li><a href="#%E5%8F%AF%E8%AF%BB%E6%B5%81readable" title="#%E5%8F%AF%E8%AF%BB%E6%B5%81readable">可读流（Readable）</a></li>
<li><a href="#%E5%8F%AF%E5%86%99%E6%B5%81writable" title="#%E5%8F%AF%E5%86%99%E6%B5%81writable">可写流（Writable）</a></li>
<li><a href="#%E6%B5%81%E7%AE%A1%E9%81%93pipe" title="#%E6%B5%81%E7%AE%A1%E9%81%93pipe">流管道（pipe）</a></li>
<li><a href="#%E6%B5%81%E4%BA%8B%E4%BB%B6" title="#%E6%B5%81%E4%BA%8B%E4%BB%B6">流事件</a></li>
<li><a href="#%E6%B5%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86" title="#%E6%B5%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">流错误处理</a></li>
</ul>
</li>
<li><a href="#%E6%B5%81stream%E9%AB%98%E7%BA%A7" title="#%E6%B5%81stream%E9%AB%98%E7%BA%A7">流（Stream）高级</a>
<ul>
<li><a href="#%E5%8F%8C%E5%B7%A5%E6%B5%81duplex" title="#%E5%8F%8C%E5%B7%A5%E6%B5%81duplex">双工流（Duplex）</a></li>
<li><a href="#%E8%BD%AC%E6%8D%A2%E6%B5%81transform" title="#%E8%BD%AC%E6%8D%A2%E6%B5%81transform">转换流（Transform）</a></li>
<li><a href="#%E6%B5%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" title="#%E6%B5%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">流性能优化</a></li>
</ul>
</li>
<li><a href="#buffer-%E4%B8%8E-stream-%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8F%8A%E9%80%89%E6%8B%A9" title="#buffer-%E4%B8%8E-stream-%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8F%8A%E9%80%89%E6%8B%A9">Buffer 与 Stream 的关系及选择</a></li>
</ul>
<hr/>
<h2 data-id="heading-1">Buffer（缓冲区）</h2>
<h3 data-id="heading-2">Buffer 的实际作用</h3>
<p>在深入理解 Buffer 的语法之前，我们先来看看 Buffer 在实际开发中解决了什么问题。</p>
<h4 data-id="heading-3">场景一：处理图片文件</h4>
<p><strong>问题：没有 Buffer 的情况</strong></p>
<p>假设你需要读取一个图片文件并上传到服务器。JavaScript 的字符串只能处理文本数据，无法直接处理二进制数据（如图片、视频、音频等）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 错误示例：尝试用字符串读取图片</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 如果使用文本模式读取图片，会导致数据损坏</span>
<span class="hljs-keyword">const</span> imageData = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'photo.jpg'</span>, <span class="hljs-string">'utf8'</span>); <span class="hljs-comment">// 错误！图片会被损坏</span>
<span class="hljs-comment">// 图片文件包含二进制数据，不能按文本处理</span>
</code></pre>
<p><strong>解决方案：使用 Buffer</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ✅ 正确示例：使用 Buffer 处理图片</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// Buffer 可以安全地处理二进制数据</span>
<span class="hljs-keyword">const</span> imageBuffer = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'photo.jpg'</span>); <span class="hljs-comment">// 返回 Buffer 对象</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imageBuffer); <span class="hljs-comment">// &lt;Buffer ff d8 ff e0 00 10 4a 46 49 46 ...&gt;</span>

<span class="hljs-comment">// 可以将 Buffer 转换为 Base64 用于传输</span>
<span class="hljs-keyword">const</span> base64Image = imageBuffer.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'base64'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Base64:'</span>, base64Image);

<span class="hljs-comment">// 或者直接写入文件</span>
fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">'copy.jpg'</span>, imageBuffer);
</code></pre>
<h4 data-id="heading-4">场景二：网络数据传输</h4>
<p><strong>问题：没有 Buffer 的瓶颈</strong></p>
<p>在网络通信中，数据通常以字节流的形式传输。如果只能使用字符串：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 问题示例：字符串处理二进制数据的问题</span>
<span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);

<span class="hljs-keyword">const</span> server = net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> {
  socket.<span class="hljs-title function_">setEncoding</span>(<span class="hljs-string">'utf8'</span>); <span class="hljs-comment">// 只能处理文本</span>
  
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-comment">// 问题1：如果接收到二进制数据（如图片），会被错误解析</span>
    <span class="hljs-comment">// 问题2：字符串操作（如拼接）会创建新对象，内存占用大</span>
    <span class="hljs-comment">// 问题3：无法精确控制字节级别的操作</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 可能显示乱码或数据损坏</span>
  });
});
</code></pre>
<p><strong>解决方案：使用 Buffer</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ✅ 正确示例：使用 Buffer 处理网络数据</span>
<span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);

<span class="hljs-keyword">const</span> server = net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> {
  <span class="hljs-comment">// 不设置编码，默认接收 Buffer</span>
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">buffer</span>) =&gt;</span> {
    <span class="hljs-comment">// Buffer 可以精确处理每个字节</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'接收到'</span>, buffer.<span class="hljs-property">length</span>, <span class="hljs-string">'字节'</span>);
    
    <span class="hljs-comment">// 可以检查数据头（如检查文件类型）</span>
    <span class="hljs-keyword">if</span> (buffer[<span class="hljs-number">0</span>] === <span class="hljs-number">0xFF</span> &amp;&amp; buffer[<span class="hljs-number">1</span>] === <span class="hljs-number">0xD8</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'这是一个 JPEG 图片'</span>);
    }
    
    <span class="hljs-comment">// 可以精确提取特定字节</span>
    <span class="hljs-keyword">const</span> header = buffer.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 提取前4个字节</span>
    
    <span class="hljs-comment">// 可以高效地拼接数据（不会创建大量中间字符串）</span>
    <span class="hljs-comment">// Buffer.concat() 比字符串拼接效率高得多</span>
  });
});
</code></pre>
<h4 data-id="heading-5">场景三：文件操作性能问题</h4>
<p><strong>问题：大文件处理的内存瓶颈</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 问题示例：处理大文件时的内存问题</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 读取整个大文件到内存（字符串）</span>
<span class="hljs-keyword">const</span> largeFile = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'large-file.txt'</span>, <span class="hljs-string">'utf8'</span>);
<span class="hljs-comment">// 问题：</span>
<span class="hljs-comment">// 1. 整个文件被加载到内存，占用大量内存</span>
<span class="hljs-comment">// 2. 字符串操作（如 replace）会创建新字符串，内存翻倍</span>
<span class="hljs-comment">// 3. 对于 1GB 的文件，可能需要 2GB+ 的内存</span>

<span class="hljs-comment">// 字符串替换会创建新字符串</span>
<span class="hljs-keyword">const</span> modified = largeFile.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/old/g</span>, <span class="hljs-string">'new'</span>); <span class="hljs-comment">// 又占用一份内存</span>
</code></pre>
<p><strong>解决方案：使用 Buffer + Stream</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ✅ 正确示例：使用 Buffer 和 Stream 高效处理大文件</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-comment">// 使用流式处理，不需要将整个文件加载到内存</span>
<span class="hljs-keyword">const</span> transformStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({
  <span class="hljs-title function_">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// chunk 是 Buffer，可以高效处理</span>
    <span class="hljs-comment">// 只处理当前这一块数据，内存占用小</span>
    <span class="hljs-keyword">const</span> modified = chunk.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/old/g</span>, <span class="hljs-string">'new'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(modified));
    <span class="hljs-title function_">callback</span>();
  }
});

<span class="hljs-comment">// 流式处理，内存占用恒定（只占用缓冲区大小）</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'large-file.txt'</span>)
  .<span class="hljs-title function_">pipe</span>(transformStream)
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt'</span>));

<span class="hljs-comment">// 即使处理 10GB 的文件，内存占用也只有几 MB</span>
</code></pre>
<h4 data-id="heading-6">场景四：数据编码转换</h4>
<p><strong>问题：不同编码格式的处理</strong></p>
<p>在实际开发中，经常需要在不同编码格式之间转换（如 UTF-8、Base64、Hex 等）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 问题示例：字符串无法直接处理编码转换</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-string">'Hello 世界'</span>;

<span class="hljs-comment">// JavaScript 字符串内部使用 UTF-16，无法直接转换为其他编码</span>
<span class="hljs-comment">// 无法直接获取字节级别的数据</span>
</code></pre>
<p><strong>解决方案：使用 Buffer 进行编码转换</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ✅ 正确示例：使用 Buffer 进行编码转换</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-string">'Hello 世界'</span>;

<span class="hljs-comment">// 1. 字符串转 Buffer（UTF-8 编码）</span>
<span class="hljs-keyword">const</span> buffer = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(data, <span class="hljs-string">'utf8'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buffer); <span class="hljs-comment">// &lt;Buffer 48 65 6c 6c 6f 20 e4 b8 96 e7 95 8c&gt;</span>

<span class="hljs-comment">// 2. Buffer 转 Base64（常用于数据传输）</span>
<span class="hljs-keyword">const</span> base64 = buffer.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'base64'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(base64); <span class="hljs-comment">// 'SGVsbG8g5LiW5L2T'</span>

<span class="hljs-comment">// 3. Buffer 转 Hex（常用于调试）</span>
<span class="hljs-keyword">const</span> hex = buffer.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'hex'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hex); <span class="hljs-comment">// '48656c6c6f20e4b896e7958c'</span>

<span class="hljs-comment">// 4. 从 Base64 解码</span>
<span class="hljs-keyword">const</span> decoded = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(base64, <span class="hljs-string">'base64'</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf8'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(decoded); <span class="hljs-comment">// 'Hello 世界'</span>
</code></pre>
<h4 data-id="heading-7">总结：Buffer 的核心价值</h4>
<ol>
<li><strong>处理二进制数据</strong>：图片、视频、音频等非文本数据</li>
<li><strong>精确控制字节</strong>：网络协议、文件格式解析等需要字节级操作</li>
<li><strong>内存效率</strong>：避免字符串操作带来的内存浪费</li>
<li><strong>编码转换</strong>：在不同编码格式之间高效转换</li>
<li><strong>性能优化</strong>：配合 Stream 实现高效的大数据处理</li>
</ol>
<h3 data-id="heading-8">Buffer 概念</h3>
<p>Buffer 是 Node.js 中用于处理二进制数据的类，类似于整数数组，但对应于 V8 堆外部的固定大小的原始内存分配。Buffer 的大小在创建时确定，且无法调整。</p>
<p><strong>Buffer 的特点：</strong></p>
<ul>
<li>Buffer 是固定大小的内存分配</li>
<li>Buffer 中的数据是二进制格式</li>
<li>Buffer 实例是 JavaScript 的 Uint8Array 实例</li>
<li>Buffer 的大小在创建时确定，无法改变</li>
</ul>
<blockquote>
<p><strong>提示</strong>：关于 Buffer 的实际应用场景和解决的问题，请参考 <a href="#buffer-%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8" title="#buffer-%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8">Buffer 的实际作用</a> 章节。</p>
</blockquote>
<h3 data-id="heading-9">创建 Buffer</h3>
<p>在 Node.js 中，有几种方式可以创建 Buffer：</p>
<h4 data-id="heading-10">1. Buffer.from()</h4>
<p><code>Buffer.from()</code> 是最推荐的方式，可以从字符串、数组或其他 Buffer 创建新的 Buffer。</p>
<p><strong>语法：</strong> <code>Buffer.from(source, encoding)</code> 或 <code>Buffer.from(array)</code> 或 <code>Buffer.from(buffer)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>source</code>: 源数据（字符串、数组或 Buffer）</li>
<li><code>encoding</code>（可选）: 字符编码，当 source 是字符串时使用，默认为 'utf8'</li>
</ul>
<p><strong>返回值：</strong> 返回一个新的 Buffer。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 从字符串创建 Buffer（默认使用 utf8 编码）</span>
<span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello World'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf1); <span class="hljs-comment">// &lt;Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64&gt;</span>

<span class="hljs-comment">// 从字符串创建 Buffer（指定编码）</span>
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello World'</span>, <span class="hljs-string">'utf8'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf2);

<span class="hljs-comment">// 从数组创建 Buffer</span>
<span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>([<span class="hljs-number">0x48</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x6c</span>, <span class="hljs-number">0x6f</span>]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf3); <span class="hljs-comment">// &lt;Buffer 48 65 6c 6c 6f&gt;</span>

<span class="hljs-comment">// 从另一个 Buffer 创建</span>
<span class="hljs-keyword">const</span> buf4 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(buf1);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf4);
</code></pre>
<h4 data-id="heading-11">2. Buffer.alloc()</h4>
<p><code>Buffer.alloc()</code> 创建一个指定大小的 Buffer，并用零填充。这是最安全的方式，因为内存会被初始化为零。</p>
<p><strong>语法：</strong> <code>Buffer.alloc(size, fill, encoding)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>size</code>: Buffer 的大小（字节数）</li>
<li><code>fill</code>（可选）: 填充值，默认为 0</li>
<li><code>encoding</code>（可选）: 当 fill 是字符串时的编码，默认为 'utf8'</li>
</ul>
<p><strong>返回值：</strong> 返回一个新的 Buffer。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建一个大小为 10 的 Buffer，用零填充</span>
<span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf); <span class="hljs-comment">// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span>

<span class="hljs-comment">// 创建一个大小为 10 的 Buffer，用指定值填充</span>
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">10</span>, <span class="hljs-string">'a'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf2); <span class="hljs-comment">// &lt;Buffer 61 61 61 61 61 61 61 61 61 61&gt;</span>
</code></pre>
<h4 data-id="heading-12">3. Buffer.allocUnsafe()</h4>
<p><code>Buffer.allocUnsafe()</code> 创建一个指定大小的 Buffer，但<strong>不会初始化内存</strong>。这意味着内存可能包含敏感数据。虽然性能更好，但需要谨慎使用。</p>
<p><strong>语法：</strong> <code>Buffer.allocUnsafe(size)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>size</code>: Buffer 的大小（字节数）</li>
</ul>
<p><strong>返回值：</strong> 返回一个新的 Buffer（内存未初始化）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建一个大小为 10 的 Buffer，内存未初始化</span>
<span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">10</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf); <span class="hljs-comment">// 内容可能是随机的旧数据</span>

<span class="hljs-comment">// 如果需要安全，创建后应该填充</span>
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">10</span>);
buf2.<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 手动填充为零</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf2);
</code></pre>
<p><strong>性能对比：</strong></p>
<ul>
<li><code>Buffer.alloc()</code>: 最安全，性能稍慢（需要初始化内存）</li>
<li><code>Buffer.allocUnsafe()</code>: 性能最好，但不安全（内存未初始化）</li>
<li><code>Buffer.allocUnsafe() + fill(0)</code>: 性能与 <code>Buffer.alloc()</code> 相近，但代码更复杂</li>
<li><code>Buffer.from()</code>: 根据源数据创建，性能取决于源数据大小</li>
</ul>
<blockquote>
<p><strong>注意</strong>：<code>Buffer.allocUnsafe() + fill(0)</code> 理论上可能比 <code>Buffer.alloc()</code> 稍快，但性能差异很小。大多数情况下推荐使用 <code>Buffer.alloc()</code>，因为它更安全、更简洁。</p>
</blockquote>
<h3 data-id="heading-13">Buffer 与字符串转换及编码</h3>
<p>Buffer 和字符串之间的转换是 Buffer 的核心功能之一。Node.js 的 Buffer 支持多种字符编码格式。</p>
<h4 data-id="heading-14">字符串转 Buffer</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 方法 1: Buffer.from()（推荐）</span>
<span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello World'</span>, <span class="hljs-string">'utf8'</span>);

<span class="hljs-comment">// 方法 2: Buffer.alloc() + write()</span>
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">11</span>);
buf2.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Hello World'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'utf8'</span>);

<span class="hljs-comment">// 方法 3: 使用 Buffer.allocUnsafe()（不推荐，除非性能要求高）</span>
<span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">11</span>);
buf3.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Hello World'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'utf8'</span>);
</code></pre>
<h4 data-id="heading-15">Buffer 转字符串</h4>
<p><strong>语法：</strong> <code>buf.toString(encoding, start, end)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>encoding</code>（可选）: 字符编码，默认为 'utf8'</li>
<li><code>start</code>（可选）: 开始位置，默认为 0</li>
<li><code>end</code>（可选）: 结束位置（不包含），默认为 <code>buf.length</code></li>
</ul>
<p><strong>返回值：</strong> 返回转换后的字符串。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello World'</span>, <span class="hljs-string">'utf8'</span>);

<span class="hljs-comment">// 方法 1: toString()（推荐）</span>
<span class="hljs-keyword">const</span> str1 = buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf8'</span>);

<span class="hljs-comment">// 方法 2: toString() 默认使用 utf8</span>
<span class="hljs-keyword">const</span> str2 = buf.<span class="hljs-title function_">toString</span>();

<span class="hljs-comment">// 方法 3: 指定范围</span>
<span class="hljs-keyword">const</span> str3 = buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf8'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 'Hello'</span>
</code></pre>
<h4 data-id="heading-16">支持的编码格式</h4>
<p>Node.js Buffer 支持多种字符编码，常用编码如下：</p>
<p><strong>常用编码：</strong></p>
<ul>
<li><strong>utf8</strong>（默认）：支持所有 Unicode 字符</li>
<li><strong>base64</strong>：常用于编码二进制数据以便在文本协议中传输</li>
<li><strong>hex</strong>：十六进制编码，常用于调试</li>
<li><strong>ascii</strong>：仅支持 ASCII 字符（0-127）</li>
</ul>
<p><strong>其他编码：</strong> <code>latin1</code> / <code>binary</code>、<code>ucs2</code> / <code>utf16le</code>、<code>utf16be</code></p>
<h4 data-id="heading-17">编码转换示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'Hello World'</span>;

<span class="hljs-comment">// UTF-8（默认）</span>
<span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(str, <span class="hljs-string">'utf8'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf8'</span>)); <span class="hljs-comment">// 'Hello World'</span>

<span class="hljs-comment">// Base64 编码/解码</span>
<span class="hljs-keyword">const</span> base64 = buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'base64'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(base64); <span class="hljs-comment">// 'SGVsbG8gV29ybGQ='</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(base64, <span class="hljs-string">'base64'</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf8'</span>)); <span class="hljs-comment">// 'Hello World'</span>

<span class="hljs-comment">// Hex 编码/解码</span>
<span class="hljs-keyword">const</span> hex = buf.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'hex'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(hex); <span class="hljs-comment">// '48656c6c6f20576f726c64'</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(hex, <span class="hljs-string">'hex'</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">'utf8'</span>)); <span class="hljs-comment">// 'Hello World'</span>

<span class="hljs-comment">// ASCII（仅支持 ASCII 字符）</span>
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello'</span>, <span class="hljs-string">'ascii'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf2.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'ascii'</span>)); <span class="hljs-comment">// 'Hello'</span>
</code></pre>
<h3 data-id="heading-18">Buffer 操作</h3>
<p>Buffer 提供了多种操作方法，用于处理二进制数据。字符串转换相关的方法在上面已经详细说明。</p>
<h4 data-id="heading-19">slice()</h4>
<p>创建一个新的 Buffer，引用相同的内存，但偏移和裁剪到指定的索引范围。</p>
<p><strong>语法：</strong> <code>buf.slice(start, end)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>start</code>（可选）: 开始位置，默认为 0</li>
<li><code>end</code>（可选）: 结束位置（不包含），默认为 <code>buf.length</code></li>
</ul>
<p><strong>返回值：</strong> 返回一个新的 Buffer，与原 Buffer 共享内存。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello World'</span>);

<span class="hljs-comment">// 创建切片（从索引 0 到 5）</span>
<span class="hljs-keyword">const</span> slice1 = buf.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slice1.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'Hello'</span>

<span class="hljs-comment">// 创建切片（从索引 6 到结束）</span>
<span class="hljs-keyword">const</span> slice2 = buf.<span class="hljs-title function_">slice</span>(<span class="hljs-number">6</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(slice2.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'World'</span>

<span class="hljs-comment">// 注意：slice 是浅拷贝，修改会影响原 Buffer</span>
<span class="hljs-keyword">const</span> slice3 = buf.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
slice3[<span class="hljs-number">0</span>] = <span class="hljs-number">0x4a</span>; <span class="hljs-comment">// 修改第一个字节</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'Jello World'（原 Buffer 也被修改）</span>
</code></pre>
<h4 data-id="heading-20">concat()</h4>
<p>将多个 Buffer 实例连接成一个新的 Buffer。</p>
<p><strong>语法：</strong> <code>Buffer.concat(list, totalLength)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>list</code>: Buffer 数组，要连接的 Buffer 列表</li>
<li><code>totalLength</code>（可选）: 连接后 Buffer 的总长度</li>
</ul>
<p><strong>返回值：</strong> 返回一个新的 Buffer，包含所有连接的 Buffer。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello'</span>);
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">' '</span>);
<span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'World'</span>);

<span class="hljs-comment">// 连接多个 Buffer</span>
<span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([buf1, buf2, buf3]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'Hello World'</span>

<span class="hljs-comment">// 可以指定总长度（可选）</span>
<span class="hljs-keyword">const</span> buf4 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([buf1, buf2, buf3], <span class="hljs-number">11</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf4.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'Hello World'</span>
</code></pre>
<h4 data-id="heading-21">copy()</h4>
<p>将 Buffer 的数据复制到另一个 Buffer 中。</p>
<p><strong>语法：</strong> <code>buf.copy(target, targetStart, sourceStart, sourceEnd)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>target</code>: 目标 Buffer，要复制到的 Buffer</li>
<li><code>targetStart</code>（可选）: 目标 Buffer 的起始位置，默认为 0</li>
<li><code>sourceStart</code>（可选）: 源 Buffer 的起始位置，默认为 0</li>
<li><code>sourceEnd</code>（可选）: 源 Buffer 的结束位置（不包含），默认为 <code>buf.length</code></li>
</ul>
<p><strong>返回值：</strong> 返回复制的字节数。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello World'</span>);
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">5</span>);

<span class="hljs-comment">// 将 buf1 的前 5 个字节复制到 buf2</span>
buf1.<span class="hljs-title function_">copy</span>(buf2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf2.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'Hello'</span>

<span class="hljs-comment">// 从 buf1 的索引 6 复制到 11，到 buf3 的索引 0</span>
<span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">5</span>);
buf1.<span class="hljs-title function_">copy</span>(buf3, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">11</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf3.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'World'</span>
</code></pre>
<h4 data-id="heading-22">write()</h4>
<p>将字符串写入 Buffer，返回写入的字节数。</p>
<p><strong>语法：</strong> <code>buf.write(string, offset, length, encoding)</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>string</code>: 要写入的字符串</li>
<li><code>offset</code>（可选）: 开始写入的位置，默认为 0</li>
<li><code>length</code>（可选）: 要写入的最大字节数，默认为 <code>buf.length - offset</code></li>
<li><code>encoding</code>（可选）: 字符编码，默认为 'utf8'</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">11</span>);

<span class="hljs-comment">// 从索引 0 开始写入</span>
<span class="hljs-keyword">const</span> bytesWritten = buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Hello World'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'utf8'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bytesWritten); <span class="hljs-comment">// 11（写入的字节数）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'Hello World'</span>

<span class="hljs-comment">// 从指定位置开始写入</span>
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">20</span>);
buf2.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Hello'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'utf8'</span>);
buf2.<span class="hljs-title function_">write</span>(<span class="hljs-string">'World'</span>, <span class="hljs-number">6</span>, <span class="hljs-string">'utf8'</span>); <span class="hljs-comment">// 从索引 6 开始写入</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf2.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'Hello World'</span>

<span class="hljs-comment">// 限制写入长度</span>
<span class="hljs-keyword">const</span> buf3 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">5</span>);
buf3.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Hello World'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-string">'utf8'</span>); <span class="hljs-comment">// 只写入前 5 个字节</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf3.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'Hello'</span>
</code></pre>
<p><strong>返回值：</strong> 返回实际写入的字节数。如果 Buffer 空间不足，可能小于字符串的字节数。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">5</span>);
<span class="hljs-keyword">const</span> written = buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Hello World'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'utf8'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(written); <span class="hljs-comment">// 5（只写入了 5 个字节）</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(buf.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'Hello'</span>
</code></pre>
<h3 data-id="heading-23">Buffer 性能优化</h3>
<h4 data-id="heading-24">1. 使用 Buffer.allocUnsafe() 时要小心</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 不好的做法：直接使用 allocUnsafe 而不填充。可能包含敏感数据</span>
<span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">allocUnsafe</span>(<span class="hljs-number">1024</span>);

<span class="hljs-comment">// 好的做法：使用 alloc（安全且性能足够好）</span>
<span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">1024</span>);
</code></pre>
<h4 data-id="heading-25">2. 复用 Buffer 实例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 不好的做法：频繁创建新 Buffer</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(data);
  <span class="hljs-comment">// 处理...</span>
}

<span class="hljs-comment">// 好的做法：复用 Buffer</span>
<span class="hljs-keyword">const</span> reusableBuf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">1024</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processData</span>(<span class="hljs-params">data</span>) {
  reusableBuf.<span class="hljs-title function_">write</span>(data, <span class="hljs-number">0</span>, <span class="hljs-string">'utf8'</span>);
  <span class="hljs-comment">// 处理...</span>
}
</code></pre>
<h4 data-id="heading-26">3. 使用 Buffer.concat() 而不是字符串拼接</h4>
<p>字符串拼接会创建多个中间字符串对象，导致内存浪费和性能下降。<code>Buffer.concat()</code> 直接操作 Buffer，一次性合并，更高效。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 不好的做法：字符串拼接后转 Buffer</span>
<span class="hljs-comment">// 问题：每次 += 操作可能创建新字符串，内存占用大</span>
<span class="hljs-keyword">let</span> result = <span class="hljs-string">''</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
  result += <span class="hljs-string">'data'</span>;
}
<span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(result);

<span class="hljs-comment">// 好的做法：使用 Buffer.concat()</span>
<span class="hljs-comment">// 优势：直接操作 Buffer，避免字符串中间对象，性能更好</span>
<span class="hljs-keyword">const</span> buffers = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
  buffers.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'data'</span>));
}
<span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>(buffers);
</code></pre>
<h4 data-id="heading-27">4. 避免不必要的 Buffer 复制</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 不好的做法：不必要的复制</span>
<span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello'</span>);
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(buf1); <span class="hljs-comment">// 创建了副本</span>

<span class="hljs-comment">// 好的做法：直接使用或使用 slice（如果需要共享内存）</span>
<span class="hljs-keyword">const</span> buf1 = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Hello'</span>);
<span class="hljs-keyword">const</span> buf2 = buf1.<span class="hljs-title function_">slice</span>(); <span class="hljs-comment">// 共享内存，性能更好</span>
</code></pre>
<h4 data-id="heading-28">5. 预分配 Buffer 大小</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 不好的做法：动态增长</span>
<span class="hljs-keyword">let</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([buf, <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'data'</span>)]);
}

<span class="hljs-comment">// 好的做法：预分配大小</span>
<span class="hljs-keyword">const</span> buf = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">alloc</span>(<span class="hljs-number">400</span>); <span class="hljs-comment">// 预分配足够的大小</span>
<span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
  offset += buf.<span class="hljs-title function_">write</span>(<span class="hljs-string">'data'</span>, offset);
}
</code></pre>
<hr/>
<h2 data-id="heading-29">流（Stream）基础</h2>
<h3 data-id="heading-30">流的实际作用</h3>
<p>在了解流的语法之前，我们先来看看 Stream 在实际开发中解决了什么问题。</p>
<h4 data-id="heading-31">场景一：处理大文件的内存问题</h4>
<p><strong>问题：没有 Stream 的情况</strong></p>
<p>当需要处理大文件时，如果一次性将整个文件加载到内存，会导致严重的内存问题。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 错误示例：一次性读取大文件</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-comment">// 问题1：内存占用巨大</span>
<span class="hljs-comment">// 假设有一个 2GB 的视频文件</span>
<span class="hljs-keyword">const</span> videoData = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'large-video.mp4'</span>); <span class="hljs-comment">// 将整个 2GB 文件加载到内存</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内存占用:'</span>, videoData.<span class="hljs-property">length</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>, <span class="hljs-string">'MB'</span>); <span class="hljs-comment">// 约 2000MB</span>

<span class="hljs-comment">// 问题2：响应时间慢</span>
<span class="hljs-comment">// 用户需要等待整个文件读取完成后才能开始下载</span>
http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'large-video.mp4'</span>); <span class="hljs-comment">// 阻塞，等待读取完成</span>
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'video/mp4'</span> });
  res.<span class="hljs-title function_">end</span>(data); <span class="hljs-comment">// 用户等待很久才能看到响应</span>
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);

<span class="hljs-comment">// 问题3：服务器可能崩溃</span>
<span class="hljs-comment">// 如果有多个用户同时请求，内存会迅速耗尽</span>
<span class="hljs-comment">// 10 个用户 = 20GB 内存占用！</span>
</code></pre>
<p><strong>解决方案：使用 Stream</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ✅ 正确示例：使用 Stream 流式处理</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);

<span class="hljs-comment">// 内存占用恒定（只占用缓冲区大小，通常几 MB）</span>
http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'large-video.mp4'</span>);
  
  res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'video/mp4'</span> });
  
  <span class="hljs-comment">// 流式传输：边读边写，立即开始响应</span>
  readStream.<span class="hljs-title function_">pipe</span>(res);
  
  <span class="hljs-comment">// 内存占用：无论文件多大，都只有缓冲区大小（如 64KB）</span>
  <span class="hljs-comment">// 10 个用户 = 640KB 内存占用（而不是 20GB！）</span>
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);

<span class="hljs-comment">// 优势：</span>
<span class="hljs-comment">// 1. 内存占用恒定，不受文件大小影响</span>
<span class="hljs-comment">// 2. 响应速度快，用户可以立即开始下载</span>
<span class="hljs-comment">// 3. 可以处理任意大小的文件</span>
</code></pre>
<h4 data-id="heading-32">场景二：实时数据处理</h4>
<p><strong>问题：没有 Stream 的延迟问题</strong></p>
<p>在某些场景下，需要实时处理数据，而不是等待所有数据就绪。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 问题示例：等待所有数据就绪</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 假设需要处理一个很大的日志文件</span>
<span class="hljs-keyword">const</span> logData = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'access.log'</span>); <span class="hljs-comment">// 等待整个文件读取完成</span>
<span class="hljs-keyword">const</span> lines = logData.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n'</span>);

<span class="hljs-comment">// 问题：</span>
<span class="hljs-comment">// 1. 必须等待整个文件读取完成才能开始处理</span>
<span class="hljs-comment">// 2. 如果文件很大，用户需要等待很长时间</span>
<span class="hljs-comment">// 3. 无法实时看到处理进度</span>

<span class="hljs-comment">// 处理每一行</span>
lines.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">line, index</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'ERROR'</span>)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">${index}</span> 行发现错误:`</span>, line);
  }
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'处理完成'</span>); <span class="hljs-comment">// 用户需要等待很久才能看到这个</span>
</code></pre>
<p><strong>解决方案：使用 Stream 实时处理</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ✅ 正确示例：使用 Stream 实时处理</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">'readline'</span>);

<span class="hljs-comment">// 创建可读流</span>
<span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'access.log'</span>);
<span class="hljs-keyword">const</span> rl = readline.<span class="hljs-title function_">createInterface</span>({
  <span class="hljs-attr">input</span>: readStream,
  <span class="hljs-attr">crlfDelay</span>: <span class="hljs-title class_">Infinity</span>
});

<span class="hljs-keyword">let</span> lineNumber = <span class="hljs-number">0</span>;

<span class="hljs-comment">// 边读边处理，立即看到结果</span>
rl.<span class="hljs-title function_">on</span>(<span class="hljs-string">'line'</span>, <span class="hljs-function">(<span class="hljs-params">line</span>) =&gt;</span> {
  lineNumber++;
  
  <span class="hljs-comment">// 实时处理，不需要等待整个文件</span>
  <span class="hljs-keyword">if</span> (line.<span class="hljs-title function_">includes</span>(<span class="hljs-string">'ERROR'</span>)) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`第 <span class="hljs-subst">${lineNumber}</span> 行发现错误:`</span>, line);
    <span class="hljs-comment">// 可以立即采取行动，如发送告警</span>
  }
  
  <span class="hljs-comment">// 可以显示进度</span>
  <span class="hljs-keyword">if</span> (lineNumber % <span class="hljs-number">1000</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`已处理 <span class="hljs-subst">${lineNumber}</span> 行...`</span>);
  }
});

rl.<span class="hljs-title function_">on</span>(<span class="hljs-string">'close'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'处理完成，共处理'</span>, lineNumber, <span class="hljs-string">'行'</span>);
});

<span class="hljs-comment">// 优势：</span>
<span class="hljs-comment">// 1. 立即开始处理，不需要等待</span>
<span class="hljs-comment">// 2. 可以实时看到处理进度</span>
<span class="hljs-comment">// 3. 内存占用小，只缓存当前行</span>
</code></pre>
<h4 data-id="heading-33">场景三：数据转换管道</h4>
<p><strong>问题：没有 Stream 的复杂处理</strong></p>
<p>当需要对数据进行多个步骤的处理时，传统方式需要多次读取和写入。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 问题示例：多次读取和写入</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zlib'</span>);

<span class="hljs-comment">// 步骤1：读取文件</span>
<span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'input.txt'</span>); <span class="hljs-comment">// 占用内存</span>

<span class="hljs-comment">// 步骤2：压缩</span>
<span class="hljs-keyword">const</span> compressed = zlib.<span class="hljs-title function_">gzipSync</span>(data); <span class="hljs-comment">// 又占用一份内存</span>

<span class="hljs-comment">// 步骤3：加密（假设有加密函数）</span>
<span class="hljs-keyword">const</span> encrypted = <span class="hljs-title function_">encrypt</span>(compressed); <span class="hljs-comment">// 再占用一份内存</span>

<span class="hljs-comment">// 步骤4：写入文件</span>
fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">'output.txt.gz.enc'</span>, encrypted);

<span class="hljs-comment">// 问题：</span>
<span class="hljs-comment">// 1. 内存占用 = 原始数据 + 压缩数据 + 加密数据（可能是原始数据的 3 倍）</span>
<span class="hljs-comment">// 2. 每个步骤都需要等待前一步完成</span>
<span class="hljs-comment">// 3. 代码复杂，难以维护</span>
<span class="hljs-comment">// 4. 对于大文件，内存可能不足</span>
</code></pre>
<p><strong>解决方案：使用 Stream 管道</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ✅ 正确示例：使用 Stream 管道</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zlib'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-comment">// 创建加密转换流</span>
<span class="hljs-keyword">const</span> encryptStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({
  <span class="hljs-title function_">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-keyword">const</span> cipher = crypto.<span class="hljs-title function_">createCipher</span>(<span class="hljs-string">'aes192'</span>, <span class="hljs-string">'password'</span>);
    <span class="hljs-keyword">const</span> encrypted = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([
      cipher.<span class="hljs-title function_">update</span>(chunk),
      cipher.<span class="hljs-title function_">final</span>()
    ]);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(encrypted);
    <span class="hljs-title function_">callback</span>();
  }
});

<span class="hljs-comment">// 使用管道连接：读取 -&gt; 压缩 -&gt; 加密 -&gt; 写入</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>)
  .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGzip</span>())        <span class="hljs-comment">// 压缩流</span>
  .<span class="hljs-title function_">pipe</span>(encryptStream)            <span class="hljs-comment">// 加密流</span>
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt.gz.enc'</span>));

<span class="hljs-comment">// 优势：</span>
<span class="hljs-comment">// 1. 内存占用恒定（只占用缓冲区大小）</span>
<span class="hljs-comment">// 2. 数据流式处理，不需要等待</span>
<span class="hljs-comment">// 3. 代码简洁，易于理解和维护</span>
<span class="hljs-comment">// 4. 可以处理任意大小的文件</span>
<span class="hljs-comment">// 5. 自动处理背压（backpressure），防止内存溢出</span>
</code></pre>
<h4 data-id="heading-34">场景四：HTTP 文件上传</h4>
<p><strong>问题：没有 Stream 的上传限制</strong></p>
<p>处理文件上传时，如果一次性加载整个文件到内存，会有严重限制。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 问题示例：一次性处理上传文件</span>
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> formidable = <span class="hljs-built_in">require</span>(<span class="hljs-string">'formidable'</span>);

http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">'POST'</span>) {
    <span class="hljs-keyword">const</span> form = <span class="hljs-title function_">formidable</span>({
      <span class="hljs-comment">// 问题：整个文件会被加载到内存</span>
      <span class="hljs-comment">// 如果用户上传 1GB 文件，服务器需要 1GB+ 内存</span>
    });
    
    form.<span class="hljs-title function_">parse</span>(req, <span class="hljs-function">(<span class="hljs-params">err, fields, files</span>) =&gt;</span> {
      <span class="hljs-comment">// 文件已经在内存中了</span>
      <span class="hljs-keyword">const</span> uploadedFile = files.<span class="hljs-property">file</span>;
      
      <span class="hljs-comment">// 如果内存不足，服务器可能崩溃</span>
      <span class="hljs-comment">// 多个用户同时上传大文件时，问题更严重</span>
    });
  }
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<p><strong>解决方案：使用 Stream 流式上传</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ✅ 正确示例：使用 Stream 流式上传</span>
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> { promisify } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">const</span> pipelineAsync = <span class="hljs-title function_">promisify</span>(pipeline);

http.<span class="hljs-title function_">createServer</span>(<span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">method</span> === <span class="hljs-string">'POST'</span> &amp;&amp; req.<span class="hljs-property">url</span> === <span class="hljs-string">'/upload'</span>) {
    <span class="hljs-comment">// 创建写入流，直接写入磁盘</span>
    <span class="hljs-keyword">const</span> writeStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">`uploads/<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>.file`</span>);
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 流式传输：请求体 -&gt; 文件</span>
      <span class="hljs-comment">// 内存占用恒定，不受文件大小影响</span>
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">pipelineAsync</span>(req, writeStream);
      
      res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, { <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span> });
      res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">'上传成功'</span> }));
    } <span class="hljs-keyword">catch</span> (err) {
      res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">500</span>);
      res.<span class="hljs-title function_">end</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: err.<span class="hljs-property">message</span> }));
    }
  }
}).<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);

<span class="hljs-comment">// 优势：</span>
<span class="hljs-comment">// 1. 内存占用恒定，可以处理任意大小的文件</span>
<span class="hljs-comment">// 2. 数据直接写入磁盘，不需要在内存中缓存</span>
<span class="hljs-comment">// 3. 可以同时处理多个上传请求</span>
<span class="hljs-comment">// 4. 自动处理背压，防止内存溢出</span>
</code></pre>
<h4 data-id="heading-35">场景五：数据库批量导入</h4>
<p><strong>问题：没有 Stream 的批量操作瓶颈</strong></p>
<p>从文件批量导入数据到数据库时，传统方式效率低下。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 问题示例：一次性加载所有数据</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mysql2/promise'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">importData</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 读取整个 CSV 文件到内存</span>
  <span class="hljs-keyword">const</span> csvData = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'large-data.csv'</span>, <span class="hljs-string">'utf8'</span>);
  <span class="hljs-keyword">const</span> lines = csvData.<span class="hljs-title function_">split</span>(<span class="hljs-string">'\n'</span>);
  
  <span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> mysql.<span class="hljs-title function_">createConnection</span>({ <span class="hljs-comment">/* ... */</span> });
  
  <span class="hljs-comment">// 问题：</span>
  <span class="hljs-comment">// 1. 整个文件在内存中，占用大量内存</span>
  <span class="hljs-comment">// 2. 如果文件很大（如 10GB），可能无法加载</span>
  <span class="hljs-comment">// 3. 需要等待所有数据解析完成才能开始插入</span>
  <span class="hljs-comment">// 4. 如果中途出错，所有工作都白费</span>
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> lines) {
    <span class="hljs-keyword">const</span> [name, email] = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
    <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">execute</span>(
      <span class="hljs-string">'INSERT INTO users (name, email) VALUES (?, ?)'</span>,
      [name, email]
    );
  }
  
  <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">end</span>();
}
</code></pre>
<p><strong>解决方案：使用 Stream 批量导入</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ✅ 正确示例：使用 Stream 批量导入</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> readline = <span class="hljs-built_in">require</span>(<span class="hljs-string">'readline'</span>);
<span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mysql2/promise'</span>);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">importData</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> connection = <span class="hljs-keyword">await</span> mysql.<span class="hljs-title function_">createConnection</span>({ <span class="hljs-comment">/* ... */</span> });
  <span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'large-data.csv'</span>);
  <span class="hljs-keyword">const</span> rl = readline.<span class="hljs-title function_">createInterface</span>({
    <span class="hljs-attr">input</span>: readStream,
    <span class="hljs-attr">crlfDelay</span>: <span class="hljs-title class_">Infinity</span>
  });
  
  <span class="hljs-keyword">let</span> batch = [];
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BATCH_SIZE</span> = <span class="hljs-number">1000</span>; <span class="hljs-comment">// 批量插入大小</span>
  
  <span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> line <span class="hljs-keyword">of</span> rl) {
    <span class="hljs-keyword">const</span> [name, email] = line.<span class="hljs-title function_">split</span>(<span class="hljs-string">','</span>);
    batch.<span class="hljs-title function_">push</span>([name, email]);
    
    <span class="hljs-comment">// 达到批量大小时，执行插入</span>
    <span class="hljs-keyword">if</span> (batch.<span class="hljs-property">length</span> &gt;= <span class="hljs-variable constant_">BATCH_SIZE</span>) {
      <span class="hljs-keyword">const</span> values = batch.<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">'(?, ?)'</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">', '</span>);
      <span class="hljs-keyword">const</span> sql = <span class="hljs-string">`INSERT INTO users (name, email) VALUES <span class="hljs-subst">${values}</span>`</span>;
      <span class="hljs-keyword">const</span> flatBatch = batch.<span class="hljs-title function_">flat</span>();
      
      <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">execute</span>(sql, flatBatch);
      batch = []; <span class="hljs-comment">// 清空批次</span>
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`已导入 <span class="hljs-subst">${BATCH_SIZE}</span> 条记录...`</span>);
    }
  }
  
  <span class="hljs-comment">// 处理剩余数据</span>
  <span class="hljs-keyword">if</span> (batch.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">const</span> values = batch.<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">'(?, ?)'</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">', '</span>);
    <span class="hljs-keyword">const</span> sql = <span class="hljs-string">`INSERT INTO users (name, email) VALUES <span class="hljs-subst">${values}</span>`</span>;
    <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">execute</span>(sql, batch.<span class="hljs-title function_">flat</span>());
  }
  
  <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">end</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'导入完成'</span>);
}

<span class="hljs-comment">// 优势：</span>
<span class="hljs-comment">// 1. 内存占用小，只缓存当前批次</span>
<span class="hljs-comment">// 2. 可以处理任意大小的文件</span>
<span class="hljs-comment">// 3. 实时处理，可以看到进度</span>
<span class="hljs-comment">// 4. 批量插入，数据库操作效率高</span>
</code></pre>
<h4 data-id="heading-36">总结：Stream 的核心价值</h4>
<ol>
<li><strong>内存效率</strong>：处理大文件时内存占用恒定，不受文件大小影响</li>
<li><strong>时间效率</strong>：可以边读边处理，不需要等待所有数据就绪</li>
<li><strong>可组合性</strong>：通过管道（pipe）将多个流连接，代码简洁优雅</li>
<li><strong>实时处理</strong>：可以实时看到处理进度和结果</li>
<li><strong>自动背压控制</strong>：自动处理数据生产速度超过消费速度的情况</li>
<li><strong>可扩展性</strong>：可以处理任意大小的数据，不受内存限制</li>
</ol>
<h3 data-id="heading-37">流概念</h3>
<p>流（Stream）是 Node.js 中处理流式数据的抽象接口。流是数据的集合，就像数组或字符串一样，但流可能不会一次性全部可用，也不需要全部放入内存。</p>
<p><strong>流的类型：</strong></p>
<ol>
<li><strong>Readable（可读流）</strong>：可以读取数据的流（如 <code>fs.createReadStream()</code>）</li>
<li><strong>Writable（可写流）</strong>：可以写入数据的流（如 <code>fs.createWriteStream()</code>）</li>
<li><strong>Duplex（双工流）</strong>：既可读又可写的流（如 TCP socket）</li>
<li><strong>Transform（转换流）</strong>：在读写过程中可以修改或转换数据的双工流（如 <code>zlib.createGzip()</code>）</li>
</ol>
<p><strong>流的工作模式：</strong></p>
<ul>
<li><strong>对象模式</strong>：流可以处理 JavaScript 对象（除了 null）</li>
<li><strong>非对象模式</strong>：流处理字符串、Buffer 或 Uint8Array</li>
</ul>
<blockquote>
<p><strong>提示</strong>：关于 Stream 的实际应用场景和解决的问题，请参考 <a href="#%E6%B5%81%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8" title="#%E6%B5%81%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8">流的实际作用</a> 章节。</p>
</blockquote>
<h3 data-id="heading-38">可读流（Readable）</h3>
<p>可读流是数据的来源，可以从文件、网络、内存等读取数据。</p>
<h4 data-id="heading-39">创建可读流</h4>
<p>可读流有两种工作模式：</p>
<p><strong>1. 流动模式（Flowing Mode）</strong> - 数据自动从底层系统读取，并通过事件提供给应用程序。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 从文件创建可读流</span>
<span class="hljs-keyword">const</span> readableStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>);

<span class="hljs-comment">// 流动模式：监听 data 事件，数据自动流动</span>
readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`接收到 <span class="hljs-subst">${chunk.length}</span> 字节的数据`</span>);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk.<span class="hljs-title function_">toString</span>());
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据读取完成'</span>);
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'读取错误:'</span>, err);
});
</code></pre>
<p><strong>2. 暂停模式（Paused Mode）</strong> - 必须显式调用 <code>stream.read()</code> 来读取数据块。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> readableStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>);

<span class="hljs-comment">// 暂停模式：监听 readable 事件，手动读取</span>
readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'readable'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">let</span> chunk;
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">null</span> !== (chunk = readableStream.<span class="hljs-title function_">read</span>())) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'读取数据:'</span>, chunk.<span class="hljs-title function_">toString</span>());
  }
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'读取完成'</span>);
});
</code></pre>
<h4 data-id="heading-40">手动创建可读流</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Readable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-comment">// 创建自定义可读流</span>
<span class="hljs-keyword">const</span> readableStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Readable</span>({
  <span class="hljs-title function_">read</span>(<span class="hljs-params">size</span>) {
    <span class="hljs-comment">// 模拟数据生成</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'Hello '</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'World'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 表示数据结束</span>
  }
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk.<span class="hljs-title function_">toString</span>()); <span class="hljs-comment">// 'Hello World'</span>
});
</code></pre>
<h3 data-id="heading-41">可写流（Writable）</h3>
<p>可写流是数据的目标，可以向文件、网络、内存等写入数据。</p>
<h4 data-id="heading-42">创建可写流</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 创建可写流</span>
<span class="hljs-keyword">const</span> writableStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt'</span>);

<span class="hljs-comment">// write(): 写入数据</span>
writableStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Hello '</span>);
writableStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'World'</span>);

<span class="hljs-comment">// end(): 结束写入（可选传入最后的数据）</span>
writableStream.<span class="hljs-title function_">end</span>();

<span class="hljs-comment">// 监听完成事件</span>
writableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'finish'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'数据写入完成'</span>);
});

<span class="hljs-comment">// 监听错误事件</span>
writableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'写入错误:'</span>, err);
});

<span class="hljs-comment">// 监听 drain 事件（当缓冲区可以继续写入时）</span>
writableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'drain'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'缓冲区已清空，可以继续写入'</span>);
});
</code></pre>
<h4 data-id="heading-43">手动创建可写流</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Writable</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-comment">// 创建自定义可写流</span>
<span class="hljs-keyword">const</span> writableStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Writable</span>({
  <span class="hljs-title function_">write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'写入数据:'</span>, chunk.<span class="hljs-title function_">toString</span>());
    <span class="hljs-comment">// 模拟异步操作</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 调用回调表示写入完成</span>
    }, <span class="hljs-number">100</span>);
  }
});

writableStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Hello'</span>);
writableStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">' World'</span>);
writableStream.<span class="hljs-title function_">end</span>();
</code></pre>
<h3 data-id="heading-44">流管道（pipe）</h3>
<p><code>pipe()</code> 方法将可读流连接到可写流，自动管理数据流和背压（backpressure）。</p>
<h4 data-id="heading-45">基本用法</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 创建可读流和可写流</span>
<span class="hljs-keyword">const</span> readableStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>);
<span class="hljs-keyword">const</span> writableStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt'</span>);

<span class="hljs-comment">// 使用 pipe 连接流</span>
readableStream.<span class="hljs-title function_">pipe</span>(writableStream);

<span class="hljs-comment">// 监听完成事件</span>
writableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'finish'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件复制完成'</span>);
});
</code></pre>
<h4 data-id="heading-46">链式管道</h4>
<p>可以将多个流通过管道连接起来。<code>pipe()</code> 返回目标流，所以可以链式调用：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> zlib = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zlib'</span>);

<span class="hljs-comment">// 链式管道：读取文件 -&gt; 压缩 -&gt; 写入文件</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>)
  .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGzip</span>())
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'input.txt.gz'</span>));

<span class="hljs-comment">// 也可以分开写，pipe() 返回目标流</span>
<span class="hljs-keyword">const</span> readableStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>);
<span class="hljs-keyword">const</span> gzipStream = zlib.<span class="hljs-title function_">createGzip</span>();
<span class="hljs-keyword">const</span> writableStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt.gz'</span>);

readableStream
  .<span class="hljs-title function_">pipe</span>(gzipStream)
  .<span class="hljs-title function_">pipe</span>(writableStream);

writableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'finish'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'压缩完成'</span>);
});
</code></pre>
<h3 data-id="heading-47">流事件</h3>
<p>流是 EventEmitter 的实例，可以监听各种事件。前面章节已经展示了基本的事件使用（<code>data</code>、<code>end</code>、<code>error</code>、<code>finish</code>、<code>drain</code> 等），这里补充一些重要的事件和最佳实践。</p>
<p><strong>可读流常用事件：</strong></p>
<ul>
<li><code>data</code>: 当流将数据块传送给消费者时触发（流动模式）</li>
<li><code>readable</code>: 当有数据可从流中读取时触发（暂停模式）</li>
<li><code>end</code>: 当流中没有更多数据可供消费时触发</li>
<li><code>error</code>: 当流发生错误时触发</li>
<li><code>close</code>: 当流及其底层资源被关闭时触发</li>
</ul>
<p><strong>可写流常用事件：</strong></p>
<ul>
<li><code>drain</code>: 当可以继续写入数据到流时触发</li>
<li><code>finish</code>: 当所有数据已被刷新到底层系统时触发</li>
<li><code>error</code>: 当写入或管道操作发生错误时触发</li>
<li><code>close</code>: 当流及其底层资源被关闭时触发</li>
<li><code>pipe</code>: 当在可读流上调用 <code>stream.pipe()</code> 方法时触发</li>
<li><code>unpipe</code>: 当在可读流上调用 <code>stream.unpipe()</code> 方法时触发</li>
</ul>
<h4 data-id="heading-48">事件处理最佳实践</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">copyFile</span>(<span class="hljs-params">source, destination</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> readableStream = fs.<span class="hljs-title function_">createReadStream</span>(source);
    <span class="hljs-keyword">const</span> writableStream = fs.<span class="hljs-title function_">createWriteStream</span>(destination);
    
    <span class="hljs-comment">// 使用 once 监听一次性事件</span>
    readableStream.<span class="hljs-title function_">once</span>(<span class="hljs-string">'error'</span>, reject);
    writableStream.<span class="hljs-title function_">once</span>(<span class="hljs-string">'error'</span>, reject);
    writableStream.<span class="hljs-title function_">once</span>(<span class="hljs-string">'finish'</span>, resolve);
    
    <span class="hljs-comment">// 使用 pipe 连接流</span>
    readableStream.<span class="hljs-title function_">pipe</span>(writableStream);
  });
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-title function_">copyFile</span>(<span class="hljs-string">'input.txt'</span>, <span class="hljs-string">'output.txt'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件复制成功'</span>);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'文件复制失败:'</span>, err);
  });
</code></pre>
<h3 data-id="heading-49">流错误处理</h3>
<p>正确处理流错误非常重要，可以防止内存泄漏和未处理的异常。虽然可以使用 <code>on('error')</code> 手动处理错误，但 Node.js 提供了更好的方式。</p>
<h4 data-id="heading-50">使用 pipeline() 自动处理错误</h4>
<p><code>pipeline()</code> 是 Node.js 提供的更好的方式，可以自动处理错误和清理资源。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> { promisify } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">const</span> pipelineAsync = <span class="hljs-title function_">promisify</span>(pipeline);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">copyFile</span>(<span class="hljs-params">source, destination</span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">pipelineAsync</span>(
      fs.<span class="hljs-title function_">createReadStream</span>(source),
      fs.<span class="hljs-title function_">createWriteStream</span>(destination)
    );
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件复制成功'</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'文件复制失败:'</span>, err);
  }
}

<span class="hljs-title function_">copyFile</span>(<span class="hljs-string">'input.txt'</span>, <span class="hljs-string">'output.txt'</span>);
</code></pre>
<h4 data-id="heading-51">使用 finished() 监听流结束</h4>
<p><code>finished()</code> 可以监听流的结束（成功或失败）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> { finished } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> { promisify } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">const</span> finishedAsync = <span class="hljs-title function_">promisify</span>(finished);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processStream</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">const</span> readableStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>);
  
  readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'处理数据:'</span>, chunk.<span class="hljs-title function_">toString</span>());
  });
  
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">finishedAsync</span>(readableStream);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'流处理完成'</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'流处理错误:'</span>, err);
  }
}

<span class="hljs-title function_">processStream</span>();
</code></pre>
<h4 data-id="heading-52">自定义流的错误处理</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Transform</span> {
  <span class="hljs-title function_">_transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// 可能抛出错误的操作</span>
      <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processChunk</span>(chunk);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(result);
      <span class="hljs-title function_">callback</span>();
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-comment">// 将错误传递给回调</span>
      <span class="hljs-title function_">callback</span>(err);
    }
  }
  
  <span class="hljs-title function_">processChunk</span>(<span class="hljs-params">chunk</span>) {
    <span class="hljs-comment">// 处理逻辑</span>
    <span class="hljs-keyword">return</span> chunk.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">toUpperCase</span>();
  }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">const</span> transform = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SafeTransform</span>();

transform.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'转换错误:'</span>, err);
});

transform.<span class="hljs-title function_">write</span>(<span class="hljs-string">'hello'</span>);
transform.<span class="hljs-title function_">end</span>();
</code></pre>
<hr/>
<h2 data-id="heading-53">流（Stream）高级</h2>
<h3 data-id="heading-54">双工流（Duplex）</h3>
<p>双工流同时实现了可读流和可写流的接口，可以同时读取和写入数据。TCP socket 就是一个典型的双工流。</p>
<h4 data-id="heading-55">创建双工流</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Duplex</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-comment">// 创建自定义双工流</span>
<span class="hljs-keyword">const</span> duplexStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Duplex</span>({
  <span class="hljs-title function_">read</span>(<span class="hljs-params">size</span>) {
    <span class="hljs-comment">// 可读端：生成数据</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'Hello '</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'World'</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
  },
  
  <span class="hljs-title function_">write</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// 可写端：处理写入的数据</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'接收到写入数据:'</span>, chunk.<span class="hljs-title function_">toString</span>());
    <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 调用回调表示写入完成</span>
  }
});

<span class="hljs-comment">// 可以同时读取和写入</span>
duplexStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'读取:'</span>, chunk.<span class="hljs-title function_">toString</span>());
});

duplexStream.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Test'</span>);
duplexStream.<span class="hljs-title function_">end</span>();
</code></pre>
<h4 data-id="heading-56">实际应用：TCP Socket</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">'net'</span>);

<span class="hljs-comment">// TCP socket 是双工流</span>
<span class="hljs-keyword">const</span> server = net.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">socket</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'客户端已连接'</span>);
  
  <span class="hljs-comment">// socket 是可读流</span>
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'接收到数据:'</span>, data.<span class="hljs-title function_">toString</span>());
    <span class="hljs-comment">// socket 也是可写流</span>
    socket.<span class="hljs-title function_">write</span>(<span class="hljs-string">'Echo: '</span> + data);
  });
  
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'客户端断开连接'</span>);
  });
});

server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'服务器监听在 8080 端口'</span>);
});
</code></pre>
<h3 data-id="heading-57">转换流（Transform）</h3>
<p>转换流是一种特殊的双工流，在数据从可写端写入后，经过转换处理，可以从可读端读取转换后的数据。<code>zlib.createGzip()</code> 就是一个转换流。</p>
<h4 data-id="heading-58">创建转换流</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-comment">// 创建自定义转换流：将输入转换为大写</span>
<span class="hljs-keyword">const</span> upperCaseTransform = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({
  <span class="hljs-title function_">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// 转换数据</span>
    <span class="hljs-keyword">const</span> upperChunk = chunk.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">toUpperCase</span>();
    <span class="hljs-comment">// 将转换后的数据推送到可读端</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(upperChunk);
    <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 调用回调表示处理完成</span>
  }
});

<span class="hljs-comment">// 使用转换流</span>
process.<span class="hljs-property">stdin</span>
  .<span class="hljs-title function_">pipe</span>(upperCaseTransform)
  .<span class="hljs-title function_">pipe</span>(process.<span class="hljs-property">stdout</span>);

<span class="hljs-comment">// 输入: hello world</span>
<span class="hljs-comment">// 输出: HELLO WORLD</span>
</code></pre>
<h4 data-id="heading-59">实际应用：数据加密转换流</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);

<span class="hljs-comment">// 创建加密转换流</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">EncryptTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Transform</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">password</span>) {
    <span class="hljs-variable language_">super</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cipher</span> = crypto.<span class="hljs-title function_">createCipher</span>(<span class="hljs-string">'aes192'</span>, password);
  }
  
  <span class="hljs-title function_">_transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-keyword">const</span> encrypted = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cipher</span>.<span class="hljs-title function_">update</span>(chunk);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(encrypted);
    <span class="hljs-title function_">callback</span>();
  }
  
  <span class="hljs-title function_">_flush</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cipher</span>.<span class="hljs-title function_">final</span>());
    <span class="hljs-title function_">callback</span>();
  }
}

<span class="hljs-comment">// 创建解密转换流</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DecryptTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Transform</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">password</span>) {
    <span class="hljs-variable language_">super</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">decipher</span> = crypto.<span class="hljs-title function_">createDecipher</span>(<span class="hljs-string">'aes192'</span>, password);
  }
  
  <span class="hljs-title function_">_transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-keyword">const</span> decrypted = <span class="hljs-variable language_">this</span>.<span class="hljs-property">decipher</span>.<span class="hljs-title function_">update</span>(chunk);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(decrypted);
    <span class="hljs-title function_">callback</span>();
  }
  
  <span class="hljs-title function_">_flush</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">decipher</span>.<span class="hljs-title function_">final</span>());
    <span class="hljs-title function_">callback</span>();
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);
<span class="hljs-keyword">const</span> password = <span class="hljs-string">'my-secret-password'</span>;

<span class="hljs-comment">// 加密文件</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>)
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EncryptTransform</span>(password))
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'encrypted.txt'</span>));

<span class="hljs-comment">// 解密文件</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'encrypted.txt'</span>)
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecryptTransform</span>(password))
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'decrypted.txt'</span>));
</code></pre>
<h4 data-id="heading-60">实际应用：JSON 解析转换流</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-comment">// 创建 JSON 解析转换流</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">JSONParseTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Transform</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-variable language_">super</span>({ <span class="hljs-attr">objectMode</span>: <span class="hljs-literal">true</span> }); <span class="hljs-comment">// 对象模式</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buffer</span> = <span class="hljs-string">''</span>;
  }
  
  <span class="hljs-title function_">_transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">buffer</span> += chunk.<span class="hljs-title function_">toString</span>();
    
    <span class="hljs-comment">// 尝试解析完整的 JSON 对象</span>
    <span class="hljs-keyword">let</span> boundary = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buffer</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'\n'</span>);
    <span class="hljs-keyword">while</span> (boundary !== -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">const</span> line = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buffer</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, boundary);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">buffer</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buffer</span>.<span class="hljs-title function_">slice</span>(boundary + <span class="hljs-number">1</span>);
      
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(line);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(obj); <span class="hljs-comment">// 推送解析后的对象</span>
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-comment">// 忽略解析错误</span>
      }
      
      boundary = <span class="hljs-variable language_">this</span>.<span class="hljs-property">buffer</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'\n'</span>);
    }
    
    <span class="hljs-title function_">callback</span>();
  }
  
  <span class="hljs-title function_">_flush</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-comment">// 处理剩余数据</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">buffer</span>.<span class="hljs-title function_">trim</span>()) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">buffer</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(obj);
      } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-comment">// 忽略解析错误</span>
      }
    }
    <span class="hljs-title function_">callback</span>();
  }
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'data.jsonl'</span>)
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JSON</span>ParseTransform())
  .<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'解析的对象:'</span>, obj);
  });
</code></pre>
<h3 data-id="heading-61">流性能优化</h3>
<h4 data-id="heading-62">1. 使用对象模式提高性能</h4>
<p>对于处理对象而不是 Buffer 的场景，使用对象模式可以提高性能。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-comment">// 对象模式：直接传递对象，避免序列化/反序列化</span>
<span class="hljs-keyword">const</span> objectTransform = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({
  <span class="hljs-attr">objectMode</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-title function_">transform</span>(<span class="hljs-params">obj, encoding, callback</span>) {
    <span class="hljs-comment">// 直接处理对象</span>
    obj.<span class="hljs-property">processed</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(obj);
    <span class="hljs-title function_">callback</span>();
  }
});

<span class="hljs-comment">// 非对象模式：需要处理 Buffer</span>
<span class="hljs-keyword">const</span> bufferTransform = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({
  <span class="hljs-title function_">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// 需要将 Buffer 转换为对象，处理后再转换回 Buffer</span>
    <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(chunk.<span class="hljs-title function_">toString</span>());
    obj.<span class="hljs-property">processed</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj)));
    <span class="hljs-title function_">callback</span>();
  }
});
</code></pre>
<h4 data-id="heading-63">2. 控制背压（Backpressure）</h4>
<p>背压是流控制的重要机制，防止数据生产速度超过消费速度。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> readableStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'large-file.txt'</span>);
<span class="hljs-keyword">const</span> writableStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt'</span>);

<span class="hljs-comment">// pipe() 自动处理背压</span>
readableStream.<span class="hljs-title function_">pipe</span>(writableStream);

<span class="hljs-comment">// 手动处理背压</span>
readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> canContinue = writableStream.<span class="hljs-title function_">write</span>(chunk);
  
  <span class="hljs-keyword">if</span> (!canContinue) {
    <span class="hljs-comment">// 缓冲区已满，暂停读取</span>
    readableStream.<span class="hljs-title function_">pause</span>();
    
    <span class="hljs-comment">// 等待 drain 事件后继续读取</span>
    writableStream.<span class="hljs-title function_">once</span>(<span class="hljs-string">'drain'</span>, <span class="hljs-function">() =&gt;</span> {
      readableStream.<span class="hljs-title function_">resume</span>();
    });
  }
});

readableStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'end'</span>, <span class="hljs-function">() =&gt;</span> {
  writableStream.<span class="hljs-title function_">end</span>();
});
</code></pre>
<h4 data-id="heading-64">3. 使用高水位标记（High Water Mark）</h4>
<p>高水位标记控制内部缓冲区的大小。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// 设置较大的高水位标记以提高性能（但会占用更多内存）</span>
<span class="hljs-keyword">const</span> readableStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'large-file.txt'</span>, {
  <span class="hljs-attr">highWaterMark</span>: <span class="hljs-number">64</span> * <span class="hljs-number">1024</span> <span class="hljs-comment">// 64KB（默认是 16KB）</span>
});

<span class="hljs-comment">// 对于可写流</span>
<span class="hljs-keyword">const</span> writableStream = fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt'</span>, {
  <span class="hljs-attr">highWaterMark</span>: <span class="hljs-number">64</span> * <span class="hljs-number">1024</span>
});
</code></pre>
<h4 data-id="heading-65">4. 批量处理数据</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Transform</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-variable language_">super</span>(options);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">batchSize</span> = options.<span class="hljs-property">batchSize</span> || <span class="hljs-number">10</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">batch</span> = [];
  }
  
  <span class="hljs-title function_">_transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">batch</span>.<span class="hljs-title function_">push</span>(chunk);
    
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">batch</span>.<span class="hljs-property">length</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">batchSize</span>) {
      <span class="hljs-comment">// 批量处理</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processBatch</span>();
    }
    
    <span class="hljs-title function_">callback</span>();
  }
  
  <span class="hljs-title function_">_flush</span>(<span class="hljs-params">callback</span>) {
    <span class="hljs-comment">// 处理剩余数据</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">batch</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processBatch</span>();
    }
    <span class="hljs-title function_">callback</span>();
  }
  
  <span class="hljs-title function_">processBatch</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 批量处理逻辑</span>
    <span class="hljs-keyword">const</span> batchData = <span class="hljs-variable language_">this</span>.<span class="hljs-property">batch</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">batchSize</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(batchData)));
  }
}

<span class="hljs-comment">// 使用</span>
<span class="hljs-keyword">const</span> batchTransform = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchTransform</span>({ <span class="hljs-attr">batchSize</span>: <span class="hljs-number">100</span> });
</code></pre>
<h4 data-id="heading-66">5. 使用流池避免内存泄漏</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { pipeline } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);
<span class="hljs-keyword">const</span> { promisify } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'util'</span>);

<span class="hljs-keyword">const</span> pipelineAsync = <span class="hljs-title function_">promisify</span>(pipeline);

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processMultipleFiles</span>(<span class="hljs-params">files</span>) {
  <span class="hljs-comment">// 使用 Promise.all 并行处理，但限制并发数</span>
  <span class="hljs-keyword">const</span> concurrency = <span class="hljs-number">3</span>;
  
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; files.<span class="hljs-property">length</span>; i += concurrency) {
    <span class="hljs-keyword">const</span> batch = files.<span class="hljs-title function_">slice</span>(i, i + concurrency);
    
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(
      batch.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> (file) =&gt; {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">await</span> <span class="hljs-title function_">pipelineAsync</span>(
            fs.<span class="hljs-title function_">createReadStream</span>(file.<span class="hljs-property">input</span>),
            fs.<span class="hljs-title function_">createWriteStream</span>(file.<span class="hljs-property">output</span>)
          );
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`处理完成: <span class="hljs-subst">${file.input}</span>`</span>);
        } <span class="hljs-keyword">catch</span> (err) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`处理失败: <span class="hljs-subst">${file.input}</span>`</span>, err);
        }
      })
    );
  }
}
</code></pre>
<h4 data-id="heading-67">6. 避免不必要的中间流</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 不好的做法：创建不必要的中间流</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>)
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({ <span class="hljs-comment">/* ... */</span> }))
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({ <span class="hljs-comment">/* ... */</span> }))
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({ <span class="hljs-comment">/* ... */</span> }))
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt'</span>));

<span class="hljs-comment">// 好的做法：合并转换逻辑到一个流中</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CombinedTransform</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Transform</span> {
  <span class="hljs-title function_">_transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// 合并所有转换逻辑</span>
    <span class="hljs-keyword">let</span> result = chunk;
    result = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">transform1</span>(result);
    result = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">transform2</span>(result);
    result = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">transform3</span>(result);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(result);
    <span class="hljs-title function_">callback</span>();
  }
}

fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>)
  .<span class="hljs-title function_">pipe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CombinedTransform</span>())
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt'</span>));
</code></pre>
<hr/>
<h2 data-id="heading-68">Buffer 与 Stream 的关系及选择</h2>
<h3 data-id="heading-69">Buffer 和 Stream 的关系</h3>
<p>Buffer 和 Stream 在 Node.js 中经常一起使用，它们的关系如下：</p>
<ol>
<li>
<p><strong>Stream 使用 Buffer 作为数据单元</strong></p>
<ul>
<li>Stream 在传输数据时，数据块（chunk）通常是 Buffer 对象</li>
<li>可读流读取的数据是 Buffer，可写流写入的数据也是 Buffer</li>
<li>Stream 的缓冲区内部使用 Buffer 来存储数据</li>
</ul>
</li>
<li>
<p><strong>Buffer 是数据容器，Stream 是数据传输方式</strong></p>
<ul>
<li>Buffer：处理二进制数据的容器，适合处理小块数据或需要精确控制字节的场景</li>
<li>Stream：处理大量数据的方式，通过流式传输避免内存溢出</li>
</ul>
</li>
<li>
<p><strong>它们经常配合使用</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// Stream 读取文件，数据块是 Buffer</span>
<span class="hljs-keyword">const</span> readStream = fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'file.txt'</span>);
readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  <span class="hljs-comment">// chunk 是 Buffer 对象</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Buffer</span>); <span class="hljs-comment">// true</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(chunk.<span class="hljs-property">length</span>); <span class="hljs-comment">// Buffer 的字节长度</span>
});
</code></pre>
</li>
</ol>
<h3 data-id="heading-70">如何选择使用 Buffer 还是 Stream？</h3>
<h4 data-id="heading-71">使用 Buffer 的场景</h4>
<p><strong>✅ 适合使用 Buffer：</strong></p>
<ol>
<li>
<p><strong>处理小文件或数据块</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 文件小于几 MB，可以直接加载到内存</span>
<span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'small-file.txt'</span>); <span class="hljs-comment">// 返回 Buffer</span>
</code></pre>
</li>
<li>
<p><strong>需要精确控制字节</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 解析文件格式、网络协议等需要字节级操作</span>
<span class="hljs-keyword">const</span> header = buffer.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 提取文件头</span>
<span class="hljs-keyword">if</span> (header[<span class="hljs-number">0</span>] === <span class="hljs-number">0xFF</span> &amp;&amp; header[<span class="hljs-number">1</span>] === <span class="hljs-number">0xD8</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'这是 JPEG 文件'</span>);
}
</code></pre>
</li>
<li>
<p><strong>数据编码转换</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Base64、Hex 等编码转换</span>
<span class="hljs-keyword">const</span> base64 = buffer.<span class="hljs-title function_">toString</span>(<span class="hljs-string">'base64'</span>);
</code></pre>
</li>
<li>
<p><strong>处理图片、音频等二进制数据</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 图片处理、加密解密等</span>
<span class="hljs-keyword">const</span> imageBuffer = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'photo.jpg'</span>);
</code></pre>
</li>
<li>
<p><strong>数据量小且需要一次性处理</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 配置文件、小数据包等</span>
<span class="hljs-keyword">const</span> config = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'config.json'</span>, <span class="hljs-string">'utf8'</span>));
</code></pre>
</li>
</ol>
<h4 data-id="heading-72">使用 Stream 的场景</h4>
<p><strong>✅ 适合使用 Stream：</strong></p>
<ol>
<li>
<p><strong>处理大文件（&gt; 10MB）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 大文件处理，避免内存溢出</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'large-file.txt'</span>)
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt'</span>));
</code></pre>
</li>
<li>
<p><strong>实时数据处理</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 日志处理、实时监控等</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'access.log'</span>)
  .<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
    <span class="hljs-comment">// 实时处理每一块数据</span>
  });
</code></pre>
</li>
<li>
<p><strong>网络数据传输</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// HTTP 请求/响应、文件上传/下载</span>
http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'video.mp4'</span>).<span class="hljs-title function_">pipe</span>(res);
});
</code></pre>
</li>
<li>
<p><strong>数据转换管道</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 压缩、加密、转换等多步骤处理</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>)
  .<span class="hljs-title function_">pipe</span>(zlib.<span class="hljs-title function_">createGzip</span>())
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.gz'</span>));
</code></pre>
</li>
<li>
<p><strong>需要处理的数据大小未知</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 用户上传、API 响应等大小不确定的数据</span>
req.<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'uploaded-file'</span>));
</code></pre>
</li>
</ol>
<h4 data-id="heading-73">组合使用的场景</h4>
<p><strong>✅ Buffer + Stream 组合使用：</strong></p>
<ol>
<li>
<p><strong>流式处理中的 Buffer 操作</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">Transform</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'stream'</span>);

<span class="hljs-keyword">const</span> transformStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transform</span>({
  <span class="hljs-title function_">transform</span>(<span class="hljs-params">chunk, encoding, callback</span>) {
    <span class="hljs-comment">// chunk 是 Buffer，可以进行 Buffer 操作</span>
    <span class="hljs-keyword">const</span> modified = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>([
      <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'Header: '</span>),
      chunk,
      <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">from</span>(<span class="hljs-string">'\nFooter'</span>)
    ]);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">push</span>(modified);
    <span class="hljs-title function_">callback</span>();
  }
});

fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'input.txt'</span>)
  .<span class="hljs-title function_">pipe</span>(transformStream)
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'output.txt'</span>));
</code></pre>
</li>
<li>
<p><strong>批量处理</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用 Stream 读取，Buffer 批量处理</span>
<span class="hljs-keyword">const</span> buffers = [];
readStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
  buffers.<span class="hljs-title function_">push</span>(chunk); <span class="hljs-comment">// 收集 Buffer</span>
  <span class="hljs-keyword">if</span> (buffers.<span class="hljs-property">length</span> &gt;= <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">const</span> batch = <span class="hljs-title class_">Buffer</span>.<span class="hljs-title function_">concat</span>(buffers);
    <span class="hljs-comment">// 批量处理</span>
    buffers.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;
  }
});
</code></pre>
</li>
</ol>
<h3 data-id="heading-74">决策流程图</h3>
<pre><code class="hljs language-arduino" lang="arduino">需要处理数据
    │
    ├─ 数据大小 &lt; <span class="hljs-number">10</span>MB？
    │   ├─ 是 → 使用 Buffer
    │   │      ├─ 需要字节级操作？ → Buffer
    │   │      ├─ 需要编码转换？ → Buffer
    │   │      └─ 一次性处理？ → Buffer
    │   │
    │   └─ 否 → 使用 <span class="hljs-built_in">Stream</span>
    │          ├─ 大文件处理？ → <span class="hljs-built_in">Stream</span>
    │          ├─ 实时处理？ → <span class="hljs-built_in">Stream</span>
    │          ├─ 网络传输？ → <span class="hljs-built_in">Stream</span>
    │          └─ 数据转换管道？ → <span class="hljs-built_in">Stream</span>
    │
    └─ 需要组合使用？
        └─ <span class="hljs-built_in">Stream</span> + Buffer（在 <span class="hljs-built_in">Stream</span> 的 transform 中使用 Buffer 操作）
</code></pre>
<h3 data-id="heading-75">性能对比示例</h3>
<p><strong>❌ 错误：大文件使用 Buffer</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 问题：大文件会导致内存溢出</span>
<span class="hljs-keyword">const</span> data = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'2GB-file.mp4'</span>); <span class="hljs-comment">// 占用 2GB 内存</span>
</code></pre>
<p><strong>✅ 正确：大文件使用 Stream</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 优势：内存占用恒定（几 MB）</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'2GB-file.mp4'</span>)
  .<span class="hljs-title function_">pipe</span>(fs.<span class="hljs-title function_">createWriteStream</span>(<span class="hljs-string">'copy.mp4'</span>));
</code></pre>
<p><strong>❌ 错误：小文件使用 Stream</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 问题：不必要的复杂性</span>
fs.<span class="hljs-title function_">createReadStream</span>(<span class="hljs-string">'1KB-config.json'</span>)
  .<span class="hljs-title function_">on</span>(<span class="hljs-string">'data'</span>, <span class="hljs-function">(<span class="hljs-params">chunk</span>) =&gt;</span> {
    <span class="hljs-comment">// 处理小块数据</span>
  });
</code></pre>
<p><strong>✅ 正确：小文件使用 Buffer</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 优势：简单直接</span>
<span class="hljs-keyword">const</span> config = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'1KB-config.json'</span>, <span class="hljs-string">'utf8'</span>));
</code></pre>
<hr/>
<h2 data-id="heading-76">总结</h2>
<p>Buffer 和 Stream 是 Node.js 中处理二进制数据和流式数据的核心概念：</p>
<ul>
<li><strong>Buffer</strong>：处理二进制数据的容器，适合小块数据、字节级操作、编码转换</li>
<li><strong>Stream</strong>：流式数据传输方式，适合大文件、实时处理、网络传输</li>
<li><strong>关系</strong>：Stream 使用 Buffer 作为数据单元，两者配合使用效果最佳</li>
<li><strong>选择原则</strong>：数据量大或未知 → Stream；数据量小且确定 → Buffer</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[极致体验！一个小工具实现智能关键词高亮 (中英文混排/全字匹配)]]></title>    <link>https://juejin.cn/post/7584298069611429888</link>    <guid>https://juejin.cn/post/7584298069611429888</guid>    <pubDate>2025-12-17T02:59:00.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584298069611429888" data-draft-id="7584339190034497576" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="极致体验！一个小工具实现智能关键词高亮 (中英文混排/全字匹配)"/> <meta itemprop="keywords" content="TypeScript"/> <meta itemprop="datePublished" content="2025-12-17T02:59:00.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JQ_Zhang"/> <meta itemprop="url" content="https://juejin.cn/user/1871846865110249"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            极致体验！一个小工具实现智能关键词高亮 (中英文混排/全字匹配)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1871846865110249/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JQ_Zhang
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:59:00.000Z" title="Wed Dec 17 2025 02:59:00 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🚀 极致体验！一个小工具实现智能关键词高亮 (中英文混排/全字匹配)</h2>
<p>在前端开发中，“关键词高亮”是一个看似简单实则暗坑无数的需求。</p>
<p>你是否遇到过这些问题？</p>
<ol>
<li><strong>高亮“run”却把“running”也标红了？</strong> (英文全字匹配问题)</li>
<li><strong>搜索“C++”导致正则报错崩溃？</strong> (特殊字符转义问题)</li>
<li><strong>中文关键词死活匹配不上？</strong> (正则边界问题)</li>
<li><strong>用 <code>dangerouslySetInnerHTML</code> 总是提心吊胆？</strong> (XSS 安全问题)</li>
</ol>
<p>今天，我将分享一个 <strong>不到 40 行代码</strong> 的终极解决方案 <code>markWords</code>。它不仅完美解决了上述所有问题，还支持 React 虚拟 DOM 直接渲染！</p>
<hr/>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e433d22dc414fe69f443b0783d5077d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSlFfWmhhbmc=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766545139&amp;x-signature=jjPR8v2w6zpTrWSNrG0qhFNuvtg%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-1">✨ 核心亮点</h3>
<ul>
<li>✅ <strong>智能匹配</strong>：英文自动开启“全字匹配”，中文自动开启“模糊匹配”。</li>
<li>✅ <strong>安全无毒</strong>：返回 React Node 数组，<strong>拒绝</strong> <code>dangerouslySetInnerHTML</code>。</li>
<li>✅ <strong>正则健壮</strong>：自动转义 <code>?</code>、<code>+</code>、<code>*</code> 等正则特殊字符。</li>
<li>✅ <strong>零依赖</strong>：不需要引入任何第三方库 (lodash, highlighting, etc)。</li>
</ul>
<hr/>
<h3 data-id="heading-2">🛠️ 源码解析</h3>
<p>直接将以下代码复制到你的 <code>utils.ts</code> 中：</p>
<pre><code class="hljs language-ts" lang="ts">
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-comment">/**
 * 智能标记文本中的关键词
 * 
 * 特性：
 * 1. 英文单词 -&gt; 全字匹配 (如 "run" 不会匹配 "running")
 * 2. 中文/符号 -&gt; 模糊匹配
 * 3. 自动转义正则特殊字符
 * 4. 返回 ReactNode 数组，安全无 XSS 风险
 *
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">text</span> - 原始文本
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string[]</span>} <span class="hljs-variable">words</span> - 关键词数组
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">highlightClass</span> - 高亮类名
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">markWords</span> = (<span class="hljs-params">text, words, highlightClass = <span class="hljs-string">'highlight'</span></span>) =&gt; {
  <span class="hljs-keyword">if</span> (!text || !words || words.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> [text];
  }

  <span class="hljs-comment">// 1. 构造智能正则</span>
  <span class="hljs-keyword">const</span> pattern = words
    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> {
      <span class="hljs-comment">// 转义特殊字符，防止正则报错</span>
      <span class="hljs-keyword">const</span> escaped = word.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[.*+?^${}()|[\]\\]/g</span>, <span class="hljs-string">'\\$&amp;'</span>);
      
      <span class="hljs-comment">// 核心魔法：如果是纯英文/数字单词，加上 \b 边界实现全字匹配</span>
      <span class="hljs-comment">// 否则（如中文），直接匹配</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^\w+$/</span>.<span class="hljs-title function_">test</span>(word)) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`\\b<span class="hljs-subst">${escaped}</span>\\b`</span>;
      }
      <span class="hljs-keyword">return</span> escaped;
    })
    .<span class="hljs-title function_">join</span>(<span class="hljs-string">'|'</span>);
    
  <span class="hljs-keyword">if</span> (!pattern) <span class="hljs-keyword">return</span> [text];

  <span class="hljs-comment">// 2. 全局忽略大小写匹配</span>
  <span class="hljs-keyword">const</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`(<span class="hljs-subst">${pattern}</span>)`</span>, <span class="hljs-string">'gi'</span>);
  <span class="hljs-keyword">const</span> parts = [];
  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> match;

  <span class="hljs-comment">// 3. 循环切割文本</span>
  <span class="hljs-keyword">while</span> ((match = regex.<span class="hljs-title function_">exec</span>(text)) !== <span class="hljs-literal">null</span>) {
    <span class="hljs-comment">// 推入普通文本</span>
    <span class="hljs-keyword">if</span> (match.<span class="hljs-property">index</span> &gt; lastIndex) {
      parts.<span class="hljs-title function_">push</span>(text.<span class="hljs-title function_">slice</span>(lastIndex, match.<span class="hljs-property">index</span>));
    }
    <span class="hljs-comment">// 推入高亮节点 (使用 React.createElement)</span>
    parts.<span class="hljs-title function_">push</span>(
      <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'span'</span>, { <span class="hljs-attr">key</span>: match.<span class="hljs-property">index</span>, <span class="hljs-attr">className</span>: highlightClass }, match[<span class="hljs-number">0</span>])
    );
    lastIndex = match.<span class="hljs-property">index</span> + match[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;
  }

  <span class="hljs-comment">// 推入剩余文本</span>
  <span class="hljs-keyword">if</span> (lastIndex &lt; text.<span class="hljs-property">length</span>) {
    parts.<span class="hljs-title function_">push</span>(text.<span class="hljs-title function_">slice</span>(lastIndex));
  }

  <span class="hljs-keyword">return</span> parts.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ? parts : [text];
};
</code></pre>
<hr/>
<h3 data-id="heading-3">💡 效果演示</h3>
<h4 data-id="heading-4">场景一：英文全字匹配</h4>
<blockquote>
<p>关键词：<code>["test"]</code>
文本："This is a <code>test</code> case for testing."</p>
</blockquote>
<ul>
<li><strong>结果</strong>：只有 <strong>test</strong> 被高亮，testing 中的 test <strong>不会</strong>被误伤。</li>
</ul>
<h4 data-id="heading-5">场景二：中文混合匹配</h4>
<blockquote>
<p>关键词：<code>["苹果", "Apple"]</code>
文本："我喜欢吃<code>苹果</code>，因为<code>Apple</code>很好吃。"</p>
</blockquote>
<ul>
<li><strong>结果</strong>：<strong>苹果</strong> 和 <strong>Apple</strong> 都会被精准高亮。</li>
</ul>
<h4 data-id="heading-6">场景三：特殊字符</h4>
<blockquote>
<p>关键词：<code>["C++"]</code>
文本："<code>C++</code> is a powerful language."</p>
</blockquote>
<ul>
<li><strong>结果</strong>：正则自动转义 <code>+</code>，<strong>C++</strong> 完美高亮，程序不会崩。</li>
</ul>
<hr/>
<h3 data-id="heading-7">📖 最佳实践</h3>
<p>在组件中直接调用即可，就像使用普通的字符串一样：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> { markWords } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/utils/util'</span>;
<span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">'./index.module.scss'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">Article</span> = (<span class="hljs-params">{ title, content, searchKeyword }</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{styles.card}</span>&gt;</span>
      {/* 高亮标题 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{markWords(title, [searchKeyword], styles.highlight)}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
      
      {/* 高亮正文 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{markWords(content, [searchKeyword], styles.highlight)}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};**别忘了定义 <span class="hljs-variable constant_">CSS</span>：**
.<span class="hljs-property">highlight</span> {
  <span class="hljs-attr">color</span>: #ff4d4f;
  background-<span class="hljs-attr">color</span>: #fff1f0;
  font-<span class="hljs-attr">weight</span>: bold;
  border-<span class="hljs-attr">radius</span>: 2px;
}
</code></pre>
<hr/>
<h3 data-id="heading-8">📝 总结</h3>
<p>这个小工具虽然简单，但细节满满。它在保证 <strong>安全性</strong> 的前提下，兼顾了 <strong>中英文语言特性</strong> 和 <strong>代码健壮性</strong>。</p>
<p>把这个函数收藏进你的代码片段库（Snippets），以后遇到高亮需求，一秒搞定！💪</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[代码宇宙的精密蓝图：深入探索 Vue 3 + Vite 项目的灵魂结构]]></title>    <link>https://juejin.cn/post/7584407196071591974</link>    <guid>https://juejin.cn/post/7584407196071591974</guid>    <pubDate>2025-12-17T02:52:41.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584407196071591974" data-draft-id="7584349458856771610" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="代码宇宙的精密蓝图：深入探索 Vue 3 + Vite 项目的灵魂结构"/> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"/> <meta itemprop="datePublished" content="2025-12-17T02:52:41.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AAA阿giao"/> <meta itemprop="url" content="https://juejin.cn/user/473218785740627"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            代码宇宙的精密蓝图：深入探索 Vue 3 + Vite 项目的灵魂结构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/473218785740627/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AAA阿giao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:52:41.000Z" title="Wed Dec 17 2025 02:52:41 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引子：从一行命令到一座数字都市</h2>
<blockquote>
<p><strong>“在数字世界的深处，有一座由逻辑、美学与工程智慧共同构筑的城市。它的街道井然有序，建筑功能分明，每一砖一瓦都闪耀着现代前端工程化的光芒——这座城市的名字，叫 <code>all-vue</code>。”</strong></p>
</blockquote>
<hr/>
<p>你是否曾想过，当你在终端敲下：</p>
<pre><code class="hljs language-sql" lang="sql">npm <span class="hljs-keyword">create</span> vite<span class="hljs-variable">@latest</span> <span class="hljs-keyword">all</span><span class="hljs-operator">-</span>vue <span class="hljs-comment">-- --template vue</span>
</code></pre>
<p>并按下回车的那一刻，你其实不是在“创建一个项目”——<br/>
<strong>你是在召唤一座未来之城！</strong></p>
<p>这座城没有钢筋水泥，却有比物理世界更严谨的秩序；<br/>
它不靠图纸施工，却比任何建筑都更模块化、可扩展、易维护。</p>
<p>今天，就让我们化身“前端考古学家”，手持探照灯，走进这座名为 <code>all-vue</code> 的 Vue 3 + Vite 项目城市，逐街逐巷地揭开它的神秘面纱。你会发现：<strong>每一个文件夹，都是一片功能区；每一个文件，都是一位忠诚的市民。</strong></p>
<p>准备好了吗？City Tour Now Begins! 🚌</p>
<hr/>
<h3 data-id="heading-1">第一站：城市总览 —— 一张地图看懂全貌</h3>
<p>我们的城市 <code>all-vue/</code> 布局如下：</p>
<pre><code class="hljs language-csharp" lang="csharp">all-vue/
├── .vscode/                  <span class="hljs-meta"># 智能市政厅（IDE 配置中心）</span>
├── 项目架构图解/             <span class="hljs-meta"># 城市博物馆（学习资料档案馆）</span>
├── node_modules/             <span class="hljs-meta"># 万神殿（依赖神祇的居所）</span>
├── <span class="hljs-keyword">public</span>/                   <span class="hljs-meta"># 中央广场（静态资源直通区）</span>
├── src/                      <span class="hljs-meta"># 核心城区（源码心脏地带）</span>
│   ├── assets/               <span class="hljs-meta"># 艺术工坊（图标、SVG、字体）</span>
│   ├── components/           <span class="hljs-meta"># 工匠街区（可复用 UI 积木）</span>
│   ├── router/               <span class="hljs-meta"># 驿站总局（路由调度中枢）</span>
│   ├── views/                <span class="hljs-meta"># 行政办公区（页面级视图）</span>
│   ├── App.vue               <span class="hljs-meta"># 国师府（根组件，全局布局）</span>
│   ├── main.js               <span class="hljs-meta"># 王座厅（应用入口，创世起点）</span>
│   └── style.css             <span class="hljs-meta"># 染织局（全局样式规范）</span>
├── index.html                <span class="hljs-meta"># 城门广场（HTML 入口，迎接访客）</span>
├── package.json              <span class="hljs-meta"># 城市宪法（依赖与脚本律法）</span>
├── package-<span class="hljs-keyword">lock</span>.json         <span class="hljs-meta"># 户籍档案（锁定依赖版本）</span>
├── README.md                 <span class="hljs-meta"># 游客指南（项目说明书）</span>
├── vite.config.js            <span class="hljs-meta"># 城建总规（构建配置蓝图）</span>
└── .gitignore                <span class="hljs-meta"># 边境守则（Git 忽略规则）</span>
</code></pre>
<p>这不仅是一份目录列表——这是<strong>一座高度现代化、分工明确、自给自足的数字文明</strong>。</p>
<hr/>
<h3 data-id="heading-2">第二站：城门广场 —— <code>index.html</code>：欢迎来到 Vue 世界！</h3>
<p>一切旅程，始于城门。</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/favicon.ico"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vite + Vue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 神圣挂载点 --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<ul>
<li><strong><code>&lt;div id="app"&gt;</code></strong> 是整座城市的“祭坛”。<br/>
就像古希腊神庙中央的圣火，Vue 应用将在此显形、呼吸、生长。</li>
<li><strong>Vite 的魔法</strong>：无需手动引入 JS 文件！开发时，Vite 会自动注入 <code>&lt;script type="module" src="/src/main.js"&gt;</code>，实现原生 ES Module 加载。</li>
<li><strong><code>public/</code> 下的资源</strong>（如 <code>/favicon.ico</code>）直接映射到根路径，因为它们属于“公共基础设施”。</li>
</ul>
<blockquote>
<p><strong>冷知识</strong>：Vite 利用浏览器原生支持 <code>&lt;script type="module"&gt;</code> 的特性，跳过传统打包环节，实现<strong>毫秒级冷启动</strong>——这就是为什么你的项目“嗖”一下就打开了！</p>
</blockquote>
<hr/>
<h3 data-id="heading-3">第三站：王座厅 —— <code>src/main.js</code>：应用的诞生仪式</h3>
<p>走进核心城区，首先抵达的是<strong>王座厅</strong>——<code>main.js</code>。这里是整个 Vue 应用的“出生证明”：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createApp } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App.vue'</span>
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)
app.<span class="hljs-title function_">use</span>(router) <span class="hljs-comment">// 册封路由为宰相</span>
app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">'#app'</span>) <span class="hljs-comment">// 登基大典</span>
</code></pre>
<p>短短六行，完成三大创世行为：</p>
<ol>
<li><strong>召唤 Vue 实例</strong>：<code>createApp()</code> 创建应用容器。</li>
<li><strong>册封插件</strong>：<code>app.use(router)</code> 注册 Vue Router，赋予其导航权柄。</li>
<li><strong>登基挂载</strong>：<code>app.mount('#app')</code> 将虚拟 DOM 绑定到真实 DOM。</li>
</ol>
<blockquote>
<p><strong>Vue 3 的优雅</strong>：不再需要 <code>new Vue({})</code>，而是函数式 API，更轻量、更灵活。</p>
</blockquote>
<hr/>
<h3 data-id="heading-4">第四站：国师府 —— <code>App.vue</code>：全局布局与命运之镜</h3>
<p>接下来是<strong>国师府</strong>——<code>App.vue</code>，它是所有页面的“父容器”：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |
    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/about"</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 命运之镜 --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<ul>
<li><strong><code>&lt;router-view /&gt;</code></strong> 是“命运之镜”：它本身不渲染内容，而是<strong>动态插入当前路由匹配的组件</strong>（如 <code>Home.vue</code> 或 <code>About.vue</code>）。</li>
<li><strong><code>&lt;router-link&gt;</code></strong> 是“传送符”：点击即触发无刷新跳转，并自动添加 <code>.router-link-active</code> 类用于高亮。</li>
</ul>
<blockquote>
<p><strong>设计哲学</strong>：<code>App.vue</code> 只负责<strong>全局布局</strong>（导航栏、页脚），绝不掺和具体业务逻辑。页面内容，交给 <code>views/</code> 中的专业团队。</p>
</blockquote>
<hr/>
<h3 data-id="heading-5">第五站：行政办公区 —— <code>src/views/</code>：页面级组件的家园</h3>
<p>这里住着城市的“公务员”——页面级组件：</p>
<ul>
<li><strong><code>Home.vue</code></strong>：首页，展示核心功能或欢迎语。</li>
<li><strong><code>About.vue</code></strong>：关于页，讲述项目故事。</li>
</ul>
<p>每个 <code>.vue</code> 文件都是一个<strong>单文件组件（SFC）</strong> ，三位一体：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span> <span class="hljs-comment">&lt;!-- 视觉层 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>关于我们<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="xml"> <span class="hljs-comment">&lt;!-- 逻辑层 --&gt;</span>
export default { name: 'About' }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="xml"> <span class="hljs-comment">&lt;!-- 局部样式 --&gt;</span>
h1 { color: royalblue; }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<ul>
<li><strong><code>scoped</code> 样式</strong>：确保 CSS 仅作用于当前组件，避免“样式污染”——就像给每个办公室装上隔音墙。</li>
<li><strong>命名规范</strong>：大驼峰（PascalCase），如 <code>UserProfile.vue</code>，一眼识别为组件。</li>
</ul>
<hr/>
<h3 data-id="heading-6">第六站：工匠街区 —— <code>src/components/</code>：可复用 UI 的熔炉</h3>
<p>如果说 <code>views/</code> 是政府机构，那 <code>components/</code> 就是<strong>民间手工艺人聚集地</strong>。</p>
<ul>
<li><strong><code>HelloWorld.vue</code></strong> 是官方示例组件，常用于演示 props、事件等基础概念：</li>
</ul>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">props</span>: { <span class="hljs-attr">msg</span>: <span class="hljs-title class_">String</span> }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>在父组件中使用：</p>
<pre><code class="hljs language-ini" lang="ini">&lt;HelloWorld <span class="hljs-attr">msg</span>=<span class="hljs-string">"欢迎来到 Vue 宇宙！"</span> /&gt;
</code></pre>
<blockquote>
<p><strong>组件化思想</strong>：将 UI 拆分为独立、可组合、可测试的单元，是现代前端开发的基石。就像乐高积木，拼出无限可能。</p>
</blockquote>
<hr/>
<h3 data-id="heading-7">第七站：驿站总局 —— <code>src/router/index.js</code>：单页应用的交通网</h3>
<p>没有交通，城市就会瘫痪。而 <code>router/index.js</code> 正是这座城市的<strong>交通调度中心</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> { createRouter, createWebHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'../views/Home.vue'</span>

<span class="hljs-keyword">const</span> routes = [
  { <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> },
  { 
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/about'</span>, 
    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'../views/About.vue'</span>) <span class="hljs-comment">// 动态导入</span>
  }
]

<span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>({
  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(), <span class="hljs-comment">// 启用 HTML5 History 模式</span>
  routes
})

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router
</code></pre>
<h5 data-id="heading-8">关键技术亮点：</h5>
<ul>
<li><strong>无 <code>#</code> 的 URL</strong>：<code>createWebHistory()</code> 让地址变成 <code>/about</code> 而非 <code>/#/about</code>，更美观、SEO 友好。</li>
<li><strong>懒加载（Lazy Loading）</strong> ：<code>import()</code> 语法使 <code>About.vue</code> 仅在访问时加载，减少首屏体积。</li>
<li><strong>命名路由</strong>：<code>name: 'About'</code> 便于编程式导航（<code>router.push({ name: 'About' })</code>）。</li>
</ul>
<blockquote>
<p><strong>部署注意</strong>：若使用 History 模式，服务器需将所有路径 fallback 到 <code>index.html</code>，否则刷新会 404。</p>
</blockquote>
<hr/>
<h3 data-id="heading-9">第八站：艺术工坊 vs 中央广场 —— <code>assets/</code> 与 <code>public/</code> 的分工</h3>
<p>很多人混淆这两个目录，其实它们职责分明：</p>























<table><thead><tr><th>目录</th><th>用途</th><th>构建处理</th><th>引用方式</th></tr></thead><tbody><tr><td><code>src/assets/</code></td><td>组件内使用的资源（如 logo.png）</td><td>✅ 被 Vite 处理（哈希、压缩）</td><td><code>import img from '@/assets/logo.png'</code></td></tr><tr><td><code>public/</code></td><td>全局静态资源（如 favicon.ico）</td><td>❌ 原样复制</td><td><code>/favicon.ico</code></td></tr></tbody></table>
<blockquote>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>组件相关的图片 → <code>assets/</code></li>
<li>SEO/PWA 相关资源（manifest.json、robots.txt）→ <code>public/</code></li>
</ul>
</blockquote>
<hr/>
<h3 data-id="heading-10">第九站：城市宪法 —— <code>package.json</code> 与 <code>vite.config.js</code></h3>
<h4 data-id="heading-11"><code>package.json</code>：律法典籍</h4>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"dev"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite"</span><span class="hljs-punctuation">,</span>          <span class="hljs-comment">// 启动开发服务器</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite build"</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 构建生产代码</span>
    <span class="hljs-attr">"preview"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"vite preview"</span> <span class="hljs-comment">// 本地预览</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"vue"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^3.4.0"</span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">"vite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^5.0.0"</span> <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<ul>
<li><strong><code>dependencies</code></strong>：运行时必需（如 Vue）</li>
<li><strong><code>devDependencies</code></strong>：仅开发时需要（如 Vite）</li>
</ul>
<h4 data-id="heading-12"> <code>vite.config.js</code>：城建总规</h4>
<pre><code class="hljs language-php" lang="php">import { defineConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'vite'</span>
import vue <span class="hljs-keyword">from</span> <span class="hljs-string">'@vitejs/plugin-vue'</span>
import path <span class="hljs-keyword">from</span> <span class="hljs-string">'node:path'</span>

export <span class="hljs-keyword">default</span> <span class="hljs-title function_ invoke__">defineConfig</span>({
  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_ invoke__">vue</span>()],
  <span class="hljs-attr">resolve</span>: {
    <span class="hljs-attr">alias</span>: { <span class="hljs-string">'@'</span>: path.<span class="hljs-title function_ invoke__">resolve</span>(__dirname, <span class="hljs-string">'./src'</span>) }
  },
  <span class="hljs-attr">server</span>: {
    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>,
    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span> // 自动打开浏览器
  }
})
</code></pre>
<ul>
<li><strong>路径别名 <code>@</code></strong> ：<code>import Home from '@/views/Home.vue'</code> 更简洁。</li>
<li><strong>可扩展性</strong>：轻松添加代理、CSS 预处理器、PWA 插件等。</li>
</ul>
<hr/>
<h3 data-id="heading-13">第十站：魔法助手 —— 开发体验的极致优化</h3>
<h4 data-id="heading-14">Volar：Vue 的智能先知</h4>
<ul>
<li>
<p>VS Code 官方插件，提供：</p>
<ul>
<li>语法高亮</li>
<li>智能提示</li>
<li>重构支持</li>
<li>类型推导（即使使用 JS）</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>建议</strong>：禁用旧版 Vetur，启用 Volar 并开启 “Take Over Mode”。</p>
</blockquote>
<h4 data-id="heading-15">Vue Devtools：灵魂透视镜</h4>
<p>Chrome 插件，F12 打开后新增 “Vue” 标签页：</p>
<ul>
<li>实时查看组件树</li>
<li>监听响应式数据变化</li>
<li>追踪路由历史</li>
<li>分析性能瓶颈</li>
</ul>
<hr/>
<h3 data-id="heading-16">整体流程：从启动到渲染的奇幻旅程</h3>
<pre><code class="hljs language-css" lang="css">graph <span class="hljs-selector-tag">TD</span>
  <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[启动项目]</span> --&gt; <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[npm run dev]</span>
  <span class="hljs-selector-tag">B</span> --&gt; C<span class="hljs-selector-attr">[Vite 开发服务器启动]</span>
  C --&gt; D<span class="hljs-selector-attr">[监听 src/ 目录变化]</span>
  D --&gt; E<span class="hljs-selector-attr">[热更新：文件修改 → 浏览器自动刷新]</span>
  E --&gt; F<span class="hljs-selector-attr">[打开 http://localhost:5173]</span>

  G<span class="hljs-selector-attr">[index.html]</span> --&gt; H<span class="hljs-selector-attr">[#app 挂载点]</span>
  H --&gt; <span class="hljs-selector-tag">I</span><span class="hljs-selector-attr">[src/main.js]</span>
  <span class="hljs-selector-tag">I</span> --&gt; J<span class="hljs-selector-attr">[创建 Vue 实例]</span>
  J --&gt; K<span class="hljs-selector-attr">[注册 router]</span>
  K --&gt; L<span class="hljs-selector-attr">[渲染 App.vue]</span>
  L --&gt; M<span class="hljs-selector-attr">[&lt;router-view&gt; 渲染当前页面]</span>
</code></pre>
<blockquote>
<p><strong>热更新原理</strong>：Vite 利用 WebSocket 监听文件变化，仅更新修改的模块，无需整页刷新——快到你几乎感觉不到延迟！</p>
</blockquote>
<hr/>
<h3 data-id="heading-17">结语：你不仅是开发者，更是文明缔造者</h3>
<p>这套 <code>Vue 3 + Vite + Vue Router</code> 项目结构，之所以被称为“优秀架构”，是因为它完美体现了现代前端工程化的五大支柱：</p>





























<table><thead><tr><th>支柱</th><th>实现方式</th></tr></thead><tbody><tr><td><strong>模块化</strong></td><td><code>components/</code>, <code>views/</code>, <code>utils/</code> 分离职责</td></tr><tr><td><strong>可维护性</strong></td><td>单一职责 + 清晰目录</td></tr><tr><td><strong>可扩展性</strong></td><td>插件化架构（Vite + Vue 生态）</td></tr><tr><td><strong>开发体验</strong></td><td>热更新 + 智能提示 + Devtools</td></tr><tr><td><strong>生产优化</strong></td><td>代码分割 + 压缩 + 缓存策略</td></tr></tbody></table>
<p>当你下次创建新项目，请记住：<br/>
<strong>你不是在写代码——你是在建造一座可以自我演化、持续生长的数字文明。</strong></p>
<p>而 <code>all-vue</code>，正是这座文明的第一块基石。</p>
<blockquote>
<p> <strong>“npm run dev” 不仅启动了一个服务器——它点燃了一个宇宙的星辰。”</strong><br/>
现在，轮到你去书写它的未来了。🚀</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[react---JSX完全指南：从基础语法到进阶实战]]></title>    <link>https://juejin.cn/post/7584319403862016035</link>    <guid>https://juejin.cn/post/7584319403862016035</guid>    <pubDate>2025-12-17T03:19:49.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584319403862016035" data-draft-id="7584319403861983267" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="react---JSX完全指南：从基础语法到进阶实战"/> <meta itemprop="keywords" content="React.js,前端框架"/> <meta itemprop="datePublished" content="2025-12-17T03:19:49.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端无涯"/> <meta itemprop="url" content="https://juejin.cn/user/3967483738859639"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            react---JSX完全指南：从基础语法到进阶实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3967483738859639/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端无涯
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:19:49.000Z" title="Wed Dec 17 2025 03:19:49 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读12分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>​</p>
<blockquote>
<p>JSX（JavaScript XML）是 React 生态中最具辨识度的特性之一，它将类 HTML 的语法嵌入 JavaScript 中，让开发者能够以直观的方式编写 UI 结构，同时保留 JavaScript 的逻辑能力。很多开发者最初会将 JSX 误认为是 “HTML 在 JS 中的变体”，但实际上它是 JavaScript 的语法糖，最终会被编译为普通的 JavaScript 函数调用。本文将从<strong>本质、基础语法、进阶用法、常见误区</strong>四个维度，全面解析 JSX 的使用方法，帮助你彻底掌握这一核心技能。</p>
</blockquote>
<h2 data-id="heading-0">一、JSX 是什么？—— 不止是 “HTML+JS”</h2>
<h3 data-id="heading-1">1. JSX 的本质：语法糖</h3>
<p>JSX 是 Facebook 为 React 开发的一种语法扩展，其核心作用是<strong>简化 React 元素的创建</strong>。当我们编写 JSX 代码时，Babel（或 TypeScript）会将其编译为 React 的<code>createElement</code>函数调用（React 17 + 也支持更简洁的<code>jsx</code>/<code>jsxs</code>函数）。</p>
<p><strong>举个例子</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 我们编写的JSX代码</span>
<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"title"</span>&gt;</span>Hello, JSX!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>编译后的 JavaScript 代码</strong>（React 17 之前）：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">const</span> element = React.<span class="hljs-built_in">createElement</span>(
  <span class="hljs-string">'h1'</span>, <span class="hljs-comment">// 元素类型</span>
  { className: <span class="hljs-string">'title'</span> }, <span class="hljs-comment">// 元素属性</span>
  <span class="hljs-string">'Hello, JSX!'</span> <span class="hljs-comment">// 子元素</span>
);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>React 17 + 的编译结果</strong>（无需显式引入 React）：</p>
<pre><code class="hljs language-php" lang="php">import { jsx <span class="hljs-keyword">as</span> _jsx } <span class="hljs-keyword">from</span> <span class="hljs-string">'react/jsx-runtime'</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">element</span> = <span class="hljs-title function_ invoke__">_jsx</span>(<span class="hljs-string">'h1'</span>, {
  <span class="hljs-attr">className</span>: <span class="hljs-string">'title'</span>,
  <span class="hljs-attr">children</span>: <span class="hljs-string">'Hello, JSX!'</span>
});
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p>从编译结果可以看出：<strong>JSX 最终会被转换为描述 UI 的 JavaScript 对象（React 元素）</strong> ，而不是直接渲染为 DOM 节点。这也是 JSX 能够与 JavaScript 逻辑无缝结合的根本原因。</p>
<h3 data-id="heading-2">2. 为什么要用 JSX？</h3>
<p>在 JSX 出现之前，开发者需要通过<code>React.createElement</code>手动创建 UI 元素，代码冗长且可读性差。JSX 的出现解决了以下问题：</p>
<ul>
<li><strong>直观性</strong>：类 HTML 的语法让 UI 结构一目了然，比纯 JavaScript 代码更易读、易维护；</li>
<li><strong>无缝集成逻辑</strong>：可以在 JSX 中直接嵌入 JavaScript 表达式，实现 UI 与业务逻辑的紧密结合；</li>
<li><strong>编译时检查</strong>：Babel 和 TypeScript 会在编译阶段检查 JSX 的语法错误，提前规避运行时问题；</li>
<li><strong>组件化支持</strong>：JSX 天然支持 React 组件的嵌套和组合，是 React 组件化思想的核心载体。</li>
</ul>
<blockquote>
<p>注意：JSX 并非 React 的强制要求，你可以始终使用<code>React.createElement</code>编写代码，但几乎所有 React 项目都会选择 JSX 以提升开发效率。</p>
</blockquote>
<h2 data-id="heading-3">二、JSX 的核心语法规则：必掌握的基础</h2>
<p>JSX 虽然看起来像 HTML，但本质是 JavaScript，因此有一套自己的语法规则。以下是最核心的规则，也是新手最容易踩坑的地方。</p>
<h3 data-id="heading-4">1. 标签必须闭合</h3>
<p>与 HTML 不同，JSX 要求所有标签必须显式闭合，包括单标签（如<code>&lt;input&gt;</code>、<code>&lt;img&gt;</code>）。</p>
<pre><code class="hljs language-ini" lang="ini">// 错误：标签未闭合
const <span class="hljs-attr">input</span> = &lt;input type=<span class="hljs-string">"text"</span>&gt;<span class="hljs-comment">;</span>
const <span class="hljs-attr">img</span> = &lt;img src=<span class="hljs-string">"logo.png"</span>&gt;<span class="hljs-comment">;</span>

// 正确：单标签使用自闭合语法
const <span class="hljs-attr">input</span> = &lt;input type=<span class="hljs-string">"text"</span> /&gt;<span class="hljs-comment">;</span>
const <span class="hljs-attr">img</span> = &lt;img src=<span class="hljs-string">"logo.png"</span> alt=<span class="hljs-string">"logo"</span> /&gt;<span class="hljs-comment">;</span>

// 双标签必须成对出现
const <span class="hljs-attr">div</span> = &lt;div&gt;Hello, JSX&lt;/div&gt;<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-5">2. 只能有一个根元素</h3>
<p>JSX 表达式中<strong>不能直接返回多个同级元素</strong>，必须用一个根元素包裹（或使用 Fragment 片段）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误：多个根元素</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// 正确：用div作为根元素</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-6">3. 类名使用<code>className</code>而非<code>class</code></h3>
<p>在 JavaScript 中，<code>class</code>是关键字，因此 JSX 中不能使用<code>class</code>属性定义 CSS 类名，而是使用<code>className</code>（对应 DOM 的<code>className</code>属性）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误：使用class关键字</span>
<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;

<span class="hljs-comment">// 正确：使用className</span>
<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"container"</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<blockquote>
<p>补充：在 React Native 中，类名使用<code>style</code>属性，而不是<code>className</code>。</p>
</blockquote>
<h3 data-id="heading-7">4. 表单标签的<code>for</code>属性改为<code>htmlFor</code></h3>
<p>同理，<code>for</code>是 JavaScript 的关键字，JSX 中使用<code>htmlFor</code>替代<code>&lt;label&gt;</code>标签的<code>for</code>属性。</p>
<pre><code class="hljs language-ini" lang="ini">// 错误：使用for关键字
const <span class="hljs-attr">label</span> = &lt;label for=<span class="hljs-string">"username"</span>&gt;用户名：&lt;/label&gt;<span class="hljs-comment">;</span>

// 正确：使用htmlFor
const <span class="hljs-attr">label</span> = &lt;label htmlFor=<span class="hljs-string">"username"</span>&gt;用户名：&lt;/label&gt;<span class="hljs-comment">;</span>
&lt;input <span class="hljs-attr">id</span>=<span class="hljs-string">"username"</span> type=<span class="hljs-string">"text"</span> /&gt;<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-8">5. 内联样式是对象形式</h3>
<p>JSX 中的内联样式不能直接写 CSS 字符串，而是需要传递一个<strong>样式对象</strong>，属性名采用驼峰命名法（如<code>fontSize</code>而非<code>font-size</code>）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 错误：CSS字符串形式</span>
<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"font-size: 16px; color: red;"</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;

<span class="hljs-comment">// 正确：样式对象形式</span>
<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">fontSize:</span> '<span class="hljs-attr">16px</span>', <span class="hljs-attr">color:</span> '<span class="hljs-attr">red</span>' }}&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;

<span class="hljs-comment">// 推荐：将样式抽离为变量</span>
<span class="hljs-keyword">const</span> textStyle = {
  <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'16px'</span>,
  <span class="hljs-attr">color</span>: <span class="hljs-string">'red'</span>,
  <span class="hljs-attr">marginTop</span>: <span class="hljs-string">'10px'</span> <span class="hljs-comment">// 驼峰命名法</span>
};
<span class="hljs-keyword">const</span> element = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{textStyle}</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-9">6. 插入 JavaScript 表达式：使用<code>{}</code></h3>
<p>这是 JSX 最强大的特性之一：可以通过大括号<code>{}</code>在 JSX 中嵌入任意有效的 JavaScript 表达式（注意：是<strong>表达式</strong>，不是语句）。</p>
<pre><code class="hljs language-ini" lang="ini">// 1. 变量
const <span class="hljs-attr">name</span> = <span class="hljs-string">'React'</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">element</span> = &lt;h1&gt;Hello, {name}!&lt;/h1&gt;<span class="hljs-comment">;</span>

// 2. 算术运算
const <span class="hljs-attr">a</span> = <span class="hljs-number">10</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">b</span> = <span class="hljs-number">20</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">element</span> = &lt;p&gt;<span class="hljs-number">10</span> + <span class="hljs-number">20</span> = {a + b}&lt;/p&gt;<span class="hljs-comment">;</span>

// 3. 函数调用
const <span class="hljs-attr">getGreeting</span> = (name) =&gt; `Hello, <span class="hljs-variable">${name}</span>!`<span class="hljs-comment">;</span>
const <span class="hljs-attr">element</span> = &lt;h1&gt;{getGreeting(<span class="hljs-string">'JSX'</span>)}&lt;/h1&gt;<span class="hljs-comment">;</span>

// 4. 三元运算符（条件表达式）
const <span class="hljs-attr">isLogin</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">element</span> = &lt;p&gt;{isLogin ? <span class="hljs-string">'已登录'</span> : <span class="hljs-string">'请登录'</span>}&lt;/p&gt;<span class="hljs-comment">;</span>

// 5. 数组（会自动展开）
const <span class="hljs-attr">list</span> = [<span class="hljs-string">'苹果'</span>, <span class="hljs-string">'香蕉'</span>, <span class="hljs-string">'橙子'</span>]<span class="hljs-comment">;</span>
const <span class="hljs-attr">element</span> = &lt;div&gt;{list}&lt;/div&gt;<span class="hljs-comment">; // 渲染为：&lt;div&gt;苹果香蕉橙子&lt;/div&gt;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<blockquote>
<p>注意：<code>{}</code>中只能放<strong>表达式</strong>（有返回值的代码），不能放<strong>语句</strong>（如 if、for、switch 等）。如果需要使用语句，需在 JSX 外部处理。</p>
</blockquote>
<h3 data-id="heading-10">7. JSX 中的注释</h3>
<p>JSX 中的注释需要写在<code>{}</code>内，格式为<code>/* 注释内容 */</code>（单行注释也可以用<code>//</code>，但需要注意换行）。</p>
<pre><code class="hljs language-css" lang="css">const element = (
  &lt;<span class="hljs-selector-tag">div</span>&gt;
    {<span class="hljs-comment">/* 这是JSX中的多行注释 */</span>}
    &lt;<span class="hljs-selector-tag">h1</span>&gt;Hello, JSX!&lt;/<span class="hljs-selector-tag">h1</span>&gt;
    {<span class="hljs-comment">/* 单行注释也可以这样写 */</span>}
    {<span class="hljs-comment">/*
      多行注释
      可以换行
    */</span>}
    &lt;<span class="hljs-selector-tag">p</span>&gt;{<span class="hljs-comment">/* 行内注释 */</span>}这是内容&lt;/<span class="hljs-selector-tag">p</span>&gt;
  &lt;/<span class="hljs-selector-tag">div</span>&gt;
);

// 单行注释的另一种写法（注意换行）
const element = (
  &lt;<span class="hljs-selector-tag">div</span>&gt;
    {<span class="hljs-comment">/* 推荐 */</span>}
    &lt;<span class="hljs-selector-tag">h1</span>&gt;Hello, JSX!&lt;/<span class="hljs-selector-tag">h1</span>&gt;
    // 这种写法会报错，因为//不在{}内
    &lt;<span class="hljs-selector-tag">p</span>&gt;{// 这种写法可行，但需要换行
      '内容'}&lt;/<span class="hljs-selector-tag">p</span>&gt;
  &lt;/<span class="hljs-selector-tag">div</span>&gt;
);
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-11">三、JSX 的进阶用法：从基础到实战</h2>
<p>掌握了基础语法后，我们来看看 JSX 在实际开发中的高频进阶用法。</p>
<h3 data-id="heading-12">1. 片段（Fragment）：避免多余的根节点</h3>
<p>前面提到 JSX 必须有一个根元素，但有时我们不想添加额外的<code>&lt;div&gt;</code>等节点（避免 DOM 层级过深），此时可以使用<strong>React Fragment</strong>（片段），它会在渲染时被忽略，只保留子元素。</p>
<h4 data-id="heading-13">用法 1：<code>&lt;React.Fragment&gt;</code></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span>
  );
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-14">用法 2：空标签<code>&lt;&gt; &lt;/&gt;</code>（简写形式）</h4>
<p>这是 React 16.2 + 支持的简写语法，功能与<code>&lt;React.Fragment&gt;</code>一致，但<strong>不支持添加属性</strong>（如 key）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-15">用法 3：带 key 的 Fragment（仅支持完整写法）</h4>
<p>当在列表中渲染 Fragment 时，需要为其添加 key 属性，此时必须使用完整的<code>&lt;React.Fragment&gt;</code>。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> list = [
  { <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">'第一项'</span> },
  { <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">'第二项'</span> }
];

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {list.map(item =&gt; (
        <span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{item.text}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span>
      ))}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-16">2. 列表渲染：使用<code>map</code>并添加<code>key</code></h3>
<p>在 JSX 中渲染列表（如数组）时，通常使用<code>Array.prototype.map</code>方法，且<strong>必须为每个列表项添加唯一的<code>key</code>属性</strong>。</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">todos</span> = [
  { id: <span class="hljs-number">1</span>, text: <span class="hljs-string">'学习JSX'</span> },
  { id: <span class="hljs-number">2</span>, text: <span class="hljs-string">'学习React'</span> },
  { id: <span class="hljs-number">3</span>, text: <span class="hljs-string">'开发项目'</span> }
]<span class="hljs-comment">;</span>

const <span class="hljs-attr">TodoList</span> = () =&gt; {
  return (
    &lt;ul&gt;
      {todos.map(<span class="hljs-attr">todo</span> =&gt; (
        // 正确：使用唯一的id作为key
        &lt;li <span class="hljs-attr">key</span>={todo.id}&gt;{todo.text}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  )<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-17">关于<code>key</code>的重要注意事项：</h4>
<ul>
<li><code>key</code>的作用：帮助 React 识别列表中元素的变化（添加、删除、排序），从而优化渲染性能；</li>
<li><code>key</code>必须是<strong>唯一的</strong>：在同一列表中，每个元素的 key 不能重复；</li>
<li><strong>不要使用索引作为 key</strong>：如果列表的顺序发生变化（如排序、删除），索引会重新分配，导致 React 误判元素变化，引发性能问题或渲染错误；</li>
<li><code>key</code>只在列表内部有效：key 是给 React 看的，不会传递给组件，因此不能在组件内部通过<code>props.key</code>获取。</li>
</ul>
<h3 data-id="heading-18">3. 条件渲染：多种实现方式</h3>
<p>在 JSX 中实现条件渲染有多种方式，可根据场景选择：</p>
<h4 data-id="heading-19">方式 1：三元运算符（适合简单条件）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> isLogin = <span class="hljs-literal">true</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">UserInfo</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {isLogin ? (
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>欢迎回来，用户！<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      ) : (
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>请登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      )}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-20">方式 2：逻辑与运算符<code>&amp;&amp;</code>（适合 “存在即渲染” 的场景）</h4>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">hasUnreadMsg</span> = <span class="hljs-literal">true</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">unreadCount</span> = <span class="hljs-number">5</span><span class="hljs-comment">;</span>

const <span class="hljs-attr">MsgTip</span> = () =&gt; {
  return (
    &lt;div&gt;
      {/* 当hasUnreadMsg为true时，渲染后面的元素；为false时，返回false，不渲染 */}
      {hasUnreadMsg &amp;&amp; &lt;span <span class="hljs-attr">className</span>=<span class="hljs-string">"badge"</span>&gt;{unreadCount}&lt;/span&gt;}
    &lt;/div&gt;
  )<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-21">方式 3：外部条件语句（适合复杂条件）</h4>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">UserRole</span> = ({ role }) =&gt; {
  // 外部定义渲染逻辑
  let content<span class="hljs-comment">;</span>
  if (<span class="hljs-attr">role</span> === <span class="hljs-string">'admin'</span>) {
    <span class="hljs-attr">content</span> = &lt;p&gt;管理员&lt;/p&gt;<span class="hljs-comment">;</span>
  } else if (<span class="hljs-attr">role</span> === <span class="hljs-string">'user'</span>) {
    <span class="hljs-attr">content</span> = &lt;p&gt;普通用户&lt;/p&gt;<span class="hljs-comment">;</span>
  } else {
    <span class="hljs-attr">content</span> = &lt;p&gt;游客&lt;/p&gt;<span class="hljs-comment">;</span>
  }

  return &lt;div&gt;{content}&lt;/div&gt;<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h4 data-id="heading-22">方式 4：组件提取（适合极复杂的条件）</h4>
<p>将不同条件的渲染逻辑提取为独立组件，让代码更清晰。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">AdminPanel</span> = (<span class="hljs-params"/>) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>管理员面板<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">UserPanel</span> = (<span class="hljs-params"/>) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户面板<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">GuestPanel</span> = (<span class="hljs-params"/>) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>游客面板<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">Panel</span> = (<span class="hljs-params">{ role }</span>) =&gt; {
  <span class="hljs-keyword">switch</span> (role) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'admin'</span>:
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">AdminPanel</span> /&gt;</span></span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'user'</span>:
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">UserPanel</span> /&gt;</span></span>;
    <span class="hljs-attr">default</span>:
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">GuestPanel</span> /&gt;</span></span>;
  }
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-23">4. 自定义组件的渲染：首字母大写</h3>
<p>在 JSX 中渲染自定义 React 组件时，<strong>组件名必须以大写字母开头</strong>（这是 React 的约定，用于区分原生 HTML 标签）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 正确：组件名首字母大写</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Button</span> = (<span class="hljs-params"/>) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>自定义按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> /&gt;</span> {/* 渲染自定义组件 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>原生按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> {/* 渲染原生HTML标签 */}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-comment">// 错误：组件名小写，React会将其视为原生HTML标签（不存在的标签会渲染为&lt;div&gt;或报错）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">button</span> = (<span class="hljs-params"/>) =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>自定义按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> /&gt;</span></span>; <span class="hljs-comment">// 渲染原生&lt;button&gt;，而非自定义组件</span>
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h3 data-id="heading-24">5. 属性传递（Props）：向组件传递数据</h3>
<p>可以通过 JSX 的属性（props）向自定义组件传递数据，属性名同样采用驼峰命名法（如<code>onClick</code>、<code>dataId</code>）。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 子组件接收props</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Greeting</span> = (<span class="hljs-params">props</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {props.name}!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
};

<span class="hljs-comment">// 父组件传递props</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      {/* 传递字符串属性 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"React"</span> /&gt;</span>
      {/* 传递非字符串属性（需用{}包裹） */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">{123}</span> /&gt;</span>
      {/* 传递布尔值 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">isShow</span>=<span class="hljs-string">{true}</span> /&gt;</span>
      {/* 传递函数 */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> <span class="hljs-attr">onButtonClick</span>=<span class="hljs-string">{()</span> =&gt;</span> alert('点击了')} /&gt;
      {/* 传递JSX元素（子元素，对应props.children） */}
      <span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是子元素<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Greeting</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<blockquote>
<p>补充：<code>props.children</code>是一个特殊的 props，用于接收组件的子元素（如上面的<code>&lt;p&gt;这是子元素&lt;/p&gt;</code>）。</p>
</blockquote>
<h3 data-id="heading-25">6. 危险的 HTML 渲染：<code>dangerouslySetInnerHTML</code></h3>
<p>默认情况下，React 会转义 JSX 中的所有内容，防止 XSS 攻击（跨站脚本攻击）。但有时我们需要渲染原始的 HTML 字符串（如后端返回的富文本），此时可以使用<code>dangerouslySetInnerHTML</code>属性（注意：使用该属性存在安全风险，需确保内容是可信的）。</p>
<pre><code class="hljs language-css" lang="css">// 原始<span class="hljs-selector-tag">HTML</span>字符串
const htmlContent = '&lt;<span class="hljs-selector-tag">p</span> style="<span class="hljs-attribute">color</span>: red;"&gt;这是富文本内容&lt;/<span class="hljs-selector-tag">p</span>&gt;';

// 错误：React会转义<span class="hljs-selector-tag">HTML</span>标签，渲染为纯文本
const element = &lt;<span class="hljs-selector-tag">div</span>&gt;{htmlContent}&lt;/<span class="hljs-selector-tag">div</span>&gt;;

// 正确：使用dangerouslySetInnerHTML渲染原始<span class="hljs-selector-tag">HTML</span>
const element = &lt;<span class="hljs-selector-tag">div</span> dangerouslySetInnerHTML={{ __html: htmlContent }} /&gt;;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<blockquote>
<p>警告：<strong>不要将用户输入的内容直接通过 dangerouslySetInnerHTML 渲染</strong>，否则可能导致 XSS 攻击。如果必须渲染用户输入，需先进行 HTML 转义或过滤。</p>
</blockquote>
<h3 data-id="heading-26">7. JSX 作为变量、返回值和参数</h3>
<p>由于 JSX 最终会被编译为 JavaScript 对象，因此它可以作为变量存储、作为函数返回值、作为参数传递给函数。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 作为变量</span>
<span class="hljs-keyword">const</span> header = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, JSX<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;

<span class="hljs-comment">// 2. 作为函数返回值</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getHeader</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, JSX<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
};

<span class="hljs-comment">// 3. 作为参数传递</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">renderElement</span> = (<span class="hljs-params">element</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{element}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params"/>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">renderElement</span>(header);
};
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<h2 data-id="heading-27">四、JSX 的常见误区与避坑指南</h2>
<p>即使是有经验的开发者，也可能在使用 JSX 时踩坑。以下是最常见的误区及解决方案：</p>
<h3 data-id="heading-28">误区 1：混淆 HTML 和 JSX 的语法差异</h3>
<p><strong>问题</strong>：使用<code>class</code>、<code>for</code>、<code>style</code>等 HTML 属性，导致语法错误或样式不生效。<strong>解决方案</strong>：牢记 JSX 的属性替换规则：</p>
<ul>
<li><code>class</code> → <code>className</code></li>
<li><code>for</code> → <code>htmlFor</code></li>
<li><code>style</code> → 驼峰命名的样式对象</li>
<li>自定义属性：使用<code>data-*</code>前缀（如<code>data-id</code>），React 会保留这些属性。</li>
</ul>
<h3 data-id="heading-29">误区 2：在<code>{}</code>中使用语句（而非表达式）</h3>
<p><strong>问题</strong>：在 JSX 的<code>{}</code>中写入 if、for、switch 等语句，导致编译错误。</p>
<p>jsx</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 错误：if是语句，不能放在{}内</span>
<span class="hljs-keyword">const</span> element = &lt;div&gt;{<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span> }}&lt;/div&gt;;
</code></pre>
<p><img src="" alt="" title="点击并拖拽以移动" loading="lazy"/></p>
<p><strong>解决方案</strong>：将语句移到 JSX 外部，或使用三元运算符、逻辑与等表达式替代。</p>
<h3 data-id="heading-30">误区 3：列表渲染忘记加<code>key</code>或使用索引作为<code>key</code></h3>
<p><strong>问题</strong>：列表渲染时未添加<code>key</code>，控制台出现警告；或使用索引作为<code>key</code>，导致列表排序 / 删除时渲染异常。<strong>解决方案</strong>：使用唯一的 ID（如后端返回的 id、UUID）作为<code>key</code>；如果确实没有唯一 ID，可考虑生成唯一标识（如<code>item.name + item.index</code>），但尽量避免使用索引。</p>
<h3 data-id="heading-31">误区 4：过度使用<code>dangerouslySetInnerHTML</code></h3>
<p><strong>问题</strong>：随意使用<code>dangerouslySetInnerHTML</code>渲染不可信内容，导致 XSS 攻击风险。<strong>解决方案</strong>：</p>
<ul>
<li>尽量避免使用<code>dangerouslySetInnerHTML</code>；</li>
<li>如果必须使用，确保内容是可信的（如后端自己生成的富文本）；</li>
<li>对用户输入的内容进行 HTML 转义（如使用<code>he</code>库）。</li>
</ul>
<h3 data-id="heading-32">误区 5：忽略 JSX 的大小写敏感</h3>
<p><strong>问题</strong>：将原生 HTML 标签大写（如<code>&lt;Div&gt;</code>），或自定义组件小写（如<code>&lt;button&gt;</code>），导致渲染错误。<strong>解决方案</strong>：</p>
<ul>
<li>原生 HTML 标签：全小写（如<code>&lt;div&gt;</code>、<code>&lt;button&gt;</code>）；</li>
<li>自定义组件：首字母大写（如<code>&lt;Button&gt;</code>、<code>&lt;TodoList&gt;</code>）。</li>
</ul>
<h3 data-id="heading-33">误区 6：直接修改<code>props</code>或<code>state</code>后渲染 JSX</h3>
<p><strong>问题</strong>：修改<code>props</code>或<code>state</code>的原始值（如数组的<code>push</code>、对象的属性赋值），导致 React 无法检测到变化，JSX 不更新。<strong>解决方案</strong>：遵循 React 的不可变原则，创建新的数组 / 对象（如使用<code>concat</code>、<code>map</code>、<code>spread</code>运算符）。</p>
<h2 data-id="heading-34">五、JSX 的优势：为什么它能成为 React 的标配？</h2>
<p>总结一下，JSX 之所以能成为 React 开发的核心工具，主要有以下优势：</p>
<ol>
<li><strong>直观性</strong>：类 HTML 的语法让 UI 结构与代码逻辑分离但又紧密结合，比纯 JavaScript 更易读；</li>
<li><strong>灵活性</strong>：可以嵌入任意 JavaScript 表达式，实现复杂的逻辑渲染；</li>
<li><strong>安全性</strong>：默认转义内容，防止 XSS 攻击；</li>
<li><strong>组件化</strong>：天然支持 React 的组件化思想，便于复用和维护；</li>
<li><strong>跨平台</strong>：不仅可以用于 Web 端的 DOM 渲染，还可以用于 React Native 的原生组件渲染（语法一致，底层渲染不同）；</li>
<li><strong>工具支持</strong>：Babel、TypeScript、ESLint 等工具对 JSX 有完善的支持，提升开发效率。</li>
</ol>
<h2 data-id="heading-35">六、总结</h2>
<p>JSX 是 React 开发的基础，它不是 HTML，也不是新的编程语言，而是 JavaScript 的语法糖。掌握 JSX 的核心语法规则（如标签闭合、<code>className</code>、表达式插入）、进阶用法（如 Fragment、列表渲染、条件渲染）和避坑指南，是编写高效、可维护的 React 代码的关键。</p>
<p>值得一提的是，JSX 并非 React 的专属特性，Vue 3 也支持 JSX 语法，甚至一些其他前端框架也开始兼容 JSX。因此，学好 JSX 不仅能提升 React 开发能力，也是前端工程师的通用技能。</p>
<p>最后，记住：<strong>JSX 的本质是 JavaScript</strong>，所有 JavaScript 的特性都可以与 JSX 结合使用。不要被类 HTML 的语法迷惑，始终以 JavaScript 的思维来编写 JSX。</p>
<p>​</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[this有且仅有的五种指法]]></title>    <link>https://juejin.cn/post/7584319403862048803</link>    <guid>https://juejin.cn/post/7584319403862048803</guid>    <pubDate>2025-12-17T03:21:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584319403862048803" data-draft-id="7584319403862032419" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="this有且仅有的五种指法"/> <meta itemprop="keywords" content="JavaScript"/> <meta itemprop="datePublished" content="2025-12-17T03:21:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="OLong"/> <meta itemprop="url" content="https://juejin.cn/user/1072754539366318"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            this有且仅有的五种指法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1072754539366318/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    OLong
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:21:35.000Z" title="Wed Dec 17 2025 03:21:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>重点写在前面：</p>
<blockquote>
<p>我们并不知道我们写下的函数和方法是否被框架赋值过或显示绑定过而改变了this指向。以至this指向更加扑朔迷离。</p>
</blockquote>
<h2 data-id="heading-0">this 到底指向哪里</h2>
<blockquote>
<p>以下如果没提及，则为严格模式。</p>
</blockquote>
<p>js中作用域有两种:</p>
<ol>
<li>词法作用域</li>
<li>动态作用域</li>
</ol>
<h3 data-id="heading-1">词法作用域</h3>
<p>词法作用域指在书写代码时就被确定的作用域。
看如下代码</p>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;
        <span class="hljs-title function_">foo</span>();
    }

    <span class="hljs-title function_">bar</span>();<span class="hljs-comment">// 结果是1</span>
</code></pre>
<h3 data-id="heading-2">动态作用域</h3>
<p>动态作用域指在代码运行时才被确定的作用域。
js中<strong>只有this的作用域是动态作用域</strong></p>
<h2 data-id="heading-3">this的五种绑定</h2>
<p>初学js时，会想当然认为this遵循某一条规律，就像物理学那样，然而并不是。
this的绑定分为五种情况，这五种情况之间毫无规律可言。不过好在都很简单。</p>
<h3 data-id="heading-4">一. 默认绑定</h3>
<p>当以如下形式执行一个函数时，this为默认绑定；</p>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-title function_">func</span>()
</code></pre>
<ul>
<li>严格模式下，this为undefined</li>
<li>非严格模式下，this是全局对象。</li>
</ul>
<p>与函数调用嵌套多少层如何嵌套无关</p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-comment">/* 全是undefined */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">printThis</span>(<span class="hljs-params"/>){
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
}
<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-title function_">say</span>(<span class="hljs-params"/>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'obj.say'</span>,<span class="hljs-title function_">printThis</span>())
    }
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">funcB</span>(<span class="hljs-params"/>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'funcB'</span>,<span class="hljs-title function_">printThis</span>());
    obj.<span class="hljs-title function_">say</span>();
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'funcA'</span>,<span class="hljs-title function_">printThis</span>())
obj.<span class="hljs-title function_">say</span>()
<span class="hljs-title function_">funcB</span>()
</code></pre>
<h3 data-id="heading-5">二. 隐式绑定</h3>
<p>当以如下行驶执行一个函数时，this为隐式绑定；</p>
<pre><code class="hljs language-js" lang="js">a.<span class="hljs-property">b</span>.<span class="hljs-title function_">func</span>()
</code></pre>
<p>此时this指向<strong>点</strong>前面一个对象</p>
<h4 data-id="heading-6">赋值会改变隐式绑定this的指向</h4>
<ul>
<li>方法赋值给变量</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> {
    <span class="hljs-title function_">dotInvoke</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'dotInvoke'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sayThis</span>())
    }
    <span class="hljs-title function_">sayThis</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
    }
    <span class="hljs-title function_">assignInvoke</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">var</span> sayThis = <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayThis</span>;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'assignInvoke'</span>, <span class="hljs-title function_">sayThis</span>())
    }
}
<span class="hljs-keyword">var</span> tt = <span class="hljs-keyword">new</span> <span class="hljs-title function_">T</span>();
tt.<span class="hljs-title function_">dotInvoke</span>()<span class="hljs-comment">// 指向T</span>
tt.<span class="hljs-title function_">assignInvoke</span>()<span class="hljs-comment">// undefined</span>
</code></pre>
<ul>
<li>函数被赋值成方法</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printThis</span>(<span class="hljs-params"/>){
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
}
<span class="hljs-keyword">var</span> obj = {};
obj.<span class="hljs-property">say</span> = printThis;
obj.<span class="hljs-title function_">say</span>()<span class="hljs-comment">/* 指向obj */</span>
</code></pre>
<ul>
<li>赋值给参数
极为常见的是回调函数的this是undefined，因为回调函数被复制给参数，参数再调用时变成了默认绑定</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFun</span>(<span class="hljs-params">cb</span>){
    <span class="hljs-title function_">cb</span>()
}
<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-title function_">callback</span>(<span class="hljs-params"/>){
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)
    }
}
obj.<span class="hljs-title function_">callback</span>()<span class="hljs-comment">/*隐式绑定 obj */</span>
<span class="hljs-title function_">asyncFun</span>(obj.<span class="hljs-property">callback</span>);<span class="hljs-comment">/*默认绑定 undefined */</span>
</code></pre>
<h3 data-id="heading-7">三. 箭头函数</h3>
<p>箭头函数会让this指向最近的函数或全局作用域</p>
<ul>
<li>与最近的函数的this指向相同</li>
</ul>
<pre><code class="hljs language-js" lang="js">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 返回一个箭头函数</span>
        <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">a</span>)=&gt;</span>{
            <span class="hljs-comment">//this 继承自 foo()</span>
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>
        }
        ;
    }
    <span class="hljs-keyword">var</span> obj1 = {
        <span class="hljs-attr">a</span>: <span class="hljs-string">'obj1'</span>
    };
    <span class="hljs-keyword">var</span> obj2 = {
        <span class="hljs-attr">a</span>: <span class="hljs-string">'obj2'</span>
    }
    <span class="hljs-keyword">var</span> arrow1 = foo.<span class="hljs-title function_">call</span>(obj1);
    <span class="hljs-keyword">var</span> arrow2 = foo.<span class="hljs-title function_">call</span>(obj2);
    <span class="hljs-keyword">var</span> arrow3 = <span class="hljs-title function_">foo</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'arrow1'</span>,<span class="hljs-title function_">arrow1</span>())<span class="hljs-comment">/* obj1 */</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'arrow2'</span>,<span class="hljs-title function_">arrow2</span>())<span class="hljs-comment">/* obj2 */</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'arrow3'</span>,<span class="hljs-title function_">arrow3</span>())<span class="hljs-comment">/* undefined,严格模式下报错 */</span>
</code></pre>
<ul>
<li>指向全局</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">printThis</span> = (<span class="hljs-params"/>)=&gt;<span class="hljs-variable language_">this</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'printThis'</span>,<span class="hljs-title function_">printThis</span>());<span class="hljs-comment">/* global */</span>
</code></pre>
<ul>
<li>指向实例</li>
</ul>
<pre><code class="hljs language-js" lang="js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
    printThis = <span class="hljs-function">()=&gt;</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
    }
}
<span class="hljs-comment">//会被babel翻译成</span>
<span class="hljs-keyword">var</span> test = <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"/>) {
  <span class="hljs-keyword">var</span> _this = <span class="hljs-variable language_">this</span>;

  <span class="hljs-variable language_">this</span>.<span class="hljs-property">printThis</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> _this;
  };
};
</code></pre>
<h3 data-id="heading-8">四. 显示绑定</h3>
<p>call, apply, bind指定this指向</p>
<h3 data-id="heading-9">五. new绑定</h3>
<blockquote>
<p>构造函数，ES6中的class
new构造函数，new class时，this指向实例</p>
</blockquote>
<h2 data-id="heading-10">总结</h2>
<ol>
<li>五种绑定，后面两种情况单一，前面两种会因为方法，函数被赋值而互相转化。</li>
<li>因为this处于动态作用域，而目前开发时又大量使用框架。我们写下的代码，并不总是由我们自己调用，而是被打包工具打包后，由框架调用。<strong>导致我们并不知道我们写下的函数和方法是否被框架赋值过或显示绑定过而改变了this指向</strong>。以至this指向更加扑朔迷离。</li>
<li>写完本文顿时觉得，python里指向明确的self完爆js的this。</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[微信扫码登录 iframe 方案中的状态拦截陷阱]]></title>    <link>https://juejin.cn/post/7584319403862212643</link>    <guid>https://juejin.cn/post/7584319403862212643</guid>    <pubDate>2025-12-17T03:31:13.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584319403862212643" data-draft-id="7584298069611610112" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="微信扫码登录 iframe 方案中的状态拦截陷阱"/> <meta itemprop="keywords" content="前端,JavaScript,Vue.js"/> <meta itemprop="datePublished" content="2025-12-17T03:31:13.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鹏北海"/> <meta itemprop="url" content="https://juejin.cn/user/1425415102792237"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            微信扫码登录 iframe 方案中的状态拦截陷阱
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1425415102792237/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鹏北海
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:31:13.000Z" title="Wed Dec 17 2025 03:31:13 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">微信扫码登录 iframe 方案中的状态拦截陷阱</h2>
<h3 data-id="heading-1">背景</h3>
<p>在 Web 端实现微信扫码登录时，常见的方案是使用 iframe 嵌入微信二维码页面。用户扫码授权后，iframe 内部会重定向到我们配置的回调页面，回调页面再通过 <code>postMessage</code> 通知父页面完成登录。</p>
<p>最近在给登录流程增加「用户协议勾选」功能时，遇到了一个有趣的问题：<strong>用户勾选协议后扫码，在手机上确认授权前又取消了勾选，结果登录流程依然执行了</strong>。</p>
<h3 data-id="heading-2">问题现象</h3>
<p>预期行为：用户取消勾选协议 → 拦截登录流程 → 不跳转</p>
<p>实际行为：用户取消勾选协议 → 控制台显示"未同意协议，不触发事件" → <strong>页面依然跳转了</strong></p>
<h3 data-id="heading-3">架构分析</h3>
<p>整个微信登录的组件结构如下：</p>
<pre><code class="hljs language-scss" lang="scss">Login<span class="hljs-selector-class">.vue</span> (页面)
  └── Container<span class="hljs-selector-class">.vue</span>
        └── wxQrCodeLogin<span class="hljs-selector-class">.vue</span>
              └── <span class="hljs-selector-tag">iframe</span> (微信二维码)
                    └── WxLogin<span class="hljs-selector-class">.vue</span> (回调页面，iframe 内部)
</code></pre>
<p>登录流程：</p>
<ol>
<li>用户勾选协议 → 显示二维码（iframe）</li>
<li>用户手机扫码 → 微信授权页面</li>
<li>用户确认授权 → iframe 重定向到 <code>WxLogin.vue</code></li>
<li><code>WxLogin.vue</code> 调用后端接口获取 token</li>
<li>通过 <code>postMessage</code> 通知父页面</li>
<li>父页面完成登录跳转</li>
</ol>
<h3 data-id="heading-4">问题根因</h3>
<p>在 <code>wxQrCodeLogin.vue</code> 中，我添加了协议状态拦截：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"message"</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> {
  <span class="hljs-comment">// 未勾选协议，直接返回</span>
  <span class="hljs-keyword">if</span>(!isAgree.<span class="hljs-property">value</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"未同意协议，不触发事件"</span>);
    <span class="hljs-keyword">return</span>;
  }
​
  <span class="hljs-keyword">if</span>(msg.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === <span class="hljs-string">'1'</span>) {
    <span class="hljs-title function_">emit</span>(<span class="hljs-string">'qrLoginSuccess'</span>, msg.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>);
  }
});
</code></pre>
<p>看起来没问题，但实际上拦截失效了。原因在 <code>WxLogin.vue</code>（iframe 内的回调页面）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">if</span>(token) {
    <span class="hljs-title class_">Store</span>.<span class="hljs-title function_">set_cookie</span>(<span class="hljs-string">'token'</span>, token);  <span class="hljs-comment">// 问题在这里！</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'1'</span>, token }, <span class="hljs-string">'*'</span>);
}
</code></pre>
<p><strong>iframe 内部直接设置了 cookie！</strong></p>
<p>由于 iframe 和父页面同域，cookie 是共享的。当 token 被写入 cookie 后，主站的登录状态检测逻辑检测到 token，自动触发了页面跳转。</p>
<p>整个过程：</p>
<ol>
<li>微信授权成功 → iframe 内 <code>WxLogin.vue</code> 执行</li>
<li><code>Store.set_cookie('token', token)</code> → <strong>cookie 已写入</strong></li>
<li><code>postMessage</code> 发送给父页面</li>
<li>父页面 <code>isAgree</code> 检查 → 返回，不处理</li>
<li>但 cookie 已经存在 → 主站检测到登录状态 → 跳转</li>
</ol>
<p><strong>拦截的是 <code>postMessage</code>，但 cookie 的写入发生在 <code>postMessage</code> 之前，根本拦不住。</strong></p>
<h3 data-id="heading-5">解决方案</h3>
<h4 data-id="heading-6">核心原则</h4>
<p>iframe 回调页面只负责「中转」，不应该直接操作登录状态（cookie、localStorage 等）。状态的写入应该由父页面根据业务逻辑决定。</p>
<h4 data-id="heading-7">代码修改</h4>
<p><code>WxLogin.vue</code>（iframe 回调页面）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 修改前</span>
<span class="hljs-keyword">if</span>(token) {
    <span class="hljs-title class_">Store</span>.<span class="hljs-title function_">set_cookie</span>(<span class="hljs-string">'token'</span>, token);  <span class="hljs-comment">// 删除这行</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'1'</span>, token }, <span class="hljs-string">'*'</span>);
}
​
<span class="hljs-comment">// 修改后</span>
<span class="hljs-keyword">if</span>(token) {
    <span class="hljs-comment">// 只传递 token，不设置 cookie</span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">'1'</span>, token }, <span class="hljs-string">'*'</span>);
}
</code></pre>
<p>父页面在收到 <code>postMessage</code> 后，根据 <code>isAgree</code> 状态决定是否设置 cookie 并完成登录：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"message"</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span>(!isAgree.<span class="hljs-property">value</span>) {
    <span class="hljs-comment">// 可以弹出协议确认弹窗，让用户选择</span>
    <span class="hljs-keyword">return</span>;
  }
​
  <span class="hljs-keyword">if</span>(msg.<span class="hljs-property">data</span>.<span class="hljs-property">type</span> === <span class="hljs-string">'1'</span>) {
    <span class="hljs-comment">// 在这里设置 cookie</span>
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">loginCallback</span>({ <span class="hljs-attr">token</span>: msg.<span class="hljs-property">data</span>.<span class="hljs-property">token</span> });
    <span class="hljs-title function_">emit</span>(<span class="hljs-string">'qrLoginSuccess'</span>, msg.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>);
  }
});
</code></pre>
<h3 data-id="heading-8">延伸思考</h3>
<h4 data-id="heading-9">为什么 v-show 不能解决问题？</h4>
<p>最初尝试用 <code>v-show</code> 隐藏 iframe，但 <code>v-show</code> 只是 <code>display: none</code>，iframe 依然存在，内部的回调逻辑照常执行。</p>
<h4 data-id="heading-10">为什么 v-if 也有问题？</h4>
<p><code>v-if</code> 会销毁 iframe，但如果用户已经扫码进入微信授权页面，此时销毁 iframe 再重建，新的 iframe 无法接收之前扫码的授权回调，用户需要重新扫码。</p>
<h4 data-id="heading-11">最佳实践</h4>
<ol>
<li><strong>iframe 回调页面职责单一</strong>：只负责接收授权结果、调用后端接口、通过 <code>postMessage</code> 传递数据</li>
<li><strong>状态操作由父页面控制</strong>：cookie、localStorage、页面跳转等操作都应该在父页面根据业务状态决定</li>
<li><strong>考虑异步流程中的状态变化</strong>：用户可能在异步操作过程中改变状态，设计时要考虑这种边界情况</li>
</ol>
<h3 data-id="heading-12">总结</h3>
<p>这个问题的本质是<strong>职责划分不清晰</strong>导致的。iframe 内的回调页面越权操作了本应由父页面控制的登录状态，使得父页面的拦截逻辑形同虚设。</p>
<p>在设计跨窗口/跨 iframe 通信的功能时，要明确各个组件的职责边界，状态的写入和业务逻辑的执行应该集中在一个地方，避免分散导致的控制失效。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[📢 深度解析 Dify 核心 LLM 提示模板库，揭秘 AI 交互的「幕后魔法」]]></title>    <link>https://juejin.cn/post/7584319403861835811</link>    <guid>https://juejin.cn/post/7584319403861835811</guid>    <pubDate>2025-12-17T02:37:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584319403861835811" data-draft-id="7584297353420668928" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="📢 深度解析 Dify 核心 LLM 提示模板库，揭秘 AI 交互的「幕后魔法」"/> <meta itemprop="keywords" content="Agent,人工智能,LLM"/> <meta itemprop="datePublished" content="2025-12-17T02:37:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="AI达人说"/> <meta itemprop="url" content="https://juejin.cn/user/803109340980496"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            📢 深度解析 Dify 核心 LLM 提示模板库，揭秘 AI 交互的「幕后魔法」
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/803109340980496/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    AI达人说
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:37:37.000Z" title="Wed Dec 17 2025 02:37:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>想了解企业级 AI 应用如何保证生成内容的一致性和质量？这份对 Dify 项目 <code>core/llm_generator/prompts.py</code> 的深度解读绝对值得收藏！</p>
</blockquote>
<p>🔍 <strong>核心亮点：</strong></p>
<ul>
<li>11 种精心设计的 LLM 提示模板（对话标题生成、代码生成、问题预测等）</li>
<li>参数化模板设计，支持动态内容注入</li>
<li>明确的指令约束，确保 AI 输出的可靠性</li>
<li>多语言支持，自动适配用户输入</li>
<li>分层架构，包含基础模板和元模板</li>
</ul>
<p>💼 <strong>应用场景全覆盖：</strong></p>
<ul>
<li>智能对话系统（标题生成、后续问题预测）</li>
<li>代码自动化（Python/JavaScript 代码生成）</li>
<li>内容生成（问答对、文档摘要）</li>
<li>工作流自动化（规则配置、参数提取）</li>
<li>数据管理（JSON Schema 生成、结构化输出）</li>
</ul>
<p>📚 <strong>技术价值：</strong>
这份文档不仅分析了模板的功能和设计要点，还提供了代码优化建议（模板组织、加载机制、验证机制），是 AI 工程师和开发者学习提示工程的绝佳参考！</p>
<h2 data-id="heading-0">core/llm_generator/prompts.py 文件解读</h2>
<h3 data-id="heading-1">1. 文件概述</h3>
<p><code>core/llm_generator/prompts.py</code>是一个集中管理LLM（大语言模型）提示模板的Python文件。该文件定义了一系列精心设计的提示字符串常量，用于指导LLM完成各种特定任务，如生成对话标题、代码生成、问题预测、问答对生成等。</p>
<p><strong>主要功能</strong>：</p>
<ul>
<li>提供标准化的LLM提示模板</li>
<li>支持参数化模板替换</li>
<li>定义明确的任务指令和输出格式</li>
<li>确保LLM生成结果的一致性和可靠性</li>
</ul>
<h3 data-id="heading-2">2. 核心提示模板分析</h3>
<h4 data-id="heading-3">2.1 对话标题生成 (CONVERSATION_TITLE_PROMPT)</h4>
<p><strong>功能</strong>：根据用户输入自动生成简洁的对话标题。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>自动检测输入语言（支持多语言）</li>
<li>要求将标题分解为"意图"和"主题"两部分</li>
<li>输出JSON格式，包含语言类型、推理过程和最终标题</li>
<li>对问题类型的输入可添加表情符号</li>
</ul>
<p><strong>应用场景</strong>：对话系统中自动为聊天会话生成可读性强的标题。</p>
<h4 data-id="heading-4">2.2 Python代码生成器 (PYTHON_CODE_GENERATOR_PROMPT_TEMPLATE)</h4>
<p><strong>功能</strong>：根据指令生成符合特定规范的Python代码。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>参数化模板：<code>{{INSTRUCTION}}</code>（任务指令）、<code>{{CODE_LANGUAGE}}</code>（代码语言）</li>
<li>强制要求定义名为<code>main</code>的函数</li>
<li>函数必须返回字典格式，至少包含一个键值对</li>
<li>严格限制可使用的Python库列表</li>
<li>提供代码示例和输出格式要求</li>
</ul>
<p><strong>应用场景</strong>：自动代码生成、API集成、数据处理脚本生成等。</p>
<h4 data-id="heading-5">2.3 JavaScript代码生成器 (JAVASCRIPT_CODE_GENERATOR_PROMPT_TEMPLATE)</h4>
<p><strong>功能</strong>：根据指令生成符合特定规范的JavaScript代码。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>与Python代码生成器类似的参数化结构</li>
<li>要求使用JSDoc注释进行类型标注</li>
<li>返回对象必须使用<code>{result: ...}</code>格式</li>
<li>提供详细的代码示例</li>
</ul>
<p><strong>应用场景</strong>：前端脚本生成、Node.js应用开发、浏览器扩展开发等。</p>
<h4 data-id="heading-6">2.4 后续问题预测 (SUGGESTED_QUESTIONS_AFTER_ANSWER_INSTRUCTION_PROMPT)</h4>
<p><strong>功能</strong>：根据助手的最新回复，预测用户最可能提出的三个后续问题。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>问题长度限制（20个字符以内）</li>
<li>输出语言与助手回复保持一致</li>
<li>必须返回JSON数组格式</li>
</ul>
<p><strong>应用场景</strong>：智能客服系统、对话机器人，提升用户交互体验。</p>
<h4 data-id="heading-7">2.5 问答对生成 (GENERATOR_QA_PROMPT)</h4>
<p><strong>功能</strong>：从长文本中提取关键信息，生成问答对。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>四步思考流程：理解内容→提取关键信息→组合信息→生成问答</li>
<li>问题要求清晰详细，答案要求完整准确</li>
<li>支持多语言，由<code>{language}</code>参数控制</li>
<li>特定的输出格式要求</li>
</ul>
<p><strong>应用场景</strong>：知识库构建、文档摘要、教育内容生成等。</p>
<h4 data-id="heading-8">2.6 工作流规则配置提示生成 (WORKFLOW_RULE_CONFIG_PROMPT_GENERATE_TEMPLATE)</h4>
<p><strong>功能</strong>：根据任务描述生成高质量的提示模板。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>参数化：<code>{{TASK_DESCRIPTION}}</code></li>
<li>生成的提示模板必须包含清晰的指令（<code>&lt;instruction&gt;</code>标签）</li>
<li>要求提供三个输入输出示例</li>
<li>输出格式为XML，必须以<code>&lt;instruction&gt;</code>开始</li>
</ul>
<p><strong>应用场景</strong>：工作流自动化、规则引擎配置、智能助手定制等。</p>
<h4 data-id="heading-9">2.7 规则配置提示生成 (RULE_CONFIG_PROMPT_GENERATE_TEMPLATE)</h4>
<p><strong>功能</strong>：为特定任务生成结构化的提示模板。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>参数化：<code>{{TASK_DESCRIPTION}}</code></li>
<li>要求使用<code>{{VARIABLE}}</code>格式定义变量</li>
<li>生成的模板必须包含指令、示例和其他相关部分</li>
<li>输出格式为XML</li>
</ul>
<p><strong>应用场景</strong>：聊天机器人配置、自动化流程设计、规则系统开发等。</p>
<h4 data-id="heading-10">2.8 规则配置参数提取 (RULE_CONFIG_PARAMETER_GENERATE_TEMPLATE)</h4>
<p><strong>功能</strong>：从文本中提取由双大括号包围的变量名。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>四步提取流程：理解输入→提取参数→结构化→验证格式</li>
<li>变量名必须符合特定命名规范（数字、字母、下划线）</li>
<li>输出为JSON数组格式</li>
<li>无有效变量时返回空数组</li>
</ul>
<p><strong>应用场景</strong>：模板解析、参数验证、配置管理等。</p>
<h4 data-id="heading-11">2.9 规则配置开场白生成 (RULE_CONFIG_STATEMENT_GENERATE_TEMPLATE)</h4>
<p><strong>功能</strong>：根据任务描述生成聊天机器人的开场白。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>参数化：<code>{{TASK_DESCRIPTION}}</code>、<code>{{INPUT_TEXT}}</code></li>
<li>三步生成流程：识别目的→推断语气→创建开场白</li>
<li>开场白必须友好、清晰地说明机器人功能</li>
<li>支持多语言，与用户输入保持一致</li>
</ul>
<p><strong>应用场景</strong>：聊天机器人初始化、客户服务系统、智能助手欢迎语等。</p>
<h4 data-id="heading-12">2.10 JSON Schema生成 (SYSTEM_STRUCTURED_OUTPUT_GENERATE)</h4>
<p><strong>功能</strong>：将用户描述转换为标准的JSON Schema定义。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>八步生成流程：分析需求→识别属性→确定类型→设置必填项→生成完整Schema→添加约束→格式化输出</li>
<li>提供四个详细示例，涵盖不同复杂度的Schema</li>
<li>输出必须是纯JSON，不包含任何额外内容</li>
</ul>
<p><strong>应用场景</strong>：API设计、数据验证、表单生成、配置管理等。</p>
<h4 data-id="heading-13">2.11 结构化输出提示 (STRUCTURED_OUTPUT_PROMPT)</h4>
<p><strong>功能</strong>：指导LLM根据提供的JSON Schema生成符合格式要求的输出。</p>
<p><strong>设计要点</strong>：</p>
<ul>
<li>参数化：<code>{{schema}}</code>（JSON Schema定义）</li>
<li>严格的输出约束：必须是JSON格式，布尔值和数字必须使用字符串和数字类型</li>
<li>提供示例说明输入输出格式</li>
</ul>
<p><strong>应用场景</strong>：数据结构化、API响应生成、表单数据处理等。</p>
<h3 data-id="heading-14">3. 技术设计特点</h3>
<h4 data-id="heading-15">3.1 参数化模板设计</h4>
<p>文件中大量使用了参数化模板设计，通过<code>{{VARIABLE_NAME}}</code>或<code>{variable}</code>的格式定义可替换参数。这种设计具有以下优势：</p>
<ul>
<li>提高模板的复用性</li>
<li>支持动态内容注入</li>
<li>便于维护和更新</li>
<li>增强模板的灵活性</li>
</ul>
<h4 data-id="heading-16">3.2 明确的指令与约束</h4>
<p>每个提示模板都包含了明确的任务指令和约束条件：</p>
<ul>
<li>详细的步骤指导</li>
<li>严格的输出格式要求</li>
<li>明确的内容限制</li>
<li>语言和风格要求</li>
</ul>
<p>这种设计确保了LLM生成结果的一致性和可靠性，减少了错误和不一致的输出。</p>
<h4 data-id="heading-17">3.3 多语言支持</h4>
<p>多个模板（如对话标题生成、问答对生成、开场白生成）都支持多语言处理，能够根据用户输入自动调整输出语言。</p>
<h4 data-id="heading-18">3.4 分层设计</h4>
<p>模板设计采用了分层结构：</p>
<ul>
<li>基础模板：直接用于指导LLM完成特定任务</li>
<li>元模板：用于生成其他提示模板的模板（如WORKFLOW_RULE_CONFIG_PROMPT_GENERATE_TEMPLATE）</li>
</ul>
<p>这种分层设计提高了系统的可扩展性和维护性。</p>
<h3 data-id="heading-19">4. 应用场景与价值</h3>
<p>该文件定义的提示模板广泛应用于以下场景：</p>
<ol>
<li><strong>智能对话系统</strong>：对话标题生成、后续问题预测、开场白生成</li>
<li><strong>代码自动化</strong>：Python/JavaScript代码生成</li>
<li><strong>内容生成</strong>：问答对生成、文档摘要</li>
<li><strong>工作流自动化</strong>：规则配置提示生成、参数提取</li>
<li><strong>数据管理</strong>：JSON Schema生成、结构化输出</li>
</ol>
<p>这些模板为系统提供了标准化的LLM交互接口，确保了AI生成内容的质量和一致性，同时提高了开发效率和系统可维护性。</p>
<h3 data-id="heading-20">5. 代码优化建议</h3>
<h4 data-id="heading-21">5.1 模板组织优化</h4>
<p><strong>问题</strong>：当前所有模板都集中在一个文件中，随着模板数量增加，可能会导致文件过大，难以维护。</p>
<p><strong>建议</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 将模板按功能分类到不同的子模块中</span>
<span class="hljs-comment"># core/llm_generator/prompts/</span>
<span class="hljs-comment"># ├── __init__.py</span>
<span class="hljs-comment"># ├── code_generation.py    # 代码生成相关模板</span>
<span class="hljs-comment"># ├── conversation.py       # 对话相关模板</span>
<span class="hljs-comment"># ├── structured_data.py    # 结构化数据相关模板</span>
<span class="hljs-comment"># └── workflow.py           # 工作流相关模板</span>
</code></pre>
<h4 data-id="heading-22">5.2 模板加载机制</h4>
<p><strong>问题</strong>：当前模板是硬编码的字符串常量，不支持外部配置和动态加载。</p>
<p><strong>建议</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Dict</span>, <span class="hljs-type">Any</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PromptLoader</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, base_dir: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span></span>):
        self.base_dir = base_dir <span class="hljs-keyword">or</span> os.path.dirname(__file__)
        self.templates: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>] = {}
    
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_template</span>(<span class="hljs-params">self, template_name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-keyword">if</span> template_name <span class="hljs-keyword">in</span> self.templates:
            <span class="hljs-keyword">return</span> self.templates[template_name]
        
        <span class="hljs-comment"># 支持从文件加载模板</span>
        template_path = os.path.join(self.base_dir, <span class="hljs-string">f"<span class="hljs-subst">{template_name}</span>.prompt"</span>)
        <span class="hljs-keyword">if</span> os.path.exists(template_path):
            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(template_path, <span class="hljs-string">"r"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
                template = f.read()
                self.templates[template_name] = template
                <span class="hljs-keyword">return</span> template
        
        <span class="hljs-comment"># 支持从JSON配置文件加载</span>
        config_path = os.path.join(self.base_dir, <span class="hljs-string">"templates.json"</span>)
        <span class="hljs-keyword">if</span> os.path.exists(config_path):
            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(config_path, <span class="hljs-string">"r"</span>, encoding=<span class="hljs-string">"utf-8"</span>) <span class="hljs-keyword">as</span> f:
                config = json.load(f)
                <span class="hljs-keyword">if</span> template_name <span class="hljs-keyword">in</span> config:
                    template = config[template_name]
                    self.templates[template_name] = template
                    <span class="hljs-keyword">return</span> template
        
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"Template '<span class="hljs-subst">{template_name}</span>' not found"</span>)
</code></pre>
<h4 data-id="heading-23">5.3 模板验证机制</h4>
<p><strong>问题</strong>：当前没有模板验证机制，无法确保模板的正确性和完整性。</p>
<p><strong>建议</strong>：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Set</span>
<span class="hljs-keyword">import</span> re

<span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_template</span>(<span class="hljs-params">template: <span class="hljs-built_in">str</span>, required_params: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
    <span class="hljs-string">"""验证模板的有效性"""</span>
    <span class="hljs-comment"># 检查参数格式</span>
    param_pattern = <span class="hljs-string">r"\{\{(\w+)\}\}|\{(\w+)\}"</span>
    found_params = <span class="hljs-built_in">set</span>()
    
    <span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> re.finditer(param_pattern, template):
        param = <span class="hljs-keyword">match</span>.group(<span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">match</span>.group(<span class="hljs-number">2</span>)
        <span class="hljs-keyword">if</span> param:
            found_params.add(param)
    
    <span class="hljs-comment"># 检查必填参数</span>
    <span class="hljs-keyword">if</span> required_params:
        missing_params = <span class="hljs-built_in">set</span>(required_params) - found_params
        <span class="hljs-keyword">if</span> missing_params:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"Missing required parameters: <span class="hljs-subst">{missing_params}</span>"</span>)
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
<h3 data-id="heading-24">6. 总结</h3>
<p><code>core/llm_generator/prompts.py</code>是一个精心设计的LLM提示模板库，为系统提供了标准化、可复用的AI交互接口。该文件定义了11种不同功能的提示模板，涵盖了对话系统、代码生成、内容生成、工作流自动化和数据管理等多个应用领域。</p>
<p>文件采用了参数化模板设计、明确的指令约束、多语言支持和分层结构等技术特点，确保了LLM生成结果的一致性和可靠性。这些模板不仅提高了开发效率，也为系统的可扩展性和维护性提供了有力支持。</p>
<p>通过适当的优化（如模板组织、加载机制和验证机制），可以进一步提升该文件的功能和性能，更好地满足复杂AI系统的需求。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[面向对象开发实践之消息中心设计（二）]]></title>    <link>https://juejin.cn/post/7584377629705977891</link>    <guid>https://juejin.cn/post/7584377629705977891</guid>    <pubDate>2025-12-17T03:42:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584377629705977891" data-draft-id="7584319403862278179" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="面向对象开发实践之消息中心设计（二）"/> <meta itemprop="keywords" content="后端,Java,架构"/> <meta itemprop="datePublished" content="2025-12-17T03:42:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="代码笔耕"/> <meta itemprop="url" content="https://juejin.cn/user/3984285868763117"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            面向对象开发实践之消息中心设计（二）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3984285868763117/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    代码笔耕
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:42:29.000Z" title="Wed Dec 17 2025 03:42:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>模型设计的目标，是承载变化，而不是预判所有变化。</strong></p>
</blockquote>
<p>本文是《面向对象开发实践之消息中心设计》系列的第二篇。</p>
<p>第一篇中，我重点讨论了<strong>如何用面向对象的方法启动一个消息中心设计</strong>。这一篇将更进一步，聚焦在一个更“脏”、也更容易失控的部分：<strong>消息模型设计</strong>。</p>
<p>在多数项目中，消息中心之所以难维护，并不是因为技术有多复杂，而是<strong>模型一开始就承载了过多变化</strong>。本文会从“最小可行模型”开始，一步步说明：</p>
<ul>
<li>消息模型最初只需要解决什么问题</li>
<li>为了适配哪些真实业务场景，我们引入了哪些字段和结构</li>
<li>哪些设计是“必须的”，哪些是“刻意延后”的</li>
</ul>
<h3 data-id="heading-0">一条消息最本质是什么？</h3>
<p>如果抛开 UI、样式、跳转、未读数等需求，一条消息最本质只回答三个问题：</p>
<ol>
<li>
<p><strong>给谁看的？</strong></p>
</li>
<li>
<p><strong>什么时候产生的？</strong></p>
</li>
<li>
<p><strong>发生了什么？</strong></p>
</li>
</ol>
<p>对应到模型中，最小消息单元可以极度克制：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> {
	Long id; <span class="hljs-comment">// 消息ID</span>
	Long userId; <span class="hljs-comment">// 接收用户</span>
    String title;	<span class="hljs-comment">// 消息标题</span>
	String content; <span class="hljs-comment">// 文本内容</span>
	LocalDateTime sendTime;
}
</code></pre>
<p>这个模型<strong>几乎什么都不能做</strong>，但它有一个重要意义：<strong>它定义了“消息”与“业务”的最小边界。<strong>所有后续设计，都是在这个边界之外</strong>有意识地扩展</strong>，而不是一开始就把所有业务塞进来。</p>
<h3 data-id="heading-1">第一轮拓展：为什么需要「消息分类」？</h3>
<p>很快我们会遇到第一个真实需求：</p>
<ul>
<li>用户想单独查看「系统消息」</li>
<li>活动消息不应该和评论提醒混在一起</li>
<li>不同分类的未读数要分开统计</li>
</ul>
<p>这时，引入 <strong>消息分类（Category）</strong> 是非常自然的：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MessageCategory</span> {
    SYSTEM,
    ACTIVITY,
    INTERACTION,
    ORDER
}
</code></pre>
<p>模型随之演进：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> {
    Long id;
    Long userId;
    MessageCategory category;
    String title;
    String content;
    LocalDateTime sendTime;
}
</code></pre>
<h4 data-id="heading-2">设计取舍</h4>
<ul>
<li>✅ 分类是<strong>用户视角</strong>的概念</li>
<li>❌ 它不等同于业务类型（不要直接用业务枚举）</li>
</ul>
<p>这一层的目的很单纯：<strong>支撑列表查询与未读数统计</strong></p>
<h3 data-id="heading-3">第二轮扩展：业务关联，但不侵入业务</h3>
<p>接下来几乎一定会出现的问题是：</p>
<blockquote>
<p>“这条消息是关于哪条评论 / 哪个活动的？”</p>
</blockquote>
<p>一个常见但危险的做法是：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentMessage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Message</span> {
    Comment comment;
}
</code></pre>
<p>这种设计的问题在于：</p>
<ul>
<li>消息与业务生命周期强绑定</li>
<li>业务删除 / 变更会直接影响历史消息</li>
</ul>
<p>正确做法：<strong>只存业务标识，不存业务对象</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MessageBizType</span> {
    COMMENT,
    LIKE,
    MENTION,
    VIOLATION,
    LOTTERY
}


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> {
    Long id;
    Long userId;
    MessageCategory category;
    MessageBizType bizType;
    Long bizId; <span class="hljs-comment">// 业务主键</span>
    String title;
    String content;
    LocalDateTime sendTime;
}
</code></pre>
<p>这个设计解决了什么？</p>
<ul>
<li>
<p>消息可以<strong>长期存在</strong></p>
</li>
<li>
<p>业务可以自由演进、删除、归档</p>
</li>
<li>
<p>是否实时查询业务，由“渲染阶段”决定</p>
</li>
</ul>
<p>这是一个非常关键的边界划分。</p>
<h3 data-id="heading-4">内容结构化：为“部分跳转文字”做准备</h3>
<p>在第一篇中提到过这样的需求：</p>
<blockquote>
<p>“社区规范”“修改&gt;&gt;” 需要支持点击跳转</p>
</blockquote>
<p>如果 content 只是纯字符串，这种需求几乎无法优雅支持。</p>
<p>首先定义跳转类型</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MessageJumpType</span> {
    NONE,           <span class="hljs-comment">// 无跳转</span>
    URL,            <span class="hljs-comment">// 外链</span>
    APP_ROUTE,      <span class="hljs-comment">// 应用内部路由</span>
    MINI_PROGRAM,   <span class="hljs-comment">// 小程序路径</span>
    ACTIVITY_PAGE,  <span class="hljs-comment">// 自动跳消息归属活动页面</span>
}
</code></pre>
<p>定义跳转配置模型：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageJumpConfig</span> {
    <span class="hljs-keyword">private</span> String url;             <span class="hljs-comment">// URL 跳转</span>
    <span class="hljs-keyword">private</span> String route;           <span class="hljs-comment">// App 内部路由</span>
    <span class="hljs-keyword">private</span> String miniProgramPath; <span class="hljs-comment">// 小程序路径</span>
    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; params; <span class="hljs-comment">// 路由参数</span>

    <span class="hljs-comment">// 工具构造方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MessageJumpConfig <span class="hljs-title function_">url</span><span class="hljs-params">(String url)</span> { ... }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MessageJumpConfig <span class="hljs-title function_">route</span><span class="hljs-params">(String route)</span> { ... }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MessageJumpConfig <span class="hljs-title function_">mini</span><span class="hljs-params">(String path)</span> { ... }
}
</code></pre>
<p>针对消息文本中部分文本可点击跳转（类似超链接），这类消息通常称为<strong>富文本消息（Rich Text Message）</strong>：</p>
<p>但不能直接给整个富文本，否则跳转逻辑难以做成标准化，所以我们要做 <strong>结构化富文本（Structured Rich Text）</strong>。</p>
<h4 data-id="heading-5"><strong>核心设计方案</strong></h4>
<p>将文本拆成多个“片段（Segment）”，每个片段可以是；</p>
<ul>
<li><code>TEXT</code>：普通文本</li>
<li><code>LINK</code>：可点击的跳转链接</li>
</ul>
<p>结构如下：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RichTextSegment</span> {
    <span class="hljs-keyword">private</span> RichTextType type;         <span class="hljs-comment">// TEXT / LINK</span>
    <span class="hljs-keyword">private</span> String text;               <span class="hljs-comment">// 段落文本</span>
    <span class="hljs-keyword">private</span> MessageJumpConfig jumpConfig;  <span class="hljs-comment">// LINK 时使用</span>
}
</code></pre>
<p>卡片内容的 text 字段改为支持富文本列表：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RichTextContent</span> {
    <span class="hljs-keyword">private</span> List&lt;RichTextSegment&gt; segments;
}
</code></pre>
<p>消息模型中不再直接存展示文本，而是存 <strong>可渲染结构</strong>：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> {
    ...
    RichTextContent content;
}
</code></pre>
<p><strong>设计价值</strong>:</p>
<ul>
<li>
<p>支持部分文字跳转</p>
</li>
<li>
<p>支持前端自由渲染</p>
</li>
<li>
<p>后续可扩展为富文本 / 高亮 / icon / 图片</p>
</li>
</ul>
<h3 data-id="heading-6">消息支持图片</h3>
<p>常见的消息图片分为两种：</p>
<ul>
<li>第一种是在消息最上方，宽度撑开展示，或者展示在左侧或者右侧，这种暂且可以认为是同一种类型，后面可以用布局来切换展示位置；</li>
<li>第二种是在消息中间，作为内容的一部分</li>
</ul>
<p>基于前面的内容，我们来支持这两种样式。首先把图片作为一个对象，定义图片的最小单元：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageImage</span> {
    <span class="hljs-keyword">private</span> String image;
}
</code></pre>
<p>同样，这里再支持图片点击跳转：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageImage</span> {
    <span class="hljs-keyword">private</span> String url;
    <span class="hljs-keyword">private</span> MessageJumpConfig jumpConfig;
}
</code></pre>
<p>可以在消息内容中，增加该类型，来支持图片展示：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RichTextSegment</span> {
    <span class="hljs-keyword">private</span> RichTextType type;         <span class="hljs-comment">// TEXT / LINK / IMAGE</span>
    <span class="hljs-keyword">private</span> String text;               <span class="hljs-comment">// 段落文本</span>
    <span class="hljs-keyword">private</span> MessageJumpConfig jumpConfig;  <span class="hljs-comment">// LINK 时使用</span>
    <span class="hljs-keyword">private</span> MessageImage image;			<span class="hljs-comment">// 支持图片</span>
}
</code></pre>
<p>同样在消息体中，增加该字段，来实现第一种展示形式：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> {
    ... 
    MessageImage image;
}
</code></pre>
<h3 data-id="heading-7">布局与样式：模型不关心“长什么样”</h3>
<p>面对多种卡片样式，一个常见误区是：在 Message 里加一堆 UI 字段</p>
<p>更优雅的做法，可以提前约定多种卡片结构布局，当需要前端按照什么样式来渲染，返回该样式即可。这里定义一个消息布局：</p>
<p>例如这里约定两种渲染样式：</p>
<ul>
<li>
<p>样式一：图片（宽度撑开，可省略）+ 标题（左对齐，可省略）+ 内容（左对齐）+ 时间（右对齐）</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e840dfe1d4024621a54ddab25b1fdfb0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB56yU6ICV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766547748&amp;x-signature=fixF0fAa3gs8BWxtXlGFVUhyiTI%3D" alt="" loading="lazy"/></p>
</li>
<li>
<p>样式二：标题（左对齐） + 时间（右对齐）+ 内容（左对齐）+ 图片（宽高固定，右对齐）</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bdd3f337f7c54d82bc018363d908719b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Luj56CB56yU6ICV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766547748&amp;x-signature=11x9rH9CiwPs0IFMaphK7G3OjeM%3D" alt="" loading="lazy"/></p>
</li>
</ul>
<p>这里定义消息布局，消息体中增加布局配置支持：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MessageLayout</span> {
    IMAGE_TITLE_TEXT,
    TITLE_TEXT_RIMAGE
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> {
    ...
    MessageLayout layout;
}
</code></pre>
<p><strong>关键点</strong>：</p>
<ul>
<li>
<p>模型只描述<strong>布局类型</strong></p>
</li>
<li>
<p>具体怎么渲染，由 Renderer 决定</p>
</li>
</ul>
<h3 data-id="heading-8">DO / DTO / VO 的分层思考</h3>
<p><strong><code>DO</code>：持久化模型</strong></p>
<ul>
<li>面向存储</li>
<li>字段稳定、可索引</li>
</ul>
<p><strong><code>DTO</code>：传输与创建</strong></p>
<ul>
<li>用于创建消息</li>
<li>不暴露内部字段</li>
<li>可封装行为</li>
</ul>
<p><strong><code>VO</code>：展示模型</strong></p>
<ul>
<li>已完成渲染</li>
<li>直接面向前端</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageVO</span> {
    Long id;
    <span class="hljs-type">boolean</span> read;
    MessageCategory category;
    MessageLayout layout;
    MessageImage image;
    RichTextContent content;
    LocalDateTime sendTime;
}
</code></pre>
<p>这是<strong>隔离变化</strong>的关键一环。</p>
<h3 data-id="heading-9">哪些设计被我刻意延后了？</h3>
<p>在这一阶段，刻意没有：引入 MQ、引入复杂状态机、做多级缓存、过度拆表</p>
<p>原因很简单：<strong>模型设计的目标，是承载变化，而不是预判所有变化。</strong></p>
<h3 data-id="heading-10">结语：模型不是“想清楚一次”，而是“允许演进”</h3>
<p>一个好的消息模型，并不是字段多、覆盖全，而是：</p>
<ul>
<li>有清晰边界</li>
<li>能容纳不确定性</li>
<li>不被某个业务绑死</li>
</ul>
<p>在下一篇文章中，我会进一步展开：</p>
<ul>
<li>不同消息类型（评论 / 点赞 / @ / 违规 / 活动 / 订单）的建模方式</li>
<li>Renderer 如何与模型协作</li>
<li>消息创建、去重与渲染的完整链路</li>
</ul>
<p>这是一个<strong>从模型走向行为</strong>的过程。</p>
<p>如果你正在做类似系统，希望这篇文章能帮你在“加字段之前”，多想一步。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[一场组件的进化脱口秀——React从 “类” 到 “hooks” 的 “改头换面”]]></title>    <link>https://juejin.cn/post/7584370833703911439</link>    <guid>https://juejin.cn/post/7584370833703911439</guid>    <pubDate>2025-12-17T03:39:09.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584370833703911439" data-draft-id="7584266920642019379" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="一场组件的进化脱口秀——React从 “类” 到 “hooks” 的 “改头换面”"/> <meta itemprop="keywords" content="React.js,前端,面试"/> <meta itemprop="datePublished" content="2025-12-17T03:39:09.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="风止何安啊"/> <meta itemprop="url" content="https://juejin.cn/user/2517239724512420"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            一场组件的进化脱口秀——React从 “类” 到 “hooks” 的 “改头换面”
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2517239724512420/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    风止何安啊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:39:09.000Z" title="Wed Dec 17 2025 03:39:09 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#595959;font-size:15px;font-family:-apple-system,system-ui,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Arial,sans-serif;background-image:linear-gradient(90deg,rgba(60,10,30,.04) 3%,transparent 0),linear-gradient(1turn,rgba(60,10,30,.04) 3%,transparent 0);background-size:20px 20px;background-position:50%}.markdown-body p{color:#595959;font-size:15px;line-height:2;font-weight:400}.markdown-body p+p{margin-top:16px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{padding:30px 0;margin:0;color:#135ce0}.markdown-body h1{position:relative;text-align:center;font-size:22px;margin:50px 0}.markdown-body h1:before{position:absolute;content:"";top:-10px;left:50%;width:32px;height:32px;transform:translateX(-50%);background-size:100% 100%;opacity:.36;background-repeat:no-repeat;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC)}.markdown-body h2{position:relative;font-size:20px;border-left:4px solid;padding:0 0 0 10px;margin:30px 0}.markdown-body h3{font-size:16px}.markdown-body ul{list-style:disc outside;margin-left:2em;margin-top:1em}.markdown-body li{line-height:2;color:#595959}.markdown-body img.loaded{margin:0 auto;display:block}.markdown-body blockquote{background:#fff9f9;margin:2em 0;padding:2px 20px;border-left:4px solid #b2aec5}.markdown-body blockquote p{color:#666;line-height:2}.markdown-body a{color:#036aca;border-bottom:1px solid rgba(3,106,202,.8);font-weight:400;text-decoration:none}.markdown-body em strong,.markdown-body strong{color:#036aca}.markdown-body hr{border-top:1px solid #135ce0}.markdown-body pre{overflow:auto}.markdown-body code,.markdown-body pre{overflow:auto;position:relative;line-height:1.75;font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body table{border-collapse:collapse;margin:1rem 0;overflow-x:auto}.markdown-body table td,.markdown-body table th{border:1px solid #dfe2e5;padding:.6em 1em}.markdown-body table tr{border-top:1px solid #dfe2e5}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>家人们，咱就是说，<code>React</code> 这玩意儿就纯纯一个 <strong>“互联网打工人”</strong>，几年不更新，直接从 “穿西装打领带的老派白领”<strong>（类组件）</strong>，进化成了 “穿卫衣踩拖鞋的高效新青年”<strong>（函数组件 + hooks）</strong>。但不得不说是真好用！看完你就知道这波 <strong>“改头换面”</strong> 到底有多爽。</p>
<h3 data-id="heading-1">一、React 16.8 前：类组件的 “老派职场生存法则”</h3>
<p>在 <code>hooks</code> 还没出生的年代，写 React 组件那叫一个 <strong>“仪式感拉满”</strong>—— 必须套个<code>class</code>，像入职要填一堆表格似的。总之一个字--<strong>“装”</strong>！</p>
<h4 data-id="heading-2">1. 状态，得用<code>this.state</code>“供着”？</h4>
<p>想存个变量还能让组件 “动起来”？得搁<code>constructor</code>里写<code>this.state = {}</code>，仿佛给变量办了张 <strong>“职场工牌”</strong>，只有挂上这牌，修改它才能触发 <strong>“全组开会”（组件重新渲染）</strong>。</p>
<p>比如：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">super</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { 
            <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> 
        } <span class="hljs-comment">// 给count发工牌：“你是咱组的状态人了！”</span>
    }
    <span class="hljs-title function_">add</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ 
            <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> 
        }) <span class="hljs-comment">// 修改状态=“给工牌升级”，触发渲染</span>
    }
    <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'render'</span>); <span class="hljs-comment">// 一修改就“开会”</span>
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.add.bind(this)}</span>&gt;</span>{this.state.count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    }
}
</code></pre>
<p><strong>点击前：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/642b1bbc75654760876589b98596fab5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766547549&amp;x-signature=7wlxKa9SKvMz%2BYW%2BvnMJgXdYYoU%3D" alt="image.png" loading="lazy"/></p>
<p><strong>点击3次后：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2de61572b7fa4492bc69cfd56d07d10c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766547549&amp;x-signature=8alZDRSFL42bCAk90zd%2FMOL3bak%3D" alt="image.png" loading="lazy"/></p>
<p>这<code>bind(this)</code>更是 <strong>“老派痛点”</strong>—— 不用它，<code>this</code>能给你跑到 “外星”，主打一个 <strong>“我认识你，但你不认识我”</strong> 的尴尬。</p>
<h4 data-id="heading-3">2. 生命周期：像职场的 “上下班打卡 + 加班预警”</h4>
<p>类组件的<strong>生命周期</strong>，那就是 “打工人的一天”：</p>
<ul>
<li><code>componentDidMount</code>：组件 “入职第一天”，刚渲染完就触发，适合干 “刚入职先装个软件”（比如发请求）；</li>
<li><code>componentDidUpdate</code>：组件 “每次改需求”，状态变了就触发，相当于 “改完方案得同步给全组”；</li>
<li><code>componentWillUnmount</code>：组件 “离职前”，销毁前触发，用来 “删软件清数据”（比如清定时器）。</li>
</ul>
<p>依旧代码：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
        <span class="hljs-variable language_">super</span>(props);
        <span class="hljs-comment">// 初始化状态：模拟“入职时的工作清单”和“待办数量”</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
            <span class="hljs-attr">workList</span>: [], <span class="hljs-comment">// 工作清单</span>
            <span class="hljs-attr">todoCount</span>: <span class="hljs-number">0</span>  <span class="hljs-comment">// 待办数量</span>
        };
        <span class="hljs-comment">// 模拟一个“上班期间的定时提醒”</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-comment">// 1. componentDidMount：组件“入职第一天”</span>
    <span class="hljs-comment">// 刚渲染完成（办完入职手续）就触发，只执行一次！</span>
    <span class="hljs-comment">// 适合做“入职首件事”：比如对接接口拿数据、初始化定时器、绑定事件</span>
    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'✨ 组件入职报到！'</span>);
        <span class="hljs-comment">// 模拟“入职先拉取工作清单”（发请求）</span>
        <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://mock-api.com/work/list'</span>)
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
                <span class="hljs-attr">workList</span>: data.<span class="hljs-property">list</span>,
                <span class="hljs-attr">todoCount</span>: data.<span class="hljs-property">list</span>.<span class="hljs-property">length</span>
            });
        });
        <span class="hljs-comment">// 模拟“入职后设置定时提醒”（比如每小时检查待办）</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'⏰ 定时检查：当前待办数 →'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">todoCount</span>);
        }, <span class="hljs-number">3600000</span>);
    }

    <span class="hljs-comment">// 2. componentDidUpdate：组件“每次改需求”</span>
    <span class="hljs-comment">// 状态/属性变化后（改了工作方案）触发，每次更新都会执行！</span>
    <span class="hljs-comment">// 适合做“需求变更后的同步操作”：比如待办数变了，同步更新统计</span>
    <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState</span>) {
        <span class="hljs-comment">// 注意！一定要加判断，否则会无限循环（改状态→触发更新→又改状态→再更新）</span>
        <span class="hljs-keyword">if</span> (prevState.<span class="hljs-property">todoCount</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">todoCount</span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'📝 需求变更！待办数从'</span>, prevState.<span class="hljs-property">todoCount</span>, <span class="hljs-string">'变成'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">todoCount</span>);
            <span class="hljs-comment">// 模拟“待办数变了，同步到公司看板”</span>
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'🔄 已同步待办数到公司看板～'</span>);
        }
    }

    <span class="hljs-comment">// 3. componentWillUnmount：组件“离职前”</span>
    <span class="hljs-comment">// 组件销毁（离职）前触发，只执行一次！</span>
    <span class="hljs-comment">// 适合做“离职收尾工作”：清定时器、解绑事件、取消请求，避免内存泄漏</span>
    <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'👋 组件准备离职！'</span>);
        <span class="hljs-comment">// 清除定时提醒（带走自己的东西，不占公司资源）</span>
        <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>);
        <span class="hljs-comment">// 模拟“取消未完成的请求”（避免离职后还发请求打扰公司）</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cancelRequest</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cancelRequest</span>();
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'✅ 收尾工作完成，可安心离职～'</span>);
    }

    <span class="hljs-comment">// 模拟“新增待办”（触发状态更新，进而触发componentDidUpdate）</span>
    addTodo = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> ({
            <span class="hljs-attr">todoCount</span>: prevState.<span class="hljs-property">todoCount</span> + <span class="hljs-number">1</span>
        }));
    };

    <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> { workList, todoCount } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"work-container"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>打工人的工作面板<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>当前待办数：{todoCount}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.addTodo}</span>&gt;</span>新增待办（改需求）<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
                    {workList.map((item, index) =&gt; (
                        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>&gt;</span>{item}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
                    ))}
                <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        );
    }
}
</code></pre>
<p>拆解：</p>
<p><strong>1.componentDidMount（入职报到）</strong> ：组件第一次渲染到页面后，这个方法就像你第一天入职 —— 办完手续坐在工位上，第一件事肯定是 <strong>“对接工作”（发请求拿数据）</strong>、<strong>“配置工作环境”（设定时器）</strong>。它只执行一次，不会因为后续改需求重复触发，完美契合 “入职首件事” 的场景。如果在这里忘了设定时器 / 绑事件，后续想补就只能塞到其他地方，容易乱。</p>
<p><strong>2.componentDidUpdate（需求变更）</strong> ：每次调用<code>setState</code>修改状态（比如点击 “新增待办”），组件重新渲染后就会触发这个方法，像极了公司改需求：你改完方案后，得同步给产品、测试、后端（对应代码里 “同步待办数到看板”）。但一定要加<code>prevState</code>/<code>prevProps</code>的判断！不然每次更新都改状态，会陷入 <strong>“改需求→同步→又改需求→又同步”</strong> 的无限循环，就像打工人改需求改到崩溃。</p>
<p><strong>3.componentWillUnmount（离职收尾）</strong> ：当组件从页面消失（比如路由跳转、关闭弹窗），这个方法就是 “离职前的最后 10 分钟”—— 必须把自己的东西清干净：定时提醒要关（不然离职后还在公司弹窗）、未完成的请求要取消（不然给公司造垃圾数据）、绑定的事件要解绑（不然可能导致内存泄漏）。要是忘了清定时器，就像离职后还占着公司的工位，看似小事，多了会拖垮整个项目（性能下降）。</p>
<p><strong>老派生命周期的 “槽点”：</strong></p>
<p>这么写看似逻辑清晰，但实际开发中，一个组件的 <strong>“数据请求 + 定时器 + 事件绑定”</strong> 可能分散在三个生命周期里 —— 比如 “发请求” 在<code>componentDidMount</code>，“请求结果更新后同步数据” 在<code>componentDidUpdate</code>，“取消请求” 在<code>componentWillUnmount</code>。原本相关的逻辑被拆得七零八落，就像你把 “对接一个需求” 的动作，拆到 “入职、改需求、离职” 三个阶段，后期维护时要翻遍整个文件找逻辑，主打一个 <strong>“找得到开头，找不到结尾”。</strong></p>
<p>这个真的挺难搞懂的，我刚接触的时候差点劝退。</p>
<h3 data-id="heading-4">二、React 17+：hooks 来了！函数组件直接 “躺赢”</h3>
<p><code>hooks</code> 一上线，直接把函数组件从 “边缘外包岗” 抬成了 “核心业务岗”—— 不用<code>class</code>，不用<code>this</code>，写代码像 <strong>“唠嗑”</strong> 一样轻松。</p>
<h4 data-id="heading-5">1. <code>useState</code>：状态？“随手揣兜里” 就行</h4>
<p>想存个能触发渲染的变量？<code>useState</code>一句话搞定，不用<code>constructor</code>，不用<code>this</code>，主打一个 “轻装上阵”。</p>
<p>直接拿我第一个举的例子：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"/>) {
        count += <span class="hljs-number">1</span>; 
    }
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{add}</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
}
</code></pre>
<p>如果你这样写的话根本没用,<strong>违背了 React 函数组件的状态管理规则</strong>。无论你按多少次按钮结果都是<code>0</code>：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a6665b14bbce4ebc8ea5616900ff2923~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766547549&amp;x-signature=N26jC58fmEDKOm5O4iZGJ7THIY4%3D" alt="image.png" loading="lazy"/></p>
<p>为啥凭啥？原因如下：</p>
<ul>
<li>当点击按钮执行 <code>add</code> 函数时，<code>count += 1</code> 只是在当前函数执行栈里修改了变量值，但这个修改不会通知 React “组件需要重新渲染”；</li>
<li>函数组件每次渲染都是一次独立的函数执行，即便本次执行里 <code>count</code> 变了，React 没感知到，就不会重新调用 <code>App</code> 函数，页面上显示的依然是初始渲染时的 <code>0</code>。</li>
</ul>
<p>这时候就得请出<code>useState</code>方法了：</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 一句话：“count是状态，setCount是修改它的按钮”</span>
    <span class="hljs-keyword">const</span> [list, setList] = <span class="hljs-title function_">useState</span>([]); <span class="hljs-comment">// 还能一次性搞多个状态，不用裹在 this.state里！</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"/>) {
        <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <span class="hljs-comment">// 改状态=“按按钮”，直接触发渲染，没this的事儿！</span>
    }
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{add}</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
}
</code></pre>
<p><strong>点击前：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cd5a03bfdc44c33b0c97920ea58d5e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766547549&amp;x-signature=fPrRLnqeu4EcEntgtbm2u1pOiZA%3D" alt="image.png" loading="lazy"/></p>
<p><strong>点击3次后：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b77a51327f2646bd8f6d4318b59194b5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766547549&amp;x-signature=Id3HtSa65lNGZiuA4%2B7Epg7mG5g%3D" alt="image.png" loading="lazy"/></p>
<p>这样我们就成功修改了<code>count</code>的值。</p>
<h4 data-id="heading-6">2. <code>useEffect</code>：生命周期？“一个函数承包所有活”</h4>
<p>类组件的三个生命周期，hooks 用一个<code>useEffect</code>就给 <strong>“合并裁员”</strong> 了，还能 <strong>“按需上班”</strong>，主打一个 <strong>“精准摸鱼”</strong>。</p>
<pre><code class="hljs language-jsx" lang="jsx"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> [list, setList] = <span class="hljs-title function_">useState</span>([]);

    <span class="hljs-comment">// 场景1：只在“入职时”发请求 → 第二个参数传空数组[]</span>
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'https://mock.mengxuegu.com/mock/66585c4db462b81cb3916d3e/songer/songer'</span>) <span class="hljs-comment">// 刚入职先拉数据</span>
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">setList</span>([...list, ...data.<span class="hljs-property">data</span>]))
    }, []) <span class="hljs-comment">// 空数组=“只上一天班，之后躺平”</span>

    <span class="hljs-comment">// 场景2：count变了才触发 → 第二个参数传[count]</span>
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'count变了,我才干活'</span>);
    }, [count]) <span class="hljs-comment">// count是“考勤机”，它变了才打卡</span>

    <span class="hljs-comment">// 场景3：离职前清东西 → return一个函数</span>
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {}, <span class="hljs-number">1000</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer); <span class="hljs-comment">// 离职前把定时器“关了再走”</span>
    }, [])
}
</code></pre>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b160b993b1c9459b895b7973cecabacc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6aOO5q2i5L2V5a6J5ZWK:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766547549&amp;x-signature=z%2Bv1BVZLeZVWZLkgwHjYlgI06p0%3D" alt="image.png" loading="lazy"/></p>
<p><strong>“时间管理大师”</strong>--<code>useEffect</code>：</p>
<ul>
<li>第二个参数传<code>[]</code>：“我只在组件第一次渲染后干一次活，多一次都不干”；</li>
<li>传<code>[x]</code>：“只有 x 变了，我才动一动”；</li>
<li>返回函数：“走之前把烂摊子收拾干净”。直接把类组件的三个生命周期按在地上摩擦，效率拉满！</li>
</ul>
<h3 data-id="heading-7">三、总结：从 “老派” 到 “新派”，到底爽在哪？</h3>






























<table><thead><tr><th>对比项</th><th>类组件（16.8 前）</th><th>函数组件 + hooks（17+）</th></tr></thead><tbody><tr><td>代码量</td><td>要写 class、constructor、bind</td><td>直接 function，一行 useState 搞定</td></tr><tr><td>状态管理</td><td>裹在 this.state 里，this 易迷路</td><td>变量 + 修改函数分离，清爽不绕弯</td></tr><tr><td>生命周期</td><td>多个函数分散写，易冗余</td><td>一个 useEffect 按需配置，逻辑聚合</td></tr><tr><td>复用性</td><td>得写 HOC/Render Props（麻烦）</td><td>自定义 hooks 直接 “复制粘贴逻辑”</td></tr></tbody></table>
<p>咱就是说，<strong>现在写 React 不用 hooks</strong>，就像 “快 2026 了还在用按键手机”—— 不是不能用，但就是 “别人都在刷短视频，你在那按数字键发短信”，主打一个 <strong>“慢半拍的倔强”</strong>。</p>
<h2 data-id="heading-8">结语</h2>
<p>说到底，<code>React</code> 从<strong>类组件</strong>到 <code>hooks</code> 的进化，就像把 <strong>“做饭得先砌灶台”</strong> 改成了 <strong>“点外卖还能选定制配料”</strong>—— 少了繁琐的仪式感，多了精准的掌控力。如今的 hooks 早已是 React 的 “当家花旦”，但咱也不用嫌弃类组件 “老古董”，毕竟它是 hooks 的 “前辈恩师”。总之，不管是老派还是新派，能高效写好组件的，都是咱<strong>前端圈的 “好派”</strong>。</p>
<blockquote>
<p>这篇文章里面的知识真的难，码了很久有了这篇文章，但还不是很透彻。如果有分析的不对的地方，麻烦大佬指出😭</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[🚀 Milvus 实战部署全记录]]></title>    <link>https://juejin.cn/post/7584343534968078378</link>    <guid>https://juejin.cn/post/7584343534968078378</guid>    <pubDate>2025-12-17T03:11:44.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584343534968078378" data-draft-id="7584353612501729321" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="🚀 Milvus 实战部署全记录"/> <meta itemprop="keywords" content="AI编程,Docker,数据库"/> <meta itemprop="datePublished" content="2025-12-17T03:11:44.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户352180245475"/> <meta itemprop="url" content="https://juejin.cn/user/156576846710315"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            🚀 Milvus 实战部署全记录
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/156576846710315/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户352180245475
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:11:44.000Z" title="Wed Dec 17 2025 03:11:44 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">🚀 Milvus 实战部署全记录</h2>
<p>Milvus 2.5.23 + Attu + 鉴权 + 幂等初始化（Docker Compose）</p>
<hr/>
<h3 data-id="heading-1">一、背景说明</h3>
<p>在实际工程中部署 Milvus，并不是简单 <code>docker run</code> 就能解决的问题。<br/>
本文完整记录了一次 <strong>从踩坑到稳定上线</strong> 的 Milvus 私有化部署过程。</p>
<p>最终方案选择：</p>
<ul>
<li><strong>Milvus v2.5.23（Standalone）</strong></li>
<li><strong>开启官方鉴权（RBAC）</strong></li>
<li><strong>Attu 管理界面</strong></li>
<li><strong>幂等的初始化用户方案</strong></li>
<li><strong>Docker Compose 一键部署</strong></li>
</ul>
<hr/>
<h3 data-id="heading-2">二、为什么选择 Milvus 2.5.23？</h3>
<h4 data-id="heading-3">放弃 2.6.7 的原因</h4>
<ol>
<li>
<p><strong>内存要求更高</strong></p>
<ul>
<li>2.6.x 引入 StreamingNode</li>
<li>启动时内存占用明显增加</li>
<li>8G 内存机器非常吃力</li>
</ul>
</li>
<li>
<p><strong>MinIO 依赖更激进</strong></p>
<ul>
<li>常搭配 <code>minio/minio:RELEASE.2024-05-28T17-19-04Z</code></li>
<li>部分环境下存在 GPU / 指令集兼容问题</li>
<li>MinIO 起不来 → Milvus 直接失败</li>
</ul>
</li>
</ol>
<h4 data-id="heading-4">选择 2.5.23 的理由</h4>
<ul>
<li>架构成熟</li>
<li>资源占用低</li>
<li>MinIO 兼容性好</li>
<li>Attu / SDK 稳定</li>
</ul>
<blockquote>
<p><strong>结论：2.5.23 是当前工程部署的“甜点版本”</strong></p>
</blockquote>
<hr/>
<h3 data-id="heading-5">三、项目目录结构</h3>
<pre><code class="hljs language-text" lang="text">milvus/
├── docker-compose.yml
├── config/
│   └── milvus.yaml
├── init/
│   ├── Dockerfile
│   └── init_user.py
└── volumes/
</code></pre>
<hr/>
<h3 data-id="heading-6">四、docker-compose.yml</h3>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">'3.5'</span>

<span class="hljs-attr">services:</span>
  <span class="hljs-attr">etcd:</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">milvus-etcd</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">quay.io/coreos/etcd:v3.5.18</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">ETCD_AUTO_COMPACTION_MODE=revision</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">ETCD_AUTO_COMPACTION_RETENTION=1000</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">ETCD_QUOTA_BACKEND_BYTES=4294967296</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">ETCD_SNAPSHOT_COUNT=50000</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">${DOCKER_VOLUME_DIRECTORY:-.}/volumes/etcd:/etcd</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">etcd</span> <span class="hljs-string">-advertise-client-urls=http://etcd:2379</span> <span class="hljs-string">-listen-client-urls</span> <span class="hljs-string">http://0.0.0.0:2379</span> <span class="hljs-string">--data-dir</span> <span class="hljs-string">/etcd</span>
    <span class="hljs-attr">healthcheck:</span>
      <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD"</span>, <span class="hljs-string">"etcdctl"</span>, <span class="hljs-string">"endpoint"</span>, <span class="hljs-string">"health"</span>]
      <span class="hljs-attr">interval:</span> <span class="hljs-string">30s</span>
      <span class="hljs-attr">timeout:</span> <span class="hljs-string">20s</span>
      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">milvus</span>
  <span class="hljs-attr">minio:</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">milvus-minio</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">minio/minio:RELEASE.2023-03-20T20-16-18Z</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">MINIO_ACCESS_KEY:</span> <span class="hljs-string">minioadmin</span>
      <span class="hljs-attr">MINIO_SECRET_KEY:</span> <span class="hljs-string">minioadmin</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"9001:9001"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"9000:9000"</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">${DOCKER_VOLUME_DIRECTORY:-.}/volumes/minio:/minio_data</span>
    <span class="hljs-attr">command:</span> <span class="hljs-string">minio</span> <span class="hljs-string">server</span> <span class="hljs-string">/minio_data</span> <span class="hljs-string">--console-address</span> <span class="hljs-string">":9001"</span>
    <span class="hljs-attr">healthcheck:</span>
      <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD"</span>, <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-f"</span>, <span class="hljs-string">"http://localhost:9000/minio/health/live"</span>]
      <span class="hljs-attr">interval:</span> <span class="hljs-string">30s</span>
      <span class="hljs-attr">timeout:</span> <span class="hljs-string">20s</span>
      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">milvus</span>
  <span class="hljs-attr">milvus:</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">milvus-standalone</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">milvusdb/milvus:v2.5.23</span>
    <span class="hljs-attr">command:</span> [<span class="hljs-string">"milvus"</span>, <span class="hljs-string">"run"</span>, <span class="hljs-string">"standalone"</span>]
    <span class="hljs-attr">security_opt:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">seccomp:unconfined</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">MINIO_REGION:</span> <span class="hljs-string">us-east-1</span>
      <span class="hljs-attr">ETCD_ENDPOINTS:</span> <span class="hljs-string">etcd:2379</span>
      <span class="hljs-attr">MINIO_ADDRESS:</span> <span class="hljs-string">minio:9000</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">${DOCKER_VOLUME_DIRECTORY:-.}/volumes/milvus:/var/lib/milvus</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">${DOCKER_VOLUME_DIRECTORY:-.}/config/milvus.yaml:/milvus/configs/milvus.yaml</span>
    <span class="hljs-attr">healthcheck:</span>
      <span class="hljs-attr">test:</span> [<span class="hljs-string">"CMD"</span>, <span class="hljs-string">"curl"</span>, <span class="hljs-string">"-f"</span>, <span class="hljs-string">"http://localhost:9091/healthz"</span>]
      <span class="hljs-attr">interval:</span> <span class="hljs-string">30s</span>
      <span class="hljs-attr">start_period:</span> <span class="hljs-string">90s</span>
      <span class="hljs-attr">timeout:</span> <span class="hljs-string">20s</span>
      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"19530:19530"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"9091:9091"</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"etcd"</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"minio"</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">milvus</span>
  <span class="hljs-attr">attu:</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">milvus-attu</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">zilliz/attu:v2.4</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">MILVUS_URL:</span> <span class="hljs-string">milvus:19530</span>
      <span class="hljs-attr">MILVUS_USERNAME:</span> <span class="hljs-string">root</span>
      <span class="hljs-attr">MILVUS_PASSWORD:</span> <span class="hljs-string">Milvus@123</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"17000:3000"</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">"milvus"</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">milvus</span>
  <span class="hljs-attr">init:</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">./init</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">milvus-init</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">MILVUS_HOST:</span> <span class="hljs-string">milvus</span>
      <span class="hljs-attr">NEW_ROOT_PASSWORD:</span> <span class="hljs-string">********</span>  <span class="hljs-comment">#设置自己新的密码</span>
      <span class="hljs-attr">APP_USER:</span> <span class="hljs-string">********</span>			<span class="hljs-comment">#应用账号</span>
      <span class="hljs-attr">APP_PASSWORD:</span> <span class="hljs-string">********</span>		<span class="hljs-comment">#应用密码</span>
      <span class="hljs-attr">APP_ROLE:</span> <span class="hljs-string">admin</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">milvus</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">milvus</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">"no"</span>
<span class="hljs-attr">networks:</span>
  <span class="hljs-attr">milvus:</span>
</code></pre>
<hr/>
<h3 data-id="heading-7">五、开启 Milvus 官方鉴权</h3>
<h4 data-id="heading-8">config/milvus.yaml</h4>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">common:</span>
  <span class="hljs-attr">security:</span>
    <span class="hljs-attr">authorizationEnabled:</span> <span class="hljs-literal">true</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b205dad449824b2ab6c782ca80a5bb38~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3MzUyMTgwMjQ1NDc1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546313&amp;x-signature=FC45eIKilLiwOMHoGoZ8cNuhYfw%3D" alt="image-20251217105612296" loading="lazy"/></p>
<p>开启后：</p>
<ul>
<li>所有客户端必须登录</li>
<li>Attu 也必须使用账号密码</li>
</ul>
<hr/>
<h3 data-id="heading-9">六、幂等的 Milvus 初始化用户方案</h3>
<h4 data-id="heading-10">init/Dockerfile</h4>
<pre><code class="hljs language-dockerfile" lang="dockerfile">FROM python:3.10-slim-bullseye
RUN pip install --no-cache-dir pymilvus==2.5.16
WORKDIR /app
COPY init-user.py /app/init-user.py
CMD ["python", "/app/init-user.py"]
</code></pre>
<hr/>
<h4 data-id="heading-11">init/init_user.py</h4>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">from</span> pymilvus <span class="hljs-keyword">import</span> connections, utility, Role
<span class="hljs-keyword">from</span> pymilvus.exceptions <span class="hljs-keyword">import</span> MilvusException

<span class="hljs-comment"># ---------- 基础配置 ----------</span>
MILVUS_HOST = os.getenv(<span class="hljs-string">"MILVUS_HOST"</span>, <span class="hljs-string">"milvus"</span>)
MILVUS_PORT = os.getenv(<span class="hljs-string">"MILVUS_PORT"</span>, <span class="hljs-string">"19530"</span>)

ROOT_USER = <span class="hljs-string">"root"</span>
DEFAULT_ROOT_PASSWORD = os.getenv(<span class="hljs-string">"ROOT_PASSWORD"</span>, <span class="hljs-string">"Milvus"</span>)
NEW_ROOT_PASSWORD = os.getenv(<span class="hljs-string">"NEW_ROOT_PASSWORD"</span>)  <span class="hljs-comment"># 可选</span>

APP_USER = os.getenv(<span class="hljs-string">"APP_USER"</span>, <span class="hljs-string">"app_user"</span>)
APP_PASSWORD = os.getenv(<span class="hljs-string">"APP_PASSWORD"</span>, <span class="hljs-string">"App@123456"</span>)
APP_ROLE = os.getenv(<span class="hljs-string">"APP_ROLE"</span>, <span class="hljs-string">"admin"</span>)

<span class="hljs-comment"># ---------- 等待 Milvus ----------</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"⏳ Waiting for Milvus to be ready..."</span>)
time.sleep(<span class="hljs-number">12</span>)

<span class="hljs-comment"># ---------- 使用默认 root 密码连接 ----------</span>
connections.connect(
    alias=<span class="hljs-string">"default"</span>,
    host=MILVUS_HOST,
    port=MILVUS_PORT,
    user=ROOT_USER,
    password=DEFAULT_ROOT_PASSWORD
)

<span class="hljs-comment"># ---------- 修改 root 密码（幂等） ----------</span>
<span class="hljs-keyword">if</span> NEW_ROOT_PASSWORD <span class="hljs-keyword">and</span> NEW_ROOT_PASSWORD != DEFAULT_ROOT_PASSWORD:
    <span class="hljs-keyword">try</span>:
        utility.update_password(
            ROOT_USER,
            DEFAULT_ROOT_PASSWORD,
            NEW_ROOT_PASSWORD
        )
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"✅ Root password updated"</span>)

        <span class="hljs-comment"># 重新连接（非常重要）</span>
        connections.disconnect(<span class="hljs-string">"default"</span>)
        connections.connect(
            alias=<span class="hljs-string">"default"</span>,
            host=MILVUS_HOST,
            port=MILVUS_PORT,
            user=ROOT_USER,
            password=NEW_ROOT_PASSWORD
        )
    <span class="hljs-keyword">except</span> MilvusException <span class="hljs-keyword">as</span> e:
        <span class="hljs-keyword">if</span> <span class="hljs-string">"password is incorrect"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(e) <span class="hljs-keyword">or</span> <span class="hljs-string">"authentication failed"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(e):
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"ℹ️ Root password already changed, continue"</span>)
            connections.disconnect(<span class="hljs-string">"default"</span>)
            connections.connect(
                alias=<span class="hljs-string">"default"</span>,
                host=MILVUS_HOST,
                port=MILVUS_PORT,
                user=ROOT_USER,
                password=NEW_ROOT_PASSWORD
            )
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">raise</span>

<span class="hljs-comment"># ---------- 创建用户 ----------</span>
<span class="hljs-keyword">try</span>:
    utility.create_user(APP_USER, APP_PASSWORD)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ User created: <span class="hljs-subst">{APP_USER}</span>"</span>)
<span class="hljs-keyword">except</span> MilvusException <span class="hljs-keyword">as</span> e:
    <span class="hljs-keyword">if</span> <span class="hljs-string">"already exists"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(e):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"ℹ️ User already exists: <span class="hljs-subst">{APP_USER}</span>"</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span>

<span class="hljs-comment"># ---------- 创建角色 ----------</span>
role = Role(APP_ROLE)
<span class="hljs-keyword">try</span>:
    role.create()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ Role created: <span class="hljs-subst">{APP_ROLE}</span>"</span>)
<span class="hljs-keyword">except</span> MilvusException <span class="hljs-keyword">as</span> e:
    <span class="hljs-keyword">if</span> <span class="hljs-string">"already exists"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(e):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"ℹ️ Role already exists: <span class="hljs-subst">{APP_ROLE}</span>"</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span>

<span class="hljs-comment"># ---------- 绑定角色 ----------</span>
<span class="hljs-keyword">try</span>:
    role.add_user(APP_USER)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"✅ Granted role [<span class="hljs-subst">{APP_ROLE}</span>] to user [<span class="hljs-subst">{APP_USER}</span>]"</span>)
<span class="hljs-keyword">except</span> MilvusException <span class="hljs-keyword">as</span> e:
    <span class="hljs-keyword">if</span> <span class="hljs-string">"already"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(e):
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"ℹ️ Role already granted"</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span>

<span class="hljs-built_in">print</span>(<span class="hljs-string">"🎉 Milvus RBAC initialization finished"</span>)
</code></pre>
<h4 data-id="heading-12">幂等性说明</h4>
<ul>
<li>重复执行不会报错</li>
<li>适合 CI/CD</li>
<li>容器只执行一次即可退出</li>
</ul>
<hr/>
<h3 data-id="heading-13">七、运行与验证</h3>
<pre><code class="hljs language-bash" lang="bash">docker compose up -d
</code></pre>
<p>成功标志：</p>
<ul>
<li>
<p>milvus-init 容器执行后退出，具体的执行日志如下：</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-meta">#执行脚本</span>
docker logs -f milvus-<span class="hljs-keyword">init</span>
</code></pre>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a12a470c5e614257a0d5057b7702afc6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3MzUyMTgwMjQ1NDc1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546313&amp;x-signature=eVWrva90jp5Oz%2FdxIis%2Bmz4Cpi4%3D" alt="image-20251217105644586" loading="lazy"/></p>
</li>
<li>
<p>Milvus 日志无 ERROR</p>
</li>
<li>
<p>Milvus 的webui管理端，注意这个管理端没有账号与密码，能直接访问</p>
</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd291136f9bf4a1db9debd07de7551ba~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3MzUyMTgwMjQ1NDc1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546313&amp;x-signature=zANXo0eKbdFyqM2Zzl4zZ6KfONo%3D" alt="image.png" loading="lazy"/></p>
<ul>
<li>Attu需要账号密码才能登录，需要自己测试下新的root密码、应用账号与密码</li>
</ul>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b2c1bf5bdf114738ac2ad7f06ed08d36~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3MzUyMTgwMjQ1NDc1:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766546313&amp;x-signature=tS9174cz6n%2Bn6tlwPItI73iEID0%3D" alt="image-20251217105440796" loading="lazy"/></p>
<hr/>
<h3 data-id="heading-14">八、踩坑记录</h3>
<h4 data-id="heading-15">9091 访问不了？</h4>
<p>原因：</p>
<ul>
<li>Milvus 未完全就绪</li>
<li>MixCoord 尚未启动完成</li>
</ul>
<p>解决：</p>
<ul>
<li>耐心等待</li>
<li>通过 <code>docker logs -f milvus-standalone</code> 查看状态</li>
</ul>
<h4 data-id="heading-16">docker start 看不到日志？</h4>
<pre><code class="hljs language-bash" lang="bash">docker logs -f milvus-standalone
</code></pre>
<h4 data-id="heading-17">没有 /var/lib/milvus/logs 目录？</h4>
<ul>
<li>2.5.x 默认日志输出 stdout</li>
<li>属于正常现象</li>
</ul>
<h4 data-id="heading-18">有异常需要重新操作</h4>
<ul>
<li>
<p>看情况，可以选择从新编译init的镜像</p>
<pre><code class="hljs language-csharp" lang="csharp"> docker-compose build <span class="hljs-keyword">init</span>
</code></pre>
</li>
<li>
<p>账号信息放在ect里面，根据情况可以删除</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">rm</span> -rf ./volumes/*
</code></pre>
</li>
</ul>
<h3 data-id="heading-19">九、总结</h3>
<ul>
<li>Milvus 是工程系统，不是 Demo</li>
<li>2.5.23 是当前最稳妥的生产选择</li>
<li>初始化用户一定要做成幂等</li>
<li>鉴权 + Attu 才是完整方案</li>
</ul>
<blockquote>
<p><strong>一次搭好，后面都省心</strong></p>
</blockquote>
<hr/>
<p>完 🎉</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[使用Langchain4j和Ollama3搭建RAG系统]]></title>    <link>https://juejin.cn/post/7584362317003128859</link>    <guid>https://juejin.cn/post/7584362317003128859</guid>    <pubDate>2025-12-17T03:56:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584362317003128859" data-draft-id="7584426795757256730" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="使用Langchain4j和Ollama3搭建RAG系统"/> <meta itemprop="keywords" content="Ollama,LLM,LangChain"/> <meta itemprop="datePublished" content="2025-12-17T03:56:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大模型教程"/> <meta itemprop="url" content="https://juejin.cn/user/1145012233707299"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            使用Langchain4j和Ollama3搭建RAG系统
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1145012233707299/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大模型教程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:56:50.000Z" title="Wed Dec 17 2025 03:56:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文较长，建议点赞收藏。更多AI大模型应用开发学习视频及资料，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2FEnjoyEDU%2FLLM" target="_blank" title="https://gitcode.com/EnjoyEDU/LLM" ref="nofollow noopener noreferrer">这里</a>。</p>
</blockquote>
<p>检索增强生成（Retrieval-Augmented Generation，RAG）框架通过融合从大型文档语料库中检索到的关键信息，显著提升了生成语言模型的能力。这种策略不仅增强了生成回答的准确性，还提高了其相关性。在本文中，我们将探讨如何在Langchain4j环境下有效利用RAG技术。</p>
<h2 data-id="heading-0">RAG的重要性</h2>
<p>RAG技术通过将外部信息无缝融入生成流程，极大地提升了生成模型的效能。与传统方法不同，RAG不完全依赖于语言模型的预训练知识库，而是能够动态地从广泛的文档语料库中检索出相关信息，从而确保生成的回答不仅准确，还富含上下文信息。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/19d122696d3a449da63030521b3f3208~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548609&amp;x-signature=zDWRR3WtAx8OGMtkthpStj5%2BRMY%3D" alt="" loading="lazy"/></p>
<p>RAG不仅有效降低了模型产生幻觉的风险，还能够将模型原始训练数据中可能未涵盖的最新特定领域知识融入模型输出。通过缩小模型内静态知识与动态实时信息之间的鸿沟，RAG显著提升了生成响应的质量和可靠性，使其在那些对精确性和上下文敏感度要求极高的应用场景中显得尤为宝贵。</p>
<h2 data-id="heading-1">使用Langchain4j和Ollama3搭建的RAG系统中的关键组件</h2>
<p>为了在Langchain4j和Ollama3框架下实现RAG，本文将关注以下几个核心组件：</p>
<p>1.EmbeddingStore：负责管理从文档中提取的嵌入向量。</p>
<p>2.EmbeddingStoreIngestor：负责将文档录入系统并生成相应的嵌入向量。</p>
<p>3.OllamaEmbeddingModel：用于从文本数据中生成嵌入词，为检索提供支持。</p>
<p>4.OllamaLanguageModel：利用检索到的数据生成精确且上下文相关的响应。</p>
<h2 data-id="heading-2">分步示例</h2>
<p>首先，请确保你的Ollama3引擎已启动并正在运行。下面的文章将详细介绍这一过程： Getting started with langchain4j and Llama Model。</p>
<p>然后，在代码中添加以下依赖项：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>dev.langchain4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>langchain4j-ollama<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.33.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>接下来，假设我们的目标是向文本文件中添加新内容，具体来说，是定义一种适合出现在史诗奇幻作品《指环王》中的新异兽。</p>
<p>The Shadowmire is a mysterious and ancient creature that dwells in the darkest, most secluded swamps of Middle-earth.</p>
<p>It has the body of a large, sleek panther, but its fur is a deep, iridescent black that seems to absorb light.</p>
<p>Its eyes are a piercing emerald green, glowing with an eerie luminescence that can be seen from afar.</p>
<p>请将该文本文件保存在Maven项目资源目录下（或类路径中的任何位置），例如命名为dictionary.txt。</p>
<p>随后，我们开始编写代码，以便将这些信息集成到OllamaLanguageModel中。接下来，我们将构建一个提示，利用文本文件中的数据来查询模型。</p>
<pre><code class="hljs language-ini" lang="ini">import dev.langchain4j.data.document.Document<span class="hljs-comment">;</span>
import dev.langchain4j.data.document.DocumentSplitter<span class="hljs-comment">;</span>
import dev.langchain4j.data.document.loader.FileSystemDocumentLoader<span class="hljs-comment">;</span>
import dev.langchain4j.data.document.parser.TextDocumentParser<span class="hljs-comment">;</span>
import dev.langchain4j.data.document.splitter.DocumentSplitters<span class="hljs-comment">;</span>
import dev.langchain4j.data.embedding.Embedding<span class="hljs-comment">;</span>
import dev.langchain4j.data.segment.TextSegment<span class="hljs-comment">;</span>
import dev.langchain4j.model.embedding.EmbeddingModel<span class="hljs-comment">;</span>
import dev.langchain4j.model.input.Prompt<span class="hljs-comment">;</span>
import dev.langchain4j.model.input.PromptTemplate<span class="hljs-comment">;</span>
import dev.langchain4j.model.ollama.OllamaEmbeddingModel<span class="hljs-comment">;</span>
import dev.langchain4j.model.ollama.OllamaLanguageModel<span class="hljs-comment">;</span>
import dev.langchain4j.store.embedding.EmbeddingMatch<span class="hljs-comment">;</span>
import dev.langchain4j.store.embedding.EmbeddingStore<span class="hljs-comment">;</span>
import dev.langchain4j.store.embedding.EmbeddingStoreIngestor<span class="hljs-comment">;</span>
import dev.langchain4j.store.embedding.inmemory.InMemoryEmbeddingStore<span class="hljs-comment">;</span>
import java.net.URL<span class="hljs-comment">;</span>
import java.nio.file.Path<span class="hljs-comment">;</span>
import java.nio.file.Paths<span class="hljs-comment">;</span>
import java.time.Duration<span class="hljs-comment">;</span>
import java.util.List<span class="hljs-comment">;</span>
import java.util.Map<span class="hljs-comment">;</span>
public class RAGIngestor {
private static Duration <span class="hljs-attr">timeout</span> = Duration.ofSeconds(<span class="hljs-number">900</span>)<span class="hljs-comment">;</span>
public static void main(String args<span class="hljs-section">[]</span>) throws Exception  {
EmbeddingModel <span class="hljs-attr">embeddingModel</span> = OllamaEmbeddingModel.builder()
.baseUrl("http://localhost:11434")
.modelName("llama3")
.build()<span class="hljs-comment">;</span>
EmbeddingStore <span class="hljs-attr">embeddingStore</span> = new InMemoryEmbeddingStore()<span class="hljs-comment">;</span>
URL <span class="hljs-attr">fileUrl</span> = RAGIngestor.class.getResource(<span class="hljs-string">"/dictionary.txt"</span>)<span class="hljs-comment">;</span>
Path <span class="hljs-attr">path</span> = Paths.get(fileUrl.toURI())<span class="hljs-comment">;</span>
Document <span class="hljs-attr">document</span> = FileSystemDocumentLoader.loadDocument(path, new TextDocumentParser())<span class="hljs-comment">;</span>
DocumentSplitter <span class="hljs-attr">splitter</span> = DocumentSplitters.recursive(<span class="hljs-number">600</span>, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
EmbeddingStoreIngestor <span class="hljs-attr">ingestor</span> = EmbeddingStoreIngestor.builder()
.documentSplitter(splitter)
.embeddingModel(embeddingModel)
.embeddingStore(embeddingStore)
.build()<span class="hljs-comment">;</span>
ingestor.ingest(document)<span class="hljs-comment">;</span>
Embedding <span class="hljs-attr">queryEmbedding</span> = embeddingModel.embed(<span class="hljs-string">"What is the Shadowmire ?"</span>).content()<span class="hljs-comment">;</span>
List&lt;EmbeddingMatch&lt;TextSegment&gt;&gt; <span class="hljs-attr">relevant</span> = embeddingStore.findRelevant(queryEmbedding, <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>
EmbeddingMatch&lt;TextSegment&gt; <span class="hljs-attr">embeddingMatch</span> = relevant.get(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
String <span class="hljs-attr">information</span> = embeddingMatch.embedded().text()<span class="hljs-comment">;</span>
Prompt <span class="hljs-attr">prompt</span> = PromptTemplate.from(<span class="hljs-string">"""
Tell me about {{name}}?
Use the following information to answer the question:
{{information}}
"""</span>).apply(Map.of(<span class="hljs-string">"name"</span>, <span class="hljs-string">"Shadowmire"</span>,<span class="hljs-string">"information"</span>, information))<span class="hljs-comment">;</span>
// Initialize the language model for generating the response
OllamaLanguageModel <span class="hljs-attr">model</span> = OllamaLanguageModel.builder()
.baseUrl("http://localhost:11434")
.modelName("llama3")
.timeout(timeout)
.build()<span class="hljs-comment">;</span>
String <span class="hljs-attr">answer</span> = model.generate(prompt).content()<span class="hljs-comment">;</span>
System.out.println("Answer:"+answer)<span class="hljs-comment">;</span>
}
}
</code></pre>
<p>代码说明：</p>
<p>1.初始化嵌入模型：我们利用OllamaEmbeddingModel创建了一个与Ollama3服务相连的嵌入模型实例。</p>
<p>2.初始化嵌入存储：设置一个内存中的嵌入存储空间，用于存储文档的嵌入向量。</p>
<p>3.加载和解析文档：从文件系统加载文档，并将其解析成可处理的文本段。</p>
<p>4.分割文档：使用递归分割器将文档分解成更小的、易于管理的部分。</p>
<p>5.输入文档：为文档的每个片段生成嵌入向量，并将其存储在嵌入存储区。</p>
<p>6.创建查询嵌入：针对用户的查询内容，生成相应的嵌入向量。</p>
<p>7.检索相关信息：在嵌入存储中执行相似性搜索，以找到与查询嵌入向量相匹配的相关文本片段。</p>
<p>8.准备提示：结合检索到的信息和预设模板，构建一个完整的提示。</p>
<p>9.初始化语言模型：使用OllamaLanguageModel初始化一个生成模型，准备生成响应。</p>
<p>10.生成回复：根据准备好的提示，利用语言模型生成最终的响应内容。</p>
<p>执行上述代码后，系统经过几分钟的处理，该提示将返回生成的响应：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/11d8b20c9c4d4a08b0bc814b6f11acae~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548609&amp;x-signature=Qn5q%2FHdxdNI4nhpAMmO7x4mhx5U%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-3">结论</h2>
<p>通过融合检索式模型和生成式模型的优势，RAG结合Langchain4j和Ollama3提供了一种强有力的方法，以增强自然语言处理任务的准确性和相关性。本教程概述了实现RAG的基本框架，该框架可以根据特定的用例和数据集进行进一步的定制和扩展。</p>
<h3 data-id="heading-4">学习资源推荐</h3>
<p>如果你想更深入地学习大模型，以下是一些非常有价值的学习资源，这些资源将帮助你从不同角度学习大模型，提升你的实践能力。</p>
<blockquote>
<p>本文较长，建议点赞收藏。更多AI大模型应用开发学习视频及资料，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2FEnjoyEDU%2FLLM" target="_blank" title="https://gitcode.com/EnjoyEDU/LLM" ref="nofollow noopener noreferrer">这里</a>。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[全网首发！清北麻省顶级教授力荐的《图解大模型》中文版终于来了，碾压 95% 同类教材]]></title>    <link>https://juejin.cn/post/7584365584747495451</link>    <guid>https://juejin.cn/post/7584365584747495451</guid>    <pubDate>2025-12-17T03:57:02.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584365584747495451" data-draft-id="7584037286027919410" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="全网首发！清北麻省顶级教授力荐的《图解大模型》中文版终于来了，碾压 95% 同类教材"/> <meta itemprop="keywords" content="LLM,Agent,程序员"/> <meta itemprop="datePublished" content="2025-12-17T03:57:02.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大模型教程"/> <meta itemprop="url" content="https://juejin.cn/user/1145012233707299"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            全网首发！清北麻省顶级教授力荐的《图解大模型》中文版终于来了，碾压 95% 同类教材
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1145012233707299/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大模型教程
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T03:57:02.000Z" title="Wed Dec 17 2025 03:57:02 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{color:#383838;font-size:15px;line-height:30px;letter-spacing:2px;word-break:break-word;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Open Sans,Helvetica Neue,sans-serif;scroll-behavior:smooth;background-image:linear-gradient(0deg,transparent 24%,rgba(201,195,195,.329) 25%,hsla(0,8%,80.4%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent),linear-gradient(90deg,transparent 24%,rgba(204,196,196,.226) 25%,hsla(0,4%,66.1%,.05) 26%,transparent 27%,transparent 74%,hsla(0,5.2%,81%,.185) 75%,rgba(180,176,176,.05) 76%,transparent 77%,transparent);background-color:#fff;background-size:50px 50px;padding-bottom:60px}.markdown-body ::selection{color:#fff;background-color:#a862ea}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin:24px 0 12px;color:#a862ea}.markdown-body h1{line-height:2;font-size:1.4em}.markdown-body h1~p:first-of-type:first-letter{color:#a862ea;float:left;font-size:2em;margin-right:.4em;font-weight:bolder}.markdown-body h2{font-size:1.2em}.markdown-body h3{font-size:1.1em}.markdown-body ol,.markdown-body ul{padding-left:2em}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;padding-left:.2em}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#a862ea}.markdown-body ol li.task-list-item,.markdown-body ul li.task-list-item{list-style:none}.markdown-body ol li.task-list-item ol,.markdown-body ol li.task-list-item ul,.markdown-body ul li.task-list-item ol,.markdown-body ul li.task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:10px}.markdown-body a,.markdown-body code,.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6,.markdown-body li,.markdown-body p{opacity:.85;vertical-align:baseline;transition:all .1s ease}.markdown-body a:hover,.markdown-body code:hover,.markdown-body h1:hover,.markdown-body h2:hover,.markdown-body h3:hover,.markdown-body h4:hover,.markdown-body h5:hover,.markdown-body h6:hover,.markdown-body li:hover,.markdown-body p:hover{opacity:1}.markdown-body a{display:inline-block;color:#a862ea;cursor:pointer;text-decoration:none;position:relative}.markdown-body a:after{content:"";position:absolute;width:98%;height:1px;bottom:0;left:0;transform:scaleX(0);background-color:#a862ea;transform-origin:bottom right;transition:transform .3s ease-in-out}.markdown-body a:hover:after{transform:scaleX(1);transform-origin:bottom left}.markdown-body a:active,.markdown-body a:link{color:#a862ea}.markdown-body img{max-width:100%;user-select:none;margin:1em 0;transition:transform .2s ease 0s;background-color:#f8f5ff;box-shadow:0 0 10px #e7daff}.markdown-body img:hover{opacity:1;box-shadow:0 0 20px #e7daff;transform:translateY(-1px)}.markdown-body blockquote{padding:.5em 1em;margin:12px 0;border-top-left-radius:2px;border-bottom-left-radius:2px;border-left:3px solid #a862ea;background-color:#f8f5ff}.markdown-body blockquote&gt;p{margin:0}.markdown-body .math{font-style:italic;margin:12px 0;padding:.5em 1em;background-color:#f8f5ff}.markdown-body .math&gt;p{margin:0}.markdown-body code{padding:2px .4em;overflow-x:auto;color:#a862ea;font-weight:700;word-break:break-word;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;background-color:#f8f5ff}.markdown-body pre{margin:2em 0}.markdown-body pre&gt;code{display:block;padding:1.5em;word-break:normal;font-size:.9em;font-style:normal;font-weight:400;font-family:Operator Mono,Consolas,Monaco,Menlo,monospace;line-height:18px;color:#383838;border-radius:2px;scroll-behavior:smooth;box-shadow:0 0 10px #e7daff}.markdown-body pre&gt;code:hover{box-shadow:0 0 20px #e7daff}.markdown-body pre&gt;code::-webkit-scrollbar{height:6px;background-color:#f8f5ff}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:#e7daff;border-bottom-left-radius:3px;border-bottom-right-radius:3px}.markdown-body hr{margin:2em 0;border-top:1px solid #a862ea}.markdown-body table{width:100%;font-size:12px;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{color:#a862ea;background:#f8f5ff}.markdown-body td,.markdown-body th{padding:.5em;border:1px solid #e7daff}.markdown-body tr{background-color:#f8f5ff}@media (max-width:720px){.markdown-body{font-size:12px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>本文较长，建议点赞收藏。更多AI大模型应用开发学习视频及资料，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2FEnjoyEDU%2FLLM" target="_blank" title="https://gitcode.com/EnjoyEDU/LLM" ref="nofollow noopener noreferrer">这里</a>。</p>
</blockquote>
<p>一本让开发者与 AI 从业者翘首以盼的 LLM入门与实战指南——《图解大模型：生成式 AI原理与实战》来了</p>
<p>本书由 Jay Alammar 与 Maarten Grootendorst 联袂创作，两位在大模型与自然语言处理领域具有广泛影响力的专家，内容融合广受欢迎的图解系列精华，一经推出便获得业内高度评价。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/666c309a1191463dbeba1fe91ee2ce47~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548621&amp;x-signature=IFK8maOcTmv60x1fzmzBj%2BmBBvw%3D" alt="" loading="lazy"/></p>
<p>本书全程图解式讲解，通过大量全彩插图拆解概念，让读者真正告别学习大模型的枯燥和复杂。</p>
<p>全书分为三部分，依次介绍语言模型的原理、应用及优化。</p>
<p>第一部分 理解语言模型（第1~3章）：词元、嵌入向量、Transformer 架构一次性给你讲透！帮助读者从零搭建大模型底层认知，彻底告别 “看不懂、不会用” 的尴尬！</p>
<p>第二部分 使用预训练语言模型（第4~9章）：介绍如何使用大模型进行文本分类、聚类、语义搜索、文本生成，还有超火的多模态扩展！手把手教你解锁大模型 N 种实用技能，提升模型的应用能力。</p>
<p>第三部分 训练和微调语言模型（第10~12章）：探讨从嵌入模型搭建的底层方法论，到分类任务的高效优化技巧，再到生成式模型的针对性微调方案，全程拆解可落地的实操路径，拒绝晦涩理论。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0810f97cc3994259a8643fb0bd971f1c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548621&amp;x-signature=h97LvMoaQ4dESLH9EtD1lh6HVYo%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">课程目录如下：</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3a19562d880e44e786d95c125bacfe7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548621&amp;x-signature=YBDuShtA7u87aszbMwP6Im%2BY4Vg%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c9f73a8d4af1444d9adba6cd8c971c92~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548621&amp;x-signature=yvl6t70Kx4H%2FQf7EWhsYLjclZoU%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5665cee72b28406dbb4d05168d0f36e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548621&amp;x-signature=eP%2BFLWl4TZ%2B5WC3QaI%2Bqd4o8rcw%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e68e0289a6d34032b0e1202021bc042e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548621&amp;x-signature=9U3qirQLZFJC5ond5Cs6ao14Osw%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51363fcae89b42418397abd9dc078904~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548621&amp;x-signature=PMO9Bf7gEIKFQSpg%2BUKwNdBlTjc%3D" alt="" loading="lazy"/></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4c365b1271ca4bd9aeaeaff1b414fe2a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5aSn5qih5Z6L5pWZ56iL:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766548621&amp;x-signature=qbbFKOzBNBfFZSmS4%2BjjMIInfx0%3D" alt="" loading="lazy"/></p>
<p>本书适合对大模型感兴趣的开发者、研究人员和行业从业者。读者无须深度学习基础，只要会用Python，就可以通过本书深入理解大模型的原理并上手大模型应用开发。</p>
<h3 data-id="heading-1">学习资源推荐</h3>
<p>如果你想更深入地学习大模型，以下是一些非常有价值的学习资源，这些资源将帮助你从不同角度学习大模型，提升你的实践能力。</p>
<blockquote>
<p>本文较长，建议点赞收藏。更多AI大模型应用开发学习视频及资料，在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitcode.com%2FEnjoyEDU%2FLLM" target="_blank" title="https://gitcode.com/EnjoyEDU/LLM" ref="nofollow noopener noreferrer">这里</a>。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[开箱即用的 GoWind Admin｜风行，企业级前后端一体中后台框架：Makefile 在后端开发中的应用与 Windows 环境配置]]></title>    <link>https://juejin.cn/post/7584340871413202971</link>    <guid>https://juejin.cn/post/7584340871413202971</guid>    <pubDate>2025-12-17T02:05:51.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584340871413202971" data-draft-id="7584340871413186587" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="开箱即用的 GoWind Admin｜风行，企业级前后端一体中后台框架：Makefile 在后端开发中的应用与 Windows 环境配置"/> <meta itemprop="keywords" content="后端,Go"/> <meta itemprop="datePublished" content="2025-12-17T02:05:51.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="喵个咪"/> <meta itemprop="url" content="https://juejin.cn/user/1350630784901262"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            开箱即用的 GoWind Admin｜风行，企业级前后端一体中后台框架：Makefile 在后端开发中的应用与 Windows 环境配置
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1350630784901262/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    喵个咪
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:05:51.000Z" title="Wed Dec 17 2025 02:05:51 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    11
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">开箱即用的 GoWind Admin｜风行，企业级前后端一体中后台框架：Makefile 在后端开发中的应用与 Windows 环境配置</h2>
<p>在企业级中后台框架的开发过程中，高效的工程化管理是提升团队协作效率、保障开发流程规范的核心。GoWind Admin（风行）作为一款基于 Go 微服务框架 go-kratos 和 Vue 前端框架 Vben Admin 的全栈解决方案，其后端工程化体系中，Makefile 扮演了至关重要的角色 —— 它通过统一的命令集简化了复杂的构建流程，实现了环境初始化、依赖管理、代码生成、服务部署等操作的自动化，让开发者能够聚焦业务逻辑而非繁琐的工具链配置。本文将系统介绍 Windows 环境下 make 工具的安装方法、Makefile 的分层设计逻辑，以及核心命令的实战应用。</p>
<h3 data-id="heading-1">一、Makefile 在 GoWind Admin 后端开发中的核心价值</h3>
<p>GoWind Admin 后端采用模块化微服务设计，涉及 protobuf 代码生成、依赖管理、服务构建、容器化部署等多个环节。手动执行这些操作不仅繁琐，还容易因环境差异导致错误。Makefile 通过定义标准化命令封装流程，核心价值体现在：</p>
<ol>
<li><strong>跨平台一致性</strong>：无论开发者使用 Windows、macOS 还是 Linux，通过相同的 <code>make</code> 命令即可完成环境初始化、代码生成等操作，消除系统差异带来的流程割裂。</li>
<li><strong>工具链整合</strong>：将 go-kratos、ent、wire、buf 等工具的调用逻辑封装，无需记忆复杂参数（如 <code>buf generate --template buf.admin.openapi.gen.yaml</code>），通过 <code>make openapi</code> 即可一键执行。</li>
<li><strong>流程自动化串联</strong>：例如 <code>make all</code> 可依次完成代码生成、依赖安装、服务构建全流程，避免手动分步操作的遗漏。</li>
<li><strong>低门槛协作</strong>：新开发者通过 <code>make help</code> 即可查看所有命令及说明，无需深入理解工具细节即可快速上手。</li>
<li><strong>分层管理灵活性</strong>：根目录 Makefile 负责全局流程（如批量构建所有服务），服务目录 Makefile 聚焦单服务操作（如单独调试 admin 服务），兼顾全局统一与局部灵活。</li>
</ol>
<h3 data-id="heading-2">二、Windows 环境下 make 工具的安装与配置</h3>
<p>与 Linux/macOS 不同，Windows 系统默认不预装 make 工具，GoWind Admin 提供两种安装方式，可根据需求选择：</p>
<h4 data-id="heading-3">方式一：通过 scoop 包管理器手动安装（推荐）</h4>
<h5 data-id="heading-4">1. 安装 scoop（Windows 包管理器）</h5>
<p>打开 PowerShell（管理员模式），执行以下命令开启脚本执行权限并安装 scoop：</p>
<pre><code class="hljs language-powershell" lang="powershell"># 允许本地脚本执行
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
# 安装scoop
irm get.scoop.sh | iex
</code></pre>
<h5 data-id="heading-5">2. 安装 make 及依赖工具</h5>
<p>scoop 安装完成后，通过以下命令安装 make：</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">添加包含 make 的 extras 仓库</span>
scoop bucket add extras
<span class="hljs-meta prompt_"># </span><span class="bash">安装 make 及开发必需工具（git、go、protobuf 等）</span>
scoop install make git go protobuf buf gawk grep sed jq
</code></pre>
<h5 data-id="heading-6">3. 验证安装</h5>
<p>在 PowerShell 中执行<code>make --version</code>，若输出类似以下内容，说明安装成功：</p>
<pre><code class="hljs language-powershell" lang="powershell">GNU Make 4.4.1
Built for x86_64-w64-mingw32
Copyright (C) 1988-2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;https://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
</code></pre>
<h4 data-id="heading-7">方式二：通过一键脚本自动配置（懒人必备）</h4>
<p>GoWind Admin 提供 <code>prepare_windows.ps1</code> 脚本，可自动完成 scoop、make、Go、Docker 等全套开发环境的安装：</p>
<h5 data-id="heading-8">1. 运行脚本在项目根目录打开 PowerShell（管理员模式），执行：</h5>
<pre><code class="hljs language-powershell" lang="powershell">./backend/script/prepare_windows.ps1
</code></pre>
<h5 data-id="heading-9">2. 脚本功能说明该脚本会自动完成：</h5>
<ul>
<li>安装 scoop 及 make、git 等基础工具</li>
<li>配置 Go 环境（设置 GOPATH 并添加到 PATH）</li>
<li>安装 Docker Desktop 并尝试配置自动启动</li>
<li>安装 Node.js 及 PM2（用于服务进程管理）</li>
</ul>
<h5 data-id="heading-10">3. 后续配置脚本执行完成后，根据提示手动将以下路径添加到系统环境变量（确保工具全局可用）：</h5>
<ul>
<li>Go 二进制路径：<code>%USERPROFILE%\go\bin</code></li>
<li>NPM 全局工具路径：<code>%USERPROFILE%\.npm-global\bin</code></li>
</ul>
<h3 data-id="heading-11">三、Makefile 分层设计与核心命令详解</h3>
<p>GoWind Admin 采用「根目录 Makefile + app.mk + 服务目录 Makefile」的分层设计，既保证全局流程统一，又支持单服务精细化操作。</p>
<h4 data-id="heading-12">1. 根目录 Makefile（全局工程管理）</h4>
<p>位于 <code>backend/Makefile</code>，负责跨服务的全局操作，核心命令如下：</p>






































































<table><thead><tr><th>命令</th><th>功能说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>make init</code></td><td>初始化开发环境，安装 protoc 插件（如 protoc-gen-go）、cli 工具（如 kratos、buf）</td><td>首次拉取项目后执行</td></tr><tr><td><code>make dep</code></td><td>执行 <code>go mod download</code>，拉取所有 Go 模块依赖</td><td>依赖更新后同步</td></tr><tr><td><code>make vendor</code></td><td>生成 <code>vendor</code> 目录固化依赖版本</td><td>需离线部署或版本锁定时</td></tr><tr><td><code>make gen</code></td><td>批量生成所有服务的代码（ent 模型、wire 依赖注入、API 代码等）</td><td>全量更新代码生成文件</td></tr><tr><td><code>make build</code></td><td>构建所有微服务的可执行文件（构建前自动生成 API 代码）</td><td>打包所有服务部署包</td></tr><tr><td><code>make build_only</code></td><td>直接构建所有服务（跳过代码生成，适合依赖未变更时）</td><td>快速重新构建</td></tr><tr><td><code>make docker</code></td><td>为所有服务生成 Docker 镜像</td><td>容器化部署前执行</td></tr><tr><td><code>make compose-up</code></td><td>通过 docker-compose 启动所有依赖中间件（MySQL、Redis 等）</td><td>本地开发环境初始化</td></tr><tr><td><code>make compose-up-without-service</code></td><td>仅启动中间件，不启动后端服务</td><td>需单独调试服务时</td></tr><tr><td><code>make test</code></td><td>执行所有单元测试</td><td>提交代码前验证功能</td></tr><tr><td><code>make lint</code></td><td>通过 golangci-lint 检查代码风格与质量</td><td>代码提交前规范检查</td></tr><tr><td><code>make help</code></td><td>查看所有命令及说明</td><td>新手快速了解命令功能</td></tr></tbody></table>
<h4 data-id="heading-13">2. app.mk 与服务目录 Makefile（单服务操作）</h4>
<p>每个服务目录（如 <code>app/admin/service</code>）下的 Makefile 仅一行代码：<code>include ../../../app.mk</code>，即通过引入根目录的 <code>app.mk</code> 实现单服务命令标准化。核心命令如下：</p>













































<table><thead><tr><th>命令</th><th>功能说明</th><th>适用场景</th></tr></thead><tbody><tr><td><code>make run</code></td><td>启动当前服务（加载本地配置，适合调试）</td><td>开发时实时调试单个服务</td></tr><tr><td><code>make api</code></td><td>基于当前服务的 protobuf 生成 Go 接口代码</td><td>仅更新当前服务 API 定义后</td></tr><tr><td><code>make ent</code></td><td>生成当前服务的 ent 数据库模型代码</td><td>数据库表结构变更后</td></tr><tr><td><code>make wire</code></td><td>生成当前服务的依赖注入代码</td><td>服务内部依赖关系变更后</td></tr><tr><td><code>make openapi</code></td><td>生成当前服务的 OpenAPI 文档</td><td>需更新接口文档时</td></tr><tr><td><code>make ts</code></td><td>生成当前服务的 TypeScript 调用代码（供前端使用）</td><td>前后端接口同步时</td></tr><tr><td><code>make build</code></td><td>仅构建当前服务的可执行文件</td><td>单独部署某个服务时</td></tr></tbody></table>
<h4 data-id="heading-14">3. 实战场景示例</h4>
<h5 data-id="heading-15">场景 1：首次拉取项目，初始化环境并启动服务</h5>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">进入后端目录</span>
cd backend
<span class="hljs-meta prompt_"># </span><span class="bash">初始化开发环境（安装工具链、插件）</span>
make init
<span class="hljs-meta prompt_"># </span><span class="bash">启动依赖中间件（MySQL、Redis等）</span>
make compose-up
<span class="hljs-meta prompt_"># </span><span class="bash">生成所有代码（API、数据库模型等）</span>
make gen
<span class="hljs-meta prompt_"># </span><span class="bash">构建所有服务</span>
make build
<span class="hljs-meta prompt_"># </span><span class="bash">进入admin服务目录，启动调试</span>
cd app/admin/service
make run
</code></pre>
<h5 data-id="heading-16">场景 2：单独修改 admin 服务的 API 定义，更新代码并测试</h5>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">进入admin服务目录</span>
cd backend/app/admin/service
<span class="hljs-meta prompt_"># </span><span class="bash">生成当前服务的API代码</span>
make api
<span class="hljs-meta prompt_"># </span><span class="bash">生成OpenAPI文档</span>
make openapi
<span class="hljs-meta prompt_"># </span><span class="bash">本地启动服务验证</span>
make run
<span class="hljs-meta prompt_"># </span><span class="bash">回到根目录，执行单元测试</span>
cd ../../..
make test
</code></pre>
<h5 data-id="heading-17">场景 3：构建所有服务的 Docker 镜像并部署</h5>
<pre><code class="hljs language-shell" lang="shell">cd backend
<span class="hljs-meta prompt_"># </span><span class="bash">生成最新代码</span>
make gen
<span class="hljs-meta prompt_"># </span><span class="bash">构建所有服务的Docker镜像</span>
make docker
<span class="hljs-meta prompt_"># </span><span class="bash">启动所有服务及依赖（容器化部署）</span>
make compose-up
</code></pre>
<h3 data-id="heading-18">四、Windows 环境下的注意事项</h3>
<ol>
<li><strong>PowerShell 兼容性</strong>：部分命令（如 <code>sed</code>、<code>grep</code>）依赖 scoop 安装的 GNU 工具，需确保 PowerShell 中优先调用这些工具（可通过 <code>Get-Command sed</code> 验证）。</li>
<li><strong>路径格式</strong>：Windows 下路径使用反斜杠 <code>\</code>，但 Makefile 中统一使用正斜杠 <code>/</code>（Make 工具会自动转换），避免手动修改路径导致错误。</li>
<li><strong>Go 代理配置</strong>：若依赖拉取缓慢，可通过以下命令设置代理：
<pre><code class="hljs language-powershell" lang="powershell">go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct
</code></pre>
</li>
<li><strong>Docker 权限</strong>：<code>make compose-up</code> 需 Docker 已启动，若提示权限不足，可右键 Docker 图标选择「以管理员身份运行」。</li>
</ol>
<h3 data-id="heading-19">五、总结</h3>
<p>Makefile 作为 GoWind Admin 后端工程化的核心工具，通过分层设计实现了「全局统一流程」与「单服务灵活操作」的平衡。在 Windows 环境下，无论是通过 scoop 手动安装还是一键脚本自动配置，都能快速搭建 make 工具链，结合预置的命令集，开发者可轻松完成从环境初始化到服务部署的全流程操作。</p>
<p>熟练掌握这些命令，不仅能提升个人开发效率，更能保障团队协作的规范性，让中后台开发真正实现「如风般自由」。</p>
<h4 data-id="heading-20">项目仓库</h4>
<ul>
<li>GoWind Admin（Gitee）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Ftx7do%2Fgo-wind-admin" target="_blank" title="https://gitee.com/tx7do/go-wind-admin" ref="nofollow noopener noreferrer">gitee.com/tx7do/go-wi…</a></li>
<li>GoWind Admin（GitHub）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftx7do%2Fgo-wind-admin" target="_blank" title="https://github.com/tx7do/go-wind-admin" ref="nofollow noopener noreferrer">github.com/tx7do/go-wi…</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[闭包、现代JS架构的基石(吊打面试官)]]></title>    <link>https://juejin.cn/post/7584340871413088283</link>    <guid>https://juejin.cn/post/7584340871413088283</guid>    <pubDate>2025-12-17T01:56:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584340871413088283" data-draft-id="7584345932944293939" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="闭包、现代JS架构的基石(吊打面试官)"/> <meta itemprop="keywords" content="前端,JavaScript,面试"/> <meta itemprop="datePublished" content="2025-12-17T01:56:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="豆苗学前端"/> <meta itemprop="url" content="https://juejin.cn/user/1935598759719400"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            闭包、现代JS架构的基石(吊打面试官)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1935598759719400/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    豆苗学前端
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T01:56:48.000Z" title="Wed Dec 17 2025 01:56:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读18分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">JavaScript 闭包全解析：从入门到实战应用</h2>
<h3 data-id="heading-1">📚 目录</h3>
<ol>
<li><a href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" title="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">闭包的基本概念</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%BD%A2%E6%88%90%E6%9D%A1%E4%BB%B6" title="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%BD%A2%E6%88%90%E6%9D%A1%E4%BB%B6">闭包的形成条件</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B" title="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B">闭包的入门示例</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7" title="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7">闭包的核心特性</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" title="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">闭包的实际应用场景</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" title="#%E9%97%AD%E5%8C%85%E7%9A%84%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">闭包的常见陷阱与解决方案</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE" title="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE">性能优化建议</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE" title="#%E7%BB%BC%E5%90%88%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE">综合实战项目</a></li>
</ol>
<hr/>
<h3 data-id="heading-2">🔍 闭包的基本概念</h3>
<h4 data-id="heading-3">什么是闭包？</h4>
<p>闭包（Closure）是指函数能够访问其外部作用域中的变量，即使在外部函数执行完毕后，内部函数仍然可以访问这些变量。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 基本的闭包示例</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params">x</span>) {
    <span class="hljs-comment">// 外部函数的变量</span>
    <span class="hljs-keyword">let</span> outerVariable = x;
    
    <span class="hljs-comment">// 内部函数（闭包）</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 内部函数可以访问外部函数的变量</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVariable);
    }
    
    <span class="hljs-keyword">return</span> innerFunction;
}

<span class="hljs-comment">// 创建闭包</span>
<span class="hljs-keyword">const</span> myClosure = <span class="hljs-title function_">outerFunction</span>(<span class="hljs-number">10</span>);
<span class="hljs-title function_">myClosure</span>(); <span class="hljs-comment">// 输出: 10，尽管 outerFunction 已经执行完毕</span>
</code></pre>
<hr/>
<h3 data-id="heading-4">🎯 闭包的形成条件</h3>
<h4 data-id="heading-5">⚠️ 重要概念澄清：闭包形成 vs 闭包的实际应用</h4>
<p>很多开发者对闭包有一个误解：<strong>认为形成闭包必须外部函数返回内部函数</strong>。实际上，这是一个需要澄清的重要概念：</p>
<p><strong>闭包的本质</strong>：内部函数持有了对外部函数作用域变量的引用，即使外部函数已经执行完毕，这些变量也不会被垃圾回收。</p>
<h4 data-id="heading-6">闭包形成的真实条件</h4>
<p>闭包的形成只需要满足以下两个核心条件：</p>
<ol>
<li><strong>函数嵌套</strong>：必须有一个外部函数和一个内部函数</li>
<li><strong>内部函数引用外部变量</strong>：内部函数必须引用外部函数中的变量</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 但闭包存在但没有实际意义的例子</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> secret = <span class="hljs-string">'我是秘密'</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(secret); <span class="hljs-comment">// 内部函数引用了外部变量 -&gt; 闭包已形成</span>
    }
    
    <span class="hljs-comment">// 没有 return innerFunction</span>
    <span class="hljs-title function_">innerFunction</span>(); <span class="hljs-comment">// 直接在 outerFunction 内部调用</span>
}

<span class="hljs-title function_">outerFunction</span>(); <span class="hljs-comment">// 输出：我是秘密</span>
</code></pre>
<p>在这个例子中：</p>
<ul>
<li><code>innerFunction</code> 确实形成了闭包——它引用了 <code>secret</code></li>
<li>但 <code>innerFunction</code> 没有被返回，也没有在 <code>outerFunction</code> 外部被调用</li>
<li>所以闭包确实存在，但它只在 <code>outerFunction</code> 执行期间有效</li>
<li>执行结束后，<code>innerFunction</code> 和 <code>secret</code> 都会被垃圾回收</li>
</ul>
<h4 data-id="heading-7">为什么"返回"如此重要？</h4>
<p>只有当内部函数被返回并赋值给外部变量，或作为回调传递出去，它才能在外部作用域中被调用，这时闭包的"持久化"特性才真正体现出来：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ✅ 闭包有实际意义的例子</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 外部变量</span>
    
    <span class="hljs-comment">// 返回内部函数，让闭包在外部可被调用</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"/>) {
        count++; <span class="hljs-comment">// 引用外部变量</span>
        <span class="hljs-keyword">return</span> count;
    };
}

<span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>(); <span class="hljs-comment">// 外部持有 innerFunction 的引用</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>()); <span class="hljs-comment">// 1 —— 即使 createCounter 已执行完，count 仍被保留</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter</span>()); <span class="hljs-comment">// 2</span>
</code></pre>
<h4 data-id="heading-8">闭包的第三种条件：持久化机制</h4>
<p>为了完整理解，我们可以将闭包的条件分为：</p>
<ol>
<li>
<p><strong>形成条件</strong>（必要条件）：</p>
<ul>
<li>函数嵌套</li>
<li>内部函数引用外部变量</li>
</ul>
</li>
<li>
<p><strong>应用条件</strong>（实际价值）：</p>
<ul>
<li>内部函数被返回或传递，使其能在外部作用域中被调用</li>
</ul>
</li>
</ol>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 闭包形成但无法在外部使用的情况</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">case1</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> value = <span class="hljs-number">10</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">hasClosure</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 形成闭包</span>
    }
    
    <span class="hljs-comment">// 闭包存在，但无法在外部使用</span>
    <span class="hljs-title function_">hasClosure</span>();
}

<span class="hljs-comment">// 闭包形成且可在外部使用的情况</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">case2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> value = <span class="hljs-number">10</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">hasClosure</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 形成闭包</span>
    }
    
    <span class="hljs-keyword">return</span> hasClosure; <span class="hljs-comment">// 返回闭包，使其可在外部使用</span>
}

<span class="hljs-keyword">const</span> myClosure = <span class="hljs-title function_">case2</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myClosure</span>()); <span class="hljs-comment">// 10 - 闭包在外部被调用</span>
</code></pre>
<h4 data-id="heading-9">多种闭包传递方式</h4>
<p>除了 <code>return</code>，闭包还可以通过多种方式传递到外部：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 作为参数传递</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">asParameter</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> message = <span class="hljs-string">'回调消息'</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// 闭包形成</span>
    }
    
    <span class="hljs-built_in">setTimeout</span>(callback, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 传递给 setTimeout</span>
}

<span class="hljs-comment">// 2. 作为对象方法返回</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">asMethod</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> data = <span class="hljs-string">'私有数据'</span>;
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">getData</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">return</span> data; <span class="hljs-comment">// 闭包形成</span>
        },
        
        <span class="hljs-attr">setData</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
            data = value;
        }
    };
}

<span class="hljs-comment">// 3. 作为事件处理器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">asEventHandler</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> clickCount = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"/>) {
        clickCount++;
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`点击次数: <span class="hljs-subst">${clickCount}</span>`</span>);
    }
    
    <span class="hljs-comment">// 假设有一个按钮元素</span>
    <span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'myButton'</span>);
    <span class="hljs-keyword">if</span> (button) {
        button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handleClick); <span class="hljs-comment">// 传递为事件处理器</span>
    }
    
    <span class="hljs-keyword">return</span> handleClick; <span class="hljs-comment">// 也可以返回</span>
}
</code></pre>
<h4 data-id="heading-10">🎯 总结</h4>
<ul>
<li>✅ <strong>闭包形成</strong>：只要内部函数引用了外部作用域变量，闭包就已形成</li>
<li>✅ <strong>闭包的实际价值</strong>：必须通过返回或传递，让内部函数在外部作用域中被调用</li>
<li>❌ <strong>常见误解</strong>：认为 <code>return</code> 是形成闭包的必要条件</li>
<li>✅ <strong>正确理解</strong>：<code>return</code> 或其他传递方式是闭包产生实际意义的必要条件</li>
</ul>
<p><strong>所以，返回不是形成闭包的必要条件，但却是闭包产生实际应用的必要条件。</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 闭包形成的三个条件演示</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> privateVariable = <span class="hljs-string">"我是私有变量"</span>; <span class="hljs-comment">// 条件1：外部变量</span>
    
    <span class="hljs-comment">// 条件2：内部函数引用外部变量</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">closureFunction</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> privateVariable;
    }
    
    <span class="hljs-comment">// 条件3：返回内部函数</span>
    <span class="hljs-keyword">return</span> closureFunction;
}

<span class="hljs-keyword">const</span> closure = <span class="hljs-title function_">createClosure</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">closure</span>()); <span class="hljs-comment">// "我是私有变量"</span>
</code></pre>
<hr/>
<h3 data-id="heading-11">🌟 闭包的入门示例</h3>
<h4 data-id="heading-12">示例1：计数器</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建一个简单的计数器闭包</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 私有变量，外部无法直接访问</span>
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// 增加计数</span>
        <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            count++;
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前计数: <span class="hljs-subst">${count}</span>`</span>);
        },
        
        <span class="hljs-comment">// 减少计数</span>
        <span class="hljs-attr">decrement</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) {
                count--;
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`当前计数: <span class="hljs-subst">${count}</span>`</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"计数不能小于0"</span>);
            }
        },
        
        <span class="hljs-comment">// 获取当前计数</span>
        <span class="hljs-attr">getCount</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">return</span> count;
        }
    };
}

<span class="hljs-comment">// 使用计数器</span>
<span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();
counter.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 当前计数: 1</span>
counter.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 当前计数: 2</span>
counter.<span class="hljs-title function_">decrement</span>(); <span class="hljs-comment">// 当前计数: 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`最终计数: <span class="hljs-subst">${counter.getCount()}</span>`</span>); <span class="hljs-comment">// 最终计数: 1</span>

<span class="hljs-comment">// count变量是私有的，无法直接访问</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(counter.<span class="hljs-property">count</span>); <span class="hljs-comment">// undefined</span>
</code></pre>
<h4 data-id="heading-13">示例2：延迟执行</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用闭包实现延迟执行</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">delayedLogger</span>(<span class="hljs-params">message, delay</span>) {
    <span class="hljs-comment">// 闭包保存了 message 和 delay 的值</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);
    }, delay);
}

<span class="hljs-title function_">delayedLogger</span>(<span class="hljs-string">"Hello, World!"</span>, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 1秒后输出: Hello, World!</span>
<span class="hljs-title function_">delayedLogger</span>(<span class="hljs-string">"延迟2秒的消息"</span>, <span class="hljs-number">2000</span>); <span class="hljs-comment">// 2秒后输出: 延迟2秒的消息</span>
</code></pre>
<hr/>
<h3 data-id="heading-14">💡 闭包的核心特性</h3>
<h4 data-id="heading-15">1. 变量持久化</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPersistentVariable</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> persistent = <span class="hljs-string">"我持久存在"</span>;
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> persistent; <span class="hljs-comment">// 即使外部函数执行完毕，persistent依然存在</span>
    };
}

<span class="hljs-keyword">const</span> persistentFunc = <span class="hljs-title function_">createPersistentVariable</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">persistentFunc</span>()); <span class="hljs-comment">// "我持久存在"</span>
</code></pre>
<h4 data-id="heading-16">2. 数据封装和私有化</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建一个带有私有数据对象</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createPrivateObject</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> privateData = {
        <span class="hljs-attr">secret</span>: <span class="hljs-string">"这是私有数据"</span>,
        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>
    };
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// 只能通过这些方法访问私有数据</span>
        <span class="hljs-attr">getSecret</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">return</span> privateData.<span class="hljs-property">secret</span>;
        },
        
        <span class="hljs-attr">incrementCount</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            privateData.<span class="hljs-property">count</span>++;
        },
        
        <span class="hljs-attr">getCount</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">return</span> privateData.<span class="hljs-property">count</span>;
        }
    };
}

<span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">createPrivateObject</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">getSecret</span>()); <span class="hljs-comment">// "这是私有数据"</span>
obj.<span class="hljs-title function_">incrementCount</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-title function_">getCount</span>()); <span class="hljs-comment">// 1</span>

<span class="hljs-comment">// 无法直接访问 privateData</span>
<span class="hljs-comment">// console.log(obj.privateData); // undefined</span>
</code></pre>
<h4 data-id="heading-17">3. 函数工厂</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建具有特定配置的函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-params">factor</span>) {
    <span class="hljs-comment">// 返回一个新函数，该函数会记住factor的值</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">number</span>) {
        <span class="hljs-keyword">return</span> number * factor;
    };
}

<span class="hljs-comment">// 创建特定的乘法函数</span>
<span class="hljs-keyword">const</span> double = <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> triple = <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-number">3</span>);
<span class="hljs-keyword">const</span> quadruple = <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-number">4</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">double</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">triple</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 15</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">quadruple</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 20</span>
</code></pre>
<h4 data-id="heading-18">4. 闭包的生命周期管理</h4>
<p>理解闭包的生命周期对于避免内存泄漏和优化性能至关重要：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 闭包生命周期完整演示
 */</span>

<span class="hljs-comment">// 阶段1：闭包创建</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> lifecycle = <span class="hljs-string">'创建阶段'</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1. 外部函数执行，创建闭包环境'</span>);
    
    <span class="hljs-comment">// 内部函数捕获外部作用域</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`闭包访问: <span class="hljs-subst">${lifecycle}</span>`</span>;
    }
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'2. 内部函数已捕获外部变量，闭包形成'</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'3. 外部函数即将执行完毕'</span>);
    
    <span class="hljs-keyword">return</span> innerFunction; <span class="hljs-comment">// 返回闭包，保持其生命周期</span>
}

<span class="hljs-comment">// 阶段2：闭包活跃期</span>
<span class="hljs-keyword">const</span> myClosure = <span class="hljs-title function_">createClosure</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'4. 闭包在外部被调用，进入活跃期'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myClosure</span>()); <span class="hljs-comment">// "闭包访问: 创建阶段"</span>

<span class="hljs-comment">// 阶段3：闭包持久期</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'5. 即使外部函数执行完毕，闭包依然存在'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">myClosure</span>()); <span class="hljs-comment">// "闭包访问: 创建阶段"</span>

<span class="hljs-comment">// 阶段4：闭包销毁期</span>
myClosure = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 移除对闭包的引用</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'6. 闭包引用被移除，等待垃圾回收'</span>);

<span class="hljs-comment">// 垃圾回收会在适当时候回收闭包及其捕获的变量</span>
</code></pre>
<h4 data-id="heading-19">5. 闭包的内存特征</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 闭包的内存特征分析
 */</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">analyzeClosureMemory</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 闭包捕获的变量会一直存在于内存中</span>
    <span class="hljs-keyword">let</span> capturedVariables = {
        <span class="hljs-attr">string</span>: <span class="hljs-string">'字符串变量'</span>,
        <span class="hljs-attr">number</span>: <span class="hljs-number">42</span>,
        <span class="hljs-attr">array</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],
        <span class="hljs-attr">object</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'对象'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">100</span> }
    };
    
    <span class="hljs-comment">// 每次调用都会创建新的闭包实例</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosureInstance</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 每个闭包实例都有独立的作用域链</span>
        <span class="hljs-keyword">let</span> instanceId = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>);
        
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">getId</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
                <span class="hljs-keyword">return</span> instanceId;
            },
            
            <span class="hljs-attr">getCapturedData</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-comment">// 注意：这里访问的是同一个 capturedVariables 对象</span>
                    <span class="hljs-attr">string</span>: capturedVariables.<span class="hljs-property">string</span>,
                    <span class="hljs-attr">number</span>: capturedVariables.<span class="hljs-property">number</span>,
                    <span class="hljs-attr">arrayLength</span>: capturedVariables.<span class="hljs-property">array</span>.<span class="hljs-property">length</span>,
                    <span class="hljs-attr">objectName</span>: capturedVariables.<span class="hljs-property">object</span>.<span class="hljs-property">name</span>
                };
            },
            
            <span class="hljs-comment">// 修改捕获的数据会影响其他闭包实例</span>
            <span class="hljs-attr">modifyCapturedData</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) {
                <span class="hljs-keyword">if</span> (capturedVariables.<span class="hljs-title function_">hasOwnProperty</span>(key)) {
                    capturedVariables[key] = value;
                }
            }
        };
    }
    
    <span class="hljs-comment">// 创建两个闭包实例</span>
    <span class="hljs-keyword">const</span> closure1 = <span class="hljs-title function_">createClosureInstance</span>();
    <span class="hljs-keyword">const</span> closure2 = <span class="hljs-title function_">createClosureInstance</span>();
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'实例1 ID:'</span>, closure1.<span class="hljs-title function_">getId</span>());
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'实例2 ID:'</span>, closure2.<span class="hljs-title function_">getId</span>());
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'实例1访问捕获数据:'</span>, closure1.<span class="hljs-title function_">getCapturedData</span>());
    
    <span class="hljs-comment">// 实例2修改数据</span>
    closure2.<span class="hljs-title function_">modifyCapturedData</span>(<span class="hljs-string">'string'</span>, <span class="hljs-string">'已修改的字符串'</span>);
    
    <span class="hljs-comment">// 实例1也能看到修改后的数据（共享同一个捕获对象）</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'修改后实例1访问数据:'</span>, closure1.<span class="hljs-title function_">getCapturedData</span>());
    
    <span class="hljs-keyword">return</span> { closure1, closure2 };
}

<span class="hljs-keyword">const</span> { closure1, closure2 } = <span class="hljs-title function_">analyzeClosureMemory</span>();
</code></pre>
<hr/>
<h3 data-id="heading-20">🚀 闭包的实际应用场景</h3>
<h4 data-id="heading-21">场景1：模块化开发</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用闭包创建模块</span>
<span class="hljs-keyword">const</span> myModule = (<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 私有变量和方法</span>
    <span class="hljs-keyword">let</span> privateVar = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"这是私有方法"</span>);
        privateVar++;
    }
    
    <span class="hljs-comment">// 公共接口</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">publicMethod</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"这是公共方法"</span>);
            <span class="hljs-title function_">privateMethod</span>(); <span class="hljs-comment">// 调用私有方法</span>
            <span class="hljs-keyword">return</span> privateVar;
        },
        
        <span class="hljs-attr">publicVar</span>: <span class="hljs-string">"这是公共变量"</span>
    };
})();

<span class="hljs-comment">// 使用模块</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myModule.<span class="hljs-title function_">publicMethod</span>()); <span class="hljs-comment">// "这是公共方法", "这是私有方法", 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myModule.<span class="hljs-property">publicVar</span>); <span class="hljs-comment">// "这是公共变量"</span>
<span class="hljs-comment">// myModule.privateVar 和 myModule.privateMethod 无法访问</span>
</code></pre>
<h4 data-id="heading-22">场景2：事件处理器中的状态保持</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// HTML示例: &lt;button id="btn-1"&gt;按钮1&lt;/button&gt;, &lt;button id="btn-2"&gt;按钮2&lt;/button&gt;</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setupButtons</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> clickCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 所有按钮共享的点击计数</span>
    
    <span class="hljs-comment">// 为每个按钮设置事件处理器</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'button'</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">button, index</span>) =&gt;</span> {
        <span class="hljs-comment">// 每个按钮都有自己的闭包</span>
        button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            clickCount++; <span class="hljs-comment">// 所有按钮共享的计数器</span>
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`按钮<span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>被点击，总点击次数: <span class="hljs-subst">${clickCount}</span>`</span>);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`这是第<span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>个按钮`</span>);
        });
    });
}

<span class="hljs-comment">// 在浏览器中调用: setupButtons();</span>
</code></pre>
<h4 data-id="heading-23">场景3：防抖和节流函数</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 防抖函数：在指定时间内只执行最后一次</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">func, delay</span>) {
    <span class="hljs-keyword">let</span> timeoutId; <span class="hljs-comment">// 闭包保存定时器ID</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
        <span class="hljs-comment">// 清除之前的定时器</span>
        <span class="hljs-built_in">clearTimeout</span>(timeoutId);
        
        <span class="hljs-comment">// 设置新的定时器</span>
        timeoutId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        }, delay);
    };
}

<span class="hljs-comment">// 节流函数：在指定时间内只执行一次</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">func, limit</span>) {
    <span class="hljs-keyword">let</span> inThrottle; <span class="hljs-comment">// 闭包保存节流状态</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
        <span class="hljs-keyword">if</span> (!inThrottle) {
            func.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
            inThrottle = <span class="hljs-literal">true</span>;
            
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
                inThrottle = <span class="hljs-literal">false</span>;
            }, limit);
        }
    };
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> searchInput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'search'</span>);
<span class="hljs-keyword">if</span> (searchInput) {
    <span class="hljs-comment">// 防抖搜索</span>
    <span class="hljs-keyword">const</span> debouncedSearch = <span class="hljs-title function_">debounce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'搜索内容:'</span>, e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);
        <span class="hljs-comment">// 执行搜索逻辑</span>
    }, <span class="hljs-number">300</span>);
    
    searchInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'input'</span>, debouncedSearch);
}
</code></pre>
<h4 data-id="heading-24">场景4：缓存机制（记忆化）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建一个带缓存功能的函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">memoize</span>(<span class="hljs-params">fn</span>) {
    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 闭包保存缓存</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
        <span class="hljs-keyword">const</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args); <span class="hljs-comment">// 创建缓存键</span>
        
        <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(key)) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'从缓存中获取结果'</span>);
            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(key);
        }
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'计算新结果并缓存'</span>);
        <span class="hljs-keyword">const</span> result = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        cache.<span class="hljs-title function_">set</span>(key, result);
        <span class="hljs-keyword">return</span> result;
    };
}

<span class="hljs-comment">// 缓存斐波那契数列计算</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>) {
    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">2</span>);
}

<span class="hljs-comment">// 创建带缓存的斐波那契函数</span>
<span class="hljs-keyword">const</span> memoizedFibonacci = <span class="hljs-title function_">memoize</span>(fibonacci);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'第一次计算'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">memoizedFibonacci</span>(<span class="hljs-number">35</span>)); <span class="hljs-comment">// 会计算</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'第一次计算'</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">'第二次计算'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">memoizedFibonacci</span>(<span class="hljs-number">35</span>)); <span class="hljs-comment">// 从缓存获取</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">'第二次计算'</span>);
</code></pre>
<h4 data-id="heading-25">场景5：状态管理器</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 简单的状态管理器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createStateManager</span>(<span class="hljs-params">initialState</span>) {
    <span class="hljs-keyword">let</span> state = initialState; <span class="hljs-comment">// 闭包保存状态</span>
    <span class="hljs-keyword">const</span> subscribers = []; <span class="hljs-comment">// 闭包保存订阅者列表</span>
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">// 获取当前状态</span>
        <span class="hljs-attr">getState</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">return</span> { ...state }; <span class="hljs-comment">// 返回副本，避免直接修改</span>
        },
        
        <span class="hljs-comment">// 更新状态</span>
        <span class="hljs-attr">setState</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newState</span>) {
            state = { ...state, ...newState };
            
            <span class="hljs-comment">// 通知所有订阅者</span>
            subscribers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> <span class="hljs-title function_">callback</span>(state));
        },
        
        <span class="hljs-comment">// 订阅状态变化</span>
        <span class="hljs-attr">subscribe</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) {
            subscribers.<span class="hljs-title function_">push</span>(callback);
            
            <span class="hljs-comment">// 返回取消订阅函数</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
                <span class="hljs-keyword">const</span> index = subscribers.<span class="hljs-title function_">indexOf</span>(callback);
                <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) {
                    subscribers.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
                }
            };
        }
    };
}

<span class="hljs-comment">// 使用状态管理器</span>
<span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStateManager</span>({ 
    <span class="hljs-attr">user</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> },
    <span class="hljs-attr">theme</span>: <span class="hljs-string">'light'</span>
});

<span class="hljs-comment">// 订阅状态变化</span>
<span class="hljs-keyword">const</span> unsubscribe = store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">newState</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'状态已更新:'</span>, newState);
});

<span class="hljs-comment">// 更新状态</span>
store.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">user</span>: { <span class="hljs-attr">name</span>: <span class="hljs-string">'李四'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> } });
store.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">theme</span>: <span class="hljs-string">'dark'</span> });

<span class="hljs-comment">// 取消订阅</span>
<span class="hljs-title function_">unsubscribe</span>();
</code></pre>
<hr/>
<h3 data-id="heading-26">⚠️ 闭包的常见陷阱与解决方案</h3>
<h4 data-id="heading-27">陷阱0：对闭包形成条件的误解</h4>
<p>在深入学习闭包的常见陷阱之前，首先要澄清一个最基础但最容易被误解的问题：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 常见误解：认为不返回就不形成闭包</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">misconceptionAboutClosure</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> data = <span class="hljs-string">'重要数据'</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 这里确实形成了闭包</span>
    }
    
    <span class="hljs-comment">// 没有return，但闭包已经形成了</span>
    <span class="hljs-title function_">innerFunction</span>(); <span class="hljs-comment">// 闭包在这里被使用</span>
}

<span class="hljs-comment">// ✅ 正确理解：闭包形成与是否返回无关</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">correctUnderstanding</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 这些都会形成闭包，只是使用场景不同</span>
    
    <span class="hljs-comment">// 情况1：闭包仅在函数内部使用</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">internalUse</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">let</span> config = { <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span> };
        
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">setupTimer</span>(<span class="hljs-params"/>) {
            <span class="hljs-comment">// 形成闭包，但只在内部使用</span>
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(config.<span class="hljs-property">timeout</span>), config.<span class="hljs-property">timeout</span>);
        }
        
        <span class="hljs-title function_">setupTimer</span>(); <span class="hljs-comment">// 闭包在这里被创建和调用，然后消失</span>
    }
    
    <span class="hljs-comment">// 情况2：闭包传递给外部API</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">externalUse</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">let</span> message = <span class="hljs-string">'异步消息'</span>;
        
        <span class="hljs-comment">// 闭包形成并传递给外部函数（如setTimeout、事件监听器等）</span>
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message); <span class="hljs-comment">// 闭包在外部API中被调用</span>
        }, <span class="hljs-number">100</span>);
    }
    
    <span class="hljs-comment">// 情况3：闭包作为返回值（最常见用法）</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">returnUse</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">return</span> ++counter; <span class="hljs-comment">// 闭包返回给外部使用</span>
        };
    }
    
    <span class="hljs-title function_">internalUse</span>();
    <span class="hljs-title function_">externalUse</span>();
    <span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">returnUse</span>();
}
</code></pre>
<h4 data-id="heading-28">陷阱1：循环中的闭包问题</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 错误示例：循环中的闭包问题</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createBadButtons</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
        <span class="hljs-comment">// 使用var声明，所有闭包共享同一个i变量</span>
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`按钮<span class="hljs-subst">${i}</span>被点击`</span>); <span class="hljs-comment">// 都输出: 按钮3被点击</span>
        }, <span class="hljs-number">100</span> * i);
    }
}

<span class="hljs-comment">// ✅ 解决方案1：使用let声明</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createGoodButtons</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
        <span class="hljs-comment">// 使用let，每次循环创建新的绑定</span>
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`按钮<span class="hljs-subst">${i}</span>被点击`</span>); <span class="hljs-comment">// 正确输出: 按钮0、按钮1、按钮2被点击</span>
        }, <span class="hljs-number">100</span> * i);
    }
}

<span class="hljs-comment">// ✅ 解决方案2：使用IIFE（立即执行函数表达式）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createGoodButtons2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
        <span class="hljs-comment">// 使用IIFE创建新的作用域</span>
        (<span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) {
            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`按钮<span class="hljs-subst">${index}</span>被点击`</span>);
            }, <span class="hljs-number">100</span> * index);
        })(i);
    }
}

<span class="hljs-comment">// ✅ 解决方案3：使用bind方法</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createGoodButtons3</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`按钮<span class="hljs-subst">${index}</span>被点击`</span>);
        }.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i), <span class="hljs-number">100</span> * i);
    }
}
</code></pre>
<h4 data-id="heading-29">陷阱2：内存泄漏与垃圾回收机制</h4>
<h5 data-id="heading-30">🗑️ 什么是垃圾回收？</h5>
<p>垃圾回收（Garbage Collection）是JavaScript引擎自动管理内存的机制，它会识别并释放那些不再被使用的对象和变量，从而防止内存泄漏，保证程序运行效率。</p>
<p>在JavaScript中，垃圾回收主要通过"标记-清除"算法工作，核心原则是：<strong>如果一个变量或对象不再有任何引用指向它，它就会被回收。</strong></p>
<h5 data-id="heading-31">闭包与垃圾回收的紧密关系</h5>
<p>闭包之所以能"记住"外部函数的变量，是因为内部函数持有了对外部作用域的引用。正常情况下，当外部函数执行完毕，它的局部变量本该被销毁、内存被回收。但因为闭包的存在——内部函数被外部引用并持续使用——这些变量就"被保留"了下来，垃圾回收器认为它们"仍然有用"，于是不会释放。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 闭包阻止垃圾回收的经典例子</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这个变量本该在函数结束后被回收</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        count++; <span class="hljs-comment">// 闭包引用了 count，阻止它被回收</span>
        <span class="hljs-keyword">return</span> count;
    };
}

<span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>(); <span class="hljs-comment">// counter 持有对 count 的引用</span>
<span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 1</span>
<span class="hljs-title function_">counter</span>(); <span class="hljs-comment">// 2</span>
<span class="hljs-comment">// 即使 createCounter() 已经执行完毕，count 依然存在，不会被垃圾回收</span>
</code></pre>
<p>这就是闭包的<strong>双刃剑</strong>：它让你能实现状态持久化、私有变量等强大功能，但也可能造成内存泄漏。</p>
<h5 data-id="heading-32">常见的内存泄漏场景及解决方案</h5>
<h6 data-id="heading-33">1. ❌ 危险：闭包持有大对象</h6>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 危险示例：闭包持有了整个 DOM 元素</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bindEventWithLeak</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'myButton'</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">'red'</span>; <span class="hljs-comment">// 闭包引用了 element，阻止其被回收</span>
    };
}

<span class="hljs-keyword">const</span> leakyHandler = <span class="hljs-title function_">bindEventWithLeak</span>();
<span class="hljs-comment">// 即使按钮被从DOM中移除，element对象仍被闭包持有，无法被回收</span>
</code></pre>
<p><strong>✅ 解决方案：只保存必要信息</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 安全做法：只保存轻量的ID</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bindEventSafely</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> elementId = <span class="hljs-string">'myButton'</span>; <span class="hljs-comment">// 只保留字符串，轻量</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(elementId); <span class="hljs-comment">// 按需获取</span>
        <span class="hljs-keyword">if</span> (element) {
            element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">'red'</span>;
        }
    };
}
</code></pre>
<h6 data-id="heading-34">2. ❌ 危险：闭包中的大型数据结构</h6>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createHeavyClosure</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> largeData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">'huge data'</span>); <span class="hljs-comment">// 大型数据</span>
    <span class="hljs-keyword">let</span> config = { <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>, <span class="hljs-attr">retries</span>: <span class="hljs-number">3</span> }; <span class="hljs-comment">// 配置信息</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTimeout</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 闭包引用了largeData，即使我们只需要config.timeout</span>
        <span class="hljs-keyword">return</span> config.<span class="hljs-property">timeout</span>;
    };
}

<span class="hljs-keyword">const</span> leakyFunction = <span class="hljs-title function_">createHeavyClosure</span>();
<span class="hljs-comment">// largeData会一直存在于内存中，即使我们只用到timeout</span>
</code></pre>
<p><strong>✅ 解决方案：分离数据和功能</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createOptimizedClosure</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> config = { <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>, <span class="hljs-attr">retries</span>: <span class="hljs-number">3</span> };
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTimeout</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> config.<span class="hljs-property">timeout</span>; <span class="hljs-comment">// 只引用需要的配置</span>
    };
    
    <span class="hljs-comment">// 或者更好的做法：提取需要的值</span>
    <span class="hljs-comment">// return function() {</span>
    <span class="hljs-comment">//     return 5000; // 直接返回值，不引用任何对象</span>
    <span class="hljs-comment">// };</span>
}
</code></pre>
<h6 data-id="heading-35">3. ❌ 危险：事件监听器的内存泄漏</h6>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupEventListeners</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.button'</span>);
    <span class="hljs-keyword">const</span> handlers = [];
    
    buttons.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">button, index</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> handler = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`按钮<span class="hljs-subst">${index}</span>被点击`</span>);
            <span class="hljs-comment">// 这个闭包持有buttons和handler数组的引用</span>
        };
        
        button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handler);
        handlers.<span class="hljs-title function_">push</span>(handler);
    });
    
    <span class="hljs-comment">// 问题：handlers数组会一直存在，阻止button元素被回收</span>
    <span class="hljs-keyword">return</span> handlers;
}

<span class="hljs-keyword">const</span> handlers = <span class="hljs-title function_">setupEventListeners</span>();
<span class="hljs-comment">// 即使按钮被移除，handlers仍然持有引用</span>
</code></pre>
<p><strong>✅ 解决方案：及时清理事件监听器</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupEventListeners</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.button'</span>);
    <span class="hljs-keyword">const</span> handlers = [];
    
    buttons.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">button, index</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> handler = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`按钮<span class="hljs-subst">${index}</span>被点击`</span>);
        };
        
        button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, handler);
        
        <span class="hljs-comment">// 返回清理函数</span>
        handlers.<span class="hljs-title function_">push</span>({
            <span class="hljs-attr">element</span>: button,
            <span class="hljs-attr">handler</span>: handler,
            <span class="hljs-attr">cleanup</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handler</span>);
            }
        });
    });
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanupAll</span>(<span class="hljs-params"/>) {
        handlers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h.<span class="hljs-title function_">cleanup</span>());
    };
}

<span class="hljs-keyword">const</span> cleanup = <span class="hljs-title function_">setupEventListeners</span>();
<span class="hljs-comment">// 在合适的时机调用cleanup，释放所有引用</span>
<span class="hljs-comment">// cleanup(); // 清理所有事件监听器</span>
</code></pre>
<h6 data-id="heading-36">4. ✅ 高级方案：使用弱引用（WeakMap/WeakSet）</h6>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用WeakMap避免强引用导致的内存泄漏</span>
<span class="hljs-keyword">const</span> objectCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">processObject</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">if</span> (!objectCache.<span class="hljs-title function_">has</span>(obj)) {
        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">expensiveCalculation</span>(obj);
        objectCache.<span class="hljs-title function_">set</span>(obj, result); <span class="hljs-comment">// 弱引用：obj被回收时，缓存自动清除</span>
    }
    <span class="hljs-keyword">return</span> objectCache.<span class="hljs-title function_">get</span>(obj);
}

<span class="hljs-comment">// 对比：使用普通Map会导致内存泄漏</span>
<span class="hljs-keyword">const</span> normalCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processObjectWithMemoryLeak</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">const</span> key = obj.<span class="hljs-property">id</span>;
    <span class="hljs-keyword">if</span> (!normalCache.<span class="hljs-title function_">has</span>(key)) {
        normalCache.<span class="hljs-title function_">set</span>(key, <span class="hljs-title function_">expensiveCalculation</span>(obj));
    }
    <span class="hljs-keyword">return</span> normalCache.<span class="hljs-title function_">get</span>(key);
    <span class="hljs-comment">// 问题：即使obj被回收，normalCache中的数据依然存在</span>
}
</code></pre>
<h5 data-id="heading-37">内存泄漏检测和预防</h5>
<h6 data-id="heading-38">1. 手动清理引用</h6>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createManagedClosure</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> largeData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">'data'</span>);
    
    <span class="hljs-keyword">const</span> closure = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'使用数据'</span>);
        <span class="hljs-keyword">return</span> largeData.<span class="hljs-property">length</span>;
    };
    
    <span class="hljs-comment">// 提供清理方法</span>
    closure.<span class="hljs-property">cleanup</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        largeData = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 手动释放大对象</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'大对象已清理'</span>);
    };
    
    <span class="hljs-keyword">return</span> closure;
}

<span class="hljs-keyword">const</span> managedClosure = <span class="hljs-title function_">createManagedClosure</span>();
<span class="hljs-comment">// 使用完毕后立即清理</span>
managedClosure.<span class="hljs-title function_">cleanup</span>();
</code></pre>
<h6 data-id="heading-39">2. 使用对象池模式</h6>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectPool</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">createFn, resetFn, maxSize = <span class="hljs-number">10</span></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">createFn</span> = createFn;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">resetFn</span> = resetFn;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxSize</span> = maxSize;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span> = [];
    }
    
    <span class="hljs-title function_">acquire</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span>.<span class="hljs-title function_">pop</span>();
        }
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createFn</span>();
    }
    
    <span class="hljs-title function_">release</span>(<span class="hljs-params">obj</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span>.<span class="hljs-property">length</span> &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxSize</span>) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resetFn</span>(obj);
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">pool</span>.<span class="hljs-title function_">push</span>(obj);
        }
    }
}

<span class="hljs-comment">// 使用对象池避免频繁创建和销毁大对象</span>
<span class="hljs-keyword">const</span> arrayPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectPool</span>(
    <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>),
    <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>,
    <span class="hljs-number">5</span>
);
</code></pre>
<h6 data-id="heading-40">3. 内存监控和调试</h6>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">monitorMemoryUsage</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 在浏览器中监控内存使用</span>
    <span class="hljs-keyword">if</span> (performance.<span class="hljs-property">memory</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内存使用情况:'</span>, {
            <span class="hljs-attr">used</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(performance.<span class="hljs-property">memory</span>.<span class="hljs-property">usedJSHeapSize</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">' MB'</span>,
            <span class="hljs-attr">total</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(performance.<span class="hljs-property">memory</span>.<span class="hljs-property">totalJSHeapSize</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">' MB'</span>,
            <span class="hljs-attr">limit</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(performance.<span class="hljs-property">memory</span>.<span class="hljs-property">jsHeapSizeLimit</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">' MB'</span>
        });
    }
    
    <span class="hljs-comment">// 创建内存快照进行对比</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createMemorySnapshot</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">if</span> (performance.<span class="hljs-property">memory</span>) {
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
                <span class="hljs-attr">used</span>: performance.<span class="hljs-property">memory</span>.<span class="hljs-property">usedJSHeapSize</span>
            };
        }
    };
}

<span class="hljs-keyword">const</span> createSnapshot = <span class="hljs-title function_">monitorMemoryUsage</span>();

<span class="hljs-comment">// 在关键操作前后对比内存使用</span>
<span class="hljs-keyword">const</span> before = <span class="hljs-title function_">createSnapshot</span>();
<span class="hljs-comment">// ... 执行一些操作 ...</span>
<span class="hljs-keyword">const</span> after = <span class="hljs-title function_">createSnapshot</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内存变化:'</span>, (after.<span class="hljs-property">used</span> - before.<span class="hljs-property">used</span>) / <span class="hljs-number">1024</span> + <span class="hljs-string">' KB'</span>);
</code></pre>
<h5 data-id="heading-41">最佳实践总结</h5>
<p>✅ <strong>只在必要时使用闭包保存数据</strong>
✅ <strong>用完即弃，及时置空引用</strong>
✅ <strong>优先使用WeakMap处理对象缓存</strong>
✅ <strong>组件销毁时清理事件监听器</strong>
✅ <strong>分离热数据和冷数据</strong>
✅ <strong>使用对象池减少GC压力</strong></p>
<p>记住：闭包的内存泄漏不是"闭包本身有问题"，而是开发者无意中延长了对象的生命周期。掌握这些技巧，你就能在享受闭包强大功能的同时，避免内存失控。</p>
<h4 data-id="heading-42">陷阱3：意外的变量共享</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 错误示例：多个函数共享同一个闭包变量</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createSharedState</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> sharedCounter = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">increment1</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) { sharedCounter++; <span class="hljs-keyword">return</span> sharedCounter; },
        <span class="hljs-attr">increment2</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) { sharedCounter++; <span class="hljs-keyword">return</span> sharedCounter; }
    };
}

<span class="hljs-keyword">const</span> shared = <span class="hljs-title function_">createSharedState</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(shared.<span class="hljs-title function_">increment1</span>()); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(shared.<span class="hljs-title function_">increment2</span>()); <span class="hljs-comment">// 2 - 两个函数相互影响</span>

<span class="hljs-comment">// ✅ 解决方案：创建独立的闭包</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createIndependentCounters</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 为每个计数器创建独立的闭包</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">counter1</span>: (<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) { count++; <span class="hljs-keyword">return</span> count; };
        })(),
        
        <span class="hljs-attr">counter2</span>: (<span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) { count++; <span class="hljs-keyword">return</span> count; };
        })()
    };
}

<span class="hljs-keyword">const</span> independent = <span class="hljs-title function_">createIndependentCounters</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(independent.<span class="hljs-title function_">counter1</span>()); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(independent.<span class="hljs-title function_">counter1</span>()); <span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(independent.<span class="hljs-title function_">counter2</span>()); <span class="hljs-comment">// 1 - 独立计数</span>
</code></pre>
<hr/>
<h3 data-id="heading-43">📈 性能优化建议</h3>
<h4 data-id="heading-44">1. 避免不必要的闭包创建</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 性能较差：每次调用都创建新闭包</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processArrayBad</span>(<span class="hljs-params">items</span>) {
    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) {
        <span class="hljs-comment">// 每次迭代都创建新的闭包</span>
        <span class="hljs-keyword">return</span> item * <span class="hljs-number">2</span>;
    });
}

<span class="hljs-comment">// ✅ 性能更好：使用箭头函数或预定义函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processArrayGood</span>(<span class="hljs-params">items</span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">double</span> = item =&gt; item * <span class="hljs-number">2</span>; <span class="hljs-comment">// 只定义一次</span>
    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">map</span>(double);
}

<span class="hljs-comment">// ✅ 或者使用Math方法</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">processArrayBest</span>(<span class="hljs-params">items</span>) {
    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item * <span class="hljs-number">2</span>);
}
</code></pre>
<h4 data-id="heading-45">2. 及时清理闭包引用</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createManagedClosure</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> resource = { <span class="hljs-attr">data</span>: <span class="hljs-string">'重要资源'</span> };
    
    <span class="hljs-keyword">const</span> closure = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> resource.<span class="hljs-property">data</span>;
    };
    
    <span class="hljs-comment">// 提供清理方法</span>
    closure.<span class="hljs-property">cleanup</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        resource = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 释放资源</span>
    };
    
    <span class="hljs-keyword">return</span> closure;
}

<span class="hljs-keyword">const</span> managedClosure = <span class="hljs-title function_">createManagedClosure</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">managedClosure</span>()); <span class="hljs-comment">// '重要资源'</span>
managedClosure.<span class="hljs-title function_">cleanup</span>(); <span class="hljs-comment">// 清理资源</span>
</code></pre>
<h4 data-id="heading-46">3. 内存友好的闭包设计模式</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 避免在闭包中保留大对象的引用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">badMemoryPattern</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> largeDataset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">'大数据'</span>);
    <span class="hljs-keyword">const</span> config = { <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>, <span class="hljs-attr">retries</span>: <span class="hljs-number">3</span> };
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 问题：只需要config，但闭包持有整个largeDataset</span>
        <span class="hljs-keyword">return</span> config.<span class="hljs-property">timeout</span>;
    };
}

<span class="hljs-comment">// ✅ 优化：提取需要的数据，避免不必要的引用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">goodMemoryPattern</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> config = { <span class="hljs-attr">timeout</span>: <span class="hljs-number">1000</span>, <span class="hljs-attr">retries</span>: <span class="hljs-number">3</span> };
    <span class="hljs-keyword">const</span> timeout = config.<span class="hljs-property">timeout</span>; <span class="hljs-comment">// 提取需要的值</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> timeout; <span class="hljs-comment">// 只使用原始值，不引用对象</span>
    };
}

<span class="hljs-comment">// ✅ 更好的做法：延迟绑定</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyBindingPattern</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 按需获取配置，避免长期持有</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getConfig</span>().<span class="hljs-property">timeout</span>;
    };
}
</code></pre>
<h4 data-id="heading-47">4. 使用WeakMap管理闭包数据</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 使用WeakMap避免内存泄漏</span>
<span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createWeakMapClass</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">value</span>) {
            <span class="hljs-comment">// 使用WeakMap存储私有数据</span>
            privateData.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, { <span class="hljs-attr">privateValue</span>: value });
        }
        
        <span class="hljs-title function_">getValue</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">return</span> privateData.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">privateValue</span>;
        }
        
        <span class="hljs-title function_">setValue</span>(<span class="hljs-params">value</span>) {
            privateData.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-property">privateValue</span> = value;
        }
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">MyClass</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">WeakMapClass</span> = <span class="hljs-title function_">createWeakMapClass</span>();
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMapClass</span>(<span class="hljs-string">'私有数据'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getValue</span>()); <span class="hljs-comment">// '私有数据'</span>
</code></pre>
<h4 data-id="heading-48">5. 垃圾回收友好的编程模式</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ❌ 问题：循环引用和长期持有</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">problematicPattern</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> largeObjects = [];
    <span class="hljs-keyword">const</span> eventHandlers = [];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
        <span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">id</span>: i, <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">`数据<span class="hljs-subst">${i}</span>`</span>) };
        <span class="hljs-keyword">const</span> handler = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">id</span>); <span class="hljs-comment">// 闭包持有obj的引用</span>
        };
        
        largeObjects.<span class="hljs-title function_">push</span>(obj);
        eventHandlers.<span class="hljs-title function_">push</span>(handler);
    }
    
    <span class="hljs-keyword">return</span> eventHandlers; <span class="hljs-comment">// 所有largeObjects都无法被垃圾回收</span>
}

<span class="hljs-comment">// ✅ 解决方案1：及时解除引用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">solution1</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> eventHandlers = [];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
        <span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">id</span>: i, <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">`数据<span class="hljs-subst">${i}</span>`</span>) };
        <span class="hljs-keyword">const</span> objId = obj.<span class="hljs-property">id</span>; <span class="hljs-comment">// 提取需要的数据</span>
        
        <span class="hljs-keyword">const</span> handler = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objId); <span class="hljs-comment">// 只引用基本类型，不引用对象</span>
        };
        
        eventHandlers.<span class="hljs-title function_">push</span>(handler);
        <span class="hljs-comment">// obj在这里就能被垃圾回收</span>
    }
    
    <span class="hljs-keyword">return</span> eventHandlers;
}

<span class="hljs-comment">// ✅ 解决方案2：使用弱引用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">solution2</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
    <span class="hljs-keyword">const</span> eventHandlers = [];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) {
        <span class="hljs-keyword">const</span> obj = { <span class="hljs-attr">id</span>: i, <span class="hljs-attr">data</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">`数据<span class="hljs-subst">${i}</span>`</span>) };
        <span class="hljs-keyword">const</span> handler = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">const</span> data = weakMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>);
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data ? data.<span class="hljs-property">id</span> : <span class="hljs-string">'对象已被回收'</span>);
        };
        
        weakMap.<span class="hljs-title function_">set</span>(handler, { obj });
        eventHandlers.<span class="hljs-title function_">push</span>(handler);
    }
    
    <span class="hljs-keyword">return</span> eventHandlers;
}

<span class="hljs-comment">// ✅ 解决方案3：对象池模式</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">solution3</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 对象池避免频繁创建和销毁</span>
    <span class="hljs-keyword">const</span> objectPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getProcessedData</span>(<span class="hljs-params">id</span>) {
        <span class="hljs-keyword">if</span> (!objectPool.<span class="hljs-title function_">has</span>(id)) {
            <span class="hljs-comment">// 按需创建，避免一次性创建大量对象</span>
            objectPool.<span class="hljs-title function_">set</span>(id, {
                id,
                <span class="hljs-attr">processed</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
            });
        }
        <span class="hljs-keyword">return</span> objectPool.<span class="hljs-title function_">get</span>(id);
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">id</span>) {
        <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">getProcessedData</span>(id);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'处理数据:'</span>, data.<span class="hljs-property">id</span>);
    };
}
</code></pre>
<h4 data-id="heading-49">6. 监控和检测内存泄漏</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 内存泄漏检测工具</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createMemoryLeakDetector</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> snapshots = [];
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">takeSnapshot</span>(<span class="hljs-params">label</span>) {
        <span class="hljs-keyword">if</span> (performance.<span class="hljs-property">memory</span>) {
            snapshots.<span class="hljs-title function_">push</span>({
                label,
                <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>(),
                <span class="hljs-attr">used</span>: performance.<span class="hljs-property">memory</span>.<span class="hljs-property">usedJSHeapSize</span>,
                <span class="hljs-attr">total</span>: performance.<span class="hljs-property">memory</span>.<span class="hljs-property">totalJSHeapSize</span>
            });
            
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`内存快照 <span class="hljs-subst">${label}</span>:`</span>, {
                <span class="hljs-attr">used</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(performance.<span class="hljs-property">memory</span>.<span class="hljs-property">usedJSHeapSize</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">' MB'</span>,
                <span class="hljs-attr">total</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(performance.<span class="hljs-property">memory</span>.<span class="hljs-property">totalJSHeapSize</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>) + <span class="hljs-string">' MB'</span>
            });
        }
    }
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">analyzeGrowth</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">if</span> (snapshots.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;
        
        <span class="hljs-keyword">const</span> first = snapshots[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">const</span> last = snapshots[snapshots.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">const</span> growth = last.<span class="hljs-property">used</span> - first.<span class="hljs-property">used</span>;
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'内存增长分析:'</span>, {
            时间跨度: <span class="hljs-string">`<span class="hljs-subst">${(last.timestamp - first.timestamp) / <span class="hljs-number">1000</span>}</span> 秒`</span>,
            内存增长: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.round(growth / <span class="hljs-number">1024</span>)}</span> KB`</span>,
            平均增长率: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">Math</span>.round(growth / (last.timestamp - first.timestamp))}</span> B/s`</span>
        });
        
        <span class="hljs-keyword">if</span> (growth &gt; <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) { <span class="hljs-comment">// 超过10MB增长</span>
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'⚠️ 检测到显著的内存增长，可能存在内存泄漏！'</span>);
        }
    }
    
    <span class="hljs-keyword">return</span> {
        takeSnapshot,
        analyzeGrowth,
        <span class="hljs-attr">clear</span>: <span class="hljs-function">() =&gt;</span> snapshots.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>
    };
}

<span class="hljs-comment">// 使用检测工具</span>
<span class="hljs-keyword">const</span> detector = <span class="hljs-title function_">createMemoryLeakDetector</span>();
detector.<span class="hljs-title function_">takeSnapshot</span>(<span class="hljs-string">'初始状态'</span>);

<span class="hljs-comment">// 执行可能泄漏的操作</span>
<span class="hljs-keyword">const</span> closures = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    closures.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createHeavyClosure</span>());
}

detector.<span class="hljs-title function_">takeSnapshot</span>(<span class="hljs-string">'创建闭包后'</span>);
detector.<span class="hljs-title function_">analyzeGrowth</span>();
</code></pre>
<hr/>
<h3 data-id="heading-50">🏗️ 综合实战项目</h3>
<h4 data-id="heading-51">项目：智能任务管理器</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 智能任务管理器 - 闭包综合应用示例
 * 功能：任务创建、状态管理、优先级排序、历史记录
 */</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createTaskManager</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 私有数据存储</span>
    <span class="hljs-keyword">let</span> tasks = [];
    <span class="hljs-keyword">let</span> taskIdCounter = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> history = [];
    <span class="hljs-keyword">let</span> filters = {
        <span class="hljs-attr">status</span>: <span class="hljs-string">'all'</span>, <span class="hljs-comment">// all, pending, completed</span>
        <span class="hljs-attr">priority</span>: <span class="hljs-string">'all'</span> <span class="hljs-comment">// all, high, medium, low</span>
    };
    
    <span class="hljs-comment">// 任务状态枚举</span>
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">STATUS</span> = {
        <span class="hljs-attr">PENDING</span>: <span class="hljs-string">'pending'</span>,
        <span class="hljs-attr">COMPLETED</span>: <span class="hljs-string">'completed'</span>
    };
    
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PRIORITY</span> = {
        <span class="hljs-attr">HIGH</span>: <span class="hljs-string">'high'</span>,
        <span class="hljs-attr">MEDIUM</span>: <span class="hljs-string">'medium'</span>,
        <span class="hljs-attr">LOW</span>: <span class="hljs-string">'low'</span>
    };
    
    <span class="hljs-comment">// 私有方法：添加历史记录</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">addHistory</span>(<span class="hljs-params">action, taskId, description</span>) {
        history.<span class="hljs-title function_">push</span>({
            <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),
            action,
            taskId,
            description
        });
    }
    
    <span class="hljs-comment">// 私有方法：生成唯一ID</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateId</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">`task_<span class="hljs-subst">${taskIdCounter++}</span>`</span>;
    }
    
    <span class="hljs-comment">// 私有方法：过滤任务</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">filterTasks</span>(<span class="hljs-params">taskList</span>) {
        <span class="hljs-keyword">return</span> taskList.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">task</span> =&gt;</span> {
            <span class="hljs-keyword">let</span> statusMatch = filters.<span class="hljs-property">status</span> === <span class="hljs-string">'all'</span> || task.<span class="hljs-property">status</span> === filters.<span class="hljs-property">status</span>;
            <span class="hljs-keyword">let</span> priorityMatch = filters.<span class="hljs-property">priority</span> === <span class="hljs-string">'all'</span> || task.<span class="hljs-property">priority</span> === filters.<span class="hljs-property">priority</span>;
            <span class="hljs-keyword">return</span> statusMatch &amp;&amp; priorityMatch;
        });
    }
    
    <span class="hljs-comment">// 私有方法：排序任务</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">sortTasks</span>(<span class="hljs-params">taskList</span>) {
        <span class="hljs-keyword">return</span> [...taskList].<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
            <span class="hljs-comment">// 按优先级排序：high &gt; medium &gt; low</span>
            <span class="hljs-keyword">const</span> priorityOrder = { [<span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">HIGH</span>]: <span class="hljs-number">3</span>, [<span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">MEDIUM</span>]: <span class="hljs-number">2</span>, [<span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">LOW</span>]: <span class="hljs-number">1</span> };
            <span class="hljs-keyword">if</span> (priorityOrder[a.<span class="hljs-property">priority</span>] !== priorityOrder[b.<span class="hljs-property">priority</span>]) {
                <span class="hljs-keyword">return</span> priorityOrder[b.<span class="hljs-property">priority</span>] - priorityOrder[a.<span class="hljs-property">priority</span>];
            }
            <span class="hljs-comment">// 相同优先级按创建时间排序</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(a.<span class="hljs-property">createdAt</span>) - <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(b.<span class="hljs-property">createdAt</span>);
        });
    }
    
    <span class="hljs-comment">// 公共API</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-comment">/**
         * 添加新任务
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">title</span> - 任务标题
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">description</span> - 任务描述
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">priority</span> - 任务优先级
         * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>} 任务ID
         */</span>
        <span class="hljs-attr">addTask</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">title, description = <span class="hljs-string">''</span>, priority = PRIORITY.MEDIUM</span>) {
            <span class="hljs-keyword">const</span> task = {
                <span class="hljs-attr">id</span>: <span class="hljs-title function_">generateId</span>(),
                title,
                description,
                priority,
                <span class="hljs-attr">status</span>: <span class="hljs-variable constant_">STATUS</span>.<span class="hljs-property">PENDING</span>,
                <span class="hljs-attr">createdAt</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),
                <span class="hljs-attr">completedAt</span>: <span class="hljs-literal">null</span>
            };
            
            tasks.<span class="hljs-title function_">push</span>(task);
            <span class="hljs-title function_">addHistory</span>(<span class="hljs-string">'created'</span>, task.<span class="hljs-property">id</span>, <span class="hljs-string">`创建任务: <span class="hljs-subst">${title}</span>`</span>);
            <span class="hljs-keyword">return</span> task.<span class="hljs-property">id</span>;
        },
        
        <span class="hljs-comment">/**
         * 完成任务
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">taskId</span> - 任务ID
         * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} 是否成功完成
         */</span>
        <span class="hljs-attr">completeTask</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">taskId</span>) {
            <span class="hljs-keyword">const</span> task = tasks.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">id</span> === taskId);
            <span class="hljs-keyword">if</span> (task &amp;&amp; task.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">STATUS</span>.<span class="hljs-property">PENDING</span>) {
                task.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">STATUS</span>.<span class="hljs-property">COMPLETED</span>;
                task.<span class="hljs-property">completedAt</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
                <span class="hljs-title function_">addHistory</span>(<span class="hljs-string">'completed'</span>, taskId, <span class="hljs-string">`完成任务: <span class="hljs-subst">${task.title}</span>`</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        },
        
        <span class="hljs-comment">/**
         * 删除任务
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">taskId</span> - 任务ID
         * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">boolean</span>} 是否成功删除
         */</span>
        <span class="hljs-attr">deleteTask</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">taskId</span>) {
            <span class="hljs-keyword">const</span> taskIndex = tasks.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">id</span> === taskId);
            <span class="hljs-keyword">if</span> (taskIndex !== -<span class="hljs-number">1</span>) {
                <span class="hljs-keyword">const</span> task = tasks[taskIndex];
                tasks.<span class="hljs-title function_">splice</span>(taskIndex, <span class="hljs-number">1</span>);
                <span class="hljs-title function_">addHistory</span>(<span class="hljs-string">'deleted'</span>, taskId, <span class="hljs-string">`删除任务: <span class="hljs-subst">${task.title}</span>`</span>);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        },
        
        <span class="hljs-comment">/**
         * 获取所有任务（带过滤和排序）
         * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Array</span>} 任务列表
         */</span>
        <span class="hljs-attr">getTasks</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">const</span> filtered = <span class="hljs-title function_">filterTasks</span>(tasks);
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">sortTasks</span>(filtered);
        },
        
        <span class="hljs-comment">/**
         * 获取任务统计信息
         * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Object</span>} 统计数据
         */</span>
        <span class="hljs-attr">getStats</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">const</span> total = tasks.<span class="hljs-property">length</span>;
            <span class="hljs-keyword">const</span> completed = tasks.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">STATUS</span>.<span class="hljs-property">COMPLETED</span>).<span class="hljs-property">length</span>;
            <span class="hljs-keyword">const</span> pending = total - completed;
            
            <span class="hljs-keyword">const</span> byPriority = {
                [<span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">HIGH</span>]: tasks.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">priority</span> === <span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">HIGH</span>).<span class="hljs-property">length</span>,
                [<span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">MEDIUM</span>]: tasks.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">priority</span> === <span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">MEDIUM</span>).<span class="hljs-property">length</span>,
                [<span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">LOW</span>]: tasks.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> t.<span class="hljs-property">priority</span> === <span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">LOW</span>).<span class="hljs-property">length</span>
            };
            
            <span class="hljs-keyword">return</span> {
                total,
                completed,
                pending,
                <span class="hljs-attr">completionRate</span>: total &gt; <span class="hljs-number">0</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>((completed / total) * <span class="hljs-number">100</span>) : <span class="hljs-number">0</span>,
                byPriority
            };
        },
        
        <span class="hljs-comment">/**
         * 设置过滤器
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">newFilters</span> - 过滤器配置
         */</span>
        <span class="hljs-attr">setFilter</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newFilters</span>) {
            filters = { ...filters, ...newFilters };
        },
        
        <span class="hljs-comment">/**
         * 获取操作历史
         * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">limit</span> - 返回记录数量限制
         * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Array</span>} 历史记录
         */</span>
        <span class="hljs-attr">getHistory</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">limit = <span class="hljs-number">50</span></span>) {
            <span class="hljs-keyword">return</span> history.<span class="hljs-title function_">slice</span>(-limit).<span class="hljs-title function_">reverse</span>();
        },
        
        <span class="hljs-comment">/**
         * 清空所有任务
         */</span>
        <span class="hljs-attr">clearAll</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">const</span> count = tasks.<span class="hljs-property">length</span>;
            tasks = [];
            <span class="hljs-title function_">addHistory</span>(<span class="hljs-string">'cleared_all'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">`清空了<span class="hljs-subst">${count}</span>个任务`</span>);
        },
        
        <span class="hljs-comment">/**
         * 导出任务数据
         * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Object</span>} 可序列化的数据
         */</span>
        <span class="hljs-attr">export</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            <span class="hljs-keyword">return</span> {
                tasks,
                history,
                <span class="hljs-attr">exportDate</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()
            };
        }
    };
}

<span class="hljs-comment">// 使用示例和测试</span>
<span class="hljs-keyword">const</span> taskManager = <span class="hljs-title function_">createTaskManager</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'=== 智能任务管理器演示 ===\n'</span>);

<span class="hljs-comment">// 添加任务</span>
<span class="hljs-keyword">const</span> task1 = taskManager.<span class="hljs-title function_">addTask</span>(<span class="hljs-string">'完成JavaScript闭包学习'</span>, <span class="hljs-string">'深入理解闭包的概念和应用'</span>, <span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">HIGH</span>);
<span class="hljs-keyword">const</span> task2 = taskManager.<span class="hljs-title function_">addTask</span>(<span class="hljs-string">'编写闭包示例代码'</span>, <span class="hljs-string">'创建实际的代码示例'</span>, <span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">MEDIUM</span>);
<span class="hljs-keyword">const</span> task3 = taskManager.<span class="hljs-title function_">addTask</span>(<span class="hljs-string">'整理笔记'</span>, <span class="hljs-string">'整理学习笔记到文档'</span>, <span class="hljs-variable constant_">PRIORITY</span>.<span class="hljs-property">LOW</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'📋 初始任务列表:'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(taskManager.<span class="hljs-title function_">getTasks</span>());

<span class="hljs-comment">// 完成任务</span>
taskManager.<span class="hljs-title function_">completeTask</span>(task1);
taskManager.<span class="hljs-title function_">completeTask</span>(task2);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n✅ 完成部分任务后的列表:'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(taskManager.<span class="hljs-title function_">getTasks</span>());

<span class="hljs-comment">// 查看统计信息</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n📊 任务统计:'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(taskManager.<span class="hljs-title function_">getStats</span>());

<span class="hljs-comment">// 设置过滤器查看未完成任务</span>
taskManager.<span class="hljs-title function_">setFilter</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">'pending'</span> });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n🔍 未完成任务:'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(taskManager.<span class="hljs-title function_">getTasks</span>());

<span class="hljs-comment">// 查看操作历史</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n📜 操作历史:'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(taskManager.<span class="hljs-title function_">getHistory</span>());

<span class="hljs-comment">// 高优先级过滤器</span>
taskManager.<span class="hljs-title function_">setFilter</span>({ <span class="hljs-attr">status</span>: <span class="hljs-string">'all'</span>, <span class="hljs-attr">priority</span>: <span class="hljs-string">'high'</span> });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'\n⭐ 高优先级任务:'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(taskManager.<span class="hljs-title function_">getTasks</span>());
</code></pre>
<h4 data-id="heading-52">实际应用中的最佳实践</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 实际项目中的闭包应用模式
 */</span>

<span class="hljs-comment">// 1. 配置管理器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createConfigManager</span>(<span class="hljs-params">defaultConfig</span>) {
    <span class="hljs-keyword">let</span> config = { ...defaultConfig };
    <span class="hljs-keyword">const</span> watchers = [];
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) {
            <span class="hljs-keyword">return</span> key ? config[key] : { ...config };
        },
        
        <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) {
            <span class="hljs-keyword">const</span> oldValue = config[key];
            config[key] = value;
            
            <span class="hljs-comment">// 通知所有观察者</span>
            watchers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">watcher</span> =&gt;</span> {
                <span class="hljs-title function_">watcher</span>(key, value, oldValue);
            });
        },
        
        <span class="hljs-attr">watch</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) {
            watchers.<span class="hljs-title function_">push</span>(callback);
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
                <span class="hljs-keyword">const</span> index = watchers.<span class="hljs-title function_">indexOf</span>(callback);
                <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) watchers.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
            };
        }
    };
}

<span class="hljs-comment">// 2. HTTP请求管理器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createHttpClient</span>(<span class="hljs-params">baseURL = <span class="hljs-string">''</span></span>) {
    <span class="hljs-keyword">const</span> pendingRequests = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">url, options = {}</span>) {
        <span class="hljs-keyword">const</span> requestId = <span class="hljs-string">`<span class="hljs-subst">${options.method || <span class="hljs-string">'GET'</span>}</span>-<span class="hljs-subst">${url}</span>`</span>;
        
        <span class="hljs-comment">// 检查是否有相同的请求正在进行</span>
        <span class="hljs-keyword">if</span> (pendingRequests.<span class="hljs-title function_">has</span>(requestId)) {
            <span class="hljs-keyword">return</span> pendingRequests.<span class="hljs-title function_">get</span>(requestId);
        }
        
        <span class="hljs-keyword">const</span> promise = <span class="hljs-title function_">fetch</span>(baseURL + url, options)
            .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.<span class="hljs-title function_">json</span>())
            .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> {
                pendingRequests.<span class="hljs-title function_">delete</span>(requestId);
            });
        
        pendingRequests.<span class="hljs-title function_">set</span>(requestId, promise);
        <span class="hljs-keyword">return</span> promise;
    }
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">url, options = {}</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(url, { ...options, <span class="hljs-attr">method</span>: <span class="hljs-string">'GET'</span> });
        },
        
        <span class="hljs-attr">post</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">url, data, options = {}</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(url, {
                ...options,
                <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
                <span class="hljs-attr">headers</span>: {
                    <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'application/json'</span>,
                    ...options.<span class="hljs-property">headers</span>
                },
                <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)
            });
        },
        
        <span class="hljs-attr">cancelAll</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
            pendingRequests.<span class="hljs-title function_">clear</span>();
        }
    };
}

<span class="hljs-comment">// 3. 事件发射器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createEventEmitter</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> events = {};
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">on</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, callback</span>) {
            <span class="hljs-keyword">if</span> (!events[eventName]) {
                events[eventName] = [];
            }
            events[eventName].<span class="hljs-title function_">push</span>(callback);
            
            <span class="hljs-comment">// 返回取消订阅函数</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
                <span class="hljs-keyword">const</span> callbacks = events[eventName];
                <span class="hljs-keyword">const</span> index = callbacks.<span class="hljs-title function_">indexOf</span>(callback);
                <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) {
                    callbacks.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
                }
            };
        },
        
        <span class="hljs-attr">emit</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, ...args</span>) {
            <span class="hljs-keyword">const</span> callbacks = events[eventName];
            <span class="hljs-keyword">if</span> (callbacks) {
                callbacks.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> {
                    callback.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args);
                });
            }
        },
        
        <span class="hljs-attr">off</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, callback</span>) {
            <span class="hljs-keyword">const</span> callbacks = events[eventName];
            <span class="hljs-keyword">if</span> (callbacks) {
                <span class="hljs-keyword">const</span> index = callbacks.<span class="hljs-title function_">indexOf</span>(callback);
                <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) {
                    callbacks.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
                }
            }
        }
    };
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> config = <span class="hljs-title function_">createConfigManager</span>({ <span class="hljs-attr">theme</span>: <span class="hljs-string">'light'</span>, <span class="hljs-attr">lang</span>: <span class="hljs-string">'zh-CN'</span> });

config.<span class="hljs-title function_">watch</span>(<span class="hljs-function">(<span class="hljs-params">key, newValue, oldValue</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`配置变化: <span class="hljs-subst">${key}</span> 从 <span class="hljs-subst">${oldValue}</span> 变为 <span class="hljs-subst">${newValue}</span>`</span>);
});

config.<span class="hljs-title function_">set</span>(<span class="hljs-string">'theme'</span>, <span class="hljs-string">'dark'</span>); <span class="hljs-comment">// 触发观察者</span>

<span class="hljs-keyword">const</span> http = <span class="hljs-title function_">createHttpClient</span>(<span class="hljs-string">'https://api.example.com'</span>);
http.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/users'</span>); <span class="hljs-comment">// 自动去重相同请求</span>

<span class="hljs-keyword">const</span> emitter = <span class="hljs-title function_">createEventEmitter</span>();
<span class="hljs-keyword">const</span> unsubscribe = emitter.<span class="hljs-title function_">on</span>(<span class="hljs-string">'message'</span>, <span class="hljs-function">(<span class="hljs-params">msg</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'收到消息:'</span>, msg);
});

emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">'message'</span>, <span class="hljs-string">'Hello, Closure!'</span>); <span class="hljs-comment">// 触发事件</span>
<span class="hljs-title function_">unsubscribe</span>(); <span class="hljs-comment">// 取消订阅</span>
</code></pre>
<hr/>
<h3 data-id="heading-53">🎯 总结</h3>
<p>闭包是JavaScript中最强大和最核心的特性之一，它为我们提供了：</p>
<ol>
<li><strong>数据封装</strong>：创建私有变量和方法</li>
<li><strong>状态保持</strong>：在函数调用之间保持状态</li>
<li><strong>函数工厂</strong>：创建具有特定配置的函数</li>
<li><strong>模块化</strong>：构建可重用的模块</li>
<li><strong>事件处理</strong>：管理事件处理器中的状态</li>
</ol>
<h4 data-id="heading-54">📋 闭包使用清单</h4>
<ul>
<li>✅ <strong>正确理解形成条件</strong>：
<ul>
<li><strong>必要条件</strong>：函数嵌套 + 内部函数引用外部变量</li>
<li><strong>应用条件</strong>：通过返回或传递使闭包在外部可被调用</li>
</ul>
</li>
<li>✅ <strong>澄清常见误解</strong>：返回不是形成闭包的必要条件，但是闭包产生实际价值的必要条件</li>
<li>✅ <strong>注意内存管理</strong>：及时清理不需要的闭包引用</li>
<li>✅ <strong>避免循环陷阱</strong>：使用let或IIFE解决循环中的闭包问题</li>
<li>✅ <strong>合理使用私有化</strong>：保护内部状态，提供公共接口</li>
<li>✅ <strong>性能优化</strong>：避免不必要的闭包创建，使用WeakMap管理引用</li>
<li>✅ <strong>理解闭包生命周期</strong>：创建、活跃、持久、销毁四个阶段</li>
</ul>
<p>闭包不仅仅是JavaScript的语言特性，更是一种编程思想，掌握它将让你的JavaScript代码更加优雅、安全和高效！</p>
<hr/>
<h3 data-id="heading-55">🌐 五、闭包在现代开发中的体现</h3>
<p>闭包不仅是一个理论概念，更是现代JavaScript技术栈的核心基础。通过深入源码，我们可以发现闭包在各种框架和工具中的精妙应用。</p>
<h4 data-id="heading-56">React Hooks 中的闭包艺术</h4>
<h5 data-id="heading-57">useEffect 依赖闭包捕获当前状态</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * React Hooks 源码简化的闭包机制
 * 展示 useEffect 如何通过闭包捕获状态
 */</span>

<span class="hljs-comment">// 简化的 React useState 实现</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useState</span>(<span class="hljs-params">initialValue</span>) {
    <span class="hljs-keyword">let</span> state = initialValue;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">setState</span> = (<span class="hljs-params">newState</span>) =&gt; {
        state = <span class="hljs-keyword">typeof</span> newState === <span class="hljs-string">'function'</span> ? <span class="hljs-title function_">newState</span>(state) : newState;
        <span class="hljs-title function_">rerender</span>(); <span class="hljs-comment">// 触发重新渲染</span>
    };
    <span class="hljs-keyword">return</span> [state, setState];
}

<span class="hljs-comment">// 简化的 useEffect 实现 - 核心在于闭包</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useEffect</span>(<span class="hljs-params">callback, dependencies</span>) {
    <span class="hljs-keyword">const</span> prevDeps = <span class="hljs-title function_">getCurrentDeps</span>(); <span class="hljs-comment">// 获取上次的依赖</span>
    <span class="hljs-keyword">const</span> hasChanged = dependencies ? 
        dependencies.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">dep, i</span>) =&gt;</span> dep !== prevDeps[i]) : 
        <span class="hljs-literal">true</span>;
    
    <span class="hljs-keyword">if</span> (hasChanged) {
        <span class="hljs-comment">// 🔑 关键：闭包捕获了创建时的所有变量</span>
        <span class="hljs-keyword">const</span> cleanup = <span class="hljs-title function_">callback</span>(); <span class="hljs-comment">// 执行副作用函数</span>
        <span class="hljs-title function_">saveCleanup</span>(cleanup);
        <span class="hljs-title function_">saveDeps</span>(dependencies);
    }
}

<span class="hljs-comment">// 实际应用中的闭包陷阱和解决方案</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
    
    <span class="hljs-comment">// ❌ 闭包陷阱：每次渲染都捕获了旧的 count</span>
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'错误的计数:'</span>, count); <span class="hljs-comment">// 总是 0，闭包捕获了初始值</span>
        }, <span class="hljs-number">1000</span>);
        
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
    }, [count]); <span class="hljs-comment">// 依赖数组</span>
    
    <span class="hljs-comment">// ✅ 解决方案1：使用函数式更新</span>
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-title function_">setCount</span>(<span class="hljs-function"><span class="hljs-params">currentCount</span> =&gt;</span> {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'正确的计数:'</span>, currentCount + <span class="hljs-number">1</span>);
                <span class="hljs-keyword">return</span> currentCount + <span class="hljs-number">1</span>;
            });
        }, <span class="hljs-number">1000</span>);
        
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
    }, []); <span class="hljs-comment">// 空依赖数组</span>
    
    <span class="hljs-comment">// ✅ 解决方案2：使用 useRef 闭包</span>
    <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(count);
    countRef.<span class="hljs-property">current</span> = count;
    
    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'使用 ref 的计数:'</span>, countRef.<span class="hljs-property">current</span>);
            <span class="hljs-title function_">setCount</span>(countRef.<span class="hljs-property">current</span> + <span class="hljs-number">1</span>);
        }, <span class="hljs-number">1000</span>);
        
        <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);
    }, []);
    
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre>
<h5 data-id="heading-58">useCallback 和 useMemo 的闭包优化</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * React 性能优化 Hooks 的闭包原理
 */</span>

<span class="hljs-comment">// 简化的 useCallback 实现</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useCallback</span>(<span class="hljs-params">callback, deps</span>) {
    <span class="hljs-keyword">const</span> callbackRef = <span class="hljs-title function_">useRef</span>(callback);
    <span class="hljs-keyword">const</span> depsRef = <span class="hljs-title function_">useRef</span>(deps);
    
    <span class="hljs-comment">// 通过闭包检查依赖是否变化</span>
    <span class="hljs-keyword">if</span> (!deps || deps.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">dep, i</span>) =&gt;</span> dep !== depsRef.<span class="hljs-property">current</span>[i])) {
        callbackRef.<span class="hljs-property">current</span> = callback;
        depsRef.<span class="hljs-property">current</span> = deps;
    }
    
    <span class="hljs-comment">// 返回稳定的函数引用，内部使用闭包</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">useRef</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {
        <span class="hljs-keyword">return</span> callbackRef.<span class="hljs-title function_">current</span>(...args);
    }).<span class="hljs-property">current</span>;
}

<span class="hljs-comment">// 实际应用</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">ParentComponent</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
    
    <span class="hljs-comment">// 通过闭包记忆函数，避免不必要的子组件重渲染</span>
    <span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'闭包捕获的 count:'</span>, count);
        <span class="hljs-comment">// 这个函数的闭包会捕获当前的 count 值</span>
    }, [count]); <span class="hljs-comment">// 依赖数组变化时，闭包重新创建</span>
    
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ExpensiveChild</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{memoizedCallback}</span> /&gt;</span></span>;
}
</code></pre>
<h4 data-id="heading-59">Vue 3 响应式系统中的闭包魔法</h4>
<h5 data-id="heading-60">reactive 和 computed 的依赖追踪</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * Vue 3 响应式系统简化的闭包机制
 * 展示如何通过闭包实现依赖追踪和响应式更新
 */</span>

<span class="hljs-comment">// 简化的依赖收集器</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">// 存储订阅者</span>
    }
    
    <span class="hljs-title function_">depend</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">if</span> (activeEffect) {
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">add</span>(activeEffect);
        }
    }
    
    <span class="hljs-title function_">notify</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subscribers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> <span class="hljs-title function_">effect</span>());
    }
}

<span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span>;

<span class="hljs-comment">// 简化的 reactive 实现</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">const</span> depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 存储每个属性的依赖</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, {
        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) {
            <span class="hljs-keyword">const</span> dep = depsMap.<span class="hljs-title function_">get</span>(key) || <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();
            dep.<span class="hljs-title function_">depend</span>(); <span class="hljs-comment">// 🔑 闭包收集依赖</span>
            
            <span class="hljs-keyword">return</span> target[key];
        },
        
        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) {
            target[key] = value;
            <span class="hljs-keyword">const</span> dep = depsMap.<span class="hljs-title function_">get</span>(key) || <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();
            dep.<span class="hljs-title function_">notify</span>(); <span class="hljs-comment">// 通知所有订阅者</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    });
}

<span class="hljs-comment">// 简化的 computed 实现</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">computed</span>(<span class="hljs-params">getter</span>) {
    <span class="hljs-keyword">let</span> value;
    <span class="hljs-keyword">let</span> dirty = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>();
    
    <span class="hljs-comment">// 🔑 关键闭包：保存 getter 函数和依赖</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">effect</span> = (<span class="hljs-params"/>) =&gt; {
        activeEffect = <span class="hljs-function">() =&gt;</span> {
            dirty = <span class="hljs-literal">true</span>;
            dep.<span class="hljs-title function_">notify</span>();
        };
        value = <span class="hljs-title function_">getter</span>(); <span class="hljs-comment">// 执行时自动收集依赖</span>
        activeEffect = <span class="hljs-literal">null</span>;
        dirty = <span class="hljs-literal">false</span>;
    };
    
    <span class="hljs-title function_">effect</span>(); <span class="hljs-comment">// 初始计算</span>
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {
            <span class="hljs-keyword">if</span> (dirty) {
                <span class="hljs-title function_">effect</span>();
            }
            dep.<span class="hljs-title function_">depend</span>();
            <span class="hljs-keyword">return</span> value;
        }
    };
}

<span class="hljs-comment">// 实际应用示例</span>
<span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Vue'</span>
});

<span class="hljs-keyword">const</span> doubledCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-comment">// 🔑 闭包：这个函数会被保存，当 state.count 变化时自动重新执行</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'重新计算 doubleCount'</span>);
    <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>;
});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubledCount.<span class="hljs-property">value</span>); <span class="hljs-comment">// 触发依赖收集</span>
state.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 自动触发重新计算</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubledCount.<span class="hljs-property">value</span>);
</code></pre>
<h5 data-id="heading-61">Vue 3 的 setup 函数闭包</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * Vue 3 Composition API 的闭包设计
 */</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">setup</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// setup 函数本身就是一个闭包环境</span>
        <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'Hello Vue 3'</span>);
        
        <span class="hljs-comment">// 闭包捕获了 count 和 message</span>
        <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"/>) =&gt; {
            count.<span class="hljs-property">value</span>++;
            <span class="hljs-comment">// 这个函数通过闭包访问到 setup 作用域中的变量</span>
        };
        
        <span class="hljs-comment">// 闭包中的计算属性</span>
        <span class="hljs-keyword">const</span> doubled = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-comment">// 🔑 闭包：自动追踪 count.value 的依赖</span>
            <span class="hljs-keyword">return</span> count.<span class="hljs-property">value</span> * <span class="hljs-number">2</span>;
        });
        
        <span class="hljs-comment">// 闭包中的副作用</span>
        <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'组件挂载，message:'</span>, message.<span class="hljs-property">value</span>);
            <span class="hljs-comment">// 闭包捕获了整个 setup 作用域</span>
        });
        
        <span class="hljs-comment">// 返回的所有方法和响应式数据都通过闭包保持关联</span>
        <span class="hljs-keyword">return</span> {
            count,
            message,
            doubled,
            increment
        };
    }
}
</code></pre>
<h4 data-id="heading-62">Node.js 模块系统中的闭包隔离</h4>
<h5 data-id="heading-63">CommonJS 模块的闭包封装</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * Node.js 模块系统 - 每个模块都是闭包
 * 展示模块如何通过闭包实现作用域隔离
 */</span>

<span class="hljs-comment">// 简化的 Node.js 模块加载器</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Module</span>(<span class="hljs-params">id, parent</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">exports</span> = {};
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span> = parent;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">filename</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">loaded</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = [];
}

<span class="hljs-comment">// 模块加载的核心 - 通过闭包隔离作用域</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">loadModule</span>(<span class="hljs-params">filename</span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Module</span>(filename);
    <span class="hljs-keyword">const</span> content = fs.<span class="hljs-title function_">readFileSync</span>(filename, <span class="hljs-string">'utf8'</span>);
    
    <span class="hljs-comment">// 🔑 关键：通过闭包包装模块代码</span>
    <span class="hljs-keyword">const</span> wrappedContent = <span class="hljs-string">`(function(exports, require, module, __filename, __dirname) {
        <span class="hljs-subst">${content}</span>
    })`</span>;
    
    <span class="hljs-keyword">const</span> compiledWrapper = vm.<span class="hljs-title function_">runInThisContext</span>(wrappedContent, filename);
    
    <span class="hljs-comment">// 执行模块代码，传入闭包参数</span>
    compiledWrapper.<span class="hljs-title function_">call</span>(
        <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>,
        <span class="hljs-variable language_">module</span>.<span class="hljs-property">require</span>,
        <span class="hljs-variable language_">module</span>,
        filename,
        path.<span class="hljs-title function_">dirname</span>(filename)
    );
    
    <span class="hljs-variable language_">module</span>.<span class="hljs-property">loaded</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;
}

<span class="hljs-comment">// 实际的模块文件示例</span>
<span class="hljs-comment">// math.js</span>
<span class="hljs-comment">/*
let privateCounter = 0; // 🔑 通过闭包成为模块私有变量

function increment() {
    privateCounter++;
}

module.exports = {
    increment,
    getCount: () =&gt; privateCounter
};
*/</span>

<span class="hljs-comment">// 在使用时</span>
<span class="hljs-keyword">const</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./math'</span>);
math.<span class="hljs-title function_">increment</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(math.<span class="hljs-title function_">getCount</span>()); <span class="hljs-comment">// privateCounter 通过闭包保持状态</span>

<span class="hljs-comment">// 不同模块的私有变量是隔离的</span>
<span class="hljs-keyword">const</span> anotherMath = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./math'</span>); <span class="hljs-comment">// 返回同一个模块实例</span>
<span class="hljs-comment">// privateCounter 在所有引用间共享，但与模块外完全隔离</span>
</code></pre>
<h5 data-id="heading-64">ES6 模块的闭包机制</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * ES6 模块的闭包实现
 * 展示模块级别的作用域和导出机制
 */</span>

<span class="hljs-comment">// utils.mjs - ES6 模块文件</span>
<span class="hljs-comment">// 整个文件在一个闭包中执行</span>
<span class="hljs-keyword">const</span> privateConfig = {
    <span class="hljs-attr">apiUrl</span>: <span class="hljs-string">'https://api.example.com'</span>,
    <span class="hljs-attr">timeout</span>: <span class="hljs-number">5000</span>
};

<span class="hljs-comment">// 通过闭包实现的私有函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">validateInput</span>(<span class="hljs-params">input</span>) {
    <span class="hljs-keyword">return</span> input != <span class="hljs-literal">null</span> &amp;&amp; input.<span class="hljs-title function_">trim</span>().<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// 导出的函数通过闭包访问私有变量</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createApiClient</span>(<span class="hljs-params">basePath</span>) {
    <span class="hljs-keyword">const</span> config = { ...privateConfig, basePath }; <span class="hljs-comment">// 🔑 闭包捕获配置</span>
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">request</span>: <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">endpoint, options</span>) {
            <span class="hljs-comment">// 通过闭包访问配置</span>
            <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${config.apiUrl}</span>/<span class="hljs-subst">${config.basePath}</span>/<span class="hljs-subst">${endpoint}</span>`</span>;
            <span class="hljs-keyword">const</span> timeout = config.<span class="hljs-property">timeout</span>;
            
            <span class="hljs-comment">// validateInput 函数通过闭包可用</span>
            <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">validateInput</span>(endpoint)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Invalid endpoint'</span>);
            }
            
            <span class="hljs-comment">// ... API 调用逻辑</span>
        },
        
        <span class="hljs-attr">updateConfig</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newConfig</span>) {
            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(config, newConfig);
        }
    };
}

<span class="hljs-comment">// 每次调用 createApiClient 都创建新的闭包实例</span>
<span class="hljs-keyword">const</span> apiClient1 = <span class="hljs-title function_">createApiClient</span>(<span class="hljs-string">'users'</span>);
<span class="hljs-keyword">const</span> apiClient2 = <span class="hljs-title function_">createApiClient</span>(<span class="hljs-string">'products'</span>);
<span class="hljs-comment">// 两个客户端有独立的配置闭包</span>
</code></pre>
<h4 data-id="heading-65">TypeScript 中的闭包类型安全</h4>
<h5 data-id="heading-66">类型推断与闭包结合</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">/**
 * TypeScript 中闭包的类型推断和安全
 */</span>

<span class="hljs-comment">// 泛型闭包工厂函数</span>
<span class="hljs-keyword">function</span> createTypedClosure&lt;T&gt;(<span class="hljs-attr">initialValue</span>: T) {
    <span class="hljs-comment">// 🔑 闭包捕获泛型类型</span>
    <span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: T = initialValue;
    
    <span class="hljs-keyword">return</span> {
        <span class="hljs-title function_">getValue</span>(): T {
            <span class="hljs-keyword">return</span> value; <span class="hljs-comment">// 类型推断保持 T 类型</span>
        },
        <span class="hljs-title function_">setValue</span>(<span class="hljs-attr">newValue</span>: T): <span class="hljs-built_in">void</span> {
            value = newValue;
        },
        <span class="hljs-comment">// 闭包中的函数也保持类型安全</span>
        <span class="hljs-title function_">update</span>(<span class="hljs-attr">updater</span>: <span class="hljs-function">(<span class="hljs-params">current: T</span>) =&gt;</span> T): <span class="hljs-built_in">void</span> {
            value = <span class="hljs-title function_">updater</span>(value);
        }
    };
}

<span class="hljs-comment">// 实际使用</span>
<span class="hljs-keyword">const</span> stringClosure = <span class="hljs-title function_">createTypedClosure</span>(<span class="hljs-string">'Hello TypeScript'</span>);
stringClosure.<span class="hljs-title function_">setValue</span>(<span class="hljs-string">'Updated'</span>); <span class="hljs-comment">// 类型检查通过</span>
<span class="hljs-comment">// stringClosure.setValue(123); // ❌ 类型错误</span>

<span class="hljs-keyword">const</span> numberClosure = <span class="hljs-title function_">createTypedClosure</span>(<span class="hljs-number">42</span>);
numberClosure.<span class="hljs-title function_">update</span>(<span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> n * <span class="hljs-number">2</span>); <span class="hljs-comment">// 闭包函数保持类型推断</span>

<span class="hljs-comment">// 复杂类型的闭包</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createUserManager</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">users</span>: <span class="hljs-title class_">User</span>[] = [];
    
    <span class="hljs-comment">// 🔑 闭包捕获类型信息</span>
    <span class="hljs-keyword">return</span> {
        <span class="hljs-title function_">addUser</span>(<span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span>): <span class="hljs-built_in">void</span> {
            users.<span class="hljs-title function_">push</span>(user);
        },
        
        <span class="hljs-title function_">findUser</span>(<span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">User</span> | <span class="hljs-literal">undefined</span> {
            <span class="hljs-keyword">return</span> users.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.<span class="hljs-property">id</span> === id);
        },
        
        <span class="hljs-comment">// 高阶闭包函数</span>
        <span class="hljs-title function_">filterUsers</span>(<span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">user: User</span>) =&gt;</span> <span class="hljs-built_in">boolean</span>): <span class="hljs-title class_">User</span>[] {
            <span class="hljs-keyword">return</span> users.<span class="hljs-title function_">filter</span>(predicate); <span class="hljs-comment">// 保持类型安全</span>
        }
    };
}

<span class="hljs-keyword">const</span> userManager = <span class="hljs-title function_">userManager</span>();
userManager.<span class="hljs-title function_">addUser</span>({ <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span> });
<span class="hljs-keyword">const</span> activeUsers = userManager.<span class="hljs-title function_">filterUsers</span>(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.<span class="hljs-property">name</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">3</span>);
</code></pre>
<h5 data-id="heading-67">闭包的装饰器应用</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">/**
 * TypeScript 装饰器中的闭包机制
 */</span>

<span class="hljs-keyword">function</span> memoize&lt;T <span class="hljs-keyword">extends</span> (...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]) =&gt; <span class="hljs-built_in">any</span>&gt;(
    <span class="hljs-attr">target</span>: <span class="hljs-built_in">any</span>,
    <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,
    <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">TypedPropertyDescriptor</span>&lt;T&gt;
): <span class="hljs-title class_">TypedPropertyDescriptor</span>&lt;T&gt; {
    <span class="hljs-keyword">const</span> originalMethod = descriptor.<span class="hljs-property">value</span>!;
    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">ReturnType</span>&lt;T&gt;&gt;(); <span class="hljs-comment">// 🔑 闭包缓存</span>
    
    <span class="hljs-comment">// 返回新方法，通过闭包保持缓存</span>
    descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">this</span>: <span class="hljs-built_in">any</span>, ...args: Parameters&lt;T&gt;</span>): <span class="hljs-title class_">ReturnType</span>&lt;T&gt; {
        <span class="hljs-keyword">const</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args);
        
        <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(key)) {
            <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(key)!;
        }
        
        <span class="hljs-keyword">const</span> result = originalMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
        cache.<span class="hljs-title function_">set</span>(key, result);
        <span class="hljs-keyword">return</span> result;
    } <span class="hljs-keyword">as</span> T;
    
    <span class="hljs-keyword">return</span> descriptor;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-meta">@memoize</span>
    <span class="hljs-title function_">fibonacci</span>(<span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">2</span>);
    }
}

<span class="hljs-comment">// 每个方法实例都有自己的闭包缓存</span>
<span class="hljs-keyword">const</span> calc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();
</code></pre>
<h4 data-id="heading-68">Webpack 模块打包的闭包原理</h4>
<h5 data-id="heading-69">IIFE + 闭包的模块封装</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * Webpack 打包后的模块代码结构
 * 展示如何通过 IIFE + 闭包实现模块系统
 */</span>

<span class="hljs-comment">// Webpack 打包后的简化结构</span>
(<span class="hljs-keyword">function</span>(<span class="hljs-params">modules</span>) {
    <span class="hljs-comment">// webpackBootstrap</span>
    
    <span class="hljs-comment">// 模块缓存</span>
    <span class="hljs-keyword">const</span> installedModules = {};
    
    <span class="hljs-comment">// 🔑 闭包：模块加载函数</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) {
        <span class="hljs-comment">// 检查缓存</span>
        <span class="hljs-keyword">if</span> (installedModules[moduleId]) {
            <span class="hljs-keyword">return</span> installedModules[moduleId].<span class="hljs-property">exports</span>;
        }
        
        <span class="hljs-comment">// 创建新模块实例</span>
        <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = installedModules[moduleId] = {
            <span class="hljs-attr">i</span>: moduleId,
            <span class="hljs-attr">l</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">exports</span>: {}
        };
        
        <span class="hljs-comment">// 🔑 关键：通过闭包执行模块</span>
        modules[moduleId].<span class="hljs-title function_">call</span>(
            <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>,
            <span class="hljs-variable language_">module</span>,
            <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>,
            __webpack_require__
        );
        
        <span class="hljs-variable language_">module</span>.<span class="hljs-property">l</span> = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;
    }
    
    <span class="hljs-comment">// 启动应用</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">__webpack_require__</span>(<span class="hljs-number">0</span>);
})({

<span class="hljs-comment">// 模块定义 - 每个模块都在闭包中</span>
<span class="hljs-number">0</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) {
    <span class="hljs-comment">// 模块 0 (入口文件)</span>
    <span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 通过闭包获取其他模块</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title class_">App</span> = <span class="hljs-built_in">require</span>(<span class="hljs-number">2</span>);
    
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>).<span class="hljs-title function_">appendChild</span>(<span class="hljs-title class_">App</span>.<span class="hljs-title function_">render</span>());
},

<span class="hljs-number">1</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) {
    <span class="hljs-comment">// 模块 1 (工具模块)</span>
    
    <span class="hljs-comment">// 🔑 闭包：模块私有变量</span>
    <span class="hljs-keyword">let</span> privateCounter = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">...args</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'[Utils]'</span>, ...args);
        privateCounter++;
    }
    
    <span class="hljs-comment">// 暴露的 API 通过闭包访问私有变量</span>
    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
        log,
        <span class="hljs-attr">getLogCount</span>: <span class="hljs-function">() =&gt;</span> privateCounter,
        <span class="hljs-attr">increment</span>: <span class="hljs-function">() =&gt;</span> privateCounter++
    };
},

<span class="hljs-number">2</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) {
    <span class="hljs-comment">// 模块 2 (组件模块)</span>
    <span class="hljs-keyword">const</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-number">1</span>);
    
    <span class="hljs-comment">// 🔑 闭包：组件状态</span>
    <span class="hljs-keyword">let</span> componentState = {
        <span class="hljs-attr">renderCount</span>: <span class="hljs-number">0</span>
    };
    
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
        componentState.<span class="hljs-property">renderCount</span>++;
        utils.<span class="hljs-title function_">log</span>(<span class="hljs-string">'渲染次数:'</span>, componentState.<span class="hljs-property">renderCount</span>);
        
        <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'div'</span>);
        div.<span class="hljs-property">textContent</span> = <span class="hljs-string">'Hello Webpack Module!'</span>;
        <span class="hljs-keyword">return</span> div;
    }
    
    <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = { render };
}

});
</code></pre>
<h5 data-id="heading-70">代码分割的闭包机制</h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * Webpack 代码分割中的动态导入闭包
 */</span>

<span class="hljs-comment">// 动态导入的实现原理</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">loadComponent</span>(<span class="hljs-params">componentName</span>) {
    <span class="hljs-comment">// 🔑 闭包：保存组件名和加载状态</span>
    <span class="hljs-keyword">let</span> loadingPromise = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">let</span> componentInstance = <span class="hljs-literal">null</span>;
    
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-comment">// 闭包捕获了 componentName</span>
        <span class="hljs-keyword">if</span> (componentInstance) {
            <span class="hljs-keyword">return</span> componentInstance;
        }
        
        <span class="hljs-keyword">if</span> (!loadingPromise) {
            loadingPromise = <span class="hljs-keyword">import</span>(<span class="hljs-string">`./components/<span class="hljs-subst">${componentName}</span>.js`</span>)
                .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">module</span> =&gt;</span> {
                    componentInstance = <span class="hljs-variable language_">module</span>.<span class="hljs-property">default</span>;
                    <span class="hljs-keyword">return</span> componentInstance;
                })
                .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`加载组件 <span class="hljs-subst">${componentName}</span> 失败:`</span>, error);
                    loadingPromise = <span class="hljs-literal">null</span>;
                    <span class="hljs-keyword">throw</span> error;
                });
        }
        
        <span class="hljs-keyword">return</span> loadingPromise;
    };
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> loadHeader = <span class="hljs-title function_">loadComponent</span>(<span class="hljs-string">'Header'</span>);
<span class="hljs-keyword">const</span> loadFooter = <span class="hljs-title function_">loadComponent</span>(<span class="hljs-string">'Footer'</span>);

<span class="hljs-comment">// 每个加载函数都有自己的闭包状态</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([
    <span class="hljs-title function_">loadHeader</span>(),
    <span class="hljs-title function_">loadFooter</span>()
]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">[Header, Footer]</span>) =&gt;</span> {
    <span class="hljs-comment">// 使用加载的组件</span>
});
</code></pre>
<h4 data-id="heading-71">🎯 现代开发中的闭包总结</h4>
<h5 data-id="heading-72">技术栈中的闭包体现</h5>



































<table><thead><tr><th>技术</th><th>闭包体现</th><th>核心作用</th></tr></thead><tbody><tr><td><strong>React Hooks</strong></td><td>useEffect、useState 内部依赖闭包捕获当前状态</td><td>状态持久化、副作用管理</td></tr><tr><td><strong>Vue 3 响应式</strong></td><td>reactive 和 computed 通过闭包追踪依赖</td><td>依赖收集、自动更新</td></tr><tr><td><strong>Node.js 模块</strong></td><td>每个模块都是一个闭包，隔离全局作用域</td><td>模块隔离、私有变量</td></tr><tr><td><strong>TypeScript</strong></td><td>闭包配合类型推断实现更安全的封装</td><td>类型安全、智能推断</td></tr><tr><td><strong>Webpack 打包</strong></td><td>模块封装本质是 IIFE + 闭包</td><td>模块系统、代码分割</td></tr></tbody></table>
<h5 data-id="heading-73">闭包在现代开发中的核心价值</h5>
<ol>
<li><strong>状态管理</strong>：React、Vue 中的状态持久化</li>
<li><strong>模块隔离</strong>：Node.js、Webpack 的作用域隔离</li>
<li><strong>依赖追踪</strong>：Vue 3 响应式系统的依赖收集</li>
<li><strong>性能优化</strong>：React 的记忆化函数缓存</li>
<li><strong>类型安全</strong>：TypeScript 的泛型闭包保持类型信息</li>
</ol>
<h3 data-id="heading-74">📖 推荐阅读</h3>
<ol>
<li>《JavaScript高级程序设计》 - 闭包章节</li>
<li>《你不知道的JavaScript》 - 作用域和闭包</li>
<li>MDN Web Docs - Closures</li>
<li>JavaScript Design Patterns - Module Pattern</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Elasticsearch：在分析过程中对数字进行标准化]]></title>    <link>https://juejin.cn/post/7584343534967717930</link>    <guid>https://juejin.cn/post/7584343534967717930</guid>    <pubDate>2025-12-17T02:05:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584343534967717930" data-draft-id="7584356212801126441" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Elasticsearch：在分析过程中对数字进行标准化"/> <meta itemprop="keywords" content="Elasticsearch"/> <meta itemprop="datePublished" content="2025-12-17T02:05:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Elasticsearch"/> <meta itemprop="url" content="https://juejin.cn/user/2612095360441448"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Elasticsearch：在分析过程中对数字进行标准化
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2612095360441448/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Elasticsearch
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:05:56.000Z" title="Wed Dec 17 2025 02:05:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作者：来自 Elastic <a href="https://link.juejin.cn?target=https%3A%2F%2Fdiscuss.elastic.co%2Fu%2Fspinscale" title="https://discuss.elastic.co/u/spinscale" target="_blank" ref="nofollow noopener noreferrer">spinscale</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6f0fc4e86670495d8d6f2bbcb749a223~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWxhc3RpY3NlYXJjaA==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766541956&amp;x-signature=QHLCFdkaciuaq70fsQuDuaN3Myo%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-0">分析链中的数字标准化</h2>
<p>在全文搜索中，一个常见问题是如何处理数字。最基本的方法是将它们完全提取出来，并在范围内作为真实数字进行查询，但在很多情况下，这需要大量分析，而且数字往往只是全文搜索的一部分，比如 iphone 17 或 bed 1.4 m。</p>
<p>问题是，当用户输入搜索时，他们对数字的理解可能与你不同。</p>
<p>1.4 m 和 1,4 m 是相同的吗？事实是，美国和欧洲在大数和分数的分隔符上使用不同的字符。除此之外，用户在搜索引擎中输入数字时，点和逗号常常可以互换使用，尤其是数字较小时。</p>
<ul>
<li>007 和 7 是相同的吗？取决于你的使用场景。</li>
<li>1.4 m 和 1.40 m 是相同的吗？这取决……你明白我的意思。</li>
</ul>
<p>那么我们能做些什么来稍微标准化数字呢？</p>
<p>为了这个示例，让我们使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fdocs%2Freference%2Ftext-analysis%2Fanalysis-keep-types-tokenfilter" title="https://www.elastic.co/docs/reference/text-analysis/analysis-keep-types-tokenfilter" target="_blank" ref="nofollow noopener noreferrer">keep_types token filter</a>，仅保留数字，丢弃分析链中的其他内容：</p>
<pre><code class="hljs language-bash" lang="bash">`

1.  POST _analyze
2.  {
3.    <span class="hljs-string">"text"</span>: <span class="hljs-string">"makita führungsschiene 1.4 m, 1,4 m 1,40 1.40"</span>,
4.    <span class="hljs-string">"tokenizer"</span>: <span class="hljs-string">"standard"</span>,
5.    <span class="hljs-string">"filter"</span>: [
6.      {
7.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"keep_types"</span>,
8.        <span class="hljs-string">"types"</span>: [
9.          <span class="hljs-string">"&lt;NUM&gt;"</span>
10.        ]
11.      }
12.    ]
13.  }

`AI写代码![](https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>这只会返回看起来像数字的 token，无论它们是否包含点或逗号，但会排除其他内容，例如普通单词，比如 makita。</p>
<p>接下来，我们先统一所有带点或逗号的数字。</p>
<pre><code class="hljs language-bash" lang="bash">`

1.  POST _analyze
2.  {
3.    <span class="hljs-string">"text"</span>: <span class="hljs-string">"makita führungsschiene 1.4 m, 1,4 m 1,40 1.40"</span>,
4.    <span class="hljs-string">"tokenizer"</span>: <span class="hljs-string">"standard"</span>,
5.    <span class="hljs-string">"filter"</span>: [
6.      {
7.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"keep_types"</span>,
8.        <span class="hljs-string">"types"</span>: [
9.          <span class="hljs-string">"&lt;NUM&gt;"</span>
10.        ]
11.      },
12.      {
13.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"pattern_replace"</span>,
14.        <span class="hljs-string">"pattern"</span>: <span class="hljs-string">"(\\d+)\\,(\\d+)"</span>,
15.        <span class="hljs-string">"replacement"</span> : <span class="hljs-string">"<span class="hljs-variable">$1</span>.<span class="hljs-variable">$2</span>"</span>
16.      }
17.    ]
18.  }

`AI写代码![](https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>这只返回 1.4 或 1.40 —— 很好！所以无论索引了什么，或者用户搜索什么，现在我们总是假设数字使用点，借助 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fdocs%2Freference%2Ftext-analysis%2Fanalysis-pattern_replace-tokenfilter" title="https://www.elastic.co/docs/reference/text-analysis/analysis-pattern_replace-tokenfilter" target="_blank" ref="nofollow noopener noreferrer">pattern_replace token filter</a> 实现。</p>
<p>如果不关心位置，可以在最后使用 unique token filter —— 当然也可以省略 norms 以减少索引大小。</p>
<p>你也可以去掉点，只保留数字本身，但这可能导致搜索 1.7 时返回 iphone 17 —— 同样，这取决于是否希望这样。</p>
<p>接下来，我们去掉前导零：</p>
<pre><code class="hljs language-bash" lang="bash">`

1.  POST _analyze
2.  {
3.    <span class="hljs-string">"text"</span>: <span class="hljs-string">"test 007 7 700 000 0"</span>,
4.    <span class="hljs-string">"tokenizer"</span>: <span class="hljs-string">"standard"</span>,
5.    <span class="hljs-string">"filter"</span>: [
6.      {
7.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"keep_types"</span>,
8.        <span class="hljs-string">"types"</span>: [
9.          <span class="hljs-string">"&lt;NUM&gt;"</span>
10.        ]
11.      },
12.      {
13.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"pattern_replace"</span>,
14.        <span class="hljs-string">"pattern"</span>: <span class="hljs-string">"^0+(\\d+)"</span>,
15.        <span class="hljs-string">"replacement"</span> : <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span>
16.      }
17.    ]
18.  }

`AI写代码![](https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>现在，007 或 000 会被简化为单个数字字符。虽然这可能有用，但请注意，当用户搜索 007 作为零件编号时，可能会返回包含 7 的所有结果，从而增加歧义。</p>
<p>接下来，真正有趣的部分来了：去掉尾随零，但不要弄得太复杂。像往常一样，如果你手头只有正则表达式，你可能会想出一个复杂的正则，但也许预处理可能已经是个好主意。</p>
<pre><code class="hljs language-bash" lang="bash">`

1.  POST _analyze
2.  {
3.    <span class="hljs-string">"text"</span>: <span class="hljs-string">"0.100 0.1000 0.101 100 100.0 100.00 100.001"</span>,
4.    <span class="hljs-string">"tokenizer"</span>: <span class="hljs-string">"standard"</span>,
5.    <span class="hljs-string">"filter"</span>: [
6.      {
7.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"keep_types"</span>,
8.        <span class="hljs-string">"types"</span>: [
9.          <span class="hljs-string">"&lt;NUM&gt;"</span>
10.        ]
11.      },
12.      {
13.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"pattern_replace"</span>,
14.        <span class="hljs-string">"pattern"</span>: <span class="hljs-string">"^(\\d+)\\.([0-9])(0+)$"</span>,
15.        <span class="hljs-string">"replacement"</span> : <span class="hljs-string">"<span class="hljs-variable">$1</span>.<span class="hljs-variable">$2</span>"</span>
16.      }
17.    ]
18.  }

`AI写代码![](https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>这会返回（至少如果你在请求中添加 filter_path=**.token）：</p>
<pre><code class="hljs language-markdown" lang="markdown">`

<span class="hljs-bullet">1.</span>  {
<span class="hljs-bullet">2.</span>    "tokens": [
<span class="hljs-bullet">3.</span>      {
<span class="hljs-bullet">4.</span>        "token": "0.1"
<span class="hljs-bullet">5.</span>      },
<span class="hljs-bullet">6.</span>      {
<span class="hljs-bullet">7.</span>        "token": "0.1"
<span class="hljs-bullet">8.</span>      },
<span class="hljs-bullet">9.</span>      {
<span class="hljs-bullet">10.</span>        "token": "0.101"
<span class="hljs-bullet">11.</span>      },
<span class="hljs-bullet">12.</span>      {
<span class="hljs-bullet">13.</span>        "token": "100"
<span class="hljs-bullet">14.</span>      },
<span class="hljs-bullet">15.</span>      {
<span class="hljs-bullet">16.</span>        "token": "100.0"
<span class="hljs-bullet">17.</span>      },
<span class="hljs-bullet">18.</span>      {
<span class="hljs-bullet">19.</span>        "token": "100.0"
<span class="hljs-bullet">20.</span>      },
<span class="hljs-bullet">21.</span>      {
<span class="hljs-bullet">22.</span>        "token": "100.001"
<span class="hljs-bullet">23.</span>      }
<span class="hljs-bullet">24.</span>    ]
<span class="hljs-bullet">25.</span>  }

`AI写代码![](<span class="hljs-link">https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png</span>)
</code></pre>
<p>你已经可以看到这里还有一些可以改进的地方。100 和 100.0 之间真的有区别吗？也许在这种情况下可以完全去掉尾随的 .0。我相信你会为此想出一个很棒的正则表达式。</p>
<p>让我们把所有步骤整合起来：</p>
<pre><code class="hljs language-bash" lang="bash">`

1.  POST _analyze
2.  {
3.    <span class="hljs-string">"text"</span>: <span class="hljs-string">"makita führungsschiene 1.4 m, 1,4 m 1,40 1.40 1.0 1.00 0.100 0.1000 0.101 0.1010 100 100.0 100.00 100.001 0.100 007 700"</span>,
4.    <span class="hljs-string">"tokenizer"</span>: <span class="hljs-string">"standard"</span>,
5.    <span class="hljs-string">"filter"</span>: [
6.      {
7.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"keep_types"</span>,
8.        <span class="hljs-string">"types"</span>: [
9.          <span class="hljs-string">"&lt;NUM&gt;"</span>
10.        ]
11.      },
12.      {
13.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"pattern_replace"</span>,
14.        <span class="hljs-string">"pattern"</span>: <span class="hljs-string">"(\\d+)\\,(\\d+)"</span>,
15.        <span class="hljs-string">"replacement"</span> : <span class="hljs-string">"<span class="hljs-variable">$1</span>.<span class="hljs-variable">$2</span>"</span>
16.      },
17.      {
18.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"pattern_replace"</span>,
19.        <span class="hljs-string">"pattern"</span>: <span class="hljs-string">"^0+(\\d+)"</span>,
20.        <span class="hljs-string">"replacement"</span> : <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span>
21.      },
22.      {
23.        <span class="hljs-string">"type"</span>: <span class="hljs-string">"pattern_replace"</span>,
24.        <span class="hljs-string">"pattern"</span>: <span class="hljs-string">"^(\\d+)\\.([0-9])(0+)$"</span>,
25.        <span class="hljs-string">"replacement"</span> : <span class="hljs-string">"<span class="hljs-variable">$1</span>.<span class="hljs-variable">$2</span>"</span>
26.      }
27.    ]
28.  }

`AI写代码![](https://csdnimg.cn/release/blogv2/dist/pc/img/runCode/icon-arrowwhite.png)
</code></pre>
<p>在真实的分析链中，你可能会去掉 keep_types filter，并且在适用时尝试将正则表达式组合以提高速度，但这大概是一个不错的起点。</p>
<p>仔细看上面的输出，你会注意到还有一个小问题：0.1010 没有被简化为 0.101。因此，你可能需要对正则表达式做进一步修正 —— 记住，如果增加一个 token filter 有助于可读性，也是可以的 😊</p>
<p>还有一个实现提示。如果你想确保 pattern replace filter 只针对数字运行，可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.elastic.co%2Fdocs%2Freference%2Ftext-analysis%2Fanalysis-condition-tokenfilter" title="https://www.elastic.co/docs/reference/text-analysis/analysis-condition-tokenfilter" target="_blank" ref="nofollow noopener noreferrer">condition token filter</a>。</p>
<p>原文：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdiscuss.elastic.co%2Ft%2Fdec-2nd-2025-en-normalizing-numbers-during-analysis%2F383512" title="https://discuss.elastic.co/t/dec-2nd-2025-en-normalizing-numbers-during-analysis/383512" target="_blank" ref="nofollow noopener noreferrer">discuss.elastic.co/t/dec-2nd-2…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[java实现生成PDF文件]]></title>    <link>https://juejin.cn/post/7584357116434284585</link>    <guid>https://juejin.cn/post/7584357116434284585</guid>    <pubDate>2025-12-17T02:17:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584357116434284585" data-draft-id="7584358227611090986" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="java实现生成PDF文件"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2025-12-17T02:17:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="小火锅啊"/> <meta itemprop="url" content="https://juejin.cn/user/3502396336782874"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            java实现生成PDF文件
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3502396336782874/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    小火锅啊
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:17:17.000Z" title="Wed Dec 17 2025 02:17:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">java实现生成PDF文件</h2>
<p>1.PDF文件简介
PDF是可移植文档格式，是一种电子文件格式，具有许多其他电子文档格式无法相比的优点。PDF文件格式可以将文字、字型、格式、颜色及独立于设备和分辨率的图形图像等封装在一个文件中。该格式文件还可以包含超文本链接、声音和动态影像等电子信息，支持特长文件，集成度和安全可靠性都较高。在系统开发中通常用来生成比较正式的报告或者合同类的电子文档。</p>
<p>2.生成PDF
2.1 基于freemarker框架实现HTML转PDF
2.1.1 引入jar包依赖:</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.itextpdf/html2pdf --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.itextpdf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>html2pdf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!-- spring boot 项目请添加此依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!-- 非spring boot 项目请添加此依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>2.1.2 创建html模板test_template：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-tag">body</span>{<span class="hljs-attribute">font-family</span>:SimSun;}
        <span class="hljs-selector-class">.title</span>{<span class="hljs-attribute">align-content</span>: center;<span class="hljs-attribute">text-align</span>: center;}
        <span class="hljs-selector-class">.signature</span>{<span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:right</span> }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>副标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>当前时间: ${date_time} <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"signature"</span>&gt;</span>日期：${date}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre>
<h6 data-id="heading-1">2.1.3 获取HTML内容</h6>
<ul>
<li>当HTML模板存放在系统文件夹</li>
</ul>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-type">String</span> templateDirectory = <span class="hljs-string">"D:\\"</span>;  <span class="hljs-comment">// 系统文件夹路径 如: D:\
</span>
</code></pre>
<ul>
<li>当HTML模板存放在项目resources/templates目录</li>
</ul>
<pre><code class="hljs language-ini" lang="ini">ClassLoader <span class="hljs-attr">classLoader</span> = PdfUtilTest.class.getClassLoader()<span class="hljs-comment">;</span>
URL <span class="hljs-attr">resource</span> = classLoader.getResource(<span class="hljs-string">"templates"</span>)<span class="hljs-comment">;</span>
String <span class="hljs-attr">templateDirectory</span> = resource.toURI().getPath()<span class="hljs-comment">;</span>

</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">import</span> com.itextpdf.html2pdf.ConverterProperties;
<span class="hljs-keyword">import</span> com.itextpdf.html2pdf.HtmlConverter;
<span class="hljs-keyword">import</span> com.itextpdf.layout.font.FontProvider;
<span class="hljs-keyword">import</span> freemarker.template.Configuration;
<span class="hljs-keyword">import</span> freemarker.template.Template;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;

<span class="hljs-keyword">import</span> java.io.*;
<span class="hljs-keyword">import</span> java.net.URL;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;
<span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;
<span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfUtilTest</span> {
    <span class="hljs-comment">/**
     * 获取模板内容
     * <span class="hljs-doctag">@param</span> templateDirectory 模板文件夹
     * <span class="hljs-doctag">@param</span> templateName      模板文件名
     * <span class="hljs-doctag">@param</span> paramMap          模板参数
     * <span class="hljs-doctag">@return</span>
     * <span class="hljs-doctag">@throws</span> Exception
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getTemplateContent</span><span class="hljs-params">(String templateDirectory, String templateName, Map&lt;String, Object&gt; paramMap)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);
        <span class="hljs-keyword">try</span> {
            configuration.setDirectoryForTemplateLoading(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(templateDirectory));
        } <span class="hljs-keyword">catch</span> (Exception e) {
            System.out.println(<span class="hljs-string">"-- exception --"</span>);
        }

        <span class="hljs-type">Writer</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();
        <span class="hljs-type">Template</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> configuration.getTemplate(templateName,<span class="hljs-string">"UTF-8"</span>);
        template.process(paramMap, out);
        out.flush();
        out.close();
        <span class="hljs-keyword">return</span> out.toString();
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception {
        Map&lt;String, Object&gt; paramMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">dateTimeFormatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>);
        paramMap.put(<span class="hljs-string">"date_time"</span>, dateTimeFormatter.format(LocalDateTime.now()));
        paramMap.put(<span class="hljs-string">"date"</span>, dateTimeFormatter.format(LocalDateTime.now()).substring(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>));
        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> PdfUtilTest.class.getClassLoader();
        <span class="hljs-type">URL</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> classLoader.getResource(<span class="hljs-string">"templates"</span>);
        <span class="hljs-type">String</span> <span class="hljs-variable">templateDirectory</span>  <span class="hljs-operator">=</span>resource.toURI().getPath();
        <span class="hljs-type">String</span> <span class="hljs-variable">templateContent</span> <span class="hljs-operator">=</span> PdfUtilTest.getTemplateContent(templateDirectory, <span class="hljs-string">"test_template.html"</span>, paramMap);
        System.out.println(templateContent);
    }
    
}

</code></pre>
<h6 data-id="heading-2">2.1.4 生成PDF文档</h6>
<p>示例代码:</p>
<pre><code class="hljs language-ini" lang="ini">    /**
     * HTML 转 PDF
     * @param content html内容
     * @param outPath           输出pdf路径
     * @return 是否创建成功
     */
    public static boolean html2Pdf(String content, String outPath) {
        try {
            ConverterProperties <span class="hljs-attr">converterProperties</span> = new ConverterProperties()<span class="hljs-comment">;</span>
            converterProperties.setCharset("UTF-8")<span class="hljs-comment">;</span>
            FontProvider <span class="hljs-attr">fontProvider</span> = new FontProvider()<span class="hljs-comment">;</span>
            fontProvider.addSystemFonts()<span class="hljs-comment">;</span>
            converterProperties.setFontProvider(fontProvider)<span class="hljs-comment">;</span>
            HtmlConverter.convertToPdf(content, new FileOutputStream(outPath), converterProperties)<span class="hljs-comment">;</span>
        } catch (Exception e) {
            log.error("生成模板内容失败,{}",e)<span class="hljs-comment">;</span>
            return false<span class="hljs-comment">;</span>
        }
        return true<span class="hljs-comment">;</span>
    }
    /**
     * HTML 转 PDF
     * @param content html内容
     * @return PDF字节数组
     */
    public static byte<span class="hljs-section">[]</span> html2Pdf(String content) {
        ByteArrayOutputStream <span class="hljs-attr">outputStream</span> = new ByteArrayOutputStream()<span class="hljs-comment">;;</span>
        try {
            ConverterProperties <span class="hljs-attr">converterProperties</span> = new ConverterProperties()<span class="hljs-comment">;</span>
            converterProperties.setCharset("UTF-8")<span class="hljs-comment">;</span>
            FontProvider <span class="hljs-attr">fontProvider</span> = new FontProvider()<span class="hljs-comment">;</span>
            fontProvider.addSystemFonts()<span class="hljs-comment">;</span>
            converterProperties.setFontProvider(fontProvider)<span class="hljs-comment">;</span>
            HtmlConverter.convertToPdf(content,outputStream,converterProperties)<span class="hljs-comment">;</span>
        } catch (Exception e) {
            log.error("生成 PDF 失败,{}",e)<span class="hljs-comment">;</span>
        }
        return outputStream.toByteArray()<span class="hljs-comment">;</span>
    }
	public static void main(String<span class="hljs-section">[]</span> args) throws Exception {
	    Map&lt;String, Object&gt; <span class="hljs-attr">paramMap</span> = new HashMap&lt;&gt;()<span class="hljs-comment">;</span>
	    DateTimeFormatter <span class="hljs-attr">dateTimeFormatter</span> = DateTimeFormatter.ofPattern(<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>)<span class="hljs-comment">;</span>
	    paramMap.put("date_time", dateTimeFormatter.format(LocalDateTime.now()))<span class="hljs-comment">;</span>
	    paramMap.put("date", dateTimeFormatter.format(LocalDateTime.now()).substring(0, 10))<span class="hljs-comment">;</span>
	    String <span class="hljs-attr">outPath</span> = <span class="hljs-string">"D:\\A.pdf"</span><span class="hljs-comment">;</span>
	    String <span class="hljs-attr">templateDirectory</span> = <span class="hljs-string">"D:\\"</span><span class="hljs-comment">;</span>
	    String <span class="hljs-attr">templateContent</span> = PdfUtilTest.getTemplateContent(templateDirectory, <span class="hljs-string">"test_template.html"</span>, paramMap)<span class="hljs-comment">;</span>
	    PdfUtilTest.html2Pdf(templateContent, outPath)<span class="hljs-comment">;</span>
	    
	}

</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[早点下班：在 Vue3 中少写 40%+ 的异步代码]]></title>    <link>https://juejin.cn/post/7584297353420455936</link>    <guid>https://juejin.cn/post/7584297353420455936</guid>    <pubDate>2025-12-17T02:17:19.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584297353420455936" data-draft-id="7584286241488961576" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="早点下班：在 Vue3 中少写 40%+ 的异步代码"/> <meta itemprop="keywords" content="Vue.js"/> <meta itemprop="datePublished" content="2025-12-17T02:17:19.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="阿懂在掘金"/> <meta itemprop="url" content="https://juejin.cn/user/4485616525391678"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            早点下班：在 Vue3 中少写 40%+ 的异步代码
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4485616525391678/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    阿懂在掘金
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:17:19.000Z" title="Wed Dec 17 2025 02:17:19 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>作为前端开发者，我们每天都在和异步操作打交道 —— 发起 API 请求、处理表单提交、管理数据加载状态... 但你有没有发现，写这些代码时总在重复同样的逻辑？</p>
<p>"定义 loading 变量、定义 error 变量、调用函数时设 loading 为 true、成功后更新数据、失败后记录错误、结束后设 loading 为 false、还要处理竞态条件..." 这些样板代码占用了大量时间，却几乎没有技术含量。</p>
<p>于是我开发了「vue-asyncx」—— 一个专注于简化 Vue3 异步操作的工具库，让你少写 40%+ 的重复代码，早点下班陪女朋友 / 打游戏 / 休息😎。</p>
<h2 data-id="heading-0">为什么需要 vue-asyncx？</h2>
<p>先看一个常见场景：用 Vue3 的 Composition API 获取用户信息。传统写法大概是这样的：</p>
<pre><code class="hljs language-ts" lang="ts">&lt;script setup&gt;
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> { getUserApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span>
<span class="hljs-comment">// 1. 定义一堆状态变量</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
<span class="hljs-keyword">const</span> loading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
<span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
<span class="hljs-comment">// 2. 编写异步函数</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">queryUser</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">userId</span>) =&gt; {
  <span class="hljs-comment">// 3. 手动处理状态更新</span>
  loading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>
  error.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>
  
  <span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 4. 执行异步操作</span>
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserApi</span>(userId)
    user.<span class="hljs-property">value</span> = res.<span class="hljs-property">data</span>
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-comment">// 5. 处理错误</span>
    error.<span class="hljs-property">value</span> = e
    <span class="hljs-keyword">throw</span> e
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 6. 清理状态</span>
    loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
  }
}
&lt;/script&gt;
</code></pre>
<p>这段代码里，真正有价值的逻辑只有getUserApi(userId)这一行，其余全是重复的状态管理代码。更麻烦的是：</p>
<ul>
<li>每个异步操作都要复制这套逻辑，代码量爆炸</li>
<li>变量命名风格不统一，团队协作成本高</li>
<li>手动处理竞态条件（多次请求时数据覆盖问题）容易出错</li>
</ul>
<p>而用 vue-asyncx 实现同样的功能，只需要：</p>
<pre><code class="hljs language-ts" lang="ts">&lt;script setup&gt;
<span class="hljs-keyword">import</span> { useAsyncData } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-asyncx'</span>
<span class="hljs-keyword">import</span> { getUserApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span>
<span class="hljs-comment">// 一行代码搞定所有状态管理</span>
<span class="hljs-keyword">const</span> { user, queryUser, queryUserLoading, queryUserError } = <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'user'</span>, getUserApi)
&lt;/script&gt;
</code></pre>
<p>这就是 vue-asyncx 的核心价值：<strong>自动处理异步操作的所有周边逻辑，用命名约定提升协作效率</strong>。</p>
<blockquote>
<p>自定义变量也有类型提示</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9c43ae171aeb4ae5bafc515a21596aaa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zi_5oeC5Zyo5o6Y6YeR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542639&amp;x-signature=C0RPOP5QJ%2FTDa047N0hOisSVoAs%3D" alt="image.png" loading="lazy"/></p>
</blockquote>
<h2 data-id="heading-1">核心功能：让异步操作 "开箱即用"自动处理异步操作的所有周边逻辑，</h2>
<p>vue-asyncx 提供了两个核心 API，覆盖 90%+ 的异步场景：</p>
<h3 data-id="heading-2">1. useAsyncData：专注异步数据</h3>
<p>当你需要使用异步数据时，用useAsyncData。它会自动生成：</p>
<ul>
<li>{name}：存储异步数据 Ref（如user）</li>
<li>query{Name}：触发异步数据获取的函数（如queryUser）</li>
<li>query{Name}Loading：加载状态 Ref（如queryUserLoading）</li>
<li>query{Name}Error：错误信息 Ref（如queryUserError）</li>
<li>query{Name}Arguments：最近一次调用过程中的传参</li>
<li>{name}Expired：当前异步数据是否过期（因后续请求失败导致）</li>
</ul>
<p><strong>基础用法</strong>：</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { useAsyncData } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-asyncx'</span>
<span class="hljs-keyword">import</span> { getArticleApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span>
<span class="hljs-comment">// 管理文章数据</span>
<span class="hljs-keyword">const</span> { 
  article,         <span class="hljs-comment">// 文章数据 (Ref)</span>
  queryArticle,    <span class="hljs-comment">// 获取文章的函数</span>
  queryArticleLoading, <span class="hljs-comment">// 加载状态</span>
  queryArticleError    <span class="hljs-comment">// 错误信息</span>
} = <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'article'</span>, getArticleApi)
<span class="hljs-comment">// 调用函数获取数据</span>
<span class="hljs-title function_">queryArticle</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// 获取id=123的文章</span>
</code></pre>
<p><strong>其它特性</strong>：</p>
<ul>
<li>初始值设置：useAsyncData('user', getUserApi, { initialData: { name: '默认' } })</li>
<li>自动监听：当依赖变化时自动执行（类似 watch）</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> userId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)
<span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'user'</span>, getUserApi, { 
  <span class="hljs-attr">watch</span>: userId, <span class="hljs-comment">// userId变化时自动调用queryUser(userId.value)</span>
  <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 初始时立即执行</span>
})
</code></pre>
<ul>
<li>过程中更新数据：支持在异步函数执行过程中手动更新结果</li>
</ul>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">const</span> { progress, queryProgress } = <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'progress'</span>, <span class="hljs-keyword">async</span> (init = <span class="hljs-number">0</span>) =&gt; {
  <span class="hljs-keyword">const</span> { updateData } = <span class="hljs-title function_">getAsyncDataContext</span>() <span class="hljs-comment">// 获取上下文</span>
  <span class="hljs-title function_">updateData</span>(init) <span class="hljs-comment">// 立即更新为初始值</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">wait</span>(<span class="hljs-number">100</span>)
  <span class="hljs-title function_">updateData</span>(<span class="hljs-number">50</span>) <span class="hljs-comment">// 中途更新为50%</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">wait</span>(<span class="hljs-number">100</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">100</span> <span class="hljs-comment">// 最终结果</span>
})
</code></pre>
<h3 data-id="heading-3">2. useAsync：专注异步函数</h3>
<p>当你只需要使用异步函数（不需要长久保持结果），比如表单提交、数据删除等操作场景，用useAsync。它会生成：</p>
<ul>
<li>{name}：包装后的异步函数（如submit）</li>
<li>{name}Loading：加载状态 Ref（如submitLoading）</li>
<li>{name}Error：错误信息 Ref（如submitError）</li>
<li>{name}Arguments：最近一次调用过程中的传参</li>
</ul>
<p><strong>表单提交示例</strong>：</p>
<pre><code class="hljs language-ts" lang="ts">&lt;script setup&gt;
<span class="hljs-keyword">import</span> { useAsync } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-asyncx'</span>
<span class="hljs-keyword">import</span> { submitFormApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span>
<span class="hljs-comment">// 管理提交操作</span>
<span class="hljs-keyword">const</span> { 
  submit,       <span class="hljs-comment">// 提交函数</span>
  submitLoading, <span class="hljs-comment">// 提交状态</span>
  submitError    <span class="hljs-comment">// 提交错误</span>
} = <span class="hljs-title function_">useAsync</span>(<span class="hljs-string">'submit'</span>, submitFormApi)
&lt;/script&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">"submit(formData)"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">"submitLoading"</span>&gt;</span>
      {{ submitLoading ? '提交中...' : '提交' }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"submitError"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"error"</span>&gt;</span>
      {{ submitError.message }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-4">3. 自动处理竞态条件</h3>
<p>当一个异步函数被快速连续调用（比如用户快速点击按钮），可能出现 "后发请求先返回，先发请求后覆盖" 的竞态问题，导致数据混乱。</p>
<p>vue-asyncx 内置了竞态处理机制，通过调用追踪，确保<strong>只有最后一次调用的结果会更新状态</strong>，前面的请求结果会被自动忽略。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 模拟一个延迟返回的API</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params">id</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> 
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(id), <span class="hljs-number">1000</span>)
)
<span class="hljs-keyword">const</span> { data, queryData } = <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'data'</span>, fetchData)
<span class="hljs-comment">// 快速连续调用</span>
<span class="hljs-title function_">queryData</span>(<span class="hljs-number">1</span>)
<span class="hljs-title function_">queryData</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 最后一次调用，结果会是2</span>
<span class="hljs-comment">// 1秒后，data.value 会是2（而不是1），自动忽略了第一次调用的结果</span>
</code></pre>
<h2 data-id="heading-5">实战场景：代码量对比</h2>
<p>我们用 "用户列表 + 详情" 的经典场景，看看 vue-asyncx 能省多少代码。</p>
<h3 data-id="heading-6">传统实现（约 50 行）</h3>
<pre><code class="hljs language-ts" lang="ts">&lt;script setup&gt;
<span class="hljs-keyword">import</span> { ref, watch } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> { getUsersApi, getUserDetailApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span>
<span class="hljs-comment">// 列表相关状态</span>
<span class="hljs-keyword">const</span> users = <span class="hljs-title function_">ref</span>([])
<span class="hljs-keyword">const</span> getUsersLoading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
<span class="hljs-keyword">const</span> getUsersError = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
<span class="hljs-comment">// 详情相关状态</span>
<span class="hljs-keyword">const</span> userDetail = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
<span class="hljs-keyword">const</span> getUserDetailLoading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
<span class="hljs-keyword">const</span> getUserDetailError = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
<span class="hljs-keyword">const</span> currentUserId = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
<span class="hljs-comment">// 获取列表</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getUsers</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
  getUsersLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>
  getUsersError.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUsersApi</span>()
    users.<span class="hljs-property">value</span> = res.<span class="hljs-property">data</span>
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>
  } <span class="hljs-keyword">catch</span> (e) {
    getUsersError.<span class="hljs-property">value</span> = e
    <span class="hljs-keyword">throw</span> e
  } <span class="hljs-keyword">finally</span> {
    getUsersLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
  }
}
<span class="hljs-comment">// 获取详情</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getUserDetail</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">userId</span>) =&gt; {
  getUserDetailLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>
  getUserDetailError.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUserDetailApi</span>(userId)
    userDetail.<span class="hljs-property">value</span> = res.<span class="hljs-property">data</span>
    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span>
  } <span class="hljs-keyword">catch</span> (e) {
    getUserDetailError.<span class="hljs-property">value</span> = e
    <span class="hljs-keyword">throw</span> e
  } <span class="hljs-keyword">finally</span> {
    getUserDetailLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
  }
}
<span class="hljs-comment">// 监听用户ID变化，自动加载详情</span>
<span class="hljs-title function_">watch</span>(currentUserId, <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (id) <span class="hljs-title function_">getUserDetail</span>(id)
})
<span class="hljs-comment">// 初始加载列表</span>
<span class="hljs-title function_">getUsers</span>()
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-7">vue-asyncx 实现（约 20 行）</h3>
<pre><code class="hljs language-ts" lang="ts">&lt;script setup&gt;
<span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> { useAsyncData } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-asyncx'</span>
<span class="hljs-keyword">import</span> { getUsersApi, getUserDetailApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'./api'</span>
<span class="hljs-comment">// 列表管理（自动生成getUsers、users等）</span>
<span class="hljs-keyword">const</span> { 
  users, 
  getUsers, 
  getUsersLoading, 
  getUsersError 
} = <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'users'</span>, getUsersApi, { <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span> })
<span class="hljs-comment">// 详情管理（自动监听currentUserId变化）</span>
<span class="hljs-keyword">const</span> currentUserId = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
<span class="hljs-keyword">const</span> { 
  userDetail, 
  getUserDetail, 
  getUserDetailLoading, 
  getUserDetailError 
} = <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'userDetail'</span>, getUserDetailApi, { 
  <span class="hljs-attr">watch</span>: currentUserId, <span class="hljs-comment">// 自动监听</span>
})
&lt;/script&gt;
</code></pre>
<p><strong>代码量减少60%</strong> ，而且逻辑更清晰 —— 所有状态都和对应的异步操作强关联，不用在多个 ref 之间跳来跳去。</p>
<h2 data-id="heading-8">为什么选择 vue-asyncx？</h2>
<ol>
<li><strong>更少的代码</strong>：平均减少 40%+ 的异步相关代码，专注业务逻辑</li>
<li><strong>更强的可读性</strong>：统一的命名约定（如queryXxx、xxxLoading）让代码自文档化</li>
<li><strong>零成本维护</strong>：自动处理状态更新、竞态条件，减少 bug</li>
<li><strong>完整的 TypeScript 支持</strong>：所有 API 都有精确的类型定义，IDE 自动提示</li>
<li><strong>轻量无依赖</strong>：仅依赖 Vue3，体积极小（gzip 后 ~2KB）</li>
<li><strong>100% 测试覆盖</strong>：200+ 测试用例确保稳定性</li>
</ol>
<h2 data-id="heading-9">如何开始使用？</h2>
<ol>
<li>安装依赖：</li>
</ol>
<pre><code class="hljs language-sh" lang="sh">pnpm i vue-asyncx
<span class="hljs-comment"># 或 npm i vue-asyncx</span>
<span class="hljs-comment"># 或 yarn add vue-asyncx</span>
</code></pre>
<ol start="2">
<li>在组件中使用：</li>
</ol>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-keyword">import</span> { useAsync, useAsyncData } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-asyncx'</span>
</code></pre>
<p>详细文档和更多示例见：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxuyimingwork%2Fvue-asyncx" target="_blank" title="https://github.com/xuyimingwork/vue-asyncx" ref="nofollow noopener noreferrer">GitHub 仓库</a></p>
<h2 data-id="heading-10">社区贡献：一起让它更好</h2>
<p>vue-asyncx 还在不断进化，如果你有任何想法或需求，欢迎参与贡献：</p>
<ul>
<li>提 Issue：报告 bug 或建议新功能</li>
<li>发 PR：修复 bug 或实现新功能（欢迎新手参与）</li>
<li>分享体验：在博客或社交平台分享你的使用心得</li>
</ul>
<p>项目地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxuyimingwork%2Fvue-asyncx" target="_blank" title="https://github.com/xuyimingwork/vue-asyncx" ref="nofollow noopener noreferrer">github.com/xuyimingwor…</a></p>
<h2 data-id="heading-11">最后</h2>
<p>开发 vue-asyncx 的初衷，就是想让自己和更多开发者从重复的异步状态管理中解放出来 —— 毕竟，好的工具应该让你感觉不到它的存在，却能悄悄帮你搞定琐事。</p>
<p>希望 vue-asyncx 能让你少加班、多陪家人、多打游戏，早点下班😊。</p>
<p>如果觉得有用，欢迎给个 Star 支持一下～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[解锁 JavaScript 对象的“魔法宝箱”：这些方法让你玩转对象操作]]></title>    <link>https://juejin.cn/post/7584365584746414107</link>    <guid>https://juejin.cn/post/7584365584746414107</guid>    <pubDate>2025-12-17T01:58:40.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584365584746414107" data-draft-id="7584362317002227739" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="解锁 JavaScript 对象的“魔法宝箱”：这些方法让你玩转对象操作"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-12-17T01:58:40.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JS_Likers"/> <meta itemprop="url" content="https://juejin.cn/user/1377017277975032"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            解锁 JavaScript 对象的“魔法宝箱”：这些方法让你玩转对象操作
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1377017277975032/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JS_Likers
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T01:58:40.000Z" title="Wed Dec 17 2025 01:58:40 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>欢迎使用我的小程序👇👇👇👇</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0d25c4001b1b4e6e902dc1f8863bcef2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSlNfTGlrZXJz:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766541520&amp;x-signature=%2FPSEqqaddsUeoTsjmdujgTcPrdQ%3D" alt="small.png" loading="lazy"/></p>
<hr/>
<p>大家好！今天我要带大家探索 JavaScript 中那些让对象操作变得轻松有趣的方法。如果你曾经觉得 JavaScript 对象像个神秘的黑盒子，那么准备好，我要给你一把万能钥匙！</p>
<h2 data-id="heading-0">对象：你的“数字储物柜”</h2>
<p>想象一下，JavaScript 对象就像一个智能储物柜，每个隔间都有自己独特的标签（键）和存放的东西（值）：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> myLocker = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"小明"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,
  <span class="hljs-attr">hobbies</span>: [<span class="hljs-string">"编程"</span>, <span class="hljs-string">"游戏"</span>, <span class="hljs-string">"爬山"</span>],
  <span class="hljs-attr">isStudent</span>: <span class="hljs-literal">false</span>
};
</code></pre>
<h2 data-id="heading-1">🔑 基础钥匙：Object.keys()</h2>
<p>想要知道储物柜里有哪些隔间？用<code>Object.keys()</code>就能一目了然！</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> lockerContents = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(myLocker);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lockerContents); 
<span class="hljs-comment">// 输出：["name", "age", "hobbies", "isStudent"]</span>
</code></pre>
<p><strong>实际应用场景</strong>：检查用户表单是否填写完整</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> userForm = { <span class="hljs-attr">username</span>: <span class="hljs-string">"coder123"</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">""</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> };
<span class="hljs-keyword">const</span> emptyFields = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(userForm).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> !userForm[key]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"请填写："</span>, emptyFields); <span class="hljs-comment">// 输出：["email"]</span>
</code></pre>
<h2 data-id="heading-2">💎 宝藏清单：Object.values()</h2>
<p>只关心储物柜里有什么宝贝，不关心标签？<code>Object.values()</code>来帮你！</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> lockerTreasures = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(myLocker);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lockerTreasures);
<span class="hljs-comment">// 输出：["小明", 25, ["编程", "游戏", "爬山"], false]</span>
</code></pre>
<p><strong>有趣用法</strong>：快速计算购物车总价</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> cart = { <span class="hljs-attr">apple</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">banana</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">orange</span>: <span class="hljs-number">8</span> };
<span class="hljs-keyword">const</span> total = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(cart).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, price</span>) =&gt;</span> sum + price, <span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`总价：<span class="hljs-subst">${total}</span>元`</span>); <span class="hljs-comment">// 输出：总价：16元</span>
</code></pre>
<h2 data-id="heading-3">🎫 配对游戏：Object.entries()</h2>
<p>想要同时看到标签和内容？<code>Object.entries()</code>给你完美的配对！</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> lockerPairs = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(myLocker);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(lockerPairs);
<span class="hljs-comment">/* 输出：
[
  ["name", "小明"],
  ["age", 25],
  ["hobbies", ["编程", "游戏", "爬山"]],
  ["isStudent", false]
]
*/</span>
</code></pre>
<p><strong>实用技巧</strong>：轻松将对象转换成查询字符串</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> filters = { <span class="hljs-attr">category</span>: <span class="hljs-string">"电子产品"</span>, <span class="hljs-attr">price</span>: <span class="hljs-string">"1000-5000"</span>, <span class="hljs-attr">brand</span>: <span class="hljs-string">"小米"</span> };
<span class="hljs-keyword">const</span> queryString = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(filters)
  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[key, value]</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${key}</span>=<span class="hljs-subst">${value}</span>`</span>)
  .<span class="hljs-title function_">join</span>(<span class="hljs-string">"&amp;"</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(queryString); 
<span class="hljs-comment">// 输出：category=电子产品&amp;price=1000-5000&amp;brand=小米</span>
</code></pre>
<h2 data-id="heading-4">🎯 查找目标：Object.hasOwnProperty()</h2>
<p>不确定储物柜是否有某个隔间？用这个方法检查一下！</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myLocker.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">"name"</span>)); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myLocker.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">"address"</span>)); <span class="hljs-comment">// false</span>
</code></pre>
<h2 data-id="heading-5">🧙‍♂️ 对象克隆术</h2>
<h3 data-id="heading-6">方法一：Object.assign() - 复制粘贴小能手</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> original = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> copy = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, original);
copy.<span class="hljs-property">a</span> = <span class="hljs-number">99</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(original.<span class="hljs-property">a</span>); <span class="hljs-comment">// 仍然是1，完美克隆！</span>
</code></pre>
<h3 data-id="heading-7">方法二：展开操作符 - 更现代的写法</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> original = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> copy = { ...original, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> }; <span class="hljs-comment">// 还能顺便添加新属性！</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(copy); <span class="hljs-comment">// { a: 1, b: 2, c: 3 }</span>
</code></pre>
<h2 data-id="heading-8">🚀 高级技巧：组合使用</h2>
<p>让我们看看这些方法如何协同工作，解决实际问题：</p>
<p><strong>场景</strong>：统计文章标签出现频率</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> articles = [
  { <span class="hljs-attr">title</span>: <span class="hljs-string">"JS入门"</span>, <span class="hljs-attr">tags</span>: [<span class="hljs-string">"编程"</span>, <span class="hljs-string">"JavaScript"</span>] },
  { <span class="hljs-attr">title</span>: <span class="hljs-string">"CSS技巧"</span>, <span class="hljs-attr">tags</span>: [<span class="hljs-string">"编程"</span>, <span class="hljs-string">"CSS"</span>] },
  { <span class="hljs-attr">title</span>: <span class="hljs-string">"React实战"</span>, <span class="hljs-attr">tags</span>: [<span class="hljs-string">"编程"</span>, <span class="hljs-string">"JavaScript"</span>, <span class="hljs-string">"React"</span>] }
];

<span class="hljs-comment">// 一行代码统计所有标签频率！</span>
<span class="hljs-keyword">const</span> tagFrequency = articles
  .<span class="hljs-title function_">flatMap</span>(<span class="hljs-function"><span class="hljs-params">article</span> =&gt;</span> article.<span class="hljs-property">tags</span>)
  .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, tag</span>) =&gt;</span> {
    acc[tag] = (acc[tag] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> acc;
  }, {});

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tagFrequency);
<span class="hljs-comment">// 输出：{ 编程: 3, JavaScript: 2, CSS: 1, React: 1 }</span>
</code></pre>
<h2 data-id="heading-9">🎮 趣味挑战：自己动手试试！</h2>
<p>试试这个迷你挑战，巩固你今天学到的知识：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 挑战：找出两个对象的差异</span>
<span class="hljs-keyword">const</span> obj1 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> };
<span class="hljs-keyword">const</span> obj2 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">5</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span> };

<span class="hljs-comment">// 你的代码写在这里...</span>
<span class="hljs-comment">// 提示：使用 Object.keys() 和 filter()</span>

<span class="hljs-comment">// 答案：</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">findDifferences</span> = (<span class="hljs-params">objA, objB</span>) =&gt; {
  <span class="hljs-keyword">const</span> allKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(objA), ...<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(objB)]);
  <span class="hljs-keyword">const</span> differences = {};
  
  allKeys.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (objA[key] !== objB[key]) {
      differences[key] = { <span class="hljs-attr">obj1</span>: objA[key], <span class="hljs-attr">obj2</span>: objB[key] };
    }
  });
  
  <span class="hljs-keyword">return</span> differences;
};

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findDifferences</span>(obj1, obj2));
<span class="hljs-comment">// 输出：{ b: { obj1: 2, obj2: 5 }, c: { obj1: 3, obj2: undefined }, d: { obj1: undefined, obj2: 4 } }</span>
</code></pre>
<h2 data-id="heading-10">💡 小贴士</h2>
<ol>
<li>
<p><strong>深拷贝 vs 浅拷贝</strong>：上面的克隆方法都是浅拷贝，对于嵌套对象，需要使用递归或<code>JSON.parse(JSON.stringify(obj))</code>（有局限性）</p>
</li>
<li>
<p><strong>现代JavaScript</strong>：ES6+ 提供了更多便利，如可选链操作符<code>?.</code>和空值合并操作符<code>??</code></p>
</li>
<li>
<p><strong>性能考虑</strong>：对于大型对象，某些操作可能影响性能，在实际项目中要注意</p>
</li>
</ol>
<h2 data-id="heading-11">总结</h2>
<p>JavaScript的对象方法就像是给你的代码工具箱添加了一系列瑞士军刀。掌握这些方法不仅能让你写出更简洁的代码，还能解决许多实际开发中的难题。</p>
<p>记住，编程就像魔法——你掌握的“咒语”（方法）越多，能创造的奇迹就越大！✨</p>
<p><strong>今日收获</strong>：尝试在你当前的项目中，用至少一种今天学到的方法重构一段代码，看看能否让它变得更简洁！</p>
<hr/>
<p><em>下次预告：我们将探索数组的那些神奇方法，让你的数据处理能力更上一层楼！</em></p>
<p>希望这篇博客对你有帮助！如果有任何问题或想分享你的对象操作技巧，欢迎在评论区留言讨论！ 🎉</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[踩过坑才懂：前端生成唯一 ID，别用 Date.now ()了！一行代码搞定]]></title>    <link>https://juejin.cn/post/7584358227611107370</link>    <guid>https://juejin.cn/post/7584358227611107370</guid>    <pubDate>2025-12-17T02:20:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584358227611107370" data-draft-id="7584356212801159209" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="踩过坑才懂：前端生成唯一 ID，别用 Date.now ()了！一行代码搞定"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2025-12-17T02:20:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="尽欢i"/> <meta itemprop="url" content="https://juejin.cn/user/2641474067375560"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            踩过坑才懂：前端生成唯一 ID，别用 Date.now ()了！一行代码搞定
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2641474067375560/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    尽欢i
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:20:32.000Z" title="Wed Dec 17 2025 02:20:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:18px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:40px;margin-bottom:20px;color:#007fff;display:flex;align-items:center}.markdown-body h1:hover:before,.markdown-body h2:hover:before,.markdown-body h3:hover:before,.markdown-body h4:hover:before,.markdown-body h5:hover:before,.markdown-body h6:hover:before{transition:All .4s ease-in-out;transform:rotate(1turn)}.markdown-body h1{font-size:30px;background:linear-gradient(#fff 60%,#c6e3ff 0)}.markdown-body h1:before{content:"";display:inline-block;width:32px;height:32px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h2{font-size:24px;background:linear-gradient(#fff 60%,#cce3fb 0)}.markdown-body h2:before{content:"";display:inline-block;width:24px;height:24px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h3{font-size:20px}.markdown-body h3:before{content:"";display:inline-block;width:18px;height:18px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h4{font-size:18px}.markdown-body h4:before{content:"";display:inline-block;width:16px;height:16px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h5{font-size:16px}.markdown-body h5:before{content:"";display:inline-block;width:15px;height:15px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h6{font-size:14px}.markdown-body h6:before{content:"";display:inline-block;width:12px;height:12px;margin-right:10px;background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABfVBMVEX///8Ad/8AgP8AgP8AgP8Aff8AgP8Af/8AgP8AVf8Af/8Af/8AgP8AgP8Af/8Afv8AAP8Afv8Afv8Aef8AgP8AdP8Afv8AgP8AgP8Acf8Ae/8AgP8Af/8AgP8Af/8Af/8AfP8Afv8AgP8Af/8Af/8Afv8Afv8AgP8Afv8AgP8Af/8Af/8AgP8AgP8Afv8AgP8Af/8AgP8AgP8AgP8Ae/8Afv8Af/8AgP8Af/8AgP8Af/8Af/8Aff8Af/8Abf8AgP8Af/8AgP8Af/8Af/8Afv8AgP8AgP8Afv8Afv8AgP8Af/8Aff8AgP8Afv8AgP8Aff8AgP8AfP8AgP8Ae/8AgP8Af/8AgP8AgP8AgP8Afv8AgP8AgP8AgP8Afv8AgP8AgP8AgP8AgP8AgP8Af/8AgP8Af/8Af/8Aev8Af/8AgP8Aff8Afv8AgP8AgP8AgP8Af/8AgP8Af/8Af/8AgP8Afv8AgP8AgP8AgP8AgP8Af/8AeP8Af/8Af/8Af//////rzEHnAAAAfXRSTlMAD7CCAivatxIDx5EMrP19AXdLEwgLR+6iCR/M0yLRzyFF7JupSXn8cw6v60Q0QeqzKtgeG237HMne850/6Qeq7QaZ+WdydHtj+OM3qENCMRYl1B3K2U7wnlWE/mhlirjkODa9FN/BF7/iNV/2kASNZpX1Wlf03C4stRGxgUPclqoAAAABYktHRACIBR1IAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEaBzgZ4yeM3AAAAT9JREFUOMvNUldbwkAQvCAqsSBoABE7asSOBRUVVBQNNuy9996789+9cMFAMHnVebmdm+/bmdtbQv4dOFOW2UjPzgFyLfo6nweKfIMOBYWwFtmMPGz2Yj2pJI0JDq3udJW6VVbmKa9I192VQFV1ktXUAl5NB0cd4KpnORqsEO2ZIRpF9gJfE9Dckqq0KuZt7UAH5+8EPF3spjsRpCeQNO/tA/qDwIDA+OCQbBoKA8NOdjMySgcZGVM6jwcgRuUiSs0nlPFNSrEpJfU0jTLD6llqbvKxei7OzvkFNQohi0vAsj81+MoqsCaoPOQFgus/1LyxichW+hS2JWCHZ7VlF9jb187pIAYcHiViHAMnp5mTjJ8B5xeEXF4B1ze/fTh/C0h398DDI9HB07O8ci+vRBdvdGnfP4gBuM8vw7X/G3wDmFhFZEdxzjMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDEtMjZUMDc6NTY6MjUrMDE6MDA67pVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAxLTI2VDA3OjU2OjI1KzAxOjAwS7Mt6gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAWdEVYdFRpdGxlAGp1ZWppbl9sb2dvIGNvcHlxapmKAAAAV3pUWHRSYXcgcHJvZmlsZSB0eXBlIGlwdGMAAHic4/IMCHFWKCjKT8vMSeVSAAMjCy5jCxMjE0uTFAMTIESANMNkAyOzVCDL2NTIxMzEHMQHy4BIoEouAOoXEXTyQjWVAAAAAElFTkSuQmCC");background-size:100% 100%}.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{border-bottom:2px solid #007fff;color:#007fff;padding-right:10px}.markdown-body p{letter-spacing:1px;line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:10px auto}.markdown-body hr{border:none;border-top:1px dashed #92c8ff}.markdown-body hr:before{content:"✂";display:inline-block;position:relative;top:-12px;left:40px;padding:0 3px;color:#007fff;font-size:18px}.markdown-body hr:after{content:"按虚线剪开";position:relative;top:-15px;left:84%;padding:0 3px;color:#007fff;font-size:12px}.markdown-body del{color:#f44}.markdown-body em{color:#007fff;margin:0 2px}.markdown-body strong{color:#007fff;font-weight:bolder}.markdown-body code{word-break:break-word;border-radius:4px;overflow-x:auto;background-color:#e6f3ff;color:#007fff;font-weight:600;font-size:16px;padding:.065em .4em;border:1px solid #007fff}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:5px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px}.markdown-body pre&gt;code{font-size:18px;font-weight:400;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8;border:none}.markdown-body a{text-decoration:none;color:#007fff;border-bottom:1px solid #007fff}.markdown-body a:before{content:"¶";margin-right:5px;font-size:22px}.markdown-body a:after{content:"↷";margin-left:2px;font-size:22px;display:none}.markdown-body a:active,.markdown-body a:hover{color:#275b8c;border-bottom:1px solid #275b8c}.markdown-body a:active:after,.markdown-body a:hover:after{display:inline-block}.markdown-body table{display:inline-block!important;font-size:16px;width:auto;max-width:100%;overflow:auto;border:1px solid #a5d3ff}.markdown-body thead{background:#c6e3ff;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#eef7ff}.markdown-body tbody&gt;tr:nth-child(odd){background-color:#f8fcff}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #007fff;background-color:#eef7ff}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#007fff}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="srcery">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#1c1b19;color:#fce8c3}.hljs-emphasis,.hljs-strong{color:#918175}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ff5c8f}.hljs-code,.hljs-selector-class{color:#68a8e4}.hljs-emphasis{font-style:italic}.hljs-attribute,.hljs-keyword,.hljs-section,.hljs-selector-tag,.hljs-variable{color:#ef2f27}.hljs-name,.hljs-title{color:#fbb829}.hljs-params,.hljs-type{color:#0aaeb3}.hljs-string{color:#98bc37}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-subst,.hljs-symbol,.hljs-template-tag,.hljs-template-variable{color:#c07abe}.hljs-comment,.hljs-deletion,.hljs-meta{color:#918175}</style><h2 data-id="heading-0">前言</h2>
<p>做过电商 PC 端开发的兄弟估计都懂：经常得弄个「绝不会跟别的重样的编号（ID）」—— 比如给弹窗、临时加的商品条目、页面里动态蹦出来的元素做标识，免得代码把东西搞混。这事看着好像随手就能写，但真要做到百分百不重复，可比想的要坑。</p>
<p>今天就唠唠大伙常踩的俩坑，再给你说个浏览器自带的、一行代码搞定的靠谱法子。</p>
<h2 data-id="heading-1">一、先踩第一个坑：拿时间戳加随机数凑数</h2>
<p>好多人（不管是刚入门的还是干了俩年的）第一反应都是：把当前时间加个随机数不就行了？比如会写这么一段代码：</p>
<pre><code class="hljs language-scss" lang="scss">function <span class="hljs-built_in">generateNaiveId</span>() {
    return Date<span class="hljs-selector-class">.now</span>()<span class="hljs-selector-class">.toString</span>(<span class="hljs-number">36</span>) + Math<span class="hljs-selector-class">.random</span>()<span class="hljs-selector-class">.toString</span>(<span class="hljs-number">36</span>)<span class="hljs-selector-class">.substr</span>(<span class="hljs-number">2</span>);
}
</code></pre>
<p>出来的结果大概是<code>l6n7f4v2am50k9m7o4</code>这种，看着好像既有时间的 “独一份”，又有随机数的变化，挺好用？但真放到正经的生产环境里，这就是个定时炸弹：</p>
<ul>
<li>
<p><strong>时间戳精度不够</strong></p>
<p><code>Date.now()</code>只能精确到毫秒，要是在同一毫秒里连续调用两次这个函数 —— 比如用户点按钮点的特别快，或者页面一下子要生成好几个 ID—— 那 ID 的前半段就会完全一样</p>
</li>
<li>
<p><strong>随机数不靠谱</strong></p>
<p><code>Math.random()</code>那玩意生的不是啥 “靠谱随机数”，运气背的时候，短时间内可能跑出一模一样的序列</p>
</li>
</ul>
<p>说白了，这种法子也就用在半天用一次的场景里凑活，真要讲 “绝对不重复”，差得远了。</p>
<h2 data-id="heading-2">二、再踩第二个坑：用自增的计数器</h2>
<p>还有人想的更简单：整个全局的数字，每次生成 ID 就把数字加 1，从 0 开始往上排不就得了？但这个法子的问题更离谱：</p>
<ul>
<li>浏览器是 “没记性” 的，用户一刷新页面，这个计数器直接就归零重来了</li>
<li>要是用户开了俩同款页面，每个页面的计数器都是从零开始算，生成的 ID 会直接撞车</li>
</ul>
<h2 data-id="heading-3">三、别瞎折腾了：用浏览器自带的正经法子</h2>
<p>其实现在的现代浏览器（还有 Node.js14 以上的版本），早就给咱们内置了靠谱的工具 ——<code>crypto.randomUUID()</code>，一行代码就能生成绝对靠谱的唯一 ID：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">uniqueId</span> = crypto.randomUUID()<span class="hljs-comment">;</span>
</code></pre>
<p>出来的结果是这种格式：<code>3a6c4b2a-4c26-4d0f-a4b7-3b1a2b3c4d5e</code>为啥说这个是王者？</p>
<ol>
<li>
<p><strong>基本不可能撞号</strong></p>
<p>这个 ID 是用 122 位的随机数生成的，能组合出来的数字多到离谱 —— 比地球上的沙子总数还多，撞号的概率约等于你连续中三次头奖</p>
</li>
<li>
<p><strong>随机数够安全</strong></p>
<p>它用的是浏览器里专门搞加密的随机数生成工具，不是<code>Math.random()</code>那种随便凑的，没法被轻易猜到</p>
</li>
<li>
<p><strong>大家都认</strong></p>
<p>生成的是全球通用的标准格式，不管是后端存数据库、还是和别的系统对接，都能直接用</p>
</li>
<li>
<p><strong>省心还高效</strong></p>
<p>不用装任何第三方的库，浏览器自带的，调用起来贼快</p>
</li>
</ol>
<p>而且现在主流的新浏览器都支持这个方法：Chrome92 以上、Firefox90 以上、Safari15.4 以上都能用，要是你做的是新项目，直接用这个就行，再也不用自己瞎写凑数的 ID 生成器了。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[复杂工业场景如何实现3D实例与部件一体化分割？多视角贝叶斯融合的分层图像引导框架]]></title>    <link>https://juejin.cn/post/7584286241489043496</link>    <guid>https://juejin.cn/post/7584286241489043496</guid>    <pubDate>2025-12-17T02:08:04.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584286241489043496" data-draft-id="7584297353420341248" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="复杂工业场景如何实现3D实例与部件一体化分割？多视角贝叶斯融合的分层图像引导框架"/> <meta itemprop="keywords" content="算法,计算机视觉,深度学习"/> <meta itemprop="datePublished" content="2025-12-17T02:08:04.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="CoovallyAIHub"/> <meta itemprop="url" content="https://juejin.cn/user/2461151071843739"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            复杂工业场景如何实现3D实例与部件一体化分割？多视角贝叶斯融合的分层图像引导框架
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2461151071843739/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    CoovallyAIHub
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:08:04.000Z" title="Wed Dec 17 2025 02:08:04 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在机器人操作、数字孪生等工业智能化场景中，精确的3D场景理解是核心技术基础。尤其在工厂环境中，零部件布局密集、尺度差异大、遮挡严重，传统分割方法往难以同时保证实例分割与部件级分割的精度。针对这一难题，《Hierarchical Image-Guided 3D Point Cloud Segmentation in Industrial Scenes via Multi-View Bayesian Fusion》提出了一种分层图像引导的3D点云分割框架，融合YOLO-World检测、SAM分割与多视角贝叶斯融合策略，在减少人工标注依赖的同时，显著提升了工业场景下的分割鲁棒性与准确性。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/882844050878459bb714391d0872ff54~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=tvEEFHpyI4yHoEGmnwkVg0BUnEw%3D" alt="图片1.png" loading="lazy"/></p>
<p>论文链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fpdf%2F2512.06882" target="_blank" title="https://arxiv.org/pdf/2512.06882" ref="nofollow noopener noreferrer">arxiv.org/pdf/2512.06…</a></p>
<h2 data-id="heading-0"><strong>工业3D分割面临的核心挑战</strong></h2>
<p>工业场景的3D点云分割长期受以下问题制约：</p>
<ul>
<li>
<p>严重遮挡与边界模糊</p>
<p>产线设备往往紧密排列，遮挡导致物体几何边界不完整，基于纯点云的方法易出现分割断裂或粘连。</p>
</li>
<li>
<p>多尺度物体并存</p>
<p>场景中同时存在机械臂、传送带等大物体与螺丝、接头等小部件，端到端模型难以兼顾粗粒度与细粒度特征。</p>
</li>
<li>
<p>标注成本高昂</p>
<p>点云逐点标注费时费力，且目前缺乏公开的工业部件级3D分割数据集。</p>
</li>
<li>
<p>2D-3D投影不一致</p>
<p>单纯依靠单视角2D分割投影到3D时，易因视角变化导致语义不一致与边缘错位。</p>
</li>
</ul>
<h2 data-id="heading-1"><strong>相关工作</strong></h2>
<ul>
<li><strong>直接3D点云分割</strong></li>
</ul>
<p>传统方法使用分组方法，但依赖于几何邻近性和手工启发式规则，限制了对复杂场景的扩展性。近年来基于深度神经网络的分割方法广泛使用，直接从无序点云中学习特征以预测语义标签。然而，由于缺乏明确的拓扑和邻接结构，这些模型难以捕捉稳定的局部几何信息，因此需要密集的点级标注，且在大规模杂乱场景中表现不佳。此外，现有的标注3D数据集规模小，标注精细3D模型工作量大，目前尚无公开支持工业场景部件级分割的数据集。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cd5c6f3bb6a447c29b9ffe608d175d2b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=KzozxpgHdLW4t19vrR9hT1COTKo%3D" alt="图片2.png" loading="lazy"/></p>
<ul>
<li><strong>基于2D监督的图像引导3D分割</strong></li>
</ul>
<p>为克服3D监督的限制，一些方法将3D点云投影到2D图像，并使用生成的掩码将2D语义转移到3D空间。SAM、YOLO-World、GLIP等视觉基础模型受益于大规模2D数据集和弱监督训练，能以低成本实现高质量分割。然而，SAM不提供类别标签，YOLO-World和GLIP仅提供类别预测而无像素级掩码，难以直接用于3D分割。将点云渲染为2D图像会引入遮挡和视角相关变化，常导致跨视角边界和语义不一致。缺乏鲁棒融合策略的现有方法无法确保一致的3D分割。此外，大多数基础模型训练于通用类别，不能直接适应工厂场景，现有2D图像数据集也缺乏工业环境覆盖。</p>
<ul>
<li><strong>提出的制造场景3D点云分割方法</strong></li>
</ul>
<p>我们提出一种由2D预测引导的两阶段分层分割框架，逐步从粗实例到细粒度部件细化场景理解（图2）。框架始于自适应渲染，根据物体尺寸和点密度，使用尺度感知参数将3D点云投影为2D图像。在每个阶段，YOLO-World检测物体并提供提示给SAM生成2D掩码，再反投影到3D。实例级分割使用俯视图投影高效标记大物体，部件级分割通过贝叶斯更新融合多视角掩码，解决不一致性并在遮挡和视角变化下提高标签稳定性。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/cf954f84f26943618e5f204800dcd767~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=ekfU6lQmjfZyiMEUfFD3vSh07Bc%3D" alt="图片3.png" loading="lazy"/></p>
<ul>
<li>
<p>自适应2D图像渲染与分割</p>
<p>我们提出一种尺度自适应渲染策略，基于物体几何和密度计算点半径。渲染后的2D图像使用YOLO-World和SAM两阶段方法进行分割：YOLO-World检测物体实例或部件并生成类别感知边界框，作为SAM的提示以生成高质量像素级掩码。这种提示驱动设计使SAM能在杂乱、遮挡和尺度变化下生成准确分割。</p>
</li>
<li>
<p>通过2D掩码投影的3D点云分割</p>
<p>获取各阶段准确2D掩码后，我们将其几何和语义先验转移到3D空间。为适应两个阶段的不同目标，我们设计了不同的投影方法：</p>
<p>实例级分割（俯视图）： 使用轻量高效的基于2D掩码投影的策略，快速对大规模密集点云进行粗实例分割。</p>
<p>部件级分割（多视角反投影）： 围绕每个实例点云采样多个视角，在各视角上使用YOLO-World+SAM生成部件级2D掩码，并通过反投影和深度引导KD树匹配将其映射回3D点。</p>
</li>
<li>
<p>多视角掩码一致性与贝叶斯更新融合</p>
<p>为处理跨视角语义不一致，我们通过贝叶斯更新递归融合每个点的多视角观测，估计一致的类别分布。每个视角的观测被建模为软类别分布，并引入几何感知置信度评分以增强在遮挡和噪声下的鲁棒性。最终通过选择置信度高于阈值的类别标签，构建带标签的点集，并通过DBSCAN聚类去除异常值，进一步提升部件级分割准确性。</p>
</li>
</ul>
<h2 data-id="heading-2"><strong>实验与评估</strong></h2>
<p>我们在真实工业场景和公开数据集上评估了系统性能。实验环境为Intel i9-13900HK CPU、NVIDIA RTX 4090 GPU、32GB RAM、Ubuntu 22.04。</p>
<ul>
<li><strong>2D图像检测与分割评估</strong></li>
</ul>
<p>我们在200张图像上微调实例级YOLO-World模型（涵盖2类：传输系统和机械臂），在600张图像上训练部件级模型（涵盖6类）。实验表明，我们的分层方法在部件级掩码精度上优于直接单阶段方法，尤其在处理小结构和遮挡时表现更好。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5b689b3c17d44aca99a7185d6727bef6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=wxYYI3nFLuSD%2FPD0npkU5Gymt60%3D" alt="图片4.png" loading="lazy"/></p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/08b6b07798784fa6beb5a20871344f5c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=LFyNITG7KX98me78VVF%2FMRFfa5I%3D" alt="图片5.png" loading="lazy"/></p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/783566ddb374468296302fecc5748bb4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=bIO5%2FHCq8B%2FJeNXIwEd3ym318To%3D" alt="图片6.png" loading="lazy"/></p>
<ul>
<li><strong>3D分割结果与评估</strong></li>
</ul>
<p>通过消融实验验证贝叶斯融合在多视角投影中处理特征不一致和遮挡的有效性。实验显示，直接投影会导致错误分割，而贝叶斯融合能显著提升边界清晰度和部件识别准确性（图5）。定量评估也显示贝叶斯融合在各类别上的mIoU均有提升（表2）。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f51ad704c5b456f9d1b2c4f4c7a88c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=OM7GIKsSi3ru33xR7QYQmAznUes%3D" alt="图片7.png" loading="lazy"/></p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab541c5f13d84da0b2969a01fc8e809c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=H5oFcyZBQUqq7KUK0%2BHeN3PXtd0%3D" alt="图片8.png" loading="lazy"/></p>
<ul>
<li><strong>全场景分割结果</strong></li>
</ul>
<p>图6展示了整个工业环境的完整分割结果。实例级分割清晰分离了机械臂和传输系统，部件级分割则准确标记了所有工站的组件，展现了框架在复杂工业场景中的有效性。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7ec3cc2cfeb4aa3b334cf7985874219~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=qKlPdVA0ywwWzkbxE3O%2B0RDDTKY%3D" alt="图片9.png" loading="lazy"/></p>
<ul>
<li><strong>在公开数据集上的泛化评估</strong></li>
</ul>
<p>我们在PartNet数据集上进行实验，验证框架在通用3D场景中的泛化能力。通过组合多个物体构建复杂场景，并使用GLIP作为检测模型（无需微调），我们的方法取得了与其他专门方法相近的部件分割精度（表3）。</p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d06e3c1d027a4c9095ed1b982b2f3942~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=JZZRA4ai1B2cggOu535wgTmOGes%3D" alt="图片10.png" loading="lazy"/></p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/826a819fabf84ab58e772fbbf615d01f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=l3A0CQ5G4djIpcS8np18LsWZDGo%3D" alt="图片11.png" loading="lazy"/></p>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8f7d5f1cfe534da2b5822cf59546499b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQ29vdmFsbHlBSUh1Yg==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766542084&amp;x-signature=VIoXBPHgt61rKmvtuRergbodgrg%3D" alt="图片12.png" loading="lazy"/></p>
<h2 data-id="heading-3"><strong>结论与未来工作</strong></h2>
<p>我们提出了一种由2D检测-分割引导的分层3D分割框架，通过YOLO-World提供标签与提示，结合SAM实现从物体到部件的精确分割，并利用贝叶斯融合解决跨视角一致性问题。在真实工厂数据和公开数据集上的实验验证了其在遮挡和杂乱环境下的鲁棒性。</p>
<p>未来工作将考虑融入深度等多模态信息，提升小部件和严重遮挡部件的分割能力，并尝试在多视角一致性建模方面进行改进，直接在2D分割层保证视角一致性，减少后续融合步骤引入的误差。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[《预言市场进化论：从罗马斗兽场，到 Polymarket 的 K 线图》]]></title>    <link>https://juejin.cn/post/7584358227611189290</link>    <guid>https://juejin.cn/post/7584358227611189290</guid>    <pubDate>2025-12-17T02:40:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7584358227611189290" data-draft-id="7584343534967947306" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="《预言市场进化论：从罗马斗兽场，到 Polymarket 的 K 线图》"/> <meta itemprop="keywords" content="前端,后端"/> <meta itemprop="datePublished" content="2025-12-17T02:40:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="HiStewie"/> <meta itemprop="url" content="https://juejin.cn/user/1591748568038823"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            《预言市场进化论：从罗马斗兽场，到 Polymarket 的 K 线图》
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1591748568038823/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    HiStewie
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2025-12-17T02:40:33.000Z" title="Wed Dec 17 2025 02:40:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2025-12-17
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读15分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="github-gist">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#333}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#d73a49}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-symbol{color:#0086b3}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#6f42c1}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.hljs-number{color:#005cc5}.hljs-string{color:#032f62}</style><h2 data-id="heading-0">前言</h2>
<p>离职了，写一点对上家公司业务的感想：</p>
<ul>
<li>Web3的预测市场在做什么？</li>
<li>为什么会有这种业务？</li>
<li>是凭空产生的想法吗，还是对已有场景的Web3重构？</li>
<li>现在还能入职做类似业务吗（不建议，长尾效应 + 资本倾轧，当前市场除了Kalshi没有任何能在Polymarket嘴里抢饭吃的产品，其他预测市场未来发展除了搞不合规的业务，不然无法存活）</li>
</ul>
<p><strong>我们如何利用人类的“贪婪” (Greed)，来获取这个世界的“真相” (Truth)？</strong></p>
<p>在 2024 年的美国总统大选季，我们学到的最重要一课是：<strong>不要看 CNN 说什么，要看 Polymarket 赌什么。</strong></p>
<p>为什么一个建立在区块链上的“赌场”，会比拥有百年历史的民调机构更准确？这不仅仅是运气。这是一场关于<strong>信息论、行为学和去中心化技术</strong>的精密实验。</p>
<p>Polymarket 的本质，不是为了让你陷入一个二元牌桌进行加码下注。它是利用你投机的心理，计算出世界的真实概率。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6795bc3aff314b21882424a9b05d69dc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGlTdGV3aWU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766544032&amp;x-signature=WW%2BlKeocRc2Px2C6%2FoSQVv3o7BQ%3D" alt="截屏2025-12-17 10.28.38.png" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-1">第一章：行为学与经济学 —— 为什么“真金白银”是唯一诚实的语言？</h2>
<p><strong>(The Psychology: Skin in the Game)</strong></p>
<p>在互联网时代，观点（Opinion）是世界上最泛滥的商品，同时也是最廉价的。</p>
<p>打开 Twitter 或微博，你会看到无数专家信誓旦旦地预测：“A 币必涨”、“B 队必胜”、“C 候选人稳了”。</p>
<p>如果他们错了，代价是什么？通常是<strong>零</strong>。他们甚至不需要删帖，只要换个话题继续吹牛即可。</p>
<p>经济学把这种现象称为“廉价谈话” (Cheap Talk)。因为没有成本，所以噪音淹没了信号。</p>
<p>但在 Polymarket 上，同样的一个观点，可能要花你 1000 美元。</p>
<ol>
<li>
<h3 data-id="heading-2">切肤之痛 (Skin in the Game)：理性的强制唤醒</h3>
</li>
</ol>
<p>纳西姆·塔勒布（Nassim Taleb）在《非对称风险》中提出了一个核心概念： <strong>“没有风险共担，就没有决策权。”</strong></p>
<p>预测市场的魔力，在于它利用金钱强行改变了你的大脑运作模式：</p>
<ul>
<li><strong>无筹码状态（社交媒体）：</strong> 大脑由<strong>多巴胺</strong>主导。你的发言是为了寻求认同、宣泄情绪或展示立场。你说“川普会赢”，是因为你希望他赢。</li>
<li><strong>有筹码状态（预测市场）：</strong> 当你把 1000 USDC 放在牌桌上的那一刻，多巴胺退场，<strong>前额叶皮层（理性逻辑）</strong> 重新占领高地。你会立刻停止一厢情愿的幻想，开始疯狂研究民调数据、摇摆州经济状况和历史赔率。</li>
</ul>
<p><strong>结论：</strong> Polymarket 并不是在预测未来，它是在“提纯”人类的判断。它用金钱作为过滤器，滤掉了所有的“我希望 (I hope)”，只留下了最真实的“我认为 (I think)”。</p>
<ol start="2">
<li>
<h3 data-id="heading-3">风险转移 (Risk Transfer)：给“焦虑”定价</h3>
</li>
</ol>
<p>如果说“切肤之痛”解释了为什么预测市场<strong>准</strong>，那么“风险转移”则解释了为什么它<strong>有用</strong>。</p>
<p>很多人误以为 Polymarket 只是一个赌博平台，但在经济学家眼里，它是一个完美的“焦虑交易所”。</p>
<p>让我们看一个经典的 <strong>“情感对冲” (Emotional Hedge)</strong> 案例：</p>
<blockquote>
<p>假设你是一位坚定的环保主义者，你极度恐惧特朗普当选，因为你担心他会废除环保法案，导致你的清洁能源公司破产。</p>
<p><strong>你应该怎么做？</strong> 在 Polymarket 上，你应该<strong>重仓买入“特朗普胜选”</strong> 。</p>
</blockquote>
<p>这听起来很反直觉，但这正是金融对冲的精髓：</p>
<ul>
<li><strong>情况 A（特朗普赢了）：</strong> 你的环保理想破灭了，公司可能面临困难，<strong>但你在 Polymarket 上赚了一大笔钱</strong>。这笔钱是对你精神创伤和潜在经济损失的<strong>补偿</strong>。</li>
<li><strong>情况 B（特朗普输了）：</strong> 你在 Polymarket 上的钱归零了，<strong>但你很高兴</strong>。因为你的理想实现了，你的公司安全了。你亏掉的那笔钱，本质上是你为“世界和平”支付的<strong>保费</strong>。</li>
</ul>
<p>通过这种机制，Polymarket 把风险从“风险厌恶者” <strong>（如上述的环保主义者）手中，转移到了</strong>“风险投机者”（单纯想赚钱的交易员）手中。</p>
<p>在这个维度上，预测市场不再是赌场，它是<strong>人类历史上第一个能够量化、交易并对冲“未来焦虑”的金融基础设施</strong>。</p>
<h2 data-id="heading-4">第二章：历史演变 —— 从“多巴胺”到“资产化”</h2>
<p><strong>(The Evolution: History &amp; Status)</strong></p>
<p>人类为了给“不确定性”定价，走了几千年。这是一部从血腥的沙场走向冰冷的代码的进化史。</p>
<p>让我们把镜头拉过这漫长的时光隧道，看看“预测”是如何一步步脱胎换骨的。</p>
<h3 data-id="heading-5">1.0 罗马斗兽场：带血的筹码</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8c15c6277b474a4dbfa3f78ba723f104~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGlTdGV3aWU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766544032&amp;x-signature=deTSpuXTIJaGfgmInmMss4ORDYQ%3D" alt="" loading="lazy"/></p>
<p><strong>(The Era of Dopamine)</strong></p>
<p>公元 80 年，罗马斗兽场。</p>
<p>空气中弥漫着汗水和血腥味。两个角斗士正在殊死搏斗，看台上的贵族把金币扔进盘子里，赌那个拿三叉戟的奴隶能活下来。</p>
<p>这是预测市场的<strong>史前时代</strong>。 在这里，预测是一种纯粹的<strong>多巴胺消费</strong>。没有复杂的赔率计算，没有风险对冲模型，只有最原始的冲动——我想看他赢，或者我想看他死。这本质上和今天你在球赛里赌谁进球没有区别，它满足的是兽性，而非理性。</p>
<p><strong>核心逻辑：</strong> 钱进去了，被庄家狠狠切了一刀，剩下的才给赢家。这是一个<strong>负和游戏</strong>。</p>
<h3 data-id="heading-6">2.0 芝加哥的粮仓：恐惧的解药</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/16379cd39ab14fefbdb19bea07bd6b4f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGlTdGV3aWU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766544032&amp;x-signature=TCzin6g4v19q9O9TYKRU812Sa%2BI%3D" alt="" loading="lazy"/></p>
<p><strong>(The Era of Hedging)</strong></p>
<p>镜头切到 1848 年，芝加哥。</p>
<p>这里没有角斗士，只有满脸愁容的玉米农场主。他们不关心谁赢，他们只关心明年玉米会不会跌到连运费都不够。</p>
<p>于是，<strong>芝加哥期货交易所 (CBOT)</strong> 诞生了。 人类历史上第一次，人们把“明年的玉米”变成了一张可以现在买卖的纸。这不再是赌博，这是<strong>生存</strong>。 预测从“娱乐”进化成了“避险工具”。金融学介入了，它告诉世界：<strong>时间是可以被定价的，恐惧是可以被买卖的。</strong></p>
<p><strong>核心逻辑：</strong> 农民卖出“恐惧”，投机者买入“贪婪”。CME 在中间做担保。这是<strong>金融避险</strong>。</p>
<h3 data-id="heading-7">3.0 以太坊的早期废墟：极客的乌托邦</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e920ad3c738045ad937ac1c1b358e70a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGlTdGV3aWU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766544032&amp;x-signature=VpF9%2BK6yLPqu1a%2BnD5nI%2BuocKMg%3D" alt="" loading="lazy"/></p>
<p><strong>(The Era of Friction)</strong></p>
<p>时间来到 2015 年，以太坊刚刚诞生。 一群天才极客（包括 Vitalik 自己）兴奋地宣称：“我们要把芝加哥交易所搬到链上！我们要消灭中间商！” 于是，<strong>Augur</strong> 诞生了。理念极其性感，现实极其骨感。</p>
<p>想象一下这个场景： 你想赌希拉里会不会赢。你打开 Augur，首先要下载几十 GB 的区块链数据，同步三天三夜。好不容易同步完了，你点了一下“Yes”，弹窗告诉你：<strong>Gas 费 $50，确认时间 15 分钟。</strong> 等你下完注，希拉里可能都已经发表败选感言了。</p>
<p>Augur 是一次伟大的失败。它证明了：<strong>没有用户体验的去中心化，只是一场昂贵的自嗨。</strong> 它赢了哲学，输了人性。</p>
<p><strong>核心逻辑：</strong> 流程太长，摩擦太大。用户还没开始玩，就被 Gas 费和等待时间劝退了。这是<strong>技术自嗨</strong>。</p>
<h3 data-id="heading-8">4.0 Polymarket：当技术隐形</h3>
<p><strong>(The Era of Assetization)</strong></p>
<p>最后，镜头定格在 2024 年。</p>
<p>你躺在沙发上，打开手机，点开 Polymarket。没有下载节点，没有助记词的恐惧，没有高昂的 Gas 费（感谢 Polygon 和 L2）。</p>
<p>你用 USDC 充值，像发微信一样丝滑地买入了“特朗普胜选”。</p>
<p>这才是终局。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf82856271a5492e9e3b3165265e3867~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGlTdGV3aWU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766544032&amp;x-signature=tU2lDXsZQ0rVmANMQrxr1iyy8nQ%3D" alt="" loading="lazy"/></p>
<p><strong>核心逻辑：</strong> USDC 进去，瞬间变成 Yes/No 代币。L2 解决了速度，AMM 解决了流动性。这是<strong>信息资产化</strong>。</p>
<p>Polymarket 做对了一件事：<strong>它让区块链消失了。</strong> 它把“预测”变成了一种<strong>高流动性的信息资产</strong>。你手中的那个 Token，不再是一张死板的赌票，而是一个活着的、每秒钟都在跳动的 <strong>“概率所有权”</strong> 。</p>
<ul>
<li>你可以随时买入（表达观点）；</li>
<li>你可以随时卖出（获利了结）；</li>
<li>你可以把它借贷、抵押、甚至组合。</li>
</ul>
<p>从罗马的带血金币，到芝加哥的期货合约，再到 Augur 的卡顿代码，最终进化成了 Polymarket 上那条丝滑的蓝色 K 线。</p>
<p>这不仅仅是技术的胜利，这是<strong>流动性的胜利</strong>。</p>
<hr/>
<h2 data-id="heading-9">第三章：工作原理 —— 价格即概率</h2>
<p><strong>(The Mechanism: Price = Probability)</strong></p>
<p>Polymarket 的核心魔法，在于它充当了一台“降维打击”的机器。</p>
<p>现实世界是混沌的、复杂的、充满噪音的。但 Polymarket 通过<strong>二元期权 (Binary Option)</strong> ，强行把这个复杂的世界压缩成了两个简单的状态：<strong>Yes 或 No</strong>。</p>
<p>这背后有一套优雅的数学逻辑。</p>
<ol>
<li>
<h3 data-id="heading-10">拆解原子：1 USDC = 1 Yes + 1 No</h3>
</li>
</ol>
<p>很多人以为在 Polymarket 上下注是把钱交给庄家。<strong>错。</strong> 当你把 1 美元（USDC）存入市场时，智能合约实际上执行了一次“原子分裂”：</p>
<blockquote>
<p><strong>1 USDC ➡️ 1 个“Yes Token” + 1 个“No Token”</strong></p>
</blockquote>
<p>这是一个恒等式。无论未来发生什么，只要你同时持有 Yes 和 No，你随时可以把它们合并，换回你的 1 USDC。</p>
<ul>
<li><strong>如果事件发生（Yes 赢了）：</strong> Yes Token 价值变成 $1，No Token 归零。</li>
<li><strong>如果事件没发生（No 赢了）：</strong> No Token 价值变成 $1，Yes Token 归零。</li>
</ul>
<p>这就是为什么<strong>价格完美对应概率</strong>： 如果“川普胜选”的 Yes Token 现在的交易价格是 **<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.60</mn><mo>∗</mo><mo>∗</mo><mtext>，这意味着市场共识认为，这张纸片最终变成</mtext></mrow><annotation encoding="application/x-tex">0.60**，这意味着市场共识认为，这张纸片最终变成 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"/><span class="mord">0.60</span><span class="mspace" style="margin-right:0.2222em;"/><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"/></span><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord">∗</span><span class="mord cjk_fallback">，这意味着市场共识认为，这张纸片最终变成</span></span></span></span></span>1 的概率是 <strong>60%</strong> 。</p>
<p>这不再是简单的交易，这是<strong>全球认知的实时投票</strong>。每一分钱的流动，都在微调这个概率模型。</p>
<ol start="2">
<li>
<h3 data-id="heading-11">贪婪的鲨鱼：套利机制 (Arbitrage)</h3>
</li>
</ol>
<p>为什么我们要相信这个 $0.60 是准确的？为什么它比 CNN 的民调更准？ 答案很简单：<strong>因为有人想捡钱。</strong></p>
<p>让我们推演一个“错误定价”的场景：</p>
<blockquote>
<p><strong>场景：</strong> 假设所有客观数据（民调、经济模型）都显示川普的胜率是 <strong>60%</strong> 。 <strong>现状：</strong> 但在 Polymarket 上，由于一群狂热的反对者砸盘，川普的价格被压低到了 <strong>$0.10</strong>（即 10%）。</p>
</blockquote>
<p>这时候，<strong>套利者（Arbitrageurs）</strong> 登场了。 在他们眼里，这不叫“政治立场”，这叫“地上有钱”。</p>
<ul>
<li>他们看到的是：用 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.10</mn><mtext>买入一个价值</mtext></mrow><annotation encoding="application/x-tex">0.10 买入一个价值 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord">0.10</span><span class="mord cjk_fallback">买入一个价值</span></span></span></span></span>0.60 的资产。</li>
<li><strong>期望收益率：500%。</strong></li>
</ul>
<p>全世界的聪明资金、量化基金、甚至 AI 机器人会像闻到血腥味的鲨鱼一样蜂拥而至，疯狂买入“Yes Token”。</p>
<p>这种买入力量会迅速推高价格，直到价格从 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.10</mn><mtext>回升到</mtext></mrow><annotation encoding="application/x-tex">0.10 回升到 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"/><span class="mord">0.10</span><span class="mord cjk_fallback">回升到</span></span></span></span></span>0.60。当价格回到 $0.60 时，无利可图，鲨鱼散去。</p>
<p><strong>结论：</strong> 并不是 Polymarket 知道真相。是<strong>一个个贪婪的个体，为了赚取哪怕 1% 的无风险利润，通过“群体博弈”，强行把价格修正到了最接近真相的位置。</strong></p>
<ol start="3">
<li>
<h3 data-id="heading-12">底层引擎：CTF 与 AMM</h3>
</li>
</ol>
<p>支撑这场全球博弈的，是两个关键的技术支柱。没有它们，Polymarket 就会退化成卡顿的 Augur。</p>
<ul>
<li>
<p><strong>条件代币框架 (Conditional Tokens Framework, CTF)：</strong> 这是 Gnosis 开发的一套积木。它允许预测变得<strong>可组合</strong>。</p>
<ul>
<li><em>例子：</em> 你不仅可以赌“川普赢”，你还可以赌“川普赢 <strong>且</strong> 拜登退选”。CTF 允许把这种复杂的逻辑嵌套进 Token 里，让预测有了深度。</li>
</ul>
</li>
<li>
<p><strong>混合做市机制 (Hybrid CLOB/AMM)：</strong> 早期的链上市场使用 AMM（自动做市商），就像 Uniswap，滑点很高。 现在的 Polymarket 引入了 <strong>CLOB（中央限价订单簿）</strong> 。这意味着做市商（Market Makers）可以像在纳斯达克一样挂单。</p>
<ul>
<li><strong>结果：</strong> 极致的流动性。即使你一次性下注 100 万美元，价格可能也只会波动 0.1%。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>
<h3 data-id="heading-13">裁决机制：去中心化的法官 (The Resolution)</h3>
</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9632fedeee904aec83fbae650313584b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSGlTdGV3aWU=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1766544032&amp;x-signature=cQFxI4Zq8FzXQj4cQuTTYyY2hi0%3D" alt="" loading="lazy"/></p>
<p>在传统赌场，庄家既是运动员，又是裁判。如果庄家耍赖，你毫无办法。 但在 Polymarket，<strong>没有人拥有“上帝视角”</strong> 。</p>
<p>它引入了一个名为 <strong>UMA (Universal Market Access)</strong> 的去中心化预言机系统。这套机制被称为“乐观预言机” (Optimistic Oracle)，其逻辑非常反直觉：</p>
<ul>
<li><strong>默认诚实原则（Optimistic）：</strong> 当大选结束，任何人（通常是提议者）都可以向链上提交结果：“川普赢了”。 系统<strong>默认</strong>这句话是真的。它不会立即去查证，而是开启一个“异议窗口期” (Dispute Window)（通常是 2 小时）。</li>
<li><strong>挑战机制（The Challenge）：</strong> 在这个窗口期内，如果有人觉得结果不对（比如其实是拜登赢了），他可以质押一笔钱发起“挑战” (Dispute)。 一旦发生挑战，案件就会升级，交给 <strong>UMA 代币持有者</strong> 进行全网投票。</li>
<li><strong>谢林点博弈 (Schelling Point)：</strong> 这时候，成千上万的 UMA 持币者会进行投票。 他们为什么要投出真话？因为博弈论。 如果我乱投票（指鹿为马），UMA 系统的公信力会崩塌，我手里的币会归零。 为了保护我的资产价值，我必须<strong>投出我认为其他人也会投出的那个结果</strong>——而这个结果，通常就是<strong>客观真相</strong>。</li>
</ul>
<p><strong>结论：</strong> 并没有一个中心化的“上帝”在宣布结果。 真相是经过“默认通过 -&gt; 挑战 -&gt; 全民公投”这套严密的博弈流程后，沉淀下来的共识。这确保了即使 Polymarket 公司倒闭，只要以太坊还在，你的赌注依然能得到公正的裁决。</p>
<hr/>
<h2 data-id="heading-14">第四章：合规与冲突 —— 赌场还是公共设施？ <strong>(The Regulation: The Conflict)</strong></h2>
<p>Polymarket 已经征服了技术，但它面前还挡着一座大山：<strong>法律</strong>。</p>
<p>当一个去中心化的协议变得比 CNN 更具权威性，比拉斯维加斯更具流动性时，它不可避免地撞上了旧世界的围墙。</p>
<p>目前，Polymarket 正处于一种极度分裂的“量子叠加态”：在极客眼中，它是真理机器；在监管者眼中，它是非法赌场。</p>
<h3 data-id="heading-15">1. 监管者的视角：手里拿着锤子的 CFTC <strong>(The Hammer)</strong></h3>
<p>在美国商品期货交易委员会 (CFTC) 的办公室里，Polymarket 看起来并不性感，它看起来像是一个<strong>违规的犯罪现场</strong>。</p>
<p>CFTC 的逻辑非常硬核且传统：</p>
<ul>
<li><strong>定义：</strong> 只要你对未来的某个结果下注，并且涉及资金交割，你就是在交易“二元期权” (Binary Options)。</li>
<li><strong>规则：</strong> 在美国，提供期权交易必须持有两张牌照：<strong>DCM</strong> (指定合约市场) 和 <strong>DCO</strong> (衍生品清算组织)。</li>
<li><strong>错位：</strong> 这些法律是 1930 年代为了监管<strong>大豆、玉米和黄金</strong>而制定的。监管者的思维框架里，只有“大宗商品”才配拥有期货市场。</li>
</ul>
<p>在他们看来，把“谁当总统”变成一种可交易的资产，不仅荒谬，而且危险。这不仅涉嫌非法赌博，还可能被视为干扰选举。 <strong>结论：</strong> 在 CFTC 眼里，Polymarket 就是一个没有执照的地下赌场，必须关停。</p>
<h3 data-id="heading-16">2. 辩护者的视角：混乱时代的灯塔 <strong>(The Shield)</strong></h3>
<p>但在硅谷投资人、经济学家和 Vitalik Buterin 看来，Polymarket 根本不是赌场。</p>
<p>它是“信息公共产品” (Information Public Good)。</p>
<p>在这个 Deepfake（深度伪造）泛滥、媒体立场极化、假新闻漫天飞舞的时代，我们失去了对“真相”的感知。</p>
<ul>
<li>CNN 有立场，Fox 有立场，由于人类的偏见，民调也会撒谎。</li>
<li><strong>但钱不会撒谎。</strong></li>
</ul>
<p>支持者认为，Polymarket 提供了一个“真相仪表盘” <strong>。它不仅具有巨大的商业价值，更具有极高的</strong>社会正外部性。它让社会以最低的成本，获取了关于未来最准确的预测。 <strong>结论：</strong> 封杀 Polymarket，就像因为有人用电报诈骗而切断电报线一样，是因噎废食。</p>
<h3 data-id="heading-17">3. 现状：地缘政治套利 <strong>(The Gray Zone)</strong></h3>
<p>面对这种不可调和的矛盾，Polymarket 选择了一种极其狡猾的生存策略：<strong>地缘政治套利 (Geopolitical Arbitrage)</strong> 。</p>
<ul>
<li><strong>名义合规：</strong> 如果你用美国 IP 打开 Polymarket，你会看到一个巨大的“Access Restricted”弹窗。Polymarket 官方在前端屏蔽了美国用户，以此向 CFTC 示好：“你看，我没服务美国人。”</li>
<li><strong>链上现实：</strong> 但别忘了，智能合约部署在 Polygon 链上。<strong>区块链没有国界。</strong> 任何一个懂技术的美国人，挂个 VPN，或者直接通过 Etherscan 调用合约，依然可以畅通无阻地交易。</li>
</ul>
<p>这是一场<strong>去中心化技术 vs 威斯特伐利亚主权国家</strong>的拉锯战。 监管者可以罚款公司（Polymarket 曾在 2022 年被罚 140 万美元），可以关闭网站前端，但他们无法关闭以太坊网络，无法删除链上的代码。</p>
<hr/>
<h3 data-id="heading-18">⚔️ 附表：两个世界的认知错位</h3>
<p>为了更清晰地展示这种冲突，我们可以用一张对比表来总结：</p>



































<table><thead><tr><th>维度</th><th>🏛️ CFTC (旧世界监管)</th><th>🗽 Polymarket (新世界代码)</th></tr></thead><tbody><tr><td>核心定义</td><td>非法场外衍生品 (Illegal Derivatives)</td><td>预测市场 / 信息公共产品 (Public Good)</td></tr><tr><td>监管逻辑</td><td>“大豆逻辑”：只有大宗商品才需要期货</td><td>“信息逻辑”：任何不确定性都应被定价</td></tr><tr><td>合规要求</td><td>必须持有 DCO/DCM 牌照</td><td>代码即法律 (Code is Law)</td></tr><tr><td>看待用户</td><td>需要被保护的“赌徒”</td><td>提供信息的“预言家”</td></tr><tr><td>终极目标</td><td>维护金融秩序稳定</td><td>发现并捍卫真相</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-19">第五章：未来展望 —— 从预测选举到预测一切</h2>
<p><strong>(The Future: Predict Everything)</strong></p>
<p>选举只是 Polymarket 的“特洛伊木马” <strong>。</strong> <strong>它用最受关注的政治话题吸引了全世界的目光，但它真正想植入人类社会的，是一种全新的</strong>认知方式。</p>
<p>当“价格即概率”的机制被验证有效后，我们可以把它复制粘贴到任何充满不确定性的领域。</p>
<h3 data-id="heading-20">1. 下一代新闻标准：告别“标题党”</h3>
<p><strong>(The New Media Standard)</strong></p>
<p>现在的新闻是廉价的。任何专家都可以张口就来：“我认为美联储下个月肯定降息。” 说错了也不用负责。</p>
<p>未来的新闻将是“长着牙齿”的。</p>
<ul>
<li><strong>嵌入式真相：</strong> 想象一下，当你浏览 Bloomberg 或《纽约时报》时，不再是看专栏作家的长篇大论，而是文章旁边挂着一个 Polymarket 的实时插件：</li>
</ul>
<blockquote>
<ul>
<li><strong>“美联储降息概率：72%”</strong></li>
</ul>
</blockquote>
<ul>
<li><strong>用钱投票：</strong> 所有的 pundit（评论员）都将被迫通过下注来证明自己的观点。新闻将从“观点的罗列”进化为“概率的加权”。</li>
<li><strong>结果：</strong> 噪音被过滤，只有那些敢拿真金白银冒险的信息，才会被视为高价值信号。</li>
</ul>
<h3 data-id="heading-21">2. 企业的“诚实血清”：消灭“Yes Men”</h3>
<p><strong>(Corporate Truth Serum)</strong></p>
<p>大公司最大的问题是什么？是<strong>信息传导失真</strong>。 底层工程师明明知道项目会延期，但为了不得罪领导，层层汇报上去全是“一切顺利”。直到 Deadline 前一天，CEO 才知道完蛋了。</p>
<p>预测市场是完美的<strong>企业内部管理工具</strong>：</p>
<ul>
<li><strong>场景：</strong> Google 内部开设一个市场：“Gemini 2.0 能在 12 月前发布吗？”</li>
<li><strong>机制：</strong> 允许员工匿名交易。如果工程师们疯狂买入“No”，导致“No”的价格飙升到 $0.90。</li>
<li><strong>价值：</strong> CEO 不需要听汇报，看一眼价格就知道项目出问题了。这是一种<strong>绕过科层制、直接提取底层真相</strong>的手段。</li>
</ul>
<h3 data-id="heading-22">3. 科学与治理：Futarchy 的雏形</h3>
<p><strong>(Governance by Market)</strong></p>
<p>这是最科幻、也最激进的愿景。经济学家 Robin Hanson 提出了 <strong>"Futarchy"</strong> （未来政体）的概念： <strong>“对价值投票，对信仰下注” (Vote on Values, Bet on Beliefs)。</strong></p>
<ul>
<li>
<p><strong>解决科学危机：</strong> 现在的学术界充满无法复现的垃圾论文。如果要求科学家在发表论文时，必须在预测市场买入“我的实验可复现”的合约，学术造假成本将无限拉高。</p>
</li>
<li>
<p><strong>政策制定：</strong> 政府不再争论“该不该实施 A 政策”，而是设立两个市场：</p>
<ul>
<li>“如果实施 A，一年后 GDP 是多少？”</li>
<li>“如果不实施 A，一年后 GDP 是多少？” 市场会给出最客观的预测，政策制定者只需选择那个预期 GDP 更高的选项。</li>
</ul>
</li>
</ul>
<hr/>
<h3 data-id="heading-23">总结：从“赌场”到“认识论”</h3>
<p>Polymarket 的进化路径非常清晰：</p>





























<table><thead><tr><th>阶段</th><th>核心应用</th><th>价值主张</th><th>角色</th></tr></thead><tbody><tr><td>1.0 (现在)</td><td>美国大选、体育赛事</td><td>娱乐与投机</td><td>一个更公平的赌场</td></tr><tr><td>2.0 (中期)</td><td>宏观经济、突发新闻</td><td>信息发现</td><td>新闻媒体的“后端”</td></tr><tr><td>3.0 (终局)</td><td>企业决策、政策制定</td><td>资源配置</td><td>人类社会的“导航仪”</td></tr></tbody></table>
<p><strong>最后的结语：</strong> Polymarket 并不是在鼓励赌博。 它是在利用人类最原始的本能——<strong>贪婪</strong>，来提炼人类最稀缺的资源——<strong>真相</strong>。 在这个充满谎言的世界里，这或许是我们能找到的最诚实的镜子。</p>
<hr/>
<h2 data-id="heading-24">💡 总结</h2>
<p>从罗马斗兽场的嘶吼，到 Polymarket 安静跳动的订单薄，人类从未停止过对未来的窥探。</p>
<p>区别在于，以前我们靠祭司和水晶球，现在我们靠<strong>代码、博弈论和无数个贪婪的个体</strong>。</p>
<p>在这个充满噪音的世界里，Polymarket 告诉了我们一个朴素的真理： <strong>Talk is cheap. Show me your position.</strong> （废话少说，亮出你的仓位。）</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>