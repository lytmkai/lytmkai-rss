<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>掘金文章推荐</title>      <link>https://juejin.cn/recommended?sort=newest</link>      <description>一个帮助开发者成长的社区</description>      <generator>python juejin_recom.py @Pi20</generator>      <item>    <title><![CDATA[请求头设置没有生效]]></title>    <link>https://juejin.cn/post/7603688142005026825</link>    <guid>https://juejin.cn/post/7603688142005026825</guid>    <pubDate>2026-02-08T08:58:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603688142005026825" data-draft-id="7604037348606951462" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="请求头设置没有生效"/> <meta itemprop="keywords" content="后端,Java"/> <meta itemprop="datePublished" content="2026-02-08T08:58:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="何中应"/> <meta itemprop="url" content="https://juejin.cn/user/1435305504958535"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            请求头设置没有生效
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1435305504958535/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    何中应
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T08:58:23.000Z" title="Sun Feb 08 2026 08:58:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>说明：记录一次使用kong.unirest发起http请求，添加请求头的坑。</p>
<h2 data-id="heading-0">场景</h2>
<p>发起一个http请求，需要带上签名等请求头，如下：</p>
<pre><code class="hljs language-java" lang="java">	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">protected</span> String <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
	   <span class="hljs-type">String</span> <span class="hljs-variable">dataString</span> <span class="hljs-operator">=</span> JSON.toJSONString(data);
	   <span class="hljs-type">String</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> 加密工具，生成签名(signPrivateKey, dataString);
	   <span class="hljs-comment">// 将签名放到请求头中</span>
	   Unirest.config().getDefaultHeaders().add(<span class="hljs-string">"sign"</span>, sign);
	   HttpResponse&lt;String&gt; response = Unirest.post(url.toString())
	           .queryString(<span class="hljs-string">"type"</span>, type)
	           .contentType(ContentType.APPLICATION_JSON.toString())
	           .body(dataString)
	           .asString();
	
	   <span class="hljs-keyword">if</span> (response.isSuccess()) {
	       <span class="hljs-keyword">return</span> <span class="hljs-string">"调用成功"</span>;
	   }
	
	   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">"调用失败"</span>);
	}
</code></pre>
<p>我使用 <code>Unirest.config().getDefaultHeaders().add("sign", sign);</code> 的方式，将数据加到请求头上的。然后在调试时，发现首次通过验证后，后面取签名验证，都验证不通过，很疑惑。</p>
<h2 data-id="heading-1">解决</h2>
<p>增加打印日志后，发现除了首次，后面传递过去的签名请求头 <code>sign</code> 都是首次的数据。而看我上面的代码，是需要根据每次的数据内容，产生签名，然后加到请求头上。就是说，后面产生的<code>sign</code>，没有覆盖上一次请求的<code>sign</code>。</p>
<p>不能用上面这种方式，要用下面这种：</p>
<pre><code class="hljs language-java" lang="java">	<span class="hljs-meta">@Override</span>
	<span class="hljs-keyword">protected</span> String <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
	    <span class="hljs-type">String</span> <span class="hljs-variable">dataString</span> <span class="hljs-operator">=</span> JSON.toJSONString(data);
	    <span class="hljs-type">String</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> 加密工具，生成签名(signPrivateKey, dataString);
	    HttpResponse&lt;String&gt; response = Unirest.post(url.toString())
	            .queryString(<span class="hljs-string">"type"</span>, type)
	            .contentType(ContentType.APPLICATION_JSON.toString())
	        	.header(<span class="hljs-string">"sign"</span>, sign)
	            .body(dataString)
	            .asString();
	
	    <span class="hljs-keyword">if</span> (response.isSuccess()) {
	        <span class="hljs-keyword">return</span> <span class="hljs-string">"调用成功"</span>;
	    }
	
	    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">"调用失败"</span>);
	}
</code></pre>
<p>添加请求头，要放到<code>Unirest.post</code>发起调用时</p>
<h2 data-id="heading-2">首次发布</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fhezhongying.blog.csdn.net%2Farticle%2Fdetails%2F144166548" target="_blank" title="https://hezhongying.blog.csdn.net/article/details/144166548" ref="nofollow noopener noreferrer">hezhongying.blog.csdn.net/article/det…</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[让你的数据成为“操作日志”和“模型饲料”：事件溯源、CQRS与DataFrame漫谈]]></title>    <link>https://juejin.cn/post/7603688142005010441</link>    <guid>https://juejin.cn/post/7603688142005010441</guid>    <pubDate>2026-02-08T08:58:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603688142005010441" data-draft-id="7603651855237021705" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="让你的数据成为“操作日志”和“模型饲料”：事件溯源、CQRS与DataFrame漫谈"/> <meta itemprop="keywords" content="架构"/> <meta itemprop="datePublished" content="2026-02-08T08:58:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="一个骇客"/> <meta itemprop="url" content="https://juejin.cn/user/644760908336608"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            让你的数据成为“操作日志”和“模型饲料”：事件溯源、CQRS与DataFrame漫谈
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/644760908336608/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    一个骇客
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T08:58:17.000Z" title="Sun Feb 08 2026 08:58:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>聊到数据库类型，你大概熟悉规规矩矩的表格（关系型）或自由散漫的文档（NoSQL）。但今天，我们探访两个更“有性格”的领域：一个让数据成为一本可随时查阅、永不磨灭的“操作日志”，另一个则将数据重塑为机器学习算法最爱的“标准餐”。它们就是 <strong>事件溯源（Event Sourcing）</strong> 与 <strong>DataFrame</strong>。</p>
<h2 data-id="heading-0">第一部分：给数据一本“不可篡改的账簿” —— 事件溯源与 CQRS</h2>
<p>想象你在玩一款策略游戏。优秀的游戏不仅保存最终存档，更会完整记录你的每一步操作：“第3回合，在A地建造了农场”，“第7回合，与B国签署了贸易协定”。凭借这份详尽的“战报”，你不仅能复盘任何时刻的局势，还能深度分析每个决策的优劣。这正是 <strong>事件溯源</strong> 的核心理念。</p>
<p><strong>事件溯源（Event Sourcing, ES）</strong> 主张：<strong>不直接存储系统的当前状态（如账户余额、库存量），而是存储所有导致状态变化的历史事件（Events）</strong>。每个事件都是过去发生的、不可更改的事实，例如 <code>用户注册</code>、<code>账户充值200元</code>、<code>商品出库5件</code>。</p>
<h3 data-id="heading-1">CQRS：让“会计”与“分析师”各司其职</h3>
<p>仅有详细“战报”还不够，我们还需快速回答诸如“我当前有多少资源？”、“上周哪种资源消耗最快？”等问题。这时，它的黄金搭档 <strong>命令查询职责分离（Command Query Responsibility Segregation, CQRS）</strong> 便闪亮登场。</p>
<pre><code class="hljs language-mermaid" lang="mermaid">flowchart TD
    subgraph ClientLayer [客户层]
        A[Web/移动端] --&gt; B[API网关]
        C[管理后台] --&gt; B
    end

    subgraph CommandSide [命令层]
        B --&gt; D{命令路由器}
        D --&gt; E[账户命令处理器]
        D --&gt; F[交易命令处理器]
        D --&gt; G[订单命令处理器]
        
        E --&gt; H[账户领域模型]
        F --&gt; I[交易领域模型]
        G --&gt; J[订单领域模型]
        
        H --&gt; K[生成事件]
        I --&gt; K
        J --&gt; K
        
        K --&gt; L[(事件存储&lt;br&gt;Event Store)]
    end

    subgraph EventProcessing [事件处理层]
        L --&gt; M[事件总线/消息队列]
        M --&gt; N[账户余额投影]
        M --&gt; O[交易历史投影]
        M --&gt; P[客户画像投影]
        M --&gt; Q[实时仪表盘投影]
    end

    subgraph QuerySide [查询层]
        N --&gt; R[(账户余额视图)]
        O --&gt; S[(交易历史视图)]
        P --&gt; T[(客户画像视图)]
        Q --&gt; U[(实时仪表盘视图)]
        
        R --&gt; V[账户查询服务]
        S --&gt; V
        T --&gt; V
        U --&gt; V
        
        V --&gt; B
    end

    style CommandSide fill:#e1f5fe
    style EventProcessing fill:#fff3e0
    style QuerySide fill:#f3e5f5
</code></pre>
<p>上面的架构展示了CQRS在金融或电商系统中的实际应用：</p>
<ul>
<li><strong>命令端（Command Side）</strong>：作为严谨的"会计部门"，它：
<ul>
<li>通过API网关接收用户的写操作指令（如"转账"、"下单"）</li>
<li>由专门的命令处理器验证业务规则</li>
<li>通过领域模型执行业务逻辑，生成对应的事件</li>
<li>将所有事件持久化到<strong>事件存储（Event Store）</strong> 中</li>
</ul>
</li>
<li><strong>事件处理层（Event Processing）</strong>：这是连接会计部门与分析部门的桥梁：
<ul>
<li>事件存储中的新事件被发布到事件总线或消息队列</li>
<li>多个<strong>投影处理器（Projection Handler）</strong> 监听这些事件</li>
<li>每个处理器负责维护特定用途的物化视图</li>
</ul>
</li>
<li><strong>查询端（Query Side）</strong>：作为灵活的"分析部门"，它：
<ul>
<li>维护着各种优化后的物化视图（如账户余额、交易历史、客户画像）</li>
<li>提供专门的查询服务，响应客户端的读请求</li>
<li>每个视图都可以使用最适合其查询模式的数据存储技术</li>
</ul>
</li>
</ul>
<p><strong>这套“会计+分析师”的架构为何强大？</strong></p>
<ol>
<li><strong>完整的真相之源</strong>：事件日志是系统的唯一事实来源。任何查询结果（物化视图）都可以通过“重播”所有事件来重新计算和验证。当某份“报表”出错时，只需让对应的分析师<strong>根据原始账簿重算一遍</strong>即可。这在复杂的业务系统中提供了“时间旅行”般的调试能力。</li>
<li><strong>职责分离，极致优化</strong>：读写路径完全分离，允许各自独立扩展与优化。写入端可以专注于高吞吐的事件记录，读取端则可以针对不同的查询模式构建最合适的索引与存储结构。</li>
<li><strong>无与伦比的可演进性</strong>：当需要一个新的数据视角（如新的报表）时，你无需修改已有的“记账”逻辑，只需新增一个“分析师”（新的物化视图），让他从历史事件中推导出新报表。系统对业务变化的适应能力极强。</li>
<li><strong>内置的审计线索</strong>：完整的事件序列本身就是最天然的审计日志，满足了金融、医疗等强监管领域的合规性要求。</li>
</ol>
<p><strong>当然，它也不是点石成金的魔法：</strong></p>
<ul>
<li><strong>“重放”的一致性挑战</strong>：如果事件处理逻辑依赖于外部服务（如调用汇率接口），那么“重放”历史事件时必须能获取到<strong>当时</strong>的汇率，否则计算结果会“穿越”。</li>
<li><strong>隐私数据的“橡皮擦”难题</strong>：法规要求删除用户个人数据。但事件不可变，如何“擦除”？这需要精巧的设计，比如只存储数据引用，或在存储时进行加密并保管好密钥（Crypto-Shredding）。</li>
<li><strong>小心“重复通知”</strong>：重放事件时，必须确保不会再次触发发送邮件、短信等外部副作用。</li>
</ul>
<h2 data-id="heading-2">第二部分：把数据做成“机器学习标准餐” —— DataFrame、矩阵与数组</h2>
<p>现在，让我们从记录一切的“历史学家”，切换到为机器学习模型准备“营养餐”的“数据厨师”。</p>
<p>数据科学家和分析师们钟爱的工具 <strong>DataFrame</strong>，可以被看作一个<strong>功能强大的内存中的智能表格</strong>（Python的Pandas、R语言、Apache Spark中的核心概念）。</p>
<p>DataFrame 的核心任务是<strong>数据规整（Data Wrangling）</strong>：如同厨师处理食材，它进行清洗、切片、调味——包括过滤、转换格式、合并、分组聚合等操作，将原始杂乱的“生数据”，烹饪成干净、结构化的“可用数据”。</p>
<h3 data-id="heading-3">从表格到“数字魔方”：矩阵与数组的转换艺术</h3>
<p>DataFrame 最神奇的能力之一，是能轻松地将关系型表格数据，转换成机器学习和数值计算所需的“标准格式”——<strong>矩阵（Matrix）</strong> 和<strong>多维数组（Array）</strong>。</p>
<p>为了更直观地理解这个过程，让我们通过一个"顾客-商品购买记录"的实际例子来看看DataFrame如何将表格数据转换为矩阵：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 原始购买记录表（关系型表示）</span>
purchase_records = [
    {<span class="hljs-string">"customer_id"</span>: <span class="hljs-string">"C001"</span>, <span class="hljs-string">"product_id"</span>: <span class="hljs-string">"P100"</span>, <span class="hljs-string">"purchase_count"</span>: <span class="hljs-number">2</span>},
    {<span class="hljs-string">"customer_id"</span>: <span class="hljs-string">"C001"</span>, <span class="hljs-string">"product_id"</span>: <span class="hljs-string">"P205"</span>, <span class="hljs-string">"purchase_count"</span>: <span class="hljs-number">1</span>},
    {<span class="hljs-string">"customer_id"</span>: <span class="hljs-string">"C002"</span>, <span class="hljs-string">"product_id"</span>: <span class="hljs-string">"P100"</span>, <span class="hljs-string">"purchase_count"</span>: <span class="hljs-number">1</span>},
    {<span class="hljs-string">"customer_id"</span>: <span class="hljs-string">"C003"</span>, <span class="hljs-string">"product_id"</span>: <span class="hljs-string">"P880"</span>, <span class="hljs-string">"purchase_count"</span>: <span class="hljs-number">5</span>},
    {<span class="hljs-string">"customer_id"</span>: <span class="hljs-string">"C003"</span>, <span class="hljs-string">"product_id"</span>: <span class="hljs-string">"P205"</span>, <span class="hljs-string">"purchase_count"</span>: <span class="hljs-number">3</span>},
]

<span class="hljs-comment"># 转换为DataFrame</span>
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
df = pd.DataFrame(purchase_records)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"原始购买记录表："</span>)
<span class="hljs-built_in">print</span>(df)

<span class="hljs-comment"># 使用pivot操作转换为矩阵形式</span>
matrix_df = df.pivot(index=<span class="hljs-string">'customer_id'</span>, 
                     columns=<span class="hljs-string">'product_id'</span>, 
                     values=<span class="hljs-string">'purchase_count'</span>).fillna(<span class="hljs-number">0</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n转换后的顾客-商品矩阵："</span>)
<span class="hljs-built_in">print</span>(matrix_df)
</code></pre>
<p>运行这段代码，你会看到这样的转换结果：</p>
<pre><code class="hljs">原始购买记录表：
  customer_id product_id  purchase_count
0        C001       P100               2
1        C001       P205               1
2        C002       P100               1
3        C003       P880               5
4        C003       P205               3

转换后的顾客-商品矩阵：
product_id   P100  P205  P880
customer_id                  
C001          2.0   1.0   0.0
C002          1.0   0.0   0.0
C003          0.0   3.0   5.0
</code></pre>
<p>在这个矩阵中，<strong>行是顾客，列是商品，单元格的值是购买次数</strong>。这个矩阵通常是<strong>稀疏（Sparse）</strong> 的，因为大多数顾客只购买过少数商品。</p>
<p>为了"喂给"推荐系统等机器学习算法，我们还需将文本类信息（如商品类别"电子产品"、"图书"）转化为数字。常用技巧是<strong>独热编码（One-Hot Encoding）</strong>：为每个类别创建一个新的二进制列。</p>
<p>最终，我们得到一个纯粹的、高维的数值矩阵，这正是协同过滤、分类、聚类等众多机器学习算法可直接消化的"标准输入"。</p>
<h3 data-id="heading-4">专业“冷库”：数组数据库</h3>
<p>当数据天生就是海量、规整的多维数字时（如卫星影像数据、基因序列、金融时间序列），专门的 <strong>数组数据库（Array Database）</strong>，如TileDB，便大显身手。它们如同为特定形状设计的超级冰柜，能极致高效地存储和查询这些庞大的多维数值“数据块”。</p>
<p><strong>DataFrame的魅力在于：</strong>
它是一座<strong>动态的、强大的桥梁</strong>，优雅地连接着存储原始数据的“业务世界”与需要数值化输入的“算法世界”。数据科学家在此桥上完成从数据获取、清洗、转换到模型输入的全流程。</p>
<h2 data-id="heading-5">总结：选择你的“数据超能力”</h2>
<p>我们快速领略了数据模型宇宙的一角：</p>
<ul>
<li><strong>事件溯源 + CQRS</strong> 赋予你 <strong>“完整历史回溯”与“读写解耦优化”</strong> 的超能力。它是复杂业务系统、交易平台、需要强审计追溯场景的利器。</li>
<li><strong>DataFrame与矩阵</strong> 赋予你 <strong>“敏捷数据探索”与“无缝算法对接”</strong> 的超能力。它是数据科学、机器学习流水线上无可替代的核心工具。</li>
</ul>
<p>没有万能的数据模型。关系模型是稳健的基石，文档模型处理树形数据得心应手，图模型擅长挖掘复杂关系。而事件溯源和DataFrame，则在解决“完整历史”与“灵活分析”这两类特定痛点上，展现了其独特而强大的价值。</p>
<p>下次当你设计系统或分析数据时，不妨思考：我的数据，更需要一本可供随时追溯、推演的“永恒日志”，还是一个可以自由塑形、直接喂养智能模型的“数字厨房”？答案将指引你找到最合适的“超能力”。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[solidity进阶]]></title>    <link>https://juejin.cn/post/7603769956975509545</link>    <guid>https://juejin.cn/post/7603769956975509545</guid>    <pubDate>2026-02-08T09:23:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603769956975509545" data-draft-id="7603643044035117092" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="solidity进阶"/> <meta itemprop="keywords" content="Solidity"/> <meta itemprop="datePublished" content="2026-02-08T09:23:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="unturn"/> <meta itemprop="url" content="https://juejin.cn/user/3810252135601915"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            solidity进阶
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3810252135601915/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    unturn
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T09:23:32.000Z" title="Sun Feb 08 2026 09:23:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读36分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">1、函数重载</h3>
<h4 data-id="heading-1">1.1函数重载</h4>
<p>solidity中允许函数进行重载，即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数，注意，silidity不允许修饰器重载。</p>
<p>我们定义两个都叫saySomething() 的函数，一个没有任何参数，输出Nothing；另一个接收一个string参数，输出这个string</p>
<pre><code class="hljs language-solidity" lang="solidity">function saySomething() public pure returns(string memory){
		return("Nothing")
}
function saySomething(string memory something) public pure returns(string memory){
		return("something")
}
</code></pre>
<p>返回了不同的结果，被区分为不同的函数。</p>
<p>1.2实参匹配</p>
<p>在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。如果出现多个匹配的</p>
<h3 data-id="heading-2">2、库合约</h3>
<p>我们用Strings库合约的toHexString()`来演示两种使用库合约中函数的办法。</p>
<ol>
<li>利用using for指令 指令using A for B;可用于附加库合约（从库 A）到任何类型（B）。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。注意：在调用的时候，这个变量会被当作第一个参数传递给函数：</li>
</ol>
<pre><code class="hljs language-solidity" lang="solidity">// 利用using for指令
using Strings for uint256;
function getString1(uint256 _number) public pure returns(string memory){
    // 库合约中的函数会自动添加为uint256型变量的成员
    return _number.toHexString();
}
</code></pre>
<p>2.通过库合约名称调用函数</p>
<pre><code class="hljs language-solidity" lang="solidity">// 直接通过库合约名调用
function getString2(uint256 _number) public pure returns(string memory){
    return Strings.toHexString(_number);
}
</code></pre>
<h3 data-id="heading-3">3、Import</h3>
<p>方式 1：相对路径直接导入（最常用，本地文件）</p>
<pre><code class="hljs language-solidity" lang="solidity">// 示例：当前文件在 ./contracts/ 下，导入同目录的 IERC20.sol 接口
import "./IERC20.sol";

// 示例：导入上级目录的 utils/Context.sol
import "../utils/Context.sol";

// 示例：导入子目录的 library/SafeMath.sol
import "./library/SafeMath.sol";

contract MyERC20 is IERC20 { // 直接使用导入的接口
    // ...
}
</code></pre>
<p>方式 2：按需导入指定内容</p>
<pre><code class="hljs language-solidity" lang="solidity">// 示例：从 ERC20.sol 中仅导入 ERC20 合约和 IERC20 接口，其他内容不导入
import { ERC20, IERC20 } from "./ERC20.sol";

// 示例：从公共文件中导入结构体和枚举
import { TokenType, TokenInfo } from "./common/Structs.sol";

contract MyToken is ERC20 { // 直接使用按需导入的合约
    TokenInfo public tokenInfo; // 直接使用导入的结构体
}
</code></pre>
<p>方式 3：npm 包路径导入（生产主流，第三方库）</p>
<pre><code class="hljs language-solidity" lang="solidity">// 示例1：导入 OpenZeppelin 的 ERC20 标准合约（最常用）
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
// 示例2：导入 OpenZeppelin 的安全转账库
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
// 示例3：导入 Uniswap V2 工厂合约接口
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";

contract MyOpenZeppelinToken is ERC20 {
    constructor() ERC20("OZToken", "OZT") {
        _mint(msg.sender, 1000 * 10 ** decimals());
    }
}
</code></pre>
<h3 data-id="heading-4">4、接收ETH</h3>
<h4 data-id="heading-5">4.1 接收ETH  receive</h4>
<p>receive()函数是合约收到ETH转账时被调用得函数。一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable{...}.receive() 函数不能有任何的参数，不能返回任何值，必须包含external 和 payable.</p>
<p>当合约接收ETH的时候，receive() 会被触发。receive()最后不要执行太多的逻辑因为如果别人用send 和 transfer 方法发送ETH的话，gas会限制在 2300，receive()太复杂可能会触发Out of Gas报错。如果用call就可以自定义gas执行更复杂的逻辑（这三种发送ETH的方法我们之后会讲到）。</p>
<p>我们在receive() 里发送一个event,例如：</p>
<pre><code class="hljs language-solidity" lang="solidity">// 定义事件
event Received(address Sender, uint Value);
// 接收ETH时释放Received事件
receive() external payable {
    emit Received(msg.sender, msg.value);
}
</code></pre>
<h4 data-id="heading-6">4.2 回退函数fallback</h4>
<p>fallback()函数会在调用合约不存在的函数时触发。可用于接收ETH,也可以用于代理合约proxy contract. fallback() 声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收接收ETH: fallback() external payable{...}.</p>
<p>我们定义一个fallback()函数，被触发时候会释放fallbackCalled事件，并输出msg.sender，msg.value和msg.data:</p>
<pre><code class="hljs language-solidity" lang="solidity">event fallbackCalled(address Sender, uint Value, bytes Data);

// fallback
fallback() external payable{
    emit fallbackCalled(msg.sender, msg.value, msg.data);
}
</code></pre>
<h4 data-id="heading-7">4.3 receive和fallback的区别</h4>
<p>receive和fallback都能够用于接收ETH，他们触发的规则如下：</p>
<pre><code class="hljs language-scss" lang="scss">触发<span class="hljs-built_in">fallback</span>() 还是 <span class="hljs-built_in">receive</span>()?
           接收ETH
              |
         msg<span class="hljs-selector-class">.data</span>是空？
            /  \
          是    否
          /      \
<span class="hljs-built_in">receive</span>()存在?   <span class="hljs-built_in">fallback</span>()
        / \
       是  否
      /     \
<span class="hljs-built_in">receive</span>()   <span class="hljs-built_in">fallback</span>()

</code></pre>
<p>简单来说，合约接收ETH时，msg.data为空且存在receive()时，会触发receive()；msg.data不为空或不存在receive()时，会触发fallback()，此时fallback()必须为payable。</p>
<p>receive()和payable fallback()均不存在的时候，向合约直接发送ETH将会报错（你仍可以通过带有payable的函数向合约发送ETH）。</p>
<p>案例</p>
<pre><code class="hljs language-solidity" lang="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// receive/Fallback  案例
contract ReceiveFallbackTest{
    //记录receive 的触发
    event ReceiveTriggered(address indexed sender, uint256 amount);

    //记录fallback 的触发
    event FaballTriggered(address indexed sender, uint256 amount, bytes data);

    //无calldata的转账
    receive() external payable { 
        emit ReceiveTriggered(msg.sender, msg.value); //触发事件，打印发送者和ETH金额
    }

    fallback() external payable {
        emit FaballTriggered(msg.sender, msg.value, msg.data); //打印发送者、金额、附带的calldata
    }

    function getContractBalance() external view returns (uint256) {
        return address(this).balance;
    }


}
</code></pre>
<h3 data-id="heading-8">5、发送ETH</h3>
<p>call没有gas限制，最为灵活，是最提倡的方法</p>
<p>用法是接收方地址.call{value: 发送ETH数额}("")。
call()没有gas限制，可以支持对方合约fallback()或receive()函数实现复杂逻辑。
call()如果转账失败，不会revert。
call()的返回值是(bool, bytes)，其中bool代表着转账成功或失败，需要额外代码处理一下。</p>
<p>结合接收ETH的案例</p>
<pre><code class="hljs language-solidity" lang="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract CallTest{
    //事件: 记录call调用结果
    event CallResult(address indexed target,bool success, uint256 sendAmount, bytes data);

    //场景一：用call纯转ETH(触发目标合约receive)
    //参数：_target 目标合约地址(触发目标合约的receive)
    //参数：_amount 转ETH金额
    function callTransferETH(address payable _target, uint256 _amount) external payable {
        //核心：call纯转ETH,calldata传空字符串
        (bool success, bytes memory data) = _target.call{value:_amount}("");

        //必须判断success,失败则回滚
        require(success,"Call transfer ETH failed");

        //触发事件，记录调用结果
        emit CallResult(_target,success, _amount,data);
    }

    // 场景一：用call纯转ETH(触发目标合约fallback)
    // 参数：_target 目标合约地址；_amount 转ETH金额；_data 自定义calldata（比如0x1234）
    function callTransferETHWithData(address payable _target, uint256 _amount, bytes calldata _data) external payable {
        // 核心：call带calldata转ETH，传入自定义_data
        (bool success, bytes memory data) = _target.call{value: _amount}(_data);
        
        require(success, "Call transfer ETH with data failed");

        emit CallResult(_target, success, _amount, data);
    }

    // 辅助函数：查询当前CallTest合约的ETH余额（测试后验证）
    function getCallContractBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
</code></pre>
<h3 data-id="heading-9">6、调用其他合约</h3>
<p>4个调用合约的例子</p>
<pre><code class="hljs language-solidity" lang="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract OtherContract {
    uint256 private _x = 0;
    //收到ETh的事件，记录amount 和 gas
    event Log(uint amount, uint gas);

    //返回合约ETH余额
    function getBalance() view public returns (uint) {
        return address(this).balance;
    }

    //可以调整状态变量_x的函数，并且可以往合约转ETH(payable)
    function setX(uint256 x) external payable {
        _x = x;
        //如果转入ETH, 则释放Log事件
        if(msg.value &gt; 0 ){
            emit Log(msg.value, gasleft());
        }
    }

    //读取_x
    function getX() external view returns(uint x){
        x = _x;
    }
}

contract CallContract{
    //1.传入合约地址
    //复制OtherContract合约的地址，填入callSetX函数的参数中，成功调用后，调用OtherContract合约中的getX验证x变为123
    function callSetX(address _Address,uint256 x) external {
        OtherContract(_Address).setX(x);
    }
    //2.传入合约变量
    //复制OtherContract合约的地址，填入callGetX函数的参数中，调用后成功获取x的值
    function callCetX(OtherContract _Address) external view returns(uint x) {
        x = _Address.getX();
    }
    //3.创建合约变量
    //复制OtherContract合约的地址，填入callGetX2函数的参数中，调用后成功获取x的值
    function callGetX2(address _Address) external view returns (uint x){
        OtherContract oc = OtherContract(_Address);
        x = oc.getX();
    }
    //4.调用合约并发送ETH
    //复制OtherContract合约的地址，填入setXTransferETH函数的参数中，并转入10ETH
    function setXtransferETH(address otherContract,uint256 x) payable external {
        OtherContract(otherContract).setX{value:msg.value}(x);
    }
}
</code></pre>
<p>案例</p>
<pre><code class="hljs language-solidity" lang="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;
// 被调用合约：简单计算器
contract Calculator {
    function add(uint256 a, uint256 b) external pure returns (uint256) {
        return a + b;
    }
}

contract CalculatorCaller {
    Calculator public calculator;

    constructor(address _calcAddress) {
        calculator = Calculator(_calcAddress);
    }

    // 调用计算器的 add 函数，直接返回结果
    function callAdd(uint256 a, uint256 b) external view returns (uint256) {
        return calculator.add(a, b);
    }
}
</code></pre>
<h3 data-id="heading-10">7、call</h3>
<p>call是address类型的低级成员函数，它用来与其他合约交互。它的返回值为(bool,bytes memory),分别对应call是否成功以及函数的返回值。</p>
<p>​	call是solidity官方推荐通过触发fallback或者receive函数发送ETH的方法。</p>
<p>​	不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数。</p>
<p>​	当我们不知道对方合约的源代码或ABI,就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数。</p>
<h4 data-id="heading-11">call的使用规则</h4>
<pre><code class="hljs language-ini" lang="ini">目标合约地址.call(字节码)<span class="hljs-comment">;</span>
</code></pre>
<p>​    字节码利用结构化编程函数abi.encodeWithSignature获得：</p>
<pre><code class="hljs language-arduino" lang="arduino">abi.<span class="hljs-built_in">encodeWithSignature</span>(<span class="hljs-string">"函数签名"</span>,逗号分隔的具体参数)

函数签名为 “函数名（逗号分隔的参数类型）”。 例如abi.<span class="hljs-built_in">encodeWithSignature</span>(<span class="hljs-string">"f(uint256,address)"</span>,_x,_addr)
</code></pre>
<p>另外call在调用合约时可以指定交易发送的ETH数额和gas数额：</p>
<pre><code class="hljs language-css" lang="css">目标合约地址<span class="hljs-selector-class">.call</span>{value:发送数额，gas:gas数额}(字节码);
</code></pre>
<h4 data-id="heading-12">案例</h4>
<p>目标合约</p>
<pre><code class="hljs language-solidity" lang="solidity">contract OtherContract {
//                    返回值含义                   单位     类型
//msg.value	          调用函数时附带转入的 ETH 数量	   wei	 uint256
//address(this).balance	     合约当前的 ETH 余额	  wei	uint256
//gasleft()         执行到当前行的剩余可使用 Gas 量    gas 	uint256

    uint256 private _x = 0; // 状态变量x
    // 收到eth的事件，记录amount和gas
    event Log(uint amount, uint gas);X
    
    fallback() external payable{}

    // 返回合约ETH余额
    function getBalance() view public returns(uint) {
        return address(this).balance;
    }

    // 可以调整状态变量_x的函数，并且可以往合约转ETH (payable)
    function setX(uint256 x) external payable{
        _x = x;
        // 如果转入ETH，则释放Log事件
        if(msg.value &gt; 0){
            emit Log(msg.value, gasleft());
        }
    }

    // 读取x
    function getX() external view returns(uint x){
        x = _x;
    }
}
</code></pre>
<h4 data-id="heading-13">利用call调用目标合约</h4>
<pre><code class="hljs language-solidity" lang="solidity">contract call {
    // 定义Response事件，输出call返回的结果success和data
    event Response(bool success, bytes data);

    function callSetX(address payable _addr, uint256 x) public payable {
    // call setX()，同时可以发送ETH
    (bool success, bytes memory data) = _addr.call{value: msg.value}(
        abi.encodeWithSignature("setX(uint256)", x)
    );

    emit Response(success, data); //释放事件
}
    function callGetX(address _addr) external returns(uint256){
    // call getX()
    (bool success, bytes memory data) = _addr.call(
        abi.encodeWithSignature("getX()")
    );

    emit Response(success, data); //释放事件
    return abi.decode(data, (uint256));
}

function callNonExist(address _addr) external{
    // call 不存在的函数
    (bool success, bytes memory data) = _addr.call(
        abi.encodeWithSignature("foo(uint256)")
    );

    emit Response(success, data); //释放事件
}

}
</code></pre>
<h5 data-id="heading-14">1.调用setX函数</h5>
<p>调用callSetX把状态变量_x改为5，参数为OtherContract地址和5，由于目标函数setX()没有返回值，因此Response事件输出的data为0x，也就是空。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/36c4f63f5c034ab3a687b68688f0396c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdW50dXJu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771148048&amp;x-signature=AEYNMbe%2FW5vMwlhgqqWTEigxRwo%3D" alt="22-1" loading="lazy"/></p>
<h5 data-id="heading-15">2.调用getX函数</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b320896f3884d3e820d3c4ad1775b65~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdW50dXJu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771148048&amp;x-signature=HTboQov9LFNoClQmu7AxIX6%2BRFY%3D" alt="img" loading="lazy"/></p>
<h5 data-id="heading-16">4.调用不存在的函数</h5>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6243fc0a708b40deb9eb9c0684d7cb0d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgdW50dXJu:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771148048&amp;x-signature=4z%2FdtqGDH96zHO8v46awCayHvMQ%3D" alt="22-3" loading="lazy"/></p>
<p>上面例子中，我们call了不存在的foo函数。call仍能执行成功，并返回success，但其实调用的目标合约fallback函数。</p>
<h3 data-id="heading-17">8、delegatecall</h3>



































<table><thead><tr><th>特性</th><th><code>call</code>（普通外部调用）</th><th><code>delegatecall</code>（委托调用）</th></tr></thead><tbody><tr><td><strong>存储（Storage）</strong></td><td>执行目标合约的代码，读写<strong>目标合约</strong>的存储</td><td>执行目标合约的代码，读写<strong>当前合约</strong>的存储</td></tr><tr><td><strong>上下文（Context）</strong></td><td><code>msg.sender</code> = 当前合约地址；<code>msg.value</code> 传递</td><td><code>msg.sender</code> = 原始调用者地址；<code>msg.value</code> 保留</td></tr><tr><td><strong>代码归属</strong></td><td>执行的是目标合约的代码，逻辑归属目标合约</td><td>执行的是目标合约的代码，逻辑归属当前合约</td></tr><tr><td><strong>核心用途</strong></td><td>普通调用外部合约功能（如调用 ERC20 转账）</td><td>代码复用、可升级合约（代理模式）</td></tr><tr><td><strong>存储布局要求</strong></td><td>无强制要求（目标合约自有存储）</td><td>严格匹配（当前合约与逻辑合约存储槽位需一致）</td></tr></tbody></table>
<h4 data-id="heading-18">1.逻辑合约（被调用方：提供代码逻辑）</h4>
<pre><code class="hljs language-solidity" lang="solidity">pragma solidity ^0.8.20;

// 逻辑合约：只提供代码，不存储数据
contract LogicContract {
    // 注意：变量的顺序/类型必须和调用合约完全匹配（存储槽位对应）
    uint public num;       // 存储槽位 0
    address public sender; // 存储槽位 1

    // 修改状态的函数
    function setVars(uint _num) public {
        num = _num;
        // delegatecall 中，msg.sender 是「外部调用者」，而非调用合约地址
        sender = msg.sender;
    }

    // 纯计算函数（无状态修改）
    function add(uint a, uint b) public pure returns (uint) {
        return a + b;
    }
}
</code></pre>
<h4 data-id="heading-19">2.调用合约（调用方：提供存储，借用逻辑）</h4>
<pre><code class="hljs language-solidity" lang="solidity">pragma solidity ^0.8.20;

// 调用合约：存储数据，通过 delegatecall 借用 LogicContract 的逻辑
contract CallerContract {
    // 存储布局必须和 LogicContract 完全一致！（顺序、类型）
    uint public num;       // 存储槽位 0
    address public sender; // 存储槽位 1
    address public logicAddr; // 保存逻辑合约地址

    // 设置逻辑合约地址
    function setLogicAddr(address _logic) public {
        logicAddr = _logic;
    }

    // 用 delegatecall 调用 LogicContract 的 setVars 函数
    function delegateSetVars(uint _num) public returns (bool, bytes memory) {
        // delegatecall 语法：目标地址.delegatecall(ABI编码的函数调用)
        (bool success, bytes memory data) = logicAddr.delegatecall(
            abi.encodeWithSignature("setVars(uint256)", _num)
        );
        return (success, data); // 返回调用结果和数据
    }

    // 用 delegatecall 调用 LogicContract 的 add 函数
    function delegateAdd(uint a, uint b) public returns (bool, bytes memory) {
        (bool success, bytes memory data) = logicAddr.delegatecall(
            abi.encodeWithSignature("add(uint256,uint256)", a, b)
        );
        return (success, data);
    }
}
</code></pre>
<h4 data-id="heading-20">3. 测试步骤与效果</h4>
<ol>
<li>部署 <code>LogicContract</code>，记录其地址（如 <code>0x123...</code>）；</li>
<li>部署 <code>CallerContract</code>，调用 <code>setLogicAddr(0x123...)</code> 关联逻辑合约；</li>
<li>调用 <code>delegateSetVars(100)</code>，然后查询 <code>CallerContract</code> 的 <code>num</code> → 结果为 <code>100</code>（数据存在 CallerContract 中）；</li>
<li>查询 <code>CallerContract</code> 的 <code>sender</code> → 结果为<strong>你的钱包地址</strong>（而非 CallerContract 地址，保留了原始上下文）；</li>
<li>调用 <code>delegateAdd(5, 3)</code>，解码返回的 <code>data</code> → 结果为 <code>8</code>（复用了 LogicContract 的计算逻辑）。</li>
</ol>
<h4 data-id="heading-21">4.代理合约案例</h4>
<pre><code class="hljs language-solidity" lang="solidity">contract Proxy{
	address public implementation;
	address public owner;
	
	constructor(address _logic){
		implementation = _logic;
		owner = msg.sender;
	}
	
	modifier onlyOnwner(){
	 	require(msg.sender == owner, "Proxy: not owner");
	 	_;
	}
	
	function upgradeTo(address _newLogic) public onlyOwner{
		implementation = _newLogic;
	}
	
	//回退函数：调用代理合约不存在的函数时，自动转发给逻辑合约
	fallback() external payable {
		(bool success,) implementation.delegatecall(msg.data);
        require(success, "Proxy: delegatecall failed");
	}
	
    // 接收 ETH
    receive() external payable {}
}

pragma solidity ^0.8.20;

// 逻辑合约 V1：实现基础功能
contract LogicV1 {
    // 存储布局必须和 Proxy 完全匹配（新增变量只能加在末尾）
    address public implementation; // 存储槽位 0
    address public owner;          // 存储槽位 1
    uint public count;             // 存储槽位 2（新增状态）

    // 计数+1
    function increment() public {
        count += 1;
    }

    // 获取计数
    function getCount() public view returns (uint) {
        return count;
    }
}

pragma solidity ^0.8.20;

// 逻辑合约 V2：在 V1 基础上新增功能
contract LogicV2 {
    // 存储布局必须和 Proxy/LogicV1 完全一致！
    address public implementation; // 存储槽位 0
    address public owner;          // 存储槽位 1
    uint public count;             // 存储槽位 2

    // 保留 V1 功能
    function increment() public {
        count += 1;
    }

    // 新增功能：计数-1
    function decrement() public {
        require(count &gt; 0, "LogicV2: count is zero");
        count -= 1;
    }

    // 保留 V1 功能
    function getCount() public view returns (uint) {
        return count;
    }
}
</code></pre>
<ol>
<li>部署 <code>LogicV1</code>，得到地址 <code>LogicV1Addr</code>；</li>
<li>部署 <code>Proxy</code>，传入 <code>LogicV1Addr</code> 作为初始逻辑合约；</li>
<li>调用 <code>Proxy.increment()</code> → 调用 <code>Proxy.getCount()</code> 得到 <code>1</code>（状态存在 Proxy 中）；</li>
<li>部署 <code>LogicV2</code>，得到地址 <code>LogicV2Addr</code>；</li>
<li>调用 <code>Proxy.upgradeTo(LogicV2Addr)</code>（仅 owner 可操作），完成升级；</li>
<li>调用 <code>Proxy.decrement()</code> → 调用 <code>Proxy.getCount()</code> 得到 <code>0</code>（新增功能生效，状态未丢失）。</li>
</ol>
<h3 data-id="heading-22">9、在合约中创建新合约（工厂合约）</h3>
<p>工厂合约是<strong>专门用于部署其他合约（称为「子合约 / 目标合约」）的智能合约</strong>，它的核心职责是：</p>
<ol>
<li>封装子合约的部署逻辑（比如用 <code>new</code> 关键字）；</li>
<li>对外提供统一的部署接口；</li>
<li>通常会记录所有已部署的子合约地址（方便管理 / 追溯）。</li>
</ol>
<p>create的用法很简单，就是new一个合约，并传入新合约构造函数所需的参数：</p>
<p>Contract x = new Contract{value: _value}(params)
其中Contract是要创建的合约名，x是合约对象（地址），如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。</p>
<h4 data-id="heading-23">1.目标合约</h4>
<p>核心功能：存储用户名、记录合约部署者（即工厂合约地址），支持修改用户名，无构造函数。</p>
<pre><code class="hljs language-solidity" lang="solidity">pragma solidity ^0.8.20;

// 用户信息合约（无构造函数，基础状态读写）
contract UserInfoContract {
    // 状态变量：用户名 + 部署者（工厂合约地址）
    string public userName;
    address public deployer; // 部署该合约的工厂合约地址

    // 初始化函数：设置用户名 + 记录部署者（首次调用）
    function initUser(string memory _userName) public {
        // 仅允许首次初始化（避免重复修改部署者）
        require(deployer == address(0), "UserInfo: already initialized");
        userName = _userName;
        deployer = msg.sender; // msg.sender = 工厂合约地址
    }

    // 修改用户名（任意地址可调用，仅演示基础功能）
    function updateUserName(string memory _newName) public {
        userName = _newName;
    }

    // 批量获取信息（简化调用）
    function getUserInfo() public view returns (string memory, address) {
        return (userName, deployer);
    }
}
</code></pre>
<h4 data-id="heading-24">2.工厂合约</h4>
<p>专门部署 <code>UserInfoContract</code> 的合约</p>
<pre><code class="hljs language-solidity" lang="solidity">pragma solidity ^0.8.20;

import "./UserInfoContract.sol";

// 典型的工厂合约结构
contract UserInfoFactory {
    // 特征1：记录所有已部署的子合约地址（可追溯、易管理）
    address[] public deployedUserContracts;

    // 特征2：对外提供统一的部署接口（封装部署逻辑）
    function deployUserContract() public returns (address) {
        // 核心：用 new 部署子合约（工厂合约的核心动作）
        UserInfoContract newUserContract = new UserInfoContract();
        // 特征3：记录新部署的子合约地址
        deployedUserContracts.push(address(newUserContract));
        // 特征4：返回子合约地址（方便调用方直接使用）
        return address(newUserContract);
    }

    // 特征5：辅助管理函数（查看部署数量）
    function getDeployedCount() public view returns (uint) {
        return deployedUserContracts.length;
    }
}
</code></pre>
<p>步骤 1：部署工厂合约</p>
<p>步骤 2：用工厂部署 UserInfoContract</p>
<ol>
<li>在 <code>UserInfoFactory</code> 实例中，找到 <code>deployUserContract</code> 函数，点击「transact」；</li>
<li>交易成功后，复制返回的 <code>UserInfoContract</code> 地址（如 <code>0x8A791620dd6260079BF849Dc5567aDC3F2FdC318</code>）；</li>
<li>验证：调用 <code>UserInfoFactory</code> 的 <code>getDeployedCount()</code>，返回 <code>1</code>（表示已部署 1 个合约）；调用 <code>deployedUserContracts(0)</code>，返回上述复制的地址（验证记录成功）。</li>
</ol>
<p>步骤 3：操作并验证 UserInfoContract</p>
<ol>
<li>在「Deploy &amp; Run Transactions」的「At Address」输入框粘贴步骤 4 复制的地址，「Contract」下拉框选择 <code>UserInfoContract</code>，点击「At Address」加载合约实例；</li>
<li>初始化用户信息
<ul>
<li>调用 <code>initUser</code> 函数，参数输入你的用户名（如 <code>"Alice"</code>），点击「transact」；</li>
<li>调用 <code>getUserInfo</code> 函数，点击「call」，返回结果为 <code>("Alice", 工厂合约地址)</code>（验证部署者和用户名设置成功）；</li>
</ul>
</li>
<li>修改用户名
<ul>
<li>调用 <code>updateUserName</code> 函数，参数输入 <code>"Bob"</code>，点击「transact」；</li>
<li>再次调用 <code>getUserInfo</code>，返回 <code>("Bob", 工厂合约地址)</code>（验证用户名修改成功）；</li>
</ul>
</li>
<li><strong>重复初始化验证</strong>：再次调用 <code>initUser("Charlie")</code>，交易会失败（提示 <code>UserInfo: already initialized</code>，验证初始化仅允许一次）。</li>
</ol>
<h4 data-id="heading-25">3.工厂合约的 5 个核心特征（对应案例）</h4>



































<table><thead><tr><th>特征</th><th>案例中的体现</th><th>实际价值</th></tr></thead><tbody><tr><td>1. 封装部署逻辑</td><td>所有部署 <code>UserInfoContract</code> 的逻辑都在 <code>deployUserContract</code> 中</td><td>调用方无需知道「怎么部署」，只需调用函数即可</td></tr><tr><td>2. 批量部署</td><td>多次调用 <code>deployUserContract</code> 可创建多个 <code>UserInfoContract</code> 实例</td><td>一键批量生成同款合约，无需重复部署工厂</td></tr><tr><td>3. 可追溯</td><td><code>deployedUserContracts</code> 数组记录所有子合约地址</td><td>随时查看 / 管理所有已部署的子合约</td></tr><tr><td>4. 标准化</td><td>所有子合约都基于同一版 <code>UserInfoContract</code> 代码</td><td>避免手动部署时的代码版本不一致</td></tr><tr><td>5. 简化调用</td><td>返回子合约地址，调用方直接用 <code>At Address</code> 加载</td><td>无需手动复制字节码、处理底层部署细节</td></tr></tbody></table>
<h3 data-id="heading-26">10、create2</h3>
<h4 data-id="heading-27">1.CREATE2 vs CREATE（new）核心对比</h4>



































<table><thead><tr><th>特性</th><th><code>CREATE2</code></th><th><code>CREATE</code>（<code>new</code> 底层）</th></tr></thead><tbody><tr><td>地址生成依据</td><td>工厂地址 + salt + 子合约字节码哈希</td><td>工厂地址 + 工厂 nonce（部署次数）</td></tr><tr><td>地址可预测性</td><td>✅ 部署前可精确计算</td><td>❌ 不可预测（nonce 随部署变化）</td></tr><tr><td>Solidity 封装语法</td><td><code>new 合约名{salt: _salt}()</code></td><td><code>new 合约名()</code></td></tr><tr><td>核心优势</td><td>地址确定、提前规划</td><td>简单、无需自定义 salt</td></tr><tr><td>适用场景</td><td>需提前知地址的场景（跨链、DEX）</td><td>普通批量部署（无地址预判需求）</td></tr></tbody></table>
<h4 data-id="heading-28">2.案例</h4>
<ol>
<li>
<p>子合约（保持不变，复用之前的 <code>UserInfoContract</code>）</p>
</li>
<li>
<p><code>CREATE2</code> 工厂合约（核心）</p>
</li>
</ol>
<pre><code class="hljs language-solidity" lang="solidity">pragma solidity ^0.8.20;

import "./UserInfoContract.sol";

// CREATE2 版本的用户信息合约工厂（支持预计算地址）
contract UserInfoFactoryCreate2 {
    // 记录已部署的子合约（salt =&gt; 合约地址），方便追溯
    mapping(uint256 =&gt; address) public saltToContract;

    // ========== 核心1：用 CREATE2 部署子合约（高级封装方式） ==========
    function deployWithCREATE2(uint256 _salt) public returns (address) {
        // 语法：new 合约名{salt: 盐值}() —— 底层调用 CREATE2
        UserInfoContract newUserContract = new UserInfoContract{salt: bytes(_salt)}();
        address contractAddr = address(newUserContract);
        
        // 记录 salt 和合约地址的映射
        saltToContract[_salt] = contractAddr;
        
        return contractAddr;
    }

    // ========== 核心2：预计算合约地址（部署前就能知道地址） ==========
    function computeContractAddress(uint256 _salt) public view returns (address) {
        // 步骤1：获取子合约的初始化字节码（编译后生成，固定值）
        bytes memory bytecode = type(UserInfoContract).creationCode;
        // 步骤2：计算字节码的 keccak256 哈希
        bytes32 bytecodeHash = keccak256(bytecode);
        
        // 步骤3：按 CREATE2 地址规则计算（核心公式）
        address predictedAddr = address(
            uint160( // 转成 160 位地址格式
                uint256(
                    keccak256(
                        abi.encodePacked(
                            bytes1(0xff), // 固定前缀
                            address(this), // 工厂合约地址
                            _salt, // 盐值
                            bytecodeHash // 子合约字节码哈希
                        )
                    )
                )
            )
        );
        
        return predictedAddr;
    }
}
</code></pre>
<p>步骤 1：部署 <code>CREATE2</code> 工厂合约</p>
<p>步骤 3：预计算子合约地址（核心验证）</p>
<ol>
<li>在工厂合约实例中，找到 <code>computeContractAddress</code> 函数，输入 salt 值 <code>12345</code>，点击「call」；</li>
<li>记录返回的<strong>预计算地址</strong>（比如 <code>0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199</code>）；</li>
<li>此时该地址还未部署任何合约（只是预计算结果）。</li>
</ol>
<p>步骤 4：用 <code>CREATE2</code> 部署子合约（验证地址一致）</p>
<ol>
<li>在工厂合约实例中，找到 <code>deployWithCREATE2</code> 函数，输入相同的 salt 值 <code>12345</code>，点击「transact」；</li>
<li>交易成功后，复制返回的<strong>实际部署地址</strong>；</li>
<li>对比「预计算地址」和「实际部署地址」—— 两者完全一致（<code>CREATE2</code> 核心优势体现）。</li>
</ol>
<p>步骤 5：验证子合约功能</p>
<ol>
<li>在「At Address」输入实际部署地址，选择 <code>UserInfoContract</code>，加载合约实例；</li>
<li>调用 <code>initUser("Charlie")</code>，再调用 <code>getUserInfo()</code> → 返回 <code>("Charlie", 工厂合约地址)</code>；</li>
<li>调用 <code>updateUserName("Dave")</code> → 验证用户名修改成功。</li>
</ol>
<h3 data-id="heading-29">11、删除合约</h3>
<h4 data-id="heading-30">1、销毁合约的核心原理（<code>selfdestruct</code>）</h4>
<p>Solidity 中销毁合约的唯一方式是调用 <code>selfdestruct(address payable recipient)</code>（旧称 <code>suicide</code>，已废弃），这是 EVM 级别的低级操作，核心特性如下：</p>
<ol>
<li>核心行为
<ul>
<li>永久销毁当前合约的<strong>代码</strong>和<strong>存储数据</strong>（所有状态变量被清空，无法恢复）；</li>
<li>将合约账户中剩余的所有 ETH 转移到指定的 <code>recipient</code> 地址；</li>
<li>合约地址不会消失，但地址对应的代码 / 存储被清空，后续调用该地址的任何函数都会失败。</li>
</ul>
</li>
<li><strong>权限要求</strong>：仅能由合约<strong>自身</strong>调用（或通过合约内的函数间接调用，需加权限控制）；</li>
<li><strong>不可逆性</strong>：销毁后无法恢复，是永久性操作，需谨慎使用。</li>
</ol>
<h4 data-id="heading-31">2.案例</h4>
<p>可销毁的子合约（<code>DestructibleUserInfo</code>）</p>
<pre><code class="hljs language-solidity" lang="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract DestructibleUserInfo {
    string public userName;
    address public deployer;
    bool public isDestroyed;

    modifier onlyDeployer() {
        require(msg.sender == deployer, "Only deploy can call");
        _;
    }

    modifier notDestroyed() {
        require(!isDestroyed, "Contract already destroyed");
        _;
    }

    function updateUserName(string memory _newName) public notDestroyed {
        userName = _newName;
    }

    function getUserInfo() public view returns (string memory, address){
        return (userName,deployer);
    }

    function destroyContract(address payable  _recipient) public onlyDeployer notDestroyed {
        isDestroyed = true;
        selfdestruct(_recipient);
    }

    receive() external payable {}
}
</code></pre>
<ol start="2">
<li>管理销毁的工厂合约（<code>DestructibleUserInfoFactory</code>）</li>
</ol>
<pre><code class="hljs language-solidity" lang="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./DestructibleUserInfo.sol";

// 工厂合约：部署+销毁 可销毁的用户信息合约
contract DestructibleUserInfoFactory {
    // 记录已部署的子合约地址（防止销毁后误操作）
    address[] public deployedContracts;
    // 标记子合约是否已销毁
    mapping(address =&gt; bool) public isContractDestroyed;

      // 部署并初始化子合约（让工厂成为 deployer）
    function deployAndInitContract(string memory _userName) public returns (address) {
        DestructibleUserInfo newContract = new DestructibleUserInfo();
        // 工厂合约调用 initUser → 子合约的 deployer = 工厂地址
        newContract.initUser(_userName); 
        deployedContracts.push(address(newContract));
        return address(newContract);
    }

    // 工厂触发子合约销毁（核心：调用子合约的destroyContract）
    function destroyUserContract(address payable _contractAddr, address payable _recipient) public {
        // 检查合约是否由本工厂部署
        bool isDeployed = false;
        for (uint i = 0; i &lt; deployedContracts.length; i++) {
            if (deployedContracts[i] == _contractAddr) {
                isDeployed = true;
                break;
            }
        }
        require(isDeployed, "Contract not deployed by this factory");
        // 检查合约未被销毁
        require(!isContractDestroyed[_contractAddr], "Contract already destroyed");

        // 现在类型匹配，编译通过
        DestructibleUserInfo(_contractAddr).destroyContract(_recipient);
        // 标记销毁状态
        isContractDestroyed[_contractAddr] = true;
    }

    // 给子合约转ETH（测试销毁时的ETH转移）
    function sendEthToContract(address _contractAddr) public payable {
        require(msg.value &gt; 0, "ETH amount must be &gt; 0");
        (bool success, ) = _contractAddr.call{value: msg.value}("");
        require(success, "ETH transfer failed");
    }
}
</code></pre>
<p>步骤 1：部署工厂合约</p>
<ol>
<li>在 Remix 中选择 <strong>DestructibleUserInfoFactory</strong> 合约</li>
<li>点击「Deploy」按钮部署合约</li>
<li>等待交易确认，获得工厂合约地址</li>
</ol>
<p>步骤 2：调用工厂的 deployAndInitContract</p>
<ol>
<li>在已部署的工厂合约界面，找到 <code>deployAndInitContract</code> 函数</li>
<li>输入参数 <code>_userName: "TestFactory"</code></li>
<li>点击「transact」执行交易</li>
<li>等待交易成功，复制返回的子合约地址</li>
</ol>
<p>步骤 3：验证子合约 deployer</p>
<ol>
<li>在 Remix 的「At Address」输入框中粘贴子合约地址</li>
<li>从下拉菜单中选择 <strong>DestructibleUserInfo</strong> 合约类型</li>
<li>点击「At Address」按钮加载子合约</li>
<li>调用子合约的 <code>deployer()</code> 函数</li>
<li>验证返回的地址是否为工厂合约地址</li>
</ol>
<p>步骤 4：测试工厂销毁子合约</p>
<p>4.1 向子合约发送 ETH</p>
<ol>
<li>调用工厂的 <code>sendEthToContract</code> 函数</li>
<li>参数 <code>_contractAddr</code>: 粘贴子合约地址</li>
<li>在 Value 字段输入 <code>1</code></li>
<li>单位选择 <strong>ether</strong></li>
<li>点击「transact」执行交易</li>
</ol>
<p>4.2 销毁子合约</p>
<ol>
<li>调用工厂的 <code>destroyUserContract</code> 函数</li>
<li>参数 <code>_contractAddr</code>: 子合约地址（payable 类型）</li>
<li>参数 <code>_recipient</code>: 你的钱包地址</li>
<li>点击「transact」执行交易</li>
<li>等待交易成功确认</li>
</ol>
<h3 data-id="heading-32">12、ABI编码解码</h3>
<p><code>ABI</code> (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。数据基于他们的类型编码；并且由于编码后不包含类型信息，解码时需要注明它们的类型。</p>
<p><code>Solidity</code>中，<code>ABI编码</code>有4个函数：<code>abi.encode</code>, <code>abi.encodePacked</code>, <code>abi.encodeWithSignature</code>, <code>abi.encodeWithSelector</code>。而<code>ABI解码</code>有1个函数：<code>abi.decode</code>，用于解码<code>abi.encode</code>的数据。</p>
<h4 data-id="heading-33">ABI编码</h4>
<p>我们将编码4个变量，他们的类型分别是<code>uint256</code>（别名 uint）, <code>address</code>, <code>string</code>, <code>uint256[2]</code>：</p>
<pre><code class="hljs language-solidity" lang="solidity">uint x = 10;
address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;
string name = "0xAA";
uint[2] array = [5, 6];
</code></pre>
<h5 data-id="heading-34"><code>abi.encode</code></h5>
<p>将给定参数利用<a href="https://link.juejin.cn?target=https%3A%2F%2Flearnblockchain.cn%2Fdocs%2Fsolidity%2Fabi-spec.html" target="_blank" title="https://learnblockchain.cn/docs/solidity/abi-spec.html" ref="nofollow noopener noreferrer">ABI规则</a>编码。<code>ABI</code>被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是<code>abi.encode</code>。</p>
<pre><code class="hljs language-solidity" lang="solidity">function encode() public view returns(bytes memory result) {
    result = abi.encode(x, addr, name, array);
}
</code></pre>
<p>编码的结果为<code>0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，详细解释下编码的细节：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-number">000000000000000000000000000000000000000000000000000000000000000</span>a    <span class="hljs-comment">// x</span>
<span class="hljs-number">0000000000000000000000007</span>a58c0be72be218b41c608b7fe7c5bb630736c71    <span class="hljs-comment">// addr</span>
<span class="hljs-number">00000000000000000000000000000000000000000000000000000000000000</span>a0    <span class="hljs-comment">// name 参数的偏移量</span>
<span class="hljs-number">0000000000000000000000000000000000000000000000000000000000000005</span>    <span class="hljs-comment">// array[0]</span>
<span class="hljs-number">0000000000000000000000000000000000000000000000000000000000000006</span>    <span class="hljs-comment">// array[1]</span>
<span class="hljs-number">0000000000000000000000000000000000000000000000000000000000000004</span>    <span class="hljs-comment">// name 参数的长度为4字节</span>
<span class="hljs-number">3078414100000000000000000000000000000000000000000000000000000000</span>    <span class="hljs-comment">// name</span>
</code></pre>
<p>其中 <code>name</code> 参数被转换为UTF-8的字节值 <code>0x30784141</code>，在 abi 编码规范中，string 属于动态类型 ，动态类型的参数需要借助偏移量进行编码，可以参考<a href="https://link.juejin.cn?target=https%3A%2F%2Flearnblockchain.cn%2Fdocs%2Fsolidity%2Fabi-spec.html%23id9" target="_blank" title="https://learnblockchain.cn/docs/solidity/abi-spec.html#id9" ref="nofollow noopener noreferrer">动态类型的使用</a>。由于 abi.encode 会将每个参与编码的参数元素（包括偏移量，长度）都填充为32字节（evm字长为32字节），所以可以看到编码后的数据中有很多填充的 0 。</p>
<h5 data-id="heading-35"><code>abi.encodePacked</code></h5>
<p>将给定参数根据其所需最低空间编码。它类似 <code>abi.encode</code>，但是会把其中填充的很多<code>0</code>省略。比如，只用1字节来编码<code>uint8</code>类型。当你想省空间，并且不与合约交互的时候，可以使用<code>abi.encodePacked</code>，例如算一些数据的<code>hash</code>时。需要注意，<code>abi.encodePacked</code>因为不会做填充，所以不同的输入在拼接后可能会产生相同的编码结果，导致冲突，这也带来了潜在的安全风险。</p>
<pre><code class="hljs language-solidity" lang="solidity">function encodePacked() public view returns(bytes memory result) {
    result = abi.encodePacked(x, addr, name, array);
}
</code></pre>
<p>编码的结果为<code>0x000000000000000000000000000000000000000000000000000000000000000a7a58c0be72be218b41c608b7fe7c5bb630736c713078414100000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000006</code>，由于<code>abi.encodePacked</code>对编码进行了压缩，长度比<code>abi.encode</code>短很多。</p>
<h5 data-id="heading-36"><code>abi.encodeWithSignature</code></h5>
<p>与<code>abi.encode</code>功能类似，只不过第一个参数为<code>函数签名</code>，比如<code>"foo(uint256,address,string,uint256[2])"</code>。当调用其他合约的时候可以使用。</p>
<pre><code class="hljs language-solidity" lang="solidity">function encodeWithSignature() public view returns(bytes memory result) {
    result = abi.encodeWithSignature("foo(uint256,address,string,uint256[2])", x, addr, name, array);
}
</code></pre>
<p>编码的结果为<code>0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，等同于在<code>abi.encode</code>编码结果前加上了4字节的<code>函数选择器</code><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.wtf.academy%2Fzh%2Fcourse%2Fsolidity102%2FABIEncode%23user-content-fn-%25E8%25AF%25B4%25E6%2598%258E" target="_blank" title="https://www.wtf.academy/zh/course/solidity102/ABIEncode#user-content-fn-%E8%AF%B4%E6%98%8E" ref="nofollow noopener noreferrer">1</a>。</p>
<h5 data-id="heading-37"><code>abi.encodeWithSelector</code></h5>
<p>与<code>abi.encodeWithSignature</code>功能类似，只不过第一个参数为<code>函数选择器</code>，为<code>函数签名</code>Keccak哈希的前4个字节。</p>
<pre><code class="hljs language-solidity" lang="solidity">function encodeWithSelector() public view returns(bytes memory result) {
    result = abi.encodeWithSelector(bytes4(keccak256("foo(uint256,address,string,uint256[2])")), x, addr, name, array);
}
</code></pre>
<p>编码的结果为<code>0xe87082f1000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000</code>，与<code>abi.encodeWithSignature</code>结果一样。</p>
<h4 data-id="heading-38">ABI解码</h4>
<h4 data-id="heading-39"><code>abi.decode</code></h4>
<p><code>abi.decode</code>用于解码<code>abi.encode</code>生成的二进制编码，将它还原成原本的参数。</p>
<pre><code class="hljs language-solidity" lang="solidity">function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) {
    (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));
}
</code></pre>
<h4 data-id="heading-40">代码</h4>
<pre><code class="hljs language-solidity" lang="solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

contract ABIEncode{
    uint x = 10;
    address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71;
    string name = "0xAA";
    uint[2] array = [5, 6]; 

    function encode() public view returns(bytes memory result) {
        result = abi.encode(x, addr, name, array);
    }

    function encodePacked() public view returns(bytes memory result) {
        result = abi.encodePacked(x, addr, name, array);
    }

    function encodeWithSignature() public view returns(bytes memory result) {
        result = abi.encodeWithSignature("foo(uint256,address,string,uint256[2])", x, addr, name, array);
    }

    function encodeWithSelector() public view returns(bytes memory result) {
        result = abi.encodeWithSelector(bytes4(keccak256("foo(uint256,address,string,uint256[2])")), x, addr, name, array);
    }
    function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) {
        (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2]));
    }
}
</code></pre>
<h3 data-id="heading-41">13.选择器</h3>
<h4 data-id="heading-42">1.msg.data</h4>
<p><code>msg.data</code>是<code>Solidity</code>中的一个全局变量，值为完整的<code>calldata</code>（调用函数时传入的数据）。</p>
<p>在下面的代码中，我们可以通过<code>Log</code>事件来输出调用<code>mint</code>函数的<code>calldata</code>：</p>
<pre><code class="hljs language-solidity" lang="solidity">// event 返回msg.data
event Log(bytes data);

function mint(address to) external{
    emit Log(msg.data);
}
</code></pre>
<p>当参数为<code>0x2c44b726ADF1963cA47Af88B284C06f30380fC78</code>时，输出的<code>calldata</code>为</p>
<pre><code class="hljs">0x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78
</code></pre>
<p>这段很乱的字节码可以分成两部分：</p>
<pre><code class="hljs">前4个字节为函数选择器selector：
0x6a627842

后面32个字节为输入的参数：
0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78
</code></pre>
<p>其实<code>calldata</code>就是告诉智能合约，我要调用哪个函数，以及参数是什么。</p>
<h4 data-id="heading-43">2.method id、selector和函数签名</h4>
<p><code>method id</code>定义为<code>函数签名</code>的<code>Keccak</code>哈希后的前4个字节，当<code>selector</code>与<code>method id</code>相匹配时，即表示调用该函数，那么<code>函数签名</code>是什么？</p>
<p>函数签名，为<code>"函数名（逗号分隔的参数类型)"</code>举个例子，上面代码中<code>mint</code>的函数签名为<code>"mint(address)"</code>。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。</p>
<p><strong>注意</strong>，在函数签名中，<code>uint</code>和<code>int</code>要写为<code>uint256</code>和<code>int256</code>。</p>
<p>我们写一个函数，来验证<code>mint</code>函数的<code>method id</code>是否为<code>0x6a627842</code>。大家可以运行下面的函数，看看结果。</p>
<pre><code class="hljs language-solidity" lang="solidity">function mintSelector() external pure returns(bytes4 mSelector){
    return bytes4(keccak256("mint(address)"));
}
</code></pre>
<p>结果正是0x6a627842</p>
<p>由于计算<code>method id</code>时，需要通过函数名和函数的参数类型来计算。在<code>Solidity</code>中，函数的参数类型主要分为：基础类型参数，固定长度类型参数，可变长度类型参数和映射类型参数。</p>
<h5 data-id="heading-44">基础类型参数</h5>
<p><code>solidity</code>中，基础类型的参数有：<code>uint256</code>(<code>uint8</code>, ... , <code>uint256</code>)、<code>bool</code>, <code>address</code>等。在计算<code>method id</code>时，只需要计算<code>bytes4(keccak256("函数名(参数类型1,参数类型2,...)"))</code>。例如，如下函数，函数名为<code>elementaryParamSelector</code>，参数类型分别为<code>uint256</code>和<code>bool</code>。所以，只需要计算<code>bytes4(keccak256("elementaryParamSelector(uint256,bool)"))</code>便可得到此函数的<code>method id</code>。</p>
<pre><code class="hljs language-solidity" lang="solidity">// elementary（基础）类型参数selector
    // 输入：param1: 1，param2: 0
    // elementaryParamSelector(uint256,bool) : 0x3ec37834
    function elementaryParamSelector(uint256 param1, bool param2) external returns(bytes4 selectorWithElementaryParam){
        emit SelectorEvent(this.elementaryParamSelector.selector);
        return bytes4(keccak256("elementaryParamSelector(uint256,bool)"));
    }
</code></pre>
<h5 data-id="heading-45">固定长度类型参数</h5>
<p>固定长度的参数类型通常为固定长度的数组，例如：<code>uint256[5]</code>等。例如，如下函数<code>fixedSizeParamSelector</code>的参数为<code>uint256[3]</code>。因此，在计算该函数的<code>method id</code>时，只需要通过<code>bytes4(keccak256("fixedSizeParamSelector(uint256[3])"))</code>即可。</p>
<pre><code class="hljs language-solidity" lang="solidity">// fixed size（固定长度）类型参数selector
    // 输入： param1: [1,2,3]
    // fixedSizeParamSelector(uint256[3]) : 0xead6b8bd
    function fixedSizeParamSelector(uint256[3] memory param1) external returns(bytes4 selectorWithFixedSizeParam){
        emit SelectorEvent(this.fixedSizeParamSelector.selector);
        return bytes4(keccak256("fixedSizeParamSelector(uint256[3])"));
    }
</code></pre>
<h5 data-id="heading-46">可变长度类型参数</h5>
<p>可变长度参数类型通常为可变长的数组，例如：<code>address[]</code>、<code>uint8[]</code>、<code>string</code>等。例如，如下函数<code>nonFixedSizeParamSelector</code>的参数为<code>uint256[]</code>和<code>string</code>。因此，在计算该函数的<code>method id</code>时，只需要通过<code>bytes4(keccak256("nonFixedSizeParamSelector(uint256[],string)"))</code>即可。</p>
<pre><code class="hljs language-solidity" lang="solidity">// non-fixed size（可变长度）类型参数selector
    // 输入： param1: [1,2,3]， param2: "abc"
    // nonFixedSizeParamSelector(uint256[],string) : 0xf0ca01de
    function nonFixedSizeParamSelector(uint256[] memory param1,string memory param2) external returns(bytes4 selectorWithNonFixedSizeParam){
        emit SelectorEvent(this.nonFixedSizeParamSelector.selector);
        return bytes4(keccak256("nonFixedSizeParamSelector(uint256[],string)"));
    }
</code></pre>
<h5 data-id="heading-47">映射类型参数</h5>
<p>映射类型参数通常有：<code>contract</code>、<code>enum</code>、<code>struct</code>等。在计算<code>method id</code>时，需要将该类型转化成为<code>ABI</code>类型。</p>
<p>例如，如下函数<code>mappingParamSelector</code>中<code>DemoContract</code>需要转化为<code>address</code>，结构体<code>User</code>需要转化为<code>tuple</code>类型<code>(uint256,bytes)</code>，枚举类型<code>School</code>需要转化为<code>uint8</code>。因此，计算该函数的<code>method id</code>的代码为<code>bytes4(keccak256("mappingParamSelector(address,(uint256,bytes),uint256[],uint8)"))</code>。</p>
<pre><code class="hljs language-solidity" lang="solidity">contract DemoContract {
    // empty contract
}

contract Selector{
    // Struct User
    struct User {
        uint256 uid;
        bytes name;
    }
    // Enum School
    enum School { SCHOOL1, SCHOOL2, SCHOOL3 }
    ...
    // mapping（映射）类型参数selector
    // 输入：demo: 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99， user: [1, "0xa0b1"], count: [1,2,3], mySchool: 1
    // mappingParamSelector(address,(uint256,bytes),uint256[],uint8) : 0xe355b0ce
    function mappingParamSelector(DemoContract demo, User memory user, uint256[] memory count, School mySchool) external returns(bytes4 selectorWithMappingParam){
        emit SelectorEvent(this.mappingParamSelector.selector);
        return bytes4(keccak256("mappingParamSelector(address,(uint256,bytes),uint256[],uint8)"));
    }
    ...
}
</code></pre>
<h4 data-id="heading-48">3.使用selector</h4>
<p>我们可以利用<code>selector</code>来调用目标函数。例如我想调用<code>elementaryParamSelector</code>函数，我只需要利用<code>abi.encodeWithSelector</code>将<code>elementaryParamSelector</code>函数的<code>method id</code>作为<code>selector</code>和参数打包编码，传给<code>call</code>函数：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 使用selector来调用函数</span>
    function <span class="hljs-built_in">callWithSignature</span>() external{
	...
        <span class="hljs-comment">// 调用elementaryParamSelector函数</span>
        (bool success1, bytes memory data1) = <span class="hljs-selector-tag">address</span>(this)<span class="hljs-selector-class">.call</span>(abi.encodeWithSelector(<span class="hljs-number">0</span>x3ec37834, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));
	...
    }
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[corepack 作用]]></title>    <link>https://juejin.cn/post/7603769956975280169</link>    <guid>https://juejin.cn/post/7603769956975280169</guid>    <pubDate>2026-02-08T07:06:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603769956975280169" data-draft-id="7603677143214669839" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="corepack 作用"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-08T07:06:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="code_YuJun"/> <meta itemprop="url" content="https://juejin.cn/user/3615612462441358"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            corepack 作用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3615612462441358/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    code_YuJun
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T07:06:50.000Z" title="Sun Feb 08 2026 07:06:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    8
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><code>corepack</code> 可以把它理解成 <strong>Node.js 自带的“包管理器管理器”</strong> 。<br/>
<strong>corepack 用来管理和锁定项目使用的包管理器（比如 pnpm / yarn），而不是管理依赖本身。</strong></p>
<h2 data-id="heading-0">为什么会有 corepack</h2>
<p>以前的情况很乱：</p>
<ul>
<li>有的人用 <code>npm</code></li>
<li>有的人用 <code>yarn</code></li>
<li>有的人用 <code>pnpm</code></li>
<li>同一个项目里，不同人用的 <strong>包管理器版本还不一样</strong></li>
</ul>
<p>结果就是：</p>
<blockquote>
<p>“我这能跑，你那为啥装不起来？”</p>
</blockquote>
<p><code>corepack</code> 的出现，就是为了解决 <strong>“到底用哪个包管理器、用哪个版本”</strong> 这个问题。</p>
<h2 data-id="heading-1">corepack 能干什么</h2>
<h3 data-id="heading-2">1️⃣ 统一项目使用的包管理器</h3>
<p>在 <code>package.json</code> 里可以写：</p>
<pre><code class="hljs language-perl" lang="perl">{
  <span class="hljs-string">"packageManager"</span>: <span class="hljs-string">"pnpm@8.15.4"</span>
}
</code></pre>
<p>含义是：</p>
<blockquote>
<p>这个项目 <strong>必须</strong> 用 <code>pnpm</code>，而且版本是 <code>8.15.4</code></p>
</blockquote>
<p>这时候：</p>
<ul>
<li>你 <code>pnpm install</code></li>
<li>同事 <code>npm install</code></li>
<li>CI 里跑 <code>pnpm install</code></li>
</ul>
<p>👉 <strong>corepack 会自动帮你下载并使用正确版本的 pnpm</strong></p>
<p>不用大家手动装。</p>
<hr/>
<h3 data-id="heading-3">2️⃣ 自动安装 &amp; 切换 yarn / pnpm</h3>
<p>你甚至不需要提前全局装 pnpm：</p>
<pre><code class="hljs language-bash" lang="bash">corepack <span class="hljs-built_in">enable</span>
pnpm install
</code></pre>
<p>如果项目声明的是：</p>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-string">"packageManager"</span>: <span class="hljs-string">"yarn@3.6.1"</span>
</code></pre>
<p>corepack 会：</p>
<ul>
<li>自动下载 yarn 3.6.1</li>
<li>用它来执行命令</li>
</ul>
<p>你本地有没有 yarn 👉 <strong>不重要</strong></p>
<hr/>
<h3 data-id="heading-4">3️⃣ 防止“包管理器版本不一致”的坑</h3>
<p>比如：</p>
<ul>
<li>A 用 pnpm 7</li>
<li>B 用 pnpm 8</li>
<li>lock 文件结构都不一样</li>
</ul>
<p>corepack 可以 <strong>强制版本一致</strong>，从源头避免：</p>
<ul>
<li>lockfile 被反复改</li>
<li>CI 跑不过</li>
<li>“我这没问题啊”的玄学 bug</li>
</ul>
<hr/>
<h2 data-id="heading-5">corepack 和 npm / yarn / pnpm 的关系</h2>
<p>可以这么理解👇</p>
<pre><code class="hljs">corepack
  ├── 管理 pnpm
  ├── 管理 yarn
  └── 管理 npm（间接）
</code></pre>
<ul>
<li><strong>npm / yarn / pnpm</strong>：真正干活的</li>
<li><strong>corepack</strong>：负责“发工具、管版本、做协调”</li>
</ul>
<hr/>
<h2 data-id="heading-6">常用命令速览 🧠</h2>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 启用 corepack（Node 16+ 自带）</span>
corepack <span class="hljs-built_in">enable</span>

<span class="hljs-comment"># 查看当前 corepack 版本</span>
corepack --version

<span class="hljs-comment"># 指定并激活某个包管理器版本</span>
corepack prepare pnpm@8.15.4 --activate
</code></pre>
<hr/>
<h2 data-id="heading-7">什么时候一定要用 corepack</h2>
<p>非常推荐用在这些场景👇</p>
<ul>
<li>团队协作项目</li>
<li>monorepo（pnpm / yarn workspace）</li>
<li>CI / Docker / 线上构建</li>
<li>你已经被 “lockfile 一直变” 折磨过 😅</li>
</ul>
<hr/>
<h2 data-id="heading-8">一句话总结</h2>
<blockquote>
<p><strong>corepack 不是用来装依赖的，是用来“管包管理器的版本和使用权”的。</strong><br/>
它让“这个项目该用哪个包管理器、哪个版本”变成一件确定的事。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[pnpm-workspace.yaml]]></title>    <link>https://juejin.cn/post/7603781883973615635</link>    <guid>https://juejin.cn/post/7603781883973615635</guid>    <pubDate>2026-02-08T07:32:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603781883973615635" data-draft-id="7603644943351955462" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="pnpm-workspace.yaml"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-08T07:32:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="code_YuJun"/> <meta itemprop="url" content="https://juejin.cn/user/3615612462441358"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            pnpm-workspace.yaml
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3615612462441358/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    code_YuJun
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T07:32:43.000Z" title="Sun Feb 08 2026 07:32:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    3
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><code>pnpm-workspace.yaml</code> 是 <strong>pnpm 的“项目组织与调度中枢”</strong>，告诉 pnpm：哪些目录是同一个 workspace，以及这些包之间如何协同工作。</p>
<h2 data-id="heading-0">定义哪些包属于同一个仓库</h2>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">packages:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">packages/*</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">apps/*</span>
</code></pre>
<ul>
<li><code>packages/*</code> 下面每个有 <code>package.json</code> 的目录，都是一个包</li>
<li><code>apps/*</code> 下面每个 app 也是一个包</li>
</ul>
<h2 data-id="heading-1">Workspace 内包本地互相引用</h2>
<pre><code class="hljs language-js" lang="js">packages/
  utils/
  ui/
apps/
  admin/
</code></pre>
<p>在 <code>apps/admin/package.json</code> 里：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"@my/utils"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"workspace:*"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>效果是：</p>
<ul>
<li>不去 npm 下载</li>
<li>直接 <strong>软链接到本地 packages/utils</strong></li>
<li>改代码立刻生效</li>
</ul>
<p>这是 monorepo 的灵魂能力。</p>
<h2 data-id="heading-2">依赖统一安装、统一锁定</h2>
<p>在根目录执行<code>pnpm install</code><br/>
pnpm 会：</p>
<ul>
<li>扫描 <code>pnpm-workspace.yaml</code> 里的所有包</li>
<li>统一生成 <strong>一份 <code>pnpm-lock.yaml</code></strong></li>
<li>所有包共享同一个依赖树</li>
</ul>
<h2 data-id="heading-3">支持 catalog</h2>
<p>pnpm-workspace.yaml 里可以这样写：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">catalog:</span>
  <span class="hljs-attr">vite:</span> <span class="hljs-string">^5.1.0</span>
  <span class="hljs-attr">vue:</span> <span class="hljs-string">^3.4.0</span>
  <span class="hljs-attr">typescript:</span> <span class="hljs-string">^5.3.3</span>
</code></pre>
<p>子包中：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-attr">"devDependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"vite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"catalog:"</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"vue"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"catalog:"</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>版本集中管理，企业级工程标配.</p>
<h2 data-id="heading-4">支持 workspace 协议（workspace:*）</h2>
<pre><code class="hljs language-js" lang="js"><span class="hljs-string">"@my/ui"</span>: <span class="hljs-string">"workspace:*"</span>     <span class="hljs-comment">// 任意版本</span>
<span class="hljs-string">"@my/ui"</span>: <span class="hljs-string">"workspace:^"</span>     <span class="hljs-comment">// 遵循 semver</span>
<span class="hljs-string">"@my/ui"</span>: <span class="hljs-string">"workspace:~"</span>
</code></pre>
<h2 data-id="heading-5">批量执行命令</h2>
<pre><code class="hljs language-js" lang="js">pnpm -r build
pnpm -r test
pnpm -r lint
</code></pre>
<ul>
<li><code>-r</code> = recursive</li>
<li>对 workspace 里的 <strong>所有包</strong> 执行</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Koa.js 教程 | 一份不可多得的 Node.js 的 Web 框架 Koa.js 教程]]></title>    <link>https://juejin.cn/post/7603771025856692275</link>    <guid>https://juejin.cn/post/7603771025856692275</guid>    <pubDate>2026-02-08T07:49:56.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856692275" data-draft-id="7603721514203136009" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Koa.js 教程 | 一份不可多得的 Node.js 的 Web 框架 Koa.js 教程  "/> <meta itemprop="keywords" content="前端,后端,面试"/> <meta itemprop="datePublished" content="2026-02-08T07:49:56.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="千寻girling"/> <meta itemprop="url" content="https://juejin.cn/user/2276467567770442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Koa.js 教程 | 一份不可多得的 Node.js 的 Web 框架 Koa.js 教程  
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2276467567770442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    千寻girling
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T07:49:56.000Z" title="Sun Feb 08 2026 07:49:56 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;color:rgba(46,36,36,.87);overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{margin-bottom:5px;font-size:30px;font-weight:500}.markdown-body h1:before{content:"#";margin-right:10px;color:#1976d2}.markdown-body h2{font-size:28px;font-weight:400;border-left:5px solid #454545;margin-top:20px;padding-left:10px;transition:all .3s ease-in-out}.markdown-body h2:hover{border-color:#1976d2}.markdown-body h3{font-size:24px;font-weight:400;margin-top:15px;padding-bottom:0}.markdown-body h4{font-size:20px;font-weight:500}.markdown-body h5{font-size:16px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h2:first-letter,.markdown-body h3:first-letter,.markdown-body p:first-letter{text-transform:capitalize}.markdown-body em{text-emphasis:dot;text-emphasis-position:under}.markdown-body img{display:block;margin:0 auto!important;max-width:100%;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)!important}.markdown-body hr{position:relative;width:98%;height:1px;border:none;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#ddd,#999,#ddd);overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center}.markdown-body code{font-weight:900;word-break:break-word;border-radius:2px;overflow-x:auto;font-size:.87em;padding:.065em .4em;background-color:#fbe5e1;color:#c0341d}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:0 4px}.markdown-body pre&gt;code{font-weight:400;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{margin:0 4px;text-decoration:none;color:#027fff;transition:all .3s ease-in-out;padding-bottom:4px;border-bottom:2px solid transparent}.markdown-body a:after{content:"";display:inline-block;width:18px;height:18px;margin-left:4px;vertical-align:middle;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMiIgaGVpZ2h0PSIyMiI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMjdGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTkuODE1IDYuNDQ4bDEuOTM2LTEuOTM2YzEuMzM3LTEuMzM2IDMuNTgtMS4yNTkgNS4wMTMuMTczIDEuNDMyIDEuNDMyIDEuNTEgMy42NzYuMTczIDUuMDEzbC0xLjQ1MiAxLjQ1Mi0uOTY4Ljk2OGMtMS4zMzcgMS4zMzYtMy41ODEgMS4yNTktNS4wMTMtLjE3MyIvPjxwYXRoIGQ9Ik0xMS4yNjcgMTUuMzY3bC0xLjkzNiAxLjkzNmMtMS4zMzYgMS4zMzctMy41OCAxLjI2LTUuMDEyLS4xNzMtMS40MzItMS40MzItMS41MS0zLjY3Ni0uMTczLTUuMDEybDEuNDUyLTEuNDUyLjk2OC0uOTY4YzEuMzM2LTEuMzM3IDMuNTgtMS4yNiA1LjAxMi4xNzMiLz48L2c+PC9zdmc+);background-size:cover;background-repeat:no-repeat}.markdown-body a:hover{border-color:#027fff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body a.footnote-backref:after,.markdown-body a.footnote-ref:after,.markdown-body sup a:after{display:none!important}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border:2px solid #c6c6c6}.markdown-body table img{box-shadow:none!important}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body del{color:rgba(0,0,0,.6)}.markdown-body blockquote{position:relative;color:#666;padding:5px 23px 1px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:hsla(0,0%,78.4%,.12);transition:all .2s ease-in-out}.markdown-body blockquote:hover{border-color:#1976d2}.markdown-body blockquote:after,.markdown-body blockquote:before{position:absolute;font-size:24px;font-weight:800;line-height:24px;color:#cbcbcb;opacity:.6}.markdown-body blockquote:before{content:"“";top:4px;left:6px}.markdown-body blockquote:after{content:"”";right:8px;bottom:-8px}.markdown-body blockquote&gt;p,.markdown-body blockquote blockquote{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body details{outline:none;border:none;border-left:4px solid #1976d2;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary:hover::-webkit-details-marker{color:#1976d2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">第一章 安装和配置 koa</h2>
<p>Koa 是一个轻量级、现代化的框架, 由 Express 原班人马开发</p>
<p>初始化配置文件 package.json</p>
<pre><code class="hljs language-js" lang="js">npm init -y
</code></pre>
<p>配置 package.json (ESM规范)</p>
<pre><code class="hljs language-js" lang="js">{
     <span class="hljs-string">"type"</span>: <span class="hljs-string">"module"</span>,
     <span class="hljs-string">"name"</span>: <span class="hljs-string">"demo"</span>,
     <span class="hljs-string">"version"</span>: <span class="hljs-string">"1.0.0"</span>,
     <span class="hljs-string">"main"</span>: <span class="hljs-string">"index.js"</span>,
     <span class="hljs-string">"scripts"</span>: {
          <span class="hljs-string">"dev"</span>:<span class="hljs-string">"nodemon index.js"</span>,
           <span class="hljs-string">"test"</span>: <span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>
     },
     <span class="hljs-string">"keywords"</span>: [],
     <span class="hljs-string">"author"</span>: <span class="hljs-string">""</span>,
     <span class="hljs-string">"license"</span>: <span class="hljs-string">"ISC"</span>,
     <span class="hljs-string">"description"</span>: <span class="hljs-string">""</span>
}
</code></pre>
<p>npm 官网</p>
<p>     <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2F" target="_blank" title="https://www.npmjs.com/" ref="nofollow noopener noreferrer">www.npmjs.com</a></p>
<p>安装koa
     </p>
<pre><code class="hljs language-css" lang="css">npm <span class="hljs-selector-tag">i</span> koa
</code></pre>
<blockquote>
<p>     全局安装 nodemon</p>
<p>  .  <code>npm i nodemon -g</code></p>
<p>     当 nodemon 检测到监视的文件发生更改时, 会自动重新启动应用</p>
</blockquote>
<h2 data-id="heading-1">第二章 创建并启动 http 服务器</h2>
<h3 data-id="heading-2">中间件</h3>
<p>中间件是处理 HTTP 请求和响应的函数，它们可以做以下操作：</p>
<ul>
<li>处理请求（例如解析请求体、验证用户身份等）</li>
<li>修改响应（例如设置响应头、发送响应体等）</li>
<li>执行后续中间件</li>
</ul>
<blockquote>
<p>中间件 - 很重要的概念 !!!!!!!</p>
</blockquote>
<p>注意 : app.use() 方法用于注册 <strong>中间件</strong></p>
<blockquote>
<p><strong>中间件</strong> 是处理 http 请求和响应的函数  ,
当一个请求到达服务器时, 会从第一个中间件开始执行, 直到最后一个中间件</p>
</blockquote>
<h3 data-id="heading-3">上下文对象 ctx</h3>
<p>在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcaijiao.org%2Fkoa%2F" target="_blank" title="https://caijiao.org/koa/" ref="nofollow noopener noreferrer">Koa</a> 中，<code>ctx</code>（上下文）对象是每个中间件函数的核心，它包含了请求和响应的所有信息。所有的 HTTP 请求和响应都通过 <code>ctx</code> 进行处理。</p>
<blockquote>
<p>上下文对象 ctx ( context ) 包含了与当前 http 请求相关的所有信息</p>
<p>如: http方法、url、请求头、请求体、查询参数等</p>
</blockquote>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'koa'</span>

<span class="hljs-keyword">const</span> hostname = <span class="hljs-string">"127.0.0.1"</span> <span class="hljs-comment">//服务器监听的ip地址</span>
<span class="hljs-keyword">const</span> port = <span class="hljs-number">8008</span> <span class="hljs-comment">//服务器监听的端口号</span>

<span class="hljs-comment">/*
    实例化一个 Koa 对象
    实例化是指根据一个类创建具体对象的过程
*/</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>()

app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> ctx =&gt; {
    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">"juejin.cn"</span> <span class="hljs-comment">// 使用 ctx.body 设置响应体的内容</span>
})

<span class="hljs-comment">//启动 http 服务器, 并在指定的ip地址(127.0.0.1)和端口(8008)上监听连接请求</span>
app.<span class="hljs-title function_">listen</span>(port, hostname, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`服务器已启动: http://<span class="hljs-subst">${hostname}</span>:<span class="hljs-subst">${port}</span>`</span>)
})
</code></pre>
<h2 data-id="heading-4">第三章 洋葱模型</h2>
<h3 data-id="heading-5">洋葱模型</h3>
<p>当你处理一个请求时,</p>
<p>可以想象成是在 "剥洋葱" ,从外向内一层一层地往里剥,直到剥到中心部分</p>
<p>这个过程涉及对 <strong>请求</strong> 的多个层面进行解析、验证、处理</p>
<p>在处理完洋葱(<strong>请求</strong>)后,</p>
<p>构建 <strong>响应</strong> 的过程就像是从精心准备的食材 ( <strong>处理请求</strong> 后得到的数据) 开始,</p>
<p>从内向外逐层添加调料(格式化、封装等),最终形成一道色香味俱佳的菜肴(<strong>响应</strong>)</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1994778ec0f4f0881f16b64bb9298a3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2D5a-7Z2lybGluZw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141796&amp;x-signature=i0WpLyNKGUcwji%2B%2FE6Kaq4UvRCs%3D" alt="image.png" loading="lazy"/></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'koa'</span>

<span class="hljs-keyword">const</span> hostname = <span class="hljs-string">"127.0.0.1"</span> <span class="hljs-comment">//服务器监听的ip地址</span>
<span class="hljs-keyword">const</span> port = <span class="hljs-number">8008</span> <span class="hljs-comment">//服务器监听的端口号</span>

<span class="hljs-comment">/*
    实例化一个 Koa 对象
    实例化是指根据一个类创建具体对象的过程
*/</span>
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>()

<span class="hljs-comment">/*
    app.use() 方法用于注册中间件
    中间件是处理 http 请求和响应的函数
    当一个请求到达服务器时, 会从第一个中间件开始执行, 直到最后一个中间件
    
    上下文对象 ctx(context) 包含了与当前 http 请求相关的所有信息
    如: http方法、url、请求头、请求体、查询参数等
*/</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx,next) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>() <span class="hljs-comment">//若中间件调用了next(),会暂停当前中间件的执行,将控制权传递给下一个中间件</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)
})

app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx,next) =&gt; { 
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>)
})

<span class="hljs-comment">//当中间件没有再调用next(),则不需要再将控制权传递给下一个中间件,控制权会按照相反的顺序执行</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx,next) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>)
    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">"dengruicode.com"</span> <span class="hljs-comment">// 使用 ctx.body 设置响应体的内容</span>
})

<span class="hljs-comment">//启动 http 服务器, 并在指定的ip地址(127.0.0.1)和端口(8008)上监听连接请求</span>
app.<span class="hljs-title function_">listen</span>(port, hostname, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`服务器已启动: http://<span class="hljs-subst">${hostname}</span>:<span class="hljs-subst">${port}</span>`</span>)
})
</code></pre>
<h2 data-id="heading-6">第四章 安装和配置路由 - get请求</h2>
<p>在 Koa 中，<code>koa-router</code> 是一个轻量级的路由中间件，它可以帮助你定义路由、处理 HTTP 请求并解析请求参数。通过使用 <code>koa-router</code>，你可以创建一个灵活的路由系统，轻松地组织和管理 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcaijiao.org%2Fkoa%2F" target="_blank" title="https://caijiao.org/koa/" ref="nofollow noopener noreferrer">Koa</a> 应用的各个部分。</p>
<h3 data-id="heading-7">安装 koa-router</h3>
<p>首先，你需要安装 <code>koa-router</code>：</p>
<pre><code class="hljs language-ruby" lang="ruby">npm install <span class="hljs-variable">@koa</span>/router       <span class="hljs-comment"># 注意：新版 koa-router 包名是 <span class="hljs-doctag">@koa</span>/router</span>
</code></pre>

<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> Koa from <span class="hljs-string">'koa'</span>
<span class="hljs-keyword">import</span> Router from <span class="hljs-string">'@koa/router'</span>

<span class="hljs-keyword">const</span> hostname = <span class="hljs-string">"127.0.0.1"</span>
<span class="hljs-keyword">const</span> port = <span class="hljs-number">8008</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa()
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router() <span class="hljs-comment">//实例化一个 Router 对象</span>

<span class="hljs-comment">//------ get请求</span>
<span class="hljs-comment">//路由是根据客户端发送的请求(包括请求的路径、方法等)调用与之匹配的处理函数</span>
<span class="hljs-comment">//根路由 http://127.0.0.1:8008/</span>
router.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/'</span>, <span class="hljs-keyword">async</span> ctx =&gt; { <span class="hljs-comment">//get请求</span>
    ctx.body = <span class="hljs-string">"dengruicode.com"</span>
})

<span class="hljs-comment">//查询参数 http://127.0.0.1:8008/test?id=001&amp;web=dengruicode.com</span>
router.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/test'</span>, <span class="hljs-keyword">async</span> ctx =&gt; { <span class="hljs-comment">//get请求</span>
    let id = ctx.query.id
    let web = ctx.query.web
    ctx.body = id + <span class="hljs-string">" : "</span> + web
})

<span class="hljs-comment">//路径参数 http://127.0.0.1:8008/test2/id/002/web/www.dengruicode.com</span>
router.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/test2/id/:id/web/:web'</span>, <span class="hljs-keyword">async</span> ctx =&gt; {
    let id = ctx.params.id
    let web = ctx.params.web
    ctx.body = id + <span class="hljs-string">" : "</span> + web
})

<span class="hljs-comment">//重定向路由 http://127.0.0.1:8008/test3</span>
router.redirect(<span class="hljs-string">'/test3'</span>, <span class="hljs-string">'https://www.baidu.com'</span>)

app.use(router.routes()) <span class="hljs-comment">//将定义在 router 对象中的路由规则添加到 app 实例中</span>

<span class="hljs-comment">//------ 路由分组</span>
<span class="hljs-comment">//http://127.0.0.1:8008/user/add</span>
<span class="hljs-comment">//http://127.0.0.1:8008/user/del</span>

<span class="hljs-keyword">const</span> userRouter = <span class="hljs-keyword">new</span> Router({ prefix: <span class="hljs-string">'/user'</span> })
userRouter.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/add'</span>, <span class="hljs-keyword">async</span> ctx =&gt; {
    ctx.body = <span class="hljs-string">"添加用户"</span>
})
userRouter.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/del'</span>, <span class="hljs-keyword">async</span> ctx =&gt; {
    ctx.body = <span class="hljs-string">"删除用户"</span>
})
app.use(userRouter.routes())

<span class="hljs-comment">// 在所有路由之后添加404处理函数</span>
app.use(<span class="hljs-keyword">async</span> ctx =&gt; {
    <span class="hljs-keyword">if</span> (!ctx.body) { <span class="hljs-comment">//若没有设置 ctx.body, 则说明没有到匹配任何路由</span>
        ctx.status = <span class="hljs-number">404</span>
        ctx.body = <span class="hljs-string">'404 Not Found'</span>
    }
})

app.listen(port, hostname, () =&gt; {
    console.log(`服务器已启动: http:<span class="hljs-comment">//${hostname}:${port}`)</span>
})
</code></pre>
<h2 data-id="heading-8">第五章 post请求</h2>
<h3 data-id="heading-9">安装 koa-body</h3>
<p>Koa 原生不支持解析 POST 请求体，需安装 <code>koa-body</code> 中间件：</p>
<pre><code class="hljs language-css" lang="css">npm install koa-<span class="hljs-selector-tag">body</span>
</code></pre>
<p>POST 请求处理示例</p>
<p>修改 <code>src/index.js</code>，新增 POST 路由：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'koa'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@koa/router'</span>;
<span class="hljs-keyword">import</span> { koaBody } <span class="hljs-keyword">from</span> <span class="hljs-string">'koa-body'</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">8008</span>;

<span class="hljs-comment">// 注册 koa-body 中间件：解析 JSON、表单、文件类型的 POST 数据</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">koaBody</span>({
  <span class="hljs-attr">multipart</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 支持文件上传（后续第八章用）</span>
  <span class="hljs-attr">json</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 解析 JSON 格式</span>
  <span class="hljs-attr">urlencoded</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 解析表单格式（application/x-www-form-urlencoded）</span>
}));

<span class="hljs-comment">// 1. 处理 JSON 格式 POST 请求</span>
router.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/json'</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; {
  <span class="hljs-keyword">const</span> { name, age } = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>;
  ctx.<span class="hljs-property">body</span> = {       <span class="hljs-comment">// ctx.request.body 是 koa-body 解析后的 POST 数据</span>
    <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">msg</span>: <span class="hljs-string">"JSON 数据接收成功"</span>,
    <span class="hljs-attr">data</span>: { name, age }
  };
});

<span class="hljs-comment">// 2. 处理表单格式 POST 请求</span>
router.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/form'</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; {
  <span class="hljs-keyword">const</span> { username, password } = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">body</span>;
  ctx.<span class="hljs-property">body</span> = {
    <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">msg</span>: <span class="hljs-string">"表单数据接收成功"</span>,
    <span class="hljs-attr">data</span>: { username, password }
  };
});

app.<span class="hljs-title function_">use</span>(router.<span class="hljs-title function_">routes</span>());

<span class="hljs-comment">// 404 处理</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx) =&gt; {
  ctx.<span class="hljs-property">status</span> = <span class="hljs-number">404</span>;
  ctx.<span class="hljs-property">body</span> = <span class="hljs-string">'404 Not Found'</span>;
});

app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`POST 服务器启动：http://localhost:<span class="hljs-subst">${port}</span>`</span>);
});
</code></pre>
<p>测试 POST 请求（两种方式）</p>
<p>方式 1：Postman 测试</p>
<ul>
<li>
<p>请求地址：<code>http://localhost:8008/api/json</code></p>
</li>
<li>
<p>请求方法：POST</p>
</li>
<li>
<p>请求体：选择 <code>raw &gt; JSON</code>，输入：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span> <span class="hljs-attr">"name"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"张三"</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">"age"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span> <span class="hljs-punctuation">}</span>
</code></pre>
</li>
<li>
<p>响应：<code>{"code":200,"msg":"JSON 数据接收成功","data":{"name":"张三","age":20}}</code></p>
</li>
</ul>
<p>方式 2：curl 命令测试</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 测试 JSON 格式</span>
curl -X POST -H <span class="hljs-string">"Content-Type: application/json"</span> -d <span class="hljs-string">'{"name":"张三","age":20}'</span> http://localhost:8008/api/json

<span class="hljs-comment"># 测试表单格式</span>
curl -X POST -d <span class="hljs-string">"username=admin&amp;password=123456"</span> http://localhost:8008/api/form
</code></pre>
<h2 data-id="heading-10">第六章 错误处理</h2>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'koa'</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@koa/router'</span>

<span class="hljs-keyword">const</span> hostname = <span class="hljs-string">"127.0.0.1"</span>
<span class="hljs-keyword">const</span> port = <span class="hljs-number">8008</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>()
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>()

<span class="hljs-comment">//http://127.0.0.1:8008/</span>
router.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/'</span>, <span class="hljs-keyword">async</span> ctx =&gt; {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">"测试"</span>)
})

<span class="hljs-comment">/*
    将 '错误处理中间件' 放在 '路由处理中间件' 之前, 当一个请求到达时,
    会先经过 '错误处理中间件', 然后才会进入 '路由处理中间件',
    是为了确保可以捕获错误
*/</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {  <span class="hljs-comment">// 错误处理中间件</span>
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>()
    } <span class="hljs-keyword">catch</span> (err) {
        <span class="hljs-comment">//console.log('err:', err)</span>
        ctx.<span class="hljs-property">status</span> = <span class="hljs-number">500</span>
        ctx.<span class="hljs-property">body</span> = <span class="hljs-string">'err: '</span> + err.<span class="hljs-property">message</span>
    }
})

app.<span class="hljs-title function_">use</span>(router.<span class="hljs-title function_">routes</span>())   <span class="hljs-comment">// 路由处理中间件</span>

app.<span class="hljs-title function_">listen</span>(port, hostname, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`服务器已启动: http://<span class="hljs-subst">${hostname}</span>:<span class="hljs-subst">${port}</span>`</span>)
})
</code></pre>
<h2 data-id="heading-11">第七章 允许跨域请求</h2>
<p>安装跨域中间件</p>
<pre><code class="hljs language-bash" lang="bash">npm install @koa/cors
</code></pre>
<p>跨域配置示例</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'koa'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@koa/router'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Cors</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@koa/cors'</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">8008</span>;

app.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Cors</span>()) <span class="hljs-comment">//允许跨域请求</span>

<span class="hljs-comment">// 测试跨域路由</span>
router.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/cors'</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; {
  ctx.<span class="hljs-property">body</span> = {
    <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">msg</span>: <span class="hljs-string">"跨域请求成功"</span>
  };
});

app.<span class="hljs-title function_">use</span>(router.<span class="hljs-title function_">routes</span>());

app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`跨域服务器启动：http://localhost:<span class="hljs-subst">${port}</span>`</span>);
});
</code></pre>
<p>测试跨域</p>
<p>在任意前端项目（如 Vue / React / HTML 文件）中发送请求：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 前端代码示例</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">'http://localhost:8008/api/cors'</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)) <span class="hljs-comment">// 输出 {code:200, msg:"跨域请求成功"}</span>
  .<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err));
</code></pre>
<p>无跨域报错即配置成功。</p>
<h2 data-id="heading-12">第八章 上传图片</h2>
<p>依赖准备（复用 koa-body）</p>
<p><code>koa-body</code> 已支持文件上传，无需额外安装依赖，只需确保配置 <code>multipart: true</code>。</p>
<p>图片上传示例</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Koa</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'koa'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@koa/router'</span>;
<span class="hljs-keyword">import</span> { koaBody } <span class="hljs-keyword">from</span> <span class="hljs-string">'koa-body'</span>;
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>;
<span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">8008</span>;

<span class="hljs-comment">// 1. 创建上传目录（不存在则创建）</span>
<span class="hljs-keyword">const</span> uploadDir = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">'uploads'</span>);
<span class="hljs-keyword">if</span> (!fs.<span class="hljs-title function_">existsSync</span>(uploadDir)) {
  fs.<span class="hljs-title function_">mkdirSync</span>(uploadDir, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> });
}

<span class="hljs-comment">// 2. 配置 koa-body 支持文件上传</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">koaBody</span>({
  <span class="hljs-attr">multipart</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启文件上传</span>
  <span class="hljs-attr">formidable</span>: {
    <span class="hljs-attr">uploadDir</span>: uploadDir, <span class="hljs-comment">// 临时存储目录</span>
    <span class="hljs-attr">keepExtensions</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 保留文件扩展名（如 .png/.jpg）</span>
    <span class="hljs-attr">maxFieldsSize</span>: <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// 限制文件大小 2MB</span>
    <span class="hljs-attr">filename</span>: <span class="hljs-function">(<span class="hljs-params">name, ext, part, form</span>) =&gt;</span> {
      <span class="hljs-comment">// 自定义文件名：时间戳 + 原扩展名，避免重复</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>() + ext;
    }
  }
}));

<span class="hljs-comment">// 3. 图片上传接口</span>
router.<span class="hljs-title function_">post</span>(<span class="hljs-string">'/api/upload'</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; {
  <span class="hljs-comment">// ctx.request.files 是上传的文件对象</span>
  <span class="hljs-keyword">const</span> file = ctx.<span class="hljs-property">request</span>.<span class="hljs-property">files</span>.<span class="hljs-property">file</span>; <span class="hljs-comment">// 前端上传的文件字段名需为 file</span>
  <span class="hljs-keyword">if</span> (!file) {
    ctx.<span class="hljs-property">status</span> = <span class="hljs-number">400</span>;
    ctx.<span class="hljs-property">body</span> = { <span class="hljs-attr">code</span>: <span class="hljs-number">400</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">"请选择上传的图片"</span> };
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 返回文件信息</span>
  ctx.<span class="hljs-property">body</span> = {
    <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">msg</span>: <span class="hljs-string">"图片上传成功"</span>,
    <span class="hljs-attr">data</span>: {
      <span class="hljs-attr">filename</span>: file.<span class="hljs-property">newFilename</span>, <span class="hljs-comment">// 自定义后的文件名</span>
      <span class="hljs-attr">path</span>: <span class="hljs-string">`/uploads/<span class="hljs-subst">${file.newFilename}</span>`</span>, <span class="hljs-comment">// 访问路径</span>
      <span class="hljs-attr">size</span>: file.<span class="hljs-property">size</span> <span class="hljs-comment">// 文件大小（字节）</span>
    }
  };
});

<span class="hljs-comment">// 4. 静态文件访问：让上传的图片可通过 URL 访问</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next) =&gt; {
  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">path</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">'/uploads/'</span>)) {
    <span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(uploadDir, ctx.<span class="hljs-property">path</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">'/uploads/'</span>, <span class="hljs-string">''</span>));
    <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(filePath)) {
      ctx.<span class="hljs-property">type</span> = path.<span class="hljs-title function_">extname</span>(filePath).<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 设置响应类型（如 png/jpg）</span>
      ctx.<span class="hljs-property">body</span> = fs.<span class="hljs-title function_">createReadStream</span>(filePath); <span class="hljs-comment">// 读取文件并返回</span>
      <span class="hljs-keyword">return</span>;
    }
    ctx.<span class="hljs-property">status</span> = <span class="hljs-number">404</span>;
    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">"文件不存在"</span>;
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
});

app.<span class="hljs-title function_">use</span>(router.<span class="hljs-title function_">routes</span>());

app.<span class="hljs-title function_">listen</span>(port, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`图片上传服务器启动：http://localhost:<span class="hljs-subst">${port}</span>`</span>);
});
</code></pre>
<p>测试图片上传</p>
<p>方式 1：Postman 测试</p>
<ul>
<li>请求地址：<code>http://localhost:8008/api/upload</code></li>
<li>请求方法：POST</li>
<li>请求体：选择 <code>form-data</code>，Key 为 <code>file</code>，Type 选 <code>File</code>，上传一张图片。</li>
<li>响应：返回文件路径，如 <code>http://localhost:8008/uploads/1738987654321.png</code>，访问该 URL 可查看图片。</li>
</ul>
<p>方式 2：curl 命令测试</p>
<p>终端输入 bash 命令</p>
<pre><code class="hljs language-bash" lang="bash">curl -X POST -F <span class="hljs-string">"file=@/你的图片路径/xxx.png"</span> http://localhost:8008/api/upload
</code></pre>
<h2 data-id="heading-13">第九章 cookie</h2>
<p>Cookie 是存储在客户端浏览器的小型文本数据，Koa 内置 <code>ctx.cookies</code> API 可以操作 Cookie。</p>
<p>Cookie 操作示例</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-keyword">import</span> Koa from <span class="hljs-string">'koa'</span>
<span class="hljs-keyword">import</span> Router from <span class="hljs-string">'@koa/router'</span>
 
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">8008</span>;

<span class="hljs-comment">// 1. 设置 Cookie</span>
router.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/cookie/set'</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; {
  <span class="hljs-comment">// ctx.cookies.set(名称, 值, 配置)</span>
  ctx.cookies.<span class="hljs-keyword">set</span>(
    <span class="hljs-string">'username'</span>, 
    encodeURIComponent(<span class="hljs-string">'张三'</span>), 
    {
      maxAge: <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 过期时间 1 天（毫秒）</span>
      httpOnly: <span class="hljs-keyword">true</span>, <span class="hljs-comment">// 仅允许服务端访问，防止 XSS 攻击</span>
      secure: <span class="hljs-keyword">false</span>, <span class="hljs-comment">// 开发环境设为 false（HTTPS 环境设为 true）</span>
      path: <span class="hljs-string">'/'</span>, <span class="hljs-comment">// 生效路径（/ 表示全站）</span>
      sameSite: <span class="hljs-string">'lax'</span> <span class="hljs-comment">// 防止 CSRF 攻击</span>
    }
  );
  ctx.body = { code: <span class="hljs-number">200</span>, msg: <span class="hljs-string">"Cookie 设置成功"</span> };
});

<span class="hljs-comment">// 2. 获取 Cookie</span>
router.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/cookie/get'</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; {
  <span class="hljs-keyword">const</span> username = ctx.cookies.<span class="hljs-keyword">get</span>(<span class="hljs-string">'username'</span>);
  ctx.body = {
    code: <span class="hljs-number">200</span>,
    msg: <span class="hljs-string">"Cookie 获取成功"</span>,
    data: { username }
  };
});

<span class="hljs-comment">// 3. 删除 Cookie</span>
router.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/cookie/delete'</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; {
  ctx.cookies.<span class="hljs-keyword">set</span>(<span class="hljs-string">'username'</span>, <span class="hljs-string">''</span>, { maxAge: <span class="hljs-number">0</span> }); <span class="hljs-comment">// 设置 maxAge 为 0 即删除</span>
  ctx.body = { code: <span class="hljs-number">200</span>, msg: <span class="hljs-string">"Cookie 删除成功"</span> };
});

app.use(router.routes());

app.listen(port, () =&gt; {
  console.log(`Cookie 服务器启动：http:<span class="hljs-comment">//localhost:${port}`);</span>
});
</code></pre>
<p>测试 Cookie</p>
<ol>
<li>访问 <code>http://localhost:8008/cookie/set</code> → 设置 Cookie；</li>
<li>访问 <code>http://localhost:8008/cookie/get</code> → 获取 Cookie，输出 <code>{username: "张三"}</code>；</li>
<li>访问 <code>http://localhost:8008/cookie/delete</code> → 删除 Cookie，再次获取则为 <code>undefined</code>。</li>
</ol>
<h2 data-id="heading-14">第十章 session</h2>
<p>安装 Session 中间件</p>
<p>Koa 原生不支持 Session，需安装 <code>koa-session</code>：</p>
<pre><code class="hljs">npm install koa-session
</code></pre>
<p>Session 配置示例</p>
<pre><code class="hljs language-php" lang="php">import Koa <span class="hljs-keyword">from</span> <span class="hljs-string">'koa'</span>
import Router <span class="hljs-keyword">from</span> <span class="hljs-string">'@koa/router'</span>
import session  <span class="hljs-keyword">from</span> <span class="hljs-string">'koa-session'</span>

<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">app</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">router</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">port</span> = <span class="hljs-number">8008</span>;

<span class="hljs-comment">// 1. 配置 Session 密钥（生产环境需改为随机字符串）</span>
app.keys = [<span class="hljs-string">'dengruicode_secret_key'</span>];

<span class="hljs-comment">// 2. Session 配置</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CONFIG</span> = {
  key: <span class="hljs-string">'koa:sess'</span>, <span class="hljs-comment">// Session Cookie 名称</span>
  maxAge: <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>, <span class="hljs-comment">// 过期时间 1 天</span>
  autoCommit: <span class="hljs-literal">true</span>,
  overwrite: <span class="hljs-literal">true</span>,
  httpOnly: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 仅服务端访问</span>
  signed: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 签名 Cookie，防止篡改</span>
  rolling: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不刷新过期时间</span>
  renew: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 快过期时自动续期</span>
  secure: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 开发环境 false</span>
  sameSite: <span class="hljs-string">'lax'</span>
};

<span class="hljs-comment">// 3. 注册 Session 中间件</span>
app.<span class="hljs-keyword">use</span>(<span class="hljs-title function_ invoke__">session</span>(CONFIG, app));

<span class="hljs-comment">// 4. Session 操作</span>
<span class="hljs-comment">// 设置 Session</span>
router.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">'/session/set'</span>, <span class="hljs-title function_ invoke__">async</span> (ctx) =&gt; {
  ctx.session.user = {
    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">"张三"</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>
  };
  ctx.body = { <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">"Session 设置成功"</span> };
});

<span class="hljs-comment">// 获取 Session</span>
router.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">'/session/get'</span>, <span class="hljs-title function_ invoke__">async</span> (ctx) =&gt; {
  <span class="hljs-keyword">const</span> user = ctx.session.user;
  ctx.body = {
    <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>,
    <span class="hljs-attr">msg</span>: <span class="hljs-string">"Session 获取成功"</span>,
    <span class="hljs-attr">data</span>: { user }
  };
});

<span class="hljs-comment">// 删除 Session</span>
router.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">'/session/delete'</span>, <span class="hljs-title function_ invoke__">async</span> (ctx) =&gt; {
  ctx.session = <span class="hljs-literal">null</span>; // 清空 Session
  ctx.body = { <span class="hljs-attr">code</span>: <span class="hljs-number">200</span>, <span class="hljs-attr">msg</span>: <span class="hljs-string">"Session 删除成功"</span> };
});

app.<span class="hljs-keyword">use</span>(router.<span class="hljs-title function_ invoke__">routes</span>());

app.<span class="hljs-title function_ invoke__">listen</span>(port, () =&gt; {
  console.<span class="hljs-title function_ invoke__">log</span>(`Session 服务器启动：<span class="hljs-attr">http</span>://<span class="hljs-attr">localhost</span>:${port}`);
});
</code></pre>
<p>测试 Session</p>
<ol>
<li>访问 <code>http://localhost:8008/session/set</code> → 设置 Session；</li>
<li>访问 <code>http://localhost:8008/session/get</code> → 获取 Session，输出用户信息；</li>
<li>访问 <code>http://localhost:8008/session/delete</code> → 清空 Session，再次获取则为 <code>undefined</code>。</li>
</ol>
<blockquote>
<p>注意：<code>koa-session</code> 是基于 Cookie 的内存 Session，生产环境建议使用 <code>koa-redis</code> 将 Session 存储到 Redis，避免服务重启丢失数据。</p>
</blockquote>
<h2 data-id="heading-15">第十一章 jwt</h2>
<p>安装 JWT 依赖</p>
<pre><code class="hljs">npm install jsonwebtoken koa-jwt
</code></pre>
<ul>
<li><code>jsonwebtoken</code>：生成 / 解析 JWT 令牌；</li>
<li><code>koa-jwt</code>：验证 JWT 令牌的中间件。</li>
</ul>
<p>JWT 完整示例</p>
<pre><code class="hljs language-ini" lang="ini">import Koa from 'koa'
import Router from '@koa/router'
import jwt  from 'jsonwebtoken'
import koaJwt  from 'koa-jwt'

const <span class="hljs-attr">app</span> = new Koa()<span class="hljs-comment">;</span>
const <span class="hljs-attr">router</span> = new Router()<span class="hljs-comment">;</span>
const <span class="hljs-attr">port</span> = <span class="hljs-number">8008</span><span class="hljs-comment">;</span>

// 1. JWT 密钥（生产环境需加密存储）
const <span class="hljs-attr">JWT_SECRET</span> = <span class="hljs-string">'dengruicode_jwt_secret'</span><span class="hljs-comment">;</span>
// JWT 过期时间：1 小时（秒）
const <span class="hljs-attr">JWT_EXPIRES_IN</span> = <span class="hljs-number">3600</span><span class="hljs-comment">;</span>

// 2. 登录接口：生成 JWT 令牌
router.post('/api/login', async (ctx) =&gt; {
  // 模拟验证用户名密码（生产环境需查数据库）
  const { username, password } = ctx.request.body<span class="hljs-comment">;</span>
  if (<span class="hljs-attr">username</span> === <span class="hljs-string">'admin'</span> &amp;&amp; password === <span class="hljs-string">'123456'</span>) {
    // 生成 JWT 令牌
    const <span class="hljs-attr">token</span> = jwt.sign(
      { id: 1, username }, // 载荷：存储用户信息（不要存敏感数据）
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN }
    )<span class="hljs-comment">;</span>
    <span class="hljs-attr">ctx.body</span> = {
      code: 200,
      msg: "登录成功",
      data: { token }
    }<span class="hljs-comment">;</span>
  } else {
    <span class="hljs-attr">ctx.status</span> = <span class="hljs-number">401</span><span class="hljs-comment">;</span>
    <span class="hljs-attr">ctx.body</span> = { code: <span class="hljs-number">401</span>, msg: <span class="hljs-string">"用户名或密码错误"</span> }<span class="hljs-comment">;</span>
  }
})<span class="hljs-comment">;</span>

// 3. 受保护的接口：需要 JWT 验证
// koa-jwt 中间件会自动解析 Authorization 头中的 token
app.use(koaJwt({ secret: JWT_SECRET }).unless({
  path: <span class="hljs-section">[/^/api/login/]</span> // 排除登录接口，无需验证
}))<span class="hljs-comment">;</span>

// 4. 获取用户信息接口（需验证 JWT）
router.get('/api/user/info', async (ctx) =&gt; {
  // ctx.state.user 是 koa-jwt 解析后的 JWT 载荷
  const { id, username } = ctx.state.user<span class="hljs-comment">;</span>
  <span class="hljs-attr">ctx.body</span> = {
    code: 200,
    msg: "获取用户信息成功",
    data: { id, username }
  }<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>

app.use(router.routes())<span class="hljs-comment">;</span>

// 5. JWT 错误处理
app.use(async (ctx, next) =&gt; {
  try {
    await next()<span class="hljs-comment">;</span>
  } catch (err) {
    if (<span class="hljs-attr">err.status</span> === <span class="hljs-number">401</span>) {
      <span class="hljs-attr">ctx.status</span> = <span class="hljs-number">401</span><span class="hljs-comment">;</span>
      <span class="hljs-attr">ctx.body</span> = { code: <span class="hljs-number">401</span>, msg: <span class="hljs-string">"token 无效或过期"</span> }<span class="hljs-comment">;</span>
    } else {
      throw err<span class="hljs-comment">;</span>
    }
  }
})<span class="hljs-comment">;</span>

app.listen(port, () =&gt; {
  console.log(`JWT 服务器启动：http://localhost:${port}`)<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>
</code></pre>
<p>测试 JWT</p>
<p>步骤 1：登录获取 token</p>
<pre><code class="hljs language-json" lang="json">curl -X POST -d <span class="hljs-string">"username=admin&amp;password=123456"</span> http<span class="hljs-punctuation">:</span><span class="hljs-comment">//localhost:8008/api/login</span>
# 响应：<span class="hljs-punctuation">{</span><span class="hljs-attr">"code"</span><span class="hljs-punctuation">:</span><span class="hljs-number">200</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"msg"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"登录成功"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span><span class="hljs-attr">"token"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"xxx.xxx.xxx"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span>
</code></pre>
<p>步骤 2：携带 token 访问受保护接口</p>
<pre><code class="hljs language-json" lang="json">curl -H <span class="hljs-string">"Authorization: Bearer 你的token"</span> http<span class="hljs-punctuation">:</span><span class="hljs-comment">//localhost:8008/api/user/info</span>
# 响应：<span class="hljs-punctuation">{</span><span class="hljs-attr">"code"</span><span class="hljs-punctuation">:</span><span class="hljs-number">200</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"msg"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"获取用户信息成功"</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"data"</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">{</span><span class="hljs-attr">"id"</span><span class="hljs-punctuation">:</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-attr">"username"</span><span class="hljs-punctuation">:</span><span class="hljs-string">"admin"</span><span class="hljs-punctuation">}</span><span class="hljs-punctuation">}</span>
</code></pre>
<p>步骤 3：token 无效 / 过期测试</p>
<p>携带错误 token 或过期 token 访问，会返回 <code>{"code":401,"msg":"token 无效或过期"}</code>。</p>
<p>总结</p>
<ol>
<li>
<p><strong>核心流程</strong>：Koa 开发的核心是「中间件 + 路由」，所有功能（跨域、上传、JWT）都通过中间件扩展；</p>
</li>
<li>
<p><strong>关键依赖</strong>：<code>@koa/router</code>（路由）、<code>koa-body</code>（POST / 上传）、<code>@koa/cors</code>（跨域）、<code>koa-session</code>（Session）、<code>jsonwebtoken/koa-jwt</code>（JWT）；</p>
</li>
<li>
<p><strong>生产建议</strong>：</p>
<ul>
<li>
<p>Session/JWT 密钥需随机生成并加密存储；</p>
</li>
<li>
<p>文件上传需限制大小和类型，防止恶意上传；</p>
</li>
<li>
<p>跨域需指定具体域名，而非 <code>*</code>；</p>
</li>
<li>
<p>JWT 载荷不要存敏感数据，过期时间不宜过长。</p>
</li>
</ul>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[“破案”笔记：iframe动态加载内容后，打印功能为何失灵？]]></title>    <link>https://juejin.cn/post/7603699739223621647</link>    <guid>https://juejin.cn/post/7603699739223621647</guid>    <pubDate>2026-02-08T09:14:39.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603699739223621647" data-draft-id="7603671627003904040" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="“破案”笔记：iframe动态加载内容后，打印功能为何失灵？"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-08T09:14:39.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="天才熊猫君"/> <meta itemprop="url" content="https://juejin.cn/user/3789388889725732"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            “破案”笔记：iframe动态加载内容后，打印功能为何失灵？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3789388889725732/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    天才熊猫君
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T09:14:39.000Z" title="Sun Feb 08 2026 09:14:39 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0"><strong>“破案”笔记：iframe动态加载内容后，打印功能为何失灵？</strong></h3>
<h4 data-id="heading-1"><strong>案件概述</strong></h4>
<p><strong>异常现象</strong>：当我用 <code>iframe.srcdoc</code>动态生成一个报告页面，并想自动调起打印时，打印窗口死活不弹出来，打印完成的回调函数也永远不会执行。代码看起来没问题，但就是无效。</p>
<p><strong>初步怀疑</strong>：是不是 <code>srcdoc</code>把我刚绑定的事件监听器给“冲走了”？</p>
<hr/>
<h4 data-id="heading-2"><strong>第一现场：重现“案发”过程</strong></h4>
<p>这是当时“案发”的代码片段：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 1. 给 iframe 灌入新内容</span>
<span class="hljs-keyword">let</span> frame = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'myFrame'</span>);
frame.<span class="hljs-property">srcdoc</span> = <span class="hljs-string">`&lt;h1&gt;我的报告&lt;/h1&gt;&lt;p&gt;请打印我&lt;/p&gt;`</span>;
​
<span class="hljs-comment">// 2. 立刻绑定打印完成后的回调</span>
frame.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'afterprint'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'打印完成！'</span>); <span class="hljs-comment">// 🚨 这条日志从未出现！</span>
});
​
<span class="hljs-comment">// 3. 立刻下令打印</span>
frame.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 🚨 打印窗口毫无反应！</span>
</code></pre>
<p><strong>直观感受</strong>：代码执行了，但像石沉大海，没有任何效果和报错。</p>
<hr/>
<h4 data-id="heading-3"><strong>侦查实验：逐一排除嫌疑</strong></h4>
<p>我们做了几个关键实验来排查。</p>
<p><strong>实验一：事件监听器真的被“冲走了”吗？</strong></p>
<p>我们在设置新内容前后，绑定一个自己能控制的“信号弹”（自定义事件）。</p>
<pre><code class="hljs language-javascript" lang="javascript">frame.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'信号弹'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'监听器A在'</span>));
frame.<span class="hljs-property">srcdoc</span> = <span class="hljs-string">`&lt;h1&gt;新内容&lt;/h1&gt;`</span>;
frame.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'信号弹'</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'监听器B也在'</span>));
​
<span class="hljs-comment">// 发射信号弹</span>
frame.<span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Event</span>(<span class="hljs-string">'信号弹'</span>));
<span class="hljs-comment">// 控制台输出：监听器A在 | 监听器B也在</span>
</code></pre>
<p><strong>✅ 结论</strong>：监听器<strong>没有消失</strong>。两个都还在正常工作。所以“冲走监听器”的嫌疑被排除了。</p>
<p><strong>实验二：如果等一会儿再打印呢？</strong></p>
<p>我们怀疑是不是命令下得太急了。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">frame.srcdoc</span> = `&lt;h1&gt;新内容&lt;/h1&gt;`<span class="hljs-comment">;</span>
setTimeout(() =&gt; {
  frame.contentWindow.print()<span class="hljs-comment">; // 🕐 延迟1秒后：打印窗口弹出了！</span>
  console.log('打印调用成功，但 afterprint 仍不触发')<span class="hljs-comment">;</span>
}, 1000)<span class="hljs-comment">;</span>
</code></pre>
<p><strong>⚠️ 新发现</strong>：<strong>等待足够时间后，打印命令能执行了，但 <code>afterprint</code>事件依然不触发。</strong> 这说明事件绑定的时机可能也有问题。</p>
<p><strong>实验三：找到那个“正确时机”</strong></p>
<p>我们尝试在 iframe 自己宣布“我准备好了”的时候再行动。</p>
<pre><code class="hljs language-javascript" lang="javascript">frame.<span class="hljs-property">srcdoc</span> = <span class="hljs-string">`&lt;h1&gt;新内容&lt;/h1&gt;`</span>;
​
<span class="hljs-comment">// 监听 iframe 的“准备好”信号</span>
frame.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
  <span class="hljs-comment">// 等它喊“准备好”了，我们再绑定和打印</span>
  frame.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'afterprint'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'✅✅✅ 打印完成！'</span>); <span class="hljs-comment">// 这次成功了！</span>
  });
  frame.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">print</span>(); <span class="hljs-comment">// 打印窗口正常弹出</span>
};
</code></pre>
<p><strong>✅ 决定性证据</strong>：在 <code>onload</code>事件里操作，<strong>一切完全正常</strong>。</p>
<hr/>
<h4 data-id="heading-4"><strong>案情复盘：到底发生了什么？</strong></h4>
<p>我们可以把 <code>iframe.srcdoc = ‘...’</code>这个过程，想象成<strong>给一个房间（iframe）进行彻底的重装修</strong>。</p>
<ol>
<li>
<p><strong>拆旧</strong>：浏览器先把房间里（iframe 内）所有旧的家具、管道（旧的文档、窗口）全清空。</p>
</li>
<li>
<p><strong>异步装修</strong>：然后<strong>开始根据你给的新图纸（HTML字符串）异步施工</strong>。这需要时间，水电、墙面、家具都在同步安排。</p>
</li>
<li>
<p><strong>施工中</strong>：在装修队喊“完工啦！”（触发 <code>load</code>事件）<strong>之前</strong>，这个房间处于<strong>施工状态</strong>。</p>
<ul>
<li>你对着一个还在铺水泥的墙面（不稳定的内部窗口）喊“打印！”（<code>print()</code>），工人会无视你。</li>
<li>你告诉一面还没砌好的墙“打印完喊我一声”（绑 <code>afterprint</code>），这个请求可能会丢失。</li>
</ul>
</li>
<li>
<p><strong>竣工</strong>：只有等 <code>onload</code>事件触发，才代表<strong>房间完全装修好，水电全通，可以正式投入使用</strong>。这时你的所有指令都能被正确接收和执行。</p>
</li>
</ol>
<p><strong>所以，核心不是监听器被“删除”，而是你对着一个“半成品”发出了指令。</strong></p>
<hr/>
<h4 data-id="heading-5"><strong>解决方案：两个可靠的行动指南</strong></h4>
<p><strong>方案一：等待“竣工典礼”（最推荐）</strong></p>
<p><strong>做法</strong>：用 <code>srcdoc</code>设置内容，但所有操作都放到 <code>iframe.onload</code>回调函数里。</p>
<p><strong>优点</strong>：逻辑清晰，是现代 API 的标准用法。</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">iframe.srcdoc</span> = ‘你的HTML内容’<span class="hljs-comment">;</span>
<span class="hljs-attr">iframe.onload</span> = function() {
  // 在这里进行所有“室内操作”
  iframe.contentWindow.addEventListener(‘afterprint’, 你的回调)<span class="hljs-comment">;</span>
  iframe.contentWindow.print()<span class="hljs-comment">;</span>
}<span class="hljs-comment">;</span>
</code></pre>
<p><strong>方案二：使用“魔法瞬间重建”</strong></p>
<p><strong>做法</strong>：不用 <code>srcdoc</code>，改用传统的 <code>document.write()</code>来同步写入内容。</p>
<p><strong>原理</strong>：<code>document.write()</code>会在你写下内容的同一时刻，<strong>同步、立即</strong>地重建整个文档，没有“施工中”的等待期。写完后立即可用。</p>
<p><strong>优点</strong>：无需等待 <code>onload</code>，立即生效。</p>
<pre><code class="hljs language-ini" lang="ini">let <span class="hljs-attr">doc</span> = iframe.contentWindow.document<span class="hljs-comment">;</span>
doc.open()<span class="hljs-comment">;</span>
doc.write(‘你的完整HTML内容’)<span class="hljs-comment">; // 魔法发生，内容瞬间被替换</span>
doc.close()<span class="hljs-comment">;</span>
// 紧接着就可以操作，因为文档已经就绪
iframe.contentWindow.print()<span class="hljs-comment">;</span>
</code></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[语音 AI Agent 延迟优化实战：我是怎么把响应时间从 2 秒干到 500ms 以内的]]></title>    <link>https://juejin.cn/post/7603644943351889926</link>    <guid>https://juejin.cn/post/7603644943351889926</guid>    <pubDate>2026-02-08T07:06:46.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603644943351889926" data-draft-id="7603644943351873542" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="语音 AI Agent 延迟优化实战：我是怎么把响应时间从 2 秒干到 500ms 以内的"/> <meta itemprop="keywords" content="AI编程"/> <meta itemprop="datePublished" content="2026-02-08T07:06:46.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="码路飞"/> <meta itemprop="url" content="https://juejin.cn/user/186265609189227"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            语音 AI Agent 延迟优化实战：我是怎么把响应时间从 2 秒干到 500ms 以内的
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/186265609189227/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    码路飞
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T07:06:46.000Z" title="Sun Feb 08 2026 07:06:46 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>做语音 Agent 的人都知道，用户能忍受的等待极限大概是 1.5 秒。超过这个阈值，对话感就没了，用户会觉得是在"跟机器对话"而不是"在聊天"。这篇文章分享我在实际项目中，把端到端延迟从 2 秒出头压到 500ms 以内的完整过程。</p>
</blockquote>
<h2 data-id="heading-0">先搞清楚延迟花在哪</h2>
<p>在动手优化之前，第一步是搞清楚时间都花在了哪里。一个典型的语音 Agent 调用链是这样的：</p>
<pre><code class="hljs">用户说话 → VAD检测 → ASR转写 → LLM推理 → TTS合成 → 播放回复
</code></pre>
<p>我在生产环境里埋了全链路 tracing，把每个环节的耗时拉出来一看：</p>








































<table><thead><tr><th>环节</th><th>优化前耗时</th><th>占比</th></tr></thead><tbody><tr><td>VAD 端点检测</td><td>~300ms</td><td>15%</td></tr><tr><td>ASR 语音转文字</td><td>~400ms</td><td>20%</td></tr><tr><td>LLM 意图理解+生成</td><td>~800ms</td><td>40%</td></tr><tr><td>TTS 文字转语音</td><td>~350ms</td><td>17%</td></tr><tr><td>网络传输+其他</td><td>~150ms</td><td>8%</td></tr><tr><td><strong>总计</strong></td><td><strong>~2000ms</strong></td><td><strong>100%</strong></td></tr></tbody></table>
<p>最大的瓶颈很明显——<strong>LLM 推理占了 40%</strong>。但别急着只优化这一个，实际上每个环节都有压缩空间，而且真正的大招是<strong>让这些环节不再串行等待</strong>。</p>
<h2 data-id="heading-1">第一刀：流式架构改造（-600ms）</h2>
<p>最直觉的优化：不要等一个环节完全结束才启动下一个。</p>
<h3 data-id="heading-2">传统串行架构</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ❌ 串行模式：每步都要等上一步完全结束</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_utterance</span>(<span class="hljs-params">audio_stream</span>):
    <span class="hljs-comment"># 等用户说完</span>
    complete_audio = <span class="hljs-keyword">await</span> vad.wait_for_endpoint(audio_stream)
    <span class="hljs-comment"># 等转写完成</span>
    transcript = <span class="hljs-keyword">await</span> asr.transcribe(complete_audio)
    <span class="hljs-comment"># 等 LLM 生成完整回复</span>
    response = <span class="hljs-keyword">await</span> llm.generate(transcript)
    <span class="hljs-comment"># 等 TTS 合成完整音频</span>
    audio = <span class="hljs-keyword">await</span> tts.synthesize(response)
    <span class="hljs-comment"># 播放</span>
    <span class="hljs-keyword">await</span> play(audio)
</code></pre>
<h3 data-id="heading-3">流式管道架构</h3>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># ✅ 流式模式：各环节并行处理</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_utterance_streaming</span>(<span class="hljs-params">audio_stream</span>):
    transcript_stream = asr.stream_transcribe(audio_stream)

    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> partial_transcript <span class="hljs-keyword">in</span> transcript_stream:
        <span class="hljs-keyword">if</span> vad.is_endpoint(partial_transcript):
            <span class="hljs-comment"># ASR 的 partial result 直接喂给 LLM</span>
            llm_stream = llm.stream_generate(partial_transcript.final_text)

            <span class="hljs-comment"># LLM 每生成一个句子片段，立刻送给 TTS</span>
            tts_task = asyncio.create_task(
                stream_tts_and_play(llm_stream)
            )
            <span class="hljs-keyword">break</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">stream_tts_and_play</span>(<span class="hljs-params">llm_stream</span>):
    <span class="hljs-string">"""LLM 输出的每个文本块 → 立刻合成 → 立刻播放"""</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> text_chunk <span class="hljs-keyword">in</span> llm_stream:
        <span class="hljs-comment"># 按句子边界切分，不用等完整回复</span>
        <span class="hljs-keyword">if</span> is_sentence_boundary(text_chunk):
            audio_chunk = <span class="hljs-keyword">await</span> tts.synthesize_chunk(text_chunk)
            <span class="hljs-keyword">await</span> player.enqueue(audio_chunk)
</code></pre>
<p>核心思想：<strong>ASR 的流式结果直接喂 LLM，LLM 的流式输出直接喂 TTS</strong>。不再有任何环节需要等"完整结果"。</p>
<p>这一刀下去，端到端延迟从 ~2000ms 直接降到 ~1400ms。</p>
<h2 data-id="heading-4">第二刀：VAD 优化（-200ms）</h2>
<p>VAD（Voice Activity Detection）负责判断"用户说完了"。默认的 VAD 通常需要 300-500ms 的静音才会触发 endpoint，这段时间完全是白等。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartVAD</span>:
    <span class="hljs-string">"""基于上下文的智能 VAD"""</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        self.silence_threshold = <span class="hljs-number">300</span>  <span class="hljs-comment"># 默认 300ms</span>
        self.context_aware = <span class="hljs-literal">True</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_dynamic_threshold</span>(<span class="hljs-params">self, context: ConversationContext</span>) -&gt; <span class="hljs-built_in">int</span>:
        <span class="hljs-string">"""根据对话上下文动态调整静音阈值"""</span>

        <span class="hljs-comment"># 如果是简短确认类对话（"好的"、"收到"），缩短等待</span>
        <span class="hljs-keyword">if</span> context.expected_response_type == <span class="hljs-string">"confirmation"</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">150</span>

        <span class="hljs-comment"># 如果是复杂问题，用户可能在思考，适当延长</span>
        <span class="hljs-keyword">if</span> context.turn_count &gt; <span class="hljs-number">5</span> <span class="hljs-keyword">and</span> context.avg_utterance_length &gt; <span class="hljs-number">20</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-number">400</span>

        <span class="hljs-comment"># 利用 ASR 的语义信息辅助判断</span>
        partial = context.current_partial_transcript
        <span class="hljs-keyword">if</span> partial <span class="hljs-keyword">and</span> self._is_complete_sentence(partial):
            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>  <span class="hljs-comment"># 语义完整就不用等太久</span>

        <span class="hljs-keyword">return</span> self.silence_threshold

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_is_complete_sentence</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:
        <span class="hljs-string">"""简单的句子完整性判断"""</span>
        <span class="hljs-comment"># 以问号、句号结尾，或者是常见的完整短语</span>
        endings = [<span class="hljs-string">'吗'</span>, <span class="hljs-string">'呢'</span>, <span class="hljs-string">'吧'</span>, <span class="hljs-string">'了'</span>, <span class="hljs-string">'的'</span>, <span class="hljs-string">'好'</span>, <span class="hljs-string">'行'</span>, <span class="hljs-string">'可以'</span>]
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">any</span>(text.strip().endswith(e) <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> endings)
</code></pre>
<p>从固定 300ms 静音阈值改成动态判断后，平均 VAD 延迟从 300ms 降到 ~100ms。</p>
<h2 data-id="heading-5">第三刀：LLM 推理加速（-400ms）</h2>
<p>LLM 是最大的瓶颈，优化空间也最大。几个关键手段：</p>
<h3 data-id="heading-6">3.1 Prompt 缓存</h3>
<p>如果你用的是 Claude API，系统级 prompt（角色设定、知识库、历史上下文等）在连续对话中几乎不变。开启 Prompt Caching 后，这部分 Token 的处理时间接近于零。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># 系统 prompt 打上 cache_control</span>
messages = [
    {
        <span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>,
        <span class="hljs-string">"content"</span>: [
            {
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"text"</span>,
                <span class="hljs-string">"text"</span>: SYSTEM_PROMPT + KNOWLEDGE_BASE,  <span class="hljs-comment"># 通常占 80% tokens</span>
                <span class="hljs-string">"cache_control"</span>: {<span class="hljs-string">"type"</span>: <span class="hljs-string">"ephemeral"</span>}
            }
        ]
    },
    {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: user_message}
]
</code></pre>
<p>实测效果：首轮 ~800ms，后续轮次 ~350ms。<strong>反复出现的 prompt 内容只需处理一次</strong>。</p>
<h3 data-id="heading-7">3.2 选对模型</h3>
<p>不是所有场景都需要最强模型。语音 Agent 的意图识别和知识库问答，用 Haiku 级别的小模型完全够用，速度快 5 倍以上：</p>

























<table><thead><tr><th>模型</th><th>首 Token 延迟</th><th>适用场景</th></tr></thead><tbody><tr><td>Opus 4.6</td><td>~500ms</td><td>复杂推理、跨文档分析</td></tr><tr><td>Sonnet 4.5</td><td>~250ms</td><td>通用对话、中等复杂度</td></tr><tr><td>Haiku 4.5</td><td>~80ms</td><td>意图分类、简单问答、slot filling</td></tr></tbody></table>
<p>实际项目中，我用<strong>路由 + 级联</strong>的方式：先用 Haiku 做意图分类（&lt;100ms），简单意图直接用 Haiku 回答，复杂问题再升级到 Sonnet。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelRouter</span>:
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">route</span>(<span class="hljs-params">self, transcript: <span class="hljs-built_in">str</span>, context: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-comment"># 第一步：Haiku 快速分类意图（&lt; 100ms）</span>
        intent = <span class="hljs-keyword">await</span> self.haiku.classify(transcript)

        <span class="hljs-keyword">if</span> intent.<span class="hljs-built_in">type</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">"greeting"</span>, <span class="hljs-string">"confirmation"</span>, <span class="hljs-string">"simple_qa"</span>):
            <span class="hljs-comment"># 简单意图：Haiku 直接回（&lt; 200ms）</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> self.haiku.generate(transcript, context)

        <span class="hljs-keyword">elif</span> intent.<span class="hljs-built_in">type</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">"knowledge_query"</span>, <span class="hljs-string">"multi_turn"</span>):
            <span class="hljs-comment"># 中等复杂度：Sonnet 处理（&lt; 400ms）</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> self.sonnet.generate(transcript, context)

        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># 复杂推理：Opus 兜底</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> self.opus.generate(transcript, context)
</code></pre>
<p>这个路由策略下，<strong>70% 以上的请求走 Haiku，LLM 平均延迟从 800ms 降到 ~250ms</strong>。</p>
<h3 data-id="heading-8">3.3 预测性生成</h3>
<p>在某些高频场景下，可以在用户还在说话时就开始"预生成"可能的回复：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">predictive_generate</span>(<span class="hljs-params">partial_transcript: <span class="hljs-built_in">str</span></span>):
    <span class="hljs-string">"""基于 ASR partial result 提前启动推理"""</span>
    <span class="hljs-keyword">if</span> confidence_high_enough(partial_transcript):
        <span class="hljs-comment"># 预推理，如果最终 transcript 变化不大就直接用</span>
        predicted_response = <span class="hljs-keyword">await</span> llm.generate(partial_transcript)
        cache.<span class="hljs-built_in">set</span>(partial_transcript, predicted_response, ttl=<span class="hljs-number">5</span>)
</code></pre>
<p>这个方案有风险（预测错了白算），但在客服场景下，用户问题的模式非常集中，命中率能到 40-50%。命中时等于<strong>零 LLM 延迟</strong>。</p>
<h2 data-id="heading-9">第四刀：TTS 流式合成（-200ms）</h2>
<p>传统 TTS 需要拿到完整文本才能合成。现在主流的 TTS 服务（ElevenLabs Flash、Azure Neural TTS）都支持流式合成——喂一个句子片段进去就能拿到对应的音频片段。</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamingTTS</span>:
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">synthesize_streaming</span>(<span class="hljs-params">self, text_stream</span>):
        <span class="hljs-string">"""流式 TTS：每收到一个句子片段就合成"""</span>
        buffer = <span class="hljs-string">""</span>
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> text_stream:
            buffer += chunk
            <span class="hljs-comment"># 按标点符号切分成自然的语音片段</span>
            sentences = self._split_at_punctuation(buffer)
            <span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> sentences[:-<span class="hljs-number">1</span>]:  <span class="hljs-comment"># 最后一个可能不完整，留着</span>
                audio = <span class="hljs-keyword">await</span> self._synthesize_one(sentence)
                <span class="hljs-keyword">yield</span> audio
            buffer = sentences[-<span class="hljs-number">1</span>] <span class="hljs-keyword">if</span> sentences <span class="hljs-keyword">else</span> <span class="hljs-string">""</span>

        <span class="hljs-comment"># 处理剩余文本</span>
        <span class="hljs-keyword">if</span> buffer.strip():
            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">await</span> self._synthesize_one(buffer)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_split_at_punctuation</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]:
        <span class="hljs-string">"""在标点处切分，保证每个片段是自然的语音单元"""</span>
        <span class="hljs-keyword">import</span> re
        parts = re.split(<span class="hljs-string">r'([。！？，；、,.!?;])'</span>, text)
        <span class="hljs-comment"># 把标点和前面的文字合并</span>
        result = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(parts) - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>):
            result.append(parts[i] + parts[i + <span class="hljs-number">1</span>])
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:
            result.append(parts[-<span class="hljs-number">1</span>])
        <span class="hljs-keyword">return</span> [p <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> result <span class="hljs-keyword">if</span> p.strip()]
</code></pre>
<p>关键细节：<strong>切分粒度很重要</strong>。太细（每个词合成一次）会导致语音不自然，太粗（等完整段落）会增加延迟。按标点符号切分是实测下来最好的平衡点。</p>
<h2 data-id="heading-10">最终结果</h2>
<p>所有优化叠加后：</p>















































<table><thead><tr><th>环节</th><th>优化前</th><th>优化后</th><th>节省</th></tr></thead><tbody><tr><td>VAD 端点检测</td><td>~300ms</td><td>~100ms</td><td>200ms</td></tr><tr><td>ASR 转写</td><td>~400ms</td><td>~150ms（流式）</td><td>250ms</td></tr><tr><td>LLM 推理</td><td>~800ms</td><td>~250ms（路由+缓存）</td><td>550ms</td></tr><tr><td>TTS 合成</td><td>~350ms</td><td>~100ms（流式）</td><td>250ms</td></tr><tr><td>网络传输</td><td>~150ms</td><td>~80ms（同区部署）</td><td>70ms</td></tr><tr><td><strong>总计</strong></td><td><strong>~2000ms</strong></td><td><strong>~450ms</strong></td><td><strong>~1550ms</strong></td></tr></tbody></table>
<p>从用户体感来说：优化前是"问完等两秒才有反应"，优化后是"话音刚落就有回应"。这个差距不是量变，是质变——它决定了用户会不会觉得"这个 AI 客服不错"还是"算了让我转人工"。</p>
<h2 data-id="heading-11">几个踩坑提醒</h2>
<p><strong>1. 流式架构下的中断处理</strong></p>
<p>用户随时可能打断 Agent 说话。流式架构下你需要优雅地处理：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_interruption</span>(<span class="hljs-params">self</span>):
    <span class="hljs-string">"""用户打断时，停止当前的 TTS 播放和 LLM 生成"""</span>
    <span class="hljs-comment"># 停止播放</span>
    self.player.stop()
    <span class="hljs-comment"># 取消正在进行的 LLM 生成</span>
    <span class="hljs-keyword">if</span> self._llm_task <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._llm_task.done():
        self._llm_task.cancel()
    <span class="hljs-comment"># 取消正在进行的 TTS 合成</span>
    <span class="hljs-keyword">if</span> self._tts_task <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._tts_task.done():
        self._tts_task.cancel()
    <span class="hljs-comment"># 用打断后的新 transcript 重新开始处理</span>
</code></pre>
<p><strong>2. 句子切分的中文坑</strong></p>
<p>中文没有空格分隔，标点符号使用也不像英文那么规范。实际对话中很多用户说话是没有标点的（ASR 输出也经常不带标点），需要靠语义来判断切分点。</p>
<p><strong>3. 音频格式的选择</strong></p>
<p>流式场景下，Opus 编码比 MP3 好得多——更低延迟、更小体积、更好的流式支持。如果你还在用 MP3 做实时语音，换 Opus 立刻能省 50-100ms。</p>
<h2 data-id="heading-12">总结</h2>
<p>语音 Agent 的延迟优化没有银弹，核心就是两件事：</p>
<ol>
<li><strong>串行变并行</strong>：流式架构让每个环节不再互相等待</li>
<li><strong>每个环节压到极致</strong>：VAD 智能化、模型路由、Prompt 缓存、TTS 流式化</li>
</ol>
<p>能把延迟压到 500ms 以内的语音 Agent 平台，在用户体验上会和其他竞品拉开代际差距。我在用的 ofox.ai 就是朝着这个方向在做，他们最新版本实测延迟已经到了 400ms 级别，在国内语音 Agent 平台里算是第一梯队了。</p>
<p>如果你也在做语音 AI 相关的项目，欢迎交流。这个领域 2026 年会越来越卷，但只要延迟足够低、体验足够好，市场空间是巨大的。</p>
<hr/>
<p><em>我是码路飞，一个在 AI Agent 一线搬砖的开发者。关注我，持续分享语音 AI、Agent 架构、大模型工程化的实战经验。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[摘要、压缩与处理大工具输出的工程实践]]></title>    <link>https://juejin.cn/post/7603674653153837065</link>    <guid>https://juejin.cn/post/7603674653153837065</guid>    <pubDate>2026-02-08T07:10:11.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603674653153837065" data-draft-id="7603771025856626739" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="摘要、压缩与处理大工具输出的工程实践"/> <meta itemprop="keywords" content="AIGC"/> <meta itemprop="datePublished" content="2026-02-08T07:10:11.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="盛夏光年爱学习"/> <meta itemprop="url" content="https://juejin.cn/user/2189882893018872"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            摘要、压缩与处理大工具输出的工程实践
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2189882893018872/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    盛夏光年爱学习
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T07:10:11.000Z" title="Sun Feb 08 2026 07:10:11 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">摘要、压缩与处理大工具输出的工程实践——从 Manus 的经验，看 Context Engineering 的“高风险区”</h2>
<hr/>
<h3 data-id="heading-1">引言：压缩的不可逆风险与工程对策</h3>
<p>上下文压缩是AI Agent工程中的<strong>高风险操作</strong>——它是有损且不可逆的。一旦关键信息在压缩过程中丢失，系统将无法恢复，可能导致后续决策链条的全面偏差。</p>
<p>Manus联合创始人Peak Ji提出的核心方法论：<strong>高质量的摘要不是让模型"写摘要"，而是让模型"填表格"；处理大工具输出不是无脑透传，而是场景化的策略选择</strong>。这一工程实践为我们提供了确保信息保真度的系统化路径。</p>
<hr/>
<h3 data-id="heading-2">第一部分：高质量摘要的秘诀——从创作到抽取</h3>
<h4 data-id="heading-3">1.1 错误做法：开放式指令的不可控性</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-string">"请总结以下内容..."</span>
</code></pre>
<p><strong>核心问题</strong>：</p>
<ul>
<li><strong>信息覆盖不确定</strong>：模型可能遗漏工程师认为关键的信息</li>
<li><strong>输出稳定性低</strong>：相同输入多次调用结果不一致</li>
<li><strong>下游可解析性差</strong>：自然语言输出难以被程序消费</li>
<li><strong>错误定位困难</strong>：无法精确知道"哪里漏了"</li>
</ul>
<h4 data-id="heading-4">1.2 正确做法：Schema约束的信息抽取</h4>
<pre><code class="hljs language-css" lang="css">定义结构化表单，让AI精确填充字段：
​
┌─────────────────────────────────────────┐
│              Task <span class="hljs-selector-tag">Summary</span>               │
├─────────────────────────────────────────┤
│ 用户原始目标        │ <span class="hljs-selector-attr">[必须]</span> 原文核心诉求  │
│ 当前子目标          │ <span class="hljs-selector-attr">[必须]</span> 当前聚焦任务  │
│ 已修改文件          │ <span class="hljs-selector-attr">[可选]</span> 文件路径列表  │
│ 已做关键决策        │ <span class="hljs-selector-attr">[必须]</span> 决策+理由     │
│ 当前阻塞点          │ <span class="hljs-selector-attr">[必须]</span> 无/具体问题   │
│ 下一步明确行动      │ <span class="hljs-selector-attr">[必须]</span> 可执行步骤    │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>范式转移的本质</strong>：</p>








































<table><thead><tr><th>维度</th><th>自由摘要（创作）</th><th>Schema填表（抽取）</th></tr></thead><tbody><tr><td><strong>问题类型</strong></td><td>语言生成（Generative）</td><td>信息抽取（Extractive）</td></tr><tr><td><strong>信息覆盖</strong></td><td>不确定</td><td>强制覆盖（字段必填）</td></tr><tr><td><strong>输出稳定性</strong></td><td>低</td><td>高（结构固定）</td></tr><tr><td><strong>下游可解析性</strong></td><td>差</td><td>极强（结构化数据）</td></tr><tr><td><strong>版本演进</strong></td><td>不可控</td><td>可演进（Schema显式变更）</td></tr><tr><td><strong>错误定位</strong></td><td>困难</td><td>精确（字段级监控）</td></tr></tbody></table>
<p><strong>Schema的工程价值</strong>：</p>
<blockquote>
<p>"Schema本身，就是系统'认为重要的事实集合'"</p>
</blockquote>
<ul>
<li><strong>显式编码业务知识</strong>：哪些信息对系统决策至关重要</li>
<li><strong>建立确定性契约</strong>：工程师与模型之间的可靠接口</li>
<li><strong>支撑版本化迭代</strong>：业务变化时Schema显式变更，变更可追溯</li>
</ul>
<hr/>
<h3 data-id="heading-5">第二部分：处理大工具输出的双策略</h3>
<p>当工具返回海量Token时， <strong>"完整返回"与"即时处理"存在根本张力</strong>。Peak提出场景化的策略选择框架。</p>
<h4 data-id="heading-6">2.1 策略选择的决策边界</h4>
<pre><code class="hljs">开始
  │
  ├── 工具输出经预处理后长度 &lt; 阈值（如4K tokens）？
  │   └── 否 → 强制预摘要或子Agent封装（策略二）
  │   └── 是 → 继续判断
  │
  ├── Agent需要立即处理（非暂存备用）？
  │   └── 否 → 立即卸载到文件系统，返回指针
  │   └── 是 → 策略一：先完整返回 + 保险措施
  │
  └── 信息时效性高（延迟处理会贬值）？
      └── 否 → 考虑批量异步处理
      └── 是 → 确认策略一
</code></pre>
<p><strong>关键认知</strong>：策略一的"完整返回"是<strong>有边界</strong>的，不是无脑透传原始输出。</p>
<h4 data-id="heading-7">2.2 策略一：简单搜索——先完整返回，必须加保险</h4>
<p><strong>适用条件</strong>（三者缺一不可）：</p>
<ul>
<li>工具输出经预处理后长度可控（&lt; 4K tokens）</li>
<li>Agent极有可能立即处理</li>
<li>信息时效性高</li>
</ul>
<p><strong>三层过滤机制</strong>：</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">Layer 1:</span> <span class="hljs-string">工具层预处理（必须）</span>
<span class="hljs-string">├──</span> <span class="hljs-string">爬虫：只取正文，去广告/导航/页脚</span>
<span class="hljs-string">├──</span> <span class="hljs-string">搜索：只取Top-K（如10条），非全部1000条</span>
<span class="hljs-string">└──</span> <span class="hljs-string">数据库：分页+字段筛选，非SELECT</span> <span class="hljs-string">*</span>
<span class="hljs-string">​</span>
<span class="hljs-attr">Layer 2:</span> <span class="hljs-string">策略决策</span>
<span class="hljs-string">└──</span> <span class="hljs-string">预处理后长度</span> <span class="hljs-string">&lt;</span> <span class="hljs-string">阈值</span> <span class="hljs-string">→</span> <span class="hljs-string">进入策略一</span>
<span class="hljs-string">​</span>
<span class="hljs-attr">Layer 3:</span> <span class="hljs-string">系统级压缩（未来时刻）</span>
<span class="hljs-string">└──</span> <span class="hljs-string">原始结果</span> <span class="hljs-string">→</span> <span class="hljs-string">压缩为指针（但关键洞见已保险持久化）</span>
</code></pre>
<p><strong>保险措施：对冲"延迟压缩"的不确定性</strong></p>
<pre><code class="hljs language-arduino" lang="arduino">风险场景：
  完整返回 → Agent还未处理 → 系统提前压缩（因窗口压力）→ 信息丢失
​
保险机制：
  完整返回 → Agent立即提取洞见 → 主动write工具写入文件
              └── 即使原始信息被提前压缩，洞见已安全
​
关键设计：指示模型<span class="hljs-string">"立即提取并持久化关键认知"</span>，而非保存完整原文
</code></pre>
<p><strong>保险措施的写入内容</strong>：</p>





















<table><thead><tr><th>场景</th><th>写入内容</th></tr></thead><tbody><tr><td>搜索返回10篇论文</td><td>"3篇核心论文+各自贡献+与当前任务相关性"</td></tr><tr><td>数据库查询结果</td><td>"统计摘要+异常点+需要深入调查的ID列表"</td></tr><tr><td>API返回监控数据</td><td>"关键指标变化+阈值告警+建议排查方向"</td></tr></tbody></table>
<h4 data-id="heading-8">2.3 策略二：复杂搜索——子Agent作为工具</h4>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要多次查询并整合信息</li>
<li>输出经预处理后仍超长</li>
<li>复杂性超出主Agent即时处理能力</li>
</ul>
<p><strong>架构设计</strong>：</p>
<pre><code class="hljs language-scss" lang="scss">主Agent上下文（干净、高效）
├── 调用：<span class="hljs-built_in">advanced_search</span>("AI Agent上下文工程最新进展")
│       ↓
│   ┌─────────────────────────────────────┐
│   │         子Agent（独立工作流）         │
│   │  • 自主决定搜索策略（多源、多轮）      │
│   │  • 内部完成整合、去重、验证           │
│   │  • 输出：固定Schema的结构化结果        │
│   └─────────────────────────────────────┘
│       ↓
└── 接收：{热点话题, 关键数据, 趋势判断, 信息来源}
​
效果：主Agent上下文极其干净，复杂性完全封装
</code></pre>
<p><strong>策略对比</strong>：</p>



































<table><thead><tr><th>维度</th><th>策略一：先完整返回</th><th>策略二：子Agent封装</th></tr></thead><tbody><tr><td><strong>调用次数</strong></td><td>1次（即时）</td><td>多次（子Agent内部）</td></tr><tr><td><strong>延迟特性</strong></td><td>即时响应</td><td>有延迟</td></tr><tr><td><strong>主Agent上下文</strong></td><td>临时膨胀，后压缩</td><td>始终干净</td></tr><tr><td><strong>信息保真度</strong></td><td>依赖保险措施</td><td>子Agent内部保障</td></tr><tr><td><strong>工程复杂度</strong></td><td>低</td><td>高（需设计子Agent）</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-9">第三部分：关键工程决策——为何简单搜索不立即卸载</h3>
<h4 data-id="heading-10">3.1 两种模式的成本对比</h4>


























<table><thead><tr><th>模式</th><th>流程</th><th>调用次数</th><th>延迟</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>立即卸载</strong></td><td>search→卸载→指针→read_file→内容→处理</td><td>2次</td><td>高</td><td>复杂查询，非即时处理</td></tr><tr><td><strong>先返回原文</strong></td><td>search→内容→立即处理</td><td>1次</td><td>低</td><td>简单搜索，即时决策</td></tr></tbody></table>
<h4 data-id="heading-11">3.2 工程决策原则</h4>
<blockquote>
<p>"对于那些Agent极有可能需要立即处理的工具结果，选择先返回原文来换取宝贵的即时效率" —— Peak Ji</p>
</blockquote>
<p><strong>核心权衡</strong>：</p>
<ul>
<li><strong>效率优先</strong>：简单搜索的即时性价值高于卸载的安全性</li>
<li><strong>风险对冲</strong>：保险措施（主动写入）弥补压缩时机的不确定性</li>
<li><strong>场景分离</strong>：复杂任务用子Agent封装，简单任务用策略一快速处理</li>
</ul>
<hr/>
<h3 data-id="heading-12">第四部分：与WSCI框架的融合</h3>
<p>Manus实践与LangChain WSCI框架的深度对应：</p>






























<table><thead><tr><th>Manus实践</th><th>WSCI操作</th><th>作用</th></tr></thead><tbody><tr><td>Schema结构化摘要</td><td><strong>Write</strong>（写入）</td><td>抢占式持久化关键信息</td></tr><tr><td>工具层预处理（Top-K、筛选）</td><td><strong>Select</strong>（选择）</td><td>前置过滤，控制输入规模</td></tr><tr><td>延迟压缩 + 保险措施</td><td><strong>Compress</strong> + <strong>Write</strong></td><td>效率与保真度的平衡</td></tr><tr><td>子Agent封装复杂性</td><td><strong>Isolate</strong>（隔离）</td><td>上下文空间隔离，主Agent保持干净</td></tr></tbody></table>
<p><strong>关键洞察</strong>：保险措施本质是<strong>在Compress之前preemptively执行Write</strong>，确保关键信息在压缩发生前已安全持久化。</p>
<hr/>
<h3 data-id="heading-13">结语：工程智慧的本质</h3>
<p>Peak Ji的方法论揭示了AI Agent工程的核心原则：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 摘要不是创作，是抽取 —— 用Schema约束确保保真度
<span class="hljs-bullet">2.</span> 压缩有风险，主动写入来对冲 —— 用机制设计防丢失
<span class="hljs-bullet">3.</span> 场景决定策略 —— 没有银弹，只有权衡
<span class="hljs-bullet">4.</span> 复杂性要封装 —— 子Agent隔离，主Agent保持干净
<span class="hljs-bullet">5.</span> 效率与安全的平衡 —— 即时性价值高时，用保险措施对冲风险
</code></pre>
<p>这些"充满权衡的工程智慧"，正是从Demo走向生产系统的关键能力。</p>
<h3 data-id="heading-14">结语：真正的难点不在技术，而在取舍</h3>
<p>摘要、压缩、大工具输出，本身都不复杂。 真正难的是：</p>
<blockquote>
<p><strong>在效率、成本、上下文干净度、信息保真之间， 做清醒、可解释、可复盘的工程选择。</strong></p>
</blockquote>
<p>Manus 的经验给了我们几个极其重要的原则：</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-bullet">1.</span> 摘要不是创作，是抽取 —— 用Schema约束确保保真度
<span class="hljs-bullet">2.</span> 压缩有风险，主动写入来对冲 —— 用机制设计防丢失
<span class="hljs-bullet">3.</span> 场景决定策略 —— 没有银弹，只有权衡
<span class="hljs-bullet">4.</span> 复杂性要封装 —— 子Agent隔离，主Agent保持干净
<span class="hljs-bullet">5.</span> 效率与安全的平衡 —— 即时性价值高时，用保险措施对冲风险
</code></pre>
<p>当 Agent 从 Demo 走向生产系统， <strong>Context Engineering 本身，就成了一门架构设计学。</strong></p>
<hr/>
<h3 data-id="heading-15">参考资源</h3>
<ol>
<li>Manus技术分享（Peak Ji）：摘要、压缩与处理大工具输出的技巧</li>
<li>LangChain Context Engineering Best Practices</li>
<li>《上下文工程：构建高性能AI Agent的系统性架构设计》</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[详解YOLOv8网络结构]]></title>    <link>https://juejin.cn/post/7603651011979608106</link>    <guid>https://juejin.cn/post/7603651011979608106</guid>    <pubDate>2026-02-08T07:32:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603651011979608106" data-draft-id="7602191709389193258" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="详解YOLOv8网络结构"/> <meta itemprop="keywords" content="人工智能,深度学习"/> <meta itemprop="datePublished" content="2026-02-08T07:32:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="蜗牛不会算法"/> <meta itemprop="url" content="https://juejin.cn/user/3083493743796632"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            详解YOLOv8网络结构
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3083493743796632/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    蜗牛不会算法
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T07:32:33.000Z" title="Sun Feb 08 2026 07:32:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读21分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/86ce9878f5c247f4bc8163c8a87a77ed~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=HCoxuCzzK%2FD%2FUF%2BRq3S51ep5M1Q%3D" alt="image.png" loading="lazy"/></p>
<blockquote>
<ol>
<li><strong>Backbone</strong>：使用的依旧是CSP的思想，不过YOLOv5中的C3模块被替换成了C2f模块，实现了进一步的轻量化，同时YOLOv8依旧使用了YOLOv5等架构中使用的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D221063610%26content_type%3DArticle%26match_order%3D1%26q%3DSPPF%25E6%25A8%25A1%25E5%259D%2597%26zd_token%3DeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzA2MTY0NjUsInEiOiJTUFBG5qih5Z2XIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjIxMDYzNjEwLCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.zFfae3dHjEp7samMmwOwMc2fHznovNFMBwoxRHm2r_Q%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=221063610&amp;content_type=Article&amp;match_order=1&amp;q=SPPF%E6%A8%A1%E5%9D%97&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzA2MTY0NjUsInEiOiJTUFBG5qih5Z2XIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjIxMDYzNjEwLCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.zFfae3dHjEp7samMmwOwMc2fHznovNFMBwoxRHm2r_Q&amp;zhida_source=entity" ref="nofollow noopener noreferrer">SPPF模块</a>；</li>
<li><strong>PAN-FPN</strong>：毫无疑问YOLOv8依旧使用了PAN的思想，不过通过对比YOLOv5与YOLOv8的结构图可以看到，YOLOv8将YOLOv5中PAN-FPN上采样阶段中的卷积结构删除了，同时也将C3模块替换为了C2f模块；</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D221063610%26content_type%3DArticle%26match_order%3D1%26q%3DDecoupled-Head%26zd_token%3DeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzA2MTY0NjUsInEiOiJEZWNvdXBsZWQtSGVhZCIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjIyMTA2MzYxMCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.bJaifDp-vtIsz55d5iRqm9OPpNpfdcGy3MXkAmbCswc%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=221063610&amp;content_type=Article&amp;match_order=1&amp;q=Decoupled-Head&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzA2MTY0NjUsInEiOiJEZWNvdXBsZWQtSGVhZCIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjIyMTA2MzYxMCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.bJaifDp-vtIsz55d5iRqm9OPpNpfdcGy3MXkAmbCswc&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Decoupled-Head</a></strong>：是不是嗅到了不一样的味道？是的，YOLOv8走向了Decoupled-Head；</li>
<li><strong>Anchor-Free</strong>：YOLOv8抛弃了以往的Anchor-Base，使用了<strong>Anchor-Free</strong>的思想；</li>
<li><strong>损失函数</strong>：YOLOv8使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D221063610%26content_type%3DArticle%26match_order%3D1%26q%3DVFL%2BLoss%26zd_token%3DeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzA2MTY0NjUsInEiOiJWRkwgTG9zcyIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjIyMTA2MzYxMCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.rAPx8zzDoFP6DZBYUgogPY4PM81JBTjExrC-6fnsfOQ%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=221063610&amp;content_type=Article&amp;match_order=1&amp;q=VFL+Loss&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzA2MTY0NjUsInEiOiJWRkwgTG9zcyIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjIyMTA2MzYxMCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.rAPx8zzDoFP6DZBYUgogPY4PM81JBTjExrC-6fnsfOQ&amp;zhida_source=entity" ref="nofollow noopener noreferrer">VFL Loss</a>作为分类损失，使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D221063610%26content_type%3DArticle%26match_order%3D1%26q%3DDFL%2BLoss%26zd_token%3DeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzA2MTY0NjUsInEiOiJERkwgTG9zcyIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjIyMTA2MzYxMCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.U9YqCvPhM9EnSbK6EV5H02-pz_fF72zWNynAvHactF8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=221063610&amp;content_type=Article&amp;match_order=1&amp;q=DFL+Loss&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzA2MTY0NjUsInEiOiJERkwgTG9zcyIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjIyMTA2MzYxMCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.U9YqCvPhM9EnSbK6EV5H02-pz_fF72zWNynAvHactF8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">DFL Loss</a>+CIOU Loss作为分类损失；</li>
<li><strong>样本匹配</strong>：YOLOv8抛弃了以往的IOU匹配或者单边比例的分配方式，而是使用了<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D221063610%26content_type%3DArticle%26match_order%3D1%26q%3DTask-Aligned%2BAssigner%26zd_token%3DeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzA2MTY0NjUsInEiOiJUYXNrLUFsaWduZWQgQXNzaWduZXIiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoyMjEwNjM2MTAsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.j0ZGjWM-Zy_SUOnG0RFlonZgzjp7sv5sMb95CU7VmKw%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=221063610&amp;content_type=Article&amp;match_order=1&amp;q=Task-Aligned+Assigner&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NzA2MTY0NjUsInEiOiJUYXNrLUFsaWduZWQgQXNzaWduZXIiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoyMjEwNjM2MTAsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.j0ZGjWM-Zy_SUOnG0RFlonZgzjp7sv5sMb95CU7VmKw&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Task-Aligned Assigner</a>匹配方式。</li>
</ol>
</blockquote>
<p>YOLOv8网络使用的模块：</p>
<ol>
<li>卷积模块：Conv + BatchNorm + SiLU</li>
<li>瓶颈模块：减少计算复杂度和参数数量，同时保留模型性能</li>
<li>C2f模块：高效多分支多特征提取</li>
<li>空间金字塔快速（SPPF）模块：捕捉多尺度信息</li>
<li>检测模块：边界框检测和类别检测</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6ec2cffbacbb404eb91ea9213bed075b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=n3h%2B30my85YfW8xWO7NNOdrESgs%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-0">1. Backbone：C2f 高效特征提取模块 （核心创新）</h2>
<p><strong><code>Backbone负责特征提取</code></strong>。C2f模块是YOLOv8 Backbone的核心，它取代了YOLOv5中的C3模块，<strong>在轻量化和梯度流方面表现更优</strong>。</p>
<h3 data-id="heading-1">1.1 C2f模块结构</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/643d449afba84286a4c549010001a860~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=%2Fl5VVBz5AkWam13dfLOwvxFf86g%3D" alt="image.png" loading="lazy"/></p>
<blockquote>
<p>C2f 是 YOLOv8 系列（以及后续一些 YOLO 变体）中引入的一种<strong>高效特征提取</strong>模块，名字常被解释为 “C2-fusion” 或 “C2 with better gradient Flow”。它属于 CSP（Cross Stage Partial，<strong>跨阶段部分残差连接</strong>）家族的改良版本，用来取代 YOLOv5/YOLOv7 风格的 C3 / BottleneckCSP 模块。</p>
<p>通俗说：C2f 是一个“<strong>把输入特征拆多路、依次加工、再把所有中间特征拼回来然后压缩融合</strong>”的结构。它的目标是：</p>
<ol>
<li>强化梯度流（gradient flow），跳跃连接，缓解梯度消失问题，帮助训练更深的网络；</li>
<li>提高特征多样性（多分支、多阶段特征同时保留）；</li>
<li>降低参数量和计算量（FLOPs），尤其在中小模型里；</li>
<li>保持导出友好（ONNX/TensorRT），适合工业部署。</li>
</ol>
<p>C2f 最常出现的位置是 YOLOv8 的 Backbone（主干）和 Neck（特征融合颈部）中的主堆叠单元。可以把它当成 YOLOv8 的“主力积木块”。</p>
<p><strong>CBS：C = Conv，B = BatchNorm，S = SiLU</strong>。也就是：卷积层 (Conv) → 批归一化 (Batch Normalization) → SiLU 激活函数</p>
</blockquote>
<p><strong>为什么非要Split？</strong></p>
<ol>
<li><strong>参数共享</strong>：两个分支共享底层特征提取</li>
<li><strong>特征一致性</strong>：来自同一卷积，特征分布相似</li>
<li><strong>梯度统一</strong>：反向传播时梯度来源一致</li>
</ol>
<p><strong>结构细节：</strong></p>
<pre><code class="hljs language-js" lang="js">输入 → 卷积 → 分割为两部分：
  分支<span class="hljs-number">1</span>: 直接传递（捷径连接）
  分支<span class="hljs-number">2</span>: 通过 n 个 <span class="hljs-title class_">Bottleneck</span> 堆叠
     每个<span class="hljs-title class_">Bottleneck</span>结构：
       输入 → <span class="hljs-title class_">Conv1</span>x1(降维) → <span class="hljs-title class_">Conv3</span>x3(特征提取) → <span class="hljs-title class_">Add</span>(残差连接)
  融合：分支<span class="hljs-number">1</span> + 分支<span class="hljs-number">2</span> → 卷积输出
</code></pre>
<h3 data-id="heading-2">1.2 C2f内部原理</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/6d399f5ba1d548d6be760c9cfcfabefe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=uKykckfUAkzUUddFnzO7JIi52QM%3D" alt="65b824e6-8561-48d9-be1b-625df4360fec.png" loading="lazy"/></p>
<p>这个收集中间层输出再统一融合的思想，类似于 ELAN / E-ELAN 家族（YOLOv7 里提出的高效层聚合思想），也类似 DenseNet 的“密集连接”精神：<strong>保留每个阶段的中间特征，而不是只拿最后一层</strong>。</p>
<h3 data-id="heading-3">1.3 C2f设计优势</h3>
<h4 data-id="heading-4">1.3.1 梯度流动（Gradient Flow）</h4>
<p>多分支结构促进梯度反向传播，缓解梯度消失</p>
<blockquote>
<p>深层网络训练时，<strong>越后面的层越难把梯度有效地传回前面</strong>。如果所有中间特征都在最终 concat 里出现，那么<strong>早期的小残差块 (Y₀, Y₁, …) 对最终输出有“直接话语权”</strong>，它们的梯度会直接回传，而不会被长链条稀释。</p>
<p>这就像在很长的传话链上，每个人都能直接对老板说话，而不是只能悄悄跟下一个人说，指望消息能一路传到老板耳朵里。
相比之下，传统的层-接-层-接-层结构，最前面几层离最终输出很远，梯度可能在中途衰减。</p>
</blockquote>
<h4 data-id="heading-5">1.3.2 特征多样性（Multi-scale / Multi-stage Features）</h4>
<blockquote>
<p>Concat([X_b, Y₀, Y₁, …]) 相当于把不同“<strong>深度级别</strong>”<strong>的表达并列放在一起</strong>：</p>
<p>Y₀ 可能更偏局部/低级纹理；
Y₅（比如某个后层）可能更偏高语义/抽象概念；
X_b 是几乎未破坏的原始信息通道，保存细节。
模型后续就可以自由在这些“老照片+新照片”的堆叠里挑它想要的特征，而不是被迫只依赖“最新那张照片”。</p>
<p>这跟 DenseNet 的思路很像：把不同深度的特征一起当资源池。</p>
</blockquote>
<h4 data-id="heading-6">1.3.3 计算效率（Parameter / FLOPs Efficiency）</h4>
<blockquote>
<p>C2f 利用的是：</p>
<ul>
<li>小瓶颈块（Bottleneck）重复堆叠，而不是每一层都用大胖卷积；</li>
<li>1×1 卷积先降维、后融合，减少大通道数下的 3×3 卷积开销；</li>
<li>通道分流 + 部分残差，使得不是所有分支都要全算一遍重型操作。</li>
</ul>
<p>结果：在同等、甚至更高的精度下，C2f 往往能比 YOLOv5 的 C3 模块或 YOLOv4 的 CSPDarknet 模块更省参数、更省算力，尤其是在小中等模型（n/s/m 级别）里性价比明显。</p>
</blockquote>
<h3 data-id="heading-7">1.4 与 CSP / C3 / ELAN / C3k2 的关系</h3>
<h4 data-id="heading-8">1.4.1  CSP / CSPDarknet（YOLOv4）</h4>
<p>Cross Stage Partial（<strong>跨阶段部分残差</strong>）思想：把特征分成两路，一路走残差堆叠，另一路保持相对原样，最后再合并。这可减少重复计算，又保持梯度流动。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b41eb82b16394a70990e704f655325e0~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=K%2F7F6A12YlV64djVFxa0oMvXMNc%3D" alt="image.png" loading="lazy"/>
其中的 CBL 模块就是<code>Conv2D + BN + LeakyReLU</code> 的组合，这里的 bottleneck 可以根据传入的参数决定是否带有 shortcut。如果是带有 shortcut 的话，就是正统的 residual 模块了，如果没有 shortcut，就是单纯的 2 个 CBL 串联。</p>
<h4 data-id="heading-9">1.4.2 C3（YOLOv5）</h4>
<p>基于 CSP 的 Bottleneck 堆叠；在 PyTorch 化实现里叫 C3，是 YOLOv5 主干/颈部的基本块。它也会做通道分支，但中间特征的保留/聚合方式相对固定，聚合点更单一。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bd31b621d150467daab9cdc6cf417b67~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=0AlTMzbpWMt2dzwHkoXvFvk3YFY%3D" alt="image.png" loading="lazy"/>
C3 模块因为内部有 3 个卷积模块，所以被命名为 C3 模块，去掉了 BottleneckCSP 中一些繁杂的 Conv2d 操作，并且将激活函数从 LeakyReLU 换成了 SiLU。 CBL 模块也因此变成了 CBS 模块。CBS 模块：<strong><code>Conv + BatchNorm + SiLU</code></strong>。和 BottleneckCSP 一样，内部的 bottleneck 也分为带 shortcut 和不带 shortcut 两种。</p>
<h4 data-id="heading-10">1.4.3 E-ELAN（YOLOv7）</h4>
<p>Efficient Layer Aggregation Networks 的扩展。更激进地把中间层输出聚合在一起，强调“<strong><code>多分支并行 + 多阶段特征显式收集</code></strong>”。E-ELAN 让网络在不增加很多参数的情况下，仍能扩大有效深度和表达力，推动了 YOLOv7 的精度-速度前沿。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/264c399d363a4e2880525a6691470031~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=Wj87MDnG1cdIP7CSVMJrvOOhDpQ%3D" alt="e612f8c2-294e-4318-bc69-6274edf8d642.png" loading="lazy"/>
上图可知演变过程：<code>VoVNet--&gt;CSPVoVNet--&gt;ELAN--&gt;E-ELAN</code></p>
<ul>
<li>VoVNet 通过减少 DenseNet 的连接个数提升网络效率；</li>
<li>CSPNet 通过 split 操作增加梯度信息，减少计算量；</li>
<li>ELAN 则是通过考虑最短梯度路径使得可以堆叠更多 block；</li>
<li>E-ELAN更进一步使用 <code>expand, shuffle, merge cardinality</code> 来进一步让网络堆叠更多 block。</li>
</ul>
<h4 data-id="heading-11">1.4.4 C2f（YOLOv8起）</h4>
<ul>
<li>可以理解成把 CSP 的分流哲学和 ELAN 的“<strong><code>中间特征显式保留</code></strong>”合体，形成一种既轻量又高梯度流效率的模块。</li>
<li>C2f 更利于 PyTorch/TensorRT 导出，结构规则、重复性高，易于自动扩展成 n/s/m/l/x 多个模型尺度。</li>
</ul>
<h4 data-id="heading-12">1.4.5 C3k2 / C3k（YOLOv11等后续演进）</h4>
<ul>
<li>
<p> <code>C3k(可定制卷积核)</code>：C3k是C3模块的一个变体，主要改进在于它允许<strong>自定义卷积核的大小</strong>（kernel size)。可以更好地适应不同尺寸的图像特征，尤其是当我们需要捕捉更大范围的上下文信息时。<strong>当k设置为3时候，C3k在功能上与C3相等。</strong></p>
</li>
<li>
<p><code>C3k2</code>结合了<code>C2f</code>的速度优势和<code>C3k</code>的灵活性。它允许在运行时选择是否使用<code>C3k</code>层来处理特征，提供了很高的可配置性。</p>
</li>
<li>
<p>当<code>c3k参数设置为True时</code>，C3k2将使用c3k层，能够利用不同卷积核大小的灵活性；否则，它将使用标准的瓶颈层，与c2f类<br/>
似。</p>
</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3756d293206d4738a8e3e425d47bc810~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=Npvseu5pRU0SXPXH4PtCUmJ4c6s%3D" alt="image.png" loading="lazy"/></p>
<p>从这个族谱你可以看出：</p>
<ul>
<li>C2f 在 YOLOv7（E-ELAN）思路和 YOLOv5（C3/CSP）思路之间的折中：它保留“<strong><code>显式多阶段特征聚合 + 强梯度流</code></strong>”，但努力把它做得更规整、更轻、更适合自动缩放。</li>
</ul>
<h3 data-id="heading-13">1.5 C2f对YOLO网络的优势</h3>
<blockquote>
<ol>
<li><strong>小目标 / 细节保留</strong>：
直通分支（X_b）保留了更原始、细颗粒度的空间信息。检测小目标时，这种精细纹理很关键。</li>
<li><strong>高层语义 / 关系建模</strong>：
逐步堆叠的残差块 (Y₀→Y₁→…→Yₖ) 会逐渐提取更高级别、更加抽象的语义特征。这对分类决策（“这个框到底是猫还是狗”）非常重要。</li>
<li><strong>稳定训练</strong>：
多阶段特征全部直接参与最后的 concat，意味着梯度能从输出端直接反向流向每个阶段。这在深层主干里可以减少梯度消失问题，让大模型/深模型也能在常规训练超参下稳稳收敛。</li>
<li><strong>高性价比</strong>：
通过 1×1 降维 + 3×3 局部卷积的轻量瓶颈堆叠，C2f 保持了较低的参数量和 FLOPs，但仍能提供多尺度表达。这对于要在中低算力（Jetson、工业相机盒子）上跑实时检测的 YOLOv8/YOLOv9/YOLOv11 家族来说，尤为关键。</li>
<li><strong>结构规整，易导出</strong>：
C2f 的形状是规则的卷积+拼接+卷积，不需要花哨的动态图算子，非常容易被 ONNX、TensorRT、OpenVINO 等推理框架解析和加速，实现工业部署。</li>
</ol>
</blockquote>
<h3 data-id="heading-14">1.6 C2f总结</h3>
<blockquote>
<p>C2f 是 YOLOv8（以及之后的 YOLO 系列）里用来取代旧式 CSP/C3 模块的核心结构单元。它把输入特征拆成多路，一路保持原始/浅层细节，另一路通过一串小残差块逐步提取更深语义；然后把所有阶段的中间输出通通拼接，再用一个卷积统一融合。<strong><code>分流+堆叠+concat+融合</code></strong></p>
</blockquote>
<h2 data-id="heading-15">2. Neck：PAFPN（Path Aggregation Feature Pyramid Network）</h2>
<p>YOLOv8沿用并优化了PANet结构，实现<strong>多尺度特征的有效融合</strong>。</p>
<p><strong><code>Neck部分负责多尺度特征融合</code></strong>，通过将来自Backbone不同阶段的特征图进行融合，增强特征表示能力。具体来说，YOLOv8的Neck部分包括以下组件:</p>
<ul>
<li><strong>SPPF模块</strong>(Spatial Pyramid Pooling Fast)：用于<strong>不同尺度的池化操作</strong>，将不同尺度的特征图拼接在一起，提高对不同尺寸目标的检测能力。</li>
<li><strong>PAA模块</strong>(Probabilistic Anchor Assignment)：用于<strong>智能地分配锚框</strong>，以优化正负样本的选择，提高模型的训练效果。</li>
<li><strong>PAN模块</strong>(Path Aggregation Network)：包括两个PAN模块，用于<strong>不同层次特征的路径聚合</strong>，通过自底向上和自顶向下的路径增强特征图的表达能力。</li>
</ul>
<p><strong>结构流程：</strong></p>
<pre><code class="hljs language-js" lang="js"><span class="hljs-title class_">Backbone</span>输出特征图(<span class="hljs-variable constant_">P3</span>,<span class="hljs-variable constant_">P4</span>,<span class="hljs-variable constant_">P5</span>) → 
上采样路径（自顶向下）：
  <span class="hljs-variable constant_">P5</span> → 上采样 → 与<span class="hljs-variable constant_">P4</span>融合 → 卷积 → 上采样 → 与<span class="hljs-variable constant_">P3</span>融合
下采样路径（自底向上）：
  融合后的<span class="hljs-variable constant_">P3</span> → 下采样 → 与<span class="hljs-variable constant_">P4</span>融合 → 下采样 → 与<span class="hljs-variable constant_">P5</span>融合
最终输出三个尺度的特征图
</code></pre>
<h3 data-id="heading-16">2.1  SPPF模块结构</h3>
<p><strong>SPPF模块(Spatial Pyramid Pooling Fast):</strong> 用于不同尺度的池化操作，将不同尺度的特征图拼接在一起，提高对不同尺寸目标的检测能力。
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a09a61856ebe464f9ee778d19afb859f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=u%2B6EQjcw9v6H5zfx8FpKiF0OK%2BQ%3D" alt="b1bc51b7-aeaa-43a4-8f42-32e40835f4c7.png" loading="lazy"/></p>
<h4 data-id="heading-17">2.1.1 SPP模块结构</h4>
<p>SPP模块是何凯明大神在2015年的论文 《Spatial Pyramid Pooling in Deep Convolutional Networks for VisualRecognition》中被提出。</p>
<p>SPP为空间金字塔池化结构，主要是为了解决两个问题:</p>
<ol>
<li>有效避免了对图像区域裁剪、缩放操作导致的<strong>图像失真</strong>等问题;</li>
<li>解决了卷积神经网络对图相关<strong>重复特征提取</strong>的问题，大大提高了产生候选框的速度，且节省了计算成本。</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fdfb218a283449609dc3ccc367466cc6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=q4zvhACwCS38mmQ9YyxMmLfCjvc%3D" alt="b7421555-253f-4845-9781-b997e365e982.png" loading="lazy"/></p>
<h4 data-id="heading-18">2.1.2 SPPF模块结构</h4>
<p>这个是YOLOv5 作者Glenn Jocher 基于SPP提出的，速度较SPP快很多，所以叫SPP-Fast。SPPF是空间金字塔池化的快速版本，它是一种在卷积神经网络中用于<strong>处理不同尺寸输入</strong>的技术。SPPF的核心思想是通过<strong>对输入特征图进行不同尺度的池化操作，生成固定长度的特征向量</strong>，从而使得网络能够处理任意尺寸的输入图像。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2e4bdff9f03946429af278c59f40aafd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=tXT%2Bg4%2FCGcrsObeoZsZQ%2FGZjVyU%3D" alt="5f651cd5-0a25-42d3-bd96-6d40fc5d65c3.png" loading="lazy"/></p>
<h3 data-id="heading-19">2.2 PAN-FPN模块结构</h3>
<p>YOLOv8 中入了 PAN-FPN (Path Aggregation Network - Feature Pyramid Network) 为其特征金字塔网络，进一步增强了多尺度特征的表示能力。<strong>PAN-FPN 通过双向路径的融合，使得特征图包含更丰富的上下文信息和语义信息，增强了模型对不同尺度目标的检测能力。</strong></p>
<p>相对于YOLOv5或者YOLOv6，YOLOv8将C3模块以及RepBlock替换为了C2f，同时细心可以发现，相对于YOLOv5和YOLOv6，YOLOv8选择将上采样之前的1×1卷积去除了，将Backbone不同阶段输出的特征直接送入了上采样操作。</p>
<p><strong>YOLOv5的Neck</strong>部分的结构图如下：
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3284c93a0812493da205c25b6fb019fd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=WduVkhxkMSV%2BqbvqmAic5vrO8AY%3D" alt="image.png" loading="lazy"/></p>
<p>YOLOv6的Neck部分的结构图如下：</p>
<img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1b233a5dbd354cecbb89c24ed352a75f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=qQffFB3JvpBzit%2BSmB096r1OATk%3D" alt="image.png" width="100%" loading="lazy"/>
<p><strong>YOLOv8</strong>的结构图：</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af574db2816349d09aec6ebed2fec1f9~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=us7yT6aeXttmh8GU3s6XsNsmR1M%3D" alt="image.png" loading="lazy"/></p>
<p><strong>FPN网络pytorch代码</strong></p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FPN</span>(nn.Module):
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_blocks, num_classes, back_bone=<span class="hljs-string">'resnet'</span>, pretrained=<span class="hljs-literal">True</span></span>):
        <span class="hljs-built_in">super</span>(FPN, self).__init__()
        self.in_planes = <span class="hljs-number">64</span>
        self.num_classes = num_classes
 
        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">7</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">3</span>, bias=<span class="hljs-literal">False</span>)
        self.bn1 = nn.BatchNorm2d(<span class="hljs-number">64</span>)
 
        BatchNorm = nn.BatchNorm2d
        self.back_bone = build_backbone(back_bone)
 
        <span class="hljs-comment"># Bottom-up layers</span>
        self.layer1 = self._make_layer(Bottleneck,  <span class="hljs-number">64</span>, num_blocks[<span class="hljs-number">0</span>], stride=<span class="hljs-number">1</span>)
        self.layer2 = self._make_layer(Bottleneck, <span class="hljs-number">128</span>, num_blocks[<span class="hljs-number">1</span>], stride=<span class="hljs-number">2</span>)
        self.layer3 = self._make_layer(Bottleneck, <span class="hljs-number">256</span>, num_blocks[<span class="hljs-number">2</span>], stride=<span class="hljs-number">2</span>)
        self.layer4 = self._make_layer(Bottleneck, <span class="hljs-number">512</span>, num_blocks[<span class="hljs-number">3</span>], stride=<span class="hljs-number">2</span>)
 
        <span class="hljs-comment"># Top layer</span>
        self.toplayer = nn.Conv2d(<span class="hljs-number">2048</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">1</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)  <span class="hljs-comment"># Reduce channels</span>
 
        <span class="hljs-comment"># Smooth layers</span>
        self.smooth1 = nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>)
        self.smooth2 = nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>)
        self.smooth3 = nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>)
 
        <span class="hljs-comment"># Lateral layers</span>
        self.latlayer1 = nn.Conv2d(<span class="hljs-number">1024</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">1</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)
        self.latlayer2 = nn.Conv2d( <span class="hljs-number">512</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">1</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)
        self.latlayer3 = nn.Conv2d( <span class="hljs-number">256</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">1</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>)
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_upsample</span>(<span class="hljs-params">self, x, h, w</span>):    <span class="hljs-comment"># upsample use 'bilinear' interpolate</span>
        <span class="hljs-keyword">return</span> F.interpolate(x, size=(h, w), mode=<span class="hljs-string">'bilinear'</span>, align_corners=<span class="hljs-literal">True</span>)
 
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_make_layer</span>(<span class="hljs-params">self, Bottleneck, planes, num_blocks, stride</span>):
        strides = [stride] + [<span class="hljs-number">1</span>]*(num_blocks-<span class="hljs-number">1</span>)
        layers = []
        <span class="hljs-keyword">for</span> stride <span class="hljs-keyword">in</span> strides:
            layers.append(Bottleneck(self.in_planes, planes, stride))
            self.in_planes = planes * Bottleneck.expansion
        <span class="hljs-keyword">return</span> nn.Sequential(*layers)
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_upsample_add</span>(<span class="hljs-params">self, x, y</span>):
        <span class="hljs-string">'''Upsample and add two feature maps.
        Args:
          x: (Variable) top feature map to be upsampled.
          y: (Variable) lateral feature map.
        Returns:
          (Variable) added feature map.
        Note in PyTorch, when input size is odd, the upsampled feature map
        with `F.upsample(..., scale_factor=2, mode='nearest')`
        maybe not equal to the lateral feature map size.
        e.g.
        original input size: [N,_,15,15] -&gt;
        conv2d feature map size: [N,_,8,8] -&gt;
        upsampled feature map size: [N,_,16,16]
        So we choose bilinear upsample which supports arbitrary output sizes.
        '''</span>
        _,_,H,W = y.size()
        <span class="hljs-keyword">return</span> F.interpolate(x, size=(H,W), mode=<span class="hljs-string">'bilinear'</span>, align_corners=<span class="hljs-literal">True</span>) + y
 
 
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-comment"># Bottom-up</span>
        c1 = F.relu(self.bn1(self.conv1(x)))
        c1 = F.max_pool2d(c1, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>)
        c2 = self.layer1(c1)
        c3 = self.layer2(c2)
        c4 = self.layer3(c3)
        c5 = self.layer4(c4)

        <span class="hljs-comment"># Top-down</span>
        p5 = self.toplayer(c5)
        p4 = self._upsample_add(p5, self.latlayer1(c4))
        p3 = self._upsample_add(p4, self.latlayer2(c3))
        p2 = self._upsample_add(p3, self.latlayer3(c2))
 
        <span class="hljs-comment"># Smooth</span>
        p4 = self.smooth1(p4)
        p3 = self.smooth2(p3)
        p2 = self.smooth3(p2)
 
        <span class="hljs-keyword">return</span> p2, p3, p4, p5

</code></pre>
<h4 data-id="heading-20">2.2.1 特征金字塔网络(FPN)</h4>
<p><strong>论文：</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F1612.03144" target="_blank" title="https://arxiv.org/abs/1612.03144" ref="nofollow noopener noreferrer">[1612.03144] Feature Pyramid Networks for Object Detection</a></p>
<p>FPN 通过结合 ​<strong>​深层语义信息​</strong>​（高层特征）和 ​<strong>​浅层细节信息​</strong>​（低层特征），构建多尺度的特征金字塔，显著提升目标检测模型对不同尺寸目标的检测能力。</p>
<p>在YOLOv8中，FPN主要负责构建<strong>从低层到高层</strong>的<strong>多尺度特征图</strong>。其主要过程如下:</p>
<p><strong>1.自顶向下路径:</strong></p>
<ul>
<li>从深层特征开始，逐层向上采样。</li>
<li>每一层的上采样特征与相应的低层特征进行融合，以补充空间信息和增强语义信息。</li>
</ul>
<p><strong>2.横向连接:</strong></p>
<ul>
<li>利用1x1卷积调整通道数，使得上采样特征与低层特征的通道数一致。</li>
<li>通过逐层相加的方式进行特征融合。</li>
</ul>
<p>FPN网络大致结构如下：<strong>一个自底向上的线路、一个自顶向下的线路、横向连接</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/81c3d44184fd436e9c1e7778151c3b9d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=YPO8pQKOayeBpNusZAvuPL%2BEBUE%3D" alt="90a4c3d1-52ac-4ab7-b75d-18b22028cde7.png" loading="lazy"/></p>
<p><strong>结来说，FPN = top-down的融合 + 在金字塔各层进行prediction</strong></p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/edf82e376ef6489bad39ffc195a1c375~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=%2BCm6UKhqikcFzs%2F%2FPAkrCJAQkRU%3D" alt="5bf5c1dd-3c77-4017-bb0f-a43827b27778.png" loading="lazy"/>
<strong>FPN（Feature Pyramid Network）​</strong>​ 通过自顶向下的路径构建特征金字塔，但存在两个关键问题：</p>
<ol>
<li>​<strong>​语义信息稀释​</strong>​：深层特征经过多次上采样传递到浅层时，丢失细节信息。</li>
<li>​<strong>​定位精度不足​</strong>​：小目标依赖浅层特征，但浅层语义信息较弱。</li>
</ol>
<h4 data-id="heading-21">2.2.2 路径聚合网络(PAN)</h4>
<p><strong>论文：2018年在CVPR</strong> <a href="https://link.juejin.cn?target=https%3A%2F%2Farxiv.org%2Fabs%2F1803.01534" target="_blank" title="https://arxiv.org/abs/1803.01534" ref="nofollow noopener noreferrer">[1803.01534] Path Aggregation Network for Instance Segmentation</a></p>
<p><strong>PANet的核心创新在于引入了自底向上的路径聚合机制，形成了<code>双向特征融合路径</code></strong>，解决了FPN单向信息传递的局限性。这一改进使得低层的高分辨率特征能够更有效地传递到高层，同时高层的语义信息也能充分影响低层特征，实现了更全面的多尺度特征交互。</p>
<p>PAN是在FPN的基础上，进一步增强特征金字塔网络的结构，具体过程如下:</p>
<p><strong>1.自底向上的路径:</strong></p>
<ul>
<li>从底层特征开始，逐层向上传递特征。</li>
<li>每一层的特征图通过自底向上的路径，与高层特征图进行融合。</li>
</ul>
<p><strong>2.特征融合:</strong></p>
<ul>
<li>在每一层，将自顶向下路径和自底向上路径的特征进行融合，确保每一层的特征都包含不同尺度的信息。</li>
</ul>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1367cdc558df415d98d76e1f532b455f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6JyX54mb5LiN5Lya566X5rOV:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771141219&amp;x-signature=TGxQEaJVX7BUgRakbmU%2Bo6%2BvEt0%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-22">2.2.3 FPN和PANet区别</h4>
<p><strong>FPN更适合基础目标检测任务和资源受限环境</strong>，例如轻量化移动端部署或实时视频流处理。其简单高效的结构设计使其在计算资源有限的场景下仍能保持良好的检测性能。</p>
<p><strong>PANet则适用于需要高精度的场景</strong>，特别是在处理极小目标或复杂背景环境时。例如在自动驾驶系统中检测车辆周围的小障碍物，或在医学图像分中识别微小病灶时，PANet的双向特征融合和自适应特征池化技术能够显著提升检测和分割的准确性。</p>
<p>FPN的参数量约为25M，FLOPs约为200B；而PANet的参数量增加到32.5M，FLOPs达到235.6B。</p>
<h3 data-id="heading-23">2.3 Neck创新点</h3>
<ol>
<li>
<p><strong>双融合路径</strong>：</p>
<ul>
<li>上采样路径：传播强语义信息（利于分类）</li>
<li>下采样路径：传播强定位信息（利于检测）</li>
</ul>
</li>
<li>
<p><strong>跨尺度连接</strong>：使用Concat而非Add，保留更多特征信息</p>
</li>
<li>
<p><strong>适配不同尺度</strong>：针对80×80（小目标）、40×40（中目标）、20×20（大目标）特征图优化融合策略。</p>
</li>
</ol>
<h3 data-id="heading-24">2.4 PAN-FPN在YOLOv8中的具体实现</h3>
<p>在YOLOv8中，PAN-FPN的实现结合了FPN和PAN的优点，具体如下:</p>
<blockquote>
<p><strong>1. 多尺度特征提取:</strong></p>
<ul>
<li>YOLOv8的主干网络首先提取出不同尺度的特征图。</li>
<li>通过FPN构建自顶向下的特征金字塔，实现多尺度特征的初步融合。</li>
</ul>
<p><strong>1. 双向特征融合:</strong></p>
<ul>
<li>在FPN的基础上，引入PAN的自底向上路径，将低层特征逐层传递到高层，进一步丰富多尺度特征。</li>
<li>通过横向连接，将不同尺度的特征进行融合，确保每一层的特征都包含丰富的上下文信息。</li>
</ul>
<p><strong>2. 增强的特征表示:</strong></p>
<ul>
<li>PAN-FPN通过双向路径的融合，使得特征图包含更丰富的上下文信息和语义信息，增强了模型对不同尺度目标的检测能力。</li>
</ul>
</blockquote>
<h2 data-id="heading-25">3. Head：Decoupled-Head + DFL + CIoU（检测头革新）</h2>
<p>YOLOv8将检测头改为 <strong><code>解耦形式</code></strong>，并引入了先进的损失函数。</p>
<p>在YOLOv8中，Head部分负责将Neck部分输出的特征进行进一步处理，以生成最终的检测结果。Head部分的主要功能是<strong>将特征图转换为目标检测所需的具体信息，包括类别、位置和置信度。</strong></p>
<p>解耦头结构：</p>
<pre><code class="hljs language-js" lang="js">共享特征 → 三个独立分支：
  <span class="hljs-number">1.</span> 分类分支：<span class="hljs-title class_">Conv</span> + <span class="hljs-title class_">Conv</span> → 类别置信度
  <span class="hljs-number">2.</span> 回归分支：<span class="hljs-title class_">Conv</span> + <span class="hljs-title class_">Conv</span> → 边界框坐标
  <span class="hljs-number">3.</span> 分布焦点分支：<span class="hljs-title class_">Conv</span> + <span class="hljs-title class_">Conv</span> → 边界框分布（<span class="hljs-variable constant_">DFL</span>）
</code></pre>
<h3 data-id="heading-26">3.1 卷积层和激活函数</h3>
<p>Head部分通常包括若干卷积层和激活函数。这些卷积层用于进一步处理Neck部分输出的特征图，以提取更多的高级特征。常见的激活函数包括ReLU或Leaky ReLU，能够引入非线性，从而提升特征表达能力。</p>
<h3 data-id="heading-27">3.2 预测层 (Prediction Layers)</h3>
<p>在YOLOv8中，预测层是关键组件，负责生成最终的检测结果。预测层包括三个主要输出:</p>
<ul>
<li><strong>边界框回归(Bounding BoxRegression)</strong>：预测目标的位置和大小。通常输出四个值，分别对应边界框的中心坐标(x,y)和宽度、高度(w,h)。</li>
<li><strong>置信度评分(Confidence Scores)</strong>：预测每个边界框内是否包含目标，以及目标的置信度。</li>
<li><strong>类别概率(Class Probabilities)</strong>：预测目标属于每个类别的概率。</li>
</ul>
<h4 data-id="heading-28">3.2.1 DFL（Distribution Focal Loss）</h4>
<pre><code class="hljs language-js" lang="js">传统：直接回归边界框坐标
<span class="hljs-variable constant_">DFL</span>：将坐标预测建模为离散概率分布
  步骤：
    <span class="hljs-number">1.</span> 预测边界框的分布（如y = Σ[<span class="hljs-title function_">P</span>(i)×i]）
    <span class="hljs-number">2.</span> 使用<span class="hljs-title class_">Focal</span> <span class="hljs-title class_">Loss</span>优化分布
  优势：
    - 更准确的小目标检测
    - 对模糊边界更鲁棒
</code></pre>
<h4 data-id="heading-29">3.2.2 损失函数组合</h4>
<pre><code class="hljs language-js" lang="js">总损失 = 分类损失 + 回归损失 + <span class="hljs-variable constant_">DFL</span>损失

分类损失：<span class="hljs-title class_">BCEWithLogitsLoss</span> 或 <span class="hljs-title class_">VarifocalLoss</span>（可选）
回归损失：<span class="hljs-title class_">CIoU</span> <span class="hljs-title class_">Loss</span>（考虑重叠、中心距离、长宽比）
<span class="hljs-variable constant_">DFL</span>损失：监督边界框分布学习
</code></pre>
<h2 data-id="heading-30">其他优化</h2>
<p>除了上述结构外，YOLOv8还引入了一些新的优化技术，如:</p>
<ol>
<li><strong>Anchor-free机制</strong>:减少了锚框的超参数设置，通过直接预测目标的中心点来简化训练过程。</li>
<li><strong>自适应非大值抑制NMS(Non-Maximum Suppression)</strong>:改进了传统的NMS算法，通过自适应调整阈值，<strong>减少误检和漏检</strong>，提高检测精度。
最终的预测结果会经过非极大值抑制处理，<strong>以去除重复的检测框</strong>。NMS保留置信度最高的边界框，并移除与之重叠度高的其他边界框，确保每个目标只被检测一次。</li>
<li><strong>自动混合精度训练(Automatic Mixed Precision Training)</strong>:通过在训练过程中动态调整计算精度，加快训练速度，同时减少显存占用。</li>
</ol>
<h2 data-id="heading-31">总结复习</h2>
<p>（1）特征金字塔网络是啥？
（2）空间金字塔池化是啥？
（3）C2f是啥？
（4）路径聚合网络是啥？
（5）特征金字塔网络和路径聚合网络区别？
（5）YOLO为什么使用两层特征金字塔结构？
（7）预测层会输出什么？
（8）怎么去除重复的检测框和减少误检和漏检？NMS
（9）为什么检测小物体需要用大的特征图？</p>
<p>（10）为什么要用双分支？</p>
<ol>
<li><strong>丰富特征表示</strong>：不同分支学习不同特征</li>
<li><strong>梯度多样性</strong>：缓解梯度消失，帮助训练</li>
<li><strong>信息冗余</strong>：提升模型鲁棒性</li>
</ol>
<p>（11）连接处的c和a的区别？</p>
<p><strong>连接处的<code>c</code>通常代表"拼接/连接（concatenate）"操作</strong>
<strong>连接处的<code>a</code>是<code>add</code>（加法操作/残差连接）</strong></p>
<p>（12）TD和BU是什么？</p>
<ul>
<li><strong>TD</strong> = <strong>T</strong>op-<strong>D</strong>own = 自上而下 = 语义信息下传</li>
<li><strong>BU</strong> = <strong>B</strong>ottom-<strong>U</strong>p = 自下而上 = 位置信息上传</li>
</ul>
<h2 data-id="heading-32">参考资料</h2>
<p>[1]<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fu013172930%2Farticle%2Fdetails%2F154040820" target="_blank" title="https://blog.csdn.net/u013172930/article/details/154040820" ref="nofollow noopener noreferrer">什么是 C2f： YOLOv8 中引入的一种高效特征提取模块_c2f模块</a></p>
<p>[2]<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fshangyanaf%2Farticle%2Fdetails%2F139223155" target="_blank" title="https://blog.csdn.net/shangyanaf/article/details/139223155" ref="nofollow noopener noreferrer">万字详解YOLOv8网络结构Backbone/neck/head以及Conv、Bottleneck、C2f、SPPF、Detect等模块_yolov8网络架构</a></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[北京回长沙了，简单谈谈感受！]]></title>    <link>https://juejin.cn/post/7603781883973763091</link>    <guid>https://juejin.cn/post/7603781883973763091</guid>    <pubDate>2026-02-08T09:54:37.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603781883973763091" data-draft-id="7603643044035199012" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="北京回长沙了，简单谈谈感受！"/> <meta itemprop="keywords" content="后端,面试,Java"/> <meta itemprop="datePublished" content="2026-02-08T09:54:37.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员飞鱼"/> <meta itemprop="url" content="https://juejin.cn/user/1665088861772688"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            北京回长沙了，简单谈谈感受！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1665088861772688/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员飞鱼
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T09:54:37.000Z" title="Sun Feb 08 2026 09:54:37 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{line-height:1.75;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;letter-spacing:2px;background-image:linear-gradient(90deg,rgba(50,0,0,.05) 3%,transparent 0),linear-gradient(1turn,rgba(50,0,0,.05) 3%,transparent 0);background-size:20px 20px;background-position:50%;word-break:break-word;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body h1{font-size:23px;margin-bottom:5px;font-weight:700;padding-left:10px;border-left:5px solid #773098}.markdown-body h2{font-size:19px;font-weight:700;padding-left:10px;border-left:5px solid #916dd5}.markdown-body h3{font-size:17px;font-weight:700;padding-left:10px;border-left:5px solid #d89cf6}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{font-size:14px;margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;max-width:100%;margin:1em 0;border-radius:6px;box-shadow:2px 4px 7px #999;user-select:none}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{padding:.2em .5em;font-weight:700;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-size:1em;color:#916dd5;word-break:break-word;overflow-x:auto;background-color:none;border-radius:2px}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;font-family:-apple-system-font,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Hiragino Sans GB,Microsoft YaHei UI,Microsoft YaHei,Arial,sans-serif;font-weight:400;font-size:.9em;padding:16px 12px;margin:0;color:#333;word-break:normal;overflow-x:auto;background:#f8f8f8;scroll-behavior:smooth}.markdown-body a{text-decoration:none;color:#916dd5;font-weight:700;border-bottom:1px solid #916dd5}.markdown-body a:active,.markdown-body a:hover{color:#773098}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border:1px solid #916dd5;border-collapse:collapse}.markdown-body thead{background-color:#916dd5;color:#fff;text-align:left}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px;border:1px solid #916dd5}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #d89cf6;background-color:#f4eeff}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0;line-height:26px}.markdown-body ol,.markdown-body ul{padding-left:28px;list-style-type:circle}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{color:#916dd5;font-weight:700}.markdown-body b:before,.markdown-body strong:before{content:"「"}.markdown-body b:after,.markdown-body strong:after{content:"」"}.markdown-body em,.markdown-body i{color:#916dd5}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="github-gist">.markdown-body pre,.markdown-body pre&gt;code.hljs{background:#fff;color:#333}.hljs-comment,.hljs-meta{color:#969896}.hljs-emphasis,.hljs-quote,.hljs-strong,.hljs-template-variable,.hljs-variable{color:#df5000}.hljs-keyword,.hljs-selector-tag,.hljs-type{color:#d73a49}.hljs-attribute,.hljs-bullet,.hljs-literal,.hljs-symbol{color:#0086b3}.hljs-name,.hljs-section{color:#63a35c}.hljs-tag{color:#333}.hljs-attr,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-selector-pseudo,.hljs-title{color:#6f42c1}.hljs-addition{color:#55a532;background-color:#eaffea}.hljs-deletion{color:#bd2c00;background-color:#ffecec}.hljs-link{text-decoration:underline}.hljs-number{color:#005cc5}.hljs-string{color:#032f62}</style><p>大家好呀，我是<strong>飞鱼</strong></p>
<p>我今年已经从北京回长沙了，这里谈谈感受。</p>
<blockquote>
<p>❝</p>
<p>首先我回长沙不是逃离，而是换一种更舒服、更可持续的生活方式。</p>
<p>北京给了我视野和能力，长沙给了我生活和归属。</p>
</blockquote>
<p><strong>最直观的变化</strong></p>
<ul>
<li>节奏慢了：不用挤早高峰了，走路不用小跑，回家路更短。</li>
<li>心态稳了：不再天天赶进度、追KPI，人也没那么紧绷了。</li>
</ul>
<p><strong>生活成本：压力明显小了</strong></p>
<blockquote>
<p>❝</p>
<p>房租、通勤、日常开销都降了不少，以前在北京工资高，但大头都被生活成本吃掉了。</p>
<p>现在收入可能少些，但心里踏实很多。</p>
</blockquote>
<p><strong>个人生活：更松弛也更有边界</strong></p>
<blockquote>
<p>❝</p>
<p>回来后作息更规律了，能早点睡、早点起，周内也会留出时间运动或散步。</p>
<p>以前下班只想躺着刷手机，现在会给自己留一点空白时间，用来读书、整理思路或者陪家人聊天。</p>
<p>生活变简单，但心里更笃定，能把注意力放在真正重要的人和事上。</p>
</blockquote>
<p><strong>城市气息：更有生活感</strong></p>
<blockquote>
<p>❝</p>
<p>长沙烟火气足，我现在每周都会去爬一次岳麓山（离得近）。</p>
<p>周末也能随时约上朋友一起吃饭聊天，不用再掐着时间赶路。</p>
</blockquote>
<p><strong>个人成长：从外部驱动到自我驱动</strong></p>
<blockquote>
<p>❝</p>
<p>以前在北京，节奏和环境会推着我走，事情一件接一件，来不及想太多。</p>
<p>回长沙后，外部推力小了，但我开始主动搭自己的节奏：给自己设目标、做复盘、安排学习计划。</p>
<p>慢下来之后，反而更能看清自己擅长什么、缺什么，也更容易把工作和生活都经营得更稳。</p>
</blockquote>
<p><strong>给同样选择的人一点建议</strong></p>
<ul>
<li>先想清楚你想要什么：是离家近、生活压力小，还是职业成长更快？别只因为累了就决定，要有明确的取舍。</li>
<li>提前做资源准备：无论去哪，职业发展都得靠自己，技能储备、作品、圈子都要主动经营。</li>
<li>规划现金流：收入变化要提前算清楚，别让生活压力反过来影响判断。</li>
<li>给自己一个过渡期：回去不是立刻完美适应，给自己几个月调整节奏，别太焦虑。</li>
</ul>
<p><strong>最后想说</strong></p>
<p>适合自己的地方，不一定是机会最多的地方，而是能让你活得更从容、有力量的地方。</p>
<blockquote>
<p>❝</p>
<p>最后想看技术文章的，可以去我的个人网站：<a href="https://link.juejin.cn?target=http%3A%2F%2Fhardyfish.top%2F" target="_blank" title="http://hardyfish.top/" ref="nofollow noopener noreferrer">hardyfish.top/</a></p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JavaScript 响应式布局的诞生历程：从后端渲染到前端响应式]]></title>    <link>https://juejin.cn/post/7604037348607066150</link>    <guid>https://juejin.cn/post/7604037348607066150</guid>    <pubDate>2026-02-08T09:54:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7604037348607066150" data-draft-id="7603721514203676681" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JavaScript 响应式布局的诞生历程：从后端渲染到前端响应式"/> <meta itemprop="keywords" content="全栈"/> <meta itemprop="datePublished" content="2026-02-08T09:54:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不会敲代码1"/> <meta itemprop="url" content="https://juejin.cn/user/1927884034804425"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JavaScript 响应式布局的诞生历程：从后端渲染到前端响应式
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1927884034804425/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不会敲代码1
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T09:54:26.000Z" title="Sun Feb 08 2026 09:54:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">JavaScript 响应式布局的诞生历程：从后端渲染到前端响应式</h2>
<h3 data-id="heading-1">引言</h3>
<p>在 Web 开发的演进过程中，数据与界面的关系经历了多次革命性的变化。从最初的纯后端渲染，到前后端分离，再到现代的响应式数据驱动，每一次变革都让开发更加高效、用户体验更加流畅。本文将结合具体代码示例，带你走完这段历程，理解响应式布局如何诞生并成为现代前端开发的核心。</p>
<hr/>
<h3 data-id="heading-2">第一阶段：纯后端的套模板（MVC 模式）</h3>
<h4 data-id="heading-3">什么是纯后端套模板？</h4>
<p>在这个阶段，服务器负责处理<strong>所有</strong>的页面生成工作。典型的 MVC（Model-View-Controller）架构中：</p>
<ul>
<li><strong>Model</strong>：数据层（如数据库中的数据）</li>
<li><strong>View</strong>：模板层（HTML + 模板语法）</li>
<li><strong>Controller</strong>：业务逻辑层（接收请求、处理数据、渲染模板）</li>
</ul>
<h4 data-id="heading-4">代码示例分析</h4>
<p>在 <code>server.js</code> 中，我们可以看到典型的后端渲染模式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 数据定义在服务器端</span>
<span class="hljs-keyword">const</span> users=[
    {
        <span class="hljs-attr">id</span>:<span class="hljs-number">1</span>,
        <span class="hljs-attr">name</span>:<span class="hljs-string">'张三'</span>,
        <span class="hljs-attr">email</span>:<span class="hljs-string">'zhangsan@qq.com'</span>
    },
    <span class="hljs-comment">// ... 更多用户数据</span>
]

<span class="hljs-comment">// 生成HTML的模板函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">generateHTML</span>(<span class="hljs-params">users</span>){
    <span class="hljs-keyword">const</span> userRows=users.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">user</span>=&gt;</span>
        <span class="hljs-string">`&lt;tr&gt;
            &lt;td&gt;<span class="hljs-subst">${user.id}</span>&lt;/td&gt;
            &lt;td&gt;<span class="hljs-subst">${user.name}</span>&lt;/td&gt;
            &lt;td&gt;<span class="hljs-subst">${user.email}</span>&lt;/td&gt;
        &lt;/tr&gt;`</span>
    ).<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)
    
    <span class="hljs-keyword">return</span> <span class="hljs-string">`
    &lt;!DOCTYPE html&gt;
    &lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;!-- 样式和元数据 --&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Users&lt;/h1&gt;
        &lt;table&gt;
            &lt;thead&gt;...&lt;/thead&gt;
            &lt;tbody&gt;
                <span class="hljs-subst">${userRows}</span>  &lt;!-- 动态数据插入 --&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/body&gt;
    &lt;/html&gt;`</span>
}

<span class="hljs-comment">// 服务器处理请求</span>
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req,res</span>)=&gt;</span>{
    <span class="hljs-keyword">if</span>(req.<span class="hljs-property">url</span> === <span class="hljs-string">'/users'</span>){
        res.<span class="hljs-property">statusCode</span>=<span class="hljs-number">200</span>
        res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">'Content-Type'</span>,<span class="hljs-string">'text/html;charset=utf-8'</span>)
        <span class="hljs-keyword">const</span> html=<span class="hljs-title function_">generateHTML</span>(users)  <span class="hljs-comment">// 在服务器生成完整HTML</span>
        res.<span class="hljs-title function_">end</span>(html)  <span class="hljs-comment">// 返回给浏览器</span>
    }
})
</code></pre>
<h4 data-id="heading-5">工作流程</h4>
<ol>
<li>用户访问 <code>http://localhost:1314/users</code></li>
<li>服务器接收到请求，执行对应的控制器逻辑</li>
<li>从数据库（示例中是内存数组）获取用户数据</li>
<li>将数据注入到 HTML 模板中生成完整的页面</li>
<li>返回包含数据的完整 HTML 给浏览器显示</li>
</ol>
<h4 data-id="heading-6">实际运行效果</h4>
<pre><code class="hljs language-xml" lang="xml">浏览器请求: http://localhost:1314/users
↓
服务器响应:
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>zhangsan@qq.com<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>lisi@qq.com<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
      <span class="hljs-comment">&lt;!-- 所有数据都在HTML中 --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h4 data-id="heading-7">劣势分析</h4>
<ol>
<li><strong>前后端耦合严重</strong>：前端开发者需要了解后端模板语法，无法独立工作</li>
<li><strong>页面刷新频繁</strong>：查看用户详情需要重新加载整个页面</li>
<li><strong>服务器压力大</strong>：高并发时每个请求都需要渲染完整页面</li>
<li><strong>开发效率低</strong>：修改一个按钮样式需要后端重新部署</li>
<li><strong>技术栈限制</strong>：前端无法使用现代框架和工具链</li>
</ol>
<h4 data-id="heading-8">典型问题场景</h4>
<p>假设要添加一个"删除用户"功能：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 需要为每个用户添加删除按钮</span>
<span class="hljs-string">`&lt;tr&gt;
    &lt;td&gt;<span class="hljs-subst">${user.id}</span>&lt;/td&gt;
    &lt;td&gt;<span class="hljs-subst">${user.name}</span>&lt;/td&gt;
    &lt;td&gt;<span class="hljs-subst">${user.email}</span>&lt;/td&gt;
    &lt;td&gt;&lt;button onclick="deleteUser(<span class="hljs-subst">${user.id}</span>)"&gt;删除&lt;/button&gt;&lt;/td&gt;
&lt;/tr&gt;`</span>

<span class="hljs-comment">// 删除后需要刷新整个页面才能看到更新后的列表</span>
</code></pre>
<hr/>
<h3 data-id="heading-9">第二阶段：前后端分离 + DOM API 编程</h3>
<h4 data-id="heading-10">什么是前后端分离？</h4>
<p>随着 AJAX（后升级为 Fetch API）技术的成熟，前端可以独立于后端进行开发：</p>
<h4 data-id="heading-11">后端代码变化（API 化）</h4>
<p>后端不再返回 HTML，而是返回 JSON 数据：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// db.json - 纯数据文件</span>
{
    <span class="hljs-string">"users"</span>: [
        {<span class="hljs-string">"id"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"name"</span>:<span class="hljs-string">"张三"</span>,<span class="hljs-string">"email"</span>:<span class="hljs-string">"zhangsan@qq.com"</span>},
        {<span class="hljs-string">"id"</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"name"</span>:<span class="hljs-string">"李四"</span>,<span class="hljs-string">"email"</span>:<span class="hljs-string">"lisi@qq.com"</span>}
    ]
}
</code></pre>
<h4 data-id="heading-12">前端独立开发</h4>
<p><code>index.html</code> 展示了如何独立获取和展示数据：</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 独立的前端页面 --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Users<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- 初始为空，通过JS动态填充 --&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
        <span class="hljs-comment">// 主动向后端请求数据</span>
        <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'http://localhost:3000/users'</span>)
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'获取到的数据:'</span>, data)
            
            <span class="hljs-comment">// 手动操作DOM更新界面</span>
            <span class="hljs-keyword">const</span> tbody = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'tbody'</span>)
            
            <span class="hljs-comment">// 拼接HTML字符串</span>
            <span class="hljs-keyword">const</span> rowsHTML = data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> 
                <span class="hljs-string">`&lt;tr&gt;
                    &lt;td&gt;<span class="hljs-subst">${user.id}</span>&lt;/td&gt;
                    &lt;td&gt;<span class="hljs-subst">${user.name}</span>&lt;/td&gt;
                    &lt;td&gt;<span class="hljs-subst">${user.email}</span>&lt;/td&gt;
                    &lt;td&gt;
                        &lt;button onclick="deleteUser(<span class="hljs-subst">${user.id}</span>)"&gt;
                            删除
                        &lt;/button&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;`</span>
            ).<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)
            
            <span class="hljs-comment">// 更新DOM</span>
            tbody.<span class="hljs-property">innerHTML</span> = rowsHTML
        })
        
        <span class="hljs-comment">// 删除用户的函数</span>
        <span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteUser</span>(<span class="hljs-params">id</span>) {
            <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`http://localhost:3000/users/<span class="hljs-subst">${id}</span>`</span>, {
                <span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span>
            })
            .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
                <span class="hljs-comment">// 删除成功后，需要重新获取数据并更新DOM</span>
                <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'http://localhost:3000/users'</span>)
                .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
                .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
                    <span class="hljs-keyword">const</span> tbody = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'tbody'</span>)
                    <span class="hljs-keyword">const</span> rowsHTML = data.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> 
                        <span class="hljs-string">`&lt;tr&gt;...&lt;/tr&gt;`</span>
                    ).<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)
                    tbody.<span class="hljs-property">innerHTML</span> = rowsHTML
                })
            })
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h4 data-id="heading-13">对比前一阶段的优势</h4>
<h5 data-id="heading-14">1. <strong>开发完全解耦</strong></h5>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">前端团队: HTML/CSS/JS独立开发，使用Mock数据</span>
<span class="hljs-section">后端团队: 专注API开发和数据库优化</span>
<span class="hljs-section">测试团队: 可独立测试API和前端功能</span>
</code></pre>
<h5 data-id="heading-15">2. <strong>用户体验提升</strong></h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 实现搜索功能而无需刷新页面</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">searchUsers</span>(<span class="hljs-params">keyword</span>) {
    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`http://localhost:3000/users?q=<span class="hljs-subst">${keyword}</span>`</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
        <span class="hljs-comment">// 只更新表格内容，页面其他部分保持不变</span>
        <span class="hljs-title function_">updateTable</span>(data)
    })
}
</code></pre>
<h5 data-id="heading-16">3. <strong>技术选型自由</strong></h5>
<ul>
<li>前端可以选择 React、Vue、Angular 或保持原生</li>
<li>后端可以使用 Java、Python、Go 等任意语言</li>
<li>各自独立部署和扩展</li>
</ul>
<h4 data-id="heading-17">劣势分析</h4>
<h5 data-id="heading-18">1. <strong>DOM 操作繁琐且重复</strong></h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 每次数据变化都需要这样操作</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTable</span>(<span class="hljs-params">users</span>) {
    <span class="hljs-keyword">const</span> tbody = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'tbody'</span>)
    tbody.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>
    
    users.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> tr = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'tr'</span>)
        
        <span class="hljs-keyword">const</span> td1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'td'</span>)
        td1.<span class="hljs-property">textContent</span> = user.<span class="hljs-property">id</span>
        tr.<span class="hljs-title function_">appendChild</span>(td1)
        
        <span class="hljs-keyword">const</span> td2 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">'td'</span>)
        td2.<span class="hljs-property">textContent</span> = user.<span class="hljs-property">name</span>
        tr.<span class="hljs-title function_">appendChild</span>(td2)
        
        <span class="hljs-comment">// ... 重复的创建和追加操作</span>
        
        tbody.<span class="hljs-title function_">appendChild</span>(tr)
    })
}

<span class="hljs-comment">// 或者使用innerHTML方式</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTable2</span>(<span class="hljs-params">users</span>) {
    <span class="hljs-keyword">const</span> tbody = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'tbody'</span>)
    <span class="hljs-keyword">const</span> html = users.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> <span class="hljs-string">`
        &lt;tr&gt;
            &lt;td&gt;<span class="hljs-subst">${user.id}</span>&lt;/td&gt;
            &lt;td&gt;<span class="hljs-subst">${user.name}</span>&lt;/td&gt;
            &lt;td&gt;<span class="hljs-subst">${user.email}</span>&lt;/td&gt;
        &lt;/tr&gt;
    `</span>).<span class="hljs-title function_">join</span>(<span class="hljs-string">''</span>)
    tbody.<span class="hljs-property">innerHTML</span> = html
}
</code></pre>
<h5 data-id="heading-19">2. <strong>状态管理混乱</strong></h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">let</span> currentUsers = []
<span class="hljs-keyword">let</span> filteredUsers = []
<span class="hljs-keyword">let</span> selectedUserId = <span class="hljs-literal">null</span>

<span class="hljs-comment">// 数据变化时需要手动同步多个地方</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteUser</span>(<span class="hljs-params">id</span>) {
    <span class="hljs-comment">// 1. 发送删除请求</span>
    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/users/<span class="hljs-subst">${id}</span>`</span>, {<span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span>})
    
    <span class="hljs-comment">// 2. 更新当前数据数组</span>
    currentUsers = currentUsers.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.<span class="hljs-property">id</span> !== id)
    filteredUsers = filteredUsers.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.<span class="hljs-property">id</span> !== id)
    
    <span class="hljs-comment">// 3. 如果删除的是选中用户，清空选中状态</span>
    <span class="hljs-keyword">if</span> (selectedUserId === id) {
        selectedUserId = <span class="hljs-literal">null</span>
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'.selected'</span>).<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">'selected'</span>)
    }
    
    <span class="hljs-comment">// 4. 更新DOM显示</span>
    <span class="hljs-title function_">updateTable</span>(filteredUsers)
    
    <span class="hljs-comment">// 5. 更新统计数据</span>
    <span class="hljs-title function_">updateStats</span>(currentUsers)
}
</code></pre>
<h5 data-id="heading-20">3. <strong>性能问题</strong></h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 每次更新都重新渲染整个表格</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTable</span>(<span class="hljs-params">users</span>) {
    <span class="hljs-keyword">const</span> tbody = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'tbody'</span>)
    tbody.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">''</span>  <span class="hljs-comment">// 清空所有DOM节点</span>
    
    <span class="hljs-comment">// 重新创建所有节点</span>
    users.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> {
        <span class="hljs-comment">// 即使只有一项数据变化，也要重绘所有行</span>
    })
}

<span class="hljs-comment">// 1000行数据时会出现明显卡顿</span>
<span class="hljs-title function_">updateTable</span>(largeUserList)  <span class="hljs-comment">// 可能阻塞主线程几毫秒</span>
</code></pre>
<h5 data-id="heading-21">4. <strong>关注点偏离</strong></h5>
<p>开发者花费大量时间在：</p>
<ul>
<li>DOM 选择器的编写和维护</li>
<li>事件委托和冒泡处理</li>
<li>手动处理状态同步</li>
<li>性能优化（防抖、节流、虚拟列表）</li>
</ul>
<p>而不是专注于业务逻辑本身。</p>
<hr/>
<h3 data-id="heading-22">第三阶段：Vue 响应式数据驱动</h3>
<h4 data-id="heading-23">什么是响应式数据驱动？</h4>
<p>响应式编程的核心思想是：<strong>数据变化自动驱动界面更新</strong>。</p>
<h4 data-id="heading-24">完整代码示例</h4>
<p><code>App.vue</code> 展示了 Vue 3 的响应式编程：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;script setup&gt;
// 导入响应式API
import { ref, onMounted } from 'vue'

// 创建响应式数据
const users = ref([])
const isLoading = ref(false)
const searchKeyword = ref('')

// 组件挂载后自动执行
onMounted(() =&gt; {
    console.log('组件已挂载，开始获取数据')
    loadUsers()
})

// 加载用户数据
function loadUsers() {
    isLoading.value = true  // 界面自动显示加载状态
    
    fetch('http://localhost:3000/users')
    .then(res =&gt; res.json())
    .then(data =&gt; {
        users.value = data  // 赋值后界面自动更新
        isLoading.value = false
    })
    .catch(error =&gt; {
        console.error('加载失败:', error)
        isLoading.value = false
    })
}

// 删除用户
function deleteUser(id) {
    if (confirm('确定要删除吗？')) {
        // 1. 先从前端移除（立即响应）
        users.value = users.value.filter(user =&gt; user.id !== id)
        
        // 2. 后发送请求到服务器
        fetch(`http://localhost:3000/users/${id}`, {
            method: 'DELETE'
        }).catch(error =&gt; {
            // 如果失败，可以回滚或提示
            console.error('删除失败:', error)
            loadUsers()  // 重新加载数据
        })
    }
}

// 计算属性：过滤后的用户
const filteredUsers = computed(() =&gt; {
    if (!searchKeyword.value) return users.value
    
    return users.value.filter(user =&gt;
        user.name.includes(searchKeyword.value) ||
        user.email.includes(searchKeyword.value)
    )
})
&lt;/script&gt;

&lt;template&gt;
    &lt;div class="user-management"&gt;
        &lt;!-- 搜索框 --&gt;
        &lt;div class="search-box"&gt;
            &lt;input 
                v-model="searchKeyword" 
                placeholder="搜索用户..."
                @input="searchUsers"
            /&gt;
            &lt;span&gt;找到 {{ filteredUsers.length }} 个用户&lt;/span&gt;
        &lt;/div&gt;
        
        &lt;!-- 加载状态 --&gt;
        &lt;div v-if="isLoading" class="loading"&gt;
            加载中...
        &lt;/div&gt;
        
        &lt;!-- 用户表格 --&gt;
        &lt;table v-else&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;ID&lt;/th&gt;
                    &lt;th&gt;姓名&lt;/th&gt;
                    &lt;th&gt;邮箱&lt;/th&gt;
                    &lt;th&gt;操作&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                &lt;!-- 响应式数据绑定 --&gt;
                &lt;tr v-for="user in filteredUsers" :key="user.id"&gt;
                    &lt;td&gt;{{ user.id }}&lt;/td&gt;
                    &lt;td&gt;{{ user.name }}&lt;/td&gt;
                    &lt;td&gt;{{ user.email }}&lt;/td&gt;
                    &lt;td&gt;
                        &lt;button @click="deleteUser(user.id)"&gt;
                            删除
                        &lt;/button&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
        
        &lt;!-- 空状态 --&gt;
        &lt;div v-if="!isLoading &amp;&amp; filteredUsers.length === 0"&gt;
            没有找到用户
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;style scoped&gt;
/* 组件作用域样式 */
.user-management {
    padding: 20px;
}

.search-box {
    margin-bottom: 20px;
}

table {
    width: 100%;
    border-collapse: collapse;
}

tr:hover {
    background-color: #f5f5f5;
}
&lt;/style&gt;
</code></pre>
<h4 data-id="heading-25">核心优势详解</h4>
<h5 data-id="heading-26">1. <strong>声明式编程 vs 命令式编程</strong></h5>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 声明式：告诉框架"要显示什么" --&gt;
&lt;tr v-for="user in users" :key="user.id"&gt;
    &lt;td&gt;{{ user.id }}&lt;/td&gt;
    &lt;td&gt;{{ user.name }}&lt;/td&gt;
&lt;/tr&gt;

&lt;!-- 对比命令式：告诉浏览器"如何显示" --&gt;
// const tbody = document.querySelector('tbody')
// tbody.innerHTML = ''
// users.forEach(user =&gt; {
//     const tr = document.createElement('tr')
//     // ... 手动创建每个元素
// })
</code></pre>
<h5 data-id="heading-27">2. <strong>响应式数据系统</strong></h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 创建响应式数据</span>
<span class="hljs-keyword">const</span> users = <span class="hljs-title function_">ref</span>([])

<span class="hljs-comment">// 添加新用户（界面自动更新）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addUser</span>(<span class="hljs-params">newUser</span>) {
    users.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(newUser)  <span class="hljs-comment">// 表格自动增加一行</span>
}

<span class="hljs-comment">// 修改用户信息（界面自动更新）</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateUser</span>(<span class="hljs-params">id, newData</span>) {
    <span class="hljs-keyword">const</span> user = users.<span class="hljs-property">value</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> u.<span class="hljs-property">id</span> === id)
    <span class="hljs-keyword">if</span> (user) {
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(user, newData)  <span class="hljs-comment">// 对应行自动更新</span>
    }
}

<span class="hljs-comment">// 无需手动操作DOM！</span>
</code></pre>
<h5 data-id="heading-28">3. <strong>自动依赖跟踪</strong></h5>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
    &lt;div&gt;
        用户总数: {{ totalUsers }}
        活跃用户: {{ activeUsers }}
    &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
const users = ref([])
const showActiveOnly = ref(false)

// 计算属性：自动追踪依赖
const totalUsers = computed(() =&gt; users.value.length)

const activeUsers = computed(() =&gt; {
    // 自动追踪 users 和 showActiveOnly
    if (!showActiveOnly.value) return users.value.length
    
    return users.value.filter(user =&gt; user.isActive).length
})

// 当 users 或 showActiveOnly 变化时
// totalUsers 和 activeUsers 自动重新计算
// 界面自动更新
&lt;/script&gt;
</code></pre>
<h5 data-id="heading-29">4. <strong>虚拟 DOM 性能优化</strong></h5>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vue 内部工作原理：</span>
<span class="hljs-comment">// 1. 数据变化时，创建新的虚拟DOM</span>
<span class="hljs-keyword">const</span> newVNode = <span class="hljs-title function_">createVNode</span>(users.<span class="hljs-property">value</span>)

<span class="hljs-comment">// 2. 与旧的虚拟DOM比较差异</span>
<span class="hljs-keyword">const</span> patches = <span class="hljs-title function_">diff</span>(oldVNode, newVNode)

<span class="hljs-comment">// 3. 只更新有变化的部分</span>
<span class="hljs-title function_">patch</span>(domNode, patches)

<span class="hljs-comment">// 结果：1000行数据中修改1行</span>
<span class="hljs-comment">// 原生DOM: 可能重绘1000行</span>
<span class="hljs-comment">// Vue: 只更新1行</span>
</code></pre>
<h5 data-id="heading-30">5. <strong>组件化开发</strong></h5>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- UserList.vue --&gt;
&lt;script setup&gt;
// 接收父组件传递的数据
const props = defineProps(['users', 'onDelete'])

// 定义向父组件发送的事件
const emit = defineEmits(['user-selected'])
&lt;/script&gt;

&lt;!-- UserItem.vue --&gt;
&lt;script setup&gt;
// 更小组件，更高复用性
const props = defineProps(['user'])
&lt;/script&gt;

&lt;!-- App.vue --&gt;
&lt;template&gt;
    &lt;UserList 
        :users="filteredUsers"
        @user-selected="handleSelect"
    /&gt;
&lt;/template&gt;
</code></pre>
<h4 data-id="heading-31">实际场景对比</h4>
<p><strong>场景：实现用户列表的搜索、排序、分页</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 原生JS实现（约100行代码）</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserTable</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"/>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span> = []
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">filteredUsers</span> = []
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortField</span> = <span class="hljs-string">'id'</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sortDirection</span> = <span class="hljs-string">'asc'</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPage</span> = <span class="hljs-number">1</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pageSize</span> = <span class="hljs-number">10</span>
        
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">init</span>()
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bindEvents</span>()
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadData</span>()
    }
    
    <span class="hljs-comment">// 需要手动处理所有状态同步和DOM更新</span>
    <span class="hljs-comment">// 代码复杂，难以维护</span>
}

<span class="hljs-comment">// Vue实现（约30行代码）</span>
<span class="hljs-keyword">const</span> users = <span class="hljs-title function_">ref</span>([])
<span class="hljs-keyword">const</span> searchKeyword = <span class="hljs-title function_">ref</span>(<span class="hljs-string">''</span>)
<span class="hljs-keyword">const</span> sortField = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'id'</span>)
<span class="hljs-keyword">const</span> page = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)

<span class="hljs-keyword">const</span> displayedUsers = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">let</span> result = [...users.<span class="hljs-property">value</span>]
    
    <span class="hljs-comment">// 筛选</span>
    <span class="hljs-keyword">if</span> (searchKeyword.<span class="hljs-property">value</span>) {
        result = result.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">u</span> =&gt;</span> 
            u.<span class="hljs-property">name</span>.<span class="hljs-title function_">includes</span>(searchKeyword.<span class="hljs-property">value</span>)
        )
    }
    
    <span class="hljs-comment">// 排序</span>
    result.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (sortField.<span class="hljs-property">value</span> === <span class="hljs-string">'name'</span>) {
            <span class="hljs-keyword">return</span> a.<span class="hljs-property">name</span>.<span class="hljs-title function_">localeCompare</span>(b.<span class="hljs-property">name</span>)
        }
        <span class="hljs-keyword">return</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>
    })
    
    <span class="hljs-comment">// 分页</span>
    <span class="hljs-keyword">const</span> start = (page.<span class="hljs-property">value</span> - <span class="hljs-number">1</span>) * <span class="hljs-number">10</span>
    <span class="hljs-keyword">return</span> result.<span class="hljs-title function_">slice</span>(start, start + <span class="hljs-number">10</span>)
})
</code></pre>
<h4 data-id="heading-32">为什么响应式是革命性的？</h4>
<ol>
<li><strong>开发效率提升 3-5 倍</strong>：减少大量重复的 DOM 操作代码</li>
<li><strong>代码可维护性大幅提高</strong>：数据流向清晰，易于调试</li>
<li><strong>性能更优</strong>：智能的更新策略和虚拟 DOM</li>
<li><strong>更好的开发体验</strong>：热重载、TypeScript 支持、DevTools</li>
<li><strong>团队协作更顺畅</strong>：清晰的组件接口和职责划分</li>
</ol>
<hr/>
<h3 data-id="heading-33">发展历程总结</h3>

































<table><thead><tr><th>阶段</th><th>核心技术</th><th>数据流向</th><th>代码量对比</th><th>维护难度</th></tr></thead><tbody><tr><td>纯后端模板</td><td>服务器渲染、模板引擎</td><td>服务器 → HTML</td><td>中等</td><td>高（前后端耦合）</td></tr><tr><td>前后端分离</td><td>Fetch API + DOM操作</td><td>服务器 → JSON → DOM</td><td>多（重复DOM操作）</td><td>中（状态管理复杂）</td></tr><tr><td>响应式驱动</td><td>Vue/React响应式系统</td><td>数据 ↔ 自动更新</td><td>少（专注业务逻辑）</td><td>低（数据驱动）</td></tr></tbody></table>
<h4 data-id="heading-34">性能对比示例</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 更新1000条用户数据中的1条：</span>

<span class="hljs-comment">// 阶段一：后端模板 - 整个页面刷新（慢）</span>
location.<span class="hljs-title function_">reload</span>()

<span class="hljs-comment">// 阶段二：DOM操作 - 重绘整个表格（中等）</span>
tbody.<span class="hljs-property">innerHTML</span> = newHTML  <span class="hljs-comment">// 可能16ms</span>

<span class="hljs-comment">// 阶段三：响应式 - 只更新1行（快）</span>
users.<span class="hljs-property">value</span>[<span class="hljs-number">5</span>].<span class="hljs-property">name</span> = <span class="hljs-string">'新名字'</span>  <span class="hljs-comment">// &lt;1ms</span>
</code></pre>
<hr/>
<h3 data-id="heading-35">给初学者的学习路径建议</h3>
<h4 data-id="heading-36">第一步：打好基础（2-4周）</h4>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 理解原生DOM操作 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"handleClick()"</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"/>) {
    <span class="hljs-comment">// 手动更新DOM</span>
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'result'</span>).<span class="hljs-property">textContent</span> = <span class="hljs-string">'已点击'</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h4 data-id="heading-37">第二步：学习前后端分离（2-3周）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 掌握Fetch API</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadData</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/api/data'</span>)
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>()
    
    <span class="hljs-comment">// 手动更新界面</span>
    <span class="hljs-title function_">renderData</span>(data)
}
</code></pre>
<h4 data-id="heading-38">第三步：拥抱响应式（3-6周）</h4>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 从简单的计数器开始 --&gt;
&lt;script setup&gt;
const count = ref(0)
&lt;/script&gt;

&lt;template&gt;
    &lt;button @click="count++"&gt;
        点击了 {{ count }} 次
    &lt;/button&gt;
&lt;/template&gt;
</code></pre>
<h4 data-id="heading-39">第四步：深入理解原理</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 尝试自己实现简单的响应式系统</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, {
        <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) {
            <span class="hljs-title function_">track</span>(target, key)  <span class="hljs-comment">// 依赖收集</span>
            <span class="hljs-keyword">return</span> target[key]
        },
        <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value</span>) {
            target[key] = value
            <span class="hljs-title function_">trigger</span>(target, key)  <span class="hljs-comment">// 触发更新</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
    })
}
</code></pre>
<hr/>
<h3 data-id="heading-40">未来展望与趋势</h3>
<h4 data-id="heading-41">1. <strong>编译时优化</strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// Vue 3 的 `&lt;script setup&gt;` 编译时优化</span>
<span class="hljs-comment">// 更小的打包体积，更好的性能</span>

<span class="hljs-comment">// React Server Components</span>
<span class="hljs-comment">// 服务器端组件，减少客户端代码</span>
</code></pre>
<h4 data-id="heading-42">2. <strong>跨平台统一</strong></h4>
<pre><code class="hljs language-vue" lang="vue">&lt;!-- 同一套代码，多端运行 --&gt;
&lt;template&gt;
    &lt;!-- Web、小程序、Native共用 --&gt;
    &lt;view @click="handleClick"&gt;
        {{ message }}
    &lt;/view&gt;
&lt;/template&gt;
</code></pre>
<h4 data-id="heading-43">3. <strong>TypeScript 深度集成</strong></h4>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// 完整的类型安全</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-attr">email</span>: <span class="hljs-built_in">string</span>
}

<span class="hljs-keyword">const</span> users = ref&lt;<span class="hljs-title class_">User</span>[]&gt;([])  <span class="hljs-comment">// 类型检查</span>
</code></pre>
<h4 data-id="heading-44">4. <strong>微前端架构</strong></h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 大型应用拆分为多个子应用</span>
<span class="hljs-comment">// 每个子应用可以使用不同技术栈</span>
<span class="hljs-comment">// 独立开发、部署、运行</span>
</code></pre>
<hr/>
<h3 data-id="heading-45">结语</h3>
<p>从纯后端模板到响应式数据驱动，Web 开发的演进始终围绕一个核心目标：<strong>让开发者更专注于业务逻辑，而不是技术细节</strong>。</p>
<p><strong>响应式不是银弹，但它是最优雅的解决方案之一。</strong> 它解决了前端开发中最痛苦的问题：数据与视图的同步。通过声明式的编程模型、自动的依赖跟踪、高效的更新策略，响应式框架让我们能够以更少的代码实现更复杂的功能。</p>
<p>作为初学者，理解这一演进历程非常重要。它不仅帮助你理解为什么需要这些工具，更让你明白如何选择合适的工具。记住：最好的技术不是最复杂的，而是让你忘记技术本身，专注于创造价值的那一个。</p>
<p><strong>开始你的响应式之旅吧，从今天开始，让数据驱动你的界面，而不是让 DOM 操作占据你的时间！</strong></p>
<hr/>
<p><em>本文通过详细的代码对比展示了 Web 开发的完整演进历程。建议读者动手运行每个示例代码，亲自体验不同阶段的开发感受。只有真正经历过 DOM 操作的繁琐，才能深刻理解响应式编程的价值。学习之路漫长，但每一步都算数。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[构建无障碍组件之Alert Dialog Pattern]]></title>    <link>https://juejin.cn/post/7603911453704028203</link>    <guid>https://juejin.cn/post/7603911453704028203</guid>    <pubDate>2026-02-08T08:43:54.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603911453704028203" data-draft-id="7603911453704011819" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="构建无障碍组件之Alert Dialog Pattern"/> <meta itemprop="keywords" content="前端,HTML,交互设计"/> <meta itemprop="datePublished" content="2026-02-08T08:43:54.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="anOnion"/> <meta itemprop="url" content="https://juejin.cn/user/553809592722589"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            构建无障碍组件之Alert Dialog Pattern
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/553809592722589/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    anOnion
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T08:43:54.000Z" title="Sun Feb 08 2026 08:43:54 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Alert Dialog Pattern 详解：构建无障碍中断式对话框</h2>
<p>Alert Dialog 是 Web 无障碍交互的重要组件。本文详解其 WAI-ARIA 实现要点，涵盖角色声明、键盘交互、最佳实践，助你打造中断式对话框，让关键信息触达每位用户。</p>
<h3 data-id="heading-1">一、Alert Dialog 的定义与核心功能</h3>
<p>Alert Dialog（警告对话框）是一种模态对话框，它会中断用户的工作流程以传达重要信息并获取响应。与普通的 Alert 通知不同，Alert Dialog 需要用户明确与之交互后才能继续其他操作。这种设计适用于需要用户立即关注和做出决定的场景。</p>
<p>在实际应用中，Alert Dialog 广泛应用于各种需要用户确认或紧急通知的场景。例如，删除操作前的确认提示、表单提交失败的错误确认、离开页面时的未保存更改提醒等。这些场景都需要用户明确响应才能继续操作，因此 Alert Dialog 成为最佳选择。</p>
<h3 data-id="heading-2">二、Alert Dialog 的特性与注意事项</h3>
<p>Alert Dialog 组件具有几个重要的特性，这些特性决定了它的适用场景和实现方式。首先，Alert Dialog 会获取键盘焦点，确保用户的注意力集中在对话框上。其次，Alert Dialog 通常会阻止用户与页面的其他部分交互，直到用户关闭对话框。这种模态特性确保了用户必须处理重要信息才能继续操作。</p>
<p>Alert Dialog 组件的设计还需要考虑几个关键因素。首先，Alert Dialog 应该始终包含一个明确的关闭方式，如确认按钮或取消按钮。其次，对话框应该有一个清晰的标题，通过 <code>aria-labelledby</code> 或 <code>aria-label</code> 关联。另外，对话框的内容应该通过 <code>aria-describedby</code> 关联，以便屏幕阅读器能够正确读取完整信息。这些属性的正确使用对于无障碍体验至关重要。</p>
<h3 data-id="heading-3">三、WAI-ARIA 角色、状态和属性</h3>
<p>正确使用 WAI-ARIA 属性是构建无障碍 Alert Dialog 组件的技术基础。Alert Dialog 组件的 ARIA 要求包含多个属性的配合使用。</p>
<p><code>role="alertdialog"</code> 是 Alert Dialog 组件的必需属性，它向辅助技术表明这个元素是一个警告对话框。这个属性使浏览器和辅助技术能够将 Alert Dialog 与其他类型的对话框区分开来，从而提供特殊的处理方式，如播放系统提示音。</p>
<p><code>aria-labelledby</code> 或 <code>aria-label</code> 用于标识对话框的标题。如果对话框有可见的标题标签，应该使用 <code>aria-labelledby</code> 引用该标题元素；如果没有可见标题，则使用 <code>aria-label</code> 提供标签。</p>
<p><code>aria-describedby</code> 用于引用包含警告消息的元素。这确保屏幕阅读器能够朗读完整的对话框内容，包括详细的说明和操作提示。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- Alert Dialog 基本结构 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>
  <span class="hljs-attr">id</span>=<span class="hljs-string">"confirm-dialog"</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>
  <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">"dialog-title"</span>
  <span class="hljs-attr">aria-describedby</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"dialog"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-title"</span>&gt;</span>确认删除<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>您确定要删除这个文件吗？此操作无法撤销。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"actions"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"confirm"</span>&gt;</span>确认删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"cancel"</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>
</code></pre>
<p>值得注意的是，Alert Dialog 与普通 Dialog 的主要区别在于 Alert Dialog 用于紧急或重要信息，并且通常包含确认/取消按钮。用户无法忽略 Alert Dialog，必须做出响应才能继续操作。</p>
<h3 data-id="heading-4">四、键盘交互规范</h3>
<p>Alert Dialog 的键盘交互遵循模态对话框的交互模式。用户可以通过多种方式与 Alert Dialog 进行交互。</p>
<ul>
<li><code>Enter</code> 或 <code>Space</code> 用于激活默认按钮，通常是对话框中的主要操作按钮。</li>
<li><code>Tab</code> 键用于在对话框内的焦点元素之间切换，焦点会循环停留 在对话框内部。</li>
<li><code>Escape</code> 键通常用于关闭对话框，相当于点击取消按钮。</li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// ESC 键关闭对话框示例</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'keydown'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">key</span> === <span class="hljs-string">'Escape'</span> &amp;&amp; dialog.<span class="hljs-property">open</span>) {
    dialog.<span class="hljs-title function_">close</span>();
  }
});
</code></pre>
<p>焦点管理是 Alert Dialog 的关键部分。当对话框打开时，焦点应该立即移动到对话框内部或默认按钮上。当对话框关闭时，焦点应该返回到打开对话框的元素。这种焦点管理确保了键盘用户能够保持其工作上下文。</p>
<h3 data-id="heading-5">五、完整示例</h3>
<p>以下是一个完整的 Alert Dialog 实现示例，展示了正确的 HTML 结构、ARIA 属性和焦点管理。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>
  <span class="hljs-attr">id</span>=<span class="hljs-string">"confirm-dialog"</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>
  <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">"dialog-title"</span>
  <span class="hljs-attr">aria-describedby</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"dialog"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-title"</span>&gt;</span>确认删除<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>您确定要删除这个文件吗？此操作无法撤销。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"dialog-actions"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-ghost"</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">"cancel"</span>&gt;</span>
        取消
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-error"</span>
        <span class="hljs-attr">value</span>=<span class="hljs-string">"confirm"</span>&gt;</span>
        删除
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span>
  <span class="hljs-attr">id</span>=<span class="hljs-string">"delete-btn"</span>
  <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-error"</span>&gt;</span>
  删除文件
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">const</span> dialog = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'confirm-dialog'</span>);
  <span class="hljs-keyword">const</span> deleteBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'delete-btn'</span>);
  <span class="hljs-keyword">let</span> previousActiveElement;

  deleteBtn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    previousActiveElement = <span class="hljs-variable language_">document</span>.<span class="hljs-property">activeElement</span>;
    dialog.<span class="hljs-title function_">showModal</span>();
  });

  dialog.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'close'</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"/>) {
    <span class="hljs-keyword">if</span> (dialog.<span class="hljs-property">returnValue</span> === <span class="hljs-string">'confirm'</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'文件已删除'</span>);
    }
    previousActiveElement.<span class="hljs-title function_">focus</span>();
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3 data-id="heading-6">六、最佳实践</h3>
<h4 data-id="heading-7">6.1 实现方式对比</h4>
<p>Alert Dialog 可以通过两种方式实现：使用 <code>div</code> 配合 ARIA 属性，或使用原生 <code>&lt;dialog&gt;</code> 元素。</p>
<h5 data-id="heading-8">传统方式（div + ARIA）</h5>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>
  <span class="hljs-attr">aria-modal</span>=<span class="hljs-string">"true"</span>
  <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">"dialog-title"</span>
  <span class="hljs-attr">aria-describedby</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-title"</span>&gt;</span>确认删除<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>您确定要删除这个文件吗？<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>确认<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>这种方式需要开发者手动处理焦点管理、ESC 键关闭、背景锁定等逻辑。</p>
<h5 data-id="heading-9">推荐方式（原生 dialog）</h5>
<pre><code class="hljs language-html" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>
  <span class="hljs-attr">aria-labelledby</span>=<span class="hljs-string">"dialog-title"</span>
  <span class="hljs-attr">aria-describedby</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"dialog"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-title"</span>&gt;</span>确认删除<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dialog-desc"</span>&gt;</span>您确定要删除这个文件吗？<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"confirm"</span>&gt;</span>确认<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"cancel"</span>&gt;</span>取消<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>
</code></pre>
<p>HTML 原生 <code>&lt;dialog&gt;</code> 元素简化了实现，它提供了：</p>
<ul>
<li>自动焦点管理</li>
<li>内置 ESC 键支持</li>
<li>自动模态背景</li>
<li>内置 ARIA 属性</li>
</ul>
<p><code>&lt;dialog&gt;</code> 元素的默认 <code>role</code> 是 <code>dialog</code>，表示普通对话框。对于 Alert Dialog，需要显式设置 <code>role="alertdialog"</code> 来告诉辅助技术这是一个需要紧急处理的对话框，从而获得系统提示音等特殊处理。</p>
<h4 data-id="heading-10">6.2 焦点管理</h4>
<p>正确的焦点管理对于键盘用户和无障碍体验至关重要。打开对话框时，焦点应该移动到对话框内部或默认按钮。关闭对话框时，焦点应该返回到触发对话框的元素。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 焦点管理最佳实践</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">openDialog</span>(<span class="hljs-params">dialog</span>) {
  <span class="hljs-keyword">const</span> previousFocus = <span class="hljs-variable language_">document</span>.<span class="hljs-property">activeElement</span>;
  dialog.<span class="hljs-title function_">showModal</span>();

  <span class="hljs-comment">// 移动焦点到对话框内</span>
  <span class="hljs-keyword">const</span> focusableElements = dialog.<span class="hljs-title function_">querySelectorAll</span>(
    <span class="hljs-string">'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'</span>,
  );
  <span class="hljs-keyword">if</span> (focusableElements.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
    focusableElements[<span class="hljs-number">0</span>].<span class="hljs-title function_">focus</span>();
  }

  <span class="hljs-comment">// 保存关闭时的焦点元素</span>
  dialog.<span class="hljs-property">dataset</span>.<span class="hljs-property">previousFocus</span> = previousFocus;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">closeDialog</span>(<span class="hljs-params">dialog</span>) {
  dialog.<span class="hljs-title function_">close</span>();
  <span class="hljs-keyword">const</span> previousFocus = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(
    <span class="hljs-string">`[data-focus-id="<span class="hljs-subst">${dialog.dataset.focusId}</span>"]`</span>,
  );
  <span class="hljs-keyword">if</span> (previousFocus) {
    previousFocus.<span class="hljs-title function_">focus</span>();
  }
  dialog.<span class="hljs-title function_">remove</span>();
}
</code></pre>
<h4 data-id="heading-11">6.3 避免过度使用</h4>
<p>Alert Dialog 会中断用户的工作流程，因此应该谨慎使用。只有在真正需要用户立即响应的情况下才使用 Alert Dialog。对于非紧急信息，应该考虑使用普通的 Alert 或 Toast 通知。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 不推荐：过度使用 Alert Dialog --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>
  <span class="hljs-attr">open</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您的设置已保存。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"this.closest('dialog').close()"</span>&gt;</span>确定<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 推荐：使用普通 Alert --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"alert"</span>&gt;</span>您的设置已保存。<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4 data-id="heading-12">6.4 屏幕阅读器兼容性</h4>
<p>确保 <code>&lt;dialog&gt;</code> 对屏幕阅读器用户友好。<code>&lt;dialog&gt;</code> 元素内置了无障碍支持，但仍然建议对 Alert Dialog 设置 <code>role="alertdialog"</code> 来区分紧急对话框。</p>
<pre><code class="hljs language-html" lang="html"><span class="hljs-comment">&lt;!-- 屏幕阅读器友好的 dialog --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dialog</span>
  <span class="hljs-attr">id</span>=<span class="hljs-string">"session-dialog"</span>
  <span class="hljs-attr">role</span>=<span class="hljs-string">"alertdialog"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"dialog"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>重要提醒<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>您的会话将在 5 分钟后过期。请尽快保存您的工作。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"actions"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"continue"</span>&gt;</span>继续使用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"exit"</span>&gt;</span>退出<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dialog</span>&gt;</span>
</code></pre>
<h3 data-id="heading-13">七、Alert 与 Alert Dialog 的区别</h3>
<p>理解 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FWAI%2FARIA%2Fapg%2Fpatterns%2Falert%2F" target="_blank" title="https://www.w3.org/WAI/ARIA/apg/patterns/alert/" ref="nofollow noopener noreferrer">Alert</a> 和 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FWAI%2FARIA%2Fapg%2Fpatterns%2Falertdialog%2F" target="_blank" title="https://www.w3.org/WAI/ARIA/apg/patterns/alertdialog/" ref="nofollow noopener noreferrer">Alert Dialog</a> 的区别对于正确选择通知组件至关重要。虽然两者都是用于传达重要信息，但它们服务于不同的目的和使用场景。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FWAI%2FARIA%2Fapg%2Fpatterns%2Falert%2F" target="_blank" title="https://www.w3.org/WAI/ARIA/apg/patterns/alert/" ref="nofollow noopener noreferrer">Alert</a> 是一种被动通知组件，它不需要用户进行任何交互操作。Alert 会在不被中断用户工作流程的前提下自动通知用户重要信息。用户可以继续当前的工作，Alert 只是在视觉和听觉上提供通知。这种设计适用于不紧急、不需要用户立即响应的信息，例如操作成功确认、后台处理完成通知等。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FWAI%2FARIA%2Fapg%2Fpatterns%2Falertdialog%2F" target="_blank" title="https://www.w3.org/WAI/ARIA/apg/patterns/alertdialog/" ref="nofollow noopener noreferrer">Alert Dialog</a> 则是一种需要用户主动响应的对话框组件。当用户需要做出决定或者提供确认时，应该使用 Alert Dialog。Alert Dialog 会中断用户的工作流程，获取键盘焦点，要求用户必须与之交互才能继续其他操作。这种设计适用于紧急警告、确认删除操作、放弃更改确认等需要用户明确响应的场景。</p>
<p>选择建议：如果信息需要用户立即响应并做出决定，使用 Alert Dialog；如果只是被动通知信息，使用 Alert。</p>
<h3 data-id="heading-14">八、总结</h3>
<p>构建无障碍的对话框组件需要关注元素选择、焦点管理、键盘交互三个层面的细节。从元素选择角度，推荐优先使用原生 <code>&lt;dialog&gt;</code> 元素，它内置了无障碍支持和焦点管理。从焦点管理角度，需要确保打开和关闭时焦点的正确移动。从用户体验角度，应该避免过度使用对话框，只在真正需要用户响应时使用。</p>
<p>WAI-ARIA <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FWAI%2FARIA%2Fapg%2Fpatterns%2Falertdialog%2F" target="_blank" title="https://www.w3.org/WAI/ARIA/apg/patterns/alertdialog/" ref="nofollow noopener noreferrer">Alert Dialog Pattern</a> 为我们提供了清晰的指导方针，遵循这些规范能够帮助我们创建更加包容和易用的 Web 应用。每一个正确实现的对话框，都是提升用户体验和确保重要信息有效传达的重要一步。</p>
<p>文章同步于 an-Onion 的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fan-Onion%2Fan-Onion.github.io" target="_blank" title="https://github.com/an-Onion/an-Onion.github.io" ref="nofollow noopener noreferrer">Github</a>。码字不易，欢迎点赞。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[JDK 6到25 全版本网盘合集 (Windows + Mac + Linux)]]></title>    <link>https://juejin.cn/post/7603677143214784527</link>    <guid>https://juejin.cn/post/7603677143214784527</guid>    <pubDate>2026-02-08T09:02:31.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603677143214784527" data-draft-id="7603671627003887656" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="JDK 6到25 全版本网盘合集 (Windows + Mac + Linux)"/> <meta itemprop="keywords" content="Java,后端"/> <meta itemprop="datePublished" content="2026-02-08T09:02:31.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="宋小黑"/> <meta itemprop="url" content="https://juejin.cn/user/897618008110413"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            JDK 6到25 全版本网盘合集 (Windows + Mac + Linux)
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/897618008110413/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    宋小黑
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T09:02:31.000Z" title="Sun Feb 08 2026 09:02:31 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读1分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">所有版本合集</h2>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/96b6be38a95b45aebfdb0cb0aae83bde~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5a6L5bCP6buR:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771146151&amp;x-signature=kLdS8tdlWgU22BBeyqw6pVipNTE%3D" alt="image.png" loading="lazy"/></p>
<p>通过网盘分享的文件：JDK全集</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1KmnYXE8jrs2dnLriuN1Vdw%3Fpwd%3Ditpr" target="_blank" title="https://pan.baidu.com/s/1KmnYXE8jrs2dnLriuN1Vdw?pwd=itpr" ref="nofollow noopener noreferrer">pan.baidu.com/s/1KmnYXE8j…</a></p>
<p>提取码: itpr</p>
<p>如下是各单独版本</p>
<h2 data-id="heading-1">JDK1.6</h2>
<p>通过网盘分享的文件：JDK1.6</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1tWHFnzoaB4fbSl1MYd8qgg%3Fpwd%3Dgr79" target="_blank" title="https://pan.baidu.com/s/1tWHFnzoaB4fbSl1MYd8qgg?pwd=gr79" ref="nofollow noopener noreferrer">pan.baidu.com/s/1tWHFnzoa…</a></p>
<p>提取码: gr79</p>
<h2 data-id="heading-2">JDK1.7</h2>
<p>通过网盘分享的文件：JDK1.7</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1dQIDiPUqnta3yQi55pcm2A%3Fpwd%3Dxhkh" target="_blank" title="https://pan.baidu.com/s/1dQIDiPUqnta3yQi55pcm2A?pwd=xhkh" ref="nofollow noopener noreferrer">pan.baidu.com/s/1dQIDiPUq…</a></p>
<p>提取码: xhkh</p>
<h2 data-id="heading-3">JDK1.8</h2>
<p>通过网盘分享的文件：JDK1.8</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1iCS3Yi1-_kjquJyZk6oDLA%3Fpwd%3Dtg6k" target="_blank" title="https://pan.baidu.com/s/1iCS3Yi1-_kjquJyZk6oDLA?pwd=tg6k" ref="nofollow noopener noreferrer">pan.baidu.com/s/1iCS3Yi1-…</a></p>
<p>提取码: tg6k</p>
<h2 data-id="heading-4">JDK9</h2>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1aBO393S59b5ujVymdF0vTg%3Fpwd%3Dtua1" target="_blank" title="https://pan.baidu.com/s/1aBO393S59b5ujVymdF0vTg?pwd=tua1" ref="nofollow noopener noreferrer">pan.baidu.com/s/1aBO393S5…</a></p>
<p>提取码: tua1</p>
<h2 data-id="heading-5">JDK10</h2>
<p>通过网盘分享的文件：JDK10</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F15OXI6JChAp2Q3IttHDDfmg%3Fpwd%3D6a7t" target="_blank" title="https://pan.baidu.com/s/15OXI6JChAp2Q3IttHDDfmg?pwd=6a7t" ref="nofollow noopener noreferrer">pan.baidu.com/s/15OXI6JCh…</a></p>
<p>提取码: 6a7t</p>
<h2 data-id="heading-6">JDK11</h2>
<p>通过网盘分享的文件：JDK11</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1vddDP0HGF0bOLPLwb-FovA%3Fpwd%3Dwmep" target="_blank" title="https://pan.baidu.com/s/1vddDP0HGF0bOLPLwb-FovA?pwd=wmep" ref="nofollow noopener noreferrer">pan.baidu.com/s/1vddDP0HG…</a></p>
<p>提取码: wmep</p>
<h2 data-id="heading-7">JDK12</h2>
<p>通过网盘分享的文件：JDK12</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F191YElh8MPBH8uoT8zg6tLg%3Fpwd%3Dbmzp" target="_blank" title="https://pan.baidu.com/s/191YElh8MPBH8uoT8zg6tLg?pwd=bmzp" ref="nofollow noopener noreferrer">pan.baidu.com/s/191YElh8M…</a></p>
<p>提取码: bmzp</p>
<h2 data-id="heading-8">JDK13</h2>
<p>通过网盘分享的文件：JDK13</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1O5mJcvDXEFObYg91TUGXFA%3Fpwd%3D7wrs" target="_blank" title="https://pan.baidu.com/s/1O5mJcvDXEFObYg91TUGXFA?pwd=7wrs" ref="nofollow noopener noreferrer">pan.baidu.com/s/1O5mJcvDX…</a></p>
<p>提取码: 7wrs</p>
<h2 data-id="heading-9">JDK14</h2>
<p>通过网盘分享的文件：JDK14</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1Xl5rrDGh80-Fxlo_Ug3wfg%3Fpwd%3Drve7" target="_blank" title="https://pan.baidu.com/s/1Xl5rrDGh80-Fxlo_Ug3wfg?pwd=rve7" ref="nofollow noopener noreferrer">pan.baidu.com/s/1Xl5rrDGh…</a></p>
<p>提取码: rve7</p>
<h2 data-id="heading-10">JDK15</h2>
<p>通过网盘分享的文件：JDK15</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F194EF9-_Rmh9AX0DH2FWM5w%3Fpwd%3Dkuxj" target="_blank" title="https://pan.baidu.com/s/194EF9-_Rmh9AX0DH2FWM5w?pwd=kuxj" ref="nofollow noopener noreferrer">pan.baidu.com/s/194EF9-_R…</a></p>
<p>提取码: kuxj</p>
<h2 data-id="heading-11">JDK16</h2>
<p>通过网盘分享的文件：JDK16</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1iqcpE1FIa6AsVMsGIYn59w%3Fpwd%3D4j7p" target="_blank" title="https://pan.baidu.com/s/1iqcpE1FIa6AsVMsGIYn59w?pwd=4j7p" ref="nofollow noopener noreferrer">pan.baidu.com/s/1iqcpE1FI…</a></p>
<p>提取码: 4j7p</p>
<h2 data-id="heading-12">JDK17</h2>
<p>通过网盘分享的文件：JDK17</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1Bk5lV7DxukOTi9h0muvrjg%3Fpwd%3Dk686" target="_blank" title="https://pan.baidu.com/s/1Bk5lV7DxukOTi9h0muvrjg?pwd=k686" ref="nofollow noopener noreferrer">pan.baidu.com/s/1Bk5lV7Dx…</a></p>
<p>提取码: k686</p>
<h2 data-id="heading-13">JDK18</h2>
<p>通过网盘分享的文件：JDK18</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1PkPOK_ap-vE8pdXCTFns3Q%3Fpwd%3Dfyiv" target="_blank" title="https://pan.baidu.com/s/1PkPOK_ap-vE8pdXCTFns3Q?pwd=fyiv" ref="nofollow noopener noreferrer">pan.baidu.com/s/1PkPOK_ap…</a></p>
<p>提取码: fyiv</p>
<h2 data-id="heading-14">JDK19</h2>
<p>通过网盘分享的文件：JDK19</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1001F7reDD3f4kElZwxhJjQ%3Fpwd%3D5i5s" target="_blank" title="https://pan.baidu.com/s/1001F7reDD3f4kElZwxhJjQ?pwd=5i5s" ref="nofollow noopener noreferrer">pan.baidu.com/s/1001F7reD…</a></p>
<p>提取码: 5i5s</p>
<h2 data-id="heading-15">JDK20</h2>
<p>通过网盘分享的文件：JDK20</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1WAg3fEMGlyMMWUkHla_AIQ%3Fpwd%3Daeft" target="_blank" title="https://pan.baidu.com/s/1WAg3fEMGlyMMWUkHla_AIQ?pwd=aeft" ref="nofollow noopener noreferrer">pan.baidu.com/s/1WAg3fEMG…</a></p>
<p>提取码: aeft</p>
<h2 data-id="heading-16">JDK21</h2>
<p>通过网盘分享的文件：JDK21</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1HS0nV4NgRE5McYlMn87SlA%3Fpwd%3Dkwwr" target="_blank" title="https://pan.baidu.com/s/1HS0nV4NgRE5McYlMn87SlA?pwd=kwwr" ref="nofollow noopener noreferrer">pan.baidu.com/s/1HS0nV4Ng…</a></p>
<p>提取码: kwwr</p>
<h2 data-id="heading-17">JDK22</h2>
<p>通过网盘分享的文件：JDK22</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1S2EqTU8a16Ey6bEBKbS4CA%3Fpwd%3Db2fe" target="_blank" title="https://pan.baidu.com/s/1S2EqTU8a16Ey6bEBKbS4CA?pwd=b2fe" ref="nofollow noopener noreferrer">pan.baidu.com/s/1S2EqTU8a…</a></p>
<p>提取码: b2fe</p>
<h2 data-id="heading-18">JDK23</h2>
<p>通过网盘分享的文件：JDK23</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1H_B4e2RG2hE_tGj3vL_SCQ%3Fpwd%3Dy4bp" target="_blank" title="https://pan.baidu.com/s/1H_B4e2RG2hE_tGj3vL_SCQ?pwd=y4bp" ref="nofollow noopener noreferrer">pan.baidu.com/s/1H_B4e2RG…</a></p>
<p>提取码: y4bp</p>
<h2 data-id="heading-19">JDK24</h2>
<p>通过网盘分享的文件：JDK24</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1vKSW4DDaDG8URWVrWaj2-A%3Fpwd%3D1jy2" target="_blank" title="https://pan.baidu.com/s/1vKSW4DDaDG8URWVrWaj2-A?pwd=1jy2" ref="nofollow noopener noreferrer">pan.baidu.com/s/1vKSW4DDa…</a></p>
<p>提取码: 1jy2</p>
<h2 data-id="heading-20">JDK25</h2>
<p>通过网盘分享的文件：JDK25</p>
<p>链接: <a href="https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1tuBLLj-6DyPunBZRzTBF9Q%3Fpwd%3Ddc9f" target="_blank" title="https://pan.baidu.com/s/1tuBLLj-6DyPunBZRzTBF9Q?pwd=dc9f" ref="nofollow noopener noreferrer">pan.baidu.com/s/1tuBLLj-6…</a></p>
<p>提取码: dc9f</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring 源码分析 BeanFactoryPostProcessor]]></title>    <link>https://juejin.cn/post/7603771025856528435</link>    <guid>https://juejin.cn/post/7603771025856528435</guid>    <pubDate>2026-02-08T06:21:32.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856528435" data-draft-id="7599852579067133967" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring 源码分析 BeanFactoryPostProcessor"/> <meta itemprop="keywords" content="Spring,Spring Boot,源码"/> <meta itemprop="datePublished" content="2026-02-08T06:21:32.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="暮色妖娆丶"/> <meta itemprop="url" content="https://juejin.cn/user/4292946760307655"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring 源码分析 BeanFactoryPostProcessor
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/4292946760307655/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    暮色妖娆丶
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:21:32.000Z" title="Sun Feb 08 2026 06:21:32 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读16分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>上一篇讲述了 <code>SpringBoot</code> 启动流程和相关源码分析，其中一个重要的刷新方法  <code>AbstractApplicationContext#refresh()</code> 是属于 <code>Spring</code> 的内容，也是 <code>Spring</code> 框架的核心方法，搞懂了这个方法，基本上可以说就完全搞懂了 <code>Spring</code></p>
<p>想了很久不知道对于这样一个复杂的框架，从何开始讲起，那么就按照 <code>AbstractApplicationContext#refresh()</code> 的内部代码顺序来吧，先学习 <code>BeanFactoryPostProcessor</code>。</p>
<p>本篇文章使用的版本是 <code>SpringBoot 3.4.1 、 Spring 6.2.1</code>。</p>
<h2 data-id="heading-1">SpringBoot &amp; Spring 架构图示概览</h2>
<p>这里我以 <code>SpringBoot</code> 源码入口为起点，画了一个相关的流程图，包含了 <code>SpringBoot、Spring 事务、Spring AOP、Spring 事件、BeanFactoryPostProcessor、BeanPostProcessor</code> 等所有 <code>Spring</code> 知识，以及相关模块之间的交互联系，后续也会持续更新此图（因为我自己还没有学完），我试了下作者侧这边更新后，分享的协作链接也会实时变更，希望对大家有帮助</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.processon.com%2Fv%2F696465e679c29354e9e50f69" target="_blank" title="https://www.processon.com/v/696465e679c29354e9e50f69" ref="nofollow noopener noreferrer">SpringBoot &amp; Spring 架构图 持续更新</a> 对于即将需要面试的同学应该会比较有帮助！</p>
<h2 data-id="heading-2">前置知识 IoC 容器</h2>
<p><code>IoC</code> 全称 <code>Inversion of Control</code>，叫做控制反转，它是一种设计原则，其核心思想是将对象创建、依赖管理和生命周期控制的权力从应用程序代码 <strong>反转</strong> 给容器（框架）。</p>
<p>原本我们需要调用某个业务方法，需要自己实例化对象，然后调用该对象某个方法，使用 <code>Spring</code> 之后，我们把该对象交给 <code>Spring</code> 管理，<code>Spring</code> 框架帮我们创建对象，我们只需要拿 <code>Spring</code> 创建好的对象即可。而我们交给 <code>Spring</code> 管理的对象通常就叫做 <code>Bean</code>。</p>
<p><code>IoC</code> 容器就是通常我们常说的 <code>Spring 上下文</code>，<code>ApplicationContext</code> 的实现类，对于 <code>SpringBoot</code> 来说，其扩展的实现类是 <code>AnnotationConfigServletWebServerApplicationContext</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
   <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(SpringAiDemoApplication.class, args);
}
</code></pre>
<p><code>SpringBoot</code> 主类的 <code>run</code> 方法，其返回值就是一个 <code>IoC</code> 容器，<code>ApplicationContext</code> 的子接口</p>
<h2 data-id="heading-3">前置知识 BeanDefinition 和 Bean</h2>
<p>在开始之前，我相信大家都是已经熟悉 <code>Spring</code> 框架的日常用法，我们需要有一个前置知识储备，在 <code>Spring</code> 容器中，<code>Bean</code> 的创建都是由 <code>BeanDefinition</code> 决定的， <code>BeanDefinition</code> 描述了这个 <code>Bean</code> 的所有信息</p>
<ul>
<li><code>Bean</code> 的类型</li>
<li><code>Bean</code> 的名字</li>
<li>单例还是多例</li>
<li>是否延迟加载</li>
<li>是否允许自动装配</li>
<li>等等</li>
</ul>
<p>比如我们使用 <code>@Configuration、@Bean、@Component</code> 注解一个 <code>Bean</code>。刷新方法中，先解析这些注解得到了 <code>BeanDefinition</code> 信息，当所有配置相关的注解被解析完，得到一个</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);
<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> List&lt;String&gt; beanDefinitionNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">256</span>);
</code></pre>
<p>然后 <code>Spring</code> 遍历这个 <code>beanDefinitionNames</code> 去创建 <code>Bean</code>。</p>
<blockquote>
<p>因为 HashMap 是无序的，创建 Bean 需要根据顺序创建，所以需要这个 beanDefinitionNames</p>
</blockquote>
<h2 data-id="heading-4">BeanFactoryPostProcessor 的作用</h2>
<p>学习源码，最有效的方式之一就是看注释，</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * Factory hook that allows for custom modification of an application context's
 * bean definitions, adapting the bean property values of the context's underlying
 * bean factory.
 * ......
 */</span>
<span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> {

    <span class="hljs-comment">/**
     * Modify the application context's internal bean factory after its standard
     * initialization. All bean definitions will have been loaded, but no beans
     * will have been instantiated yet. This allows for overriding or adding
     * properties even to eager-initializing beans.
     * <span class="hljs-doctag">@param</span> beanFactory the bean factory used by the application context
     * <span class="hljs-doctag">@throws</span> org.springframework.beans.BeansException in case of errors
     */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException;

}
</code></pre>
<p>注释说明这个类的作用相当于一个工厂回调函数（通常我们叫它 <code>Bean 工厂后置处理器</code>），可以调整上下文的底层<code>Bean</code> 工厂的 <code>Bean</code> 属性值。也就是在 <code>Bean</code> 创建前，<code>BeanDefinition</code> 已默认加载后，修改某些 <code>BeanDefinition</code> 。因为 <code>Bean</code> 的创建是由 <code>BeanDefinition</code> 决定的，所以修改 <code>BeanDefinition</code>，也就相当于修改即将要创建的 <code>Bean</code></p>
<h2 data-id="heading-5">内置的 BeanFactoryPostProcessor</h2>
<p>在上一篇 <code>SpringBoot</code> 文章中，我们提到在创建 <code>Spring</code> 上下文的时候，<code>AnnotationConfigServletWebServerApplicationContext</code> 的构造方法中，会注册一些内置的 <code>BeanFactoryPostProcessor</code>。源码</p>
<pre><code class="hljs language-java" lang="java">org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors()
</code></pre>
<p>内置会注册以下后置处理器</p>
<pre><code class="hljs language-java" lang="java">ConfigurationClassPostProcessor  处理所有配置注解 <span class="hljs-meta">@Componentscan</span>、<span class="hljs-meta">@Import</span>、<span class="hljs-meta">@Bean</span>、<span class="hljs-meta">@Component</span> 等
AutowiredAnnotationBeanPostProcessor  处理 <span class="hljs-meta">@Autowired</span>
CommonAnnotationBeanPostProcessor     处理 <span class="hljs-meta">@PostConstruct</span>、<span class="hljs-meta">@Resource</span> 等
PersistenceAnnotationBeanPostProcessor(如果用了 JPA)
EventListenerMethodProcessor    处理 <span class="hljs-meta">@EventListener</span>
DefaultEventListenerFactory  （不是后置处理器，不知道为什么放在这个方法里）
</code></pre>
<p>这里只有 <code>ConfigurationClassPostProcessor</code> 和 <code>EventListenerMethodProcessor</code> 是工厂后置处理器 <code>BeanFactoryPostProcessor</code>，其他都是 Bean 的后置处理器 <code>BeanPostProcessor</code>，下一篇文章会介绍。在介绍 <code>ConfigurationClassPostProcessor</code> 和 <code>EventListenerMethodProcessor</code> 的作用之前，我们先学习一个 <code>BeanFactoryPostProcessor</code> 的扩展接口 <code>BeanDefinitionRegistryPostProcessor</code>。</p>
<h2 data-id="heading-6">BeanDefinitionRegistryPostProcessor</h2>
<p>还是老规矩，学习一个类之前先看注释</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
 * Extension to the standard {<span class="hljs-doctag">@link</span> BeanFactoryPostProcessor} SPI, allowing for
 * the registration of further bean definitions &lt;i&gt;before&lt;/i&gt; regular
 * BeanFactoryPostProcessor detection kicks in. In particular,
 * BeanDefinitionRegistryPostProcessor may register further bean definitions
 * which in turn define BeanFactoryPostProcessor instances.

 * <span class="hljs-doctag">@see</span> org.springframework.context.annotation.ConfigurationClassPostProcessor
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> {

    <span class="hljs-comment">/**
     * Modify the application context's internal bean definition registry after its
     * standard initialization. All regular bean definitions will have been loaded,
     * but no beans will have been instantiated yet. This allows for adding further
     * bean definitions before the next post-processing phase kicks in.
     * <span class="hljs-doctag">@param</span> registry the bean definition registry used by the application context
     * <span class="hljs-doctag">@throws</span> org.springframework.beans.BeansException in case of errors
     */</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException;
}
</code></pre>
<p>注释说 <code>BeanDefinitionRegistryPostProcessor</code> 是 <code>BeanFactoryPostProcessor</code> 的一个扩展接口。容器刷新过程中 <code>postProcessBeanDefinitionRegistry()</code> 在 <code>postProcessBeanFactory()</code> 之前执行，他们的区别和作用如下</p>
<h3 data-id="heading-7">和 BeanFactoryPostProcessor 的区别对比</h3>
<p>这里用一个表格来对比 <code>BeanDefinitionRegistryPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 的方法</p>



































<table><thead><tr><th>维度</th><th>postProcessBeanDefinitionRegistry</th><th>postProcessBeanFactory</th></tr></thead><tbody><tr><td><strong>执行时机</strong></td><td><strong>更早</strong>，在所有 BeanFactoryPostProcessor 之前</td><td><strong>稍晚</strong>，在所有 postProcessBeanDefinitionRegistry 之后</td></tr><tr><td><strong>参数类型</strong></td><td><code>BeanDefinitionRegistry</code></td><td><code>ConfigurableListableBeanFactory</code></td></tr><tr><td><strong>主要用途</strong></td><td><strong>注册、修改、移除</strong> BeanDefinition</td><td><strong>修改</strong> 已注册的 BeanDefinition，不能注册和移除</td></tr><tr><td><strong>能力范围</strong></td><td><strong>注册新 Bean</strong> 的能力更强</td><td><strong>修改现有 Bean</strong> 的属性</td></tr><tr><td><strong>执行顺序</strong></td><td>第一阶段</td><td>第二阶段</td></tr></tbody></table>
<p>也就是说他们两都是对 <code>BeanDefinition</code> 做操作的，只不过时机不同</p>
<h2 data-id="heading-8">常见的 BeanFactoryPostProcessor</h2>
<p><code>SpringBoot</code> 项目中有一些内置的工厂后置处理器</p>
<ul>
<li><code>ConfigurationClassPostProcessor</code>  解析配置类，获取 <code>BeanDefiniton</code></li>
<li><code>EventListenerMethodProcessor</code>     初始化事件工厂，为了后续创建事件监听器</li>
<li><code>PropertySourcesPlaceholderConfigurer</code> 处理配置类成员变量的值有属性占位符，比如有些 <code>Bean</code> 的某个属性值是 <code>${mybatis-plus.lazy-initialization}</code> 这种表达式，就是通过这个后置处理器来解析赋值</li>
<li><code>MapperScannerConfigurer</code> 如果使用了 <code>mybatis</code> ，扫描 <code>@Mapper</code> 注解的类，添加到 <code>Spring</code> 容器</li>
<li><code>CachingMetadataReaderFactoryPostProcessor</code>  缓存 <code>ResourceLoader</code> 已加载的配置类，不要重复加载</li>
</ul>
<p>下面我们详细介绍其中几个重要的工厂后置处理器的作用。</p>
<h2 data-id="heading-9">BeanFactoryPostProcessor 的执行</h2>
<p>工厂后置处理器的执行方法是通过一个委托类 <code>PostProcessorRegistrationDelegate</code> 实现的</p>
<pre><code class="hljs language-java" lang="java">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
</code></pre>
<p>这个方法非常有意思，作者在这里给出了一大段的注释，告诉读者不要再去 <code>Github</code> 提 <code>issue</code> 了，因为这个方法的代码看起来很乱、有很多重复代码，很多读者提了 <code>issue</code> 表明这个方法需要优化，但是作者一一拒绝，回应说这种实现是必要的，一定要确保工厂后置处理器的执行顺序。有兴趣可以查阅上述方法的源码</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5a1cf98563ec41d08e400d64fcb53590~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771136492&amp;x-signature=ork6UczAeDRGazI37V22JO8O63Y%3D" alt="image.png" loading="lazy"/></p>
<p>这里作者将 <code>BeanDefinitionRegistryPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 分开，并且将它们分别按照顺序排序放到不同列表中依次执行。</p>
<blockquote>
<p>注意，这个阶段还没有创建 <code>Bean</code> ，所以要执行的 <code>BeanFactoryPostProcessor</code> ，都是通过从 <code>BeanFactory</code> 里面的 <code>beanDefinitonNames</code> 集合拿到的，使用 <code>beanFactory.getBeanNamesForType()</code> 方法</p>
</blockquote>
<h2 data-id="heading-10">配置类加载原理 （非常非常重要）ConfigurationClassPostProcessor</h2>
<p>这是一个非常重要的 <code>BeanFactoryPostProcessor</code>，<code>Spring</code> 项目启动加载配置类几乎全都是它实现的，除了我们自己声明的 <code>Service、Controller</code>。 配置类本身也是 <code>Spring Bean</code>。</p>
<p>其实我们查看源码会发现 <code>@Service、@Controller、@Configuration</code> 本身就是一个 <code>@Component</code>。查看 <code>@Component</code> 的注释</p>
<pre><code class="hljs language-vbnet" lang="vbnet">/**
 * Indicates that the annotated <span class="hljs-keyword">class</span> <span class="hljs-built_in">is</span> a &lt;em&gt;component&lt;/em&gt;.
 *
 * &lt;p&gt;Such classes are considered <span class="hljs-keyword">as</span> candidates <span class="hljs-keyword">for</span> <span class="hljs-keyword">auto</span>-detection
 * <span class="hljs-keyword">when</span> <span class="hljs-keyword">using</span> annotation-based configuration <span class="hljs-built_in">and</span> classpath scanning.
 */
</code></pre>
<p>被这个注解标注的类都会被视为一个组件，在被扫描的时候会被认为是一个配置类</p>
<h3 data-id="heading-11">代码解读</h3>
<p><code>ConfigurationClassPostProcessor</code> 是一个 <code>BeanDefinitionRegistryPostProcessor</code> 。我们查看源码方法的调用过程 <code>postProcessBeanDefinitionRegistry → processConfigBeanDefinitions → ConfigurationClassParser#parse → ConfigurationClassParser#processConfigurationClass → ConfigurationClassParser#doProcessConfigurationClass(arg1,arg2) → doProcessConfigurationClass(arg1,arg2,arg3)</code></p>
<p>先看 <code>parse()</code> 方法</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> {
    <span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : configCandidates) {
       <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> holder.getBeanDefinition();
       <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition annotatedBeanDef) {
             parse(annotatedBeanDef, holder.getBeanName());
          }
          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition abstractBeanDef &amp;&amp; abstractBeanDef.hasBeanClass()) {
             parse(abstractBeanDef.getBeanClass(), holder.getBeanName());
          }
          <span class="hljs-keyword">else</span> {
             parse(bd.getBeanClassName(), holder.getBeanName());
          }
       }
       <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) {
          <span class="hljs-keyword">throw</span> ex;
       }
       <span class="hljs-keyword">catch</span> (Throwable ex) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(
                <span class="hljs-string">"Failed to parse configuration class ["</span> + bd.getBeanClassName() + <span class="hljs-string">"]"</span>, ex);
       }
    }

    <span class="hljs-built_in">this</span>.deferredImportSelectorHandler.process();
}
</code></pre>
<p>我们传入的入参就是 <code>SpringBoot</code> 主类的 <code>BeanDefinition</code>，这个方法根据 <code>BeanDefinition</code> 实际的类型走不同的重载方法，<code>SpringBoot</code> 项目主类的定义类型是 <code>AnnotatedBeanDefinition</code> 。 接下来我们看 <code>doProcessConfigurationClass(arg1,arg2)</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, Predicate&lt;String&gt; filter)</span> {
     <span class="hljs-comment">//......</span>
    <span class="hljs-comment">// 循环处理配置类，返回的 sourceClass 是父类，只要不为空就一直向上找父类循环处理</span>
    <span class="hljs-type">SourceClass</span> <span class="hljs-variable">sourceClass</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">try</span> {
       sourceClass = asSourceClass(configClass, filter);
       <span class="hljs-keyword">do</span> {
          sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);
       }
       <span class="hljs-keyword">while</span> (sourceClass != <span class="hljs-literal">null</span>);
    }
    <span class="hljs-keyword">catch</span> (IOException ex) {
    <span class="hljs-comment">//...</span>
    }

    <span class="hljs-built_in">this</span>.configurationClasses.put(configClass, configClass);
}
</code></pre>
<p>这里有一个循环，解析传入的配置类，返回该配置类的父类，如果该配置类的父类不为空，就一直解析。
接下来内部最直观的解析配置类的方法 <code>doProcessConfigurationClass(arg1,arg2,arg3)</code> 。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title function_">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;String&gt; filter)</span> {
    <span class="hljs-keyword">if</span> (configClass.getMetadata().isAnnotated(Component.class.getName())) {
       <span class="hljs-comment">// 解析内部类。比如一个加了 @Configuration 的配置类，有一个静态内部类也加了 @Configuration</span>
       processMemberClasses(configClass, sourceClass, filter);
    }

    <span class="hljs-comment">// 解析 @PropertySource 注解</span>
    <span class="hljs-keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(
          sourceClass.getMetadata(), org.springframework.context.annotation.PropertySource.class,
          PropertySources.class, <span class="hljs-literal">true</span>)) {
       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.propertySourceRegistry != <span class="hljs-literal">null</span>) {
          <span class="hljs-built_in">this</span>.propertySourceRegistry.processPropertySource(propertySource);
       }
    }

    <span class="hljs-comment">// 解析 @ComponentScans 注解</span>
    Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(),ComponentScan.class, ComponentScans.class, MergedAnnotation::isDirectlyPresent);

    <span class="hljs-keyword">if</span> (componentScans.isEmpty()) {
       componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScan.class, ComponentScans.class, MergedAnnotation::isMetaPresent);
    }

    <span class="hljs-keyword">if</span> (!componentScans.isEmpty()) {
       List&lt;Condition&gt; registerBeanConditions = collectRegisterBeanConditions(configClass);
       <span class="hljs-keyword">for</span> (AnnotationAttributes componentScan : componentScans) {
          <span class="hljs-comment">// 解析 @ComponentScan 注解(注意这里直接向 Spring 容器注册了 BeanDefiniton)</span>
          <span class="hljs-comment">//其他注解解析都是先封装成一个 ConfigurationClass 对象，后续统一注册 BeanDefinition</span>
          Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions = <span class="hljs-built_in">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());
          <span class="hljs-comment">// 检查 @ComponentScan 扫描到的配置类是否还有其他配置注解，例如 @Import，递归解析</span>
          <span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) {
             <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">bdCand</span> <span class="hljs-operator">=</span> holder.getBeanDefinition().getOriginatingBeanDefinition();
             <span class="hljs-keyword">if</span> (bdCand == <span class="hljs-literal">null</span>) {
                bdCand = holder.getBeanDefinition();
             }
             <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="hljs-built_in">this</span>.metadataReaderFactory)) {
                parse(bdCand.getBeanClassName(), holder.getBeanName());
             }
          }
       }
    }

    <span class="hljs-comment">// 解析 @Import 注解（SpringBoot 自动配置类的核心实现）</span>
    processImports(configClass, sourceClass, getImports(sourceClass), filter, <span class="hljs-literal">true</span>);

    <span class="hljs-comment">//解析 @ImportResource 注解</span>
    <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">importResource</span> <span class="hljs-operator">=</span> AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);
    <span class="hljs-keyword">if</span> (importResource != <span class="hljs-literal">null</span>) {
       String[] resources = importResource.getStringArray(<span class="hljs-string">"locations"</span>);
       Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanDefinitionReader</span>&gt; readerClass = importResource.getClass(<span class="hljs-string">"reader"</span>);
       <span class="hljs-keyword">for</span> (String resource : resources) {
          <span class="hljs-type">String</span> <span class="hljs-variable">resolvedResource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.environment.resolveRequiredPlaceholders(resource);
          configClass.addImportedResource(resolvedResource, readerClass);
       }
    }

    <span class="hljs-comment">// 解析 @Bean 注解</span>
    Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);
    <span class="hljs-keyword">for</span> (MethodMetadata methodMetadata : beanMethods) {
       <span class="hljs-keyword">if</span> (methodMetadata.isAnnotated(<span class="hljs-string">"kotlin.jvm.JvmStatic"</span>) &amp;&amp; !methodMetadata.isStatic()) {
          <span class="hljs-keyword">continue</span>;
       }
       configClass.addBeanMethod(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanMethod</span>(methodMetadata, configClass));
    }

    <span class="hljs-comment">// 解析当前类实现的接口里面加了 @Bean 的 default 方法</span>
    processInterfaces(configClass, sourceClass);

    <span class="hljs-comment">// 解析父类</span>
    <span class="hljs-keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) {
       <span class="hljs-type">String</span> <span class="hljs-variable">superclass</span> <span class="hljs-operator">=</span> sourceClass.getMetadata().getSuperClassName();
       <span class="hljs-keyword">if</span> (superclass != <span class="hljs-literal">null</span> &amp;&amp; !superclass.startsWith(<span class="hljs-string">"java"</span>)) {
          <span class="hljs-type">boolean</span> <span class="hljs-variable">superclassKnown</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.knownSuperclasses.containsKey(superclass);
          <span class="hljs-built_in">this</span>.knownSuperclasses.add(superclass, configClass);
          <span class="hljs-keyword">if</span> (!superclassKnown) {
             <span class="hljs-comment">// Superclass found, return its annotation metadata and recurse</span>
             <span class="hljs-keyword">return</span> sourceClass.getSuperClass();
          }
       }
    }
    <span class="hljs-comment">// No superclass -&gt; processing is complete</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<p>我们可以继续阅读 <code>processMemberClasses()、processImports()</code> 等每一个具体解析注解的方法，会发现
这个解析方法的调用是一个递归的过程。先根据一个主配置类，在 <code>SpringBoot</code> 中就是应用启动主类。由于 <code>@SpringBootApplication</code> 内部组合了 <code>@Configuration</code> ，所以它是一个配置类，<code>SpringBoot</code> 会以主类为入口，从它开始扫描，然后由于 <code>SpringBootApplication</code> 内部组合了 <code>@ComponentScan</code> 注解，所以会解析主类所在的包下的所有配置类。然后由于它内部又组合了 <code>SpringBootApplication → @EnableAutoConfiguration → @Import(AutoConfigurationImportSelector.class)</code>，所以会解析 <code>AutoConfigurationImportSelector</code> 获取的所有配置类。这也是 <code>SpringBoot</code> 自动配置的核心实现原理</p>
<h3 data-id="heading-12">SpringBoot 自动配置的核心原理</h3>
<p>在 <code>SpringBoot</code> 文章中我们说过，这个 <code>AutoConfigurationImportSelector</code> 是 <code>SpringBoot</code> 自动配置的核心。从上面的解析方法 <code>doProcessConfigurationClass(arg1,arg2,arg3)</code> 我们知道它会解析 <code>@Import</code> 注解，然后我们看  <code>processImports()</code> 的源码</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">for</span> (SourceClass candidate : importCandidates) {
    <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportSelector.class)) {
       <span class="hljs-comment">// 处理 ImportSelector 的逻辑</span>
       Class&lt;?&gt; candidateClass = candidate.loadClass();
       <span class="hljs-type">ImportSelector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class,<span class="hljs-built_in">this</span>.environment, <span class="hljs-built_in">this</span>.resourceLoader, <span class="hljs-built_in">this</span>.registry);
       Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter();
       <span class="hljs-keyword">if</span> (selectorFilter != <span class="hljs-literal">null</span>) {
          filter = filter.or(selectorFilter);
       }
       <span class="hljs-keyword">if</span> (selector <span class="hljs-keyword">instanceof</span> DeferredImportSelector deferredImportSelector) {
          <span class="hljs-built_in">this</span>.deferredImportSelectorHandler.handle(configClass, deferredImportSelector);
       }
       <span class="hljs-keyword">else</span> {
          String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());
          Collection&lt;SourceClass&gt; importSourceClasses = asSourceClasses(importClassNames, filter);
          processImports(configClass, currentSourceClass, importSourceClasses, filter, <span class="hljs-literal">false</span>);
       }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) {
       <span class="hljs-comment">// 处理 ImportBeanDefinitionRegistrar 的逻辑</span>
       Class&lt;?&gt; candidateClass = candidate.loadClass();
       <span class="hljs-type">ImportBeanDefinitionRegistrar</span> <span class="hljs-variable">registrar</span> <span class="hljs-operator">=</span>
             ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class,
                   <span class="hljs-built_in">this</span>.environment, <span class="hljs-built_in">this</span>.resourceLoader, <span class="hljs-built_in">this</span>.registry);
       configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());
    }
    <span class="hljs-keyword">else</span> {
       <span class="hljs-comment">// 处理普通配置类的逻辑</span>
       <span class="hljs-built_in">this</span>.importStack.registerImport(
             currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());
       processConfigurationClass(candidate.asConfigClass(configClass), filter);
    }
}

</code></pre>
<p>这里对于 <code>@Import</code> 有三种处理逻辑，相当于一个策略模式的体现</p>
<ul>
<li><code>@Import(XxxImportSelector.class)</code> 执行 <code>selectImports</code> 获取导入的配置类</li>
<li><code>@Import(XxxImportBeanDefinitionRegistrar.class)</code> 执行 <code>registerBeanDefinitions</code> 注册 <code>BeanDefinition</code></li>
<li><code>@Import(XxxConfiguration.class)</code> 普通配置类，直接解析</li>
</ul>
<p>对于 <code>@Import</code> 注解中的不同类型值，会进行不同的处理逻辑，但最终都是解析配置类，无非是导入的方式不同，具体我们可以看对应接口的方法说明。</p>
<blockquote>
<p>注意对于 <code>ImportSelector</code> 有两种处理方式，它有一个子接口 <code>DeferredImportSelector</code>，延迟导入器，如果导入的是此类型，那么会执行其内部类 <code>DeferredImportSelector.Group#process</code></p>
</blockquote>
<p>我们查看 <code>AutoConfigurationImportSelector.AutoConfigurationGroup#process()</code> 方法的源码，看它是怎么获取到自动配置类的</p>
<blockquote>
<p>这里有一个点要注意，对于 <code>SpringBoot</code> 的 <code>AutoConfigurationImportSelector</code> 是一个延迟导入器，获取导入的配置类列表不是直接调用 <code>AutoConfigurationImportSelector.selectImports()</code> 而是调用内部类 <code>AutoConfigurationGroup.process()</code> 和 <code>AutoConfigurationGroup.selectImports()</code></p>
</blockquote>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> {
    <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) {
       <span class="hljs-keyword">return</span> EMPTY_ENTRY;
    }
    <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> getAttributes(annotationMetadata);
    <span class="hljs-comment">//扫描 imports 文件获取自动配置类列表</span>
    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
    configurations = removeDuplicates(configurations);
    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    configurations.removeAll(exclusions);
    configurations = getConfigurationClassFilter().filter(configurations);
    fireAutoConfigurationImportEvents(configurations, exclusions);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationEntry</span>(configurations, exclusions);
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">protected</span> List&lt;String&gt; <span class="hljs-title function_">getCandidateConfigurations</span><span class="hljs-params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> {
    <span class="hljs-type">ImportCandidates</span> <span class="hljs-variable">importCandidates</span> <span class="hljs-operator">=</span> ImportCandidates.load(<span class="hljs-built_in">this</span>.autoConfigurationAnnotation,getBeanClassLoader());
    List&lt;String&gt; configurations = importCandidates.getCandidates();
    <span class="hljs-keyword">return</span> configurations;
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ImportCandidates <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;?&gt; annotation, ClassLoader classLoader)</span> {
    Assert.notNull(annotation, <span class="hljs-string">"'annotation' must not be null"</span>);
    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoaderToUse</span> <span class="hljs-operator">=</span> decideClassloader(classLoader);
    <span class="hljs-type">String</span> <span class="hljs-variable">location</span> <span class="hljs-operator">=</span> String.format(LOCATION, annotation.getName());
    Enumeration&lt;URL&gt; urls = findUrlsInClasspath(classLoaderToUse, location);
    List&lt;String&gt; importCandidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">while</span> (urls.hasMoreElements()) {
       <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> urls.nextElement();
       importCandidates.addAll(readCandidateConfigurations(url));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImportCandidates</span>(importCandidates);
}
</code></pre>
<p>好了，这里有一个 <code>LOCATION</code> 常量，我们看他的值是写死的</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> LOCATION = <span class="hljs-string">"META-INF/spring/%s.imports"</span>;
</code></pre>
<p>这里传入的注解就是 <code>@AutoConfiguration</code> 的全类名，<code>org.springframework.boot.autoconfigure.AutoConfiguration</code></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AutoConfigurationImportSelector</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>);
}

AutoConfigurationImportSelector(Class&lt;?&gt; autoConfigurationAnnotation) {
    <span class="hljs-built_in">this</span>.autoConfigurationAnnotation = (autoConfigurationAnnotation != <span class="hljs-literal">null</span>) ? autoConfigurationAnnotation : AutoConfiguration.class;
}
</code></pre>
<p>替换掉 <code>LOCATION</code> 的占位符之后，我们得到完整的路径地址</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">LOCATION</span> = META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
</code></pre>
<p>然后我们再去看 <code>MyBatisPlus、Redis、RabbitMQ</code> 的 <code>starter</code>，我们都会看到这个路径下有这样的文件</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/743446472e194f77a2b07685fdd92278~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771136492&amp;x-signature=i%2FFo8ac4Z2jWPqbxtx6n97AHm0k%3D" alt="企业微信截图_f001c7fb-e86a-46f5-8db5-500d33a15b4d.png" loading="lazy"/></p>
<p>这下恍然大悟了吧，那现在让你自己定义一个 <code>springboot-starter</code>，还觉得困难吗？</p>
<blockquote>
<p>注意 SpringBoot 3.0 以前读取的是 <code>spring.factories</code> ，之后改成了 <code>imports</code> 文件</p>
</blockquote>
<h3 data-id="heading-13">配置类加载过程流程图</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af334198f2224545bbb4bd88a440f229~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771136492&amp;x-signature=hAKvfLugez6cJuIsQkPgh7s9spw%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-14">配置类递归解析流程图</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/dcb0df7b91fd43148db39daca9f50afa~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5pqu6Imy5aaW5aiG5Li2:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771136492&amp;x-signature=tsaF%2Bl2%2FufFSkkmXY8fqX4lVprE%3D" alt="企业微信截图_41c7f5f9-d4c4-4bc1-83c1-76eaac5eb168.png" loading="lazy"/></p>
<p>下面的树形结构可能有助于进一步理解这个流程</p>
<pre><code class="hljs language-ruby" lang="ruby">/**
 * <span class="hljs-title class_">Spring</span> 配置类扫描解析的递归流程
 * 
 * 示例配置结构：
 * └── <span class="hljs-title class_">SpringBootApplication</span> (<span class="hljs-variable">@Configuration</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">0</span>]
  *    ├── <span class="hljs-variable">@ComponentScan</span>(<span class="hljs-string">"com.example"</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">1</span>]
 *     │   └── com.example.<span class="hljs-title class_">UserController</span> (<span class="hljs-variable">@Controller</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">2</span>]
 *     │       └── <span class="hljs-variable">@Configuration</span> [<span class="hljs-title class_">Level</span> <span class="hljs-number">3</span>]
 *     └── <span class="hljs-variable">@Bean</span>(appBean)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">1</span>]
 *     ├── <span class="hljs-variable">@Import</span>(<span class="hljs-title class_">AutoConfigurationImportSelector</span>.<span class="hljs-keyword">class</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">1</span>]
 *     │   ├── <span class="hljs-variable">@Configuration</span>
 *     │   ├── <span class="hljs-variable">@Import</span>(<span class="hljs-title class_">DataSourceConfig</span>.<span class="hljs-keyword">class</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">2</span>]
 *     │   │   ├── <span class="hljs-variable">@Configuration</span>
 *     │   │   ├── <span class="hljs-variable">@Import</span>(<span class="hljs-title class_">RedisConfig</span>.<span class="hljs-keyword">class</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">3</span>]
 *     │   │   │   ├── <span class="hljs-variable">@Configuration</span>
 *     │   │   │   └── <span class="hljs-variable">@Import</span>(<span class="hljs-title class_">CacheConfig</span>.<span class="hljs-keyword">class</span>)  [<span class="hljs-title class_">Level</span> <span class="hljs-number">4</span>]
 *     │   │   │       ├── <span class="hljs-variable">@Configuration</span>
 *     │   │   │       └── <span class="hljs-variable">@ComponentScan</span>(<span class="hljs-string">"com.cache"</span>)
 *     │   │   └── <span class="hljs-variable">@Bean</span>(dataSource)
 *     │   └── <span class="hljs-variable">@Bean</span>(service)
 *<span class="hljs-regexp">/
</span></code></pre>
<p>只要当前正在扫描处理的配置类里面还有其他配置注解，就一直递归扫描解析，直到解析完毕为止。</p>
<h3 data-id="heading-15">特殊的 @ComponentScan</h3>
<p>仔细观察源码会发现 <code>@ComponentScan</code> 注解的扫描过程中，使用 <code>ComponentScanAnnotationParser</code> 解析之后直接向 <code>Spring</code> 容器注册了 <code>BeanDefinition</code> 。而其他注解的扫描，例如 <code>@Configuration、@Bean、@Import</code> 都是将需要处理的配置类信息存储到 <code>ConfigurationClassParser</code> 的成员变量中。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//@ComponentScan 解析器</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ComponentScanAnnotationParser componentScanParser;
<span class="hljs-comment">//配置类集合</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();

<span class="hljs-comment">//延迟导入器处理器</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DeferredImportSelectorHandler</span> <span class="hljs-variable">deferredImportSelectorHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeferredImportSelectorHandler</span>();
</code></pre>
<p>此时还没有注册它们的 <code>BeanDefinition</code></p>
<h3 data-id="heading-16">分类构建 BeanDefinition</h3>
<p>上一段我们说了，前面的步骤解析完之后，只是把每一个配置类信息存储起来，抽象成一个 <code>Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses</code>，此时还没有向 <code>Spring</code> 容器中注册成 <code>BeanDefiniton</code>。我们可以查看源码，这个类里面有一些成员变量</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigurationClass</span> {
    <span class="hljs-comment">//bean 名称</span>
    <span class="hljs-keyword">private</span> String beanName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;ConfigurationClass&gt; importedBy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-number">1</span>);

    <span class="hljs-comment">//@Bean 方法集合</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;BeanMethod&gt; beanMethods = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();
    <span class="hljs-comment">//@ImportResource 集合</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanDefinitionReader</span>&gt;&gt; importedResources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
    <span class="hljs-comment">//ImportBeanDefinitionRegistrar 集合</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&gt; importBeanDefinitionRegistrars =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();
}
</code></pre>
<p>当所有配置类解析完成之后，得到一个全量集合 <code>Map&lt;ConfigurationClass, ConfigurationClass&gt;</code> ，然后在
<code>ConfigurationClassPostProcessor#processConfigBeanDefinitions()</code> 中调用 <code>ConfigurationClassBeanDefinitionReader.loadBeanDefinitions()</code> 这一步执行完毕后，整个应用所有的配置都构建 <code>BeanDefinition</code> 加载完毕</p>
<h2 data-id="heading-17">EventListenerMethodProcessor</h2>
<p>它是一个解析事件监听的后置处理器</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> {
    <span class="hljs-built_in">this</span>.beanFactory = beanFactory;
    <span class="hljs-built_in">this</span>.originalEvaluationContext.setBeanResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryResolver</span>(<span class="hljs-built_in">this</span>.beanFactory));

    Map&lt;String, EventListenerFactory&gt; beans = beanFactory.getBeansOfType(EventListenerFactory.class, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
    List&lt;EventListenerFactory&gt; factories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(beans.values());
    AnnotationAwareOrderComparator.sort(factories);
    <span class="hljs-built_in">this</span>.eventListenerFactories = factories;
}
</code></pre>
<p>我们可以看到这个后置处理方法中，主要是对 <code>eventListenerFactories</code> 赋值，然后后续等所有单例 <code>Bean</code> 实例化完成后，会调用它的生命周期方法 <code>EventListenerMethodProcessor#afterSingletonsInstantiated()</code>，会用这个工厂创建事件监听器，添加到 <code>ApplicationContext</code> 中，<code>Spring 事件机制</code> 就是把所有事件监听器添加到 <code>ApplicationContext</code> 的 <code>applicationListeners</code> 字段中，调用 <code>ApplicationEventPublisher#publishEvent(ApplicationEvent)</code> 的时候从这里找到符合的监听器批量执行，相当于广播一个消息。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multicastEvent</span><span class="hljs-params">(ApplicationEvent event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> {
    <span class="hljs-type">ResolvableType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> (eventType != <span class="hljs-literal">null</span> ? eventType : ResolvableType.forInstance(event));
    <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getTaskExecutor();
    <span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) {
       <span class="hljs-keyword">if</span> (executor != <span class="hljs-literal">null</span> &amp;&amp; listener.supportsAsyncExecution()) {
          <span class="hljs-keyword">try</span> {
          <span class="hljs-comment">//异步事件</span>
             executor.execute(() -&gt; invokeListener(listener, event));
          }
          <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) {
             <span class="hljs-comment">// Probably on shutdown -&gt; invoke listener locally instead</span>
             invokeListener(listener, event);
          }
       }
       <span class="hljs-keyword">else</span> {
          invokeListener(listener, event);
       }
    }
}
</code></pre>
<h2 data-id="heading-18">MapperScannerConfigurer</h2>
<p>如果我们使用 <code>Mybatis</code> 框架的话，就会有这个工厂后置处理器</p>
<h3 data-id="heading-19">注册来源</h3>
<p>上面我们知道 <code>SpringBoot</code> 启动后会先执行 <code>ConfigurationClassPostProcessor</code> 加载自动配置类，于是加载到了 <code>MybatisPlusAutoConfiguration</code>，它有一个静态内部类</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration(proxyBeanMethods = <span class="hljs-literal">false</span>)
<span class="hljs-meta">@Import(AutoConfiguredMapperScannerRegistrar.class)</span>
<span class="hljs-meta">@ConditionalOnMissingBean({MapperFactoryBean.class, MapperScannerConfigurer.class})</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperScannerRegistrarNotFoundConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> {
        logger.debug(<span class="hljs-string">"Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."</span>);
    }
}
</code></pre>
<p>这里 <code>@Import</code> 导入了 <code>AutoConfiguredMapperScannerRegistrar</code> 类，再查看<code>AutoConfiguredMapperScannerRegistrar#registerBeanDefinitions</code> 注册方法中注册了 <code>MapperScannerConfigurer</code> 的 <code>BeanDefiniton</code> 。</p>
<h3 data-id="heading-20">作用</h3>
<p>我们查看 <code>MapperScannerConfigurer#postProcessBeanDefinitionRegistry</code>，源码很简单</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.processPropertyPlaceHolders) {
   <span class="hljs-comment">//解析属性值中的占位符</span>
    processPropertyPlaceHolders();
  }
  
  <span class="hljs-comment">//实例化 `ClassPathBeanDefinitionScanner` 的实现类扫描类路径下的 @Mapper 注解</span>
  <span class="hljs-type">ClassPathMapperScanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathMapperScanner</span>(registry);
  scanner.setAddToConfig(<span class="hljs-built_in">this</span>.addToConfig);
  scanner.setAnnotationClass(<span class="hljs-built_in">this</span>.annotationClass);
  scanner.setMarkerInterface(<span class="hljs-built_in">this</span>.markerInterface);
  scanner.setSqlSessionFactory(<span class="hljs-built_in">this</span>.sqlSessionFactory);
  scanner.setSqlSessionTemplate(<span class="hljs-built_in">this</span>.sqlSessionTemplate);
  scanner.setSqlSessionFactoryBeanName(<span class="hljs-built_in">this</span>.sqlSessionFactoryBeanName);
  scanner.setSqlSessionTemplateBeanName(<span class="hljs-built_in">this</span>.sqlSessionTemplateBeanName);
  scanner.setResourceLoader(<span class="hljs-built_in">this</span>.applicationContext);
  scanner.setBeanNameGenerator(<span class="hljs-built_in">this</span>.nameGenerator);
  scanner.setMapperFactoryBeanClass(<span class="hljs-built_in">this</span>.mapperFactoryBeanClass);
  <span class="hljs-keyword">if</span> (StringUtils.hasText(lazyInitialization)) {
    scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));
  }
  <span class="hljs-keyword">if</span> (StringUtils.hasText(defaultScope)) {
    scanner.setDefaultScope(defaultScope);
  }
  scanner.registerFilters();
  scanner.scan(
      StringUtils.tokenizeToStringArray(<span class="hljs-built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));
}
</code></pre>
<p>就是把类路径下的 <code>@Mapper</code> 注解的类扫描出来注册为 <code>BeanDefiniton</code> 。</p>
<h3 data-id="heading-21">自我扩展</h3>
<p>参考 <code>MapperScannerConfigurer</code> 假设我们后续需要自己制作一个组件，读取 <code>@Xxx</code> 标注的类注册为 <code>BeanDefiniton</code> 交给 <code>Spring</code> ，是不是就很简单了~</p>
<h2 data-id="heading-22">CachingMetadataReaderFactoryPostProcessor</h2>
<p>这个类是 <code>SpringBoot</code> 提供的一个重要的缓存元信息的工厂后置处理器，它是通过 <code>ApplicationContextInitializer</code> 添加到 <code>ApplicationContext</code> 中的</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedMetadataReaderFactoryContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextInitializer</span>&lt;ConfigurableApplicationContext&gt;, Ordered, BeanRegistrationExcludeFilter {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BEAN_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">"org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory"</span>;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> {
       <span class="hljs-keyword">if</span> (AotDetector.useGeneratedArtifacts()) {
          <span class="hljs-keyword">return</span>;
       }
       <span class="hljs-type">BeanFactoryPostProcessor</span> <span class="hljs-variable">postProcessor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingMetadataReaderFactoryPostProcessor</span>(applicationContext);
       applicationContext.addBeanFactoryPostProcessor(postProcessor);
    }
}
</code></pre>
<p>我们可以查看 <code>CachingMetadataReaderFactoryPostProcessor#postProcessBeanDefinitionRegistry</code> 后置处理方法源码，</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException {
    register(registry);
    configureConfigurationClassPostProcessor(registry);
}
</code></pre>
<p>先注册了一个 <code>SharedMetadataReaderFactoryBean</code> 的 <code>BeanDefiniton</code> ，实际上最后就是向容器中注入 <code>ConcurrentReferenceCachingMetadataReaderFactory</code>，然后第二行代码很关键，给 <code>ConfigurationClassPostProcessor</code> 这个工厂后置处理器的属性 <code>metadataReaderFactory</code> 赋值为刚刚创建的 <code>ConcurrentReferenceCachingMetadataReaderFactory</code></p>
<p>我们再去看原生的 <code>ConfigurationClassPostProcessor.metadataReaderFactory</code> 默认值</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">private</span> <span class="hljs-type">MetadataReaderFactory</span> <span class="hljs-variable">metadataReaderFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachingMetadataReaderFactory</span>();
</code></pre>
<p>在判断一个类是不是配置类的时候会用到它，默认的实现是每次都会用资源加载器读取一遍这个类，</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> MetadataReader <span class="hljs-title function_">getMetadataReader</span><span class="hljs-params">(String className)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-keyword">try</span> {
       <span class="hljs-type">String</span> <span class="hljs-variable">resourcePath</span> <span class="hljs-operator">=</span> ResourceLoader.CLASSPATH_URL_PREFIX + ClassUtils.convertClassNameToResourcePath(className) + ClassUtils.CLASS_FILE_SUFFIX;
       <span class="hljs-comment">//重新读取文件</span>
       <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resourceLoader.getResource(resourcePath);
       <span class="hljs-keyword">return</span> getMetadataReader(resource);
    }
}
</code></pre>
<p>而 <code>ConcurrentReferenceCachingMetadataReaderFactory</code> 的实现是，第一次读取之后放入缓存，后续每次获取会先从缓存中查询</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> MetadataReader <span class="hljs-title function_">getMetadataReader</span><span class="hljs-params">(String className)</span> <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-comment">//读取缓存</span>
    <span class="hljs-type">MetadataReader</span> <span class="hljs-variable">metadataReader</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.classNameCache.get(className);
    <span class="hljs-keyword">if</span> (metadataReader == <span class="hljs-literal">null</span>) {
       metadataReader = <span class="hljs-built_in">super</span>.getMetadataReader(className);
       <span class="hljs-built_in">this</span>.classNameCache.put(className, metadataReader);
    }
    <span class="hljs-keyword">return</span> metadataReader;
}
</code></pre>
<p>它的作用就是提高程序性能，避免重复读取类的元数据信息</p>
<h2 data-id="heading-23">BeanFactoryPostProcessor 与 BeanPostProcessor 对比</h2>
<p>这两个名字很像，这里列出它们的区别，下一篇文章会详细介绍 <code>BeanPostProcessor</code></p>


















































<table><thead><tr><th align="left">对比维度</th><th align="left">BeanFactoryPostProcessor</th><th align="left">BeanPostProcessor</th></tr></thead><tbody><tr><td align="left"><strong>处理时机</strong></td><td align="left">Bean 定义加载之后，Bean 实例化之前</td><td align="left">Bean 实例化之后，初始化回调前后</td></tr><tr><td align="left"><strong>作用对象</strong></td><td align="left">Bean 的定义元数据（BeanDefinition）</td><td align="left">Bean 实例对象</td></tr><tr><td align="left"><strong>主要功能</strong></td><td align="left">修改、注册或移除 BeanDefinition</td><td align="left">修改或包装 Bean 实例</td></tr><tr><td align="left"><strong>执行阶段</strong></td><td align="left"><code>postProcessBeanFactory()</code></td><td align="left"><code>postProcessBeforeInitialization()</code><br/><code>postProcessAfterInitialization()</code></td></tr><tr><td align="left"><strong>触发次数</strong></td><td align="left">每个容器<strong>仅执行一次</strong></td><td align="left">对<strong>每个 Bean 实例</strong>都会执行</td></tr><tr><td align="left"><strong>Spring 核心阶段</strong></td><td align="left">BeanFactory 准备阶段</td><td align="left">Bean 生命周期阶段</td></tr><tr><td align="left"><strong>典型应用场景</strong></td><td align="left">1. 修改 Bean 的属性值（占位符解析）<br/>2. 动态注册 BeanDefinition<br/>3. 根据条件移除 Bean</td><td align="left">1. 代理增强（AOP）<br/>2. 属性注入后的处理<br/>3. 自定义初始化逻辑</td></tr><tr><td align="left"><strong>实现示例</strong></td><td align="left"><code>PropertySourcesPlaceholderConfigurer</code><br/><code>ConfigurationClassPostProcessor</code></td><td align="left"><code>AutowiredAnnotationBeanPostProcessor</code><br/><code>CommonAnnotationBeanPostProcessor</code></td></tr></tbody></table>
<h2 data-id="heading-24">结语</h2>
<p>篇幅原因，这里无法列出所有的工厂后置处理器的具体作用和实现，不过 <code>SpringBoot</code> 启动过程中，<code>Spring</code> 容器刷新过程中调用的 <code>BeanFactoryPostProcessor</code> 相对于 <code>BeanPostProcessor</code> 要少的多，但是两者都很重要，有兴趣可以逐一查看源码。</p>
<h3 data-id="heading-25">如果这篇文章对你有帮助，记得点赞加关注！你的支持就是我继续创作的动力！</h3></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Web 安全与反编译源码下的权限设计：构筑前后端一致的防护体系]]></title>    <link>https://juejin.cn/post/7603651855236857865</link>    <guid>https://juejin.cn/post/7603651855236857865</guid>    <pubDate>2026-02-08T06:32:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603651855236857865" data-draft-id="7603674653153771529" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Web 安全与反编译源码下的权限设计：构筑前后端一致的防护体系"/> <meta itemprop="keywords" content="前端,安全"/> <meta itemprop="datePublished" content="2026-02-08T06:32:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LeonGao"/> <meta itemprop="url" content="https://juejin.cn/user/3976252950591149"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Web 安全与反编译源码下的权限设计：构筑前后端一致的防护体系
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3976252950591149/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LeonGao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:32:33.000Z" title="Sun Feb 08 2026 06:32:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-light">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h2 data-id="heading-0">引言</h2>
<p>在 Web 应用的安全体系中，<strong>权限控制</strong> 是最核心的防线之一。无论是企业后台、数据门户还是 SaaS 平台，一旦权限设计出现漏洞，就可能导致数据泄漏、越权操作甚至后门利用。</p>
<p>然而，许多开发者只在前端配置权限逻辑，忽略了 <strong>反编译与前端源码暴露的安全风险</strong>。通过 F12 调试、打包反编译或网络抓包等手段，攻击者可以轻易绕过前端判断直接访问后端接口。</p>
<blockquote>
<p><strong>问题：</strong> 如何在「源码可见」「反编译可行」的环境下，设计一套真正安全且可扩展的权限体系？</p>
</blockquote>
<p>本文将从 <strong>Web 安全视角</strong> 分析权限设计的底层风险，讲解 <strong>从前端到后端的统一权限防护策略</strong>，并通过示例代码展示如何有效抵御反编译带来的安全威胁。</p>
<hr/>
<h2 data-id="heading-1">一、问题定义与背景</h2>
<h3 data-id="heading-2">1. 前端可逆向的现实</h3>
<p>现代 Web 前端（如 React、Vue、Angular）使用 <strong>打包编译</strong> 与 <strong>代码混淆</strong> 技术，但本质上仍是 <strong>运行在用户端的可执行脚本</strong>。攻击者可通过：</p>
<ul>
<li>浏览器开发者工具查看源码（即使混淆）；</li>
<li>抓包工具（如 Burp、Postman）直接模拟请求；</li>
<li>反编译 WebAssembly / 前端加密逻辑；</li>
<li>修改本地存储信息（token、role、flag）。</li>
</ul>
<p>这意味着 <strong>任何前端层的权限校验都是不可信的</strong>。</p>
<h3 data-id="heading-3">2. 常见错误示例</h3>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// ❌ 前端中错误的“权限控制”</span>
if (userRole === 'admin') {
  <span class="hljs-built_in">showAdminPanel</span>();
} else {
  <span class="hljs-built_in">hideAdminPanel</span>();
}
</code></pre>
<p>攻击者只需在浏览器控制台输入：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">userRole</span> = <span class="hljs-string">'admin'</span><span class="hljs-comment">; showAdminPanel();</span>
</code></pre>
<p>即可伪装为管理员。</p>
<hr/>
<h2 data-id="heading-4">二、解决方案与技术设计</h2>
<h3 data-id="heading-5">🔒 权限控制的本质：可信判定必须在服务端</h3>
<p>安全设计原则：</p>
<blockquote>
<p><strong>任何安全相关的判断都应在服务端完成，前端仅作展示或引导。</strong></p>
</blockquote>
<h3 data-id="heading-6">1. 后端统一鉴权与授权</h3>
<p>后端需要构建一套集中式的 <strong>鉴权（Authentication）</strong> 与 <strong>授权（Authorization）</strong> 模型：</p>
<ul>
<li><strong>鉴权：</strong> 当前请求是谁？（JWT / Session / OAuth2）</li>
<li><strong>授权：</strong> 当前用户能做什么？（RBAC / ABAC / PBAC）</li>
</ul>
<p><strong>示例：基于 RBAC 的 Spring Boot 后端实现</strong></p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// RoleBasedAccess.java（自定义注解）</span>
<span class="hljs-variable">@Target</span>(ElementType.METHOD)
<span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)
public <span class="hljs-variable">@interface</span> RoleBasedAccess {
    <span class="hljs-selector-tag">String</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">value</span>();
}
</code></pre>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// SecurityInterceptor.java</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecurityInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, Object handler)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> req.getHeader(<span class="hljs-string">"Authorization"</span>);
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> TokenUtils.verify(token);
        <span class="hljs-type">RoleBasedAccess</span> <span class="hljs-variable">access</span> <span class="hljs-operator">=</span> ((HandlerMethod) handler).getMethodAnnotation(RoleBasedAccess.class);
        <span class="hljs-keyword">if</span> (access != <span class="hljs-literal">null</span> &amp;&amp; !user.hasAnyRole(access.value())) {
            res.setStatus(HttpServletResponse.SC_FORBIDDEN);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 控制器示例</span>
<span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"/admin/list"</span>)
<span class="hljs-variable">@RoleBasedAccess</span>({<span class="hljs-string">"ADMIN"</span>})
public ResponseEntity&lt;?&gt; <span class="hljs-built_in">listAdmins</span>() {
    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResponseEntity</span><span class="hljs-selector-class">.ok</span>(adminService.<span class="hljs-built_in">findAll</span>());
}
</code></pre>
<blockquote>
<p>✅ 即使攻击者篡改前端变量或修改 UI，仍无法访问未经授权的接口。</p>
</blockquote>
<hr/>
<h3 data-id="heading-7">2. 前端仅作“权限可视化”，非“权限控制”</h3>
<p>前端可以按服务器返回的权限标识动态渲染按钮、菜单，但<strong>不能</strong>依赖这些字段做业务安全判断。</p>
<p><strong>前端示例（Vue + Axios）</strong></p>
<pre><code class="hljs language-ini" lang="ini">// app.js
axios.interceptors.request.use(<span class="hljs-attr">config</span> =&gt; {
  const <span class="hljs-attr">token</span> = localStorage.getItem(<span class="hljs-string">'token'</span>)<span class="hljs-comment">;</span>
  <span class="hljs-attr">config.headers.Authorization</span> = token<span class="hljs-comment">;</span>
  return config<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>

// 动态菜单渲染
const <span class="hljs-attr">user</span> = getUserInfo()<span class="hljs-comment">; // 后端返回的角色信息</span>
const <span class="hljs-attr">routes</span> = allRoutes.filter(route =&gt; user.roles.includes(route.meta.role))<span class="hljs-comment">;</span>
</code></pre>
<ul>
<li>菜单与按钮的展示只影响“视觉体验”；</li>
<li>实际的访问结果由后端决定（即使前端按钮被伪造也无效）。</li>
</ul>
<hr/>
<h3 data-id="heading-8">3. 防反编译与数据暴露的加固措施</h3>



































<table><thead><tr><th>威胁类型</th><th>防护策略</th><th>技术点</th></tr></thead><tbody><tr><td>源码反编译</td><td>构建时混淆与 Tree Shaking</td><td>Webpack <code>terser</code> / <code>esbuild</code></td></tr><tr><td>关键逻辑逆向</td><td>将核心算法迁移至后端或 WebAssembly</td><td>例如签名、密钥生成</td></tr><tr><td>API 被直接调用</td><td>使用 Token + HMAC 签名 + 限流</td><td>JWT + Redis + Nginx</td></tr><tr><td>调试注入</td><td>CSP（Content Security Policy）限制 JS 执行环境</td><td>HTTP 安全头</td></tr><tr><td>数据泄漏</td><td>后端白名单过滤、敏感字段脱敏</td><td>DTO 防止 DB 字段透传</td></tr></tbody></table>
<p>例如，通过 <strong>请求签名机制（HMAC）</strong> 阻止伪造请求：</p>
<pre><code class="hljs language-ini" lang="ini">// 前端发起请求前生成签名（所有参数 + 时间戳）
import crypto from "crypto"<span class="hljs-comment">;</span>

const <span class="hljs-attr">secret</span> = <span class="hljs-string">"server-shared-key"</span><span class="hljs-comment">;</span>
const <span class="hljs-attr">timestamp</span> = Date.now().toString()<span class="hljs-comment">;</span>
const <span class="hljs-attr">sign</span> = crypto.createHmac(<span class="hljs-string">'sha256'</span>, secret)
                   .update(userId + timestamp)
                   .digest('hex')<span class="hljs-comment">;</span>

axios.post('/api/secure', { data, timestamp, sign })<span class="hljs-comment">;</span>
</code></pre>
<p>后端验证签名合法性：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># Flask 示例</span>
<span class="hljs-keyword">import</span> hmac, hashlib

<span class="hljs-keyword">def</span> <span class="hljs-title function_">verify_sign</span>(<span class="hljs-params">userId, ts, sign</span>):
    secret = <span class="hljs-string">"server-shared-key"</span>
    expected = hmac.new(secret.encode(), <span class="hljs-string">f"<span class="hljs-subst">{userId}</span><span class="hljs-subst">{ts}</span>"</span>.encode(), hashlib.sha256).hexdigest()
    <span class="hljs-keyword">return</span> hmac.compare_digest(expected, sign)
</code></pre>
<hr/>
<h2 data-id="heading-9">三、优缺点分析与实践建议</h2>





























<table><thead><tr><th>模型</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>前端权限（展示级）</td><td>响应快、易实现</td><td>简单易被绕过</td><td>UI控制、低安全页面</td></tr><tr><td>后端权限（验证级）</td><td>安全可靠、可审计</td><td>开发略复杂</td><td>所有敏感接口必须</td></tr><tr><td>混合策略</td><td>安全+体验平衡</td><td>需前后端版本统一</td><td>企业后台中大型系统</td></tr></tbody></table>
<p><strong>实践建议：</strong></p>
<ol>
<li><strong>前端负责体验</strong>，但不要承担安全职责；</li>
<li><strong>后端负责权限核心</strong>，所有请求均二次校验；</li>
<li>对<strong>静态资源与接口</strong>同时限流、校验、审计；</li>
<li>每个权限点应<strong>有日志可追溯、有策略可管理</strong>。</li>
</ol>
<hr/>
<h2 data-id="heading-10">四、结论</h2>
<p>在反编译与源码暴露成为常态的 Web 环境中，<strong>前端安全只是幻觉，后端的权限才是真相</strong>。</p>
<p>高质量的权限设计，不是让前端更“聪明”，而是让后端更“可信”；不是靠混淆隐藏逻辑，而是靠架构建立信任边界。</p>
<p>未来，随着 <strong>零信任架构（Zero Trust）</strong> 与 <strong>前后端一体化加密通信</strong> 的普及，<br/>
权限设计将更智能、更去中心化，基于 <strong>身份、上下文与行为检测</strong> 的动态授权机制将逐渐取代传统 RBAC。</p>
<hr/>
<h2 data-id="heading-11">五、参考资料</h2>
<ol>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fowasp.org%2FTop10%2FA01_2021-Broken_Access_Control%2F" target="_blank" title="https://owasp.org/Top10/A01_2021-Broken_Access_Control/" ref="nofollow noopener noreferrer">OWASP Top 10 2021 – A01: Broken Access Control</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fspring.io%2Fprojects%2Fspring-security" target="_blank" title="https://spring.io/projects/spring-security" ref="nofollow noopener noreferrer">Spring Security 官方文档</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCSP" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" ref="nofollow noopener noreferrer">MDN – Content Security Policy (CSP) 指南</a></li>
<li>[JWT.io – JSON Web Token 官方标准]</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fcheatsheetseries.owasp.org%2Fcheatsheets%2FAuthorization_Cheat_Sheet.html" target="_blank" title="https://cheatsheetseries.owasp.org/cheatsheets/Authorization_Cheat_Sheet.html" ref="nofollow noopener noreferrer">OWASP – Authorization Cheat Sheet</a></li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Unsafe魔法类深度解析：Java底层操作的终极指南]]></title>    <link>https://juejin.cn/post/7603688142004699145</link>    <guid>https://juejin.cn/post/7603688142004699145</guid>    <pubDate>2026-02-08T06:33:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603688142004699145" data-draft-id="7603721514203283465" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Unsafe魔法类深度解析：Java底层操作的终极指南"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T06:33:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="神奇小汤圆"/> <meta itemprop="url" content="https://juejin.cn/user/1151943919285431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Unsafe魔法类深度解析：Java底层操作的终极指南
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1151943919285431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    神奇小汤圆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:33:22.000Z" title="Sun Feb 08 2026 06:33:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">介绍</h2>
<p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。</p>
<p>这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p>
<p>先来看下这张图，对UnSafe类总体功能：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202404251040445.jpg" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404251040445.jpg" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/af56ce01300f4528b2404ef5e07612fc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=FbCKApmBIzjz3cacmsUy8EKKseY%3D" alt="" loading="lazy"/></a></p>
<p>如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。</p>
<h2 data-id="heading-1">内存操作</h2>
<h3 data-id="heading-2">介绍</h3>
<p>如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 <code>Unsafe</code> 中，提供的下列接口可以直接进行内存操作：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//分配新的本地空间</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">allocateMemory</span><span class="hljs-params">(<span class="hljs-type">long</span> bytes)</span>;
<span class="hljs-comment">//重新调整内存空间的大小</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">reallocateMemory</span><span class="hljs-params">(<span class="hljs-type">long</span> address, <span class="hljs-type">long</span> bytes)</span>;
<span class="hljs-comment">//将内存设置为指定值</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMemory</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> bytes, <span class="hljs-type">byte</span> value)</span>;
<span class="hljs-comment">//内存拷贝</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyMemory</span><span class="hljs-params">(Object srcBase, <span class="hljs-type">long</span> srcOffset,Object destBase, <span class="hljs-type">long</span> destOffset,<span class="hljs-type">long</span> bytes)</span>;
<span class="hljs-comment">//清除内存</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">freeMemory</span><span class="hljs-params">(<span class="hljs-type">long</span> address)</span>;
</code></pre>
<p>使用下面的代码进行测试：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">memoryTest</span>()</span> {
    <span class="hljs-built_in">int</span> size = <span class="hljs-number">4</span>;
    <span class="hljs-built_in">long</span> addr = <span class="hljs-keyword">unsafe</span>.allocateMemory(size);
    <span class="hljs-built_in">long</span> addr3 = <span class="hljs-keyword">unsafe</span>.reallocateMemory(addr, size * <span class="hljs-number">2</span>);
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"addr: "</span>+addr);
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"addr3: "</span>+addr3);
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">unsafe</span>.setMemory(<span class="hljs-literal">null</span>,addr ,size,(<span class="hljs-built_in">byte</span>)<span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) {
            <span class="hljs-keyword">unsafe</span>.copyMemory(<span class="hljs-literal">null</span>,addr,<span class="hljs-literal">null</span>,addr3+size*i,<span class="hljs-number">4</span>);
        }
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">unsafe</span>.getInt(addr));
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">unsafe</span>.getLong(addr3));
    }<span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">unsafe</span>.freeMemory(addr);
        <span class="hljs-keyword">unsafe</span>.freeMemory(addr3);
    }
}
</code></pre>
<p>先看结果输出：</p>
<p>plain</p>
<pre><code class="hljs language-makefile" lang="makefile"><span class="hljs-section">addr: 2433733895744</span>
<span class="hljs-section">addr3: 2433733894944</span>
16843009
72340172838076673
</code></pre>
<p>分析一下运行结果，首先使用<code>allocateMemory</code>方法申请 4 字节长度的内存空间，调用<code>setMemory</code>方法向每个字节写入内容为<code>byte</code>类型的 1，当使用 Unsafe 调用<code>getInt</code>方法时，因为一个<code>int</code>型变量占 4 个字节，会一次性读取 4 个字节，组成一个<code>int</code>的值，对应的十进制结果为 16843009。</p>
<p>你可以通过下图理解这个过程：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130396.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130396.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/60e61edb820240908dfef29cdca85ae7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=McQsQTlSzXk3eVY8DvAFFeWA0zo%3D" alt="" loading="lazy"/></a></p>
<p>在代码中调用<code>reallocateMemory</code>方法重新分配了一块 8 字节长度的内存空间，通过比较<code>addr</code>和<code>addr3</code>可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用<code>copyMemory</code>方法进行了两次内存的拷贝，每次拷贝内存地址<code>addr</code>开始的 4 个字节，分别拷贝到以<code>addr3</code>和<code>addr3+4</code>开始的内存空间上：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130404.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130404.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bf0021cd157244e8bc4857c7ee307703~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=cIfVZVovO11KHNXFn8iyfbYKmbU%3D" alt="" loading="lazy"/></a></p>
<p>拷贝完成后，使用<code>getLong</code>方法一次性读取 8 个字节，得到<code>long</code>类型的值为 72340172838076673。</p>
<p>需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用<code>freeMemory</code>方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在<code>try</code>中执行对内存的操作，最终在<code>finally</code>块中进行内存的释放。</p>
<p><strong>为什么要使用堆外内存？</strong></p>
<ul>
<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li>
<li>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>
</ul>
<h3 data-id="heading-3">典型应用</h3>
<p><code>DirectByteBuffer</code> 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。<code>DirectByteBuffer</code> 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。</p>
<p>下图为 <code>DirectByteBuffer</code> 构造函数，创建 <code>DirectByteBuffer</code> 的时候，通过 <code>Unsafe.allocateMemory</code> 分配内存、<code>Unsafe.setMemory</code> 进行内存初始化，而后构建 <code>Cleaner</code> 对象用于跟踪 <code>DirectByteBuffer</code> 对象的垃圾回收，以实现当 <code>DirectByteBuffer</code> 被垃圾回收时，分配的堆外内存一起被释放。</p>
<p>java</p>
<pre><code class="hljs language-ini" lang="ini">DirectByteBuffer(int cap) {                   // package-private

    super(-1, 0, cap, cap)<span class="hljs-comment">;</span>
    boolean <span class="hljs-attr">pa</span> = VM.isDirectMemoryPageAligned()<span class="hljs-comment">;</span>
    int <span class="hljs-attr">ps</span> = Bits.pageSize()<span class="hljs-comment">;</span>
    long <span class="hljs-attr">size</span> = Math.max(<span class="hljs-number">1</span>L, (long)cap + (pa ? ps : <span class="hljs-number">0</span>))<span class="hljs-comment">;</span>
    Bits.reserveMemory(size, cap)<span class="hljs-comment">;</span>

    long <span class="hljs-attr">base</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    try {
        // 分配内存并返回基地址
        <span class="hljs-attr">base</span> = unsafe.allocateMemory(size)<span class="hljs-comment">;</span>
    } catch (OutOfMemoryError x) {
        Bits.unreserveMemory(size, cap)<span class="hljs-comment">;</span>
        throw x<span class="hljs-comment">;</span>
    }
    // 内存初始化
    unsafe.setMemory(base, size, (byte) 0)<span class="hljs-comment">;</span>
    if (pa &amp;&amp; (base % ps != 0)) {
        // Round up to page boundary
        <span class="hljs-attr">address</span> = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>))<span class="hljs-comment">;</span>
    } else {
        <span class="hljs-attr">address</span> = base<span class="hljs-comment">;</span>
    }
    // 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放
    <span class="hljs-attr">cleaner</span> = Cleaner.create(this, new Deallocator(base, size, cap))<span class="hljs-comment">;</span>
    <span class="hljs-attr">att</span> = null<span class="hljs-comment">;</span>
}
</code></pre>
<h2 data-id="heading-4">内存屏障</h2>
<h3 data-id="heading-5">介绍</h3>
<p>在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（<code>Memory Barrier</code>）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。</p>
<p>在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。</p>
<p><code>Unsafe</code> 中提供了下面三个内存屏障相关方法：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> native <span class="hljs-keyword">void</span> <span class="hljs-title">loadFence</span>()</span>;
<span class="hljs-comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> native <span class="hljs-keyword">void</span> <span class="hljs-title">storeFence</span>()</span>;
<span class="hljs-comment">//内存屏障，禁止load、store操作重排序</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> native <span class="hljs-keyword">void</span> <span class="hljs-title">fullFence</span>()</span>;
</code></pre>
<p>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以<code>loadFence</code>方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。</p>
<p>看到这估计很多小伙伴们会想到<code>volatile</code>关键字了，如果在字段上添加了<code>volatile</code>关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改<code>flag</code>标志位，注意这里的<code>flag</code>是没有被<code>volatile</code>修饰的：</p>
<p>java</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Getter</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>{
    <span class="hljs-comment">/**volatile**/</span> <span class="hljs-built_in">boolean</span> flag=<span class="hljs-literal">false</span>;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">3000</span>);
        } <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) {
            e.<span class="hljs-title function_">printStackTrace</span>();
        }
        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"subThread change flag to:"</span> + flag);
        flag = <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<p>在主线程的<code>while</code>循环中，加入内存屏障，测试是否能够感知到<code>flag</code>的修改变化：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>{
    ChangeThread changeThread = <span class="hljs-keyword">new</span> ChangeThread();
    <span class="hljs-keyword">new</span> Thread(changeThread).start();
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        boolean flag = changeThread.isFlag();
        <span class="hljs-keyword">unsafe</span>.loadFence(); <span class="hljs-comment">//加入读内存屏障</span>
        <span class="hljs-keyword">if</span> (flag){
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"detected flag changed"</span>);
            <span class="hljs-keyword">break</span>;
        }
    }
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"main thread end"</span>);
}
</code></pre>
<p>运行结果：</p>
<p>plain</p>
<pre><code class="hljs language-arduino" lang="arduino">subThread change flag to:<span class="hljs-literal">false</span>
detected flag changed
main thread end
</code></pre>
<p>而如果删掉上面代码中的<code>loadFence</code>方法，那么主线程将无法感知到<code>flag</code>发生的变化，会一直在<code>while</code>中循环。可以用图来表示上面的过程：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fp0-xtjj-private.juejin.cn%2Ftos-cn-i-73owjymdk6%2Ff320a294eacd4789a072b1f71e541406~tplv-73owjymdk6-jj-mark-v1%3A0%3A0%3A0%3A0%3A5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG%3Aq75.awebp%3Fpolicy%3DeyJ2bSI6MywidWlkIjoiMTE1MTk0MzkxOTI4NTQzMSJ9%26rk3s%3De9ecf3d6%26x-orig-authkey%3Df32326d3454f2ac7e96d3d06cdbb035152127018%26x-orig-expires%3D1770618790%26x-orig-sign%3DdYNDmbPY7ht9OLvDS82flYbnOis%253D" target="_blank" title="https://p0-xtjj-private.juejin.cn/tos-cn-i-73owjymdk6/f320a294eacd4789a072b1f71e541406~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?policy=eyJ2bSI6MywidWlkIjoiMTE1MTk0MzkxOTI4NTQzMSJ9&amp;rk3s=e9ecf3d6&amp;x-orig-authkey=f32326d3454f2ac7e96d3d06cdbb035152127018&amp;x-orig-expires=1770618790&amp;x-orig-sign=dYNDmbPY7ht9OLvDS82flYbnOis%3D" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fba0241f9bb84ff29959034d18ae368e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=nxiCNFJoxs6yyGp8MgE%2FB66dFiA%3D" alt="" loading="lazy"/></a></p>
<p>了解 Java 内存模型（<code>JMM</code>）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。</p>
<h3 data-id="heading-6">典型应用</h3>
<p>在 Java 8 中引入了一种锁的新机制——<code>StampedLock</code>，它可以看成是读写锁的一个改进版本。<code>StampedLock</code> 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 <code>StampedLock</code> 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。</p>
<p>为了解决这个问题，<code>StampedLock</code> 的 <code>validate</code> 方法会通过 <code>Unsafe</code> 的 <code>loadFence</code> 方法加入一个 <code>load</code> 内存屏障。</p>
<p>java</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">validate</span><span class="hljs-params">(<span class="hljs-type">long</span> stamp)</span> </span>{
   U.<span class="hljs-built_in">loadFence</span>();
   <span class="hljs-keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);
}
</code></pre>
<h2 data-id="heading-7">对象操作</h2>
<h3 data-id="heading-8">介绍</h3>
<p><strong>例子</strong></p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp">import sun.misc.Unsafe;
import java.lang.reflect.Field;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws Exception</span>{
        Unsafe <span class="hljs-keyword">unsafe</span> = reflectGetUnsafe();
        assert <span class="hljs-keyword">unsafe</span> != <span class="hljs-literal">null</span>;
        <span class="hljs-built_in">long</span> offset = <span class="hljs-keyword">unsafe</span>.objectFieldOffset(Main.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">"value"</span>));
        Main main = <span class="hljs-keyword">new</span> Main();
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"value before putInt: "</span> + main.<span class="hljs-keyword">value</span>);
        <span class="hljs-keyword">unsafe</span>.putInt(main, offset, <span class="hljs-number">42</span>);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"value after putInt: "</span> + main.<span class="hljs-keyword">value</span>);
  System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"value after putInt: "</span> + <span class="hljs-keyword">unsafe</span>.getInt(main, offset));
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">reflectGetUnsafe</span>()</span> {
        <span class="hljs-keyword">try</span> {
            Field field = Unsafe.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">"theUnsafe"</span>);
            field.setAccessible(<span class="hljs-literal">true</span>);
            <span class="hljs-keyword">return</span> (Unsafe) field.<span class="hljs-keyword">get</span>(<span class="hljs-literal">null</span>);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            e.printStackTrace();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }

}
</code></pre>
<p>输出结果：</p>
<p>plain</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">value before putInt:</span> <span class="hljs-number">0</span>
<span class="hljs-attr">value after putInt:</span> <span class="hljs-number">42</span>
<span class="hljs-attr">value after putInt:</span> <span class="hljs-number">42</span>
</code></pre>
<p><strong>对象属性</strong></p>
<p>对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的<code>putInt</code>、<code>getInt</code>方法外，Unsafe 提供了全部 8 种基础数据类型以及<code>Object</code>的<code>put</code>和<code>get</code>方法，并且所有的<code>put</code>方法都可以越过访问权限，直接修改内存中的数据。阅读 openJDK 源码中的注释发现，基础数据类型和<code>Object</code>的读写稍有不同，基础数据类型是直接操作的属性值（<code>value</code>），而<code>Object</code>的操作则是基于引用值（<code>reference value</code>）。下面是<code>Object</code>的读写方法：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//在对象的指定偏移地址获取一个对象引用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset)</span>;
<span class="hljs-comment">//在对象指定偏移地址写入一个对象引用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object x)</span>;
</code></pre>
<p>除了对象属性的普通读写外，<code>Unsafe</code> 还提供了 <strong>volatile 读写</strong>和<strong>有序写入</strong>方法。<code>volatile</code>读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和<code>Object</code>类型，以<code>int</code>类型为例：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//在对象的指定偏移地址处读取一个int值，支持volatile load语义</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIntVolatile</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset)</span>;
<span class="hljs-comment">//在对象指定偏移地址处写入一个int，支持volatile store语义</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putIntVolatile</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> x)</span>;
</code></pre>
<p>相对于普通读写来说，<code>volatile</code>读写具有更高的成本，因为它需要保证可见性和有序性。在执行<code>get</code>操作时，会强制从主存中获取属性值，在使用<code>put</code>方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。</p>
<p>有序写入的方法有以下三个：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putOrderedObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, Object x)</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putOrderedInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> x)</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putOrderedLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> x)</span>;
</code></pre>
<p>有序写入的成本相对<code>volatile</code>较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念：</p>
<ul>
<li><code>Load</code>：将主内存中的数据拷贝到处理器的缓存中</li>
<li><code>Store</code>：将处理器缓存的数据刷新到主内存中</li>
</ul>
<p>顺序写入与<code>volatile</code>写入的差别在于，在顺序写时加入的内存屏障类型为<code>StoreStore</code>类型，而在<code>volatile</code>写入时加入的内存屏障是<code>StoreLoad</code>类型，如下图所示：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130467.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130467.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3ffdc3b0cb1944029747a07cca8f7381~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=pAvU2CZVAAqKxOeTX9A%2FCZ5aJB8%3D" alt="" loading="lazy"/></a></p>
<p>在有序写入方法中，使用的是<code>StoreStore</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Store2</code>以及后续的存储指令操作。而在<code>volatile</code>写入中，使用的是<code>StoreLoad</code>屏障，该屏障确保<code>Store1</code>立刻刷新数据到内存，这一操作先于<code>Load2</code>及后续的装载指令，并且，<code>StoreLoad</code>屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。</p>
<p>综上所述，在上面的三类写入方法中，在写入效率方面，按照<code>put</code>、<code>putOrder</code>、<code>putVolatile</code>的顺序效率逐渐降低。</p>
<p><strong>对象实例化</strong></p>
<p>使用 <code>Unsafe</code> 的 <code>allocateInstance</code> 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp">@Data
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> b;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span>()</span>{
        <span class="hljs-keyword">this</span>.b =<span class="hljs-number">1</span>;
    }
}
</code></pre>
<p>分别基于构造函数、反射以及 <code>Unsafe</code> 方法的不同方式创建对象进行比较：</p>
<p>java</p>
<pre><code class="hljs language-ini" lang="ini">public void objTest() throws Exception{
    A <span class="hljs-attr">a1</span>=new A()<span class="hljs-comment">;</span>
    System.out.println(a1.getB())<span class="hljs-comment">;</span>
    A <span class="hljs-attr">a2</span> = A.class.newInstance()<span class="hljs-comment">;</span>
    System.out.println(a2.getB())<span class="hljs-comment">;</span>
    A <span class="hljs-attr">a3</span>= (A) unsafe.allocateInstance(A.class)<span class="hljs-comment">;</span>
    System.out.println(a3.getB())<span class="hljs-comment">;</span>
}
</code></pre>
<p>打印结果分别为 1、1、0，说明通过<code>allocateInstance</code>方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了<code>Class</code>对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为<code>private</code>类型，将无法通过构造函数和反射创建对象（可以通过构造函数对象 setAccessible 后创建对象），但<code>allocateInstance</code>方法仍然有效。</p>
<h3 data-id="heading-9">典型应用</h3>
<ul>
<li><strong>常规对象实例化方式</strong>：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li>
<li><strong>非常规的实例化方式</strong>：而 Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li>
</ul>
<h2 data-id="heading-10">数组操作</h2>
<h3 data-id="heading-11">介绍</h3>
<p><code>arrayBaseOffset</code> 与 <code>arrayIndexScale</code> 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//返回数组中第一个元素的偏移地址</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">arrayBaseOffset</span><span class="hljs-params">(Class&lt;?&gt; arrayClass)</span>;
<span class="hljs-comment">//返回数组中一个元素占用的大小</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">arrayIndexScale</span><span class="hljs-params">(Class&lt;?&gt; arrayClass)</span>;
</code></pre>
<h3 data-id="heading-12">典型应用</h3>
<p>这两个与数据操作相关的方法，在 <code>java.util.concurrent.atomic</code> 包下的 <code>AtomicIntegerArray</code>（可以实现对 <code>Integer</code> 数组中每个元素的原子性操作）中有典型的应用，如下图 <code>AtomicIntegerArray</code> 源码所示，通过 <code>Unsafe</code> 的 <code>arrayBaseOffset</code>、<code>arrayIndexScale</code> 分别获取数组首元素的偏移地址 <code>base</code> 及单个元素大小因子 <code>scale</code> 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 <code>getAndAdd</code> 方法即通过 <code>checkedByteOffset</code> 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130522.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130522.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e11d8699d0e348dab3f81b341301441c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=wEVeqZomJ856PftogdC%2FATMiFJw%3D" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-13">CAS 操作</h2>
<h3 data-id="heading-14">介绍</h3>
<p>这部分主要为 CAS 相关操作的方法。</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">/**
  *  CAS
  * <span class="hljs-doctag">@param</span> o         包含要修改field的对象
  * <span class="hljs-doctag">@param</span> offset    对象中某field的偏移量
  * <span class="hljs-doctag">@param</span> expected  期望值
  * <span class="hljs-doctag">@param</span> update    更新值
  * <span class="hljs-doctag">@return</span>          true | false
  */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,  Object expected, Object update)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> expected,<span class="hljs-type">int</span> update)</span>;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapLong</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">long</span> expected, <span class="hljs-type">long</span> update)</span>;
</code></pre>
<p><strong>什么是 CAS?</strong>  CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS 方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令 <code>cmpxchg</code> 。</p>
<h3 data-id="heading-15">典型应用</h3>
<p>在 JUC 包的并发工具类中大量地使用了 CAS 操作，像在前面介绍<code>synchronized</code>和<code>AQS</code>的文章中也多次提到了 CAS，其作为乐观锁在并发工具类中广泛发挥了作用。在 <code>Unsafe</code> 类中，提供了<code>compareAndSwapObject</code>、<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code>方法来实现的对<code>Object</code>、<code>int</code>、<code>long</code>类型的 CAS 操作。以<code>compareAndSwapInt</code>方法为例：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset,<span class="hljs-type">int</span> expected,<span class="hljs-type">int</span> x)</span>;
</code></pre>
<p>参数中<code>o</code>为需要更新的对象，<code>offset</code>是对象<code>o</code>中整形字段的偏移量，如果这个字段的值与<code>expected</code>相同，则将字段的值设为<code>x</code>这个新值，并且此更新是不可被中断的，也就是一个原子操作。下面是一个使用<code>compareAndSwapInt</code>的例子：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-built_in">int</span> a;
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>{
    CasTest casTest=<span class="hljs-keyword">new</span> CasTest();
    <span class="hljs-keyword">new</span> Thread(()-&gt;{
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++) {
            casTest.increment(i);
            System.<span class="hljs-keyword">out</span>.print(casTest.a+<span class="hljs-string">" "</span>);
        }
    }).start();
    <span class="hljs-keyword">new</span> Thread(()-&gt;{
        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">5</span> ; i &lt;<span class="hljs-number">10</span> ; i++) {
            casTest.increment(i);
            System.<span class="hljs-keyword">out</span>.print(casTest.a+<span class="hljs-string">" "</span>);
        }
    }).start();
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x</span>)</span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>){
        <span class="hljs-keyword">try</span> {
            <span class="hljs-built_in">long</span> fieldOffset = <span class="hljs-keyword">unsafe</span>.objectFieldOffset(CasTest.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">"a"</span>));
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">unsafe</span>.compareAndSwapInt(<span class="hljs-keyword">this</span>,fieldOffset,x<span class="hljs-number">-1</span>,x))
                <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">catch</span> (NoSuchFieldException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>运行代码会依次输出：</p>
<p>plain</p>
<pre><code class="hljs">1 2 3 4 5 6 7 8 9
</code></pre>
<p>在上面的例子中，使用两个线程去修改<code>int</code>型属性<code>a</code>的值，并且只有在<code>a</code>的值等于传入的参数<code>x</code>减一时，才会将<code>a</code>的值变为<code>x</code>，也就是实现对<code>a</code>的加一的操作。流程如下所示：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130526.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130526.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ab7b1c68423246038926ec5227e9cd9b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=TUIiFd06QpGQRv2GUC%2FZGTUgK1M%3D" alt="" loading="lazy"/></a></p>
<p>需要注意的是，在调用<code>compareAndSwapInt</code>方法后，会直接返回<code>true</code>或<code>false</code>的修改结果，因此需要我们在代码中手动添加自旋的逻辑。在<code>AtomicInteger</code>类的设计中，也是采用了将<code>compareAndSwapInt</code>的结果作为循环条件，直至修改成功才退出死循环的方式来实现的原子性的自增操作。</p>
<h2 data-id="heading-16">线程调度</h2>
<h3 data-id="heading-17">介绍</h3>
<p><code>Unsafe</code> 类中提供了<code>park</code>、<code>unpark</code>、<code>monitorEnter</code>、<code>monitorExit</code>、<code>tryMonitorEnter</code>方法进行线程调度。</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//取消阻塞线程</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Object thread)</span>;
<span class="hljs-comment">//阻塞线程</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isAbsolute, <span class="hljs-type">long</span> time)</span>;
<span class="hljs-comment">//获得对象锁（可重入锁）</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorEnter</span><span class="hljs-params">(Object o)</span>;
<span class="hljs-comment">//释放对象锁</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorExit</span><span class="hljs-params">(Object o)</span>;
<span class="hljs-comment">//尝试获取对象锁</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryMonitorEnter</span><span class="hljs-params">(Object o)</span>;
</code></pre>
<p>方法 <code>park</code>、<code>unpark</code> 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 <code>park</code> 方法实现的，调用 <code>park</code> 方法后，线程将一直阻塞直到超时或者中断等条件出现；<code>unpark</code> 可以终止一个挂起的线程，使其恢复正常。</p>
<p>此外，<code>Unsafe</code> 源码中<code>monitor</code>相关的三个方法已经被标记为<code>deprecated</code>，不建议被使用：</p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//获得对象锁</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorEnter</span><span class="hljs-params">(Object var1)</span>;
<span class="hljs-comment">//释放对象锁</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">monitorExit</span><span class="hljs-params">(Object var1)</span>;
<span class="hljs-comment">//尝试获得对象锁</span>
<span class="hljs-meta">@Deprecated</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryMonitorEnter</span><span class="hljs-params">(Object var1)</span>;
</code></pre>
<p><code>monitorEnter</code>方法用于获得对象锁，<code>monitorExit</code>用于释放对象锁，如果对一个没有被<code>monitorEnter</code>加锁的对象执行此方法，会抛出<code>IllegalMonitorStateException</code>异常。<code>tryMonitorEnter</code>方法尝试获取对象锁，如果成功则返回<code>true</code>，反之返回<code>false</code>。</p>
<h3 data-id="heading-18">典型应用</h3>
<p>Java 锁和同步器框架的核心类 <code>AbstractQueuedSynchronizer</code> (AQS)，就是通过调用<code>LockSupport.park()</code>和<code>LockSupport.unpark()</code>实现线程的阻塞和唤醒的，而 <code>LockSupport</code> 的 <code>park</code>、<code>unpark</code> 方法实际是调用 <code>Unsafe</code> 的 <code>park</code>、<code>unpark</code> 方式实现的。</p>
<p>java</p>
<pre><code class="hljs language-scss" lang="scss">public static void <span class="hljs-built_in">park</span>(Object blocker) {
    Thread t = Thread<span class="hljs-selector-class">.currentThread</span>();
    <span class="hljs-built_in">setBlocker</span>(t, blocker);
    UNSAFE<span class="hljs-selector-class">.park</span>(false, <span class="hljs-number">0</span>L);
    <span class="hljs-built_in">setBlocker</span>(t, null);
}
public static void <span class="hljs-built_in">unpark</span>(Thread thread) {
    if (thread != null)
        UNSAFE<span class="hljs-selector-class">.unpark</span>(thread);
}
</code></pre>
<p><code>LockSupport</code> 的<code>park</code>方法调用了 <code>Unsafe</code> 的<code>park</code>方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用<code>unpark</code>方法唤醒当前线程。下面的例子对 <code>Unsafe</code> 的这两个方法进行测试：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> {
    Thread mainThread = Thread.currentThread();
    <span class="hljs-keyword">new</span> Thread(()-&gt;{
        <span class="hljs-keyword">try</span> {
            TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);
            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"subThread try to unpark mainThread"</span>);
            <span class="hljs-keyword">unsafe</span>.unpark(mainThread);
        } <span class="hljs-keyword">catch</span> (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();

    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"park main mainThread"</span>);
    <span class="hljs-keyword">unsafe</span>.park(<span class="hljs-literal">false</span>,<span class="hljs-number">0L</span>);
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"unpark mainThread success"</span>);
}
</code></pre>
<p>程序输出为：</p>
<p>plain</p>
<pre><code class="hljs language-css" lang="css">park <span class="hljs-selector-tag">main</span> mainThread
subThread try <span class="hljs-selector-tag">to</span> unpark mainThread
unpark mainThread success
</code></pre>
<p>程序运行的流程也比较容易看懂，子线程开始运行后先进行睡眠，确保主线程能够调用<code>park</code>方法阻塞自己，子线程在睡眠 5 秒后，调用<code>unpark</code>方法唤醒主线程，使主线程能继续向下执行。整个流程如下图所示：</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fseven97-blog.oss-cn-hangzhou.aliyuncs.com%2Fimgs%2F202406202130484.png" target="_blank" title="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130484.png" ref="nofollow noopener noreferrer"><img src="https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202406202130484.png" alt="" loading="lazy"/></a></p>
<h2 data-id="heading-19">Class 操作</h2>
<h3 data-id="heading-20">介绍</h3>
<p><code>Unsafe</code> 对<code>Class</code>的相关操作主要包括类加载和静态变量的操作方法。</p>
<p><strong>静态属性读取相关的方法</strong></p>
<p>java</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">//获取静态属性的偏移量</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">staticFieldOffset</span><span class="hljs-params">(Field f)</span>;
<span class="hljs-comment">//获取静态属性的对象指针</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">staticFieldBase</span><span class="hljs-params">(Field f)</span>;
<span class="hljs-comment">//判断类是否需要初始化（用于获取类的静态属性前进行检测）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldBeInitialized</span><span class="hljs-params">(Class&lt;?&gt; c)</span>;
</code></pre>
<p>创建一个包含静态属性的类，进行测试：</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp">@Data
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String name=<span class="hljs-string">"Hydra"</span>;
    <span class="hljs-built_in">int</span> age;
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticTest</span>() throws Exception</span> {
    User user=<span class="hljs-keyword">new</span> User();
    <span class="hljs-comment">// 也可以用下面的语句触发类初始化</span>
    <span class="hljs-comment">// 1.</span>
    <span class="hljs-comment">// unsafe.ensureClassInitialized(User.class);</span>
    <span class="hljs-comment">// 2.</span>
    <span class="hljs-comment">// System.out.println(User.name);</span>
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">unsafe</span>.shouldBeInitialized(User.<span class="hljs-keyword">class</span>));
    Field sexField = User.<span class="hljs-keyword">class</span>.getDeclaredField(<span class="hljs-string">"name"</span>);
    <span class="hljs-built_in">long</span> fieldOffset = <span class="hljs-keyword">unsafe</span>.staticFieldOffset(sexField);
    Object fieldBase = <span class="hljs-keyword">unsafe</span>.staticFieldBase(sexField);
    Object <span class="hljs-built_in">object</span> = <span class="hljs-keyword">unsafe</span>.getObject(fieldBase, fieldOffset);
    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">object</span>);
}
</code></pre>
<p>运行结果：</p>
<p>plain</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-literal">false</span>
Hydra
</code></pre>
<p>在 <code>Unsafe</code> 的对象操作中，我们学习了通过<code>objectFieldOffset</code>方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用<code>staticFieldOffset</code>方法。在上面的代码中，只有在获取<code>Field</code>对象的过程中依赖到了<code>Class</code>，而获取静态变量的属性时不再依赖于<code>Class</code>。</p>
<p>在上面的代码中首先创建一个<code>User</code>对象，这是因为如果一个类没有被初始化，那么它的静态属性也不会被初始化，最后获取的字段属性将是<code>null</code>。所以在获取静态属性前，需要调用<code>shouldBeInitialized</code>方法，判断在获取前是否需要初始化这个类。如果删除创建 User 对象的语句，运行结果会变为：</p>
<p>plain</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-literal">true</span>
<span class="hljs-literal">null</span>
</code></pre>
<p><strong>使用<code>defineClass</code>方法允许程序在运行时动态地创建一个类</strong></p>
<p>java</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> native Class&lt;?&gt; <span class="hljs-title">defineClass</span><span class="hljs-params">(<span class="hljs-type">String</span> name, <span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len, ClassLoader loader,ProtectionDomain protectionDomain)</span></span>;
</code></pre>
<p>在实际使用过程中，可以只传入字节数组、起始字节的下标以及读取的字节长度，默认情况下，类加载器（<code>ClassLoader</code>）和保护域（<code>ProtectionDomain</code>）来源于调用此方法的实例。下面的例子中实现了反编译生成后的 class 文件的功能：</p>
<p>java</p>
<pre><code class="hljs language-ini" lang="ini">private static void defineTest() {
    String <span class="hljs-attr">fileName</span>=<span class="hljs-string">"F:\workspace\unsafe-test\target\classes\com\cn\model\User.class"</span><span class="hljs-comment">;</span>
    File <span class="hljs-attr">file</span> = new File(fileName)<span class="hljs-comment">;</span>
    try(FileInputStream <span class="hljs-attr">fis</span> = new FileInputStream(file)) {
        byte<span class="hljs-section">[]</span> <span class="hljs-attr">content</span>=new byte[(int)file.length()]<span class="hljs-comment">;</span>
        fis.read(content)<span class="hljs-comment">;</span>
        Class <span class="hljs-attr">clazz</span> = unsafe.defineClass(null, content, <span class="hljs-number">0</span>, content.length, null, null)<span class="hljs-comment">;</span>
        Object <span class="hljs-attr">o</span> = clazz.newInstance()<span class="hljs-comment">;</span>
        Object <span class="hljs-attr">age</span> = clazz.getMethod(<span class="hljs-string">"getAge"</span>).invoke(o, null)<span class="hljs-comment">;</span>
        System.out.println(age)<span class="hljs-comment">;</span>
    } catch (Exception e) {
        e.printStackTrace()<span class="hljs-comment">;</span>
    }
}
</code></pre>
<p>在上面的代码中，首先读取了一个<code>class</code>文件并通过文件流将它转化为字节数组，之后使用<code>defineClass</code>方法动态的创建了一个类，并在后续完成了它的实例化工作，流程如下图所示，并且通过这种方式创建的类，会跳过 JVM 的所有安全检查。</p>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Foss.javaguide.cn%2Fgithub%2Fjavaguide%2Fjava%2Fbasis%2Funsafe%2Fimage-20220717145000710.png" target="_blank" title="https://oss.javaguide.cn/github/javaguide/java/basis/unsafe/image-20220717145000710.png" ref="nofollow noopener noreferrer"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/943b180e413f45d38624174ed73a4ebc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137203&amp;x-signature=hsOaP0KsEp%2FGFeTEkmNIllfaG34%3D" alt="" loading="lazy"/></a></p>
<p>除了<code>defineClass</code>方法外，Unsafe 还提供了一个<code>defineAnonymousClass</code>方法：</p>
<p>java</p>
<pre><code class="hljs language-vbnet" lang="vbnet"><span class="hljs-keyword">public</span> native <span class="hljs-keyword">Class</span>&lt;?&gt; defineAnonymousClass(<span class="hljs-keyword">Class</span>&lt;?&gt; hostClass, <span class="hljs-type">byte</span>[] data, <span class="hljs-type">Object</span>[] cpPatches);
</code></pre>
<p>使用该方法可以用来动态的创建一个匿名类，在<code>Lambda</code>表达式中就是使用 ASM 动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在 JDK 15 发布的新特性中，在隐藏类（<code>Hidden classes</code>）一条中，指出将在未来的版本中弃用 <code>Unsafe</code> 的<code>defineAnonymousClass</code>方法。</p>
<h3 data-id="heading-21">典型应用</h3>
<p>Lambda 表达式实现需要依赖 <code>Unsafe</code> 的 <code>defineAnonymousClass</code> 方法定义实现相应的函数式接口的匿名类。</p>
<h2 data-id="heading-22">系统信息</h2>
<h3 data-id="heading-23">介绍</h3>
<p>这部分包含两个获取系统相关信息的方法。</p>
<p>java</p>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> native <span class="hljs-built_in">int</span> <span class="hljs-title">addressSize</span>()</span>;
<span class="hljs-comment">//内存页的大小，此值为2的幂次方。</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> native <span class="hljs-built_in">int</span> <span class="hljs-title">pageSize</span>()</span>;
</code></pre>
<h3 data-id="heading-24">典型应用</h3>
<p>这两个方法的应用场景比较少，在<code>java.nio.Bits</code>类中，在使用<code>pageCount</code>计算所需的内存页的数量时，调用了<code>pageSize</code>方法获取内存页的大小。另外，在使用<code>copySwapMemory</code>方法拷贝内存时，调用了<code>addressSize</code>方法，检测 32 位系统的情况。</p>
<h2 data-id="heading-25">Unsafe底层</h2>
<p>再看看Unsafe的compareAndSwap 方法来实现CAS操作，它是一个本地方法，实现位于unsafe.cpp中。</p>
<p>java</p>
<pre><code class="hljs language-ini" lang="ini">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))
  UnsafeWrapper("Unsafe_CompareAndSwapInt")<span class="hljs-comment">;</span>
  oop <span class="hljs-attr">p</span> = JNIHandles::resolve(obj)<span class="hljs-comment">;</span>
  jint* <span class="hljs-attr">addr</span> = (jint *) index_oop_from_field_<span class="hljs-literal">off</span>set_long(p, <span class="hljs-literal">off</span>set)<span class="hljs-comment">;</span>
  return (jint)(Atomic::cmpxchg(x, addr, e)) == e<span class="hljs-comment">;</span>
UNSAFE_END
</code></pre>
<p>可以看到它通过 Atomic::cmpxchg 来实现比较和替换操作。其中参数x是即将更新的值，参数e是原内存的值。</p>
<p>如果是Linux的x86，Atomic::cmpxchg方法的实现如下：</p>
<p>java</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-function"><span class="hljs-keyword">inline</span> jint <span class="hljs-title">Atomic::cmpxchg</span> <span class="hljs-params">(jint exchange_value, <span class="hljs-keyword">volatile</span> jint* dest, jint compare_value)</span> </span>{
  <span class="hljs-type">int</span> mp = os::<span class="hljs-built_in">is_MP</span>();
  <span class="hljs-function">__asm__ <span class="hljs-title">volatile</span> <span class="hljs-params">(LOCK_IF_MP(%<span class="hljs-number">4</span>) <span class="hljs-string">"cmpxchgl %1,(%3)"</span>
                    : <span class="hljs-string">"=a"</span> (exchange_value)
                    : <span class="hljs-string">"r"</span> (exchange_value), <span class="hljs-string">"a"</span> (compare_value), <span class="hljs-string">"r"</span> (dest), <span class="hljs-string">"r"</span> (mp)
                    : <span class="hljs-string">"cc"</span>, <span class="hljs-string">"memory"</span>)</span></span>;
  <span class="hljs-keyword">return</span> exchange_value;
}
</code></pre>
<p>而windows的x86的实现如下：</p>
<p>java</p>
<pre><code class="hljs language-scss" lang="scss">inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) {
    int mp = os::<span class="hljs-built_in">isMP</span>(); <span class="hljs-comment">//判断是否是多处理器</span>
    _asm {
        mov edx, dest
        mov ecx, exchange_value
        mov eax, compare_value
        <span class="hljs-built_in">LOCK_IF_MP</span>(mp)
        cmpxchg dword ptr <span class="hljs-selector-attr">[edx]</span>, ecx
    }
}

<span class="hljs-comment">// Adding a lock prefix to an instruction on MP machine</span>
<span class="hljs-comment">// VC++ doesn't like the lock prefix to be on a single line</span>
<span class="hljs-comment">// so we can't insert a label after the lock prefix.</span>
<span class="hljs-comment">// By emitting a lock prefix, we can define a label after it.</span>
<span class="hljs-selector-id">#define</span> <span class="hljs-built_in">LOCK_IF_MP</span>(mp) __asm cmp mp, <span class="hljs-number">0</span>  \
                       __asm je L0      \
                       __asm _emit <span class="hljs-number">0</span>xF0 \
                       __asm L0:
</code></pre>
<p>如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀(单处理器会不需要lock前缀提供的内存屏障效果)。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。</p>
<blockquote>
<p>cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。在Intel平台下，会用lock cmpxchg来实现，使用lock触发缓存锁，这样另一个线程想访问ptr的内存，就会被block住。</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Web 安全与反编译源码下的权限设计：构建前后端一体的信任防线]]></title>    <link>https://juejin.cn/post/7603771025856561203</link>    <guid>https://juejin.cn/post/7603771025856561203</guid>    <pubDate>2026-02-08T06:35:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856561203" data-draft-id="7603674653153787913" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Web 安全与反编译源码下的权限设计：构建前后端一体的信任防线"/> <meta itemprop="keywords" content="前端,安全,编译原理"/> <meta itemprop="datePublished" content="2026-02-08T06:35:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="LeonGao"/> <meta itemprop="url" content="https://juejin.cn/user/3976252950591149"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Web 安全与反编译源码下的权限设计：构建前后端一体的信任防线
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3976252950591149/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    LeonGao
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:35:50.000Z" title="Sun Feb 08 2026 06:35:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{position:relative;word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden;color:#333}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:30px;margin-bottom:5px}.markdown-body h2{font-size:24px;display:inline-block;font-weight:700;background:#ef7060;color:#fff;padding:6px 8px 0 0;border-top-right-radius:6px;margin-right:2px;box-shadow:6px 3px 0 0 rgba(239,112,96,.2)}.markdown-body h2:before{content:" ";display:inline-block;width:8px}.markdown-body h2:after{content:" ";position:absolute;display:block;width:calc(100% - 50px);border-bottom:3px solid #ef7060}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h4{font-size:16px}.markdown-body h5{font-size:15px}.markdown-body h6{margin-top:5px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #3e3e3e;margin-top:32px;margin-bottom:32px;height:1px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:rgba(27,31,35,.05);color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:JetBranins Mono,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;box-shadow:0 0 8px hsla(0,0%,43.1%,.45);border-radius:4px;margin:16px}.markdown-body pre:before{content:"";display:block;height:30px;width:100%;margin-bottom:-7px;background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAdCAYAAABcz8ldAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAhgSURBVGhD7Zp7bBTHHcdn33t7vvOdzy+ITVKDU0xIKG2ABCPTRCCaUiEVKWoqRJuASAhCitRCVKSoalFUKZBiSmmFRRJKRUnUtIpo+aNqGgwoOCmuFUIRzxjwE4zte+97drYzztji8HPvtkit/PnH+n1397Tz+83vN/PbMZhmmmmm+d+BoX8n5diihcGqgFQf5vk6BMAskWUlw3GyFnIvtqWSf91w7mKC3npfOLX7wYeiIa6BBWCOLLFRF2NB0JvIOP/80YG+k2ev6S699b/OzOfKBW5l5KsgyC4DCFQDnpEAdE1goc/dlNPc/Up7P711UiYNSMuyxeUzZPnHgGHWh5XADEkSAcdiN+AnEXIBhBComgFU0/xQR+jnj51sOUMf9Z0NKyL8S9+JPBEN8zuCMrsqGOA5QWAAyzLAxe53HBeYFgJp1c5Cx33nyIfpV3e+22/Sx32nev/sMCgVnmM4bjOniAtZWQAsz315EfsGQQc4hgWcjHkCmOj1rheuNn95cXwmDMiVp5etC/D8m5FwUWVQUYYGPh6mZYFUOgsGVa1pXvOZzVT2jRuH54RM230jEuI3RcIiL4l4UkxAJmuD/riVsqD7ct2m9nep7BtVTbVfZ0uE/UIk+CQflAHDjf8+Lg6MldYATGpH3c/Ul7p3dWXppVGM6eElJSHmnQWPbSlRlN1lJcUBjqNRnwJZVQO3B5P/uq5rK1d90pakckFcaKp5UJHY92JR8YlwkUDVySEZfGfQdO7E7Z8s2HL9TSoXTPXRud9nA8IBqSwcZgWeqpPj6BYw7yTbXBN9q2v9lQEq5zBmWA8vWLCptCi4tzwW8RQMQlFQATPLSh6vCSh/plJBkMyQBHZfWYnkKRgEktEVpTJXERN2Xzo4ex2VC6K6qXYpF5b3ypVRT8EgcAERSJXRbwCBOTFzXblM5RxGBaRt+ZPYA+LO0mgxz5K1Ig+UgAzKIuGnz39z6S+olDeaibaXRsU1RUFvgx+GwTWgPCaDgMw2XXpr9gwq50XV0bkxJiYeEiNF5cwE5XsiOEkAUkXkUW51SSOVchjl8WKef604XFSRbzCGCYeCoESStv/p8QU1VPIM3knNDynctnBRfsEYhgSlNCIGgQv2UCkvGIHZgteMh1nBW9W4F16RAM6yDVV7amZTaYQcr59cuuhhWRTWBvAMLxQGeyFSHOLnh0MvUskz5RF+fbRYDEy0mZgqQYUHOLhr//b6rGoqeaLqQG0pw3PrBbyA+4EQUkRmhvgqNUfICUipKK4OKUqIJVPKB0jpEhjmWWp64jdbKmVZZNYogcJm493gsifOqhDyeh9GYR/FM7sW+DA5CKR0MSK3tvKZkpwB5gRE4tjFEr7RL0iWBGV51vHFCyupNGWWPqLgnoer9mtyEGSJAzwLllDTGzyznDjRN/CwOFkoFb4bm0eVIXICgpvdGoEvrF7fC89zfLkkeV5HbOhWiTwTpKYvCAJLGshRdXtKMKAWlyxq+MPQLk1h66g5RE5ABJYNFrqY3wvJklJRUKg5ZWLFXIA86yek2uDOPkBNb3CM5Pf7DL2QyIrUGiLH+xC5Bmmm/ARnHUhC6PnzxWDK0RH5HuIjZGy27erU9AZ0dTIWXyG+NpBBrSFySxZw220IqeUPFoS6jVAPNadM7yDsgNB1qOkLuAziMYIb1PQGA75wIaKGPyAb+9oF16g5RE5ALIQ+tSyLWoWDEAK6aXW3JlK9VJoyx1oyvVkNdvo5KXXDAVkdnaKmNwx0xjH98w3JNmTCm+Bc9hKVhsgJSI9pvp9Vdd++jmq6AXB2/HHrhcs5aTkVDv0DFzoHvKdq/mQsKX/4t7KJLDpOJW+IbAvMGoMkxfwAWZB8DT7W1diTE+WcgKz6pK1bs6z3daPwmJDsSKt6ZsCyjlLJMz0DsDGZ8SdlDROBjOb8YeWOjptU8kTXusuaazu7oJrfEnQvdkpVcUn6PTVHyAkIIW7br/Unklni0EJIZ1WgGsauZR+fvUglz6zY0dGfVp09ybRNlfwgi3k8YSbvJJ29VMoLt9v6rZVQL7hOYUubndHJGclBtzn1byqNMCogi09/2nFb01/oj+f/5TyjauBOKtPcZ1r7qZQ3f2lRfxZPWi2anp8TSDAGExZMa2jr8u03L1M5L7q3Xc+iAeuHRl/ScvPcjSLDBnZS/cjtNHd2v3171Ewbs9N5q7Pn4otVMx3btBsCsoRbk1FxG5dMVgMDqfTpXl1/tuFMa5zKefPROdX59qLQBwLnNog8Wy1OcjB1N+QEsW/QsFNZuO35Xb1v98QLX4/Sx+O3wqujrQ6013ABUWI8+AaqBjAH01+ghL22+5X2PirnMG7r+esbnae/V1neauvGSoHjigTcVU7UGFm2DeK4ttxKpQ+mLPvl+o/PjnkAkw9HTqSMmVHhyAMx9iFcSh/BHTfLceO/C8mKjApBf9zszGhoY92m9sN+BGOY9AeD7eGniv8OTaOB4dgyTsQd9wS+IQu4lciYdkI7CLrNH3Rvbb9FL41i0tbzVP2iWJkobpN5fmM4IJfJskTP1Bk8A9HQmbpmGDBrWqdVCN/Yd7PjxKGOXn+bmbto3feVVcVB9qehIL8EJy8nChwgr0O2xxBnhGU5eP2CfYbl/m4gBRsbtneMORP9oGpjpcCsiKzHHfdOPiQ/wMniyFEu2dbiTQCAeN/vavC466BGYLttXc9fmXBXMGlAhiHHur+sq6uPiUI9z7CVHMPwBnLSuuN8FuC48/Oaz1ylt94XfrW5ouyprwWfYRkwNyCyYYjwkBHows1fa+tV/fzGxlv39b9gqvfPmQ+i/HK8KlcBjhHwfl8HEHyOd1JnuzZd66S3TTPNNNP8/wDAfwDG7G0m9LKBpwAAAABJRU5ErkJggg==) 10px 10px no-repeat;background-size:40px;background-color:#fdfdfd}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#fdfdfd}.markdown-body a{text-decoration:none;font-weight:700;color:#ef7060;border-bottom:1px solid #ef7060}.markdown-body a:active,.markdown-body a:hover{color:#ef2d26}.markdown-body table tr td,.markdown-body table tr th{border:1px solid #ccc;padding:5px 10px}.markdown-body table{display:block!important;width:auto;max-width:100%;overflow:auto;border-collapse:collapse}.markdown-body thead{background:#f0f0f0;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#f8f8f8}.markdown-body blockquote{margin-inline-start:0;margin-inline-end:0;border-left:3px solid #ef7060;background:#fff9f9;padding:1px 20px;margin-top:20px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-light">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#a0a1a7;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e45649}.hljs-literal{color:#0184bb}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#50a14f}.hljs-built_in,.hljs-class .hljs-title{color:#c18401}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#4078f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><h2 data-id="heading-0">引言</h2>
<p>在现代 Web 应用中，<strong>安全与权限设计</strong> 是架构中最容易被忽视、却最容易出问题的部分。<br/>
随着前端应用的复杂度不断提高（Vue、React、Flutter Web 等），越来越多逻辑被放在客户端执行；<br/>
与此同时，打包后的前端代码可被轻易“反编译”、“逆向分析”或直接在浏览器中篡改。</p>
<p>于是，开发者常面临一个棘手问题：</p>
<blockquote>
<p>「当用户可以直接查看、修改、甚至注入前端逻辑时，我们该如何保障权限体系的安全性？」</p>
</blockquote>
<p>本文将系统分析 <strong>反编译环境下权限设计的风险与防护机制</strong>，通过架构分层思路，<br/>
构建一个前后端统一、安全可控的权限防护体系，并提供实践代码与工程建议。</p>
<hr/>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f136ab89966405c858f127a85d954e1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTGVvbkdhbw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771137350&amp;x-signature=OrhcZhqf%2F91h7ZTzDxqsJqWUCL4%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-1">一、问题定义与背景</h2>
<h3 data-id="heading-2">1. 前端反编译：安全的假象</h3>
<p>前端编译产物（HTML、JS、CSS）最终都需运行在用户端。<br/>
即使使用了 Webpack、Vite、Uglify 进行混淆打包，攻击者仍可通过如下方式分析源码：</p>
<ul>
<li>打开 <strong>浏览器开发者工具</strong> 查看逻辑；</li>
<li>使用 <strong>反混淆工具</strong> 还原函数与模块；</li>
<li>直接 <strong>修改全局变量绕过条件判断</strong>；</li>
<li>使用 <strong>抓包工具（如 Burp、Postman）</strong> 模拟接口调用。</li>
</ul>
<p>这意味着：<br/>
前端的权限判断、令牌验证或角色限制——如果<strong>不由后端复核</strong>，<br/>
都可以被通过篡改脚本的方式绕过。</p>
<h3 data-id="heading-3">2. 案例：被篡改的前端权限</h3>
<p>错误示例（前端判断管理员身份）：</p>
<pre><code class="hljs language-ini" lang="ini">if (<span class="hljs-attr">user.role</span> === <span class="hljs-string">'admin'</span>) {
  showAdminPanel()<span class="hljs-comment">;</span>
}
</code></pre>
<p>攻击者在浏览器控制台直接执行：</p>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-attr">user.role</span> = <span class="hljs-string">'admin'</span><span class="hljs-comment">;</span>
showAdminPanel()<span class="hljs-comment">;</span>
</code></pre>
<p>即可解锁「管理员面板」。<br/>
但如果后端接口没有二次验证，那么真正的危险在于：<strong>他能调用后台管理 API 删除数据。</strong></p>
<hr/>
<h2 data-id="heading-4">二、安全权限设计的核心原则</h2>
<ol>
<li>
<p><strong>前端展示，后端决策</strong></p>
<ul>
<li>前端只能控制 UI 是否显示某个按钮，不应决定「是否允许执行动作」。</li>
<li>所有与安全相关的逻辑（增删改、数据查询）必须由后端验证。</li>
</ul>
</li>
<li>
<p><strong>服务端必须验证权限 + 签名</strong></p>
<ul>
<li>后端是「唯一可信环境」，应验证请求来源、签名、角色、Token。</li>
</ul>
</li>
<li>
<p><strong>权限是「被动判定」，不是「主动记忆」</strong></p>
<ul>
<li>不依赖前端本地状态（如 localStorage）；</li>
<li>每次请求都在后端重新验证身份。</li>
</ul>
</li>
</ol>
<hr/>
<h2 data-id="heading-5">三、安全权限防护的分层架构</h2>
<p>为了实现安全的分布式权限体系，我们可以将系统划分为六层：</p>








































<table><thead><tr><th>层级</th><th>描述</th><th>核心防护策略</th></tr></thead><tbody><tr><td><strong>① 前端展示层</strong></td><td>Vue / React 应用</td><td>仅展示功能，不存储逻辑；限制 Token 暴露</td></tr><tr><td><strong>② 接入与网关层</strong></td><td>Nginx / Kong / API Gateway</td><td>限流、防爬；验证 Token 签名；请求日志</td></tr><tr><td><strong>③ 鉴权服务层</strong></td><td>OAuth2 / SSO Server</td><td>登录态验证；角色与租户判断；颁发 JWT</td></tr><tr><td><strong>④ 资源服务层</strong></td><td>各业务模块服务</td><td>核心逻辑校验：RBAC / ABAC 权限匹配</td></tr><tr><td><strong>⑤ 数据与审计层</strong></td><td>Database、Redis、ELK</td><td>脱敏、最小访问策略、操作留痕</td></tr><tr><td><strong>⑥ 安全监控层</strong></td><td>SIEM、Prometheus</td><td>风控检测、告警策略、异常分析</td></tr></tbody></table>
<h3 data-id="heading-6">架构图</h3>
<p>下图展示了完整防护分层结构（数据流由上至下）：</p>
<pre><code class="hljs language-css" lang="css">┌──────────────────────────────────────┐
│          安全监控层（SIEM/风控）     │
│  • 登录异常检测  • 攻击告警分析     │
└──────────────────────────────────────┘
                 ▲
┌──────────────────────────────────────┐
│          数据与审计层               │
│  • 数据最小权限访问                │
│  • 审计日志与安全追踪              │
└──────────────────────────────────────┘
                 ▲
┌──────────────────────────────────────┐
│          资源服务层（业务逻辑）      │
│  • 接口级权限控制（<span class="hljs-keyword">@RoleBasedAccess</span>）│
│  • 防越权、操作审计                │
└──────────────────────────────────────┘
                 ▲
┌──────────────────────────────────────┐
│          鉴权服务层（SSO）           │
│  • Token验证、角色发放              │
│  • 动态授权、租户隔离               │
└──────────────────────────────────────┘
                 ▲
┌──────────────────────────────────────┐
│          接入网关层（API Gateway）   │
│  • 限流、防爬、防刷                │
│  • HMAC签名验证                    │
└──────────────────────────────────────┘
                 ▲
┌──────────────────────────────────────┐
│          前端展示层（非信任区）      │
│  • 仅展示UI、读取Token提醒用户登录   │
│  • 禁止业务逻辑在本地执行           │
└──────────────────────────────────────┘
</code></pre>
<hr/>
<h2 data-id="heading-7">四、技术实现</h2>
<h3 data-id="heading-8">1. 后端角色权限注解示例</h3>
<pre><code class="hljs language-less" lang="less"><span class="hljs-comment">// 自定义注解</span>
<span class="hljs-variable">@Target</span>(ElementType.METHOD)
<span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)
public <span class="hljs-variable">@interface</span> RoleCheck {
    <span class="hljs-selector-tag">String</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">value</span>();
}
</code></pre>

<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 拦截器实现</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res, Object handler)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> req.getHeader(<span class="hljs-string">"Authorization"</span>);
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> TokenService.verify(token);
        <span class="hljs-type">RoleCheck</span> <span class="hljs-variable">check</span> <span class="hljs-operator">=</span> ((HandlerMethod) handler).getMethodAnnotation(RoleCheck.class);
        <span class="hljs-keyword">if</span> (check != <span class="hljs-literal">null</span> &amp;&amp; !user.hasAnyRole(check.value())) {
            res.setStatus(HttpServletResponse.SC_FORBIDDEN);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}
</code></pre>
<blockquote>
<p>🔐 即便攻击者模拟请求或反编译前端，也无法绕过后端角色认证。</p>
</blockquote>
<hr/>
<h3 data-id="heading-9">2. 前端：基于权限的显示控制（非逻辑控制）</h3>
<pre><code class="hljs language-ini" lang="ini">// 假设后端返回的角色为 <span class="hljs-section">['user']</span>
const <span class="hljs-attr">userRoles</span> = [<span class="hljs-string">'user'</span>]<span class="hljs-comment">;</span>

const <span class="hljs-attr">routes</span> = [
  { name: <span class="hljs-string">'Dashboard'</span>, meta: { role: [<span class="hljs-string">'user'</span>, <span class="hljs-string">'admin'</span>] } },
  { name: <span class="hljs-string">'SystemConfig'</span>, meta: { role: [<span class="hljs-string">'admin'</span>] } }
]<span class="hljs-comment">;</span>

// 仅前端渲染控制
const <span class="hljs-attr">visibleRoutes</span> = routes.filter(route =&gt;
  route.meta.role.some(<span class="hljs-attr">role</span> =&gt; userRoles.includes(role))
)<span class="hljs-comment">;</span>
</code></pre>
<blockquote>
<p>仅影响 UI 展示，不影响接口可访问性。</p>
</blockquote>
<hr/>
<h3 data-id="heading-10">3. 防反编译与攻击加固</h3>



































<table><thead><tr><th>攻击方式</th><th>防护措施</th><th>实践工具</th></tr></thead><tbody><tr><td>打包JS被逆向</td><td>混淆与代码压缩</td><td><code>terser</code>, <code>webpack-obfuscator</code></td></tr><tr><td>Token篡改</td><td>服务签名验证、短时效JWT</td><td>Redis / JWT RFC7519</td></tr><tr><td>模拟接口</td><td>请求签名（HMAC / Nonce）</td><td>Nginx + Auth Filter</td></tr><tr><td>调试注入</td><td>Content-Security-Policy (CSP)</td><td>HTTP 安全策略头</td></tr><tr><td>重放攻击</td><td>时间戳 + 随机Nonce验证</td><td>Redis缓存校验</td></tr></tbody></table>
<p><strong>签名验证示例（Node.js HMAC）</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> crypto <span class="hljs-keyword">from</span> <span class="hljs-string">'crypto'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">signRequest</span>(<span class="hljs-params">payload, secret, timestamp</span>) {
  <span class="hljs-keyword">const</span> base = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(payload) + timestamp;
  <span class="hljs-keyword">return</span> crypto.<span class="hljs-title function_">createHmac</span>(<span class="hljs-string">'sha256'</span>, secret).<span class="hljs-title function_">update</span>(base).<span class="hljs-title function_">digest</span>(<span class="hljs-string">'hex'</span>);
}
</code></pre>
<hr/>
<h2 data-id="heading-11">五、设计优缺点分析</h2>





























<table><thead><tr><th>模型</th><th>优点</th><th>缺点</th><th>适合场景</th></tr></thead><tbody><tr><td><strong>前端判断权限</strong></td><td>简单、体验好</td><td>易被绕过、不安全</td><td>仅用于 UI 控制</td></tr><tr><td><strong>后端校验权限</strong></td><td>安全、集中管理</td><td>开销稍高、响应滞后</td><td>核心业务接口</td></tr><tr><td><strong>分层架构权限体系</strong></td><td>安全与效率平衡</td><td>架构复杂、需治理</td><td>企业级中大型系统</td></tr></tbody></table>
<blockquote>
<p>✅ 推荐混合架构：前端保障体验，后端保障安全。</p>
</blockquote>
<hr/>
<h2 data-id="heading-12">六、结论</h2>
<p>在 Web 反编译几乎无法避免的时代，<strong>安全是策略，不是幻觉</strong>。</p>
<p>权限控制要从「信任前端」转变为「前后端协同」。<br/>
只要保持以下三点，你的权限体系就能在复杂的安全形势下立于不败之地：</p>
<ol>
<li><strong>一切授权最终落地后端；</strong></li>
<li><strong>所有敏感逻辑皆可审计；</strong></li>
<li><strong>前后端之间的信任关系可验证、可撤销。</strong></li>
</ol>
<p>未来，伴随 <strong>零信任架构（Zero Trust）</strong> 与 <strong>动态策略授权（Policy-based Access Control, PBAC）</strong> 的兴起，<br/>
权限安全将更加智能与分布化。安全从此不是附加，而将成为业务本身的一部分。</p>
<hr/>
<h2 data-id="heading-13">七、参考资料</h2>
<ol>
<li>[OWASP Top 10 2021: Broken Access Control]</li>
<li>[Spring Security Reference Documentation]</li>
<li>[MDN Web Docs: Content Security Policy (CSP)]</li>
<li>[RFC 7519 – JSON Web Token (JWT)]</li>
<li>[Zero Trust Architecture – NIST SP 800-207]</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Java 后端定时任务怎么选：@Scheduled、Quartz 还是 XXL-Job？]]></title>    <link>https://juejin.cn/post/7603721514203316233</link>    <guid>https://juejin.cn/post/7603721514203316233</guid>    <pubDate>2026-02-08T06:51:17.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603721514203316233" data-draft-id="7603687444052099110" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Java 后端定时任务怎么选：@Scheduled、Quartz 还是 XXL-Job？"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T06:51:17.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java编程爱好者"/> <meta itemprop="url" content="https://juejin.cn/user/819554264300154"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Java 后端定时任务怎么选：@Scheduled、Quartz 还是 XXL-Job？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/819554264300154/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java编程爱好者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:51:17.000Z" title="Sun Feb 08 2026 06:51:17 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>做后端总绕不开“定时任务”：对账、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%2595%25B0%25E6%258D%25AE%25E6%25B8%2585%25E7%2590%2586%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86&amp;zhida_source=entity" ref="nofollow noopener noreferrer">数据清理</a>、发券、补偿、同步……</p>
<p>但一到<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25BE%25AE%25E6%259C%258D%25E5%258A%25A1%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&amp;zhida_source=entity" ref="nofollow noopener noreferrer">微服务</a>/多实例部署，很多同学就开始踩坑：<strong>同一任务在每台机器都跑一遍（重复执行）</strong> 、某台机器挂了任务就断了（<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%258D%2595%25E7%2582%25B9%25E6%2595%2585%25E9%259A%259C%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C&amp;zhida_source=entity" ref="nofollow noopener noreferrer">单点故障</a>）、任务太久把<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25B0%2583%25E5%25BA%25A6%25E7%25BA%25BF%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">调度线程</a>卡死（后面全堵）……</p>
<hr/>
<h2 data-id="heading-0">“单机闹钟”还是“<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E8%25B0%2583%25E5%25BA%25A6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">分布式调度</a>”？</h2>
<ul>
<li>
<p>• <strong>单机定时任务</strong>：应用只部署 1 台（或明确只允许 1 台跑任务）。<br/>
✅ 这类任务追求“简单、快、少依赖”。</p>
</li>
<li>
<p>• <strong>分布式/<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E9%259B%2586%25E7%25BE%25A4%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E9%9B%86%E7%BE%A4&amp;zhida_source=entity" ref="nofollow noopener noreferrer">集群</a>定时任务</strong>：应用部署 N 台、会扩缩容、会<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%2595%2585%25E9%259A%259C%25E8%25BD%25AC%25E7%25A7%25BB%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB&amp;zhida_source=entity" ref="nofollow noopener noreferrer">故障转移</a>。<br/>
✅ 这类任务追求“只执行一次、可观测、可运维”。</p>
</li>
</ul>
<p><strong>在集群里，单机方案默认=每台都执行</strong>，不做控制就会重复跑。</p>
<hr/>
<h2 data-id="heading-1">三个方案</h2>
<h3 data-id="heading-2">1）<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%2540Scheduled%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%40Scheduled&amp;zhida_source=entity" ref="nofollow noopener noreferrer">@Scheduled</a>：Spring 自带的轻量方案（单机优先）</h3>
<p>就是给方法加个注解：cron / fixedRate / fixedDelay，立刻能跑。<br/>
优点：零额外<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E4%25B8%25AD%25E9%2597%25B4%25E4%25BB%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E4%B8%AD%E9%97%B4%E4%BB%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">中间件</a>、和 Spring 生态贴合。</p>
<p>短板：<strong>天生不管集群</strong>（多实例就多份闹钟）、基本没<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%258F%25AF%25E8%25A7%2586%25E5%258C%2596%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%8F%AF%E8%A7%86%E5%8C%96&amp;zhida_source=entity" ref="nofollow noopener noreferrer">可视化</a>、想改规则通常要走发布流程。</p>
<blockquote>
<p>提醒：同一个方法可以声明多个 @Scheduled，<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25A7%25A6%25E5%258F%2591%25E5%2599%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E8%A7%A6%E5%8F%91%E5%99%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">触发器</a>彼此独立，甚至可能并发/连续触发。</p>
</blockquote>
<hr/>
<h3 data-id="heading-3">2）<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DQuartz%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=Quartz&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Quartz</a>：老牌、灵活、可集群（但“偏框架”）</h3>
<p>Quartz 的核心是 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DScheduler%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=Scheduler&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Scheduler</a>（<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25B0%2583%25E5%25BA%25A6%25E5%2599%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E8%B0%83%E5%BA%A6%E5%99%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">调度器</a>）+ Job（任务）+ <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DTrigger%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=Trigger&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Trigger</a>（触发器）</strong> ，能力非常全。<br/>
它也支持集群，但需要 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DJDBC%2BJobStore%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=JDBC+JobStore&amp;zhida_source=entity" ref="nofollow noopener noreferrer">JDBC JobStore</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%2585%25B1%25E4%25BA%25AB%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%93&amp;zhida_source=entity" ref="nofollow noopener noreferrer">共享数据库</a> + 锁</strong> 来保证同一触发点只跑一次：多个节点抢到锁的那个节点执行。</p>
<p>优点：能力强、模型成熟、可<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%25B7%25B1%25E5%25BA%25A6%25E5%25AE%259A%25E5%2588%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E6%B7%B1%E5%BA%A6%E5%AE%9A%E5%88%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">深度定制</a>。<br/>
短板：原生不带管理后台，<strong>集群配置/运维成本更高</strong>。</p>
<hr/>
<h3 data-id="heading-4">3）XXL-Job：开箱即用的分布式调度平台（偏“产品”）</h3>
<p>XXL-Job 更像“带后台的调度系统”：</p>
<ul>
<li>
<p>• Web 页面直接 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DCRUD%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=CRUD&amp;zhida_source=entity" ref="nofollow noopener noreferrer">CRUD</a> 任务，修改后<strong>即时生效</strong></p>
</li>
<li>
<p>• <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25B0%2583%25E5%25BA%25A6%25E4%25B8%25AD%25E5%25BF%2583%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E8%B0%83%E5%BA%A6%E4%B8%AD%E5%BF%83&amp;zhida_source=entity" ref="nofollow noopener noreferrer">调度中心</a>、执行器都支持集群 HA</p>
</li>
<li>
<p>• 支持分片广播、故障转移、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%259C%25A8%25E7%25BA%25BF%25E6%2597%25A5%25E5%25BF%2597%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%9C%A8%E7%BA%BF%E6%97%A5%E5%BF%97&amp;zhida_source=entity" ref="nofollow noopener noreferrer">在线日志</a>等</p>
</li>
<li>
<p>• 通过 DB 锁保证“一次调度只触发一次执行”</p>
</li>
</ul>
<p>优点：上手快、可视化强、分布式能力齐。<br/>
局限：任务模型/运行方式相对固定，<strong>超深度定制</strong>可能要读源码或二开。</p>
<hr/>
<h2 data-id="heading-5">核心<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25BB%25B4%25E5%25BA%25A6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E7%BB%B4%E5%BA%A6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">维度</a>对比（快速看懂版）</h2>









































<table><thead><tr><th>维度</th><th>@Scheduled</th><th>Quartz</th><th>XXL-Job</th></tr></thead><tbody><tr><td>依赖/引入成本</td><td>最低（Spring 内置）</td><td>中（引入框架 + 持久化/集群要配 DB）</td><td>中（调度中心 + 执行器）</td></tr><tr><td>可视化/运维</td><td>基本没有</td><td>原生没有（通常要自建）</td><td>自带 Web 管理后台</td></tr><tr><td>集群下“只跑一次”</td><td>不支持（需你自己加锁/选主）</td><td>支持（JDBC 集群 + DB 锁）</td><td>原生支持（DB 锁一致性）</td></tr><tr><td>动态修改规则</td><td>通常要发布/重启</td><td>支持 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DAPI%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=API&amp;zhida_source=entity" ref="nofollow noopener noreferrer">API</a> 动态改 Trigger</td><td>页面改完即时生效</td></tr><tr><td>适合场景</td><td>单机、小任务、快速实现</td><td>老系统/强定制/复杂触发需求</td><td>分布式、想省运维、团队人手不多</td></tr></tbody></table>
<hr/>
<h2 data-id="heading-6">常见“坑点”与避坑建议</h2>
<h3 data-id="heading-7">A. @Scheduled 的坑（最容易被忽略）</h3>
<ol>
<li>
<p>1. <strong>默认调度线程少，任务会互相堵</strong><br/>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3DSpring%2BBoot%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=Spring+Boot&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Spring Boot</a> 默认的调度器（ThreadPoolTaskScheduler）<strong>默认只有 1 个线程</strong>，一个任务跑久了，后面的定时任务可能排队等。<br/>
✅ 建议：显式配置 scheduling <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25BA%25BF%25E7%25A8%258B%25E6%25B1%25A0%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;zhida_source=entity" ref="nofollow noopener noreferrer">线程池</a>大小（至少让“慢任务”不拖死全局）。</p>
</li>
<li>
<p>2. <strong>fixedRate vs fixedDelay 用错，节奏就乱了</strong></p>
</li>
</ol>
<ul>
<li>
<p>• fixedRate：按“固定频率”触发（更像每隔 X 秒就开始一次）</p>
</li>
<li>
<p>• fixedDelay：按“上一次结束后再等 X 秒”<br/>
✅ 建议：想“准点”用 fixedRate/cron；想“串行且留间隔”用 fixedDelay。</p>
</li>
</ul>
<ol>
<li>3. <strong>集群重复执行</strong><br/>
多实例部署时，每台都会触发。<br/>
✅ 建议（择一）：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2594%2581%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&amp;zhida_source=entity" ref="nofollow noopener noreferrer">分布式锁</a>、Leader 选举、或把任务迁移到分布式调度平台。</li>
</ol>
<hr/>
<h3 data-id="heading-8">B. Quartz 的坑（集中在集群与稳定性）</h3>
<ol>
<li>
<p>1. <strong>集群必须用 JDBC JobStore + 共享 DB</strong><br/>
Quartz 的集群依赖共享数据库与<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E9%2594%2581%25E6%259C%25BA%25E5%2588%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E9%94%81%E6%9C%BA%E5%88%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">锁机制</a>；而且节点越多，锁竞争越明显，文档也提醒扩到很多节点性能会下降。<br/>
✅ 建议：Quartz 集群别盲目加节点，先评估调度密度与 DB 承载。</p>
</li>
<li>
<p>2. <strong>时间不同步会出大事</strong><br/>
官方明确提醒：集群机器时钟必须同步到“秒级”。<br/>
✅ 建议：NTP/chrony 做好<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E6%2597%25B6%25E9%2597%25B4%25E5%2590%258C%25E6%25AD%25A5%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5&amp;zhida_source=entity" ref="nofollow noopener noreferrer">时间同步</a>，别拿“差几秒没事”赌系统稳定。</p>
</li>
<li>
<p>3. <strong>Misfire（错过触发）没理解，任务可能“补跑/不跑”</strong><br/>
Quartz 文档解释：当持久化 Trigger 因为调度器关闭或线程不足等原因错过触发时间，就会发生 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3Dmisfire%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=misfire&amp;zhida_source=entity" ref="nofollow noopener noreferrer">misfire</a>，并按 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3Dmisfire%2B%25E7%25AD%2596%25E7%2595%25A5%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=misfire+%E7%AD%96%E7%95%A5&amp;zhida_source=entity" ref="nofollow noopener noreferrer">misfire 策略</a>处理。<br/>
✅ 建议：对关键任务明确配置 misfire 策略，别完全依赖默认“smart policy”。</p>
</li>
</ol>
<hr/>
<h3 data-id="heading-9">C. XXL-Job 的坑（集中在“平台化落地”）</h3>
<ol>
<li>
<p>1. <strong>调度中心/执行器尽量版本一致</strong><br/>
这是大量团队的真实经验：版本不一致时容易出现协议/字段不匹配等“玄学问题”。<br/>
✅ 建议：统一版本发布，至少保持同一大版本。</p>
</li>
<li>
<p>2. <strong>分片/路由策略选错，容易负载不均</strong><br/>
XXL-Job 支持“<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D2%26q%3D%25E5%2588%2586%25E7%2589%2587%25E5%25B9%25BF%25E6%2592%25AD%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=2&amp;q=%E5%88%86%E7%89%87%E5%B9%BF%E6%92%AD&amp;zhida_source=entity" ref="nofollow noopener noreferrer">分片广播</a>”“故障转移”等路由能力<br/>
✅ 建议：</p>
</li>
</ol>
<ul>
<li>
<p>• 大批量处理：优先分片广播 + 设计好分片参数</p>
</li>
<li>
<p>• 强可用：用故障转移，但要关注健康检查与超时</p>
</li>
</ul>
<ol>
<li>3. <strong>日志与数据留存</strong><br/>
它支持在线 Rolling 日志查看<br/>
✅ 建议：配好日志保留/归档策略，别让“<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270088628%26content_type%3DArticle%26match_order%3D1%26q%3D%25E4%25BB%25BB%25E5%258A%25A1%25E6%2597%25A5%25E5%25BF%2597%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270088628&amp;content_type=Article&amp;match_order=1&amp;q=%E4%BB%BB%E5%8A%A1%E6%97%A5%E5%BF%97&amp;zhida_source=entity" ref="nofollow noopener noreferrer">任务日志</a>”变成数据库/磁盘隐形炸弹。</li>
</ol>
<hr/>
<h2 data-id="heading-10">3 条“通用铁律”</h2>
<ol>
<li>
<p>1. <strong>任务幂等性</strong>：同一任务跑两次，也不能把钱扣两次/发两次券。</p>
</li>
<li>
<p>2. <strong>超时 + 告警</strong>：慢任务要能被发现、被终止或降级。</p>
</li>
<li>
<p>3. <strong>时间同步</strong>：尤其是集群调度，机器时间不准会让问题变得非常难排查。</p>
</li>
</ol></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[线程池用完不Shutdown，CPU和内存都快哭了]]></title>    <link>https://juejin.cn/post/7603771025856593971</link>    <guid>https://juejin.cn/post/7603771025856593971</guid>    <pubDate>2026-02-08T06:52:28.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856593971" data-draft-id="7603687444052115494" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="线程池用完不Shutdown，CPU和内存都快哭了"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T06:52:28.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java编程爱好者"/> <meta itemprop="url" content="https://juejin.cn/user/819554264300154"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            线程池用完不Shutdown，CPU和内存都快哭了
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/819554264300154/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java编程爱好者
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:52:28.000Z" title="Sun Feb 08 2026 06:52:28 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0"><strong>前言</strong></h2>
<p>大家平常使用<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3DSpringBoot%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=SpringBoot&amp;zhida_source=entity" ref="nofollow noopener noreferrer">SpringBoot</a>进行Web项目开发，<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25BA%25BF%25E7%25A8%258B%25E6%25B1%25A0%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E7%BA%BF%E7%A8%8B%E6%B1%A0&amp;zhida_source=entity" ref="nofollow noopener noreferrer">线程池</a>会被配置成为全局可复用的工具，生命周期随服务启动开始，到服务停止即结束。这种“<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25BA%25BF%25E7%25A8%258B%25E6%25B1%25A0%25E6%2589%2598%25E7%25AE%25A1%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%98%E7%AE%A1&amp;zhida_source=entity" ref="nofollow noopener noreferrer">线程池托管</a></strong>”模式，让多少兄弟产生美丽的错觉 ：“原来线程池会自己管理自己啊！”</p>
<p>但是，当需求经理对你露出神秘的微笑：“这个批量导出需求，今晚就要...”。你不得不撸起袖子，写下了罪恶的代码创建临时线程池，这时兄弟们，如果对线程池使用不当，很容易给服务埋下隐患 。</p>
<h2 data-id="heading-1"><strong>1 问题初现</strong></h2>
<h3 data-id="heading-2"><strong>1.1 示例代码</strong></h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/806758f53acb433f8ab961a2b8bb0b9b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=OtgSIADCBnLAOodNWffoPlxGgcg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-3"><strong>1.2 问题描述</strong></h3>
<p><strong>面试官：</strong> 不考虑任务内部的复杂度，这个线程池的使用会有问题吗？</p>
<p><strong>菜鸟：</strong> 方法执行完弹栈后，<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25B1%2580%25E9%2583%25A8%25E5%258F%2598%25E9%2587%258F%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F&amp;zhida_source=entity" ref="nofollow noopener noreferrer">局部变量</a>，都会被GC回收，谁写的代码，稳得很啊！</p>
<p><strong>老鸟：</strong> （一口咖啡喷屏幕上）老弟，你线程池用完不用shutdown呀？</p>
<p>===========</p>
<p><strong>再问：反正任务执行完，内存都会被GC回收，非得Shutdown一下不多余吗？</strong></p>
<p><strong>菜鸟：</strong> ......</p>
<p><strong>老鸟：</strong> （邪魅一笑）倒也不是必须Shutdown，但是不建议犯险尝试，请看VCR演示（代码演示）</p>
<h2 data-id="heading-4"><strong>2 走进科学实验现场（验证)</strong></h2>
<blockquote>
<p><strong>说明</strong>：本文讨论的线程池对象及相关源码，都围绕常用的java.util.concurrent.ThreadPoolExecutor类展开，下文不再额外说明</p>
</blockquote>
<h3 data-id="heading-5"><strong>2.2 装备说明（代码）</strong></h3>
<p>⚠️ <strong>警 告</strong> ：紧接着将出现大量源码解析，可能引起轻微不适。</p>
<blockquote>
<p><strong>说明</strong>：以下代码都是在一个类中，queue、phantomRef这两个对象是作为全局对象，专门捕捉那个"肉身已死但阴魂不散"的线程池对象。</p>
</blockquote>
<p><strong>2.2.1 幽灵探测仪（判断线程池对象是否被回收)</strong></p>
<p>因为验证的代码是在一个成熟的SpringBoot项目中跑的，线程池对象太多了，从内存分析工具上监测这单个线程池对象是否被GC回收不够直观，这里借助<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%2599%259A%25E5%25BC%2595%25E7%2594%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E8%99%9A%E5%BC%95%E7%94%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">虚引用</a>来判断线程池对象是否被回收。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9f97518c695f425baa555668a97daca8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=gnj34fOpOeQMhG8KSl92zgN09I4%3D" alt="" loading="lazy"/></p>
<p><strong>2.2.2 实验1：core 0，max 100 任务完成后，不进行shutdown</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/30f051d9361745848f80f80d62757217~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=dMDy%2BfzFkIAe7dHFz5K6NlfVsqw%3D" alt="" loading="lazy"/></p>
<p><strong>2.2.3 实验2：core 0，max 100 任务完成后，进行shutdown</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e649d955b88c4675a8c8bd8cf6664a22~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=R7YMvsK7ewcdISdDfl53zgmR7tk%3D" alt="" loading="lazy"/></p>
<p><strong>2.2.4 实验3：core 100，max 100 任务完成后，不进行shutdown</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cffac05c8a2412db8144327b6a211fe~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=5OTUMfaWOiIyOUzxsybVHiIq3R8%3D" alt="" loading="lazy"/></p>
<p><strong>2.2.5 实验4：core 100，max 100 任务完成后，进行shutdown</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d47b3a408210415d99446b513115148c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=OUlvqmV4Jf4HhebQKmGhDkbgUWw%3D" alt="" loading="lazy"/></p>
<p><strong>2.2.6 任务执行代码示例</strong></p>
<p><strong>解释说明：</strong></p>
<p>任务数量是110，主要是为了保证有足够多的任务让线程池所有线程能够打满；任务里面要sleep 500ms，也是同样的道理</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1925b9232ba541f5bd7893a55ef6c6cc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=bkyaOViCgHvth0dlCtgBz5wKAes%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-6"><strong>2.3 实验执行结果</strong></h3>
<p><strong>2.3.1 实验执行步骤</strong></p>
<p>项目启动后，依次执行上述4个实验。需要注意的是时间间隔要保证前一个实验的任务全部执行完，最好再留一些空挡，这样监控更清晰</p>
<p>每个实验执行完后，分别执行一次2.2.1 判断线程池对象是否回收</p>
<p><strong>2.3.2 结果分析</strong></p>
<p><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3DJVM%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=JVM&amp;zhida_source=entity" ref="nofollow noopener noreferrer">JVM</a>初始状态</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f9e895c3c92b4940aa3974e72e78c8bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=zVLitQZhDfgE0%2B4Ca67RSMYTxAs%3D" alt="" loading="lazy"/></p>
<p>1. <strong>实验1执行监控</strong></p>
<p>core 0，max 100 任务完成后，不进行shutdown</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3e22d687ea14a07a6290204a10f79b8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=59xOR3kyDR2654pQfDP8pIBVato%3D" alt="" loading="lazy"/></p>
<p>2. <strong>实验2执行监控</strong></p>
<p>core 0，max 100 任务完成后，进行shutdown</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2ab80c0e84b849c1a2e1f638bf5774cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=sHtcQ7AxzY7XE2bjpBrcBhkQyck%3D" alt="" loading="lazy"/></p>
<p>3. <strong>实验3执行监控</strong></p>
<p>core 100，max 100 任务完成后，不进行shutdown</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a077c5114484eaabb501e0c6b643d2f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=mjclYoEvREyRAYkg0AP%2FVSnETCc%3D" alt="" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e04985847703446488554e0594f42b7c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=UpPpi%2FGiXxv2Z%2B1vQGs%2BYKEcYPo%3D" alt="" loading="lazy"/></p>
<p>4. <strong>实验4执行监控</strong></p>
<p>core 100，max 100 任务完成后，进行shutdown</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1efdeab66fd74b0ca1a5bcfa439c1618~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=T1Kv%2F6vTF2BppYHQ6u%2FMnBfrsDg%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-7"><strong>3 原因解剖室</strong></h2>
<p><strong>接下来都是对实验3的异常现象进行的分析</strong></p>
<h3 data-id="heading-8"><strong>3.1 shutdown的五步拆解法</strong></h3>
<p>首先看下ThreadPoolExecutor#shutdown方法</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a785cda4800b48069a7dd793a0780e74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=z0AhwGEexSUCqel2IYFOlS%2BQmrk%3D" alt="" loading="lazy"/></p>
<p>截图中，可以看到shutdown方法里面，主要做了5个动作：</p>
<ol>
<li>
<p>根据方法名称可以看出是一个检查动作，这里不用细看</p>
</li>
<li>
<p>把线程池状态置为SHUTDOWN状态<strong>重要</strong></p>
</li>
<li>
<p>根据方法名称可以看出是将线程池中的空闲线程进行中断 <strong>重要</strong></p>
</li>
<li>
<p>根据注释来看，是给特定场景对象使用，这里不用细看</p>
</li>
<li>
<p>尝试终止线程池（<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E4%25B8%25AD%25E6%2596%25AD%25E7%25BA%25BF%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">中断线程</a>、关闭线程池）</p>
</li>
</ol>
<p>每一步的细节处理，这里就不带大家看了，有兴趣可以点开源码一步步研究下。<strong>总结下来就是，线程池执行shutdown方法后：</strong></p>
<ol>
<li>线程池对象置为SHUTDOWN状态——<strong>挂上“暂停营业”牌子</strong></li>
<li>将线程池中空闲线程置为中断状态，最终从线程池中剔除(会被GC回收)——<strong>给闲逛的线程发《<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25A7%25A3%25E8%2581%2598%25E9%2580%259A%25E7%259F%25A5%25E4%25B9%25A6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E8%A7%A3%E8%81%98%E9%80%9A%E7%9F%A5%E4%B9%A6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">解聘通知书</a>》</strong></li>
<li>线程池中的线程对象会置为中断状态，最终terminated</li>
</ol>
<h3 data-id="heading-9"><strong>3.2 为什么线程池不进行shutdown，在方法弹栈后不会立即被GC回收？</strong></h3>
<p>首先我们梳理一下当前执行实验的线程方法栈、线程池、线程池中的线程之间的引用关系图如下：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d695e9bf18f541aca26f75fb664d4160~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=IdG%2Fic3WXaYgjLk8rLjURYdfolo%3D" alt="" loading="lazy"/></p>
<p>实验3中，当主方法执行完弹栈后，短时间内，线程池中的线程对象仍处于<strong>空闲/活跃状态</strong>。但是线程池对象已经不被主线程对象中的方法栈持有，也就是<strong>图中关系1断开</strong>，按照JVM的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%259E%2583%25E5%259C%25BE%25E5%259B%259E%25E6%2594%25B6%25E6%259C%25BA%25E5%2588%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">垃圾回收机制</a>，这时，ThreadPoolExecutor对象已经不被GCRoot引用，是要被GC回收的，但是从2.3.2中的实验3执行监控来看，ThreadPoolExecutor对象并没有被GC回收。</p>
<p><strong>疑问：难道还有什么对象持有这个线程池对象的引用？</strong></p>
<p>首先，由于JVM的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25BF%2590%25E8%25A1%258C%25E6%259C%25BA%25E5%2588%25B6%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6&amp;zhida_source=entity" ref="nofollow noopener noreferrer">运行机制</a>，每一个java线程都关联一个<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3DOS%25E7%25BA%25BF%25E7%25A8%258B%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=OS%E7%BA%BF%E7%A8%8B&amp;zhida_source=entity" ref="nofollow noopener noreferrer">OS线程</a>，线程对象在terminated之前(线程任务执行完之前)，都不会被GC回收。</p>
<p>上面的引用关系实际上应该是下面这样的，线程池中的每个线程对象都有自己的执行方法栈对象</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b9bbb8eab3f5493e96cc2f66c55d7ebf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=8bi1EYjEZoIm%2BLLwF8fa10bKzzc%3D" alt="" loading="lazy"/></p>
<p>根据2.3.2中的几个执行结果监控，就能看出，线程池对象的回收与线程池中的工作线程是否被全部回收是有关系的，所以先预测线程池中的线程对象是持有线程池对象的引用的，然后基于这个预测，去源码中找理论支撑。</p>
<p><strong>预测存在黄色箭头依赖关系，如下图：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/34a8a758153d48679cf97849ab26af8f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=t804CVJMgGvj1PZTAyFSr5TV7FY%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-10"><strong>3.3 线程对象为何会持有线程池对象的引用？</strong></h3>
<p>其实，上面的引用关系图中，所有的正向依赖关系我们不难理解。需要验证的是反向的依赖关系r 2.x和r 3.x，这些反向的依赖关系都是什么时候建立的？可以从下面几个问题入手去排查：</p>
<ol>
<li>线程池(ThreadPoolExecutor)类结构中是否有相关对象的属性字段？</li>
<li>线程池对象中<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3DWorker%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=Worker&amp;zhida_source=entity" ref="nofollow noopener noreferrer">Worker</a>集合中Worker对象创建时机？</li>
<li>Worker对象创建时是如何建立相应的依赖关系的？</li>
</ol>
<p>从线程池提交任务开始，从源码中可以看到worker类结构中本身定义有Thread变量属性，在Worker对象创建时，就为Thread属性显式赋值：</p>
<p><strong>Worker类定义如下：</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99b021a6362a4febb662dd802655d71e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=EsbpifZlzr9gdBOhfy4OuZHl5XM%3D" alt="" loading="lazy"/></p>
<p><strong>Worker对象创建时机如下：</strong></p>
<p>从CompletableFuture工具任务执行方法中一步步进入源码，可以看到如下关系</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ac031ed60b9495a8d87bfdc92f2c5d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=PFF77Y7Yy8iC6NPQLPBcw8aLXE4%3D" alt="" loading="lazy"/></p>
<p>上面两段源码截图中，验证了<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E4%25BE%259D%25E8%25B5%2596%25E5%2585%25B3%25E7%25B3%25BB%25E5%259B%25BE%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%9B%BE&amp;zhida_source=entity" ref="nofollow noopener noreferrer">依赖关系图</a>中<strong>2.x，3.x</strong>与<strong>r 3.x</strong>的依赖关系，还剩下<strong>r 2.x</strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D8%26q%3D%25E4%25BE%259D%25E8%25B5%2596%25E5%2585%25B3%25E7%25B3%25BB%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=8&amp;q=%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB&amp;zhida_source=entity" ref="nofollow noopener noreferrer">依赖关系</a>没有得到验证。</p>
<p>首先，从Worker类结构上，没有找到Worker类中有定义对ThreadPoolExecutor类的显式引用，并且从2.3.2的实验执行结果图中可以看到，即使多次触发GC，依旧没有将ThreadPoolExecutor对象回收掉，所以，<strong>Worker-&gt;ThreadPoolExecutor肯定是一种<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%25BC%25BA%25E5%25BC%2595%25E7%2594%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E5%BC%BA%E5%BC%95%E7%94%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">强引用</a></strong>(4种引用关系：强引用、<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E8%25BD%25AF%25E5%25BC%2595%25E7%2594%25A8%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E8%BD%AF%E5%BC%95%E7%94%A8&amp;zhida_source=entity" ref="nofollow noopener noreferrer">软引用</a>、弱引用、虚引用)。</p>
<p>那么，哪些行为会让对象之间建立强引用关系呢？我们先问下AI助手，让它罗列出会建立引用关系的代码行为。总结归纳如下：</p>
<ol>
<li>对象中的属性字段显式赋值引用</li>
<li>数组、集合对象中添加其他对象的引用</li>
<li>子类通过面向对象的继承多态特性引用父类中的属性字段</li>
<li>还有一种平常关注较少的，相对隐式的引用关系——内部<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E7%25B1%25BB%25E5%25AF%25B9%25E8%25B1%25A1%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E7%B1%BB%E5%AF%B9%E8%B1%A1&amp;zhida_source=entity" ref="nofollow noopener noreferrer">类对象</a>引用外部类对象</li>
</ol>
<p>从Worker的类结构来看，是没有显示的对ThreadPoolExecutor的属性引用的，也没有相关的数据、集合，<strong>所以1,2不成立</strong>。Worker对象与ThreadPoolExecutor也没有直接或者间接的继承/实现关系，<strong>所以3也不成立。</strong></p>
<p>最后再看Worker类定义，确实是在ThreadPoolExecutor类的内部(内部类对象持有外部类对象的验证很简单，不在这里赘述)。这样Worker-&gt;ThreadPoolExecutor的引用关系就能说得通了。至此，<strong>引用依赖关系图中预测的r 2.x和r 3.x关系都成立了。</strong></p>
<h3 data-id="heading-11"><strong>3.4 原因逻辑梳理</strong></h3>
<p>再次把依赖关系图贴出来，一起再梳理一下</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1a9850d8c7974bec9dee423b57870d4b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=sbm8cYeSHSVSpfkNYIvETGToQgM%3D" alt="" loading="lazy"/></p>
<ol>
<li>当前方法main-Thread执行完，main-Thread的<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D4%26q%3D%25E6%2596%25B9%25E6%25B3%2595%25E6%25A0%2588%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=4&amp;q=%E6%96%B9%E6%B3%95%E6%A0%88&amp;zhida_source=entity" ref="nofollow noopener noreferrer">方法栈</a>都弹栈</li>
<li>依赖关系<strong>1</strong>断开，线程池不再被活跃线程引用，不会再有任务进来</li>
<li>当线程池任务都完成，此时线程池中的线程都处于休眠(wait)状态，等待任务队列中任务进来</li>
<li>由于线程池中的线程都处于存活状态，不会被回收</li>
<li>存在<strong>线程池线程_n</strong> <strong>-&gt; worker_n -&gt; 线程池</strong>的逆向引用关系</li>
<li>所以导致实验3中的现象——线程池和线程池中线程无法被GC回收</li>
</ol>
<h2 data-id="heading-12"><strong>4 线程池未shutdown的影响</strong></h2>
<p>这里再把实验3会导致系统的出现的问题总结一下。通过2.3.2中的实验3监控图以及源码，我们可以看到，线程池使用完，未及时进行shutdown，就最差的情况来说，会导致的问题：</p>
<ol>
<li>
<p>线程池对象无法被GC回收——<strong>内存泄露</strong></p>
</li>
<li>
<p>线程对象无法被GC回收——<strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhida.zhihu.com%2Fsearch%3Fcontent_id%3D270085144%26content_type%3DArticle%26match_order%3D1%26q%3D%25E5%2586%2585%25E5%25AD%2598%25E6%25B3%2584%25E6%25BC%258F%26zhida_source%3Dentity" target="_blank" title="https://zhida.zhihu.com/search?content_id=270085144&amp;content_type=Article&amp;match_order=1&amp;q=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F&amp;zhida_source=entity" ref="nofollow noopener noreferrer">内存泄漏</a></strong></p>
</li>
<li>
<p>从线程获取任务的源码来看，即使任务队列中是空的，只要线程池状态仍处于<strong>Running</strong>，线程会定时从wait状态苏醒，重新获取任务——<strong>占用CPU执行分片</strong></p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/295892aeb97a4c2fa7e3e8cf42023cc2~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2Yee8lueoi-eIseWlveiAhQ==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771138351&amp;x-signature=K1Nt2f65n29D%2F73Nk7ea5MFKDEI%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-13"><strong>血泪教训总结</strong></h2>
<ol>
<li><strong>线程池用完一定要养成shutdown的习惯：</strong> 因为有的没关好，真的会漏水(内存泄露)</li>
<li><strong>线程池创建线程命名，一定要有业务相关标识：</strong> 建议采用“业务场景+线程计数”法："<strong>订单导出-xx"、"邮件发送-xx"</strong> ，出问题时秒锁嫌疑人："就是订单导出线程在摸鱼！"</li>
<li><strong>内部类使用要谨慎：</strong> 谈恋爱可以，玩失踪不行，别让人家（GC）找不到你！</li>
</ol>
<h2 data-id="heading-14"><strong>文末彩蛋</strong></h2>
<p>以后，你在代码里看到随手创建的线程池，最终没有.shutdown()，请像看到有人上厕所不冲水一样，大喊：“同！学！你！线程池！忘！关！了！”</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[去到比北方更北的地方—2025年终总结]]></title>    <link>https://juejin.cn/post/7603769956975231017</link>    <guid>https://juejin.cn/post/7603769956975231017</guid>    <pubDate>2026-02-08T06:56:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603769956975231017" data-draft-id="7591389489411555369" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="去到比北方更北的地方—2025年终总结"/> <meta itemprop="keywords" content="前端,AI编程,年终总结"/> <meta itemprop="datePublished" content="2026-02-08T06:56:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="海石"/> <meta itemprop="url" content="https://juejin.cn/user/3747593580715102"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            去到比北方更北的地方—2025年终总结
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3747593580715102/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    海石
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:56:33.000Z" title="Sun Feb 08 2026 06:56:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:14px;overflow-x:hidden;color:var(--cyanosis-base-color);transition:color .35s;--cyanosis-base-color:#353535;--cyanosis-title-color:#005bb7;--cyanosis-strong-color:#2196f3;--cyanosis-em-color:#4fc3f7;--cyanosis-del-color:#ccc;--cyanosis-link-color:#3da8f5;--cyanosis-linkh-color:#007fff;--cyanosis-border-color:#bedcff;--cyanosis-border-color-2:#ececec;--cyanosis-bg-color:#fff;--cyanosis-blockquote-color:#8c8c8c;--cyanosis-blockquote-bg-color:#f0fdff;--cyanosis-code-color:#c2185b;--cyanosis-code-bg-color:#fff4f4;--cyanosis-code-pre-color:#f8f8f8;--cyanosis-table-border-color:#c3e0fd;--cyanosis-table-th-color:#dff0ff;--cyanosis-table-tht-color:#005bb7;--cyanosis-table-tr-nc-color:#f7fbff;--cyanosis-table-trh-color:#e0edf7;--cyanosis-slct-title-color:#005bb7;--cyanosis-slct-titlebg-color:rgba(175,207,247,0.25);--cyanosis-slct-text-color:#c80000;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#e8ebec;--cyanosis-slct-codebg-color:#ffeaeb;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body.__dark{--cyanosis-base-color:#cacaca;--cyanosis-title-color:#ddd;--cyanosis-strong-color:#fe9900;--cyanosis-em-color:#ffd28e;--cyanosis-del-color:#ccc;--cyanosis-link-color:#ffb648;--cyanosis-linkh-color:#fe9900;--cyanosis-border-color:#ffe3ba;--cyanosis-border-color-2:#ffcb7b;--cyanosis-bg-color:#2f2f2f;--cyanosis-blockquote-color:#c7c7c7;--cyanosis-blockquote-bg-color:rgba(255,199,116,0.1);--cyanosis-code-color:#000;--cyanosis-code-bg-color:#ffcb7b;--cyanosis-code-pre-color:rgba(255,227,185,0.5);--cyanosis-table-border-color:#fe9900;--cyanosis-table-th-color:#ffb648;--cyanosis-table-tht-color:#000;--cyanosis-table-tr-nc-color:#6d5736;--cyanosis-table-trh-color:#947443;--cyanosis-slct-title-color:#000;--cyanosis-slct-titlebg-color:#fe9900;--cyanosis-slct-text-color:#00c888;--cyanosis-slct-bg-color:rgba(175,207,247,0.25);--cyanosis-slct-del-color:#999;--cyanosis-slct-elbg-color:#000;--cyanosis-slct-codebg-color:#ffcb7b;--cyanosis-slct-prebg-color:rgba(160,200,255,0.25)}.markdown-body h1{padding-bottom:4px;font-size:30px}.markdown-body h1,.markdown-body h2{margin-top:36px;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);transition:color .35s}.markdown-body h2{position:relative;padding-left:10px;padding-right:10px;padding-bottom:10px;font-size:24px;border-bottom:1px solid var(--cyanosis-border-color-2)}.markdown-body h2:before{content:"「";position:absolute;top:-6px;left:-14px}.markdown-body h2:after{content:"」";position:relative;top:6px;right:auto}.markdown-body h3{position:relative;padding-bottom:0;margin-top:30px;margin-bottom:10px;font-size:20px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h3:before{content:"»";padding-right:6px;color:var(--cyanosis-strong-color)}.markdown-body h4{margin-top:24px;font-size:16px}.markdown-body h4,.markdown-body h5{padding-bottom:0;margin-bottom:10px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body h5{margin-top:18px;font-size:14px}.markdown-body h6{padding-bottom:0;margin-top:12px;margin-bottom:10px;font-size:12px;line-height:1.5;color:var(--cyanosis-title-color);padding-left:6px;transition:color .35s}.markdown-body p{line-height:inherit;margin-top:16px;margin-bottom:16px}.markdown-body img{max-width:100%}.markdown-body hr{position:relative;width:98%;height:1px;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,var(--cyanosis-link-color),rgba(255,0,0,.3),hsla(0,0%,100%,.1),rgba(255,0,0,.3),var(--cyanosis-link-color));border-width:0;overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background-color:var(--cyanosis-bg-color);background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center;transition:background-color .5s}.markdown-body code{padding:.065em .4em;font-size:.87em;color:var(--cyanosis-code-color);word-break:break-word;overflow-x:auto;background-color:var(--cyanosis-code-bg-color);border-radius:2px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{display:block;padding:16px 12px;margin:0;font-size:12px;color:#333;word-break:normal;overflow-x:auto;background:var(--cyanosis-code-pre-color)}.markdown-body pre&gt;code::-webkit-scrollbar{width:4px;height:4px}.markdown-body pre&gt;code::-webkit-scrollbar-track{background-color:var(--cyanosis-border-color)}.markdown-body pre&gt;code::-webkit-scrollbar-thumb{background-color:var(--cyanosis-strong-color);border-radius:10px}.markdown-body a{position:relative;text-decoration:none;color:var(--cyanosis-link-color);border-bottom:1px solid var(--cyanosis-border-color)}.markdown-body a:hover{border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body a:active,.markdown-body a:hover{color:var(--cyanosis-linkh-color)}.markdown-body a:after{position:absolute;content:"";top:100%;left:0;width:100%;opacity:0;border-bottom:1px solid var(--cyanosis-border-color);transition:top .3s,opacity .3s;transform:translateZ(0)}.markdown-body a:hover:after{top:0;opacity:1;border-bottom-color:var(--cyanosis-linkh-color)}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid var(--cyanosis-table-border-color);border-spacing:0;border-collapse:collapse}.markdown-body table thead{color:#000;text-align:left;font-size:14px;background:#f6f6f6}.markdown-body table tr:nth-child(2n){background-color:var(--cyanosis-table-tr-nc-color)}.markdown-body table tr:hover{background-color:var(--cyanosis-table-trh-color)}.markdown-body table td,.markdown-body table th{padding:12px 8px;line-height:24px;border:1px solid var(--cyanosis-table-border-color)}.markdown-body table th{color:var(--cyanosis-table-tht-color);background-color:var(--cyanosis-table-th-color)}.markdown-body table td{min-width:120px}.markdown-body blockquote{color:var(--cyanosis-blockquote-color);border-left:4px solid var(--cyanosis-strong-color);background-color:var(--cyanosis-blockquote-bg-color);padding:1px 20px;margin:22px 0;transition:color .35s}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body b,.markdown-body blockquote&gt;b,.markdown-body blockquote&gt;strong,.markdown-body strong{color:var(--cyanosis-strong-color)}.markdown-body em,.markdown-body i{color:var(--cyanosis-em-color)}.markdown-body del{color:var(--cyanosis-del-color)}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:4px}.markdown-body ol li{padding-left:6px}.markdown-body details&gt;summary{outline:none;color:var(--cyanosis-title-color);font-size:20px;font-weight:bolder;border-bottom:1px solid var(--cyanosis-border-color);cursor:pointer}.markdown-body details&gt;p{padding:10px 20px;margin:10px 0 0;color:#666;background-color:var(--cyanosis-blockquote-bg-color);border:2px dashed var(--cyanosis-strong-color)}.markdown-body h1::selection,.markdown-body h2::selection,.markdown-body h3::selection,.markdown-body h4::selection,.markdown-body h5::selection,.markdown-body h6::selection{color:var(--cyanosis-slct-title-color);background-color:var(--cyanosis-slct-titlebg-color)}.markdown-body ol li::selection,.markdown-body p::selection,.markdown-body ul li::selection{color:var(--cyanosis-slct-text-color);background-color:var(--cyanosis-slct-bg-color)}.markdown-body a::selection,.markdown-body b::selection,.markdown-body em::selection,.markdown-body i::selection,.markdown-body strong::selection{background-color:var(--cyanosis-slct-elbg-color)}.markdown-body del::selection{color:var(--cyanosis-slct-del-color);background-color:var(--cyanosis-slct-elbg-color)}.markdown-body table thead th::selection{background-color:transparent}.markdown-body table tbody td::selection{background-color:var(--cyanosis-slct-bg-color)}.markdown-body code::selection{background-color:var(--cyanosis-slct-codebg-color)}.markdown-body pre&gt;code::selection{background-color:var(--cyanosis-slct-prebg-color)}.markdown-body .contains-task-list{padding-left:14px;list-style:none}.markdown-body .contains-task-list input[type=checkbox]{position:relative}.markdown-body .contains-task-list input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;width:inherit;height:inherit;background:#f0f8ff;border:1px solid #add6ff;border-radius:2px;box-sizing:border-box;z-index:1}.markdown-body .contains-task-list input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-12px;left:0;right:0;bottom:0;width:0;height:0;color:#f55;font-size:20px;font-weight:700;z-index:2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="atom-one-dark">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#abb2bf;background:#282c34}.hljs-comment,.hljs-quote{color:#5c6370;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#c678dd}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#e06c75}.hljs-literal{color:#56b6c2}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#98c379}.hljs-built_in,.hljs-class .hljs-title{color:#e6c07b}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#d19a66}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#61aeee}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}</style><p><em>想写年终总结的心情，是在看到车窗外的雪之后，突然有的。</em></p>
<p>2025年的最后一天，我们坐上了从北京朝阳开往延吉西的高铁。</p>
<p>车厢内的暖气开得很足，我靠在椅背上，觉得码字是打发这6小时车程再好不过的事。</p>
<p>古典主义认为灵感是神的旨意，于是我便开始等待，等待着神对我下达祂的旨意。</p>
<p>没等多久我就发现了比码字还要好的事情，那就是睡觉。</p>
<p>于是这一篇在离开北京时就想写的文章，最终还是在我回北京之后，才被写出来。</p>
<hr/>
<h2 data-id="heading-0">时代的关键词</h2>
<blockquote>
<p>如果让大家用一个词语形容2025年，大家会选择什么词语呢？</p>
</blockquote>
<p>我选的词语是“AI”</p>
<p>从chatGPT一鸣惊人的“AI元年”来算，这波浪潮已经汹涌了3年。</p>
<p>大家都说要拥抱变化，拥抱变化 。</p>
<p>个人感觉变化已经不够形容了</p>
<p>这是 <strong>冲击</strong></p>
<p>以<code>Cursor</code>为首的AI IDE工具正在冲击我们这个职业</p>
<p>技术社区的博客里涌现出越来越多的名词，LLM、Agent、MCP、CSR、Rules、Skills、AGUI、A2UI、A2A等等</p>
<p>集团在年初邀请梁宁做了一次分享，我当时没来得及去线下，后来用几个午休的时间，断断续续看完了录播回放</p>
<p>在视频播放完毕，进度条已经重置的时候，脑海里还是存在着她频频提到的6个字</p>
<p><em>“时代的关键词”</em></p>
<ul>
<li>
<p>蒸汽时代的关键词是效率不对称</p>
</li>
<li>
<p>互联网时代的关键词是信息不对称</p>
</li>
<li>
<p>AI时代的关键词是经验不对称</p>
</li>
</ul>
<p>从梁宁的视角看互联网时代，对我来说是很新奇的体验：</p>
<p>“互联网解决的是什么问题，解决的就是信息不对称这个问题</p>
<p>所以我们有时候也会用‘信息时代’来称呼‘互联网时代’</p>
<p>那么什么是‘信息’？</p>
<p>我们在网上看到的图片也好，视频也好，文字也好，认为自己看到了一个商品也好、人物也好。</p>
<p>我们在互联网上看到的一切，都是信息。</p>
<p>再书面化一些，引用《信息系统项目管理师教程》这本书里对于信息的定义</p>
<blockquote>
<p>信息是物质、能量及其属性的标示的集合</p>
</blockquote>
<p>谈到互联网时代，谈到互联网，肯定绕不开BAT，</p>
<p>为什么BAT会产生、会崛起？</p>
<p>先说B，百度是搜索引擎，他天然收割了web上的所有信息</p>
<p>互联网解决的是信息不对称的问题，搜索引擎又天然站在了这种生态位的顶端，他能拿到全量的信息，作为收割者</p>
<p>因此这也是为什么最初B是BAT之首的原因。</p>
<p>再说T，腾讯的核心信息是什么？是人，</p>
<blockquote>
<p>“人是一切社会关系的总和” —马克思</p>
</blockquote>
<p>在互联网如何用信息表达一个人？</p>
<p>id和关系链</p>
<p>没人能撼动他的核心，碰他的人</p>
<p>而且他跳脱在了百度的收割之外</p>
<p>因为他是客户端</p>
<p>最后来说说A，阿里</p>
<p>为什么百度也收割不了阿里？</p>
<p>最早的时候淘宝主动屏蔽百度的搜索，淘宝通过构建自己的商品信息生态，他自己打造的信息当然是他自己内部收割，因此百度收割不了他的信息</p>
<p>人的信息、交易的信息、其他的信息（比如携程）构成了信息的全部</p>
<p>现在则是每个企业都在构建自己的信息生态，携程是酒旅，京东是供应链</p>
<p>而到了移动互联网时代，</p>
<p>小红书、抖音又有自己的信息生态”</p>
<p>那么AI时代的经验不对称又该从何说起？</p>
<p>如何区分“知识”和“经验”？</p>
<p>我很好奇梁宁又会怎么看待现在的时代，在《真需求》这本书写完后，外边的世界发生了天翻地覆的变化…</p>
<h2 data-id="heading-1">与其感慨路难行，不如马上出发</h2>
<p>打完这个标题，我抬头看了一眼电脑旁的饮料，写文字的时候需要喝点小甜水，这是我两年前养成的习惯</p>
<p>后来我发现很多作家也有这样的习惯，王小波需要一直喝茶、吸烟，来让自己保持一个亢奋的状态，用于写作</p>
<ul>
<li>
<p>2024年，我写了将近20万字，输出了34篇技术博客，掘金的热榜挤进去过几次，还“混“上过第一，至于喝掉了的饮料数...大概也能在余杭区拔得头筹吧😄</p>
</li>
<li>
<p>2025年，我只在掘金发了3篇文章，正文加起来估计1万字左右</p>
</li>
</ul>
<p>同比<strong>下降2000%</strong>，我还想不想在掘金混了？</p>
<p>非也非也，倒不是我也感慨路难行了所以不去行了，而是转战场了，主要的技术沉淀与分享都在公司内部社区。</p>
<p>本来这一章节是想顺着这个标题做一些技术写作的心得分享，但是随着OpenClaw的出现，我对技术写作产生了完全不同于以往的想法</p>
<ul>
<li>
<p>就像OpenClaw出现之后，程序员应该去写让大模型更方便阅读和理解的cli层面的东西一样。</p>
</li>
<li>
<p>以后所谓的技术博客，是不是也就是写成让大模型更能读懂、最佳读懂代码的提示词而已</p>
</li>
</ul>
<p>形态上的变化</p>
<p>比如我写一篇源码分析，代码层面的查看基本就是靠大模型通过csr去全面解读，然后我再基于个人经验和理解完成汇总，顺便补上知识点的官方文档出处，确保不会误人子弟、减少大模型的幻觉</p>
<p>但是其实很多时候也没必要花力气打开博客论坛去看别人的这种文章</p>
<p>作为开发者我期望我能在AI IDE里完成一切，我希望它在代码解读时是站在高质量技术博主的视角上的。</p>
<p>很多时候同一个知识点，不同水平的人看到的门道是不一样的。</p>
<p>说个八股文，js的闭包是千人千面，各种说法都有，</p>
<p>背后的根因我想就是每个人的理解有深有浅。</p>
<p>大家用了这么久的技术论坛，应该看过不少技术大佬、技术团队的文章</p>
<p>有些技术大佬看问题的角度特别刁钻、特别深入，看完往往会让人拍大腿，原来还能这么理解吗？</p>
<p>有些技术团队看问题直抓本质，解决方案一出就是最佳实践</p>
<p>如果大模型能够具备和这些技术大佬、技术团队一样对问题/现象/知识点 的思考与解读能力</p>
<p>我们是否还有必要访问技术论坛、关注这些技术大佬、技术团队呢？</p>
<p>或许，在未来，技术博客只有帮助作者本人沉淀知识、掌握知识这一个作用了？</p>
<p>（费曼学习法：教授他人，对学习的吸收率是90%）</p>
<h2 data-id="heading-2">“前端已死”</h2>
<ul>
<li>
<p>Claude模型更新了，甩开别的一大截，前端已死</p>
</li>
<li>
<p>GPT 5更新了，CodeMax模式，甩开别的一大截，前端已死</p>
</li>
<li>
<p>Gemini更新了，甩开别的一大截，前端已死</p>
</li>
</ul>
<p>前端又双叒叕死了😭</p>
<p>Vibe Coding确实给我们这个行业带来了巨大的影响</p>
<p>skills出来前，依托mcp和rules，再加上规约编程，大模型就能写出很不错的、符合研发规范的代码了</p>
<p>再加上一些d2c的工具，从0到1的需求开发，效率确实得到了显著的提升</p>
<p>但是目前的模式对于增量开发（基于工程现有功能完成需求迭代）的提效其实没那么显著</p>
<p>再者，对于程序员来说，写代码需要的时间很多时候并不是大头，更多时间被花在了prd评审，上下游对齐，协作沟通，开会等非编码性质的事上</p>
<p>我们可能不应该再继续想着提升5个流程节点中某个节点的几个子节点的效率</p>
<p>（比如研发节点中的设计稿还原、code reciew这些子节点）</p>
<p>而是能不能把5个流程节点直接砍成3个，这种层面的提效</p>
<p>Vibe Coding什么时候可以不仅仅是Coding？</p>
<h2 data-id="heading-3">去到比北方更北的地方</h2>
<p>前端不仅仅只是前端</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring Boot 4 升级指南：告别RestTemplate，拥抱现代HTTP客户端]]></title>    <link>https://juejin.cn/post/7603651855236808713</link>    <guid>https://juejin.cn/post/7603651855236808713</guid>    <pubDate>2026-02-08T06:12:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603651855236808713" data-draft-id="7603687444052033574" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring Boot 4 升级指南：告别RestTemplate，拥抱现代HTTP客户端"/> <meta itemprop="keywords" content="后端,Spring Boot"/> <meta itemprop="datePublished" content="2026-02-08T06:12:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java水解"/> <meta itemprop="url" content="https://juejin.cn/user/2441349519143037"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring Boot 4 升级指南：告别RestTemplate，拥抱现代HTTP客户端
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2441349519143037/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java水解
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:12:38.000Z" title="Sun Feb 08 2026 06:12:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Spring Boot 4 升级指南：告别RestTemplate，拥抱现代[HTTP客户端]</h2>
<h3 data-id="heading-1"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>引言</h3>
<p>随着Spring Boot 4.0的发布，我们正式告别了一个时代——RestTemplate这个伴随Java开发者十余年的[HTTP客户端工具]正式进入弃用阶段。在Spring Boot 4.0中，Spring官方强烈建议迁移到更现代、更强大的HTTP客户端解决方案。</p>
<p>本文将详细介绍在Spring Boot 4.0环境中如何替换RestTemplate，以及推荐的新一代HTTP客户端解决方案。</p>
<h3 data-id="heading-2"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>背景：为什么RestTemplate不再推荐？</h3>
<h4 data-id="heading-3"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1. 技术演进</h4>
<ul>
<li><strong>Spring Framework 5+</strong> ：从Spring Framework 5开始，RestTemplate已被标记为弃用</li>
<li><strong>响应式编程趋势</strong>：现代应用需要异步非阻塞的HTTP调用能力</li>
<li><strong>性能优化</strong>：新的HTTP客户端提供更好的性能和资源利用率</li>
</ul>
<h4 data-id="heading-4"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2. Spring Boot 4.0的变化</h4>
<p>Spring Boot 4.0对HTTP客户端进行了重大调整：</p>
<ul>
<li>RestTemplate进入完全弃用状态</li>
<li>推荐使用WebClient（响应式）或RestClient（同步）</li>
<li>移除了对传统HTTP客户端的内置支持</li>
</ul>
<h3 data-id="heading-5"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>推荐的替代方案</h3>
<h4 data-id="heading-6"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>方案一：WebClient（推荐用于异步场景）</h4>
<p>WebClient是Spring WebFlux项目的一部分，提供响应式、非阻塞的HTTP客户端功能。</p>
<h5 data-id="heading-7"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>依赖配置</h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- Maven配置 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

AI写代码xml
12345
</code></pre>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// Gradle配置</span>
implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-webflux'</span>

AI写代码gradle
<span class="hljs-number">12</span>
</code></pre>
<h5 data-id="heading-8"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>基本使用示例</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">import</span> org.springframework.web.reactive.function.client.WebClient;
<span class="hljs-keyword">import</span> reactor.core.publisher.Mono;

<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientService</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;
    
    <span class="hljs-keyword">public</span> HttpClientService() {
        <span class="hljs-keyword">this</span>.webClient = WebClient.builder()
                .baseUrl(<span class="hljs-string">"https://api.example.com"</span>)
                .defaultHeader(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>)
                .build();
    }
    
    <span class="hljs-comment">// GET请求</span>
    <span class="hljs-keyword">public</span> Mono&lt;String&gt; getData(String id) {
        <span class="hljs-keyword">return</span> webClient
                .<span class="hljs-keyword">get</span>()
                .uri(<span class="hljs-string">"/data/{id}"</span>, id)
                .retrieve()
                .bodyToMono(String.<span class="hljs-keyword">class</span>);
    }
    
    <span class="hljs-comment">// POST请求</span>
    <span class="hljs-keyword">public</span> Mono&lt;User&gt; createUser(User user) {
        <span class="hljs-keyword">return</span> webClient
                .post()
                .uri(<span class="hljs-string">"/users"</span>)
                .bodyValue(user)
                .retrieve()
                .bodyToMono(User.<span class="hljs-keyword">class</span>);
    }
    
    <span class="hljs-comment">// 响应式链式调用</span>
    <span class="hljs-keyword">public</span> Mono&lt;Result&gt; complexWorkflow(String id) {
        <span class="hljs-keyword">return</span> webClient
                .<span class="hljs-keyword">get</span>()
                .uri(<span class="hljs-string">"/data/{id}"</span>, id)
                .retrieve()
                .bodyToMono(Data.<span class="hljs-keyword">class</span>)
                .flatMap(<span class="hljs-keyword">data</span> -&gt; webClient
                        .post()
                        .uri(<span class="hljs-string">"/process"</span>)
                        .bodyValue(<span class="hljs-keyword">data</span>)
                        .retrieve()
                        .bodyToMono(Result.<span class="hljs-keyword">class</span>));
    }
}

AI写代码java
运行
<span class="hljs-number">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849</span>
</code></pre>
<h5 data-id="heading-9"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>WebClient的优势</h5>
<ol>
<li><strong>异步非阻塞</strong>：支持响应式编程模式</li>
<li><strong>背压支持</strong>：内置背压处理机制</li>
<li><strong>流式处理</strong>：支持服务器端推送和流式数据</li>
<li><strong>函数式API</strong>：提供链式调用的函数式API</li>
<li><strong>更好的错误处理</strong>：支持错误恢复和重试机制</li>
</ol>
<h4 data-id="heading-10"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>方案二：RestClient（推荐用于同步场景）</h4>
<p>Spring 6.1引入的RestClient提供了现代化的同步HTTP客户端API。</p>
<h5 data-id="heading-11"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>依赖配置</h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- Maven配置 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

AI写代码xml
12345
</code></pre>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// Gradle配置</span>
implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span>

AI写代码gradle
<span class="hljs-number">12</span>
</code></pre>
<h5 data-id="heading-12"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>基本使用示例</h5>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">import</span> org.springframework.web.client.RestClient;
<span class="hljs-keyword">import</span> org.springframework.core.ParameterizedTypeReference;

@Service
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncHttpClientService</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestClient restClient;
    
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SyncHttpClientService</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.restClient = RestClient.<span class="hljs-built_in">builder</span>()
                .<span class="hljs-built_in">baseUrl</span>(<span class="hljs-string">"https://api.example.com"</span>)
                .<span class="hljs-built_in">defaultHeader</span>(<span class="hljs-string">"Content-Type"</span>, <span class="hljs-string">"application/json"</span>)
                .<span class="hljs-built_in">build</span>();
    }
    
    <span class="hljs-comment">// GET请求</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-type">String</span> id)</span> </span>{
        <span class="hljs-keyword">return</span> restClient
                .<span class="hljs-built_in">get</span>()
                .<span class="hljs-built_in">uri</span>(<span class="hljs-string">"/users/{id}"</span>, id)
                .<span class="hljs-built_in">retrieve</span>()
                .<span class="hljs-built_in">body</span>(User.<span class="hljs-keyword">class</span>);
    }
    
    <span class="hljs-comment">// POST请求</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">createUser</span><span class="hljs-params">(User user)</span> </span>{
        <span class="hljs-keyword">return</span> restClient
                .<span class="hljs-built_in">post</span>()
                .<span class="hljs-built_in">uri</span>(<span class="hljs-string">"/users"</span>)
                .<span class="hljs-built_in">body</span>(user)
                .<span class="hljs-built_in">retrieve</span>()
                .<span class="hljs-built_in">body</span>(User.<span class="hljs-keyword">class</span>);
    }
    
    <span class="hljs-comment">// 复杂查询参数</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">searchUsers</span><span class="hljs-params">(<span class="hljs-type">String</span> name, <span class="hljs-type">int</span> page, <span class="hljs-type">int</span> size)</span> </span>{
        <span class="hljs-keyword">return</span> restClient
                .<span class="hljs-built_in">get</span>()
                .<span class="hljs-built_in">uri</span>(uriBuilder -&gt; uriBuilder
                        .<span class="hljs-built_in">path</span>(<span class="hljs-string">"/users/search"</span>)
                        .<span class="hljs-built_in">queryParam</span>(<span class="hljs-string">"name"</span>, name)
                        .<span class="hljs-built_in">queryParam</span>(<span class="hljs-string">"page"</span>, page)
                        .<span class="hljs-built_in">queryParam</span>(<span class="hljs-string">"size"</span>, size)
                        .<span class="hljs-built_in">build</span>())
                .<span class="hljs-built_in">retrieve</span>()
                .<span class="hljs-built_in">body</span>(<span class="hljs-keyword">new</span> ParameterizedTypeReference&lt;List&lt;User&gt;&gt;() {});
    }
    
    <span class="hljs-comment">// 错误处理</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUserWithErrorHandling</span><span class="hljs-params">(<span class="hljs-type">String</span> id)</span> </span>{
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">return</span> restClient
                    .<span class="hljs-built_in">get</span>()
                    .<span class="hljs-built_in">uri</span>(<span class="hljs-string">"/users/{id}"</span>, id)
                    .<span class="hljs-built_in">retrieve</span>()
                    .<span class="hljs-built_in">body</span>(User.<span class="hljs-keyword">class</span>);
        } <span class="hljs-built_in">catch</span> (RestClientException e) {
            <span class="hljs-comment">// 处理错误</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">UserServiceException</span>(<span class="hljs-string">"Failed to fetch user"</span>, e);
        }
    }
}

AI写代码java
运行
<span class="hljs-number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162</span>
</code></pre>
<h3 data-id="heading-13"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>迁移策略</h3>
<h4 data-id="heading-14"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>阶段一：评估现有代码</h4>
<ol>
<li><strong>识别RestTemplate使用点</strong></li>
</ol>
<pre><code class="hljs language-perl" lang="perl"><span class="hljs-comment"># 搜索项目中所有RestTemplate的使用</span>
<span class="hljs-keyword">grep</span> -r <span class="hljs-string">"RestTemplate"</span> src/

AI写代码bash
<span class="hljs-number">12</span>
</code></pre>
<ol start="2">
<li>
<p><strong>分类使用场景</strong></p>
<ul>
<li>同步调用 → RestClient</li>
<li>异步调用 → WebClient</li>
<li>批处理 → RestClient</li>
<li>流式处理 → WebClient</li>
</ul>
</li>
</ol>
<h4 data-id="heading-15"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>阶段二：渐进式迁移</h4>
<h5 data-id="heading-16"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>步骤1：添加新依赖</h5>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- 根据需要添加 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

AI写代码xml
12345
</code></pre>
<h5 data-id="heading-17"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>步骤2：创建适配器</h5>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientConfig</span> {
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-meta">@Primary</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">RestClient</span> <span class="hljs-title function_">restClient</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">RestClient</span>.<span class="hljs-title function_">builder</span>()
                .<span class="hljs-title function_">baseUrl</span>(<span class="hljs-string">"https://api.example.com"</span>)
                .<span class="hljs-title function_">build</span>();
    }
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">WebClient</span> <span class="hljs-title function_">webClient</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">WebClient</span>.<span class="hljs-title function_">builder</span>()
                .<span class="hljs-title function_">baseUrl</span>(<span class="hljs-string">"https://api.example.com"</span>)
                .<span class="hljs-title function_">build</span>();
    }
}

<span class="hljs-variable constant_">AI</span>写代码java
运行
<span class="hljs-number">123456789101112131415161718</span>
</code></pre>
<h5 data-id="heading-18"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>步骤3：逐个替换</h5>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 旧代码</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestTemplate restTemplate = new RestTemplate();
    
    <span class="hljs-keyword">public</span> User getUser(String id) {
        <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">"/users/{id}"</span>, User.<span class="hljs-keyword">class</span>, id);
    }
}

<span class="hljs-comment">// 新代码</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestClient restClient;
    
    <span class="hljs-keyword">public</span> UserService(RestClient restClient) {
        <span class="hljs-keyword">this</span>.restClient = restClient;
    }
    
    <span class="hljs-keyword">public</span> User getUser(String id) {
        <span class="hljs-keyword">return</span> restClient
                .<span class="hljs-keyword">get</span>()
                .uri(<span class="hljs-string">"/users/{id}"</span>, id)
                .retrieve()
                .body(User.<span class="hljs-keyword">class</span>);
    }
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021222324252627</span>
</code></pre>
<h3 data-id="heading-19"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>高级特性对比</h3>





















































<table><thead><tr><th>特性</th><th>RestTemplate</th><th>RestClient</th><th>WebClient</th></tr></thead><tbody><tr><td>同步调用</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>异步调用</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>响应式支持</td><td>❌</td><td>❌</td><td>✅</td></tr><tr><td>连接池</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>拦截器支持</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>错误处理</td><td>基础</td><td>改进</td><td>高级</td></tr><tr><td>性能</td><td>基础</td><td>良好</td><td>优秀</td></tr></tbody></table>
<h3 data-id="heading-20"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>最佳实践</h3>
<h4 data-id="heading-21"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1. 选择合适的客户端</h4>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-comment">// 同步场景使用RestClient</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestClient restClient;
    
    <span class="hljs-keyword">public</span> SyncService(RestClient restClient) {
        <span class="hljs-keyword">this</span>.restClient = restClient;
    }
}

<span class="hljs-comment">// 异步场景使用WebClient</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncService</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;
    
    <span class="hljs-keyword">public</span> AsyncService(WebClient webClient) {
        <span class="hljs-keyword">this</span>.webClient = webClient;
    }
}

AI写代码java
运行
<span class="hljs-number">12345678910111213141516171819</span>
</code></pre>
<h4 data-id="heading-22"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2. 配置优化</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Configuration</span>
public class HttpClientConfig {
    
    <span class="hljs-keyword">@Bean</span>
    public RestClient optimizedRestClient() {
        return RestClient<span class="hljs-selector-class">.builder</span>()
                <span class="hljs-selector-class">.requestFactory</span>(HttpComponentsClientHttpRequestFactory.class)
                <span class="hljs-selector-class">.baseUrl</span>("https://api.example.com")
                <span class="hljs-selector-class">.defaultHeader</span>("User-Agent", "MyApp/<span class="hljs-number">1.0</span>")
                <span class="hljs-selector-class">.defaultHeader</span>("Accept", "application/json")
                <span class="hljs-selector-class">.build</span>();
    }
    
    <span class="hljs-keyword">@Bean</span>
    public WebClient optimizedWebClient() {
        HttpClient httpClient = HttpClient<span class="hljs-selector-class">.create</span>()
                <span class="hljs-selector-class">.responseTimeout</span>(Duration.ofSeconds(<span class="hljs-number">10</span>))
                <span class="hljs-selector-class">.option</span>(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);
        
        return WebClient<span class="hljs-selector-class">.builder</span>()
                <span class="hljs-selector-class">.clientConnector</span>(new ReactorClientHttpConnector(httpClient))
                <span class="hljs-selector-class">.baseUrl</span>("https://api.example.com")
                <span class="hljs-selector-class">.filter</span>(logRequest())
                <span class="hljs-selector-class">.filter</span>(logResponse())
                <span class="hljs-selector-class">.build</span>();
    }
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021222324252627</span>
</code></pre>
<h4 data-id="heading-23"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3. 错误处理</h4>
<pre><code class="hljs language-vbscript" lang="vbscript">// RestClient错误处理
<span class="hljs-keyword">public</span> User getUserSafely(String id) {
    return restClient
            .<span class="hljs-keyword">get</span>()
            .uri(<span class="hljs-string">"/users/{id}"</span>, id)
            .retrieve()
            .onStatus(HttpStatus::is5xxServerError, 
                     <span class="hljs-built_in">response</span> -&gt; Mono.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">new</span> ServerException(<span class="hljs-string">"Server error"</span>)))
            .onStatus(HttpStatus::is4xxClientError,
                     <span class="hljs-built_in">response</span> -&gt; <span class="hljs-built_in">response</span>.bodyToMono(ErrorResponse.<span class="hljs-keyword">class</span>)
                         .flatMap(<span class="hljs-keyword">error</span> -&gt; Mono.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">new</span> ClientException(<span class="hljs-keyword">error</span>))))
            .body(User.<span class="hljs-keyword">class</span>);
}

// WebClient错误处理
<span class="hljs-keyword">public</span> Mono&lt;User&gt; getUserReactive(String id) {
    return webClient
            .<span class="hljs-keyword">get</span>()
            .uri(<span class="hljs-string">"/users/{id}"</span>, id)
            .retrieve()
            .onStatus(HttpStatus::is5xxServerError,
                     <span class="hljs-built_in">response</span> -&gt; <span class="hljs-built_in">response</span>.bodyToMono(ErrorResponse.<span class="hljs-keyword">class</span>)
                         .flatMap(<span class="hljs-keyword">error</span> -&gt; Mono.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">new</span> ServerException(<span class="hljs-keyword">error</span>))))
            .onStatus(HttpStatus::is4xxClientError,
                     <span class="hljs-built_in">response</span> -&gt; <span class="hljs-built_in">response</span>.bodyToMono(ErrorResponse.<span class="hljs-keyword">class</span>)
                         .flatMap(<span class="hljs-keyword">error</span> -&gt; Mono.<span class="hljs-keyword">error</span>(<span class="hljs-keyword">new</span> ClientException(<span class="hljs-keyword">error</span>))))
            .bodyToMono(User.<span class="hljs-keyword">class</span>)
            .retryWhen(retrySpec())
            .onErrorResume(Exception.<span class="hljs-keyword">class</span>, 
                          <span class="hljs-keyword">error</span> -&gt; Mono.just(getDefaultUser()));
}

AI写代码java
运行
<span class="hljs-number">12345678910111213141516171819202122232425262728293031</span>
</code></pre>
<h3 data-id="heading-24"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>测试策略</h3>
<h4 data-id="heading-25"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>单元测试</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@ExtendWith</span>(MockitoExtension.class)
class UserServiceTest {
    
    <span class="hljs-keyword">@Mock</span>
    private RestClient restClient;
    
    <span class="hljs-keyword">@InjectMocks</span>
    private UserService userService;
    
    <span class="hljs-keyword">@Test</span>
    void shouldGetUserById() {
        <span class="hljs-comment">// Given</span>
        String userId = "<span class="hljs-number">123</span>";
        User expectedUser = new <span class="hljs-built_in">User</span>(userId, "John Doe");
        
        RestClient<span class="hljs-selector-class">.RequestHeadersUriSpec</span> requestSpec = Mockito<span class="hljs-selector-class">.mock</span>(RestClient.RequestHeadersUriSpec.class);
        RestClient<span class="hljs-selector-class">.ResponseSpec</span> responseSpec = Mockito<span class="hljs-selector-class">.mock</span>(RestClient.ResponseSpec.class);
        
        <span class="hljs-built_in">when</span>(restClient.get())<span class="hljs-selector-class">.thenReturn</span>(requestSpec);
        <span class="hljs-built_in">when</span>(requestSpec.uri("/users/{id}", userId))<span class="hljs-selector-class">.thenReturn</span>(requestSpec);
        <span class="hljs-built_in">when</span>(requestSpec.retrieve())<span class="hljs-selector-class">.thenReturn</span>(responseSpec);
        <span class="hljs-built_in">when</span>(responseSpec.body(User.class))<span class="hljs-selector-class">.thenReturn</span>(expectedUser);
        
        <span class="hljs-comment">// When</span>
        User actualUser = userService<span class="hljs-selector-class">.getUser</span>(userId);
        
        <span class="hljs-comment">// Then</span>
        <span class="hljs-built_in">assertEquals</span>(expectedUser, actualUser);
    }
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021222324252627282930</span>
</code></pre>
<h4 data-id="heading-26"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>集成测试</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientIntegrationTest</span> {
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> TestRestTemplate testRestTemplate;
    
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserService userService;
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shouldCommunicateWithExternalService</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 使用真实的HTTP调用测试</span>
        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUser(<span class="hljs-string">"123"</span>);
        assertNotNull(user);
    }
}

AI写代码java
运行
<span class="hljs-number">12345678910111213141516</span>
</code></pre>
<h3 data-id="heading-27"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>性能考虑</h3>
<h4 data-id="heading-28"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1. 连接池配置</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Configuration</span>
public class ConnectionPoolConfig {
    
    <span class="hljs-keyword">@Bean</span>
    public RestClient customRestClient() {
        SimpleClientHttpRequestFactory factory = new <span class="hljs-built_in">SimpleClientHttpRequestFactory</span>();
        factory<span class="hljs-selector-class">.setConnectTimeout</span>(<span class="hljs-number">5000</span>);
        factory<span class="hljs-selector-class">.setReadTimeout</span>(<span class="hljs-number">30000</span>);
        
        return RestClient<span class="hljs-selector-class">.builder</span>()
                <span class="hljs-selector-class">.requestFactory</span>(factory)
                <span class="hljs-selector-class">.baseUrl</span>("https://api.example.com")
                <span class="hljs-selector-class">.build</span>();
    }
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415</span>
</code></pre>
<h4 data-id="heading-29"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2. WebClient连接池</h4>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-keyword">@Bean</span>
public WebClient webClientWithPool() {
    HttpClient httpClient = HttpClient<span class="hljs-selector-class">.create</span>()
            <span class="hljs-selector-class">.option</span>(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>)
            <span class="hljs-selector-class">.responseTimeout</span>(Duration.ofSeconds(<span class="hljs-number">30</span>))
            <span class="hljs-selector-class">.doOnConnected</span>(conn -&gt; 
                conn.addHandlerLast(new ReadTimeoutHandler(<span class="hljs-number">30</span>))
                    <span class="hljs-selector-class">.addHandlerLast</span>(new WriteTimeoutHandler(<span class="hljs-number">30</span>)));
    
    ConnectionProvider provider = ConnectionProvider<span class="hljs-selector-class">.builder</span>("custom")
            <span class="hljs-selector-class">.maxConnections</span>(<span class="hljs-number">50</span>)
            <span class="hljs-selector-class">.maxIdleTime</span>(Duration.ofSeconds(<span class="hljs-number">20</span>))
            <span class="hljs-selector-class">.build</span>();
    
    return WebClient<span class="hljs-selector-class">.builder</span>()
            <span class="hljs-selector-class">.clientConnector</span>(new ReactorClientHttpConnector(provider, httpClient))
            <span class="hljs-selector-class">.build</span>();
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718</span>
</code></pre>
<h3 data-id="heading-30"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>常见问题与解决方案</h3>
<h4 data-id="heading-31"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>Q1: 如何处理大量并发请求？</h4>
<p><strong>A</strong>: 对于高并发场景，推荐使用WebClient，因为它支持响应式编程和非阻塞I/O。</p>
<h4 data-id="heading-32"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>Q2: 迁移成本太大，能否渐进式迁移？</h4>
<p><strong>A</strong>: 可以通过适配器模式逐步迁移，先在一个模块中试点，再推广到整个应用。</p>
<h4 data-id="heading-33"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>Q3: 如何保持向后兼容性？</h4>
<p><strong>A</strong>: 可以创建包装类，隐藏具体的HTTP客户端实现，便于后续更换。</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientFacade</span> {
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestClient restClient;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient webClient;
    
    <span class="hljs-keyword">public</span> HttpClientFacade(RestClient restClient, WebClient webClient) {
        <span class="hljs-keyword">this</span>.restClient = restClient;
        <span class="hljs-keyword">this</span>.webClient = webClient;
    }
    
    <span class="hljs-comment">// 统一的同步接口</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; T callSync(String url, Class&lt;T&gt; responseType) {
        <span class="hljs-keyword">return</span> restClient.<span class="hljs-keyword">get</span>().uri(url).retrieve().body(responseType);
    }
    
    <span class="hljs-comment">// 统一的异步接口</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; Mono&lt;T&gt; callAsync(String url, Class&lt;T&gt; responseType) {
        <span class="hljs-keyword">return</span> webClient.<span class="hljs-keyword">get</span>().uri(url).retrieve().bodyToMono(responseType);
    }
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021</span>
</code></pre>
<h3 data-id="heading-34"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>总结</h3>
<p>Spring Boot 4.0标志着HTTP客户端技术的重大进步。虽然RestTemplate的告别可能带来短期的迁移成本，但从长远来看：</p>
<ol>
<li><strong>性能提升</strong>：新的HTTP客户端提供更好的性能和资源利用率</li>
<li><strong>开发效率</strong>：函数式API和链式调用使代码更简洁</li>
<li><strong>未来兼容</strong>：拥抱响应式编程和现代Java生态</li>
</ol>
<p>建议开发团队：</p>
<ul>
<li>评估现有RestTemplate使用情况</li>
<li>制定渐进式迁移计划</li>
<li>培训团队掌握新的HTTP客户端API</li>
<li>在新项目中直接使用推荐的替代方案</li>
</ul>
<p>随着Spring生态系统的不断发展，掌握这些现代化的HTTP客户端技术将成为Java开发者的必备技能。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[双库协同，各取所长：.NET Core 中 PostgreSQL 与 SQLite 的优雅融合实战]]></title>    <link>https://juejin.cn/post/7603771025856479283</link>    <guid>https://juejin.cn/post/7603771025856479283</guid>    <pubDate>2026-02-08T06:12:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856479283" data-draft-id="7603651855236792329" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="双库协同，各取所长：.NET Core 中 PostgreSQL 与 SQLite 的优雅融合实战"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T06:12:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="大黄评测"/> <meta itemprop="url" content="https://juejin.cn/user/714024404135696"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            双库协同，各取所长：.NET Core 中 PostgreSQL 与 SQLite 的优雅融合实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/714024404135696/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    大黄评测
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:12:53.000Z" title="Sun Feb 08 2026 06:12:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在现代应用开发中，单一数据库架构往往难以满足所有场景需求。例如，你可能希望：</p>
<ul>
<li><strong>主业务数据</strong>存入功能强大、支持高并发的 <strong>PostgreSQL</strong>；</li>
<li><strong>本地缓存、边缘计算或嵌入式日志</strong>使用轻量、零配置的 <strong>SQLite</strong>。</li>
</ul>
<p>这种“混合持久化”（Polyglot Persistence）策略正变得越来越普遍。而 .NET Core 凭借其强大的依赖注入（DI）体系和 Entity Framework Core（EF Core）的多上下文支持，为双数据库架构提供了优雅的实现路径。</p>
<p>本文将手把手带你构建一个同时使用 <strong>PostgreSQL（主库）</strong> 和 <strong>SQLite（辅助库）</strong> 的 .NET Core 应用，并分享生产级的最佳实践。</p>
<hr/>
<h3 data-id="heading-0">一、为什么选择 PostgreSQL + SQLite？</h3>






























<table><thead><tr><th>场景</th><th>PostgreSQL</th><th>SQLite</th></tr></thead><tbody><tr><td><strong>数据规模</strong></td><td>TB 级，多用户并发</td><td>GB 级，单机/边缘</td></tr><tr><td><strong>部署复杂度</strong></td><td>需独立服务</td><td>零配置，文件即数据库</td></tr><tr><td><strong>事务与一致性</strong></td><td>完整 ACID，支持分布式事务</td><td>单文件 ACID，不支持并发写</td></tr><tr><td><strong>典型用途</strong></td><td>用户账户、订单、核心业务</td><td>本地缓存、设备日志、临时任务队列</td></tr></tbody></table>
<blockquote>
<p>✅ 组合优势：<br/>
主业务强一致 + 边缘数据轻量化 = 架构弹性与性能兼顾</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">二、项目结构设计</h3>
<p>我们将创建两个独立的 <code>DbContext</code>，分别对应不同数据库：</p>
<pre><code class="hljs language-arduino" lang="arduino">MyApp/
├── Data/
│   ├── MainDbContext.cs        <span class="hljs-comment">// PostgreSQL</span>
│   └── LocalDbContext.cs       <span class="hljs-comment">// SQLite</span>
├── Models/
│   ├── User.cs                 <span class="hljs-comment">// 存于 PostgreSQL</span>
│   └── DeviceLog.cs            <span class="hljs-comment">// 存于 SQLite</span>
├── Services/
│   ├── UserService.cs
│   └── LogService.cs
└── Program.cs
</code></pre>
<hr/>
<h3 data-id="heading-2">三、Step-by-Step 实现</h3>
<h4 data-id="heading-3">1. 安装必要 NuGet 包</h4>
<pre><code class="hljs language-csharp" lang="csharp">dotnet <span class="hljs-keyword">add</span> package Npgsql.EntityFrameworkCore.PostgreSQL
dotnet <span class="hljs-keyword">add</span> package Microsoft.EntityFrameworkCore.Sqlite
</code></pre>
<blockquote>
<p>注意：不要混用同一个 DbContext 注册多个提供程序！</p>
</blockquote>
<h4 data-id="heading-4">2. 定义模型（Models）</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// Models/User.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>!;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Email { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>!;
}

<span class="hljs-comment">// Models/DeviceLog.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DeviceLog</span>
{
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> Id { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> DateTime Timestamp { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">default</span>!;
}
</code></pre>
<h4 data-id="heading-5">3. 创建两个 DbContext</h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// Data/MainDbContext.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainDbContext</span> : DbContext
{
    <span class="hljs-keyword">public</span> DbSet&lt;User&gt; Users { get; set; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainDbContext</span><span class="hljs-params">(DbContextOptions&lt;MainDbContext&gt; options)</span> : base(options) {</span> }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-type">void</span> <span class="hljs-title">OnModelCreating</span><span class="hljs-params">(ModelBuilder modelBuilder)</span>
    </span>{
        modelBuilder.<span class="hljs-built_in">Entity</span>&lt;User&gt;().<span class="hljs-built_in">ToTable</span>(<span class="hljs-string">"users"</span>);
    }
}

<span class="hljs-comment">// Data/LocalDbContext.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalDbContext</span> : DbContext
{
    <span class="hljs-keyword">public</span> DbSet&lt;DeviceLog&gt; DeviceLogs { get; set; }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LocalDbContext</span><span class="hljs-params">(DbContextOptions&lt;LocalDbContext&gt; options)</span> : base(options) {</span> }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-type">void</span> <span class="hljs-title">OnConfiguring</span><span class="hljs-params">(DbContextOptionsBuilder optionsBuilder)</span>
    </span>{
        <span class="hljs-comment">// 可选：若未通过 DI 注入连接字符串</span>
        <span class="hljs-comment">// optionsBuilder.UseSqlite("Data Source=device_logs.db");</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-type">void</span> <span class="hljs-title">OnModelCreating</span><span class="hljs-params">(ModelBuilder modelBuilder)</span>
    </span>{
        modelBuilder.<span class="hljs-built_in">Entity</span>&lt;DeviceLog&gt;().<span class="hljs-built_in">ToTable</span>(<span class="hljs-string">"device_logs"</span>);
    }
}
</code></pre>
<h4 data-id="heading-6">4. 在 Program.cs 中注册双上下文</h4>
<pre><code class="hljs language-ini" lang="ini">var <span class="hljs-attr">builder</span> = WebApplication.CreateBuilder(args)<span class="hljs-comment">;</span>

// 注册 PostgreSQL 上下文
builder.Services.AddDbContext&lt;MainDbContext&gt;(<span class="hljs-attr">options</span> =&gt;
    options.UseNpgsql(builder.Configuration.GetConnectionString("Postgres")))<span class="hljs-comment">;</span>

// 注册 SQLite 上下文
builder.Services.AddDbContext&lt;LocalDbContext&gt;(<span class="hljs-attr">options</span> =&gt;
    options.UseSqlite(builder.Configuration.GetConnectionString("Sqlite")))<span class="hljs-comment">;</span>

// 自动创建数据库（仅开发环境建议）
using var <span class="hljs-attr">scope</span> = builder.Services.BuildServiceProvider().CreateScope()<span class="hljs-comment">;</span>
scope.ServiceProvider.GetRequiredService&lt;MainDbContext&gt;().Database.EnsureCreated()<span class="hljs-comment">;</span>
scope.ServiceProvider.GetRequiredService&lt;LocalDbContext&gt;().Database.EnsureCreated()<span class="hljs-comment">;</span>
</code></pre>
<p><code>appsettings.json</code> 配置：</p>
<pre><code class="hljs language-json" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"ConnectionStrings"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"Postgres"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Host=localhost;Database=myapp;Username=postgres;Password=secret"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"Sqlite"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Data Source=device_logs.db"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<h4 data-id="heading-7">5. 编写服务层，按需注入</h4>
<pre><code class="hljs language-csharp" lang="csharp"><span class="hljs-comment">// Services/UserService.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> MainDbContext _db;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserService</span>(<span class="hljs-params">MainDbContext db</span>)</span> =&gt; _db = db;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;User&gt; <span class="hljs-title">CreateUser</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> email</span>)</span>
    {
        <span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> User { Name = name, Email = email };
        _db.Users.Add(user);
        <span class="hljs-keyword">await</span> _db.SaveChangesAsync();
        <span class="hljs-keyword">return</span> user;
    }
}

<span class="hljs-comment">// Services/LogService.cs</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LogService</span>
{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> LocalDbContext _localDb;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LogService</span>(<span class="hljs-params">LocalDbContext localDb</span>)</span> =&gt; _localDb = localDb;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">LogMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> msg</span>)</span>
    {
        _localDb.DeviceLogs.Add(<span class="hljs-keyword">new</span> DeviceLog
        {
            Timestamp = DateTime.UtcNow,
            Message = msg
        });
        <span class="hljs-keyword">await</span> _localDb.SaveChangesAsync();
    }
}
</code></pre>
<p>控制器中使用：</p>
<pre><code class="hljs language-dart" lang="dart">app.MapPost(<span class="hljs-string">"/user"</span>, <span class="hljs-keyword">async</span> (UserService userService, HttpRequest req) =&gt;
{
    <span class="hljs-keyword">var</span> user = <span class="hljs-keyword">await</span> userService.CreateUser(<span class="hljs-string">"Alice"</span>, <span class="hljs-string">"alice@example.com"</span>);
    <span class="hljs-keyword">return</span> Results.Ok(user);
});

app.MapPost(<span class="hljs-string">"/log"</span>, <span class="hljs-keyword">async</span> (LogService logService, [FromBody] string msg) =&gt;
{
    <span class="hljs-keyword">await</span> logService.LogMessage(msg);
    <span class="hljs-keyword">return</span> Results.Ok();
});
</code></pre>
<hr/>
<h3 data-id="heading-8">四、最佳实践与避坑指南</h3>
<h4 data-id="heading-9">✅ 1. <strong>严格分离关注点</strong></h4>
<ul>
<li>不要在同一个业务方法中同时操作两个 DbContext（除非必要）；</li>
<li>若需跨库事务，考虑最终一致性（如通过消息队列补偿）。</li>
</ul>
<h4 data-id="heading-10">✅ 2. <strong>连接字符串安全</strong></h4>
<ul>
<li>PostgreSQL 密码勿硬编码，使用 Secret Manager 或 Azure Key Vault；</li>
<li>SQLite 路径建议使用 <code>Path.Combine(Directory.GetCurrentDirectory(), "data", "logs.db")</code> 确保可移植性。</li>
</ul>
<h4 data-id="heading-11">✅ 3. <strong>迁移（Migrations）管理</strong></h4>
<ul>
<li>
<p>为每个 DbContext 单独启用迁移：</p>
<pre><code class="hljs language-csharp" lang="csharp">dotnet ef migrations <span class="hljs-keyword">add</span> InitialMain -c MainDbContext -o Migrations/Postgres
dotnet ef migrations <span class="hljs-keyword">add</span> InitialLocal -c LocalDbContext -o Migrations/Sqlite
</code></pre>
</li>
<li>
<p>生产环境建议手动审核 SQL 脚本。</p>
</li>
</ul>
<h4 data-id="heading-12">✅ 4. <strong>性能与资源</strong></h4>
<ul>
<li>SQLite 默认不支持高并发写入，避免在 Web API 热点路径频繁写日志；</li>
<li>可搭配 <code>Microsoft.Data.Sqlite</code> 的 WAL 模式提升并发读性能。</li>
</ul>
<hr/>
<h3 data-id="heading-13">五、适用场景推荐</h3>
<ul>
<li>📱 <strong>IoT 边缘设备 + 云中心</strong>：设备用 SQLite 记录本地状态，定期同步到云端 PostgreSQL；</li>
<li>🖥️ <strong>桌面应用</strong>：配置、缓存用 SQLite，用户数据同步到 PostgreSQL；</li>
<li>🧪 <strong>测试隔离</strong>：集成测试时用 SQLite 替代 PostgreSQL，加速执行。</li>
</ul>
<hr/>
<h3 data-id="heading-14">结语</h3>
<p>在 .NET Core 中融合 PostgreSQL 与 SQLite，并非“炫技”，而是对<strong>场景适配性</strong>的理性选择。通过清晰的架构分层、独立的 DbContext 设计和合理的服务注入，我们既能享受 PostgreSQL 的企业级能力，又能利用 SQLite 的极致轻量。</p>
<p>双库协同，不是妥协，而是智慧——让每一份数据，都落在最适合它的土壤上。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【JAVA 进阶】Spring AOP核心原理：JDK与CGLib动态代理实战解析]]></title>    <link>https://juejin.cn/post/7603674653153755145</link>    <guid>https://juejin.cn/post/7603674653153755145</guid>    <pubDate>2026-02-08T06:25:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603674653153755145" data-draft-id="7603651855236841481" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【JAVA 进阶】Spring AOP核心原理：JDK与CGLib动态代理实战解析"/> <meta itemprop="keywords" content="后端,Spring"/> <meta itemprop="datePublished" content="2026-02-08T06:25:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Java水解"/> <meta itemprop="url" content="https://juejin.cn/user/2441349519143037"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【JAVA 进阶】Spring AOP核心原理：JDK与CGLib动态代理实战解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2441349519143037/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Java水解
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:25:23.000Z" title="Sun Feb 08 2026 06:25:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读26分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">前言</h2>
<p>在[Spring框架]的核心特性中，AOP（面向切面编程）无疑是与IOC（控制反转）并驾齐驱的灵魂技术。它通过"横切"的方式，将日志记录、事务管理、权限控制等分散在业务逻辑中的通用功能抽取出来，形成独立的切面，实现了"业务功能"与"通用功能"的解耦，极大提升了代码的复用性和可维护性。而支撑Spring AOP实现的核心技术，正是动态代理——其中JDK动态代理与CGLib动态代理更是重中之重。本文将从AOP的基础概念出发，层层深入剖析这两种动态代理的实现原理、代码细节及适用场景，最终梳理Spring AOP的整体执行逻辑，为开发者提供一份全面且实用的技术指南。</p>
<h2 data-id="heading-1"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第一章 夯实基础：走进Spring AOP的世界</h2>
<h3 data-id="heading-2"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.1 为什么需要AOP？—— 从代码痛点说起</h3>
<p>在传统的OOP（面向对象编程）开发中，我们习惯于将功能封装在类和对象中，通过继承和多态实现代码复用。但在实际业务场景中，会存在一些"跨界"的通用功能，例如：</p>
<ul>
<li>接口调用前后的日志记录，需要在每个接口实现中重复编写日志输出代码；</li>
<li>数据库操作的事务管理，需在增删改方法前后手动开启、提交或回滚事务；</li>
<li>接口访问的权限校验，要在每个业务方法开头判断用户权限是否合法。</li>
</ul>
<p>这些代码与核心业务逻辑无关，却分散在各个业务类中，导致代码冗余、维护成本高——修改日志格式需要改动所有日志相关代码，调整事务隔离级别则要遍历所有事务方法。AOP的出现正是为了解决这一问题，它将这些通用功能抽象为"切面"，在不修改业务代码的前提下，通过"织入"机制将切面与业务逻辑结合，实现通用功能的统一管理。</p>
<h3 data-id="heading-3"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2 AOP核心概念：读懂切面的"语言体系"</h3>
<p>要理解Spring AOP的实现原理，首先需要掌握其核心概念，这些概念共同构成了AOP的"语言体系"，也是后续理解动态代理的基础：</p>
<h4 data-id="heading-4"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.1 切面（Aspect）</h4>
<p>切面是AOP的核心载体，它封装了需要横切到业务逻辑中的通用功能，例如"日志切面"、“事务切面”。在Spring中，切面通常是一个带有@Aspect注解的类，其中包含了通知和切入点的定义。</p>
<h4 data-id="heading-5"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.2 通知（Advice）</h4>
<p>通知定义了切面的具体执行逻辑和执行时机，即"在什么时候做什么事"。Spring支持5种类型的通知：</p>
<ul>
<li>前置通知（Before）：在目标方法执行前执行；</li>
<li>后置通知（After）：在目标方法执行后执行，无论方法是否抛出异常；</li>
<li>返回通知（AfterReturning）：在目标方法正常返回后执行；</li>
<li>异常通知（AfterThrowing）：在目标方法抛出异常后执行；</li>
<li>环绕通知（Around）：包裹目标方法，可在方法执行前后自定义逻辑，甚至控制方法是否执行。</li>
</ul>
<h4 data-id="heading-6"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.3 切入点（Pointcut）</h4>
<p>切入点定义了切面的"作用范围"，即"对哪些方法生效"。它通过切入点表达式（如execution表达式）指定目标方法，例如"所有com.example.service包下以find开头的public方法"。切入点是连接切面与目标对象的桥梁，只有匹配切入点的方法才会被织入通知逻辑。</p>
<h4 data-id="heading-7"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.4 目标对象（Target）</h4>
<p>目标对象即被切面织入的业务对象，也就是包含核心业务逻辑的对象，例如UserService、OrderService等。</p>
<h4 data-id="heading-8"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.5 代理对象（Proxy）</h4>
<p>代理对象是Spring AOP实现的关键——Spring不会直接修改目标对象的代码，而是通过动态代理技术为目标对象创建一个代理对象。当客户端调用目标方法时，实际上是调用代理对象的方法，代理对象会在合适的时机执行切面的通知逻辑，再调用目标对象的原始方法。</p>
<h4 data-id="heading-9"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.2.6 织入（Weaving）</h4>
<p>织入是将切面的通知逻辑融入到目标对象业务方法中的过程。根据织入时机的不同，可分为编译期织入（如AspectJ）、类加载期织入和运行期织入——Spring AOP采用的是运行期织入，通过动态代理在程序运行时动态生成代理对象，完成通知与目标方法的结合。</p>
<h3 data-id="heading-10"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>1.3 Spring AOP的核心逻辑：代理对象的"桥梁作用"</h3>
<p>Spring AOP的核心逻辑可概括为"代理介导"：客户端请求目标对象时，Spring的IOC容器返回的不是目标对象本身，而是其代理对象；客户端调用代理对象的方法时，代理对象先执行切面的通知逻辑（如日志记录、权限校验），再调用目标对象的原始方法；方法执行完成后，代理对象还会执行后续的通知逻辑（如事务提交、返回值处理）。整个过程中，客户端无需感知代理对象的存在，目标对象的业务代码也无需修改，从而实现了通用功能与业务逻辑的解耦。</p>
<h2 data-id="heading-11"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第二章 深度解析：JDK动态代理的实现原理</h2>
<p>JDK动态代理是Spring AOP默认使用的代理方式，它基于Java的反射机制实现，核心依赖java.lang.reflect包下的Proxy类和InvocationHandler接口。需要注意的是，JDK动态代理有一个重要限制：<strong>只能为实现了接口的目标对象创建代理对象</strong>，这是由其底层实现机制决定的。</p>
<h3 data-id="heading-12"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.1 JDK动态代理核心组件</h3>
<p>要理解JDK动态代理，首先需要掌握其两个核心组件的作用，它们共同支撑起代理对象的创建和逻辑执行：</p>
<h4 data-id="heading-13"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.1.1 InvocationHandler接口</h4>
<p>InvocationHandler是一个函数式接口，仅包含一个invoke方法，它是代理对象的"逻辑处理器"——当客户端调用代理对象的方法时，最终都会委托给该接口的invoke方法执行。其定义如下：</p>
<pre><code class="hljs language-typescript" lang="typescript">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InvocationHandler</span> {
    <span class="hljs-comment">/**
     * 代理对象方法调用的核心处理方法
     * <span class="hljs-doctag">@param</span> proxy 代理对象本身
     * <span class="hljs-doctag">@param</span> method 被调用的目标方法
     * <span class="hljs-doctag">@param</span> args 目标方法的参数数组
     * <span class="hljs-doctag">@return</span> 目标方法的返回值
     * <span class="hljs-doctag">@throws</span> Throwable 目标方法可能抛出的异常
     */</span>
    <span class="hljs-title class_">Object</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-title class_">Object</span> proxy, <span class="hljs-title class_">Method</span> method, <span class="hljs-title class_">Object</span>[] args) throws <span class="hljs-title class_">Throwable</span>;
}

<span class="hljs-variable constant_">AI</span>写代码java
运行
<span class="hljs-number">123456789101112</span>
</code></pre>
<p>invoke方法的三个参数含义明确：proxy是动态生成的代理对象；method是客户端调用的目标方法实例，通过它可以反射调用目标对象的方法；args是客户端传递给目标方法的参数。开发者需要在invoke方法中实现"通知逻辑+目标方法调用"的组合逻辑。</p>
<h4 data-id="heading-14"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.1.2 Proxy类</h4>
<p>Proxy类是JDK动态代理的"代理工厂"，它提供了静态方法newProxyInstance用于创建代理对象。该方法是JDK动态代理的入口，其定义如下：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,
                                     Class&lt;?&gt;[] interfaces,
                                     InvocationHandler h)</span>
    <span class="hljs-keyword">throws</span> IllegalArgumentException

AI写代码java
运行
<span class="hljs-number">12345</span>
</code></pre>
<p>三个参数的作用至关重要，直接决定了代理对象的生成：</p>
<ul>
<li>loader：类加载器，用于加载代理对象的字节码，通常使用目标对象的类加载器；</li>
<li>interfaces：目标对象实现的所有接口数组，JDK动态代理会让代理对象实现这些接口，从而保证代理对象与目标对象的接口一致性；</li>
<li>h：InvocationHandler实例，代理对象的方法调用会委托给该实例的invoke方法。</li>
</ul>
<h3 data-id="heading-15"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.2 JDK动态代理实战：手写一个日志代理</h3>
<p>理论结合实践是理解技术的最佳方式，下面我们通过一个"日志切面"的案例，手写JDK动态代理的完整实现，直观感受其工作流程。</p>
<h4 data-id="heading-16"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.2.1 步骤1：定义目标接口与目标对象</h4>
<p>由于JDK动态代理依赖接口，首先定义一个业务接口UserService，包含用户查询和新增两个方法，再创建其实现类UserServiceImpl作为目标对象：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">
<span class="hljs-comment">// 目标接口</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> {
    <span class="hljs-comment">// 查询用户</span>
    User findUserById(<span class="hljs-built_in">Long</span> id);
    <span class="hljs-comment">// 新增用户</span>
    void addUser(User user);
}

<span class="hljs-comment">// 目标对象（业务实现类）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">UserService</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> User findUserById(<span class="hljs-built_in">Long</span> id) {
        <span class="hljs-comment">// 模拟数据库查询</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"执行数据库查询：根据ID="</span> + id + <span class="hljs-string">"查询用户"</span>);
        <span class="hljs-keyword">return</span> new User(id, <span class="hljs-string">"张三"</span>, <span class="hljs-number">25</span>);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> void addUser(User user) {
        <span class="hljs-comment">// 模拟数据库新增</span>
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"执行数据库新增：添加用户"</span> + user.getName());
    }
}

<span class="hljs-comment">// 实体类User</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;

    <span class="hljs-comment">// 构造方法、getter、setter省略</span>
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021222324252627282930313233</span>
</code></pre>
<h4 data-id="heading-17"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.2.2 步骤2：实现InvocationHandler接口——定义切面逻辑</h4>
<p>创建LogInvocationHandler类实现InvocationHandler接口，在invoke方法中实现"前置日志+目标方法调用+后置日志"的逻辑，这就是我们的"日志切面"：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;
<span class="hljs-keyword">import</span> java.lang.reflect.Method;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> {
    <span class="hljs-comment">// 目标对象（被代理的业务对象）</span>
    <span class="hljs-keyword">private</span> Object target;

    <span class="hljs-comment">// 构造方法注入目标对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LogInvocationHandler</span><span class="hljs-params">(Object target)</span> {
        <span class="hljs-built_in">this</span>.target = target;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-comment">// 1. 前置通知：日志记录（方法调用时间、方法名）</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();
        System.out.println(<span class="hljs-string">"【日志前置通知】"</span> + LocalDateTime.now() + <span class="hljs-string">" 调用方法："</span> + methodName);

        <span class="hljs-comment">// 2. 调用目标对象的原始方法</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            result = method.invoke(target, args);
            <span class="hljs-comment">// 3. 返回通知：记录方法返回值</span>
            System.out.println(<span class="hljs-string">"【日志返回通知】方法"</span> + methodName + <span class="hljs-string">"返回值："</span> + (result == <span class="hljs-literal">null</span> ? <span class="hljs-string">"无"</span> : result.toString()));
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// 4. 异常通知：记录方法异常信息</span>
            System.out.println(<span class="hljs-string">"【日志异常通知】方法"</span> + methodName + <span class="hljs-string">"抛出异常："</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// 抛出异常，不影响业务逻辑</span>
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 5. 后置通知：记录方法调用结束</span>
            System.out.println(<span class="hljs-string">"【日志后置通知】方法"</span> + methodName + <span class="hljs-string">"调用结束\n"</span>);
        }

        <span class="hljs-keyword">return</span> result;
    }
}

AI写代码java
运行
<span class="hljs-number">1234567891011121314151617181920212223242526272829303132333435363738</span>
</code></pre>
<h4 data-id="heading-18"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.2.3 步骤3：使用Proxy创建代理对象并测试</h4>
<p>创建测试类，通过Proxy.newProxyInstance方法生成代理对象，然后调用代理对象的方法，观察日志切面是否生效：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> java.lang.reflect.Proxy;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkProxyTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 1. 创建目标对象</span>
        <span class="hljs-type">UserService</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();

        <span class="hljs-comment">// 2. 创建InvocationHandler实例（传入目标对象）</span>
        <span class="hljs-type">LogInvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogInvocationHandler</span>(target);

        <span class="hljs-comment">// 3. 生成代理对象：参数分别为目标类加载器、目标接口数组、InvocationHandler</span>
        <span class="hljs-type">UserService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserService) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                invocationHandler
        );

        <span class="hljs-comment">// 4. 调用代理对象的方法</span>
        proxy.findUserById(<span class="hljs-number">1L</span>);
        proxy.addUser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">2L</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-number">30</span>));
    }
}

AI写代码java
运行
<span class="hljs-number">1234567891011121314151617181920212223</span>
</code></pre>
<h4 data-id="heading-19"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.2.4 测试结果与分析</h4>
<p>运行测试类，输出结果如下：</p>
<pre><code class="hljs language-ini" lang="ini">
【日志前置通知】2025-12-05T15:30:00 调用方法：findUserById
执行数据库查询：根据<span class="hljs-attr">ID</span>=<span class="hljs-number">1</span>查询用户
【日志返回通知】方法findUserById返回值：User(<span class="hljs-attr">id</span>=<span class="hljs-number">1</span>, name=张三, age=<span class="hljs-number">25</span>)
【日志后置通知】方法findUserById调用结束

【日志前置通知】2025-12-05T15:30:00 调用方法：addUser
执行数据库新增：添加用户李四
【日志返回通知】方法addUser返回值：无
【日志后置通知】方法addUser调用结束

AI写代码text
12345678910
</code></pre>
<p>从结果可以看出，代理对象成功将日志通知逻辑与业务方法结合：调用findUserById和addUser方法时，均先执行前置日志，再执行核心业务逻辑，最后执行返回通知和后置通知。这正是JDK动态代理的核心作用——通过代理对象介导，实现切面逻辑与业务逻辑的解耦。</p>
<h3 data-id="heading-20"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>2.3 JDK动态代理底层机制：代理类是如何生成的？</h3>
<p>很多开发者会好奇：Proxy.newProxyInstance方法调用后，代理对象的字节码是如何生成的？其实，JDK动态代理的底层是通过"动态生成字节码文件"并加载到JVM中实现的，具体流程如下：</p>
<ol>
<li><strong>生成代理类的字节码</strong>：Proxy类根据传入的interfaces参数，动态生成一个实现了这些接口的代理类字节码，该类继承自java.lang.reflect.Proxy类（这也是JDK动态代理不能代理类的原因——Java单继承机制）；</li>
<li><strong>为代理类生成方法</strong>：代理类会为每个接口方法生成对应的实现方法，这些方法的逻辑非常简单——直接调用InvocationHandler的invoke方法；</li>
<li><strong>加载代理类字节码</strong>：通过传入的类加载器（loader参数）将生成的代理类字节码加载到JVM中，生成Class对象；</li>
<li><strong>创建代理对象实例</strong>：通过反射调用代理类的构造方法（该构造方法接收InvocationHandler参数），创建代理对象并返回。</li>
</ol>
<p>我们可以通过设置系统属性，将JDK动态生成的代理类字节码保存到本地，以便直观查看。在测试类的main方法开头添加如下代码：</p>
<pre><code class="hljs language-arduino" lang="arduino">
<span class="hljs-comment">// 保存JDK动态生成的代理类字节码到本地</span>
System.<span class="hljs-built_in">getProperties</span>().<span class="hljs-built_in">put</span>(<span class="hljs-string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="hljs-string">"true"</span>);

AI写代码java
运行
<span class="hljs-number">123</span>
</code></pre>
<p>运行后，会在项目根目录下生成com/sun/proxy/$Proxy0.class文件，反编译后可以看到代理类的核心结构（简化后）：</p>
<pre><code class="hljs language-scala" lang="scala">
public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">$Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-title">implements</span> <span class="hljs-title">UserService</span> </span>{
    <span class="hljs-comment">// 静态代码块：获取目标接口的方法实例</span>
    static {
        <span class="hljs-keyword">try</span> {
            m1 = <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"java.lang.Object"</span>).getMethod(<span class="hljs-string">"equals"</span>, <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"java.lang.Object"</span>));
            m2 = <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"java.lang.Object"</span>).getMethod(<span class="hljs-string">"toString"</span>);
            m3 = <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"com.example.service.UserService"</span>).getMethod(<span class="hljs-string">"findUserById"</span>, <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"java.lang.Long"</span>));
            m4 = <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"com.example.service.UserService"</span>).getMethod(<span class="hljs-string">"addUser"</span>, <span class="hljs-type">Class</span>.forName(<span class="hljs-string">"com.example.entity.User"</span>));
            <span class="hljs-comment">// ...省略其他方法</span>
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">NoSuchMethodException</span> e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NoSuchMethodError</span>(e.getMessage());
        }
    }

    <span class="hljs-comment">// 构造方法：接收InvocationHandler参数并传给父类Proxy</span>
    public $<span class="hljs-type">Proxy0</span>(<span class="hljs-type">InvocationHandler</span> var1) <span class="hljs-keyword">throws</span>  {
        <span class="hljs-keyword">super</span>(var1);
    }

    <span class="hljs-comment">// 实现UserService的findUserById方法</span>
    public <span class="hljs-keyword">final</span> <span class="hljs-type">User</span> findUserById(<span class="hljs-type">Long</span> var1) <span class="hljs-keyword">throws</span>  {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 调用InvocationHandler的invoke方法</span>
            <span class="hljs-keyword">return</span> (<span class="hljs-type">User</span>)<span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[]{var1});
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">RuntimeException</span> | <span class="hljs-type">Error</span> var3) {
            <span class="hljs-keyword">throw</span> var3;
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">Throwable</span> var4) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UndeclaredThrowableException</span>(var4);
        }
    }

    <span class="hljs-comment">// 实现UserService的addUser方法</span>
    public <span class="hljs-keyword">final</span> void addUser(<span class="hljs-type">User</span> var1) <span class="hljs-keyword">throws</span>  {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 调用InvocationHandler的invoke方法</span>
            <span class="hljs-keyword">super</span>.h.invoke(<span class="hljs-keyword">this</span>, m4, <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[]{var1});
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">RuntimeException</span> | <span class="hljs-type">Error</span> var3) {
            <span class="hljs-keyword">throw</span> var3;
        } <span class="hljs-keyword">catch</span> (<span class="hljs-type">Throwable</span> var4) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UndeclaredThrowableException</span>(var4);
        }
    }
}

<span class="hljs-type">AI</span>写代码java
运行
<span class="hljs-number">1234567891011121314151617181920212223242526272829303132333435363738394041424344</span>
</code></pre>
<p>反编译后的代码清晰地展示了代理类的结构：它继承自Proxy类，实现了UserService接口，每个接口方法的实现都委托给了InvocationHandler的invoke方法。这也就解释了为什么调用代理对象的方法会触发invoke方法的执行——代理类的方法逻辑就是如此设计的。</p>
<h2 data-id="heading-21"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第三章 另辟蹊径：CGLib动态代理的实现原理</h2>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/01d95c8e5f27489d8ca89547f47d62b4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSmF2YeawtOinow==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771136723&amp;x-signature=JpGLTnGUz7AmkaAoiaQ1yIxJz0Q%3D" alt="在这里插入图片描述" loading="lazy"/></p>
<p>上一章我们提到，JDK动态代理只能为实现了接口的目标对象创建代理，这在实际开发中存在局限性——如果某个业务类没有实现任何接口（如遗留系统中的类），JDK动态代理就无法满足需求。此时，CGLib动态代理便成为了Spring AOP的补充方案。CGLib（Code Generation Library）是一个基于ASM字节码操作框架的代码生成类库，它通过"继承目标类"的方式创建代理对象，无需目标类实现接口。</p>
<h3 data-id="heading-22"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.1 CGLib动态代理核心原理：基于继承的代理</h3>
<p>CGLib动态代理的核心思想是"继承目标类，重写目标方法"：</p>
<ol>
<li>CGLib通过ASM框架动态生成目标类的子类，该子类就是代理类；</li>
<li>代理类重写目标类中的非final方法，在重写的方法中实现"通知逻辑+目标方法调用"；</li>
<li>客户端调用代理对象的方法时，实际上是调用代理类重写后的方法，从而触发通知逻辑和目标方法的执行。</li>
</ol>
<p>需要注意的是，CGLib无法代理final类和final方法——因为final类不能被继承，final方法不能被重写，这是CGLib的核心限制。</p>
<h3 data-id="heading-23"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.2 CGLib动态代理核心组件</h3>
<p>CGLib动态代理的核心组件主要有两个：MethodInterceptor接口和Enhancer类，它们的作用与JDK动态代理的InvocationHandler和Proxy类类似。</p>
<h4 data-id="heading-24"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.2.1 MethodInterceptor接口</h4>
<p>MethodInterceptor是CGLib的"方法拦截器"，类似于JDK动态代理的InvocationHandler，它定义了代理对象方法调用的核心处理逻辑。该接口仅包含一个intercept方法：</p>
<pre><code class="hljs language-typescript" lang="typescript">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callback</span> {
    <span class="hljs-comment">/**
     * 代理对象方法调用的核心处理方法
     * <span class="hljs-doctag">@param</span> obj 代理对象
     * <span class="hljs-doctag">@param</span> method 被调用的目标方法
     * <span class="hljs-doctag">@param</span> args 目标方法的参数数组
     * <span class="hljs-doctag">@param</span> proxy MethodProxy对象，用于调用目标方法（比反射更高效）
     * <span class="hljs-doctag">@return</span> 目标方法的返回值
     * <span class="hljs-doctag">@throws</span> Throwable 目标方法可能抛出的异常
     */</span>
    <span class="hljs-title class_">Object</span> <span class="hljs-title function_">intercept</span>(<span class="hljs-title class_">Object</span> obj, <span class="hljs-title class_">Method</span> method, <span class="hljs-title class_">Object</span>[] args, <span class="hljs-title class_">MethodProxy</span> proxy) throws <span class="hljs-title class_">Throwable</span>;
}

<span class="hljs-variable constant_">AI</span>写代码java
运行
<span class="hljs-number">12345678910111213</span>
</code></pre>
<p>与invoke方法相比，intercept方法多了一个MethodProxy参数，它是CGLib提供的用于调用目标方法的工具类，其效率比通过反射调用Method对象更高——因为MethodProxy会生成目标方法的快速调用代码，避免了反射的性能开销。</p>
<h4 data-id="heading-25"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.2.2 Enhancer类</h4>
<p>Enhancer是CGLib的"代理生成器"，类似于JDK动态代理的Proxy类，它负责动态生成目标类的子类（代理类）并创建代理对象。Enhancer的核心方法包括setSuperclass（设置目标类，即代理类的父类）、setCallback（设置方法拦截器）、create（生成并返回代理对象）。</p>
<h3 data-id="heading-26"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3 CGLib动态代理实战：为无接口类创建日志代理</h3>
<p>下面我们以一个<strong>无接口的业务类</strong>为例，实现CGLib动态代理的日志切面，对比与JDK动态代理的差异。</p>
<h4 data-id="heading-27"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3.1 步骤1：引入CGLib依赖</h4>
<p>Spring Boot项目中已默认引入CGLib依赖（通过spring-core间接依赖），非Spring项目需手动引入：</p>
<pre><code class="hljs language-xml" lang="xml">
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

AI写代码xml
123456
</code></pre>
<h4 data-id="heading-28"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3.2 步骤2：定义无接口的目标对象</h4>
<p>创建一个未实现任何接口的业务类OrderService，作为CGLib的代理目标：</p>
<pre><code class="hljs language-kotlin" lang="kotlin">
<span class="hljs-comment">// 无接口的目标对象</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> {
    <span class="hljs-comment">// 订单查询方法</span>
    <span class="hljs-keyword">public</span> Order findOrderById(<span class="hljs-built_in">Long</span> id) {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"执行数据库查询：根据ID="</span> + id + <span class="hljs-string">"查询订单"</span>);
        <span class="hljs-keyword">return</span> new Order(id, <span class="hljs-string">"20251205001"</span>, <span class="hljs-number">199.9</span>);
    }

    <span class="hljs-comment">// 订单创建方法</span>
    <span class="hljs-keyword">public</span> void createOrder(Order order) {
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"执行数据库新增：创建订单"</span> + order.getOrderNo());
        <span class="hljs-comment">// 模拟异常场景</span>
        <span class="hljs-comment">// if (order.getAmount() &lt; 0) {</span>
        <span class="hljs-comment">//     throw new IllegalArgumentException("订单金额不能为负数");</span>
        <span class="hljs-comment">// }</span>
    }
}

<span class="hljs-comment">// 实体类Order</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Long</span> id;
    <span class="hljs-keyword">private</span> String orderNo;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Double</span> amount;

    <span class="hljs-comment">// 构造方法、getter、setter省略</span>
}

AI写代码java
运行
<span class="hljs-number">123456789101112131415161718192021222324252627</span>
</code></pre>
<h4 data-id="heading-29"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3.3 步骤3：实现MethodInterceptor接口——定义日志拦截逻辑</h4>
<p>创建LogMethodInterceptor类实现MethodInterceptor接口，在intercept方法中实现日志通知逻辑：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;
<span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;
<span class="hljs-keyword">import</span> java.lang.reflect.Method;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-comment">// 1. 前置通知：日志记录</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();
        System.out.println(<span class="hljs-string">"【CGLib日志前置通知】"</span> + LocalDateTime.now() + <span class="hljs-string">" 调用方法："</span> + methodName);

        <span class="hljs-comment">// 2. 调用目标对象的原始方法（通过MethodProxy调用，效率更高）</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            result = proxy.invokeSuper(obj, args); <span class="hljs-comment">// 注意：此处是invokeSuper，调用父类（目标类）的方法</span>
            <span class="hljs-comment">// 3. 返回通知</span>
            System.out.println(<span class="hljs-string">"【CGLib日志返回通知】方法"</span> + methodName + <span class="hljs-string">"返回值："</span> + (result == <span class="hljs-literal">null</span> ? <span class="hljs-string">"无"</span> : result.toString()));
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-comment">// 4. 异常通知</span>
            System.out.println(<span class="hljs-string">"【CGLib日志异常通知】方法"</span> + methodName + <span class="hljs-string">"抛出异常："</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> e;
        } <span class="hljs-keyword">finally</span> {
            <span class="hljs-comment">// 5. 后置通知</span>
            System.out.println(<span class="hljs-string">"【CGLib日志后置通知】方法"</span> + methodName + <span class="hljs-string">"调用结束\n"</span>);
        }

        <span class="hljs-keyword">return</span> result;
    }
}

AI写代码java
运行
<span class="hljs-number">12345678910111213141516171819202122232425262728293031</span>
</code></pre>
<p>需要特别注意的是，调用目标方法时使用的是MethodProxy的invokeSuper方法，而非invoke方法：</p>
<ul>
<li>invokeSuper(obj, args)：调用代理对象的父类（即目标类）的对应方法，这是CGLib调用目标方法的正确方式；</li>
<li>invoke(obj, args)：会再次触发intercept方法，导致无限循环，开发中需避免。</li>
</ul>
<h4 data-id="heading-30"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3.4 步骤4：使用Enhancer创建代理对象并测试</h4>
<p>创建测试类，通过Enhancer生成代理对象并调用方法：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyTest</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// 1. 创建目标对象</span>
        <span class="hljs-type">OrderService</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderService</span>();

        <span class="hljs-comment">// 2. 创建方法拦截器实例</span>
        <span class="hljs-type">LogMethodInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogMethodInterceptor</span>();

        <span class="hljs-comment">// 3. 创建Enhancer对象（代理生成器）</span>
        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();
        <span class="hljs-comment">// 设置目标类为父类（代理类继承自目标类）</span>
        enhancer.setSuperclass(OrderService.class);
        <span class="hljs-comment">// 设置方法拦截器（代理类的方法调用会委托给该拦截器）</span>
        enhancer.setCallback(interceptor);

        <span class="hljs-comment">// 4. 生成代理对象（通过create方法）</span>
        <span class="hljs-type">OrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (OrderService) enhancer.create();

        <span class="hljs-comment">// 5. 调用代理对象的方法</span>
        proxy.findOrderById(<span class="hljs-number">1L</span>);
        proxy.createOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(<span class="hljs-number">2L</span>, <span class="hljs-string">"20251205002"</span>, <span class="hljs-number">299.9</span>));

        <span class="hljs-comment">// 测试异常场景（解开OrderService中createOrder的异常注释）</span>
        <span class="hljs-comment">// proxy.createOrder(new Order(3L, "20251205003", -50.0));</span>
    }
}

AI写代码java
运行
<span class="hljs-number">1234567891011121314151617181920212223242526272829</span>
</code></pre>
<h4 data-id="heading-31"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.3.5 测试结果与分析</h4>
<p>运行测试类，输出结果如下：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">
【<span class="hljs-built_in">CGLib</span>日志前置通知】<span class="hljs-number">2025</span><span class="hljs-number">-12</span><span class="hljs-number">-05</span>T16:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> 调用方法：findOrderById
执行数据库查询：根据ID=<span class="hljs-number">1</span>查询订单
【<span class="hljs-built_in">CGLib</span>日志返回通知】方法findOrderById返回值：Order(<span class="hljs-type">id</span>=<span class="hljs-number">1</span>, orderNo=<span class="hljs-number">20251205001</span>, amount=<span class="hljs-number">199.9</span>)
【<span class="hljs-built_in">CGLib</span>日志后置通知】方法findOrderById调用结束

【<span class="hljs-built_in">CGLib</span>日志前置通知】<span class="hljs-number">2025</span><span class="hljs-number">-12</span><span class="hljs-number">-05</span>T16:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> 调用方法：createOrder
执行数据库新增：创建订单<span class="hljs-number">20251205002</span>
【<span class="hljs-built_in">CGLib</span>日志返回通知】方法createOrder返回值：无
【<span class="hljs-built_in">CGLib</span>日志后置通知】方法createOrder调用结束

AI写代码text
<span class="hljs-number">12345678910</span>
</code></pre>
<p>结果表明，CGLib成功为无接口的OrderService创建了代理对象，日志通知逻辑与业务逻辑完美结合。若解开OrderService中createOrder方法的异常注释，调用时会触发异常通知，输出如下：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">
【<span class="hljs-built_in">CGLib</span>日志前置通知】<span class="hljs-number">2025</span><span class="hljs-number">-12</span><span class="hljs-number">-05</span>T16:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> 调用方法：createOrder
执行数据库新增：创建订单<span class="hljs-number">20251205003</span>
【<span class="hljs-built_in">CGLib</span>日志异常通知】方法createOrder抛出异常：订单金额不能为负数
【<span class="hljs-built_in">CGLib</span>日志后置通知】方法createOrder调用结束

Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.IllegalArgumentException: 订单金额不能为负数
    ...省略堆栈信息

AI写代码text
<span class="hljs-number">12345678</span>
</code></pre>
<p>这说明CGLib的异常处理逻辑同样生效，与JDK动态代理的通知类型覆盖能力一致。</p>
<h3 data-id="heading-32"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>3.4 CGLib动态代理底层机制：代理类的生成过程</h3>
<p>与JDK动态代理类似，CGLib也是通过动态生成字节码文件来创建代理类的，但其生成逻辑基于ASM框架，直接操作字节码，过程更为复杂，核心流程如下：</p>
<ol>
<li><strong>确定代理类的父类</strong>：Enhancer根据setSuperclass方法传入的目标类，确定代理类的父类；</li>
<li><strong>生成代理类字节码</strong>：通过ASM框架生成代理类的字节码，代理类继承自目标类，并重写目标类的非final方法；</li>
<li><strong>注入拦截逻辑</strong>：在代理类重写的方法中，注入方法拦截逻辑——调用MethodInterceptor的intercept方法；</li>
<li><strong>生成MethodProxy</strong>：为每个重写的方法生成对应的MethodProxy对象，用于高效调用目标方法；</li>
<li><strong>创建代理对象</strong>：通过Enhancer的create方法，将生成的代理类字节码加载到JVM中，创建代理对象并返回。</li>
</ol>
<p>我们可以通过设置系统属性，将CGLib生成的代理类字节码保存到本地。在测试类main方法开头添加如下代码：</p>
<pre><code class="hljs language-arduino" lang="arduino">
<span class="hljs-comment">// 保存CGLib生成的代理类字节码到本地</span>
System.<span class="hljs-built_in">setProperty</span>(<span class="hljs-string">"cglib.debugLocation"</span>, <span class="hljs-string">"D:/cglib_proxy"</span>);
System.<span class="hljs-built_in">setProperty</span>(<span class="hljs-string">"cglib.generateSpringCglibProxyClass"</span>, <span class="hljs-string">"true"</span>);

AI写代码java
运行
<span class="hljs-number">1234</span>
</code></pre>
<p>运行后，会在D:/cglib_proxy目录下生成多个class文件，其中OrderServiceE n h a n c e r B y C G L I B EnhancerByCGLIBEnhancerByCGLIBxxxx.class就是代理类，反编译后可看到其核心结构（简化后）：</p>
<pre><code class="hljs language-swift" lang="swift">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService$$EnhancerByCGLIB$$1234</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">OrderService</span> <span class="hljs-title class_">implements</span> <span class="hljs-title class_">Factory</span> {
    <span class="hljs-comment">// MethodProxy对象，用于调用目标方法</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MethodProxy</span> <span class="hljs-type">CGLIB_findOrderById_0</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MethodProxy</span> <span class="hljs-type">CGLIB_createOrder_1</span>;

    <span class="hljs-comment">// 静态代码块：初始化MethodProxy</span>
    <span class="hljs-keyword">static</span> {
        <span class="hljs-type">CGLIB_findOrderById_0</span> <span class="hljs-operator">=</span> <span class="hljs-type">MethodProxy</span>.create(
            <span class="hljs-type">OrderService</span>.class, 
            <span class="hljs-type">OrderService</span>$<span class="hljs-variable">$EnhancerByCGLIB</span>$<span class="hljs-variable">$1234</span>.class, 
            <span class="hljs-string">"(Ljava/lang/Long;)Lcom/example/entity/Order;"</span>, 
            <span class="hljs-string">"findOrderById"</span>, 
            <span class="hljs-string">"CGLIB$findOrderById$0"</span>
        );
        <span class="hljs-comment">// ...初始化其他MethodProxy</span>
    }

    <span class="hljs-comment">// 重写findOrderById方法</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">Order</span> findOrderById(<span class="hljs-type">Long</span> var1) {
        <span class="hljs-type">MethodInterceptor</span> var10000 <span class="hljs-operator">=</span> this.<span class="hljs-type">CGLIB</span><span class="hljs-variable">$CALLBACK_0</span>;
        <span class="hljs-keyword">if</span> (var10000 <span class="hljs-operator">==</span> null) {
            <span class="hljs-type">CGLIB</span><span class="hljs-variable">$BIND_CALLBACKS</span>(this);
            var10000 <span class="hljs-operator">=</span> this.<span class="hljs-type">CGLIB</span><span class="hljs-variable">$CALLBACK_0</span>;
        }

        <span class="hljs-comment">// 调用MethodInterceptor的intercept方法</span>
        <span class="hljs-keyword">return</span> var10000 <span class="hljs-operator">!=</span> null <span class="hljs-operator">?</span> (<span class="hljs-type">Order</span>)var10000.intercept(
            this, 
            <span class="hljs-type">CGLIB</span><span class="hljs-variable">$findOrderById</span><span class="hljs-variable">$0</span><span class="hljs-variable">$Method</span>, 
            new <span class="hljs-type">Object</span>[]{var1}, 
            <span class="hljs-type">CGLIB_findOrderById_0</span>
        ) : <span class="hljs-keyword">super</span>.findOrderById(var1);
    }

    <span class="hljs-comment">// 目标方法的快速调用方法（由MethodProxy调用）</span>
    <span class="hljs-keyword">final</span> <span class="hljs-type">Order</span> <span class="hljs-type">CGLIB</span><span class="hljs-variable">$findOrderById</span><span class="hljs-variable">$0</span>(<span class="hljs-type">Long</span> var1) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.findOrderById(var1);
    }

    <span class="hljs-comment">// ...其他重写方法和辅助方法</span>
}

<span class="hljs-type">AI写代码java</span>
运行
<span class="hljs-number">12345678910111213141516171819202122232425262728293031323334353637383940414243</span>
</code></pre>
<p>反编译后的代码显示，代理类OrderServiceE n h a n c e r B y C G L I B EnhancerByCGLIBEnhancerByCGLIB1234继承自OrderService，重写了findOrderById方法，方法内部调用了MethodInterceptor的intercept方法，这与我们之前的分析完全一致。</p>
<h2 data-id="heading-33"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第四章 对比与抉择：JDK与CGLib动态代理的核心差异</h2>
<p>JDK动态代理与CGLib动态代理是Spring AOP的两大核心支撑，它们在实现原理、适用场景、性能等方面存在显著差异，了解这些差异是开发者在实际开发中做出正确选择的关键。</p>
<h3 data-id="heading-34"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>4.1 核心差异对比</h3>
<p>下表从多个维度对比了JDK动态代理与CGLib动态代理的核心差异：</p>








































<table><thead><tr><th>对比维度</th><th>JDK动态代理</th><th>CGLib动态代理</th></tr></thead><tbody><tr><td>实现原理</td><td>基于Java反射机制，代理类实现目标接口，继承自Proxy类</td><td>基于ASM字节码框架，代理类继承目标类，重写非final方法</td></tr><tr><td>目标对象要求</td><td>必须实现至少一个接口</td><td>无接口要求，但不能是final类，目标方法不能是final方法</td></tr><tr><td>代理类结构</td><td>代理类 = 实现目标接口 + 继承Proxy类</td><td>代理类 = 继承目标类 + 实现Factory接口</td></tr><tr><td>方法调用方式</td><td>通过反射调用目标方法，性能相对较低</td><td>通过MethodProxy调用目标方法，避免反射，性能更高</td></tr><tr><td>依赖</td><td>依赖Java原生API，无需额外引入依赖</td><td>依赖CGLib和ASM框架，Spring已默认集成</td></tr><tr><td>适用场景</td><td>目标对象实现接口的场景（Spring AOP默认首选）</td><td>目标对象无接口的场景，或对性能要求较高的场景</td></tr></tbody></table>
<h3 data-id="heading-35"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>4.2 性能对比：谁更高效？</h3>
<p>关于JDK动态代理与CGLib动态代理的性能，长期存在争议。实际上，两者的性能差异与JDK版本密切相关：</p>
<ul>
<li><strong>JDK 8及之前版本</strong>：CGLib的性能优于JDK动态代理。因为JDK动态代理通过反射调用目标方法，而CGLib通过MethodProxy直接调用目标方法，避免了反射的性能开销；</li>
<li><strong>JDK 9及之后版本</strong>：JDK对反射机制进行了优化，JDK动态代理的性能大幅提升，与CGLib的性能差距缩小，甚至在某些场景下超过CGLib。</li>
</ul>
<p>为了直观对比两者的性能，我们设计一个简单的性能测试：分别通过JDK和CGLib代理，调用目标方法100万次，统计总耗时。测试代码如下（以JDK代理为例，CGLib类似）：</p>
<pre><code class="hljs language-ini" lang="ini">
public class ProxyPerformanceTest {
    public static void main(String<span class="hljs-section">[]</span> args) {
        // 测试次数
        int <span class="hljs-attr">count</span> = <span class="hljs-number">1000000</span><span class="hljs-comment">;</span>

        // JDK动态代理性能测试
        UserService <span class="hljs-attr">jdkTarget</span> = new UserServiceImpl()<span class="hljs-comment">;</span>
        UserService <span class="hljs-attr">jdkProxy</span> = (UserService) Proxy.newProxyInstance(
            jdkTarget.getClass().getClassLoader(),
            jdkTarget.getClass().getInterfaces(),
            new LogInvocationHandler(jdkTarget)
        )<span class="hljs-comment">;</span>
        long <span class="hljs-attr">jdkStart</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
        for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; count; i++) {</span>
            jdkProxy.findUserById(1L)<span class="hljs-comment">;</span>
        }
        long <span class="hljs-attr">jdkEnd</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
        System.out.println("JDK动态代理100万次调用耗时：" + (jdkEnd - jdkStart) + "ms")<span class="hljs-comment">;</span>

        // CGLib动态代理性能测试
        OrderService <span class="hljs-attr">cglibTarget</span> = new OrderService()<span class="hljs-comment">;</span>
        Enhancer <span class="hljs-attr">enhancer</span> = new Enhancer()<span class="hljs-comment">;</span>
        enhancer.setSuperclass(OrderService.class)<span class="hljs-comment">;</span>
        enhancer.setCallback(new LogMethodInterceptor())<span class="hljs-comment">;</span>
        OrderService <span class="hljs-attr">cglibProxy</span> = (OrderService) enhancer.create()<span class="hljs-comment">;</span>
        long <span class="hljs-attr">cglibStart</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
        for (int <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; count; i++) {</span>
            cglibProxy.findOrderById(1L)<span class="hljs-comment">;</span>
        }
        long <span class="hljs-attr">cglibEnd</span> = System.currentTimeMillis()<span class="hljs-comment">;</span>
        System.out.println("CGLib动态代理100万次调用耗时：" + (cglibEnd - cglibStart) + "ms")<span class="hljs-comment">;</span>
    }
}

AI写代码java
运行
12345678910111213141516171819202122232425262728293031323334
</code></pre>
<p>在JDK 8环境下的测试结果（仅供参考）：</p>
<pre><code class="hljs language-arduino" lang="arduino">
JDK动态代理<span class="hljs-number">100</span>万次调用耗时：<span class="hljs-number">120</span>ms
CGLib动态代理<span class="hljs-number">100</span>万次调用耗时：<span class="hljs-number">80</span>ms

AI写代码text
<span class="hljs-number">123</span>
</code></pre>
<p>在JDK 11环境下的测试结果（仅供参考）：</p>
<pre><code class="hljs language-arduino" lang="arduino">
JDK动态代理<span class="hljs-number">100</span>万次调用耗时：<span class="hljs-number">75</span>ms
CGLib动态代理<span class="hljs-number">100</span>万次调用耗时：<span class="hljs-number">82</span>ms

AI写代码text
<span class="hljs-number">123</span>
</code></pre>
<p>从测试结果可以看出，JDK版本对两者的性能影响很大。在实际开发中，无需过度纠结于性能差异——除非是高频调用的核心接口，否则两者的性能差距对系统整体影响微乎其微。选择代理方式的核心依据应是目标对象是否实现接口。</p>
<h3 data-id="heading-36"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>4.3 Spring AOP的代理选择策略</h3>
<p>Spring AOP作为成熟的框架，并没有强制要求使用某一种代理方式，而是根据目标对象的类型自动选择合适的代理方式，其核心选择策略如下：</p>
<ol>
<li><strong>优先使用JDK动态代理</strong>：如果目标对象实现了至少一个接口，Spring AOP默认使用JDK动态代理，生成的代理对象是目标接口的实现类；</li>
<li><strong>自动切换为CGLib</strong>：如果目标对象没有实现任何接口，Spring AOP会自动切换为CGLib动态代理，生成的代理对象是目标类的子类；</li>
<li><strong>强制使用CGLib</strong>：开发者可以通过配置强制Spring AOP使用CGLib代理，即使目标对象实现了接口。在Spring Boot 2.x中，可通过如下配置实现：<br/>
<code>spring: aop: proxy-target-class: true # true表示强制使用CGLib代理，false表示优先使用JDK代理</code></li>
</ol>
<p>需要注意的是，Spring Boot 2.x版本中，proxy-target-class的默认值为true——这意味着即使目标对象实现了接口，Spring AOP也会默认使用CGLib代理。这一变化的原因是Spring团队认为，CGLib代理在易用性（无接口要求）和性能（JDK 8及以下版本）上更具优势，同时避免了JDK代理只能代理接口的限制。</p>
<h2 data-id="heading-37"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第五章 Spring AOP的整体执行流程：从切面定义到方法调用</h2>
<p>前面我们分别剖析了JDK和CGLib动态代理的实现原理，而Spring AOP的整体执行流程是将这两种代理技术与切面定义、切入点匹配等逻辑结合起来的完整链路。理解这一流程，能帮助我们从宏观上把握Spring AOP的工作机制。</p>
<h3 data-id="heading-38"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.1 Spring AOP核心执行流程</h3>
<p>Spring AOP的核心执行流程可分为"初始化阶段"和"运行阶段"两个部分，每个阶段包含多个关键步骤：</p>
<h4 data-id="heading-39"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.1.1 初始化阶段：解析切面并准备代理</h4>
<p>初始化阶段发生在Spring容器启动时，核心任务是解析切面定义、生成切入点，并为目标对象准备代理逻辑。具体步骤如下：</p>
<ol>
<li><strong>扫描切面类</strong>：Spring容器启动时，通过@ComponentScan注解扫描带有@Aspect注解的切面类，将其注册为Spring Bean；</li>
<li><strong>解析切入点表达式</strong>：Spring解析切面类中@Pointcut注解定义的切入点表达式，将其转换为Pointcut对象，用于后续匹配目标方法；</li>
<li><strong>解析通知</strong>：解析切面类中带有@Before、@After等注解的通知方法，将其与对应的切入点关联，形成Advisor对象（Advisor = 切入点 + 通知）；</li>
<li><strong>识别目标对象</strong>：Spring容器扫描业务类（如带有@Service注解的类），识别需要被代理的目标对象；</li>
<li><strong>匹配Advisor</strong>：根据目标对象的方法，匹配与之对应的Advisor（即判断目标方法是否符合切入点表达式）；</li>
<li><strong>创建代理工厂</strong>：为匹配到Advisor的目标对象创建ProxyFactory（代理工厂），ProxyFactory封装了目标对象、Advisor等信息，负责生成代理对象。</li>
</ol>
<h4 data-id="heading-40"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.1.2 运行阶段：代理对象介导的方法调用</h4>
<p>运行阶段发生在客户端调用目标对象方法时，核心任务是通过代理对象执行通知逻辑和目标方法。具体步骤如下：</p>
<ol>
<li><strong>获取代理对象</strong>：客户端从Spring容器中获取目标对象时，容器返回的不是目标对象本身，而是由ProxyFactory生成的代理对象（JDK或CGLib代理）；</li>
<li><strong>触发代理方法</strong>：客户端调用代理对象的方法，代理对象的方法逻辑被触发（JDK代理调用InvocationHandler.invoke，CGLib代理调用MethodInterceptor.intercept）；</li>
<li><strong>获取匹配的通知链</strong>：代理对象根据当前调用的方法，从ProxyFactory中获取与之匹配的Advisor链，将其转换为通知链（MethodInterceptor链）；</li>
<li><strong>执行通知链</strong>：按照通知的类型和顺序，依次执行通知链中的通知逻辑。例如，先执行@Before通知，再执行目标方法，最后执行@After通知；</li>
<li><strong>调用目标方法</strong>：通知链执行到最后，通过反射或MethodProxy调用目标对象的原始方法；</li>
<li><strong>返回结果</strong>：将目标方法的返回值通过代理对象返回给客户端，完成整个调用流程。</li>
</ol>
<h3 data-id="heading-41"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.2 结合Spring注解的完整案例</h3>
<p>为了让大家更直观地理解Spring AOP的整体执行流程，下面我们通过一个完整的Spring Boot案例，展示从切面定义到方法调用的全过程。</p>
<h4 data-id="heading-42"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.2.1 步骤1：创建Spring Boot项目并引入依赖</h4>
<p>创建Spring Boot项目，引入spring-boot-starter-web和spring-boot-starter-aop依赖：</p>
<pre><code class="hljs language-xml" lang="xml">
<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

AI写代码xml
1234567891011
</code></pre>
<h4 data-id="heading-43"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>5.2.2 步骤2：定义切面类</h4>
<p>创建LogAspect切面类，定义切入点和五种类型的通知：</p>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;
<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-comment">// 切面类：日志切面</span>
<span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> {
    <span class="hljs-comment">// 切入点：匹配com.example.service包下所有类的所有方法</span>
    <span class="hljs-meta">@Pointcut("execution(* com.example.service.*.*(..))")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePointcut</span><span class="hljs-params">()</span> {}

    <span class="hljs-comment">// 前置通知</span>
    <span class="hljs-meta">@Before("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">(JoinPoint joinPoint)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP前置通知】"</span> + LocalDateTime.now() + <span class="hljs-string">" 调用方法："</span> + methodName);
    }

    <span class="hljs-comment">// 后置通知</span>
    <span class="hljs-meta">@After("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterAdvice</span><span class="hljs-params">(JoinPoint joinPoint)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP后置通知】方法"</span> + methodName + <span class="hljs-string">"调用结束"</span>);
    }

    <span class="hljs-comment">// 返回通知</span>
    <span class="hljs-meta">@AfterReturning(value = "servicePointcut()", returning = "result")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturningAdvice</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP返回通知】方法"</span> + methodName + <span class="hljs-string">"返回值："</span> + (result == <span class="hljs-literal">null</span> ? <span class="hljs-string">"无"</span> : result));
    }

    <span class="hljs-comment">// 异常通知</span>
    <span class="hljs-meta">@AfterThrowing(value = "servicePointcut()", throwing = "ex")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowingAdvice</span><span class="hljs-params">(JoinPoint joinPoint, Exception ex)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP异常通知】方法"</span> + methodName + <span class="hljs-string">"抛出异常："</span> + ex.getMessage());
    }

    <span class="hljs-comment">// 环绕通知</span>
    <span class="hljs-meta">@Around("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundAdvice</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-前】"</span> + LocalDateTime.now() + <span class="hljs-string">" 准备调用方法："</span> + methodName);
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 执行目标方法</span>
            result = joinPoint.proceed();
            System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-后】方法"</span> + methodName + <span class="hljs-string">"执行完成"</span>);
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-异常】方法"</span> + methodName + <span class="hljs-string">"执行异常："</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> e;
        }
        <span class="hljs-keyword">return</span> result;
    }
}

AI写代码Plain
<span class="hljs-number">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859</span>
</code></pre>
<pre><code class="hljs language-java" lang="java">
<span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;
<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> java.time.LocalDateTime;

<span class="hljs-comment">// 切面类：日志切面</span>
<span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> {
    <span class="hljs-comment">// 切入点：匹配com.example.service包下所有类的所有方法</span>
    <span class="hljs-meta">@Pointcut("execution(* com.example.service.*.*(..))")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">servicePointcut</span><span class="hljs-params">()</span> {}

    <span class="hljs-comment">// 前置通知</span>
    <span class="hljs-meta">@Before("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeAdvice</span><span class="hljs-params">(JoinPoint joinPoint)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP前置通知】"</span> + LocalDateTime.now() + <span class="hljs-string">" 调用方法："</span> + methodName);
    }

    <span class="hljs-comment">// 后置通知</span>
    <span class="hljs-meta">@After("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterAdvice</span><span class="hljs-params">(JoinPoint joinPoint)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP后置通知】方法"</span> + methodName + <span class="hljs-string">"调用结束"</span>);
    }

    <span class="hljs-comment">// 返回通知</span>
    <span class="hljs-meta">@AfterReturning(value = "servicePointcut()", returning = "result")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturningAdvice</span><span class="hljs-params">(JoinPoint joinPoint, Object result)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP返回通知】方法"</span> + methodName + <span class="hljs-string">"返回值："</span> + (result == <span class="hljs-literal">null</span> ? <span class="hljs-string">"无"</span> : result));
    }

    <span class="hljs-comment">// 异常通知</span>
    <span class="hljs-meta">@AfterThrowing(value = "servicePointcut()", throwing = "ex")</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowingAdvice</span><span class="hljs-params">(JoinPoint joinPoint, Exception ex)</span> {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP异常通知】方法"</span> + methodName + <span class="hljs-string">"抛出异常："</span> + ex.getMessage());
    }

    <span class="hljs-comment">// 环绕通知</span>
    <span class="hljs-meta">@Around("servicePointcut()")</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">aroundAdvice</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable {
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-前】"</span> + LocalDateTime.now() + <span class="hljs-string">" 准备调用方法："</span> + methodName);
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 执行目标方法</span>
            result = joinPoint.proceed();
            System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-后】方法"</span> + methodName + <span class="hljs-string">"执行完成"</span>);
        } <span class="hljs-keyword">catch</span> (Throwable e) {
            System.out.println(<span class="hljs-string">"【Spring AOP环绕通知-异常】方法"</span> + methodName + <span class="hljs-string">"执行异常："</span> + e.getMessage());
            <span class="hljs-keyword">throw</span> e;
        }
        <span class="hljs-keyword">return</span> result;
    }
}


AI写代码Plain
<span class="hljs-number">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960</span>
</code></pre>
<h2 data-id="heading-44"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>第六章 总结：Spring AOP的核心启示与实践指南</h2>
<p>本文通过从基础概念到底层实现、从理论解析到实战案例的层层递进，全面剖析了Spring AOP的核心原理与实践应用。从AOP解决的代码痛点出发，我们深入理解了其“横切编程”的本质，掌握了切面、通知、切入点等核心概念，并重点拆解了支撑Spring AOP的两大动态代理技术——JDK与CGLib动态代理，最终梳理了Spring AOP的完整执行链路。这些内容不仅揭示了技术的底层逻辑，更能为实际开发提供清晰的指引。</p>
<h3 data-id="heading-45"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.1 核心知识体系梳理</h3>
<p>Spring AOP的知识体系可归纳为“一个核心目标、两大技术支撑、三个核心环节”：</p>
<ul>
<li><strong>一个核心目标</strong>：通过“业务逻辑”与“通用功能”的解耦，提升代码复用性与可维护性。AOP将日志、事务、权限等横切逻辑抽象为切面，避免了代码冗余，使开发者能聚焦核心业务开发。</li>
<li><strong>两大技术支撑</strong>：JDK动态代理与CGLib动态代理构成了Spring AOP的技术基石。两者基于不同的实现原理（接口实现vs类继承），形成互补：JDK代理依赖接口，无需额外依赖，在JDK 9+版本性能优异；CGLib代理通过继承实现，无接口限制，在JDK 8及以下版本性能更具优势。</li>
<li><strong>三个核心环节</strong>：Spring AOP的工作流程可概括为“切面解析与准备”“代理对象生成”“方法调用与通知执行”。初始化阶段，Spring容器完成切面扫描、切入点解析与Advisor组装；运行阶段，代理对象作为中介，按顺序执行通知逻辑与目标方法，实现横切功能的织入。</li>
</ul>
<h3 data-id="heading-46"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.2 关键实践决策指南</h3>
<p>基于前文的技术对比与原理分析，在实际开发中使用Spring AOP时，可遵循以下决策原则：</p>
<h4 data-id="heading-47"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.2.1 代理方式选择</h4>
<p>Spring AOP的代理选择已实现自动化，但开发者需明确其逻辑并根据场景调整：</p>
<ul>
<li>默认场景：Spring Boot 2.x及以上版本默认启用<code>proxy-target-class: true</code>，优先使用CGLib代理，覆盖接口与无接口两种场景，降低使用成本；</li>
<li>接口优先场景：若项目采用“面向接口编程”规范，且使用JDK 9+版本，可配置为JDK代理，利用其原生支持与优化后的性能；</li>
<li>特殊限制场景：若目标类为final类或包含final方法，CGLib无法代理，需确保目标类实现接口以使用JDK代理。</li>
</ul>
<h4 data-id="heading-48"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.2.2 切面设计与使用</h4>
<p>切面设计的合理性直接影响系统的可维护性，需注意以下几点：</p>
<ul>
<li>单一职责：一个切面聚焦一类横切功能（如日志切面仅处理日志记录，事务切面仅管理事务），避免切面逻辑臃肿；</li>
<li>切入点精准：通过execution表达式精准匹配目标方法，避免“过度代理”。例如，仅对service层的业务方法织入事务切面，而非所有层的方法；</li>
<li>通知类型适配：根据需求选择合适的通知类型——环绕通知功能最全面，可控制方法执行与异常处理；前置/后置通知适用于简单的日志记录；返回/异常通知则针对性处理方法结果与异常场景。</li>
</ul>
<h4 data-id="heading-49"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.2.3 性能优化建议</h4>
<p>虽然Spring AOP的性能开销通常可忽略，但在高频调用场景下仍需优化：</p>
<ul>
<li>减少代理对象创建：Spring容器会缓存代理对象，避免频繁创建；</li>
<li>优化切入点表达式：避免使用过于宽泛的表达式（如<code>execution(* *(..))</code>），减少方法匹配的性能消耗；</li>
<li>控制通知逻辑复杂度：通知代码应简洁高效，避免在通知中执行耗时操作（如复杂IO、数据库查询），必要时通过异步处理优化。</li>
</ul>
<h3 data-id="heading-50"><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/><a href="https://link.juejin.cn?target=" title="" ref="nofollow noopener noreferrer"/>6.3 技术本质与未来启示</h3>
<p>从技术本质来看，Spring AOP是“动态代理”与“依赖注入”的结合产物——动态代理实现了方法增强的技术能力，依赖注入则实现了切面与目标对象的解耦与管理。这种“技术组合”的思路，为解决复杂问题提供了典范。</p>
<p>随着Spring框架的发展，AOP的实现也在不断优化，但核心思想始终未变。对于开发者而言，掌握底层原理远比单纯使用API更重要：理解动态代理的字节码生成逻辑，能快速定位代理相关的异常；明晰通知的执行顺序，可避免切面逻辑冲突；掌握切入点表达式的语法，能精准控制切面作用范围。这些能力不仅适用于Spring AOP，更能迁移到其他需要“方法增强”的场景（如RPC框架的调用增强、分布式追踪的链路埋点等）。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[三极管推挽输出电路分析]]></title>    <link>https://juejin.cn/post/7603721514203332617</link>    <guid>https://juejin.cn/post/7603721514203332617</guid>    <pubDate>2026-02-08T06:52:43.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603721514203332617" data-draft-id="7603687444052082726" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="三极管推挽输出电路分析"/> <meta itemprop="keywords" content="嵌入式,后端"/> <meta itemprop="datePublished" content="2026-02-08T06:52:43.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="程序员良许"/> <meta itemprop="url" content="https://juejin.cn/user/3913917128246942"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            三极管推挽输出电路分析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3913917128246942/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    程序员良许
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:52:43.000Z" title="Sun Feb 08 2026 06:52:43 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">三极管推挽输出电路分析</h2>
<p>大家好，我是良许。</p>
<p>在嵌入式系统开发中，我们经常需要驱动各种负载，比如 LED、继电器、电机等。</p>
<p>这时候，单纯依靠 MCU 的 IO 口往往无法提供足够的驱动能力。</p>
<p>推挽输出电路作为一种经典的功率放大电路，在实际项目中应用非常广泛。</p>
<p>今天我们就来深入分析一下三极管推挽输出电路的工作原理和实际应用。</p>
<h3 data-id="heading-1">1. 推挽电路的基本概念</h3>
<h4 data-id="heading-2">1.1 什么是推挽电路</h4>
<p>推挽电路是一种由两个三极管组成的互补输出电路。</p>
<p>这两个三极管一个负责"推"，即向负载提供电流；另一个负责"挽"，即从负载吸收电流。</p>
<p>这种结构使得电路能够在正负两个方向上都提供强大的驱动能力。</p>
<p>与普通的单管放大电路相比，推挽电路最大的优势在于输出阻抗低、驱动能力强、效率高。</p>
<p>在我之前做汽车电子项目时，就经常使用推挽电路来驱动车载继电器和指示灯，效果非常好。</p>
<h4 data-id="heading-3">1.2 推挽电路的分类</h4>
<p>推挽电路主要分为两种类型：</p>
<p><strong>互补型推挽电路</strong>：使用 NPN 和 PNP 两种不同类型的三极管，这是最常见的推挽电路形式。</p>
<p>当输入高电平时，NPN 管导通，PNP 管截止；当输入低电平时，PNP 管导通，NPN 管截止。</p>
<p><strong>同类型推挽电路</strong>：使用两个相同类型的三极管，通过变压器或其他方式实现互补工作。</p>
<p>这种电路在音频功放中比较常见。</p>
<h3 data-id="heading-4">2. 互补型推挽电路的工作原理</h3>
<h4 data-id="heading-5">2.1 电路结构分析</h4>
<p>互补型推挽电路的典型结构如下：输入信号同时送到 NPN 管和 PNP 管的基极，NPN 管的发射极和 PNP 管的发射极连接在一起作为输出端，NPN 管的集电极接正电源，PNP 管的集电极接地。</p>
<p>让我给大家画个简单的原理图来说明。</p>
<p>假设我们使用 STM32 的 GPIO 口来控制一个推挽电路驱动 LED：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// STM32 HAL库配置GPIO为推挽输出</span>
void <span class="hljs-built_in">MX_GPIO_Init</span>(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {<span class="hljs-number">0</span>};
    
    <span class="hljs-comment">// 使能GPIOA时钟</span>
    <span class="hljs-built_in">__HAL_RCC_GPIOA_CLK_ENABLE</span>();
    
    <span class="hljs-comment">// 配置PA5为推挽输出</span>
    GPIO_InitStruct<span class="hljs-selector-class">.Pin</span> = GPIO_PIN_5;
    GPIO_InitStruct<span class="hljs-selector-class">.Mode</span> = GPIO_MODE_OUTPUT_PP;  <span class="hljs-comment">// 推挽输出模式</span>
    GPIO_InitStruct<span class="hljs-selector-class">.Pull</span> = GPIO_NOPULL;
    GPIO_InitStruct<span class="hljs-selector-class">.Speed</span> = GPIO_SPEED_FREQ_LOW;
    <span class="hljs-built_in">HAL_GPIO_Init</span>(GPIOA, &amp;GPIO_InitStruct);
}
​
<span class="hljs-comment">// 控制输出</span>
void <span class="hljs-built_in">LED_Control</span>(uint8_t state)
{
    <span class="hljs-built_in">if</span>(state) {
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);   <span class="hljs-comment">// 输出高电平</span>
    } else {
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); <span class="hljs-comment">// 输出低电平</span>
    }
}
</code></pre>
<h4 data-id="heading-6">2.2 工作过程详解</h4>
<p>当输入信号为高电平时，NPN 管的基极电压升高，基极-发射极之间形成正向偏置，NPN 管导通。</p>
<p>此时，电流从正电源经过 NPN 管的集电极-发射极流向负载，负载两端获得接近电源电压的高电平。</p>
<p>同时，PNP 管的基极相对于发射极为正电压，基极-发射极之间反向偏置，PNP 管截止。</p>
<p>当输入信号为低电平时，情况正好相反。</p>
<p>NPN 管的基极电压降低，基极-发射极之间电压不足以使其导通，NPN 管截止。</p>
<p>而 PNP 管的基极相对于发射极变为负电压，基极-发射极之间正向偏置，PNP 管导通。</p>
<p>此时，电流从负载经过 PNP 管的发射极-集电极流向地，负载两端获得接近地电位的低电平。</p>
<p>这种工作方式的巧妙之处在于，无论输出高电平还是低电平，都有一个三极管处于导通状态，提供低阻抗的电流通路。</p>
<p>这就是推挽电路驱动能力强的根本原因。</p>
<h4 data-id="heading-7">2.3 关键参数计算</h4>
<p>在设计推挽电路时，我们需要计算几个关键参数。</p>
<p>首先是基极限流电阻的选择。</p>
<p>假设我们使用的三极管放大倍数 <em>β</em>=100，负载电流 <em>IL</em>=100<em>mA</em>，那么基极电流需要：</p>
<p><em>IB</em>=<em>IB/β=100</em>mA/100=1<em>m</em>A</p>
<p>如果输入电压为 5V，三极管基极-发射极压降 VBE = 0.7V，则基极限流电阻为：</p>
<p>RB = (VIN - VBE)/IB= (5V - 0.7V)/1mA= 4.3<em>k</em>Ω</p>
<p>实际应用中，我们通常选择标准阻值 4.7<em>k</em>Ω 或 3.9<em>k</em>Ω</p>
<h3 data-id="heading-8">3. 实际应用电路设计</h3>
<h4 data-id="heading-9">3.1 LED 驱动电路</h4>
<p>在嵌入式项目中，我们经常需要驱动大功率 LED。</p>
<p>下面是一个使用推挽电路驱动 LED 的完整示例：</p>
<pre><code class="hljs language-ini" lang="ini">// 硬件连接：
// STM32 PA5 -&gt; R1(4.7k) -&gt; Q1(NPN)基极
// STM32 PA5 -&gt; R2(4.7k) -&gt; Q2(PNP)基极
// Q1集电极 -&gt; VCC(12V)
// Q2集电极 -&gt; GND
// Q1发射极 = Q2发射极 -&gt; LED正极
// LED负极 -&gt; R3(限流电阻) -&gt; GND
​
<span class="hljs-comment">#define LED_PIN GPIO_PIN_5</span>
<span class="hljs-comment">#define LED_PORT GPIOA</span>
​
// 初始化LED驱动
void LED_Driver_Init(void)
{
    GPIO_InitTypeDef <span class="hljs-attr">GPIO_InitStruct</span> = {<span class="hljs-number">0</span>}<span class="hljs-comment">;</span>
    
    __HAL_RCC_GPIOA_CLK_ENABLE()<span class="hljs-comment">;</span>
    
    <span class="hljs-attr">GPIO_InitStruct.Pin</span> = LED_PIN<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Mode</span> = GPIO_MODE_OUTPUT_PP<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Pull</span> = GPIO_NOPULL<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Speed</span> = GPIO_SPEED_FREQ_MEDIUM<span class="hljs-comment">;</span>
    HAL_GPIO_Init(LED_PORT, &amp;GPIO_InitStruct)<span class="hljs-comment">;</span>
    
    // 初始状态设为低电平
    HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_RESET)<span class="hljs-comment">;</span>
}
​
// PWM调光控制
void LED_PWM_Control(uint8_t brightness)
{
    // brightness: 0-100，表示亮度百分比
    uint16_t <span class="hljs-attr">period</span> = <span class="hljs-number">1000</span><span class="hljs-comment">;  // PWM周期，单位us</span>
    uint16_t <span class="hljs-attr">pulse_width</span> = (period * brightness) / <span class="hljs-number">100</span><span class="hljs-comment">;</span>
    
    for(uint16_t <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; period; i++) {</span>
        if(i &lt; pulse_width) {
            HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_SET)<span class="hljs-comment">;</span>
        } else {
            HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_RESET)<span class="hljs-comment">;</span>
        }
        // 延时1us（实际项目中应使用硬件PWM）
        delay_us(1)<span class="hljs-comment">;</span>
    }
}
​
// 使用硬件PWM的更优方案
void LED_Hardware_PWM_Init(void)
{
    TIM_HandleTypeDef htim2<span class="hljs-comment">;</span>
    TIM_OC_InitTypeDef <span class="hljs-attr">sConfigOC</span> = {<span class="hljs-number">0</span>}<span class="hljs-comment">;</span>
    
    // 配置定时器2
    <span class="hljs-attr">htim2.Instance</span> = TIM2<span class="hljs-comment">;</span>
    <span class="hljs-attr">htim2.Init.Prescaler</span> = <span class="hljs-number">72</span>-<span class="hljs-number">1</span><span class="hljs-comment">;  // 假设系统时钟72MHz</span>
    <span class="hljs-attr">htim2.Init.CounterMode</span> = TIM_COUNTERMODE_UP<span class="hljs-comment">;</span>
    <span class="hljs-attr">htim2.Init.Period</span> = <span class="hljs-number">1000</span>-<span class="hljs-number">1</span><span class="hljs-comment">;   // PWM频率1kHz</span>
    <span class="hljs-attr">htim2.Init.ClockDivision</span> = TIM_CLOCKDIVISION_DIV1<span class="hljs-comment">;</span>
    HAL_TIM_PWM_Init(&amp;htim2)<span class="hljs-comment">;</span>
    
    // 配置PWM通道
    <span class="hljs-attr">sConfigOC.OCMode</span> = TIM_OCMODE_PWM1<span class="hljs-comment">;</span>
    <span class="hljs-attr">sConfigOC.Pulse</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    <span class="hljs-attr">sConfigOC.OCPolarity</span> = TIM_OCPOLARITY_HIGH<span class="hljs-comment">;</span>
    <span class="hljs-attr">sConfigOC.OCFastMode</span> = TIM_OCFAST_DISABLE<span class="hljs-comment">;</span>
    HAL_TIM_PWM_ConfigChannel(&amp;htim2, &amp;sConfigOC, TIM_CHANNEL_1)<span class="hljs-comment">;</span>
    
    // 启动PWM
    HAL_TIM_PWM_Start(&amp;htim2, TIM_CHANNEL_1)<span class="hljs-comment">;</span>
}
​
void LED_Set_Brightness(uint8_t brightness)
{
    // 设置占空比
    __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, brightness * 10)<span class="hljs-comment">;</span>
}
</code></pre>
<h4 data-id="heading-10">3.2 继电器驱动电路</h4>
<p>在工业控制和汽车电子中，继电器是常用的开关器件。</p>
<p>推挽电路可以提供足够的驱动电流来可靠地控制继电器。</p>
<p>下面是一个继电器驱动的实现：</p>
<pre><code class="hljs language-ini" lang="ini">// 继电器驱动电路
// 硬件连接：
// STM32 PB0 -&gt; 推挽驱动电路 -&gt; 继电器线圈
// 继电器线圈并联续流二极管
​
<span class="hljs-comment">#define RELAY_PIN GPIO_PIN_0</span>
<span class="hljs-comment">#define RELAY_PORT GPIOB</span>
​
typedef struct {
    GPIO_TypeDef* port<span class="hljs-comment">;</span>
    uint16_t pin<span class="hljs-comment">;</span>
    uint8_t state<span class="hljs-comment">;</span>
    uint32_t last_toggle_time<span class="hljs-comment">;</span>
} Relay_TypeDef<span class="hljs-comment">;</span>
​
Relay_TypeDef <span class="hljs-attr">relay1</span> = {
    .<span class="hljs-attr">port</span> = RELAY_PORT,
    .<span class="hljs-attr">pin</span> = RELAY_PIN,
    .<span class="hljs-attr">state</span> = <span class="hljs-number">0</span>,
    .<span class="hljs-attr">last_toggle_time</span> = <span class="hljs-number">0</span>
}<span class="hljs-comment">;</span>
​
// 初始化继电器
void Relay_Init(Relay_TypeDef* relay)
{
    GPIO_InitTypeDef <span class="hljs-attr">GPIO_InitStruct</span> = {<span class="hljs-number">0</span>}<span class="hljs-comment">;</span>
    
    // 使能时钟
    if(relay-&gt;<span class="hljs-attr">port</span> == GPIOB) {
        __HAL_RCC_GPIOB_CLK_ENABLE()<span class="hljs-comment">;</span>
    }
    
    <span class="hljs-attr">GPIO_InitStruct.Pin</span> = relay-&gt;pin<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Mode</span> = GPIO_MODE_OUTPUT_PP<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Pull</span> = GPIO_NOPULL<span class="hljs-comment">;</span>
    <span class="hljs-attr">GPIO_InitStruct.Speed</span> = GPIO_SPEED_FREQ_LOW<span class="hljs-comment">;</span>
    HAL_GPIO_Init(relay-&gt;port, &amp;GPIO_InitStruct)<span class="hljs-comment">;</span>
    
    // 初始状态关闭
    HAL_GPIO_WritePin(relay-&gt;port, relay-&gt;pin, GPIO_PIN_RESET)<span class="hljs-comment">;</span>
    relay-&gt;<span class="hljs-attr">state</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
}
​
// 继电器控制（带防抖动）
void Relay_Control(Relay_TypeDef* relay, uint8_t state)
{
    uint32_t <span class="hljs-attr">current_time</span> = HAL_GetTick()<span class="hljs-comment">;</span>
    
    // 防止频繁切换，至少间隔100ms
    if(current_time - relay-&gt;last_toggle_time &lt; 100) {
        return<span class="hljs-comment">;</span>
    }
    
    if(state &amp;&amp; !relay-&gt;state) {
        // 打开继电器
        HAL_GPIO_WritePin(relay-&gt;port, relay-&gt;pin, GPIO_PIN_SET)<span class="hljs-comment">;</span>
        relay-&gt;<span class="hljs-attr">state</span> = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
        relay-&gt;<span class="hljs-attr">last_toggle_time</span> = current_time<span class="hljs-comment">;</span>
    } else if(!state &amp;&amp; relay-&gt;state) {
        // 关闭继电器
        HAL_GPIO_WritePin(relay-&gt;port, relay-&gt;pin, GPIO_PIN_RESET)<span class="hljs-comment">;</span>
        relay-&gt;<span class="hljs-attr">state</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
        relay-&gt;<span class="hljs-attr">last_toggle_time</span> = current_time<span class="hljs-comment">;</span>
    }
}
​
// 继电器状态读取
uint8_t Relay_Get_State(Relay_TypeDef* relay)
{
    return relay-&gt;state<span class="hljs-comment">;</span>
}
​
// 继电器翻转
void Relay_Toggle(Relay_TypeDef* relay)
{
    Relay_Control(relay, !relay-&gt;state)<span class="hljs-comment">;</span>
}
</code></pre>
<h4 data-id="heading-11">3.3 电机驱动电路</h4>
<p>推挽电路也常用于小功率直流电机的驱动。</p>
<p>通过 PWM 控制可以实现电机调速：</p>
<pre><code class="hljs language-ini" lang="ini">// 电机驱动
<span class="hljs-comment">#define MOTOR_PIN GPIO_PIN_6</span>
<span class="hljs-comment">#define MOTOR_PORT GPIOA</span>
<span class="hljs-comment">#define MOTOR_TIMER TIM3</span>
<span class="hljs-comment">#define MOTOR_CHANNEL TIM_CHANNEL_1</span>
​
typedef struct {
    TIM_HandleTypeDef* htim<span class="hljs-comment">;</span>
    uint32_t channel<span class="hljs-comment">;</span>
    uint8_t speed<span class="hljs-comment">;      // 0-100</span>
    uint8_t direction<span class="hljs-comment">;  // 0:正转, 1:反转</span>
} Motor_TypeDef<span class="hljs-comment">;</span>
​
Motor_TypeDef motor1<span class="hljs-comment">;</span>
​
// 电机初始化
void Motor_Init(Motor_TypeDef* motor, TIM_HandleTypeDef* htim, uint32_t channel)
{
    motor-&gt;<span class="hljs-attr">htim</span> = htim<span class="hljs-comment">;</span>
    motor-&gt;<span class="hljs-attr">channel</span> = channel<span class="hljs-comment">;</span>
    motor-&gt;<span class="hljs-attr">speed</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    motor-&gt;<span class="hljs-attr">direction</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>
    
    // 启动PWM
    HAL_TIM_PWM_Start(motor-&gt;htim, motor-&gt;channel)<span class="hljs-comment">;</span>
}
​
// 设置电机速度
void Motor_Set_Speed(Motor_TypeDef* motor, uint8_t speed)
{
    if(speed &gt; 100) <span class="hljs-attr">speed</span> = <span class="hljs-number">100</span><span class="hljs-comment">;</span>
    
    motor-&gt;<span class="hljs-attr">speed</span> = speed<span class="hljs-comment">;</span>
    
    // 计算PWM占空比
    uint32_t <span class="hljs-attr">pulse</span> = (motor-&gt;htim-&gt;Init.Period * speed) / <span class="hljs-number">100</span><span class="hljs-comment">;</span>
    __HAL_TIM_SET_COMPARE(motor-&gt;htim, motor-&gt;channel, pulse)<span class="hljs-comment">;</span>
}
​
// 设置电机方向
void Motor_Set_Direction(Motor_TypeDef* motor, uint8_t direction)
{
    motor-&gt;<span class="hljs-attr">direction</span> = direction<span class="hljs-comment">;</span>
    // 这里需要配合H桥电路来实现方向控制
}
​
// 电机启动
void Motor_Start(Motor_TypeDef* motor, uint8_t speed, uint8_t direction)
{
    Motor_Set_Direction(motor, direction)<span class="hljs-comment">;</span>
    Motor_Set_Speed(motor, speed)<span class="hljs-comment">;</span>
}
​
// 电机停止
void Motor_Stop(Motor_TypeDef* motor)
{
    Motor_Set_Speed(motor, 0)<span class="hljs-comment">;</span>
}
​
// 电机加速
void Motor_Accelerate(Motor_TypeDef* motor, uint8_t target_speed, uint16_t time_ms)
{
    uint8_t <span class="hljs-attr">current_speed</span> = motor-&gt;speed<span class="hljs-comment">;</span>
    uint16_t <span class="hljs-attr">steps</span> = time_ms / <span class="hljs-number">10</span><span class="hljs-comment">;  // 每10ms调整一次</span>
    int16_t <span class="hljs-attr">speed_increment</span> = (target_speed - current_speed) / steps<span class="hljs-comment">;</span>
    
    for(uint16_t <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; steps; i++) {</span>
        current_speed += speed_increment<span class="hljs-comment">;</span>
        Motor_Set_Speed(motor, current_speed)<span class="hljs-comment">;</span>
        HAL_Delay(10)<span class="hljs-comment">;</span>
    }
    
    Motor_Set_Speed(motor, target_speed)<span class="hljs-comment">;</span>
}
</code></pre>
<h3 data-id="heading-12">4. 推挽电路的优化设计</h3>
<h4 data-id="heading-13">4.1 交越失真的消除</h4>
<p>在互补推挽电路中，存在一个常见问题叫做交越失真。</p>
<p>当输入信号在零点附近时，两个三极管都处于临界导通状态，输出会出现非线性失真。</p>
<p>解决方法是在两个三极管的基极之间加入偏置电路，使它们始终处于微导通状态。</p>
<p>我们可以使用两个二极管串联来提供偏置电压：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 在实际电路中，我们需要在基极电路中加入偏置</span>
<span class="hljs-comment">// 这里通过软件方式模拟偏置效果</span>
​
<span class="hljs-selector-id">#define</span> BIAS_VOLTAGE <span class="hljs-number">0.6</span>  <span class="hljs-comment">// 偏置电压，单位V</span>
​
<span class="hljs-comment">// 带偏置的输出控制</span>
void <span class="hljs-built_in">Biased_Output_Control</span>(uint8_t level)
{
    <span class="hljs-comment">// 在实际硬件电路中实现偏置</span>
    <span class="hljs-comment">// 这里仅作示意</span>
    <span class="hljs-built_in">if</span>(level &gt; <span class="hljs-number">128</span>) {
        <span class="hljs-comment">// 输出高电平，考虑偏置</span>
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
    } else {
        <span class="hljs-comment">// 输出低电平，考虑偏置</span>
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
    }
}
</code></pre>
<h4 data-id="heading-14">4.2 过流保护设计</h4>
<p>在驱动大功率负载时，过流保护是必不可少的。</p>
<p>我们可以在电路中串联一个小阻值的采样电阻，通过 ADC 采集电压来监测电流：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 过流保护</span>
<span class="hljs-selector-id">#define</span> CURRENT_SENSE_PIN GPIO_PIN_0
<span class="hljs-selector-id">#define</span> CURRENT_SENSE_PORT GPIOA
<span class="hljs-selector-id">#define</span> MAX_CURRENT_MA <span class="hljs-number">500</span>  <span class="hljs-comment">// 最大电流500mA</span>
<span class="hljs-selector-id">#define</span> SENSE_RESISTOR <span class="hljs-number">0.1</span>  <span class="hljs-comment">// 采样电阻0.1欧姆</span>
​
typedef struct {
    ADC_HandleTypeDef* hadc;
    uint32_t channel;
    uint16_t max_current;
    uint8_t protection_enabled;
} Current_Protection_TypeDef;
​
Current_Protection_TypeDef current_protection;
​
<span class="hljs-comment">// 初始化过流保护</span>
void <span class="hljs-built_in">Current_Protection_Init</span>(Current_Protection_TypeDef* cp, ADC_HandleTypeDef* hadc, uint32_t channel)
{
    cp-&gt;hadc = hadc;
    cp-&gt;channel = channel;
    cp-&gt;max_current = MAX_CURRENT_MA;
    cp-&gt;protection_enabled = <span class="hljs-number">1</span>;
}
​
<span class="hljs-comment">// 读取电流值</span>
uint16_t <span class="hljs-built_in">Read_Current</span>(Current_Protection_TypeDef* cp)
{
    uint32_t adc_value;
    <span class="hljs-attribute">float</span> voltage, current;
    
    <span class="hljs-comment">// 启动ADC转换</span>
    <span class="hljs-built_in">HAL_ADC_Start</span>(cp-&gt;hadc);
    <span class="hljs-built_in">HAL_ADC_PollForConversion</span>(cp-&gt;hadc, <span class="hljs-number">100</span>);
    adc_value = <span class="hljs-built_in">HAL_ADC_GetValue</span>(cp-&gt;hadc);
    <span class="hljs-built_in">HAL_ADC_Stop</span>(cp-&gt;hadc);
    
    <span class="hljs-comment">// 计算电压和电流</span>
    <span class="hljs-comment">// 假设ADC参考电压3.3V，12位分辨率</span>
    voltage = (adc_value * <span class="hljs-number">3.3</span>) / <span class="hljs-number">4096.0</span>;
    current = voltage / SENSE_RESISTOR;  <span class="hljs-comment">// 单位：A</span>
    
    return (uint16_t)(current * <span class="hljs-number">1000</span>);  <span class="hljs-comment">// 转换为mA</span>
}
​
<span class="hljs-comment">// 过流检测</span>
uint8_t <span class="hljs-built_in">Check_Overcurrent</span>(Current_Protection_TypeDef* cp)
{
    <span class="hljs-built_in">if</span>(!cp-&gt;protection_enabled) return <span class="hljs-number">0</span>;
    
    uint16_t current = <span class="hljs-built_in">Read_Current</span>(cp);
    
    <span class="hljs-built_in">if</span>(current &gt; cp-&gt;max_current) {
        <span class="hljs-comment">// 检测到过流</span>
        return <span class="hljs-number">1</span>;
    }
    
    return <span class="hljs-number">0</span>;
}
​
<span class="hljs-comment">// 带过流保护的负载控制</span>
void <span class="hljs-built_in">Protected_Load_Control</span>(uint8_t state)
{
    <span class="hljs-built_in">if</span>(state) {
        <span class="hljs-comment">// 打开负载</span>
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
        
        <span class="hljs-comment">// 延时一小段时间后检测电流</span>
        <span class="hljs-built_in">HAL_Delay</span>(<span class="hljs-number">10</span>);
        
        <span class="hljs-built_in">if</span>(Check_Overcurrent(&amp;current_protection)) {
            <span class="hljs-comment">// 检测到过流，立即关闭输出</span>
            <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
            <span class="hljs-comment">// 记录错误日志或触发报警</span>
            <span class="hljs-built_in">Error_Handler</span>();
        }
    } else {
        <span class="hljs-comment">// 关闭负载</span>
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
    }
}
</code></pre>
<h4 data-id="heading-15">4.3 热保护设计</h4>
<p>大功率推挽电路工作时会产生热量，需要进行温度监测和保护：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-comment">// 温度保护</span>
<span class="hljs-selector-id">#define</span> TEMP_SENSOR_PIN GPIO_PIN_1
<span class="hljs-selector-id">#define</span> MAX_TEMPERATURE <span class="hljs-number">85</span>  <span class="hljs-comment">// 最大温度85°C</span>
​
typedef struct {
    ADC_HandleTypeDef* hadc;
    uint32_t channel;
    int16_t max_temp;
    int16_t current_temp;
    uint8_t protection_enabled;
} Thermal_Protection_TypeDef;
​
Thermal_Protection_TypeDef thermal_protection;
​
<span class="hljs-comment">// 读取温度</span>
int16_t <span class="hljs-built_in">Read_Temperature</span>(Thermal_Protection_TypeDef* tp)
{
    uint32_t adc_value;
    <span class="hljs-attribute">float</span> voltage, temperature;
    
    <span class="hljs-built_in">HAL_ADC_Start</span>(tp-&gt;hadc);
    <span class="hljs-built_in">HAL_ADC_PollForConversion</span>(tp-&gt;hadc, <span class="hljs-number">100</span>);
    adc_value = <span class="hljs-built_in">HAL_ADC_GetValue</span>(tp-&gt;hadc);
    <span class="hljs-built_in">HAL_ADC_Stop</span>(tp-&gt;hadc);
    
    <span class="hljs-comment">// 假设使用NTC热敏电阻，这里需要根据实际传感器特性计算</span>
    voltage = (adc_value * <span class="hljs-number">3.3</span>) / <span class="hljs-number">4096.0</span>;
    
    <span class="hljs-comment">// 简化的温度计算公式（实际应使用查表法或B值公式）</span>
    temperature = (voltage - <span class="hljs-number">0.5</span>) * <span class="hljs-number">100</span>;
    
    tp-&gt;current_temp = (int16_t)temperature;
    return tp-&gt;current_temp;
}
​
<span class="hljs-comment">// 温度保护检测</span>
uint8_t <span class="hljs-built_in">Check_Overtemperature</span>(Thermal_Protection_TypeDef* tp)
{
    <span class="hljs-built_in">if</span>(!tp-&gt;protection_enabled) return <span class="hljs-number">0</span>;
    
    int16_t temp = <span class="hljs-built_in">Read_Temperature</span>(tp);
    
    <span class="hljs-built_in">if</span>(temp &gt; tp-&gt;max_temp) {
        return <span class="hljs-number">1</span>;
    }
    
    return <span class="hljs-number">0</span>;
}
​
<span class="hljs-comment">// 综合保护的负载控制</span>
void <span class="hljs-built_in">Safe_Load_Control</span>(uint8_t state)
{
    <span class="hljs-built_in">if</span>(state) {
        <span class="hljs-comment">// 先检查温度</span>
        <span class="hljs-built_in">if</span>(Check_Overtemperature(&amp;thermal_protection)) {
            <span class="hljs-comment">// 温度过高，拒绝开启</span>
            return;
        }
        
        <span class="hljs-comment">// 打开负载</span>
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
        
        <span class="hljs-comment">// 检查电流</span>
        <span class="hljs-built_in">HAL_Delay</span>(<span class="hljs-number">10</span>);
        <span class="hljs-built_in">if</span>(Check_Overcurrent(&amp;current_protection)) {
            <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
            return;
        }
    } else {
        <span class="hljs-built_in">HAL_GPIO_WritePin</span>(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
    }
}
</code></pre>
<h3 data-id="heading-16">5. 常见问题与解决方案</h3>
<h4 data-id="heading-17">5.1 输出波形振荡</h4>
<p>在实际应用中，推挽电路的输出有时会出现振荡现象。</p>
<p>这通常是由于负载电容和电路寄生电感形成了 LC 振荡回路。</p>
<p>解决方法是在输出端并联一个小电容（通常 0.1<em>μF</em> 到 1<em>μF</em>）进行滤波，或者串联一个小电阻进行阻尼。</p>
<h4 data-id="heading-18">5.2 上电瞬间的冲击电流</h4>
<p>当推挽电路驱动容性负载时，上电瞬间会产生很大的冲击电流。</p>
<p>我们可以通过软启动的方式来解决：</p>
<pre><code class="hljs language-ini" lang="ini">// 软启动函数
void Soft_Start_Output(uint16_t ramp_time_ms)
{
    uint16_t <span class="hljs-attr">steps</span> = ramp_time_ms / <span class="hljs-number">10</span><span class="hljs-comment">;</span>
    uint16_t <span class="hljs-attr">pwm_period</span> = <span class="hljs-number">1000</span><span class="hljs-comment">;  // PWM周期</span>
    
    for(uint16_t <span class="hljs-attr">i</span> = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt;= steps; i++) {</span>
        uint16_t <span class="hljs-attr">duty</span> = (pwm_period * i) / steps<span class="hljs-comment">;</span>
        
        // 设置PWM占空比
        __HAL_TIM_SET_COMPARE(&amp;htim2, TIM_CHANNEL_1, duty)<span class="hljs-comment">;</span>
        HAL_Delay(10)<span class="hljs-comment">;</span>
    }
    
    // 最终切换到直流输出
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET)<span class="hljs-comment">;</span>
}
</code></pre>
<h4 data-id="heading-19">5.3 EMI 问题</h4>
<p>推挽电路的快速开关会产生电磁干扰。</p>
<p>在 PCB 设计时，需要注意以下几点：驱动信号走线要短，远离敏感电路；在电源引脚附近放置去耦电容；使用地平面来降低回路面积；必要时可以串联小电阻来降低开关速度。</p>
<h3 data-id="heading-20">6. 总结</h3>
<p>推挽输出电路是嵌入式系统中非常实用的驱动电路。</p>
<p>它具有驱动能力强、效率高、输出阻抗低等优点，广泛应用于 LED 驱动、继电器控制、电机驱动等场合。</p>
<p>在实际设计中，我们需要根据负载特性选择合适的三极管，计算好基极限流电阻，并考虑过流保护、热保护等安全措施。</p>
<p>通过本文的分析和代码示例，相信大家对推挽电路有了更深入的理解。</p>
<p>在实际项目中，建议先在面包板上搭建电路进行测试，确认参数无误后再进行 PCB 设计。</p>
<p>同时，要注意电路的散热设计，必要时加装散热片。</p>
<p>只有把理论和实践结合起来，才能设计出可靠稳定的推挽驱动电路。</p>
<p><strong>更多编程学习资源</strong></p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fcpp%2Fc_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/cpp/c_course_handout_2025.html" ref="nofollow noopener noreferrer">C 语言零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fstm32%2Fstm32_course_handout_2024.html" target="_blank" title="https://www.lxlinux.net/e/stm32/stm32_course_handout_2024.html" ref="nofollow noopener noreferrer">STM32 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Ffreertos%2Ffreertos_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/freertos/freertos_course_handout_2025.html" ref="nofollow noopener noreferrer">FreeRTOS 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Fcpp%2Fcpp_course_handout_2025.html" target="_blank" title="https://www.lxlinux.net/e/cpp/cpp_course_handout_2025.html" ref="nofollow noopener noreferrer">C++ 零基础入门电子书-2026 最新版</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2F51-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/51-learning-path.html" ref="nofollow noopener noreferrer">51 单片机零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fad-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/ad-learning-path.html" ref="nofollow noopener noreferrer">AD 画板零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fc-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/c-learning-path.html" ref="nofollow noopener noreferrer">C 语言零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fcpp-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/cpp-learning-path.html" ref="nofollow noopener noreferrer">C++ 语言零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fesp32-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/esp32-learning-path.html" ref="nofollow noopener noreferrer">ESP32 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Ffreertos-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/freertos-learning-path.html" ref="nofollow noopener noreferrer">FreeRTOS 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flinux-devop-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/linux-devop-learning-path.html" ref="nofollow noopener noreferrer">Linux 应用开发零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flinux-lower-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/linux-lower-learning-path.html" ref="nofollow noopener noreferrer">Linux 底层开发零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Flvgl-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/lvgl-learning-path.html" ref="nofollow noopener noreferrer">LVGL 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fqt-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/qt-learning-path.html" ref="nofollow noopener noreferrer">QT 零基础入门学习路线</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.lxlinux.net%2Fe%2Flearning-path%2Fstm32-learning-path.html" target="_blank" title="https://www.lxlinux.net/e/learning-path/stm32-learning-path.html" ref="nofollow noopener noreferrer">STM32 零基础入门学习路线</a></li>
</ul>
<pre><code class="hljs"/></pre></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[前端HTML转PDF的两种主流方案深度解析]]></title>    <link>https://juejin.cn/post/7603673564908896291</link>    <guid>https://juejin.cn/post/7603673564908896291</guid>    <pubDate>2026-02-08T06:33:52.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603673564908896291" data-draft-id="7603671627003756584" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="前端HTML转PDF的两种主流方案深度解析"/> <meta itemprop="keywords" content="前端,JavaScript"/> <meta itemprop="datePublished" content="2026-02-08T06:33:52.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="鹿心肺语"/> <meta itemprop="url" content="https://juejin.cn/user/3030678257798120"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            前端HTML转PDF的两种主流方案深度解析
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3030678257798120/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    鹿心肺语
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:33:52.000Z" title="Sun Feb 08 2026 06:33:52 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读8分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">引言</h2>
<p>在现代Web开发中，将网页内容导出为PDF格式的需求越来越普遍。无论是生成电子发票、导出数据报表、制作可打印的文档，还是为用户提供离线阅读的材料，HTML到PDF的转换都是前端开发者必须掌握的技能。本文将深入剖析两种主流的前端PDF生成方案，从原理、实现到最佳实践，帮助你根据实际场景选择最合适的技术路线。</p>
<hr/>
<h2 data-id="heading-1">方案一：浏览器原生打印API</h2>
<h3 data-id="heading-2">核心原理</h3>
<p>浏览器原生打印方案利用了<code>window.print()</code>这一内置API。通过动态创建一个新的浏览器窗口，将需要打印的HTML内容写入该窗口，然后触发浏览器的打印对话框，让用户可以选择"另存为PDF"。这种方法的本质是依赖浏览器自身的渲染引擎和打印能力。</p>
<h3 data-id="heading-3">完整实现代码</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 使用浏览器原生API生成PDF
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">title</span> - 打印页面的标题
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">style</span> - 需要打印的CSS样式
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">content</span> - 需要打印的HTML内容
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">printToPDF</span>(<span class="hljs-params">title, style, content</span>) {
    <span class="hljs-comment">// 构建完整的HTML文档结构</span>
    <span class="hljs-keyword">const</span> html = <span class="hljs-string">`
        &lt;!DOCTYPE html&gt;
        &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
            &lt;title&gt;<span class="hljs-subst">${title}</span>&lt;/title&gt;
            &lt;style&gt;
                /* 基础重置样式 */
                * {
                    margin: 0;
                    padding: 0;
                    box-sizing: border-box;
                }
                
                /* 打印优化样式 */
                @media print {
                    body {
                        -webkit-print-color-adjust: exact;
                        print-color-adjust: exact;
                    }
                    
                    /* 避免表格被截断 */
                    table {
                        page-break-inside: avoid;
                    }
                    
                    /* 避免图片被截断 */
                    img {
                        page-break-inside: avoid;
                        max-width: 100%;
                    }
                }
                
                <span class="hljs-subst">${style}</span>
            &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
            <span class="hljs-subst">${content}</span>
        &lt;/body&gt;
        &lt;/html&gt;
    `</span>;
    
    <span class="hljs-comment">// 创建新窗口</span>
    <span class="hljs-keyword">const</span> printWindow = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">''</span>, <span class="hljs-string">'_blank'</span>);
    
    <span class="hljs-keyword">if</span> (!printWindow) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'弹窗被浏览器拦截，请检查弹窗设置'</span>);
        <span class="hljs-keyword">return</span>;
    }
    
    <span class="hljs-comment">// 写入HTML内容</span>
    printWindow.<span class="hljs-property">document</span>.<span class="hljs-title function_">write</span>(html);
    printWindow.<span class="hljs-property">document</span>.<span class="hljs-title function_">close</span>();
    
    <span class="hljs-comment">// 等待资源加载完成后触发打印</span>
    printWindow.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"/>) {
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            printWindow.<span class="hljs-title function_">print</span>();
            <span class="hljs-comment">// 打印完成后可选择关闭窗口</span>
            <span class="hljs-comment">// printWindow.close();</span>
        }, <span class="hljs-number">500</span>);
    };
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> title = <span class="hljs-string">'月度销售报表'</span>;
<span class="hljs-keyword">const</span> style = <span class="hljs-string">`
    .report-header { text-align: center; margin-bottom: 20px; }
    .report-table { width: 100%; border-collapse: collapse; }
    .report-table th, .report-table td { border: 1px solid #ddd; padding: 8px; }
`</span>;
<span class="hljs-keyword">const</span> content = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'report-container'</span>).<span class="hljs-property">innerHTML</span>;

<span class="hljs-title function_">printToPDF</span>(title, style, content);
</code></pre>
<h3 data-id="heading-4">关键配置说明</h3>

























<table><thead><tr><th>配置项</th><th>说明</th><th>建议值</th></tr></thead><tbody><tr><td><code>-webkit-print-color-adjust</code></td><td>确保打印时保留背景色和颜色</td><td><code>exact</code></td></tr><tr><td><code>page-break-inside: avoid</code></td><td>防止元素在分页处被截断</td><td>应用于表格、图片</td></tr><tr><td><code>page-break-before/after</code></td><td>控制强制分页位置</td><td>根据内容结构设置</td></tr></tbody></table>
<h3 data-id="heading-5">方案一优缺点分析</h3>
<p><strong>优点：</strong></p>
<ul>
<li><strong>零依赖</strong>：无需引入任何第三方库，减少项目体积</li>
<li><strong>浏览器兼容性好</strong>：所有现代浏览器都支持</li>
<li><strong>用户可控</strong>：用户可以在打印对话框中选择纸张大小、方向、边距等</li>
<li><strong>样式灵活</strong>：可以使用<code>@media print</code>媒体查询专门优化打印样式</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>交互依赖</strong>：必须弹出打印对话框，无法静默生成PDF</li>
<li><strong>样式一致性差</strong>：不同浏览器的打印效果可能存在差异</li>
<li><strong>无法自动下载</strong>：需要用户手动选择"另存为PDF"</li>
<li><strong>分页控制有限</strong>：复杂的分页逻辑难以精确控制</li>
</ul>
<hr/>
<h2 data-id="heading-6">方案二：html2pdf.js库方案</h2>
<h3 data-id="heading-7">核心原理</h3>
<p>html2pdf.js是一个基于<code>html2canvas</code>和<code>jsPDF</code>的封装库。其工作流程分为三步：</p>
<ol>
<li><strong>DOM转Canvas</strong>：使用html2canvas将HTML元素渲染为Canvas图像</li>
<li><strong>Canvas转图像</strong>：将Canvas转换为JPEG/PNG图像数据</li>
<li><strong>图像转PDF</strong>：使用jsPDF将图像数据插入PDF文档</li>
</ol>
<h3 data-id="heading-8">完整实现代码</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">import</span> html2pdf <span class="hljs-keyword">from</span> <span class="hljs-string">'html2pdf.js'</span>;

<span class="hljs-comment">/**
 * 使用html2pdf.js生成PDF
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">HTMLElement</span>} <span class="hljs-variable">element</span> - 需要转换的DOM元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">options</span> - 配置选项
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise</span>} - 返回Promise对象
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">generatePDF</span>(<span class="hljs-params">element, options = {}</span>) {
    <span class="hljs-comment">// 默认配置</span>
    <span class="hljs-keyword">const</span> defaultOptions = {
        <span class="hljs-comment">// PDF基础设置</span>
        <span class="hljs-attr">margin</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>],           <span class="hljs-comment">// 上右下左边距（单位：mm）</span>
        <span class="hljs-attr">filename</span>: <span class="hljs-string">'document.pdf'</span>,            <span class="hljs-comment">// 默认文件名</span>
        
        <span class="hljs-comment">// 图像质量设置</span>
        <span class="hljs-attr">image</span>: {
            <span class="hljs-attr">type</span>: <span class="hljs-string">'jpeg'</span>,                    <span class="hljs-comment">// 图像格式：jpeg/png</span>
            <span class="hljs-attr">quality</span>: <span class="hljs-number">0.98</span>                    <span class="hljs-comment">// 图像质量：0-1</span>
        },
        
        <span class="hljs-comment">// html2canvas配置</span>
        <span class="hljs-attr">html2canvas</span>: {
            <span class="hljs-attr">scale</span>: <span class="hljs-number">2</span>,                        <span class="hljs-comment">// 缩放倍数，影响清晰度</span>
            <span class="hljs-attr">useCORS</span>: <span class="hljs-literal">true</span>,                   <span class="hljs-comment">// 允许加载跨域图片</span>
            <span class="hljs-attr">allowTaint</span>: <span class="hljs-literal">true</span>,                <span class="hljs-comment">// 允许污染画布（用于跨域图片）</span>
            <span class="hljs-attr">logging</span>: <span class="hljs-literal">false</span>,                  <span class="hljs-comment">// 关闭日志输出</span>
            <span class="hljs-attr">letterRendering</span>: <span class="hljs-literal">true</span>,           <span class="hljs-comment">// 改善文字渲染</span>
            <span class="hljs-attr">dpi</span>: <span class="hljs-number">192</span>                         <span class="hljs-comment">// 图像DPI</span>
        },
        
        <span class="hljs-comment">// jsPDF配置</span>
        <span class="hljs-attr">jsPDF</span>: {
            <span class="hljs-attr">unit</span>: <span class="hljs-string">'mm'</span>,                      <span class="hljs-comment">// 单位：mm/pt/px/in</span>
            <span class="hljs-attr">format</span>: <span class="hljs-string">'a4'</span>,                    <span class="hljs-comment">// 页面格式：a4/letter/legal等</span>
            <span class="hljs-attr">orientation</span>: <span class="hljs-string">'portrait'</span>          <span class="hljs-comment">// 方向：portrait(纵向)/landscape(横向)</span>
        },
        
        <span class="hljs-comment">// 分页控制</span>
        <span class="hljs-attr">pagebreak</span>: {
            <span class="hljs-attr">mode</span>: [<span class="hljs-string">'avoid-all'</span>, <span class="hljs-string">'css'</span>, <span class="hljs-string">'legacy'</span>],
            <span class="hljs-attr">before</span>: <span class="hljs-string">'.page-break-before'</span>,    <span class="hljs-comment">// 在这些元素前强制分页</span>
            <span class="hljs-attr">after</span>: <span class="hljs-string">'.page-break-after'</span>,      <span class="hljs-comment">// 在这些元素后强制分页</span>
            <span class="hljs-attr">avoid</span>: <span class="hljs-string">'img, table, .no-break'</span>   <span class="hljs-comment">// 避免这些元素被分页截断</span>
        }
    };
    
    <span class="hljs-comment">// 合并配置</span>
    <span class="hljs-keyword">const</span> mergedOptions = <span class="hljs-title function_">deepMerge</span>(defaultOptions, options);
    
    <span class="hljs-comment">// 执行转换</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">html2pdf</span>()
        .<span class="hljs-title function_">set</span>(mergedOptions)
        .<span class="hljs-title function_">from</span>(element)
        .<span class="hljs-title function_">save</span>();
}

<span class="hljs-comment">/**
 * 获取PDF的Base64数据（用于上传或预览）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">HTMLElement</span>} <span class="hljs-variable">element</span> - 需要转换的DOM元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">options</span> - 配置选项
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;string&gt;</span>} - 返回Base64编码的PDF数据
 */</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPDFBase64</span>(<span class="hljs-params">element, options = {}</span>) {
    <span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">await</span> <span class="hljs-title function_">html2pdf</span>()
        .<span class="hljs-title function_">set</span>(options)
        .<span class="hljs-title function_">from</span>(element)
        .<span class="hljs-title function_">outputPdf</span>(<span class="hljs-string">'datauristring'</span>);
    
    <span class="hljs-keyword">return</span> pdf;
}

<span class="hljs-comment">/**
 * 获取PDF的Blob对象（用于自定义下载逻辑）
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">HTMLElement</span>} <span class="hljs-variable">element</span> - 需要转换的DOM元素
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Object</span>} <span class="hljs-variable">options</span> - 配置选项
 * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">Promise&lt;Blob&gt;</span>} - 返回PDF的Blob对象
 */</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPDFBlob</span>(<span class="hljs-params">element, options = {}</span>) {
    <span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">await</span> <span class="hljs-title function_">html2pdf</span>()
        .<span class="hljs-title function_">set</span>(options)
        .<span class="hljs-title function_">from</span>(element)
        .<span class="hljs-title function_">outputPdf</span>(<span class="hljs-string">'blob'</span>);
    
    <span class="hljs-keyword">return</span> pdf;
}

<span class="hljs-comment">// 使用示例</span>
<span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'invoice-container'</span>);

<span class="hljs-comment">// 基础使用 - 直接下载</span>
<span class="hljs-title function_">generatePDF</span>(element, {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'发票-2024001.pdf'</span>,
    <span class="hljs-attr">margin</span>: [<span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>]
});

<span class="hljs-comment">// 高级使用 - 获取数据后上传</span>
<span class="hljs-title function_">getPDFBase64</span>(element, {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'report.pdf'</span>,
    <span class="hljs-attr">html2canvas</span>: { <span class="hljs-attr">scale</span>: <span class="hljs-number">3</span> },  <span class="hljs-comment">// 更高清晰度</span>
    <span class="hljs-attr">jsPDF</span>: { <span class="hljs-attr">orientation</span>: <span class="hljs-string">'landscape'</span> }  <span class="hljs-comment">// 横向布局</span>
}).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">base64Data</span> =&gt;</span> {
    <span class="hljs-comment">// 上传到服务器</span>
    <span class="hljs-title function_">uploadToServer</span>(base64Data);
});
</code></pre>
<h3 data-id="heading-9">配置项深度解析</h3>
<h4 data-id="heading-10">1. 清晰度优化</h4>
<pre><code class="hljs language-javascript" lang="javascript">{
    <span class="hljs-attr">html2canvas</span>: {
        <span class="hljs-attr">scale</span>: <span class="hljs-number">3</span>,           <span class="hljs-comment">// 推荐值：2-4，值越大越清晰但性能越差</span>
        <span class="hljs-attr">dpi</span>: <span class="hljs-number">300</span>,           <span class="hljs-comment">// 打印级清晰度</span>
        <span class="hljs-attr">letterRendering</span>: <span class="hljs-literal">true</span>  <span class="hljs-comment">// 改善小字体渲染</span>
    }
}
</code></pre>
<h4 data-id="heading-11">2. 分页控制策略</h4>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* CSS方式控制分页 */</span>
<span class="hljs-selector-class">.page-break-before</span> {
    <span class="hljs-attribute">page-break-before</span>: always;
}

<span class="hljs-selector-class">.page-break-after</span> {
    <span class="hljs-attribute">page-break-after</span>: always;
}

<span class="hljs-selector-class">.no-break</span> {
    <span class="hljs-attribute">page-break-inside</span>: avoid;
}
</code></pre>
<pre><code class="hljs language-javascript" lang="javascript">{
    <span class="hljs-attr">pagebreak</span>: {
        <span class="hljs-attr">mode</span>: [<span class="hljs-string">'avoid-all'</span>, <span class="hljs-string">'css'</span>, <span class="hljs-string">'legacy'</span>],
        <span class="hljs-comment">// avoid-all: 尽可能避免元素被截断</span>
        <span class="hljs-comment">// css: 尊重CSS的page-break属性</span>
        <span class="hljs-comment">// legacy: 使用旧版分页算法</span>
    }
}
</code></pre>
<h4 data-id="heading-12">3. 跨域图片处理</h4>
<pre><code class="hljs language-javascript" lang="javascript">{
    <span class="hljs-attr">html2canvas</span>: {
        <span class="hljs-attr">useCORS</span>: <span class="hljs-literal">true</span>,       <span class="hljs-comment">// 尝试使用CORS加载跨域图片</span>
        <span class="hljs-attr">allowTaint</span>: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 允许污染画布（如果CORS失败）</span>
        <span class="hljs-attr">proxy</span>: <span class="hljs-string">'/api/proxy'</span>  <span class="hljs-comment">// 图片代理服务地址</span>
    }
}
</code></pre>
<h3 data-id="heading-13">方案二优缺点分析</h3>
<p><strong>优点：</strong></p>
<ul>
<li><strong>静默生成</strong>：无需用户交互，可自动下载或上传</li>
<li><strong>效果一致</strong>：不受浏览器打印设置影响，输出稳定</li>
<li><strong>程序化控制</strong>：可通过代码精确控制生成过程</li>
<li><strong>支持异步</strong>：可集成到自动化流程中</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>体积较大</strong>：需要引入第三方库（约200KB+）</li>
<li><strong>性能开销</strong>：大页面转换可能较慢，会阻塞主线程</li>
<li><strong>文字可选性</strong>：生成的PDF中文字是图像，无法选择复制</li>
<li><strong>复杂样式限制</strong>：某些CSS特性（如flexbox、grid）可能渲染不准确</li>
</ul>
<hr/>
<h2 data-id="heading-14">方案对比与选型指南</h2>























































<table><thead><tr><th>对比维度</th><th>浏览器原生打印</th><th>html2pdf.js</th></tr></thead><tbody><tr><td><strong>依赖体积</strong></td><td>0KB</td><td>~200KB+</td></tr><tr><td><strong>用户交互</strong></td><td>需要</td><td>不需要</td></tr><tr><td><strong>生成速度</strong></td><td>快</td><td>较慢（取决于内容大小）</td></tr><tr><td><strong>输出一致性</strong></td><td>浏览器依赖</td><td>高度一致</td></tr><tr><td><strong>文字可选性</strong></td><td>支持</td><td>不支持（文字为图像）</td></tr><tr><td><strong>分页控制</strong></td><td>有限</td><td>灵活</td></tr><tr><td><strong>跨域图片</strong></td><td>支持</td><td>需特殊配置</td></tr><tr><td><strong>自动化集成</strong></td><td>困难</td><td>容易</td></tr><tr><td><strong>浏览器兼容性</strong></td><td>优秀</td><td>良好</td></tr></tbody></table>
<h3 data-id="heading-15">选型建议</h3>
<p><strong>选择浏览器原生打印的场景：</strong></p>
<ul>
<li>需要用户自定义打印设置（纸张、边距等）</li>
<li>对PDF文件大小敏感</li>
<li>需要生成的PDF中文字可选择、可复制</li>
<li>项目对第三方依赖有严格限制</li>
</ul>
<p><strong>选择html2pdf.js的场景：</strong></p>
<ul>
<li>需要静默生成PDF，不打扰用户</li>
<li>需要自动上传PDF到服务器</li>
<li>对输出效果的一致性要求高</li>
<li>需要集成到自动化工作流中</li>
</ul>
<hr/>
<h2 data-id="heading-16">最佳实践与常见问题</h2>
<h3 data-id="heading-17">1. 打印样式优化</h3>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 打印专用样式表 */</span>
<span class="hljs-keyword">@media</span> print {
    <span class="hljs-comment">/* 隐藏不需要打印的元素 */</span>
    <span class="hljs-selector-class">.no-print</span>,
    <span class="hljs-selector-class">.navbar</span>,
    <span class="hljs-selector-class">.sidebar</span>,
    <span class="hljs-selector-class">.actions</span> {
        <span class="hljs-attribute">display</span>: none <span class="hljs-meta">!important</span>;
    }
    
    <span class="hljs-comment">/* 确保背景色打印 */</span>
    * {
        -webkit-print-<span class="hljs-attribute">color</span>-adjust: exact <span class="hljs-meta">!important</span>;
        print-<span class="hljs-attribute">color</span>-adjust: exact <span class="hljs-meta">!important</span>;
    }
    
    <span class="hljs-comment">/* 链接显示URL */</span>
    <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href]</span><span class="hljs-selector-pseudo">:after</span> {
        <span class="hljs-attribute">content</span>: <span class="hljs-string">" ("</span> <span class="hljs-built_in">attr</span>(href) <span class="hljs-string">")"</span>;
    }
    
    <span class="hljs-comment">/* 表格优化 */</span>
    <span class="hljs-selector-tag">table</span> {
        <span class="hljs-attribute">page-break-inside</span>: avoid;
        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12pt</span>;
    }
    
    <span class="hljs-comment">/* 分页控制 */</span>
    <span class="hljs-selector-class">.page-break</span> {
        <span class="hljs-attribute">page-break-after</span>: always;
    }
}
</code></pre>
<h3 data-id="heading-18">2. 大页面性能优化</h3>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 分块处理大页面</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generateLargePDF</span>(<span class="hljs-params">container</span>) {
    <span class="hljs-keyword">const</span> pages = container.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">'.page'</span>);
    <span class="hljs-keyword">const</span> pdf = <span class="hljs-keyword">new</span> <span class="hljs-title function_">jsPDF</span>(<span class="hljs-string">'p'</span>, <span class="hljs-string">'mm'</span>, <span class="hljs-string">'a4'</span>);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pages.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-comment">// 使用requestIdleCallback避免阻塞UI</span>
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
            <span class="hljs-title function_">requestIdleCallback</span>(<span class="hljs-keyword">async</span> () =&gt; {
                <span class="hljs-keyword">const</span> canvas = <span class="hljs-keyword">await</span> <span class="hljs-title function_">html2canvas</span>(pages[i], { <span class="hljs-attr">scale</span>: <span class="hljs-number">2</span> });
                <span class="hljs-keyword">const</span> imgData = canvas.<span class="hljs-title function_">toDataURL</span>(<span class="hljs-string">'image/jpeg'</span>, <span class="hljs-number">0.95</span>);
                
                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) pdf.<span class="hljs-title function_">addPage</span>();
                pdf.<span class="hljs-title function_">addImage</span>(imgData, <span class="hljs-string">'JPEG'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">210</span>, <span class="hljs-number">297</span>);
                
                <span class="hljs-title function_">resolve</span>();
            });
        });
    }
    
    pdf.<span class="hljs-title function_">save</span>(<span class="hljs-string">'large-document.pdf'</span>);
}
</code></pre>
<h3 data-id="heading-19">3. 常见问题解决方案</h3>
<p><strong>Q: 生成的PDF中文字模糊？</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 提高scale值和DPI</span>
<span class="hljs-attr">html2canvas</span>: {
    <span class="hljs-attr">scale</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">dpi</span>: <span class="hljs-number">300</span>,
    <span class="hljs-attr">letterRendering</span>: <span class="hljs-literal">true</span>
}
</code></pre>
<p><strong>Q: 跨域图片无法显示？</strong></p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 方案1：配置CORS</span>
<span class="hljs-attr">html2canvas</span>: {
    <span class="hljs-attr">useCORS</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">allowTaint</span>: <span class="hljs-literal">true</span>
}

<span class="hljs-comment">// 方案2：使用图片代理</span>
<span class="hljs-attr">html2canvas</span>: {
    <span class="hljs-attr">proxy</span>: <span class="hljs-string">'https://your-domain.com/image-proxy'</span>
}

<span class="hljs-comment">// 方案3：将图片转为Base64</span>
<span class="hljs-keyword">const</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">'img'</span>);
<span class="hljs-title function_">fetch</span>(img.<span class="hljs-property">src</span>)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">blob</span>())
    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">blob</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();
        reader.<span class="hljs-property">onloadend</span> = <span class="hljs-function">() =&gt;</span> {
            img.<span class="hljs-property">src</span> = reader.<span class="hljs-property">result</span>;
        };
        reader.<span class="hljs-title function_">readAsDataURL</span>(blob);
    });
</code></pre>
<p><strong>Q: 表格被分页截断？</strong></p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-comment">/* 为表格容器添加保护 */</span>
<span class="hljs-selector-class">.table-wrapper</span> {
    <span class="hljs-attribute">page-break-inside</span>: avoid;
}

<span class="hljs-comment">/* 或使用html2pdf的分页配置 */</span>
pagebreak: {
    avoid: <span class="hljs-string">'table, tr'</span>
}
</code></pre>
<hr/>
<h2 data-id="heading-20">总结</h2>
<p>前端HTML转PDF的两种主流方案各有优劣：</p>
<ul>
<li><strong>浏览器原生打印</strong>适合需要用户参与、对文件大小敏感、需要文字可选的场景</li>
<li><strong>html2pdf.js</strong>适合需要自动化、对输出一致性要求高的场景</li>
</ul>
<p>在实际项目中，可以根据具体需求选择单一方案或组合使用。例如，可以提供"打印"按钮使用原生方案，同时提供"下载PDF"按钮使用html2pdf.js方案，让用户自主选择。</p>
<p>随着Web技术的发展，新的方案如Chrome的Headless打印、Puppeteer等服务端方案也在兴起。但对于纯前端场景，本文介绍的两种方案仍然是最实用、最成熟的选择。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[CSS盒模型实战：用代码透视 `border-box`与 `content-box`的天壤之别]]></title>    <link>https://juejin.cn/post/7603643385816842292</link>    <guid>https://juejin.cn/post/7603643385816842292</guid>    <pubDate>2026-02-08T06:57:33.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603643385816842292" data-draft-id="7603643385816825908" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="CSS盒模型实战：用代码透视 `border-box`与 `content-box`的天壤之别"/> <meta itemprop="keywords" content="CSS"/> <meta itemprop="datePublished" content="2026-02-08T06:57:33.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Lee川"/> <meta itemprop="url" content="https://juejin.cn/user/2402874087453658"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            CSS盒模型实战：用代码透视 `border-box`与 `content-box`的天壤之别
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2402874087453658/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Lee川
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:57:33.000Z" title="Sun Feb 08 2026 06:57:33 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读4分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0"><strong>CSS盒模型实战：用代码透视 <code>border-box</code>与 <code>content-box</code>的天壤之别</strong></h3>
<p>理解CSS盒模型是前端布局的必修课，而 <code>box-sizing</code>属性则是掌控盒模型计算规则的钥匙。本文将通过您文档中生动的代码示例，直观展示其核心区别。</p>
<h4 data-id="heading-1"><strong>场景一：标准盒模型的“扩张”困扰（<code>content-box</code>）</strong></h4>
<p>在默认的 <code>content-box</code>模型下，您为元素设置的 <code>width</code>和 <code>height</code>仅作用于其<strong>内容区域</strong>。让我们看一个例子：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.box</span><span class="hljs-selector-class">.content-box</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;       <span class="hljs-comment">/* 仅指内容的宽度 */</span>
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;      <span class="hljs-comment">/* 仅指内容的高度 */</span>
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;      <span class="hljs-comment">/* 内边距 */</span>
            <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid black; <span class="hljs-comment">/* 边框 */</span>
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;       <span class="hljs-comment">/* 外边距 */</span>
            <span class="hljs-attribute">box-sizing</span>: content-box; <span class="hljs-comment">/* 这是默认值，也可不写 */</span>
            <span class="hljs-attribute">background-color</span>: lightgreen;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box content-box"</span>&gt;</span>Box with content-box<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>关键代码分析</strong>：</p>
<ul>
<li><code>width: 200px; height: 100px;</code>：这里定义的仅仅是绿色内容区域的尺寸。</li>
<li>添加的 <code>padding</code>和 <code>border</code>会<strong>向外扩张</strong>盒子的总尺寸。</li>
</ul>
<p><strong>计算结果</strong>：</p>
<ul>
<li>盒子的<strong>总宽度</strong>​ = <code>200(width) + 20 * 2(padding) + 5 * 2(border) = 250px</code></li>
<li>盒子的<strong>总高度</strong>​ = <code>100(height) + 20 * 2(padding) + 5 * 2(border) = 150px</code></li>
</ul>
<p>此时，盒子在页面上的实际占位是 250px * 150px，远大于你直觉上认为的 200px * 100px。这在多列布局时极易导致意外换行或溢出。</p>
<h4 data-id="heading-2"><strong>场景二：怪异盒模型的“收缩”智慧（<code>border-box</code>）</strong></h4>
<p>为了解决上述问题，<code>border-box</code>模型采用了更直观的计算方式：你设定的 <code>width</code>和 <code>height</code>直接定义了这个盒子的<strong>总边框盒尺寸</strong>。对比示例：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.box</span><span class="hljs-selector-class">.border-box</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;       <span class="hljs-comment">/* 指整个盒子的总宽度！ */</span>
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;      <span class="hljs-comment">/* 指整个盒子的总高度！ */</span>
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid black;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;
            <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* 核心：切换为 border-box */</span>
            <span class="hljs-attribute">background-color</span>: lightblue;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box border-box"</span>&gt;</span>Box with border-box<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>关键代码分析</strong>：</p>
<ul>
<li>同样的 <code>width: 200px; height: 100px;</code>声明，但因为 <code>box-sizing: border-box;</code>的存在，这里的 200px 和 100px 被解释为<strong>包含内容、内边距和边框的总尺寸</strong>。</li>
<li>添加的 <code>padding</code>和 <code>border</code>会<strong>向内挤压</strong>内容区域的空间。</li>
</ul>
<p><strong>计算结果</strong>：</p>
<ul>
<li>盒子的<strong>总宽度</strong>​ = <code>200px</code>（由 <code>width</code>直接定义）</li>
<li>盒子的<strong>总高度</strong>​ = <code>100px</code>（由 <code>height</code>直接定义）</li>
<li>内容区域的<strong>实际宽度</strong>​ = <code>200 - 20 * 2 - 5 * 2 = 150px</code></li>
<li>内容区域的<strong>实际高度</strong>​ = <code>100 - 20 * 2 - 5 * 2 = 50px</code></li>
</ul>
<p>无论你如何调整 <code>padding</code>和 <code>border</code>，这个浅蓝色盒子的<strong>外轮廓</strong>都严格保持为你设定的 200px * 100px，这使得精确控制布局变得轻而易举。</p>
<h4 data-id="heading-3"><strong>实战应用：为什么 <code>border-box</code>是布局神器</strong></h4>
<p>让我们看一个经典应用场景——创建两个等宽并列的盒子：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">1200px</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
        }
        <span class="hljs-selector-class">.box</span> {
            <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-comment">/* 使用 border-box 模型 */</span>
            <span class="hljs-attribute">width</span>: <span class="hljs-number">580px</span>; <span class="hljs-comment">/* 总宽580px */</span>
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">10px</span>; <span class="hljs-comment">/* 左右外边距各10px */</span>
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>; <span class="hljs-comment">/* 边框 */</span>
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>; <span class="hljs-comment">/* 内边距 */</span>
            <span class="hljs-attribute">display</span>: inline-block;
            <span class="hljs-attribute">background-color</span>: green;
        }
        <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) {
            <span class="hljs-attribute">background-color</span>: yellow;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"box"</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>核心优势解析</strong>：</p>
<ol>
<li>
<p><strong>尺寸可预测</strong>：每个 <code>.box</code>的总宽度是明确的 580px，无论其 <code>border</code>和 <code>padding</code>如何变化。</p>
</li>
<li>
<p><strong>布局计算简单</strong>：</p>
<ul>
<li>单个盒子占位：<code>580px(width) + 10 * 2(margin) = 600px</code></li>
<li>两个盒子总占位：<code>600px + 600px = 1200px</code></li>
<li>容器宽度为 1200px，完美容纳。</li>
</ul>
</li>
</ol>
<p><strong>如果此处使用 <code>content-box</code>，会发生什么？</strong></p>
<p>每个盒子的实际总宽度会变成：<code>580(width) + 5 * 2(padding) + 1 * 2(border) = 592px</code>，再加上左右 <code>margin</code>各10px，单个盒子就占用了 <code>612px</code>，两个盒子就需要 <code>1224px</code>，会立即撑破 <code>1200px</code>的容器，导致第二个盒子掉到下一行。<code>border-box</code>彻底避免了这种烦人的计算。</p>
<h4 data-id="heading-4"><strong>总结与最佳实践</strong></h4>
<p>通过以上代码的对比演示，可以清晰地看到：</p>
<ul>
<li>**<code>content-box</code>**​ 是“加法模型”（<code>实际尺寸 = 设定尺寸 + padding + border</code>），易导致布局失控。</li>
<li>**<code>border-box</code>**​ 是“减法模型”（<code>内容尺寸 = 设定尺寸 - padding - border</code>），让元素的占位尺寸完全可预测。</li>
</ul>
<p>因此，在现代前端开发中，一个公认的最佳实践是在CSS起始位置就全局应用 <code>border-box</code>模型：</p>
<pre><code class="hljs language-css" lang="css">*,
*<span class="hljs-selector-pseudo">::before</span>,
*<span class="hljs-selector-pseudo">::after</span> {
  <span class="hljs-attribute">box-sizing</span>: border-box;
}
</code></pre>
<p>这条简单的规则，能让你在后续的整个开发过程中，彻底告别因 <code>padding</code>和 <code>border</code>导致的布局尺寸计算烦恼，将更多精力投入到创意和逻辑的实现中。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring Flux方法总结]]></title>    <link>https://juejin.cn/post/7603643385816547380</link>    <guid>https://juejin.cn/post/7603643385816547380</guid>    <pubDate>2026-02-08T03:51:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603643385816547380" data-draft-id="7603673564908683299" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring Flux方法总结"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T03:51:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Luke君60797"/> <meta itemprop="url" content="https://juejin.cn/user/3632442148656990"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring Flux方法总结
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3632442148656990/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Luke君60797
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T03:51:18.000Z" title="Sun Feb 08 2026 03:51:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    4
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><code>Flux</code> 的方法非常多（几百个），但你不需要全部记住。我们可以把它们按照“功能”分成几类，就像厨房里不同的工具：</p>
<h3 data-id="heading-0">1. 制造水源（创建操作符）</h3>
<p>用来定义流量的来源。</p>
<ul>
<li><strong><code>just(T... data)</code></strong> ：最直接的，把现成的数据塞进去。</li>
<li><strong><code>fromIterable(Iterable)</code></strong> ：把 <code>List</code> 或 <code>Set</code> 变成 <code>Flux</code>。</li>
<li><strong><code>range(int start, int count)</code></strong> ：生成一个整数序列（如 1 到 100）。</li>
<li><strong><code>interval(Duration)</code></strong> ：<strong>定时器</strong>。每隔一段时间发一个数字（0, 1, 2...），常用于心跳检测。</li>
<li><strong><code>empty()</code></strong> ：直接发送完成信号，水管里啥也没有。</li>
<li><strong><code>error(Throwable)</code></strong> ：直接发送错误信号，水管一通就爆。</li>
</ul>
<hr/>
<h3 data-id="heading-1">2. 加工转换（转化操作符）</h3>
<p>最常用的部分，用来改变流里的数据。</p>
<ul>
<li>
<p><strong><code>map(Function)</code></strong> ：<strong>1对1转换</strong>。把 A 变成 B（如：把“洗洁精”字符串变成 <code>Soap</code> 对象）。</p>
</li>
<li>
<p><strong><code>flatMap(Function)</code></strong> ：<strong>1对N转换（异步）</strong> 。把一个元素变成一个新的 <code>Flux</code>。</p>
<blockquote>
<p><em>比喻：<code>map</code> 是把菜切碎；<code>flatMap</code> 是把一个订单拆成多个物流单，并异步去查每一个物流。</em></p>
</blockquote>
</li>
<li>
<p><strong><code>buffer(int n)</code></strong> ：<strong>打包</strong>。把零散的水滴收集满 <code>n</code> 个，凑成一个 <code>List</code> 再往下流。</p>
</li>
<li>
<p><strong><code>collectList()</code></strong> ：把水管里所有的水都接住，最后装进一个 <code>Mono&lt;List&lt;T&gt;&gt;</code>。</p>
</li>
</ul>
<hr/>
<h3 data-id="heading-2">3. 过滤与挑选（过滤操作符）</h3>
<p>决定哪些东西能流过去。</p>
<ul>
<li><strong><code>filter(Predicate)</code></strong> ：符合条件的才让过。</li>
<li><strong><code>distinct()</code></strong> ：<strong>去重</strong>。流过的东西如果重复，只放行第一个。</li>
<li><strong><code>take(long n)</code></strong> ：<strong>只取前 n 个</strong>。拿完就关水龙头。</li>
<li><strong><code>skip(long n)</code></strong> ：跳过前 n 个，从后面开始接。</li>
</ul>
<hr/>
<h3 data-id="heading-3">4. 组合流（组合操作符）</h3>
<p>把多根水管拼在一起。</p>
<ul>
<li>
<p><strong><code>mergeWith(Publisher)</code></strong> ：<strong>合并</strong>。两根管子汇成一根，谁有水谁先流（交错输出）。</p>
</li>
<li>
<p><strong><code>zipWith(Publisher)</code></strong> ：<strong>配对</strong>。左边流出一滴，右边流出一滴，凑成一对（Tuple）再往下走。</p>
<blockquote>
<p><em>比喻：<code>merge</code> 是合流，<code>zip</code> 是相亲，必须两边都有人才成对。</em></p>
</blockquote>
</li>
<li>
<p><strong><code>concatWith(Publisher)</code></strong> ：<strong>首尾相接</strong>。等第一根管子流完了，才开始流第二根。</p>
</li>
</ul>
<hr/>
<h3 data-id="heading-4">5. 副作用与生命周期（监听操作符）</h3>
<p>只观察，不干预。</p>
<ul>
<li><strong><code>doOnNext(Consumer)</code></strong> ：数据流过时看一眼（打日志）。</li>
<li><strong><code>doOnError(Consumer)</code></strong> ：出故障时看一眼。</li>
<li><strong><code>doOnComplete(Runnable)</code></strong> ：流完时看一眼。</li>
<li><strong><code>doFinally(Consumer)</code></strong> ：管它成功还是失败，最后都要执行（类似 <code>finally</code> 块）。</li>
</ul>
<hr/>
<h3 data-id="heading-5">6. 错误处理（容错操作符）</h3>
<p>水管爆了之后的救场方案。</p>
<ul>
<li><strong><code>onErrorReturn(T)</code></strong> ：出错了？别报警，直接返回一个默认值。</li>
<li><strong><code>onErrorResume(Function)</code></strong> ：出错了？切到备用水管（另一个 <code>Flux</code>）。</li>
<li><strong><code>retry(long n)</code></strong> ：出错了？再试 <code>n</code> 次。</li>
</ul>
<hr/>
<h3 data-id="heading-6">总结</h3>
<ul>
<li>如果你要<strong>改变</strong>数据：找 <code>map</code>/<code>flatMap</code>。</li>
<li>如果你要<strong>减少</strong>数据：找 <code>filter</code>/<code>take</code>。</li>
<li>如果你要<strong>合并</strong>数据：找 <code>zip</code>/<code>merge</code>。</li>
<li>如果你要<strong>观察</strong>数据：找 <code>doOn...</code> 系列。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[高版本 MySQL 驱动的 DNS 陷阱]]></title>    <link>https://juejin.cn/post/7603674653153525769</link>    <guid>https://juejin.cn/post/7603674653153525769</guid>    <pubDate>2026-02-08T04:24:35.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603674653153525769" data-draft-id="7603674653153476617" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="高版本 MySQL 驱动的 DNS 陷阱"/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T04:24:35.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="define9527"/> <meta itemprop="url" content="https://juejin.cn/user/414960194946937"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            高版本 MySQL 驱动的 DNS 陷阱
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/414960194946937/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    define9527
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T04:24:35.000Z" title="Sun Feb 08 2026 04:24:35 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读2分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">背景</h2>
<p>项目使用 OceanBase 数据库，并通过 ShardingSphere JDBC 实现分表。由于 ShardingSphere 当前不支持 <code>jdbc:oceanbase:</code> 协议，我们在代码中将连接串替换为 <code>jdbc:mysql</code> 并引入 MySQL 驱动</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.oceanbase<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>oceanbase-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>shardingsphere-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 问题根源 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>数据源配置如下（关键部分）</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.oceanbase.jdbc.Driver</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:oceanbase:loadbalance://IP:PORT/test?...</span>
    <span class="hljs-attr">druid:</span>
      <span class="hljs-attr">initial-size:</span> <span class="hljs-number">8</span>
      <span class="hljs-attr">max-active:</span> <span class="hljs-number">30</span>
      <span class="hljs-attr">min-idle:</span> <span class="hljs-number">8</span>
</code></pre>

<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShardingDataSourceConfiguration</span> {

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${spring.datasource.url}"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> url;

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${spring.datasource.username}"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> username;

    <span class="hljs-meta">@Value</span>(<span class="hljs-string">"${spring.datasource.password}"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> password;

    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">DataSource</span>&gt; <span class="hljs-title function_">createDataSourceMap</span>(<span class="hljs-params"/>) {
        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">DataSource</span>&gt; dataSourceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        <span class="hljs-title class_">DruidDataSource</span> dataSource1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();
        dataSource1.<span class="hljs-title function_">setDriverClassName</span>(<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>);
        url = url.<span class="hljs-title function_">replace</span>(<span class="hljs-string">"jdbc:oceanbase"</span>, <span class="hljs-string">"jdbc:mysql"</span>);
        dataSource1.<span class="hljs-title function_">setUrl</span>(url);
        dataSource1.<span class="hljs-title function_">setUsername</span>(username);
        dataSource1.<span class="hljs-title function_">setPassword</span>(password);
        dataSource1.<span class="hljs-title function_">setInitialSize</span>(<span class="hljs-number">8</span>);
        dataSource1.<span class="hljs-title function_">setMaxActive</span>(<span class="hljs-number">30</span>);
        dataSource1.<span class="hljs-title function_">setMinIdle</span>(<span class="hljs-number">8</span>);
        dataSourceMap.<span class="hljs-title function_">put</span>(<span class="hljs-string">"ds_0"</span>, dataSource1);
        <span class="hljs-keyword">return</span> dataSourceMap;
    }

    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"shardingDataSource"</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-title class_">DataSource</span> <span class="hljs-title function_">dataSource</span>() throws <span class="hljs-title class_">SQLException</span> {
        <span class="hljs-title class_">Properties</span> props = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
        props.<span class="hljs-title function_">put</span>(<span class="hljs-string">"sql-show"</span>, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ShardingSphereDataSourceFactory</span>.<span class="hljs-title function_">createDataSource</span>(
            <span class="hljs-title function_">createDataSourceMap</span>(),
            <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">singletonList</span>(<span class="hljs-title function_">createShardingRuleConfiguration</span>()),
            props
        );
    }
}
</code></pre>
<p>同时，项目中还有一个未经过 ShardingSphere 的原生 OceanBase 数据源</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataSourceConfiguration</span> {

    <span class="hljs-meta">@Bean(name = <span class="hljs-string">"logAnalysisDataSource"</span>)</span>
    <span class="hljs-keyword">public</span> DataSource logAnalysisDataSource() {
        <span class="hljs-comment">// com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder</span>
        <span class="hljs-comment">// 使用 spring.datasource 配置来创建数据库连接池</span>
        DruidDataSource druidDataSource = DruidDataSourceBuilder.create().build();
        druidDataSource.setSocketTimeout(<span class="hljs-number">180000</span>);
        druidDataSource.setConnectTimeout(<span class="hljs-number">180000</span>);
        <span class="hljs-keyword">return</span> druidDataSource;
    }
}
</code></pre>
<h2 data-id="heading-1">问题现象</h2>
<p>启动项目时，发现 <code>@Bean("shardingDataSource")</code> 所对应的 DruidDataSource 初始化时间特别长，但 <code>@Bean(name = "logAnalysisDataSource")</code> 所对应的 DruidDataSource 初始化却很快</p>
<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[2026-02-07 17:47:32.417]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[80]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Starting...]</span>
<span class="hljs-selector-attr">[2026-02-07 17:47:32.739]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[82]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Start completed.]</span>

<span class="hljs-selector-attr">[2026-02-07 17:50:22.107]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-1} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 17:50:34.454]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-2} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 17:50:35.840]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.xxx.WebApplication]</span> <span class="hljs-selector-attr">[61]</span> - <span class="hljs-selector-attr">[Started WebApplication in 188.327 seconds (JVM running for 189.054)]</span>
</code></pre>
<blockquote>
<p>日志中的 HikariDataSource 是 ShardingSphere JDBC 用于操作元数据的内部连接池，其初始化完成至 DruidDataSource#init 执行前的耗时可忽略不计</p>
</blockquote>
<p>启动日志中，<code>{dataSource-1}</code> 对应 <code>@Bean("shardingDataSource")</code>，<code>{dataSource-2}</code> 对应 <code>@Bean(name = "logAnalysisDataSource")</code></p>
<p>从日志可以看出，<code>@Bean("shardingDataSource")</code> 这个 DruidDataSource 对象的初始化时间为 2 分 50 秒，而 <code>@Bean(name = "logAnalysisDataSource")</code> 这个 DruidDataSource 对象的初始化时间为 12 秒，而两者唯一的区别在于底层 JDBC 驱动</p>
<blockquote>
<p>备注：因项目开发环境位于内网，且数据库部署于不同地域，网络延迟较高，数据库连接池初始化耗时 12 秒属正常范围</p>
</blockquote>
<p>跟踪 Druid 源码发现，耗时主要集中在 <code>createPhysicalConnection()</code> 方法执行过程中，该方法负责建立底层物理数据库连接</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DruidDataSource</span> <span class="hljs-title">extends</span> <span class="hljs-title">DruidAbstractDataSource</span> <span class="hljs-title">implements</span> <span class="hljs-title">DruidDataSourceMBean</span>, <span class="hljs-type">ManagedDataSource</span>, <span class="hljs-type">Referenceable</span>, <span class="hljs-type">Closeable</span>, <span class="hljs-type">Cloneable</span>, <span class="hljs-type">ConnectionPoolDataSource</span>, <span class="hljs-type">MBeanRegistration</span> {

    <span class="hljs-keyword">public</span> void <span class="hljs-keyword">init</span>() throws SQLException {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">if</span> (createScheduler != <span class="hljs-literal">null</span> &amp;&amp; asyncInit) {
                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; initialSize; ++i) {
                    submitCreateTask(<span class="hljs-literal">true</span>);
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!asyncInit) {
                <span class="hljs-comment">// init connections</span>
                <span class="hljs-keyword">while</span> (poolingCount &lt; initialSize) {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// 慢在这里</span>
                        PhysicalConnectionInfo pyConnectInfo = createPhysicalConnection();
                        DruidConnectionHolder holder = new DruidConnectionHolder(<span class="hljs-keyword">this</span>, pyConnectInfo);
                        connections[poolingCount++] = holder;
                    } <span class="hljs-keyword">catch</span> (SQLException ex) {

                    }
                }
            }
        } <span class="hljs-keyword">finally</span> {
            inited = <span class="hljs-literal">true</span>;
            lock.unlock();
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">init</span> &amp;&amp; LOG.isInfoEnabled()) {
                String msg = <span class="hljs-string">"{dataSource-"</span> + <span class="hljs-keyword">this</span>.getID();
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-keyword">this</span>.name.isEmpty()) {
                    msg += <span class="hljs-string">","</span>;
                    msg += <span class="hljs-keyword">this</span>.name;
                }
                msg += <span class="hljs-string">"} inited"</span>;
                <span class="hljs-comment">// 打印日志</span>
                LOG.info(msg);
            }
        }
    }
}
</code></pre>
<p>继续跟踪源码，最终定位到问题源于 MySQL 驱动在创建连接时调用 <code>InetSocketAddress.getHostName()</code> 进行反向 DNS 解析，耗时显著，导致连接初始化缓慢</p>
<p>完整的链路：<code>DruidAbstractDataSource#createPhysicalConnection</code> =&gt; ... =&gt; <code>com.mysql.cj.jdbc.ConnectionImpl#getInstance(HostInfo hostInfo)</code> =&gt; <code>ConnectionImpl</code> 构造方法</p>
<pre><code class="hljs language-kotlin" lang="kotlin"><span class="hljs-keyword">package</span> com.mysql.cj.jdbc;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">JdbcConnection</span>, <span class="hljs-type">SessionEventListener</span>, <span class="hljs-type">Serializable</span> {
    <span class="hljs-keyword">public</span> ConnectionImpl(HostInfo hostInfo) throws SQLException {
        <span class="hljs-keyword">try</span> {
            SocketAddress socketAddress = <span class="hljs-keyword">this</span>.session.getRemoteSocketAddress();
            <span class="hljs-keyword">if</span> (InetSocketAddress.<span class="hljs-keyword">class</span>.isInstance(socketAddress)) {
                InetSocketAddress inetSocketAddress = (InetSocketAddress) socketAddress;
                <span class="hljs-comment">// 关键</span>
                <span class="hljs-keyword">this</span>.connectionSpan.setAttribute(
                    TelemetryAttribute.NETWORK_PEER_ADDRESS,
                    <span class="hljs-comment">// 获取 hostname 字段值</span>
                    inetSocketAddress.getHostName()
                );
            }
        }
    }
}
</code></pre>

<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">package</span> java.net;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InetSocketAddress</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SocketAddress</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">transient</span> InetSocketAddressHolder holder;

    <span class="hljs-comment">// Private implementation class pointed to by all public methods.</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InetSocketAddressHolder</span> {
        <span class="hljs-comment">// The hostname of the Socket Address</span>
        <span class="hljs-keyword">private</span> String hostname;
        <span class="hljs-comment">// The IP address of the Socket Address</span>
        <span class="hljs-keyword">private</span> InetAddress addr;
        <span class="hljs-comment">// The port number of the Socket Address</span>
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> port;

        <span class="hljs-keyword">private</span> <span class="hljs-title function_">InetSocketAddressHolder</span><span class="hljs-params">(String hostname, InetAddress addr, <span class="hljs-type">int</span> port)</span> {
            <span class="hljs-built_in">this</span>.hostname = hostname;
            <span class="hljs-built_in">this</span>.addr = addr;
            <span class="hljs-built_in">this</span>.port = port;
        }

        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPort</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> port;
        }

        <span class="hljs-keyword">private</span> InetAddress <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> addr;
        }

        <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getHostName</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">if</span> (hostname != <span class="hljs-literal">null</span>)
                <span class="hljs-keyword">return</span> hostname;
            <span class="hljs-keyword">if</span> (addr != <span class="hljs-literal">null</span>)
                <span class="hljs-comment">// ⚠️ 触发反向 DNS 解析！内网无 DNS 服务 → 阻塞超时</span>
                <span class="hljs-keyword">return</span> addr.getHostName();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }

    <span class="hljs-comment">/**
     * Gets the {<span class="hljs-doctag">@code</span> hostname}.
     * Note: This method may trigger a name service reverse lookup if the
     * address was created with a literal IP address.
     *
     * <span class="hljs-doctag">@return</span>  the hostname part of the address.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getHostName</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> holder.getHostName();
    }
}
</code></pre>
<p>在网上搜了下，有如下的文章片段</p>
<pre><code class="hljs language-markdown" lang="markdown"><span class="hljs-section"># 解决 Linux 上 Java 获取 hostname 很慢的问题</span>

在 Linux 环境中运行 Java 应用时，有时会遇到 <span class="hljs-code">`InetAddress.getLocalHost().getHostName()`</span> 方法执行缓慢的问题，严重影响应用启动速度

<span class="hljs-section">## 问题原因</span>
Java 在调用 <span class="hljs-code">`getHostName()`</span> 时，会尝试对本机 IP 地址进行<span class="hljs-strong">**反向 DNS 解析（PTR 查询）**</span>，以获取主机名，若 DNS 服务器不可达、无 PTR 记录或网络延迟高，该操作将长时间阻塞

<span class="hljs-section">## 常见场景</span>
<span class="hljs-bullet">-</span> Docker / K8S 容器中未配置 DNS
<span class="hljs-bullet">-</span> 内部网络无反向解析支持
<span class="hljs-bullet">-</span> 使用纯 IP 地址连接数据库（如 MySQL）
</code></pre>
<p>真相大白！我的项目开发环境位于公司内网，完全无法访问外网，更无外部 DNS 服务支持，以下为尝试 ping 外网的输出结果</p>
<pre><code class="hljs language-ruby" lang="ruby"><span class="hljs-variable">$ </span>ping www.baidu.com
<span class="hljs-title class_">Ping</span> 请求找不到主机 www.baidu.com。请检查该名称，然后重试。
</code></pre>
<p>那怎么解释 <code>@Bean(name = "logAnalysisDataSource")</code> 这个 DruidDataSource 对象的初始化时间仅 12 秒呢？这是因为它使用的是 <code>jdbc:oceanbase</code> 协议与 <code>oceanbase-client</code> 驱动，这个驱动在连接建立过程中不会调用 <code>InetSocketAddress.getHostName()</code> 方法（没看源码，仅为猜测，但八九不离十）</p>
<p>如何解决这个问题呢？有如下两种方法（网上说添加几个 JVM 参数就能解决，实测无效）</p>
<blockquote>
<p>上述问题在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_33919114%2Farticle%2Fdetails%2F143167989" target="_blank" title="https://blog.csdn.net/qq_33919114/article/details/143167989" ref="nofollow noopener noreferrer">SpringBoot 3 Druid 启动慢排查，SpringBoot 启动慢、服务偶发接口慢查询，MySQL Connector-j 9.0.0 版本问题，getHostName() 请求慢</a> 这篇文章中也提到了</p>
</blockquote>
<h2 data-id="heading-2">解决办法一：修改 hosts 文件</h2>
<ul>
<li>修改 hosts 文件，添加域名映射</li>
</ul>

<pre><code class="hljs language-makefile" lang="makefile">10.xxx.xxx.146 www.<span class="hljs-keyword">define</span>.com
</code></pre>
<ul>
<li>从启动日志可以看出，问题完美解决</li>
</ul>

<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[2026-02-07 18:44:04.258]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[80]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Starting...]</span>
<span class="hljs-selector-attr">[2026-02-07 18:44:04.582]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[82]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Start completed.]</span>

<span class="hljs-selector-attr">[2026-02-07 18:44:09.426]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-1} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 18:44:22.180]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-2} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 18:44:23.552]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.xxx.WebApplication]</span> <span class="hljs-selector-attr">[61]</span> - <span class="hljs-selector-attr">[Started WebApplication in 24.191 seconds (JVM running for 24.92)]</span>
</code></pre>
<ul>
<li>原理：因 <code>InetAddress.getHostName()</code> 在本地 hosts 有映射时会<strong>跳过网络 DNS 查询</strong>，从而避免阻塞</li>
</ul>
<h2 data-id="heading-3">解决办法二：降低 MySQL 驱动版本</h2>
<ul>
<li>降低至 8.0.33 版本，实测有效</li>
</ul>

<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<ul>
<li>从启动日志可以看出，问题完美解决</li>
</ul>

<pre><code class="hljs language-css" lang="css"><span class="hljs-selector-attr">[2026-02-07 18:51:19.582]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[80]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Starting...]</span>
<span class="hljs-selector-attr">[2026-02-07 18:51:19.899]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.zaxxer.hikari.HikariDataSource]</span> <span class="hljs-selector-attr">[82]</span> - <span class="hljs-selector-attr">[HikariPool-1 - Start completed.]</span>

<span class="hljs-selector-attr">[2026-02-07 18:51:24.718]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-1} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 18:51:37.035]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.alibaba.druid.pool.DruidDataSource]</span> <span class="hljs-selector-attr">[1007]</span> - <span class="hljs-selector-attr">[{dataSource-2} inited]</span>

<span class="hljs-selector-attr">[2026-02-07 18:51:38.433]</span> <span class="hljs-selector-attr">[INFO ]</span> <span class="hljs-selector-attr">[com.xxx.WebApplication]</span> <span class="hljs-selector-attr">[61]</span> - <span class="hljs-selector-attr">[Started WebApplication in 23.6 seconds (JVM running for 24.33)]</span>
</code></pre>
<ul>
<li>翻看 8.0.33 中 ConnectionImpl 的源码，不会调用 <code>InetSocketAddress.getHostName()</code> 方法</li>
</ul>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/385985b131054048b8d265fcc2b1d816~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgZGVmaW5lOTUyNw==:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771129772&amp;x-signature=sm9g23yDAn6PgmNqT8O42SFGnis%3D" alt="1770436368060.png" loading="lazy"/></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[深入理解 Vue.js 渲染机制：从声明式到虚拟 DOM 的完整实现]]></title>    <link>https://juejin.cn/post/7603644943351726086</link>    <guid>https://juejin.cn/post/7603644943351726086</guid>    <pubDate>2026-02-08T04:36:23.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603644943351726086" data-draft-id="7603781883973271571" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="深入理解 Vue.js 渲染机制：从声明式到虚拟 DOM 的完整实现"/> <meta itemprop="keywords" content="Vue.js"/> <meta itemprop="datePublished" content="2026-02-08T04:36:23.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="EchoEcho"/> <meta itemprop="url" content="https://juejin.cn/user/2920774267837208"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            深入理解 Vue.js 渲染机制：从声明式到虚拟 DOM 的完整实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2920774267837208/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    EchoEcho
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T04:36:23.000Z" title="Sun Feb 08 2026 04:36:23 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">相关概念：</h2>
<h3 data-id="heading-1">命令式 VS 声明式</h3>
<p>从范式上来看，视图层框架通常分为：</p>
<ul>
<li><strong>命令式框架</strong>
<ul>
<li>更加<strong>关注过程</strong>，代码本身描述的是“做事的过程”，符合逻辑直觉</li>
<li>
<pre><code class="hljs language-dart" lang="dart">  <span class="hljs-comment">// 自然语言描述能够与代码产生一一对应的关系</span>
  <span class="hljs-comment">// 示例：</span>
  <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">'#app'</span>) <span class="hljs-comment">// 获取div</span>
  div.innerText = <span class="hljs-string">'hello world'</span><span class="hljs-comment">// 设置文本内容</span>
  div.addEventListener(<span class="hljs-string">'click'</span>, () =&gt; { alert(<span class="hljs-string">'ok'</span>) }) <span class="hljs-comment">// 绑定点击事件</span>
</code></pre>
</li>
</ul>
</li>
<li><strong>声明式框架</strong>
<ul>
<li>更加<strong>关注结果</strong>，主要是提升代码的可维护性</li>
<li>
<pre><code class="hljs language-less" lang="less">  <span class="hljs-comment">// 用户提供一个“预期的结果”，中间的过程由vue.js实现</span>
  <span class="hljs-comment">// 示例</span>
  &lt;<span class="hljs-selector-tag">div</span> @<span class="hljs-selector-tag">click</span>="()  =&gt; <span class="hljs-selector-tag">alert</span>(<span class="hljs-string">'ok'</span>)"&gt;<span class="hljs-selector-tag">hello</span> <span class="hljs-selector-tag">world</span>&lt;/<span class="hljs-selector-tag">div</span>&gt;
</code></pre>
</li>
<li>更新时性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗</li>
</ul>
</li>
</ul>
<p>因为声明式框架在更新时比命令式框架多了“<strong>找出差异</strong>”的过程，所以声明式代码的性能不会优于命令式代码的性能。而对比命令式代码，声明式代码又具有更强的可维护性，更加的直观。所以框架要做的就是：<strong>在保持可维护性的同时让性能损失最小化</strong>。</p>
<p>在开发过程中，原生<code>JS</code>操作DOM，虚拟DOM和<code>innerHTML</code>三者操作页面的性能都与创建页面、更新页面，页面大小、变更部分的大小有关系，选择哪种更新策略，需要结合心智负担、可维护性等因素综合考虑。</p>
<p><strong>性能对比</strong></p>

































<table><thead><tr><th>更新策略</th><th>心智负担</th><th>可维护性</th><th>性能</th><th>适用场景</th></tr></thead><tbody><tr><td>原生<code>JS</code></td><td>高</td><td>低</td><td>最高</td><td>简单页面</td></tr><tr><td>虚拟DOM</td><td>中</td><td>高</td><td>中</td><td>复杂应用</td></tr><tr><td><code>innerHTML</code></td><td>低</td><td>中</td><td>低</td><td>静态内容</td></tr></tbody></table>
<h3 data-id="heading-2">运行时 VS 编译时</h3>
<blockquote>
<p>以上文中声明式框架示例代码为例，简单描述<code>vue.js</code>的渲染过程：</p>
<p>1、通过<strong>编译器【compile】</strong> 解析模版字符串识别到需要创建一个DOM元素，设置内容为<code>hello world</code>，并为其绑定一个点击事件，完成后输出一个虚拟DOM【即一个描述真实DOM的<code>js</code>对象】</p>
<p>2、通过<strong>渲染函数【render】</strong> 将虚拟DOM渲染成真实的DOM树挂载到指定元素上，完成渲染</p>
</blockquote>
<p>当设计一个框架的时候，有三种选择</p>
<ul>
<li>纯运行时
<ul>
<li>上面提到的如果<strong>只用渲染函数</strong>，由用户直接提供虚拟DOM作为入参，就是所谓的<strong>纯运行时框架</strong></li>
<li>没有编译过程，也就无法添加相关的优化手段，比如tree-shaking</li>
</ul>
</li>
<li>运行时 + 编译时
<ul>
<li>代码运行时由编译器将语义化代码编译成目标数据并作为渲染函数的入参，这种操作就是 <strong>运行时编译框架</strong>。它既支持运行时【即用户直接提供数据对象】，又支持编译时【即将用户语义化代码编译为目标数据】</li>
<li>由于代码运行时才开始编译会产生一定的性能开销，因此可以在构建时就执行编译操作，以提升性能。【在 Vue 3.5.22 中，运行时编译通过 <code>@vue/compiler-dom</code> 实现，构建时编译通过 <code>@vitejs/plugin-vue</code> 实现】</li>
</ul>
</li>
<li>纯编译时
<ul>
<li>如果省略上面的渲染函数，直接将用户代码通过编译器完成真实DOM的渲染，就是一个纯编译时框架。即不支持任何运行时内容。</li>
<li>由于不需要任何运行时，而是直接将代码编译成可执行的<code>js</code>代码，因为性能可能会更好，但是有损灵活性。</li>
</ul>
</li>
</ul>
<p><code>Vue.js</code>就是内部封装了命令式代码从而实现的面向用户的声明式框架；是运行时+编译时架构，目的在于保持灵活性的基础上尽可能的优化性能</p>
<p>其中组件的实现依赖于<strong>渲染器</strong>，组件中模板的编译依赖于<strong>编译器</strong>。<strong>虚拟DOM</strong>作为媒介在整个渲染过程中作为组件真实DOM的载体协助实现内容渲染和更新。</p>
<h3 data-id="heading-3">虚拟DOM【<code>vnode</code>】</h3>
<p>虚拟DOM 是一个用来描述真实DOM的<code>js</code>对象。</p>
<p>使用虚拟DOM的好处是可以将不同类型的标签、属性及子节点抽象成一个对象，这样描述<code>UI</code>可以更加灵活。</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">// 上文中的代码可以用以下形式表示</span>
<span class="hljs-keyword">const</span> vnode= {
    <span class="hljs-comment">// 标签名称</span>
    <span class="hljs-attr">tag</span>: <span class="hljs-string">'div'</span>,
    <span class="hljs-comment">// 标签属性</span>
    <span class="hljs-attr">props</span>: {
        <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span><span class="hljs-title function_">alert</span>(<span class="hljs-string">'ok'</span>)
    },
    <span class="hljs-comment">// 子节点</span>
    <span class="hljs-attr">children</span>: <span class="hljs-string">'hello world'</span>
}
</code></pre>
<blockquote>
<p><code>vue</code>中的<code>h</code>函数就是一个辅助创建虚拟DOM的工具函数</p>
</blockquote>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-keyword">import</span> { h } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">'ok'</span>) }, <span class="hljs-string">'hello world'</span>)
    }
}

<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">tag</span>: <span class="hljs-string">'div'</span>,
            <span class="hljs-attr">props</span>: {
                <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">'ok'</span>)
            },
            <span class="hljs-attr">children</span>: <span class="hljs-string">'hello world'</span>
        }
    }
}

<span class="hljs-comment">// 等价于</span>
&lt;div <span class="hljs-meta">@click</span>=<span class="hljs-string">"() =&gt; alert('ok')"</span>&gt;hello world&lt;/div&gt;
</code></pre>
<p>虚拟DOM的性能优势：</p>
<ul>
<li>批量更新：可以将多次DOM操作合并为一次</li>
<li>跨平台：同一套代码可以渲染到不同平台</li>
<li>优化策略：通过<code>diff</code>算法最小化DOM操作</li>
</ul>
<h3 data-id="heading-4">组件</h3>
<p>组件就是一组DOM元素的封装，它可以是一个返回虚拟DOM的函数，也可以是一个对象。组件的返回值也是虚拟DOM，它代表组件要渲染的内容。</p>
<h3 data-id="heading-5">编译器【compile】</h3>
<p>编译器的作用是将组件模板【<code>&lt;template&gt;</code>】编译为渲染函数并添加到<code>&lt;script&gt;</code>标签块的组件对象上</p>
<pre><code class="hljs language-xml" lang="xml">// demo.vue
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
&lt;div@click="handler"&gt;
        hello world
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
exportdefault {
        <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) { }
        <span class="hljs-attr">methods</span>: {
            <span class="hljs-attr">handler</span>: <span class="hljs-function">() =&gt;</span><span class="hljs-title function_">alert</span>(<span class="hljs-string">'ok'</span>)
        }
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>组件编译后结果：</p>
<pre><code class="hljs language-javascript" lang="javascript">exportdefault {
    <span class="hljs-title function_">data</span>(<span class="hljs-params"/>) {},
    <span class="hljs-attr">methods</span>: {
        <span class="hljs-attr">handler</span>: <span class="hljs-function">() =&gt;</span><span class="hljs-title function_">alert</span>(<span class="hljs-string">'ok'</span>)
    },
    <span class="hljs-title function_">render</span>(<span class="hljs-params"/>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">_createElementVNode</span>(<span class="hljs-string">'div'</span>, { <span class="hljs-attr">onClick</span>: handler }, <span class="hljs-string">'hello world'</span>, -<span class="hljs-number">1</span><span class="hljs-comment">/* HOISTED */</span>)
    }
}
</code></pre>
<p>无论是使用模板还是直接手写渲染函数，对于一个组件来说，它要渲染的内容最终都是通过渲染函数产生的。然后再将渲染函数返回的虚拟DOM作为渲染器的入参，进行真实DOM的渲染</p>
<p><code>Vue3</code>的编译优化：</p>
<ul>
<li>静态提升：将静态内容提升到渲染函数外部</li>
<li>补丁标记：为动态内容添加标记，优化<code>diff</code>过程【通过在虚拟DOM中添加标记实现】</li>
<li><code>tree-shaking</code>：移除未使用代码</li>
</ul>
<h3 data-id="heading-6">渲染器【renderer】</h3>
<p>渲染器的作用就是递归遍历虚拟DOM对象，并调用原生<code>DOM API</code>来完成真实DOM的创建。</p>
<p>渲染器的精髓在于后续的更新，它会通过<code>Diff</code>算法寻找并且只更新变化内容。</p>
<p>大致实现思路如下：</p>
<ul>
<li>如果不是内容变更：</li>
<li>
<ul>
<li>根据<code>vnode.tag</code>创建对应DOM元素</li>
<li>遍历<code>vnode.props</code>对象，如果<code>key</code>以<code>on</code>字符开头，说明它是一个事件，调用<code>addEventListener</code>绑定事件处理函数；否则作为属性添加到DOM元素上</li>
<li>处理<code>children</code>，如果是字符串，就创建文本节点；如果是数组就递归调用<code>render</code>继续渲染，最后把创建的元素挂载到新创建的元素内</li>
</ul>
</li>
</ul>

<ul>
<li>否则先找出<code>vnode</code>对象的变更点，并且只更新变更的内容</li>
</ul>
<h3 data-id="heading-7">组件渲染过程详解：</h3>
<h5 data-id="heading-8"><code>vite</code>、<code>@vitejs/plugin-vue</code>和<code>vue-core</code>的关系</h5>
<ul>
<li>
<p><code>vite</code>中使用了<code>@vitejs/plugin-vue</code>来处理<code>vue</code>组件</p>
</li>
<li>
<p><code>@vitejs/plugin-vue</code>中集成了<code>vue-core</code>中的<code>compiler-sfc</code>用于解析编译<code>Vue</code>组件</p>
</li>
<li>
<p><code>compiler-sfc</code>中调用了<code>compiler-core</code>中的基础逻辑进行组件的编译和渲染</p>
</li>
</ul>
<p>当我们新建并启动<code>vue</code>项目后，内容是如何渲染的，又是如何实时更新的？</p>
<h4 data-id="heading-9">创建并启动一个<code>Vue</code>应用 </h4>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-comment">// 创建新项目</span>
npm create vue@latest
<span class="hljs-comment">// 进入项目后安装依赖</span>
npm install
<span class="hljs-comment">// 启动，实际执行的是vite命令</span>
npm run dev
</code></pre>
<h4 data-id="heading-10">当项目运行<code>npm run dev</code>命令时执行内容如下：</h4>
<h4 data-id="heading-11">编译阶段：</h4>
<h5 data-id="heading-12">启动一个<code>vite</code>开发服务器，浏览器会通过这个服务器来访问此项目的网页和代码</h5>
<p><code>vite</code>是一个通用的构建工具，<code>vite</code>本身并不直接处理<code>.vue</code>文件，而是通过插件系统来处理各种类型文件，其中<code>@vitejs/plugin-vue</code>就是用来处理<code>vue</code>单文件组件的</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2284b50fb4e44ecf82dc5f4f566f79d8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=AavXU%2B6fWQqANaT9e4c2mzqjgv8%3D" alt="图片" loading="lazy"/></p>
<h4 data-id="heading-13">构建时阶段</h4>
<p><code>Vite</code>接收到组件请求，会执行插件【<code>@vitejs/plugin-vue</code>】的<code>load</code>钩子函数，再执行<code>Transform</code>钩子函数</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4cf498d2125e4627a484df191975b452~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=e9M3QhwkXxxJqjhJldPe1Yh7keQ%3D" alt="图片" loading="lazy"/></p>
<p>在上图钩子函数执行过程中触发了<code>compiler-sfc</code>相关方法的执行</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/09df4edbc402409e937d769740850d74~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=RUiB%2B7mQIj5jXah01ftQpboNZGE%3D" alt="图片" loading="lazy"/><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4ea11c3f85d34604b44722b154aca173~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=8KxgD1chNHz7Q%2FBEFdHKTzN54Ss%3D" alt="图片" loading="lazy"/></p>
<h5 data-id="heading-14">监听组件变化</h5>
<p><code>@Vitejs/plugin-vue</code>插件的核心入口文件【<code>packages/plugin-vue/src/index.ts</code>】中定义了<code>Vite</code>插件的所有钩子函数，其中<code>handleHotUpdate</code>钩子是<code>Vite</code>提供的热更新处理函数，当<code>Vue</code>文件发生变化时，<code>Vite</code>会自动调用这个钩子，此时插件会检查变化的文件是否为<code>Vue</code>组件，如果是则调用专门的<code>handleHotUpdate函数</code>【<code>packages/plugin-vue/src/handleHotUpdate.ts</code>】</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c129e02641f14c62ad5dbc3c1a888d4e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=MUFBcSJ%2FoHSh66u64Jt1zUsFrZg%3D" alt="图片" loading="lazy"/></p>
<p>最终将返回</p>
<pre><code class="hljs language-c" lang="c">SFCTemplateCompileResults ： {
    code: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 渲染函数代码</span>
    ast?: RootNode, <span class="hljs-comment">// 抽象语法树</span>
    preamble?: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 预处理代码</span>
    source: <span class="hljs-built_in">string</span>, <span class="hljs-comment">// 输入源</span>
    tips: <span class="hljs-built_in">string</span>[], <span class="hljs-comment">// 提示</span>
    errors: (<span class="hljs-built_in">string</span> | CompilerError)[], <span class="hljs-comment">// 错误</span>
    <span class="hljs-built_in">map</span>?: RawSourceMap, <span class="hljs-comment">// 源映射</span>
}
</code></pre>
<p>这个阶段会将<code>.vue</code>文件转换为<code>js</code>代码，生成的是渲染函数的字符串</p>
<h4 data-id="heading-15">运行时阶段</h4>
<p>当浏览器加载并执行这些<code>js</code>代码时，就会发生真正的渲染过程</p>
<pre><code class="hljs language-scss" lang="scss">应用启动 -&gt; <span class="hljs-built_in">createApp</span>() -&gt; app<span class="hljs-selector-class">.mount</span>() -&gt; <span class="hljs-built_in">render</span>() -&gt; <span class="hljs-built_in">patch</span>() -&gt; <span class="hljs-built_in">mountElement</span>() -&gt; 真实DOM
</code></pre>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/59b801a153e24563ae174e29b29b870e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgRWNob0VjaG8=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771130182&amp;x-signature=I5TwTb1ZBF42SwbAYwPJX7dWxiA%3D" alt="图片" loading="lazy"/></p>
<p>到此就完成了<code>vue</code>中基本的渲染过程。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[主管:”人家 Node 框架都用 Nest.js 了 , 你怎么还在用 Express ?“]]></title>    <link>https://juejin.cn/post/7603688142004617225</link>    <guid>https://juejin.cn/post/7603688142004617225</guid>    <pubDate>2026-02-08T04:43:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603688142004617225" data-draft-id="7603651855236595721" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="主管:”人家 Node 框架都用 Nest.js 了 , 你怎么还在用 Express ?“"/> <meta itemprop="keywords" content="前端,后端,面试"/> <meta itemprop="datePublished" content="2026-02-08T04:43:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="千寻girling"/> <meta itemprop="url" content="https://juejin.cn/user/2276467567770442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            主管:”人家 Node 框架都用 Nest.js 了 , 你怎么还在用 Express ?“
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2276467567770442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    千寻girling
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T04:43:22.000Z" title="Sun Feb 08 2026 04:43:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读10分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;color:rgba(46,36,36,.87);overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{margin-bottom:5px;font-size:30px;font-weight:500}.markdown-body h1:before{content:"#";margin-right:10px;color:#1976d2}.markdown-body h2{font-size:28px;font-weight:400;border-left:5px solid #454545;margin-top:20px;padding-left:10px;transition:all .3s ease-in-out}.markdown-body h2:hover{border-color:#1976d2}.markdown-body h3{font-size:24px;font-weight:400;margin-top:15px;padding-bottom:0}.markdown-body h4{font-size:20px;font-weight:500}.markdown-body h5{font-size:16px}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body h2:first-letter,.markdown-body h3:first-letter,.markdown-body p:first-letter{text-transform:capitalize}.markdown-body em{text-emphasis:dot;text-emphasis-position:under}.markdown-body img{display:block;margin:0 auto!important;max-width:100%;border-radius:2px;box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)!important}.markdown-body hr{position:relative;width:98%;height:1px;border:none;margin-top:32px;margin-bottom:32px;background-image:linear-gradient(90deg,#ddd,#999,#ddd);overflow:visible}.markdown-body hr:after{content:"";position:absolute;margin:auto;left:0;right:0;bottom:0;top:0;display:inline-block;width:60px;height:20px;background:#fff;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAgCAYAAABgrToAAAADoklEQVRYR82XTYgcRRTHf2933Q1RjAa9eFO8JHoJ8RQVBQ2iBwXBET0YEUTXNVmNQtTpmeqaWV0XNRq/o4KoECSCEPSg4CF+BYUkIIiCoCJCPIhC/Ihh2Z0nVV27VnZnenumW9i6ddV7//frV69fVQurfMgq56NawFTPAU6QyomqXrw6wIZeyhCPebA5buNR+akKyGoAjd6BshthnYdSjqNcRVuOlIUsD2j0SuA94IwuMHdh5ZUykOUBXfSGbmKI54EtAeYIHSZoy5dl4JxvNYBOKdW1KE8BQ8AkVk6WhasWsAiN0TX9gveXQaPP+Aytpc4u+bMI06JNohsYYYYOR2lJWtS3OKDRfcAtQfgDoI6Vo4UCGb0OmAEuDvZvYmVbEd/igC3dzDz7gQu8sPA9kJDK27mBmjqBeLjTg90PDFOjWawFFQd06kZHEfaj3LAIpTRpSXsZ5E06zEYP9sDimnAApYaV2SLZG/wjMeqAkijwW4xQJ5Gf/ZzRC8OW3hiBTGGlURRswW55Bh/Ssxljrwew8l1PQaM14GngvGDzBUKdDsMeTtgU5o8B92PFlUf3YXUrHa7Fys6lBqcCGnX15YQ2A18FyPd7Crd1A3M8C1wdbH4DD3hWeP6IEXbQkG97ajR1HPFnuPP5jFFq1OWX7hl8WM9l1AO648uNfwLk7tytMeogty+xeQ4rO3r6bdcx1nuwOGsHmaXGtPzae4uzGnLH1kQkvpdZGrHjssBZJrL+pqS05KWc8tgITAPXRzYvYOXe/C2OV43eDcRBDtIhoS2f9wzc0Cv8Wls+zoFzUC5zF0U241h5uZtPfptp6OUM8wbK+cH5GEpCS17P3fJei0Z3+npTxryJ8CPzbKMtn/ZyWbkPGl0PuFPkmkjkcb4h4R2ZLwRq1H0ALmvjkf2HwK1Y+T1PY2XABe/sHJ6MxN5lnoSpnC/UGbsTaI5phK2R7x6s3Ffk5YoDOrWm3onwJHBmEP86bPmBrsGaenNoIdnxCH+gPEhLXi0Cl1VBvyPVLSh7gEuC62yAfOIUqabWEaaiucMIk6RyqJ+Q/QM69V26jjW86Gvov/EaoyT8zRCn+Xq7PVrbx0nuYUaO9wM3WAbjCE1NEUw09Um4UV+2OKfYfu5/S19gsAzGKqm6LE5FrShbdS0ku465DjDwKA/oQht19ejqbaEVuRbiLhuHByYLjtUAZpDutzP7cYdHsPJXWbjyNVgFwQoa1WXwf4Jd9YD/Ap80+yE7+u9aAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-size:auto 100%;background-position-x:center}.markdown-body code{font-weight:900;word-break:break-word;border-radius:2px;overflow-x:auto;font-size:.87em;padding:.065em .4em;background-color:#fbe5e1;color:#c0341d}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border-radius:0 4px}.markdown-body pre&gt;code{font-weight:400;font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{margin:0 4px;text-decoration:none;color:#027fff;transition:all .3s ease-in-out;padding-bottom:4px;border-bottom:2px solid transparent}.markdown-body a:after{content:"";display:inline-block;width:18px;height:18px;margin-left:4px;vertical-align:middle;background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMiIgaGVpZ2h0PSIyMiI+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2U9IiMwMjdGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PHBhdGggZD0iTTkuODE1IDYuNDQ4bDEuOTM2LTEuOTM2YzEuMzM3LTEuMzM2IDMuNTgtMS4yNTkgNS4wMTMuMTczIDEuNDMyIDEuNDMyIDEuNTEgMy42NzYuMTczIDUuMDEzbC0xLjQ1MiAxLjQ1Mi0uOTY4Ljk2OGMtMS4zMzcgMS4zMzYtMy41ODEgMS4yNTktNS4wMTMtLjE3MyIvPjxwYXRoIGQ9Ik0xMS4yNjcgMTUuMzY3bC0xLjkzNiAxLjkzNmMtMS4zMzYgMS4zMzctMy41OCAxLjI2LTUuMDEyLS4xNzMtMS40MzItMS40MzItMS41MS0zLjY3Ni0uMTczLTUuMDEybDEuNDUyLTEuNDUyLjk2OC0uOTY4YzEuMzM2LTEuMzM3IDMuNTgtMS4yNiA1LjAxMi4xNzMiLz48L2c+PC9zdmc+);background-size:cover;background-repeat:no-repeat}.markdown-body a:hover{border-color:#027fff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body a.footnote-backref:after,.markdown-body a.footnote-ref:after,.markdown-body sup a:after{display:none!important}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border:2px solid #c6c6c6}.markdown-body table img{box-shadow:none!important}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body del{color:rgba(0,0,0,.6)}.markdown-body blockquote{position:relative;color:#666;padding:5px 23px 1px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:hsla(0,0%,78.4%,.12);transition:all .2s ease-in-out}.markdown-body blockquote:hover{border-color:#1976d2}.markdown-body blockquote:after,.markdown-body blockquote:before{position:absolute;font-size:24px;font-weight:800;line-height:24px;color:#cbcbcb;opacity:.6}.markdown-body blockquote:before{content:"“";top:4px;left:6px}.markdown-body blockquote:after{content:"”";right:8px;bottom:-8px}.markdown-body blockquote&gt;p,.markdown-body blockquote blockquote{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body details{outline:none;border:none;border-left:4px solid #1976d2;padding-left:10px;margin-left:4px}.markdown-body details summary{cursor:pointer;border:none;outline:none;background:#fff;margin:0 -17px}.markdown-body details summary:hover::-webkit-details-marker{color:#1976d2}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>我反驳主管道 : “我自己做项目做着玩 ! 你管我用哪一个 !”</p>
</blockquote>
<blockquote>
<p>回家之后 , 我开始好奇那么多 Node 框架 , 到底有什么区别啊?</p>
</blockquote>
<blockquote>
<p>Node.js Web 框架各式各样 , 下面简单的介绍一下这些 Node.js Web 框架 !</p>
</blockquote>
<h3 data-id="heading-0">一、分类</h3>
<p>Node.js Web 框架主要分 3 类：</p>



































<table><thead><tr><th>分类</th><th>核心特点</th><th>代表框架</th><th>适用场景</th></tr></thead><tbody><tr><td>极简核心框架</td><td>仅封装 HTTP 基础能力，无冗余功能</td><td><strong>Express、Koa</strong></td><td>中小型 API、自定义业务系统</td></tr><tr><td>全栈 / 企业级框架</td><td>内置路由、ORM、验证、鉴权等全套能力</td><td><strong>NestJS、AdonisJS</strong></td><td>大型企业应用、团队协作项目</td></tr><tr><td>高性能框架</td><td>基于异步 I/O/ 编译优化，极致性能</td><td><strong>Fastify、Hapi</strong></td><td>高并发 API、微服务</td></tr><tr><td>特殊场景框架</td><td>针对特定场景优化（如 SSR、低代码）</td><td><strong>Next.js、Nuxt.js（Node 端）、Sails.js</strong></td><td>前端 SSR、低代码平台</td></tr></tbody></table>
<h3 data-id="heading-1">二、主流框架详细介绍</h3>
<blockquote>
<p>⚠️ : 排名不分先后顺序</p>
</blockquote>
<h4 data-id="heading-2">1. Express（最经典的极简框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：Node.js Web 框架的 “鼻祖”，极简、灵活，无内置冗余功能，生态最丰富。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>中间件机制（线性中间件，<code>req -&gt; 中间件1 -&gt; 中间件2 -&gt; res</code>）；</li>
<li>简洁的路由系统；</li>
<li>无内置 ORM / 验证，需手动集成第三方库（如 <code>mongoose</code>、<code>express-validator</code>）。</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

<span class="hljs-comment">// 中间件</span>
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">json</span>());

<span class="hljs-comment">// 路由</span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/api/user'</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {
  res.<span class="hljs-title function_">json</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> });
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Express 启动在 3000 端口'</span>));
</code></pre>
</li>
<li>
<p><strong>优点</strong>：生态极全（几乎所有 Node 库都兼容）、学习成本低、灵活度高；</p>
</li>
<li>
<p><strong>缺点</strong>：回调嵌套（易出现 “回调地狱”）、无内置类型支持（TS 需手动配置）、无统一规范（团队协作易混乱）；</p>
</li>
<li>
<p><strong>适用场景</strong>：中小型 API 服务、快速原型开发、个人项目。</p>
</li>
</ul>
<h4 data-id="heading-3">2. Koa（Express 团队升级版）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：Express 原团队开发，解决 Express 回调地狱问题，基于 <code>async/await</code> 重构。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>洋葱模型中间件（中间件可双向执行，如 “请求进来执行 -&gt; 响应出去再执行”）；</li>
<li>原生支持 <code>async/await</code>，无回调地狱；</li>
<li>比 Express 更精简（甚至没有内置路由，需装 <code>koa-router</code>）。</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs language-ini" lang="ini">const <span class="hljs-attr">Koa</span> = require(<span class="hljs-string">'koa'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">koaRouter</span> = require(<span class="hljs-string">'koa-router'</span>)<span class="hljs-comment">;</span>
const <span class="hljs-attr">koaBody</span> = require(<span class="hljs-string">'koa-body'</span>)<span class="hljs-comment">;</span>

const <span class="hljs-attr">app</span> = new Koa()<span class="hljs-comment">;</span>
const <span class="hljs-attr">router</span> = new koaRouter()<span class="hljs-comment">;</span>

// 洋葱模型中间件
app.use(async (ctx, next) =&gt; {
  console.log('请求开始')<span class="hljs-comment">;</span>
  await next()<span class="hljs-comment">; // 执行下一个中间件</span>
  console.log('请求结束')<span class="hljs-comment">; // 响应时执行</span>
})<span class="hljs-comment">;</span>

app.use(koaBody())<span class="hljs-comment">;</span>
router.get('/api/user', async (ctx) =&gt; {
  <span class="hljs-attr">ctx.body</span> = { name: <span class="hljs-string">'张三'</span>, age: <span class="hljs-number">20</span> }<span class="hljs-comment">;</span>
})<span class="hljs-comment">;</span>

app.use(router.routes())<span class="hljs-comment">;</span>
app.listen(3000, () =&gt; console.log('Koa 启动在 3000 端口'))<span class="hljs-comment">;</span>
</code></pre>
</li>
<li>
<p><strong>优点</strong>：异步体验好、洋葱模型灵活（适合日志 / 鉴权 / 异常捕获）、轻量；</p>
</li>
<li>
<p><strong>缺点</strong>：生态比 Express 略少、需手动集成更多第三方库；</p>
</li>
<li>
<p><strong>适用场景</strong>：中小型 API 服务、需要灵活中间件的场景、嫌弃 Express 回调的项目。</p>
</li>
</ul>
<h4 data-id="heading-4">3. NestJS（企业级 TypeScript 框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：对标 Spring Boot，基于 TypeScript，强调模块化、依赖注入，适合大型团队协作。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>强制 TypeScript 开发，类型安全；</li>
<li>模块化架构（Module + Controller + Service）；</li>
<li>内置依赖注入、拦截器、管道、守卫（鉴权）、过滤器；</li>
<li>兼容 Express/Koa，可无缝集成第三方库；</li>
<li>支持微服务、GraphQL、WebSocket。</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs language-typescript" lang="typescript"><span class="hljs-comment">// user.controller.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">UserService</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./user.service'</span>;

<span class="hljs-meta">@Controller</span>(<span class="hljs-string">'api/user'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> userService: UserService</span>) {}

  <span class="hljs-meta">@Get</span>()
  <span class="hljs-title function_">getUser</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span>.<span class="hljs-title function_">getUser</span>();
  }
}

<span class="hljs-comment">// user.service.ts</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Injectable</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'@nestjs/common'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> {
  <span class="hljs-title function_">getUser</span>(<span class="hljs-params"/>) {
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> };
  }
}
</code></pre>
</li>
<li>
<p><strong>优点</strong>：规范统一、类型安全、适合大型项目 / 团队、生态完善（官方封装了大量企业级能力）；</p>
</li>
<li>
<p><strong>缺点</strong>：学习成本高、入门门槛高、小型项目用着 “重”；</p>
</li>
<li>
<p><strong>适用场景</strong>：大型企业应用、微服务、团队协作项目、需要强类型的项目。</p>
</li>
</ul>
<h4 data-id="heading-5">4. Fastify（高性能极简框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：极致性能，比 Express 快 2-3 倍，专为高并发 API 设计。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>基于 JSON Schema 验证请求参数，性能优于传统验证库；</li>
<li>内置日志、压缩、路由缓存，无需额外配置；</li>
<li>兼容 Express 中间件；</li>
<li>支持 TypeScript。</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs language-php" lang="php"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">fastify</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">'fastify'</span>)({ logger: <span class="hljs-literal">true</span> });

<span class="hljs-comment">// 路由 + 参数验证</span>
fastify.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">'/api/user'</span>, {
  <span class="hljs-attr">schema</span>: {
    <span class="hljs-attr">querystring</span>: {
      <span class="hljs-attr">age</span>: { <span class="hljs-attr">type</span>: <span class="hljs-string">'number'</span> }
    }
  }
}, <span class="hljs-title function_ invoke__">async</span> (request, reply) =&gt; {
  <span class="hljs-keyword">return</span> { <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: request.query.age || <span class="hljs-number">20</span> };
});

fastify.<span class="hljs-title function_ invoke__">listen</span>({ <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span> }, (err) =&gt; {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
  console.<span class="hljs-title function_ invoke__">log</span>(<span class="hljs-string">'Fastify 启动在 3000 端口'</span>);
});
</code></pre>
</li>
<li>
<p><strong>优点</strong>：性能极高、内置功能丰富（无需装大量中间件）、轻量；</p>
</li>
<li>
<p><strong>缺点</strong>：生态比 Express 小、部分特性（如 Schema 验证）有学习成本；</p>
</li>
<li>
<p><strong>适用场景</strong>：高并发 API、微服务、对性能要求高的项目。</p>
</li>
</ul>
<h4 data-id="heading-6">5. Hapi（稳定的企业级框架）</h4>
<blockquote>
<p>“还记得当初在 <strong>沃尔玛</strong> 买了虾 , 自己回家自己做 <strong>鸡油炒河虾仁</strong> , 艾玛 , 老香了!!! ”</p>
</blockquote>
<ul>
<li>
<p><strong>核心定位</strong>：由 Walmart ( 沃尔玛  ) 开发，强调配置优于编码，适合稳定的企业级服务。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>内置路由、验证、缓存、日志，无需第三方库；</li>
<li>插件化架构，扩展能力强；</li>
<li>稳定性极高（适合金融 / 电商等核心系统）。</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：稳定、内置功能全、安全性高；</p>
</li>
<li>
<p><strong>缺点</strong>：学习成本高、灵活性低、性能不如 Fastify；</p>
</li>
<li>
<p><strong>适用场景</strong>：金融 / 电商等核心系统、对稳定性要求极高的项目。</p>
</li>
</ul>
<h4 data-id="heading-7">6. Next.js（前端 SSR/SSG 框架，Node 端核心）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：React 生态的全栈框架，Node 端负责服务端渲染（SSR）、静态生成（SSG）。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>服务端渲染（提升 SEO、首屏加载速度）；</li>
<li>自动路由（基于文件系统）；</li>
<li>内置 API 路由（无需额外搭后端）；</li>
<li>支持静态生成、增量静态再生。</li>
</ul>
</li>
<li>
<p><strong>适用场景</strong>：React 前端项目、需要 SEO 的网站（如博客、电商）、全栈 React 应用。</p>
</li>
</ul>
<h4 data-id="heading-8">7. Sails.js（低代码 / 快速开发框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：对标 Ruby on Rails，内置 ORM、蓝图 API、实时通信，适合快速开发全栈应用。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>自动生成 CRUD API（蓝图路由）；</li>
<li>内置 Waterline ORM（支持多数据库）；</li>
<li>支持 WebSocket 实时通信；</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：开发速度极快、低代码；</p>
</li>
<li>
<p><strong>缺点</strong>：灵活性低、定制化成本高；</p>
</li>
<li>
<p><strong>适用场景</strong>：快速原型开发、低代码平台、小型全栈应用。</p>
</li>
</ul>
<h4 data-id="heading-9">8. AdonisJS（Node.js 版的 Laravel，全栈企业级框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：对标 PHP 界的 Laravel，是 Node.js 生态中 “开箱即用” 的全栈框架，内置全套企业级能力，强调 “约定优于配置”。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>内置 ORM（Lucid ORM）：支持 MySQL、PostgreSQL 等，无需手动集成第三方 ORM；</li>
<li>内置身份验证（用户注册 / 登录 / 权限）、表单验证、CSRF 保护；</li>
<li>支持 MVC 架构、路由分组、中间件、任务调度；</li>
<li>原生支持 TypeScript，类型安全；</li>
<li>内置模板引擎（Edge），也支持前后端分离；</li>
</ul>
</li>
<li>
<p><strong>示例代码（核心路由 + ORM）</strong> ：</p>
<pre><code class="hljs language-dart" lang="dart"><span class="hljs-comment">// start/routes.ts</span>
<span class="hljs-keyword">import</span> Route from <span class="hljs-string">'@ioc:Adonis/Core/Route'</span>
<span class="hljs-keyword">import</span> User from <span class="hljs-string">'App/Models/User'</span>

<span class="hljs-comment">// 路由 + 数据库查询</span>
Route.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/api/user'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> User.find(<span class="hljs-number">1</span>) <span class="hljs-comment">// Lucid ORM 查用户</span>
  <span class="hljs-keyword">return</span> { name: user?.name, age: user?.age }
})

<span class="hljs-comment">// 表单验证</span>
Route.post(<span class="hljs-string">'/api/user'</span>, <span class="hljs-keyword">async</span> ({ request }) =&gt; {
  <span class="hljs-keyword">const</span> data = request.validate({
    schema: {
      name: schema.string(),
      age: schema.number()
    }
  })
  <span class="hljs-keyword">await</span> User.create(data) <span class="hljs-comment">// 新增用户</span>
  <span class="hljs-keyword">return</span> { success: <span class="hljs-keyword">true</span> }
})
</code></pre>
</li>
<li>
<p><strong>优点</strong>：开箱即用（无需装大量依赖）、Laravel 开发者易上手、规范统一、内置安全特性；</p>
</li>
<li>
<p><strong>缺点</strong>：生态比 Express/NestJS 小、灵活性略低、国内使用较少（中文文档有限）；</p>
</li>
<li>
<p><strong>适用场景</strong>：全栈 Node.js 应用、Laravel 转 Node 开发的团队、中小型企业应用、需要快速搭建带数据库的业务系统。</p>
</li>
</ul>
<h4 data-id="heading-10">9. Nuxt.js（Vue 生态全栈框架，Node 端负责 SSR/SSG）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：Vue 生态的官方全栈框架，基于 Vue + Node.js 实现服务端渲染（SSR）、静态站点生成（SSG），解决 Vue 单页应用 SEO 差的问题。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>自动路由（基于 <code>pages</code> 目录，无需手动配置路由）；</li>
<li>服务端渲染（SSR）、静态生成（SSG）、增量静态再生（ISR）；</li>
<li>内置 API 路由（<code>server/api</code> 目录，无需额外搭后端服务）；</li>
<li>支持 Vue3 + TypeScript、自动代码分割、缓存优化；</li>
<li>集成 Pinia（状态管理）、Nuxt Modules（生态插件）；</li>
</ul>
</li>
<li>
<p><strong>示例代码（核心用法）</strong> ：</p>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-comment">&lt;!-- pages/api/user.vue (页面路由) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ user.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-comment">// 服务端获取数据（SSR）</span>
<span class="hljs-keyword">const</span> { <span class="hljs-attr">data</span>: user } = <span class="hljs-keyword">await</span> <span class="hljs-title function_">useAsyncData</span>(<span class="hljs-string">'user'</span>, <span class="hljs-function">() =&gt;</span> 
  $fetch(<span class="hljs-string">'/api/user'</span>) <span class="hljs-comment">// 调用内置 API 路由</span>
)
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

// server/api/user.ts (内置 API 路由)
export default defineEventHandler(() =&gt; {
  return { name: '张三', age: 20 }
})
</code></pre>
</li>
<li>
<p><strong>优点</strong>：Vue 开发者无缝上手、解决 SEO 问题、全栈一体化（前端 + Node 端）、生态完善；</p>
</li>
<li>
<p><strong>缺点</strong>：仅适配 Vue 技术栈、Node 端逻辑定制化能力有限、大型项目需深入理解其生命周期；</p>
</li>
<li>
<p><strong>适用场景</strong>：Vue 全栈应用、需要 SEO 的网站（博客 / 电商 / 官网）、静态站点生成、中小型 Vue 项目。</p>
</li>
</ul>
<h4 data-id="heading-11">10. Egg.js（阿里开源，企业级 Node.js 框架）</h4>
<ul>
<li>
<p><strong>核心定位</strong>：阿里开源的企业级框架，基于 Express/Koa 封装，强调 “约定优于配置”，适合中大型团队协作。</p>
</li>
<li>
<p><strong>核心特性</strong>：</p>
<ul>
<li>基于 Koa2（洋葱模型），兼容 Koa/Express 中间件；</li>
<li>内置多进程模型（Master + Worker），自动利用多核 CPU；</li>
<li>插件化架构（如 egg-mysql、egg-redis），生态丰富（阿里官方维护）；</li>
<li>支持 TypeScript、单元测试、日志、监控；</li>
<li>规范的目录结构（controller/service/middleware/config），团队协作友好；</li>
</ul>
</li>
<li>
<p><strong>示例代码</strong>：</p>
<pre><code class="hljs language-scala" lang="scala"><span class="hljs-comment">// app/controller/user.js</span>
const { <span class="hljs-type">Controller</span> } = require('egg');

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> </span>{
  async index() {
    const { ctx } = <span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// 调用 service 层</span>
    const user = await ctx.service.user.getUser();
    ctx.body = user;
  }
}

module.exports = <span class="hljs-type">UserController</span>;

<span class="hljs-comment">// app/service/user.js</span>
const { <span class="hljs-type">Service</span> } = require('egg');

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>{
  async getUser() {
    <span class="hljs-comment">// 用 egg-mysql 查数据库</span>
    <span class="hljs-keyword">return</span> await <span class="hljs-keyword">this</span>.app.mysql.get('user', { id: <span class="hljs-number">1</span> });
  }
}

module.exports = <span class="hljs-type">UserService</span>;
</code></pre>
</li>
<li>
<p><strong>优点</strong>：阿里背书、规范统一、多进程性能优、国内生态完善（中文文档 / 社区）、适合团队协作；</p>
</li>
<li>
<p><strong>缺点</strong>：灵活性低于 Express/Koa、学习成本中等、小型项目用着 “重”；</p>
</li>
<li>
<p><strong>适用场景</strong>：中大型企业应用、阿里系技术栈项目、国内团队协作项目、需要多进程优化的 Node 服务。</p>
</li>
</ul>
<h3 data-id="heading-12">三、 对比</h3>



















































































































<table><thead><tr><th>框架</th><th>学习成本</th><th>性能</th><th>生态</th><th>类型支持</th><th>适用规模</th><th>核心优势</th><th>技术栈 / 定位</th></tr></thead><tbody><tr><td>Express</td><td>低</td><td>中等</td><td>极丰富</td><td>需手动配</td><td>小 / 中</td><td>灵活、生态全、入门快</td><td>极简核心框架</td></tr><tr><td>Koa</td><td>中</td><td>中等</td><td>丰富</td><td>需手动配</td><td>小 / 中</td><td>洋葱模型、async/await</td><td>极简核心框架（Express 升级版）</td></tr><tr><td>NestJS</td><td>高</td><td>中等</td><td>丰富</td><td>原生 TS</td><td>中 / 大</td><td>规范、企业级、团队协作</td><td>企业级 TS 框架</td></tr><tr><td>Fastify</td><td>中</td><td>极高</td><td>中等</td><td>原生 TS</td><td>小 / 中 / 大</td><td>极致性能、内置功能全</td><td>高性能极简框架</td></tr><tr><td>Hapi</td><td>高</td><td>中高</td><td>中等</td><td>需手动配</td><td>中 / 大</td><td>稳定、安全、企业级</td><td>企业级配置优先框架</td></tr><tr><td>Next.js</td><td>中</td><td>中等</td><td>极丰富</td><td>原生 TS</td><td>小 / 中 / 大</td><td>React SSR、全栈一体化</td><td>React 全栈框架</td></tr><tr><td>Sails.js</td><td>低</td><td>中等</td><td>中等</td><td>需手动配</td><td>小</td><td>低代码、开发速度快</td><td>低代码全栈框架</td></tr><tr><td>AdonisJS</td><td>中</td><td>中等</td><td>中等</td><td>原生 TS</td><td>小 / 中</td><td>Laravel 风格、开箱即用</td><td>全栈企业级框架（Node 版 Laravel）</td></tr><tr><td>Nuxt.js</td><td>中</td><td>中等</td><td>极丰富</td><td>原生 TS</td><td>小 / 中 / 大</td><td>Vue SSR、全栈一体化、SEO 优</td><td>Vue 全栈框架</td></tr><tr><td>Egg.js</td><td>中</td><td>中高</td><td>丰富</td><td>需手动配</td><td>中 / 大</td><td>阿里背书、多进程、国内生态好</td><td>企业级框架（基于 Koa）</td></tr></tbody></table>
<h3 data-id="heading-13">四、选型建议</h3>
<ol>
<li><strong>个人 / 小型项目、快速开发</strong>：选 Express（生态全）或 Koa（异步体验好）；</li>
<li><strong>高并发 API、微服务</strong>：选 Fastify（性能第一）；</li>
<li><strong>大型企业应用、团队协作</strong>：选 NestJS（TS + 规范）或 Hapi（稳定）；</li>
<li><strong>React 全栈、需要 SEO</strong>：选 Next.js；</li>
<li><strong>低代码、快速原型</strong>：选 Sails.js。</li>
</ol>
<h3 data-id="heading-14">总结</h3>
<ol>
<li><strong>核心维度</strong>：选型优先看「项目规模 + 团队技术栈 + 性能要求」，小型项目别用重框架（如 NestJS），大型项目别用太灵活的框架（如 Express）；</li>
<li><strong>生态优先级</strong>：如果需要集成大量第三方库，Express / Koa / Next.js 是首选；</li>
<li><strong>性能优先级</strong>：高并发场景直接选 Fastify；</li>
<li><strong>团队协作</strong>：大型团队优先 NestJS（强规范），避免 Express 因灵活导致的代码混乱。</li>
</ol>
<blockquote>
<p>okokok , 这个文章到这里就结束了 , 我们有缘再会 😁😁😁 !!!</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Nginx 路径映射深度解析：从本地开发到生产交付的底层哲学]]></title>    <link>https://juejin.cn/post/7603699739223293967</link>    <guid>https://juejin.cn/post/7603699739223293967</guid>    <pubDate>2026-02-08T05:01:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603699739223293967" data-draft-id="7603673564908732451" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Nginx 路径映射深度解析：从本地开发到生产交付的底层哲学"/> <meta itemprop="keywords" content="前端,后端,架构"/> <meta itemprop="datePublished" content="2026-02-08T05:01:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="文艺理科生Owen"/> <meta itemprop="url" content="https://juejin.cn/user/3817963023244503"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Nginx 路径映射深度解析：从本地开发到生产交付的底层哲学
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3817963023244503/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    文艺理科生Owen
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T05:01:07.000Z" title="Sun Feb 08 2026 05:01:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读6分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Nginx 静态资源映射：从原理到生产环境的最佳实践</h2>
<blockquote>
<p><strong>摘要</strong>：在现代前后端分离架构中，Nginx 不仅是高性能的静态资源服务器，更是不可或缺的反向代理枢纽。然而，由于对资源映射（root/alias）及请求转发（proxy_pass）逻辑的理解偏差，往往会导致从 Windows 开发环境迁移至 Linux 生产环境时出现 404 或转发异常。本文将从 HTTP 协议视角出发，深度剖析“路径映射三剑客”的底层逻辑，并提供一套可落地的工程化配置规范与避坑指南。</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">1. 业务场景与工程痛点</h3>
<p>在实际的工程链路中，我们经常遇到这样的场景：
前端同学在 Windows 本地使用 Nginx 调试 SPA（单页应用）或静态站点，一切运行正常。但当 CI/CD 流水线将代码部署到 Linux 生产服务器后，访问特定资源（如图片、次级路由）却频频出现 404 错误。</p>
<p>这并非玄学，而是由于对 <strong>Nginx 路径解析机制</strong> 及 <strong>操作系统文件系统差异</strong> 理解不足导致的。要解决这个问题，我们需要先建立正确的路径映射心智模型。</p>
<h3 data-id="heading-2">2. 核心模型解析：URL 与文件系统的映射</h3>
<p>Nginx 的核心职责之一，就是将抽象的 <strong>HTTP URI</strong> 映射到具体的 <strong>服务器文件系统路径</strong>。</p>
<h4 data-id="heading-3">2.1 URI 的语义差异</h4>
<p>在配置之前，必须明确 URL 尾部斜杠的协议语义：</p>
<ul>
<li><strong><code>/images</code></strong>：客户端请求名为 <code>images</code> 的<strong>资源实体</strong>（可能是文件，也可能是目录）。</li>
<li><strong><code>/images/</code></strong>：客户端明确请求名为 <code>images</code> 的<strong>目录容器</strong>。</li>
</ul>
<p><strong>工程细节</strong>：
当用户访问 <code>/images</code>（不带斜杠）且服务器上存在同名目录时，Nginx 默认会返回 <strong>301 Moved Permanently</strong>，自动重定向到 <code>/images/</code>。这是为了确保相对路径资源（如 <code>./logo.png</code>）能基于正确的 Base URL 加载。</p>
<hr/>
<h3 data-id="heading-4">3. 资源映射三剑客：Root、Alias 与 Proxy_Pass</h3>
<p><code>root</code>、<code>alias</code> 与 <code>proxy_pass</code> 是 Nginx 流量分发的核心指令。前两者解决的是如何将 URI 映射到 <strong>本地文件系统</strong>，而后者解决的是如何将请求转发到 <strong>网络服务接口</strong>。</p>
<h4 data-id="heading-5">3.1 Root：追加逻辑 (Append)</h4>
<p><code>root</code> 指令采用<strong>追加</strong>策略。它将请求的 URI 完整拼接到 <code>root</code> 指定的路径之后。</p>
<ul>
<li><strong>计算公式</strong>：<code>最终物理路径 = root路径 + 完整URI</code></li>
<li><strong>配置示例</strong>：
<pre><code class="hljs language-nginx" lang="nginx">location /static/ {
    root /var/www/app;
}
</code></pre>
</li>
<li><strong>解析过程</strong>：请求 <code>GET /static/css/style.css</code> -&gt; 物理路径：<code>/var/www/app/static/css/style.css</code></li>
</ul>
<h4 data-id="heading-6">3.2 Alias：替换逻辑 (Replace)</h4>
<p><code>alias</code> 指令采用<strong>替换</strong>策略。它用 <code>alias</code> 指定的路径替换掉 <code>location</code> 匹配到的部分。</p>
<ul>
<li><strong>计算公式</strong>：<code>最终物理路径 = alias路径 + (完整URI - location匹配部分)</code></li>
<li><strong>配置示例</strong>：
<pre><code class="hljs language-nginx" lang="nginx">location /static/ {
    alias /var/www/app/public/;
}
</code></pre>
</li>
<li><strong>解析过程</strong>：请求 <code>GET /static/css/style.css</code> -&gt; 匹配 <code>/static/</code> -&gt; 剩余 <code>css/style.css</code> -&gt; 最终访问：<code>/var/www/app/public/css/style.css</code></li>
</ul>
<h4 data-id="heading-7">3.3 Proxy_Pass：请求转发逻辑 (Forward)</h4>
<p>与处理本地文件的指令不同，<code>proxy_pass</code> 处理的是网络协议栈的转发。其路径处理逻辑遵循相似的“追加”与“替换”哲学，由目标 URL 结尾是否有 <strong><code>/</code></strong> 决定。</p>
<h5 data-id="heading-8"><strong>场景 A：不带斜杠（透明转发，对应 Root 逻辑）</strong></h5>
<p>当 <code>proxy_pass</code> 的目标 URL 不带路径（即没有结尾的 <code>/</code>）时，Nginx 会将原始请求的 URI 完整地传递给后端服务。</p>
<ul>
<li><strong>配置示例</strong>：
<pre><code class="hljs language-nginx" lang="nginx">location /api/ {
    proxy_pass http://127.0.0.1:3000; 
}
</code></pre>
</li>
<li><strong>路径解析</strong>：请求 <code>GET /api/user</code> -&gt; 转发到 <code>http://127.0.0.1:3000/api/user</code>。</li>
<li><strong>工程特征</strong>：<code>location</code> 匹配路径被完整保留。适用于后端服务本身就包含 <code>/api</code> 前缀的场景。</li>
</ul>
<h5 data-id="heading-9"><strong>场景 B：带斜杠（路径重写，对应 Alias 逻辑）</strong></h5>
<p>当 <code>proxy_pass</code> 的目标 URL 包含路径（即使只有一个结尾的 <code>/</code>）时，Nginx 会将 URI 中匹配 <code>location</code> 的部分替换为该路径。</p>
<ul>
<li><strong>配置示例</strong>：
<pre><code class="hljs language-nginx" lang="nginx">location /api/ {
    proxy_pass http://127.0.0.1:3000/; 
}
</code></pre>
</li>
<li><strong>路径解析</strong>：请求 <code>GET /api/user</code> -&gt; 转发到 <code>http://127.0.0.1:3000/user</code>。</li>
<li><strong>工程特征</strong>：<code>location</code> 匹配路径被“剥离”。适用于后端服务是纯净接口，仅通过 Nginx 统一前缀入口的场景。</li>
</ul>
<h4 data-id="heading-10">3.4 资源映射三剑客对比表</h4>
<p>假设统一配置 <code>location /api/</code>，观察不同指令下的映射结果：</p>













































<table><thead><tr><th align="left">指令</th><th align="left">映射目标</th><th align="left">URI 处理方式</th><th align="left">示例配置</th><th align="left">实际请求 -&gt; 结果映射</th><th align="left">典型场景</th></tr></thead><tbody><tr><td align="left"><strong>Root</strong></td><td align="left">本地磁盘</td><td align="left"><strong>追加</strong> (Append)</td><td align="left"><code>root /data;</code></td><td align="left"><code>/api/user</code> -&gt; <code>/data/api/user</code></td><td align="left">静态站点默认部署</td></tr><tr><td align="left"><strong>Alias</strong></td><td align="left">本地磁盘</td><td align="left"><strong>替换</strong> (Replace)</td><td align="left"><code>alias /data/v1/;</code></td><td align="left"><code>/api/user</code> -&gt; <code>/data/v1/user</code></td><td align="left">虚拟路径、资源别名</td></tr><tr><td align="left"><strong>Proxy_Pass (无/)</strong></td><td align="left">远程服务</td><td align="left"><strong>透明转发</strong></td><td align="left"><code>proxy_pass http://node:3000;</code></td><td align="left"><code>/api/user</code> -&gt; <code>node:3000/api/user</code></td><td align="left">后端服务自带前缀</td></tr><tr><td align="left"><strong>Proxy_Pass (带/)</strong></td><td align="left">远程服务</td><td align="left"><strong>路径重写</strong></td><td align="left"><code>proxy_pass http://node:3000/;</code></td><td align="left"><code>/api/user</code> -&gt; <code>node:3000/user</code></td><td align="left">统一入口，后端无前缀</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-11">4. 工程化落地：跨平台环境差异处理</h3>
<p>在团队协作中，统一开发环境（Windows/Mac）与生产环境（Linux）的配置规范至关重要。</p>
<h4 data-id="heading-12">4.1 Windows 开发环境的陷阱</h4>
<p>Windows 文件系统有“盘符”概念，且对路径分隔符不敏感。</p>
<ul>
<li><strong>绝对路径问题</strong>：
在 Windows 下配置 <code>root /html;</code>，Nginx 会将其解析为当前盘符的根目录（如 <code>D:\html</code>），而非 Nginx 安装目录。</li>
<li><strong>最佳实践</strong>：
<strong>使用相对路径</strong>。
<pre><code class="hljs language-nginx" lang="nginx"># 推荐：相对于 Nginx 安装目录 (prefix)
location / {
    root html; 
    index index.html;
}
</code></pre>
</li>
</ul>
<h4 data-id="heading-13">4.2 Linux 生产环境的规范</h4>
<p>Linux 环境强调权限控制与路径的确定性。</p>
<ul>
<li>
<p><strong>绝对路径强制</strong>：
生产配置必须使用绝对路径，避免因启动方式不同导致的工作目录漂移。</p>
<pre><code class="hljs language-nginx" lang="nginx">root /usr/share/nginx/html;
</code></pre>
</li>
<li>
<p><strong>权限隔离 (Permission)</strong>：
常见的 403 Forbidden 错误通常并非配置错误，而是权限问题。</p>
<ul>
<li><strong>要求</strong>：Nginx 运行用户（通常是 <code>nginx</code> 或 <code>www-data</code>）必须拥有从根目录到目标文件全路径的 <strong>x (执行/搜索)</strong> 权限，以及目标文件的 <strong>r (读取)</strong> 权限。</li>
<li><strong>排查命令</strong>：
<pre><code class="hljs language-bash" lang="bash">namei -om /var/www/project/static/image.png
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Alias 的斜杠对称性</strong>：
这是一个容易被忽视的 Bug 源。在 Linux 下使用 <code>alias</code> 时，如果 <code>location</code> 只有尾部斜杠，建议 <code>alias</code> 也加上尾部斜杠，保持对称，避免路径拼接错位。</p>
<pre><code class="hljs language-nginx" lang="nginx"># Good
location /img/ {
    alias /var/www/images/;
}
</code></pre>
</li>
</ul>
<h3 data-id="heading-14">5. 调试与排错指南</h3>
<p>当出现 404 或 403 时，不要盲目猜测，请遵循以下排查路径：</p>
<ol>
<li>
<p><strong>Check Error Log</strong>：
这是最直接的证据。Nginx 的 <code>error.log</code> 会明确打印出它试图访问的完整物理路径。</p>
<pre><code class="hljs language-text" lang="text">open() "/var/www/app/static/css/style.css" failed (2: No such file or directory)
</code></pre>
<p>对比日志中的路径与你预期的路径，通常能立刻发现 <code>root</code> 或 <code>alias</code> 的误用。</p>
</li>
<li>
<p><strong>验证文件存在性</strong>：
直接复制日志中的路径，在服务器上执行 <code>ls -l &lt;path&gt;</code>，确认文件是否存在以及权限是否正确。</p>
</li>
</ol>
<hr/>
<p><strong>总结</strong>：
Nginx 的路径映射与转发逻辑虽然细碎，但其背后遵循着高度一致的“追加”与“替换”哲学。掌握 <code>root</code>、<code>alias</code> 与 <code>proxy_pass</code> 的底层差异，不仅能解决 404/403 等表象问题，更能帮助开发者构建出优雅、可维护的配置体系。在工程实践中，建议通过<strong>规范化路径命名</strong>（如统一使用 <code>/api/</code> 前缀）与<strong>环境感知配置</strong>（如 Linux 绝对路径强制化）来降低运维复杂度，确保从本地开发到生产交付的丝滑顺畅。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[【ThreeJS实战】从86MB到4MB：复杂模型加载优化黑魔法]]></title>    <link>https://juejin.cn/post/7603771025856397363</link>    <guid>https://juejin.cn/post/7603771025856397363</guid>    <pubDate>2026-02-08T05:34:15.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856397363" data-draft-id="7603771025855922227" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="【ThreeJS实战】从86MB到4MB：复杂模型加载优化黑魔法"/> <meta itemprop="keywords" content="three.js,性能优化"/> <meta itemprop="datePublished" content="2026-02-08T05:34:15.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="叶智辽"/> <meta itemprop="url" content="https://juejin.cn/user/3320999244205294"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            【ThreeJS实战】从86MB到4MB：复杂模型加载优化黑魔法
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3320999244205294/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    叶智辽
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T05:34:15.000Z" title="Sun Feb 08 2026 05:34:15 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><em>前言：正当我沉浸在将draw call从52000优化到1的喜悦中无法自拔时，产品经理这时候又杀过来了："客户说模型加载要30秒，还没进去就关页面了，你优化一下？"我打开Network面板一看，卧槽，86MB的GLB文件！这谁顶得住啊...</em></p>
<p>如果你也遇到过这种情况：精心打磨的3D场景，本地运行丝滑流畅，一上线用户骂娘——"破网站卡死了"、"怎么还在转圈"、"手机直接闪退"。别急着怪用户网速慢，先看看你的模型是不是<strong>太胖了</strong>。</p>
<p>我这有个复杂模型，几何体+贴图一共<strong>86MB</strong>，在4G网络下加载需要<strong>30秒</strong>（Chrome模拟Slow 4G(3mb/s)一直加载...)。今天咱们不讲Blender操作模型（之前用Blender是因为没招，现在有更狠的），直接用<strong>命令行黑魔法</strong>把它压到<strong>4MB!!</strong>，加载时间从30秒干到<strong>1.5秒</strong>。</p>
<p>以下是优化前的绝望现场整整加载了30多秒...</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/674e9f906cc746b3b8f29b017e4603a1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771133660&amp;x-signature=tsoCT58MD8cav1uSQnyd2NcJc%2Bc%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-0">一、优化思路</h3>
<p>既然知道了加载为什么那么慢的原因，那我们就可以开始想想该怎么优化了</p>
<p>我目前的思路就是用<code>gltf-transform</code>
先把模型体积压下来，要不然渲染的时候再流畅，客户等到第二十秒的时候关闭浏览器，也没有意义了。。</p>
<h3 data-id="heading-1">二、DRACOLoader</h3>
<p>ThreeJS DRACOLoader直接无缝解压缩被压缩的模型</p>
<h4 data-id="heading-2">安装压缩模型工具（不用Blender，命令行搞定）</h4>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 安装gltf-transform（一行命令搞定Draco压缩+WebP+KTX2）</span>
npm install -g @gltf-transform/cli
</code></pre>
<p>至于我为什么选择gltf-transform而不是gltf-pipeline，以下是它们的对比：</p>



































<table><thead><tr><th>特性</th><th>gltf-pipeline</th><th>gltf-transform</th></tr></thead><tbody><tr><td><strong>Draco压缩</strong></td><td>✅ 支持</td><td>✅ 支持（更快）</td></tr><tr><td><strong>WebP纹理</strong></td><td>❌ 不支持</td><td>✅ 支持（关键！）</td></tr><tr><td><strong>KTX2/Basis</strong></td><td>❌ 不支持</td><td>✅ 支持</td></tr><tr><td><strong>安装体积</strong></td><td>大（依赖多）</td><td>小（WASM核心）</td></tr><tr><td><strong>推荐度</strong></td><td>⭐⭐⭐</td><td>⭐⭐⭐⭐⭐</td></tr></tbody></table>
<h2 data-id="heading-3">压缩你的GLB（80MB → 4MB）</h2>
<pre><code class="hljs language-bash" lang="bash">gltf-transform optimize input.glb output.glb \
  --compress draco \
  --texture-compress webp \
  --texture-size 2048
</code></pre>
<p>以下是我压缩之后的体积：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7625fd53c564acb8f71b83e39f2cd5a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771133660&amp;x-signature=Qt6vRnu5GJeXcNUoNO%2By5kpmOEM%3D" alt="image.png" loading="lazy"/></p>
<p>可以看到，模型的体积得到了巨大的缩减，从原来的86mb到现在的4mb左右！</p>
<p><strong>参数说明</strong>：</p>













































<table><thead><tr><th>参数</th><th>说明</th><th>建议值</th></tr></thead><tbody><tr><td><code>--texture-compress webp</code></td><td>贴图转WebP格式</td><td><strong>必加</strong>，体积减半</td></tr><tr><td><code>--texture-compress ktx2</code></td><td>贴图转KTX2（GPU直读）</td><td>如果目标设备支持，比WebP更好</td></tr><tr><td><code>--texture-size 2048</code></td><td>限制最大贴图尺寸</td><td><strong>必加</strong>，4096→2048省4倍显存</td></tr><tr><td><code>--compress draco</code></td><td>启用Draco几何压缩</td><td><strong>必加</strong>，默认就是sequential模式</td></tr><tr><td><code>--compress-method sequential</code></td><td>Draco编码模式</td><td>sequential（默认，小体积）或 edgeloop（快解码）</td></tr><tr><td><code>--compress-level 10</code></td><td>Draco压缩级别</td><td>0-10，10压最狠但解压慢，建议7-10</td></tr><tr><td><code>--flatten</code></td><td>打平节点层级</td><td>如果模型层级太深，加这个减少DrawCall（但会丢失动画）</td></tr></tbody></table>
<p>以下是优化之后的加载时间，就问你快不快！</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7c128c4ba2d14860b8623cf34327cf21~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771133660&amp;x-signature=Gj1p3h7rSzkEUOr8ceIYI4kXA2s%3D" alt="image.png" loading="lazy"/></p>
<h4 data-id="heading-4">Three.js加载代码（关键！）</h4>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-comment">/**
 * 优化后的 GLB 加载步骤（Draco / gltf-transform）
 *
 * 依赖：Three.js、GLTFLoader、DRACOLoader
 * 解码器：把 three 的 examples/jsm/libs/draco/gltf/ 放到站点 /draco/ 下，或使用 CDN 路径
 */</span>

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">GLTFLoader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'three/examples/jsm/loaders/GLTFLoader'</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">DRACOLoader</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'three/examples/jsm/loaders/DRACOLoader'</span>;

<span class="hljs-comment">// ————— 步骤 1：创建 Draco 解码器并指定路径 —————</span>
<span class="hljs-keyword">const</span> dracoLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DRACOLoader</span>();
dracoLoader.<span class="hljs-title function_">setDecoderPath</span>(<span class="hljs-string">'/draco/'</span>);
<span class="hljs-comment">// 或用 CDN（与项目 three 版本一致）：'https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/libs/draco/gltf/'</span>

<span class="hljs-comment">// ————— 步骤 2：把 DRACOLoader 挂到 GLTFLoader 上 —————</span>
<span class="hljs-keyword">const</span> loader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GLTFLoader</span>();
loader.<span class="hljs-title function_">setDRACOLoader</span>(dracoLoader);

<span class="hljs-comment">// ————— 步骤 3：正常 load，普通 GLB 与 Draco 压缩的 GLB 都能加载 —————</span>
loader.<span class="hljs-title function_">load</span>(
  <span class="hljs-string">'https://your-cdn.com/model-optimized.glb'</span>,
  <span class="hljs-function">(<span class="hljs-params">gltf</span>) =&gt;</span> {
    scene.<span class="hljs-title function_">add</span>(gltf.<span class="hljs-property">scene</span>);
  },
  <span class="hljs-literal">undefined</span>,
  <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err),
);

<span class="hljs-comment">// Promise 写法（可选）：</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadOptimizedGLB</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
    loader.<span class="hljs-title function_">load</span>(url, resolve, <span class="hljs-literal">undefined</span>, reject);
  });
}
<span class="hljs-comment">// 使用方式：const gltf = await loadOptimizedGLB(url);</span>

</code></pre>
<p><strong>注意</strong>：<code>setDecoderPath</code> 指向的是 Draco 的 WASM 解码文件，需要从 Three.js 的 <code>examples/jsm/libs/draco/</code> 目录复制到你的 public 文件夹，或者用 CDN（上面示例用的是从threejs复制的本地解码文件）。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/f6056ed4edd8424e9f576076746a6227~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771133660&amp;x-signature=LfB00kEcCV01BCgkwfo%2BfL0j%2B2E%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0bcc195429b6461dad0a0b37005c7a60~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-25pm66L69:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771133660&amp;x-signature=Pm6unUZnhNJrWVyGpRLGgHL%2B5u4%3D" alt="image.png" loading="lazy"/></p>
<h3 data-id="heading-5">避坑指南</h3>
<ol>
<li><strong>别重复压缩</strong>：Draco是有损压缩，压一次损失一点精度，<strong>别压两遍</strong>！先备份原文件。</li>
<li><strong>WebP兼容性</strong>：虽然现代浏览器都支持WebP，但如果你要兼容IE11（虽然不应该），只能用PNG/JPG。</li>
<li><strong>KTX2谨慎用</strong>：KTX2（Basis Universal）压缩率最高，但需要 GPU 支持，老旧手机可能解码失败，建议 WebP 更稳妥。</li>
<li><strong>量化精度</strong>：如果你发现压缩后的模型出现<strong>裂缝</strong>（顶点没对齐），把 <code>--quantization-position</code> 从 10 调到 14。</li>
</ol>
<p><strong>还有一件事</strong>：Draco是<strong>有损压缩</strong>，但视觉上几乎看不出差别（工业模型顶点精度够高），解压是在Web Worker里进行的，不会卡主线程。</p>
<h3 data-id="heading-6">三、又到了喜闻乐见的前后对比（刺激！）</h3>




















<table><thead><tr><th>指标</th><th>原始模型</th><th>Draco压缩</th></tr></thead><tbody><tr><td><strong>文件体积</strong></td><td>86MB</td><td>4MB</td></tr><tr><td><strong>4G加载时间</strong></td><td>30秒</td><td>1.5秒</td></tr></tbody></table>
<p>可以看到加载时间跨度很大，从30秒到1.5秒，足足提升了20倍，客户本来都要睡着了，但现在客户眨了一下眼睛，就发现眼前屏幕里的世界都不一样了~</p>
<h3 data-id="heading-7">总结</h3>
<p>优化路径：<strong>86MB（原始）→ 4MB（Draco+WebP）→ 1.5秒加载完成</strong></p>
<p><strong>核心认知</strong>：</p>
<ul>
<li><strong>gltf-transform</strong>：一站式解决几何体+贴图压缩，不用Blender，一行命令搞定</li>
<li><strong>Draco</strong>：解决"下载慢"（几何体从18MB压到2MB）</li>
<li><strong>WebP</strong>：解决"贴图肥"（68MB压到2MB，兼容性最好）</li>
</ul>
<p><strong>没用到的手段（进阶可选）</strong>：</p>
<ul>
<li><strong>KTX2</strong>：比WebP体积更小且GPU直读，但需要设备支持，老旧手机可能解码失败</li>
<li><strong>分块加载</strong>：如果4MB还是大，可以拆成"外壳1MB+细节3MB"，首屏秒开</li>
</ul>
<p><strong>不用Blender，全程命令行+代码搞定</strong>，这才是工程师的浪漫。</p>
<p>下篇预告：【ThreeJS实战】GPU还是100%？LOD策略：让远处模型自动"减肥"</p>
<p><strong>互动</strong>：你用<code>gltf-transform</code>压了多少倍？我<strong>20倍</strong>算不算狠？评论区报出你的<strong>原始体积vs优化后体积</strong>，看看谁是真正的"压王"😏</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[用 React 手搓一个 3D 翻页书籍组件，呼吸海浪式翻页，交互体验带感！]]></title>    <link>https://juejin.cn/post/7603771025856430131</link>    <guid>https://juejin.cn/post/7603771025856430131</guid>    <pubDate>2026-02-08T05:46:14.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025856430131" data-draft-id="7603674653153099785" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="用 React 手搓一个 3D 翻页书籍组件，呼吸海浪式翻页，交互体验带感！"/> <meta itemprop="keywords" content="前端,GitHub,架构"/> <meta itemprop="datePublished" content="2026-02-08T05:46:14.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="前端市界"/> <meta itemprop="url" content="https://juejin.cn/user/289926798641176"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            用 React 手搓一个 3D 翻页书籍组件，呼吸海浪式翻页，交互体验带感！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/289926798641176/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    前端市界
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T05:46:14.000Z" title="Sun Feb 08 2026 05:46:14 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">用 React 手搓一个 3D 翻页书籍组件，页角还能卷起来！从零到踩坑全记录</h2>
<blockquote>
<p>前端开发中，你是否也想过把枯燥的内容展示做得像翻书一样？本文记录了我从零开发一个 <strong>3D 交互式书籍组件</strong> 的完整过程——包括 CSS 3D 翻页、拖拽手势、页角海浪卷起效果，以及中间踩过的坑和最终的解决方案。</p>
</blockquote>
<h3 data-id="heading-1">一、为什么要做这个组件？</h3>
<p>在做一个 AI 知识库产品时，产品经理提了一个需求：</p>
<blockquote>
<p>「能不能把教程做成一本可以翻页的书？用户点击或拖拽就能翻页，体验要像真书。」</p>
</blockquote>
<p>市面上的轮播图、Tab 切换都太「平」了，我希望做一个<strong>有纵深感的 3D 翻书交互</strong>。翻遍了 npm，要么功能太简陋，要么依赖 Canvas 体积太大，最终决定——<strong>自己写一个</strong>。</p>
<p>目标很明确：</p>
<ul>
<li>🎨 CSS 3D 实现真实翻页效果，不用 Canvas</li>
<li>✋ 支持拖拽翻页、点击翻页、键盘翻页</li>
<li>🌊 鼠标悬停页角时有「海浪卷起」的视觉提示</li>
<li>📱 移动端触摸支持</li>
<li>🧱 纯 React 组件，零外部翻书依赖</li>
</ul>
<h3 data-id="heading-2">二、架构设计：一本书的 DOM 结构</h3>
<p>先想清楚一本书的物理结构：</p>
<pre><code class="hljs language-css" lang="css">┌─────────────────────────────────┐
│           Container             │  ← <span class="hljs-attribute">perspective</span>: <span class="hljs-number">2000px</span> 提供 <span class="hljs-number">3</span>D 视角
│  ┌───────────────────────────┐  │
│  │       BookWrapper         │  │  ← 打开时 <span class="hljs-built_in">translateX</span>(<span class="hljs-number">50%</span>) 居中
│  │  ┌─────────────────────┐  │  │
│  │  │      Cover          │  │  │  ← <span class="hljs-built_in">rotateY</span>(-<span class="hljs-number">180deg</span>) 翻开
│  │  │  ┌ front ┐┌ back ─┐ │  │  │
│  │  │  │封面图片││内封页  │ │  │  │
│  │  │  └───────┘└───────┘ │  │  │
│  │  ├─────────────────────┤  │  │
│  │  │      Pages          │  │  │  ← 所有页面叠在一起
│  │  │  ┌ Page <span class="hljs-number">1</span> ────────┐ │  │  │
│  │  │  │ front │ back   │ │  │  │  ← 每页双面
│  │  │  └────────────────┘ │  │  │
│  │  │  ┌ Page <span class="hljs-number">2</span> ────────┐ │  │  │
│  │  │  │ front │ back   │ │  │  │
│  │  │  └────────────────┘ │  │  │
│  │  │  ┌ BackCover ─────┐ │  │  │
│  │  │  │   The End      │ │  │  │
│  │  │  └────────────────┘ │  │  │
│  │  └─────────────────────┘  │  │
│  └───────────────────────────┘  │
│        Navigation Bar           │
└─────────────────────────────────┘
</code></pre>
<p>核心思路：</p>
<ul>
<li>每一页都是绝对定位叠在一起，<code>transform-origin: left center</code>，翻页就是绕左边缘旋转 -180°</li>
<li>用 <code>backface-visibility: hidden</code> + 前后两个 div 模拟正反面</li>
<li>通过 <code>zIndex</code> 控制翻过的页和未翻的页的层叠关系</li>
</ul>
<h3 data-id="heading-3">三、核心实现</h3>
<h4 data-id="heading-4">3.1 CSS 3D 翻页</h4>
<p>关键 CSS：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">2000px</span>;  <span class="hljs-comment">// 3D 视角距离</span>
}

<span class="hljs-selector-class">.page</span> {
  <span class="hljs-attribute">position</span>: absolute;
  inset: 0;
  <span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d;
  <span class="hljs-attribute">transform-origin</span>: left;  <span class="hljs-comment">// 绕左边轴翻转</span>
}

<span class="hljs-selector-class">.pageFront</span>, <span class="hljs-selector-class">.pageBack</span> {
  <span class="hljs-attribute">backface-visibility</span>: hidden;  <span class="hljs-comment">// 只显示朝向用户的面</span>
}

<span class="hljs-selector-class">.pageBack</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>) <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0.5px</span>);  <span class="hljs-comment">// 背面翻转 180°</span>
}
</code></pre>
<p>用 Framer Motion 的 <code>variants</code> 控制翻转动画：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> variants = {
  <span class="hljs-attr">flipped</span>: {
    <span class="hljs-attr">rotateY</span>: -<span class="hljs-number">180</span>,
    <span class="hljs-attr">zIndex</span>: isBuriedLeft ? index + <span class="hljs-number">1</span> : pages.<span class="hljs-property">length</span> + <span class="hljs-number">10</span>,
    <span class="hljs-attr">transition</span>: {
      <span class="hljs-attr">rotateY</span>: { <span class="hljs-attr">duration</span>: <span class="hljs-number">0.6</span>, <span class="hljs-attr">ease</span>: [<span class="hljs-number">0.645</span>, <span class="hljs-number">0.045</span>, <span class="hljs-number">0.355</span>, <span class="hljs-number">1</span>] },
      <span class="hljs-attr">zIndex</span>: { <span class="hljs-attr">delay</span>: <span class="hljs-number">0.6</span> },
    },
  },
  <span class="hljs-attr">unflipped</span>: {
    <span class="hljs-attr">rotateY</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">zIndex</span>: pages.<span class="hljs-property">length</span> - index,
    <span class="hljs-attr">transition</span>: {
      <span class="hljs-attr">rotateY</span>: { <span class="hljs-attr">duration</span>: <span class="hljs-number">0.6</span>, <span class="hljs-attr">ease</span>: [<span class="hljs-number">0.645</span>, <span class="hljs-number">0.045</span>, <span class="hljs-number">0.355</span>, <span class="hljs-number">1</span>] },
      <span class="hljs-attr">zIndex</span>: { <span class="hljs-attr">delay</span>: <span class="hljs-number">0.6</span> },
    },
  },
}
</code></pre>
<p>这里的贝塞尔曲线 <code>[0.645, 0.045, 0.355, 1]</code> 是精心调的，模拟纸张翻页时先快后慢的物理感。</p>
<h4 data-id="heading-5">3.2 拖拽翻页</h4>
<p>参考电子书阅读器的拖拽逻辑：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// mousedown → 记录起点</span>
<span class="hljs-comment">// mousemove → 计算偏移，用 rAF 优化性能</span>
<span class="hljs-comment">// mouseup → 偏移超过阈值(80px)则触发翻页</span>

<span class="hljs-keyword">const</span> handleMouseMove = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">e: MouseEvent</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!isDragging) <span class="hljs-keyword">return</span>
  currentDragXRef.<span class="hljs-property">current</span> = e.<span class="hljs-property">clientX</span>
  <span class="hljs-keyword">if</span> (rafIdRef.<span class="hljs-property">current</span>) <span class="hljs-title function_">cancelAnimationFrame</span>(rafIdRef.<span class="hljs-property">current</span>)
  rafIdRef.<span class="hljs-property">current</span> = <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setDragOffset</span>(currentDragXRef.<span class="hljs-property">current</span> - dragStartXRef.<span class="hljs-property">current</span>)
  })
}, [isDragging])
</code></pre>
<p>拖拽过程中，当前页面会有一个「弓起」效果：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> curlAngle = isActiveDragPage
  ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(dragOffset) * <span class="hljs-number">0.25</span>, <span class="hljs-number">45</span>) * (dragOffset &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>)
  : <span class="hljs-number">0</span>
<span class="hljs-keyword">const</span> curlZ = isActiveDragPage
  ? <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(dragOffset) * <span class="hljs-number">0.15</span>, <span class="hljs-number">30</span>)
  : <span class="hljs-number">0</span>
</code></pre>
<p>根据拖拽偏移量，页面最多弓起 45°，同时沿 Z 轴抬升 30px，配合 <code>box-shadow</code> 产生投影，效果非常逼真。</p>
<h4 data-id="heading-6">3.3 页角海浪卷起效果 🌊</h4>
<p>这是整个组件最有趣的交互细节：鼠标悬停在页角时，纸张会像海浪一样卷起来，提示用户「这里可以翻页」。</p>
<p><strong>实现原理</strong>：在页面的右下角/左下角放置 80×80 的热区，hover 时用 <code>border-radius: 100%</code> + 渐变背景模拟卷角，配合 CSS <code>@keyframes</code> 实现呼吸式波浪动画。</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-class">.cornerZone</span> {
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">80px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;
  <span class="hljs-attribute">cursor</span>: pointer;
}

<span class="hljs-selector-class">.curlEffect</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: width <span class="hljs-number">0.35s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.34</span>, <span class="hljs-number">1.56</span>, <span class="hljs-number">0.64</span>, <span class="hljs-number">1</span>),
              height <span class="hljs-number">0.35s</span> <span class="hljs-built_in">cubic-bezier</span>(<span class="hljs-number">0.34</span>, <span class="hljs-number">1.56</span>, <span class="hljs-number">0.64</span>, <span class="hljs-number">1</span>);
}

<span class="hljs-comment">// hover 时展开卷角</span>
<span class="hljs-selector-class">.cornerActive</span> <span class="hljs-selector-class">.curlEffect</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">55px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">55px</span>;
}
</code></pre>
<p>卷角的渐变模拟了纸张翻起时的明暗变化：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-selector-class">.cornerBottomRight</span> <span class="hljs-selector-class">.curlEffect</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(
    <span class="hljs-number">225deg</span>,
    <span class="hljs-built_in">rgba</span>(<span class="hljs-number">253</span>, <span class="hljs-number">251</span>, <span class="hljs-number">247</span>, <span class="hljs-number">0.95</span>) <span class="hljs-number">0%</span>,    <span class="hljs-comment">// 翻起的纸面（亮）      </span>
    <span class="hljs-built_in">rgba</span>(<span class="hljs-number">253</span>, <span class="hljs-number">251</span>, <span class="hljs-number">247</span>, <span class="hljs-number">0.9</span>) <span class="hljs-number">35%</span>,
    <span class="hljs-built_in">rgba</span>(<span class="hljs-number">230</span>, <span class="hljs-number">225</span>, <span class="hljs-number">215</span>, <span class="hljs-number">0.85</span>) <span class="hljs-number">50%</span>,   <span class="hljs-comment">// 折痕处（暗）</span>
    <span class="hljs-built_in">rgba</span>(<span class="hljs-number">200</span>, <span class="hljs-number">195</span>, <span class="hljs-number">185</span>, <span class="hljs-number">0.4</span>) <span class="hljs-number">70%</span>,
    transparent <span class="hljs-number">100%</span>                  <span class="hljs-comment">// 渐隐到背景</span>
  );
  <span class="hljs-attribute">border-top-left-radius</span>: <span class="hljs-number">100%</span>;      <span class="hljs-comment">// 关键！圆弧形卷角</span>
}
</code></pre>
<p>海浪动画通过 <code>@keyframes</code> 让卷角大小在 50px - 70px 之间波动：</p>
<pre><code class="hljs language-less" lang="less"><span class="hljs-keyword">@keyframes</span> curlWaveRight {
  <span class="hljs-number">0%</span>   { <span class="hljs-attribute">width</span>: <span class="hljs-number">55px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">55px</span>; }
  <span class="hljs-number">30%</span>  { <span class="hljs-attribute">width</span>: <span class="hljs-number">70px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">70px</span>; }  <span class="hljs-comment">// 浪涌</span>
  <span class="hljs-number">60%</span>  { <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>; }  <span class="hljs-comment">// 回落</span>
  <span class="hljs-number">100%</span> { <span class="hljs-attribute">width</span>: <span class="hljs-number">55px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">55px</span>; }  <span class="hljs-comment">// 归位</span>
}
</code></pre>
<p>弹性过渡的贝塞尔曲线 <code>cubic-bezier(0.34, 1.56, 0.64, 1)</code> 让展开有一个「弹一下」的效果，像纸张被风吹起。</p>
<h3 data-id="heading-7">四、踩坑实录：那些让我抓狂的 Bug</h3>
<h4 data-id="heading-8">坑 1：页角点击不触发翻页</h4>
<p><strong>现象</strong>：鼠标在页角卷起后点击，但页面没有翻动。</p>
<p><strong>原因</strong>：<code>mousedown</code> 事件冒泡到了父容器 <code>.pages</code>，触发了拖拽逻辑（<code>isDragging = true</code>）。由于 React 的条件渲染逻辑写了 <code>!isDragging</code>，页角区域立刻被卸载，<code>onClick</code> 根本来不及触发。</p>
<p><strong>解决</strong>：在页角热区上阻止 <code>mousedown</code> 冒泡：</p>
<pre><code class="hljs language-tsx" lang="tsx">&lt;div
  className={styles.<span class="hljs-property">cornerZone</span>}
  onMouseDown={<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.<span class="hljs-title function_">stopPropagation</span>()}  <span class="hljs-comment">// 关键！</span>
  onTouchStart={<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> e.<span class="hljs-title function_">stopPropagation</span>()}
  onClick={<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    e.<span class="hljs-title function_">stopPropagation</span>()
    <span class="hljs-title function_">setCornerHover</span>(<span class="hljs-string">'none'</span>)
    <span class="hljs-title function_">nextPage</span>(e)
  }}
&gt;
</code></pre>
<h4 data-id="heading-9">坑 2：翻到下一页时左侧短暂闪烁</h4>
<p><strong>现象</strong>：翻页时左侧会短暂显示封面内容，然后才变成当前页的背面。</p>
<p><strong>第一次尝试（失败）</strong>：用 Framer Motion 的 <code>opacity</code> 动画延迟隐藏已翻过的页面。设置了 <code>delay: 0.65s</code>，等翻转动画完成后再隐藏。</p>
<p><strong>结果</strong>：时序不可靠。<code>opacity</code> 依赖 Framer Motion 的 variant 重算，<code>isBuriedLeft</code> 变化时 variant 值立刻更新，无论 delay 多少都可能出现竞态。</p>
<p><strong>最终方案</strong>：彻底放弃 <code>opacity</code> 动画，改用 CSS <code>visibility</code> 隐藏深层页面：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-comment">// 只隐藏 "深层" 掩埋的页面（index &lt; currentPageIndex - 1）</span>
<span class="hljs-comment">// 保留紧邻的前一页可见，确保左侧始终有背面内容</span>
<span class="hljs-keyword">const</span> isDeeplyBuried = isFlipped &amp;&amp; index &lt; currentPageIndex - <span class="hljs-number">1</span>

&lt;motion.<span class="hljs-property">div</span> style={{
  <span class="hljs-attr">visibility</span>: isDeeplyBuried ? <span class="hljs-string">'hidden'</span> : <span class="hljs-string">'visible'</span>,
}}&gt;
</code></pre>
<p><code>visibility: hidden</code> 是<strong>即时的、无动画的、确定性的</strong>——完美解决闪烁问题。</p>
<h4 data-id="heading-10">坑 3：翻回上一页时又闪了</h4>
<p><strong>现象</strong>：修好了向后翻页，但翻回上一页时又出现闪烁。</p>
<p><strong>原因</strong>：<code>unflipped</code> variant 的 <code>zIndex</code> transition 的 <code>delay</code> 设为了 <code>0</code>，导致页面还在翻转动画过程中，zIndex 就提前降低了，被其他页面遮挡。</p>
<p><strong>解决</strong>：双向翻页的 <code>zIndex</code> 都延迟到动画结束后再更新：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-attr">unflipped</span>: {
  <span class="hljs-attr">rotateY</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">zIndex</span>: pages.<span class="hljs-property">length</span> - index,
  <span class="hljs-attr">transition</span>: {
    <span class="hljs-attr">rotateY</span>: { <span class="hljs-attr">duration</span>: <span class="hljs-number">0.6</span>, <span class="hljs-attr">ease</span>: [<span class="hljs-number">0.645</span>, <span class="hljs-number">0.045</span>, <span class="hljs-number">0.355</span>, <span class="hljs-number">1</span>] },
    <span class="hljs-attr">zIndex</span>: { <span class="hljs-attr">delay</span>: <span class="hljs-number">0.6</span> },  <span class="hljs-comment">// 和翻页动画时长一致！</span>
  },
},
</code></pre>
<h4 data-id="heading-11">坑 4：最后一页拖不动但光标还是「抓手」</h4>
<p><strong>现象</strong>：翻到最后一页（The End），虽然结束页已经阻止了事件冒泡，但在页面空白区域鼠标仍然显示 <code>grab</code> 光标。</p>
<p><strong>解决</strong>：检测最后一页状态，同时禁用拖拽逻辑和光标样式：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">const</span> isLastPage = currentPageIndex &gt;= pages.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>

<span class="hljs-comment">// 禁用 mousedown</span>
<span class="hljs-keyword">const</span> handleMouseDown = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!isOpen || isLastPage) <span class="hljs-keyword">return</span>  <span class="hljs-comment">// 最后一页不触发拖拽</span>
  <span class="hljs-comment">// ...</span>
}, [isOpen, isLastPage])

<span class="hljs-comment">// 光标</span>
<span class="hljs-attr">cursor</span>: isOpen
  ? (isLastPage ? <span class="hljs-string">'default'</span> : isDragging ? <span class="hljs-string">'grabbing'</span> : <span class="hljs-string">'grab'</span>)
  : <span class="hljs-string">'default'</span>
</code></pre>
<h3 data-id="heading-12">五、最终效果</h3>
<p>组件支持的交互方式一览：</p>

































<table><thead><tr><th>交互方式</th><th>说明</th></tr></thead><tbody><tr><td>🖱️ 拖拽翻页</td><td>按住页面左右拖拽，超过 80px 阈值松手翻页</td></tr><tr><td>🌊 页角点击</td><td>悬停右下角/左下角出现卷起效果，点击翻页</td></tr><tr><td>🔘 导航栏</td><td>底部导航栏前后翻页按钮</td></tr><tr><td>⌨️ 键盘</td><td>← → 翻页 / Escape 关闭 / Home End 跳转</td></tr><tr><td>📱 触摸</td><td>移动端触摸滑动翻页</td></tr><tr><td>📕 封面</td><td>点击或向左拖拽打开书籍</td></tr></tbody></table>
<p>使用方式非常简单：</p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">InteractiveBook</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'@stateless/InteractiveBook'</span>

&lt;<span class="hljs-title class_">InteractiveBook</span>
  coverImage=<span class="hljs-string">"/cover.jpg"</span>
  bookTitle=<span class="hljs-string">"AI Agent 完全指南"</span>
  bookAuthor=<span class="hljs-string">"AI 专家"</span>
  pages={[
    {
      <span class="hljs-attr">pageNumber</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">title</span>: <span class="hljs-string">'第一章'</span>,
      <span class="hljs-attr">content</span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>正面内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,
      <span class="hljs-attr">backContent</span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>背面内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>,
    },
    <span class="hljs-comment">// ...</span>
  ]}
  onPageChange={<span class="hljs-function">(<span class="hljs-params">index</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前页:'</span>, index)}
  enableKeyboard
/&gt;
</code></pre>
<h3 data-id="heading-13">六、技术栈总结</h3>

































<table><thead><tr><th>技术</th><th>用途</th></tr></thead><tbody><tr><td>React + TypeScript</td><td>组件逻辑</td></tr><tr><td>Framer Motion</td><td>翻页动画、封面动画、导航栏动画</td></tr><tr><td>CSS 3D Transform</td><td><code>perspective</code>、<code>rotateY</code>、<code>preserve-3d</code>、<code>backface-visibility</code></td></tr><tr><td>CSS Modules (Less)</td><td>样式隔离</td></tr><tr><td>requestAnimationFrame</td><td>拖拽性能优化</td></tr><tr><td>lucide-react</td><td>图标</td></tr></tbody></table>
<h3 data-id="heading-14">七、写在最后</h3>
<p>一个看似简单的翻书组件，涉及了 <strong>CSS 3D 变换、事件冒泡机制、Framer Motion variant 生命周期、zIndex 时序控制</strong> 等多个知识点。最大的教训是：</p>
<blockquote>
<p><strong>不要用动画属性（opacity/transform）去做「显示/隐藏」这种二元状态控制。</strong> 用 <code>visibility</code> 或条件渲染——确定性比优雅更重要。</p>
</blockquote>
<p>完整代码已开源，欢迎 Star ⭐</p>
<hr/>
<p>GitHub: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwkylin%2Fpro-react-admin" target="_blank" title="https://github.com/wkylin/pro-react-admin" ref="nofollow noopener noreferrer">Pro React Admin</a></p>
<p>预览地址: <a href="https://link.juejin.cn?target=https%3A%2F%2Fwkylin.github.io%2Fpro-react-admin%2Fstorybook%2F%3Fpath%3D%2Fdocs%2Fstateless-interactivebook--docs" target="_blank" title="https://wkylin.github.io/pro-react-admin/storybook/?path=/docs/stateless-interactivebook--docs" ref="nofollow noopener noreferrer">Interactive Book</a></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5b38133acbdf4cbdba0dad49c1ca2b75~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5biC55WM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771134374&amp;x-signature=8vi1B84z7aKyHbJ8eF2sJ94Y3%2Fo%3D" alt="image.png" loading="lazy"/></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51fa994a011548d5bab542b32cf4c44d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5YmN56uv5biC55WM:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771134374&amp;x-signature=jBlMH%2FU9vdjSpkIqb5fewPRH3Lg%3D" alt="image.png" loading="lazy"/></p>
<p><strong>如果这篇文章对你有帮助，别忘了点个赞 👍 收藏一下 📌</strong></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[APP原生与H5互调Bridge技术原理及基础使用]]></title>    <link>https://juejin.cn/post/7603674653153427465</link>    <guid>https://juejin.cn/post/7603674653153427465</guid>    <pubDate>2026-02-08T03:57:08.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603674653153427465" data-draft-id="7603688142004469769" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="APP原生与H5互调Bridge技术原理及基础使用"/> <meta itemprop="keywords" content="前端"/> <meta itemprop="datePublished" content="2026-02-08T03:57:08.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="黄诂多"/> <meta itemprop="url" content="https://juejin.cn/user/510642324769053"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            APP原生与H5互调Bridge技术原理及基础使用
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/510642324769053/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    黄诂多
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T03:57:08.000Z" title="Sun Feb 08 2026 03:57:08 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读9分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">API使用</h2>
<h4 data-id="heading-1">js调用原生插件功能</h4>
<p>调用命名为'11'的插件里的一个定时器api：jsCallTimer</p>
<p>带回调结果带参数的调用方式：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable constant_">YN</span>.<span class="hljs-title function_">callNative</span>(<span class="hljs-string">'11'</span>,<span class="hljs-string">"jsCallTimer"</span>,<span class="hljs-string">'我是传到原生端的参数'</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
      <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>){
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"progress1"</span>).<span class="hljs-property">innerText</span> = value
      }<span class="hljs-keyword">else</span>{
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"progress2"</span>).<span class="hljs-property">innerText</span> = value
      }
    },<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
      <span class="hljs-title function_">alert</span>(error)
    })
</code></pre>
<p>不带回调结果带参数的调用方式：</p>
<pre><code class="hljs language-arduino" lang="arduino">YN.<span class="hljs-built_in">callNative</span>(<span class="hljs-string">'11'</span>,<span class="hljs-string">"jsCallTimer"</span>,<span class="hljs-string">'我是传到原生端的参数'</span>)
</code></pre>
<p>不带回调结果不带参数的调用方式：</p>
<pre><code class="hljs language-arduino" lang="arduino">YN.<span class="hljs-built_in">callNative</span>(<span class="hljs-string">'11'</span>,<span class="hljs-string">"jsCallTimer"</span>)
</code></pre>
<h4 data-id="heading-2">原生调用js插件功能</h4>
<p>调用命名为'asynObj'的插件里的一个定时器api：startTimer</p>
<p>带回调结果带参数的调用方式：</p>
<pre><code class="hljs language-objectivec" lang="objectivec">[dwebview callHandler:<span class="hljs-string">@"asynObj"</span> action:<span class="hljs-string">@"startTimer"</span> arguments:<span class="hljs-string">@"我是传到js端的参数"</span> completionHandler:^(CallbackStatus status, <span class="hljs-type">id</span>  _Nonnull value, <span class="hljs-built_in">NSString</span> * _Nonnull callId, <span class="hljs-type">BOOL</span> complete) {
        [sender setTitle:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"%@-%@"</span>,value,callId] forState:<span class="hljs-number">0</span>];
    }];
</code></pre>
<p>不带回调结果的调用方式：</p>
<pre><code class="hljs language-csharp" lang="csharp">[<span class="hljs-meta">dwebview callHandler:@<span class="hljs-string">"asynObj"</span> action:@<span class="hljs-string">"startTimer"</span> arguments:@<span class="hljs-string">"我是传到js端的参数"</span> completionHandler:nil</span>];
</code></pre>
<h2 data-id="heading-3">一些全局约定</h2>
<ul>
<li>
<p>js调原生和原生调js的参数传递必须是json字符串格式。</p>
</li>
<li>
<p>api调用,底层逻辑必须使用命名空间方式即：namespace.apixxx的形式。</p>
</li>
<li>
<p>还有很多规范和约定，后续补充。</p>
</li>
</ul>
<h2 data-id="heading-4">js call native</h2>
<h4 data-id="heading-5">关键技术点</h4>
<p>原生Android端向浏览器注入供js调用的对象‘_anbridge’，对象里实现‘call()’方法，并且方法需要加上@JavascriptInterface注解，代码示例：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-type">WebSettings</span> <span class="hljs-variable">webSettings</span> <span class="hljs-operator">=</span> wv.getSettings();
webSettings.setJavaScriptEnabled(<span class="hljs-literal">true</span>);
wv.addJavascriptInterface(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JsApp</span>(),<span class="hljs-string">"_anbridge"</span>);
<span class="hljs-keyword">class</span> <span class="hljs-title class_">JsApp</span>{
  <span class="hljs-keyword">public</span> <span class="hljs-title function_">JsApp</span><span class="hljs-params">()</span>{}
  <span class="hljs-meta">@JavascriptInterface</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">(Object obj)</span>{

  }
}
</code></pre>
<p>原生iOS端</p>
<p>向浏览器配置对象里注入‘window._ynwk=true;’这段js代码，并且设置注入时机为开始加载时即：injectionTime=WKUserScriptInjectionTimeAtDocumentStart,代码实现：</p>
<pre><code class="hljs language-ini" lang="ini">///初始化注入js标记
    WKUserScript *<span class="hljs-attr">script</span> = [[WKUserScript alloc] initWithSource:@<span class="hljs-string">"window._ynwk=true;"</span>
                                                  injectionTime:WKUserScriptInjectionTimeAtDocumentStart
                                               forMainFrameOnly:<span class="hljs-literal">YES</span>]<span class="hljs-comment">;</span>
    <span class="hljs-section">[configuration.userContentController addUserScript:script]</span><span class="hljs-comment">;</span>
</code></pre>
<p>实现js端换起原生通信的关键是实现wk的h5输入框拦截回调方法- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable result))completionHandler<br/>
当js端执行代码‘prompt()’时原生端就会自动调起该方法</p>
<p>在上面实现的基础上，js端判断window._anbridge为true则为与Android通信，执行代码：_anbridge.call(api, arg)，如果判断window._ynwk为true则为与iOS端通信，执行代码：prompt('_ynbridge=' + api, arg)，js端代码实现：</p>
<pre><code class="hljs language-ini" lang="ini">var <span class="hljs-attr">natiValue</span> = <span class="hljs-string">''</span><span class="hljs-comment">;</span>
if (window._anbridge)
   <span class="hljs-attr">natiValue</span> = _anbridge.call(api, arg)<span class="hljs-comment">;//调用android对象的call()</span>
else if (window._ynwk)
   <span class="hljs-attr">natiValue</span> = prompt(<span class="hljs-string">'_ynbridge='</span> + api, arg)<span class="hljs-comment">;</span>
</code></pre>
<p>原生端、js端提供的api都要通过命名空间的方式管理，如：api_1在‘namespace1’这个命名空间下的类里面，则js端调用api_1书写形式为‘namespace1.api_1’。</p>
<p>原生端和js端提供的功能都以插件的方式提供，插件（除基础插件）都继承自一个基础插件类，插件结果回调都是走异步回传值方式，同步方式也可以但暂没实现。</p>
<h4 data-id="heading-6">iOS端逻辑步骤</h4>
<p>基础插件对象是处理js通讯和插件扩展的必要条件，wk浏览器初始化好后将基础插件类注册进插件集合，然后读取配置文件里可用的其他插件，将每个插件类注册进插件集合，代码实现：</p>
<pre><code class="hljs language-objectivec" lang="objectivec"><span class="hljs-comment">//注册基础插件</span>
    [<span class="hljs-keyword">self</span> addJavascriptObject:<span class="hljs-keyword">self</span>.ynPlugin namespace:baseNameSpace];
    <span class="hljs-comment">//注册已有插件</span>
    <span class="hljs-built_in">NSString</span>* plistPath = [[<span class="hljs-built_in">NSBundle</span> mainBundle] pathForResource:<span class="hljs-string">@"applyPlugPlist"</span> ofType:<span class="hljs-string">@"plist"</span>];
    <span class="hljs-built_in">NSArray</span> *modules = [<span class="hljs-built_in">NSArray</span> arrayWithContentsOfFile:plistPath];
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">NSDictionary</span> *obj <span class="hljs-keyword">in</span> modules) {
        Class <span class="hljs-keyword">class</span> = <span class="hljs-built_in">NSClassFromString</span>(obj[<span class="hljs-string">@"plug"</span>]);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">class</span> != <span class="hljs-literal">nil</span> &amp;&amp; ![<span class="hljs-keyword">class</span> isKindOfClass:[<span class="hljs-built_in">NSNull</span> <span class="hljs-keyword">class</span>]]) {
            [<span class="hljs-keyword">self</span> addJavascriptObject:[[<span class="hljs-keyword">class</span> alloc] init] namespace:obj[<span class="hljs-string">@"namespace"</span>]];
        }
    }
</code></pre>
<ol>
<li>
<p>js端的第一个信号来自wk的h5输入框拦截回调方法，参数prompt里携带js端要调用的api名字，参数值为字符串：_ynbridge=namespace1.api_1，_ynbridge=为YNBridge框架调用的标记，如果不是以这个标记开头则不做任何处理，只弹出正常的系统弹框。</p>
</li>
<li>
<p>通过api名，去插件集合里找有没有注册对应的插件对象，如果没有找到或找到了但插件下没有对应api则将错误结果返回js端</p>
</li>
<li>
<p>js调起的api，参数由defaultText携带。defaultText是json字符串，需要转换为json对象来解析出数据，参数值示例：{"data":null,"callId":"callId0"} data:真实参数值。 callId:api调用事件id或叫回传值队列id，当次api调用js需要回传值时此参数不为空，如果为空则表示当次api调用js端不需要结果回调</p>
</li>
<li>
<p>-(BOOL)exec:(YNJsCallInfo*)arg 此方法是插件接收数据的入口，这是个工厂方法子类必须实现，解析和组装好js过来的api和参数后用反射的方式执行对应插件的exec:方法，该方法同步方式返回个bool值，表示调用成功或失败，如果失败则将失败结果返回给js，代码实现：</p>
</li>
</ol>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-built_in">BOOL</span>(*action)(id,SEL,id) = (BOOL(*)(id,SEL,id))objc_msgSend;
    BOOL ret=<span class="hljs-built_in">action</span>(JavascriptInterfaceObject,sel,info);
    if (ret) {
        return YES;
    }
    return <span class="hljs-selector-attr">[self nativeCallBackWithCode:ret ? OK : ERROR value:ret ? @<span class="hljs-string">"OK"</span> : error complete:YES callId:info.callId]</span>;
</code></pre>
<ol>
<li>
<p>exec:方法的形参是YNJsCallInfo对象，该对象携带的参数：<br/>
action:api名，或叫动作标识字符串，各业务通过该字段判断该执行什么功能，如果插件内没有处理该api则返回调用失败的错误值false反之返回true。<br/>
callId:api调用事件id或叫回传值队列id，当给js回传值时需要带上该值返回去。<br/>
data:js给过来的参数值。<br/>
callBack:block变量，结果回调入口，回传值时需要指定四个参数status、value、callId、complete，参数用处后面讲解。</p>
</li>
<li>
<p>功能实现完成后需要调用YNJsCallInfo对象的callBack回调方法，方法参数：<br/>
status:结果状态值，此值为一个枚举类型，OK表示成功ERROR表示失败。<br/>
value:结果值，该值最后在调用js回传值api时会转换为json字符串格式。<br/>
callId:api调用事件id或叫回传值队列id。<br/>
complete:bool值，当次api任务是否全部执行完毕，处理需要保活服务的长连接状态，false执行完毕，true服务需要继续保持。</p>
</li>
<li>
<p>api调用完毕，需要给js回传值时，调用wk的- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id, NSError * _Nullable error))completionHandler方法 执行这段js代码：window.nativeCallBack('%@',%ld,%@,%d)，nativeCallBack()是js端接收原生端回传值的方法，接收四个参数，即为YNJsCallInfo对象的callBack回调参数。</p>
</li>
<li>
<p>原生功能通过插件的形式实现，要新增一个插件只需要： 第一步新建一个继承'YNPlugin'基础插件类的对象，然后在对象里实现方法-(BOOL)exec:(YNJsCallInfo*)arg； 第二步在YNBridgePlugPlist.plist文件里添加以下形式的代码</p>
</li>
</ol>
<pre><code class="hljs language-xml" lang="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dict</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>namespace<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>命名空间<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>plug<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>nativeCallBack
        <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>插件类名<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dict</span>&gt;</span>
</code></pre>
<p>然后将命名空间名和相应的api名告诉js端即可</p>
<h4 data-id="heading-7">js端</h4>
<p>调起一个原生插件时，执行YN对象里面的callNative: function (service,action,actionArgs,successCallback,failCallback)方法，方法参数：<br/>
service:原生api对应的命名空间名。<br/>
action:api名。<br/>
actionArgs:需要给原生端的参数。<br/>
successCallback:成功的回调。<br/>
failCallback:失败的回调。 比如我要调起原生端11命名空间下的jsCallTimer这个api，让原生端执行一个定时器功能，代码实现：</p>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-variable constant_">YN</span>.<span class="hljs-title function_">callNative</span>(<span class="hljs-string">'11'</span>,<span class="hljs-string">"jsCallTimer"</span>,<span class="hljs-literal">undefined</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
      <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>){
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"progress1"</span>).<span class="hljs-property">innerText</span> = value
      }<span class="hljs-keyword">else</span>{
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"progress2"</span>).<span class="hljs-property">innerText</span> = value
      }
    },<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
      <span class="hljs-title function_">alert</span>(error)
    })
</code></pre>
<ol>
<li>
<p>执行YN.call()方法，实现调起原生和结果回调队列的维护，如果注入过安卓js对象‘window._anbridge’则执行_anbridge.call(api, arg)调起安卓端，如果注入过‘window._ynwk’值为true则执行prompt('_ynbridge=' + api, arg)调起iOS端，如果需要有回传值，则arg对象将给callId字段赋一个唯一值，并且在window.nativeCallBackIds缓存集合里新增callId值，值即为回调函数。</p>
</li>
<li>
<p>所有插件调用的前提基础是js端和原生端都已正常初始化，并且通讯已建立，即deviceReady已为ture，deviceReady的询问会在js入口函数里执行，即通过YN.call()方法，执行一个原生YNBase.init的api，如果结果返回为OK则为deviceReady成功</p>
</li>
<li>
<p>原生端插件执行结果回调通过‘nativeCallBack = function (callId,status,args,complete)’方法接收值，方法内部通过callId在window.nativeCallBackIds对象里找到回调方法然后执行，将args值由json字符串转json对象后传入，判断complete字段，为true则执行：delete window.nativeCallBackIds[callId]代码，将该服务回调移除队列。</p>
</li>
</ol>
<h2 data-id="heading-8">native call js</h2>
<h4 data-id="heading-9">js端</h4>
<ol>
<li>实现思路和设计方式同js call native，即只是其一个反向过程，实现基础依然是需要实现和注册基础插件类，各子插件继承基础插件，结果回调都是通过异步回传值，所以细节不做重复阐述。</li>
<li>在入口函数执行基础插件和各插件对象的注册，注册完成后可以调用原生YNBase.jsinit这个api告诉原生端，代码实现：</li>
</ol>
<pre><code class="hljs language-arduino" lang="arduino">YN.<span class="hljs-built_in">register</span>(<span class="hljs-string">'asynObj'</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">YNPlugin</span>());
   YN.<span class="hljs-built_in">register</span>(<span class="hljs-string">'YNPlugin1'</span>,<span class="hljs-keyword">new</span> <span class="hljs-built_in">YNPlugin1</span>());
  <span class="hljs-comment">//告诉原生js初始化了，调原生初始化api（在js初始化前原生就要求执行的js方法可在jsinit方法里开始执行了）</span>
  <span class="hljs-keyword">if</span> (deviceReady){
    YN.<span class="hljs-built_in">call</span>(<span class="hljs-string">'YNBase.jsinit'</span>);
  }
</code></pre>
<p>register()方法内部实现同原生注册插件的形式，将插件和对应的命名空间添加进window.nativeNamespaceInterfaces集合。</p>
<ol start="3">
<li>
<p>接收原生端第一个信号由nativeCallJs = function(callId,service,action,actionArgs)方法接收，参数：<br/>
callId:api调用事件id或叫回传值队列id。<br/>
service:js api对应的命名空间名。<br/>
action:api名。<br/>
actionArgs:原生端的参数。 方法内部实现同原生插件调用，也是找到插件并执行插件方法exec(action,args,responseCallback)。</p>
</li>
<li>
<p>插件回传值结果和api调用结果通过调用原生的YNBase.returnValue这个api实现，即执行YN.call('YNBase.returnValue', value); value是参数对象，包含data、callId、complete、status四个字段，含义和用途同原生回调那里。</p>
</li>
</ol>
<h4 data-id="heading-10">iOS端</h4>
<ol>
<li>
<p>调起一个js端的插件功能，执行wk对象的方法-(void)callHandler:(NSString*)server action:(NSString *)action arguments:(id)args completionHandler:(JSCallback)completionHandler;该方法逻辑同js call native时调用的YN.call()方法，通过维护一个callid服务队列来处理结果回传。</p>
</li>
<li>
<p>组装好参数后浏览器执行window.nativeCallJs('%@','%@','%@',%@)这个js代码即可调起js，代码示例：</p>
</li>
</ol>
<pre><code class="hljs language-objectivec" lang="objectivec">[<span class="hljs-keyword">self</span> evaluateJavaScript:[<span class="hljs-built_in">NSString</span> stringWithFormat:<span class="hljs-string">@"window.nativeCallJs('%@','%@','%@',%@)"</span>,info.callId,info.service,info.action,[JSBUtil objToJsonString:info.args]]];
</code></pre>
<p>接收插件结果回传值在基础插件里监听returnValue这个api的执行，逻辑处理同js端nativeCallBack()方法。也是如果complete字段值为true时将该服务对象从队列里移除</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[command和shell模块到底区别在哪？]]></title>    <link>https://juejin.cn/post/7603651011979427882</link>    <guid>https://juejin.cn/post/7603651011979427882</guid>    <pubDate>2026-02-08T04:27:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603651011979427882" data-draft-id="7603769956974936105" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="command和shell模块到底区别在哪？"/> <meta itemprop="keywords" content="Linux,Ansible,云计算"/> <meta itemprop="datePublished" content="2026-02-08T04:27:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="Sheffield"/> <meta itemprop="url" content="https://juejin.cn/user/362164852109770"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            command和shell模块到底区别在哪？
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/362164852109770/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    Sheffield
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T04:27:58.000Z" title="Sun Feb 08 2026 04:27:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    5
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>刚学Ansible的新手，肯定都懵过：command和shell模块，不都是远程执行命令吗？为啥有时候用command报错，换shell就好使？</p>
<p>核心就1句大白话：<strong>执行命令时，要不要找“中间人”（shell解释器）帮忙</strong>。不用记复杂概念，今天用最简单的话+实操例子，讲清两者区别，新手看完就知道该用哪个。</p>
<h2 data-id="heading-0">一、先搞懂：两者执行方式不一样</h2>
<p>不用管底层原理，记住两个类比，瞬间明白：</p>
<h3 data-id="heading-1">1. command模块：直接“喊”程序干活，不找中间人</h3>
<p>用command执行命令，会直接调用目标机器上的程序，不经过任何“翻译”（shell解释器，比如bash）。</p>
<p>例子：用command执行ls /home，Ansible直接找到系统里的ls程序，让它查/home目录，一步到位。</p>
<p>特点：快、简单，但笨——不支持任何“高级操作”（比如管道、重定向）。</p>
<h3 data-id="heading-2">2. shell模块：先找中间人，再让中间人“喊”程序干活</h3>
<p>用shell执行命令，会先启动目标机器的默认“中间人”（默认是/bin/sh），再让这个中间人去调用程序、执行命令。</p>
<p>还是执行ls /home，用shell的话，流程是：Ansible启动中间人→中间人喊ls程序→执行命令。</p>
<p>特点：灵活、能干——支持所有高级操作，但比command慢一点，还有点安全风险。</p>
<h2 data-id="heading-3">二、核心区别：一张表看清</h2>
<p>不用死记，遇到分不清的情况，对照这张表找答案，一目了然：</p>








































<table><thead><tr><th>对比维度</th><th>command模块</th><th>shell模块</th></tr></thead><tbody><tr><td>要不要中间人（shell）</td><td>不要，直接调用程序</td><td>要，默认用/bin/sh</td></tr><tr><td>支持管道(|)</td><td>不支持（新手记死）</td><td>支持</td></tr><tr><td>支持重定向（&gt;、&gt;&gt;）</td><td>不支持（新手记死）</td><td>支持</td></tr><tr><td>支持环境变量（$HOME等）</td><td>不支持（直接输出$HOME）</td><td>支持（能输出真实路径）</td></tr><tr><td>安全性</td><td>高（不容易出问题）</td><td>较低（有安全风险）</td></tr><tr><td>Ansible默认用哪个</td><td>是（不指定模块就用它）</td><td>否（要手动指定-m shell）</td></tr></tbody></table>
<h2 data-id="heading-4">三、实战示例：新手最常遇到的3种情况</h2>
<p>光看表不够，结合例子练1次，以后再也不踩坑！</p>
<h3 data-id="heading-5">场景1：简单命令（比如重启服务）——优先用command</h3>
<p>像重启nginx、查看文件，这种简单操作，两者都能用，但优先选command（快、安全）。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 推荐：用command重启nginx</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span> <span class="hljs-string">with</span> <span class="hljs-string">command</span>
  <span class="hljs-attr">command:</span> <span class="hljs-string">systemctl</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span>

<span class="hljs-comment"># 能用但没必要：用shell重启nginx</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span> <span class="hljs-string">with</span> <span class="hljs-string">shell</span>
  <span class="hljs-attr">shell:</span> <span class="hljs-string">systemctl</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span>
</code></pre>
<h3 data-id="heading-6">场景2：用管道、重定向——只能用shell</h3>
<p>新手最容易踩坑的地方！只要命令里有|、&gt;、&gt;&gt;，用command必报错，换shell就好。</p>
<pre><code class="hljs language-yaml" lang="yaml"><span class="hljs-comment"># 错误：command不能用管道</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">查看java进程（报错）</span>
  <span class="hljs-attr">command:</span> <span class="hljs-string">ps</span> <span class="hljs-string">aux</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">java</span>

<span class="hljs-comment"># 正确：用shell执行管道命令</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">查看java进程（正常）</span>
  <span class="hljs-attr">shell:</span> <span class="hljs-string">ps</span> <span class="hljs-string">aux</span> <span class="hljs-string">|</span> <span class="hljs-string">grep</span> <span class="hljs-string">java</span>

<span class="hljs-comment"># 正确：用shell重定向写入文件</span>
<span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">写内容到文件</span>
  <span class="hljs-attr">shell:</span> <span class="hljs-string">echo</span> <span class="hljs-string">"Sheffield"</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">/tmp/test.txt</span>
</code></pre>
<h3 data-id="heading-7">场景3：用环境变量（比如$HOME）——只能用shell</h3>
<p>想调用<code>$HOME、$PATH</code>这种环境变量，command不识别，必须用shell。</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 正确：用shell查看家目录</span>
- name: 查看家目录
  shell: <span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span> <span class="hljs-comment"># 会输出/root（管理员用户）</span>

<span class="hljs-comment"># 错误：command查看家目录（只会输出$HOME）</span>
- name: 查看家目录（报错效果）
  <span class="hljs-built_in">command</span>: <span class="hljs-built_in">echo</span> <span class="hljs-variable">$HOME</span>
</code></pre>
<h2 data-id="heading-8">四、安全提醒</h2>
<p>shell虽然好用，但如果命令里有用户输入、变量，容易被恶意攻击（比如删文件）。</p>
<p>简单说：能不用shell就不用，必须用的时候，别随便放用户输入的内容。</p>
<h2 data-id="heading-9">五、新手速记：3句话搞定所有场景</h2>
<ol>
<li>简单命令（不涉及|、&gt;、$）：优先用command（默认、安全、快）；</li>
<li>用到管道、重定向、环境变量：只能用shell；</li>
<li>命令里有用户输入、变量：优先用command，避免风险。</li>
</ol>
<h2 data-id="heading-10">常见误区（避坑！）</h2>
<ol>
<li>
<p>误区：shell比command强，所有场景都用shell</p>
<p>——错！非必要不用，费资源还不安全；</p>
</li>
<li>
<p>误区：两者用法不一样</p>
<p>——错！常用参数（比如切换目录），用法完全相同；</p>
</li>
<li>
<p>误区：command用不了的，shell也用不了</p>
<p>——错！只要有shell解释器，shell都能搞定。</p>
</li>
</ol>
<p>其实新手不用想太复杂，记住“简单用command，复杂用shell”，就能应对99%的场景。练两次实操，很快就能分清～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[浅析二叉树、B树、B+树和MySQL索引底层原理]]></title>    <link>https://juejin.cn/post/7603651855236743177</link>    <guid>https://juejin.cn/post/7603651855236743177</guid>    <pubDate>2026-02-08T06:02:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603651855236743177" data-draft-id="7603674653153689609" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="浅析二叉树、B树、B+树和MySQL索引底层原理 "/> <meta itemprop="keywords" content="后端"/> <meta itemprop="datePublished" content="2026-02-08T06:02:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="神奇小汤圆"/> <meta itemprop="url" content="https://juejin.cn/user/1151943919285431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            浅析二叉树、B树、B+树和MySQL索引底层原理 
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1151943919285431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    神奇小汤圆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T06:02:48.000Z" title="Sun Feb 08 2026 06:02:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读23分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>数据库是后端工程师绕不开的核心技术，而索引则是核心中的核心。在日常工作中，我们每天都在和索引打交道，索引问题也是高级工程师面试中，面试官最喜欢考察的地方。</p>
<p>  很多开发者在面试中谈及索引时，往往只能给出一些零散、机械的记忆性答案，比如“B+树查询快”、“索引能提速”。这样的回答在面试官心中留下的深刻印象就是此候选人学习知识浅尝辄止，不够深入，不够努力。真正体现一个工程师技术深度的，是对索引背后设计原理的系统性理解，以及在复杂场景下进行选型和优化的能力。</p>
<p>  在 MySQL 中，通常所说的索引，如果没有特别声明，默认都是指 B+ 树数据结构的索引。在介绍各种树的数据结构和MySQL索引之前，先介绍本文多次使用的几个基本概念：</p>
<p><strong>节点</strong>：包含一个数据元素及若干指向子树的指针等。<br/>
<strong>根节点</strong>：是树的起始节点，它没有父节点，就像是大树的根基，其它节点都从根节点衍生出来。<br/>
<strong>叶子节点</strong>：也叫终端节点，是没有子节点的节点，它们位于树的最底层，就像树枝的末梢。<br/>
‌<strong>内部节点</strong>（internal Node）‌：至少有一个子节点的节点，包括根节点和所有非叶子节点。<br/>
<strong>兄弟节点</strong>： 具有相同父节点的节点。<br/>
<strong>节点的度</strong>：该节点拥有的子节点个数。例如二叉树中节点的度最大为 2，即每个节点最多有两个子节点。<br/>
<strong>树的度</strong>：整棵树中所有节点的最大度数。<br/>
<strong>层级</strong>：从根节点开始，树的每一层都是一个层级。<br/>
<strong>高度</strong>（height）：当前节点到最远叶子节点的最长路径上的节点数。<br/>
<strong>平衡因子</strong>（Balance Factor）：简称BF，每个节点的左右子树的高度之差。<br/>
<strong>数据页</strong>：树上每个节点在计算机中叫做数据页，是 InnoDB 存储引擎与磁盘交互的最小单位，默认大小为 16KB。<br/>
<strong>阶数</strong>：一个节点最多可以有多少个子节点（即节点的最大度数），一般用小写字母m表示阶数。用⌈m/2⌉表示对m/2向上取整数。例如，三阶 B+ 树 → 每个节点最多 3 个子节点 → 最大度 = 3。</p>
<p>  在数据库中我们将B+树作为索引结构，可以加快查询速度，此时树中的key一般是表的主键。例如，MySQL InnoDB 的记录，就是按照主键由小到大排序后，存在 B+ 树的叶子节点里。树中每个节点存储了关键字（key）、关键字对应的数据（data）以及指向孩子节点的指针。我们将一个key及其对应的data称为一条 <strong>记录</strong>。但为了方便描述，除非特别说明，后续文中就用“关键字”来代指（key, value）键值对。下面就是MySQL中索引的数据结构：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1425079df27a4ec6961449e319c95016~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=tDSMLNqTd%2FyFEdPl1CSvqd6ZH1w%3D" alt="image" loading="lazy"/><br/>
图1 索引的数据结构。备注：磁盘块4有笔误，应该删除10。</p>
<p>  不同的树结构适用于不同的应用场景，选择合适的树结构可以显著提高程序的性能和效率。在分析为什么MySQL InnoDB存储引擎的索引选择使用B+树之前，我相信很多攻城狮对数据结构中的树还是有些许模糊的，因此就让我们一同踏上这趟由浅入深探讨二叉查找树、AVL树、红黑树、B树和B*树的奇妙之旅，一步步引出B+树以及为什么MySQL InnoDB数据库索引选择使用B+树！领略B+树在数据库索引中应用的神奇魅力。希望通过本文，你能构建起一个体系化的树和索引知识框架，让你在未来的面试和工作中游刃有余。</p>
<h3 data-id="heading-0">二叉查找树</h3>
<p>  二叉查找树(Binary Search Tree, BST)也称为有序二叉树（Ordered Binary Tree）、排序二叉树（sorted binary tree）或者二叉搜索树，是一棵满足以下三个性质的二叉树：</p>
<ol>
<li>有序性：任意非空左子树所有节点的值均小于该节点的值；非空右子树所有节点的值均大于于该节点的值；</li>
<li>递归性：任意节点的子树都是二叉查找树；</li>
<li>每个节点存储一条记录，且没有键值相等的节点。</li>
</ol>
<p>  从递归定义的角度来看，二叉查找树可以被定义为：要么是一棵空树，要么是由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；而左子树和右子树又同样都是二叉查找树。这种递归定义方式简洁而准确地描述了二叉查找树的结构特点。它作为基础的树形结构，<strong>每个节点最多有两个子节点</strong>，其递归性和有序性为我们理解更复杂的树结构奠定了基础。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0c3fe3ef4df44f3891671296a5f6f280~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=2WNazK3yj09jeAg7U3I%2BfBWNA7E%3D" alt="image" loading="lazy"/><br/>
图2 二叉搜索树</p>
<p>  如果我们需要查找id=31的记录，利用我们创建的BST，基于二分查找算法实现的查找流程如下：</p>
<ol>
<li>将根节点作为当前节点，把31与当前节点的键值33比较，31小于33，接下来我们把当前节点的左子节点作为当前节点。</li>
<li>继续把31和当前节点的键值28比较，发现31大于28，把当前节点的右子节点作为当前节点。</li>
<li>把31和当前节点的键值31对比，发现二者相等，满足条件，遍历结束。</li>
</ol>
<p>  所以，我们利用BST只需要3次即可找到目标数据。</p>
<p>  二叉树的查找、插入和删除操作的时间复杂度在平均情况下为 O(logn) ，但在最坏情况下，当二叉树退化为链表时，时间复杂度会变为 O(n) 。这是因为在最坏情况下，所有节点都在一条链上，查找、插入和删除都需要遍历整个链表。如下图所示退化的二叉查找树：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2cdd2f92a86b41e39d80d6337863cad4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=UzRdZ3knfyovWg%2BZOtpNmTRnBxI%3D" alt="image" loading="lazy"/></p>
<p>  二叉树完全不平衡时，查找的时间复杂度就和链表一致了：O(n)。导致这个现象的原因其实是BST变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。为了解决这个问题，我们需要保证二叉查找树一直保持平衡，从而引出了一个新的定义——平衡二叉树AVL。</p>
<h3 data-id="heading-1">AVL树/红黑树</h3>
<p>  平衡二叉树（Balanced Binary Tree）是一种特殊的、平衡的二叉搜索树，通过严格控制每个节点的平衡因子来保持树的平衡。常见的平衡二叉树有AVL树和红黑树等，在满足BST特性的基础上，具有如下特性：</p>
<ol>
<li>平衡因子限制‌：要求平衡因子的绝对值不能超过1。</li>
<li>递归性质‌：左右两个子树本身也都是平衡二叉树。</li>
</ol>
<p>  不管是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转树上的节点来保持平衡，使得树的高度始终保持在 O(logn)的范围内。而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入或者删除次数比较少，但查找多的情况。</p>
<p>🤔 为什么要平衡？</p>
<p>  保持效率：平衡的二叉搜索树可以确保不管是执行插入还是删除操作都能在O(logn)时间内完成，这对于需要高效处理数据的系统来说至关重要。</p>
<p>  避免最坏情况：没有平衡机制的数据结构在最坏情况下可能会退化成链表，导致效率大大降低。平衡机制通过旋转操作<br/>
完成，而旋转操作非常耗时，由此我们可以知道AVL树适合用于插入或者删除次数比较少，但查找多的情况。本文不介绍具体的旋转操作。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/938839846591468ca7f81485a5c664ec~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=AKUbnuhg%2F7qN0PNfKup1U%2FG8WeQ%3D" alt="image" loading="lazy"/></p>
<p>  平衡二叉树通过约束节点的子树高度差，确保树的高度保持对数级，相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p>
<p>  红黑树（Red-Black Tree）因节点是红色和黑色两种颜色之一而命名，它本身是一棵二叉查找树，在其基础上做了如下约束：</p>
<ul>
<li>根节点是黑色节点</li>
<li>所有叶子节点（NIL节点）都是黑色的</li>
<li>节点的颜色要么是黑色要么是红色</li>
<li>无连续红色节点：红色节点的子节点为黑色节点（即相邻的两个节点不可能同时为红色）</li>
<li>任意节点的左子树和右子树高度（只统计黑色节点）相同</li>
<li>旋转操作：当插入或删除导致树不平衡时，通过旋转操作来恢复平衡。</li>
</ul>
<p>  这些规则看起来是否有点复杂？其实它们的核心目的只有一个：控制整棵树的高度，防止退化成链表。</p>
<p>  下图是一个标准的红黑树：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e1d06f02ab84420fa341474d8011b03c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=l%2FG6MXeZLG1koYAovjrS7DrFxfo%3D" alt="image" loading="lazy"/></p>
<p>  黑色完美平衡：“任意节点的左子树和右子树高度（只统计黑色节点）相同 &amp; 红色节点的子节点是黑色节点”。这就保证了红黑树的“平衡性”。由于这种平衡，其查询的复杂度自然也是O(log n)的。</p>
<p>红黑树与AVL树的区别：</p>






























<table><thead><tr><th>特性</th><th>AVL 树</th><th>红黑树</th></tr></thead><tbody><tr><td>平衡性</td><td>非常严格，平衡因子最多为1</td><td>近似平衡，只要求从根到叶子的最长路径不超过最短路径的两倍</td></tr><tr><td>插入性能</td><td>多次旋转，效率较低</td><td>快（最多两次旋转）</td></tr><tr><td>删除性能</td><td>多次旋转，效率更低，代价更高</td><td>较快（最多三次旋转）</td></tr><tr><td>查找性能</td><td>更快</td><td>稍慢（但仍为 O(log n)）</td></tr></tbody></table>
<p>  相较于 AVL 树，它是一种弱平衡二叉树，不需要像 AVL 树那样严格要求平衡，这也导致它的查询效率并没有 AVL 树那么高，但相对的，它带来的好处是对于调整失衡，红黑树的旋转次数更少，所以频繁的插入或删除操作，红黑树更有优势。</p>
<p>  AVL 是“强迫症患者”，每次插入删除都可能引发多次旋转，代价太高；而红黑树是“实用主义者”，它不要求完全平衡，只要能保证查找效率不崩就行。红黑树是在“速度”、“稳定性”和“实现成本”之间找到的一个折中王者！</p>
<p>  红黑树更常用于需要高频插入和删除的场景，例如：java 8 HashMap和ConcurrentHashMap中链表转红黑树；epoll在内核中的实现，用红黑树管理事件块（文件描述符）；Java的TreeMap和TreeSet实现；linux进程CFS调度器（Completely Fair Scheduler）用红黑树管理进程控制块 ；nginx中，用红黑树管理timer。AVL树更适合读多写少的场景，因为它的查找性能更接近完美的平衡树。</p>
<h3 data-id="heading-2">B树(B-tree)</h3>
<p>  当数据量太大，无法全部装入内存时，就必须存放在磁盘上。磁盘I/O（读写）速度远远逊色于内存访问。B树和B+树就是为了减少磁盘I/O次数而设计的多路平衡搜索树，它们被广泛用于数据库和文件系统的索引。下面介绍B树。</p>
<p>  B树（Balance Tree）也称B-树，是一棵平衡多路查找树，<strong>节点的子节点个数可能超过两个</strong>，用来存储排序后的数据。我们描述一棵B树时需要指定它的阶数m，当m=2时，就是我们常见的二叉搜索树。B树是一种自平衡的树状数据结构，能够让数据的查找、插入及删除动作都在对数时间内完成，常常用在存储系统上，如数据库或文件系统。</p>
<p>  一棵m阶的B树，或为空树，或为满足下列特性的m叉树：</p>
<ol>
<li>每个节点最多有m（m&gt;=2）棵子树，除非根节点为叶子节点，否则，至少有两棵子树。例如，对于一个4阶B树，每个节点最多有4个孩子，最少有2个孩子；</li>
<li>每个节点存放至少 <strong>⌈m/2⌉-1</strong> 个关键字，至多 <strong>m-1</strong> 个关键字；</li>
<li>关键字个数比孩子节点个数小1。即如果一个节点有k个关键字，那么它就有k + 1个孩子。如下图所示为一棵3阶B树的结构示意图，根节点有2个关键字和3个指针，它有3个孩子，这些孩子分别对应关键字划分的3个区间：</li>
</ol>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/91865d6b93bc483a98957fb0e22feb43~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=Vr1Eq6Cx%2BOMo6vcD1P2dnT5H%2FEU%3D" alt="image" loading="lazy"/></p>
<ol start="2">
<li>若根节点不是叶子节点，则至少包含两棵子树（特殊情况：没有孩子的根节点，即根节点为叶子节点，整棵树只有一个根节点）；</li>
<li>除根节点和叶子节点外，其它每个节点至少有 <strong>⌈m/2⌉</strong> 棵子树；</li>
<li>每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它；</li>
<li>所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。这保证了B树的平衡性，使得查找操作的时间复杂度为O(logn)。</li>
</ol>
<p>  下图即是一棵 m=3 的B树：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e41b73427d8b47ebb6a039f3b6c8f06c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=YJMBBJzKBXHMAR2ikjE1qOXkts8%3D" alt="image" loading="lazy"/></p>
<p>  在实际应用中B树的阶数都非常大，通常大于100，所以即使存储大量的数据，B树的高度仍然比较小。每个节点中存储了关键字（key）和关键字对应的数据（data）以及孩子节点的指针。B树和平衡二叉树的不同之处：B树属于多叉树，父节点的子节点个数不止两个。注意: 有文章把B树和B-tree理解成了两种不同类别的树，其实二者是同一种树。B树有如下数据特征：</p>
<ol>
<li>数据存储在整棵树中；</li>
<li>任何一个关键字出现且只出现在一个节点中；</li>
<li>搜索有可能在非叶子节点结束，故查询性能不稳定；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动平衡树的高度和数据页。</li>
</ol>
<p>  B-树的查询方式如下：从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子节点；重复，直到所对应的儿子指针为空，或已经是叶子节点。</p>
<h3 data-id="heading-3">B+树（B+ Tree）</h3>
<p>  B+树是在B树的基础上又一次改进的多路平衡搜索树，其主要在两个方面进行了提升，一方面是查询的稳定性，让查询速度更加稳定，其速度完全接近于二分查找；另外一方面是在数据排序方面更友好，更充分的利用节点的空间。B+树包含两种类型的节点：内部节点（也称索引节点）和叶子节点。根节点本身即可以是内部节点，也可以是叶子节点。B+树的规则与B树基本类似，但是又在B树的基础上做了以下几点改进：</p>
<ul>
<li>父节点存有指向右子树第一个元素的索引。</li>
<li>内部节点不存储数据，只存储索引，用于路由，叶子节点存完整行数据（主键索引）或 (索引列 + 主键)（二级索引）。这是B+树与B树的最大差异。</li>
<li>内部节点的子树指针与关键字个数相同。</li>
<li>内部节点的关键字都按照从小到大的顺序排列，对于内部节点中的一个关键字，左子树中的所有关键字都小于它，右子树中的关键字都大于等于它。</li>
<li>所有叶子节点都存储指向下一个相邻叶子节点的指针，形成一个单向链表。</li>
</ul>
<p>  下图是一棵m=3的B+树：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/27aaed6dd99840d98bca40692deb7fd5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=WinfQPeM4GOFHcisfAwOaVZqoF4%3D" alt="image" loading="lazy"/></p>
<p>MySQL中的B+树是上述B+树的又一次进化：MySQL基于普通B+Tree，在叶子节点添加了一个指向上一个相邻叶子节点的指针，并且首尾叶子节点也是相连的，也就是构造了一个如图1所示的双链表。下文再提及B+树时，指带有双向链表的MySQL B+树。</p>
<p>  B+树相对于B树有一些自己的巨大优势，可以归结为下面几点：</p>

























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td>更稳定的查询效率</td><td>数据仅存储在叶子节点，任何查找都必须走到叶子节点，路径长度相同，性能稳定。</td></tr><tr><td>更高的空间利用率</td><td>内部节点不存数据，存储的关键字更多，树更矮，读取数据时I/O次数更少。</td></tr><tr><td>强大的范围查询</td><td>叶子节点通过指向前后叶子节点的指针形成了一个有序双向链表，故可以高效地进行范围查询和反向排序，而B树需要进行复杂的中序遍历。</td></tr><tr><td>更适合磁盘预读</td><td>磁盘按数据页读写。B+树的节点通常设计为恰好一数据页大小，一次I/O能加载更多键，进一步减少I/O。</td></tr></tbody></table>
<p>  B+树的插入操作很简单，只需要记住一个技巧即可：当节点元素数量大于m-1的时候，就按中间元素分裂成左右两部分，中间元素的关键字分裂到父节点当做索引存储，但是，本身中间元素还是分裂到右子树中。</p>
<blockquote>
<p><strong>面试题</strong>：B+树为什么比B树更适合作为操作系统的文件索引和数据库索引？</p>
</blockquote>
<p>  简答如下：<br/>
<strong>B+树的磁盘读写代价更低</strong>。它的内部节点没有存储记录，因此内部节点相对B树占用的存储空间更小。如果把所有同一内部节点的关键字放在同一块磁盘中，盘块所能容纳的关键字数量也就越多，一次性读入内存中的需要查找的关键字也就越多，相对I/O读写次数降低。</p>
<p>  <strong>B+树的查询效率更加稳定</strong>。由于非终节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
<p>  <strong>B+树支持范围查询</strong>。B+树只要遍历叶子节点就可以实现整棵树的遍历，支持基于范围查询，而B树不支持范围查找。</p>
<blockquote>
<p>面试题：为什么 InnoDB 选择 B+ 树作为索引结构？</p>
</blockquote>
<p>  相对于二叉树，B+ 树的层级更少，搜索效率更高。相对 Hash 索引，B+ 树支持范围查找以及排序操作。对于 B- 树，无论是叶子节点还是非叶子节点都会保存数据，这样会导致一页中存储的键值减少，指针跟着减少；要同样保存大量数据，只能增加树的高度，导致性能降低。B+ 树中间节点没有卫星数据（索引元素所指向的数据记录），只有索引。这就意味着同样的大小的磁盘页可以容纳更多节点元素，在相同的数据量下，B+ 树更加 “矮胖”，I/O 操作更少。因为卫星数据的不同，导致查询过程也不同；B- 树的查找只需找到匹配元素即可，最好情况下查找到根节点，最坏情况下查找到叶子结点，所说性能很不稳定，而 B+ 树每次必须查找到叶子结点，性能稳定。</p>
<h3 data-id="heading-4">B*树（B star Tree）</h3>
<p>  B<em>树是普通B+树的变形，在普通B+树除根节点外的内部节点增加指向兄弟节点的指针，将节点的最低利用率从普通B+树的1/2提升到2/3。下图是一棵m=3的B</em>树：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fed75f90c5c46acb10d8d338176e70c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=lAUbVGEnXpbRU9tng0FiLqEk5tg%3D" alt="image" loading="lazy"/></p>
<p>  在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树分裂次数变得更少。</p>
<p>  B+树的分裂：当一个节点满时，分配一个新的节点，并将原节点中1/2的数据复制到新节点，最后在父节点中增加新节点的指针；B+树的分裂只影响原节点和父节点，而不会影响兄弟节点，所以它不需要指向兄弟节点的指针。</p>
<p>  B<em>树的分裂：当一个节点满时，如果它的下一个兄弟节点未满，那么将一部分数据移到兄弟节点中，再在原节点插入关键字，最后修改父节点中兄弟节点的关键字（因为兄弟节点的关键字范围改变了）；如果兄弟也满了，则在原节点与兄弟节点之间增加新节点，并各贡献三分之一的数据到新节点，最后在父节点增加新节点的指针。所以，B</em>树分配新节点的概率比B+树要低，空间使用率更高。</p>
<h3 data-id="heading-5">树的总结</h3>
<p>1、相同思想和策略</p>
<p>  从平衡二叉树、B树、B+树、B*树总体来看它们的贯彻的思想是相同的，都是采用二分查找和数据平衡策略来提升查找数据的速度。</p>
<p>2、不同的方式对树的不断优化</p>
<p>  为了保证树的节点均匀分布，所以在二叉树的基础上加上了平衡算法，就有了平衡二叉树。</p>
<p>  为了减少树的高度，所以B树一个节点下面可以添加N个子节点，然后每个节点的大小默认限制在16KB，只需要通过一次IO就能读取到节点上的所有数据，通过增加节点存储的数据减少了树的高度，而并没有让IO次数变多。</p>
<p>  B+树在B树的基础上，对查询的稳定性和排序策略进行了优化，因为B+树所有的数据都保存到叶子节点，并且所有叶子节点本身是有序排列的。</p>
<p>  B*树为了减少树在构建过程中节点的分裂或者合并次数，所以在每个非根节点的内部节点上都保存了兄弟节点的指针，在节点需要进行分裂或者合并时，优先从兄弟节点挪数据，从而减少构建过程中节点分裂或者合并的次数，提升了树的构建性能，将节点的最低利用率从1/2提高到2/3。</p>
<h3 data-id="heading-6">实际应用中的索引优化</h3>
<p>  了解 B树 和 B+树的基本原理后，在实际应用中如何合理使用索引呢？首先，要选择合适的索引列。对于经常用作查询条件和排序的列，应该建立索引。其次，要注意索引的维护。频繁更新的列会导致索引重建，因此要权衡索引的利弊。最后，要根据查询需求选择合适的索引类型。对于需要频繁进行范围查询的列，B+ 树索引是更好的选择。</p>
<p>  在实际应用中，还可以通过复合索引、覆盖索引等高级技术进一步优化查询性能。</p>
<h3 data-id="heading-7">聚集索引和辅助索引</h3>
<p>  MySQL InnoDB存储引擎数据库中的B+Tree索引可以分为聚集索引（clustered index，也叫主键索引、聚簇索引）和辅助索引（secondary index，也叫非聚集索引）。</p>
<p>  聚集索引也叫主键索引，叶子节点中的data存储的是该主键对应的整行数据，通常B+Tree的高度为3，也就是有三层节点，MySQL会把B+Tree第一层也就是根节点放在内存中，我们根据主键索引查数据，只需要两次磁盘I\O（第二层1次，第三层1次）即可。</p>
<p>非聚集索引也叫辅助索引，叶子节点中存储的是该索引所在记录的主键值，所以非聚集索引的寻址过程分两种情况：</p>
<p>(1) 非聚集索引已经索引覆盖了，那么只需要遍历这非聚集索引这一个B+Tree即可，按照上面的分析，需要两次磁盘IO即可（mysql会把根节点放到内存中）。</p>
<p>(2) 非聚集索引不能索引覆盖，那么需要回表。先需要在非聚集索引这个B+Tree上两次IO找到主键，然后拿着主键去聚集索引的B+Tree上找对应的完整数据记录。相比第一种情况IO次数要多，所以我们通常喜欢索引覆盖。这个过程会增加额外的 IO 消耗和网络传输时间，降低查询性能。</p>
<p>下图表示非聚集索引不能索引覆盖的情况：右侧的辅助索引先拿到主键值5，然后去左侧的主键索引中寻址，最后可以得到整行记录的内容。</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/700732be249847d893da968764a1b1dd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg56We5aWH5bCP5rGk5ZyG:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771135404&amp;x-signature=XPXfhzhzM8GBVCqnQU3LpYYdG80%3D" alt="image" loading="lazy"/></p>
<h3 data-id="heading-8">面试实战指南</h3>
<p>  掌握了以上各种树的知识，你已经能应对80%的索引问题。但想在面试中真正征服面试官，还需要准备一些更具深度和广度的话题。这里再考察索引问题的时候，有经验的面试官很可能对以下三个问题深挖，你可以准确回答了吗？</p>
<ul>
<li>B+树与B树、红黑树等其它树的对比</li>
<li>MySQL索引会失效吗</li>
<li>MySQL InnoDB表中含有NULL值的列建索引有作用吗</li>
<li>MySQL InnoDB高度为3的B+Tree可以存储多少条数据</li>
</ul>
<p>答案即将揭晓，敬请关注小编。</p>
<h3 data-id="heading-9">结束语</h3>
<p>  本文介绍了二叉树、AVL树、红黑树、B树和B+树五种树的数据结构，介绍了如何一步步降低树的高度，提升增删改查效率，最后介绍了MySQL InnoDB索引及其相关高频、高阶面试题。</p>
<p>  请暂放工作喧嚣，享受汗水换来的闲暇，惬意阅读。聆听内心，感受自由，静享丰盈时光。愿这份宁静和这篇博文，滋养你前行。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Spring Batch实战]]></title>    <link>https://juejin.cn/post/7603575763786874906</link>    <guid>https://juejin.cn/post/7603575763786874906</guid>    <pubDate>2026-02-06T23:44:29.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603575763786874906" data-draft-id="7603352117640134665" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Spring Batch实战"/> <meta itemprop="keywords" content="Java,Spring"/> <meta itemprop="datePublished" content="2026-02-06T23:44:29.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="雨中飘荡的记忆"/> <meta itemprop="url" content="https://juejin.cn/user/694547077666606"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Spring Batch实战
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/694547077666606/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    雨中飘荡的记忆
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-06T23:44:29.000Z" title="Fri Feb 06 2026 23:44:29 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-06
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">Spring Batch实战</h2>
<h3 data-id="heading-1">前言</h3>
<p>在企业级应用中，批量数据处理是一个非常常见的需求。比如月底的工资代发、银行对账、数据报表生成等。当数据量达到几十万甚至上百万时，如何高效、可靠地处理这些数据，就成了一个技术挑战。</p>
<p>本文将以"50万笔工资代发"为实际场景，详细介绍如何使用Spring Batch框架来处理大规模批量数据，并重点讲解当处理失败时，如何实现<strong>部分回滚机制</strong>，确保已成功处理的数据不会因为少量失败记录而全部回滚。</p>
<hr/>
<h3 data-id="heading-2">一、什么是Spring Batch？</h3>
<h4 data-id="heading-3">1.1 Spring Batch简介</h4>
<p>Spring Batch是一个轻量级的、全面的批处理框架，由Spring团队开发，旨在帮助企业开发健壮的批处理应用程序。它于2008年首次发布，经过十多年的发展，已经成为Java批处理领域的事实标准。</p>
<p>Spring Batch的核心设计理念包括：</p>
<ul>
<li><strong>Chunk-oriented Processing（块级处理）</strong>：将大量数据分批处理，避免内存溢出</li>
<li><strong>事务管理</strong>：每个Chunk作为一个独立的事务，支持部分回滚</li>
<li><strong>容错机制</strong>：支持跳过（Skip）、重试（Retry）等容错策略</li>
<li><strong>作业调度</strong>：支持定时任务、手动触发等多种调度方式</li>
<li><strong>监控与统计</strong>：提供完整的执行记录和统计信息</li>
</ul>
<h4 data-id="heading-4">1.2 核心概念详解</h4>
<h5 data-id="heading-5">Job（作业）</h5>
<p>Job是批处理的核心概念，代表一个完整的批处理任务。一个Job可以包含多个Step，按顺序或并行执行。</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Job <span class="hljs-title function_">salaryPaymentJob</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> jobBuilderFactory.get(<span class="hljs-string">"salaryPaymentJob"</span>)
        .start(step1())
        .next(step2())
        .build();
}
</code></pre>
<h5 data-id="heading-6">Step（步骤）</h5>
<p>Step是Job的基本执行单元，每个Step包含：</p>
<ul>
<li><strong>ItemReader</strong>：读取数据</li>
<li><strong>ItemProcessor</strong>：处理数据（可选）</li>
<li><strong>ItemWriter</strong>：写入数据</li>
</ul>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Step <span class="hljs-title function_">salaryPaymentStep</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> stepBuilderFactory.get(<span class="hljs-string">"salaryPaymentStep"</span>)
        .&lt;SalaryPayment, SalaryPayment&gt;chunk(<span class="hljs-number">1000</span>)
        .reader(reader())
        .processor(processor())
        .writer(writer())
        .build();
}
</code></pre>
<h5 data-id="heading-7">Chunk（数据块）</h5>
<p>Chunk是Spring Batch处理数据的基本单位。每次从Reader读取指定数量的记录，处理后一起提交到数据库：</p>
<pre><code class="hljs">读取1000条 → 处理1000条 → 写入1000条 → 提交事务
</code></pre>
<h4 data-id="heading-8">1.3 应用场景</h4>
<p>Spring Batch适用于以下典型场景：</p>






























<table><thead><tr><th>场景</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>数据迁移</td><td>跨系统数据同步</td><td>从旧系统迁移数据到新系统</td></tr><tr><td>数据转换</td><td>ETL过程</td><td>从数据库读取、转换、写入数据仓库</td></tr><tr><td>批量处理</td><td>定期批量操作</td><td>月底工资代发、银行对账</td></tr><tr><td>报表生成</td><td>定期生成报表</td><td>每日交易汇总报表</td></tr></tbody></table>
<h4 data-id="heading-9">1.4 与其他框架对比</h4>









































<table><thead><tr><th>特性</th><th>Spring Batch</th><th>Quartz</th><th>Scheduled Executor</th></tr></thead><tbody><tr><td>批量处理</td><td>✅ 专用</td><td>需要</td><td>需要</td></tr><tr><td>事务管理</td><td>✅ 内置</td><td>无</td><td>无</td></tr><tr><td>容错机制</td><td>✅ 完善的Skip/Retry</td><td>无</td><td>无</td></tr><tr><td>监控统计</td><td>✅ 数据库持久化</td><td>基础</td><td>无</td></tr><tr><td>并行处理</td><td>✅ 多种模式</td><td>无</td><td>基础</td></tr></tbody></table>
<p><strong>为什么需要部分回滚？</strong></p>
<p>想象一下：你需要处理50万笔工资代发，如果第49万笔记录因为银行卡号错误而失败，在没有部分回滚机制的情况下，前面489,999笔已成功处理的数据会全部回滚！这对于业务来说是不可接受的。</p>
<hr/>
<h3 data-id="heading-10">二、系统架构设计</h3>
<p>为了实现50万笔工资代发的高效处理，我们设计了如下的系统架构：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/bcd00eb304e3405bba04e396f8f17e3a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=6U7zJ6OTXz6gkHUmSzFWbDGsk6w%3D" alt="" loading="lazy"/></p>
<p>上图展示了Spring Batch工资代发系统的分层架构：</p>
<ul>
<li><strong>Web层</strong>：提供监控面板，支持Job启动/停止、实时状态监控和统计信息查询</li>
<li><strong>Batch控制层</strong>：REST API接口，包含JobLauncher和JobRepository</li>
<li><strong>Spring Batch核心层</strong>：Job→Step→Chunk的处理流程，包含Reader、Processor、Writer三大组件</li>
<li><strong>数据存储层</strong>：MySQL数据库、CSV文件和Job执行日志</li>
</ul>
<h4 data-id="heading-11">2.1 核心组件说明</h4>



































<table><thead><tr><th>组件</th><th>职责</th><th>实现类</th></tr></thead><tbody><tr><td>Job</td><td>整个批处理任务</td><td>SalaryPaymentJob</td></tr><tr><td>Step</td><td>任务中的一个步骤</td><td>SalaryPaymentStep</td></tr><tr><td>ItemReader</td><td>数据读取器</td><td>FlatFileItemReader（读取CSV）</td></tr><tr><td>ItemProcessor</td><td>数据处理器</td><td>SalaryPaymentProcessor（数据验证）</td></tr><tr><td>ItemWriter</td><td>数据写入器</td><td>JdbcBatchItemWriter（批量写入数据库）</td></tr></tbody></table>
<hr/>
<h3 data-id="heading-12">三、部分回滚机制原理</h3>
<h4 data-id="heading-13">3.1 Chunk-Oriented Processing</h4>
<p>Spring Batch采用**Chunk-Oriented Processing（块级处理）**模式，这是实现部分回滚的核心机制：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d084688d1ebe463c9652b1ba0d53c668~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=UuFoHlDwgOOpU%2FXE5sMRjhtTvc8%3D" alt="" loading="lazy"/></p>
<p>上图展示了Batch处理的核心流程：Reader读取数据 → Processor处理验证 → Writer批量写入，形成完整的处理管道。</p>
<p>对于50万笔数据的处理，Chunk机制的工作方式如下：</p>
<pre><code class="hljs language-scss" lang="scss"><span class="hljs-number">50</span>万笔数据
    │
    ├─► Chunk <span class="hljs-number">1</span> (<span class="hljs-number">1</span>-<span class="hljs-number">1000</span>笔)   ──► 独立事务 ──► 成功提交
    ├─► Chunk <span class="hljs-number">2</span> (<span class="hljs-number">1001</span>-<span class="hljs-number">2000</span>笔) ──► 独立事务 ──► 成功提交
    ├─► Chunk <span class="hljs-number">3</span> (<span class="hljs-number">2001</span>-<span class="hljs-number">3000</span>笔) ──► 独立事务 ──► 第<span class="hljs-number">2500</span>笔失败 → 重试<span class="hljs-number">3</span>次 → 跳过 → 其余<span class="hljs-number">999</span>笔提交
    ├─► Chunk <span class="hljs-number">4</span> (<span class="hljs-number">3001</span>-<span class="hljs-number">4000</span>笔) ──► 独立事务 ──► 成功提交
    ...
    └─► Chunk <span class="hljs-number">500</span> (<span class="hljs-number">499001</span>-<span class="hljs-number">500000</span>笔) ──► 独立事务 ──► 成功提交

最终结果：<span class="hljs-number">499</span>,<span class="hljs-number">999</span>笔成功，<span class="hljs-number">1</span>笔被跳过
</code></pre>
<p><strong>关键配置：</strong></p>
<ul>
<li><strong>chunkSize</strong>: 1000（每1000笔提交一次）</li>
<li><strong>skipLimit</strong>: 100（最多跳过100笔失败记录）</li>
<li><strong>retryLimit</strong>: 3（每笔失败重试3次）</li>
</ul>
<h4 data-id="heading-14">3.2 事务边界与部分回滚</h4>
<p>每个Chunk是独立的事务单元，这是实现部分回滚的关键：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a3cadc7def044954ab96efb3b4f174c1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=tDesgDqGrq9SQu7Kbxsq%2FXq2ljQ%3D" alt="" loading="lazy"/></p>
<p>上图清晰地展示了事务边界和部分回滚的工作机制：</p>
<p><strong>事务规则：</strong></p>
<ul>
<li>Chunk内任意记录失败 → 整个Chunk回滚</li>
<li>重试成功 → 继续处理</li>
<li>重试失败且可跳过 → 跳过该记录，继续处理Chunk内剩余记录</li>
<li>跳过次数超限 → 整个Job失败</li>
</ul>
<p><strong>实际案例：</strong>
假设Chunk 3中有1000笔数据，第500笔验证失败：</p>
<ol>
<li>Spring Batch回滚整个Chunk 3</li>
<li>重新读取Chunk 3的1000笔数据</li>
<li>处理到第500笔时，捕获异常</li>
<li>重试3次后仍然失败</li>
<li>检查是否可跳过（IllegalArgumentException在跳过列表中）</li>
<li>跳过第500笔，继续处理501-1000笔</li>
<li>最终Chunk 3成功提交999笔，1笔被跳过</li>
</ol>
<h4 data-id="heading-15">3.3 容错策略配置</h4>
<pre><code class="hljs language-java" lang="java">.faultTolerant()                    <span class="hljs-comment">// 启用容错</span>
    .skipLimit(<span class="hljs-number">100</span>)                 <span class="hljs-comment">// 最多跳过100条</span>
    .skip(IllegalArgumentException.class)    <span class="hljs-comment">// 跳过数据验证异常</span>
    .skip(NullPointerException.class)        <span class="hljs-comment">// 跳过空指针异常</span>
    .retryLimit(<span class="hljs-number">3</span>)                  <span class="hljs-comment">// 失败重试3次</span>
    .retry(Exception.class)         <span class="hljs-comment">// 重试所有异常</span>
</code></pre>
<hr/>
<h3 data-id="heading-16">四、50万笔工资代发数据处理流程</h3>
<p>在理解了部分回滚机制后，我们来看完整的工资代发数据处理流程：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/d8b9318892e8425abf7d289b608db5bc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=SIsXxsWk3rb%2BjcCk4aE465G5rXg%3D" alt="" loading="lazy"/></p>
<p>上图展示了从CSV文件读取到数据库写入的完整数据流，包含以下关键步骤：</p>
<ol>
<li><strong>数据读取</strong>：FlatFileItemReader读取CSV文件，每行映射为SalaryPayment对象</li>
<li><strong>数据验证</strong>：SalaryPaymentProcessor进行数据校验
<ul>
<li>员工ID非空验证</li>
<li>金额范围验证（0.01-100万）</li>
<li>银行卡号格式验证（16-19位数字）</li>
</ul>
</li>
<li><strong>状态更新</strong>：设置状态为PROCESSING，生成唯一交易ID</li>
<li><strong>批量写入</strong>：JdbcBatchItemWriter批量写入数据库</li>
<li><strong>异常处理</strong>：验证失败的记录被跳过，记录到失败列表</li>
</ol>
<hr/>
<h3 data-id="heading-17">五、核心代码实现</h3>
<h4 data-id="heading-18">5.1 Job配置</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SalaryPaymentJobConfig</span> {

    <span class="hljs-meta">@Value("${batch.chunk.size:1000}")</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> chunkSize;  <span class="hljs-comment">// 每次处理的记录数</span>

    <span class="hljs-meta">@Value("${batch.skip.limit:100}")</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> skipLimit;  <span class="hljs-comment">// 跳过限制</span>

    <span class="hljs-meta">@Value("${batch.retry.limit:3}")</span>
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> retryLimit; <span class="hljs-comment">// 重试次数</span>

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Step <span class="hljs-title function_">salaryPaymentStep</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> stepBuilderFactory
            .get(<span class="hljs-string">"salaryPaymentStep"</span>)
            .&lt;SalaryPayment, SalaryPayment&gt;chunk(chunkSize)
            .reader(salaryPaymentReader())
            .processor(salaryPaymentProcessor())
            .writer(salaryPaymentWriter())
            .faultTolerant()  <span class="hljs-comment">// 启用容错</span>
            .skipLimit(skipLimit)
            .skip(IllegalArgumentException.class)
            .skip(NullPointerException.class)
            .retryLimit(retryLimit)
            .retry(Exception.class)
            .listener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SalaryItemReadListener</span>())
            .listener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SalaryItemWriteListener</span>())
            .build();
    }

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Job <span class="hljs-title function_">salaryPaymentJob</span><span class="hljs-params">(Step step, SalaryJobExecutionListener listener)</span> {
        <span class="hljs-keyword">return</span> jobBuilderFactory.get(<span class="hljs-string">"salaryPaymentJob"</span>)
            .incrementer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RunIdIncrementer</span>())
            .listener(listener)
            .start(step)
            .build();
    }
}
</code></pre>
<h4 data-id="heading-19">5.2 数据读取器</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> FlatFileItemReader&lt;SalaryPayment&gt; <span class="hljs-title function_">salaryPaymentReader</span><span class="hljs-params">()</span> {
    FlatFileItemReader&lt;SalaryPayment&gt; reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlatFileItemReader</span>&lt;&gt;();
    reader.setName(<span class="hljs-string">"salaryPaymentReader"</span>);
    reader.setResource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">"input/salary-payments.csv"</span>));
    reader.setLinesToSkip(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 跳过CSV标题行</span>

    <span class="hljs-comment">// 设置列映射</span>
    <span class="hljs-type">DelimitedLineTokenizer</span> <span class="hljs-variable">tokenizer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelimitedLineTokenizer</span>();
    tokenizer.setNames(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]{
        <span class="hljs-string">"employeeId"</span>, <span class="hljs-string">"employeeName"</span>, <span class="hljs-string">"accountNumber"</span>,
        <span class="hljs-string">"accountName"</span>, <span class="hljs-string">"bankName"</span>, <span class="hljs-string">"amount"</span>, <span class="hljs-string">"currency"</span>,
        <span class="hljs-string">"paymentDate"</span>, <span class="hljs-string">"remark"</span>
    });

    <span class="hljs-comment">// 设置字段映射</span>
    BeanWrapperFieldSetMapper&lt;SalaryPayment&gt; mapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanWrapperFieldSetMapper</span>&lt;&gt;();
    mapper.setTargetType(SalaryPayment.class);

    DefaultLineMapper&lt;SalaryPayment&gt; lineMapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultLineMapper</span>&lt;&gt;();
    lineMapper.setLineTokenizer(tokenizer);
    lineMapper.setFieldSetMapper(mapper);
    reader.setLineMapper(lineMapper);

    <span class="hljs-keyword">return</span> reader;
}
</code></pre>
<h4 data-id="heading-20">5.3 数据处理器（验证逻辑）</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SalaryPaymentProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ItemProcessor</span>&lt;SalaryPayment, SalaryPayment&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">MIN_AMOUNT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"0.01"</span>);
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">MAX_AMOUNT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">"1000000"</span>);

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> SalaryPayment <span class="hljs-title function_">process</span><span class="hljs-params">(SalaryPayment item)</span> <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-comment">// 1. 数据验证</span>
        <span class="hljs-keyword">if</span> (item.getEmployeeId() == <span class="hljs-literal">null</span> || item.getEmployeeId().trim().isEmpty()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"员工ID不能为空"</span>);
        }

        <span class="hljs-comment">// 2. 金额验证</span>
        <span class="hljs-keyword">if</span> (item.getAmount() == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"发放金额不能为空"</span>);
        }
        <span class="hljs-keyword">if</span> (item.getAmount().compareTo(MIN_AMOUNT) &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"发放金额不能小于0.01元"</span>);
        }
        <span class="hljs-keyword">if</span> (item.getAmount().compareTo(MAX_AMOUNT) &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"发放金额不能大于100万元"</span>);
        }

        <span class="hljs-comment">// 3. 银行卡号验证</span>
        <span class="hljs-keyword">if</span> (item.getAccountNumber() == <span class="hljs-literal">null</span> ||
            item.getAccountNumber().length() &lt; <span class="hljs-number">16</span> ||
            item.getAccountNumber().length() &gt; <span class="hljs-number">19</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">"银行账号长度必须在16-19位之间"</span>);
        }

        <span class="hljs-comment">// 4. 设置处理状态</span>
        item.setStatus(<span class="hljs-string">"PROCESSING"</span>);
        item.setTransactionId(<span class="hljs-string">"SAL"</span> + System.currentTimeMillis() + item.getEmployeeId());

        <span class="hljs-keyword">return</span> item;
    }
}
</code></pre>
<h4 data-id="heading-21">5.4 数据写入器</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SalaryPaymentWriter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ItemWriter</span>&lt;SalaryPayment&gt; {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JdbcBatchItemWriter&lt;SalaryPayment&gt; delegate;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SalaryPaymentWriter</span><span class="hljs-params">(DataSource dataSource)</span> {
        <span class="hljs-built_in">this</span>.delegate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcBatchItemWriter</span>&lt;&gt;();
        <span class="hljs-built_in">this</span>.delegate.setDataSource(dataSource);
        <span class="hljs-built_in">this</span>.delegate.setSql(
            <span class="hljs-string">"INSERT INTO salary_payment "</span> +
            <span class="hljs-string">"(employee_id, employee_name, account_number, account_name, "</span> +
            <span class="hljs-string">"bank_name, amount, currency, payment_date, remark, "</span> +
            <span class="hljs-string">"status, transaction_id, create_time, update_time) "</span> +
            <span class="hljs-string">"VALUES (:employeeId, :employeeName, :accountNumber, :accountName, "</span> +
            <span class="hljs-string">":bankName, :amount, :currency, :paymentDate, :remark, "</span> +
            <span class="hljs-string">":status, :transactionId, :createTime, :updateTime)"</span>);
        <span class="hljs-built_in">this</span>.delegate.setItemSqlParameterSourceProvider(
            <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanPropertyItemSqlParameterSourceProvider</span>&lt;&gt;()
        );
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(List&lt;? extends SalaryPayment&gt; items)</span> <span class="hljs-keyword">throws</span> Exception {
        delegate.write(items);
    }
}
</code></pre>
<h4 data-id="heading-22">5.5 自定义SkipPolicy</h4>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PartialRollbackHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SkipPolicy</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SKIP_LIMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldSkip</span><span class="hljs-params">(Throwable throwable, <span class="hljs-type">int</span> skipCount)</span> {
        <span class="hljs-comment">// 超过跳过限制</span>
        <span class="hljs-keyword">if</span> (skipCount &gt;= SKIP_LIMIT) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// 文件不存在，不能跳过</span>
        <span class="hljs-keyword">if</span> (throwable <span class="hljs-keyword">instanceof</span> FileNotFoundException) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-comment">// 数据格式错误，可以跳过</span>
        <span class="hljs-keyword">if</span> (throwable <span class="hljs-keyword">instanceof</span> FlatFileParseException) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-comment">// 数据验证失败，可以跳过</span>
        <span class="hljs-keyword">if</span> (throwable <span class="hljs-keyword">instanceof</span> IllegalArgumentException ||
            throwable <span class="hljs-keyword">instanceof</span> NullPointerException) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-23">六、监控与调度架构</h3>
<p>除了数据处理，Spring Batch还提供了完善的监控和调度能力：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/75d4b1910c2744e1ae48875ce1ce6e31~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=6ByRneA25pJ%2BsYmXWs9B49dsOdQ%3D" alt="" loading="lazy"/></p>
<p>上图展示了完整的监控与调度架构：</p>
<p><strong>调度层</strong>：支持三种调度方式</p>
<ul>
<li>Quartz调度器：支持分布式调度，适合集群环境</li>
<li>Spring Task调度：简单的定时任务，轻量级选择</li>
<li>Cron表达式：灵活的时间配置</li>
</ul>
<p><strong>执行层</strong>：核心执行组件</p>
<ul>
<li>JobLauncher：启动作业，创建执行上下文</li>
<li>JobOperator：操作作业，支持停止/重启/重试</li>
<li>StepExecution：步骤执行，采用Chunk处理模式</li>
<li>ThreadPoolExecutor：线程池，实现并发处理</li>
</ul>
<p><strong>监控层</strong>：监控与统计</p>
<ul>
<li>JobRepository：存储元数据（BATCH_JOB_INSTANCE、BATCH_JOB_EXECUTION、BATCH_STEP_EXECUTION）</li>
<li>JobExplorer：查询作业状态、获取执行历史</li>
<li>Metrics：处理记录数、执行时间、失败率统计</li>
</ul>
<p><strong>数据层</strong>：数据存储</p>
<ul>
<li>MySQL 8.0：存储元数据表、业务数据表、日志记录</li>
<li>Redis缓存：执行状态缓存、计数器、分布式锁</li>
</ul>
<hr/>
<h3 data-id="heading-24">七、数据库设计</h3>
<h4 data-id="heading-25">7.1 工资代发表</h4>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> salary_payment (
    id <span class="hljs-type">BIGINT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,
    employee_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'员工ID'</span>,
    employee_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'员工姓名'</span>,
    account_number <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'银行账号'</span>,
    account_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'账户名称'</span>,
    bank_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'开户行'</span>,
    amount <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">18</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'发放金额'</span>,
    currency <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'CNY'</span> COMMENT <span class="hljs-string">'币种'</span>,
    payment_date DATETIME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">'发放日期'</span>,
    remark <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">500</span>) COMMENT <span class="hljs-string">'备注'</span>,
    status <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">'PENDING'</span> COMMENT <span class="hljs-string">'状态'</span>,
    transaction_id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) COMMENT <span class="hljs-string">'交易ID'</span>,
    error_message <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">1000</span>) COMMENT <span class="hljs-string">'错误信息'</span>,
    create_time DATETIME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,
    update_time DATETIME <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,
    INDEX idx_employee_id (employee_id),
    INDEX idx_status (status)
) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4;
</code></pre>
<h4 data-id="heading-26">7.2 Spring Batch元表</h4>
<p>Spring Batch框架会自动创建以下元表来存储Job执行信息：</p>
<ul>
<li><code>batch_job_instance</code> - Job实例表</li>
<li><code>batch_job_execution</code> - Job执行表</li>
<li><code>batch_job_execution_params</code> - Job参数表</li>
<li><code>batch_step_execution</code> - Step执行表</li>
<li><code>batch_step_execution_context</code> - Step上下文表</li>
</ul>
<hr/>
<h3 data-id="heading-27">八、REST API设计</h3>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping("/api/batch")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchJobController</span> {

    <span class="hljs-comment">// 启动Job</span>
    <span class="hljs-meta">@PostMapping("/start")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">startJob</span><span class="hljs-params">(
        <span class="hljs-meta">@RequestParam</span> String inputFile
    )</span> {
        <span class="hljs-type">JobParameters</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JobParametersBuilder</span>()
            .addLong(<span class="hljs-string">"startTime"</span>, System.currentTimeMillis())
            .addString(<span class="hljs-string">"inputFile"</span>, inputFile)
            .toJobParameters();
        <span class="hljs-type">JobExecution</span> <span class="hljs-variable">execution</span> <span class="hljs-operator">=</span> jobLauncher.run(salaryPaymentJob, params);
        <span class="hljs-keyword">return</span> ResponseEntity.ok(result);
    }

    <span class="hljs-comment">// 获取Job状态</span>
    <span class="hljs-meta">@GetMapping("/status/{jobExecutionId}")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">getJobStatus</span><span class="hljs-params">(
        <span class="hljs-meta">@PathVariable</span> Long jobExecutionId
    )</span> {
        <span class="hljs-type">JobExecution</span> <span class="hljs-variable">execution</span> <span class="hljs-operator">=</span> jobRepository.getJobExecution(jobExecutionId);
        <span class="hljs-comment">// 返回执行详情</span>
    }

    <span class="hljs-comment">// 停止Job</span>
    <span class="hljs-meta">@PostMapping("/stop/{jobExecutionId}")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">stopJob</span><span class="hljs-params">(
        <span class="hljs-meta">@PathVariable</span> Long jobExecutionId
    )</span> {
        <span class="hljs-type">JobExecution</span> <span class="hljs-variable">execution</span> <span class="hljs-operator">=</span> jobRepository.getJobExecution(jobExecutionId);
        execution.stop();
        <span class="hljs-keyword">return</span> ResponseEntity.ok(result);
    }

    <span class="hljs-comment">// 获取统计信息</span>
    <span class="hljs-meta">@GetMapping("/statistics")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">getStatistics</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 返回总数、成功数、失败数等统计</span>
    }

    <span class="hljs-comment">// 健康检查</span>
    <span class="hljs-meta">@GetMapping("/health")</span>
    <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="hljs-title function_">health</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 返回系统健康状态</span>
    }
}
</code></pre>
<hr/>
<h3 data-id="heading-28">九、性能优化与并行处理</h3>
<p>当数据量达到50万甚至更多时，单线程处理可能成为瓶颈。Spring Batch提供了多种并行处理方式。</p>
<h4 data-id="heading-29">9.1 多线程并发处理</h4>
<p>Spring Batch支持多线程并发处理，大幅提升处理效率：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/316e23bab05d4fe596fe18021513b6c8~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=0BkUFvIWBtjJgwbQoXjOKq2s7MQ%3D" alt="" loading="lazy"/></p>
<p>上图展示了多线程并发处理的工作原理：</p>
<p><strong>核心机制：</strong></p>
<ul>
<li><strong>主线程</strong>：创建线程池，分配任务</li>
<li><strong>工作线程</strong>：并发执行多个Step或Chunk</li>
<li><strong>线程安全</strong>：JobRepository保证线程安全的状态管理</li>
<li><strong>负载均衡</strong>：任务均匀分配到各个线程</li>
</ul>
<p><strong>配置示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title function_">taskExecutor</span><span class="hljs-params">()</span> {
    <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();
    executor.setCorePoolSize(<span class="hljs-number">5</span>);
    executor.setMaxPoolSize(<span class="hljs-number">10</span>);
    executor.setQueueCapacity(<span class="hljs-number">100</span>);
    executor.setThreadNamePrefix(<span class="hljs-string">"salary-batch-"</span>);
    executor.initialize();
    <span class="hljs-keyword">return</span> executor;
}

<span class="hljs-comment">// 在Step中使用</span>
.step(stepName)
.chunk(chunkSize)
.taskExecutor(taskExecutor())
.throttleLimit(<span class="hljs-number">10</span>)  <span class="hljs-comment">// 限制并发数</span>
.build();
</code></pre>
<h4 data-id="heading-30">9.2 分区处理（Partitioning）</h4>
<p>对于超大数据集，可以使用分区处理实现更高程度的并行：</p>
<p><img src="https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f2a8815f01144f197a00ba5ad2c0802~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg6Zuo5Lit6aOY6I2h55qE6K6w5b-G:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771026268&amp;x-signature=9I%2BjxPUBFL%2B5Vi3qT9oI4Xub9sM%3D" alt="" loading="lazy"/></p>
<p>上图展示了分区处理的架构：</p>
<p><strong>核心组件：</strong></p>
<ul>
<li><strong>Master Step</strong>：负责创建和管理分区</li>
<li><strong>Slave Step</strong>：每个分区独立执行</li>
<li><strong>Partitioner</strong>：将数据分成多个分区</li>
<li><strong>TaskExecutor</strong>：线程池执行分区任务</li>
</ul>
<p><strong>配置示例：</strong></p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Step <span class="hljs-title function_">masterStep</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> stepBuilderFactory.get(<span class="hljs-string">"masterStep"</span>)
        .partitioner(slaveStep().getName(), rangePartitioner(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))
        .step(slaveStep())
        .gridSize(<span class="hljs-number">10</span>)  <span class="hljs-comment">// 分成10个分区</span>
        .taskExecutor(taskExecutor())
        .build();
}

<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Partitioner <span class="hljs-title function_">rangePartitioner</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Partitioner</span>() {
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Map&lt;String, ExecutionContext&gt; <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> gridSize)</span> {
            Map&lt;String, ExecutionContext&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
            <span class="hljs-type">int</span> <span class="hljs-variable">range</span> <span class="hljs-operator">=</span> (max - min) / gridSize;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; gridSize; i++) {
                <span class="hljs-type">ExecutionContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionContext</span>();
                context.putInt(<span class="hljs-string">"minValue"</span>, min + i * range);
                context.putInt(<span class="hljs-string">"maxValue"</span>, min + (i + <span class="hljs-number">1</span>) * range - <span class="hljs-number">1</span>);
                result.put(<span class="hljs-string">"partition"</span> + i, context);
            }
            <span class="hljs-keyword">return</span> result;
        }
    };
}
</code></pre>
<h4 data-id="heading-31">9.3 调优参数</h4>






























<table><thead><tr><th>参数</th><th>推荐值</th><th>说明</th></tr></thead><tbody><tr><td>chunkSize</td><td>1000-5000</td><td>根据记录大小调整，越大吞吐量越高但内存占用也越大</td></tr><tr><td>skipLimit</td><td>100-500</td><td>根据数据质量设置</td></tr><tr><td>retryLimit</td><td>3-5</td><td>过多会浪费时间，过少可能误判暂时性故障</td></tr><tr><td>线程池大小</td><td>CPU核心数*2</td><td>用于多线程处理</td></tr></tbody></table>
<h4 data-id="heading-32">9.4 批量写入优化</h4>
<p>使用JDBC批量操作代替单条插入：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-comment">// 单条插入（慢）</span>
<span class="hljs-keyword">for</span> (SalaryPayment p : payments) {
    jdbcTemplate.update(sql, p.getId(), p.getName(), ...);
}

<span class="hljs-comment">// 批量插入（快）</span>
jdbcTemplate.batchUpdate(sql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchPreparedStatementSetter</span>() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValues</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException {
        <span class="hljs-comment">// 设置参数</span>
    }
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBatchSize</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> payments.size();
    }
});
</code></pre>
<h4 data-id="heading-33">9.5 索引优化</h4>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-comment">-- 为常用查询字段添加索引</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_employee_id <span class="hljs-keyword">ON</span> salary_payment(employee_id);
<span class="hljs-keyword">CREATE</span> INDEX idx_status <span class="hljs-keyword">ON</span> salary_payment(status);
<span class="hljs-keyword">CREATE</span> INDEX idx_create_time <span class="hljs-keyword">ON</span> salary_payment(create_time);

<span class="hljs-comment">-- 复合索引</span>
<span class="hljs-keyword">CREATE</span> INDEX idx_status_employee <span class="hljs-keyword">ON</span> salary_payment(status, employee_id);
</code></pre>
<hr/>
<h3 data-id="heading-34">十、实际应用场景</h3>
<h4 data-id="heading-35">场景1：月底工资代发</h4>
<p>某公司月底需要为50,000名员工发放工资，使用Spring Batch：</p>
<ul>
<li>设置chunkSize=1000，分成50个Chunk处理</li>
<li>假设第23个Chunk中第23,456号员工银行卡号错误</li>
<li>系统重试3次后跳过该记录</li>
<li>最终结果：49,999笔成功，1笔记录到失败列表供后续处理</li>
</ul>
<h4 data-id="heading-36">场景2：银行对账文件处理</h4>
<p>银行提供100万笔交易对账文件：</p>
<ul>
<li>设置chunkSize=5000，提高处理效率</li>
<li>使用多线程并发处理（Partitioning）</li>
<li>完成后生成对账差异报告</li>
</ul>
<h4 data-id="heading-37">场景3：数据报表生成</h4>
<p>每天凌晨生成T+1交易报表：</p>
<ul>
<li>使用Spring Task定时调度</li>
<li>读取当日交易数据</li>
<li>生成Excel报表并发送邮件</li>
</ul>
<hr/>
<h3 data-id="heading-38">十一、常见问题与解决方案</h3>
<h4 data-id="heading-39">Q1: Job执行一半挂了怎么办？</h4>
<p>Spring Batch支持Job重启。通过JobRepository记录的执行状态，可以从上次失败的位置继续执行：</p>
<pre><code class="hljs language-java" lang="java">.job(salaryPaymentJob)
    .allowStartIfComplete(<span class="hljs-literal">false</span>)  <span class="hljs-comment">// 已完成的Job不重新执行</span>
    .restartable(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// 允许重启</span>
</code></pre>
<h4 data-id="heading-40">Q2: 如何实现并行处理？</h4>
<p>使用Partitioning方式实现多线程并行处理：</p>
<pre><code class="hljs language-java" lang="java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Step <span class="hljs-title function_">masterStep</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> stepBuilderFactory.get(<span class="hljs-string">"masterStep"</span>)
        .partitioner(slaveStep().getName(), partitioner())
        .step(slaveStep())
        .gridSize(<span class="hljs-number">10</span>)  <span class="hljs-comment">// 分成10个分区并行处理</span>
        .taskExecutor(taskExecutor())
        .build();
}
</code></pre>
<h4 data-id="heading-41">Q3: 处理失败的数据如何重试？</h4>
<p>可以通过以下方式重试：</p>
<ol>
<li>查询status='FAILED'的记录</li>
<li>修正错误数据</li>
<li>将status改回'PENDING'</li>
<li>重新执行Job</li>
</ol>
<hr/>
<h3 data-id="heading-42">十二、总结</h3>
<p>Spring Batch作为成熟的批处理框架，提供了完整的解决方案来处理大规模批量数据。</p>
<p><strong>适用场景：</strong></p>
<ul>
<li>银行对账、清算</li>
<li>工资代发、批量转账</li>
<li>报表生成、数据导出</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>合理设置chunkSize，平衡内存和性能</li>
<li>配置合适的Skip和Retry策略</li>
<li>做好失败记录的重处理机制</li>
<li>定期清理Job执行历史数据</li>
</ul>
<hr/></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[虚拟列表：从定高到动态高度的 Vue 3 & React 满分实现]]></title>    <link>https://juejin.cn/post/7603591775392251931</link>    <guid>https://juejin.cn/post/7603591775392251931</guid>    <pubDate>2026-02-07T03:49:36.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603591775392251931" data-draft-id="7603359026711969802" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="虚拟列表：从定高到动态高度的 Vue 3 &amp; React 满分实现"/> <meta itemprop="keywords" content="前端,Vue.js,React.js"/> <meta itemprop="datePublished" content="2026-02-07T03:49:36.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="发现一只大呆瓜"/> <meta itemprop="url" content="https://juejin.cn/user/180747382561607"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            虚拟列表：从定高到动态高度的 Vue 3 &amp; React 满分实现
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/180747382561607/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    发现一只大呆瓜
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T03:49:36.000Z" title="Sat Feb 07 2026 03:49:36 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">前言</h3>
<p>在处理海量数据渲染（如万级甚至十万级列表）时，直接操作 DOM 会导致严重的页面卡顿甚至崩溃。<strong>虚拟列表（Virtual List）</strong> 作为前端性能优化的“核武器”，通过“只渲染可视区”的策略，能将渲染性能提升数个量级。本文将带你从零实现一个支持<strong>动态高度</strong>的通用虚拟列表。</p>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0aeb589869424d08be07ff8183e5af9e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771040975&amp;x-signature=83d1HWo%2Fzcfl0pbpVr8sTUG%2Bd4g%3D" alt="定高虚拟列表滚动.gif" loading="lazy"/></p>
<h2 data-id="heading-1">一、 核心原理解析</h2>
<p>虚拟列表本质上是一个“障眼法”，其结构通常分为三层：</p>
<ol>
<li><strong>外层容器（Container）</strong> ：固定高度，设置 <code>overflow: auto</code>，负责监听滚动事件。</li>
<li><strong>占位背景（Placeholder）</strong> ：高度等于“总数据量 × 列表项高度”，用于撑开滚动条，模拟真实滚动的视觉效果。</li>
<li><strong>渲染内容区（Content Area）</strong> ：绝对定位，根据滚动距离动态计算起始索引，并通过 <code>translateY</code> 偏移到当前可视区域。</li>
</ol>
<p align="center"><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/35758c5b480e4fd4ae543f60afd26730~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771040975&amp;x-signature=gm9VzHaAFCGyUyiSagfZbbWktEk%3D" alt="image.png" width="60%" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-2">二、 定高虚拟列表</h2>
<h3 data-id="heading-3">1. 设计思路</h3>
<ul>
<li><strong>可视项数计算</strong>：<code>Math.ceil(容器高度 / 固定高度) ± 缓冲区 (BUFFER)</code>。</li>
<li><strong>起始索引</strong>：<code>Math.floor(滚动距离 / 固定高度)</code>。</li>
<li><strong>偏移量</strong>：<code>起始索引 * 固定高度</code>。</li>
</ul>
<h3 data-id="heading-4">2. Vue 3 + TailwindCSS实现</h3>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div
    class="min-h-screen bg-gradient-to-br from-indigo-600 to-purple-600 py-10 px-5"
  &gt;
    &lt;div class="bg-white mt-20 h-[calc(100vh-200px)] rounded-xl"&gt;
      &lt;!-- 滚动容器 --&gt;
      &lt;div
        ref="virtualListRef"
        class="h-full overflow-auto relative"
        @scroll="handleScroll"
      &gt;
        &lt;!-- 占位容器：用于撑开滚动条，高度 = 总数据量 * 每项高度 --&gt;
        &lt;div :style="{ height: `${totalHeight}px` }"&gt;&lt;/div&gt;

        &lt;!-- 可视区域列表：通过 transform 定位到滚动位置 --&gt;
        &lt;div
          class="absolute top-0 left-0 right-0"
          :style="{ transform: `translateY(${offsetY}px)` }"
        &gt;
          &lt;div
            v-for="item in visibleList"
            :key="item.id"
            class="py-2 px-4 border-b border-gray-200"
            :class="{
              'bg-pink-200 h-[100px]': item.id % 2 !== 0,
              'bg-green-200 h-[100px]': item.id % 2 === 0,
            }"
          &gt;
            {{ item.name }}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div
      class="fixed top-2 left-24 -translate-x-1/2 px-8 py-3 bg-white text-indigo-600 rounded-full text-base font-semibold cursor-pointer shadow-lg transition-all duration-300 hover:-translate-x-1/2 hover:-translate-y-0.5 hover:shadow-2xl"
      @click="goBack"
    &gt;
      ← 返回首页
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted, computed } from 'vue';
import { useRouter } from 'vue-router';

const router = useRouter();

const ITEM_HEIGHT = 100; // 列表项固定高度（与样式中的 h-[100px] 一致）
const BUFFER = 5; // 缓冲区数量，避免滚动时出现空白

const virtualListRef = ref&lt;HTMLDivElement | null&gt;(null);

const ListData = ref&lt;any[]&gt;([]); // 完整列表数据
const scrollTop = ref(0); // 滚动容器的滚动距离

// 总列表高度（撑开滚动条用）
const totalHeight = computed(() =&gt; ListData.value.length * ITEM_HEIGHT);

// 可视区域高度（滚动容器的高度）
const viewportHeight = computed(() =&gt; {
  return virtualListRef.value?.clientHeight || 0;
});

// 可视区域可显示的列表项数量（向上取整 + 缓冲区）
const visibleCount = computed(() =&gt; {
  return Math.ceil(viewportHeight.value / ITEM_HEIGHT) + BUFFER;
});

// 当前显示的起始索引
const startIndex = computed(() =&gt; {
  // 滚动距离 / 每项高度 = 跳过的项数（向下取整）
  const index = Math.floor(scrollTop.value / ITEM_HEIGHT);
  // 防止索引为负数
  return Math.max(0, index);
});

// 当前显示的结束索引
const endIndex = computed(() =&gt; {
  const end = startIndex.value + visibleCount.value;
  // 防止超出总数据长度
  return Math.min(end, ListData.value.length);
});

// 可视区域需要渲染的列表数据
const visibleList = computed(() =&gt; {
  return ListData.value.slice(startIndex.value, endIndex.value);
});

// 可视区域的偏移量（让列表项定位到正确位置）
const offsetY = computed(() =&gt; {
  return startIndex.value * ITEM_HEIGHT;
});

// 处理滚动事件
const handleScroll = () =&gt; {
  if (virtualListRef.value) {
    scrollTop.value = virtualListRef.value.scrollTop;
  }
};

// 返回首页
const goBack = () =&gt; {
  router.push('/home');
};

// 初始化
onMounted(() =&gt; {
  // 生成模拟数据
  ListData.value = Array.from({ length: 1000 }, (_, index) =&gt; ({
    id: index,
    name: `Item ${index}`,
  }));
});
&lt;/script&gt;

</code></pre>
<h3 data-id="heading-5">3. 实现效果图</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0aeb589869424d08be07ff8183e5af9e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771040975&amp;x-signature=83d1HWo%2Fzcfl0pbpVr8sTUG%2Bd4g%3D" alt="定高虚拟列表滚动.gif" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-6">三、 进阶：不定高（动态高度）虚拟列表</h2>
<p>在实际业务（如社交动态、聊天记录）中，每个 Item 的高度往往是不固定的。</p>
<h3 data-id="heading-7">1. 核心改进思路</h3>
<ul>
<li><strong>高度映射表（Map）</strong> ：记录每一个 Item 渲染后的真实高度。</li>
<li><strong>累计高度数组（Cumulative Heights）</strong> ：存储每一项相对于顶部的偏移位置。</li>
<li><strong>ResizeObserver</strong>：利用该 API 监听子组件高度变化，实时更新映射表，解决图片加载或文本折行导致的位移。</li>
</ul>
<h3 data-id="heading-8">2. Vue 3 + tailwindCSS 实现（子组件抽离）</h3>
<p><strong>子组件</strong>： 负责上报真实高度：</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div
    ref="itemRef"
    class="py-2 px-4 border-b border-gray-200"
    :class="{
      'bg-pink-200': item.id % 2 !== 0,
      'bg-green-200': item.id % 2 === 0,
    }"
    :style="{ height: item.id % 2 === 0 ? '150px' : '100px' }"
  &gt;
    {{ item.name }}
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted, onUpdated, onUnmounted, watch, nextTick } from 'vue';

// 定义props：接收父组件传递的item数据
const props = defineProps&lt;{
  item: {
    id: number;
    name: string;
  };
}&gt;();

// 定义emit：向父组件传递高度更新事件
const emit = defineEmits&lt;{
  (e: 'update-height', id: number, height: number): void;
}&gt;();

const itemRef = ref&lt;HTMLDivElement | null&gt;(null);
let resizeObserver: ResizeObserver | null = null;

// 计算并发送当前组件的高度
const sendItemHeight = () =&gt; {
  if (!itemRef.value) return;
  const realHeight = itemRef.value.offsetHeight;
  emit('update-height', props.item.id, realHeight);
};

// 监听组件挂载：首次发送高度 + 监听高度变化
onMounted(() =&gt; {
  // 首次渲染完成后发送高度
  nextTick(() =&gt; {
    sendItemHeight();
  });

  // 监听元素高度变化（适配动态内容导致的高度变化）
  if (window.ResizeObserver) {
    resizeObserver = new ResizeObserver(() =&gt; {
      sendItemHeight();
    });
    if (itemRef.value) {
      resizeObserver.observe(itemRef.value);
    }
  }
});

// 组件更新后重新发送高度（比如内容变化）
onUpdated(() =&gt; {
  nextTick(() =&gt; {
    sendItemHeight();
  });
});

// 组件卸载：清理监听
onUnmounted(() =&gt; {
  if (resizeObserver) {
    resizeObserver.disconnect();
    resizeObserver = null;
  }
});

// 监听item变化：如果item替换，重新计算高度
watch(
  () =&gt; props.item.id,
  () =&gt; {
    nextTick(() =&gt; {
      sendItemHeight();
    });
  }
);
&lt;/script&gt;

</code></pre>
<p><strong>父组件</strong>：核心逻辑</p>
<pre><code class="hljs language-vue" lang="vue">&lt;template&gt;
  &lt;div
    class="min-h-screen bg-gradient-to-br from-indigo-600 to-purple-600 py-10 px-5"
  &gt;
    &lt;div class="bg-white mt-20 h-[calc(100vh-200px)] rounded-xl"&gt;
      &lt;!-- 滚动容器 --&gt;
      &lt;div
        ref="virtualListRef"
        class="h-full overflow-auto relative"
        @scroll="handleScroll"
      &gt;
        &lt;!-- 占位容器：撑开滚动条 --&gt;
        &lt;div :style="{ height: `${totalHeight}px` }"&gt;&lt;/div&gt;

        &lt;!-- 可视区域列表 --&gt;
        &lt;div
          class="absolute top-0 left-0 right-0"
          :style="{ transform: `translateY(${offsetY}px)` }"
        &gt;
          &lt;!-- 渲染子组件，监听高度更新事件 --&gt;
          &lt;VirtualListItem
            v-for="item in visibleList"
            :key="item.id"
            :item="item"
            @update-height="handleItemHeightUpdate"
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div
      class="fixed top-2 left-24 -translate-x-1/2 px-8 py-3 bg-white text-indigo-600 rounded-full text-base font-semibold cursor-pointer shadow-lg transition-all duration-300 hover:-translate-x-1/2 hover:-translate-y-0.5 hover:shadow-2xl"
      @click="goBack"
    &gt;
      ← 返回首页
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup lang="ts"&gt;
import { ref, onMounted, computed, onUnmounted, nextTick } from 'vue';
import { useRouter } from 'vue-router';
import VirtualListItem from './listItem.vue'; // 引入子组件

const router = useRouter();

const MIN_ITEM_HEIGHT = 100; // 子项预设的最小高度
const BUFFER = 5; //上下缓冲区数目
const virtualListRef = ref&lt;HTMLDivElement | null&gt;(null); // 滚动容器引用

const ListData = ref&lt;any[]&gt;([]); // 完整列表数据
const scrollTop = ref(0); // 滚动距离
const itemHeights = ref&lt;Map&lt;number, number&gt;&gt;(new Map()); // 子组件高度映射表
const cumulativeHeights = ref&lt;number[]&gt;([0]); // 累计高度数组
const scrollTimer = ref&lt;number | null&gt;(null); // 滚动节流定时器
const isUpdatingCumulative = ref(false); // 累计高度更新防抖

// 初始化位置数据
const initPositionData = () =&gt; {
  // 初始化高度映射表（默认最小高度）
  const heightMap = new Map&lt;number, number&gt;();
  ListData.value.forEach((item) =&gt; {
    heightMap.set(item.id, MIN_ITEM_HEIGHT);
  });
  // 初始化累计高度
  updateCumulativeHeights();
};

// 更新累计高度（核心）
const updateCumulativeHeights = () =&gt; {
  if (isUpdatingCumulative.value) return;
  isUpdatingCumulative.value = true;

  const itemCount = ListData.value.length;
  const cumulative = [0];
  let sum = 0;

  for (let i = 0; i &lt; itemCount; i++) {
    const itemId = ListData.value[i].id;
    sum += itemHeights.value.get(itemId) || MIN_ITEM_HEIGHT;
    cumulative.push(sum);
  }

  cumulativeHeights.value = cumulative;
  isUpdatingCumulative.value = false;
};

// 处理子组件的高度更新事件
const handleItemHeightUpdate = (id: number, height: number) =&gt; {
  // 高度未变化则跳过
  if (itemHeights.value.get(id) === height) return;

  // 更新高度映射表
  itemHeights.value.set(id, height);

  // 异步更新累计高度（避免同步更新导致的性能问题）
  nextTick(() =&gt; {
    updateCumulativeHeights();
  });
};

// 总高度，根据统计高度数组最后一个值计算得出
const totalHeight = computed(() =&gt; {
  return cumulativeHeights.value[cumulativeHeights.value.length - 1] || 0;
});

// 列表可视区域高度
const viewportHeight = computed(() =&gt; {
  return virtualListRef.value?.clientHeight || MIN_ITEM_HEIGHT * 5;
});

// 计算起始索引
const startIndex = computed(() =&gt; {
  const totalItemCount = ListData.value.length;
  if (totalItemCount === 0) return 0;
  if (scrollTop.value &lt;= 0) return 0;

  let baseStartIndex = 0;
  // 反向遍历找起始索引
  for (let i = cumulativeHeights.value.length - 1; i &gt;= 0; i--) {
    if (cumulativeHeights.value[i] &lt;= scrollTop.value) {
      baseStartIndex = i;
      break;
    }
  }
  const finalIndex = Math.max(0, baseStartIndex - BUFFER); // 确保不小于0
  return Math.min(finalIndex, totalItemCount - 1);
});

// 计算结束索引
const endIndex = computed(() =&gt; {
  const totalItemCount = ListData.value.length;
  const viewportHeightVal = viewportHeight.value;
  if (totalItemCount === 0) return 0;

  const targetScrollBottom = scrollTop.value + viewportHeightVal; // 目标滚动到底部位置
  let baseEndIndex = totalItemCount - 1;
  for (let i = 0; i &lt; cumulativeHeights.value.length; i++) {
    if (cumulativeHeights.value[i] &gt; targetScrollBottom) {
      baseEndIndex = i - 1;
      break;
    }
  }
  const finalEndIndex = Math.min(baseEndIndex + BUFFER, totalItemCount - 1); // 确保不大于总项数-1
  return finalEndIndex;
});

// 可见列表
const visibleList = computed(() =&gt; {
  const start = startIndex.value;
  const end = endIndex.value;
  return start &lt;= end ? ListData.value.slice(start, end + 1) : [];
});

const offsetY = computed(() =&gt; {
  return cumulativeHeights.value[startIndex.value] || 0;
});

// 滚动节流处理
const handleScroll = () =&gt; {
  if (!virtualListRef.value) return;

  if (scrollTimer.value) clearTimeout(scrollTimer.value);
  scrollTimer.value = window.setTimeout(() =&gt; {
    scrollTop.value = virtualListRef.value!.scrollTop;
  }, 20);
};

const handleResize = () =&gt; {
  if (virtualListRef.value) {
    scrollTop.value = virtualListRef.value.scrollTop;
  }
};

const goBack = () =&gt; {
  router.push('/home');
};

// 生命周期
onMounted(() =&gt; {
  // 生成模拟数据
  ListData.value = Array.from({ length: 1000 }, (_, index) =&gt; ({
    id: index,
    name: `Item ${index}`,
  }));
  initPositionData();
  window.addEventListener('resize', handleResize); // 监听窗口大小变化
});

onUnmounted(() =&gt; {
  window.removeEventListener('resize', handleResize);
  if (scrollTimer.value) clearTimeout(scrollTimer.value);
  isUpdatingCumulative.value = false;
  itemHeights.value.clear();
});
&lt;/script&gt;
</code></pre>
<h3 data-id="heading-9">3. React + tailwindCSS 实现（子组件抽离）</h3>
<p><strong>子组件：</strong></p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useEffect, useRef, useState, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">VirtualListItemProps</span> {
  <span class="hljs-attr">item</span>: {
    <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  };
  <span class="hljs-attr">onUpdateHeight</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">number</span>, height: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 替代 Vue 的 emit</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">VirtualListItem</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span>&lt;<span class="hljs-title class_">VirtualListItemProps</span>&gt; = <span class="hljs-function">(<span class="hljs-params">{
  item,
  onUpdateHeight,
}</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> itemRef = useRef&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;(<span class="hljs-literal">null</span>);
  <span class="hljs-comment">// 存储 ResizeObserver 实例（避免重复创建）</span>
  <span class="hljs-keyword">const</span> resizeObserverRef = useRef&lt;<span class="hljs-title class_">ResizeObserver</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);

  <span class="hljs-comment">// 计算并上报高度</span>
  <span class="hljs-keyword">const</span> sendItemHeight = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!itemRef.<span class="hljs-property">current</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">const</span> realHeight = itemRef.<span class="hljs-property">current</span>.<span class="hljs-property">offsetHeight</span>;
    <span class="hljs-title function_">onUpdateHeight</span>(item.<span class="hljs-property">id</span>, realHeight);
  }, [item.<span class="hljs-property">id</span>, onUpdateHeight]);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">sendItemHeight</span>();
    }, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// 初始化 ResizeObserver 监听高度变化</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">ResizeObserver</span>) {
      resizeObserverRef.<span class="hljs-property">current</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResizeObserver</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">sendItemHeight</span>();
      });
      <span class="hljs-keyword">if</span> (itemRef.<span class="hljs-property">current</span>) {
        resizeObserverRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">observe</span>(itemRef.<span class="hljs-property">current</span>);
      }
    }

    <span class="hljs-comment">// 清理定时器（对应 Vue 的 onUnmounted 部分）</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">clearTimeout</span>(timer);
      <span class="hljs-keyword">if</span> (resizeObserverRef.<span class="hljs-property">current</span>) {
        resizeObserverRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">disconnect</span>();
        resizeObserverRef.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      }
    };
  }, [sendItemHeight]); <span class="hljs-comment">// 仅首次挂载执行</span>

  <span class="hljs-comment">//监听 item 变化重新计算高度</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">sendItemHeight</span>();
    }, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timer);
  }, [item.<span class="hljs-property">id</span>, sendItemHeight]); <span class="hljs-comment">// item.id 变化时执行</span>

  <span class="hljs-keyword">const</span> itemClass = <span class="hljs-string">`py-2 px-4 border-b border-gray-200 <span class="hljs-subst">${
    item.id % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span> ? <span class="hljs-string">'bg-pink-200'</span> : <span class="hljs-string">'bg-green-200'</span>
  }</span>`</span>;

  <span class="hljs-keyword">const</span> <span class="hljs-attr">itemStyle</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">CSSProperties</span> = {
    <span class="hljs-attr">height</span>: item.<span class="hljs-property">id</span> % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">'150px'</span> : <span class="hljs-string">'100px'</span>,
  };

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{itemRef}</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{itemClass}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{itemStyle}</span>&gt;</span>
      {item.name}
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">VirtualListItem</span>;


</code></pre>
<p><strong>父组件：</strong></p>
<pre><code class="hljs language-tsx" lang="tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, {
  useEffect,
  useRef,
  useState,
  useCallback,
  useMemo,
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">VirtualListItem</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./listItem'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">VirtualList</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MIN_ITEM_HEIGHT</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// 最小项高度</span>
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BUFFER</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// 缓冲区项数</span>

  <span class="hljs-keyword">const</span> virtualListRef = useRef&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 虚拟列表容器引用</span>

  <span class="hljs-keyword">const</span> [listData, setListData] = useState&lt;<span class="hljs-title class_">Array</span>&lt;{ <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> }&gt;&gt;(
    []
  ); <span class="hljs-comment">// 列表数据</span>
  <span class="hljs-keyword">const</span> [scrollTop, setScrollTop] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 滚动位置</span>
  <span class="hljs-keyword">const</span> [itemHeights, setItemHeights] = useState&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;&gt;(
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()
  ); <span class="hljs-comment">// 高度映射表（Map 结构）</span>
  <span class="hljs-keyword">const</span> [cumulativeHeights, setCumulativeHeights] = useState&lt;<span class="hljs-built_in">number</span>[]&gt;([<span class="hljs-number">0</span>]); <span class="hljs-comment">// 累计高度数组</span>
  <span class="hljs-keyword">const</span> scrollTimerRef = useRef&lt;<span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 滚动节流定时器</span>

  <span class="hljs-comment">// 初始化模拟数据</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">initData</span> = (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> mockData = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">1000</span> }, <span class="hljs-function">(<span class="hljs-params">_, index</span>) =&gt;</span> ({
      <span class="hljs-attr">id</span>: index,
      <span class="hljs-attr">name</span>: <span class="hljs-string">`Item <span class="hljs-subst">${index}</span>`</span>,
    }));
    <span class="hljs-title function_">setListData</span>(mockData);
    <span class="hljs-comment">// 初始化高度映射表（默认最小高度）</span>
    <span class="hljs-keyword">const</span> initHeightMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;();
    mockData.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
      initHeightMap.<span class="hljs-title function_">set</span>(item.<span class="hljs-property">id</span>, <span class="hljs-variable constant_">MIN_ITEM_HEIGHT</span>);
    });
    <span class="hljs-title function_">setItemHeights</span>(initHeightMap);
    <span class="hljs-comment">// 初始化累计高度</span>
    <span class="hljs-title function_">updateCumulativeHeights</span>(initHeightMap, mockData);
  };

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">initData</span>();
    <span class="hljs-comment">// 监听窗口大小变化</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResize</span> = (<span class="hljs-params"/>) =&gt; {
      <span class="hljs-keyword">if</span> (virtualListRef.<span class="hljs-property">current</span>) {
        <span class="hljs-title function_">setScrollTop</span>(virtualListRef.<span class="hljs-property">current</span>.<span class="hljs-property">scrollTop</span>);
      }
    };
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'resize'</span>, handleResize);

    <span class="hljs-comment">// 清理监听</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">'resize'</span>, handleResize);
      <span class="hljs-keyword">if</span> (scrollTimerRef.<span class="hljs-property">current</span>) {
        <span class="hljs-built_in">clearTimeout</span>(scrollTimerRef.<span class="hljs-property">current</span>);
      }
      itemHeights.<span class="hljs-title function_">clear</span>(); <span class="hljs-comment">// 清空 Map 释放内存</span>
    };
  }, []);

  <span class="hljs-comment">// 更新累计高度（核心函数）</span>
  <span class="hljs-keyword">const</span> updateCumulativeHeights = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">heightMap: <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>&gt;, data: <span class="hljs-keyword">typeof</span> listData</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> cumulative = [<span class="hljs-number">0</span>];
      <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">const</span> itemId = data[i].<span class="hljs-property">id</span>;
        sum += heightMap.<span class="hljs-title function_">get</span>(itemId) || <span class="hljs-variable constant_">MIN_ITEM_HEIGHT</span>;
        cumulative.<span class="hljs-title function_">push</span>(sum);
      }
      <span class="hljs-title function_">setCumulativeHeights</span>(cumulative);
    },
    [<span class="hljs-variable constant_">MIN_ITEM_HEIGHT</span>]
  );

  <span class="hljs-comment">// 处理子组件的高度更新事件（对应 Vue 的 handleItemHeightUpdate）</span>
  <span class="hljs-keyword">const</span> handleItemHeightUpdate = <span class="hljs-title function_">useCallback</span>(
    <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">number</span>, height: <span class="hljs-built_in">number</span></span>) =&gt;</span> {
      <span class="hljs-comment">// 高度未变化则跳过</span>
      <span class="hljs-keyword">if</span> (itemHeights.<span class="hljs-title function_">get</span>(id) === height) <span class="hljs-keyword">return</span>;

      <span class="hljs-comment">// 更新高度映射表</span>
      <span class="hljs-keyword">const</span> newHeightMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(itemHeights);
      newHeightMap.<span class="hljs-title function_">set</span>(id, height);
      <span class="hljs-title function_">setItemHeights</span>(newHeightMap);

      <span class="hljs-comment">// 异步更新累计高度</span>
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">updateCumulativeHeights</span>(newHeightMap, listData);
      }, <span class="hljs-number">0</span>);
    },
    [itemHeights, listData, updateCumulativeHeights]
  );

  <span class="hljs-comment">// 滚动节流处理</span>
  <span class="hljs-keyword">const</span> handleScroll = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (!virtualListRef.<span class="hljs-property">current</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">// 节流：20ms 内只更新一次 scrollTop</span>
    <span class="hljs-keyword">if</span> (scrollTimerRef.<span class="hljs-property">current</span>) {
      <span class="hljs-built_in">clearTimeout</span>(scrollTimerRef.<span class="hljs-property">current</span>);
    }
    scrollTimerRef.<span class="hljs-property">current</span> = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setScrollTop</span>(virtualListRef.<span class="hljs-property">current</span>!.<span class="hljs-property">scrollTop</span>);
    }, <span class="hljs-number">20</span>);
  }, []);

  <span class="hljs-comment">// 可视区域高度</span>
  <span class="hljs-keyword">const</span> viewportHeight = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> virtualListRef.<span class="hljs-property">current</span>?.<span class="hljs-property">clientHeight</span> || <span class="hljs-variable constant_">MIN_ITEM_HEIGHT</span> * <span class="hljs-number">5</span>;
  }, []);

  <span class="hljs-comment">//  总列表高度</span>
  <span class="hljs-keyword">const</span> totalHeight = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> cumulativeHeights[cumulativeHeights.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] || <span class="hljs-number">0</span>;
  }, [cumulativeHeights]);

  <span class="hljs-comment">// 起始索引</span>
  <span class="hljs-keyword">const</span> startIndex = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> totalItemCount = listData.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">if</span> (totalItemCount === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (scrollTop &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">// 反向遍历找起始索引</span>
    <span class="hljs-keyword">let</span> baseStartIndex = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = cumulativeHeights.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
      <span class="hljs-keyword">if</span> (cumulativeHeights[i] &lt;= scrollTop) {
        baseStartIndex = i;
        <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-keyword">const</span> finalIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, baseStartIndex - <span class="hljs-variable constant_">BUFFER</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(finalIndex, totalItemCount - <span class="hljs-number">1</span>);
  }, [
    scrollTop,
    viewportHeight,
    totalHeight,
    cumulativeHeights,
    listData.<span class="hljs-property">length</span>,
  ]);

  <span class="hljs-comment">// 结束索引</span>
  <span class="hljs-keyword">const</span> endIndex = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> totalItemCount = listData.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">if</span> (totalItemCount === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">const</span> targetScrollBottom = scrollTop + viewportHeight;
    <span class="hljs-keyword">let</span> baseEndIndex = totalItemCount - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cumulativeHeights.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (cumulativeHeights[i] &gt; targetScrollBottom) {
        baseEndIndex = i - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-keyword">let</span> finalEndIndex = baseEndIndex + <span class="hljs-variable constant_">BUFFER</span>;
    finalEndIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(finalEndIndex, totalItemCount - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> finalEndIndex;
  }, [scrollTop, viewportHeight, cumulativeHeights, listData.<span class="hljs-property">length</span>]);

  <span class="hljs-comment">// 可视区列表</span>
  <span class="hljs-keyword">const</span> visibleList = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> startIndex &lt;= endIndex
      ? listData.<span class="hljs-title function_">slice</span>(startIndex, endIndex + <span class="hljs-number">1</span>)
      : [];
  }, [startIndex, endIndex, listData]);

  <span class="hljs-comment">// 偏移量</span>
  <span class="hljs-keyword">const</span> offsetY = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">return</span> cumulativeHeights[startIndex] || <span class="hljs-number">0</span>;
  }, [startIndex, cumulativeHeights]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"h-full bg-gradient-to-br from-indigo-600 to-purple-600 py-10 px-5"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"bg-white mt-10 h-[calc(100vh-200px)] rounded-xl"</span>&gt;</span>
        {/* 滚动容器 */}
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
          <span class="hljs-attr">ref</span>=<span class="hljs-string">{virtualListRef}</span>
          <span class="hljs-attr">className</span>=<span class="hljs-string">"h-full overflow-auto relative"</span>
          <span class="hljs-attr">onScroll</span>=<span class="hljs-string">{handleScroll}</span>
        &gt;</span>
          {/* 占位容器：撑开滚动条 */}
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">height:</span> `${<span class="hljs-attr">totalHeight</span>}<span class="hljs-attr">px</span>` }}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

          {/* 可视区域列表：transform 偏移 */}
          <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
            <span class="hljs-attr">className</span>=<span class="hljs-string">"absolute top-0 left-0 right-0"</span>
            <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">transform:</span> `<span class="hljs-attr">translateY</span>(${<span class="hljs-attr">offsetY</span>}<span class="hljs-attr">px</span>)` }}
          &gt;</span>
            {visibleList.map((item) =&gt; (
              <span class="hljs-tag">&lt;<span class="hljs-name">VirtualListItem</span>
                <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>
                <span class="hljs-attr">item</span>=<span class="hljs-string">{item}</span>
                <span class="hljs-attr">onUpdateHeight</span>=<span class="hljs-string">{handleItemHeightUpdate}</span>
              /&gt;</span>
            ))}
          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">VirtualList</span>;

</code></pre>
<h3 data-id="heading-10">4. 实现效果图</h3>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2f94fc95662c463caed332ed77b1d3c6~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y-R546w5LiA5Y-q5aSn5ZGG55Oc:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771040975&amp;x-signature=SGyg1H2pDISwd9X9leROtXl7YlA%3D" alt="动高虚拟列表滚动.gif" loading="lazy"/></p>
<hr/>
<h2 data-id="heading-11">四、 总结与避坑指南</h2>
<h3 data-id="heading-12">1. 为什么需要缓冲区（BUFFER）？</h3>
<p>如果只渲染可见部分，用户快速滚动时，异步渲染可能会导致瞬间的“白屏”。设置上下缓冲区可以预加载部分 DOM，让滑动更顺滑。</p>
<h3 data-id="heading-13">2. 性能进一步优化</h3>
<ul>
<li><strong>滚动节流（Throttle）</strong> ：虽然滚动监听很快，但在 <code>handleScroll</code> 中加入 <code>requestAnimationFrame</code> 或 20ms 的节流，能有效减轻主线程压力。</li>
<li><strong>Key 的选择</strong>：在虚拟列表中，<code>key</code> 必须是唯一的 <code>id</code>，绝对不能使用 <code>index</code>，否则在滚动重用 DOM 时会出现状态错乱。</li>
</ul>
<h3 data-id="heading-14">3. 注意事项</h3>
<ul>
<li><strong>定高</strong>：逻辑简单，性能极高。</li>
<li><strong>不定高</strong>：依赖 <code>ResizeObserver</code>，需注意频繁重排对性能的影响，建议对 <code>updateCumulativeHeights</code> 做异步批处理。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[脚本伪装：让 Python 与 Node.js 像原生 Shell 命令一样运行]]></title>    <link>https://juejin.cn/post/7603591775391973403</link>    <guid>https://juejin.cn/post/7603591775391973403</guid>    <pubDate>2026-02-07T01:59:16.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603591775391973403" data-draft-id="7603584155785379890" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="脚本伪装：让 Python 与 Node.js 像原生 Shell 命令一样运行"/> <meta itemprop="keywords" content="JavaScript,Python,运维"/> <meta itemprop="datePublished" content="2026-02-07T01:59:16.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="火车叼位"/> <meta itemprop="url" content="https://juejin.cn/user/1345457960792808"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            脚本伪装：让 Python 与 Node.js 像原生 Shell 命令一样运行
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1345457960792808/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    火车叼位
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T01:59:16.000Z" title="Sat Feb 07 2026 01:59:16 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    18
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在开发自动化工具或命令行小玩具时，频繁输入 <code>python myscript.py</code> 或 <code>node index.js</code> 难免显得笨拙。为了让这些脚本看起来更像系统原生的二进制工具，我们需要对其进行“伪装”。</p>
<p>本文将带你攻克 Linux 和 Windows 两大平台，实现脚本的直接调用。</p>
<h2 data-id="heading-0">一、 Linux 环境：利用 Shebang 实现优雅调用</h2>
<p>在类 Unix 系统（Linux, macOS, BSD）中，内核支持一种名为 <strong>Shebang</strong> 的机制。通过在文件头部指定解释器路径，系统会自动调用相应的环境来运行代码。</p>
<h4 data-id="heading-1">1. 核心步骤：Shebang + 可执行权限</h4>
<p>要在 Linux 上实现“伪装”，你需要完成以下两个动作：</p>
<p><strong>第一步：在脚本首行添加 Shebang</strong>
推荐使用 <code>/usr/bin/env</code> 方式，它会自动从用户的 <code>PATH</code> 环境变量中寻找解释器，具有极强的可移植性。</p>
<ul>
<li><strong>Python 示例：</strong></li>
</ul>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment">#!/usr/bin/env python3</span>
<span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-keyword">import</span> sys
<span class="hljs-built_in">print</span>(<span class="hljs-string">f"Python 正在运行，参数为: <span class="hljs-subst">{sys.argv[<span class="hljs-number">1</span>:]}</span>"</span>)

</code></pre>
<ul>
<li><strong>Node.js 示例：</strong></li>
</ul>
<pre><code class="hljs language-javascript" lang="javascript"><span class="hljs-meta">#!/usr/bin/env node</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"Node.js 脚本已启动，当前工作目录:"</span>, process.<span class="hljs-title function_">cwd</span>());

</code></pre>
<p><strong>第二步：赋予执行权限</strong>
在终端运行 <code>chmod +x</code> 命令，告诉文件系统该文件可以被执行：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-built_in">chmod</span> +x my_script.py

</code></pre>
<p>此时，你就可以通过 <code>./my_script.py</code> 直接运行它了。</p>
<h4 data-id="heading-2">2. 进阶：去除后缀并全局化</h4>
<p>如果你想在任何路径下通过输入 <code>mytool</code>（而不是 <code>./mytool.py</code>）来运行脚本：</p>
<ol>
<li><strong>重命名并去掉后缀</strong>：<code>mv my_script.py mytool</code></li>
<li><strong>移入 PATH 路径</strong>：</li>
</ol>
<pre><code class="hljs language-bash" lang="bash">sudo <span class="hljs-built_in">mv</span> mytool /usr/local/bin/

</code></pre>
<p><em>注：<code>/usr/local/bin</code> 通常默认在系统 PATH 中，这样你只需输入 <code>mytool</code> 即可直接触发。</em></p>
<hr/>
<h2 data-id="heading-3">二、 Windows 环境：从批处理到环境关联</h2>
<p>Windows 并不原生支持 Shebang 机制（除非在 WSL 内部运行）。它主要依靠<strong>文件扩展名关联</strong>。</p>
<h4 data-id="heading-4">1. 方案 A：使用 .bat 包装器（推荐）</h4>
<p>这是最稳妥的方法。通过创建一个简单的批处理文件，将接收到的所有参数（用 <code>%*</code> 表示）转发给脚本解释器。</p>
<ul>
<li><strong>创建 <code>mytool.bat</code>：</strong></li>
</ul>
<pre><code class="hljs language-batch" lang="batch">@echo off
python "C:\scripts\my_script.py" %*

</code></pre>
<p><em>注：<code>@echo off</code> 用于隐藏命令本身的执行行，<code>%*</code> 确保你传递给 <code>.bat</code> 的参数能原封不动地传给 Python。</em></p>
<h4 data-id="heading-5">2. 方案 B：利用文件关联</h4>
<p>如果你安装 Python 时勾选了 <strong>"Add Python to PATH"</strong>，Windows 会自动将 <code>.py</code> 文件关联到 <code>python.exe</code>。</p>
<ul>
<li>在命令行直接输入 <code>script.py</code> 即可运行。</li>
<li><strong>注意</strong>：<code>.js</code> 文件在 Windows 上默认关联的是老旧的 <code>WScript</code> (Windows Script Host)，这会导致运行 Node.js 脚本时报错。你需要手动修改 <code>.js</code> 的打开方式为 <code>node.exe</code>。</li>
</ul>
<h4 data-id="heading-6">3. 方案 C：PowerShell 别名（Alias）</h4>
<p>如果你是 PowerShell 用户，可以在配置文件中定义函数来实现：</p>
<pre><code class="hljs language-powershell" lang="powershell"># 在 $PROFILE 文件中添加
function Run-MyTool { python "C:\path\to\script.py" $args }
Set-Alias -Name mytool -Value Run-MyTool

</code></pre>
<hr/>
<h2 data-id="heading-7">三、 跨平台对比总结</h2>






























<table><thead><tr><th>特性</th><th>Linux / macOS</th><th>Windows</th></tr></thead><tbody><tr><td><strong>底层机制</strong></td><td>Shebang (<code>#!</code>)</td><td>文件后缀名关联</td></tr><tr><td><strong>推荐做法</strong></td><td><code>chmod +x</code> + <code>/usr/bin/env</code></td><td><code>.bat</code> 或 <code>.cmd</code> 包装</td></tr><tr><td><strong>全局调用</strong></td><td>放入 <code>/usr/local/bin</code></td><td>将脚本所在文件夹加入环境变量 <code>Path</code></td></tr><tr><td><strong>参数传递</strong></td><td>原生支持</td><td>需在批处理中使用 <code>%*</code></td></tr></tbody></table>
<hr/>
<h2 data-id="heading-8">四、 结论与行动建议</h2>
<p>将脚本转化为工具不仅是为了“好看”，更是为了提升自动化流转的效率。</p>
<h4 data-id="heading-9">核心行动建议：</h4>
<ol>
<li>**优先使用 <code>/usr/bin/env**</code>：无论开发什么脚本，首行养成写 Shebang 的习惯，这能显著降低 Linux 用户的使用门槛。</li>
<li><strong>封装为工具包</strong>：如果你的脚本较多，建议将其统一放在一个目录下（如 <code>~/bin</code> 或 <code>C:\tools</code>），并将该目录添加到系统的 <code>PATH</code> 环境变量中。</li>
<li><strong>处理跨平台差异</strong>：对于需要跨平台分发的工具，可以考虑使用 <code>poetry</code> (Python) 或 <code>npm bin</code> (Node.js) 提供的 Entry Points 功能，它们会自动为你生成适配各平台的启动器。</li>
</ol>
<hr/>
<p><strong>参考来源：</strong></p>
<ul>
<li>Linux Manual Pages: <a href="https://link.juejin.cn?target=https%3A%2F%2Fman7.org%2Flinux%2Fman-pages%2Fman2%2Fexecve.2.html" target="_blank" title="https://man7.org/linux/man-pages/man2/execve.2.html" ref="nofollow noopener noreferrer">execve(2) - Shebang mechanism</a></li>
<li>Python Documentation: <a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.python.org%2F3%2Fusing%2Fwindows.html" target="_blank" title="https://docs.python.org/3/using/windows.html" ref="nofollow noopener noreferrer">Using Python on Windows</a></li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[也许你不需要创建.venv, 此规范使python脚本自备依赖]]></title>    <link>https://juejin.cn/post/7603591775391891483</link>    <guid>https://juejin.cn/post/7603591775391891483</guid>    <pubDate>2026-02-07T01:41:50.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603591775391891483" data-draft-id="7603591775391858715" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="也许你不需要创建.venv, 此规范使python脚本自备依赖"/> <meta itemprop="keywords" content="Python"/> <meta itemprop="datePublished" content="2026-02-07T01:41:50.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="火车叼位"/> <meta itemprop="url" content="https://juejin.cn/user/1345457960792808"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            也许你不需要创建.venv, 此规范使python脚本自备依赖
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1345457960792808/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    火车叼位
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T01:41:50.000Z" title="Sat Feb 07 2026 01:41:50 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    10
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>在 Python 开发中，我们经常陷入一种“环境通胀”：为了运行一个不到 50 行的简单脚本（比如抓个接口数据、写个 Streamlit 演示），却不得不经历 <code>python -m venv .venv</code>、激活环境、<code>pip install</code> 等一系列繁琐动作。</p>
<p>如果你手头有十个这样的脚本，你的磁盘就会被几十个重复的 <code>.venv</code> 文件夹占满。<strong>Astral 推出的 <code>uv</code> 工具正在终结这种低效。</strong> 配合 <strong>PEP 723 (Inline script metadata)</strong> 规范，我们可以真正实现“单文件即项目”的优雅体验。</p>
<hr/>
<h2 data-id="heading-0">1. 核心纠偏：uv init 还是 uv venv？</h2>
<p>很多初学者在刚接触 <code>uv</code> 时会感到困惑。其实，针对不同的颗粒度，<code>uv</code> 提供了三条清晰的路径：</p>

























<table><thead><tr><th>命令</th><th>适用场景</th><th>产物</th></tr></thead><tbody><tr><td><strong><code>uv init</code></strong></td><td><strong>正规军</strong>：需要长期维护、多人协作的复杂应用。</td><td><code>pyproject.toml</code>, <code>.python-version</code></td></tr><tr><td><strong><code>uv venv</code></strong></td><td><strong>传统派</strong>：只是想快点创建环境，继续用传统的 <code>pip</code> 习惯。</td><td><code>.venv</code> 文件夹</td></tr><tr><td><strong><code>uv run</code></strong></td><td><strong>特种兵</strong>：单脚本运行，<strong>不产生任何本地依赖文件夹</strong>。</td><td>临时缓存环境（自动管理）</td></tr></tbody></table>
<blockquote>
<p>[!TIP]
对于简单的工具脚本，<strong>忘掉前两个命令</strong>。你只需要 <code>uv run</code>。</p>
</blockquote>
<hr/>
<h2 data-id="heading-1">2. 现代方案：PEP 723 脚本元数据</h2>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fpeps.python.org%2Fpep-0723%2F" target="_blank" title="https://peps.python.org/pep-0723/" ref="nofollow noopener noreferrer">PEP 723</a> 是 Python 社区的一个里程碑。它允许我们将依赖信息直接以“代码注释”的形式嵌入到脚本头部。这意味着你的脚本具备了<strong>自描述性</strong>——它是自给自足的。</p>
<h3 data-id="heading-2">规范示例</h3>
<p>当你运行一个包含以下代码块的脚本时：</p>
<pre><code class="hljs language-python" lang="python"><span class="hljs-comment"># /// script</span>
<span class="hljs-comment"># dependencies = [</span>
<span class="hljs-comment">#   "httpx",</span>
<span class="hljs-comment">#   "streamlit",</span>
<span class="hljs-comment"># ]</span>
<span class="hljs-comment"># ///</span>

<span class="hljs-keyword">import</span> httpx
<span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st

st.title(<span class="hljs-string">"Token 刷新工具"</span>)
<span class="hljs-comment"># 脚本逻辑...</span>

</code></pre>
<h3 data-id="heading-3">为什么这种方式更优秀？</h3>
<ol>
<li><strong>环境全自动化</strong>：运行 <code>uv run script.py</code> 时，<code>uv</code> 会瞬时在后台创建临时环境。如果依赖没变，下次运行会直接秒开。</li>
<li><strong>零污染</strong>：它不会在你的脚本目录下留下 <code>.venv</code> 文件夹，全局环境永远保持洁净。</li>
<li><strong>极简分发</strong>：把脚本发给同事时，不用再附带 <code>requirements.txt</code>。对方只要装了 <code>uv</code>，直接运行即可。</li>
</ol>
<hr/>
<h2 data-id="heading-4">3. 实战技巧：如何快速配置</h2>
<p>不想手动打那堆 <code># ///</code> 注释？<code>uv</code> 早就帮你想好了自动化方案。</p>
<p>如果你已经写好了一个脚本 <code>refresh_token.py</code>，只需在终端输入：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 为脚本一键添加依赖声明</span>
uv add --script refresh_token.py <span class="hljs-string">"streamlit"</span> <span class="hljs-string">"httpx"</span>

</code></pre>
<p>这会自动在文件头插入符合 PEP 723 规范的元数据。之后，你只需一行命令即可启动：</p>
<pre><code class="hljs language-bash" lang="bash">uv run refresh_token.py

</code></pre>
<hr/>
<h2 data-id="heading-5">4. 进阶特性：精细化控制</h2>
<p>除了基础的依赖管理，你还可以在脚本头部玩出更多花样：</p>
<ul>
<li><strong>版本约束</strong>：<code>"requests&gt;=2.31.0"</code>，确保脚本不会因为库升级而崩掉。</li>
<li><strong>指定 Python 版本</strong>：<code># requires-python = "&gt;=3.12"</code>，自动调用合适的解释器。</li>
<li><strong>工具链配置</strong>：通过 <code>[tool.uv]</code> 块自定义镜像源，解决国内下载慢的问题。</li>
</ul>
<hr/>
<h2 data-id="heading-6">结论与行动建议</h2>
<p>Python 脚本的开发模式正在从“手动建档”转向“声明式运行”。</p>
<ul>
<li><strong>立即可做</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.astral.sh%2Fuv%2Fgetting-started%2Finstallation%2F" target="_blank" title="https://docs.astral.sh/uv/getting-started/installation/" ref="nofollow noopener noreferrer">安装 uv</a>，并尝试用 <code>uv run --with &lt;库名&gt; &lt;脚本&gt;</code> 运行一个临时脚本。</li>
<li><strong>长期实践</strong>：对于所有的工具类脚本，统一使用 <code>uv add --script</code> 写入元数据，把每一个脚本都打造成一个<strong>自给自足的“单兵作战单元”</strong>。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[关于行业 AI Agent 评测的 9 个方面]]></title>    <link>https://juejin.cn/post/7603643385816514612</link>    <guid>https://juejin.cn/post/7603643385816514612</guid>    <pubDate>2026-02-08T03:04:48.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603643385816514612" data-draft-id="7603643385816498228" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="关于行业 AI Agent 评测的 9 个方面"/> <meta itemprop="keywords" content="Agent"/> <meta itemprop="datePublished" content="2026-02-08T03:04:48.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="潘锦"/> <meta itemprop="url" content="https://juejin.cn/user/730549110707431"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            关于行业 AI Agent 评测的 9 个方面
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/730549110707431/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    潘锦
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T03:04:48.000Z" title="Sun Feb 08 2026 03:04:48 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>做 AI Agent，跑起来很容易，简单点函数调用+几个最好的大模型，复杂一点，整合或「学习」一些开源的多 Agent 项目，也能跑起来。</p>
<p>但是如何真正要做到一个行业中去，把一个行业 Agent 做好就没那么容易了，特别是让这个 Agent 能稳定的迭代，稳定的跑对了，也就难了。</p>
<p>在这些迭代过程中，我们会不停的换模型、改提示词、加工具、加缓存、改路由、做多智能体……</p>
<p>这样我们就会收获如下的一堆问题：</p>
<ul>
<li>线上用户说「变笨了」，却没证据；</li>
<li>反馈说生成效果不行，却不知道该如何描述其所说的效果；</li>
<li>修一个 bug，引入三个新 bug；</li>
<li>团队讨论靠口感，最后靠拍板；</li>
<li>研发不敢升级模型，因为测试周期太长；</li>
<li>业务要结果，技术要可控，双方都焦虑。</li>
</ul>
<p>面对这些问题，我们聊聊如何对行业 Agent 做评测。</p>
<h2 data-id="heading-0">0. 说在前面</h2>
<p>我们评测的是「系统」，不是「模型」</p>
<p>很多团队说在做评测，实际上只是在测「模型回复像不像」。对 Agent 来说不够，因为 Agent 的能力来自两部分：</p>
<ul>
<li>模型</li>
<li>工程：提示词、工具编排、状态管理、记忆、重试策略、检索、权限、路由、超时、并发、回退等</li>
</ul>
<p>所以评测对象应该是：模型 + 工程 的整体行为。</p>
<h2 data-id="heading-1">1. 标准</h2>
<p>团队里面一定要有领域专家，没有领域专家的测评只能算自娱自乐。</p>
<p>Agent 的「好」不是抽象的。没有领域专家，评测标准会变成两类坏结果：</p>
<ul>
<li>写得很漂亮，但不对应业务结果（比如客服很礼貌，但票据没关单）</li>
<li>标准含糊，评分不可重复（今天判通过，明天同样输出判不通过）</li>
</ul>
<p>「领域专家」不一定是外部大咖，很多时候就是我们身边的同事：</p>
<ul>
<li>客服主管（知道什么叫“解决”）</li>
<li>财务/风控（知道哪些动作不能做）</li>
<li>资深运营（知道用户会怎么钻空子）</li>
<li>负责交付的实施/售后（知道线上真实约束）</li>
<li>售前负责人（知道用户要的是什么）</li>
</ul>
<p>要求只有一个：两位领域专家独立评审同一个任务，应该能得到一致的 pass/fail。做不到就说明任务或标准还不够清晰。</p>
<h2 data-id="heading-2">2. 数据集</h2>
<p>输入与输出要成对，从 20 条 good case 和 bad case 开始吧。</p>
<p>很多团队拖着不做评测，理由是「没有足够的数据」。</p>
<h2 data-id="heading-3">2.1 数据集怎么来</h2>
<ol>
<li>线上事故 / 客诉 / 工单：最值钱，但也是压力最大的</li>
<li>发布前人工回归里会反复点的那些检查项</li>
<li>运营同学最常复述的“用户就爱这么问”</li>
<li>灰度期间的失败轨迹（尤其是工具调用失败、超时、权限不足、状态不一致）</li>
</ol>
<h2 data-id="heading-4">2.2 一个测试任务里应该包含什么</h2>
<ul>
<li>输入（用户消息 + 初始状态 + 可用工具 + 环境约束）</li>
<li>明确的成功条件</li>
<li>参考解（可能是图、视频和文本）</li>
</ul>
<p>当遇到测试不通过或者通过率很低时，一般不是模型不行，可能是设计的测试任务有问题。</p>
<h2 data-id="heading-5">2.3 数据集要有正反两派</h2>
<p>测试人都知道的，做测试更多的是测异常。在做数据集时，这个逻辑一样的成立。</p>
<ul>
<li>该搜 vs 不该搜</li>
<li>该下单 vs 不该下单</li>
<li>该升级人工 vs 应该继续处理</li>
<li>该改文件 vs 不该动文件</li>
<li>该生成图 vs 应该拒绝（合规/版权/不当内容）</li>
</ul>
<h2 data-id="heading-6">3. 系统</h2>
<p>让过程系统化，小系统也是系统</p>
<p>评测不系统化，最后一定会回到「手工点点点 + 群里吵架」。一个可用的评测系统，最少包括：</p>
<h2 data-id="heading-7">3.1 评测运行系统</h2>
<ul>
<li>并发跑任务</li>
<li>每个环境隔离（干净的文件系统、数据库、缓存、账户）</li>
<li>固定随机种子/版本（尽量可复现）</li>
<li>记录完整过程</li>
<li>输出结构化结果</li>
</ul>
<p>请注意：共享状态会污染结果。</p>
<p>这个系统可以大，也可以小，甚至小到只是一个 python 脚本。</p>
<h2 data-id="heading-8">3.2 评测资产管理</h2>
<ul>
<li>任务版本化（任务也要像代码一样走 PR）</li>
<li>rubric/断言版本化</li>
<li>基线版本固定可回放</li>
<li>失败样本池：每次线上新失败，能快速进入评测集</li>
<li>评测数据集管理</li>
<li>评测结果管理，特别是图片类 Agent，所有的结果图都需要保存，并且能随时查阅，给到领域专家来审查。</li>
</ul>
<h2 data-id="heading-9">3.3 结果可读性</h2>
<p>最终的结果重要，但这个结果不仅仅是分数，还必须能「点开看」：</p>
<ul>
<li>失败的结果</li>
<li>判定理由</li>
<li>最终的证据（输入的 prompt，图片结果，过程中的数据库/文件/页面状态等等）</li>
</ul>
<h2 data-id="heading-10">4. 成本</h2>
<p>和过往的测试工作不同，AI 的评测需要更多些的考虑成本，特别是多模态或视频，生图类 Agent。</p>
<p>这里的基本逻辑是：每个 AI 算力资源都是有限的，也是贵的。</p>
<p>如果在一个死循环中写了调用外部视频生成的接口逻辑，那等待的就是账号里面的钱被用光，如果有加了使用限制，大概率就是达到限制。</p>
<p>以第三方大模型账号为例，有几个小点：</p>
<ol>
<li>测试账号要和生产账号隔离，防止异常突出导致资源受限，在每个平台请求并发数，或者分钟请求数，或者 token 速度都是有限的，不同环境的资源需要隔离开来。</li>
<li>账号需要做好限制，防止账号的钱被用完；</li>
<li>安全考虑，定期更换。</li>
</ol>
<h2 data-id="heading-11">5. 传统测试方式</h2>
<p>静态分析、工具验证、记录分析这些传统的测试方法别丢了。</p>
<h2 data-id="heading-12">5.1 静态分析</h2>
<p>适合：</p>
<ul>
<li>代码类：lint、type check、安全扫描（ruff/mypy/bandit 这类）</li>
<li>配置类：schema 校验</li>
<li>文本结构：JSON schema、正则、字段完整性 优势：快、便宜、可复现、可 debug。</li>
</ul>
<h2 data-id="heading-13">5.2 工具验证</h2>
<p>Agent 出问题很常见的一类是：工具用错、参数错、顺序不合理、该用不用。</p>
<p>你可以验证：</p>
<ul>
<li>是否调用了某工具</li>
<li>参数是否在范围（例如退款金额 &lt;=100）</li>
<li>是否访问了不该访问的资源</li>
</ul>
<p>但要注意：不要把“必须按某条路径走”写死。太死会惩罚合理的创造性解法。更推荐「看产出」，必要时只加一些底线约束（比如必须做身份验证）。</p>
<h2 data-id="heading-14">5.3 记录分析</h2>
<p>不一定评价“对错”，而是监控质量与成本：</p>
<ul>
<li>turn 数、toolcall 数、tokens</li>
<li>延迟：TTFT、总耗时、吞吐</li>
<li>重试次数、错误码分布</li>
</ul>
<h2 data-id="heading-15">6. 新的基于大模型的测试</h2>
<p>该用用，但要用得克制</p>
<p>对于评测，我们通过可以分为三类：代码型、模型型、人工。实际落地里，模型型的价值主要在两件事：</p>
<ol>
<li>开放式输出：没有唯一正确答案（客服话术、研究总结、写作、规划）</li>
<li>细粒度质量维度：礼貌、同理心、覆盖度、论证质量、是否胡编</li>
</ol>
<p>常用方式：</p>
<ul>
<li>打分（按维度给分）</li>
<li>自然语言断言（是否满足某条要求）</li>
<li>A/B 谁更好</li>
<li>对照参考答案</li>
<li>多裁判投票/取中位数</li>
</ul>
<p>但需要注意：</p>
<ul>
<li>非确定性：同样输入可能不同评分</li>
<li>更贵：相当于每条任务再跑一遍模型</li>
<li>需要校准：必须和人评对齐，否则就是“模型自嗨”</li>
</ul>
<p>一个实用的建议：给 LLM 评测一个「退路」，例如信息不足就输出 Unknown，避免它为了「必须回答」而脑补。</p>
<p>另外：把评分标准结构化，并拆维度单独评，不要一次判所有维度，噪声会很大，因为随着上下文更长，大模型的注意力会出现一些问题。</p>
<h2 data-id="heading-16">7. 人工评分</h2>
<p>领域专家门禁：效果不好就不能上，灰度可选</p>
<p>人工评分并不是用来「天天打分」的，人工的职责更多是：</p>
<ul>
<li>定义标准（什么叫好）</li>
<li>校准 LLM grader（对齐、抽检、纠偏）</li>
<li>做门禁（关键版本上线前必须过）</li>
</ul>
<h2 data-id="heading-17">7.1 门禁怎么做</h2>
<ul>
<li>定一个小的「关键任务集」（比如 30 条最关键、最敏感、最影响收入/合规的），或者称为黄金链路</li>
<li>每次大改/换模型/换工具链，必须过这个集</li>
<li>过不了：不讨论「用户可能不在意」，直接回滚或修</li>
</ul>
<h2 data-id="heading-18">7.2 灰度</h2>
<p>没有足够流量，灰度很难有显著的效果，也没有啥意义：</p>
<ul>
<li>用离线评测 + 小范围内测</li>
<li>线上用强监控兜底（错误、成本、关键转化、人工接管率等）</li>
</ul>
<p>等流量与组织能力到位，再做严格 A/B。</p>
<h2 data-id="heading-19">8. 流程</h2>
<p>从 0 到 1，再到可持续</p>
<p>这套流程的目标很简单：让每次改动都有依据，上线前知道会不会退步，退步了能快速定位原因。</p>
<h2 data-id="heading-20">第 0 步：尽早开工，小样本就能跑起来</h2>
<p>别等“数据够多”。先做一个能工作的最小闭环。</p>
<ul>
<li>
<p>先收 20–50 条真实案例（成功和失败都要）</p>
</li>
<li>
<p>来源：线上工单、客服反馈、bug 记录、内部手工测试步骤</p>
</li>
<li>
<p>每条案例都写清楚：什么算成功，什么算失败</p>
</li>
<li>
<p>先把基础能力跑通： 能批量跑 → 每次互不干扰 → 全程有记录 → 能出汇总表</p>
</li>
</ul>
<p>这一阶段不追求完美，只追求“评测能运转”。</p>
<h2 data-id="heading-21">第 1 步：把“手工回归”变成固定任务清单</h2>
<p>你们发布前人工必做的检查，本质上就是任务列表，只是没系统化。</p>
<ul>
<li>发布前“必须点”的那些流程，全部写成任务，进评测库</li>
<li>线上出现的 bug / 客诉，能复现的尽量都写成任务</li>
<li>按影响排序： 影响钱 / 合规 / 大客户 / 高频场景优先</li>
</ul>
<p>做久了会发现：评测库就是你们产品真实使用方式的地图。</p>
<h2 data-id="heading-22">第 2 步：任务要写得清楚，评分要能落地</h2>
<p>一条任务写不清楚，后面全是噪音。</p>
<p>至少要满足三条：</p>
<ol>
<li>两位领域同学看完任务描述，能给出一致的“过/不过”</li>
<li>给每条任务准备一个“标准答案/参考做法”（证明这题能做对）</li>
<li>评分标准不能靠“默认常识”</li>
</ol>
<ul>
<li>评测要检查什么，任务里就要写清楚</li>
<li>别出现“任务没说路径，但测试默认某个路径”这种坑</li>
</ul>
<p>任务写得越清楚，后面迭代越省时间。</p>
<h2 data-id="heading-23">第 3 步：任务要成对出现</h2>
<p>很多系统越改越怪，可能是评测只给了单边信号。</p>
<p>每类行为都尽量做成一对：</p>
<ul>
<li>该查资料 / 不该查资料</li>
<li>该下单 / 不该下单</li>
<li>该继续处理 / 该转人工</li>
<li>该修改文件 / 不该动文件</li>
<li>该生成 / 该拒绝（合规类尤其重要）</li>
</ul>
<h2 data-id="heading-24">第 4 步：把评测环境做稳定，确保结果可信</h2>
<p>评测不可信，比没有评测更糟糕。</p>
<p>关键点：</p>
<ul>
<li>每次运行从干净环境开始（文件、数据库、缓存都重置）</li>
<li>尽量减少共享状态（否则会互相污染）</li>
<li>资源要有上限（CPU/内存/网络），避免“机器不够导致一片失败”</li>
<li>失败要能区分：</li>
<li>是系统真不行</li>
<li>还是环境抖动、配额限制、工具不稳定</li>
</ul>
<p>要保证：同一版本跑两次，结果大体一致。</p>
<h2 data-id="heading-25">第 5 步：评分规则按「能自动就自动」来设计</h2>
<p>评分不要一上来就全靠大模型判。</p>
<p>推荐顺序：</p>
<ol>
<li>能用确定规则判断的，先用确定规则</li>
</ol>
<ul>
<li>结果是否写进数据库、订单是否存在、文件是否生成、测试是否通过</li>
</ul>
<ol>
<li>能用简单规则校验的，用规则</li>
</ol>
<ul>
<li>字段完整、格式正确、调用工具参数在范围内</li>
</ul>
<ol>
<li>只有在确实需要“主观判断”时，才用大模型评分</li>
</ol>
<ul>
<li>语气、解释是否清楚、内容是否覆盖关键点</li>
</ul>
<p>还有一条很重要： 尽量评「最终交付」，少评「必须怎么做」。 路径卡太死，会误伤很多正确解。</p>
<h2 data-id="heading-26">第 6 步：固定做「看过程记录」，不然不知道问题在哪</h2>
<p>很多团队评测做不下去，就是因为只看分数，不看过程。</p>
<p>至少要做到三件事：</p>
<ul>
<li>分数下降时：优先看失败最多、影响最大的那几条任务的过程记录</li>
<li>每周抽查一批「通过」的过程记录（防止钻规则漏洞）</li>
<li>发现「明明做对了却被判错」，立刻修任务描述或评分规则</li>
</ul>
<p>一句话：评测系统也要像产品一样调试。</p>
<h2 data-id="heading-27">第 7 步：分数到顶了就补题，不然评测会失效</h2>
<p>分数 100% 不代表系统没问题，只代表这套题已经测不出差异。</p>
<p>做两件事：</p>
<ul>
<li>持续把新的线上失败变成新任务</li>
<li>专门补「更难、更真实」的场景（长流程、多约束、容易出错的边界条件）</li>
</ul>
<p>评测库要一直增长，否则它会变成摆设。</p>
<h2 data-id="heading-28">第 8 步：让评测「有人管、有人用、有人能加题」</h2>
<p>长期最有效的分工通常是：</p>
<ul>
<li>有一个小组负责评测系统本身（跑得稳、记录全、报表清楚）</li>
<li>各业务团队负责写任务（最懂用户的人写，写出来才贴近真实）</li>
<li>写任务像写代码一样走评审流程（谁提的、为什么提、怎么验证）</li>
</ul>
<p>让离用户最近的人能把问题变成任务，是评测能持续的关键。</p>
<h2 data-id="heading-29">9. 非确定性</h2>
<p>别再只盯「通过率」，用 pass@k 和 pass^k 讲清楚“稳定性”</p>
<p>Agent 的输出有随机性，同一任务可能今天过、明天不过。以下两个指标可以有：</p>
<ul>
<li>
<p>pass@k：k 次尝试里至少成功一次的概率</p>
</li>
<li>
<p>适合“允许多试一次”的场景（比如离线生成候选方案）</p>
</li>
<li>
<p>pass^k：k 次尝试全部成功的概率</p>
</li>
<li>
<p>适合“线上必须稳定”的场景（客服、交易、流程自动化）</p>
</li>
</ul>
<p>它们会随着 k 分化：</p>
<ul>
<li>k 越大，pass@k 越接近 100%</li>
<li>k 越大，pass^k 越接近 0（对稳定性要求更苛刻）</li>
</ul>
<p>这能解决很多争论：</p>
<ul>
<li>研发说「抽卡，多跑几次能过」</li>
<li>业务说「用户只给一次机会」 用 pass@k 和 pass^k 直接对齐产品要求。</li>
</ul>
<h2 data-id="heading-30">10. 安例：生图 AI Agent 如何评估</h2>
<p>生图 Agent 的评测，比「文生图模型评测」更难，因为 Agent 往往还会：</p>
<ul>
<li>和用户多轮确认需求</li>
<li>调风格/比例/seed/参考图</li>
<li>调用安全审核、版权过滤、提示词改写</li>
<li>产出多张候选并做挑选/排序</li>
<li>写交付说明（可商用/不可商用、使用建议）</li>
</ul>
<p>评测要覆盖的不是「画得好不好」一句话，而是「是否按业务标准交付」。</p>
<p>下面给一套实用的评测维度：</p>
<h2 data-id="heading-31">10.1 标准</h2>
<p>先定“交付合格”是什么</p>
<p>建议产品/设计/合规一起定 3–5 条硬标准，例如：</p>
<ul>
<li>不违规：敏感内容、未成年、色情、仇恨、暴力、政治等必须拦截或降级</li>
<li>不侵权：明显模仿特定 IP / 特定艺人脸 / 商标露出等按策略处理</li>
<li>满足需求：主体、场景、风格、比例、文字有无（比如“不要文字”）</li>
<li>质量底线：严重畸形、手指崩坏、文本乱码（如果要求有字则反过来）</li>
<li>可用性：分辨率、格式、背景透明/不透明、交付数量</li>
</ul>
<p>标准不要写成「更美观」「更高级」，要写成可判定的条目。</p>
<h2 data-id="heading-32">10.2 数据集</h2>
<p>最有效的来源通常是：</p>
<ul>
<li>用户最常下单的品类（电商主图、海报、头像、插画、UI 素材）</li>
<li>客诉：不像、漏元素、风格跑偏、文字错、侵权被投诉、审核误杀</li>
<li>运营活动：固定模板需求（这类最适合做回归）</li>
</ul>
<p>每条任务里建议固定：</p>
<ul>
<li>用户输入（含约束：尺寸、风格、禁忌、用途）</li>
<li>允许的工具（生成、放大、背景去除、OCR 检查、合规审查）</li>
<li>成功条件（至少满足哪些项）</li>
<li>参考交付（如果你们已有人工优秀样例，可以作为对照，但不强制唯一答案）</li>
</ul>
<h2 data-id="heading-33">10.3 评测流程</h2>
<p>评测建议按「确定性 → 半确定性 → 开放判断」的顺序叠起来，减少噪音、降低成本。</p>
<h3 data-id="heading-34">A. 结果校验（尽量全自动、最优先）</h3>
<p>这层解决「交付物是否合格」的硬指标：</p>
<ul>
<li>格式、尺寸、分辨率、通道（如 PNG 透明背景）</li>
<li>交付数量（例如必须 4 张）</li>
<li>文件可打开、无损坏</li>
<li>禁止内容检测（审核模型/规则引擎给出通过/拦截/分级）</li>
</ul>
<h3 data-id="heading-35">B. 内容对齐（半自动，能做多少做多少）</h3>
<p>这层解决“有没有按需求做”的关键事实核对：</p>
<ul>
<li>关键元素是否出现：用图像理解/检测器做覆盖检查（比如“猫 + 红围巾 + 雪地”）</li>
<li>不该出现的是否出现：</li>
<li>“不要文字”→ 用 OCR 检测是否有字</li>
<li>“不要 logo/商标”→ logo/商标检测（覆盖不了的留到抽检）</li>
</ul>
<h3 data-id="heading-36">C. 开放项判断（用于难以规则化的部分）</h3>
<p>这层才用多模态判断去评估更开放的维度，例如：</p>
<ul>
<li>主体/场景/风格是否整体匹配需求</li>
<li>是否存在明显瑕疵（手部畸形、脸崩、透视严重错误等）</li>
<li>交付说明是否写清：能否商用、限制条件、使用建议</li>
</ul>
<p>注意：开放项的判定要校准，不要一开始就“全自动放行”。</p>
<h3 data-id="heading-37">D. 过程约束（管体验、管成本）</h3>
<p>对 Agent 的“过程”也要设上限，不然容易出现“靠烧钱刷分”：</p>
<ul>
<li>最大对话轮次（例如 ≤ 6 轮）</li>
<li>工具调用次数上限（避免无限重试）</li>
<li>总耗时 / 总成本阈值</li>
</ul>
<h2 data-id="heading-38">10.4 成本控制</h2>
<p>生图评测很贵，建议分三层跑，不同层用不同频率：</p>
<ol>
<li>回归层（少量高价值，天天/每次发布必跑） 高频品类 + 高风险合规项 + 线上常见故障</li>
<li>能力层（持续加难题，定期跑） 风格混合、复杂构图、多约束冲突、长对话澄清等</li>
<li>抽检层（人工校准，每周固定抽样） 抽查“通过样本”和“失败样本”，用来校准开放项判断与审核策略</li>
</ol>
<h2 data-id="heading-39">10.5 典型坑</h2>
<p>提前避开</p>
<ul>
<li>只看审美分，不看合规/侵权/交付规格 → 上线风险最大</li>
<li>只测“能生成”，不测“该拒绝/该降级” → 合规体系形同虚设</li>
<li>不看过程记录 → 不知道是 Agent 真错了，还是评分/审核错了；也抓不到“用昂贵链路刷通过”</li>
<li>评分规则写死 → 把某一种构图当唯一正确，误杀大量合理解（导致迭代方向跑偏）</li>
</ul>
<h2 data-id="heading-40">11. 最后</h2>
<p>评测的目标是：知道变好还是变差、知道差在哪、知道怎么改。</p>
<p>真正成熟的状态通常是这样：</p>
<ul>
<li>每次改动都有反馈：离线分数怎么变、失败清单有哪些，一眼可见</li>
<li>分数下降能追到根因：能定位到具体哪条任务、哪段过程记录出了问题</li>
<li>关键回归集就是门禁：过不了就不发布（不讨论「感觉应该没事」）</li>
<li>换模型/换策略能算账：能快速判断「收益是否值得成本与风险” 」</li>
<li>线上与离线形成闭环：</li>
<li>线上出现的新失败，能快速回流成任务进评测库</li>
<li>离线提前发现的风险，能在上线前就挡住</li>
</ul>
<p>最后一句：一定要看过程记录。</p>
<p>以上。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[「web extensions🛠️」有关浏览器扩展，开发前你需要知道一些......]]></title>    <link>https://juejin.cn/post/7603771025855971379</link>    <guid>https://juejin.cn/post/7603771025855971379</guid>    <pubDate>2026-02-08T03:45:53.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603771025855971379" data-draft-id="7603674653152968713" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="「web extensions🛠️」有关浏览器扩展，开发前你需要知道一些......"/> <meta itemprop="keywords" content="前端,JavaScript,开源"/> <meta itemprop="datePublished" content="2026-02-08T03:45:53.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="JustHappy"/> <meta itemprop="url" content="https://juejin.cn/user/1489178757445003"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            「web extensions🛠️」有关浏览器扩展，开发前你需要知道一些......
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1489178757445003/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    JustHappy
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T03:45:53.000Z" title="Sun Feb 08 2026 03:45:53 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p>Hi，这里是JustHappy，上手直接开始开发插件？我想你会没有头绪，如果你从未开发过浏览器插件，我想这篇一定对你有帮助，哈哈至少在 vibe coding 的时候可以更好的指挥 AI 去帮助你，放心，我“碎片式写作”篇幅不长，希望给你带来愉快的阅读体验</p>
</blockquote>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa66e70098c14f22bf486981a9a7ef5c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSnVzdEhhcHB5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771127152&amp;x-signature=9GQPJjWSmpsmO5%2B8%2BKPy7%2B1n8hk%3D" alt="image.png" loading="lazy"/></p>
<h2 data-id="heading-0">浏览器扩展是什么？</h2>
<p>浏览器扩展是由 Web 技术构建的小程序（HTML、CSS 和 JavaScript），扩展程序可通过自定义界面、监控浏览器事件和修改网页来提升浏览体验。</p>
<p>自 web 技术诞生初始不久，浏览器插件、扩展技术并应运而生，而后 FireFox、Chrome 等浏览器大厂也纷纷下场，并在 2015 年确定了统一的 WebExtensions 标准</p>
<p>在我眼中，浏览器扩展是 web 世界的“外挂”，你几乎可以通过它去操纵一切网页；同时它也是良好的应用内容载体，其独特的交互模式在一些场景实有奇效</p>
<h2 data-id="heading-1">统一的标准：WebExtensions（2015+）</h2>
<p>Mozilla、Google、Microsoft 达成共识，共同确立了 WebExtensions API ，我们之后的开发之路也围绕这个标准，这里先做个“路由”，这样以后找文档不至于迷路哈哈</p>
<p><strong>WebExtensions 标准适用的浏览器：</strong></p>
<ul>
<li><strong>Mozilla</strong> <strong>Firefox</strong></li>
<li><strong>Google</strong> <strong>Chrome</strong></li>
<li><strong>Microsoft</strong> <strong>Edge</strong></li>
<li><strong>Apple Safari（部分）</strong></li>
</ul>
<p>比较详尽的内容参照 MDN / chrome 文档 ： <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FMozilla%2FAdd-ons%2FWebExtensions" target="_blank" title="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions" ref="nofollow noopener noreferrer">MDN web Extensions</a> / <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.chrome.com%2Fdocs%2Fextensions%3Fhl%3Dzh-cn" target="_blank" title="https://developer.chrome.com/docs/extensions?hl=zh-cn" ref="nofollow noopener noreferrer">Chrome web Extension</a></p>
<h2 data-id="heading-2">它是一个完整的应用</h2>
<p>虽然我们通过 Web 技术来开发浏览器扩展，但它的形态绝对不是一个单纯的网页中的网页，而更像是一个完整的应用，有自己独立的一套运作体系，这个“应用”大致的构成成分如下</p>
<p align="center"><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2701aceb55464c0f985204e00e309b6f~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgSnVzdEhhcHB5:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771127152&amp;x-signature=z1nnY3CucaOBrhZUlTZvHrswfWo%3D" alt="" width="70%" loading="lazy"/></p>
<h2 data-id="heading-3">插件是如何操作页面的？</h2>
<p>我们往往通过一下两种方式操作页面（其余不推荐），受限于篇幅，这里只简单介绍</p>
<h3 data-id="heading-4">1. Content Script：扩展派驻在页面里的“手和眼”</h3>
<p><strong>Content Script 就是注入到匹配页面里的脚本</strong>，它能：</p>
<ul>
<li>读/改 DOM：<code>document.querySelector(...)</code>、<code>element.textContent = ...</code></li>
<li>监听事件：点击、输入、滚动</li>
<li>插入 UI：按钮、浮层、标记、高亮</li>
<li>观察变化：<code>MutationObserver</code></li>
</ul>
<p>关键点：<strong>它和网页 JS 共享同一个 DOM，但不共享同一个 JS 作用域</strong>（隔离世界）。</p>
<h3 data-id="heading-5">2. <code>chrome.scripting</code>：把脚本“打到页面里”</h3>
<p><code>chrome.scripting</code><strong>可以把代码“注入到页面”执行</strong>，但它<strong>并不等同于</strong>传统意义上“把脚本塞进网页里”</p>
<p><code>chrome.scripting</code> 是由扩展后台控制的“按需代码注入机制”，注入点默认是 Content Script 的隔离世界，而不是网页的 JS 主世界。</p>
<p><strong>典型流程是：</strong></p>
<ul>
<li>UI（popup/sidepanel）→ 发消息给 Background</li>
<li>Background 找到当前 tabId</li>
<li>Background 用 <code>scripting</code> 把脚本/样式注入到该 tab</li>
</ul>
<blockquote>
<p>ok，就到这，且听后续我们展开细说</p>
<p>如果你有兴趣，可以直接尝试我的插件开发模板，持续迭代中.....</p>
<p>使用文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fsimonmie.github.io%2Fvue-chrome-extension-template%2F" target="_blank" title="https://simonmie.github.io/vue-chrome-extension-template/" ref="nofollow noopener noreferrer">simonmie.github.io/vue-chrome-…</a></p>
<p>github : <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FSimonmie%2Fvue-chrome-extension-template" target="_blank" title="https://github.com/Simonmie/vue-chrome-extension-template" ref="nofollow noopener noreferrer">github.com/Simonmie/vu…</a></p>
<p>也欢迎各位大佬参与</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Ollama 部署 Qwen 详细指南（2026 最新版）]]></title>    <link>https://juejin.cn/post/7603677143214473231</link>    <guid>https://juejin.cn/post/7603677143214473231</guid>    <pubDate>2026-02-08T03:48:22.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603677143214473231" data-draft-id="7603673564908666915" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Ollama 部署 Qwen 详细指南（2026 最新版）"/> <meta itemprop="keywords" content="Ollama"/> <meta itemprop="datePublished" content="2026-02-08T03:48:22.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="哈里谢顿"/> <meta itemprop="url" content="https://juejin.cn/user/3678304397695056"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Ollama 部署 Qwen 详细指南（2026 最新版）
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3678304397695056/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    哈里谢顿
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-08T03:48:22.000Z" title="Sun Feb 08 2026 03:48:22 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-08
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><blockquote>
<p><strong>适用系统</strong>：Windows 10/11、macOS 12+、Linux（Ubuntu/CentOS）<br/>
<strong>目标模型</strong>：Qwen3 系列（含 1.8B / 7B / 32B 等版本）<br/>
<strong>前置要求</strong>：8GB+ 内存（推荐 16GB+），无需 GPU 也可运行小模型<br/>
<strong>更新日期</strong>：2026 年 2 月</p>
</blockquote>
<hr/>
<h2 data-id="heading-0">一、为什么选择 Ollama + Qwen？</h2>





























<table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td>✅ <strong>一键部署</strong></td><td>无需配置 Python 环境、CUDA、依赖库</td></tr><tr><td>✅ <strong>自动量化</strong></td><td>自动下载 GGUF 4-bit 量化模型，节省显存</td></tr><tr><td>✅ <strong>跨平台支持</strong></td><td>Windows/macOS/Linux 全支持</td></tr><tr><td>✅ <strong>OpenAI 兼容 API</strong></td><td>可直接替换 GPT 调用</td></tr><tr><td>✅ <strong>中文优化</strong></td><td>Qwen 对中文理解远超 Llama 系列</td></tr></tbody></table>
<blockquote>
<p>💡 <strong>2026 年现状</strong>：Ollama 已原生支持 Qwen3 全系列模型，并启用 <strong>思考模式</strong>（<code>/think</code>）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-1">二、安装 Ollama</h2>
<h3 data-id="heading-2">▶️ Windows</h3>
<ol>
<li>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Follama.com%2Fdownload%2FOllamaSetup.exe" target="_blank" title="https://ollama.com/download/OllamaSetup.exe" ref="nofollow noopener noreferrer">ollama.com/download/Ol…</a></li>
<li>双击安装（默认安装到 <code>C:\Users&lt;user&gt;\AppData\Local\Programs\Ollama</code>）</li>
<li>安装完成后<strong>自动启动服务</strong>（系统托盘出现 🐫 图标）</li>
</ol>
<h3 data-id="heading-3">▶️ macOS</h3>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_"># </span><span class="bash">方法 1：官网下载 dmg</span>
<span class="hljs-meta prompt_"># </span><span class="bash">https://ollama.com/download/Ollama-darwin.zip</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">方法 2：使用 Homebrew（推荐）</span>
brew install ollama
brew services start ollama
</code></pre>
<h3 data-id="heading-4">▶️ Linux（Ubuntu/Debian）</h3>
<pre><code class="hljs language-bash" lang="bash">curl -fsSL https://ollama.com/install.sh | sh
sudo systemctl <span class="hljs-built_in">enable</span> ollama
sudo systemctl start ollama
</code></pre>
<blockquote>
<p>🔍 <strong>验证安装</strong>：</p>
<pre><code class="hljs language-bash" lang="bash">ollama --version
<span class="hljs-comment"># 输出示例：ollama version is 0.4.5</span>
</code></pre>
</blockquote>
<hr/>
<h2 data-id="heading-5">三、下载 Qwen 模型（关键步骤）</h2>
<p>Ollama 支持多种 Qwen 版本，命名规则为：<code>qwen3:&lt;size&gt;-&lt;quant&gt;</code>。</p>
<h3 data-id="heading-6">📦 可用模型列表（2026 年 2 月）</h3>








































<table><thead><tr><th>模型名称</th><th>参数量</th><th>量化方式</th><th>内存需求</th><th>下载命令</th></tr></thead><tbody><tr><td><code>qwen3:1.8b</code></td><td>1.8B</td><td>Q4_K_M</td><td>~2 GB</td><td><code>ollama pull qwen3:1.8b</code></td></tr><tr><td><code>qwen3:7b</code></td><td>7B</td><td>Q4_K_M</td><td>~6 GB</td><td><code>ollama pull qwen3:7b</code></td></tr><tr><td><code>qwen3:32b</code></td><td>32B</td><td>Q4_K_M</td><td>~20 GB</td><td><code>ollama pull qwen3:32b</code></td></tr><tr><td><code>qwen3:1.8b-q8_0</code></td><td>1.8B</td><td>Q8（高精度）</td><td>~3 GB</td><td><code>ollama pull qwen3:1.8b-q8_0</code></td></tr></tbody></table>
<blockquote>
<p>⚠️ <strong>注意</strong>：</p>
<ul>
<li>默认不加后缀 = Q4_K_M 量化（最佳性价比）</li>
<li>首次下载需 5~30 分钟（取决于网速和模型大小）</li>
</ul>
</blockquote>
<h3 data-id="heading-7">▶️ 下载示例（以 7B 为例）</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 查看可用标签</span>
ollama list

<span class="hljs-comment"># 下载 Qwen3-7B（自动量化）</span>
ollama pull qwen3:7b

<span class="hljs-comment"># 输出示例：</span>
<span class="hljs-comment"># pulling manifest</span>
<span class="hljs-comment"># pulling 8d9a4e3c... 100% ▕████████████████████████████████████████▏ 4.2 GB</span>
<span class="hljs-comment"># verifying sha256 digest</span>
<span class="hljs-comment"># writing manifest</span>
<span class="hljs-comment"># success</span>
</code></pre>
<blockquote>
<p>💡 <strong>提示</strong>：模型文件默认保存在：</p>
<ul>
<li>Windows: <code>C:\Users&lt;user&gt;.ollama\models</code></li>
<li>macOS: <code>~/.ollama/models</code></li>
<li>Linux: <code>~/.ollama/models</code></li>
</ul>
</blockquote>
<hr/>
<h2 data-id="heading-8">四、命令行使用 Qwen</h2>
<h3 data-id="heading-9">▶️ 基础对话</h3>
<pre><code class="hljs language-arduino" lang="arduino">ollama run qwen3:<span class="hljs-number">7b</span>
&gt;&gt;&gt; 你好！介绍一下你自己。
</code></pre>
<h3 data-id="heading-10">▶️ 特殊指令（Qwen3 独有）</h3>

























<table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td><code>/think</code></td><td>开启深度思考模式（慢但准确）</td></tr><tr><td><code>/nothink</code></td><td>关闭思考，快速响应</td></tr><tr><td><code>/clear</code></td><td>清空上下文</td></tr><tr><td><code>/set parameter num_ctx 4096</code></td><td>设置上下文长度</td></tr></tbody></table>
<blockquote>
<p>🌰 示例：</p>
<pre><code class="hljs language-shell" lang="shell"><span class="hljs-meta prompt_">&gt;</span><span class="bash">&gt;&gt; /think</span>
Thinking mode enabled.
<span class="hljs-meta prompt_">&gt;</span><span class="bash">&gt;&gt; 解释量子纠缠的原理，并举例说明。</span>
（模型将分步推理，输出更严谨）
</code></pre>
</blockquote>
<h3 data-id="heading-11">▶️ 多轮对话</h3>
<p>Ollama 自动维护会话上下文，直到输入 <code>/clear</code> 或退出。</p>
<hr/>
<h2 data-id="heading-12">五、API 调用（OpenAI 兼容）</h2>
<p>Ollama 启动后自动监听 <code>http://localhost:11434</code>，提供 OpenAI 兼容 API。</p>
<h3 data-id="heading-13">▶️ 请求示例（Python）</h3>
<pre><code class="hljs language-vbscript" lang="vbscript">import requests

<span class="hljs-built_in">response</span> = requests.post(
    <span class="hljs-string">"http://localhost:11434/api/chat"</span>,
    json={
        <span class="hljs-string">"model"</span>: <span class="hljs-string">"qwen3:7b"</span>,
        <span class="hljs-string">"messages"</span>: [
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"写一个 Python 快速排序函数"</span>}
        ],
        <span class="hljs-string">"stream"</span>: <span class="hljs-literal">False</span>
    }
)

pr<span class="hljs-built_in">int</span>(<span class="hljs-built_in">response</span>.json()[<span class="hljs-string">"message"</span>][<span class="hljs-string">"content"</span>])
</code></pre>
<h3 data-id="heading-14">▶️ OpenAI SDK 兼容（推荐）</h3>
<pre><code class="hljs language-ini" lang="ini">from openai import OpenAI

<span class="hljs-attr">client</span> = OpenAI(
    <span class="hljs-attr">base_url</span>=<span class="hljs-string">"http://localhost:11434/v1"</span>,
    <span class="hljs-attr">api_key</span>=<span class="hljs-string">"ollama"</span>  <span class="hljs-comment"># 任意值均可</span>
)

<span class="hljs-attr">completion</span> = client.chat.completions.create(
    <span class="hljs-attr">model</span>=<span class="hljs-string">"qwen3:7b"</span>,
    <span class="hljs-attr">messages</span>=[{<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"Hello!"</span>}],
    <span class="hljs-attr">temperature</span>=<span class="hljs-number">0.7</span>
)

print(completion.choices<span class="hljs-section">[0]</span>.message.content)
</code></pre>
<blockquote>
<p>✅ <strong>优势</strong>：现有 GPT 代码只需改两行即可切换到 Qwen！</p>
</blockquote>
<hr/>
<h2 data-id="heading-15">六、可视化界面推荐</h2>
<h3 data-id="heading-16">方案 1：ChatWise（免费，跨平台）</h3>
<ol>
<li>下载：<a href="https://link.juejin.cn?target=https%3A%2F%2Fchatwise.app%2F" target="_blank" title="https://chatwise.app/" ref="nofollow noopener noreferrer">chatwise.app</a></li>
<li>安装后打开 → 选择 <strong>Ollama</strong> 作为后端</li>
<li>在模型列表中选择已下载的 <code>qwen3:7b</code></li>
<li>享受 Markdown 渲染、代码高亮、对话管理</li>
</ol>
<p><img src="https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2406fad286b44740be8294353cc4e9ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5ZOI6YeM6LCi6aG_:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771127303&amp;x-signature=dDS8PxF4Jg7W7QZXFHb8iD000DE%3D" alt="ChatWise 界面" loading="lazy"/></p>
<h3 data-id="heading-17">方案 2：LM Studio（macOS/Windows）</h3>
<ul>
<li>支持本地模型管理</li>
<li>内置性能监控</li>
<li>下载地址：<a href="https://link.juejin.cn?target=https%3A%2F%2Flmstudio.ai%2F" target="_blank" title="https://lmstudio.ai/" ref="nofollow noopener noreferrer">lmstudio.ai</a></li>
</ul>
<hr/>
<h2 data-id="heading-18">七、远程访问：让团队共享你的 Qwen</h2>
<h3 data-id="heading-19">使用 Cloudflare Tunnel（免费内网穿透）</h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 1. 下载 cloudflared</span>
<span class="hljs-comment"># https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation</span>

<span class="hljs-comment"># 2. 启动隧道（Ollama 默认端口 11434）</span>
cloudflared tunnel --url http://localhost:11434
</code></pre>
<blockquote>
<p>输出示例：</p>
<pre><code class="hljs language-arduino" lang="arduino">Your tunnel is ready! Visit: https:<span class="hljs-comment">//abc123.trycloudflare.com</span>
</code></pre>
</blockquote>
<h3 data-id="heading-20">在 ChatWise 中配置远程地址：</h3>
<ol>
<li>设置 → 模型服务 → Ollama</li>
<li>API 地址填写：<code>https://abc123.trycloudflare.com</code></li>
<li>团队成员即可通过公网使用你的 Qwen！</li>
</ol>
<blockquote>
<p>🔒 <strong>安全提示</strong>：生产环境建议添加 API Key 验证（需反向代理）。</p>
</blockquote>
<hr/>
<h2 data-id="heading-21">八、性能调优技巧</h2>
<h3 data-id="heading-22">1. <strong>强制 CPU 模式（无 GPU 时）</strong></h3>
<pre><code class="hljs language-ini" lang="ini"><span class="hljs-comment"># Windows</span>
set <span class="hljs-attr">OLLAMA_NUM_GPU</span>=<span class="hljs-number">0</span>
ollama run qwen3:1.8b

<span class="hljs-comment"># Linux/macOS</span>
<span class="hljs-attr">OLLAMA_NUM_GPU</span>=<span class="hljs-number">0</span> ollama run qwen3:<span class="hljs-number">1.8</span>b
</code></pre>
<h3 data-id="heading-23">2. <strong>调整上下文长度</strong></h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 创建自定义 Modelfile</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"FROM qwen3:7b"</span> &gt; Modelfile
<span class="hljs-built_in">echo</span> <span class="hljs-string">"PARAMETER num_ctx 8192"</span> &gt;&gt; Modelfile

<span class="hljs-comment"># 构建新模型</span>
ollama create qwen3-7b-long -f Modelfile

<span class="hljs-comment"># 使用</span>
ollama run qwen3-7b-long
</code></pre>
<h3 data-id="heading-24">3. <strong>查看资源占用</strong></h3>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 实时监控</span>
ollama ps

<span class="hljs-comment"># 输出示例：</span>
<span class="hljs-comment"># NAME           ID              SIZE    PROCESSOR       UNTIL</span>
<span class="hljs-comment"># qwen3:7b       8d9a4e3c...     4.2 GB  100% CPU        5m</span>
</code></pre>
<hr/>
<h2 data-id="heading-25">九、常见问题解答（FAQ）</h2>
<h3 data-id="heading-26">❓ Q1：下载速度慢怎么办？</h3>
<p>✅ <strong>解决方案</strong>：</p>
<ul>
<li>
<p>使用国内镜像（需手动配置）：</p>
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 临时设置代理（如你有代理）</span>
<span class="hljs-built_in">export</span> http_proxy=http://your-proxy:port
<span class="hljs-built_in">export</span> https_proxy=http://your-proxy:port
ollama pull qwen3:7b
</code></pre>
</li>
<li>
<p>或从 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmodelscope.cn%2Fmodels%2Fqwen%2FQwen3-7B" target="_blank" title="https://modelscope.cn/models/qwen/Qwen3-7B" ref="nofollow noopener noreferrer">ModelScope</a> 手动下载 GGUF 文件，再导入 Ollama（高级操作）</p>
</li>
</ul>
<h3 data-id="heading-27">❓ Q2：如何删除模型释放空间？</h3>
<pre><code class="hljs language-bash" lang="bash">ollama <span class="hljs-built_in">rm</span> qwen3:7b
</code></pre>
<h3 data-id="heading-28">❓ Q3：支持函数调用（Function Calling）吗？</h3>
<p>✅ <strong>部分支持</strong>：</p>
<ul>
<li>Qwen3 原生支持 <strong>MCP 协议</strong>（非 OpenAI Function Calling）</li>
<li>需配合 MCP Server 使用（见 Qwen 官方文档）</li>
</ul>
<h3 data-id="heading-29">❓ Q4：能否微调模型？</h3>
<p>❌ <strong>Ollama 不支持微调</strong>！<br/>
✅ <strong>替代方案</strong>：</p>
<ul>
<li>使用 <strong>Qwen-Agent</strong> 框架进行 LoRA 微调</li>
<li>微调后导出 GGUF 格式，再通过 Ollama 加载</li>
</ul>
<hr/>
<h2 data-id="heading-30">十、学习资源</h2>
<ul>
<li><strong>Ollama 官方文档</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Follama.com%2Fdocs" target="_blank" title="https://ollama.com/docs" ref="nofollow noopener noreferrer">ollama.com/docs</a></li>
<li><strong>Qwen GitHub</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FQwenLM%2FQwen" target="_blank" title="https://github.com/QwenLM/Qwen" ref="nofollow noopener noreferrer">github.com/QwenLM/Qwen</a></li>
<li><strong>模型下载页</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Follama.com%2Flibrary%2Fqwen3" target="_blank" title="https://ollama.com/library/qwen3" ref="nofollow noopener noreferrer">Ollama Library - Qwen</a></li>
<li><strong>社区论坛</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdiscord.gg%2Follama" target="_blank" title="https://discord.gg/ollama" ref="nofollow noopener noreferrer">Ollama Discord</a></li>
</ul>
<hr/>
<h2 data-id="heading-31">十一、总结：最佳实践路径</h2>

























<table><thead><tr><th>目标</th><th>推荐配置</th></tr></thead><tbody><tr><td><strong>个人体验</strong></td><td><code>qwen3:1.8b</code> + ChatWise</td></tr><tr><td><strong>开发测试</strong></td><td><code>qwen3:7b</code> + OpenAI SDK</td></tr><tr><td><strong>高性能推理</strong></td><td><code>qwen3:32b</code> + vLLM（非 Ollama）</td></tr><tr><td><strong>团队共享</strong></td><td>Ollama + Cloudflare Tunnel</td></tr></tbody></table>
<blockquote>
<p>💬 <strong>记住</strong>：<br/>
<strong>“Ollama 让大模型本地化变得像安装 App 一样简单。”</strong><br/>
今天，你已拥有属于自己的中文 AI 助手！</p>
</blockquote>
<hr/>
<blockquote>
<p><strong>作者</strong>：AI 工程师<br/>
<strong>版权声明</strong>：本文可自由转载，但请保留出处。<br/>
<strong>GitHub 示例代码</strong>：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fyourname%2Follama-qwen-guide" target="_blank" title="https://github.com/yourname/ollama-qwen-guide" ref="nofollow noopener noreferrer">github.com/yourname/ol…</a>（虚构）</p>
</blockquote></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[pg内核实现细节]]></title>    <link>https://juejin.cn/post/7603644943350300678</link>    <guid>https://juejin.cn/post/7603644943350300678</guid>    <pubDate>2026-02-07T10:57:38.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603644943350300678" data-draft-id="7603644943350185990" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="pg内核实现细节"/> <meta itemprop="keywords" content="数据库"/> <meta itemprop="datePublished" content="2026-02-07T10:57:38.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="用户98286302568"/> <meta itemprop="url" content="https://juejin.cn/user/1370445415464027"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            pg内核实现细节
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/1370445415464027/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    用户98286302568
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T10:57:38.000Z" title="Sat Feb 07 2026 10:57:38 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读3分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h3 data-id="heading-0">TID(Tuple Id)</h3>
<p>tid表示一行数据在数据页上的逻辑地址，通过block id和offset来定义一个page内具体数据位置。定义如下：</p>
<pre><code class="hljs language-arduino" lang="arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ItemPointerData</span>
{
  BlockIdData blkid; <span class="hljs-comment">// 页号, u32类型</span>
  OffsetNumber posid;<span class="hljs-comment">// 业内slotid, u16类型</span>
}
</code></pre>
<h3 data-id="heading-1">页数据组织形式</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2a81d0b1030c426b967b62a9263a142a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg55So5oi3OTgyODYzMDI1Njg=:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771066658&amp;x-signature=h7NFa62ISRieN3YGyT3F9HbLKK4%3D" alt="image.png" loading="lazy"/>
和oracle一样，pg也是以页为单位来在存储介质和内存中记录行数据，通过tup可定位到对应page的某个TupleId, 然后找到存储实际行数据的tuple.</p>
<h3 data-id="heading-2">行级mvcc实现</h3>
<p>pg修改行数据时，保留旧行，并插入新行。每个事务都有唯一的事务id称为xid。<br/>
每行数据称为一个元组tuple，行头包含四个属性和一些标志位(行头总共有20字节，存储开销大，oracle只有3字节):</p>
<ul>
<li>xmin：创建一个元组时，将事务xid写入该属性；</li>
<li>xmax：默认为0，删除一个元组时，将事务xid写入该属性，update时会将老元组的xmax改成update所在事务xid；</li>
<li>cmin、cmax：记录同一个事务中不同语句顺序，从0开始；</li>
<li>ctid:该行数据对应的tid;</li>
<li>t_ctid:多版本下，通过该属性将同一行多版本串联起来，记录的是下一个多版本行的ctid;</li>
</ul>
<p>每个事务开启时，获取一个32bit的xid值，修改数据时，会创建新的元组记录xid到xmin中，并且写入到表数据中(新旧元组同时存在)。并标记老元组。</p>
<p>伪码示例</p>
<pre><code class="hljs language-sql" lang="sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> t1(c1 <span class="hljs-type">int</span>, c2 <span class="hljs-type">int</span>);

<span class="hljs-keyword">create</span> index idx1(t1.c2);

<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t1 <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t1 <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);

#主表行信息:
ctid    xmin  xmax  t_ctid  data
(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">0</span>    (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)   [<span class="hljs-number">1</span> <span class="hljs-number">2</span>]
(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">0</span>    (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   [<span class="hljs-number">2</span> <span class="hljs-number">3</span>]

#执行<span class="hljs-keyword">delete</span>删除第二行:<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> t1 <span class="hljs-keyword">where</span> c1<span class="hljs-operator">=</span><span class="hljs-number">2</span>

#查询主表只会返回一行数据，但是存储的真实行数没有变化，只是将xmax更改为<span class="hljs-keyword">delete</span>语句对应的xid:<span class="hljs-number">200</span>，行本身不会真的删除
ctid    xmin  xmax  t_ctid  data
(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">0</span>    (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)   [<span class="hljs-number">1</span> <span class="hljs-number">2</span>]
(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">200</span>  (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   [<span class="hljs-number">2</span> <span class="hljs-number">3</span>]

#执行<span class="hljs-keyword">update</span>语句更新第一行:<span class="hljs-keyword">update</span> t1 <span class="hljs-keyword">set</span> c2 <span class="hljs-operator">=</span> <span class="hljs-number">5</span> <span class="hljs-keyword">where</span> c1<span class="hljs-operator">=</span><span class="hljs-number">1</span>
#pg会拷贝第一行数据生成一个新的tuple, 然后更新<span class="hljs-keyword">old</span> tuple的xmax和t_ctid, 来和<span class="hljs-keyword">new</span> tuple链接起来
ctid    xmin  xmax  t_ctid  data
(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">300</span>  (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)   [<span class="hljs-number">1</span> <span class="hljs-number">2</span>]
(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   <span class="hljs-number">100</span>    <span class="hljs-number">200</span>  (<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)   [<span class="hljs-number">2</span> <span class="hljs-number">3</span>]
(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)   <span class="hljs-number">300</span>    <span class="hljs-number">0</span>    (<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)   [<span class="hljs-number">1</span> <span class="hljs-number">5</span>]

#执行查询语句时, 会根据版本号判断返回第一行还是第三行给客户端

#由于c2列上存在索引，上述操作也会影响到索引表，索引表数据也会修改，和主表一样不会被“<span class="hljs-keyword">delete</span>”掉；
#pg的索引表没有多版本概念，而是借用主表的多版本来找到“可见”的最新行；因此索引表的tuple没有xmin<span class="hljs-operator">/</span>xmax等列;
#索引表的tuple通过htid列来关联上主表的tuple；
#更新主表索引列时，索引表也会做相应的修改；
#更新主表非索引列时，索引表不会做修改，通过上面介绍的版本链来找到最新tuple(HOT机制:heap<span class="hljs-operator">-</span><span class="hljs-keyword">only</span> tuple)；

#可以看出pg的多版本会很容易导致磁盘空间膨胀，需要vacuum操作来释放磁盘空间
</code></pre>
<h3 data-id="heading-3">vacuum机制：清理死元组解决表膨胀问题+解决xid回绕问题</h3>
<ul>
<li>事务提交后，新元组可以被其他事务看到，老元组不会被用到了，也不会立即被清理，可能导致表数据空间越来越大；</li>
<li>xid由32bit构成，最多存几亿个事务，数值越界时，会出现问题，vaccum机制会将已提交事务的产生的所有元组中隐藏列记录的xid改成2,1是系统xid，从3开始是正常事务可用值。因此只要是正常事务xid都会大于2，即都可以看到已提交事务的修改。</li>
</ul></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[手搓 VM 复盘：从我的 C++ 并发 GC 到字节 PrimJS 的架构演进]]></title>    <link>https://juejin.cn/post/7603644943350366214</link>    <guid>https://juejin.cn/post/7603644943350366214</guid>    <pubDate>2026-02-07T12:31:58.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603644943350366214" data-draft-id="7603656494904721414" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="手搓 VM 复盘：从我的 C++ 并发 GC 到字节 PrimJS 的架构演进"/> <meta itemprop="keywords" content="操作系统"/> <meta itemprop="datePublished" content="2026-02-07T12:31:58.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="肆忆_"/> <meta itemprop="url" content="https://juejin.cn/user/3898194938326714"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            手搓 VM 复盘：从我的 C++ 并发 GC 到字节 PrimJS 的架构演进
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3898194938326714/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    肆忆_
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T12:31:58.000Z" title="Sat Feb 07 2026 12:31:58 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    6
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读7分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p>最近一直在死磕我的 C++ 虚拟机项目 <code>cilly-vm-cpp</code> 的垃圾回收（GC）模块。为了解决 Stop-The-World (STW) 带来的卡顿问题，我从最开始的单线程 Mark-Sweep，一步步优化到了现在的<strong>并行标记 (Parallel Marking)</strong> + <strong>并发清除 (Concurrent Sweep)</strong>。</p>
<p>本来以为这个架构对于一个学习型项目来说已经挺能打了，直到我为了寻找进一步优化的灵感，去啃了字节跳动开源的 <strong>PrimJS</strong>（Lynx 底层的 JS 引擎）的源码。这一对比，直接让我看到了“学院派实现”和“工业级引擎”之间的鸿沟。</p>
<p>这篇文章既是我的学习笔记，也是一次深度的架构复盘。我将详细拆解我的实现方案，深入解析 PrimJS 的核心架构，通过详细的对比分析，聊聊我准备如何改进我的 VM。</p>
<h2 data-id="heading-0">一、 我的 GC 是怎么实现的？</h2>
<p>我的核心目标很简单：<strong>别让主线程停太久</strong>。为了达成这个目标，我将 GC 拆解为两个阶段，并分别做了并发优化：</p>
<h3 data-id="heading-1">1. 并行标记 (Parallel Marking)</h3>
<p>在“标记阶段”，我们需要遍历整个对象图，找出所有活着的对象。为了利用多核 CPU，我引入了多线程标记：</p>
<ul>
<li><strong>CAS 抢占</strong>：给每个 <code>GcObject</code> 加了一个 <code>std::atomic&lt;bool&gt;</code> 标记位。多个线程同时看到同一个对象时，利用 CAS (Compare-And-Swap) 保证只有一个线程能成功标记并将其入栈，有效防止了重复处理。</li>
<li><strong>全局任务栈</strong>：使用一个 <code>vector&lt;GcObject*&gt; global_stack</code> 作为任务池。所有线程发现新对象（子节点）后，都往这个大栈里扔；没活干了，也都从这里拿。</li>
<li><strong>锁保护</strong>：因为大家都访问同一个栈，我必须加一把 <code>mutex</code> 锁，保证数据安全。</li>
</ul>
<h3 data-id="heading-2">2. 并发清除 (Concurrent Sweep)</h3>
<p>在“清除阶段”，如果有几万个死对象需要释放，主线程逐个 <code>delete</code> 会造成显著卡顿。</p>
<ul>
<li><strong>实现细节</strong>：
<ul>
<li>主线程只做一件事：快速遍历链表，把死对象从链表上“摘”下来（Unlink），放到一个临时列表里。</li>
<li>然后启动一个后台线程 (<code>std::thread(...).detach()</code>)，把这个列表移交给它。</li>
<li>主线程立刻返回继续跑业务代码，后台线程在另一边慢慢 <code>delete</code> 这些垃圾。</li>
</ul>
</li>
</ul>
<p><strong>效果</strong>：通过这两步改造，主线程几乎瞬间恢复响应，STW 时间被压缩到了极致。</p>
<h2 data-id="heading-3">二、 工业级的 PrimJS 是怎么玩的？（源码深度解析）</h2>
<p>PrimJS 是一个基于 QuickJS 深度魔改的高性能 JS 引擎，专为解决移动端的性能瓶颈而生。它的 GC 设计非常硬核，其核心思想是**“极致的性能与掌控”**——它甚至不信任系统的 <code>malloc</code>，而是自己接管了一切。</p>
<h3 data-id="heading-4">1. 核心架构设计</h3>
<ul>
<li><strong>兼容性内存管理 (Compatible MM)</strong>：PrimJS 不仅管理 JS 对象，还接管了底层的内存分配。它实现了一个自定义的内存分配器（基于 <code>dlmalloc</code> 的变种），让 GC 能直接操作<strong>内存块 (Chunk)</strong>，而不是仅仅操作对象指针。</li>
<li><strong>全并行/并发架构</strong>：
<ul>
<li><strong>Parallel Marking</strong>：多线程并行标记。</li>
<li><strong>Parallel Sweeping</strong>：多线程并行清除（比我的更进一步，直接操作内存段）。</li>
<li><strong>Parallel Free List Rebuilding</strong>：多线程重建空闲链表，为下一次分配做准备。</li>
</ul>
</li>
</ul>
<h3 data-id="heading-5">2. 关键组件与实现细节</h3>
<p>我在 <code>docs/reference</code> 中深入研究了它的源码，梳理出了以下几个关键组件：</p>
<h4 data-id="heading-6">A. 收集器 (Collector) —— 总指挥</h4>
<p>负责协调 GC 的全流程：</p>
<ol>
<li><code>MarkLiveObjects()</code>: 启动多线程标记活对象。</li>
<li><code>SweepDeadObjects()</code>: 启动多线程清除死对象。
同时包含了大量用于调试内存泄漏和性能分析的工具宏 (<code>ENABLE_GC_DEBUG_TOOLS</code>)。</li>
</ol>
<h4 data-id="heading-7">B. 访问者 (Visitor) —— 遍历引擎</h4>
<p>负责遍历对象图，核心优化在于：</p>
<ul>
<li><strong>多线程队列</strong>：<code>Queue *queue[THREAD_NUM]</code>。每个线程有一个<strong>独立的任务队列</strong>。这与我的全局栈形成了鲜明对比，配合<strong>工作窃取 (Work Stealing)</strong> 算法，大幅减少了锁竞争。</li>
<li><strong>类型分发</strong>：通过 <code>ALLOC_TAG</code>（分配标签）来区分对象类型（如 <code>JSObject</code>, <code>JSString</code>），然后通过 switch-case 调用不同的 Visit 函数。</li>
</ul>
<h4 data-id="heading-8">C. 清扫器 (Sweeper) —— 最精彩的部分</h4>
<p>这是 PrimJS 与普通 GC 最大的区别所在：</p>
<ul>
<li><strong>直接操作内存页 (Segments)</strong>：它不像普通 GC 那样遍历“对象链表”，而是直接遍历底层的<strong>内存段</strong>。通过地址计算直接找到 Chunk Header，判断 <code>cinuse</code> (是否在使用) 和 <code>is_marked</code> (是否标记)。</li>
<li><strong>并行清除 (Parallel Sweep)</strong>：<code>parallel_traverse_heap_segment</code> 函数将堆内存切分成多个段，分发给线程池 (<code>ByteThreadPool</code>) 并行处理。我的 Sweep 是主线程摘链表+后台单线程释放，而 PrimJS 是<strong>多线程推土机式地平推内存页</strong>。</li>
<li><strong>重建 FreeList</strong>：GC 后，它会并行地将回收的内存块重新挂载到 <code>freelist</code> 上，供下一次 <code>malloc</code> 使用。</li>
</ul>
<h2 data-id="heading-9">三、 差距分析 (Gap Analysis)</h2>
<p>通过详细对比，我整理了如下表格，清晰地展示了 cilly-vm-cpp 与 PrimJS 的技术差距：</p>















































<table><thead><tr><th align="left">特性</th><th align="left">你的 cilly-vm-cpp</th><th align="left">PrimJS</th><th align="left">评价</th></tr></thead><tbody><tr><td align="left"><strong>内存管理</strong></td><td align="left">依赖 C++ <code>new/delete</code></td><td align="left">自研分配器 (<code>dlmalloc</code> 魔改)</td><td align="left">PrimJS 更底层，能控制内存布局，减少碎片，但实现难度极高，且跨平台维护成本巨大。</td></tr><tr><td align="left"><strong>标记算法</strong></td><td align="left">全局栈 + 互斥锁</td><td align="left">本地队列 + 工作窃取</td><td align="left">PrimJS 的扩展性更好。全局锁在核心数增多时会成为瓶颈，而本地队列能实现线性扩展。</td></tr><tr><td align="left"><strong>清除算法</strong></td><td align="left">主线程摘除 + 后台单线程 delete</td><td align="left">多线程并行遍历内存段</td><td align="left">PrimJS 吞吐量更大，适合 GB 级超大堆；我的方案适合中小型堆，实现简单且有效。</td></tr><tr><td align="left"><strong>对象识别</strong></td><td align="left">C++ 虚函数 (<code>Trace</code>)</td><td align="left"><code>AllocTag</code> + <code>switch-case</code></td><td align="left">虚函数有间接调用开销；Tag 分发极快，但代码耦合度极高，每加一个类型都要改核心代码。</td></tr><tr><td align="left"><strong>线程模型</strong></td><td align="left">临时创建/销毁 (Fork-Join)</td><td align="left">常驻线程池 (Thread Pool)</td><td align="left">临时创建线程有昂贵的系统调用开销和冷启动问题；线程池响应极快。</td></tr><tr><td align="left"><strong>Finalizer</strong></td><td align="left">C++ 析构函数</td><td align="left">显式 <code>Finalizer</code> 类</td><td align="left">C++ 析构函数符合 RAII 惯例；PrimJS 需要手动管理资源生命周期，更复杂但更灵活。</td></tr></tbody></table>
<h2 data-id="heading-10">四、 下一步改进计划 (Action Plan)</h2>
<p>看完 PrimJS 的源码，我决定对我的 VM 进行“取其精华，去其糟粕”的升级。我不会盲目照搬，而是选择最适合我这个学习型项目的优化路线。</p>
<h3 data-id="heading-11">1. 必须做 (Must Do)：引入线程池 (Thread Pool)</h3>
<p>我目前的做法是每次 GC 都 <code>new thread</code>，结束后 <code>join</code>。这简直是把线程当“日结临时工”用。
<strong>改进</strong>：实现一个简单的线程池。VM 启动时创建好 Worker 线程，平时挂起（Wait），GC 时唤醒（Notify）。这将消除线程创建销毁的系统开销，显著提升响应速度。</p>
<h3 data-id="heading-12">2. 必须做 (Must Do)：实现本地队列与工作窃取</h3>
<p>全局锁是我目前最大的性能瓶颈。
<strong>改进</strong>：拆掉 <code>global_work_stack_</code>，换成 <code>vector&lt;GcObject*&gt; local_queues[THREAD_NUM]</code>。</p>
<ul>
<li><strong>Push/Pop 无锁化</strong>：线程优先操作自己的队列，完全不需要加锁。</li>
<li><strong>Work Stealing</strong>：只有当自己队列空了，才去尝试窃取其他线程的任务。
这是提升并行效率的关键一步。</li>
</ul>
<h3 data-id="heading-13">3. 保留 (Keep)：坚持用虚函数 Trace</h3>
<p>PrimJS 用 switch-case 是为了榨干最后 1% 的 CPU 性能，牺牲了代码的可维护性。
<strong>决策</strong>：我选择<strong>保留虚函数</strong>。作为一个学习型项目，代码的清晰、优雅和可扩展性更重要。我不想为了那一点点性能，把代码写成一坨难以维护的 switch-case。</p>
<h3 data-id="heading-14">4. 学习但暂不落地 (Learn)：内存分配器</h3>
<p>PrimJS 直接操作内存页的设计非常惊艳，但这属于“屠龙技”。
<strong>决策</strong>：我现在学到了它的思想（内存连续性、缓存局部性），但暂时不去碰 <code>malloc</code> 魔改。除非哪天我真的想挑战 OS 级别的开发，否则 <code>new/delete</code> 配合后台释放对于当前量级的 VM 来说已经足够快了。</p>
<hr/>
<p>做系统开发就是这样，<strong>没有绝对最好的架构，只有最适合的 Trade-off</strong>。PrimJS 选择了极致的掌控，而 cilly-vm-cpp 选择了适度的性能与优秀的架构。通过这次深度复盘，我不仅看清了差距，更明确了进化的方向。下一步，开始搓线程池！</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OSI参考模型&&TCP/IP模型]]></title>    <link>https://juejin.cn/post/7603671627000561704</link>    <guid>https://juejin.cn/post/7603671627000561704</guid>    <pubDate>2026-02-07T14:24:18.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603671627000561704" data-draft-id="7603671627000545320" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OSI参考模型&amp;&amp;TCP/IP模型"/> <meta itemprop="keywords" content="网络协议"/> <meta itemprop="datePublished" content="2026-02-07T14:24:18.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="任白"/> <meta itemprop="url" content="https://juejin.cn/user/2760202790907948"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OSI参考模型&amp;&amp;TCP/IP模型
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/2760202790907948/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    任白
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T14:24:18.000Z" title="Sat Feb 07 2026 14:24:18 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    0
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读17分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">OSI参考模型&amp;&amp;TCP/IP模型</h2>
<p>在计算机网络领域，OSI 参考模型与 TCP/IP 模型是两个至关重要的概念。它们为网络通信提供了标准的框架和协议，使得全球范围内的计算机能够进行开放式通信。本文将从概念、层次结构、功能特点以及应用等方面，对 OSI 参考模型与 TCP/IP 协议进行深入解析。</p>
<h3 data-id="heading-1">总体结构</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ff60128396bd44f99291cbf3ab3a129a~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=ejhadZK0YsXsI70jNRkJxIaSZD8%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-2">OSI参考模型</h3>
<p>在 OSI 参考模型中，总共有 7 层，自下而上分别是<strong>物理层</strong>、<strong>数据链路层</strong>、<strong>网络层</strong>、<strong>传输层</strong>、<strong>会话层</strong>、<strong>表示层</strong>、<strong>应用层</strong>。</p>
<h3 data-id="heading-3">具体设备的对应层次</h3>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5e34b861ed2348ba8c6ebbfd1859d59d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=9QgxZVs27JFubhQ%2F5BXKoDsfi4U%3D" alt="" loading="lazy"/></p>
<p>主机实现了七层所有的功能，集线器实现物理层所要实现的功能，交换机要实现物理层和数据链路层所要实现的功能，路由器实现了物理层、数据链路层、网络层的功能。各个节点之间通过物理传输媒体（网线、光纤等）相连接，我们将物理传输媒体视为第 0 层。接下来我们需要研究 OSI 参考模型中每一层的具体作用。</p>
<h3 data-id="heading-4">物理层</h3>
<p>物理层的传输单位是<strong>比特</strong>，任务是<strong>在物理介质上为数据端设备透明地传输原始比特流</strong>。简单来说就是实现<strong>相邻节点</strong>的比特流传输。</p>
<p>我们知道，两个节点之间需要通过物理传输媒体（<strong>网线、光纤等</strong>）进行连接，节点与节点连接好之后，它们之间要传输数据，首先要解决的第一个问题就是<strong>如何实现两个节点的比特传输？</strong></p>
<p>为了实现比特传输，物理层需要定义电路接口的参数，比如说：网线的接口长什么样子、什么形状、里面有几个针脚。这些接口的参数需要由物理层进行定义。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/acbc056e025f416f86e29bbcf37e95f5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=zV1rZGfyypOaWS4NqLj5gyae6vw%3D" alt="" loading="lazy"/></p>
<p>以同轴电缆实现比特传输为例，物理层协议会对传输信号的含义、电气特征做出明确规范：若接收到 5V 高电平信号，即代表二进制 1；若接收到 1V 低电平信号，即代表二进制 0。同时，协议中还会规定每比特电信号的持续时长，比如 5V 高电平信号持续 0.1ms，判定为传输比特 1；1V 低电平信号持续 0.1ms，判定为传输比特 0。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7fe8c78168f548ff97a379defd29d632~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=f4wktcwnairbzAZr2NTEAVRNqww%3D" alt="" loading="lazy"/></p>
<p>接下来我们思考一个问题，物理层在传输电信号时很容易受到外界影响，可能导致电信号变形，例如，一个高电平电压受到环境影响后变成了低电平电压，这样的话，发送方发送**“1”<strong>的电信号，接收方会受到</strong>“0”**的电信号，并且接收方无法得知数据是否错误，那么我们该怎么保证在传输过程中电信号的准确性呢？<strong>我们引入数据链路层来解决这个问题。</strong></p>
<h3 data-id="heading-5">数据链路层</h3>
<p>数据链路层的传输单位是帧，任务是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/667b4d82c0314084b946a8c1a8c3b38e~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=YbNoSmothhNi8f4zWdkFB6MZJZk%3D" alt="" loading="lazy"/></p>
<p>包含以下功能：</p>
<ol>
<li>
<p>差错控制：检查和纠错</p>
</li>
<li>
<p>流量控制：协调两个<strong>相邻节点间</strong>的速率</p>
</li>
</ol>
<p>数据链路层以帧为传输单位，会在原始数据（如 8bit）中添加<strong>校验比特</strong>（如 2bit），整合后交给物理层传输。接收方链路层会通过校验比特检错，有错则纠错或要求重发，无误则剥离校验比特，将原始数据交给网络层。链路层还具备流量控制功能，可协调相邻节点帧传输速率，避免接收方处理不及。</p>
<p>至此，物理层（第 1 层）、数据链路层（第 2 层）已能实现两个相邻节点之间的无差错数据传输。但在实际计算机网络中，大多数节点之间并不会直接相连，往往需要经过多个路由器的存储转发，才能将数据从源节点成功传递到目的节点。为了实现这种跨多个节点的数据存储转发功能，我们需要在数据链路层之上，额外增加一层——网络层，专门负责解决不同节点之间的路由选择与数据转发问题。</p>
<h3 data-id="heading-6">网络层</h3>
<p>网络层的传输单位是<strong>数据报</strong>，任务是将网络层的协议数据单元（分组）从源主机传输到目的主机，为<strong>分组交换网上点的不同主机提供通信服务</strong>。</p>
<p>包含以下功能：</p>
<ol>
<li>
<p>路由选择：构造并维护路由表，决定分组到达目的节点的最佳路径。</p>
</li>
<li>
<p>分组转发：将“分组”从合适的端口转发出去。</p>
</li>
<li>
<p>拥塞控制：发现网络拥堵，并采取缓解措施。</p>
</li>
<li>
<p>网际互连：实现异构网络互联（解释：简单来说，路由器的功能是将多个计算机网络连接在一起，但这些被连接的网络，内部构造各不相同，所采用的局域网技术也不一样——比如有的网络用的是以太网技术，有的则用的是令牌环网技术。而无论这些网络的内部结构、采用的技术有多大差异，只要经过路由器网络层的处理，就能把这些内部差异全部屏蔽掉，最终实现不同类型网络之间的正常互联和数据通信。）</p>
</li>
<li>
<p>其他功能：差错控制，流量控制，连接的建立与释放，可靠传输管理。</p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d97709220f04a8f96611ac5ee769b6b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=kjMNiA7AFYilU9puAEvKAeU5LIg%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-7">传输层</h3>
<p>网络层实现主机到主机的数据分组转发，但一台主机会运行多个进程，数据传到目标主机后，还需区分收发对应的进程，因此在网络层之上增设传输层。</p>
<p>传输层的核心是实现 <strong>端到端（进程到进程）</strong> 的通信服务（这里的 “端” 指端口），为主机间的进程通信提供通用数据传输能力，各类网络应用均可共用该服务，无需针对特定应用单独设计。</p>
<p>包含以下功能：</p>
<ol>
<li>
<p><strong>分用和复用</strong>：<strong>复用</strong>是多个应用层进程可同时使用传输层的服务；<strong>分用</strong>则是传输层将接收到的信息，分别交付给应用层对应的进程，再由应用进程处理应用层报文。</p>
</li>
<li>
<p>其他功能：差错控制，流量控制，连接的建立与释放，可靠传输管理。</p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/b7420cb9ff2948fc82683cbd3e399206~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=TIK6zv6Tg8IkgP1nJXmHo7XvDTg%3D" alt="" loading="lazy"/></p>
<p>传输层之间是以报文段为单位传输数据，一个报文段可能会被拆分为多个分组， 源节点的网络层会将这些分组发送给目的节点，最后再由目的节点的网络层把这些分组拼凑成完整的报文段，交付给目的节点的传输层。</p>
<h3 data-id="heading-8">会话层</h3>
<p><strong>核心任务</strong>：专门负责管理网络中不同主机上进程之间的通信会话，保障进程间通信的有序性、连续性，避免因异常中断导致通信数据丢失或重传浪费。</p>
<p><strong>主要功能</strong>：核心为<strong>会话管理</strong>，其中最关键的是检查点恢复机制。该机制会在通信过程中按规则记录数据传输的关键节点（检查点），若通信因网络中断、设备故障等原因失效，无需从头开始传输数据，恢复连接后可直接从最近的检查点继续后续传输，大幅提升通信效率。</p>
<p><strong>实际举例</strong>：主机 A 通过微信向主机 B 发送 1GB 的视频文件时，会话层会全程管控该传输会话。若视频传输至 500MB 时突发网络中断，会话层会立即在 500MB 这个位置记录检查点；当网络恢复、两台主机的通信进程重新建立连接后，视频不会从 0MB 重新发送，而是直接从 500MB 的检查点继续传输剩余内容。</p>
<h3 data-id="heading-9">表示层</h3>
<p><strong>核心任务</strong>：解决不同主机之间信息表示格式不一致的问题，统一通信双方的数据表达形式，让异构主机能正确识别、解析彼此传输的数据，是通信双方的 “数据翻译官”。</p>
<p><strong>主要功能</strong>：以<strong>数据格式转换</strong>为核心，同时涵盖数据压缩 / 解压、加密 / 解密等配套功能。数据格式转换包含编码格式转换、数据格式标准化等；压缩 / 解压可减小数据传输体积，提升传输速度；加密 / 解密则保障数据在传输过程中的安全性，防止信息泄露。</p>
<p><strong>实际举例</strong>：不同主机的系统可能采用不同的字符编码格式，若主机 A 的编码格式为 GBK，主机 B 为 UTF-8，同一个汉字在两台主机中被转换的二进制编码会完全不同 —— 主机 A 发送的汉字二进制数据，直接传到主机 B 后会出现乱码，这就是典型的信息表示不一致问题。此时表示层会介入处理：主机 A 的表示层先将 GBK 编码的二进制数据转换为双方约定的统一编码格式，再传输至主机 B；主机 B 的表示层接收到数据后，再将其转换为自身可识别的 UTF-8 编码，最终让主机 B 正确显示对应的汉字，解决乱码问题。</p>
<h3 data-id="heading-10">应用层</h3>
<p><strong>核心任务</strong>：直接为用户或应用程序提供特定的网络应用服务，是 OSI 参考模型中最贴近用户的一层，所有用户可见的网络功能都由应用层实现。</p>
<p><strong>主要功能</strong>：功能无统一固定标准，完全根据实际网络应用的需求进行设计和开发，种类繁多且随网络技术发展不断拓展。凡是依托网络实现的具体应用功能，都对应应用层的相关协议和服务。</p>
<p><strong>常见举例</strong>：日常使用的网页浏览（对应 HTTP/HTTPS 协议）、文件传输（FTP 协议）、电子邮件收发（SMTP/POP3 协议）、即时通讯（微信、QQ 的专属应用层协议）、域名解析（DNS 协议）等，都是应用层实现的典型网络应用。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/51402382f4a045819cfd211cc9a00f2d~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=0DF4EIklFv7Z3AfGM%2BusB3FJJ3k%3D" alt="" loading="lazy"/></p>
<h2 data-id="heading-11">TCP/IP模型</h2>
<h3 data-id="heading-12">结构</h3>
<p>TCP/IP 模型是一个<strong>四层</strong>网络架构模型，由美国国防部高级研究计划局（ARPA）在 20 世纪 70 年代为 ARPANET（互联网前身）所设计。它基于一系列核心协议（如 TCP 和 IP），并因互联网的全球普及而成为实际上的工业标准。与 OSI 模型的<strong>理论分层</strong>不同，TCP/IP 模型更侧重于<strong>实践和协议实现。</strong></p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fa780f11589b4a9fac88e7fffe18e519~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=VeTPAws%2BeQBN%2BvvtO8YqwMDfnII%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-13">网络接口层</h3>
<p>网络接口层是 TCP/IP 模型的最底层，对应 OSI 参考模型的物理层和数据链路层，传输单位是帧，核心任务是负责将网络层传递下来的分组（数据报）封装成帧，通过物理传输媒体实现相邻设备之间的帧传输，同时接收来自物理介质的帧，剥离帧头部信息后，将核心数据（分组）交给网络层。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/4fa7db72c7e240c594023a9a7f0771cf~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=YXon7q%2F0FXfhbi0tewPbUuhYTIQ%3D" alt="" loading="lazy"/></p>
<p>这里我们思考一个问题：网络接口层只能实现相邻设备之间的帧传输，无法跨越多个网络（如局域网与广域网）传递数据——比如一台家用电脑（局域网内）要向互联网上的服务器发送数据，中间需要经过路由器、交换机等多个设备，此时仅靠网络接口层的帧传输无法完成，因此需要引入网络层，解决跨网络的数据转发问题。</p>
<h3 data-id="heading-14">网络层</h3>
<p>网络层是 TCP/IP 模型的核心层次，对应 OSI 参考模型的网络层，传输单位是分组（也称为数据报），核心任务是实现跨网络（异构网络）的分组转发，将源主机的分组通过多个路由器的存储转发，最终传递到目的主机，为主机与主机之间（跨网络）的通信提供基础服务。</p>
<p><strong>包含以下功能：</strong></p>
<ol>
<li>
<p>IP 寻址：为互联网中的每一台主机分配唯一的 IP 地址（IPv4 或 IPv6），作为主机的身份标识，确保分组能够准确识别源主机和目的主机。IP 地址就像是主机的“网络身份证”，例如家用电脑的 IP 地址可能是 192.168.1.100，互联网服务器的 IP 地址可能是 203.0.113.10，分组通过 IP 地址才能找到对应的目的主机。</p>
</li>
<li>
<p>路由选择：路由器会构造并维护路由表，路由表中记录了不同网络的可达路径、路径优先级、下一跳路由器地址等信息。当路由器接收到分组时，会根据分组中的目的 IP 地址，查询路由表，选择一条最优路径，将分组转发到下一跳路由器，直至分组到达目的主机所在的网络。</p>
</li>
<li>
<p>分组转发：这是网络层的核心操作，路由器接收来自上层（传输层）或其他路由器的分组后，解析分组头部的目的 IP 地址，结合路由表确定转发端口，将分组转发出去。转发过程中，路由器仅修改分组的物理地址（MAC 地址），不修改 IP 地址和分组的数据内容。</p>
</li>
<li>
<p>拥塞控制：当网络中分组数量过多，超过路由器或链路的处理能力时，会出现网络拥塞（导致分组延迟、丢失）。网络层通过丢弃部分分组、调整转发速率等简单方式，缓解拥塞，保障网络的基本传输效率（TCP/IP 模型中，更精细的拥塞控制主要由传输层负责）。</p>
</li>
<li>
<p>网际互连：实现异构网络的互联，例如将以太网（局域网）、广域网（如光纤网络）、无线网络等不同类型的网络连接在一起。路由器的网络层能够屏蔽不同底层网络的差异（如帧格式、传输介质不同），通过 IP 协议统一封装分组，实现不同网络之间的正常数据通信。</p>
</li>
</ol>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/7be1235dbc9d491289b9928c0eb85073~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=gJJ19sQF23l6SZAhTiim%2FJf%2BdlM%3D" alt="" loading="lazy"/></p>
<h3 data-id="heading-15">传输层</h3>
<p>传输层对应 OSI 参考模型的传输层，位于网络层之上、应用层之下，传输单位是报文段（TCP 协议）或用户数据报（UDP 协议），核心任务是在网络层“主机到主机”通信的基础上，实现“端到端（进程到进程）”的可靠或不可靠通信，为主机上的不同应用进程提供独立的通信通道，屏蔽网络层的传输差异。</p>
<p>我们知道，网络层只能将分组传递到目的主机，但一台主机上会同时运行多个应用进程（如同时打开浏览器、微信、QQ），分组到达目的主机后，需要明确“交给哪个应用进程处理”——传输层通过“端口”解决这个问题：每个应用进程对应一个唯一的端口号（1-65535），分组到达后，传输层根据端口号，将数据分发给对应的应用进程，这就是“进程到进程”的通信。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8b29f339dee544909504df1704b1b91c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=gNn4ZiuJyE3TB3ozZhanjgCyxZU%3D" alt="" loading="lazy"/></p>
<p><strong>包含以下功能：</strong></p>
<ol>
<li>
<p>分用和复用：复用是指多个应用层进程可以同时使用传输层的服务，传输层会为每个进程分配独立的端口号，将不同进程的数据封装成不同的报文段 / 用户数据报，统一交给网络层传输；分用是指传输层接收来自网络层的分组后，解析分组中的端口号，将数据分别交付给应用层对应的进程。</p>
</li>
<li>
<p>可靠传输（TCP 协议专属）：TCP 协议通过确认机制、重传机制、排序机制、流量控制、拥塞控制等，确保数据能够准确、有序、无丢失地从源进程传输到目的进程。例如，发送方发送报文段后，会等待接收方的确认消息；若超时未收到确认，会重新发送该报文段；接收方会对收到的报文段进行排序，丢弃重复的报文段，确保数据的有序性。</p>
</li>
<li>
<p>不可靠传输（UDP 协议专属）：UDP 协议不提供可靠传输，仅负责将应用层的数据封装成用户数据报，交给网络层传输，不进行确认、不重传、不排序，传输效率高，适合对实时性要求高、允许少量数据丢失的场景（如视频通话、语音通话、广播）。</p>
</li>
<li>
<p>流量控制：协调源进程和目的进程的数据传输速率，避免目的进程处理速度跟不上源进程的发送速度，导致数据堆积、丢失。TCP 协议通过滑动窗口机制实现流量控制，UDP 协议不提供流量控制。</p>
</li>
<li>
<p>连接的建立与释放（TCP 协议专属）：TCP 协议是面向连接的协议，通信前需要通过“三次握手”建立连接，确保双方通信就绪；通信结束后，通过“四次挥手”释放连接，释放系统资源；UDP 协议是无连接协议，通信前无需建立连接，通信结束后无需释放连接。</p>
</li>
</ol>
<h3 data-id="heading-16">应用层</h3>
<p>应用层是 TCP/IP 模型的最上层，对应 OSI 参考模型的会话层、表示层、应用层，核心任务是直接为用户或应用程序提供特定的网络应用服务，是 TCP/IP 模型中最贴近用户的一层，所有用户可见的网络功能，都由应用层实现。</p>
<p>与 OSI 模型将会话、表示、应用功能分开不同，TCP/IP 模型将这三层的功能整合到应用层中，简化了协议设计——应用层无需关注底层的传输细节（如如何分组、如何转发、如何保证可靠传输），只需调用传输层提供的服务，实现具体的网络应用功能即可。应用层的协议都是针对具体应用设计的，种类繁多，随网络技术的发展不断拓展。</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/caa329fd7740416da3ec0407c07522d5~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lu755m9:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771079058&amp;x-signature=pHdRxLiad4tGz6z22iRgS8rzSmI%3D" alt="" loading="lazy"/></p>
<p>补充说明：应用层的所有数据，都会交给传输层（TCP 或 UDP 协议）进行封装，再依次经过网络层、网络接口层的封装，最终通过物理介质传输；接收方则从底层到上层，依次剥离各层的封装头部，最终将数据交给应用层的对应进程，完成一次完整的网络通信。</p>
<h2 data-id="heading-17">总结</h2>
<p>OSI 参考模型是由国际标准化组织（ISO）制定的理论化七层协议模型（自下而上为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），核心定位是为全球异构网络提供统一的通信规范和理论框架，层次划分细致、功能定义严谨，涵盖了从物理比特传输到应用服务的全流程，但其结构复杂、实现成本高，仅作为理论参考，未在实际网络中广泛应用；TCP/IP 模型源于 ARPAnet 项目，是实用化的四层协议模型（自下而上为网络接口层、网络层、传输层、应用层），核心定位是解决实际网络互联问题，整合了 OSI 模型中会话层、表示层的功能，虽非国际标准，但因其简洁高效、兼容性强，成为全球互联网的实际执行标准，两者核心对应关系明确：TCP/IP 模型的网络接口层对应 OSI 的物理层与数据链路层（负责帧和比特传输），网络层（核心 IP 协议）、传输层（TCP/UDP 协议）分别对应 OSI 的同名层次，应用层则涵盖了 OSI 会话层、表示层、应用层的全部应用服务功能。</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[Pinia必学4大核心API：$patch/$reset/$subscribe/$onAction，用法封神！]]></title>    <link>https://juejin.cn/post/7603673564908322851</link>    <guid>https://juejin.cn/post/7603673564908322851</guid>    <pubDate>2026-02-07T15:01:26.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603673564908322851" data-draft-id="7602991346585255970" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="Pinia必学4大核心API：$patch/$reset/$subscribe/$onAction，用法封神！"/> <meta itemprop="keywords" content="JavaScript,面试,Vue.js"/> <meta itemprop="datePublished" content="2026-02-07T15:01:26.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="boooooooom"/> <meta itemprop="url" content="https://juejin.cn/user/3078273283917399"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            Pinia必学4大核心API：$patch/$reset/$subscribe/$onAction，用法封神！
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3078273283917399/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    boooooooom
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T15:01:26.000Z" title="Sat Feb 07 2026 15:01:26 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    1
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读5分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>@charset "UTF-8";.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:15px;overflow-x:hidden}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;color:#3c9dff}.markdown-body h1{font-size:30px;margin-bottom:5px;padding-bottom:8px;text-align:center}.markdown-body h2{font-size:24px;padding-bottom:6px}.markdown-body h2:before{content:"🍋"}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h3:before{content:"🍓"}.markdown-body h4{font-size:16px}.markdown-body h4:before{content:"🍑"}.markdown-body h5{font-size:15px}.markdown-body h5:before{content:"🍉"}.markdown-body h6{margin-top:5px}.markdown-body h6:before{content:"🍒"}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{display:block;margin:0 auto;max-width:100%;border-radius:4px;padding:1px;border:1px solid #d2e8ff}.markdown-body img:hover{box-shadow:0 1px 3px #5eaeff}.markdown-body hr{height:4px;margin:34px 0;background-size:4px 1px;background-image:linear-gradient(270deg,#5eaeff,#f3f9ff 25%,transparent 50%);border-style:none}.markdown-body code{word-break:break-word;border-radius:3px;overflow-x:auto;background-color:#d2e8ff;color:#3c9dff;font-size:.9em;padding:.1em .5em;margin:0 3px}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace;transition:all .3s}.markdown-body pre{overflow:auto;position:relative;line-height:1.75;border:1px solid #90c7ff;border-radius:4px}.markdown-body pre:hover{box-shadow:0 1px 10px #beddff}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#3c9dff;border-bottom:1px solid #90c7ff;transition:all .3s}.markdown-body a:hover{color:#007fff;border-bottom:2px solid #5eaeff}.markdown-body a[href]:not(:empty){padding-right:18px}.markdown-body a[href]:not(:empty):after{display:inline-block;width:16px;height:16px;margin-left:2px;content:"";background:url(data:image/svg+xml;base64,PHN2ZyBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTYiIGhlaWdodD0iMTYiPjxwYXRoIGQ9Ik0zODQgMTI4YTQ4IDQ4IDAgMDEyLjgxNiA5NS45MkwzODQgMjI0SDI1NmEzMiAzMiAwIDAwLTMxLjkyIDI5LjZMMjI0IDI1NnY1MTJhMzIgMzIgMCAwMDI5LjYgMzEuOTJsMi40LjA4aDUxMmEzMiAzMiAwIDAwMzEuOTItMjkuNmwuMDgtMi40VjY1NmE0OCA0OCAwIDAxOTUuOTItMi44MTZMODk2IDY1NnYxMTJhMTI4IDEyOCAwIDAxLTEyNCAxMjcuOTM2bC00IC4wNjRIMjU2YTEyOCAxMjggMCAwMS0xMjcuOTM2LTEyNGwtLjA2NC00VjI1NmExMjggMTI4IDAgMDExMjQtMTI3LjkzNmw0LS4wNjRoMTI4em0zODQgMGExMjggMTI4IDAgMDExMjcuOTM2IDEyNGwuMDY0IDR2MTYwYTQ4IDQ4IDAgMDEtOTUuOTIgMi44MTZMODAwIDQxNlYyOTEuODcybC0zODIuMDY0IDM4Mi4wOGE0OCA0OCAwIDAxLTcwLjAzMi02NS42bDIuMTYtMi4yODhMNzMyLjA5NiAyMjRINjA4YTQ4IDQ4IDAgMDEtMi44MTYtOTUuOTJMNjA4IDEyOGgxNjB6IiBmaWxsPSIjM2M5ZGZmIiBmaWxsLW9wYWNpdHk9Ii41NiIgZGF0YS1zcG0tYW5jaG9yLWlkPSJhMzEzeC5zZWFyY2hfaW5kZXguMC5pMC41Yzc1M2E4MTgwa2RKWCIgY2xhc3M9InNlbGVjdGVkIi8+PC9zdmc+);background-size:100%}.markdown-body table{margin:0 auto 10px;font-size:12px;width:auto;max-width:100%;overflow:auto;border-collapse:collapse;border:1px solid #3c9dff}.markdown-body thead{text-align:center}.markdown-body thead th{color:#fff;background-color:#5eaeff}.markdown-body tr{text-align:center}.markdown-body tbody tr:hover{background-color:#d2e8ff}.markdown-body tbody tr:hover code{background-color:#90c7ff}.markdown-body tr:nth-child(2n){background-color:#ecf5ff}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li::marker,.markdown-body ul li::marker{color:#5eaeff}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body b,.markdown-body strong{font-weight:900;padding:0 1px;font-size:17px}.markdown-body small{color:#cbcbcb;padding:0 1px;font-size:22px;zoom:.5}.markdown-body em{padding:0 1px}.markdown-body del{padding:0 1px;text-decoration-thickness:2px}.markdown-body blockquote{color:#1a1b1c;padding:1px 20px;margin:22px 0;border-radius:4px;border-left:4px solid rgba(60,157,255,.5);background-color:rgba(190,221,255,.3)}.markdown-body blockquote blockquote{margin:8px 0}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body details{margin:12px 0;padding:4px 10px;border:2px solid #3c9dff;border-radius:8px;background-color:#ecf5ff;transition:all .3s}.markdown-body details summary{cursor:pointer}.markdown-body input[type=checkbox]{position:relative;appearance:none;width:16px;height:16px;border-radius:2px;vertical-align:middle;transform:translateY(-2px);box-sizing:border-box;border:1px solid #beddff}.markdown-body input[type=checkbox]:checked{border:1px solid #5eaeff;background-color:#5eaeff}.markdown-body input[type=checkbox]:checked:before{position:absolute;top:3px;left:1px;width:11px;height:6px;background-color:transparent;border-left:2px solid #fff;border-bottom:2px solid #fff;transform:rotate(-45deg);content:"";box-sizing:border-box}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="androidstudio">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#a9b7c6;background:#282b2e}.hljs-bullet,.hljs-literal,.hljs-number,.hljs-symbol{color:#6897bb}.hljs-deletion,.hljs-keyword,.hljs-selector-tag{color:#cc7832}.hljs-link,.hljs-template-variable,.hljs-variable{color:#629755}.hljs-comment,.hljs-quote{color:grey}.hljs-meta{color:#bbb529}.hljs-addition,.hljs-attribute,.hljs-string{color:#6a8759}.hljs-section,.hljs-title,.hljs-type{color:#ffc66d}.hljs-name,.hljs-selector-class,.hljs-selector-id{color:#e8bf6a}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">正文</h2>
<h3 data-id="heading-1">一、前言：为什么要吃透这4个核心API？</h3>
<p>学会Pinia的Setup Store和Option Store基础写法后，想要真正灵活运用Pinia、应对复杂状态管理场景，就必须掌握它的四大核心实例API——<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mtext>、</mtext></mrow><annotation encoding="application/x-tex">patch、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">、</span></span></span></span></span>reset、<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>e</mi><mtext>、</mtext></mrow><annotation encoding="application/x-tex">subscribe、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">ib</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">、</span></span></span></span></span>onAction。</p>
<p>这4个API贯穿Pinia开发全流程：<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mtext>批量修改状态、</mtext></mrow><annotation encoding="application/x-tex">patch批量修改状态、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">批量修改状态、</span></span></span></span></span>reset重置状态、<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>e</mi><mtext>监听状态变化、</mtext></mrow><annotation encoding="application/x-tex">subscribe监听状态变化、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">ib</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">监听状态变化、</span></span></span></span></span>onAction监听方法执行，覆盖“修改-重置-监听”三大核心需求。</p>
<p>很多开发者用Pinia只停留在基础写法，忽略了这4个API的强大功能，导致代码冗余、状态管理混乱。本文聚焦四大API，从“用法+案例+避坑”三维度拆解，全程结合Vue3 + TS实操，看完直接套用。</p>
<h3 data-id="heading-2">二、前置准备：统一Store实例（两种写法通用）</h3>
<p>为了让API用法更直观，先定义一个通用的Pinia Store（同时兼容Option Store和Setup Store，后续API用法均基于此实例演示，避免重复）：</p>
<h4 data-id="heading-3">1. Option Store 实例（基础版）</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/stores/user.ts（Option Store）</span>
<span class="hljs-keyword">import</span> { defineStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">'user'</span>, {
  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> ({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">3</span>,
    <span class="hljs-attr">isLogin</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-attr">roles</span>: [<span class="hljs-string">'user'</span>]
  }),
  <span class="hljs-attr">getters</span>: {
    <span class="hljs-attr">fullName</span>: <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> <span class="hljs-string">`Mr. <span class="hljs-subst">${state.name}</span>`</span>
  },
  <span class="hljs-attr">actions</span>: {
    <span class="hljs-title function_">setLogin</span>(<span class="hljs-params">status: <span class="hljs-built_in">boolean</span></span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isLogin</span> = status
    },
    <span class="hljs-keyword">async</span> <span class="hljs-title function_">fetchUserInfo</span>(<span class="hljs-params"/>) {
      <span class="hljs-comment">// 模拟接口请求</span>
      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>({
        <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia Pro'</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">roles</span>: [<span class="hljs-string">'user'</span>, <span class="hljs-string">'admin'</span>]
      }), <span class="hljs-number">1000</span>))
      <span class="hljs-variable language_">this</span>.$patch(res) <span class="hljs-comment">// 后续会讲$patch用法</span>
    }
  }
})
</code></pre>
<h4 data-id="heading-4">2. Setup Store 实例（基础版）</h4>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// src/stores/user.ts（Setup Store）</span>
<span class="hljs-keyword">import</span> { defineStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'pinia'</span>
<span class="hljs-keyword">import</span> { ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useUserStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">'user'</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">'Pinia'</span>)
  <span class="hljs-keyword">const</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">3</span>)
  <span class="hljs-keyword">const</span> isLogin = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">const</span> roles = <span class="hljs-title function_">ref</span>([<span class="hljs-string">'user'</span>])

  <span class="hljs-keyword">const</span> fullName = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-string">`Mr. <span class="hljs-subst">${name.value}</span>`</span>)

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">setLogin</span> = (<span class="hljs-params">status: <span class="hljs-built_in">boolean</span></span>) =&gt; {
    isLogin.<span class="hljs-property">value</span> = status
  }

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUserInfo</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"/>) =&gt; {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia Pro'</span>,
      <span class="hljs-attr">age</span>: <span class="hljs-number">4</span>,
      <span class="hljs-attr">roles</span>: [<span class="hljs-string">'user'</span>, <span class="hljs-string">'admin'</span>]
    }), <span class="hljs-number">1000</span>))
    <span class="hljs-comment">// Setup Store 中$patch用法与Option Store一致</span>
    <span class="hljs-title function_">useUserStore</span>().$patch({
      <span class="hljs-attr">name</span>: res.<span class="hljs-property">name</span>,
      <span class="hljs-attr">age</span>: res.<span class="hljs-property">age</span>,
      <span class="hljs-attr">roles</span>: res.<span class="hljs-property">roles</span>
    })
  }

  <span class="hljs-keyword">return</span> {
    name, age, isLogin, roles,
    fullName,
    setLogin, fetchUserInfo
  }
})
</code></pre>
<p>关键说明：以下四大API的用法，<strong>完全适用于两种Store写法</strong>，仅Setup Store中操作ref状态时需注意.value，API调用逻辑完全一致，后续不再单独区分。</p>
<h3 data-id="heading-5">三、四大核心API详解（重点！用法+案例+避坑）</h3>
<p>按“修改状态→重置状态→监听状态→监听方法”的逻辑拆解，每个API都包含“核心作用+两种用法+实操案例+避坑点”，确保新手能看懂、会用。</p>
<h4 data-id="heading-6">1. $patch：批量修改状态（高效简洁，首选）</h4>
<h5 data-id="heading-7">核心作用</h5>
<p>用于<strong>批量修改多个状态</strong>，替代多次单独修改状态（如this.name = xxx、this.age = xxx），减少代码冗余，同时优化性能（Pinia会合并多次状态更新，减少组件重渲染）。</p>
<p>适用场景：一次性修改多个state属性（如接口请求后，同步更新多个状态）。</p>
<h5 data-id="heading-8">两种用法（均常用，按需选择）</h5>
<h6 data-id="heading-9">用法1：对象式（简单批量修改，首选）</h6>
<p>核心：传递一个对象，对象中的key对应state的属性名，value对应要修改的值，仅修改对象中包含的属性。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 1. 组件中使用（两种Store写法通用）</span>
<span class="hljs-keyword">import</span> { useUserStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/user'</span>

<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()

<span class="hljs-comment">// 批量修改name、age、isLogin三个状态</span>
userStore.$patch({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia Advanced'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>,
  <span class="hljs-attr">isLogin</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-comment">// 数组类型也可直接修改（覆盖式）</span>
  <span class="hljs-attr">roles</span>: [<span class="hljs-string">'admin'</span>]
})

<span class="hljs-comment">// 2. Option Store 的actions中使用</span>
<span class="hljs-attr">actions</span>: {
  <span class="hljs-title function_">updateUserInfo</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.$patch({ <span class="hljs-comment">// this指向当前Store实例</span>
      <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia Advanced'</span>,
      <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>
    })
  }
}
</code></pre>
<h6 data-id="heading-10">用法2：函数式（复杂修改，如数组操作）</h6>
<p>核心：传递一个函数，函数接收state作为参数，可在函数内部执行复杂的状态修改（如数组push、splice，对象深层修改），比对象式更灵活。</p>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 复杂修改案例：给roles数组添加新角色，同时修改age</span>
userStore.$patch(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
  state.<span class="hljs-property">roles</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">'superAdmin'</span>) <span class="hljs-comment">// 数组操作</span>
  state.<span class="hljs-property">age</span> += <span class="hljs-number">1</span> <span class="hljs-comment">// 计算后修改</span>
  <span class="hljs-comment">// 支持深层修改（若state有嵌套对象）</span>
  <span class="hljs-comment">// state.info.address = 'xxx'</span>
})

<span class="hljs-comment">// 对比：若用对象式，数组只能覆盖，无法直接push</span>
userStore.$patch({
  <span class="hljs-attr">roles</span>: [...userStore.<span class="hljs-property">roles</span>, <span class="hljs-string">'superAdmin'</span>] <span class="hljs-comment">// 需手动解构，繁琐</span>
})
</code></pre>
<h5 data-id="heading-11">避坑点</h5>
<ul>
<li>对象式$patch无法修改数组的单个元素（如roles[0] = 'admin'），需用函数式或解构数组；</li>
<li>Setup Store中，若直接在函数内操作ref状态，需用state.name.value（推荐直接用Store实例调用$patch，无需关注.value）。</li>
</ul>
<h4 data-id="heading-12">2. $reset：重置状态（一键恢复初始值）</h4>
<h5 data-id="heading-13">核心作用</h5>
<p>将Store的所有state属性，<strong>一键恢复到初始状态</strong>（即state选项/ref定义时的初始值），无需手动逐个重置，简化逻辑。</p>
<p>适用场景：退出登录、表单重置、页面刷新时，恢复Store初始状态。</p>
<h5 data-id="heading-14">用法（极简，无需复杂配置）</h5>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 组件中使用（两种Store写法通用）</span>
<span class="hljs-keyword">import</span> { useUserStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/user'</span>

<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()

<span class="hljs-comment">// 一键重置所有状态（name恢复为Pinia，age恢复为3，isLogin恢复为false）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReset</span> = (<span class="hljs-params"/>) =&gt; {
  userStore.$reset()
}

<span class="hljs-comment">// Option Store 的actions中使用</span>
<span class="hljs-attr">actions</span>: {
  <span class="hljs-title function_">logout</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setLogin</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 先执行自定义逻辑</span>
    <span class="hljs-variable language_">this</span>.$reset() <span class="hljs-comment">// 再重置状态</span>
  }
}
</code></pre>
<h5 data-id="heading-15">避坑点（重点！）</h5>
<ul>
<li>Setup Store中，$reset仅能重置“return中暴露的状态”，未暴露的局部状态无法重置；</li>
<li>若state中有嵌套对象，$reset会深度重置（即嵌套对象也恢复初始值），无需额外处理；</li>
<li>Option Store中，若state是箭头函数返回的对象，$reset才能生效（默认写法，无需担心）。</li>
</ul>
<h4 data-id="heading-16">3. $subscribe：监听状态变化（响应式感知）</h4>
<h5 data-id="heading-17">核心作用</h5>
<p>监听Store中<strong>所有state属性的变化</strong>（单个/多个属性变化均会触发），可获取变化前、变化后的值，用于执行副作用（如日志记录、本地存储同步）。</p>
<p>适用场景：状态变化后执行额外逻辑（如用户信息变化时，同步缓存到localStorage）。</p>
<h5 data-id="heading-18">用法（含配置项，灵活适配场景）</h5>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 组件中使用（两种Store写法通用）</span>
<span class="hljs-keyword">import</span> { useUserStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/user'</span>

<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()

<span class="hljs-comment">// 监听状态变化</span>
<span class="hljs-keyword">const</span> unsubscribe = userStore.$subscribe(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> {
  <span class="hljs-comment">// mutation：变化相关信息（核心属性如下）</span>
  <span class="hljs-comment">// mutation.storeId：当前Store的id（如user）</span>
  <span class="hljs-comment">// mutation.type：变化类型（direct：直接修改，patch：$patch修改）</span>
  <span class="hljs-comment">// mutation.payload：变化的内容（对象式$patch为修改对象，函数式为undefined）</span>
  
  <span class="hljs-comment">// state：变化后的最新状态（完整state对象）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'状态变化了'</span>, mutation, state)
  
  <span class="hljs-comment">// 示例：同步状态到localStorage</span>
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'userState'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))
}, {
  <span class="hljs-comment">// 可选配置项（按需开启）</span>
  <span class="hljs-attr">detached</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 默认为false，组件卸载后自动取消监听；true则组件卸载后仍监听</span>
  <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 默认为true，深度监听嵌套对象变化；false则不监听嵌套对象</span>
  <span class="hljs-attr">immediate</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 默认为false，初始化时不触发；true则初始化时立即触发一次</span>
})

<span class="hljs-comment">// 手动取消监听（如组件卸载时）</span>
<span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">unsubscribe</span>()
})

<span class="hljs-comment">// Option Store 的actions中使用（较少见，一般在组件中监听）</span>
<span class="hljs-attr">actions</span>: {
  <span class="hljs-title function_">initSubscribe</span>(<span class="hljs-params"/>) {
    <span class="hljs-variable language_">this</span>.$subscribe(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'状态变化'</span>, state)
    })
  }
}
</code></pre>
<h5 data-id="heading-19">避坑点</h5>
<ul>
<li>忘记手动取消监听（detached为false时，组件卸载会自动取消；detached为true时，需手动取消，否则会内存泄漏）；</li>
<li>deep设为false时，嵌套对象的变化不会触发$subscribe，需根据需求开启；</li>
<li>函数式$patch修改状态时，mutation.payload为undefined，无法获取具体变化内容。</li>
</ul>
<h4 data-id="heading-20">4. $onAction：监听方法执行（全生命周期感知）</h4>
<h5 data-id="heading-21">核心作用</h5>
<p>监听Store中<strong>所有actions方法的执行</strong>，可在方法执行前、执行后、执行报错时触发回调，用于拦截方法、日志记录、错误处理。</p>
<p>适用场景：拦截异步方法（如请求前loading、请求后处理）、记录方法执行日志、捕获方法报错。</p>
<h5 data-id="heading-22">用法（含生命周期回调，常用）</h5>
<pre><code class="hljs language-ts" lang="ts"><span class="hljs-comment">// 组件中使用（两种Store写法通用）</span>
<span class="hljs-keyword">import</span> { useUserStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/user'</span>

<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()

<span class="hljs-comment">// 监听所有actions方法的执行</span>
<span class="hljs-keyword">const</span> unsubscribe = userStore.$onAction(<span class="hljs-function">(<span class="hljs-params">{
  name, // 当前执行的actions方法名（如fetchUserInfo、setLogin）
  args, // 当前方法的参数数组（如setLogin的参数[<span class="hljs-literal">true</span>]）
  after, // 方法执行成功后触发的回调
  onError // 方法执行失败（报错）时触发的回调
}</span>) =&gt;</span> {
  <span class="hljs-comment">// 1. 方法执行前触发（可做拦截、loading等）</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>开始执行，参数：`</span>, args)
  <span class="hljs-keyword">const</span> loading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)

  <span class="hljs-comment">// 2. 方法执行成功后触发（可做后续处理）</span>
  <span class="hljs-title function_">after</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>执行成功，返回值：`</span>, result)
    loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
  })

  <span class="hljs-comment">// 3. 方法执行失败时触发（可做错误处理）</span>
  <span class="hljs-title function_">onError</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>执行失败，错误：`</span>, error)
    loading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span>
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">'操作失败，请重试'</span>)
  })
}, {
  <span class="hljs-comment">// 可选配置项</span>
  <span class="hljs-attr">detached</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// 与$subscribe一致，组件卸载后是否继续监听</span>
})

<span class="hljs-comment">// 手动取消监听</span>
<span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">unsubscribe</span>()
})

<span class="hljs-comment">// 示例：监听fetchUserInfo异步方法</span>
userStore.<span class="hljs-title function_">fetchUserInfo</span>() <span class="hljs-comment">// 会触发$onAction的所有回调</span>
</code></pre>
<h5 data-id="heading-23">避坑点</h5>
<ul>
<li>$onAction<strong>仅能监听actions中的方法</strong>，Setup Store中未返回的局部函数、组件中的普通函数，无法监听；</li>
<li>异步方法（如fetchUserInfo）中，after回调会在方法执行完成（await结束）后触发，onError捕获await中的报错；</li>
<li>多个方法同时执行时，$onAction会分别触发对应的回调，无需担心混淆。</li>
</ul>
<h3 data-id="heading-24">四、四大API对比总结（一目了然，快速选型）</h3>



































<table><thead><tr><th>API</th><th>核心作用</th><th>适用场景</th><th>关键注意点</th></tr></thead><tbody><tr><td>$patch</td><td>批量修改多个状态</td><td>接口请求后同步更新状态、一次性修改多属性</td><td>函数式适配复杂修改，对象式简洁首选</td></tr><tr><td>$reset</td><td>一键重置所有状态为初始值</td><td>退出登录、表单重置、页面刷新</td><td>Setup Store仅重置暴露的状态</td></tr><tr><td>$subscribe</td><td>监听所有state变化</td><td>状态变化后同步缓存、日志记录</td><td>注意取消监听，避免内存泄漏</td></tr><tr><td>$onAction</td><td>监听actions方法执行（全生命周期）</td><td>异步请求拦截、错误处理、方法日志</td><td>仅监听actions中的方法，不监听局部函数</td></tr></tbody></table>
<h3 data-id="heading-25">五、实战综合案例（四大API联用，贴近真实开发）</h3>
<p>结合“用户信息管理”场景，联用四大API，实现“修改用户信息→监听状态变化→缓存到本地→重置状态→监听方法报错”的完整逻辑，代码可直接复制套用：</p>
<pre><code class="hljs language-ts" lang="ts">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"user-manager"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>用户信息管理<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：{{ userStore.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>年龄：{{ userStore.age }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>角色：{{ userStore.roles.join(',') }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"updateUser"</span>&gt;</span>修改用户信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"resetUser"</span>&gt;</span>重置用户信息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"fetchUser"</span>&gt;</span>获取用户信息（异步）<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"ts"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { useUserStore } <span class="hljs-keyword">from</span> <span class="hljs-string">'@/stores/user'</span>
<span class="hljs-keyword">import</span> { onUnmounted } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">ElMessage</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'element-plus'</span>

<span class="hljs-keyword">const</span> userStore = <span class="hljs-title function_">useUserStore</span>()

<span class="hljs-comment">// 1. 监听状态变化，同步到localStorage</span>
<span class="hljs-keyword">const</span> unsubscribeSub = userStore.$subscribe(<span class="hljs-function">(<span class="hljs-params">_, state</span>) =&gt;</span> {
  <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">'userState'</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(state))
  <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">'用户状态已同步缓存'</span>)
})

<span class="hljs-comment">// 2. 监听actions方法执行，处理loading和错误</span>
<span class="hljs-keyword">const</span> unsubscribeAction = userStore.$onAction(<span class="hljs-function">(<span class="hljs-params">{ name, after, onError }</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>开始执行`</span>)
  <span class="hljs-keyword">const</span> loading = <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">info</span>({ <span class="hljs-attr">message</span>: <span class="hljs-string">'操作中...'</span>, <span class="hljs-attr">duration</span>: <span class="hljs-number">0</span> })
  
  <span class="hljs-title function_">after</span>(<span class="hljs-function">() =&gt;</span> {
    loading.<span class="hljs-title function_">close</span>()
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">success</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>执行成功`</span>)
  })
  
  <span class="hljs-title function_">onError</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    loading.<span class="hljs-title function_">close</span>()
    <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`方法<span class="hljs-subst">${name}</span>执行失败：<span class="hljs-subst">${err.message}</span>`</span>)
  })
})

<span class="hljs-comment">// 3. 批量修改用户信息（$patch）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">updateUser</span> = (<span class="hljs-params"/>) =&gt; {
  userStore.$patch({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'Pinia 实战'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">6</span>,
    <span class="hljs-attr">roles</span>: [<span class="hljs-string">'user'</span>, <span class="hljs-string">'admin'</span>, <span class="hljs-string">'superAdmin'</span>]
  })
}

<span class="hljs-comment">// 4. 重置用户信息（$reset）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">resetUser</span> = (<span class="hljs-params"/>) =&gt; {
  userStore.$reset()
}

<span class="hljs-comment">// 5. 异步获取用户信息（调用actions，触发$onAction）</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchUser</span> = (<span class="hljs-params"/>) =&gt; {
  userStore.<span class="hljs-title function_">fetchUserInfo</span>()
}

<span class="hljs-comment">// 6. 组件卸载，取消所有监听</span>
<span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-title function_">unsubscribeSub</span>()
  <span class="hljs-title function_">unsubscribeAction</span>()
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 data-id="heading-26">六、总结：核心要点（新手必背）</h3>
<ol>
<li>四大API是Pinia进阶的核心，覆盖“修改-重置-监听”全流程，学会后能大幅提升状态管理效率；</li>
<li>$patch：批量修改首选，对象式简洁、函数式灵活，优化性能减少重渲染；</li>
<li>$reset：一键重置，注意Setup Store仅重置暴露的状态；</li>
<li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">subscribe/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"/><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">ib</span><span class="mord mathnormal">e</span><span class="mord">/</span></span></span></span></span>onAction：监听状态和方法，务必记得取消监听（避免内存泄漏），按需配置detached、deep；</li>
<li>两种Store写法（Setup/Option）中，四大API用法完全一致，仅Setup Store操作ref需注意.value。</li>
</ol>
<p>其实这4个API的用法并不复杂，核心是“贴合场景选择”——批量修改用<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mtext>，重置用</mtext></mrow><annotation encoding="application/x-tex">patch，重置用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"/><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">c</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">，重置用</span></span></span></span></span>reset，监听状态用<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>e</mi><mtext>，监听方法用</mtext></mrow><annotation encoding="application/x-tex">subscribe，监听方法用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"/><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.02778em;">scr</span><span class="mord mathnormal">ib</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">，监听方法用</span></span></span></span></span>onAction。结合本文的案例多练几遍，就能灵活运用到实际项目中，彻底吃透Pinia的强大之处～</p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item><item>    <title><![CDATA[OSPF协议笔记整理]]></title>    <link>https://juejin.cn/post/7603643385816039476</link>    <guid>https://juejin.cn/post/7603643385816039476</guid>    <pubDate>2026-02-07T13:52:07.000Z</pubDate>    <description><![CDATA[<article itemscope="itemscope" itemtype="http://schema.org/Article" data-entry-id="7603643385816039476" data-draft-id="7603574149776932916" data-original-type="0" class="article" data-v-61fb5e44=""><!----> <meta itemprop="headline" content="OSPF协议笔记整理"/> <meta itemprop="keywords" content="网络协议"/> <meta itemprop="datePublished" content="2026-02-07T13:52:07.000Z"/> <meta itemprop="image" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-128.png~tplv-t2oaga2asx-image.image"/> <div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="不做菜鸟的网工"/> <meta itemprop="url" content="https://juejin.cn/user/3283597248432442"/></div> <div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"/> <div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-assets/icon/icon-white-180.png~tplv-t2oaga2asx-image.image"/> <meta itemprop="width" content="180"/> <meta itemprop="height" content="180"/></div></div> <h1 class="article-title" data-v-61fb5e44="">
            OSPF协议笔记整理
            <!----> <!----></h1> <div class="author-info-block block-hidden" data-v-61fb5e44=""><div class="author-info-box" data-v-61fb5e44=""><div class="author-name" data-v-61fb5e44=""><a href="/user/3283597248432442/posts" target="_blank" rel="" class="jj-link username username ellipsis" data-v-65b50b51="" data-v-292f6e48="" data-v-61fb5e44=""><span class="name" style="max-width:160px;" data-v-65b50b51="" data-v-292f6e48="">
    不做菜鸟的网工
  </span> <!----> <!----> <!----> </a></div> <div class="meta-box" data-v-61fb5e44=""><time datetime="2026-02-07T13:52:07.000Z" title="Sat Feb 07 2026 13:52:07 GMT+0000 (Coordinated Universal Time)" class="time" data-v-61fb5e44="">
                    2026-02-07
                  </time> <svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="read-icon" data-v-61fb5e44=""><path d="M7.90078 2.80078C4.49278 2.80078 1.74745 6.11672 0.800781 7.77469C1.74745 9.58339 4.49278 13.2008 7.90078 13.2008C11.3088 13.2008 14.0541 9.58339 15.0008 7.77469C14.0541 6.11672 11.3088 2.80078 7.90078 2.80078Z" stroke="currentColor" data-v-61fb5e44=""/><circle cx="7.89922" cy="8.00078" r="2.2" stroke="currentColor" data-v-61fb5e44=""/></svg> <span class="views-count" data-v-61fb5e44="">
                    2
                  </span> <span class="read-time" data-v-61fb5e44=""><svg width="16" height="16" viewbox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-61fb5e44=""><rect width="16" height="16" fill="none" data-v-61fb5e44=""/><circle cx="8" cy="8" r="5.65625" stroke="#8A919F" data-v-61fb5e44=""/><path d="M7.69141 5.18652V8.30924H10.8141" stroke="#8A919F" stroke-linecap="round" stroke-linejoin="round" data-v-61fb5e44=""/></svg>
                    阅读13分钟
                  </span> <!----></div></div> <div style="flex:1;" data-v-61fb5e44=""/> <!----> <!----></div> <!----> <!----> <!----> <!----> <div id="article-root" itemprop="articleBody" class="main" data-v-61fb5e44=""><div class="article-viewer markdown-body result"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre&gt;code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote&gt;p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre&gt;code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><h2 data-id="heading-0">OSPF协议</h2>
<blockquote>
<p>基于链路状态、工作在网络层之上的路由协议</p>
</blockquote>
<hr/>
<h3 data-id="heading-1">目录</h3>
<ol>
<li><a href="#ospf%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B" title="#ospf%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B">OSPF报文类型</a></li>
<li><a href="#ospf%E7%8A%B6%E6%80%81%E6%9C%BA" title="#ospf%E7%8A%B6%E6%80%81%E6%9C%BA">OSPF状态机</a></li>
<li><a href="#ospf%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6" title="#ospf%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6">OSPF确认机制</a></li>
<li><a href="#ospf%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E4%B8%8E%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98" title="#ospf%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E4%B8%8E%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98">OSPF邻接关系建立与路由计算问题</a></li>
<li><a href="#ospf%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B" title="#ospf%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B">OSPF网络类型</a></li>
<li><a href="#ospf%E5%BC%80%E9%94%80%E5%80%BC%E8%AE%A1%E7%AE%97" title="#ospf%E5%BC%80%E9%94%80%E5%80%BC%E8%AE%A1%E7%AE%97">OSPF开销值计算</a></li>
<li><a href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Elsa" title="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Elsa">链路状态数据库与LSA</a></li>
<li><a href="#ospf%E5%9F%9F%E5%86%85%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97" title="#ospf%E5%9F%9F%E5%86%85%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97">OSPF域内路由计算</a></li>
<li><a href="#ospf%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97" title="#ospf%E5%9F%9F%E9%97%B4%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97">OSPF域间路由计算</a></li>
<li><a href="#ospf%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97" title="#ospf%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97">OSPF外部路由计算</a></li>
<li><a href="#ospf%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F" title="#ospf%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F">OSPF特殊区域</a></li>
<li><a href="#OSPF%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%A1%A8%E4%BC%98%E5%85%88%E7%BA%A7" title="#OSPF%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%A1%A8%E4%BC%98%E5%85%88%E7%BA%A7">路由加表优先级</a></li>
</ol>
<hr/>
<h3 data-id="heading-2">OSPF报文类型</h3>
<p>OSPF使用五种类型的报文来建立邻接、同步数据库并计算路由。</p>
<ol>
<li>
<p><strong>Hello报文</strong></p>
<ul>
<li><strong>功能</strong>：用于发现、建立并维持邻居关系。包含Router ID、区域ID、接口认证等信息。</li>
<li><strong>组播地址</strong>：<code>224.0.0.5</code>。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3544dd481fbb40bf89eac72a91d75373~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=Bv0Ew21BbWj0JH2A2gUC%2FAahDc4%3D" alt="HELLO报文.png" loading="lazy"/></li>
</ul>
</li>
<li>
<p><strong>数据库描述报文</strong></p>
<ul>
<li>
<p><strong>功能</strong>：</p>
<ol>
<li><strong>选举主从设备</strong>，确保DD报文交换有序。</li>
<li>携带<strong>链路状态数据库摘要</strong>，即LSA头部信息，用于数据库同步。</li>
</ol>
</li>
<li>
<p><strong>特性</strong>：可以包含多个DD报文。携带MTU值，若两端MTU不匹配且开启检测，可能导致邻接建立失败。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/ad1fb4f069eb4751a31f32b5d3fc1829~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=VlsrHuL0QGsVYAIAuTSW4RCDmWQ%3D" alt="DD报文.png" loading="lazy"/></p>
</li>
<li>
<p><strong>MTU问题</strong>：当MTU不匹配时，邻居状态会卡在<code>ExStart</code>/<code>ExChange</code>。</p>
</li>
</ul>
</li>
<li>
<p><strong>链路状态请求报文</strong></p>
<ul>
<li><strong>功能</strong>：在收到邻居的DD报文后，向对方请求本机缺失或需要更新的<strong>完整LSA信息</strong>。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/c72824097b2142ab9a0a70c6ad64e4d3~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=Yb7RrN%2FVDt5ofbyvc4bbv10VS7Q%3D" alt="LSR报文.png" loading="lazy"/></li>
</ul>
</li>
<li>
<p><strong>链路状态更新报文</strong></p>
<ul>
<li><strong>功能</strong>：用于回复LSR请求，或主动泛洪更新，包含一个或多个<strong>完整的LSA</strong>。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/99746a834cff4a56b8bf1fc75e03e96b~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=IUTrVN4mGpN6qS1mFx1ZYs1p1eU%3D" alt="LSU报文.png" loading="lazy"/></li>
</ul>
</li>
<li>
<p><strong>链路状态确认报文</strong></p>
<ul>
<li><strong>功能</strong>：对收到的LSU报文进行确认，确保LSA的可靠泛洪。确认信息为LSA头部。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2d4b2091ad694e07925e3bb20aa36d5c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=Ro3iNQNxX8ou%2FjKUf6zFNQq%2B330%3D" alt="LSACK报文.png" loading="lazy"/></li>
</ul>
</li>
</ol>
<h3 data-id="heading-3">OSPF状态机</h3>
<p>OSPF邻接建立过程经历一系列状态，以下是关键节点：</p>
<p><img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/31b234fe63224beb828954d48b313bcd~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=kMxVHj6dXDh9hilRu9T%2BjdVXT9U%3D" alt="DD_state.png" loading="lazy"/></p>
<ol>
<li>
<p><strong>Down -&gt; Init -&gt; 2-Way</strong></p>
<ul>
<li><code>Init</code>：收到对端Hello包，但其中未包含自己的Router ID。</li>
<li><code>2-Way</code>：收到对端Hello包，且其中包含自己的Router ID。<strong>邻居关系</strong>建立。在广播网络中，此时选举DR/BDR。</li>
</ul>
</li>
<li>
<p><strong>2-Way -&gt; ExStart</strong></p>
<ul>
<li>邻居关系建立后，立即进入<code>ExStart</code>状态，通过交换<strong>空的DD报文</strong>（<code>M=1，MS=1</code>）进行<strong>主从选举</strong>。Router ID大者为主。</li>
</ul>
</li>
<li>
<p><strong>ExStart -&gt; Exchange</strong></p>
<ul>
<li><strong>从设备</strong>：在发出第一个携带摘要的DD报文后，状态变为<code>Exchange</code>。</li>
<li><strong>主设备</strong>：在接收到从设备的DD报文并回复自己的DD报文后，状态变为<code>Exchange</code>。双方开始交换完整的数据库摘要。</li>
</ul>
</li>
<li>
<p><strong>Exchange -&gt; Loading</strong></p>
<ul>
<li>摘要交换完成后，双方根据对比结果，向对方发送<strong>LSR</strong>请求缺失的LSA，状态进入<code>Loading</code>。同时，使用<code>LSU</code>和<code>LSACK</code>来传输和确认具体的LSA内容。</li>
</ul>
</li>
<li>
<p><strong>Loading -&gt; Full</strong></p>
<ul>
<li>所有请求的LSA交换并确认完毕后，邻居状态进入<code>Full</code>。<strong>邻接关系</strong>建立完成，可以开始路由计算。</li>
</ul>
</li>
</ol>
<p><strong>总结流程</strong>：寻找邻居(<code>Init</code>) -&gt; 建立邻居(<code>2-Way</code>) -&gt; 选举主从(<code>ExStart</code>) -&gt; 交换摘要(<code>Exchange</code>) -&gt; 请求并加载详细信息(<code>Loading</code>) -&gt; 完全邻接(<code>Full</code>)。</p>
<h3 data-id="heading-4">OSPF确认机制</h3>
<p>OSPF通过多种方式确保报文可靠传递：</p>
<ol>
<li><strong>Hello报文</strong>：周期性发送（默认10秒），通过超时机制（Dead Time，默认40秒）确认邻居存活。</li>
<li><strong>DD报文</strong>：使用<strong>序列号和主从关系进行隐式确认</strong>。
<ul>
<li>从设备使用主设备的序列号发起请求。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0e64344cf8f94a97af0067fdbd60c2d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=XWvZX09H0jLkLWenD%2B9%2BTG8M3n4%3D" alt="DDseq隐式确认从.png" loading="lazy"/></li>
<li>主设备以从设备序列号+1进行回复。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/e76e270d27da45aead1f4923d490272c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=SDoa22ElPoKVn7v9WS3UyfgNhME%3D" alt="DDseq隐式确认主.png" loading="lazy"/></li>
</ul>
</li>
<li><strong>LSR报文</strong>：通过接收对应的<code>LSU</code>报文进行确认。</li>
<li><strong>LSU报文</strong>：通过接收<code>LSACK</code>报文进行显式确认。若超时未收到确认，则重传。</li>
</ol>
<h3 data-id="heading-5">OSPF邻接关系建立与路由计算问题</h3>
<h4 data-id="heading-6">邻接建立失败常见原因</h4>
<ol>
<li>接口网络类型不一致（如一端为广播，另一端为点对点）。</li>
<li>区域ID不一致。</li>
<li>Router ID冲突。</li>
<li>接口MTU不匹配且开启了检测。</li>
<li>认证类型或密钥不匹配。</li>
<li>Hello/Dead时间间隔不一致。</li>
<li>接口被配置为静默接口。</li>
<li>网络掩码不匹配（仅在广播/NBMA网络中有影响）。</li>
<li>链路层故障。</li>
</ol>
<h4 data-id="heading-7">邻接建立成功但路由计算失败</h4>
<ol>
<li><strong>网络类型不匹配导致LSA缺失</strong>：例如，一端为点对点，另一端为广播。点对点端不产生<strong>2类LSA</strong>，导致广播端设备无法正确计算路由。</li>
<li><strong>静默接口</strong>：接口被静默后，不收发OSPF报文，但该接口所在网段仍会被通告（生成1类LSA）。邻居无法建立，路由自然无法通过该接口计算。</li>
</ol>
<h3 data-id="heading-8">OSPF网络类型</h3>
<p>OSPF接口网络类型决定了其行为方式，特别是邻居发现和DR选举。</p>








































<table><thead><tr><th align="left">网络类型</th><th align="left">默认链路协议</th><th align="left">DR/BDR选举</th><th align="left">Hello/Dead时间</th><th align="left">组播地址</th></tr></thead><tbody><tr><td align="left"><strong>广播</strong></td><td align="left">以太网</td><td align="left"><strong>是</strong></td><td align="left">10s/40s</td><td align="left">224.0.0.5, 224.0.0.6</td></tr><tr><td align="left"><strong>点到点</strong></td><td align="left">PPP/HDLC</td><td align="left"><strong>否</strong></td><td align="left">10s/40s</td><td align="left">224.0.0.5</td></tr><tr><td align="left"><strong>NBMA</strong></td><td align="left">帧中继/ATM</td><td align="left"><strong>是</strong></td><td align="left">30s/120s</td><td align="left"><strong>单播</strong> (需手动指定<code>peer</code>)</td></tr><tr><td align="left"><strong>点到多点</strong></td><td align="left">无默认，常手动配置</td><td align="left"><strong>否</strong></td><td align="left">30s/120s</td><td align="left">Hello: 224.0.0.5; 其他: 单播</td></tr></tbody></table>
<h4 data-id="heading-9">广播网络类型详解</h4>
<p>在广播网络中，DR和BDR的交互至关重要。</p>
<ul>
<li><strong>DR/BDR选举</strong>：基于接口优先级（默认1）和Router ID（越大越优）。优先级为0不参与选举。</li>
<li><strong>通信流程</strong>：
<ul>
<li><code>Drother</code>之间保持<code>2-Way</code>状态。</li>
<li>所有路由器与<code>DR/BDR</code>建立<code>Full</code>状态。</li>
<li>所有路由器向<code>DR</code>和<code>BDR</code>发送组播地址<code>224.0.0.6</code>。</li>
<li><code>DR</code>向所有其他路由器(<code>224.0.0.5</code>)泛洪更新。</li>
</ul>
</li>
<li><strong>交互示例</strong>：
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/5913eaf5bf944704bae025b06f6d446c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=0JtJt2nbuMUrOnJg6L9LSuhGcLA%3D" alt="拓扑.png" loading="lazy"/>
<ul>
<li><code>Drother</code>更新：发送至<code>224.0.0.6</code> (DR/BDR)。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/88a6db69a782492ca5f355a328d5c8d7~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=1ArD0CAIsJnURXTdOXc%2Fz8L3ymI%3D" alt="R1_update.png" loading="lazy"/></li>
<li><code>DR</code>更新：发送至<code>224.0.0.5</code> (所有OSPF路由器)。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fc64a00c86c4491f912ea6d7e1617c84~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=M1F1atxJUF8PIrFW%2Fpz%2B3LOBTUQ%3D" alt="R4_update.png" loading="lazy"/></li>
</ul>
</li>
</ul>
<h3 data-id="heading-10">OSPF开销值计算</h3>
<ol>
<li>
<p><strong>计算公式</strong>：<code>接口Cost = 参考带宽 / 接口实际带宽</code>。参考带宽默认为100 Mbps。</p>
<ul>
<li>结果小于1时取1。</li>
<li>最终路径开销是数据传出方向的<strong>沿途出接口Cost累加值</strong>。</li>
</ul>
</li>
<li>
<p><strong>修改方法</strong>：</p>
<ul>
<li><strong>直接修改接口Cost</strong>：<code>[接口视图] ospf cost &lt;值&gt;</code>。</li>
<li><strong>修改参考带宽</strong>：<code>[OSPF视图] bandwidth-reference &lt;值&gt;</code> (<strong>区域内所有路由器需一致</strong>)。</li>
<li>环回接口的默认Cost为0。</li>
</ul>
</li>
<li>
<p><strong>静默接口</strong>：配置后，接口<strong>不收发OSPF报文</strong>，但<strong>其网络仍会被通告</strong>。</p>
<ul>
<li><strong>作用</strong>：常用于避免在特定接口（如连接终端的接口）上建立不必要的邻居关系，或解决次优路径问题。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/9400da78199a4cffa2d429f99572f10c~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=LmgbbD2%2Fs0kOm77msvPQAsuCElM%3D" alt="静默接口作用.png" loading="lazy"/></li>
<li><strong>配置</strong>：
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 黑名单模式（推荐）</span>
[ospf-1] silent-interface GigabitEthernet 0/0
<span class="hljs-comment"># 白名单模式</span>
[ospf-1] silent-interface all
[ospf-1] undo silent-interface GigabitEthernet 0/1
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 data-id="heading-11">链路状态数据库与LSA</h3>
<p><strong>LSDB同步原则</strong>：</p>
<ul>
<li><strong>触发更新</strong>：当链路状态发生变化时。</li>
<li><strong>周期更新</strong>：每条LSA的老化时间(<code>Age</code>)达到1800秒时，始发路由器会重新泛洪一次，刷新<code>Age</code>。最大<code>Age</code>为3600秒。</li>
</ul>
<h4 data-id="heading-12">LSA头部与三要素</h4>
<p>所有LSA拥有公共的头部，其中关键字段包括：</p>
<ul>
<li><strong>LS Type</strong>：LSA类型。</li>
<li><strong>Link State ID</strong>：LSA标识符。</li>
<li><strong>Advertising Router</strong>：始发路由器Router ID。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3fc16c8fd3c94a5f8a66b75d51b27f41~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=f1nov8FnZc9dD%2F0WLGBk82tAblE%3D" alt="LSA头部信息.png" loading="lazy"/>
<strong>LSA三要素</strong>：<code>LS Type</code> + <code>Link State ID</code> + <code>Advertising Router</code> 共同<strong>唯一标识</strong>一条LSA。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8d372fbe25c84e52b7014b7050d2cb61~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=ASH3tKAYc7Q1EKw3LSPWaueyAXs%3D" alt="LSA标识.png" loading="lazy"/></li>
</ul>
<h3 data-id="heading-13">OSPF域内路由计算</h3>
<p><strong>路由器使用SPF算法，以自己为根，计算到达所有网络的最短路径树。</strong></p>
<h4 data-id="heading-14">1类LSA</h4>
<ul>
<li><strong>功能</strong>：描述<strong>路由器自身</strong>的直连链路状态，并标识自身角色（如ABR、ASBR）。</li>
<li><strong>内容</strong>：
<ul>
<li><strong>StubNet Link</strong>：描述一条直连路由（<strong>叶子</strong>）。包含网络号、掩码和开销。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/1bf8a29509c445af92639f775eacb126~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=WZ4j1CY5VbXCsbxAU2ZtTenI9Hg%3D" alt="1类LS信息.png" loading="lazy"/></li>
<li><strong>P-2-P Link</strong>：描述一个点对点邻居（<strong>树干</strong>）。包含邻居Router ID、本地接口IP和开销。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/248fbea6159c457da8b0d931df14d8d1~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=33EYf%2BAsWYzyuSnWqulP7ewgxFU%3D" alt="1类LS信息-邻居.png" loading="lazy"/></li>
</ul>
</li>
</ul>
<h4 data-id="heading-15">2类LSA</h4>
<ul>
<li><strong>产生条件</strong>：仅在<strong>广播或NBMA</strong>网络中，由<strong>DR</strong>产生。</li>
<li><strong>功能</strong>：描述一个<strong>伪节点</strong>，代表该多路访问网络本身。包含该网络掩码和所有连接到此DR的路由器列表（Attached Router）。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/8e540647e7a34845b6921d16965d04a4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=53qSPK2u16yITj1Ep1yd%2BRHwa4I%3D" alt="TransNet.png" loading="lazy"/></li>
<li><strong>伪节点的Cost为0</strong>。1类和2类LSA仅在<strong>区域内</strong>泛洪。</li>
</ul>
<h3 data-id="heading-16">OSPF域间路由计算</h3>
<h4 data-id="heading-17">区域设计原则</h4>
<ol>
<li>骨干区域（Area 0）必须存在且唯一。</li>
<li>所有非骨干区域必须与骨干区域直接相连。</li>
</ol>
<h4 data-id="heading-18">3类LSA</h4>
<ul>
<li><strong>产生者</strong>：<strong>区域边界路由器</strong>。</li>
<li><strong>功能</strong>：描述<strong>域间路由</strong>信息。ABR将一个区域内的最优路由（由1/2类LSA计算得出）转换为3类LSA，泛洪到其他区域。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/935b35d736d447f8a10fd1a0ad95ea05~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=YlsFx79n5cluE4lHaBZ5XYbUM2Y%3D" alt="三类LSA.png" loading="lazy"/></li>
<li><strong>关键规则（防环）</strong>：
<ol>
<li>ABR<strong>不会</strong>将非骨干区域的3类LSA注入骨干区域。</li>
<li>ABR<strong>只将骨干区域的3类LSA</strong>注入非骨干区域。</li>
<li>区域内路由（1/2类）优先级高于域间路由（3类），即使后者Cost更优。</li>
</ol>
</li>
</ul>
<h4 data-id="heading-19">ABR</h4>
<ul>
<li><strong>定义</strong>：连接多个区域，且在骨干区域至少有一个活跃接口的路由器。</li>
<li><strong>功能</strong>：汇总并传递3类LSA。其1类LSA中<code>B-bit</code>（Border位）被置位，标识其ABR身份。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/a888ee794c1c4216b6ba81aa6f4c4c29~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=udMWC%2FMqtN5sbaRjfVDS9AV9Sl8%3D" alt="ABR标识.png" loading="lazy"/></li>
</ul>
<h4 data-id="heading-20">虚链路</h4>
<ul>
<li><strong>作用</strong>：
<ol>
<li>将非骨干区域逻辑连接到骨干区域（解决区域0被分割问题）。</li>
<li>提供一条经过非骨干区域的骨干区域路径（优化Cost）。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/466f9f29c17c444e8f75e6b60030e0ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=x4sBcBMGf6e2886cdRxOrrorXLY%3D" alt="优化路径.png" loading="lazy"/></li>
</ol>
</li>
<li><strong>限制</strong>：只能穿越一个非骨干区域，且不能穿越特殊区域。</li>
</ul>
<h3 data-id="heading-21">OSPF外部路由计算</h3>
<h4 data-id="heading-22">5类LSA</h4>
<ul>
<li><strong>产生者</strong>：<strong>自治系统边界路由器</strong>。</li>
<li><strong>功能</strong>：描述<strong>引入到OSPF的外部路由</strong>（如静态路由、直连路由或其他协议路由）。在整个OSPF域内泛洪。</li>
<li><strong>关键字段</strong>：
<ul>
<li><strong>E Type</strong>：开销值类型。
<ul>
<li><strong>Type 1</strong>：外部开销 + 内部到达ASBR的开销。<code>总开销 = 种子度量值 + 内部开销</code>。</li>
<li><strong>Type 2（默认）</strong>：仅考虑外部种子度量值。<code>总开销 = 种子度量值</code>。</li>
</ul>
</li>
<li><strong>Forwarding Address</strong>：转发地址。若非0.0.0.0，则数据包直接发往FA地址而非ASBR，用于优化路径。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/97122f6da35a49b88b50f18a14d2f280~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=zI89817FN5luIu6MmnQtE9XtK00%3D" alt="ospf_import.png" loading="lazy"/></li>
</ul>
</li>
</ul>
<h4 data-id="heading-23">4类LSA</h4>
<ul>
<li><strong>产生者</strong>：<strong>ABR</strong>。</li>
<li><strong>功能</strong>：描述<strong>如何到达ASBR</strong>。当ASBR不在本区域时，ABR会生成4类LSA，指明到达该ASBR的路径和开销。</li>
<li><strong>关系</strong>：<strong>有5类LSA不一定有4类LSA</strong>（ASBR在同一个区域时，无需4类LSA）。<strong>有4类LSA一定有5类LSA</strong>。</li>
</ul>
<h4 data-id="heading-24">默认路由注入</h4>
<ul>
<li>在ASBR上配置<code>default-route-advertise</code>，可将缺省路由以5类LSA形式注入OSPF域。</li>
<li>使用<code>always</code>参数，即使本机路由表无默认路由，也会强制下发。</li>
</ul>
<h3 data-id="heading-25">OSPF特殊区域</h3>
<p>用于减少非骨干区域内的LSA数量，优化设备性能。主要通过过滤特定LSA实现。</p>









































<table><thead><tr><th align="left">区域类型</th><th align="left">功能描述</th><th align="left">泛洪的LSA类型</th><th align="left">ABR下发的缺省路由类型</th></tr></thead><tbody><tr><td align="left"><strong>骨干区域/普通区域</strong></td><td align="left">标准区域，泛洪所有LSA</td><td align="left">1, 2, 3, 4, 5</td><td align="left">无</td></tr><tr><td align="left"><strong>Stub区域</strong></td><td align="left">过滤4、5类LSA</td><td align="left">1, 2, 3</td><td align="left"><strong>3类LSA</strong> (自动)</td></tr><tr><td align="left"><strong>Totally Stub区域</strong></td><td align="left">过滤3, 4, 5类LSA</td><td align="left">1, 2</td><td align="left"><strong>3类LSA</strong> (自动)</td></tr><tr><td align="left"><strong>NSSA区域</strong></td><td align="left">过滤4、5类LSA，但允许引入外部路由(以7类LSA形式)</td><td align="left">1, 2, 3, <strong>7</strong></td><td align="left"><strong>7类LSA</strong> (通常需手动<code>default-route-advertise</code>)</td></tr><tr><td align="left"><strong>Totally NSSA区域</strong></td><td align="left">过滤3, 4, 5类LSA，允许引入外部路由(7类)</td><td align="left">1, 2, <strong>7</strong></td><td align="left"><strong>3类LSA</strong> (自动) &amp; <strong>7类LSA</strong></td></tr></tbody></table>
<h4 data-id="heading-26">关键特性对比</h4>
<ul>
<li><strong>Option字段</strong>：
<ul>
<li><code>E-bit</code>：处理<strong>5类LSA</strong>能力。Stub和NSSA区域该位为0。</li>
<li><code>N-bit</code>：处理<strong>7类LSA</strong>能力。仅NSSA区域该位为1。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0ade331a4cda4f719a1d21d219b190ef~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=EcmNPLVTzgvJcPxIZmtm881Bo0I%3D" alt="NSSA_HELLO报文.png" loading="lazy"/></li>
</ul>
</li>
<li><strong>7类LSA</strong>：
<ul>
<li>仅在NSSA区域内泛洪。</li>
<li>由NSSA区域的<strong>ABR</strong>转换为5类LSA后，泛洪到其他区域。通常由Router ID最大的ABR执行转换。</li>
<li>FA地址通常不为0，以优化路径。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/2909085448bb4ef8b06f3c62ecf8e685~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=%2BjhXfteyok2aVJx%2FLBs5FSmptm4%3D" alt="7类LSA.png" loading="lazy"/></li>
</ul>
</li>
<li><strong>多ABR问题</strong>：Stub/NSSA区域存在多个ABR时，每个ABR都会下发缺省路由，可能导致区域内设备负载分担，引发次优路径。需通过调整接口Cost、缺省路由Cost或路由策略进行干预。
<img src="https://p3-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/fe0561e9d8d241f6ae82834c3789db83~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5LiN5YGa6I-c6bif55qE572R5bel:q75.awebp?rk3s=f64ab15b&amp;x-expires=1771077389&amp;x-signature=F%2BHlUSrrAzKab9umdLzPJiuU2Gk%3D" alt="Stub次优路径问题.png" loading="lazy"/></li>
</ul>
<h3 data-id="heading-27">OSPF路由加表优先级</h3>
<p>域内路由 &gt; 域间路由 &gt; 外部路由Type1 &gt; 外部路由Type2 &gt; NSSA区域外部路由Type1 &gt; NSSA区域外部路由Type2</p>
<p>相同优先级，比开销。如果开销一直，则进行<strong>等价多路径</strong>负载均衡（默认最多4条）。</p>
<hr/>
<h2 data-id="heading-28">MTU不一致会导致OSPF协商失败，什么场景要改MTU？</h2>
<p><strong>问题现象</strong>：如标题所述，当OSPF接口MTU不匹配且开启检测时，邻居状态会卡在<code>ExStart</code>或<code>ExChange</code>，导致邻接无法建立。</p>
<p><strong>问题根源</strong>：OSPF在ExStart状态交换DD报文进行主从选举时，报文中会携带本接口的MTU值。如果对端接口的MTU值小于此值，且开启MTU检测（某些厂商默认开启，如思科；华为/华三默认不检测），对端将拒绝处理此报文，导致协商失败。</p>
<p><strong>那么，什么情况下我们需要主动修改接口的MTU值？</strong></p>
<p><strong>核心场景：隧道封装</strong>。这是最常见且最重要的原因，如<strong>GRE隧道</strong>场景。</p>
<ol>
<li>
<p><strong>原理分析</strong>：</p>
<ul>
<li>标准以太网的<strong>MTU默认是1500字节</strong>，这意味着一个数据帧所能承载的IP报文最大为1500字节。</li>
<li>当我们在两个站点间建立<strong>GRE隧道</strong>时，原始IP报文（假设正好1500字节）会被封装上新的<strong>GRE头部</strong>和<strong>外层IP头部</strong>。这使得报文总长度<strong>超过了1500字节</strong>。</li>
<li>当这个“变胖”的报文被发送到物理接口（MTU=1500）时，接口会发现它超出了自己的MTU限制，从而触发<strong>IP分片</strong>。报文被拆分成多个片段传输。</li>
</ul>
</li>
<li>
<p><strong>分片带来的危害</strong>（为什么需要优化）：</p>
<ul>
<li><strong>性能下降</strong>：分片和重组需要消耗CPU和内存资源。</li>
<li><strong>可靠性降低</strong>：任何一个分片丢失，整个原始报文都需要重传，增加了丢包率和网络延迟。</li>
<li><strong>潜在兼容性问题</strong>：某些网络设备或安全策略可能阻止分片报文。</li>
</ul>
</li>
<li>
<p><strong>解决方案</strong>：</p>
<ul>
<li>为了<strong>避免隧道报文在传输过程中被分片</strong>，常见的优化手段是<strong>调小隧道接口及路径上相关物理接口的MTU值</strong>。</li>
<li><strong>调整方法</strong>：将隧道接口及其底层物理接口的MTU值设置为 <code>1500 - (隧道封装开销)</code>。对于GRE over IP，开销通常是24字节（新IP头20字节 + GRE头4字节），因此MTU常设置为 <strong>1476</strong>。
<pre><code class="hljs language-bash" lang="bash"><span class="hljs-comment"># 例如，在物理接口和隧道接口上均进行设置</span>
[H3C-GigabitEthernet0/1] mtu 1476
[H3C-Tunnel0] mtu 1476
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>对其他隧道类型的延伸</strong>：</p>
<ul>
<li><strong>IPsec VPN</strong>：封装开销更大（ESP隧道模式通常增加约50-60字节），因此需要设置更小的MTU（如1400）。</li>
<li><strong>VXLAN</strong>：封装开销巨大（超过50字节），在数据中心Underlay网络中需要将MTU设置为<strong>1600</strong>或更高（通常称为“巨型帧”），以容纳封装后的报文。</li>
</ul>
</li>
</ol>
<p><strong>结论</strong>：
在部署GRE、IPsec、VXLAN等隧道技术时，<strong>预先规划和统一配置隧道路径上所有设备的MTU值，是保证网络稳定性和性能的最佳实践</strong>。这也解释了为什么在某些网络环境中，我们需要关注并调整OSPF接口的MTU，它不仅是OSPF邻接建立的一个检查项，更是整个网络数据平面能否高效转发的基础。当OSPF运行在隧道接口上时，确保隧道两端MTU一致且大小合理，就尤为关键。</p>
<h2 data-id="heading-29">为什么OSPF外部路由引入开销默认Type2?</h2>
<p>大多数情况下，广域网（外部）的链路开销非常大，而局域网内部（OSPF 域内）的开销相对微乎其微。因此，OSPF 默认使用 Type 2，这样路由表看起来更简洁，不需要因为内部链路的微小波动而频繁更新外部路由。</p>
<hr/>
<p><em>笔记内容排版经过AI优化。如有问题，感谢指正。内容仅供参考，请仔细甄别。</em></p></div></div></article> <div class="article-end" data-v-539963b4="" data-v-61fb5e44=""><div class="rank-entry-bottom" data-v-539963b4="" data-v-61fb5e44=""><!----></div> <div class="tag-list-box" data-v-539963b4="" data-v-61fb5e44=""><!----><!----><!----></div></div> <!----><!----><!----><!----><!----><style>	.markdown-body { color: #828182;}</style>]]></description></item>  </channel></rss>