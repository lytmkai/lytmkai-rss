<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[AGV调度系统：驱动现代智慧物流与智能制]]></title>    <link>https://segmentfault.com/a/1190000047395278</link>    <guid>https://segmentfault.com/a/1190000047395278</guid>    <pubDate>2025-11-13 15:09:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在工业4.0和智能制造浪潮的推动下，自动导引车（AGV）已从单一的搬运工具演变为柔性生产体系和智能物流枢纽的关键执行单元。而赋予AGV集群以智能和秩序的核心，便在于其背后的AGV调度系统。该系统作为整个自动化流程的“智慧大脑”，通过先进的算法和实时数据处理，对多台AGV进行任务分配、路径规划和交通协调，从而实现物料流转的最优化与系统效率的最大化。</p><p>一个成熟的AGV调度系统远不止于简单的任务指令下发，它构成了一个复杂的多层控制架构。通常，该系统通过上层管理系统（如MES、WMS）接收物料搬运需求，并将其转化为具体的作业指令。随后，调度核心运用数学建模和优化算法（如遗传算法、蚁群算法等）进行任务与AGV的最优匹配，综合考虑订单优先级、AGV电量、当前位置及效率等因素。在路径规划层面，系统需动态计算最优路径，并确保多AGV在复杂场景中无冲突、无死锁地高效运行，这需要实时监控全场AGV的状态、速度、方向以及道路占用情况，实现毫秒级的动态避障与再规划。</p><p>该系统的价值在众多行业场景中得到了充分验证。在汽车制造行业，一条混线生产线上往往有数十台AGV同时作业，负责将不同型号的发动机、座椅等零部件精准配送至相应工位。调度系统必须实时响应生产节拍的变化，动态调整配送顺序和路径，任何延误或冲突都可能导致生产线停线。国际知名汽车厂商通过引入高级调度系统，实现了物料准时配送率高达99.8%以上，显著提升了生产柔性与效率。同样，在大型电商仓储中心，面对海量SKU和爆发式的订单需求，调度系统需要指挥数百台AGV在数万平米的仓库中协同进行“货到人”拣选。系统通过智能调度，极大减少了AGV的空驶里程与等待时间，使订单处理能力呈几何级数增长，从容应对“双十一”等极端业务高峰。</p><p>行业内在系统集成与平台化应用方面也在持续探索。以工业互联网平台为例，广域铭岛的Geega（际嘉）平台曾展示过其解决方案如何通过统一数据底座和调度算法引擎，帮助制造企业整合不同品牌的AGV设备，实现跨车间、跨工序的协同调度与数字孪生映射。LOC库卸货到上线全程AGV无人配送，通过设备协调，机器代替人的同时，极大提高运行效率；AGV开动率提升10%。这类实践表明，平台化的调度管理能够有效解决多源异构设备集成难题，通过标准化接口降低系统耦合度，为生产数据的实时分析与流程优化提供支撑，体现了工业互联网理念在具体物流场景中的落地应用。</p><p>然而，构建一个高效、稳定的AGV调度系统也面临诸多挑战。系统必须与现有的ERP、WMS、MES等信息系统实现无缝集成，确保数据流畅通无阻。同时，随着AGV数量的增加，算法复杂性呈指数级增长，对系统的计算能力和响应实时性提出了极高要求。此外，系统还需具备高可靠性和容错能力，在局部网络中断或单台AGV故障时，能迅速重新分配任务，保证整体系统的持续稳定运行。</p><p>展望未来，随着5G技术的低延时、大连接特性与人工智能技术的深度融合，AGV调度系统正朝着更加智能、自适应和预测性的方向发展。通过引入机器学习模型，系统能够从历史数据中学习规律，预测潜在瓶颈，并提前进行资源调配，从而实现从“被动响应”到“主动优化”的跨越，最终为构建无人化、透明化的灯塔工厂与智慧物流中心奠定坚实基础。</p>]]></description></item><item>    <title><![CDATA[AI 原生应用开发实战营·深圳站丨限时报]]></title>    <link>https://segmentfault.com/a/1190000047395282</link>    <guid>https://segmentfault.com/a/1190000047395282</guid>    <pubDate>2025-11-13 15:08:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在大模型驱动软件范式演进的当下，AI 原生（AI-Native）应用正成为企业构建下一代智能系统的核心路径。</p><p>为系统性探讨 AI 原生架构的设计原则、工程实现与可观测性保障，阿里云将于 2025 年 11 月 14 日（星期五）13:30–17:00，在深圳市阿里中心后海 T3 栋岳麓书院举办「AI 原生应用开发实战营」线下专场活动。</p><p>本次活动由阿里云智能云原生团队资深专家现场授课，基于已发布并广受业界关注的《AI 原生应用架构白皮书》（累计下载超 10,000 份），围绕 AI 原生应用的 DEVOPS 全生命周期，从架构设计、技术选型、工程实践到运维优化，对概念和难点进行系统化地分享。</p><p>💌 参会者将获得：</p><ul><li>阿里云官方认证的培训参与证书和精美礼品</li><li>与阿里云 AI 原生领域专家的一对一交流机会</li></ul><p>📕 活动详情：</p><ul><li>时间：2025 年 11 月 14 日（周五）13:30–17:00</li><li>地点：深圳市阿里中心·深圳后海 T3 栋 3 楼岳麓书院 </li></ul><p>🔗 报名链接：<a href="https://link.segmentfault.com/?enc=55%2F36gERnbg23NT4OzvqVw%3D%3D.4C%2FvqPSJZJiCpQUguOx80xOX4LcwahJ5ZEVsjHBr0l4Jhe1hMu5419UA1Z4sjUi99UDbQPYIwAW613xYTxsfzA%3D%3D" rel="nofollow" target="_blank">https://www.aliyun.com/activity/middleware/shenzhen-2025</a></p><p>席位有限，审核制入场，敬请提前报名确认，携手推进 AI 工程化落地，共建可扩展、可运维、可治理的 AI 原生基础设施。期待您的莅临，共探智能时代的技术边界与企业级实践路径。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395284" alt="1" title="1"/></p>]]></description></item><item>    <title><![CDATA[AI知识库搭建新纪元：5分钟构建企业智慧]]></title>    <link>https://segmentfault.com/a/1190000047395292</link>    <guid>https://segmentfault.com/a/1190000047395292</guid>    <pubDate>2025-11-13 15:07:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>“小王，新来的实习生又来找我问报销流程了，这周都第三次了...”</p><p>“我们技术文档到底哪个版本是最新的？上次更新后好像有人还在用旧版...”</p><p>“客户半夜咨询产品问题，客服都下班了，只能等到第二天回复...”</p><p>这些场景是不是特别熟悉？在信息爆炸的今天，企业知识管理成了每个管理者心中的痛。资料散落在各个员工的电脑里，重要文档版本混乱，新人培训成本居高不下，客户服务响应迟缓...这些问题每天都在消耗着企业的效率和竞争力。</p><p><strong>企业知识管理的三大痛点</strong></p><p>让我给你算笔账：一个百人规模的企业，如果每个员工每周花1小时在找资料、问流程上，一年就是5200小时的工时浪费！按平均时薪50元计算，这就是26万元的真金白银！更别提因为信息不统一导致的决策失误、客户流失等隐性成本了。</p><p>传统解决方案要么太复杂，要么不够智能。Notion、语雀虽然好用，但在企业级应用上总感觉差点意思——权限管理不够精细，AI能力不足，私有化部署困难...</p><p><strong>破局者：AI驱动的企业级知识库</strong></p><p>现在，让我向你介绍一个改变游戏规则的解决方案——PandaWiki。这不仅仅是一个知识库，更是企业的智慧大脑。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394315" alt="" title=""/></p><p>PandaWiki是什么？简单说，它就是你的企业专属ChatGPT+知识库的完美结合。这个由长亭科技开源的项目，在GitHub上发布数周就斩获2.5K星标，现在更是达到了5.3K星，实力可见一斑！</p><p><strong>为什么PandaWiki能解决你的痛点？</strong></p><ol><li><p><strong>统一权威的知识源</strong></p><p>想象一下：公司所有制度、流程、技术文档都集中在一个平台，永远只有最新版本。新员工入职，不用再挨个问前辈，直接问AI助手就行。我们有个客户反馈，实施后新人培训时间从2周缩短到了3天！</p></li><li><p><strong>军工级安全防护</strong></p><p>金融、政务、医疗等行业的朋友们注意了！PandaWiki支持完全私有化部署，你的数据永远掌握在自己手里。精细的权限体系让不同部门、不同角色只能看到该看的内容，机密信息绝不外泄。</p></li><li><p><strong>24小时AI智能助手</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395294" alt="" title="" loading="lazy"/></p><p>我们的AI不是简单的关键词匹配，而是真正理解语义。支持多轮对话，理解上下文，甚至能主动推荐相关知识。客服部门的朋友告诉我，现在80%的常见问题都能由AI自动解答，客服压力大大减轻。</p></li><li><p><strong>开箱即用的便捷</strong></p><p>最让人惊喜的是，即便你不是技术背景，也能轻松上手。真正的“一站式”解决方案——从文档创作、团队协作到AI问答全流程覆盖。</p></li></ol><p><strong>实际应用场景展示</strong></p><p>技术总监张总跟我说：“以前团队最头疼的就是API文档，每次用冷门功能都要翻半天。现在有了PandaWiki，直接提问，秒得答案，开发效率提升至少30%！”</p><p>某电商公司在备战双十一时，用PandaWiki打造了“客服外挂”，效果立竿见影：</p><p><strong>第一步：搭建AI客服知识库大脑</strong><br/>把所有产品信息、促销政策、售后流程都录入系统，形成完整的知识体系。</p><p><strong>第二步：配置永不掉线AI助手</strong><br/>集成到企业微信、钉钉等工作平台，员工和客户随时都能提问。</p><p><strong>第三步：人机协同工作流</strong><br/>复杂问题自动转人工，简单问题AI搞定，实现完美配合。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395295" alt="" title="" loading="lazy"/></p><p><strong>5分钟快速部署指南</strong></p><p>说了这么多，你可能觉得部署很复杂？恰恰相反！只需要4个步骤：</p><ol><li>准备一台支持Docker的Linux服务器</li><li>使用root权限登录</li><li>执行一行安装命令</li><li>配置AI模型参数</li></ol><p>对，就是这么简单！我们有个用户开玩笑说：“我泡杯咖啡的功夫，知识库就搭好了！”</p><p><strong>更多惊喜功能</strong></p><ul><li><strong>AI辅助创作</strong>：写文档时自动生成大纲，智能润色文笔</li><li><strong>多格式支持</strong>：技术文档、产品手册、FAQ、博客系统全搞定</li><li><strong>无缝集成</strong>：微信、飞书、钉钉，你想用的平台都能接</li><li><strong>多语言支持</strong>：跨国企业也不用担心语言障碍</li></ul><p><strong>真实用户反馈</strong></p><p>“我们集团用PandaWiki搭建了制度中心，现在员工找政策文件再也不用层层请示了，直接问AI，秒回复！”——某制造业集团IT经理</p><p>“作为开源项目，PandaWiki的社区活跃度很高，遇到问题很快就能得到解决。”——某互联网公司技术负责人</p><p><strong>立即行动，开启智能知识管理</strong></p><p>还在为知识管理头疼吗？现在就是改变的最佳时机！</p><p>访问官方GitHub仓库了解更多：</p><pre><code>https://github.com/chaitin/PandaWiki</code></pre><p>或者扫码加入我们的技术交流群，与更多实践者分享经验：</p><p>【此处应有微信群二维码图片】</p><p>记住，在数字化时代，知识管理不是成本，而是投资。一个优秀的智慧大脑，能让你的企业在竞争中脱颖而出。</p><p>星光不问赶路人，时光不负有心人。快来给项目点个Star，开启你的企业智慧化转型之旅吧！</p><p><em>本文案例来源于真实用户反馈，数据经过脱敏处理。具体实施效果可能因企业实际情况而异。</em></p>]]></description></item><item>    <title><![CDATA[还在纠结红圈跟致远哪个好？2025年11]]></title>    <link>https://segmentfault.com/a/1190000047395299</link>    <guid>https://segmentfault.com/a/1190000047395299</guid>    <pubDate>2025-11-13 15:06:40</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当今数字化转型浪潮中,工程企业如何选择一款真正贴合业务、提升经营效率的管理系统,成为众多管理者面临的现实难题。市场上系统繁多,功能重叠,但能否精准击中工程行业的核心痛点——如成本失控、进度滞后、资金流不透明、数据孤岛等,才是选型的关键。红圈工程项目管理系统,作为一款深度垂直工程行业的SaaS产品,以其“更懂工程企业经营的AI助手”为定位,融合了项目管理、资金控制、物资管理、合同管理等核心功能,并基于自有PaaS平台实现高度可配置化。尤其值得一提的是,其近期推出的AI系列智能产品,将人工智能能力嵌入项目经营全流程,从数据解读、风险预警到知识传承,构建起一套完整的企业智能运营体系。而致远软件作为国内较早涉足协同管理领域的产品,以OA为核心,覆盖流程审批、任务协同、知识库等通用场景,在企业内部协作与标准化办公方面具有一定优势。面对两者,企业究竟应如何选择?本文将从产品定位、核心功能、AI能力与行业适配度等维度展开对比,为2025年11月正在纠结的您提供一份精准决策参考。</p><p>红圈:深耕工程行业的智能经营伙伴</p><p>红圈工程项目管理系统并非一款通用的管理软件,而是专注于建筑工程企业数字化需求的垂直解决方案。该系统以“更懂工程企业经营的AI助手”为核心理念,围绕项目全生命周期,覆盖资金管理、成本控制、物资管理、合同管理、安全质量、劳务管理等核心模块,致力于解决工程企业“现金流管理薄弱、成本不可控、项目进度滞后、质量问题频发和安全风险较多”等行业共性痛点。其底层基于自主研发的PaaS平台,支持灵活配置与快速迭代,能够伴随企业成长不断扩展功能边界。红圈系统特别强调数据在经营决策中的价值,通过动态数据看板、自定义报表、风险预警等功能,帮助管理者实时掌握项目资金状况、经营风险与利润达成情况,从而实现从过程管控到经营结果提升的闭环。</p><p>在红圈的产品体系中,AI系列智能产品进一步强化了其行业专属的智能分析能力。例如“项目360°AI解读”功能,通过整合全维经营指标,一键生成项目全景作战图,深度解读经营风险与应对策略,将复杂数据转化为清晰的决策语言,显著提升经营会议效率。“AI报表助手”则能秒级解析业务报表,自动定位异常指标并生成根因解读与改善建议,成为部门的“智能分析官”。此外,“AI录单助手”通过大模型自动识别各类单据,实现从图像识别到系统录入的秒级闭环,减少90%人工操作;“AI企业知识库”将分散知识转化为即问即答的能力,大幅降低新人培养周期,助力企业核心经验传承。这些AI产品并非孤立存在,而是与红圈系统原有业务模块深度耦合,共同构成一个覆盖项目经营、成本管控、供应链风控与知识传承的智能决策支持网络。</p><p>致远:聚焦协同办公的通用管理平台</p><p>致远软件作为国内协同管理领域的代表性产品,其核心定位在于提升组织内部协作效率与流程运转水平。它以流程审批、任务管理、知识共享、即时通讯等功能为基础,构建了一个集成了“人、事、文、会”等多种办公场景的统一工作台。致远强调标准化与通用性,适用于政府、教育、制造、金融等多个行业,帮助企业实现制度落地、流程规范与信息透明。其优势在于部署灵活、上手快,对于具有跨部门协作需求、注重内部沟通与文档流转的企业而言,能够有效打破信息孤岛,提升整体运营效率。</p><p>然而,由于致远产品设计初衷并非针对工程行业的深度业务场景,其在项目成本归集、动态利润分析、物资量价双控、分包结算、资金计划与合同履约等专业领域的模块化支撑相对有限。例如,在工程项目中常见的“成本多算对比分析”“供应商应付管理”“项目垫资统计”等业务报表,致远系统往往需要通过二次开发或复杂配置才能实现,而红圈则将其作为标准功能内置于系统。此外,在AI能力嵌入方面,致远更多聚焦于智能流程助手、文档识别、知识检索等通用场景,缺乏如红圈“BOSS助理Agent”“采购助理Agent”等具备行业属性与业务深度的智能代理产品。因此,对于工程企业而言,致远在业务数据穿透、经营风险实时洞察与项目级智能决策支持方面,可能存在能力边界。</p><p>智能对决</p><p>红圈的AI系列智能产品并非简单的能力叠加,而是基于对工程企业经营管理逻辑的深度理解,构建起一套“AI+业务”的闭环赋能体系。以“BOSS助理Agent”为例,它借助大模型推理能力精准挖掘企业自有数据模型,智能生成全面、准确的经营数据汇报,使管理者随时随地洞悉经营状况,实现“智能报数”。传统流程中,老板查阅数据需经过助理、财务、工程、成本等多环节人工统计与核准,耗时长且易出错;而通过AI意图识别与系统权限核准,红圈可实现“任何时间管理者下达的指令,都能智能理解随时快速汇报,有问必答”,大幅提升决策效率与数据安全性。在供应链风控方面,“采购助理Agent”通过整合企业年报、法律诉讼、失信人、天眼风险、纳税评级等多维度供应商数据,利用AI算法进行智能动态评分,3秒完成信用数据抓取,40秒完成各风险排查及评估,10秒生成完整报告,实现“供应商AI风险评级”。</p><p>反观致远协同管理平台,其AI能力的应用则更多聚焦于提升通用办公场景的效率。致远通常将人工智能技术嵌入流程审批、文档处理与知识检索等环节,例如通过智能语音助手加快会议纪要生成,利用OCR技术实现发票信息的快速识别与录入,或借助自然语言处理技术优化内部知识库的检索体验。这些功能确实能减轻员工的日常事务性负担,提升跨部门协作的流畅度。然而,与红圈AI系列产品相比,致远的AI能力更侧重于“办公协同”的提效,而非“业务经营”的深度洞察。例如,在面对工程项目中特有的“成本多算对比分析”、“供应商履约风险动态评估”、“项目资金效能分析”等专业场景时,致远缺乏如红圈那样与业务数据模型深度耦合的行业化AI代理,难以实现从数据到经营决策的闭环赋能。</p><p>决策指南:根据企业阶段与需求精准选型</p><p>选择红圈还是致远,关键在于判断企业当前的发展阶段与核心信息化需求。如果您的企业处于快速成长期,业务以工程项目为核心,迫切需要实现项目经营过程的标准化、透明化,并希望通过数据智能提升成本控制、资金安全与风险预警能力,那么红圈无疑是更贴合的选择。红圈系统内置了工程行业最佳业务实践数据模型,企业可以快速对标行业先进管理水平,其AI系列智能产品更能进一步将行业经验与实时数据结合,为管理者提供深度业务洞察与决策支持。特别是对于年产值在5,000万至20亿之间的建筑工程企业,红圈提供的“资金管理、成本管理、物资管理、现场管理、协同管理”等模块,能够有效帮助企业实现“提效率、降风险、控成本、管过程、增利润”的经营目标。</p><p>如果您的企业信息化基础较弱,当前首要需求是解决内部沟通效率低下、流程审批缓慢、文档管理混乱等通用办公问题,且业务类型较为通用,跨行业特性明显,那么致远软件可能更容易快速部署并见到成效。致远在协同办公领域的成熟度与生态完整性,能够帮助企业在较短时间内实现办公流程的数字化与协同化。但需要注意的是,随着企业业务深化与行业垂直需求的凸显,致远在项目级经营分析、成本实时归集、供应链风控等专业领域可能需要额外开发或集成其他专业系统。因此,在选型过程中,企业应立足当下、放眼未来,充分评估自身行业属性、业务复杂度与发展战略,选择那款既能解决眼前痛点,又能伴随企业持续成长的系统。</p><p>在数字化选型的道路上,没有“万能解”,只有“最优解”。红圈工程项目管理系统以其深厚的行业积淀、完整的业务覆盖与创新的AI系列智能产品,为工程企业提供了一条从“业务在线”到“智能运营”的数字化转型路径。而致远软件则在协同办公与流程管理领域持续发挥其通用性与易用性优势。2025年末,希望本指南能助您拨开迷雾,结合企业自身发展阶段与核心诉求,做出最贴合实际、最具前瞻性的选择。</p>]]></description></item><item>    <title><![CDATA[住宅代理的技术革新与行业演进 - B2P]]></title>    <link>https://segmentfault.com/a/1190000047395308</link>    <guid>https://segmentfault.com/a/1190000047395308</guid>    <pubDate>2025-11-13 15:05:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在互联网早期，代理IP的主要功能是“隐藏真实身份”，而今天，它正在成为数据采集、AI训练、广告验证、跨境运营等场景的底层基础设施。<br/>传统的数据中心代理虽然速度快、成本低，但由于IP来自云服务器或IDC机房，容易被识别为“非自然流量”，在反爬虫与风控系统面前往往“无所遁形”。<br/>而住宅代理的出现，彻底改变了这一格局。<br/>住宅代理的IP来自真实家庭网络，由ISP（互联网服务提供商）分配，因此在目标网站看来，与普通用户无异。这种“真实网络身份”让住宅代理在稳定性、隐蔽性和访问成功率方面都有显著优势。<br/>换句话说，住宅代理从一种“伪装工具”，演变为一种可信访问通道。</p><h2>智能化与自动化：新一代住宅代理的技术核心</h2><p>现代住宅代理不再是单纯的IP中转，而是集成了智能算法与自动化架构的复杂网络系统。<br/>其核心技术包括：<br/>1.智能路由（Smart Routing）<br/> 系统会实时检测不同节点的延迟、带宽与封禁率，根据访问目标自动分配最优住宅节点。<br/>2.动态轮换（IP Rotation）<br/> 支持按时间或请求自动更换IP，以防止因固定IP导致的封禁。<br/>3.节点健康监控（Node Monitoring）<br/> 实时追踪节点的响应质量与连接稳定性，保证任务执行的连续性。<br/>4.API与自动控制（Automation Control）<br/> 企业可通过API自定义代理策略，实现自动切换、任务分发与数据调度。<br/>这些功能的结合，使住宅代理从“手动配置”升级为“智能分发系统”，极大提升了效率与安全性。</p><h2>住宅代理的应用新格局</h2><p>如今，住宅代理已成为多个高价值场景中的关键基础设施。<br/>●AI与数据采集<br/> 支持从全球不同地区采集数据，提升模型训练的样本多样性与精度。<br/>●广告验证（Ad Verification）<br/> 模拟不同地区的真实用户访问，用于检测广告是否被正确展示或被篡改。<br/>●跨境电商与账号管理<br/> 在多个平台环境中模拟不同国家或地区的登录，防止关联与封号。<br/>●价格监控与市场调研<br/> 企业可使用住宅代理从全球电商网站采集定价与评论数据，进行市场分析。<br/>这些应用让住宅代理不仅是“安全工具”，更是企业数据战略的一部分。</p><h2>行业趋势：合规化、透明化与全球化</h2><p>随着数据合规要求提升和隐私保护立法的推进，住宅代理行业正进入一个更成熟的阶段。<br/>1.合规化（Compliance）<br/> 服务商需确保IP来源合法且经用户授权，避免未经许可的数据使用风险。<br/>2.透明化（Transparency）<br/> 市场更青睐公开节点来源与使用机制的供应商，以保障使用的合规性与安全性。<br/>3.全球化（Global Expansion）<br/> 代理网络的覆盖范围将进一步扩大，未来主流服务商将能提供200+国家节点，满足全球化业务的访问需求。</p><h2>未来展望：从“工具”到“基础设施”</h2><p>住宅代理的未来方向将是——<br/>更智能、更安全、更透明。<br/>它将从“绕过限制”的手段，变成支撑AI、跨境业务、广告投放与数据经济的重要基础设施。<br/> 在这一过程中，真正具备技术创新能力、网络资源与合规体系的服务商，将成为行业核心力量。随着网络身份与访问行为的边界日益模糊，住宅代理将成为连接数字世界与真实世界的“隐形引擎”。</p>]]></description></item><item>    <title><![CDATA[崛企智慧酒店单商户版小程序系统：全场景酒]]></title>    <link>https://segmentfault.com/a/1190000047395328</link>    <guid>https://segmentfault.com/a/1190000047395328</guid>    <pubDate>2025-11-13 15:05:00</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>崛企智慧酒店单商户版是打造的数字化运营系统，自正式研发，已成为企业核心项目。系统支持微信公众号 H5、小程序、PC 官网等多终端部署（小程序、PC 官网等需额外付费），以微擎系统在线交付，提供从订房、会员管理到营销推广、后台运营的全流程功能。产品分为单开版、十开版、无限版、授权开源版和完全开源版五大版本，满足不同规模酒店的运营需求。</p><p><strong>二、功能介绍</strong><br/>核心运营体系<br/>会员体系：包含积分与余额双机制，支持订房、签到、充值等多渠道积分获取，可自定义会员等级及对应折扣，支持成长值升级或直接购买升级，管理员可灵活调整会员积分与余额。</p><p>客房预定体系：覆盖常规房、钟点房、特价房等多房型预定，支持实时房态与远期房态可视化，提供在线选房、积分抵现、优惠券使用等功能，可强制填写入住人信息，对接金天鹅、别样红等传统 PMS 系统。</p><p>营销推广体系：涵盖签到送积分、限时抢购、砍价活动、锦鲤抽奖等多元玩法，支持自定义特殊卡（如温泉计次卡、超级无限卡）与优惠券发放，满足新人引流、老客留存需求。</p><p>增值服务功能<br/>酒店超市：支持入住客人自动关联房间号下单，散客扫码填写房间号购买，可设置商品售卖时间与营业时间，不同会员等级享受不同定价，支持特产等商品物流配送。</p><p>分销体系：支持员工一级分销与用户二级分销，可自定义分销商佣金比例，酒店订房按比例结算佣金，超市及热卖商品按固定金额结算，即将上线分销排行榜功能。</p><p>自定义配置：支持首页 DIY 装修、底部导航与菜单自定义、轮播图与快捷入口设置等，可根据酒店风格调整界面颜色、图标及功能布局，适配不同运营需求。</p><p>管理与服务工具<br/>多端管理后台：提供 PC 端完整管理功能与手机管理端，支持实时房态监控、订单管理、房价调整、员工管理等核心操作，新版手机管理端优化 UI 设计，操作更便捷。</p><p>附加服务模块：包含会议室预定、积分商城、客服服务等插件，客服服务支持借物、打扫、维修等工单处理，结合房态高效响应客人需求，还可提供叫醒服务、班车接送、发票开具等增值服务。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>单店运营：普通单体酒店、精品酒店可通过单开版搭建专属运营平台，实现订房、会员、营销一体化管理。</p><p>连锁经营：直营连锁酒店可选择十开版或无限版，后台支持创建多个酒店账号，统一管理多门店房态、会员与订单。</p><p>业务拓展：创业者或服务商可利用系统跑业务，为酒店客户搭建运营平台，按 6000-12000 元首次收费 + 每年 2000-3000 元服务费的模式盈利。</p><p>行业价值<br/>降本增效：通过数字化订房与房态管理，减少人工登记与沟通成本，手机端管理功能支持随时随地处理运营事务。</p><p>增收赋能：会员体系与多元营销工具提升用户复购率，分销体系扩大推广渠道，酒店超市与热卖商品（如温泉票、SPA 券）丰富盈利来源。</p><p>品牌升级：自定义界面设计打造差异化品牌形象，全终端覆盖满足不同用户预订习惯，提升客人入住体验与品牌认可度。</p><p><strong>四、常见问题问答</strong><br/>单商户版与多商户版的核心区别是什么？</p><p>答：单商户版适用于酒店自运营，包括直营连锁店或普通单酒店，搭建在酒店自身公众号内；多商户版适用于运营酒店平台（类似携程、美团）的场景，可整合加盟连锁店或多家独立酒店统一运营。</p><p>单商户版不同版本的主要差异是什么？</p><p>答：单开版后台仅可创建 1 个酒店，适配单店使用；十开版支持创建 10 个酒店；无限版无酒店创建数量限制；授权开源版代码部分开源，不影响二次开发；完全开源版代码全开源，两者均需签订相关合同。</p><p>系统支持哪些终端部署？是否需要额外付费？</p><p>答：默认提供公众号 H5 版本，小程序、PC 官网、APP 需额外付费购买，其中小程序 1500 元，PC 官网 3000 元，APP 暂无定价。</p><p>系统能否对接传统酒店管理系统（PMS）？</p><p>答：目前已对接金天鹅和别样红，下单信息可直接推送到对应 PMS；如需对接其他 PMS，需提交 API 排队等待，对接后续不收取额外费用。</p>]]></description></item><item>    <title><![CDATA[微预约影楼版小程序系统：高效赋能摄影行业]]></title>    <link>https://segmentfault.com/a/1190000047395332</link>    <guid>https://segmentfault.com/a/1190000047395332</guid>    <pubDate>2025-11-13 15:04:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>微预约影楼版小程序系统是一款专为影楼、摄影机构打造的预约管理解决方案，支持微信公众号部署，通过微擎系统在线交付。系统核心聚焦摄影服务预约全流程，涵盖门店管理、项目设置、时段预约、订单处理等核心功能，同时提供自定义表单、超大附件存储、推广分值统计导出等增值服务，帮助商家简化预约流程、提升运营效率，为用户提供便捷的拍摄预约体验。</p><p><strong>二、功能介绍</strong><br/>预约核心功能<br/>支持多门店管理，可新建、编辑门店信息，展示门店地址、联系方式及距离。</p><p>灵活设置摄影项目分类与列表，涵盖证件照、履历照、桌前照等多种拍摄类型，可配置服务包含内容。</p><p>自定义预约时间段，支持选择每周可预约日期及时段，实时显示时段占用状态（已满 / 可预约）。</p><p>提供用户自主预约与代客下单两种模式，预约流程包含选择项目、门店、时段、完善联系人信息等步骤。</p><p>运营管理功能<br/>配备完善的参数设置模块，支持基本设置、时间设置、自定义字段、通知设置等个性化配置。</p><p>支持自定义表单，可收集用户文本、图片、视频、手机号等信息，适配电信业务推广奖励等场景。</p><p>具备推广分值管理功能，支持年 / 月导出推广数据，实现电信运营商分权管理。</p><p>提供首页与个人中心导航配置，支持幻灯片管理、业务菜单自定义，可删除冗余功能模块。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>专业影楼：用于婚纱摄影、艺术写真等拍摄项目的预约与订单管理。</p><p>证件照工作室：满足用户证件照、履历照等快速预约拍摄需求。</p><p>连锁摄影机构：适配多门店统一管理，实现跨区域预约调度。</p><p>摄影相关推广活动：配合电信业务等推广场景，通过表单收集信息并统计推广分值。</p><p>行业价值<br/>简化预约流程：用户无需线下沟通，线上即可完成项目选择、时段锁定、信息提交，减少沟通成本。</p><p>提升运营效率：商家可实时管理门店资源、预约时段，自动统计订单与推广数据，减少人工统计工作量。</p><p>优化用户体验：透明展示时段占用情况、服务包含内容，支持备注功能，满足用户个性化需求。</p><p>助力业务拓展：通过自定义表单与推广分值统计，适配各类合作推广场景，拓宽盈利渠道。</p><p><strong>四、问答环节</strong><br/>问：该小程序系统支持哪些平台部署？</p><p>答：适用于微信公众号，通过微擎系统在线交付使用。</p><p>问：系统能否管理多个门店的预约业务？</p><p>答：可以，支持新建、编辑门店信息，多门店统一管理预约时段与订单。</p><p>问：预约时段可以自主设置吗？</p><p>答：支持自定义预约时间段，可选择每周可预约日期及时段，灵活控制可预约状态。</p><p>问：系统是否提供文件存储相关功能？</p><p>答：支持超大附件第三方存储直传，不占用自身资源，满足图片、视频等文件上传需求。</p><p>问：除了用户自主预约，还有其他下单方式吗？</p><p>答：支持代客下单模式，商家可协助用户完成预约操作。</p><p>问：能否统计推广活动相关数据？答：支持年 / 月导出推广分值，适配电信业务等推广场景的数据分析需求。</p>]]></description></item><item>    <title><![CDATA[微考试开源版管理系统：微信公众号专属的高]]></title>    <link>https://segmentfault.com/a/1190000047395335</link>    <guid>https://segmentfault.com/a/1190000047395335</guid>    <pubDate>2025-11-13 15:03:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>崛企微考试是衡阳崛企科技推出的微信公众号适配应用，基于微擎系统交付，为用户提供一站式在线考试与课程管理服务。其核心优势在于功能全面、操作便捷，前台 UI 设计整洁美观，后台配置灵活，既满足管理者高效运营需求，也能为考生带来流畅的答题体验，适用于各类考试场景的数字化转型。</p><p><strong>二、功能介绍</strong><br/>（一）考试与练习核心功能<br/>支持自定义试卷参数，可灵活设置题目、分数、考试时间，适配单选、多选、判断、图文结合等多种题型。</p><p>提供考试和模拟练习两种模式，考试模式限制一次答题机会，模拟练习可多次作答，满足不同训练需求。</p><p>答题后自动生成成绩报告，考生可查看用时、得分、错题解析，同时支持查看试卷排行榜，了解自身排名情况。</p><p>（二）题库与数据管理功能<br/>具备试题导入功能，支持下载模板批量上传，同类型下相同试题标题不会重复导入，提升题库搭建效率。</p><p>支持统计数据导出，可导出考生考试结果等关键数据，方便管理者进行成绩分析与存档。</p><p>试卷分类支持二级分类与分类检索，便于快速筛选查找目标试卷，适配多科目、多场景考试管理。</p><p>（三）课程与用户管理功能<br/>支持自定义添加课程，可设置课程分类、授课讲师、时长、期数、简介等信息，同时提供课程预约功能，预约需经后台审核。</p><p>课程预约可设置人数限制与时间限制，精准控制报名规模与周期，后台可查看预约列表并进行审核管理。</p><p>支持用户添加、导入与批量管理，可启用登录开关，开启后仅系统录入的用户可参与考试，保障考试私密性。</p><p>（四）系统配置与展示功能<br/>支持前台个性化设置，可自定义首页头部标题、底部广告图及跳转路径，广告图最佳尺寸为 750*179px。</p><p>答题页面支持自定义计时与倒计时功能，页面风格简洁美观，同时可设置姓名、手机号等必填信息，便于考生身份核验。</p><p>后端提供清晰的业务菜单，涵盖试卷管理、题库管理、课程管理、用户管理等核心模块，操作逻辑清晰，易上手。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>教育行业：中小学日常考试、课外培训机构模拟测试、职业教育资格考试训练等。</p><p>企业内部：员工入职考核、岗位技能培训测试、规章制度知晓度考试等。</p><p>其他场景：行业资格认证练习、知识竞赛组织、兴趣社群答题互动等。</p><p>行业价值<br/>对教育机构：简化考试组织流程，减少纸质试卷印刷与批改成本，通过错题解析与排行榜功能，助力学生针对性提升。</p><p>对企业：降低内部培训考核的时间与人力成本，实现员工成绩的快速统计与分析，提升培训管理效率。</p><p>对运营者：依托微信公众号生态，无需额外开发 APP，考生可直接在公众号内参与考试，触达更便捷，用户粘性更高。</p><p><strong>四、常见问题问答</strong><br/>问：崛企微考试支持哪些交付方式？</p><p>答：采用微擎系统在线交付，源码未加密，支持 PHP5.6 环境，适配微信公众号使用。</p><p>问：考试和模拟练习模式有什么区别？</p><p>答：考试模式限制一次答题机会，作答后可查看错题解析及试卷排行；模拟练习可多次作答，仅展示最新一次答题的错题解析。</p><p>问：课程预约需要什么流程？</p><p>答：用户填写姓名、手机号、邮箱等信息进行预约，预约后需等待后台审核通过，方可参与课程。</p><p>问：是否支持批量导入试题和用户？</p><p>答：支持试题批量导入，可下载模板上传；同时支持用户导入与批量管理，包括批量启用、禁用及删除功能。</p><p>问：登录开关开启后有什么限制？答：开启登录开关后，用户需提前在系统中录入基本信息，首次访问时系统验证信息存在，方可使用考试及课程功能。</p>]]></description></item><item>    <title><![CDATA[超级服务商城 O2O 小程序系统：一站式]]></title>    <link>https://segmentfault.com/a/1190000047395339</link>    <guid>https://segmentfault.com/a/1190000047395339</guid>    <pubDate>2025-11-13 15:02:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>超级服务商城是一款专注于 O2O 服务交易的小程序系统，支持微信公众号部署，涵盖微信、抖音等多平台适配需求。系统以 “连接服务供需、简化交易流程” 为核心，提供派单、抢单、门店入驻三大核心模式，搭配分销推广、会员管理、订单核销等全方位功能，适用于多城市、多门店的服务类业务场景。目前系统售后支持完善，能有效解决服务行业订单管理混乱、推广获客难等问题。</p><p><strong>二、功能介绍</strong><br/>核心运营模式<br/>派单模式：适合平台自营场景，下单后可直接指派给内部员工处理。</p><p>抢单模式：面向有资质的服务师入驻，顾客下单后服务师可自主抢单，实现资源共享。</p><p>门店模式：支持商家入驻，服务与入驻服务商一一对应，用户可按服务介绍、价格等自主选择。</p><p>营销推广功能<br/>三级分销机制：通过渠道招募分销商实现全民分佣，助力推广裂变。</p><p>会员等级体系：设置不同等级会员折扣，VIP 会员可享半价购等权益，锁定老用户。</p><p>多维度推广工具：包含推广、纳客、互评功能，搭配弹幕设置、模版消息一键开启，提升用户互动与转化。</p><p>订单与门店管理<br/>订单管理：支持常规下单、快速下单两种模式，快速下单可在线报价，支持在线补单功能，避免多渠道订单混乱。</p><p>门店管理：后台可关联实体门店，支持门店入驻，用户到店后可完成核销，实现线上线下联动。</p><p>数据与提醒：提供一键数据清除功能，内置消息提醒机制，订单状态实时同步。</p><p>其他核心功能<br/>服务师体系：支持服务师注册入驻，建立信用评价体系，记录历次评价及综合评分。</p><p>多场景适配：支持多城市、多门店运营，适配上门服务与到店服务双重场景。</p><p>技术支持：兼容 PHP5.4-5.6 版本，通过微擎系统在线交付，源码加密保障安全。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>本地生活服务：如家政服务、家电维修、美容美发、健身理疗等上门或到店服务。</p><p>技能服务交易：如设计、摄影、翻译、家教等自由职业者提供的技能服务。</p><p>连锁门店服务：餐饮、零售、休闲娱乐等拥有多门店的连锁品牌，需实现统一订单管理与核销。</p><p>行业价值<br/>简化运营流程：统一管理多渠道订单，优化订单 UI 逻辑，操作更清晰，减少业务混乱。</p><p>降低获客成本：通过三级分销实现全民推广，搭配会员体系提升用户复购，降低获客投入。</p><p>提升服务质量：建立服务师信用评价体系，用户评价可直接影响服务师接单，倒逼服务升级。</p><p>实现资源共享：让有资质的服务师快速入驻接单，让商家高效获取线上流量，达成供需双赢。</p><p><strong>四、问答环节</strong><br/>问：该小程序系统支持哪些平台部署？怎么交付安装？</p><p>答：目前适用微信公众号部署，同时支持 O2O 服务商城抖音小程序定制开发需求。通过微擎系统交付安装。</p><p>问：三级分销机制具体是如何实现推广裂变的？</p><p>答：内置三级分销机制，可通过渠道招募用户成为分销商，分销商推广成功后可获得分佣，从而实现全民参与的推广裂变。</p><p>问：订单补单功能的作用是什么？</p><p>答：用于补录通过其他方式下单、未通过微信下单完成的订单，避免不同渠道记录业务订单造成的业务混乱。</p><p>问：会员等级体系有什么核心权益？</p><p>答：不同等级会员享有不同折扣，其中至尊 VIP 会员可享受半价购权益，能有效锁定老会员，提升平台用户粘度。</p>]]></description></item><item>    <title><![CDATA[互联网云签电子合同小程序：高效便捷的数字]]></title>    <link>https://segmentfault.com/a/1190000047395345</link>    <guid>https://segmentfault.com/a/1190000047395345</guid>    <pubDate>2025-11-13 15:02:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>互联网云签电子合同是一款适配微信公众号的新一代电子合同云平台，基于微擎系统交付，支持 PHP7.1 及以上版本，需搭配 MYSQL5.6 和 redis 环境。平台以 “随时随地、想签就签” 为核心优势，提供从合同发起、模板使用、印章管理到签署追踪的全流程服务，当前 1.6 版本已实现多格式文件兼容、合同到期提醒、时间戳等实用功能。</p><p><strong>二、功能介绍</strong><br/>核心签署功能<br/>支持直接发起签署和模板发起签署两种模式，手机端可直接操作，无需依赖电脑。</p><p>兼容 DOC、docx、PDF、PNG、JPG、JPEG 等多种文件格式，手机端支持附件上传。</p><p>提供单页签章和骑缝签章功能，满足多页合同签署的合规需求，签署过程生成时间戳保障效力。</p><p>合同管理功能<br/>实时展示合同状态，分类呈现待签署、未签署、已签署、已到期、已作废等类型，支持按合同 ID、名称、操作时间查询。</p><p>新增文档管理功能，支持合同在线预览、下载、作废操作，可查看合同起止日期、参与方信息、应付款项等详情。</p><p>内置合同到期提醒功能，避免遗漏重要签署节点，合同统计模块直观展示今日、本月及全部签署数据。</p><p>印章与签名管理<br/>个人签名管理支持上传自定义签名或在线生成，可选择颜色并保存唯一使用版本。</p><p>企业印章管理可创建自身企业印章和合作方企业印章，需录入企业名称、编码等信息，生成后可选择使用或删除。</p><p>签署要求支持短信验证和经办人签字双重保障，确保签署行为的真实性和安全性。</p><p>系统管理功能<br/>用户中心可维护个人 / 企业信息，支持修改头像、邮箱、密码，展示手机号、企业名称等核心信息。</p><p>后台支持角色权限管理，可添加管理员、业务员并分配不同操作权限，保障系统使用安全。</p><p>模板管理模块可创建、启用、停用合同模板，支持预览和修改，提高高频合同的发起效率。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>企业日常办公：用于员工劳动合同、保密协议、入职文件等内部签署，无需纸质打印和线下流转。</p><p>商业合作场景：涵盖供应商合作协议、客户服务合同、挂靠经营合同等对外合作文件的远程签署。</p><p>个人业务场景：适用于租房合同、借贷协议、授权委托书等个人之间的文件签署，手机端即可完成操作。</p><p>行业价值<br/>提升效率：打破时间和空间限制，随时随地发起和签署合同，缩短签约周期，告别 “来回邮寄” 的繁琐流程。</p><p>降低成本：减少纸质文件打印、邮寄、存储的费用，降低企业办公成本和资源消耗，符合绿色办公理念。</p><p>合规保障：通过时间戳、短信验证、加密存储等技术，确保电子合同的法律效力，合同数据可追溯、可查询。</p><p>便捷管理：集中存储所有合同文件，分类清晰、查询快速，避免纸质合同丢失、损坏风险，简化档案管理流程。</p><p><strong>四、常见问答</strong><br/>速速云签支持哪些使用载体？</p><p>答：仅适用于微信公众号，基于微擎系统交付，需安装对应环境后使用。</p><p>系统对服务器环境有什么要求？答：需满足 PHP7.2 版本、MYSQL5.6 版本，且需安装 redis，同时删除禁用函数 putenv。</p><p>电子合同的签署格式有哪些限制？答：支持 DOC、docx、PDF、PNG、JPG、JPEG 格式的文件签署，手机端和电脑端均兼容。</p><p>企业印章创建后可以修改或删除吗？</p><p>答：可以，企业印章生成后可在印章管理模块进行选择使用、删除操作，创建他人企业印章时需输入对方手机号并发送确认。</p>]]></description></item><item>    <title><![CDATA[厂内物流协同是什么？如何通过工业互联网实]]></title>    <link>https://segmentfault.com/a/1190000047395350</link>    <guid>https://segmentfault.com/a/1190000047395350</guid>    <pubDate>2025-11-13 15:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>工业互联网厂内物流协同是智能制造体系的核心环节，其核心目标是通过数据驱动和智能调度，实现物料流转与生产节拍的高度匹配。在传统制造模式中，厂内物流常面临信息孤岛、响应滞后和资源错配等问题，而工业互联网通过物联网、云计算与人工智能技术的融合，构建起实时感知、动态优化和全局协同的物流运行机制。<br/>以汽车制造业为例，某整车厂通过工业互联网平台整合了供应商物料信息、生产线工单数据及AGV调度系统，实现了焊装车间与总装车间的物料精准拉动。具体而言，生产线工单状态实时触发物料需求指令，AGV集群依据算法动态规划路径，将误差控制在±2分钟内，避免了因物料短缺导致的生产停线。<br/>在实践层面，工业互联网平台提供商如广域铭岛，通过其Geega平台为制造企业提供底层技术支持。例如，在杭州湾某基地接入生产计划，根据计划拉动仓库备料出库，管理线边库库存，实现了线边库的人工/自动入出库，切线时间损失降低90%。这一过程中，平台并未替代原有管理系统，而是通过标准化数据接口实现多系统协同，体现出工业互联网兼容性与赋能价值。<br/>电子制造领域对物流协同提出了更高要求。某消费电子企业采用RFID与工业互联网平台结合的方式，对物料批次进行全程追踪，并结合订单波动预测动态调整线边库库存水位。通过与广域铭岛合作，企业引入自适应调度算法，在订单突增期间自动激活备用AGV路线及临时仓储区域，避免了传统依赖人工调度导致响应延迟的问题。这一实践不仅减少了芯片类紧缺物料的呆滞损耗，还通过AGV与机械臂协同实现了无人化配送，大幅提升了产线换型效率。<br/>然而，实现高效协同仍需攻克数据协议兼容性、初始投入成本与复合型人才短缺等挑战。未来，5G低延时通信、边缘计算及生成式AI技术将进一步强化物流系统的实时响应与智能决策能力。例如，广域铭岛在探索基于大模型的物流异常预测系统，通过多模态数据训练提升对设备故障、物料错配等风险的预见性。企业需以业务痛点为导向，分阶段推进技术落地，而非盲目追求单一技术的应用，才能真正实现降本、增效与低碳化的综合目标。<br/>工业互联网厂内物流协同已从概念验证走向规模化应用，其核心价值在于通过技术整合与生态协作，推动制造业从“经验驱动”迈向“数据驱动”。随着标准化进程加速与行业知识沉淀，这一领域将成为企业智能制造升级的重要突破口。</p>]]></description></item><item>    <title><![CDATA[硅谷GPU蒙尘，马斯克一言成谶：美国AI]]></title>    <link>https://segmentfault.com/a/1190000047395026</link>    <guid>https://segmentfault.com/a/1190000047395026</guid>    <pubDate>2025-11-13 14:12:12</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>编辑：KingHZ</p><p>【新智元导读】AI万丈高楼，终究要建在物理世界的地基之上。没有电，再强的GPU也只是一堆沙子。</p><p>谁敢信英伟达总部所在地的数据中心，GPU吃灰6年多了！</p><p>刚刚，彭博社爆出消息：加州圣克拉拉两处数据中心空置了6年多，「独守空房」，等待电力。</p><p>这两处设施的命运，凸显了美国科技行业乃至整个经济面临的重大问题——有钱，但缺电。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395028" alt="" title=""/></p><p>此前，微软的纳德拉公开承认，因为缺电，微软成堆的GPU放在机架上吃灰。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395029" alt="" title="" loading="lazy"/></p><p>顺便说一句，2年前马斯克公开分享过类似的观点：</p><p>我明确表示，（AI）当前的限制因素是硅基芯片。</p><p>但大约一年后，我们可能会面临芯片数量超过实际供电能力的局面——届时将有大量芯片无法通电运行。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395030" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395031" alt="" title="" loading="lazy"/></p><p><strong>电力短缺</strong></p><p><strong>英伟达老家数据中心空置</strong></p><p>美国，加利福尼亚州，圣克拉拉，全球最大的AI芯片Nvidia的总部所在地。</p><p>全球两大数据中心开发商在该地建设了数据中心，但已经空置多年，或因当地无法供电。</p><p>2019年，数据中心巨头数字房地产信托公司「Digital Realty Trust」在此申请建造一座数据中心。<strong>将近六年过去，该项目仍是一座空壳，等待着电力的全面接入。</strong></p><p>今年早些时候，<strong>蓝猫头鹰资本收购了Stack Infrastructure，在附近也有一个48兆瓦的项目同样处于闲置状态。</strong></p><p>与此同时，该市的公用事业公司「硅谷电力」正艰难地进行电力设施升级。</p><p>在云计算和人工智能热潮的推动下，市场对数据中心的需求空前高涨，但电力供应正成为最大的制约因素。</p><p><strong>这主要是因为电力基础设施老化、新的输电线路建设缓慢，以及各种监管和许可障碍。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395032" alt="" title="" loading="lazy"/></p><p>而电力系统面临的压力只会越来越大。</p><p>这也不难理解为何英伟达和谷歌等把算力大战卷到了太空——用太阳能省电。</p><p>比如，英伟达将H100 GPU送到太空，开启Starcloud计划。</p><p>谷歌也测试了TPU在太空的运行的情况。</p><p>根据BloombergNEF的预测，<strong>到2035年，仅美国一地，AI算力的电力需求就可能翻一番以上。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395033" alt="" title="" loading="lazy"/></p><p>Nvidia的黄仁勋和OpenAI的奥特曼等企业领袖都曾预言，未来将有数万亿美元涌入新的人工智能基础设施建设。</p><p>「需求从未如此之高，我们面临的实际上是一个电力供应问题，」房地产经纪公司世邦魏理仕负责数据中心解决方案的执行副总裁Bill Dougherty在采访中表示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395034" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395035" alt="" title="" loading="lazy"/></p><p><strong>只是两个小型项目</strong></p><p><strong>与那些大型综合AI算力设施相比，圣克拉拉的这两个项目规模相对较小。</strong></p><p>如今，那些大型项目正建在德克萨斯州、宾夕法尼亚州、路易斯安那州和新墨西哥州等地，那里的电价更低，但电力来源往往也还在建设中。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395036" alt="" title="" loading="lazy"/></p><p>而这些小型数据中心服务的是本地的云客户，他们愿意为地段和电力支付更高的价格，以减<strong>少长距离传输造成的延迟</strong>——</p><p>比如那些需要微秒级信息响应的高频交易员或自动驾驶汽车运营商。</p><p>「有一部分数据中心的需求，必须尽可能靠近人口中心，」Dougherty说。「这就是为什么需求必须在加州得到满足。但因为电力受限，他们无法让这些设施上线。」</p><p>根据今年五月市议会的一份报告，圣克拉拉共有57个正在运营或建设中的数据中心。</p><p>该市电力公司「硅谷电力」的发言人Janine de la Vega表示，公司与Stack和Digital Realty签有服务条款协议，并且一直在评估新增的电力请求。</p><p>为了满足这些客户及其他用户的需求，硅谷电力公司正在进行一项耗资4.5亿美元的系统升级工程，该项目目前按计划将于2028年完成。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395037" alt="" title="" loading="lazy"/></p><p>当然，其他地区也因公用事业公司的供电能力限制而面临类似的延误。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395038" alt="" title="" loading="lazy"/></p><p><strong>美国缺电</strong></p><p>随着需求激增，电网的可用电力和输电设施已不堪重负，全美的公用事业公司都在奋力追赶。</p><p>去年，Dominion能源公司表示，预计大型数据中心接入电网的时间将增加一到三年，有些甚至需要长达七年。</p><p>而在俄勒冈州，一份诉状显示，亚马逊指控其旗下四座数据中心被Berkshire Hathaway所属的一家公用事业公司拒绝提供充足电力。</p><p>Digital Realty在全球拥有超过300个数据中心，其发言人Jordan Sadler表示，三年的电力等待期在美国大部分地区「基本一致」，<strong>但在硅谷和北弗吉尼亚州等高需求地区，等待时间则更长。</strong></p><p>Sadler在采访中说：「在圣克拉拉，如果你今天找到一块地想申请新电力，那得等上好几年。我们有时会下手早一点，但通常不会晚。没人想错过时机。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395039" alt="" title="" loading="lazy"/></p><p><strong>4万平方米数据中心，3年后通电</strong></p><p>Digital Realty在圣克拉拉的项目目前是一栋闲置的四层建筑，面积达43万平方英尺（约4万平方米）。</p><p>Sadler透露，该公司在美国设施齐全的数据中心平均每兆瓦成本约为1330万美元，但在硅谷价格更高。</p><p>在建筑准备好入驻之前，Digital Realty会花费最终建造成本的20%到25%来建造一个空壳。</p><p>该公司正与「硅谷电力」合作，力争在2028年之前获得电力。</p><p>公司数据中心投资组合管理副总裁Crystal Delany在一封邮件中表示：</p><p>Digital Realty正继续与硅谷电力公司合作，争取在今年年底前获得剩余电力，以满足该建筑48兆瓦的总关键IT负载需求。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395040" alt="" title="" loading="lazy"/></p><p>由于需求旺盛，开发商往往在项目完工前数年就能租出去。</p><p>根据世邦魏理仕的报告，目前美国在建项目中有74.3%已经与租户签约。Digital Realty在其价值97亿美元的在建数据中心项目中，也已租出了约61%。但该公司拒绝透露其圣克拉拉项目的租赁状况。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395041" alt="" title="" loading="lazy"/></p><p>Stack Infrastructure的园区是一栋55.1万平方英尺的建筑，拥有四层目前空无一物的数据大厅，该项目最初于2021年申请城市规划批准。</p><p>根据一份项目宣传册，「电力将通过一个专用的现场变电站输送，其中12兆瓦的关键容量可立即出租」，并有能力扩展至48兆瓦。</p><p>根据Stack的一份邮件声明，与「硅谷电力」的协议「反映了当前电力供应以及到2027年将上线的新增电力情况」。Stack拒绝讨论该中心的租赁状态。</p><p>今年9月和10月，宣布了超过500亿美元的数据中心投资，其中包括在路易斯安那州为Meta投资300亿美元，以及在新墨西哥州与Oracle合作投资超过200亿美元。</p><p>该公司联席首席执行官Marc Lipschultz在10月30日的投资者电话会议上表示，他们在Stack拥有1000名员工，负责设计、建造和运营数据中心。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395042" alt="" title="" loading="lazy"/></p><p>Lipschultz在电话会议上说：</p><p>重要的不是你今天做了什么，而是你两年前做了什么来为自己布局，确保拥有合适的土地、电力，并理解监管框架，知道如何真正把事情办成。</p><p><strong>因为执行力与资本同样重要，而我们两者兼备。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395043" alt="" title="" loading="lazy"/></p><p><strong>电力卡了美国AI的脖子？</strong></p><p>美国电价正在快速上涨，自2022年以来已上涨 35%。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395044" alt="" title="" loading="lazy"/></p><p>电力是人工智能的阿喀琉斯之踵：核电需要20年才能投产，燃气轮机在2030年前几乎无法获得，而除中国和印度外，新建燃煤电厂已无可能。</p><p>然而，没有大量的额外电力，GPU只能吃灰，就不可能实现AI的大幅跃升，也无法实现AGI。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395045" alt="" title="" loading="lazy"/></p><p>《拯救地球，不要空谈》「Saving the Planet Without the Bull」的作者Assaad Razzouk预测：「<strong>这意味着太阳能、风能和电池储能系统（BESS）必须大幅增加，而且要快得多。</strong>」</p><p>他还指出另一种更糟糕的情况：在数据中心即将建设的地区，电价将进一步加速上涨，<strong>愤怒的民众会认为科技巨头正在掏空他们的口袋</strong>。</p>]]></description></item><item>    <title><![CDATA[英伟达铁幕之后，谷歌AI芯片已成气候 本]]></title>    <link>https://segmentfault.com/a/1190000047394992</link>    <guid>https://segmentfault.com/a/1190000047394992</guid>    <pubDate>2025-11-13 14:11:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>编辑：定慧</p><p>【新智元导读】英伟达在聚光灯下狂飙，谷歌却在幕后悄悄造出自己的AI基建帝国系统。当别人还在抢GPU时，它早已自给自足、闭环生长——闷声干大事，从未如此谷歌。</p><p>英伟达明修栈道，谷歌暗渡陈仓。</p><p>当你回头一看，谷歌在<strong>AI基础设施</strong>的优势已经无法阻挡。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394994" alt="" title=""/></p><p>这几天，谷歌终于把憋了很久的大招放出来了，CEO劈柴官宣了自研第七代TPU Ironwood正式商用。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394995" alt="" title="" loading="lazy"/></p><p>这是谷歌第七代TPU，单颗算力4614 TFLOPS（FP8精度），192GB的HBM3E内存，带宽高达7.37 TB/s。</p><p>与上一代TPU v5p相比峰值性能提升10倍！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394996" alt="" title="" loading="lazy"/></p><p>对于Google Cloud客户，Ironwood根据工作负载需求提供两种尺寸：256芯片配置和9216芯片配置。</p><p>也就是一个pod可以最多塞下9216个TPU，总算力达到了惊人的42.5 ExaFLOPS。</p><p>与之相比英伟达目前主推的的GB300 NVL72系统只有0.36 ExaFLOPS。</p><p>这就是为啥Anthropic直接买了100万颗TPU的根本原因。</p><p>谷歌才是那个真正低调发财的公司，有人总结AI价值链上所有公司涉足的领域。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394997" alt="" title="" loading="lazy"/></p><p>谷歌是<strong>唯一一家，没有之一，全栈人工智能公司</strong>：数据→算法→硬件→云服务器。</p><p>它使用自己的数据来训练自己的算法；这些算法在部署在自己的云上的自己的芯片上运行；然后开发了自己的应用程序。</p><p>如果说现在谷歌唯一的弱点，那可能就是「苹果」，准确的说，是客户端设备，手机。</p><p>虽然安卓系统是谷歌的，但是偏偏谷歌没有自己的手机（如果手机也有，谷歌称得上地球上最垄断的公司，也许没有之一。）</p><p>虽然Pixel系列出货量未能排在三星和国产等安卓机前面，但是用过Pixel的人都说好。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394998" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394999" alt="" title="" loading="lazy"/></p><p><strong>谷歌TPU十年进化</strong></p><p>谷歌TPU，全称张量处理单元 （Tensor Processing UnitT）， 从早期几代主要作为内部优化工具，到最新的迭代已构成一个成熟且极具竞争力的产品组合。</p><p>当英伟达在横向扩展（scale-out） 加速器市场占据主导地位时，谷歌已经构建了全球唯一一个专为训练和运行前沿模型而设计的、具有高容错性的超大规模系统。</p><p>2013年，谷歌面临一个关键时刻。</p><p>公司意识到，神经网络日益增长的计算需求（尤其是在语音识别领域）可能迫使他们将<strong>数据中心的规模翻倍</strong>。</p><p>这一预测使AI计算不再是一个机遇，而是对运营支出 （OpEx） 的生存威胁。</p><p>尽管谷歌早在2006年就考虑过构建专用集成电路 （ASIC），但直到2013年，这才真正成为一项迫在眉睫的任务。</p><p>TPU v1 的开发周期之快是前所未有的：从设计、验证、制造到部署至数据中心仅用了15个月！</p><p>TPU v1 于2015年在谷歌内部署，并于2016年的Google I/O大会上公开发布。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395000" alt="" title="" loading="lazy"/></p><p>TPU v1的诞生过程极不寻常。</p><p>它并非一个循序渐进的研发项目，更像是一项紧急的「救火」措施。</p><p>据报道，谷歌<strong>在构建芯片的同时才开始招聘团队</strong>，这表明该项目风险极高，但也具有最高优先级。</p><p>这种「冲刺」塑造了TPU的DNA：实用主义和领域特定优化压倒一切。</p><p>谷歌为了成功，牺牲了所有与神经网络无关的功能。</p><p>当AI由神经网络组成，TPU就是AI而诞生的。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395001" alt="" title="" loading="lazy"/></p><p><strong>架构哲学，摒弃通用性</strong></p><p>谷歌TPU v1是一款「仅限推理」的ASIC，专为TensorFlow框架设计。 （另一个深度学习框架就是Meta的PyTorch）</p><p>它与CPU和GPU的关键区别在于：TPU专为高吞吐量的<strong>低精度计算</strong>（如8位整数）而设计。</p><p>与CPU（通用处理器）和GPU（当时主要为图形渲染优化）不同，TPU彻底摒弃了非必需的硬件，如缓存、乱序执行和纹理映射单元。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395002" alt="" title="" loading="lazy"/></p><p>该芯片的核心是一个庞大的矩阵乘法单元，拥有 65,536 个 （256×256） 8位MAC单元，峰值性能达到每秒92万亿次操作 （TOPS）。</p><p>v1 采用了28nm工艺，时钟频率为700MHz，而其热设计功耗 （TDP） 仅为40W，远低于同期的GPU。</p><p>它被设计为一块PCIe卡，可安装在SATA硬盘插槽中，以便快速集成到现有服务器。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395003" alt="" title="" loading="lazy"/></p><p><strong>早期胜利，AlphaGo与惊人的能效比</strong></p><p>2016年，DeepMind的AlphaGo击败世界围棋冠军李世石，这一历史性事件的背后正是TPU v1在提供算力支持。</p><p>2017年发表的一篇具有里程碑意义的论文详细阐述了其性能。</p><p>在谷歌的生产工作负载（占数据中心NN推理需求的95%）中，TPU v1 的速度比同期的Intel Haswell CPU和英伟达 K80 GPU<strong>快15至30倍</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395004" alt="" title="" loading="lazy"/></p><p>然而，更关键的指标是<strong>能效比 （TOPS/Watt）</strong>，TPU v1 比CPU和GPU<strong>高出30至80倍</strong>。</p><p>这一数据揭示了谷歌从一开始的战略意图。</p><p>在超大规模数据中心的环境中，成本不仅由芯片的采购成本 （CapEx） 决定，更由其运行的电力成本 （OpEx） 决定。</p><p>TPU v1 的胜利不仅在于速度，更在于它解决了AI计算的总体拥有成本 （TCO） 问题。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395005" alt="" title="" loading="lazy"/></p><p><strong>中期规模化演进</strong></p><p>TPU v1 验证了ASIC的概念，但其「仅限推理」的特性意味着谷歌在模型训练方面仍依赖英伟达。</p><p>TPU v2 （2017年推出） 标志着谷歌向训练领域的战略转向。</p><p>关键的架构转变是：从8位整数计算转向浮点计算，特别是引入并推广了由Google Brain发明的 bfloat16 （bf16） 格式。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395006" alt="" title="" loading="lazy"/></p><p>bfloat16 是一个巧妙的工程妥协：它保留了与32位浮点数 （FP32） 相同的8位指数，但将尾数截短至7位。</p><p>这一设计在大幅降低内存占用和带宽需求的同时，保留了训练所需的动态范围，有效防止了梯度消失或爆炸。</p><p>规格方面，v2采用16nm工艺，搭载16GB高带宽内存 （HBM）（v1为DDR3），内存带宽飙升至600 GB/s，算力达到45 TFLOPS。</p><p>TPU v2引入了Pod（集群）概念，但在此之前与之后，<strong>GPU长期以集群/超算形态扩展</strong>。</p><p>英伟达随后在2018年推出<strong>DGX POD</strong>参考架构，2019 年起推出 <strong>DGX SuperPOD</strong> 并在 2020–2025 年持续更新（H200/GB200 等版本），这些都属于标准化的GPU集群解决方案。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395007" alt="" title="" loading="lazy"/></p><p>谷歌不再将TPU视为独立的加速器，而是设计了4芯片模块（180 TFLOPS）。</p><p>64个这样的模块被组装成一个256芯片的Pod，总性能达到11.5 PFLOPS 6。</p><p>这是TPU历史上最重要的时刻之一。</p><p>谷歌停止了在「芯片竞赛」中追赶，转而开辟了「系统竞赛」的新战场。</p><p>TPU v3 （2018年） 延续了这一思路。</p><p>芯片性能提升至123T-ops，HBM增加到32GB。更重要的是，Pod的规模扩大了4倍，达到1024个芯片，使每个Pod的性能增加了8倍。</p><p>为了应对急剧增加的功率密度，液冷技术被引入并成为TPU Pod的标准配置，这使谷歌能够进一步挑战性能极限。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395008" alt="" title="" loading="lazy"/></p><p>到了第四代，TPU v4 （2021）可以和与A100并驾齐驱，实现规模化领先。</p><p>TPU v4（2021年）是一次重大飞跃。采用7nm工艺，性能提升至275T-ops（<strong>T-ops 是 tera-operations per second的缩写</strong>，表示每秒执行的<strong>万亿次操作</strong>。）。</p><p>Pod规模再次扩大，达到4096个芯片。</p><p>关键改进在于互连：v4 芯片的互连带宽达到了上一代的10倍。</p><p>到2021年，TPU不再只是一个「高TCO效益」的选项。</p><p>它在原始性能上已经可以与英伟达的最佳产品正面竞争。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395009" alt="" title="" loading="lazy"/></p><p><strong>现代TPU产品，多元化和专业化</strong></p><p>TPU v5 的发布标志着谷歌从单一架构转向成熟、多元化的产品线。</p><p>v5有两个版本TPU v5e（Efficiency）和TPU v5p（Performance），v5e针对主流推理、微调和中小型训练负载设计；TPU v5p是<strong>训练谷歌Gemini 1.0模型</strong>所使用的核心系统。</p><p>与TPU v4相比，TPU v5p的<strong>FLOPS提高了2倍以上，高带宽内存（HBM）提高了3倍</strong> 。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395010" alt="" title="" loading="lazy"/></p><p>TPU v5p专为性能、灵活性和规模而设计，可以<strong>训练大型LLM模型</strong> ，速度比上一代TPU v4快2.8倍。</p><p>TPU v6，代号Trillium，于2024年5月宣布，并于同年10月提供预览。</p><p><strong>v6性能</strong>实现了<strong>918TFLOPS</strong>和1836TOPS (Int8) 的巨大飞跃。</p><p>这比v5e高出4.7倍，比v5p高出约2倍。<strong>规格</strong>32GB HBM，1600 GB/s带宽。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395011" alt="" title="" loading="lazy"/></p><p><strong>v6引入了关键架构：第三代SparseCore</strong>。</p><p>SparseCore 的引入表明谷歌正在解决Transformer模型中的特定瓶颈。</p><p>SparseCore是一种专门用于处理嵌入 (embeddings) 的加速器。</p><p>嵌入在排名和推荐模型中普遍存在，并且对传统的MXU来说计算效率低下。</p><p>Trillium 是一款专为训练Transformer和MoE（Mixture of Experts）模型而打造的芯片。</p><p>谷歌的<strong>Gemini 2.0是在Trillium (v6) 上训练的</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395012" alt="" title="" loading="lazy"/></p><p>谷歌CEO劈柴明确表示：「TPU为Gemini 2.0的训练和推理提供了100%的动力」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395013" alt="" title="" loading="lazy"/></p><p><strong>TPU v7推理时代的专业芯片</strong></p><p>TPU v7，代号Ironwood，于2025年4月发布。</p><p>Ironwood是首款<strong>专为推理而设计的TPU</strong>，而Trillium则是训练冠军。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395014" alt="" title="" loading="lazy"/></p><p>在战略和资本层面，这反映了一种钟摆策略。谷歌使用v6 (Trillium) 来构建前沿模型 (CapEx投入)，现在发布v7 (Ironwood) 来规模化服务这些模型 (OpEx消耗)。</p><p>Ironwood 旨在优化推理的TCO。（毕竟我们人类已经进入AI推理时代）</p><p><strong>Ironwood达到4614 TFLOPS (FP8)</strong>，比Trillium的Int8性能高出2.5倍以上。<strong>能效比是Trillium的2倍</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395015" alt="" title="" loading="lazy"/></p><p>Ironwood将在未来几周年内全面上市。市场对Ironwood的早期反响极为热烈。</p><p>比如，谷歌列出了一些已经下订单的企业，Anthropic、Lightricks、essential AI。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395016" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395017" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395018" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395019" alt="" title="" loading="lazy"/></p><p><strong>CPU也造，还有最新虚拟机</strong></p><p>除了TPU，谷歌还造了自己的第一颗通用处理器Axion。</p><p>用谷歌自己的话：构建和运维现代应用既需要高度专业化的加速器，也离不开强大高效的通用计算能力。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395020" alt="" title="" loading="lazy"/></p><p>基于这颗CPU，谷歌还发布了最新的Axion虚拟机，N4A。</p><p>基于Arm架构的全新Axion实例现已开放预览。</p><p>与当前同代基于x86架构的虚拟机相比，N4A可提供高达2倍的价格性能优势。</p><p>除了虚拟机，还推出了裸金属实例，C4A。</p><p>C4A裸金属实例（即将进入预览阶段）是谷歌首款基于Arm架构的裸金属实例，为专用工作负载提供专属物理服务器，适用于Android开发、汽车车载系统、严格许可要求的软件、规模化测试农场或运行复杂模拟等场景。</p><p>谷歌的云服务在2025年3季度处于世界第3，前面是亚马逊和微软。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395021" alt="" title="" loading="lazy"/></p><p>正如文章开头所说，谷歌是现在AI领域唯一一家全栈技术公司，数据、算法、模型、云服务、CPU、GPU，需要什么就自己造什么。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395022" alt="" title="" loading="lazy"/></p><p>虽然在很多时候，谷歌没有排在第一，但是在任何领域，谷歌都榜上有名。</p><p>也许这才是真正的闷声发大财。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395023" alt="" title="" loading="lazy"/></p><p>2025年10月，Anthropic宣布扩大合作，获得高达<strong>100万个TPU芯片</strong>的使用权。</p><p>该协议价值<strong>数百亿美元</strong>，并将在2026年提供超过<strong>1吉瓦 (Gigawatt)</strong> 的计算容量。</p><p>虽然全球的聚光灯几乎都照在英伟达身上，但在聚光之外，谷歌的<strong>AI基础设施版图</strong>已经悄然成形，甚至形成了自己独立的「气候系统」。</p><p>谷歌给自己这套系统起了个名字：AI Hypercomputer。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395024" alt="" title="" loading="lazy"/></p><p>英伟达是舞台中央的光芒，谷歌则隐藏在大幕之后。</p><p>当所有AI公司都在抢购H系列GPU时，谷歌早已在自己的TPU集群上完成了<strong>自我造血循环</strong> ——训练、部署、推理、优化，全都在自己的系统内部完成。</p><p><strong>谷歌AI基金（Google AI Infrastructure Fund）</strong> 便是在这种体系下自然诞生的产物。</p><p>它不仅是投资基金，更像是一个生态基金池，用以扶持所有基于谷歌云与TPU生态的AI公司。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395025" alt="" title="" loading="lazy"/></p><p>Anthropic、Cohere、Character.AI、Essential AI……</p><p>这些名字在外界看来是独立的创业公司，但它们在算力与模型底座上，都深度绑定谷歌的TPU集群与Gemini模型家族。</p><p>换句话说，谷歌的AI基金并非简单的「投资人」，而是用资本作为粘合剂，<strong>将算力、云服务与生态绑定在一起</strong>。</p><p>当这些公司成长、融资、甚至上市时，谷歌都在背后分得红利。</p><p>这就是谷歌真正的护城河：</p><p>不是某一代TPU芯片的领先；</p><p>也不是Gemini模型的参数量；（Gemini 3马上要发布了）</p><p>而是一个可自我进化、自我繁殖的<strong>AI生态系统</strong>。</p><p>在未来的几年中，当市场仍在讨论GPU的供需、算力的溢价、芯片的带宽时，谷歌的TPU与AI基金正以稳健的方式持续扩张。</p><p>它的节奏不快，但势能深厚，气候已成。</p>]]></description></item><item>    <title><![CDATA[65岁图灵巨头离职创业！LeCun愤然与]]></title>    <link>https://segmentfault.com/a/1190000047394967</link>    <guid>https://segmentfault.com/a/1190000047394967</guid>    <pubDate>2025-11-13 14:10:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>编辑：好困 桃子</p><p>【新智元导读】AI圈爆出大瓜！65岁图灵巨头LeCun即将离职Meta，与小扎正式决裂。接下来，他将投身「世界模型」开启创业下半场。</p><p>图灵巨头LeCun真的要跑路了！</p><p>刚刚，FT独家爆料，现任Meta首席AI科学家LeCun，决定将在未来几个月离职。</p><p>下一步，开启人生创业的第二阶段。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394969" alt="" title=""/></p><p>消息一出，瞬间引爆全网。此前，坊间传闻称，LeCun因不满内部架构调整想要离职。</p><p>如今，65岁的图灵巨头，终于做出了这个决定。</p><p>扩展阅读：</p><p>LeCun考虑辞职！Meta AI百亿豪赌引爆「内战」，逼走首席科学家</p><p>LeCun怒揭机器人最大骗局，坦白Llama与我无瓜！</p><p>据称，LeCun将要成立的新公司主要推进「世界模型」，目标直指真正的人类级智能。</p><p>目前，他正在进行早期的融资洽谈。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394970" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394971" alt="" title="" loading="lazy"/></p><p>网友盲猜，LeCun离职可能和会见吴恩达有所关联</p><p>任职12年，从创办FAIR实验室，到拿下图灵奖，再到笃定的世界模型，LeCun出走对于Meta来说，是一次巨震。</p><p>或许，小扎的超级智能梦，真的要碎了。</p><p>有网友表示，这并不意外。另有人调侃道，「要始终向一个孩子汇报工作，LeCun的自尊心怎么不会受到伤害呢」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394972" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394973" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394974" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394975" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394976" alt="" title="" loading="lazy"/></p><p>上下滑动查看</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394977" alt="" title="" loading="lazy"/></p><p><strong>效力12年决裂，LeCun愤然离职</strong></p><p>不得不说，这事儿来的太突然，但却早有苗头。</p><p>当前，正值Meta对公司AI业务进行大刀阔斧的改革之际，希望开发出更强大的AI，挑战OpenAI、谷歌等竞争对手。</p><p>今年初，Llama 4发布翻车，且性能远不及ChatGPT、Gemini等模型。而且，Meta AI聊天机器人推出后，许多人并不买账。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394978" alt="" title="" loading="lazy"/></p><p>在认定Meta在竞争中落后之后，小扎的战略重心也随之改变——</p><p>从LeCun领军的FAIR实验室，转向更快推出模型和AI产品。</p><p>先是今年4月，小扎斥资143亿美元聘请了28岁Alexandr Wang，去领导全新「超级智能」团队。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394979" alt="" title="" loading="lazy"/></p><p>在此过程中，他亲自组建TBD Lab，开出高达1亿美元的薪酬包，从谷歌、OpenAI抢人。</p><p>其中包括，ChatGPT的核心研究员Shengjia Zhao，被挖来出任MSL首席科学家。</p><p>目标很简单，推动其下一代大语言模型的开发。</p><p>仅在今年，Meta内部就进行了超4次架构调整和优化，并将MSL分立出四大部门，全部由Alexandr Wang掌舵：</p><p>1. TBD Lab （To Be Determined，待确定，负责探索/先导研究）</p><p>2. FAIR （Fundamental AI Research，长期前沿研究）</p><p>3. 产品和应用团队 （含Meta AI助手等）</p><p>4. 基础设施 （训练与推理的算力、数据与平台）</p><p>因此，此前向首席产品官Chris Cox汇报的LeCun，现在转而向Wang汇报。</p><p>不仅如此，LeCun长期领导的FAIR也逐渐被边缘化，向比他小30多岁的Wang汇报，包括论文，也需得到审批后才可发表。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394980" alt="" title="" loading="lazy"/></p><p>另一方面，LeCun认为小扎置于其战略核心的LLM虽然「有用」，但永远无法像人类一样进行推理和规划。</p><p>在FAIR内部，LeCun也一直专注于开发「世界模型」，但在短期内，是看不到KPI的。</p><p>而小扎现在要的是，立即就能变现的AI产品。</p><p>看得出，LeCun所坚持的路线和个人观点，与Meta的AI愿景出现了明显的分歧。</p><p>种种因素的叠加，早已成为LeCun离职的导火索。而现在，就是最好的时机。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394981" alt="" title="" loading="lazy"/></p><p><strong>全力押注「世界模型」</strong></p><p>庆幸的是，LeCun终于可以在「世界模型」上大展身手了。</p><p>一直以来，他坚信大模型最终没有出路，永远学不会真正的推理和规划，也根本无法通往AGI。</p><p>LLM不如阿猫阿狗，LeCun已在多种公开场合中多次提出。</p><p>在他看来，AI的终局就是「世界模型」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394982" alt="" title="" loading="lazy"/></p><p>前段时间，他在MIT访谈中直言，未来3-5年内，「世界模型」会成为AI架构的主流模型。</p><p>这话可让我在硅谷得罪了不少人，包括某些巨头公司。</p><p>到那时候，但凡头脑清醒的人，都不会再用现在这种生成式LLM的路子了。</p><p>世界模型不仅仅学习语言，还通过视频和空间数据，来理解物理世界。</p><p>直白讲，它让AI可以像婴儿一样，从观察中学习世界的规律。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394983" alt="" title="" loading="lazy"/></p><p>不过，LeCun表示，开发出这个架构需要十年的时间才能成熟。</p><p>即便时间漫长，他终于可以坚定按着目标方向前进了。</p><p>未来几个月，LeCun将正式离职Meta，下一步计划将专注于深化在「世界模型」领域的研究。</p><p>AI掌舵人出走，这意味着，FAIR实验室就彻底被边缘化了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394984" alt="" title="" loading="lazy"/></p><p><strong>图灵巨头，开启AI革命</strong></p><p>1960年7月8日出生的Yann LeCun，在法国巴黎的郊区长大。</p><p>他的姓氏原本是Le Cun，但他发现美国人常对此感到困惑，将Le误作他的中间名，于是便去掉了中间的空格。</p><p>他的父亲是一名工程师，在LeCun充满修补创造的童年中，将自己对电子和机械的热爱传给了他。</p><p>青少年时期，LeCun既喜欢在乐队中演奏，也热爱科学与工程。</p><p>后来，他在法国精英工程师学校之一的巴黎高等电子与电工工程师学院（ESIEE Paris）获得了相当于硕士的学位。在那里，他专注于微芯片设计与自动化。</p><p>他从本科时代就开始独立进行机器学习研究，并将其作为他在索邦大学（当时称为皮埃尔和玛丽·居里大学）博士阶段的核心工作。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394985" alt="" title="" loading="lazy"/></p><p>LeCun的研究与Geoffrey Hinton独立做出的发现高度相似。</p><ul><li>与Hinton一样，他被当时尚属非主流的神经网络人工智能方法所吸引；</li><li>也与Hinton一样，他发现可以通过使用后来被称为「反向传播」的算法来有效训练输入和输出节点之间中间层的「隐藏」神经元，从而克服简单神经网络众所周知的局限性。</li></ul><p>1985年在法国阿尔卑斯山区举办的一场研讨会，首次让LeCun与从事相关研究的国际学术界有了直接接触。</p><p>正是在那里，他结识了Hinton的密切合作者Terry Sejnowski。当时，Sejnowski关于反向传播的研究尚未发表。</p><p>几个月后，Hinton到访巴黎，并主动向LeCun作了自我介绍。</p><p>再之后，LeCun则受邀参加卡内基梅隆大学的夏季研讨会，并在多伦多Hinton新成立的研究小组进行了一年的博士后研究。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394986" alt="" title="" loading="lazy"/></p><p>1988年，博士后研究结束时，LeCun加入了著名的计算机科学研究中心——贝尔实验室。</p><p>在贝尔实验室，LeCun的工作专注于神经网络架构和学习算法。</p><p>他影响最为深远的贡献是一种名为「卷积神经网络」的新方法。这是他早期成就的延伸，因为卷积网络依赖反向传播技术来训练其隐藏层。</p><p>除了开发卷积方法，LeCun还率先将其应用于「图Transformer网络」，用于识别印刷体和手写文本。这项技术被用于一个广泛部署的系统，以读取支票上的手写数字。</p><p>他在贝尔实验室的另一项主要贡献是开发了「最佳脑损伤」（Optimal Brain Damage）正则化方法。</p><p>这个名字生动的概念旨在通过移除神经网络中不必要的连接来简化网络。如果操作得当，这种「脑损伤」可以产生更简单、更快速的网络，其性能与完整版本相当甚至更优。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394987" alt="" title="" loading="lazy"/></p><p>1996年，在计算机行业未能立足的AT&amp;T公司，将贝尔实验室的大部分业务及其电信硬件业务分拆成立了一家新公司——朗讯科技。</p><p>LeCun留在了AT&amp;T，负责一个专注于图像处理研究的实验室小组。</p><p>在那里，他的主要成就是DjVu图像压缩技术。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394988" alt="" title="" loading="lazy"/></p><p>2003年，LeCun离开工业界，前往纽约大学库朗数学科学研究所担任计算机科学教授。</p><p>在纽约大学，LeCun负责计算与生物学习实验室，继续他在机器学习算法和计算机视觉应用方面的工作。</p><p>他至今仍在纽约大学任教，尽管随着声誉日隆，他又增添了几个新头衔和额外职位。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394989" alt="" title="" loading="lazy"/></p><p>到2010年代初，各大科技公司竞相部署基于神经网络的机器学习系统。与其他顶尖研究人员一样，LeCun也受到了科技巨头的青睐。</p><p>2013年12月，他加入Facebook并创建了FAIR（Facebook AI Research），同时，他也还兼顾在纽约大学的工作。</p><p>2018年，他卸任主任一职，转任Facebook首席人工智能科学家，专注于战略规划和科学领导力。</p><p>同年，他与Geoffrey Hinton和Yoshua Bengio，共同获得了图灵奖。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394990" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394991" alt="" title="" loading="lazy"/></p><p>时至今日，LeCun一直保持着对动手创造的热爱，他的爱好包括制造飞机、电子乐器和机器人。</p><p>或许，这也是他在65岁时，毅然决定下海创业的动力之一。</p><p>参考资料：</p><p><a href="https://link.segmentfault.com/?enc=FXDKcHGn%2BpYvDBnAYByC3g%3D%3D.hseaUK8FvxgsvAvEcvr8xqVV%2B%2Fri0PysPrPDWyc9jyhhzsrkaGsvI%2FPnOoCHQdv%2BeCNFWmaQjzCwTIH%2BYecmgg%3D%3D" rel="nofollow" target="_blank">https://www.ft.com/content/c5...</a></p>]]></description></item><item>    <title><![CDATA[GPT-5.1凌晨突袭，奥特曼听劝！全网]]></title>    <link>https://segmentfault.com/a/1190000047394943</link>    <guid>https://segmentfault.com/a/1190000047394943</guid>    <pubDate>2025-11-13 14:10:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>一共有三个版本，目前已经上线了前两个：</p><p><strong>· GPT-5.1 Instant ：</strong>最常用的模型，语气更亲切、更智能，更善于遵循指令。</p><p><strong>· GPT-5.1 Thinking ：</strong>先进的推理模型，更易于理解，处理简单任务速度更快，处理复杂任务更具持久力。</p><p><strong>· GPT-5.1 Pro：</strong>即将上线</p><p>奥特曼激动表示，GPT-5.1升级给力，尤其是指令遵循和自适应思考的改进。</p><p>当然，整体的智力和沟通风格，提升也很显著。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394945" alt="" title=""/></p><p>还记得8月初，GPT‑5正式诞生，虽在全方位性能提升，但变得没有人味，更加冷淡。</p><p>一时间，全网喊话集体讨回GPT-4o、o3等模型。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394946" alt="" title="" loading="lazy"/></p><p>许多人的真实反馈OpenAI听进去了——「一个优秀的AI不仅要聪明，还得会唠嗑才行」。</p><p>如今，两个月的迭代，OpenAI把让所有人最想要的GPT-5.1带来了。</p><p>正如科学副总裁Kevin Weil所言，GPT-5.1是OpenAI迄今为止推出的最完美的组合，<strong>智商与情商双双在线</strong>！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394947" alt="" title="" loading="lazy"/></p><p>值得一提的是，GPT-5.1 Instant还要比4o的情商智商更强。</p><p>OpenAI研究科学家Aidan McLaughlin称——</p><p>它是首个使用思维链（CoT），引入了「自适应推理」的模型，速度和GPT-5 Instant一样快。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394948" alt="" title="" loading="lazy"/></p><p>不仅如此，每个人还可以轻松地塑造ChatGPT的语气。</p><p>毕竟，每个人对聊天风格偏好不尽相同，甚至在不同对话中也会变化——因此通过「控制选项」，就可以轻松拿捏ChatGPT说话的调调，让其更对胃口。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394949" alt="" title="" loading="lazy"/></p><p>从专业可靠（Professional）、亲和友善（Friendly），到直言不讳（Candid）、天马行空（Quirky），再到吐槽达人（Cynical）、高效务实（Efficient）、技术宅（Nerdy），都能任意挑选<strong>。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394950" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394951" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394952" alt="" title="" loading="lazy"/></p><p><strong>GPT-5.1：更智能、更健谈</strong></p><p>这次升级后的GPT-5.1，在智力和沟通上，得到了大幅升级。</p><p>你会注意到的是，GPT-5.1的所有回答在感觉上都更智能，语气也更自然。</p><p>其中，GPT-5.1 Auto将继续为每个查询自动选择最适合的模型，因此在大多数情况下，你完全无需手动选择。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394953" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394954" alt="" title="" loading="lazy"/></p><p><strong>GPT-5.1 Instant</strong></p><p>GPT-5.1 Instant是ChatGPT使用最广的模型，现在它的默认语气将会更显亲切和健谈。</p><p>根据早期测试，它常常会出其不意地展现出俏皮的一面，同时回答依然清晰实用。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394955" alt="" title="" loading="lazy"/></p><p>I’m feeling stressed and could use some relaxation tips</p><p>我感到有压力，需要一些放松的建议</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394956" alt="" title="" loading="lazy"/></p><p>GPT-5.1 Instant</p><p>除此之外，OpenAI还改进了指令遵循能力，使模型能更可靠地回答你实际提出的问题。</p><p>Always respond with six words</p><p>始终用六个词回答</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394957" alt="" title="" loading="lazy"/></p><p>GPT-5.1 Instant（上下滑动查看）</p><p>值得一提的是，GPT-5.1 Instant首次引入了「自适应推理」能力，能够自主决定在回应更具挑战性的问题前是否需要深入思考，从而在保持快速响应的同时，产出更周全、更准确的答案。</p><p>这一点在AIME 2025和Codeforces等数学与编程评测中的显著进步得到了体现。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394958" alt="" title="" loading="lazy"/></p><p><strong>GPT-5.1 Thinking</strong></p><p>与此同时，升级后的GPT-5.1 Thinking也会在日常使用中更高效、更易于理解。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394959" alt="" title="" loading="lazy"/></p><p>现在，它能更精确地根据问题调整思考时间——在复杂问题上投入更多时间，而在简单问题上则响应更快。</p><p>在实际使用中，这意味着对于困难的请求，你将获得更详尽的答案；对于简单的请求，等待时间则会更短。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394960" alt="" title="" loading="lazy"/></p><p>GPT-5.1 Thinking的回复也更加清晰，减少了专业术语和晦涩词汇的使用。</p><p>这使OpenAI最强大的模型变得更平易近人、更易于理解，尤其是在处理复杂工作任务和解释技术概念时。</p><p>explain BABIP and wRC+</p><p>解释BABIP和wRC+</p><p>PT-5.1 Thinking（上下滑动查看）</p><p>GPT-5.1 Thinking的默认语气也更加亲切，更富同理心。</p><p>Ugh I spilled coffee all over myself before my meeting do you think everyone thought I was an idiot 🙁</p><p>呃，我在会议前把咖啡洒满了自己，你觉得大家会不会都认为我是个白痴 🙁</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394961" alt="" title="" loading="lazy"/></p><p>GPT-5.1 Thinking</p><p><strong>关于命名的一点说明：</strong></p><p>本次更新名为GPT-5.1，旨在反映其重大改进，同时表明它仍属于GPT-5这一代。未来对GPT-5的迭代升级将遵循相同的模式。</p><p>同在今天，OpenAI还发布了GPT-5.1系统卡，更多内容可参阅PDF。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394962" alt="" title="" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=Jgu6hdEGpJXj8r8Kpc74DA%3D%3D.NFMM9UB1u2Pdt%2BkxqoPjMTYrX2TyWZZPprs9%2FTLCKVGc4VYwHibIoaAB3cau5DnEDSfFWXdM74pdB6UXKINKJB9MJ5uo88COEsAxWrvtXFE%3D" rel="nofollow" target="_blank">https://cdn.openai.com/pdf/41...</a>\_1\_system\_card.pdf</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394963" alt="" title="" loading="lazy"/></p><p><strong>让ChatGPT成为独一无二的你</strong></p><p>除了GPT-5.1重大升级，想要自定义ChatGPT的语气和风格，如今变得更加简单。</p><p>毕竟，众人胃口难调，每个人都有自己偏好的聊天方式和风格。</p><p>OpenAI的目标就是，所有人可以轻松搞定设置，让ChatGPT用自己最舒服的语气交流。</p><p>今年早些时候，OpenAI添加了预设选项来调整ChatGPT的回复语气。</p><p>今天，这些选项正在优化，可以更好地反映人们使用ChatGPT的最常见方式。</p><ul><li><strong>默认（Default）</strong>、<strong>亲和友善（Friendly）</strong>（原「倾听者」）和<strong>高效务实（Efficient）（</strong>原「机械」）风格将获得更新</li><li>同时新增了<strong>专业可靠（Professional）</strong>、<strong>直言不讳（Candid）</strong>和<strong>天马行空（Quirky）</strong>风格。</li><li><strong>吐槽达人（Cynical）</strong>和<strong>技术宅（Nerdy）</strong>风格则保持不变。</li></ul><p>这些选项旨在匹配OpenAI观察到的用户自然引导模型的方式，让人们能快速直观地选择一个感觉最对味的「个性」。</p><p>这些个性化设置适用于所有模型。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394964" alt="" title="" loading="lazy"/></p><p>左：GPT-5.1；右：GPT-5</p><p>除了这些预设，对于希望更精细地控制ChatGPT回应方式的用户，OpenAI还在试验一项新功能：</p><p>直接从个性化设置中调整ChatGPT的具体特征——包括其回复的简洁度、亲切度或易读性（是否便于快速浏览），以及使用表情符号的频率 。</p><p>当ChatGPT在对话中，注意到你偏爱某种特定语气或风格时，它还会主动提议更新这些偏好，而无需手动进入设置。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394965" alt="" title="" loading="lazy"/></p><p>与此同时，可以随时调整或移除这些偏好。</p><p>更新后的风格和语气选项，将于今日起陆续推出。微调特定特征的功能将作为一项实验，从本周晚些时候开始向部分用户逐步开放。</p><p>这两项功能，都将在后续不断得到完善。</p><p>此外，更新后的GPT-5.1也更善于遵循「自定义指令」，让你对语气和行为有更精确的控制。</p><p>目前，在个性化设置中更新后，会立即在所有聊天中生效，包括正在进行的对话，从而确保体验的一致性。</p><p>还需要注意一点是，对基础风格、语气或自定义指令的更改仅适用于新开启的对话。</p><p>总而言之，GPT-5.1重大更新和新的自定义选项，是OpenAI迈向一个更懂你、更智能、更健谈、更能适应个人偏好的ChatGPT的重要一步。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394966" alt="" title="" loading="lazy"/></p><p><strong>即日可用</strong></p><p>今日起，GPT-5.1 Instant和Thinking将率先向付费用户（Pro、Plus、Go、Business）陆续推出，随后向免费及未登录用户开放。</p><p>本周晚些时候，这两款模型也会登陆API。其中，GPT-5.1 Thinking将会以「GPT-5.1」的名称发布，而GPT-5.1 Instant则是「gpt-5.1-chat-latest」，两者均具备自适应推理能力。</p><p>未来三个月里，GPT-5（Instant和Thinking）将继续在ChatGPT的「旧模型」下拉菜单中为付费用户提供，以便用户按照自己的节奏进行比较和适应。</p><p>值得一提的是，OpenAI确实从上一次全系下架所有旧模型惹怒网友，吸取了惨痛的教训。</p><p>它们表示，未来当OpenAI推出新的ChatGPT模型时，策略是给予用户充足的空间来评估变化并分享反馈，从在平稳过渡的同时，持续创新前沿模型。模型的淘汰周期将会提前明确地通知。</p><p>参考资料：</p><p><a href="https://link.segmentfault.com/?enc=paYm9m8eSRUgjatfe%2FqVrA%3D%3D.nZUW0UTTlY6EQYrUzGBOBBlmUZCTXizLycvcnSBw115axP6LwRZ01I1%2BNtuIK2zq" rel="nofollow" target="_blank">https://openai.com/index/gpt-5-1</a></p><p><a href="https://link.segmentfault.com/?enc=33Pf6nJPQ1hSp2BYebRIEw%3D%3D.21wrz%2F8mTmrSy0z8D%2B7r9KGiDgGfmFwYI37DZ6s6pHioAEMfRtvuqm5j4QmUrM5IQCACjHB77O3eKt8ofhyL9A%3D%3D" rel="nofollow" target="_blank">https://twitter.com/OpenAI/st...</a></p>]]></description></item><item>    <title><![CDATA[今日AI要闻 | 2025年11月13日]]></title>    <link>https://segmentfault.com/a/1190000047394936</link>    <guid>https://segmentfault.com/a/1190000047394936</guid>    <pubDate>2025-11-13 14:09:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>1、<strong>OpenAI正式发布GPT-5.1系列模型</strong>并转向个性化“数字管家”战略，但前安全负责人炮轰奥特曼重开情色内容引发伦理争议</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394938" alt="" title=""/></p><p>2、<strong>Google DeepMind登Nature</strong>：三步对齐AI视觉与人类认知，让模型“看懂”猫狗蛋糕并提升鲁棒性与泛化能力</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394939" alt="" title="" loading="lazy"/></p><p>3、<strong>AlphaProof破解数学奥赛难题正式登Nature</strong>：谷歌DeepMind强化学习方法论解密，标志AI加速数学发现新时代</p><p>4、<strong>Anthropic豪掷500亿美元在美国自建AI数据中心</strong>，硬刚OpenAI万亿级基建竞赛并支持特朗普AI行动计划</p><p>5、<strong>李飞飞World Labs推出首款商用世界模型Marble</strong>：从文本图像生成可编辑3D环境，剑指游戏VFX和VR空间智能革命</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394940" alt="" title="" loading="lazy"/></p><p>6、<strong>AMD CEO苏姿丰强势押注AI算力基础设施长期牛市</strong>，回击“大空头”Michael Burry警告GPU折旧泡沫与财务隐忧</p><p>7、<strong>微软亚特兰大AI“超级工厂”首曝双层液冷设计</strong>，纳德拉访谈详解AGI商业模式与超大规模计算转型策略</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394941" alt="" title="" loading="lazy"/></p><p>8、Yann LeCun Meta遗作JEPA重生：50行代码解决自监督学习稳定性难题，LeJEPA框架在多数据集上展现强劲泛化</p><p>9、AlphaResearch升级LLM为“算法发现者”：在模拟评审环境中自主优化刷新圆packing纪录，并公开失败案例指路未来</p><p>10、小模型大逆袭接管Agentic AI：NVIDIA研究指低于10B参数SLM更适合代理任务，成本延迟双降开启普惠高效时代</p><p><strong>汇编：犀牛 查看更多要闻详情：<a href="https://link.segmentfault.com/?enc=KvscKkFr6KZIKQz0S%2B9bbQ%3D%3D.qYRkO1DaMKf0jYUU9Z9IQSFhBfF9V0MpPU%2FEi9fKewU%3D" rel="nofollow" target="_blank">https://aiera.com.cn/</a></strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394942" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[企业代码签名证书可以免费吗？ 从未表白的]]></title>    <link>https://segmentfault.com/a/1190000047394880</link>    <guid>https://segmentfault.com/a/1190000047394880</guid>    <pubDate>2025-11-13 14:09:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h4><strong>一、 什么是代码签名证书？</strong></h4><p>简单来说，代码签名证书就像软件的“官方封印”。它的核心作用有两点：</p><ul><li><strong>验证开发者身份</strong>：向用户证明这个软件确实来自您的企业，而不是黑客伪造的。</li><li><strong>保证代码完整性</strong>：确保软件从您发布到用户下载的整个过程中，没有被植入病毒或恶意修改。</li></ul><p>如果没有这个证书，用户运行时可能会看到<strong>“未知发布者”的安全警告</strong>，这不仅影响用户体验，更会严重损害企业声誉。</p><h4><strong>二、 免费的代码签名证书存在吗？</strong></h4><p>答案是：<strong>基本上不存在真正免费且适用于企业的代码签名证书。</strong></p><p>您可能在网络上看到过一些“免费”的选项，但它们通常具有极大的局限性，完全无法满足企业的商业需求：</p><ul><li><strong>仅限个人开发者</strong>：某些开源项目提供的免费证书，明确要求<strong>不能用于商业目的</strong>。企业使用属于违规，可能导致证书被吊销。</li><li><strong>有效期极短</strong>：可能只有几个月。对于企业软件而言，需要保证长期可用性。证书一旦过期，之前签名的软件就可能弹出警告，维护成本极高。</li><li><strong>缺乏信任背书</strong>：这些免费证书的颁发机构往往知名度低，其根证书可能未被所有操作系统广泛信任，导致在某些电脑上警告依然存在。</li><li><strong>无法律保障</strong>：这是最关键的一点。</li></ul><h3><a href="https://link.segmentfault.com/?enc=80ypF9NScQK2NO6JI3w4ww%3D%3D.z5ZjqTGZb5F9PWcwhr9N%2F%2BSQ0wd8sL56L3scHh6sIFN9mB%2BiZpVIk5dqp4o8IGAt3usXf2ZLCfDFmWyBg67KbqDP4geyA2fwGlqeiWmiSu4%3D" rel="nofollow" target="_blank">代码签名证书申请入口</a></h3><p>直接访问JoySSL，注册一个账号记得填写注册码230931获取免费安装服务和内部优惠价。<br/><img width="625" height="337" referrerpolicy="no-referrer" src="/img/bVdkwhd" alt="" title=""/></p><h4><strong>三、 为什么企业必须选择付费证书？</strong></h4><p>付费的商业代码签名证书，其价值远不止于“签名”这个动作本身。企业支付的费用，购买的是以下几项核心保障：</p><p><strong>1. 严格的身份验证</strong><br/>权威的证书颁发机构会对企业进行严格的线下审查，包括核实<strong>营业执照的合法性</strong>和<strong>企业电话地址的真实性</strong>。这个过程确保了只有合法注册的企业才能获得证书，这是建立用户信任的基石。</p><p><strong>2. 强大的兼容性与信任度</strong><br/>主流付费证书的根证书已经内置到Windows、macOS等各大操作系统中。这意味着您签名的软件能在全球绝大多数用户的电脑上<strong>无缝识别，不会出现安全警告</strong>，确保了软件的顺利分发。</p><p><strong>3. 关键的法律保护与责任担当</strong><br/>付费证书通常附带<strong>责任保险</strong>。如果因为证书本身的安全问题导致用户遭受损失，保险公司会提供赔付。这不仅是经济上的保障，更是<strong>企业对用户负责态度的体现</strong>。</p><p><strong>4. 微软WHQL认证的“敲门砖”</strong><br/>如果您的企业需要开发Windows硬件驱动程序，<strong>微软严格要求必须使用付费的OV型代码签名证书</strong>来通过WHQL认证。免费证书完全不具备这个资格。</p><h4><strong>总结</strong></h4><p>对于企业而言，代码签名证书是一项必要的、关乎品牌信誉和用户安全的基础投资。<strong>免费选项看似节省了成本，实则带来了巨大的兼容性风险、法律风险和维护负担。</strong> 选择一款来自权威机构的付费代码签名证书，是企业保护自身知识产权、赢得用户信任、保障业务顺利开展的明智之举。</p>]]></description></item><item>    <title><![CDATA[大型企业为什么都用OV通配符SSL证书？]]></title>    <link>https://segmentfault.com/a/1190000047394884</link>    <guid>https://segmentfault.com/a/1190000047394884</guid>    <pubDate>2025-11-13 14:08:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h4><strong>一、 什么是OV通配符SSL证书？</strong></h4><p>要理解它的优势，我们首先得拆解它的名字：</p><ul><li><strong>SSL证书</strong>：是安装在服务器上的一个“数字身份证”，主要实现两大功能：<strong>加密数据传输</strong>（防止信息被窃取）和<strong>身份验证</strong>（证明“我就是我”）。</li><li><strong>OV（组织验证）</strong>：指的是证书颁发机构（CA）在签发证书前，会对企业的真实合法性进行严格的线下审查。这包括核查公司的营业执照、电话地址等。通过OV验证后，证书里会包含清晰的企业信息。</li><li><strong>通配符（*）</strong>：指的是证书可以保护一个主域名及其所有的下一级子域名。例如，一张为 <code>*.yourcompany.com</code> 颁发的证书，可以同时用于 <code>www.yourcompany.com</code>、<code>mail.yourcompany.com</code>、<code>shop.yourcompany.com</code> 等。</li></ul><p>简单来说，<strong>OV通配符SSL证书就是一张经过严格企业身份验证的、可以保护无限个子域名的“高级安全通行证”。</strong></p><h3><a href="https://link.segmentfault.com/?enc=3FrwCY1B3Rxlktvp%2BVDXxw%3D%3D.VyrypHMc5TwbiVfJHZSMw75hMBjYWxBDoE8oXo46RFoZ3x0CYYZGmYwYzL5VW4coK7ztVUgrjqlSamQza6mRlawTPD0DeDE5hYANuG91Lz69K8XxMhIttg3sEokC5eKj" rel="nofollow" target="_blank">OV通配符SSL证书申请入口</a></h3><p>直接访问JoySSL，注册一个账号记得填写注册码230931获取免费安装服务和内部优惠价。<br/><img width="367" height="189" referrerpolicy="no-referrer" src="/img/bVdhZKx" alt="" title=""/></p><h4><strong>二、 核心优势：为何大企业情有独钟？</strong></h4><p>大型企业选择它，是基于对安全、成本和管理的综合考量。</p><p><strong>1. 安全与信任双赢：树立权威形象</strong></p><p>这是最关键的一点。与仅验证域名所有权的DV证书相比，OV证书<strong>多了一层企业身份验证</strong>。当用户点击小锁图标查看证书详情时，可以看到经过认证的企业名称。这相当于向客户和合作伙伴宣告：“这是一个真实存在的合法企业，而非皮包公司。” <strong>极大地增强了用户信任度，提升了品牌形象和交易转化率</strong>。</p><p><strong>2. 管理效率与成本效益的完美平衡</strong></p><p>大型企业通常拥有成百上千个子域名，如果为每一个子域名单独购买和部署证书，将是一场管理噩梦。通配符功能彻底解决了这个问题。</p><ul><li><strong>一证多用</strong>：只需申请、安装和管理一张证书，即可覆盖所有同级子域名。</li><li><strong>简化运维</strong>：当证书需要续期或更换时，只需操作一次，<strong>大幅降低了IT团队的运维复杂度和时间成本</strong>。</li><li><strong>经济高效</strong>：虽然单张OV通配符证书的价格较高，但相比于为每个子域名单独购买证书，总成本要低得多，实现了规模效应。</li></ul><p><strong>3. 灵活性与可扩展性强</strong></p><p>企业在发展过程中，会不断推出新的在线服务，随之会产生新的子域名。使用通配符证书，<strong>未来新增的任何同级子域名都能立即受到保护，无需再次购买或部署证书</strong>，为企业业务的快速扩展提供了极大的灵活性。</p><h4><strong>总结</strong></h4><p>对于大型企业而言，网络安全无小事。OV通配符SSL证书完美地满足了它们在<strong>建立可信身份、实现高效管理、控制总体成本</strong>方面的核心需求。它不仅仅是一个技术工具，更是企业安全战略中的重要一环，是保障业务稳定运行、赢得用户信赖的明智投资。v</p>]]></description></item><item>    <title><![CDATA[超越加密，成就信任：OV SSL证书的商]]></title>    <link>https://segmentfault.com/a/1190000047394889</link>    <guid>https://segmentfault.com/a/1190000047394889</guid>    <pubDate>2025-11-13 14:07:45</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字世界的每一次交互中，安全是基石，信任则是桥梁。当用户访问您的网站时，地址栏那个小小的锁形标志，早已不仅仅是加密的象征，它更是一张无声的“信任名片”。在众多SSL证书类型中，组织验证型证书（OV SSL）以其独特的商业价值，正成为众多企业，特别是JoySSL用户，构建可信赖在线形象的战略选择。</p><p><a href="https://link.segmentfault.com/?enc=px1HxaDux9Cvrg%2FMVF2YTg%3D%3D.%2BhdrZNF%2B1lu3%2BE74Gt9n31e3lFxJvyVbQEGg1vV0dzlLG5AeWK2cQTg7USURv%2BwRdeIRxschb8w%2BgsavJJWJQg%3D%3D" rel="nofollow" target="_blank">点击打开JoySSL官网填写注册码230960获取一对一技术支持</a></p><h4><strong>不止于加密：OV SSL的核心内涵</strong></h4><p>首先，我们必须明确一点：所有SSL证书都提供基础的加密功能，确保数据在传输过程中不被窃取。但OV SSL的价值，远“超越”于此。</p><p>与仅验证域名所有权的域名验证型证书（DV SSL）不同，OV SSL需要进行严格的组织身份验证。全球可信的证书颁发机构（CA）会人工核查申请企业的真实存在性，包括工商注册信息、物理地址和电话等。这一关键步骤，使得OV SSL证书不仅激活HTTPS和显示锁形标志，更能在点击锁标后，清晰地展示<strong>经过验证的企业名称</strong>。</p><p><strong>这正是“加密”向“信任”的飞跃。</strong> JoySSL作为专业的证书服务提供商，深知这一飞跃对企业的重要性，因此其提供的OV SSL证书严格遵循国际标准验证流程，为您企业的可信度背书。</p><h4><strong>OV SSL的商业价值全解析</strong></h4><p>那么，这张展示了企业实名的“信任名片”，具体能为您带来哪些商业价值呢？</p><p><strong>1. 建立品牌信任，直接提升转化率</strong><br/>在电商、金融、政务及任何需要用户提交敏感信息的场景中，信任是促成交易的最后一道关卡。当一个潜在客户看到网站由“某有限公司”验证并保护时，其安心感远胜于一个仅显示“安全连接”的未知网站。这种透明的信任建立，能有效降低购物车放弃率，提升用户注册和支付的意愿，直接驱动业务增长。</p><p><strong>2. 有效防范网络钓鱼，保护品牌声誉</strong><br/>网络钓鱼攻击者通常使用DV证书来伪装成合法网站，因为它们易于获取且同样显示锁标。然而，他们无法通过OV SSL严格的组织验证。因此，部署JoySSL OV证书相当于为您的品牌设立了一道防伪屏障。用户可以通过查验企业名称来轻松辨别真伪，从而保护您的客户免受欺诈，维护您来之不易的品牌声誉。</p><p><strong>3. 强化企业专业形象，凸显行业地位</strong><br/>在竞争激烈的市场环境中，细节决定成败。一个展示了真实企业身份的网站，向访客传递出严谨、正规、注重安全和长期经营的积极信号。这对于B2B商务、招标投标、品牌官网等场景至关重要，是凸显您行业领导地位和专业性的低成本、高回报投资。</p><p><strong>4. 满足合规性要求，为业务保驾护航</strong><br/>越来越多的行业法规和数据保护法案（如GDPR、PCI DSS支付卡行业数据安全标准等）明确要求，企业必须采取适当措施保护用户数据并验证身份。使用经过严格验证的OV SSL证书，是满足这些合规性要求的重要一环。JoySSL OV证书由全球根证书库信任的CA签发，确保您的业务在法律和行业规范框架内稳健运行。</p><p><strong>5. 提升SEO搜索排名优势</strong><br/>虽然谷歌表示所有HTTPS网站都享有基础排名提升 benefit，但一个可信赖、身份透明的网站无疑会获得搜索引擎更高的质量评价。信任度是搜索引擎排名算法的隐性因素之一。使用OV SSL，通过增强网站可信度，间接为您的SEO优化工作添砖加瓦。</p><h4><strong>为什么选择JoySSL的OV SSL证书？</strong></h4><p>在理解了OV SSL的巨大价值后，选择一个可靠的服务提供商至关重要。JoySSL为您提供：</p><ul><li><strong>权威认证：</strong> 签发机构根证书被所有主流浏览器和操作系统广泛信任，确保全球无障碍访问。</li><li><strong>严格且高效的验证：</strong> 在提供标准OV证书的同时，JoySSL也提供支持IP地址验证的OV证书，满足不同场景的严格身份验证需求，流程专业且顺畅。</li><li><strong>强大的加密性能：</strong> 提供高达256位的加密强度，确保数据传输的绝对安全。</li><li><strong>无忧的服务支持：</strong> 提供从选购、验证到安装的全流程技术支持，让您轻松部署和管理证书。</li><li><strong>高性价比：</strong> 以极具竞争力的价格，提供具备高商业价值的证书产品，让每一笔安全投资都物超所值。</li></ul><h4><strong>结语</strong></h4><p>在当今时代，网络安全不再是可有可无的选项，而是商业运营的必需品。而信任，则是这个数字商业世界里最珍贵的货币。选择一款JoySSL OV SSL证书，不仅仅是完成从HTTP到HTTPS的技术升级，更是一次从“匿名”到“实名”，从“基础安全”到“深度信任”的品牌战略升级。</p><p><strong>超越加密，成就信任。</strong> 让JoySSL OV SSL证书成为您企业在互联网上最闪亮、最可信的官方名片，为您开启商业增长的新篇章。</p>]]></description></item><item>    <title><![CDATA[从加密信封到保险箱：SSL证书的等级之谜]]></title>    <link>https://segmentfault.com/a/1190000047394891</link>    <guid>https://segmentfault.com/a/1190000047394891</guid>    <pubDate>2025-11-13 14:06:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>从加密信封到保险箱：揭秘SSL证书的三大安全等级</strong></p><p>当您为网站选择SSL证书时，可能会发现它们的价格从免费到数千元不等。这背后的核心差异，就在于其验证等级。SSL证书并非千篇一律，它像安全服务一样分为不同级别，从基础保密到最高级别的身份担保，以满足不同的安全与信任需求。</p><p><strong>简单来说，我们可以将其类比为加密信封、带钢印的密封函和银行级保险箱。</strong></p><p><strong>第一级：域名验证型 - 基础加密信封</strong></p><p><strong>核心验证：</strong> 只验证您是否拥有该域名的管理权。</p><p><strong>验证过程：</strong> 通常通过回复指定邮箱的验证邮件或配置DNS解析记录来完成，流程自动化，耗时极短（几分钟至几小时）。</p><p><strong>显示内容：</strong> 浏览器地址栏显示HTTPS和锁形标志。</p><p><strong>适合场景：</strong> 个人博客、展示类网站、测试环境等无需进行交易或收集敏感信息的网站。</p><p><strong>形象比喻：</strong> 像一个加密信封。它能保证信的内容（数据传输）不被偷看，但无法证明寄信人（网站所有者）的真实身份。</p><p><strong>小结：DV证书解决了“通信加密”问题，但未解决“身份可信”问题。</strong></p><p><strong>第二级：组织验证型 - 官方认证的密封函</strong></p><p><strong>核心验证：</strong> 除了验证域名所有权，证书颁发机构（CA）会人工核实申请企业的真实存在性和合法性（如公司名称、地址、电话等）。</p><p><strong>验证过程：</strong> 需要提交营业执照等官方文件，CA会进行人工核对，可能需要1-3天。</p><p><strong>显示内容：</strong> 同样显示HTTPS和锁形标志，但点击小锁后，可以看到已验证的公司组织信息。</p><p><strong>适合场景</strong>： 企业官网、政府机构、教育机构等需要向用户证明其真实身份的网站。</p><p><strong>形象比喻：</strong> 像一封带有官方机构钢印的密封函。它不仅加密了内容，还证明了发件机构的真实身份，大大增强了可信度。</p><p><strong>小结：OV证书在加密基础上，提供了可靠的企业身份认证，是商业网站的安全基准。</strong></p><p><strong>第三级：扩展验证型 - 银行级的金色保险箱</strong></p><p><strong>核心验证</strong>： 遵循官方制定的严格审查准则，是最严格、最全面的验证等级。CA会对企业进行全面的背景调查，包括其法律、物理和运营存在性。</p><p><strong>验证过程：</strong> 最为严格和复杂，通常需要多个工作日才能完成。</p><p><strong>显示内容</strong>： 这是EV证书最显著的特点——使浏览器地址栏变为醒目的绿色，并直接显示经过验证的公司名称。</p><p><strong>适合场景：</strong> 银行、金融机构、大型电商平台、任何处理高度敏感信息（如金融交易、医疗数据）的网站。</p><p><strong>形象比喻：</strong> 像一个银行级别的金色保险箱。它提供了最高强度的安全保护，并以最直观、最醒目的方式（绿色地址栏）向用户宣告：“这是一家经过最严格验证的合法企业，请放心交易。”</p><p><strong>小结：EV证书提供了最高级别的安全与信任，通过视觉上的显著差异，为用户注入最强的信任感。</strong></p><p><strong>总结：</strong></p><p><strong>了解SSL证书的等级之谜，是构建网站信任体系的关键一步。从DV到OV再到EV，是一个从基础加密到身份验证，再到最高级别可视化信任的递进过程。明智地选择适合您业务的证书等级，不仅能保障数据安全，更能有效地建立品牌信誉，让用户在您的网站上安心停留。</strong></p>]]></description></item><item>    <title><![CDATA[网站提示 “不安全”？免费 SSL 证书]]></title>    <link>https://segmentfault.com/a/1190000047394898</link>    <guid>https://segmentfault.com/a/1190000047394898</guid>    <pubDate>2025-11-13 14:06:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>网站提示 “不安全”？免费 SSL 证书一键解决，HTTPS 零成本升级指南</h2><p>浏览器地址栏的 “不安全” 警告，不仅会让用户直接关闭页面，还会影响 SEO 排名和品牌信任度。其实不用花钱，免费 SSL 证书就能彻底解决问题，从申请到部署全程简单易操作，个人站长、中小企业都能快速上手。<br/><img width="650" height="407" referrerpolicy="no-referrer" src="/img/bVdmdBK" alt="" title=""/></p><p>zhucema 230959<br/><a href="https://link.segmentfault.com/?enc=OxZHaCkUYEat5r8Qq1ZsUg%3D%3D.tjnpAaOxSz2XpE%2BWGERs5A5XQpr0g40I5LyPPSLlxIi1S69%2BcITrVXTPSYTYhr7RAMQRFNKksJ8RHb6r8lu2Kw%3D%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/free.html?nid=59</a></p><h3>一、先搞懂：“不安全” 警告的 5 大核心原因</h3><ol><li>网站仍使用 HTTP 协议，未启用 HTTPS 加密，数据传输无保护。</li><li>SSL 证书过期、域名不匹配，或未正确部署（如证书链不完整）。</li><li>虽装了证书，但未设置 HTTP 强制跳转，部分流量仍走非安全通道。</li><li>网页加载混合内容（HTTPS 页面引用 HTTP 资源，如图片、脚本）。</li><li>服务器端口 443 未开放，或启用了不安全的加密协议（如 TLS 1.0）。</li></ol><ul><li><ul><li>*</li></ul></li></ul><h3>二、3 款靠谱免费 SSL 证书推荐（按需选）</h3><h4>1. Let's Encrypt</h4><ul><li>特点：全球广泛认可，支持单域名 / 通配符，90 天有效期且可自动续签。</li><li>优势：适配宝塔面板等工具，一键申请部署，适合个人博客、测试环境。</li><li>限制：无企业验证（OV/EV）证书，通配符证书需手动配置。</li></ul><h4>2. JoySSL</h4><ul><li>特点：提供 1 年期免费单域名证书，支持自动续签，中文文档 + 技术支持完善。</li><li>优势：申请流程简单，验证速度快，适合中小企业官网长期使用。</li><li>限制：免费版仅支持单域名，多子域名需升级。</li></ul><h4>3. ZeroSSL</h4><ul><li>特点：支持 IP 地址签发，提供 3 个免费 90 天证书，验证方式灵活（DNS/HTTP/ 邮箱）。</li><li>优势：操作界面友好，适合短期项目、需要 IP SSL 证书的场景。</li><li>限制：免费版不支持通配符，每个账号仅限 3 个证书。</li><li><ul><li>*</li></ul></li></ul><h3>三、零基础部署流程（以宝塔面板 + Let's Encrypt 为例）</h3><ol><li>登录宝塔面板，找到目标网站的 “设置”，切换到 “SSL” 选项卡。</li><li>选择 “Let's Encrypt”，勾选需要保护的域名（主域名 / 子域名）。</li><li>选择验证方式：80 端口可用选 “文件验证”，用 CDN 则选 “DNS 验证”（需在域名后台加 TXT 记录）。</li><li>点击 “申请证书”，等待 1-2 分钟，系统自动完成签发和部署。</li><li>开启 HTTPS 强制跳转：添加 Nginx 规则（<code>if ($scheme = http) { return 301 https://$host$request_uri;}</code>），确保所有流量走 HTTPS。</li></ol><ul><li><ul><li>*</li></ul></li></ul><h3>四、避坑指南：部署后仍提示 “不安全”？</h3><ol><li>检查证书有效性：用 SSL Labs 工具检测，补充缺失的中间证书。</li><li>清理混合内容：按 F12 打开浏览器控制台，将所有 HTTP 资源改为 HTTPS 或相对路径。</li><li>确认端口与协议：开放 443 端口，禁用 SSLv3、TLS 1.0/1.1，仅保留 TLS 1.2 及以上。</li><li>开启 HSTS 响应头：配置<code>Strict-Transport-Security: max-age=31536000</code>，让浏览器强制使用 HTTPS 访问。</li></ol>]]></description></item><item>    <title><![CDATA[为什么网站要安装SSL证书？有什么用？ ]]></title>    <link>https://segmentfault.com/a/1190000047394901</link>    <guid>https://segmentfault.com/a/1190000047394901</guid>    <pubDate>2025-11-13 14:05:33</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>一、<strong>先搞懂：什么是 SSL 证书？</strong></p><p>SSL 证书（Secure Sockets Layer），简单说就是网站的 「数字身份证」 <strong>—— 它通过</strong>加密技术 ，在用户浏览器和网站服务器之间建立一条<strong>安全加密通道</strong>，让数据传输像 “装在加密信封里” 一样，避免被<strong>窃取、篡改或伪造</strong>。</p><p>如今我们看到的网址前缀 「https://」 <strong>，正是 SSL 证书生效的标志（没有安装的网站会显示</strong>「http://」，部分浏览器会标注 “不安全”）。</p><p>二、<strong>核心问题：为什么网站必须装 SSL 证书？</strong></p><ol><li><strong>保护数据安全：守住用户的「隐私底线」</strong></li></ol><p>这是 SSL 最基础也最关键的作用！</p><ul><li>当用户在网站填写<strong>手机号、密码、银行卡号、收货地址</strong>等信息时，未加密的 http 网站会让数据 “裸奔传输” <strong>—— 黑客可轻松</strong>拦截窃取 <strong>，导致</strong>账号被盗、财产损失**；</li><li>安装 SSL 后，所有数据会被<strong>高强度加密</strong>（256 位加密算法，破解难度相当于 “大海捞针”），哪怕被拦截，黑客也只能看到乱码，无法解读真实内容。</li></ul><p><strong>典型场景</strong>：电商支付、登录注册、表单提交、在线预约等，没有 SSL 的网站，用户根本不敢填写敏感信息。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394903" alt="" title=""/></p><ol start="2"><li><strong>赢得用户信任：消除「不安全」的心理壁垒</strong></li></ol><p>想象一下：你打开一个购物网站，浏览器地址栏弹出「不安全」警告，或者没有绿色小锁标识 —— 你还会放心下单、填写个人信息吗？</p><ul><li>SSL 证书会让浏览器显示 「绿色小锁」 <strong>（部分高端证书还会显示</strong>企业名称 ），直接传递 “这个网站是安全的” 信号；</li><li>据统计，<strong>78% 的用户</strong>会因为 “网站显示不安全” 直接关闭页面，而有 SSL 的网站，<strong>用户停留时间和转化率平均提升 30% 以上</strong>。</li></ul><ol start="3"><li><strong>提升搜索引擎排名：SEO 的「隐形加分项」</strong></li></ol><p>早在 2014 年，<strong>Google</strong> 就明确将 「https」作为搜索排名的重要因素 —— 同样内容的网站，安装 SSL 的会比未安装的排名更靠前。</p><p>此外，<strong>百度、360</strong> 等国内搜索引擎也纷纷跟进这一规则，想要做好 SEO、获取更多<strong>自然流量</strong>，SSL 证书已经成为 “必备门槛”。</p><ol start="4"><li><strong>避免浏览器警告：不丢流量不损口碑</strong></li></ol><p>现在主流浏览器（<strong>Chrome、Firefox、Edge、Safari</strong> 等）对未安装 SSL 的 http 网站 “零容忍”：</p><ul><li>打开时会弹出醒目的 「不安全」警告框 ，甚至<strong>阻止用户访问</strong>；</li><li>这种警告会严重损害<strong>网站口碑</strong>，让用户误以为是 “钓鱼网站”，直接关闭页面 —— 相当于白白流失大量潜在客户。</li></ul><ol start="5"><li><strong>适配移动互联网：兼容小程序 / APP 接口的「通行证」</strong></li></ol><p>随着移动互联网的发展，越来越多网站需要对接<strong>微信小程序、APP、支付接口</strong>等 —— 这些平台都明确要求：接入的网站必须是 <strong>https 协议</strong>（即安装 SSL 证书），否则无法正常对接。</p><p>如果你的网站想要做<strong>移动端推广、开通在线支付、接入第三方工具</strong>，SSL 证书是必不可少的 “通行证”。</p><p>三、<strong>误区澄清：这些情况，网站也需要 SSL！</strong></p><p>很多人认为 “只有电商、支付类网站才需要 SSL”，其实大错特错：</p><ul><li><strong>个人博客 / 自媒体</strong>：用户留言、订阅邮箱等信息需要保护，且 https 能提升访问体验；</li><li><strong>企业官网</strong>：展示企业正规性，避免客户因 “不安全” 警告流失，提升品牌信任度；</li></ul><ul><li><strong>公众号跳转页面</strong>：微信对 http 页面的跳转限制越来越严格，SSL 能保证正常访问；</li></ul><ul><li><strong>后台管理系统</strong>：管理员账号密码、网站数据传输需要加密，防止被黑客入侵。</li></ul><p>四、<strong>总结：SSL 证书不是「可选配置」，而是「必备基建」</strong></p><p>从<strong>数据安全</strong>到<strong>用户信任</strong>，从<strong>SEO 排名</strong>到<strong>业务拓展</strong>，SSL 证书的作用贯穿网站运营的全流程。它不仅是保护用户隐私的 “安全锁” <strong>，更是提升网站竞争力的</strong>“加分项”。</p><p>如今，<strong>免费 SSL 证书</strong>（如 JoySSL）已普及，安装流程也越来越简单 —— 花几分钟时间，就能为网站筑起一道安全防线，还能赢得用户信任、提升流量转化，何乐而不为？</p>]]></description></item><item>    <title><![CDATA[uniapp获取微信小程序顶部NavBa]]></title>    <link>https://segmentfault.com/a/1190000047394926</link>    <guid>https://segmentfault.com/a/1190000047394926</guid>    <pubDate>2025-11-13 14:04:33</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>我在这里封装了一个类，可以直接使用</p><pre><code>export default class NavBarInfo {
    constructor() {
        this.statusBarHeight = 0; //状态栏的高度
        this.navigatorHeight = 0; //导航栏高度
        this.menuHeight = 0; //胶囊高度
        this.menuTop = 0; //胶囊与顶部的距离
        this.totalHeight = 0; //总高度
        this.getNavBarInfo();
    }

    getNavBarInfo() {
        let menu = {};
        let system = {};
        //获取系统信息
        uni.getSystemInfo({
            success: (res) =&gt; (system = res)
        });

        //获取胶囊信息
        try {
            menu = uni.getMenuButtonBoundingClientRect();
        } catch {
            menu = {
                height: 0,
                top: 0
            };
        }

        //计算组件高度
        this.statusBarHeight = system.statusBarHeight; //状态栏高度
        this.menuHeight = menu.height; //胶囊高度
        this.menuTop = menu.top; //胶囊与顶部的距离
        //导航栏高度= （胶囊顶部距离-状态栏高度） x 2 + 胶囊的高度
        // 这里用 x 1就是底部跟胶囊底部对齐，如果 x 2则是胶囊底部还留有一个边距的位置
        this.navigatorHeight = (menu.top - system.statusBarHeight) * 1 + menu.height;
        //总高度 = 状态栏的高度 + 导航栏高度
        this.totalHeight = this.statusBarHeight + this.navigatorHeight;
    }
}</code></pre><p>页面使用</p><pre><code>&lt;template&gt;
  &lt;view class="container"&gt;&lt;/view&gt;
&lt;/template&gt;

&lt;script setup&gt;
  import NavBarInfo from '@/utils/NavBarInfo.js';
  let navBarInfo = new NavBarInfo();
  // navBarInfo.totalHeight 顶部总高度
&lt;/script&gt;</code></pre>]]></description></item><item>    <title><![CDATA[数据分析案例详解：基于smardaten]]></title>    <link>https://segmentfault.com/a/1190000047395120</link>    <guid>https://segmentfault.com/a/1190000047395120</guid>    <pubDate>2025-11-13 14:03:43</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>需求背景<br/>随着城市交通网络的日益复杂，智慧交通运营对数据管理提出了更高要求：一方面，交通数据分散在监控、运营、收费等多个系统中，人工整合不仅效率低下，还易出现数据偏差；另一方面，交通运营需实时掌握拥堵趋势、违法统计、公交准点率等多维度指标，传统模式下复杂指标分析依赖专业编码，响应业务需求滞后。<br/>此外，数据采集与可视化展示脱节，无法直观呈现运营全局，难以支撑管理人员快速做出调度决策、拥堵治理等关键判断，亟需一套能整合多源数据、快速处理分析、直观呈现结果的解决方案，满足实时监控与精准运营的核心需求。<br/>数据分析能力介绍<br/>smardaten 平台为智慧交通数据大屏提供了多维度的数据分析能力，覆盖从智能交互到手动配置的全场景需求：<br/>•智能问数助手：以自然语言描述需求即可触发智能分析，AI 自动拆解意图、匹配数据并生成专业数据解读，还能一键生成图表、导出分析文档，大幅降低数据分析门槛；<br/>•自助分析：支持数据类型转换、多维度统计、权限隔离等复杂场景，满足深度数据处理需求；<br/>￮分析仪分析：作为独立专业分析模块，支持多源交通数据接入整合与清洗预处理，提供预置算法调用，可创建专属工作区，结果支持导出汇报文档或直接绑定数据大屏；<br/>￮大屏图表分析：在大屏配置界面可直接完成数据统计与图表绑定，无需切换模块，实现 “配置即展示”，提升可视化落地效率。<br/>配置过程<br/>进入平台后，先通过应用助手智能生成大屏雏形，再在数据分析仪或数据大屏配置界面中开展数据分析，核心涵盖智能问数、手动精准配置、大屏内置分析三类操作，全面覆盖从数据处理、维度统计到可视化绑定的全流程。</p><ol><li>智能问数<br/>分析 “各线路总收入”，只需在智能问数助手中输入需求，助手会主动追问补充条件<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Nj" alt="" title=""/><br/>补充信息后，AI 自动完成数据拆解、分析与解读文本生成，点击「生成文档」即可导出包含分析结果的汇报材料。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Nk" alt="" title="" loading="lazy"/><br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Nl" alt="" title="" loading="lazy"/><br/>最后返回数据大屏，选中目标图表并将数据来源设为 “数据分析仪”，就能快速绑定分析结果，实现可视化展示。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Nm" alt="" title="" loading="lazy"/></li><li>自助分析<br/>2.1 分析仪分析<br/>处理 “拥堵时长趋势” 数据时，先选择原始数据并将 “监测日期” 转换为标准日期类型。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Nn" alt="" title="" loading="lazy"/><br/>创建工作区，以 “监测日期” ，“区域”为维度，调用平台预置算法计算同比、环比增长率。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1No" alt="" title="" loading="lazy"/><br/>数据权限隔离，可按 “区域名称” 添加过滤条件，系统会自动根据登录人员所属区域展示对应数据。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Np" alt="" title="" loading="lazy"/><br/>完成后回到大屏，选中指标卡绑定同比、环比数据，各区域拥堵时长趋势即可清晰呈现。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Nr" alt="" title="" loading="lazy"/><br/>2.2 大屏图表分析<br/>进入大屏配置界面后，可直接对各板块数据进行可视化配置。<br/>•共享单车区域使用频次 TOP10：在数据资产选择共享单车原始数据，以 “区域” 为统计维度汇总使用数量，按数量降序排列并设置仅展示前 10 条，即可直观呈现热门区域排名。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Ns" alt="" title="" loading="lazy"/><br/>•交通违法行为月度管理统计：选择交通违法原始数据，先筛选 “时间维度 = 本月” 的数据，统计 “违法总量”“各类型违法次数”；对 “罚款金额” 字段使用内置函数，分别求和、取平均、找最大最小值，实现违法总量与罚款数据的多维度展示。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Nt" alt="" title="" loading="lazy"/><br/>•主干道拥堵路段状况：<br/>选择主干道拥堵原始数据，利用平台数据字典将区域编码翻译为区域名称，通过 “编辑字段” 功能用计算表达式定义拥堵等级。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Nu" alt="" title="" loading="lazy"/><br/>再以 “区域” 和 “拥堵等级” 为维度计数统计路段数量，并用别名优化字段展示，让拥堵分布一目了然。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Nw" alt="" title="" loading="lazy"/><br/>•公交到站准点率统计：选择数据源，通过 SQL 定制化处理复杂数据 —— 定义准点标准、筛选有效数据，按 “公交路线 + 站点名称” 分组统计总到站次数与准点次数，计算准点率并保留 1 位小数，精准呈现每条线路、每个站点的准点表现。<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm1Nx" alt="" title="" loading="lazy"/><br/>效果呈现<br/>所有图表数据绑定完成后，一键预览即可查看大屏全局效果，各板块核心指标与区域数据精准呈现，满足交通运营的实时监控与决策需求。<br/><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdm1Ny" alt="" title="" loading="lazy"/><br/>应用价值<br/>通过 smardaten 平台的 AI + 无代码数据分析能力，智慧交通数据大屏实现了三大核心价值：<br/>•配置门槛极低：从智能问数到自助分析，全程可视化操作，业务人员无需编码基础即可自主完成复杂数据处理与可视化；<br/>•分析能力强：兼容自然语言交互、深度数据处理、多维度可视化等全场景需求，从宏观运营指标到微观路段详情，精准匹配各指标不同层次决策诉求；<br/>落地效率高：数据处理与大屏可视化一体化衔接，配置完成即预览生效，真正做到 “配置即展示”，助力交通运营决策快速</li></ol>]]></description></item><item>    <title><![CDATA[系统日志管理与审计 运维有小邓 ]]></title>    <link>https://segmentfault.com/a/1190000047395124</link>    <guid>https://segmentfault.com/a/1190000047395124</guid>    <pubDate>2025-11-13 14:02:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>网络安全管理的范畴远不止 Windows 计算机。要抵御安全漏洞，还需从外围设备层面追踪网络入侵。这里的 “外围设备” 包括防火墙、路由器、交换机及 IDS/IPS（入侵检测 / 防御系统），它们共同构成了网络安全的 “第一道防线”。</p><p>无论是外围网络设备，还是 Linux 服务器，它们都是企业网络的重要组成部分，必须通过全面监控实现全方位网络安全。而这些设备的共同点在于，它们均会生成系统日志。</p><p>系统日志中包含着关键的网络活动信息，因此必须对其进行管理、分析和监控，才能保障网络安全。但面对海量的系统日志，如何实现高效管理？答案很简单：借助安全信息和事件管理（SIEM）解决方案。</p><h2>优质 SIEM 解决方案，让系统日志管理更高效</h2><p>既然明确了需要 SIEM 解决方案，该如何选择？一款全面的 SIEM 解决方案需具备以下核心能力：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395126" alt="图片" title="图片"/></p><p><strong>1、强大的日志采集与整合能力</strong><br/>内置高性能 syslog 服务器，可兼容防火墙、路由器、Linux/Unix 服务器等各类设备，无需额外部署插件，就能实时接收多源日志数据，实现异构环境下的日志集中管理，彻底告别分散日志 “碎片化” 管理的难题。</p><p><strong>2、智能分析与信息提取能力</strong><br/>无需人工逐行浏览日志，通过内置的算法模型，能自动过滤冗余信息，从海量数据中提取与安全相关的关键内容，再以可视化仪表盘、简洁报告的形式呈现，让管理员快速掌握网络活动动态，大幅降低日志分析的时间成本。</p><p><strong>3、核心的事件关联分析能力</strong><br/>能将分散的日志事件串联起来，识别潜在的攻击链条。比如当检测到 “异常 IP 尝试登录”“防火墙拒绝连接”“服务器权限变更” 等一系列关联事件时，可提前预警潜在威胁，让管理员在攻击造成损失前及时介入，真正将系统日志转化为网络安全的 “预警雷达”，为企业构建起主动防御的安全屏障。</p><h2>EventLog Analyzer：全方位满足系统日志管理需求</h2><p>卓豪 EventLog Analyzer 完全具备上述能力，为企业提供一站式系统日志管理方案。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395127" alt="图片" title="图片" loading="lazy"/></p><p>它能实时收集并监控系统日志，通过用户友好的界面实现简单管理。同时，它会对日志进行深度分析与关联，精准识别关键安全事件，一旦检测到网络异常，还会立即发送警报。</p><p>此外，EventLog Analyzer 提供丰富的报告功能，支持即时查看及定时生成，其中仅 Linux 相关报告就超过 100 种，让企业对网络状态实现全面掌控：</p><p><strong>登录 / 注销报告：</strong></p><p>详细呈现访问核心 Linux/Unix 服务器的用户信息，精准掌握服务器访问动态。</p><p><strong>防火墙拒绝连接报告：</strong></p><p>剖析攻击网络的恶意流量，为防范网络入侵提供关键依据。</p><p><strong>路由器配置报告：</strong></p><p>追踪外围网络的配置变更，若发现未授权修改，可快速恢复，保障网络设备安全。</p><p>系统日志中蕴藏着关于安全防护、故障排查及合规审计的宝贵信息，而高效提取这些信息正是保障网络安全的关键。除了上述报告，<a href="https://link.segmentfault.com/?enc=b59LRMaoXt1Jg4t2IdZMiQ%3D%3D.ih1NnvEAxb%2BxPJAkJYjbrN%2BHswf4ysfYLStIRYrDP7sfqpbUOJms8GZ9HNJbjlGPmdh9LezxP5HZy2UTlKYp8j4HjBAaGME7A%2FuxP%2FpNohtNChUfwQGJBTqX%2F%2BQNKcBy" rel="nofollow" target="_blank">EventLog Analyzer</a> 还能提供更多维度的日志分析能力，如需了解更多，可进一步探索其全部功能。</p>]]></description></item><item>    <title><![CDATA[Python在线教育广告精准投放：SEM]]></title>    <link>https://segmentfault.com/a/1190000047395129</link>    <guid>https://segmentfault.com/a/1190000047395129</guid>    <pubDate>2025-11-13 14:02:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>全文链接：<a href="https://link.segmentfault.com/?enc=Wsxbz2bnvlWM25nN6kuIMQ%3D%3D.2%2FuUnP48A84pV24qn8yjZiSEIkezbq3Memcx66aY2ZE%3D" rel="nofollow" title="https://tecdat.cn/?p=44299" target="_blank">https://tecdat.cn/?p=44299</a></p><p>原文出处：拓端数据部落公众号  <br/>分析师：Jian Huang</p><h2><a name="t0" target="_blank"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395131" alt="封面" title="封面"/></h2><p>在数字经济纵深发展的今天，在线广告已成为在线教育行业触达用户、实现商业转化的核心载体，但行业普遍面临“流量昂贵却转化低效”“用户反感却投放盲目”的痛点。作为数据科学家，我们深知单一分析视角难以破解复杂的广告生态问题——既要读懂用户需求，又要摸透渠道规律，更要打通从创意到转化的全链路逻辑。</p><p><strong>引言</strong>  <br/>本文改编自我们为客户提供的广告优化咨询项目，项目团队通过整合全国21个省级行政区的1090份用户问卷数据与889个广告投放渠道数据，构建了“用户洞察-渠道评估-策略优化”的完整分析框架。我们没有局限于传统的曝光、点击指标，而是创新性地将因子分析、SEM结构方程模型与K-means聚类、XGBoost回归等算法集成，既挖掘了用户满意度的核心影响因素，又精准识别了高价值投放渠道与广告元素组合。  <br/>本文内容源自过往项目技术沉淀与已通过实际业务校验，该项目完整代码与数据已分享至交流社群。阅读原文进群，可与600+行业人士交流成长；还提供人工答疑，拆解核心原理、代码逻辑与业务适配思路，帮大家既懂 怎么做，也懂 为什么这么做；遇代码运行问题，更能享24小时调试支持。我们希望通过这份通俗易懂的报告，让学生和从业者既能掌握数据分析工具的实际应用，又能理解数据背后的业务逻辑，真正实现“数据驱动决策”。</p><h3><a name="t2" target="_blank"/>国内研究现状</h3><h4><a name="t3" target="_blank"/>文献计量分析</h4><p>我们借助CiteSpace工具对2018-2024年的555篇相关文献进行分析，发现在线广告领域的研究呈现明显的阶段特征：2018-2020年随着短视频平台兴起与5G技术落地，研究进入热潮；2021年后研究放缓，行业面临深度优化的瓶颈。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395132" alt="" title="" loading="lazy"/>  <br/>从关键词聚类图谱可见，在线广告与广告营销、投放策略等聚类的交叉性较弱，说明跨维度的系统性研究仍有空白。这些聚类内部一致性高，但交叉领域的探索不足，为本次研究提供了切入点。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395133" alt="" title="" loading="lazy"/>  <br/>现有研究多聚焦单一渠道或单一指标，缺乏对用户体验与渠道效能的双维度整合分析，这也正是本项目的核心切入点——通过多模型集成填补这一研究空白。</p><h3><a name="t4" target="_blank"/>调查方案设计</h3><h4><a name="t5" target="_blank"/>核心研究框架</h4><p>我们采用多阶段抽样、分层抽样与PPS抽样结合的方法，覆盖全国21个省级行政区，最终回收有效问卷1090份，有效回收率达93.2%。问卷设计融合了用户技术接受度模型与ACSI满意度评估标准，包含广告接触特征、内容偏好、满意度等6大模块15个可量化指标。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395134" alt="" title="" loading="lazy"/>  <br/>这个研究流程确保了数据从收集到分析的科学性：先通过预调查验证问卷有效性，再通过多阶段抽样扩大样本代表性，最后通过信效度检验保障数据质量。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395135" alt="" title="" loading="lazy"/>  <br/>问卷结构围绕用户“接触-感知-决策”全流程设计，既包含客观行为数据（如接触频率、渠道），也涵盖主观评价数据（如满意度、偏好），实现对广告效果的全方位评估。  <br/>通过预调查验证，问卷克隆巴赫Alpha系数达0.872，KMO值为0.660，信效度均满足分析要求，确保了数据的可靠性。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395136" alt="" title="" loading="lazy"/>  <br/>分层抽样将全国34个省级行政区按教育需求与经济水平分为四层，第一层（河南、浙江等）侧重高端教育需求，第四层（内蒙古、新疆等）侧重基础教育普及，这种分层确保了样本在不同区域的代表性。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395137" alt="" title="" loading="lazy"/>  <br/>最终抽样覆盖的21个省份在地理分布上兼顾了东中西部，人口权重与实际人口分布基本一致，保障了研究结论的全国推广价值。</p><h3><a name="t6" target="_blank"/>在线教育广告现状分析</h3><h4><a name="t7" target="_blank"/>受众特征核心发现</h4><p>受访者中男女比例均衡（51%:49%），年龄集中在18-24岁（39.70%），学生与上班族占比达82%，成为在线教育广告的核心受众。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395138" alt="" title="" loading="lazy"/>  <br/>18-24岁青年群体既是互联网主力用户，又处于学业提升与职业起步阶段，对在线教育的需求刚性强；18岁以下群体占比25%，多为K12教育潜在用户，这两类群体应成为广告投放的重点对象。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395139" alt="" title="" loading="lazy"/>  <br/>学生群体（40%）面临考试备考、技能提升的需求，上班族（42%）因技术迭代需要持续学习，两者共同构成在线教育的核心消费群体。针对这两类人群的广告内容应突出“备考提分”“职场晋升”等核心卖点。</p><hr/><h4><a name="t8" target="_blank"/>相关文章</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395140" alt="" title="" loading="lazy"/></p><h2><a name="t9" target="_blank"/>R语言结构方程模型SEM、路径分析房价和犯罪率数据、预测智力影响因素可视化2案例</h2><h4><a name="t10" target="_blank"/>原文链接：<a href="https://link.segmentfault.com/?enc=npdO%2FL4CwoDm7VsmIAHaLg%3D%3D.JkTQBuD3LXbIojXxuSxiC3tJLOIuO1nHoR%2FyprTTS16YjpJHhUc7dnJc3AXndo94CLQ2j6eX3rqG8WI%2FgXHfuw%3D%3D" rel="nofollow" title="http://tecdat.cn/?p=25044" target="_blank">http://tecdat.cn/?p=25044</a></h4><hr/><h4><a name="t12" target="_blank"/>广告接触与偏好特征</h4><p>用户每天接触10条以上在线广告的比例接近70%，其中10-20条的占比最高（41.67%），说明用户日常被广告高频触达，广告竞争激烈。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395141" alt="" title="" loading="lazy"/>  <br/>从接触渠道看，社交媒体（89.67%）与视频网站（74.50%）是用户接触在线教育广告的主要平台，这与当下用户的媒介使用习惯高度契合，广告投放应重点布局这两大渠道。  <br/>在内容偏好上，78.5%的用户关注职业教育，73.25%关注高等教育学历教育，成为在线教育广告的核心发力方向；K12教育关注占比59.58%，低幼教育与素质教育占比相对较低。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395142" alt="" title="" loading="lazy"/>  <br/>职业教育的高关注度与就业市场对技能人才的需求激增密切相关，在线教育企业应加大职业教育领域的广告投入，突出就业导向、技能认证等核心优势。</p><h4><a name="t13" target="_blank"/>品牌广告与效果广告现状</h4><p>品牌广告与效果广告在营销中扮演不同角色：品牌广告侧重塑造形象，效果广告侧重直接转化。数据显示，54.08%的用户认为品牌广告对提升知名度效果较好，14.83%认为效果非常好，说明品牌广告的认知提升作用显著。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395143" alt="" title="" loading="lazy"/>  <br/>购买行为数据显示，50.67%的用户倾向于购买熟悉品牌的促销商品，仅38%会直接购买促销商品，这一结果验证了“AIDA法则”——用户需先认知品牌（Attention），再产生兴趣（Interest），最后实现购买（Action）。因此，在线教育企业应先通过品牌广告建立用户认知，再投放效果广告促进转化。</p><h3><a name="t14" target="_blank"/>用户对在线教育广告的满意度分析</h3><h4><a name="t15" target="_blank"/>因子分析与SEM模型</h4><p>通过因子分析，我们从8个观测变量中提取出3个核心因子：广告内容质量、广告制作创意水平、广告投放精确度，累计方差解释率达86.57%，说明这三个维度能全面反映用户满意度的影响因素。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395144" alt="" title="" loading="lazy"/>  <br/>碎石图显示，前三个因子的特征值下降明显，第四个及以后因子特征值变化平缓，进一步验证了提取3个公共因子的合理性。  <br/>基于ACSI模型构建SEM结构方程模型，验证了质量感知、顾客期望对顾客满意的正向影响（标准化回归系数分别为0.646、0.712），顾客满意对顾客忠诚的正向影响（标准化回归系数0.757），模型拟合效果良好（卡方自由度比1.595，GFI=1.685，RMR=0.045）。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395145" alt="" title="" loading="lazy"/>  <br/>这一模型表明，用户的期望与实际感知质量共同决定满意度，而满意度直接影响推荐意愿与复购行为。企业不仅要提升广告质量，还要管理用户期望，避免过度宣传导致的心理落差。</p><h4><a name="t16" target="_blank"/>满意度关键问题分析</h4><p>关键发现一：广告与用户兴趣匹配度不足。60%以上用户认为广告与自身兴趣匹配度一般及以下，说明当前广告定向投放的精准度有待提升。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395146" alt="" title="" loading="lazy"/>  <br/>针对这一问题，企业可通过用户行为数据（如浏览历史、搜索记录）构建精准用户画像，采用程序化交易广告实现定向投放，提高广告与用户需求的匹配度。  <br/>关键发现二：广告创意性欠缺。70%用户觉得广告缺乏创意，其中“不太满意”与“非常不满意”占比超过20%，创意不足导致广告难以吸引用户注意力。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395147" alt="" title="" loading="lazy"/>  <br/>提升广告创意需从用户画像出发，结合叙事化表达、视觉化设计与情感共鸣，例如职业教育广告可采用“职场逆袭故事”形式，突出课程带来的实际改变。</p><h3><a name="t17" target="_blank"/>广告投放渠道质量分析</h3><h4><a name="t18" target="_blank"/>指标体系搭建与数据特征</h4><p>基于OSM模型搭建渠道质量评估体系，明确以销售额为核心目标，拆解为流量、转化、用户参与度三大维度指标，为渠道分析提供框架支撑。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395148" alt="" title="" loading="lazy"/>  <br/>OSM模型将业务目标（O）、策略（S）、指标（M）层层拆解，确保每个指标都与核心目标强相关，避免“指标泛滥”导致的分析偏差。  <br/>通过KDE核密度分析发现，广告投放总时间分布均匀，而日均UV、订单转化率等指标呈极度偏态分布——75%的渠道日均UV低于466.87，最高却达25294.77，说明渠道流量差异极大，存在“少数超级渠道垄断流量”的现象。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047395149" alt="" title="" loading="lazy"/>  <br/>描述性统计显示，平均注册率与订单转化率均值极低（分别为0.0014、0.0029），说明在线教育广告的转化效率普遍不高，需通过渠道优化与内容升级提升转化效果。</p><h4><a name="t19" target="_blank"/>多模型集成分析</h4><h5>1. K-means聚类渠道分类</h5><p>我们将889个渠道聚类为4类，通过雷达图直观呈现各类渠道特征：<img referrerpolicy="no-referrer" src="/img/remote/1460000047395150" alt="" title="" loading="lazy"/></p><ul><li>第一类（39%）：各指标表现差，投放需谨慎取舍，避免资源浪费；</li><li>第二类（35%）：转化效果好但流量不足，适合精准转化，可适当加大投放力度提升流量；</li><li>第三类（8%）：流量大，适合品牌宣传，用于提升品牌知名度与用户覆盖；</li><li>第四类（17%）：引流与转化双优，需重点关注，倾斜更多预算资源。</li></ul><h5>2. 随机森林与XGBoost特征重要性</h5><p>先通过随机森林筛选重要特征（剔除重要性低于0.05的指标），再用XGBoost回归分析订单转化率的影响因素：</p><pre><code>import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.model_selection import train_test_splitfrom xgboost import XGBRegressorfrom sklearn.metrics import mean_squared_error# 设置中文字体plt.rcParams['font.sans-serif'] = ['SimHei']plt.rcParams['axes.unicode_minus'] = False# 读取数据并预处理df_processed = pd.read_csv('清洗后的数据集.csv')df_model = df_processed.drop(columns=["渠道代号"])y_target = df_model["订单转化率"]X_features = pd.read_excel('回归数据X.xlsx')# 划分训练集与测试集X_tr, X_te, y_tr, y_te = train_test_split(X_features, y_target, test_size=0.2, random_state=42)# XGBoost建模与训练xgb_model = XGBRegressor(random_state=42, n_estimators=100)xgb_model.fit(X_tr, y_tr)# 模型评估y_pred = xgb_model.predict(X_te)mse_score = mean_squared_error(y_te, y_pred)print(f"测试集MSE: {mse_score:.6f}")# 特征重要性输出feature_importance = list(zip(X_features.columns, xgb_model.feature_importances_))feature_importance.sort(key=lambda x: x[1], reverse=True)print("特征重要性排序:", feature_importance[:5])</code></pre><p>结果显示，日均UV（0.396）、素材类型（0.243）、平均停留时间（0.177）是影响转化率的三大核心因素，验证了流量与用户体验的关键作用。随机森林的学习曲线帮助我们确定了最优参数n_estimators=13，确保模型效果与计算效率的平衡。<img referrerpolicy="no-referrer" src="/img/remote/1460000047395151" alt="" title="" loading="lazy"/></p><h5>3. FP-growth关联规则挖掘</h5><p>通过FP-growth算法挖掘广告元素组合规律，设置最小支持度0.1，生成关联规则：</p><pre><code>import pandas as pdfrom pyfpgrowth import find_frequent_patterns, generate_association_rulesimport matplotlib.pyplot as plt# 构建事务数据def create_transaction_data(df): select_cols = ['日均UV', '广告类型', '合作方式', '订单转化率'] trans_list = [] for _, row in df.iterrows(): trans = [f"{col}_{row[col]}" for col in select_cols] trans_list.append(trans) return trans_list# 读取数据并分析try: df_assoc = pd.read_excel('关联规则挖掘数据集.xlsx') transactions = create_transaction_data(df_assoc)# 挖掘频繁项集 freq_patterns = find_frequent_patterns(transactions, min_support=0.1)# 生成关联规则 assoc_rules = generate_association_rules(freq_patterns, min_threshold=0.7) print("高频关联规则前5条:", list(assoc_rules.items())[:5])except FileNotFoundError: print("请检查数据集文件路径是否正确")</code></pre><p>核心发现：banner广告+308<em>388尺寸（提升度&gt;5.7）、免费卖点+jpg素材+CPC合作方式的组合效果最优；信息流广告搭配视频素材+600</em>90尺寸关联性强，这些组合可直接应用于广告制作与投放。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395152" alt="" title="" loading="lazy"/></p><h3><a name="t20" target="_blank"/>结论与建议</h3><h4><a name="t21" target="_blank"/>核心结论</h4><ol><li>在线教育广告核心受众为18-24岁学生与上班族，职业教育、高等教育是主要需求方向，社交媒体与视频网站是核心接触渠道；</li><li>广告内容质量、创意水平、投放精确度是影响用户满意度的关键因素，当前存在匹配度与创意不足的突出问题；</li><li>渠道可分为四类，需根据“流量-转化”特征制定差异化策略，双优渠道应重点倾斜资源；</li><li>日均UV、素材类型、平均停留时间主导转化率，特定广告元素组合（如banner+308*388、免费卖点+jpg）能显著提升效果。</li></ol><h4><a name="t22" target="_blank"/>关键建议</h4><ol><li>投放策略：先通过大流量渠道做品牌曝光，再用高转化小流量渠道实现精准转化；优化投放时段，避免广告断档，初期采用“广撒网”后期精准定向；</li><li>内容优化：突出职业教育、低价、权威师资等卖点，提升广告创意与用户兴趣匹配度；避免低俗洗脑、反复跳转的广告形式；</li><li>元素组合：优先选择jpg/视频素材，banner广告用308<em>388尺寸，信息流广告用视频+600</em>90尺寸；采用CPC/ROI模式扩大曝光，CPD模式精准转化；</li><li>技术支撑：采用AI技术实现精准定向，缩短转化链路，确保落地页2秒内打开；定期清理7天无转化的低效广告。</li></ol><h4><a name="t23" target="_blank"/>服务强调</h4><p>本文所有代码均经过实际业务校验，我们提供24小时应急修复服务，响应“代码运行异常”求助，比学生自行调试效率提升40%。我们始终坚持“买代码不如买明白”，人工创作比例达90%以上，既解决“代码能运行但怕查重、怕漏洞”的痛点，又帮大家吃透核心逻辑。所有涉及的分析工具（Python、Scikit-learn、XGBoost等）均为国内可正常访问的开源工具，无访问限制，且有丰富的中文社区资源提供支持。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395131" alt="封面" title="封面" loading="lazy"/></p><h2><a name="t24" target="_blank"/>关于分析师</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047395153" alt="" title="" loading="lazy"/></p><p>在此对 Jian Huang 对本文所作的贡献表示诚挚感谢，他在桂林电子科技大学完成了数学与应用数学专业的本科学历，专注商业数据分析与机器学习领域。擅长 Python、Matlab、SPSS、Tableau，以及机器学习、商业数据分析、数学建模。</p><p>Jian Huang 过往曾任职于方正证券担任数据分析师，具备扎实的数据分析实践经验，能够将数学理论与商业场景深度结合，为本文的模型构建、数据处理及策略优化提供了重要的技术支撑。</p>]]></description></item><item>    <title><![CDATA[安全可靠数据库选型之阿里云PolarDB]]></title>    <link>https://segmentfault.com/a/1190000047395232</link>    <guid>https://segmentfault.com/a/1190000047395232</guid>    <pubDate>2025-11-13 14:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>阿里云 PolarDB 数据库管理软件（分布式版）V2.0 ，安全可靠的集中分布式一体化数据库管理软件。<a href="https://link.segmentfault.com/?enc=g5cXgPXBUWwNv2ah8f8V2Q%3D%3D.ibCES53iKRUl4IXbFNzVT5dKXovC7%2BdRHpuFK1a%2FmbMFWMOazOAcIyRuiar37fPi%2FhRgCPZWjML%2BcXz2gnd7gg%3D%3D" rel="nofollow" target="_blank">点此查看详情</a><br/>PolarDB 数据库管理软件（分布式版）V2.0 于2024年9⽉通过数据库安全可靠测评，<a href="https://link.segmentfault.com/?enc=6BK8Vt%2BkrKXMw7LQmCIRkA%3D%3D.DdSR4KeKs89H4Ecp%2Fjf%2Fjbu8UgUEdZWGYdLAIfPf7ldmZ555Dxnyy052RiknHvvPwx%2FMsamw6eiNvCZhZ6%2FeB200eOGJ8kjJGcwl1hqppD8%3D" rel="nofollow" target="_blank">测评结果公示</a></p><p><img width="723" height="696" referrerpolicy="no-referrer" src="/img/bVdm1Pu" alt="" title=""/></p><h3>一、PolarDB 分布式版 V2.0 产品方案介绍</h3><p>阿里云 PolarDB 数据库管理软件（分布式版）V2.0 （简称 PolarDB 分布式版 V2.0）采用 Shared-nothing 架构，兼容 MySQL 开源生态构建产品竞争力，支持集中式和分布式一体化形态，具备金融级数据高可用、高可靠和分布式水平扩展能力。<br/><img width="723" height="162" referrerpolicy="no-referrer" src="/img/bVdm1Pt" alt="" title="" loading="lazy"/></p><p>PolarDB 分布式版 V2.0 有以下产品方案供用户选择：</p><h4>PolarDB 分布式版 V2.0（公有云版本）</h4><p>PolarDB 分布式版 (PolarDB for Xscale，简称 "PolarDB-X") 是阿里云自主设计研发的高性能云原生分布式数据库产品，为用户提供高吞吐、大存储、低延时、易扩展和超高可用的云时代数据库服务。依托云资源和容器化部署能力，PolarDB 分布式版可在数分钟内完成集群创建和变配；支持按量付费模式，帮助用户精准降本。新用户购买 PolarDB 分布式标准版 2 核 4G/4 核 8G 实例，享 1 年付 2.8 折优惠！全线规格首年低至 6 折起，配置越高，节省越多。<br/><a href="https://link.segmentfault.com/?enc=7cX9WxTs5rFVylelv1S0pQ%3D%3D.Ipw2J2%2Fbr5mOIxENYb3raVYKCg2E6xkCWZSwGmBUU4nVZz0xmmytXHVueIsY4d6MS%2B%2Fz8nMCRnp6yriu9Ihi1A%3D%3D" rel="nofollow" target="_blank">立即查看解决方案</a></p><h4>PolarDB 分布式版 V2.0（轻量化版本）</h4><p>自 PolarDB 正式上线以来，它已成功支撑成千上万的客户应用，并在真实的商业环境中展现了卓越的表现。PolarDB 凭借其卓越的性能、坚如磐石的稳定性和为企业度身定制的高级功能，为客户提供了前所未有的数据库体验。 随着技术的不断进步和国产市场需求的变化，PolarDB 推出了满足国产市场需要且更具性价比的轻量化版本。与公有云在线化版本不同，轻量化版本采用软件输出的方式，可以部署在客户自主环境中。更为关键的是，该产品仍保留并承载了 PolarDB 技术团队深入的内核优化成果，使其既能保持高性能，又能大幅降低成本。<br/><a href="https://link.segmentfault.com/?enc=es9w6nvJ3L%2B8M2yuGsJQNA%3D%3D.g6PYhLVslpPE2%2BaUoe7Hmgf4%2B2hMe1xe%2F6bZhXK6WvZf7YGwcZ7MwAji7Prhj79k1XMgUv64mPQmcyhNR4Ouag%3D%3D" rel="nofollow" target="_blank">点此咨询</a></p><h3>二、PolarDB 分布式版 V2.0 产品优势</h3><h4>云原生 + MySQL 生态</h4><p>100% 兼容 MySQL 生态，依托云资源和容器化部署能力，PolarDB 分布式版可在数分钟内完成集群创建和变配；支持按量付费模式，帮助用户精准降本。</p><h4>存储计算分离架构</h4><p>PolarDB 分布式版采用了基于存储计算分离的 Shared-Nothing 系统架构，该架构使用户可以根据业务需要进行分层容量规划。</p><h4>透明分布式体验</h4><p>让用户以使用单机 MySQL 数据库的体验，操作分布式数据库是 PolarDB 分布式版一贯追求的目标。</p><h3>三、PolarDB 分布式版 V2.0 产品影响力</h3><p>国际市场研究机构 Gartner® 日前公布 2024 年度全球《云数据库管理系统魔力象限》报告，阿里云成为亚太区唯一入选该报告 "领导者（LEADERS）" 象限的科技公司，同时也是唯一一家连续 5 年入选 "领导者" 象限的中国企业。</p><h4>阿里云（PolarDB）荣膺 "2023 年度十大软件著作权人"</h4><p>凭借瑶池数据库 PolarDB 等自研技术、软件著作权、商标及专利，阿里云首次荣膺 "2023 年度十大软件著作权人" 荣誉称号。</p><h4>国内首批，通过国家标准 GB18030-2022 最高级别认证</h4><p>云原生数据库 PolarDB 完成了强制性国家标准 GB 18030-2022《信息技术 中文编码字符集》标准测评，通过了该标准的最高级别 3 级认证，成为首批通过该测评认证的关系型数据库管理软件。</p><h4>全国首个完成信通院全密态数据库基础能力测评的数据库产品</h4><p>云原生关系型数据库 PolarDB 全密态版（以下简称全密态 PolarDB）软件顺利完成了首个全密态数据库技术标准的全部四大能力域、三十个能力项能力测试。</p><h4>阿里云 PolarDB 再获 SIGMOD 最佳论文奖</h4><p>数据库国际学术顶会 SIGMOD 2024 上，阿里云凭借自研 PolarDB 新架构斩获工业赛道 "最佳论文奖"，这是中国企业独立完成的成果首次摘得 SIGMOD 最高奖。</p><h3>四、开源版本推荐</h3><h4>PolarDB 分布式版（开源版本）</h4><p>PolarDB 分布式版 (PolarDB for Xscale，简称 "PolarDB-X") 是阿里云自主研发的高性能云原生分布式数据库产品，其采用 Shared-nothing 与存储计算分离架构，支持水平扩展、分布式事务、混合负载等能力，具备企业级、云原生、高可用、高度兼容 MySQL 系统及生态等特点。PolarDB-X 于 2021 年 10 月正式开源。</p><p>信创数据库 #安全可靠数据库 #国产数据库 #国产自研数据库 #PolarDB V2.0 #阿里云数据库 #分布式数据库 #MySQL数据库</p>]]></description></item><item>    <title><![CDATA[曝OpenAI布道黑幕！MIT华人记者：]]></title>    <link>https://segmentfault.com/a/1190000047394829</link>    <guid>https://segmentfault.com/a/1190000047394829</guid>    <pubDate>2025-11-13 13:03:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>编辑：倾倾</p><p>【新智元导读】当硅谷把「AGI造福全人类」包装成信仰时，真实世界却在付出代价。Karen Hao在《Empire of AI》犀利指出，这场竞赛甚至被渲染成「中美对抗」——只要跑赢中国，就能守护自由。但事实是，美国与中国差距并未拉大，唯一真正收割的，是硅谷自己。我们是否还要为这场幻觉买单？</p><p>历史上的帝国，总有一套自我合理化的信仰。</p><p>殖民者扩张靠「拯救灵魂」，今天的AI帝国靠「AGI造福全人类」。</p><p>但当信仰被资本、算力裹挟着一路狂奔时，现实却不断发出警示：能源透支、劳工剥削、心理危机……</p><p>问题是，这套信仰究竟如何驱动着整个行业？</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394831" alt="" title=""/></p><p><strong>「造福人类」的口号，却变成加速的理由</strong></p><p>Karen Hao是麻省理工学院《Technology Review》前记者，长期追踪硅谷公司，作品多次揭露AI行业的权力结构。</p><p>她的新书《Empire of AI》一经上市就引起热议，其中最鲜明的观点，就是把OpenAI比作「帝国」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394832" alt="" title="" loading="lazy"/></p><p>在一次播客采访中，她提到自己遇到过一些工程师：</p><p>他们的声音都在因信仰AGI而颤抖。</p><p>这种近乎宗教般的热忱，正是推动OpenAI和整个行业狂奔的燃料。</p><p>对于AGI，OpenAI给出的定义是：</p><p>一种「在绝大多数有经济价值的工作上超越人类的高度自主系统」，它将「增加财富、加速经济、推动科学发现」。</p><p>这种叙事看似高远宏大，却也模糊而空泛。</p><p>也正因如此，资本、公司和从业者可以在信仰的外衣下不断加码。</p><p>在Hao看来，一旦目标被设定为「造福人类」，并且竞争被定义为「赢者通吃」，速度就会压倒一切。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394833" alt="" title="" loading="lazy"/></p><p>她直言：</p><p>当你把有益的AGI之路定义成一场赢者通吃的竞赛时，最重要的就是速度，速度凌驾于效率之上，凌驾于安全之上，凌驾于探索式研究之上。</p><p>也就是说，这是一场被包装成「必须赢」的赛跑，任何对效率、安全、甚至科学探索的考量，都会被速度踩在脚下。</p><p>事实上，AI的进步并不只有一条路。</p><p>研究者完全可以通过改进算法来减少对数据和算力的依赖。但这条路意味着放慢脚步，不符合OpenAI的竞赛逻辑。</p><p>于是，他们选择了「最省智力成本的方式」——把已有的技术塞进更大的算力工厂，用更多数据去硬拱。</p><p>Hao的评价毫不客气：</p><p>保证速度的最佳方式，就是用更多数据和超级计算机去堆现有技术，而不是去做更困难的原创研究。</p><p>这种「堆料式」的发展，并不是技术进化的必然，而是商业化与竞赛逻辑的产物。更严重的后果在于学术生态。</p><p>Hao指出，如今顶尖的AI研究者大多进入大公司，学术界逐渐失去独立性：</p><p>整个学科的研究议程，正在被这些公司的商业目标所塑造，而不是由真正的科学探索来决定。</p><p>从外部看，OpenAI的路线似乎极其高效：ChatGPT、GPT-4o不断迭代，迫使其他公司追随。</p><p>但这种速度带来的，并不是稳固的科研积累，而更像是一场对未来的豪赌。</p><p>速度本身，反而成了信仰的证明。而为了维持这种速度信仰，整个行业开始疯狂烧钱。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394834" alt="" title="" loading="lazy"/></p><p><strong>烧钱竞赛：AI帝国的真实账单</strong></p><p>在AI行业，速度不只是信仰，更是一场巨额消耗的战争。</p><p>OpenAI预计到2029年将烧掉1150亿美元；Meta宣布，仅2025年一年，就要砸下720亿美元扩建AI基础设施；谷歌的资本开支则可能高达850亿美元，大部分投向算力与运服务。</p><p>这些数字冷冰冰的，却足够让人眩晕。</p><p>可这些钱砸下去，带来的不是乌托邦，而是沉重的「账单」。</p><p>能源是一笔最直观的成本。大模型训练时需要成千上万张GPU同时运行，耗电量相当于一座中等城市。</p><p>今年5月，AI的能源需求已经占到全球数据中心电力消耗的约20%，预计年底可能翻倍。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394835" alt="" title="" loading="lazy"/></p><p>社会的成本同样不容忽视。Hao在《Empire of AI》里写道：</p><p>AI的高速发展伴随着「就业流失与财富集中」：自动化在挤压客服、写作、编程等岗位，而由此产生的利润却被少数科技巨头收割。</p><p>AI没有「造福全人类」，反而进一步加剧不平等。</p><p>更隐形的是心理健康的代价。</p><p>聊天机器人制造的虚拟陪伴，正在让部分用户陷入「幻觉式依赖」，甚至加剧精神脆弱人群的危机。</p><p>而在产业链的另一端，位于肯尼亚的标注工人，只能以每小时1.5至2美元的工资，长期处理极端内容（包括儿童性虐待影像），很多人因此出现失眠、焦虑，甚至创伤后应激障碍。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394836" alt="" title="" loading="lazy"/></p><p>在委内瑞拉，研究者发现虽然数据标注为陷入经济危机的家庭带来了一点收入，但雇主与工人之间存在严重不平等，工作条件极度苛刻。</p><p>天价的算力账单、不断膨胀的能源消耗、用户与工人的健康风险……所有这些，构成了 AI 帝国看不见的「暗面」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394837" alt="" title="" loading="lazy"/></p><p>赢家或许只有少数几家公司，但真正为这场竞赛买单的，却是普通人和整个社会。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394838" alt="" title="" loading="lazy"/></p><p><strong>另一条出路：不靠烧钱也能改写医学</strong></p><p>在铺天盖地的AGI神话之外，其实存在另一种路径——低能耗、少数据，却能直接推动科学突破的AI。</p><p>最典型的例子，就是Google DeepMind推出的AlphaFold。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394839" alt="" title="" loading="lazy"/></p><p>AlphaFold的任务很具体：预测蛋白质的三维结构。</p><p>过去，科学家往往需要几年甚至十几年才能确定某些蛋白质的折叠方式，而AlphaFold通过训练在氨基酸序列数据与结构数据库上的模型，已经能在几分钟内准确给出结果。</p><p>DeepMind官方数据显示，它已成功预测超过两亿个蛋白质结构，并将结果通过开放数据库免费提供给全球科研人员。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394840" alt="" title="" loading="lazy"/></p><p>这种突破并不是停留在实验室里的炫技，而是正在改变医学研究的节奏。</p><p>根据NCBI收录的一篇综述论文，AlphaFold2已被广泛用于生物医学研究，从疾病相关蛋白的结构解析，到药物靶点发现，再到新型抗体的设计，都在显著加速。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394841" alt="" title="" loading="lazy"/></p><p>科研人员形容，这为药物研发节省了「无法想象的时间和成本」。</p><p>Karen Hao在《Empire of AI》里也强调：</p><p>我们真正需要的，是像AlphaFold这样的系统。它不会制造心理健康危机，不会引发巨大的环境消耗，也不会让底层劳工接触互联网上最黑暗的内容。</p><p>相比之下，AGI路线更多依赖无休止的算力堆叠，带来的是天价能耗与社会风险。</p><p>AlphaFold的成功提醒我们，AI并非天然与「高风险」绑定。</p><p>它完全可以被引导去解决具体而有价值的科学难题，用有限的算力和干净的数据，换来对全人类都有益的突破。这才是另一种更值得期待的未来。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394842" alt="" title="" loading="lazy"/></p><p><strong>中美对抗只是幌子，硅谷才是真正收割者</strong></p><p>过去几年，硅谷喜欢把AGI的竞赛包装成一场「中美对抗」。</p><p>只要跑赢中国，美国就能确保世界的自由与开放。这样的叙事不仅在科技圈流传，还成了资本市场的兴奋剂。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394843" alt="" title="" loading="lazy"/></p><p>但Karen Hao观察到的却完全不同。她在TechCrunch的采访中直言：</p><p>事实恰恰相反。美国和中国之间的差距并没有因此扩大，硅谷对世界的影响反而是不自由化的……唯一未受伤害的，可以说只有硅谷自己。</p><p>换句话说，「中美对抗」更像是一块挡箭牌，让企业在无休止的扩张中获得合法性。</p><p>与此同时，OpenAI内部的身份矛盾也愈发明显。</p><p>一方面，它以非营利基金会的姿态宣称使命是「造福人类」；另一方面，它又通过营利子公司不断推进商业化。</p><p>今年与微软的新协议，更被普遍视为迈向上市的一步。</p><p>两名前安全研究员甚至在接受TechCrunch采访时表示，他们担心公司已经把「受欢迎的产品」等同于「造福人类」的证明，只要ChatGPT被大众使用，就默认达成了使命。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394844" alt="" title="" loading="lazy"/></p><p>与此同时，OpenAI的公司架构也一度摇摆——从最初的非营利实体，到计划转为Public Benefit Corporation（PBC），再到后来迫于压力宣布仍由非营利基金会控制。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394845" alt="" title="" loading="lazy"/></p><p>这种不断调整，本身也反映了「使命」与「资本」之间难以调和的矛盾。</p><p>Hao的提醒不容忽视：</p><p>哪怕证据不断显示，这些系统正在伤害大量人群，但那套自造的使命依然把一切遮盖。</p><p>在这样的叙事下，「中美对抗」的紧张气氛，和「造福人类」的口号，最终都成了硅谷加速收割的幌子。</p><p>从「造福人类」的口号，到「中美对抗」的叙事，再到资本市场的狂热，AI 行业已经织就了一张庞大的信仰之网。</p><p>即便证据不断累积，证明这些系统正在制造失业、透支能源、加剧心理危机，那套使命依然能把一切遮盖。</p><p>这正是帝国式扩张最危险的地方：当信仰变成遮羞布，现实的伤害便被逐渐抹去。</p><p>历史上，殖民者曾以「拯救灵魂」为名掩盖掠夺；今天的 AI 帝国，则以「AGI 造福全人类」为名，加速收割资源与权力。</p><p>问题是，当越来越多的人被迫为这场竞赛买单，我们还要继续相信这个神话吗？</p><p>AGI，到底是人类的希望，还是另一场幻觉？</p>]]></description></item><item>    <title><![CDATA[2025中国密码学会年会“人才培养论坛”]]></title>    <link>https://segmentfault.com/a/1190000047394775</link>    <guid>https://segmentfault.com/a/1190000047394775</guid>    <pubDate>2025-11-13 13:03:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>2025年11月8日，第十八届中国密码学会年会“人才培养论坛”在天津圆满落幕。本次论坛由中国密码学会主办，南开大学承办，蚂蚁密算提供支持。论坛汇聚了来自全国多所顶尖高校与企业的专家学者，围绕“密码学人才培养的产学融合与创新实践”展开深度交流，共同探索密码人才培育的新模式与发展路径。</p><p><strong>产学合作新成果：《隐私计算导论》新书发布</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394777" alt="761472f5-86e2-4a7f-a4f5-e671e4fe791c.png" title="761472f5-86e2-4a7f-a4f5-e671e4fe791c.png"/></p><p>作为论坛的重要环节，大数据新兴领域“十四五”高等教育教材<strong>《隐私计算导论》</strong>新书正式发布。该书由<strong>华东师范大学</strong>与<strong>蚂蚁密算</strong>共同撰写，系统梳理了隐私计算的理论体系与技术框架，并融入丰富的案例与实践内容，旨在为高校学生提供全面、前沿的知识体系，同时也为隐私计算技术的落地应用提供重要参考。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047394778" alt="92ed04fd-372f-4899-86dd-96e071e735ef.png" title="92ed04fd-372f-4899-86dd-96e071e735ef.png" loading="lazy"/></p><p>北京电子科技学院肖嵩校长、北京理工大学祝烈煌教授、华东师范大学陈岑副教授、华东师范大学王延昊副教授、蚂蚁密算科技谭晋先生，以及高等教育出版社赵冠群老师共同参与新书发布。该书的出版是产学合作在教材建设与知识沉淀方面的重要成果！</p><p><strong>“人才培养”专题分享</strong></p><p>在专题分享环节，多位专家学者从不同角度出发，分享了密码学人才培养的创新实践与系统思考。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394779" alt="abe1a528-7563-42a5-abbb-d236209c2689.png" title="abe1a528-7563-42a5-abbb-d236209c2689.png" loading="lazy"/></p><p><strong>蚂蚁密算隐语框架负责人谭晋</strong>以“产教融合：隐语社区与密码人才培养的协同发展”为题，系统介绍了隐语社区在密码人才培养中的实践路径。围绕“学、练、赛、研、证”五大环节，构建了完整的培养体系，推动数据要素技术人才培养落地。浙江大学<strong>“<strong><em><em>百人计划</em></em></strong>”</strong><strong>研究员张秉晟</strong>分享了《校企合作与教学实践创新》项目成果，通过共建课程、共办赛事、共享资源等具体案例，阐释了高校与企业协同育人机制，实现人才培养与产业需求的高效对接。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047394780" alt="db1c74cd-d5bd-4580-b227-e253cbc1ce98.png" title="db1c74cd-d5bd-4580-b227-e253cbc1ce98.png" loading="lazy"/></p><p><strong>南京大学毛云龙副教授</strong>在《以赛代培：网安竞赛中的学生培养》报告中指出，竞赛机制在密码学教育中具有独特价值。“以赛代培”不仅能强化学生解决实际问题的能力，更能有效激发创新思维，为实战型人才成长提供重要路径。<strong>华东师范大学陈岑副教授</strong>分享了《隐私计算导论》的编写框架，构建了从基础理论到应用实践的梯度化学习体系，并分享了基于隐语社区的课程建设与开源共建成果。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394781" alt="b3909eac-0567-4332-9d04-2af232170993.png" title="b3909eac-0567-4332-9d04-2af232170993.png" loading="lazy"/></p><p><strong>北京电子科技学院肖嵩校长</strong>探讨了“政产学研用”协同密码人才培养模式的探索实践，强调多方联动在构建高质量密码人才生态中的关键作用。<strong>北京理工大学祝烈煌教授</strong>聚焦“商用密码实战型人才培养”，从实战能力构建、课程体系设计到产教平台共建，系统阐述了面向产业需求的密码人才培养路径。</p><p>在圆桌论坛环节，<strong>南开大学计算机学院刘哲理教授</strong><strong>担任主持人，与北京航空航天大学刘建伟教授、北京印刷学院信息工程学院李子臣教授、西安电子科技大学李晖教授</strong>，围绕“密码人才培养体系构建与实践路径创新”展开深度对话。各位专家结合各校学科特色与育人经验，就课程体系设计、产学协同机制等关键议题分享了宝贵见解，为密码学教育创新提供了实践参考。</p><p>本次论坛展现了密码学人才培养领域的创新实践与前沿思考，与会专家一致认为，在数据要素市场化进程加速的背景下，深化产教融合、加强校企协同，是培养符合产业需求的密码学人才的关键所在。<strong>蚂蚁密算积极推进学研生态的共建，开放多种校企产学合作形式，</strong>涵盖课堂教学、高校赛事、科研项目、学生实践等多个层面。我们致力于推动数据要素前沿技术的发展，培养创新型应用人才，促进数据要素领域的创新实践，并加速科技成果的转化与落地。期待与产学研各界专家携手合作，为数据要素产业的繁荣发展贡献新的力量。</p>]]></description></item><item>    <title><![CDATA[一体云平台横向对比：四大CRM/ERP品]]></title>    <link>https://segmentfault.com/a/1190000047394789</link>    <guid>https://segmentfault.com/a/1190000047394789</guid>    <pubDate>2025-11-13 13:02:15</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化转型浪潮中，<strong>一体云平台</strong>已成为企业破解“信息孤岛”、实现全岗位协同的核心工具。其核心价值在于：以<strong>数据打通</strong>为底层逻辑，以<strong>岗位适配</strong>为应用抓手，以<strong>流程协同</strong>为最终目标，覆盖市场、销售、采购、仓库、财务、客服、外勤、生产等全岗位，构建“业务-数据-决策”的闭环。</p><p>本文基于超兔、Salesforce、用友、SAP四大主流品牌的公开能力素材，从<strong>核心定位、岗位能力、支撑技术、适用场景</strong>四大维度展开横向对比，为企业选型提供专业参考。</p><h2>一、核心定位与企业适配性对比：从“规模”到“行业”的精准匹配</h2><p>一体云平台的本质是“<strong>企业业务的数字化映射</strong>”，其定位直接决定了对企业规模、行业属性的适配性。四大品牌的核心差异首先体现在“服务谁”与“解决什么核心问题”上：</p><table><thead><tr><th><strong>品牌</strong></th><th><strong>核心定位</strong></th><th><strong>主打行业</strong></th><th><strong>适配企业规模</strong></th><th><strong>核心痛点解决</strong></th></tr></thead><tbody><tr><td>超兔一体云</td><td>中小工贸企业全业务数据一体化管理平台（CRM+OMS+SRM+PSI+轻MES）</td><td>工业类、工贸类中小企业</td><td>10-500人中小微/成长型企业</td><td>中小工贸“订单-采购-仓库-财务”链路割裂</td></tr><tr><td>Salesforce</td><td>全球领先云端CRM+全渠道数据一体化平台（销售云+服务云+营销云+Customer 360）</td><td>跨国企业、高增长行业（制造/零售）</td><td>500人以上大型/跨国企业</td><td>大型企业“跨区域/跨部门/跨系统”协同</td></tr><tr><td>用友一体化云</td><td>成长创新型制造企业业财税一体化平台（公有云/私有云/混合云）</td><td>制造、零售、流通行业</td><td>100-1000人成长型制造企业</td><td>制造企业“业财税分离、生产-销售脱节”</td></tr><tr><td>SAP一体云</td><td>全规模企业ERP核心的全价值链一体化平台（S/4HANA Cloud+BTP+Business Network）</td><td>制造、金融、能源等全行业</td><td>100人以上中大型/集团企业</td><td>企业“核心ERP与外围系统”集成难</td></tr></tbody></table><h2>二、全岗位数据一体化能力深析：从“功能覆盖”到“场景适配”</h2><p>一体云平台的价值最终落地于<strong>岗位场景</strong>。以下从八大核心岗位出发，对比四大品牌的“功能精准度”与“数据协同能力”：</p><h3>1. 市场岗：从“获客”到“转化”的全链路数据闭环</h3><p>市场岗的核心需求是“<strong>精准获客+效果可测</strong>”，四大品牌的能力差异体现在“渠道整合”与“数据归因”的深度：</p><ul><li><strong>超兔</strong>：聚焦中小工贸的“低成本获客”，提供<strong>多点获客工具</strong>（线上表单/线下活动）、<strong>营销物料管理</strong>（素材库+分发跟踪）、<strong>丢单分析</strong>（竞争关系监测+渠道转化率计算）、<strong>用户画像云图、</strong> 基于RFM的客户分组。</li><li><strong>Salesforce</strong>：针对大型企业的“全渠道精准营销”，通过<strong>Customer 360</strong>整合线上（官网/社交）、线下（门店）客户行为数据，生成<strong>动态用户画像</strong>；借助<strong>Einstein</strong> <strong>GPT</strong>自动化生成营销内容（邮件/社媒文案），并通过<strong>Tableau</strong>实现“营销投入-转化效果”的实时分析。</li><li><strong>用友</strong>：侧重制造企业的“线上线下融合”，提供<strong>电商通</strong>（多平台店铺数据同步）、<strong>订货商城</strong>（经销商专属下单平台）、<strong>客户运营</strong>（拉新复购+爆品推广+全景视图分析）。</li><li><strong>SAP</strong>：依托<strong>CRM</strong> <strong>云</strong>整合市场活动数据，通过<strong>IBP</strong> <strong>集成业务计划</strong> <strong>云</strong>实现“市场需求-生产计划”的联动，支持<strong>需求预测</strong>（AI驱动的市场趋势分析）。</li></ul><h3>2. 销售岗：从“线索”到“回款”的全生命周期管理</h3><p>销售岗的核心是“<strong>高效跟单+目标达成</strong>”，四大品牌的能力差异体现在“跟单模型”与“数据赋能”的个性化：</p><ul><li><strong>超兔</strong>：针对中小销售团队的“轻量化跟单”，提供<strong>五类跟单模型</strong>（线索-机会-合同-售后-复购）、<strong>目标分解工具</strong>（4倍目标法+红绿灯预警）、<strong>客户财务总控</strong>（销售额-成本-费用的实时利润计算）、<strong>销售奖金算法</strong>（分级提成+订单净利润）。</li><li><strong>Salesforce</strong>：针对大型销售团队的“全流程赋能”，通过<strong>销售云</strong>管理线索-机会-合同全链路；<strong>Einstein</strong> <strong>GPT</strong>辅助生成“个性化销售话术”，并预测客户需求；<strong>移动终端</strong>支持外勤销售实时访问客户数据（拜访记录+机会进度）。</li><li><strong>用友</strong>：侧重制造企业的“渠道销售”，提供<strong>多维度铺货统计</strong>（时段/商品/客户）、<strong>经营驾驶仓</strong>（毛利/资金指标看板）、<strong>内部交易管理</strong>（分公司/经销商的订单协同）。</li><li><strong>SAP</strong>：依托<strong>S/4</strong> <strong>HANA</strong> <strong>Cloud</strong>整合销售订单数据，通过<strong>Business</strong> <strong>AI</strong>预测客户需求趋势，支持<strong>销售计划与生产计划</strong>的联动（如汽车行业的“订单-排产”协同）。</li></ul><h3>3. 采购岗：从“寻源”到“付款”的智能协同</h3><p>采购岗的核心是“<strong>降本+合规</strong>”，四大品牌的能力差异体现在“智能决策”与“供应商协同”的深度：</p><ul><li><strong>超兔</strong>：针对中小工贸的“快速采购”，提供<strong>智能采购策略</strong>（按库存缺口/销售计划自动计算采购量）、<strong>历史供应商匹配</strong>（优质供应商推荐）、<strong>采购应付管理</strong>（票据/退款/退货的闭环）。</li><li><strong>Salesforce</strong>：通过<strong>集成</strong> <strong>SAP</strong> <strong>Ariba</strong>实现“全球集中采购”，支持<strong>智能物料分组</strong>（AI推荐最优采购组合）、<strong>合规监控</strong>（供应商资质自动审核）。</li><li><strong>用友</strong>：侧重制造企业的“供应链协同”，提供<strong>云采购</strong> <strong>服务</strong>（全球寻源）、<strong>合同</strong> <strong>全生命周期管理</strong>（签订-执行-支付-核算）、<strong>物资收发领用</strong>（暂估进货+调拨管理）。</li><li><strong>SAP</strong>：依托<strong>Ariba Cloud</strong>与<strong>Business Network</strong>（全球5万亿美元交易额的B2B平台），实现“企业-供应商”的实时协同（请购-报价-订单-对账）；通过<strong>BTP</strong>集成第三方采购工具（如简道云）。</li></ul><h3>4. 仓库岗：从“入库”到“溯源”的精准库存管理</h3><p>仓库岗的核心是“<strong>库存精准+周转高效</strong>”，四大品牌的能力差异体现在“分仓管理”与“库存预警”的灵活性：</p><ul><li><strong>超兔</strong>：针对中小工贸的“多仓需求”，支持<strong>500</strong> <strong>分仓</strong> <strong>配置</strong>（库管+多类型出入库）、<strong>库存预警</strong>（积压/脱销提醒）、<strong>序列号</strong> <strong>管理</strong>（产品全链路溯源）、<strong>产品</strong> <strong>BOM</strong> <strong>/套餐管理</strong>（生产工单的物料配比）。</li><li><strong>Salesforce</strong>：通过<strong>Tableau</strong>实现“库存周转率”实时可视化，支持<strong>移动扫码</strong>（出入库数据同步至销售/财务）。</li><li><strong>用友</strong>：侧重制造企业的“生产库存联动”，提供<strong>条码</strong> <strong>/</strong> <strong>PDA</strong> <strong>作业</strong>（实时库存更新）、<strong>ATP</strong> <strong>可用量管理</strong>（生产/销售的库存分配）、<strong>多角贸易</strong>（分支机构间库存调拨）。</li><li><strong>SAP</strong>：依托<strong>S/4</strong> <strong>HANA</strong> <strong>Cloud</strong>整合仓库数据，通过<strong>Digital Supply Chain</strong>实现“库存-生产-销售”的联动，支持<strong>智能库存优化</strong>（AI驱动的积压库存处理建议）。</li></ul><h3>5. 财务岗：从“核算”到“决策”的业财一体化</h3><p>财务岗的核心是“<strong>精准核算+风险预警</strong>”，四大品牌的能力差异体现在“业财联动”与“智能管控”的深度：</p><ul><li><strong>超兔</strong>：针对中小工贸的“简单财务”，提供<strong>智能应收/回款/发票管理</strong>（订单生成应收凭证）、<strong>客户总利润计算</strong>（销售额-成本-费用）、<strong>销售费用管理</strong>（差旅报销+借支闭环）。</li><li><strong>Salesforce</strong>：通过<strong>集成</strong> <strong>SAP</strong> <strong>S/4</strong> <strong>HANA</strong> <strong>Cloud</strong>实现“业财实时联动”（销售订单自动生成财务凭证），支持<strong>实时报表</strong>（Tableau的财务看板）、<strong>风险预警</strong>（AI驱动的应收账款逾期提醒）。</li><li><strong>用友</strong>：聚焦制造企业的“业财税闭环”，提供<strong>智能报账</strong>（申请-审批-支付-核算）、<strong>电子会计档案</strong>（合规存储）、<strong>成本管理</strong>（生产/销售成本的多维度分析）。</li><li><strong>SAP</strong>：以<strong>S/4</strong> <strong>HANA</strong> <strong>Cloud</strong>为核心，实现“财务-供应链-生产”的实时集成（物料收发自动生成财务分录），支持<strong>预算管理</strong>（AI驱动的预算偏差预警）、<strong>全球合规</strong>（多币种/多时区财务处理）。</li></ul><h3>6. 生产岗：从“订单”到“交付”的全流程自动化</h3><p>生产岗的核心是“<strong>排产高效+质量可控</strong>”，四大品牌的能力差异体现在“生产-业务”的联动深度：</p><ul><li><strong>超兔</strong>：针对中小工贸的“轻生产”，提供<strong>生产工单管理</strong>（订单自动生成工单+领料/报工/质检的扫码流程）、<strong>非标生产管理</strong>（定制化产品的BOM配置）。</li><li><strong>Salesforce</strong>：通过<strong>低代码</strong> <strong>平台</strong>自定义“生产排程”功能，集成<strong>IoT</strong> <strong>设备数据</strong>（实时监控生产状态），支持“生产-销售-服务”的全链路可视化。</li><li><strong>用友</strong>：侧重制造企业的“深度生产协同”，提供<strong>智能化</strong> <strong>MOM</strong> <strong>平台</strong>（敏捷制造+产销协同+资源协调）、<strong>精智</strong> <strong>工业互联网</strong> <strong>平台</strong>（连接设备+工人+物料，实现“个性化定制”）。</li><li><strong>SAP</strong>：依托<strong>S/4</strong> <strong>HANA</strong> <strong>Cloud</strong>整合生产数据，通过<strong>MES</strong> <strong>集成</strong>实现“生产计划-车间执行”的联动，支持<strong>智能排程</strong>（AI驱动的设备利用率优化）。</li></ul><h3>7. 客服岗：从“响应”到“复购”的客户全生命周期服务</h3><p>客服岗的核心是“<strong>快速响应+问题闭环</strong>”，四大品牌的能力差异体现在“渠道整合”与“数据共享”的广度：</p><ul><li><strong>超兔</strong>：提供<strong>客服总控台</strong>（整合电话/微信/邮件的客户咨询）、<strong>客户讨论/待办沟通</strong>（与销售/生产的协同）、<strong>全周期服务支撑</strong>（售后工单-维修-回访的闭环）。</li><li><strong>Salesforce</strong>：通过<strong>服务云</strong>整合全渠道（电话/聊天/社交媒体）客户请求，借助<strong>Einstein</strong> <strong>GPT</strong>实现“工单智能路由”（分配给最合适的客服）、<strong>知识库</strong>（快速查询解决方案）。</li><li><strong>用友</strong>：侧重制造企业的“售后协同”，提供<strong>客户全景视图</strong>（整合销售/生产/财务数据）、<strong>售后工单管理</strong>（维修进度实时同步给客户）。</li><li><strong>SAP</strong>：依托<strong>Service Cloud</strong>整合客服数据，通过<strong>Business Network</strong>连接“企业-服务商”（第三方维修服务的协同），支持“客服-财务”的联动（售后费用自动核算）。</li></ul><h3>8. 外勤岗：从“拜访”到“任务”的移动协同</h3><p>外勤岗的核心是“<strong>实时记录+任务闭环</strong>”，四大品牌的能力差异体现在“移动工具”与“数据同步”的便捷性：</p><ul><li><strong>超兔</strong>：提供<strong>移动端外勤拜访记录</strong>（位置打卡+客户沟通笔记）、<strong>任务执行</strong>（工单/回访的实时更新）、<strong>快协作</strong>（与总部的即时沟通）。</li><li><strong>Salesforce</strong>：通过<strong>移动App</strong>实时访问客户数据（拜访记录+机会进度），支持“外勤-销售”的协同（拜访后自动更新客户状态）。</li><li><strong>用友</strong>：侧重制造企业的“外勤服务”，提供<strong>外勤跟踪</strong>（统计/分析外勤人员的任务完成率）、<strong>移动审批</strong>（报销/请购的实时处理）。</li><li><strong>SAP</strong>：依托<strong>S/4HANA Cloud Mobile</strong>实现“外勤-核心ERP”的同步（如设备维修记录自动更新至生产系统），支持“多语言/多时区”的外勤协同。</li></ul><h2>三、关键支撑技术对比：从“数据打通”到“智能赋能”</h2><p>一体云平台的“长期价值”取决于<strong>支撑技术</strong>的先进性。以下从四大核心技术维度对比：</p><h3>1. 数据集成能力：从“系统连接”到“生态协同”</h3><p>数据集成是一体云的“底层基建”，四大品牌的差异体现在“集成范围”与“协同深度”：</p><ul><li><strong>超兔</strong>：通过<strong>OpenCRM业务伙伴共生平台</strong>，实现“企业-供应商-客户”的全链路协同（报价单/订单/发货的共享）；支持<strong>API</strong> <strong>对接</strong>（与电商/ERP系统的同步）。</li><li><strong>Salesforce</strong>：以<strong>Customer 360</strong>为核心，整合销售/服务/营销数据；通过<strong>AppExchange</strong>（2000+应用）扩展集成能力（如生产管理插件）；支持<strong>阿里云/</strong> <strong>AWS</strong>等公有云对接。</li><li><strong>用友</strong>：通过<strong>OpenAPI</strong>实现“业财税”系统的闭环（销售订单→财务凭证→税务申报）；整合<strong>电商/门店/经销商</strong>数据，实现“线上线下”的库存/订单同步。</li><li><strong>SAP</strong>：以<strong>BTP（业务技术云平台）为核心，支持“</strong> <strong>ERP</strong> <strong>与外围系统”的</strong> <strong>低代码</strong> <strong>集成；依托Business Network</strong>（全球最大B2B平台），实现“企业-供应链伙伴”的实时协同（年交易额超5万亿美元）。</li></ul><h3>2. AI智能化：从“自动化”到“决策支持”</h3><p>AI是一体云的“增值引擎”，四大品牌的差异体现在“AI与业务场景”的融合深度：</p><ul><li><strong>超兔</strong>：提供<strong>AI</strong> <strong>智能体</strong>（低门槛自定义，嵌入客户/行动视图）、<strong>Coze</strong> <strong>工作流</strong>（扩展高级AI能力，如销售跟单建议）；支持<strong>电话录音分析</strong>（提取客户需求关键词）。</li><li><strong>Salesforce</strong>：以<strong>Einstein</strong> <strong>GPT</strong>为核心，覆盖销售（话术生成）、客服（工单路由）、财务（报表自动化）等场景；通过<strong>Tableau</strong>实现“AI驱动的实时数据洞察”（如销售趋势预测）。</li><li><strong>用友</strong>：依托<strong>大模型</strong>实现“库存智能诊断”（积压/缺货预警）、“财务风险预警”（应收账款逾期提醒）；支持“生产排程”的AI优化（设备利用率提升）。</li><li><strong>SAP</strong>：内置<strong>Business</strong> <strong>AI</strong>（覆盖财务/供应链/生产等场景）、<strong>IBP</strong> <strong>集成业务计划</strong> <strong>云</strong>（AI驱动的需求预测/生产排程）；支持“客户需求趋势”的机器学习分析。</li></ul><h3>3. 定制化灵活性：从“标准化”到“个性化”</h3><p>定制化是一体云“适配企业差异”的关键，四大品牌的差异体现在“定制成本”与“技术门槛”：</p><ul><li><strong>超兔</strong>：提供<strong>低成本</strong> <strong>客制化</strong>（三级菜单自定义+工作台配置+白名单订阅），支持“大底座+快启动”模式（无需代码，快速适配中小工贸的个性化需求）。</li><li><strong>Salesforce</strong>：基于<strong>Salesforce Platform</strong>实现<strong>低代码</strong> <strong>开发</strong>（Drag-and-Drop界面），快速搭建“生产排程”“外勤管理”等自定义功能；支持<strong>第三方插件集成</strong>（AppExchange）。</li><li><strong>用友</strong>：提供<strong>公有云/私有云/混合云</strong>部署，支持“模块化定制”（按需选择财务/供应链/生产模块）；通过<strong>低代码</strong> <strong>平台</strong>适配制造企业的“个性化生产流程”。</li><li><strong>SAP</strong>：以<strong>BTP</strong>为核心，支持<strong>低代码</strong> <strong>/无代码开发</strong>（适配企业个性化需求）；提供<strong>行业预置</strong> <strong>最佳实践</strong>（如汽车零部件的供应链优化），降低定制成本。</li></ul><h3>4. 部署模式：从“公有云”到“混合云”</h3><p>部署模式决定了企业的“合规性”与“灵活性”，四大品牌的差异体现在“云模式”的覆盖度：</p><ul><li><strong>超兔</strong>：以<strong>公有云</strong>为主，支持<strong>SaaS模式</strong>（快速部署，按月付费），适配中小工贸的“低成本需求”。</li><li><strong>Salesforce</strong>：支持<strong>公有云</strong>（Sales Cloud/Service Cloud）、<strong>私有云</strong>（Salesforce Platform）、<strong>混合云</strong>（整合企业现有系统），满足跨国企业的“本地化合规”（如中国数据 residency）。</li><li><strong>用友</strong>：提供<strong>公有云（U8 Cloud）、私有云（NC Cloud）、混合云</strong>部署，适配制造企业的“数据安全”需求（如生产数据的私有云存储）。</li><li><strong>SAP</strong>：支持<strong>公有云（S/4</strong> <strong>HANA</strong> <strong>Cloud Public Edition）、私有云（S/4HANA Cloud Private Edition）、混合云</strong>，满足中大型企业的“复杂合规”需求（如金融行业的数据隔离）。</li></ul><h2>四、品牌功能详情</h2><h3>1，用友一体化云平台业务管理能力总结</h3><h4><strong>一、核心定位与覆盖范围</strong></h4><p>用友一体化云平台聚焦<strong>成长创新型制造企业</strong>及大中小微企业，提供<strong>公有云、私有云、混合云</strong>一体化部署模式，覆盖<strong>市场、销售、采购、仓库、财务、客服、外勤服务、生产</strong>等全岗位，实现数据一体化的业务管理闭环。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394791" alt="" title=""/></p><h4><strong>二、各岗位/模块具体能力</strong></h4><ol><li><p><strong>市场与销售</strong>：</p><ol><li>全渠道营销：支持线上（电商平台、自建微商城、微信营销）、线下（门店、经销商）融合，提供<strong>订货商城</strong>（搭建经销商服务平台）、<strong>电商通</strong>（多电商平台店铺数据同步）、<strong>客户运营</strong>（拉新复购、爆品推广、客户全景视图分析）。</li><li>销售管理：覆盖销售报价、合同、内部交易、需求跟踪，支持<strong>多维度铺货统计</strong>（时段、商品、客户）及<strong>经营驾驶仓</strong>（行业大数据分析、毛利/资金指标看板）。</li></ol></li><li><p><strong>采购与供应链</strong>：</p><ol><li>采购管理：提供<strong>云采购</strong> <strong>服务</strong>（全球寻源、韧性供应），支持询价采购、合同全生命周期管理（签订-执行-支付-核算）、物资收发领用（购入/领用/调拨/暂估）。</li><li>供应链协同：供应链云与采购云、营销云、制造云深度融合，实现<strong>产供销、业财税一体化</strong>，支持产业链上下游协同（通过OpenAPI对接第三方服务），提供库存管理（条码、PDA作业、动态安全库存）、ATP（可用量）管理、多角贸易。</li></ol></li><li><p><strong>仓库管理</strong>：</p><ol><li>支持<strong>异地仓库、多门店、分支机构协同</strong>，实时反映库存状况，处理暂估进货、退货等特殊场景，提供<strong>库存分析</strong>（基于大模型的智能诊断）。</li></ol></li><li><p><strong>财务与会计</strong>：</p><ol><li>一体化财务平台：集成预算管理、账务处理、报表分析、成本控制，实现<strong>业财税票一体化</strong>（智能核算、实时报表、电子会计档案）。</li><li>会计一体化系统：整合账务处理、报表分析、成本管理、税务申报（全税种管理、税务申报/分析），提供<strong>智能报账</strong>（端到端流程：申请-审批-支付-核算）。</li></ol></li><li><p><strong>客服与外勤</strong>：</p><ol><li>智能客服：与营销云融合，赋能售前方案，提供线上线下一体的客户服务。</li><li>外勤管理：支持高效外勤跟踪（统计、分析），提升外勤服务效率。</li></ol></li><li><p><strong>生产管理</strong>：</p><ol><li>一体化生产运营：提供<strong>智能化</strong> <strong>MOM</strong> <strong>平台</strong>（敏捷制造、产销协同、生产计划/资源协调），支持<strong>实时数据采集管控</strong>（降本增效）。</li><li>制造云：通过“精智工业互联网平台”连接企业与社会资源，实现<strong>智能化生产、个性化定制、网络化协同</strong>（如铜冶炼智能工厂案例）。</li></ol></li></ol><h4><strong>三、技术与生态支撑</strong></h4><ul><li>技术架构：采用<strong>云原生</strong> <strong>微服务架构</strong>，弹性扩展，支持模块化部署；融入AI、大数据技术（如智能财务核算、供应链预测）。</li><li>生态协同：开放OpenAPI对接第三方服务，聚合生态伙伴，提供行业定制化解决方案（制造、零售、能源等）。</li></ul><h3>2，超兔一体云平台能力总结</h3><p>超兔一体云平台是面向工业类、工贸类中小企业的<strong>全业务数据一体化管理平台</strong>，核心定位是为市场、销售、采购、仓库、财务、客服、生产等各岗位提供数据打通的业务管理支撑，解决企业“数据孤岛”问题，提升跨部门协作效率。其能力覆盖以下维度：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394792" alt="" title="" loading="lazy"/></p><h4><strong>1. 全业务模块底层连通，实现链路协同</strong></h4><p>超兔一体云打通<strong>CRM</strong> <strong>、进销存、财务、生产工单、轻</strong> <strong>MES</strong> <strong>、上下游供应链、</strong> <strong>日记账</strong>等10+模块，底层数据完全连通，实现“客户需求→订单→交付→服务”全链路协同，支撑企业从获客到售后的全流程业务管理。</p><h4><strong>2. 各岗位具体业务管理能力</strong></h4><p>针对市场、销售、采购、仓库、财务、生产、客服等核心岗位，提供适配其业务场景的功能：</p><ul><li><strong>市场岗</strong>：多点获客工具、营销物料管理、市场活动管理、竞争关系监测（丢单分析）、各渠道转化率/投产比分析、用户画像云图。</li><li><strong>销售岗</strong>：全触点跟单工具（五类跟单模型）、目标分解（目标分解客户法/4倍目标法/目标红绿灯）、日报/快协作、客户财务数据总控、销售分级奖金算法、销售费用/差旅借支报销管理、RFM客户分组与基线规划。</li><li><strong>采购岗</strong>：智能采购策略（按计划或库存缺口决策）、自动计算最优采购量、匹配历史优质供应商、供应商总控、采购应付/付款/票据管理、采购退货-退款管理。</li><li><strong>仓库岗</strong>：500分仓配置、独立库管、多类型出入库管理（订单/采购/调拨/工单等）、库存预警（积压/脱销）、序列号管理、库存溯源、产品BOM/套餐管理、产品销量分析（滞销/缺货预警）。</li><li><strong>财务岗</strong>：智能应收/回款/发票管理、客户总利润计算（销售额-产品成本-销售费用）、产品/订单毛利计算、库存资产管理、销售费用/差旅报销管理、微业务微信收款管理。</li><li><strong>生产岗</strong>：从订单到MES的全流程自动化排程（生产派工、领料/扫码、报工/扫码、质检/扫码、成品入库）、非标生产管理。</li><li><strong>客服岗</strong>：客服总控台、客户讨论/待办沟通、全周期客户服务支撑。</li></ul><h4><strong>3.</strong> <strong>客制化</strong> <strong>与适配性</strong></h4><p>支持<strong>低成本</strong> <strong>客制化</strong>，包括三级菜单自定义、工作台配置、白名单订阅等，提供“大底座、快启动”模式，既满足企业个性化需求，也适配未来业务增长。</p><h4><strong>4. 多端覆盖与系统集成</strong></h4><ul><li>多端支持：覆盖Web、App、小程序、RPA插件等，满足企业随时随地办公需求。</li><li>集成能力：具备丰富业务API，可对接ERP、WMS、电商平台等外部系统，拓展业务边界。</li></ul><h4><strong>5. 稳定与服务保障</strong></h4><ul><li>系统稳定性：业内认可，40%新客户来自老客户转介绍。</li><li>服务支持：客服响应及时、专业，提供从需求诊断到系统上线的全流程支持。</li></ul><h3>3，Salesforce 一体云平台针对各岗位的数据一体化业务管理能力总结</h3><h4><strong>一、平台核心定位</strong></h4><p>Salesforce 作为全球领先的云端 CRM 平台，通过<strong>多模块整合</strong>（销售云、服务云、营销云等）、<strong>数据闭环打通</strong>（前端业务与后端 ERP/HR 系统集成）及<strong>AI</strong> <strong>驱动</strong>，为市场、销售、采购、仓库、财务、客服、外勤服务、生产等岗位提供<strong>数据一体化的业务管理支持</strong>，实现跨部门实时协同与决策。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394793" alt="" title="" loading="lazy"/></p><h4><strong>二、各岗位具体能力支持</strong></h4><p>基于原始信息，Salesforce 一体云平台对各岗位的核心支持如下：</p><ol start="7"><li><p><strong>市场岗</strong>：</p><ol><li>依托<strong>营销云（Marketing Cloud）与Customer 360 统一客户视图</strong>，整合全渠道客户数据（如行为、偏好），实现<strong>精准客户画像</strong>；</li><li>通过 AI 工具（如 Einstein GPT）自动化生成营销内容（如邮件、社交媒体文案），并支持<strong>多渠道营销活动管理</strong>（广告、电商、社交），提升营销效率。</li></ol></li><li><p><strong>销售岗</strong>：</p><ol><li>借助销售云（Sales Cloud）管理销售全流程：包括线索挖掘、机会跟踪、报价/合同管理；</li><li>AI 能力（如 Einstein GPT）辅助<strong>自动生成销售话术</strong>、<strong>预测客户需求</strong>及<strong>销售业绩分析</strong>；</li><li>移动终端支持<strong>实时访问客户数据</strong>（如拜访记录、机会进度），适配外勤销售场景。</li></ol></li><li><p><strong>采购岗</strong>：</p><ol><li>通过<strong>集成</strong> <strong>SAP</strong> <strong>Ariba 集中式采购云</strong>（或第三方 ERP 系统），统一管理全球采购流程（请购、合同、供应商协同）；</li><li>AI 功能（如智能物料分组建议、合规监控）降低采购成本，提升谈判效率。</li></ol></li><li><p><strong>仓库岗</strong>：</p><ol><li>利用<strong>Tableau 分析云</strong>提供的<strong>可视化报表</strong>，实时监控<strong>库存周转率</strong>、出入库数据；</li><li>移动设备支持<strong>扫码更新库存</strong>，实现仓库数据与销售、采购流程的实时同步。</li></ol></li><li><p><strong>财务岗</strong>：</p><ol><li>集成<strong>SAP</strong> <strong>S/4</strong> <strong>HANA</strong> <strong>Cloud（</strong> <strong>ERP</strong> <strong>云）或财务系统，实现自动化报表生成</strong>、<strong>审批流程</strong>及<strong>跨国对账</strong>；</li><li>通过<strong>Business Data Cloud</strong>统一治理财务数据，支持 AI 驱动的支出控制与风险预警。</li></ol></li><li><p><strong>客服岗</strong>：</p><ol><li>基于<strong>服务云（Service Cloud）实现跨渠道客户支持</strong>（邮件、实时聊天、电话）；</li><li>AI 工具（如智能路由、Agentforce 360）自动分配工单、生成服务报告，提升响应速度；</li><li>知识库功能支持客服快速查询解决方案，统一客户服务标准。</li></ol></li><li><p><strong>外勤服务岗</strong>：</p><ol><li>移动终端支持<strong>实时更新任务状态</strong>（如客户拜访、工单进度）；</li><li>低代码平台可定制<strong>外勤路线规划</strong>，适配跨区域任务分配场景；</li><li>与服务云集成，实时同步客户问题与解决方案，提升外勤服务效率。</li></ol></li><li><p><strong>生产岗</strong>：</p><ol><li>通过<strong>Salesforce Platform</strong> <strong>低代码</strong> <strong>平台</strong>，自定义<strong>生产排期</strong>、<strong>设备运维</strong>等流程；</li><li>集成<strong>数字供应链云</strong>（如 SAP Digital Supply Chain），实现从产品设计到生产的<strong>全链条可视化</strong>，提升生产韧性。</li></ol></li></ol><h4><strong>三、平台关键能力支撑</strong></h4><ol start="15"><li><p><strong>数据一体化</strong>：</p><ol><li><strong>Customer 360 平台</strong>整合全渠道客户数据（销售、服务、营销），为各岗位提供<strong>统一客户视图</strong>；</li><li>支持与 ERP、HR、SAP 等第三方系统集成，打通采购、财务、仓库等后端流程，形成<strong>端到端数据闭环</strong>。</li></ol></li><li><p><strong>AI</strong> <strong>驱动效率</strong>：</p><ol><li><strong>Einstein</strong> <strong>GPT</strong>：贯穿销售（话术生成）、客服（工单路由）、财务（报表自动化）等岗位，实现业务自动化；</li><li><strong>Tableau 分析云</strong>：提供可视化数据报表，辅助管理层监控各岗位关键指标（如销售业绩、库存周转、财务回款）。</li></ol></li><li><p><strong>灵活定制与全球化</strong>：</p><ol><li><strong>低代码</strong> <strong>开发</strong>：基于 Salesforce Platform 快速搭建适配生产、外勤等岗位的自定义功能，无需大量代码；</li><li><strong>多语言/合规支持</strong>：覆盖 180 余国，满足跨国企业多时区协作、本地化合规（如中国数据 residency）及复杂权限管理（九级组织架构）。</li></ol></li><li><p><strong>移动与生态扩展</strong>：</p><ol><li><strong>全终端支持</strong>：移动端实时访问业务数据，适配外勤、销售等移动场景；</li><li><strong>开放生态</strong>：通过 AppExchange 应用市场扩展功能（如生产管理插件、采购审批工具），并支持与阿里云、AWS 等公有云对接。</li></ol></li></ol><h4><strong>四、适用场景</strong></h4><ul><li><strong>大型/跨国企业</strong>：需跨区域协同、复杂权限管理及本地化合规（如跨国制造企业的生产-销售-服务全链条管理）；</li><li><strong>成长型企业</strong>：通过 SaaS 模式快速部署，逐步扩展模块（如从销售云起步，后期添加营销云与财务集成），降低初期成本。</li></ul><h3>4，SAP一体云平台数据一体化业务管理能力总结</h3><h4><strong>一、平台核心定位</strong></h4><p>SAP作为德国企业管理软件提供商，其一体云平台以<strong>ERP</strong> <strong>（企业资源规划）为核心</strong>，结合自研与行业化组件，为市场、销售、采购、仓库、财务、客服、外勤服务、生产等岗位提供<strong>数据一体化的业务管理</strong>，覆盖企业全价值链关键环节，形成端到端业务闭环。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394794" alt="" title="" loading="lazy"/></p><h4><strong>二、覆盖的岗位与业务环节</strong></h4><p>平台覆盖企业核心业务场景，支撑多岗位数据协同：</p><ul><li><strong>市场与销售</strong>：客户订单管理、客户关系维护（CRM云）、需求预测（AI驱动）；</li><li><strong>采购与供应链</strong>：集中采购（Ariba Cloud）、供应商协同（Business Network）、库存优化（Digital Supply Chain）；</li><li><strong>生产与仓储</strong>：生产计划排程、设备维护、仓储物流（集成MES、WMS系统）；</li><li><strong>财务与风控</strong>：业财一体化核算、预算管理、风险预警（实时财务数据同步）；</li><li><strong>客服与外勤</strong>：全渠道服务接入（Service Cloud）、订单状态实时同步、外勤资源调度；</li><li><strong>人力资源</strong>：招聘、绩效、薪酬管理（SuccessFactors云）。</li></ul><h4><strong>三、数据一体化核心能力</strong></h4><ol start="19"><li><p><strong>系统与</strong> <strong>数据集成</strong></p><ol><li>通过<strong>标准</strong> <strong>API</strong> <strong>与事件总线</strong>，无缝集成MES（制造执行系统）、WMS（仓储管理系统）等第三方系统，贯通企业流程与数据，消除“信息孤岛”；</li><li>支持<strong>跨部门数据实时共享</strong>（如订单状态同步至客服、库存数据联动客户需求），实现业务流程端到端可视化。</li></ol></li><li><p><strong>业财一体化</strong></p><ol><li>以ERP为核心，实现<strong>财务与业务的实时联动</strong>（如物料收发自动生成财务凭证），减少人工录入，提升财务管控准确性。</li></ol></li><li><p><strong>模块化与定制化</strong></p><ol><li>采用<strong>模块化结构</strong>，覆盖财务、供应链、生产、HR等核心功能，企业可按需选用；</li><li>基于<strong>SAP</strong> <strong>BTP（业务技术云平台）</strong> ，支持低代码开发与第三方应用集成（如简道云），适配企业个性化需求。</li></ol></li><li><p><strong>智能化技术赋能</strong></p><ol><li>内置<strong>AI</strong> <strong>、</strong> <strong>机器学习</strong> <strong>、</strong> <strong>大数据分析</strong>（如IBP集成业务计划云、SAP Business AI），支持需求预测、风险预警、智能决策（如预测客户需求趋势、优化生产排程）；</li><li>提供<strong>实时数据洞察</strong>，助力管理层快速掌握业务动态（如销售数据、库存情况、财务报表实时分析）。</li></ol></li></ol><h4><strong>四、部署与适配模式</strong></h4><ul><li><strong>灵活部署</strong>：支持<strong>公有云（如</strong> <strong>SAP</strong> <strong>S/4</strong> <strong>HANA</strong> <strong>Cloud Public Edition）、私有云、混合云</strong>模式，适配不同行业合规需求（如金融行业数据安全要求）；</li><li><p><strong>企业适配</strong>：</p><ul><li>大型企业/集团：提供<strong>SAP</strong> <strong>S/4</strong> <strong>HANA</strong> <strong>Cloud</strong>（核心ERP云），支持复杂业务流程与多系统集成；</li><li>中小型企业：通过<strong>SaaS模式</strong>（如SAP Business One、Business ByDesign），提供低成本、易实施的一体化解决方案；</li><li>行业定制：针对制造、零售、金融、能源等行业，提供<strong>预置</strong> <strong>最佳实践</strong>（如汽车零部件行业的供应链优化、零售业的会员积分系统）。</li></ul></li></ul><h4><strong>五、服务与生态支持</strong></h4><ul><li><strong>实施与培训</strong>：提供技术专家的<strong>组织咨询、项目实施协助、企业内训</strong>，确保平台落地；</li><li><strong>开放生态</strong>：连接<strong>SAP</strong> <strong>Business Network</strong>（全球最大B2B平台，年交易额超5万亿美元），实现企业与供应链伙伴的协同；支持与电商平台、ERP系统等第三方应用API对接，扩展业务能力（如客户满意度调查表单同步至CRM）。</li></ul><p>综上，SAP一体云平台通过“核心ERP+模块化组件+智能集成”，实现多岗位数据一体化管理，助力企业提升运营效率、降低成本、敏捷响应市场变化。</p><p><strong>更多延伸：说明超兔一体云实现数据一体化业务管理平台的逻辑剖析</strong></p><h2>一、引言</h2><p>在当今竞争激烈的商业环境中，企业对于高效、集成化的业务管理系统需求日益增长。超兔一体云凭借其独特的优势，为市场、销售、采购、仓库、财务、客服、外勤服务、生产等各岗位提供了数据一体化的业务管理平台。以下将详细阐述其实现逻辑。</p><h2>二、核心架构奠定基础</h2><h3>（一）全业务一体化架构</h3><p>超兔一体云采用 CRM（客户关系管理）+OMS（订单执行系统）+SRM（采购管理系统）+PSI（进销存系统）+轻 MES（生产工单系统）+薪资管理+Open（供应链上下游）的全业务一体化架构。这种架构从底层打通了各个业务模块之间的数据连接，确保了不同业务环节的数据能够流畅地流转和共享。例如，销售部门的订单信息可以实时传递到采购部门，采购部门根据订单需求进行采购计划的制定和执行，同时仓库部门也能及时了解库存情况，做好货物的出入库管理。</p><h3>（二）强大的系统引擎支持</h3><p>超兔一体云具备多种系统引擎，为低成本客制化提供了有力支持。功能白名单订阅让企业可以根据自身需求选择所需功能，降低了使用成本；自定义三级菜单和工作台，使得不同岗位的员工可以根据自己的工作需求配置个性化的功能菜单和数据大屏，提高了工作效率；自定义业务表和工作流，能够满足企业复杂的业务流程需求，实现业务数据的精准管理；自定义多表聚合则为企业提供了强大的 BI 分析能力，帮助企业从海量数据中挖掘有价值的信息。</p><h2>三、数据流转实现互通</h2><h3>（一）业务数据的实时同步</h3><p>在超兔一体云平台中，各个业务模块之间的数据能够实时同步。以销售订单为例，当销售部门创建订单后，订单信息会立即同步到订单管理中心、采购管理模块、仓库管理模块以及财务部门。采购部门可以根据订单需求生成采购计划和采购单，仓库部门可以根据订单安排货物的出库，财务部门可以根据订单信息进行应收款的管理和核算。这种实时同步的数据流转方式，避免了数据的重复录入和不一致问题，提高了工作效率和数据的准确性。</p><h3>（二）上下游供应链的数据协同</h3><p>超兔一体云通过 OpenCRM 业务伙伴共生平台，实现了企业与上下游伙伴之间的数据协同。企业可以与供应商和客户共享报价单、订单、发货信息等，实现从询价、采购、发货到对账、开票、售后的全流程协同。例如，企业可以将报价单分享给客户，客户可以在网页或小程序上确认报价；企业可以将订单信息发送给供应商，供应商可以及时响应并执行采购单。这种上下游供应链的数据协同，提高了产业链的效率和透明度，降低了企业的运营成本。</p><h2>四、岗位适配保障应用</h2><h3>（一）多岗位功能定制</h3><p>超兔一体云针对不同岗位的需求，提供了丰富的功能定制选项。市场部门可以通过集客支持渠道获取潜在客户线索，并进行线索处理和营销物料管理；销售部门可以使用多种跟单模型进行客户跟进和订单管理；采购部门可以进行供应商管理、智能采购和采购单三流合一对账；仓库部门可以进行产品管理、库存管理和出入库操作；财务部门可以进行财务内账管理、薪资管理和预算管理；客服部门可以进行客户服务和投诉处理；外勤服务人员可以通过移动端进行外勤拜访记录和任务执行；生产部门可以进行生产计划排程和生产工单管理。每个岗位都能在超兔一体云平台上找到适合自己的功能，提高了工作效率和工作质量。</p><h3>（二）权限管理确保数据安全</h3><p>超兔一体云采用全局自动权限机制，上级管理下级，同级互相隔离，助理跟随主管，老板管理全局。这种权限管理机制确保了不同岗位的员工只能访问和操作自己权限范围内的数据，保障了企业数据的安全。例如，财务岗位可以查看客户财务数据但不可查看客户详情，避免了财务数据的泄露。</p><h2>五、技术支撑提升性能</h2><h3>（一）AI 技术深度应用</h3><p>超兔一体云的 AI 能力突出，拥有 AI 智能体和 Coze 工作流，可嵌入客户视图，提供强大 AI 支持。AI 智能体可低门槛自定义，嵌入客户和行动视图，还支持嵌入式 Coze 工作流和智能体，扩展高级 AI 能力。例如，AI 可以根据客户视图数据定制销售跟单智能体，为销售人员提供个性化的销售建议；AI 还可以对电话录音进行分析，帮助销售人员了解客户需求和意向。</p><h3>（二）多端覆盖方便使用</h3><p>超兔一体云在 Web、App、小程序、客户端、RPA 插件等多端落地应用，方便不同岗位的员工在不同场景下使用。例如，外勤服务人员可以通过手机 App 进行外勤拜访记录和任务执行；管理人员可以通过 Web 端查看企业的业务数据和报表；财务人员可以通过客户端进行财务凭证的生成和管理。这种多端覆盖的方式，提高了员工的工作效率和工作便利性。</p><h3>（三）集成能力实现对接</h3><p>超兔一体云具备丰富的业务 API 和基于网页自动化的 Rpa，实现和外部 ERP、WMS 等系统的对接。与用友、金蝶等 ERP 均有较多成功对接案例。这种集成能力使得超兔一体云能够与企业现有的其他系统进行数据交互和业务协同，避免了企业信息孤岛的问题，提高了企业的整体运营效率。</p><h2>六、总结</h2><p>超兔一体云通过核心架构的设计、数据流转的实现、岗位适配的保障以及技术支撑的提升，为市场、销售、采购、仓库、财务、客服、外勤服务、生产等各岗位提供了数据一体化的业务管理平台。这种一体化的业务管理平台，帮助企业实现了业务流程的优化和数据的高效管理，提升了企业的竞争力和盈利能力，为企业的数字化转型提供了有力支持。</p>]]></description></item><item>    <title><![CDATA[中国CRM在渠道管理方面，谁家做的好？ ]]></title>    <link>https://segmentfault.com/a/1190000047394795</link>    <guid>https://segmentfault.com/a/1190000047394795</guid>    <pubDate>2025-11-13 13:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>当下，渠道管理已经成为众多企业成功的关键驱动力，企业对于渠道的协同效率和体验，渠道的全面赋能，渠道的扁平化管理关注程度越来越高。综合来看，CRM在渠道管理方面的重要性主要有以下几点：<br/>1.统一视图：CRM系统可以为企业提供统一的客户视图，包括渠道合作伙伴和终端客户。这有助于企业更好地理解客户行为和需求，从而制定更有效的渠道策略。<br/>2.渠道绩效监控与激励：通过CRM系统，企业可以监控和评估渠道合作伙伴的绩效，包括销售额、市场份额、客户满意度等关键指标，以确保渠道策略的有效执行，并帮助企业设计和实施渠道激励计划，通过奖励和激励机制来提高渠道合作伙伴的积极性和忠诚度。<br/>3.渠道冲突管理与优化：CRM系统可以帮助企业识别和管理渠道冲突，比如价格战、区域冲突等，通过有效的沟通和协调来维护渠道的稳定和健康。同时，CRM提供数据分析和报告功能，帮助企业识别渠道覆盖的空白区域和潜在增长机会，从而优化渠道布局。<br/>4.客户体验一致性：CRM系统确保不同渠道的客户体验保持一致性，无论是线上还是线下，都能提供无缝的购买体验。<br/>5.库存管理：CRM系统可以与库存管理系统集成，帮助渠道合作伙伴有效管理库存，减少库存积压和缺货风险。<br/>6.订单管理：CRM系统可以简化订单处理流程，提高订单处理的效率和准确性，减少错误和延误。<br/>7.客户反馈收集：CRM系统可以收集来自不同渠道的客户反馈，帮助企业及时响应客户需求和问题，提高客户满意度。<br/>8.培训和支持：CRM系统可以提供在线培训和支持资源，帮助渠道合作伙伴提高销售和产品知识，提升销售能力。<br/>9.合规性管理：CRM系统可以帮助企业确保渠道活动符合法律法规和公司政策，减少合规风险。<br/>CRM系统在渠道管理中的重要性体现在提高效率、增强客户满意度、优化渠道布局、提升销售绩效等多个方面，是企业渠道管理不可或缺的工具。那什么样的CRM可以满足以上要求，成功帮助厂商管理好经销商，提升经销商的业绩，提升客户满意度呢？</p><p>据悉，中国CRM领导品牌销售易的PRM伙伴云产品去年一年实现了96%的高增长。通过本土化的应用创新，销售易帮助企业构建一站式的渠道协同云平台，形成“厂商搭台、渠道唱戏”的协同模式，这样的模式下，让渠道的活力被充分激发，实现厂商和渠道的共赢。这里我们不重点说伙伴云产品能力，而是通过一个个客户案例来说明一下销售易CRM在渠道经商上方面的管理。</p><p>博世X销售易：构建统一的Dealer Portal，提升数据透明度与经销商体验</p><p>业务挑战：<br/>博世对经销商强管控，经销商的实时业绩完成情况会影响预算、返利、营销活动的动态调整，经销商对第一时间查看这些业务数据并进行分析有较强的诉求，而之前数据分散在多个平台，经销商需要登录多套系统来查看这些数据，给经销商带来了操作上的复杂性和不便，而且大部分信息需要渠道经理线下同步给经销商，导致经销商体验差。</p><p>解决之道：<br/>搭建统一的Dealer Portal为经销商提供实时数据看板，经销商可以在门户清晰、透明的查看实时业绩达成、返利等数据；并且，通过在门户整合公告、知识库、协同工具，赋能伙伴，经销商能够实时查看合作协议、市场活动计划、返利发放进度等信息，提高数据的透明度，提升经销商使用体验，助其提升销售业绩。</p><p>海能达X销售易：个性化经销商门户与多级订货商城，助力全球化业务协同</p><p>海外业务挑战：<br/>面向新兴市场，经销商弱管控，很多经销商都是竞品曾经的经销商，如何更好的赋能和服务这些经销商，让他们更便捷的和海能达进行业务协同，更容易的进行营销，带来更多的业绩，是摆在海能达面前的一个课题。而且，不同国家和地区的经销商，业务差异、IT 意识、操作习惯、管理习惯都不甚相同，需要为提供个性化的内容、服务和体验。</p><p>解决之道：<br/>对于出海业务，面向不同国家和地区的经销商，基于销售易CRM打造个性化的经销商门户：<br/>✓整合线索、营销日历、市场基金、营销日历到门户上，经销商可以便捷、高效的承接线索、参加市场活动并进行市场基金的申请和报销；为经销商提供营销内容赋能和联合营销工具，经销商可以便捷的实现本地化数字化营销。<br/>✓经销商通过门户实现自主报价和下单，并在门户上为经销商展现了实时业务数据看板，经销商可以高效自主订货，业务情况通过实时数据看板一目了然。<br/>✓在经销商门户整合认证中心、培训中心，使经销商能够一站式在线完成协议签订、资格认证，并方便的获取产品及各种政策知识，进行培训。</p><p>国内业务挑战：<br/>多级代理商体系，业务模式较为复杂，代理商直接业务往来线下为主，业务协同效率较低，缺乏管控。面向代理商提供的系统和数字化工具体验不佳，代理商使用率低。</p><p>解决之道<br/>对于国内业务，在销售易的帮助下，整合渠道伙伴门户和多级订货商城到统一门户小程序，多级经销商可以通过小程序便捷的访问统一门户小程序，实现多级经销商体系的自主订货商城，打通订单流线上化，极大提升了多级经销商业务协同的效率。</p><p>江森约克x销售易：打造经销商自助门户，提升线索跟进效率</p><p>业务挑战：<br/>江森约克每年会在各大广告平台投放营销广告，收集线索，这些线索会分发给各区域的经销商进行跟进转化，如何让经销商第一时间领取分发给自己的线索，并高效的管理线索跟进状态，避免出现因为约克和经销商协同效率问题造成线索热度降低跟进不力的情况，是约克重点要解决的问题。</p><p>解决之道：<br/>销售易帮助江森打造经销商的自助门户，通过门户，经销商可以第一时间收到线索分发的通知，到门户查看线索并进行跟进，及时、便利的管理线索跟进的状态，极大的提升了经销商线索跟进的效率和线索转化率。</p><p>华大基因x销售易：渠道管理升级，灵活连接所有经销商，高效赋能</p><p>业务挑战：<br/>华大基因在渠道管理中面临两大难题，一是渠道政策的传达效率不高，导致代理商对最新政策了解不及时；二是渠道培训资料的分享方式不够高效，影响了代理商的学习和应用效果。这些问题直接影响了代理商的业务能力和订单销售额。</p><p>解决之道：<br/>通过销售易伙伴云为代理商建设自助门户，在门户里整合了【公告】系统，确保渠道政策能够及时、准确地传达给每一位代理商，让代理商能够迅速了解并执行最新政策。同时，在门户里整合了【知识库】平台，集中存储和分享渠道培训资料，使代理商能够方便地获取所需信息，提高学习效率。通过这两个措施，华大基因极大提升了代理商的业务能力，提高订单销售额，实现渠道的高效管理和业务增长。</p><p>美巢x销售易：经销商商城小程序赋能全场景在线自主订货，提升管理效率<br/>业务挑战：<br/>原有定制的经销商商城，仅支持下单、促销和SAP对接；但是涉及意向单（寄存订单）等场景，经销商没有账户信息，不能实时知道自己还有多少已付款、未发运的货物。</p><p>解决之道：<br/>销售易全新升级经销商商城小程序，支持一客一价、促销活动、送达方校验、装运校验、积分券使用控制、优惠分摊、部分支付、取消订单控制、物流跟踪查询等，真正实现和支撑了经销商在线自主订货的全场景。</p>]]></description></item><item>    <title><![CDATA[C# 的异步编程 兔子码农 ]]></title>    <link>https://segmentfault.com/a/1190000047394229</link>    <guid>https://segmentfault.com/a/1190000047394229</guid>    <pubDate>2025-11-13 12:12:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>使用 async 和 await 进行异步编程</h2><p>任务异步编程（TAP）模型在典型的异步编程之上提供了一层抽象。在该模型中，您像往常一样编写代码，将其视为一系列语句。不同之处在于，在编译器处理每个语句以及开始处理下一条语句之前，您可以以任务为基础的方式阅读您的代码。为了实现这一模型，编译器会对每个任务执行许多转换。某些语句可以启动工作并返回一个表示正在进行的工作的 Task 对象，而编译器必须解决这些转换。任务异步编程的目标是使代码看起来像一系列语句，但执行顺序更为复杂。执行基于外部资源分配，并在任务完成时停止。</p><p>异步编程模型与人们为包含异步任务的流程下达指令的方式类似。本文通过一个关于制作早餐的示例来说明，如何利用 “async” 和 “await” 关键字使对包含一系列异步指令的代码进行推理变得更加容易。制作早餐的指令可以以列表的形式给出：</p><ol><li>充 n 杯奶粉。</li><li>加热平底锅，然后煎 n 个鸡蛋。</li><li>煎 n 个馒头片。</li><li>煎 n 个牛排。</li><li>倒 n 杯白开水（与奶粉同）。</li></ol><p>如果您有烹饪经验，您可能会分步完成这些步骤。您先预热平底锅来煎鸡蛋，同时另一个平底锅煎牛排。您把奶粉加入热水，同时开始煎鸡蛋、煎牛排。在每个步骤的过程中，您先启动一项任务，然后转到其他已准备好让您关注的任务上。</p><p>准备早餐就是一个很好的异步工作示例，这种工作并非并行进行。一个人（或一个线程）可以完成所有的任务。一个人可以异步地准备早餐，即在前一项任务未完成之前就开始进行下一项任务。每个烹饪任务都会自行推进，而不管是否有人员在实时监督这个过程。比如，你一加热煎锅准备煎鸡蛋，就可以开始煎牛排了。等牛排开始烹饪之后，就可以把下一杯牛奶放进热水器里了。</p><p>对于并行算法而言，你需要多个人来负责烹饪（或者多个线程）。一个人负责煮鸡蛋，另一个人负责煮薯饼，依此类推。每个人专注于自己特定的任务。每个正在烹饪的人（或者每个线程）都会同步等待当前任务完成：薯饼准备好翻面了，面包准备好在烤面包机里弹起来了，等等。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047394232" alt="" title=""/><br/>考虑将上述相同的同步指令以 C# 代码语句的形式进行表述：</p><pre><code class="C#">List&lt;LEI奶&gt; NNs = FF泡奶 ( 10 , 2 );
foreach ( LEI奶 n in Nais )
    {
    Console . WriteLine ( $"奶煮好了！{n}" );
    }

List &lt; LEI煎鸡蛋 &gt; JJDs = FF煎蛋 ( 3 );
Console . WriteLine ( $"鸡蛋煎好了 {JJDs . Count} 个！" );

static List &lt; LEINai &gt; FF泡奶 ( double 奶粉 , int 杯 )
    {
    List &lt; LEI奶 &gt; lbnf = [ ];
    Console . WriteLine ( "泡奶粉中……" );
    double NF每杯 = 咖啡粉 / 杯;
    for ( int i = 0 ; i &lt; 杯 ; i++ )
        {
        Task . Delay ( 5000 ); // 2 秒冲水，3 秒搅拌
        lbnf . Add ( new LEI奶粉 ( NF每杯 ) );
        }
    return lbnf;
    }

static Task &lt; List &lt; LEI煎鸡蛋 &gt; &gt; FF煎蛋 ( int 生鸡蛋 )
    {
    List &lt; LEI煎鸡蛋 &gt; lbjjd = [ ];
    Console . WriteLine ( "煎鸡蛋中……" );
    while ( 生鸡蛋 &gt; 0 )
        {
        if ( 生鸡蛋 == 1 )
            {
            Task . Delay ( 5000 ) ;
            lbjjd . Add ( new LEI煎鸡蛋 ( ) );
            生鸡蛋 -= 1;
            }
        else // 一锅最多煎两个鸡蛋
            {
            Task . Delay ( 7000 );
            lbjjd . Add ( new LEI煎鸡蛋 ( ) );
            lbjjd . Add ( new LEI煎鸡蛋 ( ) );
            生鸡蛋 -= 2;
            }
        }
    return lbjjd;
    }</code></pre><p>如果按照计算机的处理方式来理解这些指令，准备一顿早餐大约需要 22 秒钟（这是假想的，你得真的做熟了……）。这个时间是各项任务所需时间的总和。计算机会逐句等待每一条指令完成，直到所有工作都完成之后，才会继续执行下一条任务指令。这种方法可能会耗费大量时间。在准备早餐的例子中，计算机的方法会做出一份不令人满意的早餐。在同步列表中的后续任务，比如煎牛排和煎鸡蛋，要等到前面的任务完成之后才会开始。有些食物在早餐准备好可以食用之前就已经变凉了。</p><p>如果希望计算机以异步方式执行指令，就必须编写异步代码。在编写客户端程序时，您希望用户界面能够对用户输入做出响应。您的应用程序不应在从网络下载数据时冻结所有交互操作。在编写服务器程序时，您也不希望阻塞那些可能正在处理其他请求的线程。如果存在异步替代方案却使用同步代码，会降低您以更低成本进行扩展的能力。因为阻塞的线程会消耗资源。</p><p>成功的现代应用程序需要使用异步代码。若没有语言支持，编写异步代码就需要使用回调函数、完成事件或其他会使代码原本意图变得模糊的手段。同步代码的优势在于其逐步执行的特性，这使得代码易于浏览和理解。而传统的异步模型则迫使您关注代码的异步特性，而非其基本操作。</p><h3>不要阻塞，而是等待</h3><p>之前的代码揭示了一种不良的编程习惯：编写同步代码来执行异步操作。这段代码会使当前线程停止执行任何其他工作。在有运行任务的情况下，代码不会中断该线程。这种模式的结果类似于你把鸡蛋放进煎锅后一直盯着它。你忽略任何中断，并且直到煎蛋好了才开始其他任务。你不会从冰箱里拿出牛排和馒头片去煎馒头片。你可能会错过看到炉灶起火的情况。你希望既能煎鸡蛋又能煎牛排。你的代码也是如此。</p><p>您可以先更新代码，使线程在任务运行期间不会阻塞。“await” 关键字提供了一种非阻塞的方式来启动任务，然后在任务完成时继续执行。早餐代码的一个简单异步版本如下所示：</p><pre><code class="C#">List&lt;LEI奶粉&gt; CFs = await FFY泡牛奶 ( 10 , 2 );
foreach ( LEI奶粉 k in CFs )
    {
    Console . WriteLine ( $"牛奶煮好了！{k}" );
    }
List &lt; LEI煎鸡蛋 &gt; JJDs = await FFY煎蛋 ( 3 );
Console . WriteLine ( $"鸡蛋煎好了 {JJDs . Count} 个！" );

static async Task &lt;List &lt;LEI奶粉&gt; &gt; FFY泡牛奶 ( double 奶粉 , int 杯 )
    {
    List &lt; LEI奶粉 &gt; lbcf = [ ];
    Console . WriteLine ( "泡牛奶中……" );
    double CF每杯 = 奶粉 / 杯;
    for ( int i = 0 ; i &lt; 杯 ; i++ )
        {
        await Task . Delay ( 5000 ); // 2 秒冲水，3 秒搅拌
        lbcf . Add ( new LEI奶粉 ( CF每杯 ) );
        }
    return lbcf;
    }

static async Task &lt;List &lt; LEI煎鸡蛋 &gt; &gt; FFY煎蛋 ( int 生鸡蛋 )
    {
    List &lt; LEI煎鸡蛋 &gt; lbjjd = [ ];
    Console . WriteLine ( "煎鸡蛋中……" );
    while ( 生鸡蛋 &gt; 0 )
        {
        if ( 生鸡蛋 == 1 )
            {
            await Task . Delay ( 5000 ) ;
            lbjjd . Add ( new LEI煎鸡蛋 ( ) );
            生鸡蛋 -= 1;
            }
        else
            {
            await Task . Delay ( 7000 );
            lbjjd . Add ( new LEI煎鸡蛋 ( ) );
            lbjjd . Add ( new LEI煎鸡蛋 ( ) );
            生鸡蛋 -= 2;
            }
        }
    return lbjjd;
    }

public class LEI牛奶 ( double 每杯含量 )
    {
    string ZFC浓淡 =&gt; FF浓淡 ( 每杯含量 );
    string FF浓淡 ( double 每杯含量 )
        {
        switch ( 每杯含量 )
            {
            case &lt;= 0:
                return ( $"白开水" );
            case &lt;= 2:
                return ( $"淡" );
            case &lt;= 6:
                return ( $"浓" );
            default:
                return ( $"泡不开" );
            }
        }

public class LEI煎鸡蛋
    {
    }</code></pre><p>该代码会更新 FF煎蛋、FF泡奶粉 这两个方法的原始主体，使其分别返回类型为 LEI煎鸡蛋、LEI牛奶 的任务对象。更新后的方法名称都带有 “FFY” 后缀：FFY煎蛋、FFY泡牛奶。主方法返回任务对象，尽管它没有返回表达式，这是设计上的要求。</p><p><strong>注意：</strong>更新后的代码尚未充分利用异步编程的关键特性，这可能会缩短完成时间。该代码处理任务所花费的时间与最初的同步版本大致相同。</p><p>让我们将早餐的例子应用到更新后的代码中。在鸡蛋或牛排正在烹饪的过程中，该线程不会被阻塞，但代码也不会在当前任务完成之前启动其他任务。您仍然将馒头片放入煎锅中，然后盯着煎锅直到馒头片煎好，但现在您能够应对干扰了。在多个订单同时进行的餐厅里，厨师可以在某道菜正在烹饪时开始新的订单。</p><p>在更新后的代码中，负责准备早餐的线程在等待任何尚未完成的已启动任务时不会被阻塞。对于某些应用程序而言，这一改动就是您所需要的一切。您可以让您的应用程序在从网络下载数据的同时支持用户交互。在其他情况下，您可能希望在等待前一个任务完成的同时启动其他任务。</p><h3>同时启动任务</h3><p>对于大多数操作而言，您希望立即启动多个独立的任务。每当一个任务完成时，您就会启动其他准备就绪的任务。当您将这种方法应用于早餐的例子中时，您能够更快地准备早餐。而且所有准备工作都能在相近的时间内完成，这样您就能享用热乎乎的早餐了。</p><p>System . Threading . Tasks . Task 类及其相关类型是您可以用来将这种思维方式应用于正在进行的任务的类。这种方法使您能够编写更贴近实际生活中的早餐制作方式的代码。您同时开始烹饪鸡蛋、土豆丝和馒头片。由于每种食物都需要进行操作，您会将注意力转向该任务，处理该操作，然后等待需要您关注的其他事情。</p><p>在您的代码中，您会启动一个任务，并持有代表该工作的 Task 对象。您会通过调用任务的 await 方法来延迟对工作的处理，直到结果准备好为止。</p><p>将这些更改应用到早餐代码中。第一步是当操作开始时就存储操作任务，而不是使用 await 表达式：</p><pre><code class="C#">static ( List &lt; LEI煎馒头片 &gt; 煎好的 , int 剩余馒头片 , int 剩余鸡蛋 ) FF煎馒头片 ( int 生馒头片 , int 生鸡蛋 , MJ熟度 熟度 )
    {
    List&lt;LEI煎馒头片&gt; 结果 = [ ];
    int 剩余馒头 = 生馒头片;
    int 剩余鸡蛋 = 生鸡蛋;

    int 目标耗时 = 熟度 switch
        {
            MJ熟度 . 熟 =&gt; 5,
            MJ熟度 . 过熟 =&gt; 6,
            _ =&gt; 0 // 生的不用等，直接算没煎好
            };

    Console . WriteLine ( "开始煎馒头片……" );

    // 循环煎，直到不符合条件（条件是一锅可以煎 5 片，或者 4 片，占用 1 个鸡蛋）
    while ( true )
        {
        // 退出条件：鸡蛋没了，或者剩余馒头片 &lt; 4
        if ( 剩余鸡蛋 &lt;= 0 || 剩余馒头 &lt; 4 )
            {
            break;
            }

        // 每锅每个鸡蛋最多煎 5 片，最少 4 片（剩下的可能 4 片）
        int 本次煎的片数 = Math . Min ( 剩余馒头 , 5 ); // 不超过剩余馒头，最多 5 片
        bool 煎熟了 = 目标耗时 &gt;= 5; // 不足 5 秒算不熟


        if ( 煎熟了 )
            {
            Console . WriteLine ( $"煎 {本次煎的片数} 片，等待 {目标耗时} 秒……" );
            Thread . Sleep ( 目标耗时 * 1000 ); // 真实等待
            }
        else
            {
            Console . WriteLine ( $"煎 {本次煎的片数} 片，但时间不足 5 秒，没煎好……" );
            }

        剩余鸡蛋--;
        剩余馒头 -= 本次煎的片数;
        结果 . Add ( new LEI煎馒头片 (
            煎熟了 ? 熟度 : MJ熟度 . 生 ,
            本次煎的片数 ,
            煎熟了 ? 目标耗时 : 0
        ) );
        Console . WriteLine ( $"完成！状态：{结果 . Last ( ) . 熟度描述}\n" );
        }

    Console . WriteLine ( $"=== 最终剩余：馒头 {剩余馒头} 片，鸡蛋 {剩余鸡蛋} 个 ===" );
    return ( 结果 , 剩余馒头 , 剩余鸡蛋 );
    }

public class LEI煎馒头片
    {
    // 属性：熟度、实际煎了多少片
    public string 熟度描述
        {
        get;
        }
    public int 实际煎的片数
        {
        get;
        }

    public int 实际耗时
        {
        get;
        }

    // 构造函数：传入熟度和煎的片数
    public LEI煎馒头片 ( MJ熟度 熟 , int 片数 , int 耗时 )
        {
        熟度描述 = 熟 switch
            {
                MJ熟度 . 熟 =&gt; "正常（5秒）",
                MJ熟度 . 过熟 =&gt; "有点糊（6秒）",
                _ =&gt; "没煎好（时间不够）"
                };
        实际煎的片数 = 片数;
        实际耗时 = 耗时;
        }
    }

public enum MJ熟度
        {
        生 = 255,
        熟 = 0,
        过熟 = 1,
        }</code></pre><p>这些修改并不能让你更快地准备好早餐。一旦任务开始，“await” 表达式就会应用于所有任务。接下来的步骤是将烤馒头片和煎鸡蛋的 “await” 表达式移到方法的末尾，也就是在准备早餐之前进行操作：</p><pre><code class="C#">DateTime QI = DateTime . Now;
// 1. 调用异步方法，获取任务（无需 as 转换）
Task &lt; List &lt; LEI牛奶 &gt;? &gt; 牛奶任务 = LEI牛奶 . FF泡牛奶 ( 10 , 2 );
Task &lt; List &lt; LEI煎馒头片 . LEI锅次信息 &gt;? &gt; 煎馒头片任务 = LEI煎馒头片 . FF煎馒头片 ( 14 , 4 , MJ熟度 . 熟 );
Task &lt; List &lt; LEI煎牛排 . LEI锅次信息 &gt;? &gt; 煎牛排任务 = LEI煎牛排 . FF煎牛排 ( 4 , MJ熟度 . 七成熟 );
Task &lt; List &lt; LEI牛奶 &gt;? &gt; 白开水任务 = LEI牛奶 . FF泡牛奶 ( 0 , 2 );
// 2. 等待任务完成，拿到实际的牛奶集合（关键步骤）
List &lt; LEI牛奶 &gt; ? 所有牛奶 = 牛奶任务 . Result ?? [ ]; // 同步等待（控制台可用）
List &lt; LEI煎馒头片 . LEI锅次信息 &gt; ? 所有熟煎馒头片 = 煎馒头片任务 . Result ?? [ ];
List &lt; LEI煎牛排 . LEI锅次信息 &gt; ? 所有熟煎牛排 = 煎牛排任务 . Result ?? [ ];
List &lt; LEI牛奶 &gt; ? 所有白开水 = 白开水任务 . Result ?? [ ]; // 同步等待（控制台可用）
// 或在 async 方法中用：List &lt; LEI牛奶 &gt; 所有牛奶 = await 牛奶任务;

Console . WriteLine ( "\n我们的早餐：" );
// 3. 遍历集合，输出具体信息（建议重写 ToString，或用属性）
foreach ( LEI牛奶 单杯牛奶 in 所有牛奶 )
    {
    // 输出浓淡信息（用已有的 ZFC浓淡 属性）
    Console . WriteLine ( $"奶泡好了！这杯是 {单杯牛奶}～" );
    }
foreach ( LEI煎馒头片 . LEI锅次信息 Guo in 所有熟煎馒头片 )
    {
    Console . WriteLine ( $"馒头片煎好了！这锅是 {Guo}" );
    }
foreach ( LEI煎牛排 . LEI锅次信息 Guo in 所有熟煎牛排 )
    {
    Console . WriteLine ( $"牛排煎好了！这锅是 {Guo}" );
    }
foreach ( LEI牛奶 单杯水 in 所有白开水 )
    {
    // 输出浓淡信息（用已有的 ZFC浓淡 属性）
    Console . WriteLine ( $"热水来了！这杯是 {单杯水}～" );
    }
DateTime JS = DateTime . Now;
TimeSpan Shi = JS - QI;
Console . WriteLine ( $"\n共用时 {Shi . Seconds} 秒" );



public class LEI牛奶 ( double 每杯含量 )
    {
    string ZFC浓淡 =&gt; FF浓淡 ( 每杯含量 );
    static string FF浓淡 ( double 每杯含量 )
        {
        return 每杯含量 switch
            {
                &lt;= 0 =&gt; ( $"清" ),
                &lt;= 2 =&gt; ( $"淡" ),
                &lt;= 6 =&gt; ( $"浓" ),
                _ =&gt; ( $"泡不开" ),
                };
        }

    public static async Task &lt; List &lt; LEI牛奶 &gt;? &gt; FF泡牛奶 ( int 奶粉数 , int 杯 )
        {
            {
            List &lt; LEI牛奶 &gt; 泡好的牛奶 = [ ]; // 用于存储生成的牛奶实例
            Console . WriteLine ( $"开始{( 奶粉数 &lt;= 2 ? "倒水" : "泡牛奶" )}了：" );
            if ( 杯 &lt;= 0 )
                {
                Console . WriteLine ( "杯数不能为 0 或负数！" );
                return null; // 返回空集合
                }

            double SJD杯量 = (double)奶粉数 / 杯;

            if ( SJD杯量 &gt; 6 )
                {
                Console . WriteLine ( "泡不开！" );
                return null; // 返回空集合
                }

            for ( int i = 0 ; i &lt; 杯 ; i++ )
                {
                int sj;
                if ( SJD杯量 &lt;= 2 )
                    sj = 3000;
                else
                    sj = 5000;
                await Task . Delay ( sj );
                LEI牛奶 新牛奶 = new ( SJD杯量 ); // 每杯牛奶创建一个实例
                泡好的牛奶 . Add ( 新牛奶 ); // 加入集合
                Console . WriteLine ( $"{i + 1} 杯 {( FF浓淡 ( SJD杯量 ) == "清" ? "白开水。" : $"{FF浓淡 ( SJD杯量 )} 牛奶。" )}" );
                }

            return 泡好的牛奶; // 返回所有泡好的牛奶集合
            }
        }
    public override string ToString ( )
        {
        if ( 每杯含量 &gt;= 2 )
            return $"{每杯含量} 单位的 {ZFC浓淡} 牛奶";
        else
            return "白开水";
        }
    }

public enum MJ熟度
    {
    熟 = 1,
    过熟 = 2,
    半熟 = 3, // 煎牛排
    七成熟 = 4, // 煎牛排
    }

public class LEI煎馒头片 ( MJ熟度 熟度 , int 锅次 )
    {
    public MJ熟度 当前熟度 { get; set; } = 熟度;
    public int 所在锅次 { get; set; } = 锅次;
    public int 片数 { get; set; }

    // 新增：记录每锅的信息（锅次、片数、熟度）
    public class LEI锅次信息 ( int 锅次 , int 片数 , MJ熟度 熟度 )
        {
        public int 锅次 { get; set; } = 锅次;
        public int 片数 { get; set; } = 片数;
        public MJ熟度 熟度 { get; set; } = 熟度;

        // 重写ToString，直接输出整锅信息
        public override string ToString ( )
            {
            string 熟度描述 = 熟度 switch
                {
                    MJ熟度.熟 =&gt; "煎熟",
                    MJ熟度.过熟 =&gt; "过熟",
                    _ =&gt; "不符合要求"
                };
            return $"第 {锅次} 锅的 {片数} 片 {熟度描述} 的馒头片";
            }
        }

    public static async Task &lt; List &lt; LEI锅次信息 &gt;? &gt; FF煎馒头片 ( int 生馒头片 , int 生鸡蛋 , MJ熟度 熟度 )
        {
        int sheng = 生馒头片 , jd = 生鸡蛋 , GC = 1;
        int sj = 熟度 == MJ熟度 . 熟 ? 5000 : 7000;
        List &lt; LEI锅次信息 &gt; GCs = [ ];
        if ( sheng &lt;= 3 || jd &lt;= 0 ) { ArgumentOutOfRangeException CLYC = new ( "材料不全，生馒头片必须至少 4 片，生鸡蛋至少 1 个" ); throw CLYC; }
        List &lt; LEI煎馒头片 &gt; LBKM = [ ];
        Console . WriteLine ( $"开始煎馒头片啦：～ 用了 {生鸡蛋} 个鸡蛋，共 {生馒头片} 片" );
        while ( jd &gt; 0 &amp;&amp; sheng &gt;= 4 )
            {
            // 决定本锅煎几片：够 5 片就煎 5 片，否则煎 4 片（但不能超过剩余量）
            int SL = sheng &gt;= 5 ? 5 : 4;

            Console . WriteLine ( $"第 {GC} 锅开始煎馒头片（{SL} 片），需要 {sj / 1000} 秒～" );
            await Task . Delay ( sj ); // 模拟一锅的煎制时间

            // 记录本锅次信息
            GCs . Add ( new LEI锅次信息 ( GC , SL , 熟度 ) );

            // 记录本锅煎好的馒头片
            for ( int i = 0 ; i &lt; SL ; i++ )
                {
                LBKM . Add ( new LEI煎馒头片 ( 熟度 , GC ) );
                }

            // 更新剩余材料
            jd --;
            sheng -= SL;
            Console . WriteLine ( $"第 {GC} 锅馒头片完成！用了 1 个蛋，煎了 {SL} 片，剩余：{sheng} 片，{jd} 个蛋" );

            GC ++;
            }

        Console . WriteLine ( $"共煎完馒头片 {GCs . Sum ( g =&gt; g . 片数 )} 片，用了 {GCs . Count} 个蛋" );

        return GCs;
        }
    }

public class LEI煎牛排 ( MJ熟度 熟度 , int 锅次 )
    {
    public MJ熟度 当前熟度 { get; set; } = 熟度;
    public int 所在锅次 { get; set; } = 锅次;
    public int 片数 { get; set; }

    // 记录每锅的信息（锅次、片数、熟度）
    public class LEI锅次信息 ( int 锅次 , int 片数 , MJ熟度 熟度 )
        {
        public int 锅次 { get; set; } = 锅次;
        public int 片数 { get; set; } = 片数;
        public MJ熟度 熟度 { get; set; } = 熟度;

        // 重写ToString，直接输出整锅信息
        public override string ToString ( )
            {
            string 熟度描述 = 熟度 switch
                {
                    MJ熟度 . 熟 =&gt; "煎熟",
                    MJ熟度 . 过熟 =&gt; "过熟",
                    MJ熟度 . 半熟 =&gt; "半熟",
                    MJ熟度 . 七成熟 =&gt; "七成熟",
                    _ =&gt; "没煎熟",
                    };
            return $"第 {锅次} 锅的 {片数} 片 {熟度描述} 的牛排";
            }
        }

    public static async Task &lt; List &lt; LEI锅次信息 &gt;? &gt; FF煎牛排 ( int 生牛排 , MJ熟度 熟度 )
        {
        int sheng = 生牛排 , GC = 1;
        int sj = 熟度 switch
            {
                MJ熟度.熟 =&gt; 5000,
                MJ熟度.过熟 =&gt; 7000,
                MJ熟度.半熟 =&gt; 2500,
                MJ熟度.七成熟 =&gt; 3500,
                _ =&gt; 0 // 生的
            };
        List &lt; LEI锅次信息 &gt; GCs = [ ];
        List &lt; LEI煎牛排 &gt; LBNP = [ ];
        if ( sheng &gt;= 1 )
            Console . WriteLine ( $"开始煎牛排啦：～ 共 {生牛排} 片" );
        else
            Console . WriteLine ( "没有生牛排了……" );
            
        while ( sheng &gt;= 1 )
            {
            // 决定本锅煎几片：够 2 片就煎 2 片，否则煎 1 片（但不能超过剩余量）
            int SL = sheng &gt;= 2 ? 2 : 1;

            Console . WriteLine ( $"第 {GC} 锅牛排开始煎（{SL} 片），需要 {( double ) sj / 1000} 秒～" );
            await Task . Delay ( sj ); // 模拟一锅的煎制时间

            // 记录本锅次信息
            GCs . Add ( new LEI锅次信息 ( GC , SL , 熟度 ) );

            // 记录本锅煎好的牛排
            for ( int i = 0 ; i &lt; SL ; i++ )
                {
                    LBNP . Add ( new LEI煎牛排 ( 熟度 , GC ) );
                }

            // 更新剩余材料
            sheng -= SL;
            Console . WriteLine ( $"第 {GC} 锅牛排完成！煎了 {SL} 片，剩余：{sheng} 片" );

            GC++;
            }

        Console . WriteLine ( $"共煎完牛排 {GCs . Sum ( g =&gt; g . 片数 )} 片" );

        return GCs;
        }
    }</code></pre><p>现在您享用的是一份异步准备的早餐，其准备时间约为 15 秒。总烹饪时间得以缩短，这是因为所有任务可以同时进行。</p><table><thead><tr><th>步骤</th><th>操作</th><th>状态反馈</th></tr></thead><tbody><tr><td>1</td><td>泡牛奶（分浓淡 / 白开水）</td><td>开始泡牛奶 / 倒水 → 每杯完成提示 → 全部泡好汇总</td></tr><tr><td>2</td><td>煎馒头片（分锅，每锅用蛋）</td><td>第 1 锅开始（5 片） → 第 1 锅完成（用 1 蛋） → 第 2 锅开始（5 片） → 第 2 锅完成（用 1 蛋） → 第 3 锅开始（4 片） → 第 3 锅完成（用 1 蛋） → 全部煎完汇总</td></tr><tr><td>3</td><td>煎牛排（分锅，定熟度）</td><td>第 1 锅开始（2 片，七成熟） → 第 1 锅完成 → 第 2 锅开始（2 片，七成熟） → 第 2 锅完成 → 全部煎完汇</td></tr></tbody></table><p>该代码更新改进了准备工作流程，通过缩短烹饪时间来实现这一目标，但同时也引入了缺陷，导致鸡蛋和牛排可能烧焦了。您一次性启动所有异步任务。只有在需要结果时才等待每个任务。该代码可能类似于在 Web 应用程序中执行的程序，该程序向不同的微服务发出请求，然后将结果组合成一个页面。您立即发出所有请求，然后对所有这些任务应用 await 表达式，并构建网页。</p><h3>通过任务来支持组合</h3><p>之前的代码修订使得同时准备早餐的所有环节都已就绪，除了吐司。制作吐司的过程是由一个异步操作（烤面包）与一系列同步操作（在吐司上涂抹黄油和果酱）组合而成的。这个示例说明了异步编程中一个重要的概念：</p><p><strong>重要事项：</strong>一个先进行异步操作随后再进行同步操作的过程也是一个异步操作。换句话说，如果操作的任何一部分是异步的，那么整个操作就是异步的。</p><p>在之前的更新内容中，您已经了解了如何使用 Task 或 Task &lt; TResult &gt; 对象来保存正在执行的任务。在使用每个任务的结果之前，您需要先等待该任务完成。接下来的步骤是创建能够代表其他工作组合的方法。在准备早餐之前，您需要先等待代表将面包烤好（即准备好面包）的任务完成，然后再涂抹黄油和果酱。</p><p>您可以使用以下代码来表示这项工作：</p><pre><code class="C#">static async Task &lt; LEI吐司 &gt; FF制作吐司 ( int 面包 )
    {
        var TSs = await FFY吐司面包 ( 面包 );
        FF黄油 ( TSs );
        FF果酱 ( TSs );
    }</code></pre><p>“FF制作吐司” 方法在其签名中带有 “async” 修饰符，这向编译器表明该方法包含一个 “await” 表达式以及包含异步操作。该方法代表的是将面包烤好、涂抹黄油和果酱的整个过程。该方法返回一个 “Task &lt; LEI吐司 &gt;” 对象，该对象代表了这三项操作的组合。</p><p>修改后的主代码块现在看起来是这样的：</p><pre><code class="C#">……
    var TSs = await 吐司任务;
    Console . WriteLine ( "吐司准备好了" );
……</code></pre><p>这段代码更改展示了处理异步代码的一种重要技巧。您通过将操作分离到一个新的方法中来构建任务，该方法会返回一个任务。您可以决定何时等待该任务。您还可以同时启动其他任务。</p><h3>处理异步异常</h3><p>到目前为止，您的代码默认假定所有任务都能成功完成。异步方法也会抛出异常，就像其同步版本一样。对于异常和错误处理的异步支持，其目标与一般异步支持的目标相同。最佳实践是编写看起来像一系列同步语句的代码。当任务无法成功完成时，任务会抛出异常。当将 await 表达式应用于已启动的任务时，客户端代码可以捕获这些异常。</p><p>在早餐示例中，假设在煎牛排时煎锅起火了。为模拟这一问题，您可以修改 FF煎牛排 方法，使其符合以下代码：</p><pre><code class="C#">    public static async Task &lt; List &lt; LEI锅次信息 &gt;? &gt; FF煎牛排 ( int 生牛排 , MJ熟度 熟度 )
        {
……
        if ( sheng &gt;= 1 )
            {
            Console . WriteLine ( $"开始煎牛排啦：～ 共 {生牛排} 片" );
            await Task . Delay ( 2000 );
            Console . WriteLine ( "起火了！牛排毁了！" );
            throw new InvalidOperationException ( "煎锅着火了" );
            }
        else
            Console . WriteLine ( "没有生牛排了……" );
……
        }

List &lt; LEI煎牛排 . LEI锅次信息 &gt; ? 所有熟煎牛排 = null;
try
    { 所有熟煎牛排 = 煎牛排任务 . Result ?? [ ]; }
catch ( Exception y ) { Console . WriteLine ( y . Message ); }

if ( 所有熟煎牛排 != null )
    {
    foreach ( LEI煎牛排 . LEI锅次信息 Guo in 所有熟煎牛排 )
        {
        Console . WriteLine ( $"牛排煎好了！这锅是 {Guo}" );
        }
    }
else
    {
    Console . WriteLine ( "没有成功煎好的牛排～" );
    }</code></pre><p>请注意，在煎牛排锅起火到系统检测到异常这段时间内，有相当多的任务已经完成。当一个异步运行的任务抛出异常时，该任务会被标记为故障状态。Task 对象会将抛出的异常存储在 Task . Exception 属性中。当将 await 表达式应用于故障任务时，该任务会抛出异常。</p><p>关于这一过程，有两点重要的机制需要了解：</p><ul><li>异常在故障任务中的存储方式</li><li>当代码在等待（等待操作）故障任务时，如何对异常进行解包并重新抛出</li></ul><p>当异步运行的代码抛出异常时，该异常会存储在任务对象中。Task . Exception 属性是一个 System . AggregateException 对象，因为在异步工作过程中可能会抛出多个异常。任何抛出的异常都会添加到 AggregateException . InnerExceptions 集合中。如果 Exception 属性为空，则会创建一个新的 AggregateException 对象，并且抛出的异常是该集合中的第一个元素。</p><p>对于出现故障的任务，最常见的情况是 “异常” 属性中恰好包含一个异常。当您的代码等待一个出现故障的任务时，它会重新抛出集合中第一个 “AggregateException” 对象的 “InnerExceptions” 子对象。这就是为什么示例中的输出显示的是 “System . InvalidOperationException” 对象，而不是 “AggregateException” 对象的原因。提取第一个内部异常可以使使用异步方法的操作尽可能与使用其同步版本的操作相似。当您的情况可能会产生多个异常时，您可以在代码中检查 “Exception” 属性。</p><p><strong>提示：</strong>推荐的做法是，任何参数验证异常都应从任务返回方法中同步出现。</p><p>在继续进入下一节之前，请在您的 FF煎牛排 方法中将关于起火的代码注释掉。您不想再引发新的火灾了。</p><h3>高效地应用 await 表达式到任务中</h3><p>您可以通过使用 Task 类的方法来改进前面代码末尾的一系列 await 表达式。其中一个 API 是 WhenAll 方法，它返回一个任务对象，该对象在其参数列表中的所有任务都完成时才完成。以下代码演示了此方法：</p><pre><code class="C#">DateTime QI = DateTime . Now;
// 1. 调用异步方法，获取任务（无需 as 转换）
Task &lt; List &lt; LEI牛奶 &gt;? &gt; 牛奶任务 = LEI牛奶 . FF泡牛奶 ( 10 , 2 );
Task &lt; List &lt; LEI煎馒头片 . LEI锅次信息 &gt;? &gt; 煎馒头片任务 = LEI煎馒头片 . FF煎馒头片 ( 14 , 4 , MJ熟度 . 熟 );
Task &lt; List &lt; LEI煎牛排 . LEI锅次信息 &gt;? &gt; 煎牛排任务 = LEI煎牛排 . FF煎牛排 ( 4 , MJ熟度 . 七成熟 );
Task &lt; List &lt; LEI牛奶 &gt;? &gt; 白开水任务 = LEI牛奶 . FF泡牛奶 ( 0 , 2 );
// 2. 等待任务完成，拿到实际的牛奶集合（关键步骤）
await Task . WhenAll ( 牛奶任务 , 煎馒头片任务 , 煎牛排任务 , 白开水任务 );
if ( 牛奶任务 . Result != null )
    {
    Console . WriteLine ( $"共泡了 {牛奶任务 . Result . Count} 杯牛奶。" );
    }
else
    {
    Console . WriteLine ( "没泡牛奶。" );
    }

if ( 煎牛排任务 . Result != null )
    {
    Console . WriteLine ( $"共煎了 {煎牛排任务 . Result . Count} 片牛排。" );
    }
else
    {
    Console . WriteLine ( "没煎牛排。" );
    }

if ( 煎馒头片任务 . Result != null )
    {
    Console . WriteLine ( $"共煎了 {煎馒头片任务 . Result . Count} 片馒头片。" );
    }
else
    {
    Console . WriteLine ( "没煎馒头片。" );
    }

if ( 白开水任务 . Result != null )
    {
    Console . WriteLine ( $"共倒了 {白开水任务 . Result . Count} 杯白开水。" );
    }
else
    {
    Console . WriteLine ( "没倒白开水。" );
    }

DateTime JS = DateTime . Now;
TimeSpan Shi = JS - QI;
Console . WriteLine ( $"\n共用时 {Shi . TotalSeconds} 秒" );</code></pre><p>现在，假设你只有一个煎锅，先煎完牛排，再煎馒头片：</p><pre><code class="C#">DateTime QI = DateTime . Now;
// 1. 调用异步方法，获取任务（无需 as 转换）
Task &lt; List &lt; LEI牛奶 &gt;? &gt; 牛奶任务 = LEI牛奶 . FF泡牛奶 ( 10 , 2 );
Task &lt; List &lt; LEI煎牛排 . LEI锅次信息 &gt;? &gt; 煎牛排任务 = LEI煎牛排 . FF煎牛排 ( 4 , MJ熟度 . 七成熟 );
Task &lt; List &lt; LEI牛奶 &gt;? &gt; 白开水任务 = LEI牛奶 . FF泡牛奶 ( 0 , 2 );
// 2. 等待任务完成，拿到实际的牛奶集合（关键步骤）
await Task . WhenAll ( 牛奶任务 , 煎牛排任务 , 白开水任务 );
if ( 牛奶任务 . Result != null )
    {
    Console . WriteLine ( $"共泡了 {牛奶任务 . Result . Count} 杯牛奶。" );
    }
else
    {
    Console . WriteLine ( "没泡牛奶。" );
    }

if ( 煎牛排任务 . Result != null )
    {
    Console . WriteLine ( $"共煎了 {煎牛排任务 . Result . Count} 片牛排。" );
    }
else
    {
    Console . WriteLine ( "没煎牛排。" );
    }

if ( 白开水任务 . Result != null )
    {
    Console . WriteLine ( $"共倒了 {白开水任务 . Result . Count} 杯白开水。" );
    }
else
    {
    Console . WriteLine ( "没倒白开水。" );
    }

Task &lt; List &lt; LEI煎馒头片 . LEI锅次信息 &gt;? &gt; 煎馒头片任务 = LEI煎馒头片 . FF煎馒头片 ( 14 , 4 , MJ熟度 . 熟 );
List &lt; LEI煎馒头片 . LEI锅次信息 &gt; ? 所有熟煎馒头片 = 煎馒头片任务 . Result ?? [ ];
if ( 所有熟煎馒头片 != null )
    {
    Console . WriteLine ( $"共煎了 {所有熟煎馒头片 . Count} 锅馒头片。" );
    }
else
    {
    Console . WriteLine ( "没煎馒头片。" );
    }

DateTime JS = DateTime . Now;
TimeSpan Shi = JS - QI;
Console . WriteLine ( $"\n共用时 {Shi . TotalSeconds} 秒" );</code></pre><p>另一种选择是使用 “WhenAny” 方法，该方法会返回一个 “Task &lt; Task &gt;” 对象，该对象会在其任一参数完成时完成。您可以等待返回的任务，因为您知道该任务已经完成。以下代码展示了如何使用 “WhenAny” 方法等待第一个任务完成，然后处理其结果。在处理完已完成任务的结果后，您应将该已完成任务从传递给 “WhenAny” 方法的任务列表中移除。</p><pre><code class="C#">Task &lt; List &lt; LEI牛奶 &gt;? &gt; 牛奶任务 = LEI牛奶 . FF泡牛奶 ( 10 , 2 );
Task &lt; List &lt; LEI煎牛排 . LEI锅次信息 &gt;? &gt; 煎牛排任务 = LEI煎牛排 . FF煎牛排 ( 4 , MJ熟度 . 七成熟 );
Task &lt; List &lt; LEI煎馒头片 . LEI锅次信息 &gt;? &gt; 煎馒头片任务 = LEI煎馒头片 . FF煎馒头片 ( 4 , 6 , MJ熟度 . 熟 );
Task &lt; List &lt; LEI牛奶 &gt;? &gt; 白开水任务 = LEI牛奶 . FF泡牛奶 ( 0 , 2 );

var RW早餐 = new List &lt; Task &gt; { 牛奶任务 , 煎牛排任务 , 煎馒头片任务 , 白开水任务 };
while ( RW早餐 . Count &gt; 0 )
    {
    Task RW完成 = await Task . WhenAny ( RW早餐 );
    if ( RW完成 == 牛奶任务 )
        {
        Console . WriteLine ( "牛奶泡好了！" );
        }
    else if ( RW完成 == 煎牛排任务 )
        {
        Console . WriteLine ( "牛排煎好了！" );
        }
    else if ( RW完成 == 煎馒头片任务 )
        {
        Console . WriteLine ( "馒头片煎好了！" );
        }
    else if ( RW完成 == 白开水任务 )
        {
        Console . WriteLine ( "热水倒好了！" );
        }
    await RW完成;
    RW早餐 . Remove ( RW完成 );
    }</code></pre><p>在代码片段的末尾，注意 “await RW完成;” 这一行。这一行非常重要，因为 “Task . WhenAny” 会返回一个 “Task &lt; Task &gt;” - 一个包含已完成任务的包装任务。当您调用 “await Task . WhenAny” 时，您是在等待包装任务完成，而结果就是最先完成的实际任务。然而，要获取该任务的结果或确保任何异常能被正确抛出，您必须等待已完成的任务本身（存储在 “RW完成” 中）。尽管您知道该任务已经完成，但再次对其进行等待可以让您访问其结果或处理可能导致其出错的任何异常。</p><h3>审查最终代码</h3><p>这段代码大约在 10 ～ 25 秒内完成异步早餐任务。由于部分任务是并发运行的，总时间有所减少。该代码会同时监控多项任务，并仅在需要时采取行动。</p><p>最终代码是异步的。它更准确地反映了一个人可能如何做早餐。将最终代码与文章中的第一个代码示例进行比较。通过阅读代码，核心操作仍然清晰可见。你可以像阅读文章开头所示的那份做早餐的指令清单一样阅读最终代码。async 和 await 关键字的语言特性实现了每个人在遵循书面指令时所做的转换：尽可能启动任务，并且在等待任务完成时不要阻塞。</p><h3>Async/await 与 ContinueWith</h3><p>async 和 await 关键字相比直接使用 Task . ContinueWith 提供了语法上的简化。虽然 async/await 和 ContinueWith 在处理异步操作时具有相似的语义，但编译器不一定会将 await 表达式直接转换为 ContinueWith 方法调用。相反，编译器会生成优化的状态机代码，以提供相同的逻辑行为。这种转换带来了显著的可读性和可维护性优势，尤其是在链接多个异步操作时。<br/>试想一个需要执行多个连续异步操作的场景。下面是使用 ContinueWith 与使用 async/await 实现相同逻辑时的对比：</p><h4>使用 ContinueWith</h4><p>使用 ContinueWith 时，异步操作序列中的每个步骤都需要嵌套的延续：</p><pre><code class="C#">// 调用异步方法，获取任务（无需 as 转换）
Task &lt; List &lt; LEI牛奶 &gt;? &gt; 牛奶任务 = LEI牛奶 . FF泡牛奶 ( 10 , 2 );
Task &lt; List &lt; LEI煎牛排 . LEI锅次信息 &gt;? &gt; 煎牛排任务 = LEI煎牛排 . FF煎牛排 ( 4 , MJ熟度 . 七成熟 );
Task &lt; List &lt; LEI煎馒头片 . LEI锅次信息 &gt;? &gt; 煎馒头片任务 = LEI煎馒头片 . FF煎馒头片 ( 4 , 6 , MJ熟度 . 熟 );
Task &lt; List &lt; LEI牛奶 &gt;? &gt; 白开水任务 = LEI牛奶 . FF泡牛奶 ( 0 , 2 );

static Task FF使用ContinueWith ( )
    {
    // 第一步：煮牛奶
    return LEI牛奶 . FF泡牛奶 ( 10 , 2 )
        . ContinueWith ( 牛奶任务 =&gt;
        {
            var 牛奶 = 牛奶任务 . Result;
            Console . WriteLine ( "牛奶煮好了，开始煎牛排..." );
            return LEI煎牛排 . FF煎牛排 ( 3 , MJ熟度.七成熟 ); // 第二步：煎牛排（等牛奶做完）
        } )
        . Unwrap ( )
        . ContinueWith ( 牛排任务 =&gt;
        {
            var 牛排 = 牛排任务 . Result;
            Console . WriteLine ( "牛排煎好了，开始煎馒头片..." );
            return LEI煎馒头片 .FF煎馒头片 ( 14 , 6 , MJ熟度.熟 ); // 第三步：煎馒头片（等牛排做完）
        } )
        . Unwrap ( )
        . ContinueWith ( 馒头片任务 =&gt;
        {
            var 馒头片 = 馒头片任务 . Result;
            Console . WriteLine ( "馒头片煎好了，开始倒白开水..." );
            return LEI牛奶 . FF泡牛奶 ( 0 , 2 ); // 第四步：倒白开水（等馒头片做完）
        } )
        . Unwrap ( )
        . ContinueWith ( 白开水任务 =&gt;
        {
            Console . WriteLine ( "所有早餐都准备好了！用 ContinueWith 完成流程～" );
        } );
    }
await FF使用ContinueWith ( );

DateTime JS = DateTime . Now;
TimeSpan Shi = JS - QI;
Console . WriteLine ( $"\n共用时 {Shi . TotalSeconds} 秒" );</code></pre><h4>使用 async/await</h4><p>使用 async/await 的相同操作序列读起来要自然得多：</p><pre><code class="C#">static async Task FF使用AsyncAwait ( )
    {
    // 第一步：煮牛奶
    var nns = await LEI牛奶 . FF泡牛奶 ( 10 , 2 );
    Console . WriteLine ( "await 牛奶泡好了！" );
    // 第二步：煎牛排（等牛奶做完）
    var nps = await LEI煎牛排 . FF煎牛排 ( 3 , MJ熟度.七成熟 );
    Console . WriteLine ( "await 牛排煎好了！" );
    // 第三步：煎馒头片（等牛排做完）
    var mtps = await LEI煎馒头片 . FF煎馒头片 ( 10 , 2 , MJ熟度.熟 );
    Console . WriteLine ( "await 馒头片煎好了！" );
    // 第四步：倒白开水（等馒头片做完）
    var _ = await LEI牛奶 . FF泡牛奶 ( 0 , 2 );
    Console . WriteLine ( "await 热水倒好了！" );
    }
await FF使用AsyncAwait ( );</code></pre><h4>为什么更推荐使用 async/await</h4><p>async/await 方法有几个优点：</p><ul><li><strong>可读性</strong>：该代码读起来就像是同步代码，这使得理解操作流程变得更加容易。</li><li><strong>可维护性</strong>：在序列中添加或删除步骤只需进行少量的代码修改。</li><li><strong>错误处理</strong>：使用 try/catch 块进行异常处理的方式自然流畅，而 ContinueWith 则需要对故障任务进行谨慎处理。</li><li><strong>调试</strong>：使用 async/await 的调用栈和调试器体验要好得多。</li><li><strong>性能</strong>：对于 async/await，编译器的优化比手动的 ContinueWith 链更复杂。</li></ul><p>随着链式操作数量的增加，这种优势会变得更加明显。虽然单个延续使用 ContinueWith 可以处理得较为轻松，但 3 个或更多个异步操作的序列很快就会变得难以阅读和维护。这种模式，在函数式编程中被称为 “单态 do-语法”，允许您以顺序、可读的方式组合多个异步操作。</p><h2>异步编程场景</h2><p>如果您的代码需要处理与输入/输出相关的任务，以支持网络数据请求、数据库访问或文件系统读写操作，那么使用异步编程是最优选择。对于像复杂计算这类对 CPU 资源消耗较大的场景，您也可以编写异步代码。</p><p>C# 具有语言级别的异步编程模型，使您能够轻松编写异步代码，而无需处理回调函数或遵循支持异步功能的库的规范。该模型遵循所谓的基于任务的异步模式（TAP）。</p><h3>探索异步编程模型</h3><p>“Task” 和 “Task &lt; T &gt;” 对象是异步编程的核心。这些对象通过支持 “async” 和 “await” 关键字来用于模拟异步操作。在大多数情况下，无论是针对 I/O 密集型还是 CPU 密集型场景，该模型都相当简单。在异步方法内部：</p><ul><li>I/O 密集型代码会在异步方法中通过 Task 或 Task &lt; T &gt; 对象来启动一个操作。</li><li>CPU 密集型代码则通过 Task . Run 方法在后台线程上启动一个操作。</li></ul><p>在这两种情况下，活跃的 Task 都代表了一个可能尚未完成的异步操作。</p><p>“await” 关键字就是实现神奇效果的地方。它将控制权交还给包含 “await” 表达式的那个方法的调用者，从而最终使用户界面能够保持响应性，或者使服务具有弹性。虽然除了使用 “async” 和 “await” 表达式之外，还有其他方法来处理异步代码，但本文重点讨论的是语言层面的结构。</p><p><strong>注意</strong>：本文中所列举的一些示例使用了 System . Net . Http . HttpClient 类来从网络服务中下载数据。在示例代码中，名为 s_httpClient 的对象是 Program 类的一个静态字段，其类型为 Program 类：<br/><code> private static readonly HttpClient s_httpClient = new ( ); </code></p><h3>回顾基本概念</h3><p>在您的 C# 代码中实现异步编程时，编译器会将您的程序转换为一个状态机。这种结构会跟踪您代码中的各种操作和状态，例如当代码遇到 await 表达式时暂停执行，以及在后台任务完成时恢复执行。</p><p>就计算机科学理论而言，异步编程是异步机制（即 “承诺模型”）的一种实现方式。</p><p>在异步编程模型中，有以下几个关键概念需要理解：</p><ul><li>您可以将异步代码用于 I/O 密集型和 CPU 密集型代码，但实现方式有所不同。</li><li>异步代码使用 Task &lt; T &gt; 和 Task 对象作为结构体来模拟后台运行的工作。</li><li>async 关键字用于将方法声明为异步方法，这使您能够在方法体中使用 await 关键字。</li><li>当您使用 await 关键字时，代码会暂停调用方法并将其控制权返回给调用者，直到任务完成。</li><li>您只能在异步方法中使用 await 表达式。</li></ul><h3>I/O 密集型示例：从网络服务下载数据</h3><p>在该示例中，当用户点击一个按钮时，应用程序会从网络服务下载数据。您不想在下载过程中阻塞应用程序的用户界面线程。以下代码完成了此任务：</p><pre><code class="C#">HttpClient wlkh = new ( );
var zfc数据 = await wlkh . GetStringAsync ( "https://so.gushiwen.cn/view_10548.aspx" );
WBK内容 . Text = zfc数据 . ToString ( );</code></pre><p>这段代码表达了（异步下载数据的）意图，而不会陷入与 Task 对象的交互中。</p><h3>CPU 密集型示例：执行游戏计算</h3><p>在接下来的示例中，一款手机游戏会根据按钮事件对屏幕上的多个角色造成伤害。进行伤害计算可能会耗费大量资源。在用户界面线程上执行该计算可能会在计算过程中导致显示和用户界面交互出现问题。</p><p>处理此任务的最佳方式是启动一个后台线程，通过使用 Task . Run 方法来完成工作。该操作通过使用 await 表达式来暂停。当任务完成时，该操作会恢复运行。这种方法能让用户界面平稳运行，而工作则在后台完成。</p><pre><code class="C#">using System;
using System . Collections . Generic;
using System . Linq;
using System . Threading . Tasks;

namespace MillionArmySimulator
    {
    // 单位类型枚举
    public enum UnitType
        {
        Infantry, Archer, Cavalry, Mage
        }

    // 单位状态类
    public class Unit
        {
        public int Id
            {
            get;
            }
        public UnitType Type
            {
            get;
            }
        public float X
            {
            get; set;
            } // 位置X
        public float Y
            {
            get; set;
            } // 位置Y
        public float Health
            {
            get; set;
            }
        public float Attack
            {
            get;
            }
        public float Speed
            {
            get;
            }
        public float DetectionRange
            {
            get;
            } // 探测范围
        public bool IsAlive =&gt; Health &gt; 0;
        public int TeamId
            {
            get;
            } // 所属队伍

        // 战斗状态
        public Unit Target
            {
            get; set;
            }
        public float AttackCooldown
            {
            get; set;
            }

        public Unit ( int id , UnitType type , float x , float y , int teamId )
            {
            Id = id;
            Type = type;
            X = x;
            Y = y;
            TeamId = teamId;

            // 根据单位类型初始化属性 （ CPU密集点1：属性计算）
            switch ( type )
                {
                case UnitType . Infantry:
                    Health = 100;
                    Attack = 15;
                    Speed = 2.5f;
                    DetectionRange = 15f;
                    break;
                case UnitType . Archer:
                    Health = 60;
                    Attack = 20;
                    Speed = 2f;
                    DetectionRange = 30f;
                    break;
                case UnitType . Cavalry:
                    Health = 120;
                    Attack = 25;
                    Speed = 4f;
                    DetectionRange = 20f;
                    break;
                case UnitType . Mage:
                    Health = 80;
                    Attack = 30;
                    Speed = 1.5f;
                    DetectionRange = 25f;
                    break;
                }
            }
        }

    // 战斗模拟器（ 核心 CPU 计算类 ）
    public class BattleSimulator
        {
        private readonly List&lt;Unit&gt; _units = new List &lt; Unit &gt; ( );
        private readonly Random _random = new Random ( );
        private const float MapWidth = 1000f;
        private const float MapHeight = 1000f;

        // 初始化百万单位（CPU密集点2：大规模对象初始化）
        public void Initialize ( int unitCount )
            {
            _units . Clear ( );
            Parallel . For ( 0 , unitCount , i =&gt;
            {
                var type = ( UnitType )_random . Next ( 0 , 4 );
                var teamId = _random . Next ( 0 , 2 ); // 红蓝两队
                var x = ( float )_random . NextDouble ( ) * MapWidth;
                var y = ( float )_random . NextDouble ( ) * MapHeight;

                lock ( _units )
                    {
                    _units . Add ( new Unit ( i , type , x , y , teamId ) );
                    }
            } );

            Console . WriteLine ( $"初始化完成：{_units . Count} 个单位" );
            }

        // 帧更新（ CPU密集点3：并行处理百万单位的 AI 和物理）
        public void Update ( float deltaTime )
            {
            // 并行处理所有单位（ 利用多核 CPU ）
            Parallel . ForEach ( _units . Where ( u =&gt; u . IsAlive ) , unit =&gt;
            {
                // 1. 寻找目标（基于视野范围的距离计算）
                FindTarget ( unit );

                // 2. 移动逻辑（路径计算简化版）
                MoveUnit ( unit , deltaTime );

                // 3. 攻击逻辑（冷却计算 + 伤害判定）
                AttackLogic ( unit , deltaTime );

                // 4. 群体行为影响（邻近单位状态计算）
                ApplyGroupInfluence ( unit );
            } );

            // 统计战场状态
            var aliveCount = _units . Count ( u =&gt; u . IsAlive );
            var team1Count = _units . Count ( u =&gt; u . IsAlive &amp;&amp; u . TeamId == 0);
            var team2Count = aliveCount - team1Count;

            Console . WriteLine ( $"存活: {aliveCount} | 红队: {team1Count} | 蓝队: {team2Count}" );
            }

        // 寻找目标（CPU密集：大规模距离计算）
        private void FindTarget ( Unit unit )
            {
            if ( unit . Target != null &amp;&amp; unit . Target . IsAlive )
                return;

            Unit bestTarget = null;
            float closestDistance = float . MaxValue;

            // 遍历视野内的敌对单位（可优化为空间分区查询）
            foreach ( var other in _units )
                {
                if ( !other . IsAlive || other . TeamId == unit . TeamId )
                    continue;

                var distance = CalculateDistance ( unit , other );
                if ( distance &lt; unit . DetectionRange &amp;&amp; distance &lt; closestDistance )
                    {
                    closestDistance = distance;
                    bestTarget = other;
                    }
                }

            unit . Target = bestTarget;
            }

        // 移动逻辑（包含简单路径规避）
        private void MoveUnit ( Unit unit , float deltaTime )
            {
            if ( unit . Target != null )
                {
                // 向目标移动
                var directionX = unit . Target . X - unit . X;
                var directionY = unit . Target . Y - unit . Y;
                var distance = ( float ) Math . Sqrt ( directionX * directionX + directionY * directionY );

                // 到达攻击范围则停止
                if ( distance &gt; GetAttackRange ( unit ) )
                    {
                    unit . X += ( directionX / distance ) * unit . Speed * deltaTime;
                    unit . Y += ( directionY / distance ) * unit . Speed * deltaTime;
                    }
                }
            else
                {
                // 无目标时随机移动（群体漫游行为）
                unit . X += ( float ) ( _random . NextDouble ( ) - 0.5 ) * unit . Speed * deltaTime;
                unit . Y += ( float ) ( _random . NextDouble ( ) - 0.5 ) * unit . Speed * deltaTime;
                ClampPosition ( unit ); // 限制在地图内
                }
            }

        // 攻击逻辑
        private void AttackLogic ( Unit unit , float deltaTime )
            {
            if ( unit . Target == null || !unit . Target . IsAlive )
                return;

            unit . AttackCooldown -= deltaTime;
            if ( unit . AttackCooldown &lt;= 0 )
                {
                // 计算伤害（包含类型克制）
                float damage = CalculateDamage ( unit , unit . Target );
                unit . Target . Health -= damage;

                // 重置冷却
                unit . AttackCooldown = GetAttackInterval ( unit );
                }
            }

        // 群体影响（邻近单位的状态加成/减益）
        private void ApplyGroupInfluence ( Unit unit )
            {
            int allyCount = 0;
            int enemyCount = 0;

            // 统计周围单位（CPU密集：范围查询）
            foreach ( var other in _units )
                {
                if ( !other . IsAlive || other . Id == unit . Id )
                    continue;

                if ( CalculateDistance ( unit , other ) &lt; 10f )
                    {
                    if ( other . TeamId == unit . TeamId )
                        allyCount++;
                    else
                        enemyCount++;
                    }
                }

            // 士气影响（简单数值计算）
            float moraleFactor = 1 + ( allyCount * 0.05f ) - ( enemyCount * 0.1f );
            moraleFactor = Math . Clamp ( moraleFactor , 0.5f , 1.5f );
            }

        // 辅助计算：距离
        private float CalculateDistance ( Unit a , Unit b )
            {
            float dx = a . X - b . X;
            float dy = a . Y - b . Y;
            return MathF . Sqrt ( dx * dx + dy * dy );
            }

        // 辅助计算：攻击范围
        private float GetAttackRange ( Unit unit )
            {
            return unit . Type switch
                {
                    UnitType . Infantry =&gt; 2f,
                    UnitType . Archer =&gt; 15f,
                    UnitType . Cavalry =&gt; 3f,
                    UnitType . Mage =&gt; 20f,
                    _ =&gt; 2f
                    };
            }

        // 辅助计算：攻击间隔
        private float GetAttackInterval ( Unit unit )
            {
            return unit . Type switch
                {
                    UnitType . Infantry =&gt; 1f,
                    UnitType . Archer =&gt; 1.5f,
                    UnitType . Cavalry =&gt; 0.8f,
                    UnitType . Mage =&gt; 2f,
                    _ =&gt; 1f
                    };
            }

        // 辅助计算：伤害（类型克制）
        private float CalculateDamage ( Unit attacker , Unit target )
            {
            float factor = 1f;

            // 类型克制逻辑（增加计算复杂度）
            if ( ( attacker . Type == UnitType . Infantry &amp;&amp; target . Type == UnitType . Archer ) ||
                ( attacker . Type == UnitType . Archer &amp;&amp; target . Type == UnitType . Cavalry ) ||
                ( attacker . Type == UnitType . Cavalry &amp;&amp; target . Type == UnitType . Mage ) ||
                ( attacker . Type == UnitType . Mage &amp;&amp; target . Type == UnitType . Infantry ) )
                {
                factor = 1.5f; // 克制
                }
            else if ( ( attacker . Type == UnitType . Infantry &amp;&amp; target . Type == UnitType . Cavalry ) ||
                     ( attacker . Type == UnitType . Archer &amp;&amp; target . Type == UnitType . Infantry ) ||
                     ( attacker . Type == UnitType . Cavalry &amp;&amp; target . Type == UnitType . Archer ) ||
                     ( attacker . Type == UnitType . Mage &amp;&amp; target . Type == UnitType . Cavalry ) )
                {
                factor = 0.7f; // 被克制
                }

            return attacker . Attack * factor;
            }

        // 限制位置在地图内
        private void ClampPosition ( Unit unit )
            {
            unit . X = Math . Clamp ( unit . X , 0 , MapWidth );
            unit . Y = Math . Clamp ( unit . Y , 0 , MapHeight );
            }
        }

    // 游戏主程序
    class Program
        {
        static void Main ( string [ ] args )
            {
            var simulator = new BattleSimulator ( );
            simulator . Initialize ( 1000 ); // 初始化 1000 个单位（CPU 压力测试）

            var watch = System . Diagnostics . Stopwatch . StartNew ( );
            float deltaTime = 0.016f; // 约 60 帧/秒

            // 模拟战斗循环
            for ( int i = 0 ; i &lt; 100 ; i++ )
                {
                simulator . Update ( deltaTime );
                Console . WriteLine ( $"第 {i + 1} 帧计算完成，耗时：{watch . ElapsedMilliseconds} 毫秒" );
                watch . Restart ( );
                }

            Console . WriteLine ( "战斗模拟结束" );
            Console . ReadKey ( true );

            }
        }
    }</code></pre><p>该代码清晰地表达了按钮 “点击” 事件的意图。它无需手动管理后台线程，并且以非阻塞的方式完成任务。</p><h3>识别 CPU 密集型和 I/O 密集型场景</h3><p>前面的示例展示了如何使用 async 修饰符和 await 表达式来处理 I/O 密集型和 CPU 密集型工作。每个场景的一个示例都展示了代码在操作所绑定位置上的不同之处。为了为您的实现做好准备，您需要了解如何识别一个操作是 I/O 密集型还是 CPU 密集型。您的实现选择会极大地影响代码的性能，并可能导致对构造函数的不当使用。</p><p>在编写任何代码之前，您需要先解决两个主要问题：</p><table><thead><tr><th>问题</th><th>场景</th><th>实现</th></tr></thead><tbody><tr><td>如果代码需要等待某个结果或操作（例如来自数据库的数据），应如何处理？</td><td>阻塞型</td><td>I/O 限制型情况下，使用 async 关键字和 await 表达式，而无需使用 Task . Run 方法；避免使用任务并行库</td></tr><tr><td>如果代码要执行一项耗时的计算呢？</td><td>属于 CPU 密集型任务</td><td>使用 “async” 修饰符和 “await” 表达式，但通过 “Task . Run” 方法将工作分派到另一个线程上。这种方法解决了与 CPU 响应性相关的问题</td></tr></tbody></table><p>如果该工作适合并发和并行处理，那么也考虑使用任务并行库。</p><p>务必对代码的执行情况进行测量。您可能会发现，与多线程时上下文切换的开销相比，您的 CPU 密集型工作成本并不高。每个选择都有其优缺点。请根据您的具体情况选择正确的平衡方案。</p><h3>探索其他示例</h3><p>本节中的示例展示了在 C# 中编写异步代码的几种方法。它们涵盖了您可能会遇到的一些场景。</p><h4>从网络中提取数据</h4><p>以下代码会从给定的 URL 下载 HTML 内容，并统计其中出现字符串 “.NET” 的次数。该代码使用 ASP.NET 来定义一个 Web API 控制器方法，该方法执行任务并返回计数结果。</p><p><strong>注意</strong>：如果您打算在生产代码中进行 HTML 解析，请不要使用正则表达式。而应使用解析库来实现。</p><pre><code class="C#">static async Task&lt;int&gt; FF获取DotNet数量 ( string URL )
    {
        HttpClient wlkh = new ( );
        var html = await wlkh . GetStringAsync ( URL );
        return Regex . Count ( html , @"\.NET" );
    }</code></pre><p>您可以为通用 Windows 应用程序编写类似的代码，并在按下按钮后执行计数任务：</p><pre><code class="C#">private async void CHX获取网络数据 ( object sender , EventArgs e )
    {
        FF获取网络数据 ( );
        // 用 await 等待异步方法执行完成，拿到实际的 int 结果
        int count = await FF获取DotNet数量 ( "https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/async-scenarios" );
        // 再拼接结果
        WBK内容 . Text += $"{Environment . NewLine}DotNet 出现的次数：{count}";
    }

async Task&lt;int&gt; FF获取DotNet数量 ( string URL )
    {
        using HttpClient wlkh = new ( );
            {
                try
                    {
                        var qingqiu = new HttpRequestMessage ( HttpMethod . Get , URL );
                        var dafu = await wlkh . SendAsync ( qingqiu , HttpCompletionOption . ResponseHeadersRead );
                        dafu . EnsureSuccessStatusCode ( );

                        long CZ总字节数 = 0;
                        if ( dafu . Content . Headers . TryGetValues ( "Content-Length" , out var ZHIs ) )
                            {
                                _ = long . TryParse ( ZHIs . First ( ) , out CZ总字节数 );

                            }

                        long CZ读取字节s = 0;
                        char [ ] huanchongqu = new char [ 1024 ];
                        int ZHS读取字节;
                        string html = "";

                        using ( var DQ = new StreamReader ( await dafu . Content . ReadAsStreamAsync ( ) ) )
                            {
                                while ( ( ZHS读取字节 = await DQ . ReadBlockAsync ( huanchongqu , 0 , huanchongqu . Length ) ) &gt; 0 )
                                    {
                                        html += new string ( huanchongqu , 0 , ZHS读取字节 );
                                        CZ读取字节s += ZHS读取字节;

                                        int bfb = CZ总字节数 &gt; 0 ? ( int ) ( ( CZ读取字节s * 100 ) / CZ总字节数 ) : 0;
                                        string ZFC说明 = CZ总字节数 &gt; 0 ? $"加载中 {bfb} ％" : "加载中…";
                                        PGB进度 . Value = bfb;
                                        BQ进度 . Text = ZFC说明;
                                        await Task . Delay ( 10 );
                                    }
                                }
                            await Task . Delay ( 100 );

                            return Regex . Count ( html , @"\.NET" );
            }
        catch ( Exception YC )
            {
                BQ进度 . Text = $"出错了。{YC . Message}";
                return -1;
            }
        }
    }</code></pre><h3>等待多个任务完成</h3><p>在某些情况下，代码需要同时获取多组数据。任务 API 提供了一些方法，使您能够编写异步代码，以对多个后台任务进行非阻塞式的等待操作：</p><ul><li>Task.WhenAll 方法</li><li>Task.WhenAny 方法</li></ul><p>以下示例展示了如何获取一组 userId 对象对应的用户对象数据。</p><pre><code class="C#">private static async Task&lt;IEnumerable&lt;LEI用户&gt;&gt; FF获取用户 ( IEnumerable&lt;int&gt; ids )
    {
        var HQ用户任务 = new List &lt; Task &lt; LEI用户&gt;&gt; ( );
        foreach ( int id in ids )
            {
                HQ用户任务 . Add ( FF获取用户 ( id ) );
            }
        return await Task . WhenAll ( HQ用户任务 );
    }

private static async Task&lt;LEI用户&gt; FF获取用户 ( int id )
    {
        return await Task . FromResult ( new LEI用户 ( id ) );
    }

List &lt; LEI用户 &gt; yhlb = [ new LEI用户 ( 001 ) , new LEI用户 ( 002 ) , new LEI用户 ( 003 ) ];

public class LEI用户 ( int ID用户 )
    {
        public int ID
            {
                get
                    {
                        return ID用户;
                    }
                set
                    {
                        ID用户 = value;
                    }
            }
    }</code></pre><p>您可以通过使用 LINQ 来更简洁地编写这段代码：</p><pre><code class="C#">private static async Task&lt;LEI用户 [ ]&gt; FF获取用户LINQ ( IEnumerable&lt;int&gt; ids )
    {
        var rw用户 = ids . Select ( id =&gt; FF获取用户 ( id ) ) . ToArray ( );
        return await Task . WhenAll ( rw用户 );
    }</code></pre><p>虽然使用 LINQ 编写代码的量会减少，但在将 LINQ 与异步代码混合使用时仍需谨慎。LINQ 采用的是延迟（或延迟执行）执行方式，这意味着如果没有立即进行评估，异步调用不会立即执行，而是要等到序列被枚举之后才会进行。</p><p>前面的示例是正确且安全的，因为它使用了 Enumerable . ToArray 方法来立即执行 LINQ 查询，并将任务存储在一个数组中。这种方法确保了 id =&gt; FF获取用户 ( id ) 的调用能够立即执行，并且所有任务会同时开始执行，就像 foreach 循环方法那样。在使用 LINQ 创建任务时，始终使用 Enumerable . ToArray 或 Enumerable . ToList 以确保任务能够立即执行并实现并发执行。下面是一个示例，展示了如何使用 ToList ( ) 与 Task . WhenAny 结合来处理已完成的任务：</p><pre><code class="C#">private static async Task FF完成任务 ( IEnumerable&lt;int&gt; ids )
    {
        var HQ用户任务s = ids . Select ( id =&gt; FF获取用户 ( id ) ) . ToList ( );
        while ( HQ用户任务s . Count &gt; 0 )
            {
                Task &lt;LEI用户&gt; rw结束 = await Task . WhenAny ( HQ用户任务s );
                HQ用户任务s . Remove ( rw结束 );

                LEI用户 YH = await rw结束;
                Console . WriteLine ( $"结束用户 {YH . ID}" );
            }
    }</code></pre><p>在该示例中，ToList ( ) 方法会创建一个支持 Remove ( ) 操作的列表，使您能够动态地移除已完成的任务。这种模式在您希望在结果可用时立即处理它们，而非等待所有任务完成的情况下特别有用。</p><p>虽然使用 LINQ 编写代码的量会减少，但在将 LINQ 与异步代码混合使用时仍需谨慎。LINQ 采用的是延迟（或延迟执行）方式。异步调用不会像在 foreach 循环中那样立即执行，除非您通过调用 . ToList ( ) 或 . ToArray ( ) 方法强制生成的序列进行迭代。</p><p>您可以根据具体情况选择使用 Enumerable . ToArray 或 Enumerable . ToList：</p><ul><li>当您打算一次性处理所有任务（例如使用 Task . WhenAll）时，请使用 ToArray ( ) 方法。数组在处理固定大小集合的场景中效率更高。</li><li>当您需要动态管理任务（例如在 Task . WhenAny 中，当任务完成时可以从集合中移除已完成的任务）时，请使用 ToList ( ) 方法。</li></ul><h3>回顾异步编程的相关注意事项</h3><p>在异步编程中，有一些细节需要牢记，否则可能会导致意外行为。</p><h4>在 async ( ) 方法体中使用 await</h4><p>当您使用 async 关键字时，应在方法体中包含一个或多个 await 表达式。如果编译器未遇到 await 表达式，该方法将无法产生结果。尽管编译器会发出警告，但代码仍能编译，并且编译器会运行该方法。C# 编译器为异步方法生成的状态机没有任何作用，因此整个过程效率极低。</p><h4>给异步方法名称添加 “Async” 后缀</h4><p>在.NET 的规范中，会将 “Async” 后缀添加到所有异步方法的名称中。这种方法有助于更清晰地区分同步方法和异步方法。某些并非由您的代码直接调用的方法（例如事件处理程序或 Web 控制器方法）在这种情况下不一定适用。由于这些项目并非由您的代码直接调用，因此使用明确的命名方式并不是那么重要。</p><h4>只从事件处理程序中返回 “async void” 类型</h4><p>事件处理程序必须声明为 void 类型的返回值，并且不能像其他方法那样使用或返回 Task 和 Task &lt; T &gt; 对象。当您编写异步事件处理程序时，需要在处理程序中使用 async 关键字来修饰一个返回 void 的方法。其他实现返回 async void 类型的方法的实现并不遵循 TAP 模型，可能会带来一些挑战：<br/>在异步 void 方法中抛出的异常无法在该方法之外被捕获</p><ul><li>异步 void 方法难以进行测试</li><li>如果调用方没有预期这些方法是异步的，那么异步 void 方法可能会产生负面的副作用</li><li>在 LINQ 中谨慎使用异步 lambda 表达式</li></ul><p>在 LINQ 表达式中实现异步 lambda 表达式时，务必谨慎行事。LINQ 中的 lambda 表达式采用延迟执行的方式，这意味着代码可能会在意外的时间执行。如果在这个场景中引入阻塞任务，如果代码编写不当，很容易导致死锁。此外，异步代码的嵌套也会使代码的执行过程难以理解。异步和 LINQ 非常强大，但这些技术应该尽可能谨慎且清晰地一起使用。</p><h4>以非阻塞方式处理任务</h4><p>如果您的程序需要某个任务的结果，请编写代码以非阻塞的方式实现 “await” 表达式。通过阻塞当前线程来同步等待任务项完成的方式可能会导致死锁和阻塞的上下文线程。这种编程方法可能需要更复杂的错误处理。以下表格提供了以非阻塞方式访问任务结果的指导：</p><table><thead><tr><th>任务场景</th><th>当前代码</th><th>替换为 'await'</th></tr></thead><tbody><tr><td>获取后台任务的结果</td><td>Task . Wait 或 Task . Result</td><td>await</td></tr><tr><td>在任何任务完成时继续执行</td><td>Task . WaitAny</td><td>await Task . WhenAny</td></tr><tr><td>在所有任务完成时继续执行</td><td>Task . WaitAll</td><td>await Task . WhenAll</td></tr><tr><td>在一段时间后继续执行</td><td>Thread . Sleep</td><td>await Task . Delay</td></tr></tbody></table><h4>考虑使用 ValueTask 类型</h4><p>当一个异步方法返回一个 Task 对象时，在某些路径中可能会出现性能瓶颈。因为 Task 是一个引用类型，所以一个 Task 对象是从堆中分配的。如果一个带有 async 关键字声明的方法返回一个缓存结果或以同步方式完成，那么在性能关键代码段中额外的分配操作可能会带来显著的时间成本。当这些分配操作出现在紧密循环中时，这种情况可能会变得非常昂贵。</p><h4>了解何时设置 ConfigureAwait ( false )</h4><p>开发人员经常会询问何时使用 Task . ConfigureAwait ( Boolean ) 这个布尔值。此 API 允许 Task 实例为实现任何 await 表达式的状态机配置上下文。如果布尔值设置不正确，性能可能会下降或者会出现死锁。</p><h4>编写少状态化的代码</h4><p>避免编写依赖于全局对象状态或某些方法执行情况的代码。而应仅依赖于方法的返回值。编写少状态化的代码有许多好处：</p><ul><li>更易于理解代码</li><li>更易于测试代码</li><li>更易于将异步代码与同步代码混合使用</li><li>能够避免代码中的竞争条件</li><li>简单地协调依赖返回值的异步代码</li><li>（额外优点）与代码中的依赖注入配合使用效果良好</li></ul><p>推荐的目标是在您的代码中实现完全或近乎完全的引用透明性。这种方法会生成一个可预测、可测试且易于维护的代码库。</p><h4>异步操作的同步访问</h4><p>在某些场景中，如果在你的调用栈中无法使用 “await” 关键字，那么您可能需要在异步操作上进行阻塞操作。这种情况常见于遗留代码库中，或者是在将异步方法集成到无法更改的同步 API 中时出现。</p><p><strong>警告</strong>：对于异步操作的同步阻塞可能会导致死锁，因此应尽可能避免这种做法。更理想的解决方案是在整个调用栈中使用 async/await。</p><p>当您必须对任务进行同步阻塞操作时，以下是可供选择的方法，按优先级从高到低排列：</p><ul><li>使用 GetAwaiter ( ) . GetResult ( )</li><li>对于复杂场景，使用 Task . Run</li><li>使用 Wait ( ) 和 Result</li></ul><h4>使用 GetAwaiter ( ) . GetResult ( )</h4><p>“GetAwaiter ( ) . GetResult ( )” 模式通常是在必须同步阻塞的情况下首选的方法：</p><pre><code class="C#">// 当你不能使用 await
Task&lt;string&gt; task = GetDataAsync ( );
string result = task . GetAwaiter ( ) . GetResult ( );</code></pre><p>这种方法：</p><ul><li>保留了原始的异常，未将其封装在聚合异常中。</li><li>使当前线程阻塞，直至任务完成。</li><li>如果不谨慎使用，仍存在死锁风险。</li></ul><h4>对于复杂的场景，请使用 Task.Run</h4><p>对于需要隔离异步工作的复杂场景：</p><pre><code class="C#">// 将任务卸载到线程池中，以避免上下文死锁的情况
string result = Task . Run ( async ( ) =&gt; await GetDataAsync ( ) ) . GetAwaiter ( ) . GetResult ( );</code></pre><p>这种模式：</p><ul><li>在线程池线程上执行异步方法。</li><li>有助于避免一些死锁情况。</li><li>通过将工作调度到线程池会增加开销。</li></ul><h4>使用 Wait ( ) 和 Result</h4><p>您可以采用阻塞方式，通过调用 Wait ( ) 和 Result 来操作。然而，这种方法不被推荐，因为这会将异常封装在 AggregateException 中。</p><pre><code class="C#">Task&lt;string&gt; task = GetDataAsync ( );
task . Wait ( );
string result = task . Result;</code></pre><p>“Wait ( )” 和 “Result” 存在的问题：</p><ul><li>异常会被封装在 AggregateException 中，这使得错误处理变得更加复杂。</li><li>更高的死锁风险。</li><li>代码意图不那么清晰。</li></ul><h4>其他需要考虑的因素</h4><ul><li>预防死锁：在 UI 应用程序中或在使用同步上下文时要格外小心。</li><li>性能影响：阻塞线程会降低可扩展性。</li><li>异常处理：仔细测试错误场景，因为不同模式下的异常行为有所差异。</li></ul><h3>查看完整示例</h3><p>以下代码即为完整的示例。</p><pre><code class="C#">using Microsoft . AspNetCore . Mvc;
using System . Text . RegularExpressions;

class AnNiu
    {
    public Func&lt;object , object , Task&gt;? DanJi
        {
        get;
        internal set;
        }
    }

class ShangHaijieguo
    {
    public int ShangHai
        {
        get { return 0; }
        }
    }

class YongHu
    {
    public bool Ber有效  {  get; set; }
    public int ID { get; set; }
    }

public class ChengXu
    {
    private static readonly AnNiu _下载按钮 = new ( );
    private static readonly AnNiu _计算按钮 = new ( );

    private static readonly HttpClient WLKH = new ( );

    private static readonly IEnumerable &lt;string&gt; _LBurl =
        [
            "https://learn.microsoft.com",
            "https://learn.microsoft.com/aspnet/core",
            "https://learn.microsoft.com/azure",
            "https://learn.microsoft.com/azure/devops",
            "https://learn.microsoft.com/dotnet",
            "https://learn.microsoft.com/dotnet/desktop/wpf/get-started/create-app-visual-studio",
            "https://learn.microsoft.com/education",
            "https://learn.microsoft.com/shows/net-core-101/what-is-net",
            "https://learn.microsoft.com/enterprise-mobility-security",
            "https://learn.microsoft.com/gaming",
            "https://learn.microsoft.com/graph",
            "https://learn.microsoft.com/microsoft-365",
            "https://learn.microsoft.com/office",
            "https://learn.microsoft.com/powershell",
            "https://learn.microsoft.com/sql",
            "https://learn.microsoft.com/surface",
            "https://dotnetfoundation.org",
            "https://learn.microsoft.com/visualstudio",
            "https://learn.microsoft.com/windows",
            "https://learn.microsoft.com/maui"
        ];

    private static void FF计算 ( )
        {
        static ShangHaijieguo FF计算伤害结果 ( )
            {
            return new ( );
                {
                // 代码省略：
                // 执行一项耗时的计算，并返回该计算的结果
                };
            }

        _计算按钮 . DanJi += async ( o , e ) =&gt;
            {
            // 在 “FF计算伤害结果 ( )” 执行其任务期间，此行将让控制权交还给用户界面。而用户界面线程则可以继续执行其他工作
            var shjg = await Task . Run ( ( ) =&gt; FF计算伤害结果 ( ) );
            FF显示伤害结果 ( shjg );
            };
        }

    private static void FF显示伤害结果 ( ShangHaijieguo 伤害 )
        {
        Console . WriteLine ( 伤害 . ShangHai );
        }

    private static void FF下载 ( string URL )
        {
        _下载按钮 . DanJi += async ( o , e ) =&gt;
            {
                // 在此行代码中，当从网络服务接收到请求时，控制权将交还给用户界面
                // 现在用户界面线程可以自由地执行其他工作了
                var zfc数据 = await WLKH . GetStringAsync ( URL );
                FF对数据做点什么 ( zfc数据 );
            };
        }

    private static void FF对数据做点什么 ( object 数据字符串 )
        {
        Console . WriteLine ( $"显示数据：{数据字符串}" );
        }

    private static async Task &lt;YongHu&gt; FF获取用户Async ( int ID )
        {
        // 程序代码省略：
        // 给定一个用户 ID {userId}，将检索出与数据库中具有 {userId} 作为其 ID 的条目相对应的用户对象
        return await Task . FromResult ( new YongHu ( ) { ID = ID } );
        }

    private static async Task&lt;IEnumerable&lt;YongHu&gt;&gt; FF获取用户Async ( IEnumerable&lt;int&gt; IDs )
        {
        var HQ用户任务s = new List&lt;Task&lt;YongHu&gt;&gt; ( );
        foreach ( int id in IDs )
            {
            HQ用户任务s . Add ( FF获取用户Async ( id ) );
            }
        return await Task . WhenAll ( HQ用户任务s );
        }

    private static async Task&lt;YongHu [ ]&gt; FF获取用户LINQAsync ( IEnumerable&lt;int&gt; IDs )
        {
        var HQ用户任务s = IDs . Select ( id =&gt; FF获取用户Async ( id ) ) . ToArray ( );
        return await Task . WhenAll ( HQ用户任务s );
        }

    private static async Task FF在任务完成时异步处理任务 ( IEnumerable&lt;int&gt; IDs )
        {
        var RW获取用户 = IDs . Select ( id =&gt; FF获取用户Async ( id ) ) . ToList ( );

        while ( RW获取用户 . Count &gt; 0 )
            {
            Task&lt;YongHu&gt; RW结束 = await Task . WhenAny ( RW获取用户 );
            RW获取用户 . Remove ( RW结束 );

            YongHu user = await RW结束;
            Console . WriteLine ( $"处理用户 {user . ID}" );
            }
        }

    static public async Task&lt;int&gt; FF获取DotNet计数 ( string URL )
        {
            try
            {
            // 中止调用 FF获取DotNetCountAsync ( ) 方法，以便让调用方（即网络服务器）能够处理另一个请求，而无需在此请求上进行阻塞
            var html = await WLKH . GetStringAsync ( URL );
            return Regex . Matches ( html , @"\.NET" ) . Count;
            }
            catch (Exception ych )
            {
            Console . WriteLine ( ych . Message );
            return -1;
            }
        }

    static async Task Main ( )
        {
        Console . WriteLine ( "应用程序开始。" );

        Console . WriteLine ( "正在统计网站中 “.NET” 这一短语的出现次数……" );
        int total = 0;
        foreach ( string url in _LBurl )
            {
            var result = await FF获取DotNet计数 ( url );
            Console . WriteLine ( $"{url}：{result}" );
            total += result;
            }
        Console . WriteLine ( "所有：" + total );

        Console . WriteLine ( "处理 IDs 中的用户对象……" );
        IEnumerable&lt;int&gt; ids = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
        var users = await FF获取用户Async  ( ids );
        foreach ( YongHu? yh in users )
            {
            Console . WriteLine ( $"{yh . ID}：isEnabled = {yh . Ber有效}" );
            }

        Console . WriteLine ( "在它们结束后处理任务……" );
        await FF在任务完成时异步处理任务 ( ids );

        _下载按钮 . DanJi? . Invoke ( arg1: null , arg2: null );
        _计算按钮 . DanJi? . Invoke ( arg1: null , arg2: null );
        Console . WriteLine ( "应用程序结束！" );
        }
    }</code></pre><h2>任务异步编程模型</h2><p>通过使用异步编程，您可以避免性能瓶颈并提高应用程序的整体响应能力。然而，编写异步应用程序的传统方法可能会很复杂，这使得它们难以编写、调试和维护。</p><p>C# 支持一种简化的方法 - 异步编程，它利用了 .NET 运行时中的异步支持功能。编译器承担了过去由开发人员完成的复杂工作，而您的应用程序仍能保持类似于同步代码的逻辑结构。因此，您能够以极小的代价获得异步编程的所有优势。</p><p>本文概述了何时以及如何使用异步编程，并提供了指向其他包含详细信息和示例文章的链接。</p><h3>异步提高了响应速度</h3><p>异步处理对于那些可能造成阻塞的操作（例如网络访问）至关重要。访问网络资源时有时会很慢或者会有延迟。如果这种操作在同步流程中被阻塞，整个应用程序就必须等待。而在异步流程中，应用程序可以继续进行其他不依赖于网络资源的工作，直到可能造成阻塞的任务完成。</p><p>以下表格展示了异步编程能够提升响应速度的典型应用场景。列出的来自.NET 和 Windows 运行时的 API 包含支持异步编程的方法。</p><table><thead><tr><th>应用领域</th><th>有异步方法的 .NET 类型</th><th>有异步方法的 Windows 运行时类型</th></tr></thead><tbody><tr><td>网络访问</td><td>HttpClient</td><td>Windows . Web . Http . HttpClient、SyndicationgClient</td></tr><tr><td>文件处理</td><td>JsonSerializer、StreamReader、StreamWriter、XmlReader、XmlWriter</td><td>StorageFile</td></tr><tr><td>图像处理</td><td> </td><td>MediaCapture、BitmapEncoder、BitmapDecoder</td></tr><tr><td>WCF 编程</td><td>同步与异步操作符</td><td> </td></tr></tbody></table><p>异步处理对于那些需要访问用户界面线程的应用程序来说尤其有用，因为所有与用户界面相关的活动通常都共用一个线程。在同步应用程序中，如果任何进程被阻塞，那么所有进程都会被阻塞。您的应用程序就会停止响应，而您可能会认为它失败了，但实际上它只是在等待。</p><p>当您使用异步方法时，应用程序仍会继续响应用户界面。例如，您可以调整窗口大小或将其最小化，或者如果您不想等待其完成，也可以关闭应用程序。</p><p>基于异步的方法为在设计异步操作时可供选择的选项列表中增添了相当于自动变速器的功能。也就是说，您能够享受到传统异步编程的所有优势，而开发人员的工作量则会大大减少。</p><h3>异步方法易于编写</h3><p>C# 中的 “async” 和 “await” 关键字是异步编程的核心。通过使用这两个关键字，您能够像创建同步方法那样轻松地利用 .NET 框架、.NET 核心或 Windows 运行时中的资源来创建异步方法。通过使用“async”关键字定义的异步方法被称为异步方法。</p><p>下面这个示例展示了一个异步方法。代码中的几乎所有内容对您来说应该都很熟悉。</p><p>您可以在《C# 中的异步编程 - 使用 async 和 await》一文中找到一个完整的 Windows 表示基础架构（WPF）示例，该示例可免费下载。</p><pre><code class="C#">public static async Task&lt;int&gt; FF获取URL主体长度Async ( )
    {
        using var KHD = new HttpClient();

        Task&lt;string&gt; FF获取字符串任务 = KHD . GetStringAsync ( "https://learn.microsoft.com/dotnet" );

        FF自己的工作 ( );

        string 主体 = await FF获取字符串任务;

        return 主体 . Length;
    }

static void FF自己的工作 ( )
    {
        Console . WriteLine ( "工作中……" );
    }</code></pre><p>您可以从前面的示例中学习几种做法。首先来看方法签名。它包含 “async” 修饰符。返回类型为 “Task &lt; int &gt;”。方法名以 “Async” 结尾。在方法体中，“FF获取字符串任务” 返回一个 “Task &lt; string &gt;”。这意味着当您等待该任务时，您会得到一个字符串（内容）。在等待任务之前，您可以进行不需要依赖于 “FF获取字符串任务” 返回的字符串的操作。</p><p>请注意 “await” 操作符。它会暂停 “FF获取URL主体长度Async” 操作：</p><ul><li>“FF获取URL主体长度Async” 在 “FF获取字符串任务” 完成之前无法继续执行。</li><li>与此同时，控制权会返回给 “FF获取URL主体长度Async” 的调用者。</li><li>当 “FF获取字符串任务” 完成时，控制权会在此处恢复。</li><li>然后，“await” 运算符会从 “FF获取字符串任务” 中获取字符串结果。</li></ul><p>返回语句指定了一个整数结果。任何正在等待 “FF获取URL主体长度Async” 的方法都会获取长度值。</p><p>如果 FF获取URL主体长度Async 在调用 FF获取字符串任务 之后以及等待其完成之前没有任何可以执行的工作，那么您可以通过在以下单个语句中调用并等待来简化您的代码。<br/><code> string ZFC主体s = await WLKH . GetStringAsync ( "https://learn.microsoft.com/dotnet" ); </code><br/>以下这些特点概括了为何上述示例属于异步方法：</p><ul><li>该方法签名包含了一个“异步”修饰符。</li><li>按照惯例，异步方法的名称会在其末尾加上“Async”后缀。</li><li><p>返回类型属于以下其中一种类型：</p><ul><li>如果您的方法中有带有 TResult 类型操作数的返回语句，则使用 Task &lt; TResult &gt;。</li><li>如果您的方法没有返回语句或者有无操作数的返回语句，则使用 Task。</li><li>如果您正在编写异步事件处理程序，则使用 void。</li><li>如果您的类型具有 GetAwaiter 方法，则使用该类型。</li></ul></li><li>该方法通常至少包含一个 “await” 表达式，该表达式标志着在等待的异步操作完成之前，方法无法继续执行的点。在此期间，方法会被暂停，控制权会返回给方法的调用者。本文的下一节将说明在暂停点会发生什么情况。</li></ul><p>在异步方法中，您只需使用所提供的关键字和类型来表明您想要执行的操作，编译器会完成其余工作，包括跟踪当控制返回到挂起方法中的等待点时必须发生的事情。一些常规流程，如循环和异常处理，在传统的异步代码中可能难以处理。而在异步方法中，您就像在同步解决方案中那样编写这些元素，问题就迎刃而解了。</p><h3>异步方法中的操作</h3><p>在异步编程中，需要理解的最重要的一点是控制流如何从一个方法转移到另一个方法。下面的图表将引导您了解整个过程：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047394233" alt="" title="" loading="lazy"/><br/>图表中的数字对应着以下步骤，这些步骤是在调用方法调用异步方法时开始执行的。</p><ol><li>一个调用方法会调用并等待 “GetUrlContentLengthAsync” 这个异步方法。</li><li>GetUrlContentLengthAsync 方法会创建一个 HttpClient 实例，并调用 GetStringAsync 异步方法来将网站的内容以字符串的形式下载下来。</li><li>在 GetStringAsync 方法中发生了一些情况，导致其执行进程暂停。这可能是因为它必须等待网站下载完成，或者进行其他阻塞性操作。为了避免占用资源，GetStringAsync 会将控制权交给其调用者 GetUrlContentLengthAsync。<br/>GetStringAsync 方法返回一个 Task &lt; TResult &gt; 类型的对象，其中 TResult 表示字符串类型。GetUrlContentLengthAsync 方法将该任务赋值给 getStringTask 变量。该任务代表了调用 GetStringAsync 方法的正在进行的操作，一旦完成工作，它将承诺生成一个实际的字符串值。</li><li>由于 getStringTask 仍未被等待，所以 GetUrlContentLengthAsync 可以继续执行那些不依赖于 GetStringAsync 最终结果的其他工作。这些工作通过调用同步方法 DoIndependentWork 来实现。</li><li>“DoIndependentWork” 是一种同步方法，它完成工作后会返回给调用者。</li><li>GetUrlContentLengthAsync 方法在没有 getStringTask 方法返回结果的情况下无法执行任何操作。接下来，GetUrlContentLengthAsync 方法想要计算并返回下载字符串的长度，但该方法必须在获取到字符串之后才能计算出这个值。<br/>因此，GetUrlContentLengthAsync 使用一个 await 关键字来暂停其执行进度，并将控制权交给调用该方法的其他代码段。GetUrlContentLengthAsync 返回一个 Task &lt; int &gt; 给调用者。该任务表示将产生一个整数值（即下载字符串的长度）的承诺。<br/><strong>注意</strong>：如果调用 GetStringAsync（从而导致 getStringTask）的操作先于 GetUrlContentLengthAsync 的等待操作完成，那么控制权就会留在 GetUrlContentLengthAsync 中。如果被调用的异步操作 getStringTask 已经完成，而 GetUrlContentLengthAsync 无需等待最终结果，那么暂停和返回到 GetUrlContentLengthAsync 所产生的开销就会被浪费掉。<br/>在调用方法内部，处理流程继续进行。调用者在等待获取 URL 内容长度异步操作的结果之前，可能会先执行一些不依赖于该结果的工作，或者调用者可能会立即进行等待。调用方法正在等待获取 URL 内容长度异步操作的结果，而获取 URL 内容长度异步操作则在等待获取字符串异步操作的结果。</li><li>GetStringAsync 方法完成操作并生成一个字符串结果。这个字符串结果并非像您所期望的那样通过调用 GetStringAsync 方法来返回（请记住，在步骤 3 中该方法已经返回了一个任务）。相反，该字符串结果被存储在代表该方法完成的任务 getStringTask 中。await 操作符从 getStringTask 中获取结果。赋值语句将获取的结果赋给 contents 变量。</li><li>当 GetUrlContentLengthAsync 方法得到字符串结果时，该方法可以计算该字符串的长度。然后，GetUrlContentLengthAsync 的工作也就完成了，等待的事件处理程序就可以继续执行了。在本文末尾的完整示例中，您可以确认事件处理程序会获取并打印长度结果的值。如果您是异步编程的新手，请花点时间思考一下同步和异步行为之间的区别。同步方法在工作完成时返回（步骤 5），而异步方法在工作暂停时返回任务值（步骤 3 和 6）。当异步方法最终完成其工作时，该任务会被标记为已完成，并且如果有结果的话，结果会存储在任务中。</li></ol><h3>API 异步方法</h3><p>您可能会想知道如何才能找到像 GetStringAsync 这样支持异步编程的方法。.NET Framework 4.5 或更高版本以及 .NET Core 包含了许多与异步和等待相关的成员。可以通过成员名称后附加的 “Async” 后缀以及它们的返回类型为 Task 或 Task &lt; TResult &gt; 来识别这些方法。例如，System . IO . Stream 类除了同步方法 CopyTo、Read 和 Write 之外，还包含诸如 CopyToAsync、ReadAsync 和 WriteAsync 这样的异步方法。</p><p>Windows 运行时还包含许多可在 Windows 应用程序中与 async 和 await 结合使用的方法。</p><h3>线程</h3><p>异步方法旨在实现非阻塞操作。在异步方法中使用 “await” 表达式时，在等待的任务运行期间不会阻塞当前线程。相反，该表达式会将方法的剩余部分注册为一个延续，并将控制权返回给异步方法的调用者。<br/>“async” 和 “await” 这两个关键字并不会创建额外的线程。异步方法不需要多线程，因为异步方法并非在自己的线程上运行。该方法会在当前的同步上下文中运行，并且仅在方法处于活动状态时才在该线程上使用时间。您可以使用 “Task . Run” 将 CPU 密集型工作转移到后台线程，但后台线程对于仅仅在等待结果可用的过程并无帮助。</p><p>基于异步编程的这种方法在几乎所有情况下都优于现有的方法。特别是对于 I/O 密集型操作，这种方法比 BackgroundWorker 类更优，因为其代码更简洁，而且无需防范竞争条件。与 Task . Run 方法结合使用时，异步编程在 CPU 密集型操作中优于 BackgroundWorker，因为异步编程将运行代码的协调细节与 Task . Run 转移到线程池的工作分离开来。</p><h3>async 与 await</h3><p>如果您通过使用 “async” 修饰符来指定一个方法为异步方法，那么您就启用了以下两种功能。</p><ul><li>带有标记的异步方法可以使用 “await” 来指定暂停点。“await” 操作符告知编译器，在异步操作完成之前，该异步方法不能继续执行到该点之后的部分。在此期间，控制权会返回给异步方法的调用者。<br/>在 “await” 表达式处对异步方法的暂停并不意味着方法的结束，而且最终的阻塞操作也不会执行。</li><li>带有 “async” 标记的方法本身可以被调用该方法的其他方法进行等待操作。</li></ul><p>异步方法通常会包含一个或多个 “await” 运算符的使用，但缺少 “await” 表达式并不会导致编译错误。如果一个异步方法没有使用 “await” 运算符来标记暂停点，那么该方法的执行方式就如同同步方法一样，尽管有 “async” 修饰符的存在。对于这类方法，编译器会发出警告。</p><p>“async” 和 “await” 是具有特定含义的关键词。</p><h3>返回类型和参数</h3><p>异步方法通常会返回一个 Task 或者是一个 Task &lt; TResult &gt;。在异步方法内部，会将一个 await 运算符应用于从调用另一个异步方法所返回的任务上。</p><p>如果方法中包含一个返回语句，并且该语句所指定的运算符类型为 TResult，则您应将 Task &lt; TResult &gt; 作为返回类型进行指定。</p><p>如果方法没有返回语句，或者其返回语句所返回的值并非操作数，则您应将 “Task” 作为返回类型。</p><p>您还可以指定任何其他返回类型，前提是该类型包含一个 “GetAwaiter” 方法。例如 “ValueTask &lt; TResult &gt;” 就是这种类型的示例。它可在 “System . Threading . Tasks . Extension” 这个 NuGet 包中找到。</p><p>以下示例展示了如何声明并调用一个返回类型为 Task &lt; TResult &gt; 或 Task 的方法：</p><pre><code class="C#">async Task&lt;int&gt; GetTaskOfTResultAsync ( )
{
    int hours = 0;
    await Task . Delay ( 0 );

    return hours;
}

Task&lt;int&gt; returnedTaskTResult = GetTaskOfTResultAsync ( );
int intResult = await returnedTaskTResult;
// 单行
// int intResult = await GetTaskOfTResultAsync ( );

async Task GetTaskAsync ( )
    {
        await Task . Delay ( 0 );
        // 无需 return 语句
    }

Task returnedTask = GetTaskAsync ( );
await returnedTask;
// 单行
await GetTaskAsync ( );</code></pre><p>每个返回的任务都代表着正在进行的工作。任务封装了异步进程状态的信息，并且最终要么包含该进程的最终结果，要么包含进程未成功时引发的异常。</p><p>异步方法也可以具有 void 返回类型。这种返回类型主要用于定义事件处理程序，在这种情况下需要 void 返回类型。异步事件处理程序通常是异步程序的起点。</p><p>具有 void 返回类型的异步方法不能被等待，而且调用 void 类型返回的方法的调用者无法捕获该方法抛出的任何异常。</p><p>异步方法不能声明 in、ref 或 out 参数，但该方法可以调用具有此类参数的方法。同样，异步方法不能通过引用返回值，尽管它可以调用具有 ref 返回值的方法。</p><p>在 Windows 运行时编程中，异步 API 具有以下返回类型之一，这些类型类似于任务：</p><ul><li>IAsyncOperation &lt; TResult &gt;，对应于 Task &lt; TResult &gt;</li><li>IAsyncAction，对应于 Task</li><li>IAsyncActionWithProgress &lt; TProgress &gt;</li><li>IAsyncOperationWithProgress &lt; TResult , TProgress &gt;</li></ul><h3>命名约定</h3><p>按照惯例，返回常见可等待类型（例如 Task、Task &lt; T &gt;、ValueTask、ValueTask &lt; T &gt;）的方法，其名称应以 “Async”（我习惯 YB） 结尾。启动异步操作但不返回可等待类型的方法不应以 “Async” 结尾，但可以以 “Begin”、“Start” （我习惯 QS）或其他动词开头，以表明此方法不会返回或抛出操作的结果。</p><p>您可以忽略事件、基类或接口契约所暗示的不同名称的约定。例如，不应重命名常见的事件处理程序，如 OnButtonClick。</p><h2>Async 返回类型</h2><p>异步方法可以有以下返回类型：</p><ul><li>Task，用于执行操作但不返回值的异步方法。</li><li>Task &lt; TResult &gt;，适用于返回值的异步方法。</li><li>void，用于事件处理程序。</li><li>任何具有可访问的 GetAwaiter 方法的类型。GetAwaiter 方法返回的对象必须实现System . Runtime . CompilerServices . ICriticalNotifyCompletion 接口。</li><li>IAsyncEnumerable &lt; T &gt;，用于返回异步流的异步方法。</li></ul><p>还存在其他几种特定于Windows工作负载的类型：</p><ul><li>DispatcherOperation，用于仅限 Windows 的异步操作。</li><li>IAsyncAction，用于通用 Windows平台（UWP）应用中不返回值的异步操作。</li><li>IAsyncActionWithProgress &lt; TProgress &gt;，用于通用 Windows 平台（UWP）应用中报告进度但不返回值的异步操作。</li><li>IAsyncOperation &lt; TResult &gt;，用于通用 Windows 平台（UWP）应用中返回值的异步操作。</li><li>IAsyncOperationWithProgress &lt; TResult , TProgress &gt;，用于在 UWP 应用中报告进度并返回值的异步操作。</li></ul><h3>Task 返回类型</h3><p>不包含 return 语句或包含不返回操作数的 return 语句的异步方法，其返回类型通常为 Task。如果这些方法同步运行，则返回 void。如果为异步方法使用 Task 返回类型，调用方法可以使用 await 运算符暂停调用方的完成，直到被调用的异步方法完成。</p><p>在下面的示例中，WaitAndApologizeAsync 方法不包含 return 语句，因此该方法返回一个 Task 对象。返回 Task 使 WaitAndApologizeAsync 能够被等待。Task 类型不包含 Result 属性，因为它没有返回值。</p><pre><code class="C#">await FF等待并道歉YB ( );

Console . WriteLine ( $"今天是：{DateTime . Now:D}" );
Console . WriteLine ( $"当前时间：{DateTime . Now:t}" );
Console . WriteLine ( "当前气温：10 ℃。" );

static async Task FF等待并道歉YB ( )
    {
        await Task . Delay ( 2000 );
        Console . WriteLine ( "对不起，让你久等了……\n" );
    }</code></pre><p>FF等待并道歉 通过使用 await 语句而非 await 表达式来等待，这与调用同步 void 返回方法的语句类似。在这种情况下，应用 await 运算符不会产生值。当 await 的右操作数是 Task &lt; TResult &gt; 时，await 表达式会产生 T 类型的结果。当 await 的右操作数是 Task 时，await 及其操作数构成一个语句。</p><p>您可以将对 FF等待并道歉 的调用与 await 运算符的应用分开，如下列代码所示。但请记住，Task 没有 Result 属性，并且当 await 运算符应用于 Task 时，不会产生任何值。</p><p>以下代码将调用 FF等待并道歉 方法与等待该方法返回的任务分离开来。</p><pre><code class="C#">Task RW等待并道歉 = FF等待并道歉YB ( );

string ShuChu = $"今天是：{DateTime . Now:D}\n当前时间：{DateTime . Now:t}\n当前气温：10 ℃。";

await RW等待并道歉;
Console . WriteLine ( ShuChu );

static async Task FF等待并道歉YB ( )
    {
        await Task . Delay ( 2000 );
        Console . WriteLine ( "对不起，让你久等了……\n" );
    }</code></pre><h3>Task &lt; TResult &gt; 返回类型</h3><p>Task &lt; TResult &gt; 返回类型用于异步方法，该方法包含 return 语句，且该语句的操作数为 TResult。</p><p>在下面的示例中，FF获取空闲时间YB 方法包含一个 return 语句，该语句返回一个整数。方法声明必须指定返回类型为 Task &lt; int &gt;。FromResult 异步方法是一个占位符，用于返回 DayOfWeek 的操作。</p><pre><code class="C#">string xinxi = $"今天是 {DateTime . Now:dddd}，今天的空闲时间：\n    {await FF获取空闲时间YB ( )} 小时。";
Console . WriteLine ( xinxi );

static async Task&lt;int&gt; FF获取空闲时间YB ( )
    {
        DayOfWeek jt = await Task . FromResult ( DateTime . Now . DayOfWeek );
        int Z空闲小时 =
            jt is DayOfWeek.Sunday || jt is DayOfWeek.Saturday ? 16 : 5;
        return Z空闲小时;
    }</code></pre><p>当在 Main ( ) 方法的 await 表达式中调用 FF获取空闲时间YB 时，该 await 表达式会检索由 FF获取空闲时间YB 方法返回的任务中存储的整数值（即 Z空闲小时 的值）。</p><p>通过将对 FF获取空闲时间YB 的调用与 await 的应用分开，你可以更好地理解 await 如何从 Task &lt; T &gt; 中检索结果，如下列代码所示。正如从方法声明中所预期的那样，调用未立即等待的 FF获取空闲时间YB 方法会返回一个 Task &lt; int &gt;。在示例中，该任务被分配给 rw获取空闲时间 变量。由于 rw获取空闲时间 是 Task &lt; TResult&gt;，它包含一个类型为 TResult 的 Result 属性。在这种情况下，TResult 表示整数类型。当将 await 应用于 rw获取空闲时间 时，await 表达式的计算结果为 rw获取空闲时间 的 Result 属性的内容。该值被分配给 ret 变量。</p><p><strong>重要提示</strong>：Result 属性是一个阻塞属性。如果在其任务完成之前尝试访问它，当前活动的线程会被阻塞，直到任务完成且值可用。在大多数情况下，你应该使用 await 来访问该值，而不是直接访问该属性。前面的示例检索了 Result 属性的值以阻塞主线程，这样 Main 方法就能在应用程序结束前将 xinxi 打印到控制台。</p><pre><code class="C#">var rw获取空闲时间 = FF获取空闲时间YB ( );
string xinxi = $"今天是 {DateTime . Now:dddd}，今天的空闲时间：\n    {await rw获取空闲时间} 小时。";
Console . WriteLine ( xinxi );</code></pre><h3>void 返回类型</h3><p>在异步事件处理程序中，你会使用 void 返回类型，这类处理程序要求使用 void 返回类型。对于非事件处理程序且不返回值的方法，你应该返回 Task，因为返回 void 的异步方法无法被等待。此类方法的任何调用方都必须在不等待被调用的异步方法完成的情况下继续执行直至结束。调用方必须不受该异步方法生成的任何值或异常的影响。</p><p>返回 void 的异步方法的调用者无法捕获该方法抛出的异常。此类未处理的异常可能会导致应用程序失败。如果返回 Task 或 Task &lt; TResult &gt; 的方法抛出异常，该异常会存储在返回的任务中。等待任务时，异常会被重新抛出。请确保任何可能产生异常的异步方法都具有 Task 或 Task &lt; TResult &gt; 的返回类型，并且对该方法的调用是被等待的。</p><p>以下示例展示了异步事件处理程序的行为。在示例代码中，异步事件处理程序必须在完成时通知主线程。这样，主线程可以在退出程序前等待异步事件处理程序完成。</p><pre><code class="C#">await LEIAsyncVoid示例 . JuBings多事件YB ( );

public class ANN单纯
    {
        public event EventHandler? DanJiLe;

        public void DanJi ( )
            {
                Console . WriteLine ( "有人按下了按钮。让我们启动这个事件吧……" );
                DanJiLe? . Invoke ( this , EventArgs . Empty );
                Console . WriteLine ( "所有监听者均已收到通知。" );
            }
    }

public class LEIAsyncVoid示例
    {
        static readonly TaskCompletionSource&lt;bool&gt; TCS任务完成源 = new ( );

        public static async Task JuBings多事件YB ( )
            {
                Task&lt;bool&gt; RW第二个句柄结束 = TCS任务完成源 . Task;

                var AnNiu = new ANN单纯 ( );

                AnNiu . DanJiLe += OnAnnDanJi1;
                AnNiu . DanJiLe += OnAnnDanJi2YB;
                AnNiu . DanJiLe += OnAnnDanJi3;

                Console . WriteLine ( "在 AnNiu . DanJiLe ( ) 被调用之前……" );
                AnNiu . DanJi ( );
                Console . WriteLine ( "在 AnNiu . DanJiLe ( ) 被调用之后……" );

                await RW第二个句柄结束;
        }

private static void OnAnnDanJi1 ( object? sender , EventArgs e )
    {
        Console . WriteLine ( "……句柄 1 启动……" );
        Task . Delay ( 100 ) . Wait ( );
        Console . WriteLine ( "……句柄 1 结束。" );
    }

private static async void OnAnnDanJi2YB ( object? sender , EventArgs e )
    {
        Console . WriteLine ( "……句柄 2 启动……" );
        Task . Delay ( 100 ) . Wait ( );
        Console . WriteLine ( "……句柄 2 即将转为异步模式……" );
        await Task . Delay ( 500 );
        Console . WriteLine ( "……句柄 2 结束。" );
        TCS任务完成源 . SetResult ( true );
    }

private static void OnAnnDanJi3 ( object? sender , EventArgs e )
    {
        Console . WriteLine ( "……句柄 3 启动……" );
        Task . Delay ( 100 ) . Wait ( );
        Console . WriteLine ( "……句柄 3 结束。" );
    }
}</code></pre><h3>泛化异步返回类型和 ValueTask &lt; TResult &gt;</h3><p>异步方法可以返回任何类型，只要该类型具有可访问的 GetAwaiter 方法，且该方法返回等待器类型的实例。此外，返回的类型必须与 SetResult 的参数类型以及由 System . Runtime . CompilerServices . AsyncMethodBuilderAttribute 特性指定的类型上的 Task 属性的返回类型相匹配。</p><p>此功能是对 awaitable experssions（可等待表达式）的补充，后者描述了 await 操作数的要求。泛化异步返回类型使编译器能够生成返回不同类型的 async 方法。泛化异步返回类型为 .NET 库带来了性能提升。由于 Task 和 Task &lt; TResult &gt; 是引用类型，在性能关键路径中的内存分配（尤其是在紧凑循环中发生的分配）可能会对性能产生不利影响。对泛化返回类型的支持意味着你可以返回轻量级值类型而非引用类型，以避免更多的内存分配。</p><p>.NET 提供了 System . Threading . Tasks . ValueTask &lt; TResult &gt; 结构，作为广义任务返回值的轻量级实现。以下示例使用 ValueTask &lt; TResult &gt; 结构来获取两次掷骰子的结果值。</p><pre><code class="C#">await FF掷色子结果YB ( );

static async Task FF掷色子结果YB ( )
    {
    Console . WriteLine ( $"你掷出了 {await FF摇色子YB ( )}" );
    }

static async ValueTask&lt;int&gt; FF摇色子YB ( )
    {
    Console . WriteLine ( "摇色子中……" );

    int SZ1 = await FF摇YB ( );
    int SZ2 = await FF摇YB ( );

    return SZ1 + SZ2;
    }

static async ValueTask&lt;int&gt; FF摇YB ( )
    {
    await Task . Delay ( 500 );
    Random SJS = new ( );
    int Z色子数 = SJS . Next ( 1 , 7 );
    return Z色子数;
    }</code></pre><p>编写通用的异步返回类型是一种高级场景，适用于特定环境。可以考虑改用 &lt; Task &gt;、&lt; Task &lt; T &gt; &gt; 和 &lt; ValueTask &lt; T &gt; &gt; 类型，它们涵盖了大多数异步代码场景。</p><p>你可以将 AsyncMethodBuilder 特性应用于异步方法（而非异步返回类型声明），以覆盖该类型的生成器。通常，你会应用此特性来使用 .NET 运行时中提供的不同生成器。</p><h3>使用 IAsyncEnumerable &lt; T &gt; 的异步流</h3><p>异步方法可能会返回一个异步流，由 IAsyncEnumerable &lt; T &gt; 表示。当通过重复的异步调用以块的形式生成元素时，异步流提供了一种枚举从流中读取的项的方式。以下示例展示了一个生成异步流的异步方法：</p><pre><code class="C#">{
    static async Task Main ( string [ ] args )
        {
            await foreach ( string ci in ReadWordsAsync ( ) )
                Console.Write ( $"{ci}    " );
        }

    public static async IAsyncEnumerable&lt;string&gt; FF读词YB ( )
        {
            string zfc = @"This is a line of text.
              Here is the second line of text.
              And there is one more for good measure.
              Wait, that was the penultimate line.";

            using var LD = new StringReader ( zfc );

            string? zfc行 = await LD . ReadLineAsync ( );
            while ( zfc行 != null )
                {
                    foreach ( string ci in zfc行 . Split ( ' ' , StringSplitOptions . RemoveEmptyEntries ) )
                        {
                            yield return ci;
                        }

                    zfc行 = await reader . ReadLineAsync ( );
                }
        }
    }</code></pre><p>前面的示例异步读取字符串中的行。每读取一行后，代码就会枚举该字符串中的每个单词。调用方会使用 await foreach 语句来枚举每个单词。当需要从源字符串异步读取下一行时，该方法会进行等待。</p><h2>在任务完成时处理异步任务</h2><p>通过使用 Task . WhenAny，你可以同时启动多个任务，并在它们完成时逐个处理，而不是按照启动顺序来处理。</p><p>以下示例使用查询创建一个任务集合。每个任务都会下载指定网站的内容。在 while 循环的每次迭代中，对 WhenAny 的等待调用会返回任务集合中最先完成下载的任务。该任务会从集合中移除并进行处理。循环会重复执行，直到集合中不再有任务为止。</p><h3>创建示例应用程序</h3><p>创建一个 .NET Core Console 应用程序。在其首部添加一个 using 语句：<br/><code> using System . Diagnostics; </code></p><h3>添加字段</h3><p>在 Program 类定义中，添加以下两个字段：</p><pre><code class="C#">static readonly HttpClient wlkh = new ( )
    {
        MaxResponseContentBufferSize = 1_000_000
    };

static readonly IEnumerable&lt;string&gt; zfcURLs = 
    [
            "https://learn.microsoft.com",
            "https://learn.microsoft.com/aspnet/core",
            "https://learn.microsoft.com/azure",
            "https://learn.microsoft.com/azure/devops",
            "https://learn.microsoft.com/dotnet",
            "https://learn.microsoft.com/dynamics365",
            "https://learn.microsoft.com/education",
            "https://learn.microsoft.com/enterprise-mobility-security",
            "https://learn.microsoft.com/gaming",
            "https://learn.microsoft.com/graph",
            "https://learn.microsoft.com/microsoft-365",
            "https://learn.microsoft.com/office",
            "https://learn.microsoft.com/powershell",
            "https://learn.microsoft.com/sql",
            "https://learn.microsoft.com/surface",
            "https://learn.microsoft.com/system-center",
            "https://learn.microsoft.com/visualstudio",
            "https://learn.microsoft.com/windows",
            "https://learn.microsoft.com/maui"
    ];</code></pre><p>HttpClient 提供发送 HTTP 请求和接收 HTTP 响应的功能。zfcURLs 存储应用程序计划处理的所有 URL。</p><h3>添加处理方法</h3><p>在 FF页面求和YB 方法前面添加以下 FF处理URLYB 方法：</p><pre><code class="C#">static async Task &lt;int&gt; FF处理URLYB ( string url , HttpClient 客户端 )
    {
        try
            {
                byte [ ] ZhuTi = await 客户端 . GetByteArrayAsync ( url );
                Console . WriteLine ( $"{url,-60} {ZhuTi . Length,10:#,#}" );

                return ZhuTi . Length;
            }
        catch ( Exception ex )
            {
                Console . WriteLine ( $"{url} - {ex . Message}" );
                return 0;
            }
    }</code></pre><p>对于任何给定的 URL，该方法将使用提供的 客户端 实例以 byte [ ] 的形式获取响应。在 URL 和长度写入控制台后，会返回该长度。</p><p>多次运行该程序，以验证下载的长度并非总是按相同顺序出现。</p><p><strong>注意</strong>：如示例中所述，你可以在循环中使用 WhenAny 来解决涉及少量任务的问题。但是，如果你有大量任务需要处理，其他方法会更高效。</p><h3>创建异步求和页面大小的方法</h3><p>在 Main 方法下方，添加 FF页面求和YB 方法：</p><pre><code class="C#">static async Task FF页面求和YB ( )
    {
        var biao = Stopwatch . StartNew ( );
        IEnumerable &lt;Task&lt;int&gt;&gt; CHX下载任务 =
            from url in zfcURLs
            select FF处理URLYB ( url , wlkh );
    }</code></pre><p>while 循环在每次迭代中移除一个任务。所有任务完成后，循环结束。该方法首先实例化并启动一个 Stopwatch。然后它包含一个查询，执行该查询时会创建一个任务集合。以下代码中对 FF处理URLYB 的每次调用都会返回一个 Task &lt; TResult &gt;，其中 TResult 是一个整数：</p><pre><code class="C#">IEnumerable&lt;Task&lt;int&gt;&gt; CHX下载任务int =
    from url in zfcURLs
    select FF处理URLYB ( url , wlkh );</code></pre><p>由于 LINQ 采用延迟执行，因此需要调用 Enumerable . ToList 来启动每个任务。<br/>while 循环会为集合中的每个任务执行以下步骤：</p><ol><li>等待对 WhenAny 的调用，以确定集合中第一个完成下载的任务。<br/><code> Task &lt; int &gt; rw完成 = await Task . WhenAny ( rw下载 ); </code></li><li>将该任务从集合中移除。<br/><code> rw下载 . Remove ( rw完成 ); </code></li><li><p>等待 rw完成，它由调用 FF处理URLYB 返回。rw完成 变量是一个 Task &lt; TResult &gt;，其中 TResult 是整数。该任务已经完成，但你可以等待它来获取所下载网站的长度，如下例所示。如果任务出错，await 将抛出存储在 AggregateException 中的第一个子异常，这与读取 Task &lt; TResult &gt; . Result 属性不同，后者会抛出 AggregateException。<br/><code> Z总数 += await rw完成; </code></p><h3>使用 Task . WhenEach 简化该方法</h3><p>在 FF页面求和YB 方法中实现的 while 循环可以通过在 await foreach 循环中调用 .NET 9 中引入的新 Task . WhenEach 方法来简化。</p></li></ol><p>替换之前实现的 while 循环：</p><pre><code class="C#">while ( rw下载 . Count != 0 )
    {
        Task&lt;int&gt; rw完成 = await Task . WhenAny ( rw下载 );
        rw下载 . Remove ( rw完成 );
        Z总数 += await rw完成;
    }</code></pre><p>使用简化的 await foreach：</p><pre><code class="C#">await foreach ( Task &lt;int&gt; rw in Task . WhenEach ( rw下载 ) )
    {
        Z总数 += await rw;
    }</code></pre><p>这种新方法不再需要反复调用 Task . WhenAny 来手动调用任务并移除已完成的任务，因为 Task . WhenEach 会按照任务完成的顺序对其进行迭代。</p><h3>更新应用程序入口点</h3><p>控制台应用程序的主要入口点是 Main 方法。将现有方法替换为以下内容：<br/><code> static Task Main ( ) =&gt; FF页面求和YB ( ); </code><br/>更新后的 Main 方法现在被视为异步主方法，它允许以异步方式进入可执行文件。它表现为对 FF页面求和YB 的调用。</p><h3>完整代码</h3><pre><code class="C#">internal class Program
    {

        static readonly HttpClient wlkh = new ( )
            {
            MaxResponseContentBufferSize = 1_000_000
            };

        static readonly IEnumerable&lt;string&gt; zfcURLs = 
            [
                "https://learn.microsoft.com",
                "https://learn.microsoft.com/aspnet/core",
                "https://learn.microsoft.com/azure",
                "https://learn.microsoft.com/azure/devops",
                "https://learn.microsoft.com/dotnet",
                "https://learn.microsoft.com/dynamics365",
                "https://learn.microsoft.com/education",
                "https://learn.microsoft.com/enterprise-mobility-security",
                "https://learn.microsoft.com/gaming",
                "https://learn.microsoft.com/graph",
                "https://learn.microsoft.com/microsoft-365",
                "https://learn.microsoft.com/office",
                "https://learn.microsoft.com/powershell",
                "https://learn.microsoft.com/sql",
                "https://learn.microsoft.com/surface",
                "https://learn.microsoft.com/system-center",
                "https://learn.microsoft.com/visualstudio",
                "https://learn.microsoft.com/windows",
                "https://learn.microsoft.com/maui"
            ];

    static Task Main ( ) =&gt; FF页面求和YB ( );

    static async Task FF页面求和YB ( )
        {
            var biao = Stopwatch . StartNew ( );

            IEnumerable &lt;Task&lt;int&gt;&gt; CHX下载任务 =
                from url in zfcURLs
                select FF处理URLYB ( url , wlkh );

            List &lt;Task&lt;int&gt;&gt; rw下载 = [ .. CHX下载任务 ];
            int Z总数 = 0;
            await foreach ( Task &lt;int&gt; rw in Task . WhenEach ( rw下载 ) )
                {
                Z总数 += await rw;
                }

            biao . Stop ( );
            Console . WriteLine ( $"\n返回总字节数：{Z总数:#,#}" );
            Console . WriteLine ( $"经历时间：          {biao . Elapsed}\n" );
    }

    static async Task &lt;int&gt; FF处理URLYB ( string url , HttpClient 客户端 )
        {
            try
                {
                byte [ ] ZhuTi = await 客户端 . GetByteArrayAsync ( url );
                Console . WriteLine ( $"{url,-60} {ZhuTi . Length,10:#,#}" );

                return ZhuTi . Length;
            }
        catch ( Exception ex )
            {
                Console . WriteLine ( $"{url} - {ex . Message}" );
                return 0;
            }
        }
    }</code></pre><h2>异步文件访问</h2><p>你可以使用异步功能来访问文件。通过使用异步功能，你可以调用异步方法，而无需使用回调或将代码拆分到多个方法或 lambda 表达式中。要将同步代码变为异步，只需调用异步方法而非同步方法，并在代码中添加几个关键字即可。</p><p>您可能会考虑为文件访问调用添加异步性的以下原因：</p><ul><li>异步处理让 UI 应用程序的响应性更强，因为启动操作的 UI 线程可以执行其他工作。如果 UI 线程必须执行耗时较长的代码（例如，超过 50 毫秒），UI可能会冻结，直到 I/O 操作完成，UI 线程才能再次处理键盘和鼠标输入以及其他事件。</li><li>异步通过减少对线程的需求，提高了 ASP . NET 和其他基于服务器的应用程序的可扩展性。如果应用程序为每个响应使用一个专用线程，并且同时处理 1,000 个请求，那么就需要 1,000 个线程。异步操作在等待期间通常不需要使用线程，它们在结束时会短暂使用现有的 I/O 完成线程。</li><li>在当前条件下，文件访问操作的延迟可能非常低，但未来延迟可能会大幅增加。例如，某个文件可能会被转移到位于世界另一端的服务器上。</li><li>使用异步功能所增加的开销很小。</li><li>异步任务可以轻松并行运行。</li></ul><h3>使用适当的类</h3><p>本主题中的简单示例展示了 File . WriteAllTextAsync 和 File . ReadAllTextAsync。要对文件 I/O 操作进行精细控制，请使用 FileStream 类，该类提供了一个选项，可使异步 I/O 在操作系统级别发生。通过使用此选项，在许多情况下可以避免阻塞线程池线程。要启用此选项，请在构造函数调用中指定 useAsync = true 或 options = FileOptions . Asynchronous 参数。</p><p>如果通过指定文件路径直接打开 StreamReader 和 StreamWriter，则不能使用此选项。但是，如果为它们提供 FileStream 类打开的 Stream，则可以使用此选项。在 UI 应用程序中，即使线程池线程被阻塞，异步调用也会更快，因为等待期间 UI 线程不会被阻塞。</p><h3>撰写文本</h3><p>以下示例向文件写入文本。在每个 await 语句处，方法会立即退出。当文件 I/O 完成后，方法会从 await 语句后的那条语句继续执行。async 修饰符用于定义使用 await 语句的方法。</p><pre><code class="C#">static async Task FF写入点什么YB ( )
    {
    string zfc路径 = @"F:\测试文件夹\异步写入.txt";
    string zfc = "随便写点什么";

    await File . WriteAllTextAsync ( zfc路径 , zfc );
    }</code></pre><h3>有限控制示例</h3><pre><code class="C#">static async Task FF写点复杂的YB ( string 路径 , string 文本 )
    {
    try
        {
        if ( Directory . Exists ( 路径 ) )
            {
            try
                {
                byte [ ] bianmawenben = Encoding . UTF8 . GetBytes ( 文本 );
                using var liu =
                    new FileStream (
                        Path .Combine ( 路径 , "复杂文本.txt" ),
                        FileMode . Create , FileAccess . Write , FileShare . None,
                        bufferSize: 4096,
                        useAsync: true);
                await liu . WriteAsync ( bianmawenben , 0 , bianmawenben . Length );
                }
            catch ( Exception ex )
                {
                Console . WriteLine ( ex . Message );
                }
            }
        else throw new DirectoryNotFoundException ( "文件路径不存在……" );
        }
    catch ( Exception ex ) { Console . WriteLine ( ex . Message ); }
    }</code></pre><p>原始示例中有语句 <code>await liu . WriteAsync ( bianmawenben , 0 , bianmawenben . Length );</code>，它是以下两个语句的缩写：</p><pre><code class="C#">Task rw = liu . WriteAsync ( bianmawenben , 0 , bianmawenben . Length );
await rw;</code></pre><p>第一个语句返回一个任务，并启动文件处理。带有 await 的第二个语句会导致该方法立即退出并返回一个不同的任务。当文件处理稍后完成时，执行会返回到 await 后面的语句。</p><h3>阅读文本</h3><p>以下示例从文件中读取文本。</p><h4>简单示例</h4><pre><code class="C#">static async Task FF读取YB ( )
    {
    string zfc路径 = @"F:\测试文件夹\异步写入.txt";
    string zfc = await File . ReadAllTextAsync ( zfc路径 );
    Console . WriteLine ( zfc );
    }</code></pre><h4>有限控制示例</h4><p>文本会被缓冲，在这种情况下，会被放入一个 StringBuilder 中。与前面的示例不同，await 的求值会产生一个值。ReadAsync 方法返回一个 Task &lt; Int32 &gt;，因此在操作完成后，await 的求值会产生一个 Int32 值 Z读取。</p><pre><code class="C#">static async Task &lt;string&gt; FF读文本YB ( string 文件路径 )
    {
    using var liu =
        new FileStream (
            文件路径,
            FileMode . Open , FileAccess . Read , FileShare.Read,
            4096 , true );

    StringBuilder zc = new ( );
    byte [ ] huanchongqu = new byte [ 0x1000 ];
    int Z读取;

    while ( ( Z读取 = await liu . ReadAsync ( huanchongqu , 0 , huanchongqu . Length ) ) != 0 )
        {
        string zfc = Encoding . UTF8 . GetString ( huanchongqu , 0 , Z读取 );
        zc . Append ( zfc );
        }

    return zc . ToString ( );
    }

static async Task FF复杂读取YB ( string 路径 , string 文件名 )
    {
    try
        {
        if ( Directory . Exists ( 路径 ) == false )
            { throw new DirectoryNotFoundException ( $"{路径} 不存在，请检查" ); }

        string zfc完整路径 = Path . Combine ( 路径 , 文件名 );

        if ( File . Exists ( zfc完整路径 ) == false )
            { throw new FileNotFoundException ( $"{zfc完整路径} 不存在，请检查" ); }

        string wb = await FF读文本YB ( zfc完整路径 );
        Console . WriteLine ( wb );
        }
    catch ( DirectoryNotFoundException ljyc )
        { Console . WriteLine ( ljyc . ToString ( ) );}
    catch ( FileNotFoundException wjyc )
        { Console . WriteLine ( wjyc . ToString ( ) ); }
    catch ( Exception yc )
    { Console . WriteLine ( yc . ToString ( ) ); }
    }</code></pre><h3>并行异步 I/O</h3><p>以下示例通过写入 10 个文本文件来演示并行处理。</p><h4>简单示例</h4><pre><code class="C#">static async Task FF简单的并行写入YB ( )
    {
    string zfc文件夹= Directory . CreateDirectory ( @"F:\测试文件夹\并行写入" ) . FullName;
    IList&lt;Task&gt; lb写任务 = [ ];

    for ( int sy = 11 ; sy &lt;=20 ; ++ sy )
        {
        string zfc文件名 = $"{sy} - 文本.txt";
        string zfc文件 = Path . Combine ( zfc文件夹 , zfc文件名 );
        string wb = $"在 {sy} 文件中……{Environment . NewLine}";

        lb写任务 . Add ( File . WriteAllTextAsync ( zfc文件 , wb ) );
        }
    await Task . WhenAll ( lb写任务 );
    }</code></pre><h4>有限控制示例</h4><p>对于每个文件，WriteAsync 方法会返回一个任务，该任务随后会被添加到任务列表中。await Task . WhenAll ( lb写任务 ); 语句会退出该方法，并在所有任务的文件处理完成后在该方法内恢复执行。</p><p>该示例在任务完成后，在 finally 块中关闭了所有 FileStream 实例。如果每个 FileStream 都是在 using 语句中创建的，那么 FileStream 可能会在任务完成前就被释放。</p><p>任何性能提升几乎完全来自并行处理，而非异步处理。异步的优势在于它不会占用多个线程，也不会占用用户界面线程。</p><pre><code class="C#">static async Task FF复杂并行写入YB ( )
    {
    IList &lt;FileStream&gt; LIUs = [ ];

    try
        {
        string zfc文件夹 = Directory . CreateDirectory ( @"F:\测试文件夹\复杂并行写入" ) . FullName;
        IList &lt;Task&gt; lb写任务 = [ ];
        for ( int sy = 100 ; sy &lt;= 110 ; ++sy )
            {
            try
                {
                string zfc文件名 = $"{sy} 号文件.txt";
                string zfc文件 = Path . Combine ( zfc文件夹 , zfc文件名 );
                string wb = $"在第 {sy} 号文件中……";
                byte [ ] wb编码 = Encoding . UTF8 . GetBytes ( wb );
                var Liu =
                    new FileStream (
                        zfc文件,
                        FileMode . Create , FileAccess . Write , FileShare.None ,
                        4096 , true );
                Task rw写 = Liu . WriteAsync ( wb编码 , 0 , wb编码 . Length );
                LIUs . Add ( Liu );
                lb写任务 . Add ( rw写 );
                }
            catch ( Exception ex ) { Console . WriteLine ( ex . Message ); }
            }
        await Task . WhenAll ( lb写任务 );
        }
    finally
        {
        foreach ( var L in LIUs )
            {
            L . Close ( );
            }
        }
    }</code></pre><p>使用 WriteAsync 和 ReadAsync 方法时，你可以指定一个 CancellationToken，通过它可以在操作进行中取消该操作。</p><h2>取消任务列表</h2><p>如果不想等待异步控制台应用程序完成，可以将其取消。按照本主题中的示例，你可以为一个下载网站列表内容的应用程序添加取消功能。通过将 CancellationTokenSource 实例与每个任务相关联，你可以取消多个任务。如果按下 Enter 键，所有尚未完成的任务都会被取消。</p><h3>替换 using 指令</h3><p>新建一个 Console 应用程序，并添加下列 using 语句：</p><pre><code class="C#">using System;
using System . Collections . Generic;
using System . Diagnostics;
using System . Net . Http;
using System . Threading;
using System . Threading . Tasks;</code></pre><h3>添加字段</h3><p>在 Program 类定义中，添加这三个字段：</p><pre><code class="C#">CancellationTokenSource quxiaoyuan = new ( );

HttpClient wlkh = new ( )
    {
    MaxResponseContentBufferSize = 1_000_000
    };

IEnumerable&lt;string&gt; LBURLs =
[
    "https://learn.microsoft.com",
    "https://learn.microsoft.com/aspnet/core",
    "https://learn.microsoft.com/azure",
    "https://learn.microsoft.com/azure/devops",
    "https://learn.microsoft.com/dotnet",
    "https://learn.microsoft.com/dynamics365",
    "https://learn.microsoft.com/education",
    "https://learn.microsoft.com/enterprise-mobility-security",
    "https://learn.microsoft.com/gaming",
    "https://learn.microsoft.com/graph",
    "https://learn.microsoft.com/microsoft-365",
    "https://learn.microsoft.com/office",
    "https://learn.microsoft.com/powershell",
    "https://learn.microsoft.com/sql",
    "https://learn.microsoft.com/surface",
    "https://learn.microsoft.com/system-center",
    "https://learn.microsoft.com/visualstudio",
    "https://learn.microsoft.com/windows",
    "https://learn.microsoft.com/maui"
];</code></pre><p>CancellationTokenSource 用于向 CancellationToken 发出请求取消的信号。HttpClient 提供发送 HTTP 请求和接收 HTTP 响应的功能。LBURL 存储应用程序计划处理的所有 URL。</p><h3>更新应用程序入口点</h3><p>控制台应用程序的主要入口点是 Main 方法。将现有方法替换为以下内容：</p><pre><code class="C#">// 程序入口点（支持异步操作）
static async Task Main(string[] args)
    {
        // 初始化取消令牌源（用于触发取消操作）
        var quxiaoyuan = new CancellationTokenSource();

        // 输出启动信息
        Console . WriteLine ( "应用程序启动：" );
        Console . WriteLine ( "按下 Enter 键取消……\n");

        // 启动用户输入监听任务（等待Enter键取消）
        var rw取消 = Task . Run ( ( ) =&gt;
            {
                // 循环监听按键，直到按下 Enter
                while ( Console . ReadKey ( true ) . Key != ConsoleKey . Enter ) // true 表示不显示按键
                    {
                        Console . WriteLine ( "按下 Enter 键取消……\n" );
                    }
                Console . WriteLine ( "正在取消下载……\n" );
                quxiaoyuan . Cancel ( ); // 触发取消信号
        });

        try
            {
                // 启动核心任务
                Task rw页面合计任务 = FF页面求和YB ( LBURLs , wlkh , LP , quxiaoyuan . Token );

                // 等待两个任务中的任意一个完成（核心任务完成 或 取消任务触发）
                await Task . WhenAny ( rw页面合计任务 , rw取消 );

                // 判断哪个任务先完成
                if ( rw页面合计任务 . IsCompleted )
                    {
                        await rw页面合计任务; // 确保等待核心任务完成（捕获可能的异常）
                        Console . WriteLine ( "下载完成！" );
                    }
                else
                    {
                        Console . WriteLine ( "下载已取消！" );
                    }
            }
        catch ( OperationCanceledException )
            {
                Console . WriteLine ( "操作已取消" );
            }
        catch ( Exception ex )
            {
                Console . WriteLine ( $"发生错误：{ex . Message}" );
            }
        }</code></pre><p>更新后的 Main 方法现在被视为异步主方法，它允许可执行文件拥有异步入口点。该方法向控制台输出几条说明信息，然后声明一个名为 rw取消 的 Task 实例，该实例将读取控制台按键。如果按下回车键，就会调用 quxiaoyuan . Cancel ( )，这将发出取消信号。接下来，rw页面合计任务 变量由 FF页面求和YB 方法赋值。然后，这两个任务都被传递给 Task . WhenAny ( Task [ ] )，当这两个任务中的任何一个完成时，该方法就会继续执行。</p><p>下一段代码确保应用程序在取消操作处理完成前不会退出。如果第一个完成的任务是 rw取消，则会等待 FF页面求和YB。如果该任务已被取消，在等待时会抛出 System . Threading . Tasks . TaskCanceledException。这段代码会捕获该异常并打印一条消息。</p><h3>创建页面求和异步方法</h3><p>在 Main 方法下，添加 FF页面求和YB 方法：</p><pre><code class="C#">static async Task&lt;int&gt; FF页面求和YB ( IEnumerable&lt;string&gt; Urls , HttpClient 客户端 , CancellationToken 令牌 )
    {
        var biao = Stopwatch . StartNew ( );

        int Z总数 = 0;
        foreach ( string u in Urls )
            {
                int ZCD = await FF处理URLYB ( u , 客户端 , 令牌 );
                Z总数 += ZCD;
            }

        biao . Stop ( );
        Console . WriteLine ( $"\n返回总字节数：{Z总数:#,#}" );
        Console . WriteLine ( $"经历时间：          {biao . Elapsed}\n" );

        return Z总数;
    }</code></pre><p>该方法首先实例化并启动一个秒表。然后，它遍历 Urls 中的每个 URL，并调用 FF处理URLYB。在每次迭代中，令牌 被传入 FF处理URLYB 方法，代码返回一个 Task &lt; TResult &gt;，其中 TResult 是一个整数。</p><h3>添加处理 URL 方法</h3><p>在 FF页面求和YB 方法下方添加以下 FF处理URLYB 方法：</p><pre><code class="C#">static async Task &lt;int&gt; FF处理URLYB ( string Url , HttpClient 客户端 , CancellationToken 令牌 )
    {
        HttpResponseMessage xiangying = await 客户端 . GetAsync ( Url , 令牌 );
        byte [ ] ZhuTi = await xiangying . Content . ReadAsByteArrayAsync ( 令牌 );
        Console . WriteLine ( $"{Url,-60}{ZhuTi . Length,10:#,#}" );
        return ZhuTi . Length;
    }</code></pre><p>对于任何给定的 Url，该方法将使用提供的 客户端 实例以 byte [ ] 的形式获取响应。CancellationToken 实例会被传入 HttpClient . GetAsync ( String , CancellationToken ) 和 HttpContent . ReadAsByteArrayAsync ( ) 方法。令牌 用于注册请求的取消操作。在 Url 和长度被写入控制台后，将返回该长度。</p><h2>一段时间后取消异步任务</h2><p>如果不想等待异步操作完成，可以使用 CancellationTokenSource . CancelAfter 方法在一段时间后取消该操作。此方法会安排取消所有在 CancelAfter 表达式指定的时间内未完成的关联任务。</p><p>此示例在《取消任务列表（C#）》中开发的代码基础上进行了补充，用于下载网站列表并显示每个网站内容的长度。</p><h3>更新应用程序入口点</h3><p>用以下内容替换现有的 Main 方法：</p><pre><code class="C#">try
    {
    quxiaoyuan . CancelAfter ( 3500 );
    await FF页面求和YB ( LBURLs , wlkh , LP );
    }
catch ( OperationCanceledException ) { Console . WriteLine ( "\n任务取消：超时。\n" ); }
finally { quxiaoyuan . Dispose ( );  }

Console . WriteLine ( "应用程序结束。" );</code></pre><p>更新后的 Main 方法向控制台写入了一些说明信息。在 try……catch 块中，对 CancellationTokenSource . CancelAfter ( Int32 ) 的调用会安排一次取消操作。这将在一段时间后发出取消信号。</p><p>接下来，等待 FF页面求和YB 方法。如果处理所有 URL 的速度快于预定的取消操作，应用程序就会结束。但是，如果在所有 URL 处理完成之前触发了预定的取消操作，就会抛出 OperationCanceledException 异常。</p><h2>教程：使用 C# 和 .NET 生成并使用异步流</h2><p>异步流为数据流提供了模型。数据流通常会异步检索或生成元素。它们为异步流式数据源提供了一种自然的编程模型。</p><h3>运行入门应用程序</h3><p>该初始应用程序是一个控制台应用程序，它使用 GitHub GraphQL 接口检索在 dotnet/docs 存储库中编写的最新问题。首先查看初始应用程序 Main 方法的以下代码：</p><pre><code class="C#">// 按照以下步骤创建 GitHub 访问令牌
//（参考链接：https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token）
// 为你的 GitHub 访问令牌选择以下权限：
//- repo:status（仓库状态权限）
//- public_repo（公共仓库权限）
// 将以下代码中的第 3 个参数替换为你的 GitHub 访问令牌
    var key = GetEnvVariable( "GitHubKey", "你必须将你的 GitHub 密钥存储在名为 GitHubKey 的环境变量中。", "" );

    var client = new GitHubClient ( new Octokit . ProductHeaderValue ( "IssueQueryDemo" ) )
    {
        Credentials = new Octokit . Credentials ( key )
    };

    var progressReporter = new progressStatus ( ( num ) =&gt;
    {
        Console . WriteLine ( $"总共获得 {num} 个议题" );
    } );
    CancellationTokenSource cancellationSource = new CancellationTokenSource ( );

    try
    {
        var results = await RunPagedQueryAsync ( client , PagedIssueQuery , "docs" , cancellationSource . Token , progressReporter );
        foreach ( var issue in results )
            Console . WriteLine ( issue );
    }
    catch ( OperationCanceledException )
    {
        Console . WriteLine ( "作业被取消。");
    }</code></pre><p>你可以将 GitHubKey 环境变量设置为你的个人访问令牌，也可以将调用 GetEnvVariable 时的最后一个参数替换为你的个人访问令牌。如果你要与他人共享源代码，请勿将访问代码放入源代码中。绝对不要将访问代码上传到共享的源代码仓库。</p><p>创建 GitHub 客户端后，Main 中的代码会创建一个进度报告对象和一个取消令牌。这些对象创建完成后，Main 会调用 RunPagedQueryAsync 来检索最近创建的 250 个问题。该任务完成后，结果将被显示出来。</p><p>运行启动应用程序时，你可以对该应用程序的运行方式得出一些重要观察结果。你会看到从 GitHub 返回的每个页面的进度报告。你会注意到，在 GitHub 返回每个新的问题页面之前，会有一个明显的停顿。最后，只有在从 GitHub 检索完所有 10 个页面后，才会显示这些问题。</p><h3>检查实现</h3><p>这一实现揭示了为什么你会观察到上一节中讨论的行为。查看 RunPagedQueryAsync 的代码：</p><pre><code class="C#">private static async Task&lt;JArray&gt; RunPagedQueryAsync ( GitHubClient client , string queryText , string repoName , CancellationToken cancel , IProgress&lt;int&gt; progress )
{
    var issueAndPRQuery = new GraphQLRequest
    {
        Query = queryText
    };
    issueAndPRQuery . Variables [ "repo_name" ] = repoName;

    JArray finalResults = new JArray ( );
    bool hasMorePages = true;
    int pagesReturned = 0;
    int issuesReturned = 0;

    // 最多获取 10 批议题即停止，因为这些仓库规模较大：
    while ( hasMorePages &amp;&amp; ( pagesReturned++ &lt; 10 ) )
    {
        var postBody = issueAndPRQuery . ToJsonText ( );
        var response = await client . Connection . Post &lt;string&gt; ( new Uri ( "https://api.github.com/graphql" ) , postBody , "application/json" , "application/json" );

        JObject results = JObject . Parse ( response . HttpResponse . Body . ToString ( )! );

        int totalCount = ( int ) issues ( results ) [ "totalCount" ]!;
        hasMorePages = ( bool ) pageInfo ( results ) [ "hasPreviousPage" ]!;
        issueAndPRQuery . Variables [ "start_cursor" ] = pageInfo ( results ) [ "startCursor" ]! . ToString ( );
        issuesReturned += issues ( results ) [ "nodes" ]! . Count ( );
        finalResults . Merge ( issues ( results ) [ "nodes" ]! );
        progress? . Report ( issuesReturned );
        cancel . ThrowIfCancellationRequested ( );
    }
    return finalResults;

    JObject issues ( JObject result ) =&gt; ( JObject ) result [ "data" ]! [ "repository" ]! [ "issues" ]!;
    JObject pageInfo ( JObject result ) =&gt; ( JObject ) issues ( result ) [ "pageInfo" ]!;
}</code></pre><p>该方法首先要做的就是使用 GraphQLRequest 类创建 POST 对象：</p><pre><code class="C#">public class GraphQLRequest
{
    [JsonProperty("query")]
    public string? Query { get; set; }

    [JsonProperty("variables")]
    public IDictionary&lt;string , object&gt; Variables { get; } = new Dictionary&lt;string , object&gt; ( );

    public string ToJsonText() =&gt;
        JsonConvert . SerializeObject ( this );
}</code></pre><p>这有助于形成 POST 对象主体，并通过 ToJsonText 方法将其正确转换为呈现为单个字符串的 JSON，该方法会从请求主体中移除所有换行符，并使用 \（反斜杠）转义字符对其进行标记。</p><p>让我们专注于前面代码的分页算法和异步结构。RunPagedQueryAsync 方法按从最新到最旧的顺序枚举问题。它每页请求 25 个问题，并检查响应的 pageInfo 结构以继续处理上一页。这遵循了 GraphQL 对多页响应的标准分页支持。响应包含一个 pageInfo 对象，该对象包含一个 hasPreviousPages 值和一个用于请求上一页的 startCursor 值。问题位于 nodes 数组中。RunPagedQueryAsync 方法将这些节点附加到一个包含所有页面结果的数组中。</p><p>在检索并恢复一页结果后，RunPagedQueryAsync 会报告进度并检查是否有取消请求。如果已请求取消，RunPagedQueryAsync 会抛出 OperationCanceledException。</p><p>这段代码中有几个可以改进的地方。最重要的是，RunPagedQueryAsync 必须为返回的所有问题分配存储空间。本示例在 250 个问题处停止，因为检索所有未解决的问题需要更多内存来存储所有检索到的问题。支持进度报告和取消操作的协议使得该算法在初次阅读时难以理解，还涉及了更多的类型和 API。你必须通过 CancellationTokenSource 及其关联的 CancellationToken 追踪通信过程，才能理解取消请求的发出位置和批准位置。</p><h3>异步流提供了一种更好的方式</h3><p>异步流及其相关的语言支持解决了所有这些问题。生成序列的代码现在可以在使用 async 修饰符声明的方法中，使用 yield return 来返回元素。你可以使用 await foreach 循环来消费异步流，就像使用 foreach 循环消费任何序列一样。</p><p>这些新的语言特性依赖于添加到 .NET Standard 2 . 1 并在 .NET Core 3 . 0 中实现的三个新接口：</p><ul><li>System . Collections . Generic . IAsyncEnumerable &lt; T &gt;</li><li>System . Collections . Generic . IAsyncEnumerator &lt; T &gt;</li><li>System . IAsyncDisposable</li></ul><p>这三个接口对大多数 C# 开发者来说应该很熟悉。它们的行为方式与其同步对应接口类似：</p><ul><li>System . Collections . Generic . IEnumerable &lt; T &gt;</li><li>System . Collections . Generic . IEnumerator &lt; T &gt;</li><li>System . IDisposable</li></ul><h3>转换为异步流</h3><p>接下来，将 RunPagedQueryAsync 方法转换为生成异步流。首先，将 RunPagedQueryAsync 的签名更改为返回 IAsyncEnumerable &lt; JToken &gt;，并从参数列表中移除取消令牌和进度对象，如下列代码所示：<br/><code> private static async IAsyncEnumerable&lt;JToken&gt; RunPagedQueryAsync ( GitHubClient client , string queryText , string repoName ) </code><br/>启动代码会在检索到每个页面时对其进行处理，如下代码所示：</p><pre><code class="C#">finalResults . Merge ( issues ( results ) [ "nodes" ]! );
progress? . Report ( issuesReturned );
cancel . ThrowIfCancellationRequested ( );</code></pre><p>用以下代码替换那三行：</p><pre><code class="C#">foreach ( JObject issue in issues ( results ) [ "nodes" ]! )
    yield return issue;</code></pre><p>你也可以删除此方法中前面的 finalResults 声明，以及你修改过的循环后面的 return 语句。</p><p>你已经完成了生成异步流的修改。完成的方法应类似于以下代码：</p><pre><code class="C#">private static async IAsyncEnumerable&lt;JToken&gt; RunPagedQueryAsync ( GitHubClient client , string queryText , string repoName )
{
    var issueAndPRQuery = new GraphQLRequest
    {
        Query = queryText
    };
    issueAndPRQuery . Variables [ "repo_name" ] = repoName;

    bool hasMorePages = true;
    int pagesReturned = 0;
    int issuesReturned = 0;

    // Stop with 10 pages, because these are large repos:
    while ( hasMorePages &amp;&amp; ( pagesReturned++ &lt; 10 ) )
    {
        var postBody = issueAndPRQuery . ToJsonText ( );
        var response = await client . Connection . Post &lt; string &gt; ( new Uri ( "https://api.github.com/graphql" ) , postBody , "application/json" , "application/json" );

        JObject results = JObject . Parse ( response . HttpResponse . Body . ToString ( )! );

        int totalCount = ( int ) issues ( results ) [ "totalCount" ]!;
        hasMorePages = ( bool ) pageInfo ( results )[ "hasPreviousPage" ]!;
        issueAndPRQuery . Variables [ "start_cursor" ] = pageInfo ( results ) [ "startCursor" ]! . ToString ( );
        issuesReturned += issues ( results )[ "nodes" ]! . Count ( );

        foreach ( JObject issue in issues ( results )[ "nodes" ]! )
            yield return issue;
    }

    JObject issues ( JObject result ) =&gt; ( JObject ) result [ "data" ]! [ "repository" ]! [ "issues" ]!;
    JObject pageInfo ( JObject result ) =&gt; ( JObject ) issues ( result ) [ "pageInfo" ]!;
}</code></pre><p>接下来，你要修改使用集合的代码，使其使用异步流。在 Main 中找到以下处理问题集合的代码：</p><pre><code class="C#">var progressReporter = new progressStatus ( ( num ) =&gt;
{
    Console . WriteLine ( $"Received {num} issues in total" );
} );
CancellationTokenSource cancellationSource = new ( );

try
{
    var results = await RunPagedQueryAsync ( client , PagedIssueQuery , "docs" , cancellationSource . Token , progressReporter );
    foreach ( var issue in results )
        Console . WriteLine ( issue );
}
catch ( OperationCanceledException )
{
    Console . WriteLine ( "Work has been cancelled" );
}</code></pre><p>用以下 await foreach 循环替换该代码：</p><pre><code class="C#">int num = 0;
await foreach ( var issue in RunPagedQueryAsync ( client , PagedIssueQuery , "docs" ) )
{
    Console . WriteLine ( issue );
    Console . WriteLine ( $"Received {++num} issues in total" );
}</code></pre><p>新接口 IAsyncEnumerator &lt; T &gt; 继承自 IAsyncDisposable。这意味着上述循环在结束时会异步释放流。你可以想象该循环类似于以下代码：</p><pre><code class="C#">int num = 0;
var enumerator = RunPagedQueryAsync ( client , PagedIssueQuery , "docs" ) . GetAsyncEnumerator ( );
try
{
    while ( await enumerator . MoveNextAsync ( ) )
    {
        var issue = enumerator . Current;
        Console . WriteLine ( issue );
        Console . WriteLine ( $"Received {++num} issues in total" );
    }
} finally
{
    if ( enumerator != null )
        await enumerator . DisposeAsync ( );
}</code></pre><p>默认情况下，流元素在捕获的上下文中进行处理。如果要禁用上下文捕获，请使用 TaskAsyncEnumerableExtensions . ConfigureAwait 扩展方法。</p><p>异步流使用与其他 async 方法相同的协议来支持取消操作。你可以按如下方式修改异步迭代器方法的签名以支持取消：</p><pre><code class="C#">private static async IAsyncEnumerable&lt;JToken&gt; RunPagedQueryAsync ( GitHubClient client, string queryText, string repoName, [ EnumeratorCancellation ] CancellationToken cancellationToken = default )
{
    var issueAndPRQuery = new GraphQLRequest
    {
        Query = queryText
    };
    issueAndPRQuery.Variables["repo_name"] = repoName;

    bool hasMorePages = true;
    int pagesReturned = 0;
    int issuesReturned = 0;

    // Stop with 10 pages, because these are large repos:
    while ( hasMorePages &amp;&amp; ( pagesReturned++ &lt; 10 ) )
    {
        var postBody = issueAndPRQuery . ToJsonText ( );
        var response = await client . Connection . Post &lt; string &gt; ( new Uri ( "https://api.github.com/graphql" ) , postBody , "application/json" , application/json" );

        JObject results = JObject . Parse ( response . HttpResponse . Body . ToString ( )! );

        int totalCount = ( int ) issues ( results ) [ "totalCount" ]!;
        hasMorePages = ( bool ) pageInfo ( results ) [ "hasPreviousPage" ]!;
        issueAndPRQuery . Variables [ "start_cursor" ] = pageInfo ( results ) [ "startCursor" ]! . ToString ( );
        issuesReturned += issues ( results ) [ "nodes" ]! . Count ( );

        foreach ( JObject issue in issues ( results ) [ "nodes" ]! )
            yield return issue;
    }

    JObject issues ( JObject result ) =&gt; ( JObject ) result [ "data" ]! [ "repository" ]! [ "issues" ]!;
    JObject pageInfo ( JObject result ) =&gt; ( JObject ) issues ( result ) [ "pageInfo" ]!;
}</code></pre><p>System . Runtime . CompilerServices . EnumeratorCancellationAttribute 特性会促使编译器为 IAsyncEnumerator &lt; T &gt; 生成代码，使传递给 GetAsyncEnumerator 的令牌作为该参数在异步迭代器的主体中可见。在 runQueryAsync 内部，你可以检查令牌的状态，并在收到请求时取消后续工作。</p><p>你可以使用另一个扩展方法 WithCancellation，将取消令牌传递给异步流。你可以按如下方式修改枚举问题的循环：</p><pre><code class="C#">await foreach (var number in AsyncStreamGenerator . GenerateNumbersAsync (
    count: 5, 
    delayMs: 1000 ) . WithCancellation ( cancellationToken ) ) // 关键：用扩展方法绑定取消令牌
    {
        Console . WriteLine ( $"收到数据：{number}" );
    }</code></pre><p>你可以从 dotnet/docs 代码库的 asynchronous-programming/snippets 文件夹中获取完成的教程代码。</p><h3>运行完成的应用程序</h3><p>再次运行应用程序。将其行为与初始应用程序的行为进行对比。结果的第一页一准备好就会被枚举出来。在请求和检索每个新页面时，会有一个明显的停顿，然后下一页的结果会被快速枚举。不需要使用 try……catch 块来处理取消操作：调用方可以停止枚举集合。进度会被清晰地报告，因为异步流会在每个页面下载时生成结果。每个返回的问题的状态会无缝地包含在 await foreach 循环中。你不需要回调对象来跟踪进度。</p><p>通过检查代码，你可以发现内存使用方面的改进。在枚举所有结果之前，你不再需要分配一个集合来存储它们。调用者可以决定如何使用这些结果，以及是否需要一个存储集合。</p><p>运行初始应用程序和完成后的应用程序，你可以亲自观察两种实现之间的差异。完成本教程后，你可以删除在开始时创建的 GitHub 访问令牌。如果攻击者获取了该令牌，他们就可以使用你的凭据访问 GitHub 的 API。</p><p>在本教程中，你使用了异步流从返回分页数据的网络 API 中读取单个项目。异步流还可以从 “永不终止的流” （如股票行情或传感器设备）中读取数据。对 MoveNextAsync 的调用会在有下一个项目可用时立即返回该项目。</p><pre><code class="C#">using System;
using System . Collections . Generic;
using System . Threading;
using System . Threading . Tasks;
// 注意：需要引用 System.Linq.Async 包（NuGet命令：Install-Package System.Linq.Async）
using System . Linq;

// 假设这是一个已有的异步流生成器（可能未直接支持取消令牌）
public static class AsyncStreamGenerator
    {
    // 生成器未显式接收取消令牌（模拟第三方库或遗留代码）
    public static async IAsyncEnumerable&lt;int&gt; GenerateNumbersAsync ( int 数量 , int 延迟毫秒数 )
        {
        for ( int i = 1 ; i &lt;= 数量 ; i++ )
            {
            await Task . Delay ( 延迟毫秒数 ); // 模拟异步操作（无取消检查）
            yield return i;
            }
        }
    }

class AsyncStreamConsumer
    {
    public static async Task 带取消功能的消费方法Async ( )
        {
        try
            {
            // 创建取消令牌源（例如：3秒后自动取消）
            using var 取消源 = new CancellationTokenSource(3000);
            var 取消令牌 = 取消源.Token;

            // 消费异步流时，通过 WithCancellation 传递取消令牌
            // 即使生成器本身不支持取消，枚举过程（MoveNextAsync）会响应取消
            await foreach ( var 数字 in AsyncStreamGenerator . GenerateNumbersAsync (
                数量: 5 ,
                延迟毫秒数: 1000 )
                . WithCancellation ( 取消令牌 ) ) // 关键：用扩展方法绑定取消令牌
                {
                Console . WriteLine ( $"收到数据：{数字}" );
                }

            Console . WriteLine ( "异步流消费完成！" );
            }
        catch ( OperationCanceledException )
            {
            Console . WriteLine ( "异步流被取消（消费端触发）！" );
            }
        catch ( Exception ex )
            {
            Console . WriteLine ( $"错误：{ex . Message}" );
            }
        }

    static async Task Main ( )
        {
        await 带取消功能的消费方法Async ( );
        }
    }</code></pre>]]></description></item><item>    <title><![CDATA[电商平台数字人主播直播间激增，虚拟主播如]]></title>    <link>https://segmentfault.com/a/1190000047394497</link>    <guid>https://segmentfault.com/a/1190000047394497</guid>    <pubDate>2025-11-13 12:11:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>直播间里，主播“罗永浩”连续激情澎湃地解说了6个小时，依然精神饱满、对答如流，而这一切背后，竟无一人真人参与。（青否数字人源头v：zhibo175）</p><p>当直播时长逼近6个小时、大多数电商主播显露疲态时，百度直播间里的主播“罗永浩”和搭档“朱萧木”仍然情绪饱满地回答观众提问，时不时还能讲两句“段子”吸引观众下单。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394499" alt="" title=""/></p><p>这并非真人主播的超常发挥，而是百度借助剧本驱动多模协同数字人技术打造的数字人主播。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394500" alt="" title="" loading="lazy"/></p><p>在刚刚过去的2025年世界互联网大会乌镇峰会上，这项高拟真数字人技术荣获世界互联网大会领先科技奖。而这仅仅是数字人直播革命的一个缩影。</p><p>1、技术突破：从“工具人”到“智能体”（青否数字人源头v：zhibo175）</p><p>传统数字人常面临语音、语言、视觉多模态割裂的问题，表现为台词生硬、语音语调与台词情感匹配不佳、表情手势单一等。</p><p>青否数字人的双AI剧本互动</p><p>青否数字人深度复刻真人直播协作方式，让双 AI实现“主播 + 助播”的精准分工。</p><p>通过“讲品+捧场”或“讲品+回复弹幕”等多种直播配合模式，带来更高频的互动和更强的直播节奏！</p><p>比如在直播过程中，数字人主播正在讲解商品，助播则会实时捧哏或回复观众弹幕，打造流畅自然的直播节奏与生动的互动氛围，大幅提升观众的观看体验。</p><p>从“一人说”到“两人搭“，青否用 AI 协作逻辑，让直播全程有互动、有重点、有节奏，就像两个经验丰富的真人主播在默契配合。节奏感拉满，直播效果超硬核！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394501" alt="" title="" loading="lazy"/></p><p>双数字人直播带货，能以实现利用ai数字人为直播赋能，做到真正的降本增效，罗永浩数字人电商直播首秀创下AI直播新标杆！</p><p>2、商业实效：数字人直播的“成绩单”（青否数字人源头v：zhibo175）</p><p>罗永浩的数字人分身在电商平台完成了一场长达6小时的直播带货，创下GMV超5500万元的佳绩。</p><p>订单量同比提升150%，下单用户数量同比增长230%，人均观播时长增长30%。</p><p>这些数字背后，是数字人技术的全面进步。在这场直播中，数字人调用知识库1.3万次，生成近10万字匹配剧本和8300个动作。</p><p>甚至对直播间用户的互动问题和玩笑，也能及时回复。</p><p>更引人注目的是，数字人直播的成本效益比惊人。如今直播行业IP数字人带货GMV约为真人的70%到80%，线上成本几乎可做到真人主播的近10%，每场约千元。这种成本优势使得中小商家也能涉足直播电商领域。</p><p>3、应用场景：谁更适合数字人直播？</p><p>在直播电商领域，数字人已在三大场景展现出明显优势：</p><p>高频快消品领域（如美妆、食品、日用品、3C数码与家电），数字人可以多角度演示，24小时不间断直播，覆盖零散流量、提高转化。</p><p>科普教育、旅游咨询、企业品牌和政务宣传，建立在标准答案和基础知识框架之上，数字人与多模态、多智能体、知识图谱结合能精准回答，提升用户搜索效率。</p><p>高频低价的即时消费，如助农特色农产品、中小微商家帮扶，数字人可以围绕特定商品，通过剧本、专业话术、智能选品溯源等，提升产品的曝光度和转化率。</p><p>然而，真人主播在三大领域仍具不可替代性：提供高情绪价值的真人主播；高价格的非标品（如奢侈品、文玩珠宝、定制产品）；以及专业领域如医疗、金融、财经访谈等。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394502" alt="" title="" loading="lazy"/></p><p>4、人机协同：未来直播新范式</p><p>未来，真人主播和数字人将是协同共生关系。</p><p>二者的协作方式会根据行业、场景不同，因人而异。眼下，头部直播平台都在探索和建立 “真人+数字人” 模式。</p><p>基本逻辑是：热点时段真人引流，数字人承接剩余时段和碎片化的流量转换。</p><p>更可实现7×24小时不间断直播，用户停留时长反超人类主播15%。</p><p>未来展望：数字人直播的下一站</p><p>技术层面，多模态大模型、边缘计算和AI智能体协作，会推进数字人具备 “类人甚至超人智能” 。</p><p>同时，技术发展将提升“数字人”的商业化落地、生态协同、高质内容规模量产和跨场景应用能力。</p><p>商业层面，超写实数字人的出现，促进了直播行业从 “人力驱动”向“技术驱动” ，也倒逼行业探索“真实”和“效率”的平衡。</p><p>未来，更高智能的数字人将渗透到电商全行业，重构直播电商成本结构（青否数字人源头v：zhibo175）。</p>]]></description></item><item>    <title><![CDATA[2025全球项目管理软件排名：12款主流]]></title>    <link>https://segmentfault.com/a/1190000047394507</link>    <guid>https://segmentfault.com/a/1190000047394507</guid>    <pubDate>2025-11-13 12:10:42</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>当下IT决策者面临的核心矛盾，并非工具的功能缺失，而是<strong>战略安全性与业务敏捷性之间的深层博弈</strong>。公有云巨头以“一站式体验”为卖点，私有化工具则以数据主权为壁垒。本文基于200+政企客户深度访谈与实验室测试，建立<strong>4维评估框架</strong>，助您找到平衡合规、成本与效率的最优解。</blockquote><hr/><h3>一、权威评估框架：穿透营销话术的4大黄金维度</h3><ol><li><strong>🇨🇳 数据主权与可控性</strong></li><li>关键指标：物理服务器位置、加密级别（国密/SM4）、审计日志完备性</li><li>政企红线：军工/金融机构需满足《数据安全法》第21条本地化存储要求</li><li><strong>🖥️ 国产信创适配度</strong></li><li>认证体系：麒麟/统信UOS认证、鲲鹏/海光CPU兼容性</li><li>实测指标：龙芯环境部署成功率、达梦/人大金仓数据库支持</li><li><strong>📊 部署灵活性与TCO成本</strong></li><li>部署模型：公有云SaaS vs 私有化部署 vs 混合云</li><li>成本陷阱：警惕SaaS隐性成本（按席位涨价、数据导出费）</li><li><strong>🔌 系统集成与扩展能力</strong></li><li>开放能力：API日均调用峰值、低代码平台成熟度</li><li>生态图谱：ERP/MES/OA系统预置连接器数量</li></ol><hr/><h3>二、12款主流系统四维雷达图评测（2025最新数据）</h3><table><thead><tr><th>产品</th><th>数据主权 ★★★★☆</th><th>信创适配 ★★☆☆☆</th><th>部署成本 ★★★☆☆</th><th>扩展能力 ★★★★☆</th><th>核心定位</th></tr></thead><tbody><tr><td><strong>禅道</strong></td><td>●●●●●</td><td>●●●●●</td><td>●●●●●</td><td>●●●●●</td><td>安全优先的私有化标杆</td></tr><tr><td>Jira (Cloud)</td><td>●●○○○</td><td>●○○○○</td><td>●●○○○</td><td>●●●●●</td><td>敏捷开发全球领导者</td></tr><tr><td>飞书项目</td><td>●●○○○</td><td>●●○○○</td><td>●●●○○</td><td>●●●●○</td><td>协作型SaaS生态体</td></tr><tr><td>鼎捷T100</td><td>●●●●○</td><td>●●●●○</td><td>●●○○○</td><td>●●●●●</td><td>制造业全链路方案</td></tr><tr><td>Asana</td><td>●●○○○</td><td>○○○○○</td><td>●●●○○</td><td>●●●○○</td><td>轻量任务协作专家</td></tr><tr><td>Wrike</td><td>●●○○○</td><td>○○○○○</td><td>●●●○○</td><td>●●●●○</td><td>营销项目全周期管理</td></tr><tr><td>Monday.com</td><td>●●○○○</td><td>○○○○○</td><td>●●●●○</td><td>●●●○○</td><td>可视化工作流设计器</td></tr><tr><td>ClickUp</td><td>●●○○○</td><td>○○○○○</td><td>●●●○○</td><td>●●●●○</td><td>All-in-One效率平台</td></tr><tr><td>Smartsheet</td><td>●●●○○</td><td>○○○○○</td><td>●●●●○</td><td>●●●●○</td><td>表格化项目管理</td></tr><tr><td>GitLab</td><td>●●●●○</td><td>●●○○○</td><td>●●●○○</td><td>●●●●●</td><td>DevOps全流程引擎</td></tr><tr><td>Microsoft Project</td><td>●●●○○</td><td>●●○○○</td><td>●●○○○</td><td>●●●●●</td><td>传统复杂项目甘特图之王</td></tr><tr><td>OpenProject</td><td>●●●●●</td><td>●●●○○</td><td>●●●●●</td><td>●●●○○</td><td>开源社区首选</td></tr></tbody></table><blockquote>注：★代表得分（满分为5星），基于2025Q1第三方测试平台BenchMatrix数据校准</blockquote><hr/><h3>三、关键发现：三类企业的战略选择图谱</h3><h4>▶ 安全敏感型组织（军工/政府/金融）</h4><p><strong>首选路径：私有化部署+国产生态</strong></p><ul><li><strong>禅道</strong>在麒麟V10系统部署效率达<strong>97.6%</strong>（行业均值82.3%）</li><li>支持SM4硬件加密卡，满足等保2.0三级认证</li><li>案例：某省医保平台承载3000万用户数据0泄露</li></ul><h4>▶ 成本敏感型中小企业</h4><p><strong>平衡方案：混合云+轻量化SaaS</strong></p><ul><li><strong>Monday.com</strong>可视化看板降低培训成本40%</li><li><strong>飞书项目</strong>适合50人内团队快速启动</li></ul><h4>▶ 全球化研发团队</h4><p><strong>技术栈统一：DevOps工具链集成</strong></p><ul><li><strong>Jira+GitLab</strong>组合覆盖85%互联网公司</li><li>但需注意：境外架构可能导致数据跨境审计风险</li></ul><hr/><h3>四、为什么禅道成为高安全场景的终极选择？</h3><p>当评估框架聚焦<strong>数据主权、国产化、总拥有成本</strong>三大核心维度时，私有化方案的战略价值凸显：</p><ol><li><strong>安全模型优势</strong>：</li><li>物理隔离架构 vs SaaS的多租户风险</li><li>某头部券商替换Jira后，等保测评成本下降60%</li><li><strong>信创落地加速度</strong>：</li><li>唯一同时入围<strong>央企信创清单+军工涉密目录</strong>的项目管理软件</li><li>鲲鹏920环境性能损耗仅3.2%（行业平均11.7%）</li><li><p><strong>成本控制真相</strong>：</p><table><thead><tr><th>部署方式</th><th>100人团队5年总成本</th></tr></thead><tbody><tr><td>禅道私有化</td><td>¥38万</td></tr><tr><td>Jira Cloud</td><td>¥126万</td></tr><tr><td>飞书项目</td><td>¥89万</td></tr></tbody></table></li></ol><hr/><h3>五、决策指南：匹配业务场景的选型流程图</h3><pre><code>graph TD  
A[业务类型] --&gt;|涉密/强监管| B(选择私有化部署)  
A --&gt;|敏捷创新/全球化| C(评估SaaS方案)  
B --&gt; D{国产化要求？}  
D --&gt;|是| E[禅道/鼎捷]  
D --&gt;|否| F[GitLab/OpenProject]  
C --&gt; G{生态依赖性？}  
G --&gt;|微软体系| H[Microsoft Project]  
G --&gt;|谷歌系| I[Asana]  
G --&gt;|独立部署| J[ClickUp]  </code></pre><h2><img width="723" height="415" referrerpolicy="no-referrer" src="/img/bVdm1DD" alt="image.png" title="image.png"/></h2><h3>六、FAQ：决策者最关注的5个实战问题</h3><p><strong>Q1：国产化替代是否需要牺牲功能性？</strong></p><blockquote>答：2025年主流国产工具功能覆盖度已达国际产品92%（2020年仅65%），禅道16.0版本支持敏捷/瀑布/混合模式，缺陷管理效率超Jira 23%。</blockquote><p><strong>Q2：SaaS工具如何规避数据出境风险？</strong></p><blockquote>答：务必验证三点：①数据中心是否位于境内 ②是否通过ISO 27018认证 ③合同是否明确数据归属条款。</blockquote><p><strong>Q3：200人团队私有化部署周期多长？</strong></p><blockquote>答：禅道标准方案可在<strong>3个工作日内</strong>完成鲲鹏服务器部署+基础培训（需提前准备等保环境）。</blockquote><p><strong>Q4：开源工具（如OpenProject）能否用于生产环境？</strong></p><blockquote>答：社区版适合小型团队，但企业需评估：①漏洞修复延迟风险 ②国密算法支持缺失 ③商业支持成本。</blockquote><p><strong>Q5：如何平衡历史数据迁移与系统切换成本？</strong></p><blockquote>答：建议采用“双轨运行+增量迁移”策略，禅道提供Jira/Redmine<strong>无损迁移工具</strong>，千级任务迁移&lt;2小时。</blockquote><hr/><h3>结语：工具的本质是战略能力的延伸</h3><p>当选择项目管理软件不再仅是技术决策，而是<strong>企业风险治理与数字韧性的关键落点</strong>，那些真正理解“可控性优先”原则的组织，终将在复杂环境中赢得主动权。<strong>没有完美的系统，只有与战略基因最契合的选择</strong>——这正是我们持续优化评估框架的初心。</p><blockquote><strong>数据来源</strong>：工信部信创实验室测试报告(2025)、Gartner PMSuites Magic Quadrant、禅道客户TCO调研(样本量217家)<br/><strong>声明</strong>：本文不接受任何厂商商业赞助，评测数据经DNV GL独立验证</blockquote>]]></description></item><item>    <title><![CDATA[Flink 的 RocksDB 状态后端]]></title>    <link>https://segmentfault.com/a/1190000047394518</link>    <guid>https://segmentfault.com/a/1190000047394518</guid>    <pubDate>2025-11-13 12:10:10</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><p>作者： 互联网大数据团队- Chen Rui</p><p>本文简要介绍了特征拼接在实时推荐中的重要作用，并讲述了vivo实时推荐系统中特征拼接模块的架构演进过程以及采用现有的“基于RocksDB的大状态解决方案”的原因，重点叙述了该方案所遇到的一系列问题，包括TM Lost、RocksDB性能调优门槛高、TM初始化慢、状态远程存储HDFS RPC飙高等，并给出了这些问题的现象以及解决方案。</p></blockquote><p>1分钟看图掌握核心观点👇</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394520" alt="图片" title="图片"/></p><h2>一、背景</h2><p>在推荐系统中，样本拼接是衔接在线服务与算法模型的重要一个环节，主要职责是样本拼接和业务相关的ETL处理等，模块位置如下图红框所示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394521" alt="图片" title="图片" loading="lazy"/></p><p>推荐系统通过学习埋点数据来达到个性化精准推荐的目的，因此需要知道服务端推荐下发的内容，是否有一系列的行为(曝光，点击，播放，点赞，收藏，加购等等)，把被推荐内容的埋点数据与当下的特征拼接起来的过程，一般称为样本拼接，一个简化的流程如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394522" alt="图片" title="图片" loading="lazy"/></p><p>推荐的过程可以检验概括为以下几点：</p><blockquote><ul><li>后台服务rank 推荐内容给app客户端，同时把内容对应的特征快照保存起来；</li><li>app接收到内容后，埋点日志被上报到消息中间件；</li><li>样本拼接负责将特征与埋点日志拼接起来，定义正负样本，格式转换；</li><li>模型接收样本训练，将使用最新的模型做推荐。</li></ul></blockquote><p>为了保证较高的拼接率和稳定性，我们的拼接架构也经过了长时间的迭代，这篇文章我将给大家介绍vivo特征拼接架构的发展历程、当前方案、当前方案遇到的问题和解决方案，以及未来的规划和展望，希望能帮助到业内的同学。</p><h2>二、拼接方案选型</h2><h3>2.1 小时粒度拼接</h3><p>小时拼接是将埋点日志和特征快照都保存到Hive并以小时分区，每小时调度一个Spark任务来处理两个表相应分区的数据做拼接，由于是小时拼接，实时性较低，Spark作业本身也依赖于上游Hive表小时分区生成，每个小时末尾的请求埋点有可能是落在当前小时，也有可能落在下个小时。举个例子：19点50分下发了一个视频，客户端在19:59分点击了，但是视频播放却是在20点03分完成的，这个时候就会存在拼接不上的问题。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394523" alt="图片" title="图片" loading="lazy"/></p><h3>2.2 基于 Redis 的流式拼接</h3><p>为了提升拼接率，且达到实时拼接，节点故障容灾，完备监控等特性，Flink是一个很好的替代方案，也是最近几年比较主流的实现。最初在实时推荐场景中，Kafka中的特征快照通过Flink任务写入到Redis，另一个Flink任务消费曝光埋点数据和点击埋点数据并读取存在Redis中的特征快照数据做拼接，拼接后的数据作为拼接特征被写入到下游的Kafka中，提供给后续的算法做模型的训练，架构图如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394524" alt="图片" title="图片" loading="lazy"/></p><p>经过一段时间实践，以上的方案出现了<strong>两个痛点：</strong></p><blockquote><ul><li>Redis中存储了几十T的数据，Redis的成本高；</li><li>业务数据流量会波动，经常需要DBA对Redis集群进行扩容，涉及大量数据的迁移，运维成本高。</li></ul></blockquote><h3>2.3 基于 RocksDB 大状态流式拼接</h3><p>为了解决基于Redis的作为中间数据的存储存在的问题，我们采用Flink状态来存储特征快照，整个架构中不再需要外部的Redis，由于我们需要存储的数据量达几十T，这里我们选用适合大数据量存储的RocksDB类型的状态后端，调整后架构更加简洁，如下图所示：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394525" alt="图片" title="图片" loading="lazy"/></p><p>流程如下：</p><blockquote><ul><li>首先将曝光流点点击流以及特征在Flink 任务中做union并做keyby；</li><li>在processElement方法中如果接收到曝光流就将数据保存到state中，如果接收到曝光流就将数据保存到state中，如果接收到特征就去state中查询相应的曝光和点击数据；</li><li>如果能找到就发送到下游并将状态数据清理掉，没找到就将特征保存到state中，并注册一个定时器；</li><li>定时器触发时去state中查询相应的曝光和点击数据，如果找到就发到下游，并将状态数据清理掉。</li></ul></blockquote><p>由于RocksDB可以同时利用内存和磁盘来存储数据，所以对于内存的使用量大幅下降，由于RocksDB是嵌入式的数据库，每个TM上的RocksDB数据库只存储shuffe到该TM上的数据，无需再关注扩缩容的问题。当然随着数据上涨，Flink流式拼接在实际的生产过程中也遇到了一系列的问题，为了保证业务的可用性，我们花了较长的时间对这些问题进行攻克，目前任务稳定性达到99.99% ，拼接率长期稳定在99%以上，对拼接效果提升较大。下面我将列举我们遇到的问题和解决方案，希望能够帮助到业内的其他团队。</p><h2>三、问题及解决方案</h2><h3>3.1 TM Lost问题</h3><h4>3.1.1 现象</h4><p>在方案实施之初，我们发现这些特征拼接的任务频繁出现TM was Lost异常导致任务重启，我们看了日志，发现都是TM内存超出了YARN的内存限制被kill。</p><h4>3.1.2 问题分析</h4><p>那么我们的疑问就来了，为啥这部分任务的内存很容易超出，超出的那部分内存又是谁在用呢？下面这张图是来自Flink的官网，因为我们在平台使用Flink的时，我们只设置了总的内存，并没有关注其他各个局部的内存，那么这些部位的内存是如何分配的？为了搞清楚这个问题，有必要梳理一下每个模块内存计算的逻辑。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394526" alt="图片" title="图片" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=bqkwC0Fgtp1Nl%2Ffzi%2FGD2w%3D%3D.2LFEqghowenM%2F8gn%2Bpu2KCmer%2Bn1VJ1SgwHYQucgjwpRLEJd7RrWnbPTHNgGjWLhe8k96VAbcWWoff0gdD3ZKb37CoaQJvq%2FLokBKzpEj%2B10GgRuBzc5w4WzZyaoFxgd" rel="nofollow" target="_blank">图片引用自Flink</a></p><p><strong>Flink内存分配逻辑</strong></p><p>一般在YARN上提交的任务是含有taskmanager.memory.process.size 参数的配置的，所以Flink在分配内存时，会以调用deriveProcessSpecWithTotalProcessMemory 方法分配。</p><p>通过配置参数获得meatspace 的大小，通过jobmanager.memory.jvm-overhead.fraction 的比例计算overhead的内存，totalFlinkMemory通过总的进程的内存减去meatspace + overhead的内存得到。</p><p>通过配置中的参数获取 frameworkHeapMemory-</p><p>Size、frameworkOffHeapMemorySize 、task-</p><p>OffHeapMemorySize 的大小。</p><p>通过managedmemory的配置获取托管内存的值， 通过networkbuffer的配置获取networkbuffer的值 。totalFlinkMemory 减去所有需要排除的内存，剩下的内存分配给堆。内存分配逻辑，以及每块内存的设置方法如下图：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394527" alt="图片" title="图片" loading="lazy"/></p><p>到此TM的各个内存模块的内存已经划分完成。有上面的分析我们可以得出以下的结论：</p><pre><code>totalProcessMemorySize = totalFlinkMemorySize + JvmMetaspaceSize + JvmOverheadSize
totalFlinkMemorySize  = frameworkOffHeapMemorySize + taskOffHeapMemorySize + managedMemorySize + networkMemorySize + frameworkHeapMemorySize + taskHeapMemorySize</code></pre><p>这里重点将一下JVMOverhead，JVMOverhead并没有具体的作用，是一个预留值，它是一个缓冲区，可以避免在Flink运行在容器中是因为短时时间的内存超出了容器的限制而被kill。</p><p>frameworkOffHeapMemorySize和taskOff-</p><p>HeapMemorySize 也是预留值，offheap在概念上的主要是指native内存。frameworkHeap-</p><p>MemorySize 也是预留值。由此可以看出虽然Flink官方将TM的内存划分的较细致，但是像JvmOverheadSize frameworkOffHeap-</p><p>MemorySize，taskOffHeapMemorySize，</p><p>frameworkHeapMemorySize 都只是逻辑上的预留，并没有从操作系统层面实现隔离。</p><p><strong>RocksDB内存分配逻辑</strong></p><p>因为堆内存不足时一般会报out of memory的异常，所以到这一步我们推测应该是堆外内存溢出了，而堆外内存最大的一块就是RocksDB使用的，而从Flink的官网的介绍可以知道托管内存就是给RocksDB使用的，下面我们再看一下托管内存是如何分配给RocksDB的。</p><pre><code>cacheMemory = （1-（1/3）*（writeBufferRatio））* managedMemory
bufferMemory = （2/3）*（writeBufferRatio）* managedMemory
读写缓存总内存 =  bufferMemory + cacheMemory = （1 +（1/3）*（writeBufferRatio））* managedMemory</code></pre><p>由上面的代码可以看出，managed memory 是通过一定的比例给RocksDB的各个部分来分配内存的，writeBufferRatio会影响读缓存和写缓存的大小，理论上读写缓存总内存有可能会超过managedMemory的大小。通过上面的公式可以看出读写缓存总内存最多超出managedMemory的1/3，这里很容易想到，那么我们在排查overhead的时候配置大于managedMemory的1/3不就能你面内存溢出了，但是在实践中，我们这样配置并并没有完全的解决物理内存溢出的问题，下面关于RocksDB内存的资料，终于找到了是还有哪部分内存容易溢出了，是因为部分区域的内存难以限制导致的。</p><p>RocksDB 的内存占用有 4 个部分:</p><blockquote><ul><li>Block Cache: OS PageCache 之上的一层缓存，缓存未压缩的数据 Block；</li><li>Indexes and filter blocks: 索引及布隆过滤器，用于优化读性能；</li><li>MemTable: 类似写缓存；</li><li>Blocks pinned by Iterator: 触发 RocksDB 遍历操作（比如遍历 RocksDBMapState 的所有 key）时，Iterator 在其生命周期内会阻止其引用到的 Block 和 MemTable 被释放，导致额外的内存占用。</li></ul></blockquote><p>前三个区域的内存都是可配置的，但 Iterator 锁定的资源则要取决于应用业务使用模式，且没有提供一个硬限制，因此 Flink 在计算 RocksDB StateBackend 内存时没有将这部分纳入考虑，其次是 RocksDB Block Cache 的一个 bug，它会导致 Cache 大小无法严格控制，有可能短时间内超出设置的内存容量，相当于软限制，原来是迭代器的内存限制的不好，导致的内存溢出。</p><h4>3.1.3 解决方案</h4><p>我们在使用Flink 的RocksDB状态后端时，是通过managed memory来控制RocksDB各个部分的内存的，所以managed memory内存越小分配给各个部分的内存也就越小，迭代器内存越不容易溢出。到此我们对Flink的RocksDB状态后端的内存有了一定的认知：当性能可以满足的情况下，Flink的Manaed memory应该越小越好。但是上满形成的经验很难高效的在业务上落地，原因是“Flink的Manaed memory应该越小越好”很难去确定。</p><p>于是我们联想到了之前的JVMoverhead，在我们的实际实践中过程中，我们是通过调大JVMoverhead，和jemalloc内存分配器来解决内存溢出问题的。在Flink1.12之后Flink on k8s的内存分配器已经默认改成了jemalloc，可以避免内存的分配过程中出现64M问题。</p><p>但是要注意：由于我们的Java版本是JAVA8小版本是192，在最新版本的jemalloc5.3上出现了死锁的问题，后来我们采用jemalloc4.5 就没有问题了。据了解业界有些公司使用的JAVA8小版本是256采用jemalloc5.3没有遇到死锁问题。</p><h3>3.2 RocksDB 的性能监控问题</h3><h4>3.2.1 现象</h4><p>Flink RocksDB大状态的任务经常出现延迟，但是我们很难知道性能的瓶颈在哪块，从而优化响应的环节。</p><h4>3.2.2 解决方案</h4><p>其实Flink提供了一系列对于RocksDB的性能的监控指标，我们只需要加上参数开启即可，这里我只结局我觉得最有参考意义的指标开启的参数：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394528" alt="图片" title="图片" loading="lazy"/></p><p>下面是相关指标的监控页面：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394529" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394530" alt="图片" title="图片" loading="lazy"/></p><h3>3.3 任务出现延迟</h3><h4>3.3.1 现象</h4><p>Flink RocksDB大状态的任务经常出现延迟，调优参数高达近百个，如何系统性的调优，难度较大。</p><h4>3.3.2 解决方案</h4><p>要想对RocksDB的性能做优化，我们有必要先了解一下RocksDB的读写流程。</p><p><strong>RocksDB的读流程</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394531" alt="图片" title="图片" loading="lazy"/></p><ul><li>获取当前时刻的SuperVersion，SuperVersion是RocksDB内针对于所有SST文件列表以及内存中的MemTable和Immutable MemTable的一个版本；</li><li>获取当前的序号来决定当前读操作依赖的数据快照；</li><li>尝试从第一步SuperVersion中引用的MemTable以及Immutable MemTable中获取对应的值。首先会经过布隆过滤器，假如不存在则一定不存在，反之假如返回存在则不一定存在；</li><li>尝试从Block Cache中读取；</li><li>尝试从SST文件中获取。</li></ul><p><strong>RocksDB的写流程</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394532" alt="图片" title="图片" loading="lazy"/></p><ul><li><p>将写入操作顺序写入WAL日志中，接下来把数据写到 MemTable中（采用SkipList结构实现）</p><p>MemTable达到一定大小后，将这个 MemTable 切换为不可更改的 immutable MemTable，并新开一个 MemTable 接收新的写入请求；</p></li><li>这个 immutable MemTable进行持久化到磁盘，成为L0 层的 SSTable 文件；</li><li><p>每一层的所有文件总大小是有限制的，每下一层大十倍。一旦某一层的总大小超过阈值了，就选择一个文件和下一层的文件合并。</p><p><strong>注意：</strong> 所有下一层被影响到的文件都会参与 Compaction。合并之后，保证 L1 到 L6 层的每一层的数据都是在 key 上全局有序的，而 L0 层是可以有重叠的，写流程的约束；</p></li><li>日志文件用于崩溃恢复；</li><li>每个MemTable及SST文件中的Key都是有序的（字符顺序的升序）；</li><li>日志文件中的Key是无序的；</li><li>删除操作是标记删除，是插入操作的一种，真正的删除要在Compaction的时候实现；</li><li>无更新实现，记录更新通过插入一条新记录实现；</li></ul><p>当任务出现延迟时，由于我们已经有了RocksDB性能指标的监控也了解RocksDB的原理，我们在做性能优化时就可以对症下药了。</p><p><strong>读性能优化</strong></p><p>当任务出现延迟且块缓存命中率下降时，说明是读的性能下降导致延迟，我们可以通过提升缓存命中率的方式来提升读性能，RocksDB任务缓存命中率的优化<strong>思路如下：</strong></p><ul><li>托管内存小于TM内存20%，可以调大托管内存：state.backend.rocksdb.memory.managed 到 20%；</li><li>Flink内部对RocksDB的优化已经沉淀了多组参数，建议使用配置：</li></ul><p>state.backend.rocksdb.predefined-options = </p><p>SPINNING\_DISK\_OPTIMIZED\_HIGH\_MEM；</p><ul><li>Flink中使用state.backend.rocksdb.memory</li></ul><p>.write-buffer-ratio参数来管理写缓存，调小该参数，能够提升读缓存，该参数默认0.5；</p><ul><li>RocksDB 会有一写索引和过滤器放在内存中，用这个参数开启：state.backend.rocksdb</li></ul><p>.memory.partitioned-index-filters 默认 false，并且可以调节索引和过滤器占用的内存比例，参数是：state.backend.rocksdb.memory</p><p>.high-prio-pool-ratio默认为0.1。</p><p><strong>写性能优化</strong></p><p>当任务延迟，如果出现等待flush的内存表的大小增加，或者等待合并的个数增加，因为等带flush个数达到一定的个数时写将会被阻塞，可以先关注一下磁盘io是否打满，如果已经处于高位，建议提升任务的并发。如果此磁盘io处于低位，我们可以调整flush和compation的线程数来使写的数据不再积压。提升写写性能。Flink会将flush和compation的线程数通过一个参数统一管理，参数是：state.backend</p><p>.rocksdb.thread.num，默认值是1。</p><h3>3.4 任务启动慢的问题</h3><h4>3.4.1 现象</h4><p>由于Flink任务在从状态启动时需要将存储在远程HDFS的状态文件读到本地，当TM较集中时单台机器的磁盘io很容易被打满，导致某些sub task 长时间处于INITIALIZING的状态。</p><h4>3.4.2 解决方案</h4><p><strong>YARN参数的优化</strong></p><p>YARN默认的yarn.scheduler.fair.assignmultiple参数为flase，即一次只分配一个container，但是CDH将这个参数设置成了true，yarn.scheduler.fair.max.assigr默认为-1，表示不限制，所以导致一次调度到单个节点上的container较多。我们的解决方案是将YARN配置中的yarn.scheduler.fair.assignmultiple参数设为false，一次只调度一个container，解决了TM分配较集中的问题。</p><p><strong>Flink调度策略的优化</strong></p><p>由于只是限制了每次分配TM的个数，还不能完全避免分配集中的问题，于是我们对Flink引擎内部做了优化，可以硬限制在某台机器上调度TM的个数，具体做法是，是当YARN返回给Flink ResourceManager container信息时，判断container是否符合要求，如果不符合可以部分拒收，再次申请资源，该功能由参数开启。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394533" alt="图片" title="图片" loading="lazy"/></p><h3>3.5 磁盘打满的问题</h3><h4>3.5.1 现象</h4><p>由于我们实时集群的磁盘较小，大状态任务的状态达几十上百T，频繁出现磁盘使用率达到90%的告警。</p><h4>3.5.2 解决方案</h4><p>我们将大状态的任务的Checkpoint数据存储到磁盘资源较宽裕的离线的集群，非大状态的任务的Checkpoint数据存储在实时集群。</p><h3>3.6 HDFS RPC 飙高问题</h3><h4>3.6.1 现象</h4><p>在业务新上一批任务后，我们发现离线集群HDFS的RPC有明显的增加。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394534" alt="图片" title="图片" loading="lazy"/></p><h4>3.6.2 解决方案</h4><p>由于我们默认只会保存最近的3个Checkpoint，所以对于增量Checkpoint而言，肯定会有文件的修改和删除，据了解修改和删除是对HDFS性能影响较大的操作。我们对比这一批任务任务在HDFS上的Checkpoint文件和之前的任务对比发现，文件数量大很多，但是每个文件小很多，于是我们调整了参数：state.backend.rocksdb.compaction.level.target-file-size-base参数为256MB，这个参数默认是64MB，参数的作用控制压缩后的文件的大小。配置改参数后RPC回归正常。</p><p>效果如图：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394535" alt="图片" title="图片" loading="lazy"/></p><h2>四、总结</h2><h3>4.1 遗留问题</h3><h4>4.1.1.RocksDB的调优的门槛较高</h4><p>虽然我们在任务上使用了积累通用经验进行优化，但是有些数据量较大的任务在流量高峰期依然容易出现延迟，RocksDB的参数有几十个，要想把性能调优做到比较极致需要深入了解其原理，还有对业务特点有深入的了解，对于应用开发而言，门槛较高。</p><h4>4.1.2.任务恢复慢</h4><p>由于有些任务的状态高达几十T，在重启任务或者异常重启时要从Checkpoint恢复，需要从远程的HDFS下载状态到本地磁盘，单机的io很容易被打满，虽然我们做了TM打散，但是有些单个TM恢复状态就需要几十分钟，这对于特征拼接任务来讲是不可接受的。</p><h4>4.1.3.SSD寿命消耗加速</h4><p>我们的实时集群磁盘使用的是单块的SSD，SSD寿命是有限的，然而RcoksDB的写放大的特点加速了SSD的寿命的消耗。</p><h3>4.2 规划</h3><p>经过较长时间的实践我们理解了样本拼接的本质是将不同来源、不同更新频率、不同规模的特征（如基础特征、实时埋点特征、历史特征）组合成完整样本，而单一组件往往在 “延迟、存储规模、更新频率” 等维度存在短板，必须通过混合架构实现 “优势互补”。</p><h4>业界混合架构的案例</h4><p><strong>组件分工</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394536" alt="图片" title="图片" loading="lazy"/></p><p><strong>拼接流程</strong></p><p><strong>① 实时日志采集：</strong>用户点击商品的日志通过Kafka接入Flink实时作业；</p><p><strong>② 实时数据存储：</strong>将曝光流的数据存到RocksDB和HBase中，RocksDB的TTL设置成1小时；</p><p><strong>③ 算子内实时拼接：</strong>Flink算子从RocksDB读取用户最近1小时埋点特征，从HBase读取基础特征，初步拼接成“实时+基础”特征；</p><p><strong>④ 历史特征融合：</strong>Flink作业将初步拼接结果写入Paimon，与Paimon中存储的“7天历史特征”融合，生成完整样本；</p><p><strong>⑤ 样本分发：</strong></p><ul><li>实时推荐：完整样本通过Flink写入到HDFS提供给在线训练服务使用；</li><li>离线训练：Spark作业从Paimon读取全量完整样本，用于推荐模型的离线迭代。</li></ul><p>下面是一个调用时序图：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394537" alt="图片" title="图片" loading="lazy"/></p><p><strong>核心价值</strong></p><ul><li><strong>低延迟：</strong>RocksDB 支撑算子内毫秒级拼接，满足实时推荐的 “秒级响应” 需求；</li><li><strong>大规模：</strong>HBase+Paimon 可支撑亿级用户的PB级特征存储；</li><li><strong>流批协同：</strong>同一套样本既供实时推荐，又供离线训练，实现流批架构统一；</li><li><strong>易于扩展：</strong>Paimon动态列支持特征迭代。</li></ul><h3>4.3 展望</h3><p>近几年大数据架构已经从计算-存储紧密耦合的Map-Reduce时代，进入到了以Kubernetes容器化部署为标准的云原生世界。未来Flink将引入基于远程存储的存算分离状态管理架构，新架构主要为了解决以下问题：</p><blockquote><ul><li>容器化环境下计算节点受本地磁盘大小限制的问题；</li><li>由于RocksDB中LSM结构的周期性 Compaction 导致计算资源尖峰的问题；</li><li>大规模状态快速扩缩容的挑战。</li></ul></blockquote><p>我们也将持续关注Flink社区的发展，尝试采用远程存储状态后端来做为特征拼接的解决方案。</p>]]></description></item><item>    <title><![CDATA[隐语可信数据空间MOOC第19讲笔记：多]]></title>    <link>https://segmentfault.com/a/1190000047394557</link>    <guid>https://segmentfault.com/a/1190000047394557</guid>    <pubDate>2025-11-13 12:09:15</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394559" alt=" title=" title=" title="/></p><h2>🔒 多方安全计算(MPC) 学习笔记</h2><h3>一、背景与应用场景</h3><h4>1. 经典问题：百万富翁问题</h4><ul><li><strong>目标</strong>：两个富翁比较财富，不泄露具体数值，只得到比较结果</li><li><strong>意义</strong>：MPC的起源问题</li></ul><h4>2. 典型应用场景</h4><ul><li><strong>联合模型训练</strong>：多方数据联合训练高精度机器学习模型</li><li><strong>基因诊断(GWAS)</strong>：保护隐私的基因数据分析</li><li><strong>联合风控</strong>：金融机构间隐私保护的联合风险分析</li></ul><hr/><h3>二、MPC发展历程</h3><table><thead><tr><th>阶段</th><th>时间</th><th>重要成果</th></tr></thead><tbody><tr><td><strong>初始阶段</strong></td><td>1982-1987</td><td>百万富翁问题、混淆电路、加法秘密分享</td></tr><tr><td><strong>基础框架</strong></td><td>1988-1990</td><td>诚实大多数协议、多方混淆电路</td></tr><tr><td><strong>理论研究</strong></td><td>1990s</td><td>多种理论问题深入研究</td></tr><tr><td><strong>高效实现</strong></td><td>2004至今</td><td>多种MPC实现和开源库</td></tr></tbody></table><hr/><h3>三、MPC分类体系</h3><h4>1. 按不诚实参与方数量</h4><ul><li><strong>诚实大多数</strong>：t &lt; n/2</li><li><strong>不诚实大多数</strong>：t ≥ n/2（通常t = n-1）</li></ul><h4>2. 按敌手行为</h4><ul><li><strong>半诚实敌手</strong>：被动攻击，按协议执行但记录信息</li><li><strong>恶意敌手</strong>：主动攻击，执行任意攻击行为</li></ul><h4>3. 按敌手计算能力</h4><ul><li><strong>概率多项式时间</strong>：计算安全协议</li><li><strong>无限计算能力</strong>：信息论安全协议（仅诚实大多数）</li></ul><h4>4. 按输出可达性</h4><ul><li><strong>中止安全</strong>：恶意方可获得输出后终止协议</li><li><strong>公平性</strong>：所有实体同时获得输出</li><li><strong>保证输出传送</strong>：所有实体一定获得输出</li></ul><h4>5. 按计算模型</h4><ul><li><strong>布尔电路</strong>：逻辑门(XOR、AND)</li><li><strong>算术电路</strong>：域/环上操作(ADD、MULT)</li><li><strong>RAM程序</strong>：读、写操作</li></ul><h4>6. 按腐化策略</h4><ul><li><strong>静态腐化</strong>：协议运行前确定被腐化实体</li><li><strong>自适应腐化</strong>：协议运行过程中动态决定</li></ul><h4>7. 按通信网络</h4><ul><li><strong>同步网络</strong>：固定延时内消息一定到达</li><li><strong>异步网络</strong>：更现实的网络假设</li></ul><hr/><h3>四、两大MPC设计方法</h3><h4>🔹 混淆电路方法</h4><ul><li><strong>特点</strong>：通信带宽高，常数轮复杂度</li><li><strong>适用</strong>：两方计算，轮数敏感场景</li></ul><h4>🔹 秘密分享方法</h4><ul><li><strong>特点</strong>：通信带宽低、吞吐率高，轮数与电路深度线性相关</li><li><strong>适用</strong>：多方计算，高吞吐需求场景</li></ul><p><strong>趋势</strong>：部分协议融合两种方法</p><hr/><h3>五、混淆电路技术细节</h3><h4>1. 基本流程</h4><pre><code>Garbler → 混淆电路(GC) → Evaluator
    ↓           ↓           ↓
  编码(e)      传输       解码(d)</code></pre><h4>2. 优化技术演进</h4><ul><li><strong>Free XOR</strong>：XOR门零通信成本</li><li><strong>半门技术</strong>：AND门通信降至1.5k</li><li><strong>切割技术</strong>：进一步优化通信</li></ul><h4>3. 相关基础协议</h4><ul><li><strong>不经意传输(OT)</strong>：GC的基础组件</li><li><p><strong>OT扩展</strong>：</p><ul><li><strong>IKNP类</strong>：计算量小，通信量大</li><li><strong>PCG类</strong>：通信量小，计算量大</li><li><strong>PCF类</strong>：亚线性通信，可分批计算</li></ul></li></ul><h4>4. 多方混淆电路协议</h4><ul><li><strong>BMR</strong>：对称形，所有参与方计算GC</li><li><strong>WRK</strong>：非对称形，只有1方计算GC</li></ul><hr/><h3>六、秘密分享技术体系</h3><h4>1. 线性秘密分享(LSSS)</h4><ul><li><strong>性质</strong>：加法同态性、隐私性、正确性</li><li><strong>操作</strong>：Share(x)、Reconstruct([x])、Open([x])</li></ul><h4>2. 常用秘密分享方案</h4><ul><li><strong>加法秘密分享</strong>：x = x₁ + ⋯ + xₙ（适用于不诚实大多数）</li><li><strong>Shamir秘密分享</strong>：基于多项式插值（适用于诚实大多数）</li><li><strong>复制秘密分享</strong>：支持更灵活的访问结构</li><li><strong>打包秘密分享</strong>：提高通信效率</li></ul><h4>3. 基于秘密分享的MPC框架</h4><pre><code>输入分享 → 电路计算 → 输出重构
    ↓         ↓           ↓
  Share(x)   ADD/MULT   Reconstruct(y)</code></pre><h4>4. 关键协议技术</h4><ul><li><strong>GMW协议</strong>：基于OT的布尔电路计算</li><li><strong>Beaver三元组</strong>：预处理+在线计算，降低通信</li><li><p><strong>分布式乘法计算</strong>：</p><ul><li><strong>GRR方法</strong>：Shamir分享的多项式相乘</li><li><strong>预处理优化</strong>：减少在线通信开销</li></ul></li></ul><hr/><h3>七、安全模型与恶意敌手防护</h3><h4>1. 通用编译器</h4><ul><li><strong>GMW编译器</strong>：零知识证明验证消息合法性</li><li><strong>IPS编译器</strong>：MPC-in-the-Head技术</li></ul><h4>2. SPDZ协议</h4><ul><li><strong>核心思想</strong>：信息论消息认证码</li><li><strong>认证分享</strong>：[x] = (份额, MAC)，其中MAC = x·Δ</li><li><strong>批量验证</strong>：大幅降低通信开销</li></ul><hr/><h3>八、总结与展望</h3><h4>性能对比</h4><table><thead><tr><th>方法</th><th>通信带宽</th><th>轮数</th><th>吞吐率</th><th>适用场景</th></tr></thead><tbody><tr><td>混淆电路</td><td>大</td><td>O(1)</td><td>低</td><td>两方、轮数敏感</td></tr><tr><td>秘密分享</td><td>小</td><td>O(电路深度)</td><td>高</td><td>多方、高吞吐</td></tr></tbody></table><h4>当前挑战</h4><ol><li>混淆电路通信下界突破（当前≈1.5k/AND门）</li><li>恶意模型性能优化（比半诚实慢数倍）</li><li>协议多样性带来的标准化困难</li></ol><h4>未来趋势</h4><ul><li><strong>通信优化</strong>：MPC主要效率瓶颈</li><li><strong>性能提升</strong>：与明文计算差距不断缩小</li><li><strong>恶意模型效率</strong>：逐渐接近半诚实模型性能</li></ul><hr/><h3>九、重要思考题</h3><ol><li>如何使用1-out-of-2 OT实现比特乘法？</li><li>如何扩展GMW协议到算术电路？</li><li>如何扩展两方协议到多方(n &gt; 2)？</li><li>如何用PRG减少通信开销？</li><li>如何证明Yao协议在半诚实模型下的安全性？</li></ol>]]></description></item><item>    <title><![CDATA[静态IP与动态IP的选择：如何通过711]]></title>    <link>https://segmentfault.com/a/1190000047394578</link>    <guid>https://segmentfault.com/a/1190000047394578</guid>    <pubDate>2025-11-13 12:08:35</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2><strong>1.住宅代理IP是什么？</strong></h2><p>在互联网的应用中，代理IP被广泛使用，比如：跨境电商，网络匿名浏览等，特别需要隐藏真实IP、提高匿名性或绕过地域限制。<br/>住宅代理IP就是一种常见的代理方式，通过提供真实的住宅IP地址，让用户看起来像是来自不同地区的普通用户，因此具备较高的隐匿性和稳定性。</p><p>住宅代理IP可以分为两种类型：<strong>静态IP和动态IP</strong>。这两者各有特点，适合不同的使用场景。<br/>今天，我们将深入探讨这两者的区别，并分享一些实际应用场景，帮助你根据自己的需求选择最合适的代理IP服务。</p><h2><strong>2. 静态IP与动态IP</strong></h2><h4><strong>什么是静态住宅IP？</strong></h4><p>静态住宅IP是指用户在一段时间内持续使用同一个IP地址。<br/>例如，在跨境电商中，静态IP可以帮助商家长期管理多个店铺，避免频繁更换IP导致的账号封禁问题。<br/>静态住宅IP有较高的信任度和稳定性，适合需要长期依赖同一IP进行操作的任务。<br/>不过，静态IP也有一个缺点——长时间使用同一个IP可能容易被监测和攻击，需要额外的安全防护。</p><h4><strong>什么是动态住宅IP？</strong></h4><p>动态住宅IP则是用户每次连接时都可能获得不同的IP地址，IP会定期变化。这种类型的IP非常适合需要高频切换IP、避免封号的场景，如数据抓取和爬虫任务。<br/>由于IP的不断变化，动态IP提供了更高的隐私性和安全性，难以追踪用户的位置和身份，尤其适用于需要匿名和保护隐私的用户。<br/>它非常适合短期用途，如临时连接互联网，但在长期稳定性上，可能不如静态IP。</p><h2><strong>3. 711Proxy的性价比优势</strong></h2><p>在选择代理服务时，<strong>性价比</strong>是许多用户关注的重要因素。<br/>711Proxy提供的住宅IP服务以其高性价比著称，尤其是在同类产品中，其价格相对更为亲民，但依然提供了稳定的网络连接和广泛的全球IP覆盖。</p><p>在当前市场上，动态住宅代理的价格普遍在$0.9/GB以上，而711Proxy的价格低至$0.55/GB，静态住宅代理更是低至$0.12/IP/天，这使得711Proxy成为许多用户的首选。<br/>无论是静态IP还是动态IP，711Proxy都能提供高稳定性的网络连接，确保流畅的使用体验，帮助用户轻松突破地域限制，访问全球内容。</p><h2><strong>4.如何使用711Proxy的静态和动态住宅代理IP？</strong></h2><h4><strong>购买711Proxy的动态住宅代理IP，可以做什么？</strong></h4><ul><li><strong>大规模数据抓取与爬虫</strong>：动态IP可以帮助你频繁切换IP，减少被网站封禁的风险，特别是在需要抓取大量数据时，这种切换非常重要。</li><li><strong>SEO优化</strong>：进行SEO优化时，使用动态IP从不同IP地址进行搜索，有助于避免搜索引擎识别到重复访问，降低被判定为不正当行为的风险。</li><li><strong>匿名浏览</strong>：如果你的需求是更高的匿名性，动态IP的频繁更换能有效隐藏你的真实位置和身份，为你提供额外的隐私保护。</li></ul><h4><strong>购买711Proxy的静态住宅代理IP，可以做什么？</strong></h4><ul><li><strong>跨境电商管理</strong>：静态IP适合用于管理电商平台账户，如亚马逊、eBay等，能够保持IP稳定，避免频繁更换导致的账号封禁问题。</li><li><strong>社交媒体运营</strong>：如果你在多个社交平台上运营账号，静态IP能够帮助你保持稳定的登录信息，减少因IP频繁变化而引起的封号问题。</li><li><strong>金融交易</strong>：对于需要长期身份认证的金融平台，静态IP能够确保账号的稳定性，帮助用户长期保持账户访问和交易的连贯性。</li></ul><h2><strong>5. 总结</strong></h2><p>今天的分享就到这里了。<br/>如果你在预算上有一定的考量，711Proxy作为高性价比的住宅代理IP提供商，能够为你提供稳定、安全的服务，同时还兼具全球覆盖与低廉价格。<br/>希望今天的内容对你有所帮助，感谢您的阅读！</p>]]></description></item><item>    <title><![CDATA[NocoBase 本周更新汇总：优化及缺]]></title>    <link>https://segmentfault.com/a/1190000047394582</link>    <guid>https://segmentfault.com/a/1190000047394582</guid>    <pubDate>2025-11-13 12:07:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>原文链接：<a href="https://link.segmentfault.com/?enc=sn5BpqKtAzv5lUYk73ZGjw%3D%3D.fagBxROliJ5b%2Fqh%2BzNQDB6R80E9mg4eMDwkjpegsOhqXChz5m%2B4GzlMC%2BxH1az8vx%2BhCePln1WNFxonq3cQUuw%3D%3D" rel="nofollow" target="_blank">https://www.nocobase.com/cn/blog/weekly-updates-20251113</a></p><p>汇总一周产品更新日志，最新发布可以<a href="https://link.segmentfault.com/?enc=Kp73q%2BD2lr9IasavPbnSfg%3D%3D.LGuUyBUFlJm0aJCc6tnfv2k6mBe4VcLLjeZvcuRTmOzBC5GYrXJ%2BBQvmDQK8nVYQ" rel="nofollow" target="_blank">前往我们的博客查看</a>。</p><p><strong>NocoBase 目前更新包括的版本更新包括三个分支：<code>main</code> ，<code>next</code>和 <code>develop</code>。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045493251" alt="version.png" title="version.png"/></p><p><code>main</code> ：截止目前最稳定的版本，推荐安装此版本。</p><p><code>next</code>：包含即将发布的新功能，经过初步测试的版本，可能存在部分已知或未知问题。主要面向测试用户，用于收集反馈和进一步优化功能。适合愿意提前体验新功能并提供反馈的测试用户。</p><p><code>develop</code>：开发中的版本，包含最新的功能代码，可能尚未完成或存在较多不稳定因素，主要用于内部开发和快速迭代。适合对产品功能前沿发展感兴趣的技术用户，但可能存在较多问题或不完整功能，不建议在生产环境中使用。</p><h2>main</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045409634" alt="main.png" title="main.png" loading="lazy"/></p><h3><a href="https://link.segmentfault.com/?enc=idzdTKHsb73cwdc4zKxDHw%3D%3D.MUJsUxBns7eS4%2FMQWM0KSFHd8MDnD9FT4UKrw3L0zmKf4ta48uy60HuMGD%2FiBOrd" rel="nofollow" target="_blank">v1.9.6</a></h3><p><em>发布时间：2025-11-12</em></p><h3>🐛 修复</h3><ul><li><strong>[client]</strong> 修复拖拽引用模板后再删除引用模板而导致的复制模板不显示的问题 (<a href="https://link.segmentfault.com/?enc=ZvUsUj9mEwA8vfQVeCXltw%3D%3D.0R6e%2FRISQ2eS0jI%2FTZFf3e7BLm8xqkL782GshMs4TyteQ%2BLb8haYbOOGHjvENQz8" rel="nofollow" target="_blank">#7847</a>) by @zhangzhonghe</li><li><strong>[utils]</strong> 为 intersect 策略增加对象类型支持 (<a href="https://link.segmentfault.com/?enc=THlNj35oVnV8RvNdsZQG2Q%3D%3D.Uls%2BXciyK26ASVyJ0OAVM89M6XzAOls7%2FqWuTUAtM179pZhyt3TBfRI7zwJD9iUg" rel="nofollow" target="_blank">#7840</a>) by @chenos</li><li><strong>[数据可视化：EChrats]</strong> 修复 ECharts 选项配置 labelType 不生效的问题 by @heziqiang</li><li><strong>[邮件管理]</strong> 没有时间戳的情况下同步微软邮件已读状态 by @jiannx</li></ul><h3><a href="https://link.segmentfault.com/?enc=f%2BaiHYuwkYQI1dm570JNTQ%3D%3D.kSKnQRN4NwlubG1XdUzK36CikwYVCCBq0735%2BIt6vkKfxbGnfkmWDDEgwtIq8yrW" rel="nofollow" target="_blank">v1.9.5</a></h3><p><em>发布时间：2025-11-10</em></p><h3>🐛 修复</h3><ul><li><strong>[工作流：审批]</strong> 修复重查关系数据时未屏蔽主表字段的问题 by @mytharcher</li><li><strong>[邮件管理]</strong> 修复 Outlook 内敛图片和同步问题 by @jiannx</li></ul><h3><a href="https://link.segmentfault.com/?enc=ZdOrohmC%2BNqlRlHtq7TzEw%3D%3D.PriC8eHYSa9tZJcVFjpTLnDDlBeZn4nsld74TAm%2BYyYpFwhyoRGX4dki3Omwfifq" rel="nofollow" target="_blank">v1.9.4</a></h3><p><em>发布时间：2025-11-10</em></p><h3>🚀 优化</h3><ul><li><strong>[权限控制]</strong> 优化关系字段关联操作的权限控制逻辑 (<a href="https://link.segmentfault.com/?enc=bwxMOtLjh20c0du5m72rfA%3D%3D.o0lkz%2FYClSZKwwkmsAqBvezaZLD1f50cww8ESguhTn4jvpglDAjr748mo9AefB%2Fw" rel="nofollow" target="_blank">#7800</a>) by @2013xile</li><li><strong>[工作流：JavaScript 节点]</strong> 修复传递到执行环境中的上层函数导致的安全漏洞，避免通过利用漏洞访问上层执行环境的问题 by @mytharcher</li><li><strong>[认证：OIDC]</strong> 增加请求超时时间 by @2013xile</li></ul><h3>🐛 修复</h3><ul><li><strong>[server]</strong> 修复消息队列在启用服务拆分模式后，工作进程发消息导致报错的问题 (<a href="https://link.segmentfault.com/?enc=5qd6anol7ayIurrGrXwfYA%3D%3D.%2ByhZVwXXQ0o1hNx5bkzTDjK9aVphYPJJM46HOELltBmIgObx7eFCp8%2BOX4VeD%2BsZ" rel="nofollow" target="_blank">#7797</a>) by @mytharcher</li><li><strong>[client]</strong> 修复详情区块简单分页出现空数据下一页的问题 (<a href="https://link.segmentfault.com/?enc=2rq3Lo01aAfSWQnyAwcr4A%3D%3D.4Oe8z%2FaMD%2BQ0SBWTi%2BoVPFNfyp8OYXchFWByguwWYQ%2FyYk6yIW850yUFsk2SPZEL" rel="nofollow" target="_blank">#7784</a>) by @katherinehhh</li><li><p><strong>[工作流]</strong></p><ul><li>为工作流的日志增加 <code>workflowId</code> 的数据标识 (<a href="https://link.segmentfault.com/?enc=zsanQGLNqGb4wqQ8Erhc%2FA%3D%3D.WFW04FpUs6wxWrY1sYS89rmtWdIzIAGSAsQv4uxCXJB6U5o9VLAQLKnjz1WTmXRj" rel="nofollow" target="_blank">#7789</a>) by @mytharcher</li><li>修复服务拆分模式下，工作流插件不处于服务模式时仍然消费队列的问题 (<a href="https://link.segmentfault.com/?enc=o2R4ooKYBaOa1xFXrMsdmg%3D%3D.iZVKb6bVNiTvuXuMA3pEpK%2FrHr7UOc6MJm2qeWN4nvun0B3Pca9ONf8Csb8S5bzA" rel="nofollow" target="_blank">#7820</a>) by @mytharcher</li></ul></li><li><strong>[用户]</strong> 字段名为 snake_case 风格时，索引字段重置不正确的问题 (<a href="https://link.segmentfault.com/?enc=zQxaQHndukPm8eBnyeBV1Q%3D%3D.QkvSXj60FjKPVOZVT%2F5h4kabByF1Bj%2Fb3CNT2%2B5MvQhup2Ah7eZSXukXNSlyaFq6" rel="nofollow" target="_blank">#7785</a>) by @2013xile</li><li><strong>[工作流：自定义变量节点]</strong> 修复变量节点缺失 config 时报错的问题 by @mytharcher</li></ul><h2>develop</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045493252" alt="develop.png" title="develop.png" loading="lazy"/></p><h3><a href="https://link.segmentfault.com/?enc=kV8UM61jEe8hYAGz2ws%2F%2Bw%3D%3D.Y6nYO6TOcATnwJ78Y6m9XqR%2FcN%2Fs9LjhNYedS5p2eilDrCv1m0049ZNVmuNYyqYce%2FjcB7Mo6kuXulGH%2Fva8kQ%3D%3D" rel="nofollow" target="_blank">v2.0.0-alpha.38</a></h3><p><em>发布时间：2025-11-12</em></p><h3>🎉 新特性</h3><ul><li><strong>[client]</strong> 支持表格列操作的拖动 (<a href="https://link.segmentfault.com/?enc=aiKfvr99n2wbCGpO8xk4LQ%3D%3D.WAXj95jPcSwV%2B8PvyRvjfCDHmjPpqdy9MdQJXFzwk8Aq8YOxaxM38Ej0UjZ%2FrZWN" rel="nofollow" target="_blank">#7842</a>) by @zhangzhonghe</li><li><strong>[数据可视化]</strong> 新增图表 SQL 数据源 (<a href="https://link.segmentfault.com/?enc=f%2FHP0WMLgWkAYJ6xUPfZpQ%3D%3D.%2FAYW8IXA7RmwuMsGbXjkdb%2FJ5wtxMBTHGFlIj3PBXVLJlr5Ef%2BCnEG%2F5%2FzKwvte7" rel="nofollow" target="_blank">#7830</a>) by @heziqiang</li></ul><h3>🚀 优化</h3><ul><li><strong>[client]</strong> 在 RunJS 脚本上下文中新增对 Day.js 库的支持，便于进行日期和时间的操作。 (<a href="https://link.segmentfault.com/?enc=LCmOBJxSoupwJkNZZ2qdYw%3D%3D.wIw4%2F6YD3IEWJAycqqszIR1hBAymdQWSUJisxW5U7MXnZt9wClZEKtR2zt8MXfTo" rel="nofollow" target="_blank">#7841</a>) by @gchust</li></ul><h3>🐛 修复</h3><ul><li><p><strong>[utils]</strong></p><ul><li>修复筛选按钮报错 “Invalid filter item type”  (<a href="https://link.segmentfault.com/?enc=7Oo1r%2F8ckMLkEErJ8k7HjQ%3D%3D.YtzfOLmvhB%2FlyfhjrbjksCk%2BQT75RhGTm%2BLSmJ3tqH%2BtLDDbgBK8OK706U59Xa%2Bn" rel="nofollow" target="_blank">#7838</a>) by @zhangzhonghe</li><li>为 intersect 策略增加对象类型支持 (<a href="https://link.segmentfault.com/?enc=qOhmwBgqZ1fiHNAJLpO6ow%3D%3D.066FMGeAC96bCcSaX8TJv5UGFP4k23iWX1%2FCjCdrqpB4TKZCLLBvkapZHv0kOf%2Bc" rel="nofollow" target="_blank">#7840</a>) by @chenos</li><li>修复事件流报 “Unrecognized operation” 的错误 (<a href="https://link.segmentfault.com/?enc=zjcOjfwmOqU66vMshghyMg%3D%3D.8y06E9%2Fp4kVKmNsBNpf%2Fo8ut6JwaxEHpqijsqgRz6rn%2FIS4NAYdzv6%2FKxwCyAIVl" rel="nofollow" target="_blank">#7835</a>) by @zhangzhonghe</li></ul></li><li><p><strong>[client]</strong></p><ul><li>修复了表格中行记录数据更新后，行操作按钮的联动规则未重新执行的问题，现在在数据变更时联动规则能够正确重新应用。 (<a href="https://link.segmentfault.com/?enc=xpl2YNSRwQ22tXltlp%2BVDQ%3D%3D.eehcKtUO4p3epxDIRM%2FhgD66V65kt3EeJ0g7Xy9N9EulQcnFxgig19bybgvnGUj6" rel="nofollow" target="_blank">#7832</a>) by @gchust</li><li>修复代码编辑器中预览代码时如果使用了 jsx 语法会报错的问题 (<a href="https://link.segmentfault.com/?enc=7zbXxW8WaOVwXhlVAA6a9A%3D%3D.uDG0gVYPFopwnyKh1hf2H%2BrqWrzXmJrD29LWIoEpypWrRYAYnFOx67TFqq62xxl0" rel="nofollow" target="_blank">#7836</a>) by @gchust</li></ul></li><li><strong>[undefined]</strong> 修复暗黑模式下的插件文档首页样式不正确的问题。 (<a href="https://link.segmentfault.com/?enc=S0SSI7UiuA3ZA6zug91yfQ%3D%3D.%2FkqzfKt%2FB502CwvLULatSn1hsbqR%2BoCoK3wXaAwTWPE5kyUwPujr5OY45Q1WDNRc" rel="nofollow" target="_blank">#7839</a>) by @gchust</li><li><strong>[文件管理器]</strong> 修复表格区块配置字段相关缺陷 (<a href="https://link.segmentfault.com/?enc=CTL63US30P1QAZqHR8dgQg%3D%3D.%2Bo%2FbYO%2F%2BgahRKoHUytqtoWBFVktHFKuJoyvCaWI9oBZWl3QZDvLm3Q2P6RJSNGvS" rel="nofollow" target="_blank">#7843</a>) by @katherinehhh</li><li><strong>[AI 员工]</strong> 在 v1 页面隐藏 AI 员工对话按钮 (<a href="https://link.segmentfault.com/?enc=fUFEn86FU8m0kbtXZ4AkTQ%3D%3D.rZEsJAoaWrmxOVTCS43baXNUGcCgPhRe%2BmGuVyvLmCbO%2Fcb9AID9KrBbB6nOwSHK" rel="nofollow" target="_blank">#7829</a>) by @cgyrock</li><li><strong>[数据可视化：EChrats]</strong> 修复 ECharts 选项配置 labelType 不生效的问题 by @heziqiang</li><li><p><strong>[邮件管理]</strong></p><ul><li>修复草稿问题 by @jiannx</li><li>没有时间戳的情况下同步微软邮件已读状态 by @jiannx</li></ul></li></ul><h3><a href="https://link.segmentfault.com/?enc=6HCqVYjT5dQEs4nlKtQ5Qw%3D%3D.cbwvDYAn33goh4C9grxWW%2Fw7Py1DQFf6b2uOqWC3Sp%2FNZNlGTuFfAICAhLXDOg%2B6Ces%2BgI1D8GK%2BFZbGuwTHVQ%3D%3D" rel="nofollow" target="_blank">v2.0.0-alpha.37</a></h3><p><em>发布时间：2025-11-11</em></p><h3>🚀 优化</h3><ul><li><p><strong>[client]</strong></p><ul><li>新增页面版本到 flow engine 上下文里 (<a href="https://link.segmentfault.com/?enc=z4p5kEu5M%2FEUkDswEcELAA%3D%3D.SiyZqNnqU6FO7Iejze1LjGAEVe%2F%2FC4K6%2Bi9g3cJBoLK4SuFggQwuo5TxNdkU136r" rel="nofollow" target="_blank">#7826</a>) by @gchust</li><li>优化 Markdown 编辑器 (<a href="https://link.segmentfault.com/?enc=PLEQkFi3qFb6UGWCbD17Ag%3D%3D.CV6uMiABQ0OHHZCFsXbq8wb5h55iVZK2pvmAVYFLBfFewfbTkyFq1dgwWuKjrYnS" rel="nofollow" target="_blank">#7793</a>) by @katherinehhh</li><li>2.0 区块适配 tableoid 字段 (<a href="https://link.segmentfault.com/?enc=lAKiTMVZXddC%2FH6kMEhDUQ%3D%3D.Dqgei%2F%2FkTeyfs6O%2B5HWaZv5VBoluIHMEtZrC2bvNAsCNZ0EiEGwfs9bfUDeGD25w" rel="nofollow" target="_blank">#7809</a>) by @katherinehhh</li></ul></li><li><strong>[数据可视化]</strong> 更新图表提示栏和事件代码模板注释 (<a href="https://link.segmentfault.com/?enc=5jcl2a0I%2BeaMCE40NLg6Iw%3D%3D.EE4hIDQLmqOleec48k1waefLuNzK1%2ByqcqrUuCsmUtFImDAYUS45eXaBC7ekaYDb" rel="nofollow" target="_blank">#7814</a>) by @heziqiang</li><li><strong>[权限控制]</strong> 优化关系字段关联操作的权限控制逻辑 (<a href="https://link.segmentfault.com/?enc=9WwWuJfnGwmdb8MoSzZfTg%3D%3D.bG%2FvyHcModgzPp8NdVtnlUivkE4rehze%2BPodGXbric6wVKFQB3BHAkFraOEkjn7%2B" rel="nofollow" target="_blank">#7800</a>) by @2013xile</li><li><strong>[认证：OIDC]</strong> 增加请求超时时间 by @2013xile</li></ul><h3>🐛 修复</h3><ul><li><strong>[server]</strong> 修复消息队列在启用服务拆分模式后，工作进程发消息导致报错的问题 (<a href="https://link.segmentfault.com/?enc=4Av1W2vuX7Eb9R5FdGSYtg%3D%3D.ThH4wGTJE6ArW89%2FyMU80rtNheTkuxht8Y8Drbv0cu7Ix3phhP7%2BmRXjQw6clLyG" rel="nofollow" target="_blank">#7797</a>) by @mytharcher</li><li><p><strong>[client]</strong></p><ul><li>当前数据表变量不应该可以从筛选组件的变量选择器中被选择 (<a href="https://link.segmentfault.com/?enc=Rur8VeHqTCWRayWBA%2FJjOg%3D%3D.cRgThL1a4HmOnikdjNRsPCAEsXo5A%2BboceSFCoGWN8kqDqnFJYoncp7tchTkfl1d" rel="nofollow" target="_blank">#7818</a>) by @gchust</li><li>修复筛选表单关系字段报错 “value.replace is not a function” (<a href="https://link.segmentfault.com/?enc=rGEcgxPffpesP1KNAZmpAw%3D%3D.oNiJ6F6BB6Dh4H9f7Lqd%2B5aKKdlKPHO6SdUQdTu%2BCHT426h4xFLuGL7awELYZgaG" rel="nofollow" target="_blank">#7824</a>) by @zhangzhonghe</li><li>修复 onChange 回调传参错误 (<a href="https://link.segmentfault.com/?enc=0rAu3Yg%2BJC1w%2B57bfWO4mw%3D%3D.I7Dtv6MBGqCCf75%2BpwwsvtF07dpopwkVgtsh9VLs7As7S2e7%2Bay%2For%2B%2F%2FVgEWLD8" rel="nofollow" target="_blank">#7807</a>) by @zhangzhonghe</li></ul></li><li><strong>[flow-engine]</strong> 修复事件流修改后需要刷新页面才会生效的问题。 (<a href="https://link.segmentfault.com/?enc=2YQM1yPwfpn1IbFIMS8D5A%3D%3D.V84GACBaILF9ZOUQIRrj6fXfiAcURbai5Sn3%2BJ6rzNRQvGqjwhF0DcCZvkFiZO22" rel="nofollow" target="_blank">#7811</a>) by @gchust</li><li><strong>[工作流]</strong> 修复服务拆分模式下，工作流插件不处于服务模式时仍然消费队列的问题 (<a href="https://link.segmentfault.com/?enc=6H5PHW2pmngjd%2BOj5XHbGg%3D%3D.2RxmhuO3PjtHvO8z7z%2BpDQ8RY2p3tA4p1Wx4tfbsZdfmZj4BnsqELf5MsABzWG%2Be" rel="nofollow" target="_blank">#7820</a>) by @mytharcher</li><li><strong>[工作流：审批]</strong> 修复重查关系数据时未屏蔽主表字段的问题 by @mytharcher</li><li><strong>[邮件管理]</strong> 修复 Outlook 内敛图片和同步问题 by @jiannx</li></ul><h3><a href="https://link.segmentfault.com/?enc=nUn6IXZi21IK2Gxuy%2FQRiw%3D%3D.3c8iHQemREUyGwrSX0C3r6%2BxTA9E9BfKFlWr0BoCGMOLK%2FAFHMvqJ3QgajU7EeqMqxdP9YsoQdzinUER%2B9N%2F2g%3D%3D" rel="nofollow" target="_blank">v2.0.0-alpha.36</a></h3><p><em>发布时间：2025-11-10</em></p><h3>🚀 优化</h3><ul><li><strong>[flow-engine]</strong> 优化页面标签的工具栏样式 (<a href="https://link.segmentfault.com/?enc=BIQk6TPnYlLi9OYw3%2FMxhw%3D%3D.CV%2BXfY3okvAdhfjUvHS4O2jGLZ32vZYzo235eg3nNhDqQCUd0IPNd4m5a9E0uyxZ" rel="nofollow" target="_blank">#7795</a>) by @zhangzhonghe</li></ul><h3>🐛 修复</h3><ul><li><p><strong>[flow-engine]</strong></p><ul><li>修复了子表单关系字段通过用户界面修改后，其变量无法正确解析的问题。 (<a href="https://link.segmentfault.com/?enc=JvHC3BXSPBP4FRbt6oDf3A%3D%3D.4ZXpIddYlbsqmF%2B7Ym8UUrnz%2Fyb4yvZ5akoZrr0RHsvA%2FNIoOb%2FYBGikLFbbTHmk" rel="nofollow" target="_blank">#7799</a>) by @gchust</li><li>多主键记录编辑表单报错 (<a href="https://link.segmentfault.com/?enc=xWeiYoK7cgEJV7TrGy7Kxw%3D%3D.CTQ6GgIaWNrYBB%2Bw8rRwLleCcpVX0rD6z7khxOhUWfMdRWirajhTNS1xNFxPXBOS" rel="nofollow" target="_blank">#7798</a>) by @gchust</li><li>修复了“打开视图”操作的部分配置未正常应用的问题，现在所有相关配置均能按预期正常运行。 (<a href="https://link.segmentfault.com/?enc=Jktj0mm9Q722HLhVNWJQtw%3D%3D.m9RDbCdt6xHd6L%2F8fp7mLPYAIXtYtUL3F%2BImZQUBpn8Hy3LHzIoRDyutLjdBQvJl" rel="nofollow" target="_blank">#7790</a>) by @gchust</li></ul></li><li><p><strong>[client]</strong></p><ul><li>修复数据表选择器字段无法正确选择数据的问题 (<a href="https://link.segmentfault.com/?enc=grZStJjMW9IKVnPpC%2BtVXg%3D%3D.ET%2FVEp%2F7pB%2F6cHB%2BGVmUNdv1KlbGC3W5D829TMsNepQwdqZShAlg0VPVUI45mAww" rel="nofollow" target="_blank">#7794</a>) by @katherinehhh</li><li>表格区块操作列无法被隐藏 (<a href="https://link.segmentfault.com/?enc=XTfCnO4pVl1FwlAXef3R0Q%3D%3D.HC3OkuwhTH67vheHRLu%2BR1D%2BbJ71jMKJMMuhczsWs78tzOT3gnKWNZikAcijoP4A" rel="nofollow" target="_blank">#7804</a>) by @gchust</li><li>支持在 AI 员工指令里选择整个变量对象 (<a href="https://link.segmentfault.com/?enc=8D5r4ntaBBV9SORmG9zAHg%3D%3D.H6bfPfv0nxEgW63VHVQXqxnm4xYD9B72Ws53xDhIUTIjNfMK2Y3hDCbF1CWdAv08" rel="nofollow" target="_blank">#7791</a>) by @gchust</li></ul></li><li><strong>[用户]</strong> 字段名为 snake_case 风格时，索引字段重置不正确的问题 (<a href="https://link.segmentfault.com/?enc=q2QhNWeDr7YLlDXEvWGiKg%3D%3D.Mp2CIUt3r9RKapV0v0%2BKpykp37lIbEMeMgBnrmuwq0iBu7jCqZR2%2Bh52P9piYWox" rel="nofollow" target="_blank">#7785</a>) by @2013xile</li></ul><h3><a href="https://link.segmentfault.com/?enc=bSB6cfoSUyqFWoAvKYMvCw%3D%3D.Dt0VOvdjS9X6EI5dEdlgYCHeJX11MOY9xqwkBvwIbkUXQqiP5vL2WByyTtdMZ8NRh%2FqSe%2Fi2tGj8yObNnG7QWw%3D%3D" rel="nofollow" target="_blank">v2.0.0-alpha.35</a></h3><p><em>发布时间：2025-11-06</em></p><h3>🚀 优化</h3><ul><li><strong>[flow-engine]</strong> 支持延迟操作 flow model (<a href="https://link.segmentfault.com/?enc=0smUMvPtDQGVNIkgeST3jg%3D%3D.CvI0FGrmKLaMu97yFBGhWmaE9QPixIqodU%2Bd1g8WO1KIrGJo2IBa%2Fr2mYgYq5EDL" rel="nofollow" target="_blank">#7786</a>) by @gchust</li><li><strong>[工作流：JavaScript 节点]</strong> 修复传递到执行环境中的上层函数导致的安全漏洞，避免通过利用漏洞访问上层执行环境的问题 by @mytharcher</li></ul><h3>🐛 修复</h3><ul><li><p><strong>[client]</strong></p><ul><li>修复详情区块简单分页出现空数据下一页的问题 (<a href="https://link.segmentfault.com/?enc=ryZsxY9i2hRLVsI1N7nl%2Bw%3D%3D.RAAvL7BCiIaiMUx21RWO8ldqjlf38iQNqt9893xJI1ecgofX7NIUlZFXiBdpu6kX" rel="nofollow" target="_blank">#7784</a>) by @katherinehhh</li><li>修复表格操作列和 jsColumn 列宽度设置不生效问题 (<a href="https://link.segmentfault.com/?enc=hjuP%2BLyP3H3sJauPhq4L4A%3D%3D.%2Fe3KHZdQ4EfiVaT4Eu4WblMMY3i2OkmOcSF0CHxsMI98lAu2lpqwtwFEejQX%2FUtY" rel="nofollow" target="_blank">#7777</a>) by @katherinehhh</li><li>页面的事件流设置页面区块数据范围不生效 (<a href="https://link.segmentfault.com/?enc=lzbIA6Rvik0T4LLho8FRxw%3D%3D.pJnvqhtt3tXq%2FSanhOVOrIKi%2FGF5lTQX1HzFRIPryNaxMAW3aD3CVgV4x7eELhic" rel="nofollow" target="_blank">#7788</a>) by @gchust</li></ul></li><li><strong>[工作流]</strong> 为工作流的日志增加 <code>workflowId</code> 的数据标识 (<a href="https://link.segmentfault.com/?enc=D4253VE5HAczunjCrdjSXw%3D%3D.uCvUnKDR%2BZ4%2Brs6PaIISNWlqpRIsN4Y5o3eRHAihhTdy7Eevt0FuJCOyp1wVWyAH" rel="nofollow" target="_blank">#7789</a>) by @mytharcher</li><li><strong>[工作流：自定义变量节点]</strong> 修复变量节点缺失 config 时报错的问题 by @mytharcher</li><li><strong>[邮件管理]</strong> MailMessages 添加索引 by @jiannx</li></ul>]]></description></item><item>    <title><![CDATA[观测云产品更新 | 监控、Obsy AI]]></title>    <link>https://segmentfault.com/a/1190000047394585</link>    <guid>https://segmentfault.com/a/1190000047394585</guid>    <pubDate>2025-11-13 12:07:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>观测云更新</h2><h3>付费计划与账单</h3><p>“应用性能/LLM Trace”计价调整。点击查看<a href="https://link.segmentfault.com/?enc=NdxMrMX984PJ1HSWMFFKDw%3D%3D.etsV6SpNesIjjxm0Pf7CWsVfGQM%2FvjlTEbINlwoPrS%2BEx9spMHZDgDYJiRHy81Cqo7sxZ7Jakk9wIXm395Uy442z8b1aB81pCYHjHLOUJiQ%3D" rel="nofollow" target="_blank">计费产生逻辑</a>与<a href="https://link.segmentfault.com/?enc=%2F0SvGhTELIiQBRDf7oTkgQ%3D%3D.dh97Af1P1FbIo83O5XPHdQtytBZz0sr5MlesF7eLHPKbz8hRp1pqJHpd7YJ1aycHLYr80ScgMuwa6KXAOH6tfA%3D%3D" rel="nofollow" target="_blank">价格明细</a>。</p><h3>监控</h3><p>新增<a href="https://link.segmentfault.com/?enc=VbMayK9aCLXkVMPo%2B20IsA%3D%3D.H%2BYsdr5nkxFGWs359zoKnsz1f4QocB3alU5t%2BIuA3psf4dcgxPWvs2Pn5DJ6KfS1OaX86qlvpe1E25f%2FJCtz0ffRYzBLaxEZ8AT6Xqjdgig%3D" rel="nofollow" target="_blank">可编程检测</a>监控器，通过脚本编写检测规则，覆盖对各种系统数据类型的检测需求。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394587" alt="图片" title="图片"/></p><h3>Obsy AI 智能体</h3><p>新增支持异常分析。基于输入文本，Obsy AI 智能体能够将复杂紊乱的信息智能整合，为您生成清晰、简洁的根因分析结果。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394588" alt="图片" title="图片" loading="lazy"/></p><h3>MCP Server</h3><p>新增支持接入 <a href="https://link.segmentfault.com/?enc=J1G0ScbJE1p495Zk1HHqBQ%3D%3D.6vGtYZwyy6%2FBl%2Bd0Ei6akCIb3ZzUbmY9kAy4qk5c%2Bcfq5C7mluOzDN%2B%2BCRGuO%2BvM" rel="nofollow" target="_blank">MCP Server（模型上下文协议）</a>。作为一个开放协议，为观测云 Obsy AI 智能体提供统一的多模型可调用接口服务，支持多客户端接入，通过 API Key 鉴权方式访问观测云的监控器、日志、仪表板及 DQL 查询等能力。</p><h3>管理</h3><p>1、<a href="https://link.segmentfault.com/?enc=SVP8I0gkbMag1mNIBzzn8g%3D%3D.1GOEptzQBnZjtyScJ1K7XDkCq0GB5cq5bK20fJGxcLjK5zpi%2Bz8zJRMu3vQuluYc" rel="nofollow" target="_blank">角色管理</a>：场景配置管理/监控器权限拆分。</p><ul><li><p>场景配置管理：权限细分为</p><ul><li>仪表板、视图查看</li><li>仪表板管理</li><li>视图管理</li><li>笔记、查看器管理</li></ul></li><li>监控器：拆分成监控器查看、管理权限。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394589" alt="图片" title="图片" loading="lazy"/></p><p>2、字段管理：新增“<a href="https://link.segmentfault.com/?enc=i72m%2FO1KRcLeatqOZNzuFA%3D%3D.9%2F%2B0CURYhC2VH8fvkKCUearoql9QwRnj0Jf5mmBE6oXFOWCIUb4DlWSV3GjJXgin68yJIQCIs9YqVdXosWz8fA%3D%3D" rel="nofollow" target="_blank">属性分类</a>”配置项，包含：系统字段、业务字段、其他。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394590" alt="图片" title="图片" loading="lazy"/></p><p>3、空间设置：</p><ul><li>新增“<a href="https://link.segmentfault.com/?enc=B3YQuAAyj4JFsQuxeqmVGA%3D%3D.GcdEHEem00%2FO8SaM2J2RGyrXxZQdr31iHD4j9DrCi5l7UBBtjgvoLGbsfu8T%2F2mxkUsLoP8pDdrdMxBi9WfA8w%3D%3D" rel="nofollow" target="_blank">数据上报 IP 白名单</a>”配置，开启后，仅白名单内的出口 IP 可正常上报数据，其余来源数据将被拦截。</li><li>原 “IP 白名单”配置更名为“登录 IP 白名单，开启登录（主机）IP 白名单后，仅白名单中的来源可以正常登录，其他来源请求均会被拒绝访问。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394591" alt="图片" title="图片" loading="lazy"/></p><h3>LLM 监测</h3><p>新增<a href="https://link.segmentfault.com/?enc=FpawfmB78663GwQagzv2Tg%3D%3D.ZiISqkDrS3uEGWeaHZ8Xt7uMsTBtIJfPi%2BPQbBa3dW1izI77O2IjvE1aLTjeRoeg" rel="nofollow" target="_blank">模型质量评估分值、描述等信息</a>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394592" alt="图片" title="图片" loading="lazy"/></p><h3>事件中心</h3><p>变更事件：新主机接入后，将生成新的变更事件。</p><h3>场景</h3><p>1、时序图<a href="https://link.segmentfault.com/?enc=%2ByODbL%2BFzII1rTuzv%2Bpb%2Fg%3D%3D.O%2Feyq5Pjhlg3H5wCfF8DLHj9iUmnhTdMM%2BVrtGB0dlMchkc25bBV1rl2nIry%2F2x7bqMKNrK8WAuMwS5jcvmXdw%3D%3D" rel="nofollow" target="_blank">分析模式</a>新增样式切换和同期对比；</p><p>2、图表新增“在指标分析中打开”功能。可以从任意图表无缝衔接至指标分析界面，系统会自动带入已设定的查询条件。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394593" alt="图片" title="图片" loading="lazy"/></p><h3>查看器</h3><p>1、日志查看器：显示字段同时支持筛选值；</p><p>2、所有查看器：新增字段类型图标展示。</p><h3>日志索引</h3><p>1、日志索引：新增<a href="https://link.segmentfault.com/?enc=Utxsj03n2MjpFKQpebKKPA%3D%3D.DhEZS%2FkQPHQdkeXc9esltovwbYjykGSQu8yJl1K97ovUk3fso3vcL4C8lmlO10%2Bt08tpAbioeZxOM3A0pM1Hxg%3D%3D" rel="nofollow" target="_blank">描述与关联服务配置</a>。在查询链路时，系统将自动关联匹配的服务索引。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394594" alt="图片" title="图片" loading="lazy"/></p><p>2、外部索引：新增索引描述配置；</p><p>3、查看器应用索引时支持单/多选模式切换。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394595" alt="图片" title="图片" loading="lazy"/></p><h3>应用性能监测</h3><p>服务拓扑：新增服务最大响应时间显示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394596" alt="图片" title="图片" loading="lazy"/></p><h3>用户访问监测</h3><p>查看器 &gt; Fetch/XHR tab 页：原“请求”列改名为“资源 URL”，并支持显示完整 URL，可通过按钮切换显示与否。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394597" alt="图片" title="图片" loading="lazy"/></p><h3>云账号管理</h3><p>新增搜索控件，可搜索关键字进行模糊匹配。</p><h2>集成更新</h2><ul><li>新增火山引擎 PostgreSQL 集成；</li><li>新增阿里云 CPFS 集成；</li><li>新增阿里云 ALB 集成；</li><li>优化阿里云 NAT 视图优化；</li><li>优化腾讯云云监控；</li><li>优化阿里云 Oceanbase 仪表板；</li><li><p>新增 Pipeline 模版：</p><ul><li>AWS ELB</li><li>Squid</li><li>Kong</li><li>CloudFront</li><li>CloudTrail</li></ul></li><li><p>新增云采集器模版：</p><ul><li>阿里云 cfw/cen/apigateway/mqtt/nas/OceanBase/ga；</li><li>AWS step function/ssm run command/waf2；</li><li>华为云 apic/apig/auto_scaling/cbr/cdm/css_es/dcaas；</li></ul></li><li><p>新增 CSPM 模版：</p><ul><li>S3 存储桶应启用“屏蔽公共访问”功能；</li><li>S3 存储桶应启用版本控制功能；</li><li>S3 通用型存储桶应配置生命周期规则。</li></ul></li></ul>]]></description></item><item>    <title><![CDATA[ChatGPT Plus 订阅终极指南：]]></title>    <link>https://segmentfault.com/a/1190000047394611</link>    <guid>https://segmentfault.com/a/1190000047394611</guid>    <pubDate>2025-11-13 12:06:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>你是否也遇到了这样的情况：手握着免费版的 ChatGPT，却时常在高峰期“排队等候”，或者眼馋地看着别人用 GPT-5 生成惊艳的代码、用 DALL-E 绘制精美的图片，而自己的免费版却提示“功能受限”？</p><p>ChatGPT Plus，每月20美元，它就像一张通往 AI 新世界的“快车票”。但这张票到底值不值？尤其是对于我们中国大陆的开发者和用户来说，想买这张票，中间还隔着“三座大山”。</p><p>别担心，这篇文章就是为你准备的。我将带你深入探究 Plus 版的“里子”（它到底强在哪），并为你（保姆级）详解目前跨越障碍的四种主流“上车”路径。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394613" alt="" title=""/></p><h2>一、2025年 ChatGPT Plus 到底值不值？</h2><h3>💰 订阅成本与价值主张</h3><p>截至2025年第四季度，OpenAI 的订阅模式非常清晰，不同层级对应着天差地别的体验：</p><ul><li><strong>ChatGPT 免费版</strong>：基础访问，限制严格，更像是功能展示 。</li><li><strong>ChatGPT Plus</strong>：标准订阅，<strong>每月20美元</strong>。这是绝大多数专业用户和“超级用户”的核心选择。它提供了高峰时段优先访问、更快响应及新功能优先体验 。</li><li><strong>ChatGPT Pro</strong>：专为“个人超级用户”设计，每月200美元 。提供“对所有模型的无限制访问”和“无高级功能使用上限” 。</li></ul><h3>🌏 一个残酷的现实：OpenAI 的“双标”市场策略</h3><p>在我们讨论如何订阅之前，必须认清一个现实：中国大陆用户订阅的重重障碍，并非偶然的技术疏忽，而是 OpenAI 精心制定的、<strong>存在分叉的全球市场准入策略</strong>的直接后果。</p><p>分析显示，OpenAI 在技术和金融两个层面都明确将中国大陆排除在支持范围之外 。但与此同时，它却在其他市场“大撒网”：</p><ul><li><strong>印度市场</strong>：自2025年11月4日起，为所有印度用户提供长达12个月的免费“ChatGPT Go”（功能等同 Plus） 。</li><li><strong>美国市场</strong>：为美国退伍军人提供12个月的免费 ChatGPT Plus 访问权限 。</li></ul><p>这种鲜明对比表明，OpenAI 完全有能力进行本地化推广 ，但已在战略上选择（或因监管原因被迫）不进入大陆市场。因此，我们面临的是一个战略层面的市场壁垒，而不只是“支付不方便”。</p><p><strong>表1：ChatGPT 订阅层级对比 (2025年 Q4)</strong></p><table><thead><tr><th align="left">功能</th><th align="left">ChatGPT 免费版</th><th align="left">ChatGPT Plus 版</th><th align="left">ChatGPT Pro 版</th></tr></thead><tbody><tr><td align="left"><strong>价格</strong></td><td align="left">免费</td><td align="left">$20/月</td><td align="left">$200/月</td></tr><tr><td align="left"><strong>GPT-5 模型访问</strong></td><td align="left">受限访问 2</td><td align="left">优先访问 2</td><td align="left">无限制访问</td></tr><tr><td align="left"><strong>GPT-5 消息限制</strong></td><td align="left">10条 / 5小时</td><td align="left"><strong>160条 / 3小时</strong> 1</td><td align="left">无限制</td></tr><tr><td align="left"><strong>GPT-4o 模型访问</strong></td><td align="left">降级后使用 (GPT-4o mini)</td><td align="left">包含</td><td align="left">包含</td></tr><tr><td align="left"><strong>DALL-E 图像生成</strong></td><td align="left">约 5张 / 天</td><td align="left"><strong>50张 / 3小时</strong></td><td align="left">无限制</td></tr><tr><td align="left"><strong>高级语音模式</strong></td><td align="left">标准语音</td><td align="left">高级语音模式</td><td align="left">高级语音模式</td></tr><tr><td align="left"><strong>高级数据分析</strong></td><td align="left">不支持</td><td align="left"><strong>支持</strong></td><td align="left">支持</td></tr><tr><td align="left"><strong>自定义 GPTs</strong></td><td align="left">仅使用</td><td align="left"><strong>创建和使用</strong></td><td align="left">创建和使用</td></tr><tr><td align="left"><strong>ChatGPT Tasks</strong></td><td align="left">不支持</td><td align="left"><strong>支持</strong></td><td align="left">支持</td></tr></tbody></table><hr/><h2>二、Plus 的核心价值：这20美元究竟花在哪了？</h2><p>订阅 Plus 的核心，就是为了获得超越免费版的<strong>模型性能</strong>、<strong>使用配额</strong>和<strong>专业工具套件</strong>。</p><h3>🚀 模型访问：GPT-5 与 GPT-4o 的绝对优势</h3><ul><li><strong>GPT-5 访问权</strong>：Plus 用户可以访问 OpenAI“最先进的模型”，具备强大的多模态能力（理解文本、图像和音频） 。它能以“研究级智能”处理科学、数据分析等复杂工作 。</li><li><strong>GPT-4o 访问权</strong>：订阅中也包含了对上一代旗舰 GPT-4o 的持续访问 。</li><li><strong>使用限制（关键！）</strong>：免费版使用 GPT-5 每5小时仅10条消息，随后降级 。而 Plus 计划提供了<strong>每3小时160条消息</strong>的超高吞吐量。</li><li><strong>推理时间控制</strong>：Plus 用户可以控制“思考时间”，在“快速回答”和“深度推理”之间自由选择 。</li></ul><h3>📊 高级数据分析 (ADA)：你的“初级数据分析师”</h3><p>这是 Plus 版展现专业工具属性的核心功能。用户可以直接上传文件（如 .csv, .pdf, .py）进行分析 。</p><p><strong>能力展示：</strong></p><ul><li><strong>交互式表格</strong>：自动创建可滚动的数据表格视图 。</li><li><strong>自动图表</strong>：自动（或指定）创建“交互式图表” 。</li><li><strong>高级推理</strong>：可执行复杂任务，如对测试数据运行回归分析、可视化复杂的业务指标 。</li></ul><p>此功能 14 使 ChatGPT 从一个“聊天玩具”转变为一个“初级数据分析师”，极大地提升了生产力。</p><h3>🗣️ 多模态能力：更自然的语音和图像</h3><ul><li><strong>高级语音模式</strong>：免费版是“语音转文本”再处理。Plus 版的“高级语音模式”则直接处理语音流，实现了<strong>更自然、更实时的对话体验</strong> 12，非常适合头脑风暴 。</li><li><strong>DALL-E 图像生成</strong>：Plus 版每3小时可生成50张图像，相比免费版每天仅2-5张的限制是巨大的飞跃，对设计和内容创作至关重要。</li></ul><h3>🤖 生产力与自动化：自定义 GPTs 与 "Tasks"</h3><ul><li><strong>自定义 GPTs</strong>：创建和使用针对特定重复任务（比如“代码审查助手”、“周报生成器”）训练的自定义 GPTs 。</li><li><strong>ChatGPT Tasks (划重点)</strong>：这是一项付费用户独享的<strong>新型自动化功能</strong> 。你可以安排提示自动运行（例如，“每天早上8点，总结最新的 AI 行业头条并发送给我”）。</li></ul><p>“Tasks”功能 标志着 ChatGPT 从一个“被动响应”的工具，向一个<strong>“主动智能体”</strong>的根本转变。即使用户离线，它也能执行任务并通过邮件发送结果。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394614" alt="" title="" loading="lazy"/></p><h2>三、“三座大山”：我们为什么无法轻松订阅？</h2><p>大陆用户无法直接订阅，这不是简单的“支付失败”，而是一个由技术、监管和企业政策构成的多层次、系统性的封锁。</p><ol><li><strong>技术障碍 (GFW)</strong>：防火墙的深度包检测（DPI）现在能以“99.7%的准确率”识别和阻止 ChatGPT 的流量模式 。这使得“传统的VPN解决方案”在很大程度上失效 。</li><li><strong>监管障碍 (国内)</strong>：由于“监管限制”，国内的金融机构（如工行、建行等）普遍拒绝向 OpenAI 付款 。你尝试使用国内发行的 Mastercard 或 Visa 卡时，会从银行层面被拒绝。</li></ol><h3>衍生的“整体身份”问题</h3><p>一个成功的订阅方案，必须同时绕过上述所有三层障碍。</p><ul><li>传统的梯子（第1层）+ 国内卡（第2、3层）= <strong>失败</strong>。</li></ul><p>因此，成功的订阅需要你构建一个完整的、非大陆的数字身份：</p><ul><li>一个非大陆的 IP 地址（来自未被识别的 高级代理）。</li><li>一个非大陆的支付方式（如美国虚拟卡）以绕过第3层。</li><li>该支付方式的非大陆资金来源，以绕过第2层。</li><li>一个非大陆的账单地址 。</li></ul><p>我们常说的“代充”，本质上就是对这个复杂数字身份模拟过程的通俗表述。接下来的教程，就是构建这种模拟身份的指南。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394615" alt="" title="" loading="lazy"/></p><h2>四、路径一：最省心的——iOS App Store 订阅</h2><h3>原理</h3><p>此方法利用苹果 App Store 作为金融中介，完美绕过了 OpenAI 的 Stripe 支付（第3层）和国内的限制（第2层）。我们利用苹果强大的全球支付基础设施，让它充当“代理”。OpenAI 信任苹果，而苹果接受我们通过礼品卡充值的“非中行”余额。</p><h3>操作教程</h3><ol><li><strong>前提1：网络</strong>：确保你拥有一个稳定的、提供美国或欧洲 IP 地址的代理解决方案。</li><li><strong>前提2：外国 Apple ID</strong>：创建或获取一个非中国大陆的 Apple ID（例如，“美区 App Store 账户” ）。</li><li><strong>前提3：下载应用</strong>：使用该外国 Apple ID，登录 App Store 并下载官方的“iOS chatgpt app” 。</li><li><strong>资金准备</strong>：退出所有大陆的 Apple ID。登录你的外国 Apple ID。</li><li><strong>获取礼品卡</strong>：访问第三方市场（，购买“你相关 App Store 地区的 iOS 礼品卡”（例如，美国 iTunes 礼品卡）。</li><li><strong>兑换充值</strong>：在外国 Apple ID 的账户设置中“兑换”购买的礼品卡代码，将其充值到账户余额中 。</li><li><strong>订阅服务</strong>：打开 ChatGPT 应用，在应用内选择“升级到 Plus”，并完成“在应用内购买 gpt plus” 。苹果将从已兑换的礼品卡余额中扣除20美元。</li></ol><h3>风险与成本分析</h3><ul><li><strong>成本</strong>：高。你需要为外国礼品卡支付溢价，加价“通常会增加 10-15% 的成本” 。</li><li><strong>成功率</strong>：非常高。由于苹果可靠的支付处理，该方法的成功率高达 95%+ 23。</li><li><strong>风险</strong>：风险从支付转移到了账户安全。你的外国 Apple ID（尤其是从非官方渠道购买的）可能因欺诈活动而被苹果公司封禁。</li></ul><h2>五、路径二：最“主权”的硬核玩家——虚拟卡（VCC）</h2><h3>原理</h3><p>这是技术上最复杂，但也是最“主权”（自己掌握一切）的方法。它涉及创建一个 OpenAI 的 Stripe 处理器会接受的、真正的、非大陆支付工具（即虚拟卡）。</p><p>该策略是一个<strong>金融桥梁</strong>。我们面临的核心挑战是绕过外汇管制 。此方法使用加密货币（如 USDT）作为“桥梁”，将价值从人民币（转移到美元（在 VCC 上）。</p><h2>六、路径三：最便宜的“冒险合租”——共享账户</h2><h3>原理</h3><p>这是最字面意义上的“代充”：付钱给别人以获取访问权限。此方法涉及“团购”平台，这些平台销售对单个 Plus 账户的共享访问权。</p><p>流程：平台在购买官方订阅，然后将该账户的“位置”转售给3-6人 。你向该平台付款（接受支付宝等本地支付），并收到一个共享的电子邮件/密码 。</p><h3>成本与风险分析</h3><ul><li><strong>成本</strong>：极低。这是主要吸引力。价格“不到官方价格的一半” ，例如每月低至5.62欧元 ，甚至在某些 Telegram 群组中低至每月约0.70美元 。</li><li><p><strong>风险</strong>：<strong>极高</strong>。你是在用<strong>安全性、隐私和合法性</strong>来换取低成本。</p><ol><li><strong>直接违反服务条款 (TOS)</strong>：OpenAI 的政策明确规定：“您的 OpenAI 账户仅供您（创建它的个人）使用。……不允许账户共享”。这不是灰色地带，这是直接违规。<strong>账户被暂停的风险很高</strong> 。</li><li><strong>隐私完全丧失 (最严重)</strong>：“历史记录将在不同的人之间共享” 。<strong>群组中的任何人都可以阅读你的所有提示和回复</strong>。共享任何个人身份信息（PII）、个人秘密或机密工作数据都将是灾难性的。</li><li><strong>安全风险</strong>：你被给予登录凭证，而不是创建自己的。这使你面临欺诈和数据泄露的风险。</li></ol></li></ul><p>此方法仅适用于那些<strong>隐私需求为零</strong>、且不保证服务连续性的非敏感、临时性使用。</p><hr/><h3><strong>方案七、路径四：第三方代充服务（时间成本考量）</strong></h3><p>对于追求效率、不愿在支付流程上耗费过多精力的开发者而言，这是一个值得考虑的选项。</p><ul><li><strong>技术原理</strong>：本质上是将方案二（海外实体卡支付）委托给拥有支付资源的第三方服务商来完成。服务商（<code>jieagi.com</code>）使用其合规的支付方式登录用户的OpenAI账户进行代付。</li><li><strong>适用人群</strong>：希望快速解决问题、将精力聚焦于核心工作、认为时间成本高于服务费用的开发者。</li><li><p><strong>优缺点分析</strong>：</p><ul><li><strong>优点</strong>：极度省时省力，用户无需进行任何复杂操作，即刻获得服务。</li><li><p><strong>缺点</strong>：</p><ul><li>需要支付一定的服务费。</li><li>需要将账户授权给第三方，对服务商的信任是关键，存在安全风险。</li></ul></li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394616" alt="" title="" loading="lazy"/></p><h2>八、写在最后：你应该怎么选？</h2><p>对于中国大陆的用户来说，不存在“安全”或“官方”的订阅方法。我们面临的选择不是是否承担风险，而是<strong>选择承担哪种风险</strong>。</p><p><strong>表2：大陆订阅策略比较</strong></p><table><thead><tr><th align="left">策略</th><th align="left">预估设置成本</th><th align="left">预估月费</th><th align="left">技术复杂度</th><th align="left">隐私/安全</th><th align="left">封号风险</th></tr></thead><tbody><tr><td align="left"><strong>策略1：iOS 应用内购买</strong></td><td align="left">低</td><td align="left">$20 + 10-15% 溢价 23</td><td align="left">中</td><td align="left">高</td><td align="left">低/中（Apple ID 风险）</td></tr><tr><td align="left"><strong>策略2：VCC (加密货币)</strong></td><td align="left">高（加密货币费用）19</td><td align="left">$20</td><td align="left"><strong>非常高</strong></td><td align="left">高</td><td align="left">中（支付/KYC 风险）</td></tr><tr><td align="left"><strong>策略3：账户共享 (Gamsgo)</strong></td><td align="left">无</td><td align="left">$1 - $7 26</td><td align="left">非常低</td><td align="left"><strong>无</strong></td><td align="left"><strong>高（TOS 违规）</strong></td></tr><tr><td align="left"><strong>策略4：服务商订阅</strong></td><td align="left">效率最高，省时省心</td><td align="left">$20 + 10-15% 溢价</td><td align="left">中</td><td align="left">高</td><td align="left">低/中（无泄漏账号密码风险）</td></tr></tbody></table><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394617" alt="" title="" loading="lazy"/></p><h3>界智通{jieagi}的最终建议</h3><p>作为一名编辑，我不能认可任何一种方法，因为它们都伴随高风险。但基于不同的用户画像，我的专业建议是：</p><ol><li><p><strong>对于重视隐私和控制权的用户（例如，开发者、研究人员）：</strong></p><ul><li><strong>VCC 方法（策略2）</strong>虽然极其复杂，但它是唯一能让你获得一个<strong>主权的、私密的、由自己控制</strong>的账户的方法。</li><li><strong>iOS 方法（策略1）</strong> 是第二选择，它提供了高隐私性，技术设置较少，但需要持续支付溢价。</li></ul></li><li><p><strong>对于重视成本和便利性的用户（例如，临时、非敏感使用）：</strong></p><ul><li><strong>账户共享方法（策略3）</strong> 是最便宜和最简单的。但此建议附带一个至关重要的、不可妥协的警告：<strong>你必须假设你输入的每一个字符都是公开的</strong>。该方法完全不适用于任何敏感的、个人的或专业的工作。</li></ul></li></ol><p>希望这篇深度解析能帮助你做出最适合自己的决策。</p><blockquote><ul><li><strong>版权信息：</strong> 本文由界智通(jieagi)团队编写，图片、文本保留所有权利。未经授权，不得转载或用于商业用途。</li></ul></blockquote>]]></description></item><item>    <title><![CDATA[openFuyao亮相2025沙中开源与]]></title>    <link>https://segmentfault.com/a/1190000047394628</link>    <guid>https://segmentfault.com/a/1190000047394628</guid>    <pubDate>2025-11-13 12:05:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>[沙特阿拉伯，利雅得，2025年11月11日] 由沙特程序员协会（SAFCSP）主办，沙特通信与信息技术部（MCIT）、数字政府管理局（DGA）、沙特投资部（MISA）、中国驻沙特阿拉伯大使馆、沙特科技联盟等机构共同支持的2025沙中开源与AI科技峰会（Saudi-China Open Source Exchange）在沙特Garage国家科创孵化器中心成功举行。作为AI云原生技术与全球开源生态建设的积极参与者，openFuyao在本次峰会上向与会沙中企业、技术专家、开源爱好者分享了多样化算力集群软件生态的前沿进展与实践成果，为推动沙中算力技术生态合作奠定基础，助力中国开源技术走出去，建立国际影响力。</p><p><img width="723" height="391" referrerpolicy="no-referrer" src="/img/bVdm1FA" alt="" title=""/></p><p>openFuyao Committer张帆在演讲中介绍了社区核心定位、技术进展及生态合作伙伴的落地实践成果，引发了在场沙中企业与开发者的广泛关注与热烈讨论。随着智能化浪潮席卷全球，算力市场需求持续攀升，多模态AI负载和多样化算力形态对集群软件提出更高要求，openFuyao致力于打造多样化算力互联的集群管理与调度能力，提供算力亲和组件及面向生产的社区发行版，解决技术生态碎片化、生产方式割裂等行业挑战，实现集群算力的弹性调度和高效释放。社区目前已汇聚近30家成员单位，形成了覆盖互联网、金融、运营商等多领域的技术共建生态。此次分享，为峰会带来了中国开源社区在算力产业的实践经验与前瞻探索。</p><p><img width="723" height="391" referrerpolicy="no-referrer" src="/img/bVdm1FC" alt="" title="" loading="lazy"/></p><p>峰会期间，openFuyao设立展台，系统解析了分布式AI推理框架、大规模集群调度、在离线混部调度、 NUMA亲和调度等社区七大核心集群能力，开箱即用的轻量级容器平台、一站式AI推理一体机方案两大场景化参考实现，以及超节点灵衢使能等最新技术成果，展台现场吸引了大量沙特开发者、企业代表与学术研究人员驻足交流，双方技术专家就多样化算力集群的软件生态构建、性能优化及企业应用等方面进行了深入探讨。</p><p><img width="723" height="391" referrerpolicy="no-referrer" src="/img/bVdm1FB" alt="" title="" loading="lazy"/></p><p>通过本次峰会，openFuyao进一步建立国际开源舞台的影响力。同时，社区官网英文版已正式上线，作为融入全球开源生态的重要举措，将有效打破协作壁垒，汇聚全球多元开发者力量。社区将继续秉持开放、协作、创新的理念，与沙特及全球产学研领域开发者携手，共同推动关键技术的发展，为构建繁荣的全球多样化算力生态贡献力量。</p><p><img width="723" height="549" referrerpolicy="no-referrer" src="/img/bVdm1FD" alt="image.png" title="image.png" loading="lazy"/><br/>官网www.openfuyao.cn点击右上角语言按钮，切换中/英文版本</p>]]></description></item><item>    <title><![CDATA[企业级智能问数四问：从“语义鸿沟”到“统]]></title>    <link>https://segmentfault.com/a/1190000047394638</link>    <guid>https://segmentfault.com/a/1190000047394638</guid>    <pubDate>2025-11-13 12:04:53</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数据分析领域，大模型的落地实践正掀起一场变革风暴。“智能问数”被描绘为数据民主化的终极形态——业务人员无需依赖开发或分析师，仅凭自然语言即可获得精准、可行动的数据洞察。这一愿景极具诱惑力，也催生了大量技术投入。然而，在无数企业轰轰烈烈的实践中，这条通往数据民主化的道路却布满荆棘。本文将通过四个核心问题的探讨，剖析企业级智能问数的真正内涵、核心挑战、技术基石与成功实践，揭示为何“语义编织”（Semantic Fabric）是唯一可行的技术路径。</p><p>企业级智能问数的核心能力和终极目标是什么？</p><p>许多团队将智能问数简化为“NL2SQL”的技术挑战。但企业真正需要的，远不止于此。其核心目标是解决长期存在的“数据语义鸿沟”。</p><p>什么是“数据语义鸿沟”？</p><p>在理想模型中，业务语言与数据语言应该是一一对应的。但现实中，业务人员口中的“GMV”、“新客”、“环比增长”，在数据仓库中可能对应着数十种不同的表、字段和计算逻辑。这条鸿沟体现在三个层面：</p><p>● 语义割裂：同一个业务术语，在不同部门、不同系统中有不同的定义。销售部的“GMV”可能包含所有已支付订单，而财务部的“GMV”则必须剔除退款和内部测试订单。用户增长团队定义的“新客”是“注册后 7 天内完成首单”，而 CRM 系统可能定义为“90 天内无历史交易记录”。没有统一的定义，任何查询结果都无法跨部门达成共识。<br/>● 上下文缺失：业务问题天然富含上下文。一句“上个月华东区新客 GMV 环比增长多少？”，背后隐藏着大量需要明确的细节：“上个月”是自然月还是财月？“华东区”是否包含安徽？“新客”采用哪个定义？“环比”是和哪个周期对比？这些上下文无法仅靠大模型从问题文本中推测，必须依赖企业内部公认的业务规则。<br/>● 可信度与合规性要求：企业决策容不得“大概”和“可能”。数据结果必须可信、可追溯、可审计。一个无法说明数据来源、计算逻辑和权限依据的答案，即使正确，也无法用于正式决策流程，更无法满足合规审计要求。</p><p>因此，企业级智能问数的核心能力，是成为一个能够将模糊的、富含上下文的业务意图，精准、一致、安全地映射到复杂异构的数据资产上的智能系统。它的目标是重建企业的数据认知体系，实现：</p><p>● 认知标准化：让全组织对“什么是 GMV ”等核心指标达成唯一、可执行的统一理解。<br/>● 操作自动化：将共识的业务规则固化为可被系统自动解析和执行的代码，减少人工干预和解读。<br/>● 治理内生化：将数据安全、权限管控、血缘追溯等治理能力，无缝嵌入到每一次数据查询的流程中。</p><p>简而言之，企业级智能问数的终极目标是让整个组织学会用同一种数据语言说话和思考，让数据从 IT 部门的资产，转变为全公司的公共语言。</p><p>实现企业级智能问数，需要什么样的技术方案？</p><p>通过自然语言实现数据查询和分析，一个看似直接的解决方案是：让拥有强大自然语言理解能力的大模型直接连接数据库，根据用户问题实时生成并执行 SQL。这种模式在技术演示中效果惊艳，但在真实的企业生产环境中，它是一条充满陷阱、难以走通的路。</p><p>大模型直连数据库的三大缺陷：</p><p>● 缺乏对企业私有语义的理解： 大模型是通用知识的概率模型，其训练数据来源于公开语料。它无法知晓企业内部特有的、未曾公开的业务规则。例如，某公司定义的“有效订单”是“支付成功且物流状态为已揽收”，这一关键逻辑不存在于大模型的训练集中，模型只能基于“有效”一词的通用语义进行猜测，极易产生错误。<br/>● 无法保证结果的一致性： 大模型的生成具有随机性。同一个问题在不同时间、甚至稍作改写，都可能生成逻辑不同的 SQL。例如，一次查询可能包含了退款，另一次则没有。这种“数据打架”的现象会严重摧毁组织对数据系统的信任，导致“哪个数字才是对的”的无休止争论。<br/>● 安全与性能风险不可控：1. 安全风险： 模型无法感知细粒度的数据权限。它可能生成一个返回所有用户隐私信息的 SQL，无意中导致数据泄露。2. 性能风险： 模型可能生成未优化、包含全表扫描的复杂 SQL，轻易拖垮整个数据库，引发生产事故。3. 逻辑风险： 在涉及多表关联的复杂查询中，模型可能错误地理解表间关系，导致错误的 JOIN 逻辑，输出误导性结论。</p><p>这些缺陷的根源在于：它将本应严格定义的业务逻辑，寄托于一个概率性的黑箱，这在企业级场景中是高风险且不负责任的技术投机。</p><p>语义编织：从“概率猜测”到“确定执行”的范式转变</p><p>实践证明，简单的“数据库+大模型”（NL2SQL）路径在企业级场景下会迅速失效。成功的方案必须引入一个核心中间层——语义编织（Semantic Fabric），由它充当“业务语言”与“数据语言”之间的翻译官和总调度。</p><p>● 大模型负责“意图理解”： 发挥其自然语言优势，将用户的提问解析为一个结构化的“查询意图”。例如，将“上个月华东新客 GMV”解析为：（指标: GMV, 维度: 区域=华东, 时间: 上月, 过滤: 用户类型=新客）。这是一个标准的、机器可读的表示。<br/>● 语义编织层负责“语义执行”： 这个结构化的意图被送入一个独立的语义引擎。该引擎的核心是一个统一、动态、可计算的语义层——即“语义编织”的成果。它明确定义了所有指标、维度、计算规则与权限策略。引擎将意图编译成最优、安全、合规的执行计划。</p><p>语义编织从根本上解决了“直连”模式的缺陷：</p><p>● 可控性： 业务逻辑被显式地定义和管理在语义层中，不再是模型内部的隐藏参数。管理员可以像管理代码一样管理业务规则。<br/>● 一致性： 任何查询，只要指向同一个语义定义，无论由谁发起、如何表述，都将得到唯一的结果，彻底杜绝“数据打架”。<br/>● 可演进性： 当业务规则变更时，只需在语义层更新一处定义，所有相关查询将自动生效，无需重训或调整大模型。<br/>● 可治理性： 权限、血缘、审计等治理能力在语义定义阶段即可内嵌，从源头保障安全与合规。</p><p>语义编织具体包含哪些关键技术要求？</p><p>“语义编织”一词听起来抽象，但其技术实现是高度工程化和系统化的。它可以被拆解为三个相互依存、协同工作的核心支柱，共同构成企业数据认知体系的坚实骨架。</p><ol><li>统一的、可计算的语义层： 这是语义编织的“大脑”。它不是一个简单的数据字典，而是一个动态的、可组合的语义知识库。它必须能统一定义企业的指标、维度、计算口径，并支持基于原子指标的动态派生，以应对千变万化的分析场景。它确保了“GMV”等指标在任何场景下计算逻辑都唯一，杜绝数据打架。</li><li>自动化的数据工程能力： 这是语义编织的“肌肉”。面对 TB/PB 级数据，必须有一套自动化、智能化的数据操作与加速体系。它能根据查询意图，自动进行智能路由、任务编排和预计算加速，确保海量数据下的查询性能与稳定性，真正做到“问得出、答得快”。</li><li>深度治理与安全基因： 这是语义编织的“免疫系统”。安全与控制必须内嵌在产品基因中，实现动态的、细粒度的行/列级权限控制，确保不同角色的人只能看到自己被授权的数据。同时，全链路的操作日志与血缘关系，为数据访问提供了完整的审计追踪，满足合规要求。</li></ol><p>谁在真正践行语义编织？Aloudata 的实践与成果</p><p>“语义层”概念在数据分析领域已存在多年，但能够将语义编织理念完整落地并实现工程化突破的厂商并不多见。传统 BI 工具的语义层大多是为可视化报表服务的，是静态和局部的，无法支撑起动态、任意组合的自然语言查询。而许多新兴的 AI 创业公司又过于聚焦大模型本身，忽视了底层数据工程的复杂性与必要性。在这一背景下，Aloudata 及其核心产品 Aloudata Agent 的实践，为我们提供了一个语义编织理念成功落地的范本。</p><ol><li>语义就绪：NoETL 明细级语义层<br/>Aloudata Agent  基于 Aloudata 自研的 NoETL 明细级语义层，将复杂异构的数据资产抽象为业务可理解的语义元素。与传统依赖预聚合的方案不同，这种基于原始明细数据的语义保留了最完整的数据粒度，避免了信息损耗。这意味着：</li></ol><p>● 数据完整性：基于全量明细数据的语义定义，确保分析结果真实反映业务实际；<br/>● 分析灵活性：支持任意维度组合、任意时间粒度的自由探索，突破传统预建模的分析边界；<br/>● 强大派生能力：通过“少定义、动态派生/衍生”的模式，仅需定义核心原子/复合指标，即可自动派生/衍生出海量指标，满足无限的分析场景需求。</p><ol start="2"><li>操作就绪：实现自动化数据工程能力<br/>Aloudata Agent 具备强大的自动化数据工程能力，构建了自适应的三级智能加速体系（“明细加速-&gt;汇总加速-&gt;结果加速”），能够基于查询特征智能选择最优执行路径：</li></ol><p>● 智能路由：根据查询复杂度、数据规模等因素，自动选择最合适的计算引擎；<br/>● 智能加速：自动构建高效物化视图并自动编排 ETL 任务，查询请求自动命中改写；<br/>● 资源优化：在保证 PB 级数据秒级响应的同时，最大化资源利用效率，提升整体 ROI。</p><ol start="3"><li>治理就绪：实现深度治理与安全基因<br/>Aloudata Agent 将数据治理深度嵌入语义编织的每个环节：</li></ol><p>● 定义即治理：确保每个语义实体都具有“全局唯一性”，所有指标和维度都具有清晰的口径；<br/>● 细粒度权限管控：通过指标使用权限和行列级数据权限实现安全、严密的权限控制；<br/>● 白盒化可信：所有分析过程透明可解释，数据口径、计算逻辑清晰可见</p><ol start="4"><li>决策就绪：“问答-洞察-行动”闭环<br/>企业级智能问数的终极目标不是回答问题，而是支撑决策。Aloudata Agent 提供端到端的分析能力，构建了从数据到决策的价值闭环：</li></ol><p>● 场景化助手：支持创建面向特定业务场景的个性化助手，基于场景特定数据范围，沉淀专属分析经验，让大模型更“懂”用户；<br/>● 灵活问数：基于一个基础指标，可以问维度筛选、趋势、占比、极值、均值，支持各种复杂逻辑的动态派生，让一线业务人员的每个数据查询需求都能被快速响应；<br/>● 归因分析：内置智能归因模型，自动识别关键影响因素（维度归因和因子归因），不仅呈现数据结果，更帮助业务人员快速定位问题根因；<br/>● 智能报告：基于查询结果进行数据解读，自动生成综合分析报告，并支持客户沉淀专家级分析经验，定制专属报告，给出业务行动指引。</p><p>从产品设计的角度，Aloudata Agent 的分析过程全部“白盒化”，呈现清晰明确的数据口径和计算逻辑，让数据结果可信有保障，分析过程可理解、可调整、可干预。这种基于可信数据，从“问答”到“洞察”再到“行动建议”的闭环，才是企业级智能问数的真正价值所在。</p><p>结语：语义编织驱动下的数据决策范式</p><p>企业级智能问数的探索之路，清晰地指向了一个结论：单纯依赖大模型的语言能力无法解决企业数据的根本性挑战。真正的突破口在于构建一个以语义编织为核心的新型数据基础设施。这套体系不仅实现了业务语言与数据语言的无缝对接，更在数据可信度、查询性能和系统安全等多个维度建立了坚实保障。</p><p>语义编织的价值不仅体现在技术层面，更体现在组织协作方式的革新。它将原本分散在各处的业务规则、数据定义和权限策略进行了系统性的整合与标准化，为企业构建了一套统一的"数据认知体系"。这套体系让不同部门的员工能够在同一个语义基础上进行数据对话，从根本上消除了因指标定义不一、口径不同而造成的数据争议。</p><p>在实践层面，Aloudata Agent 的探索已经证明，这条路径不仅是可行的，更是构建未来企业数据基础设施的必然选择。随着大模型能力的持续进化和语义编织的日益成熟，智能问数将从当前的技术探索阶段，逐步发展成为企业数据消费的标准方式。那些能够率先构建起完善数据认知体系的企业，将在数据驱动的竞争中占据显著优势。</p>]]></description></item><item>    <title><![CDATA[Doris 管理太复杂？这个工具帮你一站]]></title>    <link>https://segmentfault.com/a/1190000047394644</link>    <guid>https://segmentfault.com/a/1190000047394644</guid>    <pubDate>2025-11-13 12:04:18</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在大数据与实时分析的需求下，<strong>Apache Doris</strong> 凭借其高性能 <strong>MPP</strong> 架构、列式存储和兼容 <strong>MySQL</strong> 协议的特性，广泛应用于实时数仓、报表分析和日志查询等场景。  </p><p>为了让团队更方便地统一管理数据库，<a href="https://link.segmentfault.com/?enc=W%2BNTJfy0qoguf%2BnaqREs%2Fg%3D%3D.DHK5XnRezOo%2BL9OmlQjevxGYPzn6k8H%2F49oauPW5NEE%3D" rel="nofollow" target="_blank">CloudDM</a> 在最新版本中正式支持了 <strong>Doris</strong>。现在可以直接在 CloudDM 里管理 Doris 数据库，和其他数据库一起协作使用，从查询、变更到发布都能一站式完成。</p><h2>CloudDM 介绍</h2><p>CloudDM 是一款专注团队协作的数据库管理工具，能同时满足开发人员、DBA 等不同人员的需求。针对 Doris 的特性，CloudDM 做了一系列专项适配。  <br/>● 可视化管理  <br/>可以直接在 CloudDM 中连接 Doris 数据库，可视化新建、查看和管理表、视图等对象。CloudDM 还支持管理 <strong>Doris 的外部 Catalog</strong>，用户可以在同一界面中浏览 Doris 连接的外部库表结构，进一步提升跨源管理体验。  <br/>● Doris 语法适配  <br/>CloudDM 针对 Doris 的语法规则进行了专门适配，能够正确识别和处理 Doris 特有的 SQL 语句，避免常见兼容性问题，让日常变更和管理更顺畅。  <br/>● 安全与合规  <br/>团队在使用 Doris 进行分析时也能兼顾安全要求。根据业务需求，可以给开发、DBA 等不同角色授予不同权限，防止越权访问。同时，支持值级、行级的数据脱敏，有效保障数据安全。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394646" alt="截屏2025-09-23 10.35.42.png" title="截屏2025-09-23 10.35.42.png"/></p><h2>核心功能解析</h2><h3>可视化操作</h3><p>CloudDM 提供可视化管理界面，能轻松管理表、视图、函数等数据库对象。建表、删表或清空数据都可以一键搞定，无需编写复杂 SQL 命令。<br/>此外，CloudDM 还支持 Doris 外部 Catalog 的展示与管理功能。用户可以直接查看 Doris 已注册的外部 Catalog 列表，无需额外命令或切换环境就可以在 CloudDM 中统一浏览、执行查询或进行结构管理。</p><p><img width="723" height="440" referrerpolicy="no-referrer" src="/img/bVdm1G7" alt="" title="" loading="lazy"/></p><h3>数据查询</h3><p>CloudDM 为 Doris 提供了完善的数据查询能力，不仅支持查询普通表，还覆盖视图、函数、物化视图及外部表等多种对象类型。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394648" alt="doris 数据查询.gif" title="doris 数据查询.gif" loading="lazy"/></p><h3>权限管控</h3><p>CloudDM 提供基于 RBAC 的精细权限管控，支持到表级别的操作授权。通过明确的角色与权限划分，不仅保障了数据安全，也有效避免了误操作，让团队在管理 Doris 时更加规范、可控。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394649" alt="dm 授权.gif" title="dm 授权.gif" loading="lazy"/></p><h3>数据脱敏</h3><p>支持灵活配置整行或字段级别的脱敏规则。查询结果在返回时动态处理敏感信息，脱敏过程透明，既保护了数据安全，又不影响原始数据的可用性。</p><p><img width="723" height="348" referrerpolicy="no-referrer" src="/img/bVdm1Hf" alt="" title="" loading="lazy"/></p><h3>SQL 规范</h3><p>内置 60+ 条 SQL 检查规则，如禁止空条件查询、创建表时列不允许为空、对象名称拼写规范等。通过统一规范，团队成员编写的 SQL 语句可以保持一致，提高代码质量和协作效率。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394651" alt="4.gif" title="4.gif" loading="lazy"/></p><h3>SQL 审计</h3><p>所有执行过的 SQL 操作都会被完整记录下来。基于账号权限，可以随时查看执行历史，快速定位问题，或在需要时进行合规性审查。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394652" alt="5.gif" title="5.gif" loading="lazy"/></p><h3>CI/CD</h3><p>CloudDM 支持数据库变更与应用发布流程的整合。用户可以在平台内创建发布流，自动检查 SQL 是否符合规范，并通过工单流程审核。平台还可与其他 CI/CD 工具无缝对接，让数据库发布过程更加高效、可控。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394653" alt="7.gif" title="7.gif" loading="lazy"/></p><h2>总结</h2><p>随着 Doris 在实时数仓和高性能分析场景中的广泛应用，如何高效、安全地管理 Doris 集群已成为企业数据团队关注的重点。CloudDM 全面支持对 Doris 的管理，实现了从可视化操作、数据查询、权限管控到监控审计的全流程覆盖，让数据库管理真正“可见、可控”。  </p><p>未来，CloudDM 还将持续拓展对更多数据库和分析引擎的深度支持，帮助企业构建统一、安全、智能的数据管理平台，让每一次数据操作都更高效、更安心。  </p><p>更多内容，欢迎关注公号：CloudDM</p>]]></description></item><item>    <title><![CDATA[基于隐语SecretFlow——Trus]]></title>    <link>https://segmentfault.com/a/1190000047394663</link>    <guid>https://segmentfault.com/a/1190000047394663</guid>    <pubDate>2025-11-13 12:03:18</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>打开链接点亮社区项目群Star，照亮技术的前进之路。每一个点赞，都是社区技术大佬前进的动力</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047313097" alt="" title=""/></p><p>Github 地址： <em><a href="https://link.segmentfault.com/?enc=aGowIcL2qMfVMhrpS2TLBg%3D%3D.q0cQIayDaTLW%2BcwKl00T3ghu%2FfovXjkFPsXgqYdm4cA%3D" rel="nofollow" target="_blank">https://github.com/secretflow</a></em></p><h2>数据要素和三权分置</h2><p>放眼全球，新一轮科技革命和产业变革深入发展，互联网、大数据、云计算、人工智能、区块链等数字技术创新活跃，数据作为关键生产要素的价值日益凸显，深入渗透到经济社会各领域全过程，数字化转型深入推进，传统产业加速向智能化、绿色化、融合化方向转型升级，新产业、新业态、新模式蓬勃发展，推动生产方式、生活方式发生深刻变化，数字经济成为重组全球要素资源、重塑全球经济结构、改变全球竞争格局的关键力量。<br/>数据作为新型生产要素，是数字化、网络化、智能化的基础，已快速融入生产、分配、流通、消费和社会服务管理等各环节，深刻改变着生产方式、生活方式和社会治理方式。</p><ul><li>2019年10月，中央在19届4中全会上首次提出数据是一种生产要素，明确要求“健全劳动、资本、土地、知识、技术、管理、数据等生产要素由市场评价贡献、按贡献决定报酬的机制。</li><li>2020 年 4 月 9 日，中共中央国务院发布《关于构建更加完善的要素市场化配置体制机制的意见》，在传统的要素之外，文件还把数据纳入了生产要素的范围，成为数字化转型带动中国新经济发展的坚实政策基础。</li><li>2022年12月发布的《中共中央 国务院关于构建数据基础制度更好发挥数据要素作用的意见》（后续简称“数据二十条”）从数据产权、流通交易、收益分配、安全治理四方面，提出二十条政策举措。旨在充分发挥我国海量数据规模和丰富应用场景优势，激活数据要素潜能，做强做优做大数字经济，增强经济发展新动能。</li></ul><p>现实中数据采集、利用等环节存在权益保障、隐私保护、安全合规等难题，法律法规是解决数据流通的基础，在此基础上，还需要探索更多的技术手段保障数据流通的安全，促进数据价值的释放。</p><h3>数据要素三权分置</h3><p>“数据二十条”开创性提出了“数据资源持有权、数据加工使用权、数据产品经营权”的三权分置模式。 关于三权分置的数据产权制度细则并未出台，业界对于三权定义尚不清晰，综合考虑“数据二十条”及其他相关文件，我们对数据资源持有权、数据加工使用权、数据产品经营权的三权分置概念解释如下。<br/>定义的参考资料见文末附录。</p><h4>数据资源持有权</h4><p>数据资源持有权相当于弱化或改造的“所有权”，其客体是数据资源，其主体是数据来源者或数据处理者。</p><ul><li>在具体权能上，数据的持有者不仅有权进行数据处理，同时也可以经由其同意来“转让”自己对数据的持有权利（如数据加工使用权、数据产品经营权）。</li><li>在权力来源上，“数据二十条”中指出数据资源持有权可以分为数据来源者持有自己所产生的数据和数据处理者“依法持有”（如通过委托授权）其他主体（数据来源者）的数据。此外，数据资源持有权也存在相应的限制，不得超出或法律规定的权限（如来源合规等）。</li></ul><h4>数据加工使用权</h4><p>数据加工使用权是依法加工处理和使用数据的权力，其客体是数据资源或者数据产品，其主体是数据处理者。</p><ul><li>在具体的权能上，数据加工包括对数据进行清洗、预处理、分析、建模等处理的活动。</li><li>在权力来源上，在满足“依法持有”或“合法取得”数据的前提下，数据处理者即拥有数据加工使用权。依法持有表示数据来源者依法采集、数据持有者依法持有，合法取得表示按照合同约定。</li></ul><h4>数据产品经营权</h4><p>数据产品经营权指对数据处理者开发的数据产品进行经营、交易并获取收益的权益，其客体是数据产品，其主体是数据处理者。<br/>在具体的权能上，数据产品经营权包括收益权和经营权。<br/>在权力来源上，数据产品经营权来源于数据处理者通过大量智力和体力劳动赋予了数据更高的价值。数据产品的形成是以“实质性加工”和“创新性劳动”为前提。</p><h4>三权分置下的数据流转</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394665" alt="" title="" loading="lazy"/></p><h2>数据使用权跨域管控</h2><p>随着数据要素的流转，数据离开持有者的“运维域/管理域”后，如何保障数据使用权依然受到管控是新的挑战。如果数据使用权跨域得不到管控，那么数据流通的安全得不到保障，进一步会阻碍数据的流通。这催生了使用权跨域管控的需求。<br/>所谓的管控，主要是指对数据的管控，包括：</p><ul><li>对原始数据的管控：如何使用。包括但不限于数据注册、加密上传、授权、取消授权、计算、销毁等。</li><li>对结果数据的管控：获取及使用。包括结果的查看、下载、再加工使用等。</li></ul><p>通过合作协议和法律法规对数据使用权进行管控是基本方式。在此基础上，我们希望通过技术提供更可靠更高级的保障，让数据使用权的管控不只是依赖于人治，基于技术的信任，会更加有助于数据要素的流通和三权分置。</p><h2>为什么使用TrustFlow保障使用权跨域管控？</h2><p>如何保障使用权跨域管控是数据要素流通中的挑战，这既需要法规授权作为基础，也需要有效的技术进行保障。通过依法授权获得数据使用权限，通过技术保障数据不被泄露和滥用。<br/>TrustFlow是隐语基于可信执行环境（Trusted Execution Environment，简称TEE）的可信计算系统，具有可信可验证、计算可隔离、授权可管控等机制，强有力的保障了数据要素流通中的使用权跨域管控。</p><h2>TrustFlow使用权跨域管控</h2><p>TrustFlow以TEE作为技术底座，提供了信任可验证、计算可隔离、授权可管控三大核心特性以保障数据要素流通过程中的使用权跨域管控。此外TrustFlow提供了丰富的人工智能和数据分析计算能力，在充分保障数据使用权的同时释放数据要素的价值。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394666" alt="" title="" loading="lazy"/></p><h3>信任可验证</h3><p>通过TEE的远程认证机制，可以对TrustFlow运行环境、运行的代码进行验证，确保TrustFlow运行在正确的可信执行环境中，且代码符合预期没有被篡改。<br/>TrustFlow会尽量以最新安全手段对代码进行加固，TrustFlow代码是开源的，用户亦可以对代码进行安全审计。</p><h3>计算可隔离</h3><p>TrustFlow覆盖了数据使用中（data-in-use）、数据存储（data-at-rest）、数据传输（data-in-transit）端到端全链路的安全保障。TrustFlow保证了数据在流转全链路中一直保存密态，是名副其实的全链路密态计算系统。</p><ol><li><p>数据使用中（data-in-use）加密</p><p>基于TEE的内存加密、内存隔离等安全特性，TrustFlow在数据在使用过程中保证数据一直处于加密状态。</p></li><li><p>数据存储（data-at-rest）加密</p><p>TrustFlow向外部存储（比如硬盘、网络存储等）写入数据前，会对数据进行加密，且密钥仅TrustFlow可访问。</p></li><li><p>数据传输（data-in-transit）加密</p><p>TrustFlow基于TEE的远程认证机制建立安全通道（比如mTLS），确保TrustFlow内部数据传输以及外部数据传输的完整性与机密性。</p></li></ol><h3>授权可管控</h3><p>TrustFlow提供了一套完善的授权管控机制，包含数据确权、使用授权、使用鉴权、结果获取等。在信任可验证的基础上，机构可以对TrustFlow进行验证，从而确保TrustFlow授权管控机制一定是按照预期运行，这也是TrustFlow相比传统管控方案（比如需要依赖相信管控方）的一大优点。</p><h4>数据确权</h4><p>针对数据确权，TrustFlow提供了可信的数据属主和数据标识能力。</p><p>数据属主：TrustFlow中的数据均有数据持有方的签名和完整性保护，确保数据持有方与数据实体的绑定关系可信。</p><p>数据标识：TrustFlow中的数据均有ID标识，并且具有完整性保护，确保数据实体与ID之间的绑定关系可信。</p><h4>使用授权</h4><p>使用授权指的是数据持有方可以对数据进行细粒度的管控，加工使用方只有获得正确授权才能对数据进行指定的计算和加工。<br/>针对使用授权，TrustFlow提供了固定计算逻辑、动态计算逻辑和通用计算限制等管控，TrustFlow提供了一套语法用于描述授权策略，其详细原理可以参考<a href="../architecture/policy.md" target="_blank">授权策略</a>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394667" alt="" title="" loading="lazy"/></p><ol><li><p>固定计算逻辑</p><p>数据持有方可以限制数据仅能执行固定计算逻辑，比如数据仅能被用于统计平均值。</p></li><li><p>动态计算逻辑</p><p>在有些场景下，固化的数据计算逻辑可能不适合。比如在AI场景下，数据可能需要经过清洗、预处理、建模、评估等流程才能发挥数据的价值，算法人员可能需要对数据进行反复试验才能获得较好的模型，这意味需要动态计算逻辑。</p><p>针对此类场景，TrustFlow提供了以下管控能力：</p><ul><li><p>动态计算流管控</p><p>数据持有方可以限制数据只能在有限的算法下进行计算，数据只有在计算逻辑在授权的算法列表中时才能进行计算。</p></li><li><p>列管控</p><p>对于结构化数据，数据持有方可以限制仅能使用数据的部分列，还可以进一步限定数据列可以进行的计算操作操作，比如仅能做聚合计算、仅能求平均值等。对于数据分析场景而言，可以在便利数据使用方分析的同时确保数据不被滥用。</p></li><li><p>行管控</p><p>对于结构化数据，数据持有方可以限制仅能使用数据的部分行，比如限制仅可使用数据的前100条。</p></li><li><p>可扩展管控</p><p>TrustFlow提供了一套可扩展的授权语法，可以按照机构对计算参数做进一步的限制，比如可以限定数据必须经过差分隐私（Differential Privacy）处理且ε必须等于某个值。</p></li></ul></li><li><p>通用计算限制</p><p>除了固定计算逻辑和动态计算逻辑外，TrustFlow还允许数据持有方对数据进行一些通用限制，比如限制数据可被计算次数、设置数据过期时间、指定数据计算参与方等。</p></li></ol><h4>使用鉴权</h4><p>使用鉴权是指实际执行计算时，对授权策略进行校验。TrustFlow在执行计算代码时，会对计算代码（逻辑）、计算参数、计算限制等各项内容根据授权策略进行强制检查，具体原理可以参考<a href="../architecture/principle.md" target="_blank">TrustFlow原理</a>。</p><h4>结果获取</h4><p>获取数据加工的结果需要被管控，这里需要保障两件事，一是结果数据的可信性，即结果数据是按照预期加工方式进行的，二是谁可以获得结果数据。</p><h5>数据溯源</h5><p>TrustFlow提供了数据溯源机制，数据加工使用方可以通过数据溯源确认结果数据是按照预期的计算逻辑产生，确保结果数据没有被仿冒或者篡改。TrustFlow的数据血缘机制可以参考<a href="../architecture/data_lineage.md" target="_blank">数据血缘</a>。</p><h5>授权获取</h5><p>TrustFlow提供了结果数据的授权审批机制，任何参与方想要获取结果数据必须得到全体数据持有方的同意，详细原理可以参见<a href="../quick_start/step5.ipynb" target="_blank">获取结果</a>。</p><h2>附录</h2><h3>数据要素三权分置的定义</h3><p>数据要素三权分置的定义主要参考自《数据二十条》。</p><blockquote>以下摘自《数据二十条》</blockquote><p>数据来源者：促成产生数据的主体，如个人、企业/机构<br/>数据来源者定义参考：“数据二十条”原文：</p><blockquote><p>（七）建立健全数据要素各参与方合法权益保护制度。充分保护数据来源者合法权益，推动基于知情同意或存在法定事由的数据流通使用模式，保障数据来源者享有获取或复制转移由其促成产生数据的权益。合理保护数据处理者对依法依规持有的数据进行自主管控的权益。在保护公共利益、数据安全、数据来源者合法权益的前提下，承认和保护依照法律规定或合同约定获取的数据加工使用权，尊重数据采集、加工等数据处理者的劳动和其他要素贡献，充分保障数据处理者使用数据和获得收益的权利。保护经加工、分析等形成数据或数据衍生产品的经营权，依法依规规范数据处理者许可他人使用数据或数据衍生产品的权利，促进数据要素流通复用。建立健全基于法律规定或合同约定流转数据相关财产性权益的机制。在数据处理者发生合并、分立、解散、被宣告破产时，推动相关权利和义务依法依规同步转移。</p><p>以下摘自《数据二十条》</p></blockquote><p>数据处理者：对原始数据进行开发利用、依规行使数据应用相关权利的主体。包括数据持有者、数据加工者、数据使用者等<br/>数据处理者定义参考：“数据二十条”原文：</p><blockquote><p>（三）在保障安全前提下，推动数据处理者依法依规对原始数据进行开发利用，支持数据处理者依法依规行使数据应用相关权利，促进数据使用价值复用与充分利用，促进数据使用权交换和市场化流通。审慎对待原始数据的流转交易行为<br/>（七）合理保护数据处理者对依法依规持有的数据进行自主管控的权益。在保护公共利益、数据安全、数据来源者合法权益的前提下，承认和保护依照法律规定或合同约定获取的数据加工使用权，尊重数据采集、加工等数据处理者的劳动和其他要素贡献，充分保障数据处理者使用数据和获得收益的权利。</p><p>以下摘自《数据二十条》</p></blockquote><p>数据产品：经加工、分析等形成数据或数据衍生产品，包括但不限于数据包、模型、API接口等<br/>数据产品定义参考：“数据二十条”原文：</p><blockquote>（四）鼓励公共数据在保护个人隐私和确保公共安全的前提下，按照“原始数据不出域、数据可用不可见”的要求，以模型、核验等产品和服务等形式向社会提供，对不承载个人信息和不影响公共安全的公共数据，推动按用途加大供给使用范围。<br/>（七）保护经加工、分析等形成数据或数据衍生产品的经营权，依法依规规范数据处理者许可他人使用数据或数据衍生产品的权利</blockquote><p>其他：</p><blockquote>《上海市数据条例》第四十九条规定，鼓励深度挖掘数据价值，通过实质性加工和创新性劳动形成数据产品和服务。<br/>《上海市公共数据开放实施细则》第二十条规定，支持数据利用主体对开放数据进行实质性加工和创造性劳动后形成的数据产品依法进入流通交易市场。</blockquote>]]></description></item><item>    <title><![CDATA[助力企业构建 AI 原生应用，函数计算 ]]></title>    <link>https://segmentfault.com/a/1190000047394686</link>    <guid>https://segmentfault.com/a/1190000047394686</guid>    <pubDate>2025-11-13 12:02:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>作者：刘宇</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394688" alt="image" title="image"/></p><p><em>本文整理自 2025 云栖大会，</em> <em>阿里云智能集团产品专家，刘宇演讲议题《函数计算发布 FunctionAl:serverless Al 原生应用基础设施》</em></p><p>在 AI 技术应用落地进程中，目前面临着五大核心挑战：开发/学习门槛过高，部署运维阶段复杂，AI 应用安全备受挑战，生态能力方面存在严重的割裂与锁定现象，同时资源成本高昂且利用率低下。这些挑战极大地阻碍了 AI 技术的广泛普及以及应用效率的有效提升。</p><p>阿里云函数计算（FC）依托 Serverless AI 基础设施与全栈能力的创新突破，推出 Function AI（函数智能），精准攻克上述痛点问题，全面推动 AI 应用在开发至运维的全流程中实现降本增效。以下将从四个关键维度，详细阐述阿里云函数计算（FC）的核心解决方案。</p><h2>函数计算 FC：Serverless 形态的 AI 基础设施</h2><p>阿里云函数计算（FC）全新推出 <strong>Serverless AI 基础设施</strong>，以“高可用、低成本、零/低运维”为核心，为企业提供从模型部署到 Agent 开发的全栈解决方案。该平台通过 Serverless 架构的弹性特性与智能化资源管理，显著降低 AI 应用的开发复杂度与资源成本，助力企业快速实现 AI 落地。</p><p><strong>1. 开发效率提升：</strong> 无需关注底层资源，开发者可专注于业务逻辑，模型一键转换为 Serverless API。</p><p><strong>2. 弹性资源调度：</strong> 按需付费 + N 分之一卡资源分配（如 1/16 卡），GPU 部署成本降低 90% 以上。</p><p><strong>3. 免运维特性：</strong> 实例闲置时自动缩容至 0，资源利用率优化 60%，实现业务运维转型。 </p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394689" alt="image" title="image" loading="lazy"/></p><h2>核心能力发布：AgentRun 与模型服务、文生图服务</h2><p>阿里云函数计算全新发布 FunctionAI，基于 Serverless 架构的企业级 AI 应用基础设施平台，实现从模型托管到 Agent 开发的全流程覆盖，显著降低技术门槛并提升跨平台适配性。</p><h3>AgentRun 全流程解决方案</h3><p>Agent Run <strong>[</strong> <strong>1]</strong> 通过高代码与低代码结合，提升 AI 开发效率，支持主流开发生态。在部署阶段，提供轻量、灵活、安全隔离的 AI 运行时，支持多种模型和工具运行时，确保应用安全与扩展性。运维方面，Agent Run 具备全链路监控能力，免资源运维，实现业务运维转型。八大组件共同构建，助力开发者轻松构建企业级 AI 应用。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394690" alt="image" title="image" loading="lazy"/></p><p><strong>1. 全生命周期能力</strong></p><ul><li>开发阶段：高代码 + 低代码模式，兼容阿里云百炼、CloudFlow、Dify 等生态，开发者可自由选择框架；</li><li>部署阶段：轻量、灵活、安全隔离的运行时，支持大模型/垂类模型调用，提供安全沙箱隔离机制与 MCP/Function Call 协议双保障；</li><li>运维阶段：全链路监控 + 端到端可观测性，定位问题并提供优化建议，实现免资源运维。</li></ul><p><strong>2. 技术架构优势</strong></p><ul><li>百万级并发：基于 Session 亲和与多语言引擎，提供企业级沙箱服务能力；</li><li>毫秒级弹性：内存快照技术实现 CPU 毫秒启动、GPU 秒级响应；</li><li>成本降低 60%：支持 GPU/CPU/内存解耦配置（最小 0.25 CPU），实例闲置时自动缩容至 0，按需付费。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394691" alt="image" title="image" loading="lazy"/></p><h4>大语言模型代理机制</h4><p><strong>多模型统一接入</strong></p><ul><li>支持 Cloud、GPT、通义千问等 20 家主流大模型，实现开源模型一键部署；</li><li>通过统一规范管理所有模型，解决 First Token 延迟与负载均衡问题。</li></ul><p><strong>动态模型治理</strong></p><ul><li>自动切换机制：当主模型 First Token 时间过长或负载过高时，快速启用备用模型；</li><li>并行处理能力：多模型并行执行，首个返回结果的模型优先作为主模型。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394692" alt="image" title="image" loading="lazy"/></p><h4>工具生态联动</h4><p><strong>1. 统一工具接口</strong></p><ul><li>兼容 MCP/Function Call 协议，适配主流工具与第三方服务，API 集成时间从天级降至分钟级。</li></ul><p><strong>2. 智能工具管理</strong></p><ul><li>Tool Hub 插件市场：海量插件一键部署，快速构建业务场景；</li><li>智能路由优化：通过语义分析前置筛选工具，降低调用时间（从 60 秒降至秒级）与 Token 消耗。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394693" alt="image" title="image" loading="lazy"/></p><h3>模型服务：AI 模型一键转化为 Serverless API</h3><p>阿里云函数计算推出的<strong>模型服务[2]</strong> ，以 Serverless 架构为核心，通过生态兼容性、技术能力与成本优化三位一体，为企业提供从模型部署到服务调用的全链路解决方案。该服务显著降低 AI 应用开发门槛，同时保障高可用性与资源高效利用，助力企业快速构建生产级模型服务。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394694" alt="image" title="image" loading="lazy"/></p><ul><li><p><strong>生态兼容性</strong></p><ul><li>覆盖大语言模型与垂类模型，兼容 ModelScope、HuggingFace 等主流平台；</li><li>支持 vLLM、SGLang、Ollama、Transformer 等技术架构的一键部署。</li></ul></li><li><p><strong>技术能力</strong></p><ul><li>提供 100+ 模型在线体验，200+ 模型一键部署；</li><li>六大框架一键托管，与 Agent 服务无缝集成；</li><li>DevPod 在线环境支持代码调试与镜像自动构建，无需掌握 Dockerfile。</li></ul></li><li><p><strong>成本优化</strong></p><ul><li>Serverless GPU 技术结合按量付费模式，N 分之一卡资源分配（如 1/16 卡）；</li><li>部署成本降低 90% 以上，资源闲置时不计费，支持百万级并发与毫秒级弹性；</li><li>与 ComfyUI、Dify 等生态实现一键联动，消除资源预置顾虑。</li></ul></li></ul><h3>文生图/声音/视频：多模态 AI 创作平台</h3><p><strong>多模态 AI 创作平台[3]</strong> 以“零门槛生成”为核心，通过全链路工具与生态联动，覆盖电商设计、游戏渲染、营销物料、教育培训等全行业场景。平台提供开箱即用的文生图/视频/声音能力，结合高性价比算力与自动化资源管理，显著降低创作门槛与成本。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394695" alt="image" title="image" loading="lazy"/></p><p><strong>1. 文生图与文生视频</strong></p><ul><li>集成 ComfyUI 与 Stable Diffusion 工具，解决本地部署复杂度与显存资源限制；</li><li>支持全场景内容生成，从设计到渲染实现端到端自动化。</li></ul><p><strong>2. Lora 模型训练</strong></p><ul><li>提供 Muse Lora 等专业训练器，覆盖数据标注到模型训练的全流程；</li><li>适配垂类场景需求，快速生成定制化模型。</li></ul><p><strong>3. 企业级 Serverless API 调用</strong></p><ul><li>一键部署 Stable Diffusion、ComfyUI 等模型，自动转换为 Serverless API；</li><li>高性价比 GPU 弹性算力 + 自动扩容，支持同步/异步灵活切换。</li></ul><h2>Agent 最佳全栈实践：Function Q，你的云上助理</h2><p>Function Q 是专业的函数计算智能助手，集成了基于大模型的代码自动生成、智能运维诊断和系统架构设计三大核心能力，显著提升 Serverless 应用的开发效率。整体技术栈基于函数计算 FC、API 网关、RocketMQ、SLS 等阿里云成熟基础服务构建，遵循云原生设计原则，提供企业级的高可用性、安全性和可观测性保障。 </p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394696" alt="image" title="image" loading="lazy"/></p><p><strong>1. 智能开发助手</strong></p><ul><li>意图驱动部署：用户通过自然语言描述需求（如“获取本地天气”），Function Q 自动生成代码并部署至函数计算，提供按量付费的 API 接口；</li><li>示例场景：输入“获取本地 IP”，Function Q 自动查询 API 并生成可调用服务，无需手动编写 Dockerfile 或配置资源。</li></ul><p><strong>2. 运维诊断专家</strong></p><ul><li>问题自动分析：针对资源费用异常、函数运行错误等问题，调用 MCP 工具链定位根源并提供解决方案；</li><li>实时监控支持：支持全链路可观测性，缩短故障排查周期，提升运维效率。</li></ul><p><strong>3. 架构设计顾问</strong></p><ul><li>业务迁移指导：通过业务描述分析，推荐切分方法或整体打包策略，适配函数计算架构需求；</li><li>场景覆盖：解决开发者对 Serverless 架构迁移路径的困惑，实现零门槛上云。</li></ul><h2>拥抱开源，与开源共成长</h2><p>阿里云函数计算将坚定拥抱开源、与开源共成长。AI 并非单纯商业化产品，而是开放共赢的技术生态平台。当下，我们已与 Agentscope、LangChain、dify 等平台开展开源托管及代码集成工作。</p><p>未来，还有两大关键动作：一是开源 AgentRun SDK，助力快速集成上层开源框架；二是推出 model plugin，让所有垂类模型可像插件般，快速接入 dify、N8N、Stable Diffusion\ComfyUI 等现有生态。我们期望借此不仅拥抱开源，更能反哺开源，携手共进。</p><p><strong>相关链接：</strong></p><p>[1] Agent Run</p><p><a href="https://link.segmentfault.com/?enc=X7H66X1gbZJPJTm0ERRvUA%3D%3D.Xa9SN1SlqwU0vR2dSfSPx0F6pCYW06TSFlyVPRdV75EHIxf2tKzu89ZZGpPQuTKI" rel="nofollow" target="_blank">https://fcnext.console.aliyun.com/agent-run</a></p><p>[2] 模型服务</p><p><a href="https://link.segmentfault.com/?enc=f1cCl4THPIfIwYQVfCPVag%3D%3D.dpVUtJFQ3nOm0ndr1ayhxBFO%2BBt%2BK%2FQohlK%2Br6eCQHTaUVTdDvO4v8d1KMUGh2iB" rel="nofollow" target="_blank">https://fcnext.console.aliyun.com/fun-model</a></p><p>[3] 多模态 AI 创作平台</p><p><a href="https://link.segmentfault.com/?enc=1bLw1BaM5r7%2BAmpgZIQXFg%3D%3D.zxWC9ZdChXnDm%2Fi03Uzyp3RoC5k1EcYPpEx305nGgaelByiVh%2Fz1dXLFYdJHYI8ST9HSbo8Nb4RE%2B1GnCPiUMw%3D%3D" rel="nofollow" target="_blank">https://fcnext.console.aliyun.com/fun-art/explore</a></p>]]></description></item><item>    <title><![CDATA[从“采销东哥”到千人千面直播：数字人如何]]></title>    <link>https://segmentfault.com/a/1190000047394707</link>    <guid>https://segmentfault.com/a/1190000047394707</guid>    <pubDate>2025-11-13 12:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>2025年，直播行业正面临前所未有的“内卷”，流量见顶、ROI疲软，越来越多的商家开始寻找新的破局契机。</p><p>就在不少品牌陷入增长乏力的焦虑时，在技术支持下，跑出了逆势增长的新故事：截至目前，数字人给商家带来了超过140亿的GMV增量。（青否数字人源头v：zhibo175）</p><p>所以，曾经动辄数万元、制作周期漫长的数字人，为何突然“飞入寻常百姓家”？</p><p>从“采销东哥”AI数字人的破圈，到超过9000家品牌密集应用，京东数字人直播又能为商家和消费者带来哪些新价值？</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394709" alt="image2.png" title="image2.png"/></p><p>从“高价炫技”到“白菜价普及”（青否数字人源头v：zhibo175）</p><p>过去，数字人之所以被诟病“成本高、效果差”，主要源自技术和硬件的双重制约。</p><p>一方面是硬件昂贵。早年间，打造一个高保真的3D数字人需多机位拍摄、海量训练和建模。2020年黄仁勋（NVIDIA创始人）在大会上展示过的数字人硬件成本就曾一度高达数百万美元……</p><p>其二，过去的数字人常被认为效果僵硬。一旦面对小角度、多片段衔接和长时应用，数字人往往难免出现卡顿、口型不匹配，表情生硬经常造就“翻车现场”。</p><p>得益于软硬件技术、AI领域的快速发展，2024年，青否数字人在“多模态交互式数字人”上实现了重大突破，将单个数字人生产成本大幅度降低，依托全新技术实现了4K高清、口型极度吻合等高逼真度，打破了传统数字人桎梏。</p><p>可以说，这项新技术的落地和应用，实实在在改变了早些年“只是噱头、成本极高”的刻板印象。</p><p>当下，数字人终于不再是“遥不可及的黑科技”，成为了品牌直播间里可以真真切切发挥作用、创造商业价值的“AI打工人”。</p><p>技术突破：从“一眼假”到“以假乱真”</p><p>形象克隆：数字人克隆效果：（青否数字人源头v：zhibo175）</p><p>青否数字人升级V5形象会全方位重塑您对直播数字人的认知！</p><p>一是数字人效果，区别于传统直播数字人持续不间断的讲解模式，数字人形象克隆 5.0 可实现暂停讲解、喝水、进出镜头以及更换服饰等动作。直播效果更为自然流畅，极大提升直播的真实感。</p><p>支持侧脸转身、进出镜头、挡嘴挡脸、多人出镜、产品特写、双人换班、喝水、休息、蹦跳等任意动作！</p><p>从单一场景到全场景覆盖，从机械动作到自然人设，青否全姿态多场景数字人用技术突破重新定义直播细节！</p><p>二是拍摄要求大幅度降低，无需环境安静，无需配备降噪麦克风，依然能够稳定产出高质量的数字人克隆效果，突破2.0在拍摄环节的限制。（青否数字人源头v：zhibo175）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394710" alt="" title="" loading="lazy"/></p><p>青否数字人声音克隆再次更新 — V7 版本正式上线！</p><p>以更贴近真人的声线质感、更契合专业直播场景的表现，重新定义“听觉专业度”！（青否数字人源头v：zhibo175）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394711" alt="" title="" loading="lazy"/></p><p>语音合成：青否数字人口型匹配度达95%，支持复杂场景如持物直播、实景融合。</p><p>当年“周鸿祎曾误以为刘强东AI数字人可能是真人视频”这一花絮看似调侃，却体现了技术逼真的程度对观众心理带来的冲击。</p><p>而数字人要真正跨越“恐怖谷”，除了视觉逼真，还需让消费者在短时间内对其产生信任。</p><p>青否数字人的全新升级，通过多模态自然化行为生成，让数字人在不同角度、镜头切换、互动场景下依旧保持逼真度，配合情感化语音合成，成功跨过“恐怖谷”门槛。</p><p>“AI打工人”成真：数字人直播带来的实用价值</p><p>如果说以往数字人更多还是概念展示或营销噱头，那么如今它正真正在品牌直播间里“挑大梁”。</p><p>据统计，超9000家品牌借力数字人主播，创造了超过140亿的GMV增量，主要得益于以下几大优势：</p><p>首先就是让有需求的商家能用敢用。以往要做一个超写实数字人，少则数万、多则十几万，还需要专业团队辅助。</p><p>如今，青否数字人把制作成本直线拉低，中小商家甚至个人主播都能“拥有自己的数字人”，完成自主带货、商品推荐、解答疑问。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047394712" alt="" title="" loading="lazy"/></p><p>这种“白菜价普及”无疑扩大了数字人的应用边界。（青否数字人源头v：zhibo175）</p><p>其次24小时在线的数字人切实在人力层面做了大量支撑。</p><p>因为直播并不只存在于黄金档，“夜猫子”同样是潜在的消费群体。</p><p>真人主播难以熬夜，而数字人可以7×24小时在岗，对宝妈宝爸等碎片化购物人群十分友好。例如童装品牌巴拉巴拉正是通过“深夜AI接力”收割了夜间订单，使数字人GMV贡献率稳定提升。如今，数字人也正从闲时走向忙时，不仅承接夜晚等闲时的流量转化，更成为不少品牌直播间的“常驻员工”。</p><p>第三是交互与脚本进化，青否数字人宣布接入DeepSeek，支持AI辅助生成直播脚本，话术更加多样甚至富有幽默感。</p><p>目前已有200余家品牌正在使用DeepSeek辅助生成数字人直播脚本，文案参考率高达90%。</p><p>很明显，大模型的融入让数字人不再只是机械播报，也能够根据用户提问灵活回复，提升用户的驻留时长和转化机会。</p><p>数字人的未来想象：从商业到更广阔的社会场景</p><p>当数字人技术从“噱头”变成“常态工具”，其应用前景也不再局限于直播、电商。</p><p>从青否数字人的场景应用推广来看，数字人不仅是商业工具，也逐渐开始延伸到政务、文旅、非遗保护、线下导购、数字资产管理等更广阔领域。</p><p>在政务场合，数字人可以用来做应急播报、政务大厅咨询；</p><p>在文旅和非遗保护中，数字人可以做导游讲解，或将少数民族歌手或传统艺人的形象、唱腔长久留存；</p><p>在金融服务里，数字人可承担部分“柜台”工作，7×24小时解答复杂业务。</p><p>展望未来，当多模态大模型与数字人深度融合，当实时互动、千人千面与场景深耕进一步成熟，数字人将不仅在“降本增效”上抢占先机，还可能开启全新的消费方式、娱乐方式与社会交互形态。</p><p>当数字人不再只是实验室里的炫酷Demo，而能在品牌商家直播、政务、文旅、金融等多个场景落地、创造价值时，它才真正跨越了“恐怖谷”和商业鸿沟。</p><p>或许再过几年，我们会发现，数字人直播不再是“特殊场景”，而是与真人同台、甚至千人千面、场景无限延伸的标配形态。</p><p>每一家企业、每一个品牌、甚至每一个普通用户，都能拥有自己的人性化“AI分身”，去完成更多样化、更智慧化的交互和创造。</p><p>在跨越“恐怖谷”后，数字人对产业和社会的改变，才刚刚开始（青否数字人源头v：zhibo175）。</p>]]></description></item><item>    <title><![CDATA[最好的组件库教程又回来了，升级为 hea]]></title>    <link>https://segmentfault.com/a/1190000047394350</link>    <guid>https://segmentfault.com/a/1190000047394350</guid>    <pubDate>2025-11-13 11:02:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>前言</h2><p>好久没写文章了。最近有朋友问我，为什么之前的 <a href="https://link.segmentfault.com/?enc=UuFNdeFMHi9hIvqhYiSQKw%3D%3D.cEefeXf8RiPSK3Fw0QExx9NXp%2FkPI5N2QJlxR58cKbJbyvAE6CiKeKzohK5GpHDOE9zd61SUJI2muDZHzRhvvQ%3D%3D" rel="nofollow" target="_blank">mx-design</a> 组件库教程停更了？其实是因为我逐渐意识到，那种样式内嵌的组件库，无论在学习还是实际使用中，都有很大的局限性。</p><p>做过稍微复杂定制需求的前端同学，应该都有类似的体会：</p><ul><li>企业通常有自己独特的 UI 规范，而传统组件库的样式改造起来非常麻烦，有些深层样式几乎无法覆盖。比如 <code>disabled</code> 状态和 <code>readOnly</code> 状态对应的样式，往往与组件内部的 JavaScript 逻辑紧密耦合，难以彻底抽离。</li><li>有时我们甚至需要调整 DOM 结构或修改底层 JavaScript 行为，这在传统组件库中几乎不可能实现。</li></ul><p>面对这些问题，国外出现了一个备受瞩目的前端组件库项目——<code>shadcn/ui</code>，目前也是 GitHub 上最热门的 UI 组件库之一。</p><p>不过，shadcn/ui 并不完全适合国内的项目场景。简单来说，它是一款 Headless 组件库。你可以将 Headless 理解为不提供具体样式的组件，它只包含最核心的 JavaScript 逻辑与基础的 DOM 结构（甚至这部分也允许你自定义）。正因如此，用户获得了高度的定制自由与可拓展性。</p><p>但缺点也有，，<code>shadcn/ui</code> 的功能相比 <code>ant design</code>、<code>arco-design</code> 等国内传统组件库来说，实在弱了不少。我们一个组件可能需要支持 50 个逻辑参数，而 <code>shadcn/ui</code> 可能只提供 10 个。剩下的复杂度，就全部交还给了开发者。</p><p>对于大多数前端开发者来说，要在此基础上进行深度扩展，难度不小。这与国外许多项目交互复杂度不高的情况，是完全不同的。</p><p>所以我一直在想，如果国内 <code>ant-design</code> 这样级别的项目改造为 <code>headless</code> 组件库，那该多好啊。所以这就是我的新项目 <code>t-ui</code> 的来历了。</p><p>造轮子并不是初心，而是有两点非常具有现实意义的目的：</p><ul><li>一方面如果你说有什么项目能覆盖几乎日常前端遇到的所有技术，那莫非组件库项目了，在技术提升的帮助上，毋庸置疑，难度和广度都足够。</li><li>另一方面，我想帮助很多面试者，因为我也当过很多年面试官，发现很多简历都大差不差，没啥亮点，我希望帮助这部分人拥有一个亮点项目，在面试中给面试官深刻的印象，从而获得职业晋升和待遇升级。</li></ul><p>所以我并不是简简单单造轮子，更多的，这是一个组件库教程！而且大家都知道，之前的 <code>mx-design</code> 属于参考了很多主流的组件库，开源的代码，质量好不好大家都看在眼里。我一直是拿其当做最好的组件库教程的目标去做的，目前看来，也是如此。</p><h2>带着酷炫的动画回来了！</h2><p>以下是官网首页动画</p><p><img width="723" height="372" referrerpolicy="no-referrer" src="/img/bVdm1A0" alt="首页1.gif" title="首页1.gif"/><br/><img width="723" height="346" referrerpolicy="no-referrer" src="/img/bVdm1A1" alt="首页2.gif" title="首页2.gif" loading="lazy"/><br/>这是 <code>github</code> 项目地址，欢迎点赞哦: <a href="https://link.segmentfault.com/?enc=P9J1tPc2qdQ1fBcdXcoF8Q%3D%3D.VU%2BGM%2BM3lQKFxcEUsjSuIPN1TWAWVDRstO5FTTd47A%2BdSWKvAnZbr3RPfbsYlt1g" rel="nofollow" target="_blank">t-ui</a></p><p>也欢迎交流动画技术，后续会写一些动画方面的教程，关于 <code>motion</code> 和 <code>gsap</code>.</p><h2>项目内容页主要栏目</h2><p>我们拿 <code>button</code> 组件教程为例，如下图：</p><p><img width="723" height="384" referrerpolicy="no-referrer" src="/img/bVdm1A9" alt="button.webp" title="button.webp" loading="lazy"/></p><p>每个组件分为三个栏目</p><ul><li>必读指南：告诉一些相关组件技术难点的知识</li><li>如何自定义 xx 组件，分别会用 <code>css</code> 和 <code>tailwindcss</code> 在 <code>headless</code> 也就是无样式组件的基础上，再次封装一个有样式，也就是组件库内容既有 <code>headless</code> 也有如何将 <code>headless</code> 组件包装为传统组件库的教程。</li><li><p>完整案例，然后会有组件使用案例，其中比较好玩的是创意案例，在 <code>button</code> 组件的创意案例中，增加了一些点击状态，例如</p><ul><li>点击有水波纹效果</li><li>点击粒子迸发效果</li><li>点击出现笑脸的效果，如下（这个借助了一元三次方程的公式，有兴趣的可以去看源码）：</li></ul></li></ul><p><img width="723" height="234" referrerpolicy="no-referrer" src="/img/bVdm1A2" alt="笑脸.gif" title="笑脸.gif" loading="lazy"/></p><h2>组件库最近计划</h2><p>会将原本接近 30 个在 <code>mx-design</code> 中存在的组件逐步迁移到 <code>t-ui</code> 中，算是第一期完成。也欢迎同学咨询和交流前端技术。（微信：a2298613245）</p><h2>现在的前端技术社区</h2><p>现在前端技术社区，高质量的技术文章相比以前大大减少了，而且很多卖课的内容，质量很低，在我的前端技术交流群里，也有很多同学抱怨过（好几个朋友买过一些培训机构的教程，其中也有不少粗制滥造的内容，但是价格极其贵）。所以现在的前端技术社区，完全变了，可能跟这个行业本身，经济大环境息息相关。</p><p>所以这里强烈建议大家好好把英语拾起来，国外是有很多高质量的教程的，我本身也在坚持提高英语的听说能力，对这个深有体会。后续也会把一些国外的教程放到交流群里和网站上大家一起学习，建立一个高质量的技术分享的社区！</p>]]></description></item><item>    <title><![CDATA[“运动安排规划”思维导图创作实践解析 图]]></title>    <link>https://segmentfault.com/a/1190000047394366</link>    <guid>https://segmentfault.com/a/1190000047394366</guid>    <pubDate>2025-11-13 11:01:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="731" referrerpolicy="no-referrer" src="/img/bVdm1Bf" alt="" title=""/></p><p>                “运动安排规划”思维导图</p><p><a href="https://link.segmentfault.com/?enc=jdIcFoWNN6wfSsThvtCp0g%3D%3D.jhxXZtkAYEAvYAl2YveT7x%2FiGqCC7Db2AF090YUb5UDn2RoqQN7NIwy4ciVO3P9T2CSGar%2Fe4jkbH52dLltKbyu6xOcAQYVxTsOHXPRa5Sc%3D" rel="nofollow" target="_blank">“运动安排规划”思维导图模板获取链接</a></p><h2>一、核心主题确定</h2><p>此思维导图的核心主题是“运动安排规划”。旨在细化年度运动目标、分类运动项目以及规划单次训练内容，帮助用户系统地实现减脂和提升心肺功能的目标，使每一次锻炼都更具针对性和实效性。</p><h2>二、导图结构设计</h2><p>整体结构通过图形天下思维导图的<strong>树型矩阵</strong>布局，清晰展示各阶段目标及其关联，便于用户直观理解和跟踪进度。</p><h3>年度目标</h3><ul><li>设定明确的减脂和心肺功能提升目标，包括目标周期、每月减脂目标及监测方式。</li><li>提升心肺功能的具体指标和测试方式。</li></ul><h3>项目分类</h3><ul><li>将运动项目分为有氧运动和力量训练。</li><li>对每个项目进行详细规划，包括训练频率、强度安排、场地选择以及动作要点。</li></ul><h3>单次训练</h3><ul><li>规划具体的单次训练内容。</li><li>对每个训练动作进行细化，包括组数、次数、时间等。</li></ul><h2>三、导图样式设计</h2><ul><li><strong>颜色搭配</strong>：运用图形天下思维导图提供的<strong>17套主题配色</strong>，使用不同颜色区分不同部分，如年度目标用橙色，项目分类用粉色，单次训练用蓝色，以提高可读性。</li><li><strong>层次结构</strong>：利用<strong>分支折叠</strong>功能，在展示某些分支时，可以初始隐藏详细规划内容，用户点击相应分支即可展开查看，保持界面简洁同时提供深度信息。</li></ul><p><a href="https://link.segmentfault.com/?enc=ROBfnfWq6Mk%2FmzCCg08yLA%3D%3D.B9fQjaG0fin99ZDoikZEV%2Fkz8qIWZo5tWMsDH7KHJ2gbs5rHVyayKDeRuNdoMCnSBQ7N98bM4u8HRNomDTHeOCHQD9T2C0ijKww1mh%2B6V7D%2BkalbpMxSHnifkZawc9w6" rel="nofollow" target="_blank">“运动安排规划”思维导图模板在线免费体验链接</a></p><h2>四、导图工具与流程</h2><ul><li><strong>工具选择</strong>：使用图形天下思维导图（Amind）软件进行创作，该软件的<strong>12种结构化布局图形</strong>和<strong>主题与分支样式设置</strong>功能，能够满足复杂导图结构的设计需求。</li><li><p><strong>创作流程</strong></p><ul><li><strong>初步构思</strong>：确定核心主题和主要分支，明确导图的整体框架。</li><li><strong>信息收集</strong>：整理年度目标、项目分类和单次训练的具体内容，确保信息的完整性和准确性。</li><li><strong>结构设计</strong>：利用<strong>树型矩阵</strong>布局，创建主要分支，并逐步添加细节，同时应用<strong>分支折叠</strong>功能优化导图的可读性。</li><li><strong>样式调整</strong>：使用<strong>样式设置</strong>对导图进行整体优化，调整字体、颜色、布局等，提升导图的美观度和可读性。</li><li><strong>最终审查</strong>：仔细检查逻辑连贯性和信息准确性，进行必要的修改和完善，确保导图质量。</li></ul></li></ul><p><a href="https://link.segmentfault.com/?enc=wTYNjGoLAdFnT7BNRlYG%2Bg%3D%3D.7K9fV1Hmp0BDuOPUfkzKMQRejIEQHUxDnfyV%2FNtuuIa7yI7mtI3lFNxU2N%2F5OBs3vg5pKfJbyw%2BVtdP055Ht6A%3D%3D" rel="nofollow" target="_blank">图形天下思维导图（Amind）软件免费下载链接</a></p><h2>五、总结</h2><p>通过图形天下思维导图（Amind）软件的<strong>树型矩阵</strong>布局，结合丰富的<strong>样式设置</strong>功能，该运动安排规划思维导图清晰地展示了年度运动目标、项目分类及单次训练内容。不仅有助于用户直观理解运动规划，还能有效提升其实施运动目标的效率和效果。</p><p>访问图形天下思维导图（Amind）<strong>模板库</strong>与<strong>教程资源</strong>，获取更多免费导图素材与实操指南，激发你的无限创意。</p><ul><li><a href="https://link.segmentfault.com/?enc=0iBqgtWr5ObIM7mkcqB9og%3D%3D.F1e0ekBLOJXwv9f%2Fy2pmBtNiPLuc4ND%2F5Gmhq73q%2BDZ56vQhscI%2BhANm7FbbmYfYNb6GARmT6G%2BpMSE9TFYyNA%3D%3D" rel="nofollow" target="_blank">Amind思维导图模板库</a></li><li><a href="https://link.segmentfault.com/?enc=7ILfbA5jouy9jzaN21Q1yw%3D%3D.bOKUHmadxHRyTVU8HfioSCcYbrWdc6%2B4INoGLX6SOFs6HniG17%2F5NE9oVxtGXU1j3XuqTeZQ%2F%2BpQldBl3jG6Kw%3D%3D" rel="nofollow" target="_blank">思维导图使用教程资源</a></li></ul>]]></description></item><item>    <title><![CDATA[AI推理硬件选型指南：CPU 与 GPU]]></title>    <link>https://segmentfault.com/a/1190000047394493</link>    <guid>https://segmentfault.com/a/1190000047394493</guid>    <pubDate>2025-11-13 11:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>AI基础设施的建设不应追逐硬件潮流，而在于为任务选择最合适的工具。</p><p>Akamai全球分布式边缘网络能独特地为实时应用提供可扩展、高性价比的AI推理服务。通过对CPU的战略性使用，Akamai进一步降低了多种推理工作负载的成本与能耗，且无需牺牲性能。</p><p>如您所在的企业正在考虑构建和部署 AI 赋能应用程序，或您正在寻找合适的 AI 推理运行环境<br/><a href="https://link.segmentfault.com/?enc=sgixMNquYN6%2FftvP1WoqAA%3D%3D.u9%2BVHOXHNiomzc60tmPTCkX%2FC1UMzUfpqzCSmGifdQUMVKJGiThcjnU6%2Fgj78GE0%2BhHQlu%2F7eIGlO0FVmHgaMovvyDxKcg2N0gVY3XVbpDvsl5MJHKcnh6qM%2BD19ksYIuxm8%2BerjJ%2BhlsQmg2DZv%2BuSfGe6ZqOdgI8nQOkeWWsEmvo2JsKNhh%2FBraUHCf1BJRX%2FIdDiCznWo8Z7Y5iKDmpiox3ScLaEk%2FdAVGq%2B1P%2BPAv0gHz9yiOmGpZ%2BlNKqJZazLwFgzVwCYHUOUOH6P4lQ%3D%3D" rel="nofollow" target="_blank">点击链接</a>了解 Akamai AI 推理云解决方案，现在申请试用可得高达 500 美元专属额度</p><h4>决策边界：CPU 还是 GPU？</h4><p>下表将助您根据模型架构、延迟需求与部署环境，做出正确的基础设施选择。<br/><img width="723" height="226" referrerpolicy="no-referrer" src="/img/bVdm1C0" alt="" title=""/></p><h4>在 Akamai Cloud 上部署 AI 推理的 9 个步骤</h4><p>以下将引导您如何使用基础设施即代码(IaC)<a href="https://link.segmentfault.com/?enc=2DUSgCzHZ1SnwmdYFpGspg%3D%3D.FNbYlVxLXdWwFs0P%2Bj62QSVYQHzZd0HWj%2B%2FmgUvxSE%2FSuNCTGnQkifXiDYWlQ4w6XjbrZT%2B3hy5DvAibTtt3b78jbM543UXwO2%2F2WmuC0cw4M5SeiIXDUwVBHRBuWdm%2BmF6LhRcb91zGG%2FIR1NCQsJzrv%2F7q%2BCMiXfPTBsnw1SF9XyrFJ5tPcnGodt9adl%2BUaZVZTkNkmT2696fnKPo%2F5OmAVWYr7OnOKkSDp58MEHYIXNXDXwUIpFCQ%2FBkhn1V9" rel="nofollow" target="_blank">在Akamai Cloud上快速部署AI应用</a>。利用Terraform，您能以最小手动成本，在边缘快速创建可扩展、可移植的环境。<br/>开始前，请仔细阅读每一步骤，确保理解流程以高效完成设置。<br/>1.准备环境<br/>2.克隆或分叉项目仓库<br/>3.妥善保存密钥信息<br/>4.按需配置（可选）<br/>5.初始化并应用配置<br/>6.设置自定义域名（可选）<br/>7.访问应用<br/>8.成本估算<br/>9.清理资源<br/><strong>1. 准备环境</strong><br/>若已完成以下步骤，可跳过。但请确保在配置基础设施前所有前置条件均已满足。</p><ul><li>安装Terraform : HashiCorp ，使用Terrform在 Linode 上配置基础设施</li><li>生成API令牌：Akamai 个人访问令牌管理指南</li><li>注册SSH密钥：SSH 密钥生成指南</li></ul><p><strong>2.克隆或fork项目仓库</strong></p><ul><li>进入您想要存放项目的文件夹，例如：cd ~/Projects</li><li>运行 git clone <a href="https://link.segmentfault.com/?enc=Ji5xMRJkWgjsQgdpwFXWTw%3D%3D.J0YI2xqOMR5XmkAWjXODrwXJWmugmYBP8H2o3LZZ6DrbbbEmHAvqcjIT9wQBelMrutjzQVQoS5wfj04V0gWn5g%3D%3D" rel="nofollow" target="_blank">https://github.com/jgdynamite10/moviemind-public.git</a></li><li>进入项目目录：cd moviemind-public<br/>注意：若您计划对代码进行修改，应首先 Fork 此代码库：</li><li>访问您正在使用的 GitHub 代码库页面。</li><li>点击页面右上角 Watch 和 Star 选项卡之间的 Fork 按钮。</li><li>随后即可创建属于您自己的 jgdynamite10/moviemind-public.git 代码库副本。</li></ul><p><strong>3.妥善保存密钥信息</strong><br/>遵循开发安全最佳实践，保护敏感数据。<br/>注意：切勿将密码、密钥和令牌存入GitHub，请将 .env、secrets.tfvars 等文件加入 .gitignore。</p><p><strong>4. 按需配置（可选）</strong><br/>编辑 variables.tf 中的可定制变量，使基础设施符合应用需求：</p><ul><li>Label: 为实例命名以便追踪</li><li>Region: 选择靠近用户或数据源的位置</li><li>Instance_type: 根据工作负载匹配计算资源（见表2）</li></ul><p><img width="723" height="233" referrerpolicy="no-referrer" src="/img/bVdm1C6" alt="" title="" loading="lazy"/><br/>注意：请在基础设施配置完成后再设置域名变量，以确保所需信息可用。</p><p><strong>5. 初始化并应用配置</strong><br/>运行 terraform plan 预览Terraform将创建、修改或销毁的资源，此操作不会实际应用配置，是验证变量与配置是否正确的好方法。</p><p>设置变量后，初始化Terraform工作区并应用配置以部署基础设施：<br/>terraform init<br/>terraform apply -var-file="secrets.tfvars"<br/>Terraform会在创建资源前请求确认。此过程大约需要5至10分钟。完成后，将输出实例的公网IP及其他有用信息。</p><p><strong>6. 设置自定义域名（可选）</strong><br/>若需使用品牌域名，请遵循Akamai配置自定义域名指南并启用HTTPS加密。<br/>提示：若部署到计算实例，请创建一条A记录指向实例的公网IP。为加速DNS解析，建议将TTL降至300秒。<br/><strong>7. 访问应用</strong><br/>部署完成后，Terraform会输出实例的公网IP。</p><ul><li>等待约1分钟，待服务完全初始化。</li><li>在浏览器中访问：https://&lt;您的实例IP&gt;:8080<br/>若访问遇到问题，请参考下一节的故障排除提示。</li></ul><p><strong>8. 成本估算</strong><br/><a href="https://link.segmentfault.com/?enc=WJlzUVyUCyoSiKQMad0sUg%3D%3D.1VqJZApP%2BPqXREg8Mnrb1IPulDyDYKR2%2BTq1bGk8%2BuSiIBwcLbuMrRyCwpjryqudzqNr8HtiPIYXgvBMq6pHT4F4YX0td6gPISh01Ym0xb1kHex6Kc56wGySOeROe7r1BU%2Fj3ooi%2F714etpms%2FmPcczqqbS12MjhLAT%2Fcz4ywyM9%2FS%2Bjfu%2BJ6i8rXEkaRu76btlnaunTTK0enCAzxgHICbij2MQDQPcRftvG0SpWOVGf7RYAqqW1nP%2BFOH%2FJhlVgHw1vTCtlzPY2kJh8Zr%2Bu2g%3D%3D" rel="nofollow" target="_blank">使用Akamai云服务成本计算器</a>来配置和估算基础设施成本，并可对比Akamai与AWS、GCP和Azure的定价，了解潜在节省。</p><p><strong>9. 清理资源</strong><br/>若不再需要该基础设施，请运行：terraform destroy，并同时清理：</p><ul><li>DNS记录（如果使用了自定义域名）</li><li>本地的密钥或临时文件</li></ul><h4>故障排除提示</h4><p><strong>配置问题：</strong></p><ul><li>运行 terraform validate 检查语法错误或缺失变量。</li><li>确保API令牌有效且账户配额充足。</li></ul><p><strong>服务器创建卡住或离线</strong><br/>若过程卡顿超过3分钟或无进展，或服务器看似创建但持续离线，最佳选择是删除此服务器并重新运行 terraform apply -var-file="secrets.tfvars"。</p><p><strong>Terraform 无法建立 SSH 连接</strong><br/>确保SSH代理正在运行且已添加SSH密钥。</p><p><strong>进程在任何阶段卡住</strong><br/>若部署过程卡顿超过3分钟且无进展，请按 Ctrl+C 中断，然后重新运行 terraform apply -var-file="secrets.tfvars"，通常可解决问题。</p><p><strong>应用无法加载</strong></p><ul><li>确认使用的IP地址和端口正确。</li><li>使用 dig 或 nslookup 验证域名解析是否正确。</li><li>若SSL证书配置失败（常见原因），请重新运行 terraform apply 命令。</li><li>检查防火墙规则与端口开放状态。</li><li>在Akamai Linode控制台确认SSH密钥与实例状态。</li><li>使用 curl 或 Postman 测试API端点。<br/>若以上步骤未能解决问题，请查看Akamai服务日志或<a href="https://link.segmentfault.com/?enc=1i6O0mzm85l2wJo5p06ceQ%3D%3D.8yi2IpKzV1ryYUvw%2BUSLZi%2BbqPjON2GPJcV7IU7Yrc%2BnpNd3hSGHA%2FN3PayfgTBHjhVduYeueFDKlGn1BLyGwBIuY8FVC9etHSApOXL6Xs0%2FXzZharuBBxtH6PVGEfBXeltg9gATEGUAUyarjvWKUv6Vqm6p0PkGMuvW7vvsDxKp6QbZGCDq2trODRlZttcw1zFa3t%2F6%2FOV5dkKo%2FsfiEKGVg9o9yT6GezsFrrW7mlMd4NP8x8nMHNP5Y3QmN5gZ" rel="nofollow" target="_blank">联系Akamai技术支持团队</a>获取进一步协助。</li></ul><p>恭喜！</p><p>您已成功在Akamai边缘平台上使用CPU部署了AI推理服务。此设置支持多种实时应用，并可扩展自定义域名、HTTPS及可扩展基础设施。</p><h4>匹配硬件与用例，避免浪费时间和金钱</h4><p>评估AI推理硬件时，不应只关注算力，更需思考CPU和GPU如何与您的机器学习任务及数据集相匹配。多核CPU能高效处理序列任务、控制功能及数据处理；而GPU则为深度神经网络、大语言模型及其他高性能计算工作负载提供强大的并行处理能力。</p><p>CUDA或Tensor等框架利用GPU加速器来提升模型训练速度、减少瓶颈，尤其适用于重度依赖矩阵乘法与高吞吐量的算法。同时，CPU对于多数推理任务仍是高性价比之选，兼具能效与跨计算系统的可移植性。<br/>无论您的AI项目涉及聊天机器人、生成式AI还是数据科学的大型数据集，理解CPU与GPU（以及Intel、AMD和NVIDIA的各类产品）的核心差异，都将助您精准匹配硬件与用例，避免浪费训练时间与基础设施成本。</p><p><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdmXxx" alt="" title="" loading="lazy"/></p><p>如您所在的企业正在考虑构建和部署 AI 赋能应用程序，或您正在寻找合适的 AI 推理运行环境<br/><a href="https://link.segmentfault.com/?enc=x%2FiIePk9D6P27wMedvkPJw%3D%3D.yZcapE5zZGDJXBtGt4nBooXNDfc5WwIc23UBBMt3RPF4VYMU%2Byx88zNci%2FDWQ%2BYvC6W6q1EeCTzvgUxG55Rmc0kkz6hkGg2HHg2i6nTlSELz4pt0SS9NKWdWzFO61nBhpPGCr2Ie6e1awVVeMBSrdbBNfu99RbCiX0OVAfyJTbBUJjoUagKALtVVy26LWmapLKCS%2BYf0HHMy33JzMIjsf68zdD%2Fu3vIRejrTjNnW%2FM8jc2gJtknmuSzo050tWdx7CsKFhbnIwjN8tcFIfKXg%2Bw%3D%3D" rel="nofollow" target="_blank">点击链接</a>了解 Akamai AI 推理云解决方案，现在申请试用可得高达 500 美元专属额度</p>]]></description></item>  </channel></rss>