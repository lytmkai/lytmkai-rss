<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[vs2022无法正常使用copilot的解决方案 Python成长路 ]]></title>    <link>https://segmentfault.com/a/1190000047536988</link>    <guid>https://segmentfault.com/a/1190000047536988</guid>    <pubDate>2026-01-12 11:10:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>问题描述</h2><p>不知道从什么时候开始，在visual studio2022中用copilot一直显示<code>完成你的请求时出现了问题。请重试</code>。</p><p><img width="370" height="284" referrerpolicy="no-referrer" src="/img/bVdnCGV" alt="" title=""/></p><p>点开<code>显示输出日志</code>发现可能是网络原因，但是我在浏览器打开显示的是404，那就是可以正常连接。</p><p><img width="723" height="461" referrerpolicy="no-referrer" src="/img/bVdnCGW" alt="" title="" loading="lazy"/></p><p>试过很多AI得到的回答无非以下几种：</p><ul><li>设置了代理</li><li>防火墙</li><li>网络原因</li></ul><p>但是经过排查防火墙我早就关闭了，代理我也没有设置过全局，都是使用的浏览器插件。而网络原因更不太可能了，因为我在vscode中是能正常使用copilot的。</p><h4>解决方案</h4><p>今天想再试试AI，我又把上面那一大串的错误复制发给了GPT5.2，然后他给出一系列的测试命令(因为使用的vscode里的copilot，所以只需要一直点允许它就能执行命令并获取执行结果了)。</p><p><code>$ErrorActionPreference='Continue'; Write-Host '=== Env Proxy Vars ==='; gci env: | ? { $_.Name -match 'PROXY|COPILOT' } | sort Name | ft -AutoSize; Write-Host '=== WinHTTP Proxy ==='; netsh winhttp show proxy; Write-Host '=== DNS ==='; Resolve-DnsName api.githubcopilot.com | select -First 5 | ft -AutoSize; Write-Host '=== TCP 443 ==='; Test-NetConnection api.githubcopilot.com -Port 443 | fl</code></p><p><img width="723" height="606" referrerpolicy="no-referrer" src="/img/bVdnCGX" alt="" title="" loading="lazy"/></p><p>说明是可以正常连接到copilot的域名</p><p><code>$ErrorActionPreference='Continue'; '=== Env Proxy Vars ==='; Get-ChildItem env: | Where-Object { $_.Name -match 'PROXY|COPILOT' } | Sort-Object Name | Format-Table -AutoSize</code></p><p><code>netsh winhttp show proxy</code></p><p><img width="723" height="108" referrerpolicy="no-referrer" src="/img/bVdnCGY" alt="" title="" loading="lazy"/></p><p><code>reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v ProxyEnable ; reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v ProxyServer ; reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" /v AutoConfigURL</code></p><p><img width="723" height="158" referrerpolicy="no-referrer" src="/img/bVdnCGZ" alt="" title="" loading="lazy"/></p><p>代理也没有设置</p><p><code>Resolve-DnsName api.githubcopilot.com | Select-Object -First 5 | Format-Table -AutoSize</code></p><p><code>Test-NetConnection api.githubcopilot.com -Port 443 | Format-List</code></p><p><img width="723" height="475" referrerpolicy="no-referrer" src="/img/bVdnCG0" alt="" title="" loading="lazy"/></p><p>DNS解析也是正常的</p><p><code>curl.exe -I https://api.githubcopilot.com/models</code></p><p><code>curl.exe -vk https://api.githubcopilot.com/models</code></p><p><img width="723" height="207" referrerpolicy="no-referrer" src="/img/bVdnCG1" alt="" title="" loading="lazy"/></p><p>这里出现了一些端倪，curl居然无法访问到模型列表，那很可能还是网络原因了，可能是被墙了，加上代理试试  </p><p><code>curl.exe -x http://127.0.0.1:10809 -vk https://api.githubcopilot.com/models</code></p><p><img width="723" height="563" referrerpolicy="no-referrer" src="/img/bVdnCG2" alt="" title="" loading="lazy"/></p><p>那看来就是域名被墙了，国内网络无法正常访问，那么加上代理应该就可以了。为了让代理不影响到其他应用，我们可以只给命令行设置代理，然后从命令行启动vs，为了方便可以写成bat文件</p><pre><code class="cmd">set HTTP_PROXY=http://127.0.0.1:10809
set HTTPS_PROXY=http://127.0.0.1:10809
set NO_PROXY=localhost,127.0.0.1

set COPILOT_USE_DEFAULTPROXY=1

start "" "C:\Program Files\Microsoft Visual Studio\2022\Community\Common7\IDE\devenv.exe"</code></pre><p><img width="395" height="1005" referrerpolicy="no-referrer" src="/img/bVdnCG3" alt="" title="" loading="lazy"/></p><p>终于能愉快的使用copilot写代码了。之前也试过设置全局代理，原来还需要添加<code>COPILOT_USE_DEFAULTPROXY</code>变量才会生效。</p>]]></description></item><item>    <title><![CDATA[2026年第四周学习——MCP原理 AIAgent研究 ]]></title>    <link>https://segmentfault.com/a/1190000047536997</link>    <guid>https://segmentfault.com/a/1190000047536997</guid>    <pubDate>2026-01-12 11:09:41</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>核心目标</h2><p>熟练理解MCP的原理， 通过写代码实战MCP</p><h2>推荐资源</h2><ol><li>MCP圣经：理论 + 实践吃透 大火的 MCP 协议<br/><a href="https://segmentfault.com/a/1190000047529698" target="_blank">https://segmentfault.com/a/1190000047529698</a></li><li><p>《A Complete Guide to the Model Context Protocol (MCP) in 2025》<br/><a href="https://segmentfault.com/a/1190000047529738" target="_blank">https://segmentfault.com/a/1190000047529738</a></p><h2>实战任务</h2><p>1、MCP原理总结<br/><img width="723" height="533" referrerpolicy="no-referrer" src="/img/bVdnCG5" alt="image.png" title="image.png"/><br/>2、使用MCP搭建自学AI的Agent</p></li></ol>]]></description></item><item>    <title><![CDATA[Dify 实战任务：基于 MCP 协议搭建 AI 学习智能 Agent（自动生成每日学习+实战内容）]]></title>    <link>https://segmentfault.com/a/1190000047537002</link>    <guid>https://segmentfault.com/a/1190000047537002</guid>    <pubDate>2026-01-12 11:08:53</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>任务核心定位</h2><p>聚焦 AI 学习场景（覆盖 Python 基础、LLM 原理、RAG 实战、Dify/n8n 工具使用等方向），基于 Dify + MCP 协议搭建「AI 学习智能 Agent」。该 Agent 能根据用户的<strong>学习阶段（新手/进阶）、目标（如掌握 Dify 实战/搭建 RAG 系统）、每日可投入时长</strong>，自动生成「知识点学习内容 + 可落地实战任务」，并通过 MCP 协议对接外部学习资源（如 GitHub 学习仓库、AI 官方文档、在线代码评测平台），实现“个性化学习计划生成→学习资源调取→实战任务设计→进度追踪”的闭环，解决 AI 学习“无规划、无方向、学完不会用”的痛点。</p><h2>一、任务基础信息</h2><ul><li><strong>适用人群</strong>：AI 学习新手/进阶者、想要系统化学习 LLM/RAG/Dify 的开发者、教育类工具搭建者；</li><li><p><strong>前置条件</strong>：</p><ol><li>已部署 Dify（v1.10.0+ 版本，支持 MCP 协议，Docker/私有化部署均可）；</li><li>开发环境：Python 3.8+（搭建 MCP Server）、Git（对接 GitHub 学习资源）、浏览器（Dify 操作）；</li><li><p>学习资源准备：</p><ul><li>本地/在线 AI 学习知识库（如 Python 基础、RAG 原理、Dify 文档等 Markdown/PDF 资料）；</li><li>可选对接外部工具：GitHub API（调取学习仓库）、LeetCode API（Python 刷题）、Dify 官方文档 API；</li></ul></li><li>工具支持：FastAPI（搭建 MCP Server）、uvicorn（运行 Server）、requests（接口调用）；</li></ol></li><li><strong>任务周期</strong>：2-3 天（按「MCP Server 搭建→Dify 配置→工作流编排→测试优化」推进）；</li><li><p><strong>最终产出</strong>：可直接使用的 AI 学习 Agent，输入指令如“我是 AI 新手，每天 1.5 小时，目标 2 周掌握 Dify 实战，生成今日学习计划”，即可返回：</p><ul><li>当日学习内容（知识点+资源链接）；</li><li>当日实战任务（步骤清晰、可落地的小任务）；</li><li>学习验证方式（如代码运行、效果验收标准）。</li></ul></li></ul><h2>二、核心原理：MCP 协议对接 AI 学习工具链</h2><p>本次 Agent 核心通过 MCP 协议对接 3 类核心工具（由 MCP Server 封装），Dify 作为“大脑”编排流程：</p><pre style="display:none;"><code class="mermaid">graph LR
    A[用户输入] --&gt; B[Dify 工作流]
    B --&gt; C[LLM 节点：解析学习阶段/目标/时长]
    C --&gt; D[Fetch MCP Tools：获取 3 类学习工具]
    D --&gt; E[Call MCP Tool：调用工具生成内容]
    E --&gt; F[内容整合节点：拼接学习+实战内容]
    F --&gt; G[返回给用户]
    
    subgraph MCP Server 封装的工具
    E --&gt; E1[学习资源查询工具：调取知识点资料]
    E --&gt; E2[实战任务生成工具：匹配阶段设计任务]
    E --&gt; E3[进度记录工具：记录每日完成情况]
    end
    
    E1 --&gt; H[GitHub 学习仓库/本地知识库]
    E2 --&gt; I[实战任务模板库]
    E3 --&gt; J[本地 JSON/轻量数据库]</code></pre><ul><li>MCP Server 作用：封装“学习资源查询、实战任务生成、进度记录”3 类工具，提供标准化 MCP 协议接口；</li><li>Dify 工作流作用：解析用户需求→调用 MCP 工具→整合结果→输出个性化学习计划。</li></ul><h2>三、任务详细拆解（Step-by-Step 落地）</h2><h3>阶段 1：搭建 AI 学习专属 MCP Server（1 天）</h3><h4>核心目标：封装 3 类 AI 学习工具，提供 MCP 协议接口供 Dify 调用</h4><h4>具体操作：</h4><ol><li><p><strong>创建 MCP Server 项目&amp;安装依赖</strong></p><ul><li><p>新建文件夹 <code>ai-learning-mcp-server</code>，执行以下命令安装依赖：</p><pre><code class="bash">pip install fastapi uvicorn requests pydantic python-dotenv</code></pre></li><li><p>新建 <code>server.py</code>（核心代码，含 3 类工具封装，可直接复制）：</p><pre><code class="python">from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import requests
import json
from datetime import datetime
import os

# 初始化 FastAPI 应用
app = FastAPI(title="AI 学习 Agent MCP Server")

# ===================== 配置项（可根据自己的学习资源修改） =====================
# 1. 学习资源映射（按阶段/主题分类）
LEARNING_RESOURCES = {
    "新手-Python基础": {
        "知识点": "Python 变量/数据类型/循环/函数/模块导入",
        "资源链接": "https://github.com/walter201230/Python.git",
        "文档": "https://docs.python.org/zh-cn/3/tutorial/index.html"
    },
    "新手-Dify部署": {
        "知识点": "Docker 基本命令、Dify 一键部署、知识库创建",
        "资源链接": "https://github.com/langgenius/dify.git",
        "文档": "https://docs.dify.ai/guides/getting-started/install-docker"
    },
    "进阶-RAG优化": {
        "知识点": "Embedding 模型选型、分片策略、混合检索、Rerank 重排序",
        "资源链接": "https://github.com/explodinggradients/ragas.git",
        "文档": "https://docs.dify.ai/guides/knowledge-base/optimize-retrieval"
    },
    "进阶-MCP协议": {
        "知识点": "MCP 协议原理、MCP Server 搭建、Dify MCP 插件配置",
        "资源链接": "https://github.com/langgenius/dify-docs.git",
        "文档": "https://docs.dify.ai/guides/plugins/mcp-plugin"
    }
}

# 2. 实战任务模板（按阶段/主题匹配）
PRACTICE_TASKS = {
    "新手-Python基础": {
        "任务名称": "Python 基础语法实战",
        "任务描述": "编写一个 Python 脚本，实现：1. 定义函数计算两个数的和；2. 循环输出 1-10 的偶数；3. 导入 math 模块计算圆的面积（半径手动输入）",
        "验收标准": "脚本可运行，无语法错误，输出结果正确"
    },
    "新手-Dify部署": {
        "任务名称": "Dify 本地部署+基础知识库创建",
        "任务描述": "1. 用 Docker 一键部署 Dify；2. 创建名为「AI 学习笔记」的知识库；3. 上传 1 篇 Python 学习笔记（Markdown 格式）；4. 测试 1 个简单问答（如“Python 函数定义规则”）",
        "验收标准": "Dify 服务正常启动，知识库问答准确率≥80%"
    },
    "进阶-RAG优化": {
        "任务名称": "Dify RAG 检索效果优化",
        "任务描述": "1. 基于已有的 Dify 知识库，修改分片参数（Chunk Size=500，Overlap=100）；2. 启用混合检索+gte-rerank-v2 模型；3. 设计 5 条测试用例，验证召回率提升≥10%",
        "验收标准": "检索结果更精准，模糊查询能匹配到相关内容"
    },
    "进阶-MCP协议": {
        "任务名称": "MCP 对接天气 API 实战",
        "任务描述": "1. 搭建简易 MCP Server，封装天气查询工具；2. 在 Dify 中配置 MCP 插件；3. 编排工作流，实现“输入城市名→调用 MCP 工具→返回天气信息”",
        "验收标准": "工作流可正常运行，查询城市天气返回准确结果"
    }
}

# 3. 学习进度存储（本地 JSON 文件，简易版）
PROGRESS_FILE = "learning_progress.json"
if not os.path.exists(PROGRESS_FILE):
    with open(PROGRESS_FILE, "w", encoding="utf-8") as f:
        json.dump({}, f)

# ===================== MCP 协议核心接口 =====================
# 定义工具调用请求模型
class ToolCallRequest(BaseModel):
    tool_name: str
    parameters: dict

# 1. MCP 接口：获取工具列表（Dify 必须调用）
@app.get("/mcp/tools")
async def get_tools():
    return {
        "tools": [
            {
                "name": "get_learning_resource",
                "description": "根据学习阶段和目标查询对应的学习资源（知识点+链接+文档）",
                "parameters": [
                    {"name": "stage", "type": "string", "required": True, "description": "学习阶段：新手/进阶"},
                    {"name": "topic", "type": "string", "required": True, "description": "学习主题：Python基础/Dify部署/RAG优化/MCP协议"}
                ]
            },
            {
                "name": "generate_practice_task",
                "description": "根据学习阶段和主题生成可落地的实战任务",
                "parameters": [
                    {"name": "stage", "type": "string", "required": True, "description": "学习阶段：新手/进阶"},
                    {"name": "topic", "type": "string", "required": True, "description": "学习主题：Python基础/Dify部署/RAG优化/MCP协议"}
                ]
            },
            {
                "name": "record_learning_progress",
                "description": "记录每日学习进度（完成/未完成）",
                "parameters": [
                    {"name": "date", "type": "string", "required": True, "description": "学习日期，格式：YYYY-MM-DD"},
                    {"name": "stage", "type": "string", "required": True, "description": "学习阶段"},
                    {"name": "topic", "type": "string", "required": True, "description": "学习主题"},
                    {"name": "status", "type": "string", "required": True, "description": "进度状态：完成/未完成"}
                ]
            }
        ]
    }

# 2. MCP 接口：调用工具（核心逻辑）
@app.post("/mcp/call")
async def call_tool(request: ToolCallRequest):
    tool_name = request.tool_name
    params = request.parameters

    # 工具1：查询学习资源
    if tool_name == "get_learning_resource":
        key = f"{params['stage']}-{params['topic']}"
        if key not in LEARNING_RESOURCES:
            return {"success": False, "error": f"无匹配的学习资源：{key}"}
        return {"success": True, "result": LEARNING_RESOURCES[key]}

    # 工具2：生成实战任务
    elif tool_name == "generate_practice_task":
        key = f"{params['stage']}-{params['topic']}"
        if key not in PRACTICE_TASKS:
            return {"success": False, "error": f"无匹配的实战任务：{key}"}
        return {"success": True, "result": PRACTICE_TASKS[key]}

    # 工具3：记录学习进度
    elif tool_name == "record_learning_progress":
        try:
            with open(PROGRESS_FILE, "r", encoding="utf-8") as f:
                progress = json.load(f)
            # 存储格式：{日期: {阶段-主题: 状态}}
            if params["date"] not in progress:
                progress[params["date"]] = {}
            progress[params["date"]][f"{params['stage']}-{params['topic']}"] = params["status"]
            with open(PROGRESS_FILE, "w", encoding="utf-8") as f:
                json.dump(progress, f, ensure_ascii=False, indent=2)
            return {"success": True, "result": "学习进度记录成功"}
        except Exception as e:
            return {"success": False, "error": f"记录失败：{str(e)}"}

    # 未知工具
    else:
        raise HTTPException(status_code=404, detail=f"工具 {tool_name} 不存在")

# 启动 MCP Server
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)</code></pre></li></ul></li><li><p><strong>启动并测试 MCP Server</strong></p><ul><li>运行 Server：在项目文件夹执行 <code>python server.py</code>；</li><li>测试工具列表接口：浏览器访问 <code>http://localhost:8001/mcp/tools</code>，能看到 3 个工具列表即启动成功；</li><li><p>测试工具调用（Postman/浏览器）：发送 POST 请求到 <code>http://localhost:8001/mcp/call</code>，请求体示例（查询新手-Dify部署的学习资源）：</p><pre><code class="json">{
  "tool_name": "get_learning_resource",
  "parameters": {"stage": "新手", "topic": "Dify部署"}
}</code></pre></li><li>若返回对应的学习资源信息，说明工具调用正常。</li></ul></li></ol><h3>阶段 2：Dify 配置 MCP 插件与工具（0.5 天）</h3><h4>核心目标：让 Dify 识别 MCP Server 中的 3 类学习工具，实现工具调用</h4><h4>具体操作：</h4><ol><li><p><strong>安装并配置 MCP 插件</strong></p><ul><li>登录 Dify 后台 → 插件市场 → 搜索「MCP SSE 插件」→ 安装；</li><li><p>配置插件参数：</p><ul><li>MCP Server URL：<code>http://你的服务器IP:8001</code>（确保 Dify 能访问该地址，本地部署填 <code>http://localhost:8001</code>）；</li><li>授权方式：选择「无授权」（简易场景）；</li><li>点击「测试连接」，显示「连接成功」即完成配置。</li></ul></li></ul></li><li><p><strong>验证 MCP 工具识别</strong></p><ul><li>进入 Dify 「工作室」→ 创建新应用，命名为「AI 学习智能 Agent」，选择「工作流」类型；</li><li><p>在工作流编辑器中，添加「Fetch MCP Tools」节点：</p><ul><li>插件选择：已安装的 MCP 插件；</li><li>运行该节点，输出结果中能看到 <code>get_learning_resource</code>/<code>generate_practice_task</code>/<code>record_learning_progress</code> 3 个工具，说明识别成功。</li></ul></li></ul></li></ol><h3>阶段 3：编排 AI 学习 Agent 工作流（核心环节，1 天）</h3><h4>核心目标：实现“用户输入→解析需求→调用 MCP 工具→整合学习+实战内容→输出计划”的完整流程</h4><h4>工作流节点配置（按顺序添加）：</h4><pre><code>用户输入 → LLM 节点（解析需求）→ 条件分支 → Call MCP Tool（资源查询）→ Call MCP Tool（实战生成）→ 内容整合 → 输出
                                                                 → 进度记录（可选）→ 输出</code></pre><ol><li><p><strong>节点 1：用户输入（默认节点）</strong></p><ul><li><p>接收用户自然语言输入，示例：</p><ul><li>新手：“我是 AI 新手，每天 1 小时，今天想学习 Dify 部署，生成学习计划和实战任务”；</li><li>进阶：“我是进阶学习者，今天想优化 RAG 检索效果，生成对应的学习内容和实战任务”。</li></ul></li></ul></li><li><p><strong>节点 2：LLM 节点（解析学习需求，关键！）</strong></p><ul><li>模型选择：GPT-3.5 Turbo/DeepSeek-R1（意图识别准确率高）；</li><li><p>Prompt 设计（严格按格式解析参数，可直接复制）：</p><pre><code>你是 AI 学习助手，需解析用户的学习需求，输出以下 JSON 格式的参数（无额外内容）：
{
  "stage": "学习阶段（仅填：新手/进阶）",
  "topic": "学习主题（仅填：Python基础/Dify部署/RAG优化/MCP协议）",
  "duration": "每日学习时长（如1小时/2小时）",
  "date": "今日日期（格式：YYYY-MM-DD）"
}
规则：
1. 必须从用户输入中提取准确的 stage 和 topic，无法识别时 stage 填“新手”，topic 填“Python基础”；
2. duration 如实提取，无则填“1小时”；
3. date 填当前系统日期（YYYY-MM-DD）。
示例：
用户输入：我是 AI 新手，每天 1 小时，今天想学习 Dify 部署 → 输出：
{"stage":"新手","topic":"Dify部署","duration":"1小时","date":"2026-01-12"}</code></pre></li><li>输出格式：选择「JSON」，确保后续节点能解析参数。</li></ul></li><li><p><strong>节点 3：Call MCP Tool（调用学习资源查询工具）</strong></p><ul><li>插件选择：已配置的 MCP 插件；</li><li>工具名称：<code>get_learning_resource</code>；</li><li><p>工具参数：</p><ul><li>stage：<code>{{$node["LLM 节点"].json["stage"]}}</code>（引用 LLM 节点解析的阶段）；</li><li>topic：<code>{{$node["LLM 节点"].json["topic"]}}</code>（引用学习主题）。</li></ul></li></ul></li><li><p><strong>节点 4：Call MCP Tool（调用实战任务生成工具）</strong></p><ul><li>插件选择：已配置的 MCP 插件；</li><li>工具名称：<code>generate_practice_task</code>；</li><li><p>工具参数：</p><ul><li>stage：<code>{{$node["LLM 节点"].json["stage"]}}</code>；</li><li>topic：<code>{{$node["LLM 节点"].json["topic"]}}</code>。</li></ul></li></ul></li><li><p><strong>节点 5：内容整合（编辑字段节点）</strong></p><ul><li><p>作用：将学习资源、实战任务、时长整合为易读的每日学习计划，示例配置：</p><pre><code>【今日 AI 学习计划】
学习阶段：{{$node["LLM 节点"].json["stage"]}}
学习主题：{{$node["LLM 节点"].json["topic"]}}
每日时长：{{$node["LLM 节点"].json["duration"]}}

=== 一、学习内容 ===
核心知识点：{{$node["Call MCP Tool（资源查询）"].json["result"]["知识点"]}}
学习资源：{{$node["Call MCP Tool（资源查询）"].json["result"]["资源链接"]}}
官方文档：{{$node["Call MCP Tool（资源查询）"].json["result"]["文档"]}}

=== 二、实战任务 ===
任务名称：{{$node["Call MCP Tool（实战生成）"].json["result"]["任务名称"]}}
任务描述：{{$node["Call MCP Tool（实战生成）"].json["result"]["任务描述"]}}
验收标准：{{$node["Call MCP Tool（实战生成）"].json["result"]["验收标准"]}}</code></pre></li></ul></li><li><p><strong>节点 6：进度记录（可选，Call MCP Tool）</strong></p><ul><li>工具名称：<code>record_learning_progress</code>；</li><li><p>工具参数：</p><ul><li>date：<code>{{$node["LLM 节点"].json["date"]}}</code>；</li><li>stage：<code>{{$node["LLM 节点"].json["stage"]}}</code>；</li><li>topic：<code>{{$node["LLM 节点"].json["topic"]}}</code>；</li><li>status：<code>未完成</code>（用户完成后可手动修改为“完成”）。</li></ul></li></ul></li><li><p><strong>节点 7：输出节点</strong></p><ul><li>引用「内容整合」节点的输出，将格式化的学习计划返回给用户。</li></ul></li></ol><h3>阶段 4：测试与优化（0.5 天）</h3><h4>核心目标：验证 Agent 生成的学习计划精准、实战任务可落地</h4><h4>具体操作：</h4><ol><li><p><strong>测试用例设计&amp;验证</strong></p><table><thead><tr><th>用户输入</th><th>预期输出</th><th>验证要点</th></tr></thead><tbody><tr><td>“我是 AI 新手，每天 1 小时，今天想学习 Dify 部署”</td><td>新手-Dify部署的学习资源+实战任务，格式清晰</td><td>知识点准确、实战任务可落地、资源链接有效</td></tr><tr><td>“我是进阶学习者，今天想优化 RAG 检索效果”</td><td>进阶-RAG优化的学习资源+实战任务</td><td>RAG 优化知识点完整、实战任务有量化验收标准</td></tr><tr><td>“随便推荐今天的 AI 学习内容”</td><td>默认新手-Python基础的学习计划</td><td>兜底逻辑生效，无报错</td></tr></tbody></table></li><li><p><strong>优化方向</strong></p><ul><li>若 LLM 解析参数错误：在 Prompt 中添加更多示例（few-shot），或降低温度参数（temperature=0.1）；</li><li>若学习资源/实战任务不足：补充 <code>LEARNING_RESOURCES</code> 和 <code>PRACTICE_TASKS</code> 字典（如新增“进阶-n8n 工作流”主题）；</li><li>若格式混乱：优化「内容整合」节点的模板，增加换行/分段。</li></ul></li></ol><h2>四、企业级/个性化扩展建议</h2><ol><li><p><strong>对接更多学习工具</strong>：</p><ul><li>在 MCP Server 中新增工具：对接 LeetCode API（Python 刷题）、AI 教程网站（如 HuggingFace Docs）、Dify 社区案例库；</li><li>新增“学习效果验证”工具：调用在线代码评测平台，自动校验实战任务的代码正确性。</li></ul></li><li><p><strong>个性化适配</strong>：</p><ul><li>增加「学习目标」参数（如“找工作/兴趣学习/企业落地”），生成不同侧重点的学习计划；</li><li>对接用户学习进度，生成“昨日未完成→今日优先学”的联动计划。</li></ul></li><li><p><strong>多端集成</strong>：</p><ul><li>通过 Dify 的「集成」功能，将 Agent 接入飞书/企业微信/钉钉，每日自动推送学习计划；</li><li>增加“进度打卡”功能，用户完成实战任务后可上传截图，Agent 自动标记“完成”。</li></ul></li></ol><h2>五、总结</h2><h3>关键点回顾</h3><ol><li>本次 AI 学习 Agent 核心通过 MCP 协议封装了「学习资源查询、实战任务生成、进度记录」3 类核心工具，实现了学习计划的自动化生成；</li><li>Dify 工作流的核心是「LLM 解析用户需求→调用 MCP 工具→整合内容」，其中 LLM Prompt 的精准解析是关键；</li><li>实战任务设计遵循“可落地、可验证”原则，每个任务都有明确的验收标准，避免“学完不会用”。</li></ol><h3>核心价值</h3><p>这个 Agent 不仅解决了 AI 学习“无规划”的问题，还通过 MCP 协议打通了“学习资源→实战任务→进度追踪”的全链路，新手可快速上手系统化学习，进阶者可针对性突破难点。你可根据自己的学习目标（如新增“大模型微调”“Agent 开发”等主题），补充 MCP Server 中的学习资源和实战任务模板，适配个性化学习需求。</p>]]></description></item><item>    <title><![CDATA[语音打断功能完全指南：AEC 技术原理与模块选型 SmartPi ]]></title>    <link>https://segmentfault.com/a/1190000047537034</link>    <guid>https://segmentfault.com/a/1190000047537034</guid>    <pubDate>2026-01-12 11:08:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>前言</h2><p>在语音交互产品开发中，你是否遇到过这样的场景：设备正在播放语音反馈时，用户发出新的指令，却必须等待当前播报完全结束才能响应？这种体验就像和一个"没礼貌"的对话对象交流——对方说话时你根本无法插话。</p><p>语音打断（Voice Barge-in）功能正是为了解决这个问题而诞生的。它允许用户在设备播报语音的过程中直接喊出新的指令，设备会立即中断当前播报并响应用户的新需求。本文将深入剖析这项技术的实现原理，以及如何在 SmartPi 语音模块生态中正确选型。</p><h2>什么是 AEC 语音打断</h2><h3>核心概念</h3><p><strong>AEC（Acoustic Echo Cancellation，声学回声消除）</strong>是实现语音打断功能的关键技术。它的核心作用是：当设备扬声器正在播放音频时，系统能够区分哪些是设备自身播放的声音（回声），哪些是用户的真实语音输入。</p><pre><code>┌─────────────────────────────────────────────────────────┐
│                    传统语音交互流程                       │
├─────────────────────────────────────────────────────────┤
│  用户说话 → 唤醒识别 → 播放反馈 → 等待结束 → 下次唤醒    │
│                              ↑                           │
│                    用户必须等待此过程完成                 │
└─────────────────────────────────────────────────────────┘
​
┌─────────────────────────────────────────────────────────┐
│                  支持 AEC 打断的交互流程                  │
├─────────────────────────────────────────────────────────┤
│  用户说话 → 唤醒识别 → 播放反馈                           │
│                                  │                       │
│                    用户可直接插话 ← ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
│                                  ↓
│                            立即中断播报
│                                  ↓
│                            响应新指令
└─────────────────────────────────────────────────────────┘</code></pre><h3>技术实现原理</h3><p>AEC 技术通过以下步骤实现语音打断：</p><ol><li><strong>回声参考信号获取</strong>：系统获取即将播放的音频数据作为参考信号</li><li><strong>自适应滤波</strong>：通过自适应算法估计扬声器到麦克风的声学路径</li><li><strong>回声消除</strong>：从麦克风采集的信号中减去估计的回声成分</li><li><strong>语音检测</strong>：在消除回声后的信号上进行语音活动检测（VAD）</li><li><strong>打断触发</strong>：检测到有效语音指令时，立即中断当前播放</li></ol><h2>SmartPi 模块 AEC 支持情况</h2><h3>支持情况速查表</h3><table><thead><tr><th>产品系列</th><th>型号示例</th><th>AEC 语音打断</th><th>备注</th></tr></thead><tbody><tr><td><strong>CI 系列</strong></td><td>CI-03T1 / CI-03T2</td><td>✅ 支持</td><td>推荐，性价比高</td></tr><tr><td><strong>CI 系列</strong></td><td>CI-33T1 / CI-33T2</td><td>✅ 支持</td><td>高端型号，500 条指令</td></tr><tr><td><strong>CI 系列</strong></td><td>CI-73T1 / CI-73T2</td><td>❌ 不支持</td><td>硬件限制</td></tr><tr><td><strong>CI 系列</strong></td><td>CI-95C1 / CI-95C2</td><td>❌ 不支持</td><td>硬件限制</td></tr><tr><td><strong>CI 系列</strong></td><td>CI-96Z61 / CI-96Z62</td><td>✅ 支持</td><td>新一代模块</td></tr><tr><td><strong>SU 系列</strong></td><td>SU-03T</td><td>❌ 不支持</td><td>热门基础款，无 AEC</td></tr><tr><td><strong>SU 系列</strong></td><td>SU-20T / SU-21T</td><td>❌ 不支持</td><td>低功耗系列</td></tr><tr><td><strong>SU 系列</strong></td><td>SU-32T</td><td>✅ 支持</td><td>高性能款，98% 识别率</td></tr><tr><td><strong>SU 系列</strong></td><td>SU-63T</td><td>✅ 支持</td><td>蓝牙音乐模块</td></tr><tr><td><strong>JX 系列</strong></td><td>JX-A7T</td><td>✅ 支持</td><td>离在线双模 AI 模块</td></tr></tbody></table><blockquote><strong>选型建议</strong>：如果产品需要语音打断功能，在预算允许的情况下优先选择 <strong>CI-03T1</strong>（性价比最高）或 <strong>CI-33T1</strong>（功能更强）。SU 系列中推荐 <strong>SU-32T</strong> 或 <strong>SU-63T</strong>。</blockquote><h3>各系列详细对比</h3><h4>CI 系列：AEC 功能的首选</h4><p>CI 系列是 SmartPi 生态中 AEC 功能支持最完善的产品线：</p><ul><li><strong>CI-03T1/03T2</strong>：性价比之选，单麦/双麦可选，支持 AEC 打断</li><li><strong>CI-33T1/33T2</strong>：高端型号，500 条指令，双麦降噪 + AEC</li><li><strong>CI-96Z61/96Z62</strong>：新一代模块，支持 AEC，接口丰富</li></ul><h4>SU 系列：部分型号支持</h4><ul><li><strong>SU-03T</strong>：经典爆款，但<strong>不支持 AEC</strong>，这是很多开发者踩过的坑</li><li><strong>SU-32T</strong>：高性能型号，支持双麦 + AEC，适合嘈杂环境</li><li><strong>SU-63T</strong>：支持 AEC 和蓝牙音乐，适合多功能集成</li></ul><h4>JX 系列：AI 对话的打断支持</h4><ul><li><strong>JX-A7T</strong>：离在线双模模块，支持 AI 对话过程中的语音打断</li></ul><h2>平台配置指南</h2><h3>启用 AEC 功能的步骤</h3><p>在智能公元平台（smartpi.cn）配置 AEC 打断功能：</p><ol><li><p><strong>选择合适的应用场景</strong></p><ul><li>进入固件配置界面</li><li>在"应用场景"或"产品特性"中选择 <strong>"语音识别 + AEC 打断"</strong></li></ul></li><li><p><strong>前端信号处理配置</strong></p><ul><li>麦克风配置：根据硬件选择单 MIC 或双 MIC</li><li>识别距离：根据实际使用场景设置（近场/远场）</li><li>启用 AEC 回声消除功能</li></ul></li><li><p><strong>打断模式选择</strong></p><ul><li>仅唤醒词打断：只有唤醒词可以打断播报</li><li>命令词打断：识别到的命令词也可以打断</li><li>组合模式：灵活配置打断触发条件</li></ul></li></ol><h3>配置注意事项</h3><ol><li><strong>固件版本要求</strong>：确保使用支持 AEC 功能的固件版本</li><li><strong>硬件设计要求</strong>：麦克风和扬声器的相对位置会影响 AEC 效果</li><li><strong>测试验证</strong>：在实际使用环境中测试打断功能的可靠性</li></ol><h2>不支持 AEC 的替代方案</h2><p>如果你的项目使用了不支持 AEC 的模块（如 SU-03T、CI-73T 等），仍有替代方案可以实现类似功能：</p><h3>方案一：串口打断</h3><p>通过外部 MCU 发送串口指令来控制播放停止：</p><pre><code>配置步骤：
1. 在智能公元平台配置串口输入触发
2. 触发方式选择"串口输入"
3. 消息号：自定义（如 0x01）
4. 执行动作：选择"停止播放"</code></pre><p>这种方式需要外部 MCU 的配合，适合已有主控芯片的方案。</p><h3>方案二：优化播报内容</h3><p>既然无法打断，那就让播报更简短：</p><ul><li>使用更简洁的语音表达</li><li>避免冗余的提示语</li><li>将长信息拆分为短播报</li></ul><h3>方案三：更换模块</h3><p>如果语音打断是核心需求，最直接的方案是更换支持 AEC 的模块：</p><pre><code>从 SU-03T 迁移到 CI-03T1：
- 引脚兼容：两者引脚定义相似
- 功能增强：获得 AEC 打断能力
- 成本增加：约 10-20% 的成本差异</code></pre><h2>常见问题解答</h2><h3>Q1：为什么 SU-03T 这么热门却不支持 AEC？</h3><p>SU-03T 采用的是 US516P6 芯片平台，这是一个主打低成本和低功耗的平台。AEC 需要额外的 DSP 算法和硬件资源支持，出于成本和功耗的平衡，SU-03T 没有集成此功能。如果需要 AEC，建议升级到 CI-03T1（采用 CI1302 芯片）。</p><h3>Q2：AEC 功能会增加功耗吗？</h3><p>AEC 算法确实需要额外的计算资源，但现代芯片的 DSP 加速能力已经能够高效处理这些计算。实际功耗增加通常在 5-10mA 范围内，对于大多数应用影响不大。</p><h3>Q3：双麦克风对 AEC 效果有多大提升？</h3><p>双麦克风方案可以提供更好的降噪和波束成形效果，配合 AEC 功能能进一步提升播放状态下的识别率。在嘈杂环境中，双麦方案的优势更加明显。</p><h3>Q4：播放音乐时能识别语音指令吗？</h3><p>AEC 技术主要用于消除设备自身播放的回声，对于音乐等动态音频，效果取决于音乐的类型和音量。建议：</p><ul><li>控制播放音量在合理范围</li><li>对于音乐场景，使用双麦 + AEC 的组合配置</li><li>在实际场景中测试验证效果</li></ul><h2>总结</h2><p>语音打断功能是提升语音交互体验的关键特性之一。在 SmartPi 模块生态中：</p><ul><li><strong>需要 AEC 功能</strong>：优先选择 CI-03T1、CI-33T1、SU-32T、SU-63T 或 JX-A7T</li><li><strong>预算有限</strong>：CI-03T1 是性价比最高的选择</li><li><strong>已经使用 SU-03T</strong>：可通过串口打断实现部分功能，或迁移到 CI-03T1</li><li><strong>AI 对话场景</strong>：JX-A7T 支持对话过程中的语音打断</li></ul><p>在产品设计初期就确定是否需要语音打断功能，可以避免后续方案变更带来的返工成本。建议在选型阶段申请样品进行实际测试，验证 AEC 功能在目标场景下的表现。</p><p><strong>参考资料</strong>：</p><ul><li><a href="https://link.segmentfault.com/?enc=3HA7I0Z2MhHSoFzxwhioVw%3D%3D.aS%2FViREds43FbBBC%2BNsd1jsg7jpqrpflMO0o3hwnm9o%3D" rel="nofollow" target="_blank">SmartPi 支持文档 - 语音调优 FAQ</a></li><li><a href="https://link.segmentfault.com/?enc=ba%2FmmHF07TsL7xhtNNN3XQ%3D%3D.kjLfGt1e4KOm6MGD%2BvTlreFJWClt%2Bzaez%2F2%2BfBaY01U%3D" rel="nofollow" target="_blank">智能公元平台配置指南</a></li></ul>]]></description></item><item>    <title><![CDATA[选择海关电子卡口系统品牌的时候，这几个问题要注意 华明视讯科技 ]]></title>    <link>https://segmentfault.com/a/1190000047537060</link>    <guid>https://segmentfault.com/a/1190000047537060</guid>    <pubDate>2026-01-12 11:07:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在海关电子卡口系统的选型过程中，品牌选择直接关系到通关效率、系统稳定性和长期运维成本。作为在智能交通与通关信息化领域深耕多年的解决方案提供商，华明视讯结合自身经验，总结出以下几个关键注意点，助您做出明智决策：<br/><strong>一、技术兼容性与扩展性</strong><br/>海关卡口系统并非孤立存在，必须与现有的海关监管平台、物流系统及企业ERP无缝衔接。选择品牌时，需重点考察：<br/>-接口标准化程度：是否支持国内外主流数据交换协议？<br/>-模块化设计：能否根据业务增长灵活扩展功能模块？<br/>-未来适应性：是否具备技术升级路径，适应智慧海关发展趋势？<br/><strong>二、系统稳定性与可靠性</strong><br/>卡口系统7×24小时不间断运行，任何故障都可能导致通关延误和经济损失。应重点关注：<br/>-硬件耐久性：设备是否针对高频率使用、恶劣天气等场景进行强化设计？<br/>-冗余备份机制：系统是否有双机热备、自动故障切换等功能？<br/>-实际案例验证：要求供应商提供同类场景的成功运行记录，尤其在高峰流量下的表现数据。<br/><strong>三、本地化支持与服务能力</strong><br/>系统部署只是开始，长期运维才是关键。评估品牌时需考虑：<br/>-服务网络覆盖：供应商在您所在区域是否有常驻技术支持团队？<br/>-响应时间承诺：紧急故障的现场响应时间是否在合同中有明确保证？<br/>-本地化定制能力：能否根据您的特定业务流程进行针对性优化？<br/><img width="723" height="356" referrerpolicy="no-referrer" src="/img/bVdku3P" alt="" title=""/><br/><strong>四、合规性与安全标准</strong><br/>海关系统涉及国家安全和商业秘密，必须符合严格标准：<br/>-资质认证：是否通过中国海关相关认证及国家信息安全等级保护要求？<br/>-数据加密机制：传输和存储环节是否有完善的加密保护？<br/>-操作审计功能：系统是否提供完整的操作日志和审计追踪功能？<br/><strong>五、成本效益分析</strong><br/>不应仅仅比较初次采购价格，而要进行全生命周期成本评估：<br/>-隐形成本：包括升级费用、维护费用、培训成本等<br/>-能耗效率：设备功耗直接影响长期运营成本<br/>-升级成本透明度：未来功能扩展和技术升级的收费是否合理透明<br/><strong>深圳华明视讯科技的建议</strong><br/>我们建议采取“三步评估法”：<br/>1.需求清单明确化：列出核心需求、期望功能和未来扩展方向<br/>2.实地考察验证：参观供应商现有项目现场，与最终用户交流实际体验<br/>3.试点先行：如条件允许，先进行小范围试点，验证系统实际表现<br/>选择海关电子卡口系统品牌是一项长期投资，需要平衡技术先进性、稳定可靠性和服务支持等多方面因素。华明视讯愿与各关区及物流企业分享我们在智能识别与通关信息化领域的经验，共同推动口岸智能化建设。<br/>在智慧海关建设不断深化的今天，选择合适的合作伙伴，不仅关乎当前通关效率，更影响着未来数字化升级的起点高度。</p>]]></description></item><item>    <title><![CDATA[AI 智能体高可靠设计模式：去中心化黑板协作 俞凡 ]]></title>    <link>https://segmentfault.com/a/1190000047537064</link>    <guid>https://segmentfault.com/a/1190000047537064</guid>    <pubDate>2026-01-12 11:06:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><em>本系列介绍增强现代智能体系统可靠性的设计模式，以直观方式逐一介绍每个概念，拆解其目的，然后实现简单可行的版本，演示其如何融入现实世界的智能体系统。本系列一共 14 篇文章，这是第 8 篇。原文：<a href="https://link.segmentfault.com/?enc=q0WC5ZpNNpqHdrQ42AubDw%3D%3D.OOJaUx3UWBiQvbfLarJSTDJ3EPJnZLxvISNUeU3cy%2FnelYXrOKJ3jFiMmo5DtFYiscPpwEEHXVkzypk6P7Hrt89Hj8yeqWCWqqjBz5F1A07mCfm6hHW0FAxvwRyOX%2Fo3" rel="nofollow" target="_blank">Building the 14 Key Pillars of Agentic AI</a></em></blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047508976" alt="" title=""/></p><p>优化智能体解决方案需要软件工程确保组件协调、并行运行并与系统高效交互。例如<a href="https://link.segmentfault.com/?enc=TOG8IRl8GWGoei5VixdTRQ%3D%3D.lDBw3P11MQbd2cBzI3TZlxqEmkfRhohpBjLOxfdaiSEw9cZ5u7njXINXaNyfFwj81V7v66XEoZS2ktEwMs9sHQ%3D%3D" rel="nofollow" target="_blank">预测执行</a>，会尝试处理可预测查询以<strong>降低时延</strong>，或者进行<a href="https://link.segmentfault.com/?enc=VnSk33cT4qjP%2Bc5WwfY3Cw%3D%3D.Mg4QtTqeDYoArX0m1IWTviJKFg%2Facj8I6VX1OIaOpBxPTtDYjfZWBwf%2B%2BalaVcJRtQoJGW7Lo4ewYCFLagiojhUtkQ31KeT22NXcG4LUMNXaqP3OEQnA40CrFEdxdLCYLV9PrgXn6kAjznXqLUXp9EEEnLI5wBPrpR7M7CmUISnuQIhUpl6jYWJD3wOZrDHxskspz0h%2FThL6aKCUD4IIzL8l0YMBhSbX7d2Xjo8E5CY%3D" rel="nofollow" target="_blank">冗余执行</a>，即<strong>对同一智能体重复执行多次</strong>以防单点故障。其他增强现代智能体系统可靠性的模式包括：</p><ul><li><strong>并行工具</strong>：智能体同时执行独立 API 调用以隐藏 I/O 时延。</li><li><strong>层级智能体</strong>：管理者将任务拆分为由执行智能体处理的小步骤。</li><li><strong>竞争性智能体组合</strong>：多个智能体提出答案，系统选出最佳。</li><li><strong>冗余执行</strong>：即两个或多个智能体解决同一任务以检测错误并提高可靠性。</li><li><strong>并行检索和混合检索</strong>：多种检索策略协同运行以提升上下文质量。</li><li><strong>多跳检索</strong>：智能体通过迭代检索步骤收集更深入、更相关的信息。</li></ul><p>还有很多其他模式。</p><p>本系列将实现最常用智能体模式背后的基础概念，以直观方式逐一介绍每个概念，拆解其目的，然后实现简单可行的版本，演示其如何融入现实世界的智能体系统。</p><p>所有理论和代码都在 GitHub 仓库里：<a href="https://link.segmentfault.com/?enc=PaDvZynxXpHpTW3fJDjNXg%3D%3D.ONeCpr2%2BVpIgGPAEVVQRweIqHdecLmxq4muemtIEm9su6%2Fvum05WA9Oe%2FWxNfjSiypz1VQtfvsCsF%2BKQ8AUP8A%3D%3D" rel="nofollow" target="_blank">🤖 Agentic Parallelism: A Practical Guide 🚀</a></p><p>代码库组织如下：</p><pre><code>agentic-parallelism/
    ├── 01_parallel_tool_use.ipynb
    ├── 02_parallel_hypothesis.ipynb
    ...
    ├── 06_competitive_agent_ensembles.ipynb
    ├── 07_agent_assembly_line.ipynb
    ├── 08_decentralized_blackboard.ipynb
    ...
    ├── 13_parallel_context_preprocessing.ipynb
    └── 14_parallel_multi_hop_retrieval.ipynb</code></pre><hr/><h2>去中心化黑板协作</h2><p>至今为止我们构建的自主式架构，如层级架构和装配线，都由严格的、预先设定的工作流定义。</p><p>但对于那些无法预知解决方案路径的问题呢？对于复杂认知理解或分析任务，需要一种更灵活、适应性更强的方法。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537066" alt="去中心化黑板协作" title="去中心化黑板协作" loading="lazy"/></p><p>在这种情况下，可以用 <strong>去中心化黑板协作（Decentralized Blackboard Collaboration）</strong> 模式，该系统由两个主要组件构成：共享数据空间（即“黑板”）以及一组独立、专业的代理，持续监控黑板。</p><ol><li>代理不按固定顺序触发，而是当黑板状态与其专业领域匹配时，会被自行激活。</li><li>代理读取当前状态，通过向黑板写入来贡献知识，然后返回休眠状态。</li><li>从而创造动态的、涌现的工作流，解决方案由每个阶段最相关的专家逐步、逐块的构建而成。</li></ol><p>为了展示这种模式如何有用，我们构建一个客户支持工单处理系统，该系统由三位专家代理协作：分析器、检索器和提案器，展示这种解耦方法如何比单一代理产生的结果更准确、更具上下文丰富性。</p><p>首先定义智能体发布到黑板上的结构化数据对象。</p><pre><code class="python">from langchain_core.pydantic_v1 import BaseModel, Field
from typing import List, Literal, Optional

class ProblemAnalysis(BaseModel):
    """结构化分析用户的问题，由分析器代理发布"""
    product: str = Field(description="The product the user is having an issue with.")
    problem_summary: str = Field(description="A concise, one-sentence summary of the technical problem.")
    user_sentiment: Literal["Positive", "Negative", "Neutral"] = Field(description="The user's sentiment.")

class Solution(BaseModel):
    """检索器代理发布潜在解决方案"""
    relevant_articles: List[str] = Field(description="A list of knowledge base articles relevant to the problem.")

class DraftResponse(BaseModel):
    """由提案器代理发布最终回复"""
    response_text: str = Field(description="The complete, user-facing response drafted by the agent.")</code></pre><p>这些 Pydantic 模型是黑板系统的正式“协作语言”。当分析器代理运行时，必须发布 <code>ProblemAnalysis</code> 对象，从而确保当解决方案检索器激活时，可以可靠的找到 <code>problem_summary</code> 对象来协作。</p><p>接下来定义 <code>BlackboardState</code> 本身，包含初始工单以及代理随时间贡献的所有结构化数据。</p><pre><code class="python">from typing import TypedDict, Annotated

class BlackboardState(TypedDict):
    ticket: str
    # 'analysis', 'solution', 'draft' 是代理在黑板上发布输出的插槽
    analysis: Optional[ProblemAnalysis]
    solution: Optional[Solution]
    draft: Optional[DraftResponse]
    performance_log: Annotated[List[str], operator.add]</code></pre><p>每个可选字段（<code>analysis</code>，<code>solution</code>，<code>draft</code>）代表拼图的一部分，随着代理填充这些字段，工作流逐步构建起解决问题所需的完整画面。</p><p>现在定义专家代理节点，每个都是读取和写入黑板的专业代理，第一个是 <code>analyzer_node</code>。</p><pre><code class="python">from langchain_core.prompts import ChatPromptTemplate
import time

# 代理 1: 问题分析器
analyzer_prompt = ChatPromptTemplate.from_messages([
    ("system", "You are a Problem Analyzer. Your job is to read a customer support ticket, identify the product, summarize the problem, and gauge the user's sentiment."),
    ("human", "Please analyze the following ticket:\n\n---\n{ticket}\n---")
])

analyzer_chain = analyzer_prompt | llm.with_structured_output(ProblemAnalysis)

def analyzer_node(state: BlackboardState):
    """第一个激活的代理：读取工单并在黑板上发布分析"""
    print("--- [AGENT: Problem Analyzer] Activating... ---")
    start_time = time.time()
    result = analyzer_chain.invoke({"ticket": state['ticket']})
    execution_time = time.time() - start_time
    log = f"[Analyzer] Completed in {execution_time:.2f}s."
    print(log)
    # 该代理的作用是填写黑板上的 'analysis' 槽
    return {"analysis": result, "performance_log": [log]}</code></pre><p><code>analyzer_node</code> 是协作的入口点，执行初始的"意义理解"步骤，将无结构用户工单转换为结构化 <code>ProblemAnalysis</code> 对象，并将其发布到黑板上供其他代理查看。</p><p>其他代理（<code>retriever_node</code> 和 <code>draftsman_node</code>)，遵循类似模式，读取黑板当前状态并添加自己的贡献。</p><p>黑板系统最关键的部分是中央路由器，功能是控制每个智能体在对应轮次检查黑板，并决定哪个专家最适合进行下一步动作，是事件驱动、机会主义协作的核心。</p><pre><code class="python">def router(state: BlackboardState) -&gt; str:
    """中央路由器：检查黑板并决定下一步激活哪个代理"""
    print("--- [ROUTER] Inspecting blackboard... ---")
    
    # 路由器的逻辑是一系列按顺序查看的规则
    # 规则 1: 如果已经写好了草案，问题就解决了
    if state.get('draft'):
        print("--- [ROUTER] Decision: Draft is complete. Finishing workflow. ---")
        return END
    
    # 规则 2：如果找到了解决方案（但还没有草案），是时候写回应了
    if state.get('solution'):
        print("--- [ROUTER] Decision: Solution found. Activating Draftsman. ---")
        return "draftsman"
    
    # 规则 3：如果完成了分析（但还没有解决方案），是时候找到解决方案了
    if state.get('analysis'):
        print("--- [ROUTER] Decision: Analysis complete. Activating Solution Retriever. ---")
        return "retriever"
    
    # 如果入口点设置正确，理想情况下不应该走到默认路径
    return "analyzer"</code></pre><p><code>router</code> 是系统的主体部分，是一个动态、状态驱动的决策者。每个节点运行后，图会调用 <code>router</code> 功能，检查 <code>BlackboardState</code>，根据已填充的字段确定最合理的下一步，从而使得工作流根据问题的演变状态自然涌现。</p><p>然后组装图，通过中央路由器连接所有节点。</p><pre><code class="python">from langgraph.graph import StateGraph, START, END

workflow = StateGraph(BlackboardState)

# 添加专家代理节点
workflow.add_node("analyzer", analyzer_node)
workflow.add_node("retriever", retriever_node) # (Defined in the notebook)
workflow.add_node("draftsman", draftsman_node) # (Defined in the notebook)

# 入口点总是分析器
workflow.add_edge(START, "analyzer")

# 每个节点运行后，转到中央路由器来决定下一步
# 这将创建 “hub-and-spoke” 架构，路由器是其核心
workflow.add_conditional_edges("analyzer", router)
workflow.add_conditional_edges("retriever", router)
workflow.add_conditional_edges("draftsman", router)

# 不需要直接到 END，路由器会处理终止条件
app = workflow.compile()
print("Graph constructed and compiled successfully.")</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537067" alt="黑板协作" title="黑板协作" loading="lazy"/></p><p>我们检查黑板的最终状态，并定性分析这种协作方式的优势。</p><pre><code class="python">import json
print("="*60)
print("                 FINAL BLACKBOARD STATE")
print("="*60)
# (已经完成完整运行，并填充了 final_state)
print(json.dumps(final_state, indent=4, default=lambda o: o.dict() if hasattr(o, 'dict') else o))

print("\n" + "="*60)
print("                     ACCURACY &amp; QUALITY ANALYSIS")
print("="*60 + "\n")</code></pre><p>得到的结果……</p><pre><code class="python">#### 输出 ####
============================================================
                 FINAL BLACKBOARD STATE
============================================================

{
    "ticket": "I'm really frustrated. My new Aura Ring isn't syncing my sleep data...",
    "analysis": {
        "product": "Aura Ring",
        "problem_summary": "The Aura Ring app is failing to sync sleep data.",
        "user_sentiment": "Negative"
    },
    "solution": {
        "relevant_articles": [
            "Article 4: To resolve app connectivity issues with the Aura Ring...",
            "Article 1: To reset your Aura Smart Ring..."
        ]
    },
    "draft": {
        "response_text": "Hi there, I'm sorry to hear you're frustrated with the Aura Ring's sleep sync issue...Here are a couple of common solutions from our knowledge base..."
    },
    "performance_log": [
        "[Analyzer] Completed in 4.55s.",
        "[Retriever] Completed in 7.89s.",
        "[Draftsman] Completed in 6.21s."
    ]
}</code></pre><p>最终草案质量明显优于单一智能体可能产生的质量，原因如下：</p><ol><li><strong>解耦减少错误</strong>：单一智能体可能会误解用户问题并找到错误的解决方案。通过将分析从检索中分离出来，确保检索步骤基于对问题清晰、结构化的总结。</li><li><strong>专业化深度增加</strong>：草案器智能体通过专注于清晰度的提示进行了专业化。接收结构化数据（情绪、问题总结、解决方案）使其能够作出更有帮助的回应，既解决了技术问题，也缓解了用户的挫败感。</li><li><strong>可审计性与模块化</strong>：黑板上的每个对象（<code>analysis</code>，<code>solution</code>，<code>draft</code>）都是独立的可审计工件。如果最终草案有误，可以追溯是否是分析出错或检索失败，使得系统比单一黑盒代理更容易调试和改进。</li></ol><hr/><blockquote>Hi，我是俞凡，一名兼具技术深度与管理视野的技术管理者。曾就职于 Motorola，现任职于 Mavenir，多年带领技术团队，聚焦后端架构与云原生，持续关注 AI 等前沿方向，也关注人的成长，笃信持续学习的力量。在这里，我会分享技术实践与思考。欢迎关注公众号「DeepNoMind」，星标不迷路。也欢迎访问独立站 <a href="https://link.segmentfault.com/?enc=Ld3r2xAglvld7wY0jyHLCQ%3D%3D.FPvPsSBNOJ0x5lht%2FoSM9a9981d4zfkEYAYA%2FX0Eid4%3D" rel="nofollow" title="www.DeepNoMind.com" target="_blank">www.DeepNoMind.com</a>，一起交流成长。</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=IT2I8pC5DGNiWKX3NS0cZQ%3D%3D.2FRTCbyY4A9Pm0NfcF3k7BdkLI4rKzjfTnAp2I8W93s%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[点量云流实时云渲染：如何设置分辨率？三招搞定！ 点量实时云渲染 ]]></title>    <link>https://segmentfault.com/a/1190000047537078</link>    <guid>https://segmentfault.com/a/1190000047537078</guid>    <pubDate>2026-01-12 11:05:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img width="723" height="311" referrerpolicy="no-referrer" src="/img/bVdnCI4" alt="" title=""/><br/>在日常工作中，咱们的同事经常收到客户关于分辨率设置的询问：“怎么设置分辨率，很多用户访问，终端设备不同，怎么设置不同的分辨率？”“云流管理后台设置了分辨率以后，会不会所有终端都是一样的分辨率了？”“怎么知道哪个分辨率是最合适的呢？”<br/>今天，我们就针对这个高频问题，来一次“接地气”的技术分享，教大家如何通过点量云流，让您的应用在任何设备上都能清晰、舒适地呈现。</p><h2>问题一：不同终端设备，如何设置不同的分辨率？</h2><p>咱们都知道，手机、平板、电脑……这些设备的屏幕尺寸和分辨率五花八门。想让云端应用在每台设备上都“刚刚好”，确实需要一点技巧。<br/>在点量云流实时云渲染中，我们为您提供了灵活的分辨率解决方案：<br/>1、“万能”的默认分辨率<br/>您只需登录点量云流管理后台，进入【云应用】→【编辑】→【高级设置】，找到“分辨率”选项。这里我们推荐设置为 1920×1080（即1080P）。这个分辨率是目前兼容性最广的“黄金比例”，能在绝大多数设备上获得良好的基础显示效果，是省心又稳妥的首选。<br/><img width="723" height="568" referrerpolicy="no-referrer" src="/img/bVdnCI7" alt="" title="" loading="lazy"/></p><p>2、API驱动，自动智能适配<br/>对于有集成需求的客户，我们提供了更智能的解决方案。您可以通过集成云流版的websdk，计算终端设备的分辨率，得出一个合适的云端应用的分辨率，使用sdk的API函数cloudDesktopApp.setResolution(width,height)动态设置当前显示的分辨率，实现分辨率动态自适应设置。</p><p>3、手动切换，随时调整<br/>如果某个特定设备觉得画面不合适，用户访问时完全可以自己动手调整。在点量云流的网页端菜单栏中，找到【画面】→【分辨率】，就能像调节视频清晰度一样，实时选择一个更匹配当前设备屏幕的分辨率，所见即所得。<br/><img width="723" height="370" referrerpolicy="no-referrer" src="/img/bVdnCI8" alt="" title="" loading="lazy"/></p><h2>问题二：云流管理后台设置的分辨率是所有终端统一的吗？</h2><p>点量云流系统后台设置的分辨率，准确来说是云应用启动时的默认分辨率。所有终端首次访问时，都会从这个统一的起点开始。</p><p>但是，统一并不等于固定不变。正如上面所说的，我们赋予了终端用户手动调整的权利，也提供了让开发者实现自动适配的能力。所以，它更像一个“推荐设置”，确保了起点的一致性，同时保留了充分的灵活性来满足个性化需求。</p><p>小提示：如果您的3D应用本身有强制全屏或自行修改分辨率的逻辑，在进行推流的过程中，可能会暂时覆盖点量云流本来的设置。遇到这类情况，欢迎随时联系我们的技术支持，一起探讨最佳配置策略。</p><p>好的云流化技术应该是“上得厅堂，下得厨房”——既足够专业强大，又能灵活解决实际的小麻烦。所以，面对多个客户询问的“在使用点量云流过程中，多终端分辨率如何适配”的这个常见技术痛点，我们通过 “默认值保底 + API驱动自动适配 + 手动调整可选” 的三层方案，确保无论是管理员、终端用户还是集成开发者，都能找到最适合自己的方式，点量云流希望让每一块屏幕都能显示最佳的视觉效果。</p><p>希望本篇点量云流技术常见问题小课堂能解答您关于“云推流中的分辨率如何设置”的疑惑！<br/>如您在实践过程中有任何新发现或新问题，欢迎随时在评论区或咨询点量团队与我们交流~</p><p>点量云流实时云渲染，有屏幕就能点亮视界！<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdmT11" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[为什么内网IP也需要SSL证书？ 冷姐Joy ]]></title>    <link>https://segmentfault.com/a/1190000047537101</link>    <guid>https://segmentfault.com/a/1190000047537101</guid>    <pubDate>2026-01-12 11:04:43</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在很多人看来，SSL证书主要是用于互联网上的网站，比如电商平台、银行网站等，需要保护用户的敏感数据。但你可能不知道，<strong>内网IP（如192.168.1.1、10.0.0.1等）同样需要SSL证书</strong>。</p><p><strong>1. 防止内网数据被窃听</strong></p><p>即使你的服务只在局域网内运行，数据仍然可能被监听。例如：</p><p>如果公司Wi-Fi被入侵，黑客可以嗅探内部HTTP流量，获取账号密码、数据库信息等。</p><p>内部员工可能利用抓包工具（如Wireshark）查看未加密的通信内容。</p><p><img width="723" height="432" referrerpolicy="no-referrer" src="/img/bVdbRuZ" alt="" title=""/><br/>内网IP地址SSL证书申请入口<a href="https://link.segmentfault.com/?enc=F4oR%2FSLT%2BoKhBkFAP2lBDQ%3D%3D.wO%2Bj3jxMvO4Bjhcd2J96Q6atQMU72qukKUD2TUsfiC8q5bIZ%2FSKvzMVvGYd2jMM4117m%2BoGH9VimuaW%2Fqg2Fkz2ZPlWG3Tun90zFmPDrA4PDVeuFyf%2BjNpOAZlXd9xoc" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/joyssl-dv-intranet-...</a></p><p><strong>SSL证书的作用</strong>：通过HTTPS加密，确保数据在传输过程中无法被窃取或篡改。</p><p><strong>2. 避免浏览器“不安全”警告</strong></p><p>现代浏览器（如Chrome、Edge）会对所有HTTP网站标记为“不安全”，即使是内网IP也不例外。这会导致：</p><p>员工访问内部系统时频繁看到警告，影响使用体验。</p><p>某些浏览器可能阻止访问HTTP网站，导致内部工具无法正常使用。</p><p><strong>SSL证书的解决方案</strong>：部署证书后，内网服务将以HTTPS运行，浏览器不再提示“不安全”。</p><p><strong>3. 满足安全合规要求</strong></p><p>许多行业（如金融、医疗、政府）对数据安全有严格要求，例如：</p><p><strong>GDPR（欧盟通用数据保护条例）</strong>  ：要求企业保护用户和员工的隐私数据。</p><p><strong>等保2.0（中国网络安全等级保护）</strong>  ：明确要求内部系统采用加密通信。</p><p><strong>SSL证书的合规价值</strong>：帮助企业在审计时证明内部通信符合安全标准。</p><p><strong>4. 防止中间人攻击（MITM）</strong></p><p>在内网环境中，攻击者可能伪装成网关或服务器，进行中间人攻击（MITM），例如：</p><p>伪造一个假的登录页面，诱导员工输入账号密码。</p><p>篡改内部API请求，导致数据泄露或系统故障。</p><p><strong>SSL证书的防护机制</strong>：HTTPS通过数字证书验证服务器身份，确保通信双方不被冒充。</p><p><strong>5. 如何为内网IP申请SSL证书？</strong></p><p>虽然公共通常不直接为内网IP签发证书，但仍有几种解决方案：</p><p><strong>私有CA（企业级方案）</strong>  ：在企业内部搭建CA，统一签发和管理证书。</p><p><strong>特殊CA支持</strong>：部分CA（如JoySSL）提供内网IP证书，需付费申请。</p><p><strong>总结</strong> 内网IP使用SSL证书并非多此一举，而是<strong>提升安全性、改善用户体验、满足合规要求</strong>的重要措施。无论是企业OA系统、内部数据库还是开发测试环境，HTTPS加密都能有效降低风险。!</p>]]></description></item><item>    <title><![CDATA[如何快速掌握CAD的基本操作？ 酷酷的板凳 ]]></title>    <link>https://segmentfault.com/a/1190000047537118</link>    <guid>https://segmentfault.com/a/1190000047537118</guid>    <pubDate>2026-01-12 11:03:53</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>想要快速掌握CAD基本操作，核心是抓重点、练高频、守规范，不用死记所有命令，聚焦新手必备的核心技能，配合针对性练习，1-2 周就能上手基础绘图。<br/>具体方法如下：<br/>1.优先记牢高频命令，拒绝全量记忆CAD 命令很多，但新手只需掌握20% 的核心命令，就能完成 80% 的基础绘图，建议按 “绘图→修改→辅助” 分类记忆，重点记英文缩写（比点击图标快 10 倍）：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047537120" alt="图片" title="图片"/><br/>记忆技巧：边练边记，每画一个图形就刻意用命令缩写，比死记硬背效率高 3 倍。<br/>2.聚焦 3 个核心操作模块，逐个突破不用贪多求全，按 “绘图→修改→规范” 的顺序逐个攻克，每步搭配 1 个简单练习，巩固效果翻倍。<br/>第一步：练熟基础绘图命令（2 天）目标：能用直线、圆、矩形画出简单图形（如正方形、带圆孔的矩形）。关键技巧：画直线时，用相对坐标精准控制长度（如输入 @100,0 画 100 单位的水平线）；画矩形时，直接输入长宽（输入 REC 后，指定角点，再输入 @长,宽，比如 @80,50 直接画出 80×50 的矩形）。<br/>第二步：掌握 4 个高频修改命令（3 天）目标：能调整图形位置、批量复制、修剪多余线条。关键技巧：修剪（TR）命令：连续按两次回车，可直接点击删除多余线条，不用选边界，效率超高；复制（CO）命令：指定基点（如图形中心点）后，可连续点击多个目标点，一次性复制多个图形。<br/>第三步：吃透图层管理，养成规范习惯（2 天）这是新手和 “小白” 的分水岭，图层能让图纸整洁、避免误操作。核心步骤：输入 LA 打开图层管理器，新建 3 个基础图层：轮廓线层（白色、实线、0.3mm 线宽）、中心线层（红色、点划线、0.15mm）、标注层（蓝色、实线、0.15mm）；绘图前切换对应图层，比如画中心线就先选中心线层，避免所有图形混在一个图层里。<br/>3.用 “刻意练习法” 代替盲目画图光看教程没用，必须针对性练习，推荐3 个新手必做的综合练习，覆盖所有基础操作：<br/>练习 1：绘制一个 100×60 的矩形，在矩形中心画一个半径 20 的圆 → 用移动（M）调整圆的位置 → 用修剪（TR）剪掉圆超出矩形的部分；<br/>练习 2：绘制一个边长 50 的正三角形 → 复制（CO）2 个副本 → 排列成一行，间距 30；<br/>练习 3：给练习 1 的图形分层（矩形放轮廓线层、圆放轮廓线层、中心线放中心线层）→ 标注尺寸（线性标注 DLI + 半径标注 DRA）。<br/>练习要求：全程用命令缩写，不点击图标，每画完一个就复盘：有没有更快捷的操作方式？记住 3 个新手避坑技巧，少走弯路随时保存：养成按 Ctrl+S 的习惯，避免软件崩溃丢失文件；善用正交模式：点击状态栏的正交按钮（或按 F8），画直线时自动锁定水平 / 垂直方向，不用手动对齐；不懂就看命令行：CAD 的命令行是 “老师”，输入命令后，命令行会提示下一步操作（比如画圆时提示 “指定圆心”），跟着提示走，不会出错。<br/>总结：快速掌握 CAD 的核心是 <strong>“少而精”</strong> —— 少记命令、多练实操、严守规范，每天花 1 小时做针对性练习，1 周就能独立画出简单的零件图或建筑平面图。</p>]]></description></item><item>    <title><![CDATA[详细指南：域名解析的定义、作用、流程与注意事项全解析 防火墙后吃泡面 ]]></title>    <link>https://segmentfault.com/a/1190000047537140</link>    <guid>https://segmentfault.com/a/1190000047537140</guid>    <pubDate>2026-01-12 11:03:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在互联网的运行体系中，域名解析如同“网络导航系统”，默默完成着从易记域名到机器可读IP地址的转换，是用户顺畅访问各类网站的核心前提。大部分人日常只需要输入域名就可以浏览网页，却对背后的解析机制知之甚少。</p><p>本文，国科云将从定义、作用、流程、注意事项四个维度，全面拆解<a href="https://link.segmentfault.com/?enc=PhP8do39erdSe1%2BJCB0Rvg%3D%3D.Qm30yO66Pn%2B3rRo5IXBbobZX597Lx769bItMd0IvztlEW337gQDe0xXNVFz1m4ib" rel="nofollow" target="_blank">域名解析</a>的核心知识，帮你轻松掌握这一互联网基础技术。</p><h2>一、什么是域名解析？</h2><p>域名解析，本质是通过DNS（域名系统，Domain Name System）将人类易于记忆的域名转换为计算机可识别的IP地址的过程。互联网中的设备依靠IP地址实现相互通信，就像现实中人们通过身份证号精准定位个人，但一串复杂的数字序列难以记忆。域名作为IP地址的“别名”，解决了记忆难题，而域名解析则承担着“翻译官”的角色，搭建起人类记忆习惯与机器通信规则之间的桥梁。</p><p>这一过程由DNS服务器集群协同完成，属于分布式服务架构，无需集中式管理即可实现全球域名的高效解析。值得注意的是，域名与IP地址并非一对一绝对对应，一个IP地址可绑定多个域名，而一个域名也可通过不同解析记录指向多个IP，满足负载均衡等多样化需求。</p><h2>二、域名解析有哪些用处？</h2><p>域名解析是互联网正常运转的底层支撑，其作用渗透于每一次网络访问，核心价值体现在三个方面。</p><ol><li>降低网络访问门槛</li></ol><p>如果没有域名解析，用户需要牢记每一个网站对应的IP地址才能访问，这对普通用户而言几乎不可能实现。域名解析让“输入好记的域名”替代“背诵复杂IP”，降低了互联网的使用成本，推动了网络的普及。</p><ol start="2"><li>保障服务灵活扩展</li></ol><p>企业网站如果更换服务器，IP地址会随之变更，通过域名解析可快速修改域名对应的IP记录，无需通知用户调整访问方式。同时，借助多线路解析、负载均衡解析等功能，还能根据用户地域、网络运营商优化访问路径，提升网站响应速度。</p><ol start="3"><li>支撑多场景网络服务</li></ol><p>除了网页访问，域名解析还为邮件服务、FTP服务等提供基础支持。例如，通过MX记录解析可将域名指向邮件服务器，实现企业邮箱的正常使用；通过CNAME记录可将域名绑定到CDN节点，提升内容分发效率。</p><h2>三、域名解析的完整流程</h2><p>域名解析通常分为递归查询和迭代查询两种方式，实际应用中多为二者结合，以下以常见的迭代查询为例，拆解解析的全步骤，核心涉及四类DNS服务器的协同工作。</p><p>第一步，本地缓存查询。</p><p>用户在浏览器输入域名后，系统会优先检查本地缓存，包括浏览器缓存和操作系统缓存。如果缓存中存在该域名的解析记录且未过期，将直接使用对应的IP地址建立连接，无需后续查询，这是提升解析效率的关键环节。</p><p>第二步，本地DNS服务器查询。</p><p>如果本地缓存无对应记录，设备会向本地DNS服务器（通常由运营商提供，或用户手动设置的公共DNS如8.8.8.8）发送查询请求。本地DNS服务器会先检查自身缓存，有记录则直接返回结果；无记录则进入下一步。</p><p>第三步，根DNS服务器查询。</p><p>本地DNS服务器向全球13组根DNS服务器发送请求，根服务器不存储具体域名的IP映射，仅根据域名后缀（如.com、.cn）返回对应顶级域名服务器（TLD服务器）的地址。例如，解析www.example.com时，根服务器会返回.com后缀对应的TLD服务器地址。</p><p>第四步，TLD服务器查询。</p><p>本地DNS服务器向TLD服务器发送查询请求，TLD服务器负责管理对应顶级域下的域名，会根据二级域名（如example.com）返回该域名的权威DNS服务器地址。</p><p>第五步，权威DNS服务器查询。</p><p>本地DNS服务器向权威DNS服务器发送请求，该服务器存储着域名的完整解析记录，会返回对应的IP地址（或其他解析记录）。</p><p>第六步，结果返回与缓存。</p><p>本地DNS服务器将获取的IP地址返回给用户设备，同时将该解析记录存入缓存，以便后续其他用户查询时快速响应。用户设备拿到IP地址后，即可与目标服务器建立连接，完成网页加载。整个过程通常在毫秒级完成，用户几乎感知不到。</p><h2>四、域名解析的实操与安全注意事项</h2><p>接下来，我再从解析记录的配置、故障排查和安全防护等几个方面简单分享下域名解析的常见注意事项。</p><p>1.解析配置方面</p><p>首先要选对解析记录类型。常用记录类型包括A记录（将域名指向IPv4地址，适用于普通网站）、CNAME记录（将域名指向另一个域名，适用于CDN或负载均衡场景）、MX记录（用于邮件服务，需设置优先级）。需根据实际需求选择，避免记录类型错误导致解析失效。</p><p>其次要合理设置TTL值，TTL（生存时间）决定解析记录在缓存中的有效时长，建议普通场景设置为3600秒（1小时），既保证解析效率，又能在需要修改记录时快速生效；如果需要频繁变更IP，可适当缩短TTL值，但不宜过小，避免增加DNS服务器负担。</p><ol start="2"><li>故障排查方面</li></ol><p>如果出现域名无法访问，可先通过“ipconfig /flushdns”（Windows系统）或“sudo killall -HUP mDNSResponder”（Mac系统）清除本地缓存；再通过nslookup或ping命令验证解析结果，确认域名是否指向正确IP。若解析记录无误但访问异常，需检查服务器状态、网络防火墙设置，或更换公共DNS服务器排查本地DNS故障。</p><ol start="3"><li>安全防护方面</li></ol><p>DNS劫持是攻击者伪造解析响应，将用户引导至恶意网站的行为。可通过启用DNSSEC（DNS安全扩展）验证解析结果真实性，或使用DNS over HTTPS（DoH）加密查询过程，提升解析安全性。同时，企业用户应开启域名注册商的锁定功能和双因素认证，防止NS记录被恶意篡改。</p>]]></description></item><item>    <title><![CDATA[基于Java开源框架搭建的零代码+可视化编排引擎（附功能清单） 软件部长 ]]></title>    <link>https://segmentfault.com/a/1190000047537148</link>    <guid>https://segmentfault.com/a/1190000047537148</guid>    <pubDate>2026-01-12 11:02:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>什么是服务编排</h2><p>服务编排是通过图形化的方式表达后端业务逻辑的能力 ， 它能够帮助我们通过可视化、 拖拉拽式进行业务逻辑的定义、 实现服务的整合调用、 数据的加工计算等多种场景。<br/>JVS逻辑引擎是一款基于可视化拖拽和原子服务编排的逻辑引擎，通过将复杂的业务逻辑拆分为可复用的原子服务，并通过可视化的方式进行编排。实现了业务规则自动化，缩短开发、部署和测试周期。特点包括界面化配置、动态扩展和多种应用场景，如业务规则管理、决策支持、实时风险评估等。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047537150" alt="图片" title="图片"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537151" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537152" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537153" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537154" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537155" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537156" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537157" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537158" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047537159" alt="图片" title="图片" loading="lazy"/><br/>功能清单<br/><img width="723" height="742" referrerpolicy="no-referrer" src="/img/bVdnCJy" alt="image.png" title="image.png" loading="lazy"/><br/><img width="723" height="752" referrerpolicy="no-referrer" src="/img/bVdnCJQ" alt="image.png" title="image.png" loading="lazy"/><br/><img width="723" height="750" referrerpolicy="no-referrer" src="/img/bVdnCJY" alt="image.png" title="image.png" loading="lazy"/><br/><img width="723" height="551" referrerpolicy="no-referrer" src="/img/bVdnCJ7" alt="image.png" title="image.png" loading="lazy"/><br/>在线demo：<a href="https://link.segmentfault.com/?enc=UgThR9k5G2Tn%2FHcpayH3xA%3D%3D.PyRwK86jwz5JX4QAom3toh%2FUh8cr00I46EqTGdyyeKU%3D" rel="nofollow" target="_blank">https://logic.bctools.cn/</a><br/>gitee地址：<a href="https://link.segmentfault.com/?enc=XGunRcVLhNEe8PiLtQBaLA%3D%3D.kLBU8pqhYeuwwsfL%2BDz91qpysc%2FdeOXwAyW0tFuDAo0u6CYJhUMd4D2fwTM9lEA%2B" rel="nofollow" target="_blank">https://gitee.com/software-minister/jvs-logic</a></p>]]></description></item><item>    <title><![CDATA[用 Python 解锁 Word 表格：高效提取与自动化处理指南 宇文成都 ]]></title>    <link>https://segmentfault.com/a/1190000047537175</link>    <guid>https://segmentfault.com/a/1190000047537175</guid>    <pubDate>2026-01-12 11:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在日常办公和自动化处理场景中，Word 文档（DOC/DOCX）依然是最常见的数据载体之一。许多业务数据、统计报表、合同条款或配置信息，往往以<strong>表格</strong>的形式存在于 Word 文档中。当我们需要对这些表格数据进行进一步处理（如导入数据库、转换为 Excel、生成报表或进行数据分析）时，手动复制粘贴显然效率低下，也容易出错。</p><p>借助 Python 以及专业的文档处理库，我们可以实现  <strong>自动化提取 Word 表格内容</strong> ，并将其保存为结构化文本文件或其他格式。本文将详细介绍如何使用  <strong>Spire.Doc for Python</strong> ，从 Word 文档中逐个提取表格，并将表格内容导出为文本文件。</p><h2>为什么选择 Spire.Doc for Python？</h2><p>在众多 Python 文档处理方案中，Spire.Doc for Python 是一款面向开发者的专业 Word 文档处理库，具备以下显著优势：</p><ul><li><strong>无需依赖 Microsoft Word</strong> ：纯 Python 实现，适合服务器和自动化环境</li><li><strong>支持完整 Word 结构</strong> ：段落、表格、页眉页脚、样式等均可访问</li><li><strong>API 设计清晰</strong> ：面向对象，逻辑与 Word 文档结构高度一致</li><li><strong>稳定可靠</strong> ：适合批量处理与企业级应用场景</li></ul><p>在提取表格这种涉及文档层级遍历的任务中，Spire.Doc 提供了非常直观的对象模型，使代码既清晰又易于维护。</p><h2>实现思路概述</h2><p>从 Word 中提取表格，本质上是对 Word 文档结构的逐层遍历。整体流程如下：</p><ol><li>加载 Word 文档</li><li>遍历文档中的所有 Section（节）</li><li>在每个 Section 中获取所有表格（Table）</li><li>遍历表格中的行（Row）和单元格（Cell）</li><li>读取单元格内的段落文本</li><li>按行列结构拼接表格数据</li><li>将每个表格保存为独立的文本文件</li></ol><p>这种方式不仅能够完整保留表格结构，也便于后续扩展为 CSV、Excel 或数据库导入逻辑。</p><h2>准备工作</h2><p>在开始之前，请确保你的环境已准备就绪：</p><ul><li>Python 3.x</li><li>已安装 <code>spire.doc</code>（Spire.Doc for Python）</li></ul><p>安装方式示例：</p><pre><code class="bash">pip install spire-doc</code></pre><p>安装完成后，即可在 Python 项目中直接引用相关模块。</p><h2>示例代码：从 Word 提取表格并保存为文本文件</h2><p>下面是完整的示例代码，用于从 Word 文档中提取所有表格，并将每个表格保存为一个 <code>.txt</code> 文件。</p><pre><code class="python">from spire.doc import *
from spire.doc.common import *

# 创建 Document 实例
doc = Document()

# 加载 Word 文档
doc.LoadFromFile("Input.docx") 

# 遍历文档中的所有节（Section）
for s in range(doc.Sections.Count):
    # 获取当前节
    section = doc.Sections.get_Item(s)
    # 获取当前节中的所有表格
    tables = section.Tables
    # 遍历当前节中的表格
    for i in range(0, tables.Count):
        # 获取表格对象
        table = tables.get_Item(i)
        # 用于存储当前表格数据的字符串
        tableData = ''
        # 遍历表格中的所有行
        for j in range(0, table.Rows.Count):
            # 遍历当前行中的所有单元格
            for k in range(0, table.Rows.get_Item(j).Cells.Count):
                # 获取单元格对象
                cell = table.Rows.get_Item(j).Cells.get_Item(k)
                # 用于存储单元格中的文本内容
                cellText = ''
                # 遍历单元格中的所有段落
                for para in range(cell.Paragraphs.Count):
                    paragraphText = cell.Paragraphs.get_Item(para).Text
                    cellText += (paragraphText + ' ')
                # 将单元格文本追加到表格数据字符串中
                tableData += cellText
                # 如果不是最后一个单元格，则添加制表符作为列分隔符
                if k &lt; table.Rows.get_Item(j).Cells.Count - 1:
                    tableData += '\t'
            # 当前行结束后，添加换行符
            tableData += '\n'
    
        # 将表格数据保存为文本文件
        with open(f'output/Tables/WordTable_{s+1}_{i+1}.txt', 'w', encoding='utf-8') as f:
            f.write(tableData)

# 关闭文档，释放资源
doc.Close()</code></pre><h2>代码详解</h2><p>下面我们对核心代码逻辑进行逐步解析，帮助你更好地理解其工作原理。</p><h3>1. 加载 Word 文档</h3><pre><code class="python">doc = Document()
doc.LoadFromFile("Input.docx")</code></pre><p>这里创建了一个 <code>Document</code> 实例，并加载指定路径下的 Word 文件。<code>Document</code> 是 Spire.Doc 中表示整个 Word 文档的核心对象。</p><h3>2. 遍历文档中的 Section</h3><pre><code class="python">for s in range(doc.Sections.Count):
    section = doc.Sections.get_Item(s)</code></pre><p>在 Word 中，文档可能由多个 Section 组成（例如分页、不同页眉页脚设置）。为了不遗漏任何表格，我们需要遍历所有 Section。</p><h3>3. 获取并遍历表格</h3><pre><code class="python">tables = section.Tables
for i in range(0, tables.Count):
    table = tables.get_Item(i)</code></pre><p>每个 Section 都可能包含多个表格。通过 <code>section.Tables</code> 可以直接获取该节中的所有表格对象。</p><h3>4. 遍历行和单元格</h3><pre><code class="python">for j in range(0, table.Rows.Count):
    for k in range(0, table.Rows.get_Item(j).Cells.Count):
        cell = table.Rows.get_Item(j).Cells.get_Item(k)</code></pre><p>表格由行和单元格组成。这里采用双层循环，确保按“行 → 列”的顺序读取数据，从而保持原有表格结构。</p><h3>5. 读取单元格中的段落文本</h3><pre><code class="python">for para in range(cell.Paragraphs.Count):
    paragraphText = cell.Paragraphs.get_Item(para).Text
    cellText += (paragraphText + ' ')</code></pre><p>一个单元格中可能包含多个段落（例如手动换行）。因此，需要遍历 <code>cell.Paragraphs</code>，并将所有段落文本拼接起来，确保内容完整。</p><h3>6. 拼接表格数据</h3><pre><code class="python">tableData += cellText
tableData += '\t'
tableData += '\n'</code></pre><ul><li>使用 <strong>制表符（\t）</strong> 分隔列</li><li>使用 <strong>换行符（\n）</strong> 分隔行</li></ul><p>这种格式非常适合后续转换为 Excel、CSV，或直接导入数据库。</p><h3>7. 保存为文本文件</h3><pre><code class="python">with open(f'output/Tables/WordTable_{s+1}_{i+1}.txt', 'w', encoding='utf-8') as f:
    f.write(tableData)</code></pre><p>每个表格都会被单独保存为一个文本文件，文件名中包含 Section 和 Table 的索引，便于区分来源。</p><h2>应用场景拓展</h2><p>基于本文示例代码，你可以轻松扩展到更多实际应用场景，例如：</p><ul><li>将提取的表格数据转换为 <strong>CSV 或 Excel</strong></li><li>自动解析 Word 报表并导入 <strong>数据库系统</strong></li><li>批量处理合同或业务文档中的表格信息</li><li>与数据分析或 BI 工具进行对接</li></ul><p>Spire.Doc for Python 提供的丰富 API，使这些扩展变得非常自然。</p><h2>总结</h2><p>本文介绍了如何使用 <strong>Spire.Doc for Python</strong> 从 Word 文档中自动提取表格内容，并将其保存为文本文件。通过对 Word 文档结构（Section、Table、Row、Cell、Paragraph）的逐层遍历，我们能够完整、准确地获取表格数据，并为后续的数据处理和自动化流程打下坚实基础。</p><p>如果你正在寻找一种 <strong>稳定、高效、无需依赖 Office 环境</strong> 的 Word 表格提取方案，那么 Spire.Doc for Python 无疑是一个值得考虑的选择。</p>]]></description></item><item>    <title><![CDATA[MySQL ERROR 1114 (HY000): The table is full 本文系转载，]]></title>    <link>https://segmentfault.com/a/1190000047536799</link>    <guid>https://segmentfault.com/a/1190000047536799</guid>    <pubDate>2026-01-12 10:05:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000045231690" alt="ERROR 1114 (HY000): The table is full" title="ERROR 1114 (HY000): The table is full"/></p><p>MySQL 是一个广泛使用的开源关系数据库管理系统（RDBMS），它允许高效的数据存储和检索。但是用户可能会偶尔遇到 "ERROR 1114 (HY000): the table ' table_name ' is full" 的错误。当达到表存储引擎或表所在的分区的容量限制时，会发生此错误。</p><p>在本中，我们将探讨不同的解决方案解决此错误，确保数据库运行顺畅。</p><p>以下是解决此错误的一些可能的解决方案：</p><p><strong>Increase maximum allowed size</strong></p><p>如果你使用内存存储引擎，考虑增加内存表的最大允许容量。</p><p>临时增加特定于会话的限制，例如设置为最大容量为 2GB</p><pre><code>SET SESSION max_heap_table_size = 1024 * 1024 * 1024 * 2;
SET SESSION tmp_table_size = 1024 * 1024 * 1024 * 2;</code></pre><p>永久增加 MySQL 配置文件（my.cnf 或 my.ini）中的限制</p><pre><code>[mysqld]
max_heap_table_size = 2G
tmp_table_size = 2G</code></pre><p>修改配置文件后，需要重启 MySQL 服务使配置生效。</p><p><strong>Switch to the InnoDB storage engine</strong></p><p>如果不是特别需要内存表，可以考虑使用 InnoDB 存储引擎，具有更好的整体性能。</p><pre><code>CREATE TABLE new_table_name SELECT * FROM table_name;</code></pre><p>然后，删除旧表并重命名新表</p><pre><code>DROP TABLE table_name;
RENAME TABLE new_table_name TO table_name;</code></pre><p><strong>Check disk space and increase available space</strong></p><p>如果您使用的是 InnoDB 或 MyISAM 存储引擎，那么您的 MySQL 的数据存储是满的，你需要释放一些磁盘空间或者向分区添加更多存储空间。</p><p><strong>Reorganize the partition to redistribute the data</strong></p><p>如果您的表是分区的，请考虑重新组织或添加更多分区。</p><pre><code>ALTER TABLE table_name REORGANIZE PARTITION partition_name INTO (new_partition_definition);</code></pre><p>或者添加更多分区来处理增加的数据</p><pre><code>ALTER TABLE table_name ADD PARTITION (new_partition_definition);</code></pre><p><strong>Optimize the table</strong></p><p>如果你已经从表中删除了大量的数据，你可以尝试优化它来回收未使用的空间。</p><pre><code>OPTIMIZE TABLE table_name;</code></pre><p><strong>注意：</strong> 在对数据库模式或配置进行任何更改之前，请始终记住备份数据，以避免数据丢失。</p>]]></description></item><item>    <title><![CDATA[工贸企业供应链客户协同 CRM 选哪个？推荐 6 款全链路贯通的高效产品 正直的炒饭 ]]></title>    <link>https://segmentfault.com/a/1190000047536805</link>    <guid>https://segmentfault.com/a/1190000047536805</guid>    <pubDate>2026-01-12 10:04:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在<strong>以客户为中心</strong>的商业时代，企业的核心竞争力已从“单一环节效率”转向“全链路协同能力”——能否将客户需求（前端）<strong>与</strong>供应链履约（后端）深度绑定，直接决定了客户满意度、复购率及供应链效率。</p><p>本文选取<strong>超兔一体云、SAP、Microsoft Dynamics 365、Oracle CX、Salesforce、浪潮CRM</strong>六大主流品牌，从<strong>核心架构、链路协同深度、数据驱动能力、行业适配性</strong>四大维度展开横评，为企业选型提供专业参考。</p><h2>一、先明确：“内外链路贯通”的核心逻辑</h2><p>所谓“内外链路贯通”，本质是构建“客户需求→销售转化→供应链履约→售后反馈→需求迭代”的闭环，核心要解决三大问题：</p><ol><li><strong>内部不协同</strong>：销售下单后，库存、生产、采购环节信息割裂，导致交货延迟；</li><li><strong>外部不同步</strong>：供应商、客户、物流商数据孤立，无法快速响应需求变化；</li><li><strong>数据不联动</strong>：客户生命周期（如需求阶段、偏好）与供应链能力（如库存、生产周期）无法关联，导致“客户要的没有，有的客户不要”。</li></ol><h2>二、六大品牌核心能力横评</h2><h3>（一）对比维度设计</h3><p>基于“链路贯通”的核心逻辑，我们选取<strong>5大核心维度+20项子指标</strong>，覆盖“架构-协同-数据-行业”全链路：</p><table><thead><tr><th>一级维度</th><th>二级维度</th><th>说明</th></tr></thead><tbody><tr><td><strong>核心架构</strong></td><td>一体化程度、模块覆盖、集成需求</td><td>是否需第三方系统支撑，或原生全业务覆盖</td></tr><tr><td><strong>内部链路协同</strong></td><td>模块联动深度、自动化流程、生产/库存联动</td><td>从订单到生产/采购的自动化程度</td></tr><tr><td><strong>外部链路拓展</strong></td><td>上下游连接能力、多渠道客户整合、生态兼容性</td><td>连接供应商/客户/物流的能力</td></tr><tr><td><strong>数据驱动能力</strong></td><td>实时性、360°客户视图、供应链-客户关联分析</td><td>数据能否支撑“需求-履约”的精准匹配</td></tr><tr><td><strong>行业适配性</strong></td><td>目标行业、企业规模、实施复杂度</td><td>匹配企业当前阶段的需求</td></tr></tbody></table><h3>（二）详细对比分析</h3><h4>1. 超兔一体云：本土中小微企业的“全业务一体”解决方案</h4><p><strong>核心定位</strong>：面向中小制造、商贸、服务企业，提供“CRM+进销存+供应链+生产+财务”全业务一体云，聚焦“快速打通内外链路”。</p><ul><li><strong>架构优势</strong>：原生全业务一体，无需集成第三方系统，从“客户线索→跟单→合同→库存→采购→生产→物流→售后”全流程闭环；</li><li><strong>内部协同</strong>：订单自动触发库存检查，库存不足时自动生成采购/生产任务，生产进度实时同步给客户；</li><li><strong>外部链路</strong>：通过<strong>OpenCRM</strong>连接上游供应商（询价/对账）与下游客户（订单跟踪/投诉），实现“企业-伙伴-客户”三方协同；</li><li><strong>数据驱动</strong>：支持“客户生命周期阶段→供应链响应策略”关联分析（如“需求培养期”提供定制化供应链服务，“复购期”优化库存备货）；</li><li><strong>行业适配</strong>：适合<strong>10-500人规模的中小制造/商贸企业</strong>，SaaS部署，实施周期≤1个月，性价比高。</li></ul><p><strong>典型场景</strong>：某中小五金制造企业用超兔后，客户下单时自动查库存，库存不足触发采购，采购到货后自动通知客户，<strong>订单交付周期从7天缩短至3天</strong>，客户复购率提升25%。</p><h4>2. SAP：大型跨国企业的“全球供应链协同”利器</h4><p><strong>核心定位</strong>：enterprise级解决方案，聚焦“全球供应链与客户需求的精准匹配”，适合复杂的跨国业务场景。</p><ul><li><strong>架构优势</strong>：以<strong>SAP S/4HANA Cloud</strong>（云ERP）为核心，集成CRM、SCM、PLM等模块，支持全球多语言、多币种、多法规；</li><li><strong>内部协同</strong>：通过集成业务计划（IBP）实现“销售需求→生产排程→采购计划”的AI模拟，优化资源分配；</li><li><strong>外部链路</strong>：依托<strong>SAP Business Network</strong>（全球B2B平台，年交易额超5万亿美元）连接供应商、物流商，实时共享交货状态、物流轨迹；</li><li><strong>数据驱动</strong>：<strong>供应链控制塔</strong>实时监控全球履约状态（如订单进度、库存水平），自动预警风险（如物流延迟）并提供解决方案；</li><li><strong>行业适配</strong>：适合<strong>千人以上大型跨国制造、化工、汽配企业</strong>，实施周期6-18个月，需专业咨询服务。</li></ul><p><strong>典型场景</strong>：某德国汽配企业用SAP后，通过<strong>供应链控制塔</strong>实时监控全球300+供应商的交货状态，<strong>订单交付准确率从85%提升至98%</strong> ，库存成本降低12%。</p><h4>3. Microsoft Dynamics 365：微软生态下的“轻量级一体化”</h4><p><strong>核心定位</strong>：依托微软生态，提供“CRM+ERP一体化”解决方案，聚焦“平衡效率与体验”。</p><ul><li><strong>架构优势</strong>：基于<strong>通用数据模型（</strong> <strong>CDM</strong> <strong>）</strong> ，原生整合销售、服务、营销、供应链模块，支持与Office 365、Power BI无缝联动；</li><li><strong>内部协同</strong>：通过<strong>双重写入（Dual Write）</strong>技术，实现CRM与ERP数据近实时同步（如客户订单自动同步至库存模块）；</li><li><strong>外部链路</strong>：整合微软生态（如Outlook同步客户数据、Power BI分析库存趋势），支持连接第三方物流/供应商；</li><li><strong>数据驱动</strong>：<strong>Copilot AI</strong>辅助销售（自动写邮件、提炼客户需求）与供应链（自动预警库存短缺），实现“客户需求→库存联动”；</li><li><strong>行业适配</strong>：适合<strong>100-2000人规模的制造、零售、科技企业</strong>，实施周期3-6个月，易上手。</li></ul><p><strong>典型场景</strong>：某零售企业用Dynamics 365后，客户下单时自动查库存，库存不足则推荐替代产品，<strong>订单转化率提升18%</strong> ，库存周转天数缩短10天。</p><h4>4. Oracle CX：“CX+ERP深度集成”的高定制化方案</h4><p><strong>核心定位</strong>：以客户数据平台（CDP）为核心，整合营销、销售、服务与ERP供应链，适合高定制化行业。</p><ul><li><strong>架构优势</strong>：CX模块（营销、销售、服务）与Oracle ERP深度集成，支持CPQ（配置报价）功能（客户选产品配置时，实时查ERP库存/生产能力）；</li><li><strong>内部协同</strong>：销售报价单自动关联ERP库存，确保“报价=可交付”，避免“承诺无法兑现”；</li><li><strong>外部链路</strong>：通过CDP整合多渠道客户数据（线上、线下、社交），构建360°客户视图；</li><li><strong>数据驱动</strong>：支持“客户偏好→供应链备货”关联分析（如某医疗设备企业，根据客户历史配置需求优化生产计划）；</li><li><strong>行业适配</strong>：适合<strong>高科技、制造、金融行业</strong>，实施周期6-12个月，适合高定制化产品场景。</li></ul><p><strong>典型场景</strong>：某医疗设备企业用Oracle CX后，<strong>报价准确率从70%提升至95%</strong> ，因实时联动了生产与库存数据，避免了“报低价但无法生产”的尴尬。</p><h4>5. Salesforce：轻量级销售团队的“灵活集成”方案</h4><p><strong>核心定位</strong>：以<strong>销售自动化</strong>为核心，适合轻量级销售团队，需集成第三方ERP实现供应链协同。</p><ul><li><strong>架构优势</strong>：CRM模块（销售、服务、营销）灵活，但需通过AppExchange集成SAP/Oracle ERP实现供应链联动；</li><li><strong>内部协同</strong>：销售线索自动分配，跟进提醒智能化，但库存/生产环节需依赖集成；</li><li><strong>外部链路</strong>：通过AppExchange连接第三方物流/供应商，支持多渠道客户互动（如社交、邮件）；</li><li><strong>数据驱动</strong>：需集成ERP后，才能实现“销售订单→库存联动”，原生不支持供应链分析；</li><li><strong>行业适配</strong>：适合<strong>SaaS、教育、轻量级销售团队</strong>，实施周期3-6个月，灵活配置。</li></ul><p><strong>典型场景</strong>：某教育机构用Salesforce后，<strong>销售线索转化率提升30%</strong> ，但供应链协同需通过Zapier连接物流系统，效率略低。</p><h4>6. 浪潮CRM：本土企业的“ERP联动”方案</h4><p><strong>核心定位</strong>：依托浪潮本土ERP（财务、生产、库存），实现“CRM+ERP一体化”，适合本土制造/零售企业。</p><ul><li><strong>架构优势</strong>：原生整合浪潮ERP（财务、生产、库存）与CRM（销售、服务），支持本土供应链（如国内物流、供应商）连接；</li><li><strong>内部协同</strong>：客户售后需求自动触发ERP备件库存查询，快速响应客户；</li><li><strong>外部链路</strong>：支持本土供应链协同（如与国内物流商对接，实时跟踪物流轨迹）；</li><li><strong>数据驱动</strong>：支持“客户需求→本土供应链响应”关联分析（如某制造企业，根据客户复购率优化库存备货）；</li><li><strong>行业适配</strong>：适合<strong>本土制造、零售、国企</strong>，实施周期3-6个月，适配本土政策与流程。</li></ul><h3>（三）核心能力对比表</h3><p>为更直观呈现差异，我们将核心指标汇总为对比表（分值1-10，越高能力越强）：</p><table><thead><tr><th>维度</th><th>超兔一体云</th><th>SAP</th><th>Dynamics 365</th><th>Oracle CX</th><th>Salesforce</th><th>浪潮CRM</th></tr></thead><tbody><tr><td>全业务覆盖能力</td><td>10</td><td>10</td><td>9</td><td>9</td><td>7</td><td>8</td></tr><tr><td>内部链路自动化</td><td>9</td><td>10</td><td>9</td><td>9</td><td>7</td><td>8</td></tr><tr><td>外部链路连接能力</td><td>8</td><td>10</td><td>9</td><td>9</td><td>8</td><td>8</td></tr><tr><td>数据实时性</td><td>10</td><td>10</td><td>9</td><td>10</td><td>7</td><td>10</td></tr><tr><td>供应链-客户关联分析</td><td>8</td><td>10</td><td>9</td><td>9</td><td>6</td><td>8</td></tr><tr><td>行业适配（中小制造）</td><td>10</td><td>5</td><td>8</td><td>7</td><td>6</td><td>9</td></tr><tr><td>实施复杂度</td><td>2</td><td>9</td><td>5</td><td>8</td><td>5</td><td>6</td></tr><tr><td>性价比</td><td>10</td><td>3</td><td>7</td><td>5</td><td>6</td><td>8</td></tr></tbody></table><h2>三、链路协同流程图对比</h2><p>通过Mermaid流程图，直观展示各品牌的“客户-供应链”闭环逻辑：</p><h3>1. 超兔一体云（全业务一体闭环）</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536807" alt="" title=""/></p><pre><code>graph TD
    A[客户线索] --&gt; B[跟单（需求确认）]
    B --&gt; C[合同生成]
    C --&gt; D{库存检查}
    D --&gt;|充足| E[物流配送]
    D --&gt;|不足| F[触发采购/生产]
    F --&gt; G[采购到货/生产完成]
    G --&gt; E
    E --&gt; H[客户收货确认]
    H --&gt; I[售后支持]
    I --&gt; J[客户复购/推荐]</code></pre><p><strong>特点</strong>：全流程无断点，从线索到复购均在同一系统内完成。</p><h3>2. SAP（全球供应链协同闭环）</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536808" alt="" title="" loading="lazy"/></p><pre><code>graph TD
    A[客户需求（全球销售）] --&gt; B[销售订单生成]
    B --&gt; C[库存检查（全球库存）]
    C --&gt;|不足| D[IBP生产排程（AI模拟）]
    D --&gt; E[采购（SAP Business Network）]
    E --&gt; F[生产执行]
    F --&gt; G[物流配送（全球物流）]
    G --&gt; H[客户交付确认]
    H --&gt; I[供应链控制塔（监控）]
    I --&gt; J[优化生产计划]</code></pre><p><strong>特点</strong>：聚焦全球供应链协同，适合跨国企业的复杂履约场景。</p><h3>3. Dynamics 365（微软生态闭环）</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536809" alt="" title="" loading="lazy"/></p><pre><code>graph TD
    A[客户互动（Outlook）] --&gt; B[销售线索分配]
    B --&gt; C[报价生成（Copilot辅助）]
    C --&gt; D{库存检查（Dual Write）}
    D --&gt;|充足| E[订单确认]
    D --&gt;|不足| F[推荐替代产品]
    E --&gt; G[物流配送（Power BI跟踪）]
    G --&gt; H[客户收货]
    H --&gt; I[售后（Copilot智能回复）]</code></pre><p><strong>特点</strong>：依托微软生态，AI辅助提升链路效率。</p><h2>四、选型建议：匹配企业需求是关键</h2><p>根据企业<strong>规模、行业、现有IT生态</strong>，给出针对性选型建议：</p><table><thead><tr><th>企业类型</th><th>推荐品牌</th><th>核心理由</th></tr></thead><tbody><tr><td>中小制造/商贸企业</td><td>超兔一体云</td><td>全业务覆盖、实施快、性价比高，适合快速闭环</td></tr><tr><td>大型跨国企业（制造/化工）</td><td>SAP</td><td>全球供应链协同、enterprise级稳定性</td></tr><tr><td>中大型企业（微软生态）</td><td>Dynamics 365</td><td>生态整合好、AI辅助、易上手</td></tr><tr><td>高科技/高定制化企业</td><td>Oracle CX</td><td>CX+ERP深度集成，支持复杂配置报价</td></tr><tr><td>轻量级销售团队（SaaS/教育）</td><td>Salesforce</td><td>销售自动化、灵活集成</td></tr><tr><td>本土制造/零售/国企</td><td>浪潮CRM</td><td>本土ERP联动、适配本土供应链</td></tr></tbody></table><h2>五、总结：链路贯通的核心是“匹配”</h2><p>无论选择哪个品牌，“匹配企业当前阶段需求”是核心原则：</p><ul><li>若需<strong>快速闭环</strong>：选超兔一体云（全业务一体，无需集成）；</li><li>若需<strong>全球协同</strong>：选SAP（全球B2B网络，强大的供应链控制塔）；</li><li>若需<strong>生态整合</strong>：选Dynamics 365（微软生态，AI辅助）；</li><li>若需<strong>高定制化</strong>：选Oracle CX（CPQ+ERP集成）。</li></ul><p>最终，“内外链路贯通”不是“选最贵的”，而是“选最适合自己的”——能真正将<strong>客户需求</strong>与<strong>供应链能力</strong>绑定的方案，才是企业的核心竞争力。</p><p>（注：文中功能相关描述均基于公开披露信息，具体功能服务以厂商实际落地版本为准。）</p>]]></description></item><item>    <title><![CDATA[局域网怎么申请SSL证书 才高八斗的杯子_dS2Fpp ]]></title>    <link>https://segmentfault.com/a/1190000047536824</link>    <guid>https://segmentfault.com/a/1190000047536824</guid>    <pubDate>2026-01-12 10:03:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>许多人为局域网（如公司内部OA、智能家居系统）访问时浏览器弹出的“不安全”警告而烦恼。其实，通过为局域网服务配置SSL证书，就能解决这个问题，实现“https”安全访问。</p><h4><strong>一、 明确需求：你需要哪种证书？</strong></h4><p>为局域网申请证书，主要就是以下方法</p><ol><li><strong>公共可信证书（推荐）</strong>  ：由全球可信的证书颁发机构（CA）签发。<strong>优点是</strong>任何设备访问都直接信任，无安全警告。</li></ol><p><strong>对于绝大多数局域网应用，我们追求便捷和安全，因此申请公共可信证书是更优解。</strong></p><h4><em>直接访问JoySSL官网，注册一个账号记得填写注册码230970获取技术支持。</em><a href="https://link.segmentfault.com/?enc=iq%2FYz2iypo7j409UXC%2BoNA%3D%3D.gAsKji9RTdDQKGZHzOlS7O%2FoGsEUd6mgOh6DrJ3lIi9X6S6vzBG3MYOVZMkxY9oqv8Y4F%2Fnv0NPecs1jjWO6KvRC2ag5fUz7r6pz6Al9z1s%3D" rel="nofollow" target="_blank">申请入口</a></h4><p><img width="700" height="400" referrerpolicy="no-referrer" src="/img/bVdna8B" alt="" title=""/></p><h4><strong>二、 如何申请公共可信证书？</strong></h4><p>公共CA默认只为公网域名签发证书。要让其为局域网IP或域名签发，需要验证你对这个地址的所有权。核心步骤如下：</p><ol><li><strong>拥有一个域名</strong>：  <br/>你必须有一个自己注册的公有域名（例如 <code>your-company.com</code>）。这是所有操作的基础。</li><li><p><strong>创建DNS解析记录</strong>：  <br/>登录你的域名管理后台，为你局域网的服务器IP地址创建一个DNS解析记录。有两种常见方式：</p><ul><li><strong>解析域名到内网IP</strong>：例如，创建一个A记录 <code>oa.your-company.com</code>，将其指向你内网服务器的IP地址 <code>192.168.1.100</code>。</li><li><strong>使用泛解析</strong>：创建一个<code>*.internal.your-company.com</code>的泛解析记录，指向你的内网网关或服务器，这样所有子域名都可以使用。</li></ul></li><li><p><strong>选择CA并申请证书</strong>：  <br/>前往各大SSL证书服务商（如JoySSL、阿里云、腾讯云等）平台。选择适合的证书类型（单域名或泛域名）。</p><ul><li>在申请时，<strong>通用名称（CN）</strong>   一栏就填写你刚设置的域名（如 <code>oa.your-company.com</code>）。</li><li>选择<strong>DNS验证</strong>方式。CA会要求你在域名DNS设置里添加一条特定的TXT记录，以验证你拥有该域名的管理权。按照提示操作即可。</li></ul></li><li><strong>验证并获取证书</strong>：  <br/>完成DNS验证后，CA通常几分钟内就会签发证书。你然后在证书管理平台下载颁发的证书文件（一般包含<code>.crt</code>和<code>.key</code>文件）。</li></ol><h4><strong>三、 在服务器上安装部署</strong></h4><p>将下载的证书文件上传到你的局域网服务器上，并在Web服务软件（如Nginx, Apache, IIS）中进行配置，指定证书和私钥的路径，然后重启服务。</p><h4><strong>重要总结</strong></h4><ul><li><strong>核心原理</strong>：<strong>利用公有域名来“代理”验证局域网服务的可信性</strong>。</li><li><strong>最大优点</strong>：一旦部署成功，局域网内任何设备、任何浏览器访问该服务，都会显示安全的小锁标志，无需每台设备手动安装证书。</li><li><strong>最佳选择</strong>：强烈建议使用<strong>泛域名证书</strong>，一个证书可以保护同一个域名下的所有二级子域名，非常适合内部有多项服务的环境。</li></ul>]]></description></item><item>    <title><![CDATA[代码之外周刊（第162期）：AI 时代的职业观 我没有三颗心脏 ]]></title>    <link>https://segmentfault.com/a/1190000047536862</link>    <guid>https://segmentfault.com/a/1190000047536862</guid>    <pubDate>2026-01-12 10:02:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>代码可以构建世界，但生活中的乐趣远不止于此。这里是我一周的精选。</p><p>周刊开源（Github：<a href="https://link.segmentfault.com/?enc=mDuA7X5IUQnXT5%2FrBmXIrw%3D%3D.iat9VvWi3PlwZn8gPhKN5lV%2BQqlLhJYa6dY0P1LyQdNjj21TFpvmblcpdxXoIAx7" rel="nofollow" target="_blank">wmyskxz/weekly</a>），欢迎提交 issue，投稿或推荐精彩内容。</p><h2>题图</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536864" alt="" title=""/></p><p>“天马-1000”集物流运输、应急救援、物资投送等多功能于一体，好比<a href="https://link.segmentfault.com/?enc=mk3S5%2BFXCJ1GIJEu7ell9g%3D%3D.o7wIutfrhXyZkILyafLOEte0XyBxGGEwnQT%2FlX4tiorZuMXw44%2FAHlBfz%2FYJ%2BDZMKaHUIX6QLyEufbp5UyQRi3a6Fb4M9ZgejoRg4PP%2BNUeBRvo410ibjB4rQHvDo7UFY7bmF0PzRUAl%2FC7bKTxAwA%3D%3D" rel="nofollow" title="空中“货拉拉”来了！“天马-1000”无人运输机成功首飞" target="_blank">空中“货拉拉”</a>，是国内首款实现“高原复杂地形适配、超短距起降、货运/空投双模快速切换”的中空低成本运输平台。</p><h2>本周讨论：AI 时代的职业观</h2><p>（本期来源：《预测之书》03_职业、职业观和第二段旅程）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536865" alt="@网络图片" title="@网络图片" loading="lazy"/></p><p>这是一本由 37 位作者共同创作，预测 1000 天以后的世界会变成什么样的书。我读完后，最想分享的是这一篇讨论 AI 与职业的文章给你，我来简单分享一下其中的观点。</p><h3>一道测试题</h3><p>文章开头有一道很有意思的测试题：</p><blockquote>给你10分钟，把一段会议录音整理成会议报告，你会怎么做？</blockquote><ul><li>如果你只是把录音丢给 AI 转写，那只能得 5 分。</li><li>如果你让 AI 查重、分段总结，可以得 6~7 分。</li><li>如果你还能防范 AI 幻觉，给每个重要观点配上原话节选，用多个 AI 交叉验证，那是 8 分。</li><li>9 分是什么水平呢？把相关的往期会议也调出来，看这次讨论跟过去有什么变化，指出达成了哪些新共识。</li></ul><p>这道题出自一套 <strong>AI 商</strong>评估测试。<strong>1000天后，这类测试会像英语四级一样普及，直接影响你能否上岗。</strong></p><p>我觉得这个说法不夸张。AI 会重塑我们的职业和工作方式，冲击可能比以往任何一次技术变革都深刻。</p><h3>历史的教训</h3><p>文章用了一个工业革命时期的例子，很有启发。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536866" alt="@网络图片" title="@网络图片" loading="lazy"/></p><p>那时候，英国煤矿大量雇用童工。为什么？原因很现实：童工的工资只有成人的十分之一到四分之一，但工作时长一样。而且机器把体力活都接管了，孩子和成人的效率差不多。矿井里有些巷道太窄，只有孩子钻得进去。</p><p>结果形成恶性循环：家庭贫穷，被迫让孩子打工；童工多了，又进一步压低工资，家庭更穷。直到后来法规出台，新产业新岗位涌现，人们的生活才慢慢好起来。<strong>整个过程花了近五十年，两代人的职场生涯。</strong></p><p>这段历史提醒我们一个冷冰冰的现实：<strong>技术进步总是优先服务于效率，而不是公平。</strong></p><p>AI 进入职场的逻辑其实很像。AI 比人便宜且不知疲倦，让很多传统技能迅速贬值，也通过催生新产业让一部分人先享受红利。</p><p>乐观派说，AI 创造的新岗位会多于被替代的岗位；悲观派担心 AI 会撕裂社会公平。但文章捅破了一层窗户纸：<strong>从中短周期看，技术更可能先损害普通劳动者的利益，再慢慢释放红利。</strong></p><p>我们是具体的人，关心每月到账的工资，顶多向前看三五年，不想成为先烈。所以现在必须打起精神，提前做准备。</p><h3>基层的变化</h3><p>AI 对基础工作的冲击最直接。</p><p>过去的模式是：毕业后一张白纸进公司，找个师傅，踏踏实实在基层熬三五年，把本事学起来。<strong>这条路正在失效。</strong></p><p>现在，一整套标准化工作流和 AI 智能体，会接手大部分技能交付和经验传承。新员工能否成长，取决于能不能优化这个工作流，而不只是照单全收。</p><p>好消息是，晋升速度会变快。<strong>不再需要熬三五年，半年甚至三个月，谁是 AI 工作流的驾驭者，谁是服从者，就会明显区分开来。</strong></p><h3>中层的变化</h3><p>中层很可能是 AI 时代被裁得最狠的一批人。</p><p>Gartner 预测，到 2026 年，20% 的组织会用 AI 扁平化结构，砍掉一半的中层岗位。</p><p>为什么？管理有四大职能：计划、组织、领导、控制。但现实中，很多中层只是上传下达——用下属的 PPT 向上汇报，把上面的活儿分给下面，年底评绩效分奖金。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536867" alt="@网络图片" title="@网络图片" loading="lazy"/></p><p>现在，AI 来了。只要给定目标和资源，它就能设计路径（计划），根据每个人的特点分配工作（组织），实时追踪进度、预警风险（控制）。</p><p>以能不能用好 AI为分界线，中层会分成两类：<strong>只负责上传下达的容易被替代；能用 AI 解决复杂问题的则会管理更多。</strong></p><p>大量中层消失后，一级一级往上爬的路径会失灵。想涨薪，有两条路：</p><p>一是平行管理更多项目，比如同时带50个剪辑任务、运营300个账号。</p><p>二是沿业务线向前后延伸，接管更长的价值链。比如编辑向前变主播，向后介入产品设计，跑通一整条链路。</p><p><strong>可以把升职加薪改写成伸职加薪——不是往上爬，而是把覆盖的范围不断伸长。</strong></p><h3>高层的变化</h3><p>从高层视角看，AI 一边解决了大量技术难题，一边又抛出更棘手的问题：不同行业怎么整合？技术怎么落地成商业模式？伦理和效率怎么平衡？</p><p>上一代企业家谈管理，问的是稻盛和夫那句作为人，何为正确。今天的领导者还要思考作为人和技术，何为正确。</p><p><strong>当 AI 越来越强，反而对高管的感知力、人文素养和价值判断力提出更高要求。</strong></p><h3>该做什么准备</h3><p>文章给出了一些建议，我觉得挺实在：</p><p><strong>第一，不管你在什么行业，先跟 AI 混熟。</strong> 把它当日常工具用起来，焦虑会降低一大半。</p><p><strong>第二，基层要理解组织的 AI 工作流，并提出优化意见。</strong></p><p><strong>第三，中层要拉长管理幅度，延伸价值链条。</strong></p><p><strong>第四，高层要整合跨领域专家，有人文底蕴，扛得住复杂的价值判断。</strong></p><p><strong>第五，如果有余力，尝试搭配 IP + AI 小闭环。</strong> 哪怕只是一个小账号，也能对冲职业风险。</p><h3>职业观的转变</h3><p>文章还提到了几个有意思的观点。</p><p>（1）职业发展会从爬一座山变成逛一座游乐场。</p><p>过去是选定一个行业，一路往上爬。现在 AI 在让行业加速更迭的同时，也抹平了行业门槛。不同行业之间的边界消失了，变成彼此连通的海域。</p><p>有个理论叫万花筒生涯，说人的职业有三块色片：自我、挑战、平衡。在不同阶段调整权重，就能组合出不同的职业图景。</p><p>（2）自我和关系将变成核心生产力。</p><p>一个真实可信的人际网络，会带你跨过一个又一个行业。未来顺利的人，大多会长期做三件事：线上持续输出有价值的内容，展现活人感，线下建立真实关系。</p><p>（3）赚不内耗和热爱的钱。</p><p>八九十年代赚的是快钱，2000年后赚的是聪明钱。但未来，再快再聪明也不一定卷过 AI。很多人会转而追求在健康的人际关系和真正擅长的工作中深耕，获得不过度透支身心的收入。</p><p>（4）职场不是唯一选择。</p><p>美国大约 35% 的人选择自由职业或副业，疫情期间一度升至 46%。中国目前只有 7%，还有很大上升空间。</p><p><strong>或许更好的自我定位，不再是某公司的某岗位，而是以自己为轴心，设计小型商业闭环，成为可以自由接单的超级个体。</strong></p><h3>最后</h3><p>文章最后引用了荣格的观点：人的一生分两个阶段，前半生繁衍延续生命，中年后踏上第二段旅程，重新关注自我，追问灵魂召唤是什么。</p><p>人类文明也走过类似的路径。发明了蒸汽机、电力、计算机、互联网，每一次技术突破都推动生产力跃升。AI 这个孩子快速吸收人类的知识，眼看要超过它的“父母”。</p><p>从这个角度看，人类似乎完成了前半程的生育任务。在认真对待这个孩子的同时，我们也该踏上第二段旅程：把目光投向自身，理解我们这个物种的真实追求和使命。</p><p>这也许不是 1000 天里会发生的事，但在 1 万天、10 万天之后，我期待它成真。<strong>Be Better~</strong></p><h2>热点新闻</h2><p>1、<a href="https://link.segmentfault.com/?enc=sDVkjLS623hXhUjDeCpTmA%3D%3D.FJnJTOrrANSzpJ95h7x0ORrq6BZV1imZIdQLSR2Loz4%3D" rel="nofollow" title="逛完CES 2026我绷不住了，AI产品一个比一个抽象，简直是华强北年度述职大会" target="_blank">CES 2026 中有意思的产品</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536868" alt="" title="" loading="lazy"/></p><p>每年的 CES，几乎被称作是全球科技的春晚，这个国际消费电子展（Consumer Electronics Show）集结了全世界最具创新意识和形态的产品。几乎都是 AI+ 的产品，选几个有意思的分享一下。</p><p><strong>1. 3D 投影 AI 伴侣</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536869" alt="" title="" loading="lazy"/></p><p>雷蛇推出的 3D 全息 AI 助手 Project AVA，通过物理设备，各式各样的 AI 形象，能够以全息影像形式呈现。目前，我们可以自选五种角色，包括二次元风格的角色和拟人化设计，支持语音感知和情境交互。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536870" alt="" title="" loading="lazy"/></p><p>现在，Project AVA 也正是运行在 Grok 平台上，约等于是把手机屏幕里面的二次元少女，邀请她来到了你身边。</p><p><strong>2. 小猫 AI 喂饭器</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536872" alt="" title="" loading="lazy"/></p><p>瑞士初创公司 AI Tails 在 CES 2026 上，推出了一款新型喂食器，它能利用摄像头分析猫的表情，帮助诊断猫咪的病情。</p><p>通过摄像头捕获的信息，设备可以分析猫咪的食量、水量、体温以及面部表情，检测潜在的健康问题，并且还提供数据云端分析和 App 提示。</p><p>目前，这款产品只适用于猫猫，小狗的版本还有待他们更新。前六个月免费使用 App，但之后需要约 21 美元/月的订阅费。</p><p><strong>3. 乐高智能积木</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536873" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536875" alt="" title="" loading="lazy"/></p><p>虽然是称作 50 年最重要的产品进化，但实际上就是内置芯片的积木，带 NFC/蓝牙/传感器，能做到的就是激活声音和灯光而已。而且还死贵，70-160 美元。</p><p><strong>4. AI 理发</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536876" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536877" alt="" title="" loading="lazy"/></p><p>任何时间、任何地点，打开 App，戴上头套，随便一个人都能拿着推子开始。Glyde 的智能刀片能够感知我们理发的速度、方向和倾斜角度，并实时调整，防止出现不均匀的层次，或过度修剪。速度过快，刀片会自动缩回。倾斜方向错误，修剪量又会减少。</p><p><strong>5. AI 淋浴系统</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536878" alt="" title="" loading="lazy"/></p><p>这套名为 Balance AI 焕肤淋浴系统的装置，实际上就是一面智能浴室镜，它直接安装在我们的淋浴间，通过近距离红外和光谱传感器，把我们淋浴过程，变成一套精准的美容程序。</p><p>系统会根据 AI 评估的结果，实时通过电解调节洗澡水的 pH 值，以及使用 NFC 标记的胶囊来分配不同的维生素和活性护肤品，进一步个性化你淋浴时使用的水流。</p><p><strong>6. AI 马桶</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536879" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536880" alt="▲ 它挂在马桶侧面，配备摄像头和麦克风，用于追踪排便和排尿情况并提供反馈" title="▲ 它挂在马桶侧面，配备摄像头和麦克风，用于追踪排便和排尿情况并提供反馈" loading="lazy"/></p><p>他们把这个设备叫做 Throne（宝座马桶电脑），利用计算机视觉技术来研究用户的便便。通过摄像头和麦克风，监测用户的排便频率、粪便的质地、和大小以及量；来分析用户的肠道健康状况。能最多同时追踪 6 人数据，售价 340 美元，另加每月 6 美元的会员费。</p><p>不过摄像头分析有点变态。特别是，他们使用的分析模型，是从哪里找来的图片、声音还有对应的症状情况来训练的呢？</p><p><strong>7. 叠衣服的机器人</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536881" alt="" title="" loading="lazy"/></p><p>叠衣服/洗碗家用机器人，速度极慢，概念产品。</p><p><strong>8. ROG 三折叠电脑</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536882" alt="" title="" loading="lazy"/></p><p>2026 款的 ROG 幻 16 双屏笔记本，配备了两个全尺寸的 16 寸屏幕，加上键盘就有了 ABCDEF 六个面，堪称「三折叠电脑」。</p><p><strong>9. 柔性屏概念机</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536883" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536884" alt="" title="" loading="lazy"/></p><p>拯救者 Pro Rollable 概念机，作为一台 16 寸机身的游戏本，联想在拯救者 Pro Rollable 上面安装了一块可卷曲的 PureSight OLED 屏幕，内部采用双电机驱动，支持在 16 寸的基础上拓展出 21.5 寸和 24 寸两种屏幕形态。</p><h2>文章</h2><p>1、<a href="https://link.segmentfault.com/?enc=n35JG3NKyNdG820DzmyL4A%3D%3D.o8KkXJKySjIlKGMrgDO2AUDSXzE2J1AuQ6LdEw2eZ6c%3D" rel="nofollow" title="我们专门生产烂软件" target="_blank">我们专门生产烂软件</a>（英文）</p><p>这是一个充满嘲讽意味的网站，里面收集了一些<strong>技术圈最隐蔽的集体犯罪现场</strong>，你可以借此“照镜子”，看看现在的团队到底是在生产软件，还是在生产能写进简历的虚构故事。阅读体验大概是：从“这什么鬼”到“卧槽这不就是我”。</p><hr/><p>2、<a href="https://link.segmentfault.com/?enc=PWiU6ba4xdRvF0tXsbJEFA%3D%3D.aWwOGGRDY3p2pGGvKB3zwEwrZUIBMmD0T4mXCrt5nNKC5cjqFccgQunVZCenwjo%2B" rel="nofollow" title="拿破仑技巧：推迟工作以提高生产力" target="_blank">拿破仑技巧：推迟工作以提高生产力</a>（英文）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536885" alt="" title="" loading="lazy"/></p><p>拿破仑让秘书把所有信件堆三周再拆，结果 80% 的问题自行消失。这就是"拿破仑技巧"：<strong>战略性推迟处理</strong>那些不需要你立即输入的事。<strong>不是拖延</strong>，而是<strong>让问题自我筛选</strong>。适用于邮件、技术故障、项目管理。</p><hr/><p>3、<a href="https://link.segmentfault.com/?enc=n3jgoUNUIk%2B%2BDckysShXfA%3D%3D.WHyPvF%2F4c0ZbrXVNdR8RB4wJO%2BI%2FaFOGSwmkYvIMTocpg9s5JrEQrTdYT941%2BeVs6JiPhiJ6ZRZS3lYOpzcCxg%3D%3D" rel="nofollow" title="什么是代码？" target="_blank">什么是代码？</a>（英文）</p><p>38000 字以上的<strong>长文警告</strong>。虽然是 15 年的旧文，但这是一本关于数字世界的“百科全书式指南”，它不仅解释了技术是如何运作的，更解释了创造这些技术的人是如何思考的，以及软件是如何正在“吞噬”和重塑我们的世界的。</p><p>如果你感兴趣，这里是一个大纲：</p><ol><li>代码的本质与基础：从计算机硬件、二进制、逻辑门讲起，解释了计算机如何通过处理简单的“开/关”信号来执行复杂的任务，以及代码如何通过编译器转化为机器能懂的指令。</li><li>编程语言的江湖：详细介绍了C语言、Java、Python、JavaScript、PHP等主流编程语言的历史、特点及适用场景。文章解释了为什么存在这么多不同的语言，以及它们各自代表的“部落文化”和哲学。</li><li>程序员的文化与生态：描绘了程序员群体的特征（如对效率的痴迷、对会议的厌恶、特有的幽默感），探讨了“10倍程序员”的神话、技术会议的社交功能，以及行业内的性别多样性问题。</li><li>软件开发的流程与工具：科普了集成开发环境（IDE）、SDK、框架（Frameworks）、版本控制（Git/GitHub）、测试（Testing）和调试（Debugging）等现代软件工业的核心工具和流程，解释了“技术债务”和“敏捷开发”等管理概念。</li><li>商业与技术的博弈：通过一个虚构的“穿着灰褐色西装外套的经理”与技术团队互动的叙事线索，展示了非技术管理层与技术人员之间的沟通鸿沟，以及在商业压力下如何平衡代码质量与发布进度（Shipping）。</li></ol><hr/><p>4、<a href="https://link.segmentfault.com/?enc=a2v%2BRHehG1i6OnDMiKy3Tw%3D%3D.P%2Fkp0qRu5tBxprkZ3eeDXAR1YdEvKu51SbX14rUTirB9B3la%2FRATI4UHoXVS7INK" rel="nofollow" title="大多数代码只是缓存" target="_blank">大多数代码只是缓存</a>（英文）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536886" alt="" title="" loading="lazy"/></p><p>作者发现 Claude Code 正在取代他所有付费SaaS应用。核心洞察：<strong>代码本身只是意图的临时缓存</strong>——真正的"源代码"是 Prompt，生成的 Python/JS 只是执行时的二进制。</p><hr/><p>5、<a href="https://link.segmentfault.com/?enc=bWl01peafSsuI0Kvhx7abQ%3D%3D.Tc8WCoSOnwp8H6y1%2FpLNHfGZhirsEk8F0JV8AVuG8m%2FkOgkW7AfDPQTuyOdWUy8d" rel="nofollow" title="终端工作原理交互式可视化" target="_blank">终端工作原理交互式可视化</a>（英文）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536887" alt="" title="" loading="lazy"/></p><p>终端=字符网格+转义序列，只是一个字符网格——像屏幕上有巨大像素的屏幕。网站用可视化的交互方式，用 3~5 分钟的阅读把终端的黑魔法给解释清楚了。</p><hr/><p>6、<a href="https://link.segmentfault.com/?enc=UBEVSq4jGdPEABdp0jLeUw%3D%3D.Q2Tn%2F7AoiOvAvX6ICN4sM19m8OFWF8srzwuK0pI5ttw8501xhteM9JUH8tNbpl4%2B63X1eLCersOMgDV%2BJHANDw%3D%3D" rel="nofollow" title="随时随地 Claude 编程" target="_blank">随时随地 Claude 编程</a>（英文）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536888" alt="" title="" loading="lazy"/></p><p>作者用 Termius + mosh 在 iPhone 上运行 6 个 Claude Code 代理，通过 PreToolUse 钩子实现 push 通知异步开发。这意味着他可以随时随地从口袋里拿出手机，然后输入 Prompt 到远程的 Claude Code，直到 Claude Code 完成任务时通知回手机。</p><p>这不是远程办公，是<strong>开发原子化</strong>——代码产出发生在等咖啡、坐公交、看电视的缝隙里。Amazing...</p><hr/><p>7、<a href="https://link.segmentfault.com/?enc=H7Ys5hpNrgU9e6uB5fgsAw%3D%3D.ua3KzI6ZcRr26YB8tEjIdtVUIRAdYyA2vHDeqwuPTCGOer9M%2FfC%2FW%2Bg2YJveoXof0RqHbD8QIS3BMpYqSD4dEUrSmy7zbMrb7AwdAo2y6W8%3D" rel="nofollow" title="所以你想让自己清空" target="_blank">所以你想让自己清空</a>（英文）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536889" alt="" title="" loading="lazy"/></p><p>这篇文章幽默地将人生陷入停滞的状态比作身陷“沼泽”，并归纳了导致这一困境的三大类心理机制，旨在帮助读者识别并自我解救。</p><ol><li><strong>活化能不足</strong>：指缺乏改变现状的动力。包括在错误方向上努力求认可（阴沟球）、等待完美方案从天而降（等大奖）、因恐惧回避挑战（拒恶龙）、安于不好不坏的现状（平庸陷阱）以及沉溺于焦虑而非解决问题（抚摸问题）。</li><li><strong>糟糕的逃生计划</strong>：指方法论错误。如盲目相信“更努力”却不改策略、幻想未来有无限精力、抱怨不可控因素（怪上帝）、误将需持续维护的“刷牙问题”当成一劳永逸的“文凭问题”，以及试图通过控制他人来解决问题。</li><li><strong>自造沼泽</strong>：指认知偏差导致的作茧自缚。包括设定无意义的苛刻规则、过度关注宏大负面新闻、将个人问题无限放大而视他人建议为儿戏，以及即使条件优越仍坚信满足感不可能存在。</li></ol><p>作者认为，为这些心理陷阱命名能帮助我们识破“我的问题独一无二”的错觉，从而找到脱困的立足点。</p><hr/><p>8、<a href="https://link.segmentfault.com/?enc=LtNws8OwTuKNiNtPp1LfZQ%3D%3D.nmUFfxWi9zrFsagovTwzQfNnNUYrXrNOQyLafPTiInMyv67MR9q4gYmX28LqeywU" rel="nofollow" title="用Claude Code跨书阅读" target="_blank">用Claude Code跨书阅读</a>（英文）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536890" alt="" title="" loading="lazy"/></p><p>这是一次利用 AI 代理进行知识挖掘和创意生成的成功实践。作者展示了如何通过构建工具和赋予 AI 自主权，让其在海量文本中发现人类难以察觉的隐秘联系（例如将史蒂夫·乔布斯的现实扭曲力场与 Theranos 的欺诈联系起来）。</p><p>网站还展示了从 100 本书中挖掘到的跨书本的主题的联系。</p><h2>好奇星人</h2><p>1、<a href="https://link.segmentfault.com/?enc=ZUPSrfHp0BglyQvniAX4dg%3D%3D.QXOrpYuzt56919ooQ4nx8DLcsBbq%2BMlI79LzSCgbFWlmt7OLX39hwaxSphO9LPlpWXVXVxSM0XfS5fgJyrB29vE4f0XH8JBGBYwxopcC0zY%3D" rel="nofollow" title="为什么飞机窗户上有个小洞？" target="_blank">为什么飞机窗户上有个小洞？</a>（英文）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536891" alt="" title="" loading="lazy"/></p><p>飞机窗户上的是三层结构，最外层最厚实，主动承担 90% 以上的压力，中层带有呼吸孔，是安全缓冲层，内层仅防刮擦和装饰，完全不承压。</p><p>小孔的作用就像呼吸孔：</p><ol><li>平衡压力：让中间那层玻璃"偷懒"，只让最外层玻璃承受压力。这样中层玻璃不容易累坏。</li><li>防止起雾：让空气在玻璃层间流动，避免窗户"出汗"看不清。</li><li>帮忙检查：如果外层玻璃裂了，气流会从小孔吹出来，在裂缝处留下痕迹，维修叔叔一眼就能看到。</li></ol><p>简单说：小孔不是漏洞，是工程师留给压力的"逃生通道"，让窗户更安全、更耐用。</p><h2>言论</h2><p>1、</p><blockquote><p>Tailwind的商业模式持续多年。它依赖开发者访问文档，浏览时发现Tailwind Plus并购买。Tailwind Plus 是一个售价 299 美元的预装 UI 组件合集。流量带来发现，发现推动销售。这是一个合理的商业模式，但始终脆弱。</p><p>在过去一年里，<strong>越来越多的开发者开始向AI索要代码，而不是阅读文档</strong>，他们的销售和营销漏斗因此崩溃。</p></blockquote><p>--<a href="https://link.segmentfault.com/?enc=bOkQEy0O0oyssGkVHYxHjQ%3D%3D.XwERxpEQPEduBO8yt%2FhpRV7oOICYTktFlIEkiLoS236WUbr%2Fk9pS%2Fg8QCJECBktnBDZSzAMv0gyUBisFqJBzgQ%3D%3D" rel="nofollow" title="人工智能是一种商业模式压力测试" target="_blank">人工智能是一种商业模式压力测试</a>（英文）</p><p>2、</p><blockquote><p>如果你在软件里添加那种"全新AI功能！"的闪亮图标，你就进入了季度驱动的失败模式。你是在主动乞求竞争对手推出一个清爽简洁的精简版来干掉你。</p><p>一旦公司或项目陷入"刷存在感"式衰败，就彻底没救了。直接动手：从零开始，做一个即插即用的替代品。</p></blockquote><p>--<a href="https://link.segmentfault.com/?enc=wI8%2BfDlg6tRnE9OYabqVPQ%3D%3D.YwOEkO%2BZsnA8NoisWjcnLAfcpA1f%2BPwDoyfhwCkKbVliWyRRUVe9ACv%2FOtHD5QNUoms1L1oZkQnLZB3O%2FGVkTtLmWYQPXPrTX1pOpu38%2B12zUTT%2FY7rQ0EKVMIFcoUmi" rel="nofollow" title="如果用户注意到你的软件，你已经是个失败者了" target="_blank">如果用户注意到你的软件，你已经是个失败者了</a>（英文）</p><p>3、</p><blockquote><p>失败的决心只是野心的表现。继续失败吧</p><p>决心是发现的工具：你不应该计划完全完成你的决心。相反，你应该用它们来指引自己朝某个方向走。</p></blockquote><p>--<a href="https://link.segmentfault.com/?enc=iYqmMYUu%2FYPhgDX3W8G9oQ%3D%3D.qEzmcSjbdQVZzICuE3uO0qN7baW5Pf9z%2Bp%2BBfVPGsuda7%2Fgh6GMAgfxY5Z%2F0ydx2BJ9T4I%2BO44xyyMfg%2B08OLzfPhKdP8l1rEogJG1%2F0at0%3D" rel="nofollow" title="失败决心的悖论" target="_blank">失败决心的悖论</a>（英文）</p><p>4、</p><blockquote><p>我们能生成代码的速度远超阅读速度，但"审查代码"而非"写代码"才是瓶颈。</p><p>我们的编写能力现在已经过时了。我们的思考能力没有。相反，现在我们的思考能力比以前价值10倍，因为实现现在基本免费。</p><p><strong>我们的工作是自动化我们的工作</strong>。</p></blockquote><p>--<a href="https://link.segmentfault.com/?enc=p%2Fz%2FqHoz3k%2BS9vuMMve8dg%3D%3D.xUCPLl1sp7rVoXSQiyVLFHvU%2FIw5gdGi7ubwfFfjG3s2Dzl%2F9X1On%2BeWaV3L7xJ6" rel="nofollow" title="人工智能狂热" target="_blank">人工智能狂热</a>（英文）</p><p>5、</p><blockquote>如果你在餐厅里等 waiter 过来，那是不是意味着你才是 waiter？</blockquote><p>--<a href="https://link.segmentfault.com/?enc=Evvxr1z8H%2F2xmpDlLf3DLw%3D%3D.w6rjmeHBqGtoSCOdwpsG3CaMv%2BYduEl5tKWwuG0lLSY9zJ%2FUpwd%2BjN4EF0tngN%2BB" rel="nofollow" title="你学到过最奇怪的知识是什么？" target="_blank">你学到过最奇怪的知识是什么？</a></p><h2>订阅</h2><p>这个周刊每个礼拜一发布，同步更新在<a href="https://link.segmentfault.com/?enc=blVrbSXnIwhV41HQoO%2FTrA%3D%3D.yPd0Xi0MZp2XYGidg0rFOXF9Bf9A4yaVbUUZpNfdU64%3D" rel="nofollow" target="_blank">个人博客</a>和<a href="https://link.segmentfault.com/?enc=ButwtLQOd0uicEV8AIac%2Bw%3D%3D.otzbmbedI1AkrWIfPYH39Ru3ysOJXeBAnr22maEoi1nlYsYsjDl1P5CWB%2Bz20UC8vo9qj6Fp2Ii2IvuANFXLpWHSLVhf%2FserofIomjViS853WSwt6jbDum%2BF0%2FKHqqe3RYhpzVQouqu84JmW0BYSBvj%2BFYoeb943d5ehViojmeKQ3UlhJ8LhQWcsPHnGHzVRDTv3ZhVkloY7Xn2XrCMQV%2BNDudmGC9I5olCa%2FlSNcDs%3D" rel="nofollow" target="_blank">微信公众号</a></p><p>微信搜索"我没有三颗心脏"或者扫描二维码，即可订阅。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536892" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[MIAOYUN | 每周AI新鲜事儿 260109 MIAOYUN ]]></title>    <link>https://segmentfault.com/a/1190000047536975</link>    <guid>https://segmentfault.com/a/1190000047536975</guid>    <pubDate>2026-01-12 10:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>2026年初AI领域动态密集，大模型方面，九坤、华为、腾讯等企业相继开源代码生成、多模态、3D动作等领域模型，在性能、部署灵活性上各有突破；AI Agent与工具持续升级，Notion 3.0、Claude Code新版本降低使用门；微信推出小程序扶持计划、ChatGPT上线健康管理功能；DeepSeek的mHC方案、智元SOP框架获技术突破；市场侧，英特尔、AMD、NVIDIA等发布新PC处理器与AI平台，强化算力支撑；八部门印发“AI+制造”专项行动意见，推动产业融合，一起来回顾本周的AI新鲜事儿吧！</p><h2>AI 大模型</h2><p><strong>九坤投资开源代码大语言模型「IQuest-Coder-V1」系列，包含多参数版本</strong></p><p>1月1日，北京九坤投资IQuest团队开源了专注于代码生成、理解与软件工程任务的「IQuest-Coder-V1」系列大模型，包含7B、14B、40B等多个参数规模，且每个规模均有Instruct和Thinking版本，40B参数还额外提供Loop版本以提升参数利用效率，其架构具备分组查询注意力、原生128K长上下文、76800词表大小等特性，采用独特的“代码流多阶段训练”策略，从代码演化过程中学习，在SWE-Bench Verified等多项榜单成绩亮眼，40B-Loop版本以81.4%的成绩超过「Claude Opus-4.5」等模型，且支持单卡H20推理，Int4版本可在3090/4090 GPU部署。</p><p><strong>融资35亿后Kimi神秘模型「Kiwi-do」现身，疑为「K2-VL」多模态模型</strong></p><p>1月5日消息，月之暗面Kimi融资35亿后，神秘模型「Kiwi-do」现身，该模型训练数据截止到2025年1月，在LM竞技场和VPCT视觉屋里理解测试中表现亮眼，被推测可能是Kimi之前提到的「K2-VL」多模态模型。Kimi计划在今年一季度发布多模态新模型，目标是超越现有AGI技术，增强模型的能力和用户体验。此次融资后，Kimi的现金储备达到100亿人民币，未来将继续加大算力扩展投资，以促进K3模型的研发和市场竞争力，同时聚焦Agent商业化实现营收量级增长。</p><p><strong>华为开源昇腾原生7B多模态模型「openPangu-VL-7B」</strong></p><p>1月5日，华为开源昇腾原生7B多模态模型「openPangu-VL-7B」，该模型兼顾轻量化与高性能，在单张Ascend Atlas 800T A2卡上720P图像首字推理时延仅160毫秒、支持5FPS实时推理，完成3T+tokens无突刺集群长稳训练，凭借适配昇腾的高性能视觉编码器、样本均衡损失设计、带填充定位数据格式等核心技术，在通用视觉问答、OCR、文档理解、视觉定位等核心任务的开源榜单中表现突出，力压同量级模型，能实现樱桃番茄计数、年报截图转markdown等实用功能，为端侧开发、个人开发者及昇腾生态提供了新选择与实践参考。</p><p><strong>MiroMind团队发布自研搜索智能体模型「MiroThinker 1.5」</strong></p><p>1月6日，陈天桥联合发起的MiroMind团队发布自研搜索智能体模型「MiroThinker 1.5」，其30B/235B低参数规模凭借内化为训练机制的Interactive Scaling及时序敏感训练沙盒技术，实现高智效比，单条调用成本仅为Kimi-K2-Thinking的1/20，多项评测跻身全球第一梯队，实测中精准预测世界杯、GTA6发售及A股连板股，逻辑严谨且推理可视。</p><p><strong>Lightricks开源的音视频一体模型「LTX-2」在ComfyUI中原生支持</strong></p><p>1月6日，Lightricks开源的音视频一体模型「LTX-2」在ComfyUI中原生支持，该模型可单次运算同步生成动作、对话、音效与音乐，支持文生视频、图生视频及Canny/深度图/姿态图控制生视频，具备关键帧驱动、原生超分等功能，资源占用低且可在消费级硬件高效运行，用户更新ComfyUI至最新版后，通过模板库对应工作流即可使用。</p><p><strong>腾讯混元开源十亿参数量级文生3D动作大模型「HY-Motion 1.0」</strong></p><p>1月7日消息，腾讯混元近期开源十亿参数量级文生3D动作大模型「HY-Motion 1.0」，基于Diffusion Transformer（DiT）架构，通过“预训练+高质量微调+强化学习对齐”三阶段训练体系，依托3000+小时高质量动作数据，可生成覆盖基础移动、体育竞技等六大领域200+类别的标准化骨骼动画，动作流畅且指令遵循能力强（SSAE指标达78.6%），能无缝适配Unreal Engine、Unity等主流3D制作管线，助力游戏、影视等领域降本提效。</p><p><strong>蚂蚁集团联合浙江省卫健委开源「AntAngelMed」医疗大模型</strong></p><p>1月7日，蚂蚁集团联合浙江省卫健委开源「AntAngelMed」医疗大模型，该模型基于百灵高效MOE基座模型「Ling-flash-base-2.0」训练而成，总参数100B，激活参数6.1B，登顶OpenAI HealthBench开源医疗模型评测第一，通过精细的三阶段训练兼具专业性与人文关怀，其基座模型的体验地址已在HuggingFace等平台公布。</p><p><strong>NVIDIA发布全新开放模型、数据和工具以推动各行业AI发展</strong></p><p>1月8日，NVIDIA发布全新开放模型、数据和工具，涵盖AI智能体「Nemotron」系列（性能提升10倍的Nemotron Speech、提升检索能力的Nemotron RAG、增强安全性的Nemotron Safety），适用于物理AI与机器人的「Cosmos」开源世界基础模型（含提升视觉感知推理的Cosmos Reason 2、生成大规模合成视频的Cosmos Transfer 2.5与Predict 2.5，以及人形机器人专用的Isaac GR00T N1.6模型、视频搜索总结的Blueprint），及推动推理型辅助驾驶开发的「Alpamayo」系列（含辅助驾驶VLA推理模型Alpamayo 1、开源仿真框架AlpaSim），还有弥合数字药物研发与现实医疗差距的「Clara AI」模型（含设计蛋白质的La-Proteina、保障药物合成的ReaSyn v2、预测药物与人体相互作用的KERMT、预测RNA三维结构的RNAPro），推动各行业AI发展。</p><h2><strong>AI Agent</strong></h2><p><strong>Notion 3.0升级AI Agent，简化复杂操作，助力高效办公</strong></p><p>1月5日消息，Notion推出3.0大版本更新，升级为「Notion AI Agent」，内置GPT-5、Claude Sonnet 4等最新大模型，支持Agent个性化定制及扩展Lovable、Perplexity等应用的MCP列表（商业版订阅可用，提供14天试用），核心以自然语言交互降低使用门槛，用户可通过其快速完成数据库搭建、自动化设置、AI填充、批量操作等任务，还能组合功能实现剪藏内容管理、个人财务管理等场景需求，虽商业版每月20美元（年付优惠）价格不低，但大幅降低了新用户上手难度。</p><p><strong>Anthropic正式上线「Claude Code」官方桌面端</strong></p><p>1月7日，Anthropic正式上线「Claude Code」官方桌面端，在原有CLI版本基础上新增原生GUI界面，支持Windows/macOS双系统，具备多会话并行、Git隔离工作区、独立自动更新等核心功能，可灵活切换本地与云端会话，适配系统环境变量，为开发者提供更直观、低干扰的本地AI编程体验。</p><p><strong>80+项改动焕新，Claude Code 2.1系列版本密集发布</strong></p><p>1月7日，「Claude Code 2.1.0」版本发布，1月8日又推出「2.1.1」小修复版本，此次更新包含80多项改动，涵盖30+新功能（如Skills自动热重载、回复语言配置、自动续写避免tokenlimit错误等）、40+bug修复（含中文输入空行问题、敏感信息泄露等安全漏洞）及10+性能优化，还带来了多终端Shift+Enter换行、任意位置斜杠命令触发、通配符Bash权限等实用改进，强化了Vim模式操作，整体旨在打造完整开发环境。</p><h2><strong>AI 工具</strong></h2><p><strong>腾讯AI工作台ima.copilot更新推出「PPT生成」功能</strong></p><p>1月5日，腾讯AI工作台ima.copilot更新至2.1.3版本，响应用户需求推出「PPT生成」功能，可将资料自动转为数据图、匹配相应图案元素并放大加亮重点数据，还支持简洁商务风、简约轻松风、深色科技风等不同风格选择，适用于学术汇报、职场总结、提案推广等场景。</p><p><strong>微信上线「AI小程序成长计划」，免费1亿Token+云开发资源扶持开发者</strong></p><p>1月5日，微信推出2026全年有效的「AI应用及线上工具小程序成长计划」，为开发者提供免费云开发资源（新开发者6个月免费环境、老开发者大额抵扣券）、1亿腾讯混元2.0文生文Token加1万张文生图额度的AI算力支持、免费We分析专业版一年及专属流量激励，还开放全终端虚拟支付与会员订阅（限时优惠费率）、广告变现免开发智能接入等商业化支持，《猜盐》《传图加画框》等多款AI小程序已展现出圈潜力，符合条件的个人及企业开发者可通过小程序后台参与该计划。</p><p><strong>OpenAI推出专为健康管理设计的新功能「ChatGPT Health」</strong></p><p>1月8日，OpenAI推出专为健康管理设计的「ChatGPT Health」新功能，允许用户安全连接医疗记录和健康应用，如Apple健康等健康与健身营养类App，整合分散的健康数据，为用户提供体检报告解读、就医问题准备、饮食运动计划制定、保险方案对比等服务，其开发有60国260多位执业医生参与并经HealthBench评估框架检验，采用独立空间隔离存储、加密审查等安全措施且健康对话不用于模型训练，强调仅为医疗辅助工具不可替代医生。</p><h2><strong>技术突破</strong></h2><p><strong>DeepSeek提出「mHC」残差连接新方案，破解大模型训练不稳定难题</strong></p><p>1月1日消息，DeepSeek团队发布新论文并提出「Manifold-Constrained Hyper-Connections」（mHC），一种能稳定训练并提升大模型可扩展性的残差连接新方案，针对Hyper-Connections（HC）结构存在的训练不稳定、信号失真、梯度爆炸及内存开销大等问题，通过Sinkhorn-Knopp算法将残差映射矩阵投影到双随机矩阵流形以恢复恒等映射性质，还对输入/输出映射做正值约束，仅引入6.7%训练时间开销，在27B参数模型的8个下游任务中全面超越HC与Baseline模型，且性能增益随模型规模扩大保持稳定甚至增强，同时通过多项优化实现高效训练，为大模型拓扑架构设计及下一代基础架构演进提供了新方向。</p><p><strong>智元具身研究中心提出「SOP（可扩展在线后训练）框架」</strong></p><p>1月6日，智元具身研究中心提出「SOP（可扩展在线后训练）框架」，是业界首次深度整合在线、分布式和多任务机制的物理世界后训练范式，通过“分布式机器人集群并行学习+云端集中在线更新+动态采样”闭环，破解传统后训练迭代慢、易遗忘等问题，在杂货补货、叠衣服等任务中表现超离线方案，四机配置训练速度达单机2.4倍，3小时在线学习即可实现约30%性能提升，为通用机器人大规模真实世界部署提供关键支撑。</p><h2><strong>市场动态</strong></h2><p><strong>英特尔发布首款基于Intel 18A制程的第三代酷睿Ultra处理器AI PC平台</strong></p><p>1月6日，英特尔发布首款基于Intel 18A制程的第三代酷睿Ultra处理器AI PC平台，涵盖移动端Ultra X9/X7及主流型号，集成锐炫显卡，旗舰款最高配16个CPU核心、12个Xe 核心和50 TOPS NPU算力，多线程性能提升60%、游戏性能提升77%，最长续航达27小时，将支撑200+款PC产品设计；该处理器首次同步发布边缘版并获嵌入式与工业级认证，可支持具身智能等多领域，消费级笔记本当日开启预售、1月27日全球面市，边缘系统将于2026年第二季度面市。</p><p><strong>AMD发布全液冷「Helios机架平台」等多项产品与计划</strong></p><p>1月6日，AMD在CES展会发布多项重磅产品与计划，包扩全液冷设计的「Helios机架平台」（搭载MI455X GPU等核心硬件，拥有2.9 exaflops算力，31TB HBM4显存、43TB/s带宽）、性能较前代提升10倍的「MI455X GPU」、能效与线程密度大幅提升的「EPYC Venice Zen 6 CPU」；计划2027年推出2nm制程「MI500」系列，目标4年AI芯片性能涨1000倍，未来5年算力达10YottaFlops。AI PC方面，Q1推出搭载Ryzen AI 400系列处理器的产品，Q2上市Ryzen AI Halo迷你PC；同时发布Ryzen AI Max +系列处理器及全套数据中心解决方案。</p><p><strong>NVIDIA发布「Vera Rubin」平台，6芯协同打造超凡AI超级计算机</strong></p><p>1月6日，NVIDIA在CES 2026期间，正式发布「Vera Rubin」平台，该平台由Vera CPU、Rubin GPU、NVLink 6交换机、ConnectX-9 SuperNIC、BlueField-4 DPU和Spectrum-6以太网交换机六款全新芯片组成，通过引入新一代NVLink互连技术等五项创新技术，实现了软硬件极致协同设计，不仅将推理token成本低至前代Blackwell平台的十分之一，MoE模型训练GPU用量仅为前代四分之一，能效与持续运行时间提升5倍，同时加速代理式AI、高级推理及超大规模MoE模型推理。</p><p><strong>工信部等八部门联合印发《“人工智能+制造”专项行动实施意见》</strong></p><p>1月8日消息，工信部等八部门联合印发《“人工智能+制造”专项行动实施意见》（2025年12月25日印发），提出到2027年实现人工智能关键核心技术安全可靠供给、产业规模与赋能水平居世界前列的目标，明确推动3-5个制造业通用大模型深度应用、推出1000个工业智能体等具体指标；围绕创新筑基、赋智升级等7大重点任务细化21项措施，涵盖强化算力供给、开发行业模型、拓展制造业全流程应用场景、推动智能装备迭代、培育优质企业、壮大开源生态、筑牢安全保障等，还附相关转型指引与应用指南，以促进AI与制造业“双向赋能”，支撑制造强国等建设。</p>]]></description></item><item>    <title><![CDATA[C#.NET ConcurrentBag<T> 设计原理与使用场景 唐青枫 ]]></title>    <link>https://segmentfault.com/a/1190000047536759</link>    <guid>https://segmentfault.com/a/1190000047536759</guid>    <pubDate>2026-01-12 09:03:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h3>简介</h3><p><code>ConcurrentBag&lt;T&gt;</code> 是 <code>System.Collections.Concurrent</code> 命名空间下的线程安全的无序集合，专为 “多线程同时添加 / 移除元素” 设计，核心特点是基于线程局部存储（<code>TLS</code>）优化，在 “同一线程频繁添加和移除元素” 的场景下性能最优，是 <code>.NET</code> 中处理无序线程安全集合的核心工具。</p><h3>核心定位与价值</h3><p>在多线程场景中，普通的 <code>List&lt;T&gt;</code> 非线程安全（多线程操作会抛出异常或数据损坏），而 <code>lock</code> 包裹的 <code>List&lt;T&gt;</code> 存在锁竞争问题（性能低）。<code>ConcurrentBag&lt;T&gt;</code> 的核心价值：</p><ul><li>无锁核心路径：通过线程局部存储（<code>TLS</code>）让每个线程优先操作自己的私有数据段，减少跨线程锁竞争；</li><li>无序存储：不保证元素的顺序（插入顺序≠遍历顺序），牺牲顺序换取性能；</li><li>线程安全：所有操作（<code>Add/TryTake</code> 等）均线程安全，无需手动加锁；</li><li>适配特定场景：尤其适合 “生产者和消费者为同一线程” 的场景（如线程池线程自产自销）。</li></ul><h3>核心特点</h3><table><thead><tr><th>特性</th><th>ConcurrentBag&lt;T&gt;</th><th>ConcurrentQueue&lt;T&gt;</th><th>ConcurrentStack&lt;T&gt;</th><th>典型使用场景</th></tr></thead><tbody><tr><td>顺序保证</td><td>无序（完全不保证）</td><td>FIFO</td><td>LIFO</td><td>不关心顺序的场景</td></tr><tr><td>线程安全</td><td>是</td><td>是</td><td>是</td><td>多线程并发</td></tr><tr><td>元素重复取出风险</td><td>可能（同一个线程可能先取后放）</td><td>不可能</td><td>不可能</td><td>允许“偷取”工作</td></tr><tr><td>内存使用</td><td>较低（分段 + 线程本地袋）</td><td>中等</td><td>中等</td><td>大量小对象</td></tr><tr><td>支持 Peek</td><td>不支持</td><td>支持</td><td>支持</td><td>—</td></tr><tr><td>典型模式</td><td>工作窃取（work-stealing）</td><td>生产者-消费者</td><td>后进先出任务栈</td><td>并行任务池、负载均衡</td></tr></tbody></table><h3>内部实现原理</h3><p><code>ConcurrentBag</code> 的高性能来源于线程本地存储 + 工作窃取的设计：</p><ul><li>每个线程拥有一个私有小袋（<code>bag</code>）（通常是链表或数组）</li><li>线程 <code>Add/Take</code> 时优先操作自己的私有袋（几乎无锁）</li><li>当自己袋子为空时，会去 <strong>“偷”</strong> 其他线程的袋子（ <code>work-stealing</code>）</li><li><p>这种设计导致：</p><ul><li>同一个线程插入的元素，很可能被同一个线程先取出（局部性好）</li><li>但跨线程看，完全无序，而且可能出现同一个元素被同一个线程先取后放的情况</li></ul></li><li>轻量级锁：仅在跨线程窃取元素时加锁，核心路径（同线程存取）无锁，性能远超全局锁的 <code>List&lt;T&gt;</code>。</li></ul><pre style="display:none;"><code class="mermaid">graph TD
    A[线程A] --&gt; A_Queue[本地队列A: 1, 3, 5]
    B[线程B] --&gt; B_Queue[本地队列B: 2, 4]
    C[线程C] --&gt; C_Queue[本地队列C: 6]
    
    D[全局队列] --&gt; |工作窃取| A_Queue
    D --&gt; |工作窃取| B_Queue
    D --&gt; |工作窃取| C_Queue</code></pre><h3>核心 API</h3><h4>核心构造函数</h4><ul><li><code>ConcurrentBag&lt;T&gt;()</code>: 创建空的线程安全集合</li><li><code>ConcurrentBag&lt;T&gt;(IEnumerable&lt;T&gt;)</code>: 用指定集合初始化<code>ConcurrentBag&lt;T&gt;</code></li></ul><h4>核心方法 / 属性</h4><ul><li><code>Add(T item)</code>: 向集合添加元素（线程安全），无返回值</li><li><code>TryTake(out T result)</code>: 尝试从集合移除并返回任意元素：成功返回<code>true</code>，集合为空返回 <code>false</code></li><li><code>Count</code>: 获取集合中元素的数量（线程安全，但值为瞬时快照）</li><li><code>IsEmpty</code>: 判断集合是否为空（线程安全，瞬时快照）</li><li><code>GetEnumerator()</code>: 返回遍历集合的枚举器（遍历的是瞬时快照，不保证后续元素不变）</li></ul><h4>常用操作</h4><pre><code class="csharp">var bag = new ConcurrentBag&lt;string&gt;();

// 插入（极快）
bag.Add("任务A");
bag.Add("任务B");

// 尝试取出（非阻塞）
if (bag.TryTake(out var item))
{
    Console.WriteLine($"取出: {item}");
}

// 尝试偷取（TryPeek 不存在！）
if (bag.TryTake(out var stolen)) { /* 处理 */ }

// 计数（注意：有一定开销）
int count = bag.Count;

// 清空（不常用）
bag.Clear();

// 检查是否为空
bool isEmpty = bag.IsEmpty;</code></pre><h3>用法示例</h3><h4>多线程添加与消费</h4><pre><code class="csharp">using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

class ConcurrentBagBasicDemo
{
    static void Main()
    {
        // 创建线程安全的ConcurrentBag
        var bag = new ConcurrentBag&lt;int&gt;();

        // 1. 多线程添加元素（4个线程，每个添加5个元素）
        Parallel.For(0, 4, threadId =&gt;
        {
            for (int i = 1; i &lt;= 5; i++)
            {
                int value = threadId * 100 + i;
                bag.Add(value);
                Console.WriteLine($"线程{threadId}：添加 {value}");
            }
        });

        Console.WriteLine($"\n集合总元素数：{bag.Count}\n");

        // 2. 多线程消费元素（直到集合为空）
        Parallel.For(0, 2, threadId =&gt;
        {
            while (!bag.IsEmpty)
            {
                if (bag.TryTake(out int value))
                {
                    Console.WriteLine($"线程{threadId}：取出 {value}");
                }
                // 避免空循环占用CPU
                Task.Delay(10).Wait();
            }
        });

        Console.WriteLine($"\n最终集合是否为空：{bag.IsEmpty}");
    }
}</code></pre><p>输出结果</p><pre><code>线程0：添加 1
线程1：添加 101
线程0：添加 2
线程2：添加 201
...（添加顺序无序）
集合总元素数：20

线程0：取出 2
线程1：取出 101
线程0：取出 1
线程1：取出 201
...（取出顺序≠添加顺序，且优先取当前线程添加的元素）
最终集合是否为空：True</code></pre><p>核心现象：</p><ul><li>添加和取出的顺序完全无序，符合 <code>ConcurrentBag&lt;T&gt;</code> “无序集合” 的特性；</li><li>同一线程优先取出自己添加的元素（<code>TLS</code> 优化的体现）。</li></ul><h4>并行处理大量独立小文件</h4><pre><code class="csharp">var files = Directory.GetFiles("big_folder", "*.txt");
var bag = new ConcurrentBag&lt;string&gt;(files);

Parallel.ForEach(bag, new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount },
    file =&gt;
    {
        ProcessFile(file);
    });</code></pre><h4>对象池实现</h4><pre><code class="csharp">public class ObjectPool&lt;T&gt;
{
    private readonly ConcurrentBag&lt;T&gt; _objects;
    private readonly Func&lt;T&gt; _objectGenerator;

    public ObjectPool(Func&lt;T&gt; objectGenerator)
    {
        _objects = new ConcurrentBag&lt;T&gt;();
        _objectGenerator = objectGenerator;
    }

    public T Get()
    {
        return _objects.TryTake(out T item) ? item : _objectGenerator();
    }

    public void Return(T item)
    {
        _objects.Add(item);
    }
}

// 使用示例
var pool = new ObjectPool&lt;StringBuilder&gt;(() =&gt; new StringBuilder());
var sb = pool.Get();
try
{
    sb.Append("Hello");
    Console.WriteLine(sb.ToString());
}
finally
{
    pool.Return(sb);
}</code></pre><h3>关键特性与适用场景</h3><h4>核心特性</h4><ul><li>顺序性: 无序（<code>Add</code> 顺序≠遍历 / <code>Take</code> 顺序）</li><li>线程安全: 所有操作线程安全，无需手动加锁</li><li>性能:    同线程存取：极高（无锁）；跨线程窃取：中（轻量级锁）</li><li>空值支持:    允许添加 <code>null</code>（若T为引用类型）</li><li>遍历特性:    遍历的是 “瞬时快照”，遍历过程中集合可修改，不抛出异常</li><li>容量: 无固定容量限制，动态扩容</li></ul><h4>最佳适用场景</h4><ul><li>线程自产自销：线程池线程添加元素后，自己快速取出处理（如线程本地缓存）；</li><li>无序批量处理：多线程收集数据，无需保证顺序（如日志收集、临时数据存储）；</li><li>低锁竞争场景：大多数操作由同一线程完成，跨线程操作少。</li><li>对象池实现：重用对象减少分配</li><li>并行计算中间结果收集</li><li>生产者即消费者模式</li></ul><h4>不适用场景</h4><ul><li>需要有序存取：如 <code>FIFO</code>（用 <code>ConcurrentQueue&lt;T&gt;</code> ）、<code>LIFO</code>（用<code>ConcurrentStack&lt;T&gt;</code>）；</li><li>高跨线程窃取：多线程频繁添加，且其他线程频繁取走（此时锁竞争多，性能低于<code>ConcurrentQueue&lt;T&gt;</code> ）；</li><li>索引访问：<code>ConcurrentBag&lt;T&gt;</code> 无索引（如 <code>bag[0]</code> ），需索引访问用<code>ConcurrentDictionary&lt;TKey, TValue&gt;</code> 或手动封装。</li></ul><h3>最佳实践</h3><h4>优先用于生产者-消费者同线程场景</h4><pre><code class="csharp">   // 同一线程添加和取出
   var threadLocalBag = new ConcurrentBag&lt;WorkItem&gt;();
   
   void Process()
   {
       threadLocalBag.Add(CreateWork());
       if (threadLocalBag.TryTake(out var work))
       {
           Execute(work);
       }
   }</code></pre><h4>避免用于生产者-消费者分离场景</h4><pre><code class="csharp">   // 生产者消费者分离
   var sharedBag = new ConcurrentBag&lt;Data&gt;();
   
   // 生产者线程
   Task.Run(() =&gt; sharedBag.Add(produce()));
   
   // 消费者线程
   Task.Run(() =&gt; 
   {
       if (sharedBag.TryTake(out var data))
       {
           consume(data);
       }
   });</code></pre><h3>总结</h3><p><code>ConcurrentBag&lt;T&gt;</code> 是 <code>.NET</code> 并发集合中的特殊工具：</p><ul><li>✅ 在生产者即消费者场景中性能卓越</li><li>✅ 内置工作窃取机制</li><li>✅ 无锁实现减少竞争</li><li>✅ 线程本地存储优化</li></ul><p>最佳适用场景：</p><ul><li>线程处理自己生成的任务</li><li>对象池实现</li><li>并行计算的结果收集</li><li>工作窃取模式的任务分发</li></ul>]]></description></item><item>    <title><![CDATA[跟老卫学仓颉编程语言开发：流程控制 waylau ]]></title>    <link>https://segmentfault.com/a/1190000047536762</link>    <guid>https://segmentfault.com/a/1190000047536762</guid>    <pubDate>2026-01-12 09:03:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>仓颉程序是从上而下顺序执行的，在此过程中，可以通过分支、循环等流程控制方式，更好的实现相应的功能。</p><p>在仓颉编程语言中，条件表达式分为<code>if</code>表达式和<code>if-let</code>表达式两种，它们的值与类型需要根据使用场景来确定。循环表达式有四种：<code>for-in</code>表达式、<code>while</code>表达式、<code>do-while</code>表达式和<code>while-let</code>表达式，它们的类型都是Unit、值为()。其中<code>if-let</code>表达式和<code>while-let</code>表达式都与模式匹配相关。</p><p>在仓颉程序中，由一对大括号“{}”包围起来的一组表达式，被称为“代码块”，它将作为程序的一个顺序执行流，其中的表达式将按编码顺序依次执行。如果代码块中有至少一个表达式，我们规定此代码块的值与类型等于其中最后一个表达式的值与类型，如果代码块中没有表达式，规定这种空代码块的类型为Unit、值为()。</p><p><strong>注</strong>：代码块本身不是一个表达式，不能被单独使用，它将依附于函数、条件表达式和循环表达式等执行和求值。</p><p>本节示例可以在“flow_control_demo”应用下找到。</p><h3>分支</h3><p>在仓颉里，分支主要通过if表达式来控制。if 表达式的基本形式为：</p><pre><code>if (条件) {
  分支 1
} else {
  分支 2
}</code></pre><p><img referrerpolicy="no-referrer" src="https://communityfile-drcn.op.hicloud.com/FileServer/getFile/cmtybbstemp/20260112/cmtybbs/042/413/002/0000000000042413002.20260112080434.55350497160755870323154212222898:20260112090435:2800:75D19762EF79AD245033C7C912AA4E0D74AA892DED2944504F9EC869278C2A74.png" alt="" title=""/></p><p>其中“条件”是布尔类型表达式，“分支 1”和“分支 2”是两个代码块。if 表达式将按如下规则执行：</p><ol><li>计算“条件”表达式，如果值为true则转到第2步，值为false则转到第3步。</li><li>执行“分支 1”，转到第4步。</li><li>执行“分支 2”，转到第4步。</li><li>继续执行if表达式后面的代码。</li></ol><p>以下是if表达式进行分支控制的示例：</p><pre><code class="rust">/// 流程控制示例
import std.random.*

main() {
    // 生成随机数
    let number: Int8 = Random().nextInt8()
    
    if (number % 2 == 0) {
        println("${number} is an even number")
    } else {
        println("${number} is an odd number")
    }
}</code></pre><p>在这段程序中，使用仓颉标准库的random包生成了一个随机整数，然后使用if表达式判断这个整数是否能被2整除，从而判断该数是偶数或奇数。</p><p>上述例子执行多次之后可能输出内容如下：</p><pre><code>101 is an odd number

-58 is an even number

-69 is an odd number</code></pre><p>在上述程序中有条件if语句，这个语法在很多其它语言中很常见，重点是：条件表达式需要用小括号包裹。</p><p>仓颉还是支持传统的else-if语法的，实现多重条件的处理。示例如下：</p><pre><code class="rust">// 处理多重条件
let number2: Int8 = Random().nextInt8();
if (number2 % 4 == 0) {
    println("${number2} is divisible by 4");
} else if (number2 % 3 == 0) {
    println("${number2} is divisible by 3");
} else if (number2 % 2 == 0) {
    println("${number2} is divisible by 2");
} else {
    println("${number2} is not divisible by 4, 3, or 2");
}</code></pre><p>上述例子执行之后输出内容如下：</p><pre><code>-115 is not divisible by 4, 3, or 2

22 is divisible by 2

27 is divisible by 3

92 is divisible by 4</code></pre><h3>循环</h3><p>多次执行同一段代码是很常用的，仓颉为此提供了4种循环：<code>for-in</code>表达式、<code>while</code>表达式、<code>do-while</code>表达式和<code>while-let</code>表达式。</p><h4>1. while</h4><p>如果你需要一个条件来循环，当该条件为true时，继续循环，条件为false，跳出循环，那么while就非常适用。while表达式的基本形式为：</p><pre><code>while (条件) {
  循环体
}</code></pre><p>其中“条件”是布尔类型表达式，“循环体”是一个代码块。while 表达式将按如下规则执行：</p><ol><li>计算“条件”表达式，如果值为true则转第2步，值为false转第3步。</li><li>执行“循环体”，转第1步。</li><li>结束循环，继续执行while表达式后面的代码。</li></ol><p>示例如下：</p><pre><code class="rust">// while循环
var number3 = 1;
while (number3 != 4) {
    println("number3: ${number3}");
    number3 += 1;
}</code></pre><p>该while循环，只有当number不等于4时，才执行，否则就立刻跳出循环。因此在上述代码中，它会先从1开始，满足条件，进行循环；然后是2，满足条件，进行循环；最终到4的时候，不满足条件，跳出while循环。</p><p>上述例子执行之后输出内容如下：</p><pre><code>number3: 1
number3: 2
number3: 3</code></pre><p><img referrerpolicy="no-referrer" src="https://communityfile-drcn.op.hicloud.com/FileServer/getFile/cmtybbstemp/20260112/cmtybbs/042/413/002/0000000000042413002.20260112080520.73978522458752011627592099553244:20260112090521:2800:4BC44D747A6889FF32CB27DD3D65E182AD0CB86A6F4DD9AA14DF671F82338524.jpg" alt="" title="" loading="lazy"/></p><h4>2. <code>for-in</code></h4><p><code>for-in</code>表达式是最常用的循环结构，常用来遍历一个线性数据结构（比如数组、集合）。<code>for-in</code>表达式的基本形式为：</p><pre><code>for (迭代变量 in 序列) {
  循环体
}</code></pre><p>其中“循环体”是一个代码块。“迭代变量”是单个标识符或由多个标识符构成的元组，用于绑定每轮遍历中由迭代器指向的数据，可以作为“循环体”中的局部变量使用。“序列”是一个表达式，它只会被计算一次，遍历是针对此表达式的值进行的，其类型必须扩展迭代器接口<code>Iterable&lt;T&gt;</code>。for-in表达式将按如下规则执行：</p><ol><li>计算“序列”表达式，将其值作为遍历对象，并初始化遍历对象的迭代器。</li><li>更新迭代器，如果迭代器终止，转第4步，否则转第3步。</li><li>将当前迭代器指向的数据与“迭代变量”绑定，并执行“循环体”，转第2步。</li><li>结束循环，继续执行for-in表达式后面的代码。</li></ol><p>示例如下：</p><pre><code class="rust">// for-in循环
let array = [10, 20, 30, 40, 50];
for (number in array) {
    println("number: ${number}");
}</code></pre><p>这个程序中的<code>for-in</code>表达式完成了对数组array的遍历。</p><p>上述例子执行之后输出内容如下：</p><pre><code>number: 10
number: 20
number: 30
number: 40
number: 50</code></pre><h4>3. do-while</h4><p>do-while 表达式的基本形式为：</p><pre><code>do {
  循环体
} while (条件)</code></pre><p>其中“条件”是布尔类型表达式，“循环体”是一个代码块。do-while 表达式将按如下规则执行：</p><ol><li>执行“循环体”，转第2步。</li><li>计算“条件”表达式，如果值为true则转第1步，值为false转第3步。</li><li>结束循环，继续执行do-while表达式后面的代码。</li></ol><p>示例如下：</p><pre><code class="rust">// do-while循环
var number4 = 1;
do {
    println("number4: ${number4}");
    number4 += 1;
} while (number4 != 4)</code></pre><p>上述例子执行之后输出内容如下：</p><pre><code>number4: 1
number4: 2
number4: 3</code></pre><h3>参考引用</h3><ul><li>示例源码，见免费开源书<a href="https://link.segmentfault.com/?enc=%2BSI254e5ywz5b6yGSKKXTA%3D%3D.vG%2Bs36nOkSXBNFc4I31iTmXpzfBx2a2jYJoNk1DfddYAPYOa6MrPjkrYdLmYSZMeaIx3lSRuoyTf7EnPvRdEjA%3D%3D" rel="nofollow" target="_blank">《跟老卫学仓颉编程语言开发》</a></li><li>免费开源书<a href="https://link.segmentfault.com/?enc=kFPZDvR9fLId4qRbfXjmAQ%3D%3D.HMXg5mQWr%2B3FMu3gQ9T8sLNAtVba1umzQnSoxP97bfgeZZ8B1rGYqqo5TiqujXks" rel="nofollow" target="_blank">《跟老卫学HarmonyOS开发》</a></li><li><a href="https://link.segmentfault.com/?enc=zufhijV%2FekMYZuBmyoShbg%3D%3D.iSS8RYZb2JugJwup%2B3oRyayuLlyz0DSYjom879DBriL8Y9t%2BZmEOoX4F0Nt1k%2FzC" rel="nofollow" target="_blank">HarmonyOS NEXT+AI大模型打造智能助手APP（仓颉版）</a>（视频）</li><li><a href="https://link.segmentfault.com/?enc=vdHsOAITowyqpxj%2F3PNuaw%3D%3D.7h6L3qufcd3nbBmK2ecm1GRPFxj6JhWs1sKLuAcESPzyHQE5KHb52XP6Qy3fpJ7J9CbQ3%2FGfs%2F16nON%2BU7i%2BdzpiVvL%2BDNV58I6V6Ev9BRQ%3D" rel="nofollow" target="_blank">仓颉编程从入门到实践</a>（北京大学出版社）</li></ul>]]></description></item><item>    <title><![CDATA[HarmonyOS基础服务套件全解析：从跨设备剪贴板到后台下载，解锁应用开发新高度 灵芸小骏 ]]></title>    <link>https://segmentfault.com/a/1190000047536769</link>    <guid>https://segmentfault.com/a/1190000047536769</guid>    <pubDate>2026-01-12 09:02:15</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在HarmonyOS应用开发中，开发者经常面临这样的挑战：如何实现跨设备的数据共享？如何处理大文件的上传下载？如何让应用的不同部分高效通信？这些看似基础却至关重要的功能，正是<strong>HarmonyOS Basic Services Kit（基础服务套件）</strong> 要解决的核心问题。</p><h2>一、基础服务套件：HarmonyOS应用的“基础设施”</h2><p>Basic Services Kit不是单一功能，而是一系列基础能力的集合，它如同现代城市的供水供电系统——虽不显眼，却支撑着所有应用的正常运行。这个套件提供了从剪贴板读写到进程通信，从USB管理到电量监控的十余种核心能力，是每个HarmonyOS开发者必须掌握的工具箱。</p><h3>核心能力三大支柱</h3><p><strong>1. 数据文件处理能力</strong></p><ul><li>剪贴板服务：支持文本、HTML、URI、PixelMap等多种数据类型</li><li>文件压缩解压：内置高效的压缩算法</li><li>上传下载服务：支持前后台传输、断点续传</li></ul><p><strong>2. 进程线程通信机制</strong></p><ul><li>公共事件：跨进程通信的标准化方案</li><li>Emitter：线程间通信的轻量级解决方案</li></ul><p><strong>3. 设备管理功能</strong></p><ul><li>设备信息查询：获取设备类型、品牌、版本等</li><li>电源管理：监控电量、管理屏幕状态</li><li>USB服务：管理外设连接和数据传输</li></ul><h2>二、实战案例：打造智能家居控制中心的完整解决方案</h2><p>让我们通过一个智能家居控制中心的应用案例，看看如何将Basic Services Kit的各项能力融会贯通。</p><h3>案例背景</h3><p>“智慧家居管家”应用需要实现以下功能：</p><ul><li>跨设备同步控制指令（手机→平板→智能屏）</li><li>后台下载设备固件更新包</li><li>实时监控设备状态变化</li><li>处理USB连接的外接安防设备</li></ul><h3>实现方案</h3><h4>1. 跨设备剪贴板：无缝分享设备配置</h4><p>当用户在手机上配置好智能灯光场景后，可以通过剪贴板轻松分享到平板上继续编辑：</p><pre><code class="typescript">// 手机端：复制灯光场景配置
import { pasteboard } from '@kit.BasicServicesKit';

async function copySceneToClipboard(sceneConfig: SceneConfig) {
  const data: pasteboard.PasteData = pasteboard.createPlainTextData(
    JSON.stringify(sceneConfig)
  );
  await pasteboard.getSystemPasteboard().setData(data);
  showToast('场景配置已复制，可在其他设备粘贴');
}

// 平板端：粘贴并应用配置
async function pasteSceneFromClipboard() {
  const pasteboard = pasteboard.getSystemPasteboard();
  const data = await pasteboard.getData();
  if (data?.getMimeTypes().includes('text/plain')) {
    const configText = await data.getText();
    const sceneConfig: SceneConfig = JSON.parse(configText);
    applySceneConfig(sceneConfig);
  }
}</code></pre><p><strong>技术要点</strong>：HarmonyOS的剪贴板服务不仅支持文本，还能处理富文本、图片甚至自定义数据类型，为跨设备协作提供了基础支持。</p><h4>2. 后台下载服务：智能固件更新</h4><p>智能家居设备的固件更新包通常较大，需要稳定的后台下载能力：</p><pre><code class="typescript">import { download } from '@kit.BasicServicesKit';

class FirmwareUpdateManager {
  private taskId: number | null = null;
  
  async downloadFirmware(deviceId: string, firmwareUrl: string) {
    const config: download.DownloadConfig = {
      url: firmwareUrl,
      header: [{ headerKey: 'User-Agent', headerValue: 'SmartHome/1.0' }],
      enableMetered: true, // 允许使用流量下载
      enableRoaming: false, // 漫游时暂停下载
      description: `${deviceId}固件更新`,
      networkType: download.NetworkType.NETWORK_MOBILE | download.NetworkType.NETWORK_WIFI
    };
    
    this.taskId = await download.download(context, config);
    
    // 监听下载进度
    download.on('progress', (taskId, received, total) =&gt; {
      if (taskId === this.taskId) {
        updateProgress(received / total * 100);
      }
    });
    
    // 监听下载完成
    download.on('complete', (taskId, filePath) =&gt; {
      if (taskId === this.taskId) {
        this.installFirmware(deviceId, filePath);
      }
    });
  }
  
  pauseDownload() {
    if (this.taskId !== null) {
      download.pause(this.taskId);
    }
  }
  
  resumeDownload() {
    if (this.taskId !== null) {
      download.resume(this.taskId);
    }
  }
}</code></pre><p><strong>技术亮点</strong>：下载服务支持断点续传、网络类型控制、进度监听，即使应用切换到后台也能继续下载，确保大文件传输的可靠性。</p><h4>3. 公共事件通信：实时设备状态同步</h4><p>当传感器检测到异常时，需要通过公共事件通知所有相关应用组件：</p><pre><code class="typescript">// 传感器服务发布异常事件
import { commonEventManager } from '@kit.BasicServicesKit';

async function publishSensorAlert(sensorId: string, alertType: string) {
  const publishInfo: commonEventManager.CommonEventPublishData = {
    code: 1001, // 自定义事件代码
    data: JSON.stringify({
      sensorId,
      alertType,
      timestamp: new Date().getTime(),
      location: '客厅窗户'
    }),
    parameters: {
      priority: 'high',
      requiresAction: true
    }
  };
  
  await commonEventManager.publish(
    'com.smarthome.SENSOR_ALERT',
    publishInfo
  );
}

// 各组件订阅事件
async function subscribeToAlerts() {
  const subscribeInfo: commonEventManager.CommonEventSubscribeInfo = {
    events: ['com.smarthome.SENSOR_ALERT'],
    publisherPermissions: ['ohos.permission.SMART_HOME_CONTROL'] // 安全限制
  };
  
  const subscriber = await commonEventManager.createSubscriber(subscribeInfo);
  
  commonEventManager.subscribe(subscriber, (err, data) =&gt; {
    if (!err) {
      const alertData = JSON.parse(data.data);
      handleSensorAlert(alertData);
      
      // 有序事件处理：高优先级组件可中断传递
      if (shouldSuppressAlert(alertData)) {
        commonEventManager.abort(data);
      }
    }
  });
}</code></pre><p><strong>架构优势</strong>：公共事件采用发布-订阅模式，实现了组件间的完全解耦。安全机制确保只有授权组件能发布或接收特定事件，保障系统安全。</p><h4>4. USB服务：外接安防摄像头管理</h4><pre><code class="typescript">import { usb } from '@kit.BasicServicesKit';

class SecurityCameraManager {
  private cameraDevice: usb.USBDevice | null = null;
  
  async connectCamera() {
    const deviceList = await usb.getDevices();
    const camera = deviceList.find(device =&gt; 
      device.productId === 0x1234 &amp;&amp; device.vendorId === 0x5678
    );
    
    if (camera) {
      await usb.connectDevice(camera);
      this.cameraDevice = camera;
      
      // 批量传输视频数据
      const endpoint = camera.interfaces[0].endpoints[0];
      const buffer = new ArrayBuffer(1024);
      
      setInterval(async () =&gt; {
        const result = await usb.bulkTransfer(
          camera,
          endpoint,
          buffer,
          5000 // 超时时间
        );
        processVideoData(result);
      }, 33); // 约30fps
    }
  }
  
  async disconnectCamera() {
    if (this.cameraDevice) {
      await usb.disconnectDevice(this.cameraDevice);
      this.cameraDevice = null;
    }
  }
}</code></pre><h2>三、最佳实践与性能优化</h2><h3>1. 资源生命周期管理</h3><p>Basic Services Kit的许多组件需要显式的资源管理，特别是Native（C/C++）开发中：</p><pre><code class="cpp">// 正确示例：完整的创建-使用-销毁流程
CommonEvent_PublishInfo* info = OH_CommonEvent_CreatePublishInfo(false);
// ...使用info发布事件
OH_CommonEvent_DestroyPublishInfo(info);
info = nullptr; // 防止悬空指针

// 错误示例：内存泄漏
OH_CommonEvent_CreatePublishInfo(false); // 没有保存指针，无法销毁！</code></pre><h3>2. 后台任务优化</h3><p>对于上传下载等后台任务，合理配置可以显著提升用户体验：</p><pre><code class="typescript">const optimalConfig: download.DownloadConfig = {
  enableMetered: false, // 默认不使用移动数据
  enableRoaming: false, // 漫游时暂停
  requireCharging: true, // 仅在充电时下载大文件
  requireBatteryNotLow: true, // 电量充足时执行
  networkType: download.NetworkType.NETWORK_WIFI // 优先WiFi
};</code></pre><h3>3. 安全通信策略</h3><p>公共事件通信必须考虑安全性：</p><pre><code class="typescript">// 发布方限制接收方
const publishInfo: commonEventManager.CommonEventPublishData = {
  // ...其他配置
  subscriberPermissions: ['ohos.permission.SMART_HOME_READ'],
  bundleName: 'com.trusted.partner' // 仅限合作应用接收
};

// 订阅方验证发布方
const subscribeInfo: commonEventManager.CommonEventSubscribeInfo = {
  events: ['com.smarthome.EVENT'],
  publisherPermissions: ['ohos.permission.SMART_HOME_CONTROL'],
  publisherBundleName: 'com.official.smarthome' // 仅信任官方发布
};</code></pre><h2>四、从基础到进阶：与其他Kit的协同工作</h2><p>Basic Services Kit不是孤立存在的，它与其他HarmonyOS Kit形成了完整的开发生态：</p><ol><li><strong>与Ability Kit配合</strong>：Ability的生命周期管理结合公共事件通信</li><li><strong>与ArkTS Kit协同</strong>：多线程任务使用Emitter进行线程间通信</li><li><strong>与Core File Kit分工</strong>：文件操作与文件传输各司其职</li></ol><h2>五、总结与展望</h2><p>HarmonyOS Basic Services Kit作为应用开发的基石，其价值在于：</p><p><strong>降低开发门槛</strong>：将复杂的系统功能封装为简单API<br/><strong>提升应用质量</strong>：提供稳定可靠的基础服务实现<br/><strong>促进生态协同</strong>：标准化接口促进应用间互联互通<br/><strong>保障系统安全</strong>：内置多层次的安全防护机制</p><p>随着HarmonyOS生态的不断发展，Basic Services Kit将持续演进。未来我们可能会看到：</p><ul><li>更智能的剪贴板（AI辅助内容理解）</li><li>更高效的传输协议（多路径并发传输）</li><li>更精细的权限控制（动态权限分级）</li></ul><p>对于开发者而言，深入掌握Basic Services Kit不仅是提升应用开发效率与质量的关键，更是解锁HarmonyOS分布式核心能力的必经之路。在万物互联的时代，这些基础能力正是构建全场景、高品质用户体验的核心支撑。正如一位资深HarmonyOS开发者所言：“精通Basic Services Kit的开发者，就像熟悉所有工具的工匠，无论面对何种分布式开发需求，都能快速找到最适配的解决方案。” 在HarmonyOS分布式操作系统的浪潮中，基础服务套件必将成为每位开发者最可靠的技术伙伴。</p>]]></description></item><item>    <title><![CDATA[SPI机制：服务扩展的核心技术 SevenCoding ]]></title>    <link>https://segmentfault.com/a/1190000047536241</link>    <guid>https://segmentfault.com/a/1190000047536241</guid>    <pubDate>2026-01-12 09:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>为什么需要SPI机制</h2><h3>SPI和API的区别是什么</h3><p>SPI是一种跟API相对应的反向设计思想：API由实现方确定标准规范和功能，调用方无权做任何干预； 而SPI是由调用方确定标准规范，也就是接口，然后调用方依赖此接口，第三方实现此接口，这样做就可以方便的进行扩展，类似于插件机制，这是SPI出现的需求背景。</p><p>SPI ： “接口”位于“调用方”所在的“包”中</p><ul><li>概念上更依赖调用方。</li><li>组织上位于调用方所在的包中。</li><li>实现位于独立的包中。</li><li>常见的例子是：插件模式的插件。</li></ul><p>API ： “接口”位于“实现方”所在的“包”中</p><ul><li>概念上更接近实现方。</li><li>组织上位于实现方所在的包中。</li><li>实现和接口在一个包中。</li></ul><h3>什么是SPI机制</h3><p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，例如数据库中的java.sql.Driver接口，不同的厂商可以针对同一接口做出不同的实现，如下图所示，MySQL和PostgreSQL都有不同的实现提供给用户。<br/>而Java的SPI机制可以为某个接口寻找服务实现，Java中SPI机制主要思想是<strong>将装配的控制权移到程序之外</strong>，在模块化设计中这个机制尤其重要，其核心思想就是 <strong>解耦</strong>。</p><p>SPI整体机制图如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045396322" alt="" title=""/></p><ol><li>当服务的提供者提供了一种接口的实现之后，需要在classpath下的 META-INF/services/ 目录里创建一个文件，文件名是以<strong>服务接口</strong>命名的，而文件里的内容是这个接口的<strong>具体的实现类</strong>。</li><li>当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，再根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。</li></ol><h2>SPI机制的简单示例</h2><p>假设现在需要一个发送消息的服务MessageService，发送消息的实现可能是基于短信、也可能是基于电子邮件、或推送通知发送消息。</p><ul><li><strong>接口定义</strong>：首先定义一个接口 <code>MessageService</code></li></ul><pre><code class="java">public interface MessageService {
    void sendMessage(String message);
}</code></pre><ul><li><strong>提供两个实现类</strong>：一个通过短信发送消息，一个通过电子邮件发送消息。</li></ul><pre><code class="java">// 短信发送实现
public class SmsMessageService implements MessageService {
    @Override
    public void sendMessage(String message) {
        System.out.println("Sending SMS: " + message);
    }
}

// 电子邮件发送实现
public class EmailMessageService implements MessageService {
    @Override
    public void sendMessage(String message) {
        System.out.println("Sending Email: " + message);
    }
}</code></pre><ul><li><strong>配置文件</strong>：在 <code>META-INF/services/</code> 目录下创建一个配置文件，文件名为 <code>MessageService</code> ，全限定名 <code>com.example.MessageService</code>，文件内容为接口的实现类的全限定名。</li></ul><pre><code class="java"># 文件: META-INF/services/com.seven.MessageService
com.seven.SmsMessageService
com.seven.EmailMessageService</code></pre><ul><li><strong>加载服务实现</strong>：在应用程序中，通过 <code>ServiceLoader</code> 动态加载并使用这些实现类。</li></ul><pre><code class="java">public class Application {
    public static void main(String[] args) {
        ServiceLoader&lt;MessageService&gt; loader = ServiceLoader.load(MessageService.class);

        for (MessageService service : loader) {
            service.sendMessage("Hello, SPI!");
        }
    }
}</code></pre><p>运行时，<code>ServiceLoader</code> 会发现并加载配置文件中列出的所有实现类，并依次调用它们的 <code>sendMessage</code> 方法。</p><p>由于在 配置文件 写了两个实现类，因此两个实现类都会执行 sendMessage 方法。</p><p>这就是因为ServiceLoader.load(Search.class)在加载某接口时，会去 META-INF/services 下找接口的全限定名文件，再根据里面的内容加载相应的实现类。</p><p>这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的META-INF/services下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。</p><h2>SPI机制的应用</h2><h3>JDBC DriverManager</h3><p>在JDBC4.0之前，开发连接数据库的时候，通常会用<code>Class.forName("com.mysql.jdbc.Driver")</code>这句先加载数据库相关的驱动，然后再进行获取连接等的操作。而JDBC4.0之后不需要用<code>Class.forName("com.mysql.jdbc.Driver")</code>来加载驱动，直接获取连接就可以了，原因就是现在使用了Java的SPI扩展机制来实现。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045396323" alt="" title="" loading="lazy"/></p><p>如上图所示：</p><ol><li>首先在java中定义了接口 java.sql.Driver，并没有具体的实现，具体的实现都是由不同厂商来提供的。</li><li>在mysql的jar包mysql-connector-java-8.0.26.jar中，可以找到 META-INF/services 目录，该目录下会有一个名字为 java.sql.Driver 的文件，文件内容是com.mysql.cj.jdbc.Driver，这里面的内容就是mysql针对Java中定义的接口的实现。</li><li>同样在ojdbc的jar包ojdbc11.jar中，也可以找到同样的配置文件，文件内容是 oracle.jdbc.OracleDriver，这是oracle数据库对Java的java.sql.Driver的实现。</li></ol><h4>使用方法</h4><p>而现在Java中写连接数据库的代码的时候，不需要再使用<code>Class.forName("com.mysql.jdbc.Driver")</code>来加载驱动了，直接获取连接就可以了：</p><pre><code class="java">String url = "jdbc:xxxx://xxxx:xxxx/xxxx";
Connection conn = DriverManager.getConnection(url, username, password);
.....</code></pre><p>这里并没有涉及到spi的使用，看下面源码。</p><h4>源码实现</h4><p>上面的使用方法，就是普通的连接数据库的代码，实际上并没有涉及到 SPI 的东西，但是有一点可以确定的是，我们没有写有关具体驱动的硬编码<code>Class.forName("com.mysql.jdbc.Driver")</code>！</p><p>而上面的代码就可以直接获取数据库连接进行操作，但是跟SPI有啥关系呢？<br/>既然上面代码没有加载驱动的代码，那实际上是怎么去确定使用哪个数据库连接的驱动呢？</p><p>这里就涉及到使用Java的SPI 扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在DriverManager中，DriverManager是Java中的实现，用来获取数据库连接，源码如下：</p><pre><code class="java">public class DriverManager {

    // 存放注册的jdbc驱动
    private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();

    /**
     * Load the initial JDBC drivers by checking the System property
     * jdbc.properties and then use the {@code ServiceLoader} mechanism
     */
    static {
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
    }
    
    private static void loadInitialDrivers() {
        String drivers;
        try {
            // 从JVM -D参数读取jdbc驱动
            drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
                public String run() {
                    return System.getProperty("jdbc.drivers");
                }
            });
        } catch (Exception ex) {
            drivers = null;
        }
        // If the driver is packaged as a Service Provider, load it.
        // Get all the drivers through the classloader
        // exposed as a java.sql.Driver.class service.
        // ServiceLoader.load() replaces the sun.misc.Providers()

        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
            public Void run() {

                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);
                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();

                /* Load these drivers, so that they can be instantiated.
                 * It may be the case that the driver class may not be there
                 * i.e. there may be a packaged driver with the service class
                 * as implementation of java.sql.Driver but the actual class
                 * may be missing. In that case a java.util.ServiceConfigurationError
                 * will be thrown at runtime by the VM trying to locate
                 * and load the service.
                 *
                 * Adding a try catch block to catch those runtime errors
                 * if driver not available in classpath but it's
                 * packaged as service and that service is there in classpath.
                 */
                try{
                    // 加载创建所有Driver
                    while(driversIterator.hasNext()) {
                        // 触发Driver的类加载-&gt;在静态代码块中创建Driver对象并放到DriverManager
                        driversIterator.next();
                    }
                } catch(Throwable t) {
                // Do nothing
                }
                return null;
            }
        });

        println("DriverManager.initialize: jdbc.drivers = " + drivers);

        if (drivers == null || drivers.equals("")) {
            return;
        }
        // 解析JVM参数的jdbc驱动
        String[] driversList = drivers.split(":");
        println("number of Drivers:" + driversList.length);
        for (String aDriver : driversList) {
            try {
                println("DriverManager.Initialize: loading " + aDriver);
                // initial为ture 
                // 触发Driver的类加载-&gt;在静态代码块中创建Driver对象并放到DriverManager
                Class.forName(aDriver, true,
                        ClassLoader.getSystemClassLoader());
            } catch (Exception ex) {
                println("DriverManager.Initialize: load failed: " + ex);
            }
        }
    }

}</code></pre><p>上面的代码主要步骤是：</p><ol><li>从系统变量中获取有关驱动的定义。</li><li>使用SPI来获取驱动的实现。</li><li>遍历使用SPI获取到的具体实现，实例化各个实现类。</li><li>根据第一步获取到的驱动列表来实例化具体实现类。</li></ol><ul><li>第二步：使用SPI来获取驱动的实现，对应的代码是：</li></ul><pre><code class="java">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</code></pre><p>这里封装了接口类型和类加载器，并初始化了一个迭代器。</p><ul><li>第三步：遍历获取到的具体实现，实例化各个实现类，对应的代码如下：</li></ul><pre><code class="java">//获取迭代器
Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();
//遍历所有的驱动实现
while(driversIterator.hasNext()) {
    driversIterator.next();
}</code></pre><p>在遍历的时候，首先调用driversIterator.hasNext()方法，这里会搜索classpath下以及jar包中所有的META-INF/services目录下的java.sql.Driver文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（ServiceLoader具体的源码实现在下面）。</p><p>然后是调用driversIterator.next();方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。</p><h3>Common-Logging</h3><p>common-logging（也称Jakarta Commons Logging，缩写 JCL）是常用的日志库门面， 使用了SPI的方式来动态加载和配置日志实现。这种机制允许库在运行时找到合适的日志实现，而无需硬编码具体的日志库。</p><p>我们看下它是怎么通过SPI解耦的。</p><p>首先，日志实例是通过LogFactory的getLog(String)方法创建的：</p><pre><code class="java">public static getLog(Class clazz) throws LogConfigurationException {
    return getFactory().getInstance(clazz);
}</code></pre><p>LogFatory是一个抽象类，它负责加载具体的日志实现，getFactory()方法源码如下：</p><pre><code class="java">public static org.apache.commons.logging.LogFactory getFactory() throws LogConfigurationException {
    // Identify the class loader we will be using
    ClassLoader contextClassLoader = getContextClassLoaderInternal();

    if (contextClassLoader == null) {
        // This is an odd enough situation to report about. This
        // output will be a nuisance on JDK1.1, as the system
        // classloader is null in that environment.
        if (isDiagnosticsEnabled()) {
            logDiagnostic("Context classloader is null.");
        }
    }

    // Return any previously registered factory for this class loader
    org.apache.commons.logging.LogFactory factory = getCachedFactory(contextClassLoader);
    if (factory != null) {
        return factory;
    }

    if (isDiagnosticsEnabled()) {
        logDiagnostic(
                "[LOOKUP] LogFactory implementation requested for the first time for context classloader " +
                        objectId(contextClassLoader));
        logHierarchy("[LOOKUP] ", contextClassLoader);
    }

    // classpath根目录下寻找commons-logging.properties
    Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES);

    // Determine whether we will be using the thread context class loader to
    // load logging classes or not by checking the loaded properties file (if any).
    // classpath根目录下commons-logging.properties是否配置use_tccl
    ClassLoader baseClassLoader = contextClassLoader;
    if (props != null) {
        String useTCCLStr = props.getProperty(TCCL_KEY);
        if (useTCCLStr != null) {
            if (Boolean.valueOf(useTCCLStr).booleanValue() == false) {
                baseClassLoader = thisClassLoader;
            }
        }
    }

    // 这里真正开始决定使用哪个factory
    // 首先，尝试查找vm系统属性org.apache.commons.logging.LogFactory，其是否指定factory
    if (isDiagnosticsEnabled()) {
        logDiagnostic("[LOOKUP] Looking for system property [" + FACTORY_PROPERTY +
                "] to define the LogFactory subclass to use...");
    }

    try {
        String factoryClass = getSystemProperty(FACTORY_PROPERTY, null);
        if (factoryClass != null) {
            if (isDiagnosticsEnabled()) {
                logDiagnostic("[LOOKUP] Creating an instance of LogFactory class '" + factoryClass +
                        "' as specified by system property " + FACTORY_PROPERTY);
            }
            factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);
        } else {
            if (isDiagnosticsEnabled()) {
                logDiagnostic("[LOOKUP] No system property [" + FACTORY_PROPERTY + "] defined.");
            }
        }
    } catch (SecurityException e) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic("[LOOKUP] A security exception occurred while trying to create an" +
                    " instance of the custom factory class" + ": [" + trim(e.getMessage()) +
                    "]. Trying alternative implementations...");
        }
        // ignore
    } catch (RuntimeException e) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic("[LOOKUP] An exception occurred while trying to create an" +
                    " instance of the custom factory class" + ": [" +
                    trim(e.getMessage()) +
                    "] as specified by a system property.");
        }
        throw e;
    }

    // 第二，尝试使用java spi服务发现机制，在META-INF/services下寻找org.apache.commons.logging.LogFactory实现
    if (factory == null) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic("[LOOKUP] Looking for a resource file of name [" + SERVICE_ID +
                    "] to define the LogFactory subclass to use...");
        }
        try {
            // META-INF/services/org.apache.commons.logging.LogFactory, SERVICE_ID
            final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID);

            if (is != null) {
                // This code is needed by EBCDIC and other strange systems.
                // It's a fix for bugs reported in xerces
                BufferedReader rd;
                try {
                    rd = new BufferedReader(new InputStreamReader(is, "UTF-8"));
                } catch (java.io.UnsupportedEncodingException e) {
                    rd = new BufferedReader(new InputStreamReader(is));
                }

                String factoryClassName = rd.readLine();
                rd.close();

                if (factoryClassName != null &amp;&amp; !"".equals(factoryClassName)) {
                    if (isDiagnosticsEnabled()) {
                        logDiagnostic("[LOOKUP]  Creating an instance of LogFactory class " +
                                factoryClassName +
                                " as specified by file '" + SERVICE_ID +
                                "' which was present in the path of the context classloader.");
                    }
                    factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader);
                }
            } else {
                // is == null
                if (isDiagnosticsEnabled()) {
                    logDiagnostic("[LOOKUP] No resource file with name '" + SERVICE_ID + "' found.");
                }
            }
        } catch (Exception ex) {
            // note: if the specified LogFactory class wasn't compatible with LogFactory
            // for some reason, a ClassCastException will be caught here, and attempts will
            // continue to find a compatible class.
            if (isDiagnosticsEnabled()) {
                logDiagnostic(
                        "[LOOKUP] A security exception occurred while trying to create an" +
                                " instance of the custom factory class" +
                                ": [" + trim(ex.getMessage()) +
                                "]. Trying alternative implementations...");
            }
            // ignore
        }
    }

    // 第三，尝试从classpath根目录下的commons-logging.properties中查找org.apache.commons.logging.LogFactory属性指定的factory
    if (factory == null) {
        if (props != null) {
            if (isDiagnosticsEnabled()) {
                logDiagnostic(
                        "[LOOKUP] Looking in properties file for entry with key '" + FACTORY_PROPERTY +
                                "' to define the LogFactory subclass to use...");
            }
            String factoryClass = props.getProperty(FACTORY_PROPERTY);
            if (factoryClass != null) {
                if (isDiagnosticsEnabled()) {
                    logDiagnostic(
                            "[LOOKUP] Properties file specifies LogFactory subclass '" + factoryClass + "'");
                }
                factory = newFactory(factoryClass, baseClassLoader, contextClassLoader);

                // TODO: think about whether we need to handle exceptions from newFactory
            } else {
                if (isDiagnosticsEnabled()) {
                    logDiagnostic("[LOOKUP] Properties file has no entry specifying LogFactory subclass.");
                }
            }
        } else {
            if (isDiagnosticsEnabled()) {
                logDiagnostic("[LOOKUP] No properties file available to determine" + " LogFactory subclass from..");
            }
        }
    }

    // 最后，使用后备factory实现，org.apache.commons.logging.impl.LogFactoryImpl
    if (factory == null) {
        if (isDiagnosticsEnabled()) {
            logDiagnostic(
                    "[LOOKUP] Loading the default LogFactory implementation '" + FACTORY_DEFAULT +
                            "' via the same classloader that loaded this LogFactory" +
                            " class (ie not looking in the context classloader).");
        }

        factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader);
    }

    if (factory != null) {
        cacheFactory(contextClassLoader, factory);

        if (props != null) {
            Enumeration names = props.propertyNames();
            while (names.hasMoreElements()) {
                String name = (String) names.nextElement();
                String value = props.getProperty(name);
                factory.setAttribute(name, value);
            }
        }
    }

    return factory;
}</code></pre><p>可以看出，抽象类LogFactory加载具体实现的步骤如下：</p><ol><li>从vm系统属性org.apache.commons.logging.LogFactory</li><li>使用SPI服务发现机制，发现org.apache.commons.logging.LogFactory的实现</li><li>查找classpath根目录commons-logging.properties的org.apache.commons.logging.LogFactory属性是否指定factory实现</li><li>使用默认factory实现，org.apache.commons.logging.impl.LogFactoryImpl</li></ol><p>LogFactory的getLog()方法返回类型是org.apache.commons.logging.Log接口，提供了从trace到fatal方法。可以确定，如果日志实现提供者只要实现该接口，并且使用继承自org.apache.commons.logging.LogFactory的子类创建Log，必然可以构建一个松耦合的日志系统。</p><h3>Spring中SPI机制</h3><p>在springboot的<a href="https://link.segmentfault.com/?enc=%2FF4l%2F03PHNXZnn3JdJYBpg%3D%3D.HUf5afva2pbvGZrFD9ozt%2F9DyWM3EyzS4p3dwYGplyNYTAs3%2BYoU%2BIzQZcpiAaGD6gCBX1IwsQa9Qd7KC%2F%2FET6AXuICB8QD1RHVDFHSOJUY%3D" rel="nofollow" target="_blank">自动装配</a>过程中，最终会加载META-INF/spring.factories文件，主要通过以下几个步骤实现：</p><ol><li><strong>服务接口定义</strong>： Spring 定义了许多服务接口，如 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>。</li><li><strong>服务提供者实现</strong>： 各种具体的模块和库会提供这些服务接口的实现，如各种自动配置类。</li><li><strong>服务描述文件</strong>： 在实现模块的 JAR 包中，会有一个 <code>META-INF/spring.factories</code> 文件，这个文件中列出了该 JAR 包中实现的自动配置类。</li><li><strong>服务加载</strong>： Spring Boot 在启动时加载 <code>spring.factories</code> 文件，并实例化这些文件中列出的实现类。</li></ol><p>Spring Boot 使用 <code>SpringFactoriesLoader</code> 来加载 <code>spring.factories</code> 文件中列出的所有类，并将它们注册到应用上下文中。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。</p><pre><code class="java">public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";
// spring.factories文件的格式为：key=value1,value2,value3
// 从所有的jar包中找到META-INF/spring.factories文件
// 然后从文件中解析出key=factoryClass类名称的所有value值
public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) {
    String factoryClassName = factoryClass.getName();
    // 取得资源文件的URL
    Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
    List&lt;String&gt; result = new ArrayList&lt;String&gt;();
    // 遍历所有的URL
    while (urls.hasMoreElements()) {
        URL url = urls.nextElement();
        // 根据资源文件URL解析properties文件，得到对应的一组@Configuration类
        Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));
        String factoryClassNames = properties.getProperty(factoryClassName);
        // 组装数据，并返回
        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));
    }
    return result;
}</code></pre><p>通过 SPI 机制和 <code>spring.factories</code> 文件的配合，Spring Boot 实现了模块化和自动配置的能力。开发者可以通过定义自动配置类并在 <code>spring.factories</code> 文件中声明它们，从而实现模块的独立和松耦合。这种机制不仅简化了配置和启动过程，还提升了应用的可扩展性和维护性。</p><h2>SPI 机制通常怎么使用</h2><p>看完上面的几个例子解析，应该都能知道大概的流程了：</p><ol><li>定义标准：定义标准，就是定义接口。比如接口java.sql.Driver</li><li>具体厂商或者框架开发者实现：厂商或者框架开发者开发具体的实现：<br/>在META-INF/services目录下定义一个名字为接口全限定名的文件，比如java.sql.Driver文件，文件内容是具体的实现名字，比如me.cxis.sql.MyDriver。写具体的实现me.cxis.sql.MyDriver，都是对接口Driver的实现。</li><li>具体使用：引用具体厂商的jar包来实现我们的功能：</li></ol><pre><code class="java">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);
//获取迭代器
Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();
//遍历
while(driversIterator.hasNext()) {
    driversIterator.next();
    //可以做具体的业务逻辑
}
</code></pre><ol start="4"><li>使用规范：</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045396324" alt="" title="" loading="lazy"/></p><h2>SPI机制实现原理</h2><p>那么问题来了： 怎么样才能加载这些SPI接口的实现类呢，真正的原因是Java的<a href="https://link.segmentfault.com/?enc=HcTWMb8DMdsGtOV6x39RjQ%3D%3D.X24kDNLw3io42RBWe44xn0taVvOTbv4GhZlhfii3p83l1tJGUCntMmS%2FpKPFHePoeF16dfCnIH44j%2BBB9Wz1R93bgNu%2BFVAp7zn6sg%2Bbq%2BY%3D" rel="nofollow" target="_blank">类加载机制</a>！ SPI接口属于java rt核心包，只能由启动类加载器BootStrap classLoader加载，而第三方jar包是用户classPath路径下，根据类加载器的可见性原则：启动类加载器无法加载这些jar包，也就是没法向下委托，所以spi必须打破这种传统的双亲委派机制，通过自定义的类加载器来加载第三方jar包下的spi接口实现类！</p><p>JDK中ServiceLoader方法的具体实现：</p><pre><code class="java">//ServiceLoader实现了Iterable接口，可以遍历所有的服务实现者
public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt;{

    //查找配置文件的目录
    private static final String PREFIX = "META-INF/services/";

    //表示要被加载的服务的类或接口
    private final Class&lt;S&gt; service;

    //这个ClassLoader用来定位，加载，实例化服务提供者
    private final ClassLoader loader;

    // 访问控制上下文
    private final AccessControlContext acc;

    // 缓存已经被实例化的服务提供者，按照实例化的顺序存储
    private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;();

    // 迭代器
    private LazyIterator lookupIterator;

    //重新加载，就相当于重新创建ServiceLoader了，用于新的服务提供者安装到正在运行的Java虚拟机中的情况。
    public void reload() {
        //清空缓存中所有已实例化的服务提供者
        providers.clear();
        //新建一个迭代器，该迭代器会从头查找和实例化服务提供者
        lookupIterator = new LazyIterator(service, loader);
    }

    //私有构造器
    //使用指定的类加载器和服务创建服务加载器
    //如果没有指定类加载器，使用系统类加载器，就是应用类加载器。
    private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) {
        service = Objects.requireNonNull(svc, "Service interface cannot be null");
        loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;
        acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;
        reload();
    }

    //解析失败处理的方法
    private static void fail(Class&lt;?&gt; service, String msg, Throwable cause)
        throws ServiceConfigurationError
    {
        throw new ServiceConfigurationError(service.getName() + ": " + msg,
                                            cause);
    }

    private static void fail(Class&lt;?&gt; service, String msg)
        throws ServiceConfigurationError
    {
        throw new ServiceConfigurationError(service.getName() + ": " + msg);
    }

    private static void fail(Class&lt;?&gt; service, URL u, int line, String msg)
        throws ServiceConfigurationError
    {
        fail(service, u + ":" + line + ": " + msg);
    }

    //解析服务提供者配置文件中的一行
    //首先去掉注释校验，然后保存
    //返回下一行行号
    //重复的配置项和已经被实例化的配置项不会被保存
    private int parseLine(Class&lt;?&gt; service, URL u, BufferedReader r, int lc, List&lt;String&gt; names)
            throws IOException, ServiceConfigurationError{
        //读取一行
        String ln = r.readLine();
        if (ln == null) {
            return -1;
        }
        //#号代表注释行
        int ci = ln.indexOf('#');
        if (ci &gt;= 0) ln = ln.substring(0, ci);
        ln = ln.trim();
        int n = ln.length();
        if (n != 0) {
            if ((ln.indexOf(' ') &gt;= 0) || (ln.indexOf('\t') &gt;= 0))
                fail(service, u, lc, "Illegal configuration-file syntax");
            int cp = ln.codePointAt(0);
            if (!Character.isJavaIdentifierStart(cp))
                fail(service, u, lc, "Illegal provider-class name: " + ln);
            for (int i = Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) {
                cp = ln.codePointAt(i);
                if (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != '.'))
                    fail(service, u, lc, "Illegal provider-class name: " + ln);
            }
            if (!providers.containsKey(ln) &amp;&amp; !names.contains(ln))
                names.add(ln);
        }
        return lc + 1;
    }

    //解析配置文件，解析指定的url配置文件
    //使用parseLine方法进行解析，未被实例化的服务提供者会被保存到缓存中去
    private Iterator&lt;String&gt; parse(Class&lt;?&gt; service, URL u) throws ServiceConfigurationError{
        InputStream in = null;
        BufferedReader r = null;
        ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();
        try {
            in = u.openStream();
            r = new BufferedReader(new InputStreamReader(in, "utf-8"));
            int lc = 1;
            while ((lc = parseLine(service, u, r, lc, names)) &gt;= 0);
        }
        return names.iterator();
    }

    //服务提供者查找的迭代器
    private class LazyIterator implements Iterator&lt;S&gt;{

        Class&lt;S&gt; service;//服务提供者接口
        ClassLoader loader;//类加载器
        Enumeration&lt;URL&gt; configs = null;//保存实现类的url
        Iterator&lt;String&gt; pending = null;//保存实现类的全名
        String nextName = null;//迭代器中下一个实现类的全名

        private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) {
            this.service = service;
            this.loader = loader;
        }

        private boolean hasNextService() {
            if (nextName != null) {
                return true;
            }
            if (configs == null) {
                try {
                    String fullName = PREFIX + service.getName();
                    if (loader == null)
                        configs = ClassLoader.getSystemResources(fullName);
                    else
                        configs = loader.getResources(fullName);
                }
            }
            while ((pending == null) || !pending.hasNext()) {
                if (!configs.hasMoreElements()) {
                    return false;
                }
                pending = parse(service, configs.nextElement());
            }
            nextName = pending.next();
            return true;
        }

        private S nextService() {
            if (!hasNextService())
                throw new NoSuchElementException();
            String cn = nextName;
            nextName = null;
            Class&lt;?&gt; c = null;
            try {
                c = Class.forName(cn, false, loader);
            }
            if (!service.isAssignableFrom(c)) {
                fail(service, "Provider " + cn  + " not a subtype");
            }
            try {
                S p = service.cast(c.newInstance());
                providers.put(cn, p);
                return p;
            }
        }

        public boolean hasNext() {
            if (acc == null) {
                return hasNextService();
            } else {
                PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() {
                    public Boolean run() { return hasNextService(); }
                };
                return AccessController.doPrivileged(action, acc);
            }
        }

        public S next() {
            if (acc == null) {
                return nextService();
            } else {
                PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() {
                    public S run() { return nextService(); }
                };
                return AccessController.doPrivileged(action, acc);
            }
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

    }

    //获取迭代器
    //返回遍历服务提供者的迭代器
    //以懒加载的方式加载可用的服务提供者
    //懒加载的实现是：解析配置文件和实例化服务提供者的工作由迭代器本身完成
    public Iterator&lt;S&gt; iterator() {
        return new Iterator&lt;S&gt;() {
            //按照实例化顺序返回已经缓存的服务提供者实例
            Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders
                = providers.entrySet().iterator();

            public boolean hasNext() {
                if (knownProviders.hasNext())
                    return true;
                return lookupIterator.hasNext();
            }

            public S next() {
                if (knownProviders.hasNext())
                    return knownProviders.next().getValue();
                return lookupIterator.next();
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }

        };
    }

    //为指定的服务使用指定的类加载器来创建一个ServiceLoader
    public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service, ClassLoader loader){
        return new ServiceLoader&lt;&gt;(service, loader);
    }

    //使用线程上下文的类加载器来创建ServiceLoader
    public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return ServiceLoader.load(service, cl);
    }

    //使用扩展类加载器为指定的服务创建ServiceLoader
    //只能找到并加载已经安装到当前Java虚拟机中的服务提供者，应用程序类路径中的服务提供者将被忽略
    public static &lt;S&gt; ServiceLoader&lt;S&gt; loadInstalled(Class&lt;S&gt; service) {
        ClassLoader cl = ClassLoader.getSystemClassLoader();
        ClassLoader prev = null;
        while (cl != null) {
            prev = cl;
            cl = cl.getParent();
        }
        return ServiceLoader.load(service, prev);
    }

    public String toString() {
        return "java.util.ServiceLoader[" + service.getName() + "]";
    }

}</code></pre><ol><li><strong>首先</strong>，ServiceLoader实现了Iterable接口，所以它有迭代器的属性，这里主要都是实现了迭代器的 hasNext 和 next 方法。这里主要都是调用的lookupIterator的相应hasNext和next方法，lookupIterator是懒加载迭代器。</li><li><strong>其次</strong>，LazyIterator 中的 hasNext 方法，静态变量PREFIX就是”META-INF/services/”目录，这也就是为什么需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件。</li><li><strong>最后</strong>，通过反射方法Class.forName()加载类对象，并用newInstance方法将类实例化，并把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型）然后返回实例对象。</li></ol><p>所以可以看到ServiceLoader不是实例化以后，就去读取配置文件中的具体实现，并进行实例化。而是等到使用迭代器去遍历的时候，才会加载对应的配置文件去解析，调用hasNext方法的时候会去加载配置文件进行解析，调用next方法的时候进行实例化并缓存。</p><p>所有的配置文件只会加载一次，服务提供者也只会被实例化一次，重新加载配置文件可使用reload方法。</p><h2>JDK SPI机制的缺陷</h2><p>通过上面的解析，可以发现，我们使用SPI机制的缺陷：</p><ul><li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</li><li>多个并发多线程使用 ServiceLoader 类的实例是不安全的</li></ul>]]></description></item><item>    <title><![CDATA[【2026原创】动物识别系统~Python+深度学习+人工智能+模型训练 子午 ]]></title>    <link>https://segmentfault.com/a/1190000047536634</link>    <guid>https://segmentfault.com/a/1190000047536634</guid>    <pubDate>2026-01-11 23:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>项目介绍</h2><p>动物识别系统，是一个基于深度学习技术的智能图像识别Web应用，旨在为用户提供便捷、准确的动物种类识别服务。系统采用前后端分离架构，后端基于Python Flask框架构建，集成TensorFlow深度学习框架和预训练的ResNet50卷积神经网络模型，能够实现对猫、狗、鸡、马四种常见动物的高精度识别。</p><p>系统核心功能包括用户注册登录、图片上传识别、识别历史记录查询以及系统公告管理等模块。用户通过简单的图片上传操作，即可获得动物种类识别结果及置信度信息，所有识别记录均会被妥善保存，方便用户随时查阅历史数据。系统采用JWT（JSON Web Token）进行用户身份认证，确保数据访问的安全性；管理员账户还具备发布和管理系统公告的权限，便于系统维护和用户通知。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536636" alt="图片" title="图片"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047536637" alt="图片" title="图片" loading="lazy"/></p><h2>选题背景与意义</h2><p>随着人工智能技术的快速发展，计算机视觉已成为当今科技领域最具活力的研究方向之一。图像识别作为计算机视觉的核心应用，在生物多样性研究、野生动物保护、智慧农业、宠物医疗等众多领域展现出广阔的应用前景。传统的动物识别方法主要依赖人工观察和专家鉴定，这种方式不仅耗时费力，而且受限于专业知识门槛，难以满足大规模应用需求。因此，开发基于深度学习的自动化动物识别系统具有重要的现实意义。</p><p>从学术研究角度来看，本项目以经典的ResNet50深度卷积神经网络为基础，探索了迁移学习在动物图像分类任务中的应用。通过将预训练模型与特定数据集相结合，不仅能够有效降低模型训练成本，还能在有限样本条件下实现较高的识别准确率。这种研究方法对于解决深度学习中数据标注成本高、训练周期长等问题具有积极的参考价值。</p><p>从实际应用角度来看，本系统的实现为普通用户提供了一个便捷的动物识别工具。对于宠物爱好者，系统可以帮助他们快速了解动物的品种信息；对于农业生产者，系统可以辅助进行家禽家畜的智能管理；对于教育工作者和科普工作者，系统可以作为生物多样性教育的辅助工具。此外，系统采用的模块化架构设计和RESTful API规范，为后续功能的扩展和系统集成提供了良好的基础，具有较强的实用价值和推广前景。</p><h2>关键技术栈：Flask、TensorFlow</h2><p>本系统采用Flask作为后端Web框架，这是Python生态系统中一款轻量级且功能强大的微框架。Flask具有简洁灵活、易于上手的特点，开发者可以根据项目需求自由选择各种扩展组件。在本项目中，我们使用了Flask-SQLAlchemy进行ORM数据库操作，Flask-Migrate管理数据库版本迁移，Flask-JWT-Extended实现用户身份认证，Flask-CORS处理跨域请求。这种模块化的设计使得系统架构清晰，各组件职责明确，便于维护和扩展。Flask的Blueprint机制还允许我们将用户管理、图像识别、公告管理等功能拆分为独立的模块，实现了代码的高内聚低耦合。</p><p>TensorFlow是Google开源的第二代深度学习框架，也是当前业界应用最为广泛的AI计算平台之一。本系统使用TensorFlow 2.x版本构建图像识别核心功能，该版本引入了动态图机制（Eager Execution），使得模型开发和调试过程更加直观便捷。系统集成了预训练的ResNet50模型，这是一种采用残差连接的深度卷积神经网络，通过引入Shortcut Connections有效解决了深层网络中的梯度消失问题，实现了在ImageNet数据集上的优异表现。在动物识别任务中，我们利用迁移学习技术，将ResNet50在百万级图像上学习到的通用特征表示迁移到本项目的四分类任务中，显著提升了模型性能和训练效率。</p><h2>技术架构图</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536638" alt="图片" title="图片" loading="lazy"/></p><h2>系统功能模块图</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536639" alt="图片" title="图片" loading="lazy"/></p><h2>演示视频 and 完整代码 and 安装</h2><p>地址：<a href="https://link.segmentfault.com/?enc=bg7uk3b5YzDqDgXe4enyIw%3D%3D.KCHBjqp2Pa68k46u%2FtHIvBqbS9Vslfvx7ykTFaQZfPa2vKRPekMR83nPa3OjJj%2BRzthRQCVNew6nfPFwS8hSog%3D%3D" rel="nofollow" target="_blank">https://www.yuque.com/ziwu/qkqzd2/ve3lweewyx1s3n8u</a></p>]]></description></item><item>    <title><![CDATA[主流金融数据API对比：如何获取精准、及时的IPO数据 阶段性debugger ]]></title>    <link>https://segmentfault.com/a/1190000047535563</link>    <guid>https://segmentfault.com/a/1190000047535563</guid>    <pubDate>2026-01-11 22:12:49</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>最近在做一个跟踪全球新股上市的项目，需要实时获取即将和近期 IPO 的公司信息。作为码农，我需要的是全球市场（尤其 A 股、港股、美股）的精准 IPO 信息，包括公司名、代码、上市日期、发行价、中签时间等，我试了一圈主流金融数据 API，分享一下真实的对接体验和避坑心得。</p><h2>主流 API 实测对比</h2><p><strong>Alpha Vantage</strong></p><ul><li>免费额度友好，但没有专门的 IPO 接口</li><li>需要从股票搜索和公司概况里间接拼凑信息</li><li>数据更新慢，经常延迟 1-2 天</li><li>美股为主，港股和 A 股支持弱</li><li>适合入门，但不适合精准 IPO 需求</li></ul><p><strong>Polygon.io</strong></p><ul><li>API 设计专业，WebSocket 实时性好</li><li>有 IPO 日历接口，但细节不全（缺中签率、招股书等关键信息）</li><li>美股覆盖好，非美股支持有限</li><li>起价每月几十刀，实时性高</li><li>适合高频交易，但 IPO 专业度不足</li></ul><p><strong>iTick API</strong></p><ul><li>支持<code>type=upcoming/recent</code>和<code>region=HK/US/CN</code>等多市场</li><li>字段齐全：上市时间戳、公司名、代码、交易所、价格、市值</li><li>独有的实用字段：申购开始/结束时间、中签公布时间</li><li>数据源直接对接交易所，实测港股数据与港交所官网同步</li><li>官网注册既可免费试用</li></ul><h2>实战代码示例</h2><pre><code class="python">import requests

# iTick IPO接口调用示例
url = "https://api.itick.org/stock/ipo?type=upcoming&amp;region=HK"
headers = {
    "accept": "application/json",
    "token": "your_token_here"  # 官网申请
}

response = requests.get(url, headers=headers)
if response.status_code == 200:
    data = response.json()
    if data.get("code") == 0:
        for ipo in data["data"]["content"]:
            print(f"公司: {ipo['cn']}, 代码: {ipo['sc']}, "
                  f"上市日期: {ipo['dt']}, 价格区间: {ipo['pr']}")
            # 特有字段：bs(申购开始)、es(申购结束)、ro(中签公布)</code></pre><p><strong>注意细节</strong>：<code>dt</code>字段是毫秒时间戳，<code>bs</code>/<code>es</code>/<code>ro</code>是秒时间戳，处理时需要统一单位。</p><h2>个人总结</h2><ol><li><strong>玩票性质</strong>：用 FMP 免费版或 Alpha Vantage，简单够用</li><li><strong>专业需求</strong>：直接上<strong>iTick</strong>，IPO 数据最全最及时，多市场支持好</li><li><strong>高频交易</strong>：Polygon 的实时性最好，但 IPO 细节不足</li></ol><p>最终我的项目切到了 iTick，省去了多数据源拼凑的麻烦。API 选择关键看真实需求，别为用不上功能付费。文档和频率限制提前看清楚，能少踩很多坑。</p><p>祝大家使用愉快！</p><p>参考文档：<a href="https://link.segmentfault.com/?enc=xfQiKDL1eI3rnk1JeAPR6w%3D%3D.fPVwK89Ycwdxo9UpQm7weMbszl8h%2BW%2F5zVh27yenT5bDTCWJCV3Lgz1e8%2B86Dgr11bB30%2FKwawXwVcXGL6byMQ%3D%3D" rel="nofollow" target="_blank">https://docs.itick.org/rest-api/stocks/stock-ipo</a><br/>GitHub：<a href="https://link.segmentfault.com/?enc=PHR01Tqc7Nav%2BVKd9zfenA%3D%3D.yme7kXeG%2BIeLBUKT7cRfM22bdc%2FXgozdzJxh6iKZqio%3D" rel="nofollow" target="_blank">https://github.com/itick-org/</a></p>]]></description></item><item>    <title><![CDATA[基于 YOLOv8 的 100 类中药材智能识别实战 [目标检测完整源码] 南瓜 ]]></title>    <link>https://segmentfault.com/a/1190000047535602</link>    <guid>https://segmentfault.com/a/1190000047535602</guid>    <pubDate>2026-01-11 22:11:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>基于 YOLOv8 的 100 类中药材智能识别实战 [目标检测完整源码]</h2><h3>引言：中药识别，为什么一定要“检测”而不是“分类”？</h3><p>在中药材智能识别领域，很多初学者会优先选择 <strong>图像分类模型（ResNet、EfficientNet）</strong>，但在真实业务环境中，很快就会遇到问题：</p><ul><li>一张图里 <strong>可能存在多种药材</strong></li><li>药材 <strong>大小差异大、遮挡严重</strong></li><li>需要 <strong>明确位置与类别</strong>，而不仅是“这是什么”</li></ul><p>这使得<strong>目标检测模型</strong>成为更合理的技术选择。</p><p>本文将系统介绍一个 <strong>基于 YOLOv8 的 100 类中药材检测系统</strong>，覆盖从数据集设计、模型训练，到 PyQt5 可视化部署的完整工程流程，帮助你真正“跑通一个可用的 AI 项目”。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047535604" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><hr/><h3>源码下载与效果演示</h3><p>哔哩哔哩视频下方观看：</p><p><a href="https://www.bilibili.com/video/BV1NyGxzaEP2/" target="_blank">https://www.bilibili.com/video/BV1NyGxzaEP2/</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535605" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>包含：</p><p>📦完整项目源码</p><p>📦 预训练模型权重</p><p>🗂️ 数据集地址（含标注脚本</p><h3>一、系统整体架构设计</h3><p>整个中药材识别系统由四个核心模块构成：</p><pre><code>数据集 → YOLOv8 检测模型 → 推理服务 → PyQt5 可视化前端</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535606" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047535607" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h4>技术选型说明</h4><table><thead><tr><th>模块</th><th>技术</th></tr></thead><tbody><tr><td>目标检测</td><td>YOLOv8 (Ultralytics)</td></tr><tr><td>训练框架</td><td>PyTorch</td></tr><tr><td>推理方式</td><td>Python API</td></tr><tr><td>图形界面</td><td>PyQt5</td></tr><tr><td>数据格式</td><td>YOLO Detection 标注</td></tr></tbody></table><p>该架构的优势在于：</p><ul><li><strong>训练与推理解耦</strong></li><li>可快速替换模型（n / s / m）</li><li>前端无需理解深度学习细节</li></ul><hr/><h3>二、数据集设计与类别体系</h3><h4>2.1 类别规模与特点</h4><p>本项目共包含 <strong>100 种常见中药材</strong>，涵盖：</p><ul><li>根茎类（如：人参、黄芪）</li><li>果实种子类（如：枳壳、酸枣仁）</li><li>动物药材（如：全蝎、地龙）</li><li>矿物类（如：自然铜）</li></ul><p>数据集总规模约 <strong>9,000+ 张图像</strong>，均采用 <strong>目标检测标注方式</strong>，而非整图分类。</p><h4>2.2 YOLO 标注格式</h4><p>每张图片对应一个 <code>.txt</code> 文件：</p><pre><code>&lt;class_id&gt; &lt;x_center&gt; &lt;y_center&gt; &lt;width&gt; &lt;height&gt;</code></pre><p>所有坐标均为 <strong>归一化比例值</strong>，这使得模型对分辨率变化具备天然适应性。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535608" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>三、为什么选择 YOLOv8？</h3><p>YOLOv8 是 Ultralytics 在 2023 年发布的新一代 YOLO 系列模型，在工程实践中具备明显优势：</p><h4>3.1 架构层面优势</h4><ul><li><strong>Anchor-Free 设计</strong>，减少人工先验</li><li>Task-Aligned Assigner，提高正样本质量</li><li>解耦头结构，分类与回归更稳定</li></ul><h4>3.2 工程层面优势</h4><ul><li>原生支持 <strong>Detection / Segmentation / Pose</strong></li><li>训练、推理、导出统一 API</li><li>ONNX / TensorRT 导出流程成熟</li></ul><p>对于中药材这类 <strong>小目标 + 多类别 + 实拍环境复杂</strong> 的任务，YOLOv8 的性价比非常高。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535609" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>四、模型训练流程详解</h3><h4>4.1 数据组织结构</h4><pre><code>dataset/
├── images/
│   ├── train
│   └── val
└── labels/
    ├── train
    └── val</code></pre><p>并通过 <code>yaml</code> 文件定义：</p><pre><code class="yaml">path: dataset
train: images/train
val: images/val
nc: 100
names: [...]</code></pre><h4>4.2 训练命令示例</h4><pre><code class="bash">yolo detect train \
  model=yolov8n.pt \
  data=herb.yaml \
  epochs=100 \
  batch=16 \
  imgsz=640</code></pre><h4>4.3 训练过程关注指标</h4><ul><li><code>box_loss</code>：定位质量</li><li><code>cls_loss</code>：类别区分能力</li><li><code>mAP@0.5</code>：部署可用性判断指标</li></ul><p>在实验中，当 <strong>mAP@0.5 ≥ 0.9</strong>，模型已具备稳定实用价值。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535610" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>五、推理与结果可视化</h3><h4>5.1 Python 推理接口</h4><pre><code class="python">from ultralytics import YOLO

model = YOLO("best.pt")
results = model("test.jpg", conf=0.3, save=True)</code></pre><p>YOLOv8 会自动输出：</p><ul><li>边界框</li><li>类别名称</li><li>置信度</li><li>可视化结果图</li></ul><h4>5.2 检测效果特点</h4><ul><li>对常见药材识别准确率高</li><li>对背景干扰具备一定鲁棒性</li><li>支持同图多类别检测</li></ul><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535611" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>六、PyQt5 图形界面设计</h3><p>为了降低使用门槛，项目实现了一个 <strong>桌面级可视化检测工具</strong>，支持：</p><ul><li>单张图片检测</li><li>文件夹批量检测</li><li>视频流检测</li><li>摄像头实时识别</li><li>检测结果自动保存</li></ul><h4>6.1 UI 与模型解耦</h4><p>前端仅负责：</p><ul><li>文件选择</li><li>参数配置</li><li>结果展示</li></ul><p>模型逻辑完全独立，方便后期替换或升级。</p><hr/><h3>七、工程化落地价值</h3><p>该项目不仅是一个“能跑的 Demo”，而是具备明确工程价值的系统：</p><ul><li>可用于 <strong>中药教学演示</strong></li><li>可作为 <strong>AI + 中医药</strong> 项目原型</li><li>可二次训练，扩展至更多药材</li><li>可部署为检测服务或嵌入业务系统</li></ul><hr/><h3>总结</h3><p>通过 YOLOv8 + PyQt5 的组合，我们可以用相对低的工程成本，构建一个<strong>从数据到系统完整闭环的中药材识别平台</strong>。</p><p>这个项目的意义不在于“模型有多复杂”，而在于：</p><ul><li>流程完整</li><li>结构清晰</li><li>易于复现</li><li>具备真实落地潜力</li></ul><p>本文围绕“中药材智能识别”这一典型的 AI 落地场景，系统性地介绍了一个基于 <strong>YOLOv8 的 100 类中药材目标检测工程实践</strong>。从问题背景、数据集设计、模型选型，到训练评估、推理实现以及 PyQt5 可视化部署，完整呈现了一个可复现、可扩展、可实际使用的计算机视觉项目闭环。该方案不仅验证了 YOLOv8 在多类别、小目标复杂场景下的有效性，也体现了将深度学习模型工程化、产品化的实现路径。对于希望深入理解 <strong>CV 技术如何从算法走向真实应用</strong>，或探索 <strong>AI 与中医药数字化融合</strong> 的开发者而言，该项目具备较高的学习价值与实践参考意义。</p><p>如果你正在寻找一个 <strong>兼顾算法深度与工程实用性</strong> 的计算机视觉项目，中药材目标检测无疑是一个非常好的切入点。</p>]]></description></item><item>    <title><![CDATA[6 个替代 Excel 的企业内部管理软件 NocoBase ]]></title>    <link>https://segmentfault.com/a/1190000047535665</link>    <guid>https://segmentfault.com/a/1190000047535665</guid>    <pubDate>2026-01-11 22:10:58</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>原文链接：<a href="https://link.segmentfault.com/?enc=SC3dXhCuPh9jwP5D8pBTAw%3D%3D.c6SsV0CmfpIUt7jVNAvEZBK6Gl7QDVeypsQ2qIKqSAP%2BkQkR9dWSXVdDSKkfIP%2FoSbMnI4yChO7QryeTK%2FCppz7q0pUOBfmESFLavLY%2F0RYWHIhHwgv3FPjR7MlLHM6yzo5HqU0yYcV6S4kcmiSGPQ%3D%3D" rel="nofollow" target="_blank">https://www.nocobase.com/cn/blog/6-enterprise-softwares-to-re...</a></p><h2>引言</h2><p>在企业内部运营中，Excel 仍然是使用最广泛的管理工具之一。</p><p>销售报价表、排班表、运营数据统计表……大量关键业务信息都被放进了一个个Excel表格里面，逐渐成为团队最熟悉、也最依赖的数据载体。</p><p>当这些表格开始被多个角色、多个团队同时编辑时，版本冲突、权限失控、数据口径不一致等问题几乎不可避免。</p><p>我最近在浏览在 <a href="https://link.segmentfault.com/?enc=8wuT36UWy9xVetDmu0L52A%3D%3D.2DFyzLBWIx99Zq05xHuF82I6Ez59RgPI1ouxyBo2sY0gkjXZJAGp841whCUXAqcrAv3GzenIuHGmU2rRgnbqd5BW22JEr33QZYVyt0ld7EtEOC%2F9IJ1k3%2F2UsJqMx6z31lFfd1Zr%2F82rRZUhzTIMag%3D%3D" rel="nofollow" target="_blank">Reddit</a> 发现，持续有来自不同行业、不同规模企业的从业者讨论。</p><blockquote>有没有更合适的工具可以替代 Excel？</blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535668" alt="reddit1.png" title="reddit1.png"/></p><p>这些讨论都集中在同一类问题上： 在多人协作场景下，表格难以同步，数据修改缺乏清晰记录，权限和流程能力不足，Excel 很难继续承载更复杂的业务管理需求。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535669" alt="reddit2.png" title="reddit2.png" loading="lazy"/></p><p>社区中也有不少建议，但被反复提及的，往往是 Google Sheets、Smartsheet 等大家已经非常熟悉的成熟产品。</p><p>💡 阅读更多：<a href="https://link.segmentfault.com/?enc=M%2FV7PJ3ox%2BKvmTFXXefEdg%3D%3D.KSacrsPo9uz%2FWDGo7vBCC2joqJZG4cqE1PVAeie44f7tVfk3caKzsHJPNGWFdF%2BbZhyANgIL1j%2BNY7kYEs2FR4sDw3zXl2Pla4c5T1krbLeyDFs4KbGJK4RvFFhs4z1mXRuNXanyKHeMPtwteUgZ1A%3D%3D" rel="nofollow" target="_blank">8 个最佳 Google Sheets 替代方案（附成本与能力分析）</a></p><blockquote>这些工具真的适合每一家企业，或者企业发展的每一个阶段吗？</blockquote><p>基于这样的思考，本文将不止于重复这些“耳熟能详”的选择，而是从企业内部运营的实际使用出发，结合不同管理需求和使用方式，介绍 6 个可以在不同场景下替代 Excel 的企业内部管理软件。</p><hr/><p>💬 嗨！你正在阅读 NocoBase 博客。NocoBase 是一个极易扩展的 AI 无代码/低代码开发平台，用于构建企业应用、内部工具和各类系统。它完全支持自托管，基于插件架构设计，开发者友好。→ <a href="https://link.segmentfault.com/?enc=RUTYH5559Z57Rr1WQjf0lg%3D%3D.aV9tUijDZugNhX8QzQyLTRndozsDDoteuvnX8ecHyQj09kbVz71EiWVfYkAJ0hVP" rel="nofollow" target="_blank">欢迎在 GitHub 上了解我们</a></p><hr/><p>这些产品既包括 SaaS 方案，也包括在相同场景下可选的开源替代方案。我会根据企业实际使用 Excel 的方式，分为几类进行说明。</p><ol><li>业务运营类：</li></ol><p>NocoBase（开源）</p><p>monday work management（SaaS）</p><ol start="2"><li>协作与表格类</li></ol><p>NocoDB（开源）</p><p>Airtable（SaaS）</p><ol start="3"><li>内部工具类</li></ol><p>Appsmith（开源）</p><p>Retool（SaaS）</p><h2>一、业务运营类</h2><p>这一类产品通常用于承载核心业务数据和流程规则。</p><p>原本依赖 Excel 维护的业务台账、状态规则和协作逻辑，可以被拆解为清晰的数据模型、权限和流程配置，从而将零散的表格使用转为可配置的业务系统。</p><h3><strong>NocoBase</strong></h3><ul><li><strong>产品类型</strong>：业务系统构建平台（无代码 / 低代码）</li><li><strong>开源 / 闭源</strong>：开源（Apache-2.0）</li><li><strong>部署方式</strong>：自托管（Self-hosted）</li><li><strong>目标使用对象</strong>：IT 团队、业务与职能部门、跨部门协作场景</li><li><strong>官网</strong>：<a href="https://link.segmentfault.com/?enc=7F03RUeKe%2BoJo97%2Fi0GQ1Q%3D%3D.fmO88EiLg4HuKKb4%2FtRH0lz9MLy3cFcl8oEKIG%2FzMag%3D" rel="nofollow" target="_blank">https://www.nocobase.com</a></li><li><strong>GitHub</strong>：<a href="https://link.segmentfault.com/?enc=r8SqRDwpFGR5W2d34QZ32w%3D%3D.gIMHdgRu0hfNaKtC5zG1IEKEslFtZSHFjdhP8korZkb75UF5i7zSXqYiueWdph6H" rel="nofollow" target="_blank">https://github.com/nocobase/nocobase</a></li><li><strong>GitHub Stars</strong>：21.1k</li><li><strong>文档</strong>：<a href="[https://v2.docs.nocobase.com/](https://v2.docs.nocobase.com/" target="_blank">https://v2.docs.nocobase.com/</a>)</li></ul><p><strong>概览</strong></p><p>NocoBase 是一款开源的 AI 无代码 / 低代码业务系统构建平台，用于搭建企业内部应用、运营系统和管理工具。 面向需要进行内部运营管理或跨团队协作的组织，通过自托管方式部署在企业自己的服务器或私有云环境中，适合对数据主权和系统可控性有要求的组织。</p><p>从产品定位来看，NocoBase 以数据模型为核心，面向内部业务系统的构建，而不是单纯协作表格的使用体验，更适合用来承载和管理复杂的业务结构。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535670" alt="nocobase1.png" title="nocobase1.png" loading="lazy"/></p><p>在企业内部运营中，运用 NocoBase 可以将原本分散在 Excel 表格中的业务数据、状态规则和协作关系，整理为清晰的数据模型、权限配置和流程逻辑，从而形成结构明确、可治理、也更易扩展的系统，减少对人工维护表格的依赖。</p><p><strong>核心能力</strong></p><p><strong>数据模型驱动的数据管理能力</strong></p><p>NocoBase 采用数据模型优先的设计方式，先定义业务数据结构，再构建界面和操作逻辑。数据结构与界面解耦，同一份数据可以以表格、表单、看板或图表等多种形式呈现，更适合表达真实且复杂的业务关系，而不是将所有信息堆叠在单一表格中。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535671" alt="nocobase2.png" title="nocobase2.png" loading="lazy"/></p><p><strong>多角色协作与细粒度权限控制</strong></p><p>系统内置完整的权限体系，覆盖角色、字段、数据行和操作层级。通过权限配置，企业可以清晰界定不同角色的可见范围和可执行操作，解决 Excel 在多人协作场景下权限粗糙、责任边界不清的问题。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535672" alt="nocobase3.png" title="nocobase3.png" loading="lazy"/></p><p><strong>AI 员工</strong></p><p>NocoBase 将 AI 能力以“员工”的形式嵌入到业务系统中。AI 员工可以理解当前页面、数据行和表结构，并执行查询、分析、填写表单等实际业务操作，用于数据分析、内容辅助或流程自动化，而不仅仅是提供对话式建议。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535673" alt="nocobase4.png" title="nocobase4.png" loading="lazy"/></p><p><strong>典型使用场景</strong></p><p>CRM 与客户线索管理、项目与任务管理、内部审批流与表单系统、运营数据与管理台账、ERP 模块（如订单、库存、供应商管理）、定制化内部业务系统等</p><h3>monday work management</h3><ul><li><strong>产品类型</strong>：业务运营管理平台</li><li><strong>开源 / 闭源</strong>：闭源（SaaS）</li><li><strong>部署方式</strong>：SaaS</li><li><strong>目标使用对象</strong>：业务团队、职能部门、跨团队协作场景</li><li><strong>官网</strong>：<a href="https://link.segmentfault.com/?enc=GC3FJ9tMRohYmz1scLs43w%3D%3D.0RvQaKoaf7Tui2IHfp9gHwIfiB8yICiyZTBd5Pkya9WlHsyLith7uUs1JAAug%2BQn" rel="nofollow" target="_blank">https://monday.com/work-management</a></li><li><strong>文档</strong>：<a href="[https://support.monday.com/hc/en-us](https://support.monday.com/hc/en-us" target="_blank">https://support.monday.com/hc/en-us</a>)</li></ul><p><strong>概览</strong></p><p>monday work management 是一款以协作和流程可视化为核心的 SaaS 工作管理平台，主要用于组织团队工作、管理业务进度和协调跨部门协作。产品通过云端方式交付，用户无需自行部署或维护基础设施。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535674" alt="monday1.png" title="monday1.png" loading="lazy"/></p><p>在企业内部运营中，monday work management 通常用于替代 Excel 在任务跟踪、进度管理和协作台账等场景下的使用。Excel 里需要手动更新的状态字段、负责人和截止时间，会被转移到实时同步的协作看板中，减少沟通成本和重复维护。</p><p><strong>核心能力</strong></p><p><strong>结构化看板与多视图管理</strong></p><p>monday work management 以看板为核心数据载体。 同一份数据可以通过表格、看板、时间轴、日历等视图展示，适合用于管理任务状态、项目进度和业务流程节点，比传统 Excel 更直观。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535675" alt="monday2.png" title="monday2.png" loading="lazy"/></p><p><strong>多人协作与实时状态同步</strong></p><p>平台天然支持多人同时操作，所有修改都会实时同步并保留操作记录。相比 Excel 文件反复传递和合并版本，monday 更适合持续协作和日常运营管理。</p><p><strong>智能建议与内容生成能力</strong></p><p>在 monday work management 的 AI 体系下，集成的 AI 助手可以根据上下文提供智能建议，例如为任务分配资源、生成文本摘要、整理会议记录或生成自动化流程模板等。这种能力减少了手工整理信息的负担，让团队更专注于执行和策略。</p><p><strong>典型使用场景</strong></p><p>项目与任务管理、跨部门协作、运营进度跟踪、工作台账管理、轻量级业务流程管理</p><h2>二、协作与表格类</h2><p>这一类工具，主要解决的问题是：多人协作下，Excel 作为表格和数据载体不好用。</p><p>它们关注的是在线协作、结构化表格和视图管理，而不是复杂流程或业务逻辑。</p><h3>NocoDB</h3><ul><li><strong>产品类型</strong>：协作表格数据管理工具</li><li><strong>开源 / 闭源</strong>：开源（AGPL-3.0）</li><li><strong>部署方式</strong>：自托管（Self-hosted）</li><li><strong>目标使用对象</strong>：业务团队、数据团队、需要协作管理数据的中小团队</li><li><strong>官网</strong>：<a href="https://link.segmentfault.com/?enc=FTbuMT6vPWIpzGz54U3tiA%3D%3D.t1BS1nq%2F5kkdTNMnAUU%2BWaSAr3xmy3oRC2dpl1W3XGI%3D" rel="nofollow" target="_blank">https://nocodb.com</a></li><li><strong>GitHub</strong>：<a href="https://link.segmentfault.com/?enc=uFTAYxgUdFIVXTfGJBcEhA%3D%3D.mCEv26IoSqo5VlX88NzsnlLi3o9FKT3phEgToJVW61%2B5pQn2eRN9uQxWqf%2FKtY9m" rel="nofollow" target="_blank">https://github.com/nocodb/nocodb</a></li><li><strong>GitHub Stars</strong>：61.1k</li><li><strong>文档</strong>：<a href="[https://nocodb.com/docs/product-docs](https://nocodb.com/docs/product-docs" target="_blank">https://nocodb.com/docs/product-docs</a>)</li></ul><p><strong>概览</strong></p><p>NocoDB 是一款开源的协作表格工具，常被视为 Airtable 的开源替代方案。它将现有的关系型数据库（如 MySQL、PostgreSQL）直接转换为可协作的在线表格界面，非技术用户也可以通过类似 Excel 的方式查看和维护数据。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535676" alt="nocodb1.png" title="nocodb1.png" loading="lazy"/></p><p>NocoDB 主要用于支持 Excel 在数据台账、清单管理和多人协作表格等场景下的使用。分散在多个 Excel 文件中的数据，可以集中存储在数据库中，通过统一的表格界面进行协作维护。</p><p><strong>核心能力</strong></p><p><strong>数据库即表格的协作模式</strong></p><p>NocoDB 直接基于已有数据库工作。数据库表会被映射为可编辑的在线表格，用户无需理解 SQL，也能完成数据查看和修改，降低了数据协作门槛。</p><p><strong>多人协作与基础权限控制</strong></p><p>平台支持多人同时访问和编辑同一份数据，并提供基础的权限控制能力。相比 Excel 文件反复传递，NocoDB 能避免版本冲突问题，但权限粒度相对有限，更适合轻量协作场景。</p><p><strong>AI 驱动的字段与视图建议</strong> 在编辑数据结构时，NocoAI 会根据现有上下文提供字段、关联关系和视图的推荐建议，这减少了用户对数据库结构细节的认知负担，同时提高了基础构建效率。即便是缺乏数据库经验的业务人员，也可以迅速完成基础表和视图的配置。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535677" alt="nocodb2.png" title="nocodb2.png" loading="lazy"/></p><p><strong>典型使用场景</strong></p><p>协作数据表、运营数据台账、内容或资源清单管理、轻量级内部数据维护、Airtable 替代方案</p><h3>Airtable</h3><ul><li><strong>产品类型</strong>：协作表格数据管理平台</li><li><strong>开源 / 闭源</strong>：闭源（SaaS）</li><li><strong>部署方式</strong>：SaaS</li><li><strong>目标使用对象</strong>：业务团队、运营团队、产品与项目团队</li><li><strong>官网</strong>：<a href="https://link.segmentfault.com/?enc=MyfSR5pB7jOxKGdaa9TcJA%3D%3D.cqEmruNoK35AWSBJpAJzPLeW0xX%2BBuaHANIHf7Ad%2Fps%3D" rel="nofollow" target="_blank">https://www.airtable.com</a></li><li><strong>文档</strong>：<a href="https://link.segmentfault.com/?enc=4vAn5%2B1M3gXkZO6Mws3BKg%3D%3D.5%2FmadlOb3c7Ep0wYQzhqM3sF6rYysUUaIFmi9eW95wA%3D" rel="nofollow" target="_blank">https://www.airtable.com/guides</a></li></ul><p><strong>概览</strong></p><p>Airtable 是一款以协作表格为核心的 SaaS 数据管理平台，通过将表格、视图和轻量自动化结合，帮助团队更高效地管理结构化数据。从产品定位来看，Airtable 关注的是如何让数据以表格形态被更好地协作和可视化。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535678" alt="Airtable1.png" title="Airtable1.png" loading="lazy"/></p><p>Airtable 通常用于替代 Excel 在协作数据表、运营台账和跨团队信息同步等场景下的使用。Excel 文件共享和手动维护的数据，可以通过在线表格实现实时协作和统一管理。</p><p><strong>核心能力</strong></p><p><strong>多视图的协作表格体验</strong></p><p>Airtable 在表格基础上提供了看板、日历、时间轴等多种视图。同一份数据可以从不同角度查看和维护，适合任务、资源和状态类信息的管理。</p><p><strong>字段类型与轻量规则配置</strong></p><p>平台提供丰富的字段类型和基础公式能力。用户可以在不写代码的情况下，对数据进行简单计算、校验和关联，降低表格维护成本。</p><p><strong>面向工作流的 AI 辅助能力</strong></p><p>与单纯的内容生成不同，Airtable 的 AI 更侧重于服务既有工作流。AI 可以嵌入自动化流程中，用于触发摘要、内容补全或数据路由等操作，帮助团队在保持协作表格使用习惯的同时，引入一定程度的智能化支持。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535679" alt="Airtable2.png" title="Airtable2.png" loading="lazy"/></p><p><strong>典型使用场景</strong></p><p>协作表格、运营数据管理、项目与资源台账、内容与素材管理、跨团队信息同步</p><p>💡 阅读更多：<a href="https://link.segmentfault.com/?enc=TzUQdcpGWTr1JYm3ehlF%2Fg%3D%3D.JPxR5oFzls4%2FTKfKmqh4al4jjl8nZdtejM3BzuXysOoVtmjAmn%2BKq6xnuZoI66X%2B3ziku4u%2FUGQtMEdEGz2sdhTC%2B8MlGDGGt3%2ByTrTcpsc%3D" rel="nofollow" target="_blank">Airtable 太贵了？5 个自托管替代方案成本&amp;功能对比 </a></p><h2>三、内部工具类</h2><p>这一类场景中，Excel 更多承担的是操作界面的角色。</p><p>例如数据录入、状态修改、审批操作或简单管理视图。这些产品通常提供可配置的管理界面，用于替代直接操作表格。</p><h3>Appsmith</h3><ul><li><strong>产品类型</strong>：低代码平台</li><li><strong>开源 / 闭源</strong>：开源（Apache-2.0）</li><li><strong>部署方式</strong>：自托管 / SaaS（商业版）</li><li><strong>目标使用对象</strong>：IT 团队、工程团队、需要构建内部管理界面的业务团队</li><li><strong>官网</strong>：<a href="https://link.segmentfault.com/?enc=Q27kY1QmjNPavetmsY%2ByWA%3D%3D.D%2FY254%2Fq8w6IsPXWGR9qR3XVCY4xJtW%2B%2BSvNnDKH3uY%3D" rel="nofollow" target="_blank">https://www.appsmith.com</a></li><li><strong>GitHub</strong>：<a href="https://link.segmentfault.com/?enc=SW8Vg73gyBGwbU76u35tTw%3D%3D.sybrnjmjuc9CXWOTsddo0EQuAuxjGpOqu49rZsls3P4uY3%2FCHpCSDzPmb8tY%2FCzT" rel="nofollow" target="_blank">https://github.com/appsmithorg/appsmith</a></li><li><strong>GitHub Stars</strong>：38.8k</li><li><strong>文档</strong>：<a href="https://link.segmentfault.com/?enc=kAz4dVvZERK7Vxhx0pAIfw%3D%3D.8V3A4RUZzUPHDQ%2FlQ3cZRxaj9JB8XcilDj%2FUDJuzAkE%3D" rel="nofollow" target="_blank">https://docs.appsmith.com/</a></li></ul><p><strong>概览</strong></p><p>Appsmith 是一款开源的低代码内部工具开发平台，主要用于快速构建面向内部使用的管理界面和操作后台。它通过可视化组件和数据源连接能力，让团队能够在较短时间内搭建用于数据录入、状态修改和管理操作的 Web 界面。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535680" alt="Appsmith1.png" title="Appsmith1.png" loading="lazy"/></p><p>在企业内部运营中，Appsmith 通常用于替代 Excel 在数据操作和管理界面方面的角色。原本通过 Excel 完成的数据录入、状态更新或简单审批操作，可以被迁移到结构更清晰、权限更明确的管理界面中完成。</p><p><strong>核心能力</strong></p><p><strong>可视化界面构建能力</strong></p><p>Appsmith 提供大量现成的 UI 组件，如表格、表单、按钮和图表。</p><p>用户可以通过拖拽和配置方式，快速拼装内部管理页面，而无需从零开发前端界面。</p><p><strong>多数据源连接与操作</strong></p><p>平台支持直接连接关系型数据库、REST API 以及第三方服务。界面上的操作可以直接触发数据查询和更新，使 Appsmith 成为 Excel 与后端系统之间的中间层。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535681" alt="Appsmith2.png" title="Appsmith2.png" loading="lazy"/></p><p><strong>智能驱动能力</strong> Appsmith 平台内置了与主流大型语言模型，推出了 Appsmith AI 功能，开发人员可以在应用中快速添加文本生成、分析和分类等 AI 动作。这种能力让内部工具不仅能展示数据，还能基于业务上下文自动生成内容、提取洞察和辅助分析，减少重复性工作，提高效率。</p><p><strong>典型使用场景</strong></p><p>内部管理后台、数据录入与维护界面、运营或支持工具、简单审批与操作界面、内部系统操作入口</p><p>💡 阅读更多：<a href="https://link.segmentfault.com/?enc=Px5mwsBMXRNlGf5xqTiBkQ%3D%3D.3yx3Et4OiCFfNpGXhlDF8nktXRwagqXEypxskz4%2FtXg7yEq%2B8%2F6xks9FUFTqI4bJpyDqZPjVdGw6p2lLJyWR9fVB39JAOnuMPUAHNMiNJqVABBoyuViw2A2577CRi2rp" rel="nofollow" target="_blank">五个适合小型企业使用的管理软件！（真实经验）</a></p><h3>Retool</h3><ul><li><strong>产品类型</strong>：低代码内部工具平台</li><li><strong>开源 / 闭源</strong>：闭源（SaaS，提供企业级私有部署选项）</li><li><strong>部署方式</strong>：SaaS / 私有部署（企业版）</li><li><strong>目标使用对象</strong>：工程团队、IT 团队、需要快速交付内部工具的业务团队</li><li><strong>官网</strong>：<a href="https://link.segmentfault.com/?enc=qyHiQiv9RN9hr%2FwCD0sgVQ%3D%3D.f8bCMQu%2F853fYFln5Br6cZM1iNWWcytki0pVdqUb2SE%3D" rel="nofollow" target="_blank">https://retool.com</a></li><li><strong>文档</strong>：<a href="https://link.segmentfault.com/?enc=G6n2aiXDJCCXaUXBTuK25A%3D%3D.SFwt2dvSC5w19yWmboWJq9h7Oqq6DI5%2FQH2oz0qzDPU%3D" rel="nofollow" target="_blank">https://docs.retool.com/</a></li></ul><p><strong>概览</strong></p><p>Retool 是一款以开发者效率为核心的低代码内部工具平台，用于快速构建企业内部的管理界面和操作后台。 产品以云端 SaaS 形式为主，强调与现有数据库和 API 的深度连接能力，适合需要频繁操作业务数据的内部场景。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535682" alt="Retool1.png" title="Retool1.png" loading="lazy"/></p><p>Excel 在数据操作、状态维护和内部管理界面方面的使用，Retool 均可以替代。原本通过 Excel 手动维护的数据修改和操作流程，可以被迁移到更安全、可控的 Web 管理界面中完成。</p><p><strong>核心能力</strong></p><p><strong>组件化的内部界面构建能力</strong></p><p>Retool 提供丰富的现成组件，包括表格、表单、图表和控制组件。这些组件可以快速组合成内部工具界面，减少前端开发工作量。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535683" alt="Retool2.png" title="Retool2.png" loading="lazy"/></p><p><strong>强大的数据源连接能力</strong></p><p>平台支持直接连接 PostgreSQL、MySQL 等数据库，以及 REST API 和第三方服务。界面操作可以实时触发数据查询和更新，使 Retool 成为内部系统和数据之间的高效操作入口。</p><p><strong>AI 驱动的智能开发与工作流自动化能力</strong> Retool 的 AI 能力允许用户直接在内部工具的构建过程中使用大型语言模型来生成逻辑、查询和界面代码，支持将自然语言描述转换成功能组件和业务逻辑，减少手动编写样板代码的工作量，提升开发效率。</p><p><strong>典型使用场景</strong></p><p>内部管理后台、数据操作与维护工具、运营与支持系统、审批与状态管理界面、工程团队自用工具</p><h2>如何选择适合企业的 Excel 替代方案</h2><p><strong>组织复杂度与流程成熟度</strong></p><p>如果只是单一团队内部维护清单或台账等基础需求，选择协作表格类工具已经足够了；如果涉及多个部门、明确的角色分工，甚至跨系统的数据流转，就需要考虑能否承载流程和规则的产品。</p><p><strong>治理与合规要求</strong></p><p>不同企业对数据治理的要求差异很大。是否需要细粒度的权限控制、是否需要保留完整的修改记录、数据是否必须由企业自行托管，这些都会直接影响可选工具的范围。</p><p><strong>与现有 IT 架构的适配性</strong></p><p>有些团队只需要一个独立工具，而有些场景则需要与 CRM、ERP、协作工具或数据平台打通，所以还需要考虑工具是否要融入现有系统。</p><p><strong>变更与扩展能力</strong></p><p>当规则调整或流程变化时，是通过配置就能适配，还是需要整体替换工具，会直接影响后续的维护成本和使用稳定性。</p><p>💡 阅读更多：<a href="https://link.segmentfault.com/?enc=bE8nA4PM63F3ndKytDw3BQ%3D%3D.5SnTMUuPF95WYomacXzFUSwROPwbrTxxI7ZmACob3NfDig5A1UbyOw5mp3yYsLEZF4YFt%2Bek7v3BDMp%2BOb%2BDB4h8OssO36i1wpHUoygvZqOiOpWl5HorVWmGzF%2BAuVIh" rel="nofollow" target="_blank">如何快速搭建一个替换 Excel 的系统？（完整指南）</a></p><h2>结语</h2><p>Excel 是企业内部非常重要的工具，在台账、统计和日常记录等场景中，依旧是高效且可靠的。</p><p>在合适的场景中引入企业级管理软件，与 Excel 形成更清晰的分工，企业的协作和管理往往会更加顺畅。</p><p>如果你觉得这篇内容对你有所帮助，欢迎分享给感兴趣朋友。</p><p>相关阅读：</p><ul><li><a href="https://link.segmentfault.com/?enc=kTsKndcqDS1dCqXNiPuq3A%3D%3D.Hb7Zz9SxCXfRckLKxnvgqWrDrsnf%2FiuEtvU01K4zri41mI%2BHLpFgai8IHBajSAtBj5lbTaRWjVjwa3VVH5T0JbBpLWeftadhpPV%2BhX0Pg19akedWMQLQN1brCKCIPKSs" rel="nofollow" target="_blank">开发者收藏！10 个减少重复 CRUD 的开源工具</a></li><li><a href="https://link.segmentfault.com/?enc=jQy1m%2FMZ65N%2F3D%2BLTgUrTA%3D%3D.vyFJG8nKg80mGTYekoQr%2B%2B87IDrGaMraZ6UZoePaWujnvg0jaZ5TIkdMlwO4SG2Sm3YK%2BE427C4ydrTEnV30%2FnYilZIe4f6m8RA8FTdjoC4hdDlEMSnStcuW4m%2Bg1bdB" rel="nofollow" target="_blank">GitHub Star 数量前 12 的 AI 工作流项目</a></li><li><a href="https://link.segmentfault.com/?enc=0cQq5O1FPKDjikU4RhYHGg%3D%3D.hwwdx5ZsfsqtSQWYq3XmxYOJfbA0V5qHf6Aw97LRwh%2BWffNnu7bWNo%2B9HXySKAhuYJdVjT3%2FsOIR9gsTt6X2oplhWsAmNULGjXAE2%2BeAMLDoZ7fHvwNQ0ElLqd3l3Myq" rel="nofollow" target="_blank">最适合外包交付的 6 个开源无代码与低代码</a></li><li><a href="https://link.segmentfault.com/?enc=wAK59bpbvb486BqiEMMW9w%3D%3D.aKXexBIbKaMTWMXYqDtJD6bBWosLR7IQqZmbqTissQZMGly6MWdz5ceqodnbQY9fzkAHVIb%2BnXv9hCGz3tGLkhNpDKUNohRTxLqv6M0Kj9GRD83la%2Bgz9gOmeIID6uN%2F" rel="nofollow" target="_blank">GitHub 上星星数量前 10 的 AI CRM 开源项目 </a></li><li><a href="https://link.segmentfault.com/?enc=FnKgikZuidO4FpCZjf3oSg%3D%3D.VQ3PieKwGBRXUACRV40ApJmVZBeZmpYE9ZcsMMpF%2FvxVgSxo1QaFogZ0jhPuL4IFGokYDp4ekgfNPv787BvxRkY%2FzzgeOGLF1nszVNLJnW0Js2ccXcwvsKoZmugG7lBl" rel="nofollow" target="_blank">如何快速搭建一个替换 Excel 的系统？（完整指南）</a></li><li><a href="https://link.segmentfault.com/?enc=eJcGNkKmmdWilmWDJXmIEQ%3D%3D.AqZ0A7xrnpud%2FgMdS%2BpPDHCayiHCpCuivNHZJFuyKlfhO90aWJZ0zaXZQAuxgAdppZ%2Forow2A6ibqkcLgRsLKyZ0V7hAmfEotfVpfrcKHAc%3D" rel="nofollow" target="_blank">GitHub Star 数量前 5 的开源 AI 内部工具</a></li><li><a href="https://link.segmentfault.com/?enc=wPeBACosYcGYscsrTwODAw%3D%3D.XaIM5%2FHq6EsSJXgRER661SiCImEmUa0y5btCLCV9tjVvp0p4H9K2Bs4P9PKuRHTLqQu5J6zYZAAh1QvJJtKPPYR0YkG4ohietM%2BfIqTMuN4m3MtF4E%2FP2tVWBE1tn%2Ffuu1bVlR7PIfXUpGcQTc%2FgLw%3D%3D" rel="nofollow" target="_blank">8 个最佳 Google Sheets 替代方案（附成本与能力分析）</a></li><li><a href="https://link.segmentfault.com/?enc=iG1rHR500rSbYAt5eTNDiQ%3D%3D.LOFYCO8f%2FxZn%2BPh9fLui7S%2FT8F65OdYi0JnRmd4vcoF%2FV%2BchUpGfJtXc%2Bc80rzY3oN4%2BNF%2BwyQVWAxeq4B4BJ0ZaJmASPg3e%2F%2BNV2NL1fPG4krABnt8K9xWxZRi2p%2B7%2F" rel="nofollow" target="_blank">6个适合做 PoC 的开源无代码/低代码工具推荐</a></li></ul>]]></description></item><item>    <title><![CDATA[2026-01-11 GitHub 热点项目精选 程序员锋仔 ]]></title>    <link>https://segmentfault.com/a/1190000047535732</link>    <guid>https://segmentfault.com/a/1190000047535732</guid>    <pubDate>2026-01-11 22:10:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>🌟 2026-01-11 GitHub Python 热点项目精选(15个)</h2><blockquote>每日同步 GitHub Trending 趋势，筛选优质 Python 项目，助力开发者快速把握技术风向标～</blockquote><hr/><h3>📋 项目列表（按 Star 数排序）</h3><h4>1. <a href="https://link.segmentfault.com/?enc=w4VBEZbWemkOspnPMsWSIw%3D%3D.zmWONoi1If7Bvo1GBSPNX9Ovs0owwbrWzbFG2R2e2jMmB7PDk12Oiryeo22B%2BD3W" rel="nofollow" target="_blank">NevaMind-AI/memU</a></h4><blockquote>NevaMind-AI/memU 是一个专注于人工智能领域的项目，可能是用于开发某种新型的内存管理方案或相关技术，以提升 AI 模型的运行效率和性能，比如通过优化内存分配和访问来加速神经网络的训练和推理过程，适用于需要处理大规模数据和复杂模型的 AI 应用场景。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4245（今日+80）</td></tr><tr><td>Fork 数</td><td>🔄 280</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=zgH22CvIYD9KnDZa5WXIsg%3D%3D.bf%2BiYYjf%2Bfveq8kKeFWsNFnR8DhK5PUsKLvgRRPPR3tGwb4nKn%2F3Tf5yT1DFIDU9" rel="nofollow" target="_blank">https://github.com/NevaMind-AI/memU</a></td></tr></tbody></table><hr/><h4>2. <a href="https://link.segmentfault.com/?enc=UBe%2Bs4mEyPbkXwXqn3iKCA%3D%3D.7o%2B2jjTvvHI2k8owiN19MkOh7raL9Ly%2FhpG2oIWoMdApnNOJ7wjusK9SnWGVX1u2" rel="nofollow" target="_blank">MiroMindAI/MiroThinker</a></h4><blockquote>MiroMindAI/MiroThinker 从名字上看，可能是 MiroMindAI 团队开发的一种用于思维或逻辑推理的人工智能工具，它或许能够模拟人类的思维过程，对复杂问题进行分析和解答，比如在文本理解、知识图谱构建或智能问答系统等方面发挥作用，为需要智能决策支持的领域提供解决方案。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4189（今日+310）</td></tr><tr><td>Fork 数</td><td>🔄 265</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=QOXqmI3Xp4ezXB2b7mssPg%3D%3D.4rh%2FDoySLHIi340ZDRm7tVOH1bsCrhzY9%2BQKgYFDHlnR%2BsP1Bg7Z4NpNlY0CD7fg" rel="nofollow" target="_blank">https://github.com/MiroMindAI/MiroThinker</a></td></tr></tbody></table><hr/><h4>3. <a href="https://link.segmentfault.com/?enc=tOxP049ZzYyCxnHvnPab5w%3D%3D.5Jvc32RYDV%2BOBJFSN5veDtDGngRc%2FQWkCZDv2Y4tQ3rwRHIaC9ejNbkNa931sFxH" rel="nofollow" target="_blank">hacksider/Deep-Live-Cam</a></h4><blockquote>hacksider/Deep-Live-Cam 这个项目可能涉及到深度学习与实时摄像头视频处理的结合，例如通过深度学习算法对摄像头捕获的实时视频流进行分析、识别和处理，实现诸如目标检测、行为识别、图像增强等功能，可用于安防监控、智能交通、视频会议等多种场景，让摄像头具备更智能的视觉感知能力。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 77132（今日+109）</td></tr><tr><td>Fork 数</td><td>🔄 11278</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=%2F%2Fmfe14pmXFln9PDkUxokw%3D%3D.%2FBVclFDH6rV7w75xhJ%2FEOQU29JCUp5BR9w21LcwvW0O%2B4EUxTyuuh1Qa51MRy46x" rel="nofollow" target="_blank">https://github.com/hacksider/Deep-Live-Cam</a></td></tr></tbody></table><hr/><h4>4. <a href="https://link.segmentfault.com/?enc=wdgJUCJ1VPAd2BOy9Rzxfg%3D%3D.%2F%2FqLUqT0H9gq2nXiRfCDpbznMoupdDGFani2bbgNUnbrsUNvGUZiG4CFWy4dfTGR" rel="nofollow" target="_blank">PostHog/posthog</a></h4><blockquote>PostHog/posthog 是一个开源的用户行为分析工具，它可以帮助开发者和企业更好地了解用户在网站或应用中的行为模式，通过收集和分析用户数据，如点击、浏览、转化等行为，为产品优化、市场营销和用户体验改进提供数据支持，与传统的商业分析工具相比，它更灵活且易于集成到各种项目中。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 30774（今日+18）</td></tr><tr><td>Fork 数</td><td>🔄 2186</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=LYTjcLow%2BR3Ldj3CYFtsLg%3D%3D.RMw%2FQcjvEnJse4QWbPrtlJnh8fz2L84M3NruTBUFA6LmX%2F6loTR2rEOPEobDyoYQ" rel="nofollow" target="_blank">https://github.com/PostHog/posthog</a></td></tr></tbody></table><hr/><h4>5. <a href="https://link.segmentfault.com/?enc=c3HDLue1cSGy1mBfE4n9gQ%3D%3D.HugJJrTpCx1eTH1iYOnez%2F0fn3PD5s5XpWH2xoRapIgO9bMOeOGRhrOax6lnMoKt" rel="nofollow" target="_blank">HKUDS/VideoRAG</a></h4><blockquote>HKUDS/VideoRAG 由香港大学数据科学团队开发，可能专注于视频相关的人工智能技术，如视频内容生成、视频摘要、视频检索等。它或许利用先进的深度学习算法，对视频数据进行高效的处理和分析，为视频制作、视频平台运营、视频内容推荐等领域提供创新的技术解决方案，提升视频内容的价值和用户体验。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 2278（今日+55）</td></tr><tr><td>Fork 数</td><td>🔄 303</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=Rf%2BQzELjhgzIzjuufolETg%3D%3D.SBAixiDIReMgSSLZR0JppX53nWsH0hMF06B7hKzHUHPmQ%2BVb9WzlD%2Bdpp90rgSVu" rel="nofollow" target="_blank">https://github.com/HKUDS/VideoRAG</a></td></tr></tbody></table><hr/><h4>6. <a href="https://link.segmentfault.com/?enc=fvo%2FyvNopXGjp7G1SicMwQ%3D%3D.WWEkF%2FyS7Aw%2FcQSS1byFOhP6VM%2BXjviKItEx6iGxHf64RIexzCvUlZinruBlfBqJYo8M5U8NfRNdVp%2FmyaW66w%3D%3D" rel="nofollow" target="_blank">anthropics/claude-agent-sdk-python</a></h4><blockquote>anthropics/claude-agent-sdk-python 是一个与 Claude 人工智能相关的 Python SDK（软件开发工具包）。Claude 是一种强大的语言模型，这个 SDK 可能允许开发者更方便地在 Python 环境中集成和使用 Claude 的能力，开发各种基于自然语言处理的应用程序，如智能客服、文本生成、语言翻译等，为开发者提供了便捷的接口和工具来调用 Claude 的功能。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4030（今日+25）</td></tr><tr><td>Fork 数</td><td>🔄 534</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=fuccThr5qt1rp4xoXHyNNw%3D%3D.36rEILHYlRKyUd49gufCG0QO%2B%2F67%2FneaYuEF%2BKvB%2FUO%2FJBxXZy7TVsh3V%2BTwM10XQn9PIdX39xxQjFW%2BI44noA%3D%3D" rel="nofollow" target="_blank">https://github.com/anthropics/claude-agent-sdk-python</a></td></tr></tbody></table><hr/><h4>7. <a href="https://link.segmentfault.com/?enc=j%2BkRPSP%2FRpc4LtQdWD0ASQ%3D%3D.pKl7d6j%2BFMNJT0V2wIGvPcVx5zVvNs2cNfO1lwr0wdSNiF26pHThRInnsxhhqg70" rel="nofollow" target="_blank">Arindam200/awesome-ai-apps</a></h4><blockquote>Arindam200/awesome-ai-apps 看起来是一个整理和推荐优秀人工智能应用程序的项目。它可能收集了各种类型、不同领域的 AI 应用案例，为开发者、研究人员和对 AI 感兴趣的人提供了一个参考资源库，帮助他们快速了解当前 AI 应用的发展趋势和优秀实践，激发新的创意和灵感。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 8431（今日+76）</td></tr><tr><td>Fork 数</td><td>🔄 1037</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=Sa3SzAyWSyfBe08rTn0XkQ%3D%3D.Yql5zk8IkFfA%2Fw4Irqzw5pD8BuIxySoMad0nGDt7eKjhdNmtiAnTgsemEwVxNuVV" rel="nofollow" target="_blank">https://github.com/Arindam200/awesome-ai-apps</a></td></tr></tbody></table><hr/><h4>8. <a href="https://link.segmentfault.com/?enc=2VMJHd5Xsd71qzOmqfa6Pw%3D%3D.scGTa6fOxvOTiBEv0cLnkTW7W3RnMUckkNaAIM9SV0o%3D" rel="nofollow" target="_blank">alibaba/ROLL</a></h4><blockquote>alibaba/ROLL 是阿里巴巴开源的一个项目，虽然具体细节未知，但鉴于阿里巴巴在电商、云计算、人工智能等领域的深厚技术积累，这个项目可能与大规模数据处理、机器学习平台、智能推荐系统等相关，旨在提升数据处理效率、优化算法性能或改善用户体验，为相关领域的开发者提供先进的技术框架和工具。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 2612（今日+7）</td></tr><tr><td>Fork 数</td><td>🔄 196</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=X2iW6DpZ8orNxEMMBMaMzQ%3D%3D.LYthkk0KTH4PvdCrlLooTBpKEU5zCU2NkBOKnW3WYE8%3D" rel="nofollow" target="_blank">https://github.com/alibaba/ROLL</a></td></tr></tbody></table><hr/><h4>9. <a href="https://link.segmentfault.com/?enc=zNsPjsKiCrQWh%2BaC%2BUC1ww%3D%3D.nKuHZp%2FfMCpxS%2FrZAeC92Y%2BptqjVaG8kGxJHmfS7x7yPtmDzMHZ8hXYGigZtLAfN" rel="nofollow" target="_blank">browser-use/browser-use</a></h4><blockquote>browser-use/browser-use 从名字推测，可能是与浏览器使用相关的一个项目，或许它提供了一些工具或脚本，用于分析浏览器的使用习惯、优化浏览器性能、开发浏览器扩展或插件等，帮助开发者更好地理解和利用浏览器的功能，为用户打造更优质的浏览体验或开发相关的浏览器应用。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 75209（今日+66）</td></tr><tr><td>Fork 数</td><td>🔄 8977</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=qPEGWXdW1u2%2F2Z5zZMknCA%3D%3D.cmhyjZuEWeBwMoi%2FjKAqpaalAdaY%2BCplBfrIFpiODHwpImrJxQXt85AvELq4bt4y" rel="nofollow" target="_blank">https://github.com/browser-use/browser-use</a></td></tr></tbody></table><hr/><h4>10. <a href="https://link.segmentfault.com/?enc=wXReXlspyyP2ml0X5s6O8Q%3D%3D.aGNwbaLUjs3kLORqLryCZhgLY5Syl%2FR55C8%2F6wTYcuSCjcQx2QpFZ%2F1wvJvrY75p" rel="nofollow" target="_blank">usestrix/strix</a></h4><blockquote>usestrix/strix 这个项目的具体信息不详，但从其名称和所属组织来看，可能是某种框架或工具，用于构建、部署或管理某种类型的软件系统或服务。它可能涉及到现代软件开发的热门技术，如微服务架构、容器化部署、自动化运维等，为开发者提供便捷的工具来提高开发效率和系统可靠性。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 18892（今日+161）</td></tr><tr><td>Fork 数</td><td>🔄 1964</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=xBSq8s9ly4%2FD6e5JEg1ccg%3D%3D.ycmaPUKrbFovYEbh7s82DaPBQBVOVWFVLwK5PbDDXdYvFMaNW92Lmtn%2BDyksBrPw" rel="nofollow" target="_blank">https://github.com/usestrix/strix</a></td></tr></tbody></table><hr/><h4>11. <a href="https://link.segmentfault.com/?enc=zt39mj3GgRpmgHobxhxVXA%3D%3D.ZwFp9doGOnfWVEuXQpg5%2B1bXNl8KjoO5RlQEzp1WbbDp9d%2B0qwpnk7VSEGductVz" rel="nofollow" target="_blank">Lightricks/ComfyUI-LTXVideo</a></h4><blockquote>Lightricks/ComfyUI-LTXVideo Lightricks 是一家在图像和视频编辑领域有影响力的企业，这个项目可能与视频编辑或特效相关，提供了一个用户友好的界面（ComfyUI）和某种视频处理技术（LTXVideo），让创作者能够更轻松地制作高质量的视频内容，添加各种特效、剪辑和优化视频，适用于视频创作者、广告制作、影视后期等领域。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 2833（今日+106）</td></tr><tr><td>Fork 数</td><td>🔄 277</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=7fMlF%2FSRSrdRpXed1XAIAQ%3D%3D.IixkD4V8y1JXY44EsVCQbzYQPvLOVf%2Bo%2FH1ikF7GFYeUDYhCHVpPfVPG1ha%2BV0qN" rel="nofollow" target="_blank">https://github.com/Lightricks/ComfyUI-LTXVideo</a></td></tr></tbody></table><hr/><h4>12. <a href="https://link.segmentfault.com/?enc=Ub4sWyc3IieKUo9lRvW7gw%3D%3D.XWOZjGXMbgxwVznZlXGlVdrcn6NFsLjlzaZRU9VYjeAN51EccKrvhy6CdJT41BZZ%2Bfze%2BdENEHBLKPRkRd3vyQ%3D%3D" rel="nofollow" target="_blank">EveryInc/compound-engineering-plugin</a></h4><blockquote>EveryInc/compound-engineering-plugin 可能是一个与工程开发相关的插件项目，它或许用于增强某个开发工具或平台的功能，提供复合工程能力，比如支持多种编程语言、集成多种开发工具、优化工程构建流程等，帮助开发者更高效地进行软件开发，提升团队的协作效率和项目的开发质量。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4403（今日+206）</td></tr><tr><td>Fork 数</td><td>🔄 370</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=xjilv%2FCjUDetDco%2BwgSXOA%3D%3D.oK56vsdVyTwihQA5QNEwf7B9GUQrueMFGAMhLhWJcPLW3MZZl2m8DqE6N75bk%2B1ohMCmsDHeTBsJweMW8WU%2BgA%3D%3D" rel="nofollow" target="_blank">https://github.com/EveryInc/compound-engineering-plugin</a></td></tr></tbody></table><hr/><h4>13. <a href="https://link.segmentfault.com/?enc=CbHbLUOi1%2FgJYH8KXcCwuA%3D%3D.kzc%2BB6%2BvsSzbCC2N%2F22gsnxWj7%2FRGejvHeUXG3flOiehCWDvSKOySpAfKcFm5OPb" rel="nofollow" target="_blank">NVIDIA-NeMo/NeMo</a></h4><blockquote>NVIDIA-NeMo/NeMo 是 NVIDIA 开发的一个深度学习框架，专门用于构建和训练自然语言处理（NLP）模型和语音处理模型。它提供了丰富的预训练模型和工具，方便开发者快速开发各种语言相关的应用，如语音识别、文本到语音、机器翻译等，利用 NVIDIA 强大的 GPU 硬件加速能力，提高模型训练和推理的效率，推动自然语言和语音处理技术的发展。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 16499（今日+15）</td></tr><tr><td>Fork 数</td><td>🔄 3278</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=93jJpCvDrXHRO7yUp0yHLw%3D%3D.8JvtwztehgKaLQD0zWxQNn4FymR0RDA5u3S4xqktLLf6ezQi0FGYbq3rFcjILMJ7" rel="nofollow" target="_blank">https://github.com/NVIDIA-NeMo/NeMo</a></td></tr></tbody></table><hr/><h4>14. <a href="https://link.segmentfault.com/?enc=ScqqN5x4cbFAlrDiVeGkyw%3D%3D.NHn%2B3R5bt0%2FOlYOASczo1h83%2BhFbMZgmq5dvsK42VHGzomUzTgrI%2F%2Br8OqDiW4Dz" rel="nofollow" target="_blank">bunkerity/bunkerweb</a></h4><blockquote>bunkerity/bunkerweb 这个项目可能与网络安全或 Web 应用安全相关，提供了一种保护 Web 应用免受攻击的解决方案。它可能包括防火墙、入侵检测、安全策略管理等功能，帮助企业和开发者构建更安全的 Web 应用环境，防止常见的网络攻击，如 SQL 注入、跨站脚本攻击等，保障用户数据和应用的安全。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 9756（今日+25）</td></tr><tr><td>Fork 数</td><td>🔄 557</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=bXsds4LhaqVB9zhpBKlqtg%3D%3D.OW%2BYOtAFOgR65L0vcd2ZeDMaBvrbP2NnEFJbNly0%2FVRZIeEH%2FZhwmNvdtm4SRkKD" rel="nofollow" target="_blank">https://github.com/bunkerity/bunkerweb</a></td></tr></tbody></table><hr/><h4>15. <a href="https://link.segmentfault.com/?enc=sYLsJG7yo04Jzmt0dj%2BxXw%3D%3D.%2BQ0ZaP0yl9bQVUWhZIUPmqiDWGsTZWbh7wUJKP76AhgfXd1BXz%2F08rWUVK8zrKCK" rel="nofollow" target="_blank">getzep/graphiti</a></h4><blockquote>getzep/graphiti 从名字上看，可能与图形或数据可视化相关。它或许是一个用于创建和管理图形界面、数据图表或可视化工具的项目，帮助开发者将复杂的数据以直观的图形形式展示出来，便于用户理解和分析数据，适用于数据分析、监控系统、商业智能等领域，提升数据的可读性和交互性。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 21821（今日+53）</td></tr><tr><td>Fork 数</td><td>🔄 2130</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=0Cxbp0eogCDqI%2BvewnYGpw%3D%3D.RaEplx3jn7LDf5eT9%2Bb6xWVem%2BMgbk1DLbXUrJ8k7DV0Is51bNYUrrSjC72DgEFJ" rel="nofollow" target="_blank">https://github.com/getzep/graphiti</a></td></tr></tbody></table><hr/><h3>📝 说明</h3><ul><li>数据来源：GitHub Trending（2026-01-11 每日榜单）</li><li>筛选条件：Python 语言 + 当日热门项目</li><li>自动更新：每日同步最新趋势，建议收藏本文持续关注～</li></ul><h3>⭐ 推荐理由</h3><ol><li>热门项目代表当前技术趋势，学习价值高</li><li>优质项目代码规范，可作为学习参考</li><li>部分项目可直接用于实际开发，提高效率</li></ol>]]></description></item><item>    <title><![CDATA[深入解析 DeepDiagram：如何用多智能体架构 (Multi-Agent) 重构数据可视化 小]]></title>    <link>https://segmentfault.com/a/1190000047535809</link>    <guid>https://segmentfault.com/a/1190000047535809</guid>    <pubDate>2026-01-11 22:09:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>DeepDiagram AI</strong> 是一个开源的智能可视化平台，利用 <strong>Agentic AI</strong> 将自然语言转换为专业的图表。与传统工具不同，DeepDiagram 采用了多智能体架构，由专门的智能体处理不同的可视化领域——从交互式思维导图到复杂的数据图表。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535812" alt="Image" title="Image"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535813" alt="Demo" title="Demo" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535814" alt="Demo3" title="Demo3" loading="lazy"/></p><p>项目地址：<a href="https://link.segmentfault.com/?enc=y5ml0Ts94XoWCevLMM%2Fdlw%3D%3D.uYAbG%2BBWljlll9WAHnG69x%2FXq5tMHHKKANnD24Akvg9KxRekq%2FZEHjkwnf7Kl47L" rel="nofollow" target="_blank">https://github.com/twwch/DeepDiagram</a></p><p>Demo: <a href="https://link.segmentfault.com/?enc=niLMsIaFKnICVvYWtOPTkg%3D%3D.BNKI2dIgQIwG439tZYF1EioU4CAeu6W6KKQVojZnswc%3D" rel="nofollow" target="_blank">http://121.4.104.214:81/</a></p><hr/><h2>🚀 功能特性</h2><h3>🧠 思维导图智能体 (Mind Map Agent)</h3><ul><li><strong>核心驱动</strong>: <code>mind-elixir</code></li><li><strong>能力</strong>: 生成结构化的交互式思维导图。</li><li><strong>工作流</strong>: 支持实时预览并导出为 PNG。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535815" alt="思维导图演示" title="思维导图演示" loading="lazy"/></p><h3>🧜‍♂️ 流程图智能体 (Flowchart Agent)</h3><ul><li><strong>核心驱动</strong>: <code>React Flow</code></li><li><strong>能力</strong>: 在现代交互式画布上创建详细的流程图。</li><li><strong>工作流</strong>: 支持自动布局和高质量图像导出。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535816" alt="流程图演示" title="流程图演示" loading="lazy"/></p><h3>📊 数据图表智能体 (Data Chart Agent)</h3><ul><li><strong>核心驱动</strong>: <code>Apache ECharts</code></li><li><strong>能力</strong>: 使用柱状图、折线图、饼图等可视化数据。</li><li><strong>工作流</strong>: 分析数据或描述以生成丰富的 ECharts 配置。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535817" alt="数据图表演示" title="数据图表演示" loading="lazy"/></p><h3>✏️ Draw.io 智能体</h3><ul><li><strong>核心驱动</strong>: <code>Draw.io</code> (Atlas 主题)</li><li><strong>能力</strong>: 生成与 Draw.io 生态系统兼容的专业级技术图表。</li><li><strong>工作流</strong>: 具有 <strong>自动居中</strong> 和 <strong>侧边栏隐藏</strong> 功能的高级画布，提供专注的绘图体验。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535818" alt="Draw.io 演示" title="Draw.io 演示" loading="lazy"/></p><h3>🧜‍♀️ Mermaid 智能体</h3><ul><li><strong>核心驱动</strong>: <code>Mermaid.js</code> + <code>react-zoom-pan-pinch</code></li><li><strong>能力</strong>: 生成复杂的图表，包括序列图、甘特图、时间线、状态图和类图。</li><li><strong>工作流</strong>: 原生交互式画布，支持自适应缩放、缩放/平移控制以及高分辨率 SVG/PNG 导出。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535819" alt="Mermaid 演示" title="Mermaid 演示" loading="lazy"/></p><h3>🎨 信息图智能体 (Infographic Agent)</h3><ul><li><strong>核心驱动</strong>: AntV Infographic</li><li><strong>能力</strong>: 智能生成专业的信息图、数据海报和视觉摘要。</li><li><strong>工作流</strong>: 基于声明式 DSL 语法生成，内置丰富模板，支持高质量 SVG 渲染。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535820" alt="20260107174649_rec_|690x382" title="20260107174649_rec_|690x382" loading="lazy"/></p><h3>🤖 智能路由与多模态 (Intelligent Router &amp; Multimodal)</h3><ul><li><strong>上下文感知</strong>: 基于 ReAct 的编排层，根据意图自动将请求路由到最佳智能体。</li><li><strong>多模态</strong>: 支持图像上传。上传白板照片或草图，DeepDiagram AI 即可将其数字化。</li></ul><h3>📜 持久化历史与版本分支</h3><ul><li><strong>会话管理</strong>: 支持维护多个聊天会话，自动恢复状态（包括生成的图表、当前代码和执行过程回溯）。</li><li><strong>消息分支 (Branching)</strong>: 助理响应支持“重试”并产生新分支。用户可以通过内置的分页控件在不同版本的可视化方案间灵活切换。</li><li><strong>可靠存储</strong>: 采用 PostgreSQL 存储复杂的技术执行链路和多模态数据，确保长对话的稳定检索。</li></ul><hr/><h2>✨ 用户界面优化</h2><ul><li><strong>现代聊天输入</strong>: 重新设计的输入卡片，具有整洁的边框布局和底部对齐的操作按钮（回形针用于上传，发送用于提交）。</li><li><strong>稳定布局</strong>: 图像预览位于智能体快捷方式上方，确保工具栏在上传过程中保持固定且易于访问。</li><li><strong>可调节布局</strong>: 使用专业级的可拖动分隔符灵活调整绘图画布和聊天面板的宽度。</li><li><p><strong>过程回溯操作 (Process Trace Actions)</strong>:</p><ul><li><strong>上下文渲染</strong>: 直接从过程回溯中触发特定智能体的渲染。</li><li><strong>实时反馈</strong>: 实时状态标签（例如“渲染失败”），在成功重新运行后立即清除。</li><li><strong>回溯日志</strong>: 格式化的 JSON 日志，用于调试和提高透明度。</li></ul></li></ul><hr/>]]></description></item><item>    <title><![CDATA[服务等级SLA/SLO实践观——目标设定、误报漏报与业务影响评估 南城 ]]></title>    <link>https://segmentfault.com/a/1190000047535943</link>    <guid>https://segmentfault.com/a/1190000047535943</guid>    <pubDate>2026-01-11 22:08:53</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>写在前面，本人目前处于求职中，如有合适内推岗位，请加：lpshiyue 感谢。同时还望大家一键三连，赚点奶粉钱。</strong></p><blockquote>没有 SLO 的监控系统如同没有刻度的尺子——能量长度却无法判断长短是否合适</blockquote><p>在深入探讨分布式系统的一致性模型后，我们面临一个更实际的问题：如何量化评估系统的服务质量？服务等级协议（SLA）和服务等级目标（SLO）正是将抽象的一致性理论转化为具体可度量实践的关键桥梁。本文将深入解析 SLA/SLO 的目标设定方法论、误报漏报治理策略以及业务影响评估框架，帮助您构建可度量、可管理的服务质量体系。</p><h2>1 SLA/SLO/SLI 概念体系：服务质量的可度量框架</h2><h3>1.1 概念定义与关联关系</h3><p>在分布式系统治理中，​<strong>SLA（服务等级协议）</strong>​、<strong>​SLO（服务等级目标）​</strong>​ 和<strong>​SLI（服务等级指标）​</strong>​ 构成了完整的服务质量度量体系。</p><p><strong>​SLI（服务等级指标）​</strong>​ 是服务质量的具体量化指标，是系统行为的直接度量。常见 SLI 包括请求成功率、响应时间、吞吐量等。SLI 的本质是​<strong>将主观用户体验转化为客观数据指标</strong>​。</p><p><strong>​SLO（服务等级目标）​</strong>​ 是为 SLI 设定的目标值或目标范围，是服务对自身可靠性的内部承诺。SLO 定义了“什么样的服务质量算是合格”，例如“99.9% 的请求成功率”或“95% 的请求延迟小于 200ms”。</p><p><strong>​SLA（服务等级协议）​</strong>​ 是服务提供者与用户之间的正式协议，描述了未达到 SLO 时的后果。区别 SLO 和 SLA 的简单方法是问：“如果 SLO 没有达到时，有什么后果？”如果没有定义明确的后果，那么就是在讨论 SLO 而非 SLA。</p><h3>1.2 四大黄金指标：SLI 的核心维度</h3><p>基于 Google SRE 实践，<strong>四大黄金信号</strong>为定义 SLI 提供了基础框架：</p><ul><li>​<strong>延迟（Latency）</strong>​：请求处理速度，通常使用分位数（如 P99、P95）而非平均值</li><li>​<strong>流量（Traffic）</strong>​：系统负载压力，如 QPS（每秒查询数）、并发连接数</li><li>​<strong>错误（Errors）</strong>​：请求失败率，包括显性错误（如 5xx 状态码）和隐性错误（如超时）</li><li>​<strong>饱和度（Saturation）</strong>​：系统资源利用程度，如 CPU 使用率、内存占用</li></ul><p>这些指标几乎适用于所有服务，但需要根据具体业务场景进行定制化。</p><h2>2 SLO 目标设定的科学方法论</h2><h3>2.1 目标设定的平衡艺术</h3><p>合理的 SLO 需要在<strong>用户期望</strong>与<strong>工程成本</strong>之间找到平衡。设定 99.99% 的可用性目标意味着每月仅允许 4.38 分钟故障时间，需要冗余架构和大量运维投入——对于内部工具而言，这样的成本可能并不值得。</p><p><strong>目标设定流程</strong>应遵循以下步骤：</p><ol><li>​<strong>测量当前性能</strong>​：收集 2-4 周的性能数据作为基线</li><li>​<strong>理解用户需求</strong>​：通过用户调研确定可接受的服务质量范围</li><li>​<strong>设定略高于现状的目标</strong>​：既要具备挑战性又要可实现</li><li>​<strong>迭代调整</strong>​：根据错误预算消耗情况持续优化</li></ol><h3>2.2 错误预算：可靠性的通用货币</h3><p><strong>错误预算</strong>是 SLO 框架的核心创新概念，彻底改变了可靠性的讨论方式。它不再追求“100% 可用性”（这根本不可能实现），而是承认“我们有一定的故障预算，应将其用于创新而非应对恐慌”。</p><p>错误预算的计算公式为：</p><pre><code>错误预算 = 1 - SLO目标</code></pre><p>例如，99.9% 可用性 SLO 对应的错误预算为 0.1%。</p><p>错误预算为工程决策提供了客观依据：</p><ul><li>​<strong>绿色区域（预算 &gt;75%）</strong>​：可自由发布功能，允许承担风险</li><li>​<strong>黄色区域（预算 25%-75%）</strong>​：需审核变更请求，优先选择低风险改进</li><li>​<strong>红色区域（预算 &lt;25%）</strong>​：冻结功能发布，专注于提升可靠性</li></ul><h3>2.3 多时间窗口策略：平衡灵敏度与稳定性</h3><p>SLO 的时间窗口选择需要平衡<strong>检测灵敏度</strong>与​<strong>统计稳定性</strong>​：</p><ul><li>​<strong>短窗口（如 1 小时）</strong>​：能快速发现问题，但容易因短暂波动误报</li><li>​<strong>长窗口（如 30 天）</strong>​：提供稳定视图，但问题检测延迟高</li></ul><p>实践中推荐​<strong>多时间窗口策略</strong>​：使用短窗口用于实时告警，长窗口用于趋势分析和长期规划。</p><h2>3 误报与漏报：监控警报的精准治理</h2><h3>3.1 误报漏报的根本原因分析</h3><p><strong>​误报（False Positive）​</strong>​ 和<strong>​漏报（False Negative）​</strong>​ 是监控系统面临的核心挑战。误报导致警报疲劳，使团队对真实问题变得麻木；漏报则意味着真实问题未被及时发现，影响用户体验。</p><p>误报的常见根源包括：</p><ul><li>​<strong>阈值设置不合理</strong>​：过于敏感或基于错误假设</li><li>​<strong>数据噪声</strong>​：短期波动被误认为趋势性变化</li><li>​<strong>监控盲点</strong>​：关键指标未被覆盖或测量位置不当</li></ul><h3>3.2 基于燃烧率的智能告警机制</h3><p>传统基于固定阈值的告警机制在应对不同负载模式时表现不佳。<strong>​燃烧率（Burn Rate）​</strong>​ 告警通过度量错误预算的消耗速度，实现了更智能的告警触发。</p><p>燃烧率定义为错误预算消耗百分比与 SLO 时间窗口已过去百分比的比值。例如，燃烧率为 2 表示按当前速度，错误预算将在半段时间内耗尽。</p><p><strong>多窗口多燃烧率告警机制</strong>可同时避免误报和检测延迟：</p><ul><li>​<strong>快速消耗告警</strong>​：1 小时内消耗 2% 预算，立即通知相关人员</li><li>​<strong>缓慢消耗告警</strong>​：6 小时内消耗 5% 预算，创建工单用于后续调查</li></ul><h3>3.3 告警精准度优化策略</h3><p>提高告警精准度需要综合技术手段与流程优化：</p><p>​<strong>技术层面</strong>​：</p><ul><li>​<strong>条件组合</strong>​：结合多个相关指标共同判断，而非单一指标阈值</li><li>​<strong>平滑处理</strong>​：使用移动平均或指数加权平均减少瞬时波动影响</li><li>​<strong>异常检测</strong>​：应用机器学习算法识别真正异常模式</li></ul><p>​<strong>流程层面</strong>​：</p><ul><li>​<strong>定期评审</strong>​：每月审查告警规则的有效性和准确性</li><li>​<strong>反馈闭环</strong>​：对每条告警进行标记分类（真阳性/假阳性）</li><li>​<strong>明确升级路径</strong>​：为不同严重级别告警定义明确处理流程</li></ul><h2>4 业务影响评估：从技术指标到商业价值</h2><h3>4.1 服务分级与优先级划分</h3><p>不是所有服务都对业务有同等影响，需要根据<strong>业务影响</strong>对服务进行分级：</p><p>​<strong>L0 级（核心业务）</strong>​：直接影响营收和核心用户体验的服务，如电商交易链路、支付系统。这类服务需要最严格的 SLO（如 99.95%+ 可用性）和最及时的告警响应。</p><p>​<strong>L1 级（重要业务）</strong>​：支撑核心业务的关键服务，如用户认证、商品搜索。SLO 要求较高（99.9%+ 可用性），但不至于像 L0 级那样严格。</p><p>​<strong>L2 级（辅助业务）</strong>​：增强型功能服务，如推荐系统、评价服务。可采用相对宽松的 SLO（99%+ 可用性）。</p><h3>4.2 影响量化与经济损失评估</h3><p>将技术指标转化为业务影响是 SLO 管理的核心价值。通过建立​<strong>技术指标与业务 KPI 的关联模型</strong>​，可以量化服务质量下降的经济影响：</p><pre><code>经济损失 = 故障时长 × 受影响用户比例 × 用户平均价值 × 转化率影响因子</code></pre><p>例如，电商网站可用性下降 1% 可能直接导致营收损失，可通过历史数据建立回归模型精确估算。</p><h3>4.3 错误预算的跨部门协同</h3><p>错误预算不仅是技术概念，更是​<strong>跨部门协同的通用语言</strong>​。通过将错误预算纳入产品路线图讨论，工程团队与产品团队可以在功能开发与可靠性投入间做出数据驱动的决策。</p><p>当错误预算充足时，团队可以承担更大技术风险，加速功能迭代；当预算紧张时，则需优先进行稳定性优化。这种机制有效平衡了创新速度与系统可靠性。</p><h2>5 SLO 实施路线图与成熟度模型</h2><h3>5.1 分阶段实施策略</h3><p>SLO 实施应遵循​<strong>渐进式路径</strong>​，避免一次性全面铺开：</p><p><strong>阶段一：试点探索</strong></p><ul><li>选择 1-2 个关键服务作为试点</li><li>定义基础 SLI（可用性、延迟）</li><li>建立简单 SLO（基于历史性能）</li><li>实施基础告警机制</li></ul><p><strong>阶段二：扩展推广</strong></p><ul><li>扩大覆盖范围至核心业务链路</li><li>完善 SLI 体系（增加吞吐量、饱和度指标）</li><li>建立错误预算管理机制</li><li>实施燃烧率告警</li></ul><p><strong>阶段三：全面集成</strong></p><ul><li>全业务服务 SLO 覆盖</li><li>SLO 与业务规划流程深度集成</li><li>自动化错误预算管理与决策支持</li><li>建立持续优化文化</li></ul><h3>5.2 成熟度评估模型</h3><p>组织 SLO 实践成熟度可从多个维度评估：</p><p>​<strong>初始级</strong>​：缺乏明确定义的 SLO，监控告警基于基础设施指标而非用户体验。</p><p>​<strong>可重复级</strong>​：核心服务有基础 SLO 定义，但尚未系统化应用错误预算概念。</p><p>​<strong>已定义级</strong>​：建立了完整的 SLO 体系，错误预算开始影响技术决策。</p><p>​<strong>已管理级</strong>​：SLO 与业务目标深度对齐，错误预算驱动资源分配决策。</p><p>​<strong>优化级</strong>​：SLO 实践持续优化，形成数据驱动的可靠性文化。</p><h2>6 实战案例：电商大促 SLO 保障实践</h2><h3>6.1 大促特殊场景的 SLO 调整</h3><p>电商大促（如双 11）期间，流量模式与平常有显著差异，需要​<strong>特殊 SLO 策略</strong>​：</p><p>​<strong>预案准备阶段</strong>​：</p><ul><li>基于历史数据预测流量峰值和模式变化</li><li>制定弹性 SLO 目标，适当放宽非核心指标要求</li><li>准备降级方案，明确各服务的优先级关系</li></ul><p>​<strong>大促执行阶段</strong>​：</p><ul><li>实时监控错误预算消耗速率</li><li>实施动态限流和降级策略保护核心链路</li><li>建立战时决策机制，快速响应异常情况</li></ul><h3>6.2 全链路 SLO 协同保障</h3><p>电商交易涉及多个服务协同，需要​<strong>端到端 SLO 管理</strong>​：</p><p>​<strong>依赖关系梳理</strong>​：明确各服务间的依赖关系，识别关键路径上的瓶颈点。</p><p>​<strong>SLO 分配优化</strong>​：根据依赖关系合理分配各服务的 SLO 目标，确保端到端体验达标。例如，如果交易链路包含 5 个服务，每个服务 99.9% 的可用性只能实现 99.5% 的整体可用性。</p><p>​<strong>跨团队协作机制</strong>​：建立依赖服务间的 SLO 协同机制，明确服务提供者与消费者的责任边界。</p><h2>总结</h2><p>SLA/SLO 实践的本质是将可靠性管理从​<strong>艺术转变为科学</strong>​，为分布式系统治理提供客观、量化的决策基础。通过建立完整的 SLI 指标体系、设定合理的 SLO 目标、实施精准的告警机制以及开展业务影响评估，组织可以系统化地平衡创新速度与系统稳定性。</p><p><strong>核心成功要素​</strong>包括：高层支持与跨部门协同、循序渐进的实施策略、数据驱动的文化转变以及持续优化的反馈机制。只有当 SLO 成为组织通用语言时，技术可靠性才能真正转化为业务价值。</p><p>值得注意的是，SLO 实践不是一成不变的公式，而需要根据组织特点和业务场景灵活适配。从简单开始、持续迭代、聚焦用户体验，才是 SLO 成功落地的关键。</p><hr/><p><strong>📚 下篇预告</strong>​</p><p>《微服务化的收益与成本复盘——技术、组织与运维维度的综合账本》—— 我们将深入探讨：</p><ul><li>⚖️ ​<strong>收益成本平衡</strong>​：微服务拆分在开发效率与系统复杂度间的真实权衡</li><li>🏗️ ​<strong>技术债务评估</strong>​：分布式架构引入的隐性成本与治理挑战</li><li>👥 ​<strong>组织架构影响</strong>​：康威定律在微服务拆分中的实践验证与调适</li><li>🔧 ​<strong>运维复杂度升级</strong>​：从单体部署到分布式协调的运维范式转变</li><li>📊 ​<strong>投资回报框架</strong>​：微服务化决策的定量评估模型与复盘方法论</li></ul><p><strong>​点击关注，掌握微服务架构的综合评估能力！​</strong>​</p><blockquote><p>​<strong>今日行动建议</strong>​：</p><ol><li>选择核心业务服务，定义 3-5 个关键 SLI 并建立基线测量</li><li>基于历史数据设定初步 SLO 目标，建立错误预算概念</li><li>评审现有告警规则，识别误报漏报并优化阈值设置</li><li>建立 SLO 评审机制，定期评估目标合理性并持续优化</li></ol></blockquote>]]></description></item><item>    <title><![CDATA[『NAS』在群晖部署图片压缩工具-Squoosh 德育处主任 ]]></title>    <link>https://segmentfault.com/a/1190000047536002</link>    <guid>https://segmentfault.com/a/1190000047536002</guid>    <pubDate>2026-01-11 22:08:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p><blockquote>整理了一个NAS小专栏，有兴趣的工友可以关注一下 👉 <a href="https://link.segmentfault.com/?enc=XM0iYuIXvHbU7j6AEkwrFw%3D%3D.ViI129TyrctE8SvOmCnubuxbJlW3auhvnKgn41Vzmbnacmc9UPCDBLZPHfMiHtSL2hbYHF81DSaKgaSbJ5pzOGEUdchm8ZJGGUy3RbMCsn%2FMy76nYfWJxsoN5rp%2FqO4p4cORKXISIFol7Q4kTTQfSkKSqXP5wT7iZJ54Z59qyXI%3D" rel="nofollow" target="_blank">《NAS邪修》</a></blockquote><p>Squoosh 是一款本地运行的免费在线图片压缩工具，操作简单且注重隐私安全，可在保持图片高质量的前提下减小文件体积</p><p><img width="723" height="520" referrerpolicy="no-referrer" src="/img/bVdnCrL" alt="01.png" title="01.png"/></p><p>按照惯例，在 <code>docker</code> 目录下创建  <code>squoosh</code> 文件夹。</p><p><img width="723" height="327" referrerpolicy="no-referrer" src="/img/bVdnCrN" alt="02.png" title="02.png" loading="lazy"/></p><p>打开“Container Manager”，新增一个项目。</p><p>按照下图所示配置。</p><p><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdnCrO" alt="03.png" title="03.png" loading="lazy"/></p><p>要输入的代码如下：</p><pre><code>services:
    squoosh:
        image: hausen1012/squoosh:latest
        container_name: squoosh
        ports:
            - 7080:80
        restart: unless-stopped</code></pre><p>在“网页门户设置”里启用“通过 Web Station 设置网页门户”。</p><p><img width="723" height="581" referrerpolicy="no-referrer" src="/img/bVdnCrP" alt="04.png" title="04.png" loading="lazy"/></p><p>在“Web Station”，新增一个网络门户。</p><p>服务选择“squoosh”，其他配置按你所需即可，你也可以按照我这么配。</p><p>需要注意端口不要跟其他项目冲突。</p><p><img width="723" height="402" referrerpolicy="no-referrer" src="/img/bVdnCrQ" alt="05.png" title="05.png" loading="lazy"/></p><p>一切准备就绪后，在浏览器输入你NAS的IP地址，后面跟上在“Web Station”给Squoosh 配置的端口号就能看到 Squoosh 的界面了。</p><p><img width="723" height="520" referrerpolicy="no-referrer" src="/img/bVdnCrL" alt="01.png" title="01.png" loading="lazy"/></p><p>点击页面中间粉红色区域就可以上传你要压缩的图片了。但这个图片不会传到别人的服务器，一切都是在你本机运行的。</p><p>上传完的图片可以按照你自己需求调整选项进行压缩。</p><p><img width="723" height="427" referrerpolicy="no-referrer" src="/img/bVdnCrM" alt="06.png" title="06.png" loading="lazy"/></p><hr/><p>以上就是本文的全部内容啦，想了解更多NAS玩法可以关注<a href="https://link.segmentfault.com/?enc=Z2%2FT2bqvNOrLW1dqEdvL3A%3D%3D.oCgEpzLexCrJQxPWUXrnSFGJleiyX2Nsf4T0E8lVXLiGT%2FzH5thQDDNfNA0AEwCNy4SbvcYU1CjjKqMZ55sbzE9YSo5SsmzDNhTA8sM%2B2B4sXHtA28Mckhxis%2B1wdfHCxYXTrao5MgfSa5VIegP2e87ysxM9d25MNPPetNf4I84%3D" rel="nofollow" target="_blank">《NAS邪修》</a></p><p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p>]]></description></item><item>    <title><![CDATA[基于HarmonyOS的智慧教室场景设计 三纲 ]]></title>    <link>https://segmentfault.com/a/1190000047536008</link>    <guid>https://segmentfault.com/a/1190000047536008</guid>    <pubDate>2026-01-11 22:07:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>一、系统概述</p><p>1项目背景</p><p>随着科技的不断进步，教育行业正在经历深刻的变革。现代教育越来越强调智能化、个性化和高效化。传统的校园管理模式和教学手段已经难以满足日益增长的教育需求，学校需要借助先进的技术手段来提升管理效率、优化教学环境，为师生提供更加便捷、安全和智能的校园生活体验。 </p><p>2项目目标</p><p>利用HarmonyOS 的分布式技术可以实现校园内各种设备的互联互通，打破信息孤岛。通过智慧班牌实现校园信息的集中展示和快速传递，包括课程安排、考勤情况、校园公告等，减少信息传递的中间环节，提高信息传递的准确性和及时性。同时，智慧班牌的考勤功能可以自动记录师生的出勤情况，为学校的教务管理提供数据支持，简化考勤统计流程。利用智慧门锁实现校园门禁的智能化管理，提高校园门禁的安全性和便捷性。通过蓝牙遥控技术实现对教室灯和风扇的远程控制和智能调节，方便师生使用。在校园重点区域安装明火检测设备，实时监测是否存在明火隐患。一旦检测到明火，能够立即发出警报并通知相关人员，及时采取措施防止火灾发生，保障校园师生的生命财产安全，营造安全的校园环境。</p><p>二、总体方案</p><p>1系统架构<br/><img width="429" height="702" referrerpolicy="no-referrer" src="/img/bVdnCrk" alt="" title=""/><br/> </p><p>2 北向设计</p><pre><code>手机端作为控制中心，教师可以通过手机端发起签到、选人、控制课室设备，学生可以查看课程信息和课程成绩以及打卡签到。手机端的数据与大屏幕数据显示端和硬件部分进行交互，例如，打卡签到的数据会被传输到后台系统，并在大屏幕上显示。
手机端主要功能模块有：
（1）登录页面：学生和教职工通过账号和密码登录系统进入个人主页。
（2）个人主页：显示课程信息，包括上课时间地点和课程名称；提供打卡签到功能，学生通过位置打卡签到；展示一周的课程表；提供查询课程成绩功能大屏幕作为信息展示平台，
大屏幕的数据来源于硬件部分的传感器和手机端的操作记录，例如，环境监测数据由硬件部分的传感器采集并传输到大屏幕上显示。主要功能模块有：
（1）环境监测：通过绘制图表直观地显示当前温湿度、光照、火焰的环境数据。
（2）课程信息：显示当前课程名称、上课时间、应到人数和实到人数。
（3）打卡签到：显示签到情况，包括已签到和未签到的人员名单。</code></pre><p>本系统设计采用的是Nova14 Pro手机，HarmonyOS5.0版本</p><p>3 南向设计</p><pre><code>（1）设备控制模块：通过hi3861 MQTT客户端控制风扇、台灯、门锁设备。
（2）环境监测模块：包括温度传感器、湿度传感器、光照传感器和火焰传感器，通过hi3861 MQTT客户端进行采集和传输数据。
（3）hi3861 MQTT客户端：作为中间层，连接设备控制模块和环境检测模块，负责将设备状态和环境数据发布到华为云IoT MQTT服务器。
（4）华为云IoT MQTT服务器：接收来自hi3861 MQTT客户端的数据，把数据发布到AGC云进行存储和处理，处理后的数据显示在手机和大屏上。 
</code></pre><p>4 数据处理流程</p><pre><code>硬件部分的传感器实时采集环境数据，并将数据传输到后台系统，再由后台系统将数据推送到大屏幕数据显示端进行展示。打卡设备记录用户的签到信息，并将数据传输到后台系统，用于在大屏幕和手机端显示签到情况。
</code></pre><p>三、功能模块划分与组成</p><p>3.1手机端</p><p>1.登录及注册界面   <br/><img width="413" height="271" referrerpolicy="no-referrer" src="/img/bVdnCrm" alt="image.png" title="image.png" loading="lazy"/></p><pre><code>教师和学生可选择账号密码、手机号、邮箱登录三种登陆方式进入应用，操作便捷。对于未持有账号的用户，需用户真实姓名，手机号，用户邮箱信息进行身份注册。多重信息验证方便后续登录及提高身份安全性和准确性。 
</code></pre><p>2.教师功能模块 <br/><img width="504" height="271" referrerpolicy="no-referrer" src="/img/bVdnCrt" alt="image.png" title="image.png" loading="lazy"/></p><pre><code>(1) 教师界面展示 教师首页首先顶部展示了该名教师的头像、教师的名字、以及教授的课程。中间部分展示了该教师当前的上课课程信息。在此之后设有三个功能模块，分别是发起签到，选人，智慧控制模块，点击单个模块的箭头进入模块进行操控。
(2) 发起签到 通过首页进入教室发起签到界面，该界面简洁的展示了重要的信息，教师可以根据自己教授的班级，选择当前课程对应的班级发起打卡签到。该模块可以根据人脸识别来进行打卡签到的活动。
(3) 随机选人 同理，进入选人界面，该功能是随机选择班级学生进行回答问题。被选中的学生会在学生端收到提醒信息。(4).智慧控制 智慧控制模块，教师可以查看当前教室的智能设备状态，并且拥有手动控制的权限。教师可对灯光和门锁进行开关调节。风扇设有三档调节，可自行选择风扇挡位。 
</code></pre><p>3.学生功能模块  <br/><img width="543" height="554" referrerpolicy="no-referrer" src="/img/bVdnCru" alt="image.png" title="image.png" loading="lazy"/></p><pre><code>(1) 学生界面展示 首先界面顶部展示了学生的头像、学生的名字和学生的班级信息。中间部分展示了该学生当前的上课介绍，其次有学生可操控的三个模块分别是接收教师端发起的打卡签到活动；学生可查看自己的课程表；查看学生自己的当前课程的课程成绩。可通过点击该模块进入。
(2) 打卡签到模块 通过学生进入打卡签到界面，学生点击开始进入人脸识别，识别成功就会显示打卡成功，识别失败就会显示打卡失败并重新进行打卡。
(3) 课程表模块展示 学生进入课程表展示模块，可查看该学生的一周课程情况，点击某课程可详细查看课程内容。
(4) 课程成绩模块 该模块展示了该学生当前课程的学习情况。首先展示的是学生的基本信息，其次下面展示了本门课程以及该学生对该门课程的掌握情况，表现形式为课堂表现、作业完成、期末分数的得分。
</code></pre><p>3.2大屏幕数据显示端</p><p>1.首页信息展示<br/><img width="543" height="338" referrerpolicy="no-referrer" src="/img/bVdnCrv" alt="image.png" title="image.png" loading="lazy"/></p><pre><code>（1）大屏幕首页界面顶部展示当前日期、时间、温度、湿度、光照强度的具体数值和火焰报警系统状态，合适的温度和湿度，光照强度有助于营造良好的学习环境，火焰报警系统也能提高火灾安全的及时性和人员安全，这些数据可以作为环境管理的参考。
（2）教室日志和教室轮播图便于师生观察教室的动态，如教室日志记录教室环境每分钟的变化情况，教室轮播图查看教室布局详情。以便师生了解教室情况，有助于优化教学环境。 
</code></pre><p>2.打卡签到信息展示<br/><img width="554" height="350" referrerpolicy="no-referrer" src="/img/bVdnCrw" alt="image.png" title="image.png" loading="lazy"/></p><pre><code>(1) 采用打卡签到，能方便教师对学生的出勤情况进行记录和管理。通过系统自动统计实到人数和应到人数，教师可以快速了解班级的出勤情况，无需手动点名，节省时间。
(2) 能准确记录学生出勤情况，便于教师管理、教学调整，同时也有助于学校对整体教学秩序进行监控和管理。
</code></pre><p>3.课程表信息展示<br/><img width="557" height="354" referrerpolicy="no-referrer" src="/img/bVdnCry" alt="image.png" title="image.png" loading="lazy"/></p><pre><code>(1) 课程表以时间 / 节次为纵轴，从早上 8:00 开始，一直到晚上 21:30，详细列出了一天中不同时间段的课程安排。这样设计让师生可以很清楚地知道自己在每个时间段是否有课，便于合理规划自己的时间。
(2)通过颜色区分了上午、下午和晚上的课程。比如，上午的课程背景是白色，下午的课程背景是浅蓝色，晚上的课程背景是浅黄色。这样的设计使得师生可以快速区分不同时间段的课程，能让师生能迅速定位特定教室的课程分布。
(3)课程表信息页展示该教室一周全时间段的课程安排，点击具体课程可查看该课程的具体信息，如课程名称、课程老师、课程地点、课程简介等。这样设计的好处是简洁美观、关键信息一目了然 、避免信息遗漏，提升了信息获取的效率。
</code></pre><p>4.环境监测信息展示<br/><img width="561" height="354" referrerpolicy="no-referrer" src="/img/bVdnCrz" alt="image.png" title="image.png" loading="lazy"/></p><pre><code>在环境监测中实现可视化图，能够将复杂的环境数据（如温度、湿度等）以直观的图表形式展示出来，便于快速理解数据趋势和变化。
</code></pre><p>3.3家居设备端</p><p>3.3.1 台灯<br/><img width="380" height="505" referrerpolicy="no-referrer" src="/img/bVdnCrA" alt="image.png" title="image.png" loading="lazy"/><br/>1.功能</p><pre><code>（1）此台灯利用PWM控制占空比实现了灯光的亮度调节以及可以控制色温调节，以满足不同场景下的照明需求。
（2）具备智能功能，此台灯结合了光照传感器可以根据环境光线自动调整台灯的亮度，这个设置了自动调节灯光亮度的阈值，当环境的光线大于阈值的时候，台灯亮度变小，当环境的光线小于阈值的时候，台灯亮度变大。
（3）能够通过手机端远程控制，方便用户操作。</code></pre><p>2.连接：<br/>    台灯应与手机端通过蓝牙或者wifi等无线方式连接，以便实现远程控制；同时与环境检测设备连接，如火焰传感器，以获取环境光线数据实现智能调节。</p><p>3.3.2风扇<br/><img width="508" height="384" referrerpolicy="no-referrer" src="/img/bVdnCrB" alt="image.png" title="image.png" loading="lazy"/><br/>1.功能</p><pre><code>（1）能够进行风速调节，有三个档位可供选择。·
（2）智能模式，例如根据室内温度自动调节风速。· </code></pre><p>2.连接：</p><pre><code>通过无线连接（如 Wi - Fi、蓝牙）与手机端连接实现远程控制；还可能与室内温度传感器连接，获取温度数据来实现智能风速调节。
</code></pre><p>3.3.3门锁<br/><img width="412" height="544" referrerpolicy="no-referrer" src="/img/bVdnCrI" alt="image.png" title="image.png" loading="lazy"/><br/>1.功能：</p><pre><code>可通过手机端远程控制临时开锁。</code></pre><p>2.连接：</p><pre><code>通过蓝牙或 Wi - Fi 与手机端连接实现远程控制。
</code></pre><p>四、系统UI展示</p><p> 1.手机端展示<br/><img width="488" height="562" referrerpolicy="no-referrer" src="/img/bVdnCrR" alt="image.png" title="image.png" loading="lazy"/><br/><img width="486" height="551" referrerpolicy="no-referrer" src="/img/bVdnCrU" alt="image.png" title="image.png" loading="lazy"/></p><p> 2.大屏幕展示   <br/><img width="525" height="681" referrerpolicy="no-referrer" src="/img/bVdnCrW" alt="image.png" title="image.png" loading="lazy"/><br/>   </p>]]></description></item><item>    <title><![CDATA[C++化身孙悟空——吃俺老孙25棒！ 李兴球 ]]></title>    <link>https://segmentfault.com/a/1190000047536170</link>    <guid>https://segmentfault.com/a/1190000047536170</guid>    <pubDate>2026-01-11 22:06:45</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img width="720" height="720" referrerpolicy="no-referrer" src="/img/bVdnCuy" alt="C++孙悟空的72变小动画" title="C++孙悟空的72变小动画"/><br/>哎哟喂，各位还在翻着老黄历吗？是不是还觉得C++就是那个住在山洞里、满头白发、还要你手动推石磨豆腐的“老古董”？而Python则是那个坐在空调房里喝着快乐肥宅水、指哪打哪的“新贵”？</p><p>打住打住！现在是21世纪，是5G、AI、元宇宙满天飞的时代，咱们这位C++老祖宗早就偷偷升级了固件，穿上外骨骼装甲了！C++不仅没被时代淘汰，反而直接开启了“赛博朋克”模式，摇身一变，成了编程界的“变形金刚”。</p><p>不信？来看看这段《孙悟空的72变动画》代码，这哪里是写程序，这分明是在玩一款低代码的“沙盒游戏”！</p><p>你看那个叫monkey的对象，它哪里是什么普通的角色，它分明就是一个经过“深度学习”加持的智能NPC！以前写个图形界面得跟底层API斗智斗勇，现在呢？直接monkey.bgcolor("black")，一键构建沉浸式暗黑模式，这UI设计审美瞬间拉满。</p><p>最炸裂的是这段“跨次元”的变形操作。代码里一挥手，阿童木、光头强、灰太狼、机器猫统统加载进来。这在以前得写多少个switch-case或者if-else啊？现在呢？简直就是把“元宇宙”的概念搬进了代码里。这只赛博猴子不只是在换图片，它是在不同的“虚拟皮肤”之间进行量子穿梭！上一秒还是动漫界的扛把子，下一秒就变成了太空火箭少年，这种无缝衔接的“算法渲染”，丝滑得连最新款显卡都点赞。</p><p>还有那个random(0.9,1.5)，这可不仅仅是随机数，这是在模拟“神经元突触”的不确定性，让每一次等待都充满了未知的科技感，根本不给你任何预测算法的机会。那个while(g_screen-&gt;exitonclick())，这就是一个永不停歇的“事件循环引擎”，只要你不断电，这只猴子就能在数字世界里永生，陪你嗨到天荒地老。</p><p>所以说，什么“C++难如登天”的论调，早就该丢进电子垃圾桶了。现在的C++，穿上了外骨骼变身为超级战士了，门槛低得像个地库入口。它就像是一个披着硬核外衣的极简主义脚本语言，既能上天揽月，又能下地卖萌。已从那个高冷难攀的编程 “大神”，变成了能陪新手玩闹、能轻松做出趣味小项目的 “小伙伴”。</p><p>正文如下：</p><pre><code>#include "sprites.h"  //包含C++精灵库 
Sprite monkey;       //建立角色叫monkey 

int main(){        //主功能块 
   monkey.bgcolor("black").scale(0.5);  //背景黑，角色变小一半
   //抬笔，并且移除索引为0的造型（默认小火箭)
   monkey.penup().removeshape(0).color(200).addy(200);
   std::string s = "C++孙悟空的72变小动画";
   monkey.write(s,"center",{"","48","normal"}).wait(1);
   monkey.addy(-200);
   monkey.addshape("res/阿童木.png");   //添加造型
   monkey.addshape("res/光头强.png");
   monkey.addshape("res/灰太狼.png");
   monkey.addshape("res/机器猫.png");
   monkey.addshape("res/monkey.png"); //孙悟空
   monkey.addshape("res/外星人.png");
   monkey.addshape("res/中国结.png");
   monkey.addshape("res/qirocketboy.png");  //骑火箭飞向太空的男孩
   //加载背景音乐
   Mix_Music *music=Mix_LoadMUS("res/monkeybgmusic.wav");  //不支持中文名
   Mix_PlayMusic(music,-1);  //-1表示无限循环播放，0表示播放1次，1则是2次。
   // g_screen是角色建立后的全局屏幕指针  
   while(g_screen-&gt;exitonclick())  //单击窗口关闭按钮则循环退出
     monkey.next_shape().wait(random(0.9,1.5)); //孙悟空切换造型，并且随机等待一定的时间  
   return 0;
}</code></pre><p>从此在编程界，又多了一位既能扛得起大型项目，又能陪新手玩得起趣味小动画的 “全能选手”。</p>]]></description></item><item>    <title><![CDATA[Debian 13.3 Trixie 发布 - 通用操作系统 sysin ]]></title>    <link>https://segmentfault.com/a/1190000047536181</link>    <guid>https://segmentfault.com/a/1190000047536181</guid>    <pubDate>2026-01-11 22:06:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Debian 13.3 Trixie 发布 - 通用操作系统</p><p>The Universal Operating System</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=Nr%2BIUo7ssduyGK7owF1eZg%3D%3D.jeeXG0Vvp63BpXlTOn7vz5evLS4XWrhn0d56FrkjTv7uiiscpTQA7Qd98tPifZOG" rel="nofollow" target="_blank">https://sysin.org/blog/debian-13/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=m8g7Ct3FKa9ibPP48kQAQw%3D%3D.FFjfwgbLbkisuAI9nQWuEs%2FOKsBVOn5kH4mY3oTPLAA%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>2026 年 1 月 10 日</p><p>Debian 13.3 “Trixie” 发布，包含 108 个错误修复和 37 个安全更新</p><p>Debian 项目宣布其稳定版本 Debian 13（代号 "trixie"）的第三次更新发布。本次点版本主要是针对安全问题进行修正，并对一些严重问题进行了调整。相关的安全公告已经单独发布，并在适当的地方进行了引用。</p><p>请注意，点版本并不意味着 Debian 13 的新版本，只是更新了一些包含的包。旧的 "trixie" 安装介质不需要丢弃。安装后，可以通过使用更新的 Debian 映像来升级到当前版本的包。</p><p>那些经常从 security.debian.org 安装更新的用户，不需要更新太多包，大部分更新已经包含在此次点版本中。</p><p>详见官方<a href="https://link.segmentfault.com/?enc=si5n5mdounpVd7PgEwnSXQ%3D%3D.l3l42cFvEFRgjBDgQ7KDrT3sjHese47VXkM9Wv1oZ8csQRut5%2FrwK2D6wH41GrjE" rel="nofollow" target="_blank">发行说明</a>。</p><p>Debian 13 发布于 2025 年 8 月 9 日，此版本引入了对 RISC-V 64 位架构 的官方支持，并将 APT 3.0 作为默认的软件包管理器。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047185122" alt="sysin" title="sysin"/></p><h3>选择 Debian 的理由</h3><p>用户选择 Debian 作为他们的操作系统的原因有很多。</p><h4>主要的原因</h4><ul><li><p><strong>Debian 是自由软件</strong>。</p><p>Debian 是由自由和开放源代码的软件组成的，并将始终保持 100% 自由（Free）。每个人都能自由使用、修改，以及分发。这是对用户的主要承诺。它也是免费的。</p></li><li><p><strong>Debian 是一个稳定且安全的基于 Linux 的操作系统</strong>。</p><p>Debian 是一个广泛用于各种设备的操作系统，其使用范围包括笔记本计算机，台式机和服务器。自 1993 年以来，它的稳定性和可靠性就深受用户的喜爱。为每个软件包提供合理的默认配置。Debian 开发人员会尽可能在其生命周期内为所有软件包提供安全更新。</p></li><li><p><strong>Debian 具有广泛的硬件支持</strong>。</p><p>大多数硬件已获得 Linux 内核的支持 (sysin)。当自由软件无法提供足够的支持时，也可使用专用的硬件驱动程序。</p></li><li><p><strong>Debian 提供平滑的更新</strong>。</p><p>Debian 以在其发行周期内轻松流畅地进行更新而闻名，不仅如此，还包括轻松升级到下一个大版本。</p></li><li><p><strong>Debian 是许多其他发行版的种子和基础</strong>。</p><p>许多非常受欢迎的 Linux 发行版，例如 Ubuntu、Knoppix、PureOS、SteamOS 以及 Tails，都选择了  Debian 作为它们的软件基础。Debian 提供了所有工具，因此每个人都可以用能满足自己需求的软件包来扩展 Debian 档案库中的软件包。</p></li><li><p><strong>Debian 项目是一个社区</strong>。</p><p>Debian 不只是一个 Linux 操作系统。该软件由来自世界各地的数百名志愿者共同制作。即使您不是一个程序员或系统管理员，也可以成为 Debian 社区的一员。Debian 是由社区和共识驱动的，具有一个 <a href="https://link.segmentfault.com/?enc=Ok1RDxdfRBB4M2WjYkWSlQ%3D%3D.CnaL1WIfFIKd3X3y2Hm7g2c8r4bQFy6jXiW6GjHuZJhk9d7nxiy9Z%2FlFlSKmxL6E" rel="nofollow" target="_blank">民主的治理架构</a>。由于所有 Debian 开发人员都享有平等的权利，所以它不能被单个公司所控制。开发人员遍布在 60 多个国家 / 地区，并且 Debian Installer 提供了超过 80 种语言的翻译支持。</p></li><li><p><strong>Debian 有多个安装程序选项</strong>。</p><p>终端用户会使用 Live CD，其包括易于使用的 Calamares 安装程序，只需很少的输入或前置知识。经验丰富的用户可以使用独特的功能齐全的安装程序，而专家可以对安装进行微调，甚至可以使用自动网络安装工具。</p></li></ul><h4>企业环境</h4><p>如果您在专业环境中需要使用 Debian，则可以享受以下额外好处：</p><ul><li><p><strong>Debian 是可靠的</strong>。</p><p>Debian 在从单个用户的笔记本到超级对撞机、证劵交易所和汽车行业的数以千计的现实日常场景中证明其可靠性。它在学术界、科研机构和公共部门中也很流行。</p></li><li><p><strong>Debian 有很多专家</strong>。</p><p>软件包维护者不仅会为 Debian 软件包修正问题，还会将其补丁合并到新的上游版本 (sysin)。他们通常是上游软件的专家，直接为上游开发做出贡献。有时他们也是上游的一部分开发成员。</p></li><li><p><strong>Debian 是安全的</strong>。</p><p>Debian 对其稳定版本提供安全支持。许多其它发行版的开发人员和安全研究人员都依赖 Debian 的安全跟踪器。</p></li><li><p><strong>长期支持</strong>。</p><p>Debian 提供了免费的 <a href="https://link.segmentfault.com/?enc=3%2B%2FvmZVPgHCvZArGbj4OFw%3D%3D.7tO534t2bSm1CIWMITWVe4S%2BvNOPanzbfYgphWy17UM%3D" rel="nofollow" target="_blank">长期支持</a> (LTS)。这为您提供了对稳定版本至少 5 年的额外支持。除此以外，还有 <a href="https://link.segmentfault.com/?enc=FNAW0tAg7sWRw%2BJZHfhu%2FA%3D%3D.nuSReojDKkPYr8h04VXO2fPgVJNW%2B40N54bNrTGvBj5%2B56%2BnjLcm%2FXVKofV1DmzW" rel="nofollow" target="_blank">扩展的 LTS</a> 计划，该计划将对有限的软件包的支持延长到了 5 年以上。</p></li><li><p><strong>云映像</strong>。</p><p>官方云映像可用于所有的主流云端平台。还提供了工具和配置，因此您可以构建自己的自定义云映像。您还可以在桌面或容器里的虚拟机中使用 Debian。</p></li></ul><h4>开发者</h4><p>Debian 被各种软件和硬件开发人员广泛使用。</p><ul><li><p><strong>公开的错误跟踪系统</strong>。</p><p>Debian <a href="https://link.segmentfault.com/?enc=VjpYWAvXK4Iv%2FPhP7tRL%2FQ%3D%3D.D4jlME3GQQsMf8pdsnZA6gYKt%2BNznyl1Pk3eAmftSOE%3D" rel="nofollow" target="_blank">错误跟踪系统</a> (BTS) 向所有人公开，任何人都可通过浏览器访问。不会隐藏软件错误，您可以轻松提交新的错误报告。</p></li><li><p><strong>物联网和嵌入式设备</strong>。</p><p>支持各种设备，例如 Raspberry Pi、QNAP 的各个变种、移动设备、家庭路由器以及大量单板计算机 (SBC)。</p></li><li><p><strong>多种硬件架构支持</strong>。</p><p>Debian 支持 <a href="https://link.segmentfault.com/?enc=CRTksRVDvmtlnZ%2FHfyyAvA%3D%3D.rc3bVQ1HI2qEHTWHdqGldV4jyyLwOTpXdwIBy60yYaw%3D" rel="nofollow" target="_blank">一长串</a> 的 CPU 架构，包括 AMD64、i386、ARM 和 MIPS 、POWER7、POWER8、IBM System z、RISC-V 的多个版本。Debian 还可以用于较旧的特定架构。</p></li><li><p><strong>为数众多的可用软件包</strong>。</p><p>Debian 拥有最多数量的已安装软件包（当前为 59000）。软件包使用 deb 格式，该格式以其高质量著称。</p></li><li><p><strong>提供不同版本的选择</strong>。</p><p>除了稳定版本外，您还可以通过安装测试版或不稳定版本来获得最新版本的软件。</p></li><li><p><strong>在开发人员工具和政策的帮助下保证高质量</strong>。</p><p>多个开发人员工具帮软件包维持高水平的质量，并且 Debian 的 <a href="https://link.segmentfault.com/?enc=YQ9ZzR8JGU1VzydQFE%2FRog%3D%3D.EQS26tq6sZcVmYc%2BQpmgVi4wqSEqu34RxpESxSjxINsXNjfPuTHyh9JrZ6zIrR%2Ff" rel="nofollow" target="_blank">政策</a> 规定了每个被官方仓库接受的软件包所必须满足的技术需求。持续集成是运行在 autopkgtest 这个软件上的，piuparts 是安装、升级和删除测试工具，lintian 是一个用于 Debian 软件包的全面的软件包检查程序。</p></li></ul><h4>来自用户的声音</h4><ul><li><strong>对我而言，这是易用性和稳定性的完美水平。这些年来，我使用了各种不同的发行版，但是 Debian 是唯一一个可以使用的发行版</strong>。</li><li><strong>坚如磐石的品质，提供了海量的软件包，还有优秀的社区</strong>。</li><li><strong>对我来说，Debian 是稳定和易于使用的代表</strong>。</li></ul><h2>下载地址</h2><p>Debian 13</p><p>网盘链接：<a href="https://link.segmentfault.com/?enc=LJ0X6E%2FBUqF0eiPK8UeKOQ%3D%3D.9g81GuMBdzpK0Qc2KSQ5NGtqh%2FlmvxE0PhaaXFaVJiD1IfRCe%2Bnj458DO78%2BI6Fo" rel="nofollow" target="_blank">https://sysin.org/blog/debian-13/</a></p><ul><li>Debian 13 AMD64（x86_64）CD<br/>filename：debian-13.x.0-amd64-netinst.iso</li><li>Debian 13 AMD64（x86_64）DVD<br/>filename：debian-13.x.0-amd64-DVD-1.iso</li><li>Debian 13 AMD64（x86_64）CD for Intel based Apple Mac<br/>filename：debian-mac-13.x.0-amd64-netinst.iso</li><li>Debian 13 AMD64（x86_64）CD for educational<br/>filename：debian-edu-13.x.0-amd64-netinst.iso</li><li>Debian 13 ARM64 (AArch64) CD<br/>filename：debian-13.x.0-arm64-netinst.iso</li><li>Debian 13 ARM64 (AArch64) CD<br/>filename：debian-13.x.0-arm64-DVD-1.iso</li></ul><p>更多架构和格式请访问：<a href="https://link.segmentfault.com/?enc=vTvpo8hoLorSjABE34Uyhg%3D%3D.H5zVO%2FLNQh9A080NR8mZnMA1cPdBV%2Bi8mr0Kept4Hhf4gZNHA%2FSEy697zo5PiPxY" rel="nofollow" target="_blank">Downloading Debian CD/DVD images via HTTP/FTP</a></p><p>虚机模板下载：</p><ul><li><a href="https://link.segmentfault.com/?enc=7hcVsl13dajKIt65t6feKQ%3D%3D.T%2B%2FDVK6%2B2Kb2LWdExQafv53YQaehl%2F4CRFPzG2wlJUIqsRAQJNImncAapcOX9bbB" rel="nofollow" target="_blank">Debian 13 x86_64 OVF (sysin) - VMware 虚拟机模板</a></li></ul>]]></description></item><item>    <title><![CDATA[DataMover搞定 MySQL 实时同步 DataMover ]]></title>    <link>https://segmentfault.com/a/1190000047536523</link>    <guid>https://segmentfault.com/a/1190000047536523</guid>    <pubDate>2026-01-11 22:05:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>本文将手把手教你使用 <strong>DataMover 免费版</strong>，通过图形界面完成 <strong>MySQL 到任意目标数据库的实时同步任务</strong>。无论目标是 PostgreSQL、Oracle、MySQL、达梦（DM）、人大金仓（KingBase）、高斯（GaussDB），还是 Elasticsearch，操作流程高度一致，只需 3步！</p><p><strong><em>DataMover免费版</em></strong>，支持创建一个CDC任务，单任务支持同步150张表。</p><p>支持情况详见：<a href="https://link.segmentfault.com/?enc=Yi2SrnbJp5zr6BheNz5prg%3D%3D.dbRjyx6xYKmQR8wT2dqu8BSlrdx7ZcmN39Y3vQ9qURxwFJwos3uYjEU1RInWLcK%2BWiY6G5E%2Fqo9EIUMIg0mUKg%3D%3D" rel="nofollow" target="_blank">数据源链路</a></p><hr/><h2>一、环境准备</h2><h3>1.1 下载并安装 DataMover</h3><ul><li>访问官网下载页面：<a href="https://link.segmentfault.com/?enc=ILEAvnStxZ3ogarS5vtsaw%3D%3D.8esVSKMCYXJ0M4HKEIZv7c42w36tkW%2FIgke17nbyOnxerEU5vkh2tcKbGAmk%2BdsH" rel="nofollow" target="_blank">https://datamover.cn/download.html</a></li><li>解压后确保已安装 <strong>JDK 8+</strong></li><li>安装DataMover：<a href="https://link.segmentfault.com/?enc=1AsjcMfz4AuEK6pmVyHu4w%3D%3D.PAqn%2BYwaMNvuI%2FhqWdn56hCbHQgTLMlXznylaWUL3D12SYx65oRQsvUKHLCOSpkOUyqeZuG1vl2wHvMGhNMP2w%3D%3D" rel="nofollow" target="_blank">全新安装(Linux)</a>、<a href="https://link.segmentfault.com/?enc=LASM1jKkyPCnfZqWCLRh1g%3D%3D.nZmwMOEhd9lI26oRPtWJswNUQ5iDJ3fWsJ5txIyQKKpJshXaUF%2B0kY2UL012r9%2F8tPitaN4j01gT0qImRKKOdg%3D%3D" rel="nofollow" target="_blank">全新安装(Windows、Mac)</a></li></ul><p><img width="723" height="400" referrerpolicy="no-referrer" src="/img/bVdnCz7" alt="" title=""/></p><h3>1.2 启动服务</h3><pre><code class="bash"># Linux/macOS
manager/bin/start.sh
worker/bin/start.sh

# Windows
双击 manager/bin/start.bat 和 worker/bin/start.bat</code></pre><h3>1.3 登录 Web 控制台</h3><ul><li>浏览器访问：<code>http://localhost:8000</code></li><li>默认账号：<code>admin</code></li><li>默认密码：<code>admin123</code></li></ul><blockquote>✅ 提示：若部署在远程服务器，请确保 8000 端口开放。</blockquote><hr/><h2>二、通用操作流程（适用于所有目标端）</h2><blockquote><strong>以下步骤中，仅“添加目标数据源”部分因目标类型不同而略有差异，其余完全一致。</strong></blockquote><hr/><h3>步骤 1：添加 MySQL 源端数据源</h3><ol><li>左侧菜单点击 <strong>「数据源」→「新增」</strong></li><li>数据源类型选择 <strong>「MySQL 数据库」</strong></li><li><p>填写连接信息：</p><ul><li>名称：<code>mysql-source</code>（自定义）</li><li>主机：<code>192.168.1.100</code>（你的 MySQL IP）</li><li>端口：<code>3306</code></li><li>数据库名：<code>mydb</code></li><li>用户名/密码：具备 <code>SELECT, REPLICATION CLIENT, REPLICATION SLAVE</code> 权限</li></ul></li><li><p>关键配置</p><p>（CDC 必须）：</p><ul><li>确保 MySQL 已开启 binlog，格式为 <code>ROW</code>，并设置唯一 <code>server-id</code></li><li><p>示例 my.cnf 配置：</p><pre><code class="ini">[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW</code></pre></li></ul></li><li>点击 <strong>「测试连接」</strong> → 成功后 <strong>「保存」</strong></li></ol><p><img width="723" height="437" referrerpolicy="no-referrer" src="/img/bVdnCz8" alt="" title="" loading="lazy"/></p><hr/><h3>步骤 2：添加目标数据源（按需选择）</h3><h4>▶ 场景 A：目标为 PostgreSQL</h4><ul><li>类型选择：<strong>PostgreSQL</strong></li><li>主机/端口：<code>5432</code></li><li>数据库名、用户名、密码按实际填写</li><li>测试连接 → 保存</li></ul><h4>▶ 场景 B：目标为国产数据库（如达梦）</h4><ul><li>类型选择：<strong>达梦数据库</strong>（或 人大金仓 / GaussDB / OceanBase）</li><li>填写对应 JDBC 连接参数（通常与 Oracle 兼容）</li><li>注意：需提前在 <code>lib/</code> 目录放入对应 JDBC 驱动（如 <code>DmJdbcDriver18.jar</code>）</li><li>测试连接 → 保存</li></ul><h4>▶ 场景 C：目标为 Elasticsearch</h4><ul><li>类型选择：<strong>Elasticsearch</strong></li><li><p>填写：</p><ul><li>地址：<code>http://es-host:9200</code></li><li>索引名称前缀（如 <code>mysql_sync_</code>）</li><li>认证信息（如有）</li></ul></li><li>支持自动创建索引，字段类型自动推断</li><li>测试连接 → 保存</li></ul><h4>▶ 场景 D：目标为另一 MySQL（主从/分发）</h4><ul><li>类型选择：<strong>MySQL 数据库</strong></li><li>填写目标 MySQL 连接信息（无需 binlog 权限）</li><li>测试连接 → 保存</li></ul><p><img width="723" height="426" referrerpolicy="no-referrer" src="/img/bVdnCz9" alt="" title="" loading="lazy"/></p><hr/><h3>步骤 3：创建实时同步任务</h3><ol><li>左侧菜单点击 <strong>「任务管理」→「新建任务」</strong></li><li><p>基础配置：</p><ul><li>任务名称：<code>mysql实时同步</code>（自定义）</li><li>源端数据源：选择刚创建的 <code>mysql-source</code></li><li>目标端数据源：选择对应目标（如 <code>postgresql-target</code>）</li><li>任务类型：<strong>「实时任务」</strong>（启用 CDC）</li></ul></li><li><p>表映射：</p><ul><li>在左侧源表列表点击 <strong>「+」号</strong></li><li>勾选需要同步的表（如 <code>user</code>, <code>order</code>）</li><li>目标表可选择 <strong>“自动创建”</strong> 或 <strong>“映射到已有表”</strong></li><li>字段自动匹配（支持手动拖拽调整）</li></ul></li></ol><blockquote><p>⚠️ 注意：首次运行实时任务会先执行 <strong>全量快照</strong>，完成后自动切换至 <strong>增量 CDC</strong>。</p><p>对于CDC任务不建议使用函数和字段映射，尽量保证源表和目标表数据一致。</p></blockquote><p><img width="723" height="168" referrerpolicy="no-referrer" src="/img/bVdnCAa" alt="" title="" loading="lazy"/><br/><img width="723" height="400" referrerpolicy="no-referrer" src="/img/bVdnCAb" alt="" title="" loading="lazy"/><br/><img width="723" height="351" referrerpolicy="no-referrer" src="/img/bVdnCAc" alt="" title="" loading="lazy"/></p><hr/><h3>步骤 4：启动任务并验证</h3><ol><li>保存任务后，返回任务列表</li><li>点击 <strong>「全部启动」</strong>（CDC 任务需整体启停）</li><li><p>进入任务详情页，查看：</p><ul><li>同步进度（已处理行数）</li><li>错误日志（如有）</li></ul></li></ol><p><img width="723" height="300" referrerpolicy="no-referrer" src="/img/bVdnCAd" alt="" title="" loading="lazy"/><br/><img width="723" height="359" referrerpolicy="no-referrer" src="/img/bVdnCAe" alt="" title="" loading="lazy"/></p><h4>验证同步效果（任选其一）：</h4><ul><li><strong>INSERT</strong>：在源库插入一条记录 → 查看目标库是否出现</li><li><strong>UPDATE</strong>：更新某字段 → 目标库对应记录是否变更</li><li><strong>DELETE</strong>：删除记录 → 目标库是否同步删除</li><li><strong>TRUNCATE</strong>：清空表 → 目标表是否重建或清空</li></ul><hr/><h3>步骤 5：日常运维</h3><ul><li><strong>停止</strong>：任务列表操作按钮</li><li><strong>重置任务</strong>：清除位点，重新全量 + 增量（用于表结构变更后）</li></ul><hr/><h2>三、支持的目标端一览</h2><p>DataMover 免费版支持 <strong>35+ 种目标数据源</strong>，包括：</p><table><thead><tr><th>类别</th><th>支持目标</th></tr></thead><tbody><tr><td>关系型数据库</td><td>PostgreSQL, Oracle, SQL Server, 达梦, 人大金仓, GaussDB, OceanBase</td></tr><tr><td>数据仓库</td><td>Doris, ClickHouse, Greenplum,</td></tr><tr><td>消息队列</td><td>Kafka, RabbitMQ,</td></tr><tr><td>搜索引擎</td><td>Elasticsearch</td></tr><tr><td>文件系统</td><td>HDFS, FTP, 本地文件</td></tr></tbody></table><blockquote>💡 所有目标端均通过 <strong>统一界面配置</strong>，无需修改代码。</blockquote><hr/><h2>四、结语</h2><p>通过以上 5 个标准化步骤，你可以在 <strong>5 分钟内</strong>完成任意 MySQL 到目标系统的实时同步任务。DataMover 将复杂的 CDC 逻辑封装为 <strong>可视化操作</strong>，真正实现 <strong>“零编码、低门槛、高可靠”</strong> 的数据流动。</p>]]></description></item><item>    <title><![CDATA[深度研究Agent架构解析：4种Agent架构介绍及实用Prompt模板 本文系转载，阅读原文
ht]]></title>    <link>https://segmentfault.com/a/1190000047536527</link>    <guid>https://segmentfault.com/a/1190000047536527</guid>    <pubDate>2026-01-11 22:04:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>深度搜索Agent核心问题其实就有两个：怎么把复杂问题拆得合理，以及怎么判断搜索结果够不够用。近两年深度搜索Agent发展很快各家的实现思路也越来越成熟，围绕这两个问题业界逐渐沉淀出几种主流架构：从最基础的Planner-Only，到加入评估反馈的双模块设计，再到Sentient Labs提出的递归式方案。这篇文章将整理这些架构并顺便附上一些实用的prompt模板。</p><h2>迭代式搜索Agent</h2><p>在讨论更复杂的架构之前，先回顾一下最基础的迭代式搜索Agent。这类Agent通常基于ReAct（Reasoning and Acting）范式，工作流程很简单：接收问题→思考→调用工具搜索→观察结果→继续思考→再搜索...如此循环直到找到满意的答案。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047536529" alt="" title=""/></p><p>但是这种简单的迭代模式有个问题：当面对复杂查询时单线程一步步搜效率太低。于是就有了并行工作流的思路，把一个大问题拆成多个子查询，让多个搜索任务同时跑。</p><h2>Planner-Only架构</h2><p>但并行工作流又有个明显的短板：子查询数量是写死的。实际情况是简单问题拆2-3个子查询就够了，而复杂问题可能要拆5-6个甚至更多。也就是说子查询的拆分应该是动态的而不是预先固定。</p><p>Planner LLM就是为解决这个问题产生的。它的作用很简单，就是分析用户问题的复杂度，决定应该拆成多少个子任务，每个子任务负责什么，以及应该调用哪些工具。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047536530" alt="" title="" loading="lazy"/></p><p>一个典型的Planner提示词结构如下：</p><pre><code> # MAKE A STRATEGY/PLAN, YOU HAVE ACCESS TO FOLLOWING TOOLS  
↳ describe tools &amp; their input parameters here

# GUIDELINES FOR QUERY COMPLEXITY, TOOL CALLS &amp; [#SUBAGENTS](#SUBAGENTS)  
↳ simple fact finding queries requires just 1 subtask with 3-10 tool calls.  
↳ direct comparison queries might need 2-5 subtasks with 10-15 tools call each.  
↳ complex research might use more than 10 subtasks with clearly divided responsibilities

# CLEARLY DEFINE EACH SUBAGENT'S ROLE IN FOLLOWING FORMAT  
{  
  objective :-  
  output_format :-  
  tool_guidance :-  
  rationale :-  
}

# HEURISTICS FOR TOOL GUIDANCE (basically here we are doing Tool RAG)  
examine all available tools first, match tool usage to subagent objective,   
search the web only for broad external information or prefer specialized tools   
 over generic ones.</code></pre><p>这个提示词模板的设计思路值需要注意的是：首先告诉Planner有哪些工具可用，然后给出不同复杂度问题的拆分参考标准，最后要求它为每个子Agent明确定义目标、输出格式和工具使用指导。这样Planner输出的计划才足够具体，下游的执行Agent才能照着执行。</p><p>Planner承担的任务复杂度高是整个架构的核心节点。所以强烈建议用推理能力强的模型来做Planner，比如GPT-4o、Claude 3.5 Sonnet或者专门的推理模型如o1、DeepSeek-R1等。</p><h2>停止条件的处理</h2><p>有了Planner问题拆分的问题解决了，但还有另一个老问题：ReAct循环什么时候该停？</p><p>传统做法是手动设一个固定阈值靠经验调参比如最多跑5轮，但这显然不够灵活，因为复杂查询需要更多轮迭代，简单查询几轮就够了。固定阈值要么会让简单问题跑太多轮浪费资源，要么会让复杂问题提前结束拿不到完整答案。</p><p>所以解决办法是引入一个评估器LLM，每轮迭代后让评估器判断当前答案是否已经足够好，如果够好就停不够就继续跑。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047536531" alt="" title="" loading="lazy"/></p><p>评估器的提示词可以这样写：</p><pre><code> # TASK  
Your task is to analyse and determine if following information is sufficient   
or there are knowledge gaps?? Provide reasoning for your answer

# Question  
add here the user question

# Generated Answer  
add here the answer generated by this iteration of ReAct

# OUTPUT FORMAT  
{  
  "is_sufficient": true/false  
  "reasoning":   
  "knowledge_gap":  
 }</code></pre><p>评估器需要做两件事：判断当前答案是否充分，以及如果不充分的话缺的是什么。</p><pre><code>knowledge_gap</code></pre><p>字段很关键，它可以指导下一轮迭代应该往哪个方向搜。</p><h3>澄清问题机制</h3><p>OpenAI在评估器的基础上又加了一层设计。他们观察到有些特别刁钻的问题LLM怎么搜都找不到满意的答案，评估器一直返回</p><pre><code>is_sufficient = false</code></pre><p>循环就没完没了。</p><p>这种情况往往不是搜索能力的问题而是问题本身定义不清，比如用户问"最好的笔记本电脑是哪个"，这里的"最好"指什么？性价比最高？性能最强？便携性最好？不同的理解会导向完全不同的搜索方向。</p><p>所以OpenAI的方案是：当评估器发现反复搜索都无法得到充分答案时，不如让Agent主动问用户几个澄清问题，把人拉进来帮忙明确需求。这就是所谓的human-in-the-loop设计。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047536532" alt="" title="" loading="lazy"/></p><h3>检查清单评分</h3><p>而SamayaAI提出了另一种评估思路：检查清单评分，这个方案对长篇幅答案特别有效。</p><p>传统评估器面对长答案容易"晕"，单个LLM很难在一大段文本里保持完整的推理链，上下文一长就开始丢信息，评估结果也就不太靠谱了。SamayaAI的想法是，与其让评估器去理解和评判整个答案的内容质量不如换个角度来评估答案是否符合预设的结构规范，这个结构规范就是所谓的检查清单。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047536533" alt="" title="" loading="lazy"/></p><p>比如说，如果用户问的是"对比A和B两个产品"检查清单可能包括：是否分别介绍了A和B的特点？是否有价格对比？是否有优缺点总结？是否给出了推荐建议？评估器只需要逐项打勾比从头读完整个答案再打分要简单得多。</p><pre><code> # TASK  
Your task is to analyse and determine if the answer follows following checklist  
or not. If not the identify knowledge gaps. Provide reasoning for your answer.

# Question  
add here the user question

# Generated Answer  
add here the answer generated by this iteration of ReAct

# Checklist  
add your checklist here

# OUTPUT FORMAT  
{  
  "is_sufficient": true/false  
  "reasoning":   
  "knowledge_gap":  
 }</code></pre><h2>Planner + Plan Evaluator双模块架构</h2><p>前面说的评估器主要是评估搜索结果，但其实Planner生成的计划本身也可能有问题。于是就有了Planner + Plan Evaluator的双模块设计：先让Planner生成计划，再让评估器审核这个计划靠不靠谱，通过了再执行。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047536534" alt="" title="" loading="lazy"/></p><p>Plan Evaluator有几种典型的设计思路。</p><p><strong>思路一：多计划竞争</strong>。让Planner并行生成多个执行计划，评估器从中挑最优的那个。这样能提高计划质量，但代价是成本和延迟都会上升——多生成几个计划就多几倍的token消耗。</p><p><strong>思路二：单计划审核</strong>。先生成一个计划，评估器判断好坏，好就执行不好就打回去重新生成。这个思路成本更可控，但可能需要多轮打回-重生成才能得到合格的计划。</p><p>计划出问题一般都会是以下几种情况：</p><p><strong>目标失败</strong>：Agent没完成任务或者完成了但违反了约束条件。比如让模型规划一趟从旧金山到印度的两周旅行，预算5000美元，结果它给你规划到越南去了；或者确实规划了印度行程但预算直接超了。</p><p><strong>工具失败</strong>：这又分好几种情况。可能是生成了根本不存在的工具名（比如调用</p><pre><code>bing_search</code></pre><p>但工具库里压根没这个）；可能是工具对了但参数个数不对（</p><pre><code>lbs_to_kg</code></pre><p>只需要一个参数,它传了俩）；也可能是参数个数对了但值填错了（该传120传成了100）。</p><p>Plan Evaluator需要针对这些常见问题设计检查逻辑，在计划执行前就把明显的错误拦住，避免浪费执行资源。</p><h2>递归搜索Agent</h2><p>前面介绍的架构本质上都是迭代式的，但从算法角度看迭代能做的事递归也能做，而且递归天然适合处理可分解的层次化问题。</p><p>Sentient Labs就按照这个思路搞出了ROMA（Recursive Open Meta Agent）。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047536535" alt="" title="" loading="lazy"/></p><p>ROMA的核心思想是：把复杂问题递归地分解成子问题，每个子问题再独立处理。和普通的并行拆分不同，ROMA的子问题之间可以有依赖关系——某个子问题的答案可能是另一个子问题的输入。这种设计更符合复杂研究任务的实际结构。</p><p>上图是ROMA的简化版本，完整架构还有一层基于依赖图的信息抽取机制。依赖图用来管理子问题之间的前后关系，确保有依赖的任务按正确顺序执行。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047536536" alt="" title="" loading="lazy"/></p><p>递归架构的优势在于理论上可以处理任意深度的复杂查询，只要问题能被合理分解。但工程实现上也更有挑战，需要处理好递归深度控制、子问题结果合并、错误传播等问题。</p><h2>总结</h2><p>这几种架构并不是非此即彼的关系。Planner-Only适合入门，实现简单调试方便；加上评估器后系统变得更智能，但复杂度和成本也跟着上来；检查清单评分这类方案对长文档输出效果不错，值得在特定场景下尝试；而ROMA的递归思路理论上能处理更深层次的复杂查询，不过工程实现的门槛也更高。</p><p>实际落地时，可以先从简单架构跑通，再根据具体问题逐步叠加模块。毕竟Agent系统的调试本身就不容易，一上来就搞太复杂容易把自己绕进去。</p><p><a href="https://link.segmentfault.com/?enc=bN15oS7Of88LdPrFZWKfIg%3D%3D.aJA2Sld3VJUJyqkyNQ7YKSh4iJjxF6%2BqIQYCrbdx4A6D%2BicwtwNXkwVZRYfbHf5DDM95iH5mVklpfMHgc5NLKw%3D%3D" rel="nofollow" target="_blank">https://avoid.overfit.cn/post/c6f7744b34b048efb144d05c66e4c144</a></p>]]></description></item><item>    <title><![CDATA[印度尼西亚（IDX）股票数据对接开发 CryptoRzz ]]></title>    <link>https://segmentfault.com/a/1190000047536560</link>    <guid>https://segmentfault.com/a/1190000047536560</guid>    <pubDate>2026-01-11 22:03:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>本接口文档旨在帮助开发者快速接入印度尼西亚证券交易所（IDX）的实时市场数据。通过统一的 API 架构，开发者只需指定 <code>countryId=48</code> 即可获取印尼市场的全量金融信息。</p><h2>1. 接入准备</h2><ul><li><strong>API 基础路径</strong>：<code>https://api.stocktv.top</code></li><li><strong>国家代码 (countryId)</strong>：<code>48</code> （代表印度尼西亚）</li><li><strong>鉴权方式</strong>：所有请求必须在 URL 参数中携带有效 <code>key</code>。</li><li><strong>数据格式</strong>：统一为 <code>JSON</code> 格式。</li></ul><h2>2. 核心 API 接口说明</h2><h3>2.1 股票市场列表 (实时行情)</h3><p>获取印尼市场所有活跃股票的最新价格、涨跌幅及成交量。</p><ul><li><strong>接口地址</strong>：<code>/stock/stocks</code></li><li><strong>请求方式</strong>：<code>GET</code></li><li><strong>请求参数</strong>：</li><li><code>countryId=48</code> (必填)</li><li><code>pageSize</code>: 每页记录数，默认 10</li><li><code>page</code>: 当前页码</li><li><strong>核心字段说明</strong>：</li><li><code>last</code>: 最新成交价。</li><li><code>chgPct</code>: 涨跌百分比（前端展示时直接拼接 <code>%</code>）。</li><li><code>symbol</code>: 股票代码（如印尼主流个股代码）。</li><li><code>volume</code>: 实时交易量。</li><li><code>time</code>: 数据同步时间戳。</li></ul><h3>2.2 雅加达综合指数 (Indices)</h3><p>监控印尼大盘（如 JKSE - 雅加达综合指数）的整体走势。</p><ul><li><strong>接口地址</strong>：<code>/stock/indices</code></li><li><strong>请求参数</strong>：<code>countryId=48</code></li><li><strong>关键字段</strong>：</li><li><code>isOpen</code>: 市场是否处于交易状态（0: 休市, 1: 开盘）。</li><li><code>last</code>: 指数当前点位。</li></ul><h3>2.3 IPO 新股日历</h3><p>获取印尼市场近期拟上市及新近上市的股票信息。</p><ul><li><strong>接口地址</strong>：<code>/stock/getIpo</code></li><li><strong>请求参数</strong>：</li><li><code>countryId=48</code></li><li><code>type</code>: 1 为未上市（打新预警），2 为已上市（历史表现）。</li><li><strong>核心字段</strong>：<code>ipoListing</code> (上市时间戳)、<code>ipoPrice</code> (发行价格)、<code>company</code> (公司全称)。</li></ul><h3>2.4 K 线历史数据</h3><p>获取指定印尼个股的历史价格波动，支持 1 分钟至月线周期。</p><ul><li><strong>接口地址</strong>：<code>/stock/kline</code></li><li><strong>请求参数</strong>：</li><li><code>pid</code>: 股票的唯一 ID</li><li><code>interval</code>: 周期（<code>PT1M</code> 1分钟, <code>PT1H</code> 1小时, <code>P1D</code> 日线等）</li><li><strong>数据结构</strong>：返回包含 <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, <code>volume</code> 的数组。</li></ul><h3>2.5 公司基本面深度信息</h3><p>获取印尼上市公司的业务描述、所属行业及员工规模。</p><ul><li><strong>接口地址</strong>：<code>/stock/companies</code></li><li><strong>请求参数</strong>：<code>countryId=48</code></li><li><strong>关键字段</strong>：<code>description</code> (业务详述)、<code>sector</code> (所属板块)、<code>industry</code> (行业分类)。</li></ul><h2>3. 快速接入代码示例 (Node.js)</h2><pre><code class="javascript">const axios = require('axios');

const config = {
  baseURL: 'https://api.stocktv.top',
  apiKey: 'YOUR_API_KEY', // 联系官方获取
  indonesiaId: 48
};

async function getIndonesianStocks() {
  try {
    const response = await axios.get(`${config.baseURL}/stock/stocks`, {
      params: {
        countryId: config.indonesiaId,
        key: config.apiKey,
        pageSize: 5
      }
    });

    if (response.data.code === 200) {
      console.log('印尼股票行情数据:', response.data.data.records);
    }
  } catch (error) {
    console.error('API请求错误:', error.message);
  }
}

getIndonesianStocks();
</code></pre><h2>4. 为什么选择该数据源？</h2><ol><li><strong>极简切换</strong>：仅需修改 <code>countryId</code> 即可横跨印尼、印度、美国等 10+ 国家市场。</li><li><strong>全量数据</strong>：不仅有实时报价，更包含关键的 IPO 打新日历和公司深度背景数据。</li><li><strong>技术保障</strong>：提供 HTTP 和 WebSocket 双向接入，支持极速盘面刷新。</li></ol><hr/><p><strong>结语</strong>：通过对接 <code>countryId=48</code>，您的金融应用将具备实时洞察印尼市场脉搏的能力，助力用户把握东南亚新兴市场的投资先机。</p>]]></description></item><item>    <title><![CDATA[从事务执行者到决策操盘手：AI重塑HR核心价值 爱跑步的香蕉_cKtiNz ]]></title>    <link>https://segmentfault.com/a/1190000047536565</link>    <guid>https://segmentfault.com/a/1190000047536565</guid>    <pubDate>2026-01-11 22:02:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>从事务执行者到决策操盘手：AI重塑HR核心价值<br/>如果你是HR，大概率对这样的状态并不陌生：一天的时间被排班、筛简历、约面试、对接业务部门切得七零八落，真正用于判断“这个人值不值得要”的时间，反而少得可怜。<br/>麦肯锡在《全球HR数字化转型报告》中给出了一组刺眼的数据：60%～73%的HR从业者，每天超过60%的时间都耗在事务性工作上，而战略性工作占比不足15%。这不仅是“忙而低效”的问题，更暗藏高风险——招聘决策正逐渐变成凭经验、凭感觉、凭印象的赌徒式行为。<br/>当人力成本持续走高、用人失败的代价被无限放大，传统HR模式已触碰到效能天花板。华住、首旅如家、万达等头部集团的实践不断验证一个共识：AI不再是HR的“辅助工具”，而是招聘体系高效运转的核心杠杆。真正的行业分水岭，在于HR能否完成角色进化——从事务执行者，变成能驾驭AI的“招聘决策操盘手”。</p><p>招聘的核心痛点：打分能否成为决策依据<br/>很多企业已尝试过AI面试，却迟迟未能大规模落地，核心原因只有一个：不敢用结果做决策。效率再高、流程再顺，若打分不准，AI只能停留在“辅助筛选”阶段，无法成为招聘核心环节。<br/>成熟的AI面试系统，必然要攻克“精准打分”这一关键问题，让评分结果足以直接支撑招聘决策。这需要满足双重核心条件：一方面通过“背靠背”人机对比实验验证，确保与人工评估的一致性；另一方面通过效标效度与重测稳定信度两项心理学指标检验，保证评分的准确性与稳定性。唯有如此，AI给出的才不是“参考分”，而是能被业务、HR、管理层共同认可的决策依据。<br/>精准赋能：AI让招聘决策链更可靠<br/>真正的高精度AI招聘系统，其优势不体现在口号上，而渗透在每一个招聘细节中：<br/>•一问多能：单道题目可同步评估多项胜任力，打通HR初筛与技术复试，评估效率提升50%以上，避免重复面试与判断；<br/>•智能追问：根据候选人即时回答动态生成针对性问题，像资深面试官一样抓关键、补漏洞，避免核心能力被答题技巧掩盖；<br/>•简历深挖：自动抓取简历中的关键信息与模糊点，生成递进式提问，既防范信息造假，也避免因主观疏忽错失优质候选人；<br/>•全维考察：既能评估沟通、协作等通用胜任力，也能针对编程、算法、工程、财务等专业领域精准出题，同时解放HR与专业面试官。<br/>这类系统的核心价值，在于解决整个招聘决策链条的可靠性，而非单一环节的效率提升。<br/>体验升级：AI面试成为雇主品牌放大器<br/>很多AI面试的失败，源于交互的冰冷与机械，让候选人如同“对着机器交差”。优质的AI面试系统，会将“拟人化交互体验”作为核心竞争力：<br/>•情绪感知交互：捕捉候选人的语速、情绪与潜台词，引导其完整表达真实能力，避免因紧张被低估；<br/>•无断点流畅对话：无需手动点击启停，系统自动识别回答状态，自然衔接下一问题，体验接近面对面交流；<br/>•沉浸式视觉呈现：语音与口型高度匹配，语速、节奏精准同步，彻底告别“纸片人”式的疏离感；<br/>•多轮答疑解惑：支持候选人随时提问，AI准确解答岗位信息、公司福利等问题，让面试成为有效的雇主品牌沟通。<br/>当候选人体验被重视，招聘就不再只是筛选工具，更成为放大雇主品牌影响力的重要载体。<br/>AI技术的介入，正在重构招聘的底层逻辑，让HR从繁杂事务中解放，聚焦核心决策价值。唯有主动拥抱这一变革，才能在人才竞争中占据主动，让招聘成为支撑企业发展的核心竞争力。</p>]]></description></item><item>    <title><![CDATA[《量子算法开发实战手册：Python全栈能力的落地指南》 程序员阿伟 ]]></title>    <link>https://segmentfault.com/a/1190000047536594</link>    <guid>https://segmentfault.com/a/1190000047536594</guid>    <pubDate>2026-01-11 22:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>记得最初接触量子电路设计时，曾因使用静态类型语言遭遇硬件接口封闭性的壁垒，耗费近两周时间仍无法完成理论电路与模拟器的比特拓扑映射，反复调试底层代码却始终无法解决指令集不兼容的问题，而切换到Python工具链后，仅用半天就完成了从概念到验证的闭环—其自带的量子框架能够自动识别不同模拟器的比特排布规则，自动完成指令转换与态演化逻辑的适配，开发者无需分心底层硬件的差异，只需聚焦算法核心的态叠加与纠缠操控逻辑。这种“去冗余化”的开发体验，本质上是Python对量子开发痛点的精准洞察，它不只是充当编程载体，更像是量子算法的“逻辑转译器”，将复杂的量子物理规则封装为可感知、可操作的开发模块，让开发者能够穿透技术表象，直抵算法本质，这种原生融合的优势，是其他语言在短时间内无法复刻的。</p><p>Python的核心优势集中体现在“算法肌理打磨”的高效性上，这种高效并非简单的代码简洁，而是对量子开发全流程的深度适配，能够在不牺牲精度的前提下，实现算法原型的快速迭代与优化。在量子电路的迭代过程中，往往需要反复调整量子门的排布顺序、参数精度以及噪声适配策略，而Python的动态类型特性与模块化架构，让这种调整无需重构整个开发框架，极大降低了迭代成本。例如在优化量子态制备效率时，可通过调用专用量子框架的核心模块，快速替换不同的量子门组合方案，比如将传统的Hadamard门组合替换为更高效的任意角度旋转门序列，同时借助成熟的科学计算库实时模拟态演化过程，直观观察每个调整对量子态纯度、纠缠度等核心指标的影响。更重要的是，Python支持“噪声适配引擎”的灵活嵌入，能够根据目标硬件的噪声特性，比如超导量子比特的退相干时间、离子阱量子比特的振动噪声等，自动生成对应的补偿逻辑，这种“按需定制”的能力在处理复杂量子系统时尤为关键。对比其他语言需要手动编写噪声模型的参数拟合代码，Python通过高层接口与底层控制的双向打通，让开发者既能快速验证算法可行性，又能深入调整细节参数，这种“轻量迭代与深度控制”的平衡，正是量子算法从理论走向实践的关键支撑。</p><p>跨域融合的“语法包容性”让Python成为量子与经典计算的天然桥梁，这种包容性并非简单的库堆砌，而是底层逻辑的深度协同，能够完美承接量子算法开发中量子与经典混合流程的需求。量子算法的开发很少是纯粹的量子操作，更多是量子与经典的协同流程—数据编码阶段需要处理高维经典数据，量子计算阶段需要执行态演化，结果解析阶段需要进行概率统计与可视化，而Python凭借其在科学计算、人工智能领域积累的成熟生态，能够让这些跨域操作自然衔接，无需进行繁琐的格式转换或接口适配。例如在量子机器学习算法开发中，可通过经典AI库完成数据预处理与特征提取，比如对高维图像数据进行降维，将其转化为低维特征向量，再通过量子框架将特征向量直接编码为量子态，后续的量子电路执行与结果反推也能无缝衔接，整个过程无需手动编写数据转换代码，极大降低了跨域开发的认知负荷。更值得关注的是，Python支持混合编程架构，可在主程序中嵌入高性能语言模块处理密集型计算，比如用C++模块处理量子态密度矩阵的大规模运算，同时保留自身在逻辑调度与数据交互上的灵活性，这种“主次协同”的设计，既解决了量子模拟中的算力瓶颈，又未牺牲开发效率，让算法开发能够在性能与便捷性之间找到最优解。</p><p>Python构建的“分层抽象架构”，完美平衡了量子开发的低门槛与深度定制需求，这一特性在不同层次的开发者群体中都能体现出独特价值，成为连接量子领域初学者与资深研究者的技术纽带。对于初入领域的学习者而言，Python的高层框架提供了开箱即用的量子组件，无需深入理解量子物理的底层原理，就能通过模块化调用构建基础的量子电路，甚至借助可视化工具直观观察量子态的变化过程，比如通过布洛赫球面可视化工具看到量子态在三维空间中的旋转轨迹，通过概率分布热力图观察测量结果的分布规律，这种“降维入门”的路径，让更多非量子专业背景的开发者能够快速切入核心，避免因复杂的物理公式与底层原理望而却步。而对于资深研究者，Python又支持底层硬件的直接操控，可通过脉冲级接口调整量子比特的耦合参数，或自定义量子门的实现逻辑，比如根据硬件特性设计特定形状的驱动脉冲，优化量子门的保真度，这种“深度穿透”的能力，满足了前沿算法研究的个性化需求。在探索量子神经网络时，曾借助Python框架的分层设计，先通过高层API快速验证模型结构可行性，再深入底层优化量子电路的参数更新策略，比如调整梯度下降的步长对量子态收敛速度的影响，整个过程无需切换开发工具，既保证了探索效率，又实现了细节把控，这种“全栈覆盖”的特性，让Python成为量子算法开发的“通用语言”。</p><p>实验数据与算法优化的“动态闭环”，是Python在量子开发中的另一核心优势，这种闭环能力源于其强大的数据处理与实时反馈机制，能够让算法优化的效率提升数倍。量子算法的验证离不开大量的实验数据支撑，每次电路执行都会产生海量的测量结果，这些数据的快速解析与有效利用，直接决定了算法优化的效率，而Python的数据分析库能够实时处理量子测量的原始数据，通过统计建模生成概率分布图谱，甚至自动识别数据中的异常模式，为算法优化提供明确方向。例如在运行量子近似优化算法处理组合优化问题时，可通过Python工具实时分析不同迭代次数下的能量分布，快速定位量子门操作中的冗余环节或参数偏差，进而动态调整电路结构与演化步数，比如减少无效的量子门操作，优化参数初始化的范围，让算法更快收敛到全局最优解。这种“数据反哺优化”的模式，打破了传统开发中“实验-分析-调整”的割裂状态，形成了高效的迭代闭环。更重要的是，Python的可视化工具能够将抽象的量子态变化、概率分布等数据转化为直观的图表，让开发者能够快速捕捉算法的核心问题，比如通过能量变化曲线发现算法陷入局部最优解的迹象，通过量子态保真度曲线观察噪声对算法的影响程度，这种“数据可视化赋能”的能力，极大降低了量子算法优化的难度，加速了从实验到落地的进程。</p><p>Python对量子技术的“前瞻性兼容”，使其在快速迭代的量子领域中保持核心竞争力，这种兼容性并非被动适配，而是主动构建的技术生态，为未来量子计算的发展预留了充足的扩展空间。当前量子硬件呈现出多样化的发展态势，不同厂商的量子处理器在比特类型、拓扑结构、门操作保真度等方面存在显著差异，比如超导量子比特的高集成度、离子阱量子比特的长相干时间，而Python的开源量子框架通过统一的接口设计，能够无缝对接这些不同类型的量子硬件，开发者无需针对特定硬件重构算法，只需通过简单的参数配置即可完成适配。</p>]]></description></item><item>    <title><![CDATA[《Numba AOT编译核心技术：斩断JIT启动延迟的实操手册》 程序员阿伟 ]]></title>    <link>https://segmentfault.com/a/1190000047536597</link>    <guid>https://segmentfault.com/a/1190000047536597</guid>    <pubDate>2026-01-11 22:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Numba的JIT编译曾凭借动态代码加速能力成为很多开发者的首选，但它存在的冷启动滞涩感却在不少低延迟需求场景里成为难以突破的技术壁垒，尤其是在工业实时监测、高频数据推理这类对响应速度要求严苛的领域，这种滞涩感带来的负面影响会被无限放大。比如在某实时工业传感器数据处理场景中，系统需要每0.1秒完成一次多维度数值拟合计算，采用JIT编译时，首次调用函数的编译耗时达到0.5秒，后续每次进程重启都要重复这个编译过程，在高频启停的工况下，短短一小时内累积的编译延迟就超过十分钟，彻底抵消了JIT编译带来的计算加速收益，甚至导致系统无法满足实时性要求。而AOT编译的出现则从底层逻辑上重构了Numba的加速路径，它将编译环节从运行时剥离，转移到离线阶段提前完成，生成可直接加载执行的二进制模块，程序启动时无需再经历代码解析、优化、指令生成等一系列繁琐步骤，直接调用预生成的二进制代码，实现了启动零延迟的高效执行。这种预编译链路穿透能力，让Numba在保留动态语言灵活特性的同时，拥有了接近静态编译语言的启动速度与执行效率，更为关键的是，AOT编译还能针对不同硬件架构进行定向优化，比如在ARM架构的边缘计算设备和x86架构的服务器上分别生成适配指令集的二进制模块，让加速效果在不同平台上都能达到最优，为低延迟计算场景提供了全新的技术解决方案。</p><p>Numba AOT编译的核心竞争力在于其离线编译链路的精准把控，这种把控能力体现在对代码生命周期的全阶段优化，而非局限于运行时的临时处理，这也是它与JIT编译最本质的区别。在学习AOT编译的过程中可以发现，它的工作流程始于代码的静态深度分析，通过构建函数逻辑图谱与数据依赖关系网络，精准识别出代码中的关键计算路径与冗余环节，随后生成与目标架构高度适配的中间表示，这个中间表示会经过多轮递进式优化，包括死代码消除、循环融合、指令重排等核心操作，最大化利用CPU的流水线与缓存特性，避免指令执行过程中的流水线阻塞。不同于JIT编译在运行时受限于时间与系统资源只能进行浅层优化，AOT编译有充足的时间进行深度定制化优化，比如针对特定处理器的AVX2、AVX-512等高级指令集特性定制优化策略，甚至可以结合目标平台的内存层级结构调整数据访问模式，将频繁访问的数据优先映射到L1缓存中，减少内存读写耗时。同时，AOT编译会生成独立的二进制模块，这个模块可以被不同的程序直接调用，无需重复编译，这种特性让它在大规模分布式计算场景中也能发挥出独特优势，比如在由上千个计算节点组成的科学计算集群中，只需在主控节点完成一次AOT编译，生成的二进制模块就能分发到所有子节点直接使用，避免了每个节点都要重复编译的资源浪费，大幅降低了集群部署的时间成本与算力消耗。</p><p>在具体的科学计算场景中，AOT编译的优势会体现得淋漓尽致，比如在处理大规模气象数据的数值模拟任务时，JIT编译的启动延迟问题会变得尤为突出，这类任务往往需要根据气象卫星的实时数据频繁启停计算进程，调整模拟参数与区域范围。以某区域气象数值模拟项目为例，该项目需要对半径500公里的区域进行网格划分，网格分辨率达到1公里，每次模拟计算需要处理上亿个网格点的气象数据，采用JIT编译时，每次启动进程的编译耗时达到30秒，而实际的计算时间仅为2分钟，启动延迟在整体耗时中的占比达到20%，如果一天内进行10次参数调整与模拟，累积的编译延迟就会达到5小时，严重影响任务的执行效率与科研进度。而采用AOT编译的方式，只需要在首次部署时完成一次编译，生成对应的二进制模块，后续每次启动进程时，都可以直接加载这个模块开始计算，完全消除了编译环节的时间开销，将单次任务的整体耗时压缩到2分钟以内。在实践过程中还可以发现，通过调整AOT编译的优化级别，可以在二进制文件体积和执行效率之间找到完美的平衡点，比如在资源受限的边缘计算设备上，如无人机载气象监测终端，可以选择O1轻量级优化模式，在保证基础加速效果的同时，将模块体积减小40%，加快加载速度；而在高性能服务器上，则可以开启O3全量优化模式，通过深度挖掘硬件潜力，让计算性能提升50%以上。此外，AOT编译生成的模块还具备良好的跨平台兼容性，只要目标平台的架构一致，就可以直接移植使用，无需重新编译，比如在x86架构的服务器上编译的模块，可以直接部署到同架构的工业计算机、笔记本电脑等设备上，这为跨环境部署提供了极大的便利，也降低了多设备协同开发的技术门槛。</p><p>Numba AOT编译的落地执行需要遵循清晰的路径，从环境搭建到参数调优，再到模块集成，每个环节都需要精准把控，才能充分发挥其技术优势，任何一个环节的疏漏都可能导致编译失败或加速效果不达预期。首先是编译环境的搭建，需要确保系统中安装了适配的编译工具链，这些工具链是生成目标二进制代码的基础，不同的目标架构需要对应不同的工具链版本，比如针对x86架构的设备，推荐使用GCC 12.0以上版本的工具链，而针对ARM架构的设备，则需要安装ARM GCC交叉编译工具链，同时还要确保Numba版本与工具链版本的兼容性，避免出现因版本不匹配导致的编译异常。接下来是编译参数的调优，这是提升AOT编译效果的关键步骤，比如通过调整目标指令集参数，可以让生成的代码更好地利用CPU的高级特性，开启-mavx2参数就能让代码支持AVX2指令集，大幅提升向量计算的效率；通过设置链接方式参数，可以选择静态链接或动态链接，静态链接虽然会增大文件体积，但可以避免运行时的依赖缺失问题，适合在无网络环境的边缘设备上部署，动态链接则可以减小文件体积，提升模块的复用性，适合在集群环境中使用。然后是模块的集成环节，需要将生成的二进制模块与现有的Python项目进行整合，确保程序能够正确加载和调用模块中的函数，这个过程中需要注意模块的路径配置，比如将生成的模块放入系统环境变量指定的目录，或者在程序中通过绝对路径指定模块位置，避免出现加载失败的情况。在实践过程中还可以总结出一些实用技巧，比如将常用的计算函数集中进行AOT编译，生成一个统一的模块库，按函数功能分为矩阵运算、数值拟合、信号处理等子模块，这样在后续的项目开发中就可以直接调用，无需重复进行编译操作，大大提升了开发效率，同时也便于模块的统一维护与版本管理。</p><p>Numba AOT编译的进阶优化方向集中在指令级的深度定制与模块的轻量化处理，这些优化措施能够进一步挖掘硬件的性能潜力，提升计算任务的执行效率，也是区分普通开发者与资深技术专家的核心能力边界。在指令级定制方面，可以针对特定的计算场景优化指令序列，比如在矩阵乘法运算中，可以调整指令的执行顺序，让数据加载和计算操作并行进行，充分利用CPU的多核特性和SIMD指令集，将传统的串行矩阵乘法转化为并行向量运算，大幅提升运算速度。在学习过程中发现，通过分析目标函数的计算热点，可以针对性地对热点区域进行深度优化，比如使用性能分析工具定位到函数中占比超过80%的循环计算区域，然后对该区域进行循环展开优化，将循环次数设置为CPU流水线宽度的整数倍，比如8次或16次，让指令执行更符合CPU的流水线特性，减少指令停顿的次数，同时还可以加入数据预取指令，提前将后续需要使用的数据加载到缓存中，避免因等待数据而导致的流水线阻塞。在模块轻量化处理方面，可以通过剥离二进制模块中的调试信息和符号表，减小模块的体积，比如使用strip命令去除模块中的调试符号，能将模块体积减小30%以上，加快加载速度，同时还可以对模块进行压缩处理，选择LZ4等高效压缩算法，在保证解压速度的前提下，进一步降低存储和传输成本。此外，还可以采用增量编译的方式，只对修改过的函数进行重新编译，避免对整个模块进行全量编译，比如通过监测函数源文件的哈希值变化，判断函数是否被修改，只有哈希值发生变化的函数才会被重新编译，这种方式可以节省80%以上的编译时间，尤其适合在频繁迭代的项目开发中使用。这些进阶优化技巧需要开发者对硬件架构和编译原理有深入的理解，通过不断的实践和调试，才能找到最适合特定场景的优化方案。</p><p>Numba AOT编译的技术价值不仅体现在当前的高性能计算场景中，更在于其对未来计算架构的前瞻性适配，为新兴计算领域的发展提供独立可靠的技术支撑，这种适配能力也是它能够在技术迭代中保持竞争力的核心原因。随着边缘计算、嵌入式计算和分布式计算的快速发展，低延迟、高效率的计算需求会变得越来越迫切，而AOT编译的特性正好契合了这些需求，它可以在资源受限的边缘设备上实现高效的数值计算，比如智能电表的实时负荷预测、工业机器人的运动轨迹规划，通过AOT编译优化后的代码，能够在算力有限的嵌入式芯片上快速完成复杂计算，满足设备的实时响应要求；同时也可以在分布式集群中实现模块的统一部署和调用，避免重复编译带来的资源浪费，提升集群的整体计算效率。</p>]]></description></item><item>    <title><![CDATA[基于 YOLOv8 的智能杂草检测识别实战 [目标检测完整源码] 南瓜 ]]></title>    <link>https://segmentfault.com/a/1190000047536184</link>    <guid>https://segmentfault.com/a/1190000047536184</guid>    <pubDate>2026-01-11 16:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>基于 YOLOv8 的智能杂草检测识别实战 [目标检测完整源码]</h2><h3>引言：为什么杂草识别是智慧农业中的“硬问题”？</h3><p>在智慧农业场景中，<strong>杂草识别</strong>一直被认为是目标检测中难度较高的一类任务，原因主要集中在以下几点：</p><ul><li>杂草与作物外观高度相似，类别边界模糊</li><li>生长阶段差异大，尺度变化剧烈</li><li>田间光照复杂，背景噪声严重</li><li>实际应用对 <strong>实时性与稳定性</strong> 要求极高</li></ul><p>传统基于规则或简单分类模型的方法难以满足需求，而近年来以 YOLO 为代表的实时目标检测算法，为这一问题提供了可工程化落地的解决路径。</p><p>本文将介绍一个 <strong>基于 YOLOv8 的田间杂草检测完整项目</strong>，从系统架构、模型训练到桌面端可视化部署，展示如何构建一套真正“可用”的农业 AI 检测系统。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536186" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><h4>源码下载与效果演示</h4><p>哔哩哔哩视频下方观看：<br/><a href="https://www.bilibili.com/video/BV13iunzQEhk/" target="_blank">https://www.bilibili.com/video/BV13iunzQEhk/</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536187" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>包含：</p><p>📦完整项目源码</p><p>📦 预训练模型权重</p><p>🗂️ 数据集地址（含标注脚本</p><h3>一、系统整体方案设计</h3><p>本项目并非单一模型实验，而是按照工程系统思路进行设计，整体结构如下：</p><pre><code>杂草图像数据
   ↓
YOLOv8 检测模型训练
   ↓
推理服务模块
   ↓
PyQt5 桌面端可视化系统</code></pre><h4>技术选型说明</h4><table><thead><tr><th>模块</th><th>技术方案</th></tr></thead><tbody><tr><td>检测算法</td><td>YOLOv8（Ultralytics）</td></tr><tr><td>深度学习框架</td><td>PyTorch</td></tr><tr><td>推理接口</td><td>YOLOv8 Python API</td></tr><tr><td>桌面端界面</td><td>PyQt5</td></tr><tr><td>部署方式</td><td>脚本 / 可执行程序</td></tr></tbody></table><p>该方案兼顾了 <strong>算法性能</strong> 与 <strong>使用门槛</strong>，使非算法背景用户也能完成杂草检测任务。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536188" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047536189" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>二、杂草检测任务的数据特点</h3><h4>2.1 数据集构成</h4><p>项目使用的是 <strong>多类别田间杂草目标检测数据集</strong>，所有样本均来自真实农田场景，包含：</p><ul><li>不同生长阶段的杂草</li><li>不同天气与光照条件</li><li>单图多目标、目标重叠情况</li></ul><p>与“整图分类”不同，本项目采用 <strong>目标检测标注方式</strong>，确保模型不仅“知道是什么”，还能“知道在哪里”。</p><h4>2.2 标注格式设计</h4><p>采用标准 YOLO Detection 格式：</p><pre><code>&lt;class_id&gt; &lt;x_center&gt; &lt;y_center&gt; &lt;width&gt; &lt;height&gt;</code></pre><p>所有坐标均为归一化比例，便于模型在不同分辨率下稳定推理。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536190" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>三、YOLOv8 在农业场景中的优势</h3><h4>3.1 算法层面的改进</h4><p>YOLOv8 相较于早期 YOLO 版本，在以下方面表现突出：</p><ul><li><strong>Anchor-Free 设计</strong>，减少超参数依赖</li><li>Task-Aligned Assigner，提高正负样本分配质量</li><li>解耦检测头，提升分类与回归稳定性</li></ul><p>这些改进对 <strong>小目标、密集目标</strong> 的杂草检测尤为关键。</p><h4>3.2 工程适配性</h4><p>YOLOv8 提供了高度统一的 API：</p><ul><li>训练 / 验证 / 推理一套接口完成</li><li>支持 n / s / m 等多模型规模切换</li><li>便于导出 ONNX、TensorRT 等部署格式</li></ul><p>这使其非常适合农业这类 <strong>需要快速验证与部署</strong> 的应用场景。</p><hr/><h3>四、模型训练与评估流程</h3><h4>4.1 数据组织结构</h4><pre><code>dataset/
├── images/
│   ├── train
│   └── val
└── labels/
    ├── train
    └── val</code></pre><p>并通过 YAML 文件统一描述数据路径与类别信息。</p><h4>4.2 训练方式</h4><p>模型训练基于 Ultralytics 官方命令行接口完成，支持：</p><ul><li>预训练权重迁移学习</li><li>自定义类别扩展</li><li>批量大小、学习率灵活调整</li></ul><p>训练过程中重点关注以下指标：</p><ul><li><code>box_loss</code>：定位精度</li><li><code>cls_loss</code>：类别区分能力</li><li><code>mAP@0.5</code>：是否具备部署价值</li></ul><p>在实验中，当 mAP@0.5 稳定达到较高水平后，即可进入部署阶段。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536191" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>五、推理系统与结果展示</h3><h4>5.1 推理流程</h4><p>推理阶段通过 Python API 调用 YOLOv8 模型，自动输出：</p><ul><li>检测框位置</li><li>杂草类别</li><li>置信度分数</li><li>可视化结果图像</li></ul><p>该过程无需手动编写复杂后处理逻辑，极大降低了系统集成成本。</p><h4>5.2 检测效果分析</h4><p>在真实田间场景中，系统表现出以下特点：</p><ul><li>对常见杂草具有良好识别稳定性</li><li>支持单图多目标检测</li><li>在视频与实时流场景中保持较高帧率</li></ul><hr/><h3>六、PyQt5 桌面端系统设计</h3><p>为了让模型真正“用起来”，项目构建了一个 <strong>桌面级杂草检测工具</strong>，核心功能包括：</p><ul><li>单张图片检测</li><li>文件夹批量检测</li><li>视频文件检测</li><li>USB 摄像头实时识别</li><li>检测结果自动保存</li></ul><h4>6.1 模型与界面解耦</h4><p>PyQt5 界面仅负责：</p><ul><li>数据输入</li><li>参数控制</li><li>结果展示</li></ul><p>所有算法逻辑独立封装，便于后期模型替换或系统升级。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536192" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>七、应用场景与扩展价值</h3><p>该系统不仅适用于实验验证，还具备进一步落地潜力：</p><ul><li>智慧农业除草辅助系统</li><li>农机视觉模块原型</li><li>农业 AI 教学与培训</li><li>毕业设计与科研实验平台</li></ul><p>通过替换数据集与类别配置，也可快速迁移至 <strong>病虫害检测、作物识别等任务</strong>。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536193" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>总结</h3><p>本文从工程实践角度，系统介绍了一套 <strong>基于 YOLOv8 的田间杂草检测完整解决方案</strong>。该项目并非停留在模型精度对比层面，而是贯穿了从数据、算法到可视化部署的完整流程，真正体现了 AI 技术在农业场景中的落地方式。</p><p>其核心价值在于：</p><ul><li>流程完整，可复现</li><li>架构清晰，易扩展</li><li>兼顾算法性能与工程实用性</li></ul><p>对于希望深入理解 <strong>目标检测如何服务于真实农业应用</strong>，或希望快速构建可交付 AI 系统的开发者而言，该项目具备较高的学习与实践参考价值。</p><p>本文围绕田间杂草智能识别这一典型的智慧农业应用场景，系统阐述了一套基于 YOLOv8 的目标检测工程方案。通过对数据集构建、模型训练与评估、推理流程以及 PyQt5 桌面端可视化系统的整体介绍，完整呈现了从算法研发到实际可用系统落地的技术闭环。该项目不仅验证了 YOLOv8 在复杂田间环境下对多类别杂草检测的有效性与实时性，也展示了深度学习模型在农业场景中工程化、产品化的实现路径。对于希望将计算机视觉技术应用于智慧农业、科研教学或工程实践的开发者而言，该方案具备较强的参考价值与可扩展空间。</p>]]></description></item><item>    <title><![CDATA[Agent Skills简介 Yumenokanata ]]></title>    <link>https://segmentfault.com/a/1190000047536144</link>    <guid>https://segmentfault.com/a/1190000047536144</guid>    <pubDate>2026-01-11 15:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>什么是Skills</h2><p>全称是“<strong>Agent Skills</strong>”，它是一种轻量级、开放的、渐进式披露的AI提示词文档群的管理格式。帮助AI更好地按照指定的要求完成特定的工作。</p><h3>它为了解决什么问题？</h3><p>目前的AI虽然能力很强大，在训练的时候已经学习了人类几乎所有的知识，但是基于大模型本身的原理，还是存在下面的问题：</p><ul><li>AI的知识有局限性，训练它的时候虽然会将所有人类的知识教给它，但是陷于成本和获取问题，并不是每个领域的每个知识细节它都有学习过。</li><li>AI的知识是有时效性的，它只会知道当时训练时间点上的知识，无法了解实时的知识（MCP和RAG可以一定程度解决这个问题）</li><li>特定任务会有专有的执行顺序和执行要点。</li><li>一个完整的工作，背后都会有一套SOP（标准作业流程），这是一套庞大的提示词体系文档。</li><li>AI的上下文不能太长，基于LLM本身的注意力机制、运行成本考虑，需要合理控制AI的上下文。将所有的上下文都一股脑抛给AI，会导致输出质量急剧下降。</li><li>如果想要训练特定领域的模型，通过微调的方式成本和难度太高。</li></ul><h3>Skills</h3><p>基于上面的问题的存在，claude提出了一种叫Agent Skills（后面简称Skills）的提示词文档管理格式，并在2025年12月16日，将这个格式作为公开标准进行了开放 <a href="https://link.segmentfault.com/?enc=x5WrkfcEjz7YDOqH6xB%2Ftg%3D%3D.4shW0ykwY00FFYosMvP6X%2Fb8SW%2BbFh2qKRfmmkazqHTVnI9R%2BvUw%2BnaDr%2F6auCUa" rel="nofollow" target="_blank">Agent Skills</a></p><p>一个skill可以理解为一个特定工作的指导说明书，是“应该怎么做”的步骤说明书（当然从原理上来说，严格来说skills并不限制内容应该是什么）。<br/>你可以将完成特定工作的所有：步骤、注意事项、示例、相关知识等等都集成到一个skill中。并且它支持包含脚本、多媒体资源、庞大的额外文档资源等，并在实际需要的时候执行或者载入（skill系统会自动控制上下文，按需加载）。<br/>而这些复杂的资料、资源、脚本都会包含在一个skill文件夹中，你可以在将它们全部打包，在另一个项目或者另一台电脑上只需要导入这个文件夹就可以获得这个“技能”（skill），使复杂的工作具有极其简单的迁移性。</p><h3>对比</h3><h4>和rules的区别</h4><p>概念上和rules不同，它不是“应该遵守什么”，而更像是“应该怎么做”。<br/>不过最核心的区别是rules是固定完整加载的，每次提问都会完整地加载到对话中，不会按照需要选择性加载、也不会逐步加载，所以rules的编写一般是全局性的规范、并且不能太多。</p><p>而skills不是一定加载的，会根据任务实际需要来加载特定skill的文档。</p><h4>它和MCP的区别</h4><p>MCP也是一套让AI提供额外能力的开放格式，但是MCP更专注于“工具调用”，让AI具备和外部环境交互的能力，但本身对于上下文、提示词相关的控制的特性会弱一些（或者说MCP并不专注于这些）。<br/>MCP只是简单将所有提供的工具全部列给AI，如何使用、何时使用还是由AI在无指导的情况下自行决定。<br/>另外MCP的开发要复杂很多，需要开发一整套服务、并且部署。而skills只是一套文件，门槛低了非常多。<br/>而skills本质也是一套提示词，所以它也可以指导AI进行MCP的调用。</p><h4>它和工作流（workflow）的区别</h4><p>类似Dify、coze、n8n的工作流也能指导特定工作按照特定的顺序进行执行，但是：</p><ul><li>工作流强依赖于特定平台，并没有统一标准，不同平台的工作流标准完全不同，完全无法之间迁移</li><li>工作流的开发依赖于特定平台能够提供的节点，约束性更强，但是限制也更多（比如很多平台的编程节点只能支持python和js）</li><li>工作流固定了每个节点的执行顺序和信息传递的方向，但是skill相对来说宽松了很多，可以留给AI更多自由决策的空间。</li><li>skill本质上只是一套渐进式加载文档的协议，实际能做到的事情会更有灵活性</li></ul><h3>Skills结构</h3><p>从本质上讲，技能是一个包含<code>SKILL.md</code>文件的文件夹。该文件至少包含元数据（例如，<code>&lt;metadata&gt; </code>name<code> 和`description</code>&lt;file&gt;`）以及指示智能体如何执行特定任务的指令。技能还可以包含脚本、模板和参考资料。</p><pre><code>my-skill/
├── SKILL.md          # 必须: 说明 + metadata
├── scripts/          # 可选: 可执行的代码
├── references/       # 可选: 文档
└── assets/           # 可选: 模板, resources等</code></pre><h3>渐进式披露</h3><p>skills的核心技术特点就是<strong>渐进式披露</strong>：</p><ul><li><strong>发现</strong>：初始加载给AI的资料只有每个可用skill的名称（name）和描述（description），由AI根据需要选择需要进一步加载的skill</li><li><strong>激活</strong>：当AI选择了某个skill，系统才会完整加载<code>SKILL.md</code>文件的内容到AI上下文中。</li><li><strong>执行</strong>：AI在按照指令执行的时候，如果需要进一步加载相关的引用文档或者执行绑定脚本的时候，系统才会进一步加载。</li></ul><p>保证了AI只会了解到最小、最贴近的信息，保证了AI响应的及时性、准确性。</p><h2>Skills的详细结构</h2><p>一个skill是一个目录，其中至少包含一个<code>SKILL.md</code>文件：</p><pre><code>skill-name/
└── SKILL.md          # 必须</code></pre><p>其中：</p><ul><li>文件夹名字就是skill的名字</li><li>“<strong>SKILL.md</strong>”文件名必须严格一致，“SKILL”全大写，文件扩展名为“md”</li><li>文件夹下除了SKILL.md文件也可以添加其他文档，但从最佳实践来说，最好也是特定工作的执行步骤（这些文档就没有文件名的强制要求了）。而相关的引用的资料、脚本都应该放在子文件夹中。</li></ul><p>还可以根据需要选择性地添加其他目录：<code>scripts/</code>,<code>references/</code>,<code>assets/</code></p><h3>SKILL.md 格式</h3><p>文件<code>SKILL.md</code>必须包含YAML前置的元数据，后面是Markdown格式的详细内容。</p><h4>前言（必填）</h4><pre><code>---
name: skill-name
description: A description of what this skill does and when to use it.
---</code></pre><p>其中<code>name</code>和<code>description</code>是必须的，而其他字段是非必须的</p><p>|Field|Required|约束条件|<br/>|:-:|:-:|:-|<br/>|<code>name</code>|是的|最多64个字符。仅限小写字母、数字和连字符。不得以连字符开头或结尾。|<br/>|<code>description</code>|是的|最多 1024 个字符。非空。描述技能的效果以及何时使用。|<br/>|<code>license</code>|不|许可证名称或捆绑许可证文件的引用。|<br/>|<code>compatibility</code>|不|最多 500 个字符。说明环境要求（目标产品、系统软件包、网络访问等）。|<br/>|<code>metadata</code>|不|任意键值映射，用于添加元数据。|<br/>|<code>allowed-tools</code>|不|技能可使用的预先批准工具列表，以空格分隔。（实验性功能）|</p><p>其中，由于<code>name</code>和<code>description</code>是一定加载，并且会帮助AI进行skill的选择，所以在格式和内容上会有比较严格的限制：</p><h5>name</h5><ul><li>必须为 1 到 64 个字符</li><li>只能包含 Unicode 小写字母、数字和连字符 (a-z 和 -)（不过也有看到过中文的名称，感觉这个更多是规范上的约束）</li><li>不能以连字符开头或结尾</li><li>不能包含连续的连字符 (--)</li><li>必须与父目录名称匹配</li></ul><h5>description</h5><ul><li>长度必须为 1-1024 个字符</li><li>应描述该技能的功能以及何时使用</li><li>应包含有助于代理识别相关任务的具体关键词</li></ul><p>再次强调一下：由于<code>name</code>和<code>description</code>是一定加载，并且是帮助AI进行skill选择的，所以一定要保证AI能够通过name和描述可以正确精准地把握此skill的功能，并且不会出现歧义。</p><p>比如：</p><p>Bad：</p><pre><code>name: PDF
description: PDF助手</code></pre><p>Good：</p><pre><code>name: pdf-processing
description: 该工具可以从 PDF 文件中提取文本和表格，填写 PDF 表单，并合并多个 PDF 文件。当您需要处理 PDF 文档，或者用户提及 PDF、表单或文档提取时，请使用此工具。</code></pre><h4>Body</h4><p>前置数据之后就应该是Markdown的正文。格式上没有严格的限制，只需要编写能帮助AI有效完成任务的内容即可。</p><p>按照最佳实践，推荐章节：</p><ul><li>基本说明</li><li>分步说明</li><li>输入输出示例</li><li>常见边界情况和注意事项</li></ul><p>由于SKILL.md在激活技能的时候是完整加载的，如果特定任务的描述内容较长，可以将较长的部分拆分到多个引用文件中，AI按需进一步加载。</p><h3>可选目录</h3><p>为了增强AI完成特定任务的能力，可以给skill添加一些额外的资源帮助其完成工作。</p><h4>scripts/</h4><p>包含AI可以直接执行的代码。脚本应该是：</p><ul><li>脚本是完整可执行的</li><li>能够输出有效的错误信息（帮助AI根据信息进行错误排查）</li><li>优雅地处理极端情况</li></ul><p>支持的语言并没有限制，保证AI在调用的时候能正确执行即可。常见的语言包括Python、Bash和JavaScript.</p><p>另外在SKILL中要求AI执行某个脚本的时候，一般认为AI是不会去查看此脚本的完整代码的，所以需要详细描述调用方式，让AI在不知道脚本详细的情况下正确调用脚本（也可以有效控制AI上下文的纯净性和长度）</p><h4>references/</h4><p>包含AI在需要时可以查阅的其他文档。</p><p>格式上没有特殊要求，但从最佳实践的角度来说，最好保持每个文件内容的简洁性。AI会按需加载，所以文件越小越精确，AI的理解能更准确。</p><h4>assets/</h4><p>一些静态资源，按照实际需求添加（可以理解为others文件夹），比如（不限于）：</p><ul><li>模板（文档模板、配置模板）</li><li>图片（图表、示例）</li><li>数据文件（查找表、模式）</li></ul><h3>文件引用</h3><p>如果要在技能文档中引用，采用Markdown的标准格式，路径采用skill根目录的相对路径：</p><pre><code>查看 [详细指导](references/REFERENCE.md) 以了解详细</code></pre><h2>Skill示例</h2><p>上面介绍了skill的基本情况，下面来实践一个skill。</p><p>比如，在某个项目有个需求：需要在访问特定网页的时候切换到指定的代理，但是在访问公网网站的时候取消这个代理。（当然，这个可以用一些代理软件实现，但这里主要是为了演示skill的能力）</p><p>首先在项目文件夹下的<code>.claude</code>文件夹下（我使用的是claude code，所以在这个文件夹下，其他工具请按照各自工具的目录放置）创建<code>skills/switch-stg-network-proxy</code>的文件夹</p><pre><code>.claude
└── skills/
     └── switch-stg-network-proxy/
          └── SKILL.md</code></pre><p>SKILL.md的内容为：</p><pre><code>---
name: switch-stg-network-proxy
description: Switch system's network configuration to allow access to stg store.
---

# 切换 stg 环境的网络配置

## Overview

XXX这个App对应的下单的网站是需要特定的网络（固定IP）以及特定的网络代理配置才能够访问，但同时这个特殊的网络配置只能访问XXX的特定下单网站，无法访问其他网站，所以需要来回进行切换。
这个文档会详细描述如何进行网络配置的切换。

此技能能够帮助用户：
1. 从普通网络配置为特定的网络配置，以便能够访问下单网站。
2. 从特定网络配置切换回普通网络配置，以便能够正常访问其他网站。

## 切换为 stg 环境商店的网络配置

1. 将系统代理中http代理和https代理设置为：
  - 主机名：xxxx
  - 端口：0000
</code></pre><blockquote>注： 这里并不是我的SKILL的原始内容，隐藏、修改了一些项目内的信息。</blockquote><p>此时一个<code>skill</code>已经写好了，我们就可以在claude code中让AI调用了：</p><pre><code>将当前网络配置为stg特定网络配置</code></pre><p>AI会识别到可以调用skill来实现这个需求：</p><pre><code>⏺ 我会帮你将网络配置切换到stg环境。让我先查看一下可用的技能配置。

⏺ Read(.claude/skills/switch-stg-network-proxy/SKILL.md)
  ⎿  Read 29 lines</code></pre><p>但是似乎结果并不是我们所希望的，AI只是将需要配置的步骤给列出来了，但是并没有真正地去配置系统的设置。这是因为AI并没有和外部系统直接交互的功能，我们的文档中也没有告诉AI应该怎么去设置系统的代理。</p><p>可以采用很多的方式解决这个问题，这里采用的是编写脚本的方式。我们使用AI编写两个bash脚本来实现打开/关闭代理的功能：</p><pre><code>你编写两个shell脚本实现上面的网络配置切换</code></pre><p>然后我们将这两个脚本放到skill的scripts目录下面：</p><pre><code>.claude
└── skills/
     └── switch-stg-network-proxy/
          ├── scripts/ 
               ├── restore_normal_network.sh
               └── switch_to_stg.sh
          └── SKILL.md</code></pre><p>然后修改<code>SKILL.md</code>中的指令描述（生成脚本的时候，AI也生成了脚本的使用说明，修改一下就可以搬过来了）</p><pre><code>---
name: switch-stg-network-proxy
description: Switch system's network configuration to allow access to stg store.
---

# 切换 stg 环境 商店的网络配置

## Overview

这个项目对应的下单的网站是需要特定的网络（固定IP）以及特定的网络代理配置才能够访问，但同时这个特殊的网络配置只能访问特定下单网站，无法访问其他网站，所以需要来回进行切换。
这个文档会详细描述如何进行网络配置的切换。

此技能能够帮助用户：
1. 从普通网络配置为特定的网络配置，以便能够访问下单网站。
2. 从特定网络配置切换回普通网络配置，以便能够正常访问其他网站。

## 切换为 stg 环境商店的网络配置

执行`scripts/switch_to_stg.sh`，此脚本会完成：
1. 检测网络服务(Wi-Fi)
2. 检查当前WiFi连接(建议连接到XXX)
3. 设置HTTP代理
4. 设置HTTPS代理
5. 配置代理绕过规则
6. 显示配置结果

## 从 stg 环境的网络配置切换回普通网络配置

执行`scripts/restore_normal_network.sh`，此脚本会完成：
1. 检测网络服务(Wi-Fi)
2. 显示当前代理配置
3. 关闭HTTP代理
4. 关闭HTTPS代理
5. 清除代理绕过规则
6. 验证配置已恢复

## 注意事项

。。。

## 代理配置详情

。。。

## 手动验证

### 查看当前代理设置

。。。

### 测试网络连接

。。。

## 故障排除

。。。
</code></pre><blockquote>注： 这里的文本依然是隐去了项目相关的内容和部分描述。并不是实际的skill原文</blockquote><p>然后再和AI沟通，就可以正常使用skill进行代理切换了：</p><pre><code>&gt; 帮我把当前网络切换到stg测试用的网络配置 </code></pre><pre><code>⏺ 我会帮你切换到 stg 测试用的网络配置。我看到项目中已经有一个专门的 skill 来处理这个任务。

&gt; The "switch-stg-store-network-proxy" skill is running 

&gt; The "switch-stg-store-network-proxy" skill is running 

⏺ 好的,我现在帮你执行切换到 stg 环境网络配置的脚本。

⏺ Bash(bash .claude/skills/switch-stg-store-network-proxy/scripts/switch_to_stg.sh)
  ⎿  ========================================
     切换到 stg环境网络配置
     ========================================
     … +39 lines (ctrl+o to expand)

⏺ ✓ 网络配置已成功切换到 stg 环境!</code></pre><h2>官方Skill的示例</h2><p>上面演示的是最基础的Skill创建的示例，但实际上skill可以负责很复杂的工作。</p><p>官方提供了很多的<a href="https://link.segmentfault.com/?enc=cyA2YwWdJqZhJxHmBtVaxA%3D%3D.Pd2Mynjl5bGVDCT93V8iWDhwTiYyVwqcjDyD9oySgWUoE9IOKFVithxfI62e4bq6" rel="nofollow" target="_blank">skill示例</a>，从简单到复杂，很有参考意义。</p><p>这里简单说明一下<a href="https://link.segmentfault.com/?enc=y8j7QP9Ctzp82OGiEWfGzg%3D%3D.gpH67ToGnbX8ZN1d6vWZqDhChzJr9e5cwZILS1YzgE1%2F4sYvHxaC4A1jB%2F1f1I7%2FB2SLDFk9%2Bq5ug7HKjV8c5Q%3D%3D" rel="nofollow" target="_blank">docx</a>这个skill,它提供的是AI能够对docx格式文件的读取、修改和创建的能力。是一个相对比较复杂的skill。</p><p><img width="408" height="652" referrerpolicy="no-referrer" src="/img/bVdnCt6" alt="" title=""/></p><p>相信在阅读了上面的说明后，它的目录结构应该是能看懂的。</p><p>这里要说明的是，docx skill的根目录下面的文件：</p><ul><li><code>LICENSE.txt</code>开源协议，公开库一般都需要添加</li><li><code>SKILL.md</code>技能文件</li><li><code>docx-js.md</code>：使用js库生成docx的教程</li><li><code>ooxml.md</code>： Office Open XML 技术参考</li></ul><p>可以看到，当技能中有部分内容过长的时候就会提成独立的文件，优化AI的上下文。</p><p>在SKILL中引用的时候也会特别说明：</p><p><code>SKILL.md</code></p><pre><code class="markdown"># Creating a new Word document

When creating a new Word document from scratch, use **docx-js**, which allows you to create Word documents using JavaScript/TypeScript.

### Workflow
1. **MANDATORY - READ ENTIRE FILE**: Read [`docx-js.md`](docx-js.md) (~500 lines) completely from start to finish. **NEVER set any range limits when reading this file.** Read the full file content for detailed syntax, critical formatting rules, and best practices before proceeding with document creation.
2. Create a JavaScript/TypeScript file using Document, Paragraph, TextRun components (You can assume all dependencies are installed, but if not, refer to the dependencies section below)
3. Export as .docx using Packer.toBuffer()</code></pre><p>这个sample中演示了如何进行复杂任务的描述：决策分支、三方库的使用、注意事项、相关资料背景等等。非常推荐大家看看，当然看其他相对简单的sample也很不错 <a href="https://link.segmentfault.com/?enc=uJlYKT5SBWcPCGiOmm6LUg%3D%3D.n8V%2BbM4NxUzP1P5KjKnaf1EfoLAwZTRMw66Tee%2FyRNNGiguoCjvFHzRUQa8YFsd0At%2FBlSdOOG15%2FHTbt%2F%2FKwA%3D%3D" rel="nofollow" target="_blank">samples</a></p><h2>skill能做什么</h2><p>官方的示例实际上已经展示了很多的skill了：</p><ul><li><code>brand-guidelines</code>：anthropic官方设计风格说明</li><li><code>canvas-design</code>： 按照需要，创建设计理念，并在canvas上创建图片文件进行表达</li><li><code>frontend-design</code>： 创建具有独特风格、生产级品质且设计精良的前端界面。</li><li><code>mcp-builder</code>： 帮助创建高质量的 MCP（模型上下文协议）服务器</li><li><code>skill-creator</code>： 创建有效skills的指南</li></ul><p>等等</p><p>可以看到，因为skill只是提示词，应用可以非常广泛，包括给上下文添加设计风格的说明。<br/>甚至skill本身也是可以<strong>自举</strong>的（即自己创建自己）</p><p>除了官方这些示例之外，也有公开的的skill集： <a href="https://link.segmentfault.com/?enc=n73G%2BVyHaSWfLFnAeYrmng%3D%3D.nziWuoDG5exZmoGqL8O%2Bp55KCODsjaFAJsMvwt49p%2Bs%2FqDA9srLuyHrV4RFKka1WGsU3xlfLOmpF%2BoHw9ta7Pg%3D%3D" rel="nofollow" target="_blank">awesome-claude-skills</a>，它会更加多样、更加充满想象力。 <br/>(这只是其中一个开源仓库，由于这个只是一个开源协议，还会有很多其他地方可以找到skills)</p><p><img width="723" height="190" referrerpolicy="no-referrer" src="/img/bVdnCt7" alt="" title="" loading="lazy"/><br/><img width="723" height="223" referrerpolicy="no-referrer" src="/img/bVdnCt8" alt="" title="" loading="lazy"/><br/><img width="723" height="219" referrerpolicy="no-referrer" src="/img/bVdnCt9" alt="" title="" loading="lazy"/></p><p><code>Android adb控制器</code>： 告诉AI如何使用adb和android设备进行交互。</p><p>这里只列出了一部分，大家可以进网站查看更详细的内容。</p><blockquote>使用方式：下载对应技能的完整文件夹，放到claude code工作目录的<code>.claude/skills</code>目录下即可。</blockquote><h2>总结</h2><p>就格式来说，skills是比较简单的。但是正是这种“简单”，降低了每个人编写skill的难度，也给skill提供了非常大的自由度。可以说用精巧得设计，解决了很多的痛点。</p><p>生产过程中的各种标准化流程，之前很难让AI遵守，现在可以了；流程中的部分步骤需要执行脚本，而不是完全由AI生成，现在可以了；和AI互动的流程很难分享给别人，现在可以了。</p><p>一个标准化的AI模型+一系列skills的组合，就能搭建出一套标准化的自动工作流。</p><p>可以说skills和MCP一样，都是非常有潜力的。<br/>但是目前对skills的支持还比较有限，claude code算是支持最好的，codex只是实验性地支持；其他的模型和工具截至目前（2026年1月8日），还没有对skills的明确支持。所以要尝试skills还是要用claude code。</p><p>期待未来能看到更丰富的应用。</p>]]></description></item><item>    <title><![CDATA[二叉树概念简介 久远寺门邸 ]]></title>    <link>https://segmentfault.com/a/1190000047536096</link>    <guid>https://segmentfault.com/a/1190000047536096</guid>    <pubDate>2026-01-11 14:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <pre><code>二叉树是每个节点最多有两个子树（左、右子树）且子树有左右次序的数据结构，是树形结构中最基础且应用极广的类型。本文将从核心概念、特性、遍历、实现与应用等方面展开介绍</code></pre><h3>一、核心概念与定义</h3><p><strong>定义：n 个节点的有限集合，或为空，或由根节点 + 两棵互不相交的左/右子树组成，子树次序不可颠倒（有序树。</strong></p><h4>基本术语</h4><ol><li>根节点：树的顶层节点，无父节点。</li><li>叶子节点：无左右子树的节点。</li><li>深度/高度：根到节点的层数为深度，节点到叶子的最大层数为高度。</li><li><p>度：节点拥有的子树数（二叉树节点度≤2）。</p><h3>二、特殊二叉树类型</h3></li><li>满二叉树：特征为每层节点数达最大值（深度k有2^k-1个节点），可在完全二叉树的基础模型中应用。</li><li>完全二叉树：特征为除最后一层外均满，最后一层从左到右连续填充，可在堆排序、优先队列中运用。</li><li>二叉搜索树（BST）：特征为左子树节点值＜根，右子树节点值＞根，子树均为BST，可应用在在动态查找、排序等。</li><li><p>平衡二叉树（AVL）：特征为左右子树高度差≤1，子树均平衡，可解决 BST 退化为链表问题。</p><h3>三、重要性质</h3></li><li>第i层最多有2^(i-1)个节点（根为第 1 层）。</li><li>深度为h的二叉树最多有2^h-1个节点。</li><li>叶子节点数n0=度为2的节点数n2+1。</li><li><p>n个节点的完全二叉树深度为⌊log₂n⌋+1。</p><h3>四、遍历方式（含代码示例）</h3><p>遍历是访问所有节点的过程，核心有 4 种方式，以下以 C 语言实现二叉树节点定义与递归遍历。</p><h4>节点定义</h4><pre><code>typedef struct TreeNode
{
 int data;
 struct TreeNode* left;
 struct TreeNode* right;
} TreeNode;</code></pre><h4>遍历实现</h4></li><li><p>前序遍历（根→左→右）</p><pre><code>void preOrder(TreeNode* root) 
{
 if (root) 
 {
     printf("%d ", root-&gt;data);
     preOrder(root-&gt;left);
     preOrder(root-&gt;right);
 }
}</code></pre></li><li><p>中序遍历（左→根→右）</p><pre><code>void inOrder(TreeNode* root) 
{
 if (root) 
 {
     inOrder(root-&gt;left);
     printf("%d ", root-&gt;data);
     inOrder(root-&gt;right);
 }
}</code></pre></li><li><p>后序遍历（左→右→根）</p><pre><code>void postOrder(TreeNode* root) 
{
 if (root) 
 {
     postOrder(root-&gt;left);
     postOrder(root-&gt;right);
     printf("%d ", root-&gt;data);
 }
}</code></pre></li><li><p>层序遍历（按层访问）：借助队列实现，适用于树的广度优先搜索。</p><h3>五、存储结构</h3></li><li>顺序存储：用数组按层序存储完全二叉树，父节点i的左孩子为2i，右孩子为2i+1，适合完全二叉树。</li><li><p>链式存储：每个节点含数据域和左右指针，灵活适配各类二叉树，是最常用存储方式。</p><h3>六、应用场景</h3></li><li>数据检索：BST、AVL树支持高效增删查（平均O(logn)）。</li><li>表达式解析：二叉树表示算术表达式（运算符为根，操作数为叶子）。</li><li>路径规划：决策树、哈夫曼树用于数据压缩。</li><li>堆结构：基于完全二叉树实现优先队列。</li></ol>]]></description></item><item>    <title><![CDATA[【节点】[Channel-Split节点]原理解析与实际应用 SmalBox ]]></title>    <link>https://segmentfault.com/a/1190000047535955</link>    <guid>https://segmentfault.com/a/1190000047535955</guid>    <pubDate>2026-01-11 12:02:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><a href="https://link.segmentfault.com/?enc=PvvrzZlsYWQO2aYaaQU2Pg%3D%3D.J4G2m2R6jdCE60j7sDr2NDZ57%2ByosrTVHu6r3c1%2Fg0p9gt7RvaloJUBFF2DNalyPVfkiBQ8BGiECoeksFjbOT8UU6ZA5nxIr%2FCXAy28BIVU0CiBz983RLbSbUFitK1Qbo0boGb0kxCO7w2hBjT53JVvP0NupqJbTbWUwG5fRBpM6O965n0a8EGCDYg7pbH9tXlLzlF7NOIhkDOeBV1Ff5D4gH4nG2gOE%2FwwuvrG%2Fq2s%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong></blockquote><p>拆分节点（Split Node）是Unity ShaderGraph中用于将向量分解为独立浮点数值的基础工具。它通过提取输入向量的各个通道（R/G/B/A），将多维向量数据拆分为单精度浮点数输出，广泛应用于材质编辑、数据处理及算法逻辑中。该节点能够自动处理不同维度的输入向量，支持Vector2、Vector3和Vector4类型，并根据输入维度智能调整输出内容。</p><p>Split节点的核心优势体现在三个方面：维度分解功能支持将Vector2/3/4向量拆分为独立的浮点数值；灵活适配特性使其能够自动处理低维输入，例如Vector2仅输出R和G通道，B与A通道自动补零；逻辑清晰的设计提供了直观的通道分离功能，极大简化了向量数据操作流程。在ShaderGraph的可视化编程环境中，Split节点作为数据流转的关键环节，承担着将复合数据转换为单一数值的重要任务。</p><p>在图形渲染管线中，Split节点扮演数据预处理器的角色。当需要单独操作向量的某个分量时，它提供了最直接的解决方案。例如，在调整材质颜色属性时，若需仅修改红色通道强度而不影响其他通道，Split节点便展现出其独特价值。</p><h2>端口与参数详解</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047535957" alt="" title=""/></p><h3>输入端口配置</h3><p>Split节点的输入端口设计简洁而强大，仅包含一个名为“In”的动态矢量输入。该端口类型为Dynamic Vector，可接受Vector2、Vector3或Vector4类型的输入数据，无需用户手动指定向量维度，从而具备较高的灵活性，适应多样化的数据流场景。</p><p>输入端口的核心特性包括：类型自适应性，能自动识别和处理不同维度的输入向量；数据流兼容性，可无缝连接其他节点输出的向量数据；实时处理能力，对输入向量进行即时分解操作。在实际应用中，用户可将任何生成向量数据的节点（如纹理采样节点、数学运算节点、时间节点等）直接接入Split节点的输入端口。</p><p>输入端口的技术规格如下：支持的最小维度为Vector2，最大为Vector4；所有输入均按浮点数精度处理；端口连接无特殊限制，可接入任何输出向量类型的节点。</p><h3>输出端口架构</h3><p>Split节点提供四个独立的浮点数输出端口，分别对应向量的不同通道：</p><ul><li>R（红色通道）：输出输入向量的第一个分量，对应Vector2的x、Vector3的x、Vector4的x</li><li>G（绿色通道）：输出输入向量的第二个分量，对应Vector2的y、Vector3的y、Vector4的y</li><li>B（蓝色通道）：输出输入向量的第三个分量，Vector2输入时为0，Vector3为z，Vector4为z</li><li>A（Alpha通道）：输出输入向量的第四个分量，Vector2与Vector3输入时为0，Vector4为w</li></ul><p>该输出设计使用户能够单独访问和操作向量的每一个分量，为复杂着色器效果提供了基础支持。每个输出端口独立运作，用户可根据需要选用其中部分或全部端口，未使用的端口保持断开状态，不影响其他端口功能。</p><p>输出端口的数值范围取决于输入向量的取值范围。通常情况下，颜色通道的取值范围为[0,1]，坐标数据可能超出该范围。理解各端口的预期数值范围对正确使用Split节点至关重要。</p><h2>技术原理解析</h2><h3>核心算法逻辑</h3><p>Split节点的内部算法基于向量分量的索引访问机制。当接收到输入向量时，节点会根据向量的实际维度，按照预定义的通道映射关系提取各分量值。对不同维度的输入向量，节点处理逻辑一致，但会根据维度自动调整输出内容。</p><p>对于Vector2输入，节点执行以下操作：提取索引0位置的R通道值，提取索引1位置的G通道值，B与A通道值固定为0。Vector3输入的处理包括：提取索引0的R通道值，索引1的G通道值，索引2的B通道值，A通道值固定为0。Vector4输入则完整提取所有四个通道：索引0的R、索引1的G、索引2的B和索引3的A。</p><p>算法实现的关键在于动态类型识别。节点在运行时首先检测输入向量的维度，然后根据检测结果选择相应的处理路径。该设计避免了硬编码的局限性，使节点能灵活应对各类输入情况。</p><h3>生成代码解析</h3><p>Split节点在Shader编译阶段生成相应的HLSL代码。根据输入类型不同，生成的代码表现为多个独立的浮点数变量声明与赋值操作。代码生成过程遵循严格的类型匹配规则，确保输出值与输入向量的维度完全对应。</p><p>生成的HLSL代码具有高度优化特性，编译器会根据实际使用情况对未使用的输出通道进行剪枝优化，避免不必要的计算开销。该机制使Split节点在性能方面表现优异，即使在高频率的片段着色器中使用也不会造成明显负担。</p><p>在代码实现层面，Split节点的生成代码会根据输入类型自动调整。对于Vector3输入，生成的代码包含三个有效赋值和一个零值赋值。这种智能化的代码生成策略确保了着色器的高效执行。</p><h2>应用场景与实战案例</h2><h3>材质参数分离应用</h3><p>在材质参数分离场景中，Split节点发挥重要作用，特别是在处理法线贴图时，设计师常需独立控制各通道以实现特殊视觉效果。</p><ul><li>法线贴图通道独立控制：通过Split节点分离法线贴图的RGB通道，设计师可单独调整各通道强度，实现非物理准确但视觉上令人满意的效果</li><li>多参数材质调节：当使用一张纹理包含多个材质参数（如粗糙度、金属度、环境光遮蔽等）时，使用Split节点可分离这些参数并进行独立控制</li><li>动态材质效果：结合时间节点或动画曲线，对分离后的通道值进行动态修改，创造随时间变化的材质效果</li></ul><p>具体应用实例之一是创建动态腐蚀效果。通过Split节点分离噪声纹理的各通道，分别控制不同通道的腐蚀速度与强度，可产生更自然、复杂的腐蚀动画。</p><h3>坐标系统处理技术</h3><p>坐标系统处理是Split节点的另一重要应用领域。在处理UV坐标时，常需单独操作U和V分量以实现各类纹理效果。</p><ul><li>UV坐标分量提取：通过Split节点分离UV坐标的x和y分量，可独立控制水平和垂直方向的纹理滚动速度</li><li>局部坐标变换：处理物体局部坐标系时，使用Split节点分离xyz分量，实现基于单个坐标轴的特效</li><li>极坐标转换：实现极坐标效果时，需分别处理距离和角度分量，Split节点为此提供了基础支持</li></ul><p>在实际项目中，Split节点常用于创建高级UV动画效果。例如，通过单独控制U坐标实现水平流动的水面效果，同时保持V坐标不变以获得正确的纹理拉伸。</p><h3>数据可视化实现</h3><p>Split节点在数据可视化方面具有独特价值。通过将多维数据分离为单维分量，可实现各类直观的数据监控效果。</p><ul><li>通道值实时监控：在开发过程中，使用Split节点分离颜色或向量的各通道，连接至自发光输出，实时观察各通道数值变化</li><li>调试信息显示：通过分离重要的中间计算结果，在屏幕特定区域显示数值信息，辅助着色器调试</li><li>性能分析辅助：将复杂计算过程分解为多个步骤，使用Split节点监控每步输出值，进行性能瓶颈分析</li></ul><p>在复杂着色器开发中，Split节点可作为调试工具使用。通过将关键中间变量分离显示，开发者可快速定位问题所在。</p><h2>使用技巧与注意事项</h2><h3>维度匹配策略</h3><p>使用Split节点时，正确的维度匹配策略至关重要。用户需根据输入向量的实际维度理解输出值的含义，避免逻辑错误。</p><ul><li>Vector2输入处理：仅R和G通道包含有效数据，B和A通道输出为0，适用于处理二维坐标或简单参数对</li><li>Vector3输入处理：R、G、B三通道包含有效数据，A通道输出为0，适用于处理三维坐标或颜色值（无透明度）</li><li>Vector4输入处理：所有四通道均含有效数据，适用于处理完整颜色信息或四维数据</li></ul><p>维度匹配不仅影响数据正确性，还关系到着色器性能表现。错误地使用高维输入处理低维数据可能导致不必要的计算开销。</p><h3>与其他节点配合技巧</h3><p>Split节点通常需与其他节点配合使用，以发挥最大效用。</p><ul><li>与组合节点（Combine Node）配合：Split与Combine节点构成ShaderGraph中的数据拆分组装流水线，可灵活重组向量数据</li><li>与数学节点配合：将分离后的通道值连接至不同数学节点，实现基于通道的差异化处理</li><li>与条件节点配合：根据分离后的单个通道值进行条件判断，创建基于阈值的效果切换</li><li>与时间节点配合：对特定通道值进行时间驱动的动画处理，创造动态视觉效果</li></ul><p>典型配合使用场景之一是颜色校正系统。通过Split节点分离颜色值，对各通道应用不同的伽马校正曲线，再使用Combine节点重新组合，实现精细颜色控制。</p><h3>性能优化建议</h3><p>尽管Split节点本身性能开销较小，但在复杂着色器中仍需注意优化使用。</p><ul><li>避免不必要的拆分：仅拆分实际需使用的通道，减少冗余操作</li><li>合理使用通道剪枝：Shader编译器自动剪枝未使用的输出通道，但显式断开不需要的连接可使节点图更清晰</li><li>批量处理策略：当需对多个向量进行相同通道拆分时，考虑使用Swizzle节点或其他替代方案</li></ul><p>性能优化的关键在于理解GPU的并行计算特性。Split节点的操作在GPU上通常以向量化方式执行，合理设计可充分利用该特性。</p><h2>高级应用与特殊技巧</h2><h3>多维度数据流处理</h3><p>在复杂着色器设计中，Split节点可用于处理多维度数据流。通过创建基于Split节点的数据处理管道，可实现复杂的特效组合。</p><ul><li>并行通道处理：将分离后的不同通道连接至各自独立的处理分支，最后合并输出，充分利用GPU并行计算能力</li><li>数据重映射：通过Split节点分离原始数据，经数学变换后重新组合，实现数据的非线性重映射效果</li><li>条件通道操作：基于特定条件选择性地修改某些通道值，保持其他通道不变，实现精确效果控制</li></ul><p>高级应用实例之一是基于通道的材质混合系统。通过Split节点分离不同材质的参数，根据遮罩通道值进行加权混合，创造自然的材质过渡效果。</p><h3>动态效果创建</h3><p>Split节点在创建动态视觉效果方面具有独特优势。通过将时间因素引入通道处理，可创造丰富的动画效果。</p><ul><li>通道独立动画：为分离后的不同通道设置不同动画频率与幅度，创造复杂的动态纹理效果</li><li>交互响应效果：根据玩家输入或游戏状态，动态调整特定通道值，实现实时交互的视觉反馈</li><li>环境适应效果：根据场景光照条件或其他环境因素，自动调整材质的不同属性通道，增强视觉真实感</li></ul><p>动态效果创建的关键在于理解时间与通道值的数学关系。通过巧妙的函数设计，可实现各类复杂动画模式。</p><h2>常见问题与解决方案</h2><h3>数据类型不匹配问题</h3><p>使用Split节点时常遇到数据类型不匹配问题，主要表现为输入向量维度与预期不符。解决方案包括：利用Split节点的动态类型特性自动处理不同维度输入；在需要时使用适当的转换节点确保数据维度正确；节点连接完成后，通过预览功能验证各通道输出值是否符合预期。</p><p>具体而言，当遇到Vector2输入但需四个有效通道时，应先使用转换节点将Vector2转为Vector4，再使用Split节点分离。</p><h3>性能瓶颈排查</h3><p>当着色器出现性能问题时，Split节点的使用方式可能是影响因素之一。需进行连接优化，检查并移除未使用的输出端口连接，减少不必要计算；简化节点图，避免过度复杂的拆分-处理-重组链条，寻找更简洁的等效实现；当多个部分需要同一通道值时，考虑使用分支节点而非多次拆分。</p><p>性能分析工具的使用同样重要。Unity提供的Frame Debugger等工具可帮助开发者识别性能热点。</p><h3>视觉效果调试技巧</h3><p>调试基于Split节点的视觉效果时，可采用分层调试策略。包括：通过将单个通道直接连接至主颜色输出，单独调试各通道效果；使用Split节点分离中间计算结果，在编辑器中观察数值变化；从简单的拆分操作开始，逐步添加复杂处理逻辑，确保每一步正确无误。</p><p>调试过程中，建议使用明显的测试值验证各通道功能。例如，将R通道设为1.0，其他通道设为0，观察输出结果是否符合预期。</p><hr/><blockquote><a href="https://link.segmentfault.com/?enc=Fcww4MSR9pKTYeKgLmcldg%3D%3D.a8OOs5u9Z%2FBnca3lT6Px6Ri8xmDgs7MrEQWjUq3ORtDnMrNA5Vuj4GcLJvFSFEkWpP%2FWOWfadHORWFCf%2FSFgSxzTw%2BAqYtrp5MsdSCPP4fz8ltS3hVTIAeybhgu5HzubNsKzSfohcMOEys9Rf62IuaG2hOlayAUNLFazobbL%2Blr4LQWPl0eroVnjuD0MUFn0kIaCTr5saIcehfQPz2bfyVVYzCnyyu%2BXBUxIhCJHeDc%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong><br/>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</blockquote>]]></description></item><item>    <title><![CDATA[FFmpeg开发笔记（九十八）基于FFmpeg的跨平台图形用户界面LosslessCut aqi00]]></title>    <link>https://segmentfault.com/a/1190000047533699</link>    <guid>https://segmentfault.com/a/1190000047533699</guid>    <pubDate>2026-01-11 12:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​LosslessCut是一款跨平台FFmpeg图形用户界面，用于对视频、音频、字幕和其他相关媒体文件进行极速且无损的操作。虽然《FFmpeg开发实战：从零基础到短视频上线》一书详细介绍了如何通过ffmpeg在命令行剪辑音视频，但是命令行方式不够直观，用户更习惯在图形界面上操作。于是LosslessCut抓住用户痛点，给FFmpeg封装了一层操作界面，从而方便用户利用鼠标剪辑音视频。</p><p>LosslessCut的主要功能是对视频和音频文件进行无损剪辑，通过裁剪摄像机、GoPro、无人机等设备拍摄的大型视频文件来节省空间。LosslessCut让用户能够快速从视频中提取精彩部分，同时丢弃大量数据，而无需重新编码造成质量损失。由于LosslessCut几乎直接复制数据，并且由强大的FFmpeg完成所有繁重工作，因此一切剪辑过程都非常快速。  <br/>LosslessCut的源码托管地址为 <a href="https://link.segmentfault.com/?enc=72Tqy0bofjKx1kNiI9EQKw%3D%3D.LRG%2BzbKTn42t5yl77oASFs2TGt%2FLv4eGtXiHGkWoL3mjRs2WUdji4ixn%2Fn1oanP2" rel="nofollow" target="_blank">https://github.com/mifi/lossless-cut</a> （星星数35.5k），国内的镜像地址为 <a href="https://link.segmentfault.com/?enc=jciuNCbbPNPo%2Bj1fDZliSw%3D%3D.oK9Q6L3gKJnVSJfpakbKOQuINnvFAJs8JiJTyT%2Fd%2F1Vq8iiPvLAXlduSXADgHNMR" rel="nofollow" target="_blank">https://gitcode.com/gh_mirrors/lo/lossless-cut</a> ，最新版本是2025年12月发布的v3.67.2，可见该框架的源码更新十分及时，该版本的源码下载链接为 <a href="https://link.segmentfault.com/?enc=iobrpcfBNVyxgkkld54nwQ%3D%3D.5OCyU7MghN44x5EDG15f4Ppu%2BCT%2F1T45kBJyi2HKO6c8EP7Z63BpY4M8l8%2BKXRk8d02UXPpG33jzq7zY2cYs9d%2B9MP0%2FDz142FMv6i1OH%2BY%3D" rel="nofollow" target="_blank">https://github.com/mifi/lossless-cut/archive/refs/tags/v3.67.2.tar.gz</a> 。  <br/>LosslessCut提供了两种运行方式，一种是通过源码运行，另一种是提供编译好的安装包运行，比如Windows系统已编译的免安装压缩包下载链接为 <a href="https://link.segmentfault.com/?enc=B11vFxRnaPjUE2SxKCsiEw%3D%3D.g6CBBC0jr5CZqyPZr5AXq6fdD0H9CB3Qtz7Hu20h4QrRbcqvr4nsRTEuMR8n1GAiO1LrxgHZ5Mb0XDtNTgCnf9NiRrbY235CxSbBmVvVIu4brJPr49RQWa7mJtv2tcdB" rel="nofollow" target="_blank">https://github.com/mifi/lossless-cut/releases/download/v3.67.1/LosslessCut-win-x64.7z</a> ，下载后解压7z文件即可得到LosslessCut的可执行程序。  <br/>以源码方式运行LosslessCut的话，需要事先安装下列三个软件：  <br/>1、安装 VS Code 以便加载LosslessCut源码工程， VS Code 的官网地址为  <a href="https://link.segmentfault.com/?enc=0KIk95UUmFgdzUFNPhPdjw%3D%3D.uw%2BRbCXdCAhnyNGv%2Fm41oOkVC2vHqrqDdomV02ezkaw%3D" rel="nofollow" target="_blank">https://code.visualstudio.com/</a>   <br/>2、安装版本号大于等于16.x的 Node.js ，因为LosslessCut 依赖 Node.js 构建。 Node.js 的官网地址为 <a href="https://link.segmentfault.com/?enc=WKbCzT0Q5mFOKhgEgQA%2FnA%3D%3D.v9vxNOW1CqR7KhKpPPaRPg4nRc8w8abkjoifSKVAl2w%3D" rel="nofollow" target="_blank">https://nodejs.org/</a>  <br/>3、安装 Git 以便克隆源码， Git 的官网地址为 <a href="https://link.segmentfault.com/?enc=3eNgueWpIp2pyyGYPzA7sg%3D%3D.kRF79bvo5vXtYWm5d%2BrLXH5bGYvxLhehC9S0gL52cns%3D" rel="nofollow" target="_blank">https://git-scm.com/</a>  <br/>上述三个软件都安装完毕，运行 VS Code ，依次选择菜单：File→Open Folder，在弹出的文件对话框中选择解压后的LosslessCut源码目录。接着依次选择菜单：Terminal→New Terminal，自动在 VS Code 界面上打开终端的命令行窗口。  <br/>在命令行窗口运行下面命令，表示安装yarn工具：</p><pre><code>npm install -g yarn</code></pre><p>运行下面命令检查yarn是否安装成功，正常会返回yarn的版本号比如4.11.0。</p><pre><code>yarn -v</code></pre><p>运行下面命令安装LosslessCut依赖的第三方库：</p><pre><code>yarn install</code></pre><p>确保第三方库都成功安装后，再运行下面命令启动LosslessCut：</p><pre><code>yarn start</code></pre><p>稍等片刻会弹出LosslessCut的图形界面如下图所示：</p><p><img width="596" height="692" referrerpolicy="no-referrer" src="/img/bVdnuS4" alt="" title=""/></p><p>可见LosslessCut的图形界面十分简洁，既能通过菜单选择来打开视频文件，也能通过拖动鼠标把视频添加进来。  <br/>把视频文件拉到LosslessCut的图形界面后，就切换到视频剪辑界面如下图所示：</p><p><img width="723" height="462" referrerpolicy="no-referrer" src="/img/bVdcmd6" alt="" title="" loading="lazy"/></p><p>在视频剪辑界面可以执行裁剪、缩放、拼接等常见的加工操作，剪辑完成后单击界面右下角的Export按钮，即可导出并保存处理好的视频文件。</p><p>更多详细的FFmpeg开发知识参见<a href="https://link.segmentfault.com/?enc=nFGrZ29fGVJ0RYG79P%2FGnw%3D%3D.zlxNvrmXD7NRKM1hCdj%2BqpR9d70Cd3tB8OurHDbOkQ0dAugB7t12uMT5NuW6Mn9E" rel="nofollow" title="《FFmpeg开发实战：从零基础到短视频上线》" target="_blank">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</p>]]></description></item><item>    <title><![CDATA[生产管理系统怎么选？这篇实测对比给你答案（附八款系统详评） SaaS圈老马 ]]></title>    <link>https://segmentfault.com/a/1190000047535800</link>    <guid>https://segmentfault.com/a/1190000047535800</guid>    <pubDate>2026-01-11 11:02:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>老板们经常头疼一件事：厂子里生产计划总赶不上变化，车间进度一问三不知，库存不是积压就是短缺，报表全靠人工熬夜拼凑……这时候，大家都明白，得上套靠谱的生产管理系统了。</p><p>但市面上系统那么多，从国际巨头到国内新锐，从动辄百万的重型ERP到轻量化的SaaS工具，到底该怎么选？ <strong>选贵了怕浪费，选便宜了怕没用，选复杂了用不起来，选简单了又怕不够用。</strong></p><p>今天，我就结合多方资料和实际了解，为大家深度测评八款主流的生产管理系统。我会尽量用大白话，说清楚它们各自的特点、适合谁用、以及你可能需要留意的点，希望能帮你拨开迷雾，找到最适合自己的那一个。</p><p><strong>测评标准说明</strong></p><p>在具体介绍前，先聊聊我的测评维度。一个好的生产管理系统，不能只看名气或价格，我主要看这几点：</p><p><strong>1、核心能力是否扎实</strong>：生产计划（MPS/MRP）排得准不准？车间报工、进度跟踪及不及时？质量追溯能不能实现？这是基本功。</p><p><strong>2、灵活性与适配度</strong>：你的业务特殊，流程经常变，系统能不能跟着变？还是你必须削足适履去适应软件？</p><p><strong>3、投入与性价比</strong>：不只是首次购买价格，还包括后续的定制、升级、维护成本和隐形的时间成本。</p><p><strong>4、实施与服务</strong>：系统是“死”的，服务是“活”的。厂商能不能听懂你的业务，帮你理顺流程，而不仅仅是卖软件？</p><p><strong>5、扩展与集成</strong>：未来要和财务、供应链、CRM打通怎么办？系统是不是一个“信息孤岛”？</p><p>基于以上标准，我们来看这八款产品。</p><p><strong>一、支道：以无代码为核心的高灵活度业务管理平台</strong></p><p><a href="https://link.segmentfault.com/?enc=n6L57mZLhmdBONNtGx%2B9vA%3D%3D.Ss7qzbUVbwjLDLbhZaAAuG4h0HDYIJXOJy0YhCN5YqA%3D" rel="nofollow" target="_blank">https://www.zdsztech.com</a></p><p>首先要介绍的是<strong>支道</strong>，它在需要深度定制和快速响应业务变化的成长型企业中，口碑相当不错。</p><p><strong>核心特点：</strong></p><p><strong>1、“无代码”</strong>：它不仅仅是一个固定的MES或ERP模块，而是一个<strong>无代码应用开发平台</strong>。这意味着，可以通过可视化的“拖拉拽”方式，<strong>自主搭建或调整</strong>生产管理所需的表单、流程、报表。</p><p><strong>2、生产场景覆盖深入</strong>：基于其强大的无代码引擎，支道能构建出非常<strong>贴合实际的</strong>生产管理应用。其方案支持主生产计划（MPS）和物料需求计划（MRP），能处理生产工单、委外工单、扫码报工、工序管理、在制品跟踪、质量追溯（支持从成品追溯到原料批次）等核心场景。</p><p><strong>3、强项在于“连接”与“灵活”</strong>：它特别<strong>擅长解决因业务快速发展或流程独特导致的系统不适应问题</strong>。比如，你可以轻松将生产数据与自定义的绩效工资计算关联，或者为特定产品线配置独特的质量检验流程。</p><p><strong>4、提供原厂深度服务</strong>：支道采用“原厂交付”模式，由懂生产管理的<strong>顾问直接驻场</strong>调研、梳理流程并搭建系统。</p><p><strong>适合哪些企业？</strong></p><p>非常适合<strong>处于快速发展期、业务流程尚未完全固化、或具有独特生产模式的中小型制造企业</strong>。当标准软件无法满足你的个性化管理需求，而你又无法承担高昂且周期长的定制开发时，支道这类平台提供了一个折中且高效的解决方案。<br/><img width="723" height="301" referrerpolicy="no-referrer" src="/img/bVdnCot" alt="" title=""/></p><p><strong>二、用友U8+/U9 Cloud</strong></p><p>用友是中国管理软件的标志性企业，其面向制造业的U8+（本地部署）和U9 Cloud（云原生）产品线非常成熟。</p><p><strong>核心特点：</strong></p><p><strong>1、功能全面且体系化</strong>：覆盖从设计（PLM）、计划、生产（MES）、供应链到财务的全链路，强调<strong>业财一体化</strong>。其生产管理模块（车间管理、生产订单）经过大量客户验证，在计划排程、物料管理方面有深厚的积累。</p><p><strong>2、行业方案丰富</strong>：在电子、装备制造、汽配、食品等多个细分领域有预置的行业解决方案，能较快地匹配行业通用需求。</p><p><strong>3、生态强大</strong>：拥有庞大的用户群、合作伙伴和实施服务体系，遇到问题相对容易找到支持资源。</p><p><strong>适合哪些企业？</strong></p><p>适合那些<strong>业务流程相对规范、注重财务业务一体化、且需要一套完整ERP体系的中型到大型制造企业</strong>。如果你的企业已经发展到一定规模，需要严谨的内控和全面的信息化覆盖，用友是一个稳妥的选择。</p><p><strong>可能需要考虑的方面：</strong></p><p>传统套件式的软件，个性化调整（二次开发）的成本较高、周期较长。对于小微初创企业或业务模式变化极快的企业，可能会感觉系统有些“重”。<br/><img width="723" height="314" referrerpolicy="no-referrer" src="/img/bVdnCov" alt="" title="" loading="lazy"/></p><p><strong>三、金蝶云·星空：成长型企业ERP市场的有力竞争者</strong></p><p>金蝶是另一家国内巨头，其面向中型企业的“云·星空”产品在灵活性上做了不少改进。</p><p><strong>核心特点：</strong></p><p><strong>1、云原生，部署更灵活</strong>：天生基于云架构，在移动应用、多组织协同、快速迭代方面有优势。订阅模式降低了初期投入门槛。</p><p><strong>2、制造模块与时俱进</strong>：其生产管理模块支持多工厂协同计划、车间现场管理、以及简单的MES可视化看板等功能，努力满足现代制造的需求。</p><p><strong>3、性价比相对突出</strong>：在同等功能覆盖范围内，其价格策略对成长型企业往往更具吸引力。</p><p><strong>适合哪些企业？</strong></p><p>适合那些<strong>正在从初创向中型发展、上云意愿较强、且希望以相对可控的成本实现核心业务（包括生产）规范化的制造业企业</strong>。</p><p><strong>可能需要考虑的方面：</strong></p><p>在超大型集团或流程极度复杂的重工业场景下，其深度可能仍需验证。部分复杂生产场景的精细化程度可能不如更专业的系统。<br/><img width="723" height="312" referrerpolicy="no-referrer" src="/img/bVdnCow" alt="" title="" loading="lazy"/></p><p><strong>四、鼎捷软件：深耕制造业的“行家”</strong></p><p>鼎捷（原神州数码ERP）在制造业，尤其是离散制造业（如电子、机械、汽车零部件）的口碑非常专业。</p><p><strong>核心特点：</strong></p><p><strong>1、制造基因深厚</strong>：其产品（如TIPTOP、易助）从设计之初就紧密围绕制造核心流程，在<strong>生产计划排程（APS）、车间执行、物料管控</strong>等方面的功能设计非常细致和务实。</p><p><strong>2、注重车间现场</strong>：相比一些以财务为核心的ERP，鼎捷更贴近车间地气，对工单管理、报工、在制品管理等环节的支持更到位。</p><p><strong>3、行业解决方案专业</strong>：在特定的细分制造领域，其方案往往能直击痛点，比如针对电子行业强调的齐套分析和物料追溯。</p><p><strong>适合哪些企业？</strong></p><p>特别适合<strong>离散制造型企业，尤其是那些对车间现场管理精细化要求高、生产模式复杂（如多品种小批量、按订单设计ETO）的企业</strong>。如果你受困于生产计划不准、现场混乱，可以重点关注。</p><p><strong>可能需要考虑的方面：</strong></p><p>品牌知名度在泛IT领域可能略低于用友金蝶，但在制造业圈内是公认的专业选手。系统的界面和用户体验在早期版本中可能不如新兴的云产品，近年已有改善。<br/><img width="723" height="281" referrerpolicy="no-referrer" src="/img/bVdnCox" alt="" title="" loading="lazy"/></p><p><strong>五、SAP Business One / S/4HANA：全球顶级标准的代表</strong></p><p>SAP是德国工业4.0的核心软件供应商，代表着全球制造业管理的最高标准之一。</p><p><strong>核心特点：</strong></p><p><strong>1、管理理念先进</strong>：蕴含了全球顶级企业的管理实践，其生产模块（PP）逻辑严谨，集成度极高，是<strong>复杂制造和全球化运营</strong>的利器。</p><p><strong>2、强大的可扩展性</strong>：从适合中小企业的Business One到支撑巨头的S/4HANA，产品线完整。一旦业务成长，系统可以无缝扩展。</p><p><strong>3、生态与集成全球领先</strong>：与各类自动化设备、物联网平台、高级分析工具的集成经验丰富。</p><p><strong>适合哪些企业？</strong></p><p><strong>有出口业务、对标国际客户标准、或自身管理非常规范且追求国际化的大型制造企业</strong>。也适合那些志存高远，希望一开始就搭建世界级管理框架的成长型企业。</p><p><strong>可能需要考虑的方面：</strong></p><p><strong>价格昂贵</strong>，不仅是软件授权费用，实施、咨询和长期维护的成本都非常高。对企业的流程标准化和数据规范性要求极为苛刻，实施周期长，变革挑战大。<br/><img width="723" height="282" referrerpolicy="no-referrer" src="/img/bVdnCoy" alt="" title="" loading="lazy"/></p><p><strong>六、Oracle NetSuite：云ERP的全球化选择</strong></p><p>甲骨文旗下的NetSuite是全球领先的云ERP，近年来在国内市场发力。</p><p><strong>核心特点：</strong></p><p><strong>1、真正的云端一体化</strong>：从财务、CRM到生产、供应链，所有模块在同一云平台上，数据实时统一，支持全球多站点、多币种、多语言运营。</p><p><strong>2、适合业务全球化</strong>：对于在海外有分公司、仓库或销售点的制造企业，其全球业务管理能力是显著优势。</p><p><strong>3、灵活可配置</strong>：相对于传统本地部署软件，云的架构使其能通过配置（非代码）适应较多业务变化。</p><p><strong>适合哪些企业？</strong></p><p><strong>业务模式已涉及海外、或计划出海、且希望采用全球统一云平台来管理业务的中型制造企业</strong>。</p><p><strong>可能需要考虑的方面：</strong></p><p>在国内制造业的本地化实践深度，尤其是在与国内供应链、税务、特殊行业规范的对接上，可能仍需加强与本土厂商的对比。同样属于高价位产品。<br/><img width="723" height="297" referrerpolicy="no-referrer" src="/img/bVdnCoz" alt="" title="" loading="lazy"/><br/><strong>七、浪潮云ERP</strong></p><p>浪潮在政务和企业市场有深厚基础，其云ERP产品在国资国企、大型集团企业中应用广泛。</p><p><strong>核心特点：</strong></p><p><strong>1、符合国内监管与集团管控要求</strong>：在财务合规、集团报表合并、内控管理等方面设计周到，深受需要满足严格国资监管要求的企业青睐。</p><p><strong>2、混合云支持佳</strong>：支持公有云、私有云、混合云部署，能满足对数据主权和安全有特殊要求的大型制造集团。</p><p><strong>3、集成供应链能力强</strong>：在涉及大宗物料、集中采购、多工厂协同的计划与调度方面有特色。</p><p><strong>适合哪些企业？</strong></p><p><strong>大型集团性制造企业、或对符合中国特色的集团管控和合规性要求极高的企业。</strong></p><p><strong>可能需要考虑的方面：</strong></p><p>在面向市场端的创新业务敏捷性和用户体验方面，可能更侧重于内部管理的稳健性。<br/><img width="723" height="270" referrerpolicy="no-referrer" src="/img/bVdnCoA" alt="" title="" loading="lazy"/></p><p><strong>八、简道云：面向轻量级应用的全民开发平台</strong></p><p>它是帆软软件旗下的一款无代码/低代码应用搭建平台，与支道类似但定位和路径有所不同。</p><p><strong>核心特点：</strong></p><p><strong>1、极致轻量与易用</strong>：上手门槛非常低，普通业务人员经过短期培训就能自己搭建数据收集表单和简单流程，非常适合解决部门级、轻量级的生产数据收集问题（如设备点检、质量快报、日报等）。</p><p><strong>2、与数据分析工具结合好</strong>：背靠帆软强大的BI报表工具，意味着收集上来的数据可以很方便地做出美观实用的分析看板。</p><p><strong>3、成本低，部署快</strong>：对于简单的管理需求，可以极低的成本和极快的速度上线。</p><p><strong>适合哪些企业？</strong></p><p>适合作为<strong>大型系统（如ERP）的补充</strong>，用于填补边缘业务场景的数字化空白；或者用于<strong>小微团队、初创企业</strong>快速搭建最核心的生产跟踪管理应用。</p><p><strong>可能需要考虑的方面：</strong></p><p>在构建复杂、连贯、逻辑严密的全流程生产管理系统（如深度MES）方面，其能力边界相对有限。更像是一个功能强大的“超级表单”和“流程触发器”，用于支撑核心生产运营时会显得单薄。<br/><img width="723" height="317" referrerpolicy="no-referrer" src="/img/bVdnCoB" alt="" title="" loading="lazy"/></p><p><strong>总结与选择建议</strong></p><p>如果你<strong>业务独特、变化快、厌恶僵化</strong>，且希望系统能伴随成长持续迭代，不愿意在未来被高昂的二次开发绑架，那么应该重点考察以 <strong>支道 </strong>为代表的<strong>无代码业务平台</strong>。它用灵活性换取了长期适配性。</p><p>不过无论最终选择哪个，一定要记得：<strong>生产管理系统的核心是“管理”，而不是“系统”</strong>。成功的核心不在于软件本身多么强大，而在于它能否与你企业的业务流程、人员能力和管理变革深度融合。</p><p>因此，在选型前，先梳理清楚自己的核心痛点和关键需求；在选型时，高度重视厂商的<strong>行业理解能力和实施服务质量</strong>。</p><p>希望这篇深度测评，能为你选择生产管理系统提供一份有价值的参考。</p>]]></description></item><item>    <title><![CDATA[告别黑盒！手写Windows版简易NodeMON，学习文件监听代码修改与进程服务重启知识 水冗水孚 ]]></title>    <link>https://segmentfault.com/a/1190000047535847</link>    <guid>https://segmentfault.com/a/1190000047535847</guid>    <pubDate>2026-01-11 11:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <hr/><h2>为什么要手写 NodeMON？</h2><p>在开发 Node.js 应用时，我们经常用 <a href="https://link.segmentfault.com/?enc=2gcsdAz77kWAePUbpGuReg%3D%3D.84pH4DXlaelCinb1rLqGHf7oWjnEk6bd0ZDOq8J%2FMaJoWT6F82SD%2FAvzv0MemdaR" rel="nofollow" target="_blank"><code>nodemon</code></a> 来自动重启服务。但你有没有想过：</p><ul><li>🤔 它是如何监听文件变化的？</li><li>🤔 它是如何优雅地杀掉进程并重启新进程的？</li></ul><p>今天我们就从零开始，手写一个 <strong>Windows 专属的简易 NodeMON 工具</strong>，彻底搞懂背后的原理！</p><h3>node index.js的执行过程</h3><p>比如我使用express编写一个简单的服务代码</p><pre><code class="js">const express = require('express'); 
const app = express();

app.get('/', (req, res) =&gt; { res.send('Hello World!'); });

const server = app.listen(6666, () =&gt; { 
    console.log('Express 服务已启动，进程 ID：', process.pid); // 打印当前进程ID 
    console.log('服务监听 http://localhost:6666'); 
});</code></pre><p>当我们执行 <code>node index.js</code> 时：</p><ul><li>操作系统会在环境变量的目录里面逐个查找，并找到node的可执行程序，比如位置在：<code>C:\Program Files\nodejs</code></li><li><img width="669" height="462" referrerpolicy="no-referrer" src="/img/bVdnCpl" alt="" title=""/></li><li>当操作系统找到这个可执行程序后，会安排一个进程去加载并执行这个node.exe程序，再把index.js文件作为参数交给node.exe去解析并运行</li><li>在这个新进程的内部，Nodejs会去执行index.js的代码，最终会启动一个Express服务，这个服务使用的是6666端口</li><li>只要这个进程不终止（比如你按 <code>Ctrl+C</code>、杀死进程、服务器重启），6666 端口就会一直被占用，服务就一直可用。</li></ul><h3>通俗易懂地类比理解</h3><p>操作系统是 “工厂小老板”，进程是驾驶机器的一个个的员工，而node.exe 则是 “一台机器”，index.js 是 “机器要处理的任务单”</p><ul><li><strong>操作系统 = 工厂小老板</strong>负责统筹全局，决定要不要招新员工（创建进程）、给员工分配机器（运行可执行程序）、下发任务单（传递参数），还能随时监督员工工作状态（查看进程 PID、占用资源），或者让员工下班（终止进程）。</li><li><strong>进程 = 驾驶机器的员工</strong>是老板（系统）专门招来的 “专人”，有自己的唯一工号（PID），他的核心工作就是操作手里的机器，全程只围绕这个机器和任务转，不会同时干别的活。</li><li><strong>node.exe = 员工驾驶的机器</strong>是员工的 “工具”，本身有固定的功能（JavaScript 解释执行能力），没有员工（进程）操作的话，它就是一台闲置的机器，啥也干不了。</li><li><strong>index.js = 机器要处理的任务单</strong>上面写着具体的工作内容（比如 “启动 Express 服务、监听 3000 端口”），员工（进程）操作机器（node.exe）时，就照着任务单的要求一步步执行。</li></ul><blockquote><p>至于线程，我们知道进程中可以创建多个线程（可以理解为一个操作机器的员工，可以长出多只手，两只手干活总会比一只手干活快）</p><p>员工常常用一只手干活（进程中的主线程干活）</p></blockquote><p><strong>说到这里，就要额外提一下Process这个变量了</strong></p><p>process就相当于node.exe这个机器上面的控制显示屏，记录了一些信息，提供给外部方便使用</p><table><thead><tr><th>控制显示屏（process）的功能</th><th>对应工厂场景</th><th>代码示例</th></tr></thead><tbody><tr><td>显示 “员工工号（PID）”</td><td>屏幕上显示当前操作机器的员工编号</td><td><code>process.pid</code> → 输出 39900</td></tr><tr><td>显示 “机器运行参数”</td><td>屏幕显示机器接收到的任务单（index.js）、启动指令</td><td><code>process.argv</code> → 输出 <code>['node', 'index.js']</code></td></tr><tr><td>显示 “机器资源占用”</td><td>屏幕显示机器当前用了多少内存、CPU</td><td><code>process.memoryUsage()</code> → 输出内存占用数据</td></tr><tr><td>提供 “关机按钮”</td><td>屏幕上的 “停止运行” 按钮，按了员工就下班</td><td><code>process.exit()</code> → 终止当前进程</td></tr><tr><td>显示 “工厂环境”</td><td>屏幕显示老板（系统）给的环境变量（比如 PATH）</td><td><code>process.env</code> → 输出系统环境变量</td></tr></tbody></table><ul><li>比如，我可以打印进程id就是</li><li>console.log('进程 ID：', process.pid) // 得到39900这个值 是40188当然每次一般都不一样</li></ul><p><em>cmd命令：</em></p><p><code>tasklist | findstr 39900</code> 查看进程39900在使用哪一台机器——使用node.exe这个机器</p><pre><code class="bash">C:\Users\lss13&gt;tasklist | findstr 39900
node.exe                     39900 Console                    1     25,176 K
</code></pre><p><code>netstat -ano | findstr :6666</code> 查看6666端口，被那个进程使用——被39900进程使用</p><pre><code class="bash">C:\Users\lss13&gt;netstat -ano | findstr :6666
  TCP    0.0.0.0:6666           0.0.0.0:0              LISTENING       39900
  TCP    [::]:6666              [::]:0                 LISTENING       39900</code></pre><hr/><h2>一、原理讲解</h2><p>有了前置的知识后，我们来梳理一下手写启动监控工具的思路</p><h3>核心流程</h3><pre><code>启动监控工具
    ↓
监听文件变化（chokidar）
    ↓
检测到修改 → 计算文件 Hash
    ↓
Hash 变了？
    ├─ 是 → 杀掉旧进程（taskkill）→ 等待端口释放 → 启动新进程
    └─ 否 → 忽略（避免无意义重启）
</code></pre><h3>关键技术点</h3><p>chokidar：<a href="https://link.segmentfault.com/?enc=cY%2BXdu8zJETbxECfgsu3SQ%3D%3D.rozcdD0dLJ4PURlLUguU3ppncL5g05JJcZOtFiF67vx3ulCfv2fx6JAwn5DtHJBQ" rel="nofollow" target="_blank">https://www.npmjs.com/package/chokidar/v/4.0.1</a></p><table><thead><tr><th>技术</th><th>作用</th><th>Windows 特殊处理</th></tr></thead><tbody><tr><td><strong>chokidar</strong></td><td>监听文件变化</td><td>可选轮询模式（更稳定）</td></tr><tr><td><strong>spawn</strong></td><td>启动/管理子进程</td><td>需要处理进程树</td></tr><tr><td><strong>taskkill</strong></td><td>杀死进程</td><td>Windows 专属命令</td></tr><tr><td><strong>crypto</strong></td><td>计算文件 Hash</td><td>精确判断内容是否变化</td></tr></tbody></table><hr/><h2>二、代码实现</h2><h3>项目结构</h3><pre><code>myNodeMon/
├── package.json    # 项目配置
├── nmon.js         # 监控工具（核心）
└── index.js        # 业务代码（HTTP 服务器）
</code></pre><h3>第一步：初始化项目</h3><pre><code class="bash"># 创建项目目录
mkdir myNodeMon
cd myNodeMon

# 初始化 package.json
npm init -y

# 安装依赖
npm install chokidar</code></pre><h3>第二步：配置 package.json</h3><pre><code class="json">{
  "name": "mynodemon",
  "version": "1.0.0",
  "type": "module",
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "chokidar": "^5.0.0"
  }
}</code></pre><p><strong>关键配置：</strong></p><ul><li><code>"type": "module"</code>：启用 ES Module 语法</li></ul><hr/><h3>第三步：编写业务代码（index.js）</h3><p>这是我们要监控的目标文件index.js，一个简单的 HTTP 服务器：</p><pre><code class="javascript">import http from 'http';

// 创建http服务器
const server = http.createServer((_req, res) =&gt; {
    res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
    res.end(`
    当前时间：${new Date().toLocaleTimeString()}
  `);
});

console.log(666)

// 启动服务器
server.listen(6666, () =&gt; {
    console.log(`Node.js 服务已启动：http://localhost:6666`);
});</code></pre><p><em>功能：</em></p><ul><li>监听 6666 端口</li><li>返回当前时间</li></ul><hr/><h3>第四步：编写监控工具（nmon.js）</h3><p>这是核心代码，我们逐块解析：</p><p><em>导入依赖</em></p><pre><code class="javascript">import chokidar from 'chokidar'; // 文件监听库
import { spawn } from 'child_process'; // 子进程管理
import path from 'path';
import crypto from 'crypto'; // Hash 计算
import fs from 'fs'; // 文件读取</code></pre><hr/><p><em>配置项</em></p><pre><code class="javascript">// ===================== 配置项 =====================
const TARGET_FILE = 'index.js'; // 要监控的文件
// =================================================

const entryPath = path.resolve(process.cwd(), TARGET_FILE); // 获取绝对路径</code></pre><ul><li><code>process.cwd()</code>：当前工作目录（运行命令的位置）</li><li><code>path.resolve()</code>：拼接成绝对路径，如 <code>C:\Users\xxx\myNodeMon\index.js</code></li></ul><hr/><p><em>Hash 计算</em></p><pre><code class="javascript">let lastHash = null; // 保存上次的 hash

function getFileHash(filePath) {
    const content = fs.readFileSync(filePath);
    return crypto.createHash('md5').update(content).digest('hex');
}</code></pre><p><em>为什么要用 Hash？</em></p><table><thead><tr><th>方案</th><th>问题</th></tr></thead><tbody><tr><td>只检测修改时间</td><td>Ctrl+S 不修改内容也会触发重启 ❌</td></tr><tr><td><strong>Hash 对比</strong></td><td>只有内容真正变化才重启 ✅</td></tr></tbody></table><blockquote>当我们在编辑器里面 Ctrl+S 的时候，尽管没有修改文件，但是操作系统依旧认为这个文件变化了，也会触发文件变化回调函数，即文件的时间会变化</blockquote><p><em>工作原理：</em></p><ol><li>读取文件内容</li><li>计算 MD5 哈希值（如 <code>a1b2c3d4...</code>）</li><li>对比上次的哈希值</li><li>不同才重启</li></ol><hr/><p><em>进程引用管理</em></p><pre><code class="javascript">let childProcess = null; // 保存进程实例

// 启动或重启 index.js
function startApp() {
    if (childProcess) {
        console.log('🔄 正在终止旧进程...');

        // Windows 下用 taskkill 强制杀死进程树
        const killProcess = spawn('taskkill', ['/F', '/T', '/PID', childProcess.pid]);

        killProcess.on('close', () =&gt; {
            childProcess = null; // 清空引用
            setTimeout(() =&gt; {
                launchNewProcess();
            }, 200); // 等待端口释放
        });
        return;
    }
    launchNewProcess();
}</code></pre><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>/F</code></td><td>强制终止</td></tr><tr><td><code>/T</code></td><td>终止进程树（包括子进程）</td></tr><tr><td><code>/PID</code></td><td>按进程 ID 杀死</td></tr></tbody></table><p><em>为什么要延迟 200ms？</em></p><pre><code>taskkill 完成 → 进程退出 → 操作系统释放端口 → 新进程启动
                              ↑
                        这里需要时间（约 50-150ms）
</code></pre><p>如果不等待，新进程会报错：<code>EADDRINUSE: address already in use</code></p><hr/><p><em>启动新进程</em></p><pre><code class="javascript">function launchNewProcess() {
    console.log('🚀 正在启动新进程...\n');

    // 相当于执行：node index.js
    childProcess = spawn('node', [entryPath], {
        stdio: 'inherit' // 让子进程的日志直接显示在控制台
    });

    childProcess.on('error', (err) =&gt; {
        console.error('❌ 启动失败：', err.message);
    });
}</code></pre><p><code>stdio: 'inherit'</code>：继承父进程的输入输出，让 <code>index.js</code> 的日志能显示出来</p><hr/><p><em>文件变化监听</em></p><pre><code class="javascript">// 创建文件监听器
const watcher = chokidar.watch(TARGET_FILE, {
    ignoreInitial: true  // 忽略初始化时的事件
});

watcher.on('change', () =&gt; {
    const currentHash = getFileHash(TARGET_FILE);
    
    if (currentHash !== lastHash) {
        console.log('📝 检测到内容真的变了');
        lastHash = currentHash;
        startApp();
    } else {
        console.log('⏭️ 内容没变，忽略');
    }
});

// 初始化时计算一次
lastHash = getFileHash(TARGET_FILE);</code></pre><p><em>流程</em></p><ol><li>监听 <code>index.js</code> 的 <code>change</code> 事件</li><li>计算当前文件的 Hash</li><li>对比上次的 Hash</li><li>不同才调用 <code>startApp()</code> 重启</li></ol><hr/><p><em>启动监控</em></p><pre><code class="javascript">console.log(`🚀 Windows 监控工具已启动`);
console.log(`🎯 监控目标：${TARGET_FILE}\n`);
startApp();</code></pre><hr/><p><em>优雅退出（Ctrl+C）</em></p><pre><code class="javascript">process.on('SIGINT', () =&gt; {
    if (childProcess) {
        console.log('\n🛑 正在清理子进程...');
        spawn('taskkill', ['/F', '/T', '/PID', childProcess.pid]);
        childProcess = null;
    }
    watcher.close();
    console.log('👋 监控工具已退出');
    process.exit(0);
});</code></pre><ul><li>按 Ctrl+C 时清理子进程</li><li>关闭文件监听器</li><li>避免端口残留占用</li></ul><hr/><h2>三、测试验证效果</h2><p>测试场景 0：启动服务并访问<br/>测试场景 1：修改文件内容<br/>测试场景 2：不修改内容，只保存<br/>测试场景 3：优雅退出</p><p>效果图</p><p><img width="723" height="694" referrerpolicy="no-referrer" src="/img/bVdnCpm" alt="" title="" loading="lazy"/></p><hr/><h2>四、踩坑</h2><h3>为什么 Windows 需要特殊处理？</h3><p><em>问题 1：文件监听不稳定</em></p><p>Linux/Mac：</p><ul><li>使用 <code>inotify</code> / <code>FSEvents</code>（内核级别）</li><li>高效、准确、实时</li></ul><p>Windows：</p><ul><li>使用 <code>ReadDirectoryChangesW</code>（基于目录扫描）</li><li>容易丢失事件或重复触发</li><li>容易丢失事件或重复触发</li><li>容易丢失事件或重复触发</li></ul><blockquote><strong>特别是快速Ctrl + S保存，可能会事件误触发...</strong></blockquote><p>解决方案可选：</p><pre><code class="javascript">// 可选：使用轮询模式（更稳定但耗资源）
const watcher = chokidar.watch(TARGET_FILE, {
    ignoreInitial: true,
    usePolling: true,     // 强制轮询
    interval: 500         // 每 500ms 检查一次
});</code></pre><hr/><p><em>问题 2：进程杀不干净</em></p><p>Linux/Mac：</p><pre><code class="bash">kill -9 &lt;PID&gt;  # 直接杀进程</code></pre><p>Windows：</p><pre><code class="bash">taskkill /F /T /PID &lt;PID&gt;  # 需要杀进程树</code></pre><p>为什么要加 <code>/T</code>？</p><pre><code>父进程（node nmon.js）
  └─ 子进程（node index.js）
       └─ 可能还有孙进程
</code></pre><p>不加 <code>/T</code> 只杀父进程，子进程会变成孤儿进程，继续占用端口。</p><hr/><h3>为什么要保存进程实例？</h3><pre><code class="javascript">let childProcess = null;</code></pre><p><strong>作用：</strong></p><ol><li>获取进程 PID（<code>childProcess.pid</code>）</li><li>在重启时杀掉旧进程</li><li>监听进程状态（退出、错误）</li></ol><p><strong>如果不保存：</strong></p><pre><code class="javascript">// ❌ 错误示范
spawn('node', ['index.js']); // 启动了，但没人记住它

// 想重启时
spawn('taskkill', ['/PID', ???]); // 不知道 PID，无法杀进程</code></pre><hr/><h2>五、完整代码</h2><h3>GitHub</h3><p>仓库地址：<a href="https://link.segmentfault.com/?enc=S35TaY45qGuO64nR%2FePEtw%3D%3D.1ao3XacFWnKmxrXojFh2t3Nicz1s16i8BltihhlGfwjZaeUL%2Fc7MakadpSKzRsmf" rel="nofollow" target="_blank">https://github.com/shuirongshuifu/mynodemon</a></p><h3>nmon.js</h3><pre><code class="javascript">import chokidar from 'chokidar'; // 监控包
import { spawn } from 'child_process'; // 派发生系统命令来创建和终止子进程，实现启动和重启
import path from 'path';
import crypto from 'crypto';
import fs from 'fs';

// ===================== 配置项 =====================
const TARGET_FILE = 'index.js'; // 要监控并自动重启的文件
// =================================================

const entryPath = path.resolve(process.cwd(), TARGET_FILE); // 路径

let childProcess = null; // 保存 index.js 的进程实例对象的引用，便于后续清空重置

let lastHash = null; // 保存上次的 hash

function getFileHash(filePath) {
    const content = fs.readFileSync(filePath);
    return crypto.createHash('md5').update(content).digest('hex');
}

// 启动或重启 index.js
function startApp() {
    // 当前有进程，就清除掉以后，再启动（重启功能）
    if (childProcess) {
        console.log('🔄 正在终止旧进程...');

        // Windows 下用 taskkill命令 强制杀死进程树 // 比如类似 taskkill /f /t /im nginx.exe
        const killProcess = spawn('taskkill', ['/F', '/T', '/PID', childProcess.pid]);

        killProcess.on('close', () =&gt; {
            childProcess = null; // 清空进程实例对象的引用
            setTimeout(() =&gt; { // 等200毫秒足够操作系统释放端口了
                launchNewProcess();
            }, 200);
        });
        return;
    }
    // 当前没有进程就直接启动即可
    launchNewProcess();
}

// 启动新进程
function launchNewProcess() {
    console.log('🚀 正在启动新进程...\n');

    // 相当于执行命令：node C:\Users\xxx\myNodeMon\index.js 简化就是 node index.js
    childProcess = spawn('node', [entryPath], {
        stdio: 'inherit' // 让子进程的输出日志，直接显示在当前控制台
    });

    // 比如文件不存在或者路径错误会报错，兜一下
    childProcess.on('error', (err) =&gt; {
        console.error('❌ 启动失败：', err.message);
    });
}

// 创建文件监听器——不使用轮询
const watcher = chokidar.watch(TARGET_FILE, {
    ignoreInitial: true  // 忽略初始化时的事件
});

// // 创建文件监听器——使用轮询
// const watcher = chokidar.watch(TARGET_FILE, {
//     ignoreInitial: true,  // 忽略初始化时的事件
//     usePolling: true,     // Windows下用轮询更加稳妥（毕竟其文件管理没有Linux做得好）
//     interval: 1000         // 每 100ms 检查一次文件变化
// });

watcher.on('change', () =&gt; {
    const currentHash = getFileHash(TARGET_FILE);
    
    if (currentHash !== lastHash) {
        console.log('📝 检测到内容真的变了');
        lastHash = currentHash;
        startApp();
    } else {
        console.log('⏭️ 内容没变，忽略');
    }
});

// 初始化时计算一次
lastHash = getFileHash(TARGET_FILE);

// 启动监控
console.log(`🚀 Windows 监控工具已启动`);
console.log(`🎯 监控目标：${TARGET_FILE}\n`);
startApp();

// Ctrl+C 退出时清理进程
process.on('SIGINT', () =&gt; {
    if (childProcess) {
        console.log('\n🛑 正在清理子进程...');
        spawn('taskkill', ['/F', '/T', '/PID', childProcess.pid]);
        childProcess = null;
    }
    watcher.close();
    console.log('👋 监控工具已退出');
    process.exit(0);
});</code></pre><hr/><h2>六、总结</h2><h3>学到了什么？</h3><ul><li>通俗易懂理解一些基础概念</li><li>chokidar 的使用</li><li>Windows 下文件系统还是差点意思（稳定性问题）</li><li><code>spawn()</code> 启动子进程</li><li><code>taskkill</code> 杀死进程树</li><li>通过文件hash精确判断文件内容是否变化</li><li>信号处理（<code>SIGINT</code>）</li></ul><hr/><h3>与 nodemon 的对比</h3><table><thead><tr><th>特性</th><th>我们的工具</th><th>nodemon</th></tr></thead><tbody><tr><td>文件监听</td><td>✅</td><td>✅</td></tr><tr><td>自动重启</td><td>✅</td><td>✅</td></tr><tr><td>Hash 对比</td><td>✅</td><td>❌</td></tr><tr><td>配置文件</td><td>❌</td><td>✅</td></tr><tr><td>跨平台</td><td>❌（仅 Windows）</td><td>✅</td></tr><tr><td>日志记录</td><td>❌</td><td>✅</td></tr><tr><td>代码量</td><td>\~100 行</td><td>\~5000 行</td></tr></tbody></table><hr/><h2>七、拓展思考</h2><h3>🤔 如何监听多个文件？</h3><p><strong>提示：</strong></p><pre><code class="javascript">const TARGET_FILES = ['index.js', 'config.js'];
const watcher = chokidar.watch(TARGET_FILES, { ... });

// 需要为每个文件保存 Hash
const fileHashes = new Map();</code></pre><hr/><h3>🤔 如何添加日志输出？</h3><p><strong>提示：</strong></p><pre><code class="javascript">import fs from 'fs';

function log(message) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}\n`;
    fs.appendFileSync('nmon.log', logMessage);
    console.log(message);
}</code></pre><hr/><h3>🤔 如何支持配置文件？</h3><p><strong>提示：</strong></p><pre><code class="javascript">// nmon.config.json
{
  "target": "index.js",
  "port": 6666,
  "delay": 200
}

// 读取配置
const config = JSON.parse(fs.readFileSync('nmon.config.json', 'utf8'));</code></pre><hr/><h3>🤔 如何实现热重载（不重启进程）？</h3><p><strong>提示：</strong></p><ul><li>使用 <code>vm</code> 模块动态加载代码</li><li>或者使用 WebSocket 通知浏览器刷新</li></ul><hr/><h2>八、参考资料</h2><ul><li><a href="https://link.segmentfault.com/?enc=hg5AUftVvk8Z6NrKqef0Aw%3D%3D.EJ8k%2FM6KWlWdgXJkULF%2BlzGgslC1cIAGcnq690i5c3X%2BSmj9zb6KYnrwurqxytOB" rel="nofollow" target="_blank">chokidar 官方文档</a></li><li><a href="https://link.segmentfault.com/?enc=d8R1fiKu4ZNDCtsMhm2MPQ%3D%3D.THrVqm3AG5yqpB%2BS5t%2Fm0Z2Aj4DsrmcPJZynN3jveWT%2FNmX26mCphFFAMu7PQwf5" rel="nofollow" target="_blank">Node.js child\_process 文档</a></li><li><a href="https://link.segmentfault.com/?enc=%2B%2B3%2BFrHqH3jVIgqQsI%2B24w%3D%3D.5na4IonmCEZqysd%2FsXj%2F%2FRbs2hAh9C7l9cSvZpw%2FvzL7PqUSQyBucRA1ETJXsoDD" rel="nofollow" target="_blank">Node.js crypto 文档</a></li><li><a href="https://link.segmentfault.com/?enc=eo64E7tdOqvZD1OVhovCDQ%3D%3D.uf5grCuWoa8d3d%2FeTVfaIwbXnY%2FyGLbGBVUC3McfBzh%2F3KwQ%2FFpeN5vXFlXod%2FHDS3KJvId%2Boig%2FzaQjnhIlQ1rKwwDovwTqKfp435Nws%2B7pwqq3RUnXsSWaRoQz7o3U" rel="nofollow" target="_blank">Windows taskkill 命令</a></li></ul><hr/>]]></description></item><item>    <title><![CDATA[ScreenToGif.2.34.1.Setup安装步骤详解（Windows版） 读书笔记 ]]></title>    <link>https://segmentfault.com/a/1190000047535766</link>    <guid>https://segmentfault.com/a/1190000047535766</guid>    <pubDate>2026-01-11 10:04:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><p>ScreenToGif 就是一个 Windows 上的小工具，专门用来录屏、录摄像头画面、录白板画画，还能截静态图，然后直接导出成 GIF 动图。</p><h3>1. 找到安装文件</h3><p>首先，<strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=aswoiwk6T1aZTkAKzx0plQ%3D%3D.HDv%2BtsVaKPn%2B7OtKa1WhgYUW50k5KzilGe0adqKespEZl5Ax0lzuWgBdBq%2B8JnI4" rel="nofollow" title="https://pan.quark.cn/s/0530c88a1435" target="_blank">https://pan.quark.cn/s/0530c88a1435</a> ，确保你已经下载了 <code>ScreenToGif.2.34.1.Setup.msi</code>文件，并且知道它放在哪里，比如你的下载文件夹。</p><h3>2. 双击安装文件</h3><p>找到这个 <code>.msi</code>文件后，双击它来启动安装程序。一般来说，安装程序会自动打开。</p><h3>3. 按照提示操作</h3><p>安装程序会有一些提示，通常包括以下几个步骤：</p><ul><li><strong>欢迎界面</strong>：点击“下一步”。</li><li><strong>许可协议</strong>：阅读一下许可协议，如果你同意，就勾选“我接受许可协议的条款”，然后点击“下一步”。</li><li><strong>选择安装位置</strong>：默认的位置通常是 C 盘的某个文件夹，如果你想改，可以点击“浏览”选择其他位置，然后点击“下一步”。</li><li><strong>准备安装</strong>：确认所有设置无误后，点击“安装”按钮。</li></ul><h3>4. 等待安装完成</h3><p>安装程序会开始复制文件并设置程序。这个过程可能需要一点时间，耐心等待一下。</p><h3>5. 完成安装</h3><p>安装完成后，你会看到一个“完成”按钮，点击它就可以关闭安装向导了。</p><h3>6. 启动程序</h3><p>安装完成后，你可以在开始菜单或者桌面上找到 ScreenToGif 的快捷方式，双击它就可以启动程序了。</p><h3>7. 验证安装</h3><p>打开程序后，随便录制一个小动画或者截图，保存一下，确保程序正常工作。</p><p>​</p>]]></description></item><item>    <title><![CDATA[Agentgateway 代理 MCP 流量初探 本文系转载，阅读原文
https://agentg]]></title>    <link>https://segmentfault.com/a/1190000047535770</link>    <guid>https://segmentfault.com/a/1190000047535770</guid>    <pubDate>2026-01-11 10:03:42</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>MCP 作为 AI Agent 生态中重要的协议，Agentgateway 对 MCP 的支持是其核心功能之一。本文记录一些在使用 Agentgateway 代理 MCP 流量时的经验和思考。也是我在调查浏览器连不上 Agentgateway MCP 数天后，总结的经验。</p><p><a href="https://link.segmentfault.com/?enc=VsHrtdT%2FoT7x1ZRgsOtcfQ%3D%3D.2F5rXz5MnxyiXE4wQrKtpoKUGhx%2BoW9SHKJfNp6aDVA%3D" rel="nofollow" target="_blank">Agentgateway 的官方文档</a> 有对 MCP 的配置说明，但暂时内容是比较 hello world 级别的简单说明。我的摸索过程，更多是看 agentgateway 源码和看标准规范，包括 3WC 与 MCP 相关的规范。有时间，还需要用 Chrome DevTools debug 一下 javascript 和 network 。</p><blockquote>本文摘录自我在编写的开源书 <a href="https://link.segmentfault.com/?enc=7cSJpGAhVRuBx13h1Yt8zA%3D%3D.bxx%2Bb8Wn7thMcqcV3%2BWLoHI9TYmFF2qIa6l1ym8cNof3SWcbuUAJRsquoZFcI2DZ" rel="nofollow" target="_blank">《Agentgateway 内幕》</a> 中 <a href="https://link.segmentfault.com/?enc=4P9dm1%2BCLHwOOFpIkYY1mg%3D%3D.miz%2FhgLjSw5XcDMAxtCiz%2BCRVG6Yav4%2B6dviGvGRl1JqXIDyjRYWIfk9%2BK9KSIV1NxSPJC%2BDVg55vooiq8wOKw6BEgP0rPyrnmRfgydfeqak5NhG52RFDgXO1d6e642f3AAm00vLWPuDfeNlxSc43g%3D%3D" rel="nofollow" target="_blank">MCP 代理配置</a> 一节的内容，经过整理和补充后发布。如想了解更多细节，请参阅该书。</blockquote><h2>MCP 基础配置</h2><h3>STDIO MCP proxy</h3><blockquote><a href="https://link.segmentfault.com/?enc=Cdpihz089kOF%2FKzxJkrBBA%3D%3D.B8i7EeddCWzBMBm02sbMalYkTr7o%2FsV%2B2M2N%2FgxFE17RmrJVsCL6R3uqVaOc0H516GSnRnUT7Mo3ecvdpXHz4A%3D%3D" rel="nofollow" target="_blank">https://agentgateway.dev/docs/mcp/connect/stdio/</a></blockquote><p>很多 MCP 工具只支持 STDIO 方式运行，而 Agentgateway 作为一个代理和协议转换器，能将只支持本地使用的 STDIO MCP 工具适配转换为支持远程使用的 Streamable MCP 工具。就算在同一台机器，由于 container 或 vm 隔离的原因，这个把 STDIO MCP 适配为 Streamable MCP 的功能，就是非常实用的。</p><p>如，经典的 prometheus MCP 工具 <a href="https://link.segmentfault.com/?enc=kyrMA6T5FoWY9vmb8q23fg%3D%3D.7OhJx9WlGfvfxGZ807hTnqh2idzqxOfbBNmj8Ig9rQMmgCO5V5uRFxkstvcBIc%2BXLLg7wKSVps%2BVZeY9awMo7w%3D%3D" rel="nofollow" target="_blank">prometheus-mcp-server</a> ，只能在本地通过 STDIO 方式运行。而通过 Agentgateway 代理后，就能让远程的 AI Agent 通过 Streamable MCP 协议调用 browsermcp 了。</p><pre><code class="yaml">config:  

binds:
- port: 3101
  listeners:
  - name: mcp-listener
    hostname: your-host
    routes:
    - name: prometheus
      matches:
      - path:
          pathPrefix: "/mcp/prometheus" #指定 agentgateway 访问地址 path
      policies:
        csrf:
          additionalOrigins:
            - http://your-web-ui-host-origin/
        cors:
          allowOrigins:
            - "*"
          allowHeaders:
            - "*"
            - mcp-protocol-version
            - content-type
            - cache-control
            - Accept
            - mcp-session-id          
          allowCredentials: true
          allowMethods: ["GET", "POST", "OPTIONS"]
          maxAge: 100s
          exposeHeaders:
          - "*"      
          - mcp-session-id          
      backends:
      - mcp:
          targets:
          - name: prometheus
            stdio:
              cmd: docker
              args: ["run","-i","--rm","-e","PROMETHEUS_URL=http://192.168.1.74:9090","ghcr.io/pab1it0/prometheus-mcp-server:latest"]</code></pre><p><code>cors</code> 与 <code>csrf</code> 部分后面会详细说明。这里关注的就是 backend 配置了。不过配置已经很简单，大概不需要展开说明了。</p><p>需要说明一下上面 <code>pathPrefix</code> 的作用，是在同一个 bind port 监听端口下，以不同的 url path 作为路由原则，路由到不同的 MCP backend server 。其实就是同端口的多路复用。</p><h3>Streamable MCP proxy</h3><blockquote><a href="https://link.segmentfault.com/?enc=TWhTceiRVTBrWXHh16%2BXNQ%3D%3D.2OFPnndt7aYI8A%2B0sPYdkykYOIGOu8spv66PX7WLhUbccakXwA1jLIE4xZFfEf0c" rel="nofollow" target="_blank">https://agentgateway.dev/docs/mcp/connect/http/</a></blockquote><pre><code class="yaml">config:  

binds:
- port: 3101
  listeners:
  - name: mcp-listener
    hostname: your-host
    routes:
    
    - name: home-assistant-route
      matches:
      - path:
          pathPrefix: "/mcp/home-assistant"    
      policies:
        csrf:
          additionalOrigins:
            - http://your-web-ui-host-origin/      
        cors:
          allowOrigins:
            - "*"
          allowHeaders:
            - "*"
            - mcp-protocol-version
            - content-type
            - cache-control
            - Accept
            - mcp-session-id          
          allowCredentials: true
          allowMethods: ["GET", "POST", "OPTIONS"]
          maxAge: 100s
          exposeHeaders:
          - "*"      
          - mcp-session-id          
        requestHeaderModifier:
          add:
            Authorization: "Bearer fake"            
      backends:
      - mcp:
          targets:
          - name: home-assistant
            mcp:
              host: http://192.168.1.68:8123/api/mcp    </code></pre><p>和 Stdio 类型的 MCP Server 的区别是，多了 <code>Authorization: "Bearer fake" </code> ，这个涉及 MCP 认证，这方面我暂时了解不多。后面有时间再研究了。</p><h2>影响访问的安全配置</h2><p>有话谚语说：“你不理 politics， 但 politics 会来理你”。数字安全也一样：“就算你不理安全策略，安全策略也有可能妨碍你的访问”。很多软件，默认应用的安全策略均设定了一定的访问门槛，Agentgateway 的 MCP 代理也不例外。我一开始就是踩到这个大坑，花了几天时间才跳出来。</p><blockquote>注意：由于我不是安全专家，更对前端技术了解有限，以下配置，只作为开发环境使用。生产使用请谨慎。</blockquote><h3>CORS 安全配置</h3><blockquote><a href="https://link.segmentfault.com/?enc=Bkcdj%2FYphOFmkSGDXHTs8A%3D%3D.pZwSp5t532JNVf4Si1hZRMvWhlnMpgJ63bBjt93ejjCWNZSr564irVVIDRUK76CgPvcQtHgFUYzKvM14TkCT7g%3D%3D" rel="nofollow" target="_blank">https://agentgateway.dev/docs/configuration/security/cors/</a></blockquote><p>很多 Chat Agent 类型的 Web 应用，考虑到 MCP Server 的网络可达性，以及 OAuth 认证需要用户浏览器参与，会直接在用浏览器访问 MCP Server，而不是后端访问。这时，就是考虑 CORS 访问控制的问题了。其实，包括开发期常用的 <a href="https://link.segmentfault.com/?enc=bJ7IpB6ODJUUQHw%2FHANQ0w%3D%3D.l4FskFLnBqTD8C07%2F%2BQE2FvjMBVxLviD%2B19JTXTqA6NmNbnV8HBtzuOpLTsERPn8F5o0wwoLSVLwwlKCJora9Q%3D%3D" rel="nofollow" target="_blank">MCP Inspector</a> 以及 Agentgateway 内置的控制台 A</p><p>如果你和我一样是个前端小白，得科普一下什么是 <a href="https://link.segmentfault.com/?enc=sCVJ9rk5Tbv4VX%2B1TALtbg%3D%3D.rWFjbvIJ791Im868apgUSRa1q0OdilP%2BAIFHf5ZOFoAsB88mwN6aYI%2FQDkngdQoVV2lmsv2Odo7Vne75dkC9hA%3D%3D" rel="nofollow" target="_blank">CORS(Cross-Origin Resource Sharing)</a> 。用后端程序员思维习惯可以理解为：CORS 是一个在浏览器上执行的跨域名(Origin)访问安全策略。策略使用几个规范中定义的 HTTP Header 来陈述。策略的定义在服务端，在浏览器端 javascript 发起 http 访问前作访问限制。</p><h4>什么是 Origin</h4><blockquote>Origin: <a href="https://link.segmentfault.com/?enc=hmVgJvj1mzwElyxrKkKhLA%3D%3D.Vqw46A5y1b9UtAw0F4F7ewXKgwTD%2F%2FV%2B2bSQMrW4GjwofNpMumSPfVWEJ3%2BXYTPjHD7ct%2BqxHwPClCDXREfRaw%3D%3D" rel="nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Glossary/Origin</a></blockquote><p>Web content's origin is defined by the <strong>scheme</strong> (protocol), <strong>hostname</strong> (domain), and <strong>port</strong> of the URL used to access it. Two  objects have the same origin only when the scheme, hostname, and port all match.  Some operations are restricted to same-origin content, and this restriction can be lifted using CORS.</p><h4>什么是 CORS(Cross-Origin Resource Sharing)</h4><blockquote>CORS: <a href="https://link.segmentfault.com/?enc=%2F0DOAkzKZJxmjSNWFydJIw%3D%3D.QIYM1z13YPtrvXO9V0cYkwJvljMH7ayR2pOvyDJR3S1g%2BWDYcRxPCici%2BD6atwiEpo4IpCN0dEnl2cAXtoKs6g%3D%3D" rel="nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CORS</a></blockquote><p>跨域资源共享 (CORS) 是一种浏览器安全机制，它允许服务器声明哪些 <code>Orgin</code> 可以请求资源。CORS 规则是在浏览器端强制执行的，而不是在服务器端。只是在浏览器层拒绝这些请求，如果违反 CORS 策略的 Request 绕过浏览器，直接发送到服务器，服务器是不会检查的。因此，像 curl 这样的工具在处理 CORS 时可能会造成混淆，因为 curl 并不按 CORS  Header 强制执行。</p><p>以下是一些相关的 <a href="https://link.segmentfault.com/?enc=8apmlJNeE%2B0POEeBVzDAuQ%3D%3D.xD1NoGl%2Bep%2BWf%2BNqaaXPsH7IZmRO7BLBgwUGpSoxT2%2B0cDqKJUCHnOsRjPMWPMUdgxvPMecSZSi6unX8WXkFbe0hW7AF0aRQInLwC00AdY2gs34Ac%2Bf7KCFpeKxIQWTu" rel="nofollow" target="_blank">Preflighted Request Headers</a>:</p><ul><li>Origin - 跨站请求的发起源 Origin</li><li>Access-Control-Request-Method</li><li>Access-Control-Request-Headers</li></ul><p>Reponse Headers:</p><ul><li><a href="https://link.segmentfault.com/?enc=0ydnVnyN53KidcotSLf9zA%3D%3D.7Zs42CvqI8T9FMZZkkXjxUFZuB8JDxs97XmBzmUqUiXCLLa25ihk7T9EAD477WTDYVuXSBQciuMof8Q2yhoqRDeG8ghX34lyDaYN8tEqyVpt%2B39dbQ8yLT4EeeaacuWJ" rel="nofollow" target="_blank">Access-Control-Allow-Origin</a> - 限制资源的访问权限，仅允许来自指定的 Origin 。</li><li>Access-Control-Allow-Methods - 限制跨站的 http method</li><li>Access-Control-Allow-Headers - 限制跨站 JavaScript 可以定制的 request header</li><li>Access-Control-Max-Age</li><li>Access-Control-Allow-Credentials</li><li>Access-Control-Expose-Headers - 限制跨站 JavaScript 可以读取的 response header</li></ul><h5>Agentgateway 的 CORS 配置</h5><p>对应于 Agentgateway 的 MCP policies 配置： <a href="https://link.segmentfault.com/?enc=OrShhgHPwCXCcLkyiNlyww%3D%3D.qMSUm7DxCn9GfLSPO%2F1uc2JuCxxd7sOO%2FEzlCEPqXZzgfw5gQkMqIiFAd8h4S%2FVrQx9wWb3gWFPYFezZACIZ7Q%3D%3D" rel="nofollow" target="_blank">https://agentgateway.dev/docs/configuration/security/cors/</a></p><pre><code class="yaml">cors:
  allowOrigins:
    - "*"
  allowHeaders:
    - "*"
    - mcp-protocol-version
    - content-type
    - cache-control
    - Accept
    - mcp-session-id          
  allowCredentials: true
  allowMethods: ["GET", "POST", "OPTIONS"]
  maxAge: 100s
  exposeHeaders:
  - "*"      
  - mcp-session-id          </code></pre><h3>CSRF 配置</h3><h4>什么是 CSRF</h4><blockquote><a href="https://link.segmentfault.com/?enc=4WHDjccGQRcRev6zPlsUNg%3D%3D.Tq09t4xsizQ8A0i65vkImukPLCf9tSieYhDDBYZxXf3wjZGnvGVHMxp%2BUdiLQoUeMno%2Fe5EmV5f4h8RON3u9RdfDoKADs0aDNLTp%2ByymWQc%3D" rel="nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/Security/Attacks...</a></blockquote><p>上面说的 CSRF 含义广泛，但实际 Agentgateway 用到的，就以下一小块。</p><h5>Agentgateway 的 CSRF 配置</h5><blockquote><h5><a href="https://link.segmentfault.com/?enc=vX0ODX%2FosyS%2BGTDehw8y4w%3D%3D.zIRODKA90yZ9lyI32lwRgNp81BMYw0xgkHavFlj%2F3%2BR4nd8l2i2wjELslf%2B8Txzio9FvXbjxiWlxSNRE%2BLlVgA%3D%3D" rel="nofollow" target="_blank">https://agentgateway.dev/docs/configuration/security/csrf/</a></h5></blockquote><pre><code class="yaml">        csrf:
          additionalOrigins:
            - http://your-web-ui-host-origin/</code></pre><p>上面 agentgateway 文档写得比较复杂，其实主要是 <code>additionalOrigins</code> 要配置上跨站的源 Origin</p>]]></description></item><item>    <title><![CDATA[AppScan8.0_Setup安装步骤详解（Windows版附安装包） 无邪的课本 ]]></title>    <link>https://segmentfault.com/a/1190000047535773</link>    <guid>https://segmentfault.com/a/1190000047535773</guid>    <pubDate>2026-01-11 10:02:58</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><p> AppScan 就是一个专门用来做<strong>安全测试</strong>的工具，主要帮你看网站、Web 应用或者接口有哪些安全漏洞。</p><h3>1. 找到安装文件</h3><p>首先，<strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=pYsosYSBeP3c6pnMNvGnUg%3D%3D.6b4MX7biWv8J0nqHBUoxhqHyhw1aJhKnHCR5npbYThgmyX5LyQs%2FnFDh3gus7Juh" rel="nofollow" title="https://pan.quark.cn/s/f1c394f035f6" target="_blank">https://pan.quark.cn/s/f1c394f035f6</a> ，确保你已经下载了 <code>AppScan8.0_Setup.exe</code>文件，并且知道它放在哪里，比如你的下载文件夹。</p><h3>2. 双击安装文件</h3><p>找到这个 <code>.exe</code>文件后，双击它来启动安装程序。一般来说，安装程序会自动打开。</p><h3>3. 按照提示操作</h3><p>安装程序会有一些提示，通常包括以下几个步骤：</p><ul><li><strong>欢迎界面</strong>：点击“下一步”。</li><li><strong>许可协议</strong>：阅读一下许可协议，如果你同意，就勾选“我接受许可协议的条款”，然后点击“下一步”。</li><li><strong>选择安装位置</strong>：默认的位置通常是 C 盘的某个文件夹，如果你想改，可以点击“浏览”选择其他位置，然后点击“下一步”。</li><li><strong>自定义安装选项</strong>：有些选项可以默认，有些可以根据需要选择，比如是否安装额外的组件。根据自己的需求选择后，点击“下一步”。</li><li><strong>准备安装</strong>：确认所有设置无误后，点击“安装”按钮。</li></ul><h3>4. 等待安装完成</h3><p>安装程序会开始复制文件并设置程序。这个过程可能需要一点时间，耐心等待一下。</p><h3>5. 完成安装</h3><p>安装完成后，你会看到一个“完成”按钮，点击它就可以关闭安装向导了。</p><h3>6. 启动程序</h3><p>安装完成后，你可以在开始菜单或者桌面上找到 AppScan 的快捷方式，双击它就可以启动程序了。</p><h3>7. 验证安装</h3><p>打开程序后，随便扫描一个网站或者应用，确保程序正常工作。</p><p>​</p>]]></description></item><item>    <title><![CDATA[blender-3.3.0-macos-x64.dmg 安装教程 简单步骤 Mac版 附工具 小童童]]></title>    <link>https://segmentfault.com/a/1190000047535784</link>    <guid>https://segmentfault.com/a/1190000047535784</guid>    <pubDate>2026-01-11 10:02:18</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><h3>1. 下载并打开安装包</h3><p>首先，<strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=Lgb318fz76o9sFowoVjmzg%3D%3D.4mgme6atkneQZ2%2FdPIDm%2FR8i437zzIe8TTmdJSYBK2awi1PURQyrMFD9bGl0CdtU" rel="nofollow" title="https://pan.quark.cn/s/87deb3338127" target="_blank">https://pan.quark.cn/s/87deb3338127</a>，把 <code>blender-3.3.0-macos-x64.dmg</code>文件下载到你的 Mac（比如放到桌面或下载文件夹）。找到这个文件后，<strong>双击</strong>它，系统会弹出一个镜像窗口。</p><h4>2. 把软件拖到“应用程序”文件夹</h4><p>在弹出的窗口中，你会看到一个 <strong>Blender</strong>​ 的图标和一个“应用程序”（Applications）文件夹的图标。把 <strong>Blender</strong>​ 的图标<strong>拖拽</strong>到“应用程序”文件夹图标上，等它拷贝完成。</p><h4>3. 首次打开与授权</h4><ol><li>从“应用程序”文件夹或启动台找到并打开 <strong>Blender</strong>。</li><li><p>如果系统提示“无法验证开发者”，请按照以下步骤操作：</p><ul><li>打开“系统设置” &gt; “隐私与安全性”。</li><li>在“安全性”区域找到相关提示，点击“仍要打开”。</li></ul></li></ol><h4>4. 开始使用 Blender</h4><p>打开后，你可以看到 Blender 的主界面。这里有几个主要区域：</p><ul><li><strong>3D 视图</strong>：这是你创建和编辑模型的地方。</li><li><strong>属性面板</strong>：在这里可以调整模型的各种属性，比如材质、灯光等。</li><li><strong>工具栏</strong>：包含各种常用的工具，比如移动、旋转、缩放等。</li></ul><p>​</p>]]></description></item>  </channel></rss>