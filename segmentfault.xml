<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[敏捷转型不只是流程：资深 PM 如何带团]]></title>    <link>https://segmentfault.com/a/1190000047399649</link>    <guid>https://segmentfault.com/a/1190000047399649</guid>    <pubDate>2025-11-14 16:11:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>敏捷转型在国内企业中已经从“热词”进入“常态”，但很多组织的敏捷实践，却陷入了“表面繁荣、内在空心”的假敏捷困局。会议变多、节奏变快、工具上线，却没有带来真正的业务敏捷与团队成长。本文将从项目治理与组织效能的角度，带你看清“假敏捷”的根源，并给出走出困局的可执行路径。</p><h3>一、当敏捷成为形式：流程在跑，价值没动</h3><p>过去几年，“敏捷转型”几乎成为各大中台与研发部门的常规动作。</p><p>从互联网到制造业，从创业公司到国央企，大家都在跑 Scrum、开站会、做 OKR。但当我们深入项目现场，却常听到这样的反馈：</p><ul><li>“我们比以前更忙了，但交付节奏并没有变快。”</li><li>“站会时间越来越长，但沟通效率越来越低。”</li><li>“敏捷上线半年了，客户满意度依旧没有提升。”</li></ul><p>这就是典型的“假敏捷”：流程在跑，但组织的认知与能力并未同步升级。表面上似乎“一切更敏捷”，实际上只是把旧的项目管理习惯换了个新术语而已。</p><p>假敏捷的特征往往包括：</p><ul><li>敏捷被视为一套“标准化流程”而非“适应性机制”；</li><li>团队机械执行 Scrum 仪式，却不理解背后的逻辑；</li><li>管理层追求速度，却回避文化、结构与激励机制的变革。</li><li>综上可知，很多企业不是在做敏捷，而是在表演敏捷。</li></ul><h3>二、假敏捷的根因：方法换了，思维没变</h3><h4>1. 从“命令控制”到“赋能协作”的断层</h4><p>敏捷倡导团队拥有更高的自主权和责任感，但许多组织仍延续传统的层级管理思维。</p><p>管理者关注的是“项目是否按计划推进”，而不是“团队是否在创造价值”；团队执行的是“上级任务”，而非“用户导向”；汇报链条依旧冗长，决策依旧集中。</p><p>据 State of Agile Report 2024 调研显示，47% 的敏捷转型失败，根本原因是领导层思维未转变。</p><p>换言之，流程再精致、工具再完善，只要领导层仍旧以控制为核心，敏捷就无法生根。</p><h4>2. 流程替代思考：看板上跑的不是价值，而是任务</h4><p>Jira、ONES、Trello 等研发管理工具确实让项目更透明，也是敏捷转型中必不可少的一环，但它们不是灵丹妙药。敏捷转型告诉你“需要用”这些工具，但在真正使用工具前，你要学会“怎么用”这些工具。</p><p>很多团队误以为“上了工具＝实现敏捷”，于是陷入另一种形式主义。他们花大量时间在工具上填数据、拉报表，但当你仔细观察，就会发现：</p><ul><li>任务粒度不均、优先级模糊；</li><li>每个 Sprint 都在“堆工作量”；</li><li>燃尽图看似漂亮，但产出与战略目标脱节。</li></ul><p>由此可见，这种“流程优先”的陷阱容易让团队陷入效率幻觉——他们忙于完成流程，却未真正思考“这个功能是否真的为用户创造了价值“。</p><h4>3. 绩效机制错位：KPI 约束下的“假协作”</h4><p>传统绩效考核强调个人产出，而敏捷强调跨职能协同。当团队成员被单独考核时，他们自然更关注“自己的任务”而非“整体目标”。结果就是：每个人都很努力，但整体协作效率极低。</p><p>因此，绩效机制如果与敏捷文化背道而驰，就会导致“假协作”：看似合作，其实各自为战。敏捷无法在孤立的激励体系中存活。</p><h3>三、走出假敏捷：从流程治理到组织心智的再造</h3><p>敏捷不是自下而上的自发运动，而是自上而下的认知革新。要走出假敏捷，企业需要在三个层面完成升级：管理者心智、PMO 职能、团队实践。</p><h4>1. 管理者：从“掌控者”到“系统设计师”</h4><p>很多领导误解“授权”就是“放手”，结果要么管太死，要么彻底放任。事实上，真正的敏捷领导力，是设计一个让团队能高效自组织的系统，通过清晰的边界、价值导向和反馈机制，构建有秩序的灵活性。</p><p>管理者层面的改进建议：</p><ol><li><strong>重新定义控制：</strong>由“控制任务”转向“控制节奏与目标”，让高层参与 Sprint Review，而不是仅看汇报；</li><li><strong>系统化思维：</strong>管理者应关注跨部门协同的制度设计、信息透明机制，而非日常微观管理；</li><li><strong>创造心理安全空间：</strong>允许暴露问题，让团队敢于暴露问题、质疑流程、提出改进。</li></ol><p><strong>实操案例：</strong></p><p>某制造企业在推行敏捷时，领导层每月参与一次 Sprint Review，与团队共同识别瓶颈。六个月后，交付延误率下降 30%，员工主动改进的数量增加了两倍。</p><h4>2. PMO：从“流程守门人”到“学习促进者”</h4><p>传统 PMO 主要关注规范与合规，但在敏捷转型中，它应成为组织学习与持续改进的中枢。假敏捷常常因为 PMO 把“标准化”误解为“僵化”，而真正成熟的 PMO，是能在秩序与灵活之间找到平衡。</p><p>PMP 层面的改进建议：</p><ul><li><strong>从流程合规转向价值导向：</strong>不再问“是否按模板执行”，而关注“交付周期、客户反馈”等价值指标。</li><li><strong>搭建知识复用机制：</strong>将项目复盘、最佳实践沉淀为共享知识库，用于指导后续项目。</li><li><strong>推动跨团队共学机制：</strong>定期组织“敏捷社区”或“Guild（行会）”，分享案例、反思改进，让敏捷成为组织的共识，而非孤岛实践。</li></ul><p><strong>实操案例：</strong></p><p>某互联网企业 PMO 通过建立“敏捷数据仪表盘”，整合交付周期、缺陷率、满意度等指标，实现了跨部门的价值对齐，协作摩擦下降 40%。</p><h4>3. 团队：从“被敏捷”到“用敏捷”</h4><p>许多团队“学会了流程”，却没“掌握原理”。他们照本宣科地开会、填表，却没理解迭代的意义。真正的团队敏捷，应当从“执行者”变为“问题发现与解决的主体”。</p><p>敏捷不是别人要求你执行的流程，而是团队自主选择的工作方式。团队真正的成长在于从“遵循规则”走向“共创价值”。</p><p>团队层面的改进建议：</p><ul><li><strong>先聚焦于小胜：</strong>以一个可验证的小目标开启试点，快速体验改进收益。</li><li><strong>建立复盘文化：</strong>复盘不是找责任，而是发现系统性约束、优化模式。</li><li><strong>透明化沟通：</strong>让看板不仅仅展示任务，还要让风险、假设与反馈全部可见。</li></ul><p><strong>实操案例：</strong></p><p>一家 SaaS 团队在初期敏捷实施中，每次迭代只做任务分配，几乎无复盘。后来引入“失败展台”机制——每个迭代评选“最值得学习的失败”，团队反而更敢尝试。三个月后，创新方案产出率提升 40%，团队氛围明显改善。</p><h4>4. 工具赋能：从“工具使用”到“系统协同”</h4><p>工具是敏捷落地的加速器，而非终点。很多团队在敏捷转型初期被工具“反客为主”——流程为了工具而设计，会议为了数据而开。实际上，工具的价值在于让组织的反馈循环更快、协作更透明、改进更可视化。</p><p>要让工具真正服务于敏捷，应当遵循三个原则：</p><p><strong>① 从“记录”到“认知”</strong></p><p>工具不是任务登记簿，而是思考的镜子。在 ONES 等研发管理平台中，用户故事应表达“价值交付”而非单纯的“任务目标”。</p><p>举个例子：一个用户故事不应该只写”实现登录功能”，而应是“作为一名注册用户，我希望能通过手机号或企业账号快速登录系统，以便更方便地进入工作空间，减少首次登录失败率”。</p><p><strong>② 从“工具孤岛”到“系统协同”</strong></p><p>敏捷工具不是单一项目的容器，而是组织运营系统的一部分。企业可通过集成不同模块（项目、测试、OKR、客户反馈等），形成从目标 → 执行 → 反馈 → 改进的闭环。</p><p>例如，在 ONES 研发管理平台中将项目、测试与目标模块集成起来，团队可以在一次迭代中同时看到任务完成率与价值交付率——Sprint 不再是简单的时间盒，而是业务战略的执行节奏。</p><p>当工具协同起来，团队不再为“谁做什么”争论，而是能共同回答“我们为什么做”。</p><p><strong>③ 从“使用工具”到“用数据改进”</strong></p><p>真正成熟的团队，不只是用上工具，而是学会用数据驱动决策。</p><ul><li>通过 Lead Time 识别流程瓶颈；</li><li>用燃尽图偏差分析任务估算准确性；</li><li>通过 Velocity 趋势评估团队负载与可持续交付节奏。</li></ul><p>同时，将工具数据纳入团队回顾中，让复盘基于事实，而非感觉。当工具被正确使用，它不再是负担，而是团队反思与进步的放大镜。</p><h4>5. 构建组织级敏捷：从“团队敏捷”到“业务敏捷”</h4><p>走出“假敏捷”的终极目标，不是优化团队，而是提升组织整体的适应力。这需要企业从三个层次系统性升级：</p><table><thead><tr><th>层级</th><th>传统思维</th><th>敏捷思维</th><th>转型杠杆点</th></tr></thead><tbody><tr><td>战略层</td><td>目标分解、年度计划</td><td>动态 OKR、滚动规划</td><td>战略对齐与节奏共振</td></tr><tr><td>结构层</td><td>职能部门、项目制</td><td>跨职能小队、价值流</td><td>流程重构与组织协作</td></tr><tr><td>文化层</td><td>稳定、控制、预测</td><td>学习、信任、反馈</td><td>建立心理安全与改进文化</td></tr></tbody></table><p>整合建议：</p><ul><li>让团队 OKR 与企业战略形成自上而下的链路；</li><li>以价值流为核心优化组织架构，减少信息阻塞。</li><li>以文化机制支撑持续学习，如内部复盘大会、改进激励制度。</li></ul><p>这也意味着，当企业能在战略、结构与文化三个维度形成一致性，敏捷才会从“团队工具”演化为“组织能力”。</p><h3>四、敏捷的本质：速度不是目的，学习才是</h3><p>敏捷不是为了“更快”，而是为了“更聪明”，“更有价值”。真正的敏捷组织，不仅能高效交付，更能在不确定中学习与演化。</p><ul><li>它的节奏适中，但反馈及时；</li><li>它的文化开放，但有秩序；</li><li>它的目标清晰，但路径灵活。</li></ul><p>正如《Toyota Kata》所说：“成功的关键，不在于它的生产工具或技术，而在于它持续改进和适应变化的能力。”换言之，持续学习的能力，才决定了组织的长期竞争力。</p><p>敏捷不是一个阶段性的项目，而是一种长期主义的管理哲学。一个资深 PM 的使命，不只是执行流程，而是让组织具备持续学习与自我进化的能力。当管理者懂得系统设计，PMO 成为学习枢纽，团队学会自驱与反思时，敏捷就不再是“流程”，而是组织的本能。那一刻，敏捷不再是目标，而是企业文化的一部分。</p>]]></description></item><item>    <title><![CDATA[⚡️2025-11-14GitHub日榜]]></title>    <link>https://segmentfault.com/a/1190000047399876</link>    <guid>https://segmentfault.com/a/1190000047399876</guid>    <pubDate>2025-11-14 16:10:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>🚀 <a href="https://link.segmentfault.com/?enc=Q%2FD3GRM6X9MjIUq%2FV%2F1cdw%3D%3D.kfnYv5rLdtvakAKPEWULqotGW7mwqlLYvHNNXW612QLHAfHEDh5KRsKCk2LaWpgj" rel="nofollow" target="_blank">sansan0 /TrendRadar</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=g%2Blqv9KPvOfa8yaM9ZSsZg%3D%3D.vEliP5ywXNrciYPEBzZnWpQ5g%2BHcMYRBFS6ehFCUIncDsGK9PsiLiKebTkd7KLs%2B" rel="nofollow" target="_blank">https://github.com/sansan0/TrendRadar</a></p><p>💡 <strong>简介</strong>：趋势雷达是一个30秒快速部署的热点助手，支持11+主流平台热点聚合，通过智能推送策略、精准内容筛选和趋势分析，帮助用户获取真正关心的新闻资讯。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>2275</td></tr><tr><td>⭐ Stars</td><td>11686</td></tr><tr><td>⚒️ Forks</td><td>7068</td></tr><tr><td>💻 Language</td><td>Python</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>最快30秒部署的热点聚合工具</li><li>多平台热点实时监控与分析</li><li>智能推送策略与时间窗口控制</li><li>支持多渠道多端适配与AI分析功能</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=yNdU0zoByXuZgsDFPKy5jw%3D%3D.kBLvTASWQlbsIlzzdecaPS3j%2FPcf%2B1HCokzB9wpVuMQNbfVLrqlC6TIG8Q9Zevqt" rel="nofollow" target="_blank">google /adk-go</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=dDN3sQPewRFYtGuF5Z8Q7Q%3D%3D.P7aXq%2B62EgyYgFKtYjXJVCy9UmATg2P7UUmQBbgml%2FgKyjyJbrapjdcCu7VgEPLN" rel="nofollow" target="_blank">https://github.com/google/adk-go</a></p><p>💡 <strong>简介</strong>：Go代理开发工具包（ADK）是一个开源的、代码优先的Go工具包，用于构建、评估和部署复杂的AI代理，具有灵活性和可控性，且兼容其他框架与云原生环境。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>351</td></tr><tr><td>⭐ Stars</td><td>3197</td></tr><tr><td>⚒️ Forks</td><td>172</td></tr><tr><td>💻 Language</td><td>Go</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>代码优先开发，灵活性高</li><li>模块化多代理系统，扩展性强</li><li>符合Go习惯用法，性能优异</li><li>跨平台部署，云原生支持好</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=QnB8JuLaezsE94oWgCNFOw%3D%3D.GlyypL0Vq13U%2FxNqwqoSqU%2BTIbZpX%2FJMmmFF0JnKq47mC6RN7Etucchi3pqPcSPx" rel="nofollow" target="_blank">TapXWorld /ChinaTextbook</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=vU1%2FtDHX3g1wr%2FvXWCXg4w%3D%3D.dL9hbaxDZJO1R%2BZQs%2BbqKZPABaATK1hXjJepAZdRZu%2BBK3zPYjCgOha1EhZcOUQF" rel="nofollow" target="_blank">https://github.com/TapXWorld/ChinaTextbook</a></p><p>💡 <strong>简介</strong>：这是一个开源的中国教育资源项目，提供从小学到大学的数学教材，并提供文件合并程序以解决GitHub文件拆分问题，支持免费获取教育资源。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>399</td></tr><tr><td>⭐ Stars</td><td>56131</td></tr><tr><td>⚒️ Forks</td><td>12538</td></tr><tr><td>💻 Language</td><td>Roff</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>提供免费优质教育资源，促进义务教育普及</li><li>覆盖从小学到大学的完整数学学习资料体系</li><li>提供文件合并工具，解决大文件拆分问题</li><li>支持国内外用户便捷下载资源</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=e8XdA7%2Br68sq%2B2%2BKH287PQ%3D%3D.aU4wpgEfs9VaoxJtItES9zwU7zYbYcc%2BEP1rqlSbdfjiF0WInop64D4Q5H2haPno" rel="nofollow" target="_blank">yeongpin /cursor-free-vip</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=8LqhZAuRLHZ3zhzZFAkomw%3D%3D.MoIWcVleAmFkKmce%2FrdFoV3WdNTW5RO7e3CgzoDdnK91udXiwDnys%2Fsgw4gkGUy3" rel="nofollow" target="_blank">https://github.com/yeongpin/cursor-free-vip</a></p><p>💡 <strong>简介</strong>：Cursor Free VIP是一款支持Windows、macOS和Linux系统的工具，可重置Cursor配置，提供多语言支持，用于学习和研究，需以管理权限运行并保持最新版本。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>358</td></tr><tr><td>⭐ Stars</td><td>41585</td></tr><tr><td>⚒️ Forks</td><td>5014</td></tr><tr><td>💻 Language</td><td>Python</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>多平台支持Windows/macOS/Linux</li><li>多语言支持英文、简体中文等</li><li>可重置Cursor配置</li><li>自动化脚本便捷安装使用</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=FD9Sk3M7I8Pysj128ujE8w%3D%3D.ORrM4Giai8Fw5hL%2FeEOH7VG3kvcpvceOjnF4NzNe9Tk%3D" rel="nofollow" target="_blank">nvm-sh /nvm</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=j03vpgcnFUSHZVnEtBdbxQ%3D%3D.jVR8jgNBXQPaFwp8jianxxM9dbY%2FViT2vNbo4ycHMzw%3D" rel="nofollow" target="_blank">https://github.com/nvm-sh/nvm</a></p><p>💡 <strong>简介</strong>：nvm是一个Node.js版本管理器，允许用户快速安装和使用不同版本的Node.js，支持POSIX兼容shell，适用于Unix、macOS和Windows WSL平台。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>79</td></tr><tr><td>⭐ Stars</td><td>89195</td></tr><tr><td>⚒️ Forks</td><td>9554</td></tr><tr><td>💻 Language</td><td>Shell</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>支持多版本Node.js安装与切换</li><li>兼容多平台（Unix、macOS、Windows WSL）</li><li>支持POSIX兼容shell（sh、bash、zsh等）</li><li>提供便捷安装与升级脚本</li></ul>]]></description></item><item>    <title><![CDATA[（小程序查看DWG）在线CAD中的“组”]]></title>    <link>https://segmentfault.com/a/1190000047399880</link>    <guid>https://segmentfault.com/a/1190000047399880</guid>    <pubDate>2025-11-14 16:09:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在使用CAD工具进行绘图时，面对复杂的图形结构，如何高效地管理多个对象成为提升工作效率的关键。CAD提供的“组”功能，正是为解决这一问题而设计的实用工具。本文将全面介绍 mxcad 中”组“的概念，以及如何实现组相关的功能开发。</p><h2>一、什么是“组”（Group）？</h2><p>在CAD中，<strong>组（Group）</strong> 是指将多个图形对象逻辑地组合在一起，形成一个可被统一操作的集合。组不会创建新的图元实体，也不会改变对象本身的几何属性，仅是一种<strong>命名的对象集合</strong>，组对象包含特点如下：</p><ul><li>组内的对象保持独立，可单独编辑。</li><li>选择组中任意一个对象时，整个组可被选中（取决于系统设置）。</li><li>每个组有唯一的名称，便于识别和管理。</li><li>支持嵌套：一个组可以包含另一个组，形成层级结构。</li><li>组不作为独立实体存储在图形数据库中，仅作为对象的逻辑关联存在。</li></ul><h2>二、组的核心功能开发</h2><h3>1. 创建组</h3><p>该功能流程是从用户执行“创建组”命令开始。首先，系统初始化相关变量（如组名、描述和对象列表），并获取当前图形数据库中的组管理字典。<br/>随后进入主循环，提示用户“选择对象”。用户可以通过点击或框选方式选择一个或多个图形对象，所选对象的ID将被保存到临时列表中。<br/>在选择过程中，用户可随时输入关键字进行设置：</p><ul><li>输入 <strong>N（名称）</strong>：进入命名流程，系统提示“输入编组名”。此时可输入 <code>[查询(A)]</code> 来查看已存在的组名；若输入 <code>*</code> 或直接回车，则列出所有组；否则查询指定组信息。输入名称后，系统检查是否重名，若无冲突则保存名称并返回选择状态。</li><li>输入 <strong>D（说明）</strong>：进入说明设置，提示“输入编组说明”，用户输入的文本将作为该组的描述信息。</li></ul><p>当用户完成选择并按 <strong>回车或空格键</strong> 确认后，系统开始创建组：</p><ul><li>首先检查所选对象中是否有成员已属于其他组。</li><li>若存在此类情况，则弹出确认提示：“包含相同对象的组已经存在。仍要创建新的组？&lt;N&gt;”，并提供“是(Y)/否(N)”选项。</li><li>若用户选择“否”或取消操作，命令终止。</li><li>若用户确认继续或无冲突，则调用底层API创建组，并将之前输入的描述信息赋值给新组。</li></ul><p>最后，组创建完成，系统退出循环，命令执行结束。整个流程支持ESC中断或新命令打断，确保操作的安全性和灵活性。</p><p>根据上述流程调用 mxcad 内部API接口实现方法如下：</p><pre><code class="ts">import { McDbEntity, McDbGroup, McDbPolyline, McGePoint3d, McObjectId, MxCADSelectionSet, MxCADUiPrKeyWord, MxCADUiPrPoint, MxCADUiPrString, MxCADUtility, MxCpp } from "mxcad";
import { DetailedResult, MxFun, MrxDbgUiPrBaseReturn } from "mxdraw";
interface GroupObject {
    name: string,
    group: McDbGroup
}
// 根据实体查找组
const getGroupForEntity = (entity: McDbEntity): GroupObject[] =&gt; {
    const database = MxCpp.getCurrentDatabase()
    const groupDict = database.GetGroupDictionary()
    const handle = entity.getHandle()
    const groupNames = groupDict.getAllObjectName()
    const length = groupNames.length();
    let groupArr: GroupObject[] = [];
    for (let index = 0; index &lt; length; index++) {
        const groupName = groupNames.at(index);
        const groupId = groupDict.getAt(groupName)
        const group = groupId.getMcDbObject() as McDbGroup
        if (!group) continue;
        const entityIds = group.getAllEntityId();
        entityIds.forEach(entityId =&gt; {
            if (entityId.getMcDbEntity()?.getHandle() === handle) groupArr.push({ name: groupName, group })
        });
    };
    return groupArr
}
// 创建组
async function Mx_Group() {
  let description = ""
  let ids: McObjectId[] = [];
  const database = MxCpp.getCurrentDatabase();
  const groupDict = database.GetGroupDictionary();
  const mxcad = MxCpp.getCurrentMxCAD();
  // 设定未命名组名
  const groupNames = groupDict.getAllObjectName();
  let num = 0;
  groupNames.forEach(item =&gt; {
    if (/^\*/.test(item)) {
      num += 1;
    }
  });
  let name: string = `*A${num + 1}`;
  // 创建组
  const createGroup = async () =&gt; {
    const isPresence = ids.some((id) =&gt; {
      return database.getEntitiesInTheGroup(id).length !== 0
    })
    if (isPresence) {
      const getKey = new MxCADUiPrKeyWord();
      getKey.setMessage(`包含相同对象的组已经存在。仍要创建新的组？&lt;N&gt;`);
      getKey.setKeyWords(`[是(Y)/否(N)]`);
      const key = await getKey.go();
      ids.forEach(id =&gt; {
        id.getMcDbEntity().highlight(false);
      })
      mxcad.updateDisplay();
      if (key?.toLocaleUpperCase() === "N") {
        return
      }
      if (!key) return
    }
    if (database.CreateGroup(ids, name)) {
      const groupId = groupDict.getAt(name)
      const group = groupId.getMcDbObject() as McDbGroup;
      if (description) group.description = description;
      if (/^\*/.test(name)) {
        MxPluginContext.useMessage().success('未命名组已创建');
      } else {
        MxPluginContext.useMessage().success(`组${name}已创建`);
      }
      ids.forEach(id =&gt; {
        id.getMcDbEntity().highlight(false);
      })
      mxcad.updateDisplay();
    };
  };
  while (true) {
    const getEntityPt = new MxCADUiPrPoint();
    getEntityPt.setMessage('选择对象');
    getEntityPt.setKeyWords(`[名称(N)/说明(D)]`);
    getEntityPt.setDisableOsnap(true);
    getEntityPt.setDisableDynInput(true);
    getEntityPt.disableAllTrace(true);
    const hoverSelectEnts: McDbEntity[] = [];
    getEntityPt.setUserDraw((pt, pw) =&gt; {
      if (hoverSelectEnts.length) hoverSelectEnts.forEach(ent =&gt; ent.highlight(false));
      hoverSelectEnts.length = 0;
      const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
      if (entId.isValid() &amp;&amp; !ids.map(item =&gt; item.id).includes(entId.id)) {
        const ent = entId.getMcDbEntity();
        const arr = getGroupForEntity(ent);
        if (arr.length) {
          const group = arr[0].group;
          group.getAllEntityId().forEach(id =&gt; {
            const ent = id.getMcDbEntity();
            ent.highlight(true);
            hoverSelectEnts.push(ent)
          })
        } else {
          ent.highlight(true);
          hoverSelectEnts.push(ent)
        }
      }
    });
    const pt = await getEntityPt.go();
    hoverSelectEnts.forEach(ent =&gt; ent.highlight(false));
    // 如果选择关键字，则执行相关操作
    if (getEntityPt.getStatus() == MrxDbgUiPrBaseReturn.kKeyWord) {
      if (getEntityPt.isKeyWordPicked("N")) {
        while (true) {
          const getName = new MxCADUiPrString()
          getName.setMessage("输入编组名")
          getName.setKeyWords(`[查询(A)]`)
          const str = await getName.go()
          if (getName.getDetailedResult() === DetailedResult.kCodeAbort || getName.getDetailedResult() === DetailedResult.kEcsIn || getName.getDetailedResult() === DetailedResult.kNewCommadIn) return
          if (getEntityPt.getDetailedResult() === DetailedResult.kNullEnterIn || getEntityPt.getDetailedResult() === DetailedResult.kNullSpaceIn || getEntityPt.getDetailedResult() === DetailedResult.kMouseRightIn) {
            return createGroup()
          }
          if (getName.isKeyWordPicked("A")) {
            getName.setMessage("请输入要列出的编码组名"+ "&lt;*&gt;")
            getName.setKeyWords("")
            const name = await getName.go();
            if (getName.getDetailedResult() === DetailedResult.kCodeAbort || getName.getDetailedResult() === DetailedResult.kEcsIn || getName.getDetailedResult() === DetailedResult.kNewCommadIn) return
            if (name &amp;&amp; name !== "*") {
              const groupId = groupDict.getAt(name)
              const group = groupId.getMcDbObject() as McDbGroup
              MxFun.acutPrintf(`\n 定义的编组:`)
              if (group) {
                MxFun.acutPrintf(`\n${group.name}`)
              }
            }
            else if (name === "*" || getName.getDetailedResult() === DetailedResult.kNullEnterIn || getName.getDetailedResult() === DetailedResult.kNullSpaceIn) {
              const groupIds = groupDict.getAllObject()
              MxFun.acutPrintf(`\n 定义的编组:`)
              groupIds.forEach((groupId) =&gt; {
                const group = groupId.getMcDbObject() as McDbGroup
                group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
              })
            }
            continue;
          }
          if (!str) return;
          if (/^\*/.test(str)) {
            MxFun.acutPrintf(`*无效`);
            continue;
          }
          const groupId = groupDict.getAt(str)
          const group = groupId.getMcDbObject() as McDbGroup
          if (group &amp;&amp; groupId.isValid()) {
            MxFun.acutPrintf(`编组${str} 已经存在`);
            continue;
          }
          name = str;
          if (ids.length) {
            ids.forEach(id =&gt; {
              const ent = id.getMcDbEntity();
              ent.highlight(false);
            })
            return createGroup();
          } else {
            break;
          }
        }
      } else if (getEntityPt.isKeyWordPicked('D')) {
        const getName = new MxCADUiPrString()
        getName.setMessage("输入编组说明")
        const str = await getName.go();
        if (!str) break;
        description = str
        continue;
      }
    } else if (getEntityPt.getStatus() === MrxDbgUiPrBaseReturn.kNone) {
      if (!ids.length) {
        return MxPluginContext.useMessage().success('未选择对象，未创建编组');
      } else {
        ids.forEach(id =&gt; {
          const ent = id.getMcDbEntity();
          ent.highlight(false);
        })
        return createGroup();
      }
    } else if (getEntityPt.getStatus() === MrxDbgUiPrBaseReturn.kCancel) {
      ids.forEach(id =&gt; {
        const ent = id.getMcDbEntity();
        ent.highlight(false);
      })
      return
    } else {
      // 判断是否选中实体
      if (pt &amp;&amp; hoverSelectEnts.length) {
        const selectIds = hoverSelectEnts.map(item =&gt; {
          item.highlight(true);
          return item.getObjectID()
        })
        ids.push(...selectIds);
        continue;
      } else if (pt &amp;&amp; !hoverSelectEnts.length) {
        getEntityPt.setUserDraw((point, pw) =&gt; {
          const pts = [pt, new McGePoint3d(pt.x, point.y), point, new McGePoint3d(point.x, pt.y)]
          // 设置范围框颜色即位置
          let pl = new McDbPolyline();
          pl.isClosed = true;
          pts.forEach(pt =&gt; pl.addVertexAt(pt));
          pw.setColor(0xFFFFFF);
          pw.drawMcDbEntity(pl);
          // 动态绘制矩形填充框
          const geometry = new THREE.BufferGeometry();
          geometry.setFromPoints([
            new THREE.Vector3(pt.x, pt.y, pt.z),
            new THREE.Vector3(pt.x, point.y, point.z),
            new THREE.Vector3(point.x, point.y, point.z),
            new THREE.Vector3(point.x, pt.y, pt.z)
          ]);
          geometry.attributes.uv = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), 2);
          geometry.setIndex([0, 1, 2, 0, 2, 3]);
          // 创建材质（半透明的颜色）
          const material = new THREE.MeshBasicMaterial({
            color: 0x004D00,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
          });
          const mesh = new THREE.Mesh(geometry, material);
          pw.drawEntity(mesh);
        });
        const nextPt = await getEntityPt.go();
        if (!nextPt) break;
        const ss = new MxCADSelectionSet();
        await ss.crossingSelect(pt.x, pt.y, nextPt.x, nextPt.y);
        ss.forEach(id =&gt; {
          if (!ids.map(i =&gt; i.id).includes(id.id)) {
            const ent = id.getMcDbEntity();
            const arr = getGroupForEntity(ent);
            if (arr.length) {
              const group = arr[0].group;
              group.getAllEntityId().forEach(id =&gt; {
                id.getMcDbEntity().highlight(true)
                ids.push(id);
              })
            } else {
              ent.highlight(true);
              ids.push(id);
            }
          }
        });
        continue;
      } else {
        continue;
      };
    }
  }
}</code></pre><h3>2. 解除组</h3><p>解除组的功能流程如下：<br/>命令启动后，系统提示用户“选择组”，并支持通过关键字 <code>[名称(N)]</code> 切换为按名称分解模式。在用户操作过程中，系统启用悬停预览功能：当鼠标移动到某个对象上时，会自动查询该对象所属的组，并高亮显示该组内的所有成员对象，便于用户直观判断将要操作的范围。<br/>接下来，根据用户的选择进入不同分支：</p><p>1.<strong>若用户输入 N（名称）</strong>：<br/>   - 进入“按名称分解”模式，提示“输入编组名”。<br/>   - 支持输入关键字 <code>[查询(A)]</code>：</p><ul><li>若输入 <code>A</code>，可进一步输入要查询的组名；<br/>   - 输入 <code>*</code> 或直接回车，则列出当前图形中所有已定义的组名；<br/>   - 输入具体名称，则检查并显示该组是否存在。<br/>   - 用户输入组名后，系统查找对应组：<br/>   - 若存在，执行分解操作（清空组内对象并从组字典中移除），提示“组 已分解”；<br/>   - 若不存在，提示“编组 未定义”，并允许重新输入。</li></ul><p>2.<strong>若用户点击某个对象</strong>：<br/>   - 系统获取该对象，并查询其所属的所有组（一个对象可能属于多个组）。<br/>   - 若对象仅属于一个组，则直接选中该组，准备分解。<br/>   - 若对象属于多个组，则进入选择流程：<br/>     - 提示“对象是多个组的成员&lt;接受&gt;”，提供 <code>[接受(A)/下一个(N)]</code> 选项；<br/>     - 选择 <code>A</code>：接受当前高亮的组；<br/>     - 选择 <code>N</code>：切换到下一个组，并更新高亮显示；<br/>     - 可循环切换，直到用户确认或取消。<br/>   - 确定目标组后，记录其名称。</p><p>最后，系统根据选定的组名执行分解操作：</p><ul><li>从组字典中获取该组对象；</li><li>调用 <code>clear()</code> 清空组内成员引用；</li><li>调用 <code>remove()</code> 从字典中删除该组；</li><li>提示“组 已分解”或“对象不是组成员”（如未选中有效组）。</li></ul><p>操作完成后，清除所有高亮显示的对象，确保界面恢复整洁，命令结束。其具体实现代码如下：</p><pre><code class="ts">import { McDbEntity, McDbGroup, McDbPolyline, McGePoint3d, McObjectId, MxCADSelectionSet, MxCADUiPrKeyWord, MxCADUiPrPoint, MxCADUiPrString, MxCADUtility, MxCpp } from "mxcad";
import { DetailedResult, MxFun, MrxDbgUiPrBaseReturn } from "mxdraw";
// 解除编组
async function Mx_Ungroup() {
    const ents: McDbEntity[] = [];
    let groupArr: GroupObject[] = [];
    let name!: string;
    const database = MxCpp.getCurrentDatabase();
    const groupDict = database.GetGroupDictionary();
    let index: number = 0;
    const getEnt = new MxCADUiPrEntity();
    getEnt.setMessage('选择组');
    getEnt.setKeyWords(`[名称(N)]`);
    getEnt.setUserDraw((pt, pw) =&gt; {
        ents.forEach(ent =&gt; ent.highlight(false));
        ents.length = 0;
        const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
        if (entId.isValid()) {
            const ent = entId.getMcDbEntity();
            groupArr = getGroupForEntity(ent);//getGroupForEntity参考上述创建组内代码
            if (groupArr.length) {
                const group = groupArr[index].group;
                group.getAllEntityId().forEach(id =&gt; {
                    const entity = id.getMcDbEntity();
                    entity.highlight(true);
                    ents.push(entity);
                })
            }
        }
    });
    const entId = await getEnt.go();
    if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
        if (getEnt.isKeyWordPicked('N')) {
            while (true) {
                const getString = new MxCADUiPrString();
                getString.setMessage('输入编组名');
                getString.setKeyWords(`[查询(A)]`);
                const str = await getString.go();
                if (getString.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                    // 删除组
                    const groupId = groupDict.getAt(str);
                    const group = groupId.getMcDbObject() as McDbGroup;
                    if (groupId.isValid() &amp;&amp; group) {
                        group.clear();
                        groupDict.remove(str);
                        MxPluginContext.useMessage().success('组 ' + str + ' 已分解');
                        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
                        return;
                    } else {
                        MxFun.acutPrintf('编组 ' + str + ' 未定义');
                        continue;
                    }
                } else if (getString.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
                    // 查询组
                    getString.setMessage("请输入要列出的编码组名" + "&lt;*&gt;")
                    getString.setKeyWords("")
                    const name = await getString.go();
                    if (getString.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                        if (name &amp;&amp; name !== "*") {
                            const groupId = groupDict.getAt(name)
                            const group = groupId.getMcDbObject() as McDbGroup
                            MxFun.acutPrintf(`\n 定义的编组:`)
                            if (group) {
                                MxFun.acutPrintf(`\n${group.name}`)
                            }
                        } else if (name === "*") {
                            const groupIds = groupDict.getAllObject()
                            MxFun.acutPrintf(`\n 定义的编组:`)
                            groupIds.forEach((groupId) =&gt; {
                                const group = groupId.getMcDbObject() as McDbGroup
                                group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                            })
                        }
                    } else if (getString.getStatus() === MrxDbgUiPrBaseReturn.kNone) {
                        const groupIds = groupDict.getAllObject()
                        MxFun.acutPrintf(`\n 定义的编组:`)
                        groupIds.forEach((groupId) =&gt; {
                            const group = groupId.getMcDbObject() as McDbGroup
                            group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                        })
                    }
                    continue;
                }
            }
        }
    } else if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
        if (groupArr.length === 1) {
            name = groupArr[0].name
        } else if (groupArr.length &gt; 1) {
            while (true) {
                const getKeys = new MxCADUiPrKeyWord();
                getKeys.setMessage('对象是多个组的成员&lt;接受&gt;')
                getKeys.setKeyWords('[接受(A)/下一个(N)]');
                let key = await getKeys.go();
                if (key === "A") {
                    name = groupArr[index].name;
                    break;
                } else if (key === "N") {
                    ents.forEach(ent =&gt; ent.highlight(false));
                    ents.length = 0;
                    index + 1 &gt; groupArr.length - 1 ? index = 0 : index += 1;
                    const res = groupArr[index];
                    res.group.getAllEntityId().forEach(id =&gt; {
                        const ent = id.getMcDbEntity();
                        ent.highlight(true);
                        ents.push(ent);
                    });
                    continue;
                } else {
                    if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
                    return;
                }
            }
        }
        if (name) {
            const groupId = groupDict.getAt(name)
            const group = groupId.getMcDbObject() as McDbGroup
            if (group) {
                group.clear();
                groupDict.remove(name);
                MxPluginContext.useMessage().success(`组 ${name} 已分解`);
            } else {
                MxPluginContext.useMessage().success('对象不是组成员');
            }
        } else {
            MxPluginContext.useMessage().success('对象不是组成员');
        };
        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
    }
}</code></pre><h3>3. 编辑组</h3><p>编辑图形中已有对象组（Group）的交互式功能。其主要功能是允许用户通过选择对象或输入组名的方式，找到目标组，并对其进行<strong>添加成员、删除成员或重命名</strong>等操作。<br/>命令启动后，系统首先提示“选择组”，并支持通过关键字 <code>[名称(N)]</code> 切换为按名称选择模式。在用户移动鼠标时，系统会启用悬停预览功能：自动检测光标下的对象，查询其所属的组，并高亮显示该组内的所有成员，帮助用户直观判断当前将要操作的对象范围。</p><p>如果用户点击了一个对象，系统会获取该对象所属的所有组：</p><ul><li>若对象不属于任何组，则提示“对象不是组成员”；</li><li>若只属于一个组，则直接进入编辑操作；</li><li>若属于多个组，则提示“对象是多个组的成员&lt;接受&gt;”，并提供 <code>[接受(A)/下一个(N)]</code> 选项，用户可循环切换高亮不同的组，直到确认目标组。</li></ul><p>如果用户选择 <code>[名称(N)]</code> 模式，则进入按名称编辑流程：</p><ul><li>提示“输入组的名称”，并支持 <code>[查询(A)]</code> 关键字；</li><li>输入 <code>A</code> 后可查看所有组名（输入 <code>*</code>）或查询特定组是否存在；</li><li>输入有效组名后，若组存在，则加载并高亮其成员，进入编辑；若不存在，则提示“编组 xxx 不存在”，并允许重新输入。<br/>确定目标组后，系统弹出操作菜单：<code>[添加对象(A)/删除对象(R)/重命名(REN)]</code>。</li><li><strong>添加对象（A）</strong>：用户可通过单击或框选方式选择要加入的对象。系统会动态高亮预览可添加的对象（不包括已存在于组内的对象），支持窗口和交叉选择，完成后将所选对象追加到组中，并提示“添加对象成功！”。</li><li><strong>删除对象（R）</strong>：用户选择组内对象进行移除。系统仅允许删除当前组中的成员，选择后会从组中剔除这些对象，并通过清空后重新添加剩余对象的方式更新组内容。</li><li><p><strong>重命名（REN）</strong>：提示用户输入新名称。支持再次使用 <code>[查询(A)]</code> 查看现有组名以避免冲突。若新名称已被其他组使用，则提示“编组 xxx 已经存在”并要求重新输入；否则更新组名，并提示“修改组名成功”。<br/>实现上述流程的具体功能代码如下：</p><pre><code class="ts">import { McDbEntity, McDbGroup, McDbPolyline, McGePoint3d, McObjectId, MxCADSelectionSet, MxCADUiPrKeyWord, MxCADUiPrPoint, MxCADUiPrString, MxCADUtility, MxCpp } from "mxcad";
import { DetailedResult, MxFun, MrxDbgUiPrBaseReturn } from "mxdraw";
// 编辑组
async function Mx_Groupedit() {
    const ents: McDbEntity[] = [];//高亮实体数组
    let groupArr: GroupObject[] = [];//实体组集合
    let index: number = 0;
    let name: string = '';
    const database = MxCpp.getCurrentDatabase();
    const groupDict = database.GetGroupDictionary();
    const mxcad = MxCpp.getCurrentMxCAD();
    const editGroup = async () =&gt; {
        // 选中目标组
        if (groupArr.length === 1) {
            name = groupArr[0].name
        } else if (groupArr.length &gt; 1) {
            while (true) {
                const getKeys = new MxCADUiPrKeyWord();
                getKeys.setMessage('对象是多个组的成员&lt;接受&gt;')
                getKeys.setKeyWords(`[接受(A)/下一个(N)]`);
                let key = await getKeys.go();
                if (key === "A") {
                    name = groupArr[index].name;
                    break;
                } else if (key === "N") {
                    ents.forEach(ent =&gt; ent.highlight(false));
                    ents.length = 0;
                    index + 1 &gt; groupArr.length - 1 ? index = 0 : index += 1;
                    const res = groupArr[index];
                    res.group.getAllEntityId().forEach(id =&gt; {
                        const ent = id.getMcDbEntity();
                        ent.highlight(true);
                        ents.push(ent);
                    });
                    continue;
                } else {
                    continue;
                }
            }
        } else {
            name = '';
        }
        // 操作目标组
        if (name) {
            const groupId = groupDict.getAt(name)
            const group = groupId.getMcDbObject() as McDbGroup
            if (group) {
                // 进入编辑组
                const getKey = new MxCADUiPrKeyWord();
                getKey.setMessage(t('输入选项'));
                getKey.setKeyWords(`[添加对象(A)/删除对象(R)/重命名(REN)]`);
                const key = await getKey.go();
                if (!key) return;
                if (key === 'A') {
                    const selectIds: McObjectId[] = [];
                    // 添加对象
                    while (true) {
                        const getEntityPt = new MxCADUiPrPoint();
                        getEntityPt.setMessage('选择要添加到编组的对象');
                        getEntityPt.setDisableOsnap(true);
                        getEntityPt.setDisableDynInput(true);
                        getEntityPt.disableAllTrace(true);
                        const hoverSelectEnts: McDbEntity[] = [];
                        getEntityPt.setUserDraw((pt, pw) =&gt; {
                            if (hoverSelectEnts.length) hoverSelectEnts.forEach(ent =&gt; {
                                if (!ents.map(i =&gt; i.getObjectID().id).includes(ent.getObjectID().id)) ent.highlight(false);
                            });
                            hoverSelectEnts.length = 0;
                            const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
                            if (entId.isValid() &amp;&amp; !selectIds.map(item =&gt; item.id).includes(entId.id) &amp;&amp; !group.has(entId)) {
                                const ent = entId.getMcDbEntity();
                                const arr = getGroupForEntity(ent);
                                if (arr.length) {
                                    const group = arr[0].group;
                                    group.getAllEntityId().forEach(id =&gt; {
                                        const ent = id.getMcDbEntity();
                                        ent.highlight(true);
                                        hoverSelectEnts.push(ent)
                                    })
                                } else {
                                    ent.highlight(true);
                                    hoverSelectEnts.push(ent)
                                }
                            }
                        });
                        const pt = await getEntityPt.go();
                        if (!pt) {
                            if (hoverSelectEnts.length) hoverSelectEnts.forEach(item =&gt; item.highlight(false));
                            break;
                        } else {
                            // 判断是否选中实体
                            if (hoverSelectEnts.length) {
                                if (hoverSelectEnts.length) {
                                    hoverSelectEnts.forEach(ent =&gt; {
                                        selectIds.push(ent.getObjectID());
                                    })
                                };
                            } else {
                                getEntityPt.setUserDraw((point, pw) =&gt; {
                                    const pts = [pt, new McGePoint3d(pt.x, point.y), point, new McGePoint3d(point.x, pt.y)]
                                    // 设置范围框颜色即位置
                                    let pl = new McDbPolyline();
                                    pl.isClosed = true;
                                    pts.forEach(pt =&gt; pl.addVertexAt(pt));
                                    pw.setColor(0xFFFFFF);
                                    pw.drawMcDbEntity(pl);
 
                                    // 动态绘制矩形填充框
                                    const geometry = new THREE.BufferGeometry();
                                    geometry.setFromPoints([
                                        new THREE.Vector3(pt.x, pt.y, pt.z),
                                        new THREE.Vector3(pt.x, point.y, point.z),
                                        new THREE.Vector3(point.x, point.y, point.z),
                                        new THREE.Vector3(point.x, pt.y, pt.z)
                                    ]);
                                    geometry.attributes.uv = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), 2);
                                    geometry.setIndex([0, 1, 2, 0, 2, 3]);
                                    // 创建材质（半透明的颜色）
                                    const material = new THREE.MeshBasicMaterial({
                                        color: 0x004D00,
                                        transparent: true,
                                        opacity: 0.5,
                                        side: THREE.DoubleSide
                                    });
                                    const mesh = new THREE.Mesh(geometry, material);
                                    pw.drawEntity(mesh);
                                });
                                const nextPt = await getEntityPt.go();
                                if (!nextPt) break;
                                const ss = new MxCADSelectionSet();
                                await ss.crossingSelect(pt.x, pt.y, nextPt.x, nextPt.y);
                                ss.forEach(id =&gt; {
                                    if (!group.has(id) &amp;&amp; !selectIds.map(i =&gt; i.id).includes(id.id)) {
                                        const ent = id.getMcDbEntity();
                                        const arr = getGroupForEntity(ent);
                                        if (arr.length) {
                                            const group = arr[0].group;
                                            group.getAllEntityId().forEach(id =&gt; {
                                                id.getMcDbEntity()?.highlight(true);
                                                selectIds.push(id);
                                            })
                                        } else {
                                            id.getMcDbEntity()?.highlight(true);
                                            selectIds.push(id);
                                        }
                                    }
                                });
                            };
                            continue;
                        }
                    };
                    if (selectIds.length) {
                        selectIds.forEach(id =&gt; {
                            id.getMcDbEntity().highlight(false);
                            group.append(id);
                        });
                        MxPluginContext.useMessage().success('添加对象成功！');
                    }
                } else if (key === 'R') {
                    const selectIds: McObjectId[] = [];
                    while (true) {
                        const getEntityPt = new MxCADUiPrPoint();
                        getEntityPt.setMessage('选择要从编组中删除的对象');
                        getEntityPt.setDisableOsnap(true);
                        getEntityPt.setDisableDynInput(true);
                        getEntityPt.disableAllTrace(true);
                        const hoverSelectEnts: McDbEntity[] = [];
                        getEntityPt.setUserDraw((pt, pw) =&gt; {
                            const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
                            hoverSelectEnts.forEach(e =&gt; {
                                if (!group.has(e.getObjectID())) {
                                    e.highlight(false)
                                }
                            });
                            hoverSelectEnts.length = 0;
                            if (entId.isValid() &amp;&amp; !selectIds.map(i =&gt; i.id).includes(entId.id)) {
                                const ent = entId.getMcDbEntity();
                                ent.highlight(true);
                                hoverSelectEnts.push(ent)
                            }
                        });
                        const pt = await getEntityPt.go();
                        if (!pt) {
                            break;
                        } else {
                            // 判断是否选中实体
                            if (hoverSelectEnts.length) {
                                hoverSelectEnts.forEach(ent =&gt; {
                                    ent.highlight(false);
                                    if (group.has(ent.getObjectID())) {
                                        selectIds.push(ent.getObjectID())
                                    } else {
                                        MxFun.acutPrintf('对象不是组内元素，无法删除')
                                    }
                                })
                            } else {
                                getEntityPt.setUserDraw((point, pw) =&gt; {
                                    const pts = [pt, new McGePoint3d(pt.x, point.y), point, new McGePoint3d(point.x, pt.y)]
                                    // 设置范围框颜色即位置
                                    let pl = new McDbPolyline();
                                    pl.isClosed = true;
                                    pts.forEach(pt =&gt; pl.addVertexAt(pt));
                                    pw.setColor(0xFFFFFF);
                                    pw.drawMcDbEntity(pl);
 
                                    // 动态绘制矩形填充框
                                    const geometry = new THREE.BufferGeometry();
                                    geometry.setFromPoints([
                                        new THREE.Vector3(pt.x, pt.y, pt.z),
                                        new THREE.Vector3(pt.x, point.y, point.z),
                                        new THREE.Vector3(point.x, point.y, point.z),
                                        new THREE.Vector3(point.x, pt.y, pt.z)
                                    ]);
                                    geometry.attributes.uv = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), 2);
                                    geometry.setIndex([0, 1, 2, 0, 2, 3]);
                                    // 创建材质（半透明的颜色）
                                    const material = new THREE.MeshBasicMaterial({
                                        color: 0x004D00,
                                        transparent: true,
                                        opacity: 0.5,
                                        side: THREE.DoubleSide
                                    });
                                    const mesh = new THREE.Mesh(geometry, material);
                                    pw.drawEntity(mesh);
                                });
                                const nextPt = await getEntityPt.go();
                                if (!nextPt) break;
                                const ss = new MxCADSelectionSet();
                                await ss.crossingSelect(pt.x, pt.y, nextPt.x, nextPt.y);
                                ss.forEach(id =&gt; {
                                    if (group.has(id)) {
                                        const ent = id.getMcDbEntity();
                                        ent.highlight(false);
                                        selectIds.push(ent.getObjectID());
                                    }
                                });
                            };
                            continue;
                        }
                    };
                    if (selectIds.length) {
                        const newIds = ents.filter(ent =&gt; !selectIds.map(i =&gt; i.id).includes(ent.getObjectID().id)).map(ent =&gt; ent.getObjectID());
                        group.clear();
                        group.appendArray(newIds);
                    }
                } else if (key === 'REN') {
                    while (true) {
                        const getName = new MxCADUiPrString()
                        getName.setMessage("输入组的新名称" + `&lt;${group.name}&gt;`)
                        getName.setKeyWords('查询(A)]')
                        const str = await getName.go();
                        if (getName.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
                            if (getName.isKeyWordPicked("A")) {
                                getName.setMessage("请输入要列出的编码组名" + "&lt;*&gt;")
                                const name = await getName.go();
                                if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                                    if (name &amp;&amp; name !== "*") {
                                        const groupId = groupDict.getAt(name)
                                        const group = groupId.getMcDbObject() as McDbGroup
                                        MxFun.acutPrintf('定义的编组')
                                        if (group) {
                                            MxFun.acutPrintf(`\n${group.name}`)
                                        }
                                    } else if (name === "*") {
                                        const groupIds = groupDict.getAllObject()
                                        MxFun.acutPrintf(`\n 定义的编组:`)
                                        groupIds.forEach((groupId) =&gt; {
                                            const group = groupId.getMcDbObject() as McDbGroup
                                            group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                                        })
                                    }
                                } else {
                                    const groupIds = groupDict.getAllObject()
                                    MxFun.acutPrintf(`\n 定义的编组:`)
                                    groupIds.forEach((groupId) =&gt; {
                                        const group = groupId.getMcDbObject() as McDbGroup
                                        group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                                    })
                                }
                                continue;
                            }
                        } else if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                            const groupId = groupDict.getAt(str)
                            const _group = groupId.getMcDbObject() as McDbGroup
                            if (_group &amp;&amp; groupId.isValid()) {
                                MxFun.acutPrintf(`编组 ${str} 已经存在}`);
                                continue;
                            } else {
                                group.name = str;
                                MxPluginContext.useMessage().success('修改组名成功');
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }
            } else {
                MxPluginContext.useMessage().success('对象不是组成员');
            }
        }
        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
        mxcad.updateDisplay();
    }
    const getEnt = new MxCADUiPrEntity();
    getEnt.setMessage('选择组');
    getEnt.setKeyWords('[名称(N)]');
    getEnt.setUserDraw((pt, pw) =&gt; {
        ents.forEach(ent =&gt; ent.highlight(false));
        ents.length = 0;
        const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
        if (entId.isValid()) {
            const ent = entId.getMcDbEntity();
            groupArr = getGroupForEntity(ent);
            if (groupArr.length) {
                const group = groupArr[index].group;
                group.getAllEntityId().forEach(id =&gt; {
                    const entity = id.getMcDbEntity();
                    entity.highlight(true);
                    ents.push(entity);
                })
            }
        }
    });
    const entId = await getEnt.go();
    if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
        if (getEnt.isKeyWordPicked('N')) {
            // 选择关键字
            while (true) {
                const getName = new MxCADUiPrString()
                getName.setMessage("输入组的名称")
                getName.setKeyWords('[查询(A)]')
                const str = await getName.go();
                if (getName.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
                    if (getName.isKeyWordPicked("A")) {
                        getName.setMessage("请输入要列出的编码组名" + "&lt;*&gt;")
                        getName.setKeyWords("")
                        const name = await getName.go();
                        if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                            if (name &amp;&amp; name !== "*") {
                                const groupId = groupDict.getAt(name)
                                const group = groupId.getMcDbObject() as McDbGroup
                                MxFun.acutPrintf('定义的编组')
                                if (group) {
                                    MxFun.acutPrintf(`\n${group.name}`)
                                }
                            } else if (name === "*") {
                                const groupIds = groupDict.getAllObject()
                                MxFun.acutPrintf(`\n 定义的编组:`)
                                groupIds.forEach((groupId) =&gt; {
                                    const group = groupId.getMcDbObject() as McDbGroup
                                    group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                                })
                            }
                        } else {
                            const groupIds = groupDict.getAllObject()
                            MxFun.acutPrintf(`\n 定义的编组:`)
                            groupIds.forEach((groupId) =&gt; {
                                const group = groupId.getMcDbObject() as McDbGroup
                                group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                            })
                        }
                        continue;
                    }
                } else if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                    const groupId = groupDict.getAt(str)
                    const group = groupId.getMcDbObject() as McDbGroup
                    if (group &amp;&amp; groupId.isValid()) {
                        group.getAllEntityId().forEach(id =&gt; {
                            const ent = id.getMcDbEntity();
                            ent.highlight(true);
                            ents.push(ent);
                        })
                        groupArr.push({ name: group.name, group });
                        editGroup()
                        break;
                    } else {
                        MxFun.acutPrintf(`编组 ${str} 不存在`);
                        continue;
                    };
                } else {
                    break;
                }
            }
        }
    } else if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
        editGroup();
    } else {
        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
    }
}</code></pre></li></ul><h3>4. 启用或禁用组选择</h3><p>启用指定对象组的选择功能其执行过程如下：首先提示用户“请选择目标组”，并在鼠标悬停时自动检测光标下的对象，若该对象属于某个组，则实时高亮显示该组的所有成员，提供可视化反馈。用户点击对象后，系统获取其所属的第一个组，并将该组的 <code>isSelectable</code> 属性设置为 <code>true</code>，从而允许后续通过点击组内任意成员来选中整个组。最后清除高亮并刷新显示，完成设置。该方法提升了组对象的操作便捷性，适用于需要快速选中成组元素的场景。其完整代码如下：</p><pre><code class="ts">import { MxCADUiPrEntity, MxCADUtility, MxCpp} from "mxcad";
// 启用/禁用组选择
async function Mx_SetGroupSelection() {
    const ents: McDbEntity[] = [];
    let groupArr: GroupObject[] = [];
    const getEnt = new MxCADUiPrEntity();
    getEnt.setMessage('请选择目标组');
    getEnt.setUserDraw((pt, pw) =&gt; {
        ents.forEach(ent =&gt; ent.highlight(false));
        ents.length = 0;
        const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
        if (entId.isValid()) {
            const ent = entId.getMcDbEntity();
            groupArr = getGroupForEntity(ent);
            if (groupArr.length) {
                const group = groupArr[0].group;
                group.getAllEntityId().forEach(id =&gt; {
                    const entity = id.getMcDbEntity();
                    entity.highlight(true);
                    ents.push(entity);
                })
            }
        }
    });
    const entId = await getEnt.go();
    if (groupArr.length) {
        const group = groupArr[0].group;
        group.isSelectable = true;
        ents.forEach(ent =&gt; {
            ent.highlight(false);
        })
        MxCpp.getCurrentMxCAD().updateDisplay();
    };
}</code></pre><h2>三、功能演示</h2><p><img width="723" height="478" referrerpolicy="no-referrer" src="/img/bVdm22b" alt="" title=""/></p>]]></description></item><item>    <title><![CDATA[WeaveFox「AI 艺术家」创意大赛]]></title>    <link>https://segmentfault.com/a/1190000047399892</link>    <guid>https://segmentfault.com/a/1190000047399892</guid>    <pubDate>2025-11-14 16:08:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着AI时代的到来，天马行空的灵感可以快速变为现实。11月13日，由 <strong>WeaveFox 与 SEE Conf 联合发起的「AI艺术家」创意大赛</strong> 重磅来袭！这是一场属于创作者的挑战：你可以用一句自然语言、一张设计稿、一个灵感，在几分钟内，让 AI Coding 把你的想法变成现实。</p><p>参与大赛投稿评选，不仅有价值千元豪礼相送，更能直接解锁一票难求的 SEE Conf入场资格！这一次，我们不要“空想家”，只要敢动手的“你” ——<strong>用 WeaveFox 将灵感变为现实，“你”就是下一个被看见的「AI 艺术家」！</strong></p><p><img width="723" height="424" referrerpolicy="no-referrer" src="/img/bVdm22g" alt="网页-深1112.jpg" title="网页-深1112.jpg"/></p><blockquote>为什么不容错过？</blockquote><p>✅ 顶流入场券：SEE Conf 门票售罄？邀请好友参赛就能免费得！<br/>SEE Conf是什么？是前端人每年必蹲抢破头的年度技术盛宴，今年门票更是早早售罄！这里汇聚诸多大厂技术专家，前沿框架、实战经验、行业洞见。</p><p>参与本次大赛，成功邀请 10 位好友投稿就能直接获赠 SEE Conf 门票！优秀作品更将直接登上 WeaveFox 首页参与点赞排行，你的创意不仅可能收获千元大奖，更有机会被行业大咖“翻牌”！</p><p><a href="https://link.segmentfault.com/?enc=rJ3WwfdtAdDl0u4zXjkFCQ%3D%3D.JnWzyQkWVsLANPWXuA%2FHYKfD1O%2FfZLkMbsufTJn4wes%3D" rel="nofollow" target="_blank">点击查看 SEE Conf 2025 蚂蚁终端体验科技大会详情</a></p><p>✅ 零门槛创作：WeaveFox 帮你扫清所有障碍<br/>不会写代码？没关系！没有设计经验？不影响！WeaveFox 帮你轻松越过这些门槛 ！</p><p>输入“帮我做一个能记录学习计划的 AI 小工具”，或是上传一张想要实现的设计图，WeaveFox 会帮你完成设计到开发的全链路、直接生成可上线的应用，快速将 “灵感变为现实”，让每个人都能享受创作的快感。</p><p>✅ 丰厚奖品：豪礼+荣誉双丰收<br/>参赛即有机会拿奖，福利拉满！不用担心“陪跑”，你的每一份创意都有价值：</p><p>1、人气奖（Top 7）：点赞数 TOP7 将获价值 700- 1800 元梯度豪礼，从数码周边到实用好物，实力宠粉不手软；<br/>2、创意奖（5名）：组委会实名pick“脑洞王者”，赠送价值600元的新秀丽双肩包，出门自带“技术潮人”标识；<br/>3、邀请奖（敲重点）：成功邀请10位好友投稿，直接解锁 价值近 200元的 SEE Conf 限量门票！和前端大神面对面，机会不容错过！</p><blockquote>参赛全攻略：轻松争大奖</blockquote><p>📌 关键时间：敲黑板，别错过<br/>报名开启：2025年11月13日 10:00<br/>作品截止：2025年11月23日 23:59（10天创作期，足够你打磨灵感）<br/>奖品发放：2025年12月底，以官方通知为准</p><p>📌 投稿规则：创意无限（可以任选以下推荐主题进行创作）<br/>1、推荐主题：我的AI小帮手：比如“AI 问答机器人"，"AI 翻译小帮手等”。用AI应用解决你的日常痛点；<br/>2、推荐主题：经典复刻：用AI还原童年小游戏（如贪吃蛇、俄罗斯方块），或是复刻一款你喜欢的经典应用，玩出复古新花样。</p><p>📌投稿方式：一键投稿，如此方便<br/>1、登录 WeaveFox 官网（<a href="https://link.segmentfault.com/?enc=KR4wBgJaDpi1a8E9cKMACA%3D%3D.JqxGOLWkFmMm4w0C4BIBSRokh098JzGKrvb4rYz0NL6wlSyDbW2Tjh6Y2xkKHv5k" rel="nofollow" target="_blank">https://www.weavefox.cn/?ref=seeconf/</a>）；<br/>2、用 WeaveFox 将你的创意生成应用，围绕主题调试并优化。<br/>3、在作品详情页-&gt;点击“投稿到SEE Conf「AI艺术家」创意大赛”，或在活动弹窗选择作品-&gt;立即投稿，审核通过后，即可视为参赛成功！</p><p>进入大会官网  <a href="https://link.segmentfault.com/?enc=BOMvu6SPinxcCOMFK%2F62zQ%3D%3D.fuHpLWo1CZ%2FU9vytv%2FoX8OYJJXtnLI9jr8FalwrjwJ8%3D" rel="nofollow" target="_blank">https://seeconf.antgroup.com</a>，或登录 WeaveFox 直接投稿到创意大赛 ：<a href="https://link.segmentfault.com/?enc=6HG5pDRRGLaEqmXpgjWK1w%3D%3D.ZuzoA5q9MjCUNGWX2cVbcTkMfsHk5PkHo92iaFBNvoi1XIxpqUvN6RL%2Blj4oZykk" rel="nofollow" target="_blank">https://www.weavefox.cn/?ref=seeconf</a> ，立即参与吧！</p>]]></description></item><item>    <title><![CDATA[重磅巨制！以数字孪生之名，敬国之重器：福]]></title>    <link>https://segmentfault.com/a/1190000047399899</link>    <guid>https://segmentfault.com/a/1190000047399899</guid>    <pubDate>2025-11-14 16:08:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>11月5日，我国完全自主设计建造的首艘电磁弹射型航空母舰“福建舰”正式入列，标志着中国海军迈入三航母时代。平直通长飞行甲板、电磁弹射技术、8万余吨排水量，福建舰作为全球首艘采用常规动力电磁弹射技术的航母，正式入列开启中国海军新征程。</p><p>当福建舰身披海军军旗正式入列的那一刻，中华儿女的热血与自豪在南海之滨激荡。作为军事仿真技术领域的践行者，我们深知，国之重器的高光时刻不仅是钢铁与火焰的交响，更需要以科技为笔，在数字空间镌刻下属于中国海军的时代印记。</p><p>在这个伟大时代，我们选择以手中最前沿的数字孪生技术，向国之重器致以最崇高的敬意。</p><h2>数字铸舰，复刻雄师：福建舰航母编队数字孪生</h2><p>我们将 航母编队在 万里海疆的壮阔景象浓缩于方寸屏幕之间，通过高精度建模与实时仿真，一钉一铆地构建起这个虚拟编队，从甲板防滑纹路的精确模拟，到舰载机起降轨迹的实时渲染，每一个细节都力求还原真实世界的物理特性与作战逻辑。将福建舰及其完整编队呈现在虚拟海洋环境中，可近距离体验这一现代海军力量的核心要素。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2YL" alt="" title=""/><br/>这不仅仅是一次技术展示，更是大国力量在数字空间的真实绽放，它让每一位观者都能直观感受到中国海军迈向深蓝的坚定步伐。希望通过这个应用，将福建舰的先进性与国家强大的自豪感，传递给每一位关心国防事业的同胞，激发起更深厚的爱国情怀。</p><h4>福建舰 航母编队：体系化远洋攻防作战集群</h4><p><strong>福建舰航母编队绝非单一装备的简单拼凑，而是我国首款实现 “电磁弹射 + 隐身舰载机 + 固定翼预警机” 三位一体的体系化远洋作战集群</strong>。它开创了中国海军 “感知 - 指挥 - 打击 - 保障” 全链条自主可控的先河，每个成员都承载着 “首次突破” 的历史使命，以独有的开创性技术与定位，共同构筑起攻防兼备、远域慑止的深蓝雄师，标志着中国海军彻底迈入 “体系化远洋作战” 的新时代。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2YM" alt="" title="" loading="lazy"/><br/>在数字孪生系统中，当我们把视角聚焦南海深蓝，可以看到福建舰编队构筑起一个立体的攻防体系，其威慑范围充分体现了现代海战的战略纵深。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2YN" alt="" title="" loading="lazy"/><br/>1.<strong>“同心圆防御体系”</strong>：编队的感知体系，舰艇雷达 与 空警-600 预警机 共同编织了一张探测半径超1000公里的多维感知网，构筑起最外围的防空反导预警圈。<br/><img width="723" height="405" referrerpolicy="no-referrer" src="/img/bVdm2YO" alt="" title="" loading="lazy"/><br/>2.<strong>“空海协同打击圈”</strong>：在打击范围方面，导弹与舰载机火力交织，空海协同，将编队的有效控制与精确打击半径向前显著推进，打击半径足以覆盖西太平洋第二岛链。<br/><img width="723" height="414" referrerpolicy="no-referrer" src="/img/bVdm2YQ" alt="" title="" loading="lazy"/><br/>这意味着，福建舰编队不仅能在南海维护国家利益，还能在更广阔的远洋环境中执行威慑与干预任务，确保区域安全稳定。这种覆盖范围的扩展，绝非简单的距离叠加，而是体系化作战能力的体现。</p><h2>钢铁矩阵：编队核心装备“解密”</h2><h3>01海域 护航编队</h3><h4>“定海神针” 福建舰：自主可控，铸就大国航母新标杆</h4><p><strong>在世界航母发展史上，福建舰开创了 “常规动力 + 电磁弹射” 的全新技术路径，成为全球首艘采用这一组合的航空母舰。</strong><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y2" alt="" title="" loading="lazy"/><br/>福建舰满载排水量超过8万吨的电磁弹射航母，是我国目前吨位最大的航母，也是亚洲最大的常规动力航母，舰体设计首次实现 “平直通长甲板 + 小型化隐身舰岛” 的优化组合，3 条电磁弹射轨道与新型电磁拦阻系统配套，可适配从 歼 - 35 隐身战机 到 空警 - 600 预警机 的全谱系舰载机，其三部电磁弹射器可同时准备弹射作业，实现了舰载机起降效率的质的飞跃，开创了我国航母 “高效战力投送” 的新方式。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y5" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y6" alt="" title="" loading="lazy"/><br/>在整个航母编队体系中，福建舰是集机动部署、指挥控制、战力投送于一体的体系中枢，可实现对水上、水下、空中多维度目标的实时监控与数据融合，并将指挥指令精准传递至编队各舰艇、战机，实现 “一点发现、全网共享、协同打击” 的体系化作战模式。从战术层面看，福建舰既是舰载机的起降平台，也是编队的 “大脑” 与 “神经中枢”，其存在让分散的舰艇、战机形成有机整体，释放出体系化作战的最大效能。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y8" alt="" title="" loading="lazy"/></p><h4>“带刀护卫” 055 型驱逐舰：中国首款 万吨级 防空驱逐舰</h4><p><strong>055 型驱逐舰 是中国海军第四代导弹驱逐舰，我国首款满载排水量突破 1.2 万吨的大型驱逐舰，更是全球首款将综合射频系统与万吨体量完美融合的防空反舰核心舰，开创了中国海军 “大吨位、强火力、高智能” 的驱逐舰发展方向。</strong><br/>055 型驱逐舰 是 编队防空指挥所和全能护卫，利用先进双波段雷达系统与导弹系统，构筑起坚实的区域防空拦截线，不仅能有效保护航母的安全，更可凭借其强大的独立作战能力，率领其他舰艇组成独立编队，组织多目标拦截作战，其垂直发射系统可携带多种导弹，形成远、中、近三层攻防火力配系。是守护核心、拓展火力的 “全能卫士”，其技术水平与综合战力位居全球同类型驱逐舰前列。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Ze" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zf" alt="" title="" loading="lazy"/></p><h4>“水下利刃” 093 攻击核潜艇：中国首款静音型攻击核潜艇</h4><p><strong>093 型攻击核潜艇 是我国首款 具备现代化静音作战能力 的攻击核潜艇，更是首款专为航母编队配套设计的水下先锋，开创了中国海军 “深海隐蔽护航” 的作战模式。</strong><br/>093 型攻击核潜艇是编队的水下护航力量。采用先进降噪技术，具备在大洋深处隐蔽航行与待机的能力，在探测与火力方面，093 型攻击核潜艇可精准锁定远距离敌方潜艇与水面舰艇，并能在水下隐蔽状态下实施突然打击，成为编队前方与侧翼的 “水下警戒哨” 和 “突击利刃”让福建舰编队首次具备了远海水下反潜与反舰的体系化能力，填补了我国航母编队水下防御的空白，构筑起 “水面 - 空中 - 水下” 三位一体的立体防护网。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zi" alt="" title="" loading="lazy"/></p><h4>“远洋粮仓” 905 型综合补给舰：中国首款航母专用补给舰</h4><p><strong>905 型综合补给舰是我国首款具备大规模远洋补给能力的综合补给舰，更是首款实现海军编队 “远海伴随保障” 的专用补给平台，开创了中国海军 “告别近岸、走向深蓝” 的保障新纪元。</strong><br/>905 型综合补给舰是编队的 “续航基石”，满载排水量约 2.1 万吨，是我国首款真正意义上能支撑远海编队持续部署的补给舰，首次实现了 “燃油、弹药、食品、淡水” 多品类物资的一体化补给，能支撑航母编队在远海持续部署数月，为编队远洋存在提供了坚实的后勤支撑。作为我国远洋补给舰的 “开山之作”，905 型不仅奠定了我国海军补给舰的发展基础，更以其可靠的保障能力，成为福建舰编队驰骋深蓝的 “续航基石”。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zk" alt="" title="" loading="lazy"/></p><h3>02空中 舰载机联队</h3><h4>“制空利刃” 歼 - 35 舰载战斗机：中国首款舰载隐身战斗机</h4><p><strong>歼 - 35 是我国首款自主研发的舰载隐身战斗机，更是全球首款适配常规动力电磁弹射航母的第五代舰载机，开创了中国海军 “隐身制空” 的作战新纪元。</strong><br/>歼 - 35 是编队隐身突防的“尖刀”，具备在现代防空体系中隐蔽突防的能力，让福建舰编队首次具备了隐身突防与制空权争夺的绝对优势。在性能与适配性上，它首次实现了 “隐身 + 多任务” 的完美平衡，内置弹舱可携带 PL-15 中远程空空导弹、小型反舰导弹与精确制导炸弹，既能夺取制空权，又能实施对海对地精确打击；同时首次适配福建舰的电磁弹射系统，可实现满油满弹弹射起飞，作战半径超 1000 公里，与歼 - 15T 形成 “高低搭配”。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zl" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zm" alt="" title="" loading="lazy"/></p><h4>“重载先锋” 歼 - 15T 舰载战斗机：中国首款电磁弹射重型舰载战斗机</h4><p><strong>歼 - 15T 是我国首款适配电磁弹射系统的重型舰载战斗机，更是首款实现重载弹射能力的歼 - 15 改进型，开创了我国重型舰载机 “高效火力投送” 的新路径。</strong><br/>歼-15T “飞鲨” 是执行火力压制与空域控制任务的 “核心力量”，在对海打击中实施决定性精确攻击。在火力配置上，它首次实现了 “全谱系弹药适配”，能实施饱和式精确打击。作为歼 - 35 的 “黄金搭档”，它首次与隐身舰载机形成 “制空 + 打击” 的协同模式 —— 歼 - 35 夺取制空权后，歼 - 15T 凭借重载优势实施大规模火力突击，让编队的打击效能实现 “1+1&gt;2” 的倍增，彻底释放了电磁弹射技术带来的战力提升。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zp" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zr" alt="" title="" loading="lazy"/></p><h4>“海空鹰眼” 空警 - 600 预警机：开创了中国航母 “远域预警”</h4><p><strong>空警 - 600 是我国首款舰载固定翼预警机，更是亚洲首款适配电磁弹射系统的固定翼预警机，开创了中国航母 “远域预警” 的新时代。</strong><br/>空警-600固定翼预警机是航母编队的关键信息节点，让航母编队具备远海体系化空情保障能力。该机背部装有大型有源相控阵雷达，可探测数百公里外的空中与水面目标，尤其擅长捕捉低空突防的战机与掠海导弹，有效克服了地球曲率带来的探测盲区，在编队外围建立持续空中监视。在协同能力上，它首次实现与福建舰、055 型驱逐舰的数据链实时联动，能将探测到的目标数据秒级传输至编队各作战单元，同时可直接引导歼 - 35、歼 - 15T 舰载机实施超视距作战，构建起 “预警 - 指挥 - 打击” 的无缝衔接链条。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zx" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zy" alt="" title="" loading="lazy"/></p><h4>“多能支援” Z-20F 舰载直升机：中国首款专用舰载多任务直升机</h4><p><strong>Z-20F “海鹰” 是我国首款专为航母编队设计的多任务舰载直升机，更是首款实现反潜、搜救、运输一体化的舰载直升机，开创了中国海军 “舰载直升机多能化” 的新时代。</strong><br/>在航母编队体系中，Z-20F凭借其全域、全时出动能力，成为连接水面舰艇、水下力量与空中预警网络的重要节点，在任务适配性上，它首次实现 “一机多能”，既能执行水下反潜、海面搜救任务，又能承担舰艇间人员物资运输、近程侦察等支援任务，可快速响应编队多样化需求。Z-20 “海鹰” 的列装，让福建舰编队首次具备了全场景多任务支援能力，实现了 “攻防兼备、支援到位” 的体系化布局。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZB" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZC" alt="" title="" loading="lazy"/></p><h2>数字孪生内核支撑，复刻深蓝雄师全景态势</h2><p><strong>这份震撼的大国力量呈现，背后是数字冰雹全套自主研发的数字孪生底层技术支撑。</strong><br/>我们<strong>通过自研 图观 模型编辑器完成了编队全装备的超高精度构建</strong>，装备的结构、参数、外观 每一处细节都 1:1 还原真实原型，确保国之重器的细节精准度与视觉质感。在此基础上，<strong>图观 流渲染场景编辑器 构建了全域海域环境</strong>，从南海的复杂海况、洋流特征到远海的光影变化、气象模拟，全方位还原真实远洋作战场景，让航母编队有了贴合实战的部署舞台。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZD" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZE" alt="" title="" loading="lazy"/><br/>最终，<strong>通过 孪易 IOC 实现全体系动态整合</strong>，将装备部署、战术协同、动态推演融为一体。孪易 IOC 精准指挥着舰载机的弹射起飞、飞行编队的协同掠过、以及整个护航编队中每一件装备的战术位置码放与机动。不仅实现了视觉上的震撼还原，更在物理规律与战术逻辑层面，确保了整个福建舰航母编队在数字空间中均以全景态势实时呈现。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZF" alt="" title="" loading="lazy"/><br/>整个工具链体系 高效、协同运行，既实现了 国之重器 “静态复刻精准度”，又达成了 “动态推演真实感”，让数字空间中的福建舰编队，成为可感知、可交互、可推演的国之重器数字镜像。</p><h2>从“近海防御”到“远海防卫”</h2><p><strong>福建舰入列 开启 三航母时代</strong><br/><strong>福建舰交付入列，意味着中国海军正式迈入三航母时代</strong>。这套数字孪生系统，不仅是对福建舰本身的精确还原，更是对中国海军现代化进程的生动诠释。从辽宁舰的试验探索，到山东舰的自主建造，再到福建舰的技术突破，中国航母事业的每一步跨越，都印证着国家科技水平、工业实力与综合国力的全面跃升。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZL" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm22B" alt="" title="" loading="lazy"/><br/>现代航母战斗群的精髓不在于单个装备的性能堆砌，而在于体系化作战能力的生成。福建舰编队作为一个完整的作战体系，各单元通过数据链实现信息共享，形成整体作战效能。福建舰航母编队构建的 “感知 - 指挥 - 打击 - 保障” 全链条体系化力量，而这股力量的形成，标志着中国海军实现了从 “近海防御” 到 “远洋存在” 的历史性跨越。<br/>这支力量不用于炮舰外交，不谋求海上霸权，只为那句“守护万里海疆”的铮铮誓言！系统中模拟的劈波斩浪、壮阔夕阳下的航母编队，正是对中国海军走向深蓝的最美诠释。</p><h2>数字孪生，见证强军；中国海军，向海图强！</h2>]]></description></item><item>    <title><![CDATA[HarmonyOS 6.0 服务卡片实战]]></title>    <link>https://segmentfault.com/a/1190000047399918</link>    <guid>https://segmentfault.com/a/1190000047399918</guid>    <pubDate>2025-11-14 16:07:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>HarmonyOS 6.0 服务卡片实战：把「轻食刻」装进桌面，让轻断食一眼可控</h2><blockquote>本文基于HarmonyOS 6.0 ArkTS开发框架，结合轻食刻健康管理应用的服务卡片<code>Form Kit</code>开发实践，详细解析了<code>formProvider.openFormManager</code>等核心API在实际项目中的应用。通过具体代码示例和架构设计，展示了如何将复杂的健康数据以简洁直观的方式呈现在用户桌面上。</blockquote><h3>项目背景</h3><p>轻食刻是一款专注于轻断食和健康管理的应用，在日常使用中我发现用户需要频繁查看断食进度、体重变化等关键数据。为了提升用户体验，我决定利用HarmonyOS 6.0的服务卡片技术，让用户无需打开应用即可在桌面上快速获取这些信息。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399921" alt="8aaff505e95f1d0ceca9f59d658d6f1a.jpg" title="8aaff505e95f1d0ceca9f59d658d6f1a.jpg"/></p><h3>一、服务卡片技术概述</h3><h4>1.1 HarmonyOS 6.0服务卡片技术特性</h4><p>在轻食刻项目中，我充分利用了HarmonyOS 6.0服务卡片的以下技术特性：</p><ul><li><strong>Form Kit核心能力</strong>：从API version 18开始，Form Kit提供在应用内将ArkTS卡片添加到桌面的能力，极大提升了用户体验</li><li><strong>ArkTS声明式UI</strong>：采用统一的声明式开发范式，提升开发效率</li><li><strong>动态更新机制</strong>：支持定时更新和事件触发更新</li><li><strong>多样化交互</strong>：支持router、message、call三种事件类型</li><li><strong>多尺寸适配</strong>：兼容2<em>2、2</em>4、4*4等常见卡片尺寸</li><li><strong>卡片管理API</strong>：通过<code>formProvider.openFormManager</code>实现便捷的卡片管理</li><li><strong>完善的生命周期</strong>：提供完整的创建、更新、销毁等生命周期回调</li></ul><p><strong>重要说明</strong>：应用内拉起卡片管理加桌面的功能需要API version 18及以上版本支持，低于API version 18的设备无法使用此能力。</p><h4>1.2 轻食刻服务卡片功能设计</h4><p>针对轻食刻的核心使用场景，我设计了以下服务卡片功能：</p><ul><li><strong>断食状态监控</strong>：实时显示断食进度和剩余时间</li><li><strong>体重趋势展示</strong>：通过图表展示体重变化趋势</li><li><strong>水分摄入跟踪</strong>：监控每日水分摄入情况</li><li><strong>快捷操作入口</strong>：提供开始/结束断食的便捷操作</li></ul><h3>二、服务卡片架构设计</h3><h4>2.1 整体架构</h4><p>轻食刻的服务卡片架构采用分层设计：</p><pre><code>┌─────────────────┐
│   服务卡片UI层   │
│  (HealthWidget)  │
└─────────────────┘
         │
┌─────────────────┐
│   业务逻辑层     │
│ (WidgetService)  │
└─────────────────┘
         │
┌─────────────────┐
│   数据访问层     │
│   (DataDao)     │
└─────────────────┘</code></pre><h4>2.2 核心组件说明</h4><p><strong>HealthWidget</strong>：服务卡片UI组件，负责数据展示和用户交互<br/><strong>WidgetReminderService</strong>：服务卡片提醒管理服务，处理卡片生命周期和提醒逻辑<br/><strong>SettingsDao</strong>：数据持久化组件，存储卡片配置和用户数据</p><h3>三、服务卡片实现详解</h3><h4>3.1 卡片配置文件</h4><p>首先，我需要在<code>form_config.json</code>中定义服务卡片的基本属性：</p><pre><code class="json">{
  "forms": [
    {
      "name": "health_widget",
      "description": "$string:health_widget_description",
      "src": "./ets/widgets/HealthWidget.ets",
      "uiSyntax": "arkts",
      "window": {
        "designWidth": 720,
        "autoDesignWidth": true
      },
      "colorMode": "auto",
      "formConfigAbility": "ability://com.kirk.fastone.HealthFormAbility",
      "formVisibleNotify": true,
      "isDefault": true,
      "updateEnabled": true,
      "scheduledUpdateTime": "10:30",
      "updateDuration": 1,
      "defaultDimension": "2*2",
      "supportDimensions": ["2*2", "2*4", "4*4"]
    }
  ]
}</code></pre><p><strong>关键配置说明</strong>：</p><ul><li><code>scheduledUpdateTime</code>：设置定时更新时间</li><li><code>updateDuration</code>：更新间隔（小时）</li><li><code>supportDimensions</code>：支持的卡片尺寸</li></ul><h4>3.2 服务卡片UI组件</h4><p>以下是健康数据卡片的核心UI实现：</p><pre><code class="typescript">// HealthWidget.ets - 健康数据服务卡片
@Entry
@Component
export struct HealthWidget {
  @LocalStorageProp('fastingStatus') fastingStatus: FastingStatus = new FastingStatus();
  @LocalStorageProp('weightData') weightData: WeightData[] = [];
  @LocalStorageProp('waterIntake') waterIntake: number = 0;

  build() {
    Column() {
      // 断食状态区域
      this.buildFastingSection()
      
      // 体重趋势区域
      this.buildWeightSection()
      
      // 水分摄入区域
      this.buildWaterSection()
    
    }
    .width('100%')
    .height('100%')
    .padding(12)
    .backgroundColor($r('app.color.background_card'))
  }

  @Builder
  buildFastingSection() {
    Row() {
      Column({ space: 4 }) {
        Text('断食状态')
          .fontSize(12)
          .fontColor($r('app.color.text_secondary'))
        
        Text(this.fastingStatus.isFasting ? '进行中' : '未开始')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)
          .fontColor(this.fastingStatus.isFasting ? 
            $r('app.color.success') : $r('app.color.text_primary'))
        
        if (this.fastingStatus.isFasting) {
          Text(`剩余: ${this.fastingStatus.remainingTime}`)
            .fontSize(12)
            .fontColor($r('app.color.text_secondary'))
        }
      }
      .layoutWeight(1)
    }
    .width('100%')
  }
}</code></pre><h4>3.3 服务卡片提醒服务</h4><p>为了实现智能提醒功能，我设计了<code>WidgetReminderService</code>：</p><pre><code class="typescript">// WidgetReminderService.ets - 服务卡片提醒管理
/**
 * 服务卡片提醒类型
 */
export enum WidgetReminderType {
  WIDGET_ADD_REMINDER = 'widget_add_reminder', // 添加服务卡片提醒
  WIDGET_USAGE_REMINDER = 'widget_usage_reminder', // 使用服务卡片提醒
  WIDGET_UPDATE_REMINDER = 'widget_update_reminder' // 更新服务卡片提醒
}

/**
 * 服务卡片提醒管理服务
 */
export class WidgetReminderService {
  private static instance: WidgetReminderService;
  
  /**
   * 检查并触发服务卡片提醒
   */
  async checkAndTriggerWidgetReminders(): Promise&lt;void&gt; {
    try {
      const widgetStatus = await this.getWidgetStatus();
      const reminders = await this.getAllWidgetReminderSettings();
      
      for (const reminder of reminders) {
        if (reminder.enabled &amp;&amp; reminder.reminderCount &lt; reminder.maxReminders) {
          const shouldTrigger = await this.shouldTriggerReminder(reminder, widgetStatus);
          
          if (shouldTrigger) {
            await this.triggerWidgetReminder(reminder);
          }
        }
      }
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to check widget reminders: ${JSON.stringify(error)}`);
    }
  }

  /**
   * 判断是否应该触发提醒
   */
  private async shouldTriggerReminder(
    reminder: WidgetReminderSetting, 
    widgetStatus: WidgetStatus
  ): Promise&lt;boolean&gt; {
    // 检查时间间隔（至少间隔24小时）
    const now = Date.now();
    const twentyFourHours = 24 * 60 * 60 * 1000;
    if (reminder.lastReminderTime &gt; 0 &amp;&amp; (now - reminder.lastReminderTime) &lt; twentyFourHours) {
      return false;
    }

    // 根据提醒类型和条件判断
    switch (reminder.type) {
      case WidgetReminderType.WIDGET_ADD_REMINDER:
        return !widgetStatus.hasWidgetAdded &amp;&amp; widgetStatus.widgetUsageCount &gt;= 3;
        
      case WidgetReminderType.WIDGET_USAGE_REMINDER:
        return widgetStatus.hasWidgetAdded &amp;&amp; widgetStatus.widgetUsageCount &lt; 5;
        
      default:
        return false;
    }
  }
}</code></pre><h4>3.4 Form Kit卡片管理API实现</h4><h5>3.4.1 formProvider.openFormManager API应用</h5><p><strong>API版本要求</strong>：从API version 18开始，Form Kit提供在应用内将ArkTS卡片添加到桌面的能力，以方便用户后续便捷查看信息或快速进入应用。</p><p><strong>版本兼容性说明</strong>：</p><ul><li>✅ <strong>API version 18及以上</strong>：支持应用内拉起卡片管理加桌面功能</li><li>❌ <strong>API version 18以下</strong>：无法使用此能力，用户需要通过传统方式在桌面添加卡片</li></ul><p>在轻食刻项目中，我使用<code>formProvider.openFormManager</code>接口实现卡片管理功能：</p><pre><code class="typescript">// WidgetGuidePage.ets - 卡片管理页面跳转实现
private openWidgetManager(): void {
  try {
    const want: Want = {
      bundleName: 'com.kirk.fastone',
      abilityName: 'HealthFormAbility',
      parameters: {
        'ohos.extra.param.key.form_dimension': 2,
        'ohos.extra.param.key.form_name': 'widget',
        'ohos.extra.param.key.module_name': 'entry'
      },
    };
    
    // 检查API版本兼容性
    if (this.isApiVersionSupported(18)) {
      formProvider.openFormManager(want);
      console.info('WidgetGuidePage: Successfully opened form manager');
    } else {
      // API version 18以下设备的降级处理
      this.showLegacyWidgetGuide();
    }
    
  } catch (error) {
    console.error('WidgetGuidePage: Failed to open widget manager:', error);
    ToastUtil.showLong('⚠️ 暂无可用打开方式，请在桌面空白处长按，选择"服务卡片"，然后搜索"轻食刻"添加卡片');
  }
}

/**
 * 检查API版本是否支持
 */
private isApiVersionSupported(minVersion: number): boolean {
  const systemApiVersion = globalThis.system.apiVersion;
  return systemApiVersion &gt;= minVersion;
}

/**
 * 传统方式添加卡片引导
 */
private showLegacyWidgetGuide(): void {
  ToastUtil.showLong('📱 请在桌面空白处长按，选择"服务卡片"，然后搜索"轻食刻"添加卡片');
}</code></pre><p><strong>开发要点</strong>：</p><ul><li><strong>版本检查</strong>：在调用API前检查设备API版本，确保功能可用性</li><li><strong>参数配置</strong>：正确设置bundleName、abilityName等参数</li><li><strong>异常处理</strong>：完善的错误捕获和用户提示</li><li><strong>降级策略</strong>：为不支持API version 18的设备提供传统引导方式</li></ul><h5>3.4.2 卡片交互事件处理</h5><p>服务卡片支持多种交互事件，以下是事件处理的核心实现：</p><pre><code class="typescript">// 卡片内部事件处理
.onClick(() =&gt; {
  postCardAction(this, {
    action: 'router',
    abilityName: 'EntryAbility',
    params: {
      message: 'open_fasting_detail',
      targetPage: 'FastingDetailPage'
    }
  });
})

// 消息事件处理
.onClick(() =&gt; {
  postCardAction(this, {
    action: 'message',
    params: {
      message: 'toggle_fasting_status',
      actionType: this.fastingStatus.isFasting ? 'stop' : 'start'
    }
  });
})</code></pre><h3>四、关键技术点解析</h3><h4>4.1 卡片生命周期管理</h4><p>在轻食刻项目中，我通过<code>WidgetReminderService</code>实现了完整的卡片生命周期管理：</p><ul><li><strong>创建阶段</strong>：卡片首次添加到桌面时触发<code>onCreate</code>回调</li><li><strong>更新阶段</strong>：通过定时更新或事件触发更新，对应<code>onUpdate</code>回调</li><li><strong>销毁阶段</strong>：用户移除卡片时触发<code>onDestroy</code>回调</li><li><strong>可见性变化</strong>：卡片显示/隐藏时触发<code>onVisibilityChange</code>回调</li></ul><p>通过精细的生命周期管理，确保卡片状态与主应用保持同步。</p><h4>4.2 数据同步机制</h4><p>服务卡片与主应用之间的数据同步是关键挑战。我采用以下策略：</p><ol><li><strong>LocalStorage数据共享</strong>：使用<code>@LocalStorageProp</code>实现卡片与主应用数据同步</li><li><strong>定时更新机制</strong>：配置<code>scheduledUpdateTime</code>实现定时数据刷新</li><li><strong>事件触发更新</strong>：通过<code>postCardAction</code>触发即时数据更新</li></ol><h4>4.3 性能优化策略</h4><p>针对服务卡片的性能要求，我实施了以下优化措施：</p><ol><li><strong>内存优化</strong>：控制卡片UI复杂度，避免过多嵌套</li><li><strong>渲染优化</strong>：使用<code>LazyForEach</code>优化列表渲染</li><li><strong>数据优化</strong>：仅加载必要数据，控制数据更新量</li><li><strong>更新策略</strong>：合理设置更新频率，避免频繁刷新</li></ol><p>通过这些优化，轻食刻服务卡片在保证功能完整性的同时，实现了流畅的用户体验。</p><h4>4.4 用户体验设计</h4><p>在用户体验方面，我重点关注：</p><ul><li><strong>信息层级</strong>：重要信息突出显示，次要信息适当弱化</li><li><strong>交互反馈</strong>：点击操作提供明确的视觉反馈</li><li><p><strong>状态指示</strong>：使用颜色和图标清晰表示不同状态</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399922" alt="26aeaa72751409ea0554972ed7ff7948.jpg" title="26aeaa72751409ea0554972ed7ff7948.jpg" loading="lazy"/></p></li></ul><h3>五、开发实践与经验总结</h3><h4>5.1 开发流程建议</h4><p>基于轻食刻项目的开发经验，我建议采用以下开发流程：</p><ol><li><strong>需求分析</strong>：明确卡片功能定位和用户使用场景</li><li><strong>UI设计</strong>：设计简洁直观的卡片界面</li><li><strong>技术选型</strong>：选择合适的卡片尺寸和交互方式</li><li><strong>开发实现</strong>：按照HarmonyOS规范进行开发</li><li><strong>测试验证</strong>：在不同设备上测试卡片表现</li></ol><h4>5.2 开发中遇到的问题</h4><p>在轻食刻服务卡片开发过程中，我遇到了以下典型问题：</p><ul><li><p><strong>API调用失败</strong>：<code>formProvider.openFormManager</code>调用异常</p><ul><li><strong>解决方法</strong>：检查bundleName、abilityName配置，确认应用权限</li></ul></li><li><p><strong>数据同步延迟</strong>：卡片更新不及时</p><ul><li><strong>解决方法</strong>：优化数据同步机制，增加手动刷新功能</li></ul></li><li><p><strong>设备适配问题</strong>：不同设备显示效果不一致</p><ul><li><strong>解决方法</strong>：采用响应式布局，适配多种屏幕尺寸</li></ul></li><li><p><strong>交互响应延迟</strong>：卡片操作响应较慢</p><ul><li><strong>解决方法</strong>：优化事件处理逻辑，减少不必要的计算</li></ul></li></ul><h4>5.3 开发经验总结</h4><p>基于轻食刻项目的开发实践，我总结了以下经验：</p><ol><li><strong>API规范使用</strong>：正确使用<code>formProvider.openFormManager</code>等核心API</li><li><strong>代码规范</strong>：遵循HarmonyOS开发规范，保证代码质量</li><li><strong>性能优化</strong>：关注内存使用和渲染性能</li><li><strong>用户体验</strong>：以用户为中心设计交互流程</li><li><strong>测试覆盖</strong>：确保在各种场景下的稳定性</li></ol><h4>5.4 扩展能力展望</h4><p>基于HarmonyOS 6.0的服务卡片技术，未来可以进一步扩展：</p><ul><li><strong>AI健康建议</strong>：基于用户数据提供个性化健康建议</li><li><strong>社交分享</strong>：支持将健康成果分享到社交平台</li><li><strong>设备联动</strong>：与智能穿戴设备深度集成</li></ul><h4>5.5 学习方法与资源推荐</h4><p>在HarmonyOS开发过程中，开发过程中总结的一些经验：</p><ul><li><strong>文档使用</strong>：直接看API示例代码，重点关注版本更新说明</li><li><strong>问题解决</strong>：先排查基础配置，再社区求助，最后官方支持</li><li><strong>学习路径</strong>：从简单卡片开始，逐步增加复杂功能，注意版本兼容性</li><li><strong>持续学习</strong>：关注技术动态，多实践项目</li></ul><h3>六、总结</h3><p>通过轻食刻项目的服务卡片开发实践，我验证了HarmonyOS 6.0服务卡片技术的实用价值。该技术能够为用户提供便捷的信息获取方式，通过智能提醒和交互功能显著提升应用体验。</p><p>随着HarmonyOS生态的不断发展，服务卡片技术将在更多应用场景中发挥重要作用。我期待看到更多开发者利用这一技术，为用户创造更好的数字生活体验。</p><h3>参考资料</h3><h4>官方文档资源</h4><ol><li><a href="https://link.segmentfault.com/?enc=rsunEgqRds%2B7E0sJThzPZw%3D%3D.cFytr6D5AH9W7i4xs0bK0QBHbCi6U1IsJhd%2F6QUq6W8ivN%2FAHGo688CRrL5TkBf%2Fgf0esRFvWYof%2B2s9hdcvp0A8eBZfu9Y8mrtmmj5RCaQ%3D" rel="nofollow" target="_blank">HarmonyOS应用开发文档 - Form Kit服务卡片</a></li><li><a href="https://link.segmentfault.com/?enc=u%2FN%2ByXNGEsY9oqFyvF8NAQ%3D%3D.ufkJzewXNQ7uONj8LAgjlCcllS2kLOgauQzPUfWh%2FtyYBcJbVVscYDf0G0WjBsTGeCKImjvUuzHZ57S93WL6Mx2YUuCG3OkiFwFoh8P0tWfBacYEJLBcp1diRSMd4Q12" rel="nofollow" target="_blank">轻食刻 - 欢迎体验</a></li></ol><hr/><p><em>本文基于HarmonyOS 6.0和轻食刻项目v1.0.1版本编写，所有代码示例均经过实际测试验证。</em></p><h3>结语：为鸿蒙生态贡献力量</h3><p>通过轻食刻服务卡片的开发实践，我深刻体会到HarmonyOS作为新一代智能终端操作系统的强大技术实力和生态价值。作为一名鸿蒙开发者，我深感荣幸能够参与到这个充满活力的生态建设中。</p>]]></description></item><item>    <title><![CDATA[解决“Move to iOS 卡在准备中]]></title>    <link>https://segmentfault.com/a/1190000047399937</link>    <guid>https://segmentfault.com/a/1190000047399937</guid>    <pubDate>2025-11-14 16:06:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>从安卓换到 iPhone 时，是否也遇到了“Move to iOS 卡在准备中”的问题？别担心，你并不孤单。这个问题通常由 Wi-Fi 不稳定或传输数据过多引起。下面我们将提供 9 种快速解决方案，帮助你顺利完成数据传输。首先，我们来了解一下“准备中”通常需要多长时间。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399939" alt="图片" title="图片"/></p><p>为什么 iPhone 准备传输需要那么久？</p><pre><code>Wi-Fi 信号弱——请确保连接稳定。
数据量过大——请耐心等待，或分批传输。
后台应用干扰——关闭所有后台程序。
系统版本过旧——请更新两部设备。
连接异常——可尝试开关蓝牙/Wi-Fi。
iPhone 存储空间不足——请清理空间。

</code></pre><h3>第一部分：Move to iOS 准备阶段通常需要多久？</h3><p>Move to iOS 是苹果官方提供的安卓到 iPhone 数据迁移工具。准备阶段所需时间取决于你的 Wi-Fi 网络状况和传输的数据量。如果 Wi-Fi 信号较弱或数据量较大，准备过程可能需要 1 小时甚至更久。在某些情况下，“准备中”是正常现象，建议耐心等待。但如果时间过长，建议使用以下方法进行排查和修复。</p><h3>第二部分：解决“Move to iOS 卡在准备中”的 9 种方法</h3><p>方法 1：保持设备靠近</p><p>使用无线传输时，请将两部设备保持在 5–15 英尺（约 1.5–4.5 米） 范围内。距离过远可能导致传输失败或卡在“准备中”。</p><p>方法 2：检查 Move to iOS 的兼容性</p><pre><code>安卓设备需运行 Android 4.0 及以上版本
iPhone 需运行 iOS 9.0 及以上版本
确保两部设备连接至 同一个 Wi-Fi 网络
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399940" alt="图片" title="图片" loading="lazy"/></p><p>方法 3：检查 Wi-Fi 连接</p><p>如果反复出现“Move to iOS 准备中卡住”，请先检查路由器，并尝试打开其他网页或应用测试网络是否稳定。<br/>如网络异常，请重新连接 Wi-Fi 或重启路由器。<br/>你也可以尝试重置 iPhone 网络设置：<br/>设置 &gt; 通用 &gt; 传输或还原 iPhone &gt; 还原 &gt; 还原网络设置</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399941" alt="图片" title="图片" loading="lazy"/></p><p>方法 4：关闭“连接优化器”（Connections Optimizer）</p><p>安卓 8.0 及以上系统可能自动切换 Wi-Fi 和移动网络，建议关闭：</p><pre><code>进入 设置 &gt; 连接 &gt; 移动网络 &gt; 连接优化器
关闭“连接优化器”开关

</code></pre><p>方法 5：关闭“智能网络切换”（Smart Network Switch）</p><p>安卓 4.3 及以上系统可能启用“智能网络切换”，请关闭：</p><pre><code>打开 设置 &gt; Wi-Fi
点击右上角“更多”或“菜单”按钮
选择“智能网络切换”并取消勾选
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399942" alt="图片" title="图片" loading="lazy"/></p><p>方法 6：检查 iPhone 存储空间</p><pre><code>进入 设置 &gt; 通用 &gt; iPhone 存储空间
查看可用空间是否充足（灰色部分为剩余空间）
如空间不足，可卸载不常用应用或删除大文件
建议提前将重要文件备份至 iCloud 或电脑
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399943" alt="图片" title="图片" loading="lazy"/></p><p>方法 7：开启飞行模式</p><p>在 iPhone 上开启飞行模式可避免因网络干扰导致的传输失败。<br/>打开控制中心，点击飞机图标即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399944" alt="图片" title="图片" loading="lazy"/></p><p>方法 8：关闭所有后台应用</p><p>安卓后台应用可能干扰 Move to iOS 运行，建议全部关闭：</p><pre><code>进入 设置 &gt; 应用
查看正在运行的应用，逐个点击并选择“强制停止”
或直接卸载不常用的应用
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399945" alt="图片" title="图片" loading="lazy"/></p><p>方法 9：重启两部手机</p><p>重启可清除系统缓存和临时故障：</p><pre><code>安卓：长按电源键 &gt; 重启
iPhone：长按电源键 &gt; 滑动关机 &gt; 再次开机

</code></pre><h3>第三部分：使用更稳定的 Move to iOS 替代工具 —— iReaShare Phone Transfer</h3><p>如果你尝试了以上方法仍然无法解决问题，或者 Move to iOS 传输速度太慢，我们强烈推荐使用更专业的替代工具：iReaShare Phone Transfer（支持 Windows 和 Mac）。这是一款领先的手机数据传输工具，支持安卓与 iPhone 之间的快速迁移，不会卡在“准备中”，操作简单，传输稳定。</p><p>iReaShare Phone Transfer 的主要优势：</p><pre><code>快速将数据从安卓迁移至 iPhone，不卡在准备阶段
支持联系人、短信、通话记录、照片、视频、音乐、文档、应用、书籍等多种数据类型
不覆盖原有数据，零数据丢失风险
兼容几乎所有安卓与苹果设备，包括最新的 三星 S25 和 iPhone 16 系列
保护用户隐私，本地传输，不上传云端

</code></pre><p>使用步骤（安卓传数据到 iPhone）：</p><p>步骤 1： 下载并安装 iReaShare Phone Transfer 至电脑。</p><p><img width="723" height="492" referrerpolicy="no-referrer" src="/img/bVdm226" alt="" title="" loading="lazy"/></p><p>​编辑步骤 2： 使用 USB 数据线分别连接安卓手机与 iPhone 至电脑，软件将自动识别设备。<br/>步骤 3： 确保 iPhone 显示在右侧“目标设备”位置，如不对可点击“翻转”按钮调整。<br/>步骤 4： 勾选你想传输的数据类型，点击“开始复制”按钮，立即开始迁移。</p><h3>总结</h3><p>本文详细介绍了“Move to iOS 卡在准备中”的常见原因及 9 种解决方法。如果你希望更快、更稳定地完成安卓到 iPhone 的数据迁移，建议使用 iReaShare Phone Transfer 作为 Move to iOS 的替代方案，避免卡顿、失败、耗时等问题。<br/>​</p>]]></description></item><item>    <title><![CDATA[从缺陷预防到良率提升：涂装工艺质量管理的]]></title>    <link>https://segmentfault.com/a/1190000047399977</link>    <guid>https://segmentfault.com/a/1190000047399977</guid>    <pubDate>2025-11-14 16:05:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>从缺陷预防到良率提升：涂装工艺质量管理的智能化转型路径<br/>涂装工艺作为现代制造业的核心环节，尤其在汽车、家电和消费电子等领域，其质量管理直接关系到产品的防护性、装饰性和市场竞争力。随着行业对环保、效率和成本控制的要求日益严格，涂装工艺质量管理已成为企业必须高度重视的战略议题。一个健全的质量管理体系不仅需要覆盖从原材料到成品的全流程，还必须融入数据驱动和智能化手段，以确保一致性、可靠性和可持续性。<br/>在涂装工艺中，质量管理始于前处理阶段，这是整个流程的基础。例如，在汽车制造业中，脱脂和磷化过程的质量控制直接影响车身的耐腐蚀性能和涂层附着力。如果前处理不当，即使后续喷涂工艺再精湛，也无法避免起泡、剥落等缺陷。行业案例显示，某知名汽车品牌曾因磷化膜不均匀导致批量召回，损失高达数百万美元，这突显了前处理质量管理的重要性。通过引入自动化检测系统，如实时监控槽液浓度和温度，企业可以大幅减少人为误差，提升过程稳定性。<br/>喷涂环节的质量管理同样至关重要，尤其是电泳、中涂和面漆的均匀性与厚度控制。在静电喷涂中，涂料利用率和涂层一致性是关键指标。家电行业的一个典型例子是冰箱外壳涂装：如果清漆层厚度不均，会导致光泽度差异，影响产品外观和消费者体验。传统上，企业依赖人工抽样检测，但这种方式效率低且易漏检。现代质量管理则倾向于采用在线测量技术，如红外光谱仪或激光测厚仪，实现全数检验和数据实时反馈。这不仅提高了检测精度，还缩短了反馈周期，使问题得以快速纠正。<br/>固化与干燥过程的质量管理往往被忽视，却是决定涂层最终性能的环节。温度和时间控制不当会导致固化不完全或过烘烤，进而引发漆膜脆化、变色等问题。在消费电子行业，如智能手机外壳涂装，固化炉的温均匀性必须保持在±5°C以内，以确保颜色一致性和耐久性。通过集成物联网（IoT）传感器和数据分析平台，企业可以实时监控炉温曲线，并自动调整参数以应对波动。这种智能化手段不仅提升了质量稳定性，还降低了能源消耗，符合绿色制造趋势。<br/>行业例子进一步说明，涂装工艺质量管理需要跨部门协作和持续改进文化。在汽车制造中，广域铭岛作为行业解决方案提供商，通过其数字化平台帮助车企整合涂装线数据，实现从订单到交付的全链路可视化。例如，某合作车企利用该平台将生产、质量、工艺、设备的管理逻辑融入系统，实现涂装核心业务自动运行，提升效率。涂装质量数据实时采集上传，发现涂装质量趋势达到既定范围马上预警，实现数据驱动管理。涂装车间提升效率年收益约人民币 53.45 万元/年、减少返修，节约返修产生的物辅料费用约人民币 4.2 万元/年。<br/>总之，涂装工艺质量管理是一个多维度的系统工程，涉及技术、流程和人员素质的综合提升。随着工业4.0的推进，人工智能、大数据和云计算正成为质量管理的赋能工具。企业应拥抱这些创新，通过标准化操作、实时监控和持续优化，构建坚韧的质量体系。<br/>未来，质量管理将更加注重预测性和自适应能力，从而在激烈市场竞争中保持优势。通过借鉴行业最佳实践和利用先进技术，制造企业可以显著提升涂装工艺质量，驱动整体业务增长。</p>]]></description></item><item>    <title><![CDATA[用 Eino ADK 构建你的第一个 A]]></title>    <link>https://segmentfault.com/a/1190000047399985</link>    <guid>https://segmentfault.com/a/1190000047399985</guid>    <pubDate>2025-11-14 16:05:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文将会向您介绍如何利用 <strong>Eino ADK (Agent Development Kit)</strong> 构建一个强大的多智能体系统。</p><p>以 Excel Agent 这个实际业务场景为基础，Excel Agent 是一个能够“听懂你的话、看懂你的表格、写出并执行代码”的智能助手。它把复杂的 Excel 处理工作拆解为清晰的步骤，通过自动规划、工具调用与结果校验，稳定完成各项Excel数据处理任务。</p><p>接下来我们将从 Excel Agent 的完整架构与功能出发，向您展示该 Agent 是如何通过 Eino ADK 逐步搭建的，进而深入浅出的理解 Eino ADK 的核心设计特点，助您快速上手 Eino ADK，向构建自定义智能体与 AI 应用系统更进一步。</p><p>本示例完整代码位于 Github，您可以随时浏览与下载。</p><h4><strong>Excel Agent 是什么？</strong></h4><p>Excel Agent 是一个“看得懂 Excel 的智能助手”，它先把问题拆解成步骤，再一步步执行并校验结果。它能理解用户问题与上传的文件内容，提出可行的解决方案，并选择合适的工具（系统命令、生成并运行 Python 代码、网络查询等等）完成任务。</p><p>Excel Agent 整体是基于 Eino ADK 实现的 Multi-Agent 系统，完整架构如下图所示：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399987" alt="" title=""/></p><p>Excel Agent 内部包含的几个 Agent 功能分别为：</p><ul><li><strong>Planner</strong>：分析用户输入，拆解用户问题为可执行的计划</li><li><strong>Executor</strong>：正确执行当前计划中的首个步骤</li><li><strong>CodeAgent</strong>：接收来自 Executor 的指令，调用多种工具（例如读写文件，运行 python 代码等）完成任务</li><li><strong>WebSearchAgent</strong>：接收来自 Executor 的指令，进行网络搜索</li><li><strong>Replanner</strong>：根据 Executor 执行的结果和现有规划，决定继续执行、调整规划或完成执行</li><li><strong>ReportAgent</strong>：根据运行过程与结果，生成总结性质的报告</li></ul><h4><strong>Excel Agent 的典型使用场景</strong></h4><p>在真实业务里，你可以把 Excel Agent 当成一位“Excel 专家 + 自动化工程师”。当你交付一个原始表格和目标描述，它会给出方案并完成执行：</p><ul><li><strong>数据清理与格式化</strong>：从一个包含大量数据的 Excel 文件中完成去重、空值处理、日期格式标准化操作。</li><li><strong>数据分析与报告生成</strong>：从销售数据中提取每月的销售总额，聚合统计、透视，最终生成并导出图表报告。</li><li><strong>自动化预算计算</strong>：根据不同部门的预算申请，自动计算总预算并生成部门预算分配表。</li><li><strong>数据匹配与合并</strong>：将多个不同来源的客户信息表进行匹配合并，生成完整的客户信息数据库。</li></ul><p>Excel Agent 的完整运行动线为：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399988" alt="" title="" loading="lazy"/></p><p><strong>核心收益</strong>：</p><ul><li><strong>更少的人工操作</strong>，把复杂繁琐的 Excel 处理工作交给 Agent 自动完成。</li><li><strong>更稳定的产出质量</strong>，通过“规划—执行—反思”闭环减少漏项与错误。</li><li><strong>更强的可扩展性</strong>，各 Agent 独立构建，低耦合利于迭代更新。</li></ul><p>Excel Agent 既可以单独使用，也可以作为子 Agent，集成在一个复合的多专家系统中，由外部路由到此 Agent 上，解决 excel 领域相关的问题。</p><p>下面我们将逐步拆解 Excel Agent，深入了解 Eino ADK 的核心设计特点，以及如何利用这些特点构建高效、灵活的 AI 应用系统。</p><h4><strong>ChatModelAgent：与 LLM 交互的基石</strong></h4><p><code>ChatModelAgent</code>是 Eino ADK 中的一个核心预构建的 Agent，内部使用了 <a href="https://link.segmentfault.com/?enc=yX3SwH33JjaUaTaDMGV9OA%3D%3D.LtwyLTLe0RcImHZOhtVEh69rr1%2BVuT0QO%2FGrwePCqfc%3D" rel="nofollow" target="_blank">ReAct</a> 模式（一种让模型‘思考-行动-观察’的链式推理模式）：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399989" alt="" title="" loading="lazy"/></p><p><code>ChatModelAgent</code>旨在让 ChatModel 进行显式的、一步一步的“思考”，结合思考过程驱动行动，观测历史思考过程与行动结果继续进行下一步的思考与行动，最终解决复杂问题：</p><ul><li>调用 ChatModel（Reason）</li><li>LLM 返回工具调用请求（Action）</li><li>ChatModelAgent 执行工具（Act）</li><li>将工具结果返回给 LLM（Observation），结合之前的上下文继续生成，直到模型判断不需要调用工具后结束</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399990" alt="" title="" loading="lazy"/></p><p>在 Excel Agent 中，每个 Agent 的核心都是这样一个 <code>ChatModelAgent</code>，以 Executor 运行【读取用户输入表格的头信息】这个步骤为例 ，我们可以通过观察完整的运行过程来理解 ReAct 模式在 <code>ChatModelAgent</code>中的表现：</p><ol><li>Executor：经过判断，将任务转交给 CodeAgent 运行</li><li>CodeAgent：接收到任务【读取用户输入表格的头信息】</li></ol><ul><li><strong>Think-1</strong>：上下文未提供工作目录下的所有文件，需要查看</li><li><strong>Act-1</strong>: 调用 Bash 工具，ls 查看工作目录下的所有文件</li><li><strong>Think-2</strong>: 找到了用户输入的文件，判断需要编写 Python 代码读取 xlsx 表格的首行</li><li><strong>Act-2</strong>: 调用 PythonRunner 工具，书写代码并运行，获取运行结果</li><li><strong>Think-3</strong>: 获取到了 xlsx 首行，判断任务完成</li></ul><ol><li>运行完成，将表格头信息返回给 Executor</li></ol><h4><strong>Plan-Execute Agent：基于「规划-执行-反思」的多智能体协作框架</strong></h4><p>Plan-Execute Agent 是 Eino ADK 中一种基于「规划-执行-反思」范式的多智能体协作框架，旨在解决复杂任务的分步拆解、执行与动态调整问题。它通过 <strong>Planner（规划器）</strong>、**Executor（执行器）**和 <strong>Replanner（重规划器）</strong> 三个核心智能体的协同工作，实现任务的结构化规划、工具调用执行、进度评估与动态 replanning，最终达成用户目标：</p><pre><code>// 完整代码: https://github.com/cloudwego/eino/blob/main/adk/prebuilt/planexecute/plan_execute.go

// NewPlanner creates a new planner agent based on the provided configuration.
func NewPlanner(_ context.Context, cfg *PlannerConfig) (adk.Agent, error)

// NewExecutor creates a new executor agent.
func NewExecutor(ctx context.Context, cfg *ExecutorConfig) (adk.Agent, error)

// NewReplanner creates a new replanner agent.
func NewReplanner(_ context.Context, cfg *ReplannerConfig) (adk.Agent, error)

// New creates a new plan-execute-replan agent with the given configuration.
func New(ctx context.Context, cfg *Config) (adk.Agent, error)

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399991" alt="" title="" loading="lazy"/></p><p>而 Excel Agent 的核心能力恰好为【解决用户在 excel 领域的问题】，与该智能体协作框架定位一致：</p><ul><li><strong>规划者（Planner）</strong>：明确目标，自动拆解可执行步骤</li><li><strong>执行者（Executor）</strong>：调用工具（Excel 读取、系统命令、Python 代码）完成规划中的每一个详细步骤</li><li><strong>反思者（Replanner）</strong>：根据执行进度决定继续、调整规划或结束</li></ul><p>Planner 和 Replanner 会将用户模糊的指令拆解为清晰的、可执行的步骤清单，即包含多个步骤（Step）的计划（Plan），Eino ADK 为此提供了灵活的 Plan 接口定义，支持用户自定义 Plan 结构与细节：</p><pre><code>type Plan interface {
    // FirstStep returns the first step to be executed in the plan.
    FirstStep() string
    // Marshaler serializes the Plan into JSON.
    // The resulting JSON can be used in prompt templates.
    json.Marshaler
    // Unmarshaler deserializes JSON content into the Plan.
    // This processes output from structured chat models or tool calls into the Plan structure.
    json.Unmarshaler
}

</code></pre><p>默认情况下，框架会使用内置的 Plan 结构作为兜底配置，例如下面就是 Excel Agent 产生的一个完整运行计划：</p><pre><code>### 任务计划
- [x] 1. Read the contents of '模拟出题.csv' from the working directory into a pandas DataFrame.
- [x] 2. Identify the question type (e.g., multiple-choice, short-answer) for each row in the DataFrame.
- [x] 3. For non-short-answer questions, restructure the data to place question, answer, explanation, and options in the same row.
- [x] 4. For short-answer questions, merge the answer content into the explanation column and ensure question and merged explanation are in the same row.
- [x] 5. Verify that all processed rows have question, answer (where applicable), explanation, and options (where applicable) in a single row with consistent formatting.
- [x] 6. Generate a cleaned report presenting the formatted questions with all relevant components (question, answer, explanation, options) in unified rows.

</code></pre><h4><strong>Workflow Agents：可控的多 Agent 运行流水线</strong></h4><p>Excel Agent 中，存在一些需要按照特定顺序运行 agent 的情况：</p><ol><li><strong>顺序运行</strong>：先运行 Planner，再运行 Executor 和 Replanner；Planner 只运行一次。</li><li><strong>循环运行</strong>：Executor 和 Replanner 需要按需循环运行多次，每次循环运行都是先运行 Executor 后运行 Replanner</li><li><strong>顺序运行</strong>：Plan-Executor 整体运行完后，固定运行一次 ReportAgent 进行总结。</li></ol><p>对于这些拥有固定执行流程的场景，Eino ADK 提供了三种流程编排方式，协助用户快速搭建可控的工作流：</p><ul><li><strong>SequentialAgent</strong>：按照配置中提供的顺序，依次执行一系列子 Agent。每个子 Agent 执行完成后，其输出会通过 History 机制传递给下一个子 Agent，形成一个线性的执行链。</li></ul><pre><code>import github.com/cloudwego/eino/adk

// 依次执行 制定研究计划 -&gt; 搜索资料 -&gt; 撰写报告
sequential := adk.NewSequentialAgent(ctx, &amp;adk.SequentialAgentConfig{
    Name: "research_pipeline",
    SubAgents: []adk.Agent{
        planAgent,    // 制定研究计划
        searchAgent,  // 搜索资料
        writeAgent,   // 撰写报告
    },
})

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399992" alt="" title="" loading="lazy"/></p><ul><li><strong>LoopAgent</strong>：重复执行配置的子 Agent 序列，直到达到最大迭代次数或某个子 Agent 产生 ExitAction，每次迭代的结果都会累积，后续迭代的输入可以访问所有历史信息。LoopAgent 基于 SequentialAgent 实现。</li></ul><pre><code>import github.com/cloudwego/eino/adk

// 循环执行 5 次，每次顺序为：分析当前状态 -&gt; 提出改进方案 -&gt; 验证改进效果
loop := adk.NewLoopAgent(ctx, &amp;adk.LoopAgentConfig{
    Name: "iterative_optimization",
    SubAgents: []adk.Agent{
        analyzeAgent,  // 分析当前状态
        improveAgent,  // 提出改进方案
        validateAgent, // 验证改进效果
    },
    MaxIterations: 5,
})

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399993" alt="" title="" loading="lazy"/></p><ul><li><strong>ParallelAgent</strong>：允许多个子 Agent 基于相同的输入上下文并发执行。所有子 Agent 接收相同的初始输入，各自在独立的 goroutine（Go 语言中一种轻量级的并发执行单元） 运行，最终收集所有子 Agent 的执行结果并按顺序输出到<code>AsyncIterator</code>中。</li></ul><pre><code>import github.com/cloudwego/eino/adk

// 并发执行 情感分析 + 关键词提取 + 内容摘要
parallel := adk.NewParallelAgent(ctx, &amp;adk.ParallelAgentConfig{
    Name: "multi_analysis",
    SubAgents: []adk.Agent{
        sentimentAgent,  // 情感分析
        keywordAgent,    // 关键词提取
        summaryAgent,    // 内容摘要
    },
})

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399994" alt="" title="" loading="lazy"/></p><h4><strong>Agent 抽象：灵活定义 Agent 的基础</strong></h4><p>Eino ADK 的核心是一个简洁而强大的 Agent 接口，每个 Agent 都有明确的身份（Name）、清晰的职责（Description）和标准化的执行方式（Run），为 Agent 之间的发现与调用提供了基础。无论是简单的问答机器人，还是复杂的多步骤任务处理系统，都可以通过这个统一的接口加以实现。</p><ul><li><strong>统一的 Agent 抽象</strong>：ADK 提供的预构建 Agent（ChatModelAgent，Plan-Execute Agent，Workflow Agents）都遵循该接口定义。您也可以基于该接口，书写自定义 Agent，完成定制化需求。</li></ul><pre><code>type Agent interface {
    Name(ctx context.Context) string
    Description(ctx context.Context) string
    Run(ctx context.Context, input *AgentInput, options ...AgentRunOption) *AsyncIterator[*AgentEvent]
}

</code></pre><ul><li><strong>标准化输入</strong>：Agent 通常以 LLM 为核心，因此 Eino ADK 定义的 Agent 的输入与 LLM 接收的输入一致：</li></ul><pre><code>type AgentInput struct {
    Messages        []Message
    EnableStreaming bool
}

type Message = *schema.Message // *schema.Message 是模型输入输出的结构定义

</code></pre><ul><li><strong>异步事件驱动输出</strong>：Agent 的输出是一个 AgentEvent 的异步迭代器，其中的 AgentEvent 表示 Agent 在其运行过程中产生的核心事件数据。其中包含了 Agent 的元信息、输出、行为和报错信息：</li></ul><pre><code>type AgentEvent struct {
    AgentName string    // 产生 Event 的 Agent 名称（框架自动填充）

    RunPath []RunStep   // 到达当前 Agent 的完整运行轨迹（框架自动填充）

    Output *AgentOutput // Agent 输出消息内容

    Action *AgentAction // Agent 动作事件内容

    Err error           // Agent 报错
}

type AgentOutput struct {
    MessageOutput *MessageVariant // 模型消息输出内容

    CustomizedOutput any          // 自定义输出内容
}

type MessageVariant struct {
    IsStreaming bool            // 是否为流式输出
    
    Message       Message        // 非流式消息输出
    MessageStream MessageStream  // 流式消息输出

    Role schema.RoleType         // 消息角色
    ToolName string              // 工具名称
}

type AgentAction struct {
    Exit bool                               // Agent 退出

    Interrupted *InterruptInfo              // Agent 中断

    TransferToAgent *TransferToAgentAction  // Agent 跳转

    CustomizedAction any                    // 自定义 Agent 动作
}

</code></pre><p>异步迭代器允许 Agent 在运行过程中的任意时刻向迭代器发送消息（Agent 调用模型结果、工具运行结果、中间状态等等），同时调用方以一种有序、阻塞的方式消费这一系列事件：</p><pre><code>iter := myAgent.Run(ctx, "hello") // get AsyncIterator

for {
    event, ok := iter.Next()
    if !ok {
        break
    }
    // handle event
}

</code></pre><h3><strong>Agent 协作：隐藏在 Agent 后的数据传递</strong></h3><p>Excel Agent 架构图中的节点代表每个具体的 Agent，边代表了数据流通与任务转移。在构建多 Agent 系统时，让不同 Agent 之间高效、准确地共享信息至关重要。</p><p>这些信息不仅包含 Agent 的输入输出，还有全局的、部分可见的种种额外信息，例如：</p><ul><li>Executor 执行需要从 Planner / Replanner 拿到一个结构化的、可被拆分为详细步骤（Step）的计划（Plan），而非一段非结构化的 LLM 原始输出消息。</li><li>ReportAgent 需要拿到完整的运行计划、运行过程与运行产物才能正确产生报告。</li></ul><p>Eino ADK 包含两种基础的数据传递机制：</p><ul><li><strong>History</strong>：每一个 Agent 产生的 AgentEvent 都会被保存到这个隐藏的 History 中，调用一个新 Agent 时 History 中的 AgentEvent 会被转换并拼接到 AgentInput 中。默认情况下，其他 Agent 的 Assistant 或 Tool Message，被转换为 User Message，这相当于在告诉当前的 LLM：“刚才， Agent\_A 调用了 some\_tool ，返回了 some_result 。现在，轮到你来决策了。”。 通过这种方式，其他 Agent 的行为被当作了提供给当前 Agent 的“外部信息”或“事实陈述”，而不是它自己的行为，从而避免了 LLM 的上下文混乱。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399995" alt="" title="" loading="lazy"/></p><ul><li><strong>共享 Session</strong>：单次运行过程中持续存在的 KV 存储，用于支持跨 Agent 的状态管理和数据共享，一次运行中的任何 Agent 可以在任何时间读写 SessionValues。以 Plan-Execute Agent 模式为例，Planner 生成首个计划并写入 Session；Executor 从 Session 读取计划并执行；Replanner 从 Session 读取当前计划后，结合运行结果，将更新后的计划写回 Session 覆盖当前的计划。</li></ul><pre><code>// Agent 内获取全部 SessionValues
func GetSessionValues(ctx context.Context) map[string]any

// Agent 内指定 key 获取 SessionValues 中的值
func GetSessionValue(ctx context.Context, key string) (any, bool)

// Agent 内添加 SessionValues
func AddSessionValue(ctx context.Context, key string, value any)

// Agent 内批量添加 SessionValues
func AddSessionValues(ctx context.Context, kvs map[string]any)

// WithSessionValues 在 Agent 运行前由外部注入 SessionValues
func WithSessionValues(v map[string]any) AgentRunOption
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399996" alt="" title="" loading="lazy"/></p><p>除了完善的 Agent 间数据传递机制，Eino ADK 从实践出发，提供了多种 Agent 协作模式：</p><ul><li><strong>预设 Agent 运行顺序（Workflow）</strong>：以代码中预设好的流程运行， Agent 的执行顺序是事先确定、可预测的。对应 Workflow Agents 章节提到的三种范式。</li><li><strong>移交运行（Transfer）</strong>：携带本 Agent 输出结果上下文，将任务移交至子 Agent 继续处理。适用于智能体功能可以清晰的划分边界与层级的场景，常结合 ChatModelAgent 使用，通过 LLM 的生成结果进行动态路由。结构上，以此方式进行协作的两个 Agent 称为父子 Agent：</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399997" alt="" title="" loading="lazy"/></p><pre><code>// 设置父子 Agent 关系
func SetSubAgents(ctx context.Context, agent Agent, subAgents []Agent) (Agent, error)

// 指定目标 Agent 名称，构造 Transfer Event
func NewTransferToAgentAction(destAgentName string) *AgentAction

</code></pre><ul><li><strong>显式调用（ToolCall）</strong>：将 Agent 视为工具进行调用，适用于 Agent 运行仅需要明确清晰的参数而非完整运行上下文的场景。常结合 ChatModelAgent，将 Agent 作为工具运行后将结果返回给 ChatModel 继续处理。除此之外，ToolCall 同样支持调用符合工具接口构造的、不含 Agent 的普通工具。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399998" alt="" title="" loading="lazy"/></p><pre><code>// 将 Agent 转换为 Tool
func NewAgentTool(_ context.Context, agent Agent, options ...AgentToolOption) tool.BaseTool

</code></pre><h3><strong>Excel Agent 示例运行</strong></h3><h4><strong>配置环境与输入输出路径</strong></h4><ul><li>环境变量：Excel Agent 运行依赖的完整环境变量可参考项目 README。</li><li><p>运行输入：包括一段用户需求描述和待处理的一系列文件，其中：</p><ul><li><code>main.go</code>中首行表示用户输入的需求描述，可自行修改：</li></ul></li></ul><pre><code>func main() {
    // query := schema.UserMessage("统计附件文件中推荐的小说名称及推荐次数，并将结果写到文件中。凡是带有《》内容都是小说名称，形成表格，表头为小说名称和推荐次数，同名小说只列一行，推荐次数相加")
    // query := schema.UserMessage("读取模拟出题.csv 中的内容，规范格式将题目、答案、解析、选项放在同一行，简答题只把答案写入解析即可")
    query := schema.UserMessage("请帮我将 question.csv 表格中的第一列提取到一个新的 csv 中")
}

</code></pre><ul><li><code>adk/multiagent/integration-excel-agent/playground/input</code>为默认的附件输入路径，附件输入路径支持配置，参考 README。</li><li><code>adk/multiagent/integration-excel-agent/playground/test_data</code> 路径下提供了几个示例文件，您可以将文件复制到附件输入路径下来进行测试运行：</li></ul><pre><code>% tree adk/multiagent/integration-excel-agent/playground/test_data
adk/multiagent/integration-excel-agent/playground/test_data
├── questions.csv
├── 推荐小说.txt
└── 模拟出题.csv

1 directory, 3 files</code></pre><ul><li>运行输出：Excel Agent 输入的附件、运行的中间产物与最终结果都会放置在工作路径下：<code>adk/multiagent/integration-excel-agent/playground/${uuid}</code>，输出路径支持配置，参考 README。</li></ul><h4><strong>查看运行结果</strong></h4><p>Excel Agent 单次运行会在输出路径下创建一个新的工作目录，并在该目录下完成任务，运行时产生的中间产物与最终结果都会写到该目录下。</p><p>以<code>请帮我将 question.csv 表格中的第一列提取到一个新的 csv</code> 中这个任务为例，运行完成后在工作目录下包含的内容有：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399999" alt="" title="" loading="lazy"/></p><ol><li>原始输入：从输入路径获取到的 <code>question.csv</code></li><li>Planner / Replanner 给出的运行计划：<code>plan.md</code></li></ol><pre><code>### 任务计划
- [x] 1. {"desc":"Read the 'questions.csv' file into a pandas DataFrame."}
- [x] 2. Save the extracted first column to a new CSV file.

</code></pre><ol start="3"><li>Executor 中的 CodeAgent 书写的代码：<code>$uuid.py</code></li></ol><pre><code>import pandas as pd

df = pd.read_csv('questions.csv')
first_column = df.iloc[:, 0]
first_column.to_csv('extracted_first_column.csv', index=False)

</code></pre><ol start="4"><li>运行中间产物：<code>extracted_first_column.csv</code>和 <code>first_column.csv</code></li></ol><pre><code>type
multiple-choice
...
short-answer

</code></pre><ol start="5"><li>最终报告：<code>final_report.json</code></li></ol><pre><code>{
  "is_success": true,
  "result": "Successfully extracted the first column from questions.csv and saved it to first_column.csv.",
  "files": [
    {
      "path": "/User/user/go/src/github.com/cloudwego/eino-examples/adk/multiagent/integration-excel-agent/playground/00f118af-4bd8-42f7-8d11-71f2801218bd/first_column.csv",
      "desc": "A CSV file containing only the first column data from the original questions.csv."
    }
  ]
}

</code></pre><h4>运行过程输出</h4><p>Excel Agent 会将每个步骤的运行结果输出到日志中。下面仍以<code>请帮我将 question.csv 表格中的第一列提取到一个新的 csv 中</code>这个任务为例，向您展示 Excel Agent 在运行过程中的几个关键步骤及其输出，并通过对步骤的解释，直观地呈现 Agent 的运行流程及其强大能力。：</p><ul><li>Planner 生成 JSON 格式的初始计划</li></ul><pre><code>name: Planner
answer: {
    "steps": [
        {
            "index": 1,
            "desc": "Read the 'questions.csv' file into a pandas DataFrame."
        },
        {
            "index": 2,
            "desc": "Extract the first column from the DataFrame."
        },
        {
            "index": 3,
            "desc": "Save the extracted first column to a new CSV file."
        }
    ]
}

</code></pre><ul><li>Executor 将 CodeAgent 作为工具进行调用，执行计划中的首个步骤</li></ul><pre><code>name: Executor
tool name: CodeAgent
arguments: {"request":"Read the 'questions.csv' file into a pandas DataFrame using pandas. Use the pandas.read_csv function and store the result in a variable named df."}

</code></pre><ul><li>CodeAgent 使用 PythonRunner 工具运行代码，并使用 ReAct 模式自动纠错，修正代码中的错误</li></ul><pre><code># CodeAgent 使用 PythonRunner 工具运行代码
name: Executor
tool name: PythonRunner
arguments: {"code":"```python\nfirst_column = df.iloc[:, 0]\n```"}

# PythonRunner 代码运行报错
name: Executor
tool response: Traceback (most recent call last):
  File "/User/user/go/src/github.com/cloudwego/eino-examples/adk/multiagent/integration-excel-agent/playground/00f118af-4bd8-42f7-8d11-71f2801218bd/00f118af-4bd8-42f7-8d11-71f2801218bd.py", line 1, in &lt;module&gt;
    first_column = df.iloc[:, 0]
                   ^^
NameError: name 'df' is not defined

# ReAct 模式自动纠错，修正无法运行的代码
name: Executor
answer: The error occurs because the DataFrame `df` is not defined. We need to first load the data from the existing CSV file `questions.csv` into `df`. Here's the corrected code:
tool name: PythonRunner
arguments: {"code":"```python\nimport pandas as pd\ndf = pd.read_csv('questions.csv')\nfirst_column = df.iloc[:, 0]\nprint(first_column.head())  # Verify the result\n```"}

# 代码运行成功，返回运行结果
name: Executor
path: [{SequentialAgent} {plan_execute_replan} {Planner} {execute_replan} {Executor}]
tool response: 
0    multiple-choice
1    multiple-choice
2    multiple-choice
3    multiple-choice
4    multiple-choice
Name: type, dtype: object

</code></pre><ul><li>Replanner 判断计划完成，提交运行结果至 ReportAgent</li></ul><pre><code>name: Replanner
answer: {
    "is_success": true,
    "result": "已成功将'questions.csv'表格中的第一列提取到新的CSV文件'extracted_first_column.csv'中。",
    "files": [
        {
            "desc": "包含原表格第一列数据的新CSV文件",
            "path": "extracted_first_column.csv"
        }
    ]
}

</code></pre><ul><li>ReportAgent 进行总结，结束执行</li></ul><pre><code>name: Report
tool name: SubmitResult
arguments: {
    "is_success": true,
    "result": "Successfully extracted the first column from questions.csv and saved it to first_column.csv.",
    "files": [
        {
            "path": "/User/user/go/src/github.com/cloudwego/eino-examples/adk/multiagent/integration-excel-agent/playground/00f118af-4bd8-42f7-8d11-71f2801218bd/first_column.csv",
            "desc": "A CSV file containing only the first column data from the original questions.csv."
        }
    ]
}

</code></pre><h3><strong>总结</strong></h3><p>Excel Agent 所呈现的并非“单一智能体”的技巧，而是一套以 Eino ADK 为底座的 Multi-Agent 系统工程化方法论：</p><ul><li>以 ChatModelAgent 的 ReAct 能力为基石，让模型“可思考、会调用”。</li><li>以 WorkflowAgents 的编排能力，让 Multi-Agent 系统中的每个 Agent 以用户预期的顺序运行。</li><li>以 Planner–Executor–Replanner 的闭环，让复杂任务“可拆解、能纠错”。</li><li>以 History / Session 的数据传递机制，让多 Agent “能协作、可回放”。</li></ul><blockquote><p>💡 <strong>立即开始你的智能体开发之旅</strong></p><ul><li>⌨️ 查看 Excel Agent 源码：<a href="https://link.segmentfault.com/?enc=%2BkWCR2vNbBboGs%2B%2FS4C0LQ%3D%3D.xs4TTc0ZOM2qgHDn1dO6PFlg%2FVU%2BgXNvYgjKMhD1%2F6TZi16GFC3akfWYN8eYAeD2zlkhYzriaf3EV1D3mSjZKA%3D%3D" rel="nofollow" target="_blank">to do</a></li><li>📚 查看更多文档：<a href="https://link.segmentfault.com/?enc=X7z%2BZQWJ1qQE98IsyTo7Kw%3D%3D.McWfV4RC2Lly8afqwbY7VmmR%2FAiRM%2FefZfJCNLfb4k6PtOLmrLcnfIA4ZwrA78U9xeaflCHnYnEthzVP9w2Hvw%3D%3D" rel="nofollow" target="_blank">Eino ADK 文档</a></li><li>🛠️ 浏览 ADK 源码：<a href="https://link.segmentfault.com/?enc=U0J94tlB%2F1PLi9YTJPy6Zw%3D%3D.IdpmaPFviD0mo8BLspD9u6xqgSAIeGh18kEzjTy9DvswjZpDjEokjEi5%2BA9gWkRvpBOrR9E91NyNc7Y3OzGUhg%3D%3D" rel="nofollow" target="_blank">Eino ADK 源码</a></li><li>💡 探索 ADK 全部示例：<a href="https://link.segmentfault.com/?enc=CIz%2BEUBEjRoXw0nGoHcgpQ%3D%3D.xq5A6mJz8pjcgF1P%2FIKXED4KHsdHZPkQ%2Bo41kH%2BBd8TUuFA46Crsbs3hCd5O4gvG62zWzGBnA1h36KY7betA5A%3D%3D" rel="nofollow" target="_blank">Eino ADK Examples</a></li><li>🤝 加入开发者社区：与其他开发者交流经验和最佳实践</li></ul><p><strong>Eino ADK，让智能体开发变得简单而强大！</strong></p></blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400000" alt="" title="" loading="lazy"/></p><p><strong>参考资料</strong></p><p>[1] ReAct: _<a href="https://link.segmentfault.com/?enc=8TNh0Zg2YHn3gIYMULzDww%3D%3D.1wjotR6Oq5Mc2U2XW7LRGYgu4oR%2FUcry3NGJj4ZngJE%3D" rel="nofollow" target="_blank">https://react-lm.github.io/</a>_</p><p>[2] Eino 示例代码: _<a href="https://link.segmentfault.com/?enc=590RKEtUG5zGjRQyVaf%2B3A%3D%3D.JtPyb4qOGDEZp5UNWy2FIOotG%2BGz5L%2F2bfoSrafaRDGmFqZoNyzRNRprk%2FVqnoDYq7IlpeHwM%2BxRRAa5F1oDncdZ6RKCI4lxnSuS3%2BHiYYPjTli7sxS3L5PwxOk%2Bj%2FPU" rel="nofollow" target="_blank">https://github.com/cloudwego/eino-examples/tree/main/adk/multiagent/integration-excel-agent</a>_</p><p>[3] Eino ADK 文档: _<a href="https://link.segmentfault.com/?enc=gVQ6Kw1Xhu%2BE%2FT%2FKVcwaQA%3D%3D.XQAl8RTuqESgD26O3sOqm2Bdj3tU2KXlvTC0uxRwsOmCF9eOqqoUsMCAHMKSxVy%2Bg4SgT5vA2Z2fwYulC%2FZGtA%3D%3D" rel="nofollow" target="_blank">https://www.cloudwego.io/zh/docs/eino/core\_modules/eino\_adk/</a>_</p><p>[4] Eino ADK 源码: _<a href="https://link.segmentfault.com/?enc=UpZyZR0CdGkYjl0OoLZDXQ%3D%3D.6n2Xj4gVjawIAbHnRElTXJ63dSlMyyb8HrKN4vtsXLsgabpOr7XitCDdJCmilzBS" rel="nofollow" target="_blank">https://github.com/cloudwego/eino/tree/main/adk</a>_</p><p>[5] Eino ADK Examples: _<a href="https://link.segmentfault.com/?enc=Xj8RVzrRqRHzdFWmJyovXg%3D%3D.na98EyqlrqKEoyviWDb37rOzg%2Bvcp6Vo8gZLii9cNQDm2XbjrqOc8rIfUS%2BnqdwoBndgGdXo2IaQWQ99MGfqEA%3D%3D" rel="nofollow" target="_blank">https://github.com/cloudwego/eino-examples/tree/main/adk</a>_</p>]]></description></item><item>    <title><![CDATA[【案例分享】灯塔低代码平台助力医院构建智]]></title>    <link>https://segmentfault.com/a/1190000047400020</link>    <guid>https://segmentfault.com/a/1190000047400020</guid>    <pubDate>2025-11-14 16:04:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>构建一个以患者为中心、数据驱动、业务协同的智慧服务新生态，已成为现代医院提升服务质量、优化资源配置、创新服务模式的必然选择。而这样的转型，离不开强有力的技术支撑作为基石。北京中烟创新科技有限公司（简称：中烟创新）的灯塔低代码平台，凭借其独特的业务敏捷性、技术包容性和生态连接能力，正完美契合了这一需求，成为推动医院智慧服务体系建设的重要力量。</p><p>平台通过可视化开发、组件化封装和模型驱动架构，为医院提供了快速实现数字化创新的技术基础，让业务专家能够深度参与应用构建，使智慧服务从理念加速走向实践。其核心价值在于将复杂的技术实现过程简化为业务人员可理解的视觉元素，同时保持企业级应用所需的稳定性、安全性和集成能力。</p><p>这种特性使其成为构建医院智慧服务生态的理想技术载体。在医疗环境快速发展的今天，医院需要面对持续变化的服务需求和政策要求。传统开发模式往往需要数月的开发周期，难以满足业务的快速迭代需求。灯塔低代码平台通过可视化的开发环境和丰富的预置组件，使得应用开发周期从"月"级缩短到"周"甚至"天"级，让医院能够快速响应内外部变化，持续优化服务体验。平台有效降低了数字化创新的技术门槛，让熟悉医疗业务的医护人员、管理人员能够直接参与应用设计。</p><p>这种业务与技术的深度融合，确保了数字化解决方案更贴近实际工作场景，解决了传统开发中业务需求与技术实现之间的理解偏差问题，真正实现了"业务驱动"的数字化转型。灯塔低代码平台具备强大的系统集成能力和数据整合能力，能够作为"数字连接器"，打通医院内部各业务系统，连接医疗设备、物联网终端等物理设施，实现数据互通和业务协同，为构建统一、联动的服务生态提供技术保障。</p><p>场景一：全院医疗质量与安全一体化管理医院检查医疗质量主要靠人工抽查、纸质记录和事后查看，效率不高，检查范围也有限。很难做到实时监控和提前预警，对于保障患者安全，有时会因为信息延迟而反应不及。使用灯塔低代码平台，可建立一个覆盖“患者入院前、治疗中、出院后”所有环节的立体化质量管控体系。流程全部搬到线上：把病历书写、合理用药、手术安全、感染预防、危急值处理等上百条质量检查标准，都变成清晰的线上流程。质量管理员、科室主任和医务处工作人员通过一个统一的网站入口处理所有事务。用数据智能预警风险：平台与医院的核心系统（如挂号收费系统、电子病历系统、检验系统、影像系统）连接，自动收集关键数据。通过平台内置的规则和智能模型，能实时发现异常情况，并自动把处理任务推送给相关负责人。形成发现问题到改进的完整闭环：从发现问题、评估、整改到验证效果，形成一个完整的线上管理循环。所有操作都有记录，数据自动分析，能生成各种维度的质量报告，为医院评级、精细化管理和高水平学科建设提供科学依据。</p><p>核心价值：将质量管理从 “出了问题再惩罚” 转变为 “提前预防、过程中控制” ，从琐碎的事务管理升级为有策略的战略管理。它不仅大大提升了医疗安全水平，更培养了一种全员参与、用数据说话、持续改进的质量文化，这是医院智慧服务生态稳固运行的基石。场景二：医疗设备精益化共享管理医院里昂贵的医疗设备和科研仪器往往归各个科室自己管，使用率很不均衡，有的设备经常闲着，有的却不够用。管理靠手工记账，维护保养也不及时，导致设备整体的使用效益不高。利用灯塔低代码平台打造一个面向全院的“医疗设备共享平台”，像“共享单车”一样管理设备，实现资产在线化、资源共享化、管理精细化。一站式预约与智能调度：所有设备的信息都公开透明。临床科室可以随时通过电脑或手机查看并在线预约。</p><p>平台内置智能调度程序，能根据急诊的紧急程度、科研项目的重要性等规则，自动分配设备，最大化利用效率。自动结算与效益一目了然：系统自动记录设备使用时长或检测样本数量，并与医院收费系统打通，实现精准、无人为干预的计费和结算。清晰展示使用率、收入、成本等数据，为医院决定采购新设备还是淘汰旧设备提供客观依据。全生命周期健康管理：给设备装上传感器，实时监控它们的运行状态。平台会自动生成预防性保养计划，并在设备异常时自动报修，推送给工程师，形成完整的设备电子健康档案。核心价值：将设备从 “科室的成本负担” 变成了 “全院共享的利润来源” 。它盘活了闲置的资产，提高了资源利用效率，直接降低了医院运营成本。更重要的是，它建立了一套靠数据说话的资源调配机制，支撑起医院的精细化成本核算。</p><p>场景三：以患者为中心的智慧病房患者住院体验很零碎，想知道的信息不透明；护士忙于大量非护理性的琐事，没太多时间和患者沟通；病房的环境管理也比较粗放。围绕患者住院的全过程，打造一个“患者-护士-环境”智能联动的智慧病房系统。数字化床头屏与智能呼叫：患者通过床头的智能屏幕，可以清楚地查看每天的诊疗安排、用药明细、费用清单，还能在线点餐、查询费用、观看健康知识视频。呼叫护士时，系统能区分普通呼叫、输液完毕、紧急求助等不同情况，并直接通知到护士的手持终端上，实现精准响应。护士移动工作站：护士通过移动平板电脑就能实时接收和执行医生指令、扫描核对患者和药品信息、在床边记录生命体征。</p><p>系统会根据患者的病情，自动推送个性化的健康指导内容，帮助护士提供更高效、规范的护理服务。智慧环境与节能管理：病房的灯光、空调、窗帘等与环境传感器联动，能根据患者休息、治疗等不同模式自动调节，营造最舒适的休养环境。同时，系统能对病房的水电消耗进行精确计量和管理。核心价值：极大地提升了患者满意度和护士的职业幸福感，它让信息多跑路，患者少操心；让护士能有更多时间回归到照顾患者的本职工作。一个安全、舒适、智能的住院环境，本身就是最优质的医疗服务，是智慧服务生态最直接的体现。</p><p>场景四：多学科专家协同诊疗平台组织多学科专家会诊非常困难，专家时间难协调，患者资料分散在各处，讨论过程不规范，得出的结论落实和后续跟踪很麻烦，宝贵的诊疗经验也难以积累下来。用灯塔低代码平台构建一个支持复杂疾病诊疗的“线上专家会诊中心”，打破科室和地域的限制。统一的数字病历空间：为每一位需要会诊的患者创建一个专属的线上空间，自动从医院各个系统里收集并整理好所有相关的病历资料，方便专家在会诊前查阅。规范化的协作流程：把会诊申请、邀请专家、安排会议、线上线下混合讨论、发表意见和形成结论的全过程都标准化、线上化。平台支持视频会议、屏幕共享、电子白板等协作工具。知识积累与智能随访：会诊结论被整理成标准格式，形成可以检索、分析的医院知识宝库。系统会根据最终的治疗方案，自动生成随访计划，并对患者的长期治疗效果进行跟踪，形成诊疗效果的反馈闭环。</p><p>核心价值：让多学科会诊从 “门槛很高的专家会议” 变成了 “标准化的诊疗流程” 。它确保了疑难杂症诊疗的规范性和科学性，促进了不同学科专家之间的知识交流和碰撞。同时，它积累了宝贵的临床科研数据，直接推动了医院临床研究水平的提升。场景五：后勤保障“一站式”智能管控医院后勤保障涉及能源、安全、保洁、运输、设备维修等很多方面，这些系统通常各自为政，形成了多个“信息孤岛”，无法统一指挥调度，响应慢，管理成本高。使用灯塔低代码平台打造医院后勤的“智慧大脑”，构建一个一体化的指挥管控体系。全局情况一屏掌握：通过一个可视化大屏幕，把全院的后勤能耗、安防监控、消防报警、电梯运行、医用气体压力、环境温湿度、报修动态等成千上万个数据点融合在一起展示，实现“一个屏幕看管全院”。</p><p>智能预警与跨系统联动：设置复杂的预警规则。比如，当智能水表监测到某区域用水量异常猛增，系统会自动报警并生成巡查任务，同时调取附近的监控摄像头查看现场；消防系统报警时，能自动联动门禁打开逃生通道，并把疏散路线推送到附近人员的手机上。闭环运维与服务评价：全院报修都在线上进行，平台智能派单，维修人员手机接单，维修完成后由申请人在线评价，形成一个完整的服务闭环和考核体系。核心价值：实现后勤保障从 “被动等待报修” 到 “主动预警、智能联动” 的根本性转变。它大幅提升了医院的安全等级和突发事件响应速度，并通过节能管理和流程优化，显著降低了日常运营成本，为临床一线提供了坚强、可靠的后方保障。</p><p>灯塔低代码平台通过赋能业务、连接数据、重塑流程，成功将“以患者为中心”的理念转化为可落地的数字化实践。帮助医院构建一个更具韧性、更可持续的数字化服务体系，最终为患者提供更优质、更安全的医疗服务体验，为"健康中国"建设贡献重要力量！</p>]]></description></item><item>    <title><![CDATA[StockTV 币安交易所数据 Java]]></title>    <link>https://segmentfault.com/a/1190000047400040</link>    <guid>https://segmentfault.com/a/1190000047400040</guid>    <pubDate>2025-11-14 16:03:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文档详细介绍如何使用 Java 语言通过 StockTV API 对接币安交易所数据，包含实时行情、K线数据、交易对信息等完整功能。</p><h2>🚀 快速开始</h2><h3>环境要求</h3><ul><li>JDK 8+</li><li>Maven 3.6+</li><li>网络连接（可访问 <code>api.stocktv.top</code>）</li></ul><h3>项目依赖</h3><pre><code class="xml">&lt;!-- pom.xml --&gt;
&lt;dependencies&gt;
    &lt;!-- HTTP客户端 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
        &lt;version&gt;4.5.14&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- JSON处理 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;version&gt;2.15.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- WebSocket客户端 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.java-websocket&lt;/groupId&gt;
        &lt;artifactId&gt;Java-WebSocket&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- 日志框架 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- Lombok --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.28&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h2>🏗️ 核心架构</h2><h3>项目结构</h3><pre><code>src/main/java/com/stocktv/binance/
├── config/
│   └── BinanceConfig.java
├── model/
│   ├── CryptoPair.java
│   ├── TickerPrice.java
│   ├── KLine.java
│   ├── Trade.java
│   └── ApiResponse.java
├── client/
│   ├── BinanceHttpClient.java
│   └── BinanceWebSocketClient.java
├── service/
│   └── BinanceDataService.java
└── demo/
    └── BinanceDemo.java</code></pre><h2>📦 核心代码实现</h2><h3>1. 配置类</h3><pre><code class="java">package com.stocktv.binance.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

/**
 * 币安数据配置类
 */
public class BinanceConfig {
    
    // API 基础配置
    public static final String BASE_URL = "https://api.stocktv.top";
    public static final String WS_URL = "wss://ws-api.stocktv.top/connect";
    
    // 币安接口路径
    public static final String CRYPTO_PAIR_LIST = "/crypto/pairlist";
    public static final String CRYPTO_TICKER_PRICE = "/crypto/tickerPrice";
    public static final String CRYPTO_LAST_PRICE = "/crypto/lastPrice";
    public static final String CRYPTO_GET_KLINES = "/crypto/getKlines";
    public static final String CRYPTO_GET_TRADES = "/crypto/getTrades";
    
    // 币安市场ID
    public static final int BINANCE_MARKET_ID = 338;
    
    // 主要交易对
    public static final String BTC_USDT = "BTCUSDT";
    public static final String ETH_USDT = "ETHUSDT";
    public static final String BNB_USDT = "BNBUSDT";
    public static final String ADA_USDT = "ADAUSDT";
    public static final String DOT_USDT = "DOTUSDT";
    public static final String XRP_USDT = "XRPUSDT";
    public static final String LTC_USDT = "LTCUSDT";
    public static final String LINK_USDT = "LINKUSDT";
    public static final String BCH_USDT = "BCHUSDT";
    public static final String XLM_USDT = "XLMUSDT";
    
    // API Key
    private final String apiKey;
    
    // HTTP 客户端和JSON处理器
    private final CloseableHttpClient httpClient;
    private final ObjectMapper objectMapper;
    
    public BinanceConfig(String apiKey) {
        this.apiKey = apiKey;
        this.httpClient = HttpClients.createDefault();
        this.objectMapper = new ObjectMapper();
        this.objectMapper.findAndRegisterModules();
    }
    
    // Getter方法
    public String getApiKey() { return apiKey; }
    public CloseableHttpClient getHttpClient() { return httpClient; }
    public ObjectMapper getObjectMapper() { return objectMapper; }
}</code></pre><h3>2. 数据模型类</h3><h4>加密货币交易对数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 加密货币交易对数据模型
 */
@Data
public class CryptoPair {
    @JsonProperty("symbol")
    private String symbol;
    
    @JsonProperty("legal_currency_price")
    private BigDecimal legalCurrencyPrice;
    
    @JsonProperty("market_cap_display")
    private String marketCapDisplay;
    
    @JsonProperty("percent_change_utc0_3d")
    private BigDecimal percentChangeUtc03d;
    
    @JsonProperty("price")
    private String price;
    
    @JsonProperty("price_change_today")
    private String priceChangeToday;
    
    @JsonProperty("rank")
    private Integer rank;
    
    @JsonProperty("logo")
    private String logo;
    
    @JsonProperty("id")
    private Long id;
    
    @JsonProperty("price_display")
    private String priceDisplay;
    
    @JsonProperty("price_display_cny")
    private BigDecimal priceDisplayCny;
    
    @JsonProperty("market_id")
    private Integer marketId;
    
    @JsonProperty("market_name")
    private String marketName;
    
    @JsonProperty("market_cap_usd")
    private String marketCapUsd;
    
    @JsonProperty("exchange_time")
    private String exchangeTime;
    
    @JsonProperty("percent_change_1h")
    private BigDecimal percentChange1h;
    
    @JsonProperty("percent_change_24h")
    private BigDecimal percentChange24h;
    
    @JsonProperty("name")
    private String name;
    
    @JsonProperty("volume_24h")
    private String volume24h;
    
    @JsonProperty("price_usd")
    private String priceUsd;
    
    @JsonProperty("available_supply")
    private Long availableSupply;
    
    @JsonProperty("alias")
    private String alias;
    
    @JsonProperty("currency")
    private String currency;
    
    @JsonProperty("pair")
    private String pair;
    
    @JsonProperty("percent_change_7d")
    private BigDecimal percentChange7d;
    
    @JsonProperty("category")
    private String category;
    
    @JsonProperty("search_field")
    private String searchField;
    
    /**
     * 获取数值形式的当前价格
     */
    public BigDecimal getNumericPrice() {
        try {
            return new BigDecimal(price);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取交易对基础货币
     */
    public String getBaseAsset() {
        if (pair != null &amp;&amp; pair.contains("/")) {
            return pair.split("/")[0];
        }
        return symbol.replace("USDT", "");
    }
    
    /**
     * 获取交易对报价货币
     */
    public String getQuoteAsset() {
        if (pair != null &amp;&amp; pair.contains("/")) {
            return pair.split("/")[1];
        }
        return "USDT";
    }
}</code></pre><h4>价格行情数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 价格行情数据模型
 */
@Data
public class TickerPrice {
    @JsonProperty("priceChange")
    private String priceChange;
    
    @JsonProperty("symbol")
    private String symbol;
    
    @JsonProperty("count")
    private Long count;
    
    @JsonProperty("openPrice")
    private String openPrice;
    
    @JsonProperty("lastId")
    private Long lastId;
    
    @JsonProperty("quoteVolume")
    private String quoteVolume;
    
    @JsonProperty("firstId")
    private Long firstId;
    
    @JsonProperty("volume")
    private String volume;
    
    @JsonProperty("weightedAvgPrice")
    private String weightedAvgPrice;
    
    @JsonProperty("lowPrice")
    private String lowPrice;
    
    @JsonProperty("highPrice")
    private String highPrice;
    
    @JsonProperty("closeTime")
    private Long closeTime;
    
    @JsonProperty("openTime")
    private Long openTime;
    
    @JsonProperty("priceChangePercent")
    private String priceChangePercent;
    
    @JsonProperty("lastPrice")
    private String lastPrice;
    
    /**
     * 获取数值形式的最后价格
     */
    public BigDecimal getNumericLastPrice() {
        try {
            return new BigDecimal(lastPrice);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取数值形式的涨跌幅
     */
    public BigDecimal getNumericPriceChangePercent() {
        try {
            return new BigDecimal(priceChangePercent);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取数值形式的交易量
     */
    public BigDecimal getNumericVolume() {
        try {
            return new BigDecimal(volume);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
}</code></pre><h4>最新价格数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 最新价格数据模型
 */
@Data
public class LastPrice {
    @JsonProperty("symbol")
    private String symbol;
    
    @JsonProperty("price")
    private String price;
    
    /**
     * 获取数值形式的价格
     */
    public BigDecimal getNumericPrice() {
        try {
            return new BigDecimal(price);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
}</code></pre><h4>K线数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import lombok.Data;

import java.math.BigDecimal;

/**
 * K线数据模型
 */
@Data
public class KLine {
    private Long openTime;
    private BigDecimal openPrice;
    private BigDecimal highPrice;
    private BigDecimal lowPrice;
    private BigDecimal closePrice;
    private BigDecimal volume;
    private Long closeTime;
    private BigDecimal quoteAssetVolume;
    private Integer numberOfTrades;
    private BigDecimal takerBuyBaseAssetVolume;
    private BigDecimal takerBuyQuoteAssetVolume;
    private String ignore;
    
    /**
     * 构造函数 - 从数组解析
     */
    public KLine(Object[] data) {
        if (data != null &amp;&amp; data.length &gt;= 11) {
            this.openTime = ((Number) data[0]).longValue();
            this.openPrice = new BigDecimal(data[1].toString());
            this.highPrice = new BigDecimal(data[2].toString());
            this.lowPrice = new BigDecimal(data[3].toString());
            this.closePrice = new BigDecimal(data[4].toString());
            this.volume = new BigDecimal(data[5].toString());
            this.closeTime = ((Number) data[6]).longValue();
            this.quoteAssetVolume = new BigDecimal(data[7].toString());
            this.numberOfTrades = ((Number) data[8]).intValue();
            this.takerBuyBaseAssetVolume = new BigDecimal(data[9].toString());
            this.takerBuyQuoteAssetVolume = new BigDecimal(data[10].toString());
            if (data.length &gt; 11) {
                this.ignore = data[11].toString();
            }
        }
    }
    
    /**
     * 计算振幅百分比
     */
    public BigDecimal getAmplitudePercent() {
        if (openPrice.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO;
        }
        return highPrice.subtract(lowPrice)
                .divide(openPrice, 4, BigDecimal.ROUND_HALF_UP)
                .multiply(BigDecimal.valueOf(100));
    }
    
    /**
     * 计算涨跌幅百分比
     */
    public BigDecimal getChangePercent() {
        if (openPrice.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO;
        }
        return closePrice.subtract(openPrice)
                .divide(openPrice, 4, BigDecimal.ROUND_HALF_UP)
                .multiply(BigDecimal.valueOf(100));
    }
}</code></pre><h4>交易数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 交易数据模型
 */
@Data
public class Trade {
    @JsonProperty("quoteQty")
    private String quoteQty;
    
    @JsonProperty("price")
    private String price;
    
    @JsonProperty("qty")
    private String qty;
    
    @JsonProperty("isBestMatch")
    private Boolean isBestMatch;
    
    @JsonProperty("id")
    private Long id;
    
    @JsonProperty("time")
    private Long time;
    
    @JsonProperty("isBuyerMaker")
    private Boolean isBuyerMaker;
    
    /**
     * 获取数值形式的价格
     */
    public BigDecimal getNumericPrice() {
        try {
            return new BigDecimal(price);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取数值形式的数量
     */
    public BigDecimal getNumericQty() {
        try {
            return new BigDecimal(qty);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取交易方向
     */
    public String getTradeDirection() {
        return Boolean.TRUE.equals(isBuyerMaker) ? "SELL" : "BUY";
    }
}</code></pre><h4>API响应包装类</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

/**
 * API通用响应包装类
 */
@Data
public class ApiResponse&lt;T&gt; {
    @JsonProperty("code")
    private Integer code;
    
    @JsonProperty("message")
    private String message;
    
    @JsonProperty("data")
    private T data;
    
    /**
     * 判断请求是否成功
     */
    public boolean isSuccess() {
        return code != null &amp;&amp; code == 200;
    }
}

/**
 * 交易对列表响应包装类
 */
@Data
class PairListResponse {
    @JsonProperty("total_count")
    private Integer totalCount;
    
    @JsonProperty("total_page")
    private Integer totalPage;
    
    @JsonProperty("list")
    private List&lt;CryptoPair&gt; list;
    
    @JsonProperty("fields")
    private List&lt;String&gt; fields;
}</code></pre><h3>3. HTTP客户端实现</h3><pre><code class="java">package com.stocktv.binance.client;

import com.fasterxml.jackson.core.type.TypeReference;
import com.stocktv.binance.config.BinanceConfig;
import com.stocktv.binance.model.*;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 币安数据HTTP客户端
 */
public class BinanceHttpClient {
    
    private static final Logger logger = LoggerFactory.getLogger(BinanceHttpClient.class);
    
    private final BinanceConfig config;
    private final CloseableHttpClient httpClient;
    
    public BinanceHttpClient(BinanceConfig config) {
        this.config = config;
        this.httpClient = config.getHttpClient();
    }
    
    /**
     * 获取交易对列表
     */
    public List&lt;CryptoPair&gt; getPairList(Integer page, Integer size) throws IOException, URISyntaxException {
        URIBuilder uriBuilder = new URIBuilder(config.BASE_URL + config.CRYPTO_PAIR_LIST)
                .addParameter("key", config.getApiKey())
                .addParameter("marketId", String.valueOf(config.BINANCE_MARKET_ID));
        
        if (page != null) {
            uriBuilder.addParameter("page", String.valueOf(page));
        }
        if (size != null) {
            uriBuilder.addParameter("size", String.valueOf(size));
        }
        
        URI uri = uriBuilder.build();
        
        ApiResponse&lt;PairListResponse&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;PairListResponse&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取 {} 个交易对", response.getData().getList().size());
            return response.getData().getList();
        } else {
            throw new RuntimeException("获取交易对列表失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取最新行情
     */
    public List&lt;TickerPrice&gt; getTickerPrice(List&lt;String&gt; symbols) throws IOException, URISyntaxException {
        if (symbols == null || symbols.isEmpty()) {
            throw new IllegalArgumentException("交易对列表不能为空");
        }
        
        // 限制最大数量
        if (symbols.size() &gt; 100) {
            symbols = symbols.subList(0, 100);
            logger.warn("交易对数量超过限制，只取前100个");
        }
        
        String symbolsStr = String.join(",", symbols);
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_TICKER_PRICE)
                .addParameter("key", config.getApiKey())
                .addParameter("symbols", symbolsStr)
                .build();
        
        ApiResponse&lt;List&lt;TickerPrice&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;TickerPrice&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取 {} 个交易对的最新行情", response.getData().size());
            return response.getData();
        } else {
            throw new RuntimeException("获取最新行情失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取最新价格
     */
    public List&lt;LastPrice&gt; getLastPrice(List&lt;String&gt; symbols) throws IOException, URISyntaxException {
        if (symbols == null || symbols.isEmpty()) {
            throw new IllegalArgumentException("交易对列表不能为空");
        }
        
        // 限制最大数量
        if (symbols.size() &gt; 100) {
            symbols = symbols.subList(0, 100);
            logger.warn("交易对数量超过限制，只取前100个");
        }
        
        String symbolsStr = String.join(",", symbols);
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_LAST_PRICE)
                .addParameter("key", config.getApiKey())
                .addParameter("symbols", symbolsStr)
                .build();
        
        ApiResponse&lt;List&lt;LastPrice&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;LastPrice&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取 {} 个交易对的最新价格", response.getData().size());
            return response.getData();
        } else {
            throw new RuntimeException("获取最新价格失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取K线数据
     */
    public List&lt;KLine&gt; getKlines(String symbol, String interval) throws IOException, URISyntaxException {
        if (symbol == null || symbol.trim().isEmpty()) {
            throw new IllegalArgumentException("交易对不能为空");
        }
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_GET_KLINES)
                .addParameter("key", config.getApiKey())
                .addParameter("symbol", symbol)
                .addParameter("interval", interval)
                .build();
        
        // K线数据返回的是数组的数组
        ApiResponse&lt;List&lt;Object[]&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;Object[]&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            List&lt;KLine&gt; klines = response.getData().stream()
                    .map(KLine::new)
                    .collect(Collectors.toList());
            logger.info("成功获取交易对 {} 的K线数据，共 {} 条", symbol, klines.size());
            return klines;
        } else {
            throw new RuntimeException("获取K线数据失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取近期成交
     */
    public List&lt;Trade&gt; getTrades(String symbol) throws IOException, URISyntaxException {
        if (symbol == null || symbol.trim().isEmpty()) {
            throw new IllegalArgumentException("交易对不能为空");
        }
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_GET_TRADES)
                .addParameter("key", config.getApiKey())
                .addParameter("symbol", symbol)
                .build();
        
        ApiResponse&lt;List&lt;Trade&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;Trade&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取交易对 {} 的成交数据，共 {} 条", symbol, response.getData().size());
            return response.getData();
        } else {
            throw new RuntimeException("获取成交数据失败: " + response.getMessage());
        }
    }
    
    /**
     * 搜索交易对
     */
    public List&lt;CryptoPair&gt; searchPairs(String keyword, Integer limit) throws IOException, URISyntaxException {
        List&lt;CryptoPair&gt; allPairs = getPairList(1, 1000); // 获取较多数据用于搜索
        
        return allPairs.stream()
                .filter(pair -&gt; 
                    pair.getSymbol().toLowerCase().contains(keyword.toLowerCase()) ||
                    pair.getName().toLowerCase().contains(keyword.toLowerCase()) ||
                    (pair.getSearchField() != null &amp;&amp; 
                     pair.getSearchField().toLowerCase().contains(keyword.toLowerCase())))
                .limit(limit != null ? limit : 10)
                .collect(Collectors.toList());
    }
    
    /**
     * 获取Top N市值的加密货币
     */
    public List&lt;CryptoPair&gt; getTopMarketCapPairs(int topN) throws IOException, URISyntaxException {
        List&lt;CryptoPair&gt; allPairs = getPairList(1, topN);
        
        // 按排名排序
        return allPairs.stream()
                .sorted((p1, p2) -&gt; {
                    if (p1.getRank() == null) return 1;
                    if (p2.getRank() == null) return -1;
                    return p1.getRank().compareTo(p2.getRank());
                })
                .limit(topN)
                .collect(Collectors.toList());
    }
    
    /**
     * 通用GET请求执行方法
     */
    private &lt;T&gt; T executeGetRequest(URI uri, TypeReference&lt;T&gt; typeReference) throws IOException {
        HttpGet request = new HttpGet(uri);
        logger.debug("执行币安API请求: {}", uri);
        
        try (CloseableHttpResponse response = httpClient.execute(request)) {
            int statusCode = response.getStatusLine().getStatusCode();
            String responseBody = EntityUtils.toString(response.getEntity());
            
            if (statusCode != 200) {
                throw new IOException("HTTP请求失败，状态码: " + statusCode);
            }
            
            logger.debug("币安API响应: {}", responseBody);
            return config.getObjectMapper().readValue(responseBody, typeReference);
        }
    }
    
    /**
     * 关闭HTTP客户端
     */
    public void close() throws IOException {
        if (httpClient != null) {
            httpClient.close();
        }
    }
}</code></pre><h3>4. WebSocket客户端实现</h3><pre><code class="java">package com.stocktv.binance.client;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.stocktv.binance.config.BinanceConfig;
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * 币安WebSocket实时数据客户端
 */
public class BinanceWebSocketClient {
    
    private static final Logger logger = LoggerFactory.getLogger(BinanceWebSocketClient.class);
    
    private final BinanceConfig config;
    private final ObjectMapper objectMapper;
    private WebSocketClient webSocketClient;
    private CountDownLatch connectionLatch;
    
    public BinanceWebSocketClient(BinanceConfig config) {
        this.config = config;
        this.objectMapper = config.getObjectMapper();
    }
    
    /**
     * 连接WebSocket服务器
     */
    public void connect() throws Exception {
        String wsUrl = config.WS_URL + "?key=" + config.getApiKey();
        URI serverUri = URI.create(wsUrl);
        
        connectionLatch = new CountDownLatch(1);
        
        webSocketClient = new WebSocketClient(serverUri) {
            @Override
            public void onOpen(ServerHandshake handshake) {
                logger.info("币安WebSocket连接已建立");
                connectionLatch.countDown();
            }
            
            @Override
            public void onMessage(String message) {
                try {
                    handleRealTimeMessage(message);
                } catch (Exception e) {
                    logger.error("处理WebSocket消息时出错", e);
                }
            }
            
            @Override
            public void onClose(int code, String reason, boolean remote) {
                logger.info("币安WebSocket连接已关闭: code={}, reason={}, remote={}", code, reason, remote);
            }
            
            @Override
            public void onError(Exception ex) {
                logger.error("币安WebSocket连接错误", ex);
            }
        };
        
        webSocketClient.connect();
        
        // 等待连接建立
        if (!connectionLatch.await(10, TimeUnit.SECONDS)) {
            throw new RuntimeException("WebSocket连接超时");
        }
    }
    
    /**
     * 处理实时消息
     */
    private void handleRealTimeMessage(String message) throws Exception {
        JsonNode jsonNode = objectMapper.readTree(message);
        
        // 解析实时行情数据
        if (jsonNode.has("symbol") || jsonNode.has("pid")) {
            RealTimeData realTimeData = parseRealTimeData(jsonNode);
            onRealTimeData(realTimeData);
        } else {
            logger.debug("收到其他消息: {}", message);
        }
    }
    
    /**
     * 解析实时数据
     */
    private RealTimeData parseRealTimeData(JsonNode jsonNode) {
        RealTimeData data = new RealTimeData();
        
        if (jsonNode.has("symbol")) {
            data.setSymbol(jsonNode.get("symbol").asText());
        }
        if (jsonNode.has("pid")) {
            data.setPid(jsonNode.get("pid").asText());
        }
        if (jsonNode.has("last_numeric")) {
            data.setLastPrice(jsonNode.get("last_numeric").asText());
        }
        if (jsonNode.has("bid")) {
            data.setBid(jsonNode.get("bid").asText());
        }
        if (jsonNode.has("ask")) {
            data.setAsk(jsonNode.get("ask").asText());
        }
        if (jsonNode.has("high")) {
            data.setHigh(jsonNode.get("high").asText());
        }
        if (jsonNode.has("low")) {
            data.setLow(jsonNode.get("low").asText());
        }
        if (jsonNode.has("pc")) {
            data.setPriceChange(jsonNode.get("pc").asText());
        }
        if (jsonNode.has("pcp")) {
            data.setChangePercent(jsonNode.get("pcp").asText());
        }
        if (jsonNode.has("turnover_numeric")) {
            data.setVolume(jsonNode.get("turnover_numeric").asText());
        }
        if (jsonNode.has("time")) {
            data.setTime(jsonNode.get("time").asText());
        }
        if (jsonNode.has("timestamp")) {
            data.setTimestamp(jsonNode.get("timestamp").asText());
        }
        
        return data;
    }
    
    /**
     * 处理实时数据
     */
    protected void onRealTimeData(RealTimeData data) {
        String symbol = data.getSymbol() != null ? data.getSymbol() : data.getPid();
        
        // 记录基础信息
        logger.debug("实时行情: {} - 价格: {}, 涨跌幅: {}%", 
            symbol, data.getLastPrice(), data.getChangePercent());
        
        // 价格预警逻辑
        try {
            double changePercent = Double.parseDouble(data.getChangePercent());
            if (Math.abs(changePercent) &gt; 5.0) {
                logger.warn("🚨 加密货币价格波动预警: {} 波动 {}%", symbol, changePercent);
            }
            
            // 大额交易监控
            if (data.getVolume() != null) {
                double volume = Double.parseDouble(data.getVolume());
                if (volume &gt; 1000000) { // 100万美元以上
                    logger.info("💰 大额交易: {} 成交额 ${}", symbol, volume);
                }
            }
        } catch (NumberFormatException e) {
            // 忽略转换错误
        }
    }
    
    /**
     * 发送消息
     */
    public void sendMessage(String message) {
        if (webSocketClient != null &amp;&amp; webSocketClient.isOpen()) {
            webSocketClient.send(message);
        }
    }
    
    /**
     * 关闭连接
     */
    public void close() {
        if (webSocketClient != null) {
            webSocketClient.close();
        }
    }
    
    /**
     * 实时数据模型
     */
    public static class RealTimeData {
        private String pid;
        private String symbol;
        private String lastPrice;
        private String bid;
        private String ask;
        private String high;
        private String low;
        private String priceChange;
        private String changePercent;
        private String volume;
        private String time;
        private String timestamp;
        
        // Getters and Setters
        public String getPid() { return pid; }
        public void setPid(String pid) { this.pid = pid; }
        public String getSymbol() { return symbol; }
        public void setSymbol(String symbol) { this.symbol = symbol; }
        public String getLastPrice() { return lastPrice; }
        public void setLastPrice(String lastPrice) { this.lastPrice = lastPrice; }
        public String getBid() { return bid; }
        public void setBid(String bid) { this.bid = bid; }
        public String getAsk() { return ask; }
        public void setAsk(String ask) { this.ask = ask; }
        public String getHigh() { return high; }
        public void setHigh(String high) { this.high = high; }
        public String getLow() { return low; }
        public void setLow(String low) { this.low = low; }
        public String getPriceChange() { return priceChange; }
        public void setPriceChange(String priceChange) { this.priceChange = priceChange; }
        public String getChangePercent() { return changePercent; }
        public void setChangePercent(String changePercent) { this.changePercent = changePercent; }
        public String getVolume() { return volume; }
        public void setVolume(String volume) { this.volume = volume; }
        public String getTime() { return time; }
        public void setTime(String time) { this.time = time; }
        public String getTimestamp() { return timestamp; }
        public void setTimestamp(String timestamp) { this.timestamp = timestamp; }
    }
}</code></pre>]]></description></item><item>    <title><![CDATA[八骏医疗云：解码眼科设备制造厂商的客户关]]></title>    <link>https://segmentfault.com/a/1190000047400097</link>    <guid>https://segmentfault.com/a/1190000047400097</guid>    <pubDate>2025-11-14 16:02:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在现代医疗行业，客户关系管理（CRM）已成为企业提升运营效率、优化服务体验和增强市场竞争力的关键工具。特别是对于眼科医疗设备企业而言，CRM系统不仅是客户信息的存储与管理平台，更是连接医疗设备销售、售后服务、客户关系维护及市场拓展的重要桥梁。<br/><img width="723" height="496" referrerpolicy="no-referrer" src="/img/bVdm25P" alt="image.png" title="image.png"/><br/>本文将围绕眼科医疗设备企业的CRM软件，深入分析其在客户关系管理中的核心功能与应用场景，帮助用户更好地理解该系统如何助力眼科医疗设备企业实现高效、精准的客户管理。</p><hr/><h2>一、眼科医疗设备企业CRM软件的核心特点</h2><p>眼科医疗设备企业的客户关系管理具有以下特点：</p><ol><li><strong>精准客户画像</strong>\<br/>企业需要根据客户类型（如医院、诊所、个体医生等）进行分类管理，CRM系统可以帮助企业快速建立客户档案，实现个性化的服务与营销策略。</li><li><strong>多渠道客户互动</strong>\<br/>医疗设备销售通常涉及医院采购、医生咨询、设备维护等多个环节，CRM系统需支持多渠道客户互动，包括电话、邮件、在线客服、社交媒体等。</li><li><strong>销售流程自动化</strong>\<br/>眼科设备销售流程通常包括产品介绍、报价、订单处理、售后服务等，CRM系统可自动触发销售流程，提升效率。</li><li><strong>数据分析与洞察</strong>\<br/>企业需要通过客户数据进行分析，以优化产品推广、售后服务和客户满意度。CRM系统提供数据可视化工具，帮助企业洞察客户需求和市场趋势。</li></ol><hr/><h2>二、八骏CRM医疗版的功能拆解</h2><h3>1. <strong>客户信息管理：精准标签与分类</strong></h3><p>八骏CRM医疗版支持对客户进行多维标签管理，如医院类型（综合医院、眼科专科医院等）、客户级别（VIP客户、普通客户）、设备需求类型（如白内障手术设备、角膜移植设备等）。通过标签体系，企业可实现客户的精准分类，制定差异化的服务策略。</p><h3>2. <strong>销售流程自动化：从线索获取到售后跟进</strong></h3><ul><li><strong>线索管理</strong>：系统支持线索来源的分类与跟踪，如医院采购、医生推荐、展会邀约等。</li><li><strong>销售流程自动化</strong>：系统可自动完成报价、合同签署、订单处理、发货通知等流程，减少人工干预，提升效率。</li><li><strong>售后跟进</strong>：客户购买设备后，系统可自动提醒售后人员进行设备安装、使用培训、维护记录等，提升客户满意度。</li></ul><h3>3. <strong>多渠道客户互动：提升客户体验</strong></h3><ul><li><strong>在线客服与消息通知</strong>：支持客户通过系统实时咨询、预约、反馈问题。</li><li><strong>客户反馈与评价管理</strong>：客户可对产品和服务进行评价，系统自动归类并分析反馈趋势，帮助企业优化产品和服务。</li><li><strong>社交媒体整合</strong>：系统支持客户在社交媒体上的互动，如客户留言、产品使用分享等，提升品牌曝光度。</li></ul><h3>4. <strong>数据分析与客户洞察</strong></h3><ul><li><strong>客户行为分析</strong>：系统能够分析客户购买记录、使用频率、售后服务反馈等数据，帮助企业挖掘客户需求。</li><li><strong>客户生命周期管理</strong>：系统可根据客户状态（如新客户、潜在客户、流失客户）进行生命周期管理，制定相应的跟进策略。</li><li><strong>销售漏斗分析</strong>：通过销售流程的可视化分析，企业可以优化销售策略，提升转化率。</li></ul><hr/><h2>三、总结：选择CRM软件的关键考量</h2><p>对于眼科医疗设备企业而言，选择合适的CRM软件至关重要：</p><ul><li><strong>精准客户管理</strong>：系统需支持多维度客户标签与分类，提升客户管理的精准度。</li><li><strong>销售流程自动化</strong>：自动化流程可减少人力成本，提升销售效率。</li><li><strong>多渠道客户互动</strong>：支持多种沟通方式，提升客户体验与满意度。</li><li><strong>数据分析与洞察</strong>：通过数据驱动决策，优化产品与服务策略。</li></ul><p>八骏CRM医疗版以其强大的客户管理功能、高效的工作流程和全面的数据分析能力，成为眼科医疗设备企业提升客户服务质量与市场竞争力的理想选择。</p><hr/><h2>四、结语</h2><p>在医疗设备行业，CRM软件不仅是工具，更是企业实现精细化运营和客户价值挖掘的核心引擎。八骏CRM医疗版以其专业的功能设计和灵活的行业适配性，为眼科医疗设备企业提供了可靠的支持，助力企业在激烈的市场竞争中脱颖而出。</p><p>选择合适的CRM软件，是企业数字化转型的关键一步。希望本文能为眼科医疗设备企业选择CRM系统提供有价值的参考。</p>]]></description></item><item>    <title><![CDATA[导师型领导指南 俞凡 ]]></title>    <link>https://segmentfault.com/a/1190000047400107</link>    <guid>https://segmentfault.com/a/1190000047400107</guid>    <pubDate>2025-11-14 16:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><em>本文介绍了导师型领导的管理应该如何指导团队成员的通用原则，分析了不同学员的类型，以及针对不同类型学员的应对方式。原文：<a href="https://link.segmentfault.com/?enc=If5x7oiSD1CtugRhoooV3g%3D%3D.pEkDeNjxN9MQD1b%2FfKTGTD4y1yGWNQFdqekXMzTONMNwCbvdZqEYsL9IteLtMOHrlWsDFOJ5yRDXbip40cFQZrKln0yY1GmMhRncgSlos3jizyOqWIPYeiP8160Wtd2G" rel="nofollow" title="How to be a good mentor for your whole team" target="_blank">How to be a good mentor for your whole team</a></em></blockquote><p>在理想的世界里，所有管理者都会秉持导师型工作理念。但在现实世界中并非如此，世界显然并不完美,许多管理者只是完成工作而已。他们确保团队能够出色执行任务，但与那些秉持导师理念的管理者不同，他们对帮助员工应对新挑战或抓住新机遇并不太感兴趣。</p><p>要预测哪种类型的管理者能带领团队取得更好的成绩，或者在年度评估时获得更高的评价，其实并不需要多么复杂的算法。</p><p>关键在于，导师指导并非适用于所有情况。诚然，有些指导原则是通用的，这里就直接总结要点：</p><ul><li><strong>一致性</strong>：按照固定节奏进行交流，但也要根据实际情况灵活安排临时会议。</li><li><a href="https://link.segmentfault.com/?enc=pUUECBnLRxjW9FT5CqfpGA%3D%3D.cLEjf6gwmLq31GFe6ovObdHoqa%2FTR6Mi%2F12Av24Pr4QG%2FePrK5v2UMXavc%2FxLyFGJB6bVefTPFVPusbEZg%2F%2FLQ%3D%3D" rel="nofollow" title="**积极倾听**" target="_blank"><strong>积极倾听</strong></a>：与被指导者会面时，要静下心来，全神贯注，关掉手机，关闭电脑，以减少干扰。在交流过程中做笔记并提出疑问。</li><li><strong>建设性反馈</strong>：单方面批评是不够的，要为被指导者在遭遇挫折后如何继续前进或下次如何做出不同选择提供切实可行的建议。</li><li><strong>适当的挑战</strong>：要鼓励被指导者超越舒适区，但要以同理心的方式进行。他们的处境和/或个性可能会限制他们能够或愿意做的事情。</li><li><strong>乐观（与现实相结合）</strong>：在大多数情况下，保持积极态度并专注于激励被指导者是最佳选择。但有时事情确实不会如愿发展。坦诚交流可以帮助他们认识到何时该放弃损失并尝试新的方法。</li></ul><p>但要对所管理的人员产生深远影响，必须根据每个个体的特点调整指导方式。有些人容易合作，而指导其他人可能就不那么直接了。我们基于自身经验，再加上来自<a href="https://link.segmentfault.com/?enc=P7jGypaPUe1p2W%2BQ4ZDL%2Bw%3D%3D.KsP0xAIVeI78FjRpBOxgwJI%2BLfYBXBtURI3ZMBosZeh8I2%2Fe4bkvCX0ZIGm%2FnwYj" rel="nofollow" title="全球导师网络" target="_blank">全球导师网络</a>和 <a href="https://link.segmentfault.com/?enc=Zue5Ba6%2FdDZxGvVSHGaX9g%3D%3D.zJ6XYgijCTnc0Q7Xe2ydoA4X27zm3TNx5rS%2BqA%2BblJRHDuVNoIIXY0lrBmNkhfY%2B" rel="nofollow" title="Together" target="_blank">Together</a> 组织的一些有用资料，编写了这份指南，旨在帮助大家了解常见的人员类型，并指导如何与每一种类型的人员建立导师与学员的关系。</p><h2>学员类型及需求</h2><p>旁注：虽然我们是从管理者与直接下属合作的角度来看待问题，但下面的所有内容都适用于各种各样的情况。所以，如果你以老师、教授、教练、资深同事、朋友或亲戚的身份指导某人，你的位置仍然是正确的。</p><h5>1. 明星学员</h5><p><strong>特点</strong>：雄心勃勃；专注于职业发展；做事有条理且注重细节。</p><p><strong>需要的是</strong>：关于优先事项的指导。</p><p>这些学员的积极性堪称爆棚。如果有什么需要的话，他们只是需要一些提醒来控制自己的进度，以免过度劳累而精疲力竭。你的职责是帮助他们明确、可实现的目标，并将其分解为阶段性目标。要监督他们的表现，如果偏离正轨要及时引导他们回到正确的轨道上来。由于有着如此强烈的动力和好奇心，如果不能持续专注于自己的“北极星”目标，他们可能会变得过于分散精力。但你也应该教导他们对自己要有耐心（他们往往在这方面存在困难！），如果内心的声音变得过于强烈，要让他们安静下来。当他们达成某个阶段性目标时，准备好与他们击掌庆祝。优秀人才都喜欢一些外部的认可。</p><h5>2. 未经雕琢的璞玉</h5><p><strong>特点</strong>：大量未实现的潜力；容易犯错（诚实、粗心的）；倾向于开放和好奇，但不一定活泼或外向。</p><p><strong>需要的是</strong>：一个练习对手。</p><p>璞玉未经雕琢时，并不一定清楚自己最终想要成为什么样的人。是成为注重策略的管理者？还是成为精通某项领域的顶尖高手？两种可能性都有！你可以通过为他们提供提升现有技能或学习新技能的机会，为他们的探索活动赋予方向。在他们处理超出自身能力范围的项目时，挑战并引导他们的思维。你还可以用你的人脉介绍一些能够帮助他们发展的人。</p><h5>3. 自我驱动者</h5><p><strong>特点</strong>：非常独立；想要自己全权负责，这样才能按照自己的方式去做；对于日常小事不寻求他人的建议。</p><p><strong>需要的是</strong>：灵感与自我反省。</p><p>自我驱动者具有强烈的自主意识、自我激励能力和自我推进能力，这对于注重指导管理的管理者来说可能颇具挑战性。因为他们倾向于自行设定目标，所以你的任务就是向他们展示各种可能性，然后让他们自行决定如何（以及是否）实现这些目标。另一种能够产生影响的方式是帮助他们发现自身可能未曾意识到的长处，并找出需要加强的弱点。帮助他们成为最好的自己，他们就能开创出最辉煌的职业生涯。</p><h5>4. 无所不知的人</h5><p><strong>特点</strong>：年龄比经理大，或者拥有更丰富的行业经验；事业有成；可能在团队之外也有自己的导师。</p><p><strong>需要的是</strong>：团结。</p><p>请不要往心里去，但这个人并不确定能从你这里学到多少东西。毕竟，他们在这一领域的从业时间比你长得多。像你这样的新手能给什么帮助呢？答案是合作。不要试图引导他们的职业生涯，而是要帮助他们找到能推进他们已有目标的项目。此外，把自己当作解决棘手职场问题的资源，比如与同事之间的冲突或预算削减等问题。你甚至可以提议“反向指导”，即他们指导你在某个你想要改进的领域进行提升。</p><h5>5. 流浪者</h5><p><strong>特点</strong>：表现不佳，潜力尚未开发；拖累工作；工作质量落后于团队的其他成员。</p><p><strong>需要的是</strong>：通往成功的路线图。</p><p>这个人可能面临诸多困境。你的首要任务是找出原因。比如，个人生活中的困难是否影响了他们的工作表现？例如，新添的宝宝或家庭中的重大疾病都可能对工作表现造成严重影响，又或者也许这个职位并不适合他们。一旦你们共同确定了根本原因，就一起制定改进计划或过渡计划，设定里程碑和目标日期。在过程中要庆祝他们的进步。如果他们出现失误，要让他们承担责任，但同时也要用无条件的同情来平衡你的建设性批评。</p><h5>6. 天生敏感特质</h5><p><strong>特点</strong>：性格敏感；容易产生防御心理；可能因批评而产生愤怒或绝望的情绪。</p><p><strong>需要的是</strong>：同情心和自信。</p><p>要留意这个人身上是否存在“<a href="https://link.segmentfault.com/?enc=UIO2WLJLAPKpb%2BYlx9eI%2Bg%3D%3D.GWzZKhWHxi7lI4KPgGhdeqmRIXROxCYFgcMuKxDTgDQBfS%2FzrrOVCbhBtWkn9DoGDvpHEdSWcn1pHD1rkhIZYMHDq6XxLIrNR6MjeusKk5ZSTShyDj5E2PFjhSU2pIGt" rel="nofollow" title="冒充者综合征" target="_blank">冒充者综合征</a>”迹象。很有可能他们觉得自己在能力方面力不从心，或者被繁重的工作压得喘不过气来。关键在于要认可他们的感受，但不要加以评判。首先，询问他们认为自己面临的最大障碍是什么，然后一起制定克服或绕过这些障碍的计划。要保持真诚 —— 不要过度称赞平庸的工作表现 —— 但要多给予积极反馈，以帮助提升他们的信心。如果能在公开场合（比如团队会议或 Slack 群组）对他们进行表扬，那就更好了。</p><h2>避免误区</h2><p>积极参与导师指导有助于你成长为优秀的领导者。同时，也能够帮助团队成员成长，而这恰恰是良好领导力的体现。但在你踏上这段旅程之前，有几个潜在隐患需要留意。</p><p>首先，要明确自己能够提供的服务范围，这既是为了自己的利益，也是为了学员们的利益。很容易就会过度投入，尤其是如果你天生倾向于服务型领导风格的话。一旦学员开始期望你有如此高强度的参与度，要收回这种投入就真的很难了。</p><p>尽早设定界限，并要具体明确。例如，你不会替他们撰写项目提案，但会乐意对草稿提供反馈。或者，你会倾听他们与同事之间的矛盾，并给出建议，但不会贸然去找那个人的经理来解决问题。</p><p>第二条建议来自研究者、作家兼知名人士布伦妮·布朗：<a href="https://link.segmentfault.com/?enc=dWXZnr07TySUgo2tJW%2FqFQ%3D%3D.33k86Eu5FZvC3CISqPuzqhBQtJ1HmoHVGzxNX%2BVeVEN5nzVRlY%2BDAE47YhZUzVs4WJFgGiiOKoprG7n7XfNX8Q%3D%3D" rel="nofollow" title="要学会恰当运用内疚情绪，但要避免对其进行羞辱" target="_blank">要学会恰当运用内疚情绪，但要避免对其进行羞辱</a>。两者的区别在于，内疚让我们明白自己犯了错误，需要做得更好；而羞耻则让我们觉得自己不配获得成功。</p><p>所以，当团队成员出现失误时，应从其行为或表现方面进行讨论，而非从其个人角度出发 —— 要说“那是个错误决定”，不要说“你是个糟糕的决策者”。正如布朗指出的，羞辱更有可能引发或加剧问题，而非解决问题。</p><p>现在就行动起来吧，去帮助某人让今天变得精彩！</p><hr/><blockquote>你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。为了方便大家以后能第一时间看到文章，请朋友们关注公众号"DeepNoMind"，并设个星标吧，如果能一键三连(转发、点赞、在看)，则能给我带来更多的支持和动力，激励我持续写下去，和大家共同成长进步！</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=pW8ORexPSSzB5g3YHYy1XA%3D%3D.broKzVfH3a8D6LVN2dPtvTsVNsVdEMiiDFCmGptMl9E%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[眼科设备制造厂商如何选对CRM？2025]]></title>    <link>https://segmentfault.com/a/1190000047400118</link>    <guid>https://segmentfault.com/a/1190000047400118</guid>    <pubDate>2025-11-14 16:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>引言：眼科设备制造行业的挑战与机遇</h2><p>在2025年，随着医疗技术的不断发展和市场竞争的加剧，眼科设备制造厂商面临着前所未有的挑战与机遇。从产品研发到市场开拓，从客户关系到售后服务，每一个环节都要求企业具备高效的管理工具和精准的销售策略。</p><p><strong>痛点分析：</strong></p><ul><li><strong>客户需求多样化</strong>：客户对产品性能、价格、售后体验等有较高要求。</li><li><strong>销售流程复杂</strong>：从需求挖掘、方案制定、合同签订到交付服务，流程繁琐。</li><li><strong>数据管理滞后</strong>：缺乏系统化的客户数据管理，影响销售决策和客户体验。</li><li><strong>售后服务压力大</strong>：设备维护、技术支持、客户反馈等环节需持续跟踪。</li></ul><hr/><h2>一、眼科设备制造行业销售特点分析</h2><h3>1.1 客户画像复杂</h3><p>眼科设备客户主要包括医院、诊所、医疗器械公司等，客户群体具有专业性强、需求明确、合同金额大等特点。</p><h3>1.2 需求周期长</h3><p>从产品介绍、方案设计到签订合同，通常需要数周甚至数月，周期较长，对CRM系统的时间管理能力提出了较高要求。</p><h3>1.3 交互合作频繁</h3><p>销售、市场、研发、售后等多个部门频繁协作，信息共享和流程协同至关重要。</p><h3>1.4 服务不可替代性强</h3><p>眼科设备具有较高的技术壁垒，客户对售后服务的满意度直接影响品牌口碑与复购率。</p><hr/><h2>二、眼科设备制造厂商的智能解决方案</h2><h3>2.1 产品功能概述</h3><p>以<strong>八骏CRM医疗版</strong>为例，这是一款专为医疗行业定制的客户关系管理软件，其核心功能包括：<br/><img width="723" height="498" referrerpolicy="no-referrer" src="/img/bVdm254" alt="image.png" title="image.png"/></p><ul><li><strong>客户信息管理</strong>：支持客户画像、历史沟通、订单记录、合同管理等，实现客户数据的标准化和可视化。</li><li><strong>销售流程自动化</strong>：从线索获取、商机跟踪、销售流程到合同签订，一键完成，提升销售效率。</li><li><strong>多部门协同管理</strong>：支持销售、市场、研发、售后等部门协同工作，提高跨部门协作效率。</li><li><strong>数据分析与洞察</strong>：提供客户行为分析、销售趋势预测、潜在客户挖掘等功能，辅助决策。</li><li><strong>合规与审计</strong>：满足医疗行业严格的合规要求，支持审计追踪和数据安全。</li></ul><h3>2.2 功能拆解与适用性分析</h3><h4>2.2.1 客户信息管理</h4><ul><li><strong>客户画像</strong>：支持按医院、科室、医生等维度建立客户档案，提升精准营销能力。</li><li><strong>沟通记录</strong>：记录客户沟通内容、沟通时间、沟通方式等，便于后续跟进与服务。</li><li><strong>合同管理</strong>：支持合同签订、履约跟踪、付款记录，确保合同执行透明化。</li></ul><h4>2.2.2 销售流程自动化</h4><ul><li><strong>线索管理</strong>：自动识别潜在客户，推送至销售团队。</li><li><strong>商机跟踪</strong>：支持商机状态更新、责任人分配，确保销售进度可视化。</li><li><strong>销售流程</strong>：从需求分析、方案推荐、合同签订到售后服务，全流程自动化，减少人工干预。</li></ul><h4>2.2.3 多部门协同</h4><ul><li><strong>销售与市场协同</strong>：支持销售团队与市场团队同步客户信息，提升营销效率。</li><li><strong>研发与销售协同</strong>：研发团队可根据销售反馈优化产品，提升产品竞争力。</li><li><strong>售后与客户协同</strong>：售后团队可实时反馈客户使用问题，提升客户满意度。</li></ul><h4>2.2.4 数据分析与洞察</h4><ul><li><strong>客户行为分析</strong>：分析客户购买偏好、使用频次、售后服务反馈等，辅助精准营销。</li><li><strong>销售趋势预测</strong>：基于历史数据预测销售趋势，优化资源配置。</li><li><strong>潜在客户挖掘</strong>：基于客户画像与行为数据，识别潜在客户，提升获客效率。</li></ul><h4>2.2.5 合规与安全</h4><ul><li><strong>医疗行业合规</strong>：符合国家医疗行业数据安全与隐私保护的相关法规。</li><li><strong>审计追踪</strong>：支持全流程审计，确保数据真实、可追溯。</li></ul><hr/><h2>三、选对CRM的四个关键要素</h2><h3>3.1 功能全面性</h3><ul><li>确保CRM覆盖客户管理、销售、售后、数据分析等核心模块，满足医疗行业的复杂需求。</li></ul><h3>3.2 可扩展性</h3><ul><li>系统需具备良好的可扩展性，以适应企业业务增长与功能升级。</li></ul><h3>3.3 安全与合规</h3><ul><li>保障客户数据安全，符合医疗行业的合规要求，减少法律风险。</li></ul><h3>3.4 用户友好性</h3><ul><li>系统界面简洁直观，操作便捷，提升用户使用效率。</li></ul><hr/><h2>四、结语：2025年眼科设备制造厂商的CRM战略</h2><p>在2025年，眼科设备制造厂商的客户关系管理不仅是提升销售效率的工具，更是企业实现长期发展的核心驱动。选择一款合适的CRM系统，可以帮助企业更高效地管理客户、优化销售流程、提升客户满意度，并在激烈的市场竞争中脱颖而出。</p>]]></description></item><item>    <title><![CDATA[【Github热门项目】DeepSeek]]></title>    <link>https://segmentfault.com/a/1190000047399607</link>    <guid>https://segmentfault.com/a/1190000047399607</guid>    <pubDate>2025-11-14 15:09:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>【Github热门项目】DeepSeek-OCR项目上线即突破7k+星！突破10倍无损压缩，重新定义文本-视觉信息处理</h2><p>当“8000行代码手搓ChatGPT”的热度还未褪去，大模型领域又迎来新惊喜——DeepSeek团队于10月20日开源的 <strong>DeepSeek-OCR</strong>，以“<strong>上下文光学压缩</strong>”为核心突破，重新定义了OCR（光学字符识别）的效率边界。这款仅30亿参数量的模型，不仅能以100个视觉token超越传统模型256个token的性能，更在单张A100-40G显卡上实现每日20万页文档处理能力，为长文本压缩与大模型效率优化提供了全新思路。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399609" alt=" " title=" "/></p><p><strong>论文标题：DeepSeek-OCR:ContextsOpticalCompression</strong></p><p><a href="https://link.segmentfault.com/?enc=niPupz46Z81WfpfrTP9WlA%3D%3D.wEl5InJ2%2FVZi1BhRCvtxHyTyW6UvuirSyGGpg1m%2BZvurhAb63jVvzsMAayb4Fz43" rel="nofollow" target="_blank">👉原项目地址</a></p><p><a href="https://link.segmentfault.com/?enc=fLDBqydgJhGErX2GAXPgmg%3D%3D.J3NN1Irst42Vf%2B3uNu4A12Rhfsfy7guMLfW8bI4Xj5P%2FLZrYNAKUVrd4107oBQMHVEN1mgVzSIFgUOW9FhehHHXwtxdcGjvwLWnIimLoyn4%3D" rel="nofollow" target="_blank">👉Github论文</a></p><p><a href="https://link.segmentfault.com/?enc=rWWJ15WIxMOEhZDfGVEndw%3D%3D.r1zU3%2FFklQD4eEyaDShB603nYGx20Ek9W%2BP0l4eOeNbgvjpkl9SLBzBCj1nYhmFv" rel="nofollow" target="_blank">👉HuggingFace</a></p><p><a href="https://link.segmentfault.com/?enc=8b6b9GdR70jec9BUeU4yXw%3D%3D.OIaSgCApoFoxC4aqwwyNRrgbG9n0qBni1ZQkKBIWVAlC8lXnwgJTMtedpXf%2FjjmXpG9L155Rj0OM2rM0ek1%2FtPwmpUyDuLh8UTCJYnjj7sU8jtMSfFlZLmVzzi4cQ8mrq6%2Fd2b0H32bbsub1nDZCiVIoAt2RSgrX1kSVKTWY%2Foc%3D" rel="nofollow" target="_blank">👉Lab4AI</a></p><p>DeepSeek-OCR的核心创新在于利用视觉模态作为文本信息的高效压缩媒介。研究表明，一张包含文档文本的图像可以用比等效文本少得多的Token来表示丰富信息，这意味着通过视觉Token进行光学压缩可以实现极高的压缩率。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399610" alt=" " title=" " loading="lazy"/></p><p>其核心表现可概括为<strong>两组关键数据</strong>：</p><ul><li><strong>压缩比与精度</strong>的平衡：当文本token数量是视觉token的10倍以内（即压缩比＜10×）时，OCR解码精度高达97%；即便压缩比提升至20×，精度仍能维持在60%左右，远超行业同类模型的衰减速度。</li><li><strong>极致的token</strong>效率：在OmniDocBench基准测试中，它仅用100个视觉token就超越了需256个token的GOT-OCR2.0；面对MinerU2.0平均每页6000+token的消耗，它用不到800个token就能实现更优性能——相当于将文本处理的“token成本”降低了7-20倍。</li></ul><p>这种突破的价值不仅在于OCR本身：对于受限于“长上下文处理能力”的大模型而言，DeepSeek-OCR提供了一种新解法——<strong>将超长文本转化为视觉图像后压缩输入，可大幅减少LLM的token消耗，为处理百万字级文档、历史上下文记忆等场景打开了通道</strong>。</p><h3>DeepEncoder：编码器+MoE解码器</h3><p>为实现“高压缩比、低资源消耗”的目标，DeepSeek-OCR采用了“DeepEncoder（编码器）+DeepSeek3B-MoE（解码器）”的端到端架构，两者各司其职又高度协同。</p><h4>1. DeepEncoder</h4><p>作为模型的“压缩核心”，DeepEncoder需同时满足“<strong>高分辨率处理、低激活开销、少token输出</strong>”三大需求，其架构设计暗藏巧思：</p><ul><li>双组件串联：由8000万参数的<strong>SAM-base（视觉感知）</strong>和3亿参数的<strong>CLIP-large（视觉知识）</strong>串联而成。SAM-base用“窗口注意力”处理高分辨率图像细节，CLIP-large用“全局注意力”提取语义关联，兼顾精度与全局理解。</li><li>16倍token压缩：在双组件之间，通过<strong>2层卷积模块</strong>对视觉token进行16倍下采样。例如，1024×1024的图像先被划分为4096个patchtoken，经压缩后仅保留256个有效token，既控制了内存消耗，又不丢失关键信息。</li><li>多分辨率适配：支持Tiny（512×512）、Small（640×640）、Base（1024×1024）、Large（1280×1280）四种原生分辨率。还能通过“Gundam模式”实现超高分辨率输入（如报纸图像）的瓦片化处理，单个模型即可覆盖从手机截图到大幅文档的全场景需求。</li></ul><h4>2. DeepSeek3B-MoE</h4><p>解码器采用<strong>混合专家（MoE）架构</strong>，在“性能与效率”间找到了平衡点：</p><ul><li>参数激活策略：虽然总参数量为3B，但推理时仅激活64个“路由专家”中的6个，外加2个“共享专家”，实际参与计算的参数仅5.7亿——相当于用“500M模型的资源消耗”，获得了3B模型的表达能力。</li><li>快速文本重建：从DeepEncoder输出的压缩视觉token中，解码器能精准重建原始文本，甚至支持markdown格式转换、图表结构化提取等复杂任务，无需额外的后处理模块。</li></ul><h3>性能表现</h3><p>实验数据令人印象深刻：当文本Token数量在视觉Token的10倍以内（压缩率&lt;10×）时，模型的解码精度可达97%；即使在压缩率达到20×的情况下，OCR准确率仍保持在约60%。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399611" alt=" " title=" " loading="lazy"/></p><p>在实际应用层面，DeepSeek-OCR展现出惊人效率：在OmniDocBench基准测试中，仅使用<strong>100个视觉Token就超过了GOT-OCR2.0</strong>（每页256个Token）的表现；使用<strong>不到800个视觉Token就优于MinerU2.0</strong>（平均每页超过6000个Token）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399612" alt=" " title=" " loading="lazy"/></p><h3>大模型实验室Lab4AI</h3><p>值得一提的是，大模型技术社区「大模型实验室Lab4AI」已经第一时间上架了 <strong>DeepSeek-OCR论文及相关技术资料</strong>。该社区的技术团队正在积极复现论文中的创新方法，验证其在实际场景中的表现。大模型实验室作为专注于AI前沿技术的内容社区，将持续跟踪DeepSeek-OCR的最新进展，并<strong>分享更多实践案例和技术分析</strong>。欢迎各位开发者关注社区动态，共同探索这一创新技术的更多应用可能。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399613" alt=" " title=" " loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[CRM/ERP “内控 + 外联” 全业]]></title>    <link>https://segmentfault.com/a/1190000047399626</link>    <guid>https://segmentfault.com/a/1190000047399626</guid>    <pubDate>2025-11-14 15:08:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3>供应链与客户生命周期绑定能力横评：超兔、Salesforce、钉钉、用友、SAP的核心差异与场景适配</h3><p>在数字化转型的深水区，企业的核心竞争力已从“单一环节效率”转向“全链路协同能力”——<strong>立足上下游协同体系，打通“内控+外联”业务链路，最终实现供应链与客户生命周期的深度绑定</strong>，成为企业应对不确定性的关键。</p><p>本文选取<strong>超兔、Salesforce、钉钉、用友、</strong> <strong>SAP</strong>五大主流厂商，围绕三大核心维度展开横向对比：</p><ol><li><strong>上下游协同体系的构建能力</strong>（连接供应商、企业、客户的效率与深度）；</li><li><strong>“内控+外联”全业务链路的打通能力</strong>（内部流程自动化与外部生态集成的闭环）；</li><li><strong>供应链与客户生命周期的绑定能力</strong>（需求响应速度、数据联动深度、AI决策支持）。</li></ol><h2>一、对比框架与核心指标说明</h2><p>为确保对比的专业性与针对性，我们构建了“<strong>3大维度+9项细分指标</strong>”的评估体系（见表1），覆盖“连接-打通-绑定”的全流程价值。</p><table><thead><tr><th><strong>一级维度</strong></th><th><strong>二级细分指标</strong></th></tr></thead><tbody><tr><td>上下游协同体系</td><td>1. 协同场景覆盖（供应商/客户/产业链）；2. 数据打通深度（系统/流程/权限）；3. 生态兼容性（第三方系统对接）</td></tr><tr><td>“内控+外联”链路打通</td><td>1. 内部流程自动化（销售/生产/财务）；2. 外部系统集成（ERP/WMS/电商）；3. 数据一致性（跨系统同步率）</td></tr><tr><td>供应链与客户生命周期绑定</td><td>1. 需求响应速度（订单-履约周期）；2. 全生命周期数据联动（客户-供应链数据打通）；3. AI驱动决策（预测/优化）</td></tr></tbody></table><h2>二、各维度横向对比与深度分析</h2><h3>（一）上下游协同体系：从“信息传递”到“业务共生”的能力差异</h3><p>上下游协同的核心是<strong>打破企业边界，让供应商/客户成为业务流程的参与者</strong>，而非“信息接收方”。五大厂商的能力差异集中在“协同场景的覆盖深度”与“数据权限的精细化管理”。</p><h4>1. 超兔：OpenCRM驱动的“伙伴共生平台”</h4><p>超兔的核心是“OpenCRM业务伙伴共生平台”，直接连接企业内部CRM与上下游伙伴的业务系统，实现“询价-采购-发货-对账-售后”的全流程协同：</p><ul><li><strong>上游协同</strong>：企业通过OpenCRM向供应商发送询价请求，供应商实时响应报价；系统自动匹配历史供应商、比价生成采购单，并通过“供应商评级”（交货及时率/良品率）优化合作；</li><li><strong>下游协同</strong>：客户可在线确认报价/订单，扫码查看物流进度，验收后自动触发对账；</li><li><strong>核心优势</strong>：<strong>三流合一对账</strong>（货/款/票一致性）与<strong>全程追溯</strong>（业务节点可回溯），解决了中小制造企业“供应商分散、对账混乱”的痛点。</li><li><strong>案例</strong>：某机械制造企业通过超兔OpenCRM连接120家供应商，采购周期从15天缩短至7天，对账误差率从8%降至0.5%。</li></ul><h4>2. Salesforce：全球化生态的“Customer 360”</h4><p>作为全球CRM龙头，Salesforce的协同能力聚焦“全球化跨系统整合”：</p><ul><li><strong>核心载体</strong>：Customer 360平台整合销售、服务、营销模块，提供统一客户视图；通过<strong>AppExchange开放生态</strong>（超6000款第三方应用）对接SAP、Oracle等ERP系统，实现“总部-区域-供应商-客户”的全球数据同步；</li><li><strong>差异化能力</strong>：<strong>本地化与合规适配</strong>（支持多语言/多时区/GDPR），解决跨国企业“数据割裂、合规风险”的问题；</li><li><strong>案例</strong>：某跨国车企通过Salesforce连接全球500家供应商，售后问题解决周期从72小时缩短至24小时，全球供应链数据同步率达99%。</li></ul><h4>3. 钉钉：群场景下的“轻量级产业链协同”</h4><p>钉钉的协同能力基于“群+业务组件”，将采购、配货等业务流迁移至群内，降低跨组织协作门槛：</p><ul><li><strong>核心场景</strong>：通过“供应商群”实现“一点配货调货”（如一汽大众连接上千家供应商，群内实时同步生产排期）；通过“宜搭低代码平台”让供应商自建MES系统，确保供应链数据实时同步；</li><li><strong>优势</strong>：<strong>轻量化与易用性</strong>，适合产业链环节多、协作方IT能力弱的企业（如制造业、零售）；</li><li><strong>局限</strong>：深度协同需依赖低代码二次开发，对复杂业务的支撑能力不足。</li></ul><h4>4. 用友：B2B全链路的“供应商-经销商协同”</h4><p>用友的协同能力聚焦“B2B供应链闭环”：</p><ul><li><strong>上游</strong>：通过“电子采购门户”发布需求，管理寻源与采购执行；支持供应商评估、合同管理，建立长期合作关系；</li><li><strong>下游</strong>：通过“电子销售管理”整合经销商网络，实现自动化分销与服务管理；</li><li><strong>核心优势</strong>：<strong>与财务系统深度集成</strong>（如U8+的财务-供应链一体化），解决“业务与财务数据割裂”的问题；</li><li><strong>案例</strong>：某消费品企业通过用友U8+连接200家经销商，分销订单处理效率提升60%，库存周转率提升35%。</li></ul><h4>5. SAP：端到端的“供应商全生命周期管理”</h4><p>SAP的协同能力以“供应商全生命周期”为核心：</p><ul><li><strong>核心流程</strong>：从供应商准入（资质审核）、寻源（在线询比价）、合作（订单执行）到绩效监控（交付率/良品率），实现全流程数字化；</li><li><strong>差异化能力</strong>：<strong>合规风控机制</strong>（贸易合规检查、黑白名单校验），提升供应链韧性；</li><li><strong>案例</strong>：通达创智通过SAP构建“智能制造平台”，连接海外生产基地与全球供应商，供应链交付达成率从85%提升至98%。</li></ul><h4>上下游协同能力对比表（表2）</h4><table><thead><tr><th><strong>品牌</strong></th><th>协同场景覆盖</th><th>数据打通深度</th><th>生态兼容性</th></tr></thead><tbody><tr><td>超兔</td><td>供应商-客户全流程</td><td>三流合一（货/款/票）</td><td>支持RPA/ERP对接</td></tr><tr><td>Salesforce</td><td>全球化跨系统</td><td>统一客户视图</td><td>AppExchange生态</td></tr><tr><td>钉钉</td><td>产业链群协同</td><td>群内业务组件</td><td>宜搭低代码扩展</td></tr><tr><td>用友</td><td>B2B端到端</td><td>财务-供应链一体化</td><td>U8+/YonSuite生态</td></tr><tr><td>SAP</td><td>供应商全生命周期</td><td>端到端系统集成</td><td>ERP/SRM/SCM整合</td></tr></tbody></table><h3>（二）“内控+外联”链路打通：从“信息孤岛”到“全流程闭环”的效率差异</h3><p>“内控+外联”的核心是<strong>消除内部部门墙与外部系统壁垒</strong>，实现“获客-转化-履约-复购”的全流程数据闭环。五大厂商的差异集中在“内部流程自动化程度”与“外部系统集成的便捷性”。</p><h4>1. 超兔：全业务一体云的“底层数据打通”</h4><p>超兔的“全业务一体云”涵盖CRM、进销存、生产工单、财务等模块，实现<strong>内部流程的“无代码联动”</strong> ：</p><ul><li><strong>内控自动化</strong>：订单录入后自动拆解BOM清单，同步库存模块检查原材料缺口，触发智能采购计划；生产工单通过手机扫码完成领料、报工、入库，数据自动沉淀为“生产资产”（工时/良品率）；</li><li><strong>外联集成</strong>：通过RPA对接电商平台（如淘宝/京东）、国税开票机器人，实现订单自动同步；</li><li><strong>核心优势</strong>：<strong>全链路数据一致性</strong>（跨模块数据同步率100%），解决了中小企“跨部门人工核对”的痛点。</li></ul><h4>2. Salesforce：AI驱动的“流程自动化”</h4><p>Salesforce通过<strong>Sales Cloud+Service Cloud+Einstein</strong> <strong>GPT</strong>实现内部流程的“智能自动化”：</p><ul><li><strong>内控自动化</strong>：Einstein GPT自动生成销售话术、预测客户需求（如“客户A下周可能下单”）；Service Cloud自动分配售后工单，根据客户价值优先处理；</li><li><strong>外联集成</strong>：通过AppExchange对接ERP（如SAP）、WMS（如Oracle），实现订单-库存-物流的实时同步；</li><li><strong>核心优势</strong>：<strong>AI</strong> <strong>对流程的“预测性优化”</strong> ，而非“被动执行”。</li></ul><h4>3. 钉钉：低代码驱动的“内部协同”</h4><p>钉钉的“内控+外联”能力基于<strong>宜搭</strong> <strong>低代码</strong> <strong>平台</strong>：</p><ul><li><strong>内控自动化</strong>：通过宜搭搭建“销售订单-库存-财务”流程，自动触发库存检查与财务记账；</li><li><strong>外联集成</strong>：通过“群机器人”对接外部系统（如快递100查物流），实现信息实时推送；</li><li><strong>优势</strong>：<strong>快速部署</strong>（低代码无需IT开发），适合流程灵活的中小企业；</li><li><strong>局限</strong>：复杂流程（如生产排程）需依赖第三方系统。</li></ul><h4>4. 用友：财务-供应链的“强集成”</h4><p>用友的“内控+外联”聚焦“财务与供应链的一体化”：</p><ul><li><strong>内控自动化</strong>：U8+的“财务-供应链”模块实现“发货后自动生成应收账单”，支持多期回款自动拆分；</li><li><strong>外联集成</strong>：对接B2B订货平台（如友商网）、新零售系统（如天猫超市），实现订单自动同步；</li><li><strong>核心优势</strong>：<strong>财务业务联动</strong>，解决“财务数据滞后于业务”的问题。</li></ul><h4>5. SAP：端到端的“系统整合”</h4><p>SAP通过<strong>SAP Business Suite</strong>整合ERP、CRM、SRM、SCM等系统，实现“内控+外联”的全链路打通：</p><ul><li><strong>内控自动化</strong>：有限产能高级排程（APS）平衡设备/人员/物料，生成最优生产计划；</li><li><strong>外联集成</strong>：通过SAP BTP的CPI解决方案对接外部系统（如电商平台、物流商），实现数据实时同步；</li><li><strong>核心优势</strong>：<strong>全链路可视化</strong>（供应链控制塔实时监控履约状态），适合大型企业的复杂流程。</li></ul><h4>“内控+外联”链路流程图</h4><p>以下是超兔与SAP的流程对比（以“订单履约”为例）：</p><p><strong>超兔的“内控+外联”流程</strong>：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399628" alt="" title=""/></p><pre><code>sequenceDiagram
    participant 客户 as 客户
    participant 超兔CRM as 超兔CRM
    participant 库存模块 as 库存模块
    participant 采购模块 as 采购模块
    participant 供应商 as 供应商
    participant 财务模块 as 财务模块

    客户-&gt;&gt;超兔CRM: 下达订单
    超兔CRM-&gt;&gt;库存模块: 检查库存
    库存模块-&gt;&gt;超兔CRM: 库存不足
    超兔CRM-&gt;&gt;采购模块: 触发智能采购（匹配历史供应商）
    采购模块-&gt;&gt;供应商: 发送采购请求
    供应商-&gt;&gt;客户: 直接发货（供应商直发）
    客户-&gt;&gt;超兔CRM: 确认收货
    超兔CRM-&gt;&gt;财务模块: 生成应收账单</code></pre><p><strong>SAP</strong> <strong>的“内控+外联”流程</strong>：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399629" alt="" title="" loading="lazy"/></p><pre><code>sequenceDiagram
    participant 客户 as 客户
    participant SAP CRM as SAP CRM
    participant SAP SCM as SAP SCM
    participant SAP ERP as SAP ERP
    participant 供应商 as 供应商
    participant 物流商 as 物流商

    客户-&gt;&gt;SAP CRM: 下达订单
    SAP CRM-&gt;&gt;SAP SCM: 需求传递
    SAP SCM-&gt;&gt;SAP ERP: 检查库存/产能
    SAP ERP-&gt;&gt;供应商: 发送采购订单
    供应商-&gt;&gt;物流商: 发货
    物流商-&gt;&gt;客户: 配送
    客户-&gt;&gt;SAP CRM: 确认收货
    SAP CRM-&gt;&gt;SAP ERP: 生成发票</code></pre><h3>（三）供应链与客户生命周期绑定：从“被动响应”到“主动预测”的价值差异</h3><p>供应链与客户生命周期绑定的核心是“客户需求驱动供应链响应”，而非“供应链计划主导客户需求”。五大厂商的差异集中在“需求预测的准确性”与“全生命周期数据的联动深度”。</p><h4>1. 超兔：客户需求触发的“智能供应链”</h4><p>超兔通过“客户订单-供应链响应”的动态联动，实现“按需履约”：</p><ul><li><strong>需求响应</strong>：供应商直发的采购单执行过程是供应商根据采购单，直接发货给客户，省略了发货给我方的环节，在电商领域或大型设备贸易领域使用较多。</li><li><strong>数据联动</strong>：客户历史订单（如“客户A每年3月采购100台设备”）自动同步至供应链模块，提前安排生产/采购；</li><li><strong>案例</strong>：某电子企业通过超兔“供应商直发”模式，客户复购率从30%提升至55%。</li></ul><h4>2. Salesforce：AI预测的“动态匹配”</h4><p>Salesforce的<strong>Einstein</strong> <strong>AI</strong>通过分析客户行为（如浏览记录、售后反馈），预测客户需求：</p><ul><li><strong>需求预测</strong>：Einstein AI预测“客户B下个月可能采购50台电脑”，同步至供应链模块调整库存；</li><li><strong>数据联动</strong>：Customer 360平台整合客户“售前（营销触达）-售中（订单）-售后（报修）”数据，供应链模块实时获取“客户满意度”，优化后续履约策略；</li><li><strong>核心优势</strong>：<strong>AI</strong> <strong>对客户需求的“个性化预测”</strong> ，而非“批量预测”。</li></ul><h4>3. 钉钉：销售-库存-财务的“数据闭环”</h4><p>钉钉通过“销售-库存-财务”的数据打通，实现“客户需求的实时响应”：</p><ul><li><strong>需求响应</strong>：销售可查看客户历史订单与库存状态（如“客户C去年采购的100台设备，现在库存还有20台”），快速给出“现货/期货”报价；</li><li><strong>数据联动</strong>：财务直接调取合同签约记录，避免“客户已付款但财务未入账”的问题；</li><li><strong>优势</strong>：<strong>数据的“可见性”</strong> ，适合强调“快速响应”的零售企业。</li></ul><h4>4. 用友：CRM全生命周期的“营销供应链联动”</h4><p>用友通过<strong>CRM</strong> <strong>全生命周期管理</strong> <strong>+营销</strong> <strong>数智化</strong> <strong>服务</strong>，实现“客户需求与供应链的联动”：</p><ul><li><strong>需求响应</strong>：CRM系统识别“客户D处于‘流失预警’阶段”，自动推送“折扣券”，并同步供应链模块准备库存；</li><li><strong>数据联动</strong>：营销活动数据（如“双11促销带来1000个订单”）自动同步至供应链，调整生产计划；</li><li><strong>核心优势</strong>：<strong>营销与供应链的“双向驱动”</strong> （营销反哺供应链，供应链支撑营销）。</li></ul><h4>5. SAP：端到端的“需求排程”</h4><p>SAP通过“可承诺量（aATP）”实现“客户需求与供应链的动态匹配”：</p><ul><li><strong>需求响应</strong>：客户下单时，aATP实时计算“可用库存+未来产能”，给出准确交期（如“下周三可发货”）；</li><li><strong>数据联动</strong>：客户门户实时展示订单进度（如“已生产30%，明天发货”），售后工单自动关联产品BOM（如“客户E的设备故障，需更换零件X”）；</li><li><strong>核心优势</strong>：<strong>供应链的“承诺能力”</strong> ，适合对“交期准确性”要求高的制造业（如汽车/电子）。</li></ul><h4>供应链与客户生命周期绑定能力雷达图（表3）</h4><p>以下是各品牌在“需求响应速度、数据联动深度、AI决策能力”三项指标的评分（1-10分）：</p><table><thead><tr><th><strong>品牌</strong></th><th>需求响应速度</th><th>数据联动深度</th><th>AI决策能力</th></tr></thead><tbody><tr><td>超兔</td><td>8</td><td>9</td><td>7</td></tr><tr><td>Salesforce</td><td>9</td><td>10</td><td>10</td></tr><tr><td>钉钉</td><td>7</td><td>8</td><td>6</td></tr><tr><td>用友</td><td>8</td><td>9</td><td>8</td></tr><tr><td>SAP</td><td>10</td><td>10</td><td>9</td></tr></tbody></table><h2>三、核心结论与选型建议</h2><h3>1. 各品牌核心优势总结（脑图，Mermaid）</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399630" alt="" title="" loading="lazy"/></p><pre><code>mindmap
    root((供应链与客户生命周期绑定能力))
        超兔
            OpenCRM伙伴共生
            全业务一体云
            供应商直发
        Salesforce
            Customer 360全球整合
            Einstein AI预测
            AppExchange生态
        钉钉
            群+业务组件
            宜搭低代码
            产业链协同
        用友
            B2B供应链闭环
            财务-供应链一体化
            CRM全生命周期
        SAP
            供应商全生命周期
            aATP可承诺量
            端到端系统集成</code></pre><h3>2. 场景适配建议</h3><ul><li><strong>中小制造企业</strong>：优先选择<strong>超兔</strong>（全业务一体云+OpenCRM，快速实现“内控+外联”闭环，成本低）；</li><li><strong>跨国企业</strong>：优先选择<strong>Salesforce</strong>（全球化生态+AI预测，解决“多区域数据割裂”问题）；</li><li><strong>产业链协同企业</strong>：优先选择<strong>钉钉</strong>（群+低代码，快速连接上下游，易用性高）；</li><li><strong>中型成长企业</strong>：优先选择<strong>用友</strong>（财务-供应链一体化，支持产供销、业财税协同，满足企业发展过程中的精细化管理需求）；</li><li><strong>大型制造企业</strong>：优先选择<strong>SAP</strong>（端到端系统集成、供应商全生命周期管理和可承诺量（aATP）等功能，保障复杂供应链环境下的稳定交付与高效运营）。</li></ul><p>企业在进行数字化转型、选择供应链与客户生命周期绑定解决方案时，应充分考量自身的业务特点、发展阶段、规模大小和战略目标等因素，从超兔、Salesforce、钉钉、用友、SAP等厂商中挑选最契合自身需求的方案，以实现供应链与客户生命周期的深度绑定，提升企业的核心竞争力和市场适应能力，在激烈的市场竞争中赢得优势。</p><h2>四、功能详情</h2><h3>Salesforce相关能力</h3><h4><strong>一、立足上下游协同的体系能力</strong></h4><ol><li><strong>全球化跨系统数据整合</strong>：基于<strong>Customer 360平台</strong>，整合销售、服务、营销等核心模块，提供统一客户视图，支持跨国企业打通全球58个业务系统数据（如ERP、MES、供应链管理系统），实现总部对各区域<strong>销售动态、库存状态及客户需求的</strong> <strong>实时监控</strong>。</li><li><strong>外部生态协同闭环</strong>：通过<strong>AppExchange开放平台</strong>整合超6000款第三方应用，可与SAP、Oracle等ERP系统及主流电商平台无缝对接，构建“客户-经销商-供应商”全链路外联协同，例如某跨国车企通过该功能将售后问题解决周期从72小时缩短至24小时。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399631" alt="" title="" loading="lazy"/></p><ol start="3"><li><strong>本地化与合规适配</strong>：支持<strong>多语言、多时区部署</strong>，适配GDPR、CCPA等全球数据合规要求，满足跨国企业在不同地区的供应链数据管理规范。</li></ol><h4><strong>二、打通“内控+外联”的全业务链路能力</strong></h4><ol start="4"><li><strong>内部流程自动化提效</strong>：通过<strong>销售云（Sales Cloud）、服务云（Service Cloud）实现线索培育、商机管理、工单处理</strong>等全流程自动化；结合Einstein GPT（AI智能体）自动生成销售话术、预测客户需求，减少内部协作成本，提升流程效率。</li><li><strong>内外系统无缝衔接</strong>：一方面整合内部销售、服务、营销等模块数据，另一方面通过AppExchange与外部供应链、电商、财务系统对接，实现“内控（内部流程）+外联（外部生态）”的全链路打通，消除信息孤岛。</li></ol><h4><strong>三、供应链与客户生命周期深度绑定的能力</strong></h4><ol start="6"><li><strong>AI</strong> <strong>驱动的供需动态匹配</strong>：<strong>Einstein AI</strong>分析客户行为轨迹（如浏览、购买、服务记录），预测各地区产品需求差异，帮助企业优化<strong>库存分配、生产计划</strong>，实现供应链与客户订单的动态匹配，减少库存积压或缺货风险。</li><li><strong>全生命周期数据协同</strong>：从售前营销触达（营销云）、售中商机转化（销售云）到售后客户留存（服务云），通过<strong>Tableau</strong> <strong>BI</strong> <strong>工具</strong>构建定制化数据看板，实时展示<strong>客户转化率、</strong> <strong>供应链协同</strong> <strong>效率、客户满意度</strong>等核心指标，支持管理层科学决策（如某500强企业通过该功能实现全球销售数据实时可视化，提升跨区域响应速度）。</li><li><strong>全链路客户</strong> <strong>闭环管理</strong>：整合销售云、服务云、营销云及Commerce Cloud，实现“获客-转化-留存-复购”全客户生命周期闭环，将供应链的“生产-配送-服务”环节与客户的“需求-购买-反馈”环节深度绑定，提升客户忠诚度与供应链效率。</li></ol><h4><strong>补充说明</strong></h4><ul><li>Salesforce作为全球CRM龙头（全球市场份额超20%），功能覆盖销售、营销、客服全场景；</li><li>核心优势包括AI能力领先（如Einstein GPT自动写邮件、预测需求）、全链路销售管理、电话外呼集成等。</li></ul><h3>SAP立足上下游协同体系，打通“内控+外联”全业务链路的相关能力</h3><h4><strong>一、供应链内控能力：计划、执行与协同一体化</strong></h4><p><strong>智能需求与库存管理</strong>：融合历史数据与市场信号，自动生成需求预测、安全库存及替代料策略，异常情况可预警；实现在制、在途、跨仓库存统一看板管理，联动呆滞料与缺料风险，提升库存周转率与交付达成率。</p><p><strong>精准排程与交付承诺</strong>：平衡设备、人员、物料等产能约束，通过“可承诺量（aATP）”实时给出订单交期；若出现异常（如物料延迟），系统自动重排计划，保障交付稳定性。</p><p><strong>全链路可视化</strong>：覆盖从产品设计、生产制造到物流运维的全供应链链条，提供实时数据看板，确保各环节信息透明可追溯。</p><h4><strong>二、客户生命周期外联能力：全流程数字化服务</strong></h4><p><strong>客户自助与售后管理</strong>：搭建客户门户，支持自助报修、进度查询；结合工单派发、移动端签到、SLA计费等功能，实现售后流程标准化，且售后收入可量化统计。</p><p><strong>AI</strong> <strong>驱动的客户洞察</strong>：通过自然语言处理（NLP）快速调取客户全维度数据，构建360°客户画像；预测销售机会转化率，优化赢单策略与利润结构。</p><p><strong>全渠道旅程协同</strong>：整合官网、门店、社交媒体等触点，动态编排客户旅程（如金融行业嵌入合规审查、医疗行业关联电子病历）；打通销售、供应链、财务等模块，实现订单状态实时同步、库存数据与客户需求联动，避免信息差。</p><h4><strong>三、上下游协同体系：供应链与客户链路深度绑定</strong></h4><p><strong>供应商</strong> <strong>全生命周期管理</strong>：从供应商准入、评级到绩效监控全流程覆盖，支持集中寻源、在线询比价；内置合规风控机制（如贸易合规检查、黑白名单校验），增强供应链韧性。</p><p><strong>端到端</strong> <strong>数据集成</strong>：通过SAP Business Suite等解决方案，整合ERP（企业资源规划）、CRM（客户关系管理）、SRM（供应商关系管理）、PLM（产品生命周期管理）、SCM（供应链管理）等系统，实现从产品创意、研发、生产到交付、售后的全流程优化；连接内外部应用与数据源（如通过SAP BTP的CPI解决方案），打通信息壁垒，保障业务协同。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399632" alt="" title="" loading="lazy"/></p><h4><strong>四、价值成果</strong></h4><ul><li><strong>供应链端</strong>：交付达成率改善，呆滞料与缺料风险降低，采购成本优化，供应链韧性提升。</li><li><strong>客户端</strong>：售后收入增长，客户满意度与复购率提升，赢单效率优化。</li><li><strong>协同层面</strong>：实现“计划即事实”的供应链响应与客户需求实时联动，支撑全球化业务的合规运营与快速响应（如帮助通达创智构建“创智智能制造平台”，提升海外生产基地与全球供应链的韧性）。</li></ul><h3>钉钉立足上下游协同体系的核心能力（基于“内控+外联”全业务链路）</h3><h4><strong>一、跨组织协同场景落地：连接产业链与客户生命周期</strong></h4><p><strong>产业链协同</strong>：通过“群”植入业务组件，将采购、配货等业务流迁移至群内，降低跨组织协作门槛。例如：</p><p>  一汽大众通过钉钉群连接上千家供应商，实现“一点配货调货”；推动供应商使用钉钉低代码平台（宜搭）自建MES系统，确保供应链数据实时同步。</p><p>  集成电路企业利用钉钉实现全国供应链物流中心项目协同，通过甘特图、任务看板跟踪进度，沉淀项目经验。</p><p><strong>客户生命周期管理</strong>：打通销售、库存、财务数据链路，实现从客户对接、订单履约到售后的全流程数据闭环。例如：</p><p>  销售可查看客户历史订单与库存状态，财务直接调取合同签约记录，避免信息割裂。</p><h4><strong>二、数据与系统层深度打通：实现“内控一体化+外联扩展”</strong></h4><ol><li><strong>内控一体化</strong>：通过“钉钉宜搭”低代码平台自定义审批、项目管理等流程，自动关联考勤、文档等内部数据；打通企业所有应用（含生态ISV应用、自研系统），支持“一个账号看全局”，实现人、事、系统的高效连接。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399633" alt="" title="" loading="lazy"/></p><ol start="2"><li><strong>外联扩展能力</strong>：开放API接口（数量超2000个），与用友、金蝶等ERP系统及超兔等垂直SaaS深度对接，形成“协同+业务”闭环；同时支持与供应链上下游系统（如PLM、项目管理系统）集成，提升供需匹配效率。</li></ol><h4><strong>三、安全与效率双重保障：支撑全链路协同的可靠性</strong></h4><p><strong>安全共享机制</strong>：</p><p>  通过钉盘、场景群权限管理，保障上下游文件共享、音视频会议的安全性；采用<strong>SM4国密算法</strong>进行数据加密（传输与存储），通过ISO27001、ISO27018等国际认证，达到金融级数据安全标准。</p><p>  离职员工账号秒级冻结、截屏自动嵌入溯源水印，防止敏感信息泄露。</p><p><strong>AI</strong> <strong>与</strong> <strong>低代码</strong> <strong>赋能效率</strong>：</p><p>  结合AI能力优化供应链监控（如产线设备状态、质量追溯）和客户服务流程；通过低代码平台，企业可快速搭建适配自身业务的供应链管理工具，加速数字化落地。</p><h4><strong>四、生态化服务扩展：推动全链路绑定的闭环</strong></h4><p>推出“钉选”企业服务聚合平台，汇聚SaaS应用、采购、差旅等板块，为企业提供一站式服务；从产业链龙头企业切入，以点带面推动上下游企业数字化转型，实现供应链与客户生命周期的全链路绑定。</p><h3>超兔品牌相关能力总结（基于上下游协同、“内控+外联”链路及供应链与客户生命周期绑定）</h3><h4><strong>一、立足上下游协同体系的核心能力</strong></h4><p>超兔通过<strong>独创的OpenCRM体系</strong>，构建“供应商-企业-客户”的共生协同网络，实现上下游数据互通与业务参与：</p><ol><li><strong>供应商协同</strong>：支持采购需求自动同步、供应商在线报价比价、质量标准分享，及根据“交货及时率、良品率”对供应商评级；</li><li><strong>客户协同</strong>：客户可实时查看订单进度、验收后自动触发对账流程；</li><li><strong>应用场景</strong>：机械制造企业将采购单直接推送至供应商系统，同步生产排期与交货要求，协作效率提升50%，采购周期缩短40%。</li></ol><h4><strong>二、打通“内控+外联”全业务链路的能力</strong></h4><p>依托“全业务一体云”架构，超兔实现CRM、进销存、生产工单、财务、上下游协同等模块的<strong>全业务数据底层连通</strong>，覆盖从“市场获客→客户管理→跟单转化→订单履约→财务结算→复购”的全流程闭环：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399634" alt="" title="" loading="lazy"/></p><p><strong>内控端（企业内部流程）</strong> ：</p><p>  销售端：订单录入后自动拆解BOM清单，同步库存模块检查原材料缺口，触发智能采购计划；</p><p>  生产端：工单与MES系统联动，通过手机扫码完成领料、报工、入库，数据自动沉淀为生产资产（工时、良品率）；</p><p>  财务端：发货后同步生成应收账单，支持多期回款自动拆分，避免跨系统人工操作。</p><p><strong>外联端（外部协作）</strong> ：</p><p>  多渠道集客：整合市场获客工具（如线上广告、社交裂变），实现线索自动进入CRM系统；</p><p>  客户参与：通过OpenCRM让客户参与业务流程（如扫码验收、查看进度）。</p><ol><li><strong>效率提升</strong>：整体交付效率提升60%，跨部门协同成本降低40%。</li></ol><h4><strong>三、实现供应链与客户生命周期深度绑定的能力</strong></h4><p>通过“客户需求-供应链响应”的<strong>动态联动</strong>，超兔将客户全生命周期价值与供应链效率双向优化：</p><p><strong>需求端（</strong> <strong>客户生命周期管理</strong> <strong>）</strong> ：</p><p>  全生命周期覆盖：从市场获客到客户服务的全链条管理，支持自动客池分配、客户公海管理，优化客户资源利用；</p><p>  高价值客户挖掘：通过RFM分析识别高价值客户，结合历史采购记录推送定制化套餐（如“买设备送配件”），老客户复购占比提升至52%。</p><p><strong>供应端（供应链适配客户需求）</strong> ：</p><p>  智能库存策略：基于客户订单波动智能调整库存，某机械企业通过系统预测补货，库存周转周期缩短25%，缺货风险下降35%；</p><p>  定制化履约：客户提出非标需求后，系统自动生成定制工单，同步触发特殊材质采购，供应商直接发货至生产基地，交付周期从15天缩短至7天。</p><h4><strong>总结</strong></h4><p>超兔的核心优势在于“全业务一体云”+“OpenCRM”的组合，通过数据底层连通与上下游协同，实现“内控提效”与“外联增值”的闭环，最终将客户生命周期价值与供应链效率深度绑定，帮助企业在“失控”中构建“自组织”的业务能量场。</p><h3>用友立足上下游协同体系的核心能力</h3><h3>一、上下游协同体系能力</h3><p><strong>全价值链端到端协同</strong>：用友YonSuite供应链管理覆盖从营销到服务的全价值链端到端协同，实现采购到支付、订单到收款、计划到履约的全链条智能化管理；供应链云与采购云、营销云、制造云、财务云等深度融合，覆盖大型企业供应链业务场景，支持产供销、业财税一体化，通过OpenAPI对接第三方服务实现业务闭环。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399635" alt="" title="" loading="lazy"/></p><p><strong>B2B</strong> <strong>供应链协同</strong> <strong>解决方案</strong>：针对上游供应商及下游渠道提供一体化方案，电子销售管理经销商分销网络，整合集团总部、制造企业、分销企业、经销商等资源，打造自动化分销及服务管理体系；电子采购通过供应商门户发布需求，管理寻源与采购执行，打破信息壁垒，提高采购效率、降低成本。</p><p><strong>U8+</strong> <strong>供应链协同</strong> <strong>模式</strong>：以供应链协同为核心，包括内部供应业务精细化管控（配合生产、库存等业务）与外部产业链协同（与供应商信息共享、业务协同），通过供应商门户、即时通讯、移动应用等实现与外部供应商的实时互动，提升采购效率。</p><p><strong>供应商协同管理</strong>：供应链系统通过与供应商的信息共享和业务协同，建立长期稳定合作关系；支持供应商评估、采购合同管理等功能，确保供应商质量与稳定性，提升供应链整体效益。</p><h3>二、“内控 + 外联”全业务链路打通能力</h3><p><strong>内部精细化管控</strong>：供应链系统支持批次号、序列号、保质期管理等多种物料管理需求，覆盖原材料仓库、资产仓库等多种库存存储属性，实现成本计量与物流模式下的无成本计量，强化库存管理、控制与分析；通过质量控制、及时性控制和业务领导关系，实现上下游业务匹配与企业所有权责任，配合内控审计确保业务文件权威、业务时间可追溯及内部效率评价。</p><p><strong>业务流程集成优化</strong>：供应链系统整合订购、库存、生产、物流等环节，实现企业内外部环节高效协同，降低信息传递与操作成本；与财务系统集成（如U8+的财务与供应链一体化），实现财务业务联动，提升管理效率与效益。</p><p><strong>全链路计划与履约</strong>：提供全链路计划协同（有限产能高级排程、仓储物流网络规划、产销储运协同）、供应链计划与控制塔等功能，实现履约经营实时可视，支撑从计划到履约的全流程管理；营销数智化服务（全渠道、全链路）与供应链联动，覆盖B2B订货、直分销CRM、营销活动与费用管理、新零售、会员管理等场景，实现业务全链路贯通。</p><h3>三、供应链与客户生命周期深度绑定能力</h3><p><strong>全程</strong> <strong>客户生命周期管理</strong>：CRM系统覆盖客户从潜在、准入、变动到流失的全生命周期，支持企业透视客户生命周期全过程，识别不同阶段并制定针对性策略，推动客户阶段转化（如从目标客户到忠诚客户）；整合客户静态信息、联系人、需求、联系历史、交易过程、价值信息等，形成360度客户视图，营销角色可实时获取客户分布、关键人、需求、销售过程等数据。</p><p><strong>客户关系与项目管理</strong>：提供客户关系图（展示客户关联单位，支持关联销售与集团客户管理）、联系人关系图（展示联系人上下级关系及影响度，辅助业务开展）、项目决策树（展示项目联系人决策关系，助力项目推进），强化客户资源的企业化管理。</p><p><strong>营销与供应链联动</strong>：营销数智化服务（如全渠道营销、会员管理、电商服务）的前端数据反哺供应链，实现按需生产与精准履约（如根据销售数据调整库存、生产计划）；供应链的“订单到收款”全链条智能化与营销的订单管理、售后服务闭环，支撑从客户下单到履约、售后的全流程服务，提升客户满意度与复购率。</p><h3>补充信息：</h3><p>用友通过YonSuite、U8+等产品体系，进一步强化“内控+外联”能力：</p><ul><li><strong>YonSuite</strong>：纯公有云SaaS平台，实现财务、人力、供应链等场景一体化数据打通，支持核心企业与上下游协同，如制造业的“生产-采购-销售”全链路联动、消费品行业的柔性供应链（根据前端销售数据动态调整生产）。</li><li><strong>智能内控</strong>：基于实时数据的AI预测能力，如供应链环节的库存积压风险预测、财务领域的资金流动异常预警，辅助企业从“事后分析”转向“事前防控”；低代码平台支持企业灵活配置合同管理、商旅费控等流程，兼顾标准化与个性化需求。</li><li><strong>全球化支撑</strong>：支持多语言、多币种、多税制的统一管理，帮助企业打通跨国业务流程，实现全球化运营与供应链协同。</li></ul><p><strong>延伸说明：超兔一体云：打通“内控 + 外联”全业务链路，实现供应链与客户生命周期深度绑定的实现逻辑</strong></p><h2>一、引言</h2><p>在当今竞争激烈的商业环境中，企业需要高效整合内部资源并与上下游合作伙伴紧密协作，以实现供应链与客户生命周期的深度绑定。超兔一体云凭借其强大的功能和独特的优势，在这方面提供了卓越的解决方案。通过立足上下游协同体系，超兔一体云成功打通了“内控 + 外联”全业务链路，为企业带来了更高的运营效率和更强的竞争力。</p><h2>二、超兔一体云的核心优势奠定基础</h2><h3>（一）全业务一体化架构</h3><p>超兔一体云涵盖了 CRM、进销存、供应链、上下游、收支账、薪资、生产工单等多个模块，实现了业务和数据的底层连通。这种全业务一体化的架构为企业提供了一个综合业务大底座，使得企业内部各个部门之间的信息能够无缝流通，避免了信息孤岛的问题。例如，销售部门可以实时获取库存信息，以便更好地与客户沟通订单交付时间；生产部门可以根据销售订单及时安排生产计划，提高生产效率。</p><h3>（二）低成本客制化能力</h3><p>超兔一体云支持功能白名单订阅、自定义三级菜单、工作台、业务表、工作流和多表聚合等功能。这种低成本客制化能力使得企业可以根据自身的业务需求和特点，灵活配置系统，满足不同行业和业务模型的侧重。例如，对于制造业企业，可以自定义生产工单流程，实现生产过程的精细化管理；对于贸易型企业，可以根据自身的销售模式，定制订单管理流程。</p><h3>（三）强大的集成能力</h3><p>超兔一体云具备丰富的业务 API 和基于网页自动化的 RPA，能够与 ERP、WMS 等外部系统进行对接，还能与电商平台通过 RPA 机器人对接，以及对接国税开票机器人等。这种强大的集成能力使得企业可以将超兔一体云与现有的业务系统进行整合，实现数据的共享和业务的协同。例如，企业可以将超兔一体云与金蝶、用友等 ERP 系统对接，实现财务数据的自动同步和业务流程的无缝衔接。</p><h2>三、上下游协同体系的构建</h2><h3>（一）OpenCRM 业务伙伴共生平台</h3><p>超兔一体云的 OpenCRM 业务伙伴共生平台是实现上下游协同的关键。它通过打通企业内部 CRM 与上下游伙伴的业务数据，实现了从询价、采购、发货到对账、开票、售后的全流程协同。</p><ol><li><strong>上游协作</strong>：企业可以通过 OpenCRM 向供应商发送询价请求，供应商可以实时响应并提供报价。在采购执行过程中，系统可以自动匹配历史供应商，根据比价结果创建采购单，并对供应商进行评级。同时，系统还支持付款发票、对账、技术支持等功能，确保与供应商的合作顺畅。</li><li><strong>下游协作</strong>：企业可以向客户发送报价单和订单，客户可以在线确认报价和订单信息。在发货过程中，客户可以实时查看物流进度，并进行收货确认。系统还支持款项发票、投诉处理等功能，提高客户满意度。</li><li><strong>共性能力</strong>：OpenCRM 具备三流合一对账、全程追溯、消息通知等共性能力。三流合一对账确保了货、款、票的一致性，提高了财务核算的准确性；全程追溯功能使得企业可以对业务流程进行全面监控，及时发现问题并进行处理；消息通知功能则保证了企业与上下游伙伴之间的信息及时传递。</li></ol><h3>（二）外部共生用户管理</h3><p>OpenCRM 引入了外部共生用户的概念，允许供应商和客户直接参与业务协作。企业可以通过批量开通的方式为外部共生用户分配账号，并设置相应的权限。这种安全控制机制确保了企业数据的安全性和保密性，同时也提高了业务协作的效率。</p><h2>四、“内控 + 外联”全业务链路的打通</h2><h3>（一）内部业务流程的优化</h3><p>超兔一体云的各个模块之间实现了数据的实时共享和业务的协同。例如，在客户管理模块中，企业可以对客户进行全面的画像和背景调查，了解客户的需求和偏好。在跟单中心，企业可以根据客户的情况选择合适的跟单模型，提高跟单效率。在合同订单管理中心，企业可以对订单进行全流程管理，包括订单的生成、执行、结算等。这些内部业务流程的优化使得企业能够更好地满足客户的需求，提高客户满意度。</p><h3>（二）与上下游伙伴的业务协同</h3><p>通过 OpenCRM 业务伙伴共生平台，企业可以与上下游伙伴进行实时的业务协同。例如，在采购管理中，企业可以与供应商共享库存信息，实现智能采购，降低采购成本。在销售管理中，企业可以与客户共享订单信息，提高订单处理效率。这种与上下游伙伴的业务协同使得企业能够更好地应对市场变化，提高供应链的灵活性和响应速度。</p><h3>（三）数据的流通与整合</h3><p>超兔一体云通过数据统计分析引擎，实现了对企业内部和外部数据的流通与整合。例如，企业可以通过多表聚合引擎对不同模块的数据进行关联分析，了解业务的整体情况。同时，系统还支持同比环比引擎、关联表复合查询引擎等，为企业提供了更加深入的数据分析和决策支持。</p><h2>五、供应链与客户生命周期的深度绑定</h2><h3>（一）客户生命周期管理与供应链的协同</h3><p>超兔一体云的客户中心模块可以对客户进行全生命周期管理，根据客户的跟进状态自动分类为需求培养、有需求、上首屏、加入目标、成功等客池。在不同的客池阶段，企业可以根据客户的需求和特点，与供应链进行协同。例如，在需求培养阶段，企业可以通过供应链提供的产品信息和解决方案，为客户提供更加精准的服务；在成功阶段，企业可以根据客户的订单需求，及时安排生产和发货，确保订单的及时交付。</p><h3>（二）供应链对客户需求的响应</h3><p>超兔一体云的供应链模块可以根据客户的订单需求，自动计算采购量、匹配历史供应商、生成采购计划和采购单。同时，系统还支持供应商直发业务模型，缩短了交货周期，提高了客户满意度。例如，当客户下达订单后，系统可以自动分析库存情况，如果库存不足，系统可以立即向供应商发送采购请求，并安排供应商直接发货给客户，减少了中间环节，提高了供应链的响应速度。</p><h3>（三）数据驱动的决策支持</h3><p>超兔一体云的数据分析能力为供应链与客户生命周期的深度绑定提供了数据驱动的决策支持。通过对客户数据和供应链数据的分析，企业可以了解客户的需求趋势和供应链的运营情况，及时调整业务策略。例如，企业可以根据客户的购买历史和偏好，预测客户的未来需求，提前安排生产和采购计划；同时，企业可以通过对供应链数据的分析，优化供应链流程，降低成本，提高效率。</p><h2>六、案例分析</h2><p>以某工业类企业为例，该企业在使用超兔一体云之前，面临着内部信息流通不畅、与上下游伙伴协作效率低下、客户满意度不高等问题。在引入超兔一体云之后，企业通过 OpenCRM 业务伙伴共生平台与供应商和客户建立了紧密的合作关系，实现了业务数据的实时共享和业务流程的协同。同时，企业通过优化内部业务流程，提高了运营效率，降低了成本。在客户管理方面，企业通过超兔一体云的客户中心模块对客户进行了全生命周期管理，根据客户的需求和特点提供了个性化的服务，提高了客户满意度。通过这些措施，该企业的供应链与客户生命周期实现了深度绑定，企业的竞争力得到了显著提升。</p><h2>七、结论</h2><p>超兔一体云通过其核心优势、上下游协同体系的构建、“内控 + 外联”全业务链路的打通以及供应链与客户生命周期的深度绑定，为企业提供了一个全面、高效的解决方案。在当今数字化时代，企业需要不断提升自身的竞争力，超兔一体云的应用将有助于企业实现业务的数字化转型，提高运营效率，降低成本，增强客户满意度，从而在市场竞争中取得优势。</p>]]></description></item><item>    <title><![CDATA[OceanBase分区基础知识 老纪的技]]></title>    <link>https://segmentfault.com/a/1190000047399637</link>    <guid>https://segmentfault.com/a/1190000047399637</guid>    <pubDate>2025-11-14 15:07:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>介绍</h2><p>分析型业务通常需要对海量数据进行分析计算，这对数据库的查询能力，以及数据管理能力都有很高的要求。OceanBase通过分区技术，将一张表的数据按照分区键水平拆分成多个数据子集，有助于提升查询效率和数据管理能力：</p><p><strong>1.查询效率提升</strong>：分区裁剪能减少无关数据的扫描</p><p><strong>2.数据维护</strong>：支持按照分区粒度进行数据管理，比如数据归档、清理等</p><p><strong>3.数据分布</strong>：按照分区粒度进行数据分布，能够将数据打散到多个节点上，具备良好的可扩展性</p><p>本文首先对分区在 OceanBase 的作用进行介绍，接着描述了 OceanBase 中的基础分区方式以及它们的适用场景，最后讨论了 OceanBase 的灵活分区管理能力如何应用于数据维护、数据管理等业务场景。</p><h2>OceanBase 中分区的作用</h2><p>在 OceanBase 中，分区是水平分片的基本单位，是数据分布、负载均衡和并行操作的最小物理单元。一张大表被逻辑地分割成多个更小、更易管理的独立块，每个分区（甚至分区的不同副本）都可以分散存储在集群中不同的 OBServer 节点上。</p><p>这种设计为分析型业务带来了根本性的优势：当单一节点的存储或计算能力成为瓶颈时，可以通过增加节点并重新分布分区的方式，实现近乎线性的水平扩展，从而处理 PB 级别的数据量。</p><h3>分区裁剪提升查询效率</h3><p>使用分区后，指定分区列进行查询时，在某些场景下能够裁剪出满足查询条件的分区，使得查询无须查询那些不满足条件的分区。</p><p>参考如下例子，我们在列 c2 上创建 hash 分区，指定 c2=1 的查询条件，能够裁剪出只需要查询分区 p1。</p><pre><code class="plain">-- 创建一张四个hash分区的表格t1，分区键为C2create table t1(c1 int, c2 int) partition by hash(c2) partitions 4;
-- 指定c2=1查询，裁剪出分区p1explain select * from t1 where c2 = 1;+------------------------------------------------------------------------------------+| Query Plan                                                                         |+------------------------------------------------------------------------------------+| ===============================================                                    || |ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|                                    || -----------------------------------------------                                    || |0 |TABLE FULL SCAN|t1  |1       |3           |                                    || ===============================================                                    || Outputs &amp; filters:                                                                 || -------------------------------------                                              ||   0 - output([t1.c1], [t1.c2]), filter([t1.c2 = 1]), rowset=16                     ||       access([t1.c2], [t1.c1]), partitions(p1)                                     ||       is_index_back=false, is_global_index=false, filter_before_indexback[false],  ||       range_key([t1.__pk_increment]), range(MIN ; MAX)always true                  |+------------------------------------------------------------------------------------+</code></pre><p>分区裁剪可以过滤掉不需要的数据，但分区数太多可能也会导致其他的问题，例如元数据量过多、分区裁剪的效率可能降低等等，因此，在 OceanBase 的列存表中建议单个分区的行数&gt;=100W 行。</p><h3>分区作为数据维护单元</h3><p>在数据库运维中，将分区作为基本的数据维护单元，能较大地简化日常管理流程，例如数据清理场景、分区级收集统计信息等。以数据清理场景为例，当数据按时间进行分区后，清理过期数据就不再需要逐行删除，而是直接通过删除整个历史分区来实现，这种操作仅仅只需要修改元数据，还能彻底释放磁盘空间，避免了传统的 DML 删除操作产生的性能开销。通过分区键（如时间） 将数据自然归类，使维护操作从“逐行扫描”变为“批量处理”，极大地提升了管理效率，降低了运维的复杂度。</p><h2><strong>分区作为数据分布单元</strong></h2><p>分区作为 OceanBase 的数据分布单元，每个分区的副本可以放置在不同的 OBServer 节点，以实现存储和计算的扩展。</p><p><strong>1.存储的扩展</strong>：当创建一个分区表时，这些分区及其副本可以根据集群的资源情况，由 OceanBase 自动调度到不同的物理节点上。这意味着单张表的容量不再受限于单机磁盘，而是整个集群的存储容量，当集群的存储空间不足时，通过加节点就能够实现扩展。</p><p><strong>2.计算的并行化</strong>：这是分析型业务实现高性能的关键因素之一，当一个查询（特别是涉及全表扫描或大规模聚合的查询）被执行时，OceanBase 的优化器会识别出查询涉及的分区。查询任务可以被分解成多个子任务，并下推到各个数据分区所在的节点上并行执行。例如，一个 SUM() 操作会在每个分区本地先计算小计，然后将中间结果汇总得到最终总和，这充分利用了多节点的计算能力，从而显著加速查询。</p><h3>OceanBase 的基础分区方式</h3><p>目前 OceanBase 中支持三大类基础的分区方式，包括 Hash/Key，Range/Range Columns 和 List/List Columns，三种分区方式各自的使用场景有所不同。</p><h4>HASH/KEY 分区</h4><p>一般适用于分区列 NDV（不同值的种类）较大，且难以划分出明确范围的情况。优点是容易让没有特定规则的数据也能够在不同的分区内均匀分布，缺点是在范围查询时难以进行分区裁剪。</p><p><strong>适用场景举例</strong>：无明显查询模式，需均匀分布数据到多个节点（如用户ID、交易ID）。</p><p><strong>设计要点：</strong></p><ul><li><p>分区键选择：</p><ul><li>NDV（唯一值数量）远大于分区数（如用户 ID 的 NDV 应远大于分区数）。</li><li>优先选择无倾斜（或只有少量倾斜）的整型/时间列（如 user_id, order_time，或者自增列）。</li><li>高频查询条件字段（如 user_id 作为 Join 关键字）。</li></ul></li><li><p>分区数推荐：</p><ul><li>确保分区数匹配集群的机器数量，避免资源分配不均衡</li></ul></li></ul><p><strong>示例场景（Hash 分区使用场景）</strong></p><pre><code class="markdown">-- Hash分区，按user_id均匀分布CREATE TABLE customer(  user_id BIGINT NOT NULL,  login_time TIMESTAMP NOT NULL,  customer_name VARCHAR(100) NOT NULL,  phone_num BIGINT NOT NULL,  city_name VARCHAR(50) NOT NULL,  sex INT NOT NULL,  id_number VARCHAR(18) NOT NULL,  home_address VARCHAR(255) NOT NULL,  office_address VARCHAR(255) NOT NULL,  age INT NOT NULL)PARTITION BY HASH(user_id) PARTITIONS 128;</code></pre><h4>Range/Range Columns 分区</h4><p>一般适用于分区键容易划分出明确的范围的情况，例如可以把记录流水信息的大表，根据表示信息时间的列做 RANGE 分区。</p><p><strong>适用场景举例</strong>：</p><ul><li>数据按时间/数值范围增长（如 order_time, price）。</li><li>需快速裁剪历史数据（如仅查询最近一个月数据）。</li></ul><p><strong>设计要点</strong>：</p><ul><li><p>分区键选择：</p><ul><li>时间字段（如 order_time）或连续数值字段。</li><li>分区边界需与业务查询条件对齐（如按天/月划分）。</li></ul></li><li><p><strong>分区数推荐</strong>：</p><ul><li>根据数据增长设置分区，例如按照月份分区。</li></ul></li></ul><p><strong>示例场景（ange/Range Columns分区示例）</strong></p><pre><code class="markdown">-- 创建系统日志表，按日志时间进行月度RANGE分区，支持快速查询与数据归档CREATE TABLE system_logs(    log_id BIGINT,    log_date TIMESTAMP NOT NULL,    log_level VARCHAR(10),    source_system VARCHAR(50),    user_id BIGINT,    log_message TEXT,    client_ip VARCHAR(15))-- 主分区：按月RANGE分区，使用日期直接表达分区边界PARTITION BY RANGE COLUMNS(log_date)(    PARTITION p_202001 VALUES LESS THAN ('2020-02-01'),    PARTITION p_202002 VALUES LESS THAN ('2020-03-01'),    PARTITION p_202003 VALUES LESS THAN ('2020-04-01'),    PARTITION p_202004 VALUES LESS THAN ('2020-05-01'),    PARTITION p_202005 VALUES LESS THAN ('2020-06-01'),    PARTITION p_202006 VALUES LESS THAN ('2020-07-01'),    PARTITION p_202007 VALUES LESS THAN ('2020-08-01'),    PARTITION p_202008 VALUES LESS THAN ('2020-09-01'),    PARTITION p_202009 VALUES LESS THAN ('2020-10-01'),    PARTITION p_202010 VALUES LESS THAN ('2020-11-01'),    PARTITION p_202011 VALUES LESS THAN ('2020-12-01'),    PARTITION p_202012 VALUES LESS THAN ('2021-01-01'),    -- 默认分区处理未来数据或时间格式异常的记录    PARTITION p_future VALUES LESS THAN (MAXVALUE));</code></pre><h4>List/List Columns分区</h4><p>一般适用于需要显式控制各行数据如何映射到具体的某一个分区时，优点是可以对无序或无关的数据集进行精准分区，缺点是在范围查询时难以进行分区裁剪。</p><p><strong>适用场景举例</strong>：</p><ul><li>离散型字段（如地区、渠道类型）。</li><li>需按固定类别快速裁剪数据（如查询华东地区用户）。</li></ul><p><strong>设计要点</strong>：</p><ul><li><p>分区键选择：</p><ul><li>离散值且数量有限（如 region 字段仅有 ['east','west','south','north']）。</li><li>分区值需覆盖所有可能取值，避免遗漏。</li></ul></li><li><p><strong>分区数限制：</strong></p><ul><li>根据业务逻辑进行配置分区数</li></ul></li></ul><p><strong>示例场景（List/List Columns 分区使用场景）</strong></p><pre><code class="markdown">CREATE TABLE orders_by_region(    order_id BIGINT COMMENT '订单唯一标识',    region_code INT NOT NULL PRIMARY KEY  COMMENT '区域代码（1=north/china, 2=east/china, 3=south/china, 4=west/china）',    customer_id BIGINT COMMENT '客户ID',    order_time DATETIME COMMENT '订单创建时间',    product_category VARCHAR(50) COMMENT '商品类别',    order_amount DECIMAL(18,2) COMMENT '订单金额',    payment_status VARCHAR(20) COMMENT '支付状态（如：PAID, UNPAID）')PARTITION BY LIST(region_code)  -- 改为整数类型分区键(    PARTITION p_north VALUES IN (1),  -- 区域代码1对应north/china    PARTITION p_east VALUES IN (2),    PARTITION p_south VALUES IN (3),    PARTITION p_west VALUES IN (4),    PARTITION p_other VALUES IN (DEFAULT)  -- 默认分区处理未知区域);</code></pre><h2>灵活的分区管理能力</h2><p>OceanBase 有非常灵活的分区管理能力，从数据管理的角度来看，它既有数据维护的功能，也有数据分布的功能；从使用方式来讲，它有手动管理和自动管理两种方式；从分区的层次来考虑，它支持一级分区和二级分区组合使用，通过不同的组合，满足用户对于数据管理的不同需求。</p><p>本节将从数据维护和数据分布来个角度来展开，同时在两个角度中考虑使用方式以及分区的层次的能力组合。</p><h3>数据维护</h3><p>业务层通常按照时间维度来管理分区，方便做数据的归档，清理等操作，我们从业务的完整的数据生命周期流程来结合来描述我们的手动分区管理能力。</p><p><strong>1.业务建表</strong>：创建按照时间分区的表格，提前创建未来一段时间需要的分区</p><p><strong>2.业务导数</strong>：导入数据</p><p><strong>3.业务运行</strong>：随着时间的推进，可能提前创建的分区不足，继续提前创建未来一段时间需要的分区</p><p><strong>4.定期数据清理</strong>：当数据积累到一定时间后，可能之前的数据就不需要了，此时可以删除不需要的分区</p><p>以下是上述使用场景的具体例子：</p><pre><code class="markdown">-- 1. 创建分区表（按天分区，预创建未来7天分区）CREATE TABLE business_data(    id BIGINT NOT NULL AUTO_INCREMENT,    event_time DATETIME NOT NULL,    metric_value DECIMAL(10,2),    PRIMARY KEY (id, event_time)) PARTITION BY RANGE COLUMNS(event_time)(    PARTITION p20231025 VALUES LESS THAN ('2023-10-26'),    PARTITION p20231026 VALUES LESS THAN ('2023-10-27'),    PARTITION p20231027 VALUES LESS THAN ('2023-10-28'),    PARTITION p20231028 VALUES LESS THAN ('2023-10-29'),    PARTITION p20231029 VALUES LESS THAN ('2023-10-30'),    PARTITION p20231030 VALUES LESS THAN ('2023-10-31'),    PARTITION p20231031 VALUES LESS THAN ('2023-11-01')  -- 预创建未来7天分区);-- 2. 导入数据，这里略过-- 3. 预创建未来7天分区ALTER TABLE business_data ADD PARTITION(  PARTITION p20231101 VALUES LESS THAN ('2023-11-02'),  PARTITION p20231102 VALUES LESS THAN ('2023-11-03'),  PARTITION p20231103 VALUES LESS THAN ('2023-11-04'),  PARTITION p20231104 VALUES LESS THAN ('2023-11-05'),  PARTITION p20231105 VALUES LESS THAN ('2023-11-06'),  PARTITION p20231106 VALUES LESS THAN ('2023-11-07'),  PARTITION p20231107 VALUES LESS THAN ('2023-11-08'));-- 4. 定期数据清理，例如数据到期后，删除7天的数据ALTER TABLE business_data DROP PARTITION p20231025, p20231026, p20231027, p20231028, p20231029, p20231030, p20231031;</code></pre><p>由于数据在不停地写入，手工维护预创建分区和定期清理分区还是比较麻烦的。为了简化这个流程，OceanBase 提供了动态分区功能，支持按固定时间分区，预创建多长时间的分区和保留多久的历史分区等功能，对于上面的例子，假如我们需要保留 30 天数据，每次预创建 7 天的分区，那么使用如下语法来进行创建：</p><pre><code class="markdown">-- 1. 创建分区表，设置动态分区策略CREATE TABLE t1(    id BIGINT NOT NULL AUTO_INCREMENT,    event_time DATETIME NOT NULL,    metric_value DECIMAL(10,2),    PRIMARY KEY (id, event_time))DYNAMIC_PARTITION_POLICY(  ENABLE = true,  TIME_UNIT = 'day',  PRECREATE_TIME = '7day',  EXPIRE_TIME = '30day')PARTITION BY RANGE COLUMNS(event_time)(  PARTITION p20231025 VALUES LESS THAN ('2023-10-26'));</code></pre><p>除了 Range 分区模式外，业务也可以按照业务需求选择其他基础分区方式。</p><h3>数据分布</h3><p>分区也可以作为数据据分布管理的单元，通常情况下为了数据打散，一般使用 HASH 分区的方式，它有如下优势：</p><ol><li>它通常能实现比较好的数据打散的需求，也能够做比较准确的分区裁剪；</li><li>对于需要 join 的多张表格，如果按照 join 键进行 hash 分区，并且分区数也保持一致，此时配合 OceanBase table group 能力，能够实现相同 hash 规则的对应下标的分区绑定在一起，从而使得 join 时能够使用 Partition Wised Join，避免数据 shuffle。</li></ol><p>Hash 分区也存在部分问题：</p><ol><li>Hash 分区的分区数设置之后，修改分区数是一个比较重的操作，涉及到整张表的数据重写，所以，一般设置好 Hash 分区的分区数之后，就一般不再变化，比较难以实现可扩展；</li><li>对于分区键上的范围查询，无法裁剪出分区，需要访问所有的分区，可能会存在读放大。</li></ol><p>为了解决 HASH 分区可扩展性以及范围查询的问题，OceanBase 已经支持行存表的自动分区分裂能力，在未来版本中还将提供两种列存表自动分区分裂的模式：堆表分区分裂模式和聚集索引（clustering key）表分区分裂模式。</p><p>堆表分区分裂模式基于堆表的隐藏主键列进行自动分区，由于隐藏主键在分区分裂模式下是随机生成的，并且当租户的机器资源扩展或缩容时，会自动扩充或者缩减对应的分区数，使得该模式能够自动地进行扩展，具备比较好的可扩展性。不过，该模式下数据行是随机分布在任意一个分区的，因此是无法进行分区裁剪的，所以查询性能上可能不是最优，该模式适合对性能要求不高，且不希望提供手动分区或者自动分区键的情况，但又希望表能够自动地扩展。</p><p>聚集索引表分区分裂模式基于用户指定的聚集键进行自动分区，按照数据量进行自动地切分合适大小的分区，当租户的机器资源扩展或者缩容时，由于分裂的分区数已经足够多时，就可以将这些分区重新进行均衡。该模式由于按照聚集键进行自动拆分，当查询能够指定聚集键查询，无论是点查还是范围查询，能够进行分区裁剪，查询性能是比较优的，并且也能够根据机器资源进行自适应地扩展或者缩容。同时聚集索引表自动分裂也能够对支持多张需要 join 的表配置 table group，其中自动分裂的键可以配置为 join键，也能实现 Partition Wised Join。</p><p>为了方便大家理解，Hash、堆表分区分裂和聚集索引表分区分裂三种方式的特点对比如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399639" alt="" title=""/></p><p>除了上述分区方式，业务也可以按照业务需求选择其他的基础分区方式。</p><h3>混合数据维护和数据分布管理</h3><p>我们也可以以二级分区的方式，同时支持数据维护和数据分布的需求，通常使用比较多的场景为一级分区用于数据维护的需求，二级分区用于数据分布的需求，每种需求可以使用对应需求所支持的方式进行组合。</p><h4>典型的手动分区管理方式</h4><ol><li><p>一级分区：</p><ul><li>类型选择：使用 Range 或者 List 分区，匹配高频查询条件（如时间范围、地区）。</li><li>分区数建议：根据查询条件时间分布、数据维护的需求设置合理范围（如按月分区保留 12 个月，或按地区分为 4 个 List 分区）。</li></ul></li><li><p>二级分区：</p><ul><li>类型选择： 使用Hash分区，保证数据打散。</li><li><p>分区数推荐：</p><ul><li>如果只有一个一级分区写入，那么一级分区的二级分区数需要满足写入打散的资源诉求</li><li>如果有多个一级分区能够写入，那么能写入的一级分区数 * 二级分区数满足写入打散的资源诉求即可</li></ul></li></ul></li></ol><p>以下是 Range + Hash 和 List + Hash 的两个场景案例：</p><p><strong>1.Range + Hash</strong>：一级选择 Range 分区，指定 order_date 后，可以快速过滤掉不需要扫描数据的分区，也能够通过分区管理操作快速进行数据维护，二级选择 Hash 分区，可以将当月的写入或者读取打散到 8 个分区中，避免热点。</p><pre><code class="markdown">CREATE TABLE orders(    user_id BIGINT NOT NULL COMMENT '用户ID（二级分区键）',    order_date DATE NOT NULL COMMENT '下单日期（一级分区键）',    amount DECIMAL(10,2) NOT NULL COMMENT '订单金额',    status TINYINT NOT NULL COMMENT '状态: 0-取消 1-待支付 2-已支付 3-已发货 4-已完成',    region_code CHAR(6) NOT NULL COMMENT '地区编码（前2位省码）',    product_id INT NOT NULL COMMENT '商品ID',    payment_method VARCHAR(20) COMMENT '支付方式',    created_at TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) COMMENT '记录创建时间')PARTITION BY RANGE COLUMNS(order_date)SUBPARTITION BY HASH(user_id) SUBPARTITIONS 8(  PARTITION p202501 VALUES LESS THAN ('2025-02-01'),  PARTITION p202502 VALUES LESS THAN ('2025-03-01'),  ...  PARTITION p202601 VALUES LESS THAN ('2026-02-01'));</code></pre><p><strong>2.List + Hash</strong>：一级选择 List 分区，指定省份能够裁剪到相应的分区，也可以按照省维度进行数据维护，二级选择 Hash/Key 分区，可以将省的读写流量打散到多个分区中，实现负载均衡。</p><pre><code class="markdown">-- 一级分区：LIST按省划分（31个省级行政区）CREATE TABLE social_insurance_records(    record_id BIGINT,    province_code INT NOT NULL,  -- 省级编码（如11北京，31上海）    payment_date DATE NOT NULL,    user_id VARCHAR(32) NOT NULL,    amount DECIMAL(10,2)) PARTITION BY LIST(province_code)  -- 一级LIST分区SUBPARTITION BY KEY(user_id) SUBPARTITIONS 16  -- 二级HASH分区(  PARTITION p_beijing VALUES IN (11),  PARTITION p_shanghai VALUES IN (31),  PARTITION p_tianjin VALUES IN (12),  ...  PARTITION p_xizang VALUES IN (54));</code></pre><h3><strong>典型的自动分区管理方式</strong></h3><ol><li><strong>一级分区</strong>：选择动态分区，配置按固定时间分区，预创建多长时间的分区和保留多久的历史分区等参数；</li><li><strong>二级分区</strong>：选择自动 Range 分区分裂，能够自动地进行分裂，无须配置分区个数或者分区规则。</li></ol><h2>总结</h2><p>目前 OceanBase 支持了常见的基础分区方式，通过基础分区方式的组合使用，能够满足业务的数据维护、数据分布以及提升查询效率等需求。动态分区对按照时间进行分区数据维护的通用需求提供了标准的自动化管理能力，减少用户对数据维护的代价，未来我们将加强自动分区的管理能力，支持列存表的自动分区分裂，减少当前数据分布手工维护的代价、可扩展性等问题，进一步提升列存表的数据管理自动化管理能力，使得分析型业务场景能更容易使用OceanBase。</p>]]></description></item><item>    <title><![CDATA[硬核技术获省级名录推荐，破解水利感知决策]]></title>    <link>https://segmentfault.com/a/1190000047399695</link>    <guid>https://segmentfault.com/a/1190000047399695</guid>    <pubDate>2025-11-14 15:07:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>2024年12月，山东省水利厅发布《山东省水利改革创新典型案例（第三批）》，费县智慧水利项目凭借“孪生+流域”创新模式成功入选，展示了数字技术在破解水利管理难题上的突破性进展。</p><h2>智能感知：从“单点监测”到“全域感知”</h2><p>传统水利工程面临的最大挑战是感知能力不足。现在，多源信息融合技术正在改变这一局面。通过部署雷达水位计、多普勒流速仪、多参数水质传感器等设备，构建起空天地一体化的监测网络。</p><p>以入选省级名录的费县项目为例，该县智慧水利系统接入水利工程运行状态传感器、视频监控、雨水情监测等实时数据，实现水利工程运行状态实时可视化交互。其监测精度达到水位误差厘米级、流量测量精度90%以上，水质指标监测分辨率达0.01单位。<br/><img width="480" height="263" referrerpolicy="no-referrer" src="/img/bVdm2Y9" alt="" title=""/></p><p>智能石头技术代表了感知技术的重大突破。第五代产品采用多传感器智能串联设计，监测精度达毫米级，功能从单一震动监测升级为集倾斜、振动、走失、移位、形变于一体的“全能感知”。其运动轨迹监测算法可精准描述石体位移状态：<br/><img width="242" height="75" referrerpolicy="no-referrer" src="/img/bVdm2Zb" alt="" title="" loading="lazy"/><br/>其中Δx为位移量，v₀为初速度，a为加速度，ε为环境误差补偿系数。该技术使预警准确率跃升至80%以上，电池续航能力延长至3-4年。<br/><img width="700" height="339" referrerpolicy="no-referrer" src="/img/bVdm2Za" alt="" title="" loading="lazy"/></p><h2>智能决策：从“经验判断”到“模型驱动”</h2><p>水利决策的核心在于精准预测与仿真。宁波市开发的甬江流域预报调度一体化模型，集成了水利、自然资源、气象等多部门海量数据，以预报、预警、预演、预案为核心，通过数字孪生技术实现自然流域与虚拟模型的动态联动。</p><p>在防御台风“康妮”时，宁波市水利局应用并行计算技术，将干流及平原主要水位的预报时间从8分钟大幅压缩至2分钟。对代表站水位的预测结果与实际测量值偏差小于10厘米。其洪水演进模型采用改进的圣维南方程组：<br/><img width="461" height="71" referrerpolicy="no-referrer" src="/img/bVdm2Zc" alt="" title="" loading="lazy"/></p><p>其中Q为流量，A为过水面积，h为水位，S_f为摩擦坡度。该模型有效解决了甬江流域因上游山区源短流急、下游潮水顶托带来的复杂调度难题。</p><p>黄冈市打造的“智慧水域”平台展示了多部门协同决策的强大能力。该平台以雷达、AIS基站、高点视频以及卡口监控为载体，应用AI算法自动识别加中端应用软件精准预警、后端指挥中心自动派单的联动机制。在河湖治理过程中，黄冈市加强了水利、环保、农业等多部门协作，建立信息共享机制，实现河湖监测数据与水利设施运行数据的整合。<br/><img width="723" height="372" referrerpolicy="no-referrer" src="/img/bVdm2Zd" alt="" title="" loading="lazy"/></p><h2>工程实践：闭环管理赋能水利现代化</h2><p>在实际工程应用中，数字孪生技术正推动水利工程管理模式的深刻变革。宁波市启动的数字孪生周公宅-皎口梯级水库项目，围绕信息基础设施、数字孪生平台、业务应用及网络安全四大核心领域，全面升级优化水库运行管理体系。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm2Zg" alt="" title="" loading="lazy"/></p><p>智能诊断与预警系统实现了从被动应对到主动防控的转变。系统能自动分析渗流、位移等安全指标，预判潜在风险，并生成详细的“体检报告”。当检测到异常情况时，系统在20秒内自动生成处置工单，将预警信息实时推送至工作人员手机。<br/><img width="723" height="369" referrerpolicy="no-referrer" src="/img/bVdm2Y3" alt="" title="" loading="lazy"/></p><p>凡拓数创参与建设的“左港水库数字孪生平台”作为2025年唯一上榜水利类数字孪生项目，展示了数字孪生技术在破解水利难题上的价值。该平台通过高精度建模与实时数据分析，为水库安全管理提供了可靠的技术支撑。<br/><img width="723" height="349" referrerpolicy="no-referrer" src="/img/bVdm2Y4" alt="" title="" loading="lazy"/></p><h2>技术展望：智能水利率领未来发展</h2><p>随着技术的不断进步，水利工程正朝着智能化、精细化方向快速发展。从“智能石头”到数字孪生平台，技术创新正在重塑传统水利行业的管理模式和发展路径。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm2Zj" alt="" title="" loading="lazy"/></p><p>未来，随着5G、人工智能、大数据等技术的深度融合，水利工程将实现更高水平的智能化管理。预报调度一体化、智能诊断预警和多部门协同决策将成为行业标准，为水资源管理和防洪减灾提供更加精准、高效的技术支撑。</p><p>省级名录的推荐不仅是对创新技术的认可，更是对水利行业数字化转型的推动。随着这些硬核技术在更多水利工程中推广应用，我国水利现代化管理水平将实现新的飞跃。</p>]]></description></item><item>    <title><![CDATA[鸿蒙人物志 x 王丹辉｜善用生态之力，专]]></title>    <link>https://segmentfault.com/a/1190000047399766</link>    <guid>https://segmentfault.com/a/1190000047399766</guid>    <pubDate>2025-11-14 15:06:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>此篇文章来源于 SegmentFault 思否鸿蒙专区·鸿蒙人物志专题采访，阅读时长约 9 分钟，以下为正文：</p><blockquote><p>“跨设备协同”不应只是发布会上的热词，它需要在真实产品里被做成稳定、无感、可复制的日常体验。</p><p>王丹辉——北京湛泸教育首席架构师、开源项目“赵王电机智能关节”联合主理人，曾主导 ZBot-1600-v1、ZBot-800-v1 两款人形双足机器人的研发，如今专注于智能穿戴与生物信息交互领域，并以鸿蒙为技术底座推进实战落地与应用普及。他的最新项目 ColorVision，致力于帮助设计师实现包容性设计，以及让色觉障碍人群“看得更清楚”。</p></blockquote><h4><strong>能力流动：ColorVision 分布式实践路径</strong></h4><p>在技术路径的选择上，王丹辉基于工程本质的考量，将鸿蒙作为 ColorVision 的核心底座。他看中的是其分布式架构带来的跨设备协同便捷性，以及系统级安全机制对敏感色彩数据的可靠保障。</p><p>在王丹辉的理解中，鸿蒙是一套“能力中枢”。其核心不是将单一设备做强做大，而是让能力在端与端之间被调用、编排与无感迁移。这种“以能力为中心”的设计逻辑，使得同一份体验可以在手机、平板、穿戴、大屏之间自由流转。</p><p>对 ColorVision 来说，手机可承担色彩数据采集、核心矫正算法与交互任务，而具有广色域与更强算力的平板或 PC 则负责高精度校核与实时预览。用户在不同设备间切换时，参数与结果保持同源同步，体验始终一致。</p><p>真正的工程智慧体现在团队的取舍之间。ColorVision 立项时，团队评估过是否需要自建一套底层能力，包括色彩空间管理、HDR 适配、可变帧率、异构渲染一致性等。考虑到鸿蒙的 ArkGraphics 2D 原生能力以及星盾安全架构提供的全链路加密与数据存储保障，他们决定深度复用这套系统能力。这让原本需要 6–8 个月的底层开发周期压缩至 1 个多月，节省下来的时间与人力，被投入到两个用户可感知的价值点上。一个是针对不同色弱类型优化映射算法，另一个是为设计师提供实时预览与参数微调等专业功能。</p><blockquote>“借生态之力，做自己最擅长的事”王丹辉反复强调的能力边界观，让团队得以聚焦在真正创造差异化的核心环节。</blockquote><h4><strong>系统韧性：协同与降级双重保障</strong></h4><p>能力能流动只是起点，要打造稳定的体验，还需要把一致性与连续性写进系统约束。王丹辉认为，协同的精度决定了体验的上限。</p><p>他将跨端协同拆解为三个层次。在数据协同层面，基于分布式软总线实现跨端“同源同步”，并以统一色彩空间标准规避设备色域差异带来的偏差。在能力协同层面，当手机处理高清设计文件吃力时，分布式任务调度会调用平板算力完成渲染，再把结果无感回传。在标准协同层面，坚持跨端解析逻辑一致，确保“同一幅画在任何设备上看起来都一样”。这些看似朴素的工程约束，构成了用户心智里“理所当然”的一致性体验。</p><p>面对真实世界中的设备算力差异、网络波动与跨端断连，王丹辉的团队预置了三条兜底路径。<br/>首先是设备能力降级，老设备自动关闭高精渲染与过渡效果，仅保留核心矫正与数据同步，并用可变帧率把交互稳在 15fps 以上。其次是按网络状态降级，断连时切本地独立运行，恢复后自动对账同步，不打断当前操作。然后是按场景优先级降级，设备在低电量等限制条件下优先保障核心功能，暂时关闭非必要动画。</p><p>这套完整的协同与降级机制，为 ColorVision 的体验稳定性奠定了基础，让团队有更多精力 投入到系统优化的下一阶段。</p><h4><strong>优化演进：从验证到稳定的三阶路径</strong></h4><p>在确立协同与降级机制后，团队将重心转向了系统长期稳定性的构建。他们为优化工作设定了明确的优先级：首要解决崩溃率和应用无响应问题，随后是帧率稳定性，最后才是启动速度与内存占用等指标。<br/>项目首先追求的是“快速验证”。团队利用鸿蒙原生组件迅速搭建起基础框架，优先确保色彩矫正等核心流程能够顺畅运行，跨端协同的基本逻辑得到验证。这是从零到一的关键一步。</p><p>在核心流程跑通后，优化进入了“精准调优”阶段。通过 DevEco Studio 的 Profiler 工具，团队逐一定位性能瓶颈。例如，他们发现因重复创建 colorSpace 实例导致内存泄漏，改为单例模式后问题迎刃而解。针对穿戴设备性能特点，团队引入了轻量级渲染与动画裁剪机制，通过“高精场景才加载高级效果”的智能策略配合可变帧率技术，有效改善了帧率抖动现象。同时，冷启动阶段的分布式数据管理采用懒加载策略，显著降低了系统负担。</p><p>最终目标是实现系统的“长期稳定运行”。团队进行了大规模多设备压力测试，构建起完整的异常防护体系，并采用灰度发布与用户反馈闭环机制，让真实使用场景不断验证和校准技术方案。这条优化路径不追求参数极致，却切实保障了产品在各种环境下的可靠表现。</p><p>贯穿这一优化过程的，是一种务实的工程哲学。团队清醒地认识到，技术真正的价值，不是盲目追求参数的堆砌，而是要让生态能力与用户需求达成精准契合。鸿蒙的分布式底座恰好为这种因人制宜、因端施策的产品理念提供了坚实支撑，让团队能够为每一类用户寻找到最适合的技术路径。</p><h4><strong>开发指导：学习与上架指南</strong></h4><p>对于准备用 2-3 周时间“试水”的开发者，王丹辉给出了如下的学习路径，核心思路是“聚焦核心、复用生态、快速出成果”，避免陷入底层技术细节。</p><ul><li>第 1 周（基础打底）<br/>安装 DevEco Studio，完成环境配置（模拟器/真机调试）。<br/>重点学习 ArkUI 声明式开发，掌握布局（Flex/Grid）、组件（Text/Image/Button）及状态管理基础。<br/>理解鸿蒙核心逻辑：分布式软总线、多端部署原理（无需深度研究底层，只需理解“一次开发多端适配”核心逻辑）。<br/>跑通官方“小 demo”，感受生态能力。</li><li>第 2 周（实战落地）<br/>确定 1 个简单核心场景（如“简易色彩识别工具”或“跨设备文本同步工具”），不做复杂功能。<br/>复用鸿蒙原生组件，避免从零开发。<br/>完成“手机+平板”双端适配（布局自适应、组件尺寸适配），借助 DevEco Studio 的“多端预览”功能快速调试。</li><li>第 3 周（优化 + 验证）<br/>使用 DevEco Studio 的 Performance Profiler 排查帧率抖动、内存泄漏（重点优化启动时间＜3 秒、无明显卡顿）。<br/>做基础合规检查：权限申请是否合理（如仅需相机权限则不申请存储权限）、隐私声明是否完整。<br/>熟悉上架流程：注册华为开发者账号、了解应用提审要求、准备测试包（APK/HAP）。</li></ul><p>参考资料：<br/><a href="https://link.segmentfault.com/?enc=79t%2F%2B%2Bzi7IFWSN3EUCMXTg%3D%3D.DPSJS1zPEjiwyv%2BJp%2Fmu7gN0a1ZgyULofqzavb%2FglK%2BgKcwhWh6xjSLqivM%2BNh%2F8" rel="nofollow" target="_blank">HarmonyOS 开发者社区</a><br/><a href="https://link.segmentfault.com/?enc=dnjR6Rjm1Br9BdaopWdOBQ%3D%3D.ldYo8ticXNLkFeG%2Btxs0QT%2BLImWlWbMKsQ30Eq9FF8jHR4rxaIyUiNqffjETZmbdz1yNNTuB6Q0peq0WrckiMIDB13cSOXQQko9OVtQQAn2kg6fqEjUHIfIsXT8UbmQC" rel="nofollow" target="_blank">HarmonyOS 开发文档</a><br/><a href="https://link.segmentfault.com/?enc=Y9DyZzYkCn2IBMnYB0WRlw%3D%3D.BJ%2BmhdDVPy0PbyuNd02ohNi1XN9ST%2B53vh%2FjnuqiKWEKnD4lHM%2FEsDjkrA%2FHl4wHIQ7vGTLFbVxdU6hTZ4NJuA%3D%3D" rel="nofollow" target="_blank">HarmonyOS 应用市场</a></p><h4><strong>生态赋能：经验沉淀资产，联动加速成长</strong></h4><p>把视角拉向生态，鸿蒙带来的三类“高确定性机会”清晰可见：</p><ul><li>岗位机会——适合希望稳健发展的工程师，尤其是准备从 Web/Android/iOS 转型；</li><li>垂直应用——适合有明确产品想法与独立开发能力的小团队，在细分人群里做“有用户、有价值”的产品；</li><li>生态基础设施——开源组件/工具、技术分享、硬件适配与行业解决方案，能够获得生态资源联动并沉淀长期影响力。判断自己是否适合切入，只需两问：你是否握有真实场景痛点？你是否愿意沿着生态“已验证路径”把速度拨快一点？</li></ul><p>在生态内容建设上，他的建议是只写“能直接落地的方法论”，并给出一套“项目经验→可复用文档”的九宫格模板：问题背景/核心目标/备选方案权衡/量化指标/实施步骤/工具与资源/核心结论/踩坑与避坑/迭代建议，让经验从口碑变成可移植的工程资产。</p><p>此外，王丹辉谈到参与鸿蒙创新赛充分展示了自己对生态价值的深刻理解和实践。他的参赛动机并非单纯为了奖项，而是想通过实战验证三点关键观点：首先，垂直小众场景同样可以打造“有用户、有价值”的产品；其次，分布式技术并非单纯的炫技概念，而是能有效降本增效的实战工具；最后，开源与生态联动能够快速放大小众创新的影响力。他反复强调，鸿蒙生态的真正价值在于，让开发者将时间投入到创新上，而非被底层适配问题所困扰。</p><p>加入领航者计划则为王丹辉提供了直接的资源支持，使得他能够在生态中精准对接，形成了一个“贡献—成长”的良性循环：通过持续贡献技术，精进自身能力，并在联动中获得更多支持和成长空间。这一实践不仅为开发者提供了成长的沃土，更为那些专注于垂直场景的小团队带来了实现创新梦想的机会。</p><h4><strong>结语</strong></h4><p>王丹辉的探索，向我们揭示了一个清晰的逻辑：创新，应该善用生态之力，专注擅长之事。这也是鸿蒙生态为每一位开发者铺就的成长通途。</p>]]></description></item><item>    <title><![CDATA[AI辅助开发大屏案例详解：基于smard]]></title>    <link>https://segmentfault.com/a/1190000047399788</link>    <guid>https://segmentfault.com/a/1190000047399788</guid>    <pubDate>2025-11-14 15:06:02</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>需求背景<br/>随着港口运营规模的不断扩大与信息化水平的提升，传统的数据报表与分散监控方式已难以满足实时感知、智能分析与高效决策的管理需求。港口管理部门亟需一种能够集中展示作业动态、实时监测异常情况、直观反映运营效率的数据可视化大屏解决方案。港口作业数据量大、指标多样、关联复杂，因此需要通过可视化手段，构建一个集数据整合、智能预警与交互分析于一体的运营指挥大屏。<br/>大屏介绍<br/>港口作业分析大屏旨在实现港口核心运营数据的全景可视化、实时监测与智能交互，主要包括以下核心模块：<br/>•告警信息中心：实时呈现港口异常事件，支持一键穿透处理；<br/>•船舶状态监测：通过表格与进度条直观展示船舶作业进度与吨位分布；<br/>•泊位利用率分析：通过指标卡与页签联动，实现多港口数据对比；<br/>•作业运行分析：支持船只类型与货物类型的图表下钻与切换展示。<br/>大屏通过多种图表组合、个性化样式设计与灵活的交互配置，实现了数据的高效传达与操作闭环。<br/>搭建步骤<br/>通过smardaten构建港口作业分析大屏，仅需以下四个核心步骤：<br/>1.大屏框架生成：利用AI指令快速生成大屏布局、图表与样式；<br/>2.样式优化：根据业务需求删减非必要指标，补充缺失模块并美化样式；<br/>3.组件配置与绑定：拖拽图表与交互组件，绑定数据资产并配置显示规则；<br/>4.交互事件配置：设置点击下钻、页签筛选、开关切换等交互逻辑，实现数据联动。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm2ZW" alt="" title=""/><br/>大屏设计<br/>1.AI生成大屏<br/>进入应用设计界面，唤起右下角的AI助手，输入大屏生成指令：“生成一个管理港口作业的大屏，包含货物吞吐量、船舶调度、泊位利用率等多个模块指标”<br/>输入大屏生成指令后，系统便会根据业务场景，完成大屏展示字段、所需图表、整体样式的设计工作。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm2ZX" alt="" title="" loading="lazy"/><br/>双击进入大屏配置后台，我们观察后发现，AI不仅精准还原了我们要求展示的全部核心指标，而且其生成的布局配色专业、图表类型选用得当，整体视觉效果与可用性均达到了较高水准。<br/>接下来，我们仅需调整部分展示内容，并补充图表交互，即可快速投入实际业务使用。<br/>2.船舶状态监测<br/>在完成大屏基础框架搭建后，我们发现缺少"船舶状态监测"这一核心业务场景。<br/>首先，通过AI指令快速删除原布局中不重要的指标项：“删除货物吞吐量分布、总吞吐量、港口任务分布、完成任务数、装卸背景、装卸标题组件”<br/><img width="723" height="346" referrerpolicy="no-referrer" src="/img/bVdm2Z5" alt="" title="" loading="lazy"/><br/>随后拖入表格组件，绑定船舶实时数据资产，手动隐藏"国籍"、"代理公司"等非核心字段，确保表格信息聚焦。<br/><img width="723" height="345" referrerpolicy="no-referrer" src="/img/bVdm20a" alt="" title="" loading="lazy"/><br/>然后我们利用AI调整表格尺寸：“调整普通表格宽度为914、高度为236”<br/><img width="723" height="348" referrerpolicy="no-referrer" src="/img/bVdm20h" alt="" title="" loading="lazy"/><br/>在样式优化方面，我们进行了多维度配置：<br/>•表头设置深色背景与白色加粗字体，文字居中显示，增强视觉层次感<br/>•为表格的奇数行和偶数行分别设置不同背景色，提升数据行的可读性<br/>•将"作业进度"列切换为"进度条"可视化模式，使得完成比例一目了然<br/>•为快速识别大吨位船舶，我们设置了特殊样式规则：当"吨数"字段值大于200时，该数字自动显示为醒目的红色并加粗<br/><img width="664" height="340" referrerpolicy="no-referrer" src="/img/bVdm20j" alt="" title="" loading="lazy"/><br/>经过这一系列配置，一个数据清晰、视觉直观、重点突出的船舶状态监测表格便已完成，实现了对在港船舶作业情况的实时监控与重点船舶的快速识别。<br/><img width="723" height="346" referrerpolicy="no-referrer" src="/img/bVdm20k" alt="" title="" loading="lazy"/><br/>3.港口告警信息<br/>在屏幕左侧区域的告警信息模块，我们采用画布组件实现更自由的布局与更直观的视觉呈现。<br/>双击进入画布配置界面，首先调整画布尺寸与间隔，并拖入告警标题、触发时间、发生位置等核心字段，逐一配置字体大小、颜色<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20l" alt="" title="" loading="lazy"/><br/>接下来，我们为每个告警字段配置了交互事件：点击任一告警信息，即可一键穿透至后台的告警处理列表，直接进行派单或关闭等处置操作，形成了从全局监控到精准处理的完整闭环。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20m" alt="" title="" loading="lazy"/><br/>针对"系统异常"这类高优先级告警，我们专门新增独立画布，设置醒目的红色字体与故障图标，并通过显示条件设置实现两类告警画布的差异化呈现。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20n" alt="" title="" loading="lazy"/><br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20o" alt="" title="" loading="lazy"/><br/>如此一来，不仅实现了告警信息的智能化展示，更确保了重点异常能够得到优先关注与快速处置。<br/><img width="723" height="420" referrerpolicy="no-referrer" src="/img/bVdm20u" alt="" title="" loading="lazy"/><br/>通过以上配置，港口作业效率排行榜成功实现了对各作业单位效率值的直观对比与动态展示，为管理人员的绩效评估与决策分析提供了有力的数据支撑。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20y" alt="" title="" loading="lazy"/><br/>5.泊位利用率<br/>在右上角的泊位利用率分析模块中，AI已自动配置了4个指标卡用于展示泊位占用率、平均作业时长、船主满意度和吞吐量等关键运营数据。我们针对船主满意度指标进行专项优化：<br/>•将数值调整为百分比显示，更符合业务阅读习惯<br/>•在指标左侧添加形象化的满意度图标，使数据表达更加直观<br/>•当满意度数值低于70%时，指标卡自动切换为灰色显示<br/><img width="658" height="426" referrerpolicy="no-referrer" src="/img/bVdm20z" alt="" title="" loading="lazy"/><br/>为实现指标卡显示多港口数据，我们在该模块上方添加了页签组件：<br/>分别配置各港口名称页签，并配置交互事件，当用户切换不同港口时，页签值作为筛选条件实时传入指标卡的数据资产中，驱动四个指标同步更新，精准展示对应港口的运营状况<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20C" alt="" title="" loading="lazy"/><br/>通过以上配置，泊位利用率分析模块不仅实现了关键指标的清晰展示，还具备了多港口数据对比与智能预警能力，为港口运营管理提供了有力的决策支持。<br/><img width="723" height="349" referrerpolicy="no-referrer" src="/img/bVdm20E" alt="" title="" loading="lazy"/><br/>6.港口作业运行分析<br/>在港口作业运行分析模块中，AI已通过柱状图清晰展示了各类船只的分布情况。我们在此基础之上，进一步增强了该模块的数据分析能力和交互体验。<br/>首先柱状图设置交互下钻规则：点击任一船只类型柱状图，即可穿透查看该类型船舶在各个港口的详细分布情况<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20F" alt="" title="" loading="lazy"/><br/>在同一个模块区域中，复用预先设计好的环形图模板，快速完成货物类别占比的可视化呈现<br/><img width="723" height="350" referrerpolicy="no-referrer" src="/img/bVdm20G" alt="" title="" loading="lazy"/><br/>通过两个开关组件实现同一区域的图表切换展示，节省大屏空间。将"船只分析"开关关联到船只类型柱状图，"货物分析"开关关联到货物类型环形图。并设置互斥显示规则，用户只需轻点开关，即可在船舶分析与货物分析两种视角间自由切换。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20H" alt="" title="" loading="lazy"/><br/>该模块通过柱状图下钻、环形图占比展示以及开关切换功能，实现了对港口作业运行情况的多维度、多层次分析，有效支撑了业务决策的数据需求。<br/>效果预览<br/>启动港口作业分析大屏后，整体视觉效果专业协调，各模块数据清晰呈现，交互响应流畅敏捷：<br/>•船舶状态监测表格中，作业进度以直观的进度条展示，大吨位船舶（吨数&gt;200）的数值自动红色加粗显示，重点船舶一目了然；<br/>•港口告警信息模块以自由布局形式呈现于左侧，不同类型告警通过颜色与图标差异化显示。<br/><img width="723" height="406" referrerpolicy="no-referrer" src="/img/bVdm20J" alt="" title="" loading="lazy"/><br/>点击任一告警信息，系统立即跳转至后台处理界面，实现从发现问题到处理问题的无缝衔接；<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20K" alt="" title="" loading="lazy"/><br/>•泊位利用率分析区域，点击上方港口页签，四个指标卡数据实时联动更新，满意度低于70%时自动变灰提示，有效支持多港口对比分析；<br/><img width="723" height="404" referrerpolicy="no-referrer" src="/img/bVdm20L" alt="" title="" loading="lazy"/><br/>•港口作业运行分析模块中，点击任一船只类型柱状图，即可下钻查看该类型在各港口的详细分布。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20M" alt="" title="" loading="lazy"/><br/>通过右侧开关，用户可轻松在"船舶分析"与"货物分析"视图间切换，同一区域实现双重分析维度。<br/><img width="723" height="406" referrerpolicy="no-referrer" src="/img/bVdm20O" alt="" title="" loading="lazy"/><br/>体验总结<br/>通过对港口作业分析大屏的完整搭建，我们充分体验到smardaten平台在数据可视化大屏开发中的显著优势：<br/>AI助力，高效起步：通过自然语言指令快速生成专业大屏框架，大幅降低初始设计成本，实现分钟级原型搭建。<br/>交互灵活，闭环可控：支持穿透、下钻、筛选、切换等多种交互方式，实现从数据展示到业务操作的完整闭环。<br/>样式丰富，视觉出众：提供细粒度样式配置，轻松实现进度条、渐变色彩、条件变色等专业视觉效果。<br/>配置灵活，维护便捷：通过拖拽调整、AI指令和条件规则，可快速响应业务变化，确保大屏长期实用价值。</p>]]></description></item><item>    <title><![CDATA[Vue + Axios + Node.j]]></title>    <link>https://segmentfault.com/a/1190000047399792</link>    <guid>https://segmentfault.com/a/1190000047399792</guid>    <pubDate>2025-11-14 15:05:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在前后端分离架构中，Vue 前端配合 Axios 发起请求，Node.js（Express）搭建后端服务时，可实现 Token 无感刷新以提升用户体验。具体而言，前端 Vue 项目通过 Axios 拦截器，在每次请求前检查 Token 状态。若 Token 即将过期，先向服务端发起静默刷新请求，Express 后端验证旧 Token 后颁发新 Token。前端拦截器收到新 Token 后，将其更新到本地存储，并重新发起原请求，整个过程对用户透明，无需手动重新登录。</p><h2>页面基本流程</h2><ol><li>登录成功后，后端返回 Access Token 和 Refresh Token，前端存储两者及各自有效期。</li><li>每次发起业务请求前，前端判断 Access Token 是否即将过期。</li><li>若即将过期，先调用 “刷新 Token 接口”，用有效的 Refresh Token 换取新的 Access Token。</li><li>用新的 Access Token 发起原业务请求，用户全程无感知。</li><li><p>若 Refresh Token 也过期，才会引导用户重新登录。</p><h2>一、技术栈与核心约定</h2></li><li>前端：Vue 3（适配 Vue 2，只需微调语法）+ Axios（统一请求拦截）</li><li>后端：Node.js + Express + JWT（生成 Token）+ Redis（存储 Refresh Token，可选但推荐）<br/>Token 规则：</li><li>Access Token：短期有效（1 小时），用于业务请求身份验证</li><li>Refresh Token：长期有效（7 天），仅用于刷新 Access Token</li><li><p>状态码：401 = Access Token 过期 / 无效；403 = Refresh Token 过期 / 无效</p><h2>二、前端实现（核心代码）</h2><h3>1. 初始化 Axios 实例（api/index.js）</h3><p>封装请求 / 响应拦截器，处理 Token 携带、刷新和重试逻辑:</p></li></ol><pre><code>import axios from 'axios';
import { ElMessage } from 'element-plus'; // 按需引入 UI 组件库提示（可选）

// 1. 创建 Axios 实例
const service = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL, // 环境变量配置后端地址
  timeout: 5000, // 请求超时时间
});

// 2. Token 存取工具函数（安全存储建议用 HttpOnly Cookie，此处用 localStorage 演示）
const TokenKey = {
  ACCESS: 'access_token',
  REFRESH: 'refresh_token',
};

// 获取 Token
const getAccessToken = () =&gt; localStorage.getItem(TokenKey.ACCESS);
const getRefreshToken = () =&gt; localStorage.getItem(TokenKey.REFRESH);
// 存储新 Token
const setTokens = (accessToken, refreshToken) =&gt; {
  localStorage.setItem(TokenKey.ACCESS, accessToken);
  localStorage.setItem(TokenKey.REFRESH, refreshToken);
};
// 清除 Token（退出登录用）
const removeTokens = () =&gt; {
  localStorage.removeItem(TokenKey.ACCESS);
  localStorage.removeItem(TokenKey.REFRESH);
};

// 3. 刷新状态管理（防止并发请求重复刷新 Token）
let isRefreshing = false; // 是否正在刷新 Token
let requestQueue = []; // 等待刷新完成的请求队列

// 4. 请求拦截器：自动给所有请求添加 Access Token
service.interceptors.request.use(
  (config) =&gt; {
    const token = getAccessToken();
    if (token) {
      // 规范格式：Bearer + 空格 + Token（后端需对应解析）
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) =&gt; Promise.reject(error)
);

// 5. 响应拦截器：处理 Token 过期逻辑
service.interceptors.response.use(
  (response) =&gt; response.data, // 直接返回响应体，简化业务层调用
  async (error) =&gt; {
    const { response, config } = error;
    const originalRequest = config; // 原始失败请求

    // 仅处理 401 状态码（Access Token 过期/无效），且排除刷新 Token 本身的请求
    if (response?.status === 401 &amp;&amp; originalRequest.url !== '/auth/refresh') {
      // 避免重复刷新：正在刷新时，将请求加入队列
      if (isRefreshing) {
        return new Promise((resolve) =&gt; {
          requestQueue.push(() =&gt; {
            // 刷新成功后，用新 Token 重试原始请求
            originalRequest.headers.Authorization = `Bearer ${getAccessToken()}`;
            resolve(service(originalRequest));
          });
        });
      }

      originalRequest._retry = true; // 标记该请求已进入重试流程
      isRefreshing = true; // 开启刷新状态

      try {
        // 调用后端刷新接口，用 Refresh Token 换取新 Token
        const refreshToken = getRefreshToken();
        if (!refreshToken) {
          throw new Error('Refresh Token 不存在');
        }

        const refreshRes = await service.post('/auth/refresh', {
          refreshToken, // 传给后端的 Refresh Token
        });

        // 存储新 Token
        const { accessToken, refreshToken: newRefreshToken } = refreshRes;
        setTokens(accessToken, newRefreshToken);

        // 重试队列中所有等待的请求
        requestQueue.forEach((callback) =&gt; callback());
        requestQueue = []; // 清空队列

        // 重试当前失败的请求
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return service(originalRequest);
      } catch (refreshError) {
        // 刷新失败（Refresh Token 过期/无效），强制跳转登录页
        removeTokens(); // 清除本地无效 Token
        ElMessage.error('登录已过期，请重新登录');
        window.location.href = '/login'; // 跳转到登录页
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false; // 关闭刷新状态
      }
    }

    // 非 401 错误（如网络错误、业务错误），直接抛出
    ElMessage.error(error.message || '请求失败');
    return Promise.reject(error);
  }
);

export default service;
</code></pre><h3>2. 登录与业务请求示例（api/user.js）</h3><pre><code>import service from './index';

// 登录：获取初始双 Token
export const login = (username, password) =&gt; {
  return service.post('/auth/login', { username, password });
};

// 业务请求示例（无需手动处理 Token）
export const getUserInfo = () =&gt; {
  return service.get('/user/info');
};

// 退出登录：清除 Token
export const logout = () =&gt; {
  localStorage.removeItem('access_token');
  localStorage.removeItem('refresh_token');
  window.location.href = '/login';
};
</code></pre><h3>3. 登录页面使用示例（Login.vue）</h3><pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;input v-model="username" placeholder="用户名" /&gt;
    &lt;input v-model="password" type="password" placeholder="密码" /&gt;
    &lt;button @click="handleLogin"&gt;登录&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue';
import { login } from '@/api/user';
import { ElMessage } from 'element-plus';

const username = ref('');
const password = ref('');

const handleLogin = async () =&gt; {
  try {
    // 调用登录接口，后端返回 accessToken 和 refreshToken
    const res = await login(username.value, password.value);
    // 存储 Token（实际已在 api 拦截器中处理，此处简化）
    localStorage.setItem('access_token', res.accessToken);
    localStorage.setItem('refresh_token', res.refreshToken);
    ElMessage.success('登录成功');
    window.location.href = '/home'; // 跳转到首页
  } catch (error) {
    ElMessage.error('登录失败，请检查账号密码');
  }
};
&lt;/script&gt;
</code></pre><h2>三、后端实现（Node.js + Express）</h2><h3>1. 依赖安装</h3><pre><code>npm install express jsonwebtoken redis cors dotenv // 核心依赖</code></pre><h3>2. 核心配置（config.js）</h3><pre><code>require('dotenv').config();

module.exports = {
  // JWT 密钥（生产环境需用环境变量，避免硬编码）
  JWT_SECRET: process.env.JWT_SECRET || 'your-secret-key-321',
  // Token 有效期
  ACCESS_TOKEN_EXPIRES: '1h', // 1 小时
  REFRESH_TOKEN_EXPIRES: '7d', // 7 天
  // Redis 配置（存储 Refresh Token，防止重复使用）
  REDIS: {
    host: 'localhost',
    port: 6379,
    db: 0,
  },
};
</code></pre><h3>3. JWT 工具函数（utils/jwt.js）</h3><pre><code>const jwt = require('jsonwebtoken');
const config = require('../config');

// 生成 Token
const generateToken = (payload, expiresIn) =&gt; {
  return jwt.sign(payload, config.JWT_SECRET, { expiresIn });
};

// 验证 Token
const verifyToken = (token) =&gt; {
  try {
    return jwt.verify(token, config.JWT_SECRET);
  } catch (error) {
    throw new Error('Token 无效或已过期');
  }
};

module.exports = { generateToken, verifyToken };
</code></pre><h3>4. Redis 工具函数（utils/redis.js）</h3><pre><code>const redis = require('redis');
const config = require('../config');

// 创建 Redis 客户端
const client = redis.createClient({
  host: config.REDIS.host,
  port: config.REDIS.port,
  db: config.REDIS.db,
});

// 连接 Redis
client.connect().catch((err) =&gt; console.error('Redis 连接失败:', err));

// 存储 Refresh Token（key: userId, value: refreshToken）
const setRefreshToken = async (userId, refreshToken) =&gt; {
  // 有效期与 Refresh Token 一致（7 天）
  await client.setEx(`refresh_token:${userId}`, 60 * 60 * 24 * 7, refreshToken);
};

// 获取 Refresh Token
const getRefreshToken = async (userId) =&gt; {
  return await client.get(`refresh_token:${userId}`);
};

// 删除 Refresh Token（退出登录时）
const deleteRefreshToken = async (userId) =&gt; {
  await client.del(`refresh_token:${userId}`);
};

module.exports = { setRefreshToken, getRefreshToken, deleteRefreshToken };
</code></pre><h3>5. 核心接口实现（routes/auth.js）</h3><pre><code>const express = require('express');
const router = express.Router();
const { generateToken, verifyToken } = require('../utils/jwt');
const { setRefreshToken, getRefreshToken, deleteRefreshToken } = require('../utils/redis');
const config = require('../config');

// 模拟用户数据库（实际替换为 MySQL/MongoDB）
const mockUsers = [
  { id: 1, username: 'admin', password: '123456' },
];

// 1. 登录接口：生成双 Token
router.post('/login', (req, res) =&gt; {
  const { username, password } = req.body;
  // 验证账号密码
  const user = mockUsers.find(
    (u) =&gt; u.username === username &amp;&amp; u.password === password
  );

  if (!user) {
    return res.status(400).json({ message: '账号或密码错误' });
  }

  // 生成双 Token（payload 中存储用户唯一标识，避免敏感信息）
  const accessToken = generateToken({ userId: user.id }, config.ACCESS_TOKEN_EXPIRES);
  const refreshToken = generateToken({ userId: user.id }, config.REFRESH_TOKEN_EXPIRES);

  // 存储 Refresh Token 到 Redis（用于后续验证）
  setRefreshToken(user.id, refreshToken);

  // 返回双 Token 给前端
  res.json({
    code: 200,
    message: '登录成功',
    data: { accessToken, refreshToken },
  });
});

// 2. 刷新 Token 接口：用有效 Refresh Token 换取新双 Token
router.post('/refresh', async (req, res) =&gt; {
  const { refreshToken } = req.body;
  if (!refreshToken) {
    return res.status(403).json({ message: 'Refresh Token 不能为空' });
  }

  try {
    // 1. 验证 Refresh Token 有效性
    const payload = verifyToken(refreshToken);
    const { userId } = payload;

    // 2. 验证 Redis 中存储的 Refresh Token 是否一致（防止伪造）
    const storedRefreshToken = await getRefreshToken(userId);
    if (storedRefreshToken !== refreshToken) {
      return res.status(403).json({ message: 'Refresh Token 无效' });
    }

    // 3. 生成新的双 Token
    const newAccessToken = generateToken({ userId }, config.ACCESS_TOKEN_EXPIRES);
    const newRefreshToken = generateToken({ userId }, config.REFRESH_TOKEN_EXPIRES);

    // 4. 更新 Redis 中的 Refresh Token（滑动过期，增强安全性）
    await setRefreshToken(userId, newRefreshToken);

    // 5. 返回新 Token
    res.json({
      code: 200,
      data: { accessToken: newAccessToken, refreshToken: newRefreshToken },
    });
  } catch (error) {
    return res.status(403).json({ message: 'Refresh Token 已过期，请重新登录' });
  }
});

// 3. 退出登录接口：删除 Redis 中的 Refresh Token
router.post('/logout', async (req, res) =&gt; {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(400).json({ message: 'Token 不能为空' });
  }

  try {
    const payload = verifyToken(token);
    await deleteRefreshToken(payload.userId);
    res.json({ code: 200, message: '退出登录成功' });
  } catch (error) {
    res.status(400).json({ message: '退出登录失败' });
  }
});

module.exports = router;
</code></pre><h3>6. 后端入口文件（app.js）</h3><pre><code>const express = require('express');
const cors = require('cors');
const authRouter = require('./routes/auth');

const app = express();
const port = 3001;

// 跨域配置（生产环境需限制 origin）
app.use(cors());
// 解析 JSON 请求体
app.use(express.json());

// 挂载路由
app.use('/api/auth', authRouter);

// 启动服务
app.listen(port, () =&gt; {
  console.log(`后端服务启动成功：http://localhost:${port}`);
});
</code></pre><p><a href="https://link.segmentfault.com/?enc=BKrIXZK9O8t%2BXga6Upc%2BJw%3D%3D.4NP%2BnloakcOOVIYrnqybiFIlUM02MnYpdgDl7dSem8Y%3D" rel="nofollow" target="_blank">https://mybj123.com/27766.html</a></p><h2>四、关键注意事项（生产环境必看）</h2><h4>1.安全存储 Token</h4><ul><li>不推荐用 localStorage 存储（易受 XSS 攻击），优先用 HttpOnly Cookie 存储 Refresh Token，前端无法读取，避免窃取。</li><li><p>Access Token 可存在内存（如 Vuex/Pinia），页面刷新后通过 Cookie 获取 Refresh Token 重新刷新。</p><h4>2.防止重复刷新</h4></li><li><p>用isRefreshing状态和requestQueue队列，避免多个并发请求同时触发刷新接口，导致 Token 冲突。</p><h4>3.Redis 的必要性</h4></li><li><p>存储 Refresh Token 到 Redis，支持 “强制登出”“单点登录” 功能（如修改密码后，删除 Redis 中的旧 Refresh Token，强制用户重新登录）。</p><h4>4.HTTPS 协议</h4></li><li><p>生产环境必须启用 HTTPS，防止 Token 在传输过程中被中间人窃取。</p><h4>5.Token 有效期合理设置</h4></li><li>Access Token：15 分钟～2 小时（越短越安全）。</li><li><p>Refresh Token：7~30 天（平衡安全性和用户体验）。</p><h2>五、完整流程梳理</h2></li><li>用户登录 → 后端验证账号密码 → 返回 Access Token 和 Refresh Token → 前端存储。</li><li>前端发起业务请求 → 拦截器自动携带 Access Token → 后端验证有效 → 返回业务数据。</li><li>若 Access Token 过期 → 后端返回 401 → 前端拦截器调用刷新接口。</li><li>刷新接口验证 Refresh Token 有效 → 返回新双 Token → 前端更新存储，重试原始请求。</li><li>若 Refresh Token 过期 → 前端清除 Token，跳转登录页。</li></ul>]]></description></item><item>    <title><![CDATA[详细指南：国科云全面解析SSL证书常见错]]></title>    <link>https://segmentfault.com/a/1190000047399814</link>    <guid>https://segmentfault.com/a/1190000047399814</guid>    <pubDate>2025-11-14 15:04:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>无论您是网站运维人员还是普通用户，了解常见的SSL证书错误及其解决方法都至关重要。本文，国科云将带您逐一排查并解决这些令人头疼的问题。</p><h2>一、证书过期</h2><p>错误现象：</p><p>浏览器显示“您的连接不是私密连接”、“此网站的安全证书已过期”或“NET::ERR_CERT_DATE_INVALID”等错误。</p><p>原因分析：</p><p>SSL证书并非永久有效，它有一个明确的有效期（目前最长为13个月）。一旦超过这个有效期，证书就会失效，浏览器将拒绝建立安全连接。这是出于安全考虑，强制定期验证网站身份和密钥更新。</p><p>解决方法：</p><p>1.对于网站所有者：</p><p>重新购买并部署证书：联系您的证书颁发机构（CA）或服务商，续费或购买一个新的证书。</p><p>完成验证：根据证书类型（DV，OV，EV）完成相应的域名或组织验证。</p><p>安装新证书：将新颁发的证书文件部署到您的Web服务器（如Nginx，Apache，IIS等）上。</p><p>重启服务：部署后，重启Web服务器服务以使新证书生效。</p><p>2.预防措施：</p><p>设置提醒：在证书到期前30天、15天、7天设置多次提醒。大多数证书服务商也提供邮件提醒服务。</p><p>自动化管理：对于DV证书，强烈推荐使用工具实现全自动申请和续期，一劳永逸。</p><p>使用监控工具：使用第三方网站监控服务或自建脚本，定期检查证书有效期。</p><h2>二、证书名称不匹配</h2><p>错误现象：</p><p>浏览器提示“此网站出具的安全证书是针对其他网站的地址”、“NET::ERR_CERT_COMMON_NAME_INVALID”。</p><p>原因分析：</p><p>SSL证书中有一个“通用名称”（CommonName，CN）字段，它必须与用户实际访问的网站域名完全一致。如果访问www.guokeyun.com，但证书是为guokeyun.com颁发的，就会触发此错误。</p><p>常见场景：</p><p>证书仅覆盖主域名（guokeyun.com），但用户访问了带www的域名（www.guokeyun.com），或反之。</p><p>证书是多域名或通配符证书，但当前访问的域名恰好不在证书的覆盖列表中。</p><p>服务器配置错误，将一个站点的证书用在了另一个域名的站点上。</p><p>解决方法：</p><p>1.检查证书覆盖的域名：使用在线SSL检查工具或浏览器自带的证书查看器，确认证书到底为哪些域名提供保护。</p><p>2.确保证书类型匹配需求：</p><p>如果同时有根域名和www域名访问需求，应申请同时包含example.com和www.example.com的多域名证书，或者申请覆盖.example.com的通配符证书。</p><p>3.检查服务器配置：确保Web服务器的虚拟主机配置正确，每个域名都指向了正确的网站目录并加载了对应的证书文件。</p><h2>三、证书颁发机构不受信任</h2><p>错误现象：</p><p>“此证书并非由可信的证书颁发机构颁发”、“NET::ERR_CERT_AUTHORITY_INVALID”。</p><p>原因分析：</p><p>浏览器和操作系统维护着一个“受信任的根证书颁发机构”列表。如果您的SSL证书是由一个不在这个列表中的机构（即“不受信任的CA”）签发的，或者证书链不完整，就会出现此错误。</p><p>具体原因：</p><p>自签名证书：自己创建的证书，未经公共信任的CA签名。常用于内部测试环境。</p><p>证书链不完整：SSL证书的信任是链式的：服务器证书→中间CA证书→根CA证书。如果服务器没有在配置中发送“中间CA证书”，浏览器可能无法追溯到受信任的根证书，从而导致验证失败。</p><p>使用了过时或不常见的CA：某些老旧的系统或特定区域的CA可能未被主流浏览器广泛信任。</p><p>解决方法：</p><p>1.从受信任的CA购买证书：确保您的证书来自全球或国内主流且被广泛信任的CA（如DigiCert，Sectigo，GlobalSign，或国内的CFCA、国科云等）。</p><p>2.安装中间证书：这是最常见的解决方案。当您从CA获取证书时，通常会得到一个或多个“中间CA证书”文件。您需要将这些中间证书与您的服务器证书捆绑在一起，并在Web服务器配置中正确指定这个捆绑后的文件。</p><p>可以使用在线SSL检查工具验证您的证书链是否已正确安装。</p><h2>四、缺乏主题备用名称</h2><p>错误现象：</p><p>在较老的浏览器上可能正常，但在现代浏览器（如Chrome）中访问IP地址或特定域名时，出现“名称不匹配”错误。</p><p>原因分析：</p><p>早期SSL证书只使用“通用名称”（CN）来标识域名。现代标准要求使用“主题备用名称”（SAN）扩展字段来列出所有受保护的域名。如果证书没有SAN字段，而浏览器又严格执行新标准，即使CN正确，也会报错。</p><p>解决方法：</p><p>申请新证书时，确保CA提供了SAN扩展。几乎所有正规的现代证书都默认包含此功能。</p><p>如果您需要保护多个不同的域名（例如example.com，example.net，ip.address），务必申请多域名证书（SAN证书），并在申请时明确列出所有需要的域名。</p><h2>五、混合内容</h2><p>错误现象：</p><p>浏览器地址栏虽然显示了HTTPS和小锁，但小锁上带有感叹号或三角警告，点击后显示“您与此网站之间建立的连接并非完全安全”或“此页面上有其他资源未使用安全连接”。</p><p>原因分析：</p><p>这是最常见且容易被忽略的问题。您的网页主体是通过HTTPS加载的，但页面中包含的子资源（如图片、JavaScript脚本、CSS样式表、iframe等）却是通过不安全的HTTP协议加载的。这被称为“混合内容”（MixedContent）。这会破坏整个页面的安全性，因为攻击者可能劫持这些HTTP资源来篡改页面内容。</p><p>解决方法：</p><p>1.识别混合内容：</p><p>使用浏览器开发者工具（按F12），查看“控制台”（Console）或“安全”（Security）标签页，通常会明确列出不安全的资源URL。</p><p>2.更新资源链接：</p><p>将页面中所有资源的引用链接（src或href属性）从http://改为https://。</p><p>如果第三方服务（如CDN、统计代码、字体库）不支持HTTPS，考虑寻找替代方案。</p><p>3.使用协议相对URL：将链接写成//example.com/resource.js，浏览器会自动根据当前页面的协议（HTTP或HTTPS）来加载资源。但请注意，这种方法在某些特定场景下已不推荐，直接使用HTTPS是更佳实践。</p><h2>六、其他常见错误</h2><p>服务器时钟不正确：如果服务器的时间设置错误（过快或过慢），浏览器在检查证书有效期时可能会误判证书“尚未生效”或“已过期”。确保服务器使用NTP服务进行时间同步。</p><p>浏览器缓存或问题：有时旧的证书信息或SSL状态会被浏览器缓存。尝试清除浏览器缓存和SSL状态。</p><p>Chrome方法：设置-&gt;隐私设置和安全性-&gt;清除浏览数据-&gt;高级-&gt;选择“缓存的图片和文件”以及“其他站点数据”。</p><p>SNI问题：如果一台服务器使用一个IP地址托管多个HTTPS网站，需要依赖“服务器名称指示”（SNI）技术来传递正确的证书。老旧的客户端不支持SNI，会导致收到错误的证书。如今这已不是大问题，但若需支持老旧设备，需考虑其他方案。</p><p>上面这几种情况基本涵盖了常见的SSL证书错误类型，通过本篇介绍，基本上具备了诊断和修复绝大多数SSL证书错误的能力。</p>]]></description></item><item>    <title><![CDATA[自动化技术演进：从工具执行到认知决策，A]]></title>    <link>https://segmentfault.com/a/1190000047399843</link>    <guid>https://segmentfault.com/a/1190000047399843</guid>    <pubDate>2025-11-14 15:03:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399846" alt="图片" title="图片"/><br/>自动化技术的发展从未停滞，从早期机械执行指令的工具，到如今能自主决策的AI智能体，企业的自动化能力正经历一场从“做什么”到“为什么做”的认知革命。这一技术框架，清晰勾勒出自动化的演进路径，帮我们理解不同技术的价值边界与应用场景。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399847" alt="图片" title="图片" loading="lazy"/><br/>自动化技术并非单一形态，而是呈现“传统自动化→AI自动化→AI智能体”的三级金字塔结构，每一层都解决不同维度的问题，创造差异化价值：1.传统自动化（1.0工具级）：“做什么”的机械执行这是自动化的“基础层”，核心是机械执行预设规则，没有智能决策能力。比如：人力资源的“入职流程触发”，新员工录入系统后自动发送入职指引邮件。它适合流程绝对固定、极少变化的场景，像仓储盘点、固定报销流程的第一步，用“稳定可靠”撑起业务的“基本盘”。2.AI自动化（2.0数据智能级）：“怎么做”的数据驱动这一层引入AI模型，聚焦半结构化数据处理与规则辅助决策。比如：智能工单审核：AI识别附件文本后，根据预设规则判断是否合规，给财务人员标红风险点；客户画像分析：AI整合多源数据，按规则生成客户分层，辅助营销决策。它像“智能助手”，把人工从数据处理的繁琐中解放出来，让决策更高效。3.AI智能体（3.0认知智能级）：“为什么做”的场景化决策这是自动化的“天花板”，具备自主决策与推理能力，能模拟人类岗位的全流程服务。比如：金融智能信贷助理：自主分析客户征信、流水数据，判断风险点，给出授信建议；智能客服主管：理解客户复杂需求，自主匹配产品营销，甚至预判客户潜在诉求。它能应对复杂、不确定的场景，实现“岗位级替代”，是企业智能化的核心突破口。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399848" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399849" alt="图片" title="图片" loading="lazy"/><br/>不同自动化技术并非竞争关系，而是根据业务场景选择“最适配方案”。容智信息的对比框架，清晰区分了两者的应用边界：传统自动化：锚定中后台的“稳定刚需”基于工作流构建的传统自动化，适合中后台业务的可靠、稳定特性：流程定义清晰、模式可预测（如每月固定的财务结账流程）；可靠性必须绝对保证（如薪资发放流程，不能有丝毫误差）；决策明确无模糊性（如“库存低于安全线则触发补货”的规则）。典型场景如仓储管理的库存盘点、核心系统的账务处理，用“精确控制”保障业务的稳定运行。AI智能体：激活前台的“交互创新”基于大语言模型（LLM）构建的AI智能体，适合前台业务的灵活、交互性强特点：面向客户：如智能导购能理解客户“想要一款适合通勤的轻便背包”的隐含需求，自主推荐产品；快速迭代：营销话术、服务流程可根据反馈快速调整，无需冗长的开发周期；适配不确定输入：面对客户千奇百怪的咨询问题，能自主推理、生成个性化回应。典型场景如智能客服、个性化营销、复杂业务的智能助理，用“自主决策”打造惊艳的用户体验。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399850" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399851" alt="图片" title="图片" loading="lazy"/><br/>自动化技术的演进并非“二选一”的替代博弈，而是根据业务场景的特性，精准选择适配技术的效能匹配艺术。企业需锚定场景需求——中后台流程依赖传统自动化保障稳定可靠，前台交互场景依托AI智能体突破体验边界，唯有如此，才能在自动化浪潮中实现全链路效能的最大化跃迁。简言之，没有“万能的自动化技术”，只有“场景适配的最优解”。</p><blockquote>互动讨论：你所在的行业或岗位中，更倾向用传统自动化实现流程固定、决策明确的中后台业务，还是用AI智能体探索创新？欢迎聊聊你对自动化技术应用的思考～</blockquote>]]></description></item><item>    <title><![CDATA[无需 iTunes 备份与恢复 iPho]]></title>    <link>https://segmentfault.com/a/1190000047399859</link>    <guid>https://segmentfault.com/a/1190000047399859</guid>    <pubDate>2025-11-14 15:02:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>​许多情况可能导致 iPhone 数据丢失，例如误删重要文件、iOS 更新失败、设备损坏，甚至手机被盗。如果你之前备份过 iPhone，就可以轻松从备份中恢复丢失的数据。然而，很多 iPhone 用户不喜欢使用 iTunes 来备份和恢复数据。iTunes 的主要缺点是它会用最近一次备份覆盖所有现有数据，这可能带来不便。此外，iTunes 有时运行不稳定。如果你没有安装 iTunes，或者根本不想使用它，本文将介绍两种替代方法，帮助你在无需 iTunes 的情况下备份和恢复 iPhone 数据。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399861" alt="图片" title="图片"/></p><h3>方法一：通过 iCloud 无需 iTunes 备份与恢复 iPhone</h3><p>iCloud 是苹果提供的免费云存储服务，默认提供 5GB 免费空间。如果需要更多空间，则需付费升级。当 iTunes 不可用时，iCloud 成为用户的首选。与 iTunes 不同，iCloud 无需在电脑上安装任何软件，操作更加便捷。但 iCloud 的备份与恢复速度较慢，急性子的用户建议直接跳至方法二。</p><p>如何使用 iCloud 备份 iPhone（无需 iTunes）</p><pre><code>打开 iPhone 并连接至稳定的 Wi-Fi 网络。
依次进入“设置” &gt; 你的姓名 &gt; “iCloud”。
确保“iCloud 云备份”已开启，如未开启请手动打开。
点击“立即备份”，开始将 iPhone 数据备份至 iCloud。

</code></pre><p>注意：iCloud 备份速度较慢，请耐心等待。备份完成后，可通过“设置” &gt; 你的姓名 &gt; “iCloud” &gt; “管理存储空间”查看备份内容。</p><p>如何使用 iCloud 恢复 iPhone（无需 iTunes）</p><pre><code>打开 iPhone，进入“设置” &gt; “通用” &gt; “传输或还原 iPhone” &gt; “抹掉所有内容和设置”。
设备将重启并进入初始设置界面。
在“App 与数据”界面，选择“从 iCloud 云备份恢复”。
登录你的 Apple ID，选择备份文件进行恢复。

</code></pre><p>如果你经常忘记手动备份，也可以开启 iCloud 自动备份功能：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399862" alt="图片" title="图片" loading="lazy"/></p><pre><code>进入“设置” &gt; 你的姓名 &gt; “iCloud” &gt; “iCloud 云备份”，确保已开启。
当设备连接 Wi-Fi 并接入电源时，系统会自动备份数据。

</code></pre><h3>方法二：使用 iReaShare iPhone Manager 无需 iTunes 备份与恢复 iPhone（推荐）</h3><p>如果你电脑上没有 iTunes，也不想使用 iCloud，那该怎么办？别担心，你可以选择第三方工具——iReaShare iPhone Manager。它是一款专业的 iOS 数据管理工具，可以快速、安全地将 iPhone、iPad 或 iPod 上的所有数据传输至电脑，反之亦然。它几乎可以实现 iTunes 的所有功能，甚至更加灵活。</p><p>iReaShare iPhone Manager 的主要功能：</p><pre><code>支持备份 iPhone 上的所有数据，包括联系人、短信、备忘录、日历、书签、音乐、视频、照片、书籍、应用等。
可一键完整备份，也可选择性备份所需内容（如仅备份联系人和照片）。
支持将数据导出至电脑或 iTunes 作为备份。
操作简单，几步即可完成备份与恢复。
兼容所有 iPhone 型号（如 iPhone 16/15/14/13/12/11/X/8/7/6）及所有 iPad 和 iPod 设备。

</code></pre><p>如何使用 iReaShare iPhone Manager 备份 iPhone（无需 iTunes）</p><p>步骤 1： 在电脑上安装并启动 iReaShare iPhone Manager，使用 USB 数据线连接 iPhone。软件将自动识别你的设备。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399863" alt="图片" title="图片" loading="lazy"/></p><p>步骤 2： 点击顶部菜单中的“超级工具箱”，进入“iTunes 备份与恢复”功能界面。</p><p>步骤 3： 选择“备份”选项，软件将列出所有已连接的 iOS 设备。选择你的 iPhone，并设置备份保存位置（默认或自定义）。</p><p>步骤 4： 点击“确定”开始备份 iPhone 数据。</p><p>如何使用 iReaShare iPhone Manager 恢复 iPhone（无需 iTunes）</p><p>步骤 1： 启动软件并连接 iPhone 至电脑，等待识别。</p><p>步骤 2： 点击顶部菜单中的“超级工具箱” &gt; “iTunes 备份与恢复” &gt; “恢复”。</p><p>步骤 3： 软件将列出所有备份记录，选择你想恢复的备份文件，点击“确定”开始恢复。你也可以选择性地备份数据。例如，若只想备份照片，可在左侧菜单中点击“照片”，预览并选择所需照片后，点击“导出”按钮，将其保存至电脑指定位置。</p><h3>总结</h3><p>现在你已了解两种无需 iTunes 备份与恢复 iPhone 的方法：</p><pre><code>iCloud：适合轻度用户，但备份速度慢，免费空间有限。
iReaShare iPhone Manager：功能强大，支持完整或选择性备份，速度快，不依赖网络，推荐优先使用。

</code></pre><p>立即下载试用吧！如果你还有其他无需 iTunes 快速备份/恢复 iPhone 的方法，欢迎留言分享！<br/>​</p>]]></description></item><item>    <title><![CDATA[一文讲清楚数据脱敏是什么 风流的滑板_L]]></title>    <link>https://segmentfault.com/a/1190000047399785</link>    <guid>https://segmentfault.com/a/1190000047399785</guid>    <pubDate>2025-11-14 15:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>很多企业在选择数据库管理系统时，通常会选择具有数据脱敏功能的软件。相信很多人会感到好奇，数据脱敏功能具体指向什么呢？为什么企业如此重视呢？简单来说，数据脱敏是指通过特定方法对敏感数据进行处理，使其在非生产环境中无法识别个人身份或关键信息，同时保持数据格式和部分特征，以支持开发、测试或分析等用途。在数字化时代，数据已成为企业的核心资产，而数据库作为存储和管理数据的关键系统，其安全性直接关系到隐私保护、合规运营和商业声誉。数据库信息安全不仅涉及防止外部攻击，还包括内部数据访问的严格控制。数据脱敏作为一种有效的数据保护技术，正日益成为数据库信息安全策略的重要组成部分。如果你想了解更多关于数据脱敏的定义、意义、类别及常用方法，不妨往下看看！<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm20v" alt="" title=""/><br/>1、什么是数据脱敏？<br/>数据脱敏，也称为数据匿名化或数据伪装，是一种数据安全技术，旨在保护敏感信息不被未授权访问。其核心原理是在保留数据实用性的前提下，对原始数据中的敏感字段进行变形、替换或屏蔽，从而生成一个“脱敏”后的数据集。例如，在数据库中将真实姓名替换为虚构名称，或将身份证号部分数字隐藏。数据脱敏不同于永久性销毁数据，它允许数据在脱敏后继续用于非敏感场景，如软件测试、数据分析或员工培训。通过数据脱敏，组织可以显著降低数据泄露风险，确保即使在数据共享或外包环境中，敏感信息也不会暴露。本质上，数据脱敏是数据库信息安全的第一道防线，它平衡了数据可用性与隐私保护的需求。<br/>举个例子，你有一张生产环境用户表：<br/><img width="723" height="169" referrerpolicy="no-referrer" src="/img/bVdm20B" alt="" title="" loading="lazy"/><br/>经过信息脱敏后：<br/><img width="723" height="158" referrerpolicy="no-referrer" src="/img/bVdm20D" alt="" title="" loading="lazy"/><br/>数据脱敏的意义不仅体现在技术层面，还涉及法律、商业和伦理等多个维度，数据脱敏不仅是一种技术措施，更是构建企业信任和推动可持续发展的基石。首先，从数据库信息安全的角度看，数据脱敏能够有效防止数据滥用和泄露。在内部开发或测试环境中，如果直接使用真实数据，一旦被员工或第三方误用，可能导致严重的隐私侵犯事件。通过实施数据脱敏，组织可以确保敏感数据在非生产环境中“去标识化”，从而降低内部威胁和意外风险。其次，数据脱敏是满足合规要求的关键手段法规明确要求，在非必要情况下，不得使用可识别个人身份的数据。数据脱敏通过匿名化处理，帮助企业遵守这些规定，避免高额罚款和法律纠纷。此外，在数据分析或机器学习项目中，使用脱敏数据可以加快数据共享流程，同时保护核心商业机密。例如，电商企业可以通过数据脱敏分析用户行为模式，而无需暴露具体交易细节。3、数据脱敏的类别根据应用场景和处理方式，数据脱敏可以分为静态数据脱敏和动态数据脱敏两大类。我们可以将“静态脱敏”理解为“搬家”，即适用于数据迁移、备份或测试等场景，它在数据存储阶段对原始数据集进行永久性处理，生成一个脱敏后的副本。例如，将生产数据库中的客户数据导出为测试数据时，通过替换或扰乱敏感字段，确保副本中不包含真实信息。这种方法常用于离线环境，操作简单且效率高，但需要定期更新以反映数据变化。<br/><img width="723" height="273" referrerpolicy="no-referrer" src="/img/bVdm20I" alt="" title="" loading="lazy"/><br/>动态数据脱敏则可以理解为“戴面具”，更侧重于实时保护，它在数据访问过程中动态地对敏感信息进行脱敏。例如，当用户查询数据库时，系统根据用户权限实时隐藏或修改部分数据。假设一个客服人员需要查看客户信息，动态数据脱敏可能只显示电话号码的后四位，而隐藏其他数字。这种方法适用于在线交易系统或多租户数据库，能够在不改变底层数据的前提下，实现精细化的访问控制。<br/>4、数据脱敏的常用方法<br/>数据脱敏的常用方法多样，从简单的替换到复杂的加密技术，每种方法都有其适用场景。简单为大家介绍六种方法：替代法、屏蔽法、扰乱法、加密法、泛化法、合成法。<br/>● 替换法：这是最常见的数据脱敏方法，通过将敏感数据替换为虚构但格式一致的值。例如，将真实姓名替换为随机生成的假名，或将邮箱地址替换为通用模板。替换法简单高效，能保持数据的一致性，适用于测试环境。然而，它可能无法完全隐藏数据模式，因此在高度敏感场景中需结合其他方法。<br/>● 屏蔽法：屏蔽法通过隐藏部分数据内容来实现数据脱敏，例如只显示身份证号的前几位，其余用星号代替。这种方法常用于动态数据脱敏，如在用户界面上实时屏蔽敏感信息。它操作简便，但对数据实用性的影响较大，可能不适合需要完整数据格式的场景。<br/>● 扰乱法：扰乱法通过随机化或重排数据顺序来破坏原始信息的可读性。例如，将日期字段中的年份和月份交换，或将数值数据乘以一个随机因子。这种方法能有效保护隐私，但可能改变数据分布，影响统计分析结果。因此，它常用于非关键性测试。<br/>● 加密法：加密法作为数据加密的方法之一，在数据脱敏中扮演重要角色。它使用加密算法（如 AES 或 RSA）将敏感数据转换为密文，只有授权用户才能通过密钥解密。加密法适用于可逆脱敏场景，如数据共享或备份。然而，它计算开销较大，可能影响数据库性能，因此需权衡安全与效率。<br/>● 泛化法：泛化法通过降低数据精度来实现数据脱敏，例如将具体年龄替换为年龄段（如“ 20-30 岁”），或将详细地址替换为城市名。这种方法在保持数据统计价值的同时，有效保护个人隐私，常用于研究或报告场景。<br/>● 合成法：合成法通过生成人工数据来替代真实数据，这些数据基于原始分布生成，但不对应任何真实个体。例如，使用算法生成虚拟客户记录。这种方法在机器学习和测试中广泛应用，能最大程度降低泄露风险，但需要复杂的建模技术。<br/>5、结语<br/>数据脱敏作为数据库信息安全的核心技术，不仅能够有效防范数据泄露风险，还能助力企业满足法规要求和提升商业价值。从静态到动态脱敏，从替换到加密方法，数据脱敏的多样化为不同场景提供了灵活解决方案。相信你已经对数据脱敏有了一定的认识了解，如果你需要进一步选择相应系统，可以自行寻找合适的数据库管理系统，市面上大多数数据库工具都有数据脱敏的功能，希望这篇文章对你了解数据脱敏有所帮助～</p>]]></description></item><item>    <title><![CDATA[数据安全新选择：为什么国产SSL证书正在]]></title>    <link>https://segmentfault.com/a/1190000047399441</link>    <guid>https://segmentfault.com/a/1190000047399441</guid>    <pubDate>2025-11-14 14:09:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>近年来，国产SSL证书凭借多重优势，逐渐从“备选方案”晋升为众多企业的“首选配置”。这一转变背后，是技术突破、政策导向与市场需求的共振。</p><p><strong>一、技术自主：打破国外依赖，筑牢安全底座</strong></p><p>国产SSL证书的核心竞争力，首先体现在“自主可控”的技术基因上。传统SSL证书市场长期被国外品牌主导，而国产证书采用国密算法（如SM2、SM3、SM4），实现了从根证书签发到加密算法的全链路国产化。这意味着数据加密、传输验证等关键环节不再依赖国外技术，从源头降低了数据泄露风险。</p><p>这种“技术主权”的掌握，让企业无需再担忧国外技术后门或供应链风险。</p><p><strong>二、性能升级：速度与安全兼得，体验全面跃升</strong></p><p>以前很多企业担忧国产SSL证书可能影响网站访问速度。但实测数据显示，国产证书的OCSP（在线证书状态协议）验签服务器部署在国内，验证速度比国外证书快30%以上。</p><p>此外，国密算法在加密强度上表现优异。SM2算法采用256位密钥长度，安全强度远超RSA 2048位。这种“又快又安全”的特性，让国产证书成为高并发场景下的理想选择。</p><p><strong>三、政策驱动：合规需求倒逼，国产化势在必行</strong></p><p>《密码法》《关键信息基础设施安全保护条例》等法规相继实施，明确要求关键行业采用国产密码技术。政务、金融、能源等领域的企业，若未通过等保测评或密评，将面临业务受阻的风险。</p><p>政策红利的释放，正加速国产SSL证书在重点行业的普及。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399443" alt="" title=""/><a href="" target="_blank"/></p><p><strong>四、服务升级：本地化支持，破解运维难题</strong></p><p>相比国外证书，国产SSL证书的另一大优势在于“贴身服务”。国内CA机构提供全中文技术支持，从证书申请、部署到后期维护，均有专人对接。而使用国外证书时，类似问题需等待数天才能获得英文回复。</p><p>此外，国产证书的审核周期更短。以OV证书为例，国外品牌通常需3-5个工作日，而国产证书可缩短至1-2天，极大提升了企业部署效率。</p><p><strong>五、成本优化：性价比凸显，中小企业普惠</strong></p><p>过去，高昂的证书费用让中小企业对SSL证书望而却步。而国产证书通过技术创新和规模化应用，将成本降低了30%-50%。且支持无限次免费重签。</p><p>这种“普惠”特性，让更多企业能以低成本实现全站加密。数据显示，2025年一季度，国内中小企业采购国产SSL证书的数量同比增长67%，其中通配符证书占比超过40%。</p><p><strong>总结</strong></p><p>尽管国产SSL证书已取得显著进展，但兼容性问题仍是挑战。不过，随着主流浏览器和操作系统对国密算法的支持加强，这一瓶颈正在被打破。</p>]]></description></item><item>    <title><![CDATA[国密SSL证书的三大核心优势：自主可控、]]></title>    <link>https://segmentfault.com/a/1190000047399468</link>    <guid>https://segmentfault.com/a/1190000047399468</guid>    <pubDate>2025-11-14 14:08:49</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>国密SSL证书作为国产密码技术的重要应用，其核心优势体现在以下三个方面：</p><p><strong>国密SSL证书⬇️</strong></p><p><a href="https://link.segmentfault.com/?enc=uEfVECT4jidlYVARMj9BHQ%3D%3D.OfT6bLh2lyS8D6oBcP%2BUJd9m8WY25%2B0P%2BamvCqDzQHHoHNByRgSrt0SZ1JerEBy1sM%2F%2FtUxeLddlNm1NDNP6v%2BVvzUXlUCFwc1wNdmR0Y5Y%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/national_secret_alg...</a></p><p><img width="723" height="450" referrerpolicy="no-referrer" src="/img/bVdmOqt" alt="93b41f9735e5bc85205fe82990af4f60.png" title="93b41f9735e5bc85205fe82990af4f60.png"/></p><h3>一、<strong>自主可控：打破技术依赖，保障安全主权</strong></h3><ul><li><strong>全流程自主化</strong>：国密SSL证书采用我国自主研发的SM2/SM3/SM4算法体系，从加密算法到证书签发均实现国产化，避免因使用国外技术（如RSA/SHA）导致的“后门”风险或供应链中断隐患。</li><li><strong>政策强制要求</strong>：根据《密码法》《网络安全法》及等保2.0标准，关键领域（政务、金融、能源）必须优先采用国产密码技术。例如，某省级政务云平台迁移至国密SSL证书后，成功通过等保2.0三级认证，合规成本降低65%。</li><li><strong>抗量子威胁能力</strong>：SM2基于椭圆曲线密码学，相比RSA算法更抗量子计算攻击，为未来安全需求提供前瞻性保障。</li></ul><h3>二、<strong>合规性：满足国家标准与行业监管</strong></h3><ul><li><strong>密评密改核心工具</strong>：商用密码应用安全性评估（密评）要求数据传输需采用国密算法。国密SSL证书是政务、金融等行业通过等保测评的必要条件，未达标可能导致业务停摆或罚款。</li><li><strong>全场景适配资质</strong>：主流CA机构提供的国密证书已覆盖DV/OV/EV类型，并支持单域名、多域名及通配符绑定，满足从基础网站到高安全场景的需求。</li></ul><h3>三、<strong>高性能：优化资源效率，提升用户体验</strong></h3><ul><li><strong>低延迟高吞吐</strong>：SM2算法密钥长度仅256位（相当于RSA 2048位的安全强度），SSL握手数据量更少，经测试服务器新建并发响应时间比RSA快12-15倍，金融交易系统单笔加密耗时从8ms降至2ms。</li><li><strong>轻量化计算消耗</strong>：SM2算法在相同安全等级下，CPU占用率比RSA低40%，显著降低服务器负载，尤其适合高并发场景（如电商大促、政务高峰期）。</li></ul>]]></description></item><item>    <title><![CDATA[免费的午餐？Let‘s Encrypt的]]></title>    <link>https://segmentfault.com/a/1190000047399476</link>    <guid>https://segmentfault.com/a/1190000047399476</guid>    <pubDate>2025-11-14 14:08:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>免费的午餐？Let's Encrypt 的利与弊，你真的了解吗？</strong><br/>在推动互联网全面加密（HTTPS）的浪潮中，Let's Encrypt 如同一颗耀眼的明星，它让获取 SSL 证书变得像申请邮箱一样简单和免费。但这份“免费的午餐”究竟是完美无缺，还是有所取舍？理解其双面性，对于为您的网站做出正确选择至关重要。</p><p><strong>一、革命性的贡献：Let's Encrypt 的“利”</strong></p><p>Let's Encrypt 的诞生是一场安全民主化运动，其带来的好处是颠覆性的：</p><p><strong>完全免费，零成本加密</strong></p><p>这是它最核心的吸引力。它彻底消除了部署 HTTPS 的经济门槛，让个人站长、开源项目、小型企业都能无负担地获得基础的安全保障。</p><p><strong>申请自动化，极速签发</strong></p><p>通过其官方的 Certbot 工具或其他客户端，整个申请、验证和部署流程可以完全自动化。通常只需一行命令，几分钟内就能完成，证书自动安装到服务器上，体验远超传统证书繁琐的人工审核。</p><p><strong>推动 HTTPS 普及，功不可没</strong></p><p>Let's Encrypt 的使命就是“创建一个更安全、更尊重隐私的互联网”。它极大地降低了 HTTPS 的部署难度，是推动全球网站加密率飙升的最大功臣之一。</p><p><strong>二、现实的权衡：Let's Encrypt 的“弊”</strong></p><p>免费和便捷的背后，是其在功能和服务上做出的必要牺牲：</p><p><strong>仅有基础域名验证</strong></p><p>Let's Encrypt 只提供<strong> DV（域名验证）</strong> 证书。它只验证你对域名的控制权，不验证你的企业或组织身份。这意味着它无法向用户证明你是一家真实的、合法的公司，信任层级停留在“通信加密”，而非“身份可信”。</p><p><strong>较短的有效期与续订压力</strong></p><p>它的证书有效期仅为<strong>90天</strong>。此举旨在鼓励自动化并减少安全风险，但万一自动续订脚本失败（如服务器宕机、配置错误），网站就会面临因证书过期而中断服务的风险，需要额外的运维精力来监控。</p><p><strong>功能限制：不支持通配符？不，现在支持了！</strong></p><p>（更新） 早期 Let's Encrypt 不支持通配符证书是一个主要缺点，但现在它已经支持。这无疑是一个巨大的改进，使得管理拥有众多子域名的网站变得更加方便。</p><p>但需要注意的是，通配符证书的自动化管理和续订可能比单域名证书稍复杂。</p><p><strong>缺乏人工支持与担保</strong></p><p>作为一项免费服务，你无法在遇到技术问题时获得及时的电话或工单支持，主要依赖于社区和文档。同时，免费证书不提供任何安全担保或保险。如果因证书本身的问题导致用户损失，你无法获得赔偿。</p><p><strong>三、决策指南：我该如何选择？</strong></p><p>为了帮助您更直观地判断 Let's Encrypt 是否适合您的网站，可以参考以下决策路径：<br/><img width="723" height="1587" referrerpolicy="no-referrer" src="/img/bVdm2Vl" alt="" title=""/></p><p><strong>结论：</strong></p><p><strong>Let's Encrypt 绝非有弊无利，而是“利在普惠，弊在深度”。</strong></p><p>它是一份完美的“免费午餐”，但菜单上的选择是固定的。它出色地解决了 “<strong>从无到有</strong>” 的安全问题，是绝大多数个人和非商业网站的绝佳选择。</p><p>然而，对于需要进行在线交易、展示企业实体信誉、或需要更稳定保障的商业网站而言，付费的<strong>OV（组织验证）</strong> 或 <strong>EV（扩展验证）</strong> 证书所提供的身份信任、更长有效期、技术支持和财务担保，仍然是不可或缺的专业增值服务。</p><p><strong>明智的做法是：根据你的网站性质和需求，判断这份“免费午餐”是否能满足你的全部营养所需。</strong></p>]]></description></item><item>    <title><![CDATA[Zoho出席苏南制造业数智化峰会，破解制]]></title>    <link>https://segmentfault.com/a/1190000047399498</link>    <guid>https://segmentfault.com/a/1190000047399498</guid>    <pubDate>2025-11-14 14:07:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>11月8日，第八届苏南制造业数智化峰会暨昆山市数字化创新协会年会在昆山成功举办。大会以“AI+，如何全链条重塑制造业”为主题，汇集了500强企业技术领袖、专家学者及数字化服务商代表，共同探讨AI浪潮下，企业数字化转型新路径。Zoho作为全球知名SaaS厂商，携制造业数智化转型方案亮相现场，与业界共话产业升级新机遇。</p><p>苏南作为中国制造业的核心承载地之一，拥有多个国家级先进制造业集群、5G工厂、灯塔工厂，数字化工具普及率位居前列。昆山市数字化创新协会会长徐井西在致辞中强调，苏南制造业正处于从 “数字化转型” 向 “数智原生” 跨越的关键阶段，亟需技术与实践的深度融合。</p><p>峰会上，Zoho展示了生产制造业CRM解决方案。Zoho CRM通过定制化功能、供应链管理集成、产品生命周期管理、客户关系管理优化和数据分析与预测等方面的实现，使得与制造业的结合更加紧密。制造业企业可以借助Zoho CRM提升生产效率、客户满意度和市场竞争力，实现数字化转型和持续发展。</p><p>苏南制造的转型实践具有行业风向标意义，而当前制造业普遍面临客户信息分散、部门数据割裂、销售流程低效等痛点，这些正是 Zoho 解决方案的核心发力点。</p><p>未来，Zoho将积极融入苏南制造业生态，与昆山市数字化创新协会及行业伙伴携手，共同推动数智技术在制造业的深度应用，为培育新质生产力、构建全球领先的制造产业生态贡献力量。</p><pre><code>                               获取更多资讯，请关注公众号：Zoho
                                         —— END ——
</code></pre>]]></description></item><item>    <title><![CDATA[什么是CRM软件？从入门到精通，8款主流]]></title>    <link>https://segmentfault.com/a/1190000047399518</link>    <guid>https://segmentfault.com/a/1190000047399518</guid>    <pubDate>2025-11-14 14:07:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在竞争激烈的商业环境中，企业如何高效管理客户资源、提升销售业绩？答案就是CRM软件。据统计，使用CRM软件的企业销售额平均提升29%，销售生产力提高34%。本文将全面解析CRM软件的核心价值，并深度评测8款市场主流产品，帮助您找到最适合的解决方案。</p><h2>一、CRM软件是什么？</h2><h3>1.1 CRM软件的本质</h3><p>CRM软件（Customer Relationship Management Software）是一种帮助企业系统化管理客户关系的数字化工具。它通过技术手段将客户信息、销售流程、营销活动、服务记录等数据整合到统一平台，实现客户全生命周期的智能化管理。</p><p><strong>简单来说</strong>：CRM软件就像企业的"客户管理大脑"，记录每一次互动，预测每一个商机，优化每一个决策。</p><h3>1.2 CRM软件 vs 传统管理方式</h3><table><thead><tr><th>对比维度</th><th>传统方式（Excel/纸质）</th><th>CRM软件</th></tr></thead><tbody><tr><td>数据存储</td><td>分散、易丢失</td><td>集中云端、安全可靠</td></tr><tr><td>信息共享</td><td>困难、易出错</td><td>实时同步、全员可见</td></tr><tr><td>客户跟进</td><td>依赖记忆、易遗漏</td><td>自动提醒、智能分配</td></tr><tr><td>数据分析</td><td>手工统计、耗时长</td><td>自动生成、实时可视</td></tr><tr><td>团队协作</td><td>沟通成本高</td><td>协同高效、流程透明</td></tr><tr><td>移动办公</td><td>无法实现</td><td>随时随地访问</td></tr></tbody></table><h3>1.3 CRM软件的核心价值</h3><h4>💰 <strong>提升销售业绩</strong></h4><ul><li>缩短销售周期平均14%</li><li>提高成交率27%</li><li>增加客单价23%</li></ul><h4>🎯 <strong>优化客户体验</strong></h4><ul><li>响应速度提升3倍</li><li>客户满意度提高35%</li><li>客户流失率降低27%</li></ul><h4>📊 <strong>数据驱动决策</strong></h4><ul><li>实时掌握销售漏斗</li><li>精准预测销售业绩</li><li>识别高价值客户</li></ul><h4>⚡ <strong>提高工作效率</strong></h4><ul><li>自动化重复任务节省40%时间</li><li>减少数据录入错误</li><li>加速审批流程</li></ul><hr/><h2>二、CRM软件的核心功能模块</h2><h3>📇 <strong>客户信息管理</strong></h3><ul><li><strong>360度客户画像</strong>：整合所有客户数据</li><li><strong>联系人管理</strong>：记录关键决策人信息</li><li><strong>客户分级</strong>：识别A/B/C类客户</li><li><strong>互动历史</strong>：完整的沟通记录</li></ul><h3>🎯 <strong>销售流程管理</strong></h3><ul><li><strong>线索管理</strong>：捕获、分配、培育潜在客户</li><li><strong>商机跟踪</strong>：可视化销售漏斗</li><li><strong>报价管理</strong>：快速生成专业报价单</li><li><strong>合同管理</strong>：电子签署、自动归档</li></ul><h3>📧 <strong>营销自动化</strong></h3><ul><li><strong>邮件营销</strong>：批量发送、效果追踪</li><li><strong>客户细分</strong>：精准定位目标群体</li><li><strong>营销活动</strong>：多渠道活动管理</li><li><strong>ROI分析</strong>：评估营销投入产出</li></ul><h3>🛠️ <strong>客户服务支持</strong></h3><ul><li><strong>工单系统</strong>：问题追踪与解决</li><li><strong>知识库</strong>：自助服务资源</li><li><strong>满意度调查</strong>：收集客户反馈</li><li><strong>SLA管理</strong>：服务水平保障</li></ul><h3>📈 <strong>报表与分析</strong></h3><ul><li><strong>销售仪表盘</strong>：实时业绩监控</li><li><strong>预测分析</strong>：AI驱动的业绩预测</li><li><strong>自定义报表</strong>：按需生成各类报告</li><li><strong>数据可视化</strong>：图表化呈现关键指标</li></ul><hr/><h2>三、8款主流CRM软件深度评测</h2><h3>🥇 1. Zoho CRM - 性价比之王</h3><p>![评分：★★★★★ 4.8/5.0]</p><p><strong>产品定位</strong>：适合各规模企业的全功能CRM平台</p><h4><strong>核心亮点</strong></h4><p><strong>🤖 AI智能助手Zia</strong></p><ul><li>智能预测最佳联系时间</li><li>自动识别异常数据</li><li>语音助手快速操作</li><li>情感分析客户邮件</li></ul><p><strong>🎨 高度可定制</strong></p><ul><li>Canvas设计器自由布局界面</li><li>自定义模块、字段、工作流</li><li>灵活的权限管理</li><li>个性化仪表盘</li></ul><p><strong>🔗 强大集成能力</strong></p><ul><li>与1000+应用集成</li><li>完整的Zoho生态（邮件、文档、会议等）</li><li>API开放平台</li><li>支持自定义开发</li></ul><p><strong>💼 全渠道沟通</strong></p><ul><li>邮件、电话、短信、社交媒体统一管理</li><li>实时聊天集成</li><li>WhatsApp业务集成</li><li>微信集成（中国版）</li></ul><h4><strong>适用场景</strong></h4><ul><li>✅ 需要全面功能的中小企业</li><li>✅ 追求性价比的成长型企业</li><li>✅ 需要深度定制的企业</li><li>✅ 多部门协作的组织</li></ul><h4><strong>定价方案</strong></h4><ul><li><strong>免费版</strong>：3用户，基础功能</li><li><strong>标准版</strong>：￥14/用户/月</li><li><strong>专业版</strong>：￥23/用户/月</li><li><strong>企业版</strong>：￥40/用户/月</li><li><strong>旗舰版</strong>：￥52/用户/月</li></ul><h4><strong>用户评价</strong></h4><blockquote>"功能强大且价格合理，AI助手Zia真的很实用，帮我们节省了大量时间。" - 某科技公司销售总监</blockquote><p><strong>推荐指数：⭐⭐⭐⭐⭐</strong></p><hr/><h3>🎯 2. Zoho Bigin - 小微企业首选</h3><p>![评分：★★★★★ 4.7/5.0]</p><p><strong>产品定位</strong>：专为小微企业和初创团队设计的轻量级CRM</p><h4><strong>核心亮点</strong></h4><p><strong>📱 移动优先设计</strong></p><ul><li>直观的移动应用</li><li>离线模式工作</li><li>一键拨号和发邮件</li><li>扫描名片自动录入</li></ul><p><strong>⚡ 极简易用</strong></p><ul><li>10分钟快速上手</li><li>无需复杂培训</li><li>清爽的用户界面</li><li>聚焦核心功能</li></ul><p><strong>🔄 管道可视化</strong></p><ul><li>拖拽式管道管理</li><li>多管道并行管理</li><li>自定义销售阶段</li><li>一目了然的进度追踪</li></ul><p><strong>💡 智能工作流</strong></p><ul><li>自动分配线索</li><li>跟进任务提醒</li><li>邮件自动化</li><li>简化日常操作</li></ul><h4><strong>适用场景</strong></h4><ul><li>✅ 10人以下小团队</li><li>✅ 初创公司</li><li>✅ 个人创业者</li><li>✅ 预算有限的企业</li></ul><h4><strong>定价方案</strong></h4><ul><li><strong>Express版</strong>：￥7/用户/月</li><li><strong>Premier版</strong>：￥12/用户/月</li><li>提供15天免费试用</li></ul><h4><strong>用户评价</strong></h4><blockquote>"作为初创公司，Bigin完美满足我们的需求，不会因为功能太多而困惑。" - 某电商创业者</blockquote><p><strong>推荐指数：⭐⭐⭐⭐⭐（小微企业）</strong></p><hr/><h3>🏢 3. Salesforce Sales Cloud - 企业级标杆</h3><p>![评分：★★★★☆ 4.5/5.0]</p><p><strong>产品定位</strong>：全球领先的企业级CRM平台</p><h4><strong>核心亮点</strong></h4><ul><li><strong>Einstein AI</strong>：业界领先的AI能力</li><li><strong>AppExchange</strong>：5000+应用扩展</li><li><strong>高度可扩展</strong>：支持复杂业务场景</li><li><strong>企业级安全</strong>：金融级数据保护</li></ul><h4><strong>适用场景</strong></h4><ul><li>大型企业、跨国公司</li><li>复杂业务流程</li><li>需要深度定制</li></ul><h4><strong>定价方案</strong></h4><ul><li>从￥150/用户/月起</li><li>企业版：￥1200/用户/月</li></ul><h4><strong>优缺点</strong></h4><p>✅ 功能最全面  <br/>✅ 生态系统强大  <br/>❌ 价格昂贵  <br/>❌ 学习曲线陡峭  </p><p><strong>推荐指数：⭐⭐⭐⭐（大型企业）</strong></p><hr/><h3>🎨 4. HubSpot CRM - 免费版王者</h3><p>![评分：★★★★☆ 4.6/5.0]</p><p><strong>产品定位</strong>：入站营销与CRM一体化平台</p><h4><strong>核心亮点</strong></h4><ul><li><strong>永久免费版</strong>：功能丰富不限用户数</li><li><strong>营销中心</strong>：强大的内容营销工具</li><li><strong>用户友好</strong>：界面现代、易上手</li><li><strong>教育资源</strong>：免费的营销学院课程</li></ul><h4><strong>适用场景</strong></h4><ul><li>内容营销驱动的企业</li><li>注重入站营销</li><li>预算紧张的初创公司</li></ul><h4><strong>定价方案</strong></h4><ul><li><strong>免费版</strong>：永久免费</li><li><strong>入门版</strong>：￥50/月起</li><li><strong>专业版</strong>：￥800/月起</li></ul><h4><strong>优缺点</strong></h4><p>✅ 免费版功能强大  <br/>✅ 营销工具出色  <br/>❌ 高级功能价格跳跃大  <br/>❌ 销售功能相对简单  </p><p><strong>推荐指数：⭐⭐⭐⭐</strong></p><hr/><h3>🚀 5. Pipedrive - 销售管道专家</h3><p>![评分：★★★★☆ 4.4/5.0]</p><p><strong>产品定位</strong>：专注销售流程的可视化CRM</p><h4><strong>核心亮点</strong></h4><ul><li><strong>可视化管道</strong>：直观的拖拽式界面</li><li><strong>活动管理</strong>：强大的任务提醒系统</li><li><strong>销售报告</strong>：清晰的业绩追踪</li><li><strong>移动应用</strong>：优秀的移动体验</li></ul><h4><strong>适用场景</strong></h4><ul><li>销售驱动型团队</li><li>需要清晰销售流程管理</li><li>外勤销售团队</li></ul><h4><strong>定价方案</strong></h4><ul><li><strong>基础版</strong>：￥99/用户/月</li><li><strong>高级版</strong>：￥199/用户/月</li><li><strong>专业版</strong>：￥399/用户/月</li></ul><h4><strong>优缺点</strong></h4><p>✅ 销售流程管理出色  <br/>✅ 界面简洁直观  <br/>❌ 营销功能较弱  <br/>❌ 定制能力有限  </p><p><strong>推荐指数：⭐⭐⭐⭐</strong></p><hr/><h3>💼 6. Microsoft Dynamics 365 - 微软生态整合</h3><p>![评分：★★★★☆ 4.3/5.0]</p><p><strong>产品定位</strong>：深度集成微软生态的企业CRM</p><h4><strong>核心亮点</strong></h4><ul><li><strong>Office 365集成</strong>：无缝对接Outlook、Teams</li><li><strong>LinkedIn集成</strong>：Sales Navigator深度整合</li><li><strong>Power BI分析</strong>：强大的数据分析能力</li><li><strong>ERP集成</strong>：财务业务一体化</li></ul><h4><strong>适用场景</strong></h4><ul><li>微软生态用户</li><li>需要ERP+CRM一体化</li><li>大中型企业</li></ul><h4><strong>定价方案</strong></h4><ul><li><strong>销售专业版</strong>：￥450/用户/月</li><li><strong>销售企业版</strong>：￥750/用户/月</li></ul><h4><strong>优缺点</strong></h4><p>✅ 微软生态集成完美  <br/>✅ 企业级功能强大  <br/>❌ 价格昂贵  <br/>❌ 实施周期长  </p><p><strong>推荐指数：⭐⭐⭐⭐（微软用户）</strong></p><hr/><h3>🌟 7. Freshsales - 现代化体验</h3><p>![评分：★★★★☆ 4.5/5.0]</p><p><strong>产品定位</strong>：AI驱动的现代化销售CRM</p><h4><strong>核心亮点</strong></h4><ul><li><strong>Freddy AI</strong>：智能线索评分</li><li><strong>内置通讯</strong>：电话、邮件、聊天一体化</li><li><strong>现代界面</strong>：清爽的用户体验</li><li><strong>快速部署</strong>：即开即用</li></ul><h4><strong>适用场景</strong></h4><ul><li>快速成长的中小企业</li><li>追求现代化体验</li><li>SaaS行业</li></ul><h4><strong>定价方案</strong></h4><ul><li><strong>免费版</strong>：基础功能</li><li><strong>成长版</strong>：￥15/用户/月</li><li><strong>专业版</strong>：￥39/用户/月</li><li><strong>企业版</strong>：￥69/用户/月</li></ul><h4><strong>优缺点</strong></h4><p>✅ AI功能实用  <br/>✅ 性价比高  <br/>❌ 高级定制能力有限  <br/>❌ 生态系统较小  </p><p><strong>推荐指数：⭐⭐⭐⭐</strong></p><hr/><h3>🇨🇳 8. 纷享销客 - 本土化领导者</h3><p>![评分：★★★★☆ 4.2/5.0]</p><p><strong>产品定位</strong>：中国本土企业级CRM+PaaS平台</p><h4><strong>核心亮点</strong></h4><ul><li><strong>本土化深度</strong>：符合中国企业管理习惯</li><li><strong>连接型CRM</strong>：打通企业内外部系统</li><li><strong>移动优先</strong>：适配钉钉、企业微信</li><li><strong>行业方案</strong>：多行业解决方案</li></ul><h4><strong>适用场景</strong></h4><ul><li>中国本土中大型企业</li><li>需要本地化服务</li><li>复杂组织架构</li></ul><h4><strong>定价方案</strong></h4><ul><li>根据企业需求定制报价</li><li>通常年费制</li></ul><h4><strong>优缺点</strong></h4><p>✅ 本土化服务好  <br/>✅ 适合中国企业  <br/>❌ 国际化能力弱  <br/>❌ 价格相对较高  </p><p><strong>推荐指数：⭐⭐⭐⭐（本土企业）</strong></p><hr/><h2>四、CRM软件选型指南</h2><h3>🎯 按企业规模选择</h3><h4><strong>微型企业（1-10人）</strong></h4><p><strong>首选</strong>：Zoho Bigin、HubSpot免费版</p><ul><li>预算：￥0-100/月</li><li>关注点：易用性、移动化</li><li>实施周期：1-3天</li></ul><h4><strong>小型企业（10-50人）</strong></h4><p><strong>首选</strong>：Zoho CRM标准版、Freshsales</p><ul><li>预算：￥500-2000/月</li><li>关注点：性价比、扩展性</li><li>实施周期：1-2周</li></ul><h4><strong>中型企业（50-200人）</strong></h4><p><strong>首选</strong>：Zoho CRM专业版、Pipedrive</p><ul><li>预算：￥2000-10000/月</li><li>关注点：功能全面、集成能力</li><li>实施周期：2-4周</li></ul><h4><strong>大型企业（200人以上）</strong></h4><p><strong>首选</strong>：Salesforce、Microsoft Dynamics 365、Zoho CRM企业版</p><ul><li>预算：￥10000+/月</li><li>关注点：定制化、安全性</li><li>实施周期：1-3个月</li></ul><hr/><h3>💼 按行业选择</h3><table><thead><tr><th>行业</th><th>推荐CRM</th><th>理由</th></tr></thead><tbody><tr><td><strong>B2B制造业</strong></td><td>Zoho CRM、Salesforce</td><td>复杂销售流程、长周期管理</td></tr><tr><td><strong>B2C电商</strong></td><td>HubSpot、Zoho CRM</td><td>营销自动化、客户细分</td></tr><tr><td><strong>专业服务</strong></td><td>Zoho CRM、Freshsales</td><td>项目管理、时间追踪</td></tr><tr><td><strong>房地产</strong></td><td>Zoho CRM、Pipedrive</td><td>线索管理、跟进提醒</td></tr><tr><td><strong>教育培训</strong></td><td>Zoho Bigin、HubSpot</td><td>学员管理、课程营销</td></tr><tr><td><strong>金融保险</strong></td><td>Salesforce、Dynamics 365</td><td>合规性、安全性</td></tr><tr><td><strong>SaaS科技</strong></td><td>Freshsales、Zoho CRM</td><td>产品试用追踪、订阅管理</td></tr></tbody></table><hr/><h3>📋 选型决策清单</h3><h4><strong>第一步：明确需求（1-2天）</strong></h4><ul><li>[ ] 列出必须具备的功能</li><li>[ ] 确定预算范围</li><li>[ ] 明确用户数量</li><li>[ ] 识别集成需求</li><li>[ ] 评估定制化程度</li></ul><h4><strong>第二步：筛选候选（3-5天）</strong></h4><ul><li>[ ] 根据需求筛选3-5款产品</li><li>[ ] 查看产品演示视频</li><li>[ ] 阅读用户评价</li><li>[ ] 对比功能和价格</li><li>[ ] 申请免费试用</li></ul><h4><strong>第三步：深度试用（1-2周）</strong></h4><ul><li>[ ] 让实际使用者参与测试</li><li>[ ] 导入部分真实数据</li><li>[ ] 测试关键业务流程</li><li>[ ] 评估易用性</li><li>[ ] 测试移动应用</li></ul><h4><strong>第四步：最终决策（3-5天）</strong></h4><ul><li>[ ] 团队反馈汇总</li><li>[ ] ROI预估</li><li>[ ] 供应商沟通</li><li>[ ] 合同条款审核</li><li>[ ] 制定实施计划</li></ul><hr/><h2>五、CRM软件实施成功的5大关键</h2><h3>1️⃣ <strong>高层支持是前提</strong></h3><ul><li>获得管理层的明确支持</li><li>分配专门的项目负责人</li><li>确保足够的预算和资源</li></ul><h3>2️⃣ <strong>数据准备是基础</strong></h3><ul><li>清理历史客户数据</li><li>统一数据格式标准</li><li>规划数据迁移策略</li><li>确保数据质量</li></ul><h3>3️⃣ <strong>培训赋能是关键</strong></h3><ul><li>分层次培训计划</li><li>提供操作手册和视频</li><li>设立内部CRM专家</li><li>持续的答疑支持</li></ul><h3>4️⃣ <strong>流程优化是核心</strong></h3><ul><li>梳理现有业务流程</li><li>识别优化机会</li><li>在CRM中固化最佳实践</li><li>持续改进迭代</li></ul><h3>5️⃣ <strong>激励机制是保障</strong></h3><ul><li>将CRM使用纳入KPI</li><li>表彰积极使用者</li><li>展示成功案例</li><li>建立正向反馈循环</li></ul><hr/><h2>六、CRM软件使用常见误区</h2><h3>❌ <strong>误区1：功能越多越好</strong></h3><p><strong>正确认知</strong>：适合的才是最好的，过多无用功能反而降低效率。</p><h3>❌ <strong>误区2：买了就能见效</strong></h3><p><strong>正确认知</strong>：CRM是工具，需要配合流程优化和团队执行。</p><h3>❌ <strong>误区3：只有销售部门用</strong></h3><p><strong>正确认知</strong>：CRM应该是全公司的客户中心，营销、服务都要参与。</p><h3>❌ <strong>误区4：数据录入是负担</strong></h3><p><strong>正确认知</strong>：短期投入换来长期收益，自动化可减少手工录入。</p><h3>❌ <strong>误区5：一次性项目</strong></h3><p><strong>正确认知</strong>：CRM是持续优化的过程，需要长期运营。</p><hr/><h2>七、2025年CRM软件发展趋势</h2><h3>🤖 <strong>AI深度融合</strong></h3><ul><li>智能线索评分更精准</li><li>对话式AI助手普及</li><li>预测分析能力增强</li><li>自动化程度提升</li></ul><h3>📱 <strong>移动化加速</strong></h3><ul><li>移动优先设计成为标配</li><li>离线功能更完善</li><li>AR/VR技术应用</li><li>语音交互普及</li></ul><h3>🔗 <strong>生态系统整合</strong></h3><ul><li>与更多业务系统打通</li><li>低代码/无代码平台</li><li>API经济繁荣</li><li>数据中台建设</li></ul><h3>🎯 <strong>垂直行业深化</strong></h3><ul><li>行业专属解决方案</li><li>最佳实践模板</li><li>行业数据基准</li><li>合规性增强</li></ul><h3>🌍 <strong>全球化与本土化并重</strong></h3><ul><li>多语言、多币种支持</li><li>本地化合规要求</li><li>跨境业务管理</li><li>区域化数据中心</li></ul><hr/><h2>八、结论与建议</h2><p>选择合适的CRM软件是企业数字化转型的重要决策。基于本文的深度分析，我们给出以下建议：</p><h3>🏆 <strong>综合推荐榜</strong></h3><p><strong>🥇 最佳综合选择：Zoho CRM</strong></p><ul><li>功能全面、性价比高、适合各规模企业</li><li>强大的AI能力和定制化选项</li><li>完善的生态系统和持续创新</li></ul><p><strong>🥈 小微企业最佳：Zoho Bigin</strong></p><ul><li>专为小团队设计，简单易用</li><li>价格亲民，快速上手</li><li>移动优先，随时随地管理</li></ul><p><strong>🥉 免费版最佳：HubSpot CRM</strong></p><ul><li>永久免费，功能丰富</li><li>适合预算紧张的初创公司</li><li>营销工具出色</li></ul><h3>💡 <strong>最后的建议</strong></h3><ol><li><strong>不要急于决策</strong>：充分试用2-3款产品后再做选择</li><li><strong>从小规模开始</strong>：先在一个部门试点，成功后再推广</li><li><strong>重视培训</strong>：工具再好，不会用也是摆设</li><li><strong>持续优化</strong>：CRM是长期项目，需要不断调整改进</li><li><strong>关注ROI</strong>：定期评估投入产出比，确保价值实现</li></ol><h2>常见问题解答（FAQ）</h2><p><strong>Q1：小公司有必要用CRM软件吗？</strong><br/>A：非常有必要！小公司更需要高效管理有限的客户资源。Zoho Bigin等轻量级CRM价格低廉，能显著提升效率。</p><p><strong>Q2：CRM软件实施需要多长时间？</strong><br/>A：取决于企业规模和复杂度。小企业1-2周，中型企业2-4周，大型企业1-3个月。</p><p><strong>Q3：CRM软件的数据安全吗？</strong><br/>A：主流CRM供应商都采用银行级加密和多重安全措施。选择有ISO 27001认证的供应商更有保障。</p><p><strong>Q4：可以更换CRM软件吗？</strong><br/>A：可以，但有成本。建议初期就选对产品。大多数CRM支持数据导出，便于迁移。</p><p><strong>Q5：CRM软件能和现有系统集成吗？</strong><br/>A：主流CRM都提供丰富的集成选项和API，可与ERP、财务、营销等系统对接。</p>]]></description></item><item>    <title><![CDATA[点量云流突破架构壁垒，实现全栈信创自主可]]></title>    <link>https://segmentfault.com/a/1190000047399524</link>    <guid>https://segmentfault.com/a/1190000047399524</guid>    <pubDate>2025-11-14 14:06:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在信创产业加速推进的背景下，软硬件技术的自主可控成为关键发展路径。点量云流率先实现从硬件适配到软件生态的全栈信创布局，为各行业提供安全可靠的实时云渲染解决方案。</p><p><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm2V3" alt="" title=""/></p><h3>一、全面覆盖主流硬件架构，夯实自主根基</h3><p>点量云流实时云渲染率先完成对ARM架构的深度适配，全面支持鲲鹏等国产芯片，同时兼容x86架构的海光、兆芯等处理器，实现跨平台硬件覆盖。在图形处理层面，点量云流已完成对摩尔线程等国产GPU的兼容适配，建立起从计算到渲染的完整国产化硬件支撑体系，真正筑牢了自主可控的底层基础。</p><p><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm2V5" alt="" title="" loading="lazy"/></p><h3>二、构建完整软件生态兼容能力</h3><p>在操作系统层面，点量云流已完成与统信UOS、麒麟Kylin等主流国产操作系统的全面适配。在图形接口方面，全面支持OpenGL、DirectX、Vulkan等主流图形接口标准。同时，确保了Unreal Engine（UE）、Unity3D、WebGL等主流渲染引擎的顺畅运行，保障了现有数字内容的无缝迁移与稳定呈现。</p><p><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm2We" alt="" title="" loading="lazy"/></p><h3>三、打造端到端的全栈信创解决方案</h3><p>点量云流通过硬件架构的全面适配与软件生态的完整兼容，构建起真正的全栈信创能力，有效解决了信创环境中常见的硬件掣肘与软件断层问题，确保用户在不同架构平台上都能获得一致的高质量实时云渲染体验。</p><p><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdmT11" alt="" title="" loading="lazy"/></p><p>点量云流以ARM架构适配突破为核心，建立起覆盖硬件、操作系统、图形接口与渲染引擎的全栈信创能力，为政务、教育、工业等关键领域提供了安全可靠、高效稳定的实时云渲染服务，有力推动信创产业生态的完善与发展。</p>]]></description></item><item>    <title><![CDATA[StarRocks 4.0：让 Apac]]></title>    <link>https://segmentfault.com/a/1190000047399539</link>    <guid>https://segmentfault.com/a/1190000047399539</guid>    <pubDate>2025-11-14 14:05:12</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><p>导读：</p><p>StarRocks 4.0 已正式发布！这一版本将优化能力从查询层延伸至数据层，通过全新的 Global Shuffle Ingestion、Spill-Aware Writes、Compaction API 与 Local Sort 等特性，让数据在写入的同时即完成优化。面对 Apache Iceberg 等开放格式中“小文件过多、查询延迟高”的挑战，StarRocks 4.0 将数据仓库级的治理理念引入 Lakehouse 架构，实现了从写入、组织到维护的全链路提速。</p><p>本文将带你了解这些关键机制如何让 Lakehouse 变得真正 _Query-Ready_。</p></blockquote><p>在 Apache Iceberg 表中，数据的写入方式往往并未针对查询性能进行优化。持续不断的微批写入会产生成千上万个小文件；也很难做到让数据在写入后的第一时间就能被快速查询。</p><p>结果是：查询变慢、资源占用激增，成本也随之持续攀升。</p><h2>为什么仅靠查询优化无法解决性能问题</h2><p>查询优化可以不断地进行剪枝、缓存和向量化处理——但再聪明的优化器，也无法扭转“小文件风暴”带来的性能损耗。在实际使用中，性能不稳定往往源于以下几个原因：</p><ul><li>在分布式、并发、多分区写入过程中，小文件迅速倍增；</li><li>数据写入时未经过排序，削弱了剪枝与 I/O 合并效果；</li></ul><p>传统的事后合并虽有助于缓解问题，但过程复杂、触发不及时，常常错过数据刚刚写入的关键窗口。</p><h2>让数据湖具备数据仓库级的治理能力</h2><p>在传统数据仓库中，几乎不会出现“小文件过多”或性能波动的问题。因为数据在写入存储前，通常已经经过合并和排序等优化处理；同时，后台还会有轻量级服务持续维护系统的稳定与高效。</p><p>我们将这一理念引入 Apache Iceberg，构建了两层优化机制。</p><p><strong>1. Ingestion-first（写入优先）</strong></p><p>在数据写入前，系统会智能路由以避免写入冲突；在落盘前，数据经过缓冲与合并，最终以更大、更整洁的文件写入存储。这意味着——数据一旦落地，即可被查询，无需等待漫长的合并或维护任务。</p><p><strong>2. Compaction service</strong></p><p>后台服务持续运行，不断将小文件合并为适合查询的文件，并保持分区均衡。服务具有限流、跳过热点、即时可用等机制，能够在需要时快速完成数据整理。</p><p>借助这两层机制，Iceberg 表的运行特性更接近数据仓库表：</p><ul><li>高负载下写入依然稳定；</li><li>新写入的数据可立即查询；</li><li>后台合并优化，确保查询性能始终如一。</li></ul><h2>StarRocks 如何让这一理念落地</h2><p>StarRocks 是一款为 Apache Iceberg 等开放格式而生的高性能 SQL 引擎，专注于低延时与高并发查询。</p><p>无论是实时数据看板，还是大规模的用户侧分析场景，StarRocks 都能以强大的查询性能为支撑，让“速度”成为用户体验的核心竞争力。</p><h3>StarRocks 4.0 新特性</h3><p>在 4.0 版本中，StarRocks 的优化不再局限于查询执行层，而是进一步下沉到数据层——从写入、组织到维护，实现全链路优化。</p><h4>全局 Shuffle 写入机制</h4><p>全新的 Global Shuffle Ingestion  机制能够在集群节点间智能分配数据写入，避免后端之间的冲突。每个节点只负责部分分区，从而生成更少但更大的文件，避免“小文件”泛滥。这一机制显著降低了元数据开销，并在高分区场景下大幅提升查询扫描效率。</p><h4>感知溢出的写入机制（Spill-Aware Writes）</h4><p>在内存压力增大时，StarRocks 不再被动提前刷写数据，而是尽可能将数据缓存在内存中，并在需要时自动将其溢写到磁盘或对象存储。</p><p>这一机制避免了因防止 OOM 而过早生成小文件的问题，使数据文件更接近理想大小，即使在上千分区的复杂写入场景下，仍能保持稳定、高效的性能表现。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399541" alt="" title=""/></p><h4>Compaction API</h4><p>在需要进行数据维护时——例如经历大量微批写入之后——StarRocks 4.0 引入了全新的 Compaction API。</p><p>它复用了写入阶段的同一套 Shuffle、Spill 与 Sort 逻辑，可按需快速完成文件合并。</p><p>借助这一机制，用户无需借助外部工具，即可直接在 StarRocks 内完成数据布局的修复与优化。</p><h4>本地排序</h4><p>在文件层面，StarRocks 现已支持在写入阶段完成数据排序。每个文件内部保持有序，更便于剪枝优化，无需额外的排序任务即可显著降低查询延时。</p><p>数据在写入的同时即完成优化，可直接支撑快速、稳定、可预测的查询体验。</p><h3>Benchmarks</h3><p>我们针对 Apache Iceberg 表进行了多组写入测试，对比 StarRocks 4.0 与 3.4 版本在不同负载下的表现。</p><p>测试涵盖 100、500 和 1000 个分区的典型场景，指标包括写入延时、文件数量与平均文件大小。</p><p>主要结果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399542" alt="" title="" loading="lazy"/></p><ul><li><strong>大规模写入稳定性显著提升</strong>：旧版本在超过 100 个分区时常出现 OOM 错误；而 4.0 版本可稳定支持多达 1000 个分区的写入，无任何失败。</li><li><strong>写入延时大幅降低</strong>：在 100 分区下，写入时间缩短一半以上；在 500 分区下，延时减少约 75%，端到端数据新鲜度显著提升。</li><li><strong>文件数量骤减</strong>：新的写入路径生成的文件更少、体量更大。在 100 分区测试中，文件数从 17 万余个降至仅 259 个；在 500 分区下，则从 23 万多个降至 596 个。</li></ul><h3>A Query-Ready Lakehouse</h3><p>Apache Iceberg 为现代 Lakehouse 架构带来了开放性与治理能力，但要实现高性能，仅有开放格式还不够——还需要像数据仓库那样，对底层文件进行有序的管理与优化。</p><p>在 StarRocks 4.0 中，这种“仓库级的严谨”已被融入系统内核：</p><p>数据落地即具备可查询状态，写入过程稳定高效，合并维护可按需即时完成。</p><p>由此，StarRocks 让 Lakehouse 兼具数据仓库的速度与可预测性，同时保留开放架构的灵活与自由。</p>]]></description></item><item>    <title><![CDATA[Visual Studio 2026 正]]></title>    <link>https://segmentfault.com/a/1190000047399548</link>    <guid>https://segmentfault.com/a/1190000047399548</guid>    <pubDate>2025-11-14 14:04:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Visual Studio 2026 正式版发布 - 适用于 Windows 上 .NET 和 C++ 开发人员的最全面 IDE</p><p>The most comprehensive IDE for .NET and C++ developers on Windows</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=zgofAhZHzjPcEu16GUKcWA%3D%3D.f59yLFoPZZ7kzJ3eOznHXg0B4FPyNcBLAbxEdTIb%2FFaix2aPG%2B1S8gJkO%2BYSbFup" rel="nofollow" target="_blank">https://sysin.org/blog/visual-studio-2026/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=zsEjmQN8dOzEnKXMP9LIkw%3D%3D.68Nt33fNXKm28Lx5UtOEiqnbMOsBKsLxIbuUUqVpuZ8%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>你和 AI。协作效果更佳。</p><p>无试用版。无需信用卡。只需 GitHub 帐户。</p><p>让 Copilot 免费版和 Visual Studio 帮助你生成和重构代码、调试代码、识别 bug 和解决方法、优化性能，并在整个编码工作流中获取特定于上下文的帮助。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399550" alt="Visual Studio 2026" title="Visual Studio 2026"/></p><h2>Visual Studio 2026 重磅发布：更快、更智能</h2><p>Visual Studio Engineering Team，November 11th, 2025</p><p>亲爱的开发者们，</p><p>Microsoft 非常激动地宣布，Visual Studio 2026 现在正式发布！这是 Microsoft 与您一同共同打造的时刻。您的反馈在这次发布中起到了前所未有的重要作用。自从 9 月推出 Insiders Channel 以来，更多的开发者下载并测试了这个预览版，创下了 Visual Studio 历史上的新纪录。</p><p>在过去的一年里，Microsoft 修复了超过 <strong>5000</strong> 个您报告的 bug，并实现了 <strong>300</strong> 个功能请求 (sysin)。这是 Microsoft 有史以来做的最多的改进，而且 Microsoft 才刚刚起步！</p><p>凭借若干性能改进、重新设计的用户体验和在 AI 驱动开发方面的重大突破，这次发布旨在帮助开发者专注于真正重要的事情：创造。每一次点击、每一次敲击键盘、每一次编译都变得更加流畅、更快、更直观 —— 让您以前所未有的速度将创意变成代码。</p><p>你是否有过因为延迟中断工作流的那种沮丧感？Microsoft 花了很多时间，努力把这种问题变成过去式。<strong>极速性能</strong> 意味着启动速度更快，UI 响应如此流畅，您几乎察觉不到它的存在，挂起时间减少了超过 50%，让 IDE 即便在庞大的项目中也能保持轻便、顺畅的体验。无论您是在处理企业级仓库，还是在调整小型代码库，这都为提高效率设立了新的标杆。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399551" alt="solution load time image" title="solution load time image" loading="lazy"/><br/>图 1：显示了大规模 .NET 解决方案加载至交互的时间，比 VS 2022 更快</p><p>但这不仅仅是让解决方案加载更快。UI 在加载过程中也保持更加响应。事实上，那些令人恼火的 UI 冻结现象已经减少了一半以上。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399552" alt="solution load hang time image" title="solution load hang time image" loading="lazy"/><br/>图 2：显示了 UI 无响应时间在大规模解决方案加载中比 VS 2022 少了一半以上</p><p>数据统计是很酷的，但真正重要的是使用时的体验。IDE 的运行变得更快、更流畅、更灵敏。这是你从数字中无法直接看出的感觉。</p><p>“<em>哇！我刚刚打开了一个包含超过 100 个项目的解决方案，我简直不敢相信它这么快就启动并准备好了！干得好，Visual Studio 团队！</em>”</p><p>– Steve Smith，NimblePros 首席软件架构师</p><p>Visual Studio 2026 是原生支持 AI 的，使其成为全球首个 <strong>智能开发环境</strong> (IDE)。这并不意味着改变您的工作方式，而是提供您最需要的智能支持。无论是在调试棘手问题、分析性能，还是进行应用现代化时，AI 都能帮助消除摩擦，提供帮助您更快推进的见解，同时保持您的工作流程不受干扰。它的目的是提升您已经信赖的实践，而不是替代它们。</p><p>这个版本还带来了全新的 C# 和 C++ 代理，专为每天需要高精度和速度的专业开发者设计。这些功能扩展了您的工作能力，避免了增加复杂性，让您在掌控一切的同时，更高效地完成工作。Visual Studio 2026 并不是为了 AI 而添加 AI，而是您所依赖的工具的自然进化，旨在提升您的生产力。</p><p>这种进化打开了曾经遥不可及的可能性，将 AI 自然融入到您的日常工作流中。GitHub Copilot 已迅速成为 Visual Studio 中最受欢迎的功能之一，赢得了每天依赖它的开发者的高度评价。</p><p>“<em>Visual Studio 中的性能分析工具立即突出了瓶颈，并引导我实现了更快速、更清洁的性能 —— 就像有一个内置的性能教练。</em>”</p><p>– Roberto Perez，Redis 高级全球解决方案架构师</p><p>当你全天候使用 Visual Studio 时，每一次交互都至关重要。Microsoft 在 <strong>完善基础功能</strong> 上加大了投入 —— 消除摩擦，修复那些微小的 “纸上伤痕”，优化工作流。这次发布引入了一个灵活的新设置系统、一个现代化的 UI 重新设计，以及数百项潜在的改善，让 IDE 在各个方面都感觉更好。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399553" alt="feedback tickets fixed image" title="feedback tickets fixed image" loading="lazy"/><br/>图 3：Visual Studio 团队在过去 12 个月中解决的反馈问题数量</p><p>在过去的 12 个月里，您的反馈帮助 Microsoft 修复了超过 <strong>5000</strong> 个 bug，并增加了超过 <strong>300</strong> 个功能请求。这是 Microsoft 为一次重要的 Visual Studio 发布做出的最大努力，而这个势头还在持续增长。通过 AI 驱动的工具加速 Microsoft 发现并解决问题的速度，Microsoft 比以往更快地交付改进。</p><p>“<em>我最喜欢 Visual Studio 2026 的地方是性能和崭新清爽的 UI —— 支持 Mermaid 图表更是锦上添花。</em>”</p><p>– Erik Ejlskov Jensen，Context&amp; A/S</p><p>最棒的部分是：<strong>Visual Studio 2026 完全兼容您从 Visual Studio 2022 的项目和扩展</strong>。打开现有的解决方案，立即开始编码。没有迁移步骤，没有意外。您所有喜爱的扩展也都可以使用，因此您的工作区、工具和项目将无缝过渡，让 IDE 从第一次启动开始就如家一般。</p><p>目前与 Visual Studio 2022 兼容的超过 4000 个扩展都能在 Visual Studio 2026 中继续使用。您可以放心升级，您的设置将保持与以往一样稳定和熟悉。</p><p>“<em>从 Visual Studio 2022 升级扩展是个决定性的优势：我可以立即开始使用 VS 2026。</em>”</p><p>– Didier Donner，Aspen Technology 首席软件工程师</p><p>另外，借助 GitHub Copilot 应用现代化，.NET 10 的升级和最新 C++ 构建工具也能得到加速，并通过专业指导帮助您充分利用所有最新的性能提升和功能。GitHub Copilot 新增的 C++ 功能，现在可以通过个人预览版体验。</p><p>长期以来，更新 Visual Studio 意味着您也得更新 .NET 和 C++ 构建工具，因为这些工具与 IDE 紧密耦合。这往往让事情变得棘手，因为您既想要最新的功能和 bug 修复，但更新可能会影响现有项目，或者迫使您做出工具链上的变化，可能并</p><h2>解锁代理模式: 执行操作的 AI</h2><p>在 Visual Studio 中使用 AI 支持的代理模式，更快地重构、生成和创建。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399554" alt="GitHub AI image" title="GitHub AI image" loading="lazy"/></p><p>由你控制。AI 协助。</p><p>只需你和你的 GitHub 帐户，无需附加任何字符串。</p><p>✅ <strong>更快地访问工作代码，没有快捷方式</strong></p><ul><li>在数秒内自动完成整个函数和基架原型</li><li>使用智能建议自动执行重复性任务</li><li>使用代理工作流和预生成模板更快地生成项目</li></ul><p>✅ <strong>自信地修复和调试复杂代码</strong></p><ul><li>通过自然语言解释了解旧的逻辑</li><li>使用内存分析、根本原因见解和 Copilot 对话助手更智能地调试</li><li>通过内联修复程序和实施策略提前发现问题</li></ul><p>✅ <strong>自动提供干净且可测试的代码</strong></p><ul><li>直接通过代码生成单元测试和 docstring</li><li>通过质量门强制实施命名、样式和安全策略</li><li>通过 CI 感知测试覆盖范围和策略检查来验证更改</li></ul><p>✅ <strong>跨团队缩放最佳做法</strong></p><ul><li>自动执行复杂任务重构 → 生成 → 测试 → PR</li><li>使用提示、模板和特定于团队的规则进行扩展</li><li>使用企业级控制、安全性和 SIEM 集成来治理代码</li></ul><h2>下载地址</h2><p>Microsoft Visual Studio Enterprise 2026 v18.0.0 GA Windows x64 简体中文 | 繁體中文 | English</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=lbvIWBT%2FKb8dFndHqAheqA%3D%3D.6CFdcSpXzDoYSYyI5BEmb%2BEJgc7WZkXt%2B1rjn3mMYHZDtV9fanjDH4q8wcEZ7x2N" rel="nofollow" target="_blank">https://sysin.org/blog/visual-studio-2026/</a></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=XrtphkTq1fzOjz1JfYX5dA%3D%3D.BWZGnvucA7CZ7qK0Sro%2FoOhCYU%2FXm%2F%2BHyInibOsLnLw%3D" rel="nofollow" target="_blank">Windows 下载汇总</a></p>]]></description></item><item>    <title><![CDATA[Burp Suite Professio]]></title>    <link>https://segmentfault.com/a/1190000047399556</link>    <guid>https://segmentfault.com/a/1190000047399556</guid>    <pubDate>2025-11-14 14:03:45</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Burp Suite Professional 2025.11 发布，新增功能简介</p><p>Burp Suite Professional 2025.11 (macOS, Linux, Windows) - Web 应用安全、测试和扫描</p><p>Burp Suite Professional, Test, find, and exploit vulnerabilities.</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=%2BVmyQa7F1jCJqvzl5ynVrQ%3D%3D.9VeNLxt%2Bx9h%2Fh31Fo%2F3CZg7CsnHrh8ns0gZMoRJw%2B9MUVzf%2Bc3f6YDAU8I201FR%2F" rel="nofollow" target="_blank">https://sysin.org/blog/burp-suite-pro/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=AizbmnZHVZ3axo6G2KAw1w%3D%3D.htQ4ju%2BKqHwMIsaLUpERD5WQax%2BajPCTccLI8hmpeRg%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>Burp Suite Professional，更快、更可靠的安全测试，领先的 Web 安全测试工具包。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044800612" alt="roadmap" title="roadmap"/></p><h2>Burp Suite Pro 简介</h2><p>Burp Suite Professional 是一套用于测试 web 安全性的高级工具集 —- 所有这些都在一个产品中。从一个基本的拦截代理到尖端的 Burp 扫描器，使用 Burp Suite Pro，正确的工具只需点击一下就可以了。</p><p>强大的自动化让您有更多的机会做您最擅长的 (sysin)，而 Burp Suite 处理容易实现的目标。先进的手动工具将帮助你识别目标更微妙的盲点。</p><p>Burp Suite Pro 是由一个研究团队开发的。这意味着在发布之前，发现成果已经包含在最新更新中。 pentesting 工具将使您的工作更快，同时让您了解最新的攻击向量。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044800613" alt="Burp Suite 专业版" title="Burp Suite 专业版" loading="lazy"/></p><h2>新增功能</h2><p>Burp Suite Professional / Community <strong>2025.11</strong></p><p>2025 年 11 月 13 日</p><p>此次发布增加了一个命令面板以加快键盘导航、改进了内存控制，并增强了自定义扫描检查中的 OAST 支持。</p><p>🖥️ <strong>命令面板以加快键盘导航</strong></p><p>添加了一个命令面板，帮助您仅通过键盘快速查找和使用 Burp 的功能。按 <code>Ctrl+K</code> 或 <code>Cmd+K</code> 开始输入，您可以在不浏览菜单的情况下访问工具、设置和扩展。</p><p>为了支持这一功能，扩展了快捷键支持。您现在可以为以下命令分配快捷键：</p><ul><li>从 <strong>Repeater</strong> 运行 Burp AI 任务。</li><li>在子标签之间切换。</li><li>重命名 <strong>Repeater</strong> 标签。</li></ul><p>还添加了图标和类别，以帮助您更轻松地导航命令。</p><p>如果您已经将 <code>Ctrl+K</code> 或 <code>Cmd+K</code> 分配给其他命令 (sysin)，则命令面板将没有默认快捷键。您可以在 <strong>Settings &gt; User interface &gt; Hotkeys</strong> 中手动设置一个。</p><p>➕ <strong>将扩展命令添加到命令面板</strong></p><p>如果您是扩展开发者，您现在可以通过注册命名的快捷键将自己的命令添加到命令面板中。</p><p>💻 <strong>更轻松地管理 Burp 的内存使用</strong></p><p>更新了 <strong>Maximum memory usage</strong> 设置说明，更清楚地解释了 Burp 如何使用可用内存，以及如何调整该设置以平衡 Burp 的性能和系统的需求。</p><p>此外，该设置现在更易于发现：</p><ul><li>您可以直接从底部状态栏访问它 (sysin)，状态栏还显示当前的内存使用情况和分配给 Burp 的总内存。</li><li>它已被移到 <strong>Settings</strong> 窗口中的新 <strong>Suite &gt; Performance</strong> 类别下。</li></ul><p>🔄 <strong>在自定义扫描检查中处理 Burp Collaborator 交互</strong></p><p>您现在可以在活动的自定义扫描检查中使用 Burp Collaborator 来检测带外漏洞。</p><p>要启用此功能，请在您的检查中启用 <strong>Use Collaborator</strong>，然后在新的 <strong>Collaborator</strong> 标签中添加交互处理器。Burp 将轮询交互并将其传递给您的处理器进行分析和报告。</p><p>只要检查仍然处于活动状态 (sysin)，Burp 将在扫描完成后继续监控延迟交互。</p><p>⚙️ <strong>更新的 Intruder 负载列表</strong></p><p>根据 PortSwigger XSS 备忘单更新了 Burp Intruder 的预定义负载列表。</p><p>您可以在配置 <strong>Intruder</strong> 中的负载时直接从 <strong>Add from list...</strong> 下拉菜单中选择这些列表。</p><p>🛠️ <strong>用户体验改善</strong></p><p>做出了以下用户体验改善：</p><ul><li>当后续请求返回不同响应时，Burp 不再覆盖站点地图中的原始响应。这有助于您直接从站点地图中访问更有用的上下文。</li><li>更新了 Burp 的证书 (sysin)，包含了 Authority Key Identifier。这确保了与新版本的 Python 库的兼容性，并防止了拦截时出现 SSL 错误。</li><li>您从 <strong>target analyzer</strong> 保存的报告现在默认包括 <code>.html</code> 扩展名，因此您可以立即打开它们，无需重新命名。</li></ul><p>🐞 <strong>错误修复</strong></p><p>修复了以下错误：</p><ul><li><strong>task Logger</strong> 标签中的 <strong>Hide items without responses</strong> 过滤器未正确应用的问题。</li><li>更新了 <strong>Learn</strong> 标签中的视频链接，指向了正确的内容。</li></ul><h2>下载地址</h2><p><strong>Burp Suite Professional 2025.11</strong>, 13 November 2025</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=4mk6CYTjRYlJKPUP6zCzUw%3D%3D.nIAinm8jMFDRjPSo%2FHbD4VOPNZYkK2Dg9YH%2BWKlnzG2GmdZ%2FJfEow7hxYsqHSFsA" rel="nofollow" target="_blank">https://sysin.org/blog/burp-suite-pro/</a></li></ul><table><thead><tr><th><strong>Architectures/Description</strong></th><th><strong>File name (Professional)</strong></th></tr></thead><tbody><tr><td>Apple Intel x64 Installer</td><td>burpsuite_pro_macos_x64_v2025_11.dmg</td></tr><tr><td>Apple ARM64/M Chips Installer</td><td>burpsuite_pro_macos_arm64_v2025_11.dmg</td></tr><tr><td>Linux x64 Installer</td><td>burpsuite_pro_linux_v2025_11.tgz</td></tr><tr><td>Linux ARM64 Installer</td><td>burpsuite_pro_linux_arm64_v2025_11.tgz</td></tr><tr><td>Windows x64 Installer</td><td>burpsuite_pro_windows-x64_v2025_11.exe</td></tr><tr><td>Windows ARM64 Installer</td><td>burpsuite_pro_windows-arm64_v2025_11.exe</td></tr></tbody></table><hr/><p><strong>for macOS</strong>：<a href="https://link.segmentfault.com/?enc=LwwcTooTPLmFviuF%2F5tphg%3D%3D.PJ1knxApASkzFPjIL81pC2YVp1g1GQD7XvFKLYTwGI6xmYKLBqt07R8YrAdwO%2FoL" rel="nofollow" target="_blank">Burp Suite Professional 2025.11 for macOS x64 &amp; ARM64 - 领先的 Web 渗透测试软件</a></p><p><strong>for Windows</strong>：<a href="https://link.segmentfault.com/?enc=QYeFxEbfherPE8lSafZRJg%3D%3D.4Hy7qVcAdZvrW6mSdOJsu10V5qNULlVuD9mlprWNveuHwfEXOH23do6BycshVT4H" rel="nofollow" target="_blank">Burp Suite Professional 2025.11 for Windows x64 - 领先的 Web 渗透测试软件</a></p><p>更多：<a href="https://link.segmentfault.com/?enc=AOse7TIi0dHMT%2F3g8EGT%2Bw%3D%3D.QyTosj8akEYgqX%2Biuf5OPgNIlMOFYDxGOp4TOyN6CwQ%3D" rel="nofollow" target="_blank">HTTP 协议与安全</a></p>]]></description></item><item>    <title><![CDATA[从“指尖泄密”看数据安全短板 全知科技 ]]></title>    <link>https://segmentfault.com/a/1190000047399570</link>    <guid>https://segmentfault.com/a/1190000047399570</guid>    <pubDate>2025-11-14 14:02:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399572" alt="图片" title="图片"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399573" alt="图片" title="图片" loading="lazy"/><br/>近日，国家安全部发布的典型案例再次敲响了数据安全的警钟——某涉密单位办公室主任为了图省事，违规使用图文识别小程序将机密文件转化为电子文档，没想到该小程序的后台开发人员竟然将涉密内容打包倒卖，最终造成严重泄密。</p><p>随着企业信息化和数字化转型的加速，数据已成为核心生产要素和竞争力来源。然而，企业普遍存在员工数据权限管理粗放、用途授权不明、敏感数据缺乏分级控制等问题，导致内部违规访问、越权操作和数据外泄风险频发。尤其在人员流动频繁的情况下，离职权限回收滞后、共享账号混乱等现象更是安全隐患。</p><p>与此同时，云化架构的普及使数据访问链条更复杂，权限失控风险进一步放大。面对《网络安全法》《数据安全法》《个人信息保护法》等法规要求，建立最小化访问、动态授权、可追溯审计为核心的数据安全治理体系，实现对员工数据接口权限的精细化管控，已成为企业数字化发展的共识。</p><p>本案的发生，涉密单位员工违规使用此类应用，仅是导火索，而真正导致泄密的根源在于第三方平台后台失控与数据接口保护机制的缺失。该公司在运营中未建立完善的数据安全管理体系，后台权限过度集中，缺乏数据接口访问控制与操作审计机制，导致内部人员可直接接触并导出用户数据；同时，公司未落实数据加密、传输隔离等技术防护措施，对涉敏信息的存储与调用缺乏任何安全审查，形成了“高权限、低防护、零监管”的高危状态。这一事件也充分暴露出企业在数据安全建设和人员管控方面的严重短板，需要以更先进、更智能的数据安全防护产品加以弥补。</p><p>知影-API风险监测系统：从感知到防护的全闭环治理</p><p>知影-API风险监测系统基于流量分析与大数据识别技术，结合AI智能算法，能够自动发现企业环境中所有的API资产，精准刻画每个接口的功能、数据类型与敏感度，并建立动态更新的API画像库。通过持续监测API访问行为和数据交互过程，系统能对全网API进行“可视化、可度量、可追溯”的风险管理，形成从资产发现、风险检测、威胁处置到审计追踪的完整闭环。在企业内部复杂的应用环境中，无论是员工内部系统调用还是第三方应用接入，API风险监测系统都能实现跨业务、跨网络的统一管理，帮助安全团队实时掌握数据流动路径与访问风险，为决策层提供精细化的安全视角。</p><p>1、核心功能：基于智能算法的多维风险监测知影-API风险监测模块是系统的核心能力，融合了多维检测模型、动态基线分析和自适应防护策略三大技术体系，实现从“识别”到“处置”的全流程防护。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399574" alt="图片" title="图片" loading="lazy"/><br/>（1）多维风险识别：全面覆盖数据泄露、Web攻击与账号风险系统从数据泄露、Web攻击、账号安全三大维度构建风险分析模型，结合API类型特征自动应用不同的检测算法。例如，对登录接口采用撞库与暴破检测模型，对查询类接口聚焦数据返回量异常，对文件上传下载类接口监测数据外传行为。通过机器学习与行为分析算法，知影-API风险监测系统可实时识别扫描、枚举、越权、暴破、数据窃取等多种威胁行为，实现对复杂攻击链的精准检测。AI算法可不断优化识别策略，使监测能力随数据量与威胁类型的变化持续进化。<br/>（2）动态基线建模：还原正常行为、识别异常偏移知影-API风险监测系统通过长期采集API访问行为，建立多维度的行为基线模型，包括访问频率、参数特征、数据量分布、用户身份与IP地址模式等。当系统检测到与基线偏离的行为时，会自动触发风险判定与告警流程。更重要的是，系统支持自适应学习机制，可根据业务变化自动调整基线阈值，持续保持高准确度与低误报率。<br/>（3）智能风险响应：风险闭环管控与策略化处置一旦系统识别出异常或恶意行为，其内置的高性能风险引擎将立即执行自动化防护策略，包括：对触发风险的IP进行精准阻断或限流；针对异常账号或接口实施访问隔离；支持按API、应用、用户维度灵活配置防护规则；支持基于AI决策引擎的策略优选与自动化调整。通过集中管理平台实现跨节点联动处置。这种智能、高性能的风险处置机制，可有效减少安全团队的响应时延，实现“秒级发现、实时处置”的风险防护效果。</p><p>2、技术优势：轻量高效、智能联动的防护体系知影-API风险监测系统以轻量化架构和智能化引擎为核心，构建了一套集高性能分析、AI智能识别和多层联动防护于一体的安全体系，兼顾系统性能与防护深度，适用于多种复杂业务环境。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399575" alt="图片" title="图片" loading="lazy"/></p><p>知影-API风险监测系统采用自研的高性能大数据分析引擎，具备强大的并发处理与实时计算能力，可在云化、分布式及微服务架构中快速部署与平滑集成。无论是互联网侧的大规模API访问，还是企业内网中的多节点数据流动，系统均可实现毫秒级流量解析与风险判断，保证检测的即时性与精度。相较于传统安全网关或被动式审计产品，知影-API风险监测系统通过旁路流量采集 + 实时检测分析的组合模式，实现“零侵入式”防护，既不影响业务系统性能，也无需对现有架构进行改造，大幅降低了企业部署和运维成本。在联动防护方面，系统支持与各类安全设备深度对接，包括WAF、SOC、SIEM、数据库审计、防火墙、流量探针等，实现威胁信息共享与策略协同。当检测到风险事件时，系统可将分析结果自动推送至关联平台，触发自动化响应流程，从而构建“多维协同、联防联控”的安全矩阵。这种跨系统联动机制，不仅提升了防护的及时性与覆盖度，也让安全处置从“单点防御”升级为“全局协同”。此外，知影-API风险监测系统还能与全知科技的数据安全平台及第三方防护产品协同联动，借助智能策略匹配机制，在攻击检测、防御处置、风险反馈等环节形成闭环协作，显著提升整体防护效能。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399576" alt="图片" title="图片" loading="lazy"/></p><p>目前，全知科技的知影-API风险监测系统已获得中国信通院、工信部、Gartner、IDC等多家权威机构认可，并作为牵头单位主导制定国家标准——《数据安全技术 数据接口安全风险监测方法》。全知以自主可控的核心技术，以为政府、运营商、金融、教育、医疗、互联网等多家重点行业提供了全面可靠的数据安全产品与服务，并获得了客户高度的信赖与支持。未来，全知科技将继续坚持“技术驱动，安全赋能”的发展战略，持续深化AI算法在数据安全领域的应用，构建更智能化、高效化、合规化的数据安全建设体系，不断提升企业数字资产的防御韧性与响应能力，助力各行业迈向更加稳健可信的数字化未来。</p>]]></description></item><item>    <title><![CDATA[尺寸智能管理：提升制造业精度与效率的关键]]></title>    <link>https://segmentfault.com/a/1190000047399578</link>    <guid>https://segmentfault.com/a/1190000047399578</guid>    <pubDate>2025-11-14 14:02:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在现代制造业中，尺寸智能管理作为一种核心技术，正日益成为企业提升产品质量、优化生产流程和降低成本的重要手段。它指的是通过智能化技术，如物联网（IoT）、人工智能（AI）和大数据分析，对产品尺寸、公差和几何参数进行实时监控、预测和调整，以确保制造过程中的一致性和精确性。这一管理方式不仅适用于传统制造业，如汽车和航空航天，还扩展到电子、医疗设备等高精度行业，帮助企业应对日益复杂的市场要求和竞争压力。<br/>尺寸智能管理的核心在于其数据驱动的方法。通过传感器和测量设备收集实时数据，系统能够分析尺寸偏差、趋势和异常，从而提前预警潜在问题。例如，在汽车制造中，车身零件的尺寸精度直接影响到整车的装配质量和安全性。如果尺寸管理不当，可能导致间隙不均、噪音问题甚至召回事件。通过智能系统，企业可以实现自动化检测和调整，减少人为错误，提高生产效率。一个典型的例子是广域铭岛在智能制造领域的实践，该公司通过集成先进的尺寸管理平台，帮助客户实现从设计到生产的全流程优化，提升了产品一致性和客户满意度。某主机厂接入广域铭岛GQCM系统尺寸软件系统投资，减少50万元/套，物料损耗成本降低10万元/年，三坐标尺寸测量合格率提升4%。<br/>此外，尺寸智能管理在航空航天行业也展现出显著价值。飞机制造需要极高的公差精度以确保结构完整性和安全性。智能尺寸管理系统可以监控零部件从原材料到成品的整个生命周期，通过预测性维护避免昂贵的返工或延误。例如，利用人工智能算法，企业可以分析历史数据以预测尺寸漂移，并在问题升级前实施纠正措施。这不仅节省时间和资源，还增强了符合严格监管标准的能力。<br/>另一个行业例子来自电子制造业，其中微型组件的尺寸管理至关重要。智能手机或芯片的制造依赖于纳米级精度，智能系统通过机器视觉和实时反馈循环，确保每个组件符合规格。这降低了缺陷率并提高了良率，最终推动创新和市场竞争力。<br/>尽管尺寸智能管理带来了诸多好处，但其实施也面临挑战，如数据集成复杂性、高初始投资和技能差距。企业需要制定综合策略，包括员工培训、技术选型和合作伙伴选择，以最大化收益。未来，随着数字孪生（Digital Twin）和5G技术的普及，尺寸智能管理将更加智能化和自适应，为企业开辟新的增长路径。<br/>总之，尺寸智能管理是制造业数字化转型的重要组成部分，它通过智能化手段提升精度、效率和可靠性。企业应积极拥抱这一趋势，结合自身需求探索适合的解决方案，以在全球化竞争中保持领先地位。</p>]]></description></item><item>    <title><![CDATA[程序员 | 从一线回武汉的真实感受…… ]]></title>    <link>https://segmentfault.com/a/1190000047399585</link>    <guid>https://segmentfault.com/a/1190000047399585</guid>    <pubDate>2025-11-14 14:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>从北京回武汉差不多六年了，感慨颇多， 谈谈真实感受。</p><h3>1 IT 公司</h3><p>我们先把 IT 公司做一个分类整理 ：<br/><img width="723" height="360" referrerpolicy="no-referrer" src="/img/bVdm2WQ" alt="" title=""/></p><p>从表中来看，武汉的 IT 公司确实不算少 ，主要集中于光谷，但我需要强调一下：</p><p>1、在大厂的眼里，武汉的定位是第二研发中心，看中的是武汉海量的研发人力资源以及较低的薪资水平。</p><p>2、第二研发中心做的并非核心业务，而且第二研发中心的权限往往不够。所以第二研发中心往往也被称为外包中心，这也是武汉很多朋友都说武汉是外包之城的原因。</p><p>3、武汉的技术氛围很差，高水平的研发人员相对较少，无论是管理者还是研发人员和一线相比是有绝对差距的。</p><p>接下来，聊聊薪资。</p><p>武汉 IT 薪资和一线差距很大，我预估月薪应该是一线的 50% 到 60% 左右，年终奖一般都是 1 ~ 2 个月，少部分公司会有股票，社保/公积金相对较低。</p><p>假如你在互联网公司，达到了阿里 P7 左右，我建议暂时不回武汉，因为武汉的薪资、技术氛围真的可能让你失望，还不如在一线多攒钱，等资金充裕了，回武汉更加合适点（一线挣钱，武汉花，很美！）。</p><h3>大厂机会</h3><p>想选一个大厂作为跳板，作为自己镀金机会的，尤其是看【上海】【深圳】等<a href="https://link.segmentfault.com/?enc=L%2BZZJNYK9Yzdon1eRPT%2BXQ%3D%3D.tpgGxD0CHDds97uH2N0YGAsUQdH4gh8%2BBlLv9VP8i60%3D" rel="nofollow" target="_blank">→机会</a>的朋友，前端-测试-后端！待遇薪酬还不错，尽管来！</p><p><strong>2 大武汉</strong></p><p>我们经常会将武汉说成“大武汉”，官方数据显示，武汉的行政面积达 8569.15 平方公里，相当于0.52个北京、1.35个上海或 4.29 个深圳。</p><p>武汉被长江和众多湖泊自然分割，形成了"三镇鼎立"的独特格局——汉口、武昌、汉阳各自为政又浑然一体。</p><p><img width="723" height="350" referrerpolicy="no-referrer" src="/img/bVdm2Xz" alt="" title="" loading="lazy"/></p><p>为了连接这片水域纵横的土地，仅长江上就架起了十余座大桥，每一座都是城市发展的见证者。</p><p>回武汉的第一年，每天驱车从金银湖到关山大道，真有一种跋山涉水翻山越岭的感觉。</p><p>大江大湖造就了大武汉的壮阔景观，从金银湖的潋滟波光到南湖的静谧秀美，从堤角的市井烟火到欢乐谷的现代活力，处处都是令人惊叹的滨水景观。</p><p><strong>3 文化</strong></p><p>武汉的城市文化非常多元 ，有的时候，你甚至想不明白，为什么这么多迥异的文化元素集中于同一个城市。</p><p><strong>01 码头文化</strong></p><p>武汉因水而兴，自古就是“九省通衢”的商贸重镇。</p><p>汉口的码头文化塑造了武汉人直爽、讲义气的性格，“不服周”“讲胃口”的方言里，藏着码头工人的豪迈与坚韧。清晨的吉庆街、户部巷，热干面的芝麻香混合着面窝的酥脆，老武汉的一天就在这样的烟火气中开始。</p><p><strong>02 过早</strong></p><p>武汉人“过早”（吃早餐）的仪式感全国闻名，热干面、豆皮、糊汤粉、牛肉粉……一个月可以不重样 。</p><p><strong>03 科教中心</strong></p><p>武汉坐拥武汉大学、华中科技大学等近百所高校，是中国三大科教中心之一。</p><p>樱花纷飞的武大、梧桐成荫的华科、文艺范十足的昙华林，让这座城市既有历史的厚重感，又有青春的朝气。</p><p><strong>04 省博物馆</strong></p><p>湖北省博物馆是中国最重要的国家级博物馆之一，推荐各位同学来武汉时一定要去看一看。</p><p>1、越王勾践剑 : 锋芒依旧的王者之剑</p><p>2、曾侯乙编钟：奏响穿越时空的旋律</p><p>3、曾侯乙尊盘：青铜铸造的巅峰之作</p><p><strong>4 生活</strong></p><p>在武汉生活其实很方便，拿医疗资源来讲，我在北京望京看牙经常挂不到号，在武汉不可能发生这种情况，因为我家附近有两家三甲医院，平常看病就医都很方便。</p><p>武汉的景点非常多，周末我经常开车带老婆、孩子去东湖、九峰山动物园、植物园等景点游玩。</p><p>因为离父母近，也有了更多时间陪陪父母，他们年纪大了，总会感到孤独，我在他们身边，他们也会感觉好一点。</p><p>总而言之，相比在北京，我更加有归属感，而且幸福感更强。</p><p>有点遗憾的是，在武汉工作，一直感觉很别扭 ：</p><pre><code>讯飞的业务是 TOG 的项目，很多产品、项目质量堪忧，有的接近劣质的边缘，同时合肥管理人员所体现出的低素质，让我的价值观受到了极大的刺激。
武汉不应该仅仅作为人力资源之城，或者说是外包之城。

</code></pre><p>我曾经对老婆讲：“我有点后悔离开北京，在武汉，最高的 offer 可以拿到接近 53 w ，要是这六年还在北京，运气好的话，手里的现金可以多个 100 w 吧！”</p><p>老婆听了我的幻想，笑了笑，回道：“那可能依依都不可能出生呢”。</p><p>我想了想： “也是，现在其实挺幸福的”。</p><p>——转载自作者：勇哥Java实战</p>]]></description></item><item>    <title><![CDATA[Dexmal原力灵机融资近10亿元，阿里]]></title>    <link>https://segmentfault.com/a/1190000047399372</link>    <guid>https://segmentfault.com/a/1190000047399372</guid>    <pubDate>2025-11-14 13:05:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399374" alt="" title=""/></p><p>近日，具身智能公司Dexmal原力灵机宣布完成数亿元A+轮融资，阿里巴巴为独家投资方；此前，公司A轮融资由蔚来资本领投，洪泰基金、联想创投、锡创投和正景基金跟投，老股东君联资本超额追投、启明创投和九坤创投追投；两轮融资金额近10亿元，资金主要用于具身智能机器人软、硬件技术研发与落地。</p><p>自2025年3月成立，公司已开源一站式VLA工具箱Dexbotic、推出机器人硬件平台DOS-W1，并发布全球首个大规模真机评测平台RoboChallenge，从软件、硬件和标准方面积极推动具身智能机器人行业发展。此前，公司曾参加CVPR2025和ICRA2025机器人挑战赛，荣获多项全球冠军。</p>]]></description></item><item>    <title><![CDATA[北京论坛（2025）“人类健康与数字文明]]></title>    <link>https://segmentfault.com/a/1190000047399367</link>    <guid>https://segmentfault.com/a/1190000047399367</guid>    <pubDate>2025-11-14 13:05:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>2025/11/13 信息来源： 北京大学全球健康发展研究院</p><p>文字：蒋少翔、赵秋运、刘猛、吴宛睿、章湖洋、陈尔默、刘璐<em>|</em> 编辑：山石 <em>|</em> 责编：安宁</p><p>转自：北京大学 新闻网[](<a href="https://link.segmentfault.com/?enc=3CsqDPKmhk4%2FC2xYd5jM6w%3D%3D.7RGYM1KskB%2BS9Z%2FYEwh6mhDZiv5XwgEulf9mRCMPPfB9eWKBf%2FJwV0pNoDReb6GBn64FbGg2QG5RcsS1F0iGMAyu8lsJ7huCFiZuzVudbxU%3D" rel="nofollow" target="_blank">https://news.pku.edu.cn/xwzh/...</a>[](<a href="https://link.segmentfault.com/?enc=qc3cssv4S7wRoJYxEZq7EA%3D%3D.RWq7%2FA0JWKIkfE8QqPJctgoyaAHuImQsCX9RxehVdEG4IgUV7QSrApmGmPsZNJLsjCfj1er3rYgdJnVu7cZ6Abe2H0EYNYk%2FP95%2FILl2CCs%3D" rel="nofollow" target="_blank">https://news.pku.edu.cn/xwzh/...</a>[](<a href="https://link.segmentfault.com/?enc=p7AxrNICvZGRmybkaHCCPw%3D%3D.ssTwSoqcYksxj5s8jadrsFsIGXQqRtw3oUB236zqg4eGXO9Elfun%2Bq5cvv6%2ByQOT9sXsOCfPBvLmmyD5wpTkaknpYTkQds9tDES4yNZp56s%3D" rel="nofollow" target="_blank">https://news.pku.edu.cn/xwzh/...</a></p><p>11月9日，北京论坛（2025）“人类健康与数字文明”专题论坛在百周年纪念讲堂李莹厅举行。现场发布了北京大学由全球健康发展研究院牵头研发的“星球健康坐标系统”（Planetary Health Axis System，PHAS），该系统是全球首个星球健康人工智能大模型，是通过创新性搭建涵盖人类健康、物种健康、环境健康、社会健康四大主轴的坐标系，集成全球48,000多个关键变量构成的复杂系统。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399369" alt="" title=""/></p><p>论坛现场</p><p>中国科学技术协会名誉主席、中国科学院院士韩启德，北京大学党委书记何光彩、副校长董志勇，中国工程院院士、北京大学全球健康发展研究院理事会主席詹启敏，北京大学全球健康发展研究院院长、中国医学科学院学部委员刘国恩，中国科学院大气物理研究所原所长、国际气溶胶学会副主席曹军骥，北京大学全球健康发展研究院资深特聘研究教授、WHO办公厅原主任兼助理总干事施贺德（Bernhard Schwartländer），日内瓦国际与发展研究院全球健康中心创始人兼主席伊洛娜·基克布施（Ilona Kickbusch），经济学人智库（经济学人集团）中国区总监安珂·施拉德（Anke Schrader），亚洲基础设施投资银行社会发展与气候部门负责人薇拉·西耶约（Vera Siesjö），新加坡管理大学教授李嘉，名古屋大学教授薛进军，清华大学教授刘军、蒋靖坤、宋森、陆毅，中国医学科学院教授邱五七，北京中关村学院首席科学家刘海广，北京大学教授张维迎、雷晓燕、易君健等多位专家学者出席。开幕式由北京大学全球健康发展研究院副院长张海滨主持。</p><p>韩启德指出，PHAS工程为人类文明可持续发展提供了新的治理框架与智能支持，是一项具有世界影响的重大创新。希望PHAS继续加强国内外合作，不断充实完善并应用于实践，为全球健康事业作出更大贡献，彰显大国担当。</p><p>何光彩指出，习近平总书记强调，科技创新是人类共同应对风险挑战、促进和平和发展的重要力量。北京大学深入践行人类命运共同体理念，坚持高水平开放办学，在推动中外人文交流、科技合作与文明互鉴方面取得了积极成果。希望各方在PHAS基础上，探索运用数智化手段应对全球挑战，推动人与自然走向更高层次的和谐共生。</p><p>詹启敏高度肯定PHAS以系统科学视角整合数据与科技、打破学科壁垒的创新价值，认为PHAS是对健康认知的深刻革新，期待该系统能不断完善，成为支撑全球健康合作的公共平台，为人类与地球可持续发展指引清晰方向。</p><p>刘国恩汇报了PHAS进展，并指出这套“数字罗盘”旨在系统追踪并全景绘制人类发展足迹与星球边界的内在关联，为人类文明提供星球健康状态的导航。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399370" alt="" title="" loading="lazy"/></p><p>发布仪式</p><p>曹军骥、Ilona Kickbusch、刘海广围绕地球系统观测模拟与PHAS融合推进、健康与可持续性、人工智能赋能人类健康等话题进行主旨发言，论坛开展专家对话与点评。北京大学全球健康发展研究院副院长秦雪征在闭幕致辞中对本次论坛多学科、多角度的探讨进行了总结。</p><p><strong>延伸阅读：PHAS回顾</strong></p><p>2023年10月起，北大全球健康发展研究院携手来自中外数十家顶尖科研院所的科学家，启动了世界首个星球健康人工智能大模型——PHAS。2024年11月，北大全健院主办的“北京论坛2024：星球健康”全球专家圆桌会议在北京大学召开。2025年10月，PHAS在柏林“世界健康峰会2025”上首次全球发布。2025年11月北京论坛上的PHAS“北京发布”将成为这一全球科学公共品的新里程碑。</p><p>专题链接：<a href="https://link.segmentfault.com/?enc=RKTiy%2BfXCfv4RZ8lUXWzHA%3D%3D.uMKh%2F5hb%2BfyMHWur4QSNPGn%2FLoFmAyhQ8JjXxwW8pwUz7EjWhCFO0kPyXMd4Q1ZA" rel="nofollow" target="_blank">北京论坛2025</a></p><p><a href="https://link.segmentfault.com/?enc=GFvxU7d2ajrbKa3eePNRFw%3D%3D.oQ8pZwAmvp%2F4dpNcT8uwHFIFCAktVxUMLbmfClT6p6Jt0FxrKovncWuRJGTJOiC%2ByAg6JWs%2F9iPzJzEKKHnVMw%3D%3D" rel="nofollow" target="_blank"><img referrerpolicy="no-referrer" src="/img/remote/1460000047399371" alt=" title=" title=" title=" loading="lazy"/></a></p>]]></description></item><item>    <title><![CDATA[【技术分享】用python开发采集软件，]]></title>    <link>https://segmentfault.com/a/1190000047399334</link>    <guid>https://segmentfault.com/a/1190000047399334</guid>    <pubDate>2025-11-14 13:04:45</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、工具开发背景与效果</h2><p>在数据驱动决策的时代，社交媒体数据分析需求日益增长。作为一名资深开发者，我注意到研究人员常需要获取微博公开数据进行学术分析。为此，我开发了这款专业级数据采集工具：爬微博博主软件。旨在为学术研究提供技术支持。<br/>界面如下：<img width="723" height="589" referrerpolicy="no-referrer" src="/img/bVdm2Tx" alt="爬微博博主软件.png" title="爬微博博主软件.png"/><br/>使用过程演示视频：请见原文。</p><h2>二、工具核心特性</h2><h3>2.1 系统兼容性</h3><p>支持Windows和Mac双平台运行无需复杂环境配置，开箱即用</p><h3>2.2 数据采集机制</h3><p>采用API接口协议进行数据获取智能分页采集，确保数据完整性请求间隔优化，符合平台规范</p><h3>2.3 数据安全保障</h3><p>实时增量保存机制<br/>完善的日志记录<br/>系统数据本地化存储</p><h2>三、技术架构解析</h2><h3>3.1 前端界面</h3><p>基于tkinter框架开发GUI界面，提供直观的操作体验：<br/>简洁的输入区域<br/>实时的进度显示<br/>清晰的运行状态提示</p><p>部份实现源码：</p><pre><code class="python"># 创建主窗口
root = tk.Tk()
root.title('爬微博博主软件v1.0 | ')
# 设置窗口大小
root.minsize(width=850, height=660)</code></pre><h3>3.2 后端处理</h3><p>核心功能模块包括：<br/>请求模块：使用requests库发送HTTP请求<br/>解析模块：处理JSON格式响应数据</p><p>部分实现源码：</p><pre><code class="python"># 发送请求
r = requests.get(url, headers=h1, params=params)
# 接收响应数据
json_data = r.json()</code></pre><p>存储模块：<br/>通过pandas进行结构化存储</p><pre><code class="python"># 保存数据到DF
df = pd.DataFrame(
    {
        '博主昵称': name_list,
        '博主id': user_id,
        '页码': page,
        '微博id': id_list,
        '微博bid': bid_list,
        '微博链接': wb_url_list,
        '发布时间': create_time_list,
        '发布于': region_name_list,
        '转发数': reposts_count_list,
        '评论数': comments_count_list,
        '点赞数': like_count_list,
        '话题标签': topic_list,
        '微博内容': text_list,
    }
)
# 保存csv文件
df.to_csv(self.result_file, mode='a+', index=False, header=header, encoding='utf_8_sig')</code></pre><p>日志模块：<br/>详细记录运行全过程。<br/>部分源码：</p><pre><code class="python">def get_logger(self):
    self.logger = logging.getLogger(__name__)
    # 日志格式
    formatter = '[%(asctime)s-%(filename)s][%(funcName)s-%(lineno)d]--%(message)s'
    # 日志级别
    self.logger.setLevel(logging.DEBUG)
    # 控制台日志
    sh = logging.StreamHandler()
    log_formatter = logging.Formatter(formatter, datefmt='%Y-%m-%d %H:%M:%S')
    # info日志文件名
    info_file_name = time.strftime("%Y-%m-%d") + '.log'
    # 将其保存到特定目录
    case_dir = r'./logs/'
    info_handler = TimedRotatingFileHandler(filename=case_dir + info_file_name,
                                            when='MIDNIGHT',
                                            interval=1,
                                            backupCount=7,
                                            encoding='utf-8')
    self.logger.addHandler(sh)
    sh.setFormatter(log_formatter)
    self.logger.addHandler(info_handler)
    info_handler.setFormatter(log_formatter)
    return self.logger</code></pre><p>log文件：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399337" alt="图片" title="图片" loading="lazy"/></p><h2>四、数据规范说明</h2><h3>4.1 采集字段</h3><p>工具采集的微博数据包含以下维度：<br/>字段：博主昵称,博主id,页码,微博id,微博bid,微博链接,发布时间,发布于,转发数,评论数,点赞数,话题标签,微博内容</p><h3>4.2 数据格式</h3><p>输出为标准化CSV文件：UTF-8编码确保中文兼容规范的字段命名在数据驱动决策的时代，社交媒体数据分析需求日益增长。作为一名资深开发者，我注意到研究人员常需要获取微博公开数据进行学术分析。为此，我开发了这款专业级数据采集工具：，旨在为学术研究提供技术支持。</p><h2>五、使用规范与建议</h2><ol><li>合法使用：仅限学术研究用途</li><li>频率控制：建议设置合理采集间隔</li><li>数据管理：妥善保存采集结果</li><li>版权尊重：引用数据时注明来源</li></ol><h2>六、作者声明</h2><p>本工具为原创开发，如需了解更多技术细节或进行专业交流，可通过正规渠道联系开发者（首发公众号：老男孩的平凡之路）。工具使用需严格遵守相关法律法规和平台规定。</p>]]></description></item><item>    <title><![CDATA[六问「大模型落地」— 如何打通企业智能化]]></title>    <link>https://segmentfault.com/a/1190000047399341</link>    <guid>https://segmentfault.com/a/1190000047399341</guid>    <pubDate>2025-11-14 13:03:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047183062" alt="图片" title="图片"/><br/>作者：张红兵枫清科技（Fabarta）合作人ChatGPT 2022年底出现以来，大模型热度持续不减，尤其是今年年初DeepSeek的爆火，更让大模型走入更多人的视野。大模型除了在C端（个人用户）广泛应用，在B端（企业）也有越来越多的企业在做落地。2025年8月26号， 国务院发布《关于深入实施“人工智能+”行动的意见》，更将以大模型为主的人工智能技术放到更加突出的位置。“人工智能+” 行动堪比十年前国家推出的互联网+ 政策。人工智能+行业将重塑各行各业，助力数智化转型和产业重构。在此大背景下，以大模型为主的人工智能应用和落地已成为各大企业的必答题，而非选做题。</p><p>通过笔者与上百家企业客户的交流进而观察到：中国企业客户IT基础差异大、数据储备和质量不同、智能化进展参差不齐、AI落地驱动力差异大，可谓是一企业一世界。我们可将AI在企业落地按四个阶段进行划分：</p><p>第一阶段：企业关注大模型，但还未进行落地。有用户觉得大模型是万能的，什么都能做；有用户觉得大模型在企业中无法真正应用，纯娱乐用途。在此阶段，需要跟客户对齐理解，了解大模型能力边界，为AI在企业应用打好认知基础。</p><p>第二阶段：企业已认可大模型价值，也在探索阶段。在此阶段，不少客户也会自己拿开源软件进行各种尝试。这类客户经常会发现大模型实际落地效果不好。此时需要跟客户对齐正确的大模型落地路线，并通过场景验证技术路线的效果。</p><p>第三阶段：通过探索，认可技术路线，并且开始落地。在落地时，有两种思路，一种是直接落地场景，另一种是构建平台，基于平台落地场景。如果场景相对较少，可以直接从场景出发进行落地。但如果场景多，或有统一规划，需要统一技术路线和技术栈，降低后续运维复杂度，此情况下建议基于统一的平台构建各类场景，这与大模型出现之前的AI平台落地类似。</p><p>第四个阶段：在前三个阶段都完成的基础之上，开始深入将AI赋能各项业务，助力企业的智能决策。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399343" alt="图片" title="图片" loading="lazy"/><br/>图1：大模型落地的不同阶段</p><p>通常企业落地过程中会经历规划准备、实施落地、持续运营三个关键里程碑，在这期间有哪些要点是客户关心的？本文将其归类，简称为六问大模型落地。</p><h2>01规划准备</h2><h3>【定方向】第一问：大模型落地都包含哪些部分，只用大模型是否足够？</h3><p>不少客户会认为，有大模型，就可以直接进行场景落地，在企业直接应用。</p><p>大模型是基于世界通识数据训练而来，作为企业级应用存在明显局限。一方面，很多企业私有化知识并没有被内化到大模型中；另一方面，大模型由于其按照概率进行“单字接龙”预测输出的技术特点，导致其必然存在幻觉，所以并不适合将大模型直接用于企业的应用。仅当在回答通用知识时，原生大模型输出结果方可作为结果参考，而专业化应用必须结合领域内知识及上下文工程进行适配和效果提升。</p><p>那大模型落地都包含哪些主要部分？下图是我们根据实践给出的企业落地参考架构。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399344" alt="图片" title="图片" loading="lazy"/><br/>图2：大模型落地整体参考架构</p><p>首先大模型落地所需要的算力基础设施层通常使用主流的Nvidia GPU 与国产NPU（比如华为昇腾系列等）。 在硬件之上，可以统称为模型服务层，包括可运行各类大模型和专业领域模型，支持大模型训练、管理和推理服务，对模型进行全生命周期管理，同时覆盖用于模型训练或蒸馏的行业高质量数据集构建。</p><p>在模型之上，要结合企业数据进行大模型落地，我们将其称之为应用支撑中心。枫清科技的企业知识中台正是提供链接大模型和应用场景的中间层，包含知识引擎（将数据转换为知识，并且提供知识应用和运营），提供图+向量融合的多模态引擎助力知识的记忆和推理，以及智能体平台可以将知识和业务流程串联用于支撑场景应用，助力大模型对于业务价值的提升。</p><h3>【选路径】第二问：是否用开源软件做落地就可以?</h3><p>这是很多用户常问的问题，“我已经用开源软件进行了一些验证，并且已经运行了一些demo结果, 我是否可以直接使用开源工具进行实际场景落地？”</p><p>这个问题的答案依不同企业的自身诉求而异。如果客户的实际情况是做一些非常简单的验证，或者对业务垂域效果要求、数据的安全管控要求相对宽松，那用开源软件其实可以满足诉求，比如非常简单的文档问答或者工作流，使用RAGFlow或者Dify开源框架都是常见的做法。但在企业级应用中，开源软件存在如下问题：</p><p>1.如何进行复杂的企业级权限管控？<br/>2.如何进行系统的可扩展设计？<br/>3.如何与企业已有系统进行对接？<br/>4.如何根据企业需求进行定制化？<br/>5.如何兼容更多平台的不同能力？</p><p>这些问题会在自建企业级知识中台的过程中遇到，需要考虑支持从复杂的权限控制到安全体系设计、从系统可开放性设计到系统对接，从原型验证到持续运营，需要以企业级产品支撑场景落地。</p><p>以集团级规章制度问答为例，规章制度查询需要进行严格的管控公司内及跨公司权限控制，对本职能部门与上下级及其他职能部门的交互权限进行精准界定，构建清晰的权限边界。该管控模式通过限制非授权交互，从源头防范越权操作风险，保障规章制度问答在合规范围内进行。当前开源软件无法满足此类复杂的权限管控需求，而这些需求又是大型企业落地时的常见需求。枫清科技的知识中台可以实现文档、知识库、应用等不同类型的资源在用户、组织等层级的进行精细粒度权限管控，并且可以实现不同层级的权限分享，以满足企业复杂的权限管控要求。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399345" alt="图片" title="图片" loading="lazy"/><br/>图3：企业级权限需求实例 -- 开源软件无法处理此类需求</p><h2>02实施落地</h2><h3>【找场景】第三问：场景挖掘这件事重要吗，如何找高价值场景？</h3><p>传统软件开发一般需求相对可明确定义，而AI，尤其是大模型企业落地是新生事物，其落地效果与具体业务场景和数据情况密切相关，包括大模型在内的AI技术都有其能力边界。因此选取高价值场景成为大模型和AI落地的重要环节。枫清科技在实际落地过程中，沉淀了一系列的方法论来发掘高价值场景，包括明确用户、梳理流程、了解数据情况，从已有流程中寻找痛点，挖掘出AI能够赋能的场景，最终从技术可行性和业务价值度两个维度进行评估，来确定实际落地应用，进而助力流程的智能化实现。</p><p>通常场景挖掘挖掘过程中，需要业务人员深度参与，人工智能技术一定是为业务服务的，应当先与业务人员进行访谈作为输入，探索用户旅程，获取实际工作中的痛点，再看如何用AI进行赋能。</p><p>梳理体系会随着不同行业、不同业务诉求而变化。比如在已有客户落地过程中，我们与业务人员共创，对研产供销服完整的业务链，与通用的管理协同整体场景进行梳理，结合企业现状确定优先级列表，作为落地场景候选，进而供客户基于场景进行选择，共同进行落地。枫清科技也构建了包括AI4S、智能经营分析等多个垂类场景方案，可以在这些业务领域为客户赋能。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399346" alt="图片" title="图片" loading="lazy"/><br/>图4：场景挖掘是大模型落地的重要步骤</p><h3>【理流程】第四问：大模型落地流程是怎样的？</h3><p>场景选定后，我们来看实际落地的技术方案是怎样的，根据落地实践，推荐流程如下图所示。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399347" alt="图片" title="图片" loading="lazy"/><br/>图5：大模型落地流程</p><p>整个流程本质上是从数据到知识再到智能应用的转化过程。输入是企业内部的多模态源数据，包括企业内部存储在关系型数据库、指标系统里的各类结构化数据、文档/图片/音频/视频等各类非结构化数据，以及外部的各类舆情/新闻报道/论文/专利等各类数据。而输出则是赋能企业业务的场景应用。中间是核心处理流程，通过知识引擎对源数据的预处理、数据解析向量化、实体及关系抽取等技术将各种多模态数据转换为知识，再存储到图和向量融合的多模态引擎中作为构建应用的知识储备，包括以实现文档问答、智能问数、图谱应用等基础知识应用。最终再结合具体业务流程，通过智能体平台串联，结合知识应用，进而实现对于各个场景的支持。在整个落地流程中，结合客户的多模态数据，基于知识引擎和智能体平台进行落地，我们称之为以数据为中心的大模型落地范式。</p><h3>【看微调】第五问：需不需要微调大模型？</h3><p>很多客户会关心，在上面的架构中都要调用大模型能力，那是否需要微调或者蒸馏大模型？</p><p>根据我们的经验，大模型微调并非普适性选择，而是有明确的适用边界。如果企业在特定垂直领域不存在明确的专业诉求，并且自身尚未具备高质量、成体系的领域数据积累，盲目微调往往事倍功半。如果有垂直场景需求，数据为特定领域数据（通用大模型未将此领域知识内化为模型能力），在具有高质量数据集的同时也有领域大模型构建诉求，则可以尝试领域垂类大模型。为清晰展示不同技术路线的差异与选型逻辑，我们通过下图进行对比分析来描述各种技术路线的区别。从我们的实践来讲，以数据为中心的思路进行大模型落地，可以结合具体场景进行大模型微调，无需为了微调而微调，微调的基础需要懂数据、有高质量数据。与此同时，微调是一项资源密集型的投入，它通常涉及高昂的计算成本和专业的技术实施，性价比也是重要决策依据。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399348" alt="图片" title="图片" loading="lazy"/><br/>图6：RAG与模型微调、模型蒸馏的比较03运营迭代</p><h3>【促优化】第六问：大模型项目是不是可以像传统软件项目一样，先设定一个最终目标，仅依赖技术人员一次性调优就可交付？</h3><p>从“找场景”到“理流程”便可看到，大模型落地从来不是一个仅依赖技术部门实现的项目，它需要业务部门和技术部门的共同参与，各司其职：</p><p>业务部门负责明确业务目标，对输入进行明确整理，在项目实施过程中进行深度参与，例如，及时提供问题与答案列表、测试用例、在测试过程中反馈实现与业务诉求不相符的内容，辅助大模型落地效果评估与持续迭代。</p><p>数据部门是以数据为中心的落地应用效果的第一道防线，在枫清的指标问数实施过程中，数据质量、数据加工逻辑会严重影响AI问数应用的准确性，在优化的过程中排查到大量数据不一致的问题对实现效果构成阻碍。</p><p>技术部门则作为技术落地的执行人员，解决AI应用实施的技术问题，并提供应用使用的培训以及持续运营的技术支持，包括但不限于对用户遇到的问题提供支持，甚至包括文件上传、权限管理等操作问题。</p><p>综合来看，在实际落地时，有三个重要影响因素：</p><p>1.业务价值是目标，所有的落地都是为业务服务的；在高价值场景挖掘中，就要挖掘和发现高价值的场景，进而让大模型在高价值场景下发挥作用，具备高的业务价值；</p><p>2.数据是基础，企业只有在数据质量满足要求的情况下，才能有好的落地效果。比如在指标问答落地项目中，客户的指标体系以及指标内容就是好的落地效果的基础，在实际落地过程中，可以反推数据质量，进而促进指标体系的标准化，从而保证落地效果。对于文档落地也是类似情况，需要保证文档的正确性。</p><p>3.技术是保障，需要了解大模型的技术边界，也了解人工智能技术中其他技术点的技术边界。在实际项目落地中，很难都用大模型来解决，有可能需要视觉模型、数据分析模型、多模态大模型等来解决，在这其中，需要了解清楚各个模型的边界和上限，进而保证落地效果。</p><p>另外，从落地场景来说，会先从外围逐步过渡到核心业务。会遵从敏捷迭代，先小步快跑快速验证，再逐步推广；需要从最开始就引入业务人员，确保共同定义目标，且及时同步进展，确保交付内容是业务想要的结果。</p><p>在场景落地后，也需要通过持续优化的方式来进行迭代和完善，不同部门协作，通过收集人工反馈，针对反馈进行场景调优、新增功能、功能解耦升级以及模型定制微调方式实现闭环反馈；同时随着经验的积累和能力提升，进而转向智能自适应反馈机制，在运营中持续提升效果。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399349" alt="图片" title="图片" loading="lazy"/><br/>图7：大模型持续迭代优化流程</p><p>以上是结合我们的实践经验，针对大模型落地过程中用户常见6类问题给出的回答。在后续系列中，我们将针对各个部分展开详细介绍，涵盖从场景挖掘、平台建设到各个场景落地提供最佳实践分享，敬请期待。</p><p>如对我们的产品或技术感兴趣，欢迎通过 <a href="mailto:business@fabarta.com" target="_blank">business@fabarta.com</a>与我们联系。</p>]]></description></item><item>    <title><![CDATA[14载磨砺！思迈特实力再加冕，斩获金融B]]></title>    <link>https://segmentfault.com/a/1190000047399384</link>    <guid>https://segmentfault.com/a/1190000047399384</guid>    <pubDate>2025-11-14 13:02:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>2025年，数字经济的浪潮奔涌向前，AI与实体经济深度融合，正推动商业智能（BI）从“工具赋能”跨越到“生产力革命”的新阶段。在这一关键的技术与市场变革交汇点，<strong>国产 BI 领军者——思迈特软件（Smartbi）迎来了成立的第14周年</strong>。</p><p>在当前这轮 AI 革命中，思迈特展现出极强的前瞻性与执行力，重磅推出的 <strong>Smartbi AIChat</strong> 产品，<strong>率先实现了 “Agent + BI” 的创新性融合与落地应用</strong>，不仅获得了市场与客户的充分认可，已落地百余个项目，也实现<strong>了品牌实力与市场竞争力的里程碑式突破</strong>。</p><p>近日，思迈特再添新誉，霸榜<strong>金融BI市场“双料第一”</strong>，入选IDC<strong>数智化50+供应商推荐</strong>，持续稳居<strong>中国软件150强榜单</strong>，这不仅是对过去14年深耕的最好肯定，更标志着其在 “AI+BI” 探索道路上的绝对领先地位！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399386" alt="图片" title="图片"/></p><h2>01双料第一，领跑金融BI市场</h2><p>在商业智能赛道的金融领域，思迈特以“全行业领跑 + 细分领域夺冠” 的双重权威认证，构建起稳固的市场竞争壁垒。</p><p>作为全球 IT 市场研究的权威机构，IDC 的报告常被视为行业竞争力的 “黄金标尺”。其最新发布的《中国金融行业 BI 软件市场份额，2024》报告显示，思迈特在<strong>中国金融行业 BI 软件市场占有率第一</strong>。这份成绩的背后，是源自其深耕金融领域的深厚基因与长期积淀。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399387" alt="图片" title="图片" loading="lazy"/></p><p>自创立之初，思迈特便与金融行业深度绑定。十余年来，公司始终以金融领域为核心赛道，在数千个大型金融项目的实战中锤炼产品能力，精准把握金融行业对性能、稳定性、安全性的严苛要求。这种 “金融起家” 的基因，让其对行业业务逻辑与需求痛点形成了独到的洞察力。</p><p>而工信部赛迪研究院旗下赛迪顾问的细分赛道认证，也从垂直领域视角印证了思迈特的专业化实力。其最新发布的《2024-2025 中国证券行业 IT 解决方案市场分析与预测报告》指出，思迈特位居<strong>国内证券业 BI 厂商市场占有率第一</strong>。同时思迈特已连续多年稳居<strong>银行业商业智能软件产品市场占有率榜首</strong>，彰显了其在金融 BI 市场的绝对领先优势。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399388" alt="图片" title="图片" loading="lazy"/></p><h2>02权威上榜，综合实力认可</h2><p>如果说市占率是市场对思迈特的直接认可，那么两大权威榜单的入选，则进一步印证其在全行业数智化服务的综合实力。基于金融领域的扎实底蕴，思迈特将其长期沉淀的<strong>高标准、高要求</strong>服务经验辐射并赋能至更广阔的行业生态，实现全行业数智化服务的持续进阶，成功入选 <strong>IDC 2025《中国数智化 50 + 供应商推荐》</strong>，同时<strong>连续两年上榜 “中国软件 150 强”</strong>;榜单，综合服务实力备受各行各业认可。</p><p>其中，IDC 数智化 50 + 榜单依托十年 “未来企业大奖” 获奖数据，以“技术与平台化能力、行业知识（Know-How）、生态构建与服务能力”三大核心维度严苛评选，最终仅遴选出52 家经市场长期验证的卓越供应商，思迈特入选标志其跻身<strong>国内数智化服务第一阵营</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399389" alt="图片" title="图片" loading="lazy"/></p><p>在软件行业高速发展、竞争白热化的当下，思迈特软件连续多年上榜“<strong>中国软件 150 强</strong>”，这一成绩不仅体现了其在 BI 领域的核心竞争力，更标志着其优势已延伸至整体软件产业层面，从全维度为合作伙伴提供 “BI 技术过硬、服务能力可靠” 的信心支撑。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399390" alt="图片" title="图片" loading="lazy"/></p><h2>03跨越里程碑，迎接新变革</h2><p>从国家级专精特新 “小巨人” 的资质加冕，到 IDC、赛迪顾问的双料市占率冠军，再到数智化 50 + 供应商、中国软件 150 强，这一系列权威认可共同铸造了思迈特发展道路上的重要里程碑。</p><p>14年来，思迈特坚持以<strong>“技术创新 + 行业深耕” 的发展路径，构建起国产 BI 领域的核心竞争力</strong>。未来，依托 Smartbi AIChat V4 的技术突破与全行业服务经验，思迈特将持续为企业数智化转型提供精准赋能，以国产BI领军者的责任与担当，为中国软件产业高质量发展提供坚实支撑。</p><p><strong>14年初心不改</strong>。</p><p>感谢每一位客户的信任，感谢每一位伙伴的支持！</p><p>Smartbi 将继续秉持“让数据创造价值”的使命，与您携手，迎接AI+BI新变革，共绘数智化新蓝图！</p>]]></description></item><item>    <title><![CDATA[亲测！业务人员2小时用低代码搭建了一套个]]></title>    <link>https://segmentfault.com/a/1190000047399397</link>    <guid>https://segmentfault.com/a/1190000047399397</guid>    <pubDate>2025-11-14 13:02:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>目前市面上的CRM软件种类有很多，功能各异。但是在实际应用中，还是有很多棘手的问题：<br/>• 系统太复杂，员工用不明白<br/>• 定制开发成本高，修改一次要等半年<br/>• 数据孤岛严重，客户信息碎片化<br/>这是90%企业在使用传统CRM时面临的痛点。高昂的采购成本、漫长的实施周期、僵化的功能模块，让CRM从效率工具变成了负担。<br/>现在有一种灵活的解决方案，就是通过低代码开发系统去搭建。无需编程基础、无需等待排期，3天即可搭建一套贴合业务的CRM系统。<br/>说一个真实案例，这个是我们市场团队在去年自己搭建的一套非常好用的CRM系统，全程没有编写一行代码，IT部门零参与。<br/>CRM系统的搭建采用的JVS低代码开发平台。</p><h2>核心功能覆盖</h2><p>我们把CRM系统分为了2个环节，分别是客户管理（售前）、合同管理（售后）。每个环节里面又细分了多个具体的需求模块。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399399" alt="图片" title="图片"/><br/><strong>1、客户管理</strong><br/>每个客户需要管理的周期是比较长的，从客户进入到销售同学的“池子”，再到最终成交订单，每个环节都做了跟进的步骤。<br/>客户管理里面覆盖了客户的预约、销售和客户是什么时候对接上的，销售过程中和客户之间的沟通情况，销售跟进到哪一个环节等，让领导和销售人员都能清楚了解每个客户所处的阶段。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399400" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399401" alt="图片" title="图片" loading="lazy"/><br/>销售跟进阶段，能随时记录跟进的情况，也可以通过搜索按钮，快速查找客户信息<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399402" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399403" alt="图片" title="图片" loading="lazy"/><br/><strong>2、合同管理</strong><br/>这个模块覆盖了合同和收款方面的管理，主要是针对客户的合同存档和内部的资金流程管理，销售和财务人员都能实时了解回款进度，也确保合同信息的完整性和可追溯性。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399404" alt="图片" title="图片" loading="lazy"/></p><h2>【配置扩展】可以手动扩展：</h2><p>列表设计<br/>在JVS低代码中，数据模型和列表页是紧密关联的，列表页是对数据模型的数据展示，数据模型是列表与表单操作后的数据存储的空间。<br/>列表页设计页面的核心功能一共分为7个模块，分别是：数据模型、列表字段的增加、字段样式设置、扩展设置、甘特图、按钮配置、排序过滤、复杂表头设置。<br/>• 数据模型：明确数据的存储结构和类型。<br/>• 列表字段的增加：根据业务需求添加所需字段。<br/>• 字段样式设置：自由选择字段的颜色、宽度、样式等，还可配置公式、动态字段。<br/>• 扩展设置：满足更多个性化的设置需求。<br/>• 甘特图：以直观的图形方式展示项目进度等信息。<br/>• 按钮配置：提供新增、删除、修改、详情、导入、导出、模板下载等基础按钮，并支持自定义按钮，用户可自行扩展更多功能按钮。<br/>• 排序过滤、复杂表头设置：方便用户对数据进行排序、过滤，以及设置复杂的表头结构。<br/>进入列表设计页，配置好需要的字段<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399405" alt="图片" title="图片" loading="lazy"/><br/>配置按钮，新增、删除、修改、详情、导入、导出、模板下载这几个按钮，可以自定义按钮，支持自行扩展<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399406" alt="图片" title="图片" loading="lazy"/><br/>在列表页内，还可以触发业务逻辑和表单，直接进入到相应的配置页面<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399407" alt="图片" title="图片" loading="lazy"/><br/>表单设计<br/>表单配置流程：拖拽组件进入画布&gt;&gt;绑定数据&gt;&gt;设置属性控制&gt;&gt;设置样式控制&gt;&gt;按钮设置&gt;&gt;预览效果<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399408" alt="图片" title="图片" loading="lazy"/><br/>表单在组件操作后可以配置触发自定义逻辑事件<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399409" alt="图片" title="图片" loading="lazy"/><br/>逻辑设计<br/>在逻辑设计中，可以将用户操作、数据变化等事件转化为可执行的自动化动作。在表单提交或数据更新时还可以自动计算字段值。同时，还可以实现跨系统的数据同步。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399410" alt="图片" title="图片" loading="lazy"/><br/>流程设计<br/>通过流程引擎去执行规则，流程节点可以校验数据完整性、权限合规性，避免人为违规操作。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399411" alt="图片" title="图片" loading="lazy"/><br/>报表设计<br/>支持多种报表类型、可自定义报表样式、能实现数据钻取等<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399412" alt="图片" title="图片" loading="lazy"/><br/>在线demo：<a href="https://link.segmentfault.com/?enc=%2BSAH4ZF7hspMUAtGFrwT%2FA%3D%3D.VIfUzxlUrc1sRCFG1WvA6qc2wMbpGXgecPAHhys2Tf0%3D" rel="nofollow" target="_blank">https://app.bctools.cn</a><br/>基础框架开源地址：<a href="https://link.segmentfault.com/?enc=fxYws0xaQRyX7MNUHv1lPw%3D%3D.O2HhSe2ve8E2L6OJdEQRVWeW2f70knDU%2Fwic01naM1aazzKlEmUqsKvMmZoCuJ4S" rel="nofollow" target="_blank">https://gitee.com/software-minister/jvs</a></p>]]></description></item><item>    <title><![CDATA[必看！2025年精选10款CRM，解锁高]]></title>    <link>https://segmentfault.com/a/1190000047399429</link>    <guid>https://segmentfault.com/a/1190000047399429</guid>    <pubDate>2025-11-14 13:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>必看！2025年精选10款CRM，解锁高效客户管理新秘诀！</h2><h3>一、CRM是什么？为什么企业都在抢着用？</h3><h4>1. CRM的核心定义</h4><p>客户关系管理（<strong>Customer Relationship Management, CRM</strong>）是一种<strong>以客户为中心</strong>的商业策略，通过整合<strong>销售、营销、服务、供应链</strong>等全业务流程，利用AI、大数据等技术收集、分析客户数据，优化客户互动体验，最终实现“客户留存→价值挖掘→企业增长”的闭环。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399431" alt="" title=""/></p><h4>2. 2025年CRM的核心价值</h4><p>在数字化转型的关键期，CRM早已不是“可选工具”，而是企业的<strong>增长引擎</strong>：</p><ul><li><strong>效率跃迁</strong>：自动化线索分配、跟进提醒、报表生成等重复性任务，让销售/客服聚焦高价值工作；</li><li><strong>数据驱动</strong>：整合多渠道客户数据（微信、工商、订单、售后），形成<strong>360°客户视图</strong>，告别“信息孤岛”；</li><li><strong>客户留存</strong>：通过生命周期管理（如超兔的“需求培养→目标客户→成功签单”客池分类），降低客户流失率；</li><li><strong>全链路协同</strong>：打破销售、营销、财务、仓库的部门壁垒，实现“线索→订单→生产→售后”的数据打通；</li><li><strong>AI赋能</strong>：通过AI智能体（如超兔的Coze工作流）提供实时销售建议、自动生成工作流，让决策更精准。</li></ul><h3>二、2025年精选10款CRM：覆盖全场景，总有一款适合你！</h3><p>结合<strong>2025年CRM趋势</strong>（AI深度集成、一体化、低代码、多端覆盖），我们筛选了10款兼具“实用性”与“创新性”的CRM，重点突出<strong>行业适配性</strong>与<strong>差异化优势</strong>：</p><table><thead><tr><th>序号</th><th>CRM名称</th><th>核心亮点</th><th>适合场景</th></tr></thead><tbody><tr><td>1</td><td><strong>Salesforce</strong></td><td>行业标杆，Einstein GPT AI能力，企业级一体化平台</td><td>大型企业、全球化团队</td></tr><tr><td>2</td><td><strong>HubSpot</strong></td><td>免费版入门友好，Inbound Marketing 强，营销自动化工具丰富</td><td>中小微企业、营销驱动型团队</td></tr><tr><td>3</td><td><strong>超兔CRM</strong></td><td>21年行业经验，<strong>一体云架构</strong>（CRM+进销存+财务+生产），低成本客制化，AI智能体</td><td>工业/工贸类企业、需要全业务打通的中小企业</td></tr><tr><td>4</td><td><strong>Zoho CRM</strong></td><td>低代码自定义，多语言支持，全球化生态完善</td><td>跨境电商、多地区团队</td></tr><tr><td>5</td><td><strong>Microsoft Dynamics 365</strong></td><td>与Office 365深度集成，ERP/CRM一体化</td><td>微软生态企业、大型制造业</td></tr><tr><td>6</td><td><strong>Pipedrive</strong></td><td>可视化销售管道，聚焦销售流程管理</td><td>销售驱动型中小企业、B2B行业</td></tr><tr><td>7</td><td><strong>Freshsales</strong></td><td>AI线索评分，电话销售功能强，客户画像精准</td><td>B2B/B2C企业、高客单价行业</td></tr><tr><td>8</td><td><strong>Nimble</strong></td><td>社交CRM，整合社交媒体数据（微信、抖音），客户互动性强</td><td>电商、媒体、高互动行业</td></tr><tr><td>9</td><td><strong>Insightly</strong></td><td>项目管理+CRM，适合复杂项目型销售</td><td>咨询、IT服务、工程类企业</td></tr><tr><td>10</td><td><strong>Zendesk Sell</strong></td><td>与Zendesk Support集成，客户服务闭环，售后跟踪能力强</td><td>服务导向企业、 SaaS公司</td></tr></tbody></table><h3>三、CRM的“核心功能地图”：你需要的都在这里！</h3><p>2025年的CRM早已不是“客户信息台账”，而是<strong>全业务操作系统</strong>，核心功能覆盖以下模块：</p><h4>1. 客户数据管理</h4><ul><li><strong>360°视图</strong>：整合客户基本信息、订单历史、售后记录、跟进轨迹（如超兔的“客户背景自动调查”，补全工商/天眼查信息）；</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399432" alt="" title="" loading="lazy"/></p><ul><li><strong>查重机制</strong>：客户名/手机号/企业简称模糊查重，避免重复录入；</li><li><strong>权限分级</strong>：财务岗位可看客户财务数据，但不可看客户跟进详情（超兔的“全局自动权限”）。</li></ul><h4>2. 销售流程自动化</h4><ul><li><strong>线索管理</strong>：线索一键分配、归属地自动识别、市场活动成本分摊（超兔的“线索处理引擎”）；</li><li><strong>跟单智能</strong>：AI生成跟单工作流（超兔的“自然语言工作流”）、销售管道可视化（Pipedrive）；</li><li><strong>订单财务管控</strong>：应收自动触发（签约/发货/开票）、账期/信用度管理（超兔的“应收三角联动”）。</li></ul><h4>3. 营销自动化</h4><ul><li><strong>多渠道获客</strong>：支持百度/抖音/微信/小程序线索抓取（超兔的“集客渠道整合”）；</li><li><strong>个性化营销</strong>：根据客户画像推送精准内容（如超兔的“AI营销物料推荐”）；</li><li><strong>ROI分析</strong>：计算市场活动的获客成本与签约转化率（超兔的“营销效果统计”）。</li></ul><h4>4. 客户服务与复购</h4><ul><li><strong>工单管理</strong>：售后投诉自动分配、进度实时查询（超兔的“OpenCRM上下游协同”）；</li><li><strong>RFM分析</strong>：识别高价值客户（现金牛）、预警流失客户（超兔的“复购挖掘”）；</li><li><strong>维修/外勤工单</strong>：手机端报工、扫码追溯（超兔的“MES-App”）。</li></ul><h4>5. 数据分析与AI</h4><ul><li><strong>自定义报表</strong>：支持多表聚合、同比环比分析（超兔的“数据统计引擎”）；</li><li><strong>AI预测</strong>：销售预测、客户流失预警（Salesforce Einstein）；</li><li><strong>智能体</strong>：嵌入客户视图的销售建议（超兔的“AI智能体”）、自动生成日报（超兔的“点点速记”）。</li></ul><h3>四、2张图表帮你快速选对CRM！</h3><h4>图表1：2025年CRM核心功能覆盖对比表</h4><table><thead><tr><th>CRM名称</th><th>客户360°视图</th><th>销售自动化</th><th>营销自动化</th><th>客户服务</th><th>AI能力</th><th>低代码自定义</th><th>多端覆盖</th><th>集成能力</th></tr></thead><tbody><tr><td>超兔CRM</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Salesforce</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>HubSpot</td><td>✅</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>Zoho CRM</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td>Pipedrive</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr></tbody></table><h4>图表2：不同规模企业CRM选型推荐矩阵</h4><table><thead><tr><th>企业规模</th><th>核心需求</th><th>推荐CRM</th></tr></thead><tbody><tr><td><strong>小微企业</strong></td><td>低成本、易上手、基础功能全</td><td>超兔CRM（一体云）、HubSpot Free、Pipedrive</td></tr><tr><td><strong>中型企业</strong></td><td>一体化、可扩展、客制化</td><td>超兔CRM（低成本客制化）、Zoho CRM、Freshsales</td></tr><tr><td><strong>大型企业</strong></td><td>企业级、集成、AI</td><td>Salesforce、Microsoft Dynamics 365、Zendesk Sell</td></tr></tbody></table><h3>五、CRM的“终极作用”：不止是管理客户，更是重构业务！</h3><ol><li><strong>打通全业务流程</strong>：从“线索获客→销售跟进→订单生产→售后回访”，数据全链路打通（超兔的“一体云”），避免“销售不知道库存、财务不知道跟进”的尴尬。</li><li><strong>提升客户体验</strong>：个性化互动（如超兔的“客户视图AI建议”）、快速响应（工单自动分配）、透明化（订单进度实时查），让客户更忠诚。</li><li><strong>赋能销售团队</strong>：AI线索评分让销售聚焦高价值客户，自动日报减少重复工作（超兔的“点点速记”），销售转化率提升30%+（行业平均）。</li><li><strong>降低运营成本</strong>：自动化减少人工投入，智能采购（超兔的“库存缺口计算”）降低库存积压，数据驱动减少试错成本。</li><li><strong>支撑数字化转型</strong>：从“经验驱动”转向“数据驱动”，通过AI预测市场趋势（如超兔的“销售预测”），提前布局业务。</li></ol><h3>六、2025年CRM选型指南：6步选对不踩坑！</h3><h4>1. 明确业务需求</h4><p>先问自己：<strong>我要解决什么问题？</strong> 是“提升销售转化率”“降低客户流失”还是“打通进销存与CRM”？（超兔的“一体云”适合需要全业务打通的企业）。</p><h4>2. 评估功能匹配度</h4><p>对照核心功能，比如工业企业需要“CRM+进销存+生产”（超兔的“MES生产管理”），电商需要“社交CRM”（Nimble），销售驱动型企业需要“可视化销售管道”（Pipedrive）。</p><h4>3. 考虑 scalability</h4><p>企业增长后，CRM能否支持更多用户、更多功能？（超兔的“客制化订阅”，支持小步快跑，逐步扩展）。</p><h4>4. 关注集成能力</h4><p>能否对接现有系统（ERP、财务软件、钉钉/企业微信）？（超兔的“丰富API”，支持无缝集成）。</p><h4>5. 计算总拥有成本（TCO）</h4><p>不要只看license费，还要算实施费、培训费、维护费（超兔的“低成本客制化”，TCO比传统CRM低30%+）。</p><h4>6. 试用与反馈</h4><p>先试用免费版或demo（超兔提供“免费试用”），让一线员工参与反馈——销售觉得操作麻烦，再好用的功能也没用！</p><h3>七、用户最关心的5个CRM问题解答</h3><h4>Q1：CRM适合中小企业吗？</h4><p><strong>A</strong>：当然！超兔、HubSpot、Pipedrive等CRM专门针对中小企业设计，比如超兔的“大底座、快启动”模式，支持客制化订阅，中小企业可以<strong>低成本切入，小步快跑</strong>，无需承担大企业的实施成本。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399433" alt="" title="" loading="lazy"/></p><h4>Q2：CRM需要多长时间上线？</h4><p><strong>A</strong>：取决于复杂度：</p><ul><li>简单CRM（HubSpot Free）：1-2周；</li><li>定制化CRM（超兔）：1-3个月；</li><li>大型企业CRM（Salesforce）：3-6个月。 <strong>关键</strong>：前期需求明确，实施团队专业（超兔有“一对一实施顾问”）。</li></ul><h4>Q3：如何保障CRM数据安全？</h4><p><strong>A</strong>：选择<strong>合规厂商</strong>（超兔符合等保2.0），数据加密存储（SSL/TLS），权限分级管理（超兔的“全局自动权限”），定期备份，避免数据泄露。</p><h4>Q4：CRM能和现有系统集成吗？</h4><p><strong>A</strong>：大部分CRM支持！比如超兔的“API接口”能对接金蝶/用友ERP、钉钉/企业微信；Salesforce的“AppExchange”生态有 thousands of 集成应用；Microsoft Dynamics 365与Office 365深度集成。</p><h4>Q5：AI在CRM中的作用是什么？</h4><p><strong>A</strong>：AI是2025年CRM的“核心引擎”：</p><ul><li><strong>智能跟单</strong>：超兔的“AI智能体”根据客户视图提供实时跟进建议；</li><li><strong>线索评分</strong>：Freshsales的AI识别高价值线索；</li><li><strong>预测分析</strong>：Salesforce Einstein预测销售业绩、客户流失；</li><li><strong>自动工作流</strong>：超兔的“自然语言AI”生成跟单流程，无需代码。</li></ul><h3>结语：选对CRM，等于选对未来！</h3><p>在2025年，CRM早已不是“工具”，而是企业的“数字化大脑”。无论你是小微企业还是大型企业，<strong>关键是找到“匹配自己业务需求”的CRM</strong>——比如工业企业选超兔的“一体云”，销售驱动型企业选Pipedrive，全球化企业选Salesforce。最后提醒：<strong>CRM的价值，在于“用起来”</strong> ——不要买了不用，要让一线员工真正依赖它，才能发挥最大价值！</p>]]></description></item><item>    <title><![CDATA[如何实现柔性制造高级计划排程以应对动态生]]></title>    <link>https://segmentfault.com/a/1190000047397512</link>    <guid>https://segmentfault.com/a/1190000047397512</guid>    <pubDate>2025-11-14 12:07:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>现代制造业正面临市场需求瞬息万变、产品定制化程度不断提高的复杂环境。传统的生产计划排程方式已难以适应多品种、小批量、快速交付的生产要求，这使得柔性制造高级计划排程（Advanced Planning and Scheduling, APS）成为制造企业提升竞争力的关键核心技术。柔性制造高级计划排程系统通过集成先进算法和实时数据采集能力，帮助企业实现生产资源的动态优化配置，有效应对生产过程中的各种不确定因素。<br/>在柔性制造环境中，高级计划排程系统需要具备处理多重约束条件的能力。这些约束包括设备产能、物料供应、人力资源、工艺路线等多个维度的限制因素。系统通过建立复杂的数学模型，运用遗传算法、约束规划等优化算法，在满足各种约束条件的前提下，寻找最优的生产排程方案。例如，在汽车制造行业，当出现紧急订单需要插入生产计划时，系统能够快速评估现有设备负荷、物料库存情况以及工艺兼容性，在几分钟内生成新的可行排程方案，并准确预测该变更对原有生产计划的影响。<br/>实时动态调整是柔性制造高级计划排程的另一重要特性。系统通过与企业制造执行系统（MES）、仓储管理系统（WMS）等底层系统的深度集成，实时获取生产现场的设备状态、物料消耗、订单进度等数据。<br/>当发生设备故障、物料延迟或质量异常等突发情况时，系统能够立即触发重排程机制，基于最新现场数据生成调整后的排程方案。这种实时响应能力极大地减少了生产中断时间，提高了设备利用率和订单准时交付率。<br/>值得关注的是，工业互联网平台为柔性制造高级计划排程提供了更强大的技术支撑。以广域铭岛开发的Geega（际嘉）工业互联网平台为例，该平台通过数字孪生技术构建虚拟生产环境，使企业能够在虚拟空间中对生产计划进行模拟仿真和优化验证。<br/>平台提供的APS解决方案能够实现跨工厂、跨产线的协同计划排程，特别是在汽车行业、装备制造等离散制造领域展现了显著的应用价值。通过该平台，企业可以模拟不同排程方案下的生产产出、资源利用率等关键指标，从而选择最优的生产计划方案。<br/>在具体应用场景中，柔性制造高级计划排程系统表现出强大的实用性。广域铭岛为某汽车工艺项目完成排产系统搭建，已经具备16项核心功能，可实现一键排产，平均单次排产耗时3分45秒。系统根据实时订单需求、设备状态和物料供应情况，自动生成最优的生产序列，减少了设备换型时间，提高了生产效率。同时，系统提供的可视化排程界面使计划人员能够直观地把控整体生产进度，及时进行人工干预和调整。<br/>柔性制造高级计划排程系统的实施还促进了企业生产管理模式的变革。传统的经验式排程方式逐渐被数据驱动的智能排程所取代，生产计划制定更加科学、精准。通过系统的假设分析功能，管理者可以模拟各种市场变化情景下的生产应对策略，提前制定应急预案，增强企业的市场应变能力。这种前瞻性的生产规划能力，使企业能够在激烈的市场竞争中保持领先优势。<br/>随着人工智能、大数据等技术的不断发展，柔性制造高级计划排程正朝着更加智能化、自适应化的方向演进。未来的APS系统将具备更强的自学习能力，能够从历史数据中自动发现排程规律，不断优化排程算法。同时，系统将实现与供应链上下游的更深层次协同，构建端到端的整体优化方案，为制造企业创造更大的价值。<br/>综上所述，柔性制造高级计划排程作为智能制造的核心组成部分，正在重塑现代制造业的生产管理模式。通过实现生产计划的动态优化和实时调整，企业能够有效应对市场变化，提高生产效率和资源利用率，最终增强市场竞争力。随着技术的不断进步和应用场景的不断拓展，柔性制造高级计划排程必将在推动制造业转型升级中发挥更加重要的作用。</p>]]></description></item><item>    <title><![CDATA[自动化我的友链申请脚本：让孤岛互相连起来]]></title>    <link>https://segmentfault.com/a/1190000047397521</link>    <guid>https://segmentfault.com/a/1190000047397521</guid>    <pubDate>2025-11-14 12:06:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>友链这东西，说出来有点浪漫。</p><p>2025 年了，个人博客基本没有什么流量，更多像是一座座散落在海上的小岛。  <br/>偶尔有海风吹过，但大多数时候，就是悄悄发光、自娱自乐。</p><p>而友链……就像是在这些小岛之间铺上一条条细细的桥。  <br/>你看不到桥的尽头，但知道那里至少还有一个同样孤独、同样固执的人。</p><hr/><h2>为什么拖了这么久才开放友链申请？</h2><p>刚写博客那阵子，我其实没太敢申请友链。不是因为不想被发现，而是因为我真的是那种比较内向的类型。</p><p>内容少也不自信，总觉得“我这样去申请友链，会不会显得很冒失？”  <br/>再加上每个人对友链的理解都不太一样：</p><ul><li>有人只收特定领域的高质量博客</li><li>有人觉得必须线下认识</li><li>也有人坚持要有一定的线上互动次数</li></ul><p>即便对方没有列要求，我心里还是会嘀咕：“我们不熟，贸然提出会不会不太礼貌？”</p><p>传统的友链申请方式大多是：留言、邮件，或在 GitHub 提 issue。看似简单，但对我这种“有自助收银台绝不走人工”的 I 人来说，其实是需要一点点勇气的。</p><p>直到有一次，我在看一位老师的博客时，看到有人问：“这么多友链，你是怎么维护的？”  <br/>老师回： <strong>“脚本。”</strong></p><p>那一瞬间我有点被点醒了：  <br/>既然我不好意思主动打招呼，那是不是可以先让别人跟我打招呼不要那么困难？</p><hr/><h2>说干就干：自动化友链要处理些什么？</h2><p>为了做到“自动添加”，其实需要处理的事情很简单：</p><ol><li><strong>对方网站必须能访问</strong></li><li><strong>不能让广告站点钻空子</strong></li><li><strong>对方真得挂上了我的友链</strong></li></ol><p>于是我要求申请方提供友链页地址，然后脚本负责验证：</p><ul><li>确认主站是正常可访问的</li><li>主站域名与友链页域名一致（避免广告跳转）</li><li>友链页中确实存在我的网站</li></ul><p>通过就添加，没通过就直接拒绝，简单粗暴但有效。</p><hr/><h2>技术实现：我是怎么做的？</h2><h3>1. 友链数据剥离成 JSON（重点）</h3><p>一开始我的友链是写在 Astro 的页面里的。  <br/>但这意味着：</p><p><strong>改一个字 → 就得重新打包部署</strong></p><p>非常麻烦。</p><p>后来改用 <strong>SSR（服务端渲染）</strong>  后，我意识到：</p><blockquote>完全没必要把友链打包进页面里。  <br/>数据完全可以在服务端“即时读取”。</blockquote><p>于是我把友链抽成一个 <code>links.json</code> 文件，并且 <strong>不再使用</strong> <strong>​<code>import</code>​</strong> <strong>引入它</strong>。  <br/>因为一旦 import，它就会在构建时被写死。</p><p>正确的方式是：</p><pre><code class="ts">const raw = await fs.readFile(linksPath, 'utf-8')
const { friends } = JSON.parse(raw)</code></pre><p>这样：</p><ul><li>JSON 是独立的数据源</li><li>SSR 每次渲染页面都会读取到最新内容</li><li>修改 JSON \= 友链立即生效</li><li>无需重新打包</li></ul><p>这也是我把友链从页面剥离出来的根本原因。</p><hr/><h3>2. 头像检查 + 上传 OSS</h3><p>用户提交的头像链接永远无法保证靠谱：</p><ul><li>有的不是图片</li><li>有的没 content-type</li><li>有的会失效</li></ul><p>我的解决方案是：</p><ul><li>先判断扩展名是否是图片</li><li>再通过请求检查 content-type</li><li>最后统一上传到 OSS</li></ul><p>我用的是 <code>ossutil</code> ——  <br/>因为它是 CLI，不需要把 AccessKey 写进代码里，对我这种 Node 不熟练的人来说更安全。</p><p>（当然也可以不用 OSS，不过不管是速度还是稳定性都不如 OSS 省心）</p><hr/><h3>3. 检查对方是否挂了我的链接</h3><p>为了避免“我挂你，你不挂我或者广告”的情况出现，脚本会：</p><ol><li>访问对方主站</li><li>检查友链页是否同域</li><li>抓取页面，看是否包含我的链接</li></ol><p>确认通过，才会添加。</p><hr/><h3>4. 自动更新 JSON + 顺手 Git 提交</h3><p>友链通过验证后，脚本会：</p><ul><li>把条目写入 <code>links.json</code>​</li><li>自动执行 <code>git add → commit → push</code>​</li></ul><p>因为是 SSR，页面下一次请求时就会看到最新的友链数据。</p><p><strong>不需要重新打包，也不需要重新部署。</strong></p><p>整个流程非常轻量。</p><hr/><h2>SSR 这个环节的重要性</h2><p>在写脚本之前，我也想过纯静态博客能不能实现自动化友链。  <br/>答案是：<strong>能，但非常折腾，不值得。</strong></p><p>纯静态的问题：</p><ul><li>页面打包后就是死的，无法在服务端执行校验逻辑</li><li>用户无法直接让服务器写入文件</li><li>想走 GitHub Actions，需要用户先有权限 push（显然不行）</li></ul><p>虽然理论上可以：</p><ul><li>表单提交 → 云函数写文件 → 云函数 push GitHub → Actions 构建 → 部署</li></ul><p>但整个链路太长太容易出问题。</p><p>相比之下：</p><h3><strong>SSR：写一个 API 就全部搞定</strong></h3><p>Cloudflare、Vercel 都能跑 SSR  <br/>甚至没服务器也能跑</p><p>所以最后我还是选择了最干净、最好理解、扩展性最高的方案：  <br/><strong>在 SSR 里加一个接口，让它帮我跑脚本、改 JSON、推 Git 就完事了。</strong></p><hr/><h2>最后的一点小感慨</h2><p>整个自动化流程，说白了，就是给像我这样的 I 人一点点缓冲空间。</p><p>我非常尊重那些坚持手工审核友链的朋友</p><p>那是对自己博客节奏和边界的坚持，我完全理解。</p><p>但我也知道，有不少朋友可能跟我一样：</p><ul><li>觉得对方的博客不错</li><li>想互相交换友链</li><li>却迟迟按不下那个“开口”的按钮</li></ul><p>这个脚本解决不了我鼓起勇气去申请别人友链的问题。</p><p>但至少 <strong>如果你也是这样的 I 人，来我的博客交换友链时，你完全可以毫无心理负担</strong></p><p>想找我交换友链的朋友，欢迎直接访问我的博客 <a href="https://link.segmentfault.com/?enc=AW2yMdSYEqkWfAtR6woQ3A%3D%3D.02453WLnGnswCO2ZoRNjPugioknfm5Ktv6cqoQiSmWs%3D" rel="nofollow" target="_blank">hejunjie.life</a>，也可以在本站的文章中看到完整的代码实现</p>]]></description></item><item>    <title><![CDATA[VMware ESXi 9.0.1.0 ]]></title>    <link>https://segmentfault.com/a/1190000047397535</link>    <guid>https://segmentfault.com/a/1190000047397535</guid>    <pubDate>2025-11-14 12:05:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>ESXi 9.0.1.0 Realtek 网卡（RTL8111 / RTL8125 / RTL8126 / RTL8127）定制版</p><p>VMware ESXi 9.0.1.0 macOS Unlocker &amp; OEM BIOS 2.7 集成网卡驱动和 NVMe 驱动 (集成驱动版)</p><p>发布 ESXi 9.0 集成驱动版，在个人电脑上运行企业级工作负载</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=vpawWF85nU%2FkYiRagD85rw%3D%3D.s76varT%2BjrxaOR6GbKOCs9MP4YnjpfPV6lUsFMN1Y1YjU0%2BO0d0gAxMKgcStz3Gr" rel="nofollow" target="_blank">https://sysin.org/blog/vmware-esxi-9-sysin/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=m9FLhG9nl6fmRrhn7DjKUQ%3D%3D.460MUMrLrBesUn20HA32kIjUIF7FF03P%2F24L%2FcR0TSQ%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>2025 年 11 月 13 日，新增 Realtek 网卡（RTL8111 / RTL8125 / RTL8126 / RTL8127）支持，参看下方 “Realtak 网卡兼容性” 章节。新增 Intel E822、E823、E825、E830 系列网卡支持。相关驱动更新到当前最新版。</p><p><strong>发布 ESXi 9.0 集成驱动版，在个人电脑上运行企业级工作负载，构建开发、测试和学习的最佳平台。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044081967" alt="vSphere Workloads Everywhere" title="vSphere Workloads Everywhere"/></p><h2>通用特性概览</h2><p>该版本在官方原版基础上新增以下特性：</p><ul><li>macOS Unlocker：来自 GitHub 的 <a href="https://link.segmentfault.com/?enc=6jRFXjQ%2FF9Qp7MXb0eBaOQ%3D%3D.cCIIwDvIUOn4rXdmMXCqnDvi7XQwgKwy936ivJcs7%2FzS0hn9SIde3iEuZl8WYKm2" rel="nofollow" target="_blank">Unlocker 4</a>，现已支持 macOS Tahoe</li><li>OEM BIOS 2.7：使用社区最流行的 OEM BIOS/EFI64，现已支持 Windows Server 2025</li><li>LegacyCPU support，允许在不受支持的旧款 CPU 上安装 ESXi 9.0</li><li>ESX-OSData 卷大小修改为 8GB，解决自 ESXi 7.0 起系统占用磁盘空间过大的问题（超过 142GB）</li><li>有限支持采用混合架构的第 12 代及以上 Intel 处理器，可实现正常引导和运行</li><li>中文界面语言支持，在 ESXi 9.0 的 Host Client 中继续支持简体中文界面语言，包括繁体中文</li></ul><h3>直接运行 macOS Tahoe</h3><p>参看：<a href="https://link.segmentfault.com/?enc=2PAyEAA1F5UpL53b%2BOUCyw%3D%3D.XPGC1scvtn20SdzzQKWAvsfdcAilxocLUokT8kHUK6aRLOuctQENsLe1ugT62lbN" rel="nofollow" target="_blank">macOS 26 Blank OVF - macOS Tahoe 虚拟化解决方案</a></p><p>ESXi 默认是支持创建 macOS 虚拟机的，但该功能仅限于 Apple Mac 硬件上启用。该版本解锁了对 macOS 虚拟化的支持，在任意非 Mac 硬件上可以直接运行 macOS 虚拟机。</p><p>⚠️ macOS 虚拟机与 Mac 上的 macOS 体验有天壤之别，仅用于体验而已。开启 macOS 卓越性能的唯一平台是搭载 Apple M 芯片的 Mac。尽早加入 Apple 阵营，开启卓越体验吧。</p><p>直接新建虚拟机，操作系统选择 “Apple macOS 12 (64-bit)”，即可安装和正常启动：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046829041" alt="New VM in ESXi 9" title="New VM in ESXi 9" loading="lazy"/></p><p>💡：macOS Tahoe 采用全新的 Liquid Glass 设计，对虚拟化硬件要求较高。</p><p>虚拟化中的 macOS Tahoe：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046878483" alt="macOS Tahoe in VMware" title="macOS Tahoe in VMware" loading="lazy"/></p><p>附：</p><ul><li><a href="https://link.segmentfault.com/?enc=dHs%2B7iTNQ54mBBiExirGvQ%3D%3D.bAGh13cqNhZtNq4458pCTFUeMeZFxKWqb3sZEEUOALQHEFzqrosXzHdqWxMEfAlQ" rel="nofollow" target="_blank">macOS Tahoe 26.1 (25B78) Boot ISO 原版可引导镜像下载</a></li><li><a href="https://link.segmentfault.com/?enc=CkmHuBM8FRAxhKZISKaM7g%3D%3D.es96TkRx3zo%2F21giwFtqVPpIEi9pcBBi9uvl6CJpmZmCDBhVff%2FthKTldAyqOwSv" rel="nofollow" target="_blank">macOS Sequoia 15.7.2 (24G325) Boot ISO 原版可引导镜像下载</a></li><li><a href="https://link.segmentfault.com/?enc=eXWFqGMZYsxSSzMobVrcKg%3D%3D.qDJ0sAe%2BhhLsjotZF4TTX5nGveXNm0tK7htKdM6Q27tVVLE45b2CSlWkjE1bEzsY" rel="nofollow" target="_blank">macOS Sonoma 14.8.2 (23J126) Boot ISO 原版可引导镜像下载</a></li><li>更多：<a href="https://link.segmentfault.com/?enc=PcdzR33AIzXiaO5YTTSWWg%3D%3D.IQx05Q8JaLNn%2Fm2%2FfBl2p5KZ10e9Pw1suqwBPQGuP7I%3D" rel="nofollow" target="_blank">macOS 下载汇总 (系统、应用和教程)</a></li></ul><h3>VMware Dell 2.7 BIOS EFI64 ROM</h3><p>来自社区最新的 OEM BIOS/EFI64，现已更新支持 Windows Server 2025。</p><p>BIOS.440 &amp; EFI64.ROM - Dell 2.7 OEM BIOS: NT 6.0 (Vista/Server 2008), NT 6.1 (7/Server 2008 R2), NT 6.2 (Server 2012), NT 6.3 (Server 2012 R2), NT 10.0 (Server 2016/Server 2019/Server 2022/Server 2025)</p><p>Windows Server OVF 系列：</p><ul><li><a href="https://link.segmentfault.com/?enc=IgVZROSVjPGao8BXT6g%2FzQ%3D%3D.lcIjTIFGm0vhGs9zWqXAUPZSjmbkPZL9EO2yDq%2Fw%2FES5NoD2XOA7fwy9J%2FnEyXd5" rel="nofollow" target="_blank">Windows Server 2025 OVF (2025 年 10 月更新) - VMware 虚拟机模板</a></li><li><a href="https://link.segmentfault.com/?enc=%2BPDFpB9u5u31X%2BZz%2F6dWTw%3D%3D.9X%2FtbzL3MTDO62aX0xzQbxHpSGWBJukKHXbXXd665QyeZrBw4tgGsyWvMRTy0dEK" rel="nofollow" target="_blank">Windows Server 2022 OVF (2025 年 10 月更新) - VMware 虚拟机模板</a></li><li><a href="https://link.segmentfault.com/?enc=WEQZMQe42YQwKoMOh59iWw%3D%3D.NNdL2PNwom5us6RLRWU8qYkgq1qVDsqhtxgbEk1V6rzSMWGfVdzPyCLKVJlzMq%2FL" rel="nofollow" target="_blank">Windows Server 2019 OVF (2025 年 10 月更新) - VMware 虚拟机模板</a></li><li><a href="https://link.segmentfault.com/?enc=ipvZrmo1mGaDw6Q1jEoNSA%3D%3D.yN%2FpGHZYKJ4FmxgPVr2GaK2ggM0nq%2Fdfkeovc%2BBFDZcj9GhdnkuaWR3M0STlv0J7" rel="nofollow" target="_blank">Windows Server 2016 OVF (2025 年 10 月更新) - VMware 虚拟机模板</a></li><li><a href="https://link.segmentfault.com/?enc=acq7lj98sM5dJhheXU%2FTSA%3D%3D.DcxLY%2BV%2FfiwIMpXe2bGyGhr3%2B5ttKRt%2FttHu8P48FsaBOzuyKT4Qws6cO%2FqWsyMpBG7M3rz4IfI7iFeBh2sAig%3D%3D" rel="nofollow" target="_blank">Windows Server 2008 R2 OVF (2025 年 10 月更新) - VMware 虚拟机模板</a></li></ul><p>其他 OVF，如：<a href="https://link.segmentfault.com/?enc=ZH3uNEfXMCvt8UFGD5KmLA%3D%3D.dVvTcnx2L5sthPRiqmXuKtXZIwafZLovYiSNDFu99ylEzW6OwrzrOQ1mXDNleusr" rel="nofollow" target="_blank">Rocky Linux 10 x86_64 OVF (sysin) - VMware 虚拟机模板</a>，<a href="https://link.segmentfault.com/?enc=oC7O1nSp6FpmTAWycl%2F36w%3D%3D.NYUJ%2B6qhAhAtS7LPZAWAnYLstDPQzaOOMqGIG94fsw9n5pvrh6yPymSnQIqcJqAr" rel="nofollow" target="_blank">Ubuntu 24.04 LTS x86_64 OVF (sysin) - VMware 虚拟机模板</a>，更多请在本站搜索 “OVF”。</p><h3>支持不受官方支持的旧款 CPU</h3><p><strong>ESXi 9.0 同样废弃了对部分旧款 CPU 的支持</strong>，笔者根据相关文档判断以下 CPU 将不受 ESXi 9.0 支持：</p><ul><li><p>Intel</p><ul><li>Xeon D‑1500 Series</li><li>Xeon E3‑1200‑V5 / E3‑1500‑V5 Series</li><li>Xeon E5‑2600‑V4 / E5‑1600‑V4 Series</li><li>Xeon E5‑4600‑V4 Series</li><li>Xeon E7‑8800/4800‑V4 Series</li><li>Xeon E3‑1200‑V6 Series</li><li>Intel Xeon Platinum 8100 / Gold 6100/5100 / Silver 4100 / Bronze 3100 Series</li><li>Xeon D‑2100 Series</li><li>Xeon W‑2100 Series</li></ul></li><li><p>AMD</p><ul><li>Bulldozer 架构（如 Opteron 6200/4200/3200）</li><li>Piledriver 架构（如 Opteron 4300/6300 系列）</li><li>Steamroller 架构（如 Opteron X2250/X1250 Berlin）</li><li>Kyoto 架构（如 Opteron X1100/X2100）</li></ul></li></ul><p><strong>ESXi 8.0 同样废弃了对部分旧款 CPU 的支持</strong>，以下 CPU 将不受 ESXi 8.0 支持：</p><ul><li>Intel Family 6, Model = 2A (Sandy Bridge DT/EN, GA 2011)</li><li>Intel Family 6, Model = 2D (Sandy Bridge EP, GA 2012)</li><li>Intel Family 6, Model = 3A (Ivy Bridge DT/EN, GA 2012)</li><li>AMD Family 0x15, Model = 01 (Bulldozer, GA 2012)</li></ul><p>vSphere 7.0 Update 2 及更高版本中 ESX 安装程序显示的如下警告消息已经明示：<br/> CPU_SUPPORT_WARNING: The CPUs in this host may not be supported in future ESXi releases. Please plan accordingly.</p><p><strong>修改启动参数，在官方不受支持的 CPU 的服务器上可以正常安装。</strong></p><p>根据 VMware vSphere 7.0 Release Notes，以下 CPU 已经不受支持（无法安装或者升级 ESXi 7.0）</p><p>Comparing the processors supported by vSphere 6.7, vSphere 7.0 no longer supports the following processors:</p><ul><li>Intel Family 6, Model = 2C (Westmere-EP)</li><li>Intel Family 6, Model = 2F (Westmere-EX)</li></ul><p>笔者在一台 2010 年发布的服务器上安装运行良好 (sysin)：HP DL 380 G7，Intel® Xeon® CPU E5606</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044308374" alt="ESXi 7.0 on LegacyCPU" title="ESXi 7.0 on LegacyCPU" loading="lazy"/></p><p>备注：本截图为 7.0 版本</p><h3>ESX-OSData 卷大小修改为 8GB</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046829042" alt="ESXi 9 VMFSL" title="ESXi 9 VMFSL" loading="lazy"/></p><p><strong>ESXi 9.0 对存储容量的要求未有明显变更，以下 ESXi 8.0 的描述基本适用。</strong></p><p>⚠️ 在 ESXi 8.0 中建议放弃使用 USB/SD 卡作为系统存储介质（虽然 SD 卡和 USB 介质继续获得有限支持，详见 <a href="https://link.segmentfault.com/?enc=6OFyTihDsFhQhFOOgIOMgg%3D%3D.YyUNkRwuA9RJTDZ34Nhz0BzpQmCQVkyVpkOVxLLQGsBF9FInWb7pr%2BMBq00z6kvd" rel="nofollow" target="_blank">KB85685</a>）。</p><p>从 ESXi 7.0 开始，对磁盘空间的要求有所变化：</p><ul><li>8GB SD 卡 + 32GB 本地磁盘</li><li>32GB 本地磁盘</li><li>142G 或者更大的本地磁盘</li></ul><p>通常我们在一块数百 GB 或者更大的本地磁盘上安装 ESXi，系统分区磁盘空间将占用 142GB 以上，整个系统分区（内核参数：systemMediaSize）需要 138GB 和 4GB 以上的空闲空间，其中 ESX-OSData volume 大约需要 120GB 的磁盘空间，对于磁盘空间紧张情况下可能有一定的浪费 (sysin)。修改后，系统安装后占用的磁盘空间不超过 16GB（特别是针对个人实验，无需浪费过多存储容量）。</p><p>图：vSphere 7 中的新分区架构，只有系统引导分区固定为 100 MB，其余分区是动态的，这意味着分区大小将根据启动媒体大小确定。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044308376" alt="partition schema in vSphere 7" title="partition schema in vSphere 7" loading="lazy"/></p><p>从 vSphere 7.0 Update 1c 开始，您可以使用 ESXi 安装程序引导选项 <code>systemMediaSize</code> 限制启动媒体上系统存储分区的大小。如果您的系统占用空间较小，不需要最大 128 GB 的系统存储大小，您可以将其限制为最小 32 GB。<code>systemMediaSize</code> 参数接受以下值：</p><ul><li>min（32 GB，用于单磁盘或嵌入式服务器）</li><li>small（64 GB，用于至少有 512 GB RAM 的服务器）</li><li>default（128 GB）</li><li>max（消耗所有可用空间，用于多 TB 的服务器）</li></ul><blockquote>即使设置值为 min，相比之前的版本所需存储容量还是要大的多。</blockquote><h3>有限支持第 12 代及以上 Intel 处理器</h3><p>ESXi 面向数据中心虚拟化，在测试和学习时也常常将其运行于桌面 PC 之上。</p><p>据悉 ESXi 8.0 并不支持第 12 代 Intel 处理器，直接引导会出现 PSOD。本次通过加载内核参数可以有限支持第 12 代 Intel CPU，即可以正常引导和安装，也可以正常运行 (sysin)，但是无法区分或识别两种核心，P 核的超线程是无法识别的，比如 i7-12650H 配备 6P + 4E 在桌面系统中显示为 16 核心，而在 ESXi 中仅识别为 10 核。现在有了更好的解决方案，绝大多数主流品牌机和主板都可以通过配置开启 P 核的超线程（非主流请慎选）。</p><p>已经广泛验证支持第 12 代及以上 Intel 处理器（目前 13、14 代同样支持），更多案例，期待您的反馈。</p><blockquote><p>第 12 代英特尔酷睿桌面级处理器有 N 个性能核（P 核，Performance-core）和 N 个能效核（E 核，Efficient-core）组成，性能核和能效核的混合架构，是 12 代酷睿处理器最大的革新。该架构或俗称 PE 大小核。</p><p>第 12 代及以上 Intel CPU 已经成功安装 ESXi 后需要进一步配置，可联系笔者了解详情。</p></blockquote><p>⚠️：并不推荐此类 CPU，无法有效利用全部计算资源。</p><p>💡：仅标准版和集成驱动版提供此项特性，品牌服务器于此无关。</p><h3>可选简体和繁体中文界面语言支持</h3><p>官方弃用了对中文界面语言的支持，本定制版在 ESXi 9.0 的 Host Client 中继续支持简体中文界面语言，包括繁体中文。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046829058" alt="ESXi 9 简体中文界面和镜像配置文件" title="ESXi 9 简体中文界面和镜像配置文件" loading="lazy"/></p><p>💡：此项不推荐，单机工作正常，但是与 VVF 或者 VCF 组件协同尚未验证，在未来的 Update 版本中可能无法支持，应尽快适应官方版本的变化。</p><p>💡：仅集成驱动版提供此项特性（仅通用版本，特殊定制版暂不提供），品牌服务器无需在意。</p><h2>Realtak 网卡兼容性</h2><p>首先 REALTEK 从来没有为 VMware 创建过驱动，除非该厂商未来战略改变。VMware 也从未支持过 Realtek 网卡。历史上存在非官方 RTL 驱动，来自 Linux 移植，ESXi 早已不在兼容 Linux。但是现在好消息来了，VB 公司的工程师开发了非官方的 REALTEK 网卡驱动。2025 年 11 月 13 日之后发布的版本将默认包含。</p><p>☑️ 支持的网卡列表：</p><ul><li>RTL8111 - 1GbE</li><li>RTL8125 - 2.5GbE</li><li>RTL8126 - 5GbE</li><li>RTL8127 - 10GbE</li></ul><p>💡 提示：</p><ul><li>Realtek 网卡驱动仅提供基本的网络连接，目前不包括 TSO、LRO WOL 等硬件辅助卸载。</li><li>当前同样是非官方支持，此类网卡并非选购的参考。</li></ul><p>集成的其他驱动及网卡兼容性，请访问原文链接：<a href="https://link.segmentfault.com/?enc=PlAbW1ZMUMVPNM0QluIrOg%3D%3D.75s8DLqYv%2F82gSLw9HdMHpusxg7sh9vKS66NWigJpNd6OgnDFwUZis0Z75DV24A6" rel="nofollow" target="_blank">https://sysin.org/blog/vmware-esxi-9-sysin/</a> 查看。</p><h2>下载地址</h2><p><strong>ESXi 9.0.1.0 集成驱动版 (2025-11-13)</strong>：</p><ul><li>发布日期：2025-11-13</li><li>新增 RTL8111/RTL8125/RTL8126/RTL8127 网卡支持。</li><li>新增 Intel E822、E823、E825、E830 网卡支持。</li><li>相关驱动更新到当前最新版。</li><li>请访问：<a href="https://link.segmentfault.com/?enc=f7dx0kmygaTaO0S8cKzpYA%3D%3D.9RedT6v81YX6ftyoFVmozGd5akKaoLh3H4QO6bar9sWBpEceEup5Q5APi%2BYu1Yau" rel="nofollow" target="_blank">https://sysin.org/blog/vmware-esxi-9-sysin/</a></li></ul><hr/><p>标准版和厂商定制版，请访问：</p><ul><li><a href="https://link.segmentfault.com/?enc=LKx9dZMHb%2BajHYAPTLDNgQ%3D%3D.o1MiTx%2BypQ6HYinQC6ruenzS%2BZrb4%2BdImHoaf1AVdDsX2ka7Y9%2FOiEQ0%2F%2BUFukuN" rel="nofollow" target="_blank">VMware ESXi 9.0.1.0 macOS Unlocker &amp; OEM BIOS 2.7 标准版和厂商定制版</a></li></ul><p>官方原版，请访问：</p><ul><li><a href="https://link.segmentfault.com/?enc=lCa79neM6o%2B3Hdd4Vu7L%2BQ%3D%3D.glPdM4Jii1qhtZN9NyeXfbJ7Df%2Bb2GmOfyENS6s1LN1QxooprI1PvI8dOmOAd4xZ" rel="nofollow" target="_blank">VMware vSphere 9.0.1.0 发布 - 企业级工作负载平台</a></li></ul><p>上一个版本，请访问：</p><ul><li><a href="https://link.segmentfault.com/?enc=ffdtHgkNsdJbK25n5BSv9g%3D%3D.gVrhgq8j5hW9RZ1OPRLWNc0PPswDYITEev%2F4acI8%2FYUfQWZGsKVPoUQU%2F47r6e%2F5" rel="nofollow" target="_blank">VMware ESXi 8.0U3g macOS Unlocker &amp; OEM BIOS 2.7 集成网卡驱动和 NVMe 驱动 (集成驱动版)</a></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=pRMSN43Q%2FEkIHJp44ual3w%3D%3D.W0KfjXbY%2BVrz5BeQiHWUaqY3Tzoww8N9B8BJBNlEIHI%3D" rel="nofollow" target="_blank">VMware 产品下载汇总</a></p>]]></description></item><item>    <title><![CDATA[工业装备健康管理：从被动维修到主动预测的]]></title>    <link>https://segmentfault.com/a/1190000047397543</link>    <guid>https://segmentfault.com/a/1190000047397543</guid>    <pubDate>2025-11-14 12:04:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着全球制造业进入智能化转型的关键阶段，设备健康管理作为工业互联网的核心应用场景之一，正成为企业提升生产效率、保障设备可靠性、降低运维成本的重要抓手。设备健康管理通过整合物联网、大数据分析、人工智能等技术，构建覆盖设备全生命周期的智能运维体系，是实现“智能制造”向“智慧制造”跃升的关键支撑。<br/>在现代工业体系中，设备故障已成为影响生产连续性的主要风险之一。传统以“事后维修”为主的设备管理方式，不仅造成生产中断和经济损失，还增加了备件库存和维护成本。例如，某大型风电企业因设备突发故障，单次停机损失高达200万元，而通过预测性维护技术的引入，提前识别潜在风险并制定干预计划，成功将损失减少至最低。<br/>一、设备健康管理的核心价值<br/>设备全面诊断系统是实现健康管理的基础设施。通过实时采集设备运行数据，企业能够动态监控设备状态，预测潜在故障，并科学制定维护策略。广域铭岛的Geega工业互联网平台在多个行业展现了其技术优势。该平台整合了多源传感器数据，结合边缘计算与云计算能力，实现了从“经验驱动”到“数据驱动”的管理范式转变。<br/>以某铝业企业为例，其通过接入广域铭岛的设备健康管理平台，实现了对生产设备的实时监测与预警。覆盖了设备点巡检、保养、状态监控、 标准建立、数据报表等全生命周期，全面推进了设备管理的数字化转型。设备完好率提升10%，MTTR提高5% MTBF降低7%。<br/>二、技术架构的创新与突破<br/>设备健康管理的技术架构通常包括三个核心支点：数据采集层、智能分析层、决策执行层。数据采集层通过部署各类传感器和工业网关，实时获取设备运行数据；智能分析层利用深度学习、机器学习等AI算法处理数据，识别异常模式；决策执行层则基于分析结果制定维护计划，并通过自动化工具执行。<br/>三、行业应用与实践案例<br/>设备健康管理在多个行业展现出显著价值。在能源领域，变压器油色谱在线监测系统结合数字孪生技术，将重大事故率降低至历史水平的85%；在流程工业中，腐蚀泄漏风险预测模型帮助化工企业延长关键设备的使用寿命；在离散制造领域，某家电制造基地通过设备健康管理系统实现了空压机群控系统节能23%、产品不良率下降58%的突破性成果。<br/>四、未来发展趋势与挑战<br/>随着5G、边缘计算、量子算法等技术的演进，设备健康管理正迈向更智能化、自动化的阶段。例如，广域铭岛正在研发新一代自主维护系统，实现设备故障的“监测-诊断-处置”闭环管理。<br/>然而，设备健康管理的推广仍面临诸多挑战：数据孤岛现象严重，跨厂商设备的协议兼容性问题尚未完全解决；算法泛化能力不足，需针对不同行业和设备类型定制化开发；人机协作机制不完善，一线维护人员的数据素养和技能水平有待提升。<br/>五、结语<br/>设备健康管理不仅是技术问题，更是管理理念的革新。通过构建覆盖全生命周期的智能运维体系，企业能够实现从“被动响应”到“主动预防”的转变。广域铭岛等工业互联网平台服务商的创新实践，正在为制造业提供强有力的工具支持，推动设备管理进入一个全新的智能化时代。未来，随着技术的持续演进和生态的逐步完善，设备健康管理将从单点优化向全价值链协同演进，成为工业数字化转型的核心驱动力。</p>]]></description></item><item>    <title><![CDATA[2.4万亿参数的“暴力美学”，文心5.0]]></title>    <link>https://segmentfault.com/a/1190000047399259</link>    <guid>https://segmentfault.com/a/1190000047399259</guid>    <pubDate>2025-11-14 12:03:31</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在过去几年里，AI在多模态方向一次又一次进化。但过去的“多模态”或多或少都有些“拼接”的妥协。昨天看到2025百度世界大会发布了文心5.0，一个总参数规模超过2.4万亿的模型，以及一个试图“<strong>重新定义”原生全模态</strong>的野心。</p><p>2.4万亿参数，这听起来就像是“大力出奇迹”。但这股“蛮力”背后，是百度对“原生全模态”的执着。在模型发布后，我进行了一系列测试。看看文心5.0只是“不服跑个分”还是“上得厅堂下得厨房”。</p><h2>重新定义“原生全模态”</h2><p>要理解“重新定义”的含金量，我们得先看“旧定义”的痛点。</p><p>现在业界多数的多模态模型，更像是“拼接”起来的。你可以想象一个团队：</p><ul><li>一个“文本专家”，只懂语言。</li><li>一个“图像专家”，只懂画面。</li><li>一个“音频专家”，只懂声音。</li></ul><p>当你给出一个多模态任务（比如“看这个视频，总结一下大家的反应”），这些模型的工作流是：文本专家先分析字幕，图像专家再分析画面，最后由一个“项目经理”把他们的报告“后期融合”在一起，得出一个凑合的结论。</p><p>这种“拼接”模式有两大硬伤：</p><ol><li><strong>信息损耗：</strong> 跨模态的信息在“融合”时会大量丢失。比如，图像专家无法理解文本的“梗”，文本专家也无法感知画面的“氛围”。</li><li><strong>理解与生成割裂：</strong> 大多数“拼接”模型，要么擅长“理解”，要么擅长“生成”，但很难用一套架构同时做好两件事。</li></ol><p>像极了我们工作中的跨部门协作。</p><p>文心5.0提出的“原生全模态”（Native Full Modality），彻底掀翻了这张桌子。</p><p>它不是“拼接”的。用官方的话说，它“自训练伊始便融合语言、图像、视频、音频等多模态数据”。</p><p>用程序员来举例的话，文心5.0就是全栈工程师，<strong>在同一个“大脑”里，用统一的架构去理解和生成所有模态</strong>。</p><p>这带来的最大突破，就是真正实现了“理解与生成一体化”。</p><h2>实测一下</h2><p>理论上的“暴力美学”和“重新定义”，在实际应用中到底体验如何？</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399261" alt="" title=""/></p><h3>散发创作</h3><p><strong>输入</strong></p><pre><code>模仿林夕的填词风格，写一首适合王菲唱的关于周杰伦为什么不发新歌的歌</code></pre><p><strong>文心5.0输出</strong></p><pre><code>休止符
主歌1：
咖啡杯沿的雾气 散了又聚
像那年听《晴天》 雨下得多仔细
你写的旋律 停在哪页笔记
我数着节拍 等时光倒叙
主歌2：
琴键上的灰 积了多少厘米
像《青花瓷》里 未烧完的秘密
你说过故事 要讲到千年去
可现在 谁在续写结局
副歌：
你的笔锋为何停留 在半句的温柔
怕匆忙的音符 凑不成永久
我们等的不是新歌 是那个不会老的自己
在副歌里重逢 旧时光的褶皱
主歌3：
电台里循环着《七里香》的余韵
像青春的信笺 没写完的疑问
你说过要陪我们 看遍所有风景
可现在 谁在等 下一站的黎明
副歌：
你的笔锋为何停留 在半句的温柔
怕匆忙的音符 凑不成永久
我们等的不是新歌 是那个不会老的自己
在副歌里重逢 旧时光的褶皱
桥段：
年华像倒带 本子里的爱
还停在《简单爱》的那片海
可现在 谁在改 结尾的坦白
你把完美的休止符 藏在岁月的口袋
副歌：
你的笔锋为何停留 在半句的温柔
怕匆忙的音符 凑不成永久
我们等的不是新歌 是那个不会老的自己
在副歌里重逢 旧时光的褶皱
结尾：
咖啡凉了 又续上
像《夜曲》里 没结束的怅惘
你不发新歌 没关系
我们等的 是那个 不会老的自己
在旧旋律里 永远 年轻
注：歌词以“等待”为核心，用“咖啡杯”“琴键”“旧旋律”等意象串联周杰伦经典作品（《晴天》《青花瓷》《七里香》《简单爱》《夜曲》），将“不发新歌”的疑问转化为对“不会老的自己”的情感寄托，符合林夕“以小见大、以物喻情”的风格。王菲的声线适合处理这种带点慵懒的怅惘，主歌的长句如“咖啡杯沿的雾气散了又聚”契合她的断句习惯，副歌的重复“你的笔锋为何停留”用气声演唱会更显空灵。桥段“你把完美的休止符藏在岁月的口袋”既点题“停顿”，又保留了艺术的留白感，符合王菲“仙”的气质。</code></pre><p>风格确实抓住了林夕的“以小见大、以物喻情” 的核心特质，也符合林夕填词的文艺调性。歌词加入了周杰伦的元素，一听就知道在写周杰伦，用词也符合王菲“慵懒、空灵”的风格。</p><h3>工作报告</h3><p><strong>输入</strong></p><pre><code>帮我用互联网黑话（比如拉通闭环颗粒度）写一篇互联网大厂前端程序员岗位的年终述职报告</code></pre><p><strong>输出</strong></p><pre><code>互联网大厂前端程序员年终述职报告：以技术赋能业务，驱动增长闭环
一、战略对齐与顶层设计：构建业务增长双引擎
2025年，我深度参与公司核心业务线的前端架构升级，通过顶层设计重构用户生态体系。在电商业务线中，主导完成“用户增长闭环”的端到端设计，从流量入口的颗粒度优化（页面加载速度提升40%）到转化路径的链路拆解（关键节点转化率提升18%），实现用户生命周期价值（LTV）的量化增长。
在金融科技业务中，通过拉通产品、运营、风控三部门需求，设计动态可配置的前端框架，支持业务快速迭代。例如，在信贷产品上线周期从2周缩短至3天的过程中，前端模块的模块化封装与低代码配置能力成为关键抓手，直接降低跨部门协作成本60%。
二、技术赋能与闭环迭代：打造敏捷开发范式
性能优化闭环
针对高并发场景，构建“监控-分析-优化-验证”的闭环体系。通过Real User Monitoring（RUM）工具抓取用户行为数据，定位首屏加载瓶颈，采用骨架屏+懒加载技术将页面性能得分从72分提升至91分（Lighthouse标准），直接推动广告转化率提升12%。
工程化能力升级
推动前端工程化2.0建设，引入Monorepo架构与自动化测试体系，实现代码提交到部署的全流程自动化。通过量化代码质量指标（如ESLint错误率下降85%、单元测试覆盖率提升至90%），显著降低线上故障率。
跨端技术突破
在IoT业务线中，研发跨端渲染引擎，统一Web、小程序、快应用的渲染逻辑，减少重复开发工作量70%。该方案已申请3项技术专利，并在智能家居场景中实现日均百万级设备的动态配置更新。
三、业务增长与生态化反：从流量到变现的跃迁
用户增长实战
在社交裂变项目中，设计“任务宝+拼团”双引擎增长模型，通过前端动态配置活动规则（如阶梯奖励、实时排行榜），实现单日新增用户突破50万。其中，颗粒度极细的用户分群策略（基于RFM模型的200+标签组合）使活动ROI提升3倍。
商业变现闭环
重构广告投放系统，引入AB测试平台与实时竞价（RTB）接口，支持千人千面的广告策略。通过前端埋点数据的深度拆解（如用户停留时长、点击热力图），优化广告位布局，使eCPM（每千次展示收益）提升25%，年度广告收入增加1.2亿元。
生态化反构建
主导开发开放平台前端SDK，支持第三方开发者快速接入公司服务。通过标准化接口设计与沙箱环境，吸引200+合作伙伴入驻，形成“技术赋能-数据反哺-业务增长”的正向循环。该生态贡献的GMV占比已达公司总营收的18%。
四、组织建设与梯队赋能：激发团队内生动力
知识体系沉淀
搭建前端技术中台，封装30+可复用组件（如高阶图表库、微前端框架），输出技术文档与Demo案例，降低新人上手成本50%。
人才梯队培养
设计“新人成长飞轮”计划，通过颗粒度极细的技能矩阵（如React性能优化、Webpack配置等20个维度）与导师制，实现3个月内独立承担模块开发的占比从40%提升至75%。
文化价值观落地
推动“技术驱动业务”的文化建设，组织月度技术沙龙与黑客马拉松，孵化出5个内部创新项目，其中2个已转化为公司级战略产品。
五、反思与展望：突破第二增长曲线
当前挑战
在Web3.0与AIGC浪潮下，前端技术栈的演进速度需进一步匹配业务创新需求。
跨端一致性在复杂交互场景中仍存在体验断层，需深化渲染引擎的底层优化。
2026年规划
技术层面：探索Serverless与边缘计算的前端落地，构建“云-边-端”协同架构。
业务层面：通过AI生成代码（AIGC）技术，实现需求到原型的高效转化，缩短产品迭代周期50%。
组织层面：建立前端技术委员会，输出行业影响力白皮书，强化技术品牌壁垒。
结语
2025年是技术赋能业务、数据驱动增长的突破之年。从颗粒度极细的性能优化到生态化反的商业闭环，前端团队已从成本中心转型为价值创造中心。2026年，我们将以“技术深度×业务广度”的双轮驱动，持续打造公司第二增长曲线的核心引擎。</code></pre><p>报告完美契合需求，互联网黑话（拉通、闭环、颗粒度等）运用精准自然，无堆砌感。结构遵循 “战略 - 技术 - 业务 - 组织 - 反思” 闭环逻辑，贴合大厂述职框架。内容聚焦前端核心工作，搭配量化数据支撑业绩，既体现技术深度，又突出业务价值，岗位适配度极高。</p><h3>逻辑问题</h3><p>用弱智吧拷打一下～</p><p><strong>输入</strong></p><pre><code>立定跳远和三级跳远哪个更容易跳过App开屏广告？</code></pre><p><strong>输出</strong></p><pre><code>这个问题融合了体育项目与日常生活场景，关键在于理解立定跳远和三级跳远的特点，以及它们与跳过App开屏广告这一行为的关联性。
首先，我们明确两种跳远方式的基本定义和特点：
立定跳远：运动员从静止状态开始，通过双腿的爆发力直接跳远。它主要依赖于瞬间的力量和技巧。
三级跳远：运动员先进行一次单足跳，接着跨步跳，最后是跳跃，总共分为三个阶段。它更注重连续的动作协调和节奏感。
接下来，我们分析跳过App开屏广告这一行为：
跳过App开屏广告通常是一个简单的点击或滑动动作，与体育中的跳远没有直接联系。这里的“跳过”更多是指用户界面上的一个操作，而非物理上的跳跃。
现在，我们对比两种跳远方式与跳过App开屏广告的关联性：
无论是立定跳远还是三级跳远，它们都是体育项目，需要特定的场地、装备和训练。而跳过App开屏广告则是一个简单的电子设备操作，两者在本质上没有联系。
从实际操作的角度来看，跳过App开屏广告不需要任何体育技能或力量，只需要简单的点击或滑动。
综上所述，立定跳远和三级跳远与跳过App开屏广告这一行为没有直接关联。无论是哪种跳远方式，都无法直接帮助用户跳过App的开屏广告。跳过广告是一个简单的电子设备操作，与体育技能无关。因此，这个问题实际上是一个巧妙的比喻或玩笑，它试图将两个完全不相关的领域联系在一起。在实际情况中，我们无法通过立定跳远或三级跳远来跳过App的开屏广告。</code></pre><p>输出精准拆解了 “体育跳远” 与 “跳过广告” 的本质差异，逻辑清晰地指出两者无直接关联，还点出问题的玩笑属性，完全契合需求。</p><p>但语言偏严肃，缺乏对问题幽默调性的呼应，拆解过程稍显刻板。</p><h3>常识问题</h3><p><strong>输入</strong></p><pre><code>药物外包装写了“包装破损不可食用”，有什么办法不让包装破损的情况下食用里面的药物？难道要把外包装一起吃掉吗？</code></pre><p><strong>输出</strong></p><pre><code>药物外包装标注“包装破损不可食用”的核心目的是保障用药安全，因为包装破损可能导致药物受潮、污染或变质。要理解如何在不破坏包装的情况下正常服用药物，需要先明确“包装破损”的定义及正常使用方式：
1. 区分“正常打开”与“包装破损”
药物包装的设计本身允许用户通过正常操作取出药物（如按压泡罩、拧开瓶盖），这不属于“破损”。例如：
铝塑泡罩包装：按压泡罩底部，药片会从铝塑膜中推出（正常操作），此时泡罩本身未破裂（无孔洞或撕裂）即为正常。
药瓶包装：拧开瓶盖取出药片后重新盖紧（保持密封），瓶盖的开启是正常使用，不属于破损。
“包装破损”通常指：泡罩被挤压出孔洞、铝塑膜撕裂、药瓶密封膜被刺破、外盒浸水或严重变形等非正常损坏，导致药物可能接触外界环境（如潮湿、细菌、光线）。
2. 为何“包装破损不可食用”？
药物包装（如铝塑泡罩、密封瓶）的核心作用是隔离外界环境：
防潮：避免药物受潮（如片剂吸潮后可能碎裂、药效降低）；
防污染：防止微生物（细菌、霉菌）侵入，避免药物变质；
避光：某些药物（如维生素、抗生素）需避光保存，包装破损可能导致药物分解。
若包装破损，即使药物外观无明显变化，也可能已失效或存在安全风险，因此不建议使用。
3. 特殊情况：如何安全取出药物？
如果包装较难打开（如儿童安全瓶盖、紧密的泡罩），可尝试以下方法避免破坏包装：
儿童安全瓶盖：按住瓶盖同时向下按压并旋转（参考瓶盖上的指示），避免暴力拧开；
紧密泡罩：用干净的硬币或工具轻推泡罩底部（而非戳破），帮助药片脱出；
咨询药师：若包装确实难以打开，可联系药师或厂家获取辅助工具（如泡罩取出器）。
总结
“包装破损不可食用”并非禁止“打开包装”，而是禁止非正常损坏导致包装失去保护作用。正常服用药物时，通过合理方式打开包装（如按压泡罩、拧开瓶盖）是安全的，无需“连外包装一起吃”。若包装已意外破损（如泡罩破裂、药瓶密封膜损坏），则应丢弃药物，避免风险。</code></pre><p>输出精准回应核心疑问，清晰区分 “正常打开” 与 “包装破损” 的边界，从安全原理、操作方法两方面层层解答，完全打消 “吃外包装” 的误解。逻辑严谨、实用性强，既解释了标注初衷，又给出具体开包装技巧，贴合用药场景需求。</p><h3>简单数学题</h3><p><strong>输入</strong></p><pre><code>用通俗易懂的方式给我小学五年级的儿子讲解一下为什么9.11比9.9大</code></pre><p><strong>输出</strong></p><pre><code>其实这里可能有个小误会哦！9.11并不比9.9大，反而是9.9更大。不过别着急，我们用生活中的例子慢慢说，你肯定能明白～
第一步：把小数变成“钱”来理解
你可以把小数想象成“元角分”，这样超直观！
9.11元 = 9元1角1分（也就是9元 + 1角 + 1分）
9.9元 = 9元9角（也就是9元 + 9角，或者也可以写成9元9角0分，即9.90元）
现在比较一下：9元1角1分 和 9元9角，哪个更多？
显然是9元9角更多，因为1角1分只有11分，而9角是90分，90分比11分多呀！所以9.9元（9元9角）比9.11元（9元1角1分）更多。
第二步：用“排队”来理解小数的位数
小数的大小不是看“数字有多少位”，而是从左到右一位一位比！就像排队比身高，先比第一个人（整数部分），如果一样高，再比第二个人（十分位），还一样就比第三个人（百分位）……
比如9.11和9.9：
整数部分都是9，一样大，所以比下一位（十分位）。
9.11的十分位是1（也就是0.1），9.9的十分位是9（也就是0.9）。
1比9小，所以不管后面的数字是什么，9.11都比9.9小啦！
总结一下
小数比较大小的秘诀是：先比整数部分，整数部分一样就比十分位，十分位一样再比百分位…… 不是看谁的数字多哦！
就像9.9其实是9.90，它的十分位是9，比9.11的十分位1大，所以9.9更大～
现在你明白了吗？😊</code></pre><p>输出的内容挺契合 “给五年级孩子通俗讲解” 的核心需求，用 “元角分”“排队比身高” 两个贴近生活的例子，清晰拆解小数比较逻辑，还纠正了 “数字位数多就大” 的误区。</p><h3>理解图片元素</h3><p><strong>输入</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399262" alt="" title="" loading="lazy"/></p><pre><code>描述一下这张图片的内容</code></pre><p><strong>输出</strong></p><pre><code>这张图片呈现了一幅简洁且富有视觉冲击力的场景：
画面中央是一只鲜艳的红色消防栓，它稳稳矗立在铺满浅灰与白色鹅卵石的海滩上。消防栓结构清晰，顶部的接口、两侧的出水口及金属链条都完整可见，鲜红色在浅色调的鹅卵石衬托下格外醒目。
背景是一片广阔的蓝色海洋，海水由近及远呈现出深浅不一的蓝色层次，远处海天相接，天空是澄澈的淡蓝色，没有云层，显得格外晴朗开阔。
整体画面色彩对比强烈（红与蓝、鹅卵石的白与海水的蓝），且消防栓这一通常出现在城市街道的设施，被置于海边场景中，形成一种超现实的反差感，既营造出宁静清新的氛围，又因场景的“违和感”带来视觉上的意外与趣味。</code></pre><p>精准捕捉到核心元素。</p><h3>音频内容理解</h3><p><strong>输入</strong></p><p>我上传了一首陈奕迅的《浮夸》给文心5.0，粤语版。</p><pre><code>解释一下这首歌讲了什么</code></pre><p>输出</p><pre><code>根据提供的音频文件《歌曲.mp3》中的歌词内容，这首歌主要讲述了一个人的内心挣扎、自我表达的需求以及对被关注和认可的渴望。以下是对这首歌主题的详细解释：
内心孤独与渴望表达：
歌词开头“有人问我，我就会讲，但是无人来，我期待到无奈”表达了主人公内心的孤独感和对交流的渴望。他希望有人能倾听他的心声，但现实中却无人问津，这种期待逐渐变成了无奈。
自我表达的困境：
“有话要讲，得不到装载，我的心情就像真该等被揭开，嘴巴却再扬青苔”描绘了主人公有话想说却无处倾诉的困境。他的心情像被遮盖的秘密，渴望被揭开，但嘴巴却像长了青苔一样，无法畅所欲言。
对被忽视的感受：
“人潮来，月云静越变得不受理睬”反映了主人公在人潮中感到被忽视的情境。即使周围人来人往，他却依然感到孤独和不受关注。
自我夸张与逃避：
“我是浮夸，假装只因我恨在逃避”揭示了主人公可能通过夸张的行为来掩饰内心的真实感受，试图逃避被忽视的现实。他假装自己很浮夸，实际上是因为内心充满了怨恨和逃避的情绪。
对平凡生活的不满与追求：
“那年十八，某校舞会站着如流落，那时候我含泪发誓个鬼，别再看到我在世间平凡凡”回忆了主人公年轻时的经历，他曾在舞会上感到自己像流落街头一样无助。他发誓不再过平凡的生活，暗示了对更高追求和更好生活的渴望。
自尊与挫折：
“有普通的路太多，木村你住哪一座情爱中工作中受过的忽视太多，自尊已饱经跌簸”表达了主人公在情爱和工作中遭受的忽视和挫折，这些经历让他的自尊心受到了严重的打击。
对认可和成功的渴望：
“若然未当过，就知我为何用十倍苦心做得出一个”以及“做大娱乐家”等歌词，体现了主人公对成功和被认可的渴望。他愿意付出十倍的努力来实现自己的目标，成为众人瞩目的焦点。
内心的挣扎与不安：
歌词中多次出现“很不安怎么办”、“在这冷战中沉默”等表达，揭示了主人公内心的挣扎和不安。他在面对现实和追求梦想的过程中，充满了困惑和不确定性。</code></pre><p>准确捕捉到《浮夸》“渴望被关注、自我表达困境、内心孤独” 的核心主题。</p><h3>编程：扫雷游戏</h3><p><strong>输入</strong></p><pre><code>用js做一个扫雷游戏</code></pre><p><strong>输出</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399263" alt="" title="" loading="lazy"/></p><pre><code>扫雷游戏实现
我将为你创建一个完整的扫雷游戏，包含所有核心功能。这个实现将使用HTML、CSS和JavaScript。
设计思路
首先，我需要实现以下功能：
生成指定大小的雷区
随机布雷
左键翻开格子
右键标记旗帜/问号
自动展开空白区域
游戏状态判断（胜利/失败）
计时器和剩余雷数显示
不同难度级别
完整代码实现
html
&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;扫雷游戏&lt;/title&gt;
    &lt;style&gt;
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
            padding: 20px;
        }
        
        .game-container {
            background-color: #c0c0c0;
            border: 3px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            padding: 10px;
            box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3);
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            margin-bottom: 10px;
            background-color: #c0c0c0;
            border: 3px solid;
            border-color: #808080 #ffffff #ffffff #808080;
        }
        
        .counter {
            background-color: #000;
            color: #ff0000;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            padding: 5px 10px;
            border: 2px inset #808080;
            min-width: 60px;
            text-align: center;
        }
        
        .restart-btn {
            font-size: 24px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #c0c0c0;
            border: 3px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            cursor: pointer;
        }
        
        .restart-btn:active {
            border-color: #808080 #ffffff #ffffff #808080;
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(9, 30px);
            grid-template-rows: repeat(9, 30px);
            gap: 1px;
            background-color: #c0c0c0;
            border: 3px solid;
            border-color: #808080 #ffffff #ffffff #808080;
        }
        
        .cell {
            width: 30px;
            height: 30px;
            background-color: #c0c0c0;
            border: 3px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            user-select: none;
        }
        
        .cell.revealed {
            border: 1px solid #808080;
            background-color: #e0e0e0;
        }
        
        .cell.mine {
            background-color: #ff0000;
        }
        
        .cell.flagged {
            font-size: 20px;
        }
        
        .cell[data-count="1"] { color: #0000ff; }
        .cell[data-count="2"] { color: #008000; }
        .cell[data-count="3"] { color: #ff0000; }
        .cell[data-count="4"] { color: #000080; }
        .cell[data-count="5"] { color: #800000; }
        .cell[data-count="6"] { color: #008080; }
        .cell[data-count="7"] { color: #000000; }
        .cell[data-count="8"] { color: #808080; }
        
        .difficulty-selector {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        
        .difficulty-btn {
            padding: 5px 10px;
            background-color: #c0c0c0;
            border: 2px solid;
            border-color: #ffffff #808080 #808080 #ffffff;
            cursor: pointer;
        }
        
        .difficulty-btn:active {
            border-color: #808080 #ffffff #ffffff #808080;
        }
        
        .game-status {
            margin-top: 10px;
            font-size: 18px;
            font-weight: bold;
            height: 25px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;扫雷游戏&lt;/h1&gt;
    
    &lt;div class="game-container"&gt;
        &lt;div class="header"&gt;
            &lt;div class="counter" id="mines-counter"&gt;010&lt;/div&gt;
            &lt;div class="restart-btn" id="restart-btn"&gt;🙂&lt;/div&gt;
            &lt;div class="counter" id="timer"&gt;000&lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="board" id="board"&gt;&lt;/div&gt;
        
        &lt;div class="game-status" id="game-status"&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class="difficulty-selector"&gt;
        &lt;button class="difficulty-btn" data-level="easy"&gt;简单 (9×9, 10雷)&lt;/button&gt;
        &lt;button class="difficulty-btn" data-level="medium"&gt;中等 (16×16, 40雷)&lt;/button&gt;
        &lt;button class="difficulty-btn" data-level="hard"&gt;困难 (16×30, 99雷)&lt;/button&gt;
    &lt;/div&gt;
    &lt;script&gt;
        class MinesweeperGame {
            constructor(rows, cols, mines) {
                this.rows = rows;
                this.cols = cols;
                this.mines = mines;
                this.board = [];
                this.gameState = 'ready'; // ready, playing, won, lost
                this.minesLocations = [];
                this.revealedCells = 0;
                this.flags = 0;
                this.timer = 0;
                this.timerInterval = null;;
                
                this.initDOM();
                this.initGame();
            }
            
            initDOM() {
                this.boardElement = document.getElementById('board');
                this.minesCounterElement = document.getElementById('mines-counter');
                this.timerElement = document.getElementById('timer');
                this.gameStatusElement = document.getElementById('game-status');
                this.restartBtn = document.getElementById('restart-btn');
                
                this.restartBtn.addEventListener('click', () =&gt; this.restartGame());
                
                // 难度选择按钮
                document.querySelectorAll('.difficulty-btn').forEach(btn =&gt; {
                    btn.addEventListener('click', () =&gt; {
                        const level = btn.dataset.level;
                        this.setDifficulty(level);
                    });
                });
            }
            
            setDifficulty(level) {
                clearInterval(this.timerInterval);
                
                switch(level) {
                    case 'easy':
                        this.rows = 9;
                        this.cols = 9;
                        this.mines = 10;
                        break;
                    case 'medium':
                        this.rows = 16;
                        this.cols = 16;
                        this.mines = 40;
                        break;
                    case 'hard':
                        this.rows = 16;
                        this.cols = 30;
                        this.mines = 99;
                        break;
                }
                
                this.initGame();
            }
            
            initGame() {
                this.gameState = 'ready';
                this.board = [];
                this.minesLocations = [];
                this.revealedCells = 0;
                this.flags = 0;
                this.timer = 0;
                
                this.updateMinesCounter();
                this.updateTimer();
                this.gameStatusElement.textContent = '';
                this.restartBtn.textContent = '🙂';
                
                this.createBoard();
                this.renderBoard();
            }
            
            createBoard() {
                // 初始化棋盘
                for (let r = 0; r &lt; this.rows; r++) {
                    this.board[r] = [];
                    for (let c = 0; c &lt; this.cols; c++) {
                        this.board[r][c] = {
                            isMine: false,
                            isRevealed: false,
                            isFlagged: false,
                            neighborMines: 0
                        };
                    }
                }
                
                // 随机放置地雷
                let minesPlaced = 0;
                while (minesPlaced &lt; this.mines) {
                    const row = Math.floor(Math.random() * this.rows);
                    const col = Math.floor(Math.random() * this.cols);
                    
                    if (!this.board[row][col].isMine) {
                        this.board[row][col].isMine = true;
                        this.minesLocations.push({row, col});
                        minesPlaced++;
                    }
                }
                
                // 计算每个格子周围的地雷数
                for (let r = 0; r &lt; this.rows; r++) {
                    for (let c = 0; c &lt; this.cols; c++) {
                        if (!this.board[r][c].isMine) {
                            this.board[r][c].neighborMines = this.countNeighborMines(r, c);
                        }
                    }
                }
            }
            
            countNeighborMines(row, col) {
                let count = 0;
                for (let r = Math.max(0, row-1); r &lt;= Math.min(this.rows-1, row+1); r++) {
                    for (let c = Math.max(0, col-1); c &lt;= Math.min(this.cols-1, col+1); c++) {
                        if (this.board[r][c].isMine) {
                            count++;
                        }
                    }
                }
                return count;
            }
            
            renderBoard() {
                this.boardElement.innerHTML = '';
                this.boardElement.style.gridTemplateColumns = `repeat(${this.cols}, 30px)`;
                this.boardElement.style.gridTemplateRows = `repeat(${this.rows}, 30px)`;
                
                for (let r = 0; r &lt; this.rows; r++) {
                    for (let c = 0; c &lt; this.cols; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        
                        if (this.board[r][c].isRevealed) {
                            cell.classList.add('revealed');
                            
                            if (this.board[r][c].isMine) {
                                cell.classList.add('mine');
                                cell.textContent = '💣';
                            } else if (this.board[r][c].neighborMines &gt; 0) {
                                cell.textContent = this.board[r][c].neighborMines;
                                cell.dataset.count = this.board[r][c].neighborMines;
                            }
                        }
                        
                        if (this.board[r][c].isFlagged) {
                            cell.classList.add('flagged');
                            cell.textContent = '🚩';
                        }
                        
                        // 添加事件监听器
                        cell.addEventListener('click', (e) =&gt; this.handleCellClick(r, c));
                        cell.addEventListener('contextmenu', (e) =&gt; {
                            e.preventDefault();
                            this.handleRightClick(r, c);
                        });
                        
                        this.boardElement.appendChild(cell);
                    }
                }
            }
            
            handleCellClick(row, col) {
                if (this.gameState === 'won' || this.gameState === 'lost') {
                    return;
                }
                
                const cell = this.board[row][col];
                
                // 如果是已标记的格子，不做任何操作
                if (cell.isFlagged) {
                    return;
                }
                
                // 第一次点击时开始计时
                if (this.gameState === 'ready') {
                    this.gameState = 'playing';
                    this.startTimer();
                }
                
                // 点击到地雷
                if (cell.isMine) {
                    this.gameOver(false);
                    return;
                }
                
                // 翻开格子
                this.revealCell(row, col);
                
                // 检查是否获胜
                if (this.checkWin()) {
                    this.gameOver(true);
                }
                
                this.renderBoard();
            }
            
            handleRightClick(row, col) {
                if (this.gameState === 'won' || this.gameState === 'lost') {
                    return;
                }
                
                const cell = this.board[row][col];
                
                // 如果已经翻开，不能标记
                if (cell.isRevealed) {
                    return;
                }
                
                // 切换标记状态
                cell.isFlagged = !cell.isFlagged;
                this.flags += cell.isFlagged ? 1 : -1;
                
                this.updateMinesCounter();
                this.renderBoard();
            }
            
            revealCell(row, col) {
                const cell = this.board[row][col];
                
                // 如果已经翻开或标记，不做任何操作
                if (cell.isRevealed || cell.isFlagged) {
                    return;
                }
                
                // 翻开当前格子
                cell.isRevealed = true;
                this.revealedCells++;
                
                // 如果当前格子周围没有地雷，自动翻开相邻的格子
                if (cell.neighborMines === 0) {
                    for (let r = Math.max(0, row-1); r &lt;= Math.min(this.rows-1, row+1); r++) {
                        for (let c = Math.max(0, col-1); c &lt;= Math.min(this.cols-1, col+1); c++) {
                            if (r !== row || c !== col) {
                                this.revealCell(r, c);
                            }
                        }
                    }
                }
            }
            
            checkWin() {
                const totalCells = this.rows * this.cols;
                return this.revealedCells === totalCells - this.mines;
            }
            
            gameOver(isWin) {
                this.gameState = isWin ? 'won' : 'lost';
                clearInterval(this.timerInterval);
                
                if (isWin) {
                    this.gameStatusElement.textContent = '恭喜你赢了！';
                    this.restartBtn.textContent = '😎';
                } else {
                    this.gameStatusElement.textContent = '游戏结束！';
                    this.restartBtn.textContent = '😵';
                    
                    // 显示所有地雷
                    for (const mine of this.minesLocations) {
                        this.board[mine.row][mine.col].isRevealed = true;
                    }
                }
                
                this.renderBoard();
            }
            
            startTimer() {
                this.timerInterval = setInterval(() =&gt; {
                    this.timer++;
                    this.updateTimer();
                }, 1000);
            }
            
            updateMinesCounter() {
                const remaining = this.mines - this.flags;
                this.minesCounterElement.textContent = remaining.toString().padStart(3, '0');
            }
            
            updateTimer() {
                this.timerElement.textContent = this.timer.toString().padStart(3, '0');
            }
            
            restartGame() {
                clearInterval(this.timerInterval);
                this.initGame();
            }
        }
        
        // 初始化游戏
        const game = new MinesweeperGame(9, 9, 10);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
功能说明
这个扫雷游戏实现了以下功能：
三种难度级别：
简单：9×9网格，10个地雷
中等：16×16网格，40个地雷
困难：16×30网格，99个地雷
游戏机制：
左键点击翻开格子
右键点击标记旗帜/取消标记
自动展开空白区域（周围没有地雷的区域）
显示剩余地雷数量和游戏时间
游戏状态：
游戏进行中
获胜（翻开所有非地雷格子）
失败（点击到地雷）
用户界面：
经典扫雷游戏界面风格
笑脸按钮重新开始游戏
难度选择按钮
使用说明
点击"简单"、"中等"或"困难"按钮选择难度级别
左键点击格子翻开它
右键点击格子标记旗帜（表示你认为那里有地雷）
再次右键点击可以取消标记
点击笑脸按钮重新开始游戏
这个实现包含了扫雷游戏的所有核心功能，你可以直接复制代码到HTML文件中运行。</code></pre><p>完全满足需求。但缺少经典的 “左右键同时按空白格子自动展开相邻已标记旗帜区域” 功能。</p><h3>视频：识别游戏</h3><p><strong>输入</strong></p><p>这是测试的视频地址：<code>https://mpvideo.qpic.cn/0bc3a4afwaaa7yapvaqwqzuvab6dlmdqawya.f10002.mp4?dis_k=b3b4ff4eb827c0610629accc1d410f06&amp;dis_t=1763091378&amp;play_scene=10120&amp;auth_info=drHunsApdxYU0o390Ep3fWxFQ2wKe2BiT05+ME9jeDRMfmIaKCAqeXYfDE8mbmBHZg==&amp;auth_key=03aebda2353addffb0ccad69c4a44bc8&amp;vid=wxv_4253001887022415880&amp;format_id=10002&amp;support_redirect=0&amp;mmversion=false</code></p><pre><code>告诉我这个是什么游戏？</code></pre><p><strong>输出</strong></p><pre><code>这是《集合啦！动物森友会》（Animal Crossing: New Horizons），一款由任天堂开发的模拟经营游戏。
画面中的元素（如可爱的卡通角色、夜晚的村庄场景、紫藤花架、流星、界面左下角的时间/日期显示）都是该游戏的典型特征。游戏中玩家可以经营自己的岛屿，与动物村民互动，装饰家园，体验慢节奏的田园生活。</code></pre><p>游戏被正确识别出来。</p><h2>个人感受</h2><p>评测下来，文心5.0给我最大的感受，是它生成的<strong>内容更完整、细节更丰富，叙事连贯性和人类风格提升明显</strong>。</p><p>文心5.0的“暴力美学”（2.4万亿参数）并不是为了“炫技”，它更像是一个必要的地基——<strong>一个足以“重新定义”原生全模态的、坚实的地基</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399264" alt="" title="" loading="lazy"/></p><p>正是这个地基，让“原生全模态”得以实现，让我们在评测中看到了AI真正从“识别”走向了“理解”。</p><p>我非常期待看到，当“原生全模态”的强大能力交到开发者手中时，会催生出怎样超乎想象的新应用。</p>]]></description></item>  </channel></rss>