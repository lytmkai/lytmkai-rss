<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[隐语——数据要素流通技术MOOC三期 课]]></title>    <link>https://segmentfault.com/a/1190000047440236</link>    <guid>https://segmentfault.com/a/1190000047440236</guid>    <pubDate>2025-12-01 14:13:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><p>课程地址：<a href="https://link.segmentfault.com/?enc=0jK4i8ZDkZi1an%2F4TZsjeg%3D%3D.L97bzJKmKpxgtYGi6AshK9BC67%2BIcgDU7KWiuslMlDM1dCnJQNI%2F1NqCH2AQIdv9jpg3UR5SlbhIVfXy4mmHJSsu%2BwxMjnd5whYkec45DYUPUzbHe%2FkVPXPUPZVCOlKY6Jul5CcDblJ0rihZLjqttw%3D%3D" rel="nofollow" target="_blank">https://www.secretflow.org.cn/community/bootcamp/2narwgw4ub8r...</a></p><p><strong>讲师</strong>：贾明阳（蚂蚁密算科技）  <br/><strong>核心框架</strong>：背景知识 → 连接器功能 → 技术架构</p></blockquote><h2>一、背景知识：可信数据空间与国家数据基础设施</h2><h3>1. 国家数据基础设施核心节点</h3><table><thead><tr><th>节点类型</th><th>核心定位</th><th>关键功能</th></tr></thead><tbody><tr><td>权域功能节点</td><td>全局统一管理</td><td>统一标识管理、统一身份管理、统一目录管理（三统一）</td></tr><tr><td>区域功能节点</td><td>特定区域服务</td><td>身份注册/核验、数据登记、目录查询、标识解析、运行监测</td></tr><tr><td>行业功能节点</td><td>特定行业服务</td><td>与区域功能节点功能一致，仅服务范围为特定行业</td></tr><tr><td>业务节点</td><td>数据流通利用平台</td><td>数据采集、加工、交易、开发等，是可信数据空间的核心载体</td></tr></tbody></table><h3>2. 可信数据空间的定位与组成</h3><ul><li><strong>核心定位</strong>：作为国家数据基础设施的<strong>业务节点</strong>，实现跨区域/行业的数据可信流通。</li><li><p><strong>两大核心组件</strong>：</p><ol><li><p><strong>可信数据空间服务平台</strong>：</p><ul><li>遵循“三统一”要求，与权域/区域/行业功能节点互联互通。</li><li>可复用其他业务节点功能（交易、托管、存证审计等），支持功能扩展。</li><li>对接关系：向上→行业/区域功能节点；横向→其他业务节点；向下→接入连接器。</li></ul></li><li><p><strong>接入连接器</strong>：</p><ul><li>核心定位：用户（数据提供方/使用方）接入服务平台的入口，访问数据资源的桥梁。</li><li>合规要求：遵循NDITR相关文件，在国家数据基础设施接入连接器基础上扩展5大独有功能。</li></ul></li></ol></li></ul><h2>二、接入连接器的核心功能（六大模块）</h2><h3>1. 身份管理</h3><ul><li><strong>核心目标</strong>：实现连接器与节点、连接器之间的可信身份认证。</li><li><p>关键子功能：</p><ul><li>用户身份管理：用户名/密码登录、用户CRUD、角色权限配置。</li><li>连接器身份注册：向功能节点申请→审批→分配ID→生成CSR文件→获取CA证书→配置到连接器。</li><li><p>双向认证流程：</p><ul><li>连接器↔功能节点：连接器发送身份标识+私钥签名→功能节点通过CA验证→功能节点返回自身证书→连接器验证。</li><li>连接器↔连接器：A发送证书+签名→B通过CA验证证书合法性→B用A的公钥验签→双方互验完成。</li></ul></li></ul></li></ul><h3>2. 数据资源管理</h3><ul><li><strong>数据资源定义</strong>：具有利用价值的电子化数据集合（可社会化复用）。</li><li><p>关键子功能：</p><ul><li>数据资源接入：支持对象存储（S3、MinIO）、数据库、本地文件、SFTP等多数据源。</li><li>资源管理：本地数据资源的CRUD操作。</li><li>资源目录：按NDI标准生成目录，支持本地检索查询。</li></ul></li><li><p><strong>特色功能：密带托管</strong>：</p><ol><li>数据提供方将数据加密封装为“数据胶囊”；</li><li>托管至马尔米算密带研发平台；</li><li>平台内加工为数据产品并上架；</li><li>数据使用方通过合约申请使用。</li></ol></li></ul><h3>3. 数据产品管理</h3><ul><li><strong>数据产品定义</strong>：经实质性加工的可流通数据加工品/服务（如数据表、API、文件），是数据流通的基本单元。</li><li><p>关键子功能：</p><ul><li>产品封装：将数据资源加工为标准化数据产品。</li><li>产品上架：上传至服务平台→平台代理完成行业/区域节点登记→获取唯一标识。</li><li>产品目录：维护本地产品目录，支持检索与使用申请。</li></ul></li><li><strong>核心流程</strong>：数据资源→加工封装→上架平台→使用方查询→申请使用→合约签署→数据交付。</li></ul><h3>4. 数字合约管理</h3><ul><li><strong>数字合约定义</strong>：数字化描述的参与方承诺（含数据内容、使用方式、次数、范围等）。</li><li><p>关键子功能：</p><ol><li>合约创建：使用方发起申请→服务平台生成合约模板→下发至双方连接器。</li><li>合约协商：双方确认合约内容→达成一致后用本地私钥签名。</li><li>合约履约：按合约约定完成数据交付与使用。</li></ol></li><li><strong>生效条件</strong>：双方私钥签名完成→上报服务平台→平台下发生效合约→连接器验证签名合法性。</li></ul><h3>5. 数据交付</h3><ul><li>核心目标：按合约要求安全交付数据/计算结果。</li><li><p>关键子功能：</p><ul><li>交付数据处理：加密、脱敏、隐私保护计算（MPC）、数据沙箱等预处理。</li><li>数据传输：支持连接器间直接传输。</li><li>交付存证：记录处理/传输日志→上报服务平台存证审计系统，支持本地查验。</li></ul></li><li><p><strong>支持交付方式</strong>：</p><ol><li>密带API交付；</li><li>数据集直接交付；</li><li>隐私计算交付（基于SecretFlow、PSI等开源算子，支持多方安全计算）。</li></ol></li></ul><h3>6. 使用控制</h3><ul><li><strong>核心目标</strong>：确保数据使用符合合约约定（时间、地点、主体、行为等）。</li><li><p>关键实现：</p><ul><li>使用环境：提供安全软硬件环境。</li><li>控制策略：实时监测使用行为→校验合约限制（如使用期限、次数）→超出限制则终止使用。</li></ul></li><li><strong>核心逻辑</strong>：连接器从平台获取合约→交付过程中记录使用日志→实时校验合约约束→上报使用状态。</li></ul><h2>三、连接器技术架构（马尔米算实现）</h2><h3>1. 整体架构概述</h3><ul><li>架构模式：B/S架构，支持部署于K8s或轻量化K3s（70MB，便捷部署）。</li><li><p>核心交互：</p><ul><li>向上对接：可信数据空间服务平台、行业/区域功能节点。</li><li>横向交互：连接器之间通过Interguitave模块实现跨连接器请求转发与身份验证。</li><li>向下支撑：对接数据源（提供方）与数据使用方，拉起隐私计算等执行引擎。</li></ul></li></ul><h3>2. 核心模块职责（分层分类）</h3><table><thead><tr><th>分层/类别</th><th>模块名称</th><th>核心职责</th></tr></thead><tbody><tr><td>前端交互层</td><td>Web UI</td><td>浏览器端交互界面，支持点击/拖拉拽操作（如Dag画布编排）</td></tr><tr><td>网关层</td><td>API Gateway</td><td>接收HTTP请求→权限校验→请求转发→支持限流、熔断、链路追踪（Trace）</td></tr><tr><td>核心服务层</td><td>Connector Service</td><td>连接器登记、初始化、产品CRUD</td></tr><tr><td> </td><td>Contract Service</td><td>合约拉取、展示、签署（本地私钥签名）</td></tr><tr><td> </td><td>Dag Canvas</td><td>可视化任务流编排（拖拉拽算子，支持数据预处理、模型训练等）</td></tr><tr><td> </td><td>Project Service</td><td>项目管理（工作区Workspace），绑定合约、项目CRUD</td></tr><tr><td> </td><td>Contract Delivery</td><td>合约交付状态记录、上报服务平台</td></tr><tr><td>调度层</td><td>Scheduler</td><td>任务调度：将Dag画布转换为Task→按依赖关系执行</td></tr><tr><td> </td><td>CulTask</td><td>多方安全计算（MPC）协同调度，确保多方节点同步拉起任务</td></tr><tr><td>数据层</td><td>Data Site</td><td>数据资源CRUD、数据源接入、数据加密/处理</td></tr><tr><td> </td><td>Delocation Tool</td><td>数据封装为密带胶囊→托管至密带基础引擎</td></tr><tr><td>安全与审计层</td><td>Interguitave</td><td>跨连接器请求转发、身份认证握手、Token协商与验证</td></tr><tr><td> </td><td>Log Module</td><td>记录交付日志、操作日志</td></tr><tr><td> </td><td>Audit Module</td><td>日志上报、审计功能支持</td></tr><tr><td> </td><td>User Service</td><td>隐私计算用户管理（登录、角色权限、CRUD）</td></tr><tr><td>执行层</td><td>Executor Agent</td><td>执行任务代理，拉起隐私计算引擎（SecretFlow、PSI等算子）</td></tr><tr><td>部署层</td><td>K8s/K3s底座</td><td>部署载体，支持轻量化K3s快速部署</td></tr></tbody></table><h2>四、核心总结</h2><ol><li><strong>定位</strong>：接入连接器是可信数据空间的“入口枢纽”，连接数据提供方/使用方与服务平台，实现可信接入与数据流通。</li><li><strong>核心价值</strong>：合规（遵循NDITR标准）、安全（身份认证、加密、隐私计算）、灵活（多数据源接入、多交付方式）。</li><li><strong>技术亮点</strong>：支持隐私计算集成、轻量化部署、可视化任务编排、全流程日志存证。</li></ol>]]></description></item><item>    <title><![CDATA[隐语——数据要素流通技术MOOC三期 课]]></title>    <link>https://segmentfault.com/a/1190000047440242</link>    <guid>https://segmentfault.com/a/1190000047440242</guid>    <pubDate>2025-12-01 14:12:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>课程地址：<a href="https://link.segmentfault.com/?enc=SicNBim3ig%2F%2F1xwtXAeOrg%3D%3D.X75m1hKcK05HonRA05Ca2X9Vo%2Bet3ciYfXbeKNFRrd4LF55JE1gDU6e8kVQx%2FPvSUBDtd2lQKEx7UKpuAbwkaYyJb7nEubGrxTD8F8vGtURxBRZuZ5dlsjlukteZstSdMx0oWrpkscpm7bwIEIF9ng%3D%3D" rel="nofollow" target="_blank">https://www.secretflow.org.cn/community/bootcamp/2narwgw4ub8r...</a></blockquote><h2>一、课程核心框架</h2><ol><li>需求分析：数据要素流通的信任痛点</li><li>核心原理：远程证明的技术本质与信任链构建</li><li>标准与实现：ITS框架与星绽方案落地</li><li>实践案例：跨域管控的数据安全流通</li><li>未来展望：跨云统一证明与密算网络</li></ol><h2>二、引言：数据流通的信任核心问题</h2><h3>1. 数据的价值与安全矛盾</h3><ul><li>数据是数字经济核心生产要素，安全流通是价值释放的关键</li><li>数据跨实体传递时脱离原控制范围，需解决"可用不可见"的安全保障</li></ul><h3>2. 机密计算与远程证明的协同作用</h3><table><thead><tr><th>技术</th><th>核心功能</th><th>定位</th></tr></thead><tbody><tr><td>机密计算</td><td>创建可信执行环境（TEE），硬件隔离保护数据</td><td>提供数据安全使用保障</td></tr><tr><td>远程证明</td><td>验证连接对象是否为真实可信环境</td><td>确认保障的真实性</td></tr></tbody></table><ul><li>协同目标：实现"模糊信任→可验证信任"的转变</li></ul><h2>三、远程证明核心原理</h2><h3>1. 信任的起点：硬件根信任</h3><ul><li>信任基石：CPU/TPM中的<strong>熔断密钥</strong>（芯片出厂预置，不可导出）</li><li>信任链构建：通过权威机构（CA）的数字签名背书，形成"芯片固件→TEE→应用程序"的完整验证链条</li></ul><h3>2. 远程证明核心流程与角色</h3><h4>（1）核心角色</h4><ul><li>验证方：远程证明服务器</li><li>T节点：具备可信执行环境的硬件（如SGX、TPM、TDX等）</li><li>CA服务：权威认证机构，验证证书链有效性</li></ul><h4>（2）执行步骤</h4><ol><li>验证方向T节点发送随机制串（LUNS）</li><li>T节点生成度量环境报告，提交至可信硬件获取签名（Code）</li><li>T节点将报告发送至验证方</li><li>验证方调用CA验证证书链有效性，提取公钥验证报告签名</li><li>确认T节点为可信环境后完成授权</li></ol><h3>3. 分层架构模型</h3><table><thead><tr><th>层级</th><th>核心功能</th><th>关键标准/组件</th></tr></thead><tbody><tr><td>硬件层</td><td>生成原始度量报告</td><td>TPM、可信硬件芯片</td></tr><tr><td>协议层</td><td>定义标准化报告格式</td><td>ITS（国际标准框架）</td></tr><tr><td>云端服务层</td><td>报告处理与验证</td><td>远程证明服务器</td></tr><tr><td>应用层</td><td>消费验证结果，决策权限控制</td><td>SDK、业务系统</td></tr></tbody></table><h2>四、标准框架：ITS（International Trusted Computing）</h2><h3>1. 核心目标</h3><ul><li>打破技术隔阂，实现不同厂商TEE（Intel、AMD、华为等）的互操作</li><li>统一验证流程，整合零散方法为通用框架</li><li>为设备颁发"可信身份证"，解决"设备身份认证"问题</li></ul><h3>2. 三大核心角色</h3><table><thead><tr><th>角色</th><th>英文标识</th><th>核心职责</th></tr></thead><tbody><tr><td>证明者</td><td>Attester</td><td>在待验证设备上生成硬件级不可篡改报告（Report）</td></tr><tr><td>验证者</td><td>Verifier</td><td>验证报告真实性，签发标准化"健康证书"（EAT令牌）</td></tr><tr><td>业务系统</td><td>Relying Party</td><td>基于EAT令牌决策是否执行敏感操作</td></tr></tbody></table><h3>3. 落地基础设施要求</h3><ul><li>机密计算：提供安全可靠的TEE执行环境</li><li>信任底座：硬件级可信根（如TPM），保障信任链起点的可靠性</li></ul><h2>五、星绽方案实现：机密计算与远程证明服务</h2><h3>1. 星绽机密计算整体架构</h3><ul><li>自主研发数据保护方案，具备独立知识产权</li><li>核心价值：弥补国产CPU安全短板，降低使用成本，支持大规模复杂数据流转</li><li><p>三层架构：</p><ol><li>安全底座：底层安全虚拟化</li><li>安全操作系统：TE操作系统（自研）</li><li>可信技术设施：云原生TEE能力提供层</li></ol></li></ul><h3>2. 可信技术设施关键特性</h3><ul><li>云原生管理：结合机密虚拟机/容器，通过K8s统一管理TEE应用生命周期</li><li>信任链延伸：TE操作系统度量应用启动过程，将信任链从平台层扩展至应用层</li><li><p>核心服务双支柱：</p><table><thead><tr><th>服务名称</th><th>核心功能</th></tr></thead><tbody><tr><td>远程证明服务</td><td>验证TEE应用可信度，颁发可信身份</td></tr><tr><td>密钥管理服务</td><td>基于可信身份执行密钥授权策略，仅授权应用可获取密钥</td></tr></tbody></table></li></ul><h3>3. 信任链全流程实现（从硬件到应用）</h3><ol><li>TPM硬件可信根为起点，操作系统启动时将组件度量值写入TPM的PCR寄存器</li><li>加载驱动模块与虚拟化组件（Hypervisor），度量值同步写入PCR</li><li>Hypervisor启动后降级为非特权模式，作为机密虚拟机可信根，构建虚拟机启动链（内核、迷你行组件）</li><li>系统分区通过Device Mapper加密保护，根哈希由内核迷你行保障</li><li>应用容器启动时，通过MA机制完成完整性度量、审计与安全评估</li><li>容器通过远程证明验证平台可信度，信任链最终传递至应用层</li></ol><h2>六、星绽远程证明服务设计</h2><h3>1. 架构分层（微服务架构）</h3><table><thead><tr><th>层级</th><th>核心设计与功能</th></tr></thead><tbody><tr><td>核心层</td><td>动态插件化设计，兼容多TEE（HyperGlyph、Intel TDX、未来支持GPU认证），支持新增TEE插件</td></tr><tr><td>服务层</td><td>1. 基线策略管理：管理主机/平台/应用的认证基线，支持多版本；<br/>2. 身份管理：细粒度权限控制、审计追踪，统一EAT ID标识；<br/>3. 身份签发：基于硬件衍生密钥签发Token；<br/>4. 可信审计：记录运行日志与度量结果</td></tr><tr><td>接口层</td><td>提供基线注册、审计日志查询接口，支持组织/平台/应用三类证明者角色</td></tr></tbody></table><h3>2. 应用可信身份获取与验证流程</h3><h4>（1）身份获取步骤</h4><ol><li>应用A启动，通过Attesting Agent代理发起<strong>平台身份请求</strong>（采集平台度量值）</li><li>远程证明服务器验证平台报告，颁发JWT令牌（含公钥，由服务器报告担保防中间人攻击）</li><li>Attesting Agent缓存公钥，发起<strong>应用身份请求</strong>（报告含平台+应用度量值，平台报告担保应用报告）</li><li>服务器验证双报告与基线比对，颁发应用级JWT令牌，返回至应用A</li></ol><h4>（2）跨应用身份验证</h4><ol><li>应用A将业务数据+JWT令牌发送至应用B</li><li>应用B通过自身Attesting Agent调用验证接口，利用缓存的平台公钥验证JWT签名合法性</li><li>验证通过则执行敏感操作，失败则拒绝访问（抵御仿冒身份攻击）</li></ol><h2>七、实践案例：跨域管控的数据安全流通</h2><h3>1. 核心目标</h3><ul><li>确保密算平台环境可验证，数据/密钥在流通中全程受保护</li><li>抵御管理员及高特权软件的恶意攻击</li></ul><h3>2. 关键实现路径</h3><ol><li>硬件保障：可信硬件（TPM）保障平台可信启动</li><li>环境隔离：TEE保护数据计算过程的完整性与机密性</li><li>身份验证：远程证明服务验证平台/应用可信身份</li><li><p>加密传输：</p><ul><li>用户通过远程认证报告验证数字信封公钥合法性</li><li>对称密钥加密数据，公钥加密对称密钥，传输至密算平台</li><li>平台用私钥解密对称密钥，最终解密数据并处理</li></ul></li></ol><h2>八、未来展望：跨云统一证明与密算网络</h2><h3>1. 现存挑战</h3><ul><li>多云环境存在"信任孤岛"：各云平台安全策略、信任体系独立</li><li>密算资源稀缺、成本高、使用门槛高</li></ul><h3>2. 解决方案：跨云统一证明框架</h3><ul><li>标准化协议与抽象中间层：实现不同TEE架构的协议翻译</li><li>监管支持：区块链存证技术确保运行记录/验证结果不可篡改，提供实时监管接口</li><li>核心价值：打破厂商适配壁垒（如医院跨机构获取数据无需单独适配）</li></ul><h3>3. 终极目标：密算天空计算网络</h3><ul><li>低成本转化：将各类计算资源转化为密算节点</li><li>统一信任：通过跨云统一证明实现节点间互信、互联、互通</li><li>价值释放：工作负载跨云协作与平滑迁移，数据像自来水一样"即开即用"</li></ul><h2>九、核心术语与关键技术</h2><table><thead><tr><th>术语</th><th>英文全称</th><th>核心定义</th></tr></thead><tbody><tr><td>TEE</td><td>Trusted Execution Environment</td><td>可信执行环境，硬件隔离的安全区域，保障数据"可用不可见"</td></tr><tr><td>TPM</td><td>Trusted Platform Module</td><td>可信平台模块，存储熔断密钥与度量值（PCR），信任链起点</td></tr><tr><td>PCR</td><td>Platform Configuration Register</td><td>平台配置寄存器，记录启动组件与运行环境的度量值</td></tr><tr><td>Hypervisor</td><td>-</td><td>虚拟化管理程序，星绽方案中作为机密虚拟机的可信根</td></tr><tr><td>EAT</td><td>Entity Attestation Token</td><td>实体证明令牌，ITS框架下的标准化"健康证书"</td></tr><tr><td>JWT</td><td>JSON Web Token</td><td>用于应用身份传递的无证书令牌，通过硬件衍生密钥签名</td></tr><tr><td>Attesting Agent</td><td>-</td><td>证明代理，负责采集度量值、转发身份请求与验证结果</td></tr></tbody></table>]]></description></item><item>    <title><![CDATA[ICLR 2025 | 中科院+哈工大重]]></title>    <link>https://segmentfault.com/a/1190000047440587</link>    <guid>https://segmentfault.com/a/1190000047440587</guid>    <pubDate>2025-12-01 14:11:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>ICLR 2025 | 中科院+哈工大重磅发现：预训练视觉模型分类越准，可解释性越强</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440590" alt=" " title=" "/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440591" alt=" " title=" " loading="lazy"/></p><p>论文标题：<em>Enhancing Pre-trained Representation Classifiability can Boost its Interpretability</em></p><p>作者团队：中国科学院、哈尔滨工业大学、鹏城实验室、华为</p><p>发布时间：2025年10月28日</p><p><a href="https://link.segmentfault.com/?enc=8T8GD090kLae%2FjIB2w761w%3D%3D.w1iyJ0XkmmCV45ZbUPrYnBUIiAWRYkTZm2PpIZZykkIGJEbfpyZs8kOc06Vgl%2Bwo" rel="nofollow" target="_blank">👉一键直达论文</a></p><p><a href="https://link.segmentfault.com/?enc=YLntlXIdvcsNhI2JdsYduw%3D%3D.l1T%2BRDoA9hzquU1seJKRxChBJaBJeleNR83YRb4z1U%2FIWcPnjvmRhtC8nnEDNRA5LjDn93ooUoSEGK5lWUFEE9exwrLlpOV%2B3axZEKV60BximBCcB06Wxvhqnnogow93gVKGgSCoO1QtbG2NQ68GIfBM3NWmc1qx%2B%2BcVqeCEabI%3D" rel="nofollow" target="_blank">👉Lab4AI大模型实验室论文阅读</a></p><p>✅Lab4AI平台提供AI导读和AI翻译等工具，辅助论文阅读。您还可以投稿复现这篇论文~</p><h3>⭐研究背景</h3><p>当前预训练视觉模型在分类任务上表现优异，但其表示的可解释性常被忽视。传统观点认为可解释性与分类性能存在冲突，尤其在设计可解释模型时分类性能往往下降。</p><h3>⭐研究目的</h3><p>本文旨在探究分类导向的预训练表示是否能够同时实现高分类性能和高可解释性，并量化表示的可解释性，揭示其与分类性能之间的内在关系。</p><h3>⭐研究框架</h3><p>提出“内在可解释性评分（IIS）”，通过将表示投影到概念空间并引入稀疏化机制，衡量其在解释过程中保留任务相关语义的能力。IIS定义为不同稀疏度下解释预测准确率与原始表示准确率之比的平均值。</p><h3>⭐研究结果</h3><p>实验发现，IIS与分类准确率呈正相关，即分类性能越高的表示越易于解释。进一步地，通过最大化IIS微调模型可提升其分类性能，同时基于解释的预测也能达到接近原始模型的准确率，实现可解释性与分类性能的协同提升。</p>]]></description></item><item>    <title><![CDATA[为什么没有免费的代码签名证书 冷冷的炒面]]></title>    <link>https://segmentfault.com/a/1190000047440672</link>    <guid>https://segmentfault.com/a/1190000047440672</guid>    <pubDate>2025-12-01 14:10:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h4><strong>一、什么是代码签名证书？</strong></h4><p>简单来说，代码签名证书就像是软件的“数字身份证”和“安全封条”。</p><p>当开发者发布一个软件（比如.exe或.msi安装包）时，可以用这个证书对它进行“签名”。签名后：</p><ul><li><strong>用户看到</strong>：系统会明确显示这个软件来自“XX公司”，而不是一个“未知发布者”。</li><li><strong>系统信任</strong>：操作系统（如Windows）会认为这个软件来源可信，减少或不再弹出安全警告。</li><li><strong>保证完整性</strong>：它证明软件在签名后没有被病毒或黑客篡改过。</li></ul><p>如果没有这个签名，你的软件在用户电脑上可能会被系统安全机制直接拦截，看起来非常不可靠。<br/><img width="625" height="337" referrerpolicy="no-referrer" src="/img/bVdkwhd" alt="" title=""/></p><h4><strong>二、核心原因：信任的“看门人”不好当</strong></h4><p>免费SSL证书的成功，让很多人期待代码签名证书也能免费。但它们两者承担的责任完全不同。</p><ol><li><p><strong>验证力度不同</strong></p><ul><li><strong>免费SSL证书</strong>：通常只做“域名验证”（DV）。它只证明“你确实控制着这个域名”，不关心你是谁。这个过程可以自动化，成本极低。</li><li><strong>代码签名证书</strong>：需要进行“组织验证”（OV）或“扩展验证”（EV）。证书颁发机构（CA）需要人工核实申请公司的真实存在性、合法性和物理地址。这个过程耗时、费力，无法完全自动化，因此成本高昂。</li></ul></li><li><p><strong>风险与责任的天壤之别</strong></p><ul><li><strong>SSL证书风险</strong>：如果一个免费SSL证书被滥用，通常影响的是一個网站的通訊安全。</li><li><strong>代码签名证书风险</strong>：这是<strong>最高级别的风险</strong>。如果一个恶意软件被成功签上了“可信”的签名，它就能在用户的电脑上畅通无阻地运行。这相当于坏人拿到了警察局的官方印章，可以造成大面积的病毒传播、数据窃取等严重安全事故。证书颁发机构（CA）必须为它们发出的每一个签名证书的“可信度”背书。</li></ul></li></ol><h4><strong>三、为什么不能像SSL证书那样免费？</strong></h4><p>想象一下，如果代码签名证书也免费且无需严格审核，会发生什么：</p><ul><li><strong>恶意软件的天堂</strong>：黑客可以轻易地伪造身份，免费获取证书，为他们开发的病毒、木马签上“合法”的名字。</li><li><strong>信任体系崩溃</strong>：用户和操作系统将无法再相信任何软件的签名。整个代码签名的安全基石将彻底瓦解。</li><li><strong>CA机构无法承担的责任</strong>：一旦因为其免费证书导致大规模安全事件，CA机构将面临巨大的法律诉讼和赔偿风险，这足以让一家公司破产。</li></ul><p><strong>因此，严格的审核和收费，正是为了抬高滥用的门槛，确保这个“数字身份证”发放过程的严肃性和安全性。</strong></p><h4><strong>总结</strong></h4><p><strong>代码签名证书之所以不免费，是因为它守护的是软件分发的“最后一道信任关口”。</strong></p><p>这份信任非常沉重，需要证书颁发机构投入大量的人力物力进行审核，并承担巨大的安全与法律责任。收费，不仅是CA机构的商业模式，更是维护整个软件生态安全不可或缺的屏障。</p><p>所以，当你需要为你的软件购买代码签名证书时，请把它看作是一项必要的、对用户安全负责的投资，而不是一个可以节省的成本。</p>]]></description></item><item>    <title><![CDATA[代码签名证书：软件开发必备？ 傻傻的开心]]></title>    <link>https://segmentfault.com/a/1190000047440680</link>    <guid>https://segmentfault.com/a/1190000047440680</guid>    <pubDate>2025-12-01 14:09:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>选择代码签名证书时，需从证书类型、颁发机构、安全需求、兼容性、成本效益和技术支持六方面综合考量，以下是具体指南：</p><p><strong>一、明确需求：根据场景选证书类型</strong></p><p><strong>标准代码签名证书</strong></p><p><strong>适用场景：</strong> 常规软件发布（如Windows应用、Java小程序）。</p><p><strong>特点：</strong> 验证开发者身份，确保软件完整性，但可能触发SmartScreen过滤器警告（需积累信誉）。</p><p>EV代码签名证书</p><p>适用场景：高频更新软件（如杀毒软件、游戏客户端）、需即时信誉度的场景。</p><p><strong>优势：</strong></p><p>绕过SmartScreen过滤器，用户安装时无警告。</p><p>支持Windows硬件驱动签名（符合WHQL要求）。</p><p>证书私钥存储在USB Key中，物理隔离更安全。</p><p><strong>二、筛选颁发机构（CA）：认准三大核心标准</strong></p><p><strong>全球信任度</strong></p><p>优先选择被主流操作系统（Windows、macOS）、浏览器（Chrome、Firefox）和平台（苹果App Store、微软商店）信任的CA，</p><p><strong>兼容性保障</strong></p><p>确认证书支持目标平台（如iOS需Apple证书，Android需Java代码签名）。</p><p><strong>服务响应速度</strong></p><p>选择提供7×24小时技术支持的CA，避免因证书问题导致发布延迟。</p><p><img width="723" height="323" referrerpolicy="no-referrer" src="/img/bVdh1w5" alt="" title=""/></p><p><strong>三、评估安全需求：加密强度与签名算法</strong></p><p><strong>加密算法</strong></p><p>优先选择SHA-256算法，兼容最新安全标准。</p><p>若需兼容旧系统（如Windows XP），可同时使用SHA-1和SHA-256双签名。</p><p><strong>时间戳服务</strong></p><p>确保证书包含时间戳，避免证书过期后已签名软件失效。</p><p><strong>四、验证兼容性：覆盖目标用户环境</strong></p><p>操作系统</p><p>Windows：需支持Authenticode签名。</p><p>macOS：需支持Developer ID签名（绕过Gatekeeper拦截）。</p><p>开发工具链</p><p>确认证书可集成到现有开发环境（如Visual Studio、Xcode、Java keytool）。</p><p><strong>五、成本效益分析：平衡价格与功能</strong></p><p>有效期与续费成本</p><p>长期项目建议选择2-3年有效期，避免频繁续费。</p><p>关注续费价格，部分CA首年低价但续费昂贵。</p><p><strong>六、避坑指南：三大常见误区</strong></p><p>误区1：免费证书更划算</p><p>风险：免费证书通常不被操作系统信任，可能导致用户安装时出现“未知发布者”警告。</p><p>误区2：签名一次，终身有效</p><p>现实：证书有效期通常为1-3年，过期后需重新签名软件。</p><p><strong>结语</strong></p><p>代码签名证书是软件安全的“第一道防线”，选择时需兼顾安全需求、用户体验和成本效益。通过明确场景需求、筛选可信CA、验证兼容性，您可为软件找到最合适的“安全印章”。</p>]]></description></item><item>    <title><![CDATA[除了加密，它还能验明正身：SSL如何防范]]></title>    <link>https://segmentfault.com/a/1190000047440683</link>    <guid>https://segmentfault.com/a/1190000047440683</guid>    <pubDate>2025-12-01 14:09:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>当我们提到SSL证书，最广为人知的功能是 “<em>加密</em>” 。它像一堵墙，确保你发送的数据不被黑客偷窥。</p><p>但SSL还有一个同等重要、却常被低估的“隐藏技能”——<strong>身份验证</strong>。它像一盏探照灯，在你连接之前，<strong>照清楚服务器的真实身份。</strong></p><p>而防范网络钓鱼的关键，恰恰在于这盏“探照灯”。一个仅有加密、没有身份验证的连接，无异于在加密的房间里，和戴着面具的骗子交谈，风险依然巨大。</p><p><strong>钓鱼攻击的伪装术与SSL的反制</strong></p><p>让我们先理解典型的钓鱼攻击：</p><p><strong>模仿</strong>：黑客创建一个与真实网站（如 paypal.com ）外观一模一样的克隆网站。</p><p><strong>诱导</strong>：通过邮件、短信等方式，诱骗你访问其控制的假域名（如 paypa1-login.com）。</p><p><strong>窃取</strong>：在你输入的瞬间，窃取你的用户名、密码、银行卡号等敏感信息。</p><p>在这个场景下，单纯的加密反而可能成为骗子的帮凶——因为它会让用户产生“安全”的错觉。而SSL的身份验证机制，正是破局的关键。<br/><img width="700" height="400" referrerpolicy="no-referrer" src="/img/bVdna7Z" alt="" title=""/></p><p><strong>SSL验明正身的三道“安检”</strong></p><p>当你访问一个部署了有效SSL证书的网站时，在你点击“登录”或输入任何信息之前，验证就已经悄然发生。</p><p><strong>第一道安检：浏览器自动执行的身份鉴定</strong></p><p>当你输入网址，浏览器收到服务器发来的SSL证书时，会立刻启动一个严格的鉴定流程：</p><p><strong>颁发者可信吗？</strong></p><p>浏览器会检查证书的签发者（CA），是否在它内置的受信任的根证书列表中。这就像检查一份文件的盖章机构，是否是政府认可的公证处。山寨CA签发的证书会被浏览器直接红牌警告。</p><p><strong>证书有效吗？</strong></p><p>浏览器会检查证书是否在有效期内、是否被签发者主动吊销。一份过期的或已注销的“身份证”是无效的。</p><p><strong>域名匹配吗？（最关键的一步！）</strong></p><p>浏览器会核验证书上声明的域名，与你正在访问的实际域名是否完全一致。</p><p>回到钓鱼案例：当你访问黑客的假网站 paypa1-login.com 时，即使黑客为这个假网站申请了SSL证书（通常是DV证书），证书上也只会显示 paypa1-login.com，而绝不可能显示真实的 paypal.com。浏览器会清晰地告诉你：你正在连接的是 paypa1-login.com。对于警惕的用户，这个域名差异就是最明显的警钟。</p><p><strong>第二道安检：不同证书等级带来的视觉信任信号</strong></p><p>这就是 DV、OV、EV 证书的区别所在，它们在防范钓鱼上的能力截然不同。<br/><strong>核心要点</strong>：高级别证书（OV/EV）不仅验证“你有这个域名”，更验证“你是谁”。这使得一个想冒充 paypal.com 的钓鱼网站，几乎不可能获得一张显示“PayPal Inc.”信息的OV或EV证书。</p><p><strong>第三道安检：用户意识的最后防线</strong></p><p>最后，SSL将验证结果清晰地呈现给用户，赋予用户判断的主动权。每次连接前，养成三个简单习惯，就能避开绝大多数钓鱼陷阱：</p><p><strong>看域名</strong>：仔细核对地址栏的完整域名，是否是你想访问的官方网站。</p><p><strong>点锁标</strong>：点击地址栏的锁形图标，查看 “连接是安全的” -&gt; “证书有效” 信息。在这里，你可以清晰地看到网站所有者信息（对于OV/EV证书）。</p><p><strong>信异常</strong>：绝不忽略浏览器的安全警告（如“此连接不安全”、“证书无效”等）。出现警告，立即止步。</p><p><strong>总结：坚固的链条，缺一不可</strong></p><p>防范网络钓鱼，是一个由技术、流程和意识共同构成的防御体系。SSL证书的身份验证功能，是其中技术层面至关重要的一环。</p><p>它通过<strong>可信CA的背书</strong>，建立了身份的起点。</p><p>它通过<strong>浏览器自动化的严格校验</strong>，拦截了信息不符的连接。</p><p>它通过<strong>不同等级的视觉线索</strong>，为用户提供了判断依据。</p><p>因此，<strong>仅仅启用HTTPS（部署DV证书）是远远不够的</strong>。对于真正处理敏感信息的网站（如银行、电商、企业后台），采用经过严格组织验证的OV或EV证书，是向其用户宣告“我即是我”的最高效方式。</p><p>而对于我们每一位用户，理解SSL这盏“身份探照灯”的意义，养成点击锁图标、核对域名信息的习惯，就是在为自己的数字安全，加上最后、也是最关键的一把锁。</p>]]></description></item><item>    <title><![CDATA[当IP地址“披上铠甲”：公网IP能否申请]]></title>    <link>https://segmentfault.com/a/1190000047440687</link>    <guid>https://segmentfault.com/a/1190000047440687</guid>    <pubDate>2025-12-01 14:08:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化浪潮中，数据安全传输已成为刚需。当我们习惯为域名申请SSL证书以实现HTTPS加密时，一个实际问题浮现：<strong>没有域名，只有公网IP地址，能否申请SSL证书？</strong>  答案是肯定的，但这条路径与域名申请有显著差异。</p><h3>为何IP地址需要SSL证书？</h3><p>传统认知中，SSL证书通常与域名绑定。但在特定场景下，直接使用IP地址访问服务：</p><ul><li><strong>企业内部服务外部化</strong>：公司测试服务器、监控面板或API接口通过公网IP临时对外开放</li><li><strong>物联网与设备直连</strong>：智能设备、工业控制器通过固定IP提供Web配置界面</li><li><strong>成本与简化考量</strong>：小型项目或临时服务未配置域名，需快速启用加密</li><li><strong>网络设备管理</strong>：路由器、防火墙等网络设备的管理界面需加密访问</li></ul><p>这些场景下，为IP地址配置SSL证书能有效防止中间人攻击，保护敏感数据传输。</p><h3>证书类型的选择限制</h3><p>与域名证书类似，IP SSL证书也分为不同验证级别：</p><ul><li><strong>DV（域名验证）证书</strong>：验证申请者对IP地址的控制权，通过上传指定文件或添加DNS记录完成验证。这是最常见的IP证书类型。</li><li><strong>OV（组织验证）证书</strong>：少数证书颁发机构(CA)提供，需验证组织身份，价格较高，审核严格。</li><li><strong>EV（扩展验证）证书</strong>：基本不对IP地址颁发，因其验证标准基于法律实体和域名所有权。</li></ul><p><strong>重要限制</strong>：根据CA/浏览器论坛规定，自2016年起，公网IP SSL证书仅可包含具体IP地址（如<code>192.0.2.1</code>），不能包含通配符（如<code>192.0.2.*</code>）。内网IP（<code>10.x.x.x</code>、<code>172.16.x.x-172.31.x.x</code>、<code>192.168.x.x</code>）理论上可申请私有证书，但需自建CA或使用特定服务。<br/><img width="723" height="414" referrerpolicy="no-referrer" src="/img/bVdmRTx" alt="" title=""/></p><p><strong><em>申请办法：打开JoySSL证书官网，填写注册码230970获取技术支持</em></strong>  <a href="https://link.segmentfault.com/?enc=a9UeP%2FonWAitee29Y0kYdg%3D%3D.anAmI9CH%2Bdt01HkflpAbxPTW4QK72oKYAZwO3998%2Frjt1hmQRPWJOeRPVlJmiGd6nCAb7MkNV2cO9IcomKgcyQLSy3wlEQRKJOYN4bILTUw%3D" rel="nofollow" target="_blank">申请入口</a></p><h3>申请实战：步骤与注意事项</h3><p>为公网IP申请SSL证书的流程如下：</p><ol><li><strong>选择证书提供商</strong>：并非所有CA都支持IP证书。GlobalSign、DigiCert、Sectigo等主流提供商通常支持，部分免费证书服务（如Let's Encrypt）也支持IP证书，但需验证IP控制权。</li><li><strong>生成CSR（证书签名请求）</strong> ：与域名证书类似，需要生成包含IP地址的CSR文件。关键点：在“通用名称(CN)”字段填写IP地址，而非域名。</li><li><p><strong>完成验证</strong>：</p><ul><li><strong>文件验证</strong>：在IP地址对应的Web服务器指定路径放置验证文件</li><li><strong>DNS验证</strong>：为IP地址的反向DNS记录添加指定TXT记录（需确保IP有反向DNS解析）</li><li><strong>邮箱验证</strong>：向IP的WHOIS注册邮箱发送确认信（较少用）</li></ul></li><li><strong>安装与部署</strong>：获得证书后，像域名证书一样配置到Web服务器（Nginx、Apache、IIS等）。</li></ol><p><strong>特别注意</strong>：</p><ul><li><strong>动态IP限制</strong>：大多数CA仅对静态公网IP颁发证书。动态IP（如家庭宽带）通常无法满足验证要求。</li><li><strong>IPv6支持</strong>：越来越多的CA开始支持IPv6地址的证书申请。</li><li><strong>兼容性考量</strong>：尽管主流浏览器支持IP SSL证书，但某些旧版浏览器或移动应用可能有不兼容情况。</li></ul><h3>风险提示与最佳实践</h3><ol><li><strong>隐私考量</strong>：IP证书会将IP地址暴露在证书透明度(CT)日志中，可能增加被扫描攻击的风险。</li><li><p><strong>短期方案建议</strong>：IP证书更适合临时或测试环境。长期服务强烈建议使用域名并申请相应证书，原因如下：</p><ul><li>域名更易于记忆和传播</li><li>IP变更时域名无需重新申请证书</li><li>域名证书选择更多、价格更优</li></ul></li><li><p><strong>安全加固</strong>：</p><ul><li>即使使用IP证书，也应配置HTTP严格传输安全(HSTS)等增强措施</li><li>定期更新证书，避免使用自签名证书导致浏览器警告</li><li>考虑将IP服务置于反向代理后，在代理层配置域名证书</li></ul></li></ol>]]></description></item><item>    <title><![CDATA[国密算法IP证书：构建网络空间安全的“中]]></title>    <link>https://segmentfault.com/a/1190000047440693</link>    <guid>https://segmentfault.com/a/1190000047440693</guid>    <pubDate>2025-12-01 14:07:43</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>国密算法IP证书作为我国网络空间安全自主可控战略的核心基础设施，正通过融合国产密码算法与IP地址绑定机制，重塑网络安全的技术格局。以下从技术特性、战略价值及实践应用三个维度解析其作为“中国芯”的重要意义：</p><p><strong>国密算法IP证书⬇️</strong></p><p><a href="https://link.segmentfault.com/?enc=CrnSlryTABZZTeTB7kJpNQ%3D%3D.GnqiNzFC%2ByhSLaq91pFVAwRSRNlyzqiUhiJmaQT7xyu9Si2QmcVHZkR1V9DqFMrYuQGRLR2k9LEbow8yXhL%2BnICREXkXzayPTx%2BQQV4Du9g%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/international_algor...</a></p><p><strong>注册码230959，专属技术服务支持⬆️</strong></p><p><img width="723" height="344" referrerpolicy="no-referrer" src="/img/bVdndEz" alt="image.png" title="image.png"/></p><h3>一、技术内核：自主可控的加密体系</h3><ol><li><strong>算法革新</strong>  <br/>国密算法IP证书基于国家密码管理局认证的SM2/SM3/SM4算法体系，其优势显著：</li></ol><ul><li><strong>高效安全</strong>：SM2密钥长度（256位）等效于RSA 2048位的安全强度，计算效率提升30%以上。</li><li><strong>抗量子攻击</strong>：采用后量子密码设计，为未来量子计算威胁提供前瞻性防护。</li><li><strong>双证书架构</strong>：创新性地分离加密证书与签名证书，形成“独立防盗门+指纹锁”的双重防护，降低单点突破风险。</li></ul><ol start="2"><li><strong>生态适配</strong>  <br/>已深度兼容国产主流环境，包括360浏览器、奇安信可信浏览器、红莲花浏览器等，并支持DeepinOS、统信UOS、KylinOS等国产操作系统，构建软硬件全栈安全链。</li></ol><h3>二、战略意义：数字主权的技术支点</h3><ol><li><strong>合规刚需</strong>  <br/>根据《密码法》《网络安全法》及等保2.0要求，政务、金融、能源等领域必须部署国密算法证书以通过“密评”（商用密码应用安全性评估）。截至2023年，全国已建成覆盖200余家CA机构的SM2根证书体系，成为政企系统准入的“通行证”。</li><li><strong>摆脱技术依赖</strong>  <br/>传统SSL证书依赖国际算法标准，存在后门漏洞风险与供应链“卡脖子”隐患。国密证书实现从算法设计到证书签发的全链路国产化，彻底扭转被动局面。</li></ol><h3>三、实践价值：多场景安全防护网</h3><ol><li><strong>特殊场景覆盖</strong>  <br/>针对未绑定域名的内部系统、工业控制设备、物联网终端等直接基于IP访问的场景，弥补传统域名证书空白，防范DNS劫持风险。例如，某大型制造企业通过IP证书实现车间设备加密通信，保障生产数据安全。</li><li><strong>性能优化降本增效</strong></li></ol><ul><li><strong>运算效率</strong>：SM系列算法针对国内网络环境深度优化，结合硬件加速技术（如国密SSL加速卡），使加密效率提升50%。</li><li><strong>成本节约</strong>：同等安全强度下，运维成本降低约40%，助力企业轻量化升级。</li></ul>]]></description></item><item>    <title><![CDATA[搞懂数字签名与证书 深盾安全 ]]></title>    <link>https://segmentfault.com/a/1190000047440699</link>    <guid>https://segmentfault.com/a/1190000047440699</guid>    <pubDate>2025-12-01 14:06:45</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>前言</h2><p>在之前的文章中，我们介绍了什么是对称加密什么是非对称加密，同时我们在文章中我们留下了一个疑问，那就是如何确认公钥和数据就是对方的而不是伪造的，今天这篇文章我们就聊聊相关的技术，签名与证书，非常有用，注意听讲哈</p><h2>签名</h2><p>平时我们说的签名更多是签个名字，比如有个文件需要经过我的确认，我再确认后需要拿起笔签上名字，证明这个文件是我已经同意了的。这里的关键点就是笔迹。</p><p>那么在数字世界中，如果我需要对方发送一个文件给我，我如何确认我所接收到的文件就是对方发送给我的而不是有人恶意伪造的呢？或者我该如何确认对方发送给我的文件不是经过有人篡改后的呢？</p><p>答案就是数字签名，数字签名使用的核心技术是哈希算法和非对称加密，如果大家对非对称加密不了解可以参考之前的文章</p><h3>哈希算法（HASH）</h3><p>本篇文章不对哈希算法做详细的说明，只做一个简单的介绍，让大家知道什么是哈希算法</p><p>所谓的哈希算法也称为“散列函数”或“哈希函数”，听名字是不是被吓到了，其实它就是一种能够输入任意长度的数据，通过计算，转换为一个固定长度字符串，这个转换出的字符串被称为哈希值、散列值或信息摘要，可以把它想象为一个数据的数字指纹</p><p>一个优秀的哈希算法具有以下几个特征</p><ol><li>输入相同的数据，无论什么时候计算出的哈希值都必须是完全相同的</li><li>输入数据哪怕仅发生极其微小的变化，哪怕是1个bit，输出的哈希值都会发生巨大变化，不可预测的改变</li><li>无法从哈希值反向推导出原始数据，也就是单向性</li><li>几乎不可能找到两个不同的输入具有相同的哈希值</li></ol><h3>数字签名</h3><p>数字签名的作用就是让别人相信内容没有被改过和确实是来自指定的人，同时签名者也无法抵赖说不是自己签的名</p><p>有了哈希算法和非对称加密我们就能够实现数字签名了</p><p>其实数字签名的流程很简单，可以分为以下几步</p><ol><li>对需要签名的数据进行哈希运算，计算数据的哈希值</li><li>使用私钥对哈希值进行加密</li></ol><p>使用数字签名也很简单，进行确认签名的流程叫做验签，可以分为以下几步</p><ol><li>从数据中提取签名数据和内容</li><li>使用公钥对签名数据进行解密得到哈希值</li><li>使用相同的哈希算法计算内容的哈希值</li><li>对比计算出的哈希值和解密出的哈希值是否一致，一致代表验签成功</li></ol><h2>数字证书</h2><p>刚刚说了数字签名，那就有一个问题，验签时使用了公钥，我又如何知道我所获得的公钥是正确的呢？这就是所谓的CA体系</p><p>数字证书也称为公钥证书，是一个电子文档，它遵循国际标准（X.509），这个问的那个就像是一个数字世界的身份证一样。</p><p>它的核心作用就是将一个公钥与一个特定的实体（个人、组织）的身份信息绑定在一起，并由一个可信的第三方机构对这个绑定关系进行担保和签名</p><p>比如用驾照来类比数字证书：</p><table><thead><tr><th>要素</th><th>驾照</th><th>数字证书</th></tr></thead><tbody><tr><td>持有者信息</td><td>姓名、地址、身份证号</td><td>主题：持有者的名称、组织信息等</td></tr><tr><td>核心凭证</td><td>驾照号码</td><td>公钥：证书持有者的公钥</td></tr><tr><td>颁发机构</td><td>车管所</td><td>证书颁发机构</td></tr><tr><td>机构印章</td><td>车管所的官方盖章</td><td>颁发者的数字签名：CA用自己的私钥对证书内容进行签名</td></tr><tr><td>有效期</td><td>签发日期和到期时间</td><td>证书生效和失效的时间</td></tr></tbody></table><p>你相信驾照上的信息，是因为你信任车管所这个权威机构，并且驾照上有它的防伪签名和印章。</p><p>同样，你相信一个数字证书里的公钥属于某个人或组织是因为你信任证书的颁发机构，并且证书上有颁发机构的数字签名</p><p>总结来说就是：假如我要将我的公钥发送给对方，那我就找证书颁发机构，提供我的公钥，让证书颁发机构帮我进行签名并制作证书，然后我将制作好的证书发送给对方。</p><p>对方拿到我的证书后需要进行验签，确认证书的颁发机构，那我们凭什么就要信任颁发机构呢？答案就是不相 信，颁发机构又会有它的证书，颁发机构的证书是由更上层的颁发机构颁发的，而更上层的颁发机构又有更更上层的颁发机构颁发，这套体系叫做CA体系，这套证书叫做证书链，一直到最上层是根证书，根证书仅有几个企业可以办法，这些跟证书已经早早的保存在我们的设备中了，只需要进行一下确认就可以了</p><h2>安全问题</h2><p>好了签名和证书已经为大家介绍完了，大家是不是已经觉的我们的程序只要使用了这套签名和证书体系就很安全了呢？哈哈哈，别太自信，你想想如果有人通过逆向的手段，直接修改我们的程序，绕过了验签流程，那再安全的方案也没有用啊</p><p>那怎么办呢？</p><h3>程序加壳保护</h3><p>现在我们已经有了足够安全的保障体系了，那要防止的也就是我们的程序被其他人逆向分析或篡改，这时可以使用Virbox Protector工具，对我们的程序进行加壳保护，加壳时会使用混淆，虚拟化，反调试等各种手段保护我们的程序，程序经过保护后我们就不需要在为此担心啦</p>]]></description></item><item>    <title><![CDATA[【版本更新】火语言 0.9.98.0 更]]></title>    <link>https://segmentfault.com/a/1190000047440701</link>    <guid>https://segmentfault.com/a/1190000047440701</guid>    <pubDate>2025-12-01 14:05:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>1.修复Excel删除列、写值问题。<br/>2.浏览器监听优化处理。<br/>3.指纹浏览器应用支持调用本地客户端服务。<br/>4.新增人工等待置顶配置。<br/>5.优化发布应用拷贝的文件目录。<br/>6.优化指纹浏览器应用插件安装。<br/>7.新增界面应用控件拷贝到其他窗体。<br/>8.优化另存为模板拷贝变量、对象。<br/>9.处理窗体加载完成事件内置浏览器Timeout问题。<br/>10.获取时间间隔使用本地时间（非UTC）。</p>]]></description></item><item>    <title><![CDATA[50-100人的公司，文件共享选NAS还]]></title>    <link>https://segmentfault.com/a/1190000047440708</link>    <guid>https://segmentfault.com/a/1190000047440708</guid>    <pubDate>2025-12-01 14:05:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>根据市场研究机构Statista的一项调查显示，截至2023年，有超过79%的中小企业认为文件共享和协作是提升团队效率的关键环节。然而，在对技术解决方案的选择上，许多企业却陷入纠结：</p><p>是选择本地化设备如NAS（网络附属存储），还是采用更为弹性的企业网盘？尤其对于50-100人的中型公司来说，这道选择题尤为棘手，它不仅关系到数据的安全性和成本，也直接影响到员工的工作效率和团队的协作深度。</p><p><img width="658" height="350" referrerpolicy="no-referrer" src="/img/bVdjxj5" alt="" title=""/></p><h2>NAS与企业网盘，两个方向</h2><p>在开始比较之前，我们需要先明确这两个技术解决方案的核心概念及其适用场景。</p><p>NAS：本地化的存储<br/>NAS（Network Attached Storage）是一种通过局域网连接的专用存储设备，常用于小型团队或公司。这种设备的最大优势是数据保存在本地，可避免对外网的高度依赖。它比较适合对数据隐私、安全性要求较高，并且有一定IT管理能力的公司。</p><p>比如，一家设计公司可能需要频繁存储和传输大体积的设计文件（如动辄数十GB的CAD文件）；类似这样的企业，NAS的本地存储能力和较高的读取速度显然更能满足需求。</p><h2>企业网盘：云端的灵活办公</h2><p>与NAS形成鲜明对比的是<a href="https://link.segmentfault.com/?enc=Lz4cdUgr9FhA0Ibx3A2bsA%3D%3D.AwWwqv9zQ7f1eIqykbrKgIVu9bGrIUd0Wk1MSbpBZHcEIs%2BfvNuQ6ZfeEjpTSPCixN47vKBYT7MMzOME9xdL5g%3D%3D" rel="nofollow" target="_blank">企业网盘</a>。企业网盘基于云存储技术，为员工提供随时随地访问和共享文件的能力。无论是远程协作，实时同步，还是团队项目管理，企业网盘都具有天然的优势。它尤为适合注重灵活性，且有混合办公需求的团队。</p><p>比如，一个50人规模的营销团队可能成员分布在多个城市，这时若所有文件都集中在一台NAS上，便会因为跨地域访问的延迟问题拖慢进度，而云端企业网盘完全可以避免这样的困扰。</p><h2>核心对比：NAS与企业网盘适合谁？</h2><p>为了让选择更具针对性，我们从几个关键维度进行细致比较。</p><h3>1. 数据安全性与掌控权</h3><p>NAS<br/>数据存储在本地，完全掌控在企业手中。公司可以直接在物理层面保障文件的安全性，不用担心厂商平台的潜在漏洞。但是，这种方式的风险在于一旦设备损坏或遭遇自然灾害（如火灾、地震），数据可能面临不可逆的丢失。因此，NAS需要做好备份规划，例如搭建RAID阵列或者将部分数据异地存储。</p><p>企业网盘<br/>企业网盘则强调服务商的安全保障。以Zoho网盘为例，它不仅会对文件进行256位AES加密，还支持企业级别的权限管理和日志追踪。即使一个文件被误删除，也可以方便地从云端版本管理中恢复。如果选择了可信赖的网盘服务商，云端存储的安全性同样十分可靠，且用户无需额外担心硬件损坏问题。</p><h3>2. 部署与维护</h3><p>NAS</p><p>对中小企业而言，使用NAS有一个隐形的“门槛”：部署和维护。NAS设备的初期搭建需要IT部门的支持，后期的硬件维护、网络配置升级、定期检测等也需要一定的技术能力。而如果缺乏专业的IT人员，可能会导致设备故障时恢复效率低下，影响业务正常运行。</p><p>企业网盘</p><p>一个强大的企业网盘，可以大幅度减轻公司的技术负担。以Zoho网盘为例，用户登录即可使用，它通过SaaS模式解决了存储扩容、系统更新、访问权限配置等繁琐事项，企业无需专门配备运维团队。特别是对于不断追求高效率的成长型企业来说，这种简化的IT管理方案无疑是理想选择。</p><h3>3. 成本与灵活性</h3><p>NAS</p><p>初期购买NAS设备时，公司的预算可能会受到一定压力。一台性能优越的NAS设备，加上硬盘及相关配套软件，需要投资数万元。尽管长远来看，使用成本可控，但当公司业务增长时，扩容费用和设备更新成本会进一步攀高。</p><p>企业网盘</p><p>企业网盘则采用按需付费的模式，非常适合50-100人规模的公司。Zoho网盘提供多种套餐选项，按月或按年支付，无需一次性购入昂贵设备。同时，当团队成员增加或需求提升时，只需调整存储计划即可，弹性用量为企业节省不少预算。</p><ol start="4"><li>协作与操作体验</li></ol><p>NAS</p><p>NAS虽因复杂的本地网络操作能力而具备一定优势，但在团队协作方面不如网盘方便。大多数时候，员工只能通过公司内部网络访问NAS数据，远程工作时仍需要额外设置VPN、DDNS等。对于注重实时协同和跨地域办公的企业来说，这无形中加大了操作难度。</p><p>企业网盘</p><p>Zoho网盘则为企业提供了一站式协作体验：文件可以实时共享、在线编辑、备注讨论，所有文件版本和操作记录一目了然，同时还方便员工在多种设备中同步内容。此外，像这种网盘方案还可以通过应用程序接口（API）与其他办公工具集成，进一步扩展应用场景。</p><h2>50-100人公司如何选择？一体化协作助力企业发展</h2><p>对于50-100人的中型公司而言，选择NAS还是企业网盘，本质上是取决于企业当前的业务形态和发展需求。那么，是否有一种方案可以在安全性、便捷性和成本之间找到平衡点？</p><p>一个成熟的企业网盘，如Zoho网盘，无疑可以成为大部分中型企业的优选方案：</p><p>灵活高效的文件协作：实时共享和编辑功能，让团队的沟通更高效。</p><p>出色的数据管理与权限控制：管理员可以细化每一位成员的访问权限，完全掌握数据流向。</p><p>更低的前期投资和维护成本：按需付费的模式，让预算变得可控。</p><p>跨平台支持与远程优越体验：无论在办公室还是异地，所有文件都触手可得。</p><p>如果你的企业已经开始混合办公，或团队越来越依赖协作与共享办公工具，Zoho网盘绝对是值得深入体验的选项。</p>]]></description></item><item>    <title><![CDATA[SSL证书在哪里可以申请免费的 从未表白]]></title>    <link>https://segmentfault.com/a/1190000047440717</link>    <guid>https://segmentfault.com/a/1190000047440717</guid>    <pubDate>2025-12-01 14:04:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>SSL证书的申请渠道</h2><p>申请SSL证书的渠道多样，主要可分为以下几类：</p><ul><li><strong>免费证书颁发机构(CA)</strong>：如JoySSL提供基础DV型免费证书，针对特殊域名的</li><li><strong>付费证书颁发机构</strong>：全球知名的CA如Symantec、Comodo、GeoTrust等，提供包括DV、OV、EV在内的多种证书类型，具有更高的安全保障和信任度，通常提供保险保障和完善的技术支持。</li><li><strong>云服务提供商</strong>：如阿里云、腾讯云、华为云等云服务平台，也集成了SSL证书的申请与管理服务，部分平台提供免费证书。</li><li><strong>特定机构免费证书</strong>：例如<strong>JoySSL为政务单位及教育机构</strong>提供的免费政务版和教育版SSL证书。</li></ul><p>为了让你更直观地了解不同渠道的特点，请参考下表：</p><table><thead><tr><th align="left"><strong>渠道类型</strong></th><th align="left"><strong>主要特点</strong></th><th align="left"><strong>适用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>免费CA (如JoySSL)</strong></td><td align="left">零成本，<strong>申请便捷</strong>，通常为DV型证书；部分机构如JoySSL提供<strong>政务/教育免费版</strong></td><td align="left">个人网站、博客、测试环境、符合条件的政务/教育机构</td></tr><tr><td align="left"><strong>付费CA</strong></td><td align="left">信任度高，验证严格（尤其是OV/EV型），提供保险，技术支持完善</td><td align="left">企业官网、电商平台、金融机构等对安全要求高的场景</td></tr><tr><td align="left"><strong>云服务商</strong></td><td align="left">可与云产品便捷集成，管理方便，部分提供免费证书</td><td align="left">已在使用相应云服务的用户</td></tr></tbody></table><h3><a href="https://link.segmentfault.com/?enc=0VvU0dfbt0hK9Z%2FI%2B1zeoQ%3D%3D.gsNcMxdp%2B3KB6%2FwlxHaXWAVHTUbbWaWbUrUB9L%2FnMiQSI82NIHMaU2pGpf8K27dvExckfRfoku9JdQCz8AwEtT47M0EP0BQzIM8Kt7PNTPc%3D" rel="nofollow" target="_blank">免费证书申请入口</a></h3><p>直接访问JoySSL，注册一个账号记得填写注册码230931获取技术支持。</p><p><strong>注意免费证书是针对特殊域名的。</strong><br/><img width="539" height="197" referrerpolicy="no-referrer" src="/img/bVdjsFk" alt="" title=""/></p><h2>推荐JoySSL政务版与教育版免费证书</h2><p>对于<strong>政府机关、事业单位、公立学校、教育机构及教育平台</strong>，<strong>JoySSL</strong>提供了<strong>免费的政务版和教育版SSL证书</strong>。这是一个非常可靠且成本效益高的选择。</p><h3>主要特点与优势</h3><ol><li><strong>完全免费</strong>：JoySSL为政务和教育机构提供免费的SSL证书，有效降低这些单位的运营成本。</li><li><strong>满足基本安全需求</strong>：提供的证书能够实现网站数据的<strong>加密传输</strong>，保障用户访问安全，消除浏览器“不安全”警告。</li><li><strong>国密算法支持（可选）</strong>：JoySSL的部分证书支持<strong>国密算法</strong>，能够满足政务系统对自主可控密码应用的安全需求。</li></ol><h3>申请步骤</h3><p>JoySSL证书的申请流程简单，主要分为以下几步：</p><ol><li><strong>注册账号</strong>：访问JoySSL官方网站，注册账号。在注册过程中，通常需要填写特定的<strong>注册码（如230922）</strong> 以获取免费申请资格。</li><li><strong>选择证书类型</strong>：登录后，在证书列表中选择“免费证书”或直接找到“<strong>政务/教育版</strong>”入口并点击申请。</li><li><strong>填写信息并提交资料</strong>：准确填写需要加密的<strong>域名</strong>、单位的<strong>完整官方名称</strong>（需与证明文件一致）、联系人信息等。根据提示上传单位证明文件，如事业单位法人证书或统一社会信用代码证书的清晰照片或扫描件。</li><li><strong>验证与审核</strong>：提交申请后，等待JoySSL审核。审核时间通常为1-3个工作日。</li><li><strong>下载并安装证书</strong>：审核通过后，你会收到通知邮件。登录JoySSL用户管理后台，下载签发的SSL证书文件（通常包括<code>.crt</code>或<code>.pem</code>证书文件及<code>.key</code>私钥文件）。最后，将证书部署到你的网站服务器上。</li></ol><h2>申请与部署注意事项</h2><p>在申请和部署SSL证书时，有几个关键点需要特别注意：</p><ul><li><strong>确保证书兼容性</strong>：选择受信任的证书颁发机构，并验证证书是否支持所有主流浏览器和操作系统。</li><li><strong>注意证书有效期并及时续期</strong>：免费SSL证书的有效期通常较短（例如一年）。需要在证书到期前及时更新，否则会影响网站安全。</li><li><strong>妥善保管私钥</strong>：私钥文件是证书安全的核心，<strong>务必妥善保存</strong>，一旦丢失将无法安装和使用证书。</li><li><strong>正确安装与配置</strong>：根据服务器类型（如Nginx、Apache、IIS等）按照相应的步骤正确安装和配置SSL证书。</li></ul><p>希望这篇文章能帮助你找到合适的SSL证书申请渠道。为你的网站添加一把“安全锁”，既是保障数据安全的重要措施，也是提升网站可信度的关键一步。</p>]]></description></item><item>    <title><![CDATA[如何通过工艺优化提升汽车制造效率？ 月下]]></title>    <link>https://segmentfault.com/a/1190000047440744</link>    <guid>https://segmentfault.com/a/1190000047440744</guid>    <pubDate>2025-12-01 14:03:35</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在全球制造业迈向智能化的浪潮中，工艺优化成为传统汽车制造企业破茧重生的核心变量。广域铭岛凭借其工业互联网平台Geega，打造出覆盖冲压、焊装、涂装、总装四大关键环节的数字化工艺优化闭环，将单点技术问题转化为系统性智能解决方案。这种优化不止于质量改善，更通过实时数据流重新定义工艺逻辑，形成一种以算法驱动的生产范式。<br/>在冲压领域，广域铭岛的GQCM模具智能管理APP将经验试错的被动维护转向基于冲次数据与设备状态的预测制造。系统通过构建虚拟孪生模型，提前48小时捕捉模具异常，主动触发保养工单，让金属成型速率与精度同步提升。这种颠覆性工艺优化方式，使模具运行效率提升40%，甚至改变了制造业对标准化模具的认知边界。<br/>焊装环节的工艺优化则围绕破解"隐形缺陷"展开。5G+边缘计算的接入赋予焊接工艺前所未有的感知力，2000余项焊点参数的量化分析打破了传统质检的人为主观性。更令行业瞩目的是，AI预测模型将虚焊率压缩至0.02%以下的微小阈值，这也意味着一种全新的生产哲学：从经验迭代到数据驯化。这种工艺优化深度，连车企自身都难以企及。<br/>涂装工艺优化成为广域铭岛技术护城河的最佳体现。依托跨设备层叠数据采集，平台构建出从涂料配比到喷涂轨迹的整套优化矩阵。智能调色算法如同炼金术士般动态补偿环境波动，而能耗调控技术则将涂装从污染大户转变为降碳先锋——单套系统可同时实现12%涂料升利用率和8%能耗降低。这种工业级工艺优化，让汽车表面不再仅仅是色彩问题，更成为价值创造的实体延伸。<br/>总装工艺的优化侧重于"最后一微米"的精准拿捏。电控拧紧系统的粒子级监控将装配全环节数据化，任何扭矩偏差都会在三级预警体系中被放大消解。这种创新性工艺优化，不仅使装配返工率降低至传统模式的60%，更建立了可追溯的智能档案体系，将质量视角拓展至产品全生命周期。<br/>广域铭岛的技术架构实则是"三横三纵"的工艺优化交响曲。横向看，它通过工业AI平台实现了从传感器到决策引擎的数据流贯通；纵向分析，又构建起覆盖设备级优化、产线级平衡到工厂级排产的立体化网络。这种复合型工艺优化能力，让单一产线运行效率突破40%上限已成为可能。<br/>尤为值得关注的是，广域铭岛成功将工艺优化从核心技术突破转化为产业协同发展模式。通过开放API接口，平台连接200余家第三方厂商，形成跨越品牌的全新工艺标准。当某合资车企采用这套集成化工艺优化系统时，原本耗时3周的数据对接周期被压缩至3个工作日，80%的部署效率提升直接源于这种生态级优化思维。<br/>从制造逻辑的根本变革角度看，广域铭岛的工艺优化正在重构行业的know-how体系。传统制造业依赖经验堆积，而其工业超级智能体则将复杂的工艺变量转化为可被AI理解和操控的参数空间。这就如同为汽车制造植入动态智慧基因，让每一型零件、每一组数据都能在适配环境中"进化"出最优解。<br/>可持续发展维度下，工艺优化展现出更广阔的解构空间。统计数据显示：涂装工艺优化使能耗平均下降15%，焊装环节优化减少20%有机物排放，冲压优化实现同等质量下25%材料节省。这些复合效益不仅是技术落地的凯标，更证明了广域铭岛工艺优化方案在碳约束时代的价值权重。<br/>随着量子计算等前沿技术在工业领域的加速渗透，广域铭岛正将工艺优化推向更具想象力的新阶段。该公司对制造业的认知早已超越单点技术——智能制造范式构建的游戏规则正被其亲手改写。未来的汽车制造，必然是由这种全方位工艺优化重新编织的秩序所主宰。从设计逻辑到供应链协同，从质量管控到绿色转型，广域铭岛的工艺优化路径或将成为下一个行业基准。</p>]]></description></item><item>    <title><![CDATA[干货推荐：OOM 杀进程 or 应用卡顿]]></title>    <link>https://segmentfault.com/a/1190000047440746</link>    <guid>https://segmentfault.com/a/1190000047440746</guid>    <pubDate>2025-12-01 14:02:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3>背景</h3><p>近期，大量用户反馈系统在运行过程中出现 CPU 利用率与系统负载（load）突发性飙升，甚至引发系统短时卡顿（持续数秒至数十秒）的问题；对于业务来说，轻则导致几百毫秒的抖动，重则连机器都无法ssh上去。经分析发现，此类异常现象普遍存在一个显著特征：均发生在系统内存占用率接近阈值（90%-95%）时。用户就发出了灵魂拷问：</p><p>“水位这么高了，为什么内核不触发 OOM 杀掉一些进程来释放内存？"</p><p>“我宁愿内核OOM 把我业务进程杀了，我也不希望应用卡顿和系统夯机影响我其他业务！”</p><p>其实这个现象的核心原因就是：内核想确保应用实在没内存用了才 OOM。</p><p>思想总体是正确的，但是一条思想要满足所有场景也是非常难的。</p><h4>为什么还不 OOM？</h4><p>内存水位这么高，为什么还不 OOM！其实主要是由于系统进入了 Near-OOM 状态。现在，我们先回顾一下 Linux 的内存回收机制，如下图所示：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047440748" alt="图片" title="图片"/><br/>（图/Linux 内存水线）</p><p>Linux 划分了 high、low、min 三个内存水线。当系统剩余内存低于 low 水线后，内核会唤醒 kswapd 进程会被唤醒开始进行异步的内存回收，此时对系统没什么影响；系统剩余内存低于 min 水线后，内核会阻塞要分配的内存进程尝试尽可能地回收所有可回收的内存（主要是文件缓存以及一些内核结构体缓存），回收的过程中可能涉及到将文件缓存写入磁盘或遍历一些内核结构体，从而导致系统负载飙高、应用被阻塞。如果能成功回收内存并满足申请需求则不触发 OOM。</p><p>更糟糕的是，系统可能进入一种 Near-OOM 的活锁状态，即内核一边在尝试回收文件缓存；但是应用运行过程中从磁盘加载代码段等行为也在不断产生文件缓存，那么就会使整个系统负载持续飙高，甚至发生夯机。<br/>所以，内核 OOM 的策略在业务延时敏感的场景，还是太保守了。</p><p>那么如果我们希望宁愿 OOM 把我业务进程杀了，我也不希望应用卡顿和系统夯机影响我其他业务？还有什么办法呢？</p><h3>新 OOM 方案</h3><p>为了应对 Near-OOM 现象，核心就是“快” OOM，在内核还在犹豫要不要 OOM 的时候，我们就替他做出决定！目前业界已有的方案主要是通过用户态提前杀死相关进程来提前释放内存，比如应用较为广泛的是 Facebook（Meta）推出的 oomd。oomd 目前已经集成于 systemd 中成为 systemd-oomd，且从 Ubuntu 22.04 开始集成于 Ubuntu 中。但是 oomd 方案存在以下问题：</p><p>与 cgroupV2 以及 Linux 内核的 PSI（Pressure Stall Information）特性深度绑定。但 cgroupV1 目前仍然是云计算中主流 cgroup 版本，且由于 PSI 功能有一定的性能开销，在大部分云计算场景中都是默认关闭的。</p><p>只支持以 cgroup 为粒度杀进程，配置 cgroup 级别的杀进程策略。</p><p>所以 oomd 在适用性和灵活性上仍有欠缺。</p><p>为了解决上述问题，阿里云操作系统控制台推出了 FastOOM 功能，支持节点以及 Pod 级别的用户态 OOM 配置，通过提前介入杀进程的方式避 Near-OOM 导致的抖动夯机。</p><p>FastOOM 同样采取用户态提前杀进程的形式来避免系统进入 Near-OOM 状态，主要分为采集预测模块和 kill 模块：采集预测模块会从阿里云自研操作系统中读取内存压力相关的指标，通过统计学方法对 OOM 发生的概率进行实时预测并判定当前节点或 pod 是否达到相应的内存压力或即将进入 Near-OOM 状态。kill 模块会根据用户配置的杀进程策略，选取对应的进程杀死。</p><p>最终所有由 FastOOM 执行的 kill 操作事件都会上报到控制台中心端进行展示，让用户方便了解底层的实际操作（不用担心 FastOOM 偷偷杀死了其他进程）。<br/><img width="723" height="274" referrerpolicy="no-referrer" src="/img/bVdndFl" alt="image.png" title="image.png" loading="lazy"/></p><h3>使用 FastOOM 避免 Near-OOM 系统夯机抖动</h3><h4>场景一：配置节点级别策略解决系统Near-OOM抖动夯机问题</h4><p>客户遇到的问题<br/>某汽车行业发现某实例上业务长时间无响应、登录实例也十分卡顿。通过监控发现客户实例使用的内存在某个时间点开始徒增，接近系统的总内存（即 available 非常低），但没有超过系统总内存。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047440749" alt="图片" title="图片" loading="lazy"/><br/>通过 top 命令可以看到系统的 CPU sys 利用率和 iowait 利用率和系统负载都持续飙高，kswapd0 线程占用非常高的 CPU 进行内存回收。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440750" alt="图片" title="图片" loading="lazy"/><br/>通过操作系统控制台的系统概览可以看到，在发生 OOM 夯（即处于 Near-OOM 状态）的同时，也发生了用户态收包延时，业务发生了抖动。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440751" alt="图片" title="图片" loading="lazy"/><br/>解决方案</p><p>通过配置开启节点级别的 FastOOM 功能，由于业务是实验较为敏感的业务，内存压力选择中，且设置业务程序（以 python 启动，进程名包含 python 子串）为避免被 OOM 进程且设置无关的日志程序优先杀死。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440752" alt="图片" title="图片" loading="lazy"/><br/>开启后，当节点内存水位处于 Near-OOM 状态时，用户态提前介入，根据配置杀死了如下进程，从而释放了部分内存避免系统进入了夯机状态。通过操作系统控制台的系统概览可以看到 FastOOM 介入的相关记录。</p><p>如下图所示，由于 kube-rbac-proxy 和 node_exporter 等进程 oom_score_adj 被设置为接近 999，FastOOM 会匹配内核策略优先杀死这些进程，但是由于杀死这些进程后释放内存较小，仍处于 Near-OOM；因此 FastOOM 杀死了配置优先杀死的 logcollect 进程。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047440753" alt="图片" title="图片" loading="lazy"/><br/>由于用户态及时介入杀死进程释放出内存，使系统避免进入了 Near-OOM 的抖动状态。</p><h4>案例二：配置Pod级别策略解决Pod应用抖动夯机问题</h4><p>客户遇到的问题<br/>在 Kubernetes 环境中，我们是可以为 Pod 中的容器配置对应的内存限制的，和节点 OOM 同理，如果 Pod 中的内存使用接近限制时，内核也会尝试回收 Pod 中所有可回收内存，才触发 OOM，这时候也会导致 Pod 内业务进程的延时阻塞。</p><p>某大数据客户会部署一些延时敏感的业务 Pod（即 Pod 中运行了多个业务进程）。业务时不时会存在响应长尾延时，但是网络相关指标一切正常。</p><p>后面我们接手问题后，通过 Alibaba Cloud Linux 自研指标（该指标反映容器由于内存回收阻塞的时长）发现，存在非常高的内存回收延时，且时间节点和抖动时间匹配：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440754" alt="图片" title="图片" loading="lazy"/><br/>推荐客户配置 Pod 级别的 FastOOM 后，通过提前杀死 Pod 中的相关内存占用进程，避免了内存回收延时的发生，抖动也不再出现。</p><p>解决方案<br/>操作系统控制台提供较为灵活的 Pod 级别的 OOM 杀进程策略配置，可以灵活配置 Pod 中容器内发生 OOM 时，避免和优先杀死的进程。</p><p>假设在集群中通过名为 test-alinux 的 daemonset 在每一个节点部署了对应的 Pod。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440755" alt="图片" title="图片" loading="lazy"/><br/>在操作系统控制台中设置 Pod 级别 FastOOM 策略：</p><ul><li>为了匹配对应的 Pod，Pod 名称填写 test-alinux（正则表达式会匹配不同节点上的 test-alinux-xxx pod），命名空间为 default。</li><li>由于只是希望控制 OOM 时的杀进程策略，将内存压力级别设置为高，则触发用户态 OOM 的时机会近似于内核 OOM 的时机。</li><li>对于杀进程策略：配置优先杀死特定进程和避免杀死业务进程和 Pod 中的 1 号进程，从而避免 Pod 重启或影响业务，设置完成后下发至特定节点。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440756" alt="图片" title="图片" loading="lazy"/><br/>将配置下发到对应节点后，当 Pod 中容器内存使用超过容器 limit 后，发生 OOM；可以通过操作系统控制台系统概览看到 FastOOM 事件记录，可以看到 FastOOM 根据策略杀死了对应的进程，也避免了特定进程被杀死。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440757" alt="图片" title="图片" loading="lazy"/></p><h3>总结</h3><p>人无完人，内核的 OOM 其实也不是万能的。为了能尽可能的回收内存，内核在发生 OOM 前会阻塞申请内存的进程，并尝试回收内存，这对于延时敏感的业务的影响是非常大的；如果内存持续保持在接近 OOM 的水位，还会进入 Near-OOM 的活锁状态导致整机夯机。阿里云操作系统控制台的 FastOOM 功能，通过相关指标，支持节点/容器/Pod 级策略，可精准杀指定进程，轻松弥补了内核 OOM 带来的延时卡顿问题。</p><p>联系我们 </p><p>您在使用操作系统控制台的过程中，有任何疑问和建议，可以搜索群号：94405014449 加入钉钉群反馈，欢迎大家扫码加入交流。</p><p>阿里云操作系统控制台PC端链接：<a href="https://link.segmentfault.com/?enc=3O5sxluvMq5HZmzvItODNA%3D%3D.6QQLCxt0YNcXqCIvfXOSJ%2FrlX4Us702zjo8Xl5oj2N4ce02jPPE18fdMXR%2B9PJr6" rel="nofollow" target="_blank">https://alinux.console.aliyun.com/</a></p>]]></description></item><item>    <title><![CDATA[企业网盘有什么用？什么是企业网盘 胡萝卜]]></title>    <link>https://segmentfault.com/a/1190000047440769</link>    <guid>https://segmentfault.com/a/1190000047440769</guid>    <pubDate>2025-12-01 14:02:12</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>企业网盘并不是一个单纯的文件存储工具，它更像是一个为企业量身定制的“数字空间”，用来支持团队协作、提升工作效率，同时严格守护企业数据。这篇文章将带你深入了解企业网盘是什么，以及它能够为技术团队带来哪些具体价值。在文中，我们将探索如何通过<a href="https://link.segmentfault.com/?enc=cQgkuflV4RmrpH1wkXOXWg%3D%3D.NVidFg6F2KbF9z7JYVKACfw3p4R9%2BzoIgcwNCqxijLNU0RTZGdJerapqX4RXhMxsIxD%2FvoWo8p12qEhcdo0Mmw%3D%3D" rel="nofollow" target="_blank">企业网盘</a>为团队赋能、优化工作流程，甚至为企业带来长远性的战略意义。</p><p><img width="658" height="350" referrerpolicy="no-referrer" src="/img/bVdjxj5" alt="" title=""/></p><h2>一、什么是企业网盘？</h2><p>在介绍企业网盘之前，让我们设想一下这样一个场景：团队的某一成员急需一份文件，但他不知道文件所在的具体位置；另一个成员不小心上传了错误版本的文件，造成了整个团队工作的进度延迟；更不幸的是，公司的一份重要数据由于设备故障丢失，无法恢复。这些问题听起来似乎毫无技术含量，但它们却是每个企业每天可能面临的真实困境。</p><p>企业网盘正是为了解决这些问题而设计的一个平台。简单来说，企业网盘就是一个专为企业团队设计的云存储解决方案。它不仅提供文件存储服务，还具备灵活的权限管理、高效的共享协作、多终端访问能力、版本控制功能和数据安全保障。通过企业网盘，文件和数据不再只是静态的“资料”，它们开始流动，成为企业团队高效协作的“桥梁”和“纽带”。</p><p>Zoho网盘作为一个完善的企业端解决方案，秉承着“以数据服务团队，以效率驱动成果”的理念，为企业提供了从文件管理到团队协作的一站式解决方案。它不仅简化了传统文件存储的复杂模式，还通过智能化的功能，让数据管理更加高效和安全。</p><h2>二、企业网盘的核心价值</h2><p>企业网盘的作用不仅局限于存储，它更是一个支持团队协作和高效工作的利器。以下是企业网盘的核心价值，也是它成为企业必备工具的关键原因：</p><h3>1.文件集中管理：告别“数据孤岛”</h3><p>“数据孤岛”是今天许多企业的痛点。员工之间的个体存储习惯不同，导致文件散落在不同的设备中，无论是个人电脑、邮件附件还是移动设备，都可能潜藏着企业的重要数据。而这些数据往往缺乏系统化的整理和统一管理，导致查找困难、重复劳动甚至数据丢失。</p><p>企业网盘，将所有文件集中储存在一个统一的云端空间。以Zoho网盘为例，团队成员可以在一个共享的空间内轻松访问、上传和整理文件，不再需要花费大量时间去翻找邮件和手动核对文件版本。Zoho网盘还支持目录结构的清晰化设计，使得文件管理更加优雅而高效。</p><h3>2.权限管理：数据共享与数据保护并行</h3><p>数据共享越方便，安全挑战也越大。企业网盘的一大核心优势就是精细化的权限管理机制。Zoho网盘提供了灵活的权限设置，团队成员可以根据需求对不同的文件赋予查看、编辑或删除权限。这样一来，既保证了文件共享的效率，也能有效避免因权限错误而导致的数据泄露或误操作。</p><p>此外，Zoho网盘的权限管理不仅覆盖到文件层面，还可以细化到文件的某个版本，甚至是与外部合作伙伴的临时共享权限。这种高度定制化的权限设置，让数据保护不再是“叠加式的谨慎”，而是“有计划的开放”。</p><p>3.文件版本控制：拒绝“信息混乱”</p><p>文件版本的冲突，是团队协作的噩梦。尤其是在多人共同参与项目的时候，不同成员往往会对同一个文件进行修改，而由于缺乏系统的版本控制机制，导致文件提供错误版本或丢失关键信息。</p><p>企业网盘通过版本记录功能，有效解决了这一问题。在Zoho网盘中，每一位成员对文件的修改都会自动生成新的版本，而这些版本均可随时回溯。团队可以清晰地看到谁在何时进行过了修改，从而避免数据混乱，提高协作质量。</p><h2>三、企业网盘的实践应用</h2><p>具体到技术团队，企业网盘能够带来哪些实际的好处呢？让我们从一线场景出发，揭示企业网盘能彻底改变工作方式的几个应用：</p><h3>1.高效的跨部门协作</h3><p>技术团队往往需要和产品、运营甚至销售团队进行频繁的沟通与协作。这些跨部门的合作少不了文件共享，例如产品功能表、开发计划书、设计原型以及测试报告等。传统的方式可能需要通过邮件来往或者交接文件，这不仅耗时，还存在文件冲突和遗漏的风险。</p><p>通过Zoho网盘，技术团队可以直接在共享文件夹中创建和修改各类文档，跨部门成员可以实时查看最准确的内容。团队之间的沟通不再受到时间与地点限制，项目推进更加快速流畅。</p><h3>2.远程办公和多终端支持</h3><p>在远程办公成为趋势的当下，企业网盘的重要性愈加凸显。无论团队成员是在办公室、家中还是出差途中，他们都能通过Zoho网盘随时随地访问企业资源。Zoho网盘支持电脑、手机、平板等多终端访问，确保文件的使用场景覆盖率最大化。</p><p>此外，Zoho网盘提供了离线功能，即使网络中断，用户也可以继续使用已同步的文件，这对于突发状况下的工作续航至关重要。</p><h3>3.强大的搜索能力：一秒找到所需</h3><p>技术团队的文件名称往往复杂且大量，但在Zoho网盘的帮助下，通过强大的搜索功能，无论是根据关键词、上传日期还是文件存储路径，都能快速找到所需内容。这样既节省了查找资料的时间，也避免了错误文件的使用。</p><h3>4.数据安全和备份：技术团队的安心守则</h3><p>数据安全对于技术团队来说是至关重要的，不管是源代码、数据库架构还是产品设计方案，这些信息都是企业的核心资产。一旦丢失或泄露，将会带来不可估量的后果。</p><p>Zoho网盘采用全方位的加密技术和自动云备份服务，确保所有文件的绝对安全。即使发生系统崩溃或用户误删，也能通过备份进行恢复。技术团队不用再战战兢兢，如履薄冰地存储重要文件，而可以把更多精力放在创新和问题解决上。</p><h2>四、企业网盘如何为团队赋能？</h2><p>企业网盘以一个简单、却功能强大的平台，为企业团队带来了效率与安全的双重保障。在今天的数字化转型浪潮中，拥有一个高效、可靠又智能的企业网盘，不仅可以优化团队的工作方式，还能为企业在更大的范围内实施协作战略提供技术基础。</p><p>以Zoho网盘为例，它用细腻的功能设计满足技术团队的各种需求，从文件共享到权限管理，从版本控制到数据安全，一步步帮助我们告别传统工作模式中的沟通滞后、数据丢失和低效协作。如果你正在寻找一个能够提升技术团队效率的工具，那么企业网盘，尤其是Zoho网盘，会是一个值得关注的选择！</p><p>“协作是科技的基石，而企业网盘是通向协作之路的桥梁。”</p><p>让我们从今天开始，重新定义团队的工作方式，用科技赋能效率，用协作成就卓越！</p>]]></description></item><item>    <title><![CDATA[干货推荐：分钟级定位 IO 瓶颈，多租户]]></title>    <link>https://segmentfault.com/a/1190000047440773</link>    <guid>https://segmentfault.com/a/1190000047440773</guid>    <pubDate>2025-12-01 14:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3>背景</h3><p>随着云上规模持续扩张，AI 训练数据、实时日志、多媒体内容等数据类型呈指数级增长，推动云存储成为主流选择，同时也带来了 IO 请求量的急剧上升。在多租户云环境中，多个用户共享底层存储资源，高并发访问容易引发 IO 资源争抢，造成性能瓶颈。此外，混合云和多云架构的广泛应用，使得数据在不同云平台间频繁流动，而各异的存储策略和监控体系进一步增加了 IO 问题的排查与定位难度。为了进一步提升问题的解决效率，阿里云操作系统控制台聚焦高频的 IO 异常场景，构建了从问题发现，根因诊断到解决方案的 IO 一键诊断能力。</p><h3>业务痛点解析</h3><h4>痛点1：问题类型只是能力缺失</h4><p>用户普遍缺乏对 IO 异常类型的识别能力（如区分 IO 延迟高还是打满问题），导致无法自主调用针对性诊断工具，必须依赖运维人员介入定位，导致诊断流程效率低下，增加了人力成本。一键诊断能够聚焦于 IO 延迟高、IO 流量异常、iowait 高等几类出现频次高的问题，捕捉 IO 子系统相关的异常，帮助用户快速自动地识别问题类型。</p><h4>痛点2：问题现场丢失与取证困难</h4><p>目前传统监控普遍集成了 OS 的 IO 相关指标，如 await、util、tps、bps 等，同时会依赖指标的突变作为告警依据，但是当指标异常时可能已错过问题发生的窗口期，没法再去针对性地抓取更多帮助信息，获取关键诊断证据（如细粒度的必要辅助信息）。所以快速识别问题并采取相应的措施，是把握住最佳诊断时机的关键。</p><h4>痛点3：监控指标割裂与诊断关联弱</h4><p>现有监控指标体系存在"数据孤岛"现象，各指标独立存在，并且与具体 IO 问题类型缺乏直观的映射关系。例如在 util 指标（硬盘设备的繁忙比率）偏高的时候，往往需关联观察 await 等多个指标，同时结合磁盘 iops、bps 的理论上限来综合判断问题。即使识别出了问题类型，也需要对相应诊断工具有使用方法相关的先验知识，考虑如何根据监控指标的数值来设置诊断参数，而 IO 一键诊断旨在能够屏蔽了这些复杂的关联流程，直抵分析报告。</p><h3>解决方案</h3><h4>架构介绍</h4><p>「阿里云操作系统控制台」提供的 SysOM 管控组件已具备应对 IO 延迟高，IO 流量异常，iowait 高等几类问题的诊断能力，但是客户往往不会允许在机器上常态化执行诊断工具去不停地抓取信息。因此，IO 一键诊断设计为在诊断时段内，周期性读取 IO 监控指标数据来检测异常，定界问题，到最后触发子诊断工具输出报告的模式，实现“发现问题-&gt;诊断问题-&gt;根因分析”的自闭环。</p><p>由于不同的业务场景，关注的指标阈值会不一样，如果统一一个静态阈值覆盖各种场景，很可能引起异常的误报或者漏报，因此 IO 一键诊断通过动态阈值来识别异常，总体架构图设计如下图所示：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047390543" alt="图片" title="图片"/><br/>IO 指标监控：从系统获取 IO 的关键指标，例如 await、util、tps、iops、qu-size、iowait。</p><p>异常识别：当采集到的 IO 指标大于动态阈值时，判定为异常，因此异常识别的核心在于动态阈值的计算，具体算法将在下文解释。</p><p>异常诊断：根据不同的指标异常，触发对应的诊断工具，并且会对触发频率做了一定的限制。</p><p>数据清洗&amp;可视化：根据诊断结果呈现出可视化的输出，给出根因和解决建议。</p><h4>实现原理</h4><p>指标采集</p><p>触发一键诊断后，每间隔cycle毫秒（数值可配置）会读取并计算iowait、iops、bps、qusize、await、util等指标的值，并检查是否有异常。</p><p>动态阈值计算<br/>为了能够识别秒级的 IO 异常行为，需要将系统中采集到的各个孤立的 IO 指标聚合起来，形成对 IO Burst 等问题的监控能力，这个过程的核心在于动态阈值的计算，动态阈值经过三步计算得到：基础阈值计算，补偿阈值计算以及最小阈值计算。</p><p>基础阈值计算<br/>IO 指标其实是一种时间序列，而且一般地，在一个时间区间内，可以认为绝大部分时间是没有异常的，因此序列形成的曲线趋势是趋于平稳的，当出现异常的时候，会产生一个明显偏离平稳趋势的尖峰，因此第一步要做的就是通过本节计算得到的基础阈值把 IO 指标中的尖峰毛刺筛选出来。</p><p>我们通过动态窗口持续观察数据，计算窗口内数据的最大偏离平均值作为“瞬时波动值”。然后，将所有“瞬时波动值”的平均值作为“基础阈值”。这个阈值会持续自适应地更新，以反映数据最新的波动特征。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390544" alt="图片" title="图片" loading="lazy"/></p><p>补偿阈值计算基础阈值曲线（如下图中的黄色曲线）反映的是真实 IO 指标数据的波动情况，但是 IO 指标在平稳状态下往往是限于一个范围内波动，所以需要计算一个补偿阈值，叠加到基础阈值上会减缓基础阈值的快速下降，而从而减少带来误报的情况。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390545" alt="图片" title="图片" loading="lazy"/></p><p>当基础阈值持续下降一段时间后，可以认为系统进入“常态稳定”模式。此时，我们会过滤掉明显的噪音数据，并在剩余的“安静”数据中，计算一个“常稳态补偿值”来衡量这种稳定状态下的微小波动。在“常稳态补偿值”正式计算出来之前，我们会临时用当前窗口最大的基础阈值作为补偿值，并且在每个新窗口开始时都重置。一旦基础阈值停止下降或反弹，该机制将重置，回归更宏观的观察模式。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390546" alt="图片" title="图片" loading="lazy"/></p><p>最小阈值<br/>最小静态阈值是一个预先设定好的最低门槛，。最终的异常判定阈值为 “最小静态阈值” 和 “动态调整阈值（基础阈值 + 补偿值）” 两者中的最大值，确保只有同时超过业务容忍底线和系统动态波动范围的数据才被视为异常。</p><p>特别地，如果数据已超出“最小静态阈值”，则“动态调整阈值”的计算会简化，不再考虑“常态补偿值”，直接使用“基础阈值”作为判断依据，以聚焦更明显的异常情况。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390547" alt="图片" title="图片" loading="lazy"/></p><p>异常识别<br/>当采集到的 IO 指标大于动态阈值时判定为异常。不同异常类型虽有各自的判断算法，但都遵循以下原则：</p><ul><li>确定警戒线： 设定一个“指标警戒线”，取 “最小静态阈值”（业务容忍的最低门槛）与“动态阈值”（系统根据历史数据计算的正常波动范围）中的最大值。</li><li>触发诊断： 若当前指标值超过此“警戒线”，且监测和诊断条件满足，则立即启动诊断。</li><li>动态学习： 系统会持续根据最新的指标数据，更新并调整“动态阈值”，使其始终反映指标的正常波动范围。</li></ul><p>智能诊断</p><p>当系统监测到 IO 异常时，一键诊断工具能够自动调用诊断功能，及时抓取和分析关键信息，快速定位问题。为避免诊断过于频繁，我们通过以下参数进行频率控制：</p><ul><li>“诊断冷静期”（triggerInterval）： 设定两次诊断之间的最短间隔，确保系统不会在短时间内重复诊断。</li><li>“异常堆积计数器”（reportInterval）： 控制诊断发起的条件。若为0，则异常发生且过了冷静期即可诊断；若不为0，则需在冷静期过后，且在规定时间内积累了足够数量的异常事件，才触发诊断。</li></ul><p>根因分析<br/>在诊断工具抓取了信息之后，面对各种信息，从何处着手，也令人困扰，因此瞄准方向，进行专业的分析、剥丝抽茧地从中筛查跟问题相关的线索显得非常重要；IO 一键诊断则具备这个抽丝剥茧的分析能力，并且能够汇报跟问题相关的结论性信息：</p><ul><li>对于 IO Burst 异常，经过分析后，在监控的日志栏中汇报异常期间贡献IO最多的进程，其中极具特色的是，对于写 buffer io 后由 kworker 刷脏的情况，也能分析出来是哪个进程在写 buffer io。</li><li>对于 IO 高延迟异常，经过分析后，在监控的日志栏中汇报异常期间 IO 的延迟分布，输出 IO 延迟最大的路径。</li><li>对于 iowait 高异常，经过分析后，在监控的日志栏中汇报触发 iowait 高的进程、以及触发原因。</li></ul><p>案例分析</p><p>iowait 高</p><p>对于 iowait 高异常场景，IO 一键诊断可以直接定位到等待磁盘 IO 的进程来源以及等待时长，分析阻塞的原因。以下案例即是诊断出业务场景 IO 压力过大，脏页过多过多，导致业务进程 task_server 等待 IO 时长过长的问题。对此场景，报告中也提出谨慎地调整 dirty_ratio和dirty_bytes 参数，来减少刷脏压力，从而缓解 IO 压力的建议。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440789" alt="图片" title="图片" loading="lazy"/></p><p>IO 延迟高</p><p>用户通过监控发现机器上 IO 写流量出现了延迟比较高的现象，我们建议他尝试通过 IO 一键诊断来判断根因。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390548" alt="图片" title="图片" loading="lazy"/></p><p>在用户执行的结果中，诊断识别到了是 DiskBlockWrite 进程产生的 IO 压力，主要延迟集中在磁盘刷脏，帮助用户查到了延迟根因。对此，我们在结果中建议用户尝试减少 buffer IO 的写入或者调整机器上的配置的 dirty_ratio 和 dirty_background_ratio 参数数值，来缓解 IO 延迟高的问题。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390549" alt="图片" title="图片" loading="lazy"/></p><p>联系我们 </p><p>您在使用操作系统控制台的过程中，有任何疑问和建议，可以搜索群号：94405014449 加入钉钉群反馈，欢迎大家扫码加入交流。</p><p>阿里云操作系统控制台PC端链接：<a href="https://link.segmentfault.com/?enc=tuhLgWJ2kIVfFxQygoghrw%3D%3D.tXs2hmOEAd%2BpqdhC6qUsnIMMB1whK4Zyi%2FOW%2BglxWpLx0xnZMhxd6LLWa1S0MyJo" rel="nofollow" target="_blank">https://alinux.console.aliyun.com/</a></p>]]></description></item><item>    <title><![CDATA[国内打开国外网站很慢是什么原因？如何解决]]></title>    <link>https://segmentfault.com/a/1190000047440631</link>    <guid>https://segmentfault.com/a/1190000047440631</guid>    <pubDate>2025-12-01 13:02:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>因为地区和网络的限制原因，在国内访问国外网站大部分很慢或者有些的直接打不开，需要借助科学上网工具才能访问，这对于外贸人员来是最基本的工具了。</p><p>目前，企业级、合规访问国际网络主要有两种方式：</p><p>① 传统国际网络专线</p><p>② SD-WAN 国际专线</p><p>一、传统国际网络专线(IEPL/MPLS 国际专线)</p><ol><li>什么是传统国际专线?</li></ol><p>传统国际网络专线(如 IEPL、MPLS)是运营商提供的点对点或点到多点的跨境通信线路。属于官方许可、可备案、面向企业级的合规国际通信方式。</p><p>简单理解：</p><p>运营商拉一条“独享高速通道”，从国内机房直连你在海外的服务器或节点。</p><ol start="2"><li>核心特点<br/><img width="723" height="217" referrerpolicy="no-referrer" src="/img/bVdndDw" alt="截屏2025-12-01 12.02.18.png" title="截屏2025-12-01 12.02.18.png"/></li><li>适用场景</li></ol><p>适合金融、医疗等敏感行业</p><p>高要求场景：低时延、强稳定、可审计</p><p>二、SD-WAN 国际专线(软件定义国际网络)</p><ol><li>什么是 SD-WAN 国际专线?</li></ol><p>SD-WAN 是一种智能网络组网技术，通过软硬件终端 + 多线路融合，让企业可以灵活、成本更低地连接海外网络。</p><p>相比传统专线，它不是单一的物理线路，而是：</p><p>在合规基础上，通过智能路由、多线叠加、QoS 优化，实现跨境网络稳定访问。</p><p>一般使用：</p><p>三大运营商合规出口、海外节点、智能调度引擎</p><p>构成一个 可控、可监测、可审计的企业级跨境网络通道。</p><ol start="2"><li>核心特点</li></ol><p><img width="723" height="216" referrerpolicy="no-referrer" src="/img/bVdndDx" alt="截屏2025-12-01 12.02.46.png" title="截屏2025-12-01 12.02.46.png" loading="lazy"/></p><ol start="3"><li>适用场景</li></ol><p>外贸企业访问海外平台(Google、Meta、WhatsApp、HubSpot 等)</p><p>跨境电商运营(亚马逊、TikTok、独立站)</p><p>海外社媒营销、广告账户管理、跨境直播、视频会议（如zoom）等等场景，性价比高。</p><p>三、SD-WAN国际网络专线怎么开通使用？哪家服务商好？</p><p>下面以OSDWAN为例，给大家介绍怎么开通，简单三步：</p><p>1、确认自身的需求</p><p>比如您是做什么业务的，需要使用国外的哪些平台以及国家，是外贸办公、还是社媒运营，或者是做Tk直播的，不同的场景我们OSDWAN提供不同的套餐，直播的话建议使用专线，最低5M以上的带宽。</p><p>2、选择合适的服务商</p><p>OSDWAN是国内专业的跨境网络专线服务商，提供合规稳定的网络专线，并且是通过工信部备案的，拥有合法资质的，走的是跟三大运营商一样的线路，灵活性高，性价比高，咨询我们的顾问选择合适的套餐，开通账号即可登录连接。</p><p>3、登录使用</p><p>下面以电脑端使用界面为例，手机等设备操作类似。</p><p>账号登录成功后：</p><p>第一步：选择线路，比如有美国、新加坡、日本、香港等等。</p><p>第二步：不同模式对于重大加速软件不同。</p><p>第三步：点击连接，连接成功就可以访问国际网络了。</p><p><img width="720" height="452" referrerpolicy="no-referrer" src="/img/bVdndDy" alt="image.png" title="image.png" loading="lazy"/></p><p>下面以访问Google为例，能使用Google正常搜索那么其他国外软件也都能访问了。</p><p><img width="720" height="315" referrerpolicy="no-referrer" src="/img/bVdndDz" alt="image.png" title="image.png" loading="lazy"/></p><p>OSDWAN有哪些优势？<br/>相较于传统的SD-WAN服务商，OSDWAN跨境网络专线也有极大突出优势：更好用、更高性价比、更安心。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440633" alt="图片" title="图片" loading="lazy"/></p><p>01、更好用：相比传统SD-WAN服务商只支持CPE设备，OSDWAN不仅支持多种型号的CPE设备，还支持经过安全认证的相应软件。支持Windows、Mac、iPhone、安卓、iPad，让您随时随地一键连接全球互联网。</p><p>02、更高性价比：相比传统SD-WAN服务商与运营商接近的高额网络费用，OSDWAN仅需一半不到的成本即可享受同等优质的网络线路。</p><p>03、更安心：相比传统SD-WAN服务商需要5-8个工作日按照工单解决客户问题，OSDWAN提供专属售后支持，配备专属售后顾问。同时还提供分流解锁，路由优化等服务。让您的业务安心出海。</p><p>OSDWAN兼具合规合法、稳定安全、简单易用、高性价比等优势，支持一键访问全球互联网。是企业办公、网络营销、跨境直播的不二之选。</p><p>OSDWAN提供高质量SD-WAN线路和原生本土IP，支持手机/电脑/路由器多种设备。专线费用不到营业厅的一半，已有10000+用户通过OSDWAN连接全球。</p>]]></description></item><item>    <title><![CDATA[SD-WAN国际专线怎么购买？哪家SD-]]></title>    <link>https://segmentfault.com/a/1190000047440638</link>    <guid>https://segmentfault.com/a/1190000047440638</guid>    <pubDate>2025-12-01 13:02:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着企业越来越全球化——无论是跨国子公司、海外云资源接入，还是跨境电商、出海团队办公——网络连接的重要性愈发凸显。传统国际专线（如 MPLS）固然稳定，但成本高、部署慢、灵活性差。近年来，SD-WAN 国际专线成为一种非常有吸引力的替代方案，既保持较低时延、较高稳定性，又比传统专线更灵活可扩展。</p><p>本文将介绍什么是 SD-WAN 国际专线、适合哪些场景、主流服务商有哪些，以及如何选合适的服务商。其中，我们还特别推荐 OSDWAN（明点跨境） 这一国内较有特色的服务商，并分析为什么值得考虑。最后还帮你梳理一些购买和落地时常遇到的问题。</p><p>一、SD-WAN 国际专线是什么？哪些场景需要？<br/>SD-WAN（软件定义广域网） 是一种通过软件层（controller /管理层）来动态管理多个底层链路（如互联网、MPLS、4G/5G 等），实现智能选路、流量调度、加密隧道等功能。<br/>“国际专线”＋“SD-WAN”结合后，意味着企业可以构建一个跨国 / 跨地区的“专用逻辑网络”：虽然底层可能是公共互联网链路，但通过 SD-WAN 的覆盖、加密和策略管理，实现类似传统专线的稳定性和性能。<br/>SD-WAN 专线还可以混用多条链路，如互联网 + MPLS + 4G，做到冗余、高可用。<br/>为什么需要SD-WAN国际专线？</p><p>企业选择 SD-WAN 国际专线，通常基于以下几类业务需求：</p><p>跨境办公</p><p>海外子公司、分支机构、远程团队需要和总部或其他分支进行低延迟通信。</p><p>云 / SaaS 接入</p><p>公司使用海外云(如 AWS、Azure、GCP)或 SaaS(Salesforce、Office 365 等)，希望通过优化网络路径提高访问体验。</p><p>全球化业务</p><p>跨境电商、品牌出海、海外技术团队、跨国生产制造等，数据要在多个国家 / 地区之间传输。</p><p>成本与灵活性考虑</p><p>传统 MPLS 专线成本高、开通慢;SD-WAN 国际专线则可以更灵活扩容、按需调度。</p><p>网络弹性与高可用性</p><p>通过多链路冗余 + 智能选路，实现链路中断时快速切换，提升业务连续性。</p><p>安全性要求</p><p>使用加密隧道(如 IPSec)保护跨国传输的数据，还能集中管理策略、流量优先级等。</p><p>二、SD-WAN 服务商排行榜</p><p><img width="723" height="1726" referrerpolicy="no-referrer" src="/img/bVdm1ZO" alt="image.png" title="image.png"/><br/>注：以上排名来自明点企服SaaS点评网，排序根据产品评分、站内外热度综合计算得出，会不断发生变化，截取日期为2025年4月22日</p><p>三、主流 SD-WAN 服务商介绍<br/>下面详细介绍几家在国际专线 /跨国 SD-WAN 方面比较靠谱的服务商。</p><p>1、三大运营商</p><p>中国电信：凭借全国最大网络基础设施资源，中国电信在SD-WAN建设中具备天然优势，其端到端网络服务能力保障了政企客户对高可用性、高稳定性的严苛要求。</p><p>中国移动：作为国内移动网络领导者，中国移动在SD-WAN架构中实现了对5G链路的高效融合，在零售、制造等场景中展现出极强的灵活性和冗余能力。</p><p>中国联通：中国联通在SD-WAN的跨境组网服务方面具有显著优势，尤其在“一带一路”相关地区设有大量网络节点。</p><p>2、第三方专业服务商</p><p>OSDWAN明点跨境</p><p>OSDWAN作为国内专业的跨境网络服务商，为出海企业提供合规、高速、稳定的网络解决方案，支持硬件、软件方案灵活部署。</p><p>OSDWAN在全球的数据中心节点50个，POP节点超过200个，可以为出海企业提供海外加速、SaaS加速、SD-WAN组网、跨境组网、云专线等产品服务，助力中国企业开拓国际市场。</p><p>适用于社媒运营、TK直播、学术科研、跨境电商、品牌出海、外贸出口等各类行业场景。</p><p><img width="722" height="647" referrerpolicy="no-referrer" src="/img/bVdndDI" alt="image.png" title="image.png" loading="lazy"/></p><p>腾讯云SD-WAN</p><p>腾讯云SD-WAN 接入服务(SD-WAN Access Service)助力多分支轻松实现与云、数据中心的任意互联，具有即插即用、多地域覆盖、智能管控等特性，为企业多分支提供了更简单、可靠、智能的一站式上云的体验。</p><p>四、如何选择合适的 SD-WAN 服务商？<br/>结合业务需求和技术特点，选 SD-WAN 服务商可以按照以下几个维度来评估：</p><p>1、业务需求分析</p><p>需要多大带宽、用于什么业务（TK直播、社媒运营、多账号矩阵等）</p><p>2、计费模式</p><p>是按带宽、按流量，还是混合计费？哪个模型对你更划算。</p><p>收费灵活性如何，可按月、按季度、按年付吗?</p><p>3、可靠性与 SLA</p><p>服务商能否保证丢包率、延迟、可用性 (SLA)?</p><p>是否支持链路冗余 (多链路 +智能 failover)?</p><p>4、安全性</p><p>是否使用加密隧道 (如 IPSec)?</p><p>是否提供云端 /设备端安全能力 (防火墙、IPS、访问控制等)?</p><p>五、SD-WAN服务商哪家好？推荐 OSDWAN<br/>综合考虑价格、灵活性、覆盖和本地服务能力， OSDWAN 是国内 /出海企业在选择 SD-WAN 国际专线时非常值得重点考虑的方案：</p><p>高性价比：基础版 (690 元/年起)，适用于AI应用加速、外贸办公等场景。<br/>灵活计费：支持按月、季度、年度收费，适合不同业务的企业。<br/>全球布局：其 POP 节点覆盖200+个国际重要节点，能为跨境业务提供较为稳定的网络连接。<br/>合规可靠：OSDWAN提供合法合规的跨境网络专线，通过工信部备案的拥有合法资质的服务商。<br/>快速部署：结合SD-WAN 的架构优势，当日即可开通，一分钟即可连接使用。<br/>因此，如果中国企业，有跨境业务、出海电商、海内外分支需要互联，建议优先优先OSDWAN。</p><p>六、SD-WAN专线常见问题<br/>问：SD-WAN 是否能完全替代 MPLS?</p><p>答：不一定。SD-WAN 优势在灵活、弹性、成本，但对于某些对时延 / SLA 要求极高 (如金融、实时交易) 的业务，可能仍然需要 MPLS 或混合方案。</p><p>问：SD-WAN 和传统 VPN (如 IPsec VPN) 有什么区别?</p><p>答：传统 VPN 是在公共互联网基础上建隧道，功能较为基础;但 SD-WAN 除了加密隧道，还能做路径选择、QoS、策略控制。</p><p>问：部署周期多久?</p><p>答：相比 MPLS 专线 (可能需要数周或数月)，OSDWAN的专线当日即可开通，一分钟即可连接使用。</p><p>问：价格大致范围是多少?</p><p>答：具体取决于带宽、链路类型、计费方式。</p><p>问：是否存在安全隐患?</p><p>答：只要服务商正确实现加密隧道 (如 IPSec)、策略管理、冗余链路，并提供监控，就可以较好保证安全。但选择时应重点考察服务商的安全能力与 SLA。</p><p>问：如果业务变化 (扩容 ) 怎么办?</p><p>答：大多数 SD-WAN 服务商都支持灵活扩容 (调整带宽、链路类型);你可以根据业务来调整订阅 /服务。</p><p>结语<br/>总之，SD-WAN 国际专线是现代企业跨国 /跨境网络连接非常有效的新方案。它既能降低传统专线成本，又能兼顾性能和灵活性。如果你的公司有跨境办公、全球受众、云接入等需求，非常值得认真考虑 SD-WAN。选服务商时，要看技术能力、网络覆盖、计费灵活性、安全性和合规性。</p>]]></description></item><item>    <title><![CDATA[2024最新贪心科技-大模型开发应用实战]]></title>    <link>https://segmentfault.com/a/1190000047440667</link>    <guid>https://segmentfault.com/a/1190000047440667</guid>    <pubDate>2025-12-01 13:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在大模型技术席卷各行各业的今天，👇🏻ke🍊：xingkeit点top/9645/许多学习者陷入了"纸上谈兵"的困境——了解概念却无法实战，知道技术却不会应用。30天系统化实战训练，正是打通从理论到实践的关键路径，让学习者完整掌握大模型应用开发的核心能力。</p><p>第一周：掌握与大模型对话的艺术——Prompt工程的精髓<br/>基础奠基：从零理解Prompt机制<br/>大模型并非神秘的黑箱，而是需要精确指令的"智能大脑"。第一周的训练从理解Prompt的基本结构开始，探索如何通过系统提示词、示例演示、格式约束等要素，让模型理解我们的真实意图。</p><p>场景化实战：四大核心技巧</p><p>角色扮演技巧：通过赋予模型特定身份（如资深律师、医学专家），获得专业领域的精准回答</p><p>思维链引导：使用"逐步思考"等技巧，让模型展示推理过程，提升答案的准确性和可信度</p><p>结构化输出：约束模型按照JSON、XML等特定格式输出，便于后续程序处理</p><p>动态上下文管理：学会在长对话中维护上下文一致性，避免模型"遗忘"重要信息</p><p>超越基础：高级Prompt模式<br/>深入学习少数示例、思维树等先进技术，理解如何在复杂问题中引导模型进行深度推理，突破基础Prompt的性能瓶颈。</p><p>第二周：构建企业级知识大脑——RAG系统实战<br/>从理论到架构：构建可对话的知识库<br/>传统的企业知识管理系统正在被RAG技术重新定义。第二周重点演练如何将静态文档转化为可智能问答的知识系统。</p><p>完整实现流程：</p><p>文档解析与预处理：处理PDF、Word、网页等多格式文档，解决表格、代码块等特殊内容的提取难题</p><p>文本向量化核心：理解嵌入模型的工作原理，将文本转化为数学向量，构建企业的"数字记忆"</p><p>智能检索优化：实践相似度检索、混合搜索等策略，确保快速精准定位相关信息</p><p>生成环节调优：设计合理的提示模板，让模型基于检索内容生成准确、可靠的回答</p><p>工程化思维培养：<br/>重点突破RAG系统中的实际挑战：如何处理文档更新？怎样评估检索质量？如何应对"幻觉"问题？这些工程细节正是企业应用成败的关键。</p><p>第三周：打造专属领域专家——模型微调深度实践<br/>何时需要微调：技术选型智慧<br/>深入理解微调与Prompt工程、RAG的适用场景差异。当需要模型掌握独特风格、专业术语或复杂推理模式时，微调成为不可替代的选择。</p><p>全流程实战：</p><p>数据准备艺术：学习构建高质量的指令微调数据集，理解数据质量对模型性能的决定性影响</p><p>训练策略选择：实践LoRA等参数高效微调方法，在效果与成本间找到最佳平衡点</p><p>评估体系建立：超越简单的准确率指标，构建多维度的模型能力评估体系</p><p>迭代优化循环：基于评估结果持续改进数据质量和训练策略，实现模型性能的稳步提升</p><p>避坑指南：<br/>分享实践中常见的失败案例：过拟合的识别与应对、灾难性遗忘的预防、训练不稳定的调试技巧，让学习者少走弯路。</p><p>第四周：迈向自主智能——AI智能体开发实战<br/>智能体范式转变：从工具到伙伴<br/>智能体代表了大模型应用的未来方向——不再是简单的问答工具，而是能够自主规划、执行复杂任务的数字伙伴。</p><p>核心能力构建：</p><p>任务分解与规划：训练智能体将复杂目标拆解为可执行步骤，形成合理的行动计划</p><p>工具使用能力：集成搜索引擎、计算器、API接口等外部工具，扩展智能体的能力边界</p><p>记忆与反思机制：设计智能体的长期记忆系统，使其能够从历史交互中学习改进</p><p>安全护栏设计：建立约束机制，确保智能体行为符合安全规范和伦理要求</p><p>典型场景实战：<br/>通过客户服务智能体、数据分析智能体、个人助理智能体等实际案例，掌握智能体设计的通用模式和特定领域的最佳实践。</p><p>从学习到创造：工程思维的升华<br/>30天的实战之旅，收获的远不止技术技能：</p><p>系统化思维培养：<br/>理解Prompt工程、RAG、微调、智能体这四大技术如何相互配合，形成完整的大模型应用技术栈。学会根据具体需求选择最合适的技术组合。</p><p>工程化能力提升：<br/>掌握大模型应用的完整生命周期管理——从需求分析、技术选型、实现调试到部署运维。建立质量保障意识，确保应用的可靠性和稳定性。</p><p>业务价值导向：<br/>培养将技术能力转化为业务价值的关键思维。无论是提升企业内部效率，还是创造新的产品服务，都能够精准把握技术应用的商业逻辑。</p><p>持续学习基础：<br/>建立扎实的技术基础和理解框架，为快速适应这个日新月异的领域做好准备，具备持续自学和跟进最新进展的能力。</p><p>这30天的价值，在于完成从被动学习到主动创造的转变，从技术理解到价值实现的跨越。当您能够独立设计并实现满足复杂需求的大模型应用时，您已经在这个充满机遇的新时代占据了有利位置。</p>]]></description></item><item>    <title><![CDATA[2025主流音视频厂商选型指南 看点 ]]></title>    <link>https://segmentfault.com/a/1190000047440260</link>    <guid>https://segmentfault.com/a/1190000047440260</guid>    <pubDate>2025-12-01 12:05:33</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>2025主流音视频厂商选型指南<br/>在数字时代，音视频技术已成为重要的基建工程。然而，面对众多音视频厂商，如何选出最适合自己的，并非易事。面对各厂商的宣传，究竟谁的硬实力更强，谁更契合自身业务场景？这份指南聚焦2025年国内主流音视频厂商，摒弃虚浮宣传，对比核心技术和实际场景表现，助你在最短时间内把握关键，做出明智选择。</p><p>2025年主流音视频厂商盘点<br/>云屋科技<br/>云屋科技作为全球领先的实时音视频云服务提供商，在2025年依旧保持技术领先地位。</p><p>全自研引擎：拥有具备完全自主知识产权的音视频引擎，即使在80%丢包的环境下，仍能保障通话流畅。</p><p>超低延迟：其全球智能调度网络可实现端到端平均延迟小于200ms，达到行业标杆水平。</p><p>AI对话式交互：具备实时语音识别与语义理解能力，可驱动高效自然的人机对话。</p><p>全球覆盖：拥有500多个全球节点，服务覆盖200多个国家和地区。</p><p>腾讯云TRTC<br/>依托腾讯强大的生态体系，腾讯云TRTC在社交、游戏场景中具有独特优势，与微信、QQ等产品的集成能力是其核心竞争力。</p><p>生态整合：与微信、QQ等腾讯系产品深度集成，支持小程序优化。</p><p>社交优势：在社交、游戏场景表现出色，能够支持高并发场景。</p><p>产品协同：可与腾讯云其他产品形成完整解决方案。</p><p>阿里云RTC<br/>凭借阿里云的基础设施优势，阿里云RTC为企业提供一站式音视频解决方案，在电商、企业服务场景中表现突出。</p><p>基础设施：依托阿里云全球2800多个边缘节点，基础设施十分强大。</p><p>电商优化：针对电商直播场景进行专项优化，效果显著。</p><p>弱网对抗：采用智能抗丢包技术，在60%丢包率的情况下仍可保持通话。</p><p>AI集成：深度集成智能美颜、语音识别等AI能力。</p><p>声网（Agora）<br/>作为实时互动云服务的开创者，声网在技术积累和客户规模方面保持优势，其SD - RTN全球网络持续优化。</p><p>全球网络：自主研发的SD - RTN全球实时网络，具备智能路由优化功能。</p><p>音频技术：采用3D空间音频技术，可创造沉浸式听觉体验。</p><p>视频能力：支持4K超高清视频传输，具备自适应码率控制能力。</p><p>生态完善：拥有成熟的开发者社区和完善的技术文档体系。</p><p>融云<br/>融云提供音视频 + IM + 白板等一体化解决方案。</p><p>技术积累：整合了20余年的音视频技术积累，底蕴深厚。</p><p>弱网对抗：在80%丢包环境下仍能保持可用通信，抗丢包能力强。</p><p>教育方案：音视频 + IM + 白板一体化教育解决方案完善。</p><p>音质优化：可保障1080P高清视频和48kHz高保真音质。</p><p>火山引擎<br/>承载抖音等产品的音视频技术积累，火山引擎在视频处理、智能推荐等方面具有独特优势。</p><p>技术验证：承载了抖音等亿级用户产品的技术积累，经过海量验证。</p><p>视频处理：超高清视频编码优化，智能视频增强技术领先。</p><p>推荐算法：具备独特的智能内容推荐能力，可提升用户体验。</p><p>六大厂商核心能力对比<br/>为确保线上交互达到最佳体验，选择音视频厂商时应重点关注五大关键能力：全球覆盖的网络、先进的编解码、智能的音视频增强、优异的延时表现以及对业务场景的精准适配度。以下是服务选型与对比的核心依据：</p><p>能力维度    云屋科技    腾讯云<br/>阿里云    声网    融云    火山引擎    <br/>全球网络覆盖    强：拥有自研引擎和全球网络，自主调度和容灾能力出色    强：依托腾讯全球基础设施，与微信等生态协同，覆盖范围广    强：基于阿里云全球领先的云计算基础设施，服务稳定性和可用性高    强：以软件定义实时网为核心，专为实时互动优化，全球节点丰富    中强：具备全球服务能力，但更聚焦深耕领域    中强：依托字节跳动的全球基础设施，在娱乐和社交区域覆盖良好    <br/>音视频编解码能力    强：自研引擎通常对编解码有深度优化，并结合AI增强提升效率    强：集成腾讯多媒体实验室的先进技术，对标准编解码器深度优化    强：基于强大的云基础，在标准编解码和转码处理方面能力扎实    强：深度优化抗弱网与抗丢包编解码，技术遵循国际标准，体验较好    强：编解码技术成熟，抗弱网性能强，保障实时通话流畅清晰    强：继承抖音在视频压缩和传输方面的技术，尤其在移动端优化出色    <br/>音视频增强功能    技术前沿：具备AI增强、纯净细腻音质、超分技术，AI功能突出    生态集成强：功能全面，与微信小程序等腾讯生态的集成是特殊优势    场景化强：在电商场景优化（如试妆、虚拟背景）方面有针对性功能    丰富：通过虚拟背景、美颜等特效，精准赋能在线教育、直播电商等多元场景    垂直领域强：核心优势在于游戏语音优化（如3D语音、听声辨位）    智能推荐结合：功能全面，且能与智能推荐等算法结合，提供差异化体验    <br/>延时表现    极优：端到端延迟＜200ms，表现最佳，采用场景化AI音频处理策略，无感切换至最佳音质，实时体验卓越    优：端到端延迟200 - 400ms，可支持低延时直播场景，与TRTC产品结合    优：端到端延迟200 - 400ms，标准化的低延时直播方案成熟稳定    优：端到端延迟200 - 300ms，依托SD - RTN网络，在实时性和稳定性上平衡良好    优：端到端延迟200 - 400ms，能满足游戏直播、教育直播等大部分低延时需求    优：端到端延迟200 - 350ms，基于抖音大规模实践，在高并发直播场景下表现可靠    <br/>典型应用场景    社交、教育、IoT    社交、游戏    电商、办公    社交、教育    游戏、教育    娱乐、社交    <br/>各厂商核心定位<br/>腾讯、阿里、火山引擎：依托庞大云生态，提供一站式、标准化的通用解决方案。</p><p>声网、融云：深耕音视频垂直赛道，在特定场景与体验优化上更具深度。</p><p>推荐云屋科技的理由<br/>全球极致低延时：端到端延迟＜200ms，树立实时互动体验新标杆。</p><p>全链路自研技术：从音视频引擎、全球网络到AI算法全部自主可控，安全稳定。</p><p>领先AI增强体验：集成超分、悦音等先进处理技术，显著提升音视频质量。</p><p>结论<br/>在追求极限低延迟、卓越音画质与高度技术可控性的场景下，云屋科技是更为专业和可靠的选择。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440262" alt="" title=""/></p><p>常见问题解答FAQ<br/>Q1：如何测试各家厂商宣传的“抗丢包”和“低延迟”效果是否真实？<br/>解决方案：</p><p>要求POC测试：不要仅看数据，务必申请正式试用，进行概念验证测试。</p><p>模拟真实网络：在测试环境中，使用网络模拟工具主动制造不同比例的丢包、抖动和延迟，直观感受通话质量。</p><p>关注关键指标：在测试后台重点关注端到端延迟、视频卡顿率、音频断断续续等核心指标，而非单一的丢包率。</p><p>Q2：我们的业务用户遍布全球，如何确保海外用户的体验？<br/>解决方案：</p><p>核查全球节点：仔细询问厂商其海外数据中心的分布和数量，特别是与你目标用户区域的重合度。</p><p>测试全球路由：选择支持全球智能路由调度的厂商（如云屋、声网），确保用户能自动接入最优节点。</p><p>了解合规性：确认厂商在目标地区的数据合规性（如GDPR），避免法律风险。</p><p>Q3：初创公司预算有限，如何平衡成本与性能？<br/>解决方案：</p><p>明晰计费模式：了解是按时长、流量还是峰值人数计费，选择最符合你业务模型的方案。</p><p>善用套餐包：云屋、腾讯云等常提供具有价格优势的套餐包，适合用量可预测的场景。</p><p>关注“技术溢价”：如果低延迟和高稳定性是你的核心价值（如在线教育、金融客服），云屋等厂商的技术优势带来的用户体验提升，其“溢价”是值得的。</p><p>Q4：除了音视频通话，我们还需要IM、白板、录制等功能，如何选择？<br/>解决方案：</p><p>评估一体化方案：优先考虑能提供“音视频 + IM + 白板”一站式解决方案的厂商（如云屋科技、融云），可以大幅降低集成复杂度和联调成本。</p><p>检查API兼容性：即使选择不同厂商的组合，也要确保它们的API能够顺畅对接，避免出现“信息孤岛”。</p><p>考虑数据打通：一体化方案通常能更好地实现各模块间的数据联动（如白板与录制回放同步）。</p><p>Q5：集成SDK后，在实际用户环境中遇到偶发的卡顿、杂音问题，如何快速定位？<br/>解决方案：</p><p>利用质量监控平台：选择提供完善质量监控与回溯平台的厂商，能够快速查询每次通话的详细质量数据，定位是网络问题、设备问题还是服务端问题。</p><p>集成客户端日志：确保在SDK中开启了日志上报功能，以便在用户反馈问题时能拉取到详细的客户端日志进行分析。</p><p>考察技术支持：在选型时，就应考察厂商的技术支持响应速度和技术能力，这对于解决线上紧急问题至关重要。</p><p>通过以上常见问题的解答，你不仅能更好地理解厂商的技术宣传，也能更系统地进行测试和选型，最终找到那个真正懂你业务、能解决你实际痛点的“最佳拍档”。</p>]]></description></item><item>    <title><![CDATA[Java记录类入门：简化的以数据为中心的]]></title>    <link>https://segmentfault.com/a/1190000047440457</link>    <guid>https://segmentfault.com/a/1190000047440457</guid>    <pubDate>2025-12-01 12:04:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>记录类声明是一种在Java类中封装数据同时减少样板代码的高效方式。本文将通过基础及高级编程场景介绍其工作原理。</blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440459" alt="文件柜中的文件记录 图片来源：Stokkete / Shutterstock*  " title="文件柜中的文件记录 图片来源：Stokkete / Shutterstock*  "/></p><p>Java记录类是一种用于存储数据的新型类。无需编写构造方法、访问器、<code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code> 的样板代码，只需声明字段，<strong>Java编译器</strong>便会自动处理其余部分。本文将通过基础与高级用例示例，以及不适用记录类的场景，带您全面了解Java记录类。</p><blockquote><strong>注意：Java记录类在JDK 16中正式定型。</strong></blockquote><h2>Java编译器如何处理记录类</h2><p>传统Java创建简单数据类需要大量样板代码。以下通过<a href="https://link.segmentfault.com/?enc=q4MZVQ5QLRHsTRxgYcmWBQ%3D%3D.LHxLkfSMyKXXWwM7zNVT5CBTaG3P9Wn9g7%2FuBo22U7Q%3D" rel="nofollow" target="_blank"><strong>Java吉祥物</strong></a>Duke和Juggy的示例说明：</p><pre><code class="java">public class JavaMascot {
    private final String name;
    private final int yearCreated;

    public JavaMascot(String name, int yearCreated) {
        this.name = name;
        this.yearCreated = yearCreated;
    }

    public String getName() { return name; }
    public int getYearCreated() { return yearCreated; }

    // 为简洁起见，省略equals、hashCode和toString方法
}</code></pre><p>使用记录类后，上述代码可简化为单行：</p><pre><code class="java">public record JavaMascot(String name, int yearCreated) {}</code></pre><p>这一简洁声明自动提供了私有final字段、构造方法、访问器方法，以及正确实现的 <code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code> 方法。  </p><p>定义记录类后，即可投入使用：</p><pre><code class="java">public class RecordExample {
    public static void main(String[] args) {
        JavaMascot duke = new JavaMascot("Duke", 1996);
        JavaMascot juggy1 = new JavaMascot("Juggy", 2005);
        JavaMascot juggy2 = new JavaMascot("Juggy", 2005);

        System.out.println(duke); // 输出：JavaMascot[name=Duke, yearCreated=1996]
        System.out.println(juggy1.equals(juggy2)); // 输出：true
        System.out.println(duke.equals(juggy1));   // 输出：false
        System.out.println("吉祥物名称：" + duke.name());
        System.out.println("创建年份：" + duke.yearCreated());
    }
}</code></pre><p>记录类自动提供有意义的字符串表示、基于值的等值比较，以及与组件名称匹配的简单访问器方法。</p><h2>自定义记录类</h2><p>虽然记录类设计简洁，但仍可通过自定义行为增强功能。以下是相关示例。</p><h3>紧凑型构造方法</h3><p>记录类提供特殊的“紧凑型构造方法”语法，无需重复参数列表即可验证或转换输入参数：</p><pre><code class="java">record JavaMascot(String name, int yearCreated) {
    // 带验证的紧凑型构造方法
    public JavaMascot {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("名称不能为空");
        }
        if (yearCreated &lt; 1995) {
            throw new IllegalArgumentException("Java吉祥物在1995年前不存在");
        }
    }
}</code></pre><p>紧凑型构造方法在字段初始化后、对象完全构建前运行，非常适合用于参数验证。此示例中省略了参数声明，但这些参数在构造方法内仍隐式可用。</p><h3>添加方法</h3><p>我们还可以为记录类添加方法：</p><pre><code class="java">record JavaMascot(String name, int yearCreated) {
    public boolean isOriginalMascot() {
        return name.equals("Duke");
    }
    
    public int yearsActive() {
        return java.time.Year.now().getValue() - yearCreated;
    }
}</code></pre><p>通过添加方法，记录类可在保持语法简洁和不可变性的同时，封装与其数据相关的行为。  </p><p>接下来，我们探讨记录类更高级的用法。</p><h2>使用 <code>instanceof</code> 和 <code>switch</code> 进行模式匹配</h2><p>Java 21中，记录类成为<a href="https://link.segmentfault.com/?enc=g00vYxr%2BCHqzhZg3KcTTYA%3D%3D.ITqtadkYquLlL93OOdE6OwrvqxY%2BsTGqQ0X2XDWSmkTRBWIlhhOSekTz4tApmoqFW%2FzWqoMLxCSnhOykdf2ABlA8StvU%2FFTW7K4%2Fea3uqPQ8wcgMfDz%2BHmd9sTYA8WzN" rel="nofollow" target="_blank"><strong>模式匹配</strong></a>的关键部分，支持switch表达式、组件解构、嵌套模式和守卫条件。  </p><p>结合增强的 <code>instanceof</code> 运算符，记录类可在类型验证时简洁地提取组件：</p><pre><code class="java">record Person(String name, int age) {}

if (obj instanceof Person person) {
    System.out.println("姓名：" + person.name());
}</code></pre><p>再看一个经典示例。几何形状是展示密封接口如何与记录类协同工作的典型例子，这种组合使模式匹配尤为清晰。Switch表达式（Java 17引入）的优雅性在此凸显，它让代码简洁且类型安全，类似于函数式语言中的代数数据类型：</p><pre><code class="java">sealed interface Shape permits Rectangle, Circle, Triangle {}

record Rectangle(double width, double height) implements Shape {}
record Circle(double radius) implements Shape {}
record Triangle(double base, double height) implements Shape {}

public class RecordPatternMatchingExample {
    public static void main(String[] args) {
        Shape shape = new Circle(5);

        // 表达性强且类型安全的模式匹配
        double area = switch (shape) {
            case Rectangle r -&gt; r.width() * r.height();
            case Circle c    -&gt; Math.PI * c.radius() * c.radius();
            case Triangle t  -&gt; t.base() * t.height() / 2;
        };

        System.out.println("面积 = " + area);
    }
}</code></pre><p>此例中，<code>Shape</code> 是密封接口，仅允许 <code>Rectangle</code>、<code>Circle</code> 和 <code>Triangle</code> 实现。由于类型集合封闭，switch表达式覆盖所有情况，无需 <code>default</code> 分支。</p><blockquote><p><strong>Java中的模式匹配</strong>  </p><p>若想进一步探索记录类与模式匹配，请参阅我的近期教程：<a href="https://link.segmentfault.com/?enc=5DnWDFUOfUPFA7PNs04%2F1A%3D%3D.HOO4g9iT3Z%2Fh0Lg6UuaZwMee0lhVrrF7rF6ssFFcqclAkUDOPKgkAny18GN%2F%2BLVQFjHDfb46Xy7nDr7sqI0sSAFxkqiqOB6FUHeNlHhQ9xaFWZJyMoXGTo2B4DHOYoxT" rel="nofollow" target="_blank"><strong>《Java基础与高级模式匹配》</strong></a>。</p></blockquote><h2>将记录类用作数据传输对象</h2><p>记录类在现代API设计（如REST、GraphQL、gRPC或服务间通信）中作为数据传输对象（DTO）表现卓越。其简洁语法和内置等值比较特性，使其成为服务层间映射的理想选择。例如：</p><pre><code class="java">record UserDTO(String username, String email, Set&lt;String&gt; roles) {}
record OrderDTO(UUID id, UserDTO user, List&lt;ProductDTO&gt; items, BigDecimal total) {}</code></pre><p>DTO在<a href="https://link.segmentfault.com/?enc=Y3FIJqmFdeZroB52r5yHrg%3D%3D.dsFFUuW4e4%2FXshWnEX%2FniJGfF1dmieCRI0OTD1etmnSvstHciROapDfP91qkhb4dDnmvtNf9cAlKUVughTrqIKlRy5zL48%2FZ331DfgoblZab%2BAvXB%2BUuKoHwyQMfbBqZmyc1zF32pTwb46R1Hy1ENQ%3D%3D" rel="nofollow" target="_blank"><strong>微服务应用</strong></a>中无处不在。使用记录类可使DTO更健壮（得益于不可变性），更简洁（无需编写构造方法、getter及 <a href="https://link.segmentfault.com/?enc=nr3YRFP5JsJZjsVFwB8dBQ%3D%3D.8YzJLziPriK3kGl4REJZdiS8OMolgvfF%2FbcNMQ92r19O3FL6AJFoHwB%2BQ1138i4ZU0cvS%2Bvu%2B6qGZ2nRktx51x%2BBVi5ktQln0hEXnnhnWqnBNLIvRy2XNubbTNgat09O" rel="nofollow" target="_blank"><strong><code>equals()</code>、<code>hashCode()</code> 等方法）</strong></a>。</p><h2>函数式与并发编程中的记录类</h2><p>作为不可变数据容器，记录类完美契合函数式与并发编程需求。它们既可作为纯函数的返回类型，也可用于流处理管道，还能安全地在线程间共享数据。  </p><p>由于字段为final且不可变，记录类避免了一整类线程问题。一旦构建完成，其状态无法更改，因此无需防御性复制或同步即可实现线程安全。参考以下示例：</p><pre><code class="java">transactions.parallelStream().mapToDouble(Transaction::amount).sum();</code></pre><p>由于记录类不可变，此并行计算天生具备线程安全性。</p><h2>不适用Java记录类的场景</h2><p>至此，我们已了解记录类的优势，但它们并非万能替代品。例如，所有记录类隐式继承 <code>java.lang.Record</code>，因此无法继承其他类（但可实现接口）。在需要类继承的场景中，记录类并不适用。  </p><p>以下是记录类不适用的其他情况。</p><h3>记录类设计为不可变</h3><p>记录类组件始终为final，因此不适用于需要可变/有状态对象的场景。以下示例展示了一个依赖状态变化的可变类，而记录类不允许此类操作：</p><pre><code class="java">public class GameCharacter {
    private int health;
    private Position position;

    public void takeDamage(int amount) {
        this.health = Math.max(0, this.health - amount);
    }

    public void move(int x, int y) {
        this.position = new Position(this.position.x() + x, this.position.y() + y);
    }
}</code></pre><h3>记录类不适合复杂行为建模</h3><p>基于可变状态、复杂业务逻辑或策略模式、访问者模式、观察者模式等设计，更适合使用传统类实现。以下是复杂逻辑不适用于记录类的示例：</p><pre><code class="java">public class TaxCalculator {
    private final TaxRateProvider rateProvider;
    private final DeductionRegistry deductions;

    public TaxAssessment calculateTax(Income income, Residence residence) {
        // 复杂逻辑不适用于记录类
    }
}</code></pre><h3>记录类与某些框架不兼容</h3><p>部分框架（尤其是ORM）可能无法良好支持记录类。序列化或重度依赖反射的工具也可能存在问题。请务必检查Java特性与技术栈的兼容性：</p><pre><code class="java">// 可能无法与某些ORM框架良好协作
record Employee(Long id, String name, Department department) {}

// 此时仍需使用传统实体类
@Entity
public class Employee {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    @ManyToOne
    private Department department;
    
    // Getter、setter、equals、hashCode等方法
}</code></pre><p>这些注意事项并不意味着记录类功能不完整，而是强调记录类专为特定场景设计。在某些情况下，传统类仍是更实用的选择。</p><h2>Java中的记录类与序列化</h2><p>记录类已在Java生态中被广泛采用，其不可变性使其在持久化、配置和数据传输中极具吸引力。记录类可像普通类一样实现 <code>Serializable</code> 接口。可序列化的记录类组件天然适用于保存配置、恢复状态、网络传输数据或缓存值等场景。  </p><p>由于记录类字段为final且不可变，它们有助于避免可变状态在序列化与反序列化之间发生变化引发的问题。例如：</p><pre><code class="java">import java.io.Serializable;

record User(String username, int age, Profile profile) implements Serializable {}

class Profile {
    private String bio;
}</code></pre><p>此例中，<code>String</code> 和 <code>int</code> 可序列化，但 <code>Profile</code> 不可序列化，因此 <code>User</code> 无法序列化。若将 <code>Profile</code> 也改为实现 <code>Serializable</code>，则 <code>User</code> 将完全可序列化：</p><pre><code class="java">class Profile implements Serializable {
    private String bio;
}</code></pre><p>除序列化基础外，Java生态对记录类的支持已迅速成熟。Spring Boot、Quarkus和Jackson等流行框架均与记录类无缝协作，大多数测试工具也是如此。  </p><p>得益于这种广泛采纳，记录类在实际API中作为DTO表现卓越：</p><pre><code class="java">@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @GetMapping("/{id}")
    public OrderView getOrder(@PathVariable UUID id) {
        // 实际应用中，此数据应来自数据库或服务
        return new OrderView(
            id,
            "Duke",
            List.of(new ItemView(UUID.randomUUID(), 2)),
            new BigDecimal("149.99")
        );
    }

    // 用于API响应的记录类DTO
    record OrderView(UUID id, String customerName, List&lt;ItemView&gt; items, BigDecimal total) {}
    record ItemView(UUID productId, int quantity) {}
}</code></pre><p>如今，大多数主流Java库和工具已将记录类视为一等公民。早期的质疑已基本消散，开发者正因其清晰性与安全性而广泛接纳记录类。</p><h2>结语</h2><p>记录类是Java演进过程中的重大进步。它们降低了数据类的冗余度，并确保了不可变性和行为一致性。通过消除构造方法、访问器及 <code>equals()</code>、<code>hashCode()</code> 等方法的样板代码，记录类使代码更简洁、表达力更强，在保持类型安全的同时契合现代实践。  </p><p>记录类并非适用于所有场景，但在处理不可变数据时优势显著。结合<a href="https://link.segmentfault.com/?enc=VfmVdvwWOMBjVMngACM%2F2A%3D%3D.hgATLufLKAc9fjVgYsZSO41HVyPDbxLc34Q2tAtk5PNEdpxY9wGWpvlAl%2BcS%2FvllnTQF3Qcu0RnaKZeiUq0PvM0JgqYwtx0es7%2FaPEXDAyF%2F5C92qQ2xT4NFYrtACjiz" rel="nofollow" target="_blank"><strong>模式匹配</strong></a>，它们能让代码意图更清晰，同时由Java编译器处理样板代码。  </p><p>随着记录类、密封类和模式匹配等技术的进步，Java正稳步迈向更以数据为中心的编程风格。掌握这些工具是编写现代、高表达力Java代码的最清晰路径之一。</p><hr/><p>【注】本文译自：<a href="https://link.segmentfault.com/?enc=J8ZygdGpfI%2BRheXJPLTNEA%3D%3D.A3xlNKm6sx8If2wSEmJ0y0MorQJSJazefC7eUUv2Wig3LGOXi68vXPIOBRKfH9uxOYGS0SvjEgrkG8KUpx3f7H6WEjDZaSy4Iafnd6VRIjmZJBHh%2B68XSeKHDGE2p%2FRNr4EwAcIf1U5M8W5TkMugGDgUVafMy5AWSbQhzc8JpOg%3D" rel="nofollow" target="_blank">Introduction to Java records: Simplified data-centric programming in Java</a></p>]]></description></item><item>    <title><![CDATA[JeecgBoot 低代码 v3.9.0]]></title>    <link>https://segmentfault.com/a/1190000047440463</link>    <guid>https://segmentfault.com/a/1190000047440463</guid>    <pubDate>2025-12-01 12:03:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>项目介绍</h2><blockquote>JeecgBoot是一款集成AI应用的，基于BPM流程的低代码平台，旨在帮助开发者快速实现低代码开发和构建、部署个性化的 AI 应用。 前后端分离架构Ant Design&amp;Vue3，SpringBoot，SpringCloud，Mybatis，Shiro，强大的代码生成器让前后端代码一键生成，无需写任何代码！ 成套AI大模型功能: AI模型、AI应用、知识库、AI流程编排、AI对话等； 引领AI低代码开发模式， 帮助Java项目解决80%的重复工作，让开发更多关注业务，提高效率，同时又不失灵活性！</blockquote><p><strong>发版时间</strong>：v3.9.0 | 2025-12-01</p><h4>源码下载</h4><ul><li>Github地址： <a href="https://link.segmentfault.com/?enc=xBAvuiUzE%2FW1CRtcqXMEiA%3D%3D.Nxgc%2BHU1uHHZl%2FdYqfPqV69xG21C5wt5K2QT%2BRnZ8AIEFmPXgUEJXFbvAthgJe7X" rel="nofollow" target="_blank">https://github.com/jeecgboot/JeecgBoot</a></li><li>Gitee地址： <a href="https://link.segmentfault.com/?enc=H6uGcVhDqjgiY27JVUc%2BHA%3D%3D.piqs%2BMNkDvQSkPXVgPzJTDGhwf%2Bwq06aBobZYdEGnpkH3JBsfuCLYHXbnMOLmFJw" rel="nofollow" target="_blank">https://gitee.com/jeecg/JeecgBoot</a></li></ul><h4>升级日志</h4><blockquote>本次升级将 langchain4j 升级至 1.3.0，强化 AI 功能，新增 MCP 和插件支持，实现聊天式业务操作（如“一句话创建用户”），扩展 AI 聊天与流程编排能力。集成 Anthropic（Claude）、网络搜索及推理模型，提升系统深度思考能力。完成 POI 升级至 5 版本，优化用户、部门、租户等系统管理功能。<br/>自 v3.9.0+ 起，停止同步升级 Spring Boot 2版。</blockquote><h5>AI功能增强</h5><ul><li>升级 langchain4j 至 1.3.0 版本。</li><li>AI 应用新增对 MCP 和插件的支持。</li><li>AI 聊天功能支持 MCP 和插件扩展。</li><li>AI 流程编排新增 MCP 和插件支持。</li><li>支持AI聊天做业务(例如：一句话创建用户)</li><li>新增 Anthropic（Claude）模型厂商支持。</li><li>AI 聊天支持推理模型，提升深度思考能力。</li><li>AI流程支持导出与导入功能</li><li>AI脚本节点支持 Python 语言编写</li><li>AI聊天集成千问模型，支持联网搜索功能</li><li>支持 2000+ 维度向量，pgvector 版本需大于 0.7</li></ul><h5>功能架构升级</h5><ul><li>从 v3.9.0+ 版本起，不再同步升级 Spring Boot 2 版本。</li><li>批量删除修改日志，提升代码可读性</li><li>POI 升级至 5 版本。</li><li>升级 <code>package.json</code> 中依赖包的小版本号</li><li>积木报表升级至最新版 v2.2.0。</li><li>积木 BI 升级至最新版 v2.2.0，新增多屏切换功能，大屏设计支持导出和导入。</li><li>集成 <code>vite-plugin-pwa</code>，实现渐进式 Web 应用（PWA），显著提升首屏加载速度。</li><li>系统资源实现异步加载，菜单响应速度更快。</li><li>登录密码采用 AES 加密传输，杜绝明文传输，提升安全性。</li><li>支持单独设置 APP 和 PC 登录会话的有效期。</li><li>支持登录规则灵活配置：</li><li>是否允许同一账号多地同时登录。</li><li>是否开启默认密码登录提醒。</li><li>是否启用登录验证码校验。</li><li>登录用户支持区分登录规则（区分 PC 与 APP），并记录终端设备信息，便于实现 APP 推送功能。</li><li>部门管理新增查看部门负责人的功能。</li><li>部门管理支持拖拽调整部门上下级关系，提升操作便捷性。</li><li>用户岗位调整为关系表结构，优化数据关联管理。</li><li>我的租户界面改版，提升整体使用体验。</li><li>优化密码默认规则，增强安全性。</li><li>支持隐藏用户联系方式，保护隐私。</li><li>富文本编辑器优化：从博客复制的文章中图片自动下载并上传至云存储</li><li>登录页面新增部门选择功能</li><li>BasicTable 列表页导出 Excel 时支持指定导出列</li><li>uniapp推送功能，支持在线和离线消息（已对接系统公告）</li><li>日志级别由 info 调整为 debug，减少日志输出量</li><li>优化延迟加载导致的部分功能失效问题，修复 token 忽略注解失效</li><li>生成代码统一导出为 xlsx 格式</li><li>我的消息支持批量删除已读消息</li><li>升级 shardingsphere-jdbc 至 5.5.0，简化 ShardingSphere 数据源配置</li><li>用户管理支持按组织架构查询用户（支持多选）</li><li>用户管理新增排序字段，选人组件和通讯录等功能按排序字段展示</li></ul><h5>Online优化功能</h5><ul><li>新增Long类型支持，补充online中db类型缺失的Long类型支持</li><li>为online报表添加AI生成SQL能力</li><li>支持主子表生成测试数据功能，完善Online AI测试数据生成</li><li>修复online表单存在的严重BUG，影响所有配置查询相关表单功能，优化Java增强</li><li>一对一子表编辑后，详情页数据未实时更新</li><li>superQuery高级组件点击查询后，弹窗未自动关闭</li><li>修复online表单联动查询无法模糊搜索选项问题，新增下拉联动组件搜索功能实现</li><li>修正online表单开发中开关控件类型字段详情页显示原始值问题（查看详情页时显示开关状态）</li><li>修复内嵌子表主题（一对多）列表展开明细时提示无权限访问</li><li>修复JS增强弹窗中popup的onChange事件无效问题</li><li>优化删除操作确认弹窗内容及样式，提升用户体验</li><li>修正ERP风格online主表在数据条数为5条时出现滚动条问题</li><li>限制online ERP风格主表固定高度，防止高度异常</li><li>生成测试数据时不再展示tooltip提示信息</li><li>修正online表单TAB主题附表页面标题与内容不一致问题</li><li>代码预览支持左右拖动功能</li><li>修复online表单图片控件多图片显示异常</li><li>JS增强弹窗支持basicModal组件的props传递</li><li>修复online下拉搜索框详情页无法正确读取数据字典问题</li><li>修复下拉搜索框绑定数据字典后导出数据报错问题</li><li>解决online表单内嵌风格中double类型数据导出带小数点“.0”导致导入报错问题</li><li>修正online建表生成的日期类型字段控件为输入框问题</li><li>解决升级mybatisPlus后SqlServer分页使用OFFSET必须有排序的报错</li><li>online代码生成中，传递配置项以支持JS增强和Java增强逻辑代码</li><li>优化online报表配置界面列表滚动条美观性</li><li>代码生成时增加操作提示语</li><li>代码直接生成前端项目后，自动刷新提醒功能</li></ul><h5>Issues处理</h5><ul><li>mysql 8.4 数据库字段类型为bigint ，代码生成为Integer · <a href="https://link.segmentfault.com/?enc=QL3ZpPUao0Hit7OdYk2pqA%3D%3D.w3BmDaZg30ZI1MoM8LmUuPbduCAA9QTy4hVt3XalhZuY8d65UB3hit82%2BBthinHqF4DQ1PZTBAU3%2Bya62oeJuA%3D%3D" rel="nofollow" target="_blank">Issue #8909</a></li><li>online中的列表如果第一列固定就出现带 +号的列在向右滑动的时候被错位隐藏 · <a href="https://link.segmentfault.com/?enc=rMsxs6mI8p68tDLMSBW8Jw%3D%3D.IF1hddxnQQC4vI4pbDzP6RjS2lpuYBIvlqBexIFIbH%2FmZblevXlIWpYu7GxtJ1m3gqLEGgOOK%2B8e6dy%2BF03bDA%3D%3D" rel="nofollow" target="_blank">Issue #8862</a></li><li>选中行如果存在右侧固定操作列或X方向滚动条会出现数据悬浮超出 · <a href="https://link.segmentfault.com/?enc=YK%2FiNA4tL9WyuCk%2BwTI%2BUg%3D%3D.PsrfF9T9SWdMbHVfnqsu3LVgTs4xcfIG8MPaxmu8S2bLJ9%2FdnycCoqRJGB2Kz0m%2FrNBgsYDRcJbMukytHBT56Q%3D%3D" rel="nofollow" target="_blank">Issue #8839</a></li><li>关于BasicTable组件自适应高度的建议 · <a href="https://link.segmentfault.com/?enc=3r%2B%2FqfyU22e6CtzpfxSVmg%3D%3D.JP6WwRvnWOm%2FQiBDf1VK10w7P1TrZx6rhsP0oANBQ5pXJEV36Y6%2BE3dkf3NpKZv9D96VE7LTRFTYS6alf2ajEA%3D%3D" rel="nofollow" target="_blank">Issue #8880</a></li><li>popup弹框怎么onlChange()不生效？ · <a href="https://link.segmentfault.com/?enc=drXckZE5A7ZaqKhW55YHLw%3D%3D.sNn7WsEP8kO5lE%2BX06vOGsU2s504Q1Cu1yusZQlBJCNpUWSKNCidlPJcbELl3EKWJVlp3%2BDCyVx%2BKg9tSfcvhg%3D%3D" rel="nofollow" target="_blank">Issue #8791</a></li><li>关联问题8567，修改密码接口可以被恶意爆破 · <a href="https://link.segmentfault.com/?enc=atO8GiUXuw7JD6WEI6Opaw%3D%3D.jhRcg%2BANpEsLmelnjchluJfYiRGAkLHmxNUrmVUCptM2sr2ZpTlUE4OYDtDUsGQAUJ5aae2CAYql9RIpLiMd%2Bg%3D%3D" rel="nofollow" target="_blank">Issue #8805</a></li><li>同一页面下存在多个basicTable，获取实例错误 · <a href="https://link.segmentfault.com/?enc=u1ZrgHztoNPP261omeMYKg%3D%3D.mVHkBKYbcQnhJod2zV8HsKw5LJcxNUX6op8fCU4OrS0uPowcv3kvXYuoz3Eiymp05Ye%2FIf8vlVG32GB0DzyClw%3D%3D" rel="nofollow" target="_blank">Issue #8792</a></li><li>EditableCell.vue 点击单元格对号之后，会过滤掉表格的id字段，导致无法更新数据。 · <a href="https://link.segmentfault.com/?enc=mwAom%2F5pThy0Bpq9A1C6%2Bw%3D%3D.wLN9HKmxo9TGraUqHFwc8VpfIsLveCHizVEMqJ%2F%2BRKgmPHv9W062hHU8v4dzVIRquB7De880I1PBAfTCnFQJ9Q%3D%3D" rel="nofollow" target="_blank">Issue #8924</a></li><li>数据填报时数字转换报错 · <a href="https://link.segmentfault.com/?enc=P2MY18IMQOo7qPeQCmtUEQ%3D%3D.eM8PZxJFBCHFItQmBPcySiaYwCzYoTjmrZA1Qd2XgYZLAqgKy8AKHb028UH8EE97cIwc1pZRtnJVwpZBLlmwqA%3D%3D" rel="nofollow" target="_blank">Issue #4091</a></li><li>jeecgboot master分支jdk1.8无法启动 · <a href="https://link.segmentfault.com/?enc=SFY02KwhfLOc0w2Egwv2mw%3D%3D.%2BgelTJLMEAvZ8Ha3e3MxUkvxe90n6kpPyeDTBWp8RL0BjGS33i4PwTgDQZt9rqHxKm4iSQtMibexJ8M0ZNamUA%3D%3D" rel="nofollow" target="_blank">Issue #8944</a></li><li>online表单java增强失效 · <a href="https://link.segmentfault.com/?enc=wzM9Mb5G0S5HDQZd2YbjYA%3D%3D.GK20g7%2BzYlJ9YkKOe1qYTRUatZJjUpJGCxAv6xiPL2DFDbcMad7whbIq2hAgffhiqY4OM1ho2Q0WLV%2BP9S6EuQ%3D%3D" rel="nofollow" target="_blank">Issue #8859</a></li><li>日志注解@AutoLog 多文件上传时报错 · <a href="https://link.segmentfault.com/?enc=ayM2updlX7bAhgFlPP4T%2BA%3D%3D.Rcx0ptWOIqQduyca9ySNeFFVUiR%2FzQW4Cwn8b%2FRPQ0%2Fsx%2F%2Bj14knF9qpAxK5xviEGIUaeipu20p19e%2BNGPW9fw%3D%3D" rel="nofollow" target="_blank">Issue #8945</a></li><li>从jeecgboot 3.8.2 升级到 3.8.3 在线表单java增强功能报错 · <a href="https://link.segmentfault.com/?enc=knFg%2Bc9fs%2Ft7RlwAQ1e6tA%3D%3D.Fad2ccFhvSX8aV9EHtwyCPgA1sDM5glKjqUM%2Be6E%2B0zSUBF%2B7gMGWjP93W6RAMC8OtAoI8ccm9Mm6CFNivcr6g%3D%3D" rel="nofollow" target="_blank">Issue #8951</a></li><li>关于sys\_user org\_code的疑问。 · <a href="https://link.segmentfault.com/?enc=spxYpksc6BxRN4qaG8Zm5w%3D%3D.B4GApgzb9ThTX9u6AWnwEVyeaXd345cZuJ4bDhRKiQCbKZfbzpN42OflcgLSSw5QGm8BuQDYYM45WCRnd6rp7A%3D%3D" rel="nofollow" target="_blank">Issue #8953</a></li><li>Online表单开发，Java增强问题 · <a href="https://link.segmentfault.com/?enc=w5wHV685IdK9YC3skg8rlw%3D%3D.8TZQTfFKNXQZ6QFpffAN%2BloItdnLlKIXquhRwBjYbIlCC%2FussXA%2FjRsATYoRDbOQe3DUyPaMdXag8j0VbbMBbw%3D%3D" rel="nofollow" target="_blank">Issue #8768</a></li><li>online 表单重大 bug，影响配置了查询 的所有表单 · <a href="https://link.segmentfault.com/?enc=8tIkz4927oIHBzG%2BKj%2BP3A%3D%3D.de6HCccwrBI7BfVm8%2F1MghuDoN8U3%2FUgQU6CSE7TbDfp7Kgclf%2FkyyRiT78MUO%2BGhrNc75x1jF4IovWFGq7Zag%3D%3D" rel="nofollow" target="_blank">Issue #8790</a></li><li>添加AI模型保存并激活的时候报错：测试模型连接失败：调用大模型接口失败，详情请查看后台日志。 · <a href="https://link.segmentfault.com/?enc=f0g5MnUtQMl4ni0%2BcjOMTg%3D%3D.lWltO2NmjSOq8en6%2BUHtgvSsOQ3pcxAVJYexjOP1RBEvLvL8osg8F%2BBqLRdVsJlhJohC66NMUaLU5kI%2FioOkLg%3D%3D" rel="nofollow" target="_blank">Issue #8906</a></li><li>AI模型激活时, 智谱/千问报错UnsupportedOperationException · <a href="https://link.segmentfault.com/?enc=neQqf5BfyC8n%2FtL0znPADw%3D%3D.AXTdYghlVEZ%2BcRJEVIrfwdzpOvspUQa6SNK3xZf1sjlIHFmliO9VplA7yyf7w8NbdAX4GJmd5sbrwWeLk0%2F3SQ%3D%3D" rel="nofollow" target="_blank">Issue #8955</a></li><li>分库分表错误 · <a href="https://link.segmentfault.com/?enc=IRwlQDAXnXqKtsxVG4azoQ%3D%3D.4T%2FofLR6ZDngM3TjUGKyHScjV43mu3Jsmp8DFWcHQX98mhB4AFDhUD50NnoOkUcZNES%2FelfXbMhFMzP0GcGCVA%3D%3D" rel="nofollow" target="_blank">Issue #8962</a></li><li>Microsoft SQL Server 2008支持问题 · <a href="https://link.segmentfault.com/?enc=mjbOS7qDC7tjcSvbOS7Bzg%3D%3D.ckPEtwcTVIaGXHno1SjnIfX%2BjOismljUs1n4VZ2evG%2BST0aq0N7dM5pFR9tr0SEU6xEdp6BQbi%2FF%2B4V%2BQsvxUQ%3D%3D" rel="nofollow" target="_blank">Issue #8975</a></li><li>通义千问的多模态模型如：qwen3-vl-plus 保存激活报错。 · <a href="https://link.segmentfault.com/?enc=3OdIjXBNc38YtmGpn2pybg%3D%3D.IngR9pVZYlBgtfzKGduzmwnnKfoe9a6mOGkS5PFNP313kEY41YjQDXxFSLKip72J6aVUJNgBCQAkjnmX5VS8qw%3D%3D" rel="nofollow" target="_blank">Issue #8972</a></li><li>Jeecgboot 登录配置 不允许或允许多设备登录 · <a href="https://link.segmentfault.com/?enc=QjFChl9HEmmT7In7aVgVjQ%3D%3D.yP5ucLbOJCKGcDk%2FDcxBLAn%2Fc7WYtY0lo8CCL7QqhbKnMO8cUpPY9NpZiuBNux4M9EoA7f1cPnAweRVg9or8MQ%3D%3D" rel="nofollow" target="_blank">Issue #8929</a></li><li>特定条件下AI助手失去响应 · <a href="https://link.segmentfault.com/?enc=m0W8wafOjMJPdsDdY7jsXQ%3D%3D.IKVWelf9R1rqBK5iDrx9aveomhQONaWhJCaYR0F4l%2B7VBRjwbJwgtQO%2FZpOrFe%2Bh3LSzwCCI%2BKX0VsANF5WocA%3D%3D" rel="nofollow" target="_blank">Issue #8997</a></li><li>内嵌子表主题（一对多）列表点+号展开明细提示：无权限访问(操作) · <a href="https://link.segmentfault.com/?enc=kNNZz1MyTKj2cUzqxpV%2F%2FQ%3D%3D.vE6KqngY92tsP2pPeT0OumMa9tod%2Bk8ldSZgxc2k%2FbZ6xryz2HJFOPkeyv4Xp7q1A9nXJQqty746Vn%2F4hvBJpg%3D%3D" rel="nofollow" target="_blank">Issue #8933</a></li><li>3.8.3-master分支：租户用户 菜单下 新增用户报错 · <a href="https://link.segmentfault.com/?enc=x7lf35CL%2FSjOTs%2BOKNVZYA%3D%3D.vqXkNxt6AOxqZUNuf3g%2Fs63ePTFlGLYvlFonw%2BxUnSZ31OPqTv5cSLgDWZ%2BHLjrY7RE6mR5nGx3WBZzTOa%2FQjQ%3D%3D" rel="nofollow" target="_blank">Issue #9039</a></li><li>从jeecgboot 3.8.2 升级到 3.8.3 在线表单java增强功能报错 · <a href="https://link.segmentfault.com/?enc=LbwfJaRAfbGeUpdRaAaTdQ%3D%3D.Wd8mz%2FHLGCVPXDXbqzhU5g7beCBpfQOe8dYW4nel0rTMWq2pPOWbg4GePxowrHMmnCqYo%2Fq8wXqeClLhwgRJWg%3D%3D" rel="nofollow" target="_blank">Issue #8951</a></li><li>ai模块的mcp菜单没有找到，版本号3.8.3 · <a href="https://link.segmentfault.com/?enc=V0Nmv82kX6bJ5bzMn9t68Q%3D%3D.GbyK0rcHB6TdO5Ev8PY1I3ejWwDxBeBiIZgZur%2FjQg0hF4Ta58paZ795w%2F0z77cXcI%2FynTudQ%2FKISkjrgE0Z1w%3D%3D" rel="nofollow" target="_blank">Issue #9044</a></li><li>AutoPoi ImageEntity建议添加scale属性，控制图片导出缩放模式 · <a href="https://link.segmentfault.com/?enc=fmjgJgZA55rraYih1jGZzg%3D%3D.h3wpWagKGyIaZVqsVwI5Mzp0cF4Wpg5LlHfRtr6oQXBxSXVlm587CL6RMcEdXw38iMhjpUY338td2ssIPzgFfQ%3D%3D" rel="nofollow" target="_blank">Issue #8892</a></li><li>3.8.3-master分支，ai工作流编排，直接回复节点没有流式响应的开关 · <a href="https://link.segmentfault.com/?enc=gPsdWdCYXedndA6%2F38KHYA%3D%3D.ewREvCqdC1LFDLI6u55u7zMrXCV%2Fapn17Lhi3X7fKwiFAMoF0%2Fg3UQ5FZlJJektRJqQj3IrRcHZSB8RDQaBjVQ%3D%3D" rel="nofollow" target="_blank">Issue #9031</a></li><li>online表单联动查询，无法模糊搜索选项 · <a href="https://link.segmentfault.com/?enc=%2BJg3qiKIqvpNdVvcbRYg3A%3D%3D.6qtb8aVg%2Fvt5to8Bfz%2F5J51p%2F%2FEgreqAblLpRCXiCvPwWkhZGV%2FFgqkfdu4VDBdY5ex7q1P36c0xVTtFAAIj6g%3D%3D" rel="nofollow" target="_blank">Issue #8486</a></li><li>online表单在线开发，下拉联动组件，怎么实现搜索功能 · <a href="https://link.segmentfault.com/?enc=fFpJPxT%2Br9HmNlHe0Kcx%2FA%3D%3D.XPBArcakUXizy50V%2FxQ778T7UBAQot41VrXpjiIELsCcHt%2FuhspJMxna8Q7%2BTuBU%2Bihw7pCUyizYfGXaPU27qQ%3D%3D" rel="nofollow" target="_blank">Issue #8587</a></li><li>online 表单开发， 设置字段 控件类型为开关时，查看详情页时 开关字段显示原始值 · <a href="https://link.segmentfault.com/?enc=jqKu%2F%2BemHIa0NCWL3xmoAw%3D%3D.mHhl5WWn%2BBjjUh1QIt7Ds5CEKKCkUtStT8Q9c2bfwcNGxklw8L3L4O8LT9G66PKUS4yDKPK3wscxywl0BhZgEA%3D%3D" rel="nofollow" target="_blank">Issue #9036</a></li><li>AI应用二次打开聊天无法继续 · <a href="https://link.segmentfault.com/?enc=I81cb3jFhb9vD1prxvoSRw%3D%3D.aoRn6cL9i07gId3trmQyoC6%2BIy9VqYQvf3CUkyd94oS1TW8QDkrOdmFRZby%2B%2FcjNF05PqVKMSkkNEhfRLWH%2FHg%3D%3D" rel="nofollow" target="_blank">Issue #9054</a></li><li>无法启动，报错：init flow executor cause error for path el_xml · <a href="https://link.segmentfault.com/?enc=BxYSTBLlpVsX7EDUNdlf%2FA%3D%3D.SxM%2F8m%2BhtebezPSlgUNWC9W5amQunqx%2FOwS%2BOAc42ndRLZF67E%2B%2BgBsad6tlrnOA33CtAjl%2FoWGVF%2FY9R0mXGw%3D%3D" rel="nofollow" target="_blank">Issue #9034</a></li><li>在线表单字段控件类型为下拉搜索框时绑定数据字典后导出数据报错 · <a href="https://link.segmentfault.com/?enc=bTCgS9cxvoofsB%2BYQzlWKQ%3D%3D.LivCiVLDng3IzwCZgtVvHIAZz9cZbkICB%2B%2BTeKCoM6DhvSP24Z2psDs%2FUdfwIYm1R7dPKo5Q4qm6HSB43owomA%3D%3D" rel="nofollow" target="_blank">Issue #9053</a></li><li>新建AI应用的时候只能选择没有自定义参数的AI流程 · <a href="https://link.segmentfault.com/?enc=22Mg4rOZizQPYJya6KYUig%3D%3D.xkbmcnTsvkPNDFE2Jty8%2BJp5uCwfmJITYhMOgkxPn93NhppdfBs%2F5545RvV5y0jm14bcAKgldrmlPyXh4A373w%3D%3D" rel="nofollow" target="_blank">Issue #8545</a></li><li>FormSchema配置componentProps为函数返回valueType: 'Array‘时在useListPage 的查询接口中仍旧是获取到类型为string · <a href="https://link.segmentfault.com/?enc=YOaGYhZaLrnPI9z6LX9loA%3D%3D.eTVWcIADVcJ8h%2BvemfJSc8DSp8pTYBOechoZhg5ENOrmfna9HZ8xgzynCaOd940BBIACAgMns33VBGRTp4LRkQ%3D%3D" rel="nofollow" target="_blank">Issue #8976</a></li><li>3.8.3-springboot3 AI模型配置中，测试连接功能被取消？ · <a href="https://link.segmentfault.com/?enc=cYMCYp2tXwWJAzRo6UAxMg%3D%3D.bU4Fmf9FW6soi2ihcjEOj07Jr5qBRyrzyzoB%2B75jlTWRV4SrpwjzhGgzC3Jhe65lgml3Zz6tOo2hwEubphgSTA%3D%3D" rel="nofollow" target="_blank">Issue #9071</a></li><li>jeecgboot-vue3 执行dev能正常启动，build或build:docker时报错 · <a href="https://link.segmentfault.com/?enc=1RFYm84sNDw7ScPsWqciIg%3D%3D.pKdwirYvC4iiHOlZ2eCAgcYywsk4XciuTfoSst5yCZe7lu47Y8Q8P%2FpNcPOpTey2Co7e%2FTfwKOzeKyVro%2BsSbg%3D%3D" rel="nofollow" target="_blank">Issue #9087</a></li><li>Online报表（带参数）预览后台报错 · <a href="https://link.segmentfault.com/?enc=k5qFCnYUpglvppJXZVqAhA%3D%3D.N32pAtoED9Smgk%2FNttbUcFB2KetMhTXOXFTQy7tlf2uoq438vSX%2BZ6%2FuGTbTphKIAhH31243iULzCSifwtLBNQ%3D%3D" rel="nofollow" target="_blank">Issue #9000</a></li><li>ai应用中如何实现深度思考功能 · <a href="https://link.segmentfault.com/?enc=Sjg29ooSHBAz4PvczlDXDg%3D%3D.3XpjqdVaAy%2BFgOBAX8lOp0X7pOg38uCM23JD7DQ%2BGEuxghOEHffK3kH8gZKPE3aalFbXNvCIGXwUhvOQlhB5zQ%3D%3D" rel="nofollow" target="_blank">Issue #9104</a></li><li>JVxeTable表格点击行选择BUG · <a href="https://link.segmentfault.com/?enc=avwvF%2FQCxI3qLimsgt6m4Q%3D%3D.KEc0bC%2Bkk%2B5KHrGpBQcAKjFuuKeS5048CoZe0MwskgiZLBnAYlZ1pTtGowacrmKB0jJvQoOL37QC6ARmlXUmUw%3D%3D" rel="nofollow" target="_blank">Issue #9038</a></li><li>superQuery高级组件，点击"查询后"不能自动关闭弹窗 · <a href="https://link.segmentfault.com/?enc=NseTupamlvIVpaDYoKOw0Q%3D%3D.32ckvUdRHVLE%2F02gpG0sSXJco2m2%2BOqsC7gFvLGDz078aYs4USl2kg8h5RBpxEA%2Fs9Bc3jHxwFlJg9E311rvkw%3D%3D" rel="nofollow" target="_blank">Issue #9060</a></li><li>BasicTable列表页导出excel可以指定列 · <a href="https://link.segmentfault.com/?enc=%2Bh6UkCepLkEn8Aysi1HC1w%3D%3D.oOXEcqDue7doZ%2F7Q8IQXRL%2FzKEar2Jpy5PM5xMRYkAR03dfGyagcnxjWGP3pZufKAJn0cvoUMJOgqhMo1mkk0A%3D%3D" rel="nofollow" target="_blank">Issue #9052</a></li><li>请求中附带非法或过期 Token 时，返回重复的 401 请求 · <a href="https://link.segmentfault.com/?enc=S9to5IfM4RY20zyvghEhGQ%3D%3D.ITcpaFg4HGdaCm7oPcWbqa0E3lW7fhQysekfGp%2BRGmu5fXh7FW8Eb%2BJ7YLmy9BaxP%2B5HWNTdNTcfP%2Bmi96gTRw%3D%3D" rel="nofollow" target="_blank">Issue #9107</a></li><li>ai流程设计，能否增加导入导出功能 · <a href="https://link.segmentfault.com/?enc=pWDSyiOAGYRih7%2FkZKHBPQ%3D%3D.7Ib2FfC9NX7l%2BvFjioeFzh7cvke26F54pwZe1uwNcVM%2FQ2HzZtSILOKyxn%2B4X8qGVkV5TtgXELyN0h%2Fq5kFe5g%3D%3D" rel="nofollow" target="_blank">Issue #8591</a></li><li>ai流程是否能支持python脚本运行 · <a href="https://link.segmentfault.com/?enc=vFn3ihEoAo7%2FZpzqpRxN2g%3D%3D.1IQ1Ma6XjdyAgGFAYDXpkejcDPQ50OF74dukIDHGv7Z2fY1h2ZkIdbSoQhnIczbmqlSMbYGudGS9L%2FVLbiveeA%3D%3D" rel="nofollow" target="_blank">Issue #9093</a></li><li>标签页tabs关闭功能异常 · <a href="https://link.segmentfault.com/?enc=X4a26bchaquoq8Enul2Y7g%3D%3D.9cQOeGAdIRgrLzbzlxa8U4C3fCIKH1nZ%2FwE%2BENoJBK%2BcOJysSGj7TM8r7i7Wub14E78r7FTv5U4IHCGoZrIxxw%3D%3D" rel="nofollow" target="_blank">Issue #9098</a></li></ul><h4>技术交流</h4><ul><li>官方网站： <a href="https://link.segmentfault.com/?enc=tY3IhcR3ioz8lsNf95Twow%3D%3D.yTOssAF3Z5lzDhL3EN1giPq%2Blq2s%2BWS15IKva1FyatM%3D" rel="nofollow" target="_blank">http://www.jeecg.com</a></li><li>在线演示：<a href="https://link.segmentfault.com/?enc=UTW8Lmk6MsequM48uPajyg%3D%3D.8WtgflbN3uOFAlm4j1ZDiF6elImSN5Rjlkj6UrEcdmo%3D" rel="nofollow" target="_blank">http://boot3.jeecg.com</a></li><li>入门指南： <a href="https://link.segmentfault.com/?enc=yciMnXfdaPVZhIiqar6oYg%3D%3D.OQvisWEmAfpfeu%2B44n5P5l4HUutiO52aVD8nT7jaJoiyQIjMlb24cBI7bT6AuxX2" rel="nofollow" target="_blank">快速入门</a> | <a href="https://link.segmentfault.com/?enc=f2Skjqojnp6LoF6CJWgfwQ%3D%3D.XqLfegLuGZxFAs17vfaGtR6SYtDyqQ1SqCpZtroT4xI%3D" rel="nofollow" target="_blank">开发文档</a> | <a href="https://link.segmentfault.com/?enc=oftyvu7ciB5aPoAaYIYO8Q%3D%3D.JL0l0HDm04tU7qbJwjTRzsfPbVixVUQc3uCEVZGoj3Q%3D" rel="nofollow" target="_blank">AI应用使用手册</a></li><li>技术支持： <a href="https://link.segmentfault.com/?enc=VnRLNaUwIWr6CYLBYfSalA%3D%3D.9HC6EGStI3nttWxmTntDC9DrrweKzzLmnLEp2IzfZx53HMHfkOqHiOF4sHsrudcrXLi1P%2F3lH6ITOm619uOrrYaMwOuaIuUqEymk0e8ORGg%3D" rel="nofollow" target="_blank">反馈问题</a> | <a href="https://link.segmentfault.com/?enc=YOw6Ip5SjviWmz%2FVnSWCfA%3D%3D.cBFDhkwYABhK3Q%2B389Qx81%2BV1d2xUkq0EAxtBo%2FbQMg%3D" rel="nofollow" target="_blank">视频教程</a> | <a href="https://link.segmentfault.com/?enc=a8ZO52FnwsP9%2BP7H2VD3SQ%3D%3D.1M0txHs1THVNETwJacyC8RZxk%2BvUWnw4uLAz%2FAW8G51%2BurRK%2BROzQyZUGJIcORXuUlwnUJ9HpjoUzEuzsndMow%3D%3D" rel="nofollow" target="_blank">低代码体验一分钟</a></li></ul><h4>快速启动项目</h4><ul><li><a href="https://link.segmentfault.com/?enc=sam34cbLGRY946TsTMjceg%3D%3D.ga7bKQqgaLQVIYr2jdVHxjVk%2B0TzkGVynmIS%2FATE1gXzfvmCjBApVfIZBPd68aN%2B" rel="nofollow" target="_blank">IDEA启动前后端项目</a></li><li><a href="https://link.segmentfault.com/?enc=w%2FlBGbntRnlX%2Fh6gfIVGyQ%3D%3D.zaN5AoQwxUzAnsMnmkFAsg4Ft9nO6INIRCnv9nFz718CY5t6SzBBdX3vHOdnZJcJ" rel="nofollow" target="_blank">Docker一键启动前后端</a></li></ul><h4>AI应用平台介绍</h4><p>JeecgBoot 平台提供了一套完善的AI应用管理系统模块，是一套类似<code>Dify</code>的<code>AIGC应用开发平台</code>+<code>知识库问答</code>，是一款基于LLM大语言模型AI应用平台和 RAG 的知识库问答系统。 其直观的界面结合了 AI 流程编排、RAG 管道、知识库管理、模型管理、对接向量库、实时运行可观察等，让您可以快速从原型到生产，拥有AI服务能力。 <a href="https://link.segmentfault.com/?enc=uDOF%2BwH%2Fl4mnh%2FI7rvb%2FGQ%3D%3D.jSGPfNIjzQ%2BConhomW6Xvx5XReaXMFDW5zevshMQXco%3D" rel="nofollow" target="_blank">详细专题介绍，请点击查看</a></p><h4>适用项目</h4><p>JeecgBoot低代码平台，可以应用在任何J2EE项目的开发中，支持信创国产化。尤其适合SAAS项目、企业信息管理系统（MIS）、内部办公系统（OA）、企业资源计划系统（ERP）、客户关系管理系统（CRM）、AI知识库等，其半智能手工Merge的开发方式，可以显著提高开发效率70%以上，极大降低开发成本。 又是一个全栈式 AI 开发平台，快速帮助企业构建和部署个性化的 AI 应用。</p><p><strong>信创兼容说明</strong></p><ul><li>操作系统：国产麒麟、银河麒麟等国产系统几乎都是基于 Linux 内核，因此它们具有良好的兼容性。</li><li>数据库：达梦、人大金仓、TiDB</li><li>中间件：东方通 TongWeb、TongRDS，宝兰德 AppServer、CacheDB, <a href="https://link.segmentfault.com/?enc=9VdRVZbiPPAzxJrO2Rx58g%3D%3D.z1Rqf5SerBs2EBXXG0tfkYe4gohBEXv83q8PvsZybZuYBA6wIISG1Te%2BARYNiIWz" rel="nofollow" target="_blank">信创配置文档</a></li></ul><h4>为什么选择 JeecgBoot?</h4><blockquote>开源界"小普元"超越传统商业平台。引领低代码开发模式(OnlineCoding-&gt; 代码生成器 -&gt; 手工MERGE)，低代码开发同时又支持灵活编码， 可以帮助解决Java项目70%的重复工作，让开发更多关注业务。既能快速提高开发效率，节省成本，同时又不失灵活性。</blockquote><ul><li>1.采用最新主流前后分离框架（Spring Boot + MyBatis + Ant Design4 + Vue3），容易上手；代码生成器依赖性低，灵活的扩展能力，可快速实现二次开发。</li><li>2.前端大版本换代，最新版采用 Vue3.0 + TypeScript + Vite6 + Ant Design Vue4 等新技术方案。</li><li>3.支持微服务Spring Cloud Alibaba（Nacos、Gateway、Sentinel、Skywalking），提供简易机制，支持单体和微服务自由切换（这样可以满足各类项目需求）。</li><li>4.开发效率高，支持在线建表和AI建表，提供强大代码生成器，单表、树列表、一对多、一对一等数据模型，增删改查功能一键生成，菜单配置直接使用。</li><li>5.代码生成器提供强大模板机制，支持自定义模板，目前提供四套风格模板（单表两套、树模型一套、一对多三套）。</li><li>6.提供强大的报表和大屏可视化工具，支持丰富的数据源连接，能够通过拖拉拽方式快速制作报表、大屏和门户设计；支持多种图表类型：柱形图、折线图、散点图、饼图、环形图、面积图、漏斗图、进度图、仪表盘、雷达图、地图等。</li><li>7.低代码能力：在线表单（无需编码，通过在线配置表单，实现表单的增删改查，支持单表、树、一对多、一对一等模型，实现人人皆可编码），在线配置零代码开发、所见即所得支持23种类控件。</li><li>8.低代码能力：在线报表、在线图表（无需编码，通过在线配置方式，实现数据报表和图形报表，可以快速抽取数据，减轻开发压力，实现人人皆可编码）。</li><li>9.Online支持在线增强开发，提供在线代码编辑器，支持代码高亮、代码提示等功能，支持多种语言（Java、SQL、JavaScript等）。</li><li>10.封装完善的用户、角色、菜单、组织机构、数据字典、在线定时任务等基础功能，支持访问授权、按钮权限、数据权限等功能。</li><li>11.前端UI提供丰富的组件库，支持各种常用组件，如表格、树形控件、下拉框、日期选择器等，满足各种复杂的业务需求 <a href="https://link.segmentfault.com/?enc=ug6L0cJGklJD1ZyMFDuTGA%3D%3D.NJx1LagFqXj95jeXUQhxtsz%2BX1Cy%2B2qP0%2F0uw%2Bj9lINHNlpISjAY%2Fx8vQhKQ5iC3fGzoZjQVxyw6xC42DY%2FbAw%3D%3D" rel="nofollow" target="_blank">UI组件库文档</a>。</li><li>12.提供APP配套框架，一份多代码多终端适配，一份代码多终端适配，小程序、H5、安卓、iOS、鸿蒙Next。</li><li>13.新版APP框架采用Uniapp、Vue3.0、Vite、Wot-design-uni、TypeScript等最新技术栈，包括二次封装组件、路由拦截、请求拦截等功能。实现了与JeecgBoot完美对接：目前已经实现登录、用户信息、通讯录、公告、移动首页、九宫格、聊天、Online表单、仪表盘等功能，提供了丰富的组件。</li><li>14.提供了一套成熟的AI应用平台功能，从AI模型、知识库到AI应用搭建，助力企业快速落地AI服务，加速智能化升级。</li><li>15.AI能力：目前JeecgBoot支持AI大模型chatgpt和deepseek，现在最新版默认使用deepseek，速度更快质量更高。目前提供了AI对话助手、AI知识库、AI应用、AI建表、AI报表等功能。</li><li>16.提供新行编辑表格JVXETable，轻松满足各种复杂ERP布局，拥有更高的性能、更灵活的扩展、更强大的功能。</li><li>17.平台首页风格，提供多种组合模式，支持自定义风格；支持门户设计，支持自定义首页。</li><li>18.常用共通封装，各种工具类（定时任务、短信接口、邮件发送、Excel导入导出等），基本满足80%项目需求。</li><li>19.简易Excel导入导出，支持单表导出和一对多表模式导出，生成的代码自带导入导出功能。</li><li>20.集成智能报表工具，报表打印、图像报表和数据导出非常方便，可极其方便地生成PDF、Excel、Word等报表。</li><li>21.采用前后分离技术，页面UI风格精美，针对常用组件做了封装：时间、行表格控件、截取显示控件、报表组件、编辑器等。</li><li>22.查询过滤器：查询功能自动生成，后台动态拼SQL追加查询条件；支持多种匹配方式（全匹配/模糊查询/包含查询/不匹配查询）。</li><li>23.数据权限（精细化数据权限控制，控制到行级、列表级、表单字段级，实现不同人看不同数据，不同人对同一个页面操作不同字段）。</li><li>24.接口安全机制，可细化控制接口授权，非常简便实现不同客户端只看自己数据等控制；也提供了基于AK和SK认证鉴权的OpenAPI功能。</li><li>25.活跃的社区支持；近年来，随着网络威胁的日益增加，团队在安全和漏洞管理方面积累了丰富的经验，能够为企业提供全面的安全解决方案。</li><li>26.权限控制采用RBAC（Role-Based Access Control，基于角色的访问控制）。</li><li>27.页面校验自动生成（必须输入、数字校验、金额校验、时间空间等）。</li><li>28.支持SaaS服务模式，提供SaaS多租户架构方案。</li><li>29.分布式文件服务，集成MinIO、阿里OSS等优秀的第三方，提供便捷的文件上传与管理，同时也支持本地存储。</li><li>30.主流数据库兼容，一套代码完全兼容MySQL、PostgreSQL、Oracle、SQL Server、MariaDB、达梦、人大金仓等主流数据库。</li><li>31.集成工作流Flowable，并实现了只需在页面配置流程转向，可极大简化BPM工作流的开发；用BPM的流程设计器画出了流程走向，一个工作流基本就完成了，只需写很少量的Java代码。</li><li>32.低代码能力：在线流程设计，采用开源Flowable流程引擎，实现在线画流程、自定义表单、表单挂靠、业务流转。</li><li>33.多数据源：极其简易的使用方式，在线配置数据源配置，便捷地从其他数据抓取数据。</li><li>34.提供单点登录CAS集成方案，项目中已经提供完善的对接代码。</li><li>35.低代码能力：表单设计器，支持用户自定义表单布局，支持单表、一对多表单，支持select、radio、checkbox、textarea、date、popup、列表、宏等控件。</li><li>36.专业接口对接机制，统一采用RESTful接口方式，集成Swagger-UI在线接口文档，JWT token安全验证，方便客户端对接。</li><li>37.高级组合查询功能，在线配置支持主子表关联查询，可保存查询历史。</li><li>38.提供各种系统监控，实时跟踪系统运行情况（监控Redis、Tomcat、JVM、服务器信息、请求追踪、SQL监控）。</li><li>39.消息中心（支持短信、邮件、微信推送等）；集成WebSocket消息通知机制。</li><li>40.支持多语言，提供国际化方案。</li><li>41.数据变更记录日志，可记录数据每次变更内容，通过版本对比功能查看历史变化。</li><li>42.提供简单易用的打印插件，支持谷歌、火狐、IE11+等各种浏览器。</li><li>43.后端采用Maven分模块开发方式；前端支持菜单动态路由。</li><li>44.提供丰富的示例代码，涵盖了常用的业务场景，便于学习和参考。</li></ul><h4>技术架构：</h4><h6>前端</h6><ul><li>前端环境要求：Node.js要求<code>Node 20+</code> 版本以上、pnpm 要求<code>9+</code> 版本以上</li><li>依赖管理：node、npm、pnpm</li><li>前端IDE建议：IDEA、WebStorm、Vscode</li><li>采用 Vue3.0+TypeScript+Vite6+Ant-Design-Vue4等新技术方案，包括二次封装组件、utils、hooks、动态菜单、权限校验、按钮级别权限控制等功能</li><li>最新技术栈：Vue3.0 + TypeScript + Vite6 + ant-design-vue4 + pinia + echarts + unocss + vxe-table + qiankun + es6</li></ul><h6>后端</h6><ul><li>IDE建议： IDEA (必须安装lombok插件 )</li><li>语言：Java 默认jdk17(支持jdk8、jdk21)</li><li>依赖管理：Maven</li><li>基础框架：Spring Boot 2.7.18</li><li>微服务框架： Spring Cloud Alibaba 2021.0.6.2</li><li>持久层框架：MybatisPlus 3.5.3.2</li><li>报表工具： JimuReport 1.9.5</li><li>安全框架：Apache Shiro 1.13.0，Jwt 4.5.0</li><li>微服务技术栈：Spring Cloud Alibaba、Nacos、Gateway、Sentinel、Skywalking</li><li>数据库连接池：阿里巴巴Druid 1.1.24</li><li>AI大模型：支持 <code>ChatGPT</code> <code>DeepSeek</code>切换</li><li>日志打印：logback</li><li>缓存：Redis</li><li>其他：autopoi, fastjson，poi，Swagger-ui，quartz, lombok（简化代码）等。</li><li>默认提供MySQL5.7+数据库脚本</li></ul><h4>微服务架构图</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047129272" alt="" title=""/></p><h4>微服务解决方案</h4><blockquote><p>微服务方式快速启动</p><ul><li><a href="https://link.segmentfault.com/?enc=sN6iNAFs1DUPu%2B9wgg71lQ%3D%3D.LKNNP4rSKOVZPLTOA7LZlpeqwpJLJRouCgLfMQYDuvF0i2pFQt7HRU4EGw32%2FW%2BUTsF18oY4NuawBQdxsb3DcA%3D%3D" rel="nofollow" target="_blank">单体快速切换微服务</a></li><li><a href="https://link.segmentfault.com/?enc=r4krXA55%2B40W4e1q8UGQWw%3D%3D.jwTpnB3W6%2BxyG42PmBA%2Bi3%2FMNafI82YSRXukqKqDCo2N9aLnGLuMyZoq%2FvJvXGk7" rel="nofollow" target="_blank">Docker一键启动微服务前后端</a></li></ul></blockquote><ul><li>1、服务注册和发现 Nacos √</li><li>2、统一配置中心 Nacos √</li><li>3、路由网关 gateway(三种加载方式) √</li><li>4、分布式 http feign √</li><li>5、熔断降级限流 Sentinel √</li><li>6、分布式文件 Minio、阿里OSS √</li><li>7、统一权限控制 JWT + Shiro √</li><li>8、服务监控 SpringBootAdmin√</li><li>9、链路跟踪 Skywalking <a href="https://link.segmentfault.com/?enc=jzjGja%2FLrut41GdXwXmkNg%3D%3D.rCj3ERfDotuVReDDpFCn8tPVdqOBFHEXgIUZ9ODrKfVLhK4W%2BKnOS5BlBZynsCQ4S110wBQEydMPsgXfD5UNWw%3D%3D" rel="nofollow" target="_blank">参考文档</a></li><li>10、消息中间件 RabbitMQ √</li><li>11、分布式任务 xxl-job √</li><li>12、分布式事务 Seata</li><li>13、轻量分布式日志 Loki+grafana套件</li><li>14、支持 docker-compose、k8s、jenkins</li><li>15、CAS 单点登录 √</li><li>16、路由限流 √</li></ul><h4>Jeecg Boot 产品功能蓝图</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047129273" alt="" title="" loading="lazy"/></p><h4>系统功能架构图</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047129274" alt="" title="" loading="lazy"/></p><h4>开源版功能清单</h4><pre><code>├─系统管理
│  ├─用户管理
│  ├─角色管理
│  ├─菜单管理
│  ├─权限设置（支持按钮权限、数据权限）
│  ├─表单权限（控制字段禁用、隐藏）
│  ├─部门管理
│  ├─我的部门（二级管理员）
│  └─字典管理
│  └─分类字典
│  └─系统公告
│  └─职务管理
│  └─通讯录
│  ├─多数据源管理
│  └─多租户管理（租户管理、租户角色、我的租户）
├─Online在线开发(低代码)
│  ├─Online在线表单
│  ├─Online代码生成器
│  ├─Online在线报表
│  ├─仪表盘设计器
│  ├─系统编码规则
│  ├─系统校验规则
├─AI应用平台
│  ├─AI知识库问答系统
│  ├─AI大模型管理
│  ├─AI流程编排
│  ├─AI流程设计器
│  ├─AI对话支持图片
│  ├─AI对话助手(智能问答)
│  ├─AI建表（Online表单）
│  ├─AI聊天窗口支持嵌入第三方
│  ├─AI聊天窗口支持移动端
│  ├─支持常见大模型ChatGPT和DeepSeek、ollama等等
│  ├─AI OCR示例
├─积木报表设计器
│  ├─打印设计器
│  ├─数据报表设计
│  ├─图形报表设计（支持echart）
├─消息中心
│  ├─消息管理
│  ├─模板管理
├─代码生成器(低代码)
│  ├─代码生成器功能（一键生成前后端代码，生成后无需修改直接用，绝对是后端开发福音）
│  ├─代码生成器模板（提供4套模板，分别支持单表和一对多模型，不同风格选择）
│  ├─代码生成器模板（生成代码，自带excel导入导出）
│  ├─查询过滤器（查询逻辑无需编码，系统根据页面配置自动生成）
│  ├─高级查询器（弹窗自动组合查询条件）
│  ├─Excel导入导出工具集成（支持单表，一对多 导入导出）
│  ├─平台移动自适应支持
│  ├─提供新版uniapp3的代码生成器模板
├─系统监控
│  ├─基于AK和SK认证鉴权OpenAPI功能
│  ├─Gateway路由网关
│  ├─性能扫描监控
│  │  ├─监控 Redis
│  │  ├─Tomcat
│  │  ├─jvm
│  │  ├─服务器信息
│  │  ├─请求追踪
│  │  ├─磁盘监控
│  ├─定时任务
│  ├─系统日志
│  ├─消息中心（支持短信、邮件、微信推送等等）
│  ├─数据日志（记录数据快照，可对比快照，查看数据变更情况）
│  ├─系统通知
│  ├─SQL监控
│  ├─swagger-ui(在线接口文档)
│─报表示例
│  ├─曲线图
│  └─饼状图
│  └─柱状图
│  └─折线图
│  └─面积图
│  └─雷达图
│  └─仪表图
│  └─进度条
│  └─排名列表
│  └─等等
│─大屏模板
│  ├─作战指挥中心大屏
│  └─物流服务中心大屏
│─常用示例
│  ├─自定义组件
│  ├─对象存储(对接阿里云)
│  ├─JVXETable示例（各种复杂ERP布局示例）
│  ├─单表模型例子
│  └─一对多模型例子
│  └─打印例子
│  └─一对多TAB例子
│  └─内嵌table例子
│  └─常用选择组件
│  └─异步树table
│  └─接口模拟测试
│  └─表格合计示例
│  └─异步树列表示例
│  └─一对多JEditable
│  └─JEditable组件示例
│  └─图片拖拽排序
│  └─图片翻页
│  └─图片预览
│  └─PDF预览
│  └─分屏功能
│─封装通用组件    
│  ├─行编辑表格JEditableTable
│  └─省略显示组件
│  └─时间控件
│  └─高级查询
│  └─用户选择组件
│  └─报表组件封装
│  └─字典组件
│  └─下拉多选组件
│  └─选人组件
│  └─选部门组件
│  └─通过部门选人组件
│  └─封装曲线、柱状图、饼状图、折线图等等报表的组件（经过封装，使用简单）
│  └─在线code编辑器
│  └─上传文件组件
│  └─验证码组件
│  └─树列表组件
│  └─表单禁用组件
│  └─等等
│─更多页面模板
│  ├─各种高级表单
│  ├─各种列表效果
│  └─结果页面
│  └─异常页面
│  └─个人页面
├─高级功能
│  ├─提供单点登录CAS集成方案
│  ├─提供APP发布方案
│  ├─集成Websocket消息通知机制
│  ├─支持electron桌面应用打包(支持windows、linux、macOS三大平台)
│  ├─docker容器支持
│  ├─提供移动APP框架及源码（Uniapp3版本）支持H5、小程序、APP、鸿蒙Next
│  ├─提供移动APP低代码设计(Online表单、仪表盘)
</code></pre><h4>系统效果预览</h4><h5>PC端</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440465" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440466" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440467" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440468" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440469" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440470" alt="" title="" loading="lazy"/></p><h5>在线聊天&amp;通知</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440471" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440472" alt="" title="" loading="lazy"/></p><h5>Online开发(在线配置表单和报表)</h5><p><a href="https://link.segmentfault.com/?enc=yY%2Fx%2FKui1onHLA9GeZkIwA%3D%3D.0tBjbd6%2BSx0L144Ijl5296kjszwS6zH4x2P5vBGOdWi2nja3FzTFW9EjODm7LTSSUvZZovl%2FM%2B%2FL2oosqs35oQ8Ib3AEzkiiKJaoY1Lkah8%3D" rel="nofollow" target="_blank"><img referrerpolicy="no-referrer" src="/img/remote/1460000045590990" alt="" title="" loading="lazy"/></a></p><h5>图表示例</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266526" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266527" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266528" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266529" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266530" alt="" title="" loading="lazy"/></p><h5>AI功能</h5><p>AI聊天助手</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266522" alt="" title="" loading="lazy"/></p><p>AI建表</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046092845" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046092846" alt="" title="" loading="lazy"/></p><p>AI写文章</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046092847" alt="" title="" loading="lazy"/></p><h5>积木BI大屏</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590982" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590983" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590984" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590985" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590986" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590987" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590988" alt="" title="" loading="lazy"/></p><h5>APP效果</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266539" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266540" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266541" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266542" alt="" title="" loading="lazy"/></p><h5>PAD端</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266543" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266544" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266545" alt="" title="" loading="lazy"/></p><h5>在线接口文档</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266546" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266547" alt="" title="" loading="lazy"/></p><h5>积木报表</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440473" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440474" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440475" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440476" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440477" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440478" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440479" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440480" alt="" title="" loading="lazy"/></p><p>欢迎吐槽，欢迎star~</p>]]></description></item><item>    <title><![CDATA[深度解读虚拟列表：从原理到实战，解决长列]]></title>    <link>https://segmentfault.com/a/1190000047440568</link>    <guid>https://segmentfault.com/a/1190000047440568</guid>    <pubDate>2025-12-01 12:03:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>深度解读虚拟列表：从原理到实战，解决长列表渲染性能难题</h2><h3>前言：被长列表 “卡崩” 的前端日常</h3><p>“万级数据加载后，页面滚动像幻灯片？”<br/>“列表项含图片时，滚动到一半突然‘跳位’？”<br/>“DOM 数量破万后，浏览器直接提示‘页面无响应’？”</p><p>做前端开发的你，大概率遇到过这些场景。这不是代码能力的问题 —— 浏览器的渲染瓶颈摆在那里：每新增一个 DOM 元素，都会增加重排重绘的计算成本，当 DOM 数量突破 5000 时，多数设备都会出现明显卡顿。</p><p>而虚拟列表（Virtual List），正是为解决这个痛点而生。它的核心逻辑极其简洁：<strong>只渲染当前可视区域内的列表项，非可视区域内容完全不渲染</strong>。通过 “用空间换时间” 的思路，把 DOM 数量牢牢控制在几十到几百的常量级别，哪怕数据量达到十万级，页面也能保持丝滑滚动。</p><p>本文将完全围绕下面提供的 “可变高度虚拟列表（可配置版）”Demo 展开，从核心原理拆解、关键步骤实现，到 Demo 的实战亮点、落地避坑，帮你把虚拟列表从 “面试知识点” 变成 “业务可用的工具”。</p><h3>给你附上完整demo (这还不值得你一键三连吗？！)</h3><pre><code class="html">
&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;可变高度虚拟列表（可配置版）&lt;/title&gt;
  &lt;style&gt;
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #f5f5f5;
    }

    .container {
      display: flex;
      gap: 30px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* 虚拟列表样式 */
    .virtual-list-container {
      height: 600px; /* 可视区域高度 */
      overflow-y: auto;
      position: relative;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background: white;
      width: 600px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .virtual-list-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: -1; /* 不影响滚动 */
    }

    .virtual-list-content {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 0 16px;
    }

    .virtual-list-item {
      margin: 12px 0;
      padding: 16px;
      border-radius: 6px;
      background: #fafafa;
      border: 1px solid #eee;
      transition: background 0.2s;
    }

    .virtual-list-item:hover {
      background: #f0f9ff;
      border-color: #e1f5fe;
    }

    /* 调试面板样式 */
    .debug-panel {
      flex: 1;
      min-width: 300px;
      background: white;
      border-radius: 8px;
      padding: 20px;
      border: 1px solid #e0e0e0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .debug-panel h3 {
      margin-bottom: 20px;
      color: #2d3748;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }

    .debug-item {
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
    }

    .debug-label {
      color: #4a5568;
      font-size: 14px;
    }

    .debug-value {
      color: #2563eb;
      font-weight: 600;
      font-size: 14px;
      min-width: 60px;
      text-align: right;
    }

    /* 配置输入区域样式 */
    .config-group {
      margin: 20px 0;
      padding: 16px;
      background: #f8fafc;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }

    .config-group h4 {
      margin-bottom: 12px;
      color: #2d3748;
      font-size: 15px;
    }

    .config-item {
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .config-item label {
      flex: 1;
      color: #4a5568;
      font-size: 14px;
    }

    .config-item input {
      flex: 1;
      padding: 8px 10px;
      border: 1px solid #cbd5e1;
      border-radius: 4px;
      font-size: 14px;
      width: 100px;
    }

    .config-item input:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
    }

    .btn-apply {
      width: 100%;
      padding: 10px;
      margin-top: 8px;
      border: none;
      border-radius: 4px;
      background: #10b981;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn-apply:hover {
      background: #059669;
    }

    .control-group {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #eee;
    }

    .control-group button {
      padding: 8px 16px;
      margin-right: 10px;
      margin-bottom: 10px;
      border: none;
      border-radius: 4px;
      background: #2563eb;
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }

    .control-group button:hover {
      background: #1d4ed8;
    }

    .control-group button.reset {
      background: #94a3b8;
    }

    .control-group button.reset:hover {
      background: #64748b;
    }

    .info-text {
      margin-top: 10px;
      font-size: 12px;
      color: #718096;
      line-height: 1.5;
    }

    .error-text {
      color: #dc2626;
      font-size: 12px;
      margin-top: 4px;
      height: 16px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="container"&gt;
    &lt;!-- 虚拟列表容器 --&gt;
    &lt;div class="virtual-list-container"&gt;
      &lt;div class="virtual-list-placeholder"&gt;&lt;/div&gt;
      &lt;div class="virtual-list-content"&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- 调试面板 --&gt;
    &lt;div class="debug-panel"&gt;
      &lt;h3&gt;虚拟列表调试信息&lt;/h3&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;总列表项数：&lt;/span&gt;
        &lt;span class="debug-value" id="total-count"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;已渲染项数：&lt;/span&gt;
        &lt;span class="debug-value" id="rendered-count"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;可视起始索引：&lt;/span&gt;
        &lt;span class="debug-value" id="start-index"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;可视结束索引：&lt;/span&gt;
        &lt;span class="debug-value" id="end-index"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;滚动位置(scrollTop)：&lt;/span&gt;
        &lt;span class="debug-value" id="scroll-top"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;列表总高度：&lt;/span&gt;
        &lt;span class="debug-value" id="total-height"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;预估高度：&lt;/span&gt;
        &lt;span class="debug-value" id="estimate-height"&gt;80&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;缓冲项数量：&lt;/span&gt;
        &lt;span class="debug-value" id="buffer-count"&gt;2&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;最大缓存列表项条数：&lt;/span&gt;
        &lt;span class="debug-value" id="max-cache-size"&gt;100&lt;/span&gt;
      &lt;/div&gt;

      &lt;!-- 新增：配置输入区域 --&gt;
      &lt;div class="config-group"&gt;
        &lt;h4&gt;自定义配置&lt;/h4&gt;
        &lt;div class="config-item"&gt;
          &lt;label for="custom-total"&gt;列表总条数：&lt;/label&gt;
          &lt;input type="number" id="custom-total" placeholder="默认1000" min="1" max="100000"&gt;
        &lt;/div&gt;
        &lt;div class="config-item"&gt;
          &lt;label for="custom-buffer"&gt;缓冲项数量：&lt;/label&gt;
          &lt;input type="number" id="custom-buffer" placeholder="默认2" min="0" max="10"&gt;
        &lt;/div&gt;
        &lt;div class="config-item"&gt;
          &lt;label for="custom-estimate"&gt;预估高度(px)：&lt;/label&gt;
          &lt;input type="number" id="custom-estimate" placeholder="默认80" min="20" max="500"&gt;
        &lt;/div&gt;
        &lt;div class="config-item"&gt;
          &lt;label for="custom-maxCacheSize"&gt;最大缓存列表项条数：&lt;/label&gt;
          &lt;input type="number" id="custom-maxCacheSize" placeholder="默认100" min="0" max="200"&gt;
        &lt;/div&gt;
        &lt;div class="error-text" id="config-error"&gt;&lt;/div&gt;
        &lt;button class="btn-apply" id="apply-config"&gt;应用配置&lt;/button&gt;
      &lt;/div&gt;

      &lt;div class="control-group"&gt;
        &lt;button id="refresh-data"&gt;刷新测试数据&lt;/button&gt;
        &lt;button id="reset" class="reset"&gt;重置默认配置&lt;/button&gt;

        &lt;div class="info-text"&gt;
          说明：&lt;br&gt;
          1. 支持手动输入列表总数（1-100000）、缓冲数（0-10）、预估高度（20-500px）、缓存条数（0-200）&lt;br&gt;
          2. 列表项高度随机（含部分图片），滚动时自动校准真实高度&lt;br&gt;
          3. 缓冲数越大，滚动越流畅但渲染DOM越多；缓冲数为0可能出现空白&lt;br&gt;
          3. 缓存数越大，滚动越流畅但渲染DOM越多；复用列表项，不会重新渲染&lt;br&gt;
          4. 总数建议不超过10万，避免内存占用过高
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;script&gt;
    class VariableHeightVirtualList {
      constructor(options) {
        // 配置参数
        this.container = options.container;
        this.data = options.data;
        this.estimateHeight = options.estimateHeight || 80;
        this.buffer = options.buffer || 2;
        this.maxCacheSize = options.maxCacheSize || 100;
        this.defaultTotal = this.data.length;
        this.defaultEstimateHeight = this.estimateHeight;
        this.defaultBuffer = this.buffer;
        this.defaultMaxCacheSize = this.maxCacheSize;


        // 核心数据
        this.itemHeights = new Array(this.data.length).fill(this.estimateHeight);
        this.prefixHeights = [0];
        this.containerHeight = this.container.clientHeight;
        this.scrollTop = 0;
        this.currentStartIndex = 0;
        this.currentEndIndex = 0;
        this.cacheElements = [];
        this.cacheElementsRecord = [];

        // DOM元素
        this.placeholder = this.container.querySelector('.virtual-list-placeholder');
        this.content = this.container.querySelector('.virtual-list-content');

        // 调试DOM
        this.debugElements = {
          totalCount: document.getElementById('total-count'),
          renderedCount: document.getElementById('rendered-count'),
          startIndex: document.getElementById('start-index'),
          endIndex: document.getElementById('end-index'),
          scrollTop: document.getElementById('scroll-top'),
          totalHeight: document.getElementById('total-height'),
          estimateHeight: document.getElementById('estimate-height'),
          bufferCount: document.getElementById('buffer-count'),
          maxCacheSize: document.getElementById('max-cache-size')
        };

        // 配置输入DOM
        this.configElements = {
          customTotal: document.getElementById('custom-total'),
          customBuffer: document.getElementById('custom-buffer'),
          customEstimate: document.getElementById('custom-estimate'),
          customMaxCacheSize: document.getElementById('custom-maxCacheSize'),
          configError: document.getElementById('config-error'),
          applyBtn: document.getElementById('apply-config')
        };

        // 初始化
        this.init();
      }

      // 初始化
      init() {
        this.calcPrefixHeights();
        this.updatePlaceholderHeight();
        this.updateVisibleItems();
        this.updateDebugInfo(); // 初始化调试信息
        this.bindEvents();
        this.bindConfigEvents(); // 绑定配置相关事件
      }

      // 计算前缀和
      calcPrefixHeights() {
        for (let i = 0; i &lt; this.data.length; i++) {
          this.prefixHeights[i + 1] = this.prefixHeights[i] + this.itemHeights[i];
        }
      }

      // 更新占位高度
      updatePlaceholderHeight() {
        const totalHeight = this.prefixHeights[this.data.length];
        this.placeholder.style.height = `${totalHeight}px`;
        // 更新调试信息中的总高度
        this.debugElements.totalHeight.textContent = Math.round(totalHeight);
      }

      // 二分查找起始索引
      findStartIndex() {
        const scrollTop = this.scrollTop;
        let low = 0, high = this.prefixHeights.length - 1;

        while (low &lt;= high) {
          const mid = Math.floor((low + high) / 2);
          if (this.prefixHeights[mid] &lt;= scrollTop) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        return Math.max(0, low - 1);
      }

      // 计算结束索引
      findEndIndex(startIndex) {
        const scrollBottom = this.scrollTop + this.containerHeight;
        let endIndex = startIndex;

        while (endIndex &lt; this.data.length &amp;&amp; this.prefixHeights[endIndex + 1] &lt;= scrollBottom) {
          endIndex++;
        }

        endIndex = Math.min(this.data.length, endIndex + this.buffer);
        return endIndex;
      }

      // 渲染可见项
      updateVisibleItems() {
        this.currentStartIndex = this.findStartIndex();
        this.currentEndIndex = this.findEndIndex(this.currentStartIndex);
        const visibleData = this.data.slice(this.currentStartIndex, this.currentEndIndex);

        // 渲染项（包含索引和高度信息，方便调试）
        this.content.innerHTML = '';
        visibleData.forEach((item, idx) =&gt; {
          const realIndex = this.currentStartIndex + idx;
          this.cacheElementsRecord = this.cacheElementsRecord.filter(i =&gt; i !== realIndex);
          this.cacheElementsRecord.unshift(realIndex);
          if(this.cacheElementsRecord.length &gt; this.maxCacheSize){
            const removeIndex = this.cacheElementsRecord.pop();
            delete this.cacheElements[removeIndex];
          }
          if(this.cacheElements[realIndex]){
            this.content.appendChild(this.cacheElements[realIndex]);
            return;
          }
          const itemHeight = this.itemHeights[realIndex];
          const element = document.createElement('div');
          element.innerHTML = `
            &lt;div class="virtual-list-item" data-index="${realIndex}"&gt;
              &lt;div style="margin-bottom: 8px; color: #64748b; font-size: 12px;"&gt;
                索引: ${realIndex} | 高度: ${itemHeight}px
              &lt;/div&gt;
              &lt;div style="color: #2d3748; line-height: 1.6;"&gt;
                ${item.content}
              &lt;/div&gt;
            &lt;/div&gt;
          `;
          this.cacheElements[realIndex] = element;
          this.content.appendChild(element);
        });

        // 定位内容区
        const offsetTop = this.prefixHeights[this.currentStartIndex];
        this.content.style.transform = `translateY(${offsetTop}px)`;

        // 校准高度
        this.calibrateHeights();

        // 更新调试信息
        this.updateDebugInfo();
      }

      // 校准真实高度
      calibrateHeights() {
        const items = this.content.querySelectorAll('.virtual-list-item');
        let isHeightChanged = false;

        items.forEach(item =&gt; {
          const index = parseInt(item.dataset.index);
          const realHeight = item.offsetHeight;

          if (this.itemHeights[index] !== realHeight) {
            this.itemHeights[index] = realHeight;
            isHeightChanged = true;
            // 实时更新项内的高度显示（调试用）
            item.querySelector('div:first-child').textContent = 
              `索引: ${index} | 高度: ${realHeight}px (已校准)`;
          }
        });

        if (isHeightChanged) {
          this.calcPrefixHeights();
          this.updatePlaceholderHeight();
          this.updateVisibleItems();
        }
      }

      // 更新调试信息
      updateDebugInfo() {
        this.debugElements.totalCount.textContent = this.data.length;
        this.debugElements.renderedCount.textContent = this.currentEndIndex - this.currentStartIndex;
        this.debugElements.startIndex.textContent = this.currentStartIndex;
        this.debugElements.endIndex.textContent = this.currentEndIndex - 1; // 显示最后一个可见索引
        this.debugElements.scrollTop.textContent = Math.round(this.scrollTop);
        this.debugElements.estimateHeight.textContent = this.estimateHeight;
        this.debugElements.bufferCount.textContent = this.buffer;
        this.debugElements.maxCacheSize.textContent = this.maxCacheSize;

        // 同步输入框默认值（显示当前配置）
        this.configElements.customTotal.placeholder = this.data.length;
        this.configElements.customBuffer.placeholder = this.buffer;
        this.configElements.customMaxCacheSize.placeholder = this.maxCacheSize;
        this.configElements.customEstimate.placeholder = this.estimateHeight;
      }

      // 绑定基础事件（滚动、resize等）
      bindEvents() {
        // 滚动事件（添加防抖，优化性能）
        let scrollTimer = null;
        this.container.addEventListener('scroll', () =&gt; {
          clearTimeout(scrollTimer);
          scrollTimer = setTimeout(() =&gt; {
            this.scrollTop = this.container.scrollTop;
            this.updateVisibleItems();
          }, 10); // 10ms防抖
        });

        // 窗口resize
        window.addEventListener('resize', () =&gt; {
          this.containerHeight = this.container.clientHeight;
          this.updateVisibleItems();
        });

        // 图片加载完成后校准高度（如果项内有图片）
        this.content.addEventListener('load', (e) =&gt; {
          if (e.target.tagName === 'IMG') {
            this.calibrateHeights();
          }
        }, true);
      }

      // 绑定配置相关事件
      bindConfigEvents() {
        // 应用配置按钮点击事件
        this.configElements.applyBtn.addEventListener('click', () =&gt; {
          this.applyCustomConfig();
        });

        // 输入框回车触发应用配置
        [this.configElements.customTotal, this.configElements.customBuffer, this.configElements.customEstimate, this.configElements.customMaxCacheSize]
          .forEach(input =&gt; {
            input.addEventListener('keydown', (e) =&gt; {
              if (e.key === 'Enter') {
                this.applyCustomConfig();
              }
            });
          });
      }

      // 应用自定义配置
      applyCustomConfig() {
        const customTotal = this.configElements.customTotal.value.trim();
        const customBuffer = this.configElements.customBuffer.value.trim();
        const customEstimate = this.configElements.customEstimate.value.trim();
        const customMaxCacheSize = this.configElements.customMaxCacheSize.value.trim();
        const errorEl = this.configElements.configError;

        // 验证输入
        let errorMsg = '';
        let newTotal = this.data.length;
        let newBuffer = this.buffer;
        let newEstimate = this.estimateHeight;
        let newMaxCacheSize = this.maxCacheSize;

        // 验证总数
        if (customTotal) {
          const num = parseInt(customTotal);
          if (isNaN(num) || num &lt; 1 || num &gt; 100000) {
            errorMsg = '列表总数必须是1-100000的数字';
          } else {
            newTotal = num;
          }
        }

        // 验证缓冲数（如果输入了）
        if (!errorMsg &amp;&amp; customBuffer) {
          const num = parseInt(customBuffer);
          if (isNaN(num) || num &lt; 0 || num &gt; 10) {
            errorMsg = '缓冲数必须是0-10的数字';
          } else {
            newBuffer = num;
          }
        }

        // 验证预估高度（如果输入了）
        if (!errorMsg &amp;&amp; customEstimate) {
          const num = parseInt(customEstimate);
          if (isNaN(num) || num &lt; 20 || num &gt; 500) {
            errorMsg = '预估高度必须是20-500的数字';
          } else {
            newEstimate = num;
          }
        }

        // 验证最大缓存数（如果输入了）
        if (!errorMsg &amp;&amp; customMaxCacheSize) {
          const num = parseInt(customMaxCacheSize);
          if (isNaN(num) || num &lt; 0 || num &gt; 200) {
            errorMsg = '最大缓存列表项数必须是0-200的数字';
          } else {
            newMaxCacheSize = num;
          }
        }

        // 处理错误
        if (errorMsg) {
          errorEl.textContent = errorMsg;
          errorEl.style.color = '#fc5430';
          setTimeout(() =&gt; {
            errorEl.textContent = '';
          }, 3000);
          return;
        }

        // 生成新数据（如果总数变化）
        let newData = this.data;
        if (newTotal !== this.data.length) {
          newData = generateMockData(newTotal);
        }

        // 更新配置和数据
        this.updateConfig({
          buffer: newBuffer,
          estimateHeight: newEstimate,
          maxCacheSize: newMaxCacheSize
        });
        this.updateData(newData);

        // 清空输入框
        this.configElements.customTotal.value = '';
        this.configElements.customBuffer.value = '';
        this.configElements.customEstimate.value = '';
        this.configElements.customMaxCacheSize.value = '';

        // 提示成功
        errorEl.textContent = '配置应用成功！';
        errorEl.style.color = '#10b981';
        setTimeout(() =&gt; {
          errorEl.textContent = '';
        }, 2000);
      }

      // 外部API：更新数据
      updateData(newData) {
        this.data = newData;
        this.itemHeights = new Array(this.data.length).fill(this.estimateHeight);
        this.prefixHeights = [0];
        this.cacheElements = [];
        this.cacheElementsRecord = [];
        this.calcPrefixHeights();
        this.updatePlaceholderHeight();
        this.updateVisibleItems();
      }

      // 外部API：修改配置
      updateConfig(config) {
        if (config.estimateHeight) this.estimateHeight = config.estimateHeight;
        if (config.buffer !== undefined) this.buffer = config.buffer;
        if (config.maxCacheSize !== undefined) this.maxCacheSize = config.maxCacheSize;
        this.itemHeights = new Array(this.data.length).fill(this.estimateHeight);
        this.prefixHeights = [0];
        this.cacheElements = [];
        this.cacheElementsRecord = [];
        this.calcPrefixHeights();
        this.updatePlaceholderHeight();
        this.updateVisibleItems();
      }

      reset() {
        this.updateConfig({
          estimateHeight: this.defaultEstimateHeight,
          buffer: this.defaultBuffer,
          maxCacheSize: this.defaultMaxCacheSize
        });
        this.updateData(generateMockData(this.defaultTotal));
      }
    }

    // ---------------- 测试数据生成 ----------------
    function generateMockData(count = 1000) {
      // 随机内容长度，模拟不同高度
      const contentLengths = [1, 2, 3, 4, 5, 6, 8, 10];
      return Array.from({ length: count }, (_, i) =&gt; {
        const length = contentLengths[Math.floor(Math.random() * contentLengths.length)];
        return {
          content: `可变高度列表项 ${i + 1} 
            ${'—— 测试内容重复'.repeat(length)} 
            ${Math.random() &gt; 0.7 ? '&lt;br&gt;&lt;img src="https://picsum.photos/200/80?random=' + i + '" style="max-width:100%;border-radius:4px;margin-top:8px;" alt="测试图"&gt;' : ''}`
        };
      });
    }

    // ---------------- 初始化 + 调试控制 ----------------
    const initialData = generateMockData(1000);
    const virtualList = new VariableHeightVirtualList({
      container: document.querySelector('.virtual-list-container'),
      data: initialData,
      estimateHeight: 80,
      buffer: 2,
      maxCacheSize: 10
    });

    // 刷新数据按钮
    document.getElementById('refresh-data').addEventListener('click', () =&gt; {
      const currentTotal = virtualList.data.length;
      const newData = generateMockData(currentTotal);
      virtualList.updateData(newData);
      alert(`已刷新数据，当前共 ${currentTotal} 条`);
    });

    // 重置按钮
    document.getElementById('reset').addEventListener('click', () =&gt; {
      virtualList.reset();
      alert(`已重置默认配置：总数=${virtualList.defaultTotal}，预估高度=${virtualList.defaultEstimateHeight}px，缓冲项=${virtualList.defaultBuffer}，最大缓存列表项=${virtualList.defaultMaxCacheSize}`);
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h3>一、先搞懂：虚拟列表的核心逻辑与分类</h3><p>在写一行代码前，先理清虚拟列表的底层逻辑 —— 这是避免后续 “越写越乱” 的关键。</p><h4>1.1 虚拟列表的 3 个核心问题</h4><p>不管是固定高度还是可变高度，所有虚拟列表都要解决 3 个核心问题，Demo 也不例外：</p><ol><li><strong>范围确定</strong>：滚动时，如何精准计算 “哪些列表项在可视区域内”？<br/>比如可视区域高度 500px，列表项高度 100px，就需要知道当前该显示第 3-7 项。</li><li><strong>平滑滚动</strong>：只渲染部分项，如何让用户感觉是在滚动 “完整列表”？<br/>不能让用户看到 “跳着走” 的卡顿感，需要通过定位模拟完整滚动效果。</li><li><strong>高度适配</strong>：列表项高度不固定时（如含图片、富文本），如何避免定位错位？<br/>这是最复杂的问题 —— Demo 正是针对这个场景设计的。</li></ol><h4>1.2 虚拟列表的 2 种核心分类</h4><p>根据列表项高度是否固定，虚拟列表可分为两类，适用场景天差地别：</p><table><thead><tr><th>类型</th><th>核心特点</th><th>实现难度</th><th>适用场景</th></tr></thead><tbody><tr><td>固定高度虚拟列表</td><td>所有项高度一致，可视范围可通过公式直接计算</td><td>低</td><td>表格数据、固定卡片（如商品列表）</td></tr><tr><td>可变高度虚拟列表</td><td>项高度动态变化，需预估 + 校准真实高度</td><td>高</td><td>评论列表、富文本内容、含图片列表</td></tr></tbody></table><p>Demo 属于 “可变高度虚拟列表”—— 这也是实际业务中最常用、最能体现技术深度的类型。接下来，我们就以 Demo 为蓝本，拆解它的实现逻辑。</p><h3>二、原理拆解：可变高度虚拟列表的 5 步实现（基于Demo）</h3><p>Demo 把可变高度虚拟列表的实现拆解成了 5 个环环相扣的步骤，每个步骤都对应解决一个核心问题。我们一步步来看：</p><h4>2.1 步骤 1：初始化配置与核心数据定义</h4><p>一切从<code>VariableHeightVirtualList</code>类的构造函数开始 —— 这里定义了整个虚拟列表的 “骨架”，Demo 在这一步做了很灵活的配置化设计：</p><pre><code class="javascript">
constructor(options) {
  // 1. 外部可配置参数（灵活适配不同业务）
  this.container = options.container; // 虚拟列表容器（可视区域DOM）
  this.data = options.data; // 完整列表数据（万级/十万级）
  this.estimateHeight = options.estimateHeight || 80; // 预估高度（默认80px）
  this.buffer = options.buffer || 2; // 缓冲项数量（避免滚动空白）
  this.maxCacheSize = options.maxCacheSize || 100; // 最大DOM缓存数（防内存溢出）

  // 2. 高度相关核心数据（解决可变高度的关键）
  this.itemHeights = new Array(this.data.length).fill(this.estimateHeight); // 存储真实高度
  this.prefixHeights = [0]; // 高度前缀和：prefixHeights[i] = 前i项总高度
  this.containerHeight = this.container.clientHeight; // 可视区域高度
  this.scrollTop = 0; // 当前滚动位置（px）

  // 3. 可视区域范围数据
  this.currentStartIndex = 0; // 可视区域起始项索引
  this.currentEndIndex = 0; // 可视区域结束项索引

  // 4. DOM缓存（性能优化：复用已渲染DOM，减少重排）
  this.cacheElements = []; // 缓存DOM元素的数组
  this.cacheElementsRecord = []; // 记录缓存的索引，控制缓存大小
}</code></pre><p>这一步有 3 个 “灵魂数据”，直接决定了后续能否处理可变高度：</p><ul><li><strong><code>estimateHeight</code></strong> <strong>（预估高度）</strong>：初始化时不知道真实高度，先假设一个值（如 80px），用于计算初始的可视范围和列表总高度。</li><li><strong><code>itemHeights</code></strong> <strong>（真实高度数组）</strong>：长度和列表数据一致，初始化时用预估高度填充，后续会通过 DOM 实际高度校准。</li><li><strong><code>prefixHeights</code></strong> <strong>（高度前缀和）</strong>：比如<code>prefixHeights[3]</code> = 前 3 项总高度，通过它能快速定位滚动位置对应的列表项（后面会详细说）。</li></ul><h4>2.2 步骤 2：计算高度前缀和（快速定位的核心）</h4><p>前缀和数组<code>prefixHeights</code>是虚拟列表的 “导航地图”—— 没有它，就无法快速找到滚动位置对应的列表项。Demo 里用<code>calcPrefixHeights</code>方法实现：</p><pre><code class="javascript">
// 计算前缀和：prefixHeights[i+1] = prefixHeights[i] + itemHeights[i]
calcPrefixHeights() {
  for (let i = 0; i &lt; this.data.length; i++) {
    this.prefixHeights[i + 1] = this.prefixHeights[i] + this.itemHeights[i];
  }
  // 更新列表总高度（用于占位，让滚动条长度正确）
  this.updatePlaceholderHeight();
}

// 更新占位容器高度（模拟完整列表高度）
updatePlaceholderHeight() {
  const totalHeight = this.prefixHeights[this.data.length];
  this.placeholder.style.height = `${totalHeight}px`;
}</code></pre><p>举个具体例子理解：<br/>如果有 3 个列表项，真实高度分别是 80px、120px、100px，那么：</p><ul><li><code>prefixHeights = [0, 80, 200, 300]</code></li><li>第 2 项（索引 1）的顶部位置 = <code>prefixHeights[1] = 80px</code></li><li>第 2 项的底部位置 = <code>prefixHeights[2] = 200px</code></li><li>列表总高度 = <code>prefixHeights[3] = 300px</code></li></ul><p>有了这个数组，后续不管滚动到哪个位置，都能快速找到对应的列表项。</p><h4>2.3 步骤 3：确定可视区域范围（滚动时的 “导航”）</h4><p>当用户滚动列表时，第一步要做的就是 “确定当前该显示哪些项”—— 这需要两个关键方法：<code>findStartIndex</code>（找起始项）和<code>findEndIndex</code>（找结束项）。</p><h5>2.3.1 用二分查找找起始项（性能优化）</h5><p>起始项是 “当前滚动位置对应的第一个可见项”。如果直接遍历前缀和数组，十万级数据会很慢，Demo 用了<strong>二分查找</strong>，把时间复杂度从 O (n) 降到 O (log n)：</p><pre><code class="javascript">
// 二分查找：找到scrollTop对应的起始项索引
findStartIndex() {
  const scrollTop = this.scrollTop;
  let low = 0, high = this.prefixHeights.length - 1;
  
  while (low &lt;= high) {
    const mid = Math.floor((low + high) / 2);
    // 如果mid项的总高度 &lt;= 滚动位置，说明起始项在mid右边
    if (this.prefixHeights[mid] &lt;= scrollTop) {
      low = mid + 1;
    } else {
      // 否则在mid左边
      high = mid - 1;
    }
  }
  // low-1就是第一个顶部位置&lt;=scrollTop的项（起始项）
  return Math.max(0, low - 1);
}</code></pre><p>还是用前面的例子：如果滚动位置<code>scrollTop = 150px</code>，二分查找会发现：</p><ul><li><code>prefixHeights[1] = 80px ≤ 150px</code></li><li><code>prefixHeights[2] = 200px ＞ 150px</code><br/>所以起始项索引是<code>1</code>（第 2 项）—— 精准且高效。</li></ul><h5>2.3.2 计算结束项（加缓冲防空白）</h5><p>结束项是 “可视区域最后一个可见项”，Demo 还加了<code>buffer</code>（缓冲项）—— 这是避免滚动空白的关键：</p><pre><code class="javascript">
// 计算结束项：从起始项开始，找到超过滚动底部的项
findEndIndex(startIndex) {
  const scrollBottom = this.scrollTop + this.containerHeight; // 可视区域底部位置
  let endIndex = startIndex;
  
  // 找到第一个底部位置&gt;scrollBottom的项
  while (endIndex &lt; this.data.length &amp;&amp; this.prefixHeights[endIndex + 1] &lt;= scrollBottom) {
    endIndex++;
  }
  
  // 加缓冲项（比如buffer=2，就多渲染前后2项）
  endIndex = Math.min(this.data.length, endIndex + this.buffer);
  return endIndex;
}</code></pre><p>比如<code>buffer=2</code>，即使用户快速滚动，也会提前渲染 2 个 “备用项”，不会因为渲染不及时出现空白 —— 这是很多新手实现虚拟列表时容易忽略的优化点。</p><h4>2.4 步骤 4：渲染可视区域项 + 滚动定位</h4><p>确定了起始和结束项，就可以渲染这部分列表项了。Demo 在这里做了两个关键优化：DOM 缓存复用和<code>transform</code>定位。</p><pre><code class="javascript">
// 更新可视区域渲染内容
updateVisibleItems() {
  // 1. 先算当前可视范围
  this.currentStartIndex = this.findStartIndex();
  this.currentEndIndex = this.findEndIndex(this.currentStartIndex);
  // 2. 取可视区域的数据
  const visibleData = this.data.slice(this.currentStartIndex, this.currentEndIndex);

  // 3. 渲染可视项（复用缓存DOM，减少重排）
  this.content.innerHTML = ''; // 清空内容区（但缓存还在）
  visibleData.forEach((item, idx) =&gt; {
    const realIndex = this.currentStartIndex + idx; // 真实数据索引
    
    // 优化1：复用已缓存的DOM，不用重新创建
    if (this.cacheElements[realIndex]) {
      this.content.appendChild(this.cacheElements[realIndex]);
      return;
    }

    // 优化2：未缓存则创建新DOM，并加入缓存
    const element = document.createElement('div');
    element.className = 'virtual-list-item';
    element.dataset.index = realIndex; // 记录真实索引，后续校准高度用
    element.innerHTML = `
      &lt;div&gt;索引: ${realIndex} | 高度: ${this.itemHeights[realIndex]}px&lt;/div&gt;
      &lt;div&gt;${item.content}&lt;/div&gt;
    `;
    
    // 加入缓存，控制缓存大小（防内存溢出）
    this.cacheElements[realIndex] = element;
    this.cacheElementsRecord.push(realIndex);
    if (this.cacheElementsRecord.length &gt; this.maxCacheSize) {
      // 缓存超限时，删除最早的缓存项
      const oldIndex = this.cacheElementsRecord.shift();
      delete this.cacheElements[oldIndex];
    }

    this.content.appendChild(element);
  });

  // 4. 定位内容区：用transform模拟滚动（比top性能好，不触发重排）
  const offsetTop = this.prefixHeights[this.currentStartIndex];
  this.content.style.transform = `translateY(${offsetTop}px)`;

  // 5. 关键步骤：校准真实高度（解决可变高度问题）
  this.calibrateHeights();
}</code></pre><p>这里有两个必须注意的细节：</p><ul><li><strong>DOM 缓存复用</strong>：避免滚动时反复创建 / 销毁 DOM—— 这是性能优化的核心，Demo 还通过<code>maxCacheSize</code>控制缓存大小，防止内存溢出。</li><li><strong><code>transform</code></strong> <strong>定位</strong>：用<code>translateY</code>代替<code>top</code>定位，因为<code>transform</code>属于 “合成层操作”，不会触发浏览器重排，滚动更流畅。</li></ul><h4>2.5 步骤 5：校准真实高度（可变高度的 “灵魂”）</h4><p>前面用了预估高度，但实际列表项高度可能和预估不同（比如图片加载后高度增加）。Demo 用<code>calibrateHeights</code>方法校准真实高度，这是解决可变高度的关键：</p><pre><code class="javascript">
// 校准真实高度：用DOM实际高度更新数据
calibrateHeights() {
  const items = this.content.querySelectorAll('.virtual-list-item');
  let isHeightChanged = false; // 标记高度是否有变化

  items.forEach(item =&gt; {
    const realIndex = parseInt(item.dataset.index);
    const realHeight = item.offsetHeight; // 获取DOM真实高度

    // 如果真实高度和记录的不一致，更新数据
    if (this.itemHeights[realIndex] !== realHeight) {
      this.itemHeights[realIndex] = realHeight;
      isHeightChanged = true;
      // 实时更新项内的高度显示（调试友好）
      item.querySelector('div:first-child').textContent = 
        `索引: ${realIndex} | 高度: ${realHeight}px (已校准)`;
    }
  });

  // 高度变化后，重新计算前缀和和列表总高度
  if (isHeightChanged) {
    this.calcPrefixHeights();
    this.updateVisibleItems(); // 重新渲染，确保定位准确
  }
}</code></pre><p>比如预估高度 80px，实际 DOM 高度 120px—— 校准后，<code>itemHeights</code>数组会更新为 120px，前缀和也会重新计算，后续滚动定位就不会错位了。Demo 还在项内实时显示校准后的高度，非常方便调试。</p><h3>三、实战亮点：Demo 做对了这些事</h3><p>所提供的 “可变高度虚拟列表（可配置版）”Demo，不只是实现了核心功能，还加了很多贴近业务的设计，这些细节让它能直接落地到项目中：</p><h4>3.1 全配置化设计（灵活适配业务）</h4><p>你把预估高度、缓冲项数量、最大缓存数等关键参数都做成了外部可配置：</p><pre><code class="javascript">
// 初始化时可自定义所有核心参数
const virtualList = new VariableHeightVirtualList({
  container: document.querySelector('.virtual-list-container'),
  data: initialData, // 业务数据
  estimateHeight: 100, // 按业务调整预估高度
  buffer: 3, // 缓冲项3个，更流畅
  maxCacheSize: 150 // 缓存150个DOM，平衡性能和内存
});

// 还支持运行时更新配置
virtualList.updateConfig({
  estimateHeight: 120,
  buffer: 2
});</code></pre><p>这种设计让虚拟列表能适配不同业务场景 —— 比如商品列表用 80px 预估高度，评论列表用 120px，不用修改核心代码。</p><h4>3.2 调试面板（开发友好）</h4><p>Demo 右侧加了调试面板，实时显示总项数、已渲染项数、可视范围、滚动位置等核心数据：</p><ul><li>开发时能直观看到 “可视范围是否正确”“渲染项数是否合理”；</li><li>测试时能快速定位问题 —— 比如滚动时起始索引是否跳变，高度校准是否生效。</li></ul><p>这是很多开源虚拟列表库都没有的细节，对开发和调试太友好了。</p><h4>3.3 图片加载后重新校准（解决实际痛点）</h4><p>列表项含图片时，图片加载后高度会变化 —— Demo 考虑到了这个场景，加了图片加载监听：</p><pre><code class="javascript">
// 监听图片加载，重新校准高度
listenImageLoad() {
  this.content.addEventListener('load', (e) =&gt; {
    if (e.target.tagName === 'IMG') {
      this.calibrateHeights(); // 图片加载后重新校准
    }
  }, true);
}</code></pre><p>这一个小细节，就避免了 “图片加载后列表错位” 的常见问题 —— 很多新手实现的虚拟列表，就是因为没处理这个场景，导致上线后出现 bug。</p><h3>四、避坑指南：虚拟列表落地的 6 个高频问题</h3><p>结合Demo 和实际业务经验，总结了 6 个最容易踩的坑，每个坑都有对应的解决方案：</p><h4>4.1 坑点 1：滚动时出现空白区域</h4><p><strong>原因</strong>：缓冲项数量不足，或预估高度与真实高度偏差太大。<br/><strong>解决方案</strong>（Demo 已实现）：</p><ul><li>缓冲项<code>buffer</code>设为 2-3（根据滚动速度调整）；</li><li>预估高度尽量贴近真实高度（比如按业务数据统计平均高度）；</li><li>图片加载后重新校准高度。</li></ul><h4>4.2 坑点 2：滚动定位错位（项的位置不对）</h4><p><strong>原因</strong>：没及时校准真实高度，或前缀和计算错误。<br/><strong>解决方案</strong>：</p><ul><li>渲染完成后必须调用<code>calibrateHeights</code>；</li><li>检查前缀和计算逻辑：确保<code>prefixHeights[i+1] = prefixHeights[i] + itemHeights[i]</code>；</li><li>避免在滚动事件中做耗时操作，导致校准延迟。</li></ul><h4>4.3 坑点 3：DOM 缓存导致内存溢出</h4><p><strong>原因</strong>：缓存的 DOM 数量太多，尤其是十万级数据时。<br/><strong>解决方案</strong>（Demo 已实现）：</p><ul><li>用<code>maxCacheSize</code>控制缓存大小（建议 100-200，根据项复杂度调整）；</li><li>缓存超限时，删除最早的缓存项（<code>cacheElementsRecord</code>记录索引，先进先出）。</li></ul><h4>4.4 坑点 4：滚动卡顿（不流畅）</h4><p><strong>原因</strong>：滚动事件触发太频繁，或渲染逻辑太重。<br/><strong>解决方案</strong>：</p><ul><li>给滚动事件加 10-20ms 防抖（Demo 用了 10ms）；</li><li>用<code>transform</code>代替<code>top</code>定位（避免重排）；</li><li>减少列表项内的 DOM 嵌套（越简单越好）。</li></ul><h4>4.5 坑点 5：初始化时滚动条长度不对</h4><p><strong>原因</strong>：用预估高度计算的列表总高度，和真实总高度偏差太大。<br/><strong>解决方案</strong>（Demo 已实现）：</p><ul><li>用<code>placeholder</code>（占位容器）显示列表总高度；</li><li>高度校准后，及时更新<code>placeholder</code>的高度（<code>updatePlaceholderHeight</code>）。</li></ul><h4>4.6 坑点 6：列表项点击事件错位</h4><p><strong>原因</strong>：DOM 复用后，事件绑定的索引没更新。<br/><strong>解决方案</strong>：</p><ul><li>给每个列表项加<code>data-index</code>记录真实索引（Demo 已做）；</li><li>点击事件中通过<code>e.target.closest('.virtual-list-item').dataset.index</code>获取真实索引，不要依赖循环变量。</li></ul><h3>五、落地建议：从 Demo 到生产环境</h3><p>Demo 已经实现了核心功能，要落地到项目中，还需要补充这些细节：</p><h4>5.1 兼容性处理</h4><ul><li><strong>低版本浏览器</strong>：<code>offsetHeight</code>、<code>transform</code>在 IE11 中可用，但<code>forEach</code>、<code>slice</code>等方法需要 polyfill；</li><li><strong>移动端</strong>：监听<code>touchmove</code>事件（配合<code>touchend</code>），避免滚动延迟。</li></ul><h4>5.2 异常场景处理</h4><ul><li><strong>数据为空</strong>：显示 “暂无数据” 占位，不要渲染空列表；</li><li><strong>数据加载中</strong>：加加载动画，避免用户以为 “列表没出来”；</li><li><strong>数据更新</strong>：数据变化后，重置<code>itemHeights</code>和<code>prefixHeights</code>，重新初始化。</li></ul><h4>5.3 性能测试</h4><p>在不同场景下测试性能，确保满足业务需求：</p><ul><li><strong>数据量测试</strong>：分别测试 1 万、5 万、10 万条数据的滚动流畅度；</li><li><strong>设备测试</strong>：在低端安卓机、iPhone 旧机型上测试，避免性能瓶颈；</li><li><strong>内存测试</strong>：滚动 10 分钟后，通过 Chrome DevTools 查看内存占用，确保无泄漏。</li></ul><h3>六、总结：虚拟列表不是银弹，但能解决大问题</h3><p>虚拟列表的核心价值是 “解决长列表的性能问题”，但它不是万能的：</p><ul><li><strong>适合场景</strong>：数据量≥1000 条、列表项高度不固定、对滚动流畅度要求高；</li><li><strong>不适合场景</strong>：数据量≤500 条（直接渲染更简单，没必要用虚拟列表）。</li></ul><p>提供的“可变高度虚拟列表（可配置版）”Demo，已经覆盖了虚拟列表的核心难点：可变高度校准、DOM 缓存复用、缓冲防空白，再补充一些兼容性和异常处理，就能直接落地到生产环境。</p><p>最后记住：虚拟列表的本质是 “取舍”—— 用少量计算成本，换取 DOM 数量的大幅减少。理解了这个核心，不管遇到什么业务场景，都能灵活调整实现方案。总而言之，一键<strong>点赞、评论、喜欢</strong>加<strong>收藏</strong>吧！这对我很重要！</p>]]></description></item><item>    <title><![CDATA[艾体宝产品 | Redis 8.4 GA]]></title>    <link>https://segmentfault.com/a/1190000047440579</link>    <guid>https://segmentfault.com/a/1190000047440579</guid>    <pubDate>2025-12-01 12:02:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Redis 8.4 在性能与开发体验上全面升级，并引入全新的混合搜索能力，让构建 AI 应用的速度和便捷性再上一个台阶。其推出的混合搜索（hybrid search）功能，将全文搜索与向量搜索融为一体，实现更灵活、更智能的查询，同时在性能与内存利用率上带来显著提升。通过对 Redis Streams 逻辑的优化和一系列新增原子操作，Redis 在大规模场景下的运维也变得更加简单可靠。</p><h2>混合搜索重磅登场</h2><p>从检索增强生成（RAG）系统到自主助理，智能体的性能取决于上下文质量。真正的挑战不在于获取数据，而在于理解数据——识别哪些信息是当前相关的、哪些存储于记忆、哪些可为决策提供推理依据。智能体需以语义方式搜索“记忆”，而非依赖字面召回，并将符号推理与语义相似度结合。</p><p>Redis 一直是实时决策与上下文检索的核心，开发者长期利用混合策略预先过滤候选集，以高效缩小向量搜索空间。</p><p>过去，全文与向量相似度的融合方法复杂繁琐，需多步操作，并在精度与性能间权衡，导致延迟上升、检索体验割裂。Redis 8.4 通过全新的 <code>FT.HYBRID</code> 命令解决了这些问题——这一统一的引擎内混合检索 API 通过评分融合（倒数排序融合或线性组合）在一次查询中合并全文与向量相似度结果，生成单一排序列表，同时捕捉语义和字面匹配。这意味着无需在精度与间取舍，也无需外部评分合并。<code>FT.HYBRID</code> 可直接在查询中表达上下文意图，便捷优先检索近期记忆，利用 GEO 和 GEOSHAPE 限定地理范围，并融合语义、模糊与精确匹配，为新一代智能体构建一致、高速且具备语义感知的检索管道。</p><h2>史上最快、资源效率最高的 Redis</h2><p>Redis 8.4 继续践行 Redis 对持续性能优化的承诺。下图展示了 Redis 在典型缓存工作负载下，吞吐量（每秒操作数）在各版本间的稳步增长趋势。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440581" alt="" title=""/></p><p>8.4 版本延续这一趋势，相比 Redis 8.2，缓存场景（90% <code>GET</code>、10% <code>SET</code>）的吞吐量提升超过 30%。</p><p>通过在分布式查询中引入多线程 I/O 处理，Redis 查询引擎在高负载环境下实现了显著的性能提升。在从多个分片检索大规模结果时，并发 I/O 线程可并行处理分片响应，而非依次执行。这有效消除了单线程瓶颈带来的 CPU 饱和与吞吐受限问题，并缓解了大型集群中的长时间排队现象，从而使系统能够充分发挥各分片的计算潜力，降低资源竞争，提升查询扇出与结果聚合的流畅性。</p><p>基准测试表明，这些改进为 <code>FT.SEARCH</code> 和 <code>FT.AGGREGATE</code> 操作带来了端到端的显著提升，新增的 <code>FT.HYBRID</code> 自然也受益于此。在大规模搜索工作负载下，并行 I/O 处理使吞吐量提升达 4.7 倍，同时同比例降低查询延迟。涉及额外后处理的聚合操作同样获益，吞吐量提升约 1.4 倍，并在并发负载下缩短响应时间。在这两种场景下，多线程 I/O 为工作线程腾出了更多空间来执行实际的搜索或聚合逻辑，确保集群资源得到更均衡的利用，并在搜索与向量工作负载中实现更快响应。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440582" alt="" title="" loading="lazy"/></p><p>Redis 还优化了查询执行的内存分配管理，让 Redis 查询引擎更加健壮。开发者现在可以自定义内存溢出（OOM）时的行为。通过新增配置项 <code>search-on-oom</code>，可全面管理内存消耗方式及引擎应对策略。</p><p>Redis 继续投入降低 JSON 数据类型的内存占用。Redis 8.2 通过内联数值实现了大幅缩减，Redis 8.4 则进一步内联短字符串（最多 7 字节）。例如，包含 500 个键值元素的 JSON 数组，若所有键值均为短字符串，内存占用将减少 37%：</p><table><thead><tr><th>键值类型</th><th>Redis 8.2 内存占用</th><th>Redis 8.4 内存占用</th><th>优化效果</th></tr></thead><tbody><tr><td>短字符串（≤7 字节）</td><td>64,512 字节</td><td>40,624 字节</td><td>减少 37%</td></tr></tbody></table><p>更重要的是，Redis 如今能够更高效地存储同质 JSON 数值数组。在 8.4 版本之前，JSON 数组的每个元素都需分别存储类型和值。现在，当数组为同质（即所有元素数据类型一致）时，仅需为整个数组存储一次元素类型。对于数值数组，Redis 会自动选择最高效的元素类型（I8、U8、I16、U16、I32、U32、I64、U64、BF16、FP16、FP32 或 FP64），保证所有值均在范围内且无精度损失。例如，对于包含 100 万个数值的 JSON 数组，内存占用可减少 50% 至 92%。</p><table><thead><tr><th>数组元素类型</th><th>Redis 8.2 内存占用</th><th>Redis 8.4 内存占用</th><th>优化效果</th></tr></thead><tbody><tr><td>有符号整数[-2⁷ … 2⁷)或无符号整数[0 … 2⁸)</td><td>8.42 MB</td><td>1.14 MB</td><td>减少 87%</td></tr><tr><td>有符号整数[-2¹⁵ … 2¹⁵)或无符号整数[0 … 2¹⁶)</td><td>8.43 MB</td><td>2.19 MB</td><td>减少 74%</td></tr><tr><td>有符号整数[-2³¹ … 2³¹)或无符号整数[0 … 2³²)</td><td>8.46 MB</td><td>4.26 MB</td><td>减少 50%</td></tr><tr><td>有符号整数[-2⁶³ … 2⁶³)或无符号整数[0 … 2⁶⁴)</td><td>24.46 MB</td><td>8.43 MB</td><td>减少 66%</td></tr><tr><td>BF16 可表示的浮点值</td><td>24.43 MB</td><td>2.16 MB</td><td>减少 92%</td></tr><tr><td>FP16 可表示的浮点值</td><td>24.43 MB</td><td>2.16 MB</td><td>减少 92%</td></tr><tr><td>FP32 可表示的浮点值</td><td>24.46 MB</td><td>4.26 MB</td><td>减少 83%</td></tr><tr><td>FP64 可表示的浮点值</td><td>24.46 MB</td><td>8.43 MB</td><td>减少 66%</td></tr></tbody></table><h2>用一条命令消费空闲待处理消息与新增消息</h2><p>在 Redis Streams 中，待处理消息是指已投递至消费者组内的消费者但尚未确认的消息，这些消息会一直保留，直到被确认或删除。若消息长时间处于待处理状态，通常意味着出现异常——可能是消费客户端在处理或发送确认前崩溃，可能是消息本身存在问题（如引发死锁或处理耗时过长），也可能是消费客户端与 Redis 之间的通信发生故障。</p><p>在正常流程中，应用期望每条消息在消费后的一定时间内完成确认。若未确认，则被视为空闲待处理消息，可尝试重新投递。鉴于流式消息处理易出错，需要简洁且可靠的恢复机制。</p><p>因此，消费者既应（1）监控待处理消息列表、认领并处理空闲消息，也应（2）处理新流入的消息。</p><p>在 Redis 8.4 之前，客户端必须实现复杂逻辑才能同时消费这两类消息。</p><p>Redis 8.4 为 <code>XREADGROUP</code> 命令引入了简洁而强大的扩展，允许客户端用单条命令消费空闲待处理消息与新增消息。</p><h2>字符串键新增原子 compare-and-set 与 compare-and-delete 命令</h2><p>Compare-and-set（又称 check-and-set、compare-and-swap）和 compare-and-delete 是实现单键乐观并发控制的原子方法。使用 compare-and-set 时，客户端可以：</p><ol><li>从服务端获取值，在应用侧保存为"旧值"</li><li>在本地修改该值副本</li><li>Compare-and-set：仅在服务端值未被其他客户端修改时（即服务端值仍等于旧值），将本地变更应用到服务端</li></ol><p>假设存在一个 <code>Product:Description</code> 字符串键，用于让用户编辑产品描述（如通过网页表单）。由于每个产品描述的修改频率较低，可采用乐观并发控制，仅在该值自获取后未被其他客户端更改时才更新。</p><p>在旧版 Redis 中，若需原子化执行此过程的第三步，必须编写自定义 Lua 脚本。自 Redis 8.4 起，客户端可通过单条命令（在 <code>SET</code> 中使用 <code>IFEQ</code>、<code>IFNE</code>、<code>IFDEQ</code> 或 <code>IFDNE</code> 选项）在字符串键值未发生变化时直接更新，更加简洁高效。类似地，引入了单条命令 <code>XDELEX</code> 实现比较并删除，即仅在字符串键值未变时原子删除。</p><h2>原子设置多个字符串键并更新过期时间的新命令</h2><p>批量设置多个键并统一设置过期时间是常见需求，通常还要求仅在所有指定键已存在或均不存在时才执行设置操作。</p><p>在 Redis 8.4 之前，这一常见需求需要自定义 Lua 脚本支持。</p><p>Redis 8.4 引入了更简单快速的方案。新的单条命令 <code>MSETEX</code> 可条件性地批量设置或更新多个字符串键的值与过期时间。</p><h2>原子槽迁移简化集群运维</h2><p>Redis 集群是一种为实现高可用、可扩展性与容错能力而设计的分布式架构。它将多个 Redis 节点连接起来，使数据与流量得以分布到各个节点。Redis 集群通过 16,384 个哈希槽自动拆分并分发数据，每个节点负责持有部分哈希槽，从而支持远超单机规模的数据集。</p><p>在两种主要场景下需要改变槽与节点的映射关系，即必须在节点间迁移键：</p><ul><li>​<strong>集群重平衡</strong>​：添加新节点后，集群需将部分哈希槽（及其中键）迁移至新节点，使数据分布更均衡。移除节点前，同样需将其槽重新分配给其他节点。</li><li>​<strong>处理过载节点</strong>​：由于键内容与访问模式，特定槽或节点可能需要更多资源（内存、算力、每秒操作数或网络吞吐量）。当节点过载时，可将其槽重新分配以实现更好的性能与资源利用率，这需要从过载节点向负载较轻节点迁移槽。</li></ul><p>此前的槽迁移是非原子的。迁移过程中，键逐个移动到目标节点再从源节点删除，这会带来诸多潜在问题：</p><ul><li>​<strong>重定向与客户端复杂度</strong>​：迁移期间，部分键可能已移动而其他尚未移动。若客户端访问已迁移的键，会收到 <code>-ASK</code> 回复，必须转向目标节点重试，增加复杂度与网络延迟，还会破坏简单的管道操作。</li><li>​<strong>多键操作在 Resharding 时不可靠​</strong>​：在 <code>MGET key1 key2</code> 等多键命令中，若部分键已迁移，客户端会收到 <code>TRYAGAIN</code> 回复，必须等待整个槽迁移完成才能执行命令。</li><li>​<strong>迁移失败导致异常状态</strong>​：部分键已移动，但因目标节点内存不足等原因未能删除剩余键时，Redis 会陷入需手动修复的异常状态，常导致数据丢失。</li><li>​<strong>复制问题</strong>​：副本不一定知道槽正在迁移，可能将键视为普通删除而非发出 <code>-ASK</code> 重定向。</li><li>​<strong>性能</strong>​：逐键迁移速度慢。传统方法中键实际上逐个移动，因额外查找和网络往返而效率低下。</li></ul><p>Redis 8.4 引入原子槽迁移（ASM）解决所有这些运维问题。ASM 类似于槽级别的全量同步复制，它会将完整槽内容复制到目标节点，加上实时增量流（类似复制积压）。仅在复制完成后，Redis 才执行单次原子所有权交接。复制过程中客户端仍与源节点通信，不会遇到上述迁移中期的任何问题，从而极大提升了大规模运维 Redis 开源版的管理体验。</p><h2>立即开始使用 Redis 8.4</h2><p>所有上述增强功能现已在 Redis 8.4 开源版中正式发布。</p><p>关注并私信“艾体宝IT”，立即下载 Redis 8.4 开始使用！</p>]]></description></item><item>    <title><![CDATA[智能工艺革新：制造业数字化转型的核心驱动]]></title>    <link>https://segmentfault.com/a/1190000047440608</link>    <guid>https://segmentfault.com/a/1190000047440608</guid>    <pubDate>2025-12-01 12:02:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当前全球制造业竞争日益激烈的背景下，企业面临着从研发到生产的全链路效率提升和质量保障的双重挑战。传统工艺流程往往依赖人工经验，导致设计变更响应滞后、图纸校核效率低下、工艺文件标准化不足等问题，这些问题不仅增加了企业的运营成本，还限制了其快速响应市场需求的能力。为破解这一困局，智能工艺革新成为制造业数字化转型的关键路径，它通过人工智能技术与工业知识的深度融合，实现了从设计到生产的全流程自动化与智能化。<br/>智能工艺的核心在于其对研发流程的深度重塑。借助“数字化大研发体系”，企业能够构建一个覆盖需求分析、设计验证、工艺规划及生产交付的全链路协同平台。以Geega捷做设计研发协同平台为例，该系统通过多维度的数据整合与智能分析，将市场需求快速转化为设计参数，减少了人为干预导致的延迟与错误。在研发过程中，Geega捷做设计研发协同平台统一管理多种BOM视图，并借助内置的变更影响分析模块，实时评估设计调整对后续工艺和生产环节的影响，从而确保质量问题在早期被拦截，避免了后期返工带来的资源浪费。<br/>工艺环节的智能化升级同样不可忽视。在传统制造模式下，工艺规划和校核往往依赖工程师的重复性劳动，不仅效率低下，还难以保证工艺参数的一致性。而智能工艺专家系统（如Geega工艺引擎）通过引入多模态大模型与强化学习算法，实现了工艺参数的自动优化与标准化。例如，AI可制造性校核模块能够自动完成定位、测量与标准校核，将图纸校核时间缩短50%以上，并提升审查效率至80%。此外，AI工艺路线生成和作业工时自动生成等功能，显著减少了工程师在工序编排和工时测算上的时间投入，使其能够专注于更高价值的创新任务。<br/>智能工艺带来的价值不仅体现在效率提升上，还表现在对生产过程的精准控制与优化。以汽车制造为例，某企业通过智能工艺引擎实现了焊装车间的实时工艺参数监控与自优化，使焊点一次合格率提升至99.5%，同时将缺陷处理时间压缩至原来的1/3。在新能源电池行业，智能工艺的应用同样成果显著。某电池制造企业通过引入AI驱动的工艺规划系统，成功将产品上市周期缩短30%，并显著提升了生产质量的一致性。<br/>在这些成功案例中，广域铭岛的工业AI体系发挥了重要作用。其Geega工业AI应用平台与工业智造超级智能体矩阵，通过高效的数据标准化治理、闭环知识封装与还原能力，以及模块化智能体开发，帮助企业实现了从单点优化到全链路协同的智能化升级。例如，在极氪汽车杭州湾工厂，广域铭岛的涂装质量预测模型将缺陷定位效率提升80%，预判准确率达到97.5%，大幅降低了返修工位。而在百矿集团电解铝基地，智能工艺优化实现了年节电6000万千瓦时，年减碳量达10.7万吨，不仅提升了生产效率，还为企业的绿色转型提供了有力支持。<br/>展望未来，随着人工智能技术的不断演进，智能工艺将在制造业中发挥更大的作用。企业应从自身需求出发，选择适合的数字化转型路径，将AI技术嵌入研发、生产与协同的各个环节。广域铭岛等工业数字化服务商通过其成熟的平台与解决方案，为制造企业提供了从数据治理到智能决策的全链路支持，助力企业在激烈的市场竞争中脱颖而出。通过智能工艺的革新，制造业将迈向更加高效、智能与可持续的未来。</p>]]></description></item><item>    <title><![CDATA[如何通过智能工艺提升制造业生产效率？ 月]]></title>    <link>https://segmentfault.com/a/1190000047440616</link>    <guid>https://segmentfault.com/a/1190000047440616</guid>    <pubDate>2025-12-01 12:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>工业智能工艺如同人体的神经系统，在传统制造体系中建立了生命的协调与平衡。这是一套将人工智能、物联网、数字孪生、大数据分析等尖端技术深度整合，形成闭环、自适应、持续进化生产机制的综合解决方案。广域铭岛公司在这一领域的创新研究提出了独特的"工业智造超级智能体"架构，为制造业的数字化转型铺设了充满活力的技术长廊。<br/>在这一态势下，工业智能工艺已经从传统的单点监控转变为多维度的数据协同系统。广域铭岛的先进案例展示出工业智能工艺的全面进化路径：从重庆市的旗舰汽车工厂到浙江省的示范电解铝基地，从郑州市的电芯组装产线到华中地区的低碳铸造单元，先进的智能体架构使传统制造机器重新获得生命，建立起前所未有的工艺自感知、自优化和自决策能力。<br/>尤为引人注目的是，工业智能工艺的多智能体架构实现了神经元单元的动态协同。区域车间面临工艺波动时，边缘智能体实时监测工况，将预警信息同步至云端集群。质量算法团队立即启动因果推理模块，通过多维度数据分析在0.2秒内生成纠正策略。这种"感知-分析-执行"的秒级闭环响应机制，本质上是在物理制造流程上构建了数字神经系统。<br/>在实操层面，广域铭岛的创新体系将工业智能工艺提升到前所未有的高度。系统通过传感器网络采集生产全周期的热力参数、化学浓度、视觉质量等多个维度指标，在云端平台进行量子级的因果关联分析。调度智能体全天候执行动态排产任务，优化路径规划，完善质量控制与能源管理，年度供应链分析显示其能够使非计划停机率下降75%，能源浪费降低15%。<br/>新型工业智能工艺的价值已经在全球几十个制造场景中得到显现。以电解铝行业为例，通过整合广域铭岛的全方位解决方案，传统耗电大户实现了惊人的降耗成效：能效优化使吨铝耗电降低600度，产能提升30%，碳排放减少千吨级。这些数字背后，反映的是智能制造技术与工业文化深度融合的技术革命。<br/>制造业4.0的核心在于突破经验主义对工艺管理的制约。工业智能工艺则将这种约束转化为生产力源泉。广域铭岛正在为行业建立新一代的智能制造生态系统，它不只是简单的自动化解决方案整合者，而是真正意义上的"工艺赋能平台"。<br/>从中长期视角看，工业智能工艺将持续打破信息壁垒，构建从原材料追溯到成品交付的全生命周期洞察力。广域铭岛的技术架构预示出未来的可能：量子计算架构下的多智能体协同，将实现分子级别的工序优化；区块链技术则会赋予制造业完整、透明的碳足迹追溯能力。这种数字化变革的浪潮，正在将工业智能工艺重塑为每个制造单元的核心智能器官。</p>]]></description></item><item>    <title><![CDATA[使用 Spire.XLS for Pyt]]></title>    <link>https://segmentfault.com/a/1190000047439799</link>    <guid>https://segmentfault.com/a/1190000047439799</guid>    <pubDate>2025-12-01 11:05:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当今数据驱动的世界中，Python 已成为数据处理和分析的首选工具。而 Excel 文件作为最常见的数据存储格式之一，如何高效、准确地在 Python 中读取和处理 Excel 数据，成为了许多开发者和数据分析师面临的挑战。传统的 Python Excel 库在处理复杂 Excel 文件（如包含公式、样式、合并单元格等）时，有时会显得力不从心，甚至性能不佳。</p><p>本文将向您介绍一款功能强大、性能卓越的 Python 库—— <strong>Spire.XLS for Python</strong> 。它能够帮助您轻松驾驭各种 Excel 文件，实现高效的数据读取。通过本文，您将学习到 Spire.XLS for Python 的安装、基础用法以及深入的数据读取技巧，助您在数据处理的道路上更进一步。</p><h2>为什么选择 Spire.XLS for Python?</h2><p>Spire.XLS for Python 是一款专业的 Excel 处理库，专为 Python 开发者设计。它无需安装 Microsoft Office 即可独立运行，支持多种 Excel 文件格式（XLS、XLSX、XLSM、XLSB 等），并提供了丰富的 API，可以满足各种复杂的 Excel 处理需求。</p><h3>与其他常见的 Python Excel 库的优势</h3><ul><li><strong>功能全面</strong> ：不仅支持基本的数据读写，还能处理复杂的 Excel 元素，如公式、图表、图片、批注、条件格式、数据验证、宏等，并能完美保留这些元素的格式和属性。</li><li><strong>高性能</strong> ：针对大型文件处理进行了优化，读写速度快。</li><li><strong>格式兼容性</strong> ：能够处理各种版本的 Excel 文件，并确保数据和格式的准确性。</li><li><strong>易用性</strong> ：API 设计直观，学习曲线平缓，即使是初学者也能快速上手。</li></ul><p>在处理需要精确保留 Excel 格式和复杂元素，或者需要高性能读写场景时，Spire.XLS for Python 无疑是您的理想选择。</p><h2>Spire.XLS for Python 的安装与基础使用</h2><h3>安装 Spire.XLS for Python</h3><p>安装 Spire.XLS for Python 非常简单，只需使用 pip 命令即可：</p><pre><code class="bash">pip install Spire.XLS</code></pre><h3>创建一个简单的 Excel 文件 (准备工作)</h3><p>为了演示读取操作，我们首先创建一个包含一些基本数据的 Excel 文件。您可以手动创建一个名为 <code>Sample.xlsx</code> 的文件，或者使用以下 Python 代码生成：</p><pre><code class="python">from spire.xls import *
from spire.xls.common import *

# 创建一个工作簿
workbook = Workbook()
# 获取第一个工作表
sheet = workbook.Worksheets[0]

# 写入数据
sheet.Range["A1"].Value = "姓名"
sheet.Range["B1"].Value = "年龄"
sheet.Range["C1"].Value = "出生日期"
sheet.Range["D1"].Value = "分数"

sheet.Range["A2"].Value = "张三"
sheet.Range["B2"].Value = "25"
sheet.Range["C2"].Value = "1998-05-10"
sheet.Range["D2"].Value = "85.5"

sheet.Range["A3"].Value = "李四"
sheet.Range["B3"].Value = "30"
sheet.Range["C3"].Value = "1993-11-20"
sheet.Range["D3"].Value = "92"

# 自动调整列宽
sheet.AutoFitColumn(1)
sheet.AutoFitColumn(2)
sheet.AutoFitColumn(3)
sheet.AutoFitColumn(4)

# 保存文件
workbook.SaveToFile("Sample.xlsx", ExcelVersion.Version2016)
workbook.Dispose()
print("Sample.xlsx 文件已创建成功！")</code></pre><h3>读取 Excel 工作簿与工作表</h3><p>现在我们有了 <code>Sample.xlsx</code> 文件，接下来演示如何使用 Spire.XLS for Python 加载它并访问工作表：</p><pre><code class="python">from spire.xls import *
from spire.xls.common import *

# 创建一个工作簿对象
workbook = Workbook()

# 加载 Excel 文件
workbook.LoadFromFile("Sample.xlsx")

# 获取第一个工作表
sheet = workbook.Worksheets[0]
print(f"第一个工作表的名称是: {sheet.Name}")

# 释放资源
workbook.Dispose()</code></pre><h2>深入读取 Excel 数据</h2><h3>读取单元格数据</h3><p>Spire.XLS for Python 提供了多种方式来读取单元格数据，包括按索引和按名称：</p><pre><code class="python">from spire.xls.common import *

workbook = Workbook()
workbook.LoadFromFile("Sample.xlsx")
sheet = workbook.Worksheets[0]

# 按行、列索引读取单元格内容
cell_a1_value = sheet.Range[1, 1].Value
cell_b2_value = sheet.Range[2, 2].Value

print(f"A1 单元格的值: {cell_a1_value}")
print(f"B2 单元格的值: {cell_b2_value}")

workbook.Dispose()</code></pre><h3>遍历行和列</h3><p>高效遍历工作表中的所有行和列是数据处理的常用操作：</p><pre><code class="python"># 获取已使用范围的行数和列数
last_row = sheet.LastRow
last_column = sheet.LastColumn

# 遍历所有行和列
for row inrange(1, last_row + 1):
    row_data = []
for col inrange(1, last_column + 1):
        cell = sheet.Range[row, col]
        value = cell.Value
if cell.ValueType == CellValueType.IsDateTime:
            value = datetime.strptime(value, "%Y-%m-%d")
        row_data.append(value)
print(row_data)

# 示例：计算分数列的总和
total_score = 0
for row inrange(2, last_row + 1):
    score_cell = sheet.Range[row, 4]
if score_cell.ValueType == CellValueType.IsNumber:
        total_score += float(score_cell.Value)
print(f"\n总分数: {total_score}")

workbook.Dispose()</code></pre><h3>读取特定区域的数据</h3><p>有时我们只需要读取 Excel 文件中的某个特定区域的数据：</p><pre><code class="python">from spire.xls import *
from spire.xls.common import *

workbook = Workbook()
workbook.LoadFromFile("Sample.xlsx")
sheet = workbook.Worksheets[0]

# 读取 A1:C3 区域的数据
range_data = sheet.Range["A1:C3"]

print("--- 读取 A1:C3 区域的数据 ---")
for row_index inrange(range_data.Row, range_data.LastRow + 1):
    row_values = []
for col_index inrange(range_data.Column, range_data.LastColumn + 1):
        cell_value = sheet.Range[row_index, col_index].Value
        row_values.append(cell_value)
print(row_values)

workbook.Dispose()</code></pre><h3>处理复杂数据类型</h3><p>Spire.XLS for Python 能够准确读取各种复杂数据类型，例如，当单元格包含公式时，您可以获取公式本身或计算结果：</p><pre><code class="python">from spire.xls import *
from spire.xls.common import *

# 创建一个包含公式的 Excel 文件
workbook_formula = Workbook()
sheet_formula = workbook_formula.Worksheets[0]
sheet_formula.Range["A1"].Value = "10"
sheet_formula.Range["A2"].Value = "20"
sheet_formula.Range["A3"].Formula = "=SUM(A1:A2)"

workbook_formula.SaveToFile("FormulaSample.xlsx", ExcelVersion.Version2016)
workbook_formula.Dispose()

# 读取包含公式的 Excel 文件
workbook = Workbook()
workbook.LoadFromFile("FormulaSample.xlsx")
sheet = workbook.Worksheets[0]

# 读取公式单元格
formula_cell = sheet.Range["A3"]
print(f"A3 单元格的公式: {formula_cell.Formula}")
print(f"A3 单元格的计算结果: {formula_cell.Value}")

workbook.Dispose()</code></pre><h2>最佳实践与注意事项</h2><ul><li><strong>资源释放</strong> ：在完成 Excel 操作后，务必调用 <code>workbook.Dispose()</code> 方法来释放资源，特别是在处理大文件或长时间运行的应用程序中，以避免内存泄漏。</li><li><strong>错误处理</strong> ：在文件操作中，建议使用 <code>try-except</code> 块来捕获可能发生的异常，例如 <code>FileNotFoundError</code>、<code>InvalidCastException</code> 等，以增强程序的健壮性。</li><li><strong>性能优化</strong> ：对于特别大的 Excel 文件，考虑分块读取或只加载特定区域，以减少内存消耗和提高处理速度。</li></ul><h2>结语</h2><p>通过本文，我们详细探讨了如何使用 Spire.XLS for Python 库来高效、准确地读取 Excel 数据。从基础的安装、文件加载到深入的单元格、区域和复杂数据类型读取，Spire.XLS for Python 都展现了其强大的功能和便捷性。</p><p>无论是进行数据分析、生成报表还是自动化办公流程，Spire.XLS for Python 都能成为您处理 Excel 文件的得力助手。它能够完美应对传统库在处理复杂 Excel 文件时遇到的挑战，极大地提升您的开发效率。我们鼓励您亲自动手尝试，体验 Spire.XLS for Python 带来的便利！</p>]]></description></item><item>    <title><![CDATA[住宅代理技术深度解析：真实网络身份如何改]]></title>    <link>https://segmentfault.com/a/1190000047439803</link>    <guid>https://segmentfault.com/a/1190000047439803</guid>    <pubDate>2025-12-01 11:04:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在风控算法不断升级的今天，网络上的每一次访问都伴随“身份校验”。对于跨境电商、数据采集、广告验证和自动化测试等高敏感领域而言，能否呈现出可信、自然的访问环境，直接决定任务能否顺利执行。在所有环境构建方案中，住宅代理（Residential Proxy）被视为最接近真实用户身份的技术手段，因此在 2025 年依然是全球企业与开发者最依赖的基础设施之一。</p><h2>一、为什么住宅代理被视为“高可信网络身份”？</h2><p>住宅代理的特殊之处在于，其 IP 地址来自真实家庭网络，而非传统数据中心。换言之，目标网站看到的不是“机房服务器流量”，而是“家庭用户流量”。风控系统长期建立在 IP 信誉、使用场景、访问习惯等多维度数据之上，而住宅 IP 更符合自然用户行为模型，因此更不容易触发警报。<br/>相较之下，数据中心 IP 由于具有批量化、可识别性强、用途集中等特点，常常被归类为“潜在自动化来源”。住宅 IP 则因其混杂度高、地域分布自然，使其在账号稳定、广告访问验证和敏感采集中保持更高成功率。</p><h2>二、住宅代理的底层技术：远不只是“换一个 IP”</h2><p>很多人以为住宅代理只是提供新的 IP，但真正高质量的住宅代理服务，其底层能力远远复杂得多。<br/>首先，动态轮换技术是核心之一。服务商通常提供自动轮换、固定时长 Session、指定国家或城市等不同模式，以确保访问行为更接近真实用户访问逻辑。其次，全球节点调度系统负责选择最优路由，让用户始终从延迟最低、稳定性最强的节点访问目标网站。高端服务商还会加入智能会话保持技术，用于在登录、支付、验证等流程中保持同一 IP，避免因为 IP 漂移而触发风控。<br/>此外，还包括带宽调度、IP 信誉优化、身份混淆、用户隔离策略等系统级技术，这些能力共同决定了住宅代理是否真正适合用在敏感任务中。</p><h2>三、住宅代理在实际业务中的关键价值</h2><p>住宅代理的使用场景非常多元，但大多数都围绕“真实身份模拟”展开。对于爬虫工程师而言，住宅 IP 能有效降低反爬虫系统的压力，因为其访问行为比数据中心流量更难被归类为异常。对于跨境电商卖家与运营团队来说，住宅代理的核心价值在于提供稳定、可信的账号登录环境，避免因网络异常而触发平台的 “高风险 IP” 提示，从而降低封号和关联风险。<br/>在广告行业，验证团队需要从真实用户视角查看广告展示情况，而住宅代理正好提供多地区、低风险的访问环境，使广告验证更准确可靠。在 App、本地化测试、社交媒体运营等领域，住宅 IP 也能帮助团队更好地模拟不同地区用户的使用习惯和网络环境。</p><h2>四、住宅代理与数据中心代理的本质差异</h2><p>虽然数据中心代理价格低、带宽大，但在风控严格的平台上，它们很容易暴露自动化特征。住宅代理则呈现完全不同的身份属性，更接近真实用户自然访问节奏。因此，在高成功率、高隐匿性、高可信度的任务中，住宅代理始终是优先选择。<br/>通俗来说，数据中心代理更适合低敏任务，而住宅代理更适合需要安全性、稳定性的高敏环境。</p><h2>五、使用住宅代理时的风险与优化建议</h2><p>即便住宅代理质量再高，不合理使用依然会触发风控。首先，应避免高频、重复、密集访问，这是任何反爬系统的敏感点。其次，必须确保设备指纹与 IP 组合一致，否则行为模型仍可能不匹配。再者，对于需要长会话的任务，应明确选择固定 Session，而不是频繁轮换 IP。最后，建议合理规划线程数量，过高并发会导致资源拥堵，也可能触发目标网站的行为限制。<br/>合理使用住宅代理，往往比代理本身更影响成功率。</p><h2>六、住宅代理为何成为 2025 年反风控关键基础设施</h2><p>随着 AI 风控能力越来越强，网站会同时检测 IP 信誉、设备指纹、访问路径、行为特征等多维信号。如果想让访问行为更像“人类用户”，就必须构建一个由真实 IP、真实指纹和真实行为组成的综合环境。<br/>住宅代理正是这一体系的基础，它解决的是最底层也是最关键的“网络身份可信度”。无论是跨境电商账号稳定、社交媒体矩阵运营、广告投放验证，还是自动化测试与高风控网站访问，住宅代理都将继续作为核心网络基础设施被广泛使用。</p>]]></description></item><item>    <title><![CDATA[极狐GitLab 18.6 发布，包括：]]></title>    <link>https://segmentfault.com/a/1190000047439861</link>    <guid>https://segmentfault.com/a/1190000047439861</guid>    <pubDate>2025-12-01 11:03:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>沿袭我们的月度发布传统，<strong>极狐GitLab 发布了 18.6 版本</strong>。本次更新的亮点包括：<strong>Maven 虚拟仓库 UI（Beta）</strong>、<strong>全新个人主页</strong>、<strong>实例级合规与安全策略管理</strong> 以及 <strong>DAST 认证脚本</strong> 等。</p><p>这些能力聚焦产品规划协作、软件供应链与安全运营的效率提升，帮助团队在一个平台里完成从计划到交付、从开发到防护的闭环。</p><h3>版本信息</h3><p><strong>容器镜像</strong></p><ul><li>18.6.0 容器镜像</li></ul><pre><code class="plaintext">registry.gitlab.cn/omnibus/gitlab-jh:18.6.0-jh.0</code></pre><ul><li>18.6.0 Helm Chart（JH）</li></ul><pre><code class="plaintext">helm search repo gitlab-jh
NAME                      CHART VERSION APP VERSION 
gitlab-jh/gitlab          9.6.0         v18.6.0    
gitlab-jh/gitlab-runner   0.83.0        18.6.0</code></pre><h3>18.6 关键功能</h3><h3>全新的 GitLab UI：为生产力而设计</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>我们推出了一个更智能、更直观的 GitLab 用户界面，它将开发者的生产力放在首位。</p><p>全新的并排布局采用上下文面板，使你始终处于自己的工作流之中，减少不必要的点击，并帮助团队更快速地工作。</p><p>你可以自定义工作空间，最大化利用屏幕空间，并享受一个更简洁、更动态、能够适应你工作流的体验。</p><p>GitLab 致力于持续改进，因此欢迎在反馈 issue 中分享你的想法，共同塑造 GitLab 的未来。</p><h3>精确代码搜索</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>随着本次版本发布，精确代码搜索现已进入限量可用阶段。你可以使用精确匹配模式和正则表达式模式，在整个实例、在某个群组或在某个项目中执行代码搜索。精确代码搜索基于开源搜索引擎 Zoekt 构建。</p><p>在 <strong>jihulab.com</strong> 上，精确代码搜索默认已启用。  <br/>在 GitLab 自托管版本中，管理员必须先安装 Zoekt，并启用精确代码搜索。</p><h3>CI/CD 组件可以引用它们自身的元数据</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>过去，CI/CD 组件无法在其配置中引用自身的元数据，例如版本号或提交 SHA。  <br/>缺少这些信息会导致你只能使用写死的配置值，或者依赖复杂的变通方案。  <br/>以这种方式编写配置可能导致在构建 Docker 镜像等资源时出现版本不匹配的问题，因为没有办法自动将这些资源与组件的兼容版本进行标记。</p><p>在本次版本更新中，我们引入了通过 <code>spec:component</code> 关键字访问组件上下文的能力。  <br/>现在，当你发布组件版本时，可以构建并发布带版本的资源（例如 Docker 镜像），确保所有内容保持同步，消除手动版本管理，并避免版本不一致的问题。</p><h3>支持在 <code>needs:parallel:matrix</code> 中使用动态作业依赖关系</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p><code>parallel:matrix</code> 允许你轻松并行运行多个具有不同配置需求的作业，例如同时测试多平台代码。但是，如果你希望后续作业使用 <code>needs:parallel:matrix</code> 来依赖某些特定的并行作业，以往的配置会非常复杂、难以维护，且灵活性不足。</p><p>在本次发布中，我们引入了一个新的 <strong>Beta 特性</strong>：<code>$[[matrix.VARIABLE]]</code> 表达式。  <br/>借助此功能，你可以创建 <strong>动态的一对一作业依赖关系</strong>，让复杂的 <code>parallel:matrix</code> 配置更加易于管理。</p><p>这样可以帮助你创建更加高效的流水线，带来以下好处：</p><ul><li>更快的流水线执行速度</li><li>更高效的制品（artifact）处理</li><li>更好的可扩展性</li><li>更简洁的 CI 配置结构</li></ul><p>此特性对以下场景特别有价值：</p><ul><li>多平台构建</li><li>多环境 Terraform 部署</li><li>任何需要跨多维度进行并行处理的工作流</li></ul><p>你可以参考官方文档进一步了解配置方式。</p><h3>GitLab Security Analyst Agent 作为基础代理正式可用</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr></tbody></table><p>GitLab Security Analyst Agent（安全分析代理）现在已经成为 GitLab Duo Agentic Chat 的基础代理（foundational agent）。  <br/>这意味着用户不再需要从 AI Catalog 中手动添加该代理；在自托管（Self-Managed）环境中，它也默认可用。</p><p>这个专门的安全助手提供了 <strong>AI 原生的漏洞管理与安全分析能力</strong>，帮助你在无须任何额外配置的情况下完成以下工作：</p><ul><li>调查安全发现（Findings）</li><li>分析与分流（triage）漏洞</li><li>浏览合规性（compliance）相关要求</li></ul><p>当前该功能为 <strong>Beta</strong> 状态，欢迎在对应 Issue 中提供反馈。</p><h3>安全仪表板升级（在 jihulab.com 进入 Beta 阶段）</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td> </td></tr></tbody></table><p>新版安全仪表板已经过更新和现代化改进。本次 Beta 版本的初始功能包括：</p><ul><li><p><strong>漏洞随时间变化的趋势图</strong>，支持：</p><ul><li>基于项目或报告类型的筛选</li><li>按报告类型或严重级别进行分组</li><li>直接跳转到漏洞报告中的对应漏洞</li></ul></li><li><strong>风险评分模块</strong>：基于 GitLab 算法，为群组或项目计算估算的风险评分。</li></ul><p>在 18.6 中发布的新安全仪表板 <strong>目前仅在 jihulab.com</strong></p><h3>GitLab Coderider Planner Agent 现已默认可用</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td> </td></tr></tbody></table><p>GitLab Coderider Planner Agent 现在已经在 GitLab Coderider Chat 的代理下拉菜单中默认可用，无需再从 AI Catalog 手动添加。  <br/>凭借对你的工作项（work items）、Epic、Issue 和任务的完整上下文理解，Planner Agent 现在可以在 <strong>群组级别</strong>和 <strong>项目级别</strong> 协助你完成规划工作。</p><p>你可以通过文档中提供的示例提示来开始使用，借助 Planner Agent 来：</p><ul><li>分解复杂工作</li><li>创建可执行的实现计划</li><li>组织团队目标</li></ul><p>该功能目前处于 Beta 阶段，欢迎在对应 Issue 中提供反馈。</p><h3>新的 GitLab CLI 功能与改进</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>GitLab CLI（<code>glab</code>）为你的命令行 GitLab 工作流带来了新的功能与改进：</p><ul><li><strong>增强的认证体验</strong>：在登录时自动从 Git 远程仓库中检测 GitLab URL，使你更容易对正确的 GitLab 实例完成认证。</li><li><strong>灵活的流水线监控</strong>：使用 <code>ci-view</code> 命令通过流水线 ID 查看任意流水线。</li><li><strong>GPG 密钥管理</strong>：通过新的命令直接在 CLI 中管理 GPG 密钥。</li><li><strong>项目成员管理</strong>：可以从命令行添加、移除和更新项目成员。</li><li><strong>更完善的 Git 集成</strong>：增强的 <code>git-credential</code> 插件现已支持所有令牌类型。</li><li><strong>现代化界面</strong>：更新了提示库，为确认对话框和其他 UI 组件提供更一致的 GitLab 主题体验。</li></ul><p>如需查看所有更改内容，请访问 CLI 发布说明。  <br/>如需开始使用 GitLab CLI 或升级到最新版本，请参考安装指南。</p><h3>Web IDE 支持离线的 GitLab 私有化部署环境</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td> </td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>在离线或严格受控的网络环境中，GitLab 私有化部署（Self-Managed）的管理员现在可以配置自定义的 Web IDE 扩展主机域名，使 Web IDE 在 <strong>无外网访问的情况下仍能完整使用功能</strong>。</p><p>此前，Web IDE 需要访问外部域名 <code>.cdn.web-ide.gitlab-static.net</code> 来加载 VS Code 扩展和相关功能，这使得许多具有高安全要求的组织（如政府部门、公共机构、拥有严格网络隔离策略的企业）无法使用 Web IDE。</p><p>通过本次更新，管理员可以将 Web IDE 所需的资源直接由 GitLab 实例自身提供，彻底消除了对外部域名的依赖。这样你可以：</p><ul><li><strong>在完全离线环境中使用完整的 Web IDE 功能集</strong></li><li><strong>通过自定义扩展注册表服务启用扩展市场（Extension Marketplace）</strong></li><li><strong>在隔离网络中启用 Markdown 预览、代码编辑以及 GitLab Coderider Chat</strong></li></ul><p>这项改进大幅提升了 Web IDE 在高安全场景下的可用性与部署灵活性。</p><h3>系统触发的审批重置现已提供 Webhook 事件</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS（jihulab.com）</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>将 GitLab 与外部系统通过 Webhook 集成，对自动化工作流和让团队随时掌握合并请求状态变化至关重要。  <br/>然而，当 GitLab 自动重置审批（例如在启用了 “Reset approvals on push” 时，有新提交推送到合并请求），外部系统无法区分这是 <strong>系统触发</strong> 还是 <strong>用户手动操作</strong>。</p><p>现在 GitLab 增强了 Webhook 载荷，能够明确标识系统触发的审批重置事件。  <br/>当审批被自动重置时，Webhook 事件中会包含：</p><ul><li><code>system: true</code> —— 表示此次变更由系统触发</li><li><p><code>system_action</code> —— 提供更具体的上下文，例如：</p><ul><li><code>approvals_reset_on_push</code></li><li><code>code_owner_approvals_reset_on_push</code></li></ul></li></ul><p>通过这些增强信息，你的 Webhook 集成可以：</p><ul><li>准确区分手动与系统自动的审批变更</li><li>根据不同的事件类型触发更精细化的自动化流程</li><li>优化外部系统的通知、审计与工作流处理</li></ul><p>此改进使得自动化系统在面对审批变更时更加可控、可追踪，也能更智能地响应具体的上下文。</p><h3>Helm chart 仓库：取消 1,000 个 Chart 的限制</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS（jihulab.com）</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>在过去的版本中，GitLab 的 Helm Chart 仓库会在请求时动态生成元数据响应。当仓库中 Chart 数量庞大时，这种机制会产生性能瓶颈。为了维持系统稳定性，GitLab 被迫对外只提供 <strong>最近 1,000 个 Chart</strong> 的元数据。</p><p>这导致：</p><ul><li>访问更旧版本 Chart 时频繁出现 <strong>404 错误</strong></li><li><p>平台团队不得不采取复杂绕路方案，例如：</p><ul><li>将 Chart 拆分到多个仓库</li><li>手动管理 Chart 保留策略</li><li>使用独立的 Chart 存储服务</li></ul></li></ul><p>这些复杂性增加了运维负担，并使部署流程碎片化，阻碍了集中化管理。</p><p>在 GitLab 18.6 中，我们通过 <strong>预计算 Chart 元数据并将其存储到对象存储中</strong> 的方式，彻底消除了此前的 1,000 个 Chart 限制。</p><p>这样带来两大显著提升：</p><ol><li><strong>Chart 数量不再受限，所有版本均可正常访问</strong></li><li><strong>性能大幅提升</strong>：元数据只需后台任务生成一次，而不是每个请求都重新生成</li></ol><p>这一架构调整为 Helm Chart 的管理和交付带来了更高的稳定性和可扩展性。</p><h3>合并请求审批策略的 bypass 例外机制</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr></tbody></table><p>组织现在可以为特定的用户、群组、角色或自定义角色配置 <strong>绕过（bypass）合并请求审批策略</strong> 的权限，以便在处理关键事件或紧急问题时更快速地响应。在保持完整审计与治理控制的前提下，这一能力提供了必要的灵活性。</p><h4>主要能力包括：</h4><h4>带有责任追踪的紧急 bypass</h4><p>在面对重大事故、安全热修复或紧急生产问题时，授权用户可以立即合并或推送代码，无需等待审批。  <br/>系统会记录所有细节，包括理由说明，确保合规与可追踪性。</p><h4>规范化的 bypass 流程</h4><p>当授权用户触发 bypass 时，需要填写详细原因，确保每一次例外行为均被完整记录。</p><h4>全面的审计集成</h4><p>每一次 bypass 操作都会生成审计事件，包含：</p><ul><li>执行用户</li><li>策略上下文</li><li>说明理由</li><li>时间戳</li></ul><p>这些记录确保策略例外的透明度与可追踪性。</p><h4>灵活的配置方式</h4><p>可以通过 YAML 或 UI 配置例外对象，包括：</p><ul><li>单个用户</li><li>GitLab 群组</li><li>标准角色</li><li>自定义角色</li></ul><h4>支持 Push 操作的例外</h4><p>拥有例外权限的用户，可在推送时使用：</p><pre><code class="plaintext">security_policy.bypass_reason</code></pre><p>填写绕过审批策略的原因。</p><h3>合并请求审批策略的警告模式（Beta）</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr></tbody></table><p>安全团队现在可以使用 <strong>警告模式（warn mode）</strong> 来测试与验证安全策略的影响，而无需立即启用强制执行（enforce）。  <br/>这可以帮助在策略上线前减少开发者阻力，并让安全团队逐步推动策略落地。</p><h4>警告模式的能力包括：</h4><h4>非阻断式的安全提示</h4><p>当策略处于警告模式时：</p><ul><li>合并请求不会被阻塞</li><li>系统会自动生成说明性评论</li><li>用户可以看到策略建议，但仍可正常流程推进</li></ul><p>适合在策略上线前评估影响并引导开发者了解新要求。</p><h4>可选的联系人（approvers-as-contact）</h4><p>你可以设置可选审批者作为策略咨询联系人，方便开发者快速获取策略相关协助。</p><h4>构建信任的渐进式策略推广</h4><p>安全团队可以先通过警告模式收集合并请求中的行为数据与反馈，再逐步切换到强制模式，确保上线更顺畅。</p><h4>明确的模式展示</h4><p>在合并请求页面中有清晰的指示显示当前策略为：</p><ul><li>warn（警告模式）</li><li>enforce（强制模式）</li></ul><p>开发者可以明确知道影响程度。</p><h4>审计事件与违规跟踪</h4><p>系统会记录：</p><ul><li>策略违规</li><li>驳回原因</li><li>解除警告的说明</li></ul><p>这些用于合规报告与审计追踪。</p><h4>允许开发者提供理由来忽略漏洞</h4><p>在警告模式与强制模式下，开发者都可以提供理由来忽略漏洞，使安全团队更好理解业务场景。</p><h3>群组所有者可以为企业用户更新主邮箱地址</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td> </td></tr></tbody></table><p>群组所有者现在可以通过 <strong>Users API</strong> 更新其群组内的企业用户（Enterprise User）的主邮箱地址。</p><p>在此之前，每位企业用户都需要自行修改自己的邮箱，这在大规模组织中会带来巨大的管理负担。  <br/>通过此更新，管理员或群组所有者可以集中完成邮箱变更工作，使企业级账号管理更加高效、可控。</p><p>此特性对以下场景尤其有用：</p><ul><li>企业邮箱统一迁移（如更换公司域名）</li><li>用户批量账号调整</li><li>合规要求下需要统一管理用户主邮箱</li><li>大型组织用户生命周期管理（入职 / 离职 / 账户合并）</li></ul><h3>现在 Code Owners 支持继承的组成员身份</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS（jihulab.com）</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>Code Owners 现在支持继承的组成员身份，作为有效的审批人。  <br/>之前，要在 <code>CODEOWNERS</code> 文件中引用一个组，该组必须直接被邀请到每个具体的项目，即使它已经是父组的成员。</p><p>现在，具有继承访问权限的组，也能在启用 Code Owners 审批时，作为有效的审批人。  <br/>这意味着不再需要将组直接邀请到每个项目中。</p><p>现有的 <code>CODEOWNERS</code> 文件不需要做任何修改，仍然可以正常工作，并且对于关键代码路径的审批权限控制保持一致。</p><p>这一变化减少了管理员的管理负担，同时保持了 Code Owners 提供的安全性和审批要求。</p><h3>主页上可以切换草稿合并请求的可见性</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>在主页上，草稿合并请求可能会混杂在正常的合并请求视图中，影响需要立即处理的工作。以前，你无法将草稿合并请求从视图中移除。</p><p>现在，你可以在 <strong>显示偏好设置</strong> 中选择隐藏草稿合并请求，避免其干扰主页上的其他工作。  <br/>当你隐藏草稿合并请求时：</p><ul><li>它们将从活动计数中排除</li><li>页面底部将显示已过滤的草稿合并请求数量</li><li>你的偏好设置将自动保存</li></ul><p>此功能帮助你专注于需要立即处理的合并请求，提高工作效率。</p><h2>GitLab MCP 服务器现已提供 Beta 版本</h2><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>GitLab MCP 服务器现已提供beta版本。  <br/>通过 GitLab MCP 服务器，你可以使用诸如 Claude Code、Cursor 以及其他 MCP 兼容工具等 AI 助手，与 GitLab 项目、Issue、合并请求以及流水线进行交互，而无需为每个工具分别构建自定义集成。</p><p>要开始使用，请在你的 Coderider 设置中开启 Beta 和实验性功能。</p><p>GitLab MCP 服务器提供涵盖 Issue、合并请求与流水线的关键工具，  <br/>我们将继续根据用户反馈进行改进。  <br/>此功能目前可能包含不完整的特性或 Bug。</p><h2>列出项目和群组成员的速率限制</h2><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>我们为 <code>/api/v4/projects/:id/members/all</code> 和 <code>/api/v4/groups/:id/members/all</code> 端点引入了速率限制，以提升 API 稳定性并确保所有用户的公平资源使用。</p><p>现在，<code>GET /api/v4/projects/:id/members/all</code> 和 <code>GET /api/v4/groups/:id/members/all</code> 端点对每位用户的速率限制为 <strong>每分钟 200 次请求</strong>。</p><p>此更改有助于保护 GitLab 实例免受过度 API 使用的影响，避免影响所有用户的系统性能。</p><p>每分钟 200 次请求的限制能够满足正常使用场景，同时可以防止滥用或意外导致的资源耗尽。</p><p>如果你的集成或脚本使用了该端点，请确保它们能正确处理速率限制响应（<strong>HTTP 429</strong>），并按需实现带有退避策略的重试逻辑。</p><p>在正常使用情况下，大多数用户不会受到此项更改的影响。</p>]]></description></item><item>    <title><![CDATA[在JVS支持哪些登录方式？一文了解JVS]]></title>    <link>https://segmentfault.com/a/1190000047439964</link>    <guid>https://segmentfault.com/a/1190000047439964</guid>    <pubDate>2025-12-01 11:03:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在企业数字化浪潮中，我们要用到不同的系统，每次使用的时候账号密码登录太麻烦。在JVS这套开源框架中，支持多种登录方式，可以构建统一、安全的登录方式，满足不同用户群体的多样化需求。<br/>JVS支持多种登录模式，默认支持账号密码、手机号+动态验证码（前提配置短信通道） ，除了这两种模式，还支持钉钉、企业微信、公众号、ldap等。<br/>实现的效果如图所示：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439966" alt="图片" title="图片"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439967" alt="图片" title="图片" loading="lazy"/></p><h2>配置流程</h2><p>首先，进入钉钉的后台设置，在工作台中点击获取应用，进入开发者后台：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439968" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439969" alt="图片" title="图片" loading="lazy"/><br/>进入开发应用<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439970" alt="图片" title="图片" loading="lazy"/><br/>①、点击“自建应用”<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439971" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439972" alt="图片" title="图片" loading="lazy"/><br/>②、填写应用名称、图标logo等<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439973" alt="图片" title="图片" loading="lazy"/><br/>③、点击应用详情，进入应用详细信息页面，选择进入。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439974" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439975" alt="图片" title="图片" loading="lazy"/><br/>④、保存下来几个信息，用于后续的地址拼装，也需要回填到JVS的配置中去。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439976" alt="图片" title="图片" loading="lazy"/><br/>⑤、选中开发管理，点击修改<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439977" alt="图片" title="图片" loading="lazy"/><br/>⑥、填写应用首页地址与PC端首页地址<br/>地址说明：<br/>应用首页地址=域名+/#/login/dingtalk?corpId=$CORPID$&amp;agentId=agentid<br/>例如：应用首页地址=<a href="https://link.segmentfault.com/?enc=ELWpQpmwmpRgRcVy%2FCtTxw%3D%3D.qkzgBH6En32lD48oWmH35ET6xuKOsmlOz05fJOpsNZDRwbiEhZKf6f2lULNKDqoQT92s%2FTFHfzeO4diPdghXYg%3D%3D" rel="nofollow" target="_blank">https://knowledge.bctools.cn/#/login/dingtalk?corpId=</a>$CORPID$&amp;agentId=agentid<br/>PC端首页地址与应用首页地址相同。<br/>CORPID在右上角可以找到。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439978" alt="图片" title="图片" loading="lazy"/><br/>点击权限管理，选中通讯录管理，选中如图所示的几个对应授权<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439979" alt="图片" title="图片" loading="lazy"/><br/>进入登录分享，设置回调域名<br/>回调地址=域名+/#/login/dingtalk/scanback<br/>例如：回调地址=<a href="https://link.segmentfault.com/?enc=8ZW3rtRf8wUKpZ9d8k0GHw%3D%3D.l4r%2BpFsqc%2BSMykCcaMNgZLyrB4Fskix5v4mQJit1ZgowgeocgsMtmBl9InRZnb43DqXsCQ3fd30adlIpZ8DoRw%3D%3D" rel="nofollow" target="_blank">https://knowledge.bctools.cn/#/login/dingtalk/scanback</a><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439980" alt="图片" title="图片" loading="lazy"/><br/>安全设置配置<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439981" alt="图片" title="图片" loading="lazy"/><br/>发布应用。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439982" alt="图片" title="图片" loading="lazy"/><br/>分享设置<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439983" alt="图片" title="图片" loading="lazy"/><br/>以管理员身份进入JVS管理界面<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439984" alt="图片" title="图片" loading="lazy"/><br/>填入从响应的 几个参数。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439985" alt="图片" title="图片" loading="lazy"/><br/>最后界面展示效果：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439986" alt="图片" title="图片" loading="lazy"/><br/>如果在系统中已经有存在的账号，那么可以关联绑定钉钉账号<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439987" alt="图片" title="图片" loading="lazy"/><br/>通过钉钉扫码绑定即可<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439988" alt="图片" title="图片" loading="lazy"/><br/>在钉钉中也可以进行直接打开应用，并且会自动登录当前关联账号。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439989" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439990" alt="图片" title="图片" loading="lazy"/><br/>在线Demo：<a href="https://link.segmentfault.com/?enc=z37DyWJ6prSRG5vJ9P0jGg%3D%3D.sSCrP%2B92s5xHi5XxO9p8YGViBPmJYGh1YGLJpj6zUWA%3D" rel="nofollow" target="_blank">http://frame.bctools.cn</a><br/>代码仓库：<a href="https://link.segmentfault.com/?enc=iBYjlXEH7MR8MCoTu1RAJA%3D%3D.nIs%2FAJbES2da9uw7ewx6G0apHpJZuOK5Wtbbrg6NPJyotBu3kHQsVEvsZhMJi6v%2B" rel="nofollow" target="_blank">https://gitee.com/software-minister/jvs</a></p>]]></description></item><item>    <title><![CDATA[2025主流CRM品牌深度横评：从数据底]]></title>    <link>https://segmentfault.com/a/1190000047440050</link>    <guid>https://segmentfault.com/a/1190000047440050</guid>    <pubDate>2025-12-01 11:02:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化转型的浪潮中，客户关系管理（CRM）已从“辅助工具”升级为企业实现<strong>精准获客、高效转化、长期留存</strong>的核心引擎。不同行业、规模的企业对CRM的需求差异显著——有的需要深度业财协同，有的依赖AI驱动的销售自动化，有的则更看重多渠道获客与线索转化。</p><p>本文基于<strong>客户信息管理、销售管理、市场营销自动化、客户服务与支持、</strong> <strong>数据分析</strong> <strong>与报表、移动办公与集成</strong>六大核心领域，对当前市场主流CRM品牌（超兔一体云、Salesforce、探迹EC、Zoho、HubSpot、金蝶云·星辰）进行深度横向对比，拆解各品牌的核心优势与适配场景，为企业选型提供专业参考。</p><h2>一、客户信息管理：从“碎片化”到“一体化”，构建精准客户画像的核心能力</h2><p>客户信息是CRM的“数据底座”，其质量直接决定了后续销售、营销与服务的效率。本部分从<strong>360°视图完整性、多渠道数据整合、</strong> <strong>智能补全</strong> <strong>与查重、权限与共享</strong>四个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440052" alt="" title=""/></p><table><thead><tr><th>品牌</th><th>360°视图核心能力</th><th>多渠道数据整合</th><th>智能补全/查重能力</th><th>权限与共享机制</th></tr></thead><tbody><tr><td>超兔一体云</td><td>整合工商信息、手机号关联微信/支付宝头像，构建“基础信息+行为轨迹”双维度画像</td><td>覆盖百度、抖音、官网、微信、地推、工商搜客等10+渠道，自动汇总线索/客户数据</td><td>自动补全工商信息（天眼查/百度）、手机号查重、企业简称模糊查重</td><td>岗位级权限（财务看财务数据、上级管下级）、助理跟随主管、老板全局管理</td></tr><tr><td>Salesforce</td><td>整合销售、服务、营销、IT多部门数据，通过Data Cloud激活实时数据，构建全链路视图</td><td>对接销售系统、客户热线、社交媒体等，Data Cloud盘活“沉睡”数据至CRM</td><td>批量导入/排重、多条件搜索，控制修改/删除权限</td><td>批量共享/分配/转移、下级客户可见、严格业务员查看范围</td></tr><tr><td>探迹EC</td><td>200+维度企业画像（含工商、财务、经营状态），智能名片追踪客户浏览轨迹</td><td>依托1亿+企业知识图谱，整合呼叫中心、AI外呼、展会、招投标等场景，每月新增100万+线索</td><td>智能名片轨迹追踪、成单数据反馈优化线索模型（意向率提升3.5倍）</td><td>公海/私海分配、离职客户资源继承、低代码权限配置</td></tr><tr><td>Zoho</td><td>自定义字段（如“课程意向”），整合销售、服务数据，支持多条件筛选</td><td>对接销售系统、客户服务热线、社交媒体，实现统一管理</td><td>自定义字段补全、自动化分配线索，Zia AI辅助查重</td><td>分级权限（上级看下级）、客户资料修改/删除权限控制</td></tr><tr><td>HubSpot</td><td>整合Gmail/Outlook邮件、海外社交媒体、电话等互动数据，构建“行为+交易”双维度视图</td><td>对接HubSpot营销/服务工具，兼容Slack、Zoom等第三方，实现跨平台数据汇聚</td><td>自动追踪客户互动（邮件打开、网页访问）、线索评分优化质量</td><td>自动化任务分配、角色级权限控制、客户分段管理</td></tr><tr><td>金蝶云·星辰</td><td>结合金蝶ERP实现“客户信息+财务数据”联动，构建业财一体化视图</td><td>整合Excel、线下记录等分散数据，对接微信/企业微信，实现统一管理</td><td>第三方潜客数据批量导入、智能分配，业财数据自动校验</td><td>业财联动权限（如服务工单关联财务凭证）、岗位级数据可见性控制</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>国内企业适配性</strong>：超兔的“工商信息自动补全”“手机号关联微信/支付宝”，金蝶的“业财数据联动”更贴合国内企业需求（如中小制造企业需要工商信息验证客户资质）；</li><li><strong>全球化协同</strong>：Salesforce的Data Cloud（激活多部门实时数据）、HubSpot的“海外渠道整合”（Gmail/LinkedIn/FB）适合跨区域或海外业务企业；</li><li><strong>线索质量优化</strong>：探迹的“1亿+知识图谱+成单反馈”能有效提升线索意向率（某制造企业应用后月度新客开发量提升200%）。</li></ul><h2>二、销售管理：从“流程驱动”到“AI驱动”，实现全链路转化效率提升</h2><p>销售管理是CRM的“核心战场”，其能力直接决定了线索到订单的转化效率。本部分从<strong>跟单模型适配性、AI辅助能力、流程自动化、绩效跟踪</strong>四个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440053" alt="" title="" loading="lazy"/></p><table><thead><tr><th>品牌</th><th>跟单模型核心能力</th><th>AI辅助功能</th><th>流程自动化能力</th><th>绩效跟踪与预测</th></tr></thead><tbody><tr><td>超兔一体云</td><td>覆盖小单快单（三一客：三定+关键节点）、商机跟单、多方项目（多业务主体）三大模型</td><td>自然语言AI生成工作流，动态进度追踪（红绿灯标识目标跟进健康度）</td><td>工作流引擎支持“数据动作触发”（如客户信息更新自动同步销售任务）</td><td>目标分解至部门/个人/环节（应收款、目标客户），实时展示完成率与异常预警</td></tr><tr><td>Salesforce</td><td>销售云全流程（线索→商机→订单），机会按可衡量指标划分阶段（如“需求确认”“报价提交”）</td><td>Einstein GPT生成销售话术、建议“下一步最佳行动”，预测销售趋势</td><td>自动化线索跟踪、任务分配（如高优先级线索自动分配给Top Sales）</td><td>销售绩效仪表盘（展示当前业绩、预测未来潜力），Zia AI识别业绩波动关键因素</td></tr><tr><td>探迹EC</td><td>全流程协同（线索分配→跟进→资金→汇报），低代码平台支持积木式流程配置（适配多行业）</td><td>AI销售Agent自动化筛选/触达客户，解放人工繁琐工作</td><td>低代码流程配置（如财税行业的“发票审核→合同签订”流程）</td><td>实时数据简报、业绩排行榜，全周期闭环分析（线索→触达→CRM）降低30%获客成本</td></tr><tr><td>Zoho</td><td>线索→商机→报价全流程，销售漏斗跟踪（展示各阶段转化率）</td><td>Zia AI自动发送跟进邮件、安排客户拜访提醒，预测销售异常</td><td>自动化任务分配（如客户三天未回复自动提醒跟进），标准化销售流程配置</td><td>销售绩效管理报表（了解团队业绩达成率），Zia AI预测未来销售潜力</td></tr><tr><td>HubSpot</td><td>可视化销售管道（拖放式界面），线索评分系统（优先推荐高转化潜力客户）</td><td>AI助手提供智能跟进建议，预测客户流失风险</td><td>自动化销售跟进（如邮件模板追踪、任务提醒），自定义销售流程</td><td>实时可视化仪表盘（销售趋势、客户行为），AI预测营销活动ROI</td></tr><tr><td>金蝶云·星辰</td><td>覆盖巡店访销（实地收集市场信息）、移动车销（随时随地开单）、在线开单（减少人工错误）</td><td>智能预警待办任务（如合同到期提醒），路线规划优化线下拜访效率</td><td>从线索→报价→订单→收款全流程跟踪，合同关联审批流程</td><td>多维度统计（业务员/客户/路线），生成可视化报表优化销售策略</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>小单快单场景</strong>：超兔的“三一客”模型是国内中小微企业（如快消、零售）的“神器”，通过“三定（定性、定级、定量）结合销售经验快速分类客户，有侧重的跟单”，可有效压缩跟单周期；</li><li><strong>AI深度赋能</strong>：Salesforce的Einstein GPT（生成话术+建议行动）、探迹的AI销售Agent（自动触达）能显著降低销售的“重复性劳动”；</li><li><strong>场景化适配</strong>：金蝶的“巡店访销/移动车销”适合零售/消费品企业（如饮料厂商需要线下业务员实时开单）；</li><li><strong>流程灵活性</strong>：探迹的“低代码积木式配置”能快速适配财税、物流等行业的个性化流程（如某物流企业通过低代码搭建了“客户对账→运费结算”流程）。</li></ul><h2>三、市场营销自动化：从“盲目投放”到“精准触达”，提升获客ROI</h2><p>市场营销自动化是CRM的“获客引擎”，其核心是将“流量”转化为“线索”，再转化为“订单”。本部分从<strong>多渠道获客、线索优化、自动化营销</strong>三个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440054" alt="" title="" loading="lazy"/></p><table><thead><tr><th>品牌</th><th>多渠道获客能力</th><th>线索优化能力</th><th>自动化营销能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>覆盖百度、抖音、官网、微信、地推、工商搜客等10+渠道，支持线索一键处理（加客户/待办/转订单）</td><td>线索手机号/IP归属地识别，成本均摊至获客线索/签约转化率，评估营销效果</td><td>工作流触发自动触达（邮件、短信），支持话术武器云/文件武器云（销售快速取用物料）</td></tr><tr><td>Salesforce</td><td>营销云跨渠道互动（邮件、社交媒体、广告、LinkedIn），客户旅程可视化设计</td><td>数据云激活沉睡数据，LinkedIn数据增强线索质量，线索评分系统优化优先级</td><td>自动化营销活动（如生日祝福邮件自动发送），客户旅程设计（从“关注”到“购买”的全流程）</td></tr><tr><td>探迹EC</td><td>集成呼叫中心、AI智能外呼、短信/邮件、展会、招投标、地图拓客等场景</td><td>1亿+知识图谱+成单反馈优化线索模型，线索意向率提升3.5倍</td><td>AI销售Agent自动化触达，行业垂直工具包（制造/跨境电商定制化营销）</td></tr><tr><td>Zoho</td><td>支持邮件/短信/社交媒体/广告/活动管理，自动化市场营销平台</td><td>线索捕获后自动分配，Zia AI辅助线索质量评估</td><td>针对性自动化营销（如向“浏览过产品页”的客户发送优惠邮件）</td></tr><tr><td>HubSpot</td><td>集成邮件、社交媒体、广告、SEO工具，支持内容营销（AI写作/SEO优化）</td><td>线索评分系统（根据行为/属性打分），自动追踪客户互动（邮件打开/网页访问）</td><td>自动化工作流（如“下载白皮书→发送跟进邮件→分配销售”），营销活动ROI分析</td></tr><tr><td>金蝶云·星辰</td><td>营销活动模板、客户分群（地域/行为）、精准推送（短信/邮件）</td><td>第三方潜客数据批量导入，智能分配给业务员，业财数据联动校验线索真实性</td><td>营销活动效果分析（如某活动的获客成本/转化率），辅助科学决策</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>国内获客场景</strong>：超兔的“工商搜客”“微信/抖音渠道整合”更贴合国内企业（如中小B2B企业通过工商信息挖掘潜在客户）；</li><li><strong>海外营销</strong>：HubSpot的“SEO工具+LinkedIn/FB整合”、Salesforce的“营销云跨渠道”适合做海外业务的企业（如跨境电商需要通过FB/Instagram获客）；</li><li><strong>线索转化效率</strong>：探迹的“AI外呼+知识图谱”能快速筛选高意向客户（某制造企业应用后线索意向率提升3.5倍）；</li><li><strong>内容营销</strong>：HubSpot的“AI写作+SEO优化”适合依赖内容获客的企业（如 SaaS 公司通过博客吸引线索）。</li></ul><h2>四、客户服务与支持：从“被动响应”到“主动留存”，构建长期客户关系</h2><p>客户服务是CRM的“留存纽带”，其能力决定了客户的复购率与忠诚度。本部分从<strong>服务协同能力、复购挖掘、工单管理</strong>三个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440055" alt="" title="" loading="lazy"/></p><table><thead><tr><th>品牌</th><th>服务协同核心能力</th><th>复购挖掘与留存</th><th>工单管理能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>客服总控台集中管理，RFM分析分块老客户（精准回访），维修/外勤工单（来店/上门）</td><td>RFM分析识别高价值客户，流失风险预警（如3个月未复购自动提醒回访）</td><td>工单派发→执行→反馈全流程跟踪，支持“供应商直发”等特殊场景</td></tr><tr><td>Salesforce</td><td>服务云整合多渠道（电话/邮件/社交媒体/聊天），智能分配工单，知识库支持</td><td>360°视图支撑个性化服务（如客户偏好自动同步服务人员），预测客户需求</td><td>工单分级处理（高优先级工单优先分配），SLA遵守（如2小时内响应投诉）</td></tr><tr><td>探迹EC</td><td>客情信息填写（拜访打卡），软硬件一体化（手机终端延伸服务），与头部硬件厂商协同</td><td>客户反馈分析（生成改进方案），长期价值挖掘（如老客户转介绍奖励）</td><td>售后工单管理（跟踪服务进度），客户满意度调查</td></tr><tr><td>Zoho</td><td>工单管理+知识库+客户门户，Zoho Learn组合（课件分发/在线测验/满意度调查）</td><td>客户行为分析（如“多次浏览某产品”自动推送优惠），预测客户流失风险</td><td>工单自动化分配（如技术问题分配给IT团队），知识库自助服务（降低人工压力）</td></tr><tr><td>HubSpot</td><td>多渠道服务请求整合（电话/聊天/社交媒体），实时聊天+聊天机器人</td><td>AI预测客户流失风险，个性化服务（如根据历史互动推送专属优惠）</td><td>工单系统自动化（如投诉自动生成工单），服务台仪表盘（展示服务效率）</td></tr><tr><td>金蝶云·星辰</td><td>工单分级处理，服务进度跟踪，对接金蝶财务（服务费用自动生成凭证）</td><td>客户价值分析（识别高价值客户），库存预警（与进销存联动，避免缺货流失）</td><td>工单关联财务（如服务费用自动结算），满意度调查（改进服务质量）</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>国内服务场景</strong>：超兔的“维修/外勤工单”（来店/上门）、金蝶的“服务费用联动财务”更贴合国内企业（如家电制造企业需要上门维修工单管理）；</li><li><strong>个性化服务</strong>：Salesforce的“360°视图+预测需求”、HubSpot的“AI预测流失”能提升客户忠诚度（如某零售企业通过Salesforce预测客户需求，提前推送优惠券，复购率提升15%）；</li><li><strong>知识付费场景</strong>：Zoho的“Zoho Learn组合”（课件/测验/满意度）适合中小知识付费团队（如在线教育机构需要分发课件并收集学员反馈）。</li></ul><h2>五、数据分析与报表：从“数据统计”到“决策支撑”，实现数据驱动增长</h2><p>数据分析是CRM的“大脑”，其能力决定了企业能否从数据中提取有效洞察。本部分从<strong>分析深度、报表定制、预测能力</strong>三个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440056" alt="" title="" loading="lazy"/></p><table><thead><tr><th>品牌</th><th>分析深度与维度</th><th>报表定制能力</th><th>预测与预警能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>支持同比环比、多表聚合、关联表复合查询、单日KPI等多引擎分析</td><td>自定义数字卡片/图表卡片（如销售漏斗图、业绩排行榜）</td><td>动态进度追踪（红绿灯标识异常），流失风险预警（如客户3个月未复购）</td></tr><tr><td>Salesforce</td><td>BI数据分析（销售/营销/服务多维度），Zia AI挖掘历史数据与客户行为模式</td><td>自定义报表与仪表盘（展示销售趋势、客户行为），支持数据导出</td><td>Einstein GPT预测销售趋势，Zia AI识别业绩波动关键因素（如“某区域竞争对手促销导致业绩下滑”）</td></tr><tr><td>探迹EC</td><td>全周期闭环分析（线索→触达→CRM），洞察客户跟进流程与潜在客群特征</td><td>实时数据简报、业绩排行榜，支持多维度筛选（业务员/客户/渠道）</td><td>预测客户意向率（通过知识图谱+成单数据），预警低转化率环节（如“跟进周期过长”）</td></tr><tr><td>Zoho</td><td>BI数据分析（销售/客户/服务），Zia AI基于历史数据预测</td><td>自定义报表（如销售业绩表、客户满意度表），支持可视化展示</td><td>Zia AI预测销售异常（如“某业务员业绩突然下滑”），提前预警</td></tr><tr><td>HubSpot</td><td>AI驱动分析（销售趋势、客户行为、营销ROI），多维度拆解数据（如某活动的获客成本）</td><td>自定义报告生成（支持Excel/PDF导出），可视化仪表盘（实时展示核心指标）</td><td>AI预测客户流失风险、销售机会、营销活动ROI</td></tr><tr><td>金蝶云·星辰</td><td>业财联动分析（订单→财务→库存），销售报表（业绩/转化率）、客户价值分析</td><td>多维度统计报表（业务员/客户/路线），支持数据导出与可视化</td><td>库存预警（与进销存联动），服务工单异常预警（如“某工单超时未处理”）</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>业财联动分析</strong>：超兔的“多表聚合+关联查询”、金蝶的“订单→财务→库存”更贴合国内企业（如中小制造企业需要分析“某产品的销售利润=销售收入 - 成本 - 费用”，这种业财联动分析能帮助企业精准核算利润）。</li><li><strong>AI预测能力</strong>：Salesforce的Einstein GPT、HubSpot的AI驱动分析以及Zoho的Zia AI在预测销售趋势、客户流失风险等方面表现出色，为企业提前制定应对策略提供有力支持。</li><li><strong>全周期分析视角</strong>：探迹EC的全周期闭环分析能让企业深入了解客户跟进流程和潜在客群特征，有助于优化销售策略，降低获客成本。</li></ul><h2>六、移动办公与集成：打破时空限制，实现业务无缝衔接</h2><p>移动办公与集成是CRM适应现代企业办公需求的重要能力，它使企业员工能够随时随地开展业务，提升工作效率。本部分从<strong>移动应用功能、系统集成能力</strong>两个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440057" alt="" title="" loading="lazy"/></p><table><thead><tr><th>品牌</th><th>移动应用功能</th><th>系统集成能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>支持Web、App、小程序、客户端、RPA插件等多端访问，提供客户管理、目标管理、行动管理等核心功能</td><td>具备丰富的业务API和基于网页自动化的Rpa，可与用友、金蝶等ERP系统，电商平台（京东、淘宝等），国税开票机器人等对接</td></tr><tr><td>Salesforce</td><td>新Salesforce移动应用通过AI助手更快处理业务，提升效率、个性化和速度</td><td>与ERP、HR等系统深度集成，满足九级组织架构的复杂权限管理，适配全球化跨区域协同</td></tr><tr><td>探迹EC</td><td>支持手机、平板等移动设备访问，与钉钉深度融合，支持移动办公、流程审批与团队协作</td><td> </td></tr><tr><td>Zoho</td><td>提供强大移动应用，支持销售团队随时随地访问客户信息、管理销售活动</td><td>集成能力强，支持与Zoho生态系统（如Zoho Books、Zoho Desk）及第三方应用（ERP、财务软件、电商平台等）无缝协作</td></tr><tr><td>HubSpot</td><td>移动端应用支持随时随地访问客户信息、任务及销售数据，实现“移动化跟进”</td><td>与HubSpot生态（营销、服务工具）无缝衔接，同时兼容第三方工具（如Slack、Zoom、Shopify、Gmail）</td></tr><tr><td>金蝶云·星辰</td><td>移动端APP支持客户拜访签到、订单录入、审批流程（如合同付款申请），实现“移动化办公”</td><td>深度集成金蝶生态（如金蝶云·星空、财务系统），同时兼容第三方应用（微信、企业微信）</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>多端适配与功能丰富度</strong>：超兔一体云的多端覆盖和全面的移动应用功能，能满足企业不同场景下的办公需求，尤其适合外勤人员较多的企业。</li><li><strong>全球化集成与协同</strong>：Salesforce的深度系统集成能力和对复杂权限管理的支持，使其成为跨国企业和大型集团的理想选择。</li><li><strong>生态融合与协作</strong>：探迹EC与钉钉的融合、金蝶云·星辰与金蝶生态及第三方应用的集成，以及Zoho和HubSpot与各自生态系统和第三方工具的协作，都为企业提供了更便捷的办公和协作体验。</li></ul><h2>七、总结与选型建议</h2><p>在数字化转型的浪潮中，CRM已成为企业实现精准获客、高效转化和长期留存的核心引擎。通过对超兔一体云、Salesforce、探迹EC、Zoho、HubSpot、金蝶云·星辰等主流CRM品牌在客户信息管理、销售管理、市场营销自动化、客户服务与支持、数据分析与报表、移动办公与集成六大核心领域的深度对比，我们可以总结出各品牌的核心优势与适配场景：</p><h3>国内企业优先考虑</h3><ul><li><strong>超兔一体云</strong>：在客户信息管理上能自动补全工商信息、关联手机号与微信/支付宝，业财联动分析和多端适配能力强，其“三一客”跟单模型适合小单快单场景，工商搜客和微信/抖音渠道整合贴合国内获客需求，维修/外勤工单管理满足国内服务场景，适合国内中小微企业，尤其是快消、零售、中小制造、工业领域等行业。</li><li><strong>金蝶云·星辰</strong>：结合金蝶ERP实现业财数据联动，具备巡店访销、移动车销等场景化功能，营销活动模板和精准推送功能实用，服务费用联动财务贴合国内服务场景，适合制造业/零售业企业，特别是需要供应链与销售全链路打通、偏好混合部署灵活性的成长型企业。</li></ul><h3>全球化业务或对AI要求高的企业</h3><ul><li><strong>Salesforce</strong>：Data Cloud激活多部门实时数据，适合跨区域或海外业务企业；Einstein GPT在销售管理和数据分析方面的强大AI能力，能显著提升销售效率和决策准确性，适合大型跨国企业和对AI技术应用有较高要求的企业。</li><li><strong>HubSpot</strong>：海外渠道整合能力强，SEO工具和AI写作支持内容营销，AI预测客户流失风险和营销活动ROI的能力出色，适合做海外业务、依赖内容获客的企业，如跨境电商、SaaS公司等。</li></ul><h3>追求自动化和流程灵活性的企业</h3><ul><li><strong>探迹EC</strong>：1亿+知识图谱和成单反馈有效提升线索意向率，AI销售Agent和低代码积木式配置能快速适配多行业个性化流程，适合需要提升线索转化效率、有个性化销售流程需求的企业，如财税、物流等行业。</li></ul><h3>功能全面且注重性价比的企业</h3><ul><li><strong>Zoho</strong>：功能全面，自动化与定制化能力突出，Zia AI在销售管理和数据分析等方面提供有力支持，适合中大型企业或有复杂流程需求的团队。</li></ul><h3>预算有限的中小企业</h3><ul><li><strong>悟空CRM</strong>：开源免费，性价比高，功能简洁，适合预算有限、需求基础的中小企业（尤其初创企业）。</li></ul><p>企业在选型时，应根据自身的行业特点、业务规模、发展战略以及实际需求，综合考虑各CRM品牌的核心优势和适配场景，做出最适合自己的选择，以充分发挥CRM系统的价值，实现企业的数字化转型和可持续发展。</p>]]></description></item><item>    <title><![CDATA[价值重构：从时间出卖者到价值创造者，凸显]]></title>    <link>https://segmentfault.com/a/1190000047440190</link>    <guid>https://segmentfault.com/a/1190000047440190</guid>    <pubDate>2025-12-01 11:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>"我每天工作10小时，周末还要加班，但感觉离财务自由越来越远。</p><p>这正是传统职场的最大陷阱：我们被训练成"时间出卖者"，而非"价值创造者"。</p><p>在旧体系中，你的价值=工时×时薪。这种线性模型注定让你陷入忙碌却无法突破的困境。</p><p>而AI时代正在重构价值评估体系：你的价值=解决问题的能力×放大系数。</p><p>关键区别在哪里？穷人的时间只卖给一个人，富人的时间通过产品化卖给成千上万人。</p><p>一个案例（青否ai员工源头v：zhibo175）</p><p>小李，24岁，国企文员，月薪8000元。每天工作8小时，处理文件、写报告、开会议。他的时间只卖给一家公司。</p><p>一年后，他学会了用AI将专业经验产品化：创建了针对国企文书写作的AI模板库，开发了标准化课程，建立了付费社群。现在，他的同一份知识，同时卖给3000+用户。</p><p>这不是特例，而是新范式的开始。</p><p>AI不是替代你的工具，而是放大你价值的杠杆。</p><p>当一个金融分析师使用AI工具，她1小时能完成过去8小时的工作，剩余7小时可以用来思考更高价值的问题，或者将专业知识产品化。</p><p>价值重构的三个层次：</p><p>效率层：用AI提升个人工作效率</p><p>产品层：将专业知识产品化，一份时间多次销售</p><p>系统层：构建AI员工体系，自动产生价值</p><p>真正的突破发生在第三层。当你不再为时间定价，而是为系统创造的价值定价时，你才真正跳出打工人的思维牢笼。</p><p>一位从程序员转型为AI创业者说："以前，我担心35岁被裁员。现在，我拥有15个AI员工，它们24小时为我创造收入。年龄不再是威胁，而是经验和洞察的积累。"</p><p>这不是鸡汤，而是正在发生的现实。国务院文件中提到的"智能体"，正是这些永不疲倦的数字员工。2027年，当70%的企业都在使用AI员工时，你希望自己是被替代的对象，还是拥有AI军团的指挥官？</p><p>当你还在计算加班费时，先行者已经在设计自己的"AI员工招聘计划"。这就是价值重构的本质：从出卖时间，到拥有资产。</p><p>青否科技聚焦于最具AI替代价值的三类岗位：（青否ai员工源头v：zhibo175）</p><p>视频运营岗位：剪辑、发布、多平台同步</p><p>客户接待岗位：微信自动回复、客户标记、标签管理</p><p>营销触达岗位：客户分类、文案生成、批量发送</p><p>这三类岗位有个共同特点：流程固定、任务清晰、可量化成果、高频重复</p><p>而这，正是AI员工最适合发挥稳定价值的场景。</p><p>青否ai超级员工能够做什么？获客+引流+销售全流程，青否AI超级员工：支持一键控制 + 岗位级替代！</p><p>1、AI获客</p><p>告别内容内耗，多平台高效运营。</p><p>sora2批量生成爆款短视频，智能匹配行业关键词，全自动发布覆盖抖音、快手、视频号、小红书。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440192" alt="" title=""/></p><p>GEO智能体优化多平台AI内容，用户提问时主动推荐企业及产品，精准曝光。</p><p>多账号一键绑定管理，数据实时监测，无需跨平台切换，省掉半个编辑团队。</p><p>解决：内容累、制作耗时长、跨平台管理乱的痛点。</p><p>2、AI引流（青否ai员工源头v：zhibo175）</p><p>全域精准引流，获客效率倍增。</p><p>按行业+用户画像全网采集高意向客户，主动私信/评论，无需人工蹲点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440193" alt="" title="" loading="lazy"/></p><p>抖音客服7*24小时在线自动回复，AI拟人聊天，引导客户留资。</p><p>解决：找客难、引流慢、精准度低的痛点。</p><p>3、AI销售（青否ai员工源头v：zhibo175）</p><p>标准化私域成交，降本又增效。</p><p>智能私域管家：自动通过好友、实时监控聊天记录、拟人化自动回复，精准预测客户行为分层。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440194" alt="" title="" loading="lazy"/></p><p>价值重构：从时间出卖者到价值创造者，凸显ai员工的重要性（青否ai员工源头v：zhibo175）！</p>]]></description></item><item>    <title><![CDATA[IT服务企业现状调研：系统集成行业转型升]]></title>    <link>https://segmentfault.com/a/1190000047439658</link>    <guid>https://segmentfault.com/a/1190000047439658</guid>    <pubDate>2025-12-01 10:11:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>最近两年，我在做ITSS课程培训时走访了不少系统集成企业。</p><p>从武汉的电力自动化到成都的政务云服务，再到深圳做安防监控的系统商，我发现几乎所有传统IT服务企业都面临同样的问题：<br/><strong>利润越来越薄，项目周期越来越短，客户需求却越来越复杂。</strong><br/> 这并不是单个公司的困境，而是整个行业的共性现象。</p><p>我还记得在某次学员研讨会上，一家做网络集成的企业负责人坦言：“现在集成项目做得越多，风险越高。硬件设备利润几乎被压到零，只能靠维保续费和小型开发项目维持。”<br/> 这句话让我印象深刻，因为十年前我在那家公司的时候，项目毛利还能达到30%。</p><p>如今，系统集成行业的商业逻辑彻底变了——客户不再为‘设备’付费，而是在为‘服务体验’买单。<br/>这正是系统集成行业的结构性转型信号。<br/> 过去的系统集成以交付为终点：项目验收完、合同结算完，关系基本就结束了。<br/> 而现在的客户更看重持续服务：系统运行是否稳定？响应是否及时？是否具备可持续的改进机制？</p><p><img width="471" height="335" referrerpolicy="no-referrer" src="/img/bVdndnV" alt="" title=""/></p><p>这意味着企业要从“项目导向”走向“服务导向”。<br/> <strong>按照ITSS标准的定义，这正是从“产品型企业”到“服务型企业”的转变。</strong><br/>很多企业在这个过程中遇到了“思维断层”。<br/> 技术团队仍习惯于一次性交付，而管理层却希望打造长期服务。</p><p><strong> 我在调研中看到的典型问题有三类：</strong></p><ol><li>服务流程不规范——没有形成标准的服务目录或SLA机制，导致交付差异大；</li><li>人员能力结构单一——重技术、轻服务意识，缺少客户协同与需求分析能力；</li><li>商业模式僵化——仍以“设备+人工”计价，无法支撑高附加值的服务定价。<br/>当这些问题叠加时，企业很容易陷入“越做越累、越赚越少”的循环。</li></ol><p>在一次企业辅导项目中，我帮一家做电力运维的公司做转型规划。<br/> 他们过去十年靠设备监控系统生存，但现在客户要求“运维外包一体化”，即希望由同一团队完成监控、巡检、应急、报告。<br/> 我们引入了 ITSS的流程管理模型，把所有工作重构为“例行操作、响应支持、优化改善、调研评估”四类服务内容。<br/> 再将其映射到具体的角色与KPI中，形成服务目录。<br/> 短短半年，他们的平均响应时长从3小时缩短到45分钟，客户满意度提升了28%。<br/> 这家企业的总经理后来对我说：“原来流程化不是约束，而是价值再造。”</p><p><strong>另一个印象深刻的案例是来自深圳的安防企业。</strong><br/> 他们的客户主要是大型园区，以前卖摄像头和布线系统。<br/> 后来引入ITSS服务成熟度评估模型后，企业发现自己处于“一级水平”——主要依靠人力经验，没有形成组织能力。<br/> 于是他们建立了基于iTop平台的工单系统，配合流程自动化和知识库管理。<br/> 三个月后，平均工单关闭率从70%提升到95%，公司也获得了更多长期合同。<br/> 这家企业负责人坦言：“我们不再卖产品，而是卖标准化服务。”</p><p>国内通过了ITSS成熟度评估的IT组织中有超过90%采用的是国际开源IT运维流程软件 iTop，艾拓先锋有幸帮到了其中的一些小伙伴。</p><p>我常常在课堂上提到这个案例，因为它说明转型的关键不在工具本身，而在管理思维的改变。<br/> 当一个企业愿意用流程、指标、评估体系来衡量服务时，它就已经跨过了“系统集成”到“IT服务”的门槛。</p><p><strong>在调研的企业样本中，有一个共同趋势非常明显：</strong><br/> 所有成功转型的企业，都在三个方面形成了系统化能力：</p><ul><li>第一，流程可复用。<br/> 他们把项目中的经验固化为标准流程，通过ITSS的“过程要求”章节完成制度化沉淀。</li><li>第二，能力可度量。<br/> 采用ITSS的“能力管理要求”，为每个岗位定义胜任力标准，并用PDCA循环做能力提升。</li><li>第三，价值可展示。<br/> 通过服务质量指标体系（GB/T 33850）量化服务成果，从而让客户看到可验证的业务改进。</li></ul><p><strong>这些企业的变化不仅仅是效率提升，更是商业模式的重构。</strong><br/> 过去他们靠卖设备赚钱，如今靠“持续服务价值”盈利；<br/> 过去他们是一次性合同关系，现在是长期运营伙伴；<br/> 过去他们依赖个人经验，如今依靠流程体系。<br/> 这正是ITSS所强调的“从能力到体系，从个体到组织”的标准化演进逻辑。</p><p>当然，转型并非一蹴而就。<br/> 在辅导过程中，我看到不少企业中层存在抗拒心理——认为标准化会降低灵活性。<br/> 但当他们亲眼看到流程带来的透明化和可控性后，这种观念逐渐转变。</p><p><strong> ITSS的核心理念其实很朴素：</strong><br/>通过统一语言、规范流程、可量化指标，让复杂的服务变得可复制、可持续。<br/>我个人认为，这种转型的本质不是“学会新标准”，而是“重建新逻辑”。</p><p>IT服务行业正在从“资源驱动”转向“价值驱动”，从“项目式经营”转向“持续服务经营”。<br/> 系统集成企业要在新周期中生存，必须重新定义自己：<br/> 你提供的不只是网络、服务器、监控，而是业务稳定运行的整体保障。</p><p>未来三到五年，这一趋势会更加明显。<br/> ITSS的推广会让越来越多企业发现：<br/>标准化不是行政约束，而是商业竞争力。<br/> 谁能先构建标准化的服务体系，谁就能在数字化转型的浪潮中获得稳定的复利。<br/> 这既是行业的方向，也是每个IT服务人的新起点。</p>]]></description></item><item>    <title><![CDATA[SSL证书的“保质期”：为什么现在只有3]]></title>    <link>https://segmentfault.com/a/1190000047439670</link>    <guid>https://segmentfault.com/a/1190000047439670</guid>    <pubDate>2025-12-01 10:11:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>你是否还记得，几年前SSL证书可以一次性购买三年甚至五年？但如今，所有公开可信的证书颁发机构（CA）签发的证书，最长有效期都已被严格限制在 <strong>398天</strong>（约13个月）。</p><p>这一变化并非偶然，而是一场由行业巨头（如Apple、Google、Mozilla）共同推动的、旨在提升全球网络安全性的主动变革。本文将为你深入解析这一政策背后的“为什么”。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdnaEc" alt="" title=""/></p><p><strong>获取SSL证书<a href="https://link.segmentfault.com/?enc=vz3Cr3EZLtScot7mRs30Fw%3D%3D.IZC4r0DCz3JrMJhM%2FVAfBmx8LpwpBJoGd0Zt1T2Szm4bCKCik2KHUcrvDaBzyzb0%2FC2fO4Ap0Ghn7bRlM%2BZenQ%3D%3D" rel="nofollow" target="_blank">申请入口</a> 注册码230976</strong></p><h3><strong>核心原因：安全、敏捷与责任</strong></h3><p>将证书有效期从数年大幅缩短至398天，主要基于以下三大核心逻辑：</p><h4><strong>1. 强化安全：缩短攻击窗口</strong></h4><p>证书的有效期，本质上是一个“攻击窗口”。如果一个证书被恶意签发或私钥不慎泄露，在它有效的整个周期内，都可能被攻击者利用。</p><ul><li><strong>过去</strong>：一张被泄露的三年期证书，可以让黑客在长达三年的时间里，伪装成合法网站进行钓鱼攻击而不被普通用户察觉。</li><li><strong>现在</strong>：将有效期缩短至398天，意味着即使证书出现问题，其造成的安全威胁最长也不会超过13个月。这<strong>极大地限制了潜在破坏的范围和时间</strong>，迫使安全问题被更快地发现和解决。</li></ul><blockquote><strong>重点</strong>：这就像给食品规定更短的保质期，以确保人们只会吃到新鲜、安全的食物。证书的“新鲜度”直接关系到连接的安全性。</blockquote><h4><strong>2. 推动自动化与最佳实践</strong></h4><p>长有效期证书容易导致一个不良习惯——  <strong>“部署即遗忘”</strong>  。管理员可能部署一张证书后，就忘了这回事，直到某天网站因证书过期而瘫痪，导致业务中断和品牌声誉受损。</p><p><strong>398天的有效期政策，是一个强有力的“推手”，它迫使企业和开发者：</strong></p><ul><li><strong>拥抱自动化管理</strong>：如此短的周期使得手动更新变得不切实际。这极大地促进了像 <strong>Let‘s Encrypt</strong> 这样的免费、自动化CA的普及，以及 <strong>ACME协议</strong> 的标准化的采用。</li><li><strong>建立健全的证书生命周期管理流程</strong>：企业必须开始使用工具来监控、部署和更新证书，从而形成一个更健康、更主动的安全运维模式。</li></ul><blockquote><strong>重点</strong>：目标不是增加麻烦，而是通过政策引导行业走向<strong>无人为干预、自动续期</strong>的最佳实践，从根本上杜绝因人为疏忽导致的服务中断。</blockquote><h4><strong>3. 加速技术迭代与合规</strong></h4><p>互联网环境和技术标准在飞速变化。一个使用五年期证书的网站，可能在第三年时还在使用已被淘汰的、不安全的加密算法。</p><p>更短的证书生命周期意味着：</p><ul><li><strong>更快的技术普及</strong>：新的、更安全的加密标准（如TLS 1.3、更强大的哈希算法）能够随着证书的快速轮换，更迅速地部署到全球服务器上。</li><li><strong>更易执行合规要求</strong>：当行业安全政策发生变化时（例如，要求淘汰某种算法），通过证书的自然更新，可以比强制召回旧证书更快、更平滑地实现全局合规。</li></ul><h3><strong>历史的车轮：从几年到398天</strong></h3><p>让我们简单回顾一下这个演变过程：</p><ul><li><strong>过去</strong>：允许签发最长 <strong>5年</strong> 的证书。</li><li><strong>2015年</strong>：苹果公司率先施压，要求将其CA安全计划中的证书有效期缩短至 <strong>2年</strong> 以内。</li><li><strong>2018年</strong>：进一步缩短至 <strong>825天</strong>（约27个月）。</li><li><strong>2020年</strong>：由Apple领衔，宣布自2020年9月1日起，所有新签发的SSL/TLS证书<strong>最长有效期不得超过398天</strong>。这一政策已成为所有浏览器和根证书项目的强制标准。</li></ul><h3><strong>这对你意味着什么？行动指南</strong></h3><p>证书有效期的缩短是不可逆转的趋势。作为网站所有者或运维人员，你必须适应这一变化。</p><ol><li><p><strong>立即检查你的证书</strong>：</p><ul><li>使用在线工具（如 SSL Labs SSL Test）或命令行，查看你网站证书的准确过期时间。</li></ul></li><li><p><strong>拥抱自动化（唯一的长久之计）</strong> ：</p><ul><li><strong>推荐工具</strong>：使用 <strong>Certbot</strong>、<strong>acme.sh</strong> 等客户端工具，它们可以与 Let’s Encrypt 等CA配合，实现证书的<strong>自动申请、部署和续期</strong>。</li><li><strong>利用托管服务</strong>：许多现代云平台和CDN服务（如 Cloudflare, AWS Certificate Manager, Azure App Service）已提供<strong>完全免费的、自动管理的证书</strong>，让你几乎感知不到证书更新的存在。</li></ul></li><li><p><strong>建立监控预警</strong>：</p><ul><li>即使实现了自动化，也必须建立独立的监控预警机制（通过监控平台、脚本或订阅服务），在证书异常或自动续期失败时能第一时间收到告警。</li></ul></li></ol><h3><strong>总结：拥抱“短保质期”的新时代</strong></h3><p>SSL证书有效期缩短至398天，并非为了增加你的工作量或让CA卖出更多证书。其核心驱动力是  <strong>“安全第一”</strong>  的原则。</p><p>它通过创造一个更短的攻击窗口、强制推行自动化管理、以及加速安全技术普及，从整体上构建了一个<strong>更健壮、更灵活的互联网安全生态</strong>。</p><p>对于终端用户而言，这意味着每一次HTTPS连接都更加可信。对于运维者而言，这意味着我们必须告别旧的手工模式，走向更现代化、更自动化的运维体系。这，是网络安全进步的必然代价，也是它带来的宝贵礼物。</p>]]></description></item><item>    <title><![CDATA[SSL证书的作用，SSL证书多久换一次？]]></title>    <link>https://segmentfault.com/a/1190000047439672</link>    <guid>https://segmentfault.com/a/1190000047439672</guid>    <pubDate>2025-12-01 10:10:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着网络发展，网站业务越来越多，SSL证书作为保障网站数据传输安全的重要手段，其重要性不言而喻。SSL证书的有效期通常为一年，并且需要定期更换。那么为什么SSL证书要一年换一次呢?如果证书过期且未续费，网站还能否正常访问呢? 今天我们就来了解下SSL证书的使用问题。</p><h2>一、SSL证书的定义</h2><p>SSL证书，全称安全套接层证书（Secure Sockets Layer Certificate），是一种由数字证书颁发机构（CA）签发的文件，旨在验证服务器或网站的身份，确保通信安全性与数据完整性。它通过遵循SSL/TLS（安全套接层/传输层安全性）协议，在客户端和服务器之间建立加密连接，实现数据的安全传输。</p><h2>二、SSL证书的重要性</h2><p>1、保护用户隐私</p><p>当您访问一个拥有有效SSL证书的网站时，您的数据将被加密，这意味着任何恶意的第三方都无法轻易窃取或窥视您的个人信息。这为用户提供了信心，使他们能够自由地在网上进行交易和共享敏感信息。</p><p>2、增强网站信誉度</p><p>拥有SSL证书的网站可以通过显示安全锁和HTTPS前缀来向访问者展示它已经采取了适当的安全措施。这不仅为用户提供了安全感，还有助于建立网站的信任度和可靠性，从而增加用户留存和转化率。</p><p>3、防止恶意活动</p><p>SSL证书可以检测和阻止钓鱼网站、恶意软件和网络攻击，确保用户不会成为网络犯罪的受害者。这对于保护个人用户和企业的财务和声誉至关重要。</p><p>4、搜索引擎优化（SEO）</p><p>大多数搜索引擎都优先显示拥有SSL证书的网站，这意味着使用SSL证书可以提高您的网站在搜索结果中的排名。这对于增加网站流量、吸引更多的访问者和潜在客户至关重要。<br/><img width="390" height="260" referrerpolicy="no-referrer" src="/img/bVddeYp" alt="" title=""/></p><h2>三、为什么需要定期更换SSL证书</h2><p>SSL证书一年换一次的原因主要可以归纳为以下几点：</p><p>保护网站信息安全：</p><ul><li>SSL证书的有效期越长，理论上被破解的可能性就越大。周期过长会给不法分子提供更多的破解时间和机会。因此，每年更新SSL证书可以减少证书被破解的风险，确保网站信息传输的安全性。</li><li>每年更新SSL证书会颁发新的密钥，这增加了黑客攻击的成本和难度，进一步提高了网站的安全性。</li></ul><p>增强可靠性：</p><ul><li>每年重新签发SSL证书意味着会对申请者身份进行重新审核。DV SSL证书会验证域名管理权限，而OV及EV SSL证书还会审核企业的真实身份。这可以确保SSL证书使用者的相关信息是最新的，从而增强证书的可靠性。</li></ul><p>应对网络风险：</p><ul><li>网络安全威胁不断演变，攻击者的技术也在不断发展。更新SSL证书可以确保网站使用最新的加密算法和安全协议来抵御新兴的安全威胁。</li><li>密钥可能会泄露，如果密钥泄露，就需要重新生成密钥并更新SSL证书。此外，网站的信息也可能发生变化（如域名、IP地址等），需要及时更新SSL证书以保证连接的安全性。一年一签发的频率可以及时应对这些风险。</li></ul><p>降低成本：</p><ul><li>虽然每年更换SSL证书需要一定的成本投入，但相对于长期依赖过期证书可能带来的安全风险和经济损失而言，这些成本是微不足道的。</li></ul><h2>四、SSL证书不续费的影响</h2><p>如果SSL证书过期且未续费，网站将失去其加密连接和安全保障，从而面临一系列风险：</p><p>数据泄露：SSL证书过期导致的加密功能失效，由于失去了加密保护，用户的敏感信息（如姓名、地址、信用卡号等）在传输过程中可能会被恶意第三方截获和窃取。</p><p>信任度下降：当SSL证书过期且未续费时，网站将无法正常提供HTTPS服务，虽然用户仍然可以通过HTTP协议访问网站，但是浏览器将显示安全警告，提示用户该网站存在安全风险。这将降低用户对网站的信任度，导致用户流失和转化率下降。</p><p>SEO排名下降：搜索引擎可能会降低过期SSL证书网站的排名，进一步影响网站的流量和曝光度。<br/><a href="https://link.segmentfault.com/?enc=yhx%2BMKMtQ%2F7x0bJmMryW0Q%3D%3D.pumEstT7CQEUpE66g8yB1VRWdOOQknRM85OLl3RbkuaRT2XdtxHqkJeKy1AugclUpctU6FUbLy2tI7xUIl4p4%2BdXfCrH5oPQSoDbdwbNHTE%3D" rel="nofollow" target="_blank">SSL</a></p><h2>五、如何选择合适的SSL证书使用</h2><p>选择合适的SSL证书非常重要，推荐使用安全SSL证书。具有 以下特点优势：</p><p>1、顶级CA机构</p><p>SSL 证书由国际顶级CA机构授权颁发，安全有保障 数字证书授权机构（CA，CertificateAuthority）是管理和签发安全凭证和加密信息安全密钥的网络机构，承担公钥体系中公钥的合法性检验的责任，需要对用户、企业的身份真实性进行验证，其权威性、公正性十分重要，只选择和顶级权威的CA机构合作，提供安全有保障的 SSL证书。</p><p>2、数据加密传输</p><p>加密保护浏览器/APP与服务器之间的数据传输安全 采用HTTPS加密APP及网页通讯，防止数据在传送过程中被窃取、篡改，确保数据的完整性；防止运营商的流量劫持、网页植入广告现象；同时有效抵挡中间人的攻击，大大提升安全性。</p><p>3、高兼容性</p><p>Sectigo根证书签发，支持所有主流浏览器和移动设备 兼容性关系到用户访问时浏览器是否会正确给予网页安全的提示，Sectigo根证书的浏览器兼容性，支持目前所有主流的浏览器和移动设备。</p><p>4、提升搜索排名</p><p>采用HTTPS有利于提升网站的搜索排名及站点可信度 2014年Google调整了搜索引擎算法，比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高，同时国内的搜索引擎厂商也在加强对HTTPS的重视，采用HTTPS可以辅助站点的SEO优化。</p><h2>六、总结</h2><p>综上所述，为了确保网站的安全性和可信度，建议网站所有者定期检查和更新其SSL证书。同时，选择可信赖的数字证书颁发机构（CA）和合适的SSL证书类型也是非常重要的，可以保障网站始终处于安全状态。</p>]]></description></item><item>    <title><![CDATA[架构火花｜35岁程序员该做些什么：留在国]]></title>    <link>https://segmentfault.com/a/1190000047439676</link>    <guid>https://segmentfault.com/a/1190000047439676</guid>    <pubDate>2025-12-01 10:09:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>引言</h2><p><strong>“35岁程序员的路，到底该怎么走？”</strong>  </p><p>留在熟悉的领域，意味着稳定与可预见的轨迹，但内心总有不甘；切换赛道，拥抱变化，又难免担忧机会成本与潜在风险。35岁，对许多程序员而言，仿佛一道无形的分水岭。一边是日渐娴熟的技术与宝贵的经验，另一边则是对未来不确定性的深深焦虑，总想试图更进一步却又害怕失去已经拥有的一切。这道人生选择题，该如何作答？  </p><p>9 月 25 日下午，一条来自同盟成员的职业道路求助信息发布在腾讯云上海架构师同盟的社群，瞬间激起了广泛的讨论与思考。 本期内容节选自上海同盟社群讨论。</p><h2><strong>求助问题</strong></h2><p>求助者：“我在目前当前公司当前事业部当前岗位已经待了近10年，感觉最近两三年职业发展遇到了瓶颈，虽然因为我主动要求，职位去年从 DBA 调整成了运维架构师，但是在领导和同事的概念里我还是 DBA，也基本上只分配给我 DBA 相关的工作。我们事业部的业务模式从我 15 年入职至今，基本上没有太大的变化，整体的技术架构从 18-19 年整体容器化转型之来也没有太大的变化。而且我们公司本身对人才的能力培养和岗位晋升方面基本没有，同一个岗位职责干了 10 多年的同事也不少，不管是大领导还是技术部领导基本上也都没有技术背景，感觉在现有的岗位上难以获得更高的技术成长。</p><p>我从入行以来干的活一直都比较杂。第一份工作是政府项目的现场实施工程师，基本上开发、数据库、运维都是自己搞，干了近5年以后因为想专数据库技术，但是公司对我的规划是数据处理岗位，因此选择跳槽。第二份工作就是现在的岗位，虽然入职的职位是 DBA，但是由于个人的兴趣和公司人才的缺乏，也在研究和负责运维相关的工作。尤其是在18年由于公司高层变动，决定从.Net+IIS 转向 Java+ 微服务+容器化的技术栈。在此期间我负责了整体的基础设施搭建，学习了 DevOps 和云原生相关的技术，发现自己对相关的技术非常感兴趣，而且自己也很擅长，从此将自己的职业发展重心开始往SRE、云原生、基础平台架构、DevOps、软件工程、研发效能等方向前进。</p><p>目前如果换岗位，自己主要是考虑两个方向：一是云原生方向的 SRE/DevOps 专家，负责建设公司的基础平台整体架构和运维开发体系；二是公有云服务商的解决方案架构师，帮助客户设计云上架构，为客户创造价值。</p><p>但是本人现年 35，大专文凭，在职场上并没有什么竞争力，基本连面试机会都很难拿到。而且现在所在公司是国企旗下子公司，属于国企正式员工，工资尚可，且由于我目前对公司的重要性应该也不太可能会被裁，所以也有一些身边的朋友劝我老老实实待到退休。现在是否是合适的寻找新职业机会的时机？而且自己目前并没有解决方案的实际项目经验，虽然有在干运维架构方面的工作，但是简历上大部分时间的职位也只是DBA，可能一眼就被刷了，要找到心仪的岗位也比较困难。</p><p>希望各位老师能够帮助我答疑解惑一下我目前的困境，谢谢各位。”</p><h2><strong>同盟成员的建议</strong></h2><p>上海同盟成员A：感觉你和我的经历差不多。我先说一下我自己的情况：</p><p>88 年，大专，学的日语专业，来当前公司工作 10 年多，没换过部门（短期支援除外）。</p><p>我做开始做的是事务性工作，自学的编写，别的没学会，学会了程序员的“偷懒”。在实际业务中发现大量重复性的工作，于是开始搞了自动化，然后随着 AI 的发展，慢慢学了 AI 相关的技术。直到现在，在部门搞 LLM 的落地可行性验证。</p><p>所以“在现有的岗位上难以获得更高的技术成长”这个是不存在的，不要被当前业务限制住“自学”的动力。而且你说“属于电信正式员工，工资尚可，且由于我目前对公司的重要性应该也不太可能会被裁”。所以更可以定下心来学习感兴趣的领域，不一定非要在工作上从事这个。有余力可以考虑副业。</p><p>千万别裸辞，咱们的学历是硬伤。当前环境不太好找和当前薪资所匹配的岗位的。</p><p>上海同盟成员B：首先这里讲了从DBA到运维架构师，现如今什么都是架构师，Java架构师、PHP架构师，所以看来仅仅是名字。</p><p>那么 DBA 难道就不能架构吗？不是这样的，我就是数据架构师。这你要看你的A是什么，如果就是 Administer，那么就是运维了。 如果是 Analysis，那么就是分析师，如果是 Architect，那就是架构师。如果仅仅是从安装备份这种 Administer 做，那么也就只能从事运维。当然这里不是说运维不好。只是看公司环境。目前你公司不重视这些。不论你是 DBA 还是运维架构师。</p><p>可以打听一下天翼云的首席，就是 DBA 出身。DBA 没什么不好，但如果只做 Administer 那就会一直处于这种境界。</p><p>而你当前考虑的两个方向：一是云原生方向的 SRE/DevOps 专家，负责建设公司的基础平台整体架构和运维开发体系。（那我要问你：是否管理过开发？是否管理过业务？这才是 DBA 的本职工作和未来方向。因为我就是这样做的。所以不要觉得简历上是 DBA不好，恰恰这是好的地方。至少我个人是这样认为。只是你的领导所谓分配给你 DBA 相关工作，是 Administer 的，而你潜意识中也是这样认为的。至少在描述中没有看到你管理开发的相关介绍。所以在于你自己怎么给自己定位。因为没有管理开发，治理开发的经验，那么怎么做 DevOps？）你提到了运维开发体系，但是其实只做过运维，没有做过开发体系。 有没有指导过开发如何写 SQL，如何设计数据库，如何分析需求，如何管理需求。如果没有这些，这 SRE/DevOps 和运维开发体系 基本做不下去。</p><p>另外一个方向：公有云服务商的解决方案架构师，帮助客户设计云上架构，为客户创造价值。（那么就是离开你现在的公司。因为只有阿里、腾讯和华为是公有云。）那么这里又是一个问题，解决方案就是要去直接管理客户。如果没有管理过开发，那么直接管理用户是很困难的。</p><p>其实DBA是你实现以上方向中必须经过的一个环节。</p><p>眼下是不是一个去寻找工作的机会？几乎不是。因为就业市场就很差，这是实际情况。你可以多收集这些信息看看是不是？</p><p>上海同盟成员C：关于你考虑的两个方向:</p><p>云原生 SRE/DevOps 专家:这与你目前的兴趣和经验高度匹配，而且你已经在这方面有实际项目经验。</p><p>解决方案架构师:虽然缺乏直接经验，但你的技术广度和对业务的理解是很好的，35岁和学历确实会带来一些挑战，但并非不可逾越。你可以考虑:</p><p>1.先在现有公司争取更多云原生相关项目，积累可展示的成果</p><p>2.考虑考取一些云厂商的认证(如AWS/Azure/阿里云的架构师认证)</p><p>3.在技术社区或公众号分享你的经验，建立个人品牌</p><ol start="4"><li>利用业余时间参与一些开源项目或接一些小项目，弥补解决方案经验的不足关于时机，我认为可以采取"骑驴找马"的策略:不急于立即离职，但开始有计划地准备和寻找机会。国企的稳定性确实是个优势，但长期来看，技术停滞的风险更大。</li></ol><p>上海同盟成员D：有一句话，也是我现在的状态，送给这个投稿人：把工作当副业去干。做自己感兴趣的事情，工作和兴趣两不误，但是要在处理好工作的前提下去做自己的兴趣。</p><p>上海同盟成员E：现在就业市场惨淡，有一份稳定的工作更重要。工作是主业，稳定的经济来源，轻车熟路的交付好工作后（当然也可以持续提高自我要求），发展副业，分散注意力到感兴趣的领域，或专业精深或持续成长或财源广进。</p><p>上海同盟成员F：个人观点，感觉未来两年内，不管什么类型程序员都会把90%的代码编写工作交给AI写，先提前来适应和调整能力去适配AI主编码的模式，基于自己主技术栈，去看AI能完成很好的，就没必要去提升了，没有完成好的比较有价值，去分析为啥没完成好，是模型能力不行，还是当前业务场景不适配，针对性的再去调整和适配技术提升路线。</p><p>上海同盟成员G：我说一个我觉得最实际的点就是，呆了这么久，当前有没有最直接的经济压力，如果工作安排这些并不会直接影响收入的话，我觉得大可不必在这内耗，生活是大于工作的。</p><p>上海同盟成员H：发表一点点浅见。</p><ol><li>新的职业机会慎选。</li><li>建议在自己擅长的 SRE/DevOps 等方面持续加深，在同盟社区发表文章，增加知名度，再看机会。</li></ol>]]></description></item><item>    <title><![CDATA[过等保到底该用什么SSL证书？如何避免扣]]></title>    <link>https://segmentfault.com/a/1190000047439679</link>    <guid>https://segmentfault.com/a/1190000047439679</guid>    <pubDate>2025-12-01 10:08:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>过等保需选用符合国家标准的SSL证书，并注意证书类型、加密算法、颁发机构、有效期及吊销机制等关键点，同时做好证书配置与兼容性测试，以避免扣分。以下是具体建议：</p><p><strong>一、选择合适的SSL证书</strong></p><p><strong>证书类型</strong></p><p>二级等保及以上：建议采用OV（组织验证）或EV（扩展验证）SSL证书，以验证域名所有权及企业真实身份，避免使用仅验证域名的DV证书。</p><p>关键业务系统：优先选择EV证书，浏览器地址栏会显示绿色企业名称，增强用户信任。</p><p><strong>加密算法</strong></p><p><strong>国际算法：</strong> 需支持RSA（≥2048位）或ECC（≥256位）算法，禁用已淘汰的1024位RSA或MD5签名。</p><p><strong>国密算法：</strong> 优先使用SM2/SM3/SM4国密算法，选择支持国密双证书（SM2+RSA）的SSL证书，以满足“自主可控”要求。</p><p><strong>证书颁发机构（CA）</strong></p><p>选择由国内自主的、可信赖的第三方证书颁发机构颁发的证书，确保证书的权威性和可信度。例如，CFCA、JoySSL等机构签发的证书。</p><p><strong>等保专用SSL证书访问入口</strong></p><p>访问JoySSL官网,注册一个证书账号，填写注册码230968，获取技术支持</p><p><strong>证书有效期</strong></p><p>证书有效期需符合《密码法》要求，通常不超过1年，避免长期证书带来的安全风险。</p><p>证书吊销机制</p><p>必须支持OCSP或CRL在线吊销查询，确保证书吊销状态可实时验证。</p><p><img width="723" height="420" referrerpolicy="no-referrer" src="/img/bVdjRsC" alt="" title=""/></p><p><strong>二、避免扣分的注意事项</strong></p><p><strong>证书链完整性</strong></p><p>确保证书包含完整的信任链（根证书+中间证书+终端实体证书），避免因证书链断裂导致浏览器警告或评估扣分。</p><p><strong>签名算法</strong></p><p>使用SHA-256及以上安全哈希算法，禁用SHA-1等弱签名算法。</p><p><strong>证书配置</strong></p><p>正确配置证书，确保服务器支持TLS 1.2及以上版本，禁用SSLv2、SSLv3等不安全协议。</p><p><strong>兼容性测试</strong></p><p>部署前在主流浏览器（Chrome、Firefox、360安全浏览器等）测试证书兼容性，尤其是国密证书需确保客户端支持。</p><p><strong>日志审计</strong></p><p>启用SSL/TLS握手日志，监控证书使用情况，及时发现并处理异常。</p><p>定期轮换私钥</p><p>每年更换证书时同步更新私钥，降低密钥泄露风险。</p>]]></description></item><item>    <title><![CDATA[女朋友换头像比翻书快？我3天肝出一个去水]]></title>    <link>https://segmentfault.com/a/1190000047439685</link>    <guid>https://segmentfault.com/a/1190000047439685</guid>    <pubDate>2025-12-01 10:07:53</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>我女朋友天天泡小红书，看到好看的图就想当头像。可小红书的图都带水印，她嫌截图裁剪太麻烦。有一天直接甩给我一句：“你是程序员，给我想个办法把水印弄掉！”<br/>得，女朋友发话，那就干呗。花三天时间，整了个去水印的小工具，挺好用。下面就是我怎么一步步搞出来的，有兴趣的可以看看。</p><h3>先看效果</h3><p>先给大佬们体验体验&gt;&gt;&gt; <a href="https://link.segmentfault.com/?enc=TPrxdhy2cKlk3ogNRQoESw%3D%3D.zUwjUGyIVE1%2BkiVvYEfyhipFdtrV3BB6x8miXDB2jIU%3D" rel="nofollow" target="_blank">https://nologo.code24.top/</a> ，移动端访问需要扫码跳转小程序。<br/>电脑端是这样的：</p><p><img width="723" height="422" referrerpolicy="no-referrer" src="/img/bVdndol" alt="image.png" title="image.png"/></p><h3>功能亮点</h3><p>小某书、某音、某手……主流平台的图片、视频都能扒<br/>完全免费，不用登录，打开就用，零广告<br/>复制分享链接→粘贴→秒出无水印素材，一步到位</p><h3>后端怎么做到的</h3><p>前端只是壳，真正干活的是后端：拿到分享链接后，靠爬虫把平台返回的数据里“无水印原始地址”抠出来，再回传给你。<br/>我是前端，最顺手的组合是 Node.js + Vue3，既然后端也要有人顶，干脆一把梭：Node 写接口，语法熟、模块多，撸起来嘎嘎快。<br/>举个例子：拿【某信公众号】来练手，它最简单了。<br/>首先想薅无水印的资源，得先摸透平台套路。公众号最“耿直”，它直接把无水印原图塞在 HTML 里。打开文章源码，一眼就能看到 window.picture_page_info_list 这个大对象，无水印原图地址全躺在里面。</p><p><img width="723" height="402" referrerpolicy="no-referrer" src="/img/bVdndom" alt="image.png" title="image.png" loading="lazy"/></p><p>之前写过一篇文章 Node.js操作Dom ，轻松hold住简单爬虫 文章提到三方库 jsdom，它能把字符串html摸拟成Dom。<br/>复制链接发送请求获取页面 HTML 内容，再转成模拟的 Dom，这样就能使用jquery 获取元素。</p><pre><code class="js">const axios = require('axios');
const jquery = require('jquery');
const jsdom = require("jsdom");
const { JSDOM } = jsdom;

const str2Dom = (html = '') =&gt; {
    if (!html) return;
    const page = new JSDOM(html);
    const window = page.window;
    return window;
}

const getHtml = async (url) =&gt; {
    return new Promise((resole, reject) =&gt; {
        axios.get(url, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36 Edg/140.0.0.0',
                'sec-ch-ua-platform': "macOS",
                cookie: 'rewardsn=; wxtokenkey=777'
            }
        }).then(res =&gt; {
            resole(res.data)
        }, err =&gt; {
            reject('')
        })
    })
}

const getFileUrl = async (url) =&gt; {
      const window = str2Dom(await getHtml(url));
      if (!window) return;
    let $ = jquery(window);
    //省略...
}</code></pre><p>获取所有script 标签，挨个循环用正则捕获数据。</p><pre><code class="js">  const getPicturePageInfoList = ($, reversedScrips) =&gt; {
    const START_STR = 'window.picture_page_info_list = [';
    let result = null;
    $.each(reversedScrips, function (i, script) {
        let scriptContent = $(script).text() || '';
        if (scriptContent.includes(START_STR)) {
            scriptContent = scriptContent.replace('.slice(0, 20)', '')
            // 使用正则表达式捕获方括号内的内容
            const regex = /window\\.picture_page_info_list\\s*=\\s*(\\[.*?\\])(?=\\s*;|\\s*$)/s;
            const match = scriptContent.match(regex);

            if (match &amp;&amp; match[1]) {
                try {
                    const fn = new Function(`return ${match[1]}`);
                    result = fn();
                } catch (e) {
                    console.warn('JSON解析失败，返回原始内容:', e);
                    result = match[1]; // 返回原始内容
                }
            }
            return false; // 跳出each循环
        }
    })
    return result;
}

const getFileUrl = async (url) =&gt; {
    //省略...
    let $ = jquery(window);
    const scrips = $('script');
    const reversedScrips = [...scrips].reverse();
    const weiXinData = getPicturePageInfoList($, reversedScrips);
 }</code></pre><p>这个我们就能得到某信公众号无水印的图片，某信公众号是最简单，基本没做太多防爬虫机制。<br/>其他平台较复杂点，涉及到 js 逆向，大多接口做了保密。</p><h3>最后</h3><p>本工具仅限于学习,请勿用于其他用途,否则后果自负。</p>]]></description></item><item>    <title><![CDATA[什么是国密算法IP证书？它为何如此重要？]]></title>    <link>https://segmentfault.com/a/1190000047439687</link>    <guid>https://segmentfault.com/a/1190000047439687</guid>    <pubDate>2025-12-01 10:07:15</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>国密算法IP证书，作为我国网络空间安全自主可控战略的关键基石，是一种融合了国密算法与IP地址绑定机制的创新性数字证书。它突破了传统SSL证书依赖域名的限制，直接将加密信任锚定于公网或内网IP地址，为无域名系统、工业设备及特殊行业应用提供了合规且高强度的安全解决方案。</p><p><strong>国密算法IP证书⬇️</strong></p><p><a href="https://link.segmentfault.com/?enc=f%2B1X43PQE%2Fl%2FizX2OiRIhg%3D%3D.rzFRdwWENiXhX1Sd4eHi01%2BQT9ECXNiznXyvK2iVxO0VLUCgeH6z3VEetKubdrv69WYR%2BLgaNGwRA7rFUGmKeCVfXoU7mor7XOsXZLkg9vs%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/international_algor...</a></p><p><strong>注册码230959⬆️</strong><br/><img width="606" height="346" referrerpolicy="no-referrer" src="/img/bVdisDe" alt="" title=""/></p><p><strong>一、核心定义与技术特性</strong></p><ol><li><strong>双重属性融合</strong>：该证书兼具“国密算法”与“IP证书”的双重特性。一方面，其密码体系严格遵循国家密码管理局制定的SM2/SM3/SM4等商用密码标准，实现了从底层算法到上层应用的完全自主可控；另一方面，证书主体直接绑定公网或内网IP地址，通过权威CA机构审核后签发，确保对该IP所代表服务的合法控制权。</li><li><strong>先进密码架构</strong>：采用SM2非对称加密进行身份认证和密钥交换，SM3哈希算法保障数据完整性，SM4对称加密实现高效数据传输。相较于国际通用的RSA/ECC算法，在同等安全强度下具备更高的运算效率和更短的密钥长度，有效降低了系统开销。</li><li><strong>广泛生态兼容</strong>：已深度适配国产主流浏览器（如360、奇安信、红莲花）、操作系统（DeepinOS、统信UOS、KylinOS）以及信创环境，并支持99.9%的移动设备访问，构建起覆盖软硬件全栈的国密生态链。</li></ol><p><strong>二、关键重要性体现</strong></p><ol><li><strong>国家战略合规刚需</strong>：在《密码法》《网络安全法》及等保2.0框架下，金融、政务、能源、医疗等关键行业被明确要求使用国密算法进行加密通信与身份认证。部署此类证书已成为满足“密评”（密码应用安全性评估）要求的必要条件，是企业通过合规审查的核心要素。</li><li><strong>主权安全自主可控</strong>：彻底摆脱对国外密码技术的依赖，规避潜在的后门风险和技术封锁。所有密钥生成、证书签发及验证流程均在国内闭环完成，从根本上保障了国家数据主权和供应链安全。</li><li><strong>特殊场景精准适配</strong>：完美适用于未绑定域名的内部系统、工业控制系统(ICS)、物联网(IoT)设备、API网关等直接基于IP访问的场景，弥补了传统域名证书的应用空白。同时支持动态IP管理和多IP绑定，灵活应对复杂网络拓扑需求。</li><li><strong>性能优化降本增效</strong>：SM系列算法在设计上针对国内网络环境进行了深度优化，在保持高安全性的同时显著提升加解密速度，降低服务器资源消耗。结合本土化服务优势，可提供更具性价比的选择方案。</li><li><strong>纵深防御体系强化</strong>：不仅实现传输层加密防窃听，更能通过OV级别验证展示企业组织信息，增强终端用户对IP直连服务的信任度，有效防范钓鱼攻击和流量劫持，构筑多层次安全防护屏障。</li></ol>]]></description></item><item>    <title><![CDATA[工业软件架构的新突破。开源的基于多核异构]]></title>    <link>https://segmentfault.com/a/1190000047439689</link>    <guid>https://segmentfault.com/a/1190000047439689</guid>    <pubDate>2025-12-01 10:06:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>工业控制器是现代工业控制系统的重要组成部分，它的性能和稳定性对工业控制系统起着至关重要的作用。<br/>现在市场上有一些国内外的成熟的工业控制器解决方案，它们一般都不开源，而且价格不斐，并且实时性并不优越。OpenPLC是开源的工业控制器解决方案，OpenPLC有良好的生态，但OpenPLC实时性能很差，有诸多地方需要改进。</p><p>成都实安安信科技有限公司将其所开发的业界领先的多核异构框架RTOnBoot，以及基于RTOnBoot的Ethercat主站解决方案，同OpenPLC完美融合，推出了开源的基于多核异构框架RTOnBoot和OpenPLC打造的低成本高性能linux主控加工业控制器解决方案。</p><p>多核异构框架RTOnBoot具有优异的实时性能，让OpenPLC的runtime运行在RTOnBoot所控制的实时核上，无疑会大大提升OpenPLC的runtime的运行的实时性能。同时OpenPLC的webserver，libmodbus，opendnp3和libsnap7等运行在linux上，这样既发挥了Linux在网络上的优势，又发挥了RTOnBoot的实时性能优势，优势互补，使系统整体性能达到最优，又不增加成本。</p><p>现在的版本采用RTOnBoot的多核版，让RTOnBoot控制两个实时核，一个运行Ethercat SOEM主站，另一个运行OpenPLC的runtime，Ethercat SOEM主站的同步周期可稳定达到125微秒，OpenPLC的runtime的循环周期也是125微秒，OpenPLC的runtime的延时不影响Ethercat SOEM主站。现在经测试，在RK3588上，OpenPLC的runtime的执行延时，最小执行延时4.592微秒，最大执行延时44.198微秒, 平均执行延时9.128微秒，这个执行延时是包含了等待锁的时间的，为了保证数据一致性，是加了核间锁的，可以看出实时性能优异。Ethercat SOEM主站的延时和以前一样，sleep的最大延时是11微秒，执行最大延时包括收发包是20微秒，两个最大的延时加起来只有30微秒多，距离125微秒还有90多微秒的裕量。</p><p>如果用户不需要Ethercat主站或是OpenPLC的runtime的延时不影响Ethercat主站的实时性能，也可让RTOnBoot只控制一个核，这很容易切换。</p><p>原有的OpenPLC方案是在目标机器上生成并编译出OpenPLC的runtime，直接照搬肯定不行，因为现在是交叉编译，而且runtime运行在Nuttx上。所以我们的解决方案是把生成的程序和hardware layer交叉编译成一个Nuttx的动态链接库，再把这个动态链接库和st源文件以及一些配置参数<br/>打包成一个特殊的bin文件。这个特殊的bin文件在开发环境下由一个脚本一键生成。把OpenPLC的原有的通过网页上传st源文件改为上传bin文件。OpenPLC的Hardware的原有选项中增加一个RTOnBoot选项，并且缺省即处于这种状态。在这种状态下，OpenPLC的原有的的编译流程改成了解包这个特殊bin文件的流程。其他的OpenPLC原有配置不变。当然OpenPLC的原有的代码中一些不完善的部分我们也进行了改进。</p><p>通过以上一些努力，我们就实现了一个完整且完善的低成本高性能Linux主控加工业控制器加Ethercat主站解决方案。</p><p>这个方案除了RTOnBoot框架的少量代码外，其他跟OpenPLC，PLC runtime和Ethercat主站有关的代码全部开源。RTOnBoot框架编程简单且经过了充分验证和测试。</p><p>以下是低成本高性能的Linux主控加工业控制器加Ethercat主站解决方案的演示视频</p><p><a href="https://www.bilibili.com/video/BV1nLSKB3EBH/vd_source=bd86c57a4fc0bbcd4f3e9d0999ce28e2" target="_blank">https://www.bilibili.com/video/BV1nLSKB3EBH/vd_source=bd86c57...</a></p><p>源码下载地址是：</p><p><a href="https://link.segmentfault.com/?enc=omkbuKD%2BEFcbUI1bV1XbLA%3D%3D.eyd1wLTHxehMog56JJHa0mF9CQGcTPPE5e235wFp4s%2BNo%2BWnS9EtLyk2ucSNwaUpQb%2BnKcOZlt67yXri0FLMZQ%3D%3D" rel="nofollow" target="_blank">https://gitee.com/winfred-young/RTOnBootIndustrialController</a></p><p>欢迎咨询交流。</p>]]></description></item><item>    <title><![CDATA[代码签名：构建软件信任的基石 魁梧的松鼠]]></title>    <link>https://segmentfault.com/a/1190000047439691</link>    <guid>https://segmentfault.com/a/1190000047439691</guid>    <pubDate>2025-12-01 10:05:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字世界的每一次软件下载中，都伴随着一场无声的信任考验。用户最担忧的并非文件大小或等待时间，而是那个刺眼的系统警告—— <strong>“未知发布者”</strong> 。这个提示如同一家没有招牌的店铺，瞬间浇灭用户热情，动摇他们的信心。对于软件开发者而言，消除这一警告并建立坚实的信任基石，不仅是一项技术步骤，更是具有深远意义的商业战略，而<strong>代码签名</strong>正是实现这一目标的核心工具。</p><h3><strong>一、 从“未知”到“可信”：用户体验的决胜时刻</strong></h3><p>当一个潜在用户历经搜索比较，最终点击您的软件下载链接后，却在安装时被操作系统的安全提示无情拦截，明确指出软件来源“无法验证”，并询问是否“真的要运行吗？”——<strong>此刻，大多数非技术用户会本能地感到警惕和犹豫。</strong></p><p>研究表明，<strong>超过60%的普通用户在面对此类安全警告时会选择取消安装。</strong>  这意味着，辛苦带来的流量和潜在客户，在转化临门一脚时，被一层不信任的壁垒无情阻挡。</p><p><strong>代码签名证书的作用，就是彻底拆除这堵墙。</strong>  它通过权威的第三方证书颁发机构（CA）验证您的身份，并为代码打上无法伪造的“数字印章”。用户下载时，系统将清晰显示您的公司名称，并确认“<strong>发布者已验证</strong>”，而非“未知”。这一关键转变，将用户的疑虑转化为安心，将放弃转化为继续，<strong>直接提升了软件的下载转化率和安装成功率。</strong></p><p><strong><em>申请办法：打开JoySSL证书官网，填写注册码230970获取技术支持</em></strong>  <a href="https://link.segmentfault.com/?enc=f9xFj2xkB9OU4c%2Fin12cZg%3D%3D.%2BmW%2BkB7ovBlRpvixIonSKSnj6mZNMJSGCkOIzc6vsX0osYR%2Bf3NeiV1PC3T6SqO2DpY7N21am%2FbFgbSAqSBoYmwexPhgyxZe96XMDnN3p2g%3D" rel="nofollow" target="_blank"><strong>申请入口</strong></a></p><p><img width="723" height="311" referrerpolicy="no-referrer" src="/img/bVdc9L3" alt="" title=""/></p><h3><strong>二、 安全即价值：保护品牌与用户的双重防线</strong></h3><p>在网络安全威胁日益猖獗的今天，用户对软件的恐惧不仅在于“无法运行”，更在于其“可能有害”。恶意软件与木马病毒常伪装成正常软件进行传播。</p><p><strong>代码签名不仅是对身份的声明，更是对软件完整性的庄严承诺。</strong></p><ul><li><strong>防篡改保障</strong>：它通过加密哈希算法，确保软件从签署后到用户下载前，未遭受任何形式的篡改。</li><li><strong>风险预警</strong>：无论是网络传输过程中的数据损坏，还是黑客的恶意注入，都会导致签名失效，触发系统更高级别的安全警报。</li></ul><p>这相当于为您的软件贴上了“<strong>原装正品</strong>”的防伪标签。它不仅保护最终用户免受恶意软件侵害，更守护了开发者苦心建立的<strong>品牌声誉</strong>。一次因软件被篡改而导致的安全事件，足以让一个品牌信誉扫地。因此，代码签名是以最小成本，为品牌购买的至关重要的“<strong>数字保险</strong>”。</p><h3><strong>三、 超越下载：提升企业形象与市场竞争力</strong></h3><p>对于企业级软件或商业应用，代码签名的价值更为凸显。它向客户（尤其是拥有严格IT政策的企业客户）传递了一个明确信息：<strong>我们是一家正规、专业、注重安全和信任的公司。</strong></p><p>当您的软件在客户系统中顺畅安装，且无任何令人不安的警告时，您已在无声中建立了专业、可靠的第一印象。这种信任感会延续到客户对您产品质量和公司实力的判断上。</p><p>在竞争激烈的软件市场中，当功能与价格相差无几时，这一点点的“更可信”与“更省心”，往往成为客户选择您的<strong>决定性因素</strong>。它已不再是可有可无的选项，而是参与主流市场竞争的<strong>准入门槛</strong>。</p><h3><strong>结论：投资信任，就是投资未来</strong></h3><p>总而言之，代码签名的价值远不止于解决一个技术警告。它是一项低投入、高回报的商业投资：</p><ul><li>它<strong>直接提升转化率</strong>，守护每一份来之不易的流量；</li><li>它<strong>强力保护品牌声誉</strong>，避免因安全问题带来的毁灭性打击；</li><li>它<strong>有效增强企业形象</strong>，在激烈竞争中赢得客户的天然好感。</li></ul><p>在数字商业的世界里，<strong>信任是最硬的通货。</strong>  投资代码签名，就是投资于这份宝贵的信任。请不要让一个“未知发布者”的警告，成为您商业成功之路上的绊脚石。立即行动，为您的代码签上名字，为您的商业未来签下一份坚实的信任保障。</p>]]></description></item><item>    <title><![CDATA[共谈架构师 AI 进化论，腾讯云架构师技]]></title>    <link>https://segmentfault.com/a/1190000047439738</link>    <guid>https://segmentfault.com/a/1190000047439738</guid>    <pubDate>2025-12-01 10:05:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdndo0" alt="image.png" title="image.png"/></p><p>AI 发展日新月异，正深刻改变架构师的工作方式，并带来切实的效率提升。同时，也引发了新的思考：在 AI 时代，架构师如何重塑核心竞争力？系统架构如何有效融入 AI 能力？个人与组织如何在变革中前行？</p><p>9 月 20 日，由腾讯云架构师技术同盟和腾讯云 TVP 联合主办的「架构师的 AI 进化论——从架构升级到行业应用」腾讯云架构师技术沙龙在合肥成功举办。活动汇聚多位深耕 AI 落地的一线资深架构师，聚焦真实场景、实战挑战与前瞻洞察，探讨 AI 时代架构设计的本质跃迁。会上，腾讯云架构师合肥同盟扬帆起航，为合肥地区的架构师群体搭建一个专业、开放的交流学习平台。</p><h2><strong>腾讯云架构师合肥同盟正式成立</strong></h2><p>2024 年 12 月，腾讯云发起并成立了腾讯云架构师技术同盟，这是专为架构领域专家与从业精英营造的技术社交圈。腾讯云架构师技术同盟学习交流主席 沈剑表示，今年腾讯云正式启动地区同盟的建设工作，已在北京、上海、长沙、深圳四地成立地区同盟分会，合肥是第五个地区同盟，腾讯云期待携手合肥本地架构师，共同打造活跃、先进、纯粹的技术交流平台。</p><p>在线上，腾讯云开发者社区也开设了“腾讯云架构师同盟交流圈”，不仅有海量技术文章、视频资源，还有行业专家在线答疑、架构专家空降直播间对话等丰富活动。不管架构师是追求技术精进、管理提升，还是商业拓展，同盟都提供了相应的学习内容，全方位助力架构师拓宽视野、持续成长，切实为架构师群体提供有效帮助。</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdndo1" alt="image.png" title="image.png" loading="lazy"/></p><p>腾讯云架构师技术同盟学习交流主席 沈剑</p><p>会上，腾讯云架构师合肥同盟理事会成员集体亮相。合肥同盟理事会由 11 位资深架构专家和行业技术领袖组成。现场举行了授勋仪式，沈剑与腾讯云架构师技术同盟副秘书长 李佳忆为到场的合肥同盟理事颁发聘书，以表彰他们对合肥同盟建设及本地技术生态发展的贡献与支持。</p><p><img width="723" height="409" referrerpolicy="no-referrer" src="/img/bVdndo2" alt="image.png" title="image.png" loading="lazy"/></p><p>腾讯云架构师合肥同盟理事会</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdndo4" alt="image.png" title="image.png" loading="lazy"/></p><p>授勋仪式</p><p>LUMI CTO、腾讯云架构师合肥同盟理事长 江冬勤在致辞中表示，首先，要感谢腾讯云成立合肥同盟，聚集各位专家将前沿技术和经验带到合肥，使当地开发者和企业学习和了解一线企业的技术与应用实践。其次，AI 时代为技术从业者带来巨大的挑战与机遇，但不少开发者对如何使用 AI 赋能业务发展、助力自身成长感到迷茫。本次合肥同盟的成立，正是搭建专业的交流学习平台的第一步，让合肥乃至中部地区的架构师不再单打独斗，能够共同学习、拥抱 AI，共同迎接智能时代下的技术变革。最后，他也对本次会议表示了期待，希望各位与会者在本次沙龙活动中有所收获、实现成长，并能以此次活动为起点，共同学习、探索与进步，携手将合肥同盟打造为本地架构师的技术家园。</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdndo5" alt="image.png" title="image.png" loading="lazy"/><br/>LUMI CTO、腾讯云架构师合肥同盟理事长 江冬勤</p><p>ClickPaaS CPO、腾讯云架构师技术同盟上海地区理事会理事长 马俊为合肥同盟送上寄语，他从腾讯云架构师技术同盟的初衷和价值观出发，鼓励大家将发展同盟当作一项公益事业，在知识分享的过程中找到获得感。同盟秉持“科技向善”与“长期主义”的理念，致力于推动科技普惠，汇聚每个人的力量，不限于小圈子的交流，还要向世界传播前沿技术。在上海同盟建设的过程中，始终坚持“海纳百川、卓越同行”的价值观，围绕国际化、行业化、辐射化的发展目标，不断推进自身建设，逐步壮大。未来，希望合肥同盟充分结合当地特色，探索出一条具有自身特色的发展路径。</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdndo6" alt="image.png" title="image.png" loading="lazy"/></p><p>ClickPaaS CPO、腾讯云架构师技术同盟上海地区理事会理事长 马俊</p><h2><strong>超越焦虑，重塑AI时代架构师的核心竞争力</strong></h2><p>腾讯云架构师技术同盟学习交流主席 沈剑带来《超越焦虑，重塑AI时代架构师的核心竞争力》的主题演讲。</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdndo8" alt="image.png" title="image.png" loading="lazy"/></p><p>腾讯云架构师技术同盟学习交流主席 沈剑</p><p>沈剑表示，在AI时代来临前，架构师曾经历过PC、移动、互联网等时代，然而这些时代的更迭并未动摇架构师岗位的核心价值。他指出，AI的本质是一种提升开发效率与质量的工具，如Eclipse、VS等开发工具一样，因此并不会真正淘汰开发者。真正决定成败的是开发者能否以开放心态主动学习AI，摆脱舒适区，实现个人成长。他强调，真正的成长并非源于年龄的增长，而是体现在取得与他人不同的结果以及实现认知的提升。</p><p>随后他谈到开发者常用的学习方法，如看书、听课、看视频等输入型学习，这些方式大多停留在无思考或浅思考层面，导致知识吸收与认知提升的效率极为低下，往往只能满足情绪价值，而难以带来实质性的进步。要想提高思考效率，开发者一方面可进行输出型学习，通过写作、分享、授课等方式来系统化梳理知识；另一方面，可借助以下四种工具来提升思考与行动效率。</p><p>一是元认知，这是对思考过程的觉察和对思维视角的切换。即以“上帝视角”来观察自身行为，并与自己对话，帮助大家深度思考，分析真实动因，提升思考质量；二是PEACE解决问题框架，P是接纳情绪、E是探究原因、A是微调认知、C是聚焦行动、E是持续迭代，通过以上五个步骤，来提升解题效率，系统化解决问题；三是最小化行动法，通过实施具体行动来获取结果，其四要素为具体行动、发生频率、验证标准以及尽可能最小化，将目标拆解为具体、可量化、可验证的行动单元来提升行动质量；四是15分钟行动法，关键是先做好“最小化行动”计划，并立刻开始，设定15分钟闹钟，从而克服启动难的问题，获得超强执行力。</p><p>沈剑以自身经验为例，当他坚持以上方法后，开始补充自己的“最小化行动法”计划，主动开展更多的工作。他表示，超强执行力并非是一次做太多的事情，也不是来自于坚强的意志力，而是在于立即付诸行动，并且善于运用那些能够提升思考、行动以及解决问题能力的工具。</p><h2><strong>AI 大模型应用架构全解析</strong></h2><p>腾讯云架构师合肥同盟理事 李伟山做题为《AI 大模型应用架构全解析》的主题演讲。</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdndpa" alt="image.png" title="image.png" loading="lazy"/><br/>腾讯云架构师合肥同盟理事 李伟山</p><p>根据专业机构数据显示，企业采用生成式 AI 的比例已从 2023 年的 33% 跃升到 2024 年的 71%。但随之而来的计算资源、安全与合规、数据、架构等挑战日益凸显。分层架构是解决这些问题的核心方案。李伟山表示，实施分层的目的并非增加系统复杂度，而是为了降低整体系统的复杂性，使架构具有清晰的演进路径。</p><p>对此，他提出六层架构体系，从下到上依次为：数据层、模型层、编排层、部署层、安全层与 API 层。数据层通过管道式 ETL 流程，支持实时/批处理混合模式，实现多源数据的抽取与转换，使用向量存储以及 ANN 索引优化检索效率。模型层通过推理算法进行优化，并运用量化、蒸馏与剪枝技术来提升性能。模型服务化通过动态批处理、权衡共享、KV 缓存以及负载均衡等手段，达成提升资源利用率、服务可用性等关键服务指标。编排层以 Agent 为智能化核心，通过编排引擎、协同决策、状态管理以及工具调用等方式，支持复杂的智能流程。部署层基于容器化部署，实现水平弹性扩容以及多集群管理，并结合 GPU 调度算法，以优化资源利用率。安全层提供身份认证、内容安全、隐私计算以及租户隔离等功能，从而保障系统安全。API 层作为用户输入层，具备版本管理、流量管理以及统一接口等功能，确保开发者体验与用户入口的稳定性。</p><p>六层架构体系的协同运作流程为：用户请求通过 API 层到达安全层，经过安全校验后，到部署层做资源分配，再由编排层做任务编排和分解，编排层可连接模型层和数据层，进行调度模型与数据服务，模型层做模型推理优化，完成推理后将数据原路返回。整体数据流向采用事件驱动架构，通过消息队列实现层级间低耦合异步通信，并在关键点部署监控点，以进行故障隔离等工作。</p><p>展望未来，李伟山表示，发展趋势将是从超大规模向小而美的专用模型转变；在多智能体协作方面，将由单体智能向多智能体分布式系统过渡；在可验证 AI 架构方面，将从黑盒模型演进至可审计、可验证的系统。企业在落地 AI 的过程中，李伟山建议架构师应从小切入，循序渐进，可采用混合模型策略，同时构建架构能力中心，持续优化数据质量，并构建可评估和监控的体系。他强调，成功的 AI 架构是技术与业务的完美结合，而非纯粹的技术堆砌。只有真正将架构与企业业务相结合，架构师才能构建出契合企业发展的实用架构。</p><h2><strong>AI 时代下搜索行业应用探索方案</strong></h2><p>腾讯云搜索业务架构师 毕志深分享《AI 时代下搜索行业应用探索方案》的主题演讲。</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdndpb" alt="image.png" title="image.png" loading="lazy"/></p><p>腾讯云搜索业务架构师 毕志深</p><p>毕志深首先回顾搜索技术的演进：1990-2000 年，搜索主要作为信息检索工具；2000-2010 年，搜索转变为意图理解引擎；2010-2020 年，搜索进入助理时代，成为答案与服务的提供者；2020 年至今，搜索进入伙伴时代，演变为问题解决型智能体。未来，搜索技术将趋于无形且无处不在，它将融入人们数字生活的方方面面，帮助人们解决各类问题。</p><p>AI 大模型推动搜索从简单的信息检索向问题解决和知识服务的范式演进。这一变革是来源于大模型与搜索的深度融合：搜索作为大模型的“知识引擎”，能够实现内容的动态扩充，突破大模型静态知识的边界，减少大模型的“幻觉”问题，因此搜索已成为大模型落地的标准配件之一，帮助大模型应对复杂问题。而大模型则赋予搜索“大脑”，使其从传统的链接列表和人工筛选的模型升级为 AI 自动总结，给出精准且高效的答案。在大模型的加持下，搜索架构从传统的搜索引擎，逐步演变为生成式搜索架构，算法也随之实现了全链路的重构。</p><p>正是由于大模型和搜索双向进化，促使两者结合，从而构建出真正强大、可靠且实用的下一代信息获取工具，腾讯云联网搜索产品应运而生。联网搜索来源于搜狗搜索，它以全网互联网数据为基础，依托腾讯生态系统，构建了从收录至召回排序全链路的综合搜索引擎。其技术对接方案简单好用，通过提供 API 接口调用的方式，帮助开发者实现综合搜索能力的快速搭建。</p><p>目前，腾讯云联网搜索产品已广泛应用于智慧生活、智慧座舱、智慧办公、电商、大模型+联网搜索、游戏、能源、传媒等多个行业领域，并在 AI 大模型、智能终端、语音助手、产品内搜、智能客服、内容创作、智慧医疗、智能问答等典型场景中成功落地。</p><p>目前，腾讯云联网搜索产品已接入 700 多款应用，也期待在未来能与企业携手共创，挖掘更多垂类场景应用，在 AI 浪潮中持续进化。</p><h2><strong>赋能 AI 进化：一体化数据标注与治理平台的架构及实践</strong></h2><p>安徽飞数系统架构师 江存高带来《赋能 AI 进化：一体化数据标注与治理平台的架构及实践》的分享。</p><p><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdndpc" alt="image.png" title="image.png" loading="lazy"/></p><p>安徽飞数系统架构师 江存高</p><p>随着 AI 进入大模型时代，各领域的应用加速落地与深化，数据需求正经历从“量”到“质”的根本性转变。作为大模型迭代优化的核心驱动力，数据在处理、治理与标注等方面迎来了新的挑战。在大模型发展趋势推动下，数据处理业务量急剧增长，数据模态从单一逐步向多模态演进，具备成熟的通用处理能力，已逐步向垂类数据拓展。如何为大模型提供高质量的数据，成为企业关注的焦点。</p><p>在此背景下，江老师从飞数的实践经验中，总结介绍了一套覆盖数据采集到服务输出的“采、存、治、标、管、用”一体化数据平台架构，支持数据的高效整合与智能应用。在数据治理上，其策略是建立数据“收集-存储-解析-清洗-抽检-标准-使用”端到端的反馈和闭环机制，以提升数据生成的针对性和质量。</p><p>该平台的数据处理流程主要包括以下环节：首先，通过数据合规采集平台，采集互联网公开数据、合作方数据以及业务数据等，并对其进行数据脱敏处理，之后将数据存入存储系统。在数据治理环节，进行数据清洗、结构化、标准化等操作，同时结合大模型进行数据提纯和知识提炼等。对于需要人工标注的数据则送入标注平台，依次经过任务分解编排、AI 预标注、人工标注、机器辅助检查、进行检查和仲裁，再进行多任务数据融合，最终形成成品数据库并推送到资产管理平台。在数据处理的全流程中，安全始终贯穿其中。整个流程中，数据安全贯穿始终，通过覆盖需求、评估、采集、传输、存储、标注、交付及销毁的全链路安全管理体系，确保数据合规性与安全性。</p><p>目前，该技术方案已在教育等多个领域落地应用。例如在教辅资料处理场景中，平台对图片、PDF、HTML 等多模态数据进行加工，完成题目识别与答案生成等任务，最终构建成品试题库。通过引入 AI 技术与分层用户设计，整体处理周期由 15 天缩短至 6 天，综合成本降低 40% 以上。</p><h2><strong>圆桌对话：AI 时代的架构师进化：范式重构、团队变革与未来人才</strong></h2><p>活动最后，来到精彩的圆桌对话环节。在华米科技大数据资深总监、腾讯云架构师合肥同盟理事 周锐的主持下，围绕 “AI 时代的架构师进化：范式重构、团队变革与未来人才”主题，羚羊工业互联网高级系统架构师，腾讯云架构师合肥同盟理事 宋国磊，前端架构专家、腾讯云架构师合肥同盟理事 大漠穷秋，LUMI CTO、腾讯云架构师合肥同盟理事长 江冬勤、优维科技联合创始人、腾讯云架构师合肥同盟理事 王津银，深入探讨架构师如何快速进化，以应对 AI 时代带来的技术挑战，并展望未来职业发展机遇。</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdndpd" alt="image.png" title="image.png" loading="lazy"/></p><p><strong>AI 时代的关键词</strong></p><p>王津银表示，一是“剪辫子”，面对 AI 变革，技术人需将过去的技术经验和认知摒弃掉。二是“成长型思维”，大家积极拥抱变化，保持开放心态。三是“激发”，他通过运营公众号等方式来倒逼自己学习，同时他注重激发团队潜能，鼓励他们拥抱 AI 变革。目前，王津银在合肥同盟理事会负责会员审核工作，他期待各位优秀架构师的加入。</p><p>江冬勤从技术管理的角度看分享，第一个是“学习”，“学”是信息输入，关注新技术发展动向，“习”是实践、输出，技术人需要在这两者间寻找平衡。第二个是“开放”。面对 AI 时代，技术人拥抱新事物、新想法。第三个关键词是“协作”。个体的能力始终有限，技术人需要连接更多人来撬动更大的事情。作为合肥同盟理事长，他将自己的角色定位为“服务员”，服务好各位同盟成员，帮助大家在同盟有所收获，有所成长。未来，他致力将合肥同盟打造成本地化、纯粹的技术社区。</p><p>大漠穷秋从开发工具的迭代中，提炼出关键词“加速”。他切身感受到，集成大模型能力的现代工具可以自动生成工程框架与目录结构，其强大功能让开发者能借助 AI 技术实现研发效率的飞跃。</p><p>宋国磊表示，首先是“热爱”，面对技术变迁，技术人员应主动拥抱并投入热爱来学习新技术；其次是“修炼”，修炼自身内功，保持对前沿技术的敏感度，积极与同行交流；最后是“传承”，他以自己坚持十年技术文章输出为例，表达了在 AI 时代继续做类似公益技术科普工作的愿望。在合肥同盟理事会，宋国磊将和大漠穷秋负责品牌发展模块，通过一系列的运营动作来树立和扩大合肥同盟的影响力。</p><p>主持人周锐总结道，无论技术如何变迁，开发者保持学习的初心，在学习过程输出总结，从而保持自身竞争力。尽管新技术层出不穷，开发者需成为掌握技术的人。</p><p><strong>问题一：AI原生架构和传统架构有哪些融合和冲突？</strong></p><p>宋国磊先从协作层面来分析，有一个名为“AI as Service”的概念，即将大模型作为大脑嵌入传统业务系统里，推动智能化升级。然而，AI 原生架构与传统架构存在冲突的地方，一是传统系统关注确定性，而大模型生成结果存在概率性，因此在实际业务场景落地时可能存在确定性和概率性的冲突问题；二是有状态与无状态的冲突，传统微服务通过无状态以支持弹性扩容，而 AI Agent 需依赖记忆和上下文进行连续决策，涉及有状态机制，这是传统架构和 AI 原生架构两个典型的冲突场景。</p><p>大漠穷秋补充道，由于大模型存在的“幻觉”问题在现阶段无法根除，当前 AI 架构存在概率性问题。在医疗、金融、大规模 IT 运维等对确定性与可靠性要求极高的场景中，核心操作无法完全交由大模型操作，这已成为当前 AI 应用落地的关键瓶颈之一。</p><p>江冬勤表示，AI 架构和传统架构之间存在确定与不确定性的矛盾竞争，AI 幻觉难以解决，没有办法做到 100% 正确率。未来，开发者的思维随着架构的变迁发生改变，开发者需要深入理解业务，从而来应用 AI，这样才能提高 AI 正确率。</p><p>王津银在探索 AI 的过程中，认识到 AI 不仅仅是一项技术或工具，而应被视为一种生产力要素。因此，开发者打造的 AI 系统应以体现人的价值，而非简单地将传统 MIS 系统进行智能化升级。例如国外一些产品已展示这种范式的重构，例如智能客服中，通过自然语言交互来重构传统的客服流程，实现全流程的智能衔接与自主决策。过去基于 UI 设计的确定性系统，把人的需求经过一系列的软件工程的步骤变成一个系统。AI 系统则很简单，人的需求通过自然语言输入，大大简化系统复杂度。当 AI 作为生产力要素融入企业组织时，它对组织协同的影响不容忽视。他强调，人们将逐步成为 AI 的决策者和监督者，而不是执行者，执行者是 AI。AI 将成为人们得力的工作伙伴。</p><p>主持人周锐表示，AI 产品的开发范式与传统 API 或云端服务开发有本质的区别。传统开发依赖逻辑和代码设计，而 AI 开发更接近“软件 2.0”，构建高质量数据集，并进行评估模型来进行不断地优化调整，涉及写代码的工作量不大。开发者无需为个别特定案例进行过度精细化的优化，真正有效的做法是基于大规模数据集进行系统性评估和持续迭代。在这种新开发范式变革下，开发者必须转变传统编程思维，强化数据驱动意识和培养评估思维。</p><p><strong>问题二：针对 AI 时代团队的变革，开发团队的构成以及工程师所具备的能力发生哪些变化？</strong></p><p>大漠穷秋分享一个例子：有些企业主可能会开玩笑说“用 AI 来替代一半团队”。这其中反映出当前的发展趋势，大量重复性工作交由 AI，大大提升工作效率。因此，未来开发团队需要的是善于应用AI工具、能够实现人机高效协作的人才。</p><p>江冬勤认为，从事需求开发和执行类工作的程序员大概率被 AI 全面替代，因为这类任务正是 AI 擅长的。未来，开发者的价值将在以下方面：一是从解决问题转向定义问题，深入业务场景，挖掘其中价值；二是进行决策，AI 可能存在幻觉问题，AI 生成多个方案时，需依赖开发者来进行决策；三是承担责任，AI 的输出结果必须由人审核和负责。</p><p>宋国磊表示，在 AI 时代，技术团队结构正发生变化：一方面，懂业务的产品经理成为关键角色，他定义好需求后，直接让大模型实现原本要前后端工程师才能完成的功能开发。因此，从事 CRUD 等重复性工作的开发者可能被 AI 替代。同时，企业对架构师的要求提升，需拥有业务理解与技术把控能力。</p><p>王津银从组织层面来分析，他建议先以独立小团队（10 人左右）形式来推进 AI 落地，避免受传统经验干扰。此外，团队 Leader 建立“非常识”的共识，统一共识对于团队来说至关重要。在个人层面，开发者可付费体验专业 AI 工具，因为付费版提供很多免费版无法提供的关键能力，可帮助开发者提升效率。例如大家可体验元宝、腾讯云代码助手等专业产品，来提升自身的工具使用能力。</p><p><strong>问题三：五年后，技术人才应具备哪些能力？</strong></p><p>宋国磊分享自身经历，过去他专注技术任务，很少去一线现场。今年，他将大量时间投入一线，深入客户现场和了解业务场景。过去，他关注技术的具体实现细节，然而在 AI 时代，技术价值的关键不在于代码实现，而在于定义问题、理解用户的真实需求。只有深入理解业务，才能将业务和AI技术结合起来，协同创新。</p><p>大漠穷秋表示，无论是架构师还是普通开发人员，都应贴近业务。从当前 AI 迅速的发展来看，开发者仅掌握编程语言、框架已不再具备竞争力。有了 AI 后，开发者的价值在于驾驭 AI，而非执行重复任务。</p><p>江冬勤引用乔新亮老师的一句话：传统 IT 团队像一支“施工队”，根据业务部门的需求来行动，十分被动。在 AI 时代，IT 团队应从被动执行转向主动思考，深入理解业务，思考业务价值，从而使用相应的 AI 工具来提效。</p><p>一些技术人员只埋头做技术，不关心业务，这种思维已难以适应 AI 时代的需求。代码是为公司创造价值的载体，其成本与收益被核算评估。因此，开发者在进行工具和框架选型时，需根据业务价值来进行权衡。</p><p>王津银谈到一些开发者面对 AI 产生的焦虑心理，认为其实不必过于担心。过去无论是蒸汽机还是电气，从技术的诞生到深度融入生产系统需要几十年的时间，AI 的发展也遵循这样的节奏。因此，开发者有充足时间准备，不必过于焦虑，而专注自己，终身学习，拥抱 AI 浪潮。</p><p>在深入的思维碰撞与观点交锋中，本次沙龙在热烈的交流氛围中迎来尾声。</p><h2><strong>结语</strong></h2><p>沙龙主持人腾讯云架构师技术同盟活动负责人 陈漱玉总结道，AI 浪潮滚滚向前，它既是工具，也是环境，更是进化的催化剂。今天的沙龙只是一个起点，愿大家带着对核心能力的自信、拥抱变革的勇气和对架构本质的洞察，共同迈入智能新纪元！</p><p>本次活动因每一位嘉宾的真诚分享而充满温度与深度，不仅有一线企业专家的实战经验与前沿洞察，更有大咖的学习心得与成长建议。对与会者来说，它不再是一场单向的技术输出，而是一个开放、平等的交流平台，让大家可以和志同道合的同行深入对话，解答困惑、共享经验、收获成长。</p><p>腾讯云架构师合肥同盟正式成立，诚邀各位架构师携手同行，迈向智能时代下的架构创新之路。</p>]]></description></item><item>    <title><![CDATA[架构火花｜一线视角下的AI：从应用边界到]]></title>    <link>https://segmentfault.com/a/1190000047439751</link>    <guid>https://segmentfault.com/a/1190000047439751</guid>    <pubDate>2025-12-01 10:04:45</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>引言</h2><p>在AI深度融入各领域的当下，围绕“AI能做什么、该做什么、落地难在哪”的讨论从未停止。结合不同行业一线实践经验，关于AI的应用场景、能力边界与落地挑战，已形成诸多值得参考的共识，这些来自实践的洞察，或许能让我们更客观地看待AI这一工具。</p><p>本文基于腾讯云架构师北京同盟成员在群内的讨论整理，在保持原意的基础上进行了编辑优化。</p><h2><strong>AI的核心应用场景：补位短板、提效赋能</strong></h2><p>在日常工作与行业实践中，AI的价值集中体现在“补全能力短板”与“优化基础流程”两大方向。</p><p>在技术开发领域，AI可有效辅助非擅长领域的工作：例如不熟悉前端或Python服务端开发时，提供前端界面截图即可生成完整的前后端项目并实现运行，大幅减少摸索时间；同时也能参与代码审核环节，如对学生提交的项目补丁进行初步筛查，为后续人工细化节省精力。不过在音视频基础处理等对专业性、稳定性要求极高的场景中，AI生成代码虽快，却常存在性能不足、编译报错、异常处理缺失等问题，暂不适合作为主力工具。</p><p>内容创作领域，AI可承担基础素材整理与框架搭建工作，辅助文章撰写；在视频生成领域，通过精准提示词实现专业参数设置，能生成远超基础操作的高质量效果，关键在于提示词的专业性与精准度。</p><p>医疗领域，AI在影像识别环节的价值已得到验证，如胸片识别可辅助医生初筛影像特征，尤其能为经验不足或判断存疑的医生提供参考，提升诊断决策的准确率。目前部分影像设备已捆绑AI标注功能，出片时同步生成AI判断结果，准确度较高，为医疗诊断提供了新的辅助路径。</p><p>此外，AI在信息检索与学术辅助中也表现亮眼，可替代传统搜索提升信息获取效率，同时在医学论文撰写等场景中，能快速整合资料、搭建框架，降低基础创作成本。</p><h2><strong>AI的能力边界：这些领域暂不适合“独当一面”</strong></h2><p>实践中，AI的局限性同样清晰，尤其在“精确性”、“严谨性”与“专业深度”方面，仍存在难以突破的瓶颈。</p><p>精确计算类任务是 AI 的明显短板，例如二进制转换、复杂函数运算时，结果错误率较高；在数据处理领域，Text2SQL 场景中，AI 在 SQL 优化与关联关系识别上存在显著不足，无法满足复杂数据查询需求。这源于AI的概率模型本质——其核心逻辑是基于数据规律生成结果，而非真正理解计算原理，因此需依赖工具辅助才能完成精确计算，无法独立承担此类任务。</p><p>更值得关注的是 AI 的“确定性偏差”：面对不确定信息时，AI 不会像人类一样给出“可能”、“应该”等模糊提示，而是始终输出绝对化结论，使用者难以判断其结论是“真懂”还是“生成式作答”，这种特性在医疗诊断、法律判断等需严谨性的场景中风险极高，必须搭配人工校验环节。</p><p>同时，部分非技术背景使用者易认为 AI 可“凭空解决复杂问题”，例如直接将大量未经梳理的数据交给AI做深度分析，或期望其独立完成跨领域复杂任务，最终因缺乏流程设计与前提条件，导致结果无法落地。本质上， AI 需依托明确指令、规范流程与配套工具，无法脱离人类引导实现“全能解决”。</p><h2><strong>AI 落地的核心挑战：需求错位与现实博弈</strong></h2><p>相较于技术能力，AI 在行业落地中面临的更大阻碍，来自需求理解偏差、责任划分与利益平衡等现实问题。</p><p>需求错位是首要难题。技术视角下，AI 常被定位为“提效工具”，例如期望通过AI辅助让医生一天查看更多影像片，但一线医疗场景的核心需求并非“效率提升”——科室主任等资深医生更关注“顶尖医院的诊断视野”，如协和、301 医院的专家判断逻辑，而非单纯增加工作量；年轻医生则需要经验补充，而非速度提升。这种“技术想提效、业务要质量”的偏差，导致 AI 工具难以匹配实际需求，甚至出现“用了 AI 反而放慢工作节奏”的情况。</p><p>责任划分与流程设计同样棘手。以医疗场景为例，AI 的核心价值是“辅助决策”，但需建立“AI 出错时的及时止损流程”：若仅依赖AI初筛而缺乏人工复核，可能引发误诊风险；若流程过于严谨，要求多人签字确认责任，又会导致效率下降，陷入“责任分散则无人担责、流程严谨则影响落地”的困境。目前行业共识是，AI 落地需先明确“责任主体在人不在AI ”，但具体流程设计仍需结合场景持续优化，例如通过“AI 置信打分+低分段人工介入”的模式，平衡效率与风险。</p><p>利益平衡与人才缺口也制约落地。企业场景中，AI 若过度替代业务环节，可能引发“技术挤压业务价值”的担忧——曾有案例显示，功能过于全面的 AI 产品因让业务部门感觉“自身价值被替代”而遭抵触，后续才意识到需在技术设计中考虑“业务让利”，保留人类在核心决策环节的价值。此外，“懂业务+懂 AI”的复合型人才稀缺，导致许多场景虽可通过“LLM+规则”模式落地，却因缺乏流程搭建能力，最终无法实现规模化应用。</p><p>数据问题是隐性瓶颈。医疗数据虽原则上需保密，但医疗集团内部数据互通已较为普遍，部分企业甚至通过售卖医院数据给大模型训练获利。这引发双重疑问：一方面，AI 在医疗领域的高准确率，究竟是基于真实病例数据训练，还是依赖书本理论生成？另一方面，数据互通的合规性与安全性如何保障？若缺乏高质量、合规的数据支撑，AI 的行业应用将沦为“空中楼阁”。</p><h2><strong>共识：AI 是“伙伴”而非“替代者”</strong></h2><p>综合一线实践经验，关于 AI 的核心共识已逐渐清晰：AI 不是“万能药”，而是需要与人类磨合的“伙伴”。</p><p>其价值不取决于技术能做什么，而在于人类如何引导其做什么——在明确场景中，通过精准指令、规范流程与人工配合，AI 可成为补位短板、优化流程的得力工具；但脱离实际需求、忽视现实约束的技术先行，只会导致工具与场景脱节。</p><p>未来 AI 的落地关键，在于从业务需求出发：先理解一线真实痛点，再匹配技术能力，而非用技术思维定义需求；同时需重视人机协同，保留人类在核心决策、风险把控与价值创造中的主导地位，让 AI 真正成为延伸人类能力的工具，而非独立替代者。毕竟，技术只有落地到人的需求中，解决真实问题，才能实现真正的价值。</p>]]></description></item><item>    <title><![CDATA[【URP】Unity[内置Shader]]]></title>    <link>https://segmentfault.com/a/1190000047439753</link>    <guid>https://segmentfault.com/a/1190000047439753</guid>    <pubDate>2025-12-01 10:03:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><a href="https://link.segmentfault.com/?enc=KkWvBXJwGygpevI%2FnlHalA%3D%3D.rxfI7%2FmQ8ZmoUR0B6FPGIkfUOky%2Fwg082JE300EqiRlRirBG3BwpOzOwvhnJztpuF9dmb8VfEsyZ8hz9WX58N7mgrEr8VKRXsw9nXlpYArGCltUub%2B95nRJ7gh57LZWlKrfNaJPodVWvFJKmJ8dkTKmEm%2Fyk0fWK6Ele3ui47V1Tce3eWXV8i93eVJzLMCX%2BeOpW8TbvW9eyn8pjUO7RvB%2B3jhpLLpXndMRfzFgP6N8%3D" rel="nofollow" target="_blank">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong></blockquote><h2><strong>BakedLit Shader的作用与原理</strong></h2><p><a href="https://link.segmentfault.com/?enc=9wHB868XLlXsDhz%2Fpcf1sg%3D%3D.RoemGL0oX9h2Xor8w9Jm5MhB6t8doJQCDCYAzhAsYOks0gS3sBauhKAiwNj2UGSp33nGts6UmgamH7IASIn6l0%2BAuZjS48g8FsxzjSugcp5axELikQ279dgGQ0K0iRQThJfkE5Irlx7iU%2FAed8%2BrEg%3D%3D" rel="nofollow" target="_blank">BakedLit</a>是Unity URP(Universal Render Pipeline)中的一种着色模型，专门用于处理预烘焙光照的场景对象。它的核心作用是利用预计算的光照信息，避免实时光照计算的开销，从而提高渲染性能。</p><h3>‌<strong>工作原理</strong>‌：</h3><ul><li>BakedLit Shader完全依赖烘焙的光照贴图(Lightmap)和光照探针(Light Probe)数据，不进行任何实时光照计算</li><li>它通过采样预烘焙的光照信息来模拟全局光照(Global Illumination)效果</li><li>适用于静态场景对象，要求物体标记为Static并设置光照模式为Baked或Mixed</li></ul><p>与标准Lit Shader相比，BakedLit的优势在于性能开销极低，特别适合移动平台或需要大量静态物体的场景。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439755" alt="" title=""/></p><h2><strong>发展历史</strong></h2><p>BakedLit Shader随着Unity的渲染管线演进：</p><ul><li>‌<strong>Built-in Render Pipeline时期</strong>‌：Unity早期版本已支持光照烘焙，但实现方式较为分散</li><li>‌<strong>URP引入2018年左右</strong>‌：将BakedLit作为标准着色模型之一，统一了跨平台实现</li><li>‌<strong>URP持续优化</strong>‌：随着URP成熟，BakedLit增加了对HDRP的兼容性，并优化了与光照探针的交互</li><li>‌<strong>Shader Graph支持</strong>‌：后期版本允许通过Shader Graph节点访问烘焙光照数据</li></ul><h2><strong>具体使用方法</strong></h2><h3><strong>基本设置步骤</strong></h3><ul><li>将场景中需要烘焙的物体标记为Static</li><li>在Window &gt; Rendering &gt; Lighting中配置烘焙参数</li><li>生成光照贴图(Bake Lightmap)</li><li>为材质选择URP &gt; BakedLit着色器</li></ul><h3><strong>代码示例</strong></h3><p>代码说明：</p><ul><li>这是一个简化的BakedLit Shader示例</li><li>主要依赖URP的Lighting.hlsl库处理烘焙光照</li><li>实际使用时URP内置的BakedLit Shader已包含完整功能</li><li><p>BakedLitExample.shader</p><pre><code class="c">Shader "Custom/BakedLitExample"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

            struct Attributes
            {
                float4 positionOS : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct Varyings
            {
                float2 uv : TEXCOORD0;
                float4 positionCS : SV_POSITION;
            };

            sampler2D _MainTex;

            Varyings vert(Attributes input)
            {
                Varyings output;
                output.positionCS = TransformObjectToHClip(input.positionOS.xyz);
                output.uv = input.uv;
                return output;
            }

            half4 frag(Varyings input) : SV_Target
            {
                half4 col = tex2D(_MainTex, input.uv);
                return col;
            }
            ENDHLSL
        }
    }
}</code></pre></li><li><p>BakedGI_Example.shadergraph</p><pre><code class="c">{
    "m_Nodes": [
        {
            "m_Id": "bakedgi_node",
            "m_Type": "UnityEditor.ShaderGraph.BakedGINode",
            "m_Position": { "x": 0, "y": 0 }
        },
        {
            "m_Id": "texture_sample",
            "m_Type": "UnityEditor.ShaderGraph.SampleTexture2DNode",
            "m_Position": { "x": -200, "y": 100 }
        },
        {
            "m_Id": "multiply",
            "m_Type": "UnityEditor.ShaderGraph.MultiplyNode",
            "m_Position": { "x": 200, "y": 0 }
        },
        {
            "m_Id": "master",
            "m_Type": "UnityEditor.ShaderGraph.UnlitMasterNode",
            "m_Position": { "x": 400, "y": 0 }
        }
    ],
    "m_Edges": [
        {
            "m_OutputSlot": "bakedgi_node_Output",
            "m_InputSlot": "multiply_A",
            "m_OutputNode": "bakedgi_node",
            "m_InputNode": "multiply"
        },
        {
            "m_OutputSlot": "texture_sample_Output",
            "m_InputSlot": "multiply_B",
            "m_OutputNode": "texture_sample",
            "m_InputNode": "multiply"
        },
        {
            "m_OutputSlot": "multiply_Output",
            "m_InputSlot": "master_Color",
            "m_OutputNode": "multiply",
            "m_InputNode": "master"
        }
    ]
}</code></pre></li></ul><h2><strong>Shader Graph中的应用</strong></h2><p>在Shader Graph中使用BakedLit效果主要有两种方式：</p><h3><strong>方法1：直接使用BakedLit Master节点(旧版)</strong></h3><ul><li>创建Shader Graph时选择"BakedLit"模板</li><li>系统会自动生成基于BakedLit的着色器图</li></ul><h3><strong>方法2：使用Baked GI节点(新版)</strong></h3><ul><li>创建常规的Unlit或Lit Shader Graph</li><li>添加"Baked GI"节点获取烘焙光照数据</li><li>将节点输出连接到主节点的适当输入端口</li></ul><h2><strong>Shader Graph示例</strong></h2><p>代码说明：</p><ul><li>此JSON结构展示了Shader Graph中使用Baked GI节点的基本配置</li><li>Baked GI节点输出与纹理采样结果相乘，最终连接到主节点的Color输入</li><li>实际使用中可通过Unity编辑器可视化构建此关系</li><li><p>BakedLitExample.shader</p><pre><code class="c">Shader "Custom/BakedLitExample"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }

        Pass
        {
            HLSLPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

            struct Attributes
            {
                float4 positionOS : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct Varyings
            {
                float2 uv : TEXCOORD0;
                float4 positionCS : SV_POSITION;
            };

            sampler2D _MainTex;

            Varyings vert(Attributes input)
            {
                Varyings output;
                output.positionCS = TransformObjectToHClip(input.positionOS.xyz);
                output.uv = input.uv;
                return output;
            }

            half4 frag(Varyings input) : SV_Target
            {
                half4 col = tex2D(_MainTex, input.uv);
                return col;
            }
            ENDHLSL
        }
    }
}</code></pre></li><li><p>BakedGI_Example.shadergraph</p><pre><code class="c">{
    "m_Nodes": [
        {
            "m_Id": "bakedgi_node",
            "m_Type": "UnityEditor.ShaderGraph.BakedGINode",
            "m_Position": { "x": 0, "y": 0 }
        },
        {
            "m_Id": "texture_sample",
            "m_Type": "UnityEditor.ShaderGraph.SampleTexture2DNode",
            "m_Position": { "x": -200, "y": 100 }
        },
        {
            "m_Id": "multiply",
            "m_Type": "UnityEditor.ShaderGraph.MultiplyNode",
            "m_Position": { "x": 200, "y": 0 }
        },
        {
            "m_Id": "master",
            "m_Type": "UnityEditor.ShaderGraph.UnlitMasterNode",
            "m_Position": { "x": 400, "y": 0 }
        }
    ],
    "m_Edges": [
        {
            "m_OutputSlot": "bakedgi_node_Output",
            "m_InputSlot": "multiply_A",
            "m_OutputNode": "bakedgi_node",
            "m_InputNode": "multiply"
        },
        {
            "m_OutputSlot": "texture_sample_Output",
            "m_InputSlot": "multiply_B",
            "m_OutputNode": "texture_sample",
            "m_InputNode": "multiply"
        },
        {
            "m_OutputSlot": "multiply_Output",
            "m_InputSlot": "master_Color",
            "m_OutputNode": "multiply",
            "m_InputNode": "master"
        }
    ]
}</code></pre></li></ul><h2><strong>实际应用场景</strong></h2><ul><li>‌<strong>静态场景光照</strong>‌：如室内环境的墙壁、地板等静态物体</li><li>‌<strong>移动平台优化</strong>‌：对性能敏感的平台，使用BakedLit替代实时光照</li><li>‌<strong>光照探针适配</strong>‌：动态物体在烘焙光照环境中的光照效果适配</li></ul><p>BakedLit Shader是URP管线中实现高性能静态光照的关键工具，合理使用可以显著提升场景渲染效率，特别是在移动设备或大型场景中</p><hr/><blockquote><a href="https://link.segmentfault.com/?enc=z9vxW49yB5%2BC6G36QKx3%2Fw%3D%3D.lNquDIej1WlLU0KzA7ON%2FSd7gsMJY8%2Fcy2ARdH%2Bj7VVN2mk0LT11hC0HUexQaZlJqh2qbCX1ZP6w2h%2FY0QggwnfJUqv4jo48bq9FoffwKdH0LchuW5L0VnZnkL88hfbdb32Rbaj%2FHxPR3ItT8s9EzXMrFcvvHMoOQT2kLOt83d%2FJWe8tPS27PBrUCzPd47Df%2FGC8d3KuDL645Ta2n%2BXmr20QfUIaGWrJ6zr%2FKJ%2Brv%2F4%3D" rel="nofollow" target="_blank">【从UnityURP开始探索游戏渲染】</a><strong>专栏-直达</strong><br/>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</blockquote>]]></description></item><item>    <title><![CDATA[价值重构：从时间出卖者到价值创造者，凸显]]></title>    <link>https://segmentfault.com/a/1190000047439757</link>    <guid>https://segmentfault.com/a/1190000047439757</guid>    <pubDate>2025-12-01 10:03:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>"我每天工作10小时，周末还要加班，但感觉离财务自由越来越远。</p><p>这正是传统职场的最大陷阱：我们被训练成"时间出卖者"，而非"价值创造者"。</p><p>在旧体系中，你的价值=工时×时薪。这种线性模型注定让你陷入忙碌却无法突破的困境。</p><p>而AI时代正在重构价值评估体系：你的价值=解决问题的能力×放大系数。</p><p>关键区别在哪里？穷人的时间只卖给一个人，富人的时间通过产品化卖给成千上万人。</p><p>一个案例（青否ai员工源头v：zhibo175）</p><p>小李，24岁，国企文员，月薪8000元。每天工作8小时，处理文件、写报告、开会议。他的时间只卖给一家公司。</p><p>一年后，他学会了用AI将专业经验产品化：创建了针对国企文书写作的AI模板库，开发了标准化课程，建立了付费社群。现在，他的同一份知识，同时卖给3000+用户。</p><p>这不是特例，而是新范式的开始。</p><p>AI不是替代你的工具，而是放大你价值的杠杆。</p><p>当一个金融分析师使用AI工具，她1小时能完成过去8小时的工作，剩余7小时可以用来思考更高价值的问题，或者将专业知识产品化。</p><p>价值重构的三个层次：</p><p>效率层：用AI提升个人工作效率</p><p>产品层：将专业知识产品化，一份时间多次销售</p><p>系统层：构建AI员工体系，自动产生价值</p><p>真正的突破发生在第三层。当你不再为时间定价，而是为系统创造的价值定价时，你才真正跳出打工人的思维牢笼。</p><p>一位从程序员转型为AI创业者说："以前，我担心35岁被裁员。现在，我拥有15个AI员工，它们24小时为我创造收入。年龄不再是威胁，而是经验和洞察的积累。"</p><p>这不是鸡汤，而是正在发生的现实。国务院文件中提到的"智能体"，正是这些永不疲倦的数字员工。2027年，当70%的企业都在使用AI员工时，你希望自己是被替代的对象，还是拥有AI军团的指挥官？</p><p>当你还在计算加班费时，先行者已经在设计自己的"AI员工招聘计划"。这就是价值重构的本质：从出卖时间，到拥有资产。</p><p>青否科技聚焦于最具AI替代价值的三类岗位：（青否ai员工源头v：zhibo175）</p><p>视频运营岗位：剪辑、发布、多平台同步</p><p>客户接待岗位：微信自动回复、客户标记、标签管理</p><p>营销触达岗位：客户分类、文案生成、批量发送</p><p>这三类岗位有个共同特点：流程固定、任务清晰、可量化成果、高频重复</p><p>而这，正是AI员工最适合发挥稳定价值的场景。</p><p>青否ai超级员工能够做什么？获客+引流+销售全流程，青否AI超级员工：支持一键控制 + 岗位级替代！</p><p>1、AI获客</p><p>告别内容内耗，多平台高效运营。</p><p>sora2批量生成爆款短视频，智能匹配行业关键词，全自动发布覆盖抖音、快手、视频号、小红书。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439759" alt="" title=""/></p><p>GEO智能体优化多平台AI内容，用户提问时主动推荐企业及产品，精准曝光。</p><p>多账号一键绑定管理，数据实时监测，无需跨平台切换，省掉半个编辑团队。</p><p>解决：内容累、制作耗时长、跨平台管理乱的痛点。</p><p>2、AI引流（青否ai员工源头v：zhibo175）</p><p>全域精准引流，获客效率倍增。</p><p>按行业+用户画像全网采集高意向客户，主动私信/评论，无需人工蹲点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439760" alt="" title="" loading="lazy"/></p><p>抖音客服7*24小时在线自动回复，AI拟人聊天，引导客户留资。</p><p>解决：找客难、引流慢、精准度低的痛点。</p><p>3、AI销售（青否ai员工源头v：zhibo175）</p><p>标准化私域成交，降本又增效。</p><p>智能私域管家：自动通过好友、实时监控聊天记录、拟人化自动回复，精准预测客户行为分层。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439761" alt="" title="" loading="lazy"/></p><p>价值重构：从时间出卖者到价值创造者，凸显ai员工的重要性（青否ai员工源头v：zhibo175）！</p>]]></description></item><item>    <title><![CDATA[MIAOYUN | 每周AI新鲜事儿（1]]></title>    <link>https://segmentfault.com/a/1190000047439768</link>    <guid>https://segmentfault.com/a/1190000047439768</guid>    <pubDate>2025-12-01 10:02:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本周全球AI领域动态密集，多家公司发布重磅模型与工具。腾讯、小米、AMD、Anthropic、DeepSeek、阿里、微软等推出多款开源大模型，覆盖视频生成、具身智能、MoE架构等，性能与成本优化显著。AI Agent、工具持续迭代，Elser.AI、Trae SOLO等落地。技术上，嵌套学习、3D资产生成等获突破，市场端特朗普签署AI战略命令，原生AI云厂商打破垄断，推动行业加速发展，一起来回顾本周发生的AI新鲜事儿吧！</p><h2><strong>AI 大模型</strong></h2><p><strong>腾讯混元大模型团队宣布开源最新视频生成模型「HunyuanVideo 1.5」</strong></p><p>11月21日，腾讯混元大模型团队宣布开源最新视频生成模型「HunyuanVideo 1.5」，基于Diffusion Transformer（DiT）架构，整合三大核心技术以实现高性能视频生成。通过8.3B参数的轻量化设计与3D因果VAE编解码器，模型实现了空间16倍、时间4倍的高效压缩，以最小参数量激发强大性能，支持生成5-10秒的高清视频。模型已经在「元宝」上线，可通过输入文字描述（Prompt），直接实现“文生视频”；或是上传图片配合Prompt，将静态图片转化为动态视频。</p><p><strong>小米正式发布并开源其全新具身智能大模型「MiMo-Embodied」</strong></p><p>11月21日，小米正式发布并开源其全新具身智能大模型「MiMo-Embodied」，实现室外自动驾驶任务（如环境感知、决策规划）与室内家居场景的具身智能的统一建模，突破传统“垂直领域专用”的局限，支持跨场景任务协同。通过“跨域能力覆盖、双向协同赋能、全链优化可靠”三大核心技术及多阶段训练策略，「MiMo-Embodied」在真实环境部署中的稳定性显著提升，并在涵盖感知、决策与规划的29项核心基准测试中全面超越现有开源与闭源模型。</p><p><strong>AMD、IBM等联合推出全球首个纯AMD硬件训练大模型「ZAYA1」</strong></p><p>11月24日，AMD联合IBM与AI初创公司Zyphra推出全球首个完全基于AMD硬件生态构建的MoE（混合专家）大模型「ZAYA1」，预训练使用14T tokens数据，在综合性能上与通义千问Qwen3系列持平。该模型在IBM Cloud的128节点集群上完成训练，每节点配备8张AMD Instinct MI300X，总计1024张GPU，峰值算力达750PFLOPs。架构层面创新包括CCA注意力机制（显存占用降32%，长上下文吞吐提18%）和线性路由MoE（稀疏度70%下仍保持高效专家利用率）。AMD借此强化其“全栈AI”战略，目标2026年实现训练成本与NVIDIA方案对等。</p><p><strong>Anthropic发布最新旗舰模型「Claude Opus 4.5」</strong></p><p>11月25日，Anthropic正式发布了最新旗舰模型「Claude Opus 4.5」，在编程、智能体（Agent）及计算机使用方面被宣称为当前全球领先的模型，并实现了性能与价格的双重突破。该模型API调用价格降至每百万Token输入5美元/输出25美元，比上代「Opus 4.1」降低了约三分之二。同时还更新了Claude开发者平台、Claude Code及消费者应用，并增强了对Excel、Chrome等工具的集成支持，智能体模式（Plan Mode）也得到升级。</p><p><strong>腾讯混元推出全新开源模型「HunyuanOCR」，参数仅1B刷新多项SOTA</strong></p><p>11月25日，腾讯混元推出全新开源模型「HunyuanOCR」，参数仅为1B，依托于混元原生多模态架构打造，获得多项业界OCR应用榜单SOTA成绩。该模型采用端到端的理念设计，由“原生分辨率视频编码器、自适应视觉适配器和轻量化混元语言模型”三大部分组建构成，精通多语种复杂文档解析，同时兼具文字检测和识别能力，并支持14种高频小语种翻译。</p><p><strong>Black Forest Labs发布开源图像生成模型「FLUX.2」</strong></p><p>11月26日，Black Forest Labs发布开源图像生成模型「FLUX.2」，专为现实创意工作流程打造，可在8秒内生成400万像素高清图像，单次生成成本仅为0.003美元，以更低的价格实现类似「Nano Banana Pro」的效果。该模型基于潜空间的流匹配架构构建，并将图像生成与编辑整合在同一个模型中。本次发布包含Pro、Flex、Dev和预告中的Klein四个版本，其中Dev版参数精简40%，支持RTX 3060级别显卡运行，在文本生成图像、单参考编辑、多参考编辑等方面均达领先水平。</p><p><strong>阿里通义实验室推出新一代文本生成图像模型「Z-Image」</strong></p><p>11月27日，阿里巴巴通义实验室推出新一代文本生成图像模型「Z-Image」，以仅6B参数的Turbo变体以8 NFEs实现亚秒级推理，16G显存即可运行，139秒生成20张高质量图。该模型采用可扩展的单流DiT（S3-DiT）架构，将文本与视觉信息融合处理，参数量减少三分之二的同时推理速度提升，RTX 4090上生成1024×1024图像仅需2.3秒。支持8步采样即达印刷级细节表现，在皮肤纹理、玻璃反光等复杂材质渲染上表现出色。</p><p><strong>DeepSeek发布「DeepSeek Math-V2」新模型，夺下IMO 2025金牌</strong></p><p>11月27日，DeepSeek发布了「DeepSeek Math-V2」新模型，相较于上一代「DeepSeek-Math-7b」及「Gemini DeepThink」等模型性能更优，以83.3%分夺下IMO 2025金牌。该模型核心突破在于从“结果导向”转向“过程导向”，构建了由“阅卷老师”（验证器）、“督导”（元验证机制）和“自省学生”（生成器）组成的系统，通过诚实奖励机制、自动化闭环等创新设计，实现可自我验证的数学推理，既提升了高难度数学证明题的解决能力，又大幅减少了大模型幻觉，为更强数学AI系统的发展提供了可行方向。</p><p><strong>微软推出首款为“电脑操作代理”设计的开源语言模型「Fara-7B」</strong></p><p>11月27日，微软推出首款专为“电脑操作代理（CUA）”设计的小型开源语言模型「Fara-7B」，只有7B参数却性能出众，能直接在本地设备（如搭载NPU的Copilot+ PC）运行，兼具低延迟与强隐私优势。该模型基于「Qwen2.5-VL-7B」训练，采用纯视觉路线，通过“观察-思考-行动”模式能直接读取网页截图、预测点击坐标并模拟鼠标键盘操作，可完成购买商品、整理Github更新、规划旅程等跨应用任务。</p><h2><strong>AI Agent</strong></h2><p><strong>北大哲学博士刘耕创办了一款AI短剧生成Agent「Elser.AI」</strong></p><p>11月24日消息，北大哲学博士刘耕创办「Elser.AI」，一款AI短剧生成Agent，在完全没有宣传情况下积累了20万全球活跃用户。「Elser.AI」支持从剧本到分镜到成片的全流程创作，用户可控制角色形象、构图景深、运镜动作等所有细节，实现“创作平权”。海外版将于12月1日上线，全线接入「Nano Banana Pro」，所有在Waitlist登记的用户都将收到首波邀请。</p><p><strong>Anthropic发布针对长程Agent的双Agent架构解决方案</strong></p><p>11月27日，Anthropic发布Agent工程实践文章，针对长程Agent在多会话间难以保持进度一致的核心难题（如一次性蛮干耗尽上下文、过早宣布完工等），提出双Agent架构解决方案：初始化Agent负责搭建环境，生成包含所有功能需求（初始标记为 “未通过”）的JSON格式功能列表、init.sh脚本、进度文件及初始Git提交；编码Agent则通过增量开发、Git提交与进度记录、端到端测试（借助浏览器自动化工具）推进单个功能，同时每个编码Agent会话开始时会通过查看工作目录、Git日志、进度文件等快速了解项目状态。</p><h2><strong>AI 工具</strong></h2><p><strong>Google旗下AI工具NotebookLM推出「Slide Decks」幻灯片生成功能</strong></p><p>11月22日，Google旗下AI笔记工具NotebookLM推出「Slide Decks」幻灯片生成功能，用户只需导入PDF、网页或视频等原始资料，AI即可自动提炼核心信息并生成结构完整、逻辑清晰的演示文稿。新功能严格遵循源材料，避免事实幻觉，并由新型图像模型「Nano Banana Pro」提供专业配图。同时新增「Infographics」图表生成功能，将复杂数据转化为可视化摘要，全面提升知识工作者的内容产出效率。</p><p><strong>阿里巴巴旗下AI助手「千问App」一周破千万，成史上增长最快的AI应用</strong></p><p>11月24日，阿里巴巴旗下AI助手「千问App」公测一周，下载量突破1000万次，超越ChatGPT、Sora、DeepSeek成为全球增长最快的AI应用，并带动阿里港股单日涨幅超6%。过去一年，凭借通义千问大模型能力的跃升、开源模型在海外市场受到的认可及其带动的云业务增长等，AI成为驱动阿里股价上涨的第二增长曲线，抢占“AI时代的超级入口”的战略重要性正在不断上升。</p><p><strong>AI编程工具「Trae SOLO」中国版正式上线，全部功能完全免费</strong></p><p>11月25日，字节跳动正式推出类似Cursor的AI编程工具「Trae SOLO」中国版，并带来SOLO Coder、Plan模式、多任务并行、代码变更工具DiffView、上下文压缩等核心能力，所有功能完全免费。此次「Trae SOLO」中国版的上线打破了海外AI编程工具的使用门槛，通过“技术平权”让更多非专业用户接触并使用编程能力，实现从“工具增强”到“流程简化”的突破。</p><p><strong>ChatGPT更新整合「语音模式」和上线「AI购物研究」功能</strong></p><p>11月26日，OpenAI宣布ChatGPT完成重大功能迭代，将原独立的「语音模式」（Voice Mode）全面整合至主聊天界面，实现语音与文本交互的深度融合，用户可在语音交互时同步查看地图、图表等视觉内容并获取自动生成的文字转录稿，同时支持一键切换回纯音频模式以适配不同使用习惯。此外还推出了「AI购物研究」功能，上线支持iCloud钥匙串的Atlas AI浏览器新功能，在部分地区开放群聊功能，并通过性能更强的GPT-5.1模型进一步提升了对话智能度与流畅性。</p><h2><strong>技术突破</strong></h2><p><strong>南洋理工开源「PhysX-Anything」框架，实现单张图像生成仿真的3D资产</strong></p><p>11月24日，南洋理工大学开源「PhysX-Anything」框架，首个面向仿真、具备物理属性的3D生成框架：仅需单张图像，即可生成高质量、可直接用于仿真的3D资产，并同时具备显式几何结构、关节运动以及物理参数，可直接用于MuJoCo等机器人仿真环境。该框架通过VLM驱动的物理建模和高效输出格式，为机器人仿真和具身智能提供了高质量资产来源。</p><p><strong>Google Research发布论文提出「嵌套学习」新机器学习范式</strong></p><p>11月25日，近期Google Research发布的论文提出了「嵌套学习」（Nested Learning）新机器学习范式，将模型拆分为一组具有各自内部工作流程的嵌套优化问题，每个子问题拥有独立工作流程，可减轻甚至避免“灾难性遗忘”。该方法通过关联记忆、更新频率分层和优化器即记忆模块三大创新，实现“早期层高频刷，后期层低频整合”的新训练框架；基于此推出的HOPE模型在语言建模困惑度和常识推理准确率上均表现最优，在长上下文大海捞针任务中展现出卓越的内存管理能力。</p><h2><strong>市场动态</strong></h2><p><strong>美国白宫特朗普正式签署「创世纪计划」行政命令当地时间</strong></p><p>11月24日，特朗普在美国白宫签署「创世纪计划」（Genesis Mission）行政命令，被比作「曼哈顿计划」和「阿波罗计划」，是其第二任期内AI战略的关键举措，核心是借助AI革新科研模式以巩固美国在全球AI及科技领域的领先地位，由美国能源部（DOE）领导，利用国家级超级计算机和联邦数据，构建一个全新的「美国科学与安全平台」，锁定核聚变、芯片、生物技术等六大核心领域攻坚科研难题，要求60天内提出20项国家挑战，并勒令9个月内构建AI科研闭环。目前，NVIDIA、Dell、AMD等科技巨头均响应参与。</p><p><strong>超6000亿美元市场，「原生AI云厂商」打破巨头垄断格局</strong></p><p>11月27日消息，IDC、沙利文等全球知名市研机构的云计算报告中都提到了一个新概念「原生AI云厂商」，在超 6000 亿美元的全球云计算市场，「原生AI云厂商」崛起打破了传统云巨头的垄断格局。报告显示，海外CoreWeave成头部玩家，国内商汤科技表现亮眼，2025年H1位列中国原生AI云厂商首位，2024年GenAI技术栈市场增长与创新指数国内第一、全球仅次于亚马逊云科技。与传统云巨头相比，「原生AI云厂商」在AI技术绑定、场景适配性等方面更具优势，但基础设施覆盖等存在短板。</p>]]></description></item><item>    <title><![CDATA[AI如何让企业知识库从成本中心变成效率引]]></title>    <link>https://segmentfault.com/a/1190000047439792</link>    <guid>https://segmentfault.com/a/1190000047439792</guid>    <pubDate>2025-12-01 10:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>你有没有算过，你的团队每天花在找资料上的时间有多少？</p><p>上周我拜访了一家科技公司，他们的技术总监给我看了一组数据：平均每个工程师每天要花1.5小时在内部资料检索上。不是他们效率低，而是公司的知识库已经变成了一个“信息黑洞”——文档散落在各个角落，版本混乱，搜索功能形同虚设。</p><p>“我们不是没有知识库，而是有太多‘知识库’了。”他苦笑着说，“Confluence里有一部分，飞书文档里有一部分，还有一堆本地文件和个人笔记。找个API文档就像在玩寻宝游戏。”</p><p>这场景你熟悉吗？</p><h2>知识管理的三大痛点，你中了几个？</h2><p><strong>痛点一：信息孤岛无处不在</strong></p><p>市场部的营销资料、技术部的API文档、客服部的话术库、人事部的规章制度...每个部门都在用自己的方式管理知识，结果就是员工需要切换多个平台才能找到完整信息。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439794" alt="" title=""/></p><p><strong>痛点二：搜索等于二次劳动</strong></p><p>传统搜索只能匹配关键词，无法理解你的真实需求。想找“视频上传失败的处理方案”？搜索结果给你一堆包含“视频”、“上传”、“失败”的文档，你得一个个打开确认。</p><p><strong>痛点三：知识更新永远滞后</strong></p><p>文档更新了没人知道，员工还在用旧版本操作。新同事入职，光是熟悉各个系统的使用规范就要花上一两周。</p><h2>AI知识库的破局之道</h2><p>当我向那位技术总监推荐PandaWiki时，他最初是怀疑的：“又一个知识库工具？我们试过很多了，都没解决根本问题。”</p><p>我告诉他：“这次不一样，因为核心不是‘存储’，而是‘理解’。”</p><h3>从“找答案”到“生成答案”的转变</h3><p>传统的知识库是你问什么，它给你什么。而AI知识库是你需要什么，它给你什么。</p><p>举个例子，他们的客服团队之前处理客户投诉时，需要在知识库、工单系统、产品文档之间来回切换。现在，客服只需要在飞书上问：“客户反映视频上传一直失败，可能是什么原因？如何解决？”</p><p>PandaWiki的AI助手会立即从产品文档、技术手册、历史工单中提取相关信息，生成一个结构化的解决方案：</p><p>“可能原因及解决方案：</p><ol><li>网络问题：检查客户网络环境，建议切换网络重试</li><li>文件格式问题：目前支持MP4、MOV格式，最大2GB</li><li>账户权限：确认客户账户是否有上传权限</li><li>系统状态：当前视频处理服务正常，无异常报警”</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047384380" alt="" title="" loading="lazy"/></p><h3>三分钟搭建，立即见效</h3><p>很多人觉得部署AI知识库很复杂，其实PandaWiki的开源版本只需要几个简单步骤：</p><ol><li><strong>环境准备</strong>：支持Docker一键部署，或者直接在服务器上安装</li><li><strong>AI模型配置</strong>：在管理后台选择适合的AI模型，中文场景推荐通义千问，英文技术文档推荐Llama3</li><li><strong>知识导入</strong>：支持本地上传PDF/Word/Excel，网页抓取，或者通过API接入现有系统数据</li></ol><p>那位技术总监的团队从部署到投入使用，只用了半天时间。效果如何？两周后他告诉我，工程师的日常检索时间从1.5小时降到了20分钟。</p><h2>真实场景中的效率提升</h2><h3>电商企业的客服变革</h3><p>某电商技术团队使用PandaWiki搭建了商品知识库后，客服响应速度提升了70%。为什么？因为AI问答模块能够自动解答80%的常见问题，客服只需要处理那些真正复杂的个案。</p><p>他们的客服主管说：“以前新客服培训要一个月，现在一周就能上岗，因为大部分产品问题AI都能实时解答。”</p><h3>开源社区的知识聚合</h3><p>一个开源社区用PandaWiki聚合了200多个项目的文档，AI自动生成的技术对比矩阵让开发者能够快速了解不同方案的优劣。结果？开发者贡献量提升了300%，社区活跃度进入行业前三。</p><h3>金融企业的合规保障</h3><p>对于金融、政务、医疗等对数据安全要求严格的行业，PandaWiki支持私有化部署，确保敏感数据不出内网。严格的权限管理体系让不同部门、不同角色只能访问被授权的知识内容。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439795" alt="" title="" loading="lazy"/></p><h2>为什么是PandaWiki？</h2><p>市面上知识库工具不少，但PandaWiki有几个独特优势：</p><p><strong>全流程覆盖</strong>：从文档创作、团队协作到AI问答，形成一个完整的知识管理闭环。不像有些工具只解决单点问题。</p><p><strong>开箱即用</strong>：非技术团队也能快速上手，不需要复杂的配置就能发挥全部功能。</p><p><strong>灵活集成</strong>：支持飞书、钉钉、企业微信等办公平台，知识查询就像@同事一样简单。</p><p><strong>智能理解</strong>：基于大模型的AI能力，真正理解你的问题意图，而不是简单关键词匹配。</p><h2>你的企业适合吗？</h2><p>PandaWiki特别适合这些场景：</p><ul><li><strong>产品团队</strong>需要管理内外产品文档和版本更新</li><li><strong>技术团队</strong>要构建API文档和部署手册</li><li><strong>客服支持</strong>想要搭建智能FAQ系统</li><li><strong>内容创作者</strong>希望打造AI驱动的博客</li><li><strong>培训教育</strong>机构需要建立智能课程库</li></ul><p>如果你们公司存在以下情况，真的应该认真考虑引入AI知识库了：</p><ul><li>员工经常抱怨找不到资料</li><li>同一个问题被反复提问</li><li>新员工上手速度慢</li><li>跨部门协作信息不畅</li></ul><h2>从今天开始改变</h2><p>知识管理不应该成为企业的成本中心，而应该成为驱动效率的引擎。当你的团队不再为找资料发愁，他们就能把更多精力放在创造价值的工作上。</p><p>那位技术总监最后对我说：“早知道这么简单，我们一年前就该用了。现在团队效率上来了，员工满意度也提高了，这才是双赢。”</p><p>如果你也想告别知识管理的烦恼，不妨试试PandaWiki。开源4个月已经在GitHub上收获6.6K Star，深受广大用户青睐。</p><p><strong>GitHub地址</strong>：<a href="https://link.segmentfault.com/?enc=LtJdGSKJDo2mcUcIRNm8Ow%3D%3D.smoZ7E6KXgr41JKSId2xZNFV1VovgiZohoR5GQUGHz2d9zo4PFlUYTheFnO%2FFysQ" rel="nofollow" target="_blank">PandaWiki开源项目</a><br/><strong>详细教程</strong>：<a href="https://link.segmentfault.com/?enc=vn1Qw%2F3jBW0jlayVWD%2FUbA%3D%3D.%2FZTCmp4Xah1b2lmo8WxVK6nFoocd%2Ba7XiNFHNHOyMCNuWy%2BC5grvjnSUt%2BZD9lZACwPi%2BsIrjgv8o17s2uaGkfFjySNlvgP4OWOlfC1SZnA%3D" rel="nofollow" target="_blank">PandaWiki完整使用指南</a></p><p>知识管理的新时代已经到来，你的企业准备好了吗？</p>]]></description></item><item>    <title><![CDATA[C#.NET Record Struct]]></title>    <link>https://segmentfault.com/a/1190000047439612</link>    <guid>https://segmentfault.com/a/1190000047439612</guid>    <pubDate>2025-12-01 09:02:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3>简介</h3><p><code>Record Structs</code> 是一种值类型的记录（<code>record</code>），结合了 <code>struct</code> 的值语义和 <code>record</code> 的功能（如自动生成相等性比较、不可变性支持）。它们是 <code>C# 9.0</code> 中引入的引用类型 <code>record</code>（默认 <code>class</code>）的扩展，专为性能敏感场景设计，特别是在需要栈分配或避免 <code>GC</code> 压力的情况下。</p><h4>核心特性</h4><ul><li>值类型：存储在栈上（除非装箱），避免堆分配，适合小数据结构。</li><li>不可变性：默认鼓励不可变设计（通过 <code>init-only</code> 属性），但可选择可变。</li><li>值相等性：自动实现基于内容的相等性比较（== 和 <code>Equals</code>）。</li><li>自动 <code>ToString</code>：生成人类可读的字符串表示。</li><li>解构支持：自动提供 <code>Deconstruct</code> 方法，方便模式匹配和解构。</li><li><code>With</code> 表达式：支持非破坏性变异（创建新实例）。</li><li>继承支持：支持继承其他 <code>record structs</code>（但不能继承 <code>class</code> 或 <code>record class</code>）。</li></ul><h3>基本语法</h3><pre><code class="csharp">// 最简单的记录结构声明
public record struct Point(int X, int Y);

// 等价于传统的结构体声明（但功能更强大）
public struct Point
{
    public int X { get; init; }
    public int Y { get; init; }
    
    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }
    
    // 自动生成的 Equals、GetHashCode、ToString 等方法
}</code></pre><h4>可变性控制</h4><pre><code class="csharp">// 不可变记录结构 (推荐)
public readonly record struct ImmutablePoint(int X, int Y);

// 可变记录结构
public record struct MutablePoint
{
    public int X { get; set; }
    public int Y { get; set; }
}

// 混合可变性
public record struct MixedPoint(int X, int Y) // X 和 Y 默认只读
{
    public int Z { get; set; } // 额外的可变属性
}</code></pre><h3>记录结构 vs 记录类 vs 普通结构体</h3><table><thead><tr><th>特性</th><th>记录结构 (record struct)</th><th>记录类 (record class)</th><th>普通结构体 (struct)</th></tr></thead><tbody><tr><td>类型</td><td>值类型</td><td>引用类型</td><td>值类型</td></tr><tr><td>分配位置</td><td>栈（通常）</td><td>堆</td><td>栈（通常）</td></tr><tr><td>默认不可变</td><td>是（属性为 <code>init</code>）</td><td>是（属性为 <code>init</code>）</td><td>否（可变）</td></tr><tr><td>值相等性</td><td>自动实现</td><td>自动实现</td><td>需手动实现</td></tr><tr><td><code>with</code> 表达式</td><td>支持</td><td>支持</td><td>不支持</td></tr><tr><td>解构</td><td>自动支持</td><td>自动支持</td><td>需手动实现</td></tr><tr><td>继承</td><td>不支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h3>记录结构的核心特性</h3><h4>位置记录结构（Positional Record Structs）</h4><pre><code class="csharp">// 位置记录结构 - 最简洁的形式
public record struct Person(string FirstName, string LastName, int Age);

// 使用示例
var person = new Person("John", "Doe", 30);
Console.WriteLine(person); // 输出: Person { FirstName = John, LastName = Doe, Age = 30 }

// 解构
var (firstName, lastName, age) = person;
Console.WriteLine($"{firstName} {lastName}, {age}岁");</code></pre><h4>值相等性（Value Equality）</h4><pre><code class="csharp">public record struct Point(int X, int Y);

// 值相等性比较
var point1 = new Point(1, 2);
var point2 = new Point(1, 2);
var point3 = new Point(3, 4);

Console.WriteLine(point1 == point2); // True - 基于值比较
Console.WriteLine(point1 == point3); // False
Console.WriteLine(point1.Equals(point2)); // True</code></pre><h4>with 表达式（非破坏性变更）</h4><pre><code class="csharp">public record struct Person(string FirstName, string LastName, int Age);

var original = new Person("John", "Doe", 30);

// 创建修改后的副本（非破坏性变更）
var updated = original with { Age = 31 };
var renamed = original with { FirstName = "Jane" };

Console.WriteLine(original); // Person { FirstName = John, LastName = Doe, Age = 30 }
Console.WriteLine(updated);  // Person { FirstName = John, LastName = Doe, Age = 31 }
Console.WriteLine(renamed);  // Person { FirstName = Jane, LastName = Doe, Age = 30 }</code></pre><h4>自定义行为</h4><pre><code class="csharp">// 自定义记录结构
public record struct Person(string FirstName, string LastName)
{
    // 添加计算属性
    public string FullName =&gt; $"{FirstName} {LastName}";
    
    // 添加方法
    public string GetFormattedName() =&gt; $"{LastName}, {FirstName}";
    
    // 重写ToString
    public override string ToString() =&gt; FullName;
    
    // 自定义相等性逻辑（可选）
    public bool Equals(Person other) =&gt; 
        FirstName == other.FirstName &amp;&amp; LastName == other.LastName;
    
    // 自定义GetHashCode（可选）
    public override int GetHashCode() =&gt; 
        HashCode.Combine(FirstName, LastName);
}

// 使用自定义记录结构
var person = new Person("John", "Doe");
Console.WriteLine(person.FullName); // John Doe
Console.WriteLine(person.GetFormattedName()); // Doe, John
Console.WriteLine(person); // John Doe</code></pre><h3>高级用法和模式</h3><h4>与模式匹配结合</h4><pre><code class="csharp">public record struct Point(int X, int Y);

// 在模式匹配中使用记录结构
string ClassifyPoint(Point point) =&gt; point switch
{
    (0, 0) =&gt; "原点",
    (var x, var y) when x == y =&gt; "在y=x线上",
    (var x, var y) when x &gt; 0 &amp;&amp; y &gt; 0 =&gt; "第一象限",
    (var x, var y) when x &lt; 0 &amp;&amp; y &gt; 0 =&gt; "第二象限",
    (var x, var y) when x &lt; 0 &amp;&amp; y &lt; 0 =&gt; "第三象限",
    (var x, var y) when x &gt; 0 &amp;&amp; y &lt; 0 =&gt; "第四象限",
    _ =&gt; "在坐标轴上"
};

// 使用示例
Console.WriteLine(ClassifyPoint(new Point(0, 0))); // 原点
Console.WriteLine(ClassifyPoint(new Point(3, 3))); // 在y=x线上
Console.WriteLine(ClassifyPoint(new Point(2, 4))); // 第一象限</code></pre><h4>实现接口</h4><pre><code class="csharp">public record struct Vector2D(double X, double Y) : IFormattable
{
    public double Magnitude =&gt; Math.Sqrt(X * X + Y * Y);
    
    public string ToString(string format, IFormatProvider formatProvider)
    {
        return format?.ToUpper() switch
        {
            "M" =&gt; $"({X}, {Y}) with magnitude {Magnitude:F2}",
            _ =&gt; $"({X}, {Y})"
        };
    }
}

// 使用接口实现
var vector = new Vector2D(3, 4);
Console.WriteLine(vector.ToString("M", CultureInfo.InvariantCulture));
// 输出: (3, 4) with magnitude 5.00</code></pre><h4>集合中使用 Record Structs</h4><pre><code class="csharp">// 高性能点集处理
var points = new Point[1000];
var sum = new Point(0, 0);

for (int i = 0; i &lt; points.Length; i++)
{
    points[i] = new Point(i, i * 2);
    sum = sum with 
    { 
        X = sum.X + points[i].X, 
        Y = sum.Y + points[i].Y 
    };
}</code></pre><h4>与 Span 和 Memory 结合</h4><pre><code class="csharp">Span&lt;Point&gt; points = stackalloc Point[4];
points[0] = new(0, 0);
points[1] = new(0, 1);
points[2] = new(1, 1);
points[3] = new(1, 0);

// 高性能几何计算
double area = CalculatePolygonArea(points);</code></pre><h3>实际应用场景</h3><h4>数学和几何计算</h4><pre><code class="csharp">public readonly record struct Rectangle(Point TopLeft, Point BottomRight)
{
    public int Width =&gt; BottomRight.X - TopLeft.X;
    public int Height =&gt; BottomRight.Y - TopLeft.Y;
    public int Area =&gt; Width * Height;
    
    public bool Contains(Point point) =&gt;
        point.X &gt;= TopLeft.X &amp;&amp; point.X &lt;= BottomRight.X &amp;&amp;
        point.Y &gt;= TopLeft.Y &amp;&amp; point.Y &lt;= BottomRight.Y;
    
    public Rectangle Inflate(int delta) =&gt;
        this with 
        { 
            TopLeft = new Point(TopLeft.X - delta, TopLeft.Y - delta),
            BottomRight = new Point(BottomRight.X + delta, BottomRight.Y + delta)
        };
}

// 使用几何记录结构
var rect = new Rectangle(new Point(0, 0), new Point(10, 10));
Console.WriteLine($"面积: {rect.Area}"); // 面积: 100
Console.WriteLine($"包含点 (5,5): {rect.Contains(new Point(5, 5))}"); // True

var largerRect = rect.Inflate(2);
Console.WriteLine($"新面积: {largerRect.Area}"); // 新面积: 196</code></pre><h4>数据传输对象（DTO）</h4><pre><code class="csharp">// API 响应DTO
public readonly record struct ApiResponse&lt;T&gt;(T Data, string Error, DateTime Timestamp)
{
    public bool IsSuccess =&gt; string.IsNullOrEmpty(Error);
    
    public static ApiResponse&lt;T&gt; Success(T data) =&gt; 
        new ApiResponse&lt;T&gt;(data, null, DateTime.UtcNow);
    
    public static ApiResponse&lt;T&gt; Failure(string error) =&gt; 
        new ApiResponse&lt;T&gt;(default, error, DateTime.UtcNow);
}

// 使用DTO记录结构
var successResponse = ApiResponse&lt;string&gt;.Success("操作成功");
var errorResponse = ApiResponse&lt;string&gt;.Failure("发生错误");

Console.WriteLine(successResponse.IsSuccess); // True
Console.WriteLine(errorResponse.IsSuccess);   // False</code></pre><h4>领域模型中的值对象</h4><pre><code class="csharp">// 货币值对象
public readonly record struct Money(decimal Amount, string Currency)
{
    public static Money operator +(Money left, Money right)
    {
        if (left.Currency != right.Currency)
            throw new InvalidOperationException("货币类型不匹配");
        
        return new Money(left.Amount + right.Amount, left.Currency);
    }
    
    public static Money operator *(Money money, decimal factor) =&gt;
        new Money(money.Amount * factor, money.Currency);
    
    public override string ToString() =&gt; $"{Amount:F2} {Currency}";
}

// 使用值对象
var price1 = new Money(100.50m, "USD");
var price2 = new Money(50.25m, "USD");
var total = price1 + price2;
var discounted = total * 0.9m;

Console.WriteLine($"总价: {total}");       // 总价: 150.75 USD
Console.WriteLine($"折扣价: {discounted}"); // 折扣价: 135.68 USD</code></pre><h3>最佳实践和注意事项</h3><h4>何时使用记录结构</h4><pre><code class="csharp">// ✅ 适合使用记录结构的场景：
// 1. 小型、简单的数据结构
public record struct Point(int X, int Y);

// 2. 值语义重要的场景
public record struct Money(decimal Amount, string Currency);

// 3. 性能敏感的场景（避免堆分配）
public record struct Measurement(double Value, string Unit);

// 4. 需要值相等性的场景
public record struct KeyValuePair&lt;TKey, TValue&gt;(TKey Key, TValue Value);

// ❌ 不适合使用记录结构的场景：
// 1. 大型数据结构（&gt;16字节）
// 2. 需要继承的场景
// 3. 需要身份标识的场景</code></pre><h3>适用场景</h3><ul><li>高性能游戏开发：<code>3D</code> 坐标、向量、颜色</li><li>科学计算：矩阵、复数、测量单位</li><li>金融系统：货币金额、汇率</li><li>数据处理管道：中间数据结构</li><li>设备通信：协议数据包结构</li><li>地理空间计算：坐标点、边界框</li></ul><h3>总结</h3><p><code>C# 10</code> 的记录结构是一个强大的特性，它结合了结构体的性能优势和记录的简洁性。关键要点：</p><ul><li>值类型语义：记录结构是值类型，分配在栈上，性能更好</li><li>不可变性：默认提供不可变属性（使用 <code>init</code> 访问器）</li><li>值相等性：自动实现基于值的相等性比较</li><li>简洁语法：提供位置语法、<code>with</code> 表达式和解构功能</li><li>适用场景：小型数据结构、值对象、性能敏感场景</li></ul>]]></description></item><item>    <title><![CDATA[数据结构-哈希表 程序员Seven ]]></title>    <link>https://segmentfault.com/a/1190000047437756</link>    <guid>https://segmentfault.com/a/1190000047437756</guid>    <pubDate>2025-12-01 09:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>介绍</h2><p>像线性数据结构在查找的时候，⼀般都是使⽤= 或者!= ，在折半查找或者其他范围查询的时候，可能会使⽤&lt; 和&gt; ,理想的时候，我们肯定希望不经过任何的⽐较，直接能定位到某个位置（存储位置），这种在数组中，可以通过索引取得元素。那么，如果我们将需要存储的数据和数组的索引对应起来，并且是⼀对⼀的关系，那不就可以很快定位到元素的位置了么？</p><p>只要通过函数f(k) 就能找到k 对应的位置，这个函数f(k) 就是hash 函数。它表示的是⼀种映射关系，但是对不同的值，可能会映射到同⼀个值（同⼀个hash 地址），也就是f(k1) = f(k2) ，这种现象我们称之为冲突或者碰撞。</p><p>hash 表定义如下：散列表（Hash table，也叫哈希表），是根据键（Key）⽽直接访问在内存储存位置的数据结构。也就是说，它通过计算⼀个关于键值的函数，将所需查询的数据映射到表中⼀个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047437758" alt="" title=""/></p><p>⼀般常⽤的hash 函数有：</p><ul><li>直接定址法：取出关键字或者关键字的某个线性函数的值为哈希函数，⽐如H(key) = key 或者H(key) = a * key + b</li><li>数字分析法：对于可能出现的数值全部了解，取关键字的若⼲数位组成哈希地址</li><li>平⽅取中法：取关键字平⽅后的中间⼏位作为哈希地址</li><li>折叠法：将关键字分割成为位数相同的⼏部分（最后⼀部分的位数可以不同），取这⼏部分的叠加和（舍去进位），作为哈希地址。</li><li>除留余数法：取关键字被某个不⼤于散列表表⻓m 的数p 除后所得的余数为散列地址。即h ash(k)=k mod p ， p&lt; =m 。不仅可以对关键字直接取模，也可在折叠法、平⽅取中法等运算之后取模。对p 的选择很重要，⼀般取素数或m ，若p 选择不好，容易产⽣冲突。</li><li>随机数法：取关键字的随机函数值作为它的哈希地址。</li></ul><p>但是这些⽅法，都⽆法避免哈希冲突，只能有意识的减少。那处理hash 冲突，⼀般有哪些⽅法呢？</p><h2>解决哈希冲突的三种方法</h2><p>拉链法、开放地址法、再散列法</p><h3>拉链法</h3><p>HashMap，HashSet其实都是采用的<a href="https://link.segmentfault.com/?enc=nuXV1fzTTPvZcAvw33G%2BAA%3D%3D.LZtcEKRERcdIJrg2BluEq%2ByrNGC5K%2BiZWMWTk0rMHkha0E7oSEKiKWBZ9Ol81VkWVxCqUpM%2FKKggx8N4j2lhoyXZsM95N5vrYFXU4C7qdTc%3D" rel="nofollow" target="_blank">拉链法</a>来解决哈希冲突的，就是在每个位桶实现的时候，采用链表的数据结构来去存取发生哈希冲突的输入域的关键字（也就是被哈希函数映射到同一个位桶上的关键字）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046514287" alt="" title="" loading="lazy"/></p><p>但是如果hash 冲突⽐较严重，链表会⽐较⻓，查询的时候，需要遍历后⾯的链表，因此JDK 优化了⼀版，链表的⻓度超过阈值的时候，会变成红⿊树，红⿊树有⼀定的规则去平衡⼦树，避免退化成为链表，影响查询效率。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046514288" alt="" title="" loading="lazy"/></p><p>但是你肯定会想到，如果数组太⼩了，放了⽐较多数据了，怎么办？再放冲突的概率会越来越⾼，其实这个时候会触发⼀个扩容机制，将数组扩容成为 2 倍⼤⼩，重新hash 以前的数据，哈希到不同的数组中。</p><p>hash 表的优点是查找速度快，但是如果不断触发重新 hash , 响应速度也会变慢。同时，如果希望范围查询， hash 表不是好的选择。</p><p>拉链法的装载因子为n/m（n为输入域的关键字个数，m为位桶的数目）</p><h3>开放地址法</h3><p>所谓开放地址法就是发生冲突时在散列表（也就是数组里）里去寻找合适的位置存取对应的元素，就是所有输入的元素全部存放在哈希表里。也就是说，位桶的实现是不需要任何的链表来实现的，换句话说，也就是这个哈希表的装载因子不会超过1。</p><p>它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。</p><p>探查序列的方法:</p><ul><li>线性探查</li><li>平方探测</li><li>伪随机探测</li></ul><h4>线性探查</h4><p>di =1，2，3，…，m-1；这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045396160" alt="" title="" loading="lazy"/></p><p><strong>（使用例子：<a href="https://link.segmentfault.com/?enc=r%2FRN%2BEInVGitgul47%2BfdIQ%3D%3D.jRQEHRI4x9f%2BaXR4k2k1AzLhgVy%2FB7dkt5gY9EIAogm4w5%2BF9NRK9NbDybMI4eI%2Bzvevdle53J5Q22xYa3tVWw%3D%3D" rel="nofollow" target="_blank">ThreadLocal</a>里面的ThreadLocalMap中的set方法）</strong></p><pre><code class="java">private void set(ThreadLocal&lt;?&gt; key, Object value) {

    // We don't use a fast path as with get() because it is at
    // least as common to use set() to create new entries as
    // it is to replace existing ones, in which case, a fast
    // path would fail more often than not.

    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode &amp; (len-1);

    //线性探测的关键代码
    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&lt;?&gt; k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
        rehash();
}</code></pre><p>但是这样会有一个问题，就是随着键值对的增多，会在哈希表里形成连续的键值对。当插入元素时，任意一个落入这个区间的元素都要一直探测到区间末尾，并且最终将自己加入到这个区间内。这样就会导致落在区间内的关键字Key要进行多次探测才能找到合适的位置，并且还会继续增大这个连续区间，使探测时间变得更长，这样的现象被称为“一次聚集（primary clustering）”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045396161" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045396162" alt="" title="" loading="lazy"/></p><h4>平方探测</h4><p>在探测时不一个挨着一个地向后探测，可以跳跃着探测，这样就避免了一次聚集。</p><p>di=12，-12，22，-22，…，k2，-k2；这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。虽然平方探测法解决了线性探测法的一次聚集，但是它也有一个小问题，就是关键字key散列到同一位置后探测时的路径是一样的。这样对于许多落在同一位置的关键字而言，越是后面插入的元素，探测的时间就越长。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045396163" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045396164" alt="" title="" loading="lazy"/></p><p>这种现象被称作“二次聚集(secondary clustering)”,其实这个在线性探测法里也有。</p><h4>伪随机探测</h4><p>di=伪随机数序列；具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），生成一个位随机序列，并给定一个随机数做起点，每次去加上这个伪随机数++就可以了。</p><h3>再散列法</h3><p>再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置</p><p>缺点：每次冲突都要重新散列，计算时间增加。一般不用这种方式</p>]]></description></item>  </channel></rss>