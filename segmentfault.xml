<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[每个产品经理都要知道的 6 个软技能 俞]]></title>    <link>https://segmentfault.com/a/1190000047400439</link>    <guid>https://segmentfault.com/a/1190000047400439</guid>    <pubDate>2025-11-14 18:06:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><em>本文总结了产品经理在工作中需要具备的六项最重要的软技能：沟通、非权威型领导力、说服、优先级排序、授权、问题解决能力，并提到了若干其他重要的软技能。原文：<a href="https://link.segmentfault.com/?enc=8w56shYAZY9bJKczOmw0oA%3D%3D.JLbVlmk3knG2nS3EsTS7%2BauAdpX%2FGTPhbqAWi9BmvtauCVZp4kf6R2p5BEsGQAaEJeIvwTH2oNviDICQrVUEe59w90%2BUM6S9Yq1nGGGsmqxCpUJd93qaHQ1iZfvctR32" rel="nofollow" title="6 Soft Skills Every Product Manager Needs" target="_blank">6 Soft Skills Every Product Manager Needs</a></em></blockquote><p>产品经理的最终职责是推出对目标市场真正有用的产品。要实现这一目标，需要多样化的技能组合，将产品经理的软技能和硬技能结合起来。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400441" alt="" title=""/></p><p>你可能存在这样的误解，即认为硬技能比其他任何技能都更为重要。没错，商业知识、数据分析以及其他可学习的技能都是有用的。但是，产品经理所具备的软技能才能帮你发展职业生涯、领导团队，并在组织中获得一定的影响力，从而被视为产品或市场方面的专家。</p><p>如果 PM 想要获得他人的认可和尊重，那么首先就应该在已有的工程和技术技能基础上，提升自身的软技能。</p><h2>为什么软技能在产品管理中如此重要？</h2><p>当你刚开始担任产品经理时，会更多专注于执行与产品相关的任务（基层执行和产品上线），包括完成质量检查、与市场营销部门合作、进行 A/B 测试、收集客户数据、进行市场调研等等。</p><p>当你晋升为高级产品经理或产品负责人时，工作重点将从执行转向影响力方面，会与同事建立更紧密的工作关系。尽管执行仍是职责的一部分，但你正朝着领导角色、团队成员的职业发展以及说服不同团队支持你所做出的决策方面迈出更多步伐。</p><p>当你获得更高职位，并晋升为集团项目经理、产品负责人或首席产品官等领导岗位时，与人建立关系以及与他人合作就变得愈发重要。在领导层中担任 PM 一职的人员，需要能够领导团队、赋予他人权力、做出重要的产品决策，并在整个组织内清晰的进行沟通，这些任务都需要提升软技能。</p><h2>最重要的产品经理软技能</h2><p>我们总结了每位产品经理都应掌握的六项最重要的软技能，这些关键的产品经理软技能将帮助你成为受团队尊重的顶尖领导者：</p><h5>1. 沟通</h5><p>有效沟通是所有优秀产品经理的基石，因为没有沟通就无法完成任何工作。</p><p>一款产品要想从一个想法转变为完整的实现，需要有效沟通作为支撑。作为产品经理，沟通将成为每一天每一刻的工作内容。从与高层管理人员沟通，到与用户沟通，PM 要负责向合适的群体传达正确的信息。</p><p>在向直接或间接参与产品开发过程的其他人交流或传达想法时，沟通也至关重要。例如，PM 需要将工程师提出的复杂想法以用户能够理解并产生共鸣的方式呈现出来，还需要知道如何与利益相关者进行沟通，并清晰的将他们的想法传达给产品团队。</p><p>任何沟通链条的中断都会导致产生出完全不符合预期的产品。而有了有效沟通，PM 就能倾听与他们互动的人员的意见，并以清晰的方式将这些想法传达给其他人。总的来说，PM 是所有人之间的纽带，同时也是信息的传递者。</p><p><strong>如何提升沟通能力</strong></p><p>关于沟通，首先要强调的一点是，必须先倾听。因为人们希望知道自己的话语被听到了，尤其是在产品管理方面。当你有目的、有意识的倾听时，人们就会知道他们的想法正在被考虑，即便你并不能百分百表示赞同。</p><h5>2. 非权威型领导</h5><p>要组建一支高效的团队，产品经理需要在产品线的每个部门赢得尊重和信任。信任和尊重能够帮助 PM 在做出和论证产品决策时发挥其影响力。</p><p>与外界可能的看法相反，PM 的权力其实很小，他们需要充分利用现有资源来开展工作。在产品团队中，没有成员直接向 PM 汇报工作，工程师直接向工程经理汇报，设计师也是如此，直接向设计经理汇报。</p><p>PM 所做的就是不凭借权威来领导，而是凭借影响力来引领。PM 会说服所有人确定最佳决策是什么，并同时提供证据来支持这一决策。如果 PM 无法为某一举措提供证据，就会导致人们对其领导能力和决策的合法性产生怀疑。</p><p>这种领导方式也可以被称为非权威型领导方式，这意味着交流并非是下达命令，而是一种建议。当 PM 们与团队成员进行这种交流，而不是明确指示他们以某种方式行事，通常会带来员工工作效率的大幅提升以及更高的认同感。</p><p>这种生产力的提升源于领导者也是团队的一员。领导意味着合作，意味着要与团队并肩作战，参与到产品开发的每一个环节中。这是你能够了解每个角色的实际情况，并掌握与每个人合作的最佳方式的唯一途径。</p><p><strong>如何在工作中提升影响力？</strong></p><p>首先，必须与组织目标保持一致。一旦 PM 理解了目标的意义所在，那么支持和倡导这个目标就会变得容易得多。高层管理人员也会因此而对你表示赞赏。</p><p>对于你的团队，必须支持他们所做的工作，尤其是在促进他们职业发展方面。当他们就公司内部的运作方式提出意见时，要作为他们的代言人向高层管理人员汇报。</p><h5>3. 说服</h5><p>说服他人就是要寻求双方的共同点，做出妥协，并帮助对方从而让对方也能帮助你。换句话说，就是“我帮你一下，你也得帮我一下”。</p><p>将一款产品推向用户的过程可能会十分漫长，其间会遇到无数阻碍。PM 的软技能中需要包含说服力，以便能够克服或绕过这些障碍。</p><p>说服工作不仅仅意味着与零售商达成一项重大商业交易，让他们销售你的产品。还意味着要敢于面对可能对基层员工要求过高的高层管理人员。这意味着当基层员工不理解时，要为高层管理人员发声，寻找中间立场，成为理性的代表，这应该是任何 PM 的首要任务。</p><p>然而，需要记住的是，掌握这项技能需要一定时间，还需要拥有丰富的经验才能培养出这种能力。不过，任何擅长说服的 PM 都能成功推出出色的产品。</p><p><strong>增强说服力</strong></p><p>关于说服力，最重要的一点在于说话者的可信度。就我个人而言，一旦在团队和组织内部建立起可信度，那么说服他们去做某事就将毫无困难。</p><p>还必须记住的另一个重要方面是“互惠原则”。当队友或组织中的任何成员提供了帮助时，你也必须以某种方式回报这份恩情。如果不是以提供帮助的形式，那么也必须分享你所知晓的机会。</p><h5>4. 优先级</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400442" alt="" title="" loading="lazy"/></p><p>如果 PM 不懂得如何合理安排与项目计划和待办列表相关的事务，那么很快就会发现工作进度停滞不前 —— 而在时间紧迫的情况下，这种情况是绝对不能发生的。</p><p>要使成功推出一款产品，需要完成的任务数量可能极其庞大。在此情况下，产品管理意味着时间管理，即要对任务进行优先级排序，以确保都能按时完成。这不仅需要你按时完成所有任务，还需要工程师和设计师也遵循同样的时间安排来工作。</p><p>你还会发现，各种想法会从各个方向涌来。其中一些想法可能看起来像是某个问题的完美解决方案，或者是某个产品的重要改进之处。但确定优先次序意味着要明白什么样的东西是完美产品所不可或缺的，而不是那些无关紧要的设计元素。</p><p>关于优先级排序，应该了解的最重要一点是，往往意味着需要学会拒绝。可能是拒绝那些与愿景不符的想法，也可能是拒绝自己某些不想做出牺牲的事项。学会说“不”最终会赋予你力量并带来成效。</p><p>采用诸如看板或价值与复杂性四象限（Value vs Complexity Quadrants）等特定的优先级排序框架，有助于 PM 真正优化其时间安排。这些框架设计简单，旨在为每个工作场所带来成功。</p><h5>5. 授权</h5><p>作为 PM，往往会觉得自己需要完成每一项任务。虽然完成工作是你的职责所在，但并非所有任务都得由你独自完成。放弃这种控制权会很困难，尤其是当你肩负着带领团队并交付出色产品的巨大压力时。不过，将任务授权给他人会让团队变得高效且富有成效。</p><p>授权意味着需要了解团队中每个人的优势所在。这样一来，就能确定哪些任务适合哪个团队成员。这会营造出高效的工作环境，让每个人都能发挥自己的最佳水平。没有 PM 能做到面面俱到，但最优秀的 PM 会清楚知道谁最适合完成特定的任务。</p><p>事实上，授权能让领导人的工作变得极其简单。一旦确定了应该把哪些任务分配给哪些人的原则，那么这些任务就会从你的工作清单中移除。这样一来，就减轻了自己的负担，并且知道这项工作正由有能力完成最佳成果的人来负责。而你只需要学会放手。</p><h5>6. 问题解决与创造力</h5><p>问题往往是 PM 日常工作中最为关键的部分。因此，我们将问题解决能力和创造力视为 PM 必备的软技能之一。</p><p>当出现问题时，高层管理人员会期望 PM 去解决这些问题，而那些在 PM 手下工作的人员则会向 PM 寻求答案。并非每一个问题的解决方案都一目了然，要解决出现的所有问题，需要有大量创造力。</p><p>解决问题意味着要从多个不同角度去审视问题。通过综合考虑多种观点，PM 能够从不同角度看到解决某个问题的不同方法。这种共情和换位思考的方式已经解决了许多重大全球性问题，而且肯定也能解决生产中的小问题。</p><h2>其他产品经理应具备的软技能</h2><h5>保持团队热情的能力</h5><p>没错，保持团队积极性也是 PM 的另一项默默的职责。当团队成员积极性高涨时，工作效率也很可能会提高。但是，PM 如何让团队成员保持积极性呢？并不需要是一次性的大型举措，而是在日常的小时刻、一天天的积累中进行。例如，在产品团队内部，可以尝试：</p><ul><li>进行坦诚交流</li><li>为队友设定目标</li><li>认可每位成员的贡献</li><li>成为团队代言人</li><li>促进团队合作</li></ul><h5>同理心</h5><p>同理心指的是理解并分享他人感受的能力。在产品管理领域，这种技能会非常有用，因为同理心能让 PM 更轻松的与他人合作。</p><p>具备同理心能够帮你理解客户、产品团队以及利益相关者。当你理解了产品开发过程中所有参与者的观点时，就能在决策中找到平衡点，并解释为何选择这种平衡方案。</p><p><strong>培养同理心的技巧</strong></p><ul><li>培养好奇心（尤其是对与你共事的人保持好奇心）</li><li>走出舒适区</li><li>以建设性的方式接受反馈</li><li>尝试设身处地为他人着想</li><li>参加公司组织的社区活动</li></ul><h5>主动作为</h5><p>主动作为指的是独立评估并采取行动的能力。PM 一天大部分时间都会被会议占据，可以说，当 PM 主动发起并引导会议（即使是偶然的或未计划的）时，他/她就是在主动作为。</p><p>PM 还需要审查诸如健康指标或竞争对手评估之类的各种报告，一位优秀的 PM 会主动去做这些事情，而且还会做得比这更多，不会因为有人要求才去做。</p><p><strong>作为 PM，为什么要主动作为呢？</strong></p><p>简单来说，主动作为就是让公司看到你的价值所在。当你主动作为时，不仅会完成本职工作，还会承担一些并非作为 PM 所必须承担的任务。这可能看起来像是额外的工作量，但你必须转变思维模式，因为当你主动作为时，就是在为自己创造成长机会。</p><h5>灵活/适应性强</h5><p>许多经验丰富的 PM 都会告诉你，这类工作非常具有动态性。这意味着情况可能会非常多变、出乎意料且节奏很快。即便现在，如果你不能明确认识到 PM 每天其实并没有严格固定的日程安排，而且任何事情都有可能发生，那么可能会发现自己总是处于极度紧张的状态，以至于无法正常完成工作。</p><p>杰出的 PM 懂得如何应对各种情况。他们早已预料到会有意想不到的情况出现，知道如何处理每一个情况，尽管有些情况可能颇具挑战性，但最出色的 PM 总会挺身而出，承担起责任。</p><p><strong>如何提高适应能力和灵活性</strong></p><ol><li>改变思维模式</li></ol><p>当处境发生变化时，必须接受自己也应该随之改变。摒弃那种一味按原计划行事的心态，要学会灵活应对，欣然接受变化。</p><ol start="2"><li>边学边做</li></ol><p>培养自己具备适应能力的一种方法就是不断学习。要乐于学习新技术、从糟糕的状况中汲取教训、关注市场最新趋势等等。</p><ol start="3"><li>鼓励他人保持开放的心态</li></ol><p>作为 PM，还必须帮助他人培养开放的心态和适应能力。在开发产品的过程中，每个人都会需要这种技能，所以不妨鼓励并教导他人如何适应不断变化的环境，尽可能给予支持。</p><h2>总结</h2><p>作为产品经理，依靠硬技能可能是最容易做到的事情。你可以是一位精通产品管理技术细节的产品经理，但实际上，最成功的产品经理会将硬技能与软技能相结合，以构建高效且富有成效的体系。</p><p>当硬技能无法解决某个问题时，软技能就会发挥作用。而且在你从事工作中的不同方面时，这两种技能会协同工作，相辅相成。</p><p>最终，正是技能的综合运用，造就了品质更高的产品，并且拥有更广泛的用户群体。沟通、非权威型领导、谈判、优先级排序、问题解决等等，都将成为 PM 工具包中的完美补充。</p><p>要满怀自信的坚信自己已经具备了所需能力。成为最核心且表现卓越的产品经理这一目标就在眼前，你也清楚自己需要做些什么。走出去，在日常工作中运用这些 PM 所需的软技能，然后会看到一切都会变得越来越好。</p><h2>FAQ</h2><h5>产品经理需要具备哪四项关键技能？</h5><p>产品经理最核心的四项技能是同理心、沟通能力、倾听能力和组织能力。当然，要做好这份工作还需要其他技能，但上述这四项必不可少，是 PM 应具备的最低要求。</p><h5>成为一名产品经理需要具备哪些技能？</h5><p>作为 PM，主要会与人打交道。从这个角度来看，单一技能是不够的。而所具有的人际交往能力的综合表现，才会在与其他团队、客户和利益相关者打交道时发挥作用。</p><h5>作为产品经理，最出色的三项特质是什么？</h5><p>要胜任产品经理这一职位，必须具备战略思维能力，对产品充满热情，并致力于为用户提供卓越的体验。然而，对于每位 PM 而言，所具备的特质可能会有所不同，但这里列出的三项特质是 PM 能够以此为基础发展成为优秀产品管理者的基石。</p><h5>产品经理是否需要具备编程技能？</h5><p>不，编程技能并非 PM 的必备技能，但这种技能肯定会派上用场，尤其是当 PM 负责技术产品，并且需要与工程团队进行有效沟通和协作时。不过，这并非是必须具备的先决条件。</p><h5>产品管理是一种软技能吗？</h5><p>产品管理更像是硬技能和软技能的结合体。比如，具备编写技术规格说明或使用产品管理工具的硬技能，在工作中可能会有用，但这只是其中一方面。PM 还需要处理产品管理中的人性方面的问题。这就是软技能发挥作用的地方，因为参加会议、与不同部门团队沟通以及向客户了解他们的需求都是常态。</p><hr/><blockquote>你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。为了方便大家以后能第一时间看到文章，请朋友们关注公众号"DeepNoMind"，并设个星标吧，如果能一键三连(转发、点赞、在看)，则能给我带来更多的支持和动力，激励我持续写下去，和大家共同成长进步！</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=hTmBjWVTHh%2FH7%2FWN2D38vQ%3D%3D.fUCxMKgLzi45%2FJB2mMZBo9s%2Bw0WhJwxSmjsCAWuKWBU%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[使用 C# 导出 Excel 数据并保存]]></title>    <link>https://segmentfault.com/a/1190000047400472</link>    <guid>https://segmentfault.com/a/1190000047400472</guid>    <pubDate>2025-11-14 18:05:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在现代企业信息化管理中，Excel 已经成为最常用的数据存储和分析工具。从员工信息表、销售数据报表到财务分析表，几乎所有部门都离不开 Excel。然而，在实际业务中，我们往往需要将系统中的数据动态生成 Excel 文件，而不是手动录入。手动操作不仅效率低，而且容易出错，对于需要批量生成报表、进行定期统计或对外发布数据的场景尤其不适用。</p><p>为了解决这一问题，C# 开发者可以借助 <strong><a href="https://link.segmentfault.com/?enc=gZPlS5ikQ%2BFrHUdPRfHE1w%3D%3D.udeoSKuoZOTBTSSvCoMaeh1Lbjq%2Bpp9vX8Wj7W2UClSKfxRWxmZoxuiJc6EpcUKdmN3sJHg1kUgtS1jNaEB%2BTA%3D%3D" rel="nofollow" target="_blank">Free Spire.XLS for .NET</a></strong>，通过代码快速创建 Excel 文件、填充数据、应用样式，并将文件导出为多种格式，包括 XLSX、CSV、PDF，甚至直接保存到内存流以便网络传输。本文将通过一个完整示例，详细演示如何在 C# 中实现 Excel 数据导出，让你的报表生成工作既高效又专业。</p><h2>1. 安装 Spire.XLS</h2><p>在开始编码前，需要通过 NuGet 安装 Spire.XLS：</p><pre><code class="bash">Install-Package FreeSpire.XLS</code></pre><p>安装完成后，即可在 C# 项目中引用命名空间：</p><pre><code class="csharp">using Spire.Xls;
using System.Data;
using System.IO;</code></pre><hr/><h2>2. 创建工作簿和填充数据</h2><p>下面示例演示如何创建一个 Excel 文件，并将员工信息填充到工作表中：</p><pre><code class="csharp">// 创建工作簿
Workbook workbook = new Workbook();
Worksheet sheet = workbook.Worksheets[0];
sheet.Name = "EmployeeData";

// 创建 DataTable 并添加列
DataTable table = new DataTable();
table.Columns.Add("EmployeeID");
table.Columns.Add("FullName");
table.Columns.Add("Department");
table.Columns.Add("HireDate");
table.Columns.Add("Salary");

// 添加示例数据
table.Rows.Add("E101", "John Miller", "Finance", "2020-02-15", "7500");
table.Rows.Add("E102", "Sarah Brown", "HR", "2019-07-10", "6800");
table.Rows.Add("E103", "Michael Davis", "IT", "2021-01-22", "8200");
table.Rows.Add("E104", "Laura Wilson", "Marketing", "2018-11-18", "7100");
table.Rows.Add("E105", "Daniel Lee", "Sales", "2022-06-12", "6900");

// 将 DataTable 插入工作表，从第一行第一列开始，并保留列名
sheet.InsertDataTable(table, true, 1, 1);

// 应用内置样式
sheet.AllocatedRange.Rows[0].BuiltInStyle = BuiltInStyles.Heading2; // 标题行
for (int i = 1; i &lt; sheet.AllocatedRange.Rows.Count(); i++)
{
    sheet.AllocatedRange.Rows[i].BuiltInStyle = BuiltInStyles.Accent2; // 数据行
}

// 自动调整列宽和行高
sheet.AllocatedRange.AutoFitColumns();
sheet.AllocatedRange.AutoFitRows();</code></pre><p><strong>说明</strong>：</p><ul><li><code>InsertDataTable</code> 可以直接将 <code>DataTable</code> 内容写入工作表，同时支持保留列名。</li><li>内置样式（<code>BuiltInStyles</code>）可以快速美化表格，例如标题行加粗、数据行配色。</li><li><code>AutoFitColumns</code> 和 <code>AutoFitRows</code> 可自动调整列宽和行高，使表格美观。</li></ul><hr/><h2>3. 保存为不同格式</h2><p>Spire.XLS 支持多种保存格式，常见的包括：</p><ul><li><strong>XLS/XLSX</strong>：传统 Excel 文件</li><li><strong>CSV</strong>：逗号分隔文本文件</li><li><strong>PDF</strong>：用于打印或发布</li><li><strong>HTML</strong> / <strong>SVG</strong>：网页或矢量图格式</li><li><strong>XLSB/XLSM</strong>：二进制或带宏 Excel 文件</li><li><strong>MemoryStream</strong>：将文件写入内存流，用于网络传输或其他二次处理</li></ul><p>示例代码：</p><pre><code class="csharp">// 保存为 Excel 2016 格式
workbook.SaveToFile("EmployeeData.xlsx", FileFormat.Version2016);

// 保存为 CSV
workbook.SaveToFile("EmployeeData.csv", FileFormat.CSV);

// 保存为 PDF
workbook.SaveToFile("EmployeeData.pdf", FileFormat.PDF);

// 保存到 MemoryStream
using (MemoryStream ms = new MemoryStream())
{
    workbook.SaveToStream(ms, FileFormat.Version2016);
    // 这里可以将 ms 写入数据库、发送 HTTP 响应等
}</code></pre><p><strong>说明</strong>：</p><ul><li><code>FileFormat</code> 枚举支持多达 25 种格式，例如 <code>Xlsb2007</code>、<code>ODS</code>、<code>HTML</code>、<code>Markdown</code> 等。</li><li>MemoryStream 保存方式适合 Web 应用场景，可以直接将文件返回给客户端而不写入磁盘。</li></ul><hr/><h2>4. 效果展示</h2><p>生成的 Excel 文件：</p><p><img width="693" height="275" referrerpolicy="no-referrer" src="/img/bVdm3bT" alt="C#保存Excel" title="C#保存Excel"/></p><p>表头加粗，数据行有配色，并且列宽自适应。</p><hr/><h2>5. 扩展说明</h2><ol><li><strong>为什么要使用代码导出？</strong><br/>对于批量生成报表或动态数据，手动操作效率低且易出错，使用代码生成可以自动化、可复用。</li><li><p><strong>MemoryStream 场景</strong></p><ul><li>Web API 返回文件下载</li><li>将 Excel 存入数据库或云存储</li><li>在内存中生成并进一步处理，例如加密或压缩</li></ul></li><li><strong>多格式支持</strong><br/>Spire.XLS 的 <code>FileFormat</code> 枚举几乎覆盖了主流的 Excel、PDF、网页、模板等格式，可以满足多种业务需求。</li></ol><hr/><h2>6. 总结</h2><p>本文演示了如何使用 <strong>Spire.XLS for .NET</strong>：</p><ul><li>在 C# 中创建 Excel 文件并填充数据</li><li>应用内置样式和自动调整行列</li><li>将文件保存为多种格式（XLSX、CSV、PDF、HTML 等）</li><li>使用 MemoryStream 保存用于网络传输或二次处理</li></ul><p>通过掌握 <code>Workbook</code>、<code>Worksheet</code>、<code>InsertDataTable</code> 和 <code>SaveToFile/SaveToStream</code>，你可以轻松实现 Excel 数据导出和格式转换，提升企业应用开发效率。</p>]]></description></item><item>    <title><![CDATA[Rust性能调优：从劝退到真香 烦恼的沙]]></title>    <link>https://segmentfault.com/a/1190000047400483</link>    <guid>https://segmentfault.com/a/1190000047400483</guid>    <pubDate>2025-11-14 18:05:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>地球人都说Rust快，安全，并发牛。但有时候我们写出来的代码，跑起来却像踩了脚刹车。这是为啥？其实，Rust给你的法拉利，你可能只当成了买菜车在开。性能这玩意儿，不是玄学，而是科学（和一点点小技巧）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400485" alt="" title=""/></p><p>BUT，在开始之前，谁也不想在配置环境这种破事上浪费生命，对吧？装Rust、装PostgreSQL、装Redis……一套下来，半天没了。这里就要用 ServBay，这是开发者的福音，一键就能把<a href="https://link.segmentfault.com/?enc=fibNiS76DfbCiDMY1AUx%2BA%3D%3D.OYRbqk91llhZM5tXpBJwQgmnA9nV7gF4sbJGWaO64K1QzOOAw0if8wtwQvOQjqeF" rel="nofollow" target="_blank">Rust开发环境</a>给搞定了，连带各种数据库都安排得明明白白。哥哥你放心飞，ServBay永相随。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400486" alt="" title="" loading="lazy"/></p><p>好了，环境搞定，系好安全带，我们发车！</p><h4><strong>技巧一：函数参数别老用</strong><code>String</code>，<code>&amp;str</code><strong>才是万金油</strong></h4><p>这可能是新手最容易犯的错误。看到字符串，下意识就用<code>String</code>。</p><p><strong>别这么干：</strong></p><pre><code class="rust">// 每次调用这个函数，都可能发生一次内存拷贝，把所有权交出去
fn welcome_user(name: String) {
    println!("Hello, {}! 欢迎来到Rust的世界！", name);
}

fn main() {
    let user_name = "CodeWizard".to_string();
    // 为了不失去 user_name 的所有权，你不得不克隆它
    welcome_user(user_name.clone()); 
    println!("你的用户名是: {}", user_name); // 如果不clone，这里就编译不过了
}</code></pre><p><strong>试试这个：</strong></p><pre><code class="rust">// 使用 &amp;str，我们只是借用了数据，不涉及所有权转移
fn welcome_user(name: &amp;str) {
    println!("Hello, {}! 欢迎来到Rust的世界！", name);
}

fn main() {
    let user_name = "CodeWizard".to_string();
    welcome_user(&amp;user_name); // 轻松借用
    welcome_user("Newbie"); // 字符串字面量也完全没问题
    println!("你的用户名是: {}", user_name); // user_name 还在，啥事没有
}</code></pre><p><strong>为啥呢？</strong> <code>String</code>是动态的、拥有所有权的字符串，把它作为参数传递，要么所有权被移走（原来的变量不能再用），要么你就得<code>clone()</code>一份，这可是实打实的内存分配和拷贝，开销不小。而<code>&amp;str</code>（字符串切片）只是一个“引用”，一个指向数据某部分的“指针+长度”组合，传递它就跟递张名片一样轻巧，不产生任何数据拷贝。</p><h4><strong>技巧二：数据共享？别傻傻地</strong><code>clone()</code>，请用<strong><code>Arc</code></strong></h4><p>当多个线程或多个数据结构需要访问同一份大数据时，比如一个共享的配置信息，无脑<code>clone()</code>会付出沉重的代价。</p><p><strong>别这么干：</strong></p><pre><code class="rust">use std::thread;

#[derive(Clone)] // 为了能在线程间传递，不得不加上Clone
struct AppConfig {
    api_key: String,
    timeout: u32,
}

fn main() {
    let config = AppConfig {
        api_key: "a_very_long_and_secret_api_key".to_string(),
        timeout: 5000,
    };

    let mut handles = vec![];
    for i in 0..5 {
        let thread_config = config.clone(); // 每次都深度拷贝整个结构体
        handles.push(thread::spawn(move || {
            println!("线程 {} 使用的 API Key 是: {}", i, thread_config.api_key);
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}</code></pre><p><strong>试试这个：</strong></p><pre><code class="rust">use std::sync::Arc;
use std::thread;

struct AppConfig {
    api_key: String,
    timeout: u32,
}

fn main() {
    // Arc是“原子引用计数”智能指针，可以安全地在线程间共享数据
    let config = Arc::new(AppConfig {
        api_key: "a_very_long_and_secret_api_key".to_string(),
        timeout: 5000,
    });

    let mut handles = vec![];
    for i in 0..5 {
        let thread_config = Arc::clone(&amp;config); // 这不是数据拷贝！只是增加引用计数，非常快
        handles.push(thread::spawn(move || {
            println!("线程 {} 使用的 API Key 是: {}", i, thread_config.api_key);
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}</code></pre><p><strong>为啥呢？</strong> <code>Arc::clone()</code>做的不是复制数据本体，它只是把一个记录“有多少人正在引用这份数据”的计数器加一。这个操作非常轻量，几乎没有成本。只有当最后一个引用消失时，数据才会被真正清理。面对多线程共享只读数据的场景，<code>Arc</code>就是不二之选。</p><h4><strong>技巧三：</strong> <strong>迭代器</strong> <strong>大法好，告别C风格的索引循环</strong></h4><p>还在用<code>for i in 0..vec.len()</code>？那可就错过了Rust编译器给准备的免费午餐。</p><p><strong>别这么干：</strong></p><pre><code class="rust">fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6];
    let mut sum_of_squares = 0;
    for i in 0..numbers.len() {
        // 每次访问 numbers[i]，编译器都会插入一个边界检查，以防你越界
        if numbers[i] % 2 == 0 {
            sum_of_squares += numbers[i] * numbers[i];
        }
    }
    println!("偶数的平方和是: {}", sum_of_squares);
}</code></pre><p><strong>试试这个：</strong></p><pre><code class="rust">fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6];
    // 迭代器是惰性的，并且链式调用会被编译器优化成一个高效的循环
    let sum_of_squares: i32 = numbers
        .iter()                // 创建一个迭代器
        .filter(|&amp;&amp;n| n % 2 == 0) // 筛选出偶数
        .map(|&amp;n| n * n)       // 计算平方
        .sum();                // 求和

    println!("偶数的平方和是: {}", sum_of_squares);
}</code></pre><p><strong>为啥呢？</strong> Rust的迭代器是零成本抽象。写的链式调用，在编译后会被融合成一个手写的、极其高效的循环，而且编译器在编译时就能确定访问不会越界，从而去掉了运行时的边界检查。既安全，又高效，代码还更清晰，何乐而不为？</p><h4><strong>技巧四：</strong> <strong>泛型</strong> <strong>优于动态分发（</strong> <code>Box&lt;dyn Trait&gt;</code> <strong>）</strong></h4><p>当代码需要处理多种不同类型，但它们都实现了同一个<code>Trait</code>时，这时候会有两种选择：静态分发（泛型）和动态分发（Trait对象）。在性能敏感的路径上，请选择前者。</p><p><strong>别这么干（动态分发）：</strong></p><pre><code class="rust">trait Sound {
    fn make_sound(&amp;self) -&gt; String;
}

struct Dog;
impl Sound for Dog {
    fn make_sound(&amp;self) -&gt; String { "汪汪!".to_string() }
}

struct Cat;
impl Sound for Cat {
    fn make_sound(&amp;self) -&gt; String { "喵~".to_string() }
}

// 使用Box&lt;dyn Trait&gt;，运行时需要通过虚函数表(vtable)查找具体调用哪个方法
fn trigger_sound(animal: Box&lt;dyn Sound&gt;) {
    println!("{}", animal.make_sound());
}

fn main() {
    trigger_sound(Box::new(Dog));
    trigger_sound(Box::new(Cat));
}</code></pre><p><strong>试试这个（静态分发）：</strong></p><pre><code class="rust">trait Sound {
    fn make_sound(&amp;self) -&gt; String;
}

struct Dog;
impl Sound for Dog {
    fn make_sound(&amp;self) -&gt; String { "汪汪!".to_string() }
}

struct Cat;
impl Sound for Cat {
    fn make_sound(&amp;self) -&gt; String { "喵~".to_string() }
}

// 使用泛型，编译器会为每种类型生成一个专门的版本，没有运行时开销
fn trigger_sound&lt;T: Sound&gt;(animal: T) {
    println!("{}", animal.make_sound());
}

fn main() {
    trigger_sound(Dog);
    trigger_sound(Cat);
}</code></pre><p><strong>为啥呢？</strong> 动态分发<code>Box&lt;dyn Trait&gt;</code>需要在运行时查找一个叫做“虚表”的东西来确定到底该调用哪个具体实现的方法，这会带来额外的指针间接引用和查找开销。而泛型，编译器在编译时就知道要用<code>Dog</code>还是<code>Cat</code>，它会直接生成两个不同版本的<code>trigger_sound</code>函数，一个给<code>Dog</code>，一个给<code>Cat</code>，调用时直接就是函数地址，没有任何运行时开销。这种技术也叫单态化。</p><h4><strong>技巧五：给小函数戴上</strong><code>#[inline]</code><strong>的帽子</strong></h4><p>对于那些又小又被频繁调用的函数，函数调用本身的开销（比如建立栈帧）可能比函数体执行的开销还大。</p><pre><code class="rust">// 这是一个非常小的辅助函数
#[inline]
fn is_positive(n: i32) -&gt; bool {
    n &gt; 0
}

fn count_positives(numbers: &amp;[i32]) -&gt; usize {
    numbers.iter().filter(|&amp;&amp;n| is_positive(n)).count()
}

fn main() {
    let data = vec![-1, 1, -2, 2, 3];
    println!("正数的个数: {}", count_positives(&amp;data));
}</code></pre><p><strong>为啥呢？</strong> <code>#[inline]</code>像是一个给编译器的建议，告诉它：“哥们，把这个函数的代码直接复制粘贴到调用它的地方吧，别走函数调用流程了。” 这样就消除了函数调用的开销。当然，别滥用，给一个巨大的函数加上<code>#[inline]</code>只会让最终程序体积膨胀，得不偿失。</p><h4><strong>技巧六：栈上分配永远比堆上快</strong></h4><p>能放在栈上的数据，就别往堆上扔。栈分配就是移动一下栈指针，快如闪电；堆分配则需要去仓库（堆）里找一块合适的空地，要慢得多。</p><p><strong>别这么干：</strong></p><pre><code class="rust">struct Point {
    x: f64,
    y: f64,
}

fn main() {
    // Box::new会把数据分配在堆上
    let p1 = Box::new(Point { x: 1.0, y: 2.0 });
    println!("堆上的点: ({}, {})", p1.x, p1.y);
}</code></pre><p><strong>试试这个：</strong></p><pre><code class="rust">struct Point {
    x: f64,
    y: f64,
}

fn main() {
    // 默认情况下，变量是分配在栈上的
    let p1 = Point { x: 1.0, y: 2.0 };
    println!("栈上的点: ({}, {})", p1.x, p1.y);
}</code></pre><p>这个技巧看起来非常简单，但其核心是当不需要在函数返回后数据仍然存活，或者数据大小在编译期就确定时，优先使用栈。<code>Box</code>、<code>String</code>、<code>Vec</code>这类都是在堆上分配的，使用时要心里有数。</p><h4><strong>技巧七：</strong> <code>MaybeUninit</code> <strong>：大</strong> <strong>内存</strong> <strong>初始化时开挂了</strong></h4><p>如果需要一块非常大的内存，并且确定马上会用自己的数据把它填满时，让Rust先用0初始化一遍的话，纯属浪费CPU。</p><p>这是一个高级技巧，需要使用<code>unsafe</code>，新手慎用！</p><pre><code class="rust">use std::mem::MaybeUninit;

const BUFFER_SIZE: usize = 1024 * 1024; // 1MB

fn main() {
    // 创建一个Vec，但告诉Rust：“先别初始化这块内存，我待会儿自己弄”
    let mut buffer: Vec&lt;MaybeUninit&lt;u8&gt;&gt; = Vec::with_capacity(BUFFER_SIZE);

    // 假设我们从某个地方读取数据填满了这块缓冲区
    // 这里我们用一个简单的循环模拟
    // 注意：在真实场景中，你会用类似 read_exact 的方法填充
    unsafe {
        // 伪装成已经初始化了，因为我们确信下面的代码会完成初始化
        buffer.set_len(BUFFER_SIZE); 
        for i in 0..BUFFER_SIZE {
            // get_mut_unchecked是`unsafe`的，但我们知道索引是合法的
            *buffer.get_mut_unchecked(i) = MaybeUninit::new((i % 256) as u8);
        }
    }

    // 现在，我们确信内存已经完全初始化，可以安全地把它转换成 Vec&lt;u8&gt;
    let buffer: Vec&lt;u8&gt; = unsafe {
        // 这步转换是零成本的，因为内存布局完全一样
        std::mem::transmute(buffer)
    };

    println!("缓冲区创建并填充完毕，第一个元素是: {}", buffer[0]);
    println!("最后一个元素是: {}", buffer[BUFFER_SIZE - 1]);
}</code></pre><p><strong>为啥呢？</strong> <code>Vec::with_capacity</code>只分配内存，不初始化。但如果你接着用<code>resize</code>或者其他安全的方法，它还是会帮你初始化。<code>MaybeUninit</code>允许你跳过这个默认的初始化步骤，直接操作未初始化的内存，对于高性能网络编程、数据解析等场景，能省下可观的时间。但记住，<code>unsafe</code>意味着你得自己对内存安全负责！</p><h3><strong>总结一下</strong></h3><p>Rust性能调优的核心思想无非几点：</p><ul><li><strong>减少</strong> <strong>内存</strong> <strong>分配和拷贝</strong>：多用借用（<code>&amp;</code>），善用智能指针（<code>Arc</code>）。</li><li><strong>让编译器帮你干活</strong>：多用迭代器，多用泛型。</li><li><strong>理解</strong> <strong>内存</strong> <strong>布局</strong>：区分栈和堆，知道什么时候该用谁。</li></ul><p>当然，优化要讲究章法，不要上来就对着贴脸代码开大。先用性能分析工具（比如<code>cargo-flamegraph</code>）找到问题在哪，再对症下药。</p><p>最后，别忘了，一个顺手的开发环境是高效工作的开始。ServBay 搞定繁琐的配置，开发者就能把全部精力投入到编写优雅且高性能的Rust代码中。现在，去把你的买菜车调教成一辆真正的法拉利吧！</p>]]></description></item><item>    <title><![CDATA[Databend SQL 存储过程使用指]]></title>    <link>https://segmentfault.com/a/1190000047400488</link>    <guid>https://segmentfault.com/a/1190000047400488</guid>    <pubDate>2025-11-14 18:04:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、什么是存储过程？</h2><p>存储过程（Stored Procedure）是一组预编译的 SQL 语句集合，它们被保存在数据库中，可以像函数一样被重复调用。想象一下，如果你经常需要执行一系列复杂的数据处理操作，与其每次都手动输入这些 SQL 语句，不如将它们封装成一个存储过程，需要时直接调用即可。</p><h3>存储过程的优势</h3><ol><li><strong>代码复用</strong>：一次编写，多次调用，避免重复代码</li><li><strong>性能优化</strong>：预编译的 SQL 语句执行效率更高</li><li><strong>业务逻辑封装</strong>：将复杂的业务逻辑封装在数据库层</li><li><strong>维护便利</strong>：统一管理和修改业务逻辑</li><li><strong>安全性</strong>：通过权限控制，限制用户对底层数据的直接访问</li></ol><h2>二、第一个存储过程：Hello World</h2><p>让我们从最简单的例子开始。假设我们需要一个简单的加法存储过程：</p><pre><code>CREATE PROCEDURE my_add(a Int32, b Int32)
RETURNS Int32
LANGUAGE SQL
AS $$
BEGIN
    RETURN a + b;
END;
$$;</code></pre><h3>语法解析</h3><p>让我们逐行理解这个存储过程：</p><ul><li><code>CREATE PROCEDURE my_add</code>：创建一个名为 <code>my_add</code> 的存储过程</li><li><code>(a Int32, b Int32)</code>：定义输入参数 <code>a</code> 和 <code>b</code>，类型为 Int32</li><li><code>RETURNS Int32</code>：指定返回值类型为 Int32</li><li><code>LANGUAGE SQL</code>：指定使用 SQL 语言编写（目前 Databend 仅支持 SQL）</li><li><code>AS $$ ... $$</code>：使用美元符号包裹存储过程的主体代码</li><li><code>BEGIN ... END</code>：存储过程主体的开始和结束标记</li><li><code>RETURN a + b</code>：执行计算并返回结果</li></ul><h3>调用存储过程</h3><p>创建后，我们可以这样调用它, 注意参数类型需要显式指定：</p><pre><code>call PROCEDURE my_add(3::Int,4::Int);
----
7</code></pre><h3>SqlScript</h3><p>存储过程中的语法我们称之为 SqlScript， 我们也可以直接使用 <code>execute immediate</code> 来执行 SqlScript 语句。</p><ul><li>执行单个 SQL</li></ul><pre><code>execute immediate 'CREATE TABLE test (id Int32)';</code></pre><ul><li>执行多个 SQL, 用 begin 和 end 包裹</li></ul><pre><code>execute immediate $$
BEGIN
    select 33;
    let s RESULTSET := select number from numbers(100);
    RETURN TABLE(s);
END;
$$;</code></pre><h2>三、进阶：使用变量和流程控制</h2><p>现在让我们学习如何在 SqlScript 中使用变量、条件判断和循环。</p><h3>3.1 变量声明和使用</h3><h4>Scalar 变量</h4><p>在 Databend 中，使用 <code>LET</code> 关键字声明变量：</p><p>语法有：</p><ol><li><code>LET &lt;variable_name&gt; := &lt;value&gt;</code> -- 声明并初始化变量 x</li><li><code>LET &lt;variable_name&gt; [&lt;type&gt;] := &lt;value&gt;</code> -- 声明并初始化变量 x</li><li><code>LET &lt;variable_name&gt; [&lt;type&gt;] DEFAULT &lt;value&gt;</code> -- 声明并初始化变量 x</li><li><code>LET &lt;variable_name&gt; [&lt;type&gt;]</code> -- 声明变量 x, 后续初始化</li></ol><pre><code>execute immediate $$
BEGIN
    LET sum := 0;  -- 声明并初始化变量 sum

    FOR i IN 1 TO 10 DO
        IF i % 2 = 0 THEN
            sum := sum + i;  -- 累加偶数
        END IF;
    END FOR;

    RETURN sum;
END;
$$;</code></pre><p>在这个例子中：</p><ul><li><code>LET sum := 0</code>：声明一个名为 <code>sum</code> 的变量并初始化为 0</li><li><code>:=</code>：赋值操作符</li><li><code>RETURNS UInt8 NOT NULL</code>：指定返回值不能为 NULL</li></ul><h4>ResultSet 变量</h4><p>ResultSet 变量用于存储查询结果集，语法有：</p><p>示例语法：</p><pre><code>execute immediate $$
BEGIN
    LET x RESULTSET := select number from numbers(10);
    RETURN TABLE(x);
END;
$$;</code></pre><p>上面是返回结果集，所以使用 <code>RETURN TABLE(x)</code> 语句</p><h4>Cursor 变量</h4><p>Cursor 变量用于遍历结果集，语法有：</p><ol><li><code>LET &lt;cursor_variable&gt; CURSOR for &lt;query&gt;</code></li><li><code>LET &lt;cursor_variable&gt; CURSOR for &lt;result_set_variable&gt;</code></li><li><code>OPEN &lt;cursor_variable&gt;</code></li><li><code>FETCH &lt;cursor_variable&gt; INTO &lt;variable&gt;</code></li><li><code>CLOSE &lt;cursor_variable&gt;</code></li><li><code>for &lt;variable&gt; in &lt;cursor_variable&gt; do ... end for</code></li></ol><p>示例语法：</p><pre><code>execute immediate $$
BEGIN
    LET v Int;
    LET c CURSOR for select max(number) from numbers(10);
    OPEN c;
    FETCH c INTO v;
    CLOSE c;

    let d RESULTSET := select number from numbers(10);
    let e CURSOR for d;
    for v2 in e do
        v := v + v2.number;
    end for;

    return v;
END;
$$;</code></pre><h3>3.2 条件判断：IF-THEN-ELSEIF-ELSE</h3><p>IF 语句允许我们根据条件执行不同的代码分支：</p><pre><code>execute immediate $$
BEGIN
    LET score := 57 + 10 + 10 + 10;
    LET grade := '';

    IF score &gt;= 90 THEN
        grade := '优秀';
    ELSEIF score &gt;= 80 THEN
        grade := '良好';
    ELSEIF score &gt;= 70 THEN
        grade := '中等';
    ELSEIF score &gt;= 60 THEN
        grade := '及格';
    ELSE
        grade := '不及格';
    END IF;
    RETURN grade;
END;
$$;</code></pre><h3>3.3 循环：FOR 循环</h3><p>FOR 循环有两种常见形式：</p><h4>形式一：范围循环</h4><pre><code>FOR i IN start_value TO end_value DO
    -- 循环体
END FOR;</code></pre><p>示例：</p><pre><code>execute immediate $$
BEGIN
    LET sum := 0;
    FOR i IN 1 TO 10 DO
        sum := sum + i;
    END FOR;
    RETURN sum;
END;
$$;</code></pre><h4>形式二：结果集循环</h4><p>示例：</p><pre><code>execute immediate $$
BEGIN
    -- 声明一个结果集变量
    LET x RESULTSET := SELECT number n FROM numbers(10);
    LET sum := 0;

    -- 遍历结果集
    FOR r IN x DO
        -- 使用 r.n 访问列值
        sum := sum + r.n;
    END FOR;
    RETURN sum;
END;
$$;</code></pre><h2>四、高级应用：嵌套循环与复杂逻辑</h2><p>让我们看一个更复杂的例子，展示嵌套循环和多层逻辑：</p><pre><code>execute immediate $$
BEGIN
    -- 声明结果集变量：从 0 到 9 的数字
    LET x RESULTSET := SELECT number n FROM numbers(10);
    LET sum := 0;

    -- 外层循环：遍历结果集
    FOR x IN x DO
        -- 内层循环：从 0 到当前数字
        FOR batch IN 0 TO x.n DO
            IF batch % 2 = 0 THEN
                sum := sum + batch;  -- 偶数加
            ELSE
                sum := sum - batch;  -- 奇数减
            END IF;
        END FOR;
    END FOR;

    RETURN sum;
END;
$$;</code></pre><h3>逻辑分析</h3><p>让我们分析一下这个过程的执行流程：</p><ol><li><strong>外层循环</strong>：遍历 0-9 这 10 个数字</li><li><strong>内层循环</strong>：对于每个数字 n，从 0 循环到 n</li><li><strong>条件判断</strong>：如果是偶数则加，奇数则减</li></ol><p>例如当 x.n = 3 时：</p><ul><li>batch = 0（偶）：sum += 0</li><li>batch = 1（奇）：sum -= 1</li><li>batch = 2（偶）：sum += 2</li><li>batch = 3（奇）：sum -= 3</li></ul><h3>动态拼接语句，嵌套执行</h3><pre><code>execute immediate $$
BEGIN
   LET tbl_name := 'abcd1' ;
   LET drop_sql := 'DROP TABLE default."' || tbl_name || '"' ;
   EXECUTE IMMEDIATE :drop_sql ;
END ;
$$ ; </code></pre><h2><em>五、返回表格数据</em></h2><p>除了返回单个值，存储过程还可以返回整张表：</p><pre><code>execute immediate $$
BEGIN
    RETURN TABLE(
        SELECT
            number % 3 d,
            SUM(number) AS total_amount
        FROM numbers(10)
        GROUP BY d
    ) ;
END ;
$$ ; </code></pre><h2><em>六、存储过程管理</em></h2><table><thead><tr><th>操作</th><th>SQL</th><th>说明</th></tr></thead><tbody><tr><td>查看所有存储过程</td><td><code>SHOW PROCEDURES;</code></td><td> </td></tr><tr><td>查看存储过程详情</td><td><code>DESC PROCEDURE sum_even_numbers(UInt8, UInt8);</code><br/>或<br/><code>DESCRIBE PROCEDURE sum_even_numbers(UInt8, UInt8);</code></td><td><strong>注意：</strong><br/>• 无参数的存储过程使用空括号：<code>DESC PROCEDURE proc_name()</code><br/>• 有参数的必须指定确切的参数类型</td></tr><tr><td>删除存储过程</td><td><code>DROP PROCEDURE my_add(int, int);</code></td><td> </td></tr><tr><td>替换存储过程</td><td><code>CREATE OR REPLACE PROCEDURE my_add(a Int32, b Int32)</code><br/><code>RETURNS Int32</code><br/><code>LANGUAGE SQL</code><br/><code>AS $$`&lt;br&gt;`BEGIN`&lt;br&gt;`    RETURN a + b + 3;`&lt;br&gt;`END;`&lt;br&gt;`$$;</code></td></tr></tbody></table><h2><em>七、</em> <em>最佳实践</em></h2><h3><em>7.1 命名规范</em></h3><ul><li>使用有意义的名称，清晰表达功能</li><li>使用下划线分隔单词（snake_case）</li><li>添加前缀区分不同类型的过程（如 <code>calc_</code>, <code>get_</code>, <code>update_</code>）</li></ul><pre><code>-- 好的命名
CREATE PROCEDURE calc_monthly_revenue(...)
CREATE PROCEDURE get_active_users(...)
CREATE PROCEDURE update_user_status(...)

-- 不好的命名
CREATE PROCEDURE proc1(...)
CREATE PROCEDURE x(...)</code></pre><h3><em>7.2 注释说明</em></h3><p>始终为存储过程添加清晰的注释：</p><pre><code>CREATE PROCEDURE process_orders(order_date DATE)
RETURNS INT
LANGUAGE SQL
COMMENT = '处理指定日期的订单，返回处理数量'
AS $$ ... $$ ; </code></pre><h3><em>7.3 性能考虑</em></h3><ol><li><strong>避免过度循环</strong>：对于大数据集，尽量使用集合操作而非逐行循环</li><li><strong>合理使用索引</strong>：在存储过程中查询的表应有适当的索引</li><li><strong>批量操作</strong>：尽可能使用批量插入/更新而非逐条处理</li><li><strong>结果集大小</strong>：返回表格时，使用 LIMIT 限制结果集大小</li></ol><h2><em>八、实战案例：数据清洗流程</em></h2><p>让我们用二个实际案例来综合运用所学知识：</p><h3><em>9.1 清理和归档不活跃用户数据</em></h3><pre><code>CREATE OR REPLACE PROCEDURE cleanup_user_data(days_threshold INT)
RETURNS TABLE(
    action VARCHAR,
    user_count INT,
    processed_at TIMESTAMP
)
LANGUAGE SQL
COMMENT = '清理和归档不活跃用户数据'
AS $$
BEGIN
    LET cutoff_date := DATE_SUB(DAY, days_threshold,today()) ;
    LET inactive_users := 0 ;
    LET deleted_users := 0 ;

    -- 统计不活跃用户
    LET inactive_resultset RESULTSET :=
        SELECT COUNT(*) AS cnt
        FROM users
        WHERE last_login_date &lt; cutoff_date
        AND status = 'active' ;

    FOR r IN inactive_resultset DO
        inactive_users := r.cnt ;
    END FOR ;

    -- 标记不活跃用户
    UPDATE users
    SET status = 'inactive'
    WHERE last_login_date &lt; cutoff_date
    AND status = 'active' ;

    -- 删除长期不活跃用户
    DELETE FROM users
    WHERE last_login_date &lt; DATE_SUB(cutoff_date, INTERVAL days_threshold DAY)
    AND status = 'inactive' ;

    -- 返回处理结果
    RETURN TABLE(
        SELECT
            'Marked Inactive' AS action,
            inactive_users AS user_count,
            CURRENT_TIMESTAMP() AS processed_at
        UNION ALL
        SELECT
            'Deleted' AS action,
            deleted_users AS user_count,
            CURRENT_TIMESTAMP() AS processed_at
    ) ;
END ;
$$ ; </code></pre><p>调用方式：</p><pre><code>-- 清理 90 天未登录的用户
CALL PROCEDURE cleanup_user_data(90::Int) ; </code></pre><h3><em>9.2 扫描表并合并数据到target表</em></h3><pre><code>CREATE OR REPLACE PROCEDURE PROC_MERGE_GPS()
RETURNS STRING
LANGUAGE SQL
AS
$$
BEGIN
    create or replace table default.gps as select number from numbers(100) ;
    create or replace table default.abcd1 as select number from numbers(100) ;
    create or replace table default.abcd2 as select number from numbers(100) ;
    create or replace table default.abcd3 as select number from numbers(100) ;

    -- Step 1: 查询符合条件的表名（使用 INFORMATION_SCHEMA）
    LET records RESULTSET := (
        select name  from system.tables where database = 'default' and name like '%abcd%'
    ) ;
    LET table_count := 0 ;
    LET record_count := 0 ;
    LET table_names := [] ;
    LET union_parts := [] ;
    for table_record in records DO
        LET name := table_record.name ;
        table_count := table_count + 1 ;
        table_names := ARRAY_APPEND(table_names, name) ;
        union_parts := ARRAY_APPEND(union_parts, 'SELECT * FROM default.' || name) ;
    END FOR ;

    -- 如果没有匹配的表，直接返回
    IF (table_count = 0) THEN
        RETURN 'No data to process' ;
    END IF ;

    -- Step 3: 创建临时视图
    LET view_sql := 'CREATE OR REPLACE VIEW default.TEMPORARY_GPS_TABLES AS ' || ARRAY_TO_STRING(union_parts, ' UNION ALL ') ;
    EXECUTE IMMEDIATE :view_sql ;

    -- Step 2: 查询表中的记录数
    LET record_count_sql := 'SELECT COUNT(*) c FROM default.TEMPORARY_GPS_TABLES' ;
    LET r RESULTSET := EXECUTE IMMEDIATE :record_count_sql ;
    for record in r DO
        record_count := record.c ;
    END FOR ;

    -- Step 4: 设置会话参数, example
    EXECUTE IMMEDIATE 'set max_block_size = 65536' ;

    -- Step 5: 执行 示例SQL
    LET merge_sql := 'insert into default.gps select * from default.TEMPORARY_GPS_TABLES;' ;
    EXECUTE IMMEDIATE :merge_sql ;

    -- Step 6: 清理：删除视图
    EXECUTE IMMEDIATE 'DROP VIEW IF EXISTS default.TEMPORARY_GPS_TABLES' ;

    -- Step 7: 删除所有 %abcd% 表
    FOR i IN 1 TO ARRAY_SIZE(table_names) DO
        LET tbl_name := table_names[i]::STRING ;
        LET drop_sql := 'DROP TABLE default."' || tbl_name || '"' ;
        EXECUTE IMMEDIATE :drop_sql ;
    END FOR ;
    RETURN 'Merge completed successfully. Processed ' || table_count || ' tables. Total records: ' || record_count ;
END ;
$$ ; </code></pre><p>调用结果：</p><pre><code>call PROCEDURE PROC_MERGE_GPS() ;
---
Merge completed successfully. Processed 3 tables. Total records: 300</code></pre><h2><em>九、总结</em></h2><p>Databend 的 SQL 存储过程为数据处理提供了强大而灵活的工具。通过本文，我们学习了：</p><ol><li><strong>基础语法</strong>：如何创建和调用存储过程</li><li><strong>变量和赋值</strong>：使用 LET 声明和管理变量</li><li><strong>流程控制</strong>：IF 条件判断和 FOR 循环</li><li><strong>高级特性</strong>：嵌套循环、结果集遍历、返回表格</li><li><strong>管理操作</strong>：查看、描述、删除存储过程</li><li><strong>最佳实践</strong>：命名规范、注释、错误处理、性能优化</li></ol><h3><em>关键要点回顾</em></h3><ul><li>✅ 使用 <code>CREATE PROCEDURE</code> 创建存储过程</li><li>✅ 使用 <code>CALL PROCEDURE</code> 调用存储过程</li><li>✅ 使用 <code>EXECUTE IMMEDIATE</code> 执行动态 SQL</li><li>✅ 使用 <code>LET</code> 声明变量，<code>:=</code> 赋值</li><li>✅ 支持 <code>IF-THEN-ELSE</code> 条件判断</li><li>✅ 支持 <code>FOR...IN...DO</code> 循环</li><li>✅ 可以返回单个值或整张表</li><li>✅ 使用 <code>CREATE OR REPLACE</code> 更新存储过程</li><li>✅ 使用 <code>RESULTSET</code> 类型处理查询结果</li></ul><h3><em>下一步</em></h3><p>现在你已经掌握了 Databend 存储过程的核心知识，可以开始：</p><ol start="7"><li>在自己的项目中创建简单的存储过程</li><li>逐步引入更复杂的逻辑和流程控制</li><li>将常用的数据处理任务封装为存储过程</li><li>探索更多高级特性和优化技巧</li></ol><p>Happy coding with Databend! 🚀</p><h2>关于 Databend</h2><p>Databend 是一款开源、弹性、低成本，基于对象存储也可以做实时分析的新式湖仓。期待您的关注，一起探索云原生数仓解决方案，打造新一代开源 Data Cloud。</p><p>👨‍💻‍ Databend Cloud：<a href="https://link.segmentfault.com/?enc=P3aVDBMB4HdPc9YUZapaVQ%3D%3D.AUOUhDeqroEbJS0UaNFRDfA5Ep1%2FDbTlLqmlt1t5Asg0pgXyWXVXIKR6o0o0jX496k35jOsLSOkTnvD3SYwEcw%3D%3D" rel="nofollow" title="https://link.juejin.cn/?target=https%3A%2F%2Fdatabend.cn%2F" target="_blank">databend.cn</a></p><p>📖 Databend 文档：<a href="https://link.segmentfault.com/?enc=H%2F8PlpltaS34N1DwPC3tbw%3D%3D.8Lkk6SMMF6WICouN6oUR6YGaauLewcQhKE3C4lwdUrZ38YfIB%2B8gW4zjEuCg8%2B%2FdoPDt1sUS7U%2FvA5QKOZsFnJQB0ClU3D9uM7tFGf5lYXE%3D" rel="nofollow" title="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.databend.cn%2F" target="_blank">docs.databend.cn</a></p><p>💻 Wechat：Databend</p><p>✨ GitHub：<a href="https://link.segmentfault.com/?enc=Cprp84F2tBEipBiWEQOG9Q%3D%3D.MYRIUJ7Xotc1UqbUieYqVR0E9eH5VyoRYtES4XFHSe5MVXiO6%2FZz6fD%2B0ABOhGf2C6B9so4LWIp%2F4mpRjaNeCC9x3maTvFGdVSeh3xquH39BE%2FJ1HnXh7kuvstjMGrgl" rel="nofollow" title="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdatabendlabs%2Fdatabend" target="_blank">github.com/databendlab…</a></p>]]></description></item><item>    <title><![CDATA[如何使用 C# 创建 Word 文档填充]]></title>    <link>https://segmentfault.com/a/1190000047400494</link>    <guid>https://segmentfault.com/a/1190000047400494</guid>    <pubDate>2025-11-14 18:03:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在企业应用中，Word 文档（DOC/DOCX）仍然是信息交换和报告制作的核心工具。无论是合同、通知、汇报材料还是自动生成报表，都需要程序化生成 Word 文件。在传统做法中，开发者可能依赖手动操作或 Office 自动化（Interop），但这类方法存在依赖 Office 安装、性能低下及易出错的问题。</p><p>本文将详细介绍如何使用 <strong><a href="https://link.segmentfault.com/?enc=POKUCajmFjOyO0%2Bl8NSMWA%3D%3D.1e6jImGNhIRiwCs4JQSpN1eGnGdPUdh%2BXVjMKE9XNB6S9mQdyJ6GBkmYMxtvRGf2WzTZ9keyAYgjIW90OtVm7A%3D%3D" rel="nofollow" target="_blank">Free Spire.Doc for .NET</a></strong> 在 C# 中创建 Word 文档、插入文本、表格、图片及页眉页脚，并扩展到保存不同格式和 MemoryStream 的场景。示例数据仍使用英文文本，以便快速理解。</p><hr/><h2>1. 安装 Spire.Doc</h2><p>在使用前，需要通过 NuGet 安装 Spire.Doc：</p><pre><code class="bash">Install-Package FreeSpire.Doc</code></pre><p>安装完成后，在 C# 项目中引用必要命名空间：</p><pre><code class="csharp">using Spire.Doc;
using Spire.Doc.Documents;
using Spire.Doc.Fields;
using System.IO;
using System.Drawing;</code></pre><hr/><h2>2. 创建 Word 文档并添加段落</h2><pre><code class="csharp">// 创建新的文档
Document document = new Document();
Section section = document.AddSection();

// 添加标题段落
Paragraph title = section.AddParagraph();
title.AppendText("Employee Report");
title.Format.HorizontalAlignment = HorizontalAlignment.Center;
title.ApplyStyle(BuiltinStyle.Heading1);

// 添加正文段落
Paragraph intro = section.AddParagraph();
intro.AppendText("This report contains the details of employees in the company. All information is for internal use only.");
intro.Format.HorizontalAlignment = HorizontalAlignment.Left;
intro.Format.LineSpacing = 15f;</code></pre><p><strong>说明</strong>：</p><ul><li><code>AddSection</code> 创建独立章节，方便分页和样式管理。</li><li>内置样式（<code>BuiltinStyle</code>）提供 Word 标准格式。</li><li><code>Paragraph.Format</code> 可自定义对齐、行距、缩进等。</li></ul><hr/><h2>3. 插入表格并填充数据</h2><pre><code class="csharp">// 创建表格，5 行 5 列（含标题行）
Table table = section.AddTable(true);
table.ResetCells(5, 5);

// 设置标题行
table[0, 0].AddParagraph().AppendText("EmployeeID");
table[0, 1].AddParagraph().AppendText("FullName");
table[0, 2].AddParagraph().AppendText("Department");
table[0, 3].AddParagraph().AppendText("HireDate");
table[0, 4].AddParagraph().AppendText("Salary");

// 填充示例数据
table[1, 0].AddParagraph().AppendText("E101");
table[1, 1].AddParagraph().AppendText("John Miller");
table[1, 2].AddParagraph().AppendText("Finance");
table[1, 3].AddParagraph().AppendText("2020-02-15");
table[1, 4].AddParagraph().AppendText("7500");

table[2, 0].AddParagraph().AppendText("E102");
table[2, 1].AddParagraph().AppendText("Sarah Brown");
table[2, 2].AddParagraph().AppendText("HR");
table[2, 3].AddParagraph().AppendText("2019-07-10");
table[2, 4].AddParagraph().AppendText("6800");

table[3, 0].AddParagraph().AppendText("E103");
table[3, 1].AddParagraph().AppendText("Mike Smith");
table[3, 2].AddParagraph().AppendText("IT");
table[3, 3].AddParagraph().AppendText("2020-01-20");
table[3, 4].AddParagraph().AppendText("9000");

table[4, 0].AddParagraph().AppendText("E104");
table[4, 1].AddParagraph().AppendText("Lisa Jones");
table[4, 2].AddParagraph().AppendText("Marketing");
table[4, 3].AddParagraph().AppendText("2018-09-05");
table[4, 4].AddParagraph().AppendText("5500");</code></pre><p><strong>说明</strong>：</p><ul><li><code>AddTable(true)</code> 创建具有默认样式的表格。</li><li><code>ResetCells</code> 定义行列数。</li><li><code>table[i, j].AddParagraph()</code> 可插入文本，支持格式和超链接。</li></ul><hr/><h2>4. 自定义表格样式和段落格式</h2><pre><code class="csharp">// 设置标题行背景色
for (int i = 0; i &lt; 5; i++)
{
    table[0, i].CellFormat.BackColor = Color.LightGray;
    table[0, i].Paragraphs[0].GetStyle().CharacterFormat.Bold = true;
}

// 设置表格边框
table.TableFormat.Borders.BorderType = BorderStyle.Single;

// 设置行高
for (int i = 0; i &lt; table.Rows.Count; i++)
{
    table.Rows[i].Height = 20f;
}</code></pre><hr/><h2>5. 插入图片</h2><pre><code class="csharp">// 添加图片
Paragraph imgPara = section.AddParagraph();
DocPicture picture = imgPara.AppendPicture(Image.FromFile("company_logo.png"));
picture.Width = 100;
picture.Height = 50;
imgPara.Format.HorizontalAlignment = HorizontalAlignment.Right;</code></pre><p><strong>说明</strong>：</p><ul><li>使用 <code>AppendPicture</code> 插入图片，可调整宽高。</li><li>图片可放置于段落中，可对齐左、中、右。</li></ul><hr/><h2>6. 添加页眉页脚</h2><pre><code class="csharp">// 页眉
HeaderFooter header = section.HeadersFooters.Header;
Paragraph headerPara = header.AddParagraph();
headerPara.AppendText("Company Confidential");
headerPara.Format.HorizontalAlignment = HorizontalAlignment.Center;

// 页脚
HeaderFooter footer = section.HeadersFooters.Footer;
Paragraph footerPara = footer.AddParagraph();
footerPara.AppendText("Page ");
footerPara.AppendField("PAGE", FieldType.FieldPage);
footerPara.AppendText(" of ");
footerPara.AppendField("NUMPAGES", FieldType.FieldNumPages);
footerPara.Format.HorizontalAlignment = HorizontalAlignment.Center;</code></pre><p><strong>说明</strong>：</p><ul><li>页眉页脚可包含文字、页码、图片等内容。</li><li><code>FieldType.FieldPage</code> 与 <code>FieldType.FieldNumPages</code> 可实现自动页码功能。</li></ul><hr/><h2>7. 保存 Word 文档及其他格式</h2><pre><code class="csharp">// 保存为 DOCX
document.SaveToFile("EmployeeReport.docx", FileFormat.Docx);

// 保存为 PDF
document.SaveToFile("EmployeeReport.pdf", FileFormat.PDF);

// 保存为 HTML
document.SaveToFile("EmployeeReport.html", FileFormat.Html);

// 保存到 MemoryStream
using (MemoryStream ms = new MemoryStream())
{
    document.SaveToStream(ms, FileFormat.Docx);
    // 可直接发送到客户端或存储到数据库
}</code></pre><hr/><h2>8. 生成效果展示</h2><p>以下是上述代码生成的 Word 文档效果：</p><p><img width="723" height="500" referrerpolicy="no-referrer" src="/img/bVdm3cf" alt="C#创建并保存Word文档" title="C#创建并保存Word文档"/></p><hr/><h2>9. 扩展应用场景</h2><ol><li><strong>自动化报表生成</strong><br/>系统可以定期生成员工报告、销售报表，减少手工操作。</li><li><strong>动态内容生成</strong><br/>根据数据库动态填充段落、表格、图片，生成模板化文档。</li><li><strong>多格式导出</strong><br/>Spire.Doc 支持 DOCX、PDF、HTML 等多种格式，满足打印、网页展示或二次处理。</li><li><strong>Web 集成</strong><br/>MemoryStream 方式可直接返回客户端，无需写入磁盘，提高安全性和性能。</li></ol><hr/><h2>10. 总结</h2><p>本文演示了如何使用 <strong>Spire.Doc for .NET</strong>：</p><ul><li>创建 Word 文档并添加标题、正文、表格</li><li>美化表格和段落样式</li><li>插入图片和页眉页脚</li><li>将文档保存为 DOCX、PDF、HTML 等多种格式</li><li>使用 MemoryStream 实现网络传输或二次处理</li></ul><p>通过掌握 <code>Document</code>、<code>Section</code>、<code>Paragraph</code>、<code>Table</code>、<code>DocPicture</code> 等核心类和方法，你可以轻松实现 Word 文档自动化生成，提高办公系统开发效率和文档管理水平。</p>]]></description></item><item>    <title><![CDATA[【HarmonyOS 6】静态和动态添加]]></title>    <link>https://segmentfault.com/a/1190000047400506</link>    <guid>https://segmentfault.com/a/1190000047400506</guid>    <pubDate>2025-11-14 18:02:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>【HarmonyOS 6】静态和动态添加应用快捷方式详解</h2><h3>一、前言</h3><p>在功能日益复杂的应用中，用户往往需要多步操作才能找到常用功能。而应用快捷方式能让用户一键直达核心功能，既提升操作效率，也能增强用户对应用的粘性。</p><p>本文结合实际开发场景，详细分享 HarmonyOS 中两种快捷方式的实现方法，包括静态快捷方式配置和应用内动态添加，全程基于单 HAP 包场景（多 HAP 包配置逻辑一致）。</p><h3>二、静态快捷方式：基础配置与快速跳转</h3><p>静态快捷方式是通过配置文件预先定义的快捷方式，用户长按应用图标即可看到。例如“回家导航”“新建便签”这类高频固定功能。效果如下：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400508" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><h5>1、 创建目标页面并配置路由</h5><p>首先创建快捷方式对应的功能页面（如“回家”“去公司”页面），页面需用 <code>@Entry</code> 装饰。然后在 <code>resources/base/profile/main_pages.json</code> 中添加页面路由，确保应用能识别页面路径：</p><pre><code class="json">{
  "src": [
    "pages/Index",  // 应用主页面
    "pages/GoHouse", // 回家导航页面
    "pages/GoCompany" // 去公司导航页面
  ]
}</code></pre><h5>2、 编写快捷方式配置文件</h5><p>在 <code>resources/base/profile/</code> 目录下新建 <code>shortcuts_config.json</code> 文件，定义快捷方式的 ID、显示文本、图标和跳转目标。每个快捷方式需包含以下核心参数：</p><ul><li><code>shortcutId</code>：唯一标识，不超过 63 字节</li><li><code>label</code>：显示文本（支持字符串或资源索引）</li><li><code>icon</code>：图标资源索引</li><li><code>wants</code>：跳转配置（包名、模块名、组件名、自定义参数）</li></ul><p>示例配置：</p><pre><code class="json">{
  "shortcuts": [
    {
      "shortcutId": "id_company",
      "label": "$string:Go_to_the_Company",
      "icon": "$media:company",
      "wants": [
        {
          "bundleName": "com.example.desktopshortcuts",
          "moduleName": "entry",
          "abilityName": "EntryAbility",
          "parameters": {
            "shortCutKey": "CompanyPage"
          }
        }
      ]
    },
    {
      "shortcutId": "id_house",
      "label": "$string:Go_to_House",
      "icon": "$media:house",
      "wants": [
        {
          "bundleName": "com.example.desktopshortcuts",
          "moduleName": "entry",
          "abilityName": "EntryAbility",
          "parameters": {
            "shortCutKey": "HousePage"
          }
        }
      ]
    }
  ]
}</code></pre><h5>3、在 module.json5 中关联配置</h5><p>在 <code>module.json5</code> 的 <code>abilities</code> 标签下添加 <code>metadata</code> 配置，指定快捷方式配置文件路径，让系统识别快捷方式：</p><pre><code class="json">{
  "module": {
    "abilities": [
      {
        "name": "EntryAbility",
        "srcEntry": "./ets/entryability/EntryAbility.ets",
        "skills": [
          {
            "entities": ["entity.system.home"],
            "actions": ["ohos.want.action.home"]
          }
        ],
        "metadata": [
          {
            "name": "ohos.ability.shortcuts",
            "resource": "$profile:shortcuts_config"
          }
        ]
      }
    ]
  }
}</code></pre><h5>4、实现页面跳转逻辑</h5><p>在主页面（Index.ets）中定义跳转方法，通过读取 <code>wants</code> 中的自定义参数 <code>shortCutKey</code>，判断用户点击的快捷方式，进而跳转到对应页面：</p><pre><code class="typescript">goToSpecifyPage(want?: Want) {
  let shortCutKey = want?.parameters?.shortCutKey;

  if (shortCutKey === 'CompanyPage') {
    this.getUIContext().getRouter().pushUrl({ url: 'pages/GoCompany' })
      .catch((err: BusinessError) =&gt; {
        hilog.error(0x0000, 'testTag', `跳转失败：${err.code}, ${err.message}`);
      });
  }
  if (shortCutKey === 'HousePage') {
    this.getUIContext().getRouter().pushUrl({ url: 'pages/GoHouse' })
      .catch((err: BusinessError) =&gt; {
        hilog.error(0x0000, 'testTag', `跳转失败：${err.code}, ${err.message}`);
      });
  }
}</code></pre><h5>5、 保存并传递 Want 参数</h5><p>快捷方式跳转分为冷启动和热启动，需在 <code>EntryAbility.ets</code> 中通过 <code>AppStorage</code> 保存 <code>want</code> 参数，确保页面能获取到跳转信息：</p><pre><code class="typescript">// 冷启动时保存参数
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
  this.context.getApplicationContext().setColorMode(ConfigurationConstant.ColorMode.COLOR_MODE_NOT_SET);
  if (want?.parameters?.shortCutKey) {
    AppStorage.setOrCreate('want', want);
  }
}

// 热启动时更新参数
onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {
  if (want?.parameters?.shortCutKey) {
    AppStorage.setOrCreate('want', want);
  }
}</code></pre><h5>6、 页面显示时执行跳转</h5><p>在主页面的 <code>onPageShow</code> 方法中，读取 <code>AppStorage</code> 中保存的 <code>want</code> 参数，调用跳转方法完成快捷方式响应：</p><pre><code class="typescript">onPageShow(): void {
  if (AppStorage.has('want')) {
    let want: Want | undefined = AppStorage.get('want');
    if (want) {
      this.goToSpecifyPage(want);
      AppStorage.delete('want'); // 跳转后清除参数，避免重复触发
    }
  }
}</code></pre><p>具体跳转的处理，通过want中的参数，开发者可以根据自己业务习惯进行跳转处理，以上处理为参考。</p><h4>注意事项</h4><p>（1）静态快捷方式最多支持配置 4 个，仅能跳转至 UIAbility 入口页面，无法直接跳转到非入口页面。<br/>（2）多 HAP 包场景无需额外配置，所有操作均在 entry 文件夹下完成。</p><h3>二、应用内动态添加快捷方式</h3><p>除了预先配置的静态快捷方式，还可以在应用内通过代码动态添加快捷方式（如用户点击“添加到桌面”按钮时创建），灵活性更高。</p><h4>核心实现代码</h4><p>创建 <code>ShortcutsUtils</code> 工具类，封装动态添加快捷方式的逻辑，包含权限校验、重复判断和创建请求：</p><pre><code class="typescript">import { hilog } from "@kit.PerformanceAnalysisKit";
import { BusinessError } from "@kit.BasicServicesKit";
import { productViewManager } from "@kit.StoreKit";
import { common, Want } from "@kit.AbilityKit";
import promptAction from '@ohos.promptAction';

export class ShortcutsUtils {
  /**
   * 点击按钮添加快捷方式
   */
  static addShortcuts() {
    const uiContext = getContext() as common.UIAbilityContext;
    const shortcutId = "id_test1"; // 需与 shortcuts_config.json 中定义的一致
    const labelResName = "shortcut"; // 对应 label 的资源索引名称
    const iconResName = "aa_icon"; // 对应 icon 的资源索引名称
    const want: Want = {
      bundleName: "com.example.appgallery.kit.demo",
      moduleName: "entry",
      abilityName: "EntryAbility",
      parameters: {
        testKey: "testValue" // 自定义参数
      }
    };

    try {
      // 校验快捷方式是否可添加（是否已存在、是否有权限）
      productViewManager.checkPinShortcutPermitted(uiContext, shortcutId, want, labelResName, iconResName)
        .then((result) =&gt; {
          hilog.info(0x0001, 'addShortcuts', `校验成功：${JSON.stringify(result)}`);
          const tid = result.tid;
          // 发起添加快捷方式请求
          productViewManager.requestNewPinShortcut(uiContext, tid)
            .then(() =&gt; {
              hilog.info(0x0001, 'addShortcuts', "快捷方式添加成功！");
            })
            .catch((error: BusinessError) =&gt; {
              hilog.error(0x0001, 'addShortcuts', `快捷方式添加失败：${error.code}, ${error.message}`);
            });
        })
        .catch((error: BusinessError) =&gt; {
          hilog.error(0x0001, 'addShortcuts', `err：${error.code}, ${error.message}`);
          // 错误码 1006620003 表示快捷方式已存在
          if (error.code === 1006620003) {
            promptAction.showToast({ message: '桌面已存在此快捷方式！' });
          }
        });
    } catch (err) {
      hilog.error(0x0001, 'TAG', `catch err：${err.code}, ${err.message}`);
    }
  }
}</code></pre><h4>使用方式</h4><p>在应用页面的按钮点击事件中调用工具类方法，即可触发快捷方式添加流程：</p><pre><code class="typescript">// 示例：按钮点击事件
Button('添加测试快捷方式')
  .onClick(() =&gt; {
    ShortcutsUtils.addShortcuts();
  })</code></pre><p>productViewManager允许应用添加快捷方式的数量为两个。这是鸿蒙官方的设计如此。</p><h3>三、两种快捷方式的区别与适用场景</h3><table><thead><tr><th>类型</th><th>配置方式</th><th>灵活性</th><th>适用场景</th></tr></thead><tbody><tr><td>静态快捷方式</td><td>配置文件定义</td><td>较低（固定功能）</td><td>高频固定功能，如导航、新建、快速拍照</td></tr><tr><td>动态快捷方式</td><td>代码动态添加</td><td>较高（用户触发）</td><td>个性化功能，如用户自定义收藏、临时高频功能</td></tr></tbody></table>]]></description></item><item>    <title><![CDATA[【赵渝强老师】OceanBase的连接与]]></title>    <link>https://segmentfault.com/a/1190000047400537</link>    <guid>https://segmentfault.com/a/1190000047400537</guid>    <pubDate>2025-11-14 18:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>OceanBase数据库连接路由管理组件ODP（OceanBase Database Proxy）是OceanBase数据库专用的连接路由管理集群。OceanBase数据库用户的数据会以多副本的形式存放在各个OBServer节点上，ODP接收用户发出的SQL请求，并将SQL请求转发至最佳目标OBServer节点，最后将执行结果返回给用户。</p><h2>一、 ODP简介</h2><p>OceanBase数据库与传统单机数据库不同，OceanBase数据库是分布式数据库，每个表甚至每个表的不同分区都可能存放在不同的机器上。想要对表进行读写，必须先要定位到数据所属的表或是分区的主副本位置，然后才能执行相应的SQL语句，这在应用层面而言是几乎不可能做到的。ODP作为OceanBase数据库专用的反向代理软件，其核心功能是路由，将客户端发起的数据访问请求转发到正确的OBServer节点上，并将OBServer节点的响应结果转发给客户端。视频讲解如下：<br/><a href="https://www.bilibili.com/video/BV1kcCbB4Ei2/?aid=115542555893412&amp;cid=33978453859" target="_blank">https://www.bilibili.com/video/BV1kcCbB4Ei2/?aid=115542555893...</a></p><p>作为OceanBase数据库的关键组件，ODP具有以下特性：</p><ul><li><strong>连接管理</strong>：针对一个客户端的物理连接，ODP维持自身到后端多个OBServer节点的连接，并维持了每个OBServer节点连接的会话状态，保证了客户端高效访问各个OBServer节点。</li><li><strong>最佳路</strong>由：ODP充分考虑用户请求涉及的副本位置、用户配置的读写分离路由策略、OceanBase多地部署的最优链路，以及OceanBase各机器的状态及负载情况，将用户的请求路由到最佳的OBServer节点，最大程度地保证了OceanBase整体的高性能运转。</li><li><strong>高性能转发</strong>：ODP完整兼容MySQL协议，并支持OceanBase自研协议，采用多线程异步框架和透明流式转发的设计，保证了数据的高性能转发，同时确保了自身对机器资源的最小消耗。</li><li><strong>易运维</strong>：ODP本身无状态，支持无限水平扩展，支持同时访问多个OceanBase集群。可通过丰富的内部命令对ODP状态进行实时监控，这使得运维简单便利。</li><li><strong>高可用</strong>：ODP高可用分为两部分：一方面保证自身高可用，持续提供代理服务；另一方面ODP是OceanBase高可用体系的主要组成部分，可以对用户屏蔽宕机、升级等情况，保证OceanBase数据库服务的稳定和快速恢复。</li><li><strong>专有协议</strong>：ODP与OBServer节点默认采用了OceanBase专有协议，如增加报文的CRC校验保证与OBServer节点链路的正确性，增强传输协议以支持Oracle兼容性的数据类型和交互模型。</li></ul><p>客户端通过ODP访问OceanBase数据库的数据链路如下图所示。<br/><img width="723" height="460" referrerpolicy="no-referrer" src="/img/bVdmYFf" alt="image.png" title="image.png"/></p><h2>二、 使用ODP连接数据库集群</h2><p>部署好ODP集群后，便可以通过OBProxy连接OceanBase数据库集群了，下面是具体的操作步骤。<br/>（1）在中控机上执行命令查看集群的节点信息。</p><pre><code class="powershell">obd cluster display myob-cluster

# 输出的信息如下：
......
Connect to obproxy ok
+-------------------------------------------------------------------+
|                             obproxy-ce                            |
+---------------+------+-----------------+-----------------+--------+
| ip            | port | prometheus_port | rpc_listen_port | status |
+---------------+------+-----------------+-----------------+--------+
| 192.168.79.11 | 2883 | 2884            | 2885            | active |
| 192.168.79.13 | 2883 | 2884            | 2885            | active |
+---------------+------+-----------------+-----------------+--------+
obclient -h192.168.79.11 -P2883 -uroot@proxysys -p'Welcome_1' -Doceanbase -A 
......

# 提示：从输出的信息可以看出，ODP集群中包含两台OBProxy，
# 它们分别运行在：192.168.79.11和192.168.79.13主机上。</code></pre><p>（2）登录192.168.79.11主机，查看OBProxy的目录结构。</p><pre><code class="powershell">tree /root/obproxy/ -L 1

# 输出的信息如下：
/root/obproxy/
├── bin                    保存ODP的可执行二进制文件
├── control-config
├── etc                    保存配置信息的目录
├── lib
├── log                    保存日志文件的目录
├── obproxyd.sh            OBProxy的守护进程
├── run                    保存OBProxy启动的进程号信息
└── sharding-config        保存Sharding（分片）相关的配置文件

# 提示：如果OBProxy进程不存在，或者异常宕机。
# obproxyd.sh脚本负责重新启动OBProxy进程。</code></pre><p>（3）通过操作的的ps命令可以查看到OBProxy的进程信息。</p><pre><code class="powershell">ps -ef | grep obproxy

# 输出的信息如下：
root  4895 ... bash /root/obproxy/obproxyd.sh /root/obproxy 192.168.79.11 2883 daemon
root  4904 ... /root/obproxy/bin/obproxy --listen_port 2883
root 10892 ... grep obproxy

# 提示：这里的进程号4895与4904与run目录下的进程号文件保持一致，如下所示：
[root@node11 obproxy]# ls run/
obproxy-192.168.79.11-2883.pid  obproxyd-192.168.79.11-2883.pid
[root@node11 obproxy]# cat run/*
4904
4895</code></pre><p>（4）通过OBProxy连接OceanBase数据库集群</p><pre><code class="powershell">obclient -h192.168.79.11 -P2883 -uroot@sys#myob-cluster -pWelcome_1 -Doceanbase -A

# 提示：该命令也可以简写成下面的形式：
obclient -h192.168.79.11 -P2883 -uroot -pWelcome_1 -Doceanbase -A

# 此时如果出现下面的错误：
ERROR 2013 (HY000): 
Lost connection to MySQL server at 'reading authorization packet', 
system error: 11

# 这是由于集群配置信息中的proxyro_password不一致造成。</code></pre><p>（5）在中控机上执行下面的命令编辑集群的配置信息。</p><pre><code class="powershell">obd cluster edit-config myob-cluster</code></pre><p>（6）将global下的proxyro_password修改为正确的密码，保存并退出。</p><pre><code class="powershell">  global:
    ......
    root_password: Welcome_1
    appname: myob-cluster
    ocp_agent_monitor_password: ztkrtULS7u
    proxyro_password: YqNSd87E3K
    ......
    
  修改为：
  
  global:
    ......
    root_password: Welcome_1
    appname: myob-cluster
    ocp_agent_monitor_password: ztkrtULS7u
    proxyro_password: Welcome_1
    ......</code></pre><p>（7）重新加载配置信息。</p><pre><code class="powershell">obd cluster reload myob-cluster</code></pre><p>（8）通过OBProxy连接OceanBase数据库集群</p><pre><code class="powershell">obclient -h192.168.79.11 -P2883 -uroot@sys#myob-cluster -pWelcome_1 -Doceanbase -A

ob&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| LBACSYS            |
| mysql              |
| oceanbase          |
| ocs                |
| ORAAUDITOR         |
| scott              |
| SYS                |
| sys_external_tbs   |
| test               |
+--------------------+
10 rows in set (0.011 sec)</code></pre><h2>三、 查看ODP配置属性</h2><p>通过使用root@sys用户通过ODP代理登录OceanBase数据库，或使用root@proxysys用户登录ODP均可以查看ODP的配置参数。下面是具体的操作步骤：<br/>（1）执行命令登录OceanBase数据库或者ODP</p><pre><code class="powershell"># 登录OceanBase数据库
obclient -h192.168.79.11 -P2883 -uroot@sys#myob-cluster -pWelcome_1 -Doceanbase -A

# 登录ODP
obclient -h192.168.79.11 -P2883 -uroot@proxysys -p'Welcome_1' -Doceanbase -A</code></pre><p>（2）查看ODP的参数配置。</p><pre><code class="powershell">ob&gt; show proxyconfig \G;

# 输出的信息如下：
......
*************************** 326. row ***************************
         name: json_config_cluster_count
        value: 1
         info: ob cluster count, meta db cluster not included
  need_reboot: false
visible_level: virtual
        range: NULL
 config_level: NULL
*************************** 327. row ***************************
         name: json_config_modified_time
        value: 2025-04-15 14:12:20.271644
         info: json config modified time
  need_reboot: false
visible_level: virtual
        range: NULL
 config_level: NULL
327 rows in set (0.012 sec)</code></pre><p>（3）使用like关键字查看ODP的参数配置。</p><pre><code class="powershell">ob&gt; show proxyconfig like '%full%'\G;

# 输出的信息如下：
*************************** 1. row ***************************
         name: enable_full_username
        value: False
        info: used for non-cloud user, if set true, username must have tenant and cluster
  need_reboot: false
visible_level: SYS
        range: 
 config_level: LEVEL_GLOBAL
*************************** 2. row ***************************
         name: enable_cloud_full_username
        value: False
         info: used for cloud user, if set false, treat all login user as username
  need_reboot: false
visible_level: SYS
        range: 
 config_level: LEVEL_VIP
*************************** 3. row ***************************
         name: enable_full_link_trace
        value: False
         info: if enable proxy will use full link trace to trace query execution
  need_reboot: false
visible_level: USER
        range: 
 config_level: LEVEL_GLOBAL
3 rows in set (0.009 sec)</code></pre><p>（4）执行select * from proxy_config命令查看配置参数。</p><pre><code class="powershell">ob&gt; select * from proxy_config;

# 输出信息如下：
+---------------------------------+-----------------+--------------+
......                                              
| server_state_refresh_interval   | 20s             | LEVEL_GLOBAL |
| cache_cleaner_clean_interval    | 20s             | LEVEL_GLOBAL |
| proxy_hot_upgrade_check_interval| 5s              | LEVEL_GLOBAL |
| proxy_info_check_interval       | 60s             | LEVEL_GLOBAL |
| refresh_config                  | False           | LEVEL_GLOBAL |
| refresh_idc_list                | False           | LEVEL_GLOBAL |
| refresh_rslist                  | False           | LEVEL_GLOBAL |
| refresh_json_config             | False           | LEVEL_GLOBAL |
| enable_xa_route                 | True            | LEVEL_GLOBAL |
| observer_sys_password           | d809d427528be882| LEVEL_GLOBAL |
+---------------------------------+-----------------+--------------+
319 rows in set (0.056 sec)

# 提示：该命令仅在使用root@proxysys用户登录ODP时可执行，其他用户下执行会报错。</code></pre><h2>四、 修改ODP配置属性</h2><p>修改ODP配置属性的值可以通过以下两种方式实现：</p><ul><li>在ODP运行时，使用root@proxysys用户登录ODP后，执行alter proxyconfig命令修改ODP配置项。</li><li>在ODP启动时，启动命令中添加-o选项修改配置项。</li></ul><p>这里以配置属性enable_cluster_checkout为例来进行演示。该属性用于控制是否进行集群名称校验，默认值是False。如果启用集群校验，在登录时ODP会发送集群名称，服务器会对其进行检查。下面是具体的操作步骤。</p><h3>方式一：通过alter proxyconfig命令</h3><p>（1）登录ODP</p><pre><code class="powershell">obclient -h192.168.79.11 -P2883 -uroot@proxysys -pWelcome_1</code></pre><p>（2）查看配置属性enable_cluster_checkout的值。</p><pre><code class="powershell">ob&gt; show proxyconfig like 'enable_cluster_checkout' \G;

# 输出信息如下：
*************************** 1. row ***************************
         name: enable_cluster_checkout
        value: False
         info: if enable cluster checkout, proxy will send cluster 
               name when login and server will check it
  need_reboot: false
visible_level: USER
        range: 
 config_level: LEVEL_GLOBAL
1 row in set (0.002 sec)</code></pre><p>（3）通过alter proxyconfig命令修改属性。</p><pre><code class="powershell">ob&gt; alter proxyconfig set enable_cluster_checkout=True;</code></pre><p>（4）重新查看配置属性enable_cluster_checkout的值。</p><pre><code class="powershell">ob&gt; show proxyconfig like 'enable_cluster_checkout' \G;

# 输出信息如下：
*************************** 1. row ***************************
         name: enable_cluster_checkout
        value: True
         info: if enable cluster checkout, proxy will send cluster 
               name when login and server will check it
  need_reboot: false
visible_level: USER
        range: 
 config_level: LEVEL_GLOBAL
1 row in set (0.002 sec)</code></pre><h3>方式二：通过启动命令的-o选项</h3><p>（1）在中控机上执行命令查看集群的节点信息。</p><pre><code class="powershell">obd cluster display myob-cluster

# 输出的信息如下：
......
Connect to obproxy ok
+-------------------------------------------------------------------+
|                             obproxy-ce                            |
+---------------+------+-----------------+-----------------+--------+
| ip            | port | prometheus_port | rpc_listen_port | status |
+---------------+------+-----------------+-----------------+--------+
| 192.168.79.11 | 2883 | 2884            | 2885            | active |
| 192.168.79.13 | 2883 | 2884            | 2885            | active |
+---------------+------+-----------------+-----------------+--------+
obclient -h192.168.79.11 -P2883 -uroot@proxysys -p'Welcome_1' -Doceanbase -A 
......</code></pre><p>（2）以192.168.79.11主机上的OBProxy为例，查看OBProxy进程信息并停止OBProxy</p><pre><code class="powershell">ps -ef|grep obproxy

# 输出信息如下：
Root 7574 1 ... bash /root/obproxy/obproxyd.sh /root/obproxy 192.168.79.11 2883 daemon
root 7583   1  ... /root/obproxy/bin/obproxy --listen_port 2883
root 11441 5714  ... grep obproxy

# 停止obproxy 进程和obproxyd进程
kill -9 7574
kill -9 7583

# 提示：obproxyd进程也需要停止。
# 否则当obproxy进程停止后，obproxyd会自动重启obproxy进程。</code></pre><p>（3）重启OBProxy，并通过-o选项修改配置参数的值。</p><pre><code class="powershell">cd /root/obproxy/
bin/obproxy -p 2883 -r'192.168.79.11:2881;192.168.79.12:2881;192.168.79.13:2881' \
  -o enable_cluster_checkout=True -c myob-cluster</code></pre><p>（4）连接OBProxy确认配置参数已修改。</p><pre><code class="powershell">obclient -h192.168.79.11 -P2883 -uroot@proxysys -pWelcome_1

ob&gt; show proxyconfig like 'enable_cluster_checkout' \G;

# 输出的信息如下：
*************************** 1. row ***************************
         name: enable_cluster_checkout
        value: True
         info: if enable cluster checkout, proxy will send 
               cluster name when login and server will check it
  need_reboot: false
visible_level: USER
        range: 
 config_level: LEVEL_GLOBAL
1 row in set (0.009 sec)</code></pre>]]></description></item><item>    <title><![CDATA[经销商管理系统小程序：高效赋能企业渠道管]]></title>    <link>https://segmentfault.com/a/1190000047400152</link>    <guid>https://segmentfault.com/a/1190000047400152</guid>    <pubDate>2025-11-14 17:12:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>这款经销商管理系统小程序是专为生产销售企业、微商团队打造的渠道管理工具。它以微擎系统为交付基础，提供在线交付服务，具备官方正品保障，且所有功能支持自由配置，能适配不同类型企业的个性化需求。系统核心聚焦经销商管理与授权认证，同时整合多元实用功能，助力企业简化管理流程、规范经销商体系，提升渠道运营效率。</p><p><strong>二、功能介绍</strong><br/>经销商管理：构建完善的经销商管理体系，涵盖经销商档案创建与维护，实现对经销商信息的集中化、规范化管理。</p><p>授权相关功能：支持授权查询、授权证生成，同时对接微商系统，满足企业对经销商授权认证的全流程需求。</p><p>上下级推荐：内置经销商上下级推荐机制，助力企业拓展经销商网络，优化渠道布局。</p><p>关注海报功能：附带关注海报生成能力，为企业及经销商提供便捷的品牌传播与推广工具。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>生产销售企业：适用于各类有渠道经销商的生产厂家、销售公司，用于管理全国或区域经销商团队。</p><p>微商团队：适配不同规模的微商品牌与团队，满足其多层级经销商管理、授权认证的核心需求。</p><p>行业价值<br/>简化管理流程：通过功能模块化与配置自由化，减少人工操作成本，让经销商管理更高效。</p><p>规范授权体系：清晰的授权查询与证书生成功能，避免授权混乱，保障企业与经销商的合法权益。</p><p>助力渠道拓展：上下级推荐功能为企业拓宽经销商来源，搭配关注海报功能，提升品牌传播与渠道扩张效率。</p><p>适配多元需求：支持功能自由配置，无论是小型初创企业还是大型成熟品牌，都能找到贴合自身的使用方案。</p><p><strong>四、问答环节</strong><br/>问：这款经销商管理系统小程序支持哪些交付方式？</p><p>答：支持在线交付，基于微擎系统完成交付流程。</p><p>问：系统是否适合小型微商团队使用？</p><p>答：适合，系统所有功能可自由配置，能适配不同规模的微商团队及各类企业的需求。</p><p>问：系统能否生成经销商授权证书？</p><p>答：可以，系统具备授权证生成功能，同时支持授权查询，满足授权管理需求。</p><p>问：除了经销商管理，系统还有哪些辅助功能？</p><p>答：包含上下级推荐、关注海报、微商系统对接等功能，兼顾渠道拓展与品牌传播需求。</p>]]></description></item><item>    <title><![CDATA[芒果疯狂霸屏小程序：抖音 + 微信双平台]]></title>    <link>https://segmentfault.com/a/1190000047400157</link>    <guid>https://segmentfault.com/a/1190000047400157</guid>    <pubDate>2025-11-14 17:12:10</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>芒果疯狂霸屏是一款基于微擎系统开发，融合抖音开放平台接口的新型商户引流拓客工具。它支持微信公众号部署，通过 AI 自动化视频合成技术，让终端客户扫码即可一键转发商家预设视频至抖音，帮助商家低成本实现精准获客。产品提供源码交付服务，搭配多档运营套餐与完善的素材支持，操作简单易上手，商户接受度高，同时保障服务周期内的免费更新，满足不同规模商户的引流需求。</p><p><strong>二、功能介绍</strong><br/>核心视频合成功能<br/>后台可上传视频、图片、音频等多元素材，AI 自动完成分割、加特效、合成及音频插入操作。</p><p>独家合成机制有效减少服务器压力，无需高配置即可稳定运行，同时解决视频去重问题。</p><p>合成视频可随机发布，搭配抖音平台传播优势，提升曝光效率。</p><p>引流拓客与运营功能<br/>终端客户一键扫码即可转发商家预设抖音视频，操作便捷降低参与门槛。</p><p>支持卡券模式与纯推广模式，卡券模式可引导用户领取卡券后跳转其他功能，纯推广模式直接跳转商家抖音主页。</p><p>后台具备完善的用户管理、商家管理、活动管理功能，可统计用户数量、商家数量、活动数据，支持新增活动、绑定商家、设置核销员等操作。</p><p>配套支持功能<br/>提供丰富运营素材，包括招商 PPT、展架、引导图片、宣传网站源文件、宣传视频等十余类资料。</p><p>支持增值服务，涵盖服务器环境部署、模块安装、二次开发、抖音蓝 V 认证等。</p><p>兼容 PHP5.5、PHP5.6、PHP7.1 版本，采用在线交付方式，源码加密保障官方正品权益。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>线下实体门店：包括餐饮、装饰、零售等需要本地精准引流的店铺，通过客户自发转发视频扩大门店影响力。</p><p>创业者与服务商：可通过包月、包年、代理授权等模式开展业务，为商户提供引流服务赚取收益。</p><p>各类营销活动：适用于门店开业、新品推广、节日促销等场景，通过视频传播 + 卡券激励提升活动参与度。</p><p>行业价值<br/>降低引流成本：无需大额广告投入，借助用户社交传播实现 “裂变式” 获客，提升获客性价比。</p><p>提升操作效率：商户无需专业视频制作能力，AI 自动化合成减少人力成本，终端用户操作简单促进参与率。</p><p>拓展盈利模式：为创业者提供多档运营方案，从基础服务到代理授权、团队收购，满足不同阶段发展需求。</p><p>精准对接流量：依托抖音平台流量优势与微信生态传播渠道，实现线上流量向线下门店的精准转化。</p><p><strong>四、常见问答环节</strong><br/>问：该系统适用于什么平台？</p><p>答：适用于微信公众号，需基于微擎系统部署，同时对接抖音开放平台实现视频传播功能。</p><p>问：使用系统前需要准备什么？</p><p>答：需申请抖音开放平台账号，商家可自行申请，平台会提供相关申请方案。</p><p>问：若抖音开放平台参数修改，系统无法使用该怎么办？</p><p>答：因抖音开放平台参数调整导致系统不可用，芒果团队不承担责任，不同意此条款请勿购买。</p><p>问：转发视频会对终端用户产生影响吗？</p><p>答：系统活动需提前告知商户及终端用户，视频会转发至用户抖音作品，未告知引发的后果由程序购买者承担。</p>]]></description></item><item>    <title><![CDATA[开源之谜：是理想乌托邦，还是商业新战略？]]></title>    <link>https://segmentfault.com/a/1190000047400161</link>    <guid>https://segmentfault.com/a/1190000047400161</guid>    <pubDate>2025-11-14 17:11:26</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在软件吞噬世界的今天，开源软件已成为不可或缺的基础设施。然而，围绕它的误解与困惑从未停止。它究竟是程序员理想主义的乌托邦，还是商业世界精心设计的战略？我们将通过一系列问题，揭开开源软件的层层面纱。</p><p><strong>第一问：开源软件是“用爱发电”的公益项目吗？</strong></p><p><strong>答：不，可持续的开源根本上是“商业驱动的现实主义”。</strong></p><p>许多人被开源的“开放、共享”精神所感动，认为这源于无私的奉献。然而，绝大多数能够长期存在并流行的开源项目，其根本动力是<strong>广义的盈利</strong>。这里的“盈利”并非单指软件授权的直接收入，而是指确保项目主导者（个人或企业）能够获得维持生存与发展的资源。</p><p>这包括：</p><ul><li><strong>个人作者</strong>：通过开源建立声誉，从而获得高薪工作、咨询合同、捐赠或赞助。</li><li><strong>创业公司</strong>：通过开源项目获取大量用户，再通过提供付费的企业版功能、云托管服务（SaaS）、技术支持或培训来赚钱。这就是经典的 <strong>“Open Core”（开源核心）</strong> 模式。</li><li><strong>科技巨头</strong>：通过开源来建立行业标准，降低整个生态的开发成本，从而更好地销售自己的云服务或硬件产品。</li></ul><p>没有可持续的收入来源，任何个体或组织都难以在漫长的岁月中持续投入巨大的研发和运维成本。<strong>“为爱发电”可以启动一个项目，但商业回报才能让它茁壮成长。</strong></p><p><strong>第二问：既然最终要收费，开源对客户有何实际意义？</strong></p><p><strong>答：开源为客户提供了“确定性与灵活性”，这是一种深层的商业价值。</strong></p><p>客户的核心诉求是“付钱解决问题”，这没错。但开源如何帮助客户更好地实现这一目标呢？</p><ol><li><strong>避免供应商锁定</strong>：如果软件是闭源的，客户就被牢牢绑定在单一供应商身上。对方可以随意提价、降低服务质量，客户却毫无还手之力。开源软件确保了客户<strong>永远拥有选择的自由</strong>。如果服务商A不满意，客户可以轻松切换到服务商B，甚至可以自己组织团队进行维护。</li><li><strong>供应链的确定性</strong>：开源代码是“不可撤回”的公共资产。这意味着，一旦客户基于某个开源版本构建了系统，就不会因为原公司倒闭、改变策略或停止更新而瞬间导致业务崩溃。这为企业的技术选型提供了<strong>最底层的安全感和确定性</strong>。</li><li><strong>透明与安全</strong>：代码可见意味着客户（或其委托的专家）可以自行审查安全性，确保没有隐藏的后门或致命漏洞。</li></ol><p>对于客户而言，开源并非一个虚无的口号，而是一个<strong>强大的议价工具和风险对冲工具</strong>。</p><p><strong>第三问：开源项目真的“人人平等”吗？为何总是少数人主导？</strong></p><p><strong>答：事实上的开源项目，尤其是成功的大型项目，几乎都是“精英治理”和“方法论专政”。</strong></p><p>观察GitHub上流行项目的提交图，我们会发现一个普遍现象：绝大部分代码贡献来自于极少数核心维护者。这并非偶然，而是由两个核心因素决定的：</p><ol><li><strong>能力的极端稀缺</strong>：主导一个流行的开源软件，需要主导者具备超凡的<strong>问题分析、架构抽象、模块拆解、社区治理和商业洞察</strong>等综合能力。这种“复合型天才”本身就是凤毛麟角。</li><li><strong>方法论的统一性</strong>：一个成功的开源软件，本质上是一套解决特定领域问题的、高度自洽的<strong>方法论的代码实践</strong>。项目的方向和架构，必须由这套方法论的创立者或核心理解者来把握，否则项目就会陷入混乱和分歧。</li></ol><p>因此，开源社区并非纯粹的民主制，而更像是“仁慈的独裁者”或“核心委员会”制度。这种集中式的决策机制，是保证项目在复杂性和规模增长中保持<strong>方向一致性和代码质量</strong>的关键。</p><p><strong>第四问：既然代码公开，开源作者不怕被竞争对手抄袭吗？</strong></p><p><strong>答：不怕。因为真正的护城河不是代码，而是“生态与方法论”。</strong></p><p>抄袭一个开源项目，看似简单，实则愚蠢。原因如下：</p><ul><li><strong>方法论之争</strong>：顶尖的竞争对手之间，往往存在着根本性的<strong>方法论分歧</strong>。让一个信奉A方法的团队，去全盘抄袭基于B方法构建的项目，无异于让其自我否定，这在技术和文化上都极其困难。</li><li><strong>生态系统的力量</strong>：一个成熟的开源项目，其价值远不止代码。它拥有庞大的用户社区、丰富的文档、海量的问答、成熟的工具链和认证的服务商。抄袭者能复制代码，但无法复制这整个<strong>活的生态系统</strong>。用户选择某个开源软件，正是因为信任这个生态带来的整体价值。</li><li><strong>分叉的代价</strong>：历史上，因社区内讧而“分叉”的项目很多，但能取代原项目成为新事实标准的，寥寥无几。分叉意味着社区分裂、资源分散，是一场伤筋动骨的“内战”。除非原主导层犯下致命错误且拒绝改正，否则分叉很难成功。</li></ul><p><strong>结论：开源——一场精心设计的“阳谋”</strong></p><p>经过以上层层剖析，我们可以清晰地看到，现代开源运动并非一场纯粹的理想主义盛宴，而是一套极其精妙的商业和社会协作模型。</p><p>它是一场“阳谋”：主导者光明正大地公开核心代码，通过吸引用户、构建生态、确立标准，最终在服务、支持和增值领域建立起难以撼动的护城河。在这个过程中，<strong>主导者实现了商业上的可持续回报，客户获得了自由和确定性，整个行业则因为知识的共享和协作而加速创新。</strong></p><p>这正是一种多赢的格局——开源，用开放的姿态，成就了最稳固的商业壁垒，并最终推动了整个数字世界的进步。它既是理想主义的火花，也是现实主义的选择，二者的结合，正是其强大生命力的源泉。</p>]]></description></item><item>    <title><![CDATA[步数运动宝 QQ 版本：步数变现 + 裂]]></title>    <link>https://segmentfault.com/a/1190000047400163</link>    <guid>https://segmentfault.com/a/1190000047400163</guid>    <pubDate>2025-11-14 17:10:49</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>步数运动宝 QQ 版本是一款适配微信、QQ、抖音等多平台的小程序系统，以 “运动步数” 为核心纽带，融合步数兑换、任务赚币、夺宝互动、商城购物等功能，既满足用户运动变现需求，又为商家提供爆炸式吸粉与营销转化解决方案，是兼具趣味性与商业价值的轻量化工具。</p><p><strong>一、概述总结</strong><br/>步数运动宝 QQ 版本通过将用户日常运动步数转化为可流通的 “活力币 / 步币”，构建起 “运动 - 赚币 - 兑换 - 分享” 的完整闭环。用户可通过签到、走步、看视频、邀请好友等方式积累虚拟货币，兑换现金红包、实物商品或参与夺宝活动；商家则借助步数砍价、邀请裂变、广告植入等功能实现快速吸粉、用户留存与收益增长。系统支持高度自定义配置，适配线上线下多场景营销，且提供微擎系统加密交付与持续更新服务，兼顾安全性与实用性。</p><p><strong>二、核心功能介绍</strong><br/>步数变现与兑换体系<br/>步数直接兑换活力币，支持微信现金红包、实物商品（如榨汁机、电影票）、虚拟道具（迷你币）等多类型兑换。</p><p>创新 “砍步数” 机制，用户可邀请好友助力减少兑换所需步数，强制裂变引流。</p><p>设置兑换门槛，可要求邀请指定数量新用户或完成特定任务，提升转化质量。</p><p>互动营销与夺宝玩法<br/>幸运转盘、运动币夺宝、免币夺宝三大互动模块，用户消耗步数或观看激励视频即可参与，奖品涵盖手机、现金红包等，增强用户粘性。</p><p>每日签到、答题闯关、试玩任务等领币渠道，丰富用户赚币路径，延长使用时长。</p><p>支持激励视频、插屏广告植入，为商家开辟额外创收途径。</p><p>裂变吸粉与用户运营<br/>邀请好友奖励机制，成功邀请可获得 3-10 活力币，部分商品兑换需邀请数十名新用户，实现粉丝几何级增长。</p><p>好友排行、全国榜单等社交互动功能，激发用户竞争与分享意愿。</p><p>支持关注公众号解锁提现、领取口令等功能，完成私域流量沉淀。</p><p>商城与线下核销功能<br/>内置步数换购商城，涵盖食品、美妆、电器等多品类商品，支持 “活力币兑换”“活力币 + 现金” 混合支付。</p><p>线上下单、到店自提模式，生成专属核销码，实现线上引流与线下实体交易的无缝衔接。</p><p>库存管理功能，支持每日限购与总计库存设置，灵活控制营销成本。</p><p>高度自定义配置<br/>导航栏、UI 界面、签到规则、红包金额、提现门槛等核心参数均可自定义，适配不同商家需求。</p><p>防撸羊毛机制内置，保障营销活动公平性，避免资源浪费。</p><p>支持第三方发货、关联店铺、商品分类管理等商家实用功能，简化运营流程。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>本地生活服务：餐饮、零售、影院、景区等线下门店，用于到店引流与到店核销。</p><p>电商平台：拼多多等电商渠道优惠券发放、商品促销，提升下单转化率。</p><p>品牌营销：需要快速积累用户的新品牌、新 APP，通过低成本裂变实现冷启动。</p><p>健身运动类产品：与运动场景深度绑定，提升用户活跃度与留存率。</p><p>公众号 / 自媒体：作为涨粉工具，快速积累私域流量，提升账号商业价值。</p><p>行业价值<br/>低成本吸粉：以步数为零成本载体，通过趣味玩法与实际奖励，实现单日数百甚至数万新用户增长，案例中商家单月吸粉超 50 万。</p><p>高用户粘性：将运动习惯与奖励激励结合，用户每日签到、走步、互动，形成稳定使用惯性。</p><p>多维度收益：融合商品销售、广告植入、线下引流转化等收益渠道，实现 “吸粉 - 留存 - 变现” 闭环。</p><p>线上线下融合：打通线上流量与线下实体交易，为实体店解决获客难问题，提升到店率。</p><p><strong>四、常见问题问答</strong><br/>问：用户如何获取活力币 / 步币？答：主要通过每日签到、运动步数兑换、邀请好友、观看激励视频、参与答题闯关或试玩任务等方式获取。</p><p>问：商家可以自定义哪些核心规则？答：可自定义兑换门槛、邀请好友数量要求、签到奖励金额、红包设置、提现规则、UI 界面、商品库存与限购数量等。</p><p>问：系统是否支持线下门店使用？</p><p>答：支持，用户线上下单后可选择到店自提，生成核销码后到店出示即可完成核销，实现线上引流线下消费。</p><p>问：购买后商家能获得哪些服务保障？</p><p>答：提供微擎系统在线交付，源码加密保障安全，服务周期内可免费更新，支持 PHP5.6、PHP7.1 运行环境，工作日 9:00-18:00 卖家服务支持。</p><p>问：“砍步数” 功能如何帮助商家吸粉？答：用户兑换部分商品时需邀请好友助力砍步数，好友需为新用户，且需贡献一定比例步数，强制触发社交分享，快速裂变新用户。</p>]]></description></item><item>    <title><![CDATA[智慧城市 O2O 分销系统：连接城市服务]]></title>    <link>https://segmentfault.com/a/1190000047400174</link>    <guid>https://segmentfault.com/a/1190000047400174</guid>    <pubDate>2025-11-14 17:09:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>智慧城市 O2O 分销系统是基于微擎系统开发的数字化工具，专注于智慧城市场景下的 O2O 业务分销需求。系统以在线交付为核心交付方式，提供未加密源码保障，确保官方正品品质，支持用户新购使用。它打破传统城市服务分销的地域与渠道限制，通过数字化手段搭建起高效的分销桥梁，助力相关主体快速布局智慧城市 O2O 业务，实现资源整合与高效流转。</p><p><strong>二、功能介绍</strong><br/>分销核心功能：适配智慧城市 O2O 场景，支持多渠道分销链路搭建，满足不同层级分销需求。</p><p>便捷交付体验：采用在线交付模式，购买后可快速获取系统，无需复杂线下流程，提升使用效率。</p><p>源码灵活优势：提供未加密源码，用户可根据自身业务需求进行二次开发与定制，适配个性化场景。</p><p>品质保障机制：依托官方正品保障，确保系统稳定性与安全性，减少使用过程中的技术风险。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>城市生活服务运营商：用于整合本地餐饮、家政、出行等生活服务资源，通过分销模式扩大服务覆盖范围。</p><p>智慧城市项目服务商：为智慧社区、智慧交通、智慧医疗等细分领域的项目，搭建分销渠道与推广网络。</p><p>区域商业运营主体：助力商圈、产业园区等实现线下资源线上化分销，打通服务触达用户的 “最后一公里”。</p><p>行业价值<br/>降低运营成本：数字化分销模式减少中间环节，降低渠道拓展与维护的人力、时间成本。</p><p>提升业务覆盖：打破地域限制，快速整合分散的城市服务资源，扩大业务辐射范围与市场份额。</p><p>增强灵活适配：未加密源码支持定制化开发，可根据不同智慧城市细分场景的需求调整功能，提升适配性。</p><p>保障合作信任：官方正品保障为合作双方提供安全背书，降低合作风险，提升业务推进效率。</p><p><strong>四、问答环节</strong><br/>问：该智慧城市 O2O 分销系统的交付方式是什么？</p><p>答：系统采用微擎在线交付方式，购买后可快速获取使用，无需线下交接流程。</p><p>问：系统源码是否支持二次开发？</p><p>答：支持。系统源码未加密，用户可根据自身业务需求进行二次开发与定制调整。</p><p>问：使用该系统能获得哪些品质保障？</p><p>答：系统提供官方正品保障，确保系统的稳定性、安全性与合规性，减少使用过程中的技术与合规风险。</p><p>问：该系统主要适配哪些业务场景？</p><p>答：主要适配智慧城市相关的 O2O 业务场景，包括城市生活服务分销、智慧社区项目推广、区域商业资源整合等。</p>]]></description></item><item>    <title><![CDATA[如何评估CRM软件是否适配长销售周期的业]]></title>    <link>https://segmentfault.com/a/1190000047400178</link>    <guid>https://segmentfault.com/a/1190000047400178</guid>    <pubDate>2025-11-14 17:09:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着企业业务的不断扩展，销售周期的长短已成为影响企业运营效率的重要因素。长销售周期通常指从客户初次接触到最终成交的整个过程较长，常见于专业服务、高端产品销售或高附加值行业。典型行业包括：咨询公司、汽车制造、房地产、医疗设备、教育服务等。这类业务往往需要更精细的客户管理、更复杂的销售流程和更高的客户关系维护效率。</p><p>本文将围绕<strong>CRM软件在长销售周期业务中的适配性</strong>，分析适合的CRM产品，并通过表格形式罗列5-6个产品，帮助用户在选择CRM时做出更明智的决策。</p><ul><li><ul><li>*</li></ul></li></ul><h2>一、长销售周期的业务特点</h2><p>在长销售周期的业务中，以下特点尤为突出：</p><ul><li><strong>客户关系复杂</strong>：客户可能经历多个阶段，涉及多个部门协作。</li><li><strong>销售流程长</strong>：从接洽到成交需要多轮沟通和审批。</li><li><strong>客户维护周期长</strong>：客户关系持续时间较长，需要持续的跟进和维护。</li><li><strong>数据管理复杂</strong>：涉及多环节数据，需整合和分析。</li></ul><p>因此，适合的CRM软件应具备以下功能：</p><ul><li>多角色协同管理</li><li>长周期销售流程支持</li><li>数据分析与预测功能</li><li>客户生命周期管理</li><li>高度可定制化</li></ul><h2>二、适合长销售周期的CRM产品分析</h2><p>以下为五款在长销售周期业务中表现突出的CRM产品：</p><table><thead><tr><th>序号</th><th>CRM产品名称</th><th>定位</th><th>特点</th><th>优势</th></tr></thead><tbody><tr><td>1</td><td><strong>八骏CRM</strong></td><td>国产企业级CRM</td><td>支持多角色协同、复杂销售流程、客户生命周期管理</td><td>个性化定制、强大的数据分析、多渠道整合</td></tr><tr><td>2</td><td><strong>Salesforce</strong></td><td>全球领先的CRM</td><td>云端部署、集成性强、数据可视化</td><td>灵活的销售流程配置、丰富的API、全球支持</td></tr><tr><td>3</td><td><strong>Salesforce Suite</strong></td><td>企业级CRM</td><td>包含Salesforce、Service Cloud、Marketing Cloud等模块</td><td>完整的客户旅程管理、多平台无缝集成</td></tr><tr><td>4</td><td><strong>HubSpot CRM</strong></td><td>企业级CRM</td><td>以营销为中心，支持客户旅程管理、数据分析</td><td>低门槛部署、易用性强、强大的营销功能</td></tr><tr><td>5</td><td><strong>Microsoft Dynamics 365</strong></td><td>企业级CRM</td><td>与Microsoft生态系统无缝集成，支持多角色协作</td><td>混合云部署、数据分析强大、流程自动化</td></tr><tr><td>6</td><td><strong>Pipedrive</strong></td><td>中端企业级CRM</td><td>以销售流程管理为主，适合长周期销售</td><td>简洁直观、流程可视化、自定义能力强</td></tr></tbody></table><h2>三、如何评估CRM软件是否适配长销售周期？</h2><p>在选择CRM软件时，需考虑以下几点：</p><ol><li><strong>业务流程的复杂性</strong>：CRM是否支持多角色协同和复杂销售流程？</li><li><strong>数据管理能力</strong>：是否能有效管理客户生命周期数据？</li><li><strong>数据分析与预测功能</strong>：是否提供数据分析和预测能力？</li><li><strong>可定制化与扩展性</strong>：是否能根据业务需求进行定制？</li><li><strong>技术支持与售后服务</strong>：是否有良好的技术支持和售后服务？</li></ol><h2>四、总结</h2><p>在长销售周期的业务中，CRM软件的选择至关重要。它不仅决定了销售效率，也影响客户关系的维护和企业整体运营。选择合适的CRM产品，应注重其<strong>流程管理、数据整合、数据分析、定制化能力</strong>等核心功能。</p><p>建议用户根据自身业务特点，结合实际需求和预算，综合评估CRM软件的适配性，以实现更高效的销售管理和客户关系维护。</p>]]></description></item><item>    <title><![CDATA[微商圈双 11 特惠模块：助力商户数字化]]></title>    <link>https://segmentfault.com/a/1190000047400181</link>    <guid>https://segmentfault.com/a/1190000047400181</guid>    <pubDate>2025-11-14 17:08:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>微商圈双 11 狂欢节专属模块，活动时间覆盖 11 月 1 日至 11 月 18 日，带来官方直降 50% 的半价福利，叠加领券折上折优惠。该模块基于微擎系统在线交付，提供源码加密保护与官方正品保障，聚焦微商户数字化经营需求，整合多元实用功能，为商户打造低成本、高效能的线上经营解决方案。</p><p><strong>二、功能介绍</strong><br/>核心经营功能：涵盖微餐饮、微外卖、微点餐、微餐厅等核心场景功能，满足商户线上接单、点餐服务需求。</p><p>高效运营工具：配备排号功能，优化门店就餐秩序；支持码上点餐，提升顾客点餐效率，降低商户人力成本。</p><p>安全保障服务：源码已加密，保障商户经营数据安全；官方正品保障，确保模块稳定运行无后顾之忧。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>线下餐饮门店：包括快餐、正餐等各类餐饮商户，需拓展线上点餐、外卖渠道或优化店内排号、点餐流程。</p><p>本地生活商户：希望借助微商圈流量，通过数字化工具提升经营效率、扩大服务覆盖范围的中小商户。</p><p>行业价值<br/>降低经营成本：双 11 半价优惠，大幅降低商户数字化转型门槛，无需高额投入即可获取专业工具。</p><p>提升运营效率：码上点餐、在线排号等功能减少顾客等待时间，优化服务体验，同时减轻店员工作压力。</p><p>拓展经营渠道：整合微外卖、微点餐等线上功能，帮助商户打破线下经营局限，触达更多潜在客户。</p><p><strong>四、问答环节</strong><br/>问：该模块的活动时间是什么时候？</p><p>答：活动时间为 11 月 1 日至 11 月 18 日，期间可享受双 11 半价及领券折上折优惠。</p><p>问：模块的交付方式是什么？是否需要线下安装？</p><p>答：采用微擎系统在线交付，无需线下安装，购买后可直接在线使用。</p><p>问：新购用户需要支付费用吗？</p><p>答：当前新购价格为 0 元，叠加双 11 半价优惠，无需额外支付费用即可获取。</p><p>问：该模块适用于哪些类型的商户？</p><p>答：主要适用于微餐饮、快餐等餐饮类商户，也可满足需要线上点餐、排号、外卖功能的本地生活商户。</p>]]></description></item><item>    <title><![CDATA[AI 时代的产品管理 俞凡 ]]></title>    <link>https://segmentfault.com/a/1190000047400198</link>    <guid>https://segmentfault.com/a/1190000047400198</guid>    <pubDate>2025-11-14 17:07:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><em>本文介绍了在 GenAI 时代，产品管理仍然占据主导地位的原因，以及产品经理如何增强其能力以适合 AI 时代的到来。原文：<a href="https://link.segmentfault.com/?enc=Hg3w%2Bys5Bc%2FS6B%2F66wG58Q%3D%3D.t2B%2FCRzrBo0ogti3u91yYXSKR%2Bffpup2avMlHaI7e80m3gZIuVlC%2BiTmL9Kndc33W%2BMg%2Bk1mtvCAHZ0Wf9fq%2BCiOK%2FLW5nWVmVNQ25BbT0lKkgl%2Bcgsvg1Y1XCyjEGT6dicI73gehyWdAonoc6JlMQ%3D%3D" rel="nofollow" title="Fundamental Product Management: Why it’s more important in the AI Age" target="_blank">Fundamental Product Management: Why it’s more important in the AI Age</a></em></blockquote><p>生成式人工智能（GenAI）不断扩大其在众多行业的视野，使所有领域的产品经理（PM）都有机会成为专注于 AI 并且精通技术的人。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400200" alt="" title=""/></p><p>过去几年里，GenAI 变得极为流行。具备 AI 功能的产品在各个行业纷纷涌现，就像蒲公英一样四处播散，其发展速度几乎不受控制，而且似乎还有源源不断的风投资金为其提供持续的“阳光和水分”。</p><p>从产品管理角度来看，AI 在诸多方面能够提升 PM 的工作效率和专业领域知识水平。</p><p>话虽如此，本文旨在探讨为何基本的产品管理实践仍然占据主导地位，以及这些基本原理如何能让产品管理在 AI 领域脱颖而出。产品管理作为一种实践方式，是一项适用于所有产品开发领域的核心技能，无论其是否涉及 AI。</p><p>那么，无论是在哪个行业（即便不涉及 AI），基本 PM 技能为何如此重要呢？</p><p>以下是基础产品管理仍然重要的三个主要原因，以及一些切实可行的方法，这些方法能让 PM 在充满未知、不断发展的 AI 世界中真正取得成功。</p><h2>1. 产品开发过程太过复杂</h2><p>每次经验不足的 PM 仅仅通过理论来了解产品团队的运作方式时，都会认为产品开发其实并不那么复杂 —— 这是一种新手常犯的错误。</p><p>实际情况是，通常情况下，任何时候都会有数百个不同环节在运作。这些环节可能包括基于团队的依赖关系、销售和营销支持、由海外团队负责的内部工具、需要更新的数据传输，或者那些对上述所有方面都有影响的小任务和职责。</p><p>PM 这一职位之所以特殊，是因为需要能够识别并管理那些隐藏的、不断变化的要素。他们是那种无论需要付出何种努力，都要竭尽全力助力产品发展与交付的超级英雄。在工作中，这种能力比成为团队中最顶尖的 AI 专家更为重要（尽管成为顶尖的 AI 专家也是好事！）</p><p>最近，我受邀前往位于温哥华的 Maximizer CRM 公司总部，就 AI 助手领域发表演讲。在演讲中，我阐述了全球 GenAI 市场规模从 2023 年的 500 亿美元增长至 2024 年的 1840 亿美元这一情况。演讲结束后，我被众多关于如何真正采用 AI 以改进产品开发流程的问题所包围。他们的担忧与我一致：鉴于产品开发的复杂性，采用像 Github Copilot 这样的工具真的能加快工作速度吗？我的回答始终围绕着基本要点：PM 需要保持强大的产品文化，以确保无论 AI 的采用多么复杂，都能顺利进行。</p><p>在产品开发领域，还有一点需要留意的是技术变化的速度，这一速度已经大幅加快。如果团队试图在产品中运用 GenAI，那么技术变化的速度可能会更快。AI 的能力发展迅速，有时甚至每周都会有所变化，因此 PM 必须坚守永恒的原则：理解用户需求、明确问题并提供实际价值。如果没有这些基本原则，团队可能会追逐 AI 的能力而未能解决客户的问题，这可能会导致项目失败。</p><p>GenAI 现在能够自动执行特定任务和流程，但其在成本、针对性和细微差别方面存在局限。具备深厚基础知识的真正人类 PM 会知道如何在拥有 AI 工具支持的产品团队中迅速发挥作用，并懂得如何协调所有推动项目向前发展的关键要素。这些要素可能包括：</p><ul><li><em>了解一天中最重要的 5 到 10 项事务（从 100 项中筛选得出）</em></li><li><em>明白哪些事项需要优先处理，哪些可以放低优先级</em></li><li><em>学会何时拒绝</em></li><li><em>利用电子邮件 AI 工具来过滤掉干扰信息</em></li><li><em>挑选出可以实现自动化或削减的领域或流程</em></li></ul><h2>2. 产品基础涉及人际交往能力，而 AI 无法取代。</h2><p>尽管这听起来可能有些讽刺，但随着 AI 产品开发的复杂性不断增加（这是必然趋势！），PM 在团队中展现出出色的人际交往能力就变得愈发重要了。</p><p>我坚信，强大的利益相关者管理是一项任何 PM 都绝不能放弃的关键要素，无论其技术有多么先进。大多数 PM 都会与各种各样的团队合作（比如：前端和后端开发人员、数据科学家、设计师、市场营销人员、销售人员、管理人员以及外部利益相关者）。你会依靠 GenAI 来切换情境并根据特定受众调整演示内容，还是会依靠自己强大的人际交往能力来推进这一工作呢？</p><p>用户访谈、客户关系管理、利益相关者管理，以及与产品团队就诸如功能优先级等问题进行的讨论，都应当依靠人际交往能力来推动，比如：</p><ul><li>了解社会动态，并且要友善、体贴，最重要的是要易于与工程师们合作</li><li>在无需权威的情况下发挥领导和影响力，通过倾听同事的意见并表明自己理解他们的观点（即便自己可能不同意）来实现这一点</li><li>在用户和客户访谈中表现出同理心，以便真正了解他们在使用产品时的感受和经历</li></ul><p>若想了解 PM 在长期职业生涯中应培养的重要人际交往和软技能，可以参考 PM 练习网站上的这篇文章：<a href="https://link.segmentfault.com/?enc=LBcEQ4mDUmhG1SaHjhKUxg%3D%3D.uR8AmoCXds3%2BLXT3FkM4R%2F2nJW%2FimGDIA3ALuG73kpANK%2FsS0qWZuy8IILH33d4ALYbtOIZi2LddZMWhyVe%2F87K4naH6%2B9U%2BShnqkiWTfh1CHaz%2FQt5beOpylRNr%2BlcL" rel="nofollow" title="https://www.productmanagementexercises.com/blog/6-soft-skills-every-product-manager-needs" target="_blank">https://www.productmanagementexercises.com/blog/6-soft-skills-every-product-manager-needs</a></p><h2>3. 产品基础概念有助于 PM 理解垂直应用场景</h2><p>垂直应用场景与传统应用场景在侧重点上有所不同。传统应用场景范围更广，可以涵盖任何类型的任务、JTBD（待完成任务，job to be done）或客户/用户试图达成的目标。而垂直应用场景只是更广泛的应用场景定义的一个子集，专注于更狭窄和特定的任务。</p><p>在 GenAI 的世界里，我们有所谓 <em>AI 代理</em>。AI 代理是独立的由语言模型驱动的 AI 组件，负责完成一项或一组特定任务。例如，在微软 Copilot 中，某个特定的 AI 代理可以是微软 Word 的摘要生成代理，其中语言模型被配置为仅分析 Word 文档中的内容，然后为用户生成摘要。与关注所有事情不同，该代理仅专注于以更专注的方式完成其特定应用场景。</p><p>这就引出了“垂直型 AI 代理”这一话题 —— 这其实只是对一种特定类型 AI 代理的形象化描述，即这种代理能够比更通用的 AI 代理或助手更好的完成某个特定任务或应用场景。</p><p>自 2022 年 GenAI 兴起以来，垂直 AI 市场迅速扩张，并有望达到创纪录的市场估值。据 <a href="https://link.segmentfault.com/?enc=ZsMc52bDiUCxeAlDGSxwVg%3D%3D.mUmJ0gOf1digFP09SK4sMmkTsTCEM5RLRKinLAvtGj5gleVtfpVm%2FeHPHnxx2sWURLcDnjUhc7dMROUGTTYoxh7t6gF3ykMO17HWlaZvDUY%3D" rel="nofollow" title="AIM 研究公司" target="_blank">AIM 研究公司</a>称，2024 年垂直 AI 市场规模为 51 亿美元，预计到 2030 年将增长至 471 亿美元，这一增长幅度令人惊叹。</p><p>PM 们理应引领这一增长趋势，他们需要找出每个垂直领域的应用场景，并确定每个垂直领域的智能代理都能成为该领域的专家。但要如何才能发现这些有价值的垂直应用场景呢？</p><p>我想分享一个专业方面的趣闻，那就是我们在 Planview 公司的工作经历以及所做的持续探索工作，以验证客户的垂直应用场景。在推出 <a href="https://link.segmentfault.com/?enc=r0bDFTdLONjSh5%2FPwxxdhg%3D%3D.byn8XutDFLyFL3hsLSWQZ%2BPaPKQ%2BN5LD%2Fjap1uAddRY%3D" rel="nofollow" title="Planview 公司的 AI 助手 Planview Copilot" target="_blank">Planview 公司的 AI 助手 Planview Copilot</a> 之后，团队很快发现，我们的客户群体根本不清楚能带来什么好处，而且潜在的应用场景范围广泛且各不相同。</p><p>作为 Planview Copilot 的产品经理，我选择了几个具体用例来启动产品 MVP，并以此作为假设，然后通过反馈电话和数据监测与客户进行互动，以验证这些用例是否对他们有用。在这一年里，我持续采用快速失败方法，直到某些东西引起客户共鸣：一系列基于 AI 的用例，真正为他们的日常工作流程带来了价值。对我们来说，基本实践是取得这一成功的关键，这就是为什么垂直 AI 代理市场将充满成长的烦恼和令人兴奋的活力，因为越来越多的公司开始像 Planview Copilot 那样发现这些垂直用例。</p><p>基本产品管理实践 —— 涵盖产品管理存在的根本原因的技能 —— 将是解决方案。例如，产品发现、用例优先级排序、客户关系以及反馈整合。PM 被雇用是为了在 GenAI 的世界中发现那些垂直用例，然后制定策略并兑现承诺。</p><p>我建议 PM 们继续做到以下几点：</p><ul><li>探索最常见但又极具创新性的产品及使用案例发现方法</li><li>通过不同方式激发思维，对需要解决的问题进行优先排序</li><li>深入研究 GenAI 市场，以预测变化、理解客户问题并识别其产品可能解决的核心差距</li></ul><h2>结论</h2><p>希望我已经阐明了产品管理基本原则的永恒重要性，即便在数字化 AI 时代也是如此。我相信，随着 PM 们继续分享最佳实践，并改进他们的工作流程和框架，GenAI 市场将继续提升其为客户带来的价值。其真正的影响将体现在工作效率、时间节省、娱乐以及生活质量等方面。</p><hr/><blockquote>你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。为了方便大家以后能第一时间看到文章，请朋友们关注公众号"DeepNoMind"，并设个星标吧，如果能一键三连(转发、点赞、在看)，则能给我带来更多的支持和动力，激励我持续写下去，和大家共同成长进步！</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=3vOLfhZDpw9Ik%2F7IPZDnuA%3D%3D.b5leFCwZ2RRFUP084P2FPyszHG2vrfXGoOyRf06HdMA%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[《ESP32-S3使用指南—IDF版 V]]></title>    <link>https://segmentfault.com/a/1190000047400220</link>    <guid>https://segmentfault.com/a/1190000047400220</guid>    <pubDate>2025-11-14 17:07:02</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>第四十七章 lwIP初探</h2><p>ESP32-S3是一款集成了Wi-Fi和蓝牙功能的微控制器，而lwIP（轻量级IP）是一个为嵌入式系统设计的开源TCP/IP协议栈。通过使用lwIP库，ESP32-S3可以实现与外部网络的通信，包括发送和接收数据包、处理网络连接等。因此，ESP32-S3是基于lwIP来实现网络功能的。<br/>章将分为如下几个部分：<br/>47.1 TCP/IP协议栈是什么<br/>47.2 lwIP简介<br/>47.3 WiFi MAC内核简介<br/>47.4 lwIP Socket编程接口</p><h3><strong>47.1 TCP/IP协议栈是什么</strong></h3><p>TCP/IP协议栈是一系列网络协议的总和，构成网络通信的核心骨架，定义了电子设备如何连入因特网以及数据如何在它们之间进行传输。该协议采用4层结构，分别是应用层、传输层、网络层和网络接口层，每一层都使用下一层提供的协议来完成自己的需求。由于大部分时间都在应用层工作，下层的事情不用操心。此外，网络协议体系本身很复杂庞大，入门门槛高，因此很难搞清楚TCP/IP的工作原理。如果读者想深入了解TCP/IP协议栈的工作原理，建议阅读《计算机网络书籍》。</p><h4>47.1.1 TCP/IP协议栈架构</h4><p>TCP/IP协议栈是一个分层结构的模型，每一层负责不同的网络功能。整个协议栈可以被分为四层，从上到下分别是：应用层、传输层、网络层和网络接口层。<br/>1，应用层：这是最顶层，负责处理特定的应用程序细节。在这一层，用户的数据被处理和解释。一些常见的应用层协议包括HTTP、FTP、SMTP和DNS等。<br/>2，传输层：这一层负责数据包的分割、打包以及传输控制，确保数据能够可靠、有序地到达目的地。主要的传输层协议有TCP和UDP。<br/>3，网络层：负责确定数据包的路径从源到目的地。这一层的主要协议是IP（InternetProtocol），它负责在主机之间发送和接收数据包。<br/>4，网络接口层：这是最底层，负责将数据转换为可以在物理媒介上发送的信号。这一层的协议涉及到如何将数据帧封装在数据链路层，以便在网络上进行传输。<br/>每一层都使用下一层提供的服务，同时对上一层提供服务。这种分层结构使得协议栈更加灵活，易于扩展和维护。不同层次上的协议一起工作，协调数据在计算机网络中的传输，使得不同的计算机能够相互通信。<br/>需要注意的是，TCP/IP协议栈和传统的OSI模型并不完全对应。TCP/IP协议栈是一个简化的模型，强调了实际的协议实现和因特网的实际运作方式。相比之下，OSI模型更加全面和理想化，它提供了一个框架来描述不同系统之间的交互方式。下图是IOS协议栈与TCP/IP协议栈分层架构的对比图。<br/><img width="434" height="242" referrerpolicy="no-referrer" src="/img/bVdmXK5" alt="" title=""/><br/>图47.1.1.1TCP/IP协议栈的分层结构<br/>ISO/OSI分层模型也是一个分层结构，包括七个层次，从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。虽然ISO/OSI模型为不同的系统之间的通信提供了一个理论框架，但TCP/IP协议栈更侧重于实际的协议实现和因特网的实际运作方式。注意：网络技术的发展并不是遵循严格的ISO/OSI分层概念。实际上现在的互联网使用的是TCP/IP体系结构，有时已经演变成为图1.1.1.2所示那样，即某些应用程序可以直接使用IP层，或甚至直接使用最下面的网络接口层。<br/><img width="280" height="223" referrerpolicy="no-referrer" src="/img/bVdmXK6" alt="" title="" loading="lazy"/><br/>图47.1.1.2TCP/IP体系结构另一种表示方法<br/>无论那种表示方法，TCP/IP模型各个层次都分别对应于不同的协议。TCP/IP协议栈负责确保网络设备之间能够通信。它是一组规则，规定了信息如何在网络中传输。其中，这些协议都分布在应用层，传输层和网络层，网络接口层是由硬件来实现。如Windows操作系统包含了CBISC协议栈，该协议栈就是实现了TCP/IP协议栈的应用层，传输层和网络层的功能，网络接口层由网卡实现，所以CBISC协议栈和网卡构建了网络通信的核心骨架。因此，无论哪一款以太网产品，都必须符合TCP/IP体系结构，才能实现网络通信。注意：路由器和交换机等相关网络设备只实现网络层和网络接口层的功能。</p><h4>47.1.2 TCP/IP协议栈的封包和拆包</h4><p>TCP/IP协议栈的封包和拆包是指在网络通信中，将数据按照一定的协议和格式进行封装和解析的过程。<br/>在TCP/IP协议栈中，数据封装是指在发送端将数据按照协议规定的格式进行打包，以便在网络中进行传输。在应用层的数据被封装后，会经过传输层、网络层和网络接口层的处理，最终转换成可以在物理网络上传输的帧格式。数据封装的过程涉及到对数据的分段、压缩、加密等操作，以确保数据能够可靠、安全地传输到目的地，下图描述的是封包处理流程。<br/><img width="530" height="175" referrerpolicy="no-referrer" src="/img/bVdmXK9" alt="" title="" loading="lazy"/><br/>图47.1.2.1 TCP/IP协议栈的封包<br/>数据拆包是指接收端收到数据后，按照协议规定的格式对数据进行解析和处理，还原出原始的数据。在接收到数据后，接收端会按照协议规定的层次从下往上逐层处理数据，最终将应用层的数据还原出来。数据拆包的过程涉及到对数据的重组、解压缩、解密等操作，以确保数据能够被正确地解析和处理，下图描述的是拆包处理流程。<br/><img width="482" height="165" referrerpolicy="no-referrer" src="/img/bVdmXLa" alt="" title="" loading="lazy"/><br/>图47.1.2.2 TCP/IP协议栈的拆包<br/>需要注意的是，TCP/IP协议栈的封包和拆包过程涉及到多个层次和协议的处理，需要按照协议规定的格式和顺序进行操作。在实际应用中，需要根据具体的情况选择合适的协议和格式来满足不同的需求。同时，为了保证数据的安全和可靠性，还需要采取相应的加密、压缩等措施，以避免数据被篡改或损坏</p><h3>47.2 lwIP简介</h3><p>lwIP，全称为LightweightIP协议，是一种专为嵌入式系统设计的轻量级TCP/IP协议栈。它可以在无操作系统或带操作系统环境下运行，支持多线程或无线程，适用于8位和32位微处理器，同时兼容大端和小端系统。它的设计核心理念在于保持TCP/IP协议的主要功能同时尽量减少对RAM的占用。这意味着，尽管它的体积小巧，但它能够实现完整的TCP/IP通信功能。通常，lwIP只需十几KB的RAM和大约40K的ROM即可运行，使其成为资源受限的嵌入式系统的理想选择。lwIP的灵活性使其既可以在无操作系统环境下工作，也可以与各种操作系统配合使用。这为开发者提供了更大的自由度，可以根据具体的应用需求和硬件配置进行优化。无论是在云台接入、无线网关、远程模块还是工控控制器等场景中，lwIP都能提供强大的网络支持。<br/><strong>一、lwIP特性参数</strong><br/>lwIP的各项特性，如下表所示：<br/><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdmXLf" alt="" title="" loading="lazy"/><br/>表47.2.1lwIP基本特性<br/><strong>二、lwIP与TCP/IP体系结构的对应关系</strong><br/><img width="482" height="281" referrerpolicy="no-referrer" src="/img/bVdmXLb" alt="" title="" loading="lazy"/><br/>图 47.2.1 lwIP与TCP/IP体系结构的对应图解<br/>从上图可以清晰地看到，lwIP软件库主要实现了TCP/IP体系结构中的三个层次：应用层、传输层和网络层。这些层次共同处理和传输数据包，确保了数据在网络中的可靠传输。然而，网络接口层作为TCP/IP协议栈的最底层，其功能并无法通过软件方式完全实现。这一层的主要任务是将数据包转换为光电模拟信号，以便能够在物理媒介上传输。这个过程涉及到与硬件的直接交互，包括数据的调制解调、信号的转换等，这些都是软件难以模拟或实现的。因此，虽然lwIP软件库没有实现网络接口层的功能，但通过与底层硬件的紧密配合，它仍然能够提供完整且高效的TCP/IP通信功能。这也使得lwIP成为一个适用于资源受限的嵌入式系统的理想选择。<br/>在开发过程中，开发者需要根据具体的硬件平台和需求进行相应的配置和优化，以确保lwIP能够与硬件完美配合，发挥出最佳的性能。</p><h3>47.3 WiFi MAC内核简介</h3><p>ESP32-S3 完全遵循802.11b/g/n Wi-Fi MAC协议栈，支持分布式控制功能（DCF）下的基本服务集（BSS）STA和SoftAP操作。支持通过最小化主机交互来优化有效工作时长，以实现功耗管理。ESP32-S3 Wi-Fi MAC支持4个虚拟Wi-Fi接口，同时支持基础结构型网络、SoftAP模式和Station+SoftAP混杂模式。它还具备RTS保护、CTS保护、立即块确认、分片和重组、TX/RX A-MPDU和TX/RX A-MSDU等高级功能。此外，ESP32-S3还支持无线多媒体、GCMP、CCMP、TKIP、WAPI等安全协议，并提供自动Beacon监测和802.11mc FTM支持。<br/>关于ESP32的WiFi MAC内核，官方没有提供更多学习资料。读者只需了解它扮演TCP/IP协议的网络接口层角色即可。下面作者使用一张示意图来介绍WiFi通讯示意图，如下图所示。<br/><img width="543" height="340" referrerpolicy="no-referrer" src="/img/bVdmXLe" alt="     " title="     " loading="lazy"/><br/>图47.3.1 ESP32-S3网络层次示意图<br/>从上图可以看出，ESP32-S3芯片内置WiFi MAC内核。当我们发送数据到网络时，数据首先被转化为无线信号，然后发送到该设备连接的WiFi路由器中。接着，路由器通过网线将数据传输到目标主机，从而完成数据传输操作。以下是作者对于无线网络传输的描述。<br/>1，数据转化为无线信号：当ESP32-S3想要发送数据到网络时，它首先会将数据封装到一个无线传输帧中。这一过程涉及到将数据转化为可以在无线介质上传输的格式。<br/>2，发送到WiFi路由器：封装后的无线信号然后被发送到ESP32-S3连接的WiFi路由器。WiFi路由器充当一个中间设备，负责将无线信号转换为有线网络信号（如果目标主机是通过有线网络连接的）或直接转发无线信号（如果目标主机也是通过WiFi连接的）。<br/>3，路由器传输数据：WiFi路由器接收到无线信号后，会进一步处理它。如果目标主机是通过有线网络连接的，路由器会将无线信号转换为有线网络信号，并通过网线将其传输到目标主机。如果目标主机也是通过WiFi连接的，路由器会直接转发无线信号到目标主机。<br/>4，完成数据传输：最终，目标主机接收到路由器发送的有线网络信号或无线信号，并将其解析为原始数据。这样，整个数据传输过程就完成了。<br/>在整个过程中，ESP32-S3的WiFi MAC内核起着核心的作用，它负责管理无线连接、封装和解封装数据以及与WiFi路由器进行通信。</p><h3>47.4 lwIP Socket编程接口</h3><p>lwIP作者为了方便开发者将其他平台上的网络应用程序移植到lwIP上，并让更多开发者快速上手lwIP，作者设计了三种应用程序编程接口：RAW编程接口、NETCONN编程接口和Socket编程接口。然而，由于RAW编程接口只能在无操作系统环境下运行，因此对于内嵌FreeRTOS操作系统的ESP32来说，无法使用这个编程接口。尽管Socket编程接口是由NETCONN编程接口封装而成，但是该接口非常简易的实现网络连接（作者推荐使用此接口）。需要注意的是，由于受到嵌入式处理器资源和性能的限制，部分Socket接口并未在lwIP中完全实现。因此，为了实现网络连接，推荐使用Socket API。<br/>下面作者简单介绍一下lwIP Socket编程接口常用的API函数。这些API函数如下所示。<br/>(1) socket函数<br/>该函数的原型，如下源码所示：</p><pre><code>#define socket(domain,type,protocol)         lwip_socket(domain,type,protocol)</code></pre><p>向内核申请一个套接字，本质上该函数调用了函数lwip_socket，该函数的参数如下表所示：<br/><img width="723" height="319" referrerpolicy="no-referrer" src="/img/bVdmXLg" alt="" title="" loading="lazy"/><br/>表47.4.1函数Socket()相关形成描述<br/>(2) bind函数<br/>该函数的原型，如下源码所示：</p><pre><code>#define bind(s,name,namelen)      lwip_bind(s,name,namelen)
int bind(int s, const struct sockaddr *name, socklen_t namelen)
</code></pre><p>该函数与netconn_bind函数一样，用于服务器端绑定套接字与网卡信息，本质上就是对函数netconn_bind再一次封装，从上述源码可以知道参数name指向一个sockaddr结构体，它包含了本地IP地址和端口号等信息；参数namelen指出结构体的长度。结构体sockaddr定义如下源码所示：</p><pre><code>struct sockaddr {
u8_t        sa_len;             /* 长度 */
sa_family_t sa_family;        /* 协议簇 */
  char        sa_data[14];       /* 连续的 14 字节信息 */
};
struct sockaddr_in {
  u8_tsin_len;             /* 长度 */
  u8_tsin_family;              /* 协议簇 */
  u16_tsin_port;               /* 端口号 */
  struct in_addr sin_addr;      /* IP地址 */
  char sin_zero[8];
};</code></pre><p>可以看出，lwIP作者定义了两个结构体，结构体sockaddr中的sa_family指向该套接字所使用的协议簇，本地IP地址和端口号等信息在sa_data数组里面定义，这里暂未用到。由于sa_data以连续空间的方式存在，所以用户要填写其中的IP字段和端口port字段，这样会比较麻烦，因此lwIP定义了另一个结构体sockaddr_in，它与sockaddr结构对等，只是从中抽出IP地址和端口号port，方便于用于的编程操作。<br/>(3) connect函数<br/>该函数与netconn接口的netconn_connect函数作用是一样的，因此它是被netconn_connect函数封装了，该函数的作用是将Socket与远程IP地址和端口号绑定，如果开发板作为客户端，通常使用这个函数来绑定服务器的IP地址和端口号，对于TCP连接，调用这个函数会使客户端与服务器之间发生连接握手过程，并建立稳定的连接；如果是UDP连接，该函数调用不会有任何数据包被发送，只是在连接结构中记录下服务器的地址信息。当调用成功时，函数返回0；否则返回-1。该函数的原型如下源码所示：</p><pre><code>#define connect(s,name,namelen)    lwip_connect(s,name,namelen)
int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen);</code></pre><p>(4) listen函数<br/>该函数和netconn的函数netconn_listen作用一样，它是由函数netconn_listen封装得来的，内核同时接收到多个连接请求时，需要对这些请求进行排队处理，参数backlog指明了该套接字上连接请求队列的最大长度。当调用成功时，函数返回0；否则返回-1。该函数的原型如下源码所示：</p><pre><code>#define listen(s,backlog)   lwip_listen(s,backlog)
int lwip_listen(int s, int backlog);</code></pre><p>注意：该函数作用于TCP服务器程序。<br/>(5) accept函数<br/>该函数与netconn_accept作用是一样的，当接收到新连接后，连接另一端（客户端）的地址信息会被填入到地址结构addr中，而对应地址信息的长度被记录到addrlen中。函数返回新连接的套接字描述符，若调用失败，函数返回-1。该函数的原型如下源码所示：</p><pre><code>#define accept(s,addr,addrlen)     lwip_accept(s,addr,addrlen)
int lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p>注意：该函数作用于TCP服务器程序。<br/>(6) send()/sendto()函数<br/>该函数是被netconn_send封装的，其作用是向另一端发送UDP报文，这两个函数的原型如下源码所示：</p><pre><code>#define send(s,dataptr,size,flags)    lwip_send(s,dataptr,size,flags)
#definesendto(s,dataptr,size,flags,to,tolen)   lwip_sendto(s,dataptr,size,flags,to,tolen)
ssize_t lwip_send(int s, const void *dataptr, size_t size, int flags);
ssize_t lwip_sendto(int s, const void *dataptr, size_t size, int flags,   
const struct sockaddr *to, socklen_t tolen);</code></pre><p>可以看出，函数sendto比函数send多了两个参数，该函数如下表所示：<br/><img width="723" height="206" referrerpolicy="no-referrer" src="/img/bVdmXLh" alt="" title="" loading="lazy"/><br/>表47.4.2 函数sendto()和send()形参描述<br/>(7) write函数<br/>该函数用于在一条已经建立的连接上发送数据，通常使用在TCP程序中，但在UDP程序中也能使用。该函数本质上是基于前面介绍的send函数来实现的，其参数的意义与send也相同。当函数调用成功时，返回成功发送的字节数；否则返回-1。<br/>(8) read()/recv()/recvfrom()函数<br/>函数recvfrom和recv用来从一个套接字中接收数据，该函数可以在UDP程序使用，也可在TCP程序中使用。该函数本质上是被函数netconn_recv的封装，其参数与函数sendto的参数完全相似，如下表所示，数据发送方的地址信息会被填写到from中，fromlen指明了缓存from的长度；mem和len分别记录了接收数据的缓存起始地址和缓存长度，flags指明用户控制接收的方式，通常设置为0。两个函数的原型如下源码所示：</p><pre><code>#define recv(s,mem,len,flags)       lwip_recv(s,mem,len,flags)
#definerecvfrom(s,mem,len,flags,from,fromlen)  lwip_recvfrom(s,mem,len,flags,from,fromlen)
ssize_t lwip_readv(int s, const struct iovec *iov, int iovcnt);
ssize_t lwip_recvfrom(int s, void *mem, size_t len, int flags,
                          struct sockaddr *from, socklen_t *fromlen);
#define read(s,mem,len) lwip_read(s,mem,len)
ssize_t lwip_read(
int s,
void *mem, size_t len);</code></pre><p><img width="723" height="216" referrerpolicy="no-referrer" src="/img/bVdmXLi" alt="" title="" loading="lazy"/><br/>表47.4.3 函数recv()和recvfrom()形参描述<br/>(9) close函数<br/>函数close作用是关闭套接字，对应的套接字描述符不再有效，与描述符对应的内核结构lwip_socket也将被全部复位。该函数本质上是被netconn_delete的封装，对于TCP连接来说，该函数将导致断开握手过程的发生。若调用成功，该函数返回0；否则返回-1。该函数的原型如下源码所示：</p><pre><code>#define close(s)     lwip_close(s)
int lwip_close(int s);</code></pre>]]></description></item><item>    <title><![CDATA[如何用数据驱动与智能调控玩转点焊质量管理]]></title>    <link>https://segmentfault.com/a/1190000047400255</link>    <guid>https://segmentfault.com/a/1190000047400255</guid>    <pubDate>2025-11-14 17:06:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>点焊，听起来像是产线上最“硬核”的工艺环节之一，但它恰恰是现代制造质量管控中最值得“啃”的硬骨头。尤其在汽车焊接、家电钣金连接等场景中，一个焊点的质量不仅牵涉到结构强度，更直接关联整车安全性与产品生命周期。然而，传统依赖老师傅经验、间歇性抽检的管理方式，显然已难以应对高速、多品种、小批次的柔性制造需求——数据化、实时化、智能化，才是真正提升点焊质量的新引擎。<br/>当前的点焊质量管理，痛点非常明确：虚焊、过烧、焊核尺寸不稳定等问题往往无法实时识别，等到后期整装甚至终端使用时才发现，代价已是数十倍甚至百倍的返修与品牌损耗。要系统化解构这一问题，就不得不引入工业物联网（IIoT）架构与边缘智能。通过在焊枪上部署高精度电流/电压传感器、压力检测模块和热电偶，实时采集每一次点焊的完整参数序列，再借助机器学习算法建立动态质量预测模型，我们完全可以在焊接发生后的毫秒之间做出质量判决与工艺反馈。<br/>以某工厂采用广域铭岛点焊质量优化系统为例，该系统集成了各品牌焊机过程数据、破解、涡流、复检抽检数据，集成业务规则、实现数据分析、问题报警、问题管理等，通过算法实现了质量判定、飞溅率管理、参数推荐等功能。焊接合格率提升0.5%，焊接批量问题0次，减少人员8万元/年，减少沟通时间、数据查询、数据分析，问题管理跟踪时间，节约人天费用18.86万元/年<br/>家电行业同样从中尝到“甜头”。某家电巨头在洗衣机内筒焊接产线中接入了工艺质量管理平台，通过对多台焊机协同数据的整合分析，系统能够自动识别因电网波动或电极帽磨损导致的能量输出异常，并实时微调焊接参数或发出预警提示。结果产线虚焊率下降40%以上，客户投诉率大幅降低，工程师也从频繁的人工点检中解放出来，转向更高价值的工艺分析与优化。<br/>当然，落地这类系统也并非毫无挑战。多源异构数据的低延迟融合、高并发实时处理、工艺-质量映射模型的精准训练，以及既懂焊接工艺又熟悉数据算法的跨职能人才，都是推进智能化管理中必须打通的“堵点”。正因如此，一批优秀的工业互联网平台如广域铭岛，开始提供从数据采集、边缘计算到云平台分析的一体化点焊质量管理方案，帮助企业低门槛部署全流程质量管控能力。<br/>未来，随着5G和算力网络在工业场景的普及，点焊质量优化将进一步走向预测性调控和工艺数字孪生。系统不仅可以实时干预，更可基于历史与实时数据模拟不同材料、不同工况下的焊接结果，自主生成工艺参数库甚至支持无人化决策。毫无疑问，拥抱智能化质量管理，已逐渐成为制造企业能否在产业升级中占据话语权的关键赛点。</p>]]></description></item><item>    <title><![CDATA[提升流式开发效率与易用性：Kitex/H]]></title>    <link>https://segmentfault.com/a/1190000047400285</link>    <guid>https://segmentfault.com/a/1190000047400285</guid>    <pubDate>2025-11-14 17:05:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>CloudWeGo 作为字节跳动开源的高性能微服务框架体系，核心组件 Kitex 与 Hertz 以其原生的流式处理能力，已成为大模型应用开发的核心技术支撑。两者通过 SSE、gRPC 及自研 TTHeader Streaming 等多协议适配，完美契合大模型 "一问多答" 的交互需求，广泛应用于 Chat、语音交互等各类大模型场景。</p><p>本文基于 Kitex / Hertz 项目 Maintainer 王宇轩在 CloudWeGo 四周年技术沙龙演讲内容整理，系统阐述过去一年里 CloudWeGo 开源的微服务框架 Kitex 和 Hertz，如何提升流式开发效率与易用性，为大模型应用保驾护航。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400287" alt="" title=""/><br/>图为 Kitex / Hertz 项目 Maintainer 王宇轩</p><p><strong>一、大模型应用框架概览：流式能力与经典链路</strong></p><p>随着大模型应用的快速发展，微服务架构已成为其核心支撑模式，而 CloudWeGo 开源的 Kitex 与 Hertz 两大微服务框架，通过原生流式能力为大模型应用提供了关键技术支撑。</p><p>Kitex 与 Hertz 紧跟技术趋势，针对大模型交互场景提供了流式处理能力，以帮助用户高效构建应用：Hertz 支持 SSE 协议，负责与端上直接交互；Kitex Streaming 则支持广为人知的 gRPC 协议及自研流式协议 TTHeader Streaming，专注处理服务间的流式通信，两者均能完美适配大模型"一问多答"交互模式。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400288" alt="" title="" loading="lazy"/></p><p>在微服务架构中，基于 Kitex 与 Hertz 的大模型应用链路具备清晰的逻辑架构，以经典 Chat 场景为例，API 服务、Chat 服务与 LLM 通过流式接口实现串联，最终达成一问多答的交互效果：</p><ul><li>API 服务通过 SSE 接口与端上交互，借助 Kitex 流式 Client 访问 Chat 服务；</li><li>LLM 根据部署环境差异，灵活暴露 SSE 接口或 RPC 流式接口，Chat 服务对应使用 SSE Client 或 Kitex 流式 Client 对接。</li></ul><p>该架构设计满足了大模型应用的交互需求，逻辑清晰流畅。但在实际开发落地过程中，流式能力所带来的工程实践问题接踵而至。</p><p><strong>二、流式工程实践增强：保障应用稳定落地</strong></p><p>为应对大模型应用在流式开发中遇到的实际挑战，服务框架团队围绕会话中断、流式异常与流式监控这三个核心场景，对 Kitex 和 Hertz 的流式工程实践进行了强化，全方位保障应用的稳定运行。</p><p><strong>1.会话中断控制：强化 Stream 生命周期管理</strong></p><p>实际场景中可能会因为用户中途修改 Prompt 终止会话、响应超时导致用户放弃、网络不稳定引发连接断开等因素导致会话中断。及时感知并终止无效会话，能有效节省 LLM 资源。对此，Kitex 与 Hertz 的流式接口通过实现统一的 golang context cancel 语义，达成 Stream 生命周期的精准控制：</p><ul><li><strong>Kitex gRPC 支持跨服务与同服务场景的 Stream 生命周期管理</strong>：跨服务场景下，上游服务主动调用 cancel 后，会通过 HTTP/2 Rst Frame 终止下游 Stream；同服务场景下，下游 Stream 的生命周期完全受上游 Stream 控制，上游 cancel 会触发下游级联终止。</li><li><strong>Hertz 原生支持 SSE 协议，对齐 Kitex gRPC 的 context cancel 能力</strong>：让流式链路从端上到服务、服务到大模型的生命周期控制形成闭环。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400289" alt="" title="" loading="lazy"/></p><p><strong>2.流式异常优化：提升问题定位效率</strong></p><p>流式交互中，gRPC-Go 经典报错 "rpc error: code = 1, context is canceled" 存在明显局限性 ------ 仅能描述结果，无法明确具体错误原因，易导致问题误判（如误归因为 LLM 服务故障）。该报错可能对应用户主动终止会话，级联 cancel 等多种场景，排查难度较大。为解决这一问题，服务框架团队优化了 Kitex gRPC 的错误描述机制，明确报错诱因，帮助开发者快速定位异常根源，大幅降低问题排查成本。</p><ul><li>错误细分为流级别错误和连接级别错误</li><li>丰富错误描述，精确对应具体错误场景</li><li>新增 "triggered by" 字段，明确触发错误的服务</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400290" alt="" title="" loading="lazy"/></p><p><strong>3.流式监控升级：完善消息观测能力</strong></p><p>传统 Ping-Pong 模型的监控指标（QPS、Latency）虽可统一适配为 "Stream 创建至生命周期结束" 的指标，但难以满足流式场景的精细化观测需求。对此，服务框架团队对监控能力进行双重升级：</p><ul><li><strong>新增 Recv/Send QPS 指标</strong>：通过 StreamEventReport 接口扩展，每次调用 Recv 或 Send 方法时自动触发打点，精准捕捉流式消息交互频率。</li><li><strong>增强流式Trace 能力</strong>：新增 StreamSendHeader/StreamRecvHeader、StreamSendRst/StreamRecvRst、StreamSendTrailer/StreamRecvTrailer 等关键状态事件，清晰刻画 Stream 状态流转，为建流失败、非预期报错等疑难问题提供排查依据。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400291" alt="" title="" loading="lazy"/></p><p>通过会话中断控制、流式异常优化、流式监控升级三大实践增强，Kitex 与 Hertz 有效解决了大模型应用的核心落地阻碍。但随着用户规模与实践案例的增加，服务框架团队发现现有流式接口仍存在学习使用成本高、复杂级联 cancel 链路排查难等问题。因此，进一步优化流式接口、推出自研流式协议并增强流式生态，推动流式能力的易用性与用户体验迈上新台阶。</p><p><strong>三、流式能力与生态升级：从可用到好用</strong></p><p>为解决现有流式接口的使用痛点，推动流式能力从 "可用" 向 "好用" 跨越，服务框架团队从接口设计优化、自研协议研发、生态工具补充三个维度，对 Kitex 与 Hertz 的流式能力及生态进行全面升级。</p><p><strong>1. 现有流式接口的核心痛点</strong></p><p>当前流式接口在设计与使用中存在两类关键问题，导致用户学习和使用成本偏高：</p><ul><li><strong>gRPC-Go 接口设计的局限性</strong>：Server 侧流式 Handler 未直接暴露 context 参数，需通过 Stream.Context () 获取；Stream 的 Recv、Send 方法也未暴露 context 参数，无法细粒度控制超时等逻辑。虽然 gRPC-Go 官方认可统一 context 设计，但未计划推出 v2 接口优化，Kitex gRPC 因遵循该设计也存在相同问题。</li><li><strong>Kitex 自身能力透出的适配问题</strong>：Kitex 最初基于 Ping-Pong 模型设计，未充分考虑流式接口需求。一方面 Options 配置作用域模糊，部分配置仅对 Unary 接口生效，需用户在实践中探索确认；另一方面，中间件只适配 Unary 接口语义（接收请求→处理→返回响应），流式场景中 resp 始终为 nil，语义差异增加理解成本，导致流式接口未能得到完全支持。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400292" alt="" title="" loading="lazy"/></p><p><strong>2. StreamX 接口优化：降低使用门槛</strong></p><p>针对上述痛点，服务框架团队推出 StreamX 流式接口，通过设计革新与能力升级提升易用性：</p><ul><li><strong>统一 context 设计</strong>：Server 侧 Unary 接口与流式接口一致暴露 context 参数，Stream 对象的 Recv、Send 方法也新增 context 参数，支持细粒度控制（如超时设置），符合用户使用直觉。</li><li><strong>流式接口 "适应性" 升级</strong>：拆分 Options 配置为 WithUnary（仅 Unary 接口生效）与 WithStream（仅流式接口生效）两类，保持原有配置兼容性；同时提供 Stream、Recv、Send 三种专属中间件，参数与作用域直观清晰，适配流式场景语义。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400293" alt="" title="" loading="lazy"/></p><p><strong>3.自研协议 TT Header Streaming改变 gRPC 痛点</strong></p><p>gRPC 难以排查复杂级联 cancel 链路，也无法有效支持 context.WithCancelCause，本质在于 gRPC 基于 HTTP/2 Rst Stream Frame 实现 context cancel 功能，只支持传递 ErrCode，无法携带其它元信息。</p><p>服务框架团队为了改善 gRPC 痛点，推出自研协议 TTHeader Streaming，允许 Rst Frame 携带 Header 与 Payload。</p><ul><li><strong>Rst Frame 携带链路追踪信息，高效应对级联 cancel</strong>：类似 HTTP via，TTHeader Streaming 在 Rst Frame 头部会携带 ttscp(ttheader streaming cancel path)，跟踪完整的 cancel 链路，从而精确定位发起 cancel 的第一跳服务。</li><li><strong>支持 context.WithCancelCause，传递自定义 cancel 异常</strong>：TTHeader Streaming 支持在 Rst Frame 中携带 payload，从而承载由 context.WithCancelCause 注入的自定义 cancel 异常，用户可以实现更为丰富的 cancel 语义。</li></ul><p><strong>4. 完备的生态支持：流式泛化能力增强</strong></p><p>在原有流式调用能力的基础上，Kitex 进一步完善了泛化生态支持，使流式交互在本地调试、压测及多协议网关等场景下也能无缝使用。</p><ul><li>支持流式泛化 Client，一个泛化 Client 搞定流式/非流式场景</li><li>支持流式泛化 Server，高效处理 二进制/JSON/Map 数据</li><li>Kitexcall 支持流式调用，方便本地调试流式接口</li></ul><p><strong>四、总结与展望</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400294" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400295" alt="" title="" loading="lazy"/></p><p>本次分享围绕三大板块展开：一是大模型应用框架的流式能力与经典链路，明确 Kitex 与 Hertz 的核心支撑作用；二是流式工程实践增强，通过会话中断控制、异常定位优化、监控能力升级，保障大模型应用稳定落地；三是流式能力与生态升级，以 StreamX 新接口、自研 TTHeader Streaming 协议、完善流式生态，实现流式能力从 "可用" 到 "好用" 的跨越。展望未来，服务框架团队将开源流式最佳工程实践并发布配套使用指南，推出 Metrics/Trace 的 open-telemetry 版本，持续迭代 TTHeader Streaming 协议、优化 WebSocket 支持，进一步完善流式生态，为更多大模型应用提供高效、可靠的技术支撑。</p><p><strong>活动回顾资料</strong></p><ul><li><strong>视频回看</strong> ：<a href="null" target="_blank">https://space.bilibili.com/3494360534485730/lists/6518781?type=season</a></li><li><strong>演讲PPT下载</strong> ：<a href="null" target="_blank">https://github.com/cloudwego/community/tree/main/meetup/2025-09-20</a></li></ul>]]></description></item><item>    <title><![CDATA[专题：2025构建全自动驾驶汽车生态系统]]></title>    <link>https://segmentfault.com/a/1190000047400325</link>    <guid>https://segmentfault.com/a/1190000047400325</guid>    <pubDate>2025-11-14 17:05:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>原文链接：<a href="https://link.segmentfault.com/?enc=oIWvxrXzhccKGRjGSXKTrw%3D%3D.gYUdH3bByRRGuZG6Nbl5a4YtphDrPDZ3VOnzY3i%2FUPk%3D" rel="nofollow" title="https://tecdat.cn/?p=44316" target="_blank">https://tecdat.cn/?p=44316</a>  <br/>原文出处：拓端抖音号@拓端tecdat</p><h3><a name="t1" target="_blank"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400327" alt="封面" title="封面"/></h3><p>2025年，智能驾驶正站在“技术落地”与“规模商业化”的十字路口——自主品牌城市NOA渗透率已达9.1%，15万级车型标配激光雷达成为常态，但深圳车主因系统未识别非常规红绿灯追尾、特斯拉FSD在京实线变道被罚的案例，却暴露了“技术跑在前，规则跟不上”的行业矛盾。</p><p>本报告洞察基于《东吴证券：2025年主流车企城市NOA试驾报告》《亿欧智库：2024中国智能驾驶城区NOA功能测评报告》《Barclays：中国Robotaxi行业现状报告》及文<strong>末80+份智能驾驶行业研究报告的数据，最新报告合集及解读实时更新已分享在交流群，阅读原文进群咨询、定制数据报告和600+行业人士共同交流和成长。</strong></p><p>报告将从“技术演进-产业链竞争-市场增长-成本突围-用户接受度”五大维度，拆解华为、特斯拉、地平线等厂商的核心动作，为车企研发、出行运营商、智能驾驶创业者提供可落地的决策参考，看清行业机遇与隐藏风险。</p><h4><a name="t2" target="_blank"/>一、智能驾驶的“逆袭路”：从“依赖进口”到“国产主导”</h4><p>智能驾驶不是一夜爆发的技术。早年中国企业在L1-L2辅助驾驶阶段，还需依赖英伟达芯片、Mobileye算法；2020年起，地平线J系列芯片量产、禾赛激光雷达价格腰斩，国产厂商开始打破外资垄断；2024年更是关键转折点——武汉Robotaxi实现“招手即停”，哈弗、小鹏等品牌将L2+智驾车型下探至10万价格带，行业正式从“技术跟随”迈入“商业领跑”。  <br/>这背后不只是技术突破，更是产业链协同的结果：激光雷达从10万美元降至500美元，智驾芯片国产化率超60%，加上政策开放17个国家级测试区，中国智能驾驶正在形成“技术-成本-政策”的三角支撑。</p><h4><a name="t3" target="_blank"/>二、产业链核心战：芯片与激光雷达的“国产突围”</h4><p>智能驾驶的竞争，本质是“关键部件”的竞争。当前产业链的核心焦点，集中在智驾芯片和激光雷达两大领域，国产厂商已实现从“跟跑”到“领跑”的跨越。</p><h5>（一）智驾芯片：英伟达仍领先，但地平线、华为正在“抢份额”</h5><p>2024年中国智驾芯片市场呈现“一超多强”格局：英伟达以39%的份额占据高端市场（如特斯拉、小鹏高端车型），但其芯片成本高、本地化服务响应慢的问题逐渐凸显。而国产厂商正在快速崛起——地平线凭借11%的份额成为行业新势力（配套长城、奇瑞），华为以17%份额绑定高端车型（如问界M9），特斯拉自研芯片占23%（仅供自家车型），国产芯片合计已占61%。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400328" alt="" title="" loading="lazy"/>  <br/>2024年中国智驾芯片厂商市场份额横向比例条形图表A1数据及PDF模板已分享到会员群  <br/>3秒解读：国产芯片已占据半壁江山，地平线、华为成为英伟达最强对手。  <br/>对应人群行动建议：车企研发可优先评估地平线J6P、华为昇腾610，降低对英伟达依赖；创业者可聚焦国产芯片的算法适配赛道，比如为地平线芯片开发低成本NOA算法。</p><h5>（二）激光雷达：中国厂商垄断全球88%份额，成本降到“15万车型用得起”</h5><p>全球车载激光雷达市场早已是“中国主场”：禾赛科技、速腾聚创各占29%份额（配套理想、小鹏），图达通以21%份额绑定蔚来，华为（9%）、法雷奥（10%）紧随其后，中国厂商合计占据88%市场。更关键的是，国产厂商将激光雷达价格从2020年的10万美元，压到2024年的1500元，直接推动广汽埃安RT、小鹏P7+等15-20万车型规模化搭载。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400329" alt="" title="" loading="lazy"/>  <br/>2023年全球车载激光雷达厂商市场份额灰底比例条形图表A2数据及PDF模板已分享到会员群  <br/>3秒解读：中国厂商靠成本优势垄断激光雷达市场，成为智能驾驶规模化的“关键推手”。  <br/>对应人群行动建议：出行运营商采购车辆时，优先选择搭载禾赛、速腾激光雷达的车型，后续维修成本更低；供应链企业可布局激光雷达核心部件（如发射端芯片），分享国产化红利。</p><hr/><p><strong>相关文章</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400330" alt="" title="" loading="lazy"/></p><h3><a name="t4" target="_blank"/>专题：2025城市NOA智能驾驶研究报告|附70+份报告PDF 汇总下载</h3><p>原文链接：<a href="https://link.segmentfault.com/?enc=ZCpZ1PFgjti2O%2Bb0M7g2Ew%3D%3D.Q1l2Aw82F2PuS5T0hZTckQa1sOGN68RaInfLiiQR4jA%3D" rel="nofollow" title="https://tecdat.cn/?p=43592" target="_blank">https://tecdat.cn/?p=43592</a></p><hr/><h4><a name="t5" target="_blank"/>三、市场增长预测：2030年Robotaxi渗透率达7%，这些城市将先爆发</h4><p>智能驾驶市场正呈现“高端先行、平价普及”的清晰趋势，而增长潜力最大的赛道，当属Robotaxi（机器人出租车）和共享自动驾驶（SAV）。</p><h5>（一）ADASSoC：中国市场五年增长3倍，成全球核心动力</h5><p>作为智能驾驶的“大脑”，ADAS SoC市场正在快速扩张：全球规模将从2023年的275亿元增至2028年的925亿元，中国市场占比从51.3%提升至53.6%，年复合增长率达28%。这背后是中国L2+车型渗透率的快速提升——2024年自主品牌L2+渗透率已达16%，远超全球平均水平。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400331" alt="" title="" loading="lazy"/>  <br/>ADAS SoC市场规模双轴图表B1数据及PDF模板已分享到会员群  <br/>3秒解读：中国ADAS SoC市场增速全球领先，本土需求（如城市NOA）是核心驱动力。  <br/>对应人群行动建议：芯片厂商可加大7nm工艺芯片研发（如地平线J6P），聚焦L2++以上高端市场；投资者可关注与华为、地平线合作的Tier 1供应商（如德赛西威）。</p><h5>（二）高阶智驾渗透率：中国2030年达80%，甩开全球平均水平</h5><p>中国高阶智驾（L2+及以上）的渗透速度，正在远超全球：2023年渗透率仅7%，2030年将飙升至80%，而全球同期仅64%。这得益于三大因素：政策开放测试道路（如北京允许Robotaxi全时段运营）、智算数据平台建设（如国家智能网联汽车创新中心平台）、平价智驾车型普及（如哈弗枭龙MAX二代13.88万起）。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400332" alt="" title="" loading="lazy"/>  <br/>高阶智驾渗透率百分比堆叠面积图表C1数据及PDF模板已分享到会员群</p><h5>（三）Robotaxi：2035年市场价值650亿美元，武汉成“示范标杆”</h5><p>2035年全球全自动驾驶车辆市场价值将达1820亿美元，其中Robotaxi以650亿美元占据最大份额，成为共享出行的主流形态。中国市场表现更突出：2030年武汉Robotaxi渗透率将达30%（因政府优先开放路权），北京、上海、广州等一线城市超10%，全国总体渗透率达7%，远超其他国家。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400333" alt="" title="" loading="lazy"/>  <br/>2035年全自动驾驶车辆市场价值预测瀑布图表市场增长-1数据及PDF模板已分享到会员群  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400334" alt="" title="" loading="lazy"/>  <br/>2030年中国机器人出租车渗透率预测刻度线图表市场增长-2数据及PDF模板已分享到会员群  <br/>3秒解读：Robotaxi是智能驾驶商业化的“最大蛋糕”，中国一线城市将先实现盈利。  <br/>对应人群行动建议：出行运营商可优先布局武汉、广州，对接当地政府申请Robotaxi运营资质（如滴滴已在武汉获牌）；地方政府可借鉴武汉“路权开放+场站补贴”模式，吸引车企落地。</p><h5>（四）共享自动驾驶（SAV）：2040年乐观情景超2600万辆，城市化是关键</h5><p>共享自动驾驶车辆（SAV）的增长将呈“指数级”：2035年保守估计560万辆，乐观情景950万辆；2040年保守1570万辆，乐观突破2640万辆。这背后是城市化进程加快（中国城市化率2030年将达70%）、用户对共享出行接受度提升（2023年中国用户接受度81%），以及技术成熟（如Momenta端到端技术适配15万级车型）。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400335" alt="" title="" loading="lazy"/>  <br/>共享自动驾驶车辆数量预测气泡图表市场增长-3数据及PDF模板已分享到会员群</p><h4><a name="t6" target="_blank"/>四、成本突围：中国厂商把Robotaxi成本降到“全球最低”</h4><p>智能驾驶要规模化，成本控制是“生死线”。中国厂商通过技术迭代与规模效应，已经实现制造成本与运营成本的双重突围，成为全球成本控制的标杆。</p><h5>（一）制造成本：五年降80%，2025年Robotaxi BOM成本仅3.75万美元</h5><p>中国Robotaxi的制造成本正在“断崖式”下降：2020年还需20万美元/辆，2025年降至3.75万美元，2030年目标3万美元。核心驱动是关键部件降价：激光雷达从10万美元降至500美元，智驾芯片国产化后成本降30%（如地平线J6P比英伟达Orin-X便宜30%），加上电池成本下降，整体BOM成本快速下探。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400336" alt="" title="" loading="lazy"/>  <br/>中国机器人出租车制造成本趋势半圆面积比例图表成本分析-1数据及PDF模板已分享到会员群  <br/>3秒解读：中国Robotaxi成本已低于全球同行（Waymo约10万美元），具备规模化推广的经济基础。  <br/>对应人群行动建议：车企可加大Robotaxi量产（如百度萝卜快跑已量产1万辆），通过规模效应进一步降本；零部件供应商可聚焦激光雷达、智驾芯片的成本优化，比如开发更低成本的MEMS激光雷达。</p><h5>（二）运营成本：百度单次行程仅2.72美元，比Waymo便宜88%</h5><p>运营成本的控制更能体现中国厂商的优势。百度Robotaxi单次行程成本已降至2.72美元，实现单位经济盈利：车辆折旧占49%（1.34美元）、充电占22%（0.59美元）、保险占9%（0.23美元），其他成本（维护、远程监控）占20%。而美国Waymo单次成本高达23.10美元，中国厂商在运营效率（如充电网络布局）、人力成本（远程监控人员薪资）上的优势明显。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400337" alt="" title="" loading="lazy"/>  <br/>BIDU机器人出租车单次行程成本组成圆环图表成本分析-2数据及PDF模板已分享到会员群</p><h4><a name="t7" target="_blank"/>五、用户接受度：中国用户81%愿用自动驾驶，远超美国的29%</h4><p>用户接受度是智能驾驶商业化的“最后一公里”。中国用户对自动驾驶的接受度，正在以“翻倍”的速度提升：2021年仅39%，2023年达81%，而美国同期仅从18%升至29%。这背后是中国用户接触智驾的机会更多（如Robotaxi试点城市多）、政府推广力度大（如深圳街头随处可见自动驾驶测试车），以及华为、小鹏等厂商的智驾功能更贴合中国路况（如识别电单车、非常规红绿灯）。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400338" alt="" title="" loading="lazy"/>  <br/>中美用户对自动驾驶舒适度比例华夫图表用户接受度-1数据及PDF模板已分享到会员群  <br/>3秒解读：中国是全球最接受自动驾驶的市场，为商业化提供了“用户基础”。  <br/>对应人群行动建议：车企在推广智驾功能时，可加大用户体验活动（如“智驾体验日”），重点宣传“贴合中国路况”的优势；出行运营商可在一二线城市先铺开Robotaxi服务，利用高接受度快速起量。</p><h4><a name="t8" target="_blank"/>六、可落地的3件事：分角色给出“行动指南”</h4><ol><li><strong>车企研发</strong>：本周梳理现有车型智驾配置，优先评估地平线J6P、华为昇腾610等国产芯片替代方案，结合成本分析报告优化BOM结构，目标将L2+智驾车型价格下探至15万以下（参考哈弗枭龙MAX二代的定价策略）。</li><li><strong>出行运营商</strong>：本月调研武汉、广州的Robotaxi运营案例（如百度萝卜快跑、滴滴自动驾驶），对接当地交通部门申请测试资质，同步规划场站与充电设施布局，参考2030年渗透率预测制定2026年运营目标（如一线城市 Robotaxi 车队规模达1000辆）。</li><li><strong>智能驾驶创业者</strong>：聚焦激光雷达零部件（如发射端VCSEL芯片）或国产芯片算法适配赛道，基于产业链竞争格局报告筛选合作伙伴（如与禾赛、速腾合作开发低成本部件），利用行业智算数据平台获取最新路况数据，快速迭代产品。</li></ol><h4><a name="t9" target="_blank"/>七、风险提示及应对方案：提前规避“坑”</h4><ol><li><strong>数据安全合规风险</strong>：智能驾驶涉及大量道路数据和用户信息，可能面临《汽车数据安全管理若干规定》的合规处罚。应对方案：建立数据脱敏与安全存储体系（如采用联邦学习技术），社群已整理《智能驾驶数据合规政策合集》，进群可领取。</li><li><strong>政策变动风险</strong>：地方政府测试道路开放进度、智驾分级政策可能调整（如某城市突然收紧Robotaxi运营时间），影响商业化节奏。应对方案：密切关注全国汽车标准化技术委员会的政策动态，与地方交通部门建立月度沟通机制，社群将实时同步政策更新。</li><li><strong>技术迭代风险</strong>：智驾芯片、算法更新快（如英伟达Thor芯片即将量产），现有产品可能快速过时。应对方案：采用模块化设计预留升级空间（如车型支持芯片替换），与地平线、华为签订长期技术合作协议，优先布局L3+以上高阶技术研发，社群提供最新技术趋势报告（如《2025智驾芯片技术路线报告》）。</li></ol><h4><a name="t10" target="_blank"/>八、核心数据对比表：不同报告差异及原因</h4><table><thead><tr><th>研究主题</th><th>核心结论</th><th>数据差异</th><th>原因分析</th></tr></thead><tbody><tr><td>智驾芯片市场份额</td><td>Barclays：地平线占11%；Bernstein：地平线占比超10%</td><td>差异±1%</td><td>统计时间略有差异，Barclays统计2024全年，Bernstein统计2024H2（地平线Q4出货量略有下滑）</td></tr><tr><td>Robotaxi渗透率</td><td>Barclays：2030年中国总体7%；亿欧智库：2030年中国8%</td><td>差异±1%</td><td>统计范围不同，Barclays仅含一二线城市，亿欧智库包含部分三线城市（如苏州、宁波）</td></tr><tr><td>智驾成本下降幅度</td><td>Barclays：五年（2020-2025）下降80%；中泰证券：四年（2021-2025）下降75%</td><td>差异±5%</td><td>时间周期不同，Barclays含2020年高基数，中泰证券从2021年（成本已初步下降）开始统计</td></tr></tbody></table><p><strong>九、文中数据图表列表</strong></p><ol><li>2024年中国智驾芯片厂商市场份额横向比例条形图表A1</li><li>2023年全球车载激光雷达厂商市场份额灰底比例条形图表A2</li><li>ADAS SoC市场规模双轴图表B1</li><li>高阶智驾渗透率百分比堆叠面积图表C1</li><li>2035年全自动驾驶车辆市场价值预测瀑布图表市场增长-1</li><li>2030年中国机器人出租车渗透率预测刻度线图表市场增长-2</li><li>共享自动驾驶车辆数量预测气泡图表市场增长-3</li><li>中国机器人出租车制造成本趋势半圆面积比例图表成本分析-1</li><li>BIDU机器人出租车单次行程成本组成圆环图表成本分析-2</li><li>中美用户对自动驾驶舒适度比例华夫图表用户接受度-1</li></ol><h2><a name="t11" target="_blank"/>本专题内的参考报告（PDF）目录</h2><ol><li>智能驾驶行业深度报告-激光雷达的应用跃迁-从驰骋公路到赋能万物 报告2025-11-10</li><li>中国智能驾驶芯片：竞争格局及关键供应商深入L2+以上NOA细分市场 报告2025-10-31</li><li>2025构建全自动驾驶汽车生态系统：未来出行研究报告 报告2025-10-19</li><li>集团企业数字化转型、数字驾驶舱、数字化平台方案 报告2025-10-15</li><li>中国自动驾驶：无人驾驶出租车全天候运行 报告2025-09-11</li><li>2025中国L4智能驾驶场景商业化发展洞察报告 报告2025-09-09</li><li>智能驾驶智算数据平台发展研究报告 报告2025-09-02</li><li>2025年智能驾驶智算数据平台发展研究报告 报告2025-09-02</li><li>城市驾驶舱解决方案 报告2025-08-28</li><li>2025年驾驶自动化系统用户告知及培训体系标准化需求研究报告 报告2025-08-28</li><li>商业综合体驾驶舱解决方案 报告2025-08-26</li><li>2024共享自动驾驶汽车的演进：市场潜力、用户接受度与早期采用者群体报... 报告2025-08-24</li><li>中国无人驾驶出租车行业现状：2030年50万量级部署与盈亏平衡点探析 报告2025-08-18</li><li>2024年自动驾驶安全模型研究报告 报告2025-07-28</li><li>2025汽车智能驾驶技术及产业发展白皮书 报告2025-07-11</li><li>汽车行业深度报告-当自动驾驶与机器人共振-详解VLA与世界模型 报告2025-07-08</li><li>2025美国各城市自动驾驶汽车部署状况研究报告 报告2025-07-06</li><li>自动驾驶汽车：时间表和未来路线图 报告2025-06-19</li><li>无人驾驶深度之一-无人物流专题-万事具备-爆发元年 报告2025-06-17</li><li>自动驾驶汽车：人工智能与学习算法的进化之旅（2024） 报告2025-06-09</li><li>2025年全球科技中国无人驾驶出租车市场商业化之路研究报告 报告2025-05-25</li><li>2025当AI接管方向盘：自动驾驶场景下的人机交互认知重构、变革及对策... 报告2025-05-07</li><li>中国民航驾驶员发展年度报告2024年 报告2025-04-29</li><li>2025年公路干线物流自动驾驶行业研究报告 报告2025-04-27</li><li>2024年中国自动驾驶行业深度报告 报告2025-04-20</li><li>2025年NVIDIA自动驾驶安全报告 报告2025-04-04</li><li>汽车智能驾驶行业深度报告-端到端与AI共振-智驾平权开启新时代 报告2025-04-01</li><li>2025全球自动驾驶行业洞察报告 报告2025-03-31</li><li>比亚迪天神之眼智能驾驶系统技术与卖点解析（2月10日发布会） 报告2025-03-24</li><li>小鹏汽车首次覆盖报告：智能驾驶先锋，产品周期发力 报告2025-03-10</li><li>自动驾驶的世界模型综述 报告2025-03-09</li><li>2024中国智能驾驶城区NOA功能测评报告 报告2025-01-24</li><li>智能驾驶2024年度报告 报告2025-01-21</li><li>自动驾驶战略与政策观察（2024年）-政策法规助力高度自动驾驶加速推进... 报告2025-01-09</li><li>2024全球电车驾驶者调研报告 报告2025-01-05</li><li>2024年中国智慧交通发展趋势报告：自动驾驶篇 报告2025-01-05</li><li>通渠有道：2024年园区物流无人驾驶行业研究报告 报告2024-12-24</li><li>中国煤炭工业协会：2024年露天煤矿无人驾驶技术应用发展报告 报告2024-12-17</li><li>通渠有道：2024年园区物流无人驾驶行业研究报告 报告2024-11-24</li><li>香港应用科技研究院&amp;德勤：2024香港网联自动驾驶汽车(CAV)研究报... 报告2024-11-04</li><li>2024特斯拉的自动驾驶系统FSD发展历程、技术原理及未来展望分析报告 报告2024-11-03</li><li>智能驾驶行业2024年深度行业分析研究报告 报告2024-10-12</li><li>2024特斯拉、华为等企业在智能驾驶领域的技术进展及商业模式分析报告 报告2024-10-08</li><li>辰韬资本：自动驾驶软硬一体演进趋势研究报告 报告2024-10-06</li><li>辰韬资本：自动驾驶软硬一体演进趋势研究报告 报告2024-10-06</li><li>全球智慧矿业创新研究院：智能矿山暨无人驾驶行业蓝皮书 报告2024-10-06</li><li>辰韬资本：2024年自动驾驶软硬一体演进趋势研究报告 报告2024-10-06</li><li>通渠有道&amp;济驭&amp;同铃科技：2024自动驾驶线控底盘行业研究报告 报告2024-09-08</li><li>华为：2024年Net5.5G时代-IP自动驾驶网络白皮书：开启自智网... 报告2024-08-12</li><li>第一财经&amp;DT研究院：2024无人驾驶网约车乘坐意愿调查报告 报告2024-08-12</li><li>源达信息：智能驾驶研究系列-智能驾驶政策技术双轮驱动-助推Robota... 报告2024-08-08</li><li>头豹：2024年中国无人驾驶商用车应用分析-多场景落地-技术革新引领行... 报告2024-07-23</li><li>亿欧智库：2024中国智慧矿山自动驾驶产业市场研究报告 报告2024-07-15</li><li>CAICV：中国智能网联汽车自动驾驶仿真测试白皮书（2023版） 报告2024-07-07</li><li>沙利文：2024全球港口无人驾驶行业独立市场研究报告 报告2024-07-04</li><li>甲子光年：2024自动驾驶行业研究报告 报告2024-07-04</li><li>亿欧智库：自动驾驶篇2024中国自动驾驶商用车港口场景商业化案例研究 报告2024-06-28</li><li>百分点舆情中心：2024智能驾驶兴趣人群研究报告 报告2024-06-27</li><li>自动驾驶分会&amp;辰韬资本：2024端到端自动驾驶行业研究报告 报告2024-06-26</li><li>亿欧智库：2024中国自动驾驶商用车港口场景商业化案例研究-港口新质生... 报告2024-06-20</li><li>亿欧智库：智能驾驶行业-2024中国智能驾驶数据闭环应用新生态分析报告 报告2024-06-11</li><li>民航局：民用无人驾驶航空器操控员和云系统数据统计报告（2023年） 报告2024-05-19</li><li>BJHAI：2024北京市高级别自动驾驶示范区数据安全治理白皮书 报告2024-05-10</li><li>中国民用航空局飞行标准司：中国民航驾驶员发展年度报告2023年版 报告2024-04-03</li><li>量子位智库：智能驾驶2023年度报告 报告2024-02-20</li><li>前瞻研究院：数据驱动时代“车路云一体化”加速自动驾驶商业化进程 报告2024-01-29</li><li>ECC&amp;中电标协&amp;华为：2023智能驾驶计算芯片性能评测标准化白皮书 报告2024-01-22</li><li>如祺出行&amp;罗兰贝格：2024自动驾驶出租车（Robotaxi）商业化趋... 报告2024-01-04</li><li>2025长城汽车深度研究报告：新品加速、出口拓展、智驾转型 报告2025-10-09</li><li>2025汽车智驾芯片行业技术趋势、市场空间、竞争格局及相关标的分析报告 报告2025-08-19</li><li>2025年智驾和机器人领域人才洞察 报告2025-07-02</li><li>2025中国高阶辅助智驾最新技术洞察 报告2025-06-26</li><li>智驾地图市场研究报告（2025） 报告2025-06-04</li><li>智驾平权之车企智驾方案梳理 报告2025-05-19</li><li>汽车智能驾驶行业深度报告-端到端与AI共振-智驾平权开启新时代 报告2025-04-01</li><li>2025新能源汽车全场景智驾用户体验报告 报告2025-03-01</li><li>NE时代：2024年北京车展分析报告-智驾篇 报告2024-05-29</li><li>2025智能座舱操作系统洞察报告：无界互联，智能座舱系统迎来AI生态革... 报告2025-07-18</li><li>2025年智能座舱操作系统洞察报告 报告2025-07-11</li><li>2025华舆奖前瞻趋势发布-中国智能座舱评选白皮书 报告2025-03-25</li><li>2024年汽车智能座舱投融资研究白皮书 报告2025-02-11</li><li>2025宝马超感智能座舱首发事件舆情洞察报告 报告2025-02-10</li><li>2024年AI大模型赋能智能座舱研究报告 报告2025-01-16</li><li>facecar：2024北京车展智能座舱趋势洞察报告 报告2024-05-23</li><li>君迪&amp;同济大学：2023年度中国汽车智能座舱典范研究白皮书 报告2024-01-10</li></ol>]]></description></item><item>    <title><![CDATA[首个记忆幻觉评估框架 HaluMem 正]]></title>    <link>https://segmentfault.com/a/1190000047400355</link>    <guid>https://segmentfault.com/a/1190000047400355</guid>    <pubDate>2025-11-14 17:04:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="117" referrerpolicy="no-referrer" src="/img/bVdm29W" alt="" title=""/></p><hr/><hr/><hr/><p>在和 AI 长期相处的过程中，你可能发现它偶尔会“记错人”：\<br/>昨天刚告诉它我喜欢黑咖，今天它却推荐了焦糖拿铁；\<br/>上周说好要去成都旅游，它却在记忆里写成了长沙。</p><p><img width="723" height="202" referrerpolicy="no-referrer" src="/img/bVdm29w" alt="" title="" loading="lazy"/></p><pre><code>                                图 记忆系统中操作级幻觉的示例
</code></pre><p>这些看似小小的“记忆偏差”，其实正是当下 AI 系统中最隐蔽、最难察觉的风险之一——<strong>记忆幻觉（Memory Hallucination），其中</strong>包括：</p><ul><li><strong>记忆提取幻觉</strong>：从对话中抽取关键信息时，可能<strong>错误或虚构事实</strong>；</li><li><strong>记忆更新幻觉：修改旧信息时，可能错误或遗漏更新；</strong></li><li><strong>记忆问答幻觉：引用记忆回答问题时，可能调用了错误记忆或编造细节。</strong></li></ul><p><strong>而幻觉，往往正是在这些环节中被“生成”或“扩散”的。</strong></p><p>这些幻觉一旦发生，会在系统内部累积、传递、放大，最终影响AI的回答。于是我们看到这样的现象：“AI越聊越熟，却越说越不对。”</p><p><strong>HaluMem：首个面向记忆系统的幻觉评估框架正式发布！</strong></p><p>记忆张量（MemTensor）联合中国电信研究院正式发布业内首个针对 AI 记忆系统的幻觉评估框架 ——<strong>HaluMem</strong>。</p><p>首日发布已登顶 Hugging Face Papers Daily &amp; Weekly TOP 1。</p><p><img width="723" height="372" referrerpolicy="no-referrer" src="/img/bVdm29X" alt="" title="" loading="lazy"/></p><p>📄 论文已上线 Hugging Face Papers：\<br/><a href="https://link.segmentfault.com/?enc=%2Fpb2OOmlRottxwd6sGHEaw%3D%3D.WfOS%2Fw9HAEvfFYd4lV2yOOYi8tV2E12daBitpaq0Ayw6HFDBkBvrkBJMSy%2BT1VgN" rel="nofollow" target="_blank">https://huggingface.co/papers/2511.03506</a></p><p>我们希望通过 HaluMem 助力：</p><blockquote>每一个智能体都能知道自己，是“在哪一步开始记错的”。</blockquote><h2>三阶段幻觉拆解机制</h2><p>不同于以往只能评估整体表现的黑箱方法，HaluMem 首创了，并将记忆过程拆分为三个关键阶段：</p><ol><li><strong>记忆抽取（Extraction）</strong> ：AI 是否正确抓取关键信息？</li><li><strong>记忆更新（Update）</strong>：在修改旧信息时是否出现误写或偏差？</li><li><strong>记忆问答（Usage）</strong> ：AI 回答问题时是否调用了正确记忆？</li></ol><p>这种“操作级”评估方式，能够精准定位幻觉来源，让开发者真正理解——模型是在<strong>哪一步</strong>开始出现问题。</p><h2>极限长上下文测试：还原真实交互</h2><p>HaluMem 构建了覆盖 <strong>1M tokens</strong> 的超长上下文数据集，系统性地揭示主流记忆系统（Mem0、Memobase、Supermemory 、Zep等）在不同阶段的幻觉模式与传播规律，模拟真实人机交互场景。</p><p>数据集包含多维人格、事件更新、关系演化等复杂场景，用于系统揭示幻觉的传播规律。</p><h2>实验结果：主流记忆框架的幻觉表现</h2><p>HaluMem 构建了覆盖 <strong>1M tokens</strong> 的长上下文数据集，并对主流记忆系统（Mem0、Zep、Memobase、SuperMemory 等）进行了系统评估。</p><p>以下为首轮实验结果（幻觉率越低越好）：</p><p><img width="723" height="339" referrerpolicy="no-referrer" src="/img/bVdm29Y" alt="" title="" loading="lazy"/><br/>从结果可以看到：</p><ul><li><strong>记忆抽取与更新阶段</strong> 是幻觉的主要集中点，占总误差约 70%；</li><li><strong>MemOS</strong> 依托结构化记忆与偏好记忆机制，幻觉率降低超过 40%；</li><li>具备上下文调度与异步记忆机制的系统，在问答阶段表现显著更稳。</li></ul><p>换句话说，HaluMem 不只是评估框架，更是一面镜子，照出了每个记忆系统在「哪里容易出错、怎么改进」的真相。</p><h2>框架特性亮点</h2><p><img width="723" height="403" referrerpolicy="no-referrer" src="/img/bVdm290" alt="" title="" loading="lazy"/></p><h2>为什么这很重要？</h2><p>过去，我们关注模型“说得对不对”； 现在，我们要关注模型“<strong>记得对不对</strong>”。</p><p>HaluMem 的出现，让 AI 记忆系统首次具备了“自检”与“溯源”能力。</p><p><strong>它可以帮助：</strong></p><ul><li>医疗类智能体——减少记忆冲突，提升诊断一致性；</li><li>情感陪伴类 Agent——防止“人格漂移”；</li><li>企业知识助理——保持知识更新与问答逻辑统一。</li></ul><p>这意味着，AI 不再只是“会回答的问题机器”，而且能在长时间学习中持续修正自己的记忆与行为逻辑。</p><h2>开放数据、开放未来</h2><p>HaluMem 的评测集与代码现已全面开源， 开发者可在 Hugging Face 或 GitHub 上快速复现与验证实验。</p><p>🔗 论文地址： <a href="https://link.segmentfault.com/?enc=Mkl7ayKsCU3wTOFDpWIvbQ%3D%3D.lP9Jqqxj%2F%2FxdduloKO%2BIvnAZzU5t9cmsVAcYouFpukSZJtYl9TtnapoEq1nA8Pkt" rel="nofollow" target="_blank">https://huggingface.co/papers/2511.03506</a></p><p>📖 GitHub 地址：github.com/MemTensor/HaluMem</p><p>📣 如果你也关注记忆系统与幻觉问题，</p><p>欢迎到 Hugging Face 为 <strong>HaluMem</strong> 投票支持，让更多开发者加入「让 AI 记得更准」的行动。</p><p>⬇️ 点击投票 | Vote for HaluMem on Hugging Face：\<br/><a href="https://link.segmentfault.com/?enc=YNKK3IUcfdgvrzbL5%2FPV9g%3D%3D.QAvfhkGPje0LwKlOAExFyd%2FweLtznxKdsaUeY2JLiG2hLpuBTzqcZKPt5WMElQr3" rel="nofollow" target="_blank">https://huggingface.co/papers/2511.03506</a></p><hr/><hr/><hr/><hr/><p><strong>关于 MemOS</strong></p><p>MemOS 为 AGI 构建统一的记忆管理平台，让智能系统如大脑般拥有灵活、可迁移、可共享的长期记忆和即时记忆。</p><p>作为记忆张量首次提出“记忆调度”架构的 AI 记忆操作系统，我们希望通过 MemOS 全面重构模型记忆资源的生命周期管理，为智能系统提供高效且灵活的记忆管理能力。</p><p><img width="723" height="117" referrerpolicy="no-referrer" src="/img/bVdm29W" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[提升 Python 性能的 10 个智能]]></title>    <link>https://segmentfault.com/a/1190000047400361</link>    <guid>https://segmentfault.com/a/1190000047400361</guid>    <pubDate>2025-11-14 17:03:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Python 作为一门高效、简洁且功能强大的编程语言，已经广泛应用于从 Web 开发到人工智能等多个领域。然而，随着项目的复杂性增加，性能瓶颈不可避免地浮现。尤其是在数据处理、实时系统和高性能计算方面，优化 Python 代码的执行效率变得至关重要。幸运的是，Python 提供了很多内置功能和优化技巧，可以显著提高代码的运行速度。</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdm295" alt="1763084769950-veas9k8qvp.jpeg" title="1763084769950-veas9k8qvp.jpeg"/><br/>以下是 10 个经过实践验证的性能优化策略，这些方法不依赖于外部库，而是通过高效的数据结构、低级优化和 Python 本身的内建功能来加速代码执行。通过这些技巧，你不仅可以在大数据集和计算密集型任务中获得性能提升，还能在保持代码简洁和可读性的同时，解决性能瓶颈。</p><h3>技巧 1：使用集合进行成员测试</h3><p>在处理大规模数据集时，检查某个元素是否在集合中，使用列表通常效率较低。列表的成员测试（<code>x in some_list</code>）是线性时间复杂度（<code>O(n)</code>），意味着它需要逐个扫描元素。而集合（<code>set</code>）则通过哈希表实现，允许常数时间复杂度（<code>O(1)</code>）的查找，效率大幅提升。</p><pre><code class="python">big_list = list(range(1000000))
big_set = set(big_list)

start = time.time()
print(999999 in big_list)
print(f"List lookup: {time.time() - start:.6f}s")

start = time.time()
print(999999 in big_set)
print(f"Set lookup: {time.time() - start:.6f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>列表查找：约 0.015 秒</li><li>集合查找：约 0.00002 秒</li></ul><p>如果你的任务涉及到去重、输入验证或交叉引用等操作，集合会比列表更高效。</p><h3>技巧 2：避免不必要的复制</h3><p>复制大型对象（如列表、字典或数组）在时间和内存上都是开销巨大的。每次复制都会创建新的对象，这可能导致内存浪费和性能下降，尤其在处理大数据集时。尽量使用原地操作而不是复制对象，Python 的许多内置数据结构都提供了原地操作的方法（如 <code>sort</code>、<code>append</code>、<code>update</code> 等）。</p><pre><code class="python">numbers = list(range(1000000))

def modify_list(lst):
    lst[0] = 999
    return lst

start = time.time()
result = modify_list(numbers)
print(f"In-place: {time.time() - start:.4f}s")

def copy_list(lst):
    new_lst = lst.copy()
    new_lst[0] = 999
    return new_lst

start = time.time()
result = copy_list(numbers)
print(f"Copy: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>原地修改：约 0.0001 秒</li><li>复制修改：约 0.0100 秒</li></ul><h3>技巧 3：使用 <code>__slots__</code> 来提高内存效率</h3><p>Python 类的实例属性通常存储在动态字典（<code>__dict__</code>）中，这为灵活性提供了便利，但也带来了内存开销。通过使用 <code>__slots__</code>，可以显式声明固定的属性集合，避免创建 <code>__dict__</code>，从而节省内存。</p><pre><code class="python">class Point:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

start = time.time()
points = [Point(i, i+1) for i in range(1000000)]
print(f"With slots: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>使用 <code>__slots__</code>：约 0.1200 秒</li><li>不使用 <code>__slots__</code>：约 0.1500 秒</li></ul><h3>技巧 4：使用 <code>math</code> 模块代替操作符</h3><p>Python 的 <code>math</code> 模块提供了一些内建的函数，这些函数是用 C 实现的，比直接在 Python 中实现的运算符更加高效。例如，使用 <code>math.sqrt()</code> 通常比使用 <code>** 0.5</code> 运算符来计算平方根要更快。</p><pre><code class="python">import math

numbers = list(range(10000000))

start = time.time()
roots = [math.sqrt(n) for n in numbers]
print(f"Math sqrt: {time.time() - start:.4f}s")

start = time.time()
roots = [n ** 0.5 for n in numbers]
print(f"Operator: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li><code>math.sqrt()</code>：约 0.2000 秒</li><li><code>** 0.5</code>：约 0.2500 秒</li></ul><h3>技巧 5：预分配已知大小的内存</h3><p>Python 在动态构建列表或数组时，会在后台进行扩容，每次扩容都会涉及到内存分配和数据复制。如果你知道数据结构的最终大小，预先分配内存能显著提高性能，避免反复扩容。</p><pre><code class="python">start = time.time()
result = [0] * 1000000
for i in range(1000000):
    result[i] = i
print(f"Pre-allocated: {time.time() - start:.4f}s")

start = time.time()
result = []
for i in range(1000000):
    result.append(i)
print(f"Dynamic: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>预分配：约 0.0300 秒</li><li>动态分配：约 0.0400 秒</li></ul><h3>技巧 6：避免在热循环中使用异常处理</h3><p>异常处理非常强大，但它的开销也不容小觑。尤其在性能关键的循环中，频繁的抛出和捕获异常会导致堆栈展开和上下文切换，这对性能有很大影响。在这些循环中，最好通过条件检查来避免预期之外的错误发生，而不是依赖异常处理。</p><pre><code class="python">numbers = list(range(10000000))

start = time.time()
total = 0
for i in numbers:
    if i % 2 != 0:
        total += i // 2
    else:
        total += i
print(f"Conditional: {time.time() - start:.4f}s")

start = time.time()
total = 0
for i in numbers:
    try:
        total += i / (i % 2)
    except ZeroDivisionError:
        total += i
print(f"Exception: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>条件检查：约 0.3000 秒</li><li>异常处理：约 0.6000 秒</li></ul><h3>技巧 7：使用局部函数提高重复逻辑的效率</h3><p>在函数中反复使用同一段逻辑时，定义一个局部（嵌套）函数可以提高性能，因为 Python 会在局部作用域内更快地查找变量。</p><pre><code class="python">def outer():
    def add_pair(a, b):
        return a + b

    result = 0
    for i in range(10000000):
        result = add_pair(result, i)

    return result

start = time.time()
result = outer()
print(f"Local function: {time.time() - start:.4f}s")

def add_pair(a, b):
    return a + b

start = time.time()
result = 0
for i in range(10000000):
    result = add_pair(result, i)
print(f"Global function: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>局部函数：约 0.4000 秒</li><li>全局函数：约 0.4500 秒</li></ul><h3>技巧 8：使用 <code>itertools</code> 进行组合操作</h3><p>Python 的 <code>itertools</code> 模块提供了一些高效的函数，适用于排列、组合、笛卡尔积等任务。这些函数采用惰性生成方式，能够在不占用大量内存的情况下处理大规模数据。</p><pre><code class="python">from itertools import product

items = [1, 2, 3] * 10

start = time.time()
result = list(product(items, repeat=2))
print(f"Itertools: {time.time() - start:.4f}s")

start = time.time()
result = []
for x in items:
    for y in items:
        result.append((x, y))
print(f"Loops: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li><code>itertools.product()</code>：约 0.0005 秒</li><li>嵌套循环：约 0.0020 秒</li></ul><h3>技巧 9：使用 <code>bisect</code> 进行有序列表操作</h3><p>如果你需要在一个有序列表中进行查找或插入操作，使用 <code>bisect</code> 模块提供的二分查找方法会比手动实现的</p><p>线性查找更加高效。</p><pre><code class="python">import bisect

sorted_list = list(range(1000000))

start = time.time()
bisect.insort(sorted_list, 500000)
print(f"Bisect insert: {time.time() - start:.4f}s")

start = time.time()
sorted_list.append(500000)
sorted_list.sort()
print(f"Manual insert: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li><code>bisect.insort()</code>：约 0.1000 秒</li><li>手动插入：约 0.1500 秒</li></ul><h3>技巧 10：使用 <code>numpy</code> 进行数值计算</h3><p>对于数值计算密集型任务，<code>numpy</code> 是一种非常高效的解决方案。相比纯 Python 实现，<code>numpy</code> 通过优化的 C 代码和向量化操作，能大幅提升计算效率。</p><pre><code class="python">import numpy as np

arr = np.arange(1000000)

start = time.time()
result = np.sqrt(arr)
print(f"NumPy: {time.time() - start:.4f}s")

start = time.time()
result = [x ** 0.5 for x in arr]
print(f"List comprehension: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li><code>numpy.sqrt()</code>：约 0.2000 秒</li><li>列表推导：约 0.4500 秒</li></ul><hr/><h2>结语</h2><p>掌握这些 Python 性能优化技巧，可以显著提升你的代码执行效率，特别是在处理大量数据或需要高性能计算时。通过了解和运用 Python 内置功能和高效的数据结构，不仅能提升运行速度，还能优化代码的可读性和可维护性。</p><hr/><p><strong>喜欢就奖励一个“👍”和“在看”呗~</strong></p><p><img width="203" height="69" referrerpolicy="no-referrer" src="/img/bVdlOIU" alt="1763084769951-955qfbo83ze.png" title="1763084769951-955qfbo83ze.png" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[开发者必看！TinyEngine 低代码]]></title>    <link>https://segmentfault.com/a/1190000047400386</link>    <guid>https://segmentfault.com/a/1190000047400386</guid>    <pubDate>2025-11-14 17:02:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文由TinyEngine低代码物料导入功能贡献者张筠同学原创。</p><h2>引言：低代码物料接入的痛点与解决方案</h2><p>在低代码平台开发中，物料接入是核心环节之一。传统物料接入依赖开发者手动编写符合平台协议的 JSON 配置，不仅效率低下，还容易因人为失误导致兼容性问题 —— 尤其是面对海量 UI 组件时，重复的人工操作会大幅拖慢开发进度。</p><p>为解决这一痛点，我们开发了 <strong>TinyEngine 低代码物料自动导入工具</strong>，支持通过 URL 爬取、NPM 包解析、源码上传三种方式，自动提取组件的 Props/Events/Slots 等 API 信息，并转换为符合 TinyEngine 协议的标准物料格式。配套的可视化前端实现了 "导入 - 预览 - 编辑 - 保存" 全流程闭环，将物料接入效率大幅度提升。</p><p>本文将从项目设计、核心模块实现、项目部署与使用指南等方面，带大家全面了解这个前后端一体化的物料处理方案。</p><h2>一、项目概览：技术栈与核心架构</h2><h3>1. 技术栈选型</h3><h4>后端技术栈</h4><ul><li>运行环境：Node.js v20.19.5+（原生支持 fetch 与 ES6 + 语法）</li><li>核心依赖：Express（接口服务）、MySQL（物料存储）、Puppeteer（URL 爬取）、LLM SDK（API 提取）</li><li>核心能力：多源数据解析、物料协议转换、异步任务管理</li></ul><h4>前端技术栈</h4><ul><li>框架：Vue 3.2+（<code>&lt;script setup&gt;</code>语法）</li><li>构建工具：Vite 4.0+（高效热更新与跨域代理）</li><li>UI 组件：OpenTiny Vue（轻量化企业级组件库）</li><li>核心能力：动态表单、任务进度可视化、表格编辑、批量数据管理</li></ul><h3>2. 整体架构设计</h3><p><img width="723" height="836" referrerpolicy="no-referrer" src="/img/bVdm3aN" alt="1.png" title="1.png"/></p><p>项目采用前后端分离架构，核心交互流程如下：</p><ol><li>前端发起导入请求（携带 URL/NPM 信息 / 源码文件）；</li><li>后端创建异步任务，根据导入类型执行对应解析逻辑；</li><li>调用 LLM 接口提取结构化 API 信息，转换为标准物料格式；</li><li>前端通过轮询获取任务进度，实时展示处理状态；</li><li>处理完成后，前端提供物料预览与编辑功能，支持保存到数据库。</li></ol><h2>二、核心功能拆解：从解析到可视化</h2><h3>1. 多源物料解析（后端核心能力）</h3><p>依托四大核心模块协同工作，实现URL、NPM、源码三种导入方式的标准化解析，全程自动化完成从原始数据到TinyEngine标准物料的转化。</p><h4>（1）URL 导入</h4><p>基于 <strong>API生成模块</strong> 的URL表格驱动流程，通过Puppeteer模拟浏览器访问目标URL，根据用户指定的CSS选择器精准定位API表格数据，搭配重试机制保障爬取稳定性；获取表格数据后，传递给LLM模型进行结构化处理，生成包含Props/Events/Slots的原始API JSON；随后经 <strong>物料转换模块</strong> 转化为符合TinyEngine规范的物料格式，最后由 <strong>后处理模块</strong> 完成组件名标准化（如统一为PascalCase格式）及规则化优化，确保物料一致性。</p><h4>（2）NPM 导入</h4><p>接收用户输入的NPM包名与组件名后，后端自动下载对应包资源，通过 <strong>文件筛选模块</strong> 的NPM类型规则（强制校验<code>index</code>入口文件，提取含组件关键词的核心文件，自动跳过<code>style</code>、<code>utils</code>等非API相关目录及<code>.map</code>文件）完成文件筛选；筛选后的核心文件进入 <strong>API生成模块</strong> 的文件驱动流程，经LLM解析生成原始API JSON；再通过 <strong>物料转换模块</strong> 补充组件基本信息、规范Props/Events/Slots定义，最终由 <strong>后处理模块</strong> 按预设规则优化（无需处理的组件直接保留、表格组件合并列定义等），输出标准物料。</p><h4>（3）源码导入</h4><p>用户可上传Vue组件源码文件或ZIP压缩包，后端解压后触发 <strong>文件筛选模块</strong> 的源码类型处理逻辑——自动识别<code>index.js/ts</code>入口文件及Props/Events定义文件，过滤非API相关内容；筛选后的有效文件进入 <strong>API生成模块</strong> 执行文件驱动流程，经LLM解析生成原始API JSON；后续通过 <strong>物料转换模块</strong> 转化为TinyEngine标准格式，再由 <strong>后处理模块</strong> 清理子项组件冗余片段、统一组件名格式，最终生成可直接使用的标准化物料。</p><h3>2. 可视化操作闭环（前端核心能力）</h3><h4>（1）动态导入表单</h4><p>根据用户选择的导入类型（URL/NPM/ 源码），自动切换对应表单：</p><ul><li>URL 导入：展示 URL 输入框与表格 CSS 选择器输入框；</li><li>NPM 导入：展示包名与组件名输入框；</li><li>源码导入：展示文件上传组件（支持单个文件与 ZIP 包）。</li></ul><h4>（2）任务进度可视化</h4><ul><li>提交导入请求后，展示进度条实时更新处理进度（0-100%）；</li><li>处理中任务支持最小化为右侧悬浮卡片，不影响其他操作，点击可重新打开模态框查看详情；</li><li>任务状态实时反馈（处理中 / 成功 / 失败），失败时显示具体错误信息。</li></ul><h4>（3）物料预览与编辑</h4><p>任务处理成功后，通过表格展示生成的物料列表，支持：</p><ul><li>主表展示基础信息（组件名、导入类型、导入时间等）；</li><li>展开行查看子表（属性 / 事件 / 插槽），支持编辑字段值、删除无效项；</li><li>编辑后实时提交更新，确保数据同步到后端。</li></ul><h4>（4）物料库管理</h4><p>提供完整的物料管理功能：</p><ul><li>筛选与搜索：按组件名精确筛选、关键词模糊搜索；</li><li>批量操作：批量导出选中物料为 JSON 文件、批量删除无用物料；</li><li>分页控制：默认 10 条 / 页，支持自定义每页显示数量。</li></ul><h2>三、项目部署</h2><h3>1. 环境要求</h3><table><thead><tr><th>环境/工具</th><th>版本要求</th><th>说明</th></tr></thead><tbody><tr><td>Node.js</td><td>v20.19.5 及以上</td><td>支持<code>fetch</code>、ES6+语法，前后端通用，建议使用官网长期支持版确保兼容性</td></tr><tr><td>前端框架</td><td>Vue 3.2+</td><td>前端采用<code>&lt;script setup&gt;</code>语法开发，需确保依赖版本符合要求</td></tr><tr><td>构建工具</td><td>Vite 4.0+</td><td>负责前端项目构建、热更新及跨域代理配置，当前项目实际使用v7.1.7版本</td></tr><tr><td>数据库</td><td>MySQL 8.0 及以上</td><td>用于存储物料数据，需提前本地安装并启动</td></tr><tr><td>依赖服务</td><td>LLM接口（如DeepSeek/Qwen/OpenAI）</td><td>后端核心依赖，需准备支持JSON输出的大模型接口及对应API密钥、接口地址</td></tr></tbody></table><h3>2. 安装与配置</h3><h4>2.1 克隆仓库</h4><p>首先将项目代码克隆到本地，执行以下命令：</p><pre><code class="bash">git clone &lt;仓库地址&gt;  # 替换为实际的项目仓库地址</code></pre><h4>2.2 安装依赖</h4><p>进入项目根目录后，分别安装后端和前端的依赖包，确保环境一致性：</p><pre><code class="bash"># 1. 安装后端依赖
cd backend
npm install  # 若使用yarn/pnpm，可替换为yarn install/pnpm install

# 2. 安装前端依赖（需新开终端或返回根目录）
cd frontend
npm install  # 同理可替换为对应包管理工具的安装命令</code></pre><h4>2.3 环境配置</h4><h5>（1）后端配置</h5><ol><li><p><strong>复制环境变量模板</strong>：进入后端目录，将 <code>.env.example</code> 模板文件复制为实际使用的 <code>.env</code> 文件：</p><pre><code class="bash">cd backend  # 若当前不在后端目录需执行此命令
cp .env.example .env  # Windows系统可手动复制文件并重命名为.env</code></pre></li><li><p><strong>编辑.env文件参数</strong>：用文本编辑器打开 <code>.env</code> 文件，根据本地环境和实际资源信息填写以下关键配置（替换占位符内容）：</p><pre><code class="env"># 服务器配置
SERVER_PORT=3001                  # 后端服务端口，默认3001，可按需修改
CORS_ALLOW_ORIGIN=http://localhost:8080 # 前端地址，需与前端端口保持一致，解决跨域问题

# 数据库配置（需与本地MySQL环境匹配）
MYSQL_HOST=localhost       # MySQL服务地址，本地默认localhost
MYSQL_PORT=3306            # MySQL端口，默认3306
MYSQL_USER=root            # MySQL用户名，替换为你的实际用户名
MYSQL_PASSWORD=your_password    # MySQL密码，替换为你的实际密码（无密码则留空）
MYSQL_DATABASE=lowcode_material # 数据库名，需后续手动创建该库

# LLM模型配置（必填，替换为实际可用的大模型信息）
OPENAI_MODEL=deepseek-reasoner            # 模型名称，如deepseek-reasoner、Qwen3-32B等
OPENAI_API_KEY=your_api_key_here          # 模型API密钥，从对应平台获取
OPENAI_BASE_URL=https://api.deepseek.com/v1 # 模型接口地址，按实际平台填写

# 默认路径配置（系统自动创建，无需手动操作）
DEFAULT_OUTPUT_DIR=output-log       # 最终物料JSON输出目录
DEFAULT_SCHEMA_LOG_DIR=schema-log   # 转换过程日志目录
DEFAULT_API_LOG_DIR=raw-api-log     # 原始API JSON日志目录</code></pre></li></ol><h5>（2）前端配置（跨域与端口）</h5><p>前端需配置代理对接后端服务，确保接口请求正常，步骤如下：</p><ol><li>进入前端目录，打开 <code>vite.config.js</code> 文件（路径：<code>frontend/vite.config.js</code>）；</li><li><p>确认或修改以下配置（需与后端 <code>.env</code> 中的配置保持一致）：</p><pre><code class="javascript">import { defineConfig } from 'vite'; 
import vue from '@vitejs/plugin-vue'; 

export default defineConfig({
  plugins: [vue()],
  server: {
    port: 8080, // 前端端口，默认8080，需与后端CORS_ALLOW_ORIGIN中的端口一致
    proxy: {
      // 代理所有/api前缀的请求到后端服务
      '/api': {
        target: 'http://localhost:3001', // 后端服务地址，与SERVER_PORT一致
        changeOrigin: true, // 开启跨域适配
      }
    }
  }
});</code></pre><ul><li>若修改了前端端口或后端服务端口，需同步更新对应配置。</li></ul></li></ol><h3>3. 快速启动</h3><p>前后端服务需按特定顺序启动，核心顺序：<strong>启动MySQL服务 → 创建项目数据库 → 启动后端服务 → 启动前端服务</strong>，具体步骤如下：</p><h4>3.1 启动MySQL服务并创建项目数据库</h4><h5>（1）启动MySQL服务</h5><p>根据本地操作系统，执行对应启动命令：</p><ul><li><strong>Windows</strong>：通过“服务”管理器找到“MySQL”服务，右键点击“启动”；</li><li><strong>macOS（Homebrew安装）</strong>：打开终端执行 <code>brew services start mysql</code>；</li><li><strong>Linux（系统服务，以Ubuntu为例）</strong>：执行 <code>sudo systemctl start mysql</code>（其他发行版按对应命令操作）。</li></ul><h5>（2）手动创建项目数据库</h5><p>项目需使用预先创建的 <code>lowcode_material</code> 数据库，执行以下步骤：</p><ol><li><p>打开终端/命令提示符，登录MySQL：</p><pre><code class="bash">mysql -u root -p  # 替换root为你的MySQL用户名，回车后输入密码（无密码直接回车）</code></pre></li><li><p>执行SQL命令创建数据库（指定字符集避免中文乱码）：</p><pre><code class="sql">CREATE DATABASE IF NOT EXISTS lowcode_material 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;</code></pre></li><li><p>（可选）验证数据库创建成功：</p><pre><code class="sql">SHOW DATABASES;  # 执行后查看输出列表，确认包含lowcode_material</code></pre></li><li><p>退出MySQL命令行：</p><pre><code class="sql">exit;</code></pre></li></ol><h4>3.2 启动后端服务</h4><pre><code class="bash"># 进入后端目录（若当前不在该目录）
cd backend

# 启动开发环境服务（使用配置的npm脚本）
npm run serve</code></pre><ul><li>启动成功标识：终端显示服务监听信息（如 <code>后端服务启动成功，端口：3001</code>）；</li><li>验证接口可用性：可通过浏览器访问 <code>http://localhost:3001/api/material/docs</code>，查看简易接口文档。</li></ul><h4>3.3 启动前端服务</h4><p>需新开一个终端（避免与后端服务冲突），执行以下命令：</p><pre><code class="bash"># 进入前端目录
cd frontend

# 启动开发环境（支持热更新，修改代码后自动刷新）
npm run dev</code></pre><ul><li>启动成功标识：终端输出 <code>VITE v7.1.7 ready in 300 ms</code> 及访问地址；</li><li>访问前端：打开浏览器输入默认地址 <code>http://localhost:8080</code>，即可进入物料管理首页。</li></ul><h3>4. 启动常见问题排查</h3><ul><li><strong>MySQL连接失败</strong>：检查 <code>.env</code> 中数据库配置（地址、端口、用户名、密码）是否与本地环境一致，确保MySQL服务已启动；</li><li><strong>LLM接口报错</strong>：检查模型配置（API密钥、接口地址、模型名称）是否正确，确保接口可正常访问且有剩余调用额度。</li></ul><h3>四、核心使用流程</h3><ol><li>访问前端地址（默认 <a href="https://link.segmentfault.com/?enc=64%2B8W7maspwJZ9%2BAFW1iTw%3D%3D.LtIQ8XggFjpjoNL3YdL6%2BQEI%2FpBIFYgBsKPbIP5HmaA%3D" rel="nofollow" target="_blank">http://localhost:8080</a>），进入物料管理首页；</li></ol><p><img width="723" height="402" referrerpolicy="no-referrer" src="/img/bVdm3aQ" alt="2.png" title="2.png" loading="lazy"/></p><ol start="2"><li><p>选择导入方式（URL / NPM / 源码），填写对应信息（如 URL 地址、NPM 包名、上传源码文件）；</p><ul><li><strong>URL 导入</strong>：输入URL地址和API表格CSS选择器；</li><li><strong>NPM 导入</strong>：输入NPM包名和组件名称；</li><li><strong>源码导入</strong>：上传源码文件（支持单个文件或zip）。</li></ul></li></ol><p><img width="723" height="397" referrerpolicy="no-referrer" src="/img/bVdm3aR" alt="3.gif" title="3.gif" loading="lazy"/></p><p><img width="723" height="397" referrerpolicy="no-referrer" src="/img/bVdm3aS" alt="4.gif" title="4.gif" loading="lazy"/></p><p><img width="723" height="433" referrerpolicy="no-referrer" src="/img/bVdm3aT" alt="5.gif" title="5.gif" loading="lazy"/></p><ol start="3"><li>提交后等待任务处理，实时查看进度条（0-100%），进度条支持最小化；</li></ol><p><img width="723" height="430" referrerpolicy="no-referrer" src="/img/bVdm3aU" alt="6.gif" title="6.gif" loading="lazy"/></p><ol start="4"><li>任务成功后，预览生成的物料数据（属性 / 事件 / 插槽），可直接编辑修改或删除；</li></ol><ul><li>编辑属性/事件/插槽</li></ul><p><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdm3aV" alt="7.gif" title="7.gif" loading="lazy"/></p><ul><li>删除属性/事件/插槽</li></ul><p><img width="723" height="439" referrerpolicy="no-referrer" src="/img/bVdm3aY" alt="8.gif" title="8.gif" loading="lazy"/></p><ul><li>删除组件物料</li></ul><p><img width="723" height="430" referrerpolicy="no-referrer" src="/img/bVdm3aZ" alt="9.gif" title="9.gif" loading="lazy"/></p><ol start="5"><li>点击 “保存到物料库”，将物料同步至 MySQL 数据库；</li></ol><p><img width="723" height="397" referrerpolicy="no-referrer" src="/img/bVdm3a0" alt="10.gif" title="10.gif" loading="lazy"/></p><ol start="6"><li>在首页通过筛选、搜索功能管理已保存的物料，支持批量导出或删除。</li></ol><ul><li>通过组件名称筛选组件物料</li></ul><p><img width="723" height="387" referrerpolicy="no-referrer" src="/img/bVdm3a1" alt="11.gif" title="11.gif" loading="lazy"/></p><ul><li>通过关键词筛选组件物料</li></ul><p><img width="723" height="387" referrerpolicy="no-referrer" src="/img/bVdm3a2" alt="12.gif" title="12.gif" loading="lazy"/></p><ul><li>批量删除组件物料</li></ul><p><img width="723" height="430" referrerpolicy="no-referrer" src="/img/bVdm3a3" alt="13.gif" title="13.gif" loading="lazy"/></p><ul><li>批量导出组件物料</li></ul><p><img width="723" height="430" referrerpolicy="no-referrer" src="/img/bVdm3a4" alt="14.gif" title="14.gif" loading="lazy"/></p><p>导出文件如下（以element-plus的Breadcrumb为例）：</p><pre><code class="json">[
  {
    "npm": {
      "package": "element-plus",
      "exportName": "ElBreadcrumb"
    },
    "icon": "breadcrumb",
    "name": {
      "zh_CN": "面包屑"
    },
    "tags": [
      "导航",
      "面包屑"
    ],
    "group": "element-plus",
    "schema": {
      "slots": {
        "default": {
          "label": {
            "zh_CN": "默认内容"
          },
          "description": {
            "zh_CN": "自定义默认内容"
          }
        }
      },
      "events": {},
      "properties": [
        {
          "name": "0",
          "label": {
            "zh_CN": "基础属性"
          },
          "content": [
            {
              "cols": 12,
              "type": "ArrayItemConfigurator-test",
              "label": {
                "text": {
                  "zh_CN": "分隔符"
                }
              },
              "widget": {
                "props": {
                  "placeholder": "请输入分隔符"
                },
                "component": "InputConfigurator"
              },
              "disabled": false,
              "property": "separator",
              "readOnly": false,
              "required": false,
              "description": {
                "zh_CN": "分隔符"
              },
              "defaultValue": "/",
              "labelPosition": "left"
            },
            {
              "cols": 12,
              "type": "unknown",
              "label": {
                "text": {
                  "zh_CN": "图标分隔符"
                }
              },
              "widget": {
                "props": {
                  "placeholder": "请输入图标名称"
                },
                "component": "InputConfigurator"
              },
              "disabled": false,
              "property": "separatorIcon",
              "readOnly": false,
              "required": false,
              "description": "图标分隔符组件",
              "defaultValue": null,
              "labelPosition": "left"
            }
          ],
          "description": {
            "zh_CN": "组件核心功能相关的配置，包括 separator、 separatorIcon 等核心属性"
          }
        }
      ]
    },
    "devMode": "proCode",
    "doc_url": "",
    "version": "",
    "category": "element-plus",
    "keywords": [
      "Breadcrumb",
      "面包屑",
      "导航"
    ],
    "snippets": [
      {
        "icon": "breadcrumb",
        "name": {
          "zh_CN": "面包屑"
        },
        "schema": {
          "children": [
            {
              "props": {
                "to": "/home"
              },
              "children": [
                {
                  "props": {
                    "text": "首页"
                  },
                  "componentName": "Text"
                }
              ],
              "componentName": "ElBreadcrumbItem"
            },
            {
              "props": {
                "to": "/list"
              },
              "children": [
                {
                  "props": {
                    "text": "列表页"
                  },
                  "componentName": "Text"
                }
              ],
              "componentName": "ElBreadcrumbItem"
            },
            {
              "props": {},
              "children": [
                {
                  "props": {
                    "text": "详情页"
                  },
                  "componentName": "Text"
                }
              ],
              "componentName": "ElBreadcrumbItem"
            }
          ]
        },
        "category": "element-plus",
        "screenshot": "",
        "snippetName": "ElBreadcrumb"
      }
    ],
    "component": "ElBreadcrumb",
    "configure": {
      "loop": true,
      "styles": true,
      "isModal": false,
      "isLayout": false,
      "isPopper": false,
      "condition": true,
      "framework": "Vue",
      "shortcuts": {
        "properties": [
          "separator"
        ]
      },
      "isNullNode": false,
      "contextMenu": {
        "actions": [
          "copy",
          "remove",
          "insert",
          "updateAttr",
          "bindEvent"
        ],
        "disable": []
      },
      "isContainer": true,
      "nestingRule": {
        "childWhitelist": "ElBreadcrumbItem",
        "parentWhitelist": "",
        "ancestorWhitelist": "",
        "descendantBlacklist": ""
      },
      "clickCapture": false,
      "rootSelector": ""
    },
    "description": "面包屑导航组件，用于显示当前页面在系统层级 结构中的位置"
  }
]</code></pre><h2>结尾</h2><p>TinyEngine 低代码物料自动导入工具的核心目标，是通过「自动化解析 + 可视化操作」的闭环设计，解决了低代码物料接入的效率瓶颈与兼容性难题。无论是 URL 爬取、NPM 解析还是源码上传，工具都力求简化全流程操作，让开发者无需关注底层协议细节与格式转换逻辑，即可快速将各类 UI 组件无缝转化为符合 TinyEngine 标准的可用物料，让低代码物料接入从繁琐的手动配置，转变为高效、省心的一站式操作。</p><h2>关于OpenTiny</h2><p>欢迎加入 OpenTiny 开源社区。添加微信小助手：opentiny-official 一起参与交流前端技术～</p><p>OpenTiny 官网：<a href="https://link.segmentfault.com/?enc=X5Z3uJ36SvpoADozbCwV3A%3D%3D.FKN7Uf0kfLbGedtydF8vvI4yY1CnouaDDFz%2Faa6cenE%3D" rel="nofollow" target="_blank">https://opentiny.design</a><br/>OpenTiny 代码仓库：<a href="https://link.segmentfault.com/?enc=Bj10ggsvGaxSQklpnRALQw%3D%3D.rDIG1CYv8J27xKydAhhtj2PqF79H1bnJXZHCR%2FcaL%2F0%3D" rel="nofollow" target="_blank">https://github.com/opentiny</a><br/>TinyVue 源码：<a href="https://link.segmentfault.com/?enc=Bzy%2BSD0BwGLSaZ70P9bxdg%3D%3D.906l18wDbvNf1FSP%2FOMQCq28p8adZFOAX32aYAWvGFujqjWLVywm1Dkdv6l8nbKG" rel="nofollow" target="_blank">https://github.com/opentiny/tiny-vue</a><br/>TinyEngine 源码： <a href="https://link.segmentfault.com/?enc=uMWL1r2RvFRSUha05xGc3Q%3D%3D.LlEcmDh%2FkCI0ftSJAYyY%2B68mkruCvYhdgjmHWfkYCVNtyiMTX0EsRmg1A28rW1jS" rel="nofollow" target="_blank">https://github.com/opentiny/tiny-engine</a><br/>欢迎进入代码仓库 Star🌟TinyEngine、TinyVue、TinyNG、TinyCLI、TinyEditor~ 如果你也想要共建，可以进入代码仓库，找到 good first issue 标签，一起参与开源贡献~</p>]]></description></item><item>    <title><![CDATA[开源欧拉社区将于 2025 年底正式上线]]></title>    <link>https://segmentfault.com/a/1190000047400412</link>    <guid>https://segmentfault.com/a/1190000047400412</guid>    <pubDate>2025-11-14 17:01:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>11 月 14 日，以“智跃无界，开源致远”为主题的操作系统大会2025（以下简称“大会”）在北京中关村国际创新中心成功举办。大会由开放原子开源欧拉（OpenAtom openEuler，简称“开源欧拉”或“openEuler”）社区，协同数十家产业伙伴共同举办，旨在汇聚全球产业界力量，打造极具创新力的操作系统，加速全球基础软件开源生态发展。<br/>据悉，在开放原子开源基金会的运营孵化下，开源欧拉社区蓬勃发展。成员单位超 2100 家，全球贡献者突破 2.3 万人，用户超过 550 万。openEuler 系操作系统累计装机量预计 2025 年底将超过 1600 万套，已经成为中国行业数智化首选操作系统，份额持续保持领先，在互联网、通信、政务、金融、公共事业和能源等行业已实现规模化应用。面向未来，开源欧拉社区正式开启新的 5 年发展之路，将于 2025 年底正式上线面向超节点的操作系统，引领 AI 时代，加速全球化。<br/><img width="723" height="482" referrerpolicy="no-referrer" src="/img/bVdm3ac" alt="" title=""/><br/>中国工程院院士倪光南在致辞中强调，基础软件是战略性产业，必须加强自主创新；是生态型产业，必须共创共建共享；是长周期产业，必须长期持续投入。过去 5 年，在产业各界的共同努力下，开源欧拉已经成为全球最活跃的开源操作系统技术社区之一，持续引领操作系统产业生态繁荣壮大。未来，超节点已经成为算力基础设施建设和部署的主流形态。智能时代的操作系统将衔接智能时代的硬件和应用，成为释放算力潜能的核心基石，助力千行万业智能化。<br/><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdm3ak" alt="" title="" loading="lazy"/><br/>开放原子开源基金会理事长程晓明在致辞中指出，开源的核心是协作，生态的未来在共生。开源欧拉的每一点进步，离不开硬件伙伴的深度适配，离不开软件应用厂商的场景验证，更离不开全球开发者的智慧贡献。相信在各方携手努力下，开源欧拉将以技术创新打破边界，让数字智能赋能万物， 以协作共生凝聚力量，推动开源生态行稳致远。<br/><img width="723" height="475" referrerpolicy="no-referrer" src="/img/bVdm3al" alt="" title="" loading="lazy"/><br/>华为公司董事、ICT BG CEO 杨超斌在致辞中表示，AI 技术正以前所未有的速度改变各行各业，传统服务器集群无法有效满足算力不断增长的诉求。华为已经开放灵衢互联协议 2.0，支持产业界伙伴打造基于灵衢的超节点，还将向开源欧拉社区贡献支持超节点的操作系统插件代码，提供“内存统一编址”、“异构算力低时延通信”和“全局资源池化”等关键能力。华为将与社区协同，推动与 Linux Foundation AI&amp;Data、PyTorch 等 AI 领域全球性开源组织深度合作，深化 AI 运行时、向量数据库、云化部署等技术专题落地。同时，华为将协同社区数十家 OSV、ISV 伙伴，面向海外客户提供 openEuler 整体解决方案，积极推动开源欧拉全球化进程。</p><h3>发布面向超节点的操作系统，引领 AI 时代</h3><p>会上，开放原子开源基金会、华为与中国电信天翼云公布联合发展倡议，联手促进技术共建、生态共筑和业务共赢，共同构建操作系统在 AI 和超节点等前沿技术领域的竞争力，推进天翼云和开源欧拉生态繁荣发展。<br/><img width="723" height="476" referrerpolicy="no-referrer" src="/img/bVdm3ap" alt="" title="" loading="lazy"/><br/>开放原子开源欧拉委员会主席熊伟发布 openEuler 全球首个面向超节点的操作系统（openEuler 24.03 LTS SP3），并在主题演讲中提到，openEuler 开启新的 5 年发展之路，坚定拥抱超节点，坚定拥抱 AI，加速全球化进程，为世界提供新的选择。<br/><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdm3aq" alt="" title="" loading="lazy"/><br/>当前，算力基础设施向 “超节点” 形态演进已成为业界普遍共识。面向超节点的操作系统，应该具备三个关键特征，包括：全局资源抽象，内存统一编址，设备池化管理；异构资源融合，大带宽低时延通信，实现平等互联；全局资源视图，兼容性接口，原生接口等，以此充分释放超节点算力潜能，加速基于超节点的应用创新。</p><h3>持续增强 AI 能力，加速行业数智化</h3><p>面向数据中心场景，开源欧拉社区提供 Intelligence BooM 全栈开源 AI 解决方案，支持 50+ 模型微调，通过异构协同推理效率提升 10%～30%，具备面向 Agentic AI 智能体生态快速适配能力，该方案已经在宝德、华鲲振宇等伙伴商用。<br/>面向新型工业自动化领域，openEuler 持续演化嵌入式能力，孵化了 MICA 混合关键性部署、UniProton 实时内核、嵌入式虚拟化等核心技术，实现微秒级响应时间。该方案已经在中国南方电网、菲尼克斯等多家国内外知名企业商业落地，有力地推动了 OT 领域 IT 化转型。</p><h3>共建产业生态，加速全球化</h3><p>今年， AMD、浪潮云、神州数码新增成为开源欧拉社区捐赠人。至此，Intel、Arm、 AMD 三大芯片企业均成为社区捐赠人。<br/><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdm3au" alt="" title="" loading="lazy"/><br/>凝思软件、中软国际、Wind River、统信软件、软通动力、超聚变、润和软件、麒麟软件、麒麟信安等成为开源欧拉社区首批全球化先锋伙伴，大家将携手推进 openEuler 全球化进程。<br/>在全球开源组织协作层面，开源欧拉社区近期与 Zephyr 嵌入式技术基金会、Linux Foundation AI&amp;Data 基金会达成深度技术合作。目前，开源欧拉社区累计与 15 家全球开源组织在 AI、云、大数据、HPC、嵌入式等领域建立紧密合作关系。<br/><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdm3aP" alt="" title="" loading="lazy"/><br/>开源欧拉的成长得益于每一位伙伴和开发者的信任。大会现场揭晓了“2025 年度 openEuler 领先商业实践”，共计23个openEuler 年度领先商业实践项目，包括 9 个规模型项目与 14 个创新型项目。</p>]]></description></item><item>    <title><![CDATA[LLM调用的最佳数据格式：TOON，成本]]></title>    <link>https://segmentfault.com/a/1190000047400431</link>    <guid>https://segmentfault.com/a/1190000047400431</guid>    <pubDate>2025-11-14 17:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在大模型逐渐融入业务系统的阶段，结构化数据输入/输出已成为落地应用的必需：RAG 检索结果、Agent 工具调用参数、业务查询结果、批处理列表等都需要让自然语言与“可机读”的结构化格式互通。事实标准是 JSON，但在高频调用、海量数据场景下，JSON 的标点开销会显著推高 token 成本。</p><p>如下JSON格式的例子：</p><pre><code class="json">{
  "users": [
    {"id": 1, "name": "Alice", "role": "admin"},
    {"id": 2, "name": "Bob", "role": "user"}
  ]
}</code></pre><p>Tokens 为 <strong>47</strong>:</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400433" alt="" title=""/></p><p>采用 TOON 格式之后，内容明显减少：</p><pre><code>users[2]{id,name,role}:
  1,Alice,admin
  2,Bob,user</code></pre><p>Tokens 为：<strong>24</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400434" alt="" title="" loading="lazy"/></p><p>差异的核心在于：TOON 用“缩进 + 一次性字段声明”的方式消除了绝大部分语法标点的冗余；当你在生产环境每天传输成千上万条记录时，冗余标点的累计开销会直接转化为可观的 API 费用。实践表明，TOON 在输入侧常带来 40–60% 的 token 节省。</p><h2>基准测试：TOKEN减少、准确率上升</h2><p>TOON格式在LLM调用时候除了在Token数量上的优化之外，不可忽略的是LLM检索准确率。如果单纯Token数量减少了，而准确率下降了，那意义就不大了。</p><p>以下是TOON官方仓库给出的综合效率排名：</p><pre><code>TOON           ████████████████████   26.9  │  73.9% acc  │  2,744 tokens
JSON compact   █████████████████░░░   22.9  │  70.7% acc  │  3,081 tokens
YAML           ██████████████░░░░░░   18.6  │  69.0% acc  │  3,719 tokens
JSON           ███████████░░░░░░░░░   15.3  │  69.7% acc  │  4,545 tokens
XML            ██████████░░░░░░░░░░   13.0  │  67.1% acc  │  5,167 tokens</code></pre><p>TOON 的准确率达到 73.9% （JSON 的准确率为 69.7%），同时使用的标记数减少了 39.6% 。可以看到TOON不仅在Token数量上有优势，在准确率上也有明显优势，更多基准测试结果请参考TOON官方仓库。</p><h2>什么时候不用 TOON</h2><p>TOON 格式在处理统一类型的对象数组时表现出色，但在某些情况下，其他格式更为合适：</p><ul><li>嵌套过深或结构不规则 （表格适用性 ≈ 0%）：JSON-compact 通常使用较少的标记。例如：具有多个嵌套层的复杂配置对象。</li><li>半均匀数组 （约 40-60% 符合表格格式）：Token节省量减少。如果您的pipline已经依赖于 JSON，则建议优先使用 JSON。</li><li>纯表格数据 ：对于平面表格，CSV 比 TOON 格式文件更小。TOON 格式仅需少量额外开销（约 5-10%）即可提供结构信息（数组长度声明、字段头、分隔符作用域），从而提高 LLM 的可靠性。</li><li>对延迟要求严格的应用 ：如果端到端响应时间是您的首要考虑因素，请在您的实际环境中进行基准测试。某些部署（尤其是像 Ollama 这样的本地/量化模型）即使 TOON 的Token数量较少，处理紧凑型 JSON 的速度也可能更快。请测量两种格式的 TTFT、每秒Token数和总时间，并使用速度更快的格式。</li></ul><h2>Java 中如何使用 TOON</h2><p>对于数据格式转换，各主流语言都有好用的SDK可以直接拿来使用。以Java为例，可以使用：</p><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.felipestanzani&lt;/groupId&gt;
    &lt;artifactId&gt;jtoon&lt;/artifactId&gt;
    &lt;version&gt;0.1.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>用法也是非常简单，核心API如下：</p><pre><code class="java">// Java 对象 → TOON 字符串
String toon = JToon.encode(object);

// JSON 字符串 → TOON
String toon = JToon.encodeJson(jsonString);

// TOON → Java 对象
Object obj = JToon.decode(toonString);

// TOON → JSON 字符串
String json = JToon.decodeToJson(toonString);</code></pre><h2>小结</h2><p>本文介绍了LLM调用时JSON格式调用在Token消耗的劣势，从而引出TOON格式。对于合适场景，如果目前Token消耗量偏高的应用，可以考虑在数据格式上进行优化，从而实现成本的优化。目前你都用什么格式呢？是否有用过TOON呢？留言区可以聊一聊。</p><blockquote>更多技术干货分享可以关注<a href="https://link.segmentfault.com/?enc=pdh%2F4jCS327JS2DAugdCKg%3D%3D.fhr7JeEK%2Bl0raU%2FG1GnXhZUU%2Btk0c7%2BhZIMo4uwnQN4%3D" rel="nofollow" target="_blank">我的代码世界</a></blockquote>]]></description></item><item>    <title><![CDATA[敏捷转型不只是流程：资深 PM 如何带团]]></title>    <link>https://segmentfault.com/a/1190000047399649</link>    <guid>https://segmentfault.com/a/1190000047399649</guid>    <pubDate>2025-11-14 16:11:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>敏捷转型在国内企业中已经从“热词”进入“常态”，但很多组织的敏捷实践，却陷入了“表面繁荣、内在空心”的假敏捷困局。会议变多、节奏变快、工具上线，却没有带来真正的业务敏捷与团队成长。本文将从项目治理与组织效能的角度，带你看清“假敏捷”的根源，并给出走出困局的可执行路径。</p><h3>一、当敏捷成为形式：流程在跑，价值没动</h3><p>过去几年，“敏捷转型”几乎成为各大中台与研发部门的常规动作。</p><p>从互联网到制造业，从创业公司到国央企，大家都在跑 Scrum、开站会、做 OKR。但当我们深入项目现场，却常听到这样的反馈：</p><ul><li>“我们比以前更忙了，但交付节奏并没有变快。”</li><li>“站会时间越来越长，但沟通效率越来越低。”</li><li>“敏捷上线半年了，客户满意度依旧没有提升。”</li></ul><p>这就是典型的“假敏捷”：流程在跑，但组织的认知与能力并未同步升级。表面上似乎“一切更敏捷”，实际上只是把旧的项目管理习惯换了个新术语而已。</p><p>假敏捷的特征往往包括：</p><ul><li>敏捷被视为一套“标准化流程”而非“适应性机制”；</li><li>团队机械执行 Scrum 仪式，却不理解背后的逻辑；</li><li>管理层追求速度，却回避文化、结构与激励机制的变革。</li><li>综上可知，很多企业不是在做敏捷，而是在表演敏捷。</li></ul><h3>二、假敏捷的根因：方法换了，思维没变</h3><h4>1. 从“命令控制”到“赋能协作”的断层</h4><p>敏捷倡导团队拥有更高的自主权和责任感，但许多组织仍延续传统的层级管理思维。</p><p>管理者关注的是“项目是否按计划推进”，而不是“团队是否在创造价值”；团队执行的是“上级任务”，而非“用户导向”；汇报链条依旧冗长，决策依旧集中。</p><p>据 State of Agile Report 2024 调研显示，47% 的敏捷转型失败，根本原因是领导层思维未转变。</p><p>换言之，流程再精致、工具再完善，只要领导层仍旧以控制为核心，敏捷就无法生根。</p><h4>2. 流程替代思考：看板上跑的不是价值，而是任务</h4><p>Jira、ONES、Trello 等研发管理工具确实让项目更透明，也是敏捷转型中必不可少的一环，但它们不是灵丹妙药。敏捷转型告诉你“需要用”这些工具，但在真正使用工具前，你要学会“怎么用”这些工具。</p><p>很多团队误以为“上了工具＝实现敏捷”，于是陷入另一种形式主义。他们花大量时间在工具上填数据、拉报表，但当你仔细观察，就会发现：</p><ul><li>任务粒度不均、优先级模糊；</li><li>每个 Sprint 都在“堆工作量”；</li><li>燃尽图看似漂亮，但产出与战略目标脱节。</li></ul><p>由此可见，这种“流程优先”的陷阱容易让团队陷入效率幻觉——他们忙于完成流程，却未真正思考“这个功能是否真的为用户创造了价值“。</p><h4>3. 绩效机制错位：KPI 约束下的“假协作”</h4><p>传统绩效考核强调个人产出，而敏捷强调跨职能协同。当团队成员被单独考核时，他们自然更关注“自己的任务”而非“整体目标”。结果就是：每个人都很努力，但整体协作效率极低。</p><p>因此，绩效机制如果与敏捷文化背道而驰，就会导致“假协作”：看似合作，其实各自为战。敏捷无法在孤立的激励体系中存活。</p><h3>三、走出假敏捷：从流程治理到组织心智的再造</h3><p>敏捷不是自下而上的自发运动，而是自上而下的认知革新。要走出假敏捷，企业需要在三个层面完成升级：管理者心智、PMO 职能、团队实践。</p><h4>1. 管理者：从“掌控者”到“系统设计师”</h4><p>很多领导误解“授权”就是“放手”，结果要么管太死，要么彻底放任。事实上，真正的敏捷领导力，是设计一个让团队能高效自组织的系统，通过清晰的边界、价值导向和反馈机制，构建有秩序的灵活性。</p><p>管理者层面的改进建议：</p><ol><li><strong>重新定义控制：</strong>由“控制任务”转向“控制节奏与目标”，让高层参与 Sprint Review，而不是仅看汇报；</li><li><strong>系统化思维：</strong>管理者应关注跨部门协同的制度设计、信息透明机制，而非日常微观管理；</li><li><strong>创造心理安全空间：</strong>允许暴露问题，让团队敢于暴露问题、质疑流程、提出改进。</li></ol><p><strong>实操案例：</strong></p><p>某制造企业在推行敏捷时，领导层每月参与一次 Sprint Review，与团队共同识别瓶颈。六个月后，交付延误率下降 30%，员工主动改进的数量增加了两倍。</p><h4>2. PMO：从“流程守门人”到“学习促进者”</h4><p>传统 PMO 主要关注规范与合规，但在敏捷转型中，它应成为组织学习与持续改进的中枢。假敏捷常常因为 PMO 把“标准化”误解为“僵化”，而真正成熟的 PMO，是能在秩序与灵活之间找到平衡。</p><p>PMP 层面的改进建议：</p><ul><li><strong>从流程合规转向价值导向：</strong>不再问“是否按模板执行”，而关注“交付周期、客户反馈”等价值指标。</li><li><strong>搭建知识复用机制：</strong>将项目复盘、最佳实践沉淀为共享知识库，用于指导后续项目。</li><li><strong>推动跨团队共学机制：</strong>定期组织“敏捷社区”或“Guild（行会）”，分享案例、反思改进，让敏捷成为组织的共识，而非孤岛实践。</li></ul><p><strong>实操案例：</strong></p><p>某互联网企业 PMO 通过建立“敏捷数据仪表盘”，整合交付周期、缺陷率、满意度等指标，实现了跨部门的价值对齐，协作摩擦下降 40%。</p><h4>3. 团队：从“被敏捷”到“用敏捷”</h4><p>许多团队“学会了流程”，却没“掌握原理”。他们照本宣科地开会、填表，却没理解迭代的意义。真正的团队敏捷，应当从“执行者”变为“问题发现与解决的主体”。</p><p>敏捷不是别人要求你执行的流程，而是团队自主选择的工作方式。团队真正的成长在于从“遵循规则”走向“共创价值”。</p><p>团队层面的改进建议：</p><ul><li><strong>先聚焦于小胜：</strong>以一个可验证的小目标开启试点，快速体验改进收益。</li><li><strong>建立复盘文化：</strong>复盘不是找责任，而是发现系统性约束、优化模式。</li><li><strong>透明化沟通：</strong>让看板不仅仅展示任务，还要让风险、假设与反馈全部可见。</li></ul><p><strong>实操案例：</strong></p><p>一家 SaaS 团队在初期敏捷实施中，每次迭代只做任务分配，几乎无复盘。后来引入“失败展台”机制——每个迭代评选“最值得学习的失败”，团队反而更敢尝试。三个月后，创新方案产出率提升 40%，团队氛围明显改善。</p><h4>4. 工具赋能：从“工具使用”到“系统协同”</h4><p>工具是敏捷落地的加速器，而非终点。很多团队在敏捷转型初期被工具“反客为主”——流程为了工具而设计，会议为了数据而开。实际上，工具的价值在于让组织的反馈循环更快、协作更透明、改进更可视化。</p><p>要让工具真正服务于敏捷，应当遵循三个原则：</p><p><strong>① 从“记录”到“认知”</strong></p><p>工具不是任务登记簿，而是思考的镜子。在 ONES 等研发管理平台中，用户故事应表达“价值交付”而非单纯的“任务目标”。</p><p>举个例子：一个用户故事不应该只写”实现登录功能”，而应是“作为一名注册用户，我希望能通过手机号或企业账号快速登录系统，以便更方便地进入工作空间，减少首次登录失败率”。</p><p><strong>② 从“工具孤岛”到“系统协同”</strong></p><p>敏捷工具不是单一项目的容器，而是组织运营系统的一部分。企业可通过集成不同模块（项目、测试、OKR、客户反馈等），形成从目标 → 执行 → 反馈 → 改进的闭环。</p><p>例如，在 ONES 研发管理平台中将项目、测试与目标模块集成起来，团队可以在一次迭代中同时看到任务完成率与价值交付率——Sprint 不再是简单的时间盒，而是业务战略的执行节奏。</p><p>当工具协同起来，团队不再为“谁做什么”争论，而是能共同回答“我们为什么做”。</p><p><strong>③ 从“使用工具”到“用数据改进”</strong></p><p>真正成熟的团队，不只是用上工具，而是学会用数据驱动决策。</p><ul><li>通过 Lead Time 识别流程瓶颈；</li><li>用燃尽图偏差分析任务估算准确性；</li><li>通过 Velocity 趋势评估团队负载与可持续交付节奏。</li></ul><p>同时，将工具数据纳入团队回顾中，让复盘基于事实，而非感觉。当工具被正确使用，它不再是负担，而是团队反思与进步的放大镜。</p><h4>5. 构建组织级敏捷：从“团队敏捷”到“业务敏捷”</h4><p>走出“假敏捷”的终极目标，不是优化团队，而是提升组织整体的适应力。这需要企业从三个层次系统性升级：</p><table><thead><tr><th>层级</th><th>传统思维</th><th>敏捷思维</th><th>转型杠杆点</th></tr></thead><tbody><tr><td>战略层</td><td>目标分解、年度计划</td><td>动态 OKR、滚动规划</td><td>战略对齐与节奏共振</td></tr><tr><td>结构层</td><td>职能部门、项目制</td><td>跨职能小队、价值流</td><td>流程重构与组织协作</td></tr><tr><td>文化层</td><td>稳定、控制、预测</td><td>学习、信任、反馈</td><td>建立心理安全与改进文化</td></tr></tbody></table><p>整合建议：</p><ul><li>让团队 OKR 与企业战略形成自上而下的链路；</li><li>以价值流为核心优化组织架构，减少信息阻塞。</li><li>以文化机制支撑持续学习，如内部复盘大会、改进激励制度。</li></ul><p>这也意味着，当企业能在战略、结构与文化三个维度形成一致性，敏捷才会从“团队工具”演化为“组织能力”。</p><h3>四、敏捷的本质：速度不是目的，学习才是</h3><p>敏捷不是为了“更快”，而是为了“更聪明”，“更有价值”。真正的敏捷组织，不仅能高效交付，更能在不确定中学习与演化。</p><ul><li>它的节奏适中，但反馈及时；</li><li>它的文化开放，但有秩序；</li><li>它的目标清晰，但路径灵活。</li></ul><p>正如《Toyota Kata》所说：“成功的关键，不在于它的生产工具或技术，而在于它持续改进和适应变化的能力。”换言之，持续学习的能力，才决定了组织的长期竞争力。</p><p>敏捷不是一个阶段性的项目，而是一种长期主义的管理哲学。一个资深 PM 的使命，不只是执行流程，而是让组织具备持续学习与自我进化的能力。当管理者懂得系统设计，PMO 成为学习枢纽，团队学会自驱与反思时，敏捷就不再是“流程”，而是组织的本能。那一刻，敏捷不再是目标，而是企业文化的一部分。</p>]]></description></item><item>    <title><![CDATA[⚡️2025-11-14GitHub日榜]]></title>    <link>https://segmentfault.com/a/1190000047399876</link>    <guid>https://segmentfault.com/a/1190000047399876</guid>    <pubDate>2025-11-14 16:10:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>🚀 <a href="https://link.segmentfault.com/?enc=Q%2FD3GRM6X9MjIUq%2FV%2F1cdw%3D%3D.kfnYv5rLdtvakAKPEWULqotGW7mwqlLYvHNNXW612QLHAfHEDh5KRsKCk2LaWpgj" rel="nofollow" target="_blank">sansan0 /TrendRadar</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=g%2Blqv9KPvOfa8yaM9ZSsZg%3D%3D.vEliP5ywXNrciYPEBzZnWpQ5g%2BHcMYRBFS6ehFCUIncDsGK9PsiLiKebTkd7KLs%2B" rel="nofollow" target="_blank">https://github.com/sansan0/TrendRadar</a></p><p>💡 <strong>简介</strong>：趋势雷达是一个30秒快速部署的热点助手，支持11+主流平台热点聚合，通过智能推送策略、精准内容筛选和趋势分析，帮助用户获取真正关心的新闻资讯。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>2275</td></tr><tr><td>⭐ Stars</td><td>11686</td></tr><tr><td>⚒️ Forks</td><td>7068</td></tr><tr><td>💻 Language</td><td>Python</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>最快30秒部署的热点聚合工具</li><li>多平台热点实时监控与分析</li><li>智能推送策略与时间窗口控制</li><li>支持多渠道多端适配与AI分析功能</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=yNdU0zoByXuZgsDFPKy5jw%3D%3D.kBLvTASWQlbsIlzzdecaPS3j%2FPcf%2B1HCokzB9wpVuMQNbfVLrqlC6TIG8Q9Zevqt" rel="nofollow" target="_blank">google /adk-go</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=dDN3sQPewRFYtGuF5Z8Q7Q%3D%3D.P7aXq%2B62EgyYgFKtYjXJVCy9UmATg2P7UUmQBbgml%2FgKyjyJbrapjdcCu7VgEPLN" rel="nofollow" target="_blank">https://github.com/google/adk-go</a></p><p>💡 <strong>简介</strong>：Go代理开发工具包（ADK）是一个开源的、代码优先的Go工具包，用于构建、评估和部署复杂的AI代理，具有灵活性和可控性，且兼容其他框架与云原生环境。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>351</td></tr><tr><td>⭐ Stars</td><td>3197</td></tr><tr><td>⚒️ Forks</td><td>172</td></tr><tr><td>💻 Language</td><td>Go</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>代码优先开发，灵活性高</li><li>模块化多代理系统，扩展性强</li><li>符合Go习惯用法，性能优异</li><li>跨平台部署，云原生支持好</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=QnB8JuLaezsE94oWgCNFOw%3D%3D.GlyypL0Vq13U%2FxNqwqoSqU%2BTIbZpX%2FJMmmFF0JnKq47mC6RN7Etucchi3pqPcSPx" rel="nofollow" target="_blank">TapXWorld /ChinaTextbook</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=vU1%2FtDHX3g1wr%2FvXWCXg4w%3D%3D.dL9hbaxDZJO1R%2BZQs%2BbqKZPABaATK1hXjJepAZdRZu%2BBK3zPYjCgOha1EhZcOUQF" rel="nofollow" target="_blank">https://github.com/TapXWorld/ChinaTextbook</a></p><p>💡 <strong>简介</strong>：这是一个开源的中国教育资源项目，提供从小学到大学的数学教材，并提供文件合并程序以解决GitHub文件拆分问题，支持免费获取教育资源。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>399</td></tr><tr><td>⭐ Stars</td><td>56131</td></tr><tr><td>⚒️ Forks</td><td>12538</td></tr><tr><td>💻 Language</td><td>Roff</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>提供免费优质教育资源，促进义务教育普及</li><li>覆盖从小学到大学的完整数学学习资料体系</li><li>提供文件合并工具，解决大文件拆分问题</li><li>支持国内外用户便捷下载资源</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=e8XdA7%2Br68sq%2B2%2BKH287PQ%3D%3D.aU4wpgEfs9VaoxJtItES9zwU7zYbYcc%2BEP1rqlSbdfjiF0WInop64D4Q5H2haPno" rel="nofollow" target="_blank">yeongpin /cursor-free-vip</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=8LqhZAuRLHZ3zhzZFAkomw%3D%3D.MoIWcVleAmFkKmce%2FrdFoV3WdNTW5RO7e3CgzoDdnK91udXiwDnys%2Fsgw4gkGUy3" rel="nofollow" target="_blank">https://github.com/yeongpin/cursor-free-vip</a></p><p>💡 <strong>简介</strong>：Cursor Free VIP是一款支持Windows、macOS和Linux系统的工具，可重置Cursor配置，提供多语言支持，用于学习和研究，需以管理权限运行并保持最新版本。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>358</td></tr><tr><td>⭐ Stars</td><td>41585</td></tr><tr><td>⚒️ Forks</td><td>5014</td></tr><tr><td>💻 Language</td><td>Python</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>多平台支持Windows/macOS/Linux</li><li>多语言支持英文、简体中文等</li><li>可重置Cursor配置</li><li>自动化脚本便捷安装使用</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=FD9Sk3M7I8Pysj128ujE8w%3D%3D.ORrM4Giai8Fw5hL%2FeEOH7VG3kvcpvceOjnF4NzNe9Tk%3D" rel="nofollow" target="_blank">nvm-sh /nvm</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=j03vpgcnFUSHZVnEtBdbxQ%3D%3D.jVR8jgNBXQPaFwp8jianxxM9dbY%2FViT2vNbo4ycHMzw%3D" rel="nofollow" target="_blank">https://github.com/nvm-sh/nvm</a></p><p>💡 <strong>简介</strong>：nvm是一个Node.js版本管理器，允许用户快速安装和使用不同版本的Node.js，支持POSIX兼容shell，适用于Unix、macOS和Windows WSL平台。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>79</td></tr><tr><td>⭐ Stars</td><td>89195</td></tr><tr><td>⚒️ Forks</td><td>9554</td></tr><tr><td>💻 Language</td><td>Shell</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>支持多版本Node.js安装与切换</li><li>兼容多平台（Unix、macOS、Windows WSL）</li><li>支持POSIX兼容shell（sh、bash、zsh等）</li><li>提供便捷安装与升级脚本</li></ul>]]></description></item><item>    <title><![CDATA[（小程序查看DWG）在线CAD中的“组”]]></title>    <link>https://segmentfault.com/a/1190000047399880</link>    <guid>https://segmentfault.com/a/1190000047399880</guid>    <pubDate>2025-11-14 16:09:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在使用CAD工具进行绘图时，面对复杂的图形结构，如何高效地管理多个对象成为提升工作效率的关键。CAD提供的“组”功能，正是为解决这一问题而设计的实用工具。本文将全面介绍 mxcad 中”组“的概念，以及如何实现组相关的功能开发。</p><h2>一、什么是“组”（Group）？</h2><p>在CAD中，<strong>组（Group）</strong> 是指将多个图形对象逻辑地组合在一起，形成一个可被统一操作的集合。组不会创建新的图元实体，也不会改变对象本身的几何属性，仅是一种<strong>命名的对象集合</strong>，组对象包含特点如下：</p><ul><li>组内的对象保持独立，可单独编辑。</li><li>选择组中任意一个对象时，整个组可被选中（取决于系统设置）。</li><li>每个组有唯一的名称，便于识别和管理。</li><li>支持嵌套：一个组可以包含另一个组，形成层级结构。</li><li>组不作为独立实体存储在图形数据库中，仅作为对象的逻辑关联存在。</li></ul><h2>二、组的核心功能开发</h2><h3>1. 创建组</h3><p>该功能流程是从用户执行“创建组”命令开始。首先，系统初始化相关变量（如组名、描述和对象列表），并获取当前图形数据库中的组管理字典。<br/>随后进入主循环，提示用户“选择对象”。用户可以通过点击或框选方式选择一个或多个图形对象，所选对象的ID将被保存到临时列表中。<br/>在选择过程中，用户可随时输入关键字进行设置：</p><ul><li>输入 <strong>N（名称）</strong>：进入命名流程，系统提示“输入编组名”。此时可输入 <code>[查询(A)]</code> 来查看已存在的组名；若输入 <code>*</code> 或直接回车，则列出所有组；否则查询指定组信息。输入名称后，系统检查是否重名，若无冲突则保存名称并返回选择状态。</li><li>输入 <strong>D（说明）</strong>：进入说明设置，提示“输入编组说明”，用户输入的文本将作为该组的描述信息。</li></ul><p>当用户完成选择并按 <strong>回车或空格键</strong> 确认后，系统开始创建组：</p><ul><li>首先检查所选对象中是否有成员已属于其他组。</li><li>若存在此类情况，则弹出确认提示：“包含相同对象的组已经存在。仍要创建新的组？&lt;N&gt;”，并提供“是(Y)/否(N)”选项。</li><li>若用户选择“否”或取消操作，命令终止。</li><li>若用户确认继续或无冲突，则调用底层API创建组，并将之前输入的描述信息赋值给新组。</li></ul><p>最后，组创建完成，系统退出循环，命令执行结束。整个流程支持ESC中断或新命令打断，确保操作的安全性和灵活性。</p><p>根据上述流程调用 mxcad 内部API接口实现方法如下：</p><pre><code class="ts">import { McDbEntity, McDbGroup, McDbPolyline, McGePoint3d, McObjectId, MxCADSelectionSet, MxCADUiPrKeyWord, MxCADUiPrPoint, MxCADUiPrString, MxCADUtility, MxCpp } from "mxcad";
import { DetailedResult, MxFun, MrxDbgUiPrBaseReturn } from "mxdraw";
interface GroupObject {
    name: string,
    group: McDbGroup
}
// 根据实体查找组
const getGroupForEntity = (entity: McDbEntity): GroupObject[] =&gt; {
    const database = MxCpp.getCurrentDatabase()
    const groupDict = database.GetGroupDictionary()
    const handle = entity.getHandle()
    const groupNames = groupDict.getAllObjectName()
    const length = groupNames.length();
    let groupArr: GroupObject[] = [];
    for (let index = 0; index &lt; length; index++) {
        const groupName = groupNames.at(index);
        const groupId = groupDict.getAt(groupName)
        const group = groupId.getMcDbObject() as McDbGroup
        if (!group) continue;
        const entityIds = group.getAllEntityId();
        entityIds.forEach(entityId =&gt; {
            if (entityId.getMcDbEntity()?.getHandle() === handle) groupArr.push({ name: groupName, group })
        });
    };
    return groupArr
}
// 创建组
async function Mx_Group() {
  let description = ""
  let ids: McObjectId[] = [];
  const database = MxCpp.getCurrentDatabase();
  const groupDict = database.GetGroupDictionary();
  const mxcad = MxCpp.getCurrentMxCAD();
  // 设定未命名组名
  const groupNames = groupDict.getAllObjectName();
  let num = 0;
  groupNames.forEach(item =&gt; {
    if (/^\*/.test(item)) {
      num += 1;
    }
  });
  let name: string = `*A${num + 1}`;
  // 创建组
  const createGroup = async () =&gt; {
    const isPresence = ids.some((id) =&gt; {
      return database.getEntitiesInTheGroup(id).length !== 0
    })
    if (isPresence) {
      const getKey = new MxCADUiPrKeyWord();
      getKey.setMessage(`包含相同对象的组已经存在。仍要创建新的组？&lt;N&gt;`);
      getKey.setKeyWords(`[是(Y)/否(N)]`);
      const key = await getKey.go();
      ids.forEach(id =&gt; {
        id.getMcDbEntity().highlight(false);
      })
      mxcad.updateDisplay();
      if (key?.toLocaleUpperCase() === "N") {
        return
      }
      if (!key) return
    }
    if (database.CreateGroup(ids, name)) {
      const groupId = groupDict.getAt(name)
      const group = groupId.getMcDbObject() as McDbGroup;
      if (description) group.description = description;
      if (/^\*/.test(name)) {
        MxPluginContext.useMessage().success('未命名组已创建');
      } else {
        MxPluginContext.useMessage().success(`组${name}已创建`);
      }
      ids.forEach(id =&gt; {
        id.getMcDbEntity().highlight(false);
      })
      mxcad.updateDisplay();
    };
  };
  while (true) {
    const getEntityPt = new MxCADUiPrPoint();
    getEntityPt.setMessage('选择对象');
    getEntityPt.setKeyWords(`[名称(N)/说明(D)]`);
    getEntityPt.setDisableOsnap(true);
    getEntityPt.setDisableDynInput(true);
    getEntityPt.disableAllTrace(true);
    const hoverSelectEnts: McDbEntity[] = [];
    getEntityPt.setUserDraw((pt, pw) =&gt; {
      if (hoverSelectEnts.length) hoverSelectEnts.forEach(ent =&gt; ent.highlight(false));
      hoverSelectEnts.length = 0;
      const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
      if (entId.isValid() &amp;&amp; !ids.map(item =&gt; item.id).includes(entId.id)) {
        const ent = entId.getMcDbEntity();
        const arr = getGroupForEntity(ent);
        if (arr.length) {
          const group = arr[0].group;
          group.getAllEntityId().forEach(id =&gt; {
            const ent = id.getMcDbEntity();
            ent.highlight(true);
            hoverSelectEnts.push(ent)
          })
        } else {
          ent.highlight(true);
          hoverSelectEnts.push(ent)
        }
      }
    });
    const pt = await getEntityPt.go();
    hoverSelectEnts.forEach(ent =&gt; ent.highlight(false));
    // 如果选择关键字，则执行相关操作
    if (getEntityPt.getStatus() == MrxDbgUiPrBaseReturn.kKeyWord) {
      if (getEntityPt.isKeyWordPicked("N")) {
        while (true) {
          const getName = new MxCADUiPrString()
          getName.setMessage("输入编组名")
          getName.setKeyWords(`[查询(A)]`)
          const str = await getName.go()
          if (getName.getDetailedResult() === DetailedResult.kCodeAbort || getName.getDetailedResult() === DetailedResult.kEcsIn || getName.getDetailedResult() === DetailedResult.kNewCommadIn) return
          if (getEntityPt.getDetailedResult() === DetailedResult.kNullEnterIn || getEntityPt.getDetailedResult() === DetailedResult.kNullSpaceIn || getEntityPt.getDetailedResult() === DetailedResult.kMouseRightIn) {
            return createGroup()
          }
          if (getName.isKeyWordPicked("A")) {
            getName.setMessage("请输入要列出的编码组名"+ "&lt;*&gt;")
            getName.setKeyWords("")
            const name = await getName.go();
            if (getName.getDetailedResult() === DetailedResult.kCodeAbort || getName.getDetailedResult() === DetailedResult.kEcsIn || getName.getDetailedResult() === DetailedResult.kNewCommadIn) return
            if (name &amp;&amp; name !== "*") {
              const groupId = groupDict.getAt(name)
              const group = groupId.getMcDbObject() as McDbGroup
              MxFun.acutPrintf(`\n 定义的编组:`)
              if (group) {
                MxFun.acutPrintf(`\n${group.name}`)
              }
            }
            else if (name === "*" || getName.getDetailedResult() === DetailedResult.kNullEnterIn || getName.getDetailedResult() === DetailedResult.kNullSpaceIn) {
              const groupIds = groupDict.getAllObject()
              MxFun.acutPrintf(`\n 定义的编组:`)
              groupIds.forEach((groupId) =&gt; {
                const group = groupId.getMcDbObject() as McDbGroup
                group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
              })
            }
            continue;
          }
          if (!str) return;
          if (/^\*/.test(str)) {
            MxFun.acutPrintf(`*无效`);
            continue;
          }
          const groupId = groupDict.getAt(str)
          const group = groupId.getMcDbObject() as McDbGroup
          if (group &amp;&amp; groupId.isValid()) {
            MxFun.acutPrintf(`编组${str} 已经存在`);
            continue;
          }
          name = str;
          if (ids.length) {
            ids.forEach(id =&gt; {
              const ent = id.getMcDbEntity();
              ent.highlight(false);
            })
            return createGroup();
          } else {
            break;
          }
        }
      } else if (getEntityPt.isKeyWordPicked('D')) {
        const getName = new MxCADUiPrString()
        getName.setMessage("输入编组说明")
        const str = await getName.go();
        if (!str) break;
        description = str
        continue;
      }
    } else if (getEntityPt.getStatus() === MrxDbgUiPrBaseReturn.kNone) {
      if (!ids.length) {
        return MxPluginContext.useMessage().success('未选择对象，未创建编组');
      } else {
        ids.forEach(id =&gt; {
          const ent = id.getMcDbEntity();
          ent.highlight(false);
        })
        return createGroup();
      }
    } else if (getEntityPt.getStatus() === MrxDbgUiPrBaseReturn.kCancel) {
      ids.forEach(id =&gt; {
        const ent = id.getMcDbEntity();
        ent.highlight(false);
      })
      return
    } else {
      // 判断是否选中实体
      if (pt &amp;&amp; hoverSelectEnts.length) {
        const selectIds = hoverSelectEnts.map(item =&gt; {
          item.highlight(true);
          return item.getObjectID()
        })
        ids.push(...selectIds);
        continue;
      } else if (pt &amp;&amp; !hoverSelectEnts.length) {
        getEntityPt.setUserDraw((point, pw) =&gt; {
          const pts = [pt, new McGePoint3d(pt.x, point.y), point, new McGePoint3d(point.x, pt.y)]
          // 设置范围框颜色即位置
          let pl = new McDbPolyline();
          pl.isClosed = true;
          pts.forEach(pt =&gt; pl.addVertexAt(pt));
          pw.setColor(0xFFFFFF);
          pw.drawMcDbEntity(pl);
          // 动态绘制矩形填充框
          const geometry = new THREE.BufferGeometry();
          geometry.setFromPoints([
            new THREE.Vector3(pt.x, pt.y, pt.z),
            new THREE.Vector3(pt.x, point.y, point.z),
            new THREE.Vector3(point.x, point.y, point.z),
            new THREE.Vector3(point.x, pt.y, pt.z)
          ]);
          geometry.attributes.uv = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), 2);
          geometry.setIndex([0, 1, 2, 0, 2, 3]);
          // 创建材质（半透明的颜色）
          const material = new THREE.MeshBasicMaterial({
            color: 0x004D00,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
          });
          const mesh = new THREE.Mesh(geometry, material);
          pw.drawEntity(mesh);
        });
        const nextPt = await getEntityPt.go();
        if (!nextPt) break;
        const ss = new MxCADSelectionSet();
        await ss.crossingSelect(pt.x, pt.y, nextPt.x, nextPt.y);
        ss.forEach(id =&gt; {
          if (!ids.map(i =&gt; i.id).includes(id.id)) {
            const ent = id.getMcDbEntity();
            const arr = getGroupForEntity(ent);
            if (arr.length) {
              const group = arr[0].group;
              group.getAllEntityId().forEach(id =&gt; {
                id.getMcDbEntity().highlight(true)
                ids.push(id);
              })
            } else {
              ent.highlight(true);
              ids.push(id);
            }
          }
        });
        continue;
      } else {
        continue;
      };
    }
  }
}</code></pre><h3>2. 解除组</h3><p>解除组的功能流程如下：<br/>命令启动后，系统提示用户“选择组”，并支持通过关键字 <code>[名称(N)]</code> 切换为按名称分解模式。在用户操作过程中，系统启用悬停预览功能：当鼠标移动到某个对象上时，会自动查询该对象所属的组，并高亮显示该组内的所有成员对象，便于用户直观判断将要操作的范围。<br/>接下来，根据用户的选择进入不同分支：</p><p>1.<strong>若用户输入 N（名称）</strong>：<br/>   - 进入“按名称分解”模式，提示“输入编组名”。<br/>   - 支持输入关键字 <code>[查询(A)]</code>：</p><ul><li>若输入 <code>A</code>，可进一步输入要查询的组名；<br/>   - 输入 <code>*</code> 或直接回车，则列出当前图形中所有已定义的组名；<br/>   - 输入具体名称，则检查并显示该组是否存在。<br/>   - 用户输入组名后，系统查找对应组：<br/>   - 若存在，执行分解操作（清空组内对象并从组字典中移除），提示“组 已分解”；<br/>   - 若不存在，提示“编组 未定义”，并允许重新输入。</li></ul><p>2.<strong>若用户点击某个对象</strong>：<br/>   - 系统获取该对象，并查询其所属的所有组（一个对象可能属于多个组）。<br/>   - 若对象仅属于一个组，则直接选中该组，准备分解。<br/>   - 若对象属于多个组，则进入选择流程：<br/>     - 提示“对象是多个组的成员&lt;接受&gt;”，提供 <code>[接受(A)/下一个(N)]</code> 选项；<br/>     - 选择 <code>A</code>：接受当前高亮的组；<br/>     - 选择 <code>N</code>：切换到下一个组，并更新高亮显示；<br/>     - 可循环切换，直到用户确认或取消。<br/>   - 确定目标组后，记录其名称。</p><p>最后，系统根据选定的组名执行分解操作：</p><ul><li>从组字典中获取该组对象；</li><li>调用 <code>clear()</code> 清空组内成员引用；</li><li>调用 <code>remove()</code> 从字典中删除该组；</li><li>提示“组 已分解”或“对象不是组成员”（如未选中有效组）。</li></ul><p>操作完成后，清除所有高亮显示的对象，确保界面恢复整洁，命令结束。其具体实现代码如下：</p><pre><code class="ts">import { McDbEntity, McDbGroup, McDbPolyline, McGePoint3d, McObjectId, MxCADSelectionSet, MxCADUiPrKeyWord, MxCADUiPrPoint, MxCADUiPrString, MxCADUtility, MxCpp } from "mxcad";
import { DetailedResult, MxFun, MrxDbgUiPrBaseReturn } from "mxdraw";
// 解除编组
async function Mx_Ungroup() {
    const ents: McDbEntity[] = [];
    let groupArr: GroupObject[] = [];
    let name!: string;
    const database = MxCpp.getCurrentDatabase();
    const groupDict = database.GetGroupDictionary();
    let index: number = 0;
    const getEnt = new MxCADUiPrEntity();
    getEnt.setMessage('选择组');
    getEnt.setKeyWords(`[名称(N)]`);
    getEnt.setUserDraw((pt, pw) =&gt; {
        ents.forEach(ent =&gt; ent.highlight(false));
        ents.length = 0;
        const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
        if (entId.isValid()) {
            const ent = entId.getMcDbEntity();
            groupArr = getGroupForEntity(ent);//getGroupForEntity参考上述创建组内代码
            if (groupArr.length) {
                const group = groupArr[index].group;
                group.getAllEntityId().forEach(id =&gt; {
                    const entity = id.getMcDbEntity();
                    entity.highlight(true);
                    ents.push(entity);
                })
            }
        }
    });
    const entId = await getEnt.go();
    if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
        if (getEnt.isKeyWordPicked('N')) {
            while (true) {
                const getString = new MxCADUiPrString();
                getString.setMessage('输入编组名');
                getString.setKeyWords(`[查询(A)]`);
                const str = await getString.go();
                if (getString.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                    // 删除组
                    const groupId = groupDict.getAt(str);
                    const group = groupId.getMcDbObject() as McDbGroup;
                    if (groupId.isValid() &amp;&amp; group) {
                        group.clear();
                        groupDict.remove(str);
                        MxPluginContext.useMessage().success('组 ' + str + ' 已分解');
                        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
                        return;
                    } else {
                        MxFun.acutPrintf('编组 ' + str + ' 未定义');
                        continue;
                    }
                } else if (getString.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
                    // 查询组
                    getString.setMessage("请输入要列出的编码组名" + "&lt;*&gt;")
                    getString.setKeyWords("")
                    const name = await getString.go();
                    if (getString.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                        if (name &amp;&amp; name !== "*") {
                            const groupId = groupDict.getAt(name)
                            const group = groupId.getMcDbObject() as McDbGroup
                            MxFun.acutPrintf(`\n 定义的编组:`)
                            if (group) {
                                MxFun.acutPrintf(`\n${group.name}`)
                            }
                        } else if (name === "*") {
                            const groupIds = groupDict.getAllObject()
                            MxFun.acutPrintf(`\n 定义的编组:`)
                            groupIds.forEach((groupId) =&gt; {
                                const group = groupId.getMcDbObject() as McDbGroup
                                group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                            })
                        }
                    } else if (getString.getStatus() === MrxDbgUiPrBaseReturn.kNone) {
                        const groupIds = groupDict.getAllObject()
                        MxFun.acutPrintf(`\n 定义的编组:`)
                        groupIds.forEach((groupId) =&gt; {
                            const group = groupId.getMcDbObject() as McDbGroup
                            group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                        })
                    }
                    continue;
                }
            }
        }
    } else if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
        if (groupArr.length === 1) {
            name = groupArr[0].name
        } else if (groupArr.length &gt; 1) {
            while (true) {
                const getKeys = new MxCADUiPrKeyWord();
                getKeys.setMessage('对象是多个组的成员&lt;接受&gt;')
                getKeys.setKeyWords('[接受(A)/下一个(N)]');
                let key = await getKeys.go();
                if (key === "A") {
                    name = groupArr[index].name;
                    break;
                } else if (key === "N") {
                    ents.forEach(ent =&gt; ent.highlight(false));
                    ents.length = 0;
                    index + 1 &gt; groupArr.length - 1 ? index = 0 : index += 1;
                    const res = groupArr[index];
                    res.group.getAllEntityId().forEach(id =&gt; {
                        const ent = id.getMcDbEntity();
                        ent.highlight(true);
                        ents.push(ent);
                    });
                    continue;
                } else {
                    if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
                    return;
                }
            }
        }
        if (name) {
            const groupId = groupDict.getAt(name)
            const group = groupId.getMcDbObject() as McDbGroup
            if (group) {
                group.clear();
                groupDict.remove(name);
                MxPluginContext.useMessage().success(`组 ${name} 已分解`);
            } else {
                MxPluginContext.useMessage().success('对象不是组成员');
            }
        } else {
            MxPluginContext.useMessage().success('对象不是组成员');
        };
        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
    }
}</code></pre><h3>3. 编辑组</h3><p>编辑图形中已有对象组（Group）的交互式功能。其主要功能是允许用户通过选择对象或输入组名的方式，找到目标组，并对其进行<strong>添加成员、删除成员或重命名</strong>等操作。<br/>命令启动后，系统首先提示“选择组”，并支持通过关键字 <code>[名称(N)]</code> 切换为按名称选择模式。在用户移动鼠标时，系统会启用悬停预览功能：自动检测光标下的对象，查询其所属的组，并高亮显示该组内的所有成员，帮助用户直观判断当前将要操作的对象范围。</p><p>如果用户点击了一个对象，系统会获取该对象所属的所有组：</p><ul><li>若对象不属于任何组，则提示“对象不是组成员”；</li><li>若只属于一个组，则直接进入编辑操作；</li><li>若属于多个组，则提示“对象是多个组的成员&lt;接受&gt;”，并提供 <code>[接受(A)/下一个(N)]</code> 选项，用户可循环切换高亮不同的组，直到确认目标组。</li></ul><p>如果用户选择 <code>[名称(N)]</code> 模式，则进入按名称编辑流程：</p><ul><li>提示“输入组的名称”，并支持 <code>[查询(A)]</code> 关键字；</li><li>输入 <code>A</code> 后可查看所有组名（输入 <code>*</code>）或查询特定组是否存在；</li><li>输入有效组名后，若组存在，则加载并高亮其成员，进入编辑；若不存在，则提示“编组 xxx 不存在”，并允许重新输入。<br/>确定目标组后，系统弹出操作菜单：<code>[添加对象(A)/删除对象(R)/重命名(REN)]</code>。</li><li><strong>添加对象（A）</strong>：用户可通过单击或框选方式选择要加入的对象。系统会动态高亮预览可添加的对象（不包括已存在于组内的对象），支持窗口和交叉选择，完成后将所选对象追加到组中，并提示“添加对象成功！”。</li><li><strong>删除对象（R）</strong>：用户选择组内对象进行移除。系统仅允许删除当前组中的成员，选择后会从组中剔除这些对象，并通过清空后重新添加剩余对象的方式更新组内容。</li><li><p><strong>重命名（REN）</strong>：提示用户输入新名称。支持再次使用 <code>[查询(A)]</code> 查看现有组名以避免冲突。若新名称已被其他组使用，则提示“编组 xxx 已经存在”并要求重新输入；否则更新组名，并提示“修改组名成功”。<br/>实现上述流程的具体功能代码如下：</p><pre><code class="ts">import { McDbEntity, McDbGroup, McDbPolyline, McGePoint3d, McObjectId, MxCADSelectionSet, MxCADUiPrKeyWord, MxCADUiPrPoint, MxCADUiPrString, MxCADUtility, MxCpp } from "mxcad";
import { DetailedResult, MxFun, MrxDbgUiPrBaseReturn } from "mxdraw";
// 编辑组
async function Mx_Groupedit() {
    const ents: McDbEntity[] = [];//高亮实体数组
    let groupArr: GroupObject[] = [];//实体组集合
    let index: number = 0;
    let name: string = '';
    const database = MxCpp.getCurrentDatabase();
    const groupDict = database.GetGroupDictionary();
    const mxcad = MxCpp.getCurrentMxCAD();
    const editGroup = async () =&gt; {
        // 选中目标组
        if (groupArr.length === 1) {
            name = groupArr[0].name
        } else if (groupArr.length &gt; 1) {
            while (true) {
                const getKeys = new MxCADUiPrKeyWord();
                getKeys.setMessage('对象是多个组的成员&lt;接受&gt;')
                getKeys.setKeyWords(`[接受(A)/下一个(N)]`);
                let key = await getKeys.go();
                if (key === "A") {
                    name = groupArr[index].name;
                    break;
                } else if (key === "N") {
                    ents.forEach(ent =&gt; ent.highlight(false));
                    ents.length = 0;
                    index + 1 &gt; groupArr.length - 1 ? index = 0 : index += 1;
                    const res = groupArr[index];
                    res.group.getAllEntityId().forEach(id =&gt; {
                        const ent = id.getMcDbEntity();
                        ent.highlight(true);
                        ents.push(ent);
                    });
                    continue;
                } else {
                    continue;
                }
            }
        } else {
            name = '';
        }
        // 操作目标组
        if (name) {
            const groupId = groupDict.getAt(name)
            const group = groupId.getMcDbObject() as McDbGroup
            if (group) {
                // 进入编辑组
                const getKey = new MxCADUiPrKeyWord();
                getKey.setMessage(t('输入选项'));
                getKey.setKeyWords(`[添加对象(A)/删除对象(R)/重命名(REN)]`);
                const key = await getKey.go();
                if (!key) return;
                if (key === 'A') {
                    const selectIds: McObjectId[] = [];
                    // 添加对象
                    while (true) {
                        const getEntityPt = new MxCADUiPrPoint();
                        getEntityPt.setMessage('选择要添加到编组的对象');
                        getEntityPt.setDisableOsnap(true);
                        getEntityPt.setDisableDynInput(true);
                        getEntityPt.disableAllTrace(true);
                        const hoverSelectEnts: McDbEntity[] = [];
                        getEntityPt.setUserDraw((pt, pw) =&gt; {
                            if (hoverSelectEnts.length) hoverSelectEnts.forEach(ent =&gt; {
                                if (!ents.map(i =&gt; i.getObjectID().id).includes(ent.getObjectID().id)) ent.highlight(false);
                            });
                            hoverSelectEnts.length = 0;
                            const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
                            if (entId.isValid() &amp;&amp; !selectIds.map(item =&gt; item.id).includes(entId.id) &amp;&amp; !group.has(entId)) {
                                const ent = entId.getMcDbEntity();
                                const arr = getGroupForEntity(ent);
                                if (arr.length) {
                                    const group = arr[0].group;
                                    group.getAllEntityId().forEach(id =&gt; {
                                        const ent = id.getMcDbEntity();
                                        ent.highlight(true);
                                        hoverSelectEnts.push(ent)
                                    })
                                } else {
                                    ent.highlight(true);
                                    hoverSelectEnts.push(ent)
                                }
                            }
                        });
                        const pt = await getEntityPt.go();
                        if (!pt) {
                            if (hoverSelectEnts.length) hoverSelectEnts.forEach(item =&gt; item.highlight(false));
                            break;
                        } else {
                            // 判断是否选中实体
                            if (hoverSelectEnts.length) {
                                if (hoverSelectEnts.length) {
                                    hoverSelectEnts.forEach(ent =&gt; {
                                        selectIds.push(ent.getObjectID());
                                    })
                                };
                            } else {
                                getEntityPt.setUserDraw((point, pw) =&gt; {
                                    const pts = [pt, new McGePoint3d(pt.x, point.y), point, new McGePoint3d(point.x, pt.y)]
                                    // 设置范围框颜色即位置
                                    let pl = new McDbPolyline();
                                    pl.isClosed = true;
                                    pts.forEach(pt =&gt; pl.addVertexAt(pt));
                                    pw.setColor(0xFFFFFF);
                                    pw.drawMcDbEntity(pl);
 
                                    // 动态绘制矩形填充框
                                    const geometry = new THREE.BufferGeometry();
                                    geometry.setFromPoints([
                                        new THREE.Vector3(pt.x, pt.y, pt.z),
                                        new THREE.Vector3(pt.x, point.y, point.z),
                                        new THREE.Vector3(point.x, point.y, point.z),
                                        new THREE.Vector3(point.x, pt.y, pt.z)
                                    ]);
                                    geometry.attributes.uv = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), 2);
                                    geometry.setIndex([0, 1, 2, 0, 2, 3]);
                                    // 创建材质（半透明的颜色）
                                    const material = new THREE.MeshBasicMaterial({
                                        color: 0x004D00,
                                        transparent: true,
                                        opacity: 0.5,
                                        side: THREE.DoubleSide
                                    });
                                    const mesh = new THREE.Mesh(geometry, material);
                                    pw.drawEntity(mesh);
                                });
                                const nextPt = await getEntityPt.go();
                                if (!nextPt) break;
                                const ss = new MxCADSelectionSet();
                                await ss.crossingSelect(pt.x, pt.y, nextPt.x, nextPt.y);
                                ss.forEach(id =&gt; {
                                    if (!group.has(id) &amp;&amp; !selectIds.map(i =&gt; i.id).includes(id.id)) {
                                        const ent = id.getMcDbEntity();
                                        const arr = getGroupForEntity(ent);
                                        if (arr.length) {
                                            const group = arr[0].group;
                                            group.getAllEntityId().forEach(id =&gt; {
                                                id.getMcDbEntity()?.highlight(true);
                                                selectIds.push(id);
                                            })
                                        } else {
                                            id.getMcDbEntity()?.highlight(true);
                                            selectIds.push(id);
                                        }
                                    }
                                });
                            };
                            continue;
                        }
                    };
                    if (selectIds.length) {
                        selectIds.forEach(id =&gt; {
                            id.getMcDbEntity().highlight(false);
                            group.append(id);
                        });
                        MxPluginContext.useMessage().success('添加对象成功！');
                    }
                } else if (key === 'R') {
                    const selectIds: McObjectId[] = [];
                    while (true) {
                        const getEntityPt = new MxCADUiPrPoint();
                        getEntityPt.setMessage('选择要从编组中删除的对象');
                        getEntityPt.setDisableOsnap(true);
                        getEntityPt.setDisableDynInput(true);
                        getEntityPt.disableAllTrace(true);
                        const hoverSelectEnts: McDbEntity[] = [];
                        getEntityPt.setUserDraw((pt, pw) =&gt; {
                            const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
                            hoverSelectEnts.forEach(e =&gt; {
                                if (!group.has(e.getObjectID())) {
                                    e.highlight(false)
                                }
                            });
                            hoverSelectEnts.length = 0;
                            if (entId.isValid() &amp;&amp; !selectIds.map(i =&gt; i.id).includes(entId.id)) {
                                const ent = entId.getMcDbEntity();
                                ent.highlight(true);
                                hoverSelectEnts.push(ent)
                            }
                        });
                        const pt = await getEntityPt.go();
                        if (!pt) {
                            break;
                        } else {
                            // 判断是否选中实体
                            if (hoverSelectEnts.length) {
                                hoverSelectEnts.forEach(ent =&gt; {
                                    ent.highlight(false);
                                    if (group.has(ent.getObjectID())) {
                                        selectIds.push(ent.getObjectID())
                                    } else {
                                        MxFun.acutPrintf('对象不是组内元素，无法删除')
                                    }
                                })
                            } else {
                                getEntityPt.setUserDraw((point, pw) =&gt; {
                                    const pts = [pt, new McGePoint3d(pt.x, point.y), point, new McGePoint3d(point.x, pt.y)]
                                    // 设置范围框颜色即位置
                                    let pl = new McDbPolyline();
                                    pl.isClosed = true;
                                    pts.forEach(pt =&gt; pl.addVertexAt(pt));
                                    pw.setColor(0xFFFFFF);
                                    pw.drawMcDbEntity(pl);
 
                                    // 动态绘制矩形填充框
                                    const geometry = new THREE.BufferGeometry();
                                    geometry.setFromPoints([
                                        new THREE.Vector3(pt.x, pt.y, pt.z),
                                        new THREE.Vector3(pt.x, point.y, point.z),
                                        new THREE.Vector3(point.x, point.y, point.z),
                                        new THREE.Vector3(point.x, pt.y, pt.z)
                                    ]);
                                    geometry.attributes.uv = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), 2);
                                    geometry.setIndex([0, 1, 2, 0, 2, 3]);
                                    // 创建材质（半透明的颜色）
                                    const material = new THREE.MeshBasicMaterial({
                                        color: 0x004D00,
                                        transparent: true,
                                        opacity: 0.5,
                                        side: THREE.DoubleSide
                                    });
                                    const mesh = new THREE.Mesh(geometry, material);
                                    pw.drawEntity(mesh);
                                });
                                const nextPt = await getEntityPt.go();
                                if (!nextPt) break;
                                const ss = new MxCADSelectionSet();
                                await ss.crossingSelect(pt.x, pt.y, nextPt.x, nextPt.y);
                                ss.forEach(id =&gt; {
                                    if (group.has(id)) {
                                        const ent = id.getMcDbEntity();
                                        ent.highlight(false);
                                        selectIds.push(ent.getObjectID());
                                    }
                                });
                            };
                            continue;
                        }
                    };
                    if (selectIds.length) {
                        const newIds = ents.filter(ent =&gt; !selectIds.map(i =&gt; i.id).includes(ent.getObjectID().id)).map(ent =&gt; ent.getObjectID());
                        group.clear();
                        group.appendArray(newIds);
                    }
                } else if (key === 'REN') {
                    while (true) {
                        const getName = new MxCADUiPrString()
                        getName.setMessage("输入组的新名称" + `&lt;${group.name}&gt;`)
                        getName.setKeyWords('查询(A)]')
                        const str = await getName.go();
                        if (getName.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
                            if (getName.isKeyWordPicked("A")) {
                                getName.setMessage("请输入要列出的编码组名" + "&lt;*&gt;")
                                const name = await getName.go();
                                if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                                    if (name &amp;&amp; name !== "*") {
                                        const groupId = groupDict.getAt(name)
                                        const group = groupId.getMcDbObject() as McDbGroup
                                        MxFun.acutPrintf('定义的编组')
                                        if (group) {
                                            MxFun.acutPrintf(`\n${group.name}`)
                                        }
                                    } else if (name === "*") {
                                        const groupIds = groupDict.getAllObject()
                                        MxFun.acutPrintf(`\n 定义的编组:`)
                                        groupIds.forEach((groupId) =&gt; {
                                            const group = groupId.getMcDbObject() as McDbGroup
                                            group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                                        })
                                    }
                                } else {
                                    const groupIds = groupDict.getAllObject()
                                    MxFun.acutPrintf(`\n 定义的编组:`)
                                    groupIds.forEach((groupId) =&gt; {
                                        const group = groupId.getMcDbObject() as McDbGroup
                                        group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                                    })
                                }
                                continue;
                            }
                        } else if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                            const groupId = groupDict.getAt(str)
                            const _group = groupId.getMcDbObject() as McDbGroup
                            if (_group &amp;&amp; groupId.isValid()) {
                                MxFun.acutPrintf(`编组 ${str} 已经存在}`);
                                continue;
                            } else {
                                group.name = str;
                                MxPluginContext.useMessage().success('修改组名成功');
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }
            } else {
                MxPluginContext.useMessage().success('对象不是组成员');
            }
        }
        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
        mxcad.updateDisplay();
    }
    const getEnt = new MxCADUiPrEntity();
    getEnt.setMessage('选择组');
    getEnt.setKeyWords('[名称(N)]');
    getEnt.setUserDraw((pt, pw) =&gt; {
        ents.forEach(ent =&gt; ent.highlight(false));
        ents.length = 0;
        const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
        if (entId.isValid()) {
            const ent = entId.getMcDbEntity();
            groupArr = getGroupForEntity(ent);
            if (groupArr.length) {
                const group = groupArr[index].group;
                group.getAllEntityId().forEach(id =&gt; {
                    const entity = id.getMcDbEntity();
                    entity.highlight(true);
                    ents.push(entity);
                })
            }
        }
    });
    const entId = await getEnt.go();
    if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
        if (getEnt.isKeyWordPicked('N')) {
            // 选择关键字
            while (true) {
                const getName = new MxCADUiPrString()
                getName.setMessage("输入组的名称")
                getName.setKeyWords('[查询(A)]')
                const str = await getName.go();
                if (getName.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
                    if (getName.isKeyWordPicked("A")) {
                        getName.setMessage("请输入要列出的编码组名" + "&lt;*&gt;")
                        getName.setKeyWords("")
                        const name = await getName.go();
                        if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                            if (name &amp;&amp; name !== "*") {
                                const groupId = groupDict.getAt(name)
                                const group = groupId.getMcDbObject() as McDbGroup
                                MxFun.acutPrintf('定义的编组')
                                if (group) {
                                    MxFun.acutPrintf(`\n${group.name}`)
                                }
                            } else if (name === "*") {
                                const groupIds = groupDict.getAllObject()
                                MxFun.acutPrintf(`\n 定义的编组:`)
                                groupIds.forEach((groupId) =&gt; {
                                    const group = groupId.getMcDbObject() as McDbGroup
                                    group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                                })
                            }
                        } else {
                            const groupIds = groupDict.getAllObject()
                            MxFun.acutPrintf(`\n 定义的编组:`)
                            groupIds.forEach((groupId) =&gt; {
                                const group = groupId.getMcDbObject() as McDbGroup
                                group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                            })
                        }
                        continue;
                    }
                } else if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                    const groupId = groupDict.getAt(str)
                    const group = groupId.getMcDbObject() as McDbGroup
                    if (group &amp;&amp; groupId.isValid()) {
                        group.getAllEntityId().forEach(id =&gt; {
                            const ent = id.getMcDbEntity();
                            ent.highlight(true);
                            ents.push(ent);
                        })
                        groupArr.push({ name: group.name, group });
                        editGroup()
                        break;
                    } else {
                        MxFun.acutPrintf(`编组 ${str} 不存在`);
                        continue;
                    };
                } else {
                    break;
                }
            }
        }
    } else if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
        editGroup();
    } else {
        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
    }
}</code></pre></li></ul><h3>4. 启用或禁用组选择</h3><p>启用指定对象组的选择功能其执行过程如下：首先提示用户“请选择目标组”，并在鼠标悬停时自动检测光标下的对象，若该对象属于某个组，则实时高亮显示该组的所有成员，提供可视化反馈。用户点击对象后，系统获取其所属的第一个组，并将该组的 <code>isSelectable</code> 属性设置为 <code>true</code>，从而允许后续通过点击组内任意成员来选中整个组。最后清除高亮并刷新显示，完成设置。该方法提升了组对象的操作便捷性，适用于需要快速选中成组元素的场景。其完整代码如下：</p><pre><code class="ts">import { MxCADUiPrEntity, MxCADUtility, MxCpp} from "mxcad";
// 启用/禁用组选择
async function Mx_SetGroupSelection() {
    const ents: McDbEntity[] = [];
    let groupArr: GroupObject[] = [];
    const getEnt = new MxCADUiPrEntity();
    getEnt.setMessage('请选择目标组');
    getEnt.setUserDraw((pt, pw) =&gt; {
        ents.forEach(ent =&gt; ent.highlight(false));
        ents.length = 0;
        const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
        if (entId.isValid()) {
            const ent = entId.getMcDbEntity();
            groupArr = getGroupForEntity(ent);
            if (groupArr.length) {
                const group = groupArr[0].group;
                group.getAllEntityId().forEach(id =&gt; {
                    const entity = id.getMcDbEntity();
                    entity.highlight(true);
                    ents.push(entity);
                })
            }
        }
    });
    const entId = await getEnt.go();
    if (groupArr.length) {
        const group = groupArr[0].group;
        group.isSelectable = true;
        ents.forEach(ent =&gt; {
            ent.highlight(false);
        })
        MxCpp.getCurrentMxCAD().updateDisplay();
    };
}</code></pre><h2>三、功能演示</h2><p><img width="723" height="478" referrerpolicy="no-referrer" src="/img/bVdm22b" alt="" title=""/></p>]]></description></item><item>    <title><![CDATA[WeaveFox「AI 艺术家」创意大赛]]></title>    <link>https://segmentfault.com/a/1190000047399892</link>    <guid>https://segmentfault.com/a/1190000047399892</guid>    <pubDate>2025-11-14 16:08:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着AI时代的到来，天马行空的灵感可以快速变为现实。11月13日，由 <strong>WeaveFox 与 SEE Conf 联合发起的「AI艺术家」创意大赛</strong> 重磅来袭！这是一场属于创作者的挑战：你可以用一句自然语言、一张设计稿、一个灵感，在几分钟内，让 AI Coding 把你的想法变成现实。</p><p>参与大赛投稿评选，不仅有价值千元豪礼相送，更能直接解锁一票难求的 SEE Conf入场资格！这一次，我们不要“空想家”，只要敢动手的“你” ——<strong>用 WeaveFox 将灵感变为现实，“你”就是下一个被看见的「AI 艺术家」！</strong></p><p><img width="723" height="424" referrerpolicy="no-referrer" src="/img/bVdm22g" alt="网页-深1112.jpg" title="网页-深1112.jpg"/></p><blockquote>为什么不容错过？</blockquote><p>✅ 顶流入场券：SEE Conf 门票售罄？邀请好友参赛就能免费得！<br/>SEE Conf是什么？是前端人每年必蹲抢破头的年度技术盛宴，今年门票更是早早售罄！这里汇聚诸多大厂技术专家，前沿框架、实战经验、行业洞见。</p><p>参与本次大赛，成功邀请 10 位好友投稿就能直接获赠 SEE Conf 门票！优秀作品更将直接登上 WeaveFox 首页参与点赞排行，你的创意不仅可能收获千元大奖，更有机会被行业大咖“翻牌”！</p><p><a href="https://link.segmentfault.com/?enc=rJ3WwfdtAdDl0u4zXjkFCQ%3D%3D.JnWzyQkWVsLANPWXuA%2FHYKfD1O%2FfZLkMbsufTJn4wes%3D" rel="nofollow" target="_blank">点击查看 SEE Conf 2025 蚂蚁终端体验科技大会详情</a></p><p>✅ 零门槛创作：WeaveFox 帮你扫清所有障碍<br/>不会写代码？没关系！没有设计经验？不影响！WeaveFox 帮你轻松越过这些门槛 ！</p><p>输入“帮我做一个能记录学习计划的 AI 小工具”，或是上传一张想要实现的设计图，WeaveFox 会帮你完成设计到开发的全链路、直接生成可上线的应用，快速将 “灵感变为现实”，让每个人都能享受创作的快感。</p><p>✅ 丰厚奖品：豪礼+荣誉双丰收<br/>参赛即有机会拿奖，福利拉满！不用担心“陪跑”，你的每一份创意都有价值：</p><p>1、人气奖（Top 7）：点赞数 TOP7 将获价值 700- 1800 元梯度豪礼，从数码周边到实用好物，实力宠粉不手软；<br/>2、创意奖（5名）：组委会实名pick“脑洞王者”，赠送价值600元的新秀丽双肩包，出门自带“技术潮人”标识；<br/>3、邀请奖（敲重点）：成功邀请10位好友投稿，直接解锁 价值近 200元的 SEE Conf 限量门票！和前端大神面对面，机会不容错过！</p><blockquote>参赛全攻略：轻松争大奖</blockquote><p>📌 关键时间：敲黑板，别错过<br/>报名开启：2025年11月13日 10:00<br/>作品截止：2025年11月23日 23:59（10天创作期，足够你打磨灵感）<br/>奖品发放：2025年12月底，以官方通知为准</p><p>📌 投稿规则：创意无限（可以任选以下推荐主题进行创作）<br/>1、推荐主题：我的AI小帮手：比如“AI 问答机器人"，"AI 翻译小帮手等”。用AI应用解决你的日常痛点；<br/>2、推荐主题：经典复刻：用AI还原童年小游戏（如贪吃蛇、俄罗斯方块），或是复刻一款你喜欢的经典应用，玩出复古新花样。</p><p>📌投稿方式：一键投稿，如此方便<br/>1、登录 WeaveFox 官网（<a href="https://link.segmentfault.com/?enc=KR4wBgJaDpi1a8E9cKMACA%3D%3D.JqxGOLWkFmMm4w0C4BIBSRokh098JzGKrvb4rYz0NL6wlSyDbW2Tjh6Y2xkKHv5k" rel="nofollow" target="_blank">https://www.weavefox.cn/?ref=seeconf/</a>）；<br/>2、用 WeaveFox 将你的创意生成应用，围绕主题调试并优化。<br/>3、在作品详情页-&gt;点击“投稿到SEE Conf「AI艺术家」创意大赛”，或在活动弹窗选择作品-&gt;立即投稿，审核通过后，即可视为参赛成功！</p><p>进入大会官网  <a href="https://link.segmentfault.com/?enc=BOMvu6SPinxcCOMFK%2F62zQ%3D%3D.fuHpLWo1CZ%2FU9vytv%2FoX8OYJJXtnLI9jr8FalwrjwJ8%3D" rel="nofollow" target="_blank">https://seeconf.antgroup.com</a>，或登录 WeaveFox 直接投稿到创意大赛 ：<a href="https://link.segmentfault.com/?enc=6HG5pDRRGLaEqmXpgjWK1w%3D%3D.ZuzoA5q9MjCUNGWX2cVbcTkMfsHk5PkHo92iaFBNvoi1XIxpqUvN6RL%2Blj4oZykk" rel="nofollow" target="_blank">https://www.weavefox.cn/?ref=seeconf</a> ，立即参与吧！</p>]]></description></item><item>    <title><![CDATA[重磅巨制！以数字孪生之名，敬国之重器：福]]></title>    <link>https://segmentfault.com/a/1190000047399899</link>    <guid>https://segmentfault.com/a/1190000047399899</guid>    <pubDate>2025-11-14 16:08:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>11月5日，我国完全自主设计建造的首艘电磁弹射型航空母舰“福建舰”正式入列，标志着中国海军迈入三航母时代。平直通长飞行甲板、电磁弹射技术、8万余吨排水量，福建舰作为全球首艘采用常规动力电磁弹射技术的航母，正式入列开启中国海军新征程。</p><p>当福建舰身披海军军旗正式入列的那一刻，中华儿女的热血与自豪在南海之滨激荡。作为军事仿真技术领域的践行者，我们深知，国之重器的高光时刻不仅是钢铁与火焰的交响，更需要以科技为笔，在数字空间镌刻下属于中国海军的时代印记。</p><p>在这个伟大时代，我们选择以手中最前沿的数字孪生技术，向国之重器致以最崇高的敬意。</p><h2>数字铸舰，复刻雄师：福建舰航母编队数字孪生</h2><p>我们将 航母编队在 万里海疆的壮阔景象浓缩于方寸屏幕之间，通过高精度建模与实时仿真，一钉一铆地构建起这个虚拟编队，从甲板防滑纹路的精确模拟，到舰载机起降轨迹的实时渲染，每一个细节都力求还原真实世界的物理特性与作战逻辑。将福建舰及其完整编队呈现在虚拟海洋环境中，可近距离体验这一现代海军力量的核心要素。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2YL" alt="" title=""/><br/>这不仅仅是一次技术展示，更是大国力量在数字空间的真实绽放，它让每一位观者都能直观感受到中国海军迈向深蓝的坚定步伐。希望通过这个应用，将福建舰的先进性与国家强大的自豪感，传递给每一位关心国防事业的同胞，激发起更深厚的爱国情怀。</p><h4>福建舰 航母编队：体系化远洋攻防作战集群</h4><p><strong>福建舰航母编队绝非单一装备的简单拼凑，而是我国首款实现 “电磁弹射 + 隐身舰载机 + 固定翼预警机” 三位一体的体系化远洋作战集群</strong>。它开创了中国海军 “感知 - 指挥 - 打击 - 保障” 全链条自主可控的先河，每个成员都承载着 “首次突破” 的历史使命，以独有的开创性技术与定位，共同构筑起攻防兼备、远域慑止的深蓝雄师，标志着中国海军彻底迈入 “体系化远洋作战” 的新时代。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2YM" alt="" title="" loading="lazy"/><br/>在数字孪生系统中，当我们把视角聚焦南海深蓝，可以看到福建舰编队构筑起一个立体的攻防体系，其威慑范围充分体现了现代海战的战略纵深。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2YN" alt="" title="" loading="lazy"/><br/>1.<strong>“同心圆防御体系”</strong>：编队的感知体系，舰艇雷达 与 空警-600 预警机 共同编织了一张探测半径超1000公里的多维感知网，构筑起最外围的防空反导预警圈。<br/><img width="723" height="405" referrerpolicy="no-referrer" src="/img/bVdm2YO" alt="" title="" loading="lazy"/><br/>2.<strong>“空海协同打击圈”</strong>：在打击范围方面，导弹与舰载机火力交织，空海协同，将编队的有效控制与精确打击半径向前显著推进，打击半径足以覆盖西太平洋第二岛链。<br/><img width="723" height="414" referrerpolicy="no-referrer" src="/img/bVdm2YQ" alt="" title="" loading="lazy"/><br/>这意味着，福建舰编队不仅能在南海维护国家利益，还能在更广阔的远洋环境中执行威慑与干预任务，确保区域安全稳定。这种覆盖范围的扩展，绝非简单的距离叠加，而是体系化作战能力的体现。</p><h2>钢铁矩阵：编队核心装备“解密”</h2><h3>01海域 护航编队</h3><h4>“定海神针” 福建舰：自主可控，铸就大国航母新标杆</h4><p><strong>在世界航母发展史上，福建舰开创了 “常规动力 + 电磁弹射” 的全新技术路径，成为全球首艘采用这一组合的航空母舰。</strong><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y2" alt="" title="" loading="lazy"/><br/>福建舰满载排水量超过8万吨的电磁弹射航母，是我国目前吨位最大的航母，也是亚洲最大的常规动力航母，舰体设计首次实现 “平直通长甲板 + 小型化隐身舰岛” 的优化组合，3 条电磁弹射轨道与新型电磁拦阻系统配套，可适配从 歼 - 35 隐身战机 到 空警 - 600 预警机 的全谱系舰载机，其三部电磁弹射器可同时准备弹射作业，实现了舰载机起降效率的质的飞跃，开创了我国航母 “高效战力投送” 的新方式。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y5" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y6" alt="" title="" loading="lazy"/><br/>在整个航母编队体系中，福建舰是集机动部署、指挥控制、战力投送于一体的体系中枢，可实现对水上、水下、空中多维度目标的实时监控与数据融合，并将指挥指令精准传递至编队各舰艇、战机，实现 “一点发现、全网共享、协同打击” 的体系化作战模式。从战术层面看，福建舰既是舰载机的起降平台，也是编队的 “大脑” 与 “神经中枢”，其存在让分散的舰艇、战机形成有机整体，释放出体系化作战的最大效能。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y8" alt="" title="" loading="lazy"/></p><h4>“带刀护卫” 055 型驱逐舰：中国首款 万吨级 防空驱逐舰</h4><p><strong>055 型驱逐舰 是中国海军第四代导弹驱逐舰，我国首款满载排水量突破 1.2 万吨的大型驱逐舰，更是全球首款将综合射频系统与万吨体量完美融合的防空反舰核心舰，开创了中国海军 “大吨位、强火力、高智能” 的驱逐舰发展方向。</strong><br/>055 型驱逐舰 是 编队防空指挥所和全能护卫，利用先进双波段雷达系统与导弹系统，构筑起坚实的区域防空拦截线，不仅能有效保护航母的安全，更可凭借其强大的独立作战能力，率领其他舰艇组成独立编队，组织多目标拦截作战，其垂直发射系统可携带多种导弹，形成远、中、近三层攻防火力配系。是守护核心、拓展火力的 “全能卫士”，其技术水平与综合战力位居全球同类型驱逐舰前列。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Ze" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zf" alt="" title="" loading="lazy"/></p><h4>“水下利刃” 093 攻击核潜艇：中国首款静音型攻击核潜艇</h4><p><strong>093 型攻击核潜艇 是我国首款 具备现代化静音作战能力 的攻击核潜艇，更是首款专为航母编队配套设计的水下先锋，开创了中国海军 “深海隐蔽护航” 的作战模式。</strong><br/>093 型攻击核潜艇是编队的水下护航力量。采用先进降噪技术，具备在大洋深处隐蔽航行与待机的能力，在探测与火力方面，093 型攻击核潜艇可精准锁定远距离敌方潜艇与水面舰艇，并能在水下隐蔽状态下实施突然打击，成为编队前方与侧翼的 “水下警戒哨” 和 “突击利刃”让福建舰编队首次具备了远海水下反潜与反舰的体系化能力，填补了我国航母编队水下防御的空白，构筑起 “水面 - 空中 - 水下” 三位一体的立体防护网。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zi" alt="" title="" loading="lazy"/></p><h4>“远洋粮仓” 905 型综合补给舰：中国首款航母专用补给舰</h4><p><strong>905 型综合补给舰是我国首款具备大规模远洋补给能力的综合补给舰，更是首款实现海军编队 “远海伴随保障” 的专用补给平台，开创了中国海军 “告别近岸、走向深蓝” 的保障新纪元。</strong><br/>905 型综合补给舰是编队的 “续航基石”，满载排水量约 2.1 万吨，是我国首款真正意义上能支撑远海编队持续部署的补给舰，首次实现了 “燃油、弹药、食品、淡水” 多品类物资的一体化补给，能支撑航母编队在远海持续部署数月，为编队远洋存在提供了坚实的后勤支撑。作为我国远洋补给舰的 “开山之作”，905 型不仅奠定了我国海军补给舰的发展基础，更以其可靠的保障能力，成为福建舰编队驰骋深蓝的 “续航基石”。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zk" alt="" title="" loading="lazy"/></p><h3>02空中 舰载机联队</h3><h4>“制空利刃” 歼 - 35 舰载战斗机：中国首款舰载隐身战斗机</h4><p><strong>歼 - 35 是我国首款自主研发的舰载隐身战斗机，更是全球首款适配常规动力电磁弹射航母的第五代舰载机，开创了中国海军 “隐身制空” 的作战新纪元。</strong><br/>歼 - 35 是编队隐身突防的“尖刀”，具备在现代防空体系中隐蔽突防的能力，让福建舰编队首次具备了隐身突防与制空权争夺的绝对优势。在性能与适配性上，它首次实现了 “隐身 + 多任务” 的完美平衡，内置弹舱可携带 PL-15 中远程空空导弹、小型反舰导弹与精确制导炸弹，既能夺取制空权，又能实施对海对地精确打击；同时首次适配福建舰的电磁弹射系统，可实现满油满弹弹射起飞，作战半径超 1000 公里，与歼 - 15T 形成 “高低搭配”。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zl" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zm" alt="" title="" loading="lazy"/></p><h4>“重载先锋” 歼 - 15T 舰载战斗机：中国首款电磁弹射重型舰载战斗机</h4><p><strong>歼 - 15T 是我国首款适配电磁弹射系统的重型舰载战斗机，更是首款实现重载弹射能力的歼 - 15 改进型，开创了我国重型舰载机 “高效火力投送” 的新路径。</strong><br/>歼-15T “飞鲨” 是执行火力压制与空域控制任务的 “核心力量”，在对海打击中实施决定性精确攻击。在火力配置上，它首次实现了 “全谱系弹药适配”，能实施饱和式精确打击。作为歼 - 35 的 “黄金搭档”，它首次与隐身舰载机形成 “制空 + 打击” 的协同模式 —— 歼 - 35 夺取制空权后，歼 - 15T 凭借重载优势实施大规模火力突击，让编队的打击效能实现 “1+1&gt;2” 的倍增，彻底释放了电磁弹射技术带来的战力提升。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zp" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zr" alt="" title="" loading="lazy"/></p><h4>“海空鹰眼” 空警 - 600 预警机：开创了中国航母 “远域预警”</h4><p><strong>空警 - 600 是我国首款舰载固定翼预警机，更是亚洲首款适配电磁弹射系统的固定翼预警机，开创了中国航母 “远域预警” 的新时代。</strong><br/>空警-600固定翼预警机是航母编队的关键信息节点，让航母编队具备远海体系化空情保障能力。该机背部装有大型有源相控阵雷达，可探测数百公里外的空中与水面目标，尤其擅长捕捉低空突防的战机与掠海导弹，有效克服了地球曲率带来的探测盲区，在编队外围建立持续空中监视。在协同能力上，它首次实现与福建舰、055 型驱逐舰的数据链实时联动，能将探测到的目标数据秒级传输至编队各作战单元，同时可直接引导歼 - 35、歼 - 15T 舰载机实施超视距作战，构建起 “预警 - 指挥 - 打击” 的无缝衔接链条。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zx" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zy" alt="" title="" loading="lazy"/></p><h4>“多能支援” Z-20F 舰载直升机：中国首款专用舰载多任务直升机</h4><p><strong>Z-20F “海鹰” 是我国首款专为航母编队设计的多任务舰载直升机，更是首款实现反潜、搜救、运输一体化的舰载直升机，开创了中国海军 “舰载直升机多能化” 的新时代。</strong><br/>在航母编队体系中，Z-20F凭借其全域、全时出动能力，成为连接水面舰艇、水下力量与空中预警网络的重要节点，在任务适配性上，它首次实现 “一机多能”，既能执行水下反潜、海面搜救任务，又能承担舰艇间人员物资运输、近程侦察等支援任务，可快速响应编队多样化需求。Z-20 “海鹰” 的列装，让福建舰编队首次具备了全场景多任务支援能力，实现了 “攻防兼备、支援到位” 的体系化布局。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZB" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZC" alt="" title="" loading="lazy"/></p><h2>数字孪生内核支撑，复刻深蓝雄师全景态势</h2><p><strong>这份震撼的大国力量呈现，背后是数字冰雹全套自主研发的数字孪生底层技术支撑。</strong><br/>我们<strong>通过自研 图观 模型编辑器完成了编队全装备的超高精度构建</strong>，装备的结构、参数、外观 每一处细节都 1:1 还原真实原型，确保国之重器的细节精准度与视觉质感。在此基础上，<strong>图观 流渲染场景编辑器 构建了全域海域环境</strong>，从南海的复杂海况、洋流特征到远海的光影变化、气象模拟，全方位还原真实远洋作战场景，让航母编队有了贴合实战的部署舞台。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZD" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZE" alt="" title="" loading="lazy"/><br/>最终，<strong>通过 孪易 IOC 实现全体系动态整合</strong>，将装备部署、战术协同、动态推演融为一体。孪易 IOC 精准指挥着舰载机的弹射起飞、飞行编队的协同掠过、以及整个护航编队中每一件装备的战术位置码放与机动。不仅实现了视觉上的震撼还原，更在物理规律与战术逻辑层面，确保了整个福建舰航母编队在数字空间中均以全景态势实时呈现。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZF" alt="" title="" loading="lazy"/><br/>整个工具链体系 高效、协同运行，既实现了 国之重器 “静态复刻精准度”，又达成了 “动态推演真实感”，让数字空间中的福建舰编队，成为可感知、可交互、可推演的国之重器数字镜像。</p><h2>从“近海防御”到“远海防卫”</h2><p><strong>福建舰入列 开启 三航母时代</strong><br/><strong>福建舰交付入列，意味着中国海军正式迈入三航母时代</strong>。这套数字孪生系统，不仅是对福建舰本身的精确还原，更是对中国海军现代化进程的生动诠释。从辽宁舰的试验探索，到山东舰的自主建造，再到福建舰的技术突破，中国航母事业的每一步跨越，都印证着国家科技水平、工业实力与综合国力的全面跃升。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZL" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm22B" alt="" title="" loading="lazy"/><br/>现代航母战斗群的精髓不在于单个装备的性能堆砌，而在于体系化作战能力的生成。福建舰编队作为一个完整的作战体系，各单元通过数据链实现信息共享，形成整体作战效能。福建舰航母编队构建的 “感知 - 指挥 - 打击 - 保障” 全链条体系化力量，而这股力量的形成，标志着中国海军实现了从 “近海防御” 到 “远洋存在” 的历史性跨越。<br/>这支力量不用于炮舰外交，不谋求海上霸权，只为那句“守护万里海疆”的铮铮誓言！系统中模拟的劈波斩浪、壮阔夕阳下的航母编队，正是对中国海军走向深蓝的最美诠释。</p><h2>数字孪生，见证强军；中国海军，向海图强！</h2>]]></description></item><item>    <title><![CDATA[HarmonyOS 6.0 服务卡片实战]]></title>    <link>https://segmentfault.com/a/1190000047399918</link>    <guid>https://segmentfault.com/a/1190000047399918</guid>    <pubDate>2025-11-14 16:07:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>HarmonyOS 6.0 服务卡片实战：把「轻食刻」装进桌面，让轻断食一眼可控</h2><blockquote>本文基于HarmonyOS 6.0 ArkTS开发框架，结合轻食刻健康管理应用的服务卡片<code>Form Kit</code>开发实践，详细解析了<code>formProvider.openFormManager</code>等核心API在实际项目中的应用。通过具体代码示例和架构设计，展示了如何将复杂的健康数据以简洁直观的方式呈现在用户桌面上。</blockquote><h3>项目背景</h3><p>轻食刻是一款专注于轻断食和健康管理的应用，在日常使用中我发现用户需要频繁查看断食进度、体重变化等关键数据。为了提升用户体验，我决定利用HarmonyOS 6.0的服务卡片技术，让用户无需打开应用即可在桌面上快速获取这些信息。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399921" alt="8aaff505e95f1d0ceca9f59d658d6f1a.jpg" title="8aaff505e95f1d0ceca9f59d658d6f1a.jpg"/></p><h3>一、服务卡片技术概述</h3><h4>1.1 HarmonyOS 6.0服务卡片技术特性</h4><p>在轻食刻项目中，我充分利用了HarmonyOS 6.0服务卡片的以下技术特性：</p><ul><li><strong>Form Kit核心能力</strong>：从API version 18开始，Form Kit提供在应用内将ArkTS卡片添加到桌面的能力，极大提升了用户体验</li><li><strong>ArkTS声明式UI</strong>：采用统一的声明式开发范式，提升开发效率</li><li><strong>动态更新机制</strong>：支持定时更新和事件触发更新</li><li><strong>多样化交互</strong>：支持router、message、call三种事件类型</li><li><strong>多尺寸适配</strong>：兼容2<em>2、2</em>4、4*4等常见卡片尺寸</li><li><strong>卡片管理API</strong>：通过<code>formProvider.openFormManager</code>实现便捷的卡片管理</li><li><strong>完善的生命周期</strong>：提供完整的创建、更新、销毁等生命周期回调</li></ul><p><strong>重要说明</strong>：应用内拉起卡片管理加桌面的功能需要API version 18及以上版本支持，低于API version 18的设备无法使用此能力。</p><h4>1.2 轻食刻服务卡片功能设计</h4><p>针对轻食刻的核心使用场景，我设计了以下服务卡片功能：</p><ul><li><strong>断食状态监控</strong>：实时显示断食进度和剩余时间</li><li><strong>体重趋势展示</strong>：通过图表展示体重变化趋势</li><li><strong>水分摄入跟踪</strong>：监控每日水分摄入情况</li><li><strong>快捷操作入口</strong>：提供开始/结束断食的便捷操作</li></ul><h3>二、服务卡片架构设计</h3><h4>2.1 整体架构</h4><p>轻食刻的服务卡片架构采用分层设计：</p><pre><code>┌─────────────────┐
│   服务卡片UI层   │
│  (HealthWidget)  │
└─────────────────┘
         │
┌─────────────────┐
│   业务逻辑层     │
│ (WidgetService)  │
└─────────────────┘
         │
┌─────────────────┐
│   数据访问层     │
│   (DataDao)     │
└─────────────────┘</code></pre><h4>2.2 核心组件说明</h4><p><strong>HealthWidget</strong>：服务卡片UI组件，负责数据展示和用户交互<br/><strong>WidgetReminderService</strong>：服务卡片提醒管理服务，处理卡片生命周期和提醒逻辑<br/><strong>SettingsDao</strong>：数据持久化组件，存储卡片配置和用户数据</p><h3>三、服务卡片实现详解</h3><h4>3.1 卡片配置文件</h4><p>首先，我需要在<code>form_config.json</code>中定义服务卡片的基本属性：</p><pre><code class="json">{
  "forms": [
    {
      "name": "health_widget",
      "description": "$string:health_widget_description",
      "src": "./ets/widgets/HealthWidget.ets",
      "uiSyntax": "arkts",
      "window": {
        "designWidth": 720,
        "autoDesignWidth": true
      },
      "colorMode": "auto",
      "formConfigAbility": "ability://com.kirk.fastone.HealthFormAbility",
      "formVisibleNotify": true,
      "isDefault": true,
      "updateEnabled": true,
      "scheduledUpdateTime": "10:30",
      "updateDuration": 1,
      "defaultDimension": "2*2",
      "supportDimensions": ["2*2", "2*4", "4*4"]
    }
  ]
}</code></pre><p><strong>关键配置说明</strong>：</p><ul><li><code>scheduledUpdateTime</code>：设置定时更新时间</li><li><code>updateDuration</code>：更新间隔（小时）</li><li><code>supportDimensions</code>：支持的卡片尺寸</li></ul><h4>3.2 服务卡片UI组件</h4><p>以下是健康数据卡片的核心UI实现：</p><pre><code class="typescript">// HealthWidget.ets - 健康数据服务卡片
@Entry
@Component
export struct HealthWidget {
  @LocalStorageProp('fastingStatus') fastingStatus: FastingStatus = new FastingStatus();
  @LocalStorageProp('weightData') weightData: WeightData[] = [];
  @LocalStorageProp('waterIntake') waterIntake: number = 0;

  build() {
    Column() {
      // 断食状态区域
      this.buildFastingSection()
      
      // 体重趋势区域
      this.buildWeightSection()
      
      // 水分摄入区域
      this.buildWaterSection()
    
    }
    .width('100%')
    .height('100%')
    .padding(12)
    .backgroundColor($r('app.color.background_card'))
  }

  @Builder
  buildFastingSection() {
    Row() {
      Column({ space: 4 }) {
        Text('断食状态')
          .fontSize(12)
          .fontColor($r('app.color.text_secondary'))
        
        Text(this.fastingStatus.isFasting ? '进行中' : '未开始')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)
          .fontColor(this.fastingStatus.isFasting ? 
            $r('app.color.success') : $r('app.color.text_primary'))
        
        if (this.fastingStatus.isFasting) {
          Text(`剩余: ${this.fastingStatus.remainingTime}`)
            .fontSize(12)
            .fontColor($r('app.color.text_secondary'))
        }
      }
      .layoutWeight(1)
    }
    .width('100%')
  }
}</code></pre><h4>3.3 服务卡片提醒服务</h4><p>为了实现智能提醒功能，我设计了<code>WidgetReminderService</code>：</p><pre><code class="typescript">// WidgetReminderService.ets - 服务卡片提醒管理
/**
 * 服务卡片提醒类型
 */
export enum WidgetReminderType {
  WIDGET_ADD_REMINDER = 'widget_add_reminder', // 添加服务卡片提醒
  WIDGET_USAGE_REMINDER = 'widget_usage_reminder', // 使用服务卡片提醒
  WIDGET_UPDATE_REMINDER = 'widget_update_reminder' // 更新服务卡片提醒
}

/**
 * 服务卡片提醒管理服务
 */
export class WidgetReminderService {
  private static instance: WidgetReminderService;
  
  /**
   * 检查并触发服务卡片提醒
   */
  async checkAndTriggerWidgetReminders(): Promise&lt;void&gt; {
    try {
      const widgetStatus = await this.getWidgetStatus();
      const reminders = await this.getAllWidgetReminderSettings();
      
      for (const reminder of reminders) {
        if (reminder.enabled &amp;&amp; reminder.reminderCount &lt; reminder.maxReminders) {
          const shouldTrigger = await this.shouldTriggerReminder(reminder, widgetStatus);
          
          if (shouldTrigger) {
            await this.triggerWidgetReminder(reminder);
          }
        }
      }
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to check widget reminders: ${JSON.stringify(error)}`);
    }
  }

  /**
   * 判断是否应该触发提醒
   */
  private async shouldTriggerReminder(
    reminder: WidgetReminderSetting, 
    widgetStatus: WidgetStatus
  ): Promise&lt;boolean&gt; {
    // 检查时间间隔（至少间隔24小时）
    const now = Date.now();
    const twentyFourHours = 24 * 60 * 60 * 1000;
    if (reminder.lastReminderTime &gt; 0 &amp;&amp; (now - reminder.lastReminderTime) &lt; twentyFourHours) {
      return false;
    }

    // 根据提醒类型和条件判断
    switch (reminder.type) {
      case WidgetReminderType.WIDGET_ADD_REMINDER:
        return !widgetStatus.hasWidgetAdded &amp;&amp; widgetStatus.widgetUsageCount &gt;= 3;
        
      case WidgetReminderType.WIDGET_USAGE_REMINDER:
        return widgetStatus.hasWidgetAdded &amp;&amp; widgetStatus.widgetUsageCount &lt; 5;
        
      default:
        return false;
    }
  }
}</code></pre><h4>3.4 Form Kit卡片管理API实现</h4><h5>3.4.1 formProvider.openFormManager API应用</h5><p><strong>API版本要求</strong>：从API version 18开始，Form Kit提供在应用内将ArkTS卡片添加到桌面的能力，以方便用户后续便捷查看信息或快速进入应用。</p><p><strong>版本兼容性说明</strong>：</p><ul><li>✅ <strong>API version 18及以上</strong>：支持应用内拉起卡片管理加桌面功能</li><li>❌ <strong>API version 18以下</strong>：无法使用此能力，用户需要通过传统方式在桌面添加卡片</li></ul><p>在轻食刻项目中，我使用<code>formProvider.openFormManager</code>接口实现卡片管理功能：</p><pre><code class="typescript">// WidgetGuidePage.ets - 卡片管理页面跳转实现
private openWidgetManager(): void {
  try {
    const want: Want = {
      bundleName: 'com.kirk.fastone',
      abilityName: 'HealthFormAbility',
      parameters: {
        'ohos.extra.param.key.form_dimension': 2,
        'ohos.extra.param.key.form_name': 'widget',
        'ohos.extra.param.key.module_name': 'entry'
      },
    };
    
    // 检查API版本兼容性
    if (this.isApiVersionSupported(18)) {
      formProvider.openFormManager(want);
      console.info('WidgetGuidePage: Successfully opened form manager');
    } else {
      // API version 18以下设备的降级处理
      this.showLegacyWidgetGuide();
    }
    
  } catch (error) {
    console.error('WidgetGuidePage: Failed to open widget manager:', error);
    ToastUtil.showLong('⚠️ 暂无可用打开方式，请在桌面空白处长按，选择"服务卡片"，然后搜索"轻食刻"添加卡片');
  }
}

/**
 * 检查API版本是否支持
 */
private isApiVersionSupported(minVersion: number): boolean {
  const systemApiVersion = globalThis.system.apiVersion;
  return systemApiVersion &gt;= minVersion;
}

/**
 * 传统方式添加卡片引导
 */
private showLegacyWidgetGuide(): void {
  ToastUtil.showLong('📱 请在桌面空白处长按，选择"服务卡片"，然后搜索"轻食刻"添加卡片');
}</code></pre><p><strong>开发要点</strong>：</p><ul><li><strong>版本检查</strong>：在调用API前检查设备API版本，确保功能可用性</li><li><strong>参数配置</strong>：正确设置bundleName、abilityName等参数</li><li><strong>异常处理</strong>：完善的错误捕获和用户提示</li><li><strong>降级策略</strong>：为不支持API version 18的设备提供传统引导方式</li></ul><h5>3.4.2 卡片交互事件处理</h5><p>服务卡片支持多种交互事件，以下是事件处理的核心实现：</p><pre><code class="typescript">// 卡片内部事件处理
.onClick(() =&gt; {
  postCardAction(this, {
    action: 'router',
    abilityName: 'EntryAbility',
    params: {
      message: 'open_fasting_detail',
      targetPage: 'FastingDetailPage'
    }
  });
})

// 消息事件处理
.onClick(() =&gt; {
  postCardAction(this, {
    action: 'message',
    params: {
      message: 'toggle_fasting_status',
      actionType: this.fastingStatus.isFasting ? 'stop' : 'start'
    }
  });
})</code></pre><h3>四、关键技术点解析</h3><h4>4.1 卡片生命周期管理</h4><p>在轻食刻项目中，我通过<code>WidgetReminderService</code>实现了完整的卡片生命周期管理：</p><ul><li><strong>创建阶段</strong>：卡片首次添加到桌面时触发<code>onCreate</code>回调</li><li><strong>更新阶段</strong>：通过定时更新或事件触发更新，对应<code>onUpdate</code>回调</li><li><strong>销毁阶段</strong>：用户移除卡片时触发<code>onDestroy</code>回调</li><li><strong>可见性变化</strong>：卡片显示/隐藏时触发<code>onVisibilityChange</code>回调</li></ul><p>通过精细的生命周期管理，确保卡片状态与主应用保持同步。</p><h4>4.2 数据同步机制</h4><p>服务卡片与主应用之间的数据同步是关键挑战。我采用以下策略：</p><ol><li><strong>LocalStorage数据共享</strong>：使用<code>@LocalStorageProp</code>实现卡片与主应用数据同步</li><li><strong>定时更新机制</strong>：配置<code>scheduledUpdateTime</code>实现定时数据刷新</li><li><strong>事件触发更新</strong>：通过<code>postCardAction</code>触发即时数据更新</li></ol><h4>4.3 性能优化策略</h4><p>针对服务卡片的性能要求，我实施了以下优化措施：</p><ol><li><strong>内存优化</strong>：控制卡片UI复杂度，避免过多嵌套</li><li><strong>渲染优化</strong>：使用<code>LazyForEach</code>优化列表渲染</li><li><strong>数据优化</strong>：仅加载必要数据，控制数据更新量</li><li><strong>更新策略</strong>：合理设置更新频率，避免频繁刷新</li></ol><p>通过这些优化，轻食刻服务卡片在保证功能完整性的同时，实现了流畅的用户体验。</p><h4>4.4 用户体验设计</h4><p>在用户体验方面，我重点关注：</p><ul><li><strong>信息层级</strong>：重要信息突出显示，次要信息适当弱化</li><li><strong>交互反馈</strong>：点击操作提供明确的视觉反馈</li><li><p><strong>状态指示</strong>：使用颜色和图标清晰表示不同状态</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399922" alt="26aeaa72751409ea0554972ed7ff7948.jpg" title="26aeaa72751409ea0554972ed7ff7948.jpg" loading="lazy"/></p></li></ul><h3>五、开发实践与经验总结</h3><h4>5.1 开发流程建议</h4><p>基于轻食刻项目的开发经验，我建议采用以下开发流程：</p><ol><li><strong>需求分析</strong>：明确卡片功能定位和用户使用场景</li><li><strong>UI设计</strong>：设计简洁直观的卡片界面</li><li><strong>技术选型</strong>：选择合适的卡片尺寸和交互方式</li><li><strong>开发实现</strong>：按照HarmonyOS规范进行开发</li><li><strong>测试验证</strong>：在不同设备上测试卡片表现</li></ol><h4>5.2 开发中遇到的问题</h4><p>在轻食刻服务卡片开发过程中，我遇到了以下典型问题：</p><ul><li><p><strong>API调用失败</strong>：<code>formProvider.openFormManager</code>调用异常</p><ul><li><strong>解决方法</strong>：检查bundleName、abilityName配置，确认应用权限</li></ul></li><li><p><strong>数据同步延迟</strong>：卡片更新不及时</p><ul><li><strong>解决方法</strong>：优化数据同步机制，增加手动刷新功能</li></ul></li><li><p><strong>设备适配问题</strong>：不同设备显示效果不一致</p><ul><li><strong>解决方法</strong>：采用响应式布局，适配多种屏幕尺寸</li></ul></li><li><p><strong>交互响应延迟</strong>：卡片操作响应较慢</p><ul><li><strong>解决方法</strong>：优化事件处理逻辑，减少不必要的计算</li></ul></li></ul><h4>5.3 开发经验总结</h4><p>基于轻食刻项目的开发实践，我总结了以下经验：</p><ol><li><strong>API规范使用</strong>：正确使用<code>formProvider.openFormManager</code>等核心API</li><li><strong>代码规范</strong>：遵循HarmonyOS开发规范，保证代码质量</li><li><strong>性能优化</strong>：关注内存使用和渲染性能</li><li><strong>用户体验</strong>：以用户为中心设计交互流程</li><li><strong>测试覆盖</strong>：确保在各种场景下的稳定性</li></ol><h4>5.4 扩展能力展望</h4><p>基于HarmonyOS 6.0的服务卡片技术，未来可以进一步扩展：</p><ul><li><strong>AI健康建议</strong>：基于用户数据提供个性化健康建议</li><li><strong>社交分享</strong>：支持将健康成果分享到社交平台</li><li><strong>设备联动</strong>：与智能穿戴设备深度集成</li></ul><h4>5.5 学习方法与资源推荐</h4><p>在HarmonyOS开发过程中，开发过程中总结的一些经验：</p><ul><li><strong>文档使用</strong>：直接看API示例代码，重点关注版本更新说明</li><li><strong>问题解决</strong>：先排查基础配置，再社区求助，最后官方支持</li><li><strong>学习路径</strong>：从简单卡片开始，逐步增加复杂功能，注意版本兼容性</li><li><strong>持续学习</strong>：关注技术动态，多实践项目</li></ul><h3>六、总结</h3><p>通过轻食刻项目的服务卡片开发实践，我验证了HarmonyOS 6.0服务卡片技术的实用价值。该技术能够为用户提供便捷的信息获取方式，通过智能提醒和交互功能显著提升应用体验。</p><p>随着HarmonyOS生态的不断发展，服务卡片技术将在更多应用场景中发挥重要作用。我期待看到更多开发者利用这一技术，为用户创造更好的数字生活体验。</p><h3>参考资料</h3><h4>官方文档资源</h4><ol><li><a href="https://link.segmentfault.com/?enc=rsunEgqRds%2B7E0sJThzPZw%3D%3D.cFytr6D5AH9W7i4xs0bK0QBHbCi6U1IsJhd%2F6QUq6W8ivN%2FAHGo688CRrL5TkBf%2Fgf0esRFvWYof%2B2s9hdcvp0A8eBZfu9Y8mrtmmj5RCaQ%3D" rel="nofollow" target="_blank">HarmonyOS应用开发文档 - Form Kit服务卡片</a></li><li><a href="https://link.segmentfault.com/?enc=u%2FN%2ByXNGEsY9oqFyvF8NAQ%3D%3D.ufkJzewXNQ7uONj8LAgjlCcllS2kLOgauQzPUfWh%2FtyYBcJbVVscYDf0G0WjBsTGeCKImjvUuzHZ57S93WL6Mx2YUuCG3OkiFwFoh8P0tWfBacYEJLBcp1diRSMd4Q12" rel="nofollow" target="_blank">轻食刻 - 欢迎体验</a></li></ol><hr/><p><em>本文基于HarmonyOS 6.0和轻食刻项目v1.0.1版本编写，所有代码示例均经过实际测试验证。</em></p><h3>结语：为鸿蒙生态贡献力量</h3><p>通过轻食刻服务卡片的开发实践，我深刻体会到HarmonyOS作为新一代智能终端操作系统的强大技术实力和生态价值。作为一名鸿蒙开发者，我深感荣幸能够参与到这个充满活力的生态建设中。</p>]]></description></item><item>    <title><![CDATA[解决“Move to iOS 卡在准备中]]></title>    <link>https://segmentfault.com/a/1190000047399937</link>    <guid>https://segmentfault.com/a/1190000047399937</guid>    <pubDate>2025-11-14 16:06:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>从安卓换到 iPhone 时，是否也遇到了“Move to iOS 卡在准备中”的问题？别担心，你并不孤单。这个问题通常由 Wi-Fi 不稳定或传输数据过多引起。下面我们将提供 9 种快速解决方案，帮助你顺利完成数据传输。首先，我们来了解一下“准备中”通常需要多长时间。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399939" alt="图片" title="图片"/></p><p>为什么 iPhone 准备传输需要那么久？</p><pre><code>Wi-Fi 信号弱——请确保连接稳定。
数据量过大——请耐心等待，或分批传输。
后台应用干扰——关闭所有后台程序。
系统版本过旧——请更新两部设备。
连接异常——可尝试开关蓝牙/Wi-Fi。
iPhone 存储空间不足——请清理空间。

</code></pre><h3>第一部分：Move to iOS 准备阶段通常需要多久？</h3><p>Move to iOS 是苹果官方提供的安卓到 iPhone 数据迁移工具。准备阶段所需时间取决于你的 Wi-Fi 网络状况和传输的数据量。如果 Wi-Fi 信号较弱或数据量较大，准备过程可能需要 1 小时甚至更久。在某些情况下，“准备中”是正常现象，建议耐心等待。但如果时间过长，建议使用以下方法进行排查和修复。</p><h3>第二部分：解决“Move to iOS 卡在准备中”的 9 种方法</h3><p>方法 1：保持设备靠近</p><p>使用无线传输时，请将两部设备保持在 5–15 英尺（约 1.5–4.5 米） 范围内。距离过远可能导致传输失败或卡在“准备中”。</p><p>方法 2：检查 Move to iOS 的兼容性</p><pre><code>安卓设备需运行 Android 4.0 及以上版本
iPhone 需运行 iOS 9.0 及以上版本
确保两部设备连接至 同一个 Wi-Fi 网络
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399940" alt="图片" title="图片" loading="lazy"/></p><p>方法 3：检查 Wi-Fi 连接</p><p>如果反复出现“Move to iOS 准备中卡住”，请先检查路由器，并尝试打开其他网页或应用测试网络是否稳定。<br/>如网络异常，请重新连接 Wi-Fi 或重启路由器。<br/>你也可以尝试重置 iPhone 网络设置：<br/>设置 &gt; 通用 &gt; 传输或还原 iPhone &gt; 还原 &gt; 还原网络设置</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399941" alt="图片" title="图片" loading="lazy"/></p><p>方法 4：关闭“连接优化器”（Connections Optimizer）</p><p>安卓 8.0 及以上系统可能自动切换 Wi-Fi 和移动网络，建议关闭：</p><pre><code>进入 设置 &gt; 连接 &gt; 移动网络 &gt; 连接优化器
关闭“连接优化器”开关

</code></pre><p>方法 5：关闭“智能网络切换”（Smart Network Switch）</p><p>安卓 4.3 及以上系统可能启用“智能网络切换”，请关闭：</p><pre><code>打开 设置 &gt; Wi-Fi
点击右上角“更多”或“菜单”按钮
选择“智能网络切换”并取消勾选
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399942" alt="图片" title="图片" loading="lazy"/></p><p>方法 6：检查 iPhone 存储空间</p><pre><code>进入 设置 &gt; 通用 &gt; iPhone 存储空间
查看可用空间是否充足（灰色部分为剩余空间）
如空间不足，可卸载不常用应用或删除大文件
建议提前将重要文件备份至 iCloud 或电脑
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399943" alt="图片" title="图片" loading="lazy"/></p><p>方法 7：开启飞行模式</p><p>在 iPhone 上开启飞行模式可避免因网络干扰导致的传输失败。<br/>打开控制中心，点击飞机图标即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399944" alt="图片" title="图片" loading="lazy"/></p><p>方法 8：关闭所有后台应用</p><p>安卓后台应用可能干扰 Move to iOS 运行，建议全部关闭：</p><pre><code>进入 设置 &gt; 应用
查看正在运行的应用，逐个点击并选择“强制停止”
或直接卸载不常用的应用
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399945" alt="图片" title="图片" loading="lazy"/></p><p>方法 9：重启两部手机</p><p>重启可清除系统缓存和临时故障：</p><pre><code>安卓：长按电源键 &gt; 重启
iPhone：长按电源键 &gt; 滑动关机 &gt; 再次开机

</code></pre><h3>第三部分：使用更稳定的 Move to iOS 替代工具 —— iReaShare Phone Transfer</h3><p>如果你尝试了以上方法仍然无法解决问题，或者 Move to iOS 传输速度太慢，我们强烈推荐使用更专业的替代工具：iReaShare Phone Transfer（支持 Windows 和 Mac）。这是一款领先的手机数据传输工具，支持安卓与 iPhone 之间的快速迁移，不会卡在“准备中”，操作简单，传输稳定。</p><p>iReaShare Phone Transfer 的主要优势：</p><pre><code>快速将数据从安卓迁移至 iPhone，不卡在准备阶段
支持联系人、短信、通话记录、照片、视频、音乐、文档、应用、书籍等多种数据类型
不覆盖原有数据，零数据丢失风险
兼容几乎所有安卓与苹果设备，包括最新的 三星 S25 和 iPhone 16 系列
保护用户隐私，本地传输，不上传云端

</code></pre><p>使用步骤（安卓传数据到 iPhone）：</p><p>步骤 1： 下载并安装 iReaShare Phone Transfer 至电脑。</p><p><img width="723" height="492" referrerpolicy="no-referrer" src="/img/bVdm226" alt="" title="" loading="lazy"/></p><p>​编辑步骤 2： 使用 USB 数据线分别连接安卓手机与 iPhone 至电脑，软件将自动识别设备。<br/>步骤 3： 确保 iPhone 显示在右侧“目标设备”位置，如不对可点击“翻转”按钮调整。<br/>步骤 4： 勾选你想传输的数据类型，点击“开始复制”按钮，立即开始迁移。</p><h3>总结</h3><p>本文详细介绍了“Move to iOS 卡在准备中”的常见原因及 9 种解决方法。如果你希望更快、更稳定地完成安卓到 iPhone 的数据迁移，建议使用 iReaShare Phone Transfer 作为 Move to iOS 的替代方案，避免卡顿、失败、耗时等问题。<br/>​</p>]]></description></item><item>    <title><![CDATA[从缺陷预防到良率提升：涂装工艺质量管理的]]></title>    <link>https://segmentfault.com/a/1190000047399977</link>    <guid>https://segmentfault.com/a/1190000047399977</guid>    <pubDate>2025-11-14 16:05:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>从缺陷预防到良率提升：涂装工艺质量管理的智能化转型路径<br/>涂装工艺作为现代制造业的核心环节，尤其在汽车、家电和消费电子等领域，其质量管理直接关系到产品的防护性、装饰性和市场竞争力。随着行业对环保、效率和成本控制的要求日益严格，涂装工艺质量管理已成为企业必须高度重视的战略议题。一个健全的质量管理体系不仅需要覆盖从原材料到成品的全流程，还必须融入数据驱动和智能化手段，以确保一致性、可靠性和可持续性。<br/>在涂装工艺中，质量管理始于前处理阶段，这是整个流程的基础。例如，在汽车制造业中，脱脂和磷化过程的质量控制直接影响车身的耐腐蚀性能和涂层附着力。如果前处理不当，即使后续喷涂工艺再精湛，也无法避免起泡、剥落等缺陷。行业案例显示，某知名汽车品牌曾因磷化膜不均匀导致批量召回，损失高达数百万美元，这突显了前处理质量管理的重要性。通过引入自动化检测系统，如实时监控槽液浓度和温度，企业可以大幅减少人为误差，提升过程稳定性。<br/>喷涂环节的质量管理同样至关重要，尤其是电泳、中涂和面漆的均匀性与厚度控制。在静电喷涂中，涂料利用率和涂层一致性是关键指标。家电行业的一个典型例子是冰箱外壳涂装：如果清漆层厚度不均，会导致光泽度差异，影响产品外观和消费者体验。传统上，企业依赖人工抽样检测，但这种方式效率低且易漏检。现代质量管理则倾向于采用在线测量技术，如红外光谱仪或激光测厚仪，实现全数检验和数据实时反馈。这不仅提高了检测精度，还缩短了反馈周期，使问题得以快速纠正。<br/>固化与干燥过程的质量管理往往被忽视，却是决定涂层最终性能的环节。温度和时间控制不当会导致固化不完全或过烘烤，进而引发漆膜脆化、变色等问题。在消费电子行业，如智能手机外壳涂装，固化炉的温均匀性必须保持在±5°C以内，以确保颜色一致性和耐久性。通过集成物联网（IoT）传感器和数据分析平台，企业可以实时监控炉温曲线，并自动调整参数以应对波动。这种智能化手段不仅提升了质量稳定性，还降低了能源消耗，符合绿色制造趋势。<br/>行业例子进一步说明，涂装工艺质量管理需要跨部门协作和持续改进文化。在汽车制造中，广域铭岛作为行业解决方案提供商，通过其数字化平台帮助车企整合涂装线数据，实现从订单到交付的全链路可视化。例如，某合作车企利用该平台将生产、质量、工艺、设备的管理逻辑融入系统，实现涂装核心业务自动运行，提升效率。涂装质量数据实时采集上传，发现涂装质量趋势达到既定范围马上预警，实现数据驱动管理。涂装车间提升效率年收益约人民币 53.45 万元/年、减少返修，节约返修产生的物辅料费用约人民币 4.2 万元/年。<br/>总之，涂装工艺质量管理是一个多维度的系统工程，涉及技术、流程和人员素质的综合提升。随着工业4.0的推进，人工智能、大数据和云计算正成为质量管理的赋能工具。企业应拥抱这些创新，通过标准化操作、实时监控和持续优化，构建坚韧的质量体系。<br/>未来，质量管理将更加注重预测性和自适应能力，从而在激烈市场竞争中保持优势。通过借鉴行业最佳实践和利用先进技术，制造企业可以显著提升涂装工艺质量，驱动整体业务增长。</p>]]></description></item><item>    <title><![CDATA[用 Eino ADK 构建你的第一个 A]]></title>    <link>https://segmentfault.com/a/1190000047399985</link>    <guid>https://segmentfault.com/a/1190000047399985</guid>    <pubDate>2025-11-14 16:05:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文将会向您介绍如何利用 <strong>Eino ADK (Agent Development Kit)</strong> 构建一个强大的多智能体系统。</p><p>以 Excel Agent 这个实际业务场景为基础，Excel Agent 是一个能够“听懂你的话、看懂你的表格、写出并执行代码”的智能助手。它把复杂的 Excel 处理工作拆解为清晰的步骤，通过自动规划、工具调用与结果校验，稳定完成各项Excel数据处理任务。</p><p>接下来我们将从 Excel Agent 的完整架构与功能出发，向您展示该 Agent 是如何通过 Eino ADK 逐步搭建的，进而深入浅出的理解 Eino ADK 的核心设计特点，助您快速上手 Eino ADK，向构建自定义智能体与 AI 应用系统更进一步。</p><p>本示例完整代码位于 Github，您可以随时浏览与下载。</p><h4><strong>Excel Agent 是什么？</strong></h4><p>Excel Agent 是一个“看得懂 Excel 的智能助手”，它先把问题拆解成步骤，再一步步执行并校验结果。它能理解用户问题与上传的文件内容，提出可行的解决方案，并选择合适的工具（系统命令、生成并运行 Python 代码、网络查询等等）完成任务。</p><p>Excel Agent 整体是基于 Eino ADK 实现的 Multi-Agent 系统，完整架构如下图所示：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399987" alt="" title=""/></p><p>Excel Agent 内部包含的几个 Agent 功能分别为：</p><ul><li><strong>Planner</strong>：分析用户输入，拆解用户问题为可执行的计划</li><li><strong>Executor</strong>：正确执行当前计划中的首个步骤</li><li><strong>CodeAgent</strong>：接收来自 Executor 的指令，调用多种工具（例如读写文件，运行 python 代码等）完成任务</li><li><strong>WebSearchAgent</strong>：接收来自 Executor 的指令，进行网络搜索</li><li><strong>Replanner</strong>：根据 Executor 执行的结果和现有规划，决定继续执行、调整规划或完成执行</li><li><strong>ReportAgent</strong>：根据运行过程与结果，生成总结性质的报告</li></ul><h4><strong>Excel Agent 的典型使用场景</strong></h4><p>在真实业务里，你可以把 Excel Agent 当成一位“Excel 专家 + 自动化工程师”。当你交付一个原始表格和目标描述，它会给出方案并完成执行：</p><ul><li><strong>数据清理与格式化</strong>：从一个包含大量数据的 Excel 文件中完成去重、空值处理、日期格式标准化操作。</li><li><strong>数据分析与报告生成</strong>：从销售数据中提取每月的销售总额，聚合统计、透视，最终生成并导出图表报告。</li><li><strong>自动化预算计算</strong>：根据不同部门的预算申请，自动计算总预算并生成部门预算分配表。</li><li><strong>数据匹配与合并</strong>：将多个不同来源的客户信息表进行匹配合并，生成完整的客户信息数据库。</li></ul><p>Excel Agent 的完整运行动线为：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399988" alt="" title="" loading="lazy"/></p><p><strong>核心收益</strong>：</p><ul><li><strong>更少的人工操作</strong>，把复杂繁琐的 Excel 处理工作交给 Agent 自动完成。</li><li><strong>更稳定的产出质量</strong>，通过“规划—执行—反思”闭环减少漏项与错误。</li><li><strong>更强的可扩展性</strong>，各 Agent 独立构建，低耦合利于迭代更新。</li></ul><p>Excel Agent 既可以单独使用，也可以作为子 Agent，集成在一个复合的多专家系统中，由外部路由到此 Agent 上，解决 excel 领域相关的问题。</p><p>下面我们将逐步拆解 Excel Agent，深入了解 Eino ADK 的核心设计特点，以及如何利用这些特点构建高效、灵活的 AI 应用系统。</p><h4><strong>ChatModelAgent：与 LLM 交互的基石</strong></h4><p><code>ChatModelAgent</code>是 Eino ADK 中的一个核心预构建的 Agent，内部使用了 <a href="https://link.segmentfault.com/?enc=yX3SwH33JjaUaTaDMGV9OA%3D%3D.LtwyLTLe0RcImHZOhtVEh69rr1%2BVuT0QO%2FGrwePCqfc%3D" rel="nofollow" target="_blank">ReAct</a> 模式（一种让模型‘思考-行动-观察’的链式推理模式）：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399989" alt="" title="" loading="lazy"/></p><p><code>ChatModelAgent</code>旨在让 ChatModel 进行显式的、一步一步的“思考”，结合思考过程驱动行动，观测历史思考过程与行动结果继续进行下一步的思考与行动，最终解决复杂问题：</p><ul><li>调用 ChatModel（Reason）</li><li>LLM 返回工具调用请求（Action）</li><li>ChatModelAgent 执行工具（Act）</li><li>将工具结果返回给 LLM（Observation），结合之前的上下文继续生成，直到模型判断不需要调用工具后结束</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399990" alt="" title="" loading="lazy"/></p><p>在 Excel Agent 中，每个 Agent 的核心都是这样一个 <code>ChatModelAgent</code>，以 Executor 运行【读取用户输入表格的头信息】这个步骤为例 ，我们可以通过观察完整的运行过程来理解 ReAct 模式在 <code>ChatModelAgent</code>中的表现：</p><ol><li>Executor：经过判断，将任务转交给 CodeAgent 运行</li><li>CodeAgent：接收到任务【读取用户输入表格的头信息】</li></ol><ul><li><strong>Think-1</strong>：上下文未提供工作目录下的所有文件，需要查看</li><li><strong>Act-1</strong>: 调用 Bash 工具，ls 查看工作目录下的所有文件</li><li><strong>Think-2</strong>: 找到了用户输入的文件，判断需要编写 Python 代码读取 xlsx 表格的首行</li><li><strong>Act-2</strong>: 调用 PythonRunner 工具，书写代码并运行，获取运行结果</li><li><strong>Think-3</strong>: 获取到了 xlsx 首行，判断任务完成</li></ul><ol><li>运行完成，将表格头信息返回给 Executor</li></ol><h4><strong>Plan-Execute Agent：基于「规划-执行-反思」的多智能体协作框架</strong></h4><p>Plan-Execute Agent 是 Eino ADK 中一种基于「规划-执行-反思」范式的多智能体协作框架，旨在解决复杂任务的分步拆解、执行与动态调整问题。它通过 <strong>Planner（规划器）</strong>、**Executor（执行器）**和 <strong>Replanner（重规划器）</strong> 三个核心智能体的协同工作，实现任务的结构化规划、工具调用执行、进度评估与动态 replanning，最终达成用户目标：</p><pre><code>// 完整代码: https://github.com/cloudwego/eino/blob/main/adk/prebuilt/planexecute/plan_execute.go

// NewPlanner creates a new planner agent based on the provided configuration.
func NewPlanner(_ context.Context, cfg *PlannerConfig) (adk.Agent, error)

// NewExecutor creates a new executor agent.
func NewExecutor(ctx context.Context, cfg *ExecutorConfig) (adk.Agent, error)

// NewReplanner creates a new replanner agent.
func NewReplanner(_ context.Context, cfg *ReplannerConfig) (adk.Agent, error)

// New creates a new plan-execute-replan agent with the given configuration.
func New(ctx context.Context, cfg *Config) (adk.Agent, error)

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399991" alt="" title="" loading="lazy"/></p><p>而 Excel Agent 的核心能力恰好为【解决用户在 excel 领域的问题】，与该智能体协作框架定位一致：</p><ul><li><strong>规划者（Planner）</strong>：明确目标，自动拆解可执行步骤</li><li><strong>执行者（Executor）</strong>：调用工具（Excel 读取、系统命令、Python 代码）完成规划中的每一个详细步骤</li><li><strong>反思者（Replanner）</strong>：根据执行进度决定继续、调整规划或结束</li></ul><p>Planner 和 Replanner 会将用户模糊的指令拆解为清晰的、可执行的步骤清单，即包含多个步骤（Step）的计划（Plan），Eino ADK 为此提供了灵活的 Plan 接口定义，支持用户自定义 Plan 结构与细节：</p><pre><code>type Plan interface {
    // FirstStep returns the first step to be executed in the plan.
    FirstStep() string
    // Marshaler serializes the Plan into JSON.
    // The resulting JSON can be used in prompt templates.
    json.Marshaler
    // Unmarshaler deserializes JSON content into the Plan.
    // This processes output from structured chat models or tool calls into the Plan structure.
    json.Unmarshaler
}

</code></pre><p>默认情况下，框架会使用内置的 Plan 结构作为兜底配置，例如下面就是 Excel Agent 产生的一个完整运行计划：</p><pre><code>### 任务计划
- [x] 1. Read the contents of '模拟出题.csv' from the working directory into a pandas DataFrame.
- [x] 2. Identify the question type (e.g., multiple-choice, short-answer) for each row in the DataFrame.
- [x] 3. For non-short-answer questions, restructure the data to place question, answer, explanation, and options in the same row.
- [x] 4. For short-answer questions, merge the answer content into the explanation column and ensure question and merged explanation are in the same row.
- [x] 5. Verify that all processed rows have question, answer (where applicable), explanation, and options (where applicable) in a single row with consistent formatting.
- [x] 6. Generate a cleaned report presenting the formatted questions with all relevant components (question, answer, explanation, options) in unified rows.

</code></pre><h4><strong>Workflow Agents：可控的多 Agent 运行流水线</strong></h4><p>Excel Agent 中，存在一些需要按照特定顺序运行 agent 的情况：</p><ol><li><strong>顺序运行</strong>：先运行 Planner，再运行 Executor 和 Replanner；Planner 只运行一次。</li><li><strong>循环运行</strong>：Executor 和 Replanner 需要按需循环运行多次，每次循环运行都是先运行 Executor 后运行 Replanner</li><li><strong>顺序运行</strong>：Plan-Executor 整体运行完后，固定运行一次 ReportAgent 进行总结。</li></ol><p>对于这些拥有固定执行流程的场景，Eino ADK 提供了三种流程编排方式，协助用户快速搭建可控的工作流：</p><ul><li><strong>SequentialAgent</strong>：按照配置中提供的顺序，依次执行一系列子 Agent。每个子 Agent 执行完成后，其输出会通过 History 机制传递给下一个子 Agent，形成一个线性的执行链。</li></ul><pre><code>import github.com/cloudwego/eino/adk

// 依次执行 制定研究计划 -&gt; 搜索资料 -&gt; 撰写报告
sequential := adk.NewSequentialAgent(ctx, &amp;adk.SequentialAgentConfig{
    Name: "research_pipeline",
    SubAgents: []adk.Agent{
        planAgent,    // 制定研究计划
        searchAgent,  // 搜索资料
        writeAgent,   // 撰写报告
    },
})

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399992" alt="" title="" loading="lazy"/></p><ul><li><strong>LoopAgent</strong>：重复执行配置的子 Agent 序列，直到达到最大迭代次数或某个子 Agent 产生 ExitAction，每次迭代的结果都会累积，后续迭代的输入可以访问所有历史信息。LoopAgent 基于 SequentialAgent 实现。</li></ul><pre><code>import github.com/cloudwego/eino/adk

// 循环执行 5 次，每次顺序为：分析当前状态 -&gt; 提出改进方案 -&gt; 验证改进效果
loop := adk.NewLoopAgent(ctx, &amp;adk.LoopAgentConfig{
    Name: "iterative_optimization",
    SubAgents: []adk.Agent{
        analyzeAgent,  // 分析当前状态
        improveAgent,  // 提出改进方案
        validateAgent, // 验证改进效果
    },
    MaxIterations: 5,
})

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399993" alt="" title="" loading="lazy"/></p><ul><li><strong>ParallelAgent</strong>：允许多个子 Agent 基于相同的输入上下文并发执行。所有子 Agent 接收相同的初始输入，各自在独立的 goroutine（Go 语言中一种轻量级的并发执行单元） 运行，最终收集所有子 Agent 的执行结果并按顺序输出到<code>AsyncIterator</code>中。</li></ul><pre><code>import github.com/cloudwego/eino/adk

// 并发执行 情感分析 + 关键词提取 + 内容摘要
parallel := adk.NewParallelAgent(ctx, &amp;adk.ParallelAgentConfig{
    Name: "multi_analysis",
    SubAgents: []adk.Agent{
        sentimentAgent,  // 情感分析
        keywordAgent,    // 关键词提取
        summaryAgent,    // 内容摘要
    },
})

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399994" alt="" title="" loading="lazy"/></p><h4><strong>Agent 抽象：灵活定义 Agent 的基础</strong></h4><p>Eino ADK 的核心是一个简洁而强大的 Agent 接口，每个 Agent 都有明确的身份（Name）、清晰的职责（Description）和标准化的执行方式（Run），为 Agent 之间的发现与调用提供了基础。无论是简单的问答机器人，还是复杂的多步骤任务处理系统，都可以通过这个统一的接口加以实现。</p><ul><li><strong>统一的 Agent 抽象</strong>：ADK 提供的预构建 Agent（ChatModelAgent，Plan-Execute Agent，Workflow Agents）都遵循该接口定义。您也可以基于该接口，书写自定义 Agent，完成定制化需求。</li></ul><pre><code>type Agent interface {
    Name(ctx context.Context) string
    Description(ctx context.Context) string
    Run(ctx context.Context, input *AgentInput, options ...AgentRunOption) *AsyncIterator[*AgentEvent]
}

</code></pre><ul><li><strong>标准化输入</strong>：Agent 通常以 LLM 为核心，因此 Eino ADK 定义的 Agent 的输入与 LLM 接收的输入一致：</li></ul><pre><code>type AgentInput struct {
    Messages        []Message
    EnableStreaming bool
}

type Message = *schema.Message // *schema.Message 是模型输入输出的结构定义

</code></pre><ul><li><strong>异步事件驱动输出</strong>：Agent 的输出是一个 AgentEvent 的异步迭代器，其中的 AgentEvent 表示 Agent 在其运行过程中产生的核心事件数据。其中包含了 Agent 的元信息、输出、行为和报错信息：</li></ul><pre><code>type AgentEvent struct {
    AgentName string    // 产生 Event 的 Agent 名称（框架自动填充）

    RunPath []RunStep   // 到达当前 Agent 的完整运行轨迹（框架自动填充）

    Output *AgentOutput // Agent 输出消息内容

    Action *AgentAction // Agent 动作事件内容

    Err error           // Agent 报错
}

type AgentOutput struct {
    MessageOutput *MessageVariant // 模型消息输出内容

    CustomizedOutput any          // 自定义输出内容
}

type MessageVariant struct {
    IsStreaming bool            // 是否为流式输出
    
    Message       Message        // 非流式消息输出
    MessageStream MessageStream  // 流式消息输出

    Role schema.RoleType         // 消息角色
    ToolName string              // 工具名称
}

type AgentAction struct {
    Exit bool                               // Agent 退出

    Interrupted *InterruptInfo              // Agent 中断

    TransferToAgent *TransferToAgentAction  // Agent 跳转

    CustomizedAction any                    // 自定义 Agent 动作
}

</code></pre><p>异步迭代器允许 Agent 在运行过程中的任意时刻向迭代器发送消息（Agent 调用模型结果、工具运行结果、中间状态等等），同时调用方以一种有序、阻塞的方式消费这一系列事件：</p><pre><code>iter := myAgent.Run(ctx, "hello") // get AsyncIterator

for {
    event, ok := iter.Next()
    if !ok {
        break
    }
    // handle event
}

</code></pre><h3><strong>Agent 协作：隐藏在 Agent 后的数据传递</strong></h3><p>Excel Agent 架构图中的节点代表每个具体的 Agent，边代表了数据流通与任务转移。在构建多 Agent 系统时，让不同 Agent 之间高效、准确地共享信息至关重要。</p><p>这些信息不仅包含 Agent 的输入输出，还有全局的、部分可见的种种额外信息，例如：</p><ul><li>Executor 执行需要从 Planner / Replanner 拿到一个结构化的、可被拆分为详细步骤（Step）的计划（Plan），而非一段非结构化的 LLM 原始输出消息。</li><li>ReportAgent 需要拿到完整的运行计划、运行过程与运行产物才能正确产生报告。</li></ul><p>Eino ADK 包含两种基础的数据传递机制：</p><ul><li><strong>History</strong>：每一个 Agent 产生的 AgentEvent 都会被保存到这个隐藏的 History 中，调用一个新 Agent 时 History 中的 AgentEvent 会被转换并拼接到 AgentInput 中。默认情况下，其他 Agent 的 Assistant 或 Tool Message，被转换为 User Message，这相当于在告诉当前的 LLM：“刚才， Agent\_A 调用了 some\_tool ，返回了 some_result 。现在，轮到你来决策了。”。 通过这种方式，其他 Agent 的行为被当作了提供给当前 Agent 的“外部信息”或“事实陈述”，而不是它自己的行为，从而避免了 LLM 的上下文混乱。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399995" alt="" title="" loading="lazy"/></p><ul><li><strong>共享 Session</strong>：单次运行过程中持续存在的 KV 存储，用于支持跨 Agent 的状态管理和数据共享，一次运行中的任何 Agent 可以在任何时间读写 SessionValues。以 Plan-Execute Agent 模式为例，Planner 生成首个计划并写入 Session；Executor 从 Session 读取计划并执行；Replanner 从 Session 读取当前计划后，结合运行结果，将更新后的计划写回 Session 覆盖当前的计划。</li></ul><pre><code>// Agent 内获取全部 SessionValues
func GetSessionValues(ctx context.Context) map[string]any

// Agent 内指定 key 获取 SessionValues 中的值
func GetSessionValue(ctx context.Context, key string) (any, bool)

// Agent 内添加 SessionValues
func AddSessionValue(ctx context.Context, key string, value any)

// Agent 内批量添加 SessionValues
func AddSessionValues(ctx context.Context, kvs map[string]any)

// WithSessionValues 在 Agent 运行前由外部注入 SessionValues
func WithSessionValues(v map[string]any) AgentRunOption
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399996" alt="" title="" loading="lazy"/></p><p>除了完善的 Agent 间数据传递机制，Eino ADK 从实践出发，提供了多种 Agent 协作模式：</p><ul><li><strong>预设 Agent 运行顺序（Workflow）</strong>：以代码中预设好的流程运行， Agent 的执行顺序是事先确定、可预测的。对应 Workflow Agents 章节提到的三种范式。</li><li><strong>移交运行（Transfer）</strong>：携带本 Agent 输出结果上下文，将任务移交至子 Agent 继续处理。适用于智能体功能可以清晰的划分边界与层级的场景，常结合 ChatModelAgent 使用，通过 LLM 的生成结果进行动态路由。结构上，以此方式进行协作的两个 Agent 称为父子 Agent：</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399997" alt="" title="" loading="lazy"/></p><pre><code>// 设置父子 Agent 关系
func SetSubAgents(ctx context.Context, agent Agent, subAgents []Agent) (Agent, error)

// 指定目标 Agent 名称，构造 Transfer Event
func NewTransferToAgentAction(destAgentName string) *AgentAction

</code></pre><ul><li><strong>显式调用（ToolCall）</strong>：将 Agent 视为工具进行调用，适用于 Agent 运行仅需要明确清晰的参数而非完整运行上下文的场景。常结合 ChatModelAgent，将 Agent 作为工具运行后将结果返回给 ChatModel 继续处理。除此之外，ToolCall 同样支持调用符合工具接口构造的、不含 Agent 的普通工具。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399998" alt="" title="" loading="lazy"/></p><pre><code>// 将 Agent 转换为 Tool
func NewAgentTool(_ context.Context, agent Agent, options ...AgentToolOption) tool.BaseTool

</code></pre><h3><strong>Excel Agent 示例运行</strong></h3><h4><strong>配置环境与输入输出路径</strong></h4><ul><li>环境变量：Excel Agent 运行依赖的完整环境变量可参考项目 README。</li><li><p>运行输入：包括一段用户需求描述和待处理的一系列文件，其中：</p><ul><li><code>main.go</code>中首行表示用户输入的需求描述，可自行修改：</li></ul></li></ul><pre><code>func main() {
    // query := schema.UserMessage("统计附件文件中推荐的小说名称及推荐次数，并将结果写到文件中。凡是带有《》内容都是小说名称，形成表格，表头为小说名称和推荐次数，同名小说只列一行，推荐次数相加")
    // query := schema.UserMessage("读取模拟出题.csv 中的内容，规范格式将题目、答案、解析、选项放在同一行，简答题只把答案写入解析即可")
    query := schema.UserMessage("请帮我将 question.csv 表格中的第一列提取到一个新的 csv 中")
}

</code></pre><ul><li><code>adk/multiagent/integration-excel-agent/playground/input</code>为默认的附件输入路径，附件输入路径支持配置，参考 README。</li><li><code>adk/multiagent/integration-excel-agent/playground/test_data</code> 路径下提供了几个示例文件，您可以将文件复制到附件输入路径下来进行测试运行：</li></ul><pre><code>% tree adk/multiagent/integration-excel-agent/playground/test_data
adk/multiagent/integration-excel-agent/playground/test_data
├── questions.csv
├── 推荐小说.txt
└── 模拟出题.csv

1 directory, 3 files</code></pre><ul><li>运行输出：Excel Agent 输入的附件、运行的中间产物与最终结果都会放置在工作路径下：<code>adk/multiagent/integration-excel-agent/playground/${uuid}</code>，输出路径支持配置，参考 README。</li></ul><h4><strong>查看运行结果</strong></h4><p>Excel Agent 单次运行会在输出路径下创建一个新的工作目录，并在该目录下完成任务，运行时产生的中间产物与最终结果都会写到该目录下。</p><p>以<code>请帮我将 question.csv 表格中的第一列提取到一个新的 csv</code> 中这个任务为例，运行完成后在工作目录下包含的内容有：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399999" alt="" title="" loading="lazy"/></p><ol><li>原始输入：从输入路径获取到的 <code>question.csv</code></li><li>Planner / Replanner 给出的运行计划：<code>plan.md</code></li></ol><pre><code>### 任务计划
- [x] 1. {"desc":"Read the 'questions.csv' file into a pandas DataFrame."}
- [x] 2. Save the extracted first column to a new CSV file.

</code></pre><ol start="3"><li>Executor 中的 CodeAgent 书写的代码：<code>$uuid.py</code></li></ol><pre><code>import pandas as pd

df = pd.read_csv('questions.csv')
first_column = df.iloc[:, 0]
first_column.to_csv('extracted_first_column.csv', index=False)

</code></pre><ol start="4"><li>运行中间产物：<code>extracted_first_column.csv</code>和 <code>first_column.csv</code></li></ol><pre><code>type
multiple-choice
...
short-answer

</code></pre><ol start="5"><li>最终报告：<code>final_report.json</code></li></ol><pre><code>{
  "is_success": true,
  "result": "Successfully extracted the first column from questions.csv and saved it to first_column.csv.",
  "files": [
    {
      "path": "/User/user/go/src/github.com/cloudwego/eino-examples/adk/multiagent/integration-excel-agent/playground/00f118af-4bd8-42f7-8d11-71f2801218bd/first_column.csv",
      "desc": "A CSV file containing only the first column data from the original questions.csv."
    }
  ]
}

</code></pre><h4>运行过程输出</h4><p>Excel Agent 会将每个步骤的运行结果输出到日志中。下面仍以<code>请帮我将 question.csv 表格中的第一列提取到一个新的 csv 中</code>这个任务为例，向您展示 Excel Agent 在运行过程中的几个关键步骤及其输出，并通过对步骤的解释，直观地呈现 Agent 的运行流程及其强大能力。：</p><ul><li>Planner 生成 JSON 格式的初始计划</li></ul><pre><code>name: Planner
answer: {
    "steps": [
        {
            "index": 1,
            "desc": "Read the 'questions.csv' file into a pandas DataFrame."
        },
        {
            "index": 2,
            "desc": "Extract the first column from the DataFrame."
        },
        {
            "index": 3,
            "desc": "Save the extracted first column to a new CSV file."
        }
    ]
}

</code></pre><ul><li>Executor 将 CodeAgent 作为工具进行调用，执行计划中的首个步骤</li></ul><pre><code>name: Executor
tool name: CodeAgent
arguments: {"request":"Read the 'questions.csv' file into a pandas DataFrame using pandas. Use the pandas.read_csv function and store the result in a variable named df."}

</code></pre><ul><li>CodeAgent 使用 PythonRunner 工具运行代码，并使用 ReAct 模式自动纠错，修正代码中的错误</li></ul><pre><code># CodeAgent 使用 PythonRunner 工具运行代码
name: Executor
tool name: PythonRunner
arguments: {"code":"```python\nfirst_column = df.iloc[:, 0]\n```"}

# PythonRunner 代码运行报错
name: Executor
tool response: Traceback (most recent call last):
  File "/User/user/go/src/github.com/cloudwego/eino-examples/adk/multiagent/integration-excel-agent/playground/00f118af-4bd8-42f7-8d11-71f2801218bd/00f118af-4bd8-42f7-8d11-71f2801218bd.py", line 1, in &lt;module&gt;
    first_column = df.iloc[:, 0]
                   ^^
NameError: name 'df' is not defined

# ReAct 模式自动纠错，修正无法运行的代码
name: Executor
answer: The error occurs because the DataFrame `df` is not defined. We need to first load the data from the existing CSV file `questions.csv` into `df`. Here's the corrected code:
tool name: PythonRunner
arguments: {"code":"```python\nimport pandas as pd\ndf = pd.read_csv('questions.csv')\nfirst_column = df.iloc[:, 0]\nprint(first_column.head())  # Verify the result\n```"}

# 代码运行成功，返回运行结果
name: Executor
path: [{SequentialAgent} {plan_execute_replan} {Planner} {execute_replan} {Executor}]
tool response: 
0    multiple-choice
1    multiple-choice
2    multiple-choice
3    multiple-choice
4    multiple-choice
Name: type, dtype: object

</code></pre><ul><li>Replanner 判断计划完成，提交运行结果至 ReportAgent</li></ul><pre><code>name: Replanner
answer: {
    "is_success": true,
    "result": "已成功将'questions.csv'表格中的第一列提取到新的CSV文件'extracted_first_column.csv'中。",
    "files": [
        {
            "desc": "包含原表格第一列数据的新CSV文件",
            "path": "extracted_first_column.csv"
        }
    ]
}

</code></pre><ul><li>ReportAgent 进行总结，结束执行</li></ul><pre><code>name: Report
tool name: SubmitResult
arguments: {
    "is_success": true,
    "result": "Successfully extracted the first column from questions.csv and saved it to first_column.csv.",
    "files": [
        {
            "path": "/User/user/go/src/github.com/cloudwego/eino-examples/adk/multiagent/integration-excel-agent/playground/00f118af-4bd8-42f7-8d11-71f2801218bd/first_column.csv",
            "desc": "A CSV file containing only the first column data from the original questions.csv."
        }
    ]
}

</code></pre><h3><strong>总结</strong></h3><p>Excel Agent 所呈现的并非“单一智能体”的技巧，而是一套以 Eino ADK 为底座的 Multi-Agent 系统工程化方法论：</p><ul><li>以 ChatModelAgent 的 ReAct 能力为基石，让模型“可思考、会调用”。</li><li>以 WorkflowAgents 的编排能力，让 Multi-Agent 系统中的每个 Agent 以用户预期的顺序运行。</li><li>以 Planner–Executor–Replanner 的闭环，让复杂任务“可拆解、能纠错”。</li><li>以 History / Session 的数据传递机制，让多 Agent “能协作、可回放”。</li></ul><blockquote><p>💡 <strong>立即开始你的智能体开发之旅</strong></p><ul><li>⌨️ 查看 Excel Agent 源码：<a href="https://link.segmentfault.com/?enc=%2BkWCR2vNbBboGs%2B%2FS4C0LQ%3D%3D.xs4TTc0ZOM2qgHDn1dO6PFlg%2FVU%2BgXNvYgjKMhD1%2F6TZi16GFC3akfWYN8eYAeD2zlkhYzriaf3EV1D3mSjZKA%3D%3D" rel="nofollow" target="_blank">to do</a></li><li>📚 查看更多文档：<a href="https://link.segmentfault.com/?enc=X7z%2BZQWJ1qQE98IsyTo7Kw%3D%3D.McWfV4RC2Lly8afqwbY7VmmR%2FAiRM%2FefZfJCNLfb4k6PtOLmrLcnfIA4ZwrA78U9xeaflCHnYnEthzVP9w2Hvw%3D%3D" rel="nofollow" target="_blank">Eino ADK 文档</a></li><li>🛠️ 浏览 ADK 源码：<a href="https://link.segmentfault.com/?enc=U0J94tlB%2F1PLi9YTJPy6Zw%3D%3D.IdpmaPFviD0mo8BLspD9u6xqgSAIeGh18kEzjTy9DvswjZpDjEokjEi5%2BA9gWkRvpBOrR9E91NyNc7Y3OzGUhg%3D%3D" rel="nofollow" target="_blank">Eino ADK 源码</a></li><li>💡 探索 ADK 全部示例：<a href="https://link.segmentfault.com/?enc=CIz%2BEUBEjRoXw0nGoHcgpQ%3D%3D.xq5A6mJz8pjcgF1P%2FIKXED4KHsdHZPkQ%2Bo41kH%2BBd8TUuFA46Crsbs3hCd5O4gvG62zWzGBnA1h36KY7betA5A%3D%3D" rel="nofollow" target="_blank">Eino ADK Examples</a></li><li>🤝 加入开发者社区：与其他开发者交流经验和最佳实践</li></ul><p><strong>Eino ADK，让智能体开发变得简单而强大！</strong></p></blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400000" alt="" title="" loading="lazy"/></p><p><strong>参考资料</strong></p><p>[1] ReAct: _<a href="https://link.segmentfault.com/?enc=8TNh0Zg2YHn3gIYMULzDww%3D%3D.1wjotR6Oq5Mc2U2XW7LRGYgu4oR%2FUcry3NGJj4ZngJE%3D" rel="nofollow" target="_blank">https://react-lm.github.io/</a>_</p><p>[2] Eino 示例代码: _<a href="https://link.segmentfault.com/?enc=590RKEtUG5zGjRQyVaf%2B3A%3D%3D.JtPyb4qOGDEZp5UNWy2FIOotG%2BGz5L%2F2bfoSrafaRDGmFqZoNyzRNRprk%2FVqnoDYq7IlpeHwM%2BxRRAa5F1oDncdZ6RKCI4lxnSuS3%2BHiYYPjTli7sxS3L5PwxOk%2Bj%2FPU" rel="nofollow" target="_blank">https://github.com/cloudwego/eino-examples/tree/main/adk/multiagent/integration-excel-agent</a>_</p><p>[3] Eino ADK 文档: _<a href="https://link.segmentfault.com/?enc=gVQ6Kw1Xhu%2BE%2FT%2FKVcwaQA%3D%3D.XQAl8RTuqESgD26O3sOqm2Bdj3tU2KXlvTC0uxRwsOmCF9eOqqoUsMCAHMKSxVy%2Bg4SgT5vA2Z2fwYulC%2FZGtA%3D%3D" rel="nofollow" target="_blank">https://www.cloudwego.io/zh/docs/eino/core\_modules/eino\_adk/</a>_</p><p>[4] Eino ADK 源码: _<a href="https://link.segmentfault.com/?enc=UpZyZR0CdGkYjl0OoLZDXQ%3D%3D.6n2Xj4gVjawIAbHnRElTXJ63dSlMyyb8HrKN4vtsXLsgabpOr7XitCDdJCmilzBS" rel="nofollow" target="_blank">https://github.com/cloudwego/eino/tree/main/adk</a>_</p><p>[5] Eino ADK Examples: _<a href="https://link.segmentfault.com/?enc=Xj8RVzrRqRHzdFWmJyovXg%3D%3D.na98EyqlrqKEoyviWDb37rOzg%2Bvcp6Vo8gZLii9cNQDm2XbjrqOc8rIfUS%2BnqdwoBndgGdXo2IaQWQ99MGfqEA%3D%3D" rel="nofollow" target="_blank">https://github.com/cloudwego/eino-examples/tree/main/adk</a>_</p>]]></description></item><item>    <title><![CDATA[【案例分享】灯塔低代码平台助力医院构建智]]></title>    <link>https://segmentfault.com/a/1190000047400020</link>    <guid>https://segmentfault.com/a/1190000047400020</guid>    <pubDate>2025-11-14 16:04:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>构建一个以患者为中心、数据驱动、业务协同的智慧服务新生态，已成为现代医院提升服务质量、优化资源配置、创新服务模式的必然选择。而这样的转型，离不开强有力的技术支撑作为基石。北京中烟创新科技有限公司（简称：中烟创新）的灯塔低代码平台，凭借其独特的业务敏捷性、技术包容性和生态连接能力，正完美契合了这一需求，成为推动医院智慧服务体系建设的重要力量。</p><p>平台通过可视化开发、组件化封装和模型驱动架构，为医院提供了快速实现数字化创新的技术基础，让业务专家能够深度参与应用构建，使智慧服务从理念加速走向实践。其核心价值在于将复杂的技术实现过程简化为业务人员可理解的视觉元素，同时保持企业级应用所需的稳定性、安全性和集成能力。</p><p>这种特性使其成为构建医院智慧服务生态的理想技术载体。在医疗环境快速发展的今天，医院需要面对持续变化的服务需求和政策要求。传统开发模式往往需要数月的开发周期，难以满足业务的快速迭代需求。灯塔低代码平台通过可视化的开发环境和丰富的预置组件，使得应用开发周期从"月"级缩短到"周"甚至"天"级，让医院能够快速响应内外部变化，持续优化服务体验。平台有效降低了数字化创新的技术门槛，让熟悉医疗业务的医护人员、管理人员能够直接参与应用设计。</p><p>这种业务与技术的深度融合，确保了数字化解决方案更贴近实际工作场景，解决了传统开发中业务需求与技术实现之间的理解偏差问题，真正实现了"业务驱动"的数字化转型。灯塔低代码平台具备强大的系统集成能力和数据整合能力，能够作为"数字连接器"，打通医院内部各业务系统，连接医疗设备、物联网终端等物理设施，实现数据互通和业务协同，为构建统一、联动的服务生态提供技术保障。</p><p>场景一：全院医疗质量与安全一体化管理医院检查医疗质量主要靠人工抽查、纸质记录和事后查看，效率不高，检查范围也有限。很难做到实时监控和提前预警，对于保障患者安全，有时会因为信息延迟而反应不及。使用灯塔低代码平台，可建立一个覆盖“患者入院前、治疗中、出院后”所有环节的立体化质量管控体系。流程全部搬到线上：把病历书写、合理用药、手术安全、感染预防、危急值处理等上百条质量检查标准，都变成清晰的线上流程。质量管理员、科室主任和医务处工作人员通过一个统一的网站入口处理所有事务。用数据智能预警风险：平台与医院的核心系统（如挂号收费系统、电子病历系统、检验系统、影像系统）连接，自动收集关键数据。通过平台内置的规则和智能模型，能实时发现异常情况，并自动把处理任务推送给相关负责人。形成发现问题到改进的完整闭环：从发现问题、评估、整改到验证效果，形成一个完整的线上管理循环。所有操作都有记录，数据自动分析，能生成各种维度的质量报告，为医院评级、精细化管理和高水平学科建设提供科学依据。</p><p>核心价值：将质量管理从 “出了问题再惩罚” 转变为 “提前预防、过程中控制” ，从琐碎的事务管理升级为有策略的战略管理。它不仅大大提升了医疗安全水平，更培养了一种全员参与、用数据说话、持续改进的质量文化，这是医院智慧服务生态稳固运行的基石。场景二：医疗设备精益化共享管理医院里昂贵的医疗设备和科研仪器往往归各个科室自己管，使用率很不均衡，有的设备经常闲着，有的却不够用。管理靠手工记账，维护保养也不及时，导致设备整体的使用效益不高。利用灯塔低代码平台打造一个面向全院的“医疗设备共享平台”，像“共享单车”一样管理设备，实现资产在线化、资源共享化、管理精细化。一站式预约与智能调度：所有设备的信息都公开透明。临床科室可以随时通过电脑或手机查看并在线预约。</p><p>平台内置智能调度程序，能根据急诊的紧急程度、科研项目的重要性等规则，自动分配设备，最大化利用效率。自动结算与效益一目了然：系统自动记录设备使用时长或检测样本数量，并与医院收费系统打通，实现精准、无人为干预的计费和结算。清晰展示使用率、收入、成本等数据，为医院决定采购新设备还是淘汰旧设备提供客观依据。全生命周期健康管理：给设备装上传感器，实时监控它们的运行状态。平台会自动生成预防性保养计划，并在设备异常时自动报修，推送给工程师，形成完整的设备电子健康档案。核心价值：将设备从 “科室的成本负担” 变成了 “全院共享的利润来源” 。它盘活了闲置的资产，提高了资源利用效率，直接降低了医院运营成本。更重要的是，它建立了一套靠数据说话的资源调配机制，支撑起医院的精细化成本核算。</p><p>场景三：以患者为中心的智慧病房患者住院体验很零碎，想知道的信息不透明；护士忙于大量非护理性的琐事，没太多时间和患者沟通；病房的环境管理也比较粗放。围绕患者住院的全过程，打造一个“患者-护士-环境”智能联动的智慧病房系统。数字化床头屏与智能呼叫：患者通过床头的智能屏幕，可以清楚地查看每天的诊疗安排、用药明细、费用清单，还能在线点餐、查询费用、观看健康知识视频。呼叫护士时，系统能区分普通呼叫、输液完毕、紧急求助等不同情况，并直接通知到护士的手持终端上，实现精准响应。护士移动工作站：护士通过移动平板电脑就能实时接收和执行医生指令、扫描核对患者和药品信息、在床边记录生命体征。</p><p>系统会根据患者的病情，自动推送个性化的健康指导内容，帮助护士提供更高效、规范的护理服务。智慧环境与节能管理：病房的灯光、空调、窗帘等与环境传感器联动，能根据患者休息、治疗等不同模式自动调节，营造最舒适的休养环境。同时，系统能对病房的水电消耗进行精确计量和管理。核心价值：极大地提升了患者满意度和护士的职业幸福感，它让信息多跑路，患者少操心；让护士能有更多时间回归到照顾患者的本职工作。一个安全、舒适、智能的住院环境，本身就是最优质的医疗服务，是智慧服务生态最直接的体现。</p><p>场景四：多学科专家协同诊疗平台组织多学科专家会诊非常困难，专家时间难协调，患者资料分散在各处，讨论过程不规范，得出的结论落实和后续跟踪很麻烦，宝贵的诊疗经验也难以积累下来。用灯塔低代码平台构建一个支持复杂疾病诊疗的“线上专家会诊中心”，打破科室和地域的限制。统一的数字病历空间：为每一位需要会诊的患者创建一个专属的线上空间，自动从医院各个系统里收集并整理好所有相关的病历资料，方便专家在会诊前查阅。规范化的协作流程：把会诊申请、邀请专家、安排会议、线上线下混合讨论、发表意见和形成结论的全过程都标准化、线上化。平台支持视频会议、屏幕共享、电子白板等协作工具。知识积累与智能随访：会诊结论被整理成标准格式，形成可以检索、分析的医院知识宝库。系统会根据最终的治疗方案，自动生成随访计划，并对患者的长期治疗效果进行跟踪，形成诊疗效果的反馈闭环。</p><p>核心价值：让多学科会诊从 “门槛很高的专家会议” 变成了 “标准化的诊疗流程” 。它确保了疑难杂症诊疗的规范性和科学性，促进了不同学科专家之间的知识交流和碰撞。同时，它积累了宝贵的临床科研数据，直接推动了医院临床研究水平的提升。场景五：后勤保障“一站式”智能管控医院后勤保障涉及能源、安全、保洁、运输、设备维修等很多方面，这些系统通常各自为政，形成了多个“信息孤岛”，无法统一指挥调度，响应慢，管理成本高。使用灯塔低代码平台打造医院后勤的“智慧大脑”，构建一个一体化的指挥管控体系。全局情况一屏掌握：通过一个可视化大屏幕，把全院的后勤能耗、安防监控、消防报警、电梯运行、医用气体压力、环境温湿度、报修动态等成千上万个数据点融合在一起展示，实现“一个屏幕看管全院”。</p><p>智能预警与跨系统联动：设置复杂的预警规则。比如，当智能水表监测到某区域用水量异常猛增，系统会自动报警并生成巡查任务，同时调取附近的监控摄像头查看现场；消防系统报警时，能自动联动门禁打开逃生通道，并把疏散路线推送到附近人员的手机上。闭环运维与服务评价：全院报修都在线上进行，平台智能派单，维修人员手机接单，维修完成后由申请人在线评价，形成一个完整的服务闭环和考核体系。核心价值：实现后勤保障从 “被动等待报修” 到 “主动预警、智能联动” 的根本性转变。它大幅提升了医院的安全等级和突发事件响应速度，并通过节能管理和流程优化，显著降低了日常运营成本，为临床一线提供了坚强、可靠的后方保障。</p><p>灯塔低代码平台通过赋能业务、连接数据、重塑流程，成功将“以患者为中心”的理念转化为可落地的数字化实践。帮助医院构建一个更具韧性、更可持续的数字化服务体系，最终为患者提供更优质、更安全的医疗服务体验，为"健康中国"建设贡献重要力量！</p>]]></description></item><item>    <title><![CDATA[StockTV 币安交易所数据 Java]]></title>    <link>https://segmentfault.com/a/1190000047400040</link>    <guid>https://segmentfault.com/a/1190000047400040</guid>    <pubDate>2025-11-14 16:03:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文档详细介绍如何使用 Java 语言通过 StockTV API 对接币安交易所数据，包含实时行情、K线数据、交易对信息等完整功能。</p><h2>🚀 快速开始</h2><h3>环境要求</h3><ul><li>JDK 8+</li><li>Maven 3.6+</li><li>网络连接（可访问 <code>api.stocktv.top</code>）</li></ul><h3>项目依赖</h3><pre><code class="xml">&lt;!-- pom.xml --&gt;
&lt;dependencies&gt;
    &lt;!-- HTTP客户端 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
        &lt;version&gt;4.5.14&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- JSON处理 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;version&gt;2.15.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- WebSocket客户端 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.java-websocket&lt;/groupId&gt;
        &lt;artifactId&gt;Java-WebSocket&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- 日志框架 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- Lombok --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.28&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h2>🏗️ 核心架构</h2><h3>项目结构</h3><pre><code>src/main/java/com/stocktv/binance/
├── config/
│   └── BinanceConfig.java
├── model/
│   ├── CryptoPair.java
│   ├── TickerPrice.java
│   ├── KLine.java
│   ├── Trade.java
│   └── ApiResponse.java
├── client/
│   ├── BinanceHttpClient.java
│   └── BinanceWebSocketClient.java
├── service/
│   └── BinanceDataService.java
└── demo/
    └── BinanceDemo.java</code></pre><h2>📦 核心代码实现</h2><h3>1. 配置类</h3><pre><code class="java">package com.stocktv.binance.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

/**
 * 币安数据配置类
 */
public class BinanceConfig {
    
    // API 基础配置
    public static final String BASE_URL = "https://api.stocktv.top";
    public static final String WS_URL = "wss://ws-api.stocktv.top/connect";
    
    // 币安接口路径
    public static final String CRYPTO_PAIR_LIST = "/crypto/pairlist";
    public static final String CRYPTO_TICKER_PRICE = "/crypto/tickerPrice";
    public static final String CRYPTO_LAST_PRICE = "/crypto/lastPrice";
    public static final String CRYPTO_GET_KLINES = "/crypto/getKlines";
    public static final String CRYPTO_GET_TRADES = "/crypto/getTrades";
    
    // 币安市场ID
    public static final int BINANCE_MARKET_ID = 338;
    
    // 主要交易对
    public static final String BTC_USDT = "BTCUSDT";
    public static final String ETH_USDT = "ETHUSDT";
    public static final String BNB_USDT = "BNBUSDT";
    public static final String ADA_USDT = "ADAUSDT";
    public static final String DOT_USDT = "DOTUSDT";
    public static final String XRP_USDT = "XRPUSDT";
    public static final String LTC_USDT = "LTCUSDT";
    public static final String LINK_USDT = "LINKUSDT";
    public static final String BCH_USDT = "BCHUSDT";
    public static final String XLM_USDT = "XLMUSDT";
    
    // API Key
    private final String apiKey;
    
    // HTTP 客户端和JSON处理器
    private final CloseableHttpClient httpClient;
    private final ObjectMapper objectMapper;
    
    public BinanceConfig(String apiKey) {
        this.apiKey = apiKey;
        this.httpClient = HttpClients.createDefault();
        this.objectMapper = new ObjectMapper();
        this.objectMapper.findAndRegisterModules();
    }
    
    // Getter方法
    public String getApiKey() { return apiKey; }
    public CloseableHttpClient getHttpClient() { return httpClient; }
    public ObjectMapper getObjectMapper() { return objectMapper; }
}</code></pre><h3>2. 数据模型类</h3><h4>加密货币交易对数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 加密货币交易对数据模型
 */
@Data
public class CryptoPair {
    @JsonProperty("symbol")
    private String symbol;
    
    @JsonProperty("legal_currency_price")
    private BigDecimal legalCurrencyPrice;
    
    @JsonProperty("market_cap_display")
    private String marketCapDisplay;
    
    @JsonProperty("percent_change_utc0_3d")
    private BigDecimal percentChangeUtc03d;
    
    @JsonProperty("price")
    private String price;
    
    @JsonProperty("price_change_today")
    private String priceChangeToday;
    
    @JsonProperty("rank")
    private Integer rank;
    
    @JsonProperty("logo")
    private String logo;
    
    @JsonProperty("id")
    private Long id;
    
    @JsonProperty("price_display")
    private String priceDisplay;
    
    @JsonProperty("price_display_cny")
    private BigDecimal priceDisplayCny;
    
    @JsonProperty("market_id")
    private Integer marketId;
    
    @JsonProperty("market_name")
    private String marketName;
    
    @JsonProperty("market_cap_usd")
    private String marketCapUsd;
    
    @JsonProperty("exchange_time")
    private String exchangeTime;
    
    @JsonProperty("percent_change_1h")
    private BigDecimal percentChange1h;
    
    @JsonProperty("percent_change_24h")
    private BigDecimal percentChange24h;
    
    @JsonProperty("name")
    private String name;
    
    @JsonProperty("volume_24h")
    private String volume24h;
    
    @JsonProperty("price_usd")
    private String priceUsd;
    
    @JsonProperty("available_supply")
    private Long availableSupply;
    
    @JsonProperty("alias")
    private String alias;
    
    @JsonProperty("currency")
    private String currency;
    
    @JsonProperty("pair")
    private String pair;
    
    @JsonProperty("percent_change_7d")
    private BigDecimal percentChange7d;
    
    @JsonProperty("category")
    private String category;
    
    @JsonProperty("search_field")
    private String searchField;
    
    /**
     * 获取数值形式的当前价格
     */
    public BigDecimal getNumericPrice() {
        try {
            return new BigDecimal(price);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取交易对基础货币
     */
    public String getBaseAsset() {
        if (pair != null &amp;&amp; pair.contains("/")) {
            return pair.split("/")[0];
        }
        return symbol.replace("USDT", "");
    }
    
    /**
     * 获取交易对报价货币
     */
    public String getQuoteAsset() {
        if (pair != null &amp;&amp; pair.contains("/")) {
            return pair.split("/")[1];
        }
        return "USDT";
    }
}</code></pre><h4>价格行情数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 价格行情数据模型
 */
@Data
public class TickerPrice {
    @JsonProperty("priceChange")
    private String priceChange;
    
    @JsonProperty("symbol")
    private String symbol;
    
    @JsonProperty("count")
    private Long count;
    
    @JsonProperty("openPrice")
    private String openPrice;
    
    @JsonProperty("lastId")
    private Long lastId;
    
    @JsonProperty("quoteVolume")
    private String quoteVolume;
    
    @JsonProperty("firstId")
    private Long firstId;
    
    @JsonProperty("volume")
    private String volume;
    
    @JsonProperty("weightedAvgPrice")
    private String weightedAvgPrice;
    
    @JsonProperty("lowPrice")
    private String lowPrice;
    
    @JsonProperty("highPrice")
    private String highPrice;
    
    @JsonProperty("closeTime")
    private Long closeTime;
    
    @JsonProperty("openTime")
    private Long openTime;
    
    @JsonProperty("priceChangePercent")
    private String priceChangePercent;
    
    @JsonProperty("lastPrice")
    private String lastPrice;
    
    /**
     * 获取数值形式的最后价格
     */
    public BigDecimal getNumericLastPrice() {
        try {
            return new BigDecimal(lastPrice);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取数值形式的涨跌幅
     */
    public BigDecimal getNumericPriceChangePercent() {
        try {
            return new BigDecimal(priceChangePercent);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取数值形式的交易量
     */
    public BigDecimal getNumericVolume() {
        try {
            return new BigDecimal(volume);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
}</code></pre><h4>最新价格数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 最新价格数据模型
 */
@Data
public class LastPrice {
    @JsonProperty("symbol")
    private String symbol;
    
    @JsonProperty("price")
    private String price;
    
    /**
     * 获取数值形式的价格
     */
    public BigDecimal getNumericPrice() {
        try {
            return new BigDecimal(price);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
}</code></pre><h4>K线数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import lombok.Data;

import java.math.BigDecimal;

/**
 * K线数据模型
 */
@Data
public class KLine {
    private Long openTime;
    private BigDecimal openPrice;
    private BigDecimal highPrice;
    private BigDecimal lowPrice;
    private BigDecimal closePrice;
    private BigDecimal volume;
    private Long closeTime;
    private BigDecimal quoteAssetVolume;
    private Integer numberOfTrades;
    private BigDecimal takerBuyBaseAssetVolume;
    private BigDecimal takerBuyQuoteAssetVolume;
    private String ignore;
    
    /**
     * 构造函数 - 从数组解析
     */
    public KLine(Object[] data) {
        if (data != null &amp;&amp; data.length &gt;= 11) {
            this.openTime = ((Number) data[0]).longValue();
            this.openPrice = new BigDecimal(data[1].toString());
            this.highPrice = new BigDecimal(data[2].toString());
            this.lowPrice = new BigDecimal(data[3].toString());
            this.closePrice = new BigDecimal(data[4].toString());
            this.volume = new BigDecimal(data[5].toString());
            this.closeTime = ((Number) data[6]).longValue();
            this.quoteAssetVolume = new BigDecimal(data[7].toString());
            this.numberOfTrades = ((Number) data[8]).intValue();
            this.takerBuyBaseAssetVolume = new BigDecimal(data[9].toString());
            this.takerBuyQuoteAssetVolume = new BigDecimal(data[10].toString());
            if (data.length &gt; 11) {
                this.ignore = data[11].toString();
            }
        }
    }
    
    /**
     * 计算振幅百分比
     */
    public BigDecimal getAmplitudePercent() {
        if (openPrice.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO;
        }
        return highPrice.subtract(lowPrice)
                .divide(openPrice, 4, BigDecimal.ROUND_HALF_UP)
                .multiply(BigDecimal.valueOf(100));
    }
    
    /**
     * 计算涨跌幅百分比
     */
    public BigDecimal getChangePercent() {
        if (openPrice.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO;
        }
        return closePrice.subtract(openPrice)
                .divide(openPrice, 4, BigDecimal.ROUND_HALF_UP)
                .multiply(BigDecimal.valueOf(100));
    }
}</code></pre><h4>交易数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 交易数据模型
 */
@Data
public class Trade {
    @JsonProperty("quoteQty")
    private String quoteQty;
    
    @JsonProperty("price")
    private String price;
    
    @JsonProperty("qty")
    private String qty;
    
    @JsonProperty("isBestMatch")
    private Boolean isBestMatch;
    
    @JsonProperty("id")
    private Long id;
    
    @JsonProperty("time")
    private Long time;
    
    @JsonProperty("isBuyerMaker")
    private Boolean isBuyerMaker;
    
    /**
     * 获取数值形式的价格
     */
    public BigDecimal getNumericPrice() {
        try {
            return new BigDecimal(price);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取数值形式的数量
     */
    public BigDecimal getNumericQty() {
        try {
            return new BigDecimal(qty);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取交易方向
     */
    public String getTradeDirection() {
        return Boolean.TRUE.equals(isBuyerMaker) ? "SELL" : "BUY";
    }
}</code></pre><h4>API响应包装类</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

/**
 * API通用响应包装类
 */
@Data
public class ApiResponse&lt;T&gt; {
    @JsonProperty("code")
    private Integer code;
    
    @JsonProperty("message")
    private String message;
    
    @JsonProperty("data")
    private T data;
    
    /**
     * 判断请求是否成功
     */
    public boolean isSuccess() {
        return code != null &amp;&amp; code == 200;
    }
}

/**
 * 交易对列表响应包装类
 */
@Data
class PairListResponse {
    @JsonProperty("total_count")
    private Integer totalCount;
    
    @JsonProperty("total_page")
    private Integer totalPage;
    
    @JsonProperty("list")
    private List&lt;CryptoPair&gt; list;
    
    @JsonProperty("fields")
    private List&lt;String&gt; fields;
}</code></pre><h3>3. HTTP客户端实现</h3><pre><code class="java">package com.stocktv.binance.client;

import com.fasterxml.jackson.core.type.TypeReference;
import com.stocktv.binance.config.BinanceConfig;
import com.stocktv.binance.model.*;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 币安数据HTTP客户端
 */
public class BinanceHttpClient {
    
    private static final Logger logger = LoggerFactory.getLogger(BinanceHttpClient.class);
    
    private final BinanceConfig config;
    private final CloseableHttpClient httpClient;
    
    public BinanceHttpClient(BinanceConfig config) {
        this.config = config;
        this.httpClient = config.getHttpClient();
    }
    
    /**
     * 获取交易对列表
     */
    public List&lt;CryptoPair&gt; getPairList(Integer page, Integer size) throws IOException, URISyntaxException {
        URIBuilder uriBuilder = new URIBuilder(config.BASE_URL + config.CRYPTO_PAIR_LIST)
                .addParameter("key", config.getApiKey())
                .addParameter("marketId", String.valueOf(config.BINANCE_MARKET_ID));
        
        if (page != null) {
            uriBuilder.addParameter("page", String.valueOf(page));
        }
        if (size != null) {
            uriBuilder.addParameter("size", String.valueOf(size));
        }
        
        URI uri = uriBuilder.build();
        
        ApiResponse&lt;PairListResponse&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;PairListResponse&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取 {} 个交易对", response.getData().getList().size());
            return response.getData().getList();
        } else {
            throw new RuntimeException("获取交易对列表失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取最新行情
     */
    public List&lt;TickerPrice&gt; getTickerPrice(List&lt;String&gt; symbols) throws IOException, URISyntaxException {
        if (symbols == null || symbols.isEmpty()) {
            throw new IllegalArgumentException("交易对列表不能为空");
        }
        
        // 限制最大数量
        if (symbols.size() &gt; 100) {
            symbols = symbols.subList(0, 100);
            logger.warn("交易对数量超过限制，只取前100个");
        }
        
        String symbolsStr = String.join(",", symbols);
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_TICKER_PRICE)
                .addParameter("key", config.getApiKey())
                .addParameter("symbols", symbolsStr)
                .build();
        
        ApiResponse&lt;List&lt;TickerPrice&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;TickerPrice&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取 {} 个交易对的最新行情", response.getData().size());
            return response.getData();
        } else {
            throw new RuntimeException("获取最新行情失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取最新价格
     */
    public List&lt;LastPrice&gt; getLastPrice(List&lt;String&gt; symbols) throws IOException, URISyntaxException {
        if (symbols == null || symbols.isEmpty()) {
            throw new IllegalArgumentException("交易对列表不能为空");
        }
        
        // 限制最大数量
        if (symbols.size() &gt; 100) {
            symbols = symbols.subList(0, 100);
            logger.warn("交易对数量超过限制，只取前100个");
        }
        
        String symbolsStr = String.join(",", symbols);
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_LAST_PRICE)
                .addParameter("key", config.getApiKey())
                .addParameter("symbols", symbolsStr)
                .build();
        
        ApiResponse&lt;List&lt;LastPrice&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;LastPrice&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取 {} 个交易对的最新价格", response.getData().size());
            return response.getData();
        } else {
            throw new RuntimeException("获取最新价格失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取K线数据
     */
    public List&lt;KLine&gt; getKlines(String symbol, String interval) throws IOException, URISyntaxException {
        if (symbol == null || symbol.trim().isEmpty()) {
            throw new IllegalArgumentException("交易对不能为空");
        }
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_GET_KLINES)
                .addParameter("key", config.getApiKey())
                .addParameter("symbol", symbol)
                .addParameter("interval", interval)
                .build();
        
        // K线数据返回的是数组的数组
        ApiResponse&lt;List&lt;Object[]&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;Object[]&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            List&lt;KLine&gt; klines = response.getData().stream()
                    .map(KLine::new)
                    .collect(Collectors.toList());
            logger.info("成功获取交易对 {} 的K线数据，共 {} 条", symbol, klines.size());
            return klines;
        } else {
            throw new RuntimeException("获取K线数据失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取近期成交
     */
    public List&lt;Trade&gt; getTrades(String symbol) throws IOException, URISyntaxException {
        if (symbol == null || symbol.trim().isEmpty()) {
            throw new IllegalArgumentException("交易对不能为空");
        }
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_GET_TRADES)
                .addParameter("key", config.getApiKey())
                .addParameter("symbol", symbol)
                .build();
        
        ApiResponse&lt;List&lt;Trade&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;Trade&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取交易对 {} 的成交数据，共 {} 条", symbol, response.getData().size());
            return response.getData();
        } else {
            throw new RuntimeException("获取成交数据失败: " + response.getMessage());
        }
    }
    
    /**
     * 搜索交易对
     */
    public List&lt;CryptoPair&gt; searchPairs(String keyword, Integer limit) throws IOException, URISyntaxException {
        List&lt;CryptoPair&gt; allPairs = getPairList(1, 1000); // 获取较多数据用于搜索
        
        return allPairs.stream()
                .filter(pair -&gt; 
                    pair.getSymbol().toLowerCase().contains(keyword.toLowerCase()) ||
                    pair.getName().toLowerCase().contains(keyword.toLowerCase()) ||
                    (pair.getSearchField() != null &amp;&amp; 
                     pair.getSearchField().toLowerCase().contains(keyword.toLowerCase())))
                .limit(limit != null ? limit : 10)
                .collect(Collectors.toList());
    }
    
    /**
     * 获取Top N市值的加密货币
     */
    public List&lt;CryptoPair&gt; getTopMarketCapPairs(int topN) throws IOException, URISyntaxException {
        List&lt;CryptoPair&gt; allPairs = getPairList(1, topN);
        
        // 按排名排序
        return allPairs.stream()
                .sorted((p1, p2) -&gt; {
                    if (p1.getRank() == null) return 1;
                    if (p2.getRank() == null) return -1;
                    return p1.getRank().compareTo(p2.getRank());
                })
                .limit(topN)
                .collect(Collectors.toList());
    }
    
    /**
     * 通用GET请求执行方法
     */
    private &lt;T&gt; T executeGetRequest(URI uri, TypeReference&lt;T&gt; typeReference) throws IOException {
        HttpGet request = new HttpGet(uri);
        logger.debug("执行币安API请求: {}", uri);
        
        try (CloseableHttpResponse response = httpClient.execute(request)) {
            int statusCode = response.getStatusLine().getStatusCode();
            String responseBody = EntityUtils.toString(response.getEntity());
            
            if (statusCode != 200) {
                throw new IOException("HTTP请求失败，状态码: " + statusCode);
            }
            
            logger.debug("币安API响应: {}", responseBody);
            return config.getObjectMapper().readValue(responseBody, typeReference);
        }
    }
    
    /**
     * 关闭HTTP客户端
     */
    public void close() throws IOException {
        if (httpClient != null) {
            httpClient.close();
        }
    }
}</code></pre><h3>4. WebSocket客户端实现</h3><pre><code class="java">package com.stocktv.binance.client;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.stocktv.binance.config.BinanceConfig;
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * 币安WebSocket实时数据客户端
 */
public class BinanceWebSocketClient {
    
    private static final Logger logger = LoggerFactory.getLogger(BinanceWebSocketClient.class);
    
    private final BinanceConfig config;
    private final ObjectMapper objectMapper;
    private WebSocketClient webSocketClient;
    private CountDownLatch connectionLatch;
    
    public BinanceWebSocketClient(BinanceConfig config) {
        this.config = config;
        this.objectMapper = config.getObjectMapper();
    }
    
    /**
     * 连接WebSocket服务器
     */
    public void connect() throws Exception {
        String wsUrl = config.WS_URL + "?key=" + config.getApiKey();
        URI serverUri = URI.create(wsUrl);
        
        connectionLatch = new CountDownLatch(1);
        
        webSocketClient = new WebSocketClient(serverUri) {
            @Override
            public void onOpen(ServerHandshake handshake) {
                logger.info("币安WebSocket连接已建立");
                connectionLatch.countDown();
            }
            
            @Override
            public void onMessage(String message) {
                try {
                    handleRealTimeMessage(message);
                } catch (Exception e) {
                    logger.error("处理WebSocket消息时出错", e);
                }
            }
            
            @Override
            public void onClose(int code, String reason, boolean remote) {
                logger.info("币安WebSocket连接已关闭: code={}, reason={}, remote={}", code, reason, remote);
            }
            
            @Override
            public void onError(Exception ex) {
                logger.error("币安WebSocket连接错误", ex);
            }
        };
        
        webSocketClient.connect();
        
        // 等待连接建立
        if (!connectionLatch.await(10, TimeUnit.SECONDS)) {
            throw new RuntimeException("WebSocket连接超时");
        }
    }
    
    /**
     * 处理实时消息
     */
    private void handleRealTimeMessage(String message) throws Exception {
        JsonNode jsonNode = objectMapper.readTree(message);
        
        // 解析实时行情数据
        if (jsonNode.has("symbol") || jsonNode.has("pid")) {
            RealTimeData realTimeData = parseRealTimeData(jsonNode);
            onRealTimeData(realTimeData);
        } else {
            logger.debug("收到其他消息: {}", message);
        }
    }
    
    /**
     * 解析实时数据
     */
    private RealTimeData parseRealTimeData(JsonNode jsonNode) {
        RealTimeData data = new RealTimeData();
        
        if (jsonNode.has("symbol")) {
            data.setSymbol(jsonNode.get("symbol").asText());
        }
        if (jsonNode.has("pid")) {
            data.setPid(jsonNode.get("pid").asText());
        }
        if (jsonNode.has("last_numeric")) {
            data.setLastPrice(jsonNode.get("last_numeric").asText());
        }
        if (jsonNode.has("bid")) {
            data.setBid(jsonNode.get("bid").asText());
        }
        if (jsonNode.has("ask")) {
            data.setAsk(jsonNode.get("ask").asText());
        }
        if (jsonNode.has("high")) {
            data.setHigh(jsonNode.get("high").asText());
        }
        if (jsonNode.has("low")) {
            data.setLow(jsonNode.get("low").asText());
        }
        if (jsonNode.has("pc")) {
            data.setPriceChange(jsonNode.get("pc").asText());
        }
        if (jsonNode.has("pcp")) {
            data.setChangePercent(jsonNode.get("pcp").asText());
        }
        if (jsonNode.has("turnover_numeric")) {
            data.setVolume(jsonNode.get("turnover_numeric").asText());
        }
        if (jsonNode.has("time")) {
            data.setTime(jsonNode.get("time").asText());
        }
        if (jsonNode.has("timestamp")) {
            data.setTimestamp(jsonNode.get("timestamp").asText());
        }
        
        return data;
    }
    
    /**
     * 处理实时数据
     */
    protected void onRealTimeData(RealTimeData data) {
        String symbol = data.getSymbol() != null ? data.getSymbol() : data.getPid();
        
        // 记录基础信息
        logger.debug("实时行情: {} - 价格: {}, 涨跌幅: {}%", 
            symbol, data.getLastPrice(), data.getChangePercent());
        
        // 价格预警逻辑
        try {
            double changePercent = Double.parseDouble(data.getChangePercent());
            if (Math.abs(changePercent) &gt; 5.0) {
                logger.warn("🚨 加密货币价格波动预警: {} 波动 {}%", symbol, changePercent);
            }
            
            // 大额交易监控
            if (data.getVolume() != null) {
                double volume = Double.parseDouble(data.getVolume());
                if (volume &gt; 1000000) { // 100万美元以上
                    logger.info("💰 大额交易: {} 成交额 ${}", symbol, volume);
                }
            }
        } catch (NumberFormatException e) {
            // 忽略转换错误
        }
    }
    
    /**
     * 发送消息
     */
    public void sendMessage(String message) {
        if (webSocketClient != null &amp;&amp; webSocketClient.isOpen()) {
            webSocketClient.send(message);
        }
    }
    
    /**
     * 关闭连接
     */
    public void close() {
        if (webSocketClient != null) {
            webSocketClient.close();
        }
    }
    
    /**
     * 实时数据模型
     */
    public static class RealTimeData {
        private String pid;
        private String symbol;
        private String lastPrice;
        private String bid;
        private String ask;
        private String high;
        private String low;
        private String priceChange;
        private String changePercent;
        private String volume;
        private String time;
        private String timestamp;
        
        // Getters and Setters
        public String getPid() { return pid; }
        public void setPid(String pid) { this.pid = pid; }
        public String getSymbol() { return symbol; }
        public void setSymbol(String symbol) { this.symbol = symbol; }
        public String getLastPrice() { return lastPrice; }
        public void setLastPrice(String lastPrice) { this.lastPrice = lastPrice; }
        public String getBid() { return bid; }
        public void setBid(String bid) { this.bid = bid; }
        public String getAsk() { return ask; }
        public void setAsk(String ask) { this.ask = ask; }
        public String getHigh() { return high; }
        public void setHigh(String high) { this.high = high; }
        public String getLow() { return low; }
        public void setLow(String low) { this.low = low; }
        public String getPriceChange() { return priceChange; }
        public void setPriceChange(String priceChange) { this.priceChange = priceChange; }
        public String getChangePercent() { return changePercent; }
        public void setChangePercent(String changePercent) { this.changePercent = changePercent; }
        public String getVolume() { return volume; }
        public void setVolume(String volume) { this.volume = volume; }
        public String getTime() { return time; }
        public void setTime(String time) { this.time = time; }
        public String getTimestamp() { return timestamp; }
        public void setTimestamp(String timestamp) { this.timestamp = timestamp; }
    }
}</code></pre>]]></description></item><item>    <title><![CDATA[八骏医疗云：解码眼科设备制造厂商的客户关]]></title>    <link>https://segmentfault.com/a/1190000047400097</link>    <guid>https://segmentfault.com/a/1190000047400097</guid>    <pubDate>2025-11-14 16:02:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在现代医疗行业，客户关系管理（CRM）已成为企业提升运营效率、优化服务体验和增强市场竞争力的关键工具。特别是对于眼科医疗设备企业而言，CRM系统不仅是客户信息的存储与管理平台，更是连接医疗设备销售、售后服务、客户关系维护及市场拓展的重要桥梁。<br/><img width="723" height="496" referrerpolicy="no-referrer" src="/img/bVdm25P" alt="image.png" title="image.png"/><br/>本文将围绕眼科医疗设备企业的CRM软件，深入分析其在客户关系管理中的核心功能与应用场景，帮助用户更好地理解该系统如何助力眼科医疗设备企业实现高效、精准的客户管理。</p><hr/><h2>一、眼科医疗设备企业CRM软件的核心特点</h2><p>眼科医疗设备企业的客户关系管理具有以下特点：</p><ol><li><strong>精准客户画像</strong>\<br/>企业需要根据客户类型（如医院、诊所、个体医生等）进行分类管理，CRM系统可以帮助企业快速建立客户档案，实现个性化的服务与营销策略。</li><li><strong>多渠道客户互动</strong>\<br/>医疗设备销售通常涉及医院采购、医生咨询、设备维护等多个环节，CRM系统需支持多渠道客户互动，包括电话、邮件、在线客服、社交媒体等。</li><li><strong>销售流程自动化</strong>\<br/>眼科设备销售流程通常包括产品介绍、报价、订单处理、售后服务等，CRM系统可自动触发销售流程，提升效率。</li><li><strong>数据分析与洞察</strong>\<br/>企业需要通过客户数据进行分析，以优化产品推广、售后服务和客户满意度。CRM系统提供数据可视化工具，帮助企业洞察客户需求和市场趋势。</li></ol><hr/><h2>二、八骏CRM医疗版的功能拆解</h2><h3>1. <strong>客户信息管理：精准标签与分类</strong></h3><p>八骏CRM医疗版支持对客户进行多维标签管理，如医院类型（综合医院、眼科专科医院等）、客户级别（VIP客户、普通客户）、设备需求类型（如白内障手术设备、角膜移植设备等）。通过标签体系，企业可实现客户的精准分类，制定差异化的服务策略。</p><h3>2. <strong>销售流程自动化：从线索获取到售后跟进</strong></h3><ul><li><strong>线索管理</strong>：系统支持线索来源的分类与跟踪，如医院采购、医生推荐、展会邀约等。</li><li><strong>销售流程自动化</strong>：系统可自动完成报价、合同签署、订单处理、发货通知等流程，减少人工干预，提升效率。</li><li><strong>售后跟进</strong>：客户购买设备后，系统可自动提醒售后人员进行设备安装、使用培训、维护记录等，提升客户满意度。</li></ul><h3>3. <strong>多渠道客户互动：提升客户体验</strong></h3><ul><li><strong>在线客服与消息通知</strong>：支持客户通过系统实时咨询、预约、反馈问题。</li><li><strong>客户反馈与评价管理</strong>：客户可对产品和服务进行评价，系统自动归类并分析反馈趋势，帮助企业优化产品和服务。</li><li><strong>社交媒体整合</strong>：系统支持客户在社交媒体上的互动，如客户留言、产品使用分享等，提升品牌曝光度。</li></ul><h3>4. <strong>数据分析与客户洞察</strong></h3><ul><li><strong>客户行为分析</strong>：系统能够分析客户购买记录、使用频率、售后服务反馈等数据，帮助企业挖掘客户需求。</li><li><strong>客户生命周期管理</strong>：系统可根据客户状态（如新客户、潜在客户、流失客户）进行生命周期管理，制定相应的跟进策略。</li><li><strong>销售漏斗分析</strong>：通过销售流程的可视化分析，企业可以优化销售策略，提升转化率。</li></ul><hr/><h2>三、总结：选择CRM软件的关键考量</h2><p>对于眼科医疗设备企业而言，选择合适的CRM软件至关重要：</p><ul><li><strong>精准客户管理</strong>：系统需支持多维度客户标签与分类，提升客户管理的精准度。</li><li><strong>销售流程自动化</strong>：自动化流程可减少人力成本，提升销售效率。</li><li><strong>多渠道客户互动</strong>：支持多种沟通方式，提升客户体验与满意度。</li><li><strong>数据分析与洞察</strong>：通过数据驱动决策，优化产品与服务策略。</li></ul><p>八骏CRM医疗版以其强大的客户管理功能、高效的工作流程和全面的数据分析能力，成为眼科医疗设备企业提升客户服务质量与市场竞争力的理想选择。</p><hr/><h2>四、结语</h2><p>在医疗设备行业，CRM软件不仅是工具，更是企业实现精细化运营和客户价值挖掘的核心引擎。八骏CRM医疗版以其专业的功能设计和灵活的行业适配性，为眼科医疗设备企业提供了可靠的支持，助力企业在激烈的市场竞争中脱颖而出。</p><p>选择合适的CRM软件，是企业数字化转型的关键一步。希望本文能为眼科医疗设备企业选择CRM系统提供有价值的参考。</p>]]></description></item><item>    <title><![CDATA[导师型领导指南 俞凡 ]]></title>    <link>https://segmentfault.com/a/1190000047400107</link>    <guid>https://segmentfault.com/a/1190000047400107</guid>    <pubDate>2025-11-14 16:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><em>本文介绍了导师型领导的管理应该如何指导团队成员的通用原则，分析了不同学员的类型，以及针对不同类型学员的应对方式。原文：<a href="https://link.segmentfault.com/?enc=If5x7oiSD1CtugRhoooV3g%3D%3D.pEkDeNjxN9MQD1b%2FfKTGTD4y1yGWNQFdqekXMzTONMNwCbvdZqEYsL9IteLtMOHrlWsDFOJ5yRDXbip40cFQZrKln0yY1GmMhRncgSlos3jizyOqWIPYeiP8160Wtd2G" rel="nofollow" title="How to be a good mentor for your whole team" target="_blank">How to be a good mentor for your whole team</a></em></blockquote><p>在理想的世界里，所有管理者都会秉持导师型工作理念。但在现实世界中并非如此，世界显然并不完美,许多管理者只是完成工作而已。他们确保团队能够出色执行任务，但与那些秉持导师理念的管理者不同，他们对帮助员工应对新挑战或抓住新机遇并不太感兴趣。</p><p>要预测哪种类型的管理者能带领团队取得更好的成绩，或者在年度评估时获得更高的评价，其实并不需要多么复杂的算法。</p><p>关键在于，导师指导并非适用于所有情况。诚然，有些指导原则是通用的，这里就直接总结要点：</p><ul><li><strong>一致性</strong>：按照固定节奏进行交流，但也要根据实际情况灵活安排临时会议。</li><li><a href="https://link.segmentfault.com/?enc=pUUECBnLRxjW9FT5CqfpGA%3D%3D.cLEjf6gwmLq31GFe6ovObdHoqa%2FTR6Mi%2F12Av24Pr4QG%2FePrK5v2UMXavc%2FxLyFGJB6bVefTPFVPusbEZg%2F%2FLQ%3D%3D" rel="nofollow" title="**积极倾听**" target="_blank"><strong>积极倾听</strong></a>：与被指导者会面时，要静下心来，全神贯注，关掉手机，关闭电脑，以减少干扰。在交流过程中做笔记并提出疑问。</li><li><strong>建设性反馈</strong>：单方面批评是不够的，要为被指导者在遭遇挫折后如何继续前进或下次如何做出不同选择提供切实可行的建议。</li><li><strong>适当的挑战</strong>：要鼓励被指导者超越舒适区，但要以同理心的方式进行。他们的处境和/或个性可能会限制他们能够或愿意做的事情。</li><li><strong>乐观（与现实相结合）</strong>：在大多数情况下，保持积极态度并专注于激励被指导者是最佳选择。但有时事情确实不会如愿发展。坦诚交流可以帮助他们认识到何时该放弃损失并尝试新的方法。</li></ul><p>但要对所管理的人员产生深远影响，必须根据每个个体的特点调整指导方式。有些人容易合作，而指导其他人可能就不那么直接了。我们基于自身经验，再加上来自<a href="https://link.segmentfault.com/?enc=P7jGypaPUe1p2W%2BQ4ZDL%2Bw%3D%3D.KsP0xAIVeI78FjRpBOxgwJI%2BLfYBXBtURI3ZMBosZeh8I2%2Fe4bkvCX0ZIGm%2FnwYj" rel="nofollow" title="全球导师网络" target="_blank">全球导师网络</a>和 <a href="https://link.segmentfault.com/?enc=Zue5Ba6%2FdDZxGvVSHGaX9g%3D%3D.zJ6XYgijCTnc0Q7Xe2ydoA4X27zm3TNx5rS%2BqA%2BblJRHDuVNoIIXY0lrBmNkhfY%2B" rel="nofollow" title="Together" target="_blank">Together</a> 组织的一些有用资料，编写了这份指南，旨在帮助大家了解常见的人员类型，并指导如何与每一种类型的人员建立导师与学员的关系。</p><h2>学员类型及需求</h2><p>旁注：虽然我们是从管理者与直接下属合作的角度来看待问题，但下面的所有内容都适用于各种各样的情况。所以，如果你以老师、教授、教练、资深同事、朋友或亲戚的身份指导某人，你的位置仍然是正确的。</p><h5>1. 明星学员</h5><p><strong>特点</strong>：雄心勃勃；专注于职业发展；做事有条理且注重细节。</p><p><strong>需要的是</strong>：关于优先事项的指导。</p><p>这些学员的积极性堪称爆棚。如果有什么需要的话，他们只是需要一些提醒来控制自己的进度，以免过度劳累而精疲力竭。你的职责是帮助他们明确、可实现的目标，并将其分解为阶段性目标。要监督他们的表现，如果偏离正轨要及时引导他们回到正确的轨道上来。由于有着如此强烈的动力和好奇心，如果不能持续专注于自己的“北极星”目标，他们可能会变得过于分散精力。但你也应该教导他们对自己要有耐心（他们往往在这方面存在困难！），如果内心的声音变得过于强烈，要让他们安静下来。当他们达成某个阶段性目标时，准备好与他们击掌庆祝。优秀人才都喜欢一些外部的认可。</p><h5>2. 未经雕琢的璞玉</h5><p><strong>特点</strong>：大量未实现的潜力；容易犯错（诚实、粗心的）；倾向于开放和好奇，但不一定活泼或外向。</p><p><strong>需要的是</strong>：一个练习对手。</p><p>璞玉未经雕琢时，并不一定清楚自己最终想要成为什么样的人。是成为注重策略的管理者？还是成为精通某项领域的顶尖高手？两种可能性都有！你可以通过为他们提供提升现有技能或学习新技能的机会，为他们的探索活动赋予方向。在他们处理超出自身能力范围的项目时，挑战并引导他们的思维。你还可以用你的人脉介绍一些能够帮助他们发展的人。</p><h5>3. 自我驱动者</h5><p><strong>特点</strong>：非常独立；想要自己全权负责，这样才能按照自己的方式去做；对于日常小事不寻求他人的建议。</p><p><strong>需要的是</strong>：灵感与自我反省。</p><p>自我驱动者具有强烈的自主意识、自我激励能力和自我推进能力，这对于注重指导管理的管理者来说可能颇具挑战性。因为他们倾向于自行设定目标，所以你的任务就是向他们展示各种可能性，然后让他们自行决定如何（以及是否）实现这些目标。另一种能够产生影响的方式是帮助他们发现自身可能未曾意识到的长处，并找出需要加强的弱点。帮助他们成为最好的自己，他们就能开创出最辉煌的职业生涯。</p><h5>4. 无所不知的人</h5><p><strong>特点</strong>：年龄比经理大，或者拥有更丰富的行业经验；事业有成；可能在团队之外也有自己的导师。</p><p><strong>需要的是</strong>：团结。</p><p>请不要往心里去，但这个人并不确定能从你这里学到多少东西。毕竟，他们在这一领域的从业时间比你长得多。像你这样的新手能给什么帮助呢？答案是合作。不要试图引导他们的职业生涯，而是要帮助他们找到能推进他们已有目标的项目。此外，把自己当作解决棘手职场问题的资源，比如与同事之间的冲突或预算削减等问题。你甚至可以提议“反向指导”，即他们指导你在某个你想要改进的领域进行提升。</p><h5>5. 流浪者</h5><p><strong>特点</strong>：表现不佳，潜力尚未开发；拖累工作；工作质量落后于团队的其他成员。</p><p><strong>需要的是</strong>：通往成功的路线图。</p><p>这个人可能面临诸多困境。你的首要任务是找出原因。比如，个人生活中的困难是否影响了他们的工作表现？例如，新添的宝宝或家庭中的重大疾病都可能对工作表现造成严重影响，又或者也许这个职位并不适合他们。一旦你们共同确定了根本原因，就一起制定改进计划或过渡计划，设定里程碑和目标日期。在过程中要庆祝他们的进步。如果他们出现失误，要让他们承担责任，但同时也要用无条件的同情来平衡你的建设性批评。</p><h5>6. 天生敏感特质</h5><p><strong>特点</strong>：性格敏感；容易产生防御心理；可能因批评而产生愤怒或绝望的情绪。</p><p><strong>需要的是</strong>：同情心和自信。</p><p>要留意这个人身上是否存在“<a href="https://link.segmentfault.com/?enc=UIO2WLJLAPKpb%2BYlx9eI%2Bg%3D%3D.GWzZKhWHxi7lI4KPgGhdeqmRIXROxCYFgcMuKxDTgDQBfS%2FzrrOVCbhBtWkn9DoGDvpHEdSWcn1pHD1rkhIZYMHDq6XxLIrNR6MjeusKk5ZSTShyDj5E2PFjhSU2pIGt" rel="nofollow" title="冒充者综合征" target="_blank">冒充者综合征</a>”迹象。很有可能他们觉得自己在能力方面力不从心，或者被繁重的工作压得喘不过气来。关键在于要认可他们的感受，但不要加以评判。首先，询问他们认为自己面临的最大障碍是什么，然后一起制定克服或绕过这些障碍的计划。要保持真诚 —— 不要过度称赞平庸的工作表现 —— 但要多给予积极反馈，以帮助提升他们的信心。如果能在公开场合（比如团队会议或 Slack 群组）对他们进行表扬，那就更好了。</p><h2>避免误区</h2><p>积极参与导师指导有助于你成长为优秀的领导者。同时，也能够帮助团队成员成长，而这恰恰是良好领导力的体现。但在你踏上这段旅程之前，有几个潜在隐患需要留意。</p><p>首先，要明确自己能够提供的服务范围，这既是为了自己的利益，也是为了学员们的利益。很容易就会过度投入，尤其是如果你天生倾向于服务型领导风格的话。一旦学员开始期望你有如此高强度的参与度，要收回这种投入就真的很难了。</p><p>尽早设定界限，并要具体明确。例如，你不会替他们撰写项目提案，但会乐意对草稿提供反馈。或者，你会倾听他们与同事之间的矛盾，并给出建议，但不会贸然去找那个人的经理来解决问题。</p><p>第二条建议来自研究者、作家兼知名人士布伦妮·布朗：<a href="https://link.segmentfault.com/?enc=dWXZnr07TySUgo2tJW%2FqFQ%3D%3D.33k86Eu5FZvC3CISqPuzqhBQtJ1HmoHVGzxNX%2BVeVEN5nzVRlY%2BDAE47YhZUzVs4WJFgGiiOKoprG7n7XfNX8Q%3D%3D" rel="nofollow" title="要学会恰当运用内疚情绪，但要避免对其进行羞辱" target="_blank">要学会恰当运用内疚情绪，但要避免对其进行羞辱</a>。两者的区别在于，内疚让我们明白自己犯了错误，需要做得更好；而羞耻则让我们觉得自己不配获得成功。</p><p>所以，当团队成员出现失误时，应从其行为或表现方面进行讨论，而非从其个人角度出发 —— 要说“那是个错误决定”，不要说“你是个糟糕的决策者”。正如布朗指出的，羞辱更有可能引发或加剧问题，而非解决问题。</p><p>现在就行动起来吧，去帮助某人让今天变得精彩！</p><hr/><blockquote>你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。为了方便大家以后能第一时间看到文章，请朋友们关注公众号"DeepNoMind"，并设个星标吧，如果能一键三连(转发、点赞、在看)，则能给我带来更多的支持和动力，激励我持续写下去，和大家共同成长进步！</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=pW8ORexPSSzB5g3YHYy1XA%3D%3D.broKzVfH3a8D6LVN2dPtvTsVNsVdEMiiDFCmGptMl9E%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[眼科设备制造厂商如何选对CRM？2025]]></title>    <link>https://segmentfault.com/a/1190000047400118</link>    <guid>https://segmentfault.com/a/1190000047400118</guid>    <pubDate>2025-11-14 16:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>引言：眼科设备制造行业的挑战与机遇</h2><p>在2025年，随着医疗技术的不断发展和市场竞争的加剧，眼科设备制造厂商面临着前所未有的挑战与机遇。从产品研发到市场开拓，从客户关系到售后服务，每一个环节都要求企业具备高效的管理工具和精准的销售策略。</p><p><strong>痛点分析：</strong></p><ul><li><strong>客户需求多样化</strong>：客户对产品性能、价格、售后体验等有较高要求。</li><li><strong>销售流程复杂</strong>：从需求挖掘、方案制定、合同签订到交付服务，流程繁琐。</li><li><strong>数据管理滞后</strong>：缺乏系统化的客户数据管理，影响销售决策和客户体验。</li><li><strong>售后服务压力大</strong>：设备维护、技术支持、客户反馈等环节需持续跟踪。</li></ul><hr/><h2>一、眼科设备制造行业销售特点分析</h2><h3>1.1 客户画像复杂</h3><p>眼科设备客户主要包括医院、诊所、医疗器械公司等，客户群体具有专业性强、需求明确、合同金额大等特点。</p><h3>1.2 需求周期长</h3><p>从产品介绍、方案设计到签订合同，通常需要数周甚至数月，周期较长，对CRM系统的时间管理能力提出了较高要求。</p><h3>1.3 交互合作频繁</h3><p>销售、市场、研发、售后等多个部门频繁协作，信息共享和流程协同至关重要。</p><h3>1.4 服务不可替代性强</h3><p>眼科设备具有较高的技术壁垒，客户对售后服务的满意度直接影响品牌口碑与复购率。</p><hr/><h2>二、眼科设备制造厂商的智能解决方案</h2><h3>2.1 产品功能概述</h3><p>以<strong>八骏CRM医疗版</strong>为例，这是一款专为医疗行业定制的客户关系管理软件，其核心功能包括：<br/><img width="723" height="498" referrerpolicy="no-referrer" src="/img/bVdm254" alt="image.png" title="image.png"/></p><ul><li><strong>客户信息管理</strong>：支持客户画像、历史沟通、订单记录、合同管理等，实现客户数据的标准化和可视化。</li><li><strong>销售流程自动化</strong>：从线索获取、商机跟踪、销售流程到合同签订，一键完成，提升销售效率。</li><li><strong>多部门协同管理</strong>：支持销售、市场、研发、售后等部门协同工作，提高跨部门协作效率。</li><li><strong>数据分析与洞察</strong>：提供客户行为分析、销售趋势预测、潜在客户挖掘等功能，辅助决策。</li><li><strong>合规与审计</strong>：满足医疗行业严格的合规要求，支持审计追踪和数据安全。</li></ul><h3>2.2 功能拆解与适用性分析</h3><h4>2.2.1 客户信息管理</h4><ul><li><strong>客户画像</strong>：支持按医院、科室、医生等维度建立客户档案，提升精准营销能力。</li><li><strong>沟通记录</strong>：记录客户沟通内容、沟通时间、沟通方式等，便于后续跟进与服务。</li><li><strong>合同管理</strong>：支持合同签订、履约跟踪、付款记录，确保合同执行透明化。</li></ul><h4>2.2.2 销售流程自动化</h4><ul><li><strong>线索管理</strong>：自动识别潜在客户，推送至销售团队。</li><li><strong>商机跟踪</strong>：支持商机状态更新、责任人分配，确保销售进度可视化。</li><li><strong>销售流程</strong>：从需求分析、方案推荐、合同签订到售后服务，全流程自动化，减少人工干预。</li></ul><h4>2.2.3 多部门协同</h4><ul><li><strong>销售与市场协同</strong>：支持销售团队与市场团队同步客户信息，提升营销效率。</li><li><strong>研发与销售协同</strong>：研发团队可根据销售反馈优化产品，提升产品竞争力。</li><li><strong>售后与客户协同</strong>：售后团队可实时反馈客户使用问题，提升客户满意度。</li></ul><h4>2.2.4 数据分析与洞察</h4><ul><li><strong>客户行为分析</strong>：分析客户购买偏好、使用频次、售后服务反馈等，辅助精准营销。</li><li><strong>销售趋势预测</strong>：基于历史数据预测销售趋势，优化资源配置。</li><li><strong>潜在客户挖掘</strong>：基于客户画像与行为数据，识别潜在客户，提升获客效率。</li></ul><h4>2.2.5 合规与安全</h4><ul><li><strong>医疗行业合规</strong>：符合国家医疗行业数据安全与隐私保护的相关法规。</li><li><strong>审计追踪</strong>：支持全流程审计，确保数据真实、可追溯。</li></ul><hr/><h2>三、选对CRM的四个关键要素</h2><h3>3.1 功能全面性</h3><ul><li>确保CRM覆盖客户管理、销售、售后、数据分析等核心模块，满足医疗行业的复杂需求。</li></ul><h3>3.2 可扩展性</h3><ul><li>系统需具备良好的可扩展性，以适应企业业务增长与功能升级。</li></ul><h3>3.3 安全与合规</h3><ul><li>保障客户数据安全，符合医疗行业的合规要求，减少法律风险。</li></ul><h3>3.4 用户友好性</h3><ul><li>系统界面简洁直观，操作便捷，提升用户使用效率。</li></ul><hr/><h2>四、结语：2025年眼科设备制造厂商的CRM战略</h2><p>在2025年，眼科设备制造厂商的客户关系管理不仅是提升销售效率的工具，更是企业实现长期发展的核心驱动。选择一款合适的CRM系统，可以帮助企业更高效地管理客户、优化销售流程、提升客户满意度，并在激烈的市场竞争中脱颖而出。</p>]]></description></item><item>    <title><![CDATA[【Github热门项目】DeepSeek]]></title>    <link>https://segmentfault.com/a/1190000047399607</link>    <guid>https://segmentfault.com/a/1190000047399607</guid>    <pubDate>2025-11-14 15:09:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>【Github热门项目】DeepSeek-OCR项目上线即突破7k+星！突破10倍无损压缩，重新定义文本-视觉信息处理</h2><p>当“8000行代码手搓ChatGPT”的热度还未褪去，大模型领域又迎来新惊喜——DeepSeek团队于10月20日开源的 <strong>DeepSeek-OCR</strong>，以“<strong>上下文光学压缩</strong>”为核心突破，重新定义了OCR（光学字符识别）的效率边界。这款仅30亿参数量的模型，不仅能以100个视觉token超越传统模型256个token的性能，更在单张A100-40G显卡上实现每日20万页文档处理能力，为长文本压缩与大模型效率优化提供了全新思路。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399609" alt=" " title=" "/></p><p><strong>论文标题：DeepSeek-OCR:ContextsOpticalCompression</strong></p><p><a href="https://link.segmentfault.com/?enc=niPupz46Z81WfpfrTP9WlA%3D%3D.wEl5InJ2%2FVZi1BhRCvtxHyTyW6UvuirSyGGpg1m%2BZvurhAb63jVvzsMAayb4Fz43" rel="nofollow" target="_blank">👉原项目地址</a></p><p><a href="https://link.segmentfault.com/?enc=fLDBqydgJhGErX2GAXPgmg%3D%3D.J3NN1Irst42Vf%2B3uNu4A12Rhfsfy7guMLfW8bI4Xj5P%2FLZrYNAKUVrd4107oBQMHVEN1mgVzSIFgUOW9FhehHHXwtxdcGjvwLWnIimLoyn4%3D" rel="nofollow" target="_blank">👉Github论文</a></p><p><a href="https://link.segmentfault.com/?enc=rWWJ15WIxMOEhZDfGVEndw%3D%3D.r1zU3%2FFklQD4eEyaDShB603nYGx20Ek9W%2BP0l4eOeNbgvjpkl9SLBzBCj1nYhmFv" rel="nofollow" target="_blank">👉HuggingFace</a></p><p><a href="https://link.segmentfault.com/?enc=8b6b9GdR70jec9BUeU4yXw%3D%3D.OIaSgCApoFoxC4aqwwyNRrgbG9n0qBni1ZQkKBIWVAlC8lXnwgJTMtedpXf%2FjjmXpG9L155Rj0OM2rM0ek1%2FtPwmpUyDuLh8UTCJYnjj7sU8jtMSfFlZLmVzzi4cQ8mrq6%2Fd2b0H32bbsub1nDZCiVIoAt2RSgrX1kSVKTWY%2Foc%3D" rel="nofollow" target="_blank">👉Lab4AI</a></p><p>DeepSeek-OCR的核心创新在于利用视觉模态作为文本信息的高效压缩媒介。研究表明，一张包含文档文本的图像可以用比等效文本少得多的Token来表示丰富信息，这意味着通过视觉Token进行光学压缩可以实现极高的压缩率。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399610" alt=" " title=" " loading="lazy"/></p><p>其核心表现可概括为<strong>两组关键数据</strong>：</p><ul><li><strong>压缩比与精度</strong>的平衡：当文本token数量是视觉token的10倍以内（即压缩比＜10×）时，OCR解码精度高达97%；即便压缩比提升至20×，精度仍能维持在60%左右，远超行业同类模型的衰减速度。</li><li><strong>极致的token</strong>效率：在OmniDocBench基准测试中，它仅用100个视觉token就超越了需256个token的GOT-OCR2.0；面对MinerU2.0平均每页6000+token的消耗，它用不到800个token就能实现更优性能——相当于将文本处理的“token成本”降低了7-20倍。</li></ul><p>这种突破的价值不仅在于OCR本身：对于受限于“长上下文处理能力”的大模型而言，DeepSeek-OCR提供了一种新解法——<strong>将超长文本转化为视觉图像后压缩输入，可大幅减少LLM的token消耗，为处理百万字级文档、历史上下文记忆等场景打开了通道</strong>。</p><h3>DeepEncoder：编码器+MoE解码器</h3><p>为实现“高压缩比、低资源消耗”的目标，DeepSeek-OCR采用了“DeepEncoder（编码器）+DeepSeek3B-MoE（解码器）”的端到端架构，两者各司其职又高度协同。</p><h4>1. DeepEncoder</h4><p>作为模型的“压缩核心”，DeepEncoder需同时满足“<strong>高分辨率处理、低激活开销、少token输出</strong>”三大需求，其架构设计暗藏巧思：</p><ul><li>双组件串联：由8000万参数的<strong>SAM-base（视觉感知）</strong>和3亿参数的<strong>CLIP-large（视觉知识）</strong>串联而成。SAM-base用“窗口注意力”处理高分辨率图像细节，CLIP-large用“全局注意力”提取语义关联，兼顾精度与全局理解。</li><li>16倍token压缩：在双组件之间，通过<strong>2层卷积模块</strong>对视觉token进行16倍下采样。例如，1024×1024的图像先被划分为4096个patchtoken，经压缩后仅保留256个有效token，既控制了内存消耗，又不丢失关键信息。</li><li>多分辨率适配：支持Tiny（512×512）、Small（640×640）、Base（1024×1024）、Large（1280×1280）四种原生分辨率。还能通过“Gundam模式”实现超高分辨率输入（如报纸图像）的瓦片化处理，单个模型即可覆盖从手机截图到大幅文档的全场景需求。</li></ul><h4>2. DeepSeek3B-MoE</h4><p>解码器采用<strong>混合专家（MoE）架构</strong>，在“性能与效率”间找到了平衡点：</p><ul><li>参数激活策略：虽然总参数量为3B，但推理时仅激活64个“路由专家”中的6个，外加2个“共享专家”，实际参与计算的参数仅5.7亿——相当于用“500M模型的资源消耗”，获得了3B模型的表达能力。</li><li>快速文本重建：从DeepEncoder输出的压缩视觉token中，解码器能精准重建原始文本，甚至支持markdown格式转换、图表结构化提取等复杂任务，无需额外的后处理模块。</li></ul><h3>性能表现</h3><p>实验数据令人印象深刻：当文本Token数量在视觉Token的10倍以内（压缩率&lt;10×）时，模型的解码精度可达97%；即使在压缩率达到20×的情况下，OCR准确率仍保持在约60%。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399611" alt=" " title=" " loading="lazy"/></p><p>在实际应用层面，DeepSeek-OCR展现出惊人效率：在OmniDocBench基准测试中，仅使用<strong>100个视觉Token就超过了GOT-OCR2.0</strong>（每页256个Token）的表现；使用<strong>不到800个视觉Token就优于MinerU2.0</strong>（平均每页超过6000个Token）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399612" alt=" " title=" " loading="lazy"/></p><h3>大模型实验室Lab4AI</h3><p>值得一提的是，大模型技术社区「大模型实验室Lab4AI」已经第一时间上架了 <strong>DeepSeek-OCR论文及相关技术资料</strong>。该社区的技术团队正在积极复现论文中的创新方法，验证其在实际场景中的表现。大模型实验室作为专注于AI前沿技术的内容社区，将持续跟踪DeepSeek-OCR的最新进展，并<strong>分享更多实践案例和技术分析</strong>。欢迎各位开发者关注社区动态，共同探索这一创新技术的更多应用可能。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399613" alt=" " title=" " loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[CRM/ERP “内控 + 外联” 全业]]></title>    <link>https://segmentfault.com/a/1190000047399626</link>    <guid>https://segmentfault.com/a/1190000047399626</guid>    <pubDate>2025-11-14 15:08:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3>供应链与客户生命周期绑定能力横评：超兔、Salesforce、钉钉、用友、SAP的核心差异与场景适配</h3><p>在数字化转型的深水区，企业的核心竞争力已从“单一环节效率”转向“全链路协同能力”——<strong>立足上下游协同体系，打通“内控+外联”业务链路，最终实现供应链与客户生命周期的深度绑定</strong>，成为企业应对不确定性的关键。</p><p>本文选取<strong>超兔、Salesforce、钉钉、用友、</strong> <strong>SAP</strong>五大主流厂商，围绕三大核心维度展开横向对比：</p><ol><li><strong>上下游协同体系的构建能力</strong>（连接供应商、企业、客户的效率与深度）；</li><li><strong>“内控+外联”全业务链路的打通能力</strong>（内部流程自动化与外部生态集成的闭环）；</li><li><strong>供应链与客户生命周期的绑定能力</strong>（需求响应速度、数据联动深度、AI决策支持）。</li></ol><h2>一、对比框架与核心指标说明</h2><p>为确保对比的专业性与针对性，我们构建了“<strong>3大维度+9项细分指标</strong>”的评估体系（见表1），覆盖“连接-打通-绑定”的全流程价值。</p><table><thead><tr><th><strong>一级维度</strong></th><th><strong>二级细分指标</strong></th></tr></thead><tbody><tr><td>上下游协同体系</td><td>1. 协同场景覆盖（供应商/客户/产业链）；2. 数据打通深度（系统/流程/权限）；3. 生态兼容性（第三方系统对接）</td></tr><tr><td>“内控+外联”链路打通</td><td>1. 内部流程自动化（销售/生产/财务）；2. 外部系统集成（ERP/WMS/电商）；3. 数据一致性（跨系统同步率）</td></tr><tr><td>供应链与客户生命周期绑定</td><td>1. 需求响应速度（订单-履约周期）；2. 全生命周期数据联动（客户-供应链数据打通）；3. AI驱动决策（预测/优化）</td></tr></tbody></table><h2>二、各维度横向对比与深度分析</h2><h3>（一）上下游协同体系：从“信息传递”到“业务共生”的能力差异</h3><p>上下游协同的核心是<strong>打破企业边界，让供应商/客户成为业务流程的参与者</strong>，而非“信息接收方”。五大厂商的能力差异集中在“协同场景的覆盖深度”与“数据权限的精细化管理”。</p><h4>1. 超兔：OpenCRM驱动的“伙伴共生平台”</h4><p>超兔的核心是“OpenCRM业务伙伴共生平台”，直接连接企业内部CRM与上下游伙伴的业务系统，实现“询价-采购-发货-对账-售后”的全流程协同：</p><ul><li><strong>上游协同</strong>：企业通过OpenCRM向供应商发送询价请求，供应商实时响应报价；系统自动匹配历史供应商、比价生成采购单，并通过“供应商评级”（交货及时率/良品率）优化合作；</li><li><strong>下游协同</strong>：客户可在线确认报价/订单，扫码查看物流进度，验收后自动触发对账；</li><li><strong>核心优势</strong>：<strong>三流合一对账</strong>（货/款/票一致性）与<strong>全程追溯</strong>（业务节点可回溯），解决了中小制造企业“供应商分散、对账混乱”的痛点。</li><li><strong>案例</strong>：某机械制造企业通过超兔OpenCRM连接120家供应商，采购周期从15天缩短至7天，对账误差率从8%降至0.5%。</li></ul><h4>2. Salesforce：全球化生态的“Customer 360”</h4><p>作为全球CRM龙头，Salesforce的协同能力聚焦“全球化跨系统整合”：</p><ul><li><strong>核心载体</strong>：Customer 360平台整合销售、服务、营销模块，提供统一客户视图；通过<strong>AppExchange开放生态</strong>（超6000款第三方应用）对接SAP、Oracle等ERP系统，实现“总部-区域-供应商-客户”的全球数据同步；</li><li><strong>差异化能力</strong>：<strong>本地化与合规适配</strong>（支持多语言/多时区/GDPR），解决跨国企业“数据割裂、合规风险”的问题；</li><li><strong>案例</strong>：某跨国车企通过Salesforce连接全球500家供应商，售后问题解决周期从72小时缩短至24小时，全球供应链数据同步率达99%。</li></ul><h4>3. 钉钉：群场景下的“轻量级产业链协同”</h4><p>钉钉的协同能力基于“群+业务组件”，将采购、配货等业务流迁移至群内，降低跨组织协作门槛：</p><ul><li><strong>核心场景</strong>：通过“供应商群”实现“一点配货调货”（如一汽大众连接上千家供应商，群内实时同步生产排期）；通过“宜搭低代码平台”让供应商自建MES系统，确保供应链数据实时同步；</li><li><strong>优势</strong>：<strong>轻量化与易用性</strong>，适合产业链环节多、协作方IT能力弱的企业（如制造业、零售）；</li><li><strong>局限</strong>：深度协同需依赖低代码二次开发，对复杂业务的支撑能力不足。</li></ul><h4>4. 用友：B2B全链路的“供应商-经销商协同”</h4><p>用友的协同能力聚焦“B2B供应链闭环”：</p><ul><li><strong>上游</strong>：通过“电子采购门户”发布需求，管理寻源与采购执行；支持供应商评估、合同管理，建立长期合作关系；</li><li><strong>下游</strong>：通过“电子销售管理”整合经销商网络，实现自动化分销与服务管理；</li><li><strong>核心优势</strong>：<strong>与财务系统深度集成</strong>（如U8+的财务-供应链一体化），解决“业务与财务数据割裂”的问题；</li><li><strong>案例</strong>：某消费品企业通过用友U8+连接200家经销商，分销订单处理效率提升60%，库存周转率提升35%。</li></ul><h4>5. SAP：端到端的“供应商全生命周期管理”</h4><p>SAP的协同能力以“供应商全生命周期”为核心：</p><ul><li><strong>核心流程</strong>：从供应商准入（资质审核）、寻源（在线询比价）、合作（订单执行）到绩效监控（交付率/良品率），实现全流程数字化；</li><li><strong>差异化能力</strong>：<strong>合规风控机制</strong>（贸易合规检查、黑白名单校验），提升供应链韧性；</li><li><strong>案例</strong>：通达创智通过SAP构建“智能制造平台”，连接海外生产基地与全球供应商，供应链交付达成率从85%提升至98%。</li></ul><h4>上下游协同能力对比表（表2）</h4><table><thead><tr><th><strong>品牌</strong></th><th>协同场景覆盖</th><th>数据打通深度</th><th>生态兼容性</th></tr></thead><tbody><tr><td>超兔</td><td>供应商-客户全流程</td><td>三流合一（货/款/票）</td><td>支持RPA/ERP对接</td></tr><tr><td>Salesforce</td><td>全球化跨系统</td><td>统一客户视图</td><td>AppExchange生态</td></tr><tr><td>钉钉</td><td>产业链群协同</td><td>群内业务组件</td><td>宜搭低代码扩展</td></tr><tr><td>用友</td><td>B2B端到端</td><td>财务-供应链一体化</td><td>U8+/YonSuite生态</td></tr><tr><td>SAP</td><td>供应商全生命周期</td><td>端到端系统集成</td><td>ERP/SRM/SCM整合</td></tr></tbody></table><h3>（二）“内控+外联”链路打通：从“信息孤岛”到“全流程闭环”的效率差异</h3><p>“内控+外联”的核心是<strong>消除内部部门墙与外部系统壁垒</strong>，实现“获客-转化-履约-复购”的全流程数据闭环。五大厂商的差异集中在“内部流程自动化程度”与“外部系统集成的便捷性”。</p><h4>1. 超兔：全业务一体云的“底层数据打通”</h4><p>超兔的“全业务一体云”涵盖CRM、进销存、生产工单、财务等模块，实现<strong>内部流程的“无代码联动”</strong> ：</p><ul><li><strong>内控自动化</strong>：订单录入后自动拆解BOM清单，同步库存模块检查原材料缺口，触发智能采购计划；生产工单通过手机扫码完成领料、报工、入库，数据自动沉淀为“生产资产”（工时/良品率）；</li><li><strong>外联集成</strong>：通过RPA对接电商平台（如淘宝/京东）、国税开票机器人，实现订单自动同步；</li><li><strong>核心优势</strong>：<strong>全链路数据一致性</strong>（跨模块数据同步率100%），解决了中小企“跨部门人工核对”的痛点。</li></ul><h4>2. Salesforce：AI驱动的“流程自动化”</h4><p>Salesforce通过<strong>Sales Cloud+Service Cloud+Einstein</strong> <strong>GPT</strong>实现内部流程的“智能自动化”：</p><ul><li><strong>内控自动化</strong>：Einstein GPT自动生成销售话术、预测客户需求（如“客户A下周可能下单”）；Service Cloud自动分配售后工单，根据客户价值优先处理；</li><li><strong>外联集成</strong>：通过AppExchange对接ERP（如SAP）、WMS（如Oracle），实现订单-库存-物流的实时同步；</li><li><strong>核心优势</strong>：<strong>AI</strong> <strong>对流程的“预测性优化”</strong> ，而非“被动执行”。</li></ul><h4>3. 钉钉：低代码驱动的“内部协同”</h4><p>钉钉的“内控+外联”能力基于<strong>宜搭</strong> <strong>低代码</strong> <strong>平台</strong>：</p><ul><li><strong>内控自动化</strong>：通过宜搭搭建“销售订单-库存-财务”流程，自动触发库存检查与财务记账；</li><li><strong>外联集成</strong>：通过“群机器人”对接外部系统（如快递100查物流），实现信息实时推送；</li><li><strong>优势</strong>：<strong>快速部署</strong>（低代码无需IT开发），适合流程灵活的中小企业；</li><li><strong>局限</strong>：复杂流程（如生产排程）需依赖第三方系统。</li></ul><h4>4. 用友：财务-供应链的“强集成”</h4><p>用友的“内控+外联”聚焦“财务与供应链的一体化”：</p><ul><li><strong>内控自动化</strong>：U8+的“财务-供应链”模块实现“发货后自动生成应收账单”，支持多期回款自动拆分；</li><li><strong>外联集成</strong>：对接B2B订货平台（如友商网）、新零售系统（如天猫超市），实现订单自动同步；</li><li><strong>核心优势</strong>：<strong>财务业务联动</strong>，解决“财务数据滞后于业务”的问题。</li></ul><h4>5. SAP：端到端的“系统整合”</h4><p>SAP通过<strong>SAP Business Suite</strong>整合ERP、CRM、SRM、SCM等系统，实现“内控+外联”的全链路打通：</p><ul><li><strong>内控自动化</strong>：有限产能高级排程（APS）平衡设备/人员/物料，生成最优生产计划；</li><li><strong>外联集成</strong>：通过SAP BTP的CPI解决方案对接外部系统（如电商平台、物流商），实现数据实时同步；</li><li><strong>核心优势</strong>：<strong>全链路可视化</strong>（供应链控制塔实时监控履约状态），适合大型企业的复杂流程。</li></ul><h4>“内控+外联”链路流程图</h4><p>以下是超兔与SAP的流程对比（以“订单履约”为例）：</p><p><strong>超兔的“内控+外联”流程</strong>：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399628" alt="" title=""/></p><pre><code>sequenceDiagram
    participant 客户 as 客户
    participant 超兔CRM as 超兔CRM
    participant 库存模块 as 库存模块
    participant 采购模块 as 采购模块
    participant 供应商 as 供应商
    participant 财务模块 as 财务模块

    客户-&gt;&gt;超兔CRM: 下达订单
    超兔CRM-&gt;&gt;库存模块: 检查库存
    库存模块-&gt;&gt;超兔CRM: 库存不足
    超兔CRM-&gt;&gt;采购模块: 触发智能采购（匹配历史供应商）
    采购模块-&gt;&gt;供应商: 发送采购请求
    供应商-&gt;&gt;客户: 直接发货（供应商直发）
    客户-&gt;&gt;超兔CRM: 确认收货
    超兔CRM-&gt;&gt;财务模块: 生成应收账单</code></pre><p><strong>SAP</strong> <strong>的“内控+外联”流程</strong>：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399629" alt="" title="" loading="lazy"/></p><pre><code>sequenceDiagram
    participant 客户 as 客户
    participant SAP CRM as SAP CRM
    participant SAP SCM as SAP SCM
    participant SAP ERP as SAP ERP
    participant 供应商 as 供应商
    participant 物流商 as 物流商

    客户-&gt;&gt;SAP CRM: 下达订单
    SAP CRM-&gt;&gt;SAP SCM: 需求传递
    SAP SCM-&gt;&gt;SAP ERP: 检查库存/产能
    SAP ERP-&gt;&gt;供应商: 发送采购订单
    供应商-&gt;&gt;物流商: 发货
    物流商-&gt;&gt;客户: 配送
    客户-&gt;&gt;SAP CRM: 确认收货
    SAP CRM-&gt;&gt;SAP ERP: 生成发票</code></pre><h3>（三）供应链与客户生命周期绑定：从“被动响应”到“主动预测”的价值差异</h3><p>供应链与客户生命周期绑定的核心是“客户需求驱动供应链响应”，而非“供应链计划主导客户需求”。五大厂商的差异集中在“需求预测的准确性”与“全生命周期数据的联动深度”。</p><h4>1. 超兔：客户需求触发的“智能供应链”</h4><p>超兔通过“客户订单-供应链响应”的动态联动，实现“按需履约”：</p><ul><li><strong>需求响应</strong>：供应商直发的采购单执行过程是供应商根据采购单，直接发货给客户，省略了发货给我方的环节，在电商领域或大型设备贸易领域使用较多。</li><li><strong>数据联动</strong>：客户历史订单（如“客户A每年3月采购100台设备”）自动同步至供应链模块，提前安排生产/采购；</li><li><strong>案例</strong>：某电子企业通过超兔“供应商直发”模式，客户复购率从30%提升至55%。</li></ul><h4>2. Salesforce：AI预测的“动态匹配”</h4><p>Salesforce的<strong>Einstein</strong> <strong>AI</strong>通过分析客户行为（如浏览记录、售后反馈），预测客户需求：</p><ul><li><strong>需求预测</strong>：Einstein AI预测“客户B下个月可能采购50台电脑”，同步至供应链模块调整库存；</li><li><strong>数据联动</strong>：Customer 360平台整合客户“售前（营销触达）-售中（订单）-售后（报修）”数据，供应链模块实时获取“客户满意度”，优化后续履约策略；</li><li><strong>核心优势</strong>：<strong>AI</strong> <strong>对客户需求的“个性化预测”</strong> ，而非“批量预测”。</li></ul><h4>3. 钉钉：销售-库存-财务的“数据闭环”</h4><p>钉钉通过“销售-库存-财务”的数据打通，实现“客户需求的实时响应”：</p><ul><li><strong>需求响应</strong>：销售可查看客户历史订单与库存状态（如“客户C去年采购的100台设备，现在库存还有20台”），快速给出“现货/期货”报价；</li><li><strong>数据联动</strong>：财务直接调取合同签约记录，避免“客户已付款但财务未入账”的问题；</li><li><strong>优势</strong>：<strong>数据的“可见性”</strong> ，适合强调“快速响应”的零售企业。</li></ul><h4>4. 用友：CRM全生命周期的“营销供应链联动”</h4><p>用友通过<strong>CRM</strong> <strong>全生命周期管理</strong> <strong>+营销</strong> <strong>数智化</strong> <strong>服务</strong>，实现“客户需求与供应链的联动”：</p><ul><li><strong>需求响应</strong>：CRM系统识别“客户D处于‘流失预警’阶段”，自动推送“折扣券”，并同步供应链模块准备库存；</li><li><strong>数据联动</strong>：营销活动数据（如“双11促销带来1000个订单”）自动同步至供应链，调整生产计划；</li><li><strong>核心优势</strong>：<strong>营销与供应链的“双向驱动”</strong> （营销反哺供应链，供应链支撑营销）。</li></ul><h4>5. SAP：端到端的“需求排程”</h4><p>SAP通过“可承诺量（aATP）”实现“客户需求与供应链的动态匹配”：</p><ul><li><strong>需求响应</strong>：客户下单时，aATP实时计算“可用库存+未来产能”，给出准确交期（如“下周三可发货”）；</li><li><strong>数据联动</strong>：客户门户实时展示订单进度（如“已生产30%，明天发货”），售后工单自动关联产品BOM（如“客户E的设备故障，需更换零件X”）；</li><li><strong>核心优势</strong>：<strong>供应链的“承诺能力”</strong> ，适合对“交期准确性”要求高的制造业（如汽车/电子）。</li></ul><h4>供应链与客户生命周期绑定能力雷达图（表3）</h4><p>以下是各品牌在“需求响应速度、数据联动深度、AI决策能力”三项指标的评分（1-10分）：</p><table><thead><tr><th><strong>品牌</strong></th><th>需求响应速度</th><th>数据联动深度</th><th>AI决策能力</th></tr></thead><tbody><tr><td>超兔</td><td>8</td><td>9</td><td>7</td></tr><tr><td>Salesforce</td><td>9</td><td>10</td><td>10</td></tr><tr><td>钉钉</td><td>7</td><td>8</td><td>6</td></tr><tr><td>用友</td><td>8</td><td>9</td><td>8</td></tr><tr><td>SAP</td><td>10</td><td>10</td><td>9</td></tr></tbody></table><h2>三、核心结论与选型建议</h2><h3>1. 各品牌核心优势总结（脑图，Mermaid）</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399630" alt="" title="" loading="lazy"/></p><pre><code>mindmap
    root((供应链与客户生命周期绑定能力))
        超兔
            OpenCRM伙伴共生
            全业务一体云
            供应商直发
        Salesforce
            Customer 360全球整合
            Einstein AI预测
            AppExchange生态
        钉钉
            群+业务组件
            宜搭低代码
            产业链协同
        用友
            B2B供应链闭环
            财务-供应链一体化
            CRM全生命周期
        SAP
            供应商全生命周期
            aATP可承诺量
            端到端系统集成</code></pre><h3>2. 场景适配建议</h3><ul><li><strong>中小制造企业</strong>：优先选择<strong>超兔</strong>（全业务一体云+OpenCRM，快速实现“内控+外联”闭环，成本低）；</li><li><strong>跨国企业</strong>：优先选择<strong>Salesforce</strong>（全球化生态+AI预测，解决“多区域数据割裂”问题）；</li><li><strong>产业链协同企业</strong>：优先选择<strong>钉钉</strong>（群+低代码，快速连接上下游，易用性高）；</li><li><strong>中型成长企业</strong>：优先选择<strong>用友</strong>（财务-供应链一体化，支持产供销、业财税协同，满足企业发展过程中的精细化管理需求）；</li><li><strong>大型制造企业</strong>：优先选择<strong>SAP</strong>（端到端系统集成、供应商全生命周期管理和可承诺量（aATP）等功能，保障复杂供应链环境下的稳定交付与高效运营）。</li></ul><p>企业在进行数字化转型、选择供应链与客户生命周期绑定解决方案时，应充分考量自身的业务特点、发展阶段、规模大小和战略目标等因素，从超兔、Salesforce、钉钉、用友、SAP等厂商中挑选最契合自身需求的方案，以实现供应链与客户生命周期的深度绑定，提升企业的核心竞争力和市场适应能力，在激烈的市场竞争中赢得优势。</p><h2>四、功能详情</h2><h3>Salesforce相关能力</h3><h4><strong>一、立足上下游协同的体系能力</strong></h4><ol><li><strong>全球化跨系统数据整合</strong>：基于<strong>Customer 360平台</strong>，整合销售、服务、营销等核心模块，提供统一客户视图，支持跨国企业打通全球58个业务系统数据（如ERP、MES、供应链管理系统），实现总部对各区域<strong>销售动态、库存状态及客户需求的</strong> <strong>实时监控</strong>。</li><li><strong>外部生态协同闭环</strong>：通过<strong>AppExchange开放平台</strong>整合超6000款第三方应用，可与SAP、Oracle等ERP系统及主流电商平台无缝对接，构建“客户-经销商-供应商”全链路外联协同，例如某跨国车企通过该功能将售后问题解决周期从72小时缩短至24小时。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399631" alt="" title="" loading="lazy"/></p><ol start="3"><li><strong>本地化与合规适配</strong>：支持<strong>多语言、多时区部署</strong>，适配GDPR、CCPA等全球数据合规要求，满足跨国企业在不同地区的供应链数据管理规范。</li></ol><h4><strong>二、打通“内控+外联”的全业务链路能力</strong></h4><ol start="4"><li><strong>内部流程自动化提效</strong>：通过<strong>销售云（Sales Cloud）、服务云（Service Cloud）实现线索培育、商机管理、工单处理</strong>等全流程自动化；结合Einstein GPT（AI智能体）自动生成销售话术、预测客户需求，减少内部协作成本，提升流程效率。</li><li><strong>内外系统无缝衔接</strong>：一方面整合内部销售、服务、营销等模块数据，另一方面通过AppExchange与外部供应链、电商、财务系统对接，实现“内控（内部流程）+外联（外部生态）”的全链路打通，消除信息孤岛。</li></ol><h4><strong>三、供应链与客户生命周期深度绑定的能力</strong></h4><ol start="6"><li><strong>AI</strong> <strong>驱动的供需动态匹配</strong>：<strong>Einstein AI</strong>分析客户行为轨迹（如浏览、购买、服务记录），预测各地区产品需求差异，帮助企业优化<strong>库存分配、生产计划</strong>，实现供应链与客户订单的动态匹配，减少库存积压或缺货风险。</li><li><strong>全生命周期数据协同</strong>：从售前营销触达（营销云）、售中商机转化（销售云）到售后客户留存（服务云），通过<strong>Tableau</strong> <strong>BI</strong> <strong>工具</strong>构建定制化数据看板，实时展示<strong>客户转化率、</strong> <strong>供应链协同</strong> <strong>效率、客户满意度</strong>等核心指标，支持管理层科学决策（如某500强企业通过该功能实现全球销售数据实时可视化，提升跨区域响应速度）。</li><li><strong>全链路客户</strong> <strong>闭环管理</strong>：整合销售云、服务云、营销云及Commerce Cloud，实现“获客-转化-留存-复购”全客户生命周期闭环，将供应链的“生产-配送-服务”环节与客户的“需求-购买-反馈”环节深度绑定，提升客户忠诚度与供应链效率。</li></ol><h4><strong>补充说明</strong></h4><ul><li>Salesforce作为全球CRM龙头（全球市场份额超20%），功能覆盖销售、营销、客服全场景；</li><li>核心优势包括AI能力领先（如Einstein GPT自动写邮件、预测需求）、全链路销售管理、电话外呼集成等。</li></ul><h3>SAP立足上下游协同体系，打通“内控+外联”全业务链路的相关能力</h3><h4><strong>一、供应链内控能力：计划、执行与协同一体化</strong></h4><p><strong>智能需求与库存管理</strong>：融合历史数据与市场信号，自动生成需求预测、安全库存及替代料策略，异常情况可预警；实现在制、在途、跨仓库存统一看板管理，联动呆滞料与缺料风险，提升库存周转率与交付达成率。</p><p><strong>精准排程与交付承诺</strong>：平衡设备、人员、物料等产能约束，通过“可承诺量（aATP）”实时给出订单交期；若出现异常（如物料延迟），系统自动重排计划，保障交付稳定性。</p><p><strong>全链路可视化</strong>：覆盖从产品设计、生产制造到物流运维的全供应链链条，提供实时数据看板，确保各环节信息透明可追溯。</p><h4><strong>二、客户生命周期外联能力：全流程数字化服务</strong></h4><p><strong>客户自助与售后管理</strong>：搭建客户门户，支持自助报修、进度查询；结合工单派发、移动端签到、SLA计费等功能，实现售后流程标准化，且售后收入可量化统计。</p><p><strong>AI</strong> <strong>驱动的客户洞察</strong>：通过自然语言处理（NLP）快速调取客户全维度数据，构建360°客户画像；预测销售机会转化率，优化赢单策略与利润结构。</p><p><strong>全渠道旅程协同</strong>：整合官网、门店、社交媒体等触点，动态编排客户旅程（如金融行业嵌入合规审查、医疗行业关联电子病历）；打通销售、供应链、财务等模块，实现订单状态实时同步、库存数据与客户需求联动，避免信息差。</p><h4><strong>三、上下游协同体系：供应链与客户链路深度绑定</strong></h4><p><strong>供应商</strong> <strong>全生命周期管理</strong>：从供应商准入、评级到绩效监控全流程覆盖，支持集中寻源、在线询比价；内置合规风控机制（如贸易合规检查、黑白名单校验），增强供应链韧性。</p><p><strong>端到端</strong> <strong>数据集成</strong>：通过SAP Business Suite等解决方案，整合ERP（企业资源规划）、CRM（客户关系管理）、SRM（供应商关系管理）、PLM（产品生命周期管理）、SCM（供应链管理）等系统，实现从产品创意、研发、生产到交付、售后的全流程优化；连接内外部应用与数据源（如通过SAP BTP的CPI解决方案），打通信息壁垒，保障业务协同。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399632" alt="" title="" loading="lazy"/></p><h4><strong>四、价值成果</strong></h4><ul><li><strong>供应链端</strong>：交付达成率改善，呆滞料与缺料风险降低，采购成本优化，供应链韧性提升。</li><li><strong>客户端</strong>：售后收入增长，客户满意度与复购率提升，赢单效率优化。</li><li><strong>协同层面</strong>：实现“计划即事实”的供应链响应与客户需求实时联动，支撑全球化业务的合规运营与快速响应（如帮助通达创智构建“创智智能制造平台”，提升海外生产基地与全球供应链的韧性）。</li></ul><h3>钉钉立足上下游协同体系的核心能力（基于“内控+外联”全业务链路）</h3><h4><strong>一、跨组织协同场景落地：连接产业链与客户生命周期</strong></h4><p><strong>产业链协同</strong>：通过“群”植入业务组件，将采购、配货等业务流迁移至群内，降低跨组织协作门槛。例如：</p><p>  一汽大众通过钉钉群连接上千家供应商，实现“一点配货调货”；推动供应商使用钉钉低代码平台（宜搭）自建MES系统，确保供应链数据实时同步。</p><p>  集成电路企业利用钉钉实现全国供应链物流中心项目协同，通过甘特图、任务看板跟踪进度，沉淀项目经验。</p><p><strong>客户生命周期管理</strong>：打通销售、库存、财务数据链路，实现从客户对接、订单履约到售后的全流程数据闭环。例如：</p><p>  销售可查看客户历史订单与库存状态，财务直接调取合同签约记录，避免信息割裂。</p><h4><strong>二、数据与系统层深度打通：实现“内控一体化+外联扩展”</strong></h4><ol><li><strong>内控一体化</strong>：通过“钉钉宜搭”低代码平台自定义审批、项目管理等流程，自动关联考勤、文档等内部数据；打通企业所有应用（含生态ISV应用、自研系统），支持“一个账号看全局”，实现人、事、系统的高效连接。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399633" alt="" title="" loading="lazy"/></p><ol start="2"><li><strong>外联扩展能力</strong>：开放API接口（数量超2000个），与用友、金蝶等ERP系统及超兔等垂直SaaS深度对接，形成“协同+业务”闭环；同时支持与供应链上下游系统（如PLM、项目管理系统）集成，提升供需匹配效率。</li></ol><h4><strong>三、安全与效率双重保障：支撑全链路协同的可靠性</strong></h4><p><strong>安全共享机制</strong>：</p><p>  通过钉盘、场景群权限管理，保障上下游文件共享、音视频会议的安全性；采用<strong>SM4国密算法</strong>进行数据加密（传输与存储），通过ISO27001、ISO27018等国际认证，达到金融级数据安全标准。</p><p>  离职员工账号秒级冻结、截屏自动嵌入溯源水印，防止敏感信息泄露。</p><p><strong>AI</strong> <strong>与</strong> <strong>低代码</strong> <strong>赋能效率</strong>：</p><p>  结合AI能力优化供应链监控（如产线设备状态、质量追溯）和客户服务流程；通过低代码平台，企业可快速搭建适配自身业务的供应链管理工具，加速数字化落地。</p><h4><strong>四、生态化服务扩展：推动全链路绑定的闭环</strong></h4><p>推出“钉选”企业服务聚合平台，汇聚SaaS应用、采购、差旅等板块，为企业提供一站式服务；从产业链龙头企业切入，以点带面推动上下游企业数字化转型，实现供应链与客户生命周期的全链路绑定。</p><h3>超兔品牌相关能力总结（基于上下游协同、“内控+外联”链路及供应链与客户生命周期绑定）</h3><h4><strong>一、立足上下游协同体系的核心能力</strong></h4><p>超兔通过<strong>独创的OpenCRM体系</strong>，构建“供应商-企业-客户”的共生协同网络，实现上下游数据互通与业务参与：</p><ol><li><strong>供应商协同</strong>：支持采购需求自动同步、供应商在线报价比价、质量标准分享，及根据“交货及时率、良品率”对供应商评级；</li><li><strong>客户协同</strong>：客户可实时查看订单进度、验收后自动触发对账流程；</li><li><strong>应用场景</strong>：机械制造企业将采购单直接推送至供应商系统，同步生产排期与交货要求，协作效率提升50%，采购周期缩短40%。</li></ol><h4><strong>二、打通“内控+外联”全业务链路的能力</strong></h4><p>依托“全业务一体云”架构，超兔实现CRM、进销存、生产工单、财务、上下游协同等模块的<strong>全业务数据底层连通</strong>，覆盖从“市场获客→客户管理→跟单转化→订单履约→财务结算→复购”的全流程闭环：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399634" alt="" title="" loading="lazy"/></p><p><strong>内控端（企业内部流程）</strong> ：</p><p>  销售端：订单录入后自动拆解BOM清单，同步库存模块检查原材料缺口，触发智能采购计划；</p><p>  生产端：工单与MES系统联动，通过手机扫码完成领料、报工、入库，数据自动沉淀为生产资产（工时、良品率）；</p><p>  财务端：发货后同步生成应收账单，支持多期回款自动拆分，避免跨系统人工操作。</p><p><strong>外联端（外部协作）</strong> ：</p><p>  多渠道集客：整合市场获客工具（如线上广告、社交裂变），实现线索自动进入CRM系统；</p><p>  客户参与：通过OpenCRM让客户参与业务流程（如扫码验收、查看进度）。</p><ol><li><strong>效率提升</strong>：整体交付效率提升60%，跨部门协同成本降低40%。</li></ol><h4><strong>三、实现供应链与客户生命周期深度绑定的能力</strong></h4><p>通过“客户需求-供应链响应”的<strong>动态联动</strong>，超兔将客户全生命周期价值与供应链效率双向优化：</p><p><strong>需求端（</strong> <strong>客户生命周期管理</strong> <strong>）</strong> ：</p><p>  全生命周期覆盖：从市场获客到客户服务的全链条管理，支持自动客池分配、客户公海管理，优化客户资源利用；</p><p>  高价值客户挖掘：通过RFM分析识别高价值客户，结合历史采购记录推送定制化套餐（如“买设备送配件”），老客户复购占比提升至52%。</p><p><strong>供应端（供应链适配客户需求）</strong> ：</p><p>  智能库存策略：基于客户订单波动智能调整库存，某机械企业通过系统预测补货，库存周转周期缩短25%，缺货风险下降35%；</p><p>  定制化履约：客户提出非标需求后，系统自动生成定制工单，同步触发特殊材质采购，供应商直接发货至生产基地，交付周期从15天缩短至7天。</p><h4><strong>总结</strong></h4><p>超兔的核心优势在于“全业务一体云”+“OpenCRM”的组合，通过数据底层连通与上下游协同，实现“内控提效”与“外联增值”的闭环，最终将客户生命周期价值与供应链效率深度绑定，帮助企业在“失控”中构建“自组织”的业务能量场。</p><h3>用友立足上下游协同体系的核心能力</h3><h3>一、上下游协同体系能力</h3><p><strong>全价值链端到端协同</strong>：用友YonSuite供应链管理覆盖从营销到服务的全价值链端到端协同，实现采购到支付、订单到收款、计划到履约的全链条智能化管理；供应链云与采购云、营销云、制造云、财务云等深度融合，覆盖大型企业供应链业务场景，支持产供销、业财税一体化，通过OpenAPI对接第三方服务实现业务闭环。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399635" alt="" title="" loading="lazy"/></p><p><strong>B2B</strong> <strong>供应链协同</strong> <strong>解决方案</strong>：针对上游供应商及下游渠道提供一体化方案，电子销售管理经销商分销网络，整合集团总部、制造企业、分销企业、经销商等资源，打造自动化分销及服务管理体系；电子采购通过供应商门户发布需求，管理寻源与采购执行，打破信息壁垒，提高采购效率、降低成本。</p><p><strong>U8+</strong> <strong>供应链协同</strong> <strong>模式</strong>：以供应链协同为核心，包括内部供应业务精细化管控（配合生产、库存等业务）与外部产业链协同（与供应商信息共享、业务协同），通过供应商门户、即时通讯、移动应用等实现与外部供应商的实时互动，提升采购效率。</p><p><strong>供应商协同管理</strong>：供应链系统通过与供应商的信息共享和业务协同，建立长期稳定合作关系；支持供应商评估、采购合同管理等功能，确保供应商质量与稳定性，提升供应链整体效益。</p><h3>二、“内控 + 外联”全业务链路打通能力</h3><p><strong>内部精细化管控</strong>：供应链系统支持批次号、序列号、保质期管理等多种物料管理需求，覆盖原材料仓库、资产仓库等多种库存存储属性，实现成本计量与物流模式下的无成本计量，强化库存管理、控制与分析；通过质量控制、及时性控制和业务领导关系，实现上下游业务匹配与企业所有权责任，配合内控审计确保业务文件权威、业务时间可追溯及内部效率评价。</p><p><strong>业务流程集成优化</strong>：供应链系统整合订购、库存、生产、物流等环节，实现企业内外部环节高效协同，降低信息传递与操作成本；与财务系统集成（如U8+的财务与供应链一体化），实现财务业务联动，提升管理效率与效益。</p><p><strong>全链路计划与履约</strong>：提供全链路计划协同（有限产能高级排程、仓储物流网络规划、产销储运协同）、供应链计划与控制塔等功能，实现履约经营实时可视，支撑从计划到履约的全流程管理；营销数智化服务（全渠道、全链路）与供应链联动，覆盖B2B订货、直分销CRM、营销活动与费用管理、新零售、会员管理等场景，实现业务全链路贯通。</p><h3>三、供应链与客户生命周期深度绑定能力</h3><p><strong>全程</strong> <strong>客户生命周期管理</strong>：CRM系统覆盖客户从潜在、准入、变动到流失的全生命周期，支持企业透视客户生命周期全过程，识别不同阶段并制定针对性策略，推动客户阶段转化（如从目标客户到忠诚客户）；整合客户静态信息、联系人、需求、联系历史、交易过程、价值信息等，形成360度客户视图，营销角色可实时获取客户分布、关键人、需求、销售过程等数据。</p><p><strong>客户关系与项目管理</strong>：提供客户关系图（展示客户关联单位，支持关联销售与集团客户管理）、联系人关系图（展示联系人上下级关系及影响度，辅助业务开展）、项目决策树（展示项目联系人决策关系，助力项目推进），强化客户资源的企业化管理。</p><p><strong>营销与供应链联动</strong>：营销数智化服务（如全渠道营销、会员管理、电商服务）的前端数据反哺供应链，实现按需生产与精准履约（如根据销售数据调整库存、生产计划）；供应链的“订单到收款”全链条智能化与营销的订单管理、售后服务闭环，支撑从客户下单到履约、售后的全流程服务，提升客户满意度与复购率。</p><h3>补充信息：</h3><p>用友通过YonSuite、U8+等产品体系，进一步强化“内控+外联”能力：</p><ul><li><strong>YonSuite</strong>：纯公有云SaaS平台，实现财务、人力、供应链等场景一体化数据打通，支持核心企业与上下游协同，如制造业的“生产-采购-销售”全链路联动、消费品行业的柔性供应链（根据前端销售数据动态调整生产）。</li><li><strong>智能内控</strong>：基于实时数据的AI预测能力，如供应链环节的库存积压风险预测、财务领域的资金流动异常预警，辅助企业从“事后分析”转向“事前防控”；低代码平台支持企业灵活配置合同管理、商旅费控等流程，兼顾标准化与个性化需求。</li><li><strong>全球化支撑</strong>：支持多语言、多币种、多税制的统一管理，帮助企业打通跨国业务流程，实现全球化运营与供应链协同。</li></ul><p><strong>延伸说明：超兔一体云：打通“内控 + 外联”全业务链路，实现供应链与客户生命周期深度绑定的实现逻辑</strong></p><h2>一、引言</h2><p>在当今竞争激烈的商业环境中，企业需要高效整合内部资源并与上下游合作伙伴紧密协作，以实现供应链与客户生命周期的深度绑定。超兔一体云凭借其强大的功能和独特的优势，在这方面提供了卓越的解决方案。通过立足上下游协同体系，超兔一体云成功打通了“内控 + 外联”全业务链路，为企业带来了更高的运营效率和更强的竞争力。</p><h2>二、超兔一体云的核心优势奠定基础</h2><h3>（一）全业务一体化架构</h3><p>超兔一体云涵盖了 CRM、进销存、供应链、上下游、收支账、薪资、生产工单等多个模块，实现了业务和数据的底层连通。这种全业务一体化的架构为企业提供了一个综合业务大底座，使得企业内部各个部门之间的信息能够无缝流通，避免了信息孤岛的问题。例如，销售部门可以实时获取库存信息，以便更好地与客户沟通订单交付时间；生产部门可以根据销售订单及时安排生产计划，提高生产效率。</p><h3>（二）低成本客制化能力</h3><p>超兔一体云支持功能白名单订阅、自定义三级菜单、工作台、业务表、工作流和多表聚合等功能。这种低成本客制化能力使得企业可以根据自身的业务需求和特点，灵活配置系统，满足不同行业和业务模型的侧重。例如，对于制造业企业，可以自定义生产工单流程，实现生产过程的精细化管理；对于贸易型企业，可以根据自身的销售模式，定制订单管理流程。</p><h3>（三）强大的集成能力</h3><p>超兔一体云具备丰富的业务 API 和基于网页自动化的 RPA，能够与 ERP、WMS 等外部系统进行对接，还能与电商平台通过 RPA 机器人对接，以及对接国税开票机器人等。这种强大的集成能力使得企业可以将超兔一体云与现有的业务系统进行整合，实现数据的共享和业务的协同。例如，企业可以将超兔一体云与金蝶、用友等 ERP 系统对接，实现财务数据的自动同步和业务流程的无缝衔接。</p><h2>三、上下游协同体系的构建</h2><h3>（一）OpenCRM 业务伙伴共生平台</h3><p>超兔一体云的 OpenCRM 业务伙伴共生平台是实现上下游协同的关键。它通过打通企业内部 CRM 与上下游伙伴的业务数据，实现了从询价、采购、发货到对账、开票、售后的全流程协同。</p><ol><li><strong>上游协作</strong>：企业可以通过 OpenCRM 向供应商发送询价请求，供应商可以实时响应并提供报价。在采购执行过程中，系统可以自动匹配历史供应商，根据比价结果创建采购单，并对供应商进行评级。同时，系统还支持付款发票、对账、技术支持等功能，确保与供应商的合作顺畅。</li><li><strong>下游协作</strong>：企业可以向客户发送报价单和订单，客户可以在线确认报价和订单信息。在发货过程中，客户可以实时查看物流进度，并进行收货确认。系统还支持款项发票、投诉处理等功能，提高客户满意度。</li><li><strong>共性能力</strong>：OpenCRM 具备三流合一对账、全程追溯、消息通知等共性能力。三流合一对账确保了货、款、票的一致性，提高了财务核算的准确性；全程追溯功能使得企业可以对业务流程进行全面监控，及时发现问题并进行处理；消息通知功能则保证了企业与上下游伙伴之间的信息及时传递。</li></ol><h3>（二）外部共生用户管理</h3><p>OpenCRM 引入了外部共生用户的概念，允许供应商和客户直接参与业务协作。企业可以通过批量开通的方式为外部共生用户分配账号，并设置相应的权限。这种安全控制机制确保了企业数据的安全性和保密性，同时也提高了业务协作的效率。</p><h2>四、“内控 + 外联”全业务链路的打通</h2><h3>（一）内部业务流程的优化</h3><p>超兔一体云的各个模块之间实现了数据的实时共享和业务的协同。例如，在客户管理模块中，企业可以对客户进行全面的画像和背景调查，了解客户的需求和偏好。在跟单中心，企业可以根据客户的情况选择合适的跟单模型，提高跟单效率。在合同订单管理中心，企业可以对订单进行全流程管理，包括订单的生成、执行、结算等。这些内部业务流程的优化使得企业能够更好地满足客户的需求，提高客户满意度。</p><h3>（二）与上下游伙伴的业务协同</h3><p>通过 OpenCRM 业务伙伴共生平台，企业可以与上下游伙伴进行实时的业务协同。例如，在采购管理中，企业可以与供应商共享库存信息，实现智能采购，降低采购成本。在销售管理中，企业可以与客户共享订单信息，提高订单处理效率。这种与上下游伙伴的业务协同使得企业能够更好地应对市场变化，提高供应链的灵活性和响应速度。</p><h3>（三）数据的流通与整合</h3><p>超兔一体云通过数据统计分析引擎，实现了对企业内部和外部数据的流通与整合。例如，企业可以通过多表聚合引擎对不同模块的数据进行关联分析，了解业务的整体情况。同时，系统还支持同比环比引擎、关联表复合查询引擎等，为企业提供了更加深入的数据分析和决策支持。</p><h2>五、供应链与客户生命周期的深度绑定</h2><h3>（一）客户生命周期管理与供应链的协同</h3><p>超兔一体云的客户中心模块可以对客户进行全生命周期管理，根据客户的跟进状态自动分类为需求培养、有需求、上首屏、加入目标、成功等客池。在不同的客池阶段，企业可以根据客户的需求和特点，与供应链进行协同。例如，在需求培养阶段，企业可以通过供应链提供的产品信息和解决方案，为客户提供更加精准的服务；在成功阶段，企业可以根据客户的订单需求，及时安排生产和发货，确保订单的及时交付。</p><h3>（二）供应链对客户需求的响应</h3><p>超兔一体云的供应链模块可以根据客户的订单需求，自动计算采购量、匹配历史供应商、生成采购计划和采购单。同时，系统还支持供应商直发业务模型，缩短了交货周期，提高了客户满意度。例如，当客户下达订单后，系统可以自动分析库存情况，如果库存不足，系统可以立即向供应商发送采购请求，并安排供应商直接发货给客户，减少了中间环节，提高了供应链的响应速度。</p><h3>（三）数据驱动的决策支持</h3><p>超兔一体云的数据分析能力为供应链与客户生命周期的深度绑定提供了数据驱动的决策支持。通过对客户数据和供应链数据的分析，企业可以了解客户的需求趋势和供应链的运营情况，及时调整业务策略。例如，企业可以根据客户的购买历史和偏好，预测客户的未来需求，提前安排生产和采购计划；同时，企业可以通过对供应链数据的分析，优化供应链流程，降低成本，提高效率。</p><h2>六、案例分析</h2><p>以某工业类企业为例，该企业在使用超兔一体云之前，面临着内部信息流通不畅、与上下游伙伴协作效率低下、客户满意度不高等问题。在引入超兔一体云之后，企业通过 OpenCRM 业务伙伴共生平台与供应商和客户建立了紧密的合作关系，实现了业务数据的实时共享和业务流程的协同。同时，企业通过优化内部业务流程，提高了运营效率，降低了成本。在客户管理方面，企业通过超兔一体云的客户中心模块对客户进行了全生命周期管理，根据客户的需求和特点提供了个性化的服务，提高了客户满意度。通过这些措施，该企业的供应链与客户生命周期实现了深度绑定，企业的竞争力得到了显著提升。</p><h2>七、结论</h2><p>超兔一体云通过其核心优势、上下游协同体系的构建、“内控 + 外联”全业务链路的打通以及供应链与客户生命周期的深度绑定，为企业提供了一个全面、高效的解决方案。在当今数字化时代，企业需要不断提升自身的竞争力，超兔一体云的应用将有助于企业实现业务的数字化转型，提高运营效率，降低成本，增强客户满意度，从而在市场竞争中取得优势。</p>]]></description></item><item>    <title><![CDATA[OceanBase分区基础知识 老纪的技]]></title>    <link>https://segmentfault.com/a/1190000047399637</link>    <guid>https://segmentfault.com/a/1190000047399637</guid>    <pubDate>2025-11-14 15:07:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>介绍</h2><p>分析型业务通常需要对海量数据进行分析计算，这对数据库的查询能力，以及数据管理能力都有很高的要求。OceanBase通过分区技术，将一张表的数据按照分区键水平拆分成多个数据子集，有助于提升查询效率和数据管理能力：</p><p><strong>1.查询效率提升</strong>：分区裁剪能减少无关数据的扫描</p><p><strong>2.数据维护</strong>：支持按照分区粒度进行数据管理，比如数据归档、清理等</p><p><strong>3.数据分布</strong>：按照分区粒度进行数据分布，能够将数据打散到多个节点上，具备良好的可扩展性</p><p>本文首先对分区在 OceanBase 的作用进行介绍，接着描述了 OceanBase 中的基础分区方式以及它们的适用场景，最后讨论了 OceanBase 的灵活分区管理能力如何应用于数据维护、数据管理等业务场景。</p><h2>OceanBase 中分区的作用</h2><p>在 OceanBase 中，分区是水平分片的基本单位，是数据分布、负载均衡和并行操作的最小物理单元。一张大表被逻辑地分割成多个更小、更易管理的独立块，每个分区（甚至分区的不同副本）都可以分散存储在集群中不同的 OBServer 节点上。</p><p>这种设计为分析型业务带来了根本性的优势：当单一节点的存储或计算能力成为瓶颈时，可以通过增加节点并重新分布分区的方式，实现近乎线性的水平扩展，从而处理 PB 级别的数据量。</p><h3>分区裁剪提升查询效率</h3><p>使用分区后，指定分区列进行查询时，在某些场景下能够裁剪出满足查询条件的分区，使得查询无须查询那些不满足条件的分区。</p><p>参考如下例子，我们在列 c2 上创建 hash 分区，指定 c2=1 的查询条件，能够裁剪出只需要查询分区 p1。</p><pre><code class="plain">-- 创建一张四个hash分区的表格t1，分区键为C2create table t1(c1 int, c2 int) partition by hash(c2) partitions 4;
-- 指定c2=1查询，裁剪出分区p1explain select * from t1 where c2 = 1;+------------------------------------------------------------------------------------+| Query Plan                                                                         |+------------------------------------------------------------------------------------+| ===============================================                                    || |ID|OPERATOR       |NAME|EST.ROWS|EST.TIME(us)|                                    || -----------------------------------------------                                    || |0 |TABLE FULL SCAN|t1  |1       |3           |                                    || ===============================================                                    || Outputs &amp; filters:                                                                 || -------------------------------------                                              ||   0 - output([t1.c1], [t1.c2]), filter([t1.c2 = 1]), rowset=16                     ||       access([t1.c2], [t1.c1]), partitions(p1)                                     ||       is_index_back=false, is_global_index=false, filter_before_indexback[false],  ||       range_key([t1.__pk_increment]), range(MIN ; MAX)always true                  |+------------------------------------------------------------------------------------+</code></pre><p>分区裁剪可以过滤掉不需要的数据，但分区数太多可能也会导致其他的问题，例如元数据量过多、分区裁剪的效率可能降低等等，因此，在 OceanBase 的列存表中建议单个分区的行数&gt;=100W 行。</p><h3>分区作为数据维护单元</h3><p>在数据库运维中，将分区作为基本的数据维护单元，能较大地简化日常管理流程，例如数据清理场景、分区级收集统计信息等。以数据清理场景为例，当数据按时间进行分区后，清理过期数据就不再需要逐行删除，而是直接通过删除整个历史分区来实现，这种操作仅仅只需要修改元数据，还能彻底释放磁盘空间，避免了传统的 DML 删除操作产生的性能开销。通过分区键（如时间） 将数据自然归类，使维护操作从“逐行扫描”变为“批量处理”，极大地提升了管理效率，降低了运维的复杂度。</p><h2><strong>分区作为数据分布单元</strong></h2><p>分区作为 OceanBase 的数据分布单元，每个分区的副本可以放置在不同的 OBServer 节点，以实现存储和计算的扩展。</p><p><strong>1.存储的扩展</strong>：当创建一个分区表时，这些分区及其副本可以根据集群的资源情况，由 OceanBase 自动调度到不同的物理节点上。这意味着单张表的容量不再受限于单机磁盘，而是整个集群的存储容量，当集群的存储空间不足时，通过加节点就能够实现扩展。</p><p><strong>2.计算的并行化</strong>：这是分析型业务实现高性能的关键因素之一，当一个查询（特别是涉及全表扫描或大规模聚合的查询）被执行时，OceanBase 的优化器会识别出查询涉及的分区。查询任务可以被分解成多个子任务，并下推到各个数据分区所在的节点上并行执行。例如，一个 SUM() 操作会在每个分区本地先计算小计，然后将中间结果汇总得到最终总和，这充分利用了多节点的计算能力，从而显著加速查询。</p><h3>OceanBase 的基础分区方式</h3><p>目前 OceanBase 中支持三大类基础的分区方式，包括 Hash/Key，Range/Range Columns 和 List/List Columns，三种分区方式各自的使用场景有所不同。</p><h4>HASH/KEY 分区</h4><p>一般适用于分区列 NDV（不同值的种类）较大，且难以划分出明确范围的情况。优点是容易让没有特定规则的数据也能够在不同的分区内均匀分布，缺点是在范围查询时难以进行分区裁剪。</p><p><strong>适用场景举例</strong>：无明显查询模式，需均匀分布数据到多个节点（如用户ID、交易ID）。</p><p><strong>设计要点：</strong></p><ul><li><p>分区键选择：</p><ul><li>NDV（唯一值数量）远大于分区数（如用户 ID 的 NDV 应远大于分区数）。</li><li>优先选择无倾斜（或只有少量倾斜）的整型/时间列（如 user_id, order_time，或者自增列）。</li><li>高频查询条件字段（如 user_id 作为 Join 关键字）。</li></ul></li><li><p>分区数推荐：</p><ul><li>确保分区数匹配集群的机器数量，避免资源分配不均衡</li></ul></li></ul><p><strong>示例场景（Hash 分区使用场景）</strong></p><pre><code class="markdown">-- Hash分区，按user_id均匀分布CREATE TABLE customer(  user_id BIGINT NOT NULL,  login_time TIMESTAMP NOT NULL,  customer_name VARCHAR(100) NOT NULL,  phone_num BIGINT NOT NULL,  city_name VARCHAR(50) NOT NULL,  sex INT NOT NULL,  id_number VARCHAR(18) NOT NULL,  home_address VARCHAR(255) NOT NULL,  office_address VARCHAR(255) NOT NULL,  age INT NOT NULL)PARTITION BY HASH(user_id) PARTITIONS 128;</code></pre><h4>Range/Range Columns 分区</h4><p>一般适用于分区键容易划分出明确的范围的情况，例如可以把记录流水信息的大表，根据表示信息时间的列做 RANGE 分区。</p><p><strong>适用场景举例</strong>：</p><ul><li>数据按时间/数值范围增长（如 order_time, price）。</li><li>需快速裁剪历史数据（如仅查询最近一个月数据）。</li></ul><p><strong>设计要点</strong>：</p><ul><li><p>分区键选择：</p><ul><li>时间字段（如 order_time）或连续数值字段。</li><li>分区边界需与业务查询条件对齐（如按天/月划分）。</li></ul></li><li><p><strong>分区数推荐</strong>：</p><ul><li>根据数据增长设置分区，例如按照月份分区。</li></ul></li></ul><p><strong>示例场景（ange/Range Columns分区示例）</strong></p><pre><code class="markdown">-- 创建系统日志表，按日志时间进行月度RANGE分区，支持快速查询与数据归档CREATE TABLE system_logs(    log_id BIGINT,    log_date TIMESTAMP NOT NULL,    log_level VARCHAR(10),    source_system VARCHAR(50),    user_id BIGINT,    log_message TEXT,    client_ip VARCHAR(15))-- 主分区：按月RANGE分区，使用日期直接表达分区边界PARTITION BY RANGE COLUMNS(log_date)(    PARTITION p_202001 VALUES LESS THAN ('2020-02-01'),    PARTITION p_202002 VALUES LESS THAN ('2020-03-01'),    PARTITION p_202003 VALUES LESS THAN ('2020-04-01'),    PARTITION p_202004 VALUES LESS THAN ('2020-05-01'),    PARTITION p_202005 VALUES LESS THAN ('2020-06-01'),    PARTITION p_202006 VALUES LESS THAN ('2020-07-01'),    PARTITION p_202007 VALUES LESS THAN ('2020-08-01'),    PARTITION p_202008 VALUES LESS THAN ('2020-09-01'),    PARTITION p_202009 VALUES LESS THAN ('2020-10-01'),    PARTITION p_202010 VALUES LESS THAN ('2020-11-01'),    PARTITION p_202011 VALUES LESS THAN ('2020-12-01'),    PARTITION p_202012 VALUES LESS THAN ('2021-01-01'),    -- 默认分区处理未来数据或时间格式异常的记录    PARTITION p_future VALUES LESS THAN (MAXVALUE));</code></pre><h4>List/List Columns分区</h4><p>一般适用于需要显式控制各行数据如何映射到具体的某一个分区时，优点是可以对无序或无关的数据集进行精准分区，缺点是在范围查询时难以进行分区裁剪。</p><p><strong>适用场景举例</strong>：</p><ul><li>离散型字段（如地区、渠道类型）。</li><li>需按固定类别快速裁剪数据（如查询华东地区用户）。</li></ul><p><strong>设计要点</strong>：</p><ul><li><p>分区键选择：</p><ul><li>离散值且数量有限（如 region 字段仅有 ['east','west','south','north']）。</li><li>分区值需覆盖所有可能取值，避免遗漏。</li></ul></li><li><p><strong>分区数限制：</strong></p><ul><li>根据业务逻辑进行配置分区数</li></ul></li></ul><p><strong>示例场景（List/List Columns 分区使用场景）</strong></p><pre><code class="markdown">CREATE TABLE orders_by_region(    order_id BIGINT COMMENT '订单唯一标识',    region_code INT NOT NULL PRIMARY KEY  COMMENT '区域代码（1=north/china, 2=east/china, 3=south/china, 4=west/china）',    customer_id BIGINT COMMENT '客户ID',    order_time DATETIME COMMENT '订单创建时间',    product_category VARCHAR(50) COMMENT '商品类别',    order_amount DECIMAL(18,2) COMMENT '订单金额',    payment_status VARCHAR(20) COMMENT '支付状态（如：PAID, UNPAID）')PARTITION BY LIST(region_code)  -- 改为整数类型分区键(    PARTITION p_north VALUES IN (1),  -- 区域代码1对应north/china    PARTITION p_east VALUES IN (2),    PARTITION p_south VALUES IN (3),    PARTITION p_west VALUES IN (4),    PARTITION p_other VALUES IN (DEFAULT)  -- 默认分区处理未知区域);</code></pre><h2>灵活的分区管理能力</h2><p>OceanBase 有非常灵活的分区管理能力，从数据管理的角度来看，它既有数据维护的功能，也有数据分布的功能；从使用方式来讲，它有手动管理和自动管理两种方式；从分区的层次来考虑，它支持一级分区和二级分区组合使用，通过不同的组合，满足用户对于数据管理的不同需求。</p><p>本节将从数据维护和数据分布来个角度来展开，同时在两个角度中考虑使用方式以及分区的层次的能力组合。</p><h3>数据维护</h3><p>业务层通常按照时间维度来管理分区，方便做数据的归档，清理等操作，我们从业务的完整的数据生命周期流程来结合来描述我们的手动分区管理能力。</p><p><strong>1.业务建表</strong>：创建按照时间分区的表格，提前创建未来一段时间需要的分区</p><p><strong>2.业务导数</strong>：导入数据</p><p><strong>3.业务运行</strong>：随着时间的推进，可能提前创建的分区不足，继续提前创建未来一段时间需要的分区</p><p><strong>4.定期数据清理</strong>：当数据积累到一定时间后，可能之前的数据就不需要了，此时可以删除不需要的分区</p><p>以下是上述使用场景的具体例子：</p><pre><code class="markdown">-- 1. 创建分区表（按天分区，预创建未来7天分区）CREATE TABLE business_data(    id BIGINT NOT NULL AUTO_INCREMENT,    event_time DATETIME NOT NULL,    metric_value DECIMAL(10,2),    PRIMARY KEY (id, event_time)) PARTITION BY RANGE COLUMNS(event_time)(    PARTITION p20231025 VALUES LESS THAN ('2023-10-26'),    PARTITION p20231026 VALUES LESS THAN ('2023-10-27'),    PARTITION p20231027 VALUES LESS THAN ('2023-10-28'),    PARTITION p20231028 VALUES LESS THAN ('2023-10-29'),    PARTITION p20231029 VALUES LESS THAN ('2023-10-30'),    PARTITION p20231030 VALUES LESS THAN ('2023-10-31'),    PARTITION p20231031 VALUES LESS THAN ('2023-11-01')  -- 预创建未来7天分区);-- 2. 导入数据，这里略过-- 3. 预创建未来7天分区ALTER TABLE business_data ADD PARTITION(  PARTITION p20231101 VALUES LESS THAN ('2023-11-02'),  PARTITION p20231102 VALUES LESS THAN ('2023-11-03'),  PARTITION p20231103 VALUES LESS THAN ('2023-11-04'),  PARTITION p20231104 VALUES LESS THAN ('2023-11-05'),  PARTITION p20231105 VALUES LESS THAN ('2023-11-06'),  PARTITION p20231106 VALUES LESS THAN ('2023-11-07'),  PARTITION p20231107 VALUES LESS THAN ('2023-11-08'));-- 4. 定期数据清理，例如数据到期后，删除7天的数据ALTER TABLE business_data DROP PARTITION p20231025, p20231026, p20231027, p20231028, p20231029, p20231030, p20231031;</code></pre><p>由于数据在不停地写入，手工维护预创建分区和定期清理分区还是比较麻烦的。为了简化这个流程，OceanBase 提供了动态分区功能，支持按固定时间分区，预创建多长时间的分区和保留多久的历史分区等功能，对于上面的例子，假如我们需要保留 30 天数据，每次预创建 7 天的分区，那么使用如下语法来进行创建：</p><pre><code class="markdown">-- 1. 创建分区表，设置动态分区策略CREATE TABLE t1(    id BIGINT NOT NULL AUTO_INCREMENT,    event_time DATETIME NOT NULL,    metric_value DECIMAL(10,2),    PRIMARY KEY (id, event_time))DYNAMIC_PARTITION_POLICY(  ENABLE = true,  TIME_UNIT = 'day',  PRECREATE_TIME = '7day',  EXPIRE_TIME = '30day')PARTITION BY RANGE COLUMNS(event_time)(  PARTITION p20231025 VALUES LESS THAN ('2023-10-26'));</code></pre><p>除了 Range 分区模式外，业务也可以按照业务需求选择其他基础分区方式。</p><h3>数据分布</h3><p>分区也可以作为数据据分布管理的单元，通常情况下为了数据打散，一般使用 HASH 分区的方式，它有如下优势：</p><ol><li>它通常能实现比较好的数据打散的需求，也能够做比较准确的分区裁剪；</li><li>对于需要 join 的多张表格，如果按照 join 键进行 hash 分区，并且分区数也保持一致，此时配合 OceanBase table group 能力，能够实现相同 hash 规则的对应下标的分区绑定在一起，从而使得 join 时能够使用 Partition Wised Join，避免数据 shuffle。</li></ol><p>Hash 分区也存在部分问题：</p><ol><li>Hash 分区的分区数设置之后，修改分区数是一个比较重的操作，涉及到整张表的数据重写，所以，一般设置好 Hash 分区的分区数之后，就一般不再变化，比较难以实现可扩展；</li><li>对于分区键上的范围查询，无法裁剪出分区，需要访问所有的分区，可能会存在读放大。</li></ol><p>为了解决 HASH 分区可扩展性以及范围查询的问题，OceanBase 已经支持行存表的自动分区分裂能力，在未来版本中还将提供两种列存表自动分区分裂的模式：堆表分区分裂模式和聚集索引（clustering key）表分区分裂模式。</p><p>堆表分区分裂模式基于堆表的隐藏主键列进行自动分区，由于隐藏主键在分区分裂模式下是随机生成的，并且当租户的机器资源扩展或缩容时，会自动扩充或者缩减对应的分区数，使得该模式能够自动地进行扩展，具备比较好的可扩展性。不过，该模式下数据行是随机分布在任意一个分区的，因此是无法进行分区裁剪的，所以查询性能上可能不是最优，该模式适合对性能要求不高，且不希望提供手动分区或者自动分区键的情况，但又希望表能够自动地扩展。</p><p>聚集索引表分区分裂模式基于用户指定的聚集键进行自动分区，按照数据量进行自动地切分合适大小的分区，当租户的机器资源扩展或者缩容时，由于分裂的分区数已经足够多时，就可以将这些分区重新进行均衡。该模式由于按照聚集键进行自动拆分，当查询能够指定聚集键查询，无论是点查还是范围查询，能够进行分区裁剪，查询性能是比较优的，并且也能够根据机器资源进行自适应地扩展或者缩容。同时聚集索引表自动分裂也能够对支持多张需要 join 的表配置 table group，其中自动分裂的键可以配置为 join键，也能实现 Partition Wised Join。</p><p>为了方便大家理解，Hash、堆表分区分裂和聚集索引表分区分裂三种方式的特点对比如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399639" alt="" title=""/></p><p>除了上述分区方式，业务也可以按照业务需求选择其他的基础分区方式。</p><h3>混合数据维护和数据分布管理</h3><p>我们也可以以二级分区的方式，同时支持数据维护和数据分布的需求，通常使用比较多的场景为一级分区用于数据维护的需求，二级分区用于数据分布的需求，每种需求可以使用对应需求所支持的方式进行组合。</p><h4>典型的手动分区管理方式</h4><ol><li><p>一级分区：</p><ul><li>类型选择：使用 Range 或者 List 分区，匹配高频查询条件（如时间范围、地区）。</li><li>分区数建议：根据查询条件时间分布、数据维护的需求设置合理范围（如按月分区保留 12 个月，或按地区分为 4 个 List 分区）。</li></ul></li><li><p>二级分区：</p><ul><li>类型选择： 使用Hash分区，保证数据打散。</li><li><p>分区数推荐：</p><ul><li>如果只有一个一级分区写入，那么一级分区的二级分区数需要满足写入打散的资源诉求</li><li>如果有多个一级分区能够写入，那么能写入的一级分区数 * 二级分区数满足写入打散的资源诉求即可</li></ul></li></ul></li></ol><p>以下是 Range + Hash 和 List + Hash 的两个场景案例：</p><p><strong>1.Range + Hash</strong>：一级选择 Range 分区，指定 order_date 后，可以快速过滤掉不需要扫描数据的分区，也能够通过分区管理操作快速进行数据维护，二级选择 Hash 分区，可以将当月的写入或者读取打散到 8 个分区中，避免热点。</p><pre><code class="markdown">CREATE TABLE orders(    user_id BIGINT NOT NULL COMMENT '用户ID（二级分区键）',    order_date DATE NOT NULL COMMENT '下单日期（一级分区键）',    amount DECIMAL(10,2) NOT NULL COMMENT '订单金额',    status TINYINT NOT NULL COMMENT '状态: 0-取消 1-待支付 2-已支付 3-已发货 4-已完成',    region_code CHAR(6) NOT NULL COMMENT '地区编码（前2位省码）',    product_id INT NOT NULL COMMENT '商品ID',    payment_method VARCHAR(20) COMMENT '支付方式',    created_at TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) COMMENT '记录创建时间')PARTITION BY RANGE COLUMNS(order_date)SUBPARTITION BY HASH(user_id) SUBPARTITIONS 8(  PARTITION p202501 VALUES LESS THAN ('2025-02-01'),  PARTITION p202502 VALUES LESS THAN ('2025-03-01'),  ...  PARTITION p202601 VALUES LESS THAN ('2026-02-01'));</code></pre><p><strong>2.List + Hash</strong>：一级选择 List 分区，指定省份能够裁剪到相应的分区，也可以按照省维度进行数据维护，二级选择 Hash/Key 分区，可以将省的读写流量打散到多个分区中，实现负载均衡。</p><pre><code class="markdown">-- 一级分区：LIST按省划分（31个省级行政区）CREATE TABLE social_insurance_records(    record_id BIGINT,    province_code INT NOT NULL,  -- 省级编码（如11北京，31上海）    payment_date DATE NOT NULL,    user_id VARCHAR(32) NOT NULL,    amount DECIMAL(10,2)) PARTITION BY LIST(province_code)  -- 一级LIST分区SUBPARTITION BY KEY(user_id) SUBPARTITIONS 16  -- 二级HASH分区(  PARTITION p_beijing VALUES IN (11),  PARTITION p_shanghai VALUES IN (31),  PARTITION p_tianjin VALUES IN (12),  ...  PARTITION p_xizang VALUES IN (54));</code></pre><h3><strong>典型的自动分区管理方式</strong></h3><ol><li><strong>一级分区</strong>：选择动态分区，配置按固定时间分区，预创建多长时间的分区和保留多久的历史分区等参数；</li><li><strong>二级分区</strong>：选择自动 Range 分区分裂，能够自动地进行分裂，无须配置分区个数或者分区规则。</li></ol><h2>总结</h2><p>目前 OceanBase 支持了常见的基础分区方式，通过基础分区方式的组合使用，能够满足业务的数据维护、数据分布以及提升查询效率等需求。动态分区对按照时间进行分区数据维护的通用需求提供了标准的自动化管理能力，减少用户对数据维护的代价，未来我们将加强自动分区的管理能力，支持列存表的自动分区分裂，减少当前数据分布手工维护的代价、可扩展性等问题，进一步提升列存表的数据管理自动化管理能力，使得分析型业务场景能更容易使用OceanBase。</p>]]></description></item><item>    <title><![CDATA[硬核技术获省级名录推荐，破解水利感知决策]]></title>    <link>https://segmentfault.com/a/1190000047399695</link>    <guid>https://segmentfault.com/a/1190000047399695</guid>    <pubDate>2025-11-14 15:07:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>2024年12月，山东省水利厅发布《山东省水利改革创新典型案例（第三批）》，费县智慧水利项目凭借“孪生+流域”创新模式成功入选，展示了数字技术在破解水利管理难题上的突破性进展。</p><h2>智能感知：从“单点监测”到“全域感知”</h2><p>传统水利工程面临的最大挑战是感知能力不足。现在，多源信息融合技术正在改变这一局面。通过部署雷达水位计、多普勒流速仪、多参数水质传感器等设备，构建起空天地一体化的监测网络。</p><p>以入选省级名录的费县项目为例，该县智慧水利系统接入水利工程运行状态传感器、视频监控、雨水情监测等实时数据，实现水利工程运行状态实时可视化交互。其监测精度达到水位误差厘米级、流量测量精度90%以上，水质指标监测分辨率达0.01单位。<br/><img width="480" height="263" referrerpolicy="no-referrer" src="/img/bVdm2Y9" alt="" title=""/></p><p>智能石头技术代表了感知技术的重大突破。第五代产品采用多传感器智能串联设计，监测精度达毫米级，功能从单一震动监测升级为集倾斜、振动、走失、移位、形变于一体的“全能感知”。其运动轨迹监测算法可精准描述石体位移状态：<br/><img width="242" height="75" referrerpolicy="no-referrer" src="/img/bVdm2Zb" alt="" title="" loading="lazy"/><br/>其中Δx为位移量，v₀为初速度，a为加速度，ε为环境误差补偿系数。该技术使预警准确率跃升至80%以上，电池续航能力延长至3-4年。<br/><img width="700" height="339" referrerpolicy="no-referrer" src="/img/bVdm2Za" alt="" title="" loading="lazy"/></p><h2>智能决策：从“经验判断”到“模型驱动”</h2><p>水利决策的核心在于精准预测与仿真。宁波市开发的甬江流域预报调度一体化模型，集成了水利、自然资源、气象等多部门海量数据，以预报、预警、预演、预案为核心，通过数字孪生技术实现自然流域与虚拟模型的动态联动。</p><p>在防御台风“康妮”时，宁波市水利局应用并行计算技术，将干流及平原主要水位的预报时间从8分钟大幅压缩至2分钟。对代表站水位的预测结果与实际测量值偏差小于10厘米。其洪水演进模型采用改进的圣维南方程组：<br/><img width="461" height="71" referrerpolicy="no-referrer" src="/img/bVdm2Zc" alt="" title="" loading="lazy"/></p><p>其中Q为流量，A为过水面积，h为水位，S_f为摩擦坡度。该模型有效解决了甬江流域因上游山区源短流急、下游潮水顶托带来的复杂调度难题。</p><p>黄冈市打造的“智慧水域”平台展示了多部门协同决策的强大能力。该平台以雷达、AIS基站、高点视频以及卡口监控为载体，应用AI算法自动识别加中端应用软件精准预警、后端指挥中心自动派单的联动机制。在河湖治理过程中，黄冈市加强了水利、环保、农业等多部门协作，建立信息共享机制，实现河湖监测数据与水利设施运行数据的整合。<br/><img width="723" height="372" referrerpolicy="no-referrer" src="/img/bVdm2Zd" alt="" title="" loading="lazy"/></p><h2>工程实践：闭环管理赋能水利现代化</h2><p>在实际工程应用中，数字孪生技术正推动水利工程管理模式的深刻变革。宁波市启动的数字孪生周公宅-皎口梯级水库项目，围绕信息基础设施、数字孪生平台、业务应用及网络安全四大核心领域，全面升级优化水库运行管理体系。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm2Zg" alt="" title="" loading="lazy"/></p><p>智能诊断与预警系统实现了从被动应对到主动防控的转变。系统能自动分析渗流、位移等安全指标，预判潜在风险，并生成详细的“体检报告”。当检测到异常情况时，系统在20秒内自动生成处置工单，将预警信息实时推送至工作人员手机。<br/><img width="723" height="369" referrerpolicy="no-referrer" src="/img/bVdm2Y3" alt="" title="" loading="lazy"/></p><p>凡拓数创参与建设的“左港水库数字孪生平台”作为2025年唯一上榜水利类数字孪生项目，展示了数字孪生技术在破解水利难题上的价值。该平台通过高精度建模与实时数据分析，为水库安全管理提供了可靠的技术支撑。<br/><img width="723" height="349" referrerpolicy="no-referrer" src="/img/bVdm2Y4" alt="" title="" loading="lazy"/></p><h2>技术展望：智能水利率领未来发展</h2><p>随着技术的不断进步，水利工程正朝着智能化、精细化方向快速发展。从“智能石头”到数字孪生平台，技术创新正在重塑传统水利行业的管理模式和发展路径。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm2Zj" alt="" title="" loading="lazy"/></p><p>未来，随着5G、人工智能、大数据等技术的深度融合，水利工程将实现更高水平的智能化管理。预报调度一体化、智能诊断预警和多部门协同决策将成为行业标准，为水资源管理和防洪减灾提供更加精准、高效的技术支撑。</p><p>省级名录的推荐不仅是对创新技术的认可，更是对水利行业数字化转型的推动。随着这些硬核技术在更多水利工程中推广应用，我国水利现代化管理水平将实现新的飞跃。</p>]]></description></item><item>    <title><![CDATA[鸿蒙人物志 x 王丹辉｜善用生态之力，专]]></title>    <link>https://segmentfault.com/a/1190000047399766</link>    <guid>https://segmentfault.com/a/1190000047399766</guid>    <pubDate>2025-11-14 15:06:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>此篇文章来源于 SegmentFault 思否鸿蒙专区·鸿蒙人物志专题采访，阅读时长约 9 分钟，以下为正文：</p><blockquote><p>“跨设备协同”不应只是发布会上的热词，它需要在真实产品里被做成稳定、无感、可复制的日常体验。</p><p>王丹辉——北京湛泸教育首席架构师、开源项目“赵王电机智能关节”联合主理人，曾主导 ZBot-1600-v1、ZBot-800-v1 两款人形双足机器人的研发，如今专注于智能穿戴与生物信息交互领域，并以鸿蒙为技术底座推进实战落地与应用普及。他的最新项目 ColorVision，致力于帮助设计师实现包容性设计，以及让色觉障碍人群“看得更清楚”。</p></blockquote><h4><strong>能力流动：ColorVision 分布式实践路径</strong></h4><p>在技术路径的选择上，王丹辉基于工程本质的考量，将鸿蒙作为 ColorVision 的核心底座。他看中的是其分布式架构带来的跨设备协同便捷性，以及系统级安全机制对敏感色彩数据的可靠保障。</p><p>在王丹辉的理解中，鸿蒙是一套“能力中枢”。其核心不是将单一设备做强做大，而是让能力在端与端之间被调用、编排与无感迁移。这种“以能力为中心”的设计逻辑，使得同一份体验可以在手机、平板、穿戴、大屏之间自由流转。</p><p>对 ColorVision 来说，手机可承担色彩数据采集、核心矫正算法与交互任务，而具有广色域与更强算力的平板或 PC 则负责高精度校核与实时预览。用户在不同设备间切换时，参数与结果保持同源同步，体验始终一致。</p><p>真正的工程智慧体现在团队的取舍之间。ColorVision 立项时，团队评估过是否需要自建一套底层能力，包括色彩空间管理、HDR 适配、可变帧率、异构渲染一致性等。考虑到鸿蒙的 ArkGraphics 2D 原生能力以及星盾安全架构提供的全链路加密与数据存储保障，他们决定深度复用这套系统能力。这让原本需要 6–8 个月的底层开发周期压缩至 1 个多月，节省下来的时间与人力，被投入到两个用户可感知的价值点上。一个是针对不同色弱类型优化映射算法，另一个是为设计师提供实时预览与参数微调等专业功能。</p><blockquote>“借生态之力，做自己最擅长的事”王丹辉反复强调的能力边界观，让团队得以聚焦在真正创造差异化的核心环节。</blockquote><h4><strong>系统韧性：协同与降级双重保障</strong></h4><p>能力能流动只是起点，要打造稳定的体验，还需要把一致性与连续性写进系统约束。王丹辉认为，协同的精度决定了体验的上限。</p><p>他将跨端协同拆解为三个层次。在数据协同层面，基于分布式软总线实现跨端“同源同步”，并以统一色彩空间标准规避设备色域差异带来的偏差。在能力协同层面，当手机处理高清设计文件吃力时，分布式任务调度会调用平板算力完成渲染，再把结果无感回传。在标准协同层面，坚持跨端解析逻辑一致，确保“同一幅画在任何设备上看起来都一样”。这些看似朴素的工程约束，构成了用户心智里“理所当然”的一致性体验。</p><p>面对真实世界中的设备算力差异、网络波动与跨端断连，王丹辉的团队预置了三条兜底路径。<br/>首先是设备能力降级，老设备自动关闭高精渲染与过渡效果，仅保留核心矫正与数据同步，并用可变帧率把交互稳在 15fps 以上。其次是按网络状态降级，断连时切本地独立运行，恢复后自动对账同步，不打断当前操作。然后是按场景优先级降级，设备在低电量等限制条件下优先保障核心功能，暂时关闭非必要动画。</p><p>这套完整的协同与降级机制，为 ColorVision 的体验稳定性奠定了基础，让团队有更多精力 投入到系统优化的下一阶段。</p><h4><strong>优化演进：从验证到稳定的三阶路径</strong></h4><p>在确立协同与降级机制后，团队将重心转向了系统长期稳定性的构建。他们为优化工作设定了明确的优先级：首要解决崩溃率和应用无响应问题，随后是帧率稳定性，最后才是启动速度与内存占用等指标。<br/>项目首先追求的是“快速验证”。团队利用鸿蒙原生组件迅速搭建起基础框架，优先确保色彩矫正等核心流程能够顺畅运行，跨端协同的基本逻辑得到验证。这是从零到一的关键一步。</p><p>在核心流程跑通后，优化进入了“精准调优”阶段。通过 DevEco Studio 的 Profiler 工具，团队逐一定位性能瓶颈。例如，他们发现因重复创建 colorSpace 实例导致内存泄漏，改为单例模式后问题迎刃而解。针对穿戴设备性能特点，团队引入了轻量级渲染与动画裁剪机制，通过“高精场景才加载高级效果”的智能策略配合可变帧率技术，有效改善了帧率抖动现象。同时，冷启动阶段的分布式数据管理采用懒加载策略，显著降低了系统负担。</p><p>最终目标是实现系统的“长期稳定运行”。团队进行了大规模多设备压力测试，构建起完整的异常防护体系，并采用灰度发布与用户反馈闭环机制，让真实使用场景不断验证和校准技术方案。这条优化路径不追求参数极致，却切实保障了产品在各种环境下的可靠表现。</p><p>贯穿这一优化过程的，是一种务实的工程哲学。团队清醒地认识到，技术真正的价值，不是盲目追求参数的堆砌，而是要让生态能力与用户需求达成精准契合。鸿蒙的分布式底座恰好为这种因人制宜、因端施策的产品理念提供了坚实支撑，让团队能够为每一类用户寻找到最适合的技术路径。</p><h4><strong>开发指导：学习与上架指南</strong></h4><p>对于准备用 2-3 周时间“试水”的开发者，王丹辉给出了如下的学习路径，核心思路是“聚焦核心、复用生态、快速出成果”，避免陷入底层技术细节。</p><ul><li>第 1 周（基础打底）<br/>安装 DevEco Studio，完成环境配置（模拟器/真机调试）。<br/>重点学习 ArkUI 声明式开发，掌握布局（Flex/Grid）、组件（Text/Image/Button）及状态管理基础。<br/>理解鸿蒙核心逻辑：分布式软总线、多端部署原理（无需深度研究底层，只需理解“一次开发多端适配”核心逻辑）。<br/>跑通官方“小 demo”，感受生态能力。</li><li>第 2 周（实战落地）<br/>确定 1 个简单核心场景（如“简易色彩识别工具”或“跨设备文本同步工具”），不做复杂功能。<br/>复用鸿蒙原生组件，避免从零开发。<br/>完成“手机+平板”双端适配（布局自适应、组件尺寸适配），借助 DevEco Studio 的“多端预览”功能快速调试。</li><li>第 3 周（优化 + 验证）<br/>使用 DevEco Studio 的 Performance Profiler 排查帧率抖动、内存泄漏（重点优化启动时间＜3 秒、无明显卡顿）。<br/>做基础合规检查：权限申请是否合理（如仅需相机权限则不申请存储权限）、隐私声明是否完整。<br/>熟悉上架流程：注册华为开发者账号、了解应用提审要求、准备测试包（APK/HAP）。</li></ul><p>参考资料：<br/><a href="https://link.segmentfault.com/?enc=79t%2F%2B%2Bzi7IFWSN3EUCMXTg%3D%3D.DPSJS1zPEjiwyv%2BJp%2Fmu7gN0a1ZgyULofqzavb%2FglK%2BgKcwhWh6xjSLqivM%2BNh%2F8" rel="nofollow" target="_blank">HarmonyOS 开发者社区</a><br/><a href="https://link.segmentfault.com/?enc=dnjR6Rjm1Br9BdaopWdOBQ%3D%3D.ldYo8ticXNLkFeG%2Btxs0QT%2BLImWlWbMKsQ30Eq9FF8jHR4rxaIyUiNqffjETZmbdz1yNNTuB6Q0peq0WrckiMIDB13cSOXQQko9OVtQQAn2kg6fqEjUHIfIsXT8UbmQC" rel="nofollow" target="_blank">HarmonyOS 开发文档</a><br/><a href="https://link.segmentfault.com/?enc=Y9DyZzYkCn2IBMnYB0WRlw%3D%3D.BJ%2BmhdDVPy0PbyuNd02ohNi1XN9ST%2B53vh%2FjnuqiKWEKnD4lHM%2FEsDjkrA%2FHl4wHIQ7vGTLFbVxdU6hTZ4NJuA%3D%3D" rel="nofollow" target="_blank">HarmonyOS 应用市场</a></p><h4><strong>生态赋能：经验沉淀资产，联动加速成长</strong></h4><p>把视角拉向生态，鸿蒙带来的三类“高确定性机会”清晰可见：</p><ul><li>岗位机会——适合希望稳健发展的工程师，尤其是准备从 Web/Android/iOS 转型；</li><li>垂直应用——适合有明确产品想法与独立开发能力的小团队，在细分人群里做“有用户、有价值”的产品；</li><li>生态基础设施——开源组件/工具、技术分享、硬件适配与行业解决方案，能够获得生态资源联动并沉淀长期影响力。判断自己是否适合切入，只需两问：你是否握有真实场景痛点？你是否愿意沿着生态“已验证路径”把速度拨快一点？</li></ul><p>在生态内容建设上，他的建议是只写“能直接落地的方法论”，并给出一套“项目经验→可复用文档”的九宫格模板：问题背景/核心目标/备选方案权衡/量化指标/实施步骤/工具与资源/核心结论/踩坑与避坑/迭代建议，让经验从口碑变成可移植的工程资产。</p><p>此外，王丹辉谈到参与鸿蒙创新赛充分展示了自己对生态价值的深刻理解和实践。他的参赛动机并非单纯为了奖项，而是想通过实战验证三点关键观点：首先，垂直小众场景同样可以打造“有用户、有价值”的产品；其次，分布式技术并非单纯的炫技概念，而是能有效降本增效的实战工具；最后，开源与生态联动能够快速放大小众创新的影响力。他反复强调，鸿蒙生态的真正价值在于，让开发者将时间投入到创新上，而非被底层适配问题所困扰。</p><p>加入领航者计划则为王丹辉提供了直接的资源支持，使得他能够在生态中精准对接，形成了一个“贡献—成长”的良性循环：通过持续贡献技术，精进自身能力，并在联动中获得更多支持和成长空间。这一实践不仅为开发者提供了成长的沃土，更为那些专注于垂直场景的小团队带来了实现创新梦想的机会。</p><h4><strong>结语</strong></h4><p>王丹辉的探索，向我们揭示了一个清晰的逻辑：创新，应该善用生态之力，专注擅长之事。这也是鸿蒙生态为每一位开发者铺就的成长通途。</p>]]></description></item><item>    <title><![CDATA[AI辅助开发大屏案例详解：基于smard]]></title>    <link>https://segmentfault.com/a/1190000047399788</link>    <guid>https://segmentfault.com/a/1190000047399788</guid>    <pubDate>2025-11-14 15:06:02</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>需求背景<br/>随着港口运营规模的不断扩大与信息化水平的提升，传统的数据报表与分散监控方式已难以满足实时感知、智能分析与高效决策的管理需求。港口管理部门亟需一种能够集中展示作业动态、实时监测异常情况、直观反映运营效率的数据可视化大屏解决方案。港口作业数据量大、指标多样、关联复杂，因此需要通过可视化手段，构建一个集数据整合、智能预警与交互分析于一体的运营指挥大屏。<br/>大屏介绍<br/>港口作业分析大屏旨在实现港口核心运营数据的全景可视化、实时监测与智能交互，主要包括以下核心模块：<br/>•告警信息中心：实时呈现港口异常事件，支持一键穿透处理；<br/>•船舶状态监测：通过表格与进度条直观展示船舶作业进度与吨位分布；<br/>•泊位利用率分析：通过指标卡与页签联动，实现多港口数据对比；<br/>•作业运行分析：支持船只类型与货物类型的图表下钻与切换展示。<br/>大屏通过多种图表组合、个性化样式设计与灵活的交互配置，实现了数据的高效传达与操作闭环。<br/>搭建步骤<br/>通过smardaten构建港口作业分析大屏，仅需以下四个核心步骤：<br/>1.大屏框架生成：利用AI指令快速生成大屏布局、图表与样式；<br/>2.样式优化：根据业务需求删减非必要指标，补充缺失模块并美化样式；<br/>3.组件配置与绑定：拖拽图表与交互组件，绑定数据资产并配置显示规则；<br/>4.交互事件配置：设置点击下钻、页签筛选、开关切换等交互逻辑，实现数据联动。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm2ZW" alt="" title=""/><br/>大屏设计<br/>1.AI生成大屏<br/>进入应用设计界面，唤起右下角的AI助手，输入大屏生成指令：“生成一个管理港口作业的大屏，包含货物吞吐量、船舶调度、泊位利用率等多个模块指标”<br/>输入大屏生成指令后，系统便会根据业务场景，完成大屏展示字段、所需图表、整体样式的设计工作。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm2ZX" alt="" title="" loading="lazy"/><br/>双击进入大屏配置后台，我们观察后发现，AI不仅精准还原了我们要求展示的全部核心指标，而且其生成的布局配色专业、图表类型选用得当，整体视觉效果与可用性均达到了较高水准。<br/>接下来，我们仅需调整部分展示内容，并补充图表交互，即可快速投入实际业务使用。<br/>2.船舶状态监测<br/>在完成大屏基础框架搭建后，我们发现缺少"船舶状态监测"这一核心业务场景。<br/>首先，通过AI指令快速删除原布局中不重要的指标项：“删除货物吞吐量分布、总吞吐量、港口任务分布、完成任务数、装卸背景、装卸标题组件”<br/><img width="723" height="346" referrerpolicy="no-referrer" src="/img/bVdm2Z5" alt="" title="" loading="lazy"/><br/>随后拖入表格组件，绑定船舶实时数据资产，手动隐藏"国籍"、"代理公司"等非核心字段，确保表格信息聚焦。<br/><img width="723" height="345" referrerpolicy="no-referrer" src="/img/bVdm20a" alt="" title="" loading="lazy"/><br/>然后我们利用AI调整表格尺寸：“调整普通表格宽度为914、高度为236”<br/><img width="723" height="348" referrerpolicy="no-referrer" src="/img/bVdm20h" alt="" title="" loading="lazy"/><br/>在样式优化方面，我们进行了多维度配置：<br/>•表头设置深色背景与白色加粗字体，文字居中显示，增强视觉层次感<br/>•为表格的奇数行和偶数行分别设置不同背景色，提升数据行的可读性<br/>•将"作业进度"列切换为"进度条"可视化模式，使得完成比例一目了然<br/>•为快速识别大吨位船舶，我们设置了特殊样式规则：当"吨数"字段值大于200时，该数字自动显示为醒目的红色并加粗<br/><img width="664" height="340" referrerpolicy="no-referrer" src="/img/bVdm20j" alt="" title="" loading="lazy"/><br/>经过这一系列配置，一个数据清晰、视觉直观、重点突出的船舶状态监测表格便已完成，实现了对在港船舶作业情况的实时监控与重点船舶的快速识别。<br/><img width="723" height="346" referrerpolicy="no-referrer" src="/img/bVdm20k" alt="" title="" loading="lazy"/><br/>3.港口告警信息<br/>在屏幕左侧区域的告警信息模块，我们采用画布组件实现更自由的布局与更直观的视觉呈现。<br/>双击进入画布配置界面，首先调整画布尺寸与间隔，并拖入告警标题、触发时间、发生位置等核心字段，逐一配置字体大小、颜色<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20l" alt="" title="" loading="lazy"/><br/>接下来，我们为每个告警字段配置了交互事件：点击任一告警信息，即可一键穿透至后台的告警处理列表，直接进行派单或关闭等处置操作，形成了从全局监控到精准处理的完整闭环。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20m" alt="" title="" loading="lazy"/><br/>针对"系统异常"这类高优先级告警，我们专门新增独立画布，设置醒目的红色字体与故障图标，并通过显示条件设置实现两类告警画布的差异化呈现。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20n" alt="" title="" loading="lazy"/><br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20o" alt="" title="" loading="lazy"/><br/>如此一来，不仅实现了告警信息的智能化展示，更确保了重点异常能够得到优先关注与快速处置。<br/><img width="723" height="420" referrerpolicy="no-referrer" src="/img/bVdm20u" alt="" title="" loading="lazy"/><br/>通过以上配置，港口作业效率排行榜成功实现了对各作业单位效率值的直观对比与动态展示，为管理人员的绩效评估与决策分析提供了有力的数据支撑。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20y" alt="" title="" loading="lazy"/><br/>5.泊位利用率<br/>在右上角的泊位利用率分析模块中，AI已自动配置了4个指标卡用于展示泊位占用率、平均作业时长、船主满意度和吞吐量等关键运营数据。我们针对船主满意度指标进行专项优化：<br/>•将数值调整为百分比显示，更符合业务阅读习惯<br/>•在指标左侧添加形象化的满意度图标，使数据表达更加直观<br/>•当满意度数值低于70%时，指标卡自动切换为灰色显示<br/><img width="658" height="426" referrerpolicy="no-referrer" src="/img/bVdm20z" alt="" title="" loading="lazy"/><br/>为实现指标卡显示多港口数据，我们在该模块上方添加了页签组件：<br/>分别配置各港口名称页签，并配置交互事件，当用户切换不同港口时，页签值作为筛选条件实时传入指标卡的数据资产中，驱动四个指标同步更新，精准展示对应港口的运营状况<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20C" alt="" title="" loading="lazy"/><br/>通过以上配置，泊位利用率分析模块不仅实现了关键指标的清晰展示，还具备了多港口数据对比与智能预警能力，为港口运营管理提供了有力的决策支持。<br/><img width="723" height="349" referrerpolicy="no-referrer" src="/img/bVdm20E" alt="" title="" loading="lazy"/><br/>6.港口作业运行分析<br/>在港口作业运行分析模块中，AI已通过柱状图清晰展示了各类船只的分布情况。我们在此基础之上，进一步增强了该模块的数据分析能力和交互体验。<br/>首先柱状图设置交互下钻规则：点击任一船只类型柱状图，即可穿透查看该类型船舶在各个港口的详细分布情况<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20F" alt="" title="" loading="lazy"/><br/>在同一个模块区域中，复用预先设计好的环形图模板，快速完成货物类别占比的可视化呈现<br/><img width="723" height="350" referrerpolicy="no-referrer" src="/img/bVdm20G" alt="" title="" loading="lazy"/><br/>通过两个开关组件实现同一区域的图表切换展示，节省大屏空间。将"船只分析"开关关联到船只类型柱状图，"货物分析"开关关联到货物类型环形图。并设置互斥显示规则，用户只需轻点开关，即可在船舶分析与货物分析两种视角间自由切换。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20H" alt="" title="" loading="lazy"/><br/>该模块通过柱状图下钻、环形图占比展示以及开关切换功能，实现了对港口作业运行情况的多维度、多层次分析，有效支撑了业务决策的数据需求。<br/>效果预览<br/>启动港口作业分析大屏后，整体视觉效果专业协调，各模块数据清晰呈现，交互响应流畅敏捷：<br/>•船舶状态监测表格中，作业进度以直观的进度条展示，大吨位船舶（吨数&gt;200）的数值自动红色加粗显示，重点船舶一目了然；<br/>•港口告警信息模块以自由布局形式呈现于左侧，不同类型告警通过颜色与图标差异化显示。<br/><img width="723" height="406" referrerpolicy="no-referrer" src="/img/bVdm20J" alt="" title="" loading="lazy"/><br/>点击任一告警信息，系统立即跳转至后台处理界面，实现从发现问题到处理问题的无缝衔接；<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20K" alt="" title="" loading="lazy"/><br/>•泊位利用率分析区域，点击上方港口页签，四个指标卡数据实时联动更新，满意度低于70%时自动变灰提示，有效支持多港口对比分析；<br/><img width="723" height="404" referrerpolicy="no-referrer" src="/img/bVdm20L" alt="" title="" loading="lazy"/><br/>•港口作业运行分析模块中，点击任一船只类型柱状图，即可下钻查看该类型在各港口的详细分布。<br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdm20M" alt="" title="" loading="lazy"/><br/>通过右侧开关，用户可轻松在"船舶分析"与"货物分析"视图间切换，同一区域实现双重分析维度。<br/><img width="723" height="406" referrerpolicy="no-referrer" src="/img/bVdm20O" alt="" title="" loading="lazy"/><br/>体验总结<br/>通过对港口作业分析大屏的完整搭建，我们充分体验到smardaten平台在数据可视化大屏开发中的显著优势：<br/>AI助力，高效起步：通过自然语言指令快速生成专业大屏框架，大幅降低初始设计成本，实现分钟级原型搭建。<br/>交互灵活，闭环可控：支持穿透、下钻、筛选、切换等多种交互方式，实现从数据展示到业务操作的完整闭环。<br/>样式丰富，视觉出众：提供细粒度样式配置，轻松实现进度条、渐变色彩、条件变色等专业视觉效果。<br/>配置灵活，维护便捷：通过拖拽调整、AI指令和条件规则，可快速响应业务变化，确保大屏长期实用价值。</p>]]></description></item><item>    <title><![CDATA[Vue + Axios + Node.j]]></title>    <link>https://segmentfault.com/a/1190000047399792</link>    <guid>https://segmentfault.com/a/1190000047399792</guid>    <pubDate>2025-11-14 15:05:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在前后端分离架构中，Vue 前端配合 Axios 发起请求，Node.js（Express）搭建后端服务时，可实现 Token 无感刷新以提升用户体验。具体而言，前端 Vue 项目通过 Axios 拦截器，在每次请求前检查 Token 状态。若 Token 即将过期，先向服务端发起静默刷新请求，Express 后端验证旧 Token 后颁发新 Token。前端拦截器收到新 Token 后，将其更新到本地存储，并重新发起原请求，整个过程对用户透明，无需手动重新登录。</p><h2>页面基本流程</h2><ol><li>登录成功后，后端返回 Access Token 和 Refresh Token，前端存储两者及各自有效期。</li><li>每次发起业务请求前，前端判断 Access Token 是否即将过期。</li><li>若即将过期，先调用 “刷新 Token 接口”，用有效的 Refresh Token 换取新的 Access Token。</li><li>用新的 Access Token 发起原业务请求，用户全程无感知。</li><li><p>若 Refresh Token 也过期，才会引导用户重新登录。</p><h2>一、技术栈与核心约定</h2></li><li>前端：Vue 3（适配 Vue 2，只需微调语法）+ Axios（统一请求拦截）</li><li>后端：Node.js + Express + JWT（生成 Token）+ Redis（存储 Refresh Token，可选但推荐）<br/>Token 规则：</li><li>Access Token：短期有效（1 小时），用于业务请求身份验证</li><li>Refresh Token：长期有效（7 天），仅用于刷新 Access Token</li><li><p>状态码：401 = Access Token 过期 / 无效；403 = Refresh Token 过期 / 无效</p><h2>二、前端实现（核心代码）</h2><h3>1. 初始化 Axios 实例（api/index.js）</h3><p>封装请求 / 响应拦截器，处理 Token 携带、刷新和重试逻辑:</p></li></ol><pre><code>import axios from 'axios';
import { ElMessage } from 'element-plus'; // 按需引入 UI 组件库提示（可选）

// 1. 创建 Axios 实例
const service = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL, // 环境变量配置后端地址
  timeout: 5000, // 请求超时时间
});

// 2. Token 存取工具函数（安全存储建议用 HttpOnly Cookie，此处用 localStorage 演示）
const TokenKey = {
  ACCESS: 'access_token',
  REFRESH: 'refresh_token',
};

// 获取 Token
const getAccessToken = () =&gt; localStorage.getItem(TokenKey.ACCESS);
const getRefreshToken = () =&gt; localStorage.getItem(TokenKey.REFRESH);
// 存储新 Token
const setTokens = (accessToken, refreshToken) =&gt; {
  localStorage.setItem(TokenKey.ACCESS, accessToken);
  localStorage.setItem(TokenKey.REFRESH, refreshToken);
};
// 清除 Token（退出登录用）
const removeTokens = () =&gt; {
  localStorage.removeItem(TokenKey.ACCESS);
  localStorage.removeItem(TokenKey.REFRESH);
};

// 3. 刷新状态管理（防止并发请求重复刷新 Token）
let isRefreshing = false; // 是否正在刷新 Token
let requestQueue = []; // 等待刷新完成的请求队列

// 4. 请求拦截器：自动给所有请求添加 Access Token
service.interceptors.request.use(
  (config) =&gt; {
    const token = getAccessToken();
    if (token) {
      // 规范格式：Bearer + 空格 + Token（后端需对应解析）
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) =&gt; Promise.reject(error)
);

// 5. 响应拦截器：处理 Token 过期逻辑
service.interceptors.response.use(
  (response) =&gt; response.data, // 直接返回响应体，简化业务层调用
  async (error) =&gt; {
    const { response, config } = error;
    const originalRequest = config; // 原始失败请求

    // 仅处理 401 状态码（Access Token 过期/无效），且排除刷新 Token 本身的请求
    if (response?.status === 401 &amp;&amp; originalRequest.url !== '/auth/refresh') {
      // 避免重复刷新：正在刷新时，将请求加入队列
      if (isRefreshing) {
        return new Promise((resolve) =&gt; {
          requestQueue.push(() =&gt; {
            // 刷新成功后，用新 Token 重试原始请求
            originalRequest.headers.Authorization = `Bearer ${getAccessToken()}`;
            resolve(service(originalRequest));
          });
        });
      }

      originalRequest._retry = true; // 标记该请求已进入重试流程
      isRefreshing = true; // 开启刷新状态

      try {
        // 调用后端刷新接口，用 Refresh Token 换取新 Token
        const refreshToken = getRefreshToken();
        if (!refreshToken) {
          throw new Error('Refresh Token 不存在');
        }

        const refreshRes = await service.post('/auth/refresh', {
          refreshToken, // 传给后端的 Refresh Token
        });

        // 存储新 Token
        const { accessToken, refreshToken: newRefreshToken } = refreshRes;
        setTokens(accessToken, newRefreshToken);

        // 重试队列中所有等待的请求
        requestQueue.forEach((callback) =&gt; callback());
        requestQueue = []; // 清空队列

        // 重试当前失败的请求
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return service(originalRequest);
      } catch (refreshError) {
        // 刷新失败（Refresh Token 过期/无效），强制跳转登录页
        removeTokens(); // 清除本地无效 Token
        ElMessage.error('登录已过期，请重新登录');
        window.location.href = '/login'; // 跳转到登录页
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false; // 关闭刷新状态
      }
    }

    // 非 401 错误（如网络错误、业务错误），直接抛出
    ElMessage.error(error.message || '请求失败');
    return Promise.reject(error);
  }
);

export default service;
</code></pre><h3>2. 登录与业务请求示例（api/user.js）</h3><pre><code>import service from './index';

// 登录：获取初始双 Token
export const login = (username, password) =&gt; {
  return service.post('/auth/login', { username, password });
};

// 业务请求示例（无需手动处理 Token）
export const getUserInfo = () =&gt; {
  return service.get('/user/info');
};

// 退出登录：清除 Token
export const logout = () =&gt; {
  localStorage.removeItem('access_token');
  localStorage.removeItem('refresh_token');
  window.location.href = '/login';
};
</code></pre><h3>3. 登录页面使用示例（Login.vue）</h3><pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;input v-model="username" placeholder="用户名" /&gt;
    &lt;input v-model="password" type="password" placeholder="密码" /&gt;
    &lt;button @click="handleLogin"&gt;登录&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue';
import { login } from '@/api/user';
import { ElMessage } from 'element-plus';

const username = ref('');
const password = ref('');

const handleLogin = async () =&gt; {
  try {
    // 调用登录接口，后端返回 accessToken 和 refreshToken
    const res = await login(username.value, password.value);
    // 存储 Token（实际已在 api 拦截器中处理，此处简化）
    localStorage.setItem('access_token', res.accessToken);
    localStorage.setItem('refresh_token', res.refreshToken);
    ElMessage.success('登录成功');
    window.location.href = '/home'; // 跳转到首页
  } catch (error) {
    ElMessage.error('登录失败，请检查账号密码');
  }
};
&lt;/script&gt;
</code></pre><h2>三、后端实现（Node.js + Express）</h2><h3>1. 依赖安装</h3><pre><code>npm install express jsonwebtoken redis cors dotenv // 核心依赖</code></pre><h3>2. 核心配置（config.js）</h3><pre><code>require('dotenv').config();

module.exports = {
  // JWT 密钥（生产环境需用环境变量，避免硬编码）
  JWT_SECRET: process.env.JWT_SECRET || 'your-secret-key-321',
  // Token 有效期
  ACCESS_TOKEN_EXPIRES: '1h', // 1 小时
  REFRESH_TOKEN_EXPIRES: '7d', // 7 天
  // Redis 配置（存储 Refresh Token，防止重复使用）
  REDIS: {
    host: 'localhost',
    port: 6379,
    db: 0,
  },
};
</code></pre><h3>3. JWT 工具函数（utils/jwt.js）</h3><pre><code>const jwt = require('jsonwebtoken');
const config = require('../config');

// 生成 Token
const generateToken = (payload, expiresIn) =&gt; {
  return jwt.sign(payload, config.JWT_SECRET, { expiresIn });
};

// 验证 Token
const verifyToken = (token) =&gt; {
  try {
    return jwt.verify(token, config.JWT_SECRET);
  } catch (error) {
    throw new Error('Token 无效或已过期');
  }
};

module.exports = { generateToken, verifyToken };
</code></pre><h3>4. Redis 工具函数（utils/redis.js）</h3><pre><code>const redis = require('redis');
const config = require('../config');

// 创建 Redis 客户端
const client = redis.createClient({
  host: config.REDIS.host,
  port: config.REDIS.port,
  db: config.REDIS.db,
});

// 连接 Redis
client.connect().catch((err) =&gt; console.error('Redis 连接失败:', err));

// 存储 Refresh Token（key: userId, value: refreshToken）
const setRefreshToken = async (userId, refreshToken) =&gt; {
  // 有效期与 Refresh Token 一致（7 天）
  await client.setEx(`refresh_token:${userId}`, 60 * 60 * 24 * 7, refreshToken);
};

// 获取 Refresh Token
const getRefreshToken = async (userId) =&gt; {
  return await client.get(`refresh_token:${userId}`);
};

// 删除 Refresh Token（退出登录时）
const deleteRefreshToken = async (userId) =&gt; {
  await client.del(`refresh_token:${userId}`);
};

module.exports = { setRefreshToken, getRefreshToken, deleteRefreshToken };
</code></pre><h3>5. 核心接口实现（routes/auth.js）</h3><pre><code>const express = require('express');
const router = express.Router();
const { generateToken, verifyToken } = require('../utils/jwt');
const { setRefreshToken, getRefreshToken, deleteRefreshToken } = require('../utils/redis');
const config = require('../config');

// 模拟用户数据库（实际替换为 MySQL/MongoDB）
const mockUsers = [
  { id: 1, username: 'admin', password: '123456' },
];

// 1. 登录接口：生成双 Token
router.post('/login', (req, res) =&gt; {
  const { username, password } = req.body;
  // 验证账号密码
  const user = mockUsers.find(
    (u) =&gt; u.username === username &amp;&amp; u.password === password
  );

  if (!user) {
    return res.status(400).json({ message: '账号或密码错误' });
  }

  // 生成双 Token（payload 中存储用户唯一标识，避免敏感信息）
  const accessToken = generateToken({ userId: user.id }, config.ACCESS_TOKEN_EXPIRES);
  const refreshToken = generateToken({ userId: user.id }, config.REFRESH_TOKEN_EXPIRES);

  // 存储 Refresh Token 到 Redis（用于后续验证）
  setRefreshToken(user.id, refreshToken);

  // 返回双 Token 给前端
  res.json({
    code: 200,
    message: '登录成功',
    data: { accessToken, refreshToken },
  });
});

// 2. 刷新 Token 接口：用有效 Refresh Token 换取新双 Token
router.post('/refresh', async (req, res) =&gt; {
  const { refreshToken } = req.body;
  if (!refreshToken) {
    return res.status(403).json({ message: 'Refresh Token 不能为空' });
  }

  try {
    // 1. 验证 Refresh Token 有效性
    const payload = verifyToken(refreshToken);
    const { userId } = payload;

    // 2. 验证 Redis 中存储的 Refresh Token 是否一致（防止伪造）
    const storedRefreshToken = await getRefreshToken(userId);
    if (storedRefreshToken !== refreshToken) {
      return res.status(403).json({ message: 'Refresh Token 无效' });
    }

    // 3. 生成新的双 Token
    const newAccessToken = generateToken({ userId }, config.ACCESS_TOKEN_EXPIRES);
    const newRefreshToken = generateToken({ userId }, config.REFRESH_TOKEN_EXPIRES);

    // 4. 更新 Redis 中的 Refresh Token（滑动过期，增强安全性）
    await setRefreshToken(userId, newRefreshToken);

    // 5. 返回新 Token
    res.json({
      code: 200,
      data: { accessToken: newAccessToken, refreshToken: newRefreshToken },
    });
  } catch (error) {
    return res.status(403).json({ message: 'Refresh Token 已过期，请重新登录' });
  }
});

// 3. 退出登录接口：删除 Redis 中的 Refresh Token
router.post('/logout', async (req, res) =&gt; {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(400).json({ message: 'Token 不能为空' });
  }

  try {
    const payload = verifyToken(token);
    await deleteRefreshToken(payload.userId);
    res.json({ code: 200, message: '退出登录成功' });
  } catch (error) {
    res.status(400).json({ message: '退出登录失败' });
  }
});

module.exports = router;
</code></pre><h3>6. 后端入口文件（app.js）</h3><pre><code>const express = require('express');
const cors = require('cors');
const authRouter = require('./routes/auth');

const app = express();
const port = 3001;

// 跨域配置（生产环境需限制 origin）
app.use(cors());
// 解析 JSON 请求体
app.use(express.json());

// 挂载路由
app.use('/api/auth', authRouter);

// 启动服务
app.listen(port, () =&gt; {
  console.log(`后端服务启动成功：http://localhost:${port}`);
});
</code></pre><p><a href="https://link.segmentfault.com/?enc=BKrIXZK9O8t%2BXga6Upc%2BJw%3D%3D.4NP%2BnloakcOOVIYrnqybiFIlUM02MnYpdgDl7dSem8Y%3D" rel="nofollow" target="_blank">https://mybj123.com/27766.html</a></p><h2>四、关键注意事项（生产环境必看）</h2><h4>1.安全存储 Token</h4><ul><li>不推荐用 localStorage 存储（易受 XSS 攻击），优先用 HttpOnly Cookie 存储 Refresh Token，前端无法读取，避免窃取。</li><li><p>Access Token 可存在内存（如 Vuex/Pinia），页面刷新后通过 Cookie 获取 Refresh Token 重新刷新。</p><h4>2.防止重复刷新</h4></li><li><p>用isRefreshing状态和requestQueue队列，避免多个并发请求同时触发刷新接口，导致 Token 冲突。</p><h4>3.Redis 的必要性</h4></li><li><p>存储 Refresh Token 到 Redis，支持 “强制登出”“单点登录” 功能（如修改密码后，删除 Redis 中的旧 Refresh Token，强制用户重新登录）。</p><h4>4.HTTPS 协议</h4></li><li><p>生产环境必须启用 HTTPS，防止 Token 在传输过程中被中间人窃取。</p><h4>5.Token 有效期合理设置</h4></li><li>Access Token：15 分钟～2 小时（越短越安全）。</li><li><p>Refresh Token：7~30 天（平衡安全性和用户体验）。</p><h2>五、完整流程梳理</h2></li><li>用户登录 → 后端验证账号密码 → 返回 Access Token 和 Refresh Token → 前端存储。</li><li>前端发起业务请求 → 拦截器自动携带 Access Token → 后端验证有效 → 返回业务数据。</li><li>若 Access Token 过期 → 后端返回 401 → 前端拦截器调用刷新接口。</li><li>刷新接口验证 Refresh Token 有效 → 返回新双 Token → 前端更新存储，重试原始请求。</li><li>若 Refresh Token 过期 → 前端清除 Token，跳转登录页。</li></ul>]]></description></item><item>    <title><![CDATA[详细指南：国科云全面解析SSL证书常见错]]></title>    <link>https://segmentfault.com/a/1190000047399814</link>    <guid>https://segmentfault.com/a/1190000047399814</guid>    <pubDate>2025-11-14 15:04:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>无论您是网站运维人员还是普通用户，了解常见的SSL证书错误及其解决方法都至关重要。本文，国科云将带您逐一排查并解决这些令人头疼的问题。</p><h2>一、证书过期</h2><p>错误现象：</p><p>浏览器显示“您的连接不是私密连接”、“此网站的安全证书已过期”或“NET::ERR_CERT_DATE_INVALID”等错误。</p><p>原因分析：</p><p>SSL证书并非永久有效，它有一个明确的有效期（目前最长为13个月）。一旦超过这个有效期，证书就会失效，浏览器将拒绝建立安全连接。这是出于安全考虑，强制定期验证网站身份和密钥更新。</p><p>解决方法：</p><p>1.对于网站所有者：</p><p>重新购买并部署证书：联系您的证书颁发机构（CA）或服务商，续费或购买一个新的证书。</p><p>完成验证：根据证书类型（DV，OV，EV）完成相应的域名或组织验证。</p><p>安装新证书：将新颁发的证书文件部署到您的Web服务器（如Nginx，Apache，IIS等）上。</p><p>重启服务：部署后，重启Web服务器服务以使新证书生效。</p><p>2.预防措施：</p><p>设置提醒：在证书到期前30天、15天、7天设置多次提醒。大多数证书服务商也提供邮件提醒服务。</p><p>自动化管理：对于DV证书，强烈推荐使用工具实现全自动申请和续期，一劳永逸。</p><p>使用监控工具：使用第三方网站监控服务或自建脚本，定期检查证书有效期。</p><h2>二、证书名称不匹配</h2><p>错误现象：</p><p>浏览器提示“此网站出具的安全证书是针对其他网站的地址”、“NET::ERR_CERT_COMMON_NAME_INVALID”。</p><p>原因分析：</p><p>SSL证书中有一个“通用名称”（CommonName，CN）字段，它必须与用户实际访问的网站域名完全一致。如果访问www.guokeyun.com，但证书是为guokeyun.com颁发的，就会触发此错误。</p><p>常见场景：</p><p>证书仅覆盖主域名（guokeyun.com），但用户访问了带www的域名（www.guokeyun.com），或反之。</p><p>证书是多域名或通配符证书，但当前访问的域名恰好不在证书的覆盖列表中。</p><p>服务器配置错误，将一个站点的证书用在了另一个域名的站点上。</p><p>解决方法：</p><p>1.检查证书覆盖的域名：使用在线SSL检查工具或浏览器自带的证书查看器，确认证书到底为哪些域名提供保护。</p><p>2.确保证书类型匹配需求：</p><p>如果同时有根域名和www域名访问需求，应申请同时包含example.com和www.example.com的多域名证书，或者申请覆盖.example.com的通配符证书。</p><p>3.检查服务器配置：确保Web服务器的虚拟主机配置正确，每个域名都指向了正确的网站目录并加载了对应的证书文件。</p><h2>三、证书颁发机构不受信任</h2><p>错误现象：</p><p>“此证书并非由可信的证书颁发机构颁发”、“NET::ERR_CERT_AUTHORITY_INVALID”。</p><p>原因分析：</p><p>浏览器和操作系统维护着一个“受信任的根证书颁发机构”列表。如果您的SSL证书是由一个不在这个列表中的机构（即“不受信任的CA”）签发的，或者证书链不完整，就会出现此错误。</p><p>具体原因：</p><p>自签名证书：自己创建的证书，未经公共信任的CA签名。常用于内部测试环境。</p><p>证书链不完整：SSL证书的信任是链式的：服务器证书→中间CA证书→根CA证书。如果服务器没有在配置中发送“中间CA证书”，浏览器可能无法追溯到受信任的根证书，从而导致验证失败。</p><p>使用了过时或不常见的CA：某些老旧的系统或特定区域的CA可能未被主流浏览器广泛信任。</p><p>解决方法：</p><p>1.从受信任的CA购买证书：确保您的证书来自全球或国内主流且被广泛信任的CA（如DigiCert，Sectigo，GlobalSign，或国内的CFCA、国科云等）。</p><p>2.安装中间证书：这是最常见的解决方案。当您从CA获取证书时，通常会得到一个或多个“中间CA证书”文件。您需要将这些中间证书与您的服务器证书捆绑在一起，并在Web服务器配置中正确指定这个捆绑后的文件。</p><p>可以使用在线SSL检查工具验证您的证书链是否已正确安装。</p><h2>四、缺乏主题备用名称</h2><p>错误现象：</p><p>在较老的浏览器上可能正常，但在现代浏览器（如Chrome）中访问IP地址或特定域名时，出现“名称不匹配”错误。</p><p>原因分析：</p><p>早期SSL证书只使用“通用名称”（CN）来标识域名。现代标准要求使用“主题备用名称”（SAN）扩展字段来列出所有受保护的域名。如果证书没有SAN字段，而浏览器又严格执行新标准，即使CN正确，也会报错。</p><p>解决方法：</p><p>申请新证书时，确保CA提供了SAN扩展。几乎所有正规的现代证书都默认包含此功能。</p><p>如果您需要保护多个不同的域名（例如example.com，example.net，ip.address），务必申请多域名证书（SAN证书），并在申请时明确列出所有需要的域名。</p><h2>五、混合内容</h2><p>错误现象：</p><p>浏览器地址栏虽然显示了HTTPS和小锁，但小锁上带有感叹号或三角警告，点击后显示“您与此网站之间建立的连接并非完全安全”或“此页面上有其他资源未使用安全连接”。</p><p>原因分析：</p><p>这是最常见且容易被忽略的问题。您的网页主体是通过HTTPS加载的，但页面中包含的子资源（如图片、JavaScript脚本、CSS样式表、iframe等）却是通过不安全的HTTP协议加载的。这被称为“混合内容”（MixedContent）。这会破坏整个页面的安全性，因为攻击者可能劫持这些HTTP资源来篡改页面内容。</p><p>解决方法：</p><p>1.识别混合内容：</p><p>使用浏览器开发者工具（按F12），查看“控制台”（Console）或“安全”（Security）标签页，通常会明确列出不安全的资源URL。</p><p>2.更新资源链接：</p><p>将页面中所有资源的引用链接（src或href属性）从http://改为https://。</p><p>如果第三方服务（如CDN、统计代码、字体库）不支持HTTPS，考虑寻找替代方案。</p><p>3.使用协议相对URL：将链接写成//example.com/resource.js，浏览器会自动根据当前页面的协议（HTTP或HTTPS）来加载资源。但请注意，这种方法在某些特定场景下已不推荐，直接使用HTTPS是更佳实践。</p><h2>六、其他常见错误</h2><p>服务器时钟不正确：如果服务器的时间设置错误（过快或过慢），浏览器在检查证书有效期时可能会误判证书“尚未生效”或“已过期”。确保服务器使用NTP服务进行时间同步。</p><p>浏览器缓存或问题：有时旧的证书信息或SSL状态会被浏览器缓存。尝试清除浏览器缓存和SSL状态。</p><p>Chrome方法：设置-&gt;隐私设置和安全性-&gt;清除浏览数据-&gt;高级-&gt;选择“缓存的图片和文件”以及“其他站点数据”。</p><p>SNI问题：如果一台服务器使用一个IP地址托管多个HTTPS网站，需要依赖“服务器名称指示”（SNI）技术来传递正确的证书。老旧的客户端不支持SNI，会导致收到错误的证书。如今这已不是大问题，但若需支持老旧设备，需考虑其他方案。</p><p>上面这几种情况基本涵盖了常见的SSL证书错误类型，通过本篇介绍，基本上具备了诊断和修复绝大多数SSL证书错误的能力。</p>]]></description></item><item>    <title><![CDATA[自动化技术演进：从工具执行到认知决策，A]]></title>    <link>https://segmentfault.com/a/1190000047399843</link>    <guid>https://segmentfault.com/a/1190000047399843</guid>    <pubDate>2025-11-14 15:03:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399846" alt="图片" title="图片"/><br/>自动化技术的发展从未停滞，从早期机械执行指令的工具，到如今能自主决策的AI智能体，企业的自动化能力正经历一场从“做什么”到“为什么做”的认知革命。这一技术框架，清晰勾勒出自动化的演进路径，帮我们理解不同技术的价值边界与应用场景。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399847" alt="图片" title="图片" loading="lazy"/><br/>自动化技术并非单一形态，而是呈现“传统自动化→AI自动化→AI智能体”的三级金字塔结构，每一层都解决不同维度的问题，创造差异化价值：1.传统自动化（1.0工具级）：“做什么”的机械执行这是自动化的“基础层”，核心是机械执行预设规则，没有智能决策能力。比如：人力资源的“入职流程触发”，新员工录入系统后自动发送入职指引邮件。它适合流程绝对固定、极少变化的场景，像仓储盘点、固定报销流程的第一步，用“稳定可靠”撑起业务的“基本盘”。2.AI自动化（2.0数据智能级）：“怎么做”的数据驱动这一层引入AI模型，聚焦半结构化数据处理与规则辅助决策。比如：智能工单审核：AI识别附件文本后，根据预设规则判断是否合规，给财务人员标红风险点；客户画像分析：AI整合多源数据，按规则生成客户分层，辅助营销决策。它像“智能助手”，把人工从数据处理的繁琐中解放出来，让决策更高效。3.AI智能体（3.0认知智能级）：“为什么做”的场景化决策这是自动化的“天花板”，具备自主决策与推理能力，能模拟人类岗位的全流程服务。比如：金融智能信贷助理：自主分析客户征信、流水数据，判断风险点，给出授信建议；智能客服主管：理解客户复杂需求，自主匹配产品营销，甚至预判客户潜在诉求。它能应对复杂、不确定的场景，实现“岗位级替代”，是企业智能化的核心突破口。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399848" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399849" alt="图片" title="图片" loading="lazy"/><br/>不同自动化技术并非竞争关系，而是根据业务场景选择“最适配方案”。容智信息的对比框架，清晰区分了两者的应用边界：传统自动化：锚定中后台的“稳定刚需”基于工作流构建的传统自动化，适合中后台业务的可靠、稳定特性：流程定义清晰、模式可预测（如每月固定的财务结账流程）；可靠性必须绝对保证（如薪资发放流程，不能有丝毫误差）；决策明确无模糊性（如“库存低于安全线则触发补货”的规则）。典型场景如仓储管理的库存盘点、核心系统的账务处理，用“精确控制”保障业务的稳定运行。AI智能体：激活前台的“交互创新”基于大语言模型（LLM）构建的AI智能体，适合前台业务的灵活、交互性强特点：面向客户：如智能导购能理解客户“想要一款适合通勤的轻便背包”的隐含需求，自主推荐产品；快速迭代：营销话术、服务流程可根据反馈快速调整，无需冗长的开发周期；适配不确定输入：面对客户千奇百怪的咨询问题，能自主推理、生成个性化回应。典型场景如智能客服、个性化营销、复杂业务的智能助理，用“自主决策”打造惊艳的用户体验。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399850" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399851" alt="图片" title="图片" loading="lazy"/><br/>自动化技术的演进并非“二选一”的替代博弈，而是根据业务场景的特性，精准选择适配技术的效能匹配艺术。企业需锚定场景需求——中后台流程依赖传统自动化保障稳定可靠，前台交互场景依托AI智能体突破体验边界，唯有如此，才能在自动化浪潮中实现全链路效能的最大化跃迁。简言之，没有“万能的自动化技术”，只有“场景适配的最优解”。</p><blockquote>互动讨论：你所在的行业或岗位中，更倾向用传统自动化实现流程固定、决策明确的中后台业务，还是用AI智能体探索创新？欢迎聊聊你对自动化技术应用的思考～</blockquote>]]></description></item><item>    <title><![CDATA[无需 iTunes 备份与恢复 iPho]]></title>    <link>https://segmentfault.com/a/1190000047399859</link>    <guid>https://segmentfault.com/a/1190000047399859</guid>    <pubDate>2025-11-14 15:02:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>​许多情况可能导致 iPhone 数据丢失，例如误删重要文件、iOS 更新失败、设备损坏，甚至手机被盗。如果你之前备份过 iPhone，就可以轻松从备份中恢复丢失的数据。然而，很多 iPhone 用户不喜欢使用 iTunes 来备份和恢复数据。iTunes 的主要缺点是它会用最近一次备份覆盖所有现有数据，这可能带来不便。此外，iTunes 有时运行不稳定。如果你没有安装 iTunes，或者根本不想使用它，本文将介绍两种替代方法，帮助你在无需 iTunes 的情况下备份和恢复 iPhone 数据。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399861" alt="图片" title="图片"/></p><h3>方法一：通过 iCloud 无需 iTunes 备份与恢复 iPhone</h3><p>iCloud 是苹果提供的免费云存储服务，默认提供 5GB 免费空间。如果需要更多空间，则需付费升级。当 iTunes 不可用时，iCloud 成为用户的首选。与 iTunes 不同，iCloud 无需在电脑上安装任何软件，操作更加便捷。但 iCloud 的备份与恢复速度较慢，急性子的用户建议直接跳至方法二。</p><p>如何使用 iCloud 备份 iPhone（无需 iTunes）</p><pre><code>打开 iPhone 并连接至稳定的 Wi-Fi 网络。
依次进入“设置” &gt; 你的姓名 &gt; “iCloud”。
确保“iCloud 云备份”已开启，如未开启请手动打开。
点击“立即备份”，开始将 iPhone 数据备份至 iCloud。

</code></pre><p>注意：iCloud 备份速度较慢，请耐心等待。备份完成后，可通过“设置” &gt; 你的姓名 &gt; “iCloud” &gt; “管理存储空间”查看备份内容。</p><p>如何使用 iCloud 恢复 iPhone（无需 iTunes）</p><pre><code>打开 iPhone，进入“设置” &gt; “通用” &gt; “传输或还原 iPhone” &gt; “抹掉所有内容和设置”。
设备将重启并进入初始设置界面。
在“App 与数据”界面，选择“从 iCloud 云备份恢复”。
登录你的 Apple ID，选择备份文件进行恢复。

</code></pre><p>如果你经常忘记手动备份，也可以开启 iCloud 自动备份功能：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399862" alt="图片" title="图片" loading="lazy"/></p><pre><code>进入“设置” &gt; 你的姓名 &gt; “iCloud” &gt; “iCloud 云备份”，确保已开启。
当设备连接 Wi-Fi 并接入电源时，系统会自动备份数据。

</code></pre><h3>方法二：使用 iReaShare iPhone Manager 无需 iTunes 备份与恢复 iPhone（推荐）</h3><p>如果你电脑上没有 iTunes，也不想使用 iCloud，那该怎么办？别担心，你可以选择第三方工具——iReaShare iPhone Manager。它是一款专业的 iOS 数据管理工具，可以快速、安全地将 iPhone、iPad 或 iPod 上的所有数据传输至电脑，反之亦然。它几乎可以实现 iTunes 的所有功能，甚至更加灵活。</p><p>iReaShare iPhone Manager 的主要功能：</p><pre><code>支持备份 iPhone 上的所有数据，包括联系人、短信、备忘录、日历、书签、音乐、视频、照片、书籍、应用等。
可一键完整备份，也可选择性备份所需内容（如仅备份联系人和照片）。
支持将数据导出至电脑或 iTunes 作为备份。
操作简单，几步即可完成备份与恢复。
兼容所有 iPhone 型号（如 iPhone 16/15/14/13/12/11/X/8/7/6）及所有 iPad 和 iPod 设备。

</code></pre><p>如何使用 iReaShare iPhone Manager 备份 iPhone（无需 iTunes）</p><p>步骤 1： 在电脑上安装并启动 iReaShare iPhone Manager，使用 USB 数据线连接 iPhone。软件将自动识别你的设备。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399863" alt="图片" title="图片" loading="lazy"/></p><p>步骤 2： 点击顶部菜单中的“超级工具箱”，进入“iTunes 备份与恢复”功能界面。</p><p>步骤 3： 选择“备份”选项，软件将列出所有已连接的 iOS 设备。选择你的 iPhone，并设置备份保存位置（默认或自定义）。</p><p>步骤 4： 点击“确定”开始备份 iPhone 数据。</p><p>如何使用 iReaShare iPhone Manager 恢复 iPhone（无需 iTunes）</p><p>步骤 1： 启动软件并连接 iPhone 至电脑，等待识别。</p><p>步骤 2： 点击顶部菜单中的“超级工具箱” &gt; “iTunes 备份与恢复” &gt; “恢复”。</p><p>步骤 3： 软件将列出所有备份记录，选择你想恢复的备份文件，点击“确定”开始恢复。你也可以选择性地备份数据。例如，若只想备份照片，可在左侧菜单中点击“照片”，预览并选择所需照片后，点击“导出”按钮，将其保存至电脑指定位置。</p><h3>总结</h3><p>现在你已了解两种无需 iTunes 备份与恢复 iPhone 的方法：</p><pre><code>iCloud：适合轻度用户，但备份速度慢，免费空间有限。
iReaShare iPhone Manager：功能强大，支持完整或选择性备份，速度快，不依赖网络，推荐优先使用。

</code></pre><p>立即下载试用吧！如果你还有其他无需 iTunes 快速备份/恢复 iPhone 的方法，欢迎留言分享！<br/>​</p>]]></description></item><item>    <title><![CDATA[一文讲清楚数据脱敏是什么 风流的滑板_L]]></title>    <link>https://segmentfault.com/a/1190000047399785</link>    <guid>https://segmentfault.com/a/1190000047399785</guid>    <pubDate>2025-11-14 15:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>很多企业在选择数据库管理系统时，通常会选择具有数据脱敏功能的软件。相信很多人会感到好奇，数据脱敏功能具体指向什么呢？为什么企业如此重视呢？简单来说，数据脱敏是指通过特定方法对敏感数据进行处理，使其在非生产环境中无法识别个人身份或关键信息，同时保持数据格式和部分特征，以支持开发、测试或分析等用途。在数字化时代，数据已成为企业的核心资产，而数据库作为存储和管理数据的关键系统，其安全性直接关系到隐私保护、合规运营和商业声誉。数据库信息安全不仅涉及防止外部攻击，还包括内部数据访问的严格控制。数据脱敏作为一种有效的数据保护技术，正日益成为数据库信息安全策略的重要组成部分。如果你想了解更多关于数据脱敏的定义、意义、类别及常用方法，不妨往下看看！<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm20v" alt="" title=""/><br/>1、什么是数据脱敏？<br/>数据脱敏，也称为数据匿名化或数据伪装，是一种数据安全技术，旨在保护敏感信息不被未授权访问。其核心原理是在保留数据实用性的前提下，对原始数据中的敏感字段进行变形、替换或屏蔽，从而生成一个“脱敏”后的数据集。例如，在数据库中将真实姓名替换为虚构名称，或将身份证号部分数字隐藏。数据脱敏不同于永久性销毁数据，它允许数据在脱敏后继续用于非敏感场景，如软件测试、数据分析或员工培训。通过数据脱敏，组织可以显著降低数据泄露风险，确保即使在数据共享或外包环境中，敏感信息也不会暴露。本质上，数据脱敏是数据库信息安全的第一道防线，它平衡了数据可用性与隐私保护的需求。<br/>举个例子，你有一张生产环境用户表：<br/><img width="723" height="169" referrerpolicy="no-referrer" src="/img/bVdm20B" alt="" title="" loading="lazy"/><br/>经过信息脱敏后：<br/><img width="723" height="158" referrerpolicy="no-referrer" src="/img/bVdm20D" alt="" title="" loading="lazy"/><br/>数据脱敏的意义不仅体现在技术层面，还涉及法律、商业和伦理等多个维度，数据脱敏不仅是一种技术措施，更是构建企业信任和推动可持续发展的基石。首先，从数据库信息安全的角度看，数据脱敏能够有效防止数据滥用和泄露。在内部开发或测试环境中，如果直接使用真实数据，一旦被员工或第三方误用，可能导致严重的隐私侵犯事件。通过实施数据脱敏，组织可以确保敏感数据在非生产环境中“去标识化”，从而降低内部威胁和意外风险。其次，数据脱敏是满足合规要求的关键手段法规明确要求，在非必要情况下，不得使用可识别个人身份的数据。数据脱敏通过匿名化处理，帮助企业遵守这些规定，避免高额罚款和法律纠纷。此外，在数据分析或机器学习项目中，使用脱敏数据可以加快数据共享流程，同时保护核心商业机密。例如，电商企业可以通过数据脱敏分析用户行为模式，而无需暴露具体交易细节。3、数据脱敏的类别根据应用场景和处理方式，数据脱敏可以分为静态数据脱敏和动态数据脱敏两大类。我们可以将“静态脱敏”理解为“搬家”，即适用于数据迁移、备份或测试等场景，它在数据存储阶段对原始数据集进行永久性处理，生成一个脱敏后的副本。例如，将生产数据库中的客户数据导出为测试数据时，通过替换或扰乱敏感字段，确保副本中不包含真实信息。这种方法常用于离线环境，操作简单且效率高，但需要定期更新以反映数据变化。<br/><img width="723" height="273" referrerpolicy="no-referrer" src="/img/bVdm20I" alt="" title="" loading="lazy"/><br/>动态数据脱敏则可以理解为“戴面具”，更侧重于实时保护，它在数据访问过程中动态地对敏感信息进行脱敏。例如，当用户查询数据库时，系统根据用户权限实时隐藏或修改部分数据。假设一个客服人员需要查看客户信息，动态数据脱敏可能只显示电话号码的后四位，而隐藏其他数字。这种方法适用于在线交易系统或多租户数据库，能够在不改变底层数据的前提下，实现精细化的访问控制。<br/>4、数据脱敏的常用方法<br/>数据脱敏的常用方法多样，从简单的替换到复杂的加密技术，每种方法都有其适用场景。简单为大家介绍六种方法：替代法、屏蔽法、扰乱法、加密法、泛化法、合成法。<br/>● 替换法：这是最常见的数据脱敏方法，通过将敏感数据替换为虚构但格式一致的值。例如，将真实姓名替换为随机生成的假名，或将邮箱地址替换为通用模板。替换法简单高效，能保持数据的一致性，适用于测试环境。然而，它可能无法完全隐藏数据模式，因此在高度敏感场景中需结合其他方法。<br/>● 屏蔽法：屏蔽法通过隐藏部分数据内容来实现数据脱敏，例如只显示身份证号的前几位，其余用星号代替。这种方法常用于动态数据脱敏，如在用户界面上实时屏蔽敏感信息。它操作简便，但对数据实用性的影响较大，可能不适合需要完整数据格式的场景。<br/>● 扰乱法：扰乱法通过随机化或重排数据顺序来破坏原始信息的可读性。例如，将日期字段中的年份和月份交换，或将数值数据乘以一个随机因子。这种方法能有效保护隐私，但可能改变数据分布，影响统计分析结果。因此，它常用于非关键性测试。<br/>● 加密法：加密法作为数据加密的方法之一，在数据脱敏中扮演重要角色。它使用加密算法（如 AES 或 RSA）将敏感数据转换为密文，只有授权用户才能通过密钥解密。加密法适用于可逆脱敏场景，如数据共享或备份。然而，它计算开销较大，可能影响数据库性能，因此需权衡安全与效率。<br/>● 泛化法：泛化法通过降低数据精度来实现数据脱敏，例如将具体年龄替换为年龄段（如“ 20-30 岁”），或将详细地址替换为城市名。这种方法在保持数据统计价值的同时，有效保护个人隐私，常用于研究或报告场景。<br/>● 合成法：合成法通过生成人工数据来替代真实数据，这些数据基于原始分布生成，但不对应任何真实个体。例如，使用算法生成虚拟客户记录。这种方法在机器学习和测试中广泛应用，能最大程度降低泄露风险，但需要复杂的建模技术。<br/>5、结语<br/>数据脱敏作为数据库信息安全的核心技术，不仅能够有效防范数据泄露风险，还能助力企业满足法规要求和提升商业价值。从静态到动态脱敏，从替换到加密方法，数据脱敏的多样化为不同场景提供了灵活解决方案。相信你已经对数据脱敏有了一定的认识了解，如果你需要进一步选择相应系统，可以自行寻找合适的数据库管理系统，市面上大多数数据库工具都有数据脱敏的功能，希望这篇文章对你了解数据脱敏有所帮助～</p>]]></description></item>  </channel></rss>