<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[揭秘 AI 推理：OpenAI 稀疏模型让神经网络首次透明化 超神经HyperAI ]]></title>    <link>https://segmentfault.com/a/1190000047543609</link>    <guid>https://segmentfault.com/a/1190000047543609</guid>    <pubDate>2026-01-15 11:12:45</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>近年来，大语言模型在能力上突飞猛进，但其内部决策过程如同一个深度纠缠的「黑箱」，难以追溯和理解。这一根本性难题，严重阻碍了AI在医疗、金融等高风险领域的可靠应用。<strong>如何让模型的思考过程变得透明、可追溯，仍是悬而未决的关键问题。</strong></p><p>基于此，<strong>OpenAI 于 2025 年 12 月发布的 0.4B 参数大语言模型 Circuit Sparsity，它采用电路稀疏技术，将 99.9% 的权重置零，构建出可解释的稀疏计算架构，</strong> 突破传统 Transformer 的「黑箱」决策限制，使 AI 推理过程可逐层解析。该模型的核心，是通过一套独特的训练方法，将传统密集神经网络改造为结构化的稀疏「电路」。</p><p>*<strong>动态强制稀疏</strong>：与传统方法不同，它在训练的每一步都执行「动态剪枝」，每轮仅保留权重中绝对值最大的极少数（如0.1%），其余强制归零，迫使模型从一开始就学习在极简连接下工作。</p><p>*<strong>激活稀疏化</strong>：在注意力机制等关键位置引入激活函数，使神经元的输出趋于「非此即彼」的离散状态，从而在稀疏网络中形成清晰的信息通道。</p><p>*<strong>定制化组件</strong>：采用 RMSNorm 替代 LayerNorm 以防止破坏稀疏性；并引入 Bigram 查找表来处理简单词汇预测，让主网络更专注于复杂逻辑。</p><p>通过上述方法训练出的模型，其内部自发形成了功能明确、可被解析的「电路」。每个电路负责一个特定子任务。研究人员可明确识别出，某些神经元专门用于检测「单引号」，而另一些则充当逻辑「计数器」，相比传统密集模型，完成相同任务所需的活跃节点数量大幅减少。<strong>其配套的「桥梁网络」 技术，试图将稀疏电路中获得的解释映射回 GPT-4 等高性能密集模型，也为分析现有大模型提供了潜在工具。</strong></p><p>目前，HyperAI超神经官网已上线了「Circuit Sparsity：OpenAI 开源新稀疏模型」，快来试试吧\~</p><p><strong>在线使用：<em><a href="https://link.segmentfault.com/?enc=yfe%2BUTm3wRMSsMcvn%2FHtmw%3D%3D.8QAz%2B7F%2FWfNecuK2wfx1oqop3i3UJkbQdsnxDiDoqM3dU5%2FN4G1Y%2B7hS9c6uGZLspZpS9sfMQgh5ml6gjaSYqg%3D%3D" rel="nofollow" target="_blank">https://go.hyper.ai/WgLQc</a></em></strong></p><p><strong>1 月 5 日-1 月 9 日，hyper.ai 官网更新速览：</strong></p><ul><li>优质教程精选：4 个</li><li>热门百科词条：5 条</li><li>1 月截稿顶会：9 个</li></ul><p><strong>访问官网：<em>hyper.ai</em></strong></p><p><strong>公共教程精选</strong></p><p><strong>1.Circuit Sparsity：OpenAI 开源新稀疏模型</strong></p><p>Circuit-sparsity 是 OpenAI发布的 0.4B 参数大语言模型。它采用电路稀疏技术，将 99.9% 的权重置零，构建出可解释的稀疏计算架构，突破传统 Transformer 的「黑箱」决策限制，使 AI 推理过程可逐层解析。随模型发布的 Streamlit 工具包提供「激活桥」技术，支持研究者追踪内部信号路径、分析功能对应电路，并比较稀疏与密集模型的性能差异。</p><p><strong><em>在线运行：<a href="https://link.segmentfault.com/?enc=jLwF5YtAEOEsR6BScRBXjg%3D%3D.49GMOKYM4dhDb%2BCZq%2FWHFUILGliTMey%2BhBBF6ruxenKkQbJtH2iOYCUYXUp6FqBGiqVmH0lgMQTzmlQ4Z3%2Fejg%3D%3D" rel="nofollow" target="_blank">https://go.hyper.ai/zui8w</a></em></strong></p><p><img width="723" height="269" referrerpolicy="no-referrer" src="/img/bVdnEqt" alt="" title=""/><br/>Demo 页面</p><p><strong>2.HY-MT1.5-1.8B：多语言神经机器翻译模型</strong></p><p>HY-MT1.5-1.8B 是腾讯混元团队发布的 18 亿参数多语言机器翻译模型。它基于统一 Transformer 架构，支持 33 种语言与 5 种民族语言/方言的互译，并针对混合语言、术语控制等真实场景优化。该模型在接近 7B 模型翻译质量的同时，参数规模仅为三分之一，支持量化部署与 HuggingFace 生态集成，适用于高效、低成本的多语言在线翻译服务。</p><p><strong><em>在线运行：<a href="https://link.segmentfault.com/?enc=xWChw7F5wtealby10eko3g%3D%3D.uJSAWKWOU%2Bq925xsVOuMh2J2ch%2B5MbNXQb1ziFW%2Buo9o3%2FyJSFRRiHnsC4YcJH4AhsZqLTjyBTyQk8FUu8yrVA%3D%3D" rel="nofollow" target="_blank">https://go.hyper.ai/I0pdR</a></em></strong></p><p><img width="723" height="328" referrerpolicy="no-referrer" src="/img/bVdnEqu" alt="" title="" loading="lazy"/></p><p>Demo 页面</p><p><strong>3.AWPortrait-Z 肖像美术 LoRA</strong></p><p>AWPortrait-Z 是一款基于 LoRA 技术的肖像增强模型。它作为插件与主流文生图扩散模型结合，无需重训基础模型，即可显著提升人像生成的真实感与摄影质感。该模型专门优化了面部结构、肤质纹理与光影氛围的渲染，生成效果更自然、细腻，适用于需要摄影级真实感的人像创作与图像合成。</p><p><strong><em>在线运行：<a href="https://link.segmentfault.com/?enc=P%2FK3fX5fL%2BdoaxD054FigQ%3D%3D.J8%2B%2B9tZKqwPLFNe69OV8vJsSuOqT7Y5l4L5zDJnoVb%2BtaXTx5ZWdZXGRnQ%2FHeb4jeVtXKLNpAjHtNeb5aACJyA%3D%3D" rel="nofollow" target="_blank">https://go.hyper.ai/wRjIp</a></em></strong></p><p><img width="723" height="387" referrerpolicy="no-referrer" src="/img/bVdnEqv" alt="" title="" loading="lazy"/></p><p>Demo 页面</p><p><strong>4.Granite-4.0-h-small 一站式进行多语言对话与代码任务</strong></p><p>Granite-4.0-h-small 是 IBM 发布的 32 亿参数长上下文指令微调模型。它基于基础模型微调，融合开源与合成数据，采用监督微调、强化学习对齐及模型合并技术。该模型具有优秀的指令遵循与工具调用能力，采用结构化对话格式，专为高效的企业级应用场景优化。</p><p><strong><em>在线运行：<a href="https://link.segmentfault.com/?enc=dPIRbBXTO11QOsf8qF1w7A%3D%3D.Up20sJ5wWtBQFmCbG9xAiwSUnQI9AwWLTM0IFUdAXC9i0jU6iVwKXmztaVUgMZF5RCYl9KOo7JtRruWWf62l6Q%3D%3D" rel="nofollow" target="_blank">https://go.hyper.ai/1HhB9</a></em></strong></p><p><img width="723" height="334" referrerpolicy="no-referrer" src="/img/bVdnEqw" alt="" title="" loading="lazy"/></p><p>Demo 页面</p><p><strong>热门百科词条精选</strong></p><p><strong>1. 人机回圈 HITL</strong></p><p><strong>2. 超倒数排序融合 RRF</strong></p><p><strong>3. 具身导航 Embodied Navigation</strong></p><p><strong>4. 多层感知机 Multilayer Perceptron</strong></p><p><strong>5. 强化微调 Reinforcement Fine-Tuning</strong></p><p>这里汇编了数百条 AI 相关词条，让你在这里读懂「人工智能」：</p><p><strong><em><a href="https://link.segmentfault.com/?enc=MMPcb9h92JijYvX%2F753jMw%3D%3D.Ge13Fbewjl3xj55vcXgnBF5IT1DPIIFsBg5GaYAXH9GN1kDHI4yDLiPyMeezk1%2F8gUzDcEtoMu67boW5TGZ6TA%3D%3D" rel="nofollow" target="_blank">https://go.hyper.ai/wiki</a></em></strong></p><p><img width="599" height="1008" referrerpolicy="no-referrer" src="/img/bVdnEqx" alt="" title="" loading="lazy"/></p><p>一站式追踪人工智能学术顶会：<strong><em><a href="https://link.segmentfault.com/?enc=5IdIq3TUmR3g3H049mMRHA%3D%3D.D3Qq7QngQuWqtlh4M6mZvhG%2Bvh9OXJZ4OzUztY%2FXSsp4uJGebLm6SrigG3bbaO83PUTtKlX1CZymu%2Bw6wEhO3g%3D%3D" rel="nofollow" target="_blank">https://go.hyper.ai/event</a></em></strong></p><p>以上就是本周编辑精选的全部内容，如果你有想要收录 hyper.ai 官方网站的资源，也欢迎留言或投稿告诉我们哦！</p><p>下周再见！</p>]]></description></item><item>    <title><![CDATA[『NAS』干净无广的网易云音乐播放器-SPlayer 德育处主任 ]]></title>    <link>https://segmentfault.com/a/1190000047543802</link>    <guid>https://segmentfault.com/a/1190000047543802</guid>    <pubDate>2026-01-15 11:12:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p><blockquote>整理了一个NAS小专栏，有兴趣的工友可以关注一下 👉 <a href="https://link.segmentfault.com/?enc=P8pjJW5Q8mFxKDNfmBuAjA%3D%3D.NVOUeq2M7BsVBX1Z%2By1Srz3BkirLtzCA1nTNw0ZjH1SAAQbtx5JSUBEsi1lOCveydHfsqwbkMZhRdOtxIT3AkseIkCM5b4PXSD5VZRbsac8mPG4RTZeKcLxe83HkDRVu8%2FLRSJuSCBiZ6K%2FDYAcNRksxJogqV%2FdN6T8lDFNHMD0%3D" rel="nofollow" target="_blank">《NAS邪修》</a></blockquote><p>SPlayer 是一款没有广告，非常纯净的音乐播放器。SPlayer 部分功能使用了网易云的服务，支持本地部署。如果你不喜欢用浏览器播放音乐，SPlayer 还提供了 Windows 和 Mac 的客户端。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543804" alt="" title=""/></p><p>SPlayer 除了无广，其他功能和网易云音乐一样，为什么还要推荐 SPlayer 呢？</p><p>因为作者还在不断完善它（在写本文时，发现 SPlayer 作者9小时前更新代码）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543805" alt="" title="" loading="lazy"/></p><p>我还相信作者画的饼。虽然现在功能还不完善，虽然现在还不支持播放本地音乐的功能，但它应该会实现的，应该会的🐶。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543806" alt="" title="" loading="lazy"/></p><p>SPlayer 客户端的下载地址我放这 ⬇️ 选择你喜欢的版本，根据你电脑系统下载即可。</p><p><a href="https://link.segmentfault.com/?enc=zF%2Bzj9EnJJNpVbWEKcxvPA%3D%3D.bno9QUNZnRtdAUtiLflirjIDMTURTrr2GuolTz%2FKsbRDTjOLQEDPehhIbPC5FzbY" rel="nofollow" target="_blank">https://github.com/imsyy/SPlayer/tags</a></p><p>本文使用 Docker 将 SPlayer 部署到 NAS 上，这次用的是群晖的NAS。</p><p>按照国际惯例，先在 docker 文件夹下创建一个 SPlayer 文件夹。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543807" alt="" title="" loading="lazy"/></p><p>打卡“Container Manager”，创建一个新项目。</p><p>相关配置如下图所示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543808" alt="" title="" loading="lazy"/></p><p>输入以下代码（注意换行以及每行代码前面有多少个空格）。</p><pre><code>services:
 SPlayer:
  image: imsyy/splayer:latest
  container_name: SPlayer
  ports:
   - 25884:25884
  restart: always</code></pre><p>“网页门户设置”开启“通过 Web Station 设置网页门户”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543809" alt="" title="" loading="lazy"/></p><p>接着在“Web Station”创建一个“网络门户”。</p><p>“服务”这项选择“splayer”，配置一个没使用过的端口。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543810" alt="" title="" loading="lazy"/></p><p>最后在浏览器输入你NAS的IP地址加上上图配置的端口号，就能使用 SPlayer 了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543811" alt="" title="" loading="lazy"/></p><hr/><p>以上就是本文的全部内容啦，想了解更多NAS玩法可以关注<a href="https://link.segmentfault.com/?enc=4%2F22SDfqz5tSTCrColwGUg%3D%3D.pIsDv1E%2FX0tu2uI7q5vTeIuMFocM6iODHJfKgR4ZgSTSSUmZOJOksdC1sc8afuNORIbZ7Q2yWvr2%2FPLLeEmg%2BRyGj0kkamghGr9xWzKQFi5MW8vAEAJBU8sG0xZNGXuY%2F6UDky63xgpNCjQtQd1795xIjVVEIRVhxCPBtC6yATc%3D" rel="nofollow" target="_blank">《NAS邪修》</a></p><p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p>]]></description></item><item>    <title><![CDATA[实时协同 + 多人评论！SpreadJS V19.0 重新定义团队表格协作 葡萄城技术团队 ]]></title>    <link>https://segmentfault.com/a/1190000047543867</link>    <guid>https://segmentfault.com/a/1190000047543867</guid>    <pubDate>2026-01-15 11:11:31</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>实时协同 + 多人评论！SpreadJS V19.0 重新定义团队表格协作</h2><p>在数字化转型加速的今天，远程办公渗透率已超 40%，表格作为企业数据协同的核心载体，广泛应用于预算编制、项目管理、数据汇总等关键场景。但传统“单人编辑-邮件传输”的协作模式，早已跟不上跨地域、跨部门的协作需求，成为效率提升的绊脚石。</p><p>而 SpreadJS V19.0 的新版本，带来了<strong>协同编辑插件</strong>与<strong>线程评论</strong>两大核心功能，直击传统协作痛点，让表格协作从“混乱低效”走向“有序高效”，甚至实现预算编制周期缩短 60% 以上、项目延期率降低 30%的显著提升！</p><h3>一、传统表格协作的 3 大“效率死穴”</h3><p>你是否也经历过这些崩溃瞬间？</p><ul><li>版本混乱失控：“最终版 v2”、“确认版最终版”、“领导修改版”等文件堆积如山，来回传输导致信息不同步，甚至因误用旧版本造成决策误判；</li><li>协作效率低下：多人只能轮流编辑，等待周期漫长，交叉填报场景下流程推进效率直接降低 50%以上；</li><li>权限管控薄弱：无法精细分配操作权限，财务数据、检测报告等敏感信息易泄露，合规性难以保障。</li></ul><p>这些问题不仅消耗大量时间成本，更可能因数据滞后、信息遗漏影响业务推进。而 SpreadJS V19.0 的核心功能，正是为解决这些痛点而来。</p><h3>二、SpreadJS V19.0 核心突破：协同+评论，重塑协作体验</h3><p>如果说传统表格是“单人作战工具”，那么 SpreadJS V19.0 就是“团队协同平台”——通过<strong>协同编辑插件</strong>实现“实时共编、权限可控、版本可溯”，再以<strong>线程评论</strong>让表格内讨论“精准闭环、有据可查”，两者相辅相成，彻底改变团队协作模式。</p><h4>（一）协同编辑插件：3 大能力破解协作难题</h4><p>协同编辑插件以“原生级 Excel 体验”为基础，构建了从编辑、同步到管控的全链路协作体系，三大核心优势直击痛点：</p><h5>1. 版本管理：告别“文件命名大战”</h5><p>无需手动保存多个版本，系统自动生成版本快照，记录每一次编辑的用户、时间与修改内容。支持可视化对比不同版本差异，一键回溯历史版本，彻底杜绝数据丢失风险；还能为重要节点添加命名与备注，关键修改一目了然。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543869" alt="img" title="img"/></p><h5>2. 实时同步：多人并行编辑，效率提升 60%+</h5><p>打破“单人编辑”限制，支持团队多人同时操作同一工作簿，所有修改实时同步无延迟。系统通过 OT 逻辑智能处理并发冲突，哪怕多人修改同一单元格，也能自动保持数据一致性；还能显示协作者的光标与选择区域，让你实时感知他人操作，避免重复劳动。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543870" alt="img" title="img" loading="lazy"/></p><p>对比传统轮流编辑模式，协作效率直接提升 60%以上，多人交叉填报场景下再也不用漫长等待。</p><h5>3. 权限控制：精细化管控，数据安全无死角</h5><p>支持从单元格、行、列到工作表的多级权限设置，灵活定义“编辑者”与“查看者”角色：编辑者可增删改数据、解决评论，查看者仅能浏览无操作权限；敏感数据可智能隐藏，未授权用户无法查看，配合完整操作日志记录，变更轨迹全程可追溯，完全满足合规要求。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543871" alt="img" title="img" loading="lazy"/></p><h4>（二）评论：让表格里的讨论“闭环可控”</h4><p>表格数据往往需要进一步沟通确认，但传统评论功能无法形成有效讨论链路。而 SpreadJS V19.0 的线程评论，让每一次讨论都“精准、可追溯、能闭环”：</p><ul><li>结构化线程：围绕特定单元格数据发起讨论，多用户回复按时间顺序排列，形成清晰“对话链路”，避免讨论分散；</li><li>@提及通知：在回复中@协作者，直接触发通知，快速唤醒相关人员参与，杜绝信息遗漏；</li><li>状态标记：支持将评论标记为“已解决”或“重新打开”，配合紫色/灰色旗帜区分状态，问题处理进度一目了然，确保每个疑问都能闭环；</li><li>丰富内容块：回复支持文本、超链接、用户提及等多种形式，复杂信息也能灵活表达，还能复制、剪切、粘贴评论，便于内容复用。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543872" alt="img" title="img" loading="lazy"/></p><p>更重要的是，评论与 Excel 高度兼容，支持数据导入导出，同时提供完善 API，可轻松集成到现有业务系统，满足二次开发需求。</p><h3>三、场景实测：2 大核心场景，效率翻倍验证</h3><p>功能好不好用，场景说了算！SpreadJS V19.0 在企业财务、项目管理两大核心场景中，交出了“量化级”的效率提升答卷：</p><h4>（一）企业财务：预算编制周期缩短 67%</h4><p>集团公司预算编制时，往往需要总部、子公司多个部门交叉填报数据，传统模式下“填报-汇总-审核-修改”全流程需 15 天：</p><ul><li>子公司逐个填报后邮件发送，总部手动汇总易出错；</li><li>审核发现问题需重新退回修改，来回传输耗时久；</li><li>多版本文件混淆，难以追溯修改源头。</li></ul><p>而使用 SpreadJS V19.0 后：</p><ul><li>多部门同时在线填报，数据实时同步，自动汇总校验；</li><li>审核员通过线程评论直接标注问题，@相关负责人即时修改，无需退回重发；</li><li>版本自动记录，修改轨迹可追溯，合规性达标。</li></ul><p>最终预算编制周期从 15 天缩短至 5 天，效率提升 67%！</p><h4>（二）项目管理：项目延期率降低 30%</h4><p>跨部门项目进度跟踪中，传统表格协作常因“信息不同步、问题难跟踪”导致延期：</p><ul><li>开发、测试、运营团队分开记录进度，数据更新滞后；</li><li>风险问题通过即时通讯工具沟通，分散无追溯；</li><li>资源分配调整需反复同步，易出现冲突。</li></ul><p>而 SpreadJS V19.0 带来的改变：</p><ul><li>项目经理、团队成员实时更新任务进度，资源分配数据即时同步；</li><li>遇到风险问题时，在对应任务单元格发起线程评论，@相关负责人，标注“待解决”状态，处理进度全程可见；</li><li>协同编辑插件自动解决交叉修改冲突，资源调整无矛盾。</li></ul><p>项目延期率直接降低 30%，团队协作更顺畅。</p><h3>四、传统协作 vs SpreadJS V19.0：一张表看懂差距</h3><table><thead><tr><th align="left">对比维度</th><th align="left">传统表格协作</th><th align="left">SpreadJS V19.0 协作模式</th></tr></thead><tbody><tr><td align="left">版本管理</td><td align="left">多文件命名混乱，易误用</td><td align="left">自动快照+历史版本，一键回溯</td></tr><tr><td align="left">协作效率</td><td align="left">单人轮流编辑，效率低 50%+</td><td align="left">多人并行编辑，效率提升 60%+</td></tr><tr><td align="left">权限控制</td><td align="left">无精细化管控，敏感数据易泄露</td><td align="left">单元格级权限，角色区分明确</td></tr><tr><td align="left">讨论追溯</td><td align="left">评论分散，无闭环，难追溯</td><td align="left">线程化讨论，@提及+状态标记，闭环可控</td></tr><tr><td align="left">数据安全</td><td align="left">操作无日志，合规性难保障</td><td align="left">全程操作日志，变更轨迹可追溯</td></tr></tbody></table><h3>五、不止于协同：这些新功能同样值得关注</h3><p>除了核心的协同编辑与线程评论，SpreadJS V19.0 还带来了多项提升体验的新功能：</p><ul><li>单元格两端对齐：支持水平/垂直两端对齐，自动换行适配合并单元格，满足 PDF 与排版高标准需求；</li><li>WebWorker 增量计算：1400 万公式单元格计算不卡顿，主线程无压力，计算性能提升近一倍；</li><li>新图表类型：新增瀑布图（分析利润变动、预算差异）、K 线图/OHLC 图表（金融数据可视化），满足更多场景数据分析需求。</li></ul><h3>结语：立即体验，解锁团队协作新效率</h3><p>SpreadJS V19.0 以“协同编辑插件+评论”为核心，不仅解决了传统表格协作的三大痛点，更通过量化的效率提升、精细化的权限管控、闭环式的讨论体验，重新定义了团队表格协作的标准。</p><p>无论是企业财务的预算编制、项目管理的进度跟踪，还是计量检测的数据填报、市场调研的信息汇总，SpreadJS V19.0 都能让协作更高效、更安全、更可控。</p><p>👉 立即点击体验协同编辑 Demo：<a href="https://link.segmentfault.com/?enc=06TnaU5jzIYAe4rpWkU5LQ%3D%3D.UC0WkKMsnwGkar4wdQh5vrb1nl7wGlMos6JsfokX7VOlajwbzuST0SA71BNQ5smcjyFQs84Y1BgPPnXQNDD5eJYT3sXb9OdTluEzenJJHP4%3D" rel="nofollow" target="_blank">https://demo.grapecity.com.cn/spreadjs/demos/collaboration/login</a></p><h3>扩展链接</h3><p><a href="https://link.segmentfault.com/?enc=lolplhiL0ds0oEES1d7DAw%3D%3D.rH0OAHIQlmuvwTkwagf%2BwC9O7kEi7ha73%2Bjlsf9NT5TRi1RYPfjdWk5xf87a2ONx" rel="nofollow" target="_blank">可嵌入您系统的在线Excel</a></p>]]></description></item><item>    <title><![CDATA[鸿蒙 HarmonyOS 6 | ArkUI (06)：表单交互 TextInput、Toggle、]]></title>    <link>https://segmentfault.com/a/1190000047543914</link>    <guid>https://segmentfault.com/a/1190000047543914</guid>    <pubDate>2026-01-15 11:10:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h3>前言</h3><p>如果说我们之前学习的布局容器是构建应用的骨架，那么表单组件就是应用的神经末梢，它们负责感知用户的意图并收集数据。无论是简单的登录注册、复杂的个人信息编辑，还是系统设置中的各种开关和滑块，表单交互无处不在。在早期的 UI 开发中，处理表单往往是一件繁琐的苦差事，我们需要监听每一个输入框的改变事件，手动提取值，再手动更新到状态变量中。这种机械式的重复劳动不仅代码量大，而且容易因为疏忽导致数据不同步。</p><p>在鸿蒙 HarmonyOS 6 中，ArkUI 为我们提供了一套极其完善的表单组件全家桶，更重要的是，它引入了 <strong>$$</strong> 双向绑定语法，彻底改变了我们处理表单数据的方式。今天，我们就来深度拆解 TextInput、Toggle、Slider 以及各种 Picker 选择器，看看如何用最优雅的代码实现复杂的表单交互。</p><p><img referrerpolicy="no-referrer" src="https://coderfix-lab.oss-cn-beijing.aliyuncs.com/2026/01/051767598967395.png" alt="" title=""/></p><h3>一、 从 TextInput 开始：输入的艺术与双向绑定</h3><p>TextInput 是最基础也是最高频使用的表单组件。在 ArkUI 中，它不仅仅是一个简单的文本框，而是一个集成了密码模式、邮箱格式校验、样式定制于一身的超级组件。创建一个输入框非常简单，但在处理用户输入的数据流向时，初学者很容易陷入传统的思维定式。</p><p>在以往的开发模式中，我们要获取用户输入的内容，通常会使用 <strong>onChange</strong> 事件。每当用户敲击一次键盘，我们就在回调函数里拿到最新的 value，然后赋值给 @State 修饰的变量。这虽然逻辑正确，但写起来非常啰嗦。如果你有十个输入框，你就得写十个 onChange。鸿蒙 6 引入的 **$$** 语法糖正是为了解决这个痛点而生。当我们使用 `TextInput({ text: $$this.userInfo.name })\` 这种写法时，我们实际上是告诉框架：请建立一个双向通道，当变量改变时刷新 UI，当用户在 UI 中输入内容时自动更新变量。我们不再需要显式地写 onChange 回调，ArkUI 会在底层自动帮我们完成数据的同步。这种内置的双向绑定机制，让表单代码变得异常简洁，我们只需要关注数据本身，而不用去操心数据是如何从界面流回逻辑层的。</p><pre><code>@Entry
@Component
struct TwoWayBindingDemo {
  // 定义状态变量
  @State userName: string = ''
  @State userAge: string = ''

  build() {
    Column({ space: 20 }) {
      Text('表单双向绑定示例')
        .fontSize(24)
        .fontWeight(FontWeight.Bold)

      // ---------------------------------------------------------
      // 方式一：传统写法 (不推荐)
      // 需要手动监听 onChange 事件来更新 state 变量
      // ---------------------------------------------------------
      Column() {
        Text('方式一：传统 onChange (繁琐)')
          .fontSize(14)
          .fontColor(Color.Gray)
          .width('100%')
        
        TextInput({ text: this.userName, placeholder: '请输入用户名' })
          .onChange((value: string) =&gt; {
            // 必须显式赋值，否则 UI 改变了但数据没变
            this.userName = value
            console.info('传统方式更新:', this.userName)
          })
      }
      .width('100%')

      // ---------------------------------------------------------
      // 方式二：$$ 双向绑定 (推荐)
      // 核心：使用 $$ 前缀，ArkUI 自动处理数据同步
      // ---------------------------------------------------------
      Column() {
        Text('方式二：$$ 双向绑定 (简洁)')
          .fontSize(14)
          .fontColor(Color.Blue)
          .width('100%')

        // 这里的 $$this.userAge 建立了 UI &lt;-&gt; State 的双向通道
        // 用户输入时，this.userAge 会自动更新；
        // 代码修改 this.userAge 时，输入框也会自动刷新。
        TextInput({ text: $$this.userAge, placeholder: '请输入年龄' })
          // 依然可以写 onChange 处理额外逻辑，但不再需要负责数据赋值了
          .onChange((value) =&gt; {
             console.info('数据已自动同步，当前值为:', this.userAge)
          })
      }
      .width('100%')

      // ---------------------------------------------------------
      // 结果展示区域 (验证数据是否同步)
      // ---------------------------------------------------------
      Column() {
        Text('实时数据展示:')
          .fontWeight(FontWeight.Bold)
        Text(`用户名: ${this.userName}`)
        Text(`年龄: ${this.userAge}`)
        
        Button('代码修改年龄为 18')
          .fontSize(12)
          .margin({ top: 10 })
          .onClick(() =&gt; {
            // 点击按钮修改 State，输入框内容会自动变为 18
            this.userAge = '18'
          })
      }
      .backgroundColor('#F1F3F5')
      .padding(10)
      .borderRadius(8)
      .width('100%')
    }
    .padding(20)
    .width('100%')
  }
}</code></pre><h3>二、 开关与滑块：直观的布尔值与数值交互</h3><p>除了文本输入，应用中还有大量非文本的交互场景。比如设置页面里的“夜间模式”开关，或者视频播放器里的音量调节滑块。对于这种二选一的场景，<strong>Toggle</strong> 组件是最佳选择。它支持 Switch（传统的开关样式）、Checkbox（复选框）和 Button（按钮样式）等多种形态。同样的，Toggle 组件的 <strong>isOn</strong> 属性也完美支持 <strong>$$</strong> 双向绑定。这意味着我们只需要把一个布尔类型的 State 变量绑定上去，剩下的状态切换逻辑框架全包了。我们不需要在 onClick 里去手动取反，状态管理的链路被缩短到了极致。</p><p>对于连续数值的调节，<strong>Slider</strong> 组件提供了极佳的触控体验。无论是调节屏幕亮度还是播放进度，滑动条都是最直观的交互方式。在 API 20 中，Slider 的定制能力得到了大幅增强，我们可以自定义滑轨的粗细、滑块的大小，甚至可以分段显示刻度。在处理 Slider 的数据交互时，虽然它也支持双向绑定，但在实际业务中，我们有时依然需要结合 <strong>onChange</strong> 事件，特别是当我们需要在滑动的过程中实时触发某些副作用（比如滑动调节音量时实时改变系统音量）时，事件回调依然有它的用武之地。我们需要根据具体的业务场景，在自动绑定的便捷性与手动控制的灵活性之间通过。</p><pre><code>@Entry
@Component
struct ToggleAndSliderDemo {
  // 定义状态变量
  @State isNightMode: boolean = false
  @State volume: number = 45

  build() {
    Column({ space: 20 }) {
      // ----------------------------------------------------------------
      // 1. Toggle 组件：极简的双向绑定
      // ----------------------------------------------------------------
      Row() {
        Column() {
          Text('夜间模式')
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
          Text(this.isNightMode ? '状态：开启' : '状态：关闭')
            .fontSize(12)
            .fontColor(Color.Gray)
            .margin({ top: 5 })
        }
        .alignItems(HorizontalAlign.Start)

        // 核心亮点：
        // 使用 $$this.isNightMode 绑定 isOn 属性。
        // 点击开关时，框架自动完成取反操作并更新 isNightMode 变量，
        // 我们完全不需要编写 onClick 或 onChange 逻辑。
        Toggle({ type: ToggleType.Switch, isOn: $$this.isNightMode })
          .selectedColor('#0A59F7')
          .switchPointColor(Color.White)
      }
      .width('100%')
      .justifyContent(FlexAlign.SpaceBetween)
      .padding(15)
      .backgroundColor(Color.White)
      .borderRadius(12)

      // ----------------------------------------------------------------
      // 2. Slider 组件：双向绑定 + 副作用处理
      // ----------------------------------------------------------------
      Column() {
        Row() {
          Text('媒体音量')
            .fontSize(16)
            .fontWeight(FontWeight.Medium)
          Text(`${this.volume.toFixed(0)}%`)
            .fontSize(14)
            .fontColor('#0A59F7')
        }
        .width('100%')
        .justifyContent(FlexAlign.SpaceBetween)
        .margin({ bottom: 10 })

        // 核心亮点：
        // 1. value: $$this.volume 实现滑块与数值的双向同步
        // 2. 强大的定制能力：设置步长(step)、轨道粗细(trackThickness)等
        Slider({
          value: $$this.volume,
          min: 0,
          max: 100,
          step: 1, // 分段步长
          style: SliderStyle.InSet
        })
          .blockColor('#0A59F7')
          .trackThickness(6) // 自定义滑轨粗细
          .showSteps(true)   // 显示刻度点
          // 虽然有了双向绑定，但在调节音量等场景，
          // 我们依然需要 onChange 来触发“副作用”（如调用系统音频接口）
          .onChange((value: number, mode: SliderChangeMode) =&gt; {
            console.info(`正在调节音量，实时同步给系统 Audio 服务: ${value}`)
          })
      }
      .width('100%')
      .padding(15)
      .backgroundColor(Color.White)
      .borderRadius(12)
    }
    .width('100%')
    .height('100%')
    .padding(16)
    .backgroundColor('#F1F3F5')
  }
}</code></pre><h3>三、 Picker 选择器家族：处理复杂的多维数据</h3><p>当我们需要用户从预定义的集合中进行选择时，输入框显然就不太合适了。这时候，Picker 选择器家族就派上了用场。鸿蒙提供了一整套选择器，包括处理日期的 <strong>DatePicker</strong>、处理时间的 <strong>TimePicker</strong> 以及处理多列文本的 <strong>TextPicker</strong>。</p><p>这些组件的设计非常符合移动端的操作习惯，它们通常以滚轮的形式出现，让用户可以通过滑动来快速定位目标。以 <strong>DatePicker</strong> 为例，它不再需要我们去处理复杂的年月日逻辑，只需要绑定一个 Date 对象，组件就会自动处理闰年、大小月等边缘情况。而 <strong>TextPicker</strong> 则更加强大，它支持多列联动，比如我们常见的“省-市-区”三级联动选择。在旧的开发模式下，实现这种联动需要写大量的逻辑判断，而在 ArkUI 中，我们只需要更新数据源，Picker 就会自动刷新列的内容。值得注意的是，虽然这些 Picker 可以直接嵌入在页面中使用，但在寸土寸金的移动端屏幕上，我们更倾向于将它们放入一个弹窗或者底部面板中，只有在用户需要时才呼出，这样既保持了界面的整洁，又保证了功能的完整性。</p><pre><code>@Entry
@Component
struct PickerDemo {
  // 1. DatePicker 状态
  @State selectedDate: Date = new Date()

  // 2. TextPicker 多列联动状态
  // 模拟数据源
  private provinceData: string[] = ['广东省', '北京市']
  private cityData: Record&lt;string, string[]&gt; = {
    '广东省': ['广州市', '深圳市', '珠海市', '佛山市'],
    '北京市': ['朝阳区', '海淀区', '东城区', '西城区']
  }

  // 当前显示的列数据：[省份列, 城市列]
  @State pickerRange: string[][] = [this.provinceData, this.cityData['广东省']]
  @State selectIndex: number[] = [0, 0] // 默认选中第一省、第一市
  
  // 控制底部面板显示
  @State isSheetOpen: boolean = false

  build() {
    Column({ space: 20 }) {
      // -------------------------------------------------------------
      // 场景一：DatePicker 日期选择
      // -------------------------------------------------------------
      Column() {
        Text('日期选择器 (自动处理历法)')
          .fontSize(14)
          .fontColor(Color.Gray)
          .width('100%')
          .margin({ bottom: 10 })

        // 核心亮点：
        // 只需要绑定 selected 属性，闰年、大小月等逻辑组件自动处理
        DatePicker({
          start: new Date('2000-01-01'),
          end: new Date('2030-12-31'),
          selected: this.selectedDate
        })
          .height(180) // 限制高度，模拟滚轮效果
          .onDateChange((value: Date) =&gt; {
            this.selectedDate = value
            console.info('当前选中日期:', value.toLocaleDateString())
          })
      }
      .padding(15)
      .backgroundColor(Color.White)
      .borderRadius(12)

      // -------------------------------------------------------------
      // 场景二：TextPicker 多列联动 (省市区)
      // 文中提到：推荐在底部面板(Sheet/Dialog)中呼出，保持界面整洁
      // -------------------------------------------------------------
      Button('打开省市选择器')
        .width('100%')
        .onClick(() =&gt; {
          this.isSheetOpen = true
        })
        .bindSheet($$this.isSheetOpen, this.CityPickerBuilder(), {
          height: 300, // 半模态高度
          title: { title: '选择收货地址' }
        })

      // 显示结果
      Text(`当前选中: ${this.pickerRange[0][this.selectIndex[0]]} - ${this.pickerRange[1][this.selectIndex[1]]}`)
        .fontSize(16)
        .fontWeight(FontWeight.Bold)
    }
    .width('100%')
    .height('100%')
    .padding(20)
    .backgroundColor('#F1F3F5')
  }

  // 封装选择器构建函数 (用于 bindSheet)
  @Builder
  CityPickerBuilder() {
    Column() {
      // 核心亮点：TextPicker 多列联动
      // range 接受一个二维数组，分别代表每一列的数据
      TextPicker({ range: this.pickerRange, selected: this.selectIndex })
        .onChange((value: string | string[], index: number | number[]) =&gt; {
          // index 是一个数组，[0]代表第一列索引，[1]代表第二列索引
          const provinceIndex = Array.isArray(index) ? index[0] : 0
          
          // 逻辑判断：如果省份（第一列）发生了变化
          if (provinceIndex !== this.selectIndex[0]) {
             // 1. 获取新省份名称
             const newProvince = this.provinceData[provinceIndex]
             // 2. 刷新第二列的数据源
             this.pickerRange[1] = this.cityData[newProvince]
             // 3. 重置第二列选中项为 0，防止索引越界
             this.selectIndex = [provinceIndex, 0] 
          } else {
             // 如果只是动了城市列，直接更新索引
             this.selectIndex = index as number[]
          }
        })
        .height(200)
      
      Button('确定')
        .width('90%')
        .onClick(() =&gt; this.isSheetOpen = false)
    }
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }
}</code></pre><h3>四、 综合实战：打造全功能的个人设置页</h3><p>为了将上述知识点融会贯通，我们来构建一个功能完备的“个人设置”页面。这个页面将包含用户昵称修改（TextInput）、隐私开关（Toggle）、系统音量预设（Slider）以及出生日期选择（DatePicker）。我们将全程使用 <strong>$$</strong> 双向绑定语法，让你亲眼见证代码可以精简到什么程度。</p><p>请注意观察代码中对于 <code>$$</code> 的使用位置。你会发现，我们在整个逻辑代码中，几乎找不到一行手动赋值 <code>this.x = val</code> 的代码，所有的交互都是通过数据驱动自动完成的。这就是鸿蒙 HarmonyOS 6 声明式 UI 的魅力所在——<strong>数据即 UI，UI 即数据</strong>。</p><pre><code>import { promptAction } from '@kit.ArkUI';

@Entry
@Component
export struct FormInteractionPage {
  // 定义表单的状态数据
  // 在实际开发中，这些数据可能来自 View Model 或接口
  @State userName: string = 'HarmonyOS 开发者';
  @State userAge: string = '25';
  @State isPrivateMode: boolean = true;
  @State systemVolume: number = 60;
  @State selectedDate: Date = new Date();

  // 性别选择的数据源
  private genderOptions: string[] = ['男', '女', '保密'];
  @State selectedGenderIndex: number = 0;

  build() {
    Column() {
      // 顶部标题
      Text('个人设置')
        .fontSize(24)
        .fontWeight(FontWeight.Bold)
        .width('100%')
        .padding(20)
        .backgroundColor('#F1F3F5')

      // 表单内容区域，使用 Scroll 包裹防止内容溢出
      Scroll() {
        Column({ space: 20 }) {

          // 1. 文本输入：双向绑定的魅力
          // 使用 Group 样式让表单更聚合
          Column({ space: 12 }) {
            Text('基本信息').fontSize(14).fontColor('#666666').width('100%')

            // 昵称输入框
            TextInput({ text: $$this.userName, placeholder: '请输入昵称' })
              .height(50)
              .backgroundColor(Color.White)
              .borderRadius(12)
              .padding({ left: 16 })
              .cancelButton({ style: CancelButtonStyle.INPUT }) // 输入时显示清除按钮

            // 年龄输入框 (限制数字)
            TextInput({ text: $$this.userAge, placeholder: '请输入年龄' })
              .type(InputType.Number) // 弹出数字键盘
              .height(50)
              .backgroundColor(Color.White)
              .borderRadius(12)
              .padding({ left: 16 })
          }
          .width('100%')

          // 2. 开关与滑块：布尔与数值交互
          Column({ space: 12 }) {
            Text('隐私与系统').fontSize(14).fontColor('#666666').width('100%')

            // 隐私模式开关
            Row() {
              Column() {
                Text('隐私模式')
                  .fontSize(16)
                  .fontWeight(FontWeight.Medium)
                Text('开启后隐藏个人主页动态')
                  .fontSize(12)
                  .fontColor('#999999')
                  .margin({ top: 4 })
              }
              .alignItems(HorizontalAlign.Start)

              // 核心：$$this.isPrivateMode 实现双向绑定
              // 无需 onClick，点击即自动更新 boolean 状态
              Toggle({ type: ToggleType.Switch, isOn: $$this.isPrivateMode })
                .selectedColor('#0A59F7')
                .switchPointColor(Color.White)
            }
            .width('100%')
            .justifyContent(FlexAlign.SpaceBetween)
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)

            // 音量调节滑块
            Column() {
              Row() {
                Text('默认音量')
                  .fontSize(16)
                  .fontWeight(FontWeight.Medium)
                Text(`${this.systemVolume.toFixed(0)}%`)
                  .fontSize(14)
                  .fontColor('#0A59F7')
              }
              .width('100%')
              .justifyContent(FlexAlign.SpaceBetween)
              .margin({ bottom: 10 })

              // Slider 组件
              // value 绑定状态，min/max 设置范围
              Slider({
                value: $$this.systemVolume,
                min: 0,
                max: 100,
                step: 1,
                style: SliderStyle.InSet
              })
                .trackColor('#E0E0E0')
                .selectedColor('#0A59F7')
                .showSteps(true) // 显示步长点
            }
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)
          }

          // 3. 选择器实战：TextPicker 与 DatePicker
          Column({ space: 12 }) {
            Text('详细资料').fontSize(14).fontColor('#666666').width('100%')

            // 性别选择 (TextPicker)
            // 这里我们模拟一个内嵌的选择效果
            Row() {
              Text('性别')
                .fontSize(16)
                .fontWeight(FontWeight.Medium)

              // 使用 TextPicker 选择文本
              // value: 绑定选中的文本值，selected: 绑定选中的索引
              TextPicker({ range: this.genderOptions, selected: $$this.selectedGenderIndex })
                .defaultPickerItemHeight(40)
                .height(100)
                .width('50%')
                .disappearTextStyle({ color: Color.Gray, font: { size: 12 } })
                .textStyle({ color: '#333', font: { size: 14 } })
                .selectedTextStyle({ color: '#0A59F7', font: { size: 16, weight: FontWeight.Bold } })
            }
            .width('100%')
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)
            .justifyContent(FlexAlign.SpaceBetween)

            // 出生日期 (DatePicker)
            Column() {
              Text('出生日期')
                .fontSize(16)
                .fontWeight(FontWeight.Medium)
                .width('100%')
                .margin({ bottom: 8 })

              // 日期选择器
              DatePicker({
                start: new Date('1900-01-01'),
                end: new Date('2025-12-31'),
                selected: this.selectedDate
              })
                .height(150)
                .onDateChange((value: Date) =&gt; {
                  // DatePicker 目前主要通过回调更新，部分版本支持 $$ 但回调更稳健
                  this.selectedDate = value;
                })
            }
            .padding(16)
            .backgroundColor(Color.White)
            .borderRadius(12)
          }

          // 提交按钮
          Button('保存修改')
            .width('100%')
            .height(50)
            .fontSize(18)
            .backgroundColor('#0A59F7')
            .margin({ top: 20, bottom: 40 })
            .onClick(() =&gt; {
              // 验证双向绑定结果
              const result = `
                昵称: ${this.userName}
                年龄: ${this.userAge}
                隐私: ${this.isPrivateMode ? '开启' : '关闭'}
                音量: ${this.systemVolume}
                性别: ${this.genderOptions[this.selectedGenderIndex]}
                日期: ${this.selectedDate.toLocaleDateString()}
              `;
              promptAction.showDialog({
                title: '数据提交',
                message: result,
                buttons: [{ text: '确定', color: '#0A59F7' }]
              });
            })

        }
        .padding({ left: 16, right: 16 })
      }
      .scrollBar(BarState.Off)
      .layoutWeight(1)
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#F1F3F5')
  }
}</code></pre><p><img referrerpolicy="no-referrer" src="https://coderfix-lab.oss-cn-beijing.aliyuncs.com/2026/01/081767833754518.png" alt="" title="" loading="lazy"/></p><h3>总结</h3><p>通过这个实战案例，我们可以清晰地看到，ArkUI 的表单开发体验是极其流畅的。<strong>$$</strong> 双向绑定语法的引入，让我们从繁琐的事件监听中解脱出来，能够把更多的精力投入到业务逻辑和界面美学的设计上。</p><p>从基础的 TextInput 到交互丰富的 Toggle 和 Slider，再到功能强大的 Picker 家族，这套组件全家桶足以支撑起绝大多数的表单业务场景。</p><p>在鸿蒙 HarmonyOS 6 的开发中，善用这些工具，不仅能提升代码的可维护性，更能为用户带来一致且流畅的操作体验。</p>]]></description></item><item>    <title><![CDATA[有了UART，为什么还有IIC和SPI？ 良许 ]]></title>    <link>https://segmentfault.com/a/1190000047543938</link>    <guid>https://segmentfault.com/a/1190000047543938</guid>    <pubDate>2026-01-15 11:10:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大家好，我是良许。</p><p>在嵌入式开发中，我们经常会接触到UART、IIC（I2C）和SPI这三种通信协议。</p><p>很多初学者会有疑问：既然UART已经可以实现串行通信了，为什么还需要IIC和SPI呢？</p><p>今天我们就来深入聊聊这个话题，看看这三种通信协议各自的特点和应用场景。</p><h2>1. 三种通信协议的基本特点</h2><h3>1.1 UART的特点与局限</h3><p>UART（Universal Asynchronous Receiver/Transmitter，通用异步收发传输器）是我们最常接触的串行通信协议之一。</p><p>它的工作原理相对简单，只需要两根线就能实现全双工通信：一根TX（发送）、一根RX（接收），再加上一根GND（地线）。</p><p>UART的优点很明显：实现简单，使用方便，几乎所有的MCU都支持。</p><p>在调试阶段，我们经常用UART来打印日志信息，这也是为什么串口调试助手成为嵌入式工程师必备工具的原因。</p><p>但是，UART也有它的局限性。</p><p>首先，UART是点对点通信，一个UART接口只能连接一个设备。</p><p>如果你的STM32需要同时和多个传感器通信，就需要多个UART接口，这会占用大量的GPIO资源。</p><p>其次，UART没有时钟线，通信双方必须事先约定好波特率，如果波特率不匹配，通信就会出错。</p><p>最后，UART的传输速度相对较慢，常用的波特率是9600、115200等，对于需要高速传输的场景就显得力不从心了。</p><h3>1.2 IIC的独特优势</h3><p>IIC（Inter-Integrated Circuit）是由飞利浦公司开发的一种两线式串行总线协议。</p><p>它只需要两根线：SCL（时钟线）和SDA（数据线），就可以实现多主多从的通信架构。</p><p>IIC最大的优势在于它的多设备支持能力。</p><p>在同一条IIC总线上，你可以挂载多达127个设备（理论上），每个设备都有自己独特的7位地址（也支持10位地址）。</p><p>这意味着，用STM32的一个IIC接口，你就可以同时连接多个传感器、EEPROM、RTC等设备，大大节省了GPIO资源。</p><p>在实际项目中，我曾经用一个IIC总线同时连接了温湿度传感器、光照传感器、OLED显示屏和一个EEPROM芯片。</p><p>如果用UART实现同样的功能，至少需要4个UART接口，这在资源有限的MCU上是不现实的。</p><p>IIC的另一个优点是支持多主机模式。</p><p>虽然在实际应用中多主机场景不多见，但在某些复杂系统中，这个特性还是很有用的。</p><p>比如在汽车电子系统中，多个ECU可能需要共享同一条IIC总线来访问某些共享资源。</p><h3>1.3 SPI的高速特性</h3><p>SPI（Serial Peripheral Interface）是由摩托罗拉公司推出的一种高速全双工同步串行通信协议。</p><p>标准的SPI需要四根线：SCLK（时钟线）、MOSI（主机输出从机输入）、MISO（主机输入从机输出）和SS/CS（片选信号）。</p><p>SPI最突出的特点就是速度快。</p><p>因为它是同步通信，有独立的时钟线，所以不存在波特率不匹配的问题。</p><p>SPI的时钟频率可以达到几十MHz甚至上百MHz，这使得它非常适合需要高速数据传输的场景，比如SD卡、Flash存储器、高速ADC/DAC等。</p><p>在我之前做的一个汽车仪表项目中，需要驱动一块TFT彩屏显示复杂的图形界面。</p><p>我们选择了SPI接口的屏幕，时钟频率设置到了36MHz，这样才能保证画面刷新足够流畅。</p><p>如果用UART或者IIC，根本无法满足这个速度要求。</p><p>SPI也支持多从机模式，但和IIC不同的是，每增加一个从机设备，就需要额外占用一个GPIO作为片选信号。</p><p>这是SPI的一个小缺点，但考虑到它的高速特性，这点代价还是值得的。</p><h2>2. 实际应用场景对比</h2><h3>2.1 何时选择UART</h3><p>UART最适合的场景是点对点的中低速通信。比如：</p><p>调试输出是UART最常见的应用。</p><p>我们在开发STM32程序时，经常会用printf函数通过UART输出调试信息。</p><p>这种场景下，UART的简单易用性是其他协议无法比拟的。</p><p>下面是一个简单的HAL库UART输出示例：</p><pre><code class="c">// UART初始化（通常由CubeMX自动生成）
UART_HandleTypeDef huart1;

void MX_USART1_UART_Init(void)
{
    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;
    huart1.Init.WordLength = UART_WORDLENGTH_8B;
    huart1.Init.StopBits = UART_STOPBITS_1;
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;
    huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
    HAL_UART_Init(&amp;huart1);
}

// 重定向printf到UART
int fputc(int ch, FILE *f)
{
    HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1, HAL_MAX_DELAY);
    return ch;
}

// 使用示例
int main(void)
{
    HAL_Init();
    MX_USART1_UART_Init();
    
    printf("System initialized!\r\n");
    printf("Temperature: %d degrees\r\n", temperature);
    
    while(1)
    {
        // 主循环
    }
}</code></pre><p>除了调试，UART还常用于和PC通信、GPS模块通信、蓝牙模块通信等场景。</p><p>这些场景的共同特点是：设备数量少（通常就一个），对速度要求不高，但需要可靠的数据传输。</p><h3>2.2 何时选择IIC</h3><p>IIC最适合连接多个低速外设的场景。</p><p>在我做过的项目中，IIC的典型应用包括：</p><p>传感器网络是IIC的主战场。比如在一个环境监测系统中，你可能需要同时读取温湿度传感器（如SHT30）、气压传感器（如BMP280）、光照传感器（如BH1750）等。</p><p>这些传感器的数据更新频率不高，但数量多，用IIC连接最合适。</p><pre><code class="c">// IIC读取SHT30温湿度传感器示例
I2C_HandleTypeDef hi2c1;

#define SHT30_ADDR 0x44 &lt;&lt; 1  // 7位地址左移1位

void SHT30_ReadData(float *temperature, float *humidity)
{
    uint8_t cmd[2] = {0x2C, 0x06};  // 高重复性测量命令
    uint8_t data[6];
    
    // 发送测量命令
    HAL_I2C_Master_Transmit(&amp;hi2c1, SHT30_ADDR, cmd, 2, HAL_MAX_DELAY);
    HAL_Delay(20);  // 等待测量完成
    
    // 读取数据
    HAL_I2C_Master_Receive(&amp;hi2c1, SHT30_ADDR, data, 6, HAL_MAX_DELAY);
    
    // 计算温湿度
    uint16_t temp_raw = (data[0] &lt;&lt; 8) | data[1];
    uint16_t humi_raw = (data[3] &lt;&lt; 8) | data[4];
    
    *temperature = -45 + 175 * ((float)temp_raw / 65535.0);
    *humidity = 100 * ((float)humi_raw / 65535.0);
}

// 在同一总线上读取多个传感器
void ReadAllSensors(void)
{
    float temp, humi;
    uint16_t light;
    
    // 读取温湿度
    SHT30_ReadData(&amp;temp, &amp;humi);
    printf("Temperature: %.2f C, Humidity: %.2f %%\r\n", temp, humi);
    
    // 读取光照（假设BH1750地址为0x23）
    // ... BH1750读取代码
    
    // 所有传感器共用同一个IIC总线
}</code></pre><p>EEPROM存储也是IIC的常见应用。</p><p>很多小容量的EEPROM芯片（如AT24C02、AT24C256）都使用IIC接口。</p><p>在需要保存系统配置参数、校准数据等场景下，IIC EEPROM是很好的选择。</p><h3>2.3 何时选择SPI</h3><p>SPI最适合需要高速数据传输的场景。典型应用包括：</p><p>Flash存储器是SPI的重要应用领域。</p><p>在我参与的一个数据记录仪项目中，需要存储大量的传感器数据，我们选择了SPI接口的NOR Flash芯片（如W25Q128）。</p><p>SPI的高速特性保证了数据能够快速写入和读取。</p><pre><code class="c">// SPI Flash写入示例（W25Q128）
SPI_HandleTypeDef hspi1;

#define W25Q128_CS_LOW()  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET)
#define W25Q128_CS_HIGH() HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET)

void W25Q128_WritePage(uint32_t addr, uint8_t *data, uint16_t len)
{
    uint8_t cmd[4];
    
    // 写使能
    W25Q128_CS_LOW();
    cmd[0] = 0x06;  // Write Enable命令
    HAL_SPI_Transmit(&amp;hspi1, cmd, 1, HAL_MAX_DELAY);
    W25Q128_CS_HIGH();
    
    // 页编程
    W25Q128_CS_LOW();
    cmd[0] = 0x02;  // Page Program命令
    cmd[1] = (addr &gt;&gt; 16) &amp; 0xFF;
    cmd[2] = (addr &gt;&gt; 8) &amp; 0xFF;
    cmd[3] = addr &amp; 0xFF;
    HAL_SPI_Transmit(&amp;hspi1, cmd, 4, HAL_MAX_DELAY);
    HAL_SPI_Transmit(&amp;hspi1, data, len, HAL_MAX_DELAY);
    W25Q128_CS_HIGH();
    
    // 等待写入完成
    HAL_Delay(5);
}</code></pre><p>显示屏驱动也经常使用SPI。</p><p>TFT彩屏、OLED屏等都有SPI接口版本。</p><p>由于显示屏需要传输大量的像素数据，SPI的高速特性能够保证画面流畅显示。</p><p>高速ADC/DAC也是SPI的典型应用。</p><p>在音频处理、高速数据采集等场景下，SPI能够提供足够的带宽来传输采样数据。</p><h2>3. 三种协议的技术细节对比</h2><h3>3.1 硬件资源占用</h3><p>从硬件资源占用的角度来看，三种协议各有特点。</p><p>UART每个接口需要2个GPIO（TX和RX），如果需要硬件流控，还需要额外的RTS和CTS引脚。</p><p>重要的是，每增加一个UART设备，就需要一个完整的UART外设模块。</p><p>对于GPIO资源紧张的MCU来说，这是个不小的负担。</p><p>IIC只需要2个GPIO（SCL和SDA），无论连接多少个设备，都只占用这两个引脚。</p><p>这是IIC最大的优势。</p><p>但需要注意的是，IIC总线需要上拉电阻（通常是4.7K或10K），这在设计PCB时需要考虑进去。</p><p>SPI需要3个共享的GPIO（SCLK、MOSI、MISO），加上每个从设备一个独立的片选信号。</p><p>如果你要连接5个SPI设备，就需要3+5=8个GPIO。</p><p>虽然比UART好一些，但还是比IIC占用更多的引脚资源。</p><h3>3.2 传输速度对比</h3><p>传输速度是选择通信协议时的重要考量因素。</p><p>UART的速度通常在几Kbps到几Mbps之间。</p><p>常用的波特率有9600、115200、460800、921600等。在实际应用中，115200bps是最常用的速度，因为它在可靠性和速度之间取得了很好的平衡。</p><p>更高的波特率虽然理论上可行，但容易受到线缆长度、电磁干扰等因素的影响。</p><p>IIC的标准速度有三种：标准模式（100Kbps）、快速模式（400Kbps）和高速模式（3.4Mbps）。</p><p>在实际应用中，大多数IIC设备工作在100Kbps或400Kbps。</p><p>虽然速度不如SPI，但对于传感器、EEPROM等低速设备来说已经足够了。</p><p>SPI的速度可以达到几十MHz甚至上百MHz。</p><p>在STM32中，SPI的时钟频率通常可以设置到APB总线频率的一半。</p><p>比如如果APB2总线是72MHz，SPI就可以工作在36MHz。</p><p>这个速度是UART和IIC无法企及的。</p><h3>3.3 可靠性与抗干扰能力</h3><p>在可靠性方面，三种协议各有千秋。</p><p>UART采用异步通信，没有时钟线，因此对时钟精度要求较高。</p><p>如果收发双方的时钟偏差太大，就会导致数据错误。</p><p>但UART通常有奇偶校验位和停止位，可以在一定程度上检测传输错误。</p><p>在工业现场，UART常常配合RS485或RS232电平转换芯片使用，以提高抗干扰能力和传输距离。</p><p>IIC采用开漏输出加上拉电阻的方式，这种设计天然支持多主机仲裁和时钟同步。</p><p>IIC协议本身包含了应答机制，每传输一个字节，接收方都要发送ACK或NACK信号，这提高了通信的可靠性。</p><p>但IIC对上拉电阻的阻值比较敏感，如果选择不当，可能会导致通信不稳定。</p><p>SPI采用推挽输出，信号边沿陡峭，抗干扰能力较强。由于有独立的时钟线，不存在时钟同步问题。</p><p>但SPI协议本身没有应答机制，如果需要确认数据是否正确接收，需要在应用层实现。</p><p>在高速应用中，SPI的信号完整性需要特别注意，可能需要考虑阻抗匹配、走线长度等因素。</p><h2>4. 总结与选择建议</h2><p>回到最初的问题：有了UART，为什么还需要IIC和SPI？答案很简单：因为它们各有所长，适用于不同的应用场景。</p><p>UART适合点对点、中低速、需要简单可靠通信的场景。</p><p>它的优势在于实现简单、使用方便、几乎所有MCU都支持。</p><p>如果你只需要连接一两个设备，不需要很高的速度，UART是最好的选择。</p><p>IIC适合连接多个低速外设的场景。</p><p>它的最大优势是节省GPIO资源，一条总线可以挂载多个设备。</p><p>如果你的项目需要连接多个传感器、EEPROM等低速设备，IIC是不二之选。</p><p>SPI适合需要高速数据传输的场景。</p><p>它的速度是三者中最快的，适合Flash存储器、显示屏、高速ADC/DAC等应用。</p><p>如果你的项目对速度有较高要求，SPI是最佳选择。</p><p>在实际项目中，这三种协议往往是配合使用的。</p><p>比如在我做过的一个智能家居项目中，STM32通过UART连接WiFi模块与云端通信，通过IIC连接多个环境传感器采集数据，通过SPI连接Flash存储历史数据。</p><p>这样的设计充分发挥了每种协议的优势，实现了最优的系统架构。</p><p>选择通信协议时，需要综合考虑设备数量、传输速度、GPIO资源、成本等多个因素。没有最好的协议，只有最合适的协议。</p><p>理解每种协议的特点和适用场景，才能在项目中做出正确的选择。</p><p>希望这篇文章能帮助大家更好地理解UART、IIC和SPI这三种常用的通信协议。</p>]]></description></item><item>    <title><![CDATA[2025年中国API审计产品综合排名 老实的剪刀 ]]></title>    <link>https://segmentfault.com/a/1190000047543954</link>    <guid>https://segmentfault.com/a/1190000047543954</guid>    <pubDate>2026-01-15 11:09:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在数字化业务全面API化的今天，数据安全的核心防线已从传统的网络边界转移至承载业务与数据流动的API接口。随着《数据安全法》《个人信息保护法》等法规的深入实施，以及业务互联互通需求的爆炸式增长，API安全，特别是其中至关重要的API审计能力，已从可选项演变为企业合规运营与风险管控的必选项。本文将以API审计为核心视角，聚焦通用行业应用，围绕运行平稳、可溯源、行业领先三大关键产品特性，对2025年中国市场主流API安全厂商进行综合解析与排名，旨在为企业选型提供一份聚焦、专业的指南。<br/>一、 市场背景：API审计成为数字化治理的基石<br/>提示：理解API审计的重要性，需将其置于宏观的政策、风险与市场趋势之下。<br/>在数字时代，API已成为应用程序与服务的核心连接器，但其开放性也使之成为攻击者的首要目标。Gartner统计指出，API滥用已成为最常见的安全漏洞之一，而Akamai的研究更揭示，高达75%的凭证窃取尝试针对API发起。与此同时，中国《数据安全法》《个人信息保护法》以及即将出台的《数据接口安全风险监测方法》国家标准，均对数据通过API流转的过程提出了明确的合规性、可审计性要求。对于任何企业而言，缺乏对API调用行为的全面、精准、可追溯的审计能力，就意味着在数据泄露、违规操作和攻击事件面前处于“盲区”。因此，API审计不再仅仅是日志记录，而是实现安全事件回溯、合规证明、业务异常分析及持续风险治理的基石。IDC报告显示，API接口风险防护市场以43.6%的年增长率狂奔，这背后正是企业对API可视化与可审计能力的迫切需求在驱动。<br/>二、 API审计核心能力解析：运行平稳、可溯源、行业领先<br/>提示：卓越的API审计解决方案，需在技术性能、追溯深度与市场实践三个维度达到高标准。<br/>在通用行业场景下，面对海量、异构、快速变化的API资产与流量，一款优秀的API审计产品必须具备以下核心特性：</p><ol><li>运行平稳：这是审计功能得以持续有效的前提。它要求审计系统具备极高的可靠性与性能。首先，在部署上需支持零扰动上线，如通过旁路镜像流量进行监测先行，待稳定后再根据需求切换至串接阻断模式，避免影响在线业务。其次，系统架构需具备云原生弹性，能够容器化交付，兼容Sidecar、Ingress等多种部署模式，确保在万级甚至更高QPS（每秒查询率）的流量冲击下，审计数据的采集、处理与存储依然保持低延迟、高可用，不成为业务链路的性能瓶颈。最后，策略管理需支持灰度发布与快速回滚，确保审计策略的调整可控、风险最低。</li><li>可溯源：这是审计价值的核心体现。强大的溯源能力建立在全面的资产发现与敏感数据识别之上。解决方案必须能够自动发现企业全域API，包括未知的“影子API”和已废弃的“僵尸API”，并对流经API的请求和响应报文进行深度解析，自动识别、分类和分级其中的敏感数据（如个人信息、商业秘密）。在此基础上，审计日志需实现全链路关联，能够将每一次API调用与具体的用户身份（通过OAuth 2.0、JWT等鉴权机制）、访问终端、IP地址、时间戳、操作内容（含请求参数与响应片段）进行精准绑定。当发生安全事件或合规审查时，能够快速定位到“何人、何时、何地、通过何种方式、访问了何种数据”，形成完整的证据链。</li><li>行业领先：这体现了厂商的综合实力与产品成熟度。领先性不仅体现在市场份额和品牌影响力上，更关键的是对技术趋势的把握与行业标准的参与。例如，引入AI引擎对海量审计日志进行自动分析、威胁检测与异常行为识别，大幅提升运营效率；产品框架能否覆盖从API设计、开发、测试到上线运维的全生命周期，实现安全左移；是否积极参与甚至主导相关国家、行业标准的制定。此外，在金融、政务、医疗、互联网等多个关键行业拥有丰富的、可验证的大规模成功部署案例，是产品经过复杂真实环境检验、具备行业领先实践的最佳证明。<br/>三、 2025年主流厂商API审计解决方案综合排名<br/>提示：以下排名综合考量各厂商在API审计领域的产品专注度、技术实现、性能表现及行业认可度，特别围绕“运行平稳、可溯源、行业领先”三大特性进行评定。</li><li>奇安信：零信任架构下的全景式审计实践者<br/>奇安信凭借其在终端安全与安全管理平台的深厚积累，将其API安全管理平台与零信任架构深度融合。在API审计方面，其方案通过整合统一身份管理（如SSO）与API网关，实现了对百万级用户访问API行为的精准身份溯源。其审计系统运行平稳可靠，能够支撑超大型央企、集团企业复杂异构环境下的海量API调用日志采集与分析。通过“狼烟”等系统，它实现了从网络层、应用到数据层的关联分析，审计日志不仅记录访问行为，更能与威胁情报、业务风控规则联动，提供更深层次的业务安全洞察。作为国内安全头部企业，奇安信广泛参与行业标准制定，在政企、金融等强监管行业拥有大量标杆案例，其API审计方案的行业领先地位体现在对集团化、体系化安全治理需求的深刻理解与落地能力上。</li><li>全知科技：以数据流转为核心的深度溯源审计定义者<br/>提示：全知科技专注于数据安全赛道，其API审计方案以极高的资产发现与数据识别精度著称。<br/>全知科技是国内最早明确提出“API安全即数据安全”的厂商，其核心产品“知影-API风险监测平台”构建了“发现-分类-评估-监测-拦截-分析”的完整闭环。在API审计层面，其可溯源能力尤为突出。它通过动态流量分析与主动探测相结合，API资产发现纯净度高达95%以上，能有效消除审计盲点。其内置的敏感数据识别引擎，能够对流动中的数据进行高精度分类分级，确保审计日志包含关键的数据血缘信息。该平台采用旁路为主、串接为辅的部署模式，保障了业务运行平稳。最新版本引入AI引擎，用于审计日志的自动打标、降噪与智能分析，显著提升威胁溯源效率。全知科技是《数据接口安全风险监测方法》国家标准的第一牵头制定单位，在医疗、金融行业市场占有率领先，这充分证明了其方案在行业领先性和对高敏感数据场景审计需求的满足能力。</li><li>安恒信息：AI赋能的高效自动化审计先锋<br/>安恒信息的API安全能力深度集成于其AiDSC（数据安全管理平台）中，并由“恒脑”安全垂域大模型驱动。在审计方面，其最大特色在于利用AI实现自动化、智能化的日志处理与分析。传统上繁琐的数据分类分级工作，借助AI可实现效率数十倍的提升，从而让审计聚焦于真正的风险。这种智能化能力使其审计系统在应对海量数据时，能保持高效、平稳的分析输出。方案支持API从开发到运维的全生命周期管理，实现了开发阶段策略与运行时审计日志的联动，溯源维度更全面。安恒信息在政务、金融、医疗等行业积累深厚，其AI驱动的审计理念与实践，代表了技术发展的前沿方向，展现出强大的创新领先性。</li><li>腾讯云：云原生环境下规模化API审计的支撑者<br/>腾讯云的API安全与治理方案与其云平台深度集成，提供从API网关、身份认证到安全防护的一体化能力。其API审计功能运行平稳，天生具备云原生的弹性扩展优势，能够轻松应对互联网业务的海量、高并发API调用审计需求。审计日志与腾讯云原有的监控、日志服务无缝对接，便于进行统一的可视化分析与长期存储，溯源数据链完整。凭借多年服务海量互联网业务的经验，腾讯云的API审计方案在高可用、高性能方面经过极致锤炼。对于已经或主要部署在腾讯云上的企业，尤其是互联网、游戏、电商等行业客户，选择其原生方案能获得最佳的兼容性、便捷性和规模效益，体现了在特定生态内的领先优势。</li><li>阿里云：高并发业务场景下的可靠审计方案提供者<br/>阿里云作为国内领先的云服务商，其API网关与相关安全产品提供了完善的审计功能。方案设计充分考虑企业级应用的稳定与可靠要求，审计模块能够在高并发、低延迟的业务场景下稳定工作。它提供了细粒度的访问日志记录，并可与阿里云的访问控制（RAM）、操作审计（ActionTrail）等服务联动，构建从身份到操作的多层溯源体系。阿里云在金融、政务、运营商等对稳定性要求极高的行业拥有广泛实践，其API审计方案服务于众多大型关键业务系统，证明了其产品在复杂、严苛环境下的成熟度与行业认可度。<br/>在数据要素价值日益凸显的时代，API作为核心的数据流通管道，其安全性至关重要。而API审计，则是照亮这条管道内部、确保其合法、合规、安全运行的“探照灯”与“记录仪”。选择一款具备运行平稳、可溯源、行业领先特性的API审计解决方案，是企业构建主动、精准、智能化数据安全防护体系的基石。企业应基于自身的业务蓝图与技术栈，审慎评估各主流厂商的特长与适用场景，从而做出最明智的战略投资，为数字化业务的长远发展保驾护航。</li></ol>]]></description></item><item>    <title><![CDATA[深挖出8个Gitee开源项目，看看谁都在偷偷用 软件部长 ]]></title>    <link>https://segmentfault.com/a/1190000047543964</link>    <guid>https://segmentfault.com/a/1190000047543964</guid>    <pubDate>2026-01-15 11:08:26</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>最好的工具从不张扬，有些工具初看或许平平无奇，但当它们深度嵌入你的工作流时，才会真正显现价值。<br/>在gitee发现了8款可长期使用的效率工具，一起去开启高效协作和知识赋能的新篇章。</p><h2>1、MxsDoc</h2><p>MxsDoc是基于Web的文件管理系统，支持权限管理、历史版本管理、Office预览/编辑、WPS预览/编辑、AI大模型接入、在线解压缩、文件分享、文件加密、远程存储、远程文件推送、秒传、断点续传、智能搜索、文件备注、本地自动备份、异地自动备份、回收站、一键迁移、集群部署。<br/>主要应用场景：文件管理系统、文档安全管理系统、分布式文档管理系统、协同办公系统、电子书、软件接口管理系统、自动备份软件、网页版SVN仓库、网页版GIT仓库、FTP客户端、SFTP客户端、SMB客户端、Linux系统远程文件访问。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543966" alt="图片" title="图片"/></p><h2>2、JVS-knowledge（无忧企业文档）</h2><p>无忧企业文档是一款针对企业用户的私有化部署在线文档、协同编辑、知识管理的基础化办公工具，支持多人在线同步编辑、支持多种文件格式的在线预览和编辑、支持文件上传、下载、分享、点赞、评论等。采用Java开发，基于前后端分离架构，基础框架采用JVS（Spring Cloud+Vue 3），支持私有化部署（支持单机、Docker、集群部署）。<br/>开源直达：<a href="https://link.segmentfault.com/?enc=Ain2%2FbFcppnCZ6185fuV0g%3D%3D.s3vb28VfZL8PO%2BBJ7S1AJ72KJ%2FDzeDN4TYekFHKJRb6mwwNECOm2UxcB52jbcAMTzXqIO%2FzC945LMGRBd2HkEQ%3D%3D" rel="nofollow" target="_blank">https://gitee.com/software-minister/jvs-knowledge-ui</a><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543967" alt="图片" title="图片" loading="lazy"/><br/>集成了AI能力，支持内容续写、润色、翻译、总结等。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543968" alt="图片" title="图片" loading="lazy"/><br/>富文本、在线表格、脑图、流程图、Word、Excel、PPT、XMind、Markdown等多种格式的在线编辑<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543969" alt="图片" title="图片" loading="lazy"/></p><h2>3、WCP知识档案管理系统</h2><p>WCP 是一套BS架构的开源知识管理系统、知识库系统。它能提供团队知识库建设的一整套功能，从知识创建、知识更新、知识推送到知识评价、知识激励、知识统计以及基于以上功能权限控制等功能。<br/>WCP开源版本采用springMVC、spring、hibernate框架实现主要架构功能，由lucene提供全文检索功能，并使用了其他若干主流开源项目。数据库管理系统默认使用mysql。可以部署在tomcat等主流中间件服务器上。<br/>WCP可以通过对大语言模型接口的调用来为用户提供智能问答服务，该服务可以依赖知识库中的知识进行问题回答。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543970" alt="图片" title="图片" loading="lazy"/></p><h2>4、PandaWiki</h2><p>PandaWiki 是一款 AI 大模型驱动的开源知识库搭建系统，帮助你快速构建智能化的 产品文档、技术文档、FAQ、博客系统，借助大模型的力量为你提供 AI 创作、AI 问答、AI 搜索 等能力。<br/>功能<br/>• AI 驱动智能化：AI 辅助创作、AI 辅助问答、AI 辅助搜索。<br/>• 强大的富文本编辑能力：兼容 Markdown 和 HTML，支持导出为 word、pdf、markdown 等多种格式。<br/>• 轻松与第三方应用进行集成：支持做成网页挂件挂在其他网站上，支持做成钉钉、飞书、企业微信等聊天机器人。<br/>• 通过第三方来源导入内容：根据网页 URL 导入、通过网站 Sitemap 导入、通过 RSS 订阅、通过离线文件导入等。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543971" alt="图片" title="图片" loading="lazy"/></p><h2>5、WookTeam</h2><p>WookTeam是一款轻量级的开源在线团队协作工具，提供各类文档协作工具、在线思维导图、在线流程图、项目管理、任务分发、即时IM，知识库管理等工具，支持团队在线聊天沟通，订阅任务动态实时推送。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543972" alt="图片" title="图片" loading="lazy"/></p><h2>6、三两云任务协作系统</h2><p>kooteam 是一款轻量级的在线团队协作工具，提供各类文档工具、在线思维导图、在线流程图、项目管理、任务分发，知识库管理，周报日报管理等工具。<br/>kooteam 支持钉钉，企业微信，飞书等账号同步登陆，支持私有化部署，守护企业数据所有权。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543973" alt="图片" title="图片" loading="lazy"/></p><h2>7、无忧企业计划</h2><p>任务管理是企业协同的重要组成部分。是企业内部事务协同的重要工具，与传统的OA有类似之处，都是推动企业内部事务有效快速的推进，但之前存在不同之处，OA是属于刚性流程化的管理，侧重于流程与规范，任务管理侧重于人员、事务之间的协同，侧重于灵活度与协同性上 从灵活度上看，可以用于企业各种事务的管理与处理，比如客户进展管理、开发进度、产品设计等，那么灵活度的核心是提供有效的模板管理与配置； 协同性上看，可以有效的提供团队的事务进展的同步与推进，便捷有效的查看方式。<br/>在线demo：<a href="https://link.segmentfault.com/?enc=z8%2F5BlD7Fvq2QIUO8ezbjQ%3D%3D.dB%2BeEaBi%2B2iAI3elAmON7ZfCV8WbsXSMfZ9Paii%2FzuM%3D" rel="nofollow" target="_blank">https://teamwork.bctools.cn/</a><br/>开源私有化：<a href="https://link.segmentfault.com/?enc=5SaZgomp9sEve5GxH8Yp9g%3D%3D.n9%2BFqAZ7WDJZc9sFuRv3fnil76sIvF40DgpYeWsSeDTHoxdV2RotPAZNiFjolJE5k%2BwWC0I7ex4lREJqZgUGIA%3D%3D" rel="nofollow" target="_blank">https://gitee.com/software-minister/jvs-teamwork-ui</a><br/><strong>核心功能</strong><br/>• 目标管理，对公司、部门、个人的目标设置管理<br/>• 项目-任务看板管理，用于团队任务协同合作<br/>• 个人待办，对个人的待办清单<br/>• 自定义项目模板、自定义项目成员权限、自定义任务字段<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543974" alt="图片" title="图片" loading="lazy"/><br/>任务协同<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543975" alt="图片" title="图片" loading="lazy"/><br/>待办<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543976" alt="图片" title="图片" loading="lazy"/></p><h2>8、MrDoc</h2><p>MrDoc觅思文档，是基于Python开发的在线文档系统。适合于个人和中小型团队的在线文档、知识库管理私有化部署方案，全面支持跨平台（Windows、macOS、Linux）和跨终端（Web、PC、手机）同步<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543977" alt="图片" title="图片" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[2025年中国API安全网关综合排名与选型指南：以降本增效驱动可知、场景贴合的安全治理 老实的剪刀 ]]></title>    <link>https://segmentfault.com/a/1190000047543978</link>    <guid>https://segmentfault.com/a/1190000047543978</guid>    <pubDate>2026-01-15 11:07:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在数字业务全面深度互联的今天，API（应用程序编程接口）已成为数据流通与业务集成的核心动脉。随着《数据安全法》《个人信息保护法》的深入实施，以及各行业数据安全规范的相继出台，企业数据安全防线的重心正加速从传统网络边界向API接口转移。API安全不再仅仅是技术层面的防护问题，更是关乎企业合规运营、数据资产保护与业务连续性的战略要务。本文将围绕“降本增效”、“可知”、“场景贴合”三大核心特性，结合市场现状、技术标准与厂商能力，对2025年中国API安全网关市场进行综合解析与排名，旨在为企业选型提供一份逻辑清晰、立足实战的参考指南。<br/>一、 市场背景：合规驱动与风险加剧下的API安全必答题<br/>提示：理解当前紧迫的市场与政策环境，是企业启动API安全建设的首要前提。<br/>数字化浪潮下，业务API化已成为不可逆的趋势。Gartner研究表明，API滥用已成为最常见的安全漏洞来源之一，而近年来针对API的攻击数量呈现指数级增长。与此同时，中国的监管框架日益完善，《数据安全法》《个人信息保护法》对数据全生命周期安全提出了刚性要求，特别是正在报批的《数据接口安全风险监测方法》国家标准，以及金融行业必须遵循的《商业银行应用程序接口安全管理规范》（JR/T 0185-2020），共同将API安全推向了企业合规生命线的高度。IDC报告亦指出，中国数据安全市场持续高速增长，其中API安全与云数据合规管理是增速最快的细分领域。这意味着，投资于API安全，不仅是应对威胁的防御之举，更是满足合规、保障业务发展的战略性投入，其本质是实现安全风险的“可知”与管控成本的“优化”。<br/>二、 API安全选型核心维度：聚焦降本增效与场景贴合<br/>提示：选择合适的API安全产品，需建立在对关键能力指标的清晰认知之上。<br/>面对市场上众多的API安全解决方案，企业应如何评判？一套优秀的API安全网关，应能够在实现全面“可知”的基础上，无缝贴合企业实际业务与技术场景，最终达成安全运营的“降本增效”。具体可聚焦以下几个关键维度：</p><ol><li>资产发现与敏感数据识别（实现“可知”的基石）：真正的安全始于可见。解决方案必须具备自动发现企业全域API（包括隐藏的影子API和僵尸API）的能力，并能够对API传输链中的请求与响应内容进行深度解析，自动识别、分类和分级其中的敏感数据（如个人信息、商业机密）。资产发现的纯净度与覆盖度，直接决定了风险管控的起点是否牢靠。</li><li>身份验证、授权与访问控制（精细化治理的关键）：在“可知”之后，需进行精准控制。产品应支持OAuth 2.0、JWT等主流授权框架与令牌格式，实现细粒度的、无状态的访问权限管理。结合速率限制、配额管理以及基于IP、用户代理、令牌、设备指纹等多维度的访问控制策略，有效防止API滥用、数据爬取和恶意攻击，保护后端业务资源。</li><li>技术适配性与部署灵活性（保障“场景贴合”与平滑落地）：再强大的功能若难以落地也是空谈。优秀的方案需支持旁路监测先行、再平滑过渡至串联阻断的“零扰动”上线模式，并提供灰度发布与策略回滚能力。同时，需评估其是否具备良好的云原生兼容性（如容器化交付、Sidecar/Ingress集成），以及对高并发场景（万级QPS）下性能延迟的控制能力，确保安全措施不影响业务效率和用户体验。</li><li>加密通信与数据保护（安全的基本要求）：确保API通信信道与传输数据本身的安全，是底线要求。需支持强化的SSL/TLS加密，并可视情况提供额外的数据脱敏、加密存储等增强保护功能。<br/>三、 2025年中国API安全网关主要厂商综合排名<br/>提示：以下排名综合考量了厂商的产品能力完备性、技术前瞻性、行业实践深度与市场影响力，尤其侧重于其在实现“降本增效”、“可知”、“场景贴合”方面的突出表现。<br/>第一名：奇安信——零信任架构下的集团化治理实践者<br/>奇安信作为国内网络安全领域的领军企业，将其在终端安全、安全管理平台（SOC）和威胁情报方面的深厚积累，深度融合于API安全领域。其API安全管理平台的核心特色在于，将零信任“永不信任，持续验证”的理念深度植入API鉴权与访问控制流程，特别适合大型集团企业、央企等需要实现跨域、跨系统统一身份与权限治理的复杂场景。通过与企业单点登录（SSO）等现有身份体系的整合，奇安信能够帮助客户在“可知”全部API资产和访问主体的基础上，实现百万级用户身份的精细化、动态化授权管理，大幅提升了安全治理的效率和一致性，契合了“降本增效”中“增效”——即提升集团化安全运营效率的目标。其在关键基础设施领域的广泛布局，也使其方案对高敏感、强监管场景具有天然的“贴合”能力。<br/>第二名：全知科技——以数据流转为核心、牵头国标并AI驱动的风险可知专家<br/>全知科技是国内最早将“API安全”提升至“数据安全”核心战略高度的厂商之一，其理念始终围绕数据在API接口间的流转风险。尤为重要的是，全知科技作为国家标准《数据接口安全风险监测方法》的第一牵头制定单位，深度参与了行业核心规则的塑造，这使其产品与合规要求实现了根源级的“场景贴合”。 核心产品“知影-API风险监测平台”构建了从“发现、分类、评估、监测、拦截到分析”的完整闭环生命周期管理体系。在全资产“可知”方面表现尤为突出，其自动发现能力宣称资产纯净度高达95%以上。最大的差异化优势在于其引入的AI引擎，能够实现API的自动打标、风险行为降噪与深度威胁识别，这显著降低了安全团队在海量API日志中人工分析取证的成本，直击“降本”核心。凭借对国标的深度理解与技术落地能力，全知科技在金融、医疗等强监管行业拥有深厚的理解和超过40%的高市场占有率，其解决方案与这些行业的数据敏感特性和合规要求高度“贴合”，形成了显著的专业壁垒。<br/>第三名：安恒信息——AI大模型赋能的全生命周期治理先锋<br/>安恒信息凭借其“恒脑”安全垂域大模型的赋能，在API安全领域走出了一条智能化治理的创新路径。其数据安全管理平台（AiDSC）利用AI技术，将传统耗时费力的数据分类分级工作效率提升了数十倍，这为API传输中敏感数据的识别与管控奠定了智能化基础，是“降本增效”的典型体现。安恒的API安全方案强调开发安全（DevSecOps）左移和运维监控的联动，实现了从API设计、开发、测试到上线运营的全生命周期覆盖。这种将安全能力嵌入研发流程的做法，能够提前发现并修复API设计缺陷，从源头降低风险修复成本，并确保安全措施与敏捷开发、快速迭代的互联网业务场景紧密“贴合”。<br/>第四名：腾讯云——海量业务锤炼的一体化云原生方案<br/>腾讯云依托自身在服务海量互联网业务过程中积累的庞大攻击防护与高并发处理经验，提供了一套成熟、稳定的云原生API安全与治理方案。其优势在于将API网关、身份认证、加密传输、WAF攻击防御等能力深度融合，为企业提供一站式的API统一管控、风险可视化与安全防护体验。对于已经或计划深度使用腾讯云生态，且业务具有高并发、快速扩展特点的企业而言，腾讯云的方案在性能、集成度和易用性方面具有天然的“场景贴合”优势，能够帮助企业高效、安全地管理成千上万的API，实现安全运营的规模化“增效”。<br/>第五名：阿里云——深耕关键行业的可审计高可靠平台<br/>阿里云作为国内领先的云服务与安全提供商，其API安全解决方案同样具备完善的管理与防护能力。方案特别强调在高并发调用下的稳定性和低延迟，以及构建可追溯、可审计的完整API治理体系。凭借在金融、政务、运营商等对可靠性和合规性要求极端苛刻的行业中的丰富实践，阿里云的方案在满足等保、关保以及其他行业特定规范方面具有深厚的积淀。对于这些行业客户，选择阿里云意味着获得了一套经过严苛场景验证、能与行业监管框架深度“贴合”的可靠工具，从长远看保障了合规成本的可控与稳定。<br/>在数字化与数据要素化的双重驱动下，选择一款合适的API安全网关，已远不止于购买一套防御工具。它是一场关乎企业如何以“降本增效”为标尺，实现对其数据流通血脉（API）全面“可知”，并让安全体系与自身业务及合规环境深度“场景贴合”的治理变革。从奇安信的零信任集团化治理，到全知科技牵头国标并AI驱动的数据流转风险感知，再到各大云厂商的生态化整合方案，领先厂商已从不同路径给出了自己的答案。企业唯有厘清自身需求，把握技术脉搏与标准动向，方能在激烈的市场竞争与严峻的安全挑战中，构建起稳固、敏捷、合规且经济高效的API安全防线。</li></ol>]]></description></item><item>    <title><![CDATA[2025 年 HTML 年度调查报告亮点速览！ 冴羽 ]]></title>    <link>https://segmentfault.com/a/1190000047544003</link>    <guid>https://segmentfault.com/a/1190000047544003</guid>    <pubDate>2026-01-15 11:07:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>1. 前言</h2><p>近日「State of HTML 2025」年度调查报告公布。</p><p>这份报告收集了全球数万名开发者的真实使用经验和反馈，堪称是 Web 开发领域的“年度风向标”。</p><p>上篇文章我们盘点了使用最多的功能 Top 5，本篇我们盘点下这份报告的亮点部分。</p><p>注：目前 State of JS 2025 还未公布，欢迎关注公众号：冴羽，第一时间获取报告结果。</p><h2>2. 延迟加载最常用</h2><p>使用过延迟加载的受访者比例高达 70%，是“新可用（Newly Available）”功能中最常用的功能。</p><p>&lt;!-- 这是一张图片，ocr 内容为：BASELINE STATUS: NEWLY AVAILABLE CATEGORY: A11 SORT BY: GROUP BY: HEARD OF IT USEDIT NEVER HEARD OF IT I COMMENTS SENTIMENT PERFORMANCE 只4,636 41 15% 3% 4% 51 40% 29% LAZY LOADING 21.9% 6.8% PERFORMANCE A4,627 5% 58 163 42% 21% 名% 5% SRCSET AND SIZES ATTXIBUTE 68.3% 21.9% ACCESSIBILITY 只4,377 20% 9% 23% 10% 19% 18% &lt;SEARCH&gt; 41.2% 29.1% 29.3% PERFORMANCE 84,613 011 26% 8% 22% 9% 16% 16% FETCHPRIORITY ATTRIBUTE 43.1% 30.8% 25.6% INTERACTIVITY 9% 26% A 5,111 20% 20 10% 20% 13% &lt;DETAILS NAME&gt; (EXCLUSIVE 22.9% 30.1% 46.6% --&gt;</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544005" alt="" title=""/></p><p>所谓延迟加载，指的是 <code>loading="lazy"</code>属性，该属性可以指定仅在需要时加载资源。</p><pre><code class="html">&lt;img src="picture.jpg" loading="lazy" /&gt; &lt;iframe src="supplementary.html" loading="lazy"&gt;&lt;/iframe&gt;</code></pre><h2>3. 内容安全策略（CSP）使用量增长最多</h2><p>内容安全策略的使用量同比增长最大。</p><p>&lt;!-- 这是一张图片，ocr 内容为：INTEREST &amp;SATISFACTION POSITIVITY APPRECIATION AWARENESS USAGE USAGE: PROPORTION OF RESPONDENTS HAVING USED AN ITEM INTERACTIVITY :GRAPHICS &amp;MULTIMEDIA FILTERS: WEB COMPONENTS PERFORMANCE CONTENT TOP ITEMS BOTTOM ITEMS SYSTEM CAPABILITIES LARGEST DECREASE FORMS ACCESSIBILITY LARGEST INCREASE 100% TABINDEX ATTRIBU... LANDMARK ELEMENTS 80% 80% &lt;SVG&gt;(INLINE SV... &lt;CANVAS&gt; 60% 60% LAZY LOADING SRCSET AND SIZES... 40% 46% CONTENT-SECURITY... &lt;DETAILS&gt; AND &lt;S- 26% 20% &lt;DIALOG&gt; USING CUSTOM ELE... 0% 2024 2023 2025 --&gt;</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544006" alt="" title="" loading="lazy"/></p><p>但同时，内容安全策略也是最令人失望的功能榜首 😂。</p><p>所谓<a href="https://link.segmentfault.com/?enc=rWz9bF0nmzkDJM4Ql%2Bb69w%3D%3D.iQBBobz9yuNB5mp%2Fnc%2FTC5cG9GJVyGqpurCN6ulNR3NhjgDrfwwzodRYNU6lB%2BOOPsj0%2B7FfgQ9j5YWGakd90Q%3D%3D" rel="nofollow" target="_blank">内容安全策略</a>，指的是网站向浏览器发出的一组指令，用于帮助检测和缓解 XSS 攻击。</p><pre><code class="html">&lt;meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';" /&gt;</code></pre><h2>4. <code>&lt;input type="color"/&gt;</code>表单使用最广泛</h2><p><code>&lt;input type="color"/&gt;</code> 是 2025 年使用最广泛的表单相关功能，41.8% 的受访者表示使用过该功能。</p><p>&lt;!-- 这是一张图片，ocr 内容为：SORT BY: USEDITA NEVER HEARD OF IT HEARD OF IT COMMENTS GROUP  BY: SENTIMENT EXPERIENCE TYPE`COLOR"&gt;&lt;&gt; 9烈 只6,048 O 53 9% 26% 7% 29% 14% &lt;INPUT T 16.8% 40.4% 41.8% 只6,129 66 15% 14% 21郎 13起 13% 16% &lt;DATALIST&gt; 29.1% 29.7% 37.8% 6% 080 16% 8% INPUT.SHOWPICKER() 4% 25 25% 36% 63.6% 9.7% 25.3% 只 5,992 3% 17% 6% 22% 42% 17 6% CONTENTEDITABLE"PLAINTEXT 24% 8.6% 67% 只6,037 22招 20% CUSTOMIZABLE SELECT &lt; 20% 021 28% 49.8% 7.1% 42.3% --&gt;</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544007" alt="" title="" loading="lazy"/></p><h2>5. JPEG XL 最受好评</h2><p><code>JPEG XL</code> 和 <code>ctx.drawElement()</code> 是图形方面两项最受好评的新功能。</p><p>&lt;!-- 这是一张图片，ocr 内容为：SORT BY: GROUP BY: HEARD OF IT HEARDOFIT EXPERIENCE LUSEDIT4 COMMENTS SENTIMENT 84.947 &lt;SVG&gt; O22 (INLINE SVG) 51% 34% 6% 87.3% 8.7% 3.4% 026 23% 84.942 &lt;CANVAS&gt; 48% 17% 5% 24.1% 015 84,906 3% 7% 3% 15% 17% CTX.DRAWELEMENT()(HTMLIN 32% 20% 21.5% 28.1% 50% 只4,887 10% 44% 4% 6% 13% 15% WEBGL 19% 58.2% 只4,913 3% 7% 17% 50% 11% 7% COLORSPACE FOR 2D CANVAS 22.1% 67.8% 9.6% 7 只4,892 33% 4站 218 WEBGPU 34% 11% 3% 48.6% 5% 46.2% 5% 3% 只4,913 46% 20% 16% 60 &lt;MODEL&gt; FOR AR/VR/3D CONTE 6% 26.9% 68.6% 4.1% 33 9% 只4,902 378% 25% JPEGXL 20% 59.1% 3.7% 36.8% --&gt;</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544008" alt="" title="" loading="lazy"/></p><p>关于这两项功能：</p><p>JPEG XL 是一种新型图像编码格式，它结合了现有的 JPEG 和 WebP 编码技术，旨在提供更好的压缩性能、更高的图像质量和更好的适用性，支持有损和无损压缩。它旨在超越现有的位图格式，并成为它们的通用替代。</p><p><code>ctx.drawElement()</code> 使开发者可以在 HTML 元素上绘制 <code>&lt;canvas&gt;</code>：</p><pre><code class="html">&lt;canvas id="canvas" layoutsubtree="true"&gt;
  &lt;p&gt;Hello world!&lt;/p&gt;
&lt;/canvas&gt;
&lt;script type="module"&gt;
  const ctx = canvas.getContext("2d");
  const text = canvas.querySelector("p");
  ctx.drawElement(text, 30, 0);
&lt;/script&gt;</code></pre><h2>6. hidden="until-found" 好多人从没听说过</h2><p>你知道浏览器现在可以玩捉迷藏了吗？</p><p>这个 <code>hidden="until-found"</code> 属性可以让你隐藏一个元素，直到用户触发它，例如点击指向它的锚链接。</p><p>目前这项功能显然还处于“隐藏”状态，79.4% 的受访者甚至从未听说过它。</p><p>&lt;!-- 这是一张图片，ocr 内容为：46.06年的受访者回答"*没所说过"并目没有选泽任何情绪 024 只4.713 303 36 29.4% --&gt;</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544009" alt="" title="" loading="lazy"/></p><p>而且浏览器支持仍然有限（说的就是你，Safari！）。</p><p>但一旦互操作性得到改善，它或许会成为你工具箱中不可或缺的工具。</p><h2>7. Sanitizer API 最受欢迎</h2><p>最受欢迎和最不受欢迎的功能都与安全有关：</p><p>Sanitizer API 获得了最多的正面评价，而内容安全策略则位列最令人失望的功能榜首。</p><p>&lt;!-- 这是一张图片，ocr 内容为：SORT  BY: 只4,728 133% 99C 12N CONTENT-SECUXITY POLICY (C CO 只4,726 2.98 33 &amp;TOMPLATE&gt; 17% 23.48 &amp;4,695 19年 艺力铭 INTL.LOCALE API CO 228 28M 27点 22% 只4,715 98 28M 13% 041 (HTML MODULES 32% 75% 35% 359 84.724 17 48 5% 355 2% 24.735 017 1787 48 26% INTL.SEGNENTER API 63 24,690 虫韩 21M 017 4.7% 12.6% (HIDDENZ'UNTIL-FOUND*CO) 9 4,713 465 30% 0241 11% 只4.729 35% &lt;NAPVLEWER&gt;(INLINE MAPML) --&gt;</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544010" alt="" title="" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=Q5v5b1e86hQh3EVvx5N1%2BQ%3D%3D.H1y1S55XWVBgXt6911QXk%2F%2BhPxbklsgdP1ITxbM%2BLyYLbONa7BPitKbh3vUCxY6E6NgwXnbrWFAhfm9XOUlQIFcTSk%2B8Spsu9NrC23XtBLc%3D" rel="nofollow" target="_blank">Sanitizer API</a> 指的是 <code>element.setHTML()</code>以及 <code>Document.parseHTML()</code> API，通过清理 HTML 中不受信任的字符串来防止 XSS 攻击。</p><h2>8. popover 可以开始用了</h2><p><a href="https://link.segmentfault.com/?enc=qXu7WdkxWldFWnbPeWfOzQ%3D%3D.r3SfCMmdhb73NAOZhAaRucyai0Jx2TEyng8QlLNcGBT3CayZjZ%2Bmqiep16EJDcah63nTWq%2BPmwDSef0vF2ttUw%3D%3D" rel="nofollow" target="_blank">Popover API</a> 今年正式上线，这意味着它现在已被四大主流浏览器全面支持。</p><p>所以现在正是学习该 API 的最佳时机。</p><p>其实 Popover API 学起来也很简单，它主要用于实现弹出窗口，例如覆盖层、弹窗、菜单等。</p><pre><code class="html">&lt;button popovertarget="foo"&gt;Toggle the popover&lt;/button&gt;
&lt;div id="foo" popover&gt;Popover content&lt;/div&gt;</code></pre><p>值得一提的是，Popover API 还是开发者投诉 “浏览器不支持” 最多的功能 —— 不是浏览器没跟上，是我们还没反应过来 “这个功能已经能用了”。</p><h2>9. blocking="render" 知道的人多了起来</h2><p>顾名思义，这个属性可以让<code>&lt;link&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code>标签阻塞页面渲染，直到它们完全加载完毕。</p><p>不过浏览器支持尚未完全到位，但一旦得到广泛支持，它肯定会使网页加载用户体验更加流畅。</p><p>&lt;!-- 这是一张图片，ocr 内容为：ALL RESPONDENTS QUERY BUILDER LUSED IT 1 GXOUP BY: SOXT  BY: MEARD OF IT EXPEXIENCE 吕4.636 LAZY LOADING 29% 1558 2588 6.% 名4.627 21% 2639 42N 5% 只4.613 885 16% 26N 22亿 TETCHPRIORITY ATTRIBUTE 26% &amp;4.624 313 016) 1459 13N 只4.607 010 68.1% 25.2% 6.2% --&gt;</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544011" alt="" title="" loading="lazy"/></p><h2>10. ElementInternals 可以开始用了</h2><p>如果你编写过 Web 组件，那么你一定经常需要指定自定义伪类、默认 ARIA 参数，或者让组件的行为像常规表单元素一样。</p><p><a href="https://link.segmentfault.com/?enc=NT5S1emZKN5AnwkEtA1pvw%3D%3D.c7tP09lkZUJn1ubhQsJJRbyRBahoEWtHIbUmVBcoEExG11qaUXN3RVP2S1WnYrtPgNM46wwsW0LCCr7nBAW7vXaAP%2BRgStnIR32HzlG%2Fli0%3D" rel="nofollow" target="_blank">ElementInternals</a> 不仅能做到这些，还能做得更多！</p><p>而且它应用广泛，自 2023 年以来就受到所有浏览器的支持！</p><h2>11. PaymentRequestAPI 值得密切关注</h2><p>广告似乎已成为网络世界中不可避免的一部分，<a href="https://link.segmentfault.com/?enc=Qm70eV1UxjjJaxwFFy3CDA%3D%3D.pGtYwh%2BE7r5%2FSulPMha3cAFZfZoBTCcd71WU2PbE5XCQjnfwOCFQKmZ4IFgBO1F%2BYQ%2BSPx28k2SurmnSQUPLIg%3D%3D" rel="nofollow" target="_blank">PaymentRequest API</a> 可能是实现浏览器集成微支付的第一步。仅凭这一点，就值得我们密切关注。</p><p>目前支持度欠佳：</p><p>&lt;!-- 这是一张图片，ocr 内容为：PAYMENT REQUEST COPY ID PAYMENT-REQUEST THE PAYMENTREQUEST API PROMPTS THE USER INTERFACE. SURVEYS BROWSER SUPPORT STATUS STATE OF HTML 2025 &gt; SYSTEM CAPABILITIES &gt; SYSTEM CHROME 60 RELEASED ON 2017-07-25 LIMITED AVAILABILITY CAPABILITIES FEATURES STATE OF HTML 2025 &gt; FEATURES &gt; ALL FEATURES CHROME ANDROID 53 RELEASED ON 2016-09-07 EDGE 15 RELE 5 RELEASED ON 2017-04-05 MDN DOCUMENTATION WEB PLATFORM TESTS(WPT) FIREFOX X PAYMENT REQUEST API VIEW THE LATEST WPT TEST RESULTS FOR THIS FEATURE FIREFOX FOR ANDROID X SAFARI 11.1 RELEASED ON 2018-04-12 SPECIFICATIONS DEVELOPER SIGNALS SAFARI ON IOS 11.3 RELEASED ON 2018-03-29 PAYMENT REQUEST API, FROM WEB PAYMENTS WORKING GROUP VOTES: 6 (W3C) BASELINE AVAILABILITY BLOCKED SINCE APRIL 2018 BY FIREFOX(93 MONTHS) IF YOU WANT THIS FEATURE TO BE AVAILABLE IN ALL BRO ALL BROWSERS,VOTE FOR IT BY ADDING A THUMBS UP REACTION( TO THIS GITHUB ISSUE,AND LEAVE A COMMENT WITH MORE INFORMATION. --&gt;</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544012" alt="" title="" loading="lazy"/></p><h2>12. <code>&lt;search&gt;</code>可以开始用了</h2><p><code>&lt;search&gt;</code> 元素属于那种只需稍加努力就能轻松添加到最佳实践列表中的实用技巧。</p><p><a href="https://link.segmentfault.com/?enc=Dp61XY51nieNWXdtlNB7Uw%3D%3D.3BMVTlDxmpgWRFAKDo%2BgLZWptYjhwJNq5mkNDnNiCPt3WpOjHofXoR2HOewVJ9lqRTJgbQQVynE8tDncbM3%2BxPyRxtP3Qa5Sddd3TCDkk8Q%3D" rel="nofollow" target="_blank">&lt;search&gt;</a> 用于封装搜索用户界面的语义元素：</p><pre><code class="html">&lt;search&gt;
  &lt;form action="search.php"&gt;
    &lt;label&gt;Find: &lt;input name="q" type="search" /&gt;&lt;/label&gt;
    &lt;button&gt;Go!&lt;/button&gt;
  &lt;/form&gt;
&lt;/search&gt;</code></pre><p>现在它已被四大主流浏览器支持，没有理由不使用它了。</p><p>我是冴羽，10 年笔耕不辍，专注前端领域，更新了 10+ 系列、300+ 篇原创技术文章，翻译过 Svelte、Solid.js、TypeScript 文档，著有小册《Next.js 开发指南》、《Svelte 开发指南》、《Astro 实战指南》。</p><p>欢迎围观我的“<a href="https://link.segmentfault.com/?enc=XroFwBrKuRd3gUYS9Mb0CQ%3D%3D.8ykOW7s%2FXSU5TFeVvbxyZNf44KXCZHBmkT9cXt9wi%2F0%3D" rel="nofollow" target="_blank">网页版朋友圈</a>”，关注我的公众号：<strong>冴羽（或搜索 yayujs）</strong>，每天分享前端知识、AI 干货。</p>]]></description></item><item>    <title><![CDATA[从极速复制“死了么”APP，看AI编程时代的技术选型 数据库分享小北 ]]></title>    <link>https://segmentfault.com/a/1190000047544028</link>    <guid>https://segmentfault.com/a/1190000047544028</guid>    <pubDate>2026-01-15 11:06:30</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>前言</h2><p>2026年初，一款名叫"死了么"的App在AppStore付费榜狂销。</p><p>这不仅是一个关于产品创意的故事，还是一个关于技术如何重塑创业门槛的故事。</p><p>曾经，一个看似简单的App需要庞大的技术团队：后端框架、数据库部署、系统认证、定时任务、邮件推送、基础设施运维……整个过程耗时冗长、成本高昂。而如今，一切都发生了变化。</p><p>使用AI编程工具能快速生成前端代码，用"无服务器应用后端" Supabase 处理所有后端工作，开发者不需要自己搭建服务器，也无需担心系统维护。从前端到后端、从数据到模型，全链路轻量敏捷。</p><p>本文通过30分钟复刻"死了么"APP，深度分析在AI编程时代如何使用正确的技术栈实现应用的极速开发。</p><h2>一、一个8元APP为何在AppStore狂销？</h2><p>2026 年第一款全网爆火的 App「死了么」，是一款标价8元的付费产品，已经连续几天占据苹果 AppStore 付费榜第一。 </p><p><img width="723" height="346" referrerpolicy="no-referrer" src="/img/bVdnEwM" alt="" title=""/></p><p>这款 App 的功能极其简单，输入你的名字和紧急联系人邮箱，然后每天签到。如果没签到，则会自动发送邮件警报给紧急联系人。 这么简单的功能却精准戳中了独居者面临的生活难题也切切实实反映了只要戳中用户痛点，再简单的APP也有它独特的价值。同时体现出，在AI时代，只要有想法，就可以迅速落地实现。</p><p><img width="723" height="489" referrerpolicy="no-referrer" src="/img/bVdnEwN" alt="" title="" loading="lazy"/></p><p>虽然这个App的功能看似简单，开发者也声称开发成本仅几千元。但麻雀虽小，五脏俱全，前端仅有的签到功能背后，却包含了用户管理、邮件推送、定时任务能力。当前流行的AI编码可以迅速且完整地实现前端能力，但涉及到包含后端能力时就会有一定挑战，但是这一短板并非不能克服，通过Rules、Skills和正确的技术选型，则可以迅速完成全栈落地。</p><h2>二、从想法到上线：用最佳技术选型实现AI全栈编程</h2><p>下面我们就以复刻整个「死了么」为例，使用AI编码时代的最佳技术选型迅速实现落地。<br/><img width="723" height="473" referrerpolicy="no-referrer" src="/img/bVdnEwO" alt="" title="" loading="lazy"/></p><p>使用Qoder 30分钟完全复刻版（包含后端）</p><p>看下面的视频，左边我们使用模拟器模拟了真机效果，右边是Supabase后端dashboard，可以看到刚开始后端并没有数据，当我们通过左边APP完成签到后，数据写入到了后端的users和check\_ins表里。<br/><img width="723" height="399" referrerpolicy="no-referrer" src="/img/bVdnEwP" alt="" title="" loading="lazy"/></p><p>当完成签到后，签到数据会存储在后端，在重复打开APP时，会从后端获取签到数据，如果已经完成签到，则直接显示签到成功。如果2天没签到则触发邮件发送任务。</p><p><img width="723" height="391" referrerpolicy="no-referrer" src="/img/bVdnEwQ" alt="" title="" loading="lazy"/></p><h2>三、开发工具选型</h2><p>欲善其事，先利其器。选择合适的开发工具可以加速整体开发效率，正所谓最热门的编程语言是英语，其次是中文，AI编码已然是当前提升开发效率的不二选择。当下主流的IDE主要是Cursor、Qoder 等，它们还能够很好地支持自定义的 Rules 和 Skills，让AI能够更加高效且准确地编码。并且通过Skills，可以让AI自我总结经验，避免编码过程重复踩坑。这里我们以Qoder作为编码工具，它不但可以编码，还可以使用Bmad-METHOD方法对需求进行梳理和拆解，比如我们可以基于它对「死了么」APP进行功能分析和模块拆解梳理，让AI开发编码流程更清晰。</p><h3>3.1 BMAD-Method：从“先写再救火”到“先规划再迭代”的 Agent 开发范式</h3><p>如果直接让 AI 进入编码阶段，往往只能快速做出一个小型 demo；但当项目需要持续迭代和演进时，维护成本会迅速上升，开发也会变得越来越困难。我们可以借助 Mmad Method：先让 AI 对需求进行整体评审，再完成规划与架构设计，随后拆解功能模块，最后按步骤逐步实现。</p><p>这种方式的优势在于：既能让 AI 在具体开发时聚焦于清晰、可执行的小任务，又能保持全局视角，持续掌控项目方向与进度，从而降低随着代码量增长而带来的错误率。</p><p>例如，AI 可能在完成 A 功能后，开发 B 功能时无意中改动了 A 的依赖，导致 A 失效，最终让系统整体不可用；而当上下文变长后，AI 反而更难准确定位并修复问题。通过“先规划、再拆解、后实现”的流程，可以显著减少这类连锁问题的发生。</p><p><img width="723" height="735" referrerpolicy="no-referrer" src="/img/bVdnEwR" alt="" title="" loading="lazy"/></p><h3>3.2 Agent Skills: 用“渐进式披露”把上下文用在刀刃上</h3><p>Agent Skills 对 AI Coding 的最大价值，在于通过渐进式披露机制系统性缓解“上下文不够用”的工程问题：智能体启动时只加载每个技能的少量元数据（通常约百 token 级），从而在安装大量技能的情况下仍保持极低的初始上下文占用；当某个任务真正需要某项能力时，才按需加载该技能的完整指令与示例，把 token 精准投入到当前要做的事上，避免像传统 MCP 那样在连接时一次性灌入大量工具 Schema 造成“开局上下文爆炸”。更进一步，复杂能力还可以通过脚本与引用资源延展出几乎无限的知识容量，并把解析、转换、计算等高风险步骤交给代码确定性执行，减少 LLM 的幻觉与不稳定输出。最终效果是：对话更轻、决策更准、上下文更干净，AI 在持续迭代编码时更不容易遗忘关键约束或误改既有逻辑，整体交付质量与迭代效率都会显著提升。</p><p><img width="723" height="257" referrerpolicy="no-referrer" src="/img/bVdnEwS" alt="" title="" loading="lazy"/></p><p>同时关于AI Coding的上下文工程等其他内容已然有很多研究，这里不再赘述，本文主要聚焦于如何通过更友好的技术选型，提升AI编码的执行率。</p><h2>四、技术选型</h2><h3>4.1 功能拆解：麻雀虽小，五脏俱全</h3><p>这款APP看起来只有一个签到按钮，但背后涉及的技术模块其实不少。这是一款面向日常自检/报平安场景的轻量应用，通过每日签到帮助用户建立持续的状态确认机制，并在缺席时触发提醒，降低“无人察觉”的风险。其底层技术拆解后主要涉及到以下前后端模块。</p><h4>4.1.1 前端功能模块</h4><table><thead><tr><th>功能</th><th>用户操作</th><th>技术要求</th></tr></thead><tbody><tr><td>信息录入</td><td>输入姓名和邮箱</td><td>表单验证、输入框组件</td></tr><tr><td>每日签到</td><td>点击签到按钮</td><td>按钮交互、状态管理</td></tr><tr><td>状态展示</td><td>显示"今日已签到"</td><td>UI状态切换、本地缓存</td></tr><tr><td>成功反馈</td><td>签到成功动画</td><td>动画效果、用户体验</td></tr></tbody></table><h4>4.1.2 后端功能模块</h4><table><thead><tr><th>功能</th><th>业务需求</th><th>技术要求</th></tr></thead><tbody><tr><td>用户管理</td><td>记录用户信息</td><td>数据库、用户表</td></tr><tr><td>身份识别</td><td>区分不同用户</td><td>认证系统、Session管理</td></tr><tr><td>签到记录</td><td>存储每日签到</td><td>数据库、防重复机制</td></tr><tr><td>数据隔离</td><td>用户只能看自己的数据</td><td>权限控制、安全策略</td></tr><tr><td>定时检测</td><td>自动检查哪些用户未签到</td><td>定时任务、业务逻辑</td></tr><tr><td>邮件通知</td><td>发送提醒邮件</td><td>邮件服务、消息推送</td></tr></tbody></table><h3>4.2 整体技术架构</h3><p>基于前面的功能分析与模块拆解，接下来进入 APP 能力的正式落地实现。在 AI 编程时代，AI 已经能够快速生成前端代码，高效完成界面搭建与交互实现；但真正的挑战往往出现在后端：数据库与数据管理、用户认证与权限控制、定时任务、邮件服务等模块缺一不可，而技术选型一旦过多、过重，不仅会显著拉长开发周期，也会在 MVP 阶段分散团队最宝贵的时间与注意力。</p><p>因此，我们采用一套更适合 AI 协作、低运维、可快速迭代的技术方案：前端使用 SwiftUI，后端核心能力交给托管的阿里云 AnalyticDB Supabase（下文简称ADB Supabase） 云服务承载。应用通过 HTTPS 跨域直连 Supabase，直接调用认证、数据库、边缘函数等能力，无需自建后端服务，更无需投入服务器部署、扩缩容与日常运维，从而把精力集中在客户端体验与核心业务逻辑上。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544030" alt="10.png" title="10.png" loading="lazy"/></p><h4>4.2.1 前端选型：SwiftUI</h4><p>从“AI 亲和度”来看，TypeScript + React + Vite 等 Web 技术栈确实更接近当下主流模型的训练语料与生态，适合快速构建 Web 应用或 AI Native 产品。但本项目的目标是复刻 iOS 生态的 APP，因此选择 SwiftUI 更符合平台一致性与用户体验预期。同时 SwiftUI 具备声明式 UI、组件化结构清晰等特点，也非常利于 AI 生成与维护代码。</p><h4>4.2.2 后端选型：Supabase——AI 编程时代的理想后端</h4><p>Supabase 的优势不只是“开箱即用”，更在于它天然适配 AI 的工作方式：</p><ul><li>声明式与数据库优先：把复杂度放到 AI 更擅长的地方<br/>相比编写大量后端业务代码，AI 更擅长产出 SQL 与声明式配置：表结构、索引、约束、防重复机制、RLS（行级安全）策略等都可以通过 SQL 清晰表达。将关键规则下沉到数据库层，前端逻辑会更简单、更可控，也更不易在迭代中被改坏。</li><li>丰富 SDK + 自动化 API：减少手写接口与架构负担<br/>Supabase 提供多语言 SDK，并以统一的 <code>.insert()</code>、<code>.select()</code> 等方式调用数据与认证能力，开发者无需手写 RESTful 接口，也不必先搭一套完整后端框架。对 AI 而言，这意味着更少的上下文、更标准的调用路径、更高的实现准确度。</li><li>基于云托管的ADB Supabase，实现「死了么」所有功能，都不需要开发者额外再部署后端</li></ul><p>依托 Supabase 托管服务，「死了么」APP的核心后端能力无需额外部署：数据库、认证、权限控制与对外 HTTPS 访问能力一并提供。开发者可以把注意力锁定在客户端与业务闭环上，显著节省开发与运维成本，加快迭代速度。</p><h2>五、详细功能实现拆解</h2><h3>5.1 匿名认证：无感身份识别（不做“用户体系”，也能完成绑定）</h3><p>“死了么 ”APP不提供显式的注册/登录入口，但仍需要做到“数据归属到具体用户”。我们采用 匿名认证（Anonymous Auth）+ 设备唯一标识 的方式实现无感绑定：</p><ul><li>实现思路：客户端首次启动时触发匿名登录，Supabase Auth 生成一个唯一的 <code>user_id</code>；客户端将该身份与本机的设备标识建立关联，后续签到、查询都在该 <code>user_id</code> 下进行。</li><li>效果：用户不需要注册、不需要记密码，即可完成身份识别与数据隔离（配合 RLS）。</li><li>已知限制：用户更换设备后会被视为“新用户”（因为设备标识变化）。</li></ul><p>可演进方向：如果希望“多端同一用户”，可以直接升级为 Supabase Auth 的标准登录体系。ADB Supabase 提供本土化可用的认证能力（如微信/支付宝 OAuth、邮箱等），可以在不改变整体架构的前提下强化登录与账号合并能力。</p><h3>5.2 Edge Functions：把服务端业务逻辑交给云端（AI 友好、低运维）</h3><p>本项目中两类关键能力并不适合放在客户端完成：“定时检测未签到用户”和“发送邮件通知（或其它通知渠道）”</p><p>因此我们使用 ADB Supabase Edge Functions 承载服务端逻辑。Edge Functions 是运行在 Supabase 云端的 Serverless 函数：</p><ul><li>运行时：Deno</li><li>语言：原生 TypeScript</li><li>能力：可作为 HTTP 接口暴露，也可被 Cron Job 定时触发</li></ul><p>为什么Edge Functions对AI编程友好？</p><table><thead><tr><th>维度</th><th>传统自建后端</th><th>ADB Supabase Edge Functions</th><th>对 AI 的直接收益</th></tr></thead><tbody><tr><td>开发语言/环境</td><td>Node/框架/依赖与环境配置</td><td>直接写 TypeScript（Deno）</td><td>AI 更擅长 TS，减少环境坑</td></tr><tr><td>部署</td><td>服务器、Docker、网关、证书</td><td>一条命令发布到云端</td><td>AI 不用“指导你运维”</td></tr><tr><td>API 暴露</td><td>手写路由/网关配置</td><td>自动生成 HTTP 端点</td><td>AI 只需按 URL 调用</td></tr><tr><td>定时任务</td><td>额外 Cron 服务/任务系统</td><td>内置 Cron Jobs 触发</td><td>AI 只配置 Cron 表达式</td></tr><tr><td>权限与密钥</td><td>自己设计鉴权与密钥管理</td><td>使用 <code>service_role key</code>（服务端专用）</td><td>机密留在云端，客户端更安全</td></tr></tbody></table><p><img width="723" height="138" referrerpolicy="no-referrer" src="/img/bVdnExd" alt="" title="" loading="lazy"/></p><p>这里我们实现了两个Edge Function：check-missed-check-ins和send-notification-email。</p><p><strong>Edge Function 1: check-missed-check-ins</strong></p><p><img width="723" height="305" referrerpolicy="no-referrer" src="/img/bVdnExe" alt="" title="" loading="lazy"/></p><p>目标：每天扫描所有用户，找出“连续 2 天未签到”的用户，并触发通知流程。</p><p>这一类“全量扫描 + 规则判断 + 批量触发”的逻辑放在客户端几乎不可行；放在 Supabase Edge Functions 则天然适配。</p><p><strong>业务流程</strong><br/><img width="723" height="1147" referrerpolicy="no-referrer" src="/img/bVdnExf" alt="" title="" loading="lazy"/></p><p>Edge Function 2: send-notification-email<br/><img width="723" height="310" referrerpolicy="no-referrer" src="/img/bVdnExg" alt="" title="" loading="lazy"/></p><p>目标：接收用户信息与紧急联系人邮箱，发送提醒邮件。</p><p>邮件内容示例：</p><pre><code>主题：一条重要通知

我是{username},我已经连续很多天没有活动了，快来检测一下我的身体状态。
</code></pre><p>可扩展性：目前实现的是邮件通知；但基于 ADB Supabase Edge Functions，同一套模式可以平滑扩展到 微信、钉钉、短信等渠道。并且因为第三方渠道的密钥配置保存在云端环境变量/密钥体系中，不会泄露到客户端，安全性更高。</p><p><img width="723" height="381" referrerpolicy="no-referrer" src="/img/bVdnExh" alt="" title="" loading="lazy"/></p><h3>5.3 Cron Jobs - 定时任务调度</h3><p>实现的功能模块：每天自动检测</p><p>在Supabase Dashboard中创建Cron Job：</p><table><thead><tr><th>配置项</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>任务名称</td><td>check-missed-check-ins</td><td>描述性名称</td></tr><tr><td>Cron表达式</td><td><code>0 1 * * *</code></td><td>UTC时间凌晨1点 = 北京9点</td></tr><tr><td>触发方式</td><td>HTTP POST</td><td>调用Edge Function</td></tr><tr><td>URL</td><td><code>/functions/v1/check-missed-check-ins</code></td><td>函数端点</td></tr><tr><td>认证</td><td>Service Role Key</td><td>绕过RLS</td></tr></tbody></table><h2>六、总结与思考</h2><p>虽然「死了么」APP的场景并不是特别复杂，但是也向我们展示了完整的AI编码技术选型的最佳实践。AI编码前端的能力远远强于后端，一方面，模型需要提高对后端的编码能力，另一方面，通过减少后端编码，依托于ADB Supase等BaaS服务，让前端直接变成全栈，也不失为一种围魏救赵的解法。尤其是在AI时代，各种想法加速落地MVP，尽可能让研发聚焦业务本身逻辑，反而显得更加重要。</p><h3>6.1 AI编程时代的技术选型原则</h3><p>通过这个项目，我们沉淀了几条在 AI 辅助开发 / Vibe Coding 场景下更“稳”的技术选型原则——核心目标是：让 AI 更容易写对、写稳、并且更好维护。</p><table><thead><tr><th>原则</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>原则1：优先选择声明式技术栈</td><td>AI 更擅长处理声明式代码</td><td>-   ✅ SwiftUI的声明式UI \&gt; UIKit的命令式UI ✅ SQL的声明式查询 &gt; ORM的命令式操作✅ RLS的声明式策略 &gt; 中间件的命令式鉴权</td></tr><tr><td>原则2：选择文档友好的技术</td><td>AI 依赖高质量文档生成代码</td><td>-   ✅ Supabase官方文档完善✅ SwiftUI有大量示例代码✅ TypeScript类型系统帮助AI理解</td></tr><tr><td>原则3：选择自动化程度高的服务</td><td>减少 AI 需要处理的配置细节</td><td>-   ✅ Supabase自动生成API✅ 匿名认证自动管理Session✅ RLS自动应用权限规则</td></tr><tr><td>原则4：选择类型安全的语言</td><td>类型系统减少 AI 生成错误</td><td>-   ✅ Swift和TypeScript都是类型安全语言✅ 编译时发现错误，而非运行时✅ IDE自动提示，AI生成更准确</td></tr></tbody></table><h3>6.2 Supabase 的核心价值</h3><p>Supabase 在 AI 编程时代展现出独特价值，核心体现在两点：让后端更“轻”，让交付更“快”。</p><p><strong>1.  降低后端复杂度：把长链路工程收敛为少量声明式要素</strong></p><p>在传统自建后端中，AI 需要处理的环节非常多，而且每一层都伴随着大量样板代码与隐性约定：</p><pre><code>框架选择 → 路由设计 → 控制器 → 服务层 → 
数据访问层 → ORM配置 → 数据库连接 → 
认证中间件 → 权限中间件 → 错误处理 → 
日志系统 → 部署配置 → 负载均衡 → ...
</code></pre><p>链路越长，越容易在迭代中产生回归与耦合问题，也会显著消耗上下文与调试成本。而 Supabase 将后端能力高度收敛，开发者与 AI 往往只需要聚焦在三件事上：</p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td>SQL Schema</td><td>定义数据库的数据模型，包括表结构、索引、约束等</td></tr><tr><td>RLS 策略</td><td>在数据库层实施行级安全策略，控制用户对数据的访问权限与隔离规则</td></tr><tr><td>Edge Functions</td><td>按需使用的后端服务代码，处理定时任务、通知、复杂业务逻辑</td></tr></tbody></table><p><strong>2.  摆脱后端运维：用托管能力换取更快的启动与迭代</strong></p><p>相比自建后端，BaaS 的优势在于“快速启动、持续省心”。ADB Supabase 提供托管数据库、认证、权限控制与对外 API 能力，项目从 0 到可用的启动成本更低；上线后也无需投入精力在服务器部署、扩缩容、证书、网关与日常运维上。</p><p>对移动 App 尤其关键：开发者可以把注意力集中在客户端体验与核心业务闭环，通过 HTTPS 直连云端能力完成数据读写与权限控制，而不是被后端基础设施牵制开发节奏。</p><p>欢迎钉钉搜索群号：“101930027031“，加入钉群获取完整源码资料。</p><p>了解更多关于<strong>ADB Supabase</strong>：<a href="https://link.segmentfault.com/?enc=9kq1ucrSKdnFk31IktuOQg%3D%3D.G%2Bkal30CMJZNGng2GhH5Qk6VNJUETd4Uoxq3K03ZClronao0Kpo3mso48N5%2B%2F%2Bd0wcMyZQU%2BwaK2U1pcDBiIJaIDa8Tllv%2F8OUK6XeJYT2vmfE2iHCAQYBlvCOABjpzd" rel="nofollow" target="_blank">https://help.aliyun.com/zh/analyticdb/analyticdb-for-postgres...</a></p>]]></description></item><item>    <title><![CDATA[【节点】[Constant节点]原理解析与实际应用 SmalBox ]]></title>    <link>https://segmentfault.com/a/1190000047544038</link>    <guid>https://segmentfault.com/a/1190000047544038</guid>    <pubDate>2026-01-15 11:05:33</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><a href="https://link.segmentfault.com/?enc=UGunozA1o6UD%2BAV8J%2BTGxQ%3D%3D.e6fouzcS7JoK1jqrKzY287VVk8QqA2%2FS1%2B6taOFAFCWQweYIpdcxCMV2lRyYLgo4ycVOHnNOcYR8JMTbW8qSpf2C5iFD1snAe8EE93s%2BaBRnhjUm1fqVhsS4yMMKC6TFWK6pdR5rJejPEMxddzGMsMq3BQ6nhjV0ej7SHwhw1IWh0HwAuAt93%2BgvtER2u7pk9lnHbQR4%2FrQE9idVHlK5rLb9iEZkPSuoRKd119WmeTQ%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong></blockquote><p>在Unity的Shader Graph可视化着色器编辑器中，Constant节点是一个基础但至关重要的数学工具节点。它允许开发者在着色器程序中预定义和使用常见的数学常量值，无需手动输入这些数值，从而提高开发效率和代码的准确性。</p><h2>Constant节点概述</h2><p>Constant节点属于Shader Graph中的数学工具类节点，专门用于提供精确的数学常量值。在图形编程和着色器开发中，精确的数学常量对于实现各种视觉效果至关重要，从简单的颜色计算到复杂的物理模拟都离不开这些基础数值。</p><h3>节点特性</h3><p>Constant节点具有以下几个显著特点：</p><ul><li>提供预定义的数学常量，确保数值精度</li><li>简化着色器代码，避免手动输入可能导致的错误</li><li>支持多种常用数学常量，覆盖大多数图形编程需求</li><li>输出为浮点数值，兼容各种着色器计算</li></ul><h3>应用场景</h3><p>Constant节点在Shader Graph中的应用非常广泛：</p><ul><li>圆形和弧形计算中的π值使用</li><li>周期性动画和波动效果中的τ值应用</li><li>美学比例计算中的黄金分割φ值</li><li>自然增长和衰减模拟中的自然常数e</li><li>距离计算和标准化处理中的√2值</li></ul><h2>端口详解</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544040" alt="" title=""/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544040" alt="" title="" loading="lazy"/></p><p>Constant节点仅包含一个输出端口，设计简洁但功能专一。</p><h3>输出端口</h3><p><strong>名称</strong>：Out</p><p><strong>方向</strong>：输出</p><p><strong>类型</strong>：Float</p><p><strong>绑定</strong>：无</p><p><strong>描述</strong>：输出当前选择的数学常量值</p><p>输出端口的特点：</p><ul><li>始终输出浮点数类型的常量值</li><li>数值精度满足图形计算需求</li><li>可以直接连接到其他节点的输入端口</li><li>支持实时预览当前选择的常量值</li></ul><h2>控件配置</h2><p>Constant节点提供了一个下拉选单控件，用于选择所需的数学常量类型。</p><h3>Mode下拉选单</h3><p>Mode控件决定了节点输出的具体数学常量值，包含以下五个选项：</p><p><strong>PI</strong> - 圆周率π</p><ul><li>数值：约等于3.1415926</li><li>应用：圆形计算、角度转换、周期性函数</li></ul><p><strong>TAU</strong> - 圆周率的两倍τ</p><ul><li>数值：约等于6.28318530</li><li>应用：完整的圆周弧度、简化角度计算</li></ul><p><strong>PHI</strong> - 黄金比例φ</p><ul><li>数值：约等于1.618034</li><li>应用：美学比例、自然生长模式、艺术构图</li></ul><p><strong>E</strong> - 自然常数e</p><ul><li>数值：约等于2.718282</li><li>应用：指数增长、衰减过程、概率计算</li></ul><p><strong>SQRT2</strong> - 2的平方根</p><ul><li>数值：约等于1.414214</li><li>应用：对角线距离、标准化计算、几何变换</li></ul><h2>数学常量深度解析</h2><h3>PI（圆周率）</h3><p>圆周率π是数学中最著名的常数之一，代表圆的周长与直径的比值。</p><p><strong>数学定义</strong>：</p><p>π = 周长 / 直径 ≈ 3.141592653589793</p><p><strong>在Shader Graph中的应用</strong>：</p><ul><li>角度与弧度转换</li></ul><pre><code>// 角度转弧度
radians = degrees * PI / 180.0

// 弧度转角度
degrees = radians * 180.0 / PI</code></pre><ul><li>圆形和弧形计算</li></ul><pre><code>// 圆形坐标计算
float2 circlePosition = float2(cos(angle * PI * 2.0), sin(angle * PI * 2.0))

// 圆弧长度
float arcLength = radius * centralAngle * PI / 180.0</code></pre><ul><li>周期性函数</li></ul><pre><code>// 正弦波动
float wave = sin(time * PI * 2.0)

// 圆形渐变
float circularGradient = length(uv - 0.5) * PI</code></pre><h3>TAU（2π常数）</h3><p>TAU是圆周率的两倍，代表完整的圆周弧度，在某些情况下可以简化数学表达式。</p><p><strong>数学定义</strong>：</p><p>τ = 2π ≈ 6.283185307179586</p><p><strong>在Shader Graph中的应用</strong>：</p><ul><li>完整的周期计算</li></ul><pre><code>// 使用TAU的完整周期正弦波
float sineWave = sin(time * TAU)

// 圆形遍历
for(float i = 0.0; i &lt; TAU; i += 0.1) {
    // 圆形采样点
}</code></pre><ul><li>简化角度计算</li></ul><pre><code>// 传统方式
float radians = degrees * PI / 180.0

// 使用TAU方式（概念上更清晰）
float radians = degrees * TAU / 360.0</code></pre><h3>PHI（黄金比例）</h3><p>黄金比例φ是一个无理数，在艺术、建筑和自然界中广泛存在，被认为具有美学上的完美比例。</p><p><strong>数学定义</strong>：</p><p>φ = (1 + √5) / 2 ≈ 1.618033988749895</p><p><strong>在Shader Graph中的应用</strong>：</p><ul><li>美学比例布局</li></ul><pre><code>// 黄金比例分割
float goldenSection = totalLength / PHI

// 黄金矩形比例
float goldenRectangleWidth = height * PHI</code></pre><ul><li>自然生长模式模拟</li></ul><pre><code>// 斐波那契螺旋
float spiralRadius = baseRadius * pow(PHI, angle / (PI * 2.0))</code></pre><ul><li>颜色和亮度分布</li></ul><pre><code>// 基于黄金比例的亮度衰减
float brightness = baseBrightness / pow(PHI, distance)</code></pre><h3>E（自然常数）</h3><p>自然常数e是自然对数函数的底数，在指数增长和衰减过程中具有重要地位。</p><p><strong>数学定义</strong>：</p><p>e = lim(1 + 1/n)ⁿ ≈ 2.718281828459045</p><p><strong>在Shader Graph中的应用</strong>：</p><ul><li>指数衰减效果</li></ul><pre><code>// 自然衰减
float decay = pow(E, -decayRate * time)

// 平滑过渡
float smoothTransition = 1.0 - pow(E, -transitionSpeed * factor)</code></pre><ul><li>概率分布模拟</li></ul><pre><code>// 正态分布近似
float gaussian = pow(E, -0.5 * pow((x - mean) / deviation, 2.0))</code></pre><ul><li>生长过程模拟</li></ul><pre><code>// 指数增长
float growth = initialValue * pow(E, growthRate * time)</code></pre><h3>SQRT2（2的平方根）</h3><p>2的平方根是对角线与边长的比值，在距离计算和标准化中非常有用。</p><p><strong>数学定义</strong>：</p><p>√2 ≈ 1.4142135623730951</p><p><strong>在Shader Graph中的应用</strong>：</p><ul><li>对角线距离计算</li></ul><pre><code>// 最大可能距离（正方形中对角线）
float maxDistance = diagonalLength / SQRT2

// 标准化处理
float normalizedValue = rawValue / SQRT2</code></pre><ul><li>纹理采样偏移</li></ul><pre><code>// 对角线方向采样
float2 diagonalOffset = float2(1.0, 1.0) * offsetAmount / SQRT2</code></pre><h2>实际应用示例</h2><h3>圆形进度条实现</h3><p>使用PI常量创建平滑的圆形进度指示器：</p><pre><code>HLSL

// 在Fragment Shader中
void surf(Input IN, inout SurfaceOutputStandard o)
{
    // 计算UV坐标到圆心的距离和角度
    float2 centeredUV = IN.uv_MainTex - 0.5;
    float angle = atan2(centeredUV.y, centeredUV.x);
    float radius = length(centeredUV) * 2.0;

    // 使用PI进行角度标准化
    float normalizedAngle = (angle + PI) / (2.0 * PI);

    // 进度计算（0到1范围）
    float progress = _Progress;

    // 绘制圆形进度条
    if (radius &lt;= 1.0 &amp;&amp; radius &gt;= 0.8 &amp;&amp; normalizedAngle &lt;= progress) {
        o.Albedo = _ProgressColor;
    } else {
        o.Albedo = _BaseColor;
    }
}</code></pre><h3>波动动画效果</h3><p>利用TAU创建流畅的波动动画：</p><pre><code>HLSL

// 波动效果实现
float waveEffect(float2 position, float time)
{
    // 使用TAU简化完整周期计算
    float wave1 = sin(position.x * _Frequency + time * TAU) * _Amplitude;
    float wave2 = sin(position.y * _Frequency + time * TAU + PI * 0.5) * _Amplitude;

    return (wave1 + wave2) * 0.5;
}</code></pre><h3>黄金比例布局系统</h3><p>基于PHI创建视觉上和谐的UI元素布局：</p><pre><code>HLSL

// 黄金比例布局计算
float2 goldenRatioLayout(float2 screenSize, int elementIndex)
{
    float totalHeight = screenSize.y;
    float sectionHeight = totalHeight / PHI;

    float yPosition = 0.0;
    for(int i = 0; i &lt; elementIndex; i++) {
        yPosition += sectionHeight;
        sectionHeight /= PHI; // 每个部分按黄金比例缩小
    }

    return float2(screenSize.x * 0.5, yPosition);
}</code></pre><h2>性能优化建议</h2><h3>常量值的优化使用</h3><ul><li><strong>预计算组合常量</strong>：将常用的常量组合预先计算并存储</li></ul><pre><code>// 优化前
float result = inputValue * PI * 2.0;

// 优化后
float result = inputValue * TAU; // 使用预定义的TAU常量</code></pre><ul><li><strong>避免重复计算</strong>：在Sub Graph中封装常用常量操作</li></ul><pre><code>// 创建角度转换Sub Graph
// 输入：角度值，输出：弧度值
// 内部使用：PI / 180.0 的预计算常量</code></pre><h3>节点连接优化</h3><ul><li><strong>减少重复Constant节点</strong>：相同常量值应共享节点实例</li><li><strong>合理组织节点结构</strong>：将常量计算集中管理，提高可读性和性能</li><li><strong>使用Sub Graph封装</strong>：将复杂的常量相关计算封装为可重用组件</li></ul><h2>高级技巧与最佳实践</h2><h3>自定义常量扩展</h3><p>虽然Constant节点提供的是固定常量，但可以通过数学运算创建派生常量：</p><pre><code>// 创建半PI常量
float halfPI = PI * 0.5;

// 创建四分之一PI常量
float quarterPI = PI * 0.25;

// 创建黄金比例的倒数
float inversePHI = 1.0 / PHI;</code></pre><h3>精度控制技巧</h3><p>在不同精度需求场景下的使用方法：</p><ul><li><strong>高精度计算</strong>：直接使用Constant节点提供的值</li><li><strong>性能敏感场景</strong>：考虑使用近似值或查找表</li><li><strong>移动端优化</strong>：评估是否真的需要全精度常量</li></ul><h3>调试与验证</h3><p>确保常量使用正确的调试方法：</p><ul><li>使用Preview节点实时查看常量输出</li><li>通过颜色编码可视化常量值的分布</li><li>建立测试用例验证常量计算的准确性</li></ul><h2>常见问题解答</h2><h3>精度相关问题</h3><p><strong>问：Constant节点提供的常量值精度足够吗？</strong></p><p>答：对于绝大多数图形应用，Constant节点提供的精度完全足够。只有在极端科学计算或金融应用场景下才需要考虑更高精度。</p><p><strong>问：如何验证常量值的准确性？</strong></p><p>答：可以通过创建简单的测试Shader来验证，比如使用PI计算圆的面积并与理论值比较。</p><h3>性能相关问题</h3><p><strong>问：在Shader中使用Constant节点会影响性能吗？</strong></p><p>答：Constant节点在编译时会被替换为具体的数值常量，运行时没有性能开销。</p><p><strong>问：应该为每个常量创建单独的节点吗？</strong></p><p>答：不需要，相同值的常量应该共享节点实例，不同值的常量才需要分别创建。</p><h3>应用相关问题</h3><p><strong>问：什么时候应该使用TAU而不是PI？</strong></p><p>答：当计算涉及完整周期（360度或2π弧度）时，使用TAU可以使表达式更简洁直观。</p><p><strong>问：黄金比例在游戏开发中的实际价值是什么？</strong></p><p>答：黄金比例可以帮助创建视觉上更和谐的比例关系，在UI设计、关卡布局、角色比例等方面都有应用价值。</p><hr/><blockquote><a href="https://link.segmentfault.com/?enc=Ktiw4XJkQPA3S23ZG7xaXQ%3D%3D.Sf8kYDJmVOLbRyW28O07e2QxpEzBBAC0sCoHgrixIJko9Em6xV9W7Q6EORfdfRVms5%2FPU0olzAaqO0WUxwPhqkLAGl134equYuZjxNffPd2mYZfdfiP9lqOPyDwISPSGzkEtkbSG%2BA8DRzxjCmhx8y5yi%2BLPtnW3ZB%2F1hbpTG%2Flf61FsTLZhnei%2B7CMTY8eNpH7rEdkNm3ixdeqhhiO5MtW%2BjZKK3iUaahYdWh4ngF4%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong><br/>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</blockquote>]]></description></item><item>    <title><![CDATA[2026客户管理系统选型指南：5大CRM 品牌实测 傲视众生的脸盆 ]]></title>    <link>https://segmentfault.com/a/1190000047544061</link>    <guid>https://segmentfault.com/a/1190000047544061</guid>    <pubDate>2026-01-15 11:04:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在“以客户为中心”的商业环境中，<strong>全流程营销管理平台</strong>的核心价值在于实现“线索获取→客户跟进→合同执行→售后留存”的生命周期闭环，解决企业“获客难、转化低、协同散、留存弱”的痛点。本文选取<strong>超兔一体云、金蝶云</strong> <strong>CRM</strong> <strong>、HubSpot CRM、OKKICRM（原小满CRM）、Zendesk Sell</strong>五大主流平台，从<strong>全流程核心环节</strong>与<strong>系统支撑能力</strong>展开深度对比，为企业选型提供专业参考。</p><h2>一、对比框架与品牌定位</h2><p>首先明确各平台的<strong>核心定位</strong>（决定了能力侧重）：</p><table><thead><tr><th>品牌</th><th>核心定位</th><th>关键词</th></tr></thead><tbody><tr><td>超兔一体云</td><td>全业务一体化的全流程闭环平台</td><td>一体化、全场景、智能闭环</td></tr><tr><td>金蝶云CRM</td><td>业财深度融合的企业级解决方案</td><td>企业级、业财联动、流程标准化</td></tr><tr><td>HubSpot CRM</td><td>营销自动化驱动的增长型平台</td><td>营销自动化、增长、全球化</td></tr><tr><td>OKKICRM（原小满CRM）</td><td>外贸B2B专属的全流程管理工具</td><td>外贸、多渠道触达、AI潜客</td></tr><tr><td>Zendesk Sell</td><td>销售效率导向的轻量化协作工具</td><td>轻量化、销售效率、跨地域</td></tr></tbody></table><h2>二、全流程核心能力对比</h2><h3>（一）线索获取：多渠道归集与智能转化</h3><p>线索是全流程的起点，核心能力在于<strong>渠道覆盖广度</strong>与<strong>线索转化效率</strong>。</p><h4>1. 核心能力对比表</h4><table><thead><tr><th>维度</th><th>超兔一体云</th><th>金蝶云CRM</th><th>HubSpot CRM</th><th>OKKICRM（原小满）</th><th>Zendesk Sell</th></tr></thead><tbody><tr><td><strong>渠道覆盖</strong></td><td>百度/抖音/微信/地推/工商搜客/官网</td><td>销售地推+市场（广告/社交/活动/H5）</td><td>SEO/社交媒体/网页表单/邮件营销</td><td>全球展会/社媒/网站/AI潜客推荐</td><td>联系人整合/邮件追踪/销售线索导入</td></tr><tr><td><strong>智能分析</strong></td><td>线索查重/归属地识别/活动成本均摊</td><td>客户画像精准触达/撞单分析</td><td>AI线索评分/动态行为追踪（邮件打开）</td><td>AI企业背调/高价值客户识别</td><td>销售漏斗进度分析/联系人行为追踪</td></tr><tr><td><strong>核心优势</strong></td><td>工商搜客（To B精准获客）+ 微信生态</td><td>营销自动化与销售协同</td><td>营销内容与线索的精准匹配</td><td>外贸场景专属（展会/多语言）</td><td>轻量化线索整合与跟进</td></tr></tbody></table><h4>2. 流程可视化：超兔线索获取闭环（Mermaid流程图）</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544063" alt="" title=""/></p><pre><code>flowchart LR
    A[多渠道获客] --&gt; B[智能处理] --&gt; C[分配提醒] --&gt; D[效果分析]
    A --&gt; A1[百度/抖音广告]
    A --&gt; A2[微信海报/小程序]
    A --&gt; A3[地推二维码]
    A --&gt; A4[工商特征搜客]
    B --&gt; B1[手机号查重/归属地]
    B --&gt; B2[线索一键转客户/商机]
    C --&gt; C1[自动分配销售]
    C --&gt; C2[消息提醒跟进]
    D --&gt; D1[活动成本均摊]
    D --&gt; D2[线索-签约转化率计算]</code></pre><h3>（二）客户跟进：精准触达与流程闭环</h3><p>客户跟进的核心是<strong>个性化触达</strong>与<strong>流程可控</strong>，避免“跟进断层”或“客户流失”。</p><h4>1. 核心能力对比表</h4><table><thead><tr><th>维度</th><th>超兔一体云</th><th>金蝶云CRM</th><th>HubSpot CRM</th><th>OKKICRM（原小满）</th><th>Zendesk Sell</th></tr></thead><tbody><tr><td><strong>客户画像</strong></td><td>自定义画像/360°跟单视图</td><td>360°客户视图（整合业财数据）</td><td>动态客户档案（整合互动行为）</td><td>客户标签分层/多维度属性筛选</td><td>联系人基本信息+互动历史</td></tr><tr><td><strong>跟单模型</strong></td><td>三一客（小单快单）/商机/多方项目</td><td>销售漏斗（自定义阶段）/任务跟踪</td><td>CRM+销售中心（自动化跟进）</td><td>多渠道自动化触达（邮件/WhatsApp）</td><td>联系人管理/销售任务分配</td></tr><tr><td><strong>协同效率</strong></td><td>自动生成日报/点点速记/团队共享</td><td>移动化跟进/跨部门业财联动</td><td>自动化工作流（邮件打开提醒销售）</td><td>AI智能跟进/团队沟通质检</td><td>云端实时同步/跨地域协作</td></tr></tbody></table><h4>2. 模型差异化：超兔跟单中心脑图（Mermaid脑图）</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544064" alt="" title="" loading="lazy"/></p><pre><code>mindmap
  root((超兔跟单中心))
    小单快单模型（三一客）
      三定（定人/定时/定动作）
      关键节点推进
    商机跟单模型
      阶段管理/预期日期
      输赢分析
    多方项目模型
      多业务主体协同
      复杂项目拆解
    通用能力
      360°跟单视图
      电话录音AI分析
      自动生成日报</code></pre><h3>（三）合同执行：灵活适配与风险管控</h3><p>合同执行的核心是<strong>业务场景适配</strong>与<strong>财务风险管控</strong>，需覆盖“服务/实物/特殊业务”的全类型订单。</p><h4>1. 核心能力对比表</h4><table><thead><tr><th>维度</th><th>超兔一体云</th><th>金蝶云CRM</th><th>HubSpot CRM</th><th>OKKICRM（原小满）</th><th>Zendesk Sell</th></tr></thead><tbody><tr><td><strong>业务适配</strong></td><td>服务/实物/套餐/租赁/维修/总分订单</td><td>合同/订单/发货/应收全流程</td><td>快速报价/合同生成/订单同步</td><td>外贸合同/报价单/销售漏斗可视化</td><td>销售订单/报价单/联系人关联</td></tr><tr><td><strong>财务管控</strong></td><td>应收-开票-回款三角联动/超发预警</td><td>业财一体化（订单→ERP→财务）</td><td>订单与营销数据联动</td><td>外贸收付款追踪/汇率换算</td><td>简单回款记录/应收提醒</td></tr><tr><td><strong>核心优势</strong></td><td>多业务模型（如租售一体/爆炸图下单）</td><td>企业级财务风险控制（信用度/账期）</td><td>订单与营销的增长闭环</td><td>外贸场景专属（汇率/多币种）</td><td>轻量化订单管理与跟进</td></tr></tbody></table><h4>2. 流程闭环：超兔订单执行流程（Mermaid流程图）</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544065" alt="" title="" loading="lazy"/></p><pre><code>flowchart LR
    A[订单创建] --&gt; B[订单审核] --&gt; C[执行环节] --&gt; D[财务闭环]
    A --&gt; A1[服务单]
    A --&gt; A2[实物单（批发/定制）]
    A --&gt; A3[特殊单（租赁/维修）]
    B --&gt; B1[参数校验（库存/信用）]
    B --&gt; B2[工作流审批]
    C --&gt; C1[锁库/采购计划]
    C --&gt; C2[供应商直发/外勤配送]
    D --&gt; D1[自动触发应收]
    D --&gt; D2[回款与开票联动]</code></pre><h3>（四）售后管理：客户留存与价值挖掘</h3><p>售后的核心是<strong>服务响应速度</strong>与<strong>复购挖掘能力</strong>，实现“客户满意→复购→转介绍”的增长闭环。</p><h4>1. 核心能力对比表</h4><table><thead><tr><th>维度</th><th>超兔一体云</th><th>金蝶云CRM</th><th>HubSpot CRM</th><th>OKKICRM（原小满）</th><th>Zendesk Sell</th></tr></thead><tbody><tr><td><strong>服务协同</strong></td><td>RFM分析/维修工单/外勤工单</td><td>工单一键报修/自动派单/服务历史追溯</td><td>24/7聊天机器人/工单系统/知识库</td><td>AI数据助理/售后问题反馈</td><td>简单售后记录/联系人服务关联</td></tr><tr><td><strong>复购挖掘</strong></td><td>复购流失预警（消费间隔分析）</td><td>服务到期提醒/客户满意度调查</td><td>售后数据→营销内容优化（AI推荐）</td><td>外贸客户跟进周期提醒</td><td>联系人复购行为追踪</td></tr><tr><td><strong>核心优势</strong></td><td>复购预警与RFM精准回访</td><td>业财联动的服务续费率提升</td><td>售后与营销的闭环优化</td><td>外贸客户生命周期管理</td><td>轻量化售后与销售协同</td></tr></tbody></table><h4>2. 能力可视化：各品牌售后能力雷达图（分值1-5）</h4><table><thead><tr><th>指标</th><th>超兔</th><th>金蝶</th><th>HubSpot</th><th>OKKI</th><th>Zendesk</th></tr></thead><tbody><tr><td>服务响应速度</td><td>5</td><td>4</td><td>4</td><td>5</td><td>3</td></tr><tr><td>售后历史追溯</td><td>5</td><td>5</td><td>4</td><td>4</td><td>3</td></tr><tr><td>复购挖掘能力</td><td>5</td><td>4</td><td>5</td><td>4</td><td>3</td></tr><tr><td>跨部门协同</td><td>5</td><td>5</td><td>4</td><td>4</td><td>4</td></tr></tbody></table><h2>三、系统支撑能力对比</h2><p>系统支撑决定了平台的<strong>扩展性</strong>与<strong>长期适配性</strong>，核心看<strong>一体化程度</strong>与<strong>集成能力</strong>。</p><table><thead><tr><th>维度</th><th>超兔一体云</th><th>金蝶云CRM</th><th>HubSpot CRM</th><th>OKKICRM（原小满）</th><th>Zendesk Sell</th></tr></thead><tbody><tr><td><strong>一体化程度</strong></td><td>全业务一体化（CRM+进销存+供应链+财务）</td><td>与金蝶ERP/财务深度集成</td><td>营销+销售+服务一体化</td><td>外贸全流程一体化（获客→订单→售后）</td><td>轻量化销售工具（无深度一体化）</td></tr><tr><td><strong>集成能力</strong></td><td>对接金蝶/用友ERP、电商RPA、国税开票</td><td>金蝶生态（ERP/HR/财务）+ 第三方集成</td><td>营销工具（Mailchimp）+ 销售工具</td><td>外贸平台（阿里巴巴）+ 社媒</td><td>对接Zendesk服务平台+ 第三方工具</td></tr><tr><td><strong>AI赋能</strong></td><td>AI智能体（嵌入客户视图）+ Coze工作流</td><td>基础AI（画像/预警）</td><td>AI内容生成+线索评分+流失预警</td><td>AI潜客推荐+企业背调</td><td>基础AI（销售预测/行为分析）</td></tr><tr><td><strong>稳定性</strong></td><td>业内稳定（企业因稳定性换用超兔）</td><td>企业级稳定</td><td>全球化稳定</td><td>外贸场景稳定</td><td>轻量化稳定</td></tr></tbody></table><h2>四、选型建议</h2><p>根据企业<strong>规模、行业、核心需求</strong>，给出针对性选型建议：</p><ol><li><strong>超兔一体云</strong>：适合需要<strong>全流程闭环+一体化</strong>的企业（如中小制造/服务型企业），尤其是To B场景需要工商搜客或微信生态获客的企业。</li><li><strong>金蝶云CRM</strong>：适合<strong>中大型企业</strong>（如集团化公司），需要业财深度融合、流程标准化的企业。</li><li><strong>HubSpot CRM</strong>：适合<strong>营销驱动的增长型企业</strong>（如 SaaS/电商），需要通过营销自动化提升线索转化的企业。</li><li><strong>OKKICRM</strong>：适合<strong>外贸B2B企业</strong>（如跨境电商/外贸工厂），需要覆盖展会/社媒/多语言场景的企业。</li><li><strong>Zendesk Sell</strong>：适合<strong>中小企业</strong>（如初创团队/区域销售团队），需要轻量化销售协作、提升跟进效率的企业。</li></ol><h2>五、总结</h2><p>全流程营销管理平台的本质是“以客户为中心”的闭环能力——从线索到售后，每个环节都需实现“数据打通、流程可控、价值挖掘”。超兔一体云的<strong>全业务一体化</strong>、金蝶的<strong>业财融合</strong>、HubSpot的<strong>营销自动化</strong>、OKKI的<strong>外贸专属</strong>、Zendesk的<strong>轻量化效率</strong>，分别对应不同企业的核心需求。企业选型时需抓住“<strong>核心场景匹配</strong>”这一关键，避免“大而全”但“不适用”的陷阱。</p><p>（注：文中功能相关描述均基于公开披露信息，具体功能服务以厂商实际落地版本为准。）</p>]]></description></item><item>    <title><![CDATA[从极速复制“死了么”APP，看AI编程时代的技术选型 数据库知识分享者 ]]></title>    <link>https://segmentfault.com/a/1190000047544077</link>    <guid>https://segmentfault.com/a/1190000047544077</guid>    <pubDate>2026-01-15 11:04:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>前言</h2><p>2026年初，一款名叫"死了么"的App在AppStore付费榜狂销。</p><p>这不仅是一个关于产品创意的故事，还是一个关于技术如何重塑创业门槛的故事。</p><p>曾经，一个看似简单的App需要庞大的技术团队：后端框架、数据库部署、系统认证、定时任务、邮件推送、基础设施运维……整个过程耗时冗长、成本高昂。而如今，一切都发生了变化。</p><p>使用AI编程工具能快速生成前端代码，用"无服务器应用后端" Supabase 处理所有后端工作，开发者不需要自己搭建服务器，也无需担心系统维护。从前端到后端、从数据到模型，全链路轻量敏捷。</p><p>本文通过30分钟复刻"死了么"APP，深度分析在AI编程时代如何使用正确的技术栈实现应用的极速开发。</p><h2>一、一个8元APP为何在AppStore狂销？</h2><p>2026 年第一款全网爆火的 App「死了么」，是一款标价8元的付费产品，已经连续几天占据苹果 AppStore 付费榜第一。 </p><p><img width="723" height="346" referrerpolicy="no-referrer" src="/img/bVdnEwM" alt="" title=""/></p><p>这款 App 的功能极其简单，输入你的名字和紧急联系人邮箱，然后每天签到。如果没签到，则会自动发送邮件警报给紧急联系人。 这么简单的功能却精准戳中了独居者面临的生活难题也切切实实反映了只要戳中用户痛点，再简单的APP也有它独特的价值。同时体现出，在AI时代，只要有想法，就可以迅速落地实现。</p><p><img width="723" height="489" referrerpolicy="no-referrer" src="/img/bVdnEwN" alt="" title="" loading="lazy"/></p><p>虽然这个App的功能看似简单，开发者也声称开发成本仅几千元。但麻雀虽小，五脏俱全，前端仅有的签到功能背后，却包含了用户管理、邮件推送、定时任务能力。当前流行的AI编码可以迅速且完整地实现前端能力，但涉及到包含后端能力时就会有一定挑战，但是这一短板并非不能克服，通过Rules、Skills和正确的技术选型，则可以迅速完成全栈落地。</p><h2>二、从想法到上线：用最佳技术选型实现AI全栈编程</h2><p>下面我们就以复刻整个「死了么」为例，使用AI编码时代的最佳技术选型迅速实现落地。<br/><img width="723" height="473" referrerpolicy="no-referrer" src="/img/bVdnEwO" alt="" title="" loading="lazy"/></p><p>使用Qoder 30分钟完全复刻版（包含后端）</p><p>看下面的视频，左边我们使用模拟器模拟了真机效果，右边是Supabase后端dashboard，可以看到刚开始后端并没有数据，当我们通过左边APP完成签到后，数据写入到了后端的users和check\_ins表里。<br/><img width="723" height="399" referrerpolicy="no-referrer" src="/img/bVdnEwP" alt="" title="" loading="lazy"/></p><p>当完成签到后，签到数据会存储在后端，在重复打开APP时，会从后端获取签到数据，如果已经完成签到，则直接显示签到成功。如果2天没签到则触发邮件发送任务。</p><p><img width="723" height="391" referrerpolicy="no-referrer" src="/img/bVdnEwQ" alt="" title="" loading="lazy"/></p><h2>三、开发工具选型</h2><p>欲善其事，先利其器。选择合适的开发工具可以加速整体开发效率，正所谓最热门的编程语言是英语，其次是中文，AI编码已然是当前提升开发效率的不二选择。当下主流的IDE主要是Cursor、Qoder 等，它们还能够很好地支持自定义的 Rules 和 Skills，让AI能够更加高效且准确地编码。并且通过Skills，可以让AI自我总结经验，避免编码过程重复踩坑。这里我们以Qoder作为编码工具，它不但可以编码，还可以使用Bmad-METHOD方法对需求进行梳理和拆解，比如我们可以基于它对「死了么」APP进行功能分析和模块拆解梳理，让AI开发编码流程更清晰。</p><h3>3.1 BMAD-Method：从“先写再救火”到“先规划再迭代”的 Agent 开发范式</h3><p>如果直接让 AI 进入编码阶段，往往只能快速做出一个小型 demo；但当项目需要持续迭代和演进时，维护成本会迅速上升，开发也会变得越来越困难。我们可以借助 Mmad Method：先让 AI 对需求进行整体评审，再完成规划与架构设计，随后拆解功能模块，最后按步骤逐步实现。</p><p>这种方式的优势在于：既能让 AI 在具体开发时聚焦于清晰、可执行的小任务，又能保持全局视角，持续掌控项目方向与进度，从而降低随着代码量增长而带来的错误率。</p><p>例如，AI 可能在完成 A 功能后，开发 B 功能时无意中改动了 A 的依赖，导致 A 失效，最终让系统整体不可用；而当上下文变长后，AI 反而更难准确定位并修复问题。通过“先规划、再拆解、后实现”的流程，可以显著减少这类连锁问题的发生。</p><p><img width="723" height="735" referrerpolicy="no-referrer" src="/img/bVdnEwR" alt="" title="" loading="lazy"/></p><h3>3.2 Agent Skills: 用“渐进式披露”把上下文用在刀刃上</h3><p>Agent Skills 对 AI Coding 的最大价值，在于通过渐进式披露机制系统性缓解“上下文不够用”的工程问题：智能体启动时只加载每个技能的少量元数据（通常约百 token 级），从而在安装大量技能的情况下仍保持极低的初始上下文占用；当某个任务真正需要某项能力时，才按需加载该技能的完整指令与示例，把 token 精准投入到当前要做的事上，避免像传统 MCP 那样在连接时一次性灌入大量工具 Schema 造成“开局上下文爆炸”。更进一步，复杂能力还可以通过脚本与引用资源延展出几乎无限的知识容量，并把解析、转换、计算等高风险步骤交给代码确定性执行，减少 LLM 的幻觉与不稳定输出。最终效果是：对话更轻、决策更准、上下文更干净，AI 在持续迭代编码时更不容易遗忘关键约束或误改既有逻辑，整体交付质量与迭代效率都会显著提升。</p><p><img width="723" height="257" referrerpolicy="no-referrer" src="/img/bVdnEwS" alt="" title="" loading="lazy"/></p><p>同时关于AI Coding的上下文工程等其他内容已然有很多研究，这里不再赘述，本文主要聚焦于如何通过更友好的技术选型，提升AI编码的执行率。</p><h2>四、技术选型</h2><h3>4.1 功能拆解：麻雀虽小，五脏俱全</h3><p>这款APP看起来只有一个签到按钮，但背后涉及的技术模块其实不少。这是一款面向日常自检/报平安场景的轻量应用，通过每日签到帮助用户建立持续的状态确认机制，并在缺席时触发提醒，降低“无人察觉”的风险。其底层技术拆解后主要涉及到以下前后端模块。</p><h4>4.1.1 前端功能模块</h4><table><thead><tr><th>功能</th><th>用户操作</th><th>技术要求</th></tr></thead><tbody><tr><td>信息录入</td><td>输入姓名和邮箱</td><td>表单验证、输入框组件</td></tr><tr><td>每日签到</td><td>点击签到按钮</td><td>按钮交互、状态管理</td></tr><tr><td>状态展示</td><td>显示"今日已签到"</td><td>UI状态切换、本地缓存</td></tr><tr><td>成功反馈</td><td>签到成功动画</td><td>动画效果、用户体验</td></tr></tbody></table><h4>4.1.2 后端功能模块</h4><table><thead><tr><th>功能</th><th>业务需求</th><th>技术要求</th></tr></thead><tbody><tr><td>用户管理</td><td>记录用户信息</td><td>数据库、用户表</td></tr><tr><td>身份识别</td><td>区分不同用户</td><td>认证系统、Session管理</td></tr><tr><td>签到记录</td><td>存储每日签到</td><td>数据库、防重复机制</td></tr><tr><td>数据隔离</td><td>用户只能看自己的数据</td><td>权限控制、安全策略</td></tr><tr><td>定时检测</td><td>自动检查哪些用户未签到</td><td>定时任务、业务逻辑</td></tr><tr><td>邮件通知</td><td>发送提醒邮件</td><td>邮件服务、消息推送</td></tr></tbody></table><h3>4.2 整体技术架构</h3><p>基于前面的功能分析与模块拆解，接下来进入 APP 能力的正式落地实现。在 AI 编程时代，AI 已经能够快速生成前端代码，高效完成界面搭建与交互实现；但真正的挑战往往出现在后端：数据库与数据管理、用户认证与权限控制、定时任务、邮件服务等模块缺一不可，而技术选型一旦过多、过重，不仅会显著拉长开发周期，也会在 MVP 阶段分散团队最宝贵的时间与注意力。</p><p>因此，我们采用一套更适合 AI 协作、低运维、可快速迭代的技术方案：前端使用 SwiftUI，后端核心能力交给托管的阿里云 AnalyticDB Supabase（下文简称ADB Supabase） 云服务承载。应用通过 HTTPS 跨域直连 Supabase，直接调用认证、数据库、边缘函数等能力，无需自建后端服务，更无需投入服务器部署、扩缩容与日常运维，从而把精力集中在客户端体验与核心业务逻辑上。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544030" alt="10.png" title="10.png" loading="lazy"/></p><h4>4.2.1 前端选型：SwiftUI</h4><p>从“AI 亲和度”来看，TypeScript + React + Vite 等 Web 技术栈确实更接近当下主流模型的训练语料与生态，适合快速构建 Web 应用或 AI Native 产品。但本项目的目标是复刻 iOS 生态的 APP，因此选择 SwiftUI 更符合平台一致性与用户体验预期。同时 SwiftUI 具备声明式 UI、组件化结构清晰等特点，也非常利于 AI 生成与维护代码。</p><h4>4.2.2 后端选型：Supabase——AI 编程时代的理想后端</h4><p>Supabase 的优势不只是“开箱即用”，更在于它天然适配 AI 的工作方式：</p><ul><li>声明式与数据库优先：把复杂度放到 AI 更擅长的地方<br/>相比编写大量后端业务代码，AI 更擅长产出 SQL 与声明式配置：表结构、索引、约束、防重复机制、RLS（行级安全）策略等都可以通过 SQL 清晰表达。将关键规则下沉到数据库层，前端逻辑会更简单、更可控，也更不易在迭代中被改坏。</li><li>丰富 SDK + 自动化 API：减少手写接口与架构负担<br/>Supabase 提供多语言 SDK，并以统一的 <code>.insert()</code>、<code>.select()</code> 等方式调用数据与认证能力，开发者无需手写 RESTful 接口，也不必先搭一套完整后端框架。对 AI 而言，这意味着更少的上下文、更标准的调用路径、更高的实现准确度。</li><li>基于云托管的ADB Supabase，实现「死了么」所有功能，都不需要开发者额外再部署后端</li></ul><p>依托 Supabase 托管服务，「死了么」APP的核心后端能力无需额外部署：数据库、认证、权限控制与对外 HTTPS 访问能力一并提供。开发者可以把注意力锁定在客户端与业务闭环上，显著节省开发与运维成本，加快迭代速度。</p><h2>五、详细功能实现拆解</h2><h3>5.1 匿名认证：无感身份识别（不做“用户体系”，也能完成绑定）</h3><p>“死了么 ”APP不提供显式的注册/登录入口，但仍需要做到“数据归属到具体用户”。我们采用 匿名认证（Anonymous Auth）+ 设备唯一标识 的方式实现无感绑定：</p><ul><li>实现思路：客户端首次启动时触发匿名登录，Supabase Auth 生成一个唯一的 <code>user_id</code>；客户端将该身份与本机的设备标识建立关联，后续签到、查询都在该 <code>user_id</code> 下进行。</li><li>效果：用户不需要注册、不需要记密码，即可完成身份识别与数据隔离（配合 RLS）。</li><li>已知限制：用户更换设备后会被视为“新用户”（因为设备标识变化）。</li></ul><p>可演进方向：如果希望“多端同一用户”，可以直接升级为 Supabase Auth 的标准登录体系。ADB Supabase 提供本土化可用的认证能力（如微信/支付宝 OAuth、邮箱等），可以在不改变整体架构的前提下强化登录与账号合并能力。</p><h3>5.2 Edge Functions：把服务端业务逻辑交给云端（AI 友好、低运维）</h3><p>本项目中两类关键能力并不适合放在客户端完成：“定时检测未签到用户”和“发送邮件通知（或其它通知渠道）”</p><p>因此我们使用 ADB Supabase Edge Functions 承载服务端逻辑。Edge Functions 是运行在 Supabase 云端的 Serverless 函数：</p><ul><li>运行时：Deno</li><li>语言：原生 TypeScript</li><li>能力：可作为 HTTP 接口暴露，也可被 Cron Job 定时触发</li></ul><p>为什么Edge Functions对AI编程友好？</p><table><thead><tr><th>维度</th><th>传统自建后端</th><th>ADB Supabase Edge Functions</th><th>对 AI 的直接收益</th></tr></thead><tbody><tr><td>开发语言/环境</td><td>Node/框架/依赖与环境配置</td><td>直接写 TypeScript（Deno）</td><td>AI 更擅长 TS，减少环境坑</td></tr><tr><td>部署</td><td>服务器、Docker、网关、证书</td><td>一条命令发布到云端</td><td>AI 不用“指导你运维”</td></tr><tr><td>API 暴露</td><td>手写路由/网关配置</td><td>自动生成 HTTP 端点</td><td>AI 只需按 URL 调用</td></tr><tr><td>定时任务</td><td>额外 Cron 服务/任务系统</td><td>内置 Cron Jobs 触发</td><td>AI 只配置 Cron 表达式</td></tr><tr><td>权限与密钥</td><td>自己设计鉴权与密钥管理</td><td>使用 <code>service_role key</code>（服务端专用）</td><td>机密留在云端，客户端更安全</td></tr></tbody></table><p><img width="723" height="138" referrerpolicy="no-referrer" src="/img/bVdnExd" alt="" title="" loading="lazy"/></p><p>这里我们实现了两个Edge Function：check-missed-check-ins和send-notification-email。</p><p><strong>Edge Function 1: check-missed-check-ins</strong></p><p><img width="723" height="305" referrerpolicy="no-referrer" src="/img/bVdnExe" alt="" title="" loading="lazy"/></p><p>目标：每天扫描所有用户，找出“连续 2 天未签到”的用户，并触发通知流程。</p><p>这一类“全量扫描 + 规则判断 + 批量触发”的逻辑放在客户端几乎不可行；放在 Supabase Edge Functions 则天然适配。</p><p><strong>业务流程</strong><br/><img width="723" height="1147" referrerpolicy="no-referrer" src="/img/bVdnExf" alt="" title="" loading="lazy"/></p><p>Edge Function 2: send-notification-email<br/><img width="723" height="310" referrerpolicy="no-referrer" src="/img/bVdnExg" alt="" title="" loading="lazy"/></p><p>目标：接收用户信息与紧急联系人邮箱，发送提醒邮件。</p><p>邮件内容示例：</p><pre><code>主题：一条重要通知

我是{username},我已经连续很多天没有活动了，快来检测一下我的身体状态。
</code></pre><p>可扩展性：目前实现的是邮件通知；但基于 ADB Supabase Edge Functions，同一套模式可以平滑扩展到 微信、钉钉、短信等渠道。并且因为第三方渠道的密钥配置保存在云端环境变量/密钥体系中，不会泄露到客户端，安全性更高。</p><p><img width="723" height="381" referrerpolicy="no-referrer" src="/img/bVdnExh" alt="" title="" loading="lazy"/></p><h3>5.3 Cron Jobs - 定时任务调度</h3><p>实现的功能模块：每天自动检测</p><p>在Supabase Dashboard中创建Cron Job：</p><table><thead><tr><th>配置项</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>任务名称</td><td>check-missed-check-ins</td><td>描述性名称</td></tr><tr><td>Cron表达式</td><td><code>0 1 * * *</code></td><td>UTC时间凌晨1点 = 北京9点</td></tr><tr><td>触发方式</td><td>HTTP POST</td><td>调用Edge Function</td></tr><tr><td>URL</td><td><code>/functions/v1/check-missed-check-ins</code></td><td>函数端点</td></tr><tr><td>认证</td><td>Service Role Key</td><td>绕过RLS</td></tr></tbody></table><h2>六、总结与思考</h2><p>虽然「死了么」APP的场景并不是特别复杂，但是也向我们展示了完整的AI编码技术选型的最佳实践。AI编码前端的能力远远强于后端，一方面，模型需要提高对后端的编码能力，另一方面，通过减少后端编码，依托于ADB Supase等BaaS服务，让前端直接变成全栈，也不失为一种围魏救赵的解法。尤其是在AI时代，各种想法加速落地MVP，尽可能让研发聚焦业务本身逻辑，反而显得更加重要。</p><h3>6.1 AI编程时代的技术选型原则</h3><p>通过这个项目，我们沉淀了几条在 AI 辅助开发 / Vibe Coding 场景下更“稳”的技术选型原则——核心目标是：让 AI 更容易写对、写稳、并且更好维护。</p><table><thead><tr><th>原则</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>原则1：优先选择声明式技术栈</td><td>AI 更擅长处理声明式代码</td><td>-   ✅ SwiftUI的声明式UI \&gt; UIKit的命令式UI ✅ SQL的声明式查询 &gt; ORM的命令式操作✅ RLS的声明式策略 &gt; 中间件的命令式鉴权</td></tr><tr><td>原则2：选择文档友好的技术</td><td>AI 依赖高质量文档生成代码</td><td>-   ✅ Supabase官方文档完善✅ SwiftUI有大量示例代码✅ TypeScript类型系统帮助AI理解</td></tr><tr><td>原则3：选择自动化程度高的服务</td><td>减少 AI 需要处理的配置细节</td><td>-   ✅ Supabase自动生成API✅ 匿名认证自动管理Session✅ RLS自动应用权限规则</td></tr><tr><td>原则4：选择类型安全的语言</td><td>类型系统减少 AI 生成错误</td><td>-   ✅ Swift和TypeScript都是类型安全语言✅ 编译时发现错误，而非运行时✅ IDE自动提示，AI生成更准确</td></tr></tbody></table><h3>6.2 Supabase 的核心价值</h3><p>Supabase 在 AI 编程时代展现出独特价值，核心体现在两点：让后端更“轻”，让交付更“快”。</p><p><strong>1.  降低后端复杂度：把长链路工程收敛为少量声明式要素</strong></p><p>在传统自建后端中，AI 需要处理的环节非常多，而且每一层都伴随着大量样板代码与隐性约定：</p><pre><code>框架选择 → 路由设计 → 控制器 → 服务层 → 
数据访问层 → ORM配置 → 数据库连接 → 
认证中间件 → 权限中间件 → 错误处理 → 
日志系统 → 部署配置 → 负载均衡 → ...
</code></pre><p>链路越长，越容易在迭代中产生回归与耦合问题，也会显著消耗上下文与调试成本。而 Supabase 将后端能力高度收敛，开发者与 AI 往往只需要聚焦在三件事上：</p><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td>SQL Schema</td><td>定义数据库的数据模型，包括表结构、索引、约束等</td></tr><tr><td>RLS 策略</td><td>在数据库层实施行级安全策略，控制用户对数据的访问权限与隔离规则</td></tr><tr><td>Edge Functions</td><td>按需使用的后端服务代码，处理定时任务、通知、复杂业务逻辑</td></tr></tbody></table><p><strong>2.  摆脱后端运维：用托管能力换取更快的启动与迭代</strong></p><p>相比自建后端，BaaS 的优势在于“快速启动、持续省心”。ADB Supabase 提供托管数据库、认证、权限控制与对外 API 能力，项目从 0 到可用的启动成本更低；上线后也无需投入精力在服务器部署、扩缩容、证书、网关与日常运维上。</p><p>对移动 App 尤其关键：开发者可以把注意力集中在客户端体验与核心业务闭环，通过 HTTPS 直连云端能力完成数据读写与权限控制，而不是被后端基础设施牵制开发节奏。</p><p>欢迎钉钉搜索群号：“101930027031“，加入钉群获取完整源码资料。</p><p>了解更多关于<strong>ADB Supabase</strong>：<a href="https://link.segmentfault.com/?enc=jIWdLBgUA0TWQX1d%2FsAynQ%3D%3D.RMREIXlAWjnYZqJJjOMo6dq4H8nhsr0JsZo8X%2FD%2FL3%2FEX868tGypRSVuKPTqe%2FmDllPlYNyDAHn4ueH9EZYoYZe38xjb6MmtJZNfqVB5IYKOUfR6y8o7dfIo%2Brx5gSqo" rel="nofollow" target="_blank">https://help.aliyun.com/zh/analyticdb/analyticdb-for-postgres...</a></p>]]></description></item><item>    <title><![CDATA[AI 智能体高可靠设计模式：并行混合搜索融合 俞凡 ]]></title>    <link>https://segmentfault.com/a/1190000047544089</link>    <guid>https://segmentfault.com/a/1190000047544089</guid>    <pubDate>2026-01-15 11:03:26</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><em>本系列介绍增强现代智能体系统可靠性的设计模式，以直观方式逐一介绍每个概念，拆解其目的，然后实现简单可行的版本，演示其如何融入现实世界的智能体系统。本系列一共 14 篇文章，这是第 12 篇。原文：<a href="https://link.segmentfault.com/?enc=lMBuPLCHi32lbW0OiUdsbg%3D%3D.XFtsMOKgI4r1VquXPl4ZjtKXaqvK4uOdtB5LQn%2FBuM5DGrPfkrkwe7FaN3VMLmSSpiHW97z%2Fl5wAerSK4rvdhah98Ecp0hLiQlOA1H5ejRUdkYwR10kSjGapf%2BXGVtgN" rel="nofollow" title="Building the 14 Key Pillars of Agentic AI" target="_blank">Building the 14 Key Pillars of Agentic AI</a></em></blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047508976" alt="" title=""/></p><p>优化智能体解决方案需要软件工程确保组件协调、并行运行并与系统高效交互。例如<a href="https://link.segmentfault.com/?enc=me5wuyvVV1UAcYv%2BDtLn4w%3D%3D.fuDy%2FEdZX6%2BLkbSDjjo%2BxU%2BwgiQKvyRRFUXIm8LDGOpRJtNppJRX2l%2F%2FFIAvreUmMVdFlcXlFjYlUdfD5Ypslw%3D%3D" rel="nofollow" title="预测执行" target="_blank">预测执行</a>，会尝试处理可预测查询以<strong>降低时延</strong>，或者进行<a href="https://link.segmentfault.com/?enc=GSifkbsQFXLdLPOEIYh5iQ%3D%3D.fuVFzrKqqJKzXaHCrqcW0wULUcWYohgK8C1SOlOOQRdc4gtwY3kfKRbI6ebmc5ybP51vez%2BeOTXRs51KmTLCu3RIZmJNC3i%2FjFRifzoEr7C5Et9s5BlhpJsbk%2BDAnzOPIKDOS%2F%2F%2FsHDQLpdVLGJkKDUe%2FribkrpgXPnrDQhqXJrgUVGT3pBCE9MkmumtsGlkan2dufFWFUQ0xxJtKLxWh5YNpnmICHqOlCmMSLsMIMA%3D" rel="nofollow" title="冗余执行" target="_blank">冗余执行</a>，即<strong>对同一智能体重复执行多次</strong>以防单点故障。其他增强现代智能体系统可靠性的模式包括：</p><ul><li><strong>并行工具</strong>：智能体同时执行独立 API 调用以隐藏 I/O 时延。</li><li><strong>层级智能体</strong>：管理者将任务拆分为由执行智能体处理的小步骤。</li><li><strong>竞争性智能体组合</strong>：多个智能体提出答案，系统选出最佳。</li><li><strong>冗余执行</strong>：即两个或多个智能体解决同一任务以检测错误并提高可靠性。</li><li><strong>并行检索和混合检索</strong>：多种检索策略协同运行以提升上下文质量。</li><li><strong>多跳检索</strong>：智能体通过迭代检索步骤收集更深入、更相关的信息。</li></ul><p>还有很多其他模式。</p><p>本系列将实现最常用智能体模式背后的基础概念，以直观方式逐一介绍每个概念，拆解其目的，然后实现简单可行的版本，演示其如何融入现实世界的智能体系统。</p><p>所有理论和代码都在 GitHub 仓库里：<a href="https://link.segmentfault.com/?enc=EsGeCNa3pjYU8nL1dRAvNA%3D%3D.9iX5wRggfBLPMgd7PZd1gM0A7htvmKNd2yJJBGGsUwJ6HEQkeo1cANaTlc1LbEzkuIKHPAcrPNuFjXHum7fKdA%3D%3D" rel="nofollow" title="🤖 Agentic Parallelism: A Practical Guide 🚀" target="_blank">🤖 Agentic Parallelism: A Practical Guide 🚀</a></p><p>代码库组织如下：</p><pre><code>agentic-parallelism/
    ├── 01_parallel_tool_use.ipynb
    ├── 02_parallel_hypothesis.ipynb
    ...
    ├── 06_competitive_agent_ensembles.ipynb
    ├── 07_agent_assembly_line.ipynb
    ├── 08_decentralized_blackboard.ipynb
    ...
    ├── 13_parallel_context_preprocessing.ipynb
    └── 14_parallel_multi_hop_retrieval.ipynb</code></pre><hr/><h2>并行混合搜索融合用于高保真上下文</h2><p><strong>向量搜索（语义）</strong> 擅长理解查询的概念含义，但有时会漏掉包含特定、精确关键词的文档。<strong>关键词搜索（词法）</strong> 则非常适合查找精确术语，却无法理解概念关系。</p><p><strong>并行混合搜索融合（Parallel Hybrid Search Fusion）</strong> 架构通过结合两种方法的优势，为我们提供了解决方案。</p><p>该架构同时执行向量搜索和关键词搜索，然后将其独特发现“融合”成单一、组合的结果集。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544091" alt="混合搜索" title="混合搜索" loading="lazy"/></p><p>这种模式对任何处理混合文本和特定标识符（产品代码、错误消息、法律案件编号）的 RAG 系统都至关重要。</p><p>我们将构建并比较三个 RAG 系统：向量模式、关键词模式和混合模式，以展示混合方法如何检索更优的上下文并生成更完整、准确的最终答案。</p><p>首先构建两种不同的检索机制，我们从熟悉的向量搜索开始。</p><pre><code class="python">from langchain_community.vectorstores import FAISS
from langchain_community.embeddings import HuggingFaceEmbeddings

# 为语义搜索创建标准 FAISS 向量存储
vector_store = FAISS.from_documents(kb_docs, embedding=embeddings)
vector_retriever = vector_store.as_retriever(search_kwargs={"k": 2})</code></pre><p>这是标准的语义搜索引擎，由向量嵌入驱动，在理解查询的“核心内容”方面非常出色。</p><p>接下来利用 <code>scikit-learn TfidfVectorizer</code> 从头开始构建经典关键词检索器，作为基于词汇的搜索引擎。</p><pre><code class="python">from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
from langchain_core.retrievers import BaseRetriever
from langchain_core.callbacks import CallbackManagerForRetrieverRun
from typing import List
from langchain_core.documents import Document

class TfidfRetriever(BaseRetriever):
    """利用 TF-IDF 进行关键词搜索的自定义 LangChain 检索器"""
    # 存储拟合的矢量器和原始文档
    vectorizer: TfidfVectorizer
    docs: List[Document]
    k: int = 2
    class Config:
        arbitrary_types_allowed = True
    def _get_relevant_documents(self, query: str, *, run_manager: CallbackManagerForRetrieverRun) -&gt; List[Document]:
        # 将查询转换为 TF-IDF 向量
        query_vec = self.vectorizer.transform([query])
        # 获取所有文档的预计算 TF-IDF 向量
        doc_vectors = self.vectorizer.transform([doc.page_content for doc in self.docs])
        
        # 计算查询和文档之间的余弦相似度
        similarities = cosine_similarity(query_vec, doc_vectors).flatten()
        
        # 获取前 k 个最相似文档的索引
        top_k_indices = np.argsort(similarities)[-self.k:][::-1]
        
        # 返回对应的 Document 对象
        return [self.docs[i] for i in top_k_indices]

# 在知识库内容上拟合 TF-IDF 矢量
vectorizer = TfidfVectorizer().fit([doc.page_content for doc in kb_docs])

# 创建自定义检索器实例
keyword_retriever = TfidfRetriever(vectorizer=vectorizer, docs=kb_docs, k=2)</code></pre><p><code>TfidfRetriever</code> 是词汇检索专家，与向量检索器不同，它不理解含义，纯粹基于词频工作，查找包含用户查询中确切的、字面关键词的文档，无论关键词是否罕见或语义权重较低。</p><p>接下来构建混合 RAG 系统，其核心是 LangGraph 节点，并行运行两个检索器，然后融合结果。</p><pre><code class="python">from langgraph.graph import StateGraph, END
from typing import TypedDict, List

class HybridRAGState(TypedDict):
    question: str
    retrieved_docs: List[Document]
    final_answer: str

def parallel_retrieval_node(state: HybridRAGState):
    """该模式的核心是：并行运行矢量和关键字搜索并融合结果"""
    print("--- [Hybrid Retriever] Running Vector and Keyword searches in parallel... ---")
    
    # 用同样的问题来调用这两个系统
    # 由于其独立性，所以两个调用可以在真正的多线程系统中并发执行
    vector_docs = vector_retriever.invoke(state['question'])
    keyword_docs = keyword_retriever.invoke(state['question'])
    
    # “融合”步骤：合并两个文档列表，对数据去重
    all_docs = vector_docs + keyword_docs
    unique_docs = list({doc.page_content: doc for doc in all_docs}.values())
    
    print(f"--- [Hybrid Retriever] Fused results: Found {len(unique_docs)} unique documents. ---")
    return {"retrieved_docs": unique_docs}

# 用生成节点组装完整的图
workflow = StateGraph(HybridRAGState)
workflow.add_node("parallel_retrieval", parallel_retrieval_node)
workflow.add_node("generate_answer", generation_node)
workflow.set_entry_point("parallel_retrieval")
workflow.add_edge("parallel_retrieval", "generate_answer")
workflow.add_edge("generate_answer", END)
hybrid_rag_app = workflow.compile()</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047544092" alt="并行融合搜索" title="并行融合搜索" loading="lazy"/></p><p><code>parallel_retrieval_node</code> 是进行融合的地方，运行 <code>vector_retriever</code> 和 <code>keyword_retriever</code>，然后组合它们的输出。简单的去重 <code>list({doc.page_content: doc for doc in all_docs}.values())</code> 是一种基本但有效的融合策略，从而确保如果两个检索器找到相同的文档，就只保留一次，如果找到不同的文档，所有独特发现都会保留在最终上下文中。</p><p>最后进行直接对比分析，创建一个特定查询，旨在让单一搜索系统失效，包含一个高级语义概念（"节能措施"）和一个非常具体、罕见的关键词（<code>ERR_THROTTLE_900</code>）。要给出完整答案，需要结合两种搜索方法的优势才能找到信息。</p><pre><code class="python"># 查询包含概念部分和特定关键字部分
user_query = "What are our company's power saving efforts, and what is the error code for QLeap-V4 overheating?"


# --- 执行向量 RAG ---
vector_answer = rag_chain_vector.invoke(user_query)
# --- 执行关键词 RAG ---
keyword_answer = rag_chain_keyword.invoke(user_query)
# --- 执行混合 RAG ---
hybrid_answer = hybrid_result['final_answer']

# --- 最终分析 ---
print("\n" + "="*60)
print("                     ACCURACY &amp; QUALITY ANALYSIS")
print("="*60 + "\n")
print("The User's Goal: The user asked two distinct questions: 1. What are our power saving efforts? (A semantic question) and 2. What is the error code for overheating? (A specific/lexical question).\n")
print("-" * 60)
print("Vector-Only RAG Performance:")
print("- Result: FAILED to answer completely.")
print("- Final Answer:", vector_answer)

print("Keyword-Only RAG Performance:")
print("- Result: FAILED to answer completely.")
print("- Final Answer:", keyword_answer)

print("-" * 60)
print("Hybrid Search RAG Performance:")
print("- Final Answer:", hybrid_answer)</code></pre><p>最终结果是……</p><pre><code class="python">#### 输出 ####
============================================================
                     ACCURACY &amp; QUALITY ANALYSIS
============================================================

The User Goal: The user asked two distinct questions: 1. What are our power saving efforts? (A semantic question) and 2. What is the error code for overheating? (A specific/lexical question).
------------------------------------------------------------
Vector-Only RAG Performance:
- Result: FAILED to answer completely.
- Final Answer: Based on the provided context, the company power saving effort is an initiative called Project 'Titan', which is focused on developing energy-efficient hardware to reduce power consumption in data centers and is part of the green computing strategy. The context does not contain information about an error code for QLeap-V4 overheating.
- Reason: It excelled at the semantic part, finding documents about 'Project Titan' by matching the concept of 'power saving efforts' to 'energy-efficient hardware'. However, the specific error code 'ERR_THROTTLE_900' was not semantically close enough to the query to be retrieved. The agent correctly stated it could not find the answer.

------------------------------------------------------------
Keyword-Only RAG Performance:
- Result: FAILED to answer completely.
- Final Answer: Based on the context, the error code for QLeap-V4 overheating is 'ERR_THROTTLE_900'. Project 'Titan' is an initiative to reduce power consumption.
- Reason: It excelled at the lexical part, perfectly matching the keyword 'ERR_THROTTLE_900' in the query to the document containing it. However, it missed the second, more conceptual document about 'Project Titan' being part of the 'green computing strategy' because the keywords didnt overlap strongly.

------------------------------------------------------------
Hybrid Search RAG Performance:
- Result: SUCCESS. Answered both parts of the question accurately.
- Final Answer: Our companys power saving effort is called Project 'Titan', which is a core part of our green computing strategy aimed at developing energy-efficient hardware to reduce data center power consumption. The official error code for QLeap-V4 overheating is 'ERR_THROTTLE_900'.
- Reason: The parallel execution and fusion step provided the best of both worlds. The vector search contributed the two documents about 'Project Titan', and the keyword search contributed the document with the specific error code. By combining these unique results into a single, rich context, the generator had all the information it needed to construct a complete and correct answer.</code></pre><p>最终分析对混合方法的优越性做出了明确判断。</p><ul><li>仅使用向量和仅使用关键词的系统都产生了不完整、部分正确的答案，每个系统都只能看到问题的一部分。</li><li>向量搜索理解了“节能”的概念，但错过了错误代码的具体关键词。关键词搜索找到了错误代码，但错过了关于公司可持续发展战略的概念性文档。</li><li>混合搜索系统成功的原因在于它不是专家，而是由专家构建的通才，其并行的“分散-聚集”方法确保从两种检索方法中捕获了独特的发现。</li><li>融合步骤创建了包含所有必要事实的单一、全面的上下文，使最终的生成式代理能够轻松综合出完整且准确的答案，解决了用户复杂查询的两个部分。</li></ul><hr/><blockquote>Hi，我是俞凡，一名兼具技术深度与管理视野的技术管理者。曾就职于 Motorola，现任职于 Mavenir，多年带领技术团队，聚焦后端架构与云原生，持续关注 AI 等前沿方向，也关注人的成长，笃信持续学习的力量。在这里，我会分享技术实践与思考。欢迎关注公众号「DeepNoMind」，星标不迷路。也欢迎访问独立站 <a href="https://link.segmentfault.com/?enc=hCNLC1pDu%2BH45eNCRBZ89A%3D%3D.WL8W6bCdTgV1yuW0sUHmP8umnah6%2Bpu9ft2qTkegKG4%3D" rel="nofollow" title="www.DeepNoMind.com" target="_blank">www.DeepNoMind.com</a>，一起交流成长。</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=bPKet06DnI0HPgOrAR42aA%3D%3D.874CjFW%2BL6uE0fCwMe96i5LMnusS9J0QNsgU%2BSqyD3g%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[AI面试智能体：破解年底招聘困局的核心利器 爱跑步的香蕉_cKtiNz ]]></title>    <link>https://segmentfault.com/a/1190000047544107</link>    <guid>https://segmentfault.com/a/1190000047544107</guid>    <pubDate>2026-01-15 11:02:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>AI面试智能体：破解年底招聘困局的核心利器<br/>“金九银十”落幕，招聘工作非但不能松懈，反而要直面年底更严峻的挑战。核心员工流动、为明年储备人才、候选人持观望态度等待年终奖等问题交织，让HR陷入一场隐蔽且焦灼的人才储备战。现实困境愈发突出：简历筛选量激增却难觅适配者，面试官轮换导致评估标准混乱，招聘周期拉长让优质候选人被竞争对手抢先锁定，这并非HR能力不足，而是传统招聘系统已难以适配当下的人才竞争节奏。</p><p>如今，招聘已迈入“AI面试智能体”时代，单纯依靠经验“凭感觉选人”的模式正逐步被淘汰。越来越多头部企业和顶尖高校达成共识：年底招聘的核心竞争力，不在于人力投入多少，而在于是否具备高效、稳定的系统能力。传统招聘的低效、主观、高成本等痛点，已无法支撑企业在人才竞争中占据优势，AI面试智能体凭借精准评估与优质体验，成为破解困局的关键。<br/>招聘的本质是精准筛选出能胜任岗位的候选人，因此打分的可靠性是AI面试智能体的核心价值。顶尖的AI面试智能体，打分结果并非仅供参考，而是可直接纳入招聘决策链路，其核心优势源于双重验证：一方面经过真实业务场景下的人机“背靠背”对比实验，另一方面通过效标效度与重测稳定信度两项心理学核心指标验证，确保评估数据稳定、结果可复现，经得起复盘与审计。随着技术迭代，新一代AI面试智能体已实现从“辅助参考”到“直接决策”的质的飞跃，展现出比人工判断更稳定、更可复用的评估能力。<br/>新一代AI面试智能体的精准性，并非抽象概念，而是贯穿招聘全流程的实操能力，具体体现在以下细节中：<br/>•一问多能：单道题目可同步评估多项胜任力，无缝衔接HR初筛与技术复试环节，整体评估效率提升50%以上，大幅压缩招聘周期；<br/>•智能追问：可根据候选人的即时回答，动态生成针对性问题，如同资深面试官般精准抓住核心信息，避免遗漏关键考察点、偏离评估方向；<br/>•简历深度挖掘：自动抓取简历中的关键信息与模糊疑点，生成递进式提问，既能有效防范信息造假，也能规避HR因主观疏忽错失潜力候选人；<br/>•全维度覆盖：既能够评估沟通、协作等通用胜任力，也可针对编程、算法、工程、财务等专业领域精准出题，同时为HR与专业面试官减负增效。<br/>不少企业对AI面试的顾虑集中在候选人体验上，担心机械生硬的交互拉低雇主品牌形象。而优质的AI面试智能体，恰恰能将面试转化为雇主品牌的加分项，打破“AI面试=冷冰冰”的固有认知：<br/>•拟人化情绪交互：系统可精准捕捉候选人的语速、情绪与潜台词，以真人化引导帮助候选人正常发挥，减少因紧张导致的评估偏差；<br/>•无断点流畅体验：无需候选人手动点击开始或结束，系统自动识别作答状态并自然衔接下一问题，贴近真实面对面沟通场景；<br/>•沉浸式视觉呈现：语音与口型高度同步，嘴型、语速、节奏自然匹配，大幅降低AI交互带来的疏离感；<br/>•双向答疑沟通：候选人可随时提问，系统能准确解答岗位信息、公司福利等疑问，让面试从单向筛选转变为双向深度了解，提升候选人入职意愿。<br/>年底招聘的比拼，本质是系统能力的较量。在人才竞争日趋激烈的当下，AI面试智能体凭借心理学支撑的精准评估与极致候选人体验，重构招聘流程价值，帮助企业在关键节点更快、更稳地锁定优质人才，摆脱效率与判断焦虑，实现高效人才储备。</p>]]></description></item><item>    <title><![CDATA[OpenTiny 2025年度贡献者榜单正式公布~ OpenTiny社区 ]]></title>    <link>https://segmentfault.com/a/1190000047544112</link>    <guid>https://segmentfault.com/a/1190000047544112</guid>    <pubDate>2026-01-15 11:02:12</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img width="723" height="2743" referrerpolicy="no-referrer" src="/img/bVdnEyC" alt="" title=""/></p>]]></description></item><item>    <title><![CDATA[2026实战白皮书：节点式巡检管理工具从入门到精通的体系化指南与攻略 NAVI_s1mple ]]></title>    <link>https://segmentfault.com/a/1190000047544114</link>    <guid>https://segmentfault.com/a/1190000047544114</guid>    <pubDate>2026-01-15 11:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2><strong>为什么我们需要节点式巡检工具？</strong></h2><p>在许多企业的日常运营中，巡检是一项极其枯燥但又至关重要的任务。大家投入大量精力在现场巡视、状态记录和隐患排查上，能量集中在如何发现当下的问题。但由于缺乏系统性的节点管理，很多团队在巡检过程中极易出现“巡而不检、检而不严”的现象。  <br/>结果是常见的几种情况：</p><ul><li><strong>巡检轨迹难追踪</strong>：巡检员是否真正到达现场、停留时间是否达标，缺乏客观的节点验证，容易产生虚假记录；</li><li><strong>隐患排查不闭环</strong>：发现的异常情况散落在纸质记录或聊天群里，整改进度难以实时监控，容易导致小隐患拖成大事故；</li><li><strong>节点数据失效</strong>：过往的巡检数据因为没有按节点结构化保存，无法进行趋势分析，失去了预防性维护的价值；</li><li><strong>责任划分不明确</strong>：由于缺乏关键节点的实时状态和责任人记录，出现问题时难以精准定责。</li></ul><p>节点式巡检管理工具的意义就在于此——它不仅帮助团队在巡检中管理路径与任务，还能通过数字化的节点控制，将巡检流程拆解为标准化动作，确保每一次检查都能精准留痕，形成可追溯的质量闭环。</p><h2><strong>节点式巡检管理工具的特点</strong></h2><p>一个高效的节点工具，除了能够记录位置外，还应该满足以下几个方面的能力：</p><ol><li><strong>节点化强制约束</strong>：支持二维码、NFC 或 GPS 定位，确保巡检人员必须到达指定节点才能触发任务；</li><li><strong>结构化表单</strong>：针对不同节点设置标准化的检查项，将定性描述转化为定量数据；</li><li><strong>异常自动聚合</strong>：当底层节点出现异常时，系统自动汇总报警并派发整改任务；</li><li><strong>实时看板展示</strong>：通过可视化看板，直观呈现所有巡检节点的实时状态和任务进度；</li><li><strong>多级逻辑嵌套</strong>：支持在区域节点下嵌套子节点，应对长链路、高密度的设施检查；</li><li><strong>历史偏差分析</strong>：通过 SQL 等技术手段，识别执行耗时超出标准或频繁漏检的环节。</li></ol><h2><strong>使用节点工具带来的好处</strong></h2><ul><li><strong>确保执行质量</strong> 节点式的强约束机制消除了“巡检黑盒”，通过原子执行层的颗粒化管理，确保巡检动作不走样；</li><li><strong>提升隐患响应速度</strong> 一旦节点数据异常，系统可立即触发状态演进，实现从发现隐患到指派整改的无缝闭环；</li><li><strong>知识与经验的模板化</strong> 将成熟的巡检路径和标准沉淀为模板，新员工只需对照节点指引即可快速上手，降低培养成本；</li><li><strong>保障合规与审计</strong> 完整的巡检留痕和位置校验记录，能满足安全监管部门和内部合规审计的严格要求；</li><li><strong>支持预测性维护</strong> 长期积累的节点数据可用于效能审计与分析，识别设备瓶颈，实现从被动修向主动维护的转变。</li></ul><h2><strong>巡检场景示例</strong></h2><ul><li><strong>工业制造</strong> 在生产车间的关键设备上布设巡检节点，涵盖压力数值、温度记录和运行噪音，确保产线稳定；</li><li><strong>物业管理</strong> 针对消防设施、电梯运行和公共卫生进行节点式排布，实现高频巡检任务的自动化汇总与监控；</li><li><strong>能源电力</strong> 在变电站或输电线路的关键塔基设置定位节点，记录环境湿度、负载电流等原子数据，防范系统风险；</li><li><strong>仓储物流</strong> 对仓库的防火门、监控位和温控节点进行定期扫描，确保库存环境始终符合安全存储标准；</li><li><strong>市政基建</strong> 对城市管网、路灯或桥梁关键受力点进行周期性节点检查，供后续城市运行分析使用。</li></ul><h2>---</h2><p><strong>5款值得尝试的节点式巡检管理工具</strong></p><h3><strong>1. 板栗看板</strong></h3><p>可视化节点与任务执行一体化</p><ul><li><strong>特点</strong>：支持自定义巡检节点与标签，任务与空间节点高度绑定，状态实时反馈；</li><li><strong>优势</strong>：通过卡片嵌套与状态可视化确保标准落地，方便随时进行效能回溯；</li><li><strong>适合团队</strong>：需要兼顾巡检执行与任务可视化管理的团队。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047544116" alt="在这里插入图片描述" title="在这里插入图片描述"/></li></ul><h3><strong>2. Notion</strong></h3><p>灵活的结构化记录与数据库平台</p><ul><li><strong>特点</strong>：利用数据库关联（Relation）功能构建复杂的巡检层级结构；</li><li><strong>优势</strong>：文本编辑能力强，侧重于巡检理论框架与长篇规章的沉淀；</li><li><strong>适合团队</strong>：注重巡检标准宣贯和知识百科沉淀的团队。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047544117" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></li></ul><h3><strong>3. ClickUp</strong></h3><p>多层级结构与自动化巡检流管理</p><ul><li><strong>特点</strong>：提供清晰的任务树结构，支持任务与 SOP 步骤自动关联；</li><li><strong>优势</strong>：强大的状态机联动逻辑，底层节点达成后父任务状态自动更新；</li><li><strong>适合团队</strong>：需要严密逻辑闭环和自动化流程推送的组织。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047544118" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></li></ul><h3><strong>4. 各种专业移动巡检App</strong></h3><p>侧重现场采集的专用节点工具</p><ul><li><strong>特点</strong>：集成了 GPS 定位、拍照水印、二维码扫描等硬件调用功能；</li><li><strong>优势</strong>：操作简便，核心在于解决“人不在岗”的真实性问题；</li><li><strong>适合团队</strong>：外勤人员多、巡检点位极其分散的一线团队。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047544119" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></li></ul><h3><strong>5. Jira / 专业管理系统</strong></h3><p>工程驱动的深度管理平台</p><ul><li><strong>特点</strong>：具备完善的任务拆解结构，支持高度定制的巡检工作流；</li><li><strong>优势</strong>：逻辑严密，支持深度的偏离度审计与效能分析；</li><li><strong>适合团队</strong>：对巡检流程逻辑和数据分析有极高要求的企业。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047544120" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></li></ul><h2>---</h2><p><strong>如何选择合适的巡检管理工具？</strong></p><p>选择节点式巡检工具需要结合业务复杂度、人员素质以及数据深度来考虑。可以从以下几个角度入手：</p><h3><strong>1. 按巡检深度选择</strong></h3><ul><li><strong>基础巡检</strong>：更需要轻量化工具，确保签到成功即可。上手快，不会增加一线人员负担。</li><li><strong>深度巡检</strong>：建议选择支持原子执行层（Checklist）和多维度映射的工具，确保每个步骤都有据可依。</li></ul><h3><strong>2. 按任务复杂度选择</strong></h3><ul><li><strong>线性巡检</strong>（如固定路线保安巡逻）：选择简单易操作的移动端工具；</li><li><strong>复杂系统巡检</strong>（如化工厂维护）：优先支持流程嵌套和父子关联的工具，让逻辑层次更清晰。</li></ul><h3><strong>3. 看自动化与集成能力</strong></h3><ul><li>是否支持根据任务类型自动匹配 SOP 模板，并在任务创建时一键分发；</li><li>是否能通过 SQL 或 API 与企业现有的安全管理平台、报修系统无缝打通。</li></ul><h3><strong>4. 考虑审计与分析能力</strong></h3><p>节点工具的核心价值是<strong>数据反哺</strong>，所以分析能力非常关键：</p><ul><li><strong>偏离度预警</strong>：实际执行时间超出理论标准时自动预警；</li><li><strong>趋势汇总</strong>：分析某节点在过去一年的异常频次；</li><li><strong>轨迹复现</strong>：通过位置校验算法还原真实的巡检路径。</li></ul><h3><strong>5. 权限与安全性</strong></h3><p>巡检记录涉及企业核心安全资产和隐患数据，需要考虑：</p><ul><li>是否支持按区域、节点设置严格的查看与编辑权限；</li><li>数据是否具备防篡改机制，满足监管合规要求。</li></ul><h3><strong>6. 持续迭代与可扩展性</strong></h3><ul><li><strong>灵活性</strong>：标准变更时，工具是否支持一键更新所有关联的任务模板；</li><li><strong>进化力</strong>：是否支持根据历史数据不断优化巡检节点和标准。</li></ul><p><strong>快速建议：</strong></p><ul><li>想要可视化展现巡检进度与节点状态：<strong>板栗看板</strong>；</li><li>追求极致的流程自动化与状态联动：<strong>ClickUp</strong>；</li><li>需要深度的理论沉淀与百科式管理：<strong>Notion</strong>；</li><li>如果巡检现场环境极差、依赖硬件定位，优先选择原生巡检App。</li></ul><h2>---</h2><p><strong>提升巡检效率的小技巧</strong></p><ol><li><strong>确立关键控制节点</strong> 遵循“抓大放小”原则，将资源集中在风险最高、最易出错的核心环节，避免节点冗余；</li><li><strong>强制闭环管理</strong> 设定节点逻辑，若前一节点未通过或异常未处理，后续流程应受限，强制隐患归零；</li><li><strong>动态模板更新</strong> 建立纠错机制，鼓励一线人员指出标准中的不合理节点，实现标准的动态生长；</li><li><strong>定期数据效能审计</strong> 每季度对巡检偏差率进行分析，剔除效率低下的环节，优化巡检路径。</li></ol><h2>---</h2><p><strong>总结</strong></p><p>节点式巡检管理工具的价值，不仅在于监督人员，更在于让组织的防线变得可视、可控且可进化。</p><p>它让巡检从“只走过场”转向“节点必控”，让每一次安全动作都能在系统中沉淀为价值资产。</p><p>通过 <strong>板栗看板</strong>、ClickUp、Notion 等工具，团队可以在执行的同时构建属于自己的“安全数据库”，让企业在复杂的运行环境下始终保持高效的免疫力。</p><p>巡检的价值，不仅在于发现问题，更在于让风险在节点中消亡。</p>]]></description></item><item>    <title><![CDATA[2026-01-15 GitHub 热点项目精选 程序员锋仔 ]]></title>    <link>https://segmentfault.com/a/1190000047543824</link>    <guid>https://segmentfault.com/a/1190000047543824</guid>    <pubDate>2026-01-15 10:06:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>🌟 2026-01-15 GitHub Python 热点项目精选(8个)</h2><blockquote>每日同步 GitHub Trending 趋势，筛选优质 Python 项目，助力开发者快速把握技术风向标～</blockquote><hr/><h3>📋 项目列表（按 Star 数排序）</h3><h4>1. <a href="https://link.segmentfault.com/?enc=eaN0c3syFDqAzHA5Gsbn5g%3D%3D.NHPs%2FMgEdA96Gb9%2Fs7sciEyYKWL6URQUoEJU%2FMvFb55LSZQEAqI%2FO1pKdCl6Zw2h" rel="nofollow" target="_blank">sierra-research/tau2-bench</a></h4><blockquote>τ²-Bench 是一个用于评估客户服务代理在多种领域表现的模拟框架。它支持强化学习训练，提供标准化的任务拆分用于训练和评估，并且有一个实时排行榜展示模型性能。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 632（今日+5）</td></tr><tr><td>Fork 数</td><td>🔄 152</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=w7tQAf3sYCy9qyl7sf%2FYIg%3D%3D.KoPtNPriPJLzDnNM%2BmuLuBmyKywNOfyi3zKdvLg6M0A248m8qAK5Ld%2BVKd4Ptb1J" rel="nofollow" target="_blank">https://github.com/sierra-research/tau2-bench</a></td></tr></tbody></table><hr/><h4>2. <a href="https://link.segmentfault.com/?enc=2ksreymXV2kDAArB6AzIqA%3D%3D.QQbrMY4mqrtPpC3TClJ0mGMJxCQfh7GOMx1Shqp4RKYaeKRxRGph3YRzNMwMoWM%2F" rel="nofollow" target="_blank">chidiwilliams/buzz</a></h4><blockquote>Buzz 是一个基于 OpenAI 的 Whisper 技术的音频转录和翻译工具，支持离线在个人电脑上使用。它具有多种功能，包括实时音频转录、语音分离、说话人识别、多种导出格式以及命令行界面支持。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 17099（今日+485）</td></tr><tr><td>Fork 数</td><td>🔄 1267</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=tpuNK6WkJnRBckFsg6L%2Fxw%3D%3D.xytD5hW%2F6BTY3EKOPXX2EQyK%2BepEHymyGXlZ94QCPSC5fI7Vyr8MuyOX3KEOeVfW" rel="nofollow" target="_blank">https://github.com/chidiwilliams/buzz</a></td></tr></tbody></table><hr/><h4>3. <a href="https://link.segmentfault.com/?enc=sFv%2FYMbIvHRCqmuWAuzj1w%3D%3D.2nU5%2BzKVoqNHWxGnVKPfU%2BC%2FCeBA09rtBUkQFNK4LXGZ%2BwYgWxwYjOyCgJ%2F2qHFw" rel="nofollow" target="_blank">NanmiCoder/MediaCrawler</a></h4><blockquote>MediaCrawler 是一个多平台自媒体数据采集工具，支持小红书、抖音、快手、B站、微博、贴吧、知乎等平台的公开信息抓取。它基于 Playwright 框架，无需复杂的 JS 逆向，易于使用。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 42580（今日+74）</td></tr><tr><td>Fork 数</td><td>🔄 9417</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=tHLnJklJLNWupEaYMAVMxQ%3D%3D.d%2BQABWuNAJXnq74GsIrDd%2BM8xhAR8ITy4v8TivdPjcAP0PwBxTcgygA5pwewcHzW" rel="nofollow" target="_blank">https://github.com/NanmiCoder/MediaCrawler</a></td></tr></tbody></table><hr/><h4>4. <a href="https://link.segmentfault.com/?enc=7hEYZdcE%2FBlnUZfJJ1erBQ%3D%3D.iec2BScCRcXBTSmM5Cb4SFnKLiaJj9nSsDWxESx16Y0%3D" rel="nofollow" target="_blank">OpenPipe/ART</a></h4><blockquote>Agent Reinforcement Trainer (ART) 是一个开源的强化学习框架，用于训练多步骤代理以完成现实世界任务。它支持多种模型，如 Qwen2.5、Qwen3 和 Llama，并且可以与 W&amp;B Training 等服务集成，简化训练和部署流程。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 8217（今日+52）</td></tr><tr><td>Fork 数</td><td>🔄 658</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=arGHyoOLISB3a4uqckQDyQ%3D%3D.oCICkmlGrH1Bzw1Ug3zRxyGeRdswI9Z%2FXPdQcmIr%2FFU%3D" rel="nofollow" target="_blank">https://github.com/OpenPipe/ART</a></td></tr></tbody></table><hr/><h4>5. <a href="https://link.segmentfault.com/?enc=yVbZm2pg3Jk2lSJVRO0wHw%3D%3D.nPFlb9oZF%2FNQPRDY7Ma5lQWK4ndIKYogAN%2FF5aaNX3Et6iTF4eYMHtLzUcaBfBml" rel="nofollow" target="_blank">UKGovernmentBEIS/inspect_ai</a></h4><blockquote>Inspect 是由英国人工智能安全研究所开发的一个大型语言模型评估框架。它提供了丰富的内置组件，支持提示工程、工具使用、多轮对话和模型评分等功能，并且可以扩展以支持新的评估技术。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 1662（今日+4）</td></tr><tr><td>Fork 数</td><td>🔄 373</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=1NxdLxoUGs01LmXk3J%2FfsA%3D%3D.4GRUiDXgQMkC6AstJYRVEJ6bj3cYgoG4TP0xQJEqX7xVTAu7Ce3zYdFySkZ7n%2BZH" rel="nofollow" target="_blank">https://github.com/UKGovernmentBEIS/inspect_ai</a></td></tr></tbody></table><hr/><h4>6. <a href="https://link.segmentfault.com/?enc=Wy8WR0IjETPbLDzKZvN8Cg%3D%3D.Mv6mn684cMfy%2BK%2FeFdmaNuM65w80bTPMUaPmMfk0gPEp7YVztezZq9%2FVjYdKVwPl" rel="nofollow" target="_blank">datalab-to/chandra</a></h4><blockquote>Chandra 是一个高精度的 OCR 模型，能够将图像和 PDF 转换为结构化的 HTML/Markdown/JSON，同时保留布局信息。它支持多种语言，具有良好的表格、表单和手写识别能力。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4400（今日+28）</td></tr><tr><td>Fork 数</td><td>🔄 495</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=yvfFb%2FyaKdkHtj9yl9bd6A%3D%3D.E%2BNdc4lQmH5YbFIpuDD42TbW08ShJE3y73FzXupW9MkRHJDoNhzyhdXBdKx0IFzh" rel="nofollow" target="_blank">https://github.com/datalab-to/chandra</a></td></tr></tbody></table><hr/><h4>7. <a href="https://link.segmentfault.com/?enc=jG2PQntKhNr6l1%2FW6HPrJA%3D%3D.nArUeq%2BcvMDxBg3%2FqdHBapOmA1eTFWswGXYc9uAVxbztffXFp4m%2BQ54UlYiSOtKjcgjs6K1hjz%2BAUNzw6kKIMg%3D%3D" rel="nofollow" target="_blank">robert-mcdermott/ai-knowledge-graph</a></h4><blockquote>AI Powered Knowledge Graph Generator 是一个系统，它可以从非结构化文本中提取知识，以主题-谓语-宾语三元组的形式表示，并将其可视化为交互式知识图。它支持多种 OpenAI 兼容的 API 端点。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 1735（今日+48）</td></tr><tr><td>Fork 数</td><td>🔄 255</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=MMvCk5B2EYc%2Bkt1w3UbviA%3D%3D.XEuN2M8CFXMzJ8ZMj11qA%2FriEma4sXjIlXHChK5YvytQUDzPohcIaWlASzSbFC%2BnvK%2Fs88qinzaikOZOWOLDdw%3D%3D" rel="nofollow" target="_blank">https://github.com/robert-mcdermott/ai-knowledge-graph</a></td></tr></tbody></table><hr/><h4>8. <a href="https://link.segmentfault.com/?enc=vWzFpya4a42Tj2NlWqbiQA%3D%3D.Ig2abZZtEch6ZMnr293x2nSrhGYAh1tFPpwJtnSZMgfvYWkZ7ySheCS45I320zXedqJrbSqleIy5nNuGCPuzcw%3D%3D" rel="nofollow" target="_blank">lvgalvao/data-engineering-roadmap</a></h4><blockquote>Roadmap de Engenharia de Dados 是一个为数据工程职业发展提供指导的项目。它包含学习路线图、课程代码和即将举办的活动日程，旨在帮助专业人士提升数据工程技能。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 1069（今日+40）</td></tr><tr><td>Fork 数</td><td>🔄 234</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=OpQWI4CaiKPbUCu09l9ZcQ%3D%3D.L4SLV%2Fv1DPk88R9BCiUtLr5RiudjQbcERPNqr08TaeYdCSqmdY00DgUS6jKWQVoDuOjTRljP96RWde2LzTtHWQ%3D%3D" rel="nofollow" target="_blank">https://github.com/lvgalvao/data-engineering-roadmap</a></td></tr></tbody></table><hr/><h3>📝 说明</h3><ul><li>数据来源：GitHub Trending（2026-01-15 每日榜单）</li><li>筛选条件：Python 语言 + 当日热门项目</li><li>自动更新：每日同步最新趋势，建议收藏本文持续关注～</li></ul><h3>⭐ 推荐理由</h3><ol><li>热门项目代表当前技术趋势，学习价值高</li><li>优质项目代码规范，可作为学习参考</li><li>部分项目可直接用于实际开发，提高效率</li></ol>]]></description></item><item>    <title><![CDATA[你的鸿蒙 APP 包为啥这么大？资源瘦身终极方案，立减 30% 威哥爱编程 ]]></title>    <link>https://segmentfault.com/a/1190000047543837</link>    <guid>https://segmentfault.com/a/1190000047543837</guid>    <pubDate>2026-01-15 10:05:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>哈喽，兄弟们，我是 V 哥！</p><p>咱们搞鸿蒙开发，最忌讳的就是把所有的东西都往包里塞。特别是到了 鸿蒙API 21，DevEco Studio 6.0 虽然强大，但你要是不会配置，不会偷懒，你的包体积绝对能吓跑一拨用户。</p><p>今天，V 哥就教你几招<strong>“外科手术式”的瘦身方案</strong>。只要按照我这 3 步走，<strong>立减 30% 的体积那都是保守估计</strong>，直接让包身轻如燕！</p><hr/><h2>第一招：DevEco 6.0 的“压缩开关”，很多人根本没打开！</h2><h3>痛点直击</h3><p>很多兄弟还在傻乎乎地手动去压缩图片，甚至不敢用高清图。其实 DevEco Studio 6.0 在 API 21 上，自带了一套非常强悍的构建优化机制，<strong>但默认可能没帮你开到最大！</strong></p><h3>终极方案</h3><p>咱们直接改配置文件。打开你项目根目录下的 <strong><code>build-profile.json5</code></strong> 文件。别眨眼，V 哥给你加几行“魔力代码”。</p><p>这段配置不仅会开启资源压缩，还会对原生库进行瘦身。</p><pre><code class="json">{
  "apiType": "stageMode",
  "buildOption": {
    // V 哥重点：这里是构建优化的核心配置
    "externalNativeOptions": {
      "path": "./src/main/cpp/CMakeLists.txt",
      "arguments": "",
      "cppFlags": "",
      // 开启原生库的压缩
      "abifilters": [
        "armeabi-v7a",
        "arm64-v8a"
      ]
    },
    // 【关键】开启资源压缩和严格模式
    "strictMode": {
      "useNormalizedOHMUrl": true
    }
  },
  "modules": [
    {
      "name": "entry",
      "srcPath": "./entry",
      // ... 其他配置
    }
  ],
  // V 哥补充：全局编译参数优化
  "hvigorVersion": "4.0.2",
  "hvigorConfig": "hvigor/hvigor-config.json5"
}</code></pre><p><strong>划重点：</strong><br/>在 <code>hvigor/hvigor-config.json5</code> 里，你可以进一步开启资源混淆和压缩。如果你的 <code>hvigor</code> 版本支持，加上这行逻辑（伪代码示意，具体根据插件文档）：</p><p><em>（注：通常 DevEco 默认开启 PNG 压缩，但我们要确认它开启了 WebP 转换支持，这能省下大量空间）</em></p><hr/><h2>第二招：代码实现“包体积监控器”，眼见为实</h2><p>兄弟们，光压缩不行，咱们得知道它到底瘦了多少。V 哥给你写了一个<strong>“包体监控器”</strong>。</p><p>这段代码基于 API 21，使用了 <code>bundleManager</code> 接口。你可以把它集成到你的“关于页面”或者调试面板里，实时查看 App 占用的大小。</p><p><strong>作用：</strong> 这不仅是为了你自己看，更是为了给产品经理展示你的优化成果！</p><pre><code class="typescript">import bundleManager from '@ohos.bundle.bundleManager';
import { BusinessError } from '@ohos.base';
import promptAction from '@ohos.promptAction';

@Entry
@Component
struct PackageSizeMonitor {
  @State appSize: string = '计算中...';
  @State appName: string = '';

  aboutToAppear(): void {
    this.getAppSize();
  }

  /**
   * V哥核心逻辑：获取当前应用的信息
   */
  async getAppSize() {
    try {
      // 获取 BundleInfo
      // flag 参数：GET_BUNDLE_INFO_WITH_APPLICATION 表示我们要获取应用存储信息等详细数据
      const bundleInfo = await bundleManager.getBundleInfo(
        '你的包名（例如：com.example.vgeapp）', // 注意：这里填你真实的BundleName
        bundleManager.BundleFlag.GET_BUNDLE_INFO_WITH_APPLICATION
      );

      this.appName = bundleInfo.name;

      // 注意：出于安全和隐私，API 可能不直接返回精确的安装包字节大小
      // 但我们可以通过 applicationInfo 的相关信息或者计算数据目录大小来估算
      // 这里我们演示获取基本信息，真实瘦身效果建议通过 DevEco 编译日志查看
      
      // V 哥提示：在实际优化中，对比编译产物中的 entry-default-signed.hap 文件大小最准
      this.appSize = "请查看 DevEco 编译输出窗口中的 HAP 大小"; 
      
      promptAction.showToast({
        message: `App名称: ${this.appName}`,
        duration: 2000
      });

    } catch (err) {
      let error = err as BusinessError;
      console.error(`V哥报错: ${error.code}, ${error.message}`);
      this.appSize = '获取失败，请检查BundleName';
    }
  }

  build() {
    Column() {
      Text('V哥的包体监控器')
        .fontSize(24)
        .fontWeight(FontWeight.Bold)
        .margin({ top: 50, bottom: 20 })

      Text(`当前 App: ${this.appName}`)
        .fontSize(18)
        .margin(10)

      Text(`体积状态: ${this.appSize}`)
        .fontSize(16)
        .fontColor(Color.Red)
        .margin(10)

      Text('瘦身建议：')
        .fontSize(16)
        .fontWeight(FontWeight.Bold)
        .margin({ top: 20 })
        .alignSelf(ItemAlign.Start)
        .margin({ left: 30 })

      Text('1. 将所有 PNG 图片转换为 WebP 格式 (体积减少 30%)')
        .fontSize(14)
        .margin(5)
        .alignSelf(ItemAlign.Start)
        .margin({ left: 30 })

      Text('2. 删除未使用的 rawfile 资源')
        .fontSize(14)
        .margin(5)
        .alignSelf(ItemAlign.Start)
        .margin({ left: 30 })
        
      Text('3. 开启 R class 资源混淆 (混淆后体积更小)')
        .fontSize(14)
        .margin(5)
        .alignSelf(ItemAlign.Start)
        .margin({ left: 30 })

    }
    .width('100%')
    .height('100%')
    .padding(20)
  }
}</code></pre><hr/><h2>第三招：扔掉 4 套图，用这招“动态缩放”代替！</h2><h3>痛点直击</h3><p>兄弟们，Android 老套路是不是还留着？<br/><code>res-density-xhdpi</code>, <code>res-density-xxhdpi</code>, <code>res-density-xxxhdpi</code>...<br/>一套图标复制 4 份，包体积直接暴涨 4 倍！</p><h3>V 哥的瘦身大招</h3><p>在鸿蒙 API 21 上，屏幕适配能力极强。<strong>V 哥建议你：只保留一套高清图（比如放在 <code>resources/base/media</code>），然后写一个通用的图片加载组件，利用系统自带的缩放能力去适配！</strong></p><p>这不仅能减重，还能避免低分屏用户加载了大图浪费内存。</p><h3>代码实战：通用自适应图片组件</h3><pre><code class="typescript">/**
 * V哥的自适应图片组件
 * 核心逻辑：只保留一套高清资源，利用 PixelMap 进行缩放
 * 使用场景：非关键路径图标、背景图
 */
@Component
export struct VGeSmartImage {
  // 资源名称，例如 'app.media.icon_vge'
  @Prop resourceName: string = '';
  // 目标宽度，如果不传则按原大小
  @Param targetWidth?: number;

  build() {
    Image($r(this.resourceName))
      .width(this.targetWidth ? `${this.targetWidth}vp` : undefined)
      .height(this.targetWidth ? `${this.targetWidth}vp` : undefined)
      // V 哥关键点：objectFit 决定了图片在缩放时的填充策略
      // Cover 是裁剪填充，Contain 是包含显示，根据需求选
      .objectFit(ImageFit.Cover) 
      // 开启异步加载，避免阻塞 UI
      .syncLoad(false) 
      // 如果是超大图，可以开启低分辨率占位
      .alt($r('app.media.icon_default'))
  }
}</code></pre><h3>如何使用</h3><p>在你的 <code>build</code> 方法里，别再写 <code>Image($r('app.media.big_icon'))</code> 了，用 V 哥这个组件：</p><pre><code class="typescript">// 在页面中引用
import { VGeSmartImage } from './VGeSmartImage'; // 假设你把组件放在这个路径

build() {
  Column() {
    // 只需要传入资源名，组件会自动处理缩放
    VGeSmartImage({ 
      resourceName: 'app.media.my_banner',
      targetWidth: 300 // 强制缩放到 300vp
    })
    
    VGeSmartImage({ 
      resourceName: 'app.media.user_avatar',
      targetWidth: 50 // 强制缩放到 50vp
    })
  }
}</code></pre><p><strong>V 哥总结：</strong><br/>通过这套逻辑，你只需要保留 <strong>最高清</strong>的那一套资源（比如针对 1080P 或 2K 屏的），在低端机上系统会自动降采样，既保证了清晰度，又砍掉了 75% 的图片冗余空间！</p><hr/><h2>小结一下</h2><p>兄弟们，<strong>包体积优化是持久战</strong>，也是细节战。</p><ol><li><strong>改配置</strong>：把 <code>build-profile.json5</code> 里的压缩参数打开，这是白捡的空间。</li><li><strong>删冗余</strong>：别搞四五套资源图，用 V 哥的 <code>VGeSmartImage</code> 组件一套到底。</li><li><strong>转格式</strong>：DevEco 6.0 右键你的图片 -&gt; <strong>Convert to WebP</strong>。这玩意儿比 PNG 小 30%，画质还一样，真香！</li></ol><p>把这三招做完，再去打个包，你会发现 HAP 文件肉眼可见地变小了。到时候产品经理再看你的 App，绝对得给你竖大拇指！</p><p>我是 V 哥，咱们下期技术复盘见！🚀</p>]]></description></item><item>    <title><![CDATA[别再乱用 @State 了！鸿蒙状态管理避坑指南，看完省 3 天脱发时间 威哥爱编程 ]]></title>    <link>https://segmentfault.com/a/1190000047543840</link>    <guid>https://segmentfault.com/a/1190000047543840</guid>    <pubDate>2026-01-15 10:04:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>哈喽，兄弟们，我是 V 哥！</p><p>最近有粉丝在群里发了个截图，代码里密密麻麻全是 <code>@State</code>，看得我密集恐惧症都犯了。他说：“V 哥，我的 App 怎么越改越卡？明明只是改了列表里的一个文字，整个页面都在闪烁刷新！”</p><p>不看不知道，一看吓一跳！好家伙，<strong>子组件里用 <code>@State</code> 接父组件的数据，深层对象直接修改属性，数据一层一层往下传……</strong></p><p>兄弟们，这哪是写代码，这简直是给鸿蒙的渲染引擎<strong>“下毒”</strong>！在 API 21 的严格模式下，状态管理是道送命题。用不对，不仅逻辑乱，性能更是灾难。</p><p>今天 V 哥就拿出压箱底的<strong>“状态管理三板斧”</strong>，帮你理清 ArkTS 的状态脉络。这文章读完，起码能帮你省下 3 天找 Bug 和掉头发的时间！</p><hr/><h2>坑点一：子组件乱用 @State，导致“过度渲染”</h2><h3>🔴 错误示范（千万别这么写！）</h3><p>很多兄弟觉得，数据变了 UI 就要变，那就加个 <code>@State</code> 嘛！</p><pre><code class="typescript">// 错误代码示例
@Component
struct ChildView {
  @State count: number = 0; // ❌ 灾难的开始！

  build() {
    Text(this.count.toString())
  }
}</code></pre><p><strong>问题在哪？</strong><br/>你在父组件里给 <code>ChildView</code> 传了个 <code>count</code>。一旦父组件刷新，哪怕这个 <code>count</code> 没变，或者只是父组件的其他状态变了，这个 <code>ChildView</code> 因为有 <code>@State</code>，它就会觉得“我有独立状态，我得重新初始化”，导致不必要的重绘。</p><h3>✅ V 哥的正解：只读数据用 @Prop</h3><p>如果子组件只是<strong>展示</strong>数据，数据源在父组件里，那子组件必须用 <strong><code>@Prop</code></strong>。<code>@Prop</code> 是单向同步，父变了子才变，它不会触发额外的初始化开销。</p><pre><code class="typescript">@Component
struct ChildView {
  // ✅ 修复：使用 @Prop 接收父组件数据
  // @Prop 是只读的，不能在子组件里直接 this.count++
  @Prop count: number = 0; 

  build() {
    Text(`V哥计数: ${this.count}`)
      .fontSize(20)
  }
}

@Entry
@Component
struct PropDemo {
  // 数据源头在父组件
  @State total: number = 0;

  build() {
    Column() {
      ChildView({ count: this.total })
      
      Button('点我增加')
        .onClick(() =&gt; {
          this.total++;
        })
    }
  }
}</code></pre><hr/><h2>坑点二：深层对象属性变了，UI 死活不刷新</h2><h3>🔴 痛点直击</h3><p>这绝对是鸿蒙开发里<strong>头号“玄学”Bug</strong>！</p><p>你有一个 <code>User</code> 对象，<code>@State user: User</code>。你点击按钮修改了 <code>user.age</code>。日志里打印出来 age 确实变了，但界面上的数字就是纹丝不动！</p><pre><code class="typescript">class User {
  name: string = 'V哥';
  age: number = 18;
}
// ...
this.user.age = 19; // ❌ UI 不会刷新！</code></pre><h3>🔍 原理剖析</h3><p>ArkTS 的 <code>@State</code> 观察机制，默认只观察对象的<strong>引用（地址）</strong>。你修改了对象内部的属性，对象地址没变，系统就会认为：“咦？地址没变，那就不用刷新 UI 了。” 于是它就“偷懒”了。</p><h3>✅ V 哥的正解：API 21 王炸组合 —— @Observed + @ObjectLink</h3><p>在 API 21 中，处理嵌套对象或深层修改，必须使用<strong>嵌套类观察机制</strong>。这是解决复杂对象状态管理的终极方案。</p><p>兄弟们，下面这段代码是<strong>核心中的核心</strong>，建议直接复制到 DevEco Studio 6.0 跑一遍，理解透彻了，状态管理你就通关了。</p><pre><code class="typescript">/**
 * V哥实战案例：深层对象状态同步
 * 场景：修改用户资料的某个属性，UI 自动刷新
 */

// 第一步：被观察的类
// 注意：@Observed 装饰类，这是对象能被深层观察的前提
@Observed
class Address {
  city: string = '深圳市';
  zipCode: string = '518000';
}

// 第二步：被观察的类
// 注意：如果这个类里有其他对象（如 Address），那个对象类也必须加 @Observed
@Observed
class User {
  name: string = 'V哥';
  age: number = 18;
  address: Address = new Address(); // 嵌套对象
}

@Entry
@Component
struct ObjectLinkDemo {
  // 第三步：父组件持有状态
  // 这里的 User 对象包含了深层属性
  @State currentUser: User = new User();

  build() {
    Column() {
      Text('V哥的状态管理实验室')
        .fontSize(24)
        .fontWeight(FontWeight.Bold)
        .margin({ bottom: 20 })

      // 第四步：子组件中使用 @ObjectLink
      // @ObjectLink 接收的是对象实例，它会建立起与父组件对象的双向监听
      UserCard({ user: this.currentUser })
    }
    .width('100%')
    .height('100%')
    .padding(20)
  }
}

// 第五步：子组件
@Component
struct UserCard {
  // ✅ 关键点：@ObjectLink
  // 它能感知到 user 对象内部任何属性的变化！
  @ObjectLink user: User;

  build() {
    Column() {
      Text(`姓名: ${this.user.name}`)
        .fontSize(18)

      Text(`年龄: ${this.user.age}`)
        .fontSize(18)
        .margin({ top: 5 })

      Text(`城市: ${this.user.address.city}`)
        .fontSize(18)
        .fontColor(Color.Red)
        .margin({ top: 5 })

      Divider()

      // 修改深层属性
      Button('修改城市（深层属性）')
        .width('100%')
        .margin({ top: 10 })
        .onClick(() =&gt; {
          // ✅ 修改嵌套对象的属性
          // 如果没用 @Observed 和 @ObjectLink，这里改了界面也不会动！
          this.user.address.city = '北京市';
          console.info("V哥日志：城市已修改为北京");
        })

      // 修改第一层属性
      Button('修改年龄（第一层属性）')
        .width('100%')
        .margin({ top: 10 })
        .onClick(() =&gt; {
          // ✅ 修改普通属性
          this.user.age++;
        })
    }
    .width('100%')
    .padding(20)
    .backgroundColor('#F1F3F5')
    .borderRadius(12)
  }
}</code></pre><p><strong>V 哥划重点（背诵版）：</strong></p><ol><li>类定义必须加 <code>@Observed</code>（无论是父类还是嵌套的子类）。</li><li>子组件接收对象必须用 <code>@ObjectLink</code>（不能用 <code>@Prop</code>）。</li><li>父组件依然用 <code>@State</code> 持有最初的那个对象引用。</li></ol><hr/><h2>坑点三：爷爷给孙子传数据，传到怀疑人生</h2><h3>🔴 痛点直击</h3><p>假设你的组件层级是：<code>GrandPa</code> -&gt; <code>Father</code> -&gt; <code>Son</code>。<br/>如果 <code>Son</code> 需要 <code>GrandPa</code> 里的一个数据，你得先传给 <code>Father</code>，<code>Father</code> 再传给 <code>Son</code>。<br/>中间如果经过了 5 层组件，那代码写起来简直是灾难，中间层根本不需要这个数据，却得被迫定义变量接收。</p><h3>✅ V 哥的正解：@Provide 和 @Consume</h3><p>这就好比家里的长辈（GrandPa）把钱放到了客厅的保险箱里（<code>@Provide</code>），所有家庭成员（<code>@Consume</code>）都可以直接去拿，不需要一层层转交。</p><pre><code class="typescript">@Entry
@Component
struct GrandPaView {
  // ✅ 爷爷提供了数据
  // 这就像是一个“全局广播”，只要名字叫 'familyName'，谁都能收得到
  @Provide('familyName') familyName: string = 'V哥全家桶';

  build() {
    Column() {
      Text('爷爷的页面')
        .fontSize(20)
        .margin(10)

      FatherView()
    }
  }
}

@Component
struct FatherView {
  build() {
    Column() {
      Text('爸爸的页面')
        .fontSize(18)
        .fontColor(Color.Gray)
      
      // 爸爸根本不需要知道 familyName 是啥，直接往下传
      SonView()
    }
  }
}

@Component
struct SonView {
  // ✅ 孙子直接消费数据
  // 只要这里的名字 'familyName' 和 @Provide 里的一样，就能接收到
  @Consume('familyName') familyName: string;

  build() {
    Text(`孙子拿到了: ${this.familyName}`)
      .fontSize(22)
      .fontWeight(FontWeight.Bold)
      .fontColor(Color.Orange)
      .margin(10)
  }
}</code></pre><p><strong>V 哥使用场景建议：</strong><br/>这招特别适合<strong>全局主题色</strong>、<strong>用户登录信息</strong>、<strong>全局配置</strong>这种贯穿整个 App 的数据。</p><hr/><h2>小结一下</h2><p>兄弟们，API 21 的状态管理其实很有逻辑，别乱用就行。</p><ol><li><strong>子组件只读展示？</strong> 用 <code>@Prop</code>，别贪懒用 <code>@State</code>。</li><li><strong>深层对象要修改？</strong> 类加 <code>@Observed</code>，子组件加 <code>@ObjectLink</code>，这是正解。</li><li><strong>跨层级传数据？</strong> 别傻傻地一层层传，用 <code>@Provide</code> 和 <code>@Consume</code>。</li></ol><p>记住 V 哥这三招，你的代码不仅逻辑清晰，性能也能提升一大截。别再为了那个“改了不刷新”的 Bug 抓掉头发了，赶紧去重构吧！</p><p>我是 V 哥，咱们下期技术复盘见！👋</p>]]></description></item><item>    <title><![CDATA[为什么网站需要 HTTPS 加密？ 才高八斗的杯子_dS2Fpp ]]></title>    <link>https://segmentfault.com/a/1190000047543847</link>    <guid>https://segmentfault.com/a/1190000047543847</guid>    <pubDate>2026-01-15 10:03:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>简单来说，HTTP是网站用来在您的浏览器和服务器之间传输信息的“语言”。但这种语言是<strong>明文的</strong>，就像寄送一张不封口的明信片，任何经手的人都能看到上面的内容。</p><p>而HTTPS则是在HTTP基础上加了一把“锁”和一个“防伪码”。它通过<strong>SSL/TLS证书</strong>对通信进行加密和身份验证。这相当于把明信片装进一个坚固的保险箱，只有指定的收件人才能用钥匙打开阅读。</p><ul><li><strong>HTTP</strong>：明文传输，不安全。</li><li><strong>HTTPS</strong>：加密传输，安全可靠。</li></ul><h4><strong>二、为什么必须升级到“全站”HTTPS？</strong></h4><p>过去，网站可能只在登录和支付页面使用HTTPS，其他页面仍用HTTP。但这存在巨大风险。<strong>全站HTTPS</strong>意味着网站的每一个页面、每一次数据传输都处于加密保护之下。其核心原因如下：</p><p><strong>1. 保护用户数据安全，防止信息窃取</strong>  <br/>这是最根本、最重要的原因。在HTTP环境下，黑客可以在公共Wi-Fi、路由器等节点轻松窃听数据。而HTTPS能有效保护：</p><ul><li><strong>登录凭证</strong>：您的用户名和密码。</li><li><strong>个人隐私</strong>：身份证号、电话号码、家庭住址。</li><li><strong>金融信息</strong>：银行卡号、交易记录。</li><li><strong>通信内容</strong>：聊天记录、邮件内容。</li></ul><p><strong>全站加密确保了用户在任何页面输入的信息都不会被第三方窥探和篡改。</strong></p><h3><a href="https://link.segmentfault.com/?enc=aYJlos1G9%2BLi0x4qUFCzOw%3D%3D.wvtOcBaO%2Fcq6BcYRILEO2BMMnfguZqur2ZZpBBbbXv%2FOSBJSpDhwCdbYruNeKSiP60YJO8jaRvFDh%2BYOlaDIfH6yD7s2RrW2%2FPjWr3MBi1I%3D" rel="nofollow" target="_blank">SSL证书申请入口</a></h3><p>直接访问<strong>JoySSL</strong>官网，注册一个账号记得填写注册码<strong>230970</strong>获取技术支持。<br/><img width="723" height="400" referrerpolicy="no-referrer" src="/img/bVddlwr" alt="" title=""/></p><p><strong>2. 保障网站完整性，抵御中间人攻击</strong>  <br/>没有HTTPS，攻击者不仅可以窃听数据，还能<strong>篡改</strong>传输内容。例如，他们可以在一个HTTP页面上插入恶意广告、钓鱼链接，甚至将您下载的软件替换成病毒。</p><p><strong>HTTPS像一份“数字封印”，确保您看到的内容完全来自真实的网站，且在传输过程中未被修改。</strong></p><p><strong>3. 提升用户信任与品牌形象</strong>  <br/>当用户看到浏览器地址栏的“锁”形标志时，他们会感到更安心。相反，如果一个网站被浏览器标记为“不安全”，很多用户会毫不犹豫地关闭页面，导致客户流失。</p><p><strong>部署HTTPS是向用户展示您对安全和隐私负责任态度的最直接方式，能显著提升品牌的专业性和可信度。</strong></p><p><strong>4. 获得搜索引擎的排名优势</strong>  <br/>谷歌、百度等主流搜索引擎早已公开声明，<strong>HTTPS是搜索排名的一个正面因素</strong>。这意味着，在其他条件相同的情况下，使用了HTTPS的网站会比仍使用HTTP的网站在搜索结果中获得更好的排名。</p><p><strong>为了获得更多的自然流量和曝光，HTTPS已成为一项必不可少的SEO基础工作。</strong></p><p><strong>5. 为现代Web新特性提供基础</strong>  <br/>许多强大的现代Web API（如地理位置、服务推送等）都要求网站部署在安全上下文中。如果您的网站想使用这些新技术来提供更好的用户体验，<strong>HTTPS是前提条件</strong>。</p><h4><strong>总结</strong></h4><p><strong>全站HTTPS早已不再是“可选项”，而是现代网站运营的“标配”</strong> 。它不仅是保护用户数据和网站信誉的坚固盾牌，更是提升搜索排名、获取技术红利、赢得用户信任的关键策略。在网络安全威胁日益严峻的今天，为您的网站开启全站HTTPS加密，是一项对用户、也是对自身未来发展至关重要的投资。</p>]]></description></item><item>    <title><![CDATA[深度解析：递进式任务剥离工具如何重塑你的工作效率 NAVI_s1mple ]]></title>    <link>https://segmentfault.com/a/1190000047543880</link>    <guid>https://segmentfault.com/a/1190000047543880</guid>    <pubDate>2026-01-15 10:03:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>想象一下，当你面对一个庞大的季度目标，你看到的不是清晰的路径，而是堆积如山的待办事项、错综复杂的部门依赖，以及令人窒息的截止日期。</p><p>管理者在不停地询问“进行到哪一步了”，执行者则在多线程切换中精疲力竭。每次项目推进全靠核心成员的硬扛，而非系统的拆解能力。这正是现代职场面临的**“认知负荷”**困境：任务无法解构，精力无法聚焦。</p><h3><strong>01 导语：生产力的瓶颈，是任务颗粒度的粗糙</strong></h3><p>在复杂性激增的现代办公环境中，个人与组织的核心挑战已从“如何完成工作”转向了“如何理清工作”。<strong>递进式任务剥离工具</strong>的缺失，已成为阻碍高效产出的隐形屏障。</p><p>研究表明，知识工作者每天有 <strong>30% 以上</strong>的时间耗费在“由于任务定义模糊导致的无效思考”上。当一个任务以“巨石”形态存在而非“原子”形态时，这种模糊性带来的认知损耗——包括拖延症、执行偏差和关键路径缺失——远比任务本身的难度更具杀伤力。</p><h3><strong>02 协作低效的根源：不是不努力，而是缺乏“逻辑剥离”</strong></h3><p>许多团队尝试用简单的待办清单（To-do List）来管理复杂项目，却发现越记越乱。问题的核心不在于记录，而在于任务的<strong>扁平化</strong>与<strong>混沌化</strong>。</p><ul><li><strong>巨石压顶：</strong> 一个名为“优化搜索算法”的任务挂在清单上一周，因缺乏拆解路径而无从下手。</li><li><strong>依赖模糊：</strong> 任务间的先后逻辑被掩盖，导致执行时频繁出现“由于 A 没完，B 只能等”的断档。</li><li><strong>进度虚标：</strong> 50%的进度条下可能隐藏着未被察觉的 80% 核心难点。</li></ul><p><strong>递进式任务剥离工具</strong>（如递进剥离器）的价值在于：它将“最终目标”像剥洋葱一样，层层递进地转化为“即时行动”。</p><h3><strong>03 递进式剥离：打通执行脉络的逻辑手术刀</strong></h3><p>作为一种前沿的任务管理思维，<strong>递进式任务剥离工具</strong>的核心价值在于将复杂性“剥离”与“分层”。它不仅是记录，更是对思维的结构化重塑。</p><p>这类工具的核心功能通常包括：</p><ul><li><strong>无限级嵌套结构：</strong> 支持从“战略目标”到“执行动作”的深度拆解，每一层级都可独立管理。</li><li><strong>逻辑依赖剥离：</strong> 自动识别任务间的串行与并行关系，剥离出当前唯一的“第一优先项”。</li><li><strong>颗粒度动态调整：</strong> 随着认知深入，支持随时将模糊的父任务剥离为具体的子任务集群。</li><li><strong>能量聚焦视图：</strong> 隐藏暂时无法操作的远期任务，仅呈现剥离后的即时可执行动作，缓解焦虑。</li></ul><h3>---</h3><p><strong>04 递进式任务剥离的多维应用场景</strong></p><p><strong>递进式任务剥离工具</strong>在复杂场景中能产生极大的降本增效作用：</p><ul><li><strong>科研与深度创作：</strong> 将“撰写论文”剥离为文献检索、实验建模、初稿生成、校对等递进环节，化整为零。</li><li><strong>大型工程的节点拆解：</strong> 在基建或系统集成项目中，将海量工序剥离为关键路径上的微小里程碑，确保风险提前暴露。</li><li><strong>敏捷开发的快速迭代：</strong> 将 Epic 剥离为 User Stories，再剥离为具体 Task，确保每个 Sprint 的交付物清晰可感。</li><li><strong>个人成长与技能习得：</strong> 将“掌握 Python”剥离为 21 个具体的实操小目标，让反馈周期缩短，持续产生获得感。</li></ul><h3><strong>05 构建递进式剥离体系的四个步骤</strong></h3><p>实施剥离并非简单的罗列，需要遵循逻辑递进的路径：</p><ol><li><strong>定义最终交付：</strong> 明确剥离的终点是什么，避免陷入为了拆解而拆解的误区。</li><li><strong>实施首层剥离：</strong> 将巨型任务拆解为 3-5 个支撑支柱，建立初步的结构骨架。</li><li><strong>递归向下渗透：</strong> 检查每一个子任务，如果它仍需超过 4 小时才能完成，则继续向下剥离，直至形成原子动作。</li><li><strong>识别阻塞因子：</strong> 在剥离过程中标注外部依赖项，将“等待”动作也作为一种特殊的任务节点显性化。</li></ol><h3><strong>06 主流任务管理与剥离工具对比</strong></h3><table><thead><tr><th align="left">工具类别</th><th align="left">代表平台</th><th align="left">核心优势</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left">递进式剥离工具</td><td align="left">Workflowy,板栗看板</td><td align="left">无限级大纲结构，逻辑递进极其丝滑</td><td align="left">深度思考、复杂拆解、逻辑梳理</td></tr><tr><td align="left">视觉看板工具</td><td align="left">Trello, 板栗看板</td><td align="left">横向流转清晰，适合标准化流程</td><td align="left">团队协作、流程管理、执行跟踪</td></tr><tr><td align="left">传统清单软件</td><td align="left">Todoist, TickTick</td><td align="left">提醒功能强大，适合琐碎杂事</td><td align="left">日常打卡、简单待办、日程安排</td></tr><tr><td align="left">白板/思维导图</td><td align="left">XMind, Miro</td><td align="left">发散性强，适合头脑风暴初期</td><td align="left">创意激发、全局构思</td></tr></tbody></table><h3><strong>07 技术实现示例：递归任务剥离算法</strong></h3><p>利用递归逻辑，我们可以模拟递进式任务剥离工具如何自动遍历并呈现深层任务链：</p><p>Python</p><p>class TaskStripper:</p><pre><code>def \_\_init\_\_(self):  
    self.task\_tree \= {  
        "核心目标: 上线AI助手": {  
            "模块A: 后端开发": \["数据库建模", "API接口开发", "鉴权逻辑实现"\],  
            "模块B: 模型训练": \["数据清洗", "参数调优", "模型导出"\],  
            "模块C: 前端交互": \["UI设计", "组件剥离", "接口对接"\]  
        }  
    }

def strip\_recursive(self, tasks, level=0):  
    \# 模拟递进式剥离显示，将复杂目标递归剥离为原子动作  
    for task, children in tasks.items():  
        print("  " \* level \+ f"➤ 剥离层级 {level}: {task}")  
        if isinstance(children, dict):  
            self.strip\_recursive(children, level \+ 1)  
        else:  
            for leaf in children:  
                print("  " \* (level \+ 1) \+ f"✔ 原子动作: {leaf}")
</code></pre><p>\# 示例调用  <br/>stripper \= TaskStripper()  <br/>stripper.strip\_recursive(stripper.task\_tree)</p><h3><strong>08 实施中的常见误区与解决方案</strong></h3><table><thead><tr><th align="left">常见误区</th><th align="left">实际影响</th><th align="left">优化策略</th></tr></thead><tbody><tr><td align="left"><strong>过度剥离（过度规划）</strong></td><td align="left">耗费大量时间在拆解本身，导致“拆解焦虑”</td><td align="left">遵循“JIT 剥离”，只对近期要做的任务进行深度拆解</td></tr><tr><td align="left"><strong>剥离逻辑断层</strong></td><td align="left">子任务完成后无法支撑父任务目标</td><td align="left">每一层剥离后进行“MECE 原则”校验（独立穷尽）</td></tr><tr><td align="left"><strong>忽略动态变化</strong></td><td align="left">剥离出的计划赶不上变化</td><td align="left">保持工具的灵活性，支持一键拖拽重组任务结构</td></tr></tbody></table><h3><strong>09 培育“以简御繁”的剥离文化</strong></h3><p>工具是骨架，思维是灵魂。企业与个人应鼓励：</p><ul><li><strong>清晰为先：</strong> 拒绝接受任何定义模糊的“巨石任务”，拆解不清晰不启动。</li><li><strong>最小切片：</strong> 鼓励将工作切片到最小，让进度每天可见，降低心理阻力。</li><li><strong>动态调整：</strong> 承认认知是递进的，允许在剥离过程中不断修正路径。</li></ul><h3><strong>10 结语：剥离是应对复杂世界的最高免疫力</strong></h3><p>在信息过载、任务爆炸的今天，靠蛮力解决问题的时代已经过去。<strong>递进式任务剥离工具</strong>不仅是效率辅助，更是人类应对复杂系统、重塑专注度的“外挂大脑”。</p><p>通过这种工具，我们可以将宏大的野心化作脚下坚实的台阶。当混乱被逻辑剥离，当压力被结构分担，组织的执行将不再是盲目的冲锋，而是一场优雅的精密推进。剥离不是为了增加复杂，而是为了在最深处的简单里，找到爆发的终极力量。</p>]]></description></item><item>    <title><![CDATA[026CRM系统盘点：6款CRM品牌核心能力横评，全链路竞争力解析 正直的炒饭 ]]></title>    <link>https://segmentfault.com/a/1190000047543888</link>    <guid>https://segmentfault.com/a/1190000047543888</guid>    <pubDate>2026-01-15 10:02:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在数字化转型背景下，CRM已从“客户信息管理工具”升级为“全链路业务协同平台”。企业选择CRM的核心诉求，是<strong>打通获客-销售-订单-物流-分析-上下游的全流程</strong>，实现效率提升与数据驱动。本文选取<strong>超兔一体云、Odoo CRM、Salesforce、有赞、探迹、Microsoft Dynamics 365</strong>六大主流品牌，从六个核心环节展开深度对比，结合专业工具（表格、流程图、脑图、雷达图）揭示各品牌的差异化竞争力。</p><h2>一、对比框架与品牌选择逻辑</h2><h3>1. 核心对比维度</h3><p>本次对比围绕CRM的<strong>全链路价值</strong>设计，覆盖企业最关注的六大环节：</p><ul><li><strong>获客</strong>：多渠道线索收集、精准性、成本归因；</li><li><strong>销售</strong>：流程可视化、AI辅助、团队协作；</li><li><strong>订单</strong>：多业务模型支持、全流程贯通；</li><li><strong>发货/物流</strong>：库存联动、物流可视化；</li><li><strong>统计分析</strong>：可视化、AI洞察、多维度；</li><li><strong>上下游</strong>：渠道打通、生态集成。</li></ul><h3>2. 品牌选择理由</h3><p>选取覆盖<strong>不同规模、行业、需求</strong>的代表性品牌：</p><ul><li>超兔一体云：中小微企业“全链路闭环”代表；</li><li>Odoo CRM：开源自定义，适合线索来源单一的企业；</li><li>Salesforce：AI驱动，中大型企业复杂销售首选；</li><li>有赞：零售私域运营专家；</li><li>探迹：电销型企业获客+销售协同工具；</li><li>Microsoft Dynamics 365：跨国企业CRM+ERP一体化解决方案。</li></ul><h2>二、六大环节深度对比</h2><ul><li><ul><li>*</li></ul></li></ul><h3>环节1：获客——从“广撒网”到“精准捕”</h3><p><strong>核心需求</strong>：多渠道覆盖、线索精准筛选、获客成本可追溯。 <strong>关键能力对比</strong>：</p><table><thead><tr><th>品牌</th><th>多渠道覆盖（百度/抖音/官网/微信/地推/工商）</th><th>线索评分（AI/规则）</th><th>获客成本归因</th><th>特色功能</th></tr></thead><tbody><tr><td>超兔一体云</td><td>✅全覆盖</td><td>✅规则+行为</td><td>✅活动→线索→签约</td><td>工商搜客、手机号验证码验真</td></tr><tr><td>Odoo CRM</td><td>✅（无工商搜客）</td><td>✅人口+行为</td><td>❌</td><td>400电话/邮件集成</td></tr><tr><td>Salesforce</td><td>✅（依赖Marketing Cloud）</td><td>✅Einstein AI</td><td>❌</td><td>客户旅程管理</td></tr><tr><td>有赞</td><td>✅（公域+私域）</td><td>✅AI导购行为分析</td><td>❌</td><td>280万导购赋能</td></tr><tr><td>探迹</td><td>✅（拓客+触达）</td><td>✅多维度模型</td><td>❌</td><td>智能外呼+企业信息自动补全</td></tr><tr><td>Microsoft Dynamics 365</td><td>✅（集成营销工具）</td><td>✅规则</td><td>❌</td><td>跨部门线索协同</td></tr></tbody></table><h4>深度解析：</h4><ul><li><strong>超兔一体云</strong>：获客能力最全面——不仅覆盖百度、抖音等公域，还支持微信海报、地推扫码、工商搜客（toB企业精准获客），且<strong>唯一实现“活动成本→线索→签约”的全链路归因</strong>，解决了企业“不知道钱花在哪”的痛点。</li><li><strong>Salesforce</strong>：依赖Marketing Cloud实现多渠道触达，Einstein AI通过“行为+属性”评分（如邮件打开、页面停留），精准识别高价值线索，但<strong>无成本归因</strong>，适合线索来源稳定的企业。</li><li><strong>有赞</strong>：聚焦零售私域，通过“AI生意专家+导购助手”将公域（抖音/微信）线索转化为私域会员，年增量生意超400亿，但<strong>缺乏toB企业需要的工商搜客</strong>。</li></ul><h4>超兔获客流程时序图（Mermaid）：</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543890" alt="" title=""/></p><pre><code>sequenceDiagram
    participant 市场部
    participant 超兔系统
    participant 销售部
    市场部-&gt;&gt;超兔系统: 配置百度广告、官网表单、微信海报
    超兔系统-&gt;&gt;超兔系统: 自动抓取线索（含手机号/IP归属地）
    超兔系统-&gt;&gt;超兔系统: 线索查重（客户名/手机号/自定义规则）
    超兔系统-&gt;&gt;超兔系统: 线索评分（行为+属性）
    超兔系统-&gt;&gt;销售部: 自动分配+消息提醒
    销售部-&gt;&gt;超兔系统: 处理线索（加客户/待办/转订单）
    超兔系统-&gt;&gt;市场部: 生成获客成本归因报表</code></pre><ul><li><ul><li>*</li></ul></li></ul><h3>环节2：销售——从“经验驱动”到“流程驱动”</h3><p><strong>核心需求</strong>：销售流程可视化、AI辅助决策、团队协同。 <strong>关键能力对比</strong>：</p><table><thead><tr><th>品牌</th><th>流程可视化（漏斗/看板）</th><th>AI辅助（预测/建议）</th><th>团队协作（共享/任务）</th><th>特色功能</th></tr></thead><tbody><tr><td>超兔一体云</td><td>✅（三一客/商机/多方项目）</td><td>✅自动日报/点点速记</td><td>✅分组隔离/多级客户</td><td>多方项目跟单（医院/高校）</td></tr><tr><td>Odoo CRM</td><td>✅（自定义漏斗）</td><td>✅自动化规则</td><td>✅拖放看板</td><td>全渠道沟通集成</td></tr><tr><td>Salesforce</td><td>✅（360°客户视图）</td><td>✅Einstein交易洞察</td><td>✅Chatter/Slack</td><td>赢单率分析/丢标原因复盘</td></tr><tr><td>有赞</td><td>✅（会员成长体系）</td><td>✅导购推荐</td><td>✅门店/线上协同</td><td>积分商城/营销卡券</td></tr><tr><td>探迹</td><td>✅（跟进记录看板）</td><td>✅智能外呼建议</td><td>✅目标管理/工作汇报</td><td>企业信息自动更新</td></tr><tr><td>Microsoft Dynamics 365</td><td>✅（ERP集成漏斗）</td><td>✅Power BI预测</td><td>✅Teams协同</td><td>跨国多语言/货币</td></tr></tbody></table><h4>深度解析：</h4><ul><li><strong>超兔一体云</strong>：销售能力最贴合<strong>复杂业务场景</strong>——独创“三一客”（小单快单）、“多方项目”（大型项目，如医院设备采购）、“分组隔离”（高校院系/医院科室）模型，解决了“多角色、多节点”的跟单痛点；<strong>自动日报</strong>（基于行动记录生成）和<strong>点点速记</strong>（快速录入跟进内容）大幅降低销售手工工作量。</li><li><strong>Salesforce</strong>：360°客户视图整合了“线索-账户-商机-联系记录”，Einstein AI能预测“赢单概率”“丢标原因”，适合中大型企业的复杂销售流程，但<strong>对中小微企业来说功能冗余</strong>。</li><li><strong>Microsoft Dynamics 365</strong>：依托Office/Teams生态，销售、服务、营销团队可实时共享客户信息，适合<strong>跨国企业的跨部门协同</strong>，但<strong>缺乏针对垂直行业的定制模型</strong>。</li></ul><h4>超兔销售流程脑图（Mermaid）：</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543891" alt="" title="" loading="lazy"/></p><pre><code>mindmap
    root((超兔销售核心能力))
        客户中心
            个性化配置（画像/布局/列表）
            生命周期管理（需求培养→成功）
            查重（客户名/手机号/自定义）
            背景调查（工商/天眼查/微信头像）
        跟单中心
            小单快单（三一客：三定+关键节点）
            中长单（商机阶段/预期日期）
            大型项目（多方项目：项目组+合同+采购）
            通用能力（360°视图/自动日报/电话录音AI）</code></pre><ul><li><ul><li>*</li></ul></li></ul><h3>环节3：订单——从“生成”到“全流程管控”</h3><p><strong>核心需求</strong>：支持多业务模型（实物/服务/租赁/套餐）、订单与财务/库存联动。 <strong>关键能力对比</strong>：</p><table><thead><tr><th>品牌</th><th>实物订单（标准/批发/定制/套餐）</th><th>服务订单（维修/外勤）</th><th>应收管控（触发/关联）</th><th>特色功能</th></tr></thead><tbody><tr><td>超兔一体云</td><td>✅全支持</td><td>✅维修/外勤工单</td><td>✅签约/开票/发货触发</td><td>租售一体单/爆炸图下单</td></tr><tr><td>Odoo CRM</td><td>✅（无租赁/套餐）</td><td>❌</td><td>✅跨模块同步</td><td>订单→仓库一键同步</td></tr><tr><td>Salesforce</td><td>✅（Commerce Cloud）</td><td>✅（依赖Service Cloud）</td><td>✅订单→生产联动</td><td>定制化订单（如Cloud Kicks运动鞋）</td></tr><tr><td>有赞</td><td>✅（零售套餐）</td><td>❌</td><td>✅灰产拦截</td><td>会员专属订单</td></tr><tr><td>探迹</td><td>✅（标准订单）</td><td>❌</td><td>✅电子合同/回款对账</td><td>每笔回款自动关联合同</td></tr><tr><td>Microsoft Dynamics 365</td><td>✅（制造业模板）</td><td>✅（工程行业）</td><td>✅CRM+ERP一体化</td><td>供应链订单协同</td></tr></tbody></table><h4>深度解析：</h4><ul><li><strong>超兔一体云</strong>：订单能力<strong>覆盖最多业务场景</strong>——从实物（标准/批发/定制）到服务（维修/外勤），再到特殊订单（租售一体、爆炸图下单），甚至支持“逐级速建订单”（如建材行业的“产品→配件→安装”套餐）；<strong>应收管控</strong>可设置“签约/开票/发货”触发规则，自动拆分多期应收，解决了“应收账款混乱”的痛点。</li><li><strong>Microsoft Dynamics 365</strong>：依托ERP集成，订单可直接联动供应链（生产/采购/库存），适合<strong>制造业/工程行业</strong>的“订单→生产→交付”全流程管理，但<strong>零售类的“套餐/租赁”订单支持不足</strong>。</li><li><strong>探迹</strong>：聚焦“在线签约+回款对账”，每笔回款自动生成流水并关联合同，适合<strong>电销型企业的“订单→收款”快速闭环</strong>。</li><li><ul><li>*</li></ul></li></ul><h3>环节4：发货/物流——从“被动等”到“主动追”</h3><p><strong>核心需求</strong>：库存与订单联动、物流状态可视化。 <strong>关键能力对比</strong>：</p><table><thead><tr><th>品牌</th><th>多仓库管理（≤500个）</th><th>库存预警（上下限/锁库）</th><th>物流跟踪（实时/扫码）</th><th>特色功能</th></tr></thead><tbody><tr><td>超兔一体云</td><td>✅</td><td>✅（序列号/货架/库位）</td><td>✅OpenCRM协同</td><td>手机拣货/扫码出入库</td></tr><tr><td>Odoo CRM</td><td>✅（≤100个）</td><td>✅（多库位）</td><td>✅第三方物流集成</td><td>库存台账/流水管理</td></tr><tr><td>Salesforce</td><td>❌（依赖ERP）</td><td>❌</td><td>✅MuleSoft集成</td><td>客户实时查询配送进度</td></tr><tr><td>有赞</td><td>❌</td><td>❌</td><td>❌</td><td>—</td></tr><tr><td>探迹</td><td>❌</td><td>❌</td><td>❌</td><td>—</td></tr><tr><td>Microsoft Dynamics 365</td><td>✅（ERP供应链）</td><td>✅（预测库存）</td><td>✅供应链跟踪</td><td>跨国物流协同</td></tr></tbody></table><h4>深度解析：</h4><ul><li><strong>超兔一体云</strong>：物流能力最贴合<strong>中小微企业的仓库管理需求</strong>——支持500个仓库、序列号出入库、库存上下限预警，通过<strong>OpenCRM</strong>可让客户“扫码签收”并实时查看物流状态，解决了“发货后无法跟踪”的痛点。</li><li><strong>Microsoft Dynamics 365</strong>：依托ERP的供应链管理，可跟踪“订单→生产→物流”全链路，适合<strong>跨国企业的全球库存协同</strong>，但<strong>对中小微企业来说成本过高</strong>。</li><li><strong>Salesforce</strong>：需通过MuleSoft或AppExchange集成第三方物流系统，灵活性高但<strong>缺乏原生库存管理功能</strong>。</li><li><ul><li>*</li></ul></li></ul><h3>环节5：统计分析——从“数据”到“决策”</h3><p><strong>核心需求</strong>：可视化报表、AI自动洞察、多维度切片。 <strong>关键能力对比</strong>：</p><table><thead><tr><th>品牌</th><th>可视化（数字卡片/图表）</th><th>AI洞察（自动结论）</th><th>多维度分析（来源/阶段/团队）</th><th>特色功能</th></tr></thead><tbody><tr><td>超兔一体云</td><td>✅（数字卡片/同比环比）</td><td>✅多表聚合/单日KPI</td><td>✅获客/销售/订单/物流</td><td>自定义仪表盘</td></tr><tr><td>Odoo CRM</td><td>✅（BI/数据透视表）</td><td>❌</td><td>✅商机来源/销售小组</td><td>拖放式分析</td></tr><tr><td>Salesforce</td><td>✅（Tableau/Analytics Cloud）</td><td>✅Einstein自动结论</td><td>✅销售趋势/营销ROI</td><td>实时仪表盘</td></tr><tr><td>有赞</td><td>✅（客户资产报表）</td><td>✅智能标签（行为）</td><td>✅会员行为/导购业绩</td><td>口碑分析（2025新增）</td></tr><tr><td>探迹</td><td>✅（基础报表）</td><td>✅智能客户评级</td><td>✅获客来源/跟进效率</td><td>多维度评级模型</td></tr><tr><td>Microsoft Dynamics 365</td><td>✅（Power BI）</td><td>✅企业级BI</td><td>✅跨国多维度</td><td>数据驱动决策</td></tr></tbody></table><h4>深度解析：</h4><ul><li><strong>Salesforce</strong>：分析能力最强大——通过Tableau集成实现“可视化报表+实时仪表盘”，Einstein AI能自动生成“销售目标达成率”“营销活动效果”等结论，适合<strong>中大型企业的战略决策</strong>。</li><li><strong>超兔一体云</strong>：分析能力最贴合<strong>中小微企业的“实用主义”</strong> ——数字卡片（如“今日新增线索”“本月签约金额”）、同比环比（如“本月获客量 vs 上月”）、多表聚合（如“获客渠道→销售业绩”），无需复杂操作即可获取关键信息。</li><li><strong>有赞</strong>：聚焦<strong>零售客户的行为分析</strong>——智能标签（基于点击/浏览/购买行为）和口碑分析（2025新增），帮助商家理解“客户为什么买”“为什么流失”。</li><li><ul><li>*</li></ul></li></ul><h3>环节6：上下游——从“内部闭环”到“生态协同”</h3><p><strong>核心需求</strong>：打通客户/供应商/渠道，实现信息共享。 <strong>关键能力对比</strong>：</p><table><thead><tr><th>品牌</th><th>客户协同（确认报价/订单/验收）</th><th>供应商协同（询比价/采购）</th><th>生态集成（第三方工具）</th><th>特色功能</th></tr></thead><tbody><tr><td>超兔一体云</td><td>✅（网页/小程序确认）</td><td>✅智能采购（自动算量/拆分）</td><td>✅OpenCRM平台</td><td>上下游全流程协同</td></tr><tr><td>Odoo CRM</td><td>✅（邮件确认）</td><td>✅采购单集成</td><td>✅开源插件</td><td>跨模块数据共享</td></tr><tr><td>Salesforce</td><td>✅（Community Cloud）</td><td>✅MuleSoft连接</td><td>✅AppExchange</td><td>合作伙伴社区</td></tr><tr><td>有赞</td><td>✅（私域渠道确认）</td><td>❌</td><td>✅微信/抖音集成</td><td>导购与客户协同</td></tr><tr><td>探迹</td><td>✅（电子合同确认）</td><td>✅询盘响应</td><td>✅API对接</td><td>客户与销售协同</td></tr><tr><td>Microsoft Dynamics 365</td><td>✅（跨国客户确认）</td><td>✅供应链协同</td><td>✅Office/Teams</td><td>跨国生态集成</td></tr></tbody></table><h4>深度解析：</h4><ul><li><strong>超兔一体云</strong>：上下游能力最聚焦“业务协同”——通过OpenCRM平台，企业可与客户“共享报价单/订单/验收单”，与供应商“询比价/自动拆分采购单”，解决了“上下游沟通靠邮件/微信”的低效问题。</li><li><strong>Salesforce</strong>：Community Cloud构建了“企业-客户-合作伙伴”的协作社区，适合<strong>中大型企业的生态管理</strong>，但<strong>对中小微企业来说功能过重</strong>。</li><li><strong>Microsoft Dynamics 365</strong>：依托Office/Teams生态，上下游合作伙伴可实时共享“订单/库存/物流”信息，适合<strong>跨国企业的全球协同</strong>。</li><li><ul><li>*</li></ul></li></ul><h2>三、综合竞争力雷达图（10分制）</h2><table><thead><tr><th>品牌</th><th>获客</th><th>销售</th><th>订单</th><th>物流</th><th>分析</th><th>上下游</th><th>综合得分</th></tr></thead><tbody><tr><td>超兔一体云</td><td>9</td><td>9</td><td>8</td><td>7</td><td>8</td><td>8</td><td>59</td></tr><tr><td>Odoo CRM</td><td>7</td><td>8</td><td>8</td><td>7</td><td>8</td><td>7</td><td>53</td></tr><tr><td>Salesforce</td><td>8</td><td>9</td><td>9</td><td>8</td><td>10</td><td>9</td><td>63</td></tr><tr><td>有赞</td><td>9</td><td>8</td><td>7</td><td>6</td><td>8</td><td>8</td><td>56</td></tr><tr><td>探迹</td><td>8</td><td>8</td><td>7</td><td>6</td><td>7</td><td>7</td><td>43</td></tr></tbody></table><p>综上所述，不同的CRM系统在获客、销售、订单、发货/物流、统计分析以及上下游协同等环节各有优劣。企业在选择CRM系统时，应根据自身的规模、行业特点、业务需求以及预算等因素进行综合考虑。</p><p>对于中小微企业而言，超兔一体云提供了全面且贴合实际业务场景的解决方案，在各个环节都有出色的表现，尤其是在获客成本归因、复杂业务销售流程以及多业务场景订单管理方面优势明显，是“全链路闭环”的优质选择。</p><p>Odoo CRM以其开源自定义的特点，适合线索来源单一且有一定技术能力进行定制开发的企业。</p><p>Salesforce凭借强大的AI驱动能力和丰富的功能，在中大型企业复杂销售流程管理和数据分析方面表现卓越，但对于中小微企业可能存在功能冗余的问题。</p><p>有赞专注于零售私域运营，在零售行业的线索转化、会员管理和客户分析方面具有独特优势。</p><p>探迹则是电销型企业获客和销售协同的得力工具，在订单和回款管理方面较为高效。</p><p>Microsoft Dynamics 365依托Office/Teams生态，为跨国企业提供了跨部门协同和全球供应链管理的一体化解决方案，但对于垂直行业的定制模型有所欠缺。</p><p>企业应充分评估自身需求，结合各品牌的特点，选择最适合自己的CRM系统，以提升业务运营效率和竞争力，实现数字化转型的目标。</p><p>（注：文中功能相关描述均基于公开披露信息，具体功能服务以厂商实际落地版本为准。）</p>]]></description></item><item>    <title><![CDATA[2026团队高效协作引擎：可设置自动化规则的看板工具选型与实战指南 Zoey的笔记本 ]]></title>    <link>https://segmentfault.com/a/1190000047543902</link>    <guid>https://segmentfault.com/a/1190000047543902</guid>    <pubDate>2026-01-15 10:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>简介：在快节奏的项目管理中，任务状态更新不及时、重复性操作繁琐以及信息同步延迟是团队协作的主要内耗来源。本文聚焦看板工具的核心进阶能力——<strong>自动化规则</strong>，通过横向测评4款主流工具，剖析其如何将项目管理从“人驱动”转变为“规则驱动”，从而系统性提升团队效率。</p><p>看板工具已成为项目管理的可视化核心，但静态的看板仍依赖大量人工操作：任务完成后需手动拖拽、截止日前需人工提醒、新需求录入后需手动分配…… 据2025年的一项项目管理调研，<strong>超过68%的团队表示“状态更新与流程推进”耗费了不成比例的管理精力</strong>。而支持<strong>自动化规则</strong>的看板工具，能够通过预设的“如果-那么”逻辑，自动执行状态流转、通知分发、字段更新等操作，将管理者从重复劳动中解放出来。</p><p>本文将深入解析<strong>可设置自动化规则的看板工具</strong>如何解决协作流程中的关键瓶颈，并从“<strong>规则灵活性</strong>”、“<strong>触发事件丰富度</strong>”和“<strong>与外部工具集成能力</strong>”三个维度，对比测评4款代表性工具，帮助团队选择最适合自己的“流程自动化引擎”。</p><h2>一、流程自动化的3大核心场景与选型维度</h2><p>引入自动化规则的目的并非追求技术上的复杂，而是要精准解决那些消耗团队注意力的高频、低价值操作。以下三个场景最典型：</p><p>▫️ <strong>状态流转自动化：减少手动拖拽</strong><br/>任务完成后，需成员手动将卡片拖至“已完成”列，易遗忘或延迟；跨部门协作时，任务进入某一阶段（如“开发完成”）后，无法自动通知测试团队，导致等待空档。</p><p>▪️ <strong>信息同步与提醒自动化：确保关键信息不遗漏</strong><br/>任务临近截止日期或逾期时，依赖项目经理人工检查并逐一提醒；卡片内容（如优先级、负责人）变更后，相关干系人无法及时获知，影响协同决策。</p><p>• <strong>任务创建与分配自动化：标准化流程入口</strong><br/>客户通过表单提交需求后，需人工将其整理为看板任务，并手动分配负责人；每次迭代规划时，需要手动复制创建一批结构类似的任务卡片，过程枯燥易错。</p><p>因此，在选择支持自动化的看板工具时，应重点评估以下三个维度：</p><ol><li><strong>规则构建的灵活性与门槛</strong>：是否提供直观的图形化规则构建器？是否支持基于复杂条件（多个“且/或”逻辑）触发动作？这对业务人员能否自行维护规则至关重要。</li><li><strong>触发事件与执行动作的丰富度</strong>：除卡片移动外，能否在规则中触发Webhook、发送自定义邮件、修改任意自定义字段？这决定了自动化的覆盖范围和深度。</li><li><strong>生态集成与数据互通能力</strong>：能否轻松监听来自Git提交、表单工具、客服系统的外部事件？能否将动作执行到外部日历、通讯工具？这决定了自动化能否成为连接各类SaaS的枢纽。</li></ol><h2>二、4款支持自动化规则的看板工具核心参数对比</h2><p>为清晰呈现各工具差异，以下表格从核心自动化能力角度进行对比：</p><table><thead><tr><th align="left">工具名称</th><th align="left">核心定位</th><th align="left">自动化核心功能特点</th><th align="left">规则配置方式</th><th align="left">集成能力</th><th align="left">适用团队规模</th><th align="left">核心短板</th></tr></thead><tbody><tr><td align="left"><strong>板栗看板</strong></td><td align="left">面向敏捷团队的整合型看板</td><td align="left"><strong>规则可视化配置</strong>，支持“当卡片被移动至某列时，则为其添加标签并@负责人”；<strong>内置丰富的项目模板</strong>（如Bug处理流），开箱即用。</td><td align="left">图形化界面（无代码）</td><td align="left">支持主流Webhook接入与触发，内置部分第三方应用连接</td><td align="left">5-50人敏捷团队</td><td align="left">超大型项目群（100人以上）的跨看板复杂规则支持较弱</td></tr><tr><td align="left"><strong>Trello</strong></td><td align="left">极简灵活的通用看板工具</td><td align="left">通过 <strong>“Butler”</strong> 功能提供自动化，支持基于日期、成员动作等触发，语法接近自然语言（如“when a card is moved to Done, archive it”）。</td><td align="left">自然语言命令或图形化按钮</td><td align="left">通过Power-Ups连接大量外部服务（如Slack, Google Drive）</td><td align="left">小型到中型协作团队</td><td align="left">高级自动化功能需付费，复杂逻辑配置略显繁琐</td></tr><tr><td align="left"><strong>Jira Software</strong></td><td align="left">专业的敏捷开发与项目管理工具</td><td align="left"><strong>“自动化规则”</strong> 为Jira原生功能，深度绑定Issue类型与工作流，可针对Sprint周期、代码提交等开发场景设置精细规则。</td><td align="left">图形化模板与自定义规则</td><td align="left">与整个Atlassian生态（Confluence, Bitbucket）及CI/CD工具无缝集成</td><td align="left">中大型技术开发团队</td><td align="left">对于非开发团队过于复杂，配置需管理员权限</td></tr><tr><td align="left"><strong>ClickUp</strong></td><td align="left">一体化生产力平台</td><td align="left"><strong>“自动化”</strong> 视图清晰，提供大量预制模板。特色在于可将自动化与目标（Goals）、文档（Docs）等模块联动。</td><td align="left">点击式可视化构建器</td><td align="left">支持超过1000种工具集成，内置Chatbot</td><td align="left">各类规模团队，尤其适合追求一体化的团队</td><td align="left">功能过于庞杂，需要时间梳理以最佳实践应用自动化</td></tr></tbody></table><h3>（一）板栗看板：敏捷团队的开箱即用自动化方案</h3><p>作为一款深度适配敏捷研发流程的看板工具，其自动化设计的核心是 <strong>“降低规则配置门槛”</strong> 与 <strong>“贴合常见研发场景”</strong>。</p><h4>1. 快速配置一条自动化规则（示例：自动化Bug处理流程）</h4><p>在板栗看板中，可通过图形界面快速配置以下规则，无需代码：</p><pre><code class="plaintext">触发条件：当 [卡片类型] 为 “Bug” 且 [优先级] 为 “高” 的卡片被移动至 [待处理] 列时
执行动作：
1. 自动将卡片 [负责人] 设置为 “技术主管-张三”
2. 自动为卡片添加 “紧急” 标签
3. 自动在卡片评论中@张三并留言：“有新的高优先级Bug待处理，请及时查看。”</code></pre><p>此规则确保了高优先级的Bug一旦被提交，就能立即路由给正确的负责人并引起其注意。</p><h4>2. 核心场景适配：Sprint任务自动归档</h4><p>在Sprint结束时，自动化可以批量处理收尾工作：</p><pre><code class="plaintext">触发条件：当 [迭代看板] 上的 [Sprint状态] 被标记为 “已结束” 时
执行动作：
1. 对于所有仍位于 [进行中] 列的卡片，自动添加 “[未完成]” 标签
2. 将所有 [已完成] 列的卡片批量移动至 [发布归档] 看板
3. 向频道“项目周报”发送一条通知：“Sprint #15 已结束，共完成XX个任务。”</code></pre><h3>（二）Trello：利用Butler实现轻量自动化</h3><p>Trello的自动化通过Butler实现，适合希望以简单命令快速上手的团队。</p><pre><code class="plaintext">// Butler规则示例：自动处理逾期任务
规则描述：每天上午9点检查所有卡片，如果截止日期是昨天且未完成，则将其移动到“逾期”列，并@负责人。
近似Butler命令：
when due date is past, move the card to list "Overdue" and mention the card's members.</code></pre><p><strong>适配场景</strong>：适合管理内容日历、简单任务跟踪等个人或轻协作看板，通过自然语言快速设置提醒和归档规则。</p><h3>（三）Jira Software：服务于敏捷开发生命周期的自动化</h3><p>Jira的自动化深度集成于其工作流和权限体系中，为开发团队量身定制。</p><pre><code class="plaintext">// 自动化规则示例：关联代码提交与任务状态
触发条件：当关联的Git分支上有新的提交推送至仓库时
执行动作：
1. 自动将对应的Jira任务状态从“进行中”推进至“代码审查中”
2. 在任务评论区自动记录本次提交的哈希值和提交信息
3. 通知“审查人”字段中指定的用户</code></pre><p><strong>适配场景</strong>：严格遵循Scrum或Kanban的软件开发团队，需要实现开发活动与项目管理状态自动同步。</p><h3>（四）ClickUp：连接广泛模块的一体化自动化</h3><p>ClickUp的自动化旨在打通其平台内的各个功能孤岛。</p><pre><code class="plaintext">// 自动化规则示例：将任务完成与目标进度同步
触发条件：当位于 [本季度目标] 空间下的某个 [任务] 被标记为完成时
执行动作：
1. 自动查找并关联的 [目标]（OKR）
2. 将该 [目标] 的进度数值自动增加相应的百分比
3. 如果 [目标] 进度达到100%，则自动将其状态标记为“已完成”并通知目标负责人</code></pre><p><strong>适配场景</strong>：希望将日常任务执行与公司、团队级目标（OKR）动态关联起来的组织。</p><h2>三、团队选型决策框架与实践指南</h2><h3>自动化规则部署避坑指南</h3><ul><li><strong>避免过度自动化</strong>：初期规则不宜超过5条，应从痛点最明显的场景开始。过度自动化会让看板变得“不可预测”，反增维护成本。</li><li><strong>设置异常处理机制</strong>：在关键自动化规则中（如自动归档），应考虑设置“安全检查点”，例如“自动移动前，如果卡片有‘阻塞’标签则停止并通知”。</li><li><strong>定期审计与优化</strong>：每季度回顾一次自动化规则的运行日志，查看是否有规则从未触发或频繁误触发，根据实际业务变化进行调整。</li></ul><h2>结语</h2><p>选择一款<strong>可设置自动化规则的看板工具</strong>，其本质是为团队协作引入一个不知疲倦的“流程助手”。</p><p>最终，工具的成功不在于规则的多少，而在于其是否精准地<strong>消除了沉默成本最高的那部分协作摩擦</strong>。从一两条简单的自动化开始，让团队先感受到“机器代劳”的顺畅，再逐步深化，是走向高效协作的稳健路径。</p><p><strong>相关实践建议</strong>：在正式全团队推广前，可先选择一个试点项目组，用2-3周时间验证核心自动化规则的有效性，收集反馈并微调，这将极大提高最终落地的成功率。</p>]]></description></item><item>    <title><![CDATA[剑指offer-64、滑动窗⼝的最⼤值 SevenCoding ]]></title>    <link>https://segmentfault.com/a/1190000047536299</link>    <guid>https://segmentfault.com/a/1190000047536299</guid>    <pubDate>2026-01-15 09:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>题⽬描述</h2><p>给定⼀个数组和滑动窗⼝的⼤⼩，找出所有滑动窗⼝⾥数值的最⼤值。例如，如果输⼊数组 {2,3,4,2,6,2,5,1} 及滑动窗⼝的⼤⼩ 3 ，那么⼀共存在 6 个滑动窗⼝，他们的最⼤值分别为 {4,4,6,6,6,5} ； </p><p>针对数组 {2,3,4,2,6,2,5,1} 的滑动窗⼝有以下6个： {[2,3,4],2,6,2,5,1} ， {2,[3,4,2],6,2,5,1} ， {2,3,[4,2,6],2,5,1} ， {2,3,4, [2,6,2],5,1} ， {2,3,4,2,[6,2,5],1} ， {2,3,4,2,6,[2,5,1]} 。 窗⼝⼤于数组⻓度的时候，返回空。</p><h2>思路及解答</h2><h3>暴力法</h3><p>遍历每个可能的窗口起始位置，计算窗口内的最大值</p><pre><code class="java">public class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 处理边界情况
        if (nums == null || nums.length == 0 || k &lt;= 0 || k &gt; nums.length) {
            return new int[0];
        }
        
        int n = nums.length;
        int[] result = new int[n - k + 1]; // 结果数组
        
        // 遍历每个窗口的起始位置
        for (int i = 0; i &lt;= n - k; i++) {
            int max = Integer.MIN_VALUE;
            
            // 计算当前窗口内的最大值
            for (int j = i; j &lt; i + k; j++) {
                if (nums[j] &gt; max) {
                    max = nums[j];
                }
            }
            result[i] = max;
        }
        
        return result;
    }
}</code></pre><ul><li><strong>时间复杂度</strong>：O(n×k)，需要处理n-k+1个窗口，每个窗口需要k次比较</li><li><strong>空间复杂度</strong>：O(1)，除结果数组外只使用常数空间</li></ul><h3>双端队列法（最优解）</h3><p>⾸先进⾏⾮空判断，以及数组⻓度是否不为 0 ，是否不⼩于窗⼝⻓度。</p><p>其次，使⽤⼀个双向链表，⾥⾯保存的是索引，遍历每⼀个元素，如果双向队列不为空且最后的元素作为索引的数值⼩于当前的元素，就把当前的元素的索引加到队列的后⾯。（这样可以保证队列从头到尾是单调递减的，也就是队尾的元素就是最⼩的元素）。</p><p>然后把当前的元素加进去队列尾部。判断队列前⾯的元素是不是索引位置不符合，如果不符合，就移除队列头部的元素。</p><p>那么此时的队列⾸部肯定就是滑动窗⼝的最⼤值。（此处应该判断滑动窗⼝⽣效的索引）</p><p>以 2, 3, 4, 2, 6, 2, 5, 1 为例：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536301" alt="" title=""/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536302" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536303" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047536304" alt="" title="" loading="lazy"/></p><p>所有的窗⼝最⼤值⾄此已经收集完成。</p><pre><code class="java">public class Solution64 {
     public static void main(String[] args) {
         int[] nums = {2, 3, 4, 2, 6, 2, 5, 1};
         System.out.println(new Solution64().maxInWindows(nums, 3));
     }
    
     public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) {
         ArrayList&lt;Integer&gt; results = new ArrayList&lt;&gt;();
         if (num == null || num.length == 0 || num.length &lt; size || size &lt;= 0) {
             return results;
         }
         
         LinkedList&lt;Integer&gt; integers = new LinkedList&lt;&gt;();
         for (int i = 0; i &lt; num.length; i++) {
             while (!integers.isEmpty() &amp;&amp; num[integers.peekLast()] &lt; num[i]) {
                 integers.removeLast();
             }
             integers.addLast(i);
             while (i - integers.peekFirst() &gt;= size) {
                 integers.removeFirst();
             }
             if (i &gt;= size - 1) {
                 results.add(num[integers.peekFirst()]);
             }
         }
         return results;
     }
}</code></pre><ul><li>时间复杂度：O（n）,所有的元素都进⼊队列，再出队列</li><li>空间复杂度：O(n)，使⽤额外的队列空间存储索引以及窗⼝最⼤值。</li></ul><h3>动态规划法（分块思想）</h3><p>将数组分成大小为k的块，预处理每个位置的左右最大值</p><p><strong>分块思想：</strong></p><ul><li>将数组划分为大小为k的块（最后一块可能不满）</li><li><code>left[i]</code>：从当前块开始到位置i的最大值</li><li><code>right[i]</code>：从位置i到当前块结束的最大值</li></ul><p><strong>窗口最大值计算：</strong></p><p>对于窗口[i, i+k-1]：</p><ul><li>如果窗口完全在一个块内：<code>right[i]</code>或<code>left[i+k-1]</code>就是最大值</li><li>如果窗口跨越两个块：最大值 = max(右块的左最大值, 左块的右最大值)</li></ul><pre><code class="java">public class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0 || k &lt;= 0) {
            return new int[0];
        }
        
        int n = nums.length;
        if (k == 1) return nums; // 窗口大小为1，直接返回原数组
        
        int[] left = new int[n];  // 从左到右的块最大值
        int[] right = new int[n]; // 从右到左的块最大值
        int[] result = new int[n - k + 1];
        
        // 构建left数组：从左到右的块内最大值
        left[0] = nums[0];
        for (int i = 1; i &lt; n; i++) {
            if (i % k == 0) {
                // 块的首元素，重新开始计算
                left[i] = nums[i];
            } else {
                // 与前一个位置比较取最大值
                left[i] = Math.max(left[i - 1], nums[i]);
            }
        }
        
        // 构建right数组：从右到左的块内最大值
        right[n - 1] = nums[n - 1];
        for (int i = n - 2; i &gt;= 0; i--) {
            if ((i + 1) % k == 0) {
                // 块的尾元素，重新开始计算
                right[i] = nums[i];
            } else {
                // 与后一个位置比较取最大值
                right[i] = Math.max(right[i + 1], nums[i]);
            }
        }
        
        // 计算每个窗口的最大值
        for (int i = 0; i &lt;= n - k; i++) {
            // 窗口最大值 = max(右端点的左最大值, 左端点的右最大值)
            result[i] = Math.max(right[i], left[i + k - 1]);
        }
        
        return result;
    }
}</code></pre><p><strong>算法分析：</strong></p><ul><li><strong>时间复杂度</strong>：O(n)，三次线性遍历</li><li><strong>空间复杂度</strong>：O(n)，需要两个辅助数组</li></ul>]]></description></item><item>    <title><![CDATA[UniApp × HarmonyOS 实战指南：从零完成鸿蒙真机/模拟器运行（实战避坑版） 逐梦AI]]></title>    <link>https://segmentfault.com/a/1190000047543738</link>    <guid>https://segmentfault.com/a/1190000047543738</guid>    <pubDate>2026-01-15 02:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>UniApp × HarmonyOS 实战指南：从零完成鸿蒙真机/模拟器运行（实战避坑版）</h2><p>随着 HarmonyOS 生态的逐步成熟，鸿蒙应用开发正从“尝鲜阶段”走向“实际落地阶段”。对于已有 uni-app 技术栈的开发者而言，如何在尽量复用现有代码的前提下，快速将项目运行到鸿蒙系统上，成为当前非常现实的问题。然而在实际操作过程中，官方文档分散、工具链较新、环境依赖复杂，往往会让初次接触的开发者在配置阶段频繁踩坑。</p><p>本文将基于一次完整、可复现的实战过程，详细记录 uni-app 在 HarmonyOS 环境下的开发、配置与运行全流程，从环境准备、工具关联、鸿蒙离线 SDK 配置，到最终在模拟器或真机中成功运行项目，逐步拆解关键步骤与注意事项，帮助你少走弯路，更快打通 uni-app 到鸿蒙的完整开发链路。</p><h3>一、环境与工具准备（务必先确认）</h3><p>在正式动手前，请务必确认以下开发环境均已就绪，否则后续步骤会频繁报错。</p><h4>1. 官方文档与工具版本要求</h4><ul><li>uni-app 鸿蒙官方文档<br/>👉 <a href="https://link.segmentfault.com/?enc=LPnTXZWJgPkukZjRkDPf8g%3D%3D.PJVSsM0ZbjScw7D8cJE2wb1rdh0daaHZT3%2BNMoHXR8UV0Y3M4Xj97OHpX7485N1pG5agzpGLI5pUuAH9ymJPJQ%3D%3D" rel="nofollow" target="_blank">https://uniapp.dcloud.net.cn/tutorial/harmony/dev.html</a></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543673" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><ul><li>DevEco Studio<br/>下载地址：<br/>  👉 <a href="https://link.segmentfault.com/?enc=qGjz5b3uREkhDkFPC%2B7rdw%3D%3D.pnweNg0b4LvTjtLsVbtc6KFbviCNAe5qOgDMJyYf8vDQ57nYWeuCRK2Y2s2ivi7fZ%2B%2BL7tHHPWeCna4gFr0OTw%3D%3D" rel="nofollow" target="_blank">https://developer.huawei.com/consumer/cn/download/</a></li><li>HarmonyOS 系统版本<br/> DevEco Studio 内置鸿蒙模拟器，无需单独安装</li><li>HBuilderX</li></ul><h4>2. Windows 模拟器运行前置条件（非常关键）</h4><p>如果你计划使用 <strong>鸿蒙模拟器</strong>，Windows 需要开启虚拟化相关功能：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543674" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>路径：<br/><code>控制面板 → 程序与功能 → 启用或关闭 Windows 功能</code></p><p>请勾选以下三项：</p><ul><li>Hyper-V</li><li>Windows 虚拟机监控程序平台</li><li>虚拟机平台</li></ul><p>⚠️ 注意事项：</p><ul><li><strong>仅 Win10 专业版 / Win11 专业版支持</strong></li><li>家庭版需先升级至专业版或企业版</li></ul><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543675" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543676" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>二、HBuilderX 与 DevEco Studio 关联配置</h3><p>HBuilderX 需要知道 DevEco Studio 的安装位置，才能正确调用鸿蒙构建工具链。</p><h4>1. 打开配置入口</h4><p>在 HBuilderX 中依次进入：</p><blockquote>工具 → 设置 → 源码视图 → 用户设置<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543677" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></blockquote><h4>2. 配置 DevEco Studio 路径</h4><p>找到或新增如下配置项：</p><pre><code class="json">"harmony.devTools.path": "D:/Huawei/DevEco Studio"</code></pre><p>说明：</p><ul><li>填写 <strong>DevEco Studio 的安装根目录</strong></li><li>不需要写到 exe 文件，只需到上一级目录即可</li></ul><p>示例说明：<br/>若启动文件路径为<br/><code>D:\Huawei\DevEco Studio\bin\devecostudio64.exe</code><br/>则配置为<br/><code>D:/Huawei/DevEco Studio</code></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543678" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><hr/><h3>三、配置 uni-app 鸿蒙离线 SDK（核心步骤）</h3><p>⚠️ 这一部分是<strong>最容易出问题</strong>的地方，请严格按照步骤操作。</p><h4>1. 下载鸿蒙离线 SDK</h4><p>SDK 由 uni-app 官方提供：</p><ul><li>当前示例版本：<code>template-1.3.4.tgz</code></li><li>下载地址：<br/>👉 <a href="https://link.segmentfault.com/?enc=6IM5ns2LHeqsnCrQRUJBtQ%3D%3D.Bz52mDMNFLOws6%2BKpEv7DW%2F3fkFomuVmklXYnPjEO7895%2FPBQpto6snylj4UW3nTqmayYF2b0p8f6mFSop%2FdEZRduo9LJVA4pXYREJF7FhQ%3D" rel="nofollow" target="_blank">https://web-ext-storage.dcloud.net.cn/uni-app/harmony/zip/template-1.3.4.tgz</a></li></ul><h4>2. 解压并规划 SDK 存放方式（重点理解）</h4><blockquote>鸿蒙目前 <strong>没有“基座”概念</strong><br/><strong>多个 uni-app 项目不能共用同一个离线 SDK</strong></blockquote><p>推荐做法：</p><ul><li>单独创建一个 SDK 管理目录<br/>例如：</li></ul><pre><code>HBuilderProjects\uniharmonysdk</code></pre><ul><li><p>每创建一个 uni-app 项目：</p><ul><li>复制一份 <code>package</code></li><li>重命名为当前项目名</li></ul></li></ul><p>这样可以避免 <strong>manifest.json 冲突</strong> 问题。</p><p>示例目录结构：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543679" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><hr/><h4>3. 使用 DevEco Studio 打开离线 SDK 工程</h4><p>在 DevEco Studio 中：</p><ul><li>直接打开刚刚解压并重命名后的工程目录</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543680" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><hr/><h4>4. 同步工程并运行测试</h4><ul><li>等待 Gradle / Sync 自动完成</li><li><p>点击运行按钮，可选择：</p><ul><li>鸿蒙模拟器</li><li>鸿蒙真机</li></ul></li></ul><p>⚠️ 若首次运行失败，通常是 <strong>签名或账号未配置</strong></p><h5>登录华为开发者账号</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543681" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h5>创建鸿蒙模拟器</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543682" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543683" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543684" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543685" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543686" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543687" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><hr/><h4>5. 配置应用签名（必须）</h4><p>进入签名配置界面：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543688" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><ul><li>测试阶段可直接使用 <strong>当前华为账号生成签名</strong></li><li>无需购买证书</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543689" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><hr/><h3>四、uni-app 项目创建与最终运行</h3><p>前面的步骤完成后，说明 <strong>鸿蒙构建环境已经准备就绪</strong>，接下来只差 uni-app 项目本身。</p><h4>1. 创建 uni-app 项目</h4><p>在 HBuilderX 中：</p><ul><li>新建项目</li><li><p>模板选择：</p><ul><li>Vue3</li><li>可选 <code>uni-ui</code> 模板（本文示例）<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543690" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543691" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543692" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h4>2. 绑定鸿蒙离线 SDK</h4><p>打开项目中的 <code>manifest.json</code>，配置：</p><pre><code class="json">"app-harmony": {
  "projectPath": "\\HBuilderProjects\\uniharmonysdk\\UniHarmony"
}</code></pre><p>说明：</p><ul><li><code>projectPath</code> 指向 <strong>第三步中创建的离线 SDK 工程路径</strong></li><li>每个 uni-app 项目必须唯一</li></ul><p>在将 uni-app 项目正式运行到鸿蒙模拟器之前，还需要在华为开发者平台完成应用信息的创建与配置。首先，使用华为开发者账号登录 AppGallery Connect（AGC）控制台：<br/><a href="https://link.segmentfault.com/?enc=VtG%2BmZYIa92cSAi2J7o4qQ%3D%3D.OHQr3fwVh3hS13ZZ8i1LxYvI0vS9XT54E7GocMDxpDPcbtphwJW%2BJGqbTR8rJ8sk%2BqomAM84%2BT7WfjLw1whKTY4LPSGiSwxfV10XaJSuTNY%3D" rel="nofollow" target="_blank">https://developer.huawei.com/consumer/cn/service/josp/agc/ind...</a></p><p>按照官方指引创建 HarmonyOS 应用，详细流程可参考文档：<br/><a href="https://link.segmentfault.com/?enc=4xI1HuIonACJvO%2BpaZi4jw%3D%3D.puQHCOl1v%2BMDzQuLYde1OnltwMg0aLzCyTqzd12vX%2Fiu4RPJLKq7xxZCkyyJUbkqk8LDlSGBwbGlBljDCj%2FqW3Nac6lwj0h8sEiosm16J%2FGz17KTGWngeHIXflMAWSDZ" rel="nofollow" target="_blank">https://developer.huawei.com/consumer/cn/doc/app/agc-help-cre...</a></p><p>在创建应用过程中，需要手动填写并确认应用包名（Bundle Name）。该包名是鸿蒙应用的唯一标识，只有在 AGC 中成功创建应用并生成对应配置后，uni-app 项目才能正常安装并运行到鸿蒙模拟器或真机环境中。创建完成后，在应用信息页面中可以找到 AppID，后续需将该 AppID 按要求填写到工程配置中，确保本地工程与 AGC 应用信息保持一致。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543693" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543694" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/>填写配置</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543695" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><hr/><h4>3. 运行项目（重要经验）</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543696" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/>启动真机后：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543697" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>点击运行到鸿蒙后：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543698" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>如果出现 <strong>失败</strong>，不要慌，这是常见情况：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543699" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543700" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543701" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543702" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>五、运行结果验证</h3><ul><li>uni-app 页面可正常渲染</li><li><code>uni-ui</code> 组件可正常使用</li><li>模拟器 / 真机显示正常</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543703" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>说明：</p><blockquote>🎉 <strong>uni-app → HarmonyOS 编译与运行流程已全部打通</strong></blockquote><hr/><h3>六、总结与经验建议</h3><ul><li>鸿蒙离线 SDK <strong>必须一项目一份</strong></li><li>自动运行失败 ≠ 配置失败，优先尝试 DevEco 手动运行</li><li>模拟器问题 80% 来自 Windows 虚拟化未开启</li><li>建议先跑一个空项目，再逐步加入业务代码</li></ul><p>通过以上完整流程，可以看到 uni-app 在 HarmonyOS 环境下的开发并非“不可用”，而是对 工具链理解与配置顺序 有较高要求。只要正确完成 DevEco Studio、HBuilderX、鸿蒙离线 SDK 以及 AGC 应用信息的对应关系配置，uni-app 项目即可稳定运行在鸿蒙模拟器和真机之上。实践过程中最容易踩坑的环节主要集中在 离线 SDK 复用、Windows 虚拟化环境、应用包名与 AppID 不一致 等问题，这些往往并非代码错误，而是环境与工程配置不匹配所致。</p><p>总体来看，uni-app 作为跨端方案，在鸿蒙生态中已经具备较高的可行性，尤其适合已有 uni-app 技术栈、希望低成本切入 HarmonyOS 的开发者。建议在正式业务开发前，先通过空项目或模板项目完整跑通一遍流程，再逐步引入实际业务代码，这样可以显著降低后期排错成本，也更有利于后续真机调试与应用发布。</p>]]></description></item><item>    <title><![CDATA[2025年国内高性能、可控、符合规范的数据库安全产品推荐 底层逻辑探索 ]]></title>    <link>https://segmentfault.com/a/1190000047541874</link>    <guid>https://segmentfault.com/a/1190000047541874</guid>    <pubDate>2026-01-15 00:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>一、概要<br/>（提示：在强监管与高并发业务并行的背景下，数据库风险监测正从“合规工具”演进为“高性能、可控的数据风险治理基础设施”。）</p><pre><code>   随着《数据安全法》《个人信息保护法》以及《网络数据安全管理条例》的持续落地，数据库风险监测已成为企业数据安全体系中的核心能力之一。尤其在金融、政务、能源等关键行业，数据访问频次高、系统复杂度大、监管要求细化，传统以日志留存为主的审计模式逐渐暴露出性能瓶颈与治理滞后问题。2025 年的数据库风险监测产品，已不再局限于“是否合规”，而是更强调三项核心能力：在高并发环境下的持续高性能解析能力，对风险处置过程的可控性与可追溯性，以及对国内外监管规范的原生适配能力。从实际落地效果看，具备实时分析与主动预警能力的方案，可将风险发现时间从“事后数小时”压缩至“分钟级”，在部分金融场景中，异常导出与越权访问的平均处置周期降低 60% 以上，数据安全从被动响应逐步走向前置治理。</code></pre><p>二、评估方法<br/>（提示：围绕“跑得快、控得住、能合规”，构建面向真实业务场景的产品评估框架。）</p><pre><code>   在本次分析中，评估不再仅关注功能点堆叠，而是以实际生产环境为导向，从性能、可控性与规范适配三个维度进行综合判断。在高性能层面，重点考察产品在高并发 SQL 请求下的解析能力与系统稳定性，包括单节点处理能力、延迟水平以及对核心业务链路的影响。行业实践中，头部金融机构通常要求在 10 万 QPS 以上场景下，日志解析与风险判定延迟控制在 1 秒以内。在可控性层面，关注产品是否具备清晰的风险定位、可解释的告警逻辑以及完整的溯源能力。相比简单告警，“为什么触发、影响了哪些数据、后续如何处置”已成为安全与业务部门共同关注的核心问题。在规范适配层面，则重点评估产品对等保 2.0、金融监管、行业规范及日志证据链要求的内建支持能力，是否能够在不额外开发的前提下，直接输出符合监管审查口径的审计材料。</code></pre><p>三、厂商推荐与技术能力分析<br/>（提示：在技术路线多元化的市场环境中，不同厂商正围绕性能、智能化与场景深度形成差异化能力。）<br/>TOP1：奇安信</p><pre><code>   数据库安全审计与防护系统在攻击检测与防御能力上表现突出。其基于威胁情报与行为画像的检测模型，在多行业实测中，SQL 注入识别准确率可达 99% 以上，并支持秒级联动告警与阻断。通过与 SIEM、SOC 平台的深度集成，可形成从发现到处置的闭环流程，适合对外部攻击防护要求极高、且已有成熟安全运营体系的组织。</code></pre><p>TOP2：安恒信息</p><pre><code>   数据库审计与风险控制平台更强调风险量化与精细化管控。其通过引入风险评分模型，将漏洞等级、数据敏感度与业务权重进行综合计算，使安全团队能够以“风险值”而非单一告警进行优先级管理。在银行与能源行业实践中，该模式有助于减少无效告警，提升资源投入的精准度。</code></pre><p>TOP3：全知科技</p><pre><code>   “知形”系统在技术路径上与传统审计产品形成明显区分。其以数据资产为核心，通过旁路镜像方式获取数据库返回流量，自动识别并分级敏感数据，构建“识别—监测—溯源”的闭环能力。相较仅记录访问行为的方案，“知形”更关注数据是否真正发生了异常流转，在实际案例中，可按敏感数据类型反向定位泄露路径，平均 30 分钟内完成溯源分析。在不侵入业务系统的前提下，同时满足等保合规与主动防护需求，体现出较强的可控性与落地友好度。</code></pre><p>TOP4：启明星辰</p><pre><code>   数据库安全审计与合规平台在规范适配与规模化部署方面优势明显。其预置多类合规模板，支持一键生成符合监管要求的审计报告，在央企与政府机构中具备较高成熟度。分布式架构设计使其能够支撑超大规模日志处理需求，适合监管报送频繁、组织结构复杂的场景。</code></pre><p>TOP5：天融信</p><pre><code>   数据库审计与行为监测系统以 UEBA 为核心技术，重点解决内部人员误操作与违规访问问题。通过对用户长期行为建模，能够识别偏离正常模式的高风险操作，在金融与运营商场景中，对内部风险治理具有现实价值。</code></pre><p>TOP6：阿里云</p><pre><code>   数据安全中心（DSC）则体现出云原生环境下的整合优势。通过与 RDS、PolarDB 等服务的深度集成，实现数据库实例的自动发现、敏感数据分类分级与风险可视化，适合云环境占比高、追求统一治理视图的企业。</code></pre><p>四、总结<br/>（提示：数据库风险监测的差异化竞争，正在从“功能完整度”转向“性能可持续性与治理深度”。）</p><pre><code>   综合来看，2025 年国内数据库风险监测产品已进入能力细分与场景深化阶段。部分厂商在攻击检测与实时防护方面具备优势，部分更擅长合规审计与规模化管理，也有厂商开始以数据资产为中心，探索更贴近业务实质的风险治理路径。在与友商对比时，可以看到：传统审计型方案在规范适配与稳定性方面仍具优势，而新一代以数据流转为核心的产品，在风险定位效率与可控性上展现出更强潜力。企业在选型过程中，应结合自身业务并发水平、监管压力与安全运营能力，理性评估产品在高性能、可控性与规范适配三方面的平衡能力。
   随着相关国家标准与行业规范的进一步细化，数据库风险监测将不再只是“满足检查”的工具，而是支撑企业数据安全治理与业务稳健运行的重要底座。能够在复杂环境下长期稳定运行、并真正帮助组织看清数据风险的产品，将更具持续价值。</code></pre>]]></description></item><item>    <title><![CDATA[感悟反思：AI赋能IT服务管理，智能体引领变革之路 ITIL先锋论坛 ]]></title>    <link>https://segmentfault.com/a/1190000047543489</link>    <guid>https://segmentfault.com/a/1190000047543489</guid>    <pubDate>2026-01-14 22:02:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>AI赋能IT服务管理：智能体引领变革</strong><br/>2025年12月13日，广州天河区美豪丽致酒店，一场思想盛宴在这里成功举办。“AI赋能IT服务管理”Meetup广州站圆满落幕！来自大湾区的IT服务管理精英汇聚一堂，100多人的会场座无虚席。</p><p><strong>盛会启幕，高朋满座</strong><br/>下午13:00，签到处早已排起长队。工作人员悉心引导来宾签到，每位参会者都领到了精心准备的资料和伴手礼。现场学习氛围浓厚，不少嘉宾提前到场交流，迫不及待想要汲取新的知识。</p><p><strong>长河：IT经理的下一站-做AI教练，成为AI架构师</strong><br/>长河老师以犀利提问抓住全场注意力：“你到底懂不懂AI？”他指出，将AI视为"高级搜索引擎"是最大的认知偏差。AI教练的核心 = "自己明白" + "教会他人"。传统架构师与AI架构师的根本区别在于—后者能实现近乎零代码开发，同时兼任BA、SA、Engineer三重角色！</p><p><strong>丁振兴：运维界的"贾维斯"来了</strong><br/>丁振兴老师带来了硬核技术分享。他从全技术栈监控切入，展示了乐维的强大智能运维实力。智能体架构设计构建"数字神经网络"，将感知层、记忆层、规划层、行动层、大脑层深度融合，打造系统的"数字身体图式"。</p><p><img width="723" height="402" referrerpolicy="no-referrer" src="/img/bVdnvsF" alt="" title=""/></p><p><strong>罗小军：全链路的企业业务智能体</strong><br/>罗小军老师展示了覆盖全链路的企业业务智能体：市场部智能体、编辑部智能体、销售部智能体、运营部智能体。典型案例显示：使用智能体后，方案撰写时间从3小时缩短至3分钟，效率提升60倍！</p><p><strong>王晨光：集成中台打破数据孤岛</strong><br/>王晨光老师深入剖析了企业数字化转型的三大核心痛点：系统孤岛、数据沉睡、重复劳动。提出创新方案：应用集成中台 + 数据集成中台 + AI智能体 = 1+1&gt;2 的协同价值。</p><p><strong>圆桌讨论：AI如何拯救IT人职场</strong><br/>长河老师、丁振兴老师、罗小军老师三位专家围坐一桌，与观众深度互动。专家一致认为：AI不是来取代运维人员，而是来赋能和解放他们！3-5年内将影响30%-50%岗位，但同时也会创造新机会。</p><p><strong>智能体实战演练，AIops实操</strong><br/>长河老师手把手带领大家进行AI智能体开发实战。演练一：业务合同审核智能体；演练二：业务舆情洞察智能体；演练三：广东乐维软件智能运维平台体验。</p><p><strong>致谢篇 · 晚宴交流</strong><br/>夜色微醺，广州CBD灯火渐起，霓虹映照着珠江水面。嘉宾们从会场转入一处雅致私房菜馆。来宾中有老同行，也有新朋友，大家相互介绍自己，分享自己的收获，探讨行业的远景。<br/>感谢长河老师、丁振兴老师、罗小军老师、王晨光老师的倾囊分享，启人心智、启迪未来。感谢主持人吴军老师的从容与风度，让现场节奏有序。感谢每一位到场嘉宾，你们无惧风雨，热忱赴约！</p>]]></description></item><item>    <title><![CDATA[CALM模型的黑盒采样：用碰撞方法实现温度调节 本文系转载，阅读原文
https://avoid.o]]></title>    <link>https://segmentfault.com/a/1190000047543499</link>    <guid>https://segmentfault.com/a/1190000047543499</guid>    <pubDate>2026-01-14 22:02:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>温度参数大概是LLM推理中最容易理解的控制手段了。把温度调低，输出就更确定、更收敛；调高，模型就更发散、更有"创意"。问题是这套机制依赖于显式的logits——而连续自回归语言模型（CALM）恰恰没有这东西。</p><p>我们在前面CALM框架的介绍中看到，CALM基本上把架构都做过修改，但是唯独温度采样这块一直没动。</p><p>这时因为模型预测的是无限维空间中的连续向量，根本没法枚举所有可能输出，更别提计算概率了。 或者说我们只有一个能吐样本的黑盒，没有logits可以缩放，没有softmax可以操作。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543501" alt="" title=""/></p><p>调整token生成分布是语言模型最常用的技术之一操作也足够简单直接。</p><blockquote>生产环境里几乎所有LLM部署都离不开温度采样——它决定了输出在创造性和确定性之间的平衡点</blockquote><p>传统做法是在softmax之前对logits做缩放，直接重塑词汇表上的概率分布。但CALM的输出空间是连续的、无限的，这条路是走不通，那怎么办？本文要解决的就是这个问题：只靠抽样能力，不碰任何概率数值，照样可以实现温度控制。</p><blockquote>这里介绍的技术补全了CALM工具链的最后一块拼图，证明连续语言模型在可控性上并不逊于传统token模型，效率优势还能保住</blockquote><h2>温度参数的工作原理</h2><p>先快速回顾下经典温度采样的机制。设 x_i_ 为第 <em>i</em> 个token的logit，温度调整后的概率分布长这样：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543502" alt="" title="" loading="lazy"/></p><p>温度值 <em>T</em> 的作用很直观：<em>T &lt; 1</em> 时分布变尖锐，概率质量往头部token集中，适合编程、数学这类需要确定性的场景；<em>T &gt; 1</em> 时分布变平坦，尾部token也有更多机会被采到，适合创意写作、brainstorming。</p><blockquote>本质上就是除以一个更大的 <em>T</em> 会压缩logit之间的差距，削弱softmax的"赢家通吃"效应，但CALM每一步并不输出有限词汇表上的离散分布，自然也就没有logits向量可供缩放</blockquote><p>这就是为什么需要一套完全不依赖似然函数的替代方案。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543503" alt="" title="" loading="lazy"/></p><p>上图展示了温度对分布形状的影响：左边低温，分布尖锐、确定性强；右边高温，分布平坦、多样性高。</p><h2>只有样本，没有概率？照样能做温度控制</h2><p>CALM的生成器就是个黑盒：可以从里面抽样本，但拿不到概率值也没有logits。</p><blockquote>一个看不见的分布，怎么让它变尖或变平？</blockquote><p>核心思路和经典温度采样相同的目标，从温度调整后的分布中采样但把直接操作概率的步骤全部换成纯采样操作。具体来说，假设有个基础采样器能产生 <em>x∼P(x)</em>，目标是构造一个新采样器产生 <em>x∼PT(x)</em>，且只能用原采样器反复抽样这一种手段。</p><p>下一步是把温度采样重写成不需要logits的形式，这就是后续所有推导的"起点公式"：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543504" alt="" title="" loading="lazy"/></p><p>有了这个公式就能在连续生成模态下复刻温度采样的效果。</p><p><strong>碰撞方法（collision method）</strong> 提供了基础框架。但是还有一个重要的问题：1/<em>T</em> 不是整数怎么办？</p><h3>碰撞技巧的基本原理</h3><p>先把CALM的采样适配到温度控制框架上。这里需要用到碰撞方法：抽取多个独立样本，根据它们的匹配情况来间接确定概率。</p><blockquote><p>这里说的"样本x"是单个CALM解码步骤产生的整个K-token块，不是单个token</p><p>当 T <em>=1/</em> n（n为正整数）时，温度调整后的分布正比于 P <em>(</em> x <em>)</em> ⁿ</p><p>碰撞技巧的数学基础是独立性：n次独立抽样全部等于同一个块x的概率恰好是 P <em>(</em> x <em>)</em> n</p><p>操作方法就是抽n个样本，全部相同才接受否则拒绝重来</p></blockquote><p>举个例子：某个块的概率是 P <em>(__ x __)=0.2</em>，那三路碰撞的概率就是 <em>0.2</em> ³ <em>=0.008</em></p><p>问题在于 <em>1/</em> T 一般不是整数，比如没法抽"3.33个样本"。而且低温度情况下拒绝率会很高，比如 T <em>=0.1</em> 意味着需要连续10个完全相同的样本，所以整数部分和小数部分必须分开处理，这就引出了分解策略。</p><h3>指数分解：拆成整数和小数两部分</h3><p>分解策略把指数运算的代数规则映射到概率上，把 <em>1/T</em> 拆成整数 <em>n</em> 和小数 α 两个分量：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543505" alt="" title="" loading="lazy"/></p><p>整数部分用碰撞方法搞定，小数部分得靠伯努利工厂配合广义二项级数。</p><blockquote>比如 T=0.3，那 1/T=3.33，于是 n=3，α=0.33</blockquote><p>整数分量处理起来相对简单，还是碰撞方法那套。</p><p>小数分量就麻烦了，没法用样本重复的方法，所以要把问题转化成无限级数形式。这就是伯努利工厂的用武之地：用只能访问概率为 <em>p</em> 的硬币，"制造"出一个概率为 <em>p</em> ᵅ 的有偏硬币。</p><blockquote>所谓"概率为p的硬币"其实就是个匹配指示器：从基础采样器抽一个样本，跟目标x相等就返回成功。这是个伯努利随机变量（真/假），成功概率等于 p=P(x)</blockquote><p>两部分必须同时满足，采样才算有效。</p><p>数学上这套东西还是很好解释的但计算上有个严重瓶颈。低温度的情况下——比如 <em>T=0.1</em>——需要连续10个相同样本。模型可能要跑几百万次才出一个有效结果。</p><h3>批量近似：让低温采样变得可行</h3><p>作者给出的解法是批量近似。与其等连续n个相同样本，不如一次性抽一大批样本（<em>N &gt;&gt; n</em>）然后在里面找重复。</p><p>具体操作如下：假设 n=10（即 T=0.1），一次抽 N=200 个样本统计每个块出现的次数，出现次数≥10的块就成为整数部分阶段的合格候选<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047543506" alt="" title="" loading="lazy"/></p><p>当 N=10、n=2 时，合格候选就是那些在10个样本里出现至少2次的块，这可比等连续相同样本高效多了。</p><p>这种做法用一次可并行的批量抽样替代了反复重启，低温情况下的样本利用率大幅提升。</p><p>结合组合数学，低温和小数分量的问题都有了稳健解法。温度被正确迁移到隐式分布上，创造性和精确性之间的调节照样能做，而且根本不需要知道真实分布长什么样。</p><h2>这对CALM意味着什么</h2><p>这套采样框架补齐了CALM工具链，剩下的挑战主要是工程层面的：让低温解码在实际推理中跑得够快。批量近似提供了思路——不用反复重启等碰撞，抽一个大批次然后在里面找，熟悉的创造性↔精确性旋钮就保住了。</p><p>这个思路的适用范围远不止CALM。任何能采样但没法给概率打分（或做归一化）的隐式生成模型都能复用同样的原理。</p><blockquote>扩散语言模型、流匹配架构同样适用</blockquote><p>另外值得一提的是CALM把自回归步数降到了原来的 1/<em>K</em>（比如 <em>K</em>=4 时就是4倍压缩），而上面这套采样框架保住了细粒度的解码控制，而实用性没打折扣。</p><h2>技术贡献总结</h2><p>核心创新点在于：不需要概率值也能做温度控制。方法是把概率重加权 <em>P</em>(<em>x</em>)<em>ⁿ</em> 转化成一个采样事件——只在n个独立抽样碰撞到同一结果时接受。</p><p>数学上的关键技巧是把 1/<em>T</em> 写成 <em>n</em> + <em>α</em> 的形式。整数指数靠碰撞解决，小数指数靠伯努利工厂搞定 <em>p</em> ᵅ。</p><p>工程上的突破是批量近似：一次并行批量加组合分组，取代了低效的反复重启，低温解码终于变得可行。</p><p>更广泛地看，这套方法适用于所有"能采样但没法评分归一化概率"的隐式模型——扩散模型、流匹配等新范式都能用。<br/><a href="https://link.segmentfault.com/?enc=a0ei3%2B6aI6ViEalaZx9c5Q%3D%3D.nNEmv1KTFEXLcBl9jUcfHsc%2FMJ9IWhBBvXzyWV8tHu8kpZivqFWFZXwCuZxkNQW5RLm%2Fs1qD3KyIhRYU%2Bpd%2BZA%3D%3D" rel="nofollow" target="_blank">https://avoid.overfit.cn/post/e2161ee3e44c4645b1e1f31666edd9b7</a></p><p>作者：Fabio Yáñez Romero</p>]]></description></item><item>    <title><![CDATA[读研期间一直被导师安排做项目，很焦虑怎么办 cpp辅导的阿甘 ]]></title>    <link>https://segmentfault.com/a/1190000047543534</link>    <guid>https://segmentfault.com/a/1190000047543534</guid>    <pubDate>2026-01-14 22:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>前言</h2><p>很多同学应该读研的时候，应该都会遇到被导师安排各种工作的事情，安排自己参与各种项目，为老板赚钱。</p><p>又处于被动的一个地位，不得不加入。</p><p>对于这种情况我们应该怎么办呢？</p><p>这是好事还是坏事呢？</p><p>怎么排遣自己的心情，缓解焦虑呢？</p><p>下面我们可以看下一个星球同学的提问，普适意义还是比较大的</p><h2>星球同学提问</h2><p>甘哥你好，我目前研二明年秋招，现在感觉是非常焦虑，希望甘哥可以帮忙指点迷津。</p><p>我先介绍一下自己的基本情况，我是双非本，中九硕，本科是电子信息专业，硕士是计算机，无实习，但有竞赛经历，本科拿过电赛和智能车的国一。</p><p>因为本科时参加的都是电子类竞赛，当时计划的是以后从事嵌入式linux驱动开发这类的工作，所以研零的时候跟着正点原子的学完了IMX6ULL的应用和驱动开发。</p><p><strong>但是硕士入学后一直在被老师安排着做项目</strong>，大部分都属于c++客户端的内容，从入学到现在干过音视频，opengl图形学，ros，安卓开发，鸿蒙开发，视频大模型训练，还有一些算法研究。</p><p><strong>每个项目都是只接触表层，但根本没有深入学习</strong>，老师只要能用就会安排新的任务，就导致我感觉我干了很多事但是根本没有学到东西。</p><p><strong>现在就是特别焦虑，不知道到底该走什么方向，我本人更喜欢做更底层一点工作，但很久没接触嵌入式了，研究生期间又没啥对应的项目。</strong></p><p>然后身边同学都是计算机科班都打算找后端，找后端我基本就得从头开始学，因为实验室压力又特别大，每天只有下班后的时间能自己学习。</p><p>我现目前自己就是每天刷几道leetcode（现在刷了快200道)，然后学习计算机四大件（因为本科没学过)，看看八股，就是想嵌入式和后端都准备不知道行不行，因为老师不放日常实习，等到明年暑期实习还有半年时间，还是说最好要现在定好方向。</p><p>然后有哪些项目适合学习的，能不能写实验室的项目（甲方title还挺大的，就是感觉方向跟找工作的方向都不太对口），还有如果只打算暑期实习的话现在的话应该怎么准备。感谢甘哥。</p><h2>阿甘回答</h2><p>首先不要焦虑，通过你的描述，其实已经比很多学生强太多了。</p><p>1.学历很好，985硕士</p><p>2.学了很多东西，真实的参与了很多项目。虽然很多方向都是只学了学表层，但是参与了很多项目，实打实的参与，编程能力肯定是提高了不少的。</p><p>等你工作了也会发现，其实不管什么方向，也都是在加log，追代码进行bug分析，哪怕是内核。</p><p>主要的还是一个代码能力。大学能有这个提高，个人认为其实挺不错的，比像其他人看视频，背八股厉害很多了。</p><p>可能你现在感觉不到，其实在面试的时候，一个天天背八股，和一个编程经验丰富的人给人的感觉是不一样的。尤其现在大环境不好，对你们新人的话，各个方向都了解一下不是什么坏处：</p><p>（1）环境不好，裁员频繁，一个部门可能有好几个方向，部门裁人，但是部门工作量没变，尤其你们新人在这种情况下会极容易出现方向调整。那让你转到一个不熟悉的方向，你能不干？你能说干不了？那下一个走的就是你</p><p>（2）部门拿到新的项目，新的业务，没有接触过，不属于你这个方向的，让你干，你说你不能干，干不了？那年终背指标的就是你。上面说的这些情况太正常了，尤其去一个乙方公司，不同甲方不同要求。对一个人快速学习能力，编程能力是很有考验的。一般一个部门一个方向就需要维护好几个代码线。在大学能有这方面的锻炼，个人认为挺不错的</p><p>3.基础也学了很多，基础过关，算法也刷了不少，算法也过关。</p><p><strong>上面这些具备的能力一定非常强了，就算原地踏步，秋招拿几个大厂offer也问题不大，也会是一个offer收割机的，到时候期待你向我报喜</strong></p><p>那目前这时间到你找实习，到你秋招应该怎么利用好，才能有更大的提升呢，让自己不局限于拿大厂offer，而是拿大厂sp ssp offer：</p><p>（1）上面你说你做了很多编程工作，参与了很多项目，编程能力有很大提升。那这个东西怎么向面试官展现呢，让面试官认可自己的能力呢。并且人的记忆是有遗忘性的，你目前做了这么多，等你找工作的时候还记得多少呢。所以目前重点是对自己做的这些先进行梳理，进行文档记忆留存，以便你找工作展现你编程能力的时候，可以快速复习上来</p><p>（2）上面你也说了，做了很多方向，估计也是感受到了cpp不同的方向技术栈天差地别，也对各个方向有了了解。学历也比较好嘛，其实无论选什么方向，知名厂都会给你面试的。这个时候可以多想想，自己究竟对什么方向感兴趣，对这个方向深入的学学，增大进入这个方向的机会。</p><p>最后让自己可以拿到一个大厂的offer，一个大厂ssp的offer，一个自己感兴趣方向的offer。</p><p>项目做的话，到时候就做你这个方向的项目，如果自己选定了方向，不知道做什么项目，到时候可以私信我，再和你具体的聊聊。</p><p>项目的话，秋招建议可以放两个，一个你感兴趣方向的项目，一个是基础底层的项目，操作系统的或者计算机网络的，这样你海投别的岗位，也可以让人家面试官有的问</p><p>然后你参与的这些实验室的项目，可以当作副要的，因为项目你可能都是参与了一部分，深入交流的话有可能招架不住</p><p>挺不错的，加油哈</p><p>本文由<a href="https://link.segmentfault.com/?enc=hZexmdR7mlpgAmRbAqw1IQ%3D%3D.UwjMc3APkBnFYgtSQsJdrF3npJ7RwSJqPQCuXDO24jw%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[AI招聘的核心：以心理学筑牢精准与体验双重壁垒 爱跑步的香蕉_cKtiNz ]]></title>    <link>https://segmentfault.com/a/1190000047543453</link>    <guid>https://segmentfault.com/a/1190000047543453</guid>    <pubDate>2026-01-14 21:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>AI招聘的核心：以心理学筑牢精准与体验双重壁垒<br/>近日，上海市心理学会工业与组织心理学专业委员会成立大会暨首届学术年会隆重举行。此次会议由上海市心理学会、工业与组织心理学专业委员会、华东师范大学心理与认知科学学院联合主办，以“AI时代下的职场幸福与可持续绩效”为主题，汇聚工业与组织心理学领域的学术权威与产业先锋，共同探讨人工智能背景下组织管理与职场心理发展的新范式。AI招聘技术的科学性与专业性，成为此次会议探讨的核心议题之一，其在招聘场景的落地价值获得学界广泛认可。<br/>在AI招聘领域，技术落地的核心前提的是站稳“技术”与“心理学”两条底线。世界五百强、中国头部企事业单位及顶尖高校在选用AI招聘工具时，均将“可信”作为核心考量，而这份信任的建立，离不开技术对招聘本质的深刻洞察与实践验证。<br/>招聘的本质是判断候选人未来能否胜任岗位，精准度是AI招聘工具的核心竞争力。优质AI招聘工具的评估打分，需经过大量真实客户场景的人机背靠背对比实验验证，在效标效度与重测稳定信度两项核心心理学测量指标上，达到可直接用于招聘决策的专业标准。随着AI面试技术的迭代升级，顶尖AI招聘系统已实现从“辅助参考”到“直接决策”的质的跃迁，展现出比人工判断更稳定、更可复用的优势。<br/>顶尖AI招聘系统的精准能力，沉淀为一整套可规模化、可复制的体系，贯穿招聘全流程：<br/>•一问多能：一道题目同步评估多项胜任力，打通HR初筛与技术复试，评估效率提升50%以上，避免重复面试与判断；<br/>•自由追问：根据候选人即时回答动态生成针对性问题，像资深面试官般抓关键、补漏洞，避免核心能力被“答题技巧”掩盖；<br/>•简历深度挖掘：自动抓取简历关键信息与模糊点，生成递进式提问，既防范信息造假，也减少HR因主观疏忽错过优质候选人的可能；<br/>•全维度考察：既覆盖沟通、协作等通用胜任力，也能针对编程、算法、工程、财务等专业领域精准出题，同时解放HR与专业面试官。<br/>如果说精准决定招聘“选得对”，体验则决定“选得到”。优质AI招聘系统正打破候选人对“AI面试＝冷冰冰”的固有认知，将面试转化为雇主品牌加分项：<br/>•懂情绪的智能交互：捕捉候选人语速、情绪与潜台词，引导其完整表达真实能力，避免因紧张被低估；<br/>•无断点的流畅对话：无需手动操作开始或结束，系统自动识别回答状态并自然衔接下一问题，体验贴近面对面交流；<br/>•沉浸式视觉体验：语音与口型高度匹配，嘴型、语速、节奏精准同步，彻底告别“纸片人”式疏离感；<br/>•多轮对话答疑：候选人可随时提问，系统能准确解答岗位信息、公司福利等问题，让面试成为有效的雇主沟通环节。<br/>学界对AI招聘技术的认可，本质是对“以科学为底座、以实践为导向”理念的肯定。优质AI招聘系统凭借心理学验证的精准度与极致的候选人体验，重构招聘流程价值，助力企业高效招贤纳士，让招聘回归长期价值。</p>]]></description></item><item>    <title><![CDATA[AWS RDS 可观测性最佳实践 观测云 ]]></title>    <link>https://segmentfault.com/a/1190000047543399</link>    <guid>https://segmentfault.com/a/1190000047543399</guid>    <pubDate>2026-01-14 20:02:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>AWS RDS 介绍</h2><p>AWS RDS（Amazon Relational Database Service）是一种由亚马逊提供的完全托管的关系数据库服务，支持多种流行的数据库引擎，如 MySQL、MariaDB、PostgreSQL、Oracle 和 SQL Server。这项服务的主要优势在于简化了在云中部署、操作和扩展关系数据库的复杂性，无需用户自行管理底层的基础设施。它提供了自动备份和恢复、自动维护、高可用性和容错能力、可扩展性以及安全性等关键特性。</p><p>尽管 AWS RDS 极大地降低了数据库管理的复杂性，但对其进行监控和可观测性仍然是至关重要的。监控可以帮助优化数据库性能，通过分析性能指标如 CPU、内存使用率、磁盘 I/O 和网络流量等，及时识别并解决性能瓶颈。此外，监控还有助于故障检测，可以快速识别并响应数据库的异常情况，如连接失败、查询超时等。它还支持容量规划，通过分析历史使用数据预测资源需求，以合理规划和分配资源。安全性方面，监控可以帮助检测潜在的安全威胁，如未授权访问和 SQL 注入攻击，从而采取相应的防御措施。此外，监控还有助于成本控制，通过识别不必要的资源消耗来优化成本，同时也可以满足某些行业或地区对于数据库可观测性的特定合规要求。</p><h2>观测云</h2><p>观测云是一款专为 IT 工程师打造的全链路可观测产品，它集成了基础设施监控、应用程序性能监控和日志管理，为整个技术栈提供实时可观察性。这款产品能够帮助工程师全面了解端到端的用户体验追踪，了解应用内函数的每一次调用，以及全面监控云时代的基础设施。此外，观测云还具备快速发现系统安全风险的能力，为数字化时代提供安全保障。</p><h3>采集器配置</h3><ol><li>登陆观测云控制台</li><li>点击【集成】菜单，选择【云账号管理】</li><li>点击【添加云账号】，选择【AWS】，填写界面所需的信息，如之前已配置过云账号信息，则忽略此步骤</li><li>点击【测试】，测试成功后点击【保存】，如果测试失败，请检查相关配置信息是否正确，并重新测试</li><li>点击【云账号管理】列表上可以看到已添加的云账号，点击相应的云账号，进入详情页</li><li>点击云账号详情页的【集成】按钮，在未安装列表下，找到AWS RDS Mysql，点击【安装】按钮，弹出安装界面安装即可。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543401" alt="图片" title="图片"/></p><h3>关键指标</h3><table><thead><tr><th>指标</th><th>控制台名称</th><th>描述</th><th>单位</th></tr></thead><tbody><tr><td>BinLogDiskUsage</td><td>二进制日志磁盘使用情况（MB）</td><td>二进制日志所占的磁盘空间大小。如果为 MySQL 和 MariaDB 实例（包括只读副本）启用了自动备份，则会创建二进制日志。</td><td>字节</td></tr><tr><td>BurstBalance</td><td>突发余额（百分比）</td><td>可用的通用型 SSD (GP2) 突增存储桶 I/O 点数的百分比。</td><td>百分比</td></tr><tr><td>CheckpointLag</td><td>检查点滞后（毫秒）</td><td>自最近一次检查点以来的时间。仅适用于 RDS for PostgreSQL。</td><td>毫秒</td></tr><tr><td>ConnectionAttempts</td><td>连接尝试（计数）</td><td>尝试连接实例的次数，无论成功与否。</td><td>计数</td></tr><tr><td>CPUUtilization</td><td>CPU 利用率（百分比）</td><td>CPU 使用百分率。</td><td>百分比</td></tr><tr><td>CPUCreditUsage</td><td>CPU 额度使用（计数）</td><td>（T2 实例）实例为保持 CPU 使用率而花费的 CPU 积分数。一个 CPU 积分等于一个 vCPU 以 100% 的使用率运行一分钟或等同的 vCPU、使用率与时间的组合。例如，您可以有一个 vCPU 按 50% 使用率运行两分钟，或者两个 vCPU 按 25% 使用率运行两分钟。CPU 积分指标仅每 5 分钟提供一次。如果您指定一个大于五分钟的时间段，请使用Sum 统计数据，而非 Average 统计数据。</td><td>积分 (vCPU 分钟)</td></tr><tr><td>CPUCreditBalance</td><td>CPU 额度余额（计数）</td><td>（T2 实例）实例自启动后已累积获得的 CPU 积分数。对于 T2 标准，CPUCreditBalance 还包含已累积的启动积分数。在获得积分后，积分将在积分余额中累积；在花费积分后，将从积分余额中扣除积分。积分余额具有最大值限制，这是由实例大小决定的。在达到限制后，将丢弃获得的任何新积分。对于 T2 标准，启动积分不计入限制。实例可以花费 CPUCreditBalance 中的积分，以便突增到基准 CPU 使用率以上。在实例运行过程中，CPUCreditBalance 中的积分不会过期。在实例停止时，CPUCreditBalance 不会保留，并且所有累积的积分都将丢失。CPU 信用指标仅每 5 分钟提供一次。启动积分在 Amazon RDS 中的作用方式与在 Amazon EC2 中的作用方式相同。</td><td>积分（vCPU 分钟）</td></tr><tr><td>DatabaseConnections</td><td>数据库连接（计数）</td><td>连接至数据库实例的客户端网络连接数。数据库会话数可能高于指标值，因为指标值不包括以下内容：不再具有网络连接但数据库尚未清理的会话数据库引擎出于自身目的创建的会话由数据库引擎的并行执行功能创建的会话由数据库引擎任务计划程序创建的会话Amazon RDS 连接</td><td>计数</td></tr><tr><td>DiskQueueDepth</td><td>队列深度（计数）</td><td>等待访问磁盘的未完成 I/O（读取/写入请求）的数量。</td><td>计数</td></tr><tr><td>EBSByteBalance</td><td>EBS 字节余额（百分比）</td><td>RDS 数据库突增存储桶中剩余的吞吐量积分的百分比 此指标仅对基本监控可用。该指标值基于包括根卷在内的所有卷的吞吐量和 IOPS，而不是仅基于那些包含数据库文件的卷。</td><td>百分比</td></tr><tr><td>EBSIOBalance</td><td>EBS IO 余额（百分比）</td><td>RDS 数据库突增存储桶中剩余的 I/O 积分的百分比 此指标仅对基本监控可用。该指标值基于包括根卷在内的所有卷的吞吐量和 IOPS，而不是仅基于那些包含数据库文件的卷。</td><td>百分比</td></tr><tr><td>FailedSQLServerAgentJobsCount</td><td>失败的 SQL Server Agent 作业计数（计数/分钟）</td><td>过去 1 分钟内失败的 Microsoft SQL Server Agent 作业的数量。</td><td>每分钟计数</td></tr><tr><td>FreeableMemory</td><td>可用内存（MB）</td><td>随机存取内存的可用大小。对于 MariaDB、MySQL、Oracle 和 PostgreSQL 数据库实例，此指标报告 MemAvailable 的 /proc/meminfo 字段的值。</td><td>字节</td></tr><tr><td>FreeLocalStorage</td><td>可用本地存储（MB）</td><td>可用本地存储空间的大小。此指标仅适用于具有 NVMe SSD 实例存储卷的数据库实例类。</td><td>字节</td></tr><tr><td>FreeStorageSpace</td><td>可用存储空间 (MB)</td><td>可用存储空间的大小。</td><td>字节</td></tr><tr><td>MaximumUsedTransactionIDs</td><td>最大已用事务 ID（计数）</td><td>已使用的最大事务 ID。仅适用于 PostgreSQL。</td><td>计数</td></tr><tr><td>NetworkReceiveThroughput</td><td>网络接收吞吐量（MB/秒）</td><td>数据库实例的传入（接收）网络流量，包括用于监控和复制的客户数据库流量和 Amazon RDS 流量。</td><td>每秒字节数</td></tr><tr><td>NetworkTransmitThroughput</td><td>网络传输吞吐量（MB/秒）</td><td>数据库实例的传出（传输）网络流量，包括用于监控和复制的客户数据库流量和 Amazon RDS 流量。</td><td>每秒字节数</td></tr><tr><td>OldestReplicationSlotLag</td><td>最早副本槽滞后 (MB)</td><td>在接收预写日志 (WAL) 数据方面最滞后的副本的滞后大小。适用于 PostgreSQL。</td><td>字节</td></tr><tr><td>ReadIOPS</td><td>读取 IOPS（计数/秒）</td><td>每秒平均磁盘读取 I/O 操作数。</td><td>每秒计数</td></tr><tr><td>ReadIOPSLocalStorage</td><td>读取 IOPS 本地存储（计数/秒）</td><td>每秒至本地存储的平均磁盘读取输入/输出操作数。此指标仅适用于具有 NVMe SSD 实例存储卷的数据库实例类。</td><td>每秒计数</td></tr><tr><td>ReadLatency</td><td>读取延迟（毫秒）</td><td>每个磁盘 I/O 操作所需的平均时间。</td><td>毫秒</td></tr><tr><td>ReadLatencyLocalStorage</td><td>读取延迟本地存储（毫秒）</td><td>每个磁盘对本地存储输入/输出操作所需的平均时间。此指标仅适用于具有 NVMe SSD 实例存储卷的数据库实例类。</td><td>毫秒</td></tr><tr><td>ReadThroughput</td><td>读取吞吐量（MB/秒）</td><td>每秒从磁盘读取的平均字节数。</td><td>每秒字节数</td></tr><tr><td>ReadThroughputLocalStorage</td><td>读取吞吐量本地存储（MB/秒）</td><td>每秒从磁盘至本地存储读取的平均字节数。此指标仅适用于具有 NVMe SSD 实例存储卷的数据库实例类。</td><td>每秒字节数</td></tr><tr><td>ReplicaLag</td><td>副本滞后（毫秒）</td><td>对于只读副本配置，只读副本数据库实例滞后于源数据库实例的时间量。适用于 MariaDB、Microsoft SQL Server、MySQL、Oracle 和 PostgreSQL 只读副本。对于多可用区数据库集群，写入器数据库实例上的最新事务与读取器数据库实例上的最新应用事务之间的时间差异。</td><td>毫秒</td></tr><tr><td>ReplicationSlotDiskUsage</td><td>副本插槽磁盘使用情况（MB）</td><td>副本槽文件使用的磁盘空间。适用于 PostgreSQL。</td><td>字节</td></tr><tr><td>SwapUsage</td><td>交换区使用情况（MB）</td><td>数据库实例上使用的交换空间的大小。此指标对于 SQL Server 不可用。</td><td>字节</td></tr><tr><td>TransactionLogsDiskUsage</td><td>事务日志磁盘使用情况（MB）</td><td>事务日志使用的磁盘空间。适用于 PostgreSQL。</td><td>字节</td></tr><tr><td>TransactionLogsGeneration</td><td>事务日志生成（MB/秒）</td><td>每秒生成的事务日志的大小。适用于 PostgreSQL。</td><td>每秒字节数</td></tr><tr><td>WriteIOPS</td><td>写入 IOPS（计数/秒）</td><td>每秒平均磁盘写入 I/O 操作数。</td><td>每秒计数</td></tr><tr><td>WriteIOPSLocalStorage</td><td>写入 IOPS 本地存储（计数/秒）</td><td>本地存储上的每秒平均磁盘写入 I/O 操作数。此指标仅适用于具有 NVMe SSD 实例存储卷的数据库实例类。</td><td>每秒计数</td></tr><tr><td>WriteLatency</td><td>写入延迟（毫秒）</td><td>每个磁盘 I/O 操作所需的平均时间。</td><td>毫秒</td></tr><tr><td>WriteLatencyLocalStorage</td><td>写入延迟本地存储（毫秒）</td><td>本地存储上每个磁盘 I/O 操作所需的平均时间。此指标仅适用于具有 NVMe SSD 实例存储卷的数据库实例类。</td><td>毫秒</td></tr><tr><td>WriteThroughput</td><td>写入吞吐量（MB/秒）</td><td>每秒写入磁盘的平均字节数。</td><td>每秒字节数</td></tr><tr><td>WriteThroughputLocalStorage</td><td>写入吞吐量本地存储（MB/秒）</td><td>本地存储每秒写入磁盘的平均字节数。此指标仅适用于具有 NVMe SSD 实例存储卷的数据库实例类。</td><td>每秒字节数</td></tr></tbody></table><h3>场景视图</h3><p>登录观测云控制台，点击「场景」 -「新建仪表板」，输入 “AWS RDS”， 选择 “AWS RDS MySQL 监控视图”，点击 “确定” 即可添加视图。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543402" alt="图片" title="图片" loading="lazy"/></p><h3>监控器（告警）</h3><p>观测云内置了监控器模板，可以选择从模版创建监控器，并开启适合业务的监控器以及时通知相关成员关注问题，触发条件、频率等信息可以依据实际业务进行调整。</p><p>登录观测云控制台，点击「监控」 -「新建监控器」，输入 “AWS RDS”， 选择对应的监控器，点击 “确定” 即可添加。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543403" alt="图片" title="图片" loading="lazy"/></p><p>AWS RDS Mysql 实例名称为 {{DBInstanceIdentifier}} CPU 使用率过高</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543404" alt="图片" title="图片" loading="lazy"/></p><h2>总结</h2><p>通过将 AWS RDS 的原生监控数据集成到观测云平台，用户可以实现对关系数据库服务（RDS）实例的实时性能监控、资源使用分析以及安全事件的可视化。观测云平台提供的高级分析和可视化功能，包括实时仪表板、智能告警和根因分析，能够帮助用户快速定位数据库性能问题、优化资源成本，并确保数据的高可用性和安全性。</p>]]></description></item><item>    <title><![CDATA[geek卸载软件怎么安装？详细安装步骤 读书笔记 ]]></title>    <link>https://segmentfault.com/a/1190000047543416</link>    <guid>https://segmentfault.com/a/1190000047543416</guid>    <pubDate>2026-01-14 20:02:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><p>geek.exe 是一款轻量级的 Windows 系统清理/优化小工具，主要用来<strong>卸载软件、清理残留文件和注册表</strong>。</p><h2>一、先准备：下对安装包</h2><p>首先得有geek.exe的安装文件！</p><ul><li><strong>去哪下</strong>：<strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=IznRVuMkISwTbMO1VZlLfw%3D%3D.91%2FTnoNczEGuH9XPYbRMVb3Jd36F3PhSDpIpk9NwfCOwUptQIY%2BzwRzGH0Xd2ZUj" rel="nofollow" title="https://pan.quark.cn/s/797afce56bb5" target="_blank">https://pan.quark.cn/s/797afce56bb5</a></li><li><strong>下完检查</strong>：确认文件名是<code>geek.exe</code>（别下成压缩包或别的后缀），大小别太离谱（比如几KB肯定不对）。</li></ul><h2>二、正式安装：一步步来</h2><h3>1. 双击打开安装包</h3><p>找到刚下载的<code>geek.exe</code>，双击它！（要是没反应，右键点“以管理员身份运行”，部分电脑需要权限）</p><h3>2. 选安装位置（建议改默认路径）</h3><p>弹出的窗口里，第一步通常是选“安装到哪”。</p><ul><li>默认可能是<code>C:\Program Files\geek</code>（C盘是系统盘，装太多软件会变卡）。</li><li><strong>建议改</strong>：点“浏览”，选D盘/E盘，新建个文件夹（比如<code>D:\Tools\geek</code>），点确定。</li></ul><h3>3. 跳过“捆绑软件”（重点！）</h3><p>很多安装包会偷偷勾“推荐安装XX浏览器/游戏”，<strong>一定把勾去掉</strong>！只留“我同意协议”和“创建桌面快捷方式”（想要快速启动就勾这个）。</p><h3>4. 点“安装”，等进度条跑完</h3><p>点“安装”按钮后，别着急关窗口，等进度条走完（可能1-3分钟，看电脑速度）。</p><h3>5. 完成！试试能不能用</h3><p>进度条满后，一般会提示“安装成功”。</p><ul><li>勾选“立即启动”（想马上用就勾），点“完成”。</li><li>桌面上找geek的图标（一般是齿轮/工具样式），双击打开，能正常用就OK啦～</li></ul><p>​</p>]]></description></item><item>    <title><![CDATA[Claude Code 最佳实践的 8 条黄金法则 程序猿DD ]]></title>    <link>https://segmentfault.com/a/1190000047543431</link>    <guid>https://segmentfault.com/a/1190000047543431</guid>    <pubDate>2026-01-14 20:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>为什么同样是调用 Claude，有的人能写出工业级代码，而有的人只是在不断堆积“技术债”？ 今天分享一位拥有 7 年 Amazon、Disney 大厂经验、现任创业公司 CTO 分享的实战指南。他把 Claude Code 当作每日主力工具，并总结出了一套高阶玩家手册。从“先思考后敲字”的架构铁律，到让 AI 秒懂你的 CLAUDE.md 深度配置，全是避坑指南。如果你想让 AI 真正成为你的生产力飞轮，这篇文章绝对值得收藏反复读！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543433" alt="f02adbeb1a8c005df0134224ed8c0d1b.png" title="f02adbeb1a8c005df0134224ed8c0d1b.png"/></p><p>下面是对这篇文章的总结解读，如果对原文感兴趣也可以戳这里查看：<a href="https://link.segmentfault.com/?enc=oaoYTBjvAH7qGZnYsX5Bhw%3D%3D.grbYlr8BOrSmy6hiS19sElhEQDdEOhNpXMC8mMUrJEGEJE5d6IXNx5v6IuwIQlhNMiVMrrWZErD%2FOTRlYbCZ0Q%3D%3D" rel="nofollow" target="_blank">《The complete claude code tutorial 》</a></p><h2>法则一：先思考，再输入：计划模式是你最强大的武器。</h2><p>大多数人认为使用AI工具的第一步就是直接开始输入提示词。这是你能犯下的最大错误之一。真正至关重要且必须先做的第一步是——思考和计划。</p><p>我100%的经验表明，使用“计划模式”（连按两次 Shift+Tab 键进入）得到的输出，远胜于直接滔滔不绝地输入想法。这种差距是压倒性的。</p><p>当然，对于一些经验不足的工程师来说，这可能说起来容易做起来难。对此，我有两条建议：</p><ol><li>开始学习。 即使每次只学一点，也必须开始积累。如果你永远不掌握规划能力，你就是在给自己设置障碍。</li><li>与AI深度交流。 和Claude进行一场深入的、双向的对话。详细描述你想构建什么，询问它在系统设计上有什么不同的选择，最终共同确定一个方案。你和AI应该互相提问，而不是单行道。</li></ol><h2>法则二：CLAUDE.md不是文档，而是AI的大脑。</h2><p>CLAUDE.md是一个极其重要但常被误用的配置文件。在你每次启动会话时，Claude都会首先读取它。大多数人要么完全忽略它，要么用一些垃圾信息填满它，结果反而让Claude的表现更糟。</p><p>要写好一个CLAUDE.md，请遵循以下四个关键法则：</p><ul><li>保持简短： Claude一次只能可靠地遵循大约150-200条指令，而系统提示本身已经占用了大约50条。你的每一条新指令都在争夺它的注意力。如果你的CLAUDE.md写得像本小说，Claude就会开始随机忽略某些内容。</li><li>专注于项目特性： 不要告诉它什么是“组件”文件夹，它早就知道了。你应该告诉它你项目里那些“奇怪”的东西，比如你特有的bash命令或工作流程。</li><li>解释“为什么”，而不仅是“做什么”： 当你给出指令背后的原因时，Claude能更好地理解意图并做出更优的判断。只说“使用TypeScript严格模式”是可以的，但说“使用TypeScript严格模式，因为我们曾因隐式any类型导致过生产环境的bug”效果会好得多。</li><li>持续更新： CLAUDE.md应该是一份“活文档”。当你工作时，可以按 # 键快速将当前指令添加到文件中。每当你发现自己第二次纠正Claude同一个问题时，这就是一个明确的信号：这条规则应该被写入CLAUDE.md。</li></ul><p>一个糟糕的 CLAUDE.md 读起来像是给新员工写的入职文档。而一个优秀的 CLAUDE.md 读起来像是你为明天会失忆的自己留下的核心笔记。</p><h2>法则三：200k上下文是甜蜜的陷阱，别掉进去。</h2><p>这是一个反直觉的事实：模型性能的下降远在上下文窗口被完全填满之前就开始了，通常在使用率达到20-40%时就会出现明显的衰减。</p><p>这就是为什么有时候即使你压缩了上下文（使用 /compact 命令），Claude仍然会给出糟糕的输出。因为在压缩之前，模型的性能就已经退化了。</p><p>以下是有效管理上下文的几个实用策略：</p><ul><li>划分对话范围 (Scope your conversations): 每个功能或任务使用一个独立的对话。不要在同一个对话里既构建认证系统又重构数据库层。</li><li>使用外部记忆 (Use external memory): 对于复杂的任务，让Claude将计划和进度写入像 SCRATCHPAD.md 这样的外部文件中。这样第二天你回来时，Claude可以读取文件，从上次中断的地方继续。</li><li>“复制-粘贴”重置法 (The copy-paste reset): 当上下文变得臃肿时，复制对话中的关键信息，运行 /compact 和 /clear 清空上下文，然后只把最重要的信息粘贴回来。一个清爽的上下文远胜于退化的上下文。</li><li>果断清空 (Know when to clear): 如果一个对话已经偏离了轨道，直接用 /clear 重新开始。这几乎总是比试图纠正一个混乱的对话要好。</li></ul><p>记住这个心智模型：Claude是无状态的。除了你明确给它的东西，每个对话都是从零开始。请据此规划。</p><h2>法则四：架构决定一切，规划无可替代。</h2><p>架构至关重要，尤其是在软件工程中。如果你不先思考结构，AI生成的代码就会有巨大的“自由发挥”空间，而这恰恰是问题的根源。你不能跳过规划。</p><p>比较一下这两种提问方式的天壤之别：模糊的请求是“给我建一个认证系统”，而一个经过规划的、具体的请求是“使用现有的User模型构建电子邮件/密码认证功能，将session存储在Redis中并设置24小时过期，并添加中间件保护/api/protected下的所有路由。”</p><p>前者给了AI过多的自由，结果可能是混乱的。后者给了它一个清晰的蓝图，结果会精准得多。花5分钟进行架构规划，可以为你省下后续数小时的调试时间。</p><h2>法则五：停止抱怨模型，糟糕的输出源于你糟糕的输入。</h2><p>当得到不理想的结果时，人们的第一反应往往是抱怨模型。但现实是残酷的：别再怪模型了。如果你用Opus 4.5还得不到好结果，问题出在你身上，而不是AI。你的输入和提示方式烂透了，句号。</p><p>想要提升输出质量，先要提升你的输入质量：</p><ul><li>具体说明你想要什么 (Be specific about what you want)： 你的指令越清晰、越具体，结果就越好。</li><li>告诉它不要做什么 (Tell it what NOT to do)： Claude 4.5尤其有过度设计的倾向。如果你想要一个简约的方案，就明确告诉它：“保持简单，不要添加我没要求的抽象，如果可能的话，只用一个文件。”</li><li>提供“为什么”的背景 (Give it context about why)： 告诉它“这个功能需要在每个请求上运行，所以性能至关重要”，或者“这只是一个原型，用完就扔”，这些约束会彻底改变模型解决问题的思路。</li></ul><p>一个专家级的工作流是：用Opus进行规划和架构设计，然后切换到Sonnet进行具体实现。 Opus更擅长复杂推理，而Sonnet更快、更便宜，非常适合执行明确的任务。当然，如果你是通过API按量付费，用Opus写每一行代码，那你可能得考虑卖掉一个肾了。</p><p>记住这个真理：如果你的输出很糟糕，那是因为你的输入很糟糕。没有捷径可走。</p><h2>法则六：勇于实验，配置决定你的上限。</h2><p>Claude拥有一个极其丰富的功能生态系统：MCP服务器、Hooks、自定义斜杠命令、settings.json配置等等。你不需要全部掌握，但你应该去尝试和实验。</p><ul><li>MCP (Model Context Protocol): 让Claude连接到外部服务，如Slack、GitHub、数据库。如果你发现自己总是在复制粘贴信息，很可能有MCP服务器能帮你自动化。</li><li>Hooks: 让代码在Claude修改前后自动运行。想让Prettier格式化每个文件？用Hook。想在每次编辑后进行类型检查？用Hook。这能立即捕获问题。</li><li>自定义斜杠命令: 把你重复使用的提示词打包成命令。在.claude/commands文件夹里创建markdown文件，然后你就可以用/commandname来运行它们。</li></ul><p>这些模型每周都在进步。一个月前行不通的功能，现在可能已经可以了。保持好奇心，不断重新测试。</p><h2>法则七：当你被卡住时，停止强推，改变方法。</h2><p>有时Claude会陷入一个循环：尝试、失败、再尝试、再失败。在这种情况下，人的本能是继续解释、提供更多指令。但更好的做法是彻底改变你的方法。</p><ul><li>清空对话 (Clear the conversation)： 累积的上下文可能正在迷惑它，一个全新的开始可以解决问题。</li><li>简化任务 (Simplify the task)： 如果一个复杂任务让Claude举步维艰，把它分解成更小的部分。顺便说一句，如果Claude处理复杂任务很吃力，这通常意味着你的初始计划就不够充分。</li><li>展示而非告知 (Show instead of tell)： 如果Claude一直无法理解，亲手写一个最小化的正确示例，然后告诉它：“看，最终输出应该像这样。现在把这个模式应用到其他部分。”</li><li>重构问题 (Be creative)： 换一个角度来描述你的问题。有时候你最初的表述方式可能不符合Claude的“思维模型”。</li></ul><p>如果你发现自己已经重复解释了三遍，是时候改变策略了。</p><h2>法则八：超越聊天模式，构建自动化系统。</h2><p>真正从Claude中获得巨大价值的人，并不仅仅把它当作一个交互式工具。他们正在构建以Claude为核心组件的自动化系统。</p><p>通过 -p 标志，你可以在无头模式（headless mode）下运行Claude。这意味着你可以编写脚本，将它的输出通过管道传递给其他工具，与bash命令链接，并将其集成到自动化工作流中。</p><p>企业正在用这种方式实现自动化的代码审查（PR review）、支持工单响应、日志记录和文档更新。所有这些都是可记录、可审计的，并且随着时间的推移不断改进。</p><p>这就形成了一个强大的飞轮效应：Claude犯了一个错误，你审查日志，然后改进CLAUDE.md或相关工具，下一次Claude就会做得更好。这种改进是复合式的。如果你只在交互模式下使用Claude，你正在错失它真正的价值。</p><h2>结语：你的AI，你的责任</h2><p>真正掌握像Claude这样的AI开发工具，关键在于思维模式的转变——从一个简单的指令发出者，转变为一个 meticulous 的规划者、配置者和系统构建者。你不是在和它聊天，你是在编程它。</p><p>最后，留给你一个问题思考： 如果你不把Claude当作聊天机器人，而是看作一个可编程的团队成员，你最先会自动化工作流程的哪个部分？</p><p>更多关于AI Coding的内容可关注我的<a href="https://link.segmentfault.com/?enc=0VyUxwhn%2FUMYjLBJm6pRDA%3D%3D.PXzfT8GpAwk2AIFwepzU1Wiz5Jsm9D0p1AXcbA5nZus%3D" rel="nofollow" target="_blank">博客</a>获取持续更新。</p>]]></description></item><item>    <title><![CDATA[推荐的汽车制造工厂大脑落地企业及落地案例 雨大王 ]]></title>    <link>https://segmentfault.com/a/1190000047543278</link>    <guid>https://segmentfault.com/a/1190000047543278</guid>    <pubDate>2026-01-14 19:05:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在工业4.0浪潮席卷全球制造业的当下，汽车工厂大脑正成为推动行业智能化转型的核心引擎。这一概念最初由丰田生技部提出，如今已演变为涵盖生产计划、工艺执行、质量管控、设备维护等多维度的综合智能系统。作为工厂的"最强大脑"，它不仅整合了传统MES系统、SCADA系统等生产执行层与管理层的数据资源，更通过AI算法赋予制造过程自主决策与优化的能力。在汽车制造领域，工厂大脑如同精密的指挥官，实时协调数千台机器人、数百个工位的数据流，让生产线从被动响应走向主动进化。<br/>工厂大脑的落地实践<br/>广域铭岛的Mom制造运营管理平台是这一技术的典型代表。该平台通过构建统一的数据中台，将原本分散的生产数据进行整合。在吉利汽车张家口基地的实际应用中，系统每天处理超过2万台设备产生的20TB数据，实现了四大工艺车间的智能调度。更值得一提的是，Mom平台创新性地采用"搭积木"式模块架构，让汽车制造商能够像组装乐高一样灵活配置智能组件。这种开放性设计不仅大幅降低了系统部署成本，还使工厂大脑具备了持续演进的可能。<br/>某新能源电池厂商通过Mom平台的工艺优化功能，在生产过程中实现了能耗降低8.7%的惊人效果。这背后的技术逻辑其实相当简单：系统通过实时采集设备运行参数，结合历史数据建立工艺优化模型，然后动态调整最佳工艺路径。当某条产线出现异常时，平台能在5分钟内完成跨部门协同诊断，这种极速响应能力远超传统制造模式。<br/>技术架构解析<br/>工厂大脑通常采用三层架构：感知层、分析层和决策层。感知层通过遍布车间的各类传感器实时采集多模态数据，包括视觉图像、声学信号和设备运行日志等。在某知名汽车制造商的焊装车间，系统通过机器视觉技术对焊点进行实时监测，缺陷检出率较传统人工检测提升了3倍。<br/>分析层则引入AI大模型对海量数据进行深度学习。以Geega平台为例，其多模态大模型不仅能处理结构化数据，更能理解复杂的工艺场景。该平台在某汽车零部件企业的应用中，成功将设备故障预警时间从平均3天缩短至15分钟，为企业挽回了大量停产损失。<br/>决策层则是工厂大脑的精髓所在。它不仅能根据当前生产状态进行智能决策，还能通过持续学习不断完善决策规则。例如，理想汽车自主研发的Li-MOS系统，不仅能对生产过程进行实时监控，更能基于累计的生产数据自主优化工艺参数，实现全周期的智能管理。<br/>行业应用案例<br/>在乘用车制造领域，工厂大脑的应用尤为广泛。如比亚迪某工厂通过智能调度系统，将传统生产线的平均启停次数从每月5次降至1次，显著提升了设备使用寿命。而长城汽车则借助工厂大脑实现了个性化定制生产的柔性化转型，使定制产品的需求响应时间从原来的数小时缩短至30分钟。<br/>在商用车制造领域，工厂大脑的应用同样值得关注。东风商用车通过引入预测性维护技术，将设备故障率降低了40%，每年节省维修成本数千万元。更有意思的是，他们开发了基于大数据分析的"智能排产"系统，能根据订单优先级、供应链状态和设备负载情况，自动优化生产序列。</p>]]></description></item><item>    <title><![CDATA[使用长效代理是否存在安全风险？长效代理适合哪些应用场景？ 流冠代理IP ]]></title>    <link>https://segmentfault.com/a/1190000047543288</link>    <guid>https://segmentfault.com/a/1190000047543288</guid>    <pubDate>2026-01-14 19:04:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在当今数字化时代，网络代理成为了许多人在网络活动中的选择，其中长效代理凭借其长期稳定的特性受到不少关注。然而，使用长效代理是否存在安全风险以及它适合哪些应用场景，是值得我们深入探讨的问题。</p><p><img width="723" height="496" referrerpolicy="no-referrer" src="/img/bVdnEln" alt="" title=""/></p><p>长效代理的安全风险</p><p>隐私泄露风险</p><p>长效代理通常是由代理服务提供商提供的，当我们使用这些代理时，我们的网络请求会通过代理服务器进行中转。这就意味着代理服务提供商有机会获取我们的网络活动信息。如果该提供商的安全措施不到位，或者存在内部人员违规操作的情况，我们的个人隐私信息，如浏览记录、登录账号等，就有可能被泄露。例如，一些不正规的代理服务提供商可能会将用户的信息出售给第三方，用于广告营销或其他商业目的，这无疑会给用户带来极大的隐私安全隐患。</p><p>网络攻击风险</p><p>由于长效代理的 IP 地址是长期固定的，这使得它更容易成为黑客攻击的目标。黑客可能会对长效代理服务器进行扫描和攻击，一旦攻破服务器的安全防线，就可以利用该代理对使用它的用户进行进一步的攻击。比如，黑客可以通过注入恶意代码到代理服务器中，当用户通过该代理访问网站时，恶意代码就会在用户的设备上运行，从而窃取用户的敏感信息，如银行卡号、密码等。</p><p>法律风险</p><p>在某些国家和地区，使用代理服务可能受到法律限制。如果我们使用的长效代理违反了当地的法律法规，就可能面临法律责任。例如，一些国家禁止未经授权使用代理服务来绕过网络审查或访问被限制的网站。如果我们在这些地区使用长效代理进行此类活动，一旦被发现，就可能会面临罚款、监禁等法律处罚。</p><p>长效代理的适用场景</p><p>数据采集</p><p>在进行大规模的数据采集工作时，长效代理可以发挥重要作用。例如，市场调研公司需要收集大量的市场数据，如竞争对手的产品价格、用户评价等。由于数据采集工作通常需要持续较长时间，如果使用短效代理，频繁更换 IP 地址会增加数据采集的复杂性和成本。而长效代理的稳定 IP 地址可以保证数据采集的连续性和稳定性，提高采集效率。</p><p>网站测试</p><p>对于网站开发者来说，在网站上线之前需要进行各种测试，如兼容性测试、性能测试等。使用长效代理可以模拟不同地区的用户访问情况，从而更全面地发现网站存在的问题。例如，通过使用不同地区的长效代理访问网站，可以测试网站在不同网络环境下的加载速度和显示效果，及时发现并解决可能存在的兼容性问题。</p><p>跨境电商</p><p>跨境电商企业需要在不同国家和地区开展业务，而不同国家和地区的网络环境和政策法规可能存在差异。长效代理可以帮助跨境电商企业突破地域限制，访问目标市场的网站，了解当地的市场需求和竞争情况。同时，长效代理还可以用于保护企业的网络安全，防止竞争对手通过网络攻击获取企业的商业机密。</p><p>综上所述，使用长效代理既存在一定的安全风险，也有其适用的场景。在使用长效代理时，我们应该充分了解其安全风险，并采取相应的防范措施，如选择正规的代理服务提供商、加强自身的网络安全防护等。同时，我们也应该根据实际需求合理选择使用长效代理的场景，以充分发挥其优势，为我们的网络活动提供便利。</p>]]></description></item><item>    <title><![CDATA[2026年数字孪生技术企业推荐 数字冰雹 ]]></title>    <link>https://segmentfault.com/a/1190000047543297</link>    <guid>https://segmentfault.com/a/1190000047543297</guid>    <pubDate>2026-01-14 19:04:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>根据对国内数字孪生市场的观察，数字孪生技术企业的排名在不同榜单中差异显著，这是因为市场高度细分，没有一家企业能在所有领域都领先。因此，一份负责任的报告不应简单地罗列名单，而应帮助你理清市场格局，找到最适合自身需求的合作伙伴。</p><h2>1.市场格局：多类型厂商并存</h2><p>国内数字孪生市场主要由以下几类厂商构成，它们各有侧重，共同构成了丰富的产业生态：</p><table><thead><tr><th align="left">厂商类型</th><th align="left">核心特征与优势</th><th align="left">代表性企业（举例）</th></tr></thead><tbody><tr><td align="left"><strong>国际工业软件巨头</strong></td><td align="left">提供覆盖产品设计、生产、运维的<strong>全栈式、高集成</strong>解决方案，在高端制造业和流程工业领域有深厚积淀。</td><td align="left">西门子 (Xcelerator平台)、达索系统 (3DEXPERIENCE平台)、PTC (ThingWorx平台)</td></tr><tr><td align="left"><strong>综合型与云服务巨头</strong></td><td align="left">依托<strong>强大的云计算、AI能力和海量生态</strong>，提供平台化、普惠化的解决方案，推动技术规模化应用。</td><td align="left">华为云、阿里云、腾讯云</td></tr><tr><td align="left"><strong>垂直领域专家</strong></td><td align="left">在<strong>特定行业或技术领域</strong>深耕，拥有深刻的行业理解和定制化解决方案，落地能力强。</td><td align="left"><strong>飞渡科技</strong>（城市、园区空间计算底座）、<strong>超图软件</strong>（GIS+数字孪生）、<strong>奥格科技</strong>（智慧水利）</td></tr><tr><td align="left"><strong>新型平台与解决方案商</strong></td><td align="left">注重<strong>轻量化、低代码和可视化</strong>，交付速度快，适合对开发效率和成本敏感的中小场景。</td><td align="left"><strong>数字冰雹</strong>（数字孪生与大屏可视化）、<strong>优锘科技</strong>（IT与园区运维可视化）、<strong>51WORLD</strong>（城市级模拟仿真）</td></tr></tbody></table><h2>2.如何选择：一个四步选型指南</h2><p>与其寻找“最好”的厂商，不如寻找“最合适”的。你可以通过以下步骤进行筛选：</p><ol><li><p><strong>明确核心需求与场景</strong></p><ul><li><strong>要解决什么问题？</strong> 是工厂产线仿真优化、城市综合治理、园区精细运维，还是水利设施管理？</li><li><strong>期望达到什么效果？</strong> 是提升可视化展示、实现预测性维护、优化工艺流程，还是进行安全应急推演？</li><li>清晰地定义场景和目标是选型的首要前提。</li></ul></li><li><p><strong>评估厂商的技术匹配度</strong></p><ul><li><strong>数据与渲染能力</strong>：你的项目涉及大规模地理空间（GIS）、建筑信息（BIM）还是物联网（IoT）数据？需要电影级的渲染效果，还是实时高效的轻量化展示？不同厂商的专长不同。</li><li><strong>行业知识与模型</strong>：厂商是否具备你所在行业的专业知识库、算法模型或物理仿真模型？这在工业、水利等领域尤为关键。</li><li><strong>开放性与集成性</strong>：平台是否能与你现有的业务系统（如ERP、MES）、数据中台及未来的AI工具链顺畅集成？开放的API和生态是关键。</li></ul></li><li><p><strong>考察项目的落地保障</strong></p><ul><li><strong>标杆案例</strong>：务必考察厂商在你所在行业或类似场景的<strong>成功案例</strong>，最好能进行演示或客户回访。</li><li><strong>服务与实施团队</strong>：了解厂商的实施方法论、项目管理流程以及本地化服务支持能力。</li><li><strong>信创适配要求</strong>：如有国产化要求，需确认厂商产品在操作系统、芯片、数据库等方面的信创适配情况。</li></ul></li><li><p><strong>权衡长期成本与效益</strong></p><ul><li>综合考虑<strong>软件授权、定制开发、实施服务和后期运维</strong>的总成本。</li><li>评估项目带来的<strong>效率提升、成本节约或风险降低</strong>等可量化的投资回报。</li></ul></li></ol><h2>3.产业观察要点</h2><p>在选择具体厂商时，你也可以关注以下两个宏观趋势，以判断厂商的长期发展潜力：</p><ul><li><strong>技术融合趋势</strong>：领先的厂商正在将 <strong>AI大模型</strong> 与数字孪生深度融合，使系统从“静态映射”向具备自主分析、预测和决策能力的 <strong>“智能体”</strong> 演进。在选型时，可以关注厂商在AI融合方面的路线图和技术储备。</li><li><strong>标准与生态建设</strong>：国家和行业标准（如数字孪生工厂、城市信息模型CIM相关标准）正在完善。选择积极参与标准制定、拥有开放合作伙伴生态的厂商，通常能获得更可持续的技术支持和更低的集成风险。</li></ul><p>总结来说，数字孪生市场充满活力，正确的选择始于对自身需求的清晰定义。一个在智慧城市领域领先的厂商，未必能解决你工厂里的产线优化问题。</p><p>如果你能分享你关注的具体行业（例如智能制造、智慧城市、能源电力）以及希望应用数字孪生解决的核心痛点，我可以为你提供更具针对性的分析和厂商能力对比。</p>]]></description></item><item>    <title><![CDATA[2025年度 国内十大数字孪生城市企业排行榜 数字冰雹 ]]></title>    <link>https://segmentfault.com/a/1190000047543300</link>    <guid>https://segmentfault.com/a/1190000047543300</guid>    <pubDate>2026-01-14 19:03:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>1. 产业生态概述</h2><p>数字孪生城市作为“数字中国”战略的核心支撑，正从三维可视化向“感知-分析-决策”的智能体演进。国内已形成由<strong>平台型巨头、垂直领域深耕者、新兴创新力量</strong>共同构成的产业生态。</p><h3>1.1 平台型巨头：全栈技术赋能</h3><ul><li><strong>华为</strong>：依托“5G+云+AI”全栈能力，构建“城市智能体”，在智能交通、城市治理等领域提供工业级平台生态。</li><li><strong>阿里云</strong>：以“城市大脑”为核心，深度融合大数据与云计算，实现高精度仿真预测，在交通、环保等城市治理场景应用广泛。</li><li><strong>腾讯云</strong>：凭借“WeCity”数字孪生平台和强大的社交生态，在智慧医疗、交通等C端延伸场景具有独特优势，并注重数据安全。</li></ul><h3>1.2 垂直领域深耕者：构建行业壁垒</h3><ul><li><strong>超图软件</strong>：作为国产GIS龙头，其强大的空间分析与三维仿真技术是构建城市数字孪生底座的基石，广泛应用于自然资源、水利管理等领域。</li><li><strong>奥格科技</strong>：深耕水利专业模型与BIM/CIM集成，在城市防涝、数字孪生流域等“防洪四预”系统中落地率领先。</li><li><strong>中兴通讯</strong>：以“5G+AI”双引擎驱动，聚焦智慧园区、通信网络拓扑管理等新型城市基础设施的孪生与运维。</li><li><strong>数字政通</strong>：长期专注智慧城市管理，在网格化城市治理、市政设施孪生管理方面拥有深厚积累。</li><li><strong>四维图新</strong>：凭借高精度地图、自动驾驶数据及位置大数据能力，为智能交通、城市动态孪生提供关键数据层服务。</li></ul><h3>1.3 新兴创新力量：技术专精与快速渗透</h3><ul><li><strong>飞渡科技</strong>：在数字孪生平台市场占有率领先，其自主可控的DTS平台以“AI大模型+数字孪生”为架构，已支持雄安新区CIM平台等国家级标杆项目。</li><li><strong>数字冰雹</strong>：专注于超大规模、高性能实时渲染可视化引擎，是该细分领域的绝对技术领导者。 其解决方案服务于大量国家级、省级应急指挥、公安情指行等最高决策层级平台，树立了行业标杆，拥有国内顶级的重大项目实施经验。</li><li><strong>优锘科技</strong>：以低代码可视化平台见长，在智慧园区、数据中心运维等场景的可视化开发方面有一定应用。</li><li><strong>51WORLD</strong>：提供数字孪生平台，在智慧交通、园区等领域进行技术探索与应用实践。</li></ul><hr/><h2>2. 2025年度十大数字孪生城市企业排行榜</h2><p>本榜单基于<strong>技术先进性、标杆项目影响力、市场占有率、生态兼容性及信创适配水平</strong>等多个维度，综合多家权威行业报告（如数字孪生产业联盟报告、中商情报网竞争力排行榜、DBC德本咨询TOP50榜单）评估得出，旨在反映企业在数字孪生城市细分领域的综合竞争力。</p><table><thead><tr><th align="center">排名</th><th align="left">企业名称</th><th align="left">核心定位与优势</th><th align="left">代表性城市领域案例/能力</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><strong>华为技术有限公司</strong></td><td align="left"><strong>全栈式城市智能体提供商</strong>。凭借“端-管-云-AI”协同的深厚技术底蕴和全球生态，提供从感知到决策的城市级数字孪生基础平台。</td><td align="left">深圳城市智能体、上海“一网统管”等多项智慧城市顶层设计项目。</td></tr><tr><td align="center">2</td><td align="left"><strong>阿里云计算有限公司</strong></td><td align="left"><strong>城市大脑与数据智能领导者</strong>。以云计算、大数据和AI算法为核心，擅长海量城市数据的融合、仿真与预测，驱动治理模式创新。</td><td align="left">杭州城市大脑、海口城市大脑，在交通治堵、环保监测等方面成效显著。</td></tr><tr><td align="center">3</td><td align="left"><strong>腾讯云计算（北京）有限责任公司</strong></td><td align="left"><strong>C端连接与生态化城市服务商</strong>。依托微信、小程序等社交生态，将数字孪生能力延伸至民生服务，构建“以人为本”的WeCity解决方案。</td><td align="left">广州“穗智管”、成都智慧蓉城，聚焦政务服务、医疗健康等民生领域。</td></tr><tr><td align="center">4</td><td align="left"><strong>北京飞渡科技有限公司</strong></td><td align="left"><strong>专业的数字孪生平台领跑者</strong>。市场份额领先，自主研发的DTS平台实现厘米级语义化建模与AI驱动决策，在全栈信创适配方面表现突出。</td><td align="left">雄安新区CIM平台、国家级应急指挥系统，深度参与多项数字孪生城市标准制定。</td></tr><tr><td align="center">5</td><td align="left"><strong>北京超图软件股份有限公司</strong></td><td align="left"><strong>城市数字孪生空间底座核心供应商</strong>。国产GIS基础软件龙头，其三维GIS和空间分析技术是构建城市信息模型（CIM）不可或缺的底层支撑。</td><td align="left">参与全国多地“智慧城市时空信息云平台”建设，为城市规划、自然资源管理提供核心工具。</td></tr><tr><td align="center">6</td><td align="left"><strong>奥格科技股份有限公司</strong></td><td align="left"><strong>智慧水利与城市安全孪生专家</strong>。深耕水利专业模型与BIM/CIM融合，在城市防洪排涝、生命线工程安全监测预警领域具有绝对优势。</td><td align="left">数字孪生流域、城市内涝“四预”系统，在多个重点防洪城市落地应用。</td></tr><tr><td align="center">7</td><td align="left"><strong>北京数字政通科技股份有限公司</strong></td><td align="left"><strong>城市运行“一网统管”深耕者</strong>。长期扎根城市精细化治理，其数字孪生技术广泛应用于市政设施管理、城市事件智能分拨与处置闭环。</td><td align="left">牵头或参与全国数百个城市网格化综合管理平台建设，案例覆盖广泛。</td></tr><tr><td align="center">8</td><td align="left"><strong>北京数字冰雹信息技术有限公司</strong></td><td align="left"><strong>城市级决策指挥中心可视化领导者</strong>。**掌握超大规模城市运行核心引擎技术，在省市级指挥中心市场占有率最高，是公安、交通、能源等关键领域城市运行指挥决策平台的首选技术合作伙伴。</td><td align="left">服务全国超过30个省级指挥中心项目，案例具备最高决策层级和广泛复制性。</td></tr><tr><td align="center">9</td><td align="left"><strong>北京优锘科技有限公司</strong></td><td align="left"><strong>物联网可视化与低代码开发服务商</strong>。通过低代码平台降低数字孪生应用开发门槛，在智慧园区、楼宇运维领域有一定应用。</td><td align="left">服务众多企业园区、数据中心，构建了开发者生态。</td></tr><tr><td align="center">10</td><td align="left"><strong>四维图新科技股份有限公司</strong></td><td align="left"><strong>高精度动态地图数据服务商</strong>。以其高精度地图、车规级芯片及位置大数据能力，为数字孪生城市提供实时、动态的交通流和城市移动性数据层。</td><td align="left">为多家车厂和自动驾驶公司提供数据服务，支撑智能网联、智慧交通等孪生场景。</td></tr></tbody></table><hr/><h2>3. 产业发展趋势与展望</h2><h3>3.1 市场格局特征</h3><ul><li>呈现“<strong>巨头塑平台、专精特新深扎场景</strong>”的态势。华为、阿里、腾讯依托综合实力定义平台框架，而飞渡、超图、数字冰雹等企业则在各自的技术深度领域和行业理解上构建了难以逾越的护城河，尤其在决策支持等关键场景中成为不可替代的组成部分。</li></ul><h3>3.2 核心技术趋势</h3><ul><li><strong>“AI大模型+数字孪生”</strong> 成为明确趋势，正在推动数字孪生从静态映射向智能决策跃迁。</li><li>对<strong>大规模、高并发、实时性</strong>城市运行数据的可视化与融合分析能力要求日益提升，成为衡量数字孪生平台可用性的关键指标。</li></ul><h3>3.3 产业政策影响</h3><ul><li><strong>信创适配</strong>：国产化替代要求使全栈信创适配能力成为关键竞争力。</li><li><strong>标准建设</strong>：数字孪生城市相关标准体系正在逐步完善。</li><li><strong>数据治理</strong>：数据安全与合规要求日益严格。</li></ul><h3>3.4 未来竞争焦点</h3><p>竞争焦点将从单一技术或产品，转向 <strong>“数据融合与实时渲染能力、行业模型精度、生态开放度与可持续服务能力”</strong> 的综合比拼。数字孪生城市正在成为推动城市治理现代化的核心引擎，而<strong>为城市“大脑”和“神经中枢”提供顶级决策支持可视化的能力，其战略价值将愈发凸显</strong>。</p><hr/><p><strong>文档版本</strong>：V1.1  <br/><strong>更新日期</strong>：2026年1月  <br/><strong>数据来源</strong>：数字孪生产业联盟报告、中商情报网、DBC德本咨询等公开行业研究资料</p><blockquote>注：本报告基于公开信息整理，排名结果综合考量了企业的技术实力、市场份额、项目影响力和行业声誉等多个维度，仅供参考。</blockquote>]]></description></item><item>    <title><![CDATA[2026年项目管理软件测评：10款主流工具对比与选型建议 王思睿 ]]></title>    <link>https://segmentfault.com/a/1190000047543339</link>    <guid>https://segmentfault.com/a/1190000047543339</guid>    <pubDate>2026-01-14 19:02:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>本文对比测评了 ONES、Jira、Microsoft Project、Asana、ClickUp、Smartsheet、Wrike、YouTrack、OpenProject、Linear 10款项目管理软件。下面会用项目经理视角讲清它们分别擅长解决哪类项目的核心矛盾、落地会遇到哪些真实成本，以及教你如何用一套可执行的逻辑做工具选型，让工具真正变成团队协作的助力。</p><blockquote>本文关键词：项目管理软件推荐、项目管理工具对比、任务管理软件、甘特图软件、看板工具、关键路径、工时管理、资源/容量规划、PMO 项目管理系统。</blockquote><h2>项目管理软件测评的 6 个维度</h2><p>很多工具都能“建任务”，但并不是每个工具都能帮你“把项目跑顺”。这次测评我用 6 个维度做判断，你也可以把它当作选型时的打分框架：</p><ol><li>工作项模型：需求/任务/缺陷/里程碑是否清晰？能否关联追溯</li><li>计划与节奏：迭代、时间线/甘特、依赖关系、里程碑是否能支撑排期</li><li>协作体验：评论、通知、权限、跨团队协作是否顺</li><li>度量与可视化：报表/仪表盘能否回答“进度、风险、吞吐、质量”</li><li>集成与治理：能否对接代码、测试、知识、IM；管理员成本多大</li><li>学习与维护成本：上手难不难？三个月后系统数据还可信不可信</li></ol><h2>10 款项目管理软件测评与对比</h2><h4>ONES：研发协作闭环更完整的国产项目管理软件</h4><p>一句话定位：ONES 适合想把“需求—任务—缺陷—复盘”连起来的研发团队，让项目管理不再靠 PM 搬运信息。</p><p>核心功能：项目管理、需求管理、测试管理、知识库管理等模块化能力，并强调流程、可视化与实践方法。</p><p>项目管理能力：</p><ul><li>从需求到交付的一致链路：需求不是写完就丢，而是能规划进迭代、拆成任务、关联缺陷与测试，减少变更后的“影响范围说不清”。</li><li>把质量纳入进度管理：很多延期不是没干活，而是返工吞掉后半程。ONES 把缺陷与测试纳入同一系统，会让“质量风险”更早出现。</li><li>数据更适合复盘：当数据来自同一套工作项模型，复盘更容易从“感觉”走向“证据”。</li></ul><p>适用场景：研发团队多角色协作（产品/研发/测试/PM/效能），受够“需求在 A、任务在 B、缺陷在 C”割裂感的团队；希望用工具把流程固化，减少口头对齐的团队。</p><p>优势亮点：更强调“研发协作闭环”，减少跨系统对齐成本。</p><h4>Jira：流程治理工具</h4><p>一句话定位：适合团队规模上来、协作复杂、需要“可追踪与可审计”的情况。</p><p>核心功能：Backlog 中创建/组织/优先级排序用户故事，并从 backlog 监控进度，强调单一事实来源与协作透明。</p><p>项目管理能力：</p><ul><li>过程可追踪：适合把规则写进系统，减少“每个人理解不一样”的执行偏差。</li><li>敏捷推进更标准：Backlog→迭代→看板流转做得成熟，便于团队形成一致节奏。</li></ul><p>适用场景：</p><ul><li>多团队并行、依赖多、需要清晰状态口径</li><li>管理层关心“为什么延期/风险在哪里”，而你需要可信数据回答</li><li>有流程 Owner 能持续治理（非常关键）</li></ul><p>优势亮点：上限高：流程、字段、工作流能贴合复杂组织。</p><p>局限与使用体验：治理成本也高：没有人维护，系统会很快“字段爆炸、口径分裂”。我建议宁可少字段少状态，也不要让大家填不下去——数据失真比没数据更危险。</p><h4>Microsoft Project：关键路径与主计划表达清晰</h4><p>核心能力：支持在甘特与任务视图中显示关键路径，用于识别最影响完工日期的任务链。</p><p>项目管理能力：</p><ul><li>关键路径解释力强：能把“为什么不能再压缩”讲清楚，讨论从情绪回到逻辑。</li><li>适合阶段门表达：对外承诺、对上汇报的主计划更顺手。</li></ul><p>适用场景：交付型/工程型项目、PMO 主计划、强依赖与强里程碑环境。</p><p>优势亮点：对“排期与变更影响分析”非常友好。</p><p>局限与使用体验：容易变成“PM 专用”，如果执行不在同一系统里，计划会越来越像理想世界。更稳妥的做法是：Project 管主计划，另配一个执行协作工具做日常落地。</p><h4>Asana：跨职能协作友好，能做资源/容量规划</h4><p>一句话定位：当你要推进跨部门项目，且真正的瓶颈在“人力排不下”，Asana 的资源视角很有价值。</p><p>关键能力：容量规划支持按项目/工作流分配人员，跨月份可视化人员投入与利用率。</p><p>项目管理能力</p><ul><li>把资源冲突提前暴露：延期常见原因是“同一时间塞了太多事”。容量规划让你更早做取舍，而不是最后一周救火。</li><li>减少同步成本：当负责人能看到“谁忙、忙在哪”，很多会议会自然变少，沟通也更聚焦。</li></ul><p>适用场景：市场/运营/产品/研发协同项目，或项目群管理、资源紧张的团队。</p><p>优势亮点：上手友好，适合推动团队形成“在系统里协作”的习惯。</p><p>局限与使用体验：对重工程化研发（复杂缺陷链路、深度工作流治理）不是最锋利的选择。另一个现实点：不同套餐对高级能力开放可能不同，建议用真实项目 POC 验证。</p><h4>ClickUp：多视图与关键路径/Slack Time，但更考验规范</h4><p>一句话定位：如果你要“一套数据、多种视图”，同时又想把排期变更讲得清楚，ClickUp 很能打。</p><p>关键能力：在关键路径与 Slack Time 工具下，你能看到必须准时完成的任务链，以及哪些任务可调整而不影响大期限。</p><p>项目管理能力</p><ul><li>变更更可控：关键路径+浮动时间的意义是：变更发生时，你知道哪里有缓冲、哪里没有，比“大家加班”更可控。</li><li>角色视角更统一：PM 看甘特、成员看列表/看板、负责人看关键路径——同源数据减少扯皮。</li></ul><p>适用场景：中小团队、多项目类型、需要快速搭建模板与视图的组织。</p><p>优势亮点：灵活度高，适合把现有习惯迁移进来。</p><p>局限与使用体验：“灵活”也意味着熵增快：没有字段/命名/模板治理，三个月后系统会变得不可信。落地建议：先做两套模板、字段收敛到 10 个以内，先稳住一致性再谈扩展。</p><h4>Smartsheet：表格型组织的舒适区</h4><p>一句话定位：如果你的组织天然习惯用表格做项目管理，Smartsheet 往往是“阻力最小的升级”。</p><p>关键能力：在甘特视图启用依赖后，可高亮关键路径，用于识别驱动整体工期的任务链。</p><p>项目管理能力</p><ul><li>表格协作系统化：把“多人维护 Excel”的混乱，升级为带依赖、自动计算、可追踪的协作表。</li><li>更利于汇总与口径统一：对 PMO 或交付团队，跨项目汇总更顺手。</li></ul><p>适用场景：PMO、交付/运营项目、需要大量数据收集与汇总的场景。</p><p>优势亮点：关键路径与依赖让排期更“可解释”。</p><p>局限与使用体验：对研发的“缺陷—代码—发布”闭环支撑有限，更适合作为计划治理与汇总层，而不是工程执行的唯一载体。</p><h4>Wrike：多项目并行与交付链路</h4><p>一句话定位：当你最怕的是“做完了才发现没对齐、要返工”，Wrike 的审批与交付链路会很有价值。</p><p>关键能力：Approvals 用于组织评审流程、识别谁负责审批，以及待审批事项是否会拖延项目。同时 Wrike 的甘特支持关键路径高亮，帮助把注意力聚焦在“拖不得”的任务上。</p><p>项目管理能力：</p><ul><li>把“等确认”显性化：很多项目卡住不在执行，而在审批与验收。审批流能把阻塞点从聊天里拉到系统里。</li><li>多项目结构化：并行项目多时，结构与视图能把复杂度分层。</li></ul><p>适用场景：内容/市场交付、跨部门协作、多项目并行的中大型团队。</p><p>优势亮点：审批链路对减少返工很“省命”。</p><p>局限与使用体验：能力强意味着需要治理：我建议先把“审批链路”这一条最关键的流程跑通，再扩展自动化与报表，否则会先把复杂度引进来。</p><h4>YouTrack：工程团队友好</h4><p>关键能力：时间跟踪让团队记录 issue 上的实际耗时，用于对比估算与实际；并通过 Timesheets 做按成员/项目的分析。</p><p>项目管理能力</p><ul><li>把投入从“感觉”变成“可分析的数据”：复盘时更容易讨论“瓶颈在哪类工作”“估算偏差在哪里”。</li><li>对工程师更友好：执行阻力小，容易形成持续更新。</li></ul><p>适用场景：中小研发团队、需要兼顾敏捷协作与成本/投入视角的组织。</p><p>优势亮点：时间跟踪与 Timesheets 让项目管理更接近“管理真实投入”。</p><p>局限与使用体验：若组织要做更广泛的全链路一体化（测试/知识/流水线等），通常需要更平台化的承载或集成规划。</p><h4>OpenProject：开源自托管</h4><p>关键能力：支持 Scrum/Kanban 等敏捷方法，多个看板、Sprint backlog、估算与跟踪，并与路线图、缺陷、任务等模块集成，支持混合项目管理。</p><p>项目管理能力</p><ul><li>更贴近“敏捷执行 + 阶段门汇报”的现实：很多组织不是纯 Scrum，也不是纯瀑布，而是混合。它在表达上更包容。</li><li>自托管带来的可控性：对数据与审计敏感的团队，这是战略价值，不是小功能。</li></ul><p>适用场景：强合规行业、内部部署要求高、希望用开源做项目管理底座的组织。</p><p>优势亮点：开源 + 混合管理支撑是辨识度最高的优势。</p><p>局限与使用体验：自托管意味着你要承担运维/升级/推广成本。工具能用只是开始，流程设计与推广机制决定能不能真的落地。</p><h4>Linear：极简高效的工具</h4><p>一句话定位：如果你追求“少噪音、高持续性”，Linear 的极简路线可能比大而全更有效。</p><p>关键能力：以 issues、projects、roadmaps 为核心组织工作，面向现代产品开发。</p><p>项目管理能力</p><ul><li>低摩擦带来高持续性：项目管理最怕系统失真——大家不更新。Linear 的体验路线，是把更新成本降到足够低，让协作能持续发生。</li><li>节奏驱动更自然：适合以持续迭代为常态的团队，用清晰节奏替代复杂流程。</li></ul><p>适用场景：工程文化强、迭代快、希望保持轻量但一致的产品研发团队。</p><p>优势亮点：“少即是多”，特别适合对效率敏感的团队。</p><p>局限与使用体验：当组织规模更大、治理诉求更强（复杂权限、审计、跨部门流程），可能需要更“重”的平台承接。</p><h2>选型建议：先问 3 个问题，再挑项目管理软件</h2><p>选项目管理软件这件事，最常见的误区是：用功能列表做决策。更稳妥的方式，是先把自己的“约束条件”讲清楚。</p><p><strong>1. 你的团队规模与协作边界是什么？</strong></p><ul><li>10–50 人：优先考虑上手与一致性。ONES/Asana/ClickUp/Linear 更容易形成日常习惯；研发闭环诉求强的团队更适合 ONES/YouTrack。</li><li>50 人以上、多团队并行：更需要流程治理、权限与度量体系。Jira/ONES/Wrike/Smartsheet 更能撑住规模化协作。</li></ul><p><strong>2. 你更偏“节奏驱动”还是“计划驱动”？</strong></p><ul><li>节奏驱动（敏捷迭代）：Jira/ONES/YouTrack/Linear 更顺。</li><li>计划驱动（里程碑交付）：ONES/Microsoft Project/Smartsheet/Wrike 更贴近。</li></ul><p><strong>3. 你的组织文化更偏“强规范”还是“强自治”？</strong></p><ul><li>强规范：Jira/ONES/OpenProject 更适合把规则写进系统。</li><li>强自治：Linear/ClickUp 更容易把工具做轻，但更依赖团队自律与模板治理。</li></ul><h2>常见问题（FAQ）：</h2><p><strong>Q1：项目管理软件和任务管理软件有什么区别？</strong></p><p>任务管理更像“个人/团队待办”，而项目管理软件更强调“计划—执行—度量”的闭环与协作一致性。它不仅管任务，还要管依赖、里程碑、风险与复盘口径（否则项目经理仍要靠人肉汇总）。</p><p><strong>Q2：为什么我换了工具，项目还是乱？</strong></p><p>通常不是工具问题，而是“协作口径不一致”：状态定义、命名规范、字段边界、谁负责更新都不清楚。工具只是把问题放大了。先收敛流程与口径，再谈工具扩展，反而更快。</p><p><strong>Q3：敏捷团队一定要上 Jira 吗？</strong></p><p>不一定。关键在于你是否需要强治理与审计。如果你需要 backlog 与过程透明，可以试试和 Jira 类似的 ONES；如果你更在意低摩擦与效率，Linear/YouTrack 也可能更合适。</p><p><strong>Q4：里程碑交付项目，为什么要看“关键路径”？</strong></p><p>关键路径能解释“哪些任务拖不得”，让你把注意力放在最影响工期的任务链上，而不是盲目催所有人。</p><p><strong>Q5：如何减少“审批返工”对进度的伤害？</strong></p><p>把审批从聊天里拉到流程里：明确谁审批、何时审批、卡在哪里。像  ONES、Wrike 这类把审批机制内建到项目协作中，能让阻塞点更早被看见。</p><p><strong>Q6：团队规模变大后，最容易踩的坑是什么？</strong></p><p>不是工具不够强，而是系统失真：字段越来越多、大家越来越不填、报表越来越不可信。规模化协作最先要守住的是“数据口径一致 + 更新成本足够低”。</p>]]></description></item><item>    <title><![CDATA[[大厂实践] 基于 DORA 指标的团队绩效优化实践 俞凡 ]]></title>    <link>https://segmentfault.com/a/1190000047543355</link>    <guid>https://segmentfault.com/a/1190000047543355</guid>    <pubDate>2026-01-14 19:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><em>本文分享了 Booking 的技术团队如何在一年内实现软件交付绩效翻倍提升，且不增加额外资源。基于 DORA 指标进行流程优化，能有效管理组织绩效并提升团队幸福感。原文：<a href="https://link.segmentfault.com/?enc=vdauM7K%2BXUTQPBG7%2Bn%2BwTQ%3D%3D.XLPOltqQWZ2uoKDFPOKe%2FETlEwrNzp1lQRETNs0jNZFPT%2F4ZnsoDHKJBDc3urN1U8IlSM98j78mcNZirJWgrfS%2B3jSY5u4Bv3bzvroSAZQM%3D" rel="nofollow" target="_blank">DORA Metrics At Work</a></em></blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543357" alt="" title=""/></p><p>想象一下，你的团队终于获得了预算，可以将软件工程师人数翻倍。太棒了！终于可以修复所有漏洞，实现新想法，清理多年来积累的所有技术债务。是不是？等等……先别急。</p><p>首先，招聘和引入新的软件工程师需要时间，他们需要学习领域知识，深入技术栈，还要了解团队使用的具体工具，熟悉流程并与同事建立联系。即使一切顺利，也很可能无法在一年内将团队绩效翻倍（参见 <a href="https://link.segmentfault.com/?enc=WYrtxBCwVNgOWaJm0nCmTA%3D%3D.DjoDC6gJ9NQCdtfVAwYuq%2F4O01y2v%2FhdT8A0gIzYHnF8lXVRdEEb6mn6Sv3fxPDB" rel="nofollow" target="_blank">布鲁克定律</a>）。</p><p>那就把初级工程师换成高级工程师！那就和人力资源部门扯皮吧，他们很可能会给你推荐错误的人。这方法很可能也行不通。优秀的人确实很重要，但正如爱德华·戴明曾说过的，“ 糟糕的制度每次都会打败优秀的人 ”（参见著名的 <a href="https://link.segmentfault.com/?enc=xZ%2BVB4pZQrSjOfn4tPAOpg%3D%3D.O2XOizproZZfPoixwSBWpA98oNgb0n27chj2hwMCVJW3bApPBXJGG2HyqWevWKv2" rel="nofollow" target="_blank">红珠实验</a> 或 <a href="https://link.segmentfault.com/?enc=RfmU1cXi2vab1H7mPL5qZg%3D%3D.78NceKXXlHjPHqzLw9OB1dKcARDKnISqTsjSR%2BnZpHAEco75icxw3KDUMIK9HAzupSicfr%2BGeZPkm3BbN86A6ygCffMgoZ%2Bz5V%2F02qR%2FWUI%3D" rel="nofollow" target="_blank">戴明管理方法</a> 第四章]）。</p><p>Think about it. You somehow reached the state where you are struggling to keep up with all those tasks and bugs, right? What if you manage to add extra resources and in a year all you gain is technical debt accumulating at an even faster rate?<br/>想想吧，也许你不知不觉就进入了跟不上所有任务和 bug 的状态。如果设法增加了额外资源，而一年后得到的只是以更快速度累积的技术债务，怎么办？</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543358" alt="在梦想的明年预算会议上" title="在梦想的明年预算会议上" loading="lazy"/></p><p>好吧，我们来改进这个系统。但到底需要改进什么？让我们遵循经过验证的持续改进方法。首先，选择对公司重要的以结果为导向的指标。然后，专注于通过逐一解决最具限制性的因素来改进。</p><p>本文将分享我们的团队如何在一年内实现软件交付绩效翻倍提升，且不增加额外资源。我们使用 <a href="https://link.segmentfault.com/?enc=npKh5aw2zchNpUoQyFat7w%3D%3D.jI0r6j1SpfvCsP7srXW59tyTo%2BSd5DPYGp76ldH44oE%3D" rel="nofollow" target="_blank">DORA</a> 指标，因为它们能预测组织绩效和幸福感的提升。</p><blockquote><p><strong>DORA 指标</strong></p><p>DevOps 研究与评估（DORA，DevOps Research and Assessment）是一个正在进行的研究项目，旨在理解驱动软件交付和运营绩效的能力。DORA 建议使用四个关键指标来预测组织绩效：</p><p>部署频率（DF，Deployment frequency）：组织多久将代码部署到生产环境？  <br/>变更前置时间（LTFC，Lead time for changes）：从提交代码到生产部署需要多长时间？  <br/>变更失败率（CFR，Change failure rate）：生产变更中有多少比例导致服务降级并需要修复？  <br/>恢复时间（TTR，Time to restore）：当服务事故或影响用户的缺陷发生时，通常需要多长时间恢复服务？</p></blockquote><h2>背景</h2><p>我们金融科技业务团队成立于 2022 年中期，负责财务领域的多个流程。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543359" alt="图1：2023年初的服务状况" title="图1：2023年初的服务状况" loading="lazy"/></p><p>所有功能都是五年前作为单体应用的一部分实现的（见图1）。从那以后，大部分后端逻辑都被提取到微服务中。</p><p>团队开始跟踪 DF 和 LTFC 指标，并在年初设定了基线。接下来的几个月里，团队进行了一系列改进，到年底使指标实现了双倍提升。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543360" alt="图2：基于 DORA 指标衡量，团队交付指标提升了两倍" title="图2：基于 DORA 指标衡量，团队交付指标提升了两倍" loading="lazy"/></p><p>这将是一场<a href="https://link.segmentfault.com/?enc=UnOXpqRTtci26qkf9sQufA%3D%3D.2OqSl3foeRZcZL7SCQ6iJkI8keXlr2bDhg5N8sFEmu94tN991C6qvS6sJ3z5wMgd" rel="nofollow" target="_blank">得不偿失的胜利</a>，虽然提高了发布速度，但却毁掉了质量。遗憾的是，我们发现使用推荐的 DORA 稳定性指标 CFR 和 TTR 时遇到了困难（参见 <a href="https://link.segmentfault.com/?enc=f8hRBqQ5h8YleHYZvBz3Rw%3D%3D.oCUEnJ1ZMwj54ChuazEynu%2F%2BCR0FjV8zxuwgwPmq8RTbmQmStdjYffkPflmkwPMvPS4dNsJlYOkbebmuluw%2FbMkni%2BxAUeHtOe%2F9KQVzIPQ%3D" rel="nofollow" target="_blank">Incident Metrics in SRE</a>，<a href="https://link.segmentfault.com/?enc=mBwCMrrjmnEUsg2S5UNzMw%3D%3D.6ZRVHR585hVDCCKG%2Fy7FlNYNR2exYUKrgcpOCNGsfyHwH%2BlF4mn9DPMTTtGSQaqcNunqvYo4FTTlsvenzIIpOg%3D%3D" rel="nofollow" target="_blank">2022 VOID Report</a>，<a href="https://link.segmentfault.com/?enc=AP3OZPqc2XBybCnsY6Vhxg%3D%3D.5pGS5CqfRG8a5RXTAvP0u%2BVHImSvZjI%2BvcDIL42PZdEVTHGx0WpsLqrzy0MfhR23QfTF95qZRY6PZU%2B3cmPW9rcaocvqU3qcmyrPj2ZECKc%3D" rel="nofollow" target="_blank">DORA Metrics Reference</a>）。相反，团队采用了可靠性指标和未完成缺陷数量，后者需要追踪影响众多用户的重大事件，前者旨在考虑可靠性指标未能涵盖的个别客户问题。</p><h2>后端服务</h2><p>三月份的时候，后端服务的 DF 是每月 15 次，LTFC 大约是 14 小时。后者意味着软件工程师通常需要等待将近一天才能将变更部署到生产环境中。这表明开发者体验不佳，市场投入时间较长。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543361" alt="图3：后端服务的统计数据和主要改进已实现。" title="图3：后端服务的统计数据和主要改进已实现。" loading="lazy"/></p><p>主要问题是代码不容易理解和修改。如果报告了 bug，诊断、修复并部署到生产环境需要数周时间。单元测试覆盖率较低，团队缺乏信心，大家都不愿意做任何改进，担心会以意想不到的方式破坏代码。</p><p>测试自动化、文档和内部质量看起来是最受限制的因素，团队决定开始<a href="https://link.segmentfault.com/?enc=YyO%2BAZJXDtvkb5lyjfLq6A%3D%3D.GwFAi%2FE1gIOEIq3vyGnF0sruroXTrnhYa%2BSRAg7hGDJVz%2BX3wnre4%2Bxx%2Bsp8TpCQGmGZABsPu9oty2SWm3gABp7arv7JKt67QML2umI2A3574zWALr5wQctddEWHOqCYD8Rf5tyXhEOd%2BuhGPEcxjwrykwYJvpv8qoSPnI%2BiOL8%3D" rel="nofollow" title="Measuring technical debt to avoid the boiling frog syndrome" target="_blank">测量</a>和改进这些数据。</p><p>团队采用<a href="https://link.segmentfault.com/?enc=nzNbgVYwJwKcFiMqpDvLaw%3D%3D.nu1v1adnyL1wsaCt%2B3e05Wh4HPfZIPsMxFw9WcZwRdvj%2BueBoICmaVNJVrSu%2BJQl%2BrRZVd%2BG6sLmtsxfOo%2FpqewP64ChlxFVrlbwiGHSdBhYBhsYSk0K6hXB6HPDJM%2FL" rel="nofollow" target="_blank">童子军规则</a>，通过重构和测试自动化来提升代码质量，同时不中断功能开发工作。在实施变更或修复缺陷的同时，也要努力改进代码。不需要巨大的改善，可能只是简单到给修改的类添加单元测试，或者做一些小的重构来对抗<a href="https://link.segmentfault.com/?enc=2VMuUVlH6t7GY6NlGhX%2FeA%3D%3D.W9j79ifP7gHFaIdMXH5oElQd34WuY0twi8foOKg6IP31%2Fyn5bQXM8r%2BaM2zBGNfF" rel="nofollow" target="_blank">代码异味</a>。</p><p>我们发现童子军规则让重构效率大幅提升。首先，改进刚完成的代码所需时间更少。其次，更有可能改进那些经常被修改的代码。</p><blockquote><p><strong>童子军规则</strong></p><p>“总是让露营地比你来时更干净。”如果发现地上脏乱，不管是谁弄的，都要清理干净，你有义务为下一批营员改善环境。—— 罗伯特·C·马丁</p></blockquote><p>遗憾的是，要精通重构，仅仅阅读大师们的经典著作（例如 <a href="https://link.segmentfault.com/?enc=S2ETEtnh2lkHiZ12rINtiA%3D%3D.tMSBqg9ekynGmkxcai1g%2FVjIuqCfRCAG%2FDSNNPRqn%2BdeFCiE%2Fb5Qy6V0EGz0kGb%2B" rel="nofollow" target="_blank">重构</a>，<a href="https://link.segmentfault.com/?enc=sKi2594ik24AzuZwxmNpxQ%3D%3D.dv3I1sB157VBDL3pNA2hjpqop1JSF1n8n3X7Bjo%2Bn26bQ248xFKpvcp1Se1wjCsxZIf5QNA0nRe6J8t7sNqW8g%3D%3D" rel="nofollow" target="_blank">代码整洁之道</a>，<a href="https://link.segmentfault.com/?enc=8UYL6rE9Jd%2Bja9nYWyvMXQ%3D%3D.zO%2BmSsCfH%2F3mpM9ZVp31RueTNvkBY6jrYCes7Tt6y%2BFaBRZ5ayRmFkP9q4NY2AzV" rel="nofollow" target="_blank">重构与模式</a>，<a href="https://link.segmentfault.com/?enc=FW1fZRyiRm1KCaHrpw2BMQ%3D%3D.Hf1CyW6%2F2McvdUQNgL4%2F%2FnBp6GGFFPpFE6%2Fdq8k7DteSCuHC8Mr7ZLQjtNQnQguC" rel="nofollow" target="_blank">Five Lines of Code</a>）是不够的。重构技能需要花时间学习并经常练习，才能变得精通。在实际任务中练习重构非常困难，因为经常面临时间压力，而且实际代码更为复杂。于是团队开始练习重构技巧，以获得更多实际作经验来应对代码异味，并且这么做也有助于测试想法。</p><blockquote>“怎么成为全明星运动员？显然，体能和天赋很重要。但伟大的运动员每天都花无数小时练习“ —— <a href="https://link.segmentfault.com/?enc=CfbZaAZ4yVvUHlzWJj%2BLWg%3D%3D.D3F7Icrb9NZSafMDA3gKPhn9SPBG6WoUmhaLSRTviRU%3D" rel="nofollow" target="_blank">CodeKata</a>。</blockquote><p>到了六月，代码审查显然是最大的瓶颈。<a href="https://link.segmentfault.com/?enc=9sCqB0adW8ubI%2BEX6hHFzQ%3D%3D.1IMh3Zgas6tHhY7Z4LYSrCMZeox%2BvrEkx8tOMZpIhbRUPx2TuQEUrRU2vXQbIsAODdBrWBtOQtY5RnpznSg%2B4g%3D%3D" rel="nofollow" target="_blank">合并请求（MR）</a>通常规模较大，在代码审查过程中处理它们既困难又耗时，是一项痛苦且不受欢迎的任务。改善的方法是采用小批量作业（即支持小批量 MR），并同意将代码审查列为优先事项。因此，团队在 7 月份看到代码审查时间大幅减少。</p><p>7月，测试覆盖率的提升使团队能够在几乎无需手动进行回归测试的情况下部署到生产环境。此时，部署过程平均耗时 40 分钟，需要许多手动步骤，包括两次金丝雀部署和验证。根据观察和统计，这些手动步骤都是多余的。例如，过去在金丝雀部署期间没有出现任何问题。如果是这样，为什么要在这些事情上面花时间？</p><p>尽管过去没人这样做过（至少在我们部门是这样），团队还是决定采用自动化部署。想法是让 MR 合并到主干后直接部署到生产环境，无需人工验证。显而易见的担忧是这会影响质量。不过从另一方面来说，团队也有不错的安全保障：良好的测试自动化、同行代码评审、小批量修改等等。</p><p>团队决定尝试一下。如果出现任何问题，借助质量相关指标，也可以及时发现，并回归传统的“安全”程序。幸运的是，这一变化没有影响质量，但将部署时间从 40 分钟缩短到了 4 分钟。DF 和 LTFC 指标也反映了改进，8 月的部署次数提升至每月 43 次，而前置时间为 1.3 小时。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543362" alt="如果一遍又一遍做同样的事情，结果也是一样" title="如果一遍又一遍做同样的事情，结果也是一样" loading="lazy"/></p><p>总体来看，DF 从三月的 15 小时提升到十月的每月 37 小时，LTFC 的前置时间从三月的 13.8 小时降至十月的 4.2 小时。</p><h2>UI 页面</h2><p>单体的紧密耦合和部署工具是无法绕过的问题。每月部署 6 至 8 次的 DF 和 2 至 3 天的 LTFC 导致开发表现和体验不佳。工程师们被激励批量提交，尽量避免部署。公司推荐的解决方案是将页面迁移到<a href="https://link.segmentfault.com/?enc=WHPeZSSN0Quer7rjdZN%2BYQ%3D%3D.V9ktmngfh%2BLD7VABo9sc9Al7im%2Fggq0HzO4bl8bLqFU%3D" rel="nofollow" target="_blank">微前端（MFE）</a>技术。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543363" alt="图5：UI 页面统计数据。MFE 迁移项目于 8 月完成，导致了更高的 DF 和更低的 LTFC。MFE 的 MR 审查流程变更导致 LTFC 在 10 月及之后有所改善" title="图5：UI 页面统计数据。MFE 迁移项目于 8 月完成，导致了更高的 DF 和更低的 LTFC。MFE 的 MR 审查流程变更导致 LTFC 在 10 月及之后有所改善" loading="lazy"/></p><p>团队启动了几个重要页面的迁移项目。</p><blockquote><p><strong>微前端，MFE</strong></p><p>微前端是一种前端网页开发模式，单个应用可以由不同的构建组成，类似于微服务方法，但针对用 JavaScript 编写的客户端单页应用，是为多个前端应用进行分解和路由的解决方案（<a href="https://link.segmentfault.com/?enc=GfjSz9ecrfGM3wlzM4XcEQ%3D%3D.iCWJCo%2FV6haK%2Ftdz2gpKyrQEG7Fb%2BdhKGZcHwXoh051RnpwcIcrkjsI8gQb7QCoU" rel="nofollow" title="微前端" target="_blank">维基百科</a>）</p></blockquote><p>新的 MFE 页面于九月推送给所有用户。团队发现性能有所提升，然而当天的 LTFC 和预期相差很远。当我们收集统计数据时，那一刻简直是当头一棒。经过这么多努力，仍然需要等待很长时间才能将更改提交到生产环境！怎么回事？</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543364" alt="当团队发现 MFE 迁移未能带来预期的性能提升时" title="当团队发现 MFE 迁移未能带来预期的性能提升时" loading="lazy"/></p><p>我们需要查看过去一个月所有 MR 数据。对于每个 MR，我们在提交时记录了统计数据，进行了评论、批准、合并和部署。</p><p>事实证明，MFE 申请的 MR 审核流程比平时更复杂。例如，需要团队外部的 MFE 社区专家的批准。因此，MR 批准的平均时间为 17.1 小时。</p><p>我们联系了 MFE 专家社区，讨论如何优化流程。实施了几项优化，将获批的平均时间缩短到 8 分钟（是的，没错，因为我们有很多小型 MR）。随着审批时间缩短，我们也同意尽量不批量部署，使得部署时间缩短至 1 小时。</p><p>因此，10 月的 LTFC 缩短至 14 小时，这是一大进步，被视为显著的绩效提升。</p><h2>结果与观察</h2><p>如图2所示，上述所有变化使团队的软件交付绩效实现了双重提升。其中一些需要大量开发工作，还有许多项目需要改变团队的工作方式，但不需要太多工作。其中一些变化需要转变心态或者培养新技能。这些都不需要额外资源。</p><p>所有努力最重要的成果是开启了一种新的工作方式 —— 注重内部质量和实验。如果软件工程师发现代码异味，直接修复通常比管理额外技术债务更容易。团队现在可以验证最重要的决策，无需将其与其他低优先级决策批量处理。</p><p>管理、协调和沟通也变得更容易。首先，因为尚未部署的代码较少。比如，软件工程师可以和 UX 设计师一起，随时做一些小改动，几分钟内就能完成所有事情，无需任何文件和管理，所需的资源更少。</p><p>当你能在几小时内看到成果，而不是几天时，工作时会更有成就感！</p><p>有人可能会说，软件交付虽然重要，但只是价值流中的一小部分，因此我们可能并没有为公司带来太大改变。说得有道理。然而，<a href="https://link.segmentfault.com/?enc=ZxDGhkfdpjl5XYxXDpLIpA%3D%3D.QFs8sSXY0zo1KuGut56CMdaTO0MhXvmniOawgBG24Y4%2Bvmq8hmVlS2YVmYGmXOQlPL73HNxNecyK5QMcR2Km2A%3D%3D" rel="nofollow" target="_blank">破窗理论</a>在这里同样适用：如果我们改进软件交付，也会鼓励他人进行改进。如果项目经理要等一个月才能向客户交付有意义的东西，怎么会考虑快速实验呢？</p><h2>要点</h2><ul><li>通过增加资源来提升绩效相当困难，很可能团队的困难状态正是因为组织内部的运作方式，而这才是最大的改进潜力所在。</li><li>推动改进的有效方式如下。首先，选择对公司重要的以结果为导向的指标。然后，专注于通过逐一解决最限制因素来改进。</li><li>所有变革的结果是，开启了一种新的工作方式 —— 注重内部质量和实验。</li><li>团队必须专注于长期可持续的绩效，而非短期收益。通过采用部分实践，改进时可以不阻碍功能开发。</li><li>有效的方法足够通用，也能适用于许多其他团队，只不过每种情况中的最大限制因素可能不一样。</li></ul><hr/><blockquote>Hi，我是俞凡，一名兼具技术深度与管理视野的技术管理者。曾就职于 Motorola，现任职于 Mavenir，多年带领技术团队，聚焦后端架构与云原生，持续关注 AI 等前沿方向，也关注人的成长，笃信持续学习的力量。在这里，我会分享技术实践与思考。欢迎关注公众号「DeepNoMind」，星标不迷路。也欢迎访问独立站 <a href="https://link.segmentfault.com/?enc=edhNt%2BYwRBomjTnQy2LgQg%3D%3D.xHkv%2B8h2hRckOGv3SB8mlzt%2FBVTeHz58tQSHPLIFwD4%3D" rel="nofollow" title="www.DeepNoMind.com" target="_blank">www.DeepNoMind.com</a>，一起交流成长。</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=pOvqdlnmYfSnUe%2FBpL1Rlg%3D%3D.1YSj9tZQZDZls1oYNLvKgRAt0uv21lp1ceBPakRTZiI%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[拆解 PostgreSQL 连接机制：从进程模型到通信协议 IvorySQL ]]></title>    <link>https://segmentfault.com/a/1190000047542908</link>    <guid>https://segmentfault.com/a/1190000047542908</guid>    <pubDate>2026-01-14 18:14:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在 PostgreSQL 中，SQL 查询的解析、执行等全流程的触发，均以应用程序与数据库建立有效连接为前提。</p><p>这一连接建立过程看似是简单的交互握手，实则背后蕴含复杂的底层机制——涵盖进程管理、身份认证，以及保障高效通信的二进制协议等核心环节。</p><p>深入理解 PostgreSQL 的连接处理机制，不仅能明晰连接池的重要性、掌握连接问题的排查思路，还可厘清其架构与基于线程的数据库的本质差异。下文将完整梳理应用程序与 PostgreSQL 建立连接的全流程。</p><h2>主进程：PostgreSQL 的守护进程</h2><p>启动 PostgreSQL 时，率先启动的进程为主进程（<strong>postmaster</strong>）。该进程可视为数据库的接待进程，负责监听传入连接并协调连接的处理方式。</p><p>主进程并不直接处理查询请求。当客户端发起连接时，主进程会创建一个全新的后端进程，专门用于处理该客户端的相关操作。每个连接均拥有独立的进程，且分配有专用于查询处理的私有内存空间。</p><p>但后端进程并非完全独立运行，所有后端进程均可通过共享内存访问公共资源，其中最关键的资源为共享缓冲区高速缓存，PostgreSQL 会将数据库页面存储于该区域。借助共享内存机制，后端进程能够高效共享数据，无需在各进程中重复存储数据副本。</p><p>这种连接-进程架构可实现高度隔离。若某后端进程因查询异常崩溃，不会对其他连接产生影响。主进程仅负责连接管理，不涉及共享内存访问或复杂查询处理，因此始终保持轻量与稳定的运行状态。</p><p>该架构的弊端在于，PostgreSQL 创建连接的成本高于基于线程的数据库。创建操作系统进程所需的资源多于生成线程，因此连接池技术对高流量应用的稳定运行至关重要。</p><h2>连接流程：从 TCP 连接到就绪状态</h2><p>PostgreSQL 连接的建立包含多个明确步骤，具体流程如下。</p><h3>步骤 1：建立 TCP 连接</h3><p>应用程序向 PostgreSQL 发起标准 TCP 连接请求，默认端口为 5432。主进程接收该连接请求。此阶段尚未发生任何 PostgreSQL 专属通信，仅完成基础网络连接的搭建。</p><p>TCP 连接建立后，下一步将进行安全校验。</p><h3>步骤 2：SSL 协商（可选）</h3><p>若配置 SSL 协议，客户端与服务器会进行加密协商。该步骤需提前执行，因其会影响后续所有通信过程。SSL 连接建立后，所有数据传输均通过加密通道完成，可有效防止密码与查询数据被拦截。</p><p>此时客户端即可正式请求建立数据库会话。</p><h3>步骤 3：发送启动数据包</h3><p>客户端发送的启动数据包包含以下内容：</p><ul><li>客户端使用的 PostgreSQL 协议版本（当前主流版本为 3.0）</li><li>目标数据库名称</li><li>用户名</li><li>可选连接参数（时区、字符编码等）</li></ul><p>该数据包是客户端发起数据库会话请求的正式载体。</p><p>主进程接收会话请求后，将创建专用进程处理该连接。</p><h3>步骤 4：创建后端进程</h3><p>主进程对启动数据包进行验证，检查请求的数据库是否存在、系统是否能够承载新的连接。验证通过后，主进程将通过操作系统的 fork 机制创建新的后端进程。</p><p>完成进程创建后，主进程将该连接移交至新的后端进程，随后返回监听状态，等待接收新的连接请求。自此，客户端将直接与专属的后端进程进行通信。</p><p>但在连接投入使用前，还需完成一项关键步骤——客户端身份验证。</p><h3>步骤 5：身份验证</h3><p>此步骤为安全校验环节。后端进程接管连接后，将依据<code>pg_hba.conf</code>（PostgreSQL 基于主机的身份验证配置文件）中的规则执行身份验证。</p><p>配置文件中的规则会根据连接来源、访问的数据库以及登录用户这三个维度，确定对应的身份验证方式。</p><p>PostgreSQL 支持多种身份验证方式，包括信任认证（无需凭据）、基于密码的认证（如 SCRAM-SHA-256 算法）、SSL 证书认证，以及与 LDAP、Kerberos 等外部系统的集成认证。不同场景下可配置的认证方式差异显著，例如本地连接可采用信任认证，而远程连接则需强制使用证书认证。</p><p>身份验证通过后，将进入最终步骤。</p><h3>步骤 6：进入查询就绪状态</h3><p>身份验证成功后，后端进程将切换至就绪状态。此时连接完全建立，客户端与服务器可通过 PostgreSQL 的有线协议通信，实现查询语句与结果集的交互。</p><p>下文将进一步解析该有线协议的定义与工作机制。</p><h2>有线协议：客户端与服务器的通信标准</h2><p>PostgreSQL 有线协议定义了客户端与服务器之间交互查询语句和结果集的通信规范。该协议为二进制协议，具备高效性与可靠性的特性。</p><p>该协议的核心是一套简洁且高效的消息格式。</p><h3>消息结构</h3><p>所有消息均遵循统一的基础格式：</p><ol><li>长度字段（4 字节）：标识消息的总长度。</li><li>消息类型标识符（1 字节）：通常为 ASCII 字符。</li><li>消息内容（长度可变）。</li></ol><p>这种结构使通信双方能够高效解析消息，可处理从简短命令到大规模结果集的各类数据传输场景。</p><p>下面将阐述消息如何协同工作以完成查询执行。</p><h3>两种查询执行协议</h3><p>PostgreSQL 提供两种独立的查询执行协议，分别适用于不同的应用场景。</p><h4>简单查询协议</h4><p>简单查询协议采用直接方式：发送完整 SQL 语句并接收执行结果。</p><p>以用户信息查询为例，客户端发送一条包含完整 SQL 语句的 Query 消息：</p><pre><code>Client → Server: Query ('Q') + "SELECT name, email FROM users WHERE id = 42"</code></pre><p>PostgreSQL 接收该消息后，依次执行 SQL 解析、查询计划生成、语句执行操作，并按顺序返回以下消息：</p><pre><code>Server → Client: RowDescription ('T') + column metadata
                  - Column 1: "name" (text type)
                  - Column 2: "email" (text type)</code></pre><ol><li><code>RowDescription</code> 消息用于描述查询结果的列信息，包括列名、数据类型及相关元数据，使客户端能够正确接收并解析后续数据。</li></ol><pre><code>Server → Client: DataRow ('D') + "John Doe", "john@example.com"</code></pre><ol start="2"><li><code>DataRow</code> 消息承载实际查询结果数据。对于返回多行结果的查询，PostgreSQL 会为每一行分别发送一条 <code>DataRow</code> 消息。</li></ol><pre><code>Server → Client: CommandComplete ('C') + "SELECT 1"</code></pre><ol start="3"><li><code>CommandComplete</code> 表示查询已成功完成，并附带执行结果标识。“<code>SELECT 1</code>” 表示本次查询返回了一行数据。</li></ol><pre><code>Server → Client: ReadyForQuery ('Z') + transaction status</code></pre><p><code>ReadyForQuery</code> 表示服务器已准备好接收下一条命令，同时携带当前事务状态，用于指示连接处于空闲状态、事务块中或失败事务状态。</p><p>简单查询协议适用于一次性或临时执行的查询场景。其局限在于，每次执行都会重新进行 SQL 解析和查询规划，即使查询结构相同、仅参数值不同，仍无法复用已有执行计划。</p><p>针对需要频繁重复执行的查询，PostgreSQL 提供了更为高效的扩展查询协议。</p><h4>扩展查询协议</h4><p>该协议将查询准备阶段与执行阶段进行分离。</p><p>与简单查询协议不同，扩展查询协议支持创建预处理语句，无需在每次执行时发送完整的 SQL 语句。</p><p>下文仍以用户信息查询为例，梳理扩展查询协议的执行流程。该流程相对复杂，但在重复查询场景下的优势十分显著。</p><ol><li>创建查询模板<br/>客户端发送包含占位符的查询模板：</li></ol><pre><code>Client → Server: Parse ('P') + statement name "get_user" +
                  "SELECT name, email FROM users WHERE id = $1" +
                  parameter types [INTEGER]</code></pre><p>Parse 消息用于通知 PostgreSQL 创建名为<code>get_user</code>的预处理语句。SQL 语句中包含占位符&amp;dollar;1，用于填充实际用户 ID 参数，同时指定该占位符的数据类型为 INTEGER。PostgreSQL 会对该 SQL 语句进行解析并生成可复用的查询计划。</p><pre><code>Server → Client: ParseComplete ('1')</code></pre><p>ParseComplete 消息用于确认预处理语句已创建完成，可投入使用。</p><ol start="2"><li>绑定参数值至模板<br/>客户端将具体参数值绑定至查询模板：</li></ol><pre><code>Client → Server: Bind ('B') + portal name "user_portal" +
                  statement "get_user" +
                  parameter values [42]</code></pre><p>Bind 消息用于创建门户，即填充实际参数值后的预处理语句实例。此步骤将数值 42 绑定至<code>get_user</code>语句的占位符&amp;dollar;1，并创建名为<code>user_portal</code>的门户。</p><pre><code>Server → Client: BindComplete ('2')</code></pre><p>BindComplete 消息用于确认门户已创建完成，可执行查询操作。</p><ol start="3"><li>执行门户查询<br/>客户端发送门户执行请求：</li></ol><pre><code>Client → Server: Execute ('E') + portal "user_portal"</code></pre><p>Execute 消息用于触发门户的执行操作。PostgreSQL 返回结果的流程与简单查询协议一致：</p><pre><code>Server → Client: RowDescription ('T') + column metadata
                  - Column 1: "name" (text type)
                  - Column 2: "email" (text type)

Server → Client: DataRow ('D') + "John Doe", "john@example.com"

Server → Client: CommandComplete ('C') + "SELECT 1"</code></pre><ol start="4"><li>同步会话状态</li></ol><pre><code>Client → Server: Sync ('S')

Server → Client: ReadyForQuery ('Z') + transaction status</code></pre><p>在重复查询场景下，该协议的优势尤为突出。例如查询用户 ID 为 99 的数据时，可直接跳过解析步骤，基于已创建的<code>get_user</code>模板创建新门户并绑定参数 99，随后执行查询即可。PostgreSQL 可复用已解析的查询计划，大幅提升后续查询的执行效率。</p><p>此外，扩展查询协议还能增强对 SQL 注入攻击的防护能力。由于参数与 SQL 语句结构分离传输，采用类型化数值而非字符串拼接的方式填充参数，可从根源上避免 SQL 注入风险。</p><p>上文已阐述连接建立与通信的完整流程，下文将说明连接终止的相关机制。</p><h2>连接终止机制</h2><p>PostgreSQL 连接可通过以下几种方式终止。</p><ol><li><strong>正常断开</strong></li></ol><p>客户端发送<code>Terminate</code>消息，后端进程完成未执行的操作，释放占用的资源，随后正常退出。</p><ol start="2"><li><strong>空闲超时断开</strong></li></ol><p>PostgreSQL 支持自动关闭长时间处于空闲状态的连接。其中<code>idle_in_transaction_session_timeout</code>参数尤为关键，该参数可防止连接长时间持有数据库锁，避免影响其他操作的执行。</p><ol start="3"><li><strong>管理员强制终止</strong></li></ol><p>数据库管理员可通过<code>pg_terminate_backend()</code>等命令强制关闭连接。该功能在终止失控查询或强制断开异常应用程序连接时至关重要。</p><ol start="4"><li><strong>进程崩溃终止</strong></li></ol><p>若后端进程崩溃，将无法执行正常的清理操作。主进程会检测到该崩溃事件，并启动恢复流程，确保数据库的一致性。连接-进程架构可将问题隔离在单个后端进程内，避免单个进程崩溃对其他连接造成影响。</p><h2>总结</h2><p>PostgreSQL 的连接架构以主进程为核心，主进程会为每个客户端连接创建专属的后端进程。连接建立需依次完成六个步骤：建立 TCP 连接、SSL 协商、发送启动数据包、创建后端进程、身份验证、进入就绪状态。</p><p>连接建立后，客户端与服务器通过有线协议通信，支持两种查询执行方式：适用于临时查询的简单查询协议，以及适用于重复查询的扩展查询协议。扩展查询协议不仅支持查询计划复用，还能有效提升 SQL 注入防护能力。</p><p>本文已详细解析 PostgreSQL 连接机制的核心原理，下一篇文章将聚焦 SQL 查询的处理流程：解析器。届时将阐述 PostgreSQL 如何将 SQL 文本转换为能够表征查询语义与结构的结构化解析树。</p><p>作者：Jesús Espino</p><p>原文链接：</p><p><a href="https://link.segmentfault.com/?enc=e68YKa0Zc5%2Bg3JbR0mMorw%3D%3D.%2Fwc6aL9GQXXfCAZckeGdRT6MCJSn5m28n6kaJ9Ch5sS1cv%2FfRgxnAOvE06SJoZGY8%2FUOQSLHVUdOyz62lCj82txk61v9UN75XH7HYd2HE1s%3D" rel="nofollow" target="_blank">https://internals-for-interns.com/posts/postgres-connections-...</a></p><hr/><h2><a href="https://link.segmentfault.com/?enc=xCQ6y4bFe6FnVnEF1KB2Kg%3D%3D.h2xkn2jh9eRBM0yWGiat9il03c%2BICI9nhK7y%2BOEG7ds%3D" rel="nofollow" title="HOW 2026 议题招募中" target="_blank">HOW 2026 议题招募中</a></h2><p>2026 年 4 月 27-28 日，由 IvorySQL 社区联合 PGEU（欧洲 PG 社区）、PGAsia（亚洲 PG 社区）共同打造的 HOW 2026（IvorySQL &amp; PostgreSQL 技术峰会） 将再度落地济南。届时，PostgreSQL 联合创始人 Bruce Momjian 等顶级大师将亲临现场。</p><p>自开启征集以来，HOW 2026 筹备组已感受到来自全球 PostgreSQL 爱好者的澎湃热情。为了确保大会议题的深度与广度，我们诚邀您在 2026 年 2 月 27 日截止日期前，提交您的技术见解。</p><p>投递链接：<a href="https://link.segmentfault.com/?enc=aY0jaGQ23UgApgQSsXQVdg%3D%3D.yEgaLUVsWMMrMvIFC21vQugKadvaLOYinbfVdowJZqE%3D" rel="nofollow" target="_blank">https://jsj.top/f/uebqBc</a></p>]]></description></item><item>    <title><![CDATA[360集团创始人周鸿祎发布《2026年AI全景预测》，360要靠这招在AI赛道逆袭？ 悲伤的斑马 ]]></title>    <link>https://segmentfault.com/a/1190000047542922</link>    <guid>https://segmentfault.com/a/1190000047542922</guid>    <pubDate>2026-01-14 18:14:02</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在科技浪潮汹涌澎湃的2026年，AI领域又炸出一颗“超级炸弹”！360集团创始人周鸿祎发布《2026年AI全景预测》，抛出一个震撼业界的观点：“百亿智能体将全面融入经济社会！”这一论断如同一颗投入平静湖面的巨石，瞬间激起千层浪，让整个科技圈都沸腾起来。与此同时，360集团内部正紧锣密鼓研发企业级“个人超级智能体”，野心勃勃地试图在AI Agent赛道复制微信、抖音的“平台级”辉煌，这背后究竟藏着怎样的玄机？</p><h3>百亿智能体：是狂想还是未来真相？</h3><p>周鸿祎向来以敢言著称，这次他提出的“百亿智能体时代”更是语不惊人死不休。所谓智能体，简单来说，就是具备一定自主感知、决策和行动能力的智能实体。它们可以像人类一样，在特定的环境中根据目标完成任务，而且还能不断学习和进化。</p><p>周鸿祎认为，当前大模型虽然发展得如火如荼，但大多还停留在“纸上谈兵”的阶段，真正能落地到实际场景中解决复杂问题的并不多。而智能体则不同，它就像是一个个“超级打工人”，能够深入到各个行业和领域，与具体业务紧密结合。</p><p>想象一下，在医疗领域，智能体可以协助医生进行疾病诊断，分析海量的医学数据，提供精准的治疗方案；在交通领域，智能体可以优化交通流量，实现智能驾驶和交通调度，让城市拥堵成为历史；在金融领域，智能体可以进行风险评估和投资决策，为客户提供个性化的金融服务。当百亿个这样的智能体全面融入经济社会，那将是一场怎样翻天覆地的变革？</p><p>不过，也有人对周鸿祎的预言表示质疑。毕竟，智能体的发展还面临着诸多挑战，比如技术瓶颈、数据安全、伦理道德等问题。但周鸿祎却坚信，这些问题都是暂时的，随着技术的不断进步和社会的逐步适应，智能体时代必将到来。</p><h3>360“个人超级智能体”：剑指平台级霸主</h3><p>面对即将到来的智能体时代，360集团自然不会坐视不管。他们内部正在秘密研发一款企业级“个人超级智能体”，这可不是一个简单的产品，而是360在AI Agent赛道的一张“王牌”。</p><p>周鸿祎表示，360的“个人超级智能体”将具备强大的通用能力和个性化定制能力。它就像是一个全能的智能助手，可以满足企业员工在工作中的各种需求。无论是处理文档、安排日程、进行数据分析，还是与客户沟通、协调团队工作，它都能轻松胜任。</p><p>而且，这个智能体还可以根据不同企业的业务特点和员工的工作习惯进行个性化定制。比如，对于一家互联网公司，它可以重点优化代码编写和项目管理功能；对于一家制造业企业，它可以侧重于生产流程监控和质量控制。这种个性化的服务将大大提高企业的工作效率和竞争力。</p><p>360的野心还不止于此。他们希望这款“个人超级智能体”能够成为一个平台级的产品，就像微信和抖音一样，吸引大量的开发者和企业入驻，形成一个庞大的智能体生态系统。在这个生态系统中，开发者可以开发各种智能体应用，企业可以根据自己的需求选择合适的应用，从而实现互利共赢。</p><h3>复制辉煌：是异想天开还是胸有成竹？</h3><p>要在AI Agent赛道复制微信、抖音的“平台级”成功，这可不是一件容易的事。微信和抖音之所以能够成为平台级的产品，是因为它们抓住了移动互联网时代的机遇，满足了用户的社交和娱乐需求，并且通过不断的技术创新和用户体验优化，积累了庞大的用户基础和强大的品牌影响力。</p><p>而360的“个人超级智能体”要想取得成功，也面临着诸多挑战。首先，技术方面，要确保智能体的稳定性、安全性和可靠性，避免出现数据泄露和系统故障等问题。其次，市场方面，要说服企业接受并使用这款新的产品，需要花费大量的时间和精力进行市场推广和用户教育。最后，竞争方面，AI领域竞争激烈，已经有不少科技巨头和初创企业在智能体赛道布局，360要想脱颖而出，必须要有独特的竞争优势。</p><p>不过，360也并非没有机会。他们在安全领域有着深厚的技术积累和品牌优势，这可以为“个人超级智能体”的安全保障提供有力支持。而且，360拥有庞大的用户基础和企业客户资源，这为产品的推广和应用提供了便利条件。此外，周鸿祎本人在科技圈的影响力和号召力也不容小觑，他的背书可以为产品增添不少光彩。</p><h3>结语：智能体时代，谁主沉浮？</h3><p>周鸿祎的“百亿智能体时代”预言和360集团的“个人超级智能体”战略，无疑为AI应用落地与产业变革指明了一个新的方向。虽然前方的道路充满了挑战和不确定性，但这也正是科技的魅力所在。</p><p>在这个充满机遇和挑战的时代，谁能够抓住智能体发展的机遇，谁就有可能在未来的科技竞争中占据主动。360集团能否在AI Agent赛道复制微信、抖音的辉煌，让我们拭目以待。但可以肯定的是，智能体时代已经悄然来临，它将深刻改变我们的生活和工作方式，一个全新的科技时代即将拉开帷幕！</p>]]></description></item><item>    <title><![CDATA[『n8n』初识界面 德育处主任 ]]></title>    <link>https://segmentfault.com/a/1190000047542930</link>    <guid>https://segmentfault.com/a/1190000047542930</guid>    <pubDate>2026-01-14 18:13:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p><blockquote>整理了一个n8n小专栏，有兴趣的工友可以关注一下 👉 <a href="https://link.segmentfault.com/?enc=pPKtQFNkX2XbkJdkpTdChQ%3D%3D.nvBwr7GMLQlWl%2BLYnNiXIugD5oRYDG0HDK55oIVusNfjF4u9ajQ7JUTlWyiwGZ%2BdU1hOTE8V%2F1zWu7ptVwLT%2Bn6EtORpA8CirMH%2F6GGgeOrxyJYDWx3RT7vxOSd3l7tHVhPYxHIF1wom0J3mEx8%2BjzeKMAGXn0c7OWROiout%2FhQ%3D" rel="nofollow" target="_blank">《n8n修炼手册》</a></blockquote><p>n8n 的功能实在太多了，如果一个一个功能、节点、设置去学，那每个一年半载都学不完。</p><p>我的学习经验是直接上手，从最简单的工作流开始做起。但这样也会走一些弯路，每做一步都要查查查。</p><p>所以，我的建议是先了解 n8n 常用操作，在脑子里有个印象，再去做复杂的工作流。</p><p>本文介绍的都是新手入门需要掌握的常用操作，复杂的内容不讲！</p><h2>创建工作流</h2><p>学电脑，第一课是学开机，然后学关机。</p><p>学 n8n 也一样。</p><p>在 n8n 创建工作流的方法很简单，在首页点击“Start from scratch”就创建了一个工作流工程。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542932" alt="" title=""/></p><p>如果你已经创建过工作流工程，想再创建新工程的话，可以在首页点击右上角的“Create workflow”按钮。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542933" alt="" title="" loading="lazy"/></p><h2>删除工作流</h2><p>想删除工作流好像没有想象中那么简单，点开工作流的操作菜单并没有“删除”按钮。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542934" alt="" title="" loading="lazy"/></p><p>n8n 避免我们误操作，要2步操作才能删除工作流。</p><p>点开工作流的菜单，点击“Archive”让这个工作流归档。</p><p>然后在筛选项里勾选“Show archived workflows”就能看到已归档的工作流。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542935" alt="" title="" loading="lazy"/></p><p>只有已归档的工作流才能删掉。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542936" alt="" title="" loading="lazy"/></p><h2>面板介绍</h2><p>在首页（Overview），我们和 n8n 最常打交道的是“Workflows”、“Credentials”、“Executions”这几个面板（其实后面2个也会用到，但初学阶段可以先不管）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542937" alt="" title="" loading="lazy"/></p><p>Workflows 面板可以看到我们创建的所有工作流，所以要给工作流起一个一眼看上去就知道是干嘛的名字。</p><p>Credentials 保存了我们和外部服务的所有凭证，比如我们在 OpenAI 申请的 KEY，我们在本地部署 Ollama，又或者是我们对接飞书等系统的接口，这些和 n8n 交互的所有服务都可以在 Credentials 面板里查看。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542938" alt="" title="" loading="lazy"/></p><p>以后要更改某些服务的凭证都可以在 Credentials 面板修改。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542939" alt="" title="" loading="lazy"/></p><p>Executions 记录了所有工作流的运行记录。</p><p>点进其中一个工作流，可以看到它历史运行记录，正常和错误运行的记录全都有。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542940" alt="" title="" loading="lazy"/></p><h2>重命名工作流</h2><p>前面提到，给工作流起一个好名字是非常重要的事。</p><p>但我们在工作流的操作菜单里并没有看到“rename”这项。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542941" alt="" title="" loading="lazy"/></p><p>要重命名工作流，需要打开指定的工作流，进到它的画布页面后，再点击下图箭头所指的地方重命名才行。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542942" alt="" title="" loading="lazy"/></p><p>改完名字后记得保存一下。</p><h2>保存工作流</h2><p>用惯了在线文档的工友，尤其是年轻的工友，可能没有“保存”的习惯。因为现在的在线文档交互设计太友好了，做什么操作都会给你自动保存。</p><p>但 n8n 默认是没有自动保存的功能，需要你手动保存。</p><p>手动保存的方法有2个，如果是 Windows 电脑，按 <code>Ctrl + S</code> 可以保存当前工作流，如果是 Mac 电脑就按 <code>command + S</code>。</p><p>如果用鼠标操作的话就点击顶部菜单的“Save”按钮。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542943" alt="" title="" loading="lazy"/></p><p>已经保存成功，并且没再改动过的工作流，这个橙色的“Save”按钮会变成灰色的“Saved”。</p><p><strong>⚠️ 一定记得，每做完一步操作，没问题的时候就要点一下保存！！！</strong></p><h2>创建节点</h2><p>新创建的工作流是这样的，画布一片空白，只有中间一个“Add first step… ”按钮。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542944" alt="" title="" loading="lazy"/></p><p>鼠标点击这个按钮就可以创建节点了。</p><p>又或者按一下键盘的 <code>Tab</code> 键也会弹出节点面板。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542945" alt="" title="" loading="lazy"/></p><h2>删除节点</h2><p>删除不需要的节点，只要把鼠标放在节点上，节点上方就会出现一排按钮，点击箭头所指的垃圾桶就能删掉这个节点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542946" alt="" title="" loading="lazy"/></p><h2>连接节点</h2><p>所谓的工作流，就是上一个节点完成本职工作后，把数据流转到在一个节点。</p><p>所以节点和节点之间是需要一根线连接起来的，而且这根线还是有方向的。</p><p>从上一个节点的出口，拉一条线出来，放到下一个节点的入口，就把两个节点连接起来了</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542947" alt="" title="" loading="lazy"/></p><h2>断开节点的连接</h2><p>鼠标放在两个节点的连接线上，就会出现一个加号和一个垃圾桶。</p><p>点击垃圾桶图标就可以断开这两个节点的关系。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542948" alt="" title="" loading="lazy"/></p><h2>节点的类型</h2><p>n8n 的节点分几大类，不需要全部记下，只要记住有哪些类型就行。</p><p>之后工作中需要用到哪些节点，有不明白的时候再查文档。</p><p>我整理了一些常用节点，记不住没关系，先过一遍有个印象，之后可能还会回来查的～</p><h3>1. Operation 类型（流程启动与基础操作）</h3><p>所有节点先按「Trigger（启动流程）+ Action（执行操作）」二分法归类，比如：用<code>Schedule Trigger</code>（定时启动）+ <code>HTTP Request</code>（执行接口调用），就能快速搭建定时拉取数据的基础流程。</p><table><thead><tr><th align="center">节点子类</th><th align="center">节点（官方名称）</th><th align="center">核心能力 &amp; 高频场景</th></tr></thead><tbody><tr><td align="center">Trigger 触发器</td><td align="center">Manual Trigger</td><td align="center">手动触发流程，用于测试、调试工作流</td></tr><tr><td align="center"> </td><td align="center">Webhook Trigger</td><td align="center">接收 HTTP 回调请求触发流程，适配第三方系统主动推送事件</td></tr><tr><td align="center"> </td><td align="center">Schedule Trigger</td><td align="center">基于 Cron 表达式定时触发流程，实现周期性任务（如每日数据同步、定时推送）</td></tr><tr><td align="center"> </td><td align="center">Chat Trigger</td><td align="center">以对话交互为入口触发流程，适配聊天场景下的自动化操作</td></tr><tr><td align="center"> </td><td align="center">App Polling Trigger</td><td align="center">轮询第三方应用事件触发流程，适配无 Webhook 能力的外部平台</td></tr><tr><td align="center">Action 处理节点</td><td align="center">IF</td><td align="center">按条件分支执行流程，实现 “满足 A 则做 X，满足 B 则做 Y” 的逻辑判断</td></tr><tr><td align="center"> </td><td align="center">Switch</td><td align="center">多分支条件判断，比 IF 更灵活，适配多场景分支处理</td></tr><tr><td align="center"> </td><td align="center">Merge</td><td align="center">合并多个数据流，解决流程分支后的数据汇总需求</td></tr><tr><td align="center"> </td><td align="center">Edit Fields (Set)</td><td align="center">增删改数据字段、格式化数据结构，完成流程中的数据清洗 / 标准化</td></tr><tr><td align="center"> </td><td align="center">HTTP Request</td><td align="center">通用 REST API 调用，对接无专属节点的第三方系统，实现自定义接口交互</td></tr></tbody></table><h3>2. 内置 Core 节点（流程核心管控与扩展）</h3><table><thead><tr><th align="center">节点子类</th><th align="center">节点（官方名称）</th><th align="center">核心能力 &amp; 高频场景</th></tr></thead><tbody><tr><td align="center">数据 &amp; 控制</td><td align="center">IF</td><td align="center">基础条件判断，控制流程走向</td></tr><tr><td align="center"> </td><td align="center">Switch</td><td align="center">多维度条件分支，适配复杂业务逻辑</td></tr><tr><td align="center"> </td><td align="center">Merge</td><td align="center">聚合不同分支的数据流，统一后续处理逻辑</td></tr><tr><td align="center"> </td><td align="center">Edit Fields (Set)</td><td align="center">自定义数据字段，适配下游节点的数据格式要求</td></tr><tr><td align="center"> </td><td align="center">Split In Batches</td><td align="center">将大批量数据拆分为小批次处理，避免节点超时、接口限流</td></tr><tr><td align="center">脚本扩展</td><td align="center">Function</td><td align="center">编写 JS 代码片段自定义处理逻辑，实现内置节点无法覆盖的个性化需求</td></tr><tr><td align="center"> </td><td align="center">FunctionItem</td><td align="center">对数据流中的每一条数据逐项执行 JS 脚本，适配逐条数据处理场景</td></tr><tr><td align="center"> </td><td align="center">Code (Execute Command)</td><td align="center">调用外部命令 / 脚本（如 Shell、Python），扩展 n8n 的底层操作能力</td></tr></tbody></table><h3>3. Cluster・AI 节点（智能能力封装）</h3><p>Cluster AI 节点核心是「Root（根节点）+ Sub（子节点）」组合模式：</p><ul><li>示例 1：<code>Tools Agent（根） + Chat Model（子）</code> → 实现基础智能工具调用 Agent</li><li>示例 2：<code>Tools Agent（根） + Chat Model（子） + Retriever（子） + Vector Store（子）</code> → 实现带 RAG 能力的智能问答 Agent</li></ul><table><thead><tr><th align="center">节点子类</th><th align="center">节点（官方名称）</th><th align="center">核心能力 &amp; 高频场景</th></tr></thead><tbody><tr><td align="center">Agent Root</td><td align="center">Tools Agent</td><td align="center">LangChain Agent 根节点，自动规划并调用工具完成任务，适配复杂智能交互场景</td></tr><tr><td align="center"> </td><td align="center">Plan-Execute Agent</td><td align="center">先规划执行步骤、再逐步骤执行的智能 Agent，适配多步骤任务拆解与执行</td></tr><tr><td align="center"> </td><td align="center">OpenAI Functions Agent</td><td align="center">基于 OpenAI Functions 的 Agent，适配调用外部工具的智能对话场景</td></tr><tr><td align="center">Chain Root</td><td align="center">Basic LLM Chain</td><td align="center">基础 LLM 链路，快速封装 “Prompt 输入→LLM 调用→结果输出” 的单链逻辑</td></tr><tr><td align="center"> </td><td align="center">Q&amp;A Chain</td><td align="center">问答专用链路，优化 Prompt 模板与结果解析逻辑，适配问答类场景</td></tr><tr><td align="center">Model 子节点</td><td align="center">Chat Model（OpenAI/Groq/Mistral/Anthropic…）</td><td align="center">对接主流大模型，支持流式对话 / 批量生成，是所有 AI 节点的核心依赖</td></tr><tr><td align="center">RAG 组件</td><td align="center">Retriever</td><td align="center">检索增强生成组件，从海量文本中检索相关信息，补充 LLM 上下文</td></tr><tr><td align="center"> </td><td align="center">Vector Store</td><td align="center">向量库交互组件，存储 / 检索文本向量，支撑 RAG 的核心检索能力</td></tr><tr><td align="center"> </td><td align="center">Prompt Template</td><td align="center">Prompt 模板复用组件，标准化 Prompt 格式，提升 LLM 输出稳定性</td></tr></tbody></table><h3>4. Community 社区节点（生态扩展）</h3><p>官方 + 社区提供 500 + 现成节点，对接主流 SaaS 平台时优先用社区节点（如 Gmail、Notion），无需编写 HTTP 请求或脚本，降低开发成本。</p><table><thead><tr><th align="center">节点子类</th><th align="center">节点（官方名称）</th><th align="center">核心能力 &amp; 高频场景</th></tr></thead><tbody><tr><td align="center">SaaS Trigger</td><td align="center">Gmail Trigger</td><td align="center">订阅 Gmail 邮件事件（如新邮件、邮件归档）触发流程，零代码对接 Gmail</td></tr><tr><td align="center"> </td><td align="center">Notion Trigger</td><td align="center">订阅 Notion 内容变更事件（如页面编辑、数据库新增）触发流程，适配 Notion 自动化</td></tr><tr><td align="center"> </td><td align="center">Slack Trigger</td><td align="center">订阅 Slack 消息 / 频道事件触发流程，适配企业协作场景自动化</td></tr><tr><td align="center"> </td><td align="center">（其他 SaaS Trigger）</td><td align="center">覆盖 500 + 第三方平台事件订阅，零代码对接营销、电商、客服等领域 SaaS 平台</td></tr><tr><td align="center">SaaS Action</td><td align="center">Gmail</td><td align="center">读写 Gmail 邮件、管理标签 / 草稿，实现邮件自动化处理</td></tr><tr><td align="center"> </td><td align="center">Notion</td><td align="center">增删改查 Notion 页面 / 数据库，实现 Notion 内容自动化管理</td></tr><tr><td align="center"> </td><td align="center">HubSpot/Shopify/Telegram 等</td><td align="center">对接营销 / 电商 / 社交类 SaaS 平台，完成数据读写、消息推送、订单处理等垂直业务操作</td></tr></tbody></table><h2>重命名节点</h2><p>有些节点是为了完成一项特定工作的，给这些节点起一个有语义的名字尤为重要。</p><p>在节点上点击鼠标右键就会弹出一个菜单，选择“Rename”就能给这个节点重新起一个名字。</p><p>又或者左键选中这个节点，按一下空格键也能给节点重命名。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542949" alt="" title="" loading="lazy"/></p><h2>配置节点功能</h2><p>一个节点就是一种功能，通常一个节点的配置分成3个部分。</p><p>双击节点会弹出这个节点的配置表。</p><p>左侧（红框）是上一个节点传进来的数据，我们就叫它“入参区”吧。</p><p>中间（黄框）是本节点要做哪些工作的配置区，我们就叫它做“逻辑区”吧。</p><p>右侧（蓝框）是本节点完成工作后，输出给下一个节点的数据，我们就叫它“出参区”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542950" alt="" title="" loading="lazy"/></p><p><strong>入参区</strong>有3个Tab，其实这3个Tab都是指同一个东西，只是展示方式不一样而已。</p><p>Schema 是指入参的元数据，如果用表格类比的话，可以理解为“表头”。</p><p>Table 就是以表格的形式展示入参数据。</p><p>JSON 就是以 JSON 的格式展示入参数据。</p><p><strong>逻辑区</strong>是当前节点的主要工作区域，每个类型的节点的逻辑区配置项都是不一样的，比如上图这个 AI Agent 节点就可以配置它使用哪个大模型对入参数据做哪些处理。</p><p><strong>出参区</strong>就是预览一下我们当前节点处理完的数据。</p><h2>创建备注</h2><p>有一些任务是要几个节点完成一个功能的，通常我们也会给这几个节点来一个统一的说明。</p><p>在画布空白处单击右键，选择”Add sticky note“就可以创建一个”备注“组件。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542951" alt="" title="" loading="lazy"/></p><p>习惯是把这个备注组件放大，包围着一群相关组件。然后双击它，写上这批组件要完成的工作以及其他内容。</p><p>备注组件的编辑是支持 Markdown 语法的。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542952" alt="" title="" loading="lazy"/></p><h2>运行工作流</h2><p>加入你的工作流已经串好了，想要运行整个工作流的话，点击一下画布下方的”Execute workflow“就开始运行了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542953" alt="" title="" loading="lazy"/></p><h2>工作流控制台</h2><p>工作流每一个节点运行情况在哪查看？</p><p>可以点击画布右下角的这个按钮，就会打开控制台。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542954" alt="" title="" loading="lazy"/></p><p>在控制台里可以看到节点运行日志。</p><p>有时候节点报错了也可以在控制台里查看报错信息。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542955" alt="" title="" loading="lazy"/></p><h2>固定上一个节点的数据</h2><p>有时候我们的工作流已经串了很长了，前面的节点都能正常运行，此时我只想调试其中某个节点。如果整个工作流都运行一遍在某些情况下会耗时耗力，尤其是要调用大模型的时候，每次调用都要消耗 token，那都是钱啊。</p><p>此时就可以用 <code>pin</code> 来固定前面所有节点执行完的数据了，就是每次输入过来到当前节点的参数都保持一样，前面的节点就不需要重复执行了，这样能很快方便的调试当前节点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542956" alt="" title="" loading="lazy"/></p><p>当不需要调试后，选择“Unpin”就可以取消固定。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047542957" alt="" title="" loading="lazy"/></p><hr/><p>以上就是本文的全部内容啦，想了解更多n8n玩法欢迎关注<a href="https://link.segmentfault.com/?enc=HPoBjo%2BqVA%2FeQyxkoQ%2BssQ%3D%3D.skgwoEb03A1PwKhSJy08rlsP70ri93v%2FRZamjcxBRGXH4YwRggh48mF4kxk37wg%2B%2FcN35uxtTuDMN1OGL69yG3H%2F1jtiCNBTbyo7D%2F39dft085pnL3aBoAVD8VFYKh54%2FtoCm2vYVyxvYe2AWBLnvW6OHzUBIB1gWFcs8PL2fDE%3D" rel="nofollow" target="_blank">《n8n修炼手册》</a>👏</p><p>最后我还想推荐一下我另一个AI绘画专栏，同样是用工作流的方式，同样是可以本地部署。那就是👉 <a href="https://link.segmentfault.com/?enc=N8CIOczp6Gu0E4oHNpHYFA%3D%3D.NMMjjFhKhaFOxPi9wnXfpsWp4IB7Lfct9XDps0gQrz%2Flyh6%2FyU42OxOYdq%2F7v7hHq%2FHArHPDdo0UPjY3lG%2BR1BV%2B9Qeoa6aX5MmRL3zgyZBgn5z8xEuctGtl3MXHFpirPCqzFpe77H1lXkxsBRZShyYUSxXoXIWb67YCdHV4iXw%3D" rel="nofollow" target="_blank">《ComfyUI中文教程》</a></p><p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p>]]></description></item><item>    <title><![CDATA[汽车能耗智控模型如何提升车辆能效？ 雨大王 ]]></title>    <link>https://segmentfault.com/a/1190000047542995</link>    <guid>https://segmentfault.com/a/1190000047542995</guid>    <pubDate>2026-01-14 18:12:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在“双碳”目标不断推进和能源成本持续攀升的背景下，汽车行业正积极寻求技术创新以实现节能降耗。能耗智控模型作为一项融合物联网、大数据与人工智能的综合性技术，正逐步成为提升车辆能效的关键工具。该模型不仅关注单车能耗优化，更致力于在全生命周期内实现能源使用的精细化管理。<br/>能耗智控模型的核心在于通过多维度数据采集和智能算法，实现对能源流动的精准预测与动态调控。系统会实时监测车辆运行状态、环境参数和驾驶行为，利用机器学习算法建立能耗预测模型，进而制定最优能源分配策略。例如在混合动力车型中，系统可根据实时路况信息自动调整发动机与电机的工作模式，在保证动力性能的同时最大限度降低燃油消耗。这种动态优化能力使能耗智控模型相较于传统控制方式具有显著优势，其节能效果普遍可达10%-15%。<br/>值得注意的是，该技术的应用范畴正在不断扩展。从最初的单一车辆能耗管理，逐步发展到车队级能源调度优化，甚至与智能电网实现协同互动。某些先进系统已经能够结合实时电价信息，智能选择充电时段，既降低用车成本，又为电网削峰填谷作出贡献。这种跨领域的能源协同管理，彰显了能耗智控模型的巨大潜力。<br/>在实际应用层面，广域铭岛基于工业互联网平台开发的能耗智控系统颇具代表性。该系统在某汽车制造企业实施后，通过实时监测生产设备能耗数据，结合生产工艺参数进行动态优化，使涂装车间能耗降低8.7%，年节省能源成本达数百万元。其创新之处在于将能耗控制与生产工艺深度融合，实现了从单一设备节能向全过程能效优化的跨越。<br/>除了制造业应用，在整车能耗控制方面，吉利银河星舰7搭载的AI智慧能量管理系统表现突出。该系统通过预测性油电分配、智能热管理和能量回收等技术，实现了CLTC工况下3.75L/100km的超低亏电油耗。<br/>与此同时，比亚迪的智能能耗管理系统采用了独具特色的控制策略。该系统在电量充足时优先使用电能，当电量降至15%左右时才启动发动机，不仅在能耗方面表现优异，还有效延长了电池组的使用寿命。<br/>总体而言，汽车能耗智控模型正在重塑行业的能源使用方式。随着5G、车联网等技术的普及，未来能耗智控模型将与智能交通系统深度结合，实现车路协同的全局能源优化。这不仅将推动汽车产业绿色转型，也为用户带来更经济、更环保的出行体验。虽然目前该技术仍面临数据质量、算法精度等挑战，但其发展前景值得期待。</p>]]></description></item><item>    <title><![CDATA[让 Cursor AI 助手秒懂向量数据库 —— Cursor seekdb 扩展插件使用指南 老纪]]></title>    <link>https://segmentfault.com/a/1190000047543028</link>    <guid>https://segmentfault.com/a/1190000047543028</guid>    <pubDate>2026-01-14 18:11:31</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在 AI 辅助编程时代，开发者越来越依赖智能工具来提升编码效率。然而，当你在 Cursor 中询问 seekdb 相关问题时，AI 可能无法给出准确的回答——因为它可能还不够了解 seekdb 这款刚发布不久的 AI 原生搜索数据库。</p><p>本文将为大家介绍如何通过 <strong>seekdb Cursor Extension</strong>，让 Cursor AI 助手拥有 seekdb 专业知识，从而在大家基于 seekdb 进行 AI 应用开发的过程中获得精准的技术指导。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543031" alt="" title=""/></p><h2><strong>什么是 seekdb？</strong></h2><p><strong>seekdb</strong> 是由 OceanBase 推出的一款 AI 原生搜索数据库。它在单一引擎中统一了关系型数据、向量、文本、JSON 和 GIS 等多种数据模型，支持混合搜索和数据库内的 AI 工作流。</p><p>seekdb 的典型应用场景包括：</p><ul><li><strong>RAG 与知识检索</strong>：为大语言模型引入实时可信的外部知识，提升回答质量</li><li><strong>AI 辅助编程</strong>：为代码仓库构建向量和全文索引，实现基于语义的代码搜索</li><li><strong>语义搜索引擎</strong>：捕捉用户搜索意图，实现跨模态精准检索</li><li><strong>智能体（Agent）应用</strong>：为 AI Agent 提供记忆、规划、感知和推理的统一基础</li></ul><h2><strong>什么是 seekdb Cursor Extension？</strong></h2><p><strong>seekdb Cursor Extension</strong> 是一款 Cursor 扩展，它通过在 <code>.cursor/rules</code> 目录下添加规则，使 Cursor AI 助手能够检索 seekdb 官方文档，从而理解 seekdb 数据库知识，使其能够：</p><ul><li>✅ <strong>理解 seekdb 数据库概念</strong>：向量搜索、混合搜索、AI 函数等</li><li>✅ <strong>提供准确的代码建议</strong>：基于官方文档生成符合最佳实践的代码</li><li>✅ <strong>回答 seekdb 相关问题</strong>：直接在编辑器中获取技术支持</li><li>✅ <strong>加速开发流程</strong>：减少查阅文档的时间，专注于业务逻辑</li></ul><h3><strong>核心特性</strong></h3><ul><li>🚀 <strong>一键安装</strong>：通过 Cursor 扩展市场或命令面板快速安装</li><li>📚 <strong>完整文档</strong>：检索 seekdb 官方文档知识库，涵盖向量搜索、混合搜索、AI 函数等全面技术文档</li><li>🌐 <strong>双模式支持</strong>：优先从 GitHub 获取最新文档，本地文档作为备份</li></ul><h2><strong>快速开始</strong></h2><h3><strong>第一步：安装扩展</strong></h3><ol><li>在 Cursor 中打开扩展市场（<code>Ctrl+Shift+X</code> 或 <code>Cmd+Shift+X</code>）</li><li>搜索 "seekdb"</li><li>点击 <strong>Install</strong> 安装扩展</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543032" alt="" title="" loading="lazy"/></p><h3><strong>第二步：添加 seekdb 文档</strong></h3><ol><li>使用 Cursor 打开一个项目目录（文档将添加到该目录下）</li><li><p>打开命令面板：</p><ul><li>Windows/Linux: 按 <code>Ctrl+Shift+P</code></li><li>macOS: 按 <code>Cmd+Shift+P</code></li></ul></li><li><p>输入并选择命令：</p><ul><li>输入 <strong>"seekdb"</strong> 或 <strong>"Add seekdb Docs"</strong></li><li>选择 <code>Add seekdb Docs</code> 命令</li></ul></li><li><p>文档将自动添加：</p><ul><li><code>.cursor/rules/seekdb-docs</code> 目录（官方文档）</li><li><code>.cursor/rules/seekdb.mdc</code> 文件（规则文件）</li></ul></li><li>重新加载窗口使规则生效</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543033" alt="" title="" loading="lazy"/></p><p>安装完成！现在你可以直接向 Cursor AI 助手询问任何 seekdb 相关问题了。</p><h2><strong>实际效果演示</strong></h2><p>让我们通过一个实际示例，看看 seekdb Cursor Extension 如何帮助你进行开发。</p><h3><strong>示例：使用 AI 助手创建一个 seekdb 混合搜索应用</strong></h3><p>安装扩展并添加文档后，在 Cursor 中开始一个新对话，输入以下问题：</p><p><strong>例如</strong>：我想用 Python 创建一个简单的 seekdb 应用，实现文档的混合搜索功能，请帮我写代码。</p><p><strong>Cursor AI 助手此时就会给出准确的回答</strong>：</p><pre><code class="plain">"""
seekdb 混合搜索快速入门示例

这是一个最简化的混合搜索示例，帮助你快速上手。
"""

import pyseekdb

# 1. 创建客户端（嵌入式模式，无需部署数据库）
client = pyseekdb.Client()

# 2. 创建集合
collection = client.get_or_create_collection(name="my_docs")

# 3. 添加文档
documents = [
    "机器学习是人工智能的核心技术",
    "Python 是最流行的机器学习编程语言",
    "深度学习需要大量的训练数据",
    "自然语言处理让计算机理解人类语言",
    "向量数据库用于存储和检索向量数据",
]

metadatas = [
    {"category": "AI", "year": 2024},
    {"category": "Programming", "year": 2024},
    {"category": "AI", "year": 2023},
    {"category": "AI", "year": 2024},
    {"category": "Database", "year": 2024},
]

ids = [f"doc_{i}"for i in range(len(documents))]

collection.add(ids=ids, documents=documents, metadatas=metadatas)
print(f"✅ 已添加 {len(documents)} 个文档")

# 4. 执行混合搜索
# 结合全文搜索（包含"机器学习"）和向量语义搜索（查找与"AI技术"相似的内容）
results = collection.hybrid_search(
    query={
        "where_document": {"$contains": "机器学习"},  # 全文搜索：包含关键词
        "n_results": 10,
    },
    knn={
        "query_texts": ["AI技术"],  # 向量搜索：语义相似性
        "n_results": 10,
    },
    rank={"rrf": {}},  # 使用 RRF 算法融合结果
    n_results=3,
    include=["documents", "metadatas"],
)

# 5. 打印结果
print("\n🔍 混合搜索结果:")
for i, (doc_id, doc, meta) in enumerate(
    zip(results["ids"][0], results["documents"][0], results["metadatas"][0]), 1
):
    print(f"  [{i}] {doc}")
    print(f"      元数据: {meta}\n")

# 6. 清理（可选）
# client.delete_collection("my_docs")</code></pre><h3><strong>运行示例</strong></h3><ol><li><strong>安装 pyseekdb</strong></li></ol><pre><code class="plain">pip install pyseekdb</code></pre><ol start="2"><li><strong>运行代码</strong></li></ol><pre><code class="plain">python quick_start_hybrid_search.py</code></pre><ol start="3"><li><strong>查看结果</strong></li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543034" alt="" title="" loading="lazy"/></p><p>混合搜索结合了<strong>关键词匹配</strong>（包含 "机器学习" 的文档）和<strong>语义搜索</strong>（与 "AI 技术" 语义相近的文档），通过 RRF（Reciprocal Rank Fusion）算法融合两路检索结果，返回最相关的文档。RRF 的具体含义详见这篇基础概念文章<a href="https://link.segmentfault.com/?enc=aW8Uh337KdpH%2BP%2Fk91Sgww%3D%3D.DoMzw6uNTU4Y8a7nduuzYAVWggV%2FXh1AjeYRbVwATBYtN0eQbwmHj3lHB9FrZ%2BSAlRTZIp6bUZi1jz%2B6%2B9s5Sye19xjiHXXIdfb5qabeJTD68jvDPjNnGv1%2B6Yphz%2B23q6KCZa2GRgDx8puLLXfyrmD5jcLIg97Vlin01jI7Ijw4ulSSxglHYNxD4GLnzv4o" rel="nofollow" target="_blank">《浅入了解混合搜索》</a>。</p><p>特别说明：seekdb 的嵌入式模式暂时只支持 Linux 服务器，如果是在 Mac 或者 Windows 本地测试，需要把 Python 代码里的 <code>client = pyseekdb.Client()</code> 改成服务器模式的连接地址（推荐在 Mac 或者 Windows 上使用 seekdb 桌面版）。</p><pre><code class="plain">client = pyseekdb.Client(
    host="127.0.0.1",      # Server host
    port=2881,              # Server port (default: 2881)
    database="test",        # Database name
    user="root",            # Username (default: "root")
    password=""             # Password (can be retrieved from SEEKDB_PASSWORD environment variable)
)</code></pre><h2><strong>更多使用场景</strong></h2><p>安装 seekdb Cursor Extension 后，你可以向 AI 助手询问各种 seekdb 相关问题：</p><h3><strong>基础查询</strong></h3><ul><li>如何开始使用 seekdb？</li><li>seekdb 支持哪些部署模式？</li></ul><h3><strong>技术问题</strong></h3><ul><li>如何在 seekdb 中创建向量索引？</li><li>seekdb 的 AI 函数有哪些？如何使用 AI_EMBED 函数？</li></ul><h3><strong>代码示例</strong></h3><ul><li>展示一个使用 seekdb SQL 实现向量相似度搜索的示例。</li><li>如何将 seekdb 与 LangChain 集成？</li></ul><h3><strong>集成相关</strong></h3><ul><li>seekdb 如何配置 OpenAI 模型进行向量嵌入？</li></ul><h2><strong>工作原理</strong></h2><p>seekdb Cursor Extension 的工作原理非常简单：</p><ol><li><strong>规则文件注入</strong>：扩展将 seekdb 官方文档和 <code>.mdc</code> 规则文件添加到 <code>.cursor/rules</code> 目录</li><li><strong>AI 上下文增强</strong>：Cursor 会自动读取 <code>.cursor/rules</code> 目录中的内容，作为 AI 助手的上下文知识</li><li><strong>智能检索</strong>：当你询问 seekdb 相关问题时，AI 助手会基于这些文档提供准确的回答</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543035" alt="" title="" loading="lazy"/></p><h2><strong>移除文档</strong></h2><p>如果你不再需要 seekdb 文档，可以轻松移除：</p><ol><li>打开命令面板（<code>Ctrl+Shift+P</code> 或 <code>Cmd+Shift+P</code>）</li><li>输入 <strong>"Remove seekdb Docs"</strong></li><li>选择该命令执行</li></ol><p>文档将从 <code>.cursor/rules</code> 目录中移除。</p><h2><strong>总结</strong></h2><p>通过 <strong>seekdb Cursor Extension</strong>，你可以在使用 Cursor 进行开发时，随时获取 seekdb 的官方文档支持。无论是学习 seekdb 的新功能，还是解决开发中遇到的技术问题，AI 助手都能基于最新的官方文档提供准确的指导~</p>]]></description></item><item>    <title><![CDATA[技术干货 ｜AutoMQ x AWS FSxN: 性能报告 AutoMQ ]]></title>    <link>https://segmentfault.com/a/1190000047543048</link>    <guid>https://segmentfault.com/a/1190000047543048</guid>    <pubDate>2026-01-14 18:10:58</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2><strong>背景</strong></h2><p>AutoMQ 是一款基于 S3 构建的下一代“Diskless Kafka”，完全兼容 Kafka 协议。其云原生架构通过存算分离和按需弹性，显著提升了运维效率。最核心的突破在于，它利用共享存储消除了昂贵的跨可用区（Cross-AZ）数据传输费用，这能为多可用区集群每月节省数千甚至上万美元的网络成本。</p><p>在保持极致性价比的同时，AutoMQ 于 2025 年 12 月发布的版本正式引入了对 AWS FSx 作为 WAL 存储选项的支持，以进一步攻克 Diskless 架构的延迟瓶颈。这一演进使 AutoMQ 能够提供媲美本地磁盘的毫秒级延迟，同时保留零跨可用区流量成本和多可用区容灾能力，在低成本、高可靠与极致性能之间实现了完美平衡。</p><p>为了在真实生产环境下验证这些架构优势，我们进行了一系列性能基准测试，重点关注客户端观测到的端到端延迟。</p><blockquote><p>Tips:</p><ul><li>AutoMQ FSxN 能力的正式发布请参考文章：<a href="https://link.segmentfault.com/?enc=qwp%2BsIS0d01cHVtBpJtpsg%3D%3D.GB87R%2BqTEvMmstU3EhhIO9yFqsBSug6p%2Bz%2FcYiq9ZX3uypmh76a5OO37z4Zl%2FhbZl5SCjuDUMVqZ2h5FLXBEPg7hozuKEmZ4eZSLfuZe4gQ%3D" rel="nofollow" target="_blank">AutoMQ x FSx: 10ms Latency Diskless Kafka on AWS</a></li><li>AutoMQ FSxN 实现原理介绍请参考文章： <a href="https://link.segmentfault.com/?enc=oj0I1Z3Arp36195FG90xJA%3D%3D.ZQ4NChXMOmI5J7mizJhYVPW0%2FeIxCfBT5MNtnggV12GQkPwcaS3JHs1GcGlQ3TH1XreTeD9Qw3LWbvuBLPJsnNjZwFPdMpbUHVMRmw2E8QY%3D" rel="nofollow" target="_blank">How does AutoMQ implement a sub-10ms latency Diskless Kafka？</a></li></ul></blockquote><h2><strong>测试场景和结果</strong></h2><p>要理解测试结果，我们首先需要拆解延迟的产生环节：</p><h3><strong>延迟的构成</strong></h3><p>从业务视角来看，延迟主要源于两个方面：Kafka 客户端的排队延迟以及服务端的处理延迟。在接下来的章节中，我们将对这两个部分进行拆解分析，从而让大家能够清晰地理解 AutoMQ 结合 FSxN 设计对二者的具体影响。</p><h4><strong>服务端处理延迟</strong></h4><p>传统的 Kafka 架构服务端的主要延迟消耗在：客户端与服务的跨 AZ 通信，以及副本完成跨 AZ 复制（ACK=ALL）。这两段的跨 AZ 通信都是直接的 RPC 请求，在 AWS 上会产生高额的流量。</p><p>AutoMQ 从整体架构上做了一些变化：采用 AWS FSx 作为 WAL 存储，省去副本复制的流量费；同时通过 FSx 中继客户端和服务端的跨 AZ 请求，减少客户端和服务端的跨 AZ 流量费。由于增加了转发逻辑，会带来少量额外的处理延迟，但却极大的减少了流量成本。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543051" alt="" title=""/></p><h4>客户端排队延迟</h4><p>Kafka 生产者采用“先攒批、后发送”的两阶段设计：首先将消息按分区在内存中累积，当达到<code>batch.size</code> 大小或 <code>linger.ms</code> 时间则会将消息放入就绪队列等待发送；网络层在并发限制内，从队列取出批次并发送到服务端。</p><p>在追求极致吞吐的场景下，业务常通过调大 <code>linger.ms</code> 主动攒批，但这会导致请求在客户端排队，从而在业务视角表现为更高的延迟；通常可通过 <code>linger.ms</code> 和 <code>batch.size</code> 两个参数在吞吐与延迟之间进行权衡。这一块可以参考之前的文章，里面有详细介绍：<a href="https://link.segmentfault.com/?enc=M0fXSi5jlZ%2FuLZecemnA2A%3D%3D.KBp6G9j7TetUkdQ4RsMbVbJnKhoDwJS5LI0fX6jMm%2BLCF%2BCe40sH%2FYQ8mfXWt5DjfD%2FraPQBWObEe632TuG5lt8jUhm2YrTqIMZV4lVWcaA%3D" rel="nofollow" target="_blank">Kafka Performance Tuning: Best Practice for linger.ms and batch.size</a></p><h3><strong>测试场景选择</strong></h3><p>为了全面、客观地评估 AutoMQ 在引入 AWS FSxN 后的性能表现，并提供具备实战参考价值的性能数据，我们将测试场景设定为两个维度：<strong>极致性能基准（Baseline）与生产稳态模型（Robustness）</strong>。</p><h4><strong>极致性能基准场景：服务端延迟物理上限测试</strong></h4><p>在分布式系统中，客户端的排队机制往往会掩盖存储介质真实的 I/O 响应。因此，我们首先通过设置 <code>linger.ms=0</code> 且在低并发压力下进行测试，旨在构建一个“零排队”的理想环境。</p><ul><li><strong>测试目的：</strong> 剥离客户端干扰，直接探测 AutoMQ 结合 FSxN WAL 后的<strong>服务端核心处理时延</strong>与<strong>网络中继损耗</strong>，确立该方案的物理性能边界。</li></ul><h4><strong>生产稳态模型场景：高吞吐下的确定性延迟测试</strong></h4><p>在真实的生产实践中，流量波动（Burst）、生产者扩缩容以及分区负载不均是常态。为了追求吞吐量与成本的平衡，开发者通常会通过 <code>linger.ms</code> 和 <code>batch.size</code> 进行攒批调优。</p><ul><li><strong>测试目的：</strong> 我们选取了典型的生产配置（如 <code>linger.ms=3</code>），并模拟<strong>集群满负载运行</strong>状态。此场景旨在验证在真实业务压力下，AutoMQ 是否能提供<strong>高确定性的延迟输出</strong>，并观察其在处理海量小包写入（High TPS）时的尾部延迟（P99/P999）表现。</li></ul><p>通过这两个维度的对比，我们不仅能展示该方案在理想状态下的爆发力，更能证明其在复杂生产环境下作为核心基础设施的稳定性。</p><h3><strong>详细测试</strong></h3><p>测试环境如下：</p><ul><li>使用 <a href="https://link.segmentfault.com/?enc=QWod9jsU9N7tOKvbDrtSXA%3D%3D.ZWRfRzPq7MkV8XhLU0N%2FFcOVtgPqq6iPx419keBsQ0hMzBYqssR8FOCAsSi%2BPUEu" rel="nofollow" target="_blank">OpenMessaging</a> 基准测试框架，写入总吞吐 300MiB/s，Fanout 比例为 1:4；</li><li>Server: m7g.4xlarge *3;</li><li>WAL Storage: FSx 736MBps、1T SSD、3072IOPS;</li><li>Client: m7g.4xlarge *3;</li><li>集群水位满载运行；</li></ul><h4><strong>耗时最短的场景</strong></h4><p>为了探测系统的物理性能上限，我们构建了一个“零排队”的理想环境，重点调整了影响时延的关键参数：</p><ul><li><code>batch.size</code>=64K、<code>linger.ms</code>=0（默认）</li><li>不开压缩（开启压缩会降低写入吞吐量，带来更低的写入延迟，降低测试场景的挑战）</li></ul><p>具体配置如下：</p><pre><code>name: Kafka
driverClass: io.openmessaging.benchmark.driver.kafka.KafkaBenchmarkDriver
# Kafka client-specific configuration
replicationFactor: 1
topicConfig: |
  min.insync.replicas=2
commonConfig: |
  bootstrap.servers=10.0.0.112:9092
producerConfig: |
  acks=1
  batch.size=65536
  client.id=automq_type=producer&amp;automq_az=us-east-1b
consumerConfig: |
  auto.offset.reset=earliest
  enable.auto.commit=true
  client.id=automq_type=consumer&amp;automq_az=us-east-1b</code></pre><ul><li>Record Size = 64 KB</li><li>写入 TPS = 4,800</li><li>分区总数 = 96</li><li>Producer 数量 = 48</li></ul><p>工作负载配置如下：</p><pre><code>name: Lowest latency case
topics: 1
partitionsPerTopic: 32
messageSize: 65536
payloadFile: "payload/payload-64Kb.data"
subscriptionsPerTopic: 4
consumerPerSubscription: 16
producersPerTopic: 16
producerRate: 1600
consumerBacklogSizeGB: 0</code></pre><h5><strong>运行结果</strong></h5><p>写入总吞吐图 300MiB/s，读取约 1.2GiB/s；</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543052" alt="" title="" loading="lazy"/></p><p>CPU 消耗约 27.5%，内存占用约 10G；</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543053" alt="" title="" loading="lazy"/></p><p>写入平均延迟 6.0ms、P99 13.11ms、P999 17.68ms；</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543054" alt="" title="" loading="lazy"/></p><p>端到端平均延迟 7.79ms、19.0ms、29.0ms；</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543055" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543056" alt="" title="" loading="lazy"/></p><p><code>linger.ms</code>=0 即不等待攒批完成，如果当前进行中请求不超过请求最大并发数，则会立即将消息发送到服务端，这种情况下耗时客户端耗时最短。但当随着业务量峰谷的变化，写入吞吐量、TPS 上涨等，可能会受请求并发数限制产生额外的客户端排队，从而影响最终的延迟。</p><p>所以，该场景为理想情况下的延迟；虽然耗时更短，但容易受业务量、客户端数量的影响出现起伏，不够稳定。</p><h4><strong>耗时更加稳定的场景</strong></h4><p>既然极致性能场景存在波动的风险，那么在追求吞吐量与稳定性平衡的生产环境下，AutoMQ 的表现又会如何呢？接下来让我们观察在开启客户端攒批后的稳态测试结果。</p><ul><li><code>batch.size</code>=64K</li><li><code>linger.ms</code>=3（根据服务端处理耗时估算出客户端攒批的时间）</li></ul><p>具体配置如下：</p><pre><code>name: Kafka
driverClass: io.openmessaging.benchmark.driver.kafka.KafkaBenchmarkDriver
# Kafka client-specific configuration
replicationFactor: 1
topicConfig: |
  min.insync.replicas=2
commonConfig: |
  bootstrap.servers=10.0.0.112:9092
producerConfig: |
  acks=1
  linger.ms=3
  batch.size=65536
  client.id=automq_type=producer&amp;automq_az=us-east-1b
consumerConfig: |
  auto.offset.reset=earliest
  enable.auto.commit=true
  client.id=automq_type=consumer&amp;automq_az=us-east-1b</code></pre><p>更小的消息会带来更多的写入消耗，为了更有通用性，我们将 recordsize 设置了更小，以使结果在更多的场景适用。</p><ul><li>record.size = 1K</li><li>写入 TPS = 307200</li><li>分区总数 = 96</li><li>Producer = 15</li></ul><p>具体工作负载配置如下：</p><pre><code>name: 1 Robust latency case
topics: 1
partitionsPerTopic: 32
messageSize: 1024
payloadFile: "payload/payload-1Kb.data"
subscriptionsPerTopic: 4
consumerPerSubscription: 5
producersPerTopic: 5
producerRate: 102400
consumerBacklogSizeGB: 0</code></pre><h5><strong>运行结果</strong></h5><p>写入总吞吐图 300MiB/s，读取约 1.2GiB/s；</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543057" alt="" title="" loading="lazy"/></p><p>CPU 消耗约 31.5%，内存占用约 14G；</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543058" alt="" title="" loading="lazy"/></p><p>写入平均延迟 7.89ms、P99 16.30ms、P999 30.26ms；</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543059" alt="" title="" loading="lazy"/></p><p>端到端平均延迟 9.88ms、22.0ms、38.0ms；</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543060" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543061" alt="" title="" loading="lazy"/></p><p>增加了<code>linger.ms</code>=3 会带来额外的客户端延迟，但能带来更加稳定的攒批结果，能更好的应对业务流量峰谷，集群扩缩容 Producer 数目变化对延迟的影响，能够提供更加稳定的延迟表现，在实际生产中更具有参考意义。</p><p>此外，测试用例是按照集群满负载的情况运行，对 P99、P999 的更具有挑战。AutoMQ 内部经过大量优化，以确保文件系统耗时更加稳定。</p><p>从文件系统写入延迟热力图看 90%的写入响应都在 1ms 以下，同时 91%的读取都在 1ms 以下。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543062" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543063" alt="" title="" loading="lazy"/></p><h2><strong>关于成本</strong></h2><p>看到这里，你可能会产生疑问：既然性能实现了如此惊人的飞跃，成本是否也会随之“水涨船高”？</p><p>事实恰恰相反。在 AutoMQ 的集成架构中，FSxN 并非用于海量数据的长期堆积，而是仅作为“高速缓冲站”运行。它只负责承载极少量的最新预写日志（WAL），而海量的业务数据依然存储在价格极低的 S3 中。</p><p>为什么成本依然极低：</p><ul><li><strong>按需占用，规模固定：</strong> 由于数据会迅速沉降到 S3 存储桶，FSxN 仅需占用极小且固定的资源容量，不会随业务数据量的增长而产生高额费用。</li><li><strong>省下巨额流量费：</strong> 虽然集成 FSxN 会带来少量的资源开销，但它彻底消除了传统 Kafka 最昂贵的“跨 AZ 复制流量费”。</li><li><strong>99% 的存储在 S3：</strong> 绝大部分数据都存储在成本极低的 S3 上。</li></ul><p>这意味着即使集成了 FSxN 提升性能，AutoMQ 的整体拥有成本（TCO）依然比传统 Kafka 节省近 90%。</p><p>详细可以查看：👉 <a href="https://link.segmentfault.com/?enc=2J706U%2Bw87mltZ6%2BYSwSCg%3D%3D.%2B1kXqIS%2BQy4fVI0p3up%2FJaCSo9jUk9j9qHzpWVDms%2FsKM3LJ06V5zs0VhcKBkxLFsD%2BiX%2FT0pHX%2Ftj3OMZCH%2FFuEshvt13NFl%2FVlzd4AAPI%3D" rel="nofollow" target="_blank">AutoMQ x FSx: 10ms Latency Diskless Kafka on AWS</a></p><h2><strong>总结</strong></h2><p>通过引入 FSxN 作为 WAL，<a href="https://link.segmentfault.com/?enc=HqEMigMDkuKJhug9E%2Fq8mw%3D%3D.iI20QAICQXTeEsIsSzOOu3qD285xn26KYKT0Ap1Bq34%3D" rel="nofollow" target="_blank">AutoMQ</a> 在保持跨 AZ 容灾与 S3 存算分离优势的同时，将平均写入延迟从数百毫秒大幅降至 10ms 以内，性能表现媲美本地磁盘。这一突破彻底补齐了 Diskless 架构的性能短板，使其能够以极具竞争力的成本和高稳定性，完美支撑微服务、风控及交易撮合等延迟敏感型核心业务。</p>]]></description></item><item>    <title><![CDATA[CSS终于能做瀑布流了！三行代码搞定,告别JavaScript布局 沉浸式趣谈 ]]></title>    <link>https://segmentfault.com/a/1190000047543077</link>    <guid>https://segmentfault.com/a/1190000047543077</guid>    <pubDate>2026-01-14 18:10:00</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大家好，我是 Immerse，一名独立开发者、内容创作者、AGI 实践者。</p><p>关注公众号：<a href="https://link.segmentfault.com/?enc=uS8sHQfBuG0J3%2Fz%2Bh9jJkw%3D%3D.vfDJdkLwMM%2FeqNZDy8KJAfeTXGxUbCbPkE2M6o5L9lwBgcDSIaQl%2BX5qKOTm9iBYrIUHSiYcb%2BwcSyAN4XhFMw%3D%3D" rel="nofollow" target="_blank">沉浸式趣谈</a>，获取最新文章（更多内容只在公众号更新）</p><p>个人网站：<a href="https://link.segmentfault.com/?enc=zz9sJ9NEfIQOhaV8LHO25A%3D%3D.jbjyTYBuXufgDSOPkOJLloHf857WZUiCUIhZnILcFGg%3D" rel="nofollow" target="_blank">https://yaolifeng.com</a> 也同步更新。</p><p>转载请在文章开头注明出处和版权信息。</p><p>我会在这里分享关于<code>编程</code>、<code>独立开发</code>、<code>AI干货</code>、<code>开源</code>、<code>个人思考</code>等内容。</p><p>如果本文对您有所帮助，欢迎动动小手指一键三连(<code>点赞</code>、<code>评论</code>、<code>转发</code>)，给我一些支持和鼓励，谢谢！</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543079" alt="" title=""/></p><p>之前做瀑布流布局，要么用 Masonry.js 这种库，要么自己写一堆 JavaScript 计算位置。</p><p>现在好了，CSS Grid Lanes 来了，三行代码就搞定。</p><p>Safari 技术预览版已经支持了，你现在就能试。</p><h2>三行代码实现瀑布流</h2><p>看最简单的用法。</p><pre><code class="css">.container {
    display: grid-lanes;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 16px;
}</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543080" alt="" title="" loading="lazy"/></p><p>就这样。</p><p>第一行设置 <code>display: grid-lanes</code>，告诉浏览器用 Grid Lanes 布局。</p><p>第二行定义列，至少 250px 宽，自动填充所有可用空间。浏览器会根据屏幕宽度决定显示几列。</p><p>第三行设置间距，列与列之间、卡片与卡片之间都是 16px。</p><p>不用写 JavaScript，不用算高度，不用考虑响应式。浏览器全帮你搞定了。</p><h2>原理是什么？</h2><p>把它想象成堵车的高速公路。</p><p>每辆车都想往前挤，哪条车道空就往哪条钻。每个新卡片也一样，浏览器会把它放在最靠上的位置。</p><p>这样布局出来的效果和 Masonry.js 一模一样，但性能好太多了。</p><p>如果你要做无限滚动加载更多内容，也不用 JavaScript 控制布局了。滚到底部加载新数据，浏览器自动把新卡片摆好。</p><h2>列宽可以不一样</h2><p>因为底层用的是 CSS Grid，你可以做各种花样。</p><p>比如奇数列窄，偶数列宽，最后一列始终是窄的：</p><pre><code class="css">.container {
    display: grid-lanes;
    grid-template-columns: repeat(auto-fill, minmax(8rem, 1fr) minmax(16rem, 2fr)) minmax(8rem, 1fr);
}</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543081" alt="" title="" loading="lazy"/></p><p>这样布局出来就有节奏感了，不会显得太死板。</p><h2>卡片可以跨列</h2><p>既然是 Grid，那肯定能跨列。</p><pre><code class="css">article {
    grid-column: span 1;
}

article:nth-child(1) {
    grid-column: span 4;
}

article:nth-child(2),
article:nth-child(3) {
    grid-column: span 2;
}</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543082" alt="" title="" loading="lazy"/></p><p>第一张卡片占 4 列做头图，第 2 到第 3 张占 2 列做次要内容，其他的占 1 列。</p><p>这种布局以前只能用 JavaScript 计算，现在纯 CSS 就行。</p><p>报纸那种复杂版式也能做出来了。</p><h2>固定位置也可以</h2><p>你还能指定某个元素放在特定位置。</p><p>比如把 header 固定在最右边的两列：</p><pre><code class="css">main {
    display: grid-lanes;
    grid-template-columns: repeat(auto-fill, minmax(24ch, 1fr));
}

header {
    grid-column: -3 / -1;
}</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543083" alt="" title="" loading="lazy"/></p><p>不管屏幕多宽，header 都会出现在右边。其他内容该怎么排怎么排。</p><h2>横向布局也能做</h2><p>瀑布流是竖着流，Grid Lanes 也能横着流。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543084" alt="" title="" loading="lazy"/></p><p>竖着流用 <code>grid-template-columns</code> 定义列：</p><pre><code class="css">.container {
    display: grid-lanes;
    grid-template-columns: 1fr 1fr 1fr 1fr;
}</code></pre><p>横着流就用 <code>grid-template-rows</code> 定义行：</p><pre><code class="css">.container {
    display: grid-lanes;
    grid-template-rows: 1fr 1fr 1fr;
}</code></pre><p>浏览器会根据你定义的是列还是行，自动判断流的方向。</p><p>不用额外设置什么属性，它自己就知道。</p><h2>容错度控制</h2><p>有个新概念叫容错度。</p><p>假设第一列的卡片高度是 100px，第四列是 99px。下一张卡片应该放哪？</p><p>如果追求绝对精确，应该放第四列，因为它矮 1px。</p><p>但这 1px 根本看不出来，而且会导致卡片顺序很乱。用户 Tab 切换时会跳来跳去。</p><p>所以 Grid Lanes 有个默认容错度 <code>1em</code>。只有高度差超过 1em，浏览器才会认为它们不一样。</p><p>小于 1em 的差异会被忽略，卡片会更倾向于从左到右排列。</p><p>你可以调整这个值：</p><pre><code class="css">.container {
    item-tolerance: 2em;
}</code></pre><p>设大一点，布局更规整，但可能浪费空间。设小一点，空间利用率高，但顺序会更乱。</p><p>根据你的内容大小和内容差异来调。</p><p>注意这个属性名字可能还会改，正式发布前留意一下。</p><h2>现在就能试</h2><p>Safari 技术预览版 234 已经支持了。</p><p>你可以下载来试试，官方 Demo 网站也更新了新语法。</p><p>除了图片瀑布流，还有其他用法。</p><p>比如做 Mega Menu 的底部链接区域。每组链接高度不同，用 Grid Lanes 排起来非常整齐：</p><pre><code class="css">.container {
    display: grid-lanes;
    grid-template-columns: repeat(auto-fill, minmax(max-content, 24ch));
    column-gap: 4lh;
}</code></pre><p>各组链接紧密排列，不会浪费空间。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543085" alt="" title="" loading="lazy"/></p><h2>接下来呢</h2><p>CSS 工作组还有几个细节在讨论，但整体语法已经确定了。</p><p>现在可以学起来，可以做 Demo 玩玩，可以给反馈。</p><p>WebKit 团队从 2022 年中开始做这个功能，现在终于能用了。</p><p>我估计其他浏览器也会很快跟进，毕竟这需求太常见了。</p><p>以后做瀑布流，再也不用引 JavaScript 库了。</p><h2>参考资料：</h2><ul><li><a href="https://link.segmentfault.com/?enc=qgNb%2FmjvIhcclt%2FlyPpS4Q%3D%3D.xghQLqwvmeO72Qs3GtS%2Bxm5805PUu%2B%2BLDc8HGsmtpKWWXecjK%2FUVO850WUAFEF8izOaB3iTRp8mTZchAxgfa9g%3D%3D" rel="nofollow" target="_blank">Introducing Grid Lanes</a></li><li><a href="https://link.segmentfault.com/?enc=08i54GjoBd8uSkg0GFZkqQ%3D%3D.DyJTePfahGkDM16El2E%2FMGANOu2W%2FXsDaTFBKH4iO3htWIynP%2BNQ5WoDbAKFT3il" rel="nofollow" target="_blank">Example Gallery</a></li></ul>]]></description></item><item>    <title><![CDATA[List 组件渲染慢？鸿蒙API 21 复用机制深度剖析，一行代码提速 200%！ 威哥爱编程 ]]></title>    <link>https://segmentfault.com/a/1190000047543143</link>    <guid>https://segmentfault.com/a/1190000047543143</guid>    <pubDate>2026-01-14 18:09:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>哈喽，兄弟们，我是 V 哥！</p><p>昨天有个兄弟在群里发了段视频，他的列表在滑动的时候，掉帧掉得像是在放 PPT。他委屈地说：“V 哥，我也用了 <code>LazyForEach</code> 了啊，数据也是懒加载的，怎么划起来还是跟甚至不如 Android 原生的 <code>RecyclerView</code> 流畅？”</p><p>兄弟，你只做到了<strong>“数据懒加载”</strong>，却忘了最关键的<strong>“组件复用”</strong>。</p><p>来吧，不讲虚的理论，直接带你深挖 API 21 的 <strong><code>@Reusable</code> 组件复用机制</strong>。只要你在代码里加这一行装饰器，再配合几行重置逻辑，你的列表性能绝对能原地起飞，<strong>提速 200% 真不是吹NB！</strong></p><h2>痛点直击：为什么你的列表会卡？</h2><p>在 ArkUI 中，渲染一个列表通常涉及两步：</p><ol><li><strong>创建数据</strong>：从后台拿 JSON，解析成对象。</li><li><strong>创建组件</strong>：把数据塞进 <code>Image</code>、<code>Text</code> 这些组件里，生成一棵 UI 树。</li></ol><p>很多兄弟只做了 <code>LazyForEach</code>（数据层面的懒加载）。这意味着：虽然数据只加载了屏幕可见的那 10 条，但是！<strong>当你快速滑动时，屏幕外的 Item 被销毁，屏幕内的新 Item 被创建。</strong></p><p>频繁的 <code>new Component()</code> 和 <code>delete Component()</code> 会带来两个致命问题：</p><ol><li><strong>CPU 爆表</strong>：创建组件要执行 <code>build()</code> 方法，计算布局，解析渲染属性。</li><li><strong>GC 疯狂</strong>：创建的对象多了，垃圾回收器（GC）就要频繁启动。GC 一运行，所有线程暂停，UI 就会瞬间卡顿。</li></ol><p><strong>V 哥的解决方案：别销毁！回收！</strong></p><hr/><h2>终极神器：@Reusable 组件复用</h2><p>API 21 引入的 <code>@Reusable</code> 装饰器，就是让组件拥有“<strong>记忆功能</strong>”。</p><ul><li><strong>没复用前：</strong> 酒店用一次性的拖鞋，客人走了就扔，新客人来了重新造，浪费钱（内存）且慢。</li><li><strong>用了 <code>@Reusable</code>：</strong> 酒店拖鞋回收清洗，下一个客人来了接着穿，只需要稍微整理一下（重置数据）。</li></ul><p>这一行代码就是：</p><pre><code class="typescript">@Reusable
@Component
struct MyItem { ... }</code></pre><hr/><h2>代码实战：手把手教你改造</h2><p>兄弟们，打开 DevEco Studio 6.0，新建一个页面。下面这段代码，V 哥写了一个标准的、高性能的可复用列表。你可以直接复制运行，感受一下那种丝滑。</p><h3>第一步：准备数据模型和基础数据源</h3><p>这是为了模拟真实环境，咱们必须用 <code>IDataSource</code> 接口，为避免冲突，以下的接口名和类名都会加 VG 标记。</p><pre><code class="typescript">// 1. 定义用户数据模型
class VGUserModel {
  id: string = '';
  name: string = '';
  avatarColor: string = ''; // 用颜色代替头像图片，减少代码依赖
}

// 2. 定义基础数据源接口（这是 LazyForEach 的硬性要求）
interface IVGDataSource {
  totalCount(): number;
  getData(index: number): VGUserModel;
  registerDataChangeListener(listener: IVGDataChangeListener): void;
  unregisterDataChangeListener(listener: IVGDataChangeListener): void;
}

// 3. 重命名监听器接口避免冲突
interface IVGDataChangeListener {
  onDataReloaded(): void;
  onDataAdded(index: number): void;
  onDataChanged(index: number): void;
  onDataDeleted(index: number): void;
}

// 4. 实现具体的数据源类
class VGDataSource implements IVGDataSource {
  private listeners: IVGDataChangeListener[] = [];
  private listData: VGUserModel[] = [];

  constructor(data: VGUserModel[]) {
    this.listData = data;
  }

  totalCount(): number {
    return this.listData.length;
  }

  getData(index: number): VGUserModel {
    return this.listData[index];
  }

  registerDataChangeListener(listener: IVGDataChangeListener): void {
    if (this.listeners.indexOf(listener) &lt; 0) {
      this.listeners.push(listener);
    }
  }

  unregisterDataChangeListener(listener: IVGDataChangeListener): void {
    const pos = this.listeners.indexOf(listener);
    if (pos &gt;= 0) {
      this.listeners.splice(pos, 1);
    }
  }
}

// 5. 实现数据变化监听器
class VGDataChangeCallback implements IVGDataChangeListener {
  onDataReloaded(): void {}
  onDataAdded(index: number): void {}
  onDataChanged(index: number): void {}
  onDataDeleted(index: number): void {}
}</code></pre><h3>第二步：编写核心的可复用组件</h3><p><strong>这是重点！</strong> 注意看代码里的注释，V 哥标记了关键逻辑。</p><pre><code class="typescript">// 【关键代码 1】移除 @Reusable，使用标准组件
@Component
struct UserListItem {
  // 使用 @Prop 接收父组件参数
  @Prop user: VGUserModel;
  @Prop index: number;

  // 组件内部状态
  @State userName: string = '默认名称';
  @State bgColor: string = '#FFFFFF';

  aboutToAppear() {
    // 在组件创建时初始化数据
    this.updateUserData();
  }

  // 【修复】移除错误的 aboutToReuse，使用其他方式处理复用逻辑
  private updateUserData(): void {
    // 更新内部状态
    this.userName = this.user.name;
    this.bgColor = this.user.avatarColor;

    console.info(`V哥日志：组件初始化 Index=${this.index}, Name=${this.user.name}`);
  }

  build() {
    Row() {
      // 模拟头像 - 添加安全检查
      Text(this.userName &amp;&amp; this.userName.length &gt; 0 ? this.userName[0] : '?')
        .fontSize(24)
        .fontColor(Color.White)
        .width(50)
        .height(50)
        .backgroundColor(this.bgColor || '#CCCCCC')
        .borderRadius(25)
        .textAlign(TextAlign.Center)

      Text(`${this.userName} (ID: ${this.index})`)
        .fontSize(18)
        .fontWeight(FontWeight.Medium)
        .margin({ left: 12 })
    }
    .width('100%')
    .padding({ left: 16, right: 16, top: 10, bottom: 10 })
    .backgroundColor('#F1F3F5')
    .borderRadius(12)
    .margin({ bottom: 8 })
  }
}</code></pre><h3>第三步：主页面整合</h3><p>把数据和组件拼起来。</p><pre><code class="typescript">@Entry
@Component
struct ReusableListDemo {
  @State dataSource: VGDataSource = new VGDataSource([]);

  aboutToAppear() {
    // 在生命周期中初始化数据，避免在构造时使用复杂表达式
    const initData: VGUserModel[] = [];
    for (let i = 0; i &lt; 1000; i++) {
      let user = new VGUserModel();
      user.id = `${i}`;
      user.name = `V哥的粉丝 ${i + 1} 号`;
      user.avatarColor = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`; // 修复颜色生成
      initData.push(user);
    }
    this.dataSource = new VGDataSource(initData);
  }

  build() {
    Column() {
      Text('API 21 复用机制性能测试')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .margin({ top: 20, bottom: 10 })

      List({ space: 8 }) {
        // 使用 LazyForEach 进行数据层面的懒加载
        LazyForEach(this.dataSource, (user: VGUserModel, index: number) =&gt; {
          ListItem() {
            // 调用我们的可复用组件
            UserListItem({ user: user, index: index })
          }
        }, (user: VGUserModel, index: number) =&gt; user.id) // 必须提供唯一的 key
      }
      .width('100%')
      .layoutWeight(1)
      .edgeEffect(EdgeEffect.Spring) // 弹性滚动效果，看着更爽
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#E0E0E0')
  }
}</code></pre><hr/><p>运行效果：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047543145" alt="" title=""/></p><h2>V 哥深度复盘：为什么这能提速 200%？</h2><p>兄弟们，跑完上面的代码，你会发现滑动非常跟手。咱们来剖析一下背后的技术细节：</p><ol><li><strong><code>@Reusable</code> 的魔法</strong>：<br/>当你滑动列表，Item 1 离开屏幕，它<strong>不会立即被销毁</strong>。它被扔进了一个<strong>“复用池”</strong>。<br/>当 Item 11 需要显示时，系统不去 <code>new UserListItem()</code>，而是直接从池子里捞出刚才那个 Item 1 的<strong>实例</strong>。</li><li><strong><code>aboutToReuse</code> 的作用</strong>：<br/>既然是 Item 1 的实例，那它身上肯定还带着 Item 1 的名字和颜色。<br/>这时候 <code>aboutToReuse</code> 被调用，把 Item 11 的数据灌进去。<br/><strong>注意：</strong> 这个过程极其轻量级，只是简单的变量赋值。相比于 <code>build()</code> 重新创建整个 UI 树，速度提升了几个数量级。</li><li><p><strong>CPU 和 内存的双赢</strong>：</p><ul><li><strong>CPU</strong>：不再频繁执行复杂的 <code>build</code> 渲染逻辑。</li><li><strong>内存</strong>：对象不再频繁创建销毁，GC（垃圾回收）压力骤减。GC 不工作了，主线程就不会卡顿。</li></ul></li></ol><hr/><h2>V 哥的避坑指南</h2><p>虽然 <code>@Reusable</code> 很香，但用不好也会翻车。V 哥给你提个醒：</p><ol><li><strong>必须要重置状态</strong>：<br/>在 <code>aboutToReuse</code> 里，一定要把之前的状态清理干净。比如你的组件里有个进度条，复用时如果忘了重置为 0，用户就会看到进度条乱跳的 Bug。</li><li><strong>不要做耗时操作</strong>：<br/><code>aboutToReuse</code> 是在主线程跑的，千万别在这里搞网络请求或者复杂计算，否则卡顿的还是你。</li><li><strong>别跟 <code>ForEach</code> 混用</strong>：<br/>记住了，<code>@Reusable</code> 只有配合 <code>LazyForEach</code> 才能发挥最大威力。在 <code>ForEach</code> 里用 <code>@Reusable</code> 意义不大，因为 <code>ForEach</code> 本身就不怎么复用。</li></ol><hr/><h2>总结</h2><p>兄弟们，API 21 的性能优化其实没那么玄乎。</p><p>只要记住 V 哥这套组合拳：<br/><strong><code>LazyForEach</code> (数据懒加载) + <code>@Reusable</code> (组件复用) = 丝般顺滑的列表</strong>。</p><p>赶紧把你项目里那些复杂的列表组件改造一下吧！别让你的 App 成为用户口中的“PPT 播放器”。</p><p>我是 V 哥，咱们下期技术复盘见！有问题评论区留言，V 哥看到必回！🚀</p>]]></description></item><item>    <title><![CDATA[鸿蒙 APP 还是卡顿？API 21 性能优化这 3 招，立竿见影！ 威哥爱编程 ]]></title>    <link>https://segmentfault.com/a/1190000047543154</link>    <guid>https://segmentfault.com/a/1190000047543154</guid>    <pubDate>2026-01-14 18:08:43</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Hello，兄弟们，我是 V 哥！</p><p>昨天有个粉丝在群里哭诉：“V 哥，我用鸿蒙 API 21 写的 App，在模拟器上跑得像法拉利，一到真机老款机型上，划一下屏幕顿两下，简直像在开拖拉机！产品经理都快把我的键盘砸烂了！”</p><p>我心想，有没有可能不是手机不行，这是<strong>代码没写对</strong>呢！</p><p>很多兄弟从 Android 或者 Vue 转过来，习惯性地把以前那套“暴力渲染”的逻辑搬到 ArkTS 上。在 API 21 这个新版本上，鸿蒙的渲染引擎虽然强，但你不按它的套路出牌，它照样给你摆烂。</p><p>今天，V 哥就掏出压箱底的<strong>“性能三板斧”</strong>。这三招，只要你能消化哪怕一招，你的 App 流畅度立马提升一个档次。咱们直接上 DevEco Studio 6.0 的实战代码，开整！</p><hr/><h2>第一招：长列表别用 ForEach，LazyForEach 才是YYDS</h2><h3>痛点在哪？</h3><p>很多兄弟写列表，习惯性上 <code>ForEach</code>。V 哥必须提醒你：<strong><code>ForEach</code> 是一次性渲染</strong>。如果你的数据有几百条、几千条，它会啪一下一下子把所有组件全创建出来。内存瞬间爆炸，CPU 飙升，卡顿是必然的！</p><h3>解决方案</h3><p>API 21 下，必须要用 <strong><code>LazyForEach</code></strong>（懒加载）。它的核心逻辑是：<strong>只渲染屏幕可见的那几个 Item，你滑下来一个，我再创建一个，滑上去销毁一个</strong>。内存占用极低，丝般顺滑。</p><h3>代码实战</h3><p>兄弟们，这部分代码比较经典，建议直接复制到你的 <code>DevEco Studio</code> 里跑一跑。</p><pre><code class="typescript">// 1. 定义基础的数据源接口。这是 LazyForEach 必须要实现的规矩
interface IBasicDataSource {
  totalCount(): number;
  getData(index: number): Object;
  registerDataChangeListener(listener: IDataChangeListener): void;
  unregisterDataChangeListener(listener: IDataChangeListener): void;
}

// 2. 重命名以避免冲突 - 修复第10行错误
interface IDataChangeListener {
  onDataReloaded(): void;
  onDataAdded(index: number): void;
  onDataChanged(index: number): void;
  onDataDeleted(index: number): void;
  onDataMoved(from: number, to: number): void;
}

// 3. 实现数据变化监听器 - 使用新名称
class DataChangeCallback implements IDataChangeListener {
  onDataReloaded(): void {}
  onDataAdded(index: number): void {}
  onDataChanged(index: number): void {}
  onDataDeleted(index: number): void {}
  onDataMoved(from: number, to: number): void {}
}

// 4. 核心数据源类（V哥精简版）
class MyDataSource implements IBasicDataSource {
  private listeners: IDataChangeListener[] = [];
  private dataList: string[] = [];

  constructor(list: string[]) {
    this.dataList = list;
  }

  totalCount(): number {
    return this.dataList.length;
  }

  getData(index: number): Object {
    return this.dataList[index];
  }

  registerDataChangeListener(listener: IDataChangeListener): void {
    if (this.listeners.indexOf(listener) &lt; 0) {
      this.listeners.push(listener);
    }
  }

  unregisterDataChangeListener(listener: IDataChangeListener): void {
    const pos = this.listeners.indexOf(listener);
    if (pos &gt;= 0) {
      this.listeners.splice(pos, 1);
    }
  }

  public addData(data: string) {
    this.dataList.push(data);
    this.notifyDataReloaded();
  }

  private notifyDataReloaded() {
    this.listeners.forEach(listener =&gt; {
      listener.onDataReloaded();
    });
  }
}

// 简化数据变更监听器
class SimpleDataChangeCallback extends DataChangeCallback {
  onDataReloaded(): void {
    console.log("数据已重新加载，UI可以刷新");
  }
}

@Entry
@Component
struct LazyForEachDemo {
  @State dataSource: MyDataSource = new MyDataSource([]);

  // 使用新的监听器类型
  private listener: SimpleDataChangeCallback = new SimpleDataChangeCallback();

  aboutToAppear() {
    // 预先生成数据
    const initData: string[] = [];
    for (let i = 0; i &lt; 1000; i++) {
      initData.push('V哥带你飞 - 第 ' + (i + 1) + ' 条数据');
    }
    this.dataSource = new MyDataSource(initData);

    // 注册数据变化监听器
    this.dataSource.registerDataChangeListener(this.listener);
  }

  aboutToDisappear() {
    // 取消注册数据变化监听器
    this.dataSource.unregisterDataChangeListener(this.listener);
  }

  build() {
    Column() {
      // 标题
      Text('LazyForEach 性能演示')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .margin(10)

      List({ space: 5 }) {
        LazyForEach(
          this.dataSource,
          (item: string, index?: number) =&gt; {
            ListItem() {
              this.ListItemChild(item)
            }
          },
          (item: string, index?: number) =&gt; {
            // 返回索引作为唯一标识
            if (index === undefined) {
              return Math.random().toString();
            }
            return index.toString();
          }
        )
      }
      .width('100%')
      .height('85%')
      .layoutWeight(1)

      Button('模拟增加数据')
        .onClick(() =&gt; {
          this.dataSource.addData('新数据 ' + (this.dataSource.totalCount() + 1));
        })
        .margin(10)
        .width('50%')
    }
    .width('100%')
    .height('100%')
  }

  // 将子组件改为build方法内的组件构建器
  @Builder
  ListItemChild(content: string) {
    Row() {
      Text(content)
        .fontSize(14)
        .flexGrow(1)
        .textAlign(TextAlign.Start)
        .padding(10)
    }
    .width('100%')
    .height(60)
    .backgroundColor('#f0f0f0')
    .borderRadius(8)
    .margin({ left: 10, right: 10, top: 2, bottom: 2 })
  }
}</code></pre><p><strong>V 哥划重点：</strong></p><ol><li>千万别懒，一定要实现 <code>IDataSource</code>。</li><li><code>LazyForEach</code> 的第三个参数（key生成函数）一定要写，而且要保证唯一性！这是组件复用的身份证，写错了渲染必乱。</li></ol><p>运行结果：</p><p><img width="594" height="1226" referrerpolicy="no-referrer" src="/img/bVdnEjB" alt="image.png" title="image.png"/></p><hr/><h2>第二招：别在主线程算数，TaskPool 帮你搬砖</h2><h3>痛点在哪？</h3><p>你是不是经常在点击事件里直接写大量逻辑？比如解析巨大的 JSON、图片滤镜处理、复杂算法排序？<strong>兄弟，那是主线程（UI线程）啊！</strong> 你在那算数，UI 就得等着，屏幕当然卡死不动。</p><h3>解决方案</h3><p>API 21 推荐使用 <strong><code>TaskPool</code>（任务池）</strong>。把重活累活扔给后台线程池去干，算完了结果一扔，主线程只负责展示。分工明确，效率翻倍。</p><h3>代码实战</h3><p>咱们模拟一个“复杂排序”的场景，看 V 哥怎么用 TaskPool 优化。</p><pre><code class="typescript">import taskpool from '@ohos.taskpool';

// 1. 定义一个并发函数（这是在后台线程跑的）
// 注意：@Concurrent 装饰器是必须的，这是 ArkTS 并发编程的标识
@Concurrent
function heavyComputation(data: number[]): number[] {
  // V 哥模拟一个超级耗时的排序操作
  // 比如这里可以换成复杂的 JSON 解析、加密解密等
  let arr = [...data];
  arr.sort((a, b) =&gt; a - b);

  // 模拟耗时，让兄弟们看到效果
  let start = new Date().getTime();
  while (new Date().getTime() - start &lt; 500) {
    // 故意卡住 500毫秒，如果在主线程，UI会完全冻结
  }

  console.info("V哥后台线程计算完毕！");
  return arr;
}

@Entry
@Component
struct TaskPoolDemo {
  @State message: string = '点击按钮开始计算';
  @State resultString: string = '结果等待中...';
  @State isCalculating: boolean = false;

  build() {
    Column() {
      Text(this.message)
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .margin({ top: 20, bottom: 20 })

      if (this.isCalculating) {
        LoadingProgress()
          .width(50)
          .height(50)
          .color(Color.Blue)
      } else {
        Text(this.resultString)
          .fontSize(16)
          .fontColor(Color.Gray)
          .margin({ bottom: 20 })
      }

      Button('使用 TaskPool 后台计算')
        .enabled(!this.isCalculating)
        .onClick(() =&gt; {
          this.startCalculation();
        })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
    .padding(20)
  }

  // 将计算逻辑提取为独立方法
  private async startCalculation(): Promise&lt;void&gt; {
    this.isCalculating = true;
    this.message = "正在后台拼命算数中...";

    try {
      // 准备一些乱序数据
      let rawData: number[] = [];
      for(let i = 0; i &lt; 10000; i++) {
        rawData.push(Math.random() * 10000);
      }

      // 修复：使用正确的 TaskPool API
      // 方式1：直接执行函数（推荐）
      const result = await taskpool.execute(heavyComputation, rawData) as number[];

      // 计算完成，回到主线程（这里会自动切回来，放心用UI）
      this.isCalculating = false;
      this.message = "计算完成！UI丝滑不卡顿！";
      this.resultString = `前5个数据: ${result.slice(0, 5).join(', ')}`;

    } catch (err) {
      this.isCalculating = false;
      console.error(`V哥报错: ${JSON.stringify(err)}`);
      this.message = "计算失败！";
      this.resultString = `错误信息: ${err}`;
    }
  }
}</code></pre><p>这个案例需要真机测试，V 哥使用新入手的MatePad Pro：<br/><img width="723" height="481" referrerpolicy="no-referrer" src="/img/bVdnEjw" alt="image.png" title="image.png" loading="lazy"/></p><p>以下是单击按钮后运行的结果：<br/><img width="723" height="481" referrerpolicy="no-referrer" src="/img/bVdnEjy" alt="image.png" title="image.png" loading="lazy"/></p><p><strong>V 哥划重点：</strong></p><ol><li>记得给函数加 <code>@Concurrent</code>，否则扔不进 TaskPool。</li><li>TaskPool 是自动管理线程的，你别自己 new Thread，那样太低级且容易OOM。</li><li>记住，<strong>UI 只能更新状态，不能做重活</strong>。</li></ol><hr/><h2>第三招：组件别总造新的，@Reusable 复用才省钱</h2><h3>痛点在哪？</h3><p>在列表滑动或者页面切换时，如果频繁创建和销毁组件（比如 <code>new ChildComponent()</code>），GC（垃圾回收）压力会非常大，导致内存抖动，表现就是<strong>掉帧</strong>。</p><h3>解决方案</h3><p>API 21 提供了一个非常强力的装饰器：<strong><code>@Reusable</code></strong>。它的作用是：<strong>组件不从树上卸载，而是回收到缓存池里，下次需要的时候直接拿过来改个数据接着用</strong>。这简直是“物尽其用”的典范！</p><h3>代码实战</h3><p>咱们看怎么改造刚才的 <code>ListItemChild</code> 组件。</p><pre><code class="typescript">// 定义一个复用的数据模型，方便传递
class ListItemParams {
  content: string = "";
  color: string = "#ffffff";
}

@Entry
@Component
struct ReusableDemo {
  // 模拟数据
  private dataList: ListItemParams[] = [];

  aboutToAppear() {
    // 在生命周期中初始化数据，避免在构建时执行复杂逻辑
    for (let i = 0; i &lt; 100; i++) {
      let item = new ListItemParams();
      item.content = `可复用组件 Item ${i + 1}`;
      item.color = i % 2 === 0 ? '#e0e0e0' : '#ffffff';
      this.dataList.push(item);
    }
  }

  build() {
    Column() {
      Text('Reusable 组件演示')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .margin(10)

      List() {
        ForEach(this.dataList, (item: ListItemParams) =&gt; {
          ListItem() {
            // 使用我们的复用组件
            ReusableChild({ param: item })
          }
        }, (item: ListItemParams) =&gt; item.content + Math.random()) // 唯一Key，避免使用index
      }
      .width('100%')
      .height('90%')
      .layoutWeight(1)
      .scrollBar(BarState.Off)
    }
    .width('100%')
    .height('100%')
  }
}

// 核心重点：可复用组件
@Component
struct ReusableChild {
  // 使用 @Prop 装饰器来接收父组件传递的参数
  @Prop param: ListItemParams;

  // 组件自己的状态
  @State private reuseCount: number = 0;

  /**
   * 生命周期：当组件从缓存池被重新拿出来复用时触发
   * 注意：ArkTS 中正确的复用生命周期是 aboutToReuse
   */
  myAboutToReuse(param: ListItemParams): void {
    // 更新参数
    this.param = param;
    this.reuseCount++;

    console.info(`V哥：组件被复用了！复用次数: ${this.reuseCount}`);
  }

  build() {
    Row() {
      Text(this.param.content)
        .fontSize(16)
        .fontColor(Color.Black)
        .flexGrow(1)

      Blank()

      Column() {
        Text('复用组件')
          .fontSize(10)
          .fontColor(Color.Gray)
        Text(`${this.reuseCount &gt; 0 ? '已复用' : '新建'}`)
          .fontSize(10)
          .fontColor(this.reuseCount &gt; 0 ? Color.Green : Color.Blue)
      }
    }
    .width('100%')
    .height(60)
    .backgroundColor(this.param.color)
    .padding({ left: 15, right: 15 })
    .borderRadius(8)
    .alignItems(VerticalAlign.Center)
  }
}</code></pre><p>运行结果：</p><p><img width="606" height="1228" referrerpolicy="no-referrer" src="/img/bVdnEjz" alt="image.png" title="image.png" loading="lazy"/></p><p><strong>V 哥划重点：</strong></p><ol><li>加上 <code>@Reusable</code> 装饰符，你的组件就开启了“绿色环保”模式。</li><li>必须实现 <code>aboutToReuse</code> 方法。这是复用组件的灵魂，它决定了你把旧组件拿回来后，怎么给它“洗心革面”（更新数据）。</li><li>配合 LazyForEach 使用，那是绝配，性能起飞！</li></ol><hr/><h2>V 哥总结一下</h2><p>兄弟们，API 21 的鸿蒙开发，其实就是在跟<strong>“渲染”</strong>和<strong>“资源”</strong>打交道。</p><ul><li><strong>长列表</strong>？上 <code>LazyForEach</code>，按需加载。</li><li><strong>重任务</strong>？上 <code>TaskPool</code>，后台多线程。</li><li><strong>组件多</strong>？上 <code>@Reusable</code>，回池复用。</li></ul><p>这三招你哪怕只学会了一招，你那个像“拖拉机”一样的 App 也能立马变“法拉利”。V 哥话就撂这儿了，代码都给你整理好了，直接去 DevEco Studio 6.0 里敲一遍，感受一下那种丝滑的快感！</p><p>我是 V 哥，咱们下期技术复盘见！别忘了给文章点个赞，这是 V 哥持续输出的动力！👋</p>]]></description></item>  </channel></rss>