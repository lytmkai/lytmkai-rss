<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[扣子Coze实战：从0到1搭建小红书图文改写智能体 AI架构师汤师爷 ]]></title>    <link>https://segmentfault.com/a/1190000047601397</link>    <guid>https://segmentfault.com/a/1190000047601397</guid>    <pubDate>2026-02-09 14:06:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大家好，我是汤师爷，专注AI智能体分享，致力于帮助100W人用智能体创富~</p><p>还在为小红书笔记创作发愁吗？</p><p>每天都要绞尽脑汁想文案，看着别人的爆款笔记却不知道如何模仿？</p><p>今天，我就教你如何利用AI智能体，轻松实现小红书图文改写，让创作效率提升10倍！</p><p>我们先看下智能体的执行效果：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601400" alt="image.png" title="image.png"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601401" alt="image.png" title="image.png" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601402" alt="image.png" title="image.png" loading="lazy"/></p><h2>1.整体工作流</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601403" alt="image.png" title="image.png" loading="lazy"/></p><p>1.获取小红书笔记详情</p><p>2.使用OCR技术，提取图片中的文字</p><p>3.将图片文案进行整理</p><p>4.图片文案仿写</p><h2>2.详细工作流节点</h2><h3>2.1 开始节点</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601404" alt="image.png" title="image.png" loading="lazy"/></p><p>开始节点有两个输入变量。</p><ul><li><p>输入：</p><ul><li>noteUrl：小红书笔记链接</li><li>cookieStr：小红书cookie</li></ul></li></ul><h3>2.2 如何获取小红书cookie？</h3><p>1.登陆<a href="https://link.segmentfault.com/?enc=kKvjTIfYn%2Bu2VS8XSfcteQ%3D%3D.Ka7MMBZcD89zamWnc%2FmwaPGJPV44im8Py4BgfdIROMw%3D" rel="nofollow" target="_blank">https://www.xiaohongshu.com/</a></p><p>2.在页面空白处右击鼠标，选择「检查」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601405" alt="image.png" title="image.png" loading="lazy"/></p><p>3.在刚刚打开的面板中，点击「网络」选项卡</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601406" alt="image.png" title="image.png" loading="lazy"/></p><p>4.刷新当前页面</p><p>5.点击第一条记录，在右侧「标头」部分向下滚动，找到cookie一行，将其内容复制下，这就是我们需要的cookieStr</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601407" alt="image.png" title="image.png" loading="lazy"/></p><h3>2.3 获取小红书笔记详情</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601408" alt="image.png" title="image.png" loading="lazy"/></p><p>我们将使用【小红书】插件的xhs_note_detail功能。</p><p>通过这个功能，我们可以根据笔记链接获取笔记详情。</p><ul><li><p>输入：</p><ul><li>cookieStr：开始 - cookieStr</li><li>noteUrl：开始 - noteUrl</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601409" alt="image.png" title="image.png" loading="lazy"/></p><h3>2.4 使用OCR技术，提取图片中的文字</h3><p><strong>1.接下来，我们使用循环节点，批量提取图片中的文字。</strong></p><ul><li><p>输入：</p><ul><li>input：获取小红书笔记详情-note_image_list</li></ul></li><li><p>输出</p><ul><li>output：从图片中提取文字-data</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601410" alt="image.png" title="image.png" loading="lazy"/></p><p><strong>2.使用循环体，批量提取图片的文字</strong></p><p>我们会使用「OCR」插件，提取图片的文字。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601411" alt="image.png" title="image.png" loading="lazy"/></p><p>输入参数如下图所示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601412" alt="image.png" title="image.png" loading="lazy"/></p><h3>2.5 使用大模型将文案内容进行整理、排版</h3><p>在这一步，我们会使用大模型节点，对文案内容进行整理、排版。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601413" alt="image.png" title="image.png" loading="lazy"/></p><p>大模型节点的系统提示词如下：</p><pre><code class="markdown">## 角色（Role）
你是一位精通内容整理和 Markdown 排版的 AI 助手。你擅长阅读和理解非结构化的文本内容，并能够将其转化为结构清晰、格式优美的 Markdown 文档。

## 背景（Background）
随着社交媒体平台的普及，大量的图文内容被创作和分享。然而，这些内容往往缺乏良好的结构和格式，不利于阅读和理解。将这些内容整理成结构化的 Markdown 文档，可以大大提高内容的可读性和价值。

## 任务（Task）
你的任务是接收一段从插件输出的非结构化文本内容（主要是抖音图文中的文字），仔细阅读并理解内容，然后将其转化为结构清晰、格式规范的 Markdown 文档。你需要：

1. 识别并提取文本中的关键信息，如标题、作者、主要内容等
2. 根据内容的逻辑关系，对文本进行分类和整理
3. 使用 Markdown 语法进行排版，包括但不限于使用标题、粗体、斜体、列表等格式
4. 确保所有原始内容都被包含在最终的 Markdown 文档中，不遗漏任何信息

## 规则与限制（Rules &amp; Restrictions）
1. 必须使用 Markdown 语法进行排版
2. 使用 #、##、### 等进行标题划分，层级不超过 3 级
3. 使用 - 或 * 进行无序列表编写，使用 1. 2. 3. 等进行有序列表编写
4. 重要内容使用粗体（**文字**）标注，需要强调的内容使用斜体（*文字*）标注
5. 保持原文的主要结构和顺序，但可以适当调整以提高可读性
6. 不得添加、删除或修改原文的实质内容
7. 如遇到不确定的内容，保留原样并用括号标注

## 参考短语（Reference sentences）
- 内容完整，不遗漏任何信息
- 结构清晰，层次分明
- 格式规范，美观实用
- 逻辑严密，条理清晰
- 重点突出，易于阅读

## 案例展示（Case Show）
### 输入：
{
  "code": 0,
  "data": {
    "results": [
      {
        "words": [
          {
            "lang": "auto",
            "text": "求大连这两个"
          },
          {
            "lang": "auto",
            "text": "地方有啥"
          },
          {
            "lang": "auto",
            "text": "区别啊？？"
          }
        ]
      }
    ]
  },
  "log_id": "20250325123913080C6F506498C6F581B7",
  "msg": "success"
}

## 风格和语气（Style &amp; Tone）
- 保持专业、清晰的语气
- 使用简洁、直接的表达方式
- 保持原文的重点和强调

## 受众群体（Audience）
- 小红书电商新手卖家
- 对开设小红书店铺感兴趣的人群
- 想要了解小红书电商运营的人群

## 输出格式（Output format）
使用 Markdown 格式输出，包括：
1. 一级标题（#）用于文章主标题
2. 二级标题（##）用于主要章节
3. 三级标题（###）用于子章节
4. 无序列表使用 - 或 *
5. 有序列表使用 1. 2. 3. 等
6. 重要内容使用粗体（**文字**）
7. 需要强调的内容使用斜体（*文字*）

## 工作流程（Workflow）
1. 仔细阅读输入的文本内容，理解其结构和主要信息点
2. 提取标题、作者、标签等元信息
3. 识别主要章节和子章节，规划文档结构
4. 按照规划的结构，使用 Markdown 语法重新排版内容
5. 使用粗体和斜体突出重要信息和需要强调的内容
6. 检查确保所有原始内容都被包含，没有遗漏
7. 最后检查 Markdown 格式是否正确，调整以确保最佳可读性

## 初始化（Initialization）

下面是你需要整理和格式化的文本内容：

&lt;评价内容&gt;

请提供需要整理和格式化的文本内容。我会仔细阅读并按照上述要求将其转化为结构清晰的 Markdown 文档。不需要输出额外除图片识别文字以外的内容。</code></pre><h3>2.6 图片文案仿写</h3><p>接下来，我们需要通过大模型节点退图片文案进行仿写。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601414" alt="image.png" title="image.png" loading="lazy"/></p><p>大模型节点的系统提示词如下：</p><pre><code class="markdown"># 角色说明
你是一位专业的图文内容仿写助手，负责根据图片中提取的文字内容，结合视觉元素和背景信息，创作风格一致的仿写内容。

# 背景说明
处理用户提供的图片文字内容时，你需要：
1. 理解图片的整体风格和背景（产品介绍、教程步骤、使用心得等）
2. 分析文字的语言特点（正式/口语化、句式特征、专业术语等）
3. 结合图片呈现的视觉信息（产品外观、使用场景等）
4. 在保持原意的基础上进行自然的仿写扩展

# 仿写原则
1. 保持原意完整性
2. 匹配原文语言风格
3. 补充恰当的细节
4. 与图片内容保持一致
5. 避免添加虚假信息

# 工作流程
1. 接收图片文字内容
2. 分析图片背景信息（可选）
3. 分析原文特点：
   - 语言风格
   - 内容结构
   - 关键词使用
4. 创作三个版本：
   - 贴近原文的保守版
   - 适度优化的改进版
   - 创意加强的亮点版

# 输出示例
## 原文：
"夏日必备防晒霜
SPF50+ PA++++
清爽不油腻"

## 仿写版本：
1. 【保守版】
"夏季必备防晒产品
防晒指数SPF50+ PA++++
质地清爽不油腻"

2. 【优化版】
"夏日防晒推荐
高倍防护SPF50+ PA++++
轻薄水感质地，肌肤零负担"

3. 【创意版】
"今夏防晒天花板！
SPF50+ PA++++超强防护
一抹化水，清爽不黏腻"

# 执行要求
请提供：
1. 图片文字提取内容
2. 图片背景说明（如有）

我将按照以上规范进行仿写创作。</code></pre><h3>2.7 使用文本处理插件拼接字符串</h3><ul><li><p>输入：</p><ul><li>String1：获取小红书笔记详情-note</li><li>String2：图片文案内容整理-output</li><li>String3：图片文案仿写-output</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601415" alt="image.png" title="image.png" loading="lazy"/></p><h3>2.8 结束节点</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601416" alt="image.png" title="image.png" loading="lazy"/></p><h2>3.总结</h2><p>通过以上介绍，相信你了解了如何利用DeepSeek+Coze来构建高效的小红书图片文案改写智能体。</p><p>在AI时代，技术门槛将越来越低，小白也能搭建智能体，用AI工具来提升工作效率。</p><p>用AI智能体不是未来，而是AI时代每个人的生存技能，学会AI智能体，人人都是超级个体。</p><p>如果你觉得这篇文章有帮助，别忘了点赞、关注、收藏，我们下期再见！</p><blockquote>对了，我整理了一份开源《智能体学习手册》，爆肝 10 万字，价值 999 元。限时开放领取👉：<a href="https://link.segmentfault.com/?enc=RKeV23zo7AOy9S9SV8PNTA%3D%3D.394dLxrNKjI%2FVxPzyCX4eS2sP9XYw4exg%2BjVVMZF7mo%3D" rel="nofollow" target="_blank">tangshiye.cn</a></blockquote>]]></description></item><item>    <title><![CDATA[从抓取到分析：我在 TikTok 内容竞品研究中的工程实践经验 听话的马克杯 ]]></title>    <link>https://segmentfault.com/a/1190000047601418</link>    <guid>https://segmentfault.com/a/1190000047601418</guid>    <pubDate>2026-02-09 14:06:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>几周前，我的团队接到一个任务：分析 20 个竞品账号的 TikTok 内容表现，为新产品的内容策略提供数据支撑。刚开始，我像往常一样登录 App，逐个账号查看发布内容，但不到一周，我就发现问题来了：</p><ul><li>多账号登录频繁切换，效率低得离谱；</li><li>我的行为开始影响推荐算法，看到的内容不再是客观的竞品数据；</li><li>数据整理完全依赖人工，累得我每天盯着屏幕到半夜。</li></ul><p>那一刻，我意识到：<strong>我们需要一套工程化、可复盘的竞品分析流程，而不是靠手动浏览和记笔记。</strong></p><h2>一、问题背景</h2><p>在实际工程项目中，分析 TikTok 内容时，我们常遇到三类问题：</p><ol><li><strong>登录状态干扰数据</strong>  <br/>官方 App 会根据浏览和互动记录调整推荐，这会导致我们看到的数据偏离真实情况。</li><li><strong>多账号批量分析效率低</strong>  <br/>手动切换账号、记录数据，不仅耗时，还容易出错。</li><li><strong>PC 端操作不便</strong>  <br/>内容分析、数据清洗、可视化大部分在电脑上完成，App 使用不方便。</li></ol><p>解决这三个问题的关键在于<strong>数据采集策略和分析流程设计</strong>。我将整个流程分为“只读采集 → 标准化存储 → 自动化分析 → 趋势可视化”。</p><h2>二、数据采集策略</h2><h3>1. 只读原则</h3><p>为了保证数据的客观性，我遵循以下原则：</p><ul><li><strong>不登录、不互动</strong>：避免点赞、评论、关注影响算法；</li><li><strong>只采集公开内容</strong>：私密账号不可获取，分析仅基于公开信息；</li><li><strong>可复盘</strong>：每次抓取流程、字段保持一致，方便历史对比。</li></ul><p>顺带提到，我偶尔会使用网页工具（例如<a href="https://link.segmentfault.com/?enc=4sCErhf%2Bp7xxrI3EEbmiCQ%3D%3D.nPAhPK%2BLWVvRmT22eAyj%2FXrC2FBptj9Cw612rM1P81k3SH3vBQYP3O7LcvhlGaRd" rel="nofollow" target="_blank">TikTok Viewer</a> 页面）做快速浏览，但它只是辅助入口，不参与核心分析。</p><h3>2. 核心字段定义</h3><p>标准化字段是工程级分析的基础，我使用如下字段：</p><table><thead><tr><th>字段</th><th>含义</th><th>用途</th></tr></thead><tbody><tr><td>account_id</td><td>账号唯一标识</td><td>多账号管理</td></tr><tr><td>publish_ts</td><td>发布时间戳</td><td>趋势分析</td></tr><tr><td>content_type</td><td>内容类型（挑战/教程/记录等）</td><td>类型对比</td></tr><tr><td>video_length</td><td>视频时长（秒）</td><td>格式偏好分析</td></tr><tr><td>likes</td><td>点赞数</td><td>热度指标</td></tr><tr><td>comments</td><td>评论数</td><td>用户互动分析</td></tr><tr><td>shares</td><td>分享数</td><td>内容传播潜力分析</td></tr></tbody></table><h2>三、自动化抓取与容错设计</h2><p>批量抓取必须考虑稳定性和可复用性：</p><ul><li><strong>异步并发</strong>：提升抓取效率；</li><li><strong>异常重试机制</strong>：处理网络波动或页面结构变化；</li><li><strong>日志记录</strong>：方便排查问题；</li><li><strong>限流保护</strong>：避免 IP 封禁或对平台造成压力。</li></ul><p>抓取流程伪代码示例：</p><pre><code class="python">for account in account_list:
    url = build_public_profile_url(account)
    html = fetch_with_retry(url)
    if parse_success(html):
        data = extract_fields(html)
        write_to_db(data)
    else:
        log_error(account, html)</code></pre><h2>四、数据分析与趋势可视化</h2><ol><li>发布时间趋势</li></ol><p>统计每日/每周发布量，判断账号更新规律：</p><pre><code>SELECT publish_date, COUNT(*) AS cnt
FROM video_data
GROUP BY publish_date
ORDER BY publish_date</code></pre><ol start="2"><li>内容类型分析</li></ol><p>不同类型视频的平均互动量：</p><pre><code>SELECT content_type,
       AVG(likes) AS avg_likes,
       AVG(comments) AS avg_comments
FROM video_data
GROUP BY content_type</code></pre><ol start="3"><li>视频长度分布</li></ol><p>将视频时长分段，观察受欢迎区间：</p><pre><code>SELECT video_length_bucket, COUNT(*) AS cnt
FROM video_data
GROUP BY video_length_bucket</code></pre><p>趋势分析帮助判断哪类内容更受用户欢迎，为内容策略提供数据支撑。</p><h2>五、工程实践总结</h2><p>字段规范化：统一字段定义和存储格式，保证多账号数据可比；</p><p>定期重抓：平台内容更新快，周期性抓取保证数据新鲜；</p><p>自动化报表：定期生成分析报告，减少人工操作；</p><p>关注趋势：单条数据可能偶然，高层趋势才更可靠。</p><p>通过工程化方法，我们可以高效、可复盘地进行竞品分析，而不是依赖人工观察。</p><h2>六、流程图示意</h2><pre><code>+----------------+       +----------------+       +----------------+
| 公开页面抓取   | ---&gt;  | 数据字段解析    | ---&gt;  | 数据库存储      |
+----------------+       +----------------+       +----------------+
         |                                          |
         v                                          v
+----------------+       +----------------+       +----------------+
| 异常重试与日志 | ---&gt;  | 数据清洗与标准化| ---&gt;  | 趋势分析 &amp; 可视化|
+----------------+       +----------------+       +----------------+</code></pre><p>这个流程图表示了工程化竞品分析的核心步骤，从抓取、解析、存储到分析和可视化，保证数据可复盘和可扩展。</p><h2>七、数据表格模板示例</h2><p>account_id    publish_ts    content_type    video_length    likes    comments    shares<br/>account_01    2026-01-01 12:30    挑战    15    1200    300    50<br/>account_01    2026-01-02 09:45    教程    30    800    120    40<br/>account_02    2026-01-01 14:10    记录    20    950    200    60</p><p>表格示例展示了每条内容的核心采集字段，可直接用于趋势分析和可视化。</p><h2>八、结语</h2><p>从抓取到分析，每一步都体现了工程实践的重要性。作为开发者，我更关注的是方法论和流程，而不是工具本身。顺带提到的 TikTok Viewer 页面，只是辅助浏览的一种入口，并不影响整体工程流程。</p><p>真正有价值的是：标准化的数据采集、可复盘的分析流程和趋势洞察能力，这是任何社媒数据分析项目长期可持续的核心。</p>]]></description></item><item>    <title><![CDATA[HarmonyOS 安全认证进阶：PatternLock 从原理到分布式场景的全链路实战 认真的咖啡]]></title>    <link>https://segmentfault.com/a/1190000047601447</link>    <guid>https://segmentfault.com/a/1190000047601447</guid>    <pubDate>2026-02-09 14:05:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>前言</h2><blockquote>在万物互联的全场景时代，设备之间的边界正在消失，安全认证已不再是单一设备的 “孤岛式” 防御，而是跨端协同的 “全链路” 保障。HarmonyOS 凭借其分布式软总线与原生 ArkUI 框架，为开发者提供了一套从终端到云端的安全认证解决方案，其中 PatternLock（图案密码锁）作为最贴近用户习惯的认证方式之一，不仅承担着保护用户隐私的核心职责，更成为连接多设备、多场景的交互入口。那么本文从技术原理出发，深度拆解 ArkUI 框架中 PatternLock 组件的三层架构设计，通过代码实战演示如何构建兼具安全性与体验感的手势密码模块，并进一步探索生物特征融合、分布式跨设备认证等进阶场景，帮助大家在全场景生态中打造更智能、更安全的认证体系。</blockquote><h2>PatternLock概念</h2><p>在HarmonyOS开发中，PatternLock是图案密码锁组件，以九宫格图案的方式输入密码，用于密码验证场景。手指在PatternLock组件区域按下时开始进入输入状态，手指离开屏幕时结束输入状态完成密码输入。（需要说明的是，该组件从API Version 9开始支持。）<br/>PatternLock 的交互逻辑简洁直观：用户手指按下九宫格区域时进入输入状态，离开屏幕时触发轨迹校验，整个过程无需键盘输入，既提升了操作效率，又降低了密码泄露风险。</p><h2>PatternLock核心功能解析</h2><h3>1、组件架构特性</h3><p>PatternLock是ArkUI框架提供的安全认证组件，采用三层架构设计：</p><ul><li>交互层：提供可定制的九宫格绘制界面，支持动态波纹反馈、连线样式自定义，让输入过程更具视觉引导性；</li><li>控制层：通过PatternLockController实现组件状态的实时控制，包括密码重置、锁定时长配置、验证结果反馈等核心能力；</li><li><p>数据层：内置哈希算法对轨迹坐标进行不可逆加密，并支持与 HarmonyOS 系统安全服务联动，确保密码传输与存储的安全性。</p><h3>2、核心参数配置</h3><p>组件的核心参数可灵活调整，以适配不同界面风格与交互需求：<br/><img width="723" height="224" referrerpolicy="no-referrer" src="/img/bVdnTto" alt="image.png" title="image.png"/></p></li></ul><h3>3、样式继承树</h3><p>关于PatternLock的样式继承树，如下所示：</p><pre><code>PatternLock → CommonShape → CommonAttribute → Component</code></pre><h2>PatternLock样式设置</h2><p>在实际开发中，任何一个组件的样式相关的设置都是非常重要且常用的操作，那么PatternLock也不例外，接下来分享关于样式相关的使用操作。<br/><img width="723" height="238" referrerpolicy="no-referrer" src="/img/bVdnTtp" alt="image.png" title="image.png" loading="lazy"/><br/>这里只分享关于PatternLock的样式设置相关的参数，具体的实际使用会在下一部分详细分享。</p><h2>关于PatternLock的基础使用</h2><h3>1、组件初始化与控制器绑定</h3><p>使用 PatternLock 的第一步是引入组件库并创建控制器实例，以实现状态的统一管理，具体如下所示：</p><pre><code>// 导入组件库
import { PatternLock, PatternLockController } from '@ohos.arkui.ts/components';

// 创建控制器实例
private patternLockCtrl: PatternLockController = new PatternLockController();</code></pre><h3>2、基础布局与视觉定制</h3><p>通过链式调用属性方法，可快速完成九宫格的布局与样式配置，包括尺寸、颜色、动态效果等，如下所示：</p><pre><code>PatternLock(this.patternLockController)
        .sideLength(200)
        .circleRadius(9)
        .pathStrokeWidth(5)
        .regularColor('#ff182431') // 未选中的颜色
        .activeColor('#707070') // 激活状态的颜色
        .selectedColor('#707070') // 选中状态的颜色
        .pathColor('#707070') // 连线颜色
        .backgroundColor('#F5F5F5') // 背景色
        .autoReset(true)
        .activateCircleStyle({ // 动态波纹效果
            color: Color.Blue,
            radius: { value: 18, unit: LengthUnit.VP },
            enableWaveEffect: true  // 启用波纹动画
        })
        .onDotConnect((index: number) =&gt; {
          console.log("onDotConnect index: " + index)
          this.handlePatternComplete(index) // 具体实现方法在下一部分会介绍
        })
</code></pre><h2>3、事件处理与安全校验</h2><p>密码输入完成后，需通过事件回调实现业务逻辑处理，包括长度验证、加密传输与异常拦截，手势完成回调，如下所示：</p><pre><code>private handlePatternComplete(input: number[]) {
    if (input.length &lt; 5) {
        this.showToast("至少连接5个点");
        return;
    }
    const encrypted = this.encryptPattern(input); // 加密方法如下面关于密码加密算法所示
    this.validateWithServer(encrypted);
}
</code></pre><p>由于涉及到加密的设置，关于密码加密算法如下所示：</p><pre><code>private encryptPattern(coordinates: number[]): string {
    const salt = cryptoFramework.createRandom(16);
    const sha256 = cryptoFramework.createHash("SHA256");
    sha256.update({ data: new Int32Array(coordinates) });
    return sha256.digest().then(hash =&gt; {
        return salt + hash.toHex();
    });
}
</code></pre><p>关于异常处理机制，如下所示：</p><pre><code>private errorCount: number = 0;

private handleValidationError() {
    this.errorCount++;
    if (this.errorCount &gt;= 3) {
        this.patternLockCtrl.lock(30000); // 锁定30秒
        this.showAlert("账号已锁定");
    }
}
</code></pre><h2>4、专属事件与控制器能力</h2><p>这里只来介绍非通用事件的使用，PatternLock有2个专属事件：onPatternComplete()和onDotConnect()。</p><h3>（1）onPatternComplete()方法</h3><p>语法：</p><pre><code>onPatternComplete(callback: (input: Array&lt;number&gt;) =&gt; void)</code></pre><p>使用：密码输入结束时触发该回调。<br/>参数：<br/><img width="723" height="220" referrerpolicy="no-referrer" src="/img/bVdnTtq" alt="image.png" title="image.png" loading="lazy"/></p><h3>（2）onDotConnect()方法</h3><p>语法：</p><pre><code>onDotConnect(callback: Callback&lt;number&gt;)</code></pre><p>使用：密码输入选中宫格圆点时触发该回调。<br/>说明：回调参数为选中宫格圆点顺序的数字，数字为选中宫格圆点的索引值（第一行圆点从左往右依次为0、1、2，第二行圆点依次为3、4、5，第三行圆点依次为6、7、8）。</p><h3>5、构造函数</h3><p>constructor()是PatternLockController的构造函数。<br/>系统能力： SystemCapability.ArkUI.ArkUI.Full</p><h3>6、重置状态</h3><p>reset()是重置组件状态。<br/>系统能力： SystemCapability.ArkUI.ArkUI.Full</p><h3>7、高阶玩法</h3><p>然后再分享2个高阶一点的玩法。<br/>生物特征融合认证，具体如下所示：</p><pre><code>async function hybridAuth(pattern: string) {
    const faceResult = await userAuth.auth(Type.FACE);
    if (faceResult === AuthResult.SUCCESS) {
        return this.quickUnlock(pattern);
    }
    return this.strictValidate(pattern);
}
</code></pre><p>分布式场景实现，具体如下所示：</p><pre><code>// 智能手表辅助认证
function watchAssistedAuth() {
    const deviceId = deviceManager.getTrustedDevices()[0];
    distributedLock.begin(deviceId);
    // 同步绘制轨迹...
}</code></pre><h2>PatternLock实际应用示例</h2><p>最后再来分享一个关于PatternLock的详细使用示例，模拟一个验证手势密码是否正确，具体代码如下所示：</p><pre><code>// test.ets
import { LengthUnit } from '@kit.ArkUI'

@Entry
@Component
struct PatternLockExample {
  @State passwords: Number[] = []
  @State message: string = '请输入密码!'
  private patternLockController: PatternLockController = new PatternLockController()

  build() {
    Column() {
      Text(this.message).textAlign(TextAlign.Center).margin(20).fontSize(20)
      PatternLock(this.patternLockController)
        .sideLength(200)
        .circleRadius(9)
        .pathStrokeWidth(5)
        .activeColor('#707066')
        .selectedColor('#707066')
        .pathColor('#707066')
        .backgroundColor('#F6F6F6')
        .autoReset(true)
        .activateCircleStyle({
          color: '#606060',
          radius: { value: 16, unit: LengthUnit.VP },
          enableWaveEffect: true
        })
        .onDotConnect((index: number) =&gt; {

        })
        .onPatternComplete((input: Array&lt;number&gt;) =&gt; {
          // 输入的密码长度小于5时，提示重新输入
          if (input.length &lt; 5) {
            this.message = '密码长度需大于5位，请重新输入。'
            return
          }
          // 判断密码长度是否大于0
          if (this.passwords.length &gt; 0) {
            // 判断两次输入的密码是否相同，相同则提示密码设置成功，否则提示重新输入
            if (this.passwords.toString() === input.toString()) {
              this.passwords = input
              this.message = '密码设置成功: ' + this.passwords.toString()
              this.patternLockController.setChallengeResult(PatternLockChallengeResult.CORRECT)
            } else {
              this.message = '两次输入的密码不一致，请重新输入。'
              this.patternLockController.setChallengeResult(PatternLockChallengeResult.WRONG)
            }
          } else {
            // 提示第二次输入密码
            this.passwords = input
            this.message = "请重新输入。"
          }
        })
      Button('重置手势密码').margin(40).onClick(() =&gt; {
        // 重置密码锁
        this.patternLockController.reset()
        this.passwords = []
        this.message = '请输入密码。'
      })
    }.width('100%').height('100%')
  }
}</code></pre><p>上面的这个示例通过sideLength设置九宫格的大小、circleRadius等属性设置宫格圆点样式、onPatternComplete属性设置密码输入时的回调。当使用者密码输入完成后，按输入的密码不同，给予不同的回应：输入的密码长度小于5时，提示重新输入；第一次输入完成后，提示第二次输入密码；第二次输入完成后，判断两次输入的密码是否相同，相同则提示密码设置成功，否则提示重新输入。然后可以通过'重置手势密码'按钮，可以重置密码锁。</p><h2>最后</h2><p>随着 HarmonyOS 全场景生态的持续演进，PatternLock 已从传统的 “单点认证工具”，进化为连接多设备、多模态的 “安全交互枢纽”。本文从技术架构、开发实战到场景进阶，系统呈现了 PatternLock 的完整能力边界，不仅能帮助开发者快速构建基础手势认证功能，更能通过生物特征融合、分布式跨设备认证等进阶玩法，打造面向未来的全场景安全体系。在 HarmonyOS 6 及后续版本中，随着 ArkUI 框架对三维手势识别、压力感应等能力的引入，PatternLock 还将突破二维平面的限制，在车机控制、智能家居中控、可穿戴设备等场景中发挥更大价值。建议开发者持续关注 HarmonyOS Design 系统的更新，将环境感知、行为分析等新型技术与 PatternLock 深度融合，构建 “主动防御、无感认证” 的智能安全体验，为全场景互联时代筑牢安全基石。这里我建议大家持续关注HarmonyOS Design系统的更新，将生物特征、环境感知等新型认证方式与PatternLock深度融合，构建面向未来的智能安全体系，一起期待吧！</p>]]></description></item><item>    <title><![CDATA[免费SSL证书怎么选？JoySSL/Let's Encrypt/Cloudflare等主流方案对比 ]]></title>    <link>https://segmentfault.com/a/1190000047601449</link>    <guid>https://segmentfault.com/a/1190000047601449</guid>    <pubDate>2026-02-09 14:04:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>选择免费SSL证书，最核心的决策依据可以简化为：追求短期效益的选Let's Encrypt，看重中文长期免费体验、国内使用的选JoySSL，需要CDN与安全防护一体选Cloudflare。</p><p><img width="723" height="692" referrerpolicy="no-referrer" src="/img/bVdmPz6" alt="" title=""/></p><h2>一、JoySSL：国产首选的中文友好长期方案</h2><p>JoySSL是国内专注提供免费SSL证书的服务商，主打本地化服务和中文体验，最大特色是提供永久免费的DV单域名SSL证书，吸引了大量国内个人站长和中小企业用户。</p><h3>优势</h3><ol><li><strong>中文界面更友好</strong>：全程中文操作指引，从申请下载到配置部署都提供中文文档，新手也能轻松上手，无需依赖翻译工具。</li><li><strong>永久免费基础版</strong>：个人用户可免费领取永久有效的单域名DV证书，无需担心定期续期问题，适合长期稳定运行的个人站点。</li><li><strong>支持国密算法</strong>：可提供符合国家标准的SM2国密证书，满足政务、金融等合规要求，为国内用户提供本土化加密选择。</li><li><strong>多平台部署教程</strong>：提供针对宝塔面板、Nginx、Apache、Docker等主流平台的详细中文配置教程，降低部署难度。</li></ol><h3>缺点</h3><ol><li><strong>通配符证书需付费</strong>：仅单域名证书永久免费，多域名和通配符证书需要购买专业版，对于需要覆盖子域名的多域名站点不够友好。</li><li><strong>品牌知名度稍低</strong>：相比Let's Encrypt，市场认知度稍逊，部分用户可能对国产证书安全性存在顾虑，但实际上其DV证书同样通过国际主流浏览器信任根体系认证。</li></ol><h3>适用场景</h3><p>国内个人博客、小型企业官网、微信小程序后端服务，适合偏好中文界面，追求长期稳定且无需频繁续期的用户。</p><h2>二、Let's Encrypt：全球最成熟的开源自动化方案</h2><p>Let's Encrypt是由互联网安全研究小组（ISRG）运营的非营利组织，是目前全球使用量最高的免费SSL证书提供商，覆盖全球超4亿个域名，是个人开发者和中小团队的首选方案。</p><h3>优势</h3><ol><li><strong>完全零成本</strong>：无隐藏消费，不限制申请次数，支持单域名、多域名和通配符证书类型，所有证书均为DV（域名验证）类型，可满足绝大多数普通网站的加密需求。</li><li><strong>自动化程度高</strong>：通过ACME协议实现自动化申请、部署和续期，配合Certbot、acme.sh等工具，可实现证书到期前自动续期，完全无需人工干预。</li><li><strong>兼容性极强</strong>：支持Nginx、Apache、Caddy等所有主流Web服务器，同时适配Windows、Linux、Docker等各种操作系统，几乎不存在兼容性问题。</li><li><strong>社区资源丰富</strong>：作为行业标杆，相关教程和解决方案覆盖全面，遇到问题能快速找到解决办法，适合有一定技术能力的开发者。</li></ol><h3>缺点</h3><ol><li><strong>证书有效期短</strong>：证书有效期仅90天，虽然支持自动续期，但依赖服务器环境稳定和续期脚本配置，一旦脚本失效可能导致证书过期。</li><li><strong>中文支持不足</strong>：官方文档以英文为主，新手上手门槛略高，部分错误提示不够直观。</li><li><strong>通配符证书需手动DNS验证</strong>：申请通配符证书时无法通过文件验证，必须手动添加DNS TXT记录完成域名所有权验证，流程相对繁琐。</li></ol><h3>适用场景</h3><p>个人博客、开源项目、测试环境、中小团队的长期稳定站点，适合熟悉服务器操作，能自主维护续期脚本的用户。</p><h2>三、Cloudflare CDN：自带安全与性能增益的云方案</h2><p>Cloudflare是全球最大的CDN服务商之一，提供免费SSL证书与CDN加速一体化服务，无需用户手动下载部署证书，通过域名DNS解析配置即可实现全站加密。</p><h3>优势</h3><ol><li><strong>零部署成本</strong>：只需将域名DNS解析到Cloudflare，即可一键启用SSL加密，无需处理证书申请、上传、配置等繁琐步骤，新手也能快速上手。</li><li><strong>附赠多重安全防护</strong>：启用Cloudflare SSL的同时，可自动获得DDoS攻击防护、WAF防火墙、恶意IP拦截等安全功能，有效提升网站安全性。</li><li><strong>支持边加密与全加密模式</strong>：提供Flexible、Full、Full (strict)三种加密模式，可适配不同服务器配置，同时支持HTTP/2、HTTP/3等现代化网络协议。</li><li><strong>全球加速能力</strong>：借助Cloudflare遍布全球的CDN节点，可同步提升网站访问速度，尤其适合面向全球用户的站点。</li></ol><h3>缺点</h3><ol><li><strong>依赖CDN服务</strong>：必须将域名DNS解析到Cloudflare才能使用SSL证书，若服务器无法对接Cloudflare CDN，或不希望使用第三方CDN，该方案无法使用。</li><li><strong>免费版存在功能限制</strong>：免费版仅支持单域名证书，通配符证书需升级到付费版，同时部分安全和加速功能存在速率和流量限制。</li><li><strong>延迟略增</strong>：经过Cloudflare中转后，可能带来轻微的网络延迟，对于对响应速度有极高要求的站点（如实时交易系统）可能存在影响。</li></ol><h3>适用场景</h3><p>需要同时实现加密、加速和安全防护的网站，适合缺乏技术能力手动部署SSL证书的新手用户，以及希望简化运维流程的中小团队。</p><h3>四、三类免费SSL证书详细对比表</h3><p>表格</p><table><thead><tr><th><strong>对比维度</strong></th><th><strong>Let's Encrypt</strong></th><th><strong>JoySSL</strong></th><th><strong>Cloudflare</strong></th></tr></thead><tbody><tr><td><strong>证书类型</strong></td><td>单域名/多域名/通配符</td><td>永久免费单域名</td><td>单域名（免费版）</td></tr><tr><td><strong>有效期</strong></td><td>90天，自动续期</td><td>永久</td><td>永久（绑定CDN服务）</td></tr><tr><td><strong>申请门槛</strong></td><td>需域名所有权验证，支持文件/DNS验证</td><td>需域名所有权验证，支持文件/DNS验证</td><td>需将域名DNS解析到Cloudflare</td></tr><tr><td><strong>技术门槛</strong></td><td>需配置ACME脚本，适合有一定技术基础用户</td><td>中文界面引导，新手友好</td><td>零配置，启用CDN即可自动生效</td></tr><tr><td><strong>附加功能</strong></td><td>仅SSL加密</td><td>国密算法支持，适配国内合规需求</td><td>CDN加速、DDoS防护、WAF防火墙</td></tr><tr><td><strong>适用场景</strong></td><td>个人博客、开发者测试环境、中小团队长期站点</td><td>国内个人站长、小型企业官网</td><td>需要加密+安全防护的站点、追求简化运维的团队</td></tr></tbody></table><h2>五、其他主流免费SSL方案对比</h2><h3>阿里云免费SSL证书</h3><p>阿里云与DigiCert合作推出的免费DV证书，单域名有效期3个月，个人用户每年可免费申请20张。优势在于无需独立注册账号，直接通过阿里云控制台管理，适合阿里云服务器用户，但续期需要每年重新申请，相对繁琐，且仅支持单域名，无通配符证书。</p><h3>腾讯云免费SSL证书</h3><p>腾讯云提供的免费DV证书，有效期12个月，支持单域名证书，通过腾讯云DNS验证流程，自动化程度较高，但每年仅支持5张免费证书，适合腾讯云生态内的短期项目或测试站点。</p><h3>ZeroSSL</h3><p>ZeroSSL与Let's Encrypt基于同一ACME协议，支持通配符证书和中文界面，提供可视化申请流程，降低新手上手难度，但续期仍需要配置自动脚本，且免费版每月仅支持3个域名，适合对界面友好度要求较高的临时项目。</p><h2>六、选型决策指南</h2><ol><li><strong>技术能力导向</strong>：有服务器运维经验，希望实现全自动续期，首选Let's Encrypt。</li><li><strong>中文体验导向</strong>：偏好中文界面，希望永久免费且无需续期，首选JoySSL。</li><li><strong>一站式需求</strong>：需要CDN加速和安全防护，不想手动操作证书部署，首选Cloudflare。</li><li><strong>云生态适配</strong>：使用阿里云或腾讯云服务器，可优先选择对应云厂商的免费证书，减少跨平台操作流程。</li></ol>]]></description></item><item>    <title><![CDATA[申请OV SSL证书的详细攻略 才高八斗的杯子_dS2Fpp ]]></title>    <link>https://segmentfault.com/a/1190000047601454</link>    <guid>https://segmentfault.com/a/1190000047601454</guid>    <pubDate>2026-02-09 14:04:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h4>什么是OVSSL证书？</h4><p>OVSSL证书，即<strong>组织验证型SSL证书</strong>。它不仅仅验证域名的所有权，更重要的是由权威的CA机构对申请<strong>企业或组织的真实存在、合法注册及运营状态</strong>进行人工审核。这是其与DV证书最核心的区别。</p><ul><li><strong>直观体现</strong>：安装后，在浏览器地址栏点击小锁图标，可以查看到<strong>企业/组织的详细信息</strong>。</li><li><strong>核心价值</strong>：建立更强的在线信任，向用户证明网站背后是一个真实合法的实体，常用于企业官网、电子商务、会员登录等需要用户提交敏感信息的场景。<br/><img width="489" height="358" referrerpolicy="no-referrer" src="/img/bVdc91G" alt="" title=""/></li></ul><h4>如何申请OVSSL证书？（详细步骤）</h4><h4><strong>第一步：前期准备与信息确认</strong></h4><ol><li><strong>确定域名</strong>：明确需要保护的域名（例如 <code>yourcompany.com</code>）。</li><li><p><strong>准备企业资料</strong>：这是最关键的一步，确保资料真实、有效且与官方记录一致。</p><ul><li><strong>企业营业执照</strong>：清晰的彩色扫描件。</li><li><strong>企业联系电话</strong>：必须是官方公开的、能接通的公司座机号码（非个人手机），用于CA电话核实。</li><li><strong>企业邮箱</strong>：通常需要使用以申请域名结尾的企业邮箱（如 <code>admin@yourcompany.com</code>），用于接收验证邮件。部分CA也接受其他公认的企业邮箱。</li><li><strong>申请者信息</strong>：申请人的姓名、职位、公司座机、个人邮箱。</li></ul></li></ol><h4>第二步：选择证书服务商（CA或经销商）并下单</h4><p>访问JoySSL官方网站，在右上角找到“注册”按钮并点击。填写相关信息，创建一个证书管理账号。注册过程中，务必填写特定的注册码<strong>230970</strong>，这样才可以获得渠道低价和全程技术支持。</p><h3><a href="https://link.segmentfault.com/?enc=rEnydCwYP1rnCTIzmSgDmg%3D%3D.PW%2FMbjurr2q5HDnffSa0Te44S6mdoiaU4K4l5ELIbE%2BYTOVhuHVorSVXlDfqm7uDw2h1EyIO9WEx86p9Z1JiQA%3D%3D" rel="nofollow" target="_blank">OVSSL证书申请入口</a></h3><p><strong>1、选择证书类型与年限</strong></p><p>登录账号后，进入SSL证书栏，找到“OV证书”选项。根据自身需求，选择OV单域名、OV通配符、或者OV IP地址等SSL证书后，点击“下单”，并通过在线支付或公对公转账的方式完成支付。</p><p><strong>2、申请证书</strong></p><p>在申请页面，需要填写一系列信息，包括域名、单位名称、联系人、联系方式、邮箱等。这些信息将用于验证单位的真实性，所以务必确保准确无误。</p><p><strong>3、验证域名或IP的管理权</strong></p><p>提交申请后，并要求验证域名或者IP地址的所有权。按照系统提示的操作步骤进行验证，包括域名DNS解析认证或者服务器文件验证，操作完成后提交。</p><p><strong>4、组织信息审核</strong></p><p>JoySSL会对企业的组织信息进行验证，通常会通过电话、电子邮件等方式确认公司信息的真实性，审核过程一般在1到3个工作日左右完成。</p><p><strong>4、部署证书</strong></p><p>一旦审核通过后，JoySSL将签发OV SSL证书。下载已经签发的证书，根据JoySSL提供的安装指南或服务器文档，将证书安装到服务器上。</p>]]></description></item><item>    <title><![CDATA[达内教育-Java培优班 学习园地主页 ]]></title>    <link>https://segmentfault.com/a/1190000047601457</link>    <guid>https://segmentfault.com/a/1190000047601457</guid>    <pubDate>2026-02-09 14:03:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在Java编程学习的征途上，许多学习者怀揣热情启程，却在基础语法阶段遭遇意想不到的障碍与困惑。这些看似简单的语法细节，往往成为后续深入学习与项目开发中的隐形绊脚石。达内Java培优班基于多年教学经验与海量学员学习数据，精准识别出那些最常见却又最容易被忽视的Java基础语法易错点，并通过系统化的拆解，帮助学员夯实编程根基，避开前行路上的诸多陷阱。</p><hr/><p>变量与数据类型：类型转换的隐秘风险<br/>Java作为一门强类型语言，变量与数据类型的严格管理是其核心特性之一。然而，恰恰是在“类型转换”这一基础环节，许多初学者频频犯错。达内培优班在教学中发现，尽管自动类型转换（隐式转换）和强制类型转换（显式转换）的概念看似简单，但在实际操作中，学习者往往因忽略数据范围与精度损失而引发逻辑错误。</p><p>例如，在将float类型赋值给long类型时，看似直接的赋值操作背后，实则可能隐藏着数据精度的微妙变化。培优班通过引入“数据范围阶梯图”与“精度损失警示模型”，将抽象的转换规则可视化，帮助学员建立起对数据类型边界的直观认知。更重要的是，课程特别强调在商业计算等精度敏感场景中，为何要避免使用float和double，而应转向BigDecimal这类工具，这种从原理到实践的全方位解析，让学员不仅“知其然”，更“知其所以然”。</p><hr/><p>运算符与表达式：优先级与结合性的思维盲区<br/>“为什么我的计算结果和预期不符？”——这是Java初学者在涉及复杂表达式时最常见的疑问。达内培优班的教学分析显示，问题往往不在于学员不会使用单个运算符，而在于对运算符的“优先级”和“结合性”缺乏系统把握。</p><p>Java中数十种运算符有着明确的优先级层次，而同一优先级的运算符则遵循特定的结合方向。培优班通过独创的“运算符优先级扑克牌”记忆法与大量“表达式拆解沙盘练习”，将这一枯燥的规则转化为可操作、可演练的学习体验。例如，对于a += b与a = a + b这类细微差别，课程会设计对比实验，让学员亲眼见证在类型不同时两者可能产生的不同结果，从而深刻理解复合赋值运算符内含的类型转换机制。</p><hr/><p>控制流程：循环与条件分支的逻辑陷阱<br/>控制流程是编程逻辑的骨架，但骨架的连接处往往是最脆弱的部分。在if-else条件判断中，初学者常因误用赋值运算符=代替关系运算符==而引入难以察觉的错误。培优班不仅指出这一常见错误，更进一步剖析其根源：为何Java编译器在某些情况下不会对此报错？这背后涉及表达式返回值、布尔上下文等更深层的语言特性。</p><p>循环结构中的易错点则更为隐蔽。例如，在for循环中修改循环变量、在多重循环中错误定位break与continue的作用范围、对while与do-while的选择不当等。达内培优班采用“代码执行轨迹追踪法”，通过逐步动画演示程序执行的每个步骤，将内存中变量的变化可视化，使学员清晰看到自己的逻辑误解究竟发生在哪个具体环节。</p><hr/><p>面向对象基础：引用与对象的认知混淆<br/>面向对象是Java的核心范式，而理解“引用”与“对象”的关系则是通往这一范式的第一道门槛。许多学员在方法参数传递时，对“值传递”这一概念产生根本性误解，误以为对象作为参数传递时是“引用传递”。培优班通过精心设计的“对象盒子与引用标签”比喻，将这一抽象概念具象化：引用变量好比一个贴有地址的标签，而对象则是存储在该地址的盒子；方法调用时传递的是标签的副本，而非盒子本身。</p><p>这一根本性理解的建立，直接影响到学员对对象比较（==与equals的区别）、对象克隆、以及集合框架中元素存储方式等一系列高级主题的掌握。培优班通过“认知纠偏-概念重建-实践验证”三步教学法，确保学员在这一关键节点上建立正确且牢固的认知模型。</p><hr/><p>异常处理：被忽视的防御性编程起点<br/>异常处理机制常被视为进阶内容而被初学者草率对待，但达内培优班将其定位为“基础语法中的高级修养”。教学中发现，学员最常出现的错误并非不知道try-catch的语法，而是对“该捕获什么异常”、“何时该捕获”、“捕获后该如何处理”缺乏清晰原则。</p><p>培优班独创“异常分类光谱图”，将Java异常体系按照严重程度、处理责任、发生频率等维度进行分类展示，帮助学员建立异常处理的层次化思维。更重要的是，课程强调异常处理不仅是语法要求，更是防御性编程的起点。通过分析未处理异常如何导致程序崩溃、资源泄露等严重后果，学员能够从项目全局的角度重新审视这一基础语法的战略价值。</p><hr/><p>总结：从易错点到思维模式的升华<br/>达内Java培优班对基础语法易错点的拆解，其深层价值不在于罗列常见错误清单，而在于通过这些问题揭示Java编程的思维模式与设计哲学。每一个易错点都是一个知识盲区的信号，每一次纠错都是一次思维结构的优化。</p><p>培优班的教学实践表明，当学员能够主动识别并规避这些基础语法陷阱时，他们的编程思维已经发生了质的飞跃：从机械记忆语法规则，转变为理解语言设计逻辑；从被动应对编译错误，转变为主动预防逻辑缺陷。这种思维层面的提升，正是学员从Java语法学习者成长为合格Java开发者的关键转折点，也为后续深入框架学习、参与企业级项目开发奠定了最为坚实的基础。在达内的教学体系中，对基础语法的精雕细琢，从来都不是小题大做，而是对编程生涯的深度投资。</p>]]></description></item><item>    <title><![CDATA[HarmonyOS ：AI 套件技能调用从场景到实战全指南 认真的咖啡 ]]></title>    <link>https://segmentfault.com/a/1190000047601460</link>    <guid>https://segmentfault.com/a/1190000047601460</guid>    <pubDate>2026-02-09 14:02:35</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>写在前面</h2><blockquote>在 AI 从 “云端集中式” 向 “端侧分布式” 演进的今天，用户对智能体验的需求早已从 “能用” 升级为 “安全、实时、无界”，而 HarmonyOS 凭借原生的端侧 AI 能力与分布式架构，恰好击中了这一行业痛点。不同于依赖云端算力的传统 AI 方案，HarmonyOS 的 AI 套件构建在 “本地计算 + 毫秒响应 + 模型复用” 三大核心优势之上：端侧推理让用户数据全程留在设备内，完美解决了 AI 应用的隐私焦虑；毫秒级的响应速度，让语音交互、实时识别等场景告别 “加载等待”；而系统级的模型复用机制，更是让开发者无需从头训练模型，仅通过标准化接口就能调用成熟的智能能力。那么本文就来以HarmonyOS开发中关于AI套件的技能调用功能的使用来详细聊聊，深入解析如何通过系统级AI接口、分布式协同框架与模型优化工具链，实现高效智能业务开发。</blockquote><h2>技能调用：端侧 AI 与应用的智能联动机制</h2><p>技能调用是意图框架依托系统AI多模态大模型能力做深度用户输入理解，并通过解析的用户意图对接应用或元服务内的功能和内容。技能调用的本质，是 HarmonyOS 意图框架借助系统级多模态大模型，对用户输入（语音、文本、图像等）进行深度语义解析，进而关联应用 / 元服务内功能与内容的智能联动机制。它的核心价值，是让用户通过自然语言即可直接触发复杂功能，无需逐层点击界面，实现 “说即所得” 的智能交互。</p><h2>核心应用场景拆解</h2><p>使用者通过对小艺对话进行自然语言输入实现内容查询，知识问答，以及通过对图片选定识别问答进行服务获取。技能调用场景分为两种：</p><ul><li>功能服务类：端侧意图调用直接进入应用或元服务对应意图功能服务页面。</li><li><p>信息交互类：云侧意图调用进行内容查询后展示，端侧用户点击进行意图调用闭环。<br/>典型的使用场景分为：功能服务类和信息交互类两种场景。</p><h3>1、信息交互类</h3><p>信息交互类的场景分为三种情况，具体如下所示：</p></li><li>内容展示场景。例如查找菜谱：语音对话输入“鱼香肉丝怎么做”，即可搜索到对应的菜谱。</li><li>内容展示+AIGC生成场景。例如查公司：语音对话输入“某公司怎么样”，即可生成并展示关于某公司的信息。</li><li><p>功能履约场景。例如订电影票：语音对话输入“买两张今天的电影票，某电影”，即可进行电影票购买选座。</p><h3>2、功能服务类</h3><p>功能服务类的场景也分为三种情况，具体如下所示：</p></li><li>跳转页面不带参数场景。例如打开付款码：语音对话输入“打开xx付款码”，即可弹窗对应付款码。</li><li>跳转页面带参数场景。例如搜索商品带关键词：语音对话输入“打开xx应用搜一下xx品牌39码”，即可弹窗对应商品。</li><li><p>功能执行并展示UIExtension。例如操控蓝牙开关：语音对话输入“打开蓝牙”，即可弹窗蓝牙设置，并打开蓝牙开关。</p><h2>技能调用接入全流程</h2><h3>1、接入方案概述</h3><p>关于使用接入方案的概述，开发者需要按照意图定义，进行意图注册并实现意图调用；用户通过对小艺对话进行自然语言输入，小艺理解语义转换成意图调用（含意图参数），执行意图调用实现对应交互体验。HarmonyOS AI 套件的技能调用遵循 “意图定义→意图注册→意图执行” 的标准化流程，具体流程图如下所示：<br/><img width="723" height="504" referrerpolicy="no-referrer" src="/img/bVdnTtA" alt="image.png" title="image.png"/></p><h3>2、意图注册</h3><p>这里以“搜索旅游攻略”特性为例，使用者需要首先注册“查看旅游攻略”（ViewTravelGuides）。开发者需要编辑对应的意图配置PROJECT_HOME/entry/src/main/resources/base/profile/insight_intent.json文件，实现意图注册，具体操作如下所示：</p></li></ul><pre><code>{
  "insightIntents": [
    {
      "intentName": "ViewTravelGuides",
      "domain": "TravelDomain",
      "intentVersion": "1.0.1",
      "srcEntry": "./ets/entryability/InsightIntentExecutorImpl.ets",
      "uiAbility": {
        "ability": "EntryAbility",
        "executeMode": [
          "background",
          "foreground"
        ]
      },
      "uiExtension": {
        "ability": "insightIntentUIExtensionAbility"
      }
    }
  ]
}</code></pre><p>其中，配置参数信息如下所示：<br/><img width="723" height="582" referrerpolicy="no-referrer" src="/img/bVdnTtD" alt="image.png" title="image.png" loading="lazy"/></p><h2>技能调用实战：两类核心意图触发</h2><p>根据上面的接入方案，这里通过前台意图和前台窗口意图两个调用来介绍具体的使用。</p><h3>1、前台 UIAbility 意图调用实践</h3><p>具体的使用的时候，需要开发者自己实现InsightIntentExecutor，并在对应回调实现打开详细页（点击推荐卡片跳转的界面，如旅游攻略详细页面）的能力，ViewTravelGuides的意图调用字段定义见查看旅游攻略 （ViewTravelGuides）。实际操作步骤如下：<br/>（1）继承InsightIntentExecutor。<br/>（2）重写对应方法，例如目标拉起前台页面，则可重写onExecuteInUIAbilityForegroundMode方法。<br/>（3）通过意图名称，识别查看旅游攻略意图(ViewTravelGuides)，在对应的方法中传递意图参数（param），并拉起对应落地页（点击推荐卡片跳转的界面，如旅游攻略详细面）。<br/>具体的实现代码如下所示：</p><pre><code>import { insightIntent, InsightIntentExecutor } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';


export default class InsightIntentExecutorImpl extends InsightIntentExecutor {
  private static readonly VIEW_TRAVEL_GUIDES = 'ViewTravelGuides';
  /**
   * override 执行前台UIAbility意图
   *
   * @param name 意图名称
   * @param param 意图参数
   * @param pageLoader 窗口
   * @returns 意图调用结果
   */
  onExecuteInUIAbilityForegroundMode(name: string, param: Record&lt;string, Object&gt;, pageLoader: window.WindowStage):
    Promise&lt;insightIntent.ExecuteResult&gt; {
    // 根据意图名称分发处理逻辑。接入方可根据实际业务实现页面跳转
    switch (name) {
      case InsightIntentExecutorImpl.VIEW_TRAVEL_GUIDES:
        return this.viewTravelGuides(param, pageLoader);
      default:
        break;
    }
    return Promise.resolve({
      code: -1,
      result: {
        message: 'unknown intent'
      }
    } as insightIntent.ExecuteResult)
  }
  /**
   * 实现调用查看旅游攻略功能
   *
   * @param param 意图参数
   * @param pageLoader 窗口
   */
  private viewTravelGuides(param: Record&lt;string, Object&gt;, pageLoader: window.WindowStage): Promise&lt;insightIntent.ExecuteResult&gt; {
    return new Promise((resolve, reject) =&gt; {
      // 实现意图调用，loadContent的入参为旅游攻略落地页路径
      pageLoader.loadContent('pages/TravelGuidePage')
        .then(() =&gt; {
          let entityId: string = (param.items as Array&lt;object&gt;)?.[0]?.['entityId'];
          resolve({
            code: 0,
            result: {
              message: 'Intent execute succeed'
            }
          });
        })
        .catch((err: BusinessError) =&gt; {
          // 调用失败的情况
          resolve({
            code: -1,
            result: {
              message: 'Intent execute failed'
            }
          })
        });
    })
  }
}</code></pre><h3>2、前台 UIExtension 窗口意图调用实践</h3><p>具体的使用的时候，开发者还需要自己实现InsightIntentExecutor，并在对应回调实现窗口页面内容加载的能力。实际操作步骤如下：<br/>（1）继承InsightIntentExecutor。<br/>（2）重写对应方法，例如目标拉起前台窗口化页面，则可重写onExecuteInUIExtensionAbility方法。<br/>（3）通过意图名称，识别打开蓝牙意图（LoadBluetoothCard）调用扩展意图，在对应的方法中传递意图参数（param），并拉起对应窗口化页面。<br/>具体的实现代码如下所示：</p><pre><code>import { insightIntent, InsightIntentExecutor, UIExtensionContentSession } from '@kit.AbilityKit';

export default class IntentExecutorImpl extends InsightIntentExecutor {
  private static readonly TAG: string = 'IntentExecutorImpl';
  private static readonly LOAD_BLUETOOTH_CARD: string = 'LoadBluetoothCard';
  /**
   * override 执行前台UI扩展意图
   *
   * @param name 意图名称
   * @param param 意图参数
   * @param pageLoader 窗口
   * @returns 意图调用结果
   */
  async onExecuteInUIExtensionAbility(name: string, param: Record&lt;string, Object&gt;,
    pageLoader: UIExtensionContentSession):
    Promise&lt;insightIntent.ExecuteResult&gt; {
    console.info(IntentExecutorImpl.TAG, `onExecuteInUIExtensionAbility`);
    switch (name) {
      case IntentExecutorImpl.LOAD_BLUETOOTH_CARD:

        return this.openLoadBluetoothCard(pageLoader);
      default:

        break;
    }

    let result: insightIntent.ExecuteResult = {
      code: -1,
      result: {
        message: 'onExecuteInUIExtensionAbility failed'
      }
    };
    return result;
  }

  /**
   * 打开加载蓝牙卡片意图
   *
   * @param pageLoader 意图内容Session对象
   * @returns 执行结果
   */
  private async openLoadBluetoothCard(pageLoader: UIExtensionContentSession): Promise&lt;insightIntent.ExecuteResult&gt; {
    pageLoader.loadContent('pages/UiExtensionPage');
    let result: insightIntent.ExecuteResult = {
      code: 0,
      result: {
        message: 'intent execute succeed'
      }
    }
    return result;
  }
}</code></pre><h2>最后</h2><p>通过上面的详细介绍，其实HarmonyOS AI 套件的技能调用，本质上是在 “端侧智能” 与 “分布式架构” 的双重加持下，重新定义了开发者与智能能力的协作方式，它不再是 “开发者适配 AI”，而是 “AI 适配开发者”。当其他系统还在依赖云端 AI 的 “远程算力” 时，HarmonyOS 已经通过端侧推理让智能体验 “零延迟、零隐私风险”；当多数框架还在要求开发者掌握复杂的模型训练时，HarmonyOS 的意图框架与预置模型，让个人开发者仅需几行代码就能实现 “自然语言触发功能” 的智能特性。这不仅是技术的平权，更是将 “泛在智能” 从概念落地为可触达的开发工具。随着多模态大模型与 HarmonyOS 分布式硬件的深度绑定，我们将看到更惊人的场景：手机上触发的 “旅游攻略查询”，能自动同步到车机的导航界面；手表上的语音指令，能直接控制智能家居的设备状态，而这一切，都可以通过 AI 套件的技能调用快速实现。</p>]]></description></item><item>    <title><![CDATA[VMware ESXi 9.0.1.0 macOS Unlocker & OEM BIOS 2.7 ]]></title>    <link>https://segmentfault.com/a/1190000047601483</link>    <guid>https://segmentfault.com/a/1190000047601483</guid>    <pubDate>2026-02-09 14:01:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>VMware ESXi 9.0.1.0 macOS Unlocker &amp; OEM BIOS 2.7 集成网迅网卡驱动定制版</p><p>VMware ESXi 9.0 macOS Unlocker &amp; OEM BIOS 2.7 集成网卡驱动和 NVMe 驱动 (集成驱动版)</p><p>发布 ESXi 9.0 集成驱动版，在个人电脑上运行企业级工作负载</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=MPhQAcm36lsWLxV6xEteXQ%3D%3D.gL3FNgPlTxLphcuFpkjTGriRfjE6WSaH071To1WEGzk6%2FiDho6xIa%2BRTQXsb%2Byee" rel="nofollow" target="_blank">https://sysin.org/blog/vmware-esxi-9-sysin/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=IvhCLixd5slbVK1WN5wb8w%3D%3D.r3HjuGyo3qul59uD1ecl8DjUR1UqGw%2FRh6qN98%2Bm4co%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>2026-01-12，应用户要求，更新集成网迅网卡驱动定制版。</p><p><strong>发布 ESXi 9.0 集成驱动版，在个人电脑上运行企业级工作负载，构建开发、测试和学习的最佳平台。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044081967" alt="vSphere Workloads Everywhere" title="vSphere Workloads Everywhere"/></p><h2>通用特性概览</h2><p>该版本在官方原版基础上新增以下特性：</p><ul><li>macOS Unlocker：来自 GitHub 的 <a href="https://link.segmentfault.com/?enc=bTmmER70VQOKftDxTcKFaA%3D%3D.pHVQT7vJOVhociJsdrfgeJiG%2FkZrj%2FWwREReFPPCziJNH%2Fgmx0ab%2FceUILUovM%2Fa" rel="nofollow" target="_blank">Unlocker 4</a>，现已支持 macOS Tahoe</li><li>OEM BIOS 2.7：使用社区最流行的 OEM BIOS/EFI64，现已支持 Windows Server 2025</li><li>LegacyCPU support，允许在不受支持的旧款 CPU 上安装 ESXi 9.0</li><li>ESX-OSData 卷大小修改为 8GB，解决自 ESXi 7.0 起系统占用磁盘空间过大的问题（超过 142GB）</li><li>有限支持采用混合架构的第 12 代及以上 Intel 处理器，可实现正常引导和运行</li><li>中文界面语言支持，在 ESXi 9.0 的 Host Client 中继续支持简体中文界面语言，包括繁体中文</li></ul><p>详情请访问原文链接：<a href="https://link.segmentfault.com/?enc=Gk4gzUFV%2B%2FnQ9ReoU3BjdA%3D%3D.M3isLqJxPYfmhrvlinnqcLpup8wo%2BV4xhwYXoGy1Dk3Vx6R3JfllJZretg9q6ksS" rel="nofollow" target="_blank">https://sysin.org/blog/vmware-esxi-9-sysin/</a> 查看。</p><h2>集成网迅网卡驱动定制版</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047539520" alt="NETSWIFT" title="NETSWIFT" loading="lazy"/></p><p>北京网迅科技有限公司是一家专门从事集成电路高端芯片设计、提供网络产品解决方案的高科技企业。公司成立于 2014 年 5 月，总部位于北京市海淀区玉泉慧谷科技园区，在浙江杭州设有分公司。</p><p>公司成功研制了自有知识产权的万兆和千兆以太网控制器芯片、适配器，突破了一系列计算机网络领域高端芯片设计的难题，在网络安全和网络虚拟化等方面达到了较高水平。</p><p>网迅网卡不仅兼容 Windows 系统和主流的 Linux 发行版，还可以支持最新的 VMware ESXi 系统，远超预期！</p><p>以下是经过验证支持最新版 ESXi 的网讯网卡型号。</p><table><thead><tr><th>Brand Name</th><th>Model</th><th>VendorID</th><th>DeviceID</th><th>SVID</th><th>SSID</th></tr></thead><tbody><tr><td>Wangxun/NETSWIFT</td><td>FF5025-DDATACXX</td><td>8088</td><td>5025</td><td>8088</td><td>1000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>FF5025-DDATAIXX</td><td>8088</td><td>5125</td><td>8088</td><td>3000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>FF5040-DDBTACXX</td><td>8088</td><td>5040</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>FF5040-DDBTAIXX</td><td>8088</td><td>5140</td><td>8088</td><td>3000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>RP1000 series</td><td>8088</td><td>1001</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>RP2000 series</td><td>8088</td><td>2001</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860A2</td><td>8088</td><td>0101</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860A4</td><td>8088</td><td>0103</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860A4S</td><td>8088</td><td>0104</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860AL2</td><td>8088</td><td>0105</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860AL2S</td><td>8088</td><td>0106</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860AL4</td><td>8088</td><td>0107</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860AL4S</td><td>8088</td><td>0108</td><td>0000</td><td>0000</td></tr><tr><td>ZTE Corporation</td><td>NO127</td><td>8088</td><td>0103</td><td>1cf2</td><td>0801</td></tr><tr><td>ZTE Corporation</td><td>NO127D</td><td>8088</td><td>0101</td><td>1cf2</td><td>0802</td></tr></tbody></table><h2>下载地址</h2><p><strong>ESXi 9.0.1.0 集成驱动版 (2026-01-12)</strong>：</p><ul><li>发布日期：2026-01-12</li><li>50 余项已知问题修复。请参看：<a href="https://link.segmentfault.com/?enc=v%2BmZ%2Bb%2FAHMpB2x9smJpZvQ%3D%3D.nRn1d9FcvKSyJpT4EkDxP6rP2qGMBesvuYPbQt9qi1uTuK5RuyjpGvSr7D46jmwo" rel="nofollow" target="_blank">ESXi 9.0.1.0 已解决的问题</a>。</li><li>请访问：<a href="https://link.segmentfault.com/?enc=vEUfqeEjIorU2AzgT0A%2F%2Bw%3D%3D.CumTORWNmwo%2FbkRESI%2B4pYGNPTPC%2FduGlotoFDXY3tUk9%2FzUVRz7GpLchNk6rWg7" rel="nofollow" target="_blank">https://sysin.org/blog/vmware-esxi-9-sysin/</a></li></ul><hr/><p>标准版和厂商定制版，请访问：</p><ul><li><a href="https://link.segmentfault.com/?enc=abyI2af7M42aU22e87mHsg%3D%3D.fmI9td0q5mGorj9b0gy9jivSaIop9rmstF2n4YqZQPLwL%2B5ZgqcCiEuX8sV2rfAz" rel="nofollow" target="_blank">VMware ESXi 9.0.1.0 macOS Unlocker &amp; OEM BIOS 2.7 标准版和厂商定制版</a></li></ul><p>官方原版，请访问：</p><ul><li><a href="https://link.segmentfault.com/?enc=C4yta874Jvkjm1sCsymsDg%3D%3D.kBksS3mQVwkdjmmt8Mf3o1wcJrGMTTlVrcKydn4zHTtj9mXdts8HLF6QABC3LG6c" rel="nofollow" target="_blank">VMware vSphere 9.0 正式版发布 - 企业级工作负载平台</a></li></ul><p>上一个版本，请访问：</p><ul><li><a href="https://link.segmentfault.com/?enc=NCj5ZwItJOIiBOg1LAiXJg%3D%3D.TCbvtuEmdUyeGyhcc26SXvKJz7mfzPXMjgkvx3RbRqlHe%2B16pgPyu2Iz1%2FYz0wZv" rel="nofollow" target="_blank">VMware ESXi 8.0U3g macOS Unlocker &amp; OEM BIOS 2.7 集成网卡驱动和 NVMe 驱动 (集成驱动版)</a></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=V1FwdrNUenPNFop1wcLTFw%3D%3D.enK0gj0Dg%2F1EB1z0vu6M3uJd%2B7PZovANhLbMv9tiQ5Y%3D" rel="nofollow" target="_blank">VMware 产品下载汇总</a></p>]]></description></item><item>    <title><![CDATA[Gemini 与住宅代理完整指南：稳定访问、风控理解与网络身份构建 IPPeak ]]></title>    <link>https://segmentfault.com/a/1190000047601493</link>    <guid>https://segmentfault.com/a/1190000047601493</guid>    <pubDate>2026-02-09 14:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>随着生成式 AI 工具逐步走向主流，Gemini 已经成为许多开发者、研究人员以及内容创作者日常工作的一部分。然而，在真实使用过程中，不少用户会发现，Gemini 的访问体验并非始终稳定。页面加载失败、功能不可用、验证反复触发，甚至在不同网络环境下表现差异明显，这些问题的背后，往往并不只是产品本身的限制，而是与网络出口的可信度密切相关。</p><h2>Gemini 对网络环境的隐性要求</h2><p>从表面来看，Gemini 只是一个面向用户开放的 AI 服务，但在底层，它运行在一套高度自动化的风控体系之中。系统并不会单纯依赖账号信息来判断请求是否可信，而是会综合分析访问来源的网络类型、地理位置、IP 历史行为以及整体使用模式。<br/>当访问请求来自数据中心、云服务器或被频繁滥用的代理网络时，即便账号本身没有问题，也更容易触发限制机制。这类限制并不总是以“封禁”的形式出现，而是通过降低响应稳定性、限制功能可用性等方式逐步体现出来。<br/>也正因为这种“软性风控”的存在，很多用户会误以为是 Gemini 本身不稳定，而忽略了网络出口这一核心变量。</p><h2>普通代理在 Gemini 场景中的局限性</h2><p>在尝试优化访问体验时，一部分用户会首先想到使用代理工具。然而，普通代理往往难以满足 Gemini 对网络真实性的隐性要求。这类代理通常集中部署在有限的 IP 段中，出口特征明显，使用行为高度重复。<br/>在短时间内，这种代理或许可以完成连接，但随着请求频率增加，系统很容易识别出异常模式。一旦 IP 被标记，后续访问即使切换账号，也难以恢复到理想状态。这也是为什么频繁更换代理并不能真正解决问题，反而可能进一步降低整体成功率。<br/>真正有效的方案，并不在于“绕过检测”，而在于让访问行为本身更接近真实用户。</p><h2>住宅代理如何改变 Gemini 的访问体验</h2><p>住宅代理的核心价值，在于其 IP 来源于真实家庭网络环境。与服务器代理相比，这类 IP 在网络路径、自治系统归属以及历史行为上，更符合普通用户的访问特征。<br/>当 Gemini 接收到来自住宅网络的请求时，其风控系统更倾向于将其视为正常使用，而非潜在风险。这种差异并不会在界面上直接体现，却会反映在连接稳定性、响应速度以及功能完整性上。<br/>尤其是在需要长期使用 Gemini、频繁进行交互或调用相关功能的场景中，住宅代理所带来的稳定性优势会逐渐显现。</p><h2>网络身份连续性的重要性</h2><p>在 Gemini 的使用过程中，另一个经常被忽视的因素，是网络身份的连续性。系统不仅关注单次请求是否异常，也会观察一段时间内访问行为是否具备连贯性。<br/>如果用户频繁切换 IP，或者在不同地区之间跳跃，反而容易形成不自然的使用轨迹。这种情况下，即便每一个 IP 本身质量尚可，整体行为模式仍然可能触发风控关注。<br/>高质量住宅代理的优势之一，正是在于能够在同一地区内提供足够自然的 IP 分布，使用户在需要更换出口时，依然保持网络身份的一致性。这种连续性，对于 Gemini 这类长期服务型平台尤为重要。</p><h2>真实使用中对代理质量的要求</h2><p>并非所有住宅代理都能带来理想效果。IP 池规模、地区覆盖深度以及匿名配置水平，都会直接影响 Gemini 的访问体验。如果住宅 IP 被过度共享，或者在协议层暴露中转特征，其效果与普通代理并无本质区别。<br/>在这一点上，IPPeak 的住宅代理架构更强调“真实分布”而非简单数量。其 IP 来源覆盖多个核心国家和地区，并保持足够分散的使用密度，使单一出口不容易形成异常使用模式。在实际应用中，这种结构有助于提高 Gemini 访问的整体成功率，并减少因网络问题导致的中断。<br/>需要强调的是，这种稳定性并非依赖激进策略，而是建立在更符合平台预期的网络表现之上。</p><h2>从技术工具到长期使用策略的转变</h2><p>当用户真正将 Gemini 视为长期工具时，对网络环境的要求也会随之发生变化。短期测试阶段，网络问题或许尚可接受，但在持续使用过程中，任何不稳定因素都会被放大。<br/>通过住宅代理构建更可信的网络身份，本质上是在为长期使用打基础。这种策略并不是为了对抗平台规则，而是通过更自然的方式，减少不必要的干扰，让技术工具回归其应有的价值。</p><h2>重新理解 Gemini 与网络出口的关系</h2><p>Gemini 的体验好坏，很大程度上并不取决于使用技巧，而取决于访问环境是否稳定、可信。当网络出口与普通用户高度一致时，系统的反馈也会更加友好。<br/>在这一背景下，住宅代理不再只是一个“辅助工具”，而是连接用户与 AI 服务之间的重要桥梁。理解这一点，往往是许多用户在经历反复尝试后才逐渐形成的共识。</p>]]></description></item><item>    <title><![CDATA[keepass安装与使用手记 三块钱 ]]></title>    <link>https://segmentfault.com/a/1190000047600947</link>    <guid>https://segmentfault.com/a/1190000047600947</guid>    <pubDate>2026-02-09 13:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>参考 与 致谢</h2><p>本手记参考以下博文融合而成，特此致谢：</p><ul><li><a href="https://link.segmentfault.com/?enc=zHEtvw8D3SZAayYBP7XpcA%3D%3D.kYWzf4J4zlZb1fA0i7M9HEQx4ECkKNT4%2BaXfE%2F30jhAyBjh1QB8p64QoyxhaYJlP" rel="nofollow" target="_blank">一劳永逸：KeePass全网最详使用指南</a></li><li><a href="https://link.segmentfault.com/?enc=QxvX9iQgumdQ4Ng1xngD2A%3D%3D.O2oakhG7Y8oKXaggOJPKQC%2BbvhnQK1ZuCRnllsIDprEjnMfd2SaaRaDmgfP4gWgok4nFM381OWnJhWvvENiOeA%3D%3D" rel="nofollow" target="_blank">KeePass安装与插件推荐</a></li><li><a href="https://link.segmentfault.com/?enc=oFXOKBnWQNXPWL%2Byi01VXw%3D%3D.r5VJB%2BfF2HY7uhXdo4l9u4dBFOadO73EqU0pWwW2NGqjqNq802xWW4Gp77%2Fg18ei7GbTevGEaCq18XQNEwnxFtNgUQxBGJ2A3vpgVKedLfRiuSMBP0RcxvK%2FST7Qbrj4" rel="nofollow" target="_blank">KeePass通过KeePassNatMsg和KeePassXC-Browser实现Chrome/FireFox/Edge自动填充</a></li><li><a href="https://link.segmentfault.com/?enc=6jvn2UTTT91WlhD4aN6kXw%3D%3D.tvPH%2FO19vtx6X%2BeBq13OhWZch5KVVJ0%2B4yKHpGNP3RyWQZpXle685zKqIEl8CoSp8FW6GLN4yhHGmgRCl5Nwcg%3D%3D" rel="nofollow" target="_blank">KeePass完全入门指南</a></li><li><a href="https://link.segmentfault.com/?enc=gD5GWIXF1OEOnNu166Zx%2Fw%3D%3D.E2AlqfK%2B76ATs3gxLKGKPBJ1Fgj2lwPZ2p2LhRFSMzo%2FfoMzDscx0N6PH1ZLAPlY" rel="nofollow" target="_blank">Keepass：多平台密码无缝同步</a></li></ul><h2>赖人版本</h2><p><strong>Keepass</strong>是一个在密码管理领域非常出色的一个工具软件，其强大的功能离不开众多的插件支持。但这也带来了一个问题，就是众多的插件配置起来繁琐又容易出错，一个一个测试需要花费巨大的时间和精力投入，就像我这边手记一样。为了避免一次次的配置和踩坑，本手记所配置完成的绿色版本<strong>Keepass</strong>包在这里下载：  <br/>★★★★★<a href="https://link.segmentfault.com/?enc=%2BSGrV1JjUL9bs0hl3hD2tA%3D%3D.1g0m8cP111VAmbYzFEwukg99BbsW6PCa%2BKHyeANfuHJI6uTWriztYq%2BZ5JnO6JN4k%2FDmFqVsSYK7AET3E5bSdA%3D%3D" rel="nofollow" target="_blank">👉Keepass 2.60 配置完整插件</a></p><p>由于每个人的使用环境差异，在下载赖人版本后，你还需要调整以下配置相关项：</p><ul><li>更改你的密码库密钥：〔文件〕/〔更改管理密钥〕</li><li>调整同步配置（坚果云配置），参考下文相关章节</li><li>安装浏览器插件并完成配置，参考下文相关章节</li><li><p>你需要确认几个快捷键：</p><ul><li>自动填充全局快捷键，见〔工具〕/〔选项〕/〔集成〕</li><li>自动填充密码全局快捷键，见〔工具〕/〔选项〕/〔集成〕</li><li>WebAutoType插件的创建记录快捷键，见下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600950" alt="alt text" title="alt text"/></li></ul></li></ul><h2>下载 与 安装</h2><p>此处推荐全胜 <strong>Portable</strong> 版本的keepass，这样你可以把 <strong>keepass</strong> 的程序和数据放到指定的位置即可。然后再通过同步软件（例如你的NAS，例如网盘，例如onedrive等）同步到其它电脑上，或者你可以把 <strong>keepass</strong> 的文件夹整体复制到另外的地方就可以直接使用，非常方便。</p><p><a href="https://link.segmentfault.com/?enc=k3SnMAzqlkBvlCO0uOkjMg%3D%3D.lHhYh%2FLHLIK6zcIughgb%2FGPYO9mMwIbPY9g8rvEeFPhxEhZky4QSHPr581t6w04o" rel="nofollow" target="_blank">👉Keepass2.60 官方链接</a>  <br/><a href="https://link.segmentfault.com/?enc=SCp5IwersQzl6W1QYBPGZQ%3D%3D.OUdS%2BF%2F%2B34V5o2VtjiPQHC0tTr%2B%2BrV8H3Bk2qoDff46pJbUUBuA4ivfEPhO5b76o0QyFa1HApyqtwmG9i0a6Tg%3D%3D" rel="nofollow" target="_blank">👉Portable Keepass2.60 🐕度链接 提取码: 6kms</a></p><h3>汉化</h3><p>在 <strong>Keepass</strong> 的官方网站中，你可以找到<a href="https://link.segmentfault.com/?enc=1PLdP2qN0SfZ8DwpbUm7gg%3D%3D.t%2BEj%2BKonbu9nJH0oM7FOtPRVnjSGa%2BDQHLRqBmIvmzd%2F6H2UBU%2BU8SZcoLZUrxf7" rel="nofollow" target="_blank">👉各种语言包</a>，👇如下  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600951" alt="alt text" title="alt text" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=psVerEOQ4WhuHuDy0GXHsw%3D%3D.g4SrCxyFkQwBEVQOVUX3cgZuL8WUVoCo5IMeYe9FK8J2gd%2FtKwKq%2FIkNR8SIHMySQiSQsTiPbqptglZRThO8Sg%3D%3D" rel="nofollow" target="_blank">👉Keepass2.60 中文语言包 🐕度链接 提取码: swwy</a></p><p>汉化包解压后得到 <strong>Chinese_Simplified.lngx</strong> 文件备用。</p><p><strong>Keepass</strong> 安装后（Portable版本不需要安装），打开界面是英文界面。此时通过〔View〕/〔Change Language〕/〔Open Folder〕打开语言包文件夹，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600952" alt="alt text" title="alt text" loading="lazy"/></p><p>然后将上一步得到的<strong>Chinese_Simplified.lngx</strong>放入打开的文件夹内。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600953" alt="alt text" title="alt text" loading="lazy"/></p><p>然后重启 <strong>Keepass</strong>，便可以选择中文界面了（选择中文语言后，会提示重启），如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600954" alt="alt text" title="alt text" loading="lazy"/></p><p>切换成功后的界面如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600955" alt="alt text" title="alt text" loading="lazy"/></p><h2>创建数据库（kdbx）</h2><p><strong>Keepass</strong>的密码数据存储与数据库文件（.kdbx）中，所以我们在使用<strong>Keepass</strong>前，需要首先创建一个用于储存与管理密码的数据库。</p><ul><li>新建数据库，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600956" alt="alt text" title="alt text" loading="lazy"/></li><li>选择一个位置来存放数据库文档，并给我们的数据库文档指定一个名字，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600957" alt="alt text" title="alt text" loading="lazy"/></li><li><p>然后，我们为我们的数据库设置打开密码，也可以指定另外两种保护方案，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600958" alt="alt text" title="alt text" loading="lazy"/></p><ul><li>👉如果你使用电脑的习惯规范（设置登录密码，并在离开时全胜<strong>Win+L</strong>锁定），单独使用〔管理密码〕或者〔密钥文件〕已经足够了。</li><li>👉我个人是单独使用〔密钥文件〕的，更为方便</li><li>👉密钥文件就是一个普通的文档而已，你可以选择现有的一个文件，也可以根据<strong>Keepass</strong>的引导创建一个新的文件。</li><li>👉密钥文件建议不要与<strong>Keepass</strong>的数据库文档放在同一位置或者关联位置</li><li>👉密钥文件可以重命名，但不可更改其内容</li><li>👉密钥文件建议云端同步，避免丢失</li><li>👉在存放密钥文件的位置，建议存放一些其它的文档，起到混淆作用</li></ul></li><li>设置数据库名称（不是数据库文档名称），如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600959" alt="alt text" title="alt text" loading="lazy"/>  <br/>关于〔应急表单〕，可以打印出来妥善保官，以备万一。</li><li>然后我们就得到了一个数据库，并附带了两个demo密码记录，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600960" alt="alt text" title="alt text" loading="lazy"/></li></ul><p>在后续的配置中，我们都基于我们所建立的数据库进行操作。</p><h2>开机启动</h2><p>开机启动设置如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600961" alt="alt text" title="alt text" loading="lazy"/></p><h2>全局热键</h2><p><strong>Keepass</strong>的全局热键可以使用户在非<strong>Keepass</strong>窗口中，也可以唤出<strong>Keepass</strong>进行键入操作。例如当你在浏览器中时，通过全局热键，就可以唤出<strong>Keepass</strong>录入用户名和密码。</p><p><strong>Keepass</strong>的全局热键可以在〔工具〕/〔选项〕中设置，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600962" alt="alt text" title="alt text" loading="lazy"/></p><h3>Keepass的匹配原理</h3><p>当用户在某一个应用程序中触发<strong>Keepass</strong>的全局热键后，<strong>Keepass</strong>会获取当前应用的标题，然后在数据库中查找应用应用满足要求的记录。并将这条记录键入到目标应用的输入框中。那么，什么样的记录算是满足要求的记录呢？这是在<strong>Keepass</strong>的〔工具〕/〔选项〕中设置的，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600963" alt="alt text" title="alt text" loading="lazy"/></p><p>所以，我们在创建密码记录时，需要考虑到<strong>Keepass</strong>的匹配机制，以便<strong>Keepass</strong>可以准确的找出我们需要的密码记录。例如你为百度账户创建密码记录时，如下的设置将更容易在百度各应用/平台上检索到本条密码记录：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600964" alt="alt text" title="alt text" loading="lazy"/></p><h2>键入规则</h2><p><strong>Keepass</strong>的默认自动键入规则为<strong>{USERNAME}{TAB}{PASSWORD}{ENTER}</strong>，解释如下👇：</p><ul><li><strong>{USERNAME}</strong> 表示输入输入用户名</li><li><strong>{TAB}</strong> 表示输入Tab键，表现行为是切换输入框</li><li><strong>{PASSWORD}</strong> 表示输入密码</li><li><strong>{ENTER}</strong> 表示按下回车键</li></ul><p>这个默认的输入行为，并不适合所有的用户。例如对于中文用户而言，在输入用户名和密码前，需要先切换输入框到英文状态，然后再启动输入动作，另例如对于有些页面或者应用程序（如QQ），则需要在输入完用户名密码后，要勾选用户协议方可进行登录。针对这些情况，本人使用的输入规则如下👇：  <br/><strong>+{DELAY 100}{CLEARFIELD}{USERNAME}{TAB}{PASSWORD}+</strong>  或者<br/><strong>^{SPACE}{DELAY 100}{CLEARFIELD}{USERNAME}{TAB}{PASSWORD}^{SPACE}</strong></p><p>解释如下👇：</p><ul><li><strong>+</strong> 表示输入<strong>Shift</strong> 键（对于Windows用户而言，<strong>Shift</strong>键用于切换输入法状态</li><li><strong>{DELAY 100}</strong> 表示等待100毫秒，输入<strong>Shift</strong>后停顿一下，等待系统响应</li><li><strong>{CLEARFIELD}</strong> 表示清空输入框，用于清空当前所在输入框的贼内容（第一个输入框是〔用户名〕输入框）</li><li><strong>{USERNAME}</strong> 表示输入输入用户名</li><li><strong>{TAB}</strong> 表示输入Tab键，表现行为是切换输入框</li><li><strong>{PASSWORD}</strong> 表示输入密码</li><li>最后一个 <strong>+</strong> 号，表示在完成键入后，将输入法状态还原</li></ul><p>注意点如下👇：</p><ul><li>这条规则最后没有了<strong>{ENTER}</strong>，最后的 <strong>Enter</strong>键由用户在勾选了用户协议后（如果有）再按下。</li><li>光标位置〔用户名〕输入框内时，确保输入法状态为<strong>中文</strong>，然后再启动<strong>Keepass</strong></li><li>如果你发现在键入时，输入法没有能成功的切换中英状态，你可以试一下把 <strong>+</strong> 换成 <strong>^{SPACE}</strong>，其中 <strong>^</strong> 表示 <strong>Ctrl</strong> 键，<strong>{SPACE}</strong> 表示空格键，这个组合可以切换输入法与非输入法。但需要使用哪个按键组合，需要根据你的电脑的相关设置而调整，如下👇：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600965" alt="alt text" title="alt text" loading="lazy"/></li></ul><h3>配置键入规则</h3><p>将上述键入规则配置到数据库中，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600966" alt="alt text" title="alt text" loading="lazy"/>  <br/>之后在该数据库中生成的密码记录将自动继承这个输入规则，除非你在添加记录时进行了额外的指定。</p><h3>关于〔双通道自动输入混淆〕</h3><p><strong>Keepass</strong>在键入用户名和密码时，是通过模拟按键进行键入的，那么如果你的电脑已经中毒，中了木马，他可以监视并获得你通过键盘键入的字符，那是不是<strong>Keepass</strong>键入的内容就被这个木马截获了？为了应对这个场景，<strong>Keepass</strong>支持在键入操作时，引入剪贴板渠道。意思就是说，<strong>Keepass</strong>将要输入的内容随机的截成n段，其中一部分通过模拟键盘键入，另一部分先放入粘贴板，然后再通过<strong>Ctrl+V</strong>粘贴到输入框中，这样木马程序只能观察到使用了<strong>Ctrl+V</strong>操作，但无法得知粘贴的内容，从而提高了密码键入的安全性。我们可以在创建密码时，在〔自动输入〕标签下的下方看到〔双通道自动输入混淆〕选项，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600967" alt="alt text" title="alt text" loading="lazy"/></p><p>👉注意，双通道键入模式，需要输入框支持<strong>Ctrl+V</strong>操作，并要求支持光标移动操作，但这两个操作并不是所有的平台的密码输入框都默认支持的，所以在使用〔双通道自动输入混淆〕功能时，请确保目标平台的密码框是支持以上操作的。</p><h2>一些基础的设置项</h2><p>为了更安全的使用<strong>Keepass</strong>，推荐您完成以下相关的设置项目（〔工具〕/〔选项〕），如下👇：</p><ul><li>[x] 〔安全〕/ 全局用户空闲如下时间后锁定主窗口：240</li><li>[x] 〔安全〕/ 剪贴板自动清空时间：12</li><li>[x] 〔安全〕/〔常规〕/ 锁定 Keepass -- 当锁定 Windows 或切换用户时</li><li>[x] 〔安全〕/〔常规〕/ 锁定 Keepass -- 当系统挂起时</li><li>[x] 〔安全〕/〔常规〕/ 锁定 Keepass -- 当远程控制模式改变时</li><li>[x] 〔高级〕/〔启动和退出〕/ 退出和锁定数据库时升上去保存</li><li>[ ] 〔高级〕/〔文件输入/输出链接〕/ 写入 数据库时全胜文件交换处理</li><li>[ ] 〔高级〕/〔高级〕/ 记住密匙源（密匙文件路径、提供者名称等...）</li><li>[x] 〔高级〕/〔高级〕/ 在安全桌布输入管理密码</li></ul><h2>层叠显示与平铺显示</h2><p>你可以通过设置〔显示〕/〔窗口布局〕来调整密码记录的显示方式，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600968" alt="alt text" title="alt text" loading="lazy"/></p><p>层叠显示效果如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600969" alt="alt text" title="alt text" loading="lazy"/>  <br/>平铺显示效果如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600970" alt="alt text" title="alt text" loading="lazy"/></p><h2>密码生成规则</h2><p>当我们注册某一账户时，需要生成一个新的密码以供使用，<strong>Keepass</strong>在创建新的记录时，会自动的生成一个新的密码以供我们注册时使用，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600971" alt="alt text" title="alt text" loading="lazy"/>  <br/>这是一个20位的由数字和字母组成的随机密码，但是并非所有的平台都支持20位这么长的密码长度，也有很多的平台要求密码必须包含特殊字符，所以这个随机密码的适应性不能满足一些要求。我们调整随机密码的生成规则如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600972" alt="alt text" title="alt text" loading="lazy"/></p><p>经过以上设置之后，我们在新建记录时，<strong>Keepass</strong>便可以根据我们刚才的设置规则生成新的随机密码了，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600973" alt="alt text" title="alt text" loading="lazy"/></p><h2>webDav(坚果云网盘)同步</h2><p>在电子设备普及的今天，几乎每个人都不止一个电脑+手机。如何在这么多的设备上共享密码信息呢？这里我们分享一个通过webDav同步<strong>Keepass</strong>数据库的方法，该方法来自<a href="https://link.segmentfault.com/?enc=nfqLlkt4N35PWrKjcqSefQ%3D%3D.bu%2BV6ocG%2BbJhFTcXMclk7VXcSv08I1cblAJffhcqmy0hDcLw0el9Ibi%2Bbf1Ki1lp" rel="nofollow" target="_blank">Keepass：多平台密码无缝同步</a>。</p><h3>准备坚果云</h3><ul><li>首先，我们需要有一个坚果云账号（免费的就行），您可以<a href="https://link.segmentfault.com/?enc=Q0Yia5B4B5BPj8viFtELcQ%3D%3D.%2BKUAd5jPIYxhPA93MNbYDGkwFs6WJ98kjA%2BKKDuwcdk%3D" rel="nofollow" target="_blank">👉在这里注册</a></li><li>然后，你需要在坚果云空间里创建一个〔keepass〕文件夹，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600974" alt="alt text" title="alt text" loading="lazy"/></li><li>然后，把你本地的<strong>Keepass</strong>的数据库文档（.kdbx文档）上传到这个坚果云的〔keepass〕文件夹内，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600975" alt="alt text" title="alt text" loading="lazy"/></li><li>然后，在坚果云上添加一个〔keepass〕应用，记下你的应用地址、账户名称和应用密码。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600976" alt="alt text" title="alt text" loading="lazy"/></li></ul><p>坚果云端完成以上设置即可。</p><h3>使用Keepass触发器触发webDav同步</h3><ul><li>按下图修改下面的<strong>Keepass</strong>触发脚本，然后复制修改完成后的脚本文本备用  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600977" alt="alt text" title="alt text" loading="lazy"/></li></ul><pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;TriggerCollection xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
&lt;Triggers&gt;
&lt;Trigger&gt;
&lt;Guid&gt;L2euC7Mr/EKh7nPjueuZvQ==&lt;/Guid&gt;
&lt;Name&gt;SaveSync&lt;/Name&gt;
&lt;Events&gt;
&lt;Event&gt;
&lt;TypeGuid&gt;s6j9/ngTSmqcXdW6hDqbjg==&lt;/TypeGuid&gt;
&lt;Parameters&gt;
&lt;Parameter&gt;1&lt;/Parameter&gt;
&lt;Parameter&gt;kdbx&lt;/Parameter&gt;
&lt;/Parameters&gt;
&lt;/Event&gt;
&lt;/Events&gt;
&lt;Conditions /&gt;
&lt;Actions&gt;
&lt;Action&gt;
&lt;TypeGuid&gt;tkamn96US7mbrjykfswQ6g==&lt;/TypeGuid&gt;
&lt;Parameters&gt;
&lt;Parameter&gt;SaveSync&lt;/Parameter&gt;
&lt;Parameter&gt;0&lt;/Parameter&gt;
&lt;/Parameters&gt;
&lt;/Action&gt;
&lt;Action&gt;
&lt;TypeGuid&gt;Iq135Bd4Tu2ZtFcdArOtTQ==&lt;/TypeGuid&gt;
&lt;Parameters&gt;
&lt;Parameter&gt;https://dav.jianguoyun.com/dav/keepass/xxx.kdbx&lt;/Parameter&gt;
&lt;Parameter&gt;userName@xxx.com&lt;/Parameter&gt;
&lt;Parameter&gt;userPwd&lt;/Parameter&gt;
&lt;/Parameters&gt;
&lt;/Action&gt;
&lt;Action&gt;
&lt;TypeGuid&gt;tkamn96US7mbrjykfswQ6g==&lt;/TypeGuid&gt;
&lt;Parameters&gt;
&lt;Parameter&gt;SaveSync&lt;/Parameter&gt;
&lt;Parameter&gt;1&lt;/Parameter&gt;
&lt;/Parameters&gt;
&lt;/Action&gt;
&lt;/Actions&gt;
&lt;/Trigger&gt;
&lt;/Triggers&gt;
&lt;/TriggerCollection&gt;</code></pre><ul><li>复制了触发器脚本后，将触发器配置到<strong>Keepass</strong>中，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600978" alt="alt text" title="alt text" loading="lazy"/></li><li>然后在<strong>Keepass</strong>界面按下<strong>Ctrl+S</strong>键，在<strong>Keepass</strong>下的状态栏中应该能看到webDave的同步过程及结果，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600979" alt="alt text" title="alt text" loading="lazy"/></li><li>关于连接，用户名，密码，也可以后期再调整，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600980" alt="alt text" title="alt text" loading="lazy"/></li></ul><h2>插件</h2><p><strong>Keepass</strong>的强大，离不开众多插件的支持。<strong>Keepass</strong>官网提供了数量众多，功能丰富的插件供用户下载使用，您可以前往<a href="https://link.segmentfault.com/?enc=8gI4JGx5Qp2FQjMFbMQtsQ%3D%3D.XyDbCvv2gKRZ0qhMnCjGnKn1Al%2BuKx51fGJVKIy2JfAkRRmhawZmMXVhsP7CWyk4" rel="nofollow" target="_blank">👉Keepass插件页面</a>下载您需要的插件。</p><h3>插件的安装</h3><p><strong>KeePass</strong>插件的安装非常之简单，当您下载了<strong>Keepass</strong>插件后，将其解压后即可得到 .plgx 文档以及 Readme.txt文档，我们将得到的 .plgx 文档放入<strong>Keepass</strong>目录的<strong>Plugins</strong>文件夹，然后<strong>重启 Keepass</strong>即可加载插件，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600981" alt="alt text" title="alt text" loading="lazy"/></p><p>你可以通过<strong>Keepass</strong>来找到并打开<strong>Plugins</strong>文件夹，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600982" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★★ SourceForgeUpdateChecker</h3><p><a href="https://link.segmentfault.com/?enc=OsEPATP7OGuiFM4jDgnDXA%3D%3D.aM%2FNPBHmWec5a3ybDoiLYRCETReUp3k1z4%2Bpa75iKZ%2FnJLrOPQ5u8s27PfYXqZoD0I5p0Pcnliy%2F4e4q8Dl1tg%3D%3D" rel="nofollow" target="_blank">SourceForgeUpdateChecker-v0.4.zip 🐕度提取码: hqgh</a></p><p>这是一个维护插件的插件。<strong>Keepass</strong>有着众多的插件，丰富的插件为我们提供了丰富的功能体验。但是这些插件是否有更新，我们无从得知；而<strong>SourceForgeUpdateChecker</strong>正是为了解决这个问题而开发的，它可以帮助我们检测我们所使用的插件是否有更新，以便我们可以及时的更新我们的插件，及时的体验新的功能和修复程序漏洞。</p><p>插件安装完成后，<strong>重启 Keepass</strong>，即可以通过〔帮助〕/〔检查更新〕来查阅各插件是否有更新版本，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600983" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★☆☆☆ KPEntryTemplates</h3><p><a href="https://link.segmentfault.com/?enc=AHMYXXfVbg1hxi60WG6o2w%3D%3D.LvwmaqD%2FBNOAbUh1uFMTZ6BYp55N7Y18sfkeuuLMHoUKntrw6wBMdLtH5OZ5%2FrnYgZutSAhkMHTm1m7osfjt4g%3D%3D" rel="nofollow" target="_blank">KPEntryTemplates.plgx 8.0 🐕度提取码: yrsf</a></p><p>当你在<strong>Keepass</strong>中添加一条密码记录时，默认情况下你应该看到的操作界面如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600984" alt="alt text" title="alt text" loading="lazy"/></p><p><strong>KPEntryTemplates</strong>模板插件可以让我们定义密码记录的录入字段和键入规则，以我们使用起来更加的方便。</p><p>虽然如此，但是在实际使用场景下，该模板的用武之地并不多，大家可以根据自己的需求决定是否添加了。</p><h4>在群组中启用模板功能</h4><p>在数据库的常规组中启用模板功能，操作如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600985" alt="alt text" title="alt text" loading="lazy"/></p><h4>配置 用户名-密码 模板</h4><p><strong>用户名-密码</strong>模板用于记录通过<strong>用户名</strong>+<strong>密码</strong>进行登录的密码记录。操作如下👇：</p><ul><li>选中〔常规〕群组，添加记录，设置标题和默认用户名，设置键入模式：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600986" alt="alt text" title="alt text" loading="lazy"/></li><li>初始化并添加需要的记录字段：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600987" alt="alt text" title="alt text" loading="lazy"/></li><li>于是，我们便得到了一个我们自定义的录入模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600988" alt="alt text" title="alt text" loading="lazy"/></li><li>我们可以在我们新建记录时，使用该模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600989" alt="alt text" title="alt text" loading="lazy"/></li></ul><p>是不是比默认的录入模板要方便好用多了？</p><h5>使用选项</h5><p>实际上，我们的电话和邮箱一般来说都是有限的，也就是说我们常用的手机和邮箱也就那么几个，每次都要手动键入手机号和邮箱号未免麻烦了。<strong>KPEntryTemplates</strong>为我们提供了<strong>ListBox</strong>字段选项，对于〔手机〕和〔邮箱〕字段，我们可以按配置如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600990" alt="alt text" title="alt text" loading="lazy"/></p><p>然后我们创建密码记录时，就可以选择〔手机〕和〔邮箱〕了，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600991" alt="alt text" title="alt text" loading="lazy"/></p><h4>配置 手机-密码 模板</h4><p><strong>手机-密码</strong>模板用于记录那些可以通过手机+密码登记的密码项目。操作如下👇：</p><ul><li>选中〔常规〕群组，添加记录，设置标题和默认用户名，设置键入模式：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600992" alt="alt text" title="alt text" loading="lazy"/></li><li>初始化并添加需要的记录字段：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600993" alt="alt text" title="alt text" loading="lazy"/></li><li>于是，我们便得到了一个我们自定义的另一个录入模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600994" alt="alt text" title="alt text" loading="lazy"/></li><li>我们可以在我们新建记录时，使用该模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600995" alt="alt text" title="alt text" loading="lazy"/></li></ul><h4>配置 邮箱-密码 模板</h4><p><strong>邮箱-密码</strong>模板用于记录那些可以通过邮箱+密码登记的密码项目。操作如下👇：</p><ul><li>选中〔常规〕群组，添加记录，设置标题和默认用户名，设置键入模式：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600996" alt="alt text" title="alt text" loading="lazy"/></li><li>初始化并添加需要的记录字段：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600997" alt="alt text" title="alt text" loading="lazy"/></li><li>于是，我们便得到了一个我们自定义的另一个录入模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600998" alt="alt text" title="alt text" loading="lazy"/></li><li>我们可以在我们新建记录时，使用该模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600999" alt="alt text" title="alt text" loading="lazy"/></li></ul><h4>作为补充</h4><p>各个平台对于密码的要求千奇百怪，我们很难完全预料到所有的记录需求场景；或者如果尽可能的覆盖各种各样的排列组合的话，我们的模板将变得繁多又复杂，所以对于模板的设计，我们应该保持有所克制，抽取必要的，最大化的需求制作模板，而对于小众的，我们通过〔高级〕标签下的〔自定义字串段〕来添加额外的字段及对应值，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601000" alt="alt text" title="alt text" loading="lazy"/>  <br/>或者我们可以通过下文介绍的插件<strong>KPEnhancedEntryView</strong>录入，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601001" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★★ KPEnhancedEntryView</h3><p><a href="https://link.segmentfault.com/?enc=mPuwloJHeuCWsb7lT8IeGQ%3D%3D.qB6eOkvmiXBp1rqJYZe3zqqLR%2Fit7P%2BIQS%2BQSQaf%2BT2NVQ4pX%2FsyEeYSuQshUDOmV8yUff46ucSLC9UhMwYB2g%3D%3D" rel="nofollow" target="_blank">👉KPEnhancedEntryView-v2.7.1.zip 🐕度提取码：2hrw</a></p><p><strong>KPEnhancedEntryView</strong>插件可以使我们更方便的使用<strong>Keepass</strong>，它允许我们👇：</p><ul><li>记录内容分类展示</li><li>在主界面直接编辑修改字段的值</li><li>添加额外的字段</li><li>通过快捷键<strong>F9</strong>在主界面显示/隐藏密码值<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601002" alt="alt text" title="alt text" loading="lazy"/></li></ul><p>为了达到使用<strong>KPEnhancedEntryView</strong>的最佳效果，请在〔工具〕/〔列设置〕中只保留显示〔标题〕和〔用户名〕两个，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601003" alt="alt text" title="alt text" loading="lazy"/></p><p>食用效果如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601004" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★☆ AutoTypeSearch</h3><p><a href="https://link.segmentfault.com/?enc=mSIsNf%2Ffg2bZ4skelAqI%2Fw%3D%3D.RU5fK1NE1rtkxclNicM%2BnXW59pN7LsmR9lx5rAMgxDiQn%2B4SpNI98H6TPBaIn3HHspsDLv8ewfg2utTy1Jz53Q%3D%3D" rel="nofollow" target="_blank">👉AutoTypeSearch-v1.6.zip 🐕度提取码: z5bx</a></p><p>如果<strong>Keepass</strong>未能自动匹配到密码记录，你可以通过本插件定义的快捷键呼出<strong>Keepass</strong>的搜索框，以便搜索你的密码库。</p><p>你可以在〔选项〕中对<strong>AutoTypeSearch</strong>进行有关设置，定义您的快捷键。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601005" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★★ KeePassNatMsg</h3><p><a href="https://link.segmentfault.com/?enc=vZXLJc7IMKOCrEOrydzesw%3D%3D.%2F1RH7lRvFFG4hxWw9EdNRrOd6a6%2BHvOTEMDEs3bX22IxE3Oa9fYmWJLbK4Zwv0jdu0LkN5JxH%2Bf9usDXbIOoAg%3D%3D" rel="nofollow" target="_blank">KeePassNatMsg.plgx v2.0.17 🐕度提取码: p4kk</a></p><p><strong>KeePassNatMsg</strong>是在基于<strong>KeePassHttp</strong>插件的基础上发展而来，实现了一种通过本机消息传递机制（Native Messaging）将<strong>KeePass</strong>的凭据提供给浏览器使用的安全方法。</p><ul><li>安装好<strong>KeePassNatMsg</strong>插件后，即可设置<strong>KeePassNatMsg</strong>的配置项，包括安装浏览器消息机，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601006" alt="alt text" title="alt text" loading="lazy"/>  <br/>👉特别的，如果你使用的是<strong>Vivaldi</strong>浏览器，你应该额外勾选〔<strong>Chromium</strong>〕，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601007" alt="alt text" title="alt text" loading="lazy"/><br/>👉如果顺利，浏览器消息机安装成功应该收到如下的弹窗：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601008" alt="alt text" title="alt text" loading="lazy"/>  <br/>👉意外，如果你收到如下弹窗，说明你的网络无法连接到<strong>gitHub</strong>服务器，你可能需要科学上网：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601009" alt="alt text" title="alt text" loading="lazy"/></li></ul><h3>★★★★★ KeePassXC-Browser</h3><p><a href="https://link.segmentfault.com/?enc=L%2Bh8BRMZByjvWP24BL8nog%3D%3D.o63eJETx4%2FGastwWtzlWFhE5Vc8oX%2BPbe6gRg5SFy8WvHxW0YrxEegvtZb66%2BDObAcetmWnyWhF6I3VzemmZdw%3D%3D" rel="nofollow" target="_blank">keepassxc-browser_1.9.11_chromium.zip 🐕度提取码: rpuy</a></p><p><strong>KeePassXC-Browser</strong>是运行在浏览器中的一个插件，它可以通过<strong>KeePassNatMsg</strong>查询使用<strong>Keepass</strong>中的密码数据。</p><p>👉你可以将<strong>zip</strong>解压后，通过浏览器加载<strong>KeePassXC-Browser</strong>插件，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601010" alt="alt text" title="alt text" loading="lazy"/></p><p>👉你也可以在Google商店中找到并安装<strong>KeePassXC-Browser</strong>插件，将其添加到你的浏览器中，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601011" alt="alt text" title="alt text" loading="lazy"/></p><p>👉插件安装完成后，点击插件图标，即可设置与<strong>Keepass</strong>的连接，在<strong>Edge</strong>浏览器中的设置过程如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601012" alt="alt text" title="alt text" loading="lazy"/>  <br/>在<strong>Vivaldi</strong>浏览器中的设置过程如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601013" alt="alt text" title="alt text" loading="lazy"/></p><p>👉我们可以在浏览器中配置<strong>KeePassXC-Browser</strong>的填充快捷键，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601014" alt="alt text" title="alt text" loading="lazy"/></p><p>👉然后，当你浏览网页时，如果<strong>KeePassXC-Browser</strong>检测到有匹配的密码输入场景时，便会添加<strong>KeePassXC-Browser</strong>标识，只需要鼠标一点就可以自动填充了。如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601015" alt="alt text" title="alt text" loading="lazy"/></p><p>👉相反，如果某一个网页中存存密码输入场景，但是未检索到有效的密码记录时，<strong>KeePassXC-Browser</strong>会显示灰色的图标，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601016" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★☆ WebAutoType</h3><p><a href="https://link.segmentfault.com/?enc=jNcHX8aVkfT0E1m%2B4ZXGCA%3D%3D.3M2qTkaVlvUdB9NX%2B0BWRTPSSWDWtAT6ykHUeWzGdC52LsIL%2FBIM7QIkn0uJ74YXHVK81J3bLvC22OREY5dDUA%3D%3D" rel="nofollow" target="_blank">👉WebAutoType-v6.9.1.zip 🐕度提取码: rssu</a></p><p>这个插件可以让你在网页中唤出<strong>Keepass</strong>的添加记录对话框，它可以自动的帮你填入一些信息，例如<strong>url</strong>，例如标题等，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601017" alt="alt text" title="alt text" loading="lazy"/></p><p>👉你可以为<strong>WebAutoType</strong>设置中意的快捷键，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601018" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★☆ RDCAutoTypeAndTCATO</h3><p><a href="https://link.segmentfault.com/?enc=otU0Wk68h3mvYz9WF5RcIA%3D%3D.RhyBTmCIhiBPGgvcBRn20bqiG1JdlwzQhoBEBaSFguLAHaIww%2F%2BjzXxXtNjVwDpijE0HnVvWEgE07DCo%2B4zspA%3D%3D" rel="nofollow" target="_blank">RDCAutoTypeAndTCATO.plgx 🐕度提取码: a7hg</a></p><p><strong>RDCAutoTypeAndTCATO</strong>可以在不支持钩子的场景下使用，例如对于&lt;font color=red&gt;<strong>QQ</strong>这种。</p><p>安装插件后，我们需要在<strong>RDCAutoTypeAndTCATO</strong>的<strong>ProgramList</strong>中添加<strong>QQ.exe</strong>，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601019" alt="alt text" title="alt text" loading="lazy"/></p><p>然后就可以在<strong>QQ</strong>登录界面顺利的通过<strong>Keepass</strong>填充用户名和密码了。</p><p>💣 注意，由于<strong>RDCAutoTypeAndTCATO</strong>的输入过程不需要通过系统输入法，所以在其输入规则中不需要使用如下的键入规则：  <br/><strong>^{SPACE}{DELAY 100}{CLEARFIELD}{USERNAME}{TAB}{PASSWORD}^{SPACE}</strong></p><p>你需要在通过<strong>RDCAutoTypeAndTCATO</strong>键入的密码条目中，调整输入规则为：  <br/><strong>{CLEARFIELD}{USERNAME}{TAB}{PASSWORD}</strong>  <br/>否则可能会因为键入了多余的字符而导致密码键入错误，登录失败。</p><h3>★★★☆☆ YetAnotherFaviconDownloader</h3><p><a href="https://link.segmentfault.com/?enc=qa7S03uTExGbEo%2B0%2BneMpw%3D%3D.ujszdPxbCPmHDOw79FA1XwOuni2ubQZIbZ%2Bg4J1NYEHQdg56lg9UNc2juCu6hH7S7YMxlYowFlT%2F0efng1eulA%3D%3D" rel="nofollow" target="_blank">👉YetAnotherFaviconDownloader.plgx v1.2.5.0 🐕度提取码: memu</a></p><p>这个插件提供的是一个锦上添花的功能，它可以帮助我们🈯批量的把密码记录项的图标设置为对应<strong>url</strong>网站的<strong>Favicon</strong>图标，从而美华我们的密码记录项。</p><p>插件安装后，你可以进行一些必要的设置，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601020" alt="alt text" title="alt text" loading="lazy"/></p><p>然后选中你要更新图标的密码记录条目，右键，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601021" alt="alt text" title="alt text" loading="lazy"/></p><h2>小结</h2><p>以上便是本次安装配置<strong>Keepass v2.60</strong>的整个过程，欢迎交流讨论。</p>]]></description></item><item>    <title><![CDATA[Qnap威联通Qu405的入手配置手记 三块钱 ]]></title>    <link>https://segmentfault.com/a/1190000047601115</link>    <guid>https://segmentfault.com/a/1190000047601115</guid>    <pubDate>2026-02-09 13:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>我的硬件</h2><h3>NAS型号</h3><p>威联通 Qu405 四盘位</p><h3>硬盘 HDD/SSD</h3><ul><li>WD40EFZZ 西数红盘 4T 2块</li><li>PM863a SSD 960G 2块</li></ul><h3>UPS电源</h3><p>cyberpower UT650EGC</p><h2>硬件组装</h2><p>根据收到的NAS所带的说明书，将你的硬盘和SSD安装到你的NAS中。</p><p>完成组装后，用网线将你的NAS与路由连接。</p><h3>连接UPS，启动NAS</h3><ul><li>将UPS电脑接入市电插座</li><li>将NAS电脑接入UPS的输出端插孔位置</li><li>使用UPS自带的USB数据线连接UPS和NAS</li><li>根据UPS说明书的操作说明，启动UPS电源</li><li>根据NAS说明书的操作说明，启动NAS。</li><li>等待一段时间，NAS上线</li></ul><h2>系统设置</h2><h3>找到NAS</h3><p>NAS第一次上电后，一般会通过路由器自动分配一个IP地址联网，此时要想登录NAS的界面，你需要使用Qnap提供的软件 <strong>Qfinder</strong>，您可以在<a href="https://link.segmentfault.com/?enc=R4%2BfBfpBxp3%2FJ0uEAXVHcA%3D%3D.EkxarI9oyhYtPkoITY8yg6HVGggjpMrOwtrFLa5vxrjQ9PDucFVS21RBlDsHMwl%2B" rel="nofollow" target="_blank">这里下载安装👇</a>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601118" alt="alt text" title="alt text"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601119" alt="alt text" title="alt text" loading="lazy"/>  <br/>打开<strong>Qfinder</strong>后，它可以自动搜索你当前局域网下的Qnap设备，找到您的NAS，即可登入，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601120" alt="alt text" title="alt text" loading="lazy"/></p><p>第一次登录NAS时，一般系统会引导你完成一些必要的系统设置，例如对于Qu405来说，会引导你选择安装QTS系统或者是QuTS系统，我选择的是QTS系统。</p><h2>UPS联动</h2><p>当我们找到我们的NAS，并进入NAS界面后，我们前往〔控制台〕/〔系统〕/〔外部设置〕/〔UPS〕，完成USP联动设置，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601121" alt="alt text" title="alt text" loading="lazy"/></p><h2>设置存储池和存储卷</h2><h3>创建Qtier存储池</h3><p>Qtier技术是Qnap独创的冷热数据分层存储融合技术，最大化的充分利用了SSD和HDD硬盘的效率。它可以将高频访问的热数据存储在SSD区，将不常访问的冷数据放在HDD存储区。相对于SSD缓存来说，Qtier技术可以将SSD的空间纳入到存储池中，避免了SSD空间的浪费。更为详细的关于SSD缓存方案和Qtier方案的对比分析，参考<a href="https://link.segmentfault.com/?enc=l%2FB3ke7fsc%2BVVBgDMWhtqQ%3D%3D.RCnItvXxvP1gD0tbGoLEcsbxf%2B%2BTxZvo5za1%2FAhZSTDJAdOI39Ws%2FchhyJ0x%2BOA6zTT876mfNAytJkslY6slYVSof1QAkmbO9JE0%2FQIFqHdkWExAIKjtwphKyCCcf2lb" rel="nofollow" target="_blank">Qnap官网的说明</a>。</p><p>就我本次的配置来说，将两块SSD配置为超高速层，组RAID1阵列，并保留了25％的容量空间；将两块HDD硬盘组RAID1阵列，做为容量层，保留20%的快照空间；报警阈值设置为90％。配置完成如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601122" alt="alt text" title="alt text" loading="lazy"/></p><h3>创建App精简卷〔系统卷〕</h3><p>首先创建的卷，会被系统自动识别为系统卷，将来NAS安装的应用，会默认安装于此卷。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601123" alt="alt text" title="alt text" loading="lazy"/></p><p>在Qtier存储池上，创建一个容量为200G的精简卷（后期根据需要可以增加），该卷主要用于供系统使用，用于安装应用程序，不要在这里存放用户的数据。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601124" alt="alt text" title="alt text" loading="lazy"/></p><h3>创建Data精简卷</h3><p>在Qtier存储池上，创建一个容量为1T的精简卷（后期根据需要可以增加），该卷主要用于存放各种资料数据，相当于用户的云空间。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601125" alt="alt text" title="alt text" loading="lazy"/></p><h3>创建Home精简卷</h3><p>在Qtier存储池上，创建一个容量为100G的精简卷（后期根据需要可以增加），该卷主要用于存放各用户的Home目录，主要目的是为用户提供一个临时的云端空间，以供临时性的转移文件使用，这个卷不启用快照功能。</p><p>👆以上Qtier存储池和三个存储卷设置完成后，效果如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601126" alt="alt text" title="alt text" loading="lazy"/></p><h2>快照计划</h2><p>完成卷设置后，为需要的卷配置合理的快照计划，可以有效的保障数据安全（必要时回滚，&lt;font color=gray&gt;一个具体的例子是，如果你本地的文件被病毒破坏了，而你的同步工具又将已经被破坏了的文件同步到了NAS上，此时如何恢复这个文件呢？就只能通过快照来恢复了&lt;/font&gt;）。选中需要配置快照的卷，然后点〔快照〕/〔快照管理员〕，即可对该卷的快照计划进行配置。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601127" alt="alt text" title="alt text" loading="lazy"/></p><h3>App卷快照计划</h3><p>App卷主要用于安装系统应用程序，为了防止在折腾过程中把系统玩崩，所以有必要启用快照功能。一般来说，在折腾NAS应用时，最好的习惯就是手动创建快照，然后再折腾。不过快照计划也为手残党提供了最后的兜底保障。考虑到一般会在周未折腾NAS，所以在每周折腾完成后，在周一的凌晨创建一次快照即可（保存折腾的成果）。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601128" alt="alt text" title="alt text" loading="lazy"/></p><h3>Data卷快照计划</h3><p>数据算是NAS使用的主要目的了，所以数据卷的快照是有必要的，所以我们为数据卷的快照设置每天1个，保留7天.如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601129" alt="alt text" title="alt text" loading="lazy"/></p><h3>Home卷快照计划</h3><p>根据以上分析，我们不为Home卷起用快照，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601130" alt="alt text" title="alt text" loading="lazy"/></p><h3>设置用户家目录</h3><p>如上， 我们为用户家目录单独创建了Home卷，现在我们统一设置用户家目录配置到Home卷，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601131" alt="alt text" title="alt text" loading="lazy"/></p><h2>外网访问</h2><p>网络是NAS的基础，否则您只能在您家的局域网内使用NAS，这无异于龙游浅池。</p><p>如果你想在公网访问你的Qnap设备，你首先需要有一个公网IP，你可以向你的电信运营商申请要求给你分配一个公网IP，一般来说，这个IP是隔段时间变化的，但是这不要紧。</p><p>有了公网IP的前提后，Qnap提供了免费的DDNS服务，你只需要以下设置，便可以在公网环境使用你的NAS设备。</p><ul><li>找到NAS上的网络设置  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601132" alt="alt text" title="alt text" loading="lazy"/></li><li>找到设定，设置静态IP，为你的Qnap设备设置一个静态IP，记住这个IP，后面要用  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601133" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601134" alt="alt text" title="alt text" loading="lazy"/></li><li>设置系统访问端口，和服务器名称，记住这个端口号和名称，后面要用  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601135" alt="alt text" title="alt text" loading="lazy"/></li><li>设置路由器的端口转发规则，设置你的路由器，将来自外部的请求转发给你的Qnap设备。这里的局域网IP就是你的NAS上设置的静态IP，这里的内部端口就是你NAS上设置的系统访问端口参考上文  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601136" alt="alt text" title="alt text" loading="lazy"/></li><li>设置myQNAPcloud云服务，使用Qnap提供的DDNs功能，解析你的公网IP  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601137" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601138" alt="alt text" title="alt text" loading="lazy"/>  <br/>DDNs开通后，会生成一个免费的二级域名，样式如： www.服务器名称.mycloudnas.com，将来你可以通过该域名来访问你的Qnap设备。</li><li>完成以上设置后，便可以测试你的DDNs是否连通了。在DDNS设置页面的底部，点击【测试连接性】，观测域名是否能成功连接到Qnap设备。👇如下可以看到系统访问端口可以连通到Qnap了。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601139" alt="alt text" title="alt text" loading="lazy"/></li><li>做为测试，你可以将你的手机切换为非wifi模式，输入您的DDNS域名和端口号，便可以打开NAS页面（由于一些原因，在大陆使用Qnap的域名解析连接性不佳，有条件的还是建议自建DDNs服务）  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601140" alt="alt text" title="alt text" loading="lazy"/></li></ul><p>🚩 如果你无法打开NAS页面，或者收到 〔ERR_NAME_NOT_RESOLVED〕，那是因为你的网络环境无法连接到Qnap的DDNS服务器所致，原因嘛，大家都懂得。</p><h2>自建DDNS解析脚本</h2><p>除了上述通过Qnap二级域名实现外网访问外，我们还可以自己申请一级域名（一些冷门域名很便宜的，一次性买10年也不过百元级），然后我们在NAS上通过ddns-go脚本将我们的NAS的公网IP（实际应该是你的路由器的IP地址）更新到域名上，这样我们就可以通过我们自己的域名自由访问我们的NAS了。</p><p>ddns-go是一个运行于Docker里的镜像容器，我一直在使用不低于2年时间，稳定性是非常棒的。</p><h3>准备域名</h3><p>我是在阿里云上申请的域名。自己用嘛，不求闻达于诸侯，所以越便宜越好，能解析是唯一的要求。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601141" alt="alt text" title="alt text" loading="lazy"/></p><p>我使用的是免费套餐，在国内全胜基本没有遇到无法解析的情况，也可以根据自己的实际使用需求，开通付费套餐。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601142" alt="alt text" title="alt text" loading="lazy"/></p><h3>安装ContainerStation</h3><p>ContainerStation是Qnap NAS中运行Docker的平台，你可以在NAS中的AppCenter中找到并安装它。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601143" alt="alt text" title="alt text" loading="lazy"/></p><p>等ContainerStation安装完成后，我们便可以在里面运行我们需要的镜像包了。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601144" alt="alt text" title="alt text" loading="lazy"/></p><p>由于DockerHub在国内的访问性不佳，所以推荐在ContainerStation中添加阿里云Docker镜像地址，以提高Docker镜像的拉取速度。打开<a href="https://link.segmentfault.com/?enc=gj70VGIzk5WF2OcmFKlxog%3D%3D.GdEeokxGBl6UWYs5o2FQkYpQWKaXImEmoHZHpI7iqMk%3D" rel="nofollow" target="_blank">容器镜像服务</a>(需要登录你的账号，每个账号的镜像地址都是不一样的)，在👈左侧找到〔镜像工具〕/〔镜像加速器〕，复制加速器地址备用。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601145" alt="alt text" title="alt text" loading="lazy"/></p><p>然后打开ContainerStation，找到〔存储库〕，然后〔添加〕  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601146" alt="alt text" title="alt text" loading="lazy"/></p><h3>使用jeessy/ddns-go进行DDNS动态解析</h3><p>本人使用jeessy/ddns-go进行DDNS解析，ddns-go是一个开源在dockerHub上的docker镜像，大家可以在ContainerStation中从dockerHub提取该镜像，也可以在电脑上下载  <br/><a href="https://link.segmentfault.com/?enc=rL00ez6IGAAKsGM9Ts8E1Q%3D%3D.Ghy9Xetw49xvEixqeeNN5n%2FJ1s3BwE9Py%2BisUlijHqXy6EjxZd4OOLDCS7X17QfTvgXB8Q8d9xG%2FVzFmz6RsIw%3D%3D" rel="nofollow" target="_blank">👉ddns-go镜像文件（amd64 CPU）</a>  <br/><a href="https://link.segmentfault.com/?enc=8hlJYGBKUiXuX2YlZR4E9w%3D%3D.5wx4sA%2FKfW3JxnIKQPdrf8DzwGc9EhdEyrjTDObwHYg%2FxDtHkRyWw9KHSK%2FFQeMjmPX2bVgTF0PURNT7ujWzow%3D%3D" rel="nofollow" target="_blank">👉ddns-go镜像文件（arm CPU）</a>  <br/>然后导入到ContainerStation中使用。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601147" alt="alt text" title="alt text" loading="lazy"/></p><h4>生成容器</h4><p>ddns-go的镜像，相当于是可以运行的一个exe文件，我们现在需要把这个exe文件〔其实是docker镜像〕运行起来，就是说需要创建一个让镜像跑起来的容器。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601148" alt="alt text" title="alt text" loading="lazy"/></p><p>等待容器创建完成  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601149" alt="alt text" title="alt text" loading="lazy"/></p><p>在容器页面就可以看到已经在运行的ddns-go了  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601150" alt="alt text" title="alt text" loading="lazy"/></p><p>🚩 如果容器运行出现 exec /app/ddns-go: exec format error 这种错误，说明ddns-go与Qnap设备的CPU架构不兼容，你需要换一下ddns-go镜像。</p><h4>设置ddns-go参数</h4><p>在局域网环境下，在浏览器中打开你的NAS IP地址 + 端口号 9876（例如192.168.1.43:9876）, 就可以对ddns-go进行参数设置了：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601151" alt="alt text" title="alt text" loading="lazy"/></p><p>登录后，可以看到参数设置页面  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601152" alt="alt text" title="alt text" loading="lazy"/></p><p>👆上图中，点击〔创建 AccessKey〕即可跳转到对应dns服务商的AccessKey创建页面（可能需要登录），根据引导完成AccessKey创建后，将AccessKey ID和AccessKey Secret填回到本页面中  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601153" alt="alt text" title="alt text" loading="lazy"/></p><p>在IPV4设置一栏，把你申请到的域名填写到Domains中，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601154" alt="alt text" title="alt text" loading="lazy"/></p><p>翻到最下面，如果你有Webhook通道（例如可能在飞书中添加消息机器人，开通Webhook连接），那么你可以在这里设置Webhook通知，当IP变化时，通过Webhook向你发送通知消息。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601155" alt="alt text" title="alt text" loading="lazy"/></p><p>对于飞书机器人，我用的RequestBody设置如下👇</p><pre><code class="json">{
    "msg_type": "post",
    "content": {
        "post": {
            "zh_cn": {
                "title": "Hi，你的公网IP变了",
                "content": [
                    [
                        {
                            "tag": "text",
                            "text": "IPv4地址：#{ipv4Addr}"
                        }
                    ],
                    [
                        {
                            "tag": "text",
                            "text": "域名更新结果：#{ipv4Result}"
                        }
                    ]
                ]
            }
        }
    }
}</code></pre><p>飞书上收到的消息如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601156" alt="alt text" title="alt text" loading="lazy"/></p><p>以上设置完成后，您的ddns应该已经可以正常解析更新了，在容器界面，选中ddns-go容器，观察其日志小黑窗口，应该有如下消息出现👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601157" alt="alt text" title="alt text" loading="lazy"/></p><p>至此，你可以通过以上设置，配合你的路由器的端口转发，你便可以通过域名：端口访问你的NAS设备了。你如你可以通过 www.zhsan.xyz:1234 访问到你的NAS。</p><h2>无密码登录</h2><p>你需要在移动端下载并安装APP &lt;font color=Green&gt;QNAP Authenticator&lt;/font&gt;，你可以在<a href="https://link.segmentfault.com/?enc=01IgCH8%2B5LS9lg%2F%2Banco3Q%3D%3D.9PggXIrWVkkQhzCVAvwUFU%2BUEz3wkUTmTPl2woXCCFu%2FtMx2%2F30g5wfXPL8fGmIk0rIIpo6%2B2T5umlSci1wKTQ%3D%3D" rel="nofollow" target="_blank">Qnap官网</a>下载到该APP：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601158" alt="alt text" title="alt text" loading="lazy"/>  <br/>然后在您的NAS界面，找到〔登录和安全性〕，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601159" alt="alt text" title="alt text" loading="lazy"/>  <br/>根据引导设置无密码登录〔或者使用两步验证〕，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601160" alt="alt text" title="alt text" loading="lazy"/>  <br/>设置成功后，您将看到你的受权的设备如下👇<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601161" alt="alt text" title="alt text" loading="lazy"/>  <br/>🚩 在设置〔二次验证〕或者是〔无密码登录〕时，将有两个验证方式，一种是本地验证，一种是云端验证；</p><ul><li>〔本地验证〕是指在你的局域网中寻找识别NAS设备进行验证，这种验证方式只能当你的移动设备和NAS处于同一局域网时可用使用。</li><li><p>〔云端验证〕是指通过登录Qnap ID账号，从你的Qnap ID账号认证的设备列表中寻找识别NAS设备进行验证，这种验证方式不受局域网环境限制。但是这种验证方式需要具备以下条件：</p><ul><li>你的设备已经在Qnap ID中注册</li><li>你的NAS开通了DDNS服务，这将使得Qnap服务器可以找到并连接你的NAS设备</li></ul></li></ul><h2>HTTPS安全访问</h2><p>如果你需要在外网访问你的NAS设备，Https加密通信就是必要的。当你在外网访问你的NAS设备时，就像你在用手机和你的NAS设备通电话。</p><ul><li>如果你们使用http访问NAS，就像是你们的通话是明文通话，如果有坏人监听了你们的通话，那么他就知道你们说了什么，一旦让他监听到了你的NAS的用户名和密码，那他就可以通过这个用户名和密码登录到你的NAS，这与家里进了贼没有什么区别。</li><li>如果你们全胜https访问NAS，就像是你们的通话是用经过加密的暗语，你们的通话内容除了你们自己能懂之外，即使是被坏人监听到了，它也无法理解你们的通话内容，也就不会泄露秘密。</li></ul><p>为了全胜https通信，我们需要为https配置SSL证书，这个SSL证书的作用就是负责给https通信的内容进行加密。</p><h3>申请SSL证书</h3><p>一般来说，SSL证书需要付费（年付）使用，但是我们也可以获取到免费的测试用的SSL证书，这些免费的SSL证书的加密效果与付费的SSL证书的加密效果是一样的。</p><p>阿里云和腾讯云都提供限时免费的SSL证书以供测试使用，我的域名是在阿里云进行的解析，所以此处以阿里云的SSL证书申请为例来进行说明。</p><ul><li>登录<a href="https://link.segmentfault.com/?enc=GK42ZZL4Il%2FhmAejHtQc8A%3D%3D.OWQfGyOF8KcaYhgtP58zlIpr%2BtJ9c3xRxnMkld6arLXcZ8q%2FvgdZDLuFLnHXFlsFVaaorPM7dSdhFUocUcitfVx%2B6QMkzY4woIf8cHIN%2FLRApppOc3W7zJHqqgKuAEuZ" rel="nofollow" target="_blank">阿里云平台</a>，搜索 〔数字证书管理服务〕，然后〔登录控制台〕，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601162" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601163" alt="alt text" title="alt text" loading="lazy"/></li><li>购买免费SSL证书名额（每个账户每年有一次购买机会，一次买20个证书名额，一个名额用90天），如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601164" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601165" alt="alt text" title="alt text" loading="lazy"/></li><li>创建SSL并提交申请，根据下图填写必要的信息后，提交审核，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601166" alt="alt text" title="alt text" loading="lazy"/></li><li>验证域名，当你提交了SSL申请后，我们在SSL证书管理页面就可以看到我们提交SSL申请的记录了，此时我们需要验证一下我们的域名是否OK， 点击SSL申请记录右侧的〔验证〕按钮，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601167" alt="alt text" title="alt text" loading="lazy"/></li><li>在弹出的证书申请页中，我们找到第三步，点击〔验证〕按钮，等待验证完成后，显示“域名验证成功。。。。。”信息，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601168" alt="alt text" title="alt text" loading="lazy"/></li><li>等待SSL签发。做完以上步骤后，我们只需要等待域名签发就可以了，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601169" alt="alt text" title="alt text" loading="lazy"/></li><li>下载SSL证书，解压后备用，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601170" alt="alt text" title="alt text" loading="lazy"/></li></ul><h3>安装SSL证书</h3><p>我们申请到了SSL证书后，我们就需要将它安装到我们的NAS中，才能使用https访问我们的NAS。我们回到NAS页面，操作如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601171" alt="alt text" title="alt text" loading="lazy"/></p><p>然后等待证书导入完成即可，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601172" alt="alt text" title="alt text" loading="lazy"/></p><p>🚩<strong>注意，我们申请的SSL证书只有90天有效，过期后我们需要重新通过以上步骤申请新的SSL证书并导入。或者可以付费申请期限为1年的SSL证书，这样就可以自动延期了。</strong></p><h3>启用HTTPS访问</h3><p>以上工作完成后，我们便可以为我们的NAS启用HTTPS服务了。我们把https的端口号设置为12345（此处为举例），设置如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601173" alt="alt text" title="alt text" loading="lazy"/></p><h3>调整路由器端口映射</h3><p>在上图中，我们可以看到我们的NAS的系统端口有两个，一个是1234， 一个是1235。</p><ul><li>其中1235是https服务端口，这个端口的通信是加密的，是安全的。我们可以把这个端口曝露在公网上使用，我们在公网环境下，可以通过 <a href="https://link.segmentfault.com/?enc=BRyT4kktbp6pCFR%2BE6YVmg%3D%3D.NACV%2B4O70Ozijhf%2BaPeyNoQYzZilq18O%2BdJ9jC1QflE%3D" rel="nofollow" target="_blank">https://www.zhangsan.xyz:1235</a> 来以https方式访问我们的NAS。</li><li>其中1234是http服务端口，这个端口的通假是没有加密的，是不安全的。所以我们不能把这个端口曝露在公网上，这个端口只可以在局域网环境下访问NAS。</li></ul><p>综合以上，我们需要在我们的路由口中调整端口映射规则，只把端口1235映射曝露到公网上，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601174" alt="alt text" title="alt text" loading="lazy"/></p><h2>关于公网安全</h2><ul><li><h3>公网端口</h3></li></ul><p>默认的NAS端口一般是5000,或者5001,这也是黑客重点扫描的NAS端口，建议大家在设置外网端口时，避开这两个端口。</p><ul><li><h3>Telnet/SSH</h3></li></ul><p>这两个功能，不要曝露在公网，如果不使用，也不要打开，如果要用，用完记得关闭<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601175" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>禁用admin账户</h3></li></ul><p>不要使用（禁用）NAS默认的管理员账户，这个一般NAS系统是默认禁用的<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601176" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>开启登录两步验证</h3></li></ul><p>进一步提高NAS页面的登录安全性  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601177" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>关闭UPnp服务</h3></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601178" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>关闭Bonjour服务</h3></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601179" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>启用IP防护</h3></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601180" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>启用账户防护</h3></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601181" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h4>关闭IPV6</h4></li></ul><p>如果你有了IPV4的公网IP，则通过IPV4即可访问NAS，此时关闭IPV6有助于提高NAS的安全性，尤其避免在域名解析中解析IPV6<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601182" alt="alt text" title="alt text" loading="lazy"/></p><h2>Qsync文件同步</h2><p>Qnap提供的Qsync文件同步技术，是一个非常好用，也总是被忽略的技术。尤其是Qsync提供的节省空间模式，让用户可以在存储空间较小的电脑上，也能处理NAS上的海量文档。</p><h3>NAS安装Qsync</h3><p>为了使用Qsync功能，我们需要在NAS上安装Qync服务端，我们在AppCenter中寻找并安装Qsync，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601183" alt="alt text" title="alt text" loading="lazy"/></p><p>Qsync安装完成后，我们可以打开Qsync，为共享文件夹授予使用权限，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601184" alt="alt text" title="alt text" loading="lazy"/></p><h3>电脑端安装Qsync</h3><p>在你需要同步文件的电脑上，也需要安装Qsync客户端，这样Qsync就可以帮我们同步电脑-NAS两端的文件了。你可以<a href="https://link.segmentfault.com/?enc=J8Qzi8ZxjC5jCkIHcv64BQ%3D%3D.CwWO%2FFBVeB2Ac%2BqgL8j%2Bb77pa5okD7vxUUi%2FUsC9FxpNJB5YIaO90Lt5rIAzj%2Fpd39aq8jtuDAKjjRQW%2BNP4qw%3D%3D" rel="nofollow" target="_blank">👉在这里下载到Qsync</a>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601185" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601186" alt="alt text" title="alt text" loading="lazy"/></p><p>Qsync下载安装完成后，你可以在Qsync中配置文件夹同步任务，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601187" alt="alt text" title="alt text" loading="lazy"/>  <br/>然后选择同步任务👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601188" alt="alt text" title="alt text" loading="lazy"/>  <br/>然后填写NAS的登录信息，以便Qsync可以知道你要同哪个NAS上同步数据，👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601189" alt="alt text" title="alt text" loading="lazy"/>  <br/>然后，你就可以添加同步的双方文件夹了，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601190" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601191" alt="alt text" title="alt text" loading="lazy"/></p><p>🚩 <strong>关于〔节省空间模式〕，最值得称道的一点，就是它不会让我们在本地编辑文档的时候，被因Qsync的同步功能而锁定文档，导致我们编辑的文档无法保存。然而，这在一些其它技术不用心的网盘工具中，是经常发生的，这导致用户的编辑经常无法保存而丢失。大家在选择网盘工具和同步工具时，需要特别注意这一点</strong></p><p>通过Qsync同步文档，在文档的图标上会有所区别。👇如下图所示，&lt;font color=red&gt;<strong>1</strong>&lt;/font&gt;号位置的文档没有云朵图标，说明这个文档是在本地的；&lt;font color=red&gt;<strong>2</strong>&lt;/font&gt;号位置的文档有云朵图标，说明这个文档是在云端的，它在本地不占用空间，当你打开他时，或者移动它时，Qsync会感知到你的操作，会自动从NAS上把文档同步到本地，以供你使用。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601192" alt="alt text" title="alt text" loading="lazy"/></p><h3>公网下连接Qsync</h3><p>如果你的电脑处于公网环境下，请按以下操作切换<strong>Qsync</strong>的连接方式，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601193" alt="alt text" title="alt text" loading="lazy"/></p><h2>使用Qfile Pro</h2><p><strong>Qfile</strong>是Qnap开发的移动端使用的NAS文件同步工具，我们上文中介绍了<strong>Qsync</strong>，<strong>Qsync</strong>这个工具也有移去版本的app，功能与电脑版本的完全一致。但是在移去端，我更喜欢全胜<strong>Qfile</strong>连接NAS，<strong>Qfile</strong>集成了<strong>Qsync</strong>的文件同步功能的同时，我觉得更吸引我的点在于，<strong>Qfile</strong>不会把<strong>NAS</strong>上的文档同步到本地，这恰好避免了<strong>NAS</strong>上的海量文档对手机浏览功能的污染（例如<strong>NAS</strong>上的图片会污染手机想册的浏览体验）。</p><h3>下载Qfile Pro</h3><p>Qnap官网提供了<strong>Qfile Pro</strong>的下载链接，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601194" alt="alt text" title="alt text" loading="lazy"/></p><p>下载对应的版本，完成<strong>Qfile Pro</strong>的安装。</p><h3>局域网下连接NAS</h3><p>我们完成<strong>Qfile</strong>的安装后，我们首先在局域网下进行<strong>Qfile</strong>与<strong>NAS</strong>的链接。具体操作如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601195" alt="alt text" title="alt text" loading="lazy"/></p><ul><li>👉其中第&lt;font color=red&gt;<strong>15</strong>&lt;/font&gt;步，可以根据情况选择〔邮件认证〕或者是〔输入密码〕。</li><li>👉另外需要注意第&lt;font color=red&gt;<strong>11</strong>&lt;/font&gt;步，打开〔检测可用的连接方法〕。</li></ul><h3>外网环境下连接NAS</h3><p>我们希望在外网环境下也可以在手机上查阅NAS上的资料，但这需要我们的路由器为我们打开NAS的连接端口（这在〔<strong>HTTPS安全访问</strong>〕一章中已经有所说明）。</p><p>我们关闭wifi，使手机处于4G网络状态下进行操作，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601196" alt="alt text" title="alt text" loading="lazy"/>  <br/>继续操作如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601197" alt="alt text" title="alt text" loading="lazy"/></p><p>以上操作完成后，我们就可以在外网环境下连接我们的NAS了。随时随地可以访问NAS，这才能发挥NAS最大的价值。</p><h3>内外网自适应</h3><p>当我们完成以上的操作后，我们的<strong>Qfile</strong>可以在外网环境下连接家里的NAS，但是它不能根据我们所处的网络环境（内网 or 外网）自动切换连接方式，这导致我们手机的网络环境切换后，<strong>Qfile</strong>就无法连接NAS，需要我们每次手动切换连接方式。要想让<strong>Qfile</strong>可以自动根据网络环境切换连接方式，请完成以下操作👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601198" alt="alt text" title="alt text" loading="lazy"/></p><p>完成以上操作后，<strong>Qfile</strong>便可以根据我们的设备所处的网络环境自适应调整连接方式了。</p><p>关于<strong>Qfile</strong>的其它使用方式，这是非常丰富的，各位自行摸索吧。</p>]]></description></item><item>    <title><![CDATA[亲测有效：Windows上使用 Claude Code 超详细安装指南 程序员小崔日记 ]]></title>    <link>https://segmentfault.com/a/1190000047601286</link>    <guid>https://segmentfault.com/a/1190000047601286</guid>    <pubDate>2026-02-09 12:06:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>亲测有效：Windows上使用 Claude Code 超详细安装指南</h2><p>这篇文章将手把手带你完成 Claude Code 在 Windows 下的完整安装与配置，帮助你一次成功。</p><hr/><h3>一、为什么推荐 Claude Code？</h3><p>如果你还没接触过 Claude Code，可以简单理解为：</p><blockquote><strong>Claude Code = Anthropic 官方出品的 AI 代码助手 CLI</strong></blockquote><p>它的优势在于：</p><ul><li>原生 CLI，适合真实项目开发</li><li>强大的代码理解与修改能力</li><li>对大型代码仓库友好</li><li>能直接参与调试、重构、解释代码</li></ul><p>对于后端、全栈，以及偏工程化的开发者，体验明显优于很多只停留在“聊天”的 AI 工具。</p><hr/><h3>二、准备工作：Kimi（Moonshot）服务配置</h3><p>由于国内网络环境限制，本文采用 Moonshot（Kimi）提供的 Anthropic 兼容接口。</p><h4>1️⃣ 获取 Moonshot API Key</h4><p>前往 Moonshot 官方控制台创建 API Key：</p><ul><li>地址：Moonshot AI 开放平台</li><li>新建 Key 后 <strong>一定要立即复制保存</strong></li><li>API Key 无法二次查看</li></ul><p>切记：创建后马上保存，否则只能重新生成</p><hr/><h4>2️⃣ 配置环境变量</h4><p>在 Windows 系统环境变量中新增：</p><pre><code class="text">ANTHROPIC_API_KEY
你的 Moonshot API Key</code></pre><pre><code class="text">ANTHROPIC_BASE_URL
https://api.moonshot.cn/anthropic/</code></pre><p>配置完成后重启终端，确保生效。</p><hr/><h3>三、Claude Code 安装前的必备条件</h3><p>在开始安装前，请确保你的系统满足以下要求：</p><ul><li>Windows 10（2004+）或 Windows 11</li><li>管理员权限</li><li>已安装 Git</li><li>Node.js 18+（推荐 LTS）</li><li>稳定网络环境</li></ul><hr/><h4>1️⃣ 安装 Git</h4><p>下载地址：<a href="https://link.segmentfault.com/?enc=ViUpdpU7HLr6FWddCkqqmQ%3D%3D.pRDfr8%2BzHuyBpWIREcKQJaxefQTutNOyYTMRmLpW79w%3D" rel="nofollow" target="_blank">https://git-scm.com/downloads</a>  </p><p>按默认步骤安装即可。</p><p>安装完成后，<strong>额外配置一个环境变量（非常关键）</strong>：</p><pre><code class="text">CLAUDE_CODE_GIT_BASH_PATH
D:\Program Files\Git\bin\bash.exe</code></pre><p>路径根据你自己的 Git 安装位置调整。</p><p>验证是否成功：</p><pre><code class="bash">git --version</code></pre><p>看到版本号即说明 Git 安装成功。</p><hr/><h4>2️⃣ 安装 Node.js</h4><p>下载地址：<a href="https://link.segmentfault.com/?enc=9Y3HqBALfSWYCieJt5DQNw%3D%3D.GREYn5VjzVt61DhnAOAD9Wv9wZgTPegYewgx%2FYHpvwg%3D" rel="nofollow" target="_blank">https://nodejs.org</a>  </p><p>安装 Node.js 18 及以上版本。</p><p>验证安装：</p><pre><code class="bash">node -v
npm -v</code></pre><hr/><h3>四、安装 Claude Code</h3><h4>1️⃣ 使用 npm 全局安装</h4><p>打开 CMD 或 Windows Terminal：</p><pre><code class="bash">npm install -g @anthropic-ai/claude-code</code></pre><p>安装完成后验证：</p><pre><code class="bash">claude --version</code></pre><p>能看到版本号说明安装成功。</p><hr/><h3>五、网络代理：很多人卡在这里</h3><p><strong>重点提醒：国内网络环境下，不开代理基本无法登录</strong></p><h3>六、启动 Claude Code</h3><h4>1️⃣ 在项目目录启动（强烈推荐）</h4><pre><code class="bash">cd 你的项目目录
claude</code></pre><p>Claude Code 启动后会：</p><ul><li>让你选择主题配色</li><li>显示安全提示</li></ul><p>安全提示的核心意思只有一句话：</p><blockquote><strong>AI 可能会犯错，运行代码前一定要自己检查</strong></blockquote><p>直接回车即可。</p><hr/><h4>2️⃣ 登录方式选择</h4><p>Claude Code 提供三种计费方式</p><p>选择 <strong>Anthropic 控制平台（推荐）</strong>，会自动跳转到浏览器。</p><hr/><h4>3️⃣ Google 账号登录</h4><ul><li>需要一个 Google 账号（Gmail）</li><li>登录后授权</li><li>复制一段 Code 回到终端</li></ul><p>如果没有 Google 账号，可以自行注册，或购买一个（价格通常 5–10 元）。</p><hr/><h4>4️⃣ 登录选择</h4><p>回到CMD会提醒你选择官方还是环境变量 API KEY,选择后者。</p><hr/><h4>5️⃣ 提示</h4><ul><li>完成上述步骤后，在vscode或idea中安装 Claude Code插件,直接就可以使用。</li></ul><p><img referrerpolicy="no-referrer" src="https://files.mdnice.com/user/170228/b27c028f-0fa1-442a-b817-b520e54bd88d.png" alt="" title=""/></p><hr/><h3>七、总结</h3><p>如果你是 Windows 开发者，这次 Claude Code 的体验可以说是一次明显升级，<br/>只要按本文步骤配置，<strong>10 分钟内即可上手 Claude Code</strong>，真正把 AI 变成你的“项目搭档”。</p><p><strong>PS：</strong><br/>安装过程中如果遇到任何问题，欢迎在评论区留言，或者私信我一起交流～<br/>如果这篇文章对你有帮助，记得点个赞 + 关注支持一下。</p><p>后续我会使用 Claude Code 插件，实战升级黑马程序员的 「苍穹外卖」项目，感兴趣的朋友可以持续关注，一手更新。</p><p>另外，火影忍者低分段超，想切磋的可以私信我，随时开打。</p><p>本文由<a href="https://link.segmentfault.com/?enc=6Nc71ebvqTM6KaYSoXqhuw%3D%3D.6ewV9frR%2F1PgGlSdVrW5aQkKzDlnDZW8lEWqjdyYRXU%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[Facebook 广告封禁无解？深度解析及方案建议 跨境百科 ]]></title>    <link>https://segmentfault.com/a/1190000047601302</link>    <guid>https://segmentfault.com/a/1190000047601302</guid>    <pubDate>2026-02-09 12:05:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在当前数字营销环境中，社交媒体平台的合规审核机制日益完善，网络环境的安全性与稳定性已成为广告投放能否持续进行的关键因素。对于需要开展跨境业务的企业而言，如何在复杂的网络环境中建立稳定、可靠的连接，成为确保业务连续性的重要课题。</p><h2><strong>网络环境的基础作用</strong></h2><p>平台通常通过多维度数据对账户行为进行分析，其中网络环境的特征尤为关键。若多个账户共享同一网络出口，或频繁切换不同地区的网络出口，这些行为易被系统识别为异常操作，从而引发审核。</p><p>同时，网络出口的地理位置信息需要与账户操作时的其他参数（如时区、语言等）保持一致。任何不匹配都可能被系统记录，并可能影响广告内容的正常投放。</p><h2><strong>建立安全稳定的网络连接</strong></h2><p>在实际操作中，采用真实家庭网络出口可以有效降低平台识别风险。这类网络出口与普通用户的网络特征更为接近，从而减少被系统标记的可能性。</p><p>建议为每个重要账户配置独立的网络出口，避免多账户间的关联风险。同时，应确保所选网络出口的地理位置与目标市场保持一致，这有助于提升广告投放的精准度。</p><p>网络连接的质量也直接影响操作体验。稳定的连接可以确保各项操作的流畅进行，而经过筛选的网络资源则能避免因历史使用记录可能带来的潜在风险。</p><h2><strong>实施方案建议</strong></h2><p>建立符合平台规范的操作环境并不复杂：</p><ol><li>根据目标市场选择相应地区的网络资源</li><li>通过专业工具配置独立的浏览器环境</li><li>确保目标网络与设备时区、语言、分辨率的精准匹配</li></ol><p>在整个广告投放周期中，保持网络环境的稳定性十分重要。避免频繁更换不同的网络出口，有助于建立长期可信的操作记录。</p><p>通过深入理解平台审核机制的核心逻辑，并采取相应的技术措施，广告主可以有效降低运营风险。稳定的网络环境不仅能保障广告投放的连续性，也能为跨境业务的拓展提供可靠的技术支持。</p>]]></description></item><item>    <title><![CDATA[用 Python 将 Excel 表格完美转换为 Word：保持格式不变 宇文成都 ]]></title>    <link>https://segmentfault.com/a/1190000047601304</link>    <guid>https://segmentfault.com/a/1190000047601304</guid>    <pubDate>2026-02-09 12:04:30</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>数据管理与转换在日常工作中扮演着重要角色。许多情况下，我们需要将 Excel 中的数据导入到 Word 文档中，以便生成报告、制作演示材料或进行文档归档。然而，这个过程不仅涉及到简单的数据搬运，还需要确保格式的完整性，以保持文档的专业性和可读性。本文将教你如何使用 Spire.XLS for Python 和 Spire.Doc for Python 库，轻松将 Excel 数据导出并在 Word 中生成美观的表格，从而提升你的工作效率。</p><h2>环境准备</h2><p>首先，确保安装了所需的库。需要使用 Spire.XLS 和 Spire.Doc，Spire.XLS 是一款非常强大的 Excel 文件处理库，支持读取、编辑和生成 Excel 文件（.xlsx 和 .xls 格式）；Spire.Doc 是一款功能强大的 Word 文档处理库，允许用户创建、编辑和读取 Word 文档（.doc 和 .docx 格式）。</p><p>安装命令：</p><pre><code class="bash">pip install Spire.XLS
pip install Spire.Doc</code></pre><h2>代码实现</h2><p>以下是将 Excel 数据导出为 Word 表格的完整代码示例：</p><pre><code class="python">from spire.xls import *
from spire.doc import *

def MergeCells(sheet, table):
    """根据 Excel 工作表中的合并单元格合并 Word 表格中的对应单元格"""
    if sheet.HasMergedCells:
        ranges = sheet.MergedCells
        for i in range(len(ranges)):
            startRow = ranges[i].Row
            startColumn = ranges[i].Column
            rowCount = ranges[i].RowCount
            columnCount = ranges[i].ColumnCount

            if rowCount &gt; 1 and columnCount &gt; 1:
                for j in range(startRow, startRow + rowCount):
                    table.ApplyHorizontalMerge(j - 1, startColumn - 1, startColumn - 1 + columnCount - 1)
                table.ApplyVerticalMerge(startColumn - 1, startRow - 1, startRow - 1 + rowCount - 1)

            if rowCount &gt; 1 and columnCount == 1:
                table.ApplyVerticalMerge(startColumn - 1, startRow - 1, startRow - 1 + rowCount - 1)

            if columnCount &gt; 1 and rowCount == 1:
                table.ApplyHorizontalMerge(startRow - 1, startColumn - 1, startColumn - 1 + columnCount - 1)

def CopyStyle(wTextRange, xCell, wCell):
    """将单元格样式从 Excel 复制到 Word"""
    # 复制字体样式
    wTextRange.CharacterFormat.TextColor = Color.FromRgb(xCell.Style.Font.Color.R, xCell.Style.Font.Color.G, xCell.Style.Font.Color.B)
    wTextRange.CharacterFormat.FontSize = float(xCell.Style.Font.Size)
    wTextRange.CharacterFormat.FontName = xCell.Style.Font.FontName
    wTextRange.CharacterFormat.Bold = xCell.Style.Font.IsBold
    wTextRange.CharacterFormat.Italic = xCell.Style.Font.IsItalic

    # 复制背景颜色
    if xCell.Style.FillPattern is not ExcelPatternType.none:
        wCell.CellFormat.BackColor = Color.FromRgb(xCell.Style.Color.R, xCell.Style.Color.G, xCell.Style.Color.B)

    # 复制对齐方式
    wCell.CellFormat.HorizontalAlignment = {
        HorizontalAlignType.Left: HorizontalAlignment.Left,
        HorizontalAlignType.Center: HorizontalAlignment.Center,
        HorizontalAlignType.Right: HorizontalAlignment.Right
    }.get(xCell.HorizontalAlignment)

    wCell.CellFormat.VerticalAlignment = {
        VerticalAlignType.Bottom: VerticalAlignment.Bottom,
        VerticalAlignType.Center: VerticalAlignment.Middle,
        VerticalAlignType.Top: VerticalAlignment.Top
    }.get(xCell.VerticalAlignment)

# 加载 Excel 文件
workbook = Workbook()
workbook.LoadFromFile("Contact list.xlsx")

# 获取第一个工作表
sheet = workbook.Worksheets[0]

# 创建 Word 文档
doc = Document()
section = doc.AddSection()
section.PageSetup.Orientation = PageOrientation.Landscape

# 添加表格
table = section.AddTable(True)
table.ResetCells(sheet.LastRow, sheet.LastColumn)

# 根据 Excel 工作表中的合并单元格合并 Word 表格中的对应单元格
MergeCells(sheet, table)

# 从 Excel 导出数据和单元格样式到 Word 表格
for r in range(1, sheet.LastRow + 1):
    table.Rows[r - 1].Height = float(sheet.Rows[r - 1].RowHeight)

    for c in range(1, sheet.LastColumn + 1):
        xCell = sheet.Range[r, c]
        wCell = table.Rows[r - 1].Cells[c - 1]

        # 复制数据
        textRange = wCell.AddParagraph().AppendText(xCell.NumberText)

        # 复制单元格样式
        CopyStyle(textRange, xCell, wCell)

# 将 Word 文档保存到文件
doc.SaveToFile("Excel转Word表格.docx", FileFormat.Docx)</code></pre><h2>代码解析</h2><ol><li><strong>合并单元格 (<code>MergeCells</code> 函数)</strong> ：为了确保 Excel 中合并的单元格在 Word 中也保持一致，该函数管理合并单元格的逻辑。</li><li><strong>复制样式 (<code>CopyStyle</code> 函数)</strong> ：设计用于将 Excel 单元格的格式（如字体、颜色和对齐方式）精确复制到 Word 表格中。</li><li><strong>加载和处理数据</strong> ：通过 Spire.XLS 从 Excel 文件中读取数据，然后创建 Word 文档并构建其中的表格。</li><li><strong>导出数据</strong> ：通过遍历 Excel 的每一行和每一列，将数据导入 Word 表格，并同时应用样式。</li></ol><h2>总结</h2><p>使用 Spire.XLS 和 Spire.Doc 库，Python 开发者可以轻松地将 Excel 数据导出到 Word 文档中，并确保格式的完整性。这种转换不仅提高了工作效率，还提升了文档的专业性，适用于各种商业和学术场景。希望本文的代码示例能为你提供帮助，让数据处理工作变得更加顺畅。</p>]]></description></item><item>    <title><![CDATA[跟老卫学仓颉编程语言开发：整数类型 waylau ]]></title>    <link>https://segmentfault.com/a/1190000047601306</link>    <guid>https://segmentfault.com/a/1190000047601306</guid>    <pubDate>2026-02-09 12:03:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>整数类型分为有符号（signed）整数类型和无符号（unsigned）整数类型。</p><p>有符号整数类型包括Int8、Int16、Int32、Int64和IntNative，分别用于表示编码长度为8-bit、16-bit、32-bit、64-bit和平台相关大小的有符号整数值的类型。</p><p>无符号整数类型包括UInt8、UInt16、UInt32、UInt64和UIntNative，分别用于表示编码长度为8-bit、16-bit、32-bit、64-bit 和平台相关大小的无符号整数值的类型。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601308" alt="" title=""/></p><p>程序具体使用哪种整数类型，取决于该程序中需要处理的整数的性质和范围。在Int64类型适合的情况下，首选Int64类型，因为Int64的表示范围足够大，并且整数类型字面量在没有类型上下文的情况下默认推断为Int64类型，可以避免不必要的类型转换。</p><h3>整数类型字面量</h3><p>整数类型字面量有4种进制表示形式：二进制（使用0b或0B前缀）、八进制（使用0o或0O前缀）、十进制（没有前缀）、十六进制（使用0x或0X前缀）。例如，对于十进制数24，表示成二进制是0b00011000（或0B00011000），表示成八进制是0o30（或0O30），表示成十六进制是0x18（或0X18）。</p><p>在各进制表示中，可以使用下划线“_”充当分隔符的作用，方便识别数值的位数，如<code>0b0001_1000</code>。</p><p>对于整数类型字面量，如果它的值超出了上下文要求的整数类型的表示范围，编译器将会报错。</p><pre><code>let x: Int8 = 128          // 错误！, 128 out of the range of Int8
let y: UInt8 = 256         // 错误！, 256 out of the range of UInt8
let z: Int32 = 0x8000_0000 // 错误！, 0x8000_0000 out of the range of Int32</code></pre><p>在使用整数类型字面量时，可以通过加入后缀来明确整数字面量的类型，后缀与类型的对应关系如下表3-1所示。</p><p>表3-1 后缀与类型的对应关系</p><table><thead><tr><th>后缀</th><th>类型</th><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>i8</td><td>Int8</td><td>u8</td><td>UInt8</td></tr><tr><td>i16</td><td>Int16</td><td>u16</td><td>UInt16</td></tr><tr><td>i32</td><td>Int32</td><td>u32</td><td>UInt32</td></tr><tr><td>i64</td><td>Int64</td><td>u64</td><td>UInt64</td></tr></tbody></table><p>加入了后缀的整数字面量可以像下面的方式来使用：</p><pre><code>var x = 100i8  // x is 100 with type Int8
var y = 0x10u64 // y is 16 with type UInt64
var z = 0o432i32  // z is 282 with type Int32</code></pre><h3>字符字节字面量</h3><p>仓颉编程语言支持字符字节字面量，以方便使用ASCII码表示UInt8类型的值。字符字节字面量由字符b、一对标识首尾的单引号、以及一个ASCII字符组成，例如：</p><pre><code>var a = b'x' // a is 120 with type UInt8
var b = b'\n' // b is 10 with type UInt8
var c = b'\u{78}' // c is 120 with type UInt8</code></pre><p><code>b'x'</code>表示类型为UInt8大小是120的字面值。另外还可以通过<code>b'\u{78}'</code>这种转义形式表示类型为UInt8，16进制大小为<code>0x78</code> 或10进制大小为120的字面值。需要注意的是，<code>\u</code>内部最多有两位16进制数，并且值必须小于256（十进制）。</p><h3>整数类型支持的操作</h3><p>整数类型默认支持的操作符包括：算术操作符、位操作符、关系操作符、自增和自减操作符、赋值操作符、复合赋值操作符。</p><p>算术操作符包括：一元负号（<code>-</code>）、加法（<code>+</code>）、减法（<code>-</code>）、乘法（<code>*</code>）、除法（<code>/</code>）、取模（<code>%</code>）、幂运算（<code>**</code>）。</p><p>除了一元负号（<code>-</code>）和幂运算（<code>**</code>），其他操作符要求左右操作数是相同的类型。</p><p><code>*</code>、<code>/</code>、<code>+</code>和<code>-</code>的操作数可以是整数类型或浮点类型。</p><p><code>%</code>的操作数只支持整数类型。</p><p><code>**</code>的左操作数只能为Int64类型或Float64类型，并且：</p><ul><li>当左操作数类型为Int64时，右操作数只能为UInt64类型，表达式的类型为Int64。</li><li>当左操作数类型为Float64时，右操作数只能为Int64类型或Float64类型，表达式的类型为Float64。</li></ul><p>幂运算的使用，见如下示例：</p><pre><code class="ts">let p1 = 2 ** 3               // p1 = 8
let p2 = 2 ** UInt64(3 ** 2)  // p2 = 512
let p3 = 2.0 ** 3.0           // p3 = 8.0
let p4 = 2.0 ** 3 ** 2        // p4 = 512.0
let p5 = 2.0 ** 3.0           // p5 = 8.0
let p6 = 2.0 ** 3.0 ** 2.0    // p6 = 512.0</code></pre><p>位操作符包括：按位求反（<code>!</code>）、左移（<code>&lt;&lt;</code>）、右移（<code>&gt;&gt;</code>）、按位与（<code>&amp;</code>）、按位异或（<code>^</code>）、按位或（<code>|</code>）。注意，按位与、按位异或和按位或操作符要求左右操作数是相同的整数类型。</p><p>关系操作符包括：小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）、大于等于（<code>&gt;=</code>）、相等（<code>==</code>）、不等（<code>!=</code>）。要求关系操作符的左右操作数是相同的整数类型。</p><p>自增和自减操作符包括：自增（<code>++</code>）和自减（<code>--</code>）。注意，仓颉中的自增和自减操作符只能作为一元后缀操作符使用。</p><p>赋值操作符即<code>=</code>，复合赋值操作符包括：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>**=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、<code>|=</code>。</p><p>整数类型之间、整数类型和浮点类型之间可以互相转换，整数类型可以转换为字符类型。</p><h3>参考引用</h3><p>更多仓颉学习资料，详见：</p><ul><li>《跟老卫学HarmonyOS开发》：<a href="https://link.segmentfault.com/?enc=rb%2FCsBJ3yVfzExkOSbj5Yw%3D%3D.ywf1%2Bz4THBa3jO85gRgFOlCU5KfLQ%2FLZrmQPs9N5CVd6OFpeTXzmgoSXjROOA3VF" rel="nofollow" target="_blank">https://github.com/waylau/harmonyos-tutorial</a></li><li>《跟老卫学仓颉编程语言开发》：<a href="https://link.segmentfault.com/?enc=D547VvToOvGcClMjpLttvw%3D%3D.tykaoVOSkCQqtFENp5QtSP4E2XkQ8VzGJFMGhm%2B00yqKiloor%2B7U0p%2FTGYiPnxS88gzqKyZqvMAOTfYgV24wig%3D%3D" rel="nofollow" target="_blank">https://github.com/waylau/cangjie-programming-language-tutorial</a></li><li>“HarmonyOS NEXT+AI大模型打造智能助手APP(仓颉版)”：<a href="https://link.segmentfault.com/?enc=g3E5Uy1RqWzaLIkFvcRolA%3D%3D.zqRqQ5KalSH4jFfA7vRU%2FgVMbucqV6qN3Kx%2FVjKutGUj15pQ%2BZgOdi5PuduV6Z9k" rel="nofollow" target="_blank">https://coding.imooc.com/class/927.html</a></li><li>《仓颉编程从入门到实践》（北京大学出版社）：<a href="https://link.segmentfault.com/?enc=GqLsmU48gTZQGnzbrj4c4Q%3D%3D.DKA86NTqEH348KJ36ItBC4TqZqJy9tFJcKQqQbfF2kIt5YOakVUwlwsbMoOoCsGVX0gYS4%2FP1nLyhKanAF3K3fiZd78%2BDKIxeL5Dh9o7GxU%3D" rel="nofollow" target="_blank">https://waylau.com/about-cangjie-programming-language-tutoria...</a></li><li><img referrerpolicy="no-referrer" src="/img/remote/1460000047601309" alt="" title="" loading="lazy"/></li></ul>]]></description></item><item>    <title><![CDATA[十大人气CRM系统详解 正直的炒饭 ]]></title>    <link>https://segmentfault.com/a/1190000047601312</link>    <guid>https://segmentfault.com/a/1190000047601312</guid>    <pubDate>2026-02-09 12:02:58</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在客户成为企业核心资产的数字化时代，一款适配的CRM（客户关系管理）系统，是激活销售效率、留存高价值客户、实现持续增长的关键抓手。2026年国内CRM市场百花齐放，既有深耕垂直领域的专业玩家，也有覆盖全链路的一体化平台。本文深度测评10款高人气CRM系统，从核心能力、适配场景、优势亮点等维度拆解，帮你找到最契合业务需求的数字化工具。</p><h3>一、十大人气CRM系统详解</h3><h4>1. 超兔CRM（XTools）：全链路一体化的中小企业数字化引擎</h4><p>作为国内CRM行业的资深玩家，超兔CRM以“一体云”为核心定位，打造了<strong>CRM+进销存+</strong> <strong>MES</strong> <strong>生产执行+财务+AI</strong>的全链路闭环系统，覆盖从获客线索、销售跟进、订单执行、生产制造到财务回款的全业务流程，无需多系统切换即可满足中小企业的数字化需求。</p><p>核心能力上，超兔CRM的CRM模块提供360°客户视图、“三一客”节点管理（定性/定级/定量）、SFA销售自动化、RFM客户分层等功能，帮助销售精准跟进客户；进销存模块支持多仓库管理、BOM清单、智能采购直发，适配贸易与生产型企业；MES生产执行模块可实现排程、报工、质检全流程管控，联动CRM订单数据实现生产-销售协同；财务模块则支持凭证智能生成、Acc日记账、薪资自动化计算，打通业财数据。</p><p>AI赋能是超兔CRM的一大特色：基于通义千问大模型的AI智能体可定制行业销售SOP、生成个性化跟进话术，还能自动抓取电商订单、招投标数据，分析微信/电话沟通内容评估客户意向。目前已落地机械设备、工业工贸、装修、生产制造等多行业场景，帮助企业提升销售效率30%以上，降低运营成本20%。</p><p><strong>优势</strong>：全链路一体化降低数字化门槛，AI深度融入业务场景，支持移动办公与多账户管理，适配中小企业从获客到生产的全流程需求。</p><h4>2. 纷享销客：中大型企业的全场景CRM标杆</h4><p>作为国内CRM领域的领军品牌，纷享销客连续多年占据市场领先份额，2024年以110亿估值入选胡润全球独角兽榜，服务中电海康、蒙牛、元气森林等6000+中大型企业。</p><p>其核心能力围绕中大型企业的精细化管理需求：360°客户视图实现全生命周期跟进，客户分级管理支撑差异化服务策略，系统可无缝集成企业微信、ERP、HR等异构系统，强化跨部门协同。同时支持私有部署、混合部署与云端部署多种模式，销售流程、权限管理、数据报表均可灵活定制，适配复杂组织架构下的管理需求。</p><p><strong>优势</strong>：中大型企业适配性强，定制化能力突出，多部署模式满足不同IT架构需求。</p><h4>3. Zoho CRM：海外本土化的全能型SaaS平台</h4><p>Zoho CRM作为全球知名CRM厂商，在国内设有本地团队，是满足国产化需求的海外品牌代表之一，全球服务25万+企业客户，包括快手、龙湖地产、网易等。</p><p>系统覆盖销售自动化、营销自动化、客户服务、数据分析全模块，支持28种语言，提供稳定的SaaS云端服务。其自动化工具可减少人工操作，多渠道营销工具助力提升品牌影响力与客户转化，适合需要全功能CRM且偏好海外本土化服务的企业。</p><p><strong>优势</strong>：功能全面，全球品牌背书，国内本地化团队支持，适配从中小企业到大型企业的需求。</p><h4>4. 小满CRM：外贸行业的垂直化CRM专家</h4><p>小满CRM是专注外贸领域的垂直型CRM，围绕外贸业务流程整合了线索开发、邮件营销、客户跟进、订单管理与数据分析全链条功能。</p><p>核心特色是智能化邮件管理：支持批量发送、模板化管理与客户行为追踪（如邮件打开、链接点击），帮助外销人员精准把握客户意向；同时对接主流社交媒体与海关数据，可快速获取海外客户线索，大幅提升外贸企业的获客与沟通效率。</p><p><strong>优势</strong>：深度适配外贸业务场景，解决外销线索获取与跟进精准度问题。</p><h4>5. 励销云：主动式获客的智能化销售平台</h4><p>励销云定位于“找客-触客-管客”一体化的主动式销售平台，核心亮点是内置海量企业工商信息与联系方式数据库，通过大数据与AI技术帮助企业主动筛选潜在商机，解决“获客难”痛点。</p><p>系统集成智能电话、短信、邮件等触达工具，所有沟通记录自动沉淀到客户档案，形成完整跟进历史；同时提供销售漏斗管理、客户分层等功能，构建主动获客与精细化管理的闭环，适合依赖线索驱动的销售型企业。</p><p><strong>优势</strong>：主动获客能力突出，实现从线索挖掘到客户管理的全流程覆盖。</p><h4>6. 简道云CRM：零代码定制的灵活型解决方案</h4><p>简道云CRM基于零代码/低代码平台构建，最大特点是高度灵活性与可定制性。用户无需编写代码，通过拖拉拽即可快速搭建或修改CRM模块，包括客户信息字段、审批流程、报表样式等，适配非标准化业务流程。</p><p>此外，简道云可与进销存、项目管理等其他业务应用连接，打通企业内部数据流，构建符合自身需求的集成化管理平台，适合业务变化频繁、需要快速调整系统的成长型企业。</p><p><strong>优势</strong>：零代码定制门槛低，灵活适配个性化业务需求。</p><h4>7. 悟空CRM：开源与商业版兼具的多元化选择</h4><p>悟空CRM同时提供开源版与商业版，为不同需求的企业提供多样化选择：开源版适合具备自主开发能力的技术团队，可基于源代码进行深度定制与二次开发，确保数据私有化部署与安全性；商业版则提供CRM、销售自动化、BI分析、HRM等全模块功能，形成一体化企业管理解决方案。</p><p>无论是希望低成本起步、灵活定制的小微企业，还是需要全面数字化运营的大中型企业，都能在悟空CRM的产品矩阵中找到适配方案。</p><p><strong>优势</strong>：开源+商业版双模式，覆盖从定制化到全流程管理的需求。</p><h4>8. 红圈CRM：外勤销售的精细化管理专家</h4><p>红圈CRM深耕外勤销售过程管理，核心能力聚焦移动端应用与外勤行为管控：销售人员可通过移动端App完成客户拜访签到、工作轨迹记录、现场信息采集与销售订单上报，一线动态实时同步到管理后台。</p><p>系统强调销售行为的量化管理，通过追踪拜访频率、时长、客户覆盖率等过程指标，帮助管理者客观评估团队执行力，及时发现销售瓶颈，适合拥有大量外勤团队、需提升销售过程管控的企业。</p><p><strong>优势</strong>：外勤管理能力突出，实现销售过程的可视化与量化管控。</p><h4>9. 快启CRM：微信生态下的SCRM私域运营平台</h4><p>快启CRM以SCRM为核心理念，深度整合微信生态，帮助企业管理微信端客户资源，解决员工离职导致微信客户流失的问题。</p><p>系统可合规存档微信聊天记录与客户互动行为，将社交数据与CRM交易数据结合构建完整客户画像；同时提供渠道活码、客户标签、群发助手等私域营销工具，帮助企业在社交场景下高效互动，实现私域流量的精细化运营与转化，适合依赖微信私域的企业。</p><p><strong>优势</strong>：微信生态集成度高，私域运营与客户留存能力突出。</p><h4>10. HubSpot：集客营销的全球标杆平台</h4><p>HubSpot是全球知名的集客营销与销售自动化平台，其免费CRM是生态核心入口，提供简洁直观的界面与流畅体验，适合初创企业快速上手。</p><p>平台一体化生态覆盖营销、销售、服务三大模块：免费版可管理客户联系人、追踪销售流程；付费版的Marketing Hub、Sales Hub、Service Hub则提供邮件营销、社交媒体管理、智能客服、高级自动化等功能，打造从吸引访客、转化线索到服务客户的完整增长闭环。不过其高级功能定价较高，国内访问速度与本土应用集成需考虑适配性。</p><p><strong>优势</strong>：集客营销理念领先，免费版门槛低，一体化生态功能强大。</p><ul><li><ul><li>*</li></ul></li></ul><h3>二、CRM系统的核心价值与必备功能</h3><h4>核心价值</h4><ol><li><strong>集中客户数据</strong>：避免因人员变动导致客户资源流失，形成统一客户视图支撑跨部门协同；</li><li><strong>解放销售生产力</strong>：自动化流程减少数据录入与行政工作，让销售聚焦客户关系与交易转化；</li><li><strong>数据驱动决策</strong>：通过销售漏斗分析、业绩预测等功能，优化销售策略，提升转化效率。</li></ol><h4>必备功能</h4><ol><li><strong>客户与线索管理</strong>：集中存储客户资料，实现线索自动捕获、分配与追踪，构建360°客户画像；</li><li><strong>销售自动化</strong>：销售漏斗可视化、任务提醒、工作流自动化，规范销售流程避免疏漏；</li><li><strong>数据分析与报表</strong>：实时业绩看板、销售预测、团队绩效评估，支撑数据驱动决策；</li><li><strong>协同与集成</strong>：支持移动办公，可与企业微信、ERP等系统对接，打通信息孤岛。</li></ol><ul><li><ul><li>*</li></ul></li></ul><h3>三、CRM系统的适配场景与选型指南</h3><h4>适配行业</h4><ul><li><strong>B2B领域</strong>：IT、制造业、金融服务、商业地产等销售周期长、客单价高的行业，CRM是精细化管理客户关系的必备工具；</li><li><strong>B2C领域</strong>：零售、教育培训、医疗健康等行业，可通过CRM实现客户分层、个性化营销与复购激活。</li></ul><h4>适配规模</h4><ul><li><strong>小微企业</strong>：优先选轻量化或一体化平台（如超兔CRM、Zoho免费版），降低数字化门槛；</li><li><strong>中大型企业</strong>：选定制化能力强、支持多部署的平台（如纷享销客、Zoho商业版），适配复杂组织架构。</li></ul><h4>选型步骤</h4><ol><li><strong>梳理核心业务流程</strong>：项目制企业选强项目管理能力的CRM（如超兔CRM、纷享销客）；快消企业选营销自动化突出的平台（如励销云、HubSpot）；</li><li><strong>评估易用性与集成性</strong>：组织一线员工试用，确保系统与现有工具（企业微信、ERP）兼容，降低培训成本；</li><li><strong>考虑扩展性</strong>：选择可定制、功能可扩展的平台，适配业务增长后的需求变化。</li></ol><ul><li><ul><li>*</li></ul></li></ul><h3>四、快速上手CRM系统的实操技巧</h3><ol><li><strong>管理层牵头明确目标</strong>：如设定“提升线索转化率15%”“缩短销售周期10%”的具体目标，自上而下统一团队认知；</li><li><strong>分阶段实施</strong>：从核心功能（客户管理、销售跟进）入手，逐步扩展到进销存、生产、财务等模块，避免团队不堪重负；</li><li><strong>差异化培训</strong>：针对销售、客服、管理层提供定制化培训内容，建立内部支持渠道及时解决问题；</li><li><strong>数据驱动优化</strong>：每周分析CRM数据，调整销售流程与跟进策略，逐步实现精细化管理。</li></ol><ul><li><ul><li>*</li></ul></li></ul><h3>常见问题解答（FAQ）</h3><ol><li><strong>CRM系统的数据安全如何保障？</strong> 主流CRM厂商采用云端加密存储、多副本备份、细粒度权限控制、操作日志追溯等技术，符合国际安全标准（如ISO27001）。部分厂商支持私有部署（如纷享销客、悟空CRM），可进一步保障数据私有化安全。</li><li><strong>使用CRM后，是否还需要用Excel管理客户？</strong> CRM可完全替代Excel，提供实时协同、数据安全、智能分析等Excel不具备的优势。初期可将Excel数据导入CRM，后续建议统一在CRM中管理客户信息，避免信息孤岛与版本混乱。</li><li><strong>独特的销售流程，CRM能适配吗？</strong> 大部分专业CRM支持高度自定义，如超兔CRM可自定义字段、工作流、报表；简道云可零代码搭建专属流程。选型时重点考察系统的定制化能力，优先选择支持可视化配置的平台。</li><li><strong>移动端App对于CRM系统重要吗？</strong> 非常重要。超兔CRM、红圈CRM等平台的移动端支持外勤签到、客户信息录入、待办提醒、订单上报等功能，让销售随时随地跟进客户，大幅提升外勤工作效率，确保客户跟进不中断。</li><li><strong>中小企业选择CRM时，功能全面还是轻量化更重要？</strong> 优先适配核心业务需求。若企业覆盖获客、销售、生产、全流程，选一体化平台（如超兔CRM）可避免多系统切换；若仅需基础客户管理，选轻量化工具（如Zoho免费版）即可，兼顾易用性与扩展性。</li></ol>]]></description></item><item>    <title><![CDATA[开源与商业CRM核心能力横评：从AI到复购的全维度较量 傲视众生的脸盆 ]]></title>    <link>https://segmentfault.com/a/1190000047601326</link>    <guid>https://segmentfault.com/a/1190000047601326</guid>    <pubDate>2026-02-09 12:01:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在企业数字化转型中，CRM（客户关系管理）已从“客户信息库”升级为“销售增长引擎”，其核心能力逐渐聚焦于AI智能自动化、销售流程标准化（SFA）、系统集成（API）、数据决策（统计分析）、客户留存（复购流失预警）<strong>五大维度。本文选取</strong>超兔一体云（商业）、YetiForce（开源）、Dolibarr（开源）、橙子CRM（中小微）、销帮帮CRM（中小企）、Zendesk Sell（海外）、OKKICRM（外贸）七大主流CRM，从技术逻辑到场景落地展开深度对比，为企业选型提供参考。</p><h2>一、评估框架与核心维度定义</h2><p>本次对比围绕CRM的“增长驱动能力”设计评估体系，五个核心维度的具体评估点如下：</p><table><thead><tr><th>维度</th><th>评估点</th></tr></thead><tbody><tr><td><strong>AI智能</strong></td><td>原生AI能力、自动化场景覆盖（如AI待办、自动分析）、NLP（自然语言处理）应用</td></tr><tr><td><strong>SFA</strong></td><td>销售流程覆盖（线索-成交全链路）、自定义能力、销售漏斗管理</td></tr><tr><td><strong>API</strong> <strong>对接</strong></td><td>接口丰富度、集成案例（如ERP/电商）、开源扩展性</td></tr><tr><td><strong>统计分析</strong></td><td>报表自定义、多维度数据整合（销售+库存+客户）、实时性</td></tr><tr><td><strong>复购流失预警</strong></td><td>数据模型（如RFM）、预警触发逻辑、自动化动作（如自动提醒）</td></tr></tbody></table><h2>二、核心能力横向对比表</h2><p>先通过<strong>一张表格</strong>快速呈现各品牌的关键差异（“√”代表具备，“-”代表不具备，“☆”代表优势）：</p><table><thead><tr><th>品牌</th><th>AI智能核心特征</th><th>SFA核心特征</th><th>API对接核心特征</th><th>统计分析核心特征</th><th>复购流失预警核心特征</th></tr></thead><tbody><tr><td>超兔一体云</td><td>原生通义千问集成，AI待办/日报/分析☆</td><td>多跟单模型（三一客/商机/项目），全流程标准化☆</td><td>金蝶/用友/京东对接案例，RPA+API☆</td><td>自定义仪表盘+多表聚合+实时KPI☆</td><td>RFM模型+消费间隔分析，自动触发跟进☆</td></tr><tr><td>YetiForce</td><td>开源扩展第三方AI，订单-库存自动化</td><td>销售漏斗+订单-生产-库存全链路绑定☆</td><td>开源API，支持ERP/库存深度集成☆</td><td>自定义报表，多维度数据整合</td><td>客户采购间隔监控，需手动触发提醒</td></tr><tr><td>Dolibarr</td><td>无原生AI，需手动扩展</td><td>报价-发票基础流程，无深度定制</td><td>基础API，支持电商/会计集成</td><td>简单报表，无多维度整合</td><td>无原生功能，需自定义分析</td></tr><tr><td>橙子CRM</td><td>无原生AI，客户标签辅助转化</td><td>线索-签单闭环，抖音/小红书客资导入☆</td><td>抖音/小红书API，支持Excel导出</td><td>销售漏斗/签单排名，基础可视化</td><td>无原生预警，需手动跟踪</td></tr><tr><td>销帮帮CRM</td><td>智能工作流自动化，AI话术建议</td><td>自定义销售流程，回款计划管理☆</td><td>开放API，支持ERP/财务集成</td><td>多维度报表，智能仪表盘</td><td>客户行为分析，触发短信提醒</td></tr><tr><td>Zendesk Sell</td><td>AI销售建议（高价值线索优先）☆</td><td>销售预测+商机管理，全周期跟踪☆</td><td>客服生态集成，基础API</td><td>实时销售看板，团队绩效对比</td><td>AI识别流失风险，自动发送邮件提醒</td></tr><tr><td>OKKICRM</td><td>AI客户画像，外贸场景智能推荐☆</td><td>外贸客户分级，订单-供应商联动☆</td><td>外贸平台（如阿里）集成，API自定义</td><td>采购频率/库存周转分析，外贸场景适配☆</td><td>RFM模型+采购间隔，自动触发补货提醒☆</td></tr></tbody></table><h2>三、技术逻辑与场景落地深度解析</h2><h3>（一）AI智能：从“工具辅助”到“流程驱动”的差异</h3><p>AI是CRM的“大脑”，其核心价值在于<strong>用机器替代重复劳动，用数据提升决策精准度</strong>。我们以<strong>超兔一体云</strong>为例，用流程图展示其AI智能的实现逻辑：</p><p>!<a href="" target="_blank"/></p><pre><code>flowchart TD
    A[技术基础：超兔AI智能体 + 通义千问大模型] --&gt; B[核心能力]
    B --&gt; B1[AI定制行业SOP（输出CJM/话术/销售流程）]
    B --&gt; B2[AI专家智能体（融合客户名称/行业/跟单时间线，生成个性化话术）]
    B --&gt; B3[AI生成关键内容（用户画像、三一客节点、SFA方案）]
    B --&gt; C[场景化应用]
    C --&gt; C1[AI待办（自动生成下一步跟单任务，去除人为偏见）]
    C --&gt; C2[AI日报（分析当日沟通/报价数据，一键生成专业总结）]
    C --&gt; C3[AI问答（岗位个性化话术：销售开场白/客服异议处理）]
    C --&gt; C4[AI执行（RPA自动抓取电商订单/招投标数据）]
    C --&gt; C5[AI分析（微信/电话录音NLP分析，提取客户意向/关键话题）]</code></pre><p><strong>各品牌AI能力差异</strong>：</p><ul><li><strong>超兔</strong>：原生集成通义千问，实现“全场景AI自动化”（从待办生成到沟通分析），是唯一覆盖“AI+SFA+分析”闭环的品牌；</li><li><strong>Zendesk Sell</strong>：侧重“销售决策辅助”（AI推荐高价值线索），但自动化场景少于超兔；</li><li><strong>OKKICRM</strong>：聚焦“外贸场景AI”（客户画像+采购推荐），适配跨境业务需求；</li><li><strong>YetiForce/Dolibarr</strong>：无原生AI，需技术团队扩展第三方工具（如ChatGPT），落地成本高。</li></ul><h3>（二）SFA：从“流程覆盖”到“场景适配”的进化</h3><p>SFA（销售自动化）是CRM的“骨架”，其核心是<strong>将销售经验转化为可复制的流程</strong>。我们用<strong>脑图</strong>展示各品牌的SFA能力结构：</p><p>!<a href="" target="_blank"/></p><pre><code>mindmap
    root((SFA销售自动化能力))
        超兔一体云
            多跟单模型（三一客小单/商机中单/多方项目大单）
            全流程标准化（关键节点+推进步骤，如“三一客”要求“1天内联系/3天内跟进/7天内转化”）
            线索-客户-订单全链路数据驱动（自动关联客户画像与跟进策略）
        YetiForce
            销售漏斗+销售预测+报价管理
            订单-生产-库存全链路绑定（库存不足自动触发采购提醒）
            自定义订单流程（适配制造业“订单-车间-发货”场景）
        OKKICRM（原小满）
            外贸客户分级（高价值客户标记）
            报价管理（历史报价对比+供应商价格联动）
            客户采购频率追踪（提醒业务员跟进复购）
        Zendesk Sell
            线索追踪（来源+跟进记录）
            商机管理（阶段划分+胜率预测）
            销售预测（基于历史数据生成月度目标）</code></pre><p><strong>SFA能力的“场景适配性”是关键</strong>：</p><ul><li>超兔的“多跟单模型”覆盖小单（如零售）、中单一（如企业服务）、大单（如项目型销售），适合<strong>业务多元化的企业</strong>；</li><li>YetiForce的“订单-库存联动”适合<strong>制造/贸易企业</strong>（需打通生产与销售）；</li><li>OKKICRM的“外贸客户分级”适合<strong>跨境电商/外贸企业</strong>（需管理海外客户采购周期）。</li></ul><h3>（三）API对接：从“数据打通”到“生态协同”的升级</h3><p>API是CRM的“神经线”，其核心价值是<strong>打破数据孤岛，实现上下游业务协同</strong>。各品牌的API能力差异主要体现在：</p><table><thead><tr><th>品牌</th><th>API能力优势</th><th>典型集成案例</th></tr></thead><tbody><tr><td>超兔一体云</td><td>RPA+API双引擎，支持非结构化数据抓取</td><td>金蝶ERP（订单同步）、京东（自动抓取订单）、国税开票机器人</td></tr><tr><td>YetiForce</td><td>开源API，支持深度二次开发</td><td>库存系统（自动同步库存）、财务软件（发票对接）</td></tr><tr><td>OKKICRM</td><td>外贸平台专属API</td><td>阿里巴巴国际站（客资导入）、海关系统（报关数据）</td></tr><tr><td>橙子CRM</td><td>自媒体平台API</td><td>抖音（粉丝转化为线索）、小红书（评论抓取）</td></tr></tbody></table><p><strong>结论</strong>：开源CRM（YetiForce）的API扩展性最强，但需技术团队维护；商业CRM（超兔/OKKICRM）的集成案例更丰富，适合<strong>无技术团队的企业</strong>。</p><h3>（四）统计分析：从“数据展示”到“决策支持”的跨越</h3><p>统计分析是CRM的“眼睛”，其核心是<strong>将数据转化为可行动的洞察</strong>。我们以<strong>超兔</strong>和<strong>OKKICRM</strong>为例对比：</p><ul><li><strong>超兔</strong>：提供“工作台自定义引擎+多表聚合引擎+单日KPI引擎”，支持<strong>销售数据+客户行为+库存数据</strong>的多维度整合（如“某地区客户的采购频率与库存周转天数关联分析”），并通过“同比环比引擎”展示业务增长趋势；</li><li><strong>OKKICRM</strong>：聚焦“外贸场景分析”，支持<strong>客户采购频率+供应商交货周期+汇率波动</strong>的联动分析（如“某客户最近3个月采购量下降，同时供应商交货延迟2天，建议调整报价”）。</li></ul><p><strong>统计分析的“场景深度”决定价值</strong>：</p><ul><li>超兔适合<strong>全行业的综合分析</strong>；</li><li>OKKICRM适合<strong>外贸企业的精准分析</strong>；</li><li>Dolibarr/橙子CRM仅能提供“销售业绩表”等基础报表，无法支撑复杂决策。</li></ul><h3>（五）复购流失预警：从“被动挽留”到“主动预测”的转变</h3><p>复购流失预警是CRM的“增长引擎”，其核心是<strong>用数据识别客户行为信号，提前干预</strong>。我们用<strong>流程图</strong>展示超兔的复购流失预警逻辑：</p><p>!<a href="" target="_blank"/></p><pre><code>flowchart TD
    A[数据采集：客户消费记录（时间/金额/频率）+ 沟通历史] --&gt; B[数据模型：RFM分析（最近消费R/频率F/金额M）]
    B --&gt; C[预警触发]
    C --&gt; C1[复购预警：消费间隔接近阈值（如“最近3次消费间隔从7天延长到15天”）]
    C --&gt; C2[流失预警：消费间隔超过阈值（如“60天未消费”）]
    C --&gt; D[自动化动作]
    D --&gt; D1[AI待办：提醒业务员跟进复购]
    D --&gt; D2[自动邮件：发送专属优惠券（针对流失客户）]
    D --&gt; D3[客服提醒：主动询问客户需求（针对高价值流失客户）]</code></pre><p><strong>各品牌的预警能力差异</strong>：</p><ul><li>超兔：<strong>RFM模型+消费间隔</strong>双维度预警，且自动触发“AI待办+邮件+客服”动作，落地成本低；</li><li>OKKICRM：<strong>外贸场景定制</strong>（如“客户采购间隔从30天延长到45天，提醒业务员发送新品报价”）；</li><li>Zendesk Sell：<strong>AI识别流失信号</strong>（如“客户最近1个月未打开邮件，自动发送调研问卷”）；</li><li>Dolibarr/橙子CRM：无原生预警功能，需手动导出数据分析，效率低。</li></ul><h2>三、综合性能雷达图</h2><p>我们用<strong>雷达图分值</strong>（1-10分，10分为满分）展示各品牌的综合能力：</p><table><thead><tr><th>品牌</th><th>AI智能</th><th>SFA</th><th>API对接</th><th>统计分析</th><th>复购流失预警</th></tr></thead><tbody><tr><td>超兔一体云</td><td>9</td><td>8.5</td><td>8</td><td>9</td><td>8.5</td></tr><tr><td>YetiForce</td><td>6</td><td>7.5</td><td>8.5</td><td>7</td><td>6.5</td></tr><tr><td>Dolibarr</td><td>3</td><td>6</td><td>7</td><td>5</td><td>4</td></tr><tr><td>橙子CRM</td><td>5</td><td>7</td><td>7.5</td><td>6.5</td><td>5</td></tr><tr><td>销帮帮CRM</td><td>7</td><td>8</td><td>8</td><td>7.5</td><td>6.5</td></tr><tr><td>Zendesk Sell</td><td>8</td><td>8.5</td><td>7.5</td><td>8</td><td>7.5</td></tr><tr><td>OKKICRM</td><td>7.5</td><td>8</td><td>7</td><td>8.5</td><td>9</td></tr></tbody></table><h2>四、选型建议：匹配业务场景是关键</h2><p>根据各品牌的核心优势，给出以下选型建议：</p><ol><li><strong>需要AI自动化的企业</strong>：选超兔一体云（原生AI覆盖多场景，无需扩展）；</li><li><strong>制造/贸易企业</strong>：选YetiForce（开源+订单-库存联动，适配生产场景）；</li><li><strong>外贸企业</strong>：选OKKICRM（外贸场景定制，复购预警精准）；</li><li><strong>中小微企业（无技术团队）</strong> ：选橙子CRM（简单易用，抖音/小红书客资导入）；</li><li><strong>海外业务企业</strong>：选Zendesk Sell（海外销售流程适配，AI销售建议）。</li></ol><h2>结论</h2><p>CRM的核心价值不是“功能多”，而是“匹配业务场景”。超兔的“AI+多跟单模型”适合<strong>业务多元化的企业</strong>，YetiForce的“开源+流程定制”适合<strong>有技术团队的制造企业</strong>，OKKICRM的“外贸场景优化”适合<strong>跨境企业</strong>。企业选型时需优先考虑“当前业务的核心痛点”（如AI自动化/流程适配/外贸场景），而非盲目追求“全功能”。</p><p>（注：文中功能相关描述均基于公开披露信息，具体功能服务以厂商实际落地版本为准。）</p>]]></description></item><item>    <title><![CDATA[IP归属地数据赋能在线用户匹配：构建精准、高效的社交连接 用户bPbDqZf ]]></title>    <link>https://segmentfault.com/a/1190000047601339</link>    <guid>https://segmentfault.com/a/1190000047601339</guid>    <pubDate>2026-02-09 12:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在移动互联网与社交软件蓬勃发展的今天，基于地理位置的“附近的人”、“同城交友”已成为提升用户活跃度与粘性的核心功能。然而，当用户出于隐私考虑关闭手机GPS定位时，这一体验链条便面临中断的风险。此时，IP地址归属地数据服务作为一种高效、非侵入式的替代方案，展现出不可或缺的价值。它能够在不依赖精确GPS信号的情况下，智能推断用户的大致地理位置，从而持续驱动同城社交、跨语言匹配及本地化内容推送等关键场景，确保社交软件的连接价值与用户体验不受损。<br/><img width="665" height="363" referrerpolicy="no-referrer" src="/img/bVdnTrF" alt="image.png" title="image.png"/></p><p>一、 同城社交匹配：基于IP的地理位置推断</p><p>当用户禁用GPS时，应用无法获取其精确的经纬度坐标。此时，通过集成高精度的IP地址归属地查询API（例如埃文科技提供的服务），应用可以实时解析用户当前连接网络所分配的IP地址，并将其映射至城市甚至区县级的地理位置。这一技术原理依赖于全球IP地址段的精心维护与地理映射数据库。基于此推断出的地理位置，系统能够优先将用户与同一城市或相邻区域的在线用户进行匹配推荐。地域的相近性天然地带来了更多共同的生活圈、文化背景和线下见面可能性，极大地提升了匹配的潜在价值与用户的互动意愿，让社交软件即使在定位功能关闭时，仍能维持其“发现身边朋友”的核心乐趣，有效提升用户粘性与平台活跃度。</p><p>二、 跨区域语种与内容智能适配</p><p>在全球化的业务场景中，用户可能遍布世界各地。IP归属地数据在此扮演了“文化桥梁”的角色。通过判断用户IP地址所属的国家或地区，系统可以智能分析其对应的主流语言环境。在此基础上，可实施两种关键优化：</p><p>语种匹配：在多人聊天室、游戏组队或语言学习社区等场景中，优先将使用同一种语言的用户匹配在一起。这从根本上消除了沟通障碍，提升了交流效率与匹配满意度，使全球用户能够无缝连接。</p><p>本地化内容推送：根据用户所在地，动态调整其看到的资讯内容、广告活动或优惠信息。例如，向北京用户推送本地生活新闻和商圈折扣，向上海用户展示艺术展览信息。这种高度本地化的内容呈现，不仅显著提高了用户的关注度与接受度，也极大地增强了广告投放的精准性与商业转化效率，提升了产品的整体商业价值。</p><p>三、 融合多维数据的智能匹配演进</p><p>需要指出的是，最先进的用户匹配系统绝非仅依赖单一的地理维度。IP归属地是一个强大的启动器和基础过滤器，而最佳的社交体验来自于多维数据的融合与智能计算。正如前沿技术实践所示，成熟的匹配系统会结合用户的兴趣标签（通过分析行为提取）、社交画像乃至虚拟形象特征等进行综合考量。例如，系统可先通过IP定位筛选出同城潜在用户池，再通过算法计算这些用户与目标用户在兴趣爱好、性格测试（如MBTI）结果或行为模式上的相似度，进行二次精准排序与推荐。这种“地理位置+兴趣图谱”的双层过滤模型，既能保障社交的在地便利性，又能确保连接的内容相关性与深度，从而实现从“简单推荐”到“智能邂逅”的体验升级。</p><p>结语：</p><p>IP地址归属地数据是在线用户匹配体系中一项稳定而高效的基础设施。它巧妙地在用户隐私（不强制开启GPS）与社交需求（同城连接、本地化内容）之间取得了平衡。对于社交平台开发者而言，选择如埃文科技所提供的精准、可靠、低延迟的IP地理位置API服务，并将其与用户兴趣模型、行为分析等上层智能算法有机结合，是构建一个全天候、全场景、高满意度的社交匹配引擎的关键一步。通过数据驱动的智能连接，让每一次匹配都更贴近用户真实的生活与兴趣世界，方能铸就持久的产品吸引力与社区活力。</p>]]></description></item><item>    <title><![CDATA[嵌入式处理器架构 良许 ]]></title>    <link>https://segmentfault.com/a/1190000047600851</link>    <guid>https://segmentfault.com/a/1190000047600851</guid>    <pubDate>2026-02-09 11:07:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大家好，我是良许。</p><p>在嵌入式开发的这些年里，我接触过各种各样的处理器架构，从最早做单片机时用的51内核，到后来做汽车电子时用的ARM Cortex-A系列，再到现在项目中偶尔会碰到的RISC-V架构。</p><p>每次换一个新架构，都需要重新熟悉它的特性和开发方式。</p><p>今天就和大家聊聊嵌入式处理器架构这个话题，帮助大家建立一个系统的认知框架。</p><h2>1. 什么是处理器架构</h2><p>处理器架构，简单来说就是处理器的设计蓝图和规范。</p><p>它定义了处理器如何执行指令、如何管理内存、如何与外设交互等一系列核心问题。</p><p>就像盖房子需要先有建筑设计图纸一样，处理器的制造也需要先有架构设计。</p><p>从技术角度来看，处理器架构主要包含以下几个方面：</p><p><strong>1.1 指令集架构（ISA）</strong></p><p>指令集架构是处理器架构的核心，它定义了处理器能够识别和执行的所有指令。</p><p>比如ARM架构有自己的指令集，x86架构也有自己的指令集，它们是完全不同的。</p><p>这就像不同的语言一样，说中文的人听不懂英文，反之亦然。</p><p>在我刚开始做嵌入式开发的时候，用的是51单片机，它的指令集非常简单，只有几十条指令。</p><p>后来转到ARM平台，发现ARM的指令集要复杂得多，但也更加强大和灵活。</p><p><strong>1.2 寄存器组织</strong></p><p>寄存器是处理器内部用于临时存储数据的高速存储单元。</p><p>不同的架构有不同数量和类型的寄存器。</p><p>比如ARM Cortex-M系列有16个通用寄存器，而x86架构的寄存器组织方式就完全不同。</p><p><strong>1.3 内存管理</strong></p><p>处理器如何访问和管理内存也是架构的重要组成部分。</p><p>有些架构支持虚拟内存管理单元（MMU），有些只支持内存保护单元（MPU），还有些什么都不支持。</p><p>这直接影响到系统能否运行复杂的操作系统。</p><p><strong>1.4 流水线和执行单元</strong></p><p>现代处理器通常采用流水线技术来提高执行效率。</p><p>不同架构的流水线级数、执行单元数量和组织方式都不相同，这直接影响到处理器的性能表现。</p><h2>2. 主流嵌入式处理器架构</h2><h3>2.1 ARM架构</h3><p>ARM架构可以说是嵌入式领域的绝对霸主，市场占有率超过90%。</p><p>我在外企做汽车电子的时候，用的就是ARM Cortex-A系列处理器。</p><p>ARM架构的成功主要得益于其低功耗、高性能和良好的生态系统。</p><p>ARM架构主要分为以下几个系列：</p><p><strong>2.1.1 ARM Cortex-M系列</strong></p><p>这是专门为微控制器（MCU）设计的系列，主打低功耗和实时性。</p><p>我们常用的STM32就是基于Cortex-M内核的。</p><p>比如STM32F103使用的是Cortex-M3内核，STM32F407使用的是Cortex-M4内核（带DSP指令和浮点运算单元）。</p><p>下面是一个简单的STM32 HAL库示例，展示如何初始化GPIO：</p><pre><code class="c">#include "stm32f4xx_hal.h"

void GPIO_Init_Example(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    /* 使能GPIOA时钟 */
    __HAL_RCC_GPIOA_CLK_ENABLE();
    
    /* 配置PA5引脚为输出模式 */
    GPIO_InitStruct.Pin = GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  // 推挽输出
    GPIO_InitStruct.Pull = GPIO_NOPULL;          // 无上下拉
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; // 低速
    
    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);
    
    /* 点亮LED */
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
}</code></pre><p><strong>2.1.2 ARM Cortex-A系列</strong></p><p>这是为应用处理器设计的系列，性能强大，支持运行Linux等复杂操作系统。</p><p>我在外企做的汽车娱乐系统就是基于Cortex-A9的处理器，运行的是定制版的Linux系统。</p><p>这类处理器通常主频在几百MHz到几GHz之间，支持MMU、多核心等高级特性。</p><p><strong>2.1.3 ARM Cortex-R系列</strong></p><p>这是为实时系统设计的系列，介于M系列和A系列之间。</p><p>主要用于对实时性要求极高的场合，比如汽车的安全系统、工业控制等。</p><h3>2.2 x86/x64架构</h3><p>x86架构主要由Intel和AMD主导，在PC和服务器领域占据统治地位。</p><p>虽然在传统嵌入式领域应用不多，但在工业PC、边缘计算等场景中也有一定的应用。</p><p>x86架构的特点是性能强大、生态成熟，但功耗相对较高。</p><p>Intel推出的Atom系列处理器就是专门针对嵌入式和移动设备的低功耗版本。</p><p>我见过一些工业控制系统使用x86架构的嵌入式主板，主要是因为需要运行一些只有x86版本的专业软件。</p><h3>2.3 RISC-V架构</h3><p>RISC-V是近年来异军突起的开源指令集架构，由加州大学伯克利分校开发。</p><p>它最大的特点就是完全开源，任何人都可以免费使用，不需要支付授权费用。</p><p>RISC-V采用模块化设计，基础指令集非常精简，只有40多条指令，然后可以根据需要添加各种扩展模块。</p><p>这种设计理念非常适合定制化需求强烈的嵌入式应用。</p><p>虽然RISC-V目前的生态还不如ARM成熟，但发展势头非常迅猛。</p><p>国内很多芯片厂商都在积极布局RISC-V，比如平头哥、芯来科技等。</p><p>我最近也在关注RISC-V的发展，考虑在一些新项目中尝试使用。</p><h3>2.4 MIPS架构</h3><p>MIPS架构曾经在嵌入式领域占有一席之地，特别是在网络设备和消费电子产品中。</p><p>但近年来市场份额逐渐被ARM蚕食。</p><p>MIPS的特点是指令集简洁、流水线效率高，但生态系统相对薄弱。</p><h3>2.5 其他架构</h3><p>除了上述主流架构，还有一些专用或小众架构，比如：</p><ul><li><strong>PowerPC架构</strong>：主要用于航空航天、工业控制等高可靠性领域</li><li><strong>AVR架构</strong>：Arduino使用的就是AVR内核的单片机</li><li><strong>8051架构</strong>：虽然古老，但在一些简单应用中仍然活跃</li><li><strong>DSP架构</strong>：专门用于数字信号处理的架构，如TI的C2000系列</li></ul><h2>3. 处理器架构的关键特性</h2><h3>3.1 RISC vs CISC</h3><p>处理器架构从指令集设计理念上可以分为RISC（精简指令集）和CISC（复杂指令集）两大类。</p><p><strong>RISC架构</strong>的特点是指令数量少、指令格式统一、每条指令执行时间固定。</p><p>ARM、RISC-V、MIPS都属于RISC架构。</p><p>RISC架构的优势是设计简单、功耗低、容易实现流水线，非常适合嵌入式应用。</p><p><strong>CISC架构</strong>的特点是指令数量多、指令功能复杂、指令长度可变。</p><p>x86就是典型的CISC架构。</p><p>CISC架构的优势是代码密度高、功能强大，但设计复杂、功耗较高。</p><p>在实际开发中，我发现RISC架构的处理器通常更容易上手，汇编代码也更容易理解。</p><p>比如ARM的汇编代码就比x86的汇编代码简洁很多。</p><h3>3.2 位宽</h3><p>处理器的位宽指的是处理器一次能处理的数据位数。</p><p>常见的有8位、16位、32位和64位。</p><ul><li><strong>8位处理器</strong>：如8051、AVR，适合简单控制应用</li><li><strong>16位处理器</strong>：如MSP430，性能和功耗的平衡点</li><li><strong>32位处理器</strong>：如ARM Cortex-M、STM32，目前嵌入式主流</li><li><strong>64位处理器</strong>：如ARM Cortex-A53/A72，用于高性能应用</li></ul><p>位宽越大，处理器能够直接处理的数据范围就越大，寻址空间也越大。</p><p>但位宽增加也会带来功耗和成本的增加。</p><p>在实际项目中，需要根据应用需求选择合适的位宽。</p><p>我在做单片机项目的时候，发现32位处理器已经成为主流选择。</p><p>即使是一些简单的应用，也倾向于使用32位MCU，因为价格已经降到了可以接受的范围，而且开发效率更高。</p><h3>3.3 主频和性能</h3><p>处理器的主频（时钟频率）是衡量性能的重要指标之一，但不是唯一指标。</p><p>同样主频的不同架构处理器，性能可能相差很大。</p><p>在嵌入式系统中，我们通常使用DMIPS（Dhrystone MIPS）或CoreMark来衡量处理器的实际性能。</p><p>比如ARM Cortex-M4在100MHz主频下，性能大约是125 DMIPS。</p><p>下面是一个简单的性能测试代码示例：</p><pre><code class="c">#include "stm32f4xx_hal.h"
#include &lt;stdio.h&gt;

#define TEST_ITERATIONS 1000000

void Performance_Test(void)
{
    uint32_t start_tick, end_tick;
    volatile uint32_t result = 0;
    
    /* 记录开始时间 */
    start_tick = HAL_GetTick();
    
    /* 执行测试循环 */
    for(uint32_t i = 0; i &lt; TEST_ITERATIONS; i++)
    {
        result += i * 2;
        result -= i / 2;
    }
    
    /* 记录结束时间 */
    end_tick = HAL_GetTick();
    
    /* 计算执行时间 */
    uint32_t elapsed_time = end_tick - start_tick;
    
    printf("Test completed in %lu ms\n", elapsed_time);
    printf("Result: %lu\n", result);
}</code></pre><h3>3.4 功耗特性</h3><p>功耗是嵌入式系统设计中非常重要的考虑因素，特别是对于电池供电的设备。</p><p>不同架构的处理器在功耗方面差异很大。</p><p>ARM Cortex-M系列在低功耗方面做得非常出色，支持多种低功耗模式：</p><ul><li><strong>Sleep模式</strong>：CPU停止，外设继续运行</li><li><strong>Stop模式</strong>：CPU和大部分外设停止，保持RAM数据</li><li><strong>Standby模式</strong>：仅保持备份寄存器和RTC，功耗最低</li></ul><p>下面是一个进入低功耗模式的示例：</p><pre><code class="c">#include "stm32f4xx_hal.h"

void Enter_Sleep_Mode(void)
{
    /* 挂起SysTick中断 */
    HAL_SuspendTick();
    
    /* 进入Sleep模式 */
    HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
    
    /* 从Sleep模式唤醒后恢复SysTick */
    HAL_ResumeTick();
}

void Enter_Stop_Mode(void)
{
    /* 使能PWR时钟 */
    __HAL_RCC_PWR_CLK_ENABLE();
    
    /* 挂起SysTick中断 */
    HAL_SuspendTick();
    
    /* 进入Stop模式 */
    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
    
    /* 从Stop模式唤醒后重新配置系统时钟 */
    SystemClock_Config();
    
    /* 恢复SysTick */
    HAL_ResumeTick();
}</code></pre><h3>3.5 中断系统</h3><p>中断系统是嵌入式处理器的重要组成部分。</p><p>不同架构的中断系统设计差异很大。</p><p>ARM Cortex-M系列使用NVIC（嵌套向量中断控制器），支持多达240个中断源，每个中断可以配置16个优先级。</p><p>这种设计非常灵活，能够满足复杂应用的需求。</p><p>在实际开发中，合理配置中断优先级非常重要。</p><p>我的经验是：</p><ul><li>高优先级：给时间敏感的任务，如通信协议的超时处理</li><li>中优先级：给普通外设中断，如串口接收、定时器</li><li>低优先级：给不太紧急的任务，如按键扫描</li></ul><pre><code class="c">#include "stm32f4xx_hal.h"

void NVIC_Config_Example(void)
{
    /* 配置USART1中断优先级 */
    HAL_NVIC_SetPriority(USART1_IRQn, 1, 0);  // 抢占优先级1，子优先级0
    HAL_NVIC_EnableIRQ(USART1_IRQn);
    
    /* 配置TIM2中断优先级 */
    HAL_NVIC_SetPriority(TIM2_IRQn, 2, 0);    // 抢占优先级2，子优先级0
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
    
    /* 配置外部中断优先级 */
    HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);   // 抢占优先级0（最高），子优先级0
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);
}</code></pre><h2>4. 如何选择合适的处理器架构</h2><p>在实际项目中，选择合适的处理器架构需要综合考虑多个因素：</p><p><strong>4.1 应用需求</strong></p><p>首先要明确应用的具体需求。</p><p>如果只是简单的控制任务，8位或16位MCU就足够了。</p><p>如果需要运行复杂的算法或操作系统，就需要32位甚至64位的处理器。</p><p>我在做汽车电子项目的时候，因为需要运行Linux系统并处理大量的多媒体数据，所以选择了ARM Cortex-A系列的处理器。</p><p>而在做一些简单的传感器节点时，使用STM32F103这样的Cortex-M3就完全够用。</p><p><strong>4.2 性能要求</strong></p><p>要根据实际的计算量来选择处理器性能。</p><p>过高的性能会造成成本和功耗的浪费，过低的性能又无法满足需求。</p><p>一个实用的方法是：先估算应用的计算量，然后选择性能略高于需求的处理器，留出一定的余量。</p><p>我的经验是留出30%左右的性能余量比较合适。</p><p><strong>4.3 功耗限制</strong></p><p>对于电池供电的设备，功耗是首要考虑因素。</p><p>需要选择支持低功耗模式的处理器，并在软件设计时充分利用这些特性。</p><p><strong>4.4 开发生态</strong></p><p>开发工具链、软件库、技术支持等生态因素也很重要。</p><p>ARM架构在这方面具有明显优势，有大量的开发工具和参考资料可用。</p><p><strong>4.5 成本因素</strong></p><p>处理器的成本包括芯片价格、开发成本、授权费用等。对于大批量产品，即使每颗芯片节省几毛钱，总体也能节省很大一笔费用。</p><p><strong>4.6 长期供货</strong></p><p>嵌入式产品的生命周期通常很长，需要考虑处理器的长期供货能力。</p><p>一些老牌厂商如ST、NXP通常能保证10年以上的供货周期。</p><h2>5. 处理器架构的发展趋势</h2><h3>5.1 异构多核</h3><p>现代嵌入式处理器越来越多地采用异构多核设计，即在一颗芯片上集成不同类型的处理器核心。</p><p>比如ARM的big.LITTLE架构，同时包含高性能核心和低功耗核心，根据负载动态切换。</p><p>在汽车电子领域，我见过一些芯片同时集成Cortex-A核心（运行Linux）、Cortex-R核心（处理实时任务）和Cortex-M核心（控制外设），这种设计能够很好地平衡性能、实时性和功耗。</p><h3>5.2 AI加速</h3><p>随着边缘AI的兴起，越来越多的嵌入式处理器开始集成AI加速单元，如NPU（神经网络处理单元）。</p><p>这些专用硬件能够大幅提升神经网络推理的效率。</p><h3>5.3 安全特性</h3><p>安全性在嵌入式系统中越来越重要。</p><p>现代处理器普遍集成了硬件安全模块，如TrustZone、安全启动、加密引擎等。</p><h3>5.4 开源架构</h3><p>RISC-V等开源架构的兴起，为嵌入式处理器市场带来了新的活力。</p><p>开源架构的优势在于灵活性和可定制性，能够满足特定应用的需求。</p><h2>6. 总结</h2><p>嵌入式处理器架构是一个博大精深的领域，涉及硬件设计、指令集、编译器、操作系统等多个层面。</p><p>作为嵌入式开发者，我们不需要成为架构设计专家，但需要对常见架构有基本的了解，这样才能在项目中做出正确的技术选择。</p><p>在我的职业生涯中，从51单片机到ARM，从简单的裸机程序到复杂的Linux系统，每一次架构的转变都是一次技术能力的提升。</p><p>我的建议是：先深入掌握一种主流架构（比如ARM），然后再去了解其他架构，这样能够建立起系统的知识体系。</p><p>随着技术的发展，新的处理器架构不断涌现，但核心的设计理念是相通的。</p><p>只要掌握了基本原理，学习新架构就会变得容易很多。</p><p>希望这篇文章能够帮助大家建立起对嵌入式处理器架构的整体认识，在实际项目中能够做出更好的技术决策。</p><p><strong>更多编程学习资源</strong></p><ul><li><a href="https://link.segmentfault.com/?enc=3pwJEr37SU15iOHL7MpVrg%3D%3D.ER12f9oP9bUrmutp7VmJKU111huBqmTfMj1BiRP1Tw9jrbc%2F8SZvgoqY6b0asAkPkMKTla6nsmGRVkHDLETEzQ%3D%3D" rel="nofollow" target="_blank">C语言零基础入门电子书-2026最新版</a></li><li><a href="https://link.segmentfault.com/?enc=pW2Kf3Y4dlUkQ7bSoR1Jsg%3D%3D.UoSinbD7qc1XsmSVe0KAK%2Fjy3qA35PqMMDDAd37393Ydil70EHkzlkyXamQklPVuVF6QabBP0FqoD3%2FzHsetxw%3D%3D" rel="nofollow" target="_blank">STM32零基础入门电子书-2026最新版</a></li><li><a href="https://link.segmentfault.com/?enc=AdMWySbNpwUVzUtgnBkZ8g%3D%3D.gwc6tX7rHtoCEwtqfkQ%2FOlr1tQtcOcOvqOKPxminKw21Q23CdHxpQfDj2DipzE0K9vrV2vNepOxrl%2FAS6UKGZ86XozAEqX7jLy5kKgX8K%2BA%3D" rel="nofollow" target="_blank">FreeRTOS零基础入门电子书-2026最新版</a></li><li><a href="https://link.segmentfault.com/?enc=JlnEvXVxqKElHyZ3XJ%2BZqA%3D%3D.JDWfXB04gF8Y3ZAsA6wOkqAImhRvsXeoindh%2FSqJkk9A8R8lvtyKIc8VXMgbZuPhlWsVHsiDuaGM2DaDSaP2LQ%3D%3D" rel="nofollow" target="_blank">C++ 零基础入门电子书-2026最新版</a></li><li><a href="https://link.segmentfault.com/?enc=Ham2mFpd%2FY7E70lx0t1xCg%3D%3D.p%2F%2F%2B7ecHx7gfTsHeTmq1fmuAtntW3wQ4f6hbLtpe7J%2F08Bp%2BTNiAWlYibGKynMV%2FhCTKz3f64cWymizZFn3H%2FQ%3D%3D" rel="nofollow" target="_blank">51单片机零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=vwI8v%2FiP1Ja0QbjnpulTsw%3D%3D.XNgC0bOLVYAIX2l0zrzSzcCUAXQU6CDaSNnLE4fwFIgyMpk8icgi6tHqGxPco2N8nqyVymeKkhyQualspi6tmw%3D%3D" rel="nofollow" target="_blank">AD画板零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=tA9of6ZP20DY1Q9ILmIRwQ%3D%3D.6eFmf9Zba47YJLFtDAo786qmcuXUDxTu23D8I6NV2db9ai1Irc0%2BNw0bBRVy8SHN52km9u2NbvRIC2Dlq7MLVQ%3D%3D" rel="nofollow" target="_blank">C语言零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=dTiKBuYCvzsSjIdLr7FaVg%3D%3D.KpFyl6zDK57N0fA06EDzsOP535Cgkaut%2FadVkouTz3kV8PgBQ6jcCnU4vFGn3b9PQq3ft43YQJVTkFWJFkGCOQ%3D%3D" rel="nofollow" target="_blank">C++语言零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=yR4PLJU0QeSbIRlM37PliA%3D%3D.KzwpnvnWVTWu7KMrCI0kO80gRdPWgeXPZN9SCQgATDOq3nvj%2FTtcaY1sLVvJwhHw%2F%2Bfs2FmvFsesHkyt%2Fx%2Fn2pMgZxT1WKd4IM4V8Z7AyJ4%3D" rel="nofollow" target="_blank">ESP32零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=Il06SO1Q0hDPGIDEKeK31A%3D%3D.ApIaLzdSCaQBAZ6LlqCyJTzf1C5aN5A9o%2BCDHsN5GKzHf97M5lBoYQSSnLUQ2Qpx%2Bna4HYk3Qx8H2UZ%2Fk1neoRWSLZE7yvjT2zZ7BV0h%2Fgg%3D" rel="nofollow" target="_blank">FreeRTOS零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=IvzVHcmzMZId%2FUu8tTTvdA%3D%3D.Lh8RD%2BQTO%2BOFgVfm6kxLMWUk%2FBs91JujT3zAThiKco9FkZ8qyc2Wjs83zmut7fqGTX9iyXym0bEhisLB7sGqo%2F1uKXAysCLhPdGIPH6OlrM%3D" rel="nofollow" target="_blank">Linux应用开发零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=wqjFSxl2hwrePSwHzOV64w%3D%3D.GlkgkAvhVQcNCloNlU85Y9bnlXyf5I%2FvmsKqmG11TCuwvIDuyfhflCcwYw94CXXRd4hHhkQmlYcjBYbQpjX%2F77Nkqlt3nBrA%2B4GrJtO7p0Y%3D" rel="nofollow" target="_blank">Linux底层开发零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=dlchjKLca21omuDnwKrf5A%3D%3D.c4OmquowV5JW2bs6%2F1mrVNOySSKahCScyAHNewwDvS%2FsvXyM6RNCNB4SoeNqKsJ6fYW%2B5bMV5MwA%2BJAl9Brq8A%3D%3D" rel="nofollow" target="_blank">LVGL零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=yPnGM%2BabZbrLET4roslS0w%3D%3D.2ff8gEnJV7ALK8CK6b8Ko%2FWGQo3689VfEC4FFXHpZDGp%2F1LfUTU%2B36Law6qLcHrN46AvunNopbFySRMUg6vkCg%3D%3D" rel="nofollow" target="_blank">QT零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=ra2JWnQJZJdBjExEAmt8tg%3D%3D.vMZ5pb%2FGtmr%2BwvSnipjKYdXO2ZLQB1bZYSJUUGXoW3l%2FoWoNZUweZj19uQcBZOmXu%2F0T8eAooVDypn0N6hT6c%2BzQ54JKADmHNHmGw9A89RQ%3D" rel="nofollow" target="_blank">STM32零基础入门学习路线</a></li></ul>]]></description></item><item>    <title><![CDATA[【TVM教程】TensorIR 超神经HyperAI ]]></title>    <link>https://segmentfault.com/a/1190000047600854</link>    <guid>https://segmentfault.com/a/1190000047600854</guid>    <pubDate>2026-02-09 11:06:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>TVM 现已更新到 0.21.0 版本，TVM 中文文档已经和新版本对齐。</p><p>Apache TVM 是一个深度的深度学习编译框架，适用于 CPU、GPU 和各种机器学习加速芯片。</p><p>在线运行 TVM 学习教程→<a href="https://link.segmentfault.com/?enc=raR1AhWPiWDTPmyIp4oI6Q%3D%3D.XjKFO3TWVpS4aUmR%2BbH7z61kOYziM1NnQwASZL%2BWZOg%3D" rel="nofollow" target="_blank">https://go.hyper.ai/PEh1Q</a></p><p>TensorIR 是 Apache TVM 栈中的核心抽象之一，用于表示和优化原始的张量函数。</p><ul><li><p><a href="https://link.segmentfault.com/?enc=zfkyRHm8I2z8HbFh%2B5ISfA%3D%3D.zVOUuAJiUzJx91SaXz9mamDGF1d%2FzMmpcfAWWqjzoRqj%2Be9KzrXWsGmL8p%2FblTsAT0xtxVOM8vmDy5YzXuB0p7Q3DxodOGvnRGP9US4WkU4%3D" rel="nofollow" target="_blank">张量程序抽象</a></p><ul><li><a href="https://link.segmentfault.com/?enc=%2BNB9hEvekQtSqB9kkbXExA%3D%3D.Iv9WIitAty%2Bm1WpNBK90aPH229b7SofjjEr5Y3o%2FYENF9%2Bd6Dw8yoI1u1fJ5it4%2FXPJ68Yyfyp6gDjcW4DohKZoyYrbO%2FOAvisqgEn4EnKtpbgCrTdK9pv2w6zAeCNNJNRm%2BHZPN02UWDBwjJ%2FmWOAEyn%2BEzVYeVG7OAtHUlbVMNKeRhvL%2FBrIToVpD%2FtPev8tNf54GiB1jt%2BkrjxF93Lg%3D%3D" rel="nofollow" target="_blank">张量程序的关键元素</a></li><li><a href="https://link.segmentfault.com/?enc=JYw0hlFiDD67Ja6P0xUXjg%3D%3D.SDmFhupj1FvXAW0uJ4hjyK%2FzADT6qVc3OwUJm71zAuqVnDgNywbo3FdLkNBrr1o3X8WbEihiR5C%2F4Kt%2BqvMG%2Fvl1BW4jLVhCns8P1meFxYHt65OVkWpb3QHa6edbIh4FyMbSnENzVF%2FZcnqnjPTa2jV2JC8%2BxIu%2FPK20Mwp7vXn9jlSdrbuKQDUXCh%2Ft2OCj" rel="nofollow" target="_blank">TensorIR 中的额外结构</a></li></ul></li><li><p><a href="https://link.segmentfault.com/?enc=dHgGPvD024fPdkIwduMUpA%3D%3D.%2FHMZP0EVjtydBwk8jX02Q2%2FILRQq8CK0FcfPnZ%2B5lka%2BrPpAnTCH7d%2B2%2BbX2e3F8lteX%2Fvpw3CwpnLH32Q2ferMNCfP1A60fytRskGsLbDg%3D" rel="nofollow" target="_blank">理解 TensorIR 抽象</a></p><ul><li><a href="https://link.segmentfault.com/?enc=TkAvZjJ2W5SOZ1B3ZHcckA%3D%3D.1%2B6YPwxPmYa1uNAZkGjnfDRygs9q38VisOpiTOLUHhY9MZsAC%2FYrPRWCVyJ44YwpoBHY1VHcKgg1YnBzCStt8Qa%2FQmXEOnjAJNCf6%2B9Y5LrzHMHLwWSg4j7GcxJBX2TFMwyC3qnpV2d1dAYJwBIz1biiqybLxPJRr3s3f0qxs32M2GLNalWaZf04UN7Im2sAfNOQ8qg3xIto2A%2FnmHQoPQ%3D%3D" rel="nofollow" target="_blank">函数参数与缓冲区</a></li><li><a href="https://link.segmentfault.com/?enc=QVHo1lPT5iWT2I2Jj6TUcw%3D%3D.0Wsrot8iWC1EC%2BG1fmuj8clrJ2mcC74qqK3mkr6aB79mcIdLKKmFpKmM7iqI7NfRo%2B%2BFYX8tmTyMLJF6mTO62Egre0nBxvSQImcwqtrub1CFExSY67wiEF9dIarW%2F31PhQKIMRwOQMHOqy17bOwqkObmLtil7Jj1ZVXzZR65UqQ%3D" rel="nofollow" target="_blank">循环迭代</a></li><li><a href="https://link.segmentfault.com/?enc=4q5RGsvp%2BT9DAG06Gq4YuA%3D%3D.XAsyNP8EsqV3EUzyOuqJwTGpBBS2nlEYTNlT5isGrAHmU1hFXTzlKuHutsrsgNJY%2FSa80RfQPWAN3NNEaton8nFbPp6Vw%2B0uRl8r%2Bl5VlOIMPRQFYrawRlFn1LcpfmXMNGvj3nFMpnMM%2FXC%2BygRptw%3D%3D" rel="nofollow" target="_blank">计算块</a></li><li><a href="https://link.segmentfault.com/?enc=UN9ZFy3iDUGpCQkrZvjHLw%3D%3D.PwtO0m6hVyK4%2FBj4Qq1a%2BPNZ8pXZ3pVwsCpnzzxof%2BIFIAFVDIkwOABWyLdA9tHySjLHD%2FqLR1mX1KmJfIMZt5muM1Xwdc9zFlZpGJG9heiyCpI9bqsUW0PZsJhYNWb8poiNXtP8tiNSQXNRSIUArOtEsqWiu0c7036GC62ckSY%3D" rel="nofollow" target="_blank">块轴属性</a></li><li><a href="https://link.segmentfault.com/?enc=zpvMjKTERNTmsunrB2LutQ%3D%3D.o3IhN0Fn1cxhAilIOw09wudZc3xEqPqXoRkE5B06abqyx2HwcMf33pI9x%2FmvKrkB4G9i%2BDmCMFzqxz0qgo1hWbbvcoPoxux%2FIHCwOjV%2BL8ZhVcP0ehzO3HeUheyH%2FsU8SeU4QaO%2B06BXk05hklittLaFBUNmiuPZYJUPd6Tfg1Y4vpIQSbQBPJUdbnh0L6f7wi5%2FBvpuFZ0xAqoBTDNXvUgp9d508ju%2FhrBuV9xS%2FSYscfBWGHUiaRe4PPSJTvhu" rel="nofollow" target="_blank">为什么计算块中需要额外信息</a></li><li><a href="https://link.segmentfault.com/?enc=JwwhCEWWBb1s73jEQcPJ1w%3D%3D.8DYZlSUEkh50slaZlT5MwksYS8Q6Vw54DDhCXSiMx%2Bai63mPx%2BN4eej9w1A%2BSE5b6Ly0dRBrRNTxa7xsy04XtZBhfxu3yWLDUayV89ORpMILvrDTc6OJdUrIeJVtSNLgRY%2FvoW3Hnnyf4AyglrkcnaJQ%2F84LU1kloJpPadNnm7U0R2stUfx7uXyVv16MM%2FpM" rel="nofollow" target="_blank">绑定块轴的语法</a></li></ul></li><li><p><a href="https://link.segmentfault.com/?enc=9WDjaYu454Xlbbtu0%2Fi1Vg%3D%3D.C9Fg4dk6BqvpL3SGQjSQ9BtXz%2FhjLtPE6umCEp3hRq%2BX4R%2BPb80JxGbP0kl%2BRsT%2FsE0NgeBPfk94uFn1mVKLfA%3D%3D" rel="nofollow" target="_blank">TensorIR 的创建</a></p><ul><li><a href="https://link.segmentfault.com/?enc=1n2A0ian9WP3w590V20rng%3D%3D.bi7GWmBeXWG9WO7H%2FZRG0vC5f1KRJMLwUB%2FOMX8XZ0suYPXTZaKW2ohdUkMmM37IVaeKRFIvtY%2FpxbutR4fOcGbGWTuw%2FpMLY8QEh%2F0OQPHv1vs5yx%2F8FZ859KCwrRobBdXvK3nMV0kho0qeyZ4LH4jc8pPeqXIcripT5BXOlqA%3D" rel="nofollow" target="_blank">使用 TVMScript 创建 TensorIR</a></li><li><a href="https://link.segmentfault.com/?enc=s9co8J%2BB62UkoBQbaDRUmw%3D%3D.VbMJiJMdgivt1nwUtS0C%2BM82X4TUdQztfaWKnmAH12IB09JrTgtZxUxC2DG5eOHSRixV%2BKTCumjB1MCyodQPPxbLTmLKXAOkaAqFcDqjhqQJoU%2B7MqCT6XHXwt8fLZk7E7d51wv0uA%2FlWZy7q3aV5KrgQSOPbra3X7X0%2FkmKilA%3D" rel="nofollow" target="_blank">使用张量表达式创建 TensorIR</a></li></ul></li><li><p><a href="https://link.segmentfault.com/?enc=Lp4Vmg98eATcsrTIqmnbDw%3D%3D.9Brv1fBw%2BLotD25erEIuFeHIzdRCKb3uz8R0j79nLVBxbOxMXnfMoyfdgCPqvdYNcdBFXQMwG4fBVfRqCibA5w%3D%3D" rel="nofollow" target="_blank">转换</a></p><ul><li><a href="https://link.segmentfault.com/?enc=ClNAY2aqjz5XUK%2BtFFWpmQ%3D%3D.9wsX2iv8dq9eC9iBZ%2F6LW1ASXQYffctZGpKD0jEICUhh2wqibwDUwpkXvzVVeTMvPCzRVTeRq0Px%2BAPeND7qJmqzn78c8%2Bg3orsIxBFhCgJeuju0d4mdNZ3EsBEbyYr%2Fjg55wMxMvE4KXbURxU%2B9Bg%3D%3D" rel="nofollow" target="_blank">初始化调度</a></li><li><a href="https://link.segmentfault.com/?enc=ttkmF7DlYD9XvwKqFWosrQ%3D%3D.%2BmcE%2FWmyMLE5SAxAJYUrMw9T%2FpawXq0%2BfFKIIBsi%2BUaKzdPfCIugPvwUoIGRDaATbfIbT8hUdJVuAAvN0957gEIBtQh7iSHtD1DdYMnncVvbloU5Iop0zeV4qb0zF0%2FkHzYizIcHJp63s8ihwFovZg%3D%3D" rel="nofollow" target="_blank">循环切分（Tiling）</a></li><li><a href="https://link.segmentfault.com/?enc=q6wfEqGEB7neHYC8GqI9Lg%3D%3D.%2FUqcSjC8WVr3Lz7avuKjhd34kJEsCNZgJVP87lksIQJmEGyoYpN0QemteZxxcdZFXIrr3zTytnTRp%2Fjlk07Tq%2B%2Fiwkyz%2BvzbXpcwsQfW5eC4c5Lfeo2u3wa2cwSIBOzmP%2BgFMLIbAtHWauEXfI0dCg%3D%3D" rel="nofollow" target="_blank">利用数据局部性</a></li><li><a href="https://link.segmentfault.com/?enc=MyCs5aDHVsjqHZtJjZW63Q%3D%3D.DSjMVENgj4H0RRhDpCnLjbwrD7wo7IgZA4Uul25TR9OamGJoV373wbhk2mJ8V7D2z1LIClZynKlS%2BGQ03VBM%2FxinTygW6tKEpFj5KGUrTBZF%2Ft7VFPB%2FMSwDxFiAKqo%2BH1qQRoriovvIueJ9kVV4YfhF7zbLg904Pwyb43q8qdU%3D" rel="nofollow" target="_blank">重写归约操作</a></li><li><a href="https://link.segmentfault.com/?enc=ZP15so1LMQIXfCC0gPTdZQ%3D%3D.SUXKLlT%2BmAp3yWIiGosLpepcVkxpChOrxfTy4qMYyfjI9XBnaIt2TWy0RsmNB76zWoXQQi5OdWcxPfe%2FTMuu6HidjqNPKonlvuPSTb9kEch05j7qsRlqqlmIDhhexfzWsvVf5hlMHzUMjkFpwNly6g%3D%3D" rel="nofollow" target="_blank">追踪变换过程</a></li></ul></li></ul>]]></description></item><item>    <title><![CDATA[Antigravity-Manager：AI 多账号管家 + API 反代 BugShare ]]></title>    <link>https://segmentfault.com/a/1190000047600869</link>    <guid>https://segmentfault.com/a/1190000047600869</guid>    <pubDate>2026-02-09 11:06:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在 AI 应用日益增长的今天，开发者往往需要同时管理多个服务账号（如 OpenAI、Claude、Gemini 等），并期望将这些服务统一调度、并在本地或服务器上稳定运行。<br/><strong>Antigravity-Manager</strong> 正是这样一款强大的开源工具，它不仅具备专业的账号管理功能，还支持协议转换、中继代理等高级功能，可以与 Claude Code CLI 等客户端无缝集成，让你的 AI 调用更稳定、更智能。</p><hr/><h2>一、Antigravity-Manager 是什么？</h2><p><strong>Antigravity-Manager</strong> 是由社区开发的一款跨平台（Windows / macOS / Linux）桌面应用，用于：</p><ul><li>🧠 <strong>账号管理与一键切换</strong> 多个 AI 服务账号；</li><li>🚀 <strong>协议转换与反代代理</strong>，兼容 OpenAI、Anthropic（Claude CLI）和 Gemini 等；</li><li>⚙️ <strong>智能调度与模型路由</strong>，实现配额管理和请求优先级调度。</li></ul><p>简而言之，它是一个“全能 AI 账号管家 + 本地反代服务端”，帮助你构建个人或团队级的 AI 调用网关。</p><hr/><h2>二、为何使用“账号管理”？</h2><p>在多个 AI 平台同时使用时，你可能面临这些痛点：</p><ul><li>📉 单一账号配额耗尽导致请求失败；</li><li>🔁 切换账号繁琐、缺少一体化管理；</li><li>🔒 难以实时查看每个账号的配额与状态；</li><li>🧠 结合 CLI 工具时，没有统一反代入口。</li></ul><p><strong>Antigravity-Manager 的账号管理（Account Management）模块</strong>正是为了解决这些问题设计的，它提供了 <strong>OAuth 授权、Token 导入、403 自动标注、账号状态健康监控等全套功能</strong>。</p><hr/><h2>三、安装 Antigravity-Manager</h2><p>安装方式非常灵活，覆盖桌面以及服务器环境。</p><h3>✔️ 方式 1：桌面安装（推荐）</h3><p>macOS / Linux（推荐）</p><p>如果你已安装 <strong>Homebrew</strong>：</p><pre><code class="bash">brew tap lbjlaq/antigravity-manager https://github.com/lbjlaq/Antigravity-Manager
brew install --cask antigravity-tools</code></pre><p>安装完成后直接运行客户端进入可视化管理界面。</p><hr/><h3>🪟 方式 2：手动下载安装</h3><p>访问 GitHub Releases 页面，下载对应系统的安装包：</p><p>📦 macOS：<code>.dmg</code><br/>💻 Windows：<code>.msi</code> / <code>.zip</code><br/>🐧 Linux：<code>.deb</code> / <code>AppImage</code><br/>（支持 Apple Silicon、Intel 等主流架构）</p><hr/><h3>🐳 方式 3：Docker 部署（服务器 &amp; NAS）</h3><p>如果希望在NAS/服务器长期运行，可参考：</p><pre><code class="bash">docker run -d \
    --name antigravity-manager \
  -p 8045:8045 \
  -e API_KEY=sk-your-api-key \
  -e WEB_PASSWORD=your-login-password \
  -v ~/.antigravity_tools:/root/.antigravity_tools \
  lbjlaq/antigravity-manager:latest

#### 🔐 鉴权逻辑说明
*   **场景 A：仅设置了 `API_KEY`**
    - **Web 登录**：使用 `API_KEY` 进入后台。
    - **API 调用**：使用 `API_KEY` 进行 AI 请求鉴权。
*   **场景 B：同时设置了 `API_KEY` 和 `WEB_PASSWORD` (推荐)**
    - **Web 登录**：**必须**使用 `WEB_PASSWORD`，使用 API Key 将被拒绝（更安全）。
    - **API 调用**：统一使用 `API_KEY`。这样您可以将 API Key 分发给成员，而保留密码仅供管理员使用。</code></pre><p>这样 Antigravity-Manager 会在容器内自动启动前端服务和反代代理。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600872" alt="PixPin_2026-02-07_19-53-26.png" title="PixPin_2026-02-07_19-53-26.png"/></p><hr/><h2>四、管理账号与接入 Claude Code CLI</h2><h3>🔑 1. 添加账号（OAuth / Token）</h3><p>打开客户端 → “Accounts / 账号” → “添加账号”，你可以：</p><ul><li>使用 <strong>OAuth 2.0 授权</strong> 添加账号，工具会提前生成授权链接，在浏览器完成登录授权后自动保存；</li><li>或者通过 <strong>Token / JSON 批量导入</strong> 已有的 API Key/Session，适合已有账号备份迁移。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600873" alt="1770467416323.png" title="1770467416323.png" loading="lazy"/></p><hr/><h3>📊 2. 账号仪表盘与健康监控</h3><p>在仪表盘中，你可以：</p><ul><li>实时查看账号类型、剩余配额、是否被禁用；</li><li>系统自动标注异常账号（例如 403 禁用），并跳过这些账号；</li><li>一键切换活跃账号，快速调度调用链路。</li></ul><p>这对管理多个付费 / 免费账号极为实用。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600874" alt="PixPin_2026-02-07_20-28-11.png" title="PixPin_2026-02-07_20-28-11.png" loading="lazy"/></p><hr/><h3>🛠 3. 接入 Claude Code CLI 反代</h3><p>Antigravity-Manager 内置了 <strong>Anthropic 协议的反代支持</strong>，可以让 Claude Code CLI 直接走本地代理。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600875" alt="PixPin_2026-02-07_20-33-42.png" title="PixPin_2026-02-07_20-33-42.png" loading="lazy"/></p><h4>📌 方式1：环境变量方式</h4><ol><li>在 Antigravity-Manager 内启用 <strong>API 反代服务</strong>；</li><li>在终端设置环境变量：</li></ol><pre><code class="bash">export ANTHROPIC_API_KEY="sk-antigravity"
export ANTHROPIC_BASE_URL="http://127.0.0.1:8045"</code></pre><ol start="3"><li>启动 <strong>Claude Code CLI</strong>：</li></ol><pre><code class="bash">claude</code></pre><h4>📌 方式2：直接点同步按钮（更爽）</h4><p>更贴心的是作者还提供了通过界面“立即同步配置”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600876" alt="1770467877401.png" title="1770467877401.png" loading="lazy"/></p><p>此时所有 CLI 请求将通过 Antigravity-Manager 的反代服务发出，你可以结合账号池调度，提高稳定性并统一管理日志与配额统计。</p><p>💡 这种方式尤其适用于开发者希望在本地终端环境使用 Claude CLI 工具时，有一个统一的代理层进行账号轮换和失败重试。</p><p>▶️ <strong>除了Claude Code CLI，还支持接入OpenCode、Kilo Code、Python</strong>（可以愉快的开发了）</p><h3>⚡ 4. 也可以启用国内智谱模型</h3><p>如果你需要混用国内模型，只要填 Key 即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600877" alt="PixPin_2026-02-07_20-49-10.png" title="PixPin_2026-02-07_20-49-10.png" loading="lazy"/></p><hr/><h2>五、使用建议与实战技巧</h2><p>✨ <strong>优化账号池</strong>：将高配额账号置于优先队列，并根据使用场景动态切换，提升成功率。</p><p>✨ <strong>批量导入</strong>：对于大量账号可以提前通过 JSON 导入，避免重复手动输入。</p><p>✨ <strong>结合 CLI 监控日志</strong>：在反代运行中，务必监控 HTTP 返回码（如 429/401）以调整请求策略。</p><p>⚠️ <strong>注意安全</strong>：OAuth 回调是通过本地监听实现的，确保防火墙允许本地回环访问，避免授权失败。</p><hr/><h2>六、总结</h2><p>🚀 <strong>Antigravity-Manager</strong> 不仅是一款强大的 <strong>AI 账号管理工具</strong>，还具备协议反代、模型路由、健康监控等丰富功能。通过它，你可以：</p><p>✔️ 一站式管理多个 AI 平台账号；<br/>✔️ 实现账号配额优先级调度和自动异常跳过；<br/>✔️ 在本地通过反代接入 <strong>Claude Code CLI</strong> 等客户端；<br/>✔️ 提升稳定性、可视化管理体验、避免手动切换误操作。</p><p>无论你是 AI 开发者、研究者，还是需要在终端高效使用 Claude 工具的用户，都可以从 Antigravity-Manager 中受益。</p>]]></description></item><item>    <title><![CDATA[云流技术深度剖析：国内云渲染主流技术与开源和海外厂商技术实测对比 点量实时云渲染 ]]></title>    <link>https://segmentfault.com/a/1190000047600903</link>    <guid>https://segmentfault.com/a/1190000047600903</guid>    <pubDate>2026-02-09 11:05:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在实时云渲染领域，除了国内近几年涌现出几家做实时云渲染（云流）的厂商，满足云游戏、云VR、3D软件云展现等场景的需求外，其实市面上还有一些海外技术方案，甚至也有一些大家关心的开源技术方案，他们各有技术亮点，但实际表现因架构设计、优化方向不同而有一些差异。</p><p>本文就给大家带来这一领域真实的多个产品的介绍，并基于真实硬件环境与统一测试标准，对英伟达Moonlight、金山云鎏光、Parsec及点量云流四款主流方案进行实测对比，从延迟、兼容性、功能完整性等核心维度展开分析，既呈现各方案的技术特点，也为行业选型提供客观参考。</p><h2>一、测试环境与评估标准：保证对比测试的客观性</h2><p>为确保测试结果的公正性与参考价值，本次测试采用统一的硬件配置、网络环境与评估方法，所有数据均为多次实测取有效值：<br/>1、基础测试环境</p><ul><li>硬件配置：服务端均采用Intel i7- 8700K CPU、NVIDIA GTX 1080 GPU、32GB RAM；客户端选用Windows 10/Android 9.0客户端/网页。</li><li>网络环境：网络基于千兆局域网，弱网环境通过Clumsy工具模拟（丢包率 10%−60%、10%−60% 、延迟50- 500ms）。</li><li>测试工具：通过纳秒级时间同步软件生成实时时间戳，采用手机高速拍照抓取两端（真机和串流后的机器）画面差值，精准测量端到端延迟；同步测试多终端兼容性、长时间运行稳定性及不同场景（游戏、桌面、普通应用）的适配效果。</li></ul><p>弱网模拟工具设置的参数如下：<br/><img width="723" height="514" referrerpolicy="no-referrer" src="/img/bVdnTko" alt="" title=""/></p><p>2、核心评估维度<br/>本次对比围绕实时云渲染的核心需求，设立5个关键评估维度：</p><ul><li>延迟表现：含局域网正常网络、弱网环境下的端到端延迟及稳定性；</li><li>兼容性：涵盖GPU适配、终端支持（Windows/Android/iOS/Chrome等）、应用场景适配（游戏/桌面/普通软件）；</li><li>传输与编码：传输协议选型、编码格式支持及弱网抗丢包能力；</li><li>功能完整性：容器化隔离、多用户并发、扩展能力（SDK/API）；</li><li>易用性：部署复杂度、无插件访问支持。</li></ul><h2>二、主流方案实测表现</h2><p>1、英伟达Moonlight：开源方案游戏串流方案<br/>作为基于NVIDIA GameStream的开源串流工具，Moonlight的核心优势集中在游戏场景的低延迟传输。其地址为：<a href="https://link.segmentfault.com/?enc=8i0SEqw7ZVhHD2%2BQq2JTkA%3D%3D.KUgaRSqj2kx1kbnOCMWbLSRELlcEjg%2BjKTOuxCQpymFhd%2FKF1KJbZIZWypbZHrfn" rel="nofollow" target="_blank">https://github.com/moonlight-stream</a></p><p>测试结果如下：</p><ul><li>实测核心数据：局域网正常环境下延迟稳定在18~19ms，长时间运行（30分钟）无波动，均为18~19ms延迟；弱网环境（10%丢包+50ms延迟）下延迟波动至18-35ms，画面无明显花屏。</li><li>客户端兼容性：支持windows、android、iOS等客户端模式，chrome下是通过Extension扩展的方式进行支持，不如WebRTC更具通用性。</li><li>技术特点分析：基于RTSP传输协议并结合了FEC纠错，支持HEVC编码与120fps高刷新率、7.1环绕声支持；客户端基于ffmpeg+sdI进行解码播放；开源特性使其具备一定定制空间。</li><li>局限与不足：英伟达出品，自然GPU有限性，仅支持NVIDIA相关系列显卡（NVIDIA GeForceGTX/RTX600+系列GPU），不兼容AMD及集成显卡；Web端需通过Chrome扩展实现访问，操作便捷性不足；仅聚焦游戏串流，不支持桌面串流和普通软件（如CAD等软件）流化。</li></ul><p>测试截图如下：<br/><img width="723" height="337" referrerpolicy="no-referrer" src="/img/bVdnTkp" alt="" title="" loading="lazy"/></p><p>2、金山云鎏光：原型级方案，具备超低延迟潜力<br/>鎏光是金山云推出的云游戏引擎原型，核心亮点是极致的延迟控制，<a href="https://link.segmentfault.com/?enc=TwTADO%2FNXku%2BGzVpdXqcVQ%3D%3D.B4qr1cUnjrjTp%2BkSW00fccbJsnGftnGA6lvA0UtIRvc%3D" rel="nofollow" target="_blank">https://github.com/ksyun-</a> kenc/liyuguang</p><ul><li>实测核心数据：局域网环境下延迟表现突出，多次捕获0ms同步画面，平均延迟0-17ms；即使在60%丢包+500ms延迟的极端弱网环境下，仍能保持0-17ms的低延迟水平，抗丢包能力亮眼。（注意：0ms，并不代表该方案是0延迟，是因为我们的测试方法是基于2台显示器的拍照，显示器在60fps下，也有大概16.7ms的刷新率延迟。如果整体端对端延迟小于16.7ms的显示器刷新率，在同一次显示器刷新间隔中，画面就显示出来了，看到的效果就是完全一样的画面，也就是0ms延迟。）</li><li>客户端兼容性：提供Windows客户端（但未开源），暂不支持android、iOS和chrome浏览器。</li><li>技术特点分析：基于WebSocket传输协议，编码解码采用FFmpeg+SDL架构，在游戏画面捕获与传输的延迟控制上表现出色。</li><li>局限与不足：目前仅支持Windows客户端，未开源且缺乏Android、iOS、Web等多终端适配；功能处于原型阶段，展现的是核心功能，方便用户进行扩展，应该是为了金山云跟游戏厂商的云游戏战略服务。功能上欠缺不少产品化的功能：比如不支持桌面抓取、多应用实例隔离等商用必备功能，无法直接用于产品级落地。</li></ul><p>测试截图如下：<br/><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnTkq" alt="" title="" loading="lazy"/><br/><img width="723" height="549" referrerpolicy="no-referrer" src="/img/bVdnTkr" alt="" title="" loading="lazy"/></p><p>3、Parsec：海外商业软件的优秀全终端方案<br/>Parsec是兼具云游戏与远程控制功能的商业软件，主打多终端覆盖与易用性。</p><ul><li>延迟核心数据：局域网环境下延迟27-41ms，5分钟后稳定在30ms左右；弱网环境下延迟增加10-15ms，整体波动至37-56ms，延迟控制略逊于前两款方案（可能是要考虑他综合用途的兼容性，并不是专门为云游戏、云VR等设计超低延迟），但稳定性良好。</li><li>客户端兼容性：作为一款商业软件，该产品支持超级多终端，包括Windows、Android、iOS、Linux、Chrome浏览器，甚至还有树莓派等，生态完整。</li><li>技术特点：终端支持全面，产品化优秀，部署简单，通过账号登录即可快速连接，无需复杂配置，适合非技术用户快速上手。</li><li>局限与不足：延迟表现处于行业中等水平，无明显优势；GPU兼容性存在短板，部分旧款或低端GPU易出现驱动不兼容问题；商业授权模式下，定制化与扩展能力有限。</li></ul><p>测试截图如下：<br/><img width="723" height="549" referrerpolicy="no-referrer" src="/img/bVdnTkt" alt="" title="" loading="lazy"/></p><p>4、点量云流：兼顾低延迟与全场景适配的商用方案</p><ul><li>延迟核心数据：局域网环境下表现最优，多次捕获0ms同步画面，平均延迟0-16ms，长时间运行（30分钟）无波动；弱网环境下延迟稳定在10-30ms，抗丢包能力与鉴光相当，且画面无卡顿花屏；跨终端测试中，Windows、Android、Chrome端延迟一致性良好，差值不超过5ms。</li><li>客户端兼容性：提供Windows、Android、国产信创系统（Linux等）客户端，据官方说明，有iOS客户端，但考虑商用客户需求，需客户自行上架。支持Chrome、Edge、微信、QQ、360、Safari等主流浏览器。</li><li>技术特点分析：传输协议客户端采用DLCA（未有详细资料，系该公司自研，据介绍底层支持UDP、TCP、RTSP等协议混合模式切换）；网页端基于深度调优的WebRTC协议；底层代码采用C++11全自主开发，部分应用层为GoLang语言开发，支持国产信创系统和部分国产显卡，并支持软硬解、软硬编切换，终端支持良好，可在华为智慧屏、机顶盒等终端上实现4K/60fps稳定输出。</li><li>优势亮点：具备成熟的容器化隔离技术（其官方介绍为CELL多开机制，应该类似沙盒的某种轻量级隔离技术），支持多实例进程隔离，除支持UE、Unity等3D引擎外，还支持AutoCAD、CATIA、SolidWorks等众多设计软件，可实现多应用同时流化且互不干扰；提供SDK模式，支持权限控制、负载均衡、文件传输等商用扩展功能，适配更多行业场景。</li></ul><p>测试截图如下：<br/><img width="723" height="550" referrerpolicy="no-referrer" src="/img/bVdnTkw" alt="" title="" loading="lazy"/></p><h2>三、综合对比与选型建议：客观看待优势与适配场景</h2><p>主流方案核心指标综合对比<br/><img width="657" height="459" referrerpolicy="no-referrer" src="/img/bVdnTkC" alt="" title="" loading="lazy"/></p><p>实时云渲染的技术竞争，其实要追溯到全流程的环节，从死磕画面获取--视频编码--低延迟传输--视频解码--画面低延迟显示绘制。到应用的多开隔离、功能完善度、API接口齐全程度、客户端视频兼容性、国产信创适配度等，最终是场景适配能力的全方位竞争。一个产品最终的特性，是全链路技术优化，而不是某一个环节的优化。更是要与商用需求的精准匹配。</p><p>对于企业而言，选型时应优先明确自身场景的核心诉求（延迟、兼容性、扩展性），再结合实测数据做出判断——这也是本次对比的核心意义所在。</p>]]></description></item><item>    <title><![CDATA[音视频 SDK：连接虚拟与现实的数字桥梁 Amymaomao ]]></title>    <link>https://segmentfault.com/a/1190000047600909</link>    <guid>https://segmentfault.com/a/1190000047600909</guid>    <pubDate>2026-02-09 11:04:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>音视频 SDK：连接虚拟与现实的数字桥梁</p><p>在数字化浪潮中，音视频交互已成为社交、办公、娱乐的标配。无论是微信视频通话、腾讯会议，还是抖音直播，其背后都离不开一个强大的技术底座——音视频 SDK。它就像一座桥梁，将物理世界的声光信号转化为数字世界的比特流，再通过算法优化，为用户提供清晰、流畅、实时的沟通体验。</p><p>一、 什么是音视频 SDK？</p><p>音视频 SDK 是一套软件开发工具包，它封装了音视频采集、编码、传输、解码、渲染等底层技术细节。开发者无需从零研究复杂的音视频编解码协议（如 H.264/H.265）或网络传输协议（如 RTP/RTCP），只需调用 SDK 提供的简单 API，即可快速构建具备专业级音视频能力的应用。</p><p>核心价值：</p><p>• 降本增效：将开发周期从数月缩短至数天，大幅降低技术门槛和人力成本。</p><p>• 专业稳定：由专业团队维护，提供经过海量用户验证的稳定性和抗弱网能力。</p><p>• 功能丰富：集成美颜、降噪、虚拟背景、屏幕共享等增值功能，提升产品竞争力。</p><p>二、 技术架构：从采集到播放的全链路</p><p>一个完整的音视频 SDK 通常包含以下核心模块：</p><ol><li><p>采集层（Capture）</p><p>◦ 音频：通过麦克风采集原始 PCM 数据。</p><p>◦ 视频：通过摄像头采集 YUV/RGB 格式的原始帧。</p></li><li><p>前处理层（Pre-processing）</p><p>◦ 音频：进行 3A 处理（AEC 回声消除、ANS 降噪、AGC 自动增益控制）。</p><p>◦ 视频：进行美颜、滤镜、虚拟背景、人脸识别等处理。</p></li><li><p>编码层（Encode）</p><p>◦ 将庞大的原始数据压缩成适合网络传输的码流（如 H.264/AVC、H.265/HEVC、AAC）。</p></li><li><p>传输层（Transport）</p><p>◦ 基于 UDP 或 QUIC 协议进行数据传输，通过智能路由、抗丢包算法（如 FEC、重传）保障弱网环境下的流畅性。</p></li><li><p>解码层（Decode）</p><p>◦ 将接收到的码流还原为原始数据。</p></li><li><p>后处理与渲染层（Render）</p><p>◦ 音频：进行混音、音效处理，输出到扬声器。</p><p>◦ 视频：进行画面裁剪、缩放，渲染到屏幕视图。</p></li></ol><p>三、 关键能力：衡量 SDK 优劣的标尺</p><p>在选择音视频 SDK 时，开发者应重点关注以下技术指标：</p><p>• 高音质（HD Audio）：支持 Opus、AAC 等高清编码，具备 AI 降噪和啸叫抑制能力。</p><p>• 高画质（HD Video）：支持 1080P/4K 分辨率，具备超分、HDR、低光照增强等画质优化技术。</p><p>• 低延迟（Low Latency）：端到端延迟控制在 100ms 以内，确保实时互动无卡顿。</p><p>• 抗弱网（Network Resilience）：在 80% 丢包环境下仍能保持通话，支持智能路由切换。</p><p>• 高兼容性（Compatibility）：覆盖 Android、iOS、Windows、macOS、Web 等全平台。</p><p>• 扩展性（Scalability）：支持万人互动直播、单房间超大规模通话等场景。</p><p>四、 应用场景：无处不在的实时互动</p><p>• 社交娱乐：视频相亲、语音房、在线 K 歌、游戏开黑。</p><p>• 远程办公：视频会议、远程面试、在线教育、屏幕共享。</p><p>• 物联网（IoT）：智能门铃、车载视频、无人机图传、安防监控。</p><p>五、 选型建议：如何选择适合的 SDK？</p><ol><li>明确业务场景：是 1v1 通话、多人会议，还是万人直播？不同场景对 SDK 的性能要求不同。</li><li>评估技术指标：对比不同厂商的延迟、卡顿率、首帧出图时间等数据。</li><li>测试集成体验：关注文档的完整性、Demo 的易用性以及技术支持响应速度。</li><li>考虑成本与合规：评估 License 费用、数据安全及 GDPR 等合规要求。</li></ol><p>音视频 SDK 是数字化转型的基础设施。随着 5G 和 AI 技术的发展，未来的 SDK 将更加智能化，深度融合 AI 视觉、空间音频、元宇宙交互等能力，为开发者打开更广阔的创新空间。选择一款稳定、高效、易用的 SDK，将是产品在激烈市场竞争中脱颖而出的关键。</p>]]></description></item><item>    <title><![CDATA[【Triton 教程】triton_language.cdiv 超神经HyperAI ]]></title>    <link>https://segmentfault.com/a/1190000047601091</link>    <guid>https://segmentfault.com/a/1190000047601091</guid>    <pubDate>2026-02-09 11:03:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Triton 是一种用于并行编程的语言和编译器。它旨在提供一个基于 Python 的编程环境，以高效编写自定义 DNN 计算内核，并能够在现代 GPU 硬件上以最大吞吐量运行。</p><p>*在线运行 Triton 学习教程 → <a href="https://link.segmentfault.com/?enc=ciGDhT1%2BbfCxoH%2F%2F4usu0A%3D%3D.YNtANz5x5asWF5DeT3ufpn%2BUwlE3EPQqjLTRBZNqjo4%3D" rel="nofollow" target="_blank">https://go.hyper.ai/wS9x1</a></p><pre><code class="js">triton.language.cdiv(x,div)</code></pre><p>计算 <code>x</code> 除以 <code>div</code> 的向上取整结果。</p><p>参数：</p><ul><li><strong>x</strong> (<em>Block</em>) - 输入数字。</li><li><strong>div</strong> (<em>Block</em>) - 除数。</li></ul><p>这个函数也可作为 <code>tensor</code> 的成员函数调用，例如 <code>x.div(...)</code> 而不是 <code>div(x, ...)</code>。</p>]]></description></item><item>    <title><![CDATA[Go语言真正强的领域是什么？ 王中阳讲编程 ]]></title>    <link>https://segmentfault.com/a/1190000047601102</link>    <guid>https://segmentfault.com/a/1190000047601102</guid>    <pubDate>2026-02-09 11:02:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Go 语言以并发实现简单而著称，现在无数云原生项目都在用它。甚至在人工智能领域，它也开始发力了。今天我们就来聊聊这个由谷歌推出的热门编程语言。<img referrerpolicy="no-referrer" src="/img/remote/1460000047601104" alt="" title=""/></p><p>问世十五年多了，Go 语言已经从技术爱好者眼里的“新鲜玩意儿”，成长为支撑全球关键云原生软件的成熟工具。</p><p>你可能好奇，为什么 Docker 和 Kubernetes 这些大项目都选 Go？这篇文章就是为了回答这个问题。我们会聊聊 Go 的核心特点，它和其他语言有什么不同，它最适合干什么，以及它现在的局限和未来。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601105" alt="" title="" loading="lazy"/></p><h2>Go 语言：小而简单</h2><p>Go（常被称为 Golang）是谷歌员工搞出来的，主要是 Rob Pike 这些 Unix 专家。不过它现在完全是由社区主导的开源项目。</p><p>Go 的设计初衷就是让人好学、好用。它的语法非常直观。和 C++ 这种功能繁多的语言比起来，Go 的功能集很小。它的风格有点像 C，所以如果你懂 C，上手 Go 会很快。不过，Go 在并发处理和函数式编程方面，其实吸收了不少 Erlang 这类语言的思想。</p><p>作为一个类 C 的通用语言，Go 在开发跨平台企业应用上和 Java 挺像。但因为它开发快、运行快，大家也常拿它和 Python 比，虽然它俩其实差别挺大。</p><p>官方文档说 Go 是“一种快速、静态类型的编译型语言，但用起来像动态类型解释型语言”。这话说得没错。就算是大项目，Go 编译起来也就是几秒钟的事。而且它没有 C 语言那种头文件和库引用的麻烦事。</p><h2>Go 语言好在哪？</h2><p>Go 通用、方便、高效、可移植，而且现在支持它的工具也多。这就是为什么大规模软件开发喜欢用它。咱们具体看看。</p><h3>用途广，上手快</h3><p>在解决常见编程问题时，Go 的效率经常被拿来和 Python 比。Go 内置了很多实用功能，比如协程（goroutine）让并发变得很轻量。标准库里的 <code>http</code> 包也很强大。和 Python 一样，Go 也有自动内存管理，不用你自己手动管理内存。</p><h3>速度比很多语言快</h3><p>Go 编译出来的程序，运行速度可能比 C 写的稍微慢一点点，但在绝大多数情况下，这个差距完全可以忽略不计。而在大多数任务中，Go 的性能接近 C，并且明显比 JavaScript、Python 和 Ruby 这些脚本语言快得多。</p><h3>哪儿都能跑，还不挑环境</h3><p>Go 编译出来的是独立的可执行文件，通常不需要依赖外部环境。它支持各种操作系统和硬件，跨平台编译也很容易。更重要的是，它既有高层抽象，又能直接访问底层系统。Go 程序可以直接调 C 库，也能执行原生系统调用。Docker 就是靠 Go 调用 Linux 的底层机制实现了容器功能。</p><h3>支持它的工具多</h3><p>Go 的工具链是免费的，Linux、macOS、Windows 都能用。很多 Linux 发行版都自带 Go。现在的开发环境，从 VS Code 到各种 IDE，对 Go 的支持都很好。</p><h2>Go 语言最适合干什么？</h2><p>没有哪种语言是万能的，但 Go 在某些领域确实表现出色。主要是在云原生开发、分布式网络服务，还有写命令行工具这几块。</p><h3>云原生开发</h3><p>Go 的并发能力强，网络编程支持好，而且可移植性高，这让它成了构建云原生应用的首选。Docker、Kubernetes、Istio 这些云原生计算的核心项目，全是用 Go 写的。</p><h3>分布式网络服务</h3><p>网络应用的关键在于怎么处理并发。Go 原生支持的协程和通道（channel）机制，就是为了解决这个问题设计的。所以，很多网络服务、分布式系统、API、Web 服务器、微服务框架，都是 Go 的强项。</p><h3>命令行工具</h3><p>Go 编译出来的文件基本不依赖外部库，启动快，好分发。这让它特别适合写命令行工具。比如 Teleport 这个工具，你可以直接下载一个预编译好的二进制文件放到服务器上就能跑，非常方便。</p><h2>Go 语言的不足</h2><p>说完优点，咱们也得客观看看 Go 的不足。</p><h3>省略了很多特性</h3><p>Go 为了保持简洁和可读性，故意砍掉了一些常见特性。这一点有人喜欢有人烦。</p><p>比如 Go 不支持宏（在编译期生成代码）。C++ 和 Rust 都有宏，Go 没有。Go 提供了一个 <code>go generate</code> 命令来做代码生成，但这和真正的宏系统还是有差距的。</p><p>另外，Go 很长一段时间都不支持泛型。直到 2022 年发布的 Go 1.18 版本，泛型才终于加进来。</p><p>Go 很少加重大新特性，这保证了版本兼容性，但也让语言演进显得有点慢。</p><h3>二进制文件比较大</h3><p>Go 编译出来的文件体积偏大。因为它是静态链接，把运行需要的东西都打包进去了。这虽然方便部署，但也让文件变大了。一个简单的“Hello World”在 Windows 上可能就有 1.5MB。</p><h3>垃圾回收消耗资源</h3><p>Go 的自动内存管理很方便，但垃圾回收是需要消耗计算资源的。Go 不提供手动内存管理接口。虽然每个新版本都在优化，但在需要极度精细控制内存的场景下，这可能是一个短板。</p><h3>没有标准的图形界面（GUI）</h3><p>Go 主要还是用来写命令行和网络服务的。虽然有第三方库尝试做 GUI，但目前还没有一个公认的标准解决方案。</p><h3>别用 Go 写系统内核</h3><p>Go 可以调用底层接口，但它不适合开发操作系统内核或驱动程序。因为 Go 依赖垃圾回收和运行时，没法完全脱离操作系统独立运行。这种活儿，Rust 更合适。</p><h2>Go 语言的未来</h2><p>Go 的团队现在越来越重视社区的反馈了。泛型的加入就是个例子。</p><p>调查显示，开发者对 Go 总体是满意的。现在的痛点主要在错误处理比较繁琐、框架生态还不够成熟这些方面。</p><p>Go 在网络服务领域的地位已经很稳固了。未来，它在这块还会继续加强。虽然现在用 Go 做 AI 的还不多，但已经有人在尝试了。阻碍 Go 在 AI 领域发展的主要是工具链还不如 Python 完善。</p><p>总的来说，Go 作为一种主流编程语言，地位已经确立了。特别是在云原生开发领域，它兼顾了高性能和开发效率，是构建基础设施的理想选择。</p><blockquote><p><strong>⚡️ 别把时间浪费在低效复习上</strong></p><p>很多人复习抓不住重点。作为过来人，我分析了100+份大厂面试记录，将 <strong>Go/Java/AI 的核心考察点、高频题、易错点</strong> 浓缩进了一份 PDF。</p><p><strong>不搞虚的，全是干货。</strong></p><p><strong>加我微信：wangzhongyang1993</strong>，备注 <strong>【面经】</strong> 免费发你，立即纠正你的复习方向，把时间用在刀刃上。</p><p>wangzhongyang.com 也欢迎大家直接访问我的官网，里面有Go / Java / AI 的资料，<strong>免费学习</strong>！</p></blockquote>]]></description></item><item>    <title><![CDATA[【vLLM 学习】Structured Outputs 超神经HyperAI ]]></title>    <link>https://segmentfault.com/a/1190000047601110</link>    <guid>https://segmentfault.com/a/1190000047601110</guid>    <pubDate>2026-02-09 11:02:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>vLLM 是一款专为大语言模型推理加速而设计的框架，实现了 KV 缓存内存几乎零浪费，解决了内存管理瓶颈问题。</p><p>更多 vLLM 中文文档及教程可访问 →<a href="https://link.segmentfault.com/?enc=z1php6Crs6WQ7o625JxIQA%3D%3D.cxda7b5ipumvOhP2dTedJX6mh1tpqucNRMHdWB3SNsc%3D" rel="nofollow" target="_blank">https://go.hyper.ai/Wa62f</a></p><p><a href="https://link.segmentfault.com/?enc=ac%2F3nlq50VGxi4YPhWdJYQ%3D%3D.yDQ1sJW%2F2Qnf8VLsxmh7iuzCyUxJKdo55mdTaU5zoPv%2BcXGas9hkqV0OmKV9IaU9r9a%2FVGA2ZoB1DuI7MaR5rvezTW3Fd9dzc1TJD%2BxQbLTaGklEYFv35TijJNqNXLvEPNX7e7423jMgmW7KuBHwvb5%2Fg4qQVZb7WLary8IDX%2BbppA8BEnAWrHskeGReorKT" rel="nofollow" target="_blank">*在线运行 vLLM 入门教程：零基础分步指南</a></p><p>源码 <a href="https://link.segmentfault.com/?enc=0EGmr1cqSxxDyjlt%2FVE1ew%3D%3D.P6XQ1QbfZS1nTcvnJLscNQaFEoskBDobbYOZkwImTTrbcGRaR0r4ujolmCv6JtsVwiUNleTHguZc8dT8t68s%2B%2BEVWUJeMx7hz5S4DUQ%2B679%2FWWDg05zoXqCTlNnT5gHc" rel="nofollow" target="_blank">examples/offline_inference/structured_outputs.py</a></p><pre><code>
from enum import Enum

from pydantic import BaseModel

from vllm import LLM, SamplingParams
from vllm.sampling_params import GuidedDecodingParams

llm = LLM(model="Qwen/Qwen2.5-3B-Instruct", max_model_len=100)

# 使用候选选项列表的引导式解码
guided_decoding_params = GuidedDecodingParams(choice=["Positive", "Negative"])
sampling_params = SamplingParams(guided_decoding=guided_decoding_params)
outputs = llm.generate(
    prompts="Classify this sentiment: vLLM is wonderful!",
    sampling_params=sampling_params,
)
print(outputs[0].outputs[0].text)

# 使用 Regex 的引导式解码
guided_decoding_params = GuidedDecodingParams(regex="\w+@\w+\.com\n")
sampling_params = SamplingParams(guided_decoding=guided_decoding_params,
                                 stop=["\n"])
prompt = ("Generate an email address for Alan Turing, who works in Enigma."
          "End in .com and new line. Example result:"
          "alan.turing@enigma.com\n")
outputs = llm.generate(prompts=prompt, sampling_params=sampling_params)
print(outputs[0].outputs[0].text)


# 使用 Pydantic 模式的 JSON 引导式解码
class CarType(str, Enum):
    sedan = "sedan"
    suv = "SUV"
    truck = "Truck"
    coupe = "Coupe"


class CarDescription(BaseModel):
    brand: str
    model: str
    car_type: CarType


json_schema = CarDescription.model_json_schema()

guided_decoding_params = GuidedDecodingParams(json=json_schema)
sampling_params = SamplingParams(guided_decoding=guided_decoding_params)
prompt = ("Generate a JSON with the brand, model and car_type of"
          "the most iconic car from the 90's")
outputs = llm.generate(
    prompts=prompt,
    sampling_params=sampling_params,
)
print(outputs[0].outputs[0].text)

# 使用 Grammar 的引导式解码
simplified_sql_grammar = """
    ?start: select_statement

    ?select_statement: "SELECT " column_list " FROM " table_name

    ?column_list: column_name ("," column_name)*

    ?table_name: identifier

    ?column_name: identifier

    ?identifier: /[a-zA-Z_][a-zA-Z0-9_]*/
"""
guided_decoding_params = GuidedDecodingParams(grammar=simplified_sql_grammar)
sampling_params = SamplingParams(guided_decoding=guided_decoding_params)
prompt = ("Generate an SQL query to show the 'username' and 'email'"
"from the 'users' table.")
outputs = llm.generate(
prompts=prompt,
sampling_params=sampling_params,
)
print(outputs[0].outputs[0].text)</code></pre>]]></description></item><item>    <title><![CDATA[基于MetaGPT构建网页生成Agent团队：从需求到可运行网页的全自动化 AIAgent研究 ]]></title>    <link>https://segmentfault.com/a/1190000047601282</link>    <guid>https://segmentfault.com/a/1190000047601282</guid>    <pubDate>2026-02-09 11:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>MetaGPT作为一款以“模拟企业协作流程”为核心的多智能体框架，能够将复杂任务拆解为不同角色的子任务，通过智能体间的信息流转和能力互补完成端到端的工作闭环。本文将手把手教你搭建“网页生成Agent团队”，让产品经理Agent、前端Agent、测试Agent各司其职，最终自动输出无语法错误的可运行网页文件，彻底打通“自然语言需求→代码实现→成果交付”的全流程。</p><h2>一、核心设计思路</h2><h3>1.1 MetaGPT多智能体协作逻辑</h3><p>MetaGPT的核心是“角色化分工+标准化成果流转”，针对“网页生成”场景，我们将任务拆解为4个核心环节：</p><pre style="display:none;"><code class="mermaid">graph LR
    A[用户自然语言需求] --&gt; B[产品经理Agent：需求分析]
    B --&gt; C[前端Agent：编写HTML/CSS代码]
    C --&gt; D[测试Agent：语法错误检测]
    D --&gt; E{测试通过？}
    E -- 是 --&gt; F[输出最终网页文件]
    E -- 否 --&gt; G[反馈给前端Agent修正]</code></pre><h3>1.2 核心技术依赖</h3><ul><li>基础框架：MetaGPT（Python 3.10+），提供智能体角色定义、任务调度、消息通信能力；</li><li>代码生成：基于大模型（OpenAI/Gemini/通义千问）的代码生成能力；</li><li>语法检测：BeautifulSoup、lxml（HTML结构校验）、csslint（CSS语法检测）；</li><li>环境配置：需提前配置大模型API密钥（支持主流商用/开源模型）。</li></ul><h2>二、环境准备</h2><h3>2.1 安装核心依赖</h3><pre><code class="bash"># 安装MetaGPT核心包
pip install metagpt&gt;=0.8.0

# 安装语法检测依赖
pip install beautifulsoup4 lxml csslint

# 配置工作目录（成果输出路径）
export METAGPT_WORKSPACE="./web_agent_workspace"
mkdir -p $METAGPT_WORKSPACE</code></pre><h3>2.2 配置大模型密钥</h3><p>创建<code>config.yaml</code>文件（MetaGPT默认读取路径：~/.metagpt/config.yaml）：</p><pre><code class="yaml">llm:
  api_type: "openai"  # 可选：openai/anthropic/qwen（通义千问）
  api_key: "你的API密钥"
  base_url: "https://api.openai.com/v1"  # 国产模型替换为对应地址
  model: "gpt-4o-mini"  # 推荐使用低成本且效果好的模型</code></pre><h2>三、各Agent角色实现</h2><p>基于MetaGPT的<code>Role</code>基类，为每个角色定制核心能力，所有代码可直接复制运行。</p><h3>3.1 产品经理Agent：需求分析</h3><p>核心职责：将模糊的自然语言需求转化为结构化、可落地的前端开发需求文档，明确页面结构、样式、核心元素等。</p><pre><code class="python">from metagpt.roles import Role
from metagpt.schema import Message
from metagpt.const import WORKSPACE_ROOT

class ProductManagerAgent(Role):
    def __init__(self):
        super().__init__(
            name="网页产品经理",
            profile="精通网页产品需求分析，能将自然语言需求转化为结构化的前端开发文档",
            goal="输出清晰、可落地的网页开发需求文档",
            constraints=[
                "需求文档需包含页面标题、核心结构（头部/主体/底部）、样式要求（主色调/字体）、核心元素（按钮/文本/图片）",
                "语言简洁，避免模糊表述，确保前端Agent能直接理解"
            ]
        )

    async def handle(self, msg: Message) -&gt; Message:
        """处理用户需求，生成结构化需求文档"""
        user_requirement = msg.content
        # 调用大模型生成结构化需求文档
        prompt = f"""
        请将以下用户需求转化为网页开发需求文档：
        用户需求：{user_requirement}
        文档格式要求：
        1. 页面标题
        2. 页面结构（头部/主体/底部）
        3. 样式要求（主色调、字体、布局）
        4. 核心元素（必须包含的按钮/文本/图片等）
        """
        # 调用MetaGPT内置的LLM能力
        requirement_doc = await self._aask(prompt)
        
        # 保存需求文档到工作目录
        doc_path = f"{WORKSPACE_ROOT}/需求文档.md"
        with open(doc_path, "w", encoding="utf-8") as f:
            f.write(requirement_doc)
        
        return Message(
            content=f"需求分析完成，文档路径：{doc_path}\n需求摘要：{requirement_doc[:200]}...",
            role=self.name
        )</code></pre><h3>3.2 前端Agent：编写HTML/CSS代码</h3><p>核心职责：基于产品经理的需求文档，生成符合W3C标准的HTML/CSS代码，样式内联便于测试，输出可直接运行的<code>.html</code>文件。</p><pre><code class="python">class FrontendAgent(Role):
    def __init__(self):
        super().__init__(
            name="前端开发工程师",
            profile="精通HTML/CSS，能根据需求文档编写规范、可运行的静态网页代码",
            goal="输出无基础语法错误的HTML/CSS代码文件",
            constraints=[
                "代码符合W3C标准，标签闭合完整，样式语法规范",
                "样式内联在HTML文件中，无需外部CSS文件",
                "文件名统一为index.html，保存到工作目录"
            ]
        )

    async def handle(self, msg: Message) -&gt; Message:
        """基于需求文档生成HTML/CSS代码"""
        # 读取需求文档
        doc_path = msg.content.split("文档路径：")[1].split("\n")[0]
        with open(doc_path, "r", encoding="utf-8") as f:
            requirement_doc = f.read()
        
        # 调用大模型生成HTML/CSS代码
        prompt = f"""
        请根据以下需求文档编写完整的HTML/CSS代码：
        {requirement_doc}
        代码要求：
        1. 完整的HTML5结构（DOCTYPE、html/head/body标签）
        2. 响应式布局，适配PC和移动端
        3. 样式内联在&lt;style&gt;标签中，主色调符合需求
        4. 包含需求中指定的所有核心元素
        """
        html_code = await self._aask(prompt)
        
        # 提取纯代码（过滤大模型的自然语言说明）
        if "```html" in html_code:
            html_code = html_code.split("```html")[1].split("```")[0]
        
        # 保存代码文件
        code_path = f"{WORKSPACE_ROOT}/index.html"
        with open(code_path, "w", encoding="utf-8") as f:
            f.write(html_code)
        
        return Message(
            content=f"前端代码生成完成，文件路径：{code_path}",
            role=self.name
        )</code></pre><h3>3.3 测试Agent：语法错误检测</h3><p>核心职责：校验HTML/CSS代码的语法错误（标签未闭合、属性错误、CSS语法错误等），输出测试报告，验收通过则触发最终文件输出。</p><pre><code class="python">import os
from bs4 import BeautifulSoup
import subprocess

class TestAgent(Role):
    def __init__(self):
        super().__init__(
            name="前端测试工程师",
            profile="精通HTML/CSS语法检测，能识别常见的语法错误",
            goal="检测网页代码语法错误，输出测试报告，确认是否可交付最终文件",
            constraints=[
                "重点检测：HTML标签闭合、属性格式、CSS语法规范",
                "若错误数为0，判定为验收通过；否则输出具体错误信息",
                "测试报告保存到工作目录"
            ]
        )

    def check_html_syntax(self, code_path):
        """检测HTML语法错误"""
        errors = []
        try:
            with open(code_path, "r", encoding="utf-8") as f:
                html_content = f.read()
            
            # 检测标签闭合
            soup = BeautifulSoup(html_content, "lxml")
            # 检查是否有未闭合的标签（简化版，可扩展更严格的校验）
            unclosed_tags = []
            for tag in soup.find_all():
                if not tag.find(string=True, recursive=False) and len(tag.contents) == 0 and not tag.name in ["img", "input", "br"]:
                    unclosed_tags.append(tag.name)
            if unclosed_tags:
                errors.append(f"HTML未闭合标签：{','.join(unclosed_tags)}")
            
            # 检测CSS语法（使用csslint）
            css_content = html_content.split("&lt;style&gt;")[1].split("&lt;/style&gt;")[0] if "&lt;style&gt;" in html_content else ""
            if css_content:
                # 临时保存CSS内容
                css_path = f"{WORKSPACE_ROOT}/temp.css"
                with open(css_path, "w", encoding="utf-8") as f:
                    f.write(css_content)
                # 调用csslint检测
                result = subprocess.run(
                    ["csslint", css_path],
                    capture_output=True,
                    text=True,
                    encoding="utf-8"
                )
                if result.returncode != 0 and result.stderr:
                    errors.append(f"CSS语法错误：{result.stderr[:200]}...")
                os.remove(css_path)
                
        except Exception as e:
            errors.append(f"文件读取/解析错误：{str(e)}")
        return errors

    async def handle(self, msg: Message) -&gt; Message:
        """执行语法检测，生成测试报告"""
        code_path = msg.content.split("文件路径：")[1]
        errors = self.check_html_syntax(code_path)
        
        # 生成测试报告
        report_path = f"{WORKSPACE_ROOT}/测试报告.md"
        if not errors:
            report_content = f"""
# 网页代码测试报告
- 测试文件：{code_path}
- 测试结果：通过（无语法错误）
- 结论：可输出最终网页文件
            """
            status = "通过"
        else:
            report_content = f"""
# 网页代码测试报告
- 测试文件：{code_path}
- 测试结果：失败
- 错误列表：
  {chr(10).join([f"- {err}" for err in errors])}
- 结论：需修正错误后重新生成
            """
            status = "失败"
        
        # 保存测试报告
        with open(report_path, "w", encoding="utf-8") as f:
            f.write(report_content)
        
        # 验收通过则复制到最终文件目录
        if status == "通过":
            final_dir = f"{WORKSPACE_ROOT}/最终文件"
            os.makedirs(final_dir, exist_ok=True)
            final_path = f"{final_dir}/index.html"
            os.system(f"cp {code_path} {final_path}")
            report_content += f"\n- 最终文件路径：{final_path}"
        
        return Message(
            content=f"测试完成，报告路径：{report_path}\n验收状态：{status}",
            role=self.name
        )</code></pre><h2>四、启动Agent团队并运行</h2><p>通过MetaGPT的<code>Team</code>类整合所有Agent，实现任务自动流转和成果输出：</p><pre><code class="python">from metagpt.team import Team
import asyncio

async def run_web_agent_team(user_requirement: str):
    """启动网页生成Agent团队"""
    # 1. 创建团队并添加成员
    team = Team()
    team.add_members([
        ProductManagerAgent(),
        FrontendAgent(),
        TestAgent()
    ])

    # 2. 启动团队，传入用户需求
    print("🚀 启动网页生成Agent团队...")
    await team.run(
        project_name="自动生成网页",
        idea=user_requirement,
        send_to="网页产品经理"  # 需求先发送给产品经理Agent
    )

    # 3. 输出最终结果
    final_path = f"{WORKSPACE_ROOT}/最终文件/index.html"
    if os.path.exists(final_path):
        print(f"✅ 任务完成！最终网页文件路径：{final_path}")
    else:
        print("❌ 任务失败！请查看测试报告修正错误。")

# 运行示例：用户需求
if __name__ == "__main__":
    # 自定义用户需求（可替换为任意自然语言描述）
    user_req = "生成一个个人简历网页，包含姓名、工作经历、技能展示区域，主色调为深蓝色，字体为微软雅黑，底部添加联系按钮"
    # 启动团队
    asyncio.run(run_web_agent_team(user_req))</code></pre><h2>五、实战效果验证</h2><h3>5.1 输入示例</h3><pre><code>生成一个个人简历网页，包含姓名、工作经历、技能展示区域，主色调为深蓝色，字体为微软雅黑，底部添加联系按钮</code></pre><h3>5.2 输出成果</h3><ol><li>产品经理Agent：生成<code>需求文档.md</code>，明确页面结构、样式、核心元素；</li><li>前端Agent：生成<code>index.html</code>，包含完整的HTML/CSS代码，符合需求；</li><li>测试Agent：检测代码无语法错误，生成<code>测试报告.md</code>，并将文件复制到<code>最终文件</code>目录；</li><li>最终成果：双击<code>最终文件/index.html</code>可直接在浏览器打开，展示完整的个人简历页面。</li></ol><h2>六、优化与扩展方向</h2><ol><li><strong>错误闭环修复</strong>：测试Agent发现错误后，自动反馈给前端Agent，触发代码修正，直到验收通过；</li><li><strong>功能扩展</strong>：增加后端Agent（编写JavaScript交互逻辑）、设计Agent（优化UI/UX）；</li><li><strong>模型优化</strong>：替换为本地开源模型（如Llama 3、Qwen2），降低API成本，实现离线运行；</li><li><strong>模板化开发</strong>：为前端Agent预设行业模板（博客、商城、简历），提升生成效率；</li><li><strong>可视化管理</strong>：集成Web UI，支持可视化配置Agent角色、查看任务进度。</li></ol><h2>七、总结</h2><p>基于MetaGPT搭建的“网页生成Agent团队”，核心价值在于将“需求分析-代码开发-测试验收”的人工工作流转化为智能体自动化协作流，不仅降低了网页开发的技术门槛，还能保证成果的规范性和一致性。该方案可适配个人轻量网页开发、企业批量生成静态页面等场景，通过角色扩展和流程优化，还能支撑更复杂的前端开发需求，是AI赋能开发效率提升的典型落地实践。</p><hr/><h3>总结</h3><ol><li>核心逻辑：MetaGPT通过“角色化分工+标准化成果流转”实现多Agent协作，产品经理Agent拆解需求、前端Agent生成代码、测试Agent校验语法，最终输出可运行网页；</li><li>实操要点：需提前配置MetaGPT环境和大模型密钥，各Agent基于<code>Role</code>基类实现核心能力，通过<code>Team</code>类完成任务调度；</li><li>扩展方向：可增加错误闭环修复、前端交互开发、本地模型适配等能力，适配更多实际开发场景。</li></ol>]]></description></item><item>    <title><![CDATA[PHP 应用遭遇 DDoS 攻击时会发生什么 从入门到进阶的防护指南 JaguarJack ]]></title>    <link>https://segmentfault.com/a/1190000047600736</link>    <guid>https://segmentfault.com/a/1190000047600736</guid>    <pubDate>2026-02-09 10:05:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>PHP 应用遭遇 DDoS 攻击时会发生什么 从入门到进阶的防护指南</h2><h3>暴风雨前的宁静</h3><p>想象一下，黑色星期五或者某个大促活动。你用 PHP 搭建的电商平台正在迎接前所未有的流量，订单源源不断，用户热情高涨，PHP 应用拼尽全力在扛。然后——啪——网站突然崩了。</p><p>你查日志，到底怎么了？流量确实飙了，但这次不是因为用户太多，而是一次 DDoS（分布式拒绝服务）攻击。</p><p>DDoS 攻击就像一场人造洪水，用大量伪造的请求把你的服务器淹掉。但具体到一个 PHP 应用，被打的时候到底发生了什么？怎么判断自己是不是正在被攻击？更重要的是——怎么防？</p><p>这篇文章会带你搞清楚 PHP 应用遭遇 DDoS 时的全过程：从识别攻击到保护你的应用不被打趴。</p><h3>什么是 DDoS 攻击</h3><p>DDoS 攻击有点像互联网上的交通堵塞。想象你要进一家热门店铺，结果突然冒出成百上千个"假顾客"堵在门口，真正的顾客根本挤不进去。店铺（你的 PHP 应用）被挤爆了，最终只能关门。</p><p>用技术语言说，DDoS 攻击是攻击者（或僵尸网络）向目标网站发送海量流量，耗尽其资源。目的很简单：让网站变慢或者直接打瘫。</p><p>对 PHP 应用来说，攻击会冲击以下几个环节：</p><ul><li><strong>Web 服务器</strong>：PHP 需要处理每一个请求，短时间内涌入大量请求会耗尽服务器资源。</li><li><strong>数据库</strong>：过多的查询会拖慢甚至打崩数据库。</li><li><strong>带宽</strong>：流量太大会吃满网络带宽，导致整体性能下降。</li></ul><h3>DDoS 攻击如何影响你的 PHP 应用</h3><p>PHP 应用被 DDoS 打中时，背后发生了这些事情：</p><h4>Web 服务器负载飙升</h4><p>用户发起请求后，Web 服务器（比如 Apache 或 Nginx）会运行 PHP 脚本、查数据库、返回动态内容。正常情况下这没什么问题，但当成千上万（甚至上百万）的请求同时涌入，服务器很快就扛不住了。</p><ul><li><strong>CPU 打满</strong>：PHP 需要处理每个请求，大量请求会让 CPU 使用率直接拉满。</li><li><strong>内存吃紧</strong>：PHP 应用通常会在内存中保存会话数据或缓存，请求太多会导致内存耗尽，轻则变慢，重则崩溃。</li></ul><h4>数据库过载</h4><p>PHP 应用通常依赖数据库来获取和展示动态内容。一个典型的请求可能涉及查库存、处理登录、渲染页面等操作。DDoS 攻击时，每个请求都可能触发开销很大的数据库查询，结果就是：</p><ul><li><strong>数据库瓶颈</strong>：数据库扛不住这种量级的负载，查询开始变慢、超时甚至直接失败。</li><li><strong>响应迟钝</strong>：数据库服务器变得无响应，内容分发被严重延迟。</li></ul><h4>带宽打满</h4><p>每个 DDoS 请求都会消耗带宽。当恶意流量大到一定程度，会把你的网络带宽全部吃掉，真实用户的请求根本进不来。</p><ul><li><strong>连接数上限</strong>：网络连接被打满后，正常用户访问你的网站要么极慢，要么完全打不开。</li></ul><h4>PHP 脚本超时</h4><p>PHP 脚本的执行时间是有上限的。服务器被大量请求淹没时，PHP 脚本可能来不及在规定时间内跑完，结果就是：</p><ul><li><strong>500 错误</strong>：服务器因资源耗尽无法处理请求。</li><li><strong>连接超时</strong>：PHP 脚本执行时间过长，连接直接断掉。</li></ul><h3>如何判断你的 PHP 应用正在被 DDoS</h3><p>及时识别 DDoS 攻击至关重要。以下是一些关键的技术指标：</p><h4>流量突然飙升</h4><p>流量在短时间内暴涨——尤其来源异常（比如来自不常见的地区或 IP 段）——就要警惕了。可以查看服务器日志来排查异常流量模式。</p><p>用 Apache 或 Nginx 日志检查是否有大量请求来自同一个 IP 或一批可疑地址：</p><pre><code class="bash"># Apache：检查访问日志中的 IP 请求频次
cat /var/log/apache2/access.log | awk '{print $1}' | sort | uniq -c | sort -n</code></pre><h4>性能下降和超时</h4><p>如果网站突然变慢或者频繁出现超时错误，可能就是 DDoS 在搞鬼。PHP 脚本处理不过来涌入的请求，开始报 500 错误或者超时。</p><h4>资源占用异常</h4><p>如果服务器的 CPU 和内存使用率突然飙高，说明 PHP 正在苦苦支撑。可以用 <code>htop</code> 或 <code>top</code> 实时监控资源使用情况：</p><pre><code class="bash"># 实时监控 CPU 和内存使用情况
top -d 1</code></pre><p>如果 CPU 或内存长时间处于高位，就该进一步排查了。</p><h3>PHP 应用的 DDoS 防护策略</h3><p>完全杜绝 DDoS 攻击很难，但有不少手段可以大幅降低其影响。下面是一些保护 PHP 应用的实用方案。</p><h4>限流：第一道防线</h4><p>限流就是限制每个用户在一段时间内能发起的请求数量。方法简单但很有效，能挡住大部分机器人和恶意请求。</p><p><strong>用 Redis 实现限流</strong></p><p>可以用 Redis 追踪每个用户的请求次数，超过阈值就拒绝：</p><pre><code class="php">$redis = new Redis();
$redis-&gt;connect('localhost', 6379);
$ip = $_SERVER['REMOTE_ADDR'];
$key = "request_count:{$ip}";
$limit = 100;  // Max requests per minute
$window = 60;  // 1 minute time window
$request_count = $redis-&gt;get($key);
if ($request_count &amp;&amp; $request_count &gt;= $limit) {
    // Too many requests, reject the user
    header('HTTP/1.1 429 Too Many Requests');
    exit('Rate limit exceeded');
}
$redis-&gt;incr($key);
$redis-&gt;expire($key, $window);  // Reset the count after 1 minute</code></pre><p>这个基础限流方案可以有效节流那些试图用大量请求淹没你服务器的用户或机器人。</p><h4>CDN：分流恶意流量</h4><p>CDN（内容分发网络）会缓存静态资源（图片、CSS、JavaScript），通过分布在全球的边缘节点提供服务。DDoS 攻击时，CDN 可以吸收大量流量，让你的 PHP 服务器专心处理动态请求（比如用户登录、订单处理）。</p><p><strong>通过 CDN 分发静态资源</strong></p><pre><code class="html">&lt;!-- 通过 CDN 提供静态资源 --&gt;
&lt;link rel="stylesheet" href="https://cdn.yoursite.com/styles.css"&gt;
&lt;script src="https://cdn.yoursite.com/app.js"&gt;&lt;/script&gt;
&lt;img src="https://cdn.yoursite.com/images/product.jpg" alt="Product"&gt;</code></pre><p>把静态资源交给 CDN，既能减轻 PHP 应用的负载，也能让 DDoS 流量更难直接打到你的应用核心。</p><h4>WAF：应用层防护</h4><p>WAF（Web 应用防火墙）是一种高级工具，专门检查和过滤发往 PHP 应用的 HTTP 流量。WAF 可以根据预设规则检测并拦截恶意请求，比如封禁可疑 IP 或屏蔽特定地区的流量。</p><p><strong>以 AWS WAF 为例</strong></p><ol><li>创建 Web ACL（访问控制列表），定义流量过滤规则。</li><li>添加规则来拦截 HTTP 洪水攻击、SQL 注入、IP 信誉过滤等。</li></ol><pre><code class="bash">aws wafv2 create-web-acl --name "MyWAF" --scope "REGIONAL" --default-action "ALLOW" --rules ...</code></pre><p>配置完成后，PHP 应用就有了一层专门的防护，恶意流量会被拦截，正常用户不受影响。</p><h4>借助第三方 DDoS 防护服务</h4><p>Cloudflare、AWS Shield 这类服务是专业做 DDoS 防护的。它们提供的高级防护能自动过滤恶意流量，保证你的 PHP 应用持续在线。</p><p>接入方式很简单：</p><ol><li>注册 Cloudflare 或 AWS Shield。</li><li>把域名的流量路由到它们的服务。</li><li>它们会自动检测并拦截 DDoS 流量。</li></ol><p>通过第三方服务，绝大部分攻击流量在到达你的 PHP 应用之前就已经被挡掉了。</p><h4>实时监控和日志记录</h4><p>持续监控流量和服务器性能有助于实时发现 DDoS 攻击。Datadog、New Relic、AWS CloudWatch 这类工具可以帮你捕捉异常流量、性能下降等问题。</p><p><strong>记录可疑 IP</strong></p><pre><code class="php">// Example: Log suspicious IPs for later analysis
$suspicious_ip = $_SERVER['REMOTE_ADDR'];
$log_file = '/path/to/your/log/file.log';
file_put_contents($log_file, "Suspicious IP: {$suspicious_ip}\n", FILE_APPEND);
// Optionally, block IP if it exceeds request limit
if ($request_count &gt; $limit) {
    // Block the IP
    $blocked_ips[] = $suspicious_ip;
}</code></pre><p>通过记录可疑活动，你可以事后封禁恶意用户，也能不断优化自己的防护策略。</p><h3>总结</h3><p>DDoS 攻击听起来可怕，但只要用对工具和策略，你完全可以保护好自己的 PHP 应用。从限流、CDN，到 WAF 和第三方防护服务，可选的方案并不少。</p><p>别慌——主动防御比被动应对强得多。今天就把这些防线搭起来，等攻击真来的时候你才不会手忙脚乱。持续监控、实时告警、遵循最佳实践，即使面对 DDoS，你的 PHP 应用照样能稳稳地跑着。<br/><a href="https://link.segmentfault.com/?enc=J6nB7%2Bllcg3AL8VlLKlZDA%3D%3D.odAfsqKrRyNxReYoTfXmEF2pZ4t6E1XQaNlPeVLQjlc3eODUk5PRMfTbzkCjg5BMwe9QSb218e9AkkkV5JB%2FGw%3D%3D" rel="nofollow" target="_blank">PHP 应用遭遇 DDoS 攻击时会发生什么：从入门到进阶的防护指南</a></p>]]></description></item><item>    <title><![CDATA[Sophos Firewall (SFOS) v22 GA re-release - 下一代防火墙 ]]></title>    <link>https://segmentfault.com/a/1190000047600752</link>    <guid>https://segmentfault.com/a/1190000047600752</guid>    <pubDate>2026-02-09 10:05:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Sophos Firewall (SFOS) v22 GA re-release - 下一代防火墙</p><p>Sophos Firewall | Next-gen firewall</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=iNB1di8thdsJHZuDbI8ftg%3D%3D.vDvCZjZYa9rd5uLOeZg4QyagF2ENEERZk0nksoyhNCQ%3D" rel="nofollow" target="_blank">https://sysin.org/blog/sfos-22/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=PlihSBaiHD9v7p3SmY0y6A%3D%3D.XaL1zJYsWFMD3E9mpIyrlnu6qL%2FMk0uPOFD4KBOJncs%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>Sophos Firewall</p><p>2026 年 1 月 20 日</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600754" alt="Sophos Firewall v22 GA re-release (Build 411) is Now Available" title="Sophos Firewall v22 GA re-release (Build 411) is Now Available"/></p><p><strong>Sophos Firewall v22 GA 重新发布（Build 411）现已提供</strong>！</p><p>随着 SFOS v22 GA（Build 411）的重新发布，我们修复了一些罕见且孤立的问题（详见下文）。如果你已经在运行 v22 GA，你将在防火墙中看到该重新发布版本作为产品内固件升级提供。建议你在方便的时候升级到 v22 GA 重新发布版本（Build 411）。</p><p><strong>🐞 v22 GA 重新发布（Build 411）中已解决的问题</strong>：</p><ul><li>当包含超过 256 个主机的主机组被分配到规则或策略时，防火墙无法将这些主机与流量进行匹配（NC-171031）。</li><li>无法通过配置了 VLAN 过滤的桥接接口访问 Web 管理控制台（NC-171003）。</li><li>CLI 中出现如下日志：“Invalid rule id or family for update”（无效的规则 ID 或更新族）（NC-170987）。</li><li>当 DNAT 规则中包含指定的出站接口时，DNAT 流量失败（NC-170970）。</li><li>当终端设备从不健康状态恢复为健康状态后 (sysin)，Ping 无法继续（NC-170527）。</li><li>在规则重新评估期间，防火墙规则标志未被重置（NC-166150）。</li><li>当默认 SNAT 规则配置为静态 IP 地址而非 MASQ 时，基于策略的 IPsec VPN 流量失败（NC-170917）。</li><li>当 Sophos Central Reporting 插件中发生 mmap 损坏时，Garner 进程会重启（NC-169540）。</li><li>当防火墙为同步应用控制（Synchronized Application Control）执行内部清理任务时，会生成一条“Security global configuration”的日志事件（NC-171885）。</li><li>由于存在控制字符，导致无法正确获取桥接成员接口，进而引发区域误判，策略测试器因此无法找到对应规则（NC-171933）。</li><li>SSL/TLS 小组件和会话图表数据无法正确显示（NC-171600）。</li><li>无法添加任何 SNMP 配置（NC-172197）。</li></ul><p>2025 年 12 月 9 日</p><p><strong>Sophos Firewall v22</strong> 现已发布</p><p>产品团队很高兴宣布 Sophos Firewall v22 已正式发布。此次更新带来了多项 “Secure by Design” 安全设计增强，以及许多用户最期待的功能。</p><p><strong>Secure By Design</strong>（安全设计）</p><p>在过去几周里，Sophos 已经介绍了 Secure by Design 原则的重要性，以及为何需要安全产品与安全设计同样重要。Sophos Firewall v22 在前几版的安全和加固增强基础上，将 Secure by Design 提升到了全新水平。</p><h2>新功能概览</h2><h3>Sophos 防火墙健康检查</h3><p>强大的安全态势依赖于防火墙的最佳配置。Sophos 防火墙 v22 通过新增的健康检查功能，使评估和优化防火墙配置更加容易。该功能<strong>评估防火墙的数十项配置设置，并将其与 CIS 基准及其他最佳实践进行对比</strong>，即时提供潜在风险的洞察 (sysin)。它会标识所有高风险设置，并提供快速定位和处理的建议。</p><p>健康检查状态将在新的控制中心小部件中显示，完整报告可在“Firewall health check”主菜单中查看。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047467594" alt="Sophos Firewall v22" title="Sophos Firewall v22" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047467595" alt="Sophos Firewall v22" title="Sophos Firewall v22" loading="lazy"/></p><h3>其他 Secure By Design 增强功能</h3><ul><li><p><strong>下一代 Xstream 架构：</strong></p><ul><li>引入全新控制平面架构，最大化安全性和可扩展性。</li><li>新控制平面实现服务模块化、隔离和容器化，例如 IPS 可像“应用”一样运行在防火墙平台上。</li><li>完全分离权限以增强安全性 (sysin)。</li><li>SFOS 现具备自愈能力，可持续监控系统状态并自动修复偏差。</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047467596" alt="Sophos Firewall v22" title="Sophos Firewall v22" loading="lazy"/></p><ul><li><p><strong>加固内核：</strong></p><ul><li>Sophos 防火墙 OS 的下一代 Xstream 架构基于新加固内核（v6.6+），提供增强的安全性、性能和可扩展性，充分利用当前及未来硬件。</li><li>新内核提供更严格的进程隔离，更好地防范侧信道攻击及 CPU 漏洞（Spectre、Meltdown、L1TF、MDS、Retbleed、ZenBleed、Downfall）。</li><li>提供加固的 usercopy、堆栈保护 (stack canaries) 和内核地址空间布局随机化 (KASLR)。</li></ul></li><li><p><strong>远程完整性监控：</strong></p><ul><li>v22 集成 Sophos XDR Linux 传感器 (sysin)，实现系统完整性实时监控，包括未授权配置、规则导出、恶意程序执行尝试、文件篡改等。</li><li>帮助安全团队更快速识别、调查和响应攻击。</li><li>提供其他防火墙厂商未提供的额外安全能力。</li></ul></li><li><p><strong>全新反恶意软件引擎：</strong></p><ul><li>集成最新 Sophos 反恶意软件引擎，通过全球声誉查询实现对新威胁的零日实时检测。</li><li>利用 SophosLabs 海量云数据库，文件每 5 分钟或更短更新一次。</li><li>引入 AI/ML 模型检测，并提供增强的遥测数据以加速新威胁分析。</li></ul></li></ul><h3>其他安全性与可扩展性增强</h3><ul><li><strong>主动威胁响应日志改进</strong>：为入站和出站流量增加细粒度日志控制，减少暴力破解等重复事件噪声；支持将入站转发流量与第三方威胁源、NDR Essentials 和 MDR 威胁源匹配，提高外部威胁检测。</li><li><strong>XML API 访问控制增强</strong>：API 配置移动到“Administration”主菜单，可按 IP、IP 范围和网络对象定义访问，支持最多 64 个对象（之前为 10 个 IP）。</li><li><p><strong>NDR Essentials 改进</strong>：</p><ul><li>日志威胁评分 - 主动威胁响应日志中包含分配的威胁评分，便于可视化、报告和分析。</li><li>数据中心选择 - 可选择 NDR Essentials 流分析的数据中心区域，满足地域或数据驻留需求，默认选择最低延迟区域。</li></ul></li><li><p><strong>即时网页类别与搜索关键词告警</strong>：</p><ul><li>可根据浏览意图或行为触发即时告警。</li><li>帮助学校从被动报告转向主动防护，保护学生安全，并符合最新数字标准。</li></ul></li><li><strong>设备访问支持 TLS1.3</strong>：Web 管理控制台、VPN 门户和用户门户现支持 TLS 1.3，加强加密。</li></ul><h3>简化管理与使用体验增强</h3><ul><li><strong>导航性能优化</strong>：可直接访问任意菜单或标签，无需等待当前页面加载完成，加快 UI 导航速度。</li><li><strong>TLS1.3 支持</strong>：Web 管理控制台 (sysin)、VPN 门户和用户门户支持 TLS 1.3。</li><li><strong>通过 SNMP 监控硬件</strong>：新增热门功能，支持下载 MIB 文件；监控指标包括 CPU 温度、NPU 温度、风扇转速、电源状态（XGS 2100 及以上）、以及所有支持 PoE 的 XGS 型号的 PoE 测量（XGS 116(w) 除外）。</li><li><strong>NTP 服务器设置</strong>：新安装默认设置为 <strong>“Use pre-defined NTP server”</strong>。</li><li><strong>XFRM 接口 UI 改进</strong>：增加分页支持，可搜索和筛选，大量 XFRM 接口管理更便捷。</li><li><strong>sFlow 监控</strong>：基于设置的采样率提供实时数据，支持任何物理接口及子接口（Alias、VLAN 等），最多 5 个采集器。</li><li><strong>蜂窝 WAN</strong>：新增 CLI 命令 <code>system cellular_wan show</code> 检查信号强度。</li></ul><h3>SG UTM9 功能</h3><p>随着 Sophos UTM 即将于 2026 年 7 月 30 日退役，一些迁移客户可受益于以下新增功能：</p><ul><li><strong>WAF 多因素认证支持</strong>：为集成 Web 应用防火墙提供 MFA，增强安全性和功能一致性。</li><li><strong>WAF 安全性增强</strong>：会话由 SFOS 管理，而非客户端 cookie，更难被劫持；当无需认证转发时，可完全卸载到 SFOS，减少内部 WAF 服务器暴露。</li><li><strong>OTP 令牌 SHA 256/512 支持</strong>：提供给 Google 和 Sophos 应用及管理员用户的选项。</li><li><strong>审计日志</strong>：提供全面审计日志，记录前后变化以满足最新 NIS2 标准。第一阶段支持防火墙规则、对象和接口的详细审计日志，可从 <em>Diagnostics &gt; Troubleshooting Logs &gt; configuration-audit.log</em> 下载，XML 用于标注前后变化。</li></ul><h2>下载地址</h2><p><strong>Sophos Firewall OS (SFOS) 22.0 GA re-release (Build 411)</strong> (2026-01-20)</p><p>v22 GA re-release 取代了之前的 v22 GA，修复了若干罕见且孤立的已知问题。</p><ul><li><p>请访问：<a href="https://link.segmentfault.com/?enc=ZskK1aTE2A5AAQZLIEpUtA%3D%3D.FsAj5GcF%2BMaJF45l7fpzDo3bg3LuP2czEwV%2Fv7XUgoc%3D" rel="nofollow" target="_blank">https://sysin.org/blog/sfos-22/</a></p><ul><li>SFOS v22 Hardware Devices for XGS Series</li><li>SFOS v22 Software Appliances for bare metal machines</li><li>SFOS v22 Virtual Appliances for VMware/KVM/Xen/Hyper-v</li></ul></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=ud8mgObVcQYu%2FyMaXWHCqg%3D%3D.TIPiy8wbJP14vpoqGr70Dn2Izhp7IlCwJyy7E35iY7lgWppPRyJUbvl1cUCR7WOd" rel="nofollow" target="_blank">Firewall 产品链接汇总</a></p>]]></description></item><item>    <title><![CDATA[Cisco NX-OS 10.6(2)F 发布 - 数据中心网络操作系统 sysin ]]></title>    <link>https://segmentfault.com/a/1190000047600760</link>    <guid>https://segmentfault.com/a/1190000047600760</guid>    <pubDate>2026-02-09 10:04:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Cisco NX-OS Software Release 10.6(2)F - 数据中心网络操作系统</p><p>NX-OS 网络操作系统</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=VfU3iUzuyrnnDFMMZQJ5ww%3D%3D.ytlQxOPbMaMczGmZuGtfRq0YGNy7tQoeeQt5P%2FZxMpbR%2FunMW%2BX%2FIXnibdzXNjik" rel="nofollow" target="_blank">https://sysin.org/blog/cisco-nx-os-10/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=bzf8E9SHG5lMMn10dEBaew%3D%3D.hYwG3Gum%2FZeggUhn0Z0TMMRioPHqk9oz%2FvBo6%2BTA2HA%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p><strong>Cisco NX-OS</strong><br/> Cisco NX-OS 操作系统助力网络紧跟业务发展步伐。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045101583" alt="Nexus 9300 Family Marquee" title="Nexus 9300 Family Marquee"/></p><h2>功能和优势</h2><p>NX-OS 网络操作系统为现代数据中心提供支持。</p><h3>架构灵活性</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044797965" alt="架构灵活性" title="架构灵活性" loading="lazy"/></p><p>NX-OS 助力数据中心随工作负载和应用的发展而不断扩展。</p><ul><li>借助 VXLAN EVPN 为可扩展工作负载提供支持</li><li>通过多租户有效利用网络资源 (sysin)</li><li>自由选用支持分段路由和 VXLAN 的 Overlay 网络技术</li><li>借助 VXLAN 多站点实现灾难恢复和业务连续性</li></ul><h3>操作简便性</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044797966" alt="操作简便性" title="操作简便性" loading="lazy"/></p><p>NX-OS 具备可编程性，可将调配时间从几天缩短到几分钟，从而简化部署。</p><ul><li>与 Cisco DCNM 完全集成，实现全面管理</li><li>通过行业标准 API 实现轻松配置</li><li>与 DevOps 自动化工具完全集成</li><li>支持原生 Docker 的简化工具 (sysin)</li></ul><h3>端到端可视性</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044797967" alt="端到端可视性" title="端到端可视性" loading="lazy"/></p><p>数据和控制平面具有深度可视性，有助于保护数据中心，并针对问题快速进行补救。</p><ul><li>借助精细流和 ASIC 遥测，优化网络 (sysin)</li><li>利用控制平面可视性和模型驱动的遥测，预防网络故障</li><li>通过 MACSEC 加密，防御监听和网络攻击</li><li>借助 802.1X 验证，保护终端和工作负载</li><li><a href="https://link.segmentfault.com/?enc=fSqsVn2XerUQ2pY31v5PAg%3D%3D.mEMLCPPnOgTeNFj5nJtRaG68U0Mnt96%2Bcswdl8Kbb2rlMEepeUkT9mZzoxS6MaVOMweOej92dmaSp5LtgF77NENbAg0Zi0mam1VdeYAmp3QtDFrOR4l9DmZBoupD1UYbIlPoMyumwekCOI1l1OdXaA%3D%3D" rel="nofollow" target="_blank">查看产品手册</a></li></ul><h2>借助 Cisco NX-OS 管理您的数据中心网络</h2><h3>遥测技术助力网络运维</h3><p>建立可靠的数据中心网络，防止停机并快速解决网络问题。</p><h3>分段路由</h3><p>使用 SRv6 架构构建可扩展的网络，从而降低网络运维的复杂性，并实现与核心/WAN 的数据中心互联 (DCI)</p><h3>自由定制、安全可靠</h3><p>灵活、安全地管理工作负载。NX-OS 支持您根据业务需求定制网络，让 DevOps 在创新时只需几分钟即可打开交换矩阵。</p><h3>轻松扩展</h3><p>为媒体构建具有成本效益且易于扩展的生产应用和网络。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044797980" alt="NX-OS 配图" title="NX-OS 配图" loading="lazy"/></p><h2>下载地址</h2><p>for Cisco Nexus 9000 Series Switches:</p><ul><li><a href="https://link.segmentfault.com/?enc=PbxqPI2%2BvCt4MzkmNmD3hg%3D%3D.eCAculCX%2Bicuxl1jw3H02DVLw39oF83n5fjZImp9WiRKourRvjmREs%2BeizrQbwTD" rel="nofollow" target="_blank">Cisco Nexus 9000 Series Switches, NX-OS Standalone 10.6(2)F and ACI Mode 16.1(4h)F</a></li></ul><p>for Cisco Nexus 9000v Switch:</p><ul><li><a href="https://link.segmentfault.com/?enc=zZbyHYXauggTQ9ctQexJsw%3D%3D.ceSzbG7kphim2sAjhcELNjbFvHCyC0kSJ%2F%2B5IOSN9HaO9UmXiqyC2SFaPA2DJM4G" rel="nofollow" target="_blank">Cisco Nexus 9000v Switch, NX-OS Release 10.6(2)F - 虚拟化的数据中心交换机</a></li></ul><hr/><p>数据中心网络相关产品：</p><ul><li><a href="https://link.segmentfault.com/?enc=RiOV6ITrLS%2Fa8qTqQ7pwOA%3D%3D.xtDZ5L8dBapDyGdm8mivJmFMb1YEnuJ8lfsrpiQSxNyxb2pcqKpaN9thNN3xve8S" rel="nofollow" target="_blank">Cisco NX-OS System Software - ACI 16.1(4h)F | 16.0(9e)M</a></li><li><a href="https://link.segmentfault.com/?enc=oc2PYI5jfFUsYUGyLdDcsQ%3D%3D.batwZGYV2KLyYtd7%2FMbp3b4mx5HOk4HHYwidBxda2x5JJ54zME171eX7AOXuxL5j" rel="nofollow" target="_blank">Cisco APIC 6.1(4h)F | 6.0(9e)M - 应用策略基础设施控制器</a></li><li><a href="https://link.segmentfault.com/?enc=%2F2RdeAUOplF823zls74p%2BQ%3D%3D.J3ZDomnu0Yyy9jiGl%2FeL8i9hjPeMXucc8BxBUajQoBJKwfOObR%2BAp3NqyqhgK0mi" rel="nofollow" target="_blank">Cisco ACI Simulator 6.1(4h)F | 6.0(9c)M - ACI 模拟器</a></li><li><a href="https://link.segmentfault.com/?enc=35vU41LodH8P198Qb%2F2kkg%3D%3D.N5aoRF%2F3FJxZ%2FLHr3VcFVFXU%2BfP%2BMIm1zOKMZgtBVb972fM8hBUrJt3oVO3CoFjC" rel="nofollow" target="_blank">Cisco NX-OS Software Release 10.6(2)F - 数据中心网络操作系统</a></li><li><a href="https://link.segmentfault.com/?enc=RjRmG9oDnU0hGTeQChtRoQ%3D%3D.yane7%2BqWT6bVCKMdayr%2FN9zm76KVNmG3NN0g93vcJlDMeKTSsPxRXtTKH%2FqSzGND" rel="nofollow" target="_blank">Cisco Nexus 9000 Series Switches, NX-OS Standalone 10.6(2)F and ACI Mode 16.1(4h)F</a></li><li><a href="https://link.segmentfault.com/?enc=MaM5gCPxDmr%2B%2FBmvigkhTw%3D%3D.TNtLiLxvMEbvyEeoMqM8xurBB62VE1YwoAyu6Wc5LkoDcT4vEVDB%2BvdyyK3SD2Lq" rel="nofollow" target="_blank">Cisco Nexus 9000v Switch, NX-OS Release 10.6(2)F - 虚拟化的数据中心交换机</a></li><li><a href="https://link.segmentfault.com/?enc=1R9sKJww5%2Fnx%2BFZD33fSfg%3D%3D.OMsvpYoyR%2FbYCGRhBr2fVBfXt32G2uCanWh%2B4lABoF7E6eiKuO%2BUDfqLVwkZSfzu" rel="nofollow" target="_blank">Cisco Nexus Dashboard 4.1(1g) - 云和数据中心网络管理软件</a></li><li><a href="https://link.segmentfault.com/?enc=3DK0IWDenogLBwkS9EhQ1g%3D%3D.9yfln4ezXG7g5oQ8kYDNmKYxQNJUIploXShqsl2mmKg03GW3kazk9f8sGGoeOAZW" rel="nofollow" target="_blank">Cisco ASR 9000 Router IOS XR Release 7.11.2 MD</a></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=EyyOPCSSJfx6ZrOhloHsnA%3D%3D.XM4EoR2Es0FNz12m9BARaQimvMZOPUxO%2Bqfo%2BPYqaaY%3D" rel="nofollow" target="_blank">Cisco 产品下载链接汇总</a></p>]]></description></item><item>    <title><![CDATA[一站式管理！新一代大模型网关神器！ Java陈序员 ]]></title>    <link>https://segmentfault.com/a/1190000047600764</link>    <guid>https://segmentfault.com/a/1190000047600764</guid>    <pubDate>2026-02-09 10:03:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大家好，我是 <code>Java陈序员</code>。</p><p>在 AI 大模型应用爆发的当下，对接多平台接口、管理 API 密钥、控制调用权限......这些繁琐的操作是否让你头疼？</p><p>今天，给大家介绍一款开源的大模型网关神器，一站式解决大模型接口管理的所有痛点！</p><blockquote>关注微信公众号：【Java陈序员】，获取<strong>开源项目分享、AI副业分享、超200本经典计算机电子书籍等。</strong></blockquote><h2>项目介绍</h2><p><code>new-api</code> —— 一款开源的大模型网关与 AI 资产管系统，定位为一站式 AI 资产管理网关，核心目标是提供大模型相关的网关管理与资产统筹能力。</p><p><strong>功能特色</strong>：</p><ul><li><strong>适配全品类模型</strong>：一个 API 端点接入所有 AI 服务，支持 OpenAI、Moonshot、Zhipu、Anthropic Claude、Google Gemini、百度文心一言、讯飞星火等主流大模型，一套网关打通全品类 AI 服务</li><li><strong>智能调度渠道</strong>：支持渠道加权随机分配，可设置默认供应商，结合令牌分组、模型限制能力，灵活管控接口调用优先级与范围</li><li><strong>精细化资产管理</strong>：集成在线充值功能，可自定义充值金额选项、折扣规则，支持模型按次数收费，可批量设置模型固定价格、模型倍率、补全倍率</li><li><strong>细粒度权限控制</strong>：支持 GitHub OAuth、LinuxDO、Telegram、OIDC 等多方式授权登录，集成双因素认证，支持令牌分组管理，限制令牌可调用的模型范围，适配团队协作场景</li><li><strong>全新 UI</strong>：现代化的用户界面设计，支持深色/浅色主题，自动适配系统偏好，支持中文、英文、法语、日语多语言，提供可视化控制台与统计分析的数据看板</li></ul><h2>快速上手</h2><p><code>new-api</code> 支持 Docker 部署，可使用 Docker 快速部署。</p><h3>Docker 部署</h3><p>1、拉取镜像</p><pre><code class="bash">docker pull calciumion/new-api</code></pre><p>2、创建挂载目录</p><pre><code class="bash">mkdir -p /data/software/new-api</code></pre><p>3、启动容器</p><ul><li><p>使用 SQLite 数据库</p><pre><code class="bash">docker run -d --name new-api \
--restart always \
-p 3000:3000 \
-e TZ=Asia/Shanghai \
-v /data/software/new-api:/data \
calciumion/new-api</code></pre></li><li><p>使用 MySQL 数据库（推荐）</p><pre><code class="bash">docker run -d --name new-api \
--restart always \
-p 3000:3000 \
-e TZ=Asia/Shanghai \
-e SQL_DSN="用户名:密码@tcp(数据库地址:3306)/数据库名" \
-v /data/software/new-api:/data \
calciumion/new-api</code></pre></li></ul><blockquote>环境变量中的数据库连接信息需要传入对应的值。</blockquote><p>4、容器运行成功后，浏览器访问</p><pre><code class="bash">http://{IP/域名}:3000</code></pre><blockquote>首次安装需要按照页面指引手动设置管理员账号和密码，完成初始化后即可使用所设置的管理员账号登录系统。</blockquote><h3>Docker Compose 部署、</h3><p>1、创建一个目录用于部署</p><pre><code class="bash">mkdir new-api
cd new-api</code></pre><p>2、在该目录下创建 <code>docker-compose.yml</code> 文件</p><ul><li>标准配置（生产环境）</li></ul><pre><code class="yaml"># New-API Docker Compose Configuration
#
# Quick Start:
#   1. docker-compose up -d
#   2. Access at http://localhost:3000
#
# Using MySQL instead of PostgreSQL:
#   1. Comment out the postgres service and SQL_DSN line 15
#   2. Uncomment the mysql service and SQL_DSN line 16
#   3. Uncomment mysql in depends_on (line 28)
#   4. Uncomment mysql_data in volumes section (line 64)
#
# ⚠️  IMPORTANT: Change all default passwords before deploying to production!

version: '3.4' # For compatibility with older Docker versions

services:
  new-api:
    image: calciumion/new-api:latest
    container_name: new-api
    restart: always
    command: --log-dir /app/logs
    ports:
      - '3000:3000'
    volumes:
      - ./data:/data
      - ./logs:/app/logs
    environment:
      - SQL_DSN=postgresql://root:123456@postgres:5432/new-api # ⚠️ IMPORTANT: Change the password in production!
      #      - SQL_DSN=root:123456@tcp(mysql:3306)/new-api  # Point to the mysql service, uncomment if using MySQL
      - REDIS_CONN_STRING=redis://redis
      - TZ=Asia/Shanghai
      - ERROR_LOG_ENABLED=true # 是否启用错误日志记录
      - BATCH_UPDATE_ENABLED=true # 是否启用批量更新 batch update enabled
    #      - STREAMING_TIMEOUT=300  # 流模式无响应超时时间，单位秒，默认120秒，如果出现空补全可以尝试改为更大值 Streaming timeout in seconds, default is 120s. Increase if experiencing empty completions
    #      - SESSION_SECRET=random_string  # 多机部署时设置，必须修改这个随机字符串！！ multi-node deployment, set this to a random string!!!!!!!
    #      - SYNC_FREQUENCY=60  # Uncomment if regular database syncing is needed

    depends_on:
      - redis
      - postgres
    #      - mysql  # Uncomment if using MySQL
    healthcheck:
      test:
        [
          'CMD-SHELL',
          "wget -q -O - http://localhost:3000/api/status | grep -o '\"success\":\\s*true' || exit 1",
        ]
      interval: 30s
      timeout: 10s
      retries: 3

  redis:
    image: redis:latest
    container_name: redis
    restart: always

  postgres:
    image: postgres:15
    container_name: postgres
    restart: always
    environment:
      POSTGRES_USER: root
      POSTGRES_PASSWORD: 123456 # ⚠️ IMPORTANT: Change this password in production!
      POSTGRES_DB: new-api
    volumes:
      - pg_data:/var/lib/postgresql/data
#    ports:
#      - "5432:5432"  # Uncomment if you need to access PostgreSQL from outside Docker

#  mysql:
#    image: mysql:8.2
#    container_name: mysql
#    restart: always
#    environment:
#      MYSQL_ROOT_PASSWORD: 123456  # ⚠️ IMPORTANT: Change this password in production!
#      MYSQL_DATABASE: new-api
#    volumes:
#      - mysql_data:/var/lib/mysql
#    ports:
#      - "3306:3306"  # Uncomment if you need to access MySQL from outside Docker

volumes:
  pg_data:
#  mysql_data:</code></pre><blockquote>生产环境下，请务必修改数据库密码。</blockquote><ul><li><p>简化配置（测试环境）</p><pre><code class="yaml">services:
new-api:
  image: calciumion/new-api:latest
  container_name: new-api
  restart: always
  ports:
    - '3000:3000'
  environment:
    - TZ=Asia/Shanghai
  volumes:
    - ./data:/data</code></pre></li></ul><p>3、启动服务</p><pre><code class="bash">docker compose up -d</code></pre><p>4、容器运行成功后，浏览器访问</p><pre><code class="bash">http://{IP/域名}:3000</code></pre><blockquote>首次安装需要按照页面指引手动设置管理员账号和密码，完成初始化后即可使用所设置的管理员账号登录系统。</blockquote><h2>功能体验</h2><ul><li><strong>操练场</strong></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600766" alt="" title=""/></p><ul><li><strong>数据看板</strong></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600767" alt="" title="" loading="lazy"/></p><ul><li><strong>令牌管理</strong></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600768" alt="" title="" loading="lazy"/></p><ul><li><strong>使用日志</strong></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600769" alt="" title="" loading="lazy"/></p><ul><li><strong>钱包管理</strong></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600770" alt="" title="" loading="lazy"/></p><ul><li><strong>个人设置</strong></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600771" alt="" title="" loading="lazy"/></p><ul><li><strong>渠道管理</strong></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600772" alt="" title="" loading="lazy"/></p><ul><li><strong>兑换码管理</strong></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600773" alt="" title="" loading="lazy"/></p><ul><li><strong>用户管理</strong></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600774" alt="" title="" loading="lazy"/></p><ul><li><strong>系统设置</strong></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600775" alt="" title="" loading="lazy"/></p><p>如果你正在被多平台 AI 接口管理困扰，想要一套轻量化、高拓展的大模型网关系统，<code>new-api</code> 值得一试！无论是个人学习、团队协作还是小型企业使用，都能满足你的需求。快去部署体验吧~</p><pre><code class="bash">项目地址：https://github.com/QuantumNous/new-api</code></pre><h2>最后</h2><p>推荐的开源项目已经收录到 <code>GitHub</code> 项目，欢迎 <code>Star</code>：</p><pre><code>https://github.com/chenyl8848/great-open-source-project</code></pre><p>或者访问网站，进行在线浏览：</p><pre><code>https://chencoding.top:8090/#/</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046659706" alt="" title="" loading="lazy"/></p><p><strong>我创建了一个开源项目交流群，方便大家在群里交流、讨论开源项目</strong>。</p><p><strong>但是任何人在群里打任何广告，都会被 T 掉</strong>。</p><p><strong>如果你对这个交流群感兴趣或者在使用开源项目中遇到问题，可以通过如下方式进群</strong>：</p><p><strong>关注微信公众号：【Java陈序员】，回复【开源项目交流群】进群，或者通过公众号下方的菜单添加个人微信，并备注【开源项目交流群】，通过后拉你进群</strong>。</p><blockquote>大家的点赞、收藏和评论都是对作者的支持，如文章对你有帮助还请点赞转发支持下，谢谢！</blockquote><hr/>]]></description></item><item>    <title><![CDATA[几步让你拥有免费SSL证书 才高八斗的杯子_dS2Fpp ]]></title>    <link>https://segmentfault.com/a/1190000047600785</link>    <guid>https://segmentfault.com/a/1190000047600785</guid>    <pubDate>2026-02-09 10:03:10</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在当今网络环境中，SSL证书已成为网站安全标配，它不仅保护用户数据传输安全，还能提升搜索引擎排名和用户信任度。对于大多数网站运营者来说，一年期SSL证书是性价比最高且管理相对便捷的选择。本文将为您详细解析一年期SSL证书的申请流程。</p><h4>第一步：理解SSL证书类型</h4><p>在申请前，您需要了解几种常见的SSL证书类型：</p><ol><li><strong>域名验证型（DV SSL）</strong> ：仅验证域名所有权，适合个人网站和小型企业</li><li><strong>组织验证型（OV SSL）</strong> ：验证组织真实性，适合企业官网</li><li><strong>扩展验证型（EV SSL）</strong> ：提供最高级别的验证，适合金融和电商平台</li></ol><p>一年期证书通常是DV或OV类型，EV证书多为两年期。</p><h4>第二步：申请前的准备工作</h4><ol><li><strong>确认域名所有权</strong>：确保您拥有要申请证书的域名管理权限</li><li><strong>服务器环境检查</strong>：了解您的服务器类型（Apache、Nginx、IIS等）</li><li><strong>生成CSR文件</strong>：这是证书签名请求文件，包含您的公钥和网站信息</li></ol><p>生成CSR的方法：</p><ul><li>通过服务器控制面板（如cPanel）的SSL/TLS管理工具</li><li>使用OpenSSL命令行工具</li><li>部分证书提供商可在申请过程中帮助生成</li></ul><p><img width="600" height="323" referrerpolicy="no-referrer" src="/img/bVdclop" alt="" title=""/></p><h4>第三步：申请SSL证书的具体步骤</h4><h3><a href="https://link.segmentfault.com/?enc=kfiUX5FVqd3mCv3w4fFYTg%3D%3D.SeJGvo7DVWnu4GVEE9wH%2BW9B4185afEz4FDrmW7OCIlCjutF2h%2F5yGxEShoepsmOtqhFtnaVDlivb%2Bo2NurvHw%3D%3D" rel="nofollow" target="_blank"> 免费SSL证书的获取入口</a></h3><p><strong>1、注册账号并登录</strong></p><p>首先，您需要在JoySSL的官方网站上注册一个账号。访问<strong>JoySSL</strong>官网，点击右上角的“注册”按钮，进入注册页面。在注册过程中填写相关信息，最后一栏务必填写注册码<strong>230970</strong>，这是获取免费一年期证书的关键步骤。</p><p><strong>2、选择并申请证书</strong></p><p>登录成功后，您将看到JoySSL的用户界面。找到免费一年期单域名SSL证书，0元下单支付。</p><p><strong>3、申请证书并验证域名所有权</strong></p><p>提交申请后，您将进入域名验证环节。选择域名DNS解析或者服务器文件验证，根据系统提示完成相应验证步骤。然后点击“验证”按钮。如果一切正常，系统将提示您验证成功。</p><p><strong>4、下载与安装证书</strong></p><p>一般10分钟左右签发，您可以在用户后台的“我的证书”或找到新签发的证书，并点击下载，然后把证书文件部署到相应服务器上。</p><p><strong>5、验证证书安装效果</strong></p><p>证书安装完成后，通过浏览器访问您的网站，查看地址栏是否出现绿色的安全锁图标以及HTTPS访问。</p>]]></description></item><item>    <title><![CDATA[《ESP32-S3使用指南—IDF版 V1.6》第四章 开发环境搭建（下） 正点原子 ]]></title>    <link>https://segmentfault.com/a/1190000047600792</link>    <guid>https://segmentfault.com/a/1190000047600792</guid>    <pubDate>2026-02-09 10:02:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>第四章 开发环境搭建（下）</h2><h3>4.2 IDF前端工具</h3><p>idf.py 是 ESP-IDF 开发环境中的一个重要命令行工具，用于提供前端界面，帮助开发者轻松管理工程的配置、构建、烧录以及调试等操作。它结合了CMake、Niunja和esptool.py等工具，使开发流程更加便捷和高效。<br/>idf.py 主要工具作用：<br/>1）CMake工具用于配置工程的构建流程，管理构建依赖和生成构建文件。<br/>2）Ninja工具用于实际执行构建操作，快速高效地编译项目。<br/>3）esptool.py工具用于烧录程序到目标芯片，并进行芯片的基本管理操作，如擦除闪存、复位和下载等。<br/>下图为idf.py主要工具操作流程图。<br/><img width="723" height="401" referrerpolicy="no-referrer" src="/img/bVdnSfj" alt="" title=""/><br/>图4.2.1 项目工程的构建、编译和烧录流程</p><p>在开发过程中，源代码通常依赖多个库或模块，而 CMake 可以自动分析并管理这些依赖关系。它根据开发者提供的 CMakeLists.txt 配置文件，确定哪些源文件需要编译、哪些库需要链接，确保所有依赖关系正确处理。在 ESP32 开发中，项目可能包含许多组件，CMake 能够智能地处理这些组件的构建顺序。通过 CMake 配置后，CMake 会生成构建文件（如 build.ninja），这些文件定义了如何构建项目。接下来，Ninja 工具执行具体的编译工作，生成最终的可执行文件或二进制等文件。最后，使用 esptool.py 工具将生成的二进制文件烧录到 ESP32 开发板上，确保程序能够运行。</p><h4>4.2.1 IDF常用命令</h4><p><strong>1，创建新的工程</strong></p><pre><code>idf.py create-project --path &lt;project name&gt;</code></pre><p>该命令用于创建一个新的项目目录结构，并将必要的文件和模板复制到指定目录中。其目的是帮助开发者快速设置一个新的 IoT 项目，而无需手动创建所有必要的文件和目录，从而加快项目初始化过程。<br/>下面是这个命令的解析和使用方法。<br/>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：create-project：操作功能为创建工程。<br/>③：--path：工程创建在哪个位置（可选）。<br/>④：&lt;project_name&gt;：创建工程的名称。<br/>2）使用方法<br/>首先，在桌面新建一个名为 test 的文件夹，用来保存新建的工程。然后，打开 ESP-IDF CMD 或 PowerShell 终端，输入以下命令来创建项目工程。<br/><img width="549" height="257" referrerpolicy="no-referrer" src="/img/bVdnSfk" alt="" title="" loading="lazy"/><br/>图4.2.1.1 指定路径创建工程</p><p>从上图可以看到，在桌面上的test文件夹下创建了一个名为“atk_project”的工程。</p><p><strong>2，创建新的组件</strong></p><pre><code>idf.py create-component &lt;component name&gt;
</code></pre><p>该命令用于在当前项目中创建一个新的组件（component）。它会自动生成该组件所需的基本目录结构和文件，包括CMakeLists.txt文件，以及默认的源代码文件和头文件。组件是ESP-IDF项目中重要的模块化单元，通常包含相关功能代码，便于代码的复用和管理。<br/>注意：新的组件一般放置在componen文件夹下。因此，我们需要在项目的根目录下新建一个名为 “components”的文件夹，用来保存我们创建的组件。<br/>下面是这个命令的解析和使用方法。<br/>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：create-component：操作功能为创建新的组件，如LED、KEY等驱动组件。<br/>③：：创建组件的名称。</p><p>2）使用方法<br/>首先，在test项目的根目录下新建一个components文件夹。接着，打开命令终端，进入components文件夹路径，并在该路径下输入以下命令来创建组件，如下图所示。<br/><img width="723" height="217" referrerpolicy="no-referrer" src="/img/bVdnSfl" alt="" title="" loading="lazy"/><br/>图4.2.1.2 创建新的组件</p><p>在上图中，我们首先利用“cd”命令进入到指定的项目工程路径。随后，在该路径下输入创建组件的命令，即可成功创建组件。led组件的文件结构如图所示。</p><p><img width="723" height="149" referrerpolicy="no-referrer" src="/img/bVdnSfm" alt="" title="" loading="lazy"/><br/>图4.2.1.3 led组件文件结构</p><p>上图中的 led.c 和 led.h 是典型的源代码文件和头文件，分别用于实现和声明与 LED 控制相关的功能。而 CMakeLists.txt 文件的作用是将 led 组件添加到构建系统中，使其能够参与项目的编译和构建。这也是前面笔者讲解的构建文件。</p><p><strong>3，选择目标芯片</strong></p><pre><code>idf.py set-target &lt;target&gt;
</code></pre><p>该命令的作用是设置当前项目的目标芯片。默认情况下，新建的项目工程是以 ESP32 系列芯片为模板的。如果你使用的不是 ESP32 系列芯片，而是其他乐鑫系列的芯片（如 ESP32-S3、ESP32-P4 等），则需要通过该命令切换到你所使用的目标芯片。<br/>下面是这个命令的解析和使用方法。<br/>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：set-target：操作功能为设置目标芯片。可使用（idf.py --list-targets 命令查看当前 ESP-IDF 版本支持的所有目标芯片）。<br/>③：：切换目标芯片。<br/>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令切换目标芯片。<br/><img width="556" height="207" referrerpolicy="no-referrer" src="/img/bVdnSfE" alt="" title="" loading="lazy"/><br/>图4.2.1.4 切换目标芯片<br/>执行上述命令后，test 工程下将会编译出 build 文件夹和 sdkconfig 文件。其中，sdkconfig 是 ESP-IDF 项目中的配置文件，用于定义项目的编译和运行参数。它包含各种配置选项，如目标芯片型号、外设启用情况、内存管理、网络协议栈配置等。该文件的主要作用是根据用户的需求调整项目的功能和性能。</p><p><strong>4，启动图形配置工具</strong></p><pre><code>idf.py menuconfig
</code></pre><p>该命令是启动 ESP-IDF 提供的图形化配置工具，用于方便地设置和管理项目的配置选项。<br/>下面是这个命令的解析和使用方法。<br/>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：menuconfig：操作功能为开启图形化配置界面。</p><p>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令开启图形化配置界面，如下图所示。<br/><img width="674" height="335" referrerpolicy="no-referrer" src="/img/bVdnSfG" alt="" title="" loading="lazy"/><br/>图4.2.1.4 进入图形配置工具</p><p>menuconfig界面是ESP-IDF的图形化配置工具，供开发者直观地设置项目参数；当通过该界面修改配置并保存后，这些更改会被写入sdkconfig文件中。sdkconfig文件则记录了所有配置选项，确保在项目编译时应用这些设置。因此，menuconfi是配置的操作界面，sdkconfig是配置的存储文件，两者共同作用于项目的配置管理。<br/>在以后的章节中，笔者将详细讲解menuconfig图形化配置工具中常用选项的作用，帮助大家更好地理解和学习它。</p><p><strong>5，构建工程</strong></p><pre><code>idf.py build
</code></pre><p>此命令将构建当前目录下的工程，具体步骤包括：创建用于保存构建输出文件的build目录（可使用-B选项更改路径），运行CMake以配置工程并生成构建文件，最后通过主要构建工具（Ninja或GNU Make）进行编译。默认情况下，构建工具会自动检测，也可以通过-G选项手动设置。相关构建流程请参见 图4.2.1流程图。<br/>下面是这个命令的解析和使用方法。</p><p>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：build：操作功能为构建项目。</p><p>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令构建项目，如下图所示。<br/><img width="548" height="129" referrerpolicy="no-referrer" src="/img/bVdnSfH" alt="" title="" loading="lazy"/><br/>图4.2.1.5 构建工程</p><p>编译成功后，系统会将生成的目标文件（.obj）、可执行文件（.elf）和二进制文件（.bin）等保存到 build 文件夹中。</p><p><strong>6，清除构建输出</strong></p><pre><code>idf.py clean
</code></pre><p>该命令可清除build目录中的构建输出文件，确保下次构建时工程会完全重新构建。需要注意的是，使用该命令不会删除build文件夹内的CMake配置输出。<br/>下面是这个命令的解析和使用方法。</p><p>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：clean：操作功能为清除构建输出。</p><p>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令清除构建输出文件，如下图所示。<br/><img width="542" height="170" referrerpolicy="no-referrer" src="/img/bVdnSfI" alt="" title="" loading="lazy"/><br/>图4.2.1.6 清除构建输出的文件<br/>注意：这个命令清除了由Ninja构建工具生成的文件，但不会清除CMake编译输出的文件。</p><p><strong>7，删除所有构建内容</strong></p><pre><code>idf.py fullclean
</code></pre><p>此命令将删除build目录下的所有内容，包括CMake配置输出。下次构建时，CMake会重新配置其输出。需要注意的是，该命令会递归删除build目录下的所有文件（工程配置将保留），因此请谨慎使用。<br/>下面是这个命令的解析和使用方法。<br/>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：fullclean：操作功能为清除所有构建输出文件。<br/>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令清除所有构建输出文件，如下图所示。<br/><img width="541" height="97" referrerpolicy="no-referrer" src="/img/bVdnSfL" alt="" title="" loading="lazy"/><br/>图4.2.1.7 清除所有构建输出文件</p><p><strong>8，烧录工程</strong></p><pre><code>idf.py -p COMx flash
</code></pre><p>该命令将在需要时自动构建工程，随后将其烧录到目标芯片。使用-p和-b选项可分别设置串口端口号和烧录程序的波特率。<br/>下面是这个命令的解析和使用方法。</p><p>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：-p：设置串口的端口号。<br/>③：COMx：串口的端口号。<br/>④：flash：操作功能为程序下载。</p><p>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令下载程序，如下图所示。<br/><img width="723" height="179" referrerpolicy="no-referrer" src="/img/bVdnSf6" alt="" title="" loading="lazy"/><br/>图4.2.1.8 烧录固件</p><p><strong>9，启动监视器</strong></p><pre><code>idf.py monitor
</code></pre><p>命令用于监控当前项目的运行状态。在监控之前，必须确保已安装 USB 虚拟串口驱动，或使用开发板上的 USB 串口/JTAG 接口连接设备，以便查看项目的调试输出和日志信息。<br/>下面是这个命令的解析和使用方法。</p><p>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：monitor：操作功能为启动监视器。</p><p>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令启动监视器，如下图所示。<br/><img width="500" height="96" referrerpolicy="no-referrer" src="/img/bVdnSf7" alt="" title="" loading="lazy"/><br/>图4.2.1.9 启动监视器</p><p><strong>10，合并二进制文件</strong></p><pre><code>idf.py merge-bin -o &lt;my-merged-binary&gt;.bin/.hex -f raw
</code></pre><p>在某些情况下（例如将文件传输到另一台机器，且不借ESP-IDF进行烧录），只烧录一个文件比烧录idf.py build生成的多个文件更为便捷。idf.py merge-bin命令会根据项目配置，合并引导加载程序、分区表、应用程序本身以及其他分区（如果存在），并在build文件夹中生成一个二进制文件merged-binary.[bin|hex]，之后可对其进行烧录。<br/>下面是这个命令的解析和使用方法。</p><p>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：merge-bin：操作功能为合并二进制。<br/>③：-o：输出文件<br/>④：.bin/.hex：输出文件名称<br/>⑤：-f raw：输出二进制。合并后的文件的输出格式可以是二进制（raw），IntelHex（hex）以及 UF2（uf2）</p><p>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令启动监视器，如下图所示。</p><p><img width="723" height="126" referrerpolicy="no-referrer" src="/img/bVdnSf8" alt="" title="" loading="lazy"/><br/>图4.2.1.10 输出合并二进制文件</p><h4>4.2.2 高级命令</h4><p><strong>1，打开目标芯片在线ESP-IDF编程文档</strong></p><pre><code>idf.py docs
</code></pre><p>该命令将在浏览器中打开与工程目标芯片和 ESP-IDF 版本对应的官方文档，方便用户查看相关的开发资料和参考信息。<br/>下面是这个命令的解析和使用方法。</p><p>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：docs：操作功能为打开文档。</p><p>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令打开在线文档，如下图所示。<br/><img width="575" height="129" referrerpolicy="no-referrer" src="/img/bVdnSgt" alt="" title="" loading="lazy"/><br/>图4.2.2.1 打开在线文档</p><p><strong>2，显示应用程序大小</strong></p><pre><code>idf.py size
</code></pre><p>该命令将显示应用程序大小，包括占用的RAM和flash 及各部分（如 .bss）的大小。<br/>下面是这个命令的解析和使用方法。<br/>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：size：操作功能为查看应用程序大小。</p><p>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令查看程序大小，如下图所示。<br/><img width="726" height="352" referrerpolicy="no-referrer" src="/img/bVdnSgw" alt="" title="" loading="lazy"/><br/>图4.2.2.2 查看程序相关大小</p><p><strong>3，查看组件应用程序大小</strong></p><pre><code>idf.py size-components
</code></pre><p>该命令将显示工程中各个组件的应用程序大小，帮助开发者了解每个组件在应用中的存储占用情况。<br/>下面是这个命令的解析和使用方法。<br/>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：size-components：操作功能为查询各组件的大小。<br/>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令查看各组件的大小，如下图所示。<br/><img width="723" height="480" referrerpolicy="no-referrer" src="/img/bVdnSgU" alt="" title="" loading="lazy"/><br/>图4.2.2.3 各组件的应用程序大小（部分截图）</p><p><strong>4，查看每个源文件大小</strong></p><pre><code>idf.py size-files
</code></pre><p>该命令将显示工程中每个源文件的大小，并支持通过--format选项指定输出格式（支持text、csv、json，默认格式为text）。此外，还可以使用--output-file参数指定输出文件的文件名，而不是将结果输出到标准输出。<br/>下面是这个命令的解析和使用方法。<br/>1）命令解析<br/>①：idf.py：是 ESP-IDF 工具链的主要命令行工具。<br/>②：size-files：操作功能为查询g工程每个源文件大小。<br/>2）使用方法<br/>首先，在 PowerShell 终端中切换到项目工程的根目录。然后，输入下图命令查看工程每个源文件的大小，如下图所示。<br/><img width="723" height="264" referrerpolicy="no-referrer" src="/img/bVdnSgW" alt="" title="" loading="lazy"/><br/>图4.2.2.4 查看工程每个源文件的大小（部分截图）</p><p>比较常用的高级命令就讲解到这里了。如果读者想了解更多高级命令，可以参考乐鑫官方在线文档中的“IDF前端工具”章节，里面对各个命令的使用和功能有非常详细的介绍。</p><h3>4.3 搭建集成开发环境</h3><p>在上一小节中，笔者详细阐述了命令式开发的常用命令。然而，对于初学者来说，他们往往更倾向于使用图形界面式的开发方式，因为图形界面能更直观地展示整个开发过程。因此，作者在此推荐使用VS Code IDE作为开发工具。VS Code 支持下载ESP-IDF插件，方便开发者进行项目开发和调试。该插件集成了编辑、编译、烧录和调试等基础功能，还提供工具安装SDK配置和CMake编辑器等附加功能，简化并增强了开发人员在VS Code中开发基于ESP32的IoT应用程序的体验。</p><h4>4.3.1 VS Code环境安装</h4><p>鉴于我们使用的是VS Code IDE搭配乐鑫ESP-IDF进行开发，接下来将介绍VS Code的安装过程。首先，访问VS Code的官方（<a href="https://link.segmentfault.com/?enc=n3uqDYoiQr%2F3K9IaCO9ObQ%3D%3D.INKx%2BI9%2BR6fMmDDaKRHV0X159f53bW7YCwKPMFfajabx8A5j8Ol00jvT7hZGdzsH" rel="nofollow" target="_blank">https://code.visualstudio.com/Download</a>）下载页面，根据系统需求选择相应的安装包进行下载。此外，也可以在A盘 6 ，软件资料 1 ， 软件 1 ，IDF开发工具路径下找到VS Code的安装包。下图为VS Code的官方下载页面。<br/><img width="723" height="272" referrerpolicy="no-referrer" src="/img/bVdhx54" alt="" title="" loading="lazy"/><br/>图4.3.1.1 VS Code官网下载界面<br/>在此，我们选择下载Windows版本的VS Code，因为我们是在Windows环境下进行开发。虽然其他版本的下载方式应该类似，但这里我们将重点介绍Windows版本的下载步骤。下载完成后，按照以下步骤进行安装即可：<br/>1，以&lt;管理员身份&gt;运行VSCodeUserSetup-x64-1.94.2.exe安装包，如下图所示。<br/><img width="465" height="74" referrerpolicy="no-referrer" src="/img/bVdnShE" alt="" title="" loading="lazy"/><br/>图4.3.1.2 以管理员身份运行VSCode安装包<br/>2，此时，进入安装的许可协议页面，如下图所示。<br/><img width="597" height="463" referrerpolicy="no-referrer" src="/img/bVdnShI" alt="" title="" loading="lazy"/><br/>图4.3.1.3 安装许可协议<br/>3，选择“我同意此协议”，然后点击“下一步”进入选择目标位置页面，如下图所示。<br/><img width="698" height="571" referrerpolicy="no-referrer" src="/img/bVdhx6a" alt="" title="" loading="lazy"/><br/>图4.3.1.4 设置安装路径<br/>用户可以自行填写安装位置，但需注意，安装路径最好使用全英文字符，以避免可能出现的路径识别问题。<br/>4，设置安装路径完成后，可点击“下一步”进入选择开始菜单文件夹，如下图所示。<br/><img width="698" height="571" referrerpolicy="no-referrer" src="/img/bVdhx6b" alt="" title="" loading="lazy"/><br/>图4.3.1.5 选择开始菜单文件夹<br/>5，这里我们保持默认配置，接着，点击“下一步”进入选择附加任务页面，如下图所示。<br/><img width="599" height="463" referrerpolicy="no-referrer" src="/img/bVdnShO" alt="" title="" loading="lazy"/><br/>图4.3.1.6 选择附加任务<br/>6，请把附加任务全部勾选，然后点击“下一步”进入准备安装页面，如下图所示。<br/><img width="598" height="463" referrerpolicy="no-referrer" src="/img/bVdnShX" alt="" title="" loading="lazy"/><br/>图4.3.1.7 准备安装页面<br/>7，点击“安装”按钮即可开始安装VS Code集成开发环境。安装成功后，界面将如图所示。<br/><img width="723" height="502" referrerpolicy="no-referrer" src="/img/bVdhx6e" alt="" title="" loading="lazy"/><br/>图4.3.1.8 VSCode 安装成功<br/>值得注意的是，第一次安装的VS Code软件为英文版本。如果读者希望将VS Code设置为中文汉化，则需要安装简体中文插件。安装方式如下。<br/>在VS Code集成开发环境中，可以通过点击左侧的“扩展”图标或使用快捷键“Ctrl + Shift + X”直接进入扩展页面。在搜索栏中输入“Chinese”，然后选择安装“Chinese (Simplified) Language Pack for Visual Studio Code”插件，如下图所示。安装完成后，必须重启VS Code才能切换为简体中文界面。<br/><img width="723" height="359" referrerpolicy="no-referrer" src="/img/bVdnSh8" alt="" title="" loading="lazy"/><br/>图4.3.1.9 安装简体中文插件<br/>至此，VS Code的安装过程就完成了。</p><h4>4.3.2 ESP-IDF插件安装与配置</h4><p>ESP-IDF插件在安装后会调用之前安装的ESP-IDF提供的各种工具和功能，为开发者提供一个集成的开发环境。具体而言，插件利用ESP-IDF的构建系统，使开发者能够轻松编译项目，并集成烧录工具，以便直接将固件烧录到目标设备。此外，插件还调用ESP-IDF监控功能，实时查看设备输出，帮助进行调试。同时，它提供图形化界面，简化了项目参数的配置过程。简单来说ESP-IDF插件通过图形化方式结合ESP-IDF和ESP-IDF Tools，对项目进行构建，从而提升开发效率和用户体验。<br/>下图是ESP-IDF插件、ESP-IDF Tools、ESP-IDF、ESP Component Registry和Project关系图。<br/><img width="723" height="249" referrerpolicy="no-referrer" src="/img/bVdnSib" alt="" title="" loading="lazy"/><br/>图4.3.2.1 项目工程编译关系图<br/>在项目开发过程中，ESP-IDF插件、ESP-IDF Tools、ESP-IDF（SDK）和ESP Component Registry协同工作，形成一个集成的开发流程。ESP-IDF插件提供了用户友好的图形界面，允许开发者提交编译、烧录等命令，并接收调试反馈。ESP-IDF Tools负责处理项目需求和执行编译、构建工作。ESP-IDF作为核心开发平台，提供了必要的核心组件，如BSP和RTOS，而ESP Component Registry则为开发者提供大量开源组件。最终，项目通过这些工具和组件库完成构建，输出最终的结果。<br/>接下来，笔者将详细介绍如何在VS Code集成开发环境下安装ESP-IDF插件的具体步骤。<br/>首先，打开VS Code软件，按下快捷键“Ctrl + Shift + X”进入扩展页面。在搜索栏中输入“ESP-IDF”进行搜索，然后点击“安装”按钮进行插件安装。下图展示了具体操作步骤。<br/><img width="723" height="140" referrerpolicy="no-referrer" src="/img/bVdnSij" alt="" title="" loading="lazy"/><br/>图4.3.2.2 下载与安装ESP-IDF插件<br/>按下快捷键“F1”或“Ctrl + Shift + P”打开“显示所有命令”界面。然后，在搜索框中输入“Configure ESP-IDF”，并从下拉菜单中选择此选项，进入 ESP-IDF 配置界面，如下图所示。<br/><img width="723" height="322" referrerpolicy="no-referrer" src="/img/bVdnPDf" alt="" title="" loading="lazy"/><br/>图4.3.2.3 配置ESP-IDF扩展<br/>回车后，将进入配置 ESP-IDF 插件的界面，如下图所示。<br/><img width="723" height="375" referrerpolicy="no-referrer" src="/img/bVdnPDk" alt="" title="" loading="lazy"/><br/>图4.3.2.4 进入ESP-IDF插件配置界面<br/>在上图中，点击“USE EXISTING SETUP”使用现有的ESP-IDF，如下图所示。<br/><img width="723" height="332" referrerpolicy="no-referrer" src="/img/bVdnSix" alt="" title="" loading="lazy"/><br/>图4.3.2.5 搜索当前系统的ESP-IDF<br/>如果在“Search ESP-IDF in System”下看到你想要安装的版本（例如上图的v5.3），可以直接点击该版本进行安装。如果没有找到所需版本，则点击“Search ESP-IDF in System”选项进入手动配置，通过指定路径来完成安装，如下图所示。<br/><img width="723" height="384" referrerpolicy="no-referrer" src="/img/bVdnSiw" alt="" title="" loading="lazy"/><br/>图4.3.2.6 手动安装ESP-IDF<br/>在上图中，首先选择“Select download server”和“Select ESP-IDF version”选项，确保与上图中的配置一致。接着，在“Enter ESP-IDF directory (IDF_PATH):”选项中设置为我们之前安装ESP-IDF（SDK）的路径，并在“Enter ESP-IDF Tools directory (IDF_TOOLS_PATH)”选项中设置为IDF_TOOLS_PATH/tools路径（IDF_TOOLS_PATH路径请看系统环境变量）。确保所有设置完成后，点击上图中的“install”按钮，开始安装ESP-IDF。<br/>当出现下图的所示，表示我们的ESP-IDF安装成功。<br/><img width="723" height="209" referrerpolicy="no-referrer" src="/img/bVdnSiv" alt="" title="" loading="lazy"/><br/>图4.3.2.7 ESP-IDF插件配置成功<br/>至此，我们已经成功配置了ESP-IDF插件，并且完成了与ESP-IDF（SDK）和ESP-IDF Tools的集成。这使我们可以在VSCode集成开发环境下，顺利进行项目的编译、烧录和调试工作，实现高效的开发流程。</p><h4>4.3.3 VSCode的个性化配置（可选）</h4><p>在Visual Studio Code（VS Code）中，settings.json文件用于存储用户的个性化配置和工作环境设置。它控制了编辑器的外观、代码格式化风格、自动补全行为、调试配置等，配置可以分为用户设置（全局设置）和工作区设置（针对特定项目）。以下是配置settings.json文件的流程：<br/><strong>1，打开设置界面</strong><br/>菜单栏中选择 文件 &gt; 首选项 &gt; 设置，进入 VS Code 的设置页。<br/><strong>2，添加个性化配置和工作环境设置参数</strong><br/>添加内容如下：</p><pre><code>{
    /* 上面的部分是我自己创建的一些设置 */ 
    "editor.insertSpaces": true,
    /* 自动插入空格禁用*/ 
    "editor.detectIndentation": true,
    /* 启用时根据文件内容进行重写*/ 
    "editor.renderControlCharacters": true,
    /* 是否显示控制字符：启用*/ 
    "editor.renderWhitespace": "all",
    /* 显示4个空格是.... */ 
    "editor.tabSize": 4,
    /* tab 设置为4个空格*/ 
    "editor.fontSize": 18,
}</code></pre><p>至此，我们已成功完成VS Code集成开发环境中ESP-IDF插件的安装，并配置好了VS Code的工作环境。在接下来的章节中，笔者将详细讲解如何在VS Code IDE中新建一个ESP-IDF项目工程，并进一步探讨工程的调试工具及相关配置的使用，以帮助大家更好地进行项目开发。</p>]]></description></item><item>    <title><![CDATA[【节点】[Exposure节点]原理解析与实际应用 SmalBox ]]></title>    <link>https://segmentfault.com/a/1190000047600812</link>    <guid>https://segmentfault.com/a/1190000047600812</guid>    <pubDate>2026-02-09 10:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><a href="https://link.segmentfault.com/?enc=BtrbjsbpsBfvo5K6kcz09g%3D%3D.UNCZO0pzHimSCI8bXMZGZ4oGVEGI5WyICE%2Fzqoy6h1AbRmwmSusXFPb%2B7wU20V3IcBSzaBKGmG7D1NXMV69ceClgL%2BNEuHEuLrmn1l2t5nr6D2QvHrsvflJ8YsbMoAiy9wgE%2FXkMaq%2BhbZnZtKnpGrv4MZiop8BIvYPUL5ErMoO%2BfRQpLhxM80HWYUGiuAGTNwJBs0zITqvsVo6p%2Bv9BV40EffZQt4xIum6x%2FM5hD%2B4%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong></blockquote><p>曝光节点是Unity Shader Graph中一个功能强大的工具节点，专门用于在着色器中访问摄像机的曝光信息。在基于物理的渲染（PBR）流程中，曝光控制是实现高动态范围（HDR）渲染的关键组成部分，而曝光节点则为着色器艺术家提供了直接访问这些曝光参数的途径。</p><p>曝光节点的核心功能是从当前渲染管线中获取摄像机的曝光值，使着色器能够根据场景的曝光设置做出相应的反应。这在创建对光照条件敏感的着色器效果时尤为重要，比如自动调整材质亮度、实现曝光自适应效果或者创建与摄像机曝光设置同步的后期处理效果。</p><p>在现代化的游戏开发中，HDR渲染已经成为标准配置，它允许场景中的亮度值超出传统的0-1范围，从而能够更真实地模拟现实世界中的光照条件。曝光节点正是在这样的背景下发挥着重要作用，它架起了着色器与渲染管线曝光系统之间的桥梁。</p><h2>渲染管线兼容性</h2><p>曝光节点在不同渲染管线中的支持情况是开发者需要特别注意的重要信息。了解节点的兼容性有助于避免在项目开发过程中遇到意外的兼容性问题。</p><table><thead><tr><th><strong>节点</strong></th><th><strong>通用渲染管线 (URP)</strong></th><th><strong>高清渲染管线 (HDRP)</strong></th></tr></thead><tbody><tr><td>Exposure</td><td>否</td><td>是</td></tr></tbody></table><p>从兼容性表格中可以清楚地看到，曝光节点目前仅在高清渲染管线（HDRP）中得到支持，而在通用渲染管线（URP）中不可用。这一差异主要源于两种渲染管线在曝光处理机制上的根本区别。</p><p>HDRP作为Unity的高端渲染解决方案，内置了完整的物理相机和曝光系统，支持自动曝光（自动曝光适应）和手动曝光控制。HDRP的曝光系统基于真实的物理相机参数，如光圈、快门速度和ISO感光度，这使得它能够提供更加真实和灵活的曝光控制。</p><p>相比之下，URP虽然也支持HDR渲染，但其曝光系统相对简化，主要提供基本的曝光补偿功能，而没有HDRP那样完整的物理相机模拟。因此，URP中没有提供直接访问曝光值的Shader Graph节点。</p><p>对于URP用户，如果需要实现类似的功能，可以考虑以下替代方案：</p><ul><li>使用自定义渲染器特性传递曝光参数</li><li>通过脚本将曝光值作为着色器全局属性传递</li><li>使用URP提供的其他光照相关节点间接实现类似效果</li></ul><h2>端口详解</h2><p>曝光节点的端口配置相对简单，但理解每个端口的特性和用途对于正确使用该节点至关重要。</p><table><thead><tr><th>名称</th><th>方向</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><strong>Output</strong></td><td>输出</td><td>Float</td><td>曝光值。</td></tr></tbody></table><p>曝光节点只有一个输出端口，这意味着它只能作为数据源在Shader Graph中使用，而不能接收外部输入。这种设计反映了曝光值的本质——它是从渲染管线的相机系统获取的只读参数。</p><p>输出端口的Float类型表明曝光值是一个标量数值，这个数值代表了当前帧或上一帧的曝光乘数。在HDRP的曝光系统中，这个值通常用于将场景中的光照值从HDR范围映射到显示设备的LDR范围。</p><p>理解曝光值的数值范围对于正确使用该节点非常重要：</p><ul><li>当曝光值为1.0时，表示没有应用任何曝光调整</li><li>曝光值大于1.0表示增加曝光（使图像更亮）</li><li>曝光值小于1.0表示减少曝光（使图像更暗）</li><li>在自动曝光系统中，这个值会根据场景亮度动态变化</li></ul><p>在实际使用中，曝光节点的输出可以直接用于乘法运算来调整材质的亮度，或者用于更复杂的曝光相关计算。例如，在创建自发光材质时，可以使用曝光值来确保材质在不同曝光设置下保持视觉一致性。</p><h2>曝光类型深度解析</h2><p>曝光节点的核心功能通过其曝光类型（Exposure Type）设置来实现，这个设置决定了节点从渲染管线获取哪种类型的曝光值。理解每种曝光类型的特性和适用场景是掌握该节点的关键。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><strong>CurrentMultiplier</strong></td><td>从当前帧获取摄像机的曝光值。</td></tr><tr><td><strong>InverseCurrentMultiplier</strong></td><td>从当前帧获取摄像机的曝光值的倒数。</td></tr><tr><td><strong>PreviousMultiplier</strong></td><td>从上一帧获取摄像机的曝光值。</td></tr><tr><td><strong>InversePreviousMultiplier</strong></td><td>从上一帧获取摄像机的曝光值的倒数。</td></tr></tbody></table><h3>CurrentMultiplier（当前帧曝光乘数）</h3><p>CurrentMultiplier是最常用的曝光类型，它提供当前帧相机的实时曝光值。这个值反映了相机系统根据场景亮度和曝光设置计算出的当前曝光乘数。</p><p>使用场景示例：</p><ul><li>实时调整材质亮度以匹配场景曝光</li><li>创建对曝光敏感的特殊效果</li><li>确保自定义着色器与HDRP曝光系统同步</li></ul><p>技术特点：</p><ul><li>值随每帧更新，响应实时变化</li><li>直接反映当前相机的曝光状态</li><li>适用于大多数需要与曝光同步的效果</li></ul><h3>InverseCurrentMultiplier（当前帧曝光乘数倒数）</h3><p>InverseCurrentMultiplier提供当前帧曝光值的倒数，即1除以曝光乘数。这种类型的曝光值在某些特定计算中非常有用，特别是当需要抵消曝光影响时。</p><p>使用场景示例：</p><ul><li>在后期处理效果中抵消曝光影响</li><li>创建在任意曝光设置下保持恒定亮度的元素</li><li>进行曝光相关的颜色校正计算</li></ul><p>技术特点：</p><ul><li>值与CurrentMultiplier互为倒数</li><li>可用于"反向"曝光计算</li><li>在需要保持恒定视觉亮度的效果中特别有用</li></ul><h3>PreviousMultiplier（上一帧曝光乘数）</h3><p>PreviousMultiplier提供上一帧的曝光值，这在某些需要平滑过渡或避免闪烁的效果中非常有用。由于自动曝光系统可能会导致曝光值在帧之间变化，使用上一帧的值可以提供更加稳定的参考。</p><p>使用场景示例：</p><ul><li>实现曝光平滑过渡效果</li><li>避免因曝光突变导致的视觉闪烁</li><li>时间相关的曝光计算</li></ul><p>技术特点：</p><ul><li>提供前一帧的曝光状态</li><li>有助于减少曝光突变带来的视觉问题</li><li>在时间性效果中提供一致性</li></ul><h3>InversePreviousMultiplier（上一帧曝光乘数倒数）</h3><p>InversePreviousMultiplier结合了上一帧数据和倒数计算，为特定的高级应用场景提供支持。这种曝光类型在需要基于历史曝光数据进行复杂计算的效果中发挥作用。</p><p>使用场景示例：</p><ul><li>基于历史曝光的数据分析</li><li>复杂的时序曝光效果</li><li>高级曝光补偿算法</li></ul><p>技术特点：</p><ul><li>结合了时间延迟和倒数计算</li><li>适用于专业的曝光处理需求</li><li>在高级渲染技术中使用</li></ul><h2>实际应用案例</h2><h3>HDR自发光材质</h3><p>在HDRP中创建自发光材质时，使用曝光节点可以确保材质在不同曝光设置下保持正确的视觉表现。以下是一个基本的实现示例：</p><ol><li>创建Shader Graph并添加Exposure节点</li><li>设置曝光类型为CurrentMultiplier</li><li>将自发光颜色与曝光节点输出相乘</li><li>连接到主节点的Emission输入</li></ol><p>这种方法确保了自发光材质的亮度会随着相机曝光设置自动调整，在低曝光情况下不会过亮，在高曝光情况下不会过暗。</p><h3>曝光自适应效果</h3><p>利用PreviousMultiplier和CurrentMultiplier可以创建平滑的曝光过渡效果，避免自动曝光调整时的突兀变化：</p><ol><li>添加两个Exposure节点，分别设置为PreviousMultiplier和CurrentMultiplier</li><li>使用Lerp节点在两者之间进行插值</li><li>通过Time节点控制插值速度</li><li>将结果用于需要平滑过渡的效果</li></ol><p>这种技术特别适用于全屏效果或UI元素，可以确保视觉元素在曝光变化时平稳过渡。</p><h3>曝光不变元素</h3><p>某些场景元素可能需要在不同曝光设置下保持恒定的视觉亮度，这时可以使用InverseCurrentMultiplier：</p><ol><li>使用Exposure节点设置为InverseCurrentMultiplier</li><li>将需要保持恒定亮度的颜色值与曝光倒数相乘</li><li>这样可以抵消相机曝光对特定元素的影响</li></ol><p>这种方法常用于UI渲染、调试信息显示或其他需要独立于场景曝光的视觉元素。</p><h2>性能考虑与最佳实践</h2><p>虽然曝光节点本身性能开销很小，但在实际使用中仍需注意一些性能优化策略：</p><ul><li>避免在片段着色器中过度复杂的曝光计算</li><li>考虑使用顶点着色器进行曝光相关计算（如果适用）</li><li>对于静态物体，可以评估是否真的需要每帧更新曝光值</li><li>在移动平台使用时注意测试性能影响</li></ul><p>最佳实践建议：</p><ul><li>在HDRP项目中充分利用曝光节点确保视觉一致性</li><li>理解不同曝光类型的适用场景，选择合适的类型</li><li>结合HDRP的Volume系统测试着色器在不同曝光设置下的表现</li><li>在自动曝光和手动曝光模式下都进行测试</li></ul><h2>故障排除与常见问题</h2><p>在使用曝光节点时可能会遇到一些常见问题，以下是相应的解决方案：</p><ul><li><strong>节点在URP中不可用</strong>：这是预期行为，曝光节点仅支持HDRP</li><li><strong>曝光值不更新</strong>：检查相机是否启用了自动曝光，在手动曝光模式下值可能不变</li><li><strong>效果不符合预期</strong>：确认使用了正确的曝光类型，不同场景需要不同的类型</li><li><strong>移动端表现异常</strong>：某些移动设备可能对HDR支持有限，需进行针对性测试</li></ul><p>调试技巧：</p><ul><li>使用Debug节点输出曝光值检查实际数值</li><li>在不同光照环境下测试着色器表现</li><li>对比手动曝光和自动曝光模式下的效果差异</li></ul><hr/><blockquote><a href="https://link.segmentfault.com/?enc=5NKfChPU8LnaukNe84S4Ow%3D%3D.2Pr4yQk6q%2B%2BQpOYFdTNuYy6C9qi767maTbJWu1P0CZhO1rRBTWiCVBnXpli6tETLDzfNB%2BaeNIlgPwzUQLXYSd4hR5boD1T5bRdyBYcNrMWwJiny13pPcl5%2Flb%2Fv%2F9LJhGczxcXW4QExfdV1qRQGSQk63UzDBlLsumW7jIJuNGSUA6vZmUZVhQGt9iSR8ocxhPzoKeYiD0K25HxpNEklefqSxXwMZH7SKmoM0pbQV4s%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong><br/>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</blockquote>]]></description></item><item>    <title><![CDATA[Dictionary 类 兔子码农 ]]></title>    <link>https://segmentfault.com/a/1190000047600741</link>    <guid>https://segmentfault.com/a/1190000047600741</guid>    <pubDate>2026-02-09 09:02:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>表示键和值的集合。</p><pre><code class="C#">public class Dictionary &lt; T键 ,
 T值 &gt; : System . Collections . Generic . ICollection &lt; System . Collections . Generic . KeyValuePair &lt; T键 ,
 T值 &gt; &gt;,
 System . Collections . Generic . IDictionary &lt; T键 ,
 T值 &gt; ,
 System . Collections . Generic . IEnumerable &lt; System . Collections . Generic . KeyValuePair &lt; T键 ,
 T值 &gt; &gt; ,
 System . Collections . Generic . IReadOnlyCollection &lt; System . Collections . Generic . KeyValuePair &lt; T键 ,
 T值 &gt; &gt; ,
 System . Collections . Generic . IReadOnlyDictionary &lt; T键 ,
 T值 &gt; ,
 System . Collections . IDictionary ,
 System . Runtime . Serialization . IDeserializationCallback ,
 System . Runtime . Serialization . ISerializable</code></pre><h2>参数</h2><table><thead><tr><th>参数</th><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>T键<br/>T值</td><td>T</td><td>字典中的 键 和值 的类型</td></tr></tbody></table><h2>继承</h2><table><thead><tr><th>Object</th><th>Dictionary &lt; T键 , T值 &gt;</th></tr></thead></table><h2>派生</h2><p>System . ServiceModel . MessageQuerySet</p><h2>实现</h2><p>ICollection &lt; KeyValuePair &lt; T键 , T值 &gt; &gt; , IDictionary &lt; T键 , T值 &gt; , IEnumerable &lt; KeyValuePair &lt; T键 , T值 &gt; &gt; , IEnumerable &lt; T &gt; , IReadOnlyCollection &lt; KeyValuePair &lt; T键 , T值 &gt; &gt; , IReadOnlyDictionary &lt; T键 , T值 &gt; , ICollection , IDictionary , IEnumerable , IDeserializationCallback , ISerializable</p><h2>示例</h2><p>以下代码示例创建了一个带有字符串键的 Empty Dictionary &lt; T键 , T值 &gt; 字符串集合，并使用Add方法添加一些元素。该示例展示了在尝试添加重复键时，Add 方法会抛出 ArgumentException。</p><p>此示例使用 Item [ ] 属性（C# 中的索引器）来检索值，展示了当请求的键不存在时会抛出 KeyNotFoundException，并表明与键相关联的值可以被替换。</p><p>此示例展示了如果程序经常需要尝试查找不在字典中的键值，如何使用 TryGetValue 方法作为一种更高效的取值方式，还展示了在调用 Add 方法之前，如何使用 ContainsKey 方法来测试某个键是否存在。</p><p>这个示例展示了如何枚举字典中的键和值，以及如何使用 Keys 属性和 Values 属性单独枚举键和值。</p><p>最后，该示例演示了 Remove 方法。</p><pre><code class="C#">// 创建一个以 string 为键，以 string 为值的 Dictionary（描述不同的文件类型的打开方式）
Dictionary &lt; string , string &gt; CD打开 = [ ];

CD打开 . Add ( "txt" , "notepad.exe" );
CD打开 . Add ( "bmp" , "paint.exe" );
CD打开 . Add ( "dib" , "paint.exe" ); // 键必须不同，但值可以相同
CD打开 . Add ( "rtf" , "wordpad.exe" );

try
    {
    CD打开 . Add ( "txt" , "winword.exe" ); // 向词典中添加一个元素
    }
catch ( ArgumentException yc ) // 由于键 txt 已存在，将会产生 ArgumentException
    {
    Console . WriteLine ( $"一个使用键 \"txt\" 的元素已存在；{yc . Message}" );
    }

Console . WriteLine ( $"使用键 \"rtf\" 的元素，值是：{CD打开 [ "rtf" ]}" );

// 如果键不存在，为键创建一个新的 键/值 对
CD打开 [ "docx" ] = "winword.exe";

// 当键不存在时，索引器抛出 KeyNotFoundException
try
    {
    Console . WriteLine ( $"使用键 \"tif\" 的元素，值是：{CD打开 [ "tif" ]}" );
    }
catch ( KeyNotFoundException yc )
    {
    Console . WriteLine ( $"使用键 \"tif\" 的元素不存在；{yc . Message}" );
    }

// 当键不存在时，TryGetValue 返回 null
if ( CD打开 . TryGetValue ( "tif" , out string? zfc ) )
    {
    Console . WriteLine ( $"使用键 \"tif\" 的元素，值是：{zfc}" );
    }
else
    {
    Console . WriteLine ( $"使用键 \"tif\" 的元素不存在" );
    }

// 可以使用 ContainsKey，多写一行 add 语句
if ( CD打开 . TryAdd ( "ht" , "hypertrm.exe" ) )
    {
    Console . WriteLine ( $"使用键 \"ht\" 的元素，值是：{CD打开 [ "ht" ]}" );
    }

// Dictionary 的每一个元素对应一个 KeyValuePair
Console . WriteLine ( );
foreach ( KeyValuePair &lt; string , string &gt; dui in CD打开 )
    {
    Console . WriteLine ( $"键 = {dui . Key}；值 = {dui . Value}" );
    }

// ValueCollection 对应 Dictionary 的值的组合
Console . WriteLine ( );
Dictionary &lt; string , string &gt; . ValueCollection ZhiZU = CD打开 . Values;
foreach ( string z in ZhiZU )
    {
    Console . WriteLine ( $"值 = {z}" );
    }

// 移除某个 Dictionary 项
Console . WriteLine ( "\nRemove(\"docx\")" );
CD打开 . Remove ( "docx" );
if ( !CD打开 . ContainsKey ( "docx" ) )
    {
    Console . WriteLine ( "键 \"docx\" 不存在" );
    }</code></pre><h2>备注</h2><p>泛型类 Dictionary &lt; T键 , T值 &gt; 提供了从一组键到一组值的映射。向字典添加的每个元素都包含一个值及其关联的键。通过键检索值的速度非常快，接近 O （1），因为 Dictionary &lt; T键 , T值 &gt; 类是作为哈希表实现的。但当 键 对象返回同一个哈希值时，检索速度将会变慢，应尽量使用系统内置（Int32/String 等）的密封类作为键类型。</p><p><strong>注意</strong>：检索速度取决于为 T键 指定的哈希算法的质量。</p><p>只要一个对象在 Dictionary &lt; T键 , T值 &gt; 中用作键，它就绝不能以任何会影响其哈希值的方式发生更改。根据字典的相等比较器，Dictionary &lt; T键 , T值 &gt; 中的每个键都必须是唯一的。键不能为 null，但如果值的类型 T值 是引用类型，则值可以为 null。</p><p>Dictionary &lt; T键 ,T值 &gt; 需要一个相等性实现来确定键是否相等。您可以通过使用接受 比较器 参数的构造函数来指定 IEqualityComparer &lt; T &gt; 泛型接口的实现；如果不指定实现，则使用默认泛型相等比较器 EqualityComparer &lt; T &gt; . Default。如果类型 T键 实现了 System . IEquatable &lt; T &gt; 泛型接口，默认相等比较器将使用该实现。</p><p><strong>注意</strong>：例如，你可以使用 StringComparer 类提供的不区分大小写的字符串比较器来创建具有不区分大小写的字符串键的字典。</p><p>Dictionary &lt; T键 , T值 &gt; 的容量是指 Dictionary &lt; T键 , T值 &gt; 可容纳的元素数量。当向 Dictionary &lt; T键 , T值 &gt; 中添加元素时，会通过重新分配内部数组，根据需要自动增加容量。</p><p>仅限于 .NET Framework：对于非常大的 Dictionary &lt; T键 , T值 &gt; 对象，在 64 位系统上，通过在运行时环境中将 &lt; gcAllowVeryLargeObjects &gt; 配置元素的 enabled 属性设置为 true，可以将最大容量增加到 20 亿个元素。</p><p>为便于枚举，字典中的每个项都被视为一个 KeyValuePair &lt; T键 , T值 &gt; 结构，该结构表示一个值及其键。返回项的顺序是未定义的。</p><p>C# 语言的 foreach 语句（Visual Basic 中为 For Each）返回集合中元素类型的对象。由于 Dictionary &lt; T键 , T值 &gt; 是键和值的集合，因此元素类型既不是键的类型，也不是值的类型。相反，元素类型是键类型和值类型的 KeyValuePair &lt; T键 , T值 &gt;。例如：</p><pre><code class="C#">foreach( KeyValuePair &lt; string , string &gt; dui in CDA )
{
    Console . WriteLine ( $"键 = {dui . Key} , 值 = {dui . Value}" );
}</code></pre><p>foreach 语句是枚举器的包装器，它只允许从集合中读取数据，而不允许向集合中写入数据。所以，不要在类似上述语句中添加 Add、Remove 等语句，仅限于查看其值。</p><p><strong>注意</strong>：由于 key 可以被继承且其行为可以被更改，因此使用 Equals 方法进行比较无法保证它们的绝对唯一性。</p><h2>构造函数</h2><h3>重载</h3><table><thead><tr><th>构造函数</th><th>描述</th></tr></thead><tbody><tr><td>Dictionary &lt; T键 , T值 &gt; ( )</td><td>初始化 Dictionary &lt; T键 , T值 &gt; 类的新实例（NotEmpty，即元素数为 0），但具有默认的初始容量，并使用键类型的默认相等比较器</td></tr><tr><td>Dictionary &lt; T键 , T值 &gt; ( IDictionary &lt; T键 , T值 &gt; )</td><td>初始化 Dictionary &lt; T键 , T值 &gt; 类的新实例，该实例包含从指定的 IDictionary &lt; T键 , T值 &gt; 中复制的元素，并使用键类型的默认相等比较器</td></tr><tr><td>Dictionary &lt; T键 , T值 &gt; ( IEnumerable &lt; KeyValuePair &lt; T键 , T值 &gt; &gt; )</td><td>初始化 Dictionary &lt; T键 , T值 &gt; 类的新实例 , 该实例包含从指定的 IEnumerable &lt; T &gt; 中复制的元素</td></tr><tr><td>Dictionary &lt; T键 , T值 &gt; ( IEqualityComparer &lt; T键 &gt; )</td><td>初始化 Dictionary &lt; T键 , T值 &gt; 类的新实例（NotEmpty，即元素数为 0），具有默认的初始容量，并使用指定的 IEqualityComparer &lt; T &gt;</td></tr><tr><td>Dictionary &lt; T键 , T值 &gt; ( Int32 初始容量 )</td><td>初始化 Dictionary &lt; T键 , T值 &gt; 类的新实例（NotEmpty，即元素数为 0），具有指定的初始容量，并使用键类型的默认相等比较器</td></tr><tr><td>Dictionary &lt; T键 , T值 &gt; ( IDictionary &lt; T键 , T值 &gt; , IEqualityComparer &lt; T键 &gt; )</td><td>初始化 Dictionary &lt; T键 , T值 &gt; 类的新实例 , 该实例包含从指定的 IDictionary &lt; T键 , T值 &gt; 中复制的元素 , 并使用指定的 IEqualityComparer &lt; T &gt;</td></tr><tr><td>Dictionary &lt; T键 , T值 &gt; ( IEnumerable &lt; KeyValuePair &lt; T键 , T值 &gt; &gt; , IEqualityComparer &lt; T键 &gt; )</td><td>初始化 Dictionary &lt; T键 , T值 &gt; 类的新实例，该实例包含从指定的 IEnumerable &lt; T &gt; 中复制的元素，并使用指定的 IEqualityComparer &lt; T &gt;</td></tr><tr><td>Dictionary &lt; T键 , T值 &gt; ( Int32 初始容量 , IEqualityComparer &lt; T键 &gt; )</td><td>初始化 Dictionary &lt; T键 , T值 &gt; 类的新实例（NotEmpty，即元素数为 0），具有指定的初始容量，并使用指定的 IEqualityComparer &lt; T &gt;</td></tr></tbody></table><p><strong>备注</strong>：NotEmpty 可以类比于水瓶子，即不是 null（不存在，你没有瓶子），又不是 Empty（空、只读的，即你的水瓶子打不开），而是有容量但实际又没有元素的 Dictionary（你可以随时添加水且容量自动扩容的水瓶子），可以随时添加其元素。</p><pre><code class="C#">public Dictionary ( );
public Dictionary ( System . Collections . Generic . IDictionary &lt; T键 , T值&gt; 词典 );
public Dictionary ( System . Collections . Generic . IEnumerable &lt; System . Collections . Generic . KeyValuePair &lt; T键 , T值 &gt; &gt; 集合 );
public Dictionary ( System . Collections . Generic . IEqualityComparer &lt; T键 &gt;? 比较器 );
public Dictionary ( int 初始容量 );
public Dictionary ( System . Collections . Generic . IDictionary &lt; T键 , T值 &gt; 词典 ,  System . Collections . Generic . IEqualityComparer &lt; T键 &gt;? 比较器 );
public Dictionary ( System . Collections . Generic . IEnumerable &lt; System . Collections . Generic . KeyValuePair &lt; T键 , T值 &gt; &gt; 集合 , System . Collections . Generic . IEqualityComparer &lt; T键 &gt;? 比较器 );
public Dictionary ( int 初始容量 , System . Collections . Generic . IEqualityComparer &lt; T键 &gt;? 比较器 );</code></pre><h3>参数</h3><table><thead><tr><th>参数</th><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>T键<br/>T值</td><td>T</td><td>词典 键 和 值 的类型</td></tr><tr><td>词典</td><td>IDictionary &lt; T键 , T值 &gt;</td><td>欲复制到新词典中的词典</td></tr><tr><td>集合</td><td>IEnumerable &lt; KeyValuePair &lt; T键 , T值 &gt; &gt;</td><td>欲复制到新词典中的集合</td></tr><tr><td>比较器</td><td>IEqualityComparer &lt; T键 &gt;?</td><td>比较键时使用的 IEqualityComparer &lt; T &gt; 实现；或 null，使用键类型的默认 EqualityComparer &lt; T &gt;</td></tr><tr><td>初始容量</td><td>Int32</td><td>可包含的初始元素数量</td></tr></tbody></table><h3>异常</h3><table><thead><tr><th>异常</th><th>注解</th></tr></thead><tbody><tr><td>ArgumentException</td><td>词典 或 集合 中包含至少一个重复键</td></tr><tr><td>ArgumentNullException</td><td>词典 或 集合 是 null</td></tr><tr><td>ArgumentOutOfRangeException</td><td>初始容量 小于 0</td></tr></tbody></table><h3>示例</h3><p>下面的示例，使用了一个已被排序的 SortedDictionary 创建了一个 Dictionary，两者内容（包括顺序）相同。</p><pre><code class="C#">SortedDictionary &lt; string , string &gt; CD1 = [ ];
CD1 . Add ( "一" , "中文数字 1，表示某事物只有一个（件）" );
CD1 . Add ( "1" , "阿拉伯数字 1，表示某事物只有一个（件）" );
CD1 . Add ( "a" , "英文描述方式，表示某事物只有一个（件）" );
CD1 . Add ( "one" , "英文数字 1，表示某事物只有一个（件）" );

foreach ( KeyValuePair &lt; string , string &gt; jz in CD1 )
    Console . WriteLine ( jz );

Console.WriteLine ( );

Dictionary &lt; string , string &gt; CD一 = new ( CD1 );
foreach ( KeyValuePair &lt; string , string &gt; jz in CD一 )
    Console . WriteLine ( jz );</code></pre><p>下面的代码示例创建了一个 Dictionary &lt; T键 , T值 &gt;，并为当前区域性使用不区分大小写的相等比较器。该示例添加了四个元素，其中一些元素的键为小写，一些为大写。然后，该示例尝试添加一个键仅在大小写方面与现有键不同的元素，捕获由此产生的异常，并显示错误消息。最后，该示例显示字典中的元素。</p><pre><code class="C#">Dictionary &lt; string , string &gt; CD1 = new ( StringComparer . OrdinalIgnoreCase ) // 默认是 StringComparer . Ordinal
    {
        { "一" , "中文数字 1，表示某事物只有一个（件）" } ,
        { "1" , "阿拉伯数字 1，表示某事物只有一个（件）" } ,
        { "a" , "英文描述方式，表示某事物只有一个（件）" } ,
        { "one" , "英文数字 1，表示某事物只有一个（件）" }
    };

foreach ( KeyValuePair &lt; string , string &gt; jz in CD1 )
    Console . WriteLine ( jz );

Console.WriteLine ( );

try
    {
    CD1 . Add ( "One" , "英文数字 1，表示某事物只有一个（件）" );
    }
catch ( Exception yc ) { Console . WriteLine ( yc . Message ); }</code></pre><h3>备注</h3><p>根据默认的相等比较器，Dictionary &lt; T键 , T值 &gt; 中的每个键都必须是唯一的。</p><p>Dictionary &lt; T键 , T值 &gt; 需要一个相等性实现来确定键是否相等。此构造函数使用默认的泛型相等比较器 EqualityComparer &lt; T &gt; . Default。如果类型 T键 实现了 System . IEquatable &lt; T &gt; 泛型接口，则默认的相等比较器会使用该实现。或者，您可以通过使用接受 比较器 参数的构造函数来指定 IEqualityComparer &lt; T &gt; 泛型接口的实现。</p><p><strong>注意</strong>：如果您能够估计集合的大小，那么使用指定初始容量的构造函数可以避免在向 Dictionary &lt; T键 , T值 &gt; 中添加元素时执行多次大小调整操作。</p><p>此构造函数是一个 O（1）操作（创建空或指定元素数的词典）或 O（n）操作（创建 n 个元素的词典，n 为元素数量）。</p><h2>属性</h2><h3>Capacity</h3><p>获取内部数据结构在不调整大小的情况下可容纳的元素总数。<br/><code> public int Capacity { get; } </code></p><h4>属性值</h4><table><thead><tr><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>Int32</td><td>该结构的当前最大容量（并被元素数）</td></tr></tbody></table><h4>备注</h4><p>Capacity 属性表示当前 Dictionary 实例在不需要扩容的前提下，能够容纳的最大元素数；仅当当前 Dictionary 实例无法容纳全部新增元素时，Capacity 才会扩张。</p><p>若未指定初始容量，默认的初始容量为 0，添加一个元素后 Capacity 是 3。无论是否指定初始容量，Capacity 的返回值也均遵循下述规则计算。大于原 Capacity（0 除外）× 2 的下一个毕达哥拉斯质数（形如 4n + 1），或其 ± 2（必须也是质数，也必须大于原 Capacity × 2，且其二进制表示中 1 分布比较均匀），确保扩容后 Capacity 是原 Capacity 的大约 2.23 倍（取其 ± 2 仅限于适当均匀分布 Hash 列表，降低冲突率，例如选择 3 或者 7，而不是选择 5；若其二进制表示均为 1 的，取之，否则取二进制表示中 1 最平均分配位置的）；其值存于 HashHelpers 类中。即 Capacity 的返回值一定是个毕达哥拉斯质数或其 ± 2，且大于等于指定的初始容量。</p><h3>Compare</h3><p>获取用于确定字典键的相等性的 IEqualityComparer &lt; T &gt;。<br/><code> public System . Collections . Generic . IEqualityComparer &lt; T键 &gt; Comparer { get; } </code></p><h4>属性值</h4><table><thead><tr><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>IEqualityComparer &lt; T键 &gt;</td><td>用于确定当前 Dictionary &lt; T键 , T值 &gt; 的键是否相等并为键提供哈希值的 IEqualityComparer &lt; T &gt; 泛型接口实现</td></tr></tbody></table><h4>备注</h4><p>Dictionary &lt; T键 , T值 &gt; 需要一个相等性实现来确定键是否相等。您可以通过使用接受 比较器 参数的构造函数来指定 IEqualityComparer &lt; T &gt; 泛型接口的实现；如果不指定，则使用默认泛型相等比较器 EqualityComparer &lt; T &gt; . Default。</p><p>获取此属性的值是一个 O（1）操作。</p><h3>Count</h3><p>获取 Dictionary &lt; T键 , T值 &gt; 中包含的键/值对的数量。<br/><code> public int Count { get; } </code></p><h4>属性值</h4><table><thead><tr><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>int</td><td>词典 中的现有元素（键/值对）数</td></tr></tbody></table><h4>示例</h4><p>以下示例展示了 Capacity 属性和 Count 属性的区别：</p><pre><code class="C#">Dictionary &lt; string , string &gt; CD = new ( StringComparer . OrdinalIgnoreCase ); // 默认是 StringComparer . Ordinal
for ( int z = 1 ; z &lt;= 10 ; z++ )
    {
    CD . Add ( z . ToString ( ) , $"阿拉伯数字 {z}" ); 
    }

Console . WriteLine ( $"词典中的元素数：{CD . Count}，词典的容量：{CD . Capacity}" );</code></pre><h4>备注</h4><p>Capacity 属性是词典能够容纳的最大元素数，但可以被放大，以容纳更多的元素，详见 Capacity 属性。Count 是词典中实际存在的元素（键/值对）数，必然小于等于当前的 Capacity 属性。</p><p>由于词典被放大是一个耗时操作，创建一个新词典（同名）并容量扩大约 2.23 倍，复制原词典的元素，然后添加新元素，所以如果能够准确知道词典的大小（例如 32），应使用带有 初始容量 参数的构造函数创建词典。</p><p>获取此属性的值是一个 O（1）操作。</p><h3>Item [ T键 ]</h3><p>获取或设置与指定键关联的值。<br/><code> public TValue this [ T键 键 ] { get; set; } </code></p><h4>属性值</h4><p>与指定键相关联的值。如果未找到指定的键，get 操作会抛出 KeyNotFoundException，而 set 操作会创建一个具有指定键的新元素。</p><h4>实现</h4><p>Item [ T键 ]</p><h4>异常</h4><table><thead><tr><th>异常</th><th>注解</th></tr></thead><tbody><tr><td>ArgumentNullException</td><td>键 是 null</td></tr><tr><td>KeyNotFoundException</td><td>欲检索的 键 在词典中不存在（仅限于 get 操作）</td></tr></tbody></table><h4>示例</h4><p>以下代码示例使用 Item [ ] 属性（C# 中的索引器）来检索值，演示了当请求的键不存在时会抛出 KeyNotFoundException，并展示了与键关联的值可以被替换。</p><p>此示例还展示了如果程序经常需要尝试字典中不存在的键值，如何使用 TryGetValue 方法作为一种更高效的检索值的方式。</p><p>此代码示例是为 Dictionary &lt; T键 , T值 &gt; 类提供的一个更大示例的一部分。CD3 是本示例中使用的 Dictionary 的名称。</p><pre><code class="C#">// 创建一个包含英文和中文对于数字 3 和序数 3 的讲解的词典
Dictionary &lt; string , string &gt; CD3 = new ( StringComparer . OrdinalIgnoreCase ) // 默认是 StringComparer . Ordinal
    {
        { "3" , "阿拉伯数字 3，表示某事物有 3 个（件）" },
        { "Three" , "英文数字 3，表示某事物有 3 个（件）" },
        { "三" , "中文数字 3，表示某事物有 3 个（件）" },
        { "III" , "罗马数字 3，表示某事物有 3 个（件）" },
        { "Third" , "英文序数 3，表示某事物的第 3 个（件）" },
        { "3rd" , "英文序数 3 的简写形式，表示某事物的第 3 个（件）" },
    };

// 尝试添加一个仅大小写不同的序数 3 简写形式，但已存在（因为该词典不区分大小写）
try
    {
    CD3 . Add ( "3RD" , "英文序数 3 的简写形式，表示某事物的第 3 个（件）" );
    }
catch ( Exception yc ) { Console . WriteLine ( yc . Message ); }

// 使用 Item 的形式读取词典的内容
Console . WriteLine ( $"键 = \"3rd\"，值 = {CD3 [ "3rd" ]}。" );

// 使用 Item 的形式向词典添加德语 3
CD3 [ "drei" ] = "德文数字 3，表示某事物有 3 个（件）";
Console . WriteLine ( $"键 = \"drei\"，值 = {CD3 [ "drei" ]}。" );

// 使用 Item 的形式修改词典中的德语 3 条目
CD3 [ "drei" ] = "德文（德语）数字 3，表示某事物有 3 个（件）";
Console . WriteLine ( $"键 = \"drei\"，值 = {CD3 [ "drei" ]}。" );

// 尝试使用 Item 的形式检索词典中不存在的法语 3
try
    {
    Console . WriteLine ( $"键 = \"trois\"，值 = {CD3 [ "trois" ]}。" );

    }
catch ( Exception yc ) { Console . WriteLine ( yc . Message ); }

// 尝试使用 TryGetValue 读取词典中可能不存在的法语 3（没有异常）
if ( CD3 . TryGetValue ( "trois" , out string? zfcF3 ) )
    {
    Console . WriteLine ( $"键 = \"trois\"，值 = {zfcF3}。" );
    }
else
    {
    Console . WriteLine ( $"键 = \"trois\"，值 = 不存在。" );
    }</code></pre><h4>备注</h4><p>此属性提供了通过以下 C# 语法访问集合中特定元素的能力：myCollection [ 键 ]（在 Visual Basic 中为 myCollection ( 键 )）。</p><p>您也可以使用 Item [ ] 属性，通过设置 Dictionary &lt; T键 , T值 &gt; 中不存在的键的值来添加新元素。设置属性值时，如果该键存在于 Dictionary &lt; T键 , T值 &gt; 中，则与该键关联的值会被所分配的值替换。如果该键不存在于 Dictionary &lt; T键 , T值 &gt; 中，则会将该键和值添加到字典中。相比之下，Add 方法不会修改现有元素。</p><p>键不能为 null，但如果值类型 T值 是引用类型，则值可以为 null。</p><p>C# 语言使用 this 关键字来定义索引器，而不是实现 Item [ ] 属性。Visual Basic 将 Item [ ] 实现为默认属性，该属性提供相同的索引功能。</p><p>获取或设置此属性的值的操作时间复杂度接近 O（1）。</p><h3>Key（键）和 Value（值）</h3><p>Keys 获取包含 Dictionary &lt; T键 , T值 &gt; 中的键的集合。Values 获取包含 Dictionary &lt; T键 , T值 &gt; 中的值的集合。<br/>` public System . Collections . Generic . Dictionary &lt; T键 , T值 &gt; . KeyCollection Keys { get; }<br/>public System . Collections . Generic . Dictionary &lt; T键 , T值 &gt; . ValueCollection Values { get; } `</p><h4>属性值</h4><table><thead><tr><th>方法</th><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>Keys</td><td>Dictionary &lt; T键 , T值 &gt; . KeyCollection</td><td>一个包含 Dictionary &lt; T键 , T值 &gt; 中键的 Dictionary &lt; T键 , T值 &gt; . KeyCollection</td></tr><tr><td>Values</td><td>Dictionary &lt; T键 , T值 &gt; . ValueCollection</td><td>一个包含 Dictionary &lt; T键 , T值 &gt; 中值的 Dictionary &lt; T键 , T值 &gt; . ValueCollection</td></tr></tbody></table><h4>示例</h4><pre><code class="C#">Dictionary &lt; int , string &gt; CD2m = [ ];
CD2m . Add ( 0 , "未知" );
CD2m . Add ( 1 , "2 的 0 次幂，既不是质数也不是合数" );
CD2m . Add ( 2 , "2 的 1 次幂，最小的质数；唯一的偶质数" );
CD2m . Add ( 3 , "1 OR 2 的值，最小的奇质数" );
CD2m . Add ( 4 , "2 的 2 次幂，最小的合数" );
CD2m . Add ( 5 , "1 OR 4 的值" );
CD2m . Add ( 6 , "2 OR 4 的值" );
CD2m . Add ( 7 , "2 OR 5 的值" );
CD2m . Add ( 8 , "2 的 3 次幂" );


Dictionary &lt; int , string &gt; . KeyCollection JH键 = CD2m . Keys;
Dictionary &lt; int , string &gt; . ValueCollection JH值 = CD2m . Values;
int [ ] S键 = [ .. JH键 ];
string [ ] S值 = [ .. JH值 ];

for ( int z = 0 ; z &lt; 9 ; z++ )
    {
    Console . WriteLine ( $"{S键 [ z ]}\t{S值 [ z ]}" );
    }</code></pre><h4>备注</h4><p>Dictionary &lt; T键 , T值 &gt; . KeyCollection 中键的顺序未指定，但与 Values 属性返回的 Dictionary &lt; T键 , T值 &gt; . ValueCollection 中关联值的顺序相同。反之亦然。</p><p>返回的 Dictionary &lt; T键 , T值 &gt; . KeyCollection 和 Dictionary &lt; T键 , T值 &gt; . ValueCollection 不是静态副本；它们会引用回原始 Dictionary &lt; T键 , T值 &gt; 中的键和值。因此，对 Dictionary &lt; T键 , T值 &gt; 所做的更改会继续反映在 Dictionary &lt; T键 , T值 &gt; . KeyCollection 和 Dictionary &lt; T键 , T值 &gt; . ValueCollection 中。</p><p>获取此属性的值是一个 O（1）操作。</p><h2>方法</h2><h3>Add 和 Remove</h3><p>Add 添加指定的键和值到词典中；Remove 将词典中具有指定键的值。</p><pre><code class="C#">public void Add ( T键 键 , T值 值 );
public bool Remove ( T键 键 );
public bool Remove ( T键 键 , out T值 值 );</code></pre><h4>参数</h4><table><thead><tr><th>参数</th><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>键</td><td>T键</td><td>欲添加或移除的元素（键/值对）的键</td></tr><tr><td>值</td><td>T值</td><td>Add 方法添加的元素（键/值对）的值；或 Remove 方法移除的元素（键/值对）的值</td></tr></tbody></table><h4>返回值</h4><table><thead><tr><th>方法</th><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>Remove</td><td>bool</td><td>如果找到具备指定键值的元素，并成功移除，返回 true；如果移除不成功，或没有找到具备指定键值的元素，返回 false</td></tr></tbody></table><h4>实现</h4><p>Add ( TKey , TValue )<br/>Remove ( TKey )</p><h4>异常</h4><table><thead><tr><th>异常</th><th>方法</th><th>注解</th></tr></thead><tbody><tr><td>ArgumentException</td><td>Add</td><td>词典中已经存在指定键值</td></tr><tr><td>ArgumentNullException</td><td>Add<br/>Remove</td><td>键 为 null</td></tr></tbody></table><h4>示例</h4><p>以下例程通过 Add 和 Remove 创建并过滤了词典中的某些元素：</p><pre><code class="C#">Dictionary &lt; int , string &gt; CD2m = [ ];
CD2m . Add ( 0 , "未知" );
CD2m . Add ( 1 , "2 的 0 次幂，既不是质数也不是合数" );
CD2m . Add ( 2 , "2 的 1 次幂，最小的质数；唯一的偶质数" );
CD2m . Add ( 3 , "1 OR 2 的值，最小的奇质数" );
CD2m . Add ( 4 , "2 的 2 次幂，最小的合数" );
CD2m . Add ( 5 , "1 OR 4 的值" );
CD2m . Add ( 6 , "2 OR 4 的值" );
CD2m . Add ( 7 , "2 OR 5 的值" );
CD2m . Add ( 8 , "2 的 3 次幂" );

foreach ( var JZ in CD2m )
    {
    int z键 = JZ . Key;
    if ( z键 % 2 == 0 )
        {
        CD2m . Remove ( z键 , out string? z值 );
        Console . WriteLine ( $"移除 {z键} 项，其值为 {z值}" );
        }
    }</code></pre><h4>备注</h4><p>您也可以使用 Item [ ] 属性，通过设置 Dictionary &lt; T键 , T值 &gt; 中不存在的键的值来添加新元素；例如，CD [ 键 ] = 值（在 Visual Basic 中为 CD ( 键 ) = 值）。但是，如果指定的键已存在于 Dictionary &lt; T键 , T值 &gt; 中，设置 Item [ ] 属性会覆盖旧值。相比之下，如果已存在具有指定键的值，Add 方法会引发异常。</p><p>如果 Count 属性值已等于 Capacity，添加元素会通过自动重新分配内部数组来增加 Dictionary &lt; T键 , T值 &gt; 的容量，并且在添加新元素之前，会将现有元素复制到新数组中。</p><p>键不能为 null，但如果 T值 是引用类型，则值可以为 null。</p><p>如果 Count 小于容量，Add 方法接近 O（1）操作。如果必须增加容量以容纳新元素，Add 方法将变为 O（n）操作，其中 n 为 Count。Remove 方法接近 O（1）操作。</p><p>仅 .NET Core 3.0+ 支持：可以安全地调用 Remove 可变方法，而不会使 Dictionary &lt; T键 , T值 &gt; 实例上的活动枚举数失效。这并不意味着线程安全。</p><h3>Clear</h3><p>从 Dictionary &lt; T键 , T值 &gt; 中移除所有键和值。<br/><code> public void Clear(); </code></p><h4>实现</h4><p>Clear ( )</p><h4>备注</h4><p>该操作会释放集合元素对其他对象的引用。</p><p>词典的 Count 会置为零，但 Capacity 属性不变。</p><p>当词典需要重置且容量需要变小（节省内存）时或变大（符合 Capacity 增长规则）时，应使用 New 并指定一个更合适的初始容量；否则使用 Clear 重置性能更好。</p><p>此方法是一个 O（n）操作，其中 n 是字典的 Capacity。</p><p>仅适用于 .NET Core 3.0 及以上版本：可以安全地调用此可变方法，而不会使 Dictionary &lt; T键 , T值 &gt; 实例上的活动枚举数失效。这并不意味着线程安全。</p><h3>ContainsKey 和 ContainsValue</h3><p>确定 Dictionary &lt; T键 , T值 &gt; 是否包含指定的键或者值。</p><pre><code class="C#">public bool ContainsKey ( T键 键 );
public bool ContainsValue ( T值 值 );</code></pre><h4>参数</h4><table><thead><tr><th>参数</th><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>键</td><td>T键</td><td>欲在词典中搜索的键值</td></tr><tr><td>值</td><td>T值</td><td>欲在词典中搜索的值</td></tr></tbody></table><h4>返回值</h4><table><thead><tr><th>方法</th><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>ContainsKey</td><td>bool</td><td>如果 词典 中包含具有指定键的元素，则为 true；否则为 false</td></tr><tr><td>ContainsValue</td><td>bool</td><td>如果 词典 中包含具有指定值的元素，则为 true；否则为 false</td></tr></tbody></table><h4>实现</h4><p>ContainsKey ( )</p><h4>异常</h4><table><thead><tr><th>异常</th><th>注解</th></tr></thead><tbody><tr><td>ArgumentNullException</td><td>键（ContainsKey）为 null</td></tr></tbody></table><h4>示例</h4><p>以下示例创建了一个 键 和 值 都是整数的 1 ～ 100 的词典，分别确认是否包含 键 和 值 为 105 和 15：</p><pre><code class="C#">Dictionary &lt; int , int &gt; CD = [ ];
for ( int z = 1 ; z &lt;= 100 ; z++ )
    {
    CD . Add ( z , z ); // 键和值都是 1、2、3……100
    }
Console . WriteLine ( $"初始词典元素数：{CD . Count}" ); // 输出：100

Console . WriteLine ( $"词典中存在键 105 吗？{(CD . ContainsKey ( 105 ) ? "存在" : "不存在")}" );
Console . WriteLine ( $"词典中存在键 15 吗？{( CD . ContainsKey ( 15 ) ? "存在" : "不存在" )}" );
Console . WriteLine ( $"词典中存在值 105 吗？{( CD . ContainsValue ( 105 ) ? "存在" : "不存在" )}" );
Console . WriteLine ( $"词典中存在值 15 吗？{( CD . ContainsValue ( 15 ) ? "存在" : "不存在" )}" );</code></pre><h4>备注</h4><p>ContainsValue 方法使用字典中值的类型 T值 的默认相等比较器 EqualityComparer &lt; T &gt; . Default 来确定相等性（例如对于 String，一定是区分大小写的）。如果要模糊搜索，需要自定义的比较逻辑。</p><p>ContainsValue 方法执行线性搜索（可能遍历词典所有元素），因此平均执行时间与 Count 成正比。也就是说，此方法是一个 O（n）操作，其中 n 为 Count。尽量不使用 ContainsValue 搜索大数据词典；但 ContainsKey 由于其值为哈希类型（无重复、内存中建立），搜索要快得多。</p><p>ContainsKey 方法接近 O（1）操作。</p><h3>EnsureCapacity</h3><p>确保字典能够容纳多达指定数量的条目，而无需进一步扩展其后备存储。<br/><code> public int EnsureCapacity ( int 初始容量 ); </code></p><h4>参数</h4><table><thead><tr><th>参数</th><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>初始容量</td><td>int</td><td>指定的词典容量</td></tr></tbody></table><h4>返回值</h4><table><thead><tr><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>int</td><td>词典 的实际容量（等于其 Capacity 属性）</td></tr></tbody></table><h4>异常</h4><table><thead><tr><th>异常</th><th>注解</th></tr></thead><tbody><tr><td>ArgumentOutOfRangeException</td><td>初始容量 小于 0</td></tr></tbody></table><h4>示例</h4><p>以下示例展示了 EnsureCapacity 和 Capacity 的关系：</p><pre><code class="C#">Dictionary &lt; int , int &gt; CD = [ ];

for ( int i = 0 ; i &lt;= 100 ; i++ )
    {
    Console . WriteLine ( $"初始词典元素数：{CD . EnsureCapacity ( i )}，{CD . Capacity}" );
    }</code></pre><h4>备注</h4><p>与默认的 Dictionary 扩容不同。当指定 EnsureCapacity 的参数时，词典的 Capacity 属性（占用内存）并不是其参数值，而是大于等于其参数的第一个符合 4n ± 1 形式的质数（需考虑其二进制形式中 1 的分布是否均匀），而且通常是 4n - 1，越小越好，除非不是质数或其二进制形式中 1 的分布不如 4n + 1 形式均匀。而默认的 Dictionary 扩容是首先将 Capacity 加倍后的符合 4n + 1 形式的质数（或其 ± 2）。</p><p>该方法不会删除词典中的元素，若指定 初始容量 参数小于该词典的 Capacity，方法无效。</p><pre><code class="C#">Dictionary &lt; int , int &gt; CD = [ ];

for ( int i = 0 ; i &lt;= 7 ; i++ )
    {
    CD . Add ( i , i * 4 );
    }

CD . EnsureCapacity ( 4 );
foreach ( var jz in CD )
    {
    Console . WriteLine ( jz );
    }</code></pre><p>其返回值一定和 Capacity 属性相等。</p><h3>TrimExcess</h3><h4>重载</h4><table><thead><tr><th>重载</th><th>注解</th></tr></thead><tbody><tr><td>TrimExcess ( )</td><td>将此字典的容量设置为其最初包含所有条目进行初始化时应有的容量</td></tr><tr><td>TrimExcess ( int )</td><td>将此字典的容量设置为可容纳指定数量的条目</td></tr></tbody></table><pre><code class="C#">public void TrimExcess ( );
public void TrimExcess ( int 容量 );</code></pre><h4>参数</h4><table><thead><tr><th>参数</th><th>类型</th><th>注解</th></tr></thead><tbody><tr><td>容量</td><td>Int32</td><td>新容量（需大于等于当前实例的 Count）</td></tr></tbody></table><h4>异常</h4><table><thead><tr><th>异常</th><th>注解</th></tr></thead><tbody><tr><td>ArgumentOutOfRangeException</td><td>容量 小于当前实例的 Count</td></tr></tbody></table><h4>示例</h4><pre><code class="C#">Dictionary &lt; int , int &gt; CD = [ ];
for ( int i = 0 ; i &lt;= 10 ; i++ ) CD . Add ( i , i * 4 );

CD . TrimExcess ( ); // 最小的 4n ± 1 的质数的 Capacity

Console . WriteLine ( $"{CD . Count}，{CD . Capacity}" ); // 如果没有 TrimExcess，Capacity 会是 17</code></pre><h4>备注</h4><p>TrimExcess 会将 Capacity 属性设置为大于等于当前词典实例的 Count 或 容量 指定的数值的二进制形式中 1 的分布最均匀，且又符合 4n ± 1 的质数，例如当前词典实例的 Count 为 5，则设置 Capacity 为 7。</p><p>一旦词典条目增加，Capacity 会自动调整为能容纳当前 Count 的最小毕达哥拉斯质数（二进制形式中 1 的分布最均匀）。例如，当有 15 个条目的词典，其 Capacity 至少为 17（除非创建词典时指定更大的初始容量）。即使 Remove、Clear 等方法也不会减少 Capacity，词典始终占据能容纳 Capacity 个条目的内存空间。使用 TrimExcess 可以降低 Capacity，以将内存占用降低至最小。</p><p>即使被 Clear 的原有条目的词典，无参数的 TrimExcess 也只能把 Capacity 降低为 3，不会为零，除非使用没有指定初始容量参数的构造函数新建该词典（ReNew）。</p><pre><code class="C#">CD . Clear ( );
CD . TrimExcess ( );</code></pre><h3>TryAdd 和 TryGetValue</h3><p>TryAdd 尝试添加条目；TryGetValue 尝试读取指定键值的条目。</p><pre><code class="C#">public bool TryAdd ( T键 键 , T值 值 );
public bool TryGetValue ( T键 键 , out T值 值 );</code></pre><h4>参数</h4><table><thead><tr><th>参数</th><th>类型</th><th>方法</th><th>注解</th></tr></thead><tbody><tr><td>键</td><td>T键</td><td> </td><td>欲添加或获取的条目的键值</td></tr><tr><td>值</td><td>T值</td><td>TryAdd</td><td>欲添加的条目的值</td></tr><tr><td>值</td><td>T值</td><td>TryGetValue</td><td>若键值存在，返回其值（可能为 null）<br/>若键值不存在，返回 T值 类型的默认值</td></tr></tbody></table><h4>返回值</h4><table><thead><tr><th>类型</th><th>方法</th><th>注解</th></tr></thead><tbody><tr><td>bool</td><td>TryAdd</td><td>仅在添加成功时，返回 true；否则 false</td></tr><tr><td>bool</td><td>TryGetValue</td><td>仅在获取成功时，返回 true；否则 false</td></tr></tbody></table><h4>异常</h4><table><thead><tr><th>异常</th><th>注解</th></tr></thead><tbody><tr><td>ArgumentNullException</td><td>键 为 null</td></tr></tbody></table><h4>示例</h4><pre><code class="C#">Dictionary&lt;int, int&gt; CD = [ ];
for ( int i = 0 ; i &lt;= 11 ; i++ ) CD . Add ( i , i * 4 );

if ( !CD . TryAdd ( 0 , 0 ) )
    Console . WriteLine ( $"CD . TryAdd ( 0 , 0 ) 不成功，已经存在了？" );
else
    {
    Console . WriteLine ( $"CD . TryAdd ( 0 , 0 ) 成功！" );
    foreach ( var jz in CD )
        {
        Console . WriteLine ( jz );
        }
    }

if ( !CD . TryAdd ( 12 , 48 ) )
    Console . WriteLine ( $"CD . TryAdd ( 12 , 48 ) 不成功，已经存在了？" );
else
    {
    Console . WriteLine ( $"CD . TryAdd ( 12 , 48 ) 成功！" );
    foreach ( var jz in CD )
        {
        Console . WriteLine ( jz );
        }
    }

Console . Write ( CD . TryGetValue ( 10 , out int z ) );
Console . WriteLine ( $"\t{z}" );

Console . Write ( CD . TryGetValue ( 15 , out int z1 ) );
Console . WriteLine ( $"\t{z1}" );</code></pre><h4>备注</h4><p>与 Add 方法不同，如果字典中已存在具有给定键的元素，TryAdd 方法不会抛出异常。与 Dictionary 索引器不同，如果字典中已存在具有给定键的元素，TryAdd 不会覆盖该元素。如果键已存在，TryAdd 不执行任何操作并返回 false。</p><p>TryGetValue 此方法结合了 ContainsKey 方法和 Item [ ] 属性的功能。</p><p>如果未找到该键，则 值 参数会获得类型 T值 的相应默认值；例如，整数类型的默认值为 0（零），布尔类型的默认值为 false，引用类型的默认值为 null。</p><p>如果你的代码经常尝试访问字典中不存在的键，请使用 TryGetValue 方法。使用此方法比捕获 Item [ ] 属性抛出的 KeyNotFoundException 更高效。</p><p>此方法的操作复杂度接近 O（1）。</p>]]></description></item><item>    <title><![CDATA[如何在Bash中捕获标准错误到一个变量 ? 本文系转载，阅读原文
https://www.koogu]]></title>    <link>https://segmentfault.com/a/1190000047600744</link>    <guid>https://segmentfault.com/a/1190000047600744</guid>    <pubDate>2026-02-09 09:02:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000045412131" alt="Store Standard Error to a Variable in Bash" title="Store Standard Error to a Variable in Bash"/></p><p>在 Bash 中，您可以使用 <code>2&gt;&amp;1</code> 操作符和 <code>$()</code> 命令替换语法将命令的标准错误输出存储到一个变量中。这里 <code>2&gt;&amp;1</code> 将错误消息重定向到 <code>&amp;1</code> (标准输出)。默认情况下，shell 作为标准输出设备。</p><p>例如，要将 <code>ls</code> 命令的标准错误输出存储到名为 errors 的变量中，可以使用以下命令：</p><pre><code>errors=$(ls non-existent-file 2&gt;&amp;1)</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600746" alt="Store Standard Error in a Bash Variable" title="Store Standard Error in a Bash Variable" loading="lazy"/></p><p>或者，您可以使用 <code>$?</code> 特殊参数，将命令的退出状态存储到一个变量中。退出状态是一个数字值，指示命令是否成功。值“0”表示成功，而非“0”表示错误。</p><p>例如，要将 <code>ls</code> 命令的退出状态存储到一个名为 status 的变量中，可以使用以下命令：</p><pre><code>ls non-existent-file 
status=$?</code></pre><p>然后可以使用 <code>$status</code> 变量检查 <code>ls</code> 命令的退出状态，并根据结果采取适当的操作。例如：</p><pre><code>ls non-existent-file
status=$?

if [ $status -ne 0 ]; then
echo "Last command failed with an error."
fi</code></pre><p>请记住，<code>$()</code> 命令替换语法允许您执行命令并替换其输出。 <code>2&gt;</code> 操作符将命令的标准错误输出重定向到 <code>&amp;1</code> 标准输出流，这允许您捕获命令的标准输出和标准错误输出到变量中。</p><h3>我的开源项目</h3><p><a href="https://link.segmentfault.com/?enc=6zv9O%2BSkp%2FA3ri6EBlyqLQ%3D%3D.SSJLegaG%2FW2BY%2BjonUGokMtEE1zp4Oc5j8LVmgG7GMU%3D" rel="nofollow" target="_blank"><img referrerpolicy="no-referrer" src="/img/remote/1460000043426502" alt="酷瓜云课堂-开源知识付费解决方案" title="酷瓜云课堂-开源知识付费解决方案" loading="lazy"/></a></p><ul><li><a href="https://link.segmentfault.com/?enc=kaeXyOYvNFEshkDNWg4VRQ%3D%3D.6AKj5tkEbIo4saZHQF2hOR3rxok6%2BATl647x82VT%2Bg0iuM3GkcNxz11r%2Bh6vBVff" rel="nofollow" target="_blank">course-tencent-cloud（酷瓜云课堂 - gitee仓库）</a></li><li><a href="https://link.segmentfault.com/?enc=HR%2ByXX7r%2F9chtHa%2FZvidIg%3D%3D.B6SoBZ3Akkpyeevk8AyaIQi%2FX9JBtECheLflJK5Q2zI47mDtP4JAG9exWXPam6%2BxNoNAzzcUuHHaMVJ%2FelVp0Q%3D%3D" rel="nofollow" target="_blank">course-tencent-cloud（酷瓜云课堂 - github仓库）</a></li></ul>]]></description></item><item>    <title><![CDATA[AQS深度探索：以ReentrantLock看Java并发编程的高效实现 SevenCoding ]]></title>    <link>https://segmentfault.com/a/1190000047598423</link>    <guid>https://segmentfault.com/a/1190000047598423</guid>    <pubDate>2026-02-09 09:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>概述</h2><p>AQS ( Abstract Queued Synchronizer ）是一个抽象的队列同步器，通过维护一个共享资源状态（ Volatile Int State ）来表示同步状态 和一个先进先出（ FIFO ）的线程<strong>等待队列</strong>来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><p>AQS整体框架如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598425" alt="" title=""/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598426" alt="" title="" loading="lazy"/></p><p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层</p><h2>原理</h2><p>AQS 为每个共享资源都设置一个共享资源锁，线程在需要访问共享资源时首先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使用该共享资源，如果获取不到，则将该线程放入线程等待队列，等待下一次资源调度，流程图如下所示：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598427" alt="" title="" loading="lazy"/></p><p>Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。</p><h2>底层结构</h2><h3>state：状态</h3><p>Abstract Queued Synchronizer 维护了 volatile int 类型的变量，用于表示当前的同步状态。volatile虽然不能保证操作的原子性，但是能保证当前变量state的可见性。</p><p>state的访问方式有三种： getState()、setState()和 compareAndSetState()，均是原子操作，其中，compareAndSetState的实现依赖于 Unsafe的compareAndSwaplnt()</p><pre><code class="java">// java.util.concurrent.locks.AbstractQueuedSynchronizer
private volatile int state;

protected final int getState() {
    return state;
}

protected final void setState(int newState) {
    state = newState;
}

protected final boolean compareAndSetState(int expect, int update) {
    // See below for intrinsics setup to support this
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598428" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598429" alt="" title="" loading="lazy"/></p><h3>CLH队列</h3><p>Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598430" alt="" title="" loading="lazy"/></p><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><h3>AQS的独占式和共享式</h3><ul><li>独占式:只有一个线程能执行，具体的 Java 实现有 ReentrantLock。</li><li>共享式：多个线程可同时执行，具体的 Java 实现有 Semaphore和CountDownLatch。</li></ul><p>AQS只是一个框架 ，只定义了一个接口，具体资源的获取、释放都由自定义同步器去实现。不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护，如获取资源失败入队、唤醒出队等， AQS 已经在顶层实现好（就是模板方法模式），不需要具体的同步器再做处理。自定义同步器实现时主要实现以下几种方法：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598431" alt="" title="" loading="lazy"/></p><ul><li>以ReentrantLock为例，ReentrantLock中的state初始值为0表示无锁状态。在线程执行 tryAcquire()获取该锁后ReentrantLock中的state+1，这时该线程独占ReentrantLock锁，其他线程在通过tryAcquire() 获取锁时均会失败，直到该线程释放锁后state再次为0，其他线程才有机会获取该锁。该线程在释放锁之前可以重复获取此锁，每获取一次便会执行一次state+1, 因此ReentrantLock也属于可重入锁。 但获取多少次锁就要释放多少次锁，这样才能保证state最终为0。如果获取锁的次数多于释放锁的次数，则会出现该线程一直持有该锁的情况；如果获取锁的次数少于释放锁的次数，则运行中的程序会报锁异常。</li><li>以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后面的动作。</li><li>以Semaphore为例，state则代表可以同时访问的线程数量，也可能理解为访问的许可证（permit）数量。每个线程访问(acquire)时需要拿到对应的许可证，否则进行阻塞，访问结束则返还（release）许可证。state只能在Semaphore的构造方法中进行初始化，后续不能进行修改。</li></ul><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><h3>Node节点</h3><p>Node即为上面CLH变体队列中的节点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598432" alt="" title="" loading="lazy"/></p><p>Node结点是每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态waitStatus</p><p>Node中几个方法和属性值的含义：</p><ul><li>waitStatus：当前节点在队列中的状态</li><li>thread：表示处于该节点的线程</li><li>prev：前驱指针</li><li>predecessor：返回前驱节点，没有的话抛出npe</li><li>nextWaiter：指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）</li><li>next：后继指针</li></ul><h3>等待状态waitStatus</h3><p>waitStatus有下面几个枚举值：如是否被阻塞、是否等待唤醒、是否已经被取消等。共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p><ul><li>CANCELLED(1)：表示当前结点已取消调度，不再想去获取资源了。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li><li>SIGNAL(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li><li>CONDITION(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li>PROPAGATE(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li>0：新结点入队时的默认状态。</li></ul><p>注意，负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常。</p><h2>源码</h2><p>以ReentrantLock的非公平锁为例，将加锁和解锁的交互流程单独拎出来强调一下</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598433" alt="" title="" loading="lazy"/></p><p>加锁：</p><ol><li>通过ReentrantLock的加锁方法Lock进行加锁操作。</li><li>会调用到内部类 Sync的Lock方法，由于Sync#lock是抽象方法，根据 ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的 Acquire 方法。</li><li>AQS的 Acquire 方法会执行 tryAcquire 方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。</li><li>tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</li></ol><p>解锁：</p><ol><li>通过ReentrantLock的解锁方法Unlock进行解锁。</li><li>Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</li><li>Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</li><li>释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</li></ol><h3>acquire(int)</h3><p>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。</p><pre><code class="java">public final void acquire(int arg) {
     if (!tryAcquire(arg) &amp;&amp;
         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
         selfInterrupt();
}</code></pre><p>函数流程如下：</p><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598434" alt="" title="" loading="lazy"/></p><p>关于整个函数流程详解，可以往下看</p><h4>tryAcquire(int)</h4><p>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，当然不仅仅只限于tryLock()。</p><pre><code class="java">protected boolean tryAcquire(int arg) {
     throw new UnsupportedOperationException();
}</code></pre><p>这里是AQS的方法，所以直接throw异常，而没有具体的实现。原因就在于AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现。</p><p>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p><p><strong>ReentrantLock实现公平锁非公平锁则主要体现在tryAcquire的实现上：</strong></p><p>公平锁中实现的tryAcquire：</p><pre><code class="java">protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
           if (!hasQueuedPredecessors() &amp;&amp;  //公平锁加锁时判断等待队列中是否存在有效节点的方法
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
           }
     }
     else if (current == getExclusiveOwnerThread()) {
           int nextc = c + acquires;
           if (nextc &lt; 0)
                throw new Error("Maximum lock count exceeded");
           setState(nextc);
           return true;
     }
     return false;
}</code></pre><p>非公平锁中实现的tryAcquire：</p><pre><code class="java">protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}

final boolean nonfairTryAcquire(int acquires) {
     final Thread current = Thread.currentThread();
     int c = getState();
     if (c == 0) {
           if (compareAndSetState(0, acquires)) {
               setExclusiveOwnerThread(current);
               return true;
           }
      }
      else if (current == getExclusiveOwnerThread()) {
           int nextc = c + acquires;
           if (nextc &lt; 0) // overflow
                throw new Error("Maximum lock count exceeded");
           setState(nextc);
           return true;
      }
      return false;
}</code></pre><ul><li>公平锁中多了一层 !hasQueuedPredecessors() 的判断，这是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以获取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。</li><li>而在非公平锁中，没有这个判断，直接尝试获取锁，能获取到锁则不用加入等待队列。</li></ul><pre><code class="java">public final boolean hasQueuedPredecessors() {
        // The correctness of this depends on head being initialized
        // before tail and on head.next being accurate if the current
        // thread is first in queue.
        Node t = tail; // Read fields in reverse initialization order
        Node h = head;
        Node s;
        return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());
}</code></pre><p>这里的判断 h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</p><p>双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h != t时： 如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True。 如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。</p><h4>addWaiter(Node)</h4><p>此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。</p><pre><code class="java">private Node addWaiter(Node mode) {
    //以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）
    Node node = new Node(Thread.currentThread(), mode);

    //尝试快速方式直接放到队尾。
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }

    //上一步失败则通过enq入队。
    enq(node);
    return node;
}</code></pre><p>主要的流程如下：</p><ol><li>通过当前的线程和锁模式新建一个节点。</li><li>Pred指针指向尾节点Tail。</li><li>将New中Node的Prev指针指向Pred。</li><li>通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。</li></ol><pre><code class="java">// java.util.concurrent.locks.AbstractQueuedSynchronizer

static {
    try {
        stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("state"));
        headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("head"));
        tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField("tail"));
        waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField("waitStatus"));
        nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField("next"));
    } catch (Exception ex) { 
    throw new Error(ex); 
  }
}</code></pre><p>从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。</p><p>如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改）,就需要enq入队</p><pre><code class="java">private Node enq(final Node node) {
    //CAS"自旋"，直到成功加入队尾
    for (;;) {
        Node t = tail;
        if (t == null) { // 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {//正常流程，放入队尾
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}</code></pre><p>如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598435" alt="" title="" loading="lazy"/></p><h4>acquireQueued(Node, int)</h4><p>通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。addWaiter()返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。那么下一步就是：如果获取不到锁，那么就进入阻塞状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。</p><p>acquireQueued：在等待队列中排队拿号（中间没其它事干可以阻塞休息），直到拿到号后再返回。</p><pre><code class="java">final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;//标记是否成功拿到资源
    try {
        boolean interrupted = false;//标记等待过程中是否被中断过

        //CAS“自旋”！
        for (;;) {
            final Node p = node.predecessor();//拿到前驱
            //如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源，也就是当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）。
            if (p == head &amp;&amp; tryAcquire(arg)) {
                setHead(node);// 获取锁成功，头指针移动到当前node
                p.next = null; // setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！
                failed = false; // 成功获取资源
                return interrupted;//返回等待过程中是否被中断过
            }

            // 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者 是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true
        }
    } finally {
        if (failed) //说明发生了意料之外的异常，将节点移除，避免影响到其他节点
            cancelAcquire(node);
    }
}</code></pre><p>setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。</p><pre><code class="java">// java.util.concurrent.locks.AbstractQueuedSynchronizer

private void setHead(Node node) {
    head = node;
    node.thread = null;
    node.prev = null;
}</code></pre><p>acquireQueued函数的具体流程：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598436" alt="" title="" loading="lazy"/></p><p>从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，shouldParkAfterFailedAcquire代码：</p><pre><code class="java">// java.util.concurrent.locks.AbstractQueuedSynchronizer

// 靠前驱节点判断当前线程是否应该被阻塞
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        // 获取头结点的节点状态
        int ws = pred.waitStatus;
        // 说明头结点处于唤醒状态
        if (ws == Node.SIGNAL)
            return true; 
        // 通过枚举值我们知道waitStatus&gt;0是取消状态
        if (ws &gt; 0) {
            do {
                // 循环向前查找取消节点，把取消节点从队列中剔除
                node.prev = pred = pred.prev;
            } while (pred.waitStatus &gt; 0);
            pred.next = node;
        } else {
            // 设置前任节点等待状态为SIGNAL
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
}</code></pre><p>parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。</p><pre><code class="java">// java.util.concurrent.locks.AbstractQueuedSynchronizer

private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);//调用park()使线程进入waiting状态
    return Thread.interrupted();//如果被唤醒，查看自己是不是被中断的。
}</code></pre><p>具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598437" alt="" title="" loading="lazy"/></p><p>整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><p>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：1）被unpark()；2）被interrupt()。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。</p><p>那么shouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？</p><p>是在什么时间释放节点通知到被挂起的线程呢？</p><h4>CANCELLED状态节点生成</h4><p>回看acquireQueued方法中的Finally代码：</p><pre><code class="java">// java.util.concurrent.locks.AbstractQueuedSynchronizer

final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
        ...
            for (;;) {
                final Node p = node.predecessor();
                if (p == head &amp;&amp; tryAcquire(arg)) {
                    ...
                    failed = false;
                    ...
                }
                ...
        } finally {
            if (failed)
                cancelAcquire(node);
            }
}</code></pre><p>显然，当failed为true时才会执行方法cancelAcquire，那什么情况下failed为true呢？try代码段执行过程中出现异常。</p><blockquote>这里不知道哪里会出现异常？假设tryAcquire出现的异常，那么acquire方法就已经不会往后执行，也就不会执行到acquireQueued</blockquote><p>通过cancelAcquire方法，将Node的状态标记为CANCELLED。</p><pre><code class="java">// java.util.concurrent.locks.AbstractQueuedSynchronizer

private void cancelAcquire(Node node) {
  // 将无效节点过滤
    if (node == null)
        return;
  // 设置该节点不关联任何线程，也就是虚节点
    node.thread = null;
    Node pred = node.prev;
  // 通过前驱节点，跳过取消状态的node
    while (pred.waitStatus &gt; 0)
        node.prev = pred = pred.prev;
  // 获取过滤后的前驱节点的后继节点
    Node predNext = pred.next;
  // 把当前node的状态设置为CANCELLED
    node.waitStatus = Node.CANCELLED;
  // 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点
  // 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null
    if (node == tail &amp;&amp; compareAndSetTail(node, pred)) {
        compareAndSetNext(pred, predNext, null);
    } else {
        int ws;
    // 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功
    // 如果1和2中有一个为true，再判断当前节点的线程是否为null
    // 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点
        if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) {
            Node next = node.next;
            if (next != null &amp;&amp; next.waitStatus &lt;= 0)
                compareAndSetNext(pred, predNext, next);
        } else {
      // 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点
            unparkSuccessor(node);
        }
        node.next = node; // help GC
    }
}</code></pre><p>cancelAcquire方法的流程：</p><ol><li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li><li><p>根据当前节点的位置，考虑以下三种情况：</p><ol><li>当前节点是尾节点。</li><li>当前节点是Head的后继节点。</li><li>当前节点不是Head的后继节点，也不是尾节点。</li></ol></li></ol><p>当前节点是尾节点：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598438" alt="" title="" loading="lazy"/></p><p>当前节点是Head的后继节点：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598439" alt="" title="" loading="lazy"/></p><p>当前节点不是Head的后继节点，也不是尾节点：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598440" alt="" title="" loading="lazy"/></p><p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p><p>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。</p><p>shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</p><pre><code class="java">do {
    node.prev = pred = pred.prev;
} while (pred.waitStatus &gt; 0);</code></pre><h3>release(int)</h3><p>此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。</p><pre><code class="java">public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;//找到头结点
        // 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);//唤醒等待队列里的下一个线程
        return true;
    }
    return false;
}</code></pre><p>根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()</p><p>这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</p><ul><li>h null Head还没初始化。初始情况下，head null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。</li><li>h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。</li><li>h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</li></ul><h4>tryRelease(int)</h4><pre><code class="java">protected boolean tryRelease(int arg) {
    throw new UnsupportedOperationException();
}</code></pre><p>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p><pre><code class="java">// java.util.concurrent.locks.ReentrantLock.Sync#tryRelease

@ReservedStackAccess
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;//在未重入的情况下，getState() = 1，减去releases 1，因此c 为 0
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);//独占锁线程设置为null
    }
    setState(c);//恢复默认
    return free;
}</code></pre><h4>unparkSuccessor(Node)</h4><p>此方法用于唤醒等待队列中下一个线程。</p><pre><code class="java">private void unparkSuccessor(Node node) {
    //这里，node一般为当前线程所在的结点。
    int ws = node.waitStatus;
    if (ws &lt; 0)//置零当前线程所在的结点状态，允许失败。
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;//找到下一个需要唤醒的结点s
    if (s == null || s.waitStatus &gt; 0) {//如果为空或已取消
        s = null;
        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) // 从后向前找。
            if (t.waitStatus &lt;= 0)//从这里可以看出，&lt;=0的结点，都是还有效的结点。
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);//唤醒
}</code></pre><p>这个函数并不复杂。一句话概括：用unpark()唤醒等待队列中最前边的那个未放弃线程s。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立了），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！</p><p>在队列中查找时是从后向前找的，为什么这么做？</p><p>从源码上看，先找到后继结点s，如果s状态正常那么直接唤醒。但有两种异常情况，会导致next链不一致：</p><ol><li>s==null，在新结点入队时可能会出现</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598441" alt="" title="" loading="lazy"/></p><ol start="2"><li>s.waitStatus &gt; 0，中间有节点取消时会出现（如超时）</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047598442" alt="" title="" loading="lazy"/></p><p>关于并发问题，addWaiter()入队操作和cancelAcquire()取消排队操作都会造成next链的不一致，而prev链是强一致的，所以这时从后往前找是最安全的。</p><blockquote><p>为什么prev链是强一致的？</p><p>因为addWaiter()里每次compareAndSetTail(pred, node)之前都有node.prev = pred，即使compareAndSetTail失败，enq()会反复尝试，直到成功。一旦compareAndSetTail成功，该node.prev就成功挂在之前的tail结点上了，而且是唯一的，这时其他新结点的prev只能尝试往新tail结点上挂。这里的组合用法非常巧妙，能保证CAS之前的prev链强一致，但不能保证CAS后的next链强一致。</p></blockquote><h3>acquireShared(int)</h3><p>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。</p><pre><code class="java">public final void acquireShared(int arg) {
     if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}</code></pre><p>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li></ol><h4>doAcquireShared(int)</h4><p>此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。</p><pre><code class="java">private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);//加入队列尾部
    boolean failed = true;//是否成功标志
    try {
        boolean interrupted = false;//等待过程中是否被中断过的标志
        for (;;) {
            final Node p = node.predecessor();//前驱
            if (p == head) {//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的
                int r = tryAcquireShared(arg);//尝试获取资源
                if (r &gt;= 0) {//成功
                    setHeadAndPropagate(node, r);//将head指向自己，还有剩余资源可以再唤醒之后的线程
                    p.next = null; // help GC
                    if (interrupted)//如果等待过程中被打断过，此时将中断补上。
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }

            //判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}</code></pre><p>这里跟acquireQueued()的流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，但实际上都一样。</p><p>跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。</p><p>那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p><p>setHeadAndPropagate(Node, int):此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p><p>private void setHeadAndPropagate(Node node, int propagate) {</p><pre><code class="java">private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head;
    setHead(node);//head指向自己
     //如果还有剩余量，继续唤醒下一个邻居线程
    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}</code></pre><h3>releaseShared()</h3><p>此方法是共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。</p><pre><code class="java">public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {//尝试释放资源
        doReleaseShared();//唤醒后继结点
        return true;
    }
    return false;
}</code></pre><p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值</p><h4>doReleaseShared()</h4><p>此方法主要用于唤醒后继</p><pre><code class="java">private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null &amp;&amp; h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;
                unparkSuccessor(h);//唤醒后继
            }
            else if (ws == 0 &amp;&amp;
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;
        }
        if (h == head)// head发生变化
            break;
    }
}</code></pre><h2>应用</h2><p>Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。核心源码：</p><pre><code class="java">class Mutex implements Lock, java.io.Serializable {
    // 自定义同步器
    private static class Sync extends AbstractQueuedSynchronizer {
        // 判断是否锁定状态
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        // 尝试获取资源，立即返回。成功则返回true，否则false。
        public boolean tryAcquire(int acquires) {
            assert acquires == 1; // 这里限定只能为1个量
            if (compareAndSetState(0, 1)) {//state为0才设置为1，不可重入！
                setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源
                return true;
            }
            return false;
        }

        // 尝试释放资源，立即返回。成功则为true，否则false。
        protected boolean tryRelease(int releases) {
            assert releases == 1; // 限定为1个量
            if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！
                throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null);
            setState(0);//释放资源，放弃占有状态
            return true;
        }
    }

    // 真正同步类的实现都依赖继承于AQS的自定义同步器！
    private final Sync sync = new Sync();

    //lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。
    public void lock() {
        sync.acquire(1);
    }

    //tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    //unlock&lt;--&gt;release。两者语文一样：释放资源。
    public void unlock() {
        sync.release(1);
    }

    //锁是否占有状态
    public boolean isLocked() {
        return sync.isHeldExclusively();
    }
}</code></pre><p>除了Mutex，ReentrantLock/CountDownLatch/Semphore这些同步类的实现方式都差不多，不同的地方就在获取-释放资源的方式tryAcquire-tryRelelase。</p><h2>ReentrantLock 的使用</h2><p>ReentrantLock 的使用方式与 <a href="https://link.segmentfault.com/?enc=cmlB7qj6OZvrFYvFOYLykg%3D%3D.WwRQbohm%2BSSWSH8KbAYJYP8UJEPDGNUXFG%2FQuzJQN514cTzA%2FToSg4Rw63ci9H7QDx136ylg8fRTHgj5LNtZyejf1uFctdcUQLH6iHgNo7A%3D" rel="nofollow" target="_blank">synchronized</a> 关键字类似，都是通过加锁和释放锁来实现同步的。我们来看看 ReentrantLock 的使用方式，以非公平锁为例：</p><pre><code class="java">public class ReentrantLockTest {
    private static final ReentrantLock lock = new ReentrantLock();
    private static int count = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10000; i++) {
                lock.lock();
                try {
                    count++;
                } finally {
                    lock.unlock();
                }
            }
        });
        Thread thread2 = new Thread(() -&gt; {
            for (int i = 0; i &lt; 10000; i++) {
                lock.lock();
                try {
                    count++;
                } finally {
                    lock.unlock();
                }
            }
        });
        thread1.start();
        thread2.start();
        thread1.join();
        thread2.join();
        System.out.println(count);
    }
}</code></pre><p>代码很简单，两个线程分别对 count 变量进行 10000 次累加操作，最后输出 count 的值。我们来看看运行结果：</p><pre><code>20000</code></pre><p>可以看到，两个线程对 count 变量进行了 20000 次累加操作，说明 ReentrantLock 是支持重入性的。再来看看公平锁的使用方式，只需要将 ReentrantLock 的构造方法改为公平锁即可：</p><pre><code class="java">private static final ReentrantLock lock = new ReentrantLock(true);</code></pre><p>运行结果为：</p><pre><code>20000</code></pre><p>可以看到，公平锁的运行结果与非公平锁的运行结果一致，这是因为公平锁的实现方式与非公平锁的实现方式基本一致，只是在获取锁时增加了判断当前节点是否有前驱节点的逻辑判断。</p><ul><li>公平锁: 按照线程请求锁的顺序获取锁，即先到先得。</li><li>非公平锁: 线程获取锁的顺序可能与请求锁的顺序不同，可能导致某些线程获取锁的速度较快。</li></ul><p>需要注意的是，使用 ReentrantLock 时，锁必须在 try 代码块开始之前获取，并且加锁之前不能有异常抛出，否则在 finally 块中就无法释放锁（ReentrantLock 的锁必须在 finally 中手动释放）。</p><p>错误示例：</p><pre><code class="java">Lock lock = new XxxLock();
// ...
try {
    // 如果在此抛出异常，会直接执行 finally 块的代码
    doSomething();
    // 不管锁是否成功，finally 块都会执行
    lock.lock();
    doOthers();

} finally {
    lock.unlock();
}</code></pre><p>正确示例：</p><pre><code class="java">Lock lock = new XxxLock();
// ...
lock.lock();
try {
    doSomething();
    doOthers();
} finally {
    lock.unlock();
}</code></pre>]]></description></item><item>    <title><![CDATA[『NAS』一键部署2048小游戏 德育处主任 ]]></title>    <link>https://segmentfault.com/a/1190000047600696</link>    <guid>https://segmentfault.com/a/1190000047600696</guid>    <pubDate>2026-02-09 08:02:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p><blockquote>整理了一个NAS小专栏，有兴趣的工友可以关注一下 👉 <a href="https://link.segmentfault.com/?enc=0nS595SB4hsIRclsNnNAwg%3D%3D.70LHA3caHnxzzmx8m5TLAPDixBu2XuYw%2FgIU4ylJe64IOabAtS9315xjLjz%2FBl5YdOETJAIIdZ98%2B1mBXLgl%2FT9%2Ba0anuuCuOtSCEUpfdD46BJDee7yRD%2FXQYfuxrwAFsJlAlB7u%2BSeo480qNfVIFP8O4FFrWdAsNNqw%2Fe0lYIY%3D" rel="nofollow" target="_blank">《NAS邪修》</a></blockquote><p>轻量化开源的 2048 游戏，完美支持 NAS 私有化部署，借助 Docker 可实现一键安装，群晖、绿联、威联通等主流 NAS 设备均能适配，无需复杂配置即可上手。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600698" alt="" title=""/></p><p>我这次使用飞牛 NAS 部署，其他品牌操作步骤基本一致。</p><p>在“文件管理”的“docker”里创建要给“gaem2048”文件夹。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600699" alt="" title="" loading="lazy"/></p><p>打开“Docker”，在“Compose”里新建一个项目，填入以下内容。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600700" alt="" title="" loading="lazy"/></p><p>代码：</p><pre><code>services:
  game2048:
    image: quchaonet/2048:latest
    container_name: game2048
    ports:
      - 2333:8080
    restart: always</code></pre><p><code>2333</code> 这个端口根据你实际情况来填，不要跟其他项目冲突即可。</p><p>项目构建成功后，在浏览器输入 <code>NAS的IP:2333</code> 就可以玩了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600701" alt="" title="" loading="lazy"/></p><hr/><p>以上就是本文的全部内容啦，<strong>有疑问可以在评论区讨论～</strong></p><p><strong>想了解更多NAS玩法可以关注<a href="https://link.segmentfault.com/?enc=2pCKgLWvPXx1h2bLDoSHUA%3D%3D.S28RhRucMl14YR3KVa2e%2B4ceywtwhHemxGpp1b6oaOou3qoE7%2BiwxvtX0wCbvhK5%2FsRl4huwtBGGwjof1q5OoHd75MBYXnhwG6vGm%2BiIi3ic3JH40tCWGJK3Z85Y1%2BtxiZvefUBxZRb1G%2FzjddF4T5g1Iko6UsO8vj5KIpfpjsQ%3D" rel="nofollow" target="_blank">《NAS邪修》👏</a></strong></p><p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p>]]></description></item><item>    <title><![CDATA[『NAS』一键部署魔塔！重拾童年经典策略闯关游戏-MagicTower 德育处主任 ]]></title>    <link>https://segmentfault.com/a/1190000047600708</link>    <guid>https://segmentfault.com/a/1190000047600708</guid>    <pubDate>2026-02-09 08:02:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p><blockquote>整理了一个NAS小专栏，有兴趣的工友可以关注一下 👉 <a href="https://link.segmentfault.com/?enc=XgA%2B84oN%2FPHESH5luv%2BNeg%3D%3D.WANjvCNyyO7xG9pKgBqf5ZfyK%2BdElh4lGeTvMv079RaCJDD3%2F3byR5b1K6Pg6TbFGX3B7v6bZ%2B5LQV7H0Gmr3enKhSlxpy7F2a2%2BRfYou8rHFisVc3UUx1NMvnOAyRJiomiOmnstz2euOHnxOjJICKW1J3PS3j2h3wga8p3k%2BzY%3D" rel="nofollow" target="_blank">《NAS邪修》</a></blockquote><p>Magic Tower（魔塔）是承载无数人童年回忆的经典策略 RPG 小游戏，NAS 小白也能通过 Docker 快速部署，无需复杂配置。它以固定数值战斗为核心，玩家需在多层高塔中计算攻防血数值，合理收集钥匙、装备与道具，规划最优路线击败怪物，最终挑战魔王，每步决策都影响通关成败。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600710" alt="" title=""/></p><p>本次使用飞牛 NAS 部署魔塔，其他品牌的 NAS 操作步骤也是一样的，有 Docker 就行。</p><p>首先打开“文件管理”，找到“docker”文件夹，在里面创建一个“magic-tower”文件夹。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600711" alt="" title="" loading="lazy"/></p><p>接着打开“Docker”应用，切换到“Compose”面板，新增一个项目。</p><p>项目名称填“magic-tower”。</p><p>路径选择刚刚在“docker”文件夹下创建的“magic-tower”。</p><p>来源选择屙“创建docker-compose.yml”。</p><p>勾选“创建项目后立即启动”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600712" alt="" title="" loading="lazy"/></p><p>然后输入以下代码：</p><pre><code>services:
  magic-tower:
    image: heizicao/magic-tower:latest
    container_name: magic-tower
    ports:
      - 2334:3000
    restart: always</code></pre><p>我给“magic-tower”配置了 <code>2334</code> 这个端口，如果你的 NAS 有其他项目使用了这个端口，那就给自己填一个没用过的端口即可。</p><p>等项目构建完成后，打开浏览器，输入 <code>NAS的IP:2334</code> 就可以开玩了～</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600713" alt="" title="" loading="lazy"/></p><hr/><p>以上就是本文的全部内容啦，<strong>有疑问可以在评论区讨论～</strong></p><p><strong>想了解更多NAS玩法可以关注<a href="https://link.segmentfault.com/?enc=kNcwkZnIQ0SOL9EELVJXOQ%3D%3D.qdY1tEmj8xobzXV41lThxMEk85CgmRbaw4IKNpJXFWs%2F6Yiv%2FHtyHB1xvw12JP9q7htFm8RmSSKz5t8Q8GxocWlVBNyOgxQRk1MP9DC6yok6d4SeBkhE2KyQAF0DqE%2FQy9AzDsFjlH8jAQAR03EhpQWqegiAowhmMZ8IGMT2s78%3D" rel="nofollow" target="_blank">《NAS邪修》👏</a></strong></p><p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p>]]></description></item><item>    <title><![CDATA[HarmonyOS 6 自定义人脸识别模型1：XComponent入门 轻口味 ]]></title>    <link>https://segmentfault.com/a/1190000047600726</link>    <guid>https://segmentfault.com/a/1190000047600726</guid>    <pubDate>2026-02-09 08:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>一、背景与核心价值</h2><p>在HarmonyOS应用开发中，面对<strong>实时画面处理、复杂图形渲染、硬件资源直操作</strong>等场景（如人脸识别中的相机预览流解析、AI模型推理结果叠加显示），传统UI组件往往难以满足性能与灵活性需求。而XComponent作为HarmonyOS提供的自定义渲染组件，恰好解决了这一痛点——它支持EGL/OpenGLES图形渲染与媒体数据写入，通过直接操作NativeWindow实现高效绘制，成为复杂场景开发的核心技术支撑。</p><p>本系列博客将以“自定义人脸识别模型”为目标，逐步拆解开发流程。第一篇作为入门篇，将聚焦XComponent的核心原理、两种应用场景与实战开发，为后续整合相机流、AI推理模型打下基础。</p><h2>二、XComponent核心原理速览</h2><h3>2.1 什么是XComponent？</h3><p>XComponent是HarmonyOS专为<strong>复杂自定义渲染</strong>设计的组件，核心作用是提供一个可直接操作的<code>surface</code>（绘图表面），开发者通过<code>NativeWindow</code>接口申请、提交绘制缓冲区（Buffer），最终由XComponent将<code>surface</code>整合到应用UI界面中。</p><p>其核心特性包括：</p><ul><li><p>两种渲染类型：</p><ul><li><code>XComponentType.SURFACE</code>：自定义绘制内容独立显示，适合全屏渲染（如游戏、相机预览）；</li><li><code>XComponentType.TEXTURE</code>：绘制内容与XComponent组件内容合成显示，适合局部叠加（如人脸识别框、水印）。</li></ul></li><li>跨层通信能力：支持ArkTS层与Native层的数据交互、事件回调，满足混合开发需求。</li></ul><h3>2.2 自绘制核心流程</h3><pre style="display:none;"><code class="mermaid">graph TD
    A[开发者] --&gt; B[通过NativeWindow申请Buffer]
    B --&gt; C[绘制内容（EGL/GLES）]
    C --&gt; D[提交Buffer至图形队列]
    D --&gt; E[XComponent持有surface接收Buffer]
    E --&gt; F[surface整合进应用UI]
    F --&gt; G[用户看到最终渲染效果]</code></pre><blockquote>图1：XComponent自绘制原理流程图</blockquote><h3>2.3 生命周期核心事件</h3><p>XComponent的生命周期与<code>surface</code>的创建、销毁强绑定，核心事件包括：</p><ul><li><code>onLoad</code>：surface准备就绪时触发，可获取Native层方法上下文，用于初始化渲染环境；</li><li><code>onDestroy</code>：组件销毁时触发，需在此释放<code>NativeWindow</code>、EGL上下文等资源，避免内存泄漏。</li></ul><p>两种场景的生命周期时序图：</p><h4>ArkTS XComponent生命周期时序图</h4><p>对于需要在ArkTS侧使用已封装接口进行功能开发（如相机预览、视频播放等）或对跨语言性能损耗不敏感的跨语言开发，建议直接在ArkTS侧使用XComponentController管理Surface生命周期。</p><ul><li>onSurfaceCreated回调，触发时刻：XComponent创建完成且创建好Surface后触发。ArkTS侧onSurfaceCreated的时序如下图：<br/><img width="319" height="139" referrerpolicy="no-referrer" src="/img/bVdnThG" alt="image.png" title="image.png"/></li><li>onSurfaceChanged回调，触发时刻：Surface大小变化触发重新布局之后触发。ArkTS侧onSurfaceChanged的时序如下图：<br/><img width="317" height="141" referrerpolicy="no-referrer" src="/img/bVdnThH" alt="image.png" title="image.png" loading="lazy"/></li><li>onSurfaceDestroyed回调，触发时刻：XComponent组件被销毁时触发，与一般ArkUI的组件销毁时机一致。ArkTS侧onSurfaceDestroyed的时序图：<br/><img width="316" height="142" referrerpolicy="no-referrer" src="/img/bVdnThI" alt="image.png" title="image.png" loading="lazy"/></li></ul><h4>Native XComponent生命周期时序图</h4><p>对于复杂的交互逻辑需跨语言开发，追求极致渲染性能或业务需求自主控制Surface的创建和销毁的，建议在Native侧使用OH_ArkUI_SurfaceHolder管理Surface生命周期。其生命周期触发时机如下：</p><ul><li><p>OnSurfaceCreated回调，触发时刻：当XComponent创建完成且创建好Surface后，满足以下任一条件时触发。</p><ol><li>组件上树且autoInitialize = true。</li><li>调用OH_ArkUI_XComponent_Initialize。</li></ol><p>Native侧OnSurfaceCreated的时序如下图：<br/><img width="683" height="403" referrerpolicy="no-referrer" src="/img/bVdnThJ" alt="image.png" title="image.png" loading="lazy"/></p></li><li>OnSurfaceChanged回调，触发时刻：OnSurfaceCreated回调成功触发且Surface大小变化触发重新布局之后触发。Native侧OnSurfaceChanged的时序如下图：<br/><img width="319" height="205" referrerpolicy="no-referrer" src="/img/bVdnThK" alt="image.png" title="image.png" loading="lazy"/></li><li>OnSurfaceDestroyed回调，触发时刻：组件下树且autoInitialize=true 或者调用 OH_ArkUI_XComponent_Finalize后触发。Native侧OnSurfaceDestroyed的时序图：<br/><img width="723" height="244" referrerpolicy="no-referrer" src="/img/bVdnThL" alt="image.png" title="image.png" loading="lazy"/></li></ul><h2>三、与 Android 自定义渲染组件深度对比</h2><p>HarmonyOS XComponent 的设计思路与 Android 的<code>SurfaceView</code>/<code>TextureView</code>相似，但在跨层协作、生命周期管理、灵活性上有显著优化。以下从核心维度对比：</p><table><thead><tr><th>对比维度</th><th>HarmonyOS XComponent</th><th>Android SurfaceView</th><th>Android TextureView</th></tr></thead><tbody><tr><td>核心渲染载体</td><td>Surface（通过 NativeWindow 操作）</td><td>Surface</td><td>SurfaceTexture</td></tr><tr><td>渲染模式</td><td>双模式：SURFACE（独立图层）、TEXTURE（UI 合成）</td><td>独立图层（SurfaceFlinger 直接渲染）</td><td>UI 合成（与 View 树同图层）</td></tr><tr><td>创建方式</td><td>3 种：ArkTS 声明式、ArkTS 自定义节点、NDK</td><td>XML 布局 / 代码创建</td><td>XML 布局 / 代码创建</td></tr><tr><td>生命周期管理</td><td>2 种：XComponentController（ArkTS 侧）、OH_ArkUI_SurfaceHolder（Native 侧）</td><td>SurfaceHolder 回调（surfaceCreated/surfaceDestroyed）</td><td>SurfaceTextureListener 回调</td></tr><tr><td>跨层通信</td><td>ArkTS↔Native 通过 Node-API 接口契约，支持直接传递 SurfaceId/NodeHandle</td><td>Java↔Native 通过 JNI，需手动传递 Surface 对象</td><td>需通过 SurfaceTexture 跨层传递，流程繁琐</td></tr><tr><td>事件支持</td><td>基础事件（触摸 / 键盘 / 鼠标）+ 高级手势（长按 / 拖拽）</td><td>仅基础触摸事件，高级手势需自定义</td><td>支持 View 树事件传递，但合成有延迟</td></tr><tr><td>性能表现</td><td>SURFACE 模式无 UI 合成开销，TEXTURE 模式合成效率优化</td><td>独立图层无合成开销，性能最优</td><td>需 GPU 合成，高帧率场景有性能损耗</td></tr><tr><td>灵活性</td><td>支持 5 种开发范式，适配不同技术栈</td><td>仅支持 Java 层开发，Native 扩展需 JNI</td><td>支持 Java 层开发，Native 扩展复杂</td></tr><tr><td>资源释放</td><td>回调明确，支持自动释放 + 手动释放双重保障</td><td>依赖 SurfaceHolder 回调，易遗漏释放导致内存泄漏</td><td>需监听 TextureView 销毁，释放逻辑复杂</td></tr></tbody></table><h3>核心优势总结</h3><ol><li><strong>跨层协作更高效</strong>：XComponent 通过<code>SurfaceId</code>/<code>NodeHandle</code>实现 ArkTS 与 Native 的直接通信，无需像 Android 那样通过 JNI 传递复杂对象；</li><li><strong>生命周期更可控</strong>：提供双端生命周期管理方式，回调触发时机明确，减少资源泄漏风险；</li><li><strong>开发范式更灵活</strong>：5 种范式覆盖从简单 UI 开发到极致性能需求的全场景，而 Android 仅支持单一创建方式；</li><li><strong>事件支持更丰富</strong>：内置高级手势识别，无需像 Android 那样自定义手势检测器；</li><li><strong>渲染模式更灵活</strong>：双渲染模式可按需切换，而 Android 需在 SurfaceView 和 TextureView 之间二选一。</li></ol><h2>四、XComponent 五大开发范式全解析</h2><p>开发范式是标准化的流程模板，XComponent 基于 "创建方式 + 生命周期管理方式" 的组合，提供 5 种开发范式，覆盖不同技术栈需求：</p><table><thead><tr><th>范式类型</th><th>创建方式</th><th>生命周期管理方式</th><th>核心适用场景</th></tr></thead><tbody><tr><td>范式 1</td><td>ArkTS 声明式 UI</td><td>XComponentController</td><td>通用 UI 开发、相机预览 / 视频播放（ArkTS 为主）</td></tr><tr><td>范式 2</td><td>ArkTS 声明式 UI</td><td>OH_ArkUI_SurfaceHolder</td><td>复杂交互、跨层性能敏感场景（Native 主导渲染）</td></tr><tr><td>范式 3</td><td>ArkTS 自定义组件节点</td><td>XComponentController</td><td>自定义复杂组件、动态布局场景</td></tr><tr><td>范式 4</td><td>ArkTS 自定义组件节点</td><td>OH_ArkUI_SurfaceHolder</td><td>复杂组件 + 极致渲染性能需求</td></tr><tr><td>范式 5</td><td>NDK 接口</td><td>OH_ArkUI_SurfaceHolder</td><td>纯 Native 开发、底层硬件操作场景</td></tr></tbody></table><h2>五、XComponent两大应用场景实战</h2><p>XComponent提供两种核心开发场景，分别适用于不同的技术栈需求。以下基于HarmonyOS 6，以“绘制可点击变色的五角星”为例，拆解实战步骤。</p><h3>5.1 场景1：Native XComponent（C++主导渲染）</h3><h4>核心特点</h4><ul><li>需配置<code>libraryname</code>（动态库名称）、<code>id</code>（唯一标识）；</li><li>Native层注册生命周期与事件回调，直接操作<code>NativeWindow</code>；</li><li>适合需要高效调用C++图形库、硬件加速的场景（如人脸识别模型推理）。</li></ul><h4>开发步骤（关键代码+解释）</h4><h5>步骤1：ArkTS侧定义XComponent</h5><pre><code class="typescript">// 声明Native侧接口
export default interface XComponentContext {
  drawPattern(): void; // 绘制五角星
  getStatus(): { hasDraw: boolean; hasChangeColor: boolean }; // 获取渲染状态
}

@Entry
@Component
struct NativeXComponentDemo {
  private xComponentContext: XComponentContext | undefined = undefined;
  // 配置XComponent属性：id唯一、类型SURFACE、绑定动态库nativerender
  private xComponentAttrs: XComponentAttrs = {
    id: 'starRenderId', // 必须唯一
    type: XComponentType.SURFACE,
    libraryname: 'nativerender' // 与Native层模块名一致
  };

  build() {
    Column() {
      XComponent(this.xComponentAttrs)
        .focusable(true) // 支持键盘事件
        .onLoad((context) =&gt; {
          // 初始化Native层上下文
          this.xComponentContext = context as XComponentContext;
          // 调用Native层绘制方法
          this.xComponentContext?.drawPattern();
        })
        .onDestroy(() =&gt; {
          console.log("XComponent销毁，释放资源");
        })
        .width('80%')
        .height(300);

      Button("切换颜色")
        .onClick(() =&gt; {
          const status = this.xComponentContext?.getStatus();
          if (status) status.hasChangeColor = true;
        })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center);
  }
}</code></pre><h5>步骤2：Native层Node-API注册</h5><pre><code class="cpp">// napi_init.cpp：将C++方法暴露给ArkTS侧
#include &lt;napi/native_api.h&gt;
#include "plugin_manager.h"

EXTERN_C_START
static napi_value Init(napi_env env, napi_value exports) {
  // 暴露getContext接口，用于获取XComponent实例
  napi_property_descriptor desc[] = {
    {"getContext", nullptr, PluginManager::GetContext, nullptr, nullptr, nullptr, napi_default, nullptr}
  };
  napi_define_properties(env, exports, sizeof(desc)/sizeof(desc[0]), desc);
  // 导出绘制相关方法（drawPattern、getStatus）
  PluginManager::GetInstance()-&gt;Export(env, exports);
  return exports;
}
EXTERN_C_END

// 注册模块，模块名需与ArkTS侧libraryname一致
static napi_module nativerenderModule = {
  .nm_version = 1,
  .nm_register_func = Init,
  .nm_modname = "nativerender", // 关键：与libraryname匹配
  .nm_priv = nullptr,
  .reserved = {0}
};

// 自动注册模块
extern "C" __attribute__((constructor)) void RegisterModule(void) {
  napi_module_register(&amp;nativerenderModule);
}</code></pre><h5>步骤3：事件回调与渲染实现</h5><p>核心是通过<code>OH_NativeXComponent_RegisterCallback</code>注册生命周期与触摸/按键事件，利用EGL/GLES绘制图形：</p><pre><code class="cpp">// plugin_render.cpp：渲染逻辑实现
void PluginRender::RegisterCallback(OH_NativeXComponent* nativeXComponent) {
  // 注册surface创建、改变、销毁回调
  renderCallback_.OnSurfaceCreated = OnSurfaceCreatedCB;
  renderCallback_.OnSurfaceChanged = OnSurfaceChangedCB;
  renderCallback_.OnSurfaceDestroyed = OnSurfaceDestroyedCB;
  // 注册触摸事件回调（用于点击变色）
  renderCallback_.DispatchTouchEvent = DispatchTouchEventCB;
  OH_NativeXComponent_RegisterCallback(nativeXComponent, &amp;renderCallback_);
}

// surface创建时初始化EGL环境
void OnSurfaceCreatedCB(OH_NativeXComponent* component, void* window) {
  std::string id = GetXComponentId(component); // 获取唯一ID
  auto render = PluginRender::GetInstance(id);
  uint64_t width, height;
  OH_NativeXComponent_GetXComponentSize(component, window, &amp;width, &amp;height);
  // 初始化EGL上下文，准备绘制
  render-&gt;eglCore_-&gt;EglContextInit(window, width, height);
  render-&gt;eglCore_-&gt;Background(); // 绘制背景
}

// 触摸事件触发颜色切换
void DispatchTouchEventCB(OH_NativeXComponent* component, void* window) {
  OH_NativeXComponent_TouchEvent touchEvent;
  OH_NativeXComponent_GetTouchEvent(component, window, &amp;touchEvent);
  if (touchEvent.type == OH_NATIVEXCOMPONENT_UP) { // 手指抬起时
    std::string id = GetXComponentId(component);
    auto render = PluginRender::GetInstance(id);
    render-&gt;eglCore_-&gt;ChangeColor(); // 切换五角星颜色
  }
}</code></pre><h5>步骤4：CMakeLists配置（编译动态库）</h5><pre><code class="cmake">cmake_minimum_required(VERSION 3.4.1)
project(XComponentDemo)

# 头文件目录
include_directories(
  ${CMAKE_CURRENT_SOURCE_DIR}
  ${CMAKE_CURRENT_SOURCE_DIR}/include
)

# 编译动态库nativerender
add_library(nativerender SHARED
  render/egl_core.cpp
  render/plugin_render.cpp
  manager/plugin_manager.cpp
  napi_init.cpp
)

# 链接依赖库（EGL、GLES、日志等）
target_link_libraries(nativerender PUBLIC
  EGL GLESv3 hilog_ndk.z ace_ndk.z ace_napi.z uv
)</code></pre><h5>运行效果</h5><p><img width="588" height="634" referrerpolicy="no-referrer" src="/img/bVdnThM" alt="image.png" title="image.png" loading="lazy"/><br/><img width="572" height="584" referrerpolicy="no-referrer" src="/img/bVdnThN" alt="image.png" title="image.png" loading="lazy"/></p><blockquote>图4：Native XComponent运行效果（左：初始状态；右：点击后变色）</blockquote><h3>5.2 场景2：ArkTS XComponent（ArkTS主导渲染）</h3><h4>核心特点</h4><ul><li>无需配置<code>libraryname</code>，通过<code>SurfaceId</code>实现跨层通信；</li><li>ArkTS侧获取<code>SurfaceId</code>并传递给Native层，生命周期与事件回调均在ArkTS侧触发；</li><li>适合ArkTS为主、Native为辅的混合开发场景，配置更简洁。</li></ul><h4>关键差异点</h4><table><thead><tr><th>对比维度</th><th>Native XComponent</th><th>ArkTS XComponent</th></tr></thead><tbody><tr><td>跨层标识</td><td>依赖<code>id</code>+动态库名</td><td>依赖<code>SurfaceId</code></td></tr><tr><td>回调触发</td><td>Native层注册回调</td><td>ArkTS侧通过Controller注册</td></tr><tr><td>初始化方式</td><td>Native层获取<code>OH_NativeXComponent</code>实例</td><td>Native层通过<code>SurfaceId</code>创建<code>NativeWindow</code></td></tr></tbody></table><h4>核心代码示例（ArkTS侧）</h4><pre><code class="typescript">// 重写XComponentController，监听Surface生命周期
class MyXComponentController extends XComponentController {
  // Surface创建时传递SurfaceId到Native层
  onSurfaceCreated(surfaceId: string): void {
    console.log(`Surface创建：${surfaceId}`);
    nativeRender.SetSurfaceId(BigInt(surfaceId)); // 传递给Native
  }

  // Surface尺寸改变时更新
  onSurfaceChanged(surfaceId: string, rect: SurfaceRect): void {
    nativeRender.ChangeSurface(BigInt(surfaceId), rect.surfaceWidth, rect.surfaceHeight);
  }

  // Surface销毁时释放资源
  onSurfaceDestroyed(surfaceId: string): void {
    nativeRender.DestroySurface(BigInt(surfaceId));
  }
}

@Entry
@Component
struct ArkTSXComponentDemo {
  private xComponentController = new MyXComponentController();

  build() {
    Column() {
      XComponent({
        type: XComponentType.SURFACE,
        controller: this.xComponentController
      })
      .width('80%')
      .height(300);

      Button("绘制五角星")
        .onClick(() =&gt; {
          const surfaceId = this.xComponentController.getXComponentSurfaceId();
          nativeRender.DrawPattern(BigInt(surfaceId)); // 调用Native绘制
        });
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center);
  }
}</code></pre><h2>六、注意事项与避坑指南</h2><ol><li><strong>id/SurfaceId唯一性</strong>：多个XComponent共存时，需保证<code>id</code>（Native场景）或<code>SurfaceId+随机数</code>（ArkTS场景）唯一，否则会导致资源缓存冲突；</li><li><strong>资源释放必须及时</strong>：<code>onDestroy</code>或<code>OnSurfaceDestroyed</code>回调中，需释放<code>NativeWindow</code>、EGL上下文、动态库实例，避免野指针崩溃；</li><li><strong>禁止跨线程访问接口</strong>：文档明确说明XComponent的NDK接口不支持跨线程调用，需在同一线程处理渲染与事件；</li><li><strong>typeNode组件特殊处理</strong>：若使用<code>typeNode</code>创建XComponent，需先通过<code>OH_NativeWindow_NativeWindowHandleOpt</code>设置缓冲区尺寸，否则绘制失败。</li></ol><h2>七、总结与后续规划</h2><h3>7.1 核心回顾</h3><p>XComponent作为HarmonyOS复杂渲染的核心组件，通过<code>NativeWindow</code>与EGL/GLES的结合，实现了高效、灵活的自定义绘制能力。本文重点讲解了：</p><ul><li>XComponent的核心原理与两种渲染类型；</li><li>Native XComponent与ArkTS XComponent的开发流程、差异对比；</li><li>实战中需注意的资源管理、唯一性约束等关键问题。</li></ul><h3>7.2 系列博客预告</h3><p>本系列的目标是实现“自定义人脸识别模型”，后续将逐步推进：</p><ul><li>第2篇：基于XComponent实现相机预览流捕获与实时渲染；</li><li>第3篇：集成轻量级人脸识别AI模型（如MTCNN），实现人脸检测；</li><li>第4篇：优化渲染性能，实现人脸框实时叠加与模型推理加速。</li></ul><p>通过本系列，你将掌握HarmonyOS中复杂渲染+AI模型整合的完整流程，为开发高性能视觉类应用提供技术支撑。如果在实战中遇到问题，欢迎在评论区交流～</p>]]></description></item><item>    <title><![CDATA[2026-02-08 GitHub 热点项目精选 程序员锋仔 ]]></title>    <link>https://segmentfault.com/a/1190000047599544</link>    <guid>https://segmentfault.com/a/1190000047599544</guid>    <pubDate>2026-02-08 23:05:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>🌟 2026-02-08 GitHub Python 热点项目精选(13个)</h2><blockquote>每日同步 GitHub Trending 趋势，筛选优质 Python 项目，助力开发者快速把握技术风向标～</blockquote><hr/><h3>📋 项目列表（按 Star 数排序）</h3><h4>1. <a href="https://link.segmentfault.com/?enc=YNc3uETzfWZUnSP5va5AHQ%3D%3D.M2ipSv4Mgam3OyiBAGI0qj801NQu9kEzX%2BRbya1%2BkU50ioiBFkgJvWO94Iwo3XVf" rel="nofollow" target="_blank">openai/skills</a></h4><blockquote>OpenAI的技能目录，用于Codex的技能包，帮助团队和个人以可重复的方式完成特定任务。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 5854（今日+576）</td></tr><tr><td>Fork 数</td><td>🔄 320</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=jYPZFuBcS1KfpzSv1LtUxg%3D%3D.xMtqCpjcEPDccv%2Bbq%2FfZGNIqVBJsSIy3Z5R5J0mxGbULTM1EIw8qr2u00wzI9Jzv" rel="nofollow" target="_blank">https://github.com/openai/skills</a></td></tr></tbody></table><hr/><h4>2. <a href="https://link.segmentfault.com/?enc=oCbHmykUGDyCzwM1xh94IA%3D%3D.nw5x9FKZ%2FTl96sO31qV6fVy3%2FZMAWIdsvWi%2FEGXI3Zj%2FQozOf%2F1qD4TjqyvBULpm" rel="nofollow" target="_blank">p-e-w/heretic</a></h4><blockquote>Heretic是一个工具，可以自动去除基于Transformer的语言模型的审查制度（也称为“安全对齐”），无需昂贵的后训练。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4691（今日+61）</td></tr><tr><td>Fork 数</td><td>🔄 451</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=lmJHjiAbGwWyVbnmaoqhnQ%3D%3D.LeMqZPqGL6Y6ToHT1oIHZVLIVUC38Fv8Kqa1BEc8p6VQLeq9%2BOCDtemaZ7DQ8zFn" rel="nofollow" target="_blank">https://github.com/p-e-w/heretic</a></td></tr></tbody></table><hr/><h4>3. <a href="https://link.segmentfault.com/?enc=YwZWrRWp%2F6BuHSGTaYVAOw%3D%3D.Tia%2B1wRQV86LauvfATF3PP4kp%2FpUuaM8HNw61hxF5GkG1P0uPdwXs4soxbODNq5p" rel="nofollow" target="_blank">OpenBMB/MiniCPM-o</a></h4><blockquote>MiniCPM-o是一个9B参数的端到端模型，支持图像、视频、文本和音频输入，并提供高质量的文本和语音输出。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 23136（今日+42）</td></tr><tr><td>Fork 数</td><td>🔄 1761</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=%2FCxD6%2F3czE2s8vlA4gvZAg%3D%3D.bX9KYWAgDIDQxQUSi%2BnJT5lyd%2BDeS5lmbWOlT34i2YAY8e3DZN5yLaWZqCaNhbAR" rel="nofollow" target="_blank">https://github.com/OpenBMB/MiniCPM-o</a></td></tr></tbody></table><hr/><h4>4. <a href="https://link.segmentfault.com/?enc=7N28N%2BANWIagChGK3%2BKjrA%3D%3D.%2BHNj6r2mmesBxypfHUAjHGJIuPZGBjbTRH0D4z9n3zqfvurMjabbGuhGGEKSabS6a4sI4PlnuWkUuUQ%2BG1aTXg%3D%3D" rel="nofollow" target="_blank">ComposioHQ/awesome-claude-skills</a></h4><blockquote>一个精选的Claude技能列表，包含实用的Claude技能、资源和工具，用于定制Claude AI工作流程。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 31905（今日+514）</td></tr><tr><td>Fork 数</td><td>🔄 3059</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=l8DHycr3NmIkr%2B3Nk44zFA%3D%3D.HdksVneXg8qKPwJofHKmHhWEKwyTX9F4V0Uyl6lLyHhDkhOzTuH98Ubk7tFJuhLGxYpAaFkF%2BrEuam4qfprJkQ%3D%3D" rel="nofollow" target="_blank">https://github.com/ComposioHQ/awesome-claude-skills</a></td></tr></tbody></table><hr/><h4>5. <a href="https://link.segmentfault.com/?enc=RIDsQ%2F1Zhgxj%2FPQMhIpvxg%3D%3D.5Rb0QV2meqlXoUixGptyaSO7XQDEzeYxXSpIBhIxsL7vfzmBKkEHxO5bjD55f7Ij" rel="nofollow" target="_blank">chenyme/grok2api</a></h4><blockquote>基于FastAPI重构的Grok2API，全面适配最新Web调用格式，支持流式对话、图像生成/编辑等功能。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 1170（今日+61）</td></tr><tr><td>Fork 数</td><td>🔄 342</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=B8Qtr0Xv%2BDzb22%2FL%2BQDAtA%3D%3D.USmSGLVtXQyHpM9YkKh7LaXOVoE1q0zWega%2Bd7qI2lIGhp7xuuVxxvV5cEhaEUR7" rel="nofollow" target="_blank">https://github.com/chenyme/grok2api</a></td></tr></tbody></table><hr/><h4>6. <a href="https://link.segmentfault.com/?enc=%2FPRw1GTOrDCxMALP8FIcrA%3D%3D.pqu6jF79E1qzb0QPrbWvtpz814Vy52dV1HWTW%2BlV34aCABsu8IZKm77kxTG0p5JF" rel="nofollow" target="_blank">hao-ai-lab/FastVideo</a></h4><blockquote>FastVideo是一个统一的后训练和推理框架，用于加速视频生成，支持多种硬件和操作系统。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 3056（今日+6）</td></tr><tr><td>Fork 数</td><td>🔄 260</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=ZYFp9Ha7ahWAUabNtASTBw%3D%3D.lVAbbYiGDg6Jkp8R4PDZV999EQ41rppJOJOJGFhSqEdL4LKICXLBd5cbWi%2Bu7cv2" rel="nofollow" target="_blank">https://github.com/hao-ai-lab/FastVideo</a></td></tr></tbody></table><hr/><h4>7. <a href="https://link.segmentfault.com/?enc=mHwpPzPYvM2%2FrXbfiXvNmg%3D%3D.jNhAo6GHKjbIlRfmssYdzHSzLRLhCC6wEPyB929DuBRgv7%2BgQped4MIOyMXh%2BrEw" rel="nofollow" target="_blank">microsoft/RD-Agent</a></h4><blockquote>RD-Agent是一个用于自动化工业研发流程的框架，专注于数据和模型的自动化，支持多种场景。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 10852（今日+36）</td></tr><tr><td>Fork 数</td><td>🔄 1249</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=SLGSqLOtLRZODlBB1Anc6g%3D%3D.9Wg5b7iROOMN2lra6ueBagZVaP036SrpsGWfqV7kFN7VXP7%2B4X%2FFoOxpjQq4bSxi" rel="nofollow" target="_blank">https://github.com/microsoft/RD-Agent</a></td></tr></tbody></table><hr/><h4>8. <a href="https://link.segmentfault.com/?enc=wLUJS01w%2FSaqUKI3H19CcQ%3D%3D.qoDmqdISpwWfQlFUU%2F4nOw2LLZBlsMwseBiYeUSfnoY%3D" rel="nofollow" target="_blank">mem0ai/mem0</a></h4><blockquote>Mem0是一个为AI代理提供通用记忆层的工具，支持多级记忆和开发者友好的API。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 46807（今日+75）</td></tr><tr><td>Fork 数</td><td>🔄 5152</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=gGQeg3Kyp8iY62g7QSArZQ%3D%3D.ffalaikLe17h%2FggNjlzReuldirF5d4PR48KNEVwCfXk%3D" rel="nofollow" target="_blank">https://github.com/mem0ai/mem0</a></td></tr></tbody></table><hr/><h4>9. <a href="https://link.segmentfault.com/?enc=pU26Ir4V%2FOJTMEE7YQ0iIg%3D%3D.UnjCh20RB0lGUSZsC0roKdIa9%2BaoBl9kCUAi0ffcpAErlwSqn0L1PNuV422qNDJ6" rel="nofollow" target="_blank">airbytehq/airbyte</a></h4><blockquote>Airbyte是一个开源的数据集成平台，用于从API、数据库和文件到数据仓库、数据湖的数据管道。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 20655（今日+3）</td></tr><tr><td>Fork 数</td><td>🔄 5048</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=73N9QJa%2F6hj%2Bw2fRTLia3g%3D%3D.DinjLm6G53soq1I%2FzFpKTa2q9f6PEG8hu0HyAIHzXtdnTgkZUFUOG%2BOqo7qayvzP" rel="nofollow" target="_blank">https://github.com/airbytehq/airbyte</a></td></tr></tbody></table><hr/><h4>10. <a href="https://link.segmentfault.com/?enc=OJXtTn1RSr4fvv%2BcEPEnuA%3D%3D.VfrzSSy9yOYHwOexBkZ9grjEsRm0ettptVZhCY%2BUfRIHrwg3xFIHRgysjTe5GVv4" rel="nofollow" target="_blank">ruvnet/wifi-densepose</a></h4><blockquote>WiFi DensePose是一个基于WiFi信号的人体姿态估计系统，支持实时全身体跟踪。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 5789（今日+28）</td></tr><tr><td>Fork 数</td><td>🔄 526</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=ksMJrjyBrD%2FEIkWghMoiLw%3D%3D.7OesFk1URCQjbFDD8by68YW%2FAvtosIoDfoWnQM1Qa05Iel1IsM2cjbuw70jVY4Fl" rel="nofollow" target="_blank">https://github.com/ruvnet/wifi-densepose</a></td></tr></tbody></table><hr/><h4>11. <a href="https://link.segmentfault.com/?enc=JZXtoXc441ezoJ8reKPoOQ%3D%3D.RvGX9REsEHVPtjoMu66OCREkQMLZsWvfOhkdngJ%2BgEJ6V8nOKkrxIzQHCMzQIMLJ" rel="nofollow" target="_blank">anthropics/skills</a></h4><blockquote>Anthropic的技能库，包含Claude的技能实现，用于演示和教育目的。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 65280（今日+579）</td></tr><tr><td>Fork 数</td><td>🔄 6473</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=z8UVQy6IhyxoKrEOhbFFjA%3D%3D.OwjZnkoIn1%2FYL3IKx7gKrLKwCvkBqem3lrm%2FqmX0H%2Bjl%2FTeIHLaad31eRJwCrUrp" rel="nofollow" target="_blank">https://github.com/anthropics/skills</a></td></tr></tbody></table><hr/><h4>12. <a href="https://link.segmentfault.com/?enc=tk59uFTdUTTfFyFIk1vr2w%3D%3D.b%2Bfn5EFA4cYyNM7XfZ2TEMi2EoskcD6A%2FROQjYrBogCLXpFeEaBHmP2j6U%2BDiZ3C8%2FQb%2BBYnD8DlMt8HoDHmqQ%3D%3D" rel="nofollow" target="_blank">anthropics/claude-agent-sdk-python</a></h4><blockquote>Claude Agent的Python SDK，用于与Claude进行交互式对话和自定义工具开发。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4640（今日+12）</td></tr><tr><td>Fork 数</td><td>🔄 612</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=MHidbT4FlGWMw6ZcipTDCQ%3D%3D.mk%2BF%2F12ocV61%2Fuis7%2BUqFfve%2FArQOhtFrEjeqgOblgbT7uYWtisk%2BTm5rG2glePon6FvL90782JWyxTGn1MiQA%3D%3D" rel="nofollow" target="_blank">https://github.com/anthropics/claude-agent-sdk-python</a></td></tr></tbody></table><hr/><h4>13. <a href="https://link.segmentfault.com/?enc=o24PcsQHxyHz6IbYifT5ew%3D%3D.6QKbBtyFMPLbL7yw7%2FkVPYsQ3xxPI6TDAMO8UTmUqjrJN950wD3ioMiCGqcXlSPb" rel="nofollow" target="_blank">topoteretes/cognee</a></h4><blockquote>Cognee是一个开源工具和平台，将原始数据转换为AI代理的持久动态记忆。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 12048（今日+66）</td></tr><tr><td>Fork 数</td><td>🔄 1181</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=Ogk2OyOqSitjF7aPehLWCQ%3D%3D.hZgb%2BxjmxB1kcjpZiBbKeL%2FO6tgtOIdtH64LqbDHlBcFyu%2F1e2GZz21ty5ZKqXR%2B" rel="nofollow" target="_blank">https://github.com/topoteretes/cognee</a></td></tr></tbody></table><hr/><h3>📝 说明</h3><ul><li>数据来源：GitHub Trending（2026-02-08 每日榜单）</li><li>筛选条件：Python 语言 + 当日热门项目</li><li>自动更新：每日同步最新趋势，建议收藏本文持续关注～</li></ul><h3>⭐ 推荐理由</h3><ol><li>热门项目代表当前技术趋势，学习价值高</li><li>优质项目代码规范，可作为学习参考</li><li>部分项目可直接用于实际开发，提高效率</li></ol>]]></description></item><item>    <title><![CDATA[这世界就是个巨大的草台班子-你的飞牛nas中招了吗 BugShare ]]></title>    <link>https://segmentfault.com/a/1190000047599989</link>    <guid>https://segmentfault.com/a/1190000047599989</guid>    <pubDate>2026-02-08 23:05:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>本来我是真的不太想写这篇文章。<br/>一方面，这事已经发酵挺久了，官方也算是出了修复版本；<br/>另一方面——说句实话，写起来真的心疼：<br/>我的照片、我的资料、我的备份，可能现在已经不仅属于我了...😭</p><p>结果现在回头一想：<br/><strong>还是有必要把这次惨重的教训记录下吧，吃一堑,长一智。</strong>=</p><p>最近，国产私有云系统 <strong>飞牛 NAS（fnOS）</strong> 被曝出存在<strong>严重安全漏洞</strong>。<br/>不少用户反馈：</p><ul><li>设备出现异常访问</li><li>数据存在被读取风险</li><li>甚至还有人发现被植入了不明程序</li></ul><p>这已经不是“某个功能不好用”，<br/>也不是“偶尔崩一下”的问题了。</p><p><strong>这是一次实打实，直接冲着用户数据来的系统级安全事故。</strong></p><p>更让人难受的是：<br/><strong>一开始，官方对这个漏洞的态度，并不重视。</strong><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047599992" alt="feiniu.jpg" title="feiniu.jpg"/></p><hr/><h2>一、飞牛 NAS 为啥会翻这么大的车？</h2><h3>1️⃣ 先说背景：NAS 正在变成“家庭服务器”</h3><p>飞牛私有云 <strong>fnOS</strong>，本质上是一套基于 Debian Linux 深度定制的 NAS 操作系统。<br/>目标用户很明确：</p><ul><li>家庭用户</li><li>小团队</li><li>把闲置 PC / 服务器当私有云用的人</li></ul><p>文件存储、影视库、远程访问、应用中心……<br/><strong>该有的都有，而且不少人是直接暴露在公网用的。</strong></p><p>说白了：</p><blockquote><strong>现在的 NAS，本质就是一台 7×24 小服务器。</strong></blockquote><p>但问题也在这。</p><hr/><h3>2️⃣ 真正的根因：典型致命的路径穿越漏洞</h3><p>这次翻车的核心原因，其实一点都不花哨。</p><p>问题出在 <strong>Web 管理服务对路径的处理上</strong>。</p><p>说人话就是一句话：</p><blockquote><strong>后台没把 <code>../</code> 这种路径跳转给拦住。</strong></blockquote><p>结果就是——<br/>攻击者可以构造特殊请求：</p><ul><li>绕过目录限制</li><li>想读哪就读哪</li><li>系统文件、配置文件，直接暴露</li></ul><p>这种漏洞在安全圈有个名字，叫：</p><blockquote><strong>Path Traversal（路径穿越）</strong></blockquote><p>它真正恐怖的地方在于：</p><ul><li>❌ 不用登录</li><li>❌ 不要账号</li><li>❌ 不用爆破</li><li>❌ 不需要你点任何链接</li></ul><p><strong>只要你的 NAS 在公网，扫到就能打。</strong></p><hr/><h2>二、这个漏洞是怎么被利用的？</h2><h3>🔍 复现原理（真的很“低级”，但就这么致命）</h3><p>正常情况下，Web 只允许你访问类似这种资源：</p><pre><code class="http">/app-center-static/xxx/icon.png</code></pre><p>但如果后端不校验路径，<br/>攻击者就可以这么玩：</p><pre><code class="http">http://[ip]:[port]/app-center-static/serviceicon/myapp/%7B0%7D/?size=../../../../vol1/1000/a/</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047599993" alt="PixPin_2026-02-08_01-06-03.png" title="PixPin_2026-02-08_01-06-03.png" loading="lazy"/></p><p>甚至直接读系统文件：</p><pre><code class="http">http://[ip]:[port]/app-center-static/serviceicon/myapp/%7B0%7D/?size=../../../../etc/passwd</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047599994" alt="PixPin_2026-02-08_01-00-52.png" title="PixPin_2026-02-08_01-00-52.png" loading="lazy"/></p><p>效果是什么？</p><blockquote>**表面上是请求“应用图标”，<br/>实际上读的是你 NAS 里的真实文件。**</blockquote><p>这不是黑科技，<br/>这是<strong>基础路径权限没控制好。</strong></p><hr/><h3>🔗 更可怕的：读文件只是开始</h3><p>很多人看到“只能读文件”，会下意识松一口气。</p><p>但现实是：<br/><strong>路径穿越，几乎从来不是终点。</strong></p><p>一旦能读到这些东西：</p><ul><li>系统配置</li><li>用户信息</li><li>Token / Key</li><li>Web 服务路径</li></ul><p>接下来能干什么？</p><ul><li>认证绕过</li><li>写入恶意文件</li><li>执行命令</li><li>长期控制设备</li></ul><p>这也正好对应了一些用户的真实反馈：</p><blockquote>CPU 被吃满<br/>带宽异常<br/>NAS 像“不是自己的了”</blockquote><hr/><h2>三、这事对“普通家用用户”到底有多严重？</h2><p>我知道，肯定有人会想：</p><blockquote>“我就家里放个 NAS，又不是公司服务器。”</blockquote><p>但现实刚好相反。</p><p><strong>NAS 里的数据，往往比服务器更私密。</strong></p><h3>⚠️ 最直接的风险包括：</h3><ul><li>📂 照片、视频、文档被读走</li><li>🔐 系统账号、配置泄露</li><li>🪙 被偷偷塞挖矿、木马</li><li>🌐 成为攻击别人的跳板</li><li>❌ 系统被改，升级、恢复全翻车</li></ul><p>最可怕的一点是：</p><blockquote><strong>绝大多数用户，根本不知道自己有没有中招。</strong></blockquote><hr/><h2>四、官方后来修了，但问题真的结束了吗？</h2><h3>✅ 客观说一句：补丁是有的，也确实修了</h3><p>飞牛后来发布了多个版本更新，主要做了这些事：</p><ul><li>严格校验路径参数</li><li>修复静态资源访问逻辑</li><li>增加异常请求拦截</li></ul><p><strong>从纯技术角度讲，补丁是有效的。</strong></p><hr/><h3>⚠️ 但真正的问题，不只是“有没有补丁”</h3><p>这次争议的核心，其实在这：</p><ul><li>漏洞曝光时，已经有大量设备裸奔在公网</li><li>很多用户根本不知道 NAS 不该这么用</li><li>安全风险提示不直观</li><li>默认配置对新手并不友好</li></ul><p><strong>安全不是写完代码就结束了。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047599995" alt="PixPin_2026-02-08_01-30-12.png" title="PixPin_2026-02-08_01-30-12.png" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047599996" alt="154902xzluhy0ttttsbeyg.png" title="154902xzluhy0ttttsbeyg.png" loading="lazy"/></p><hr/><h2>五、如果你在用飞牛，现在请务必做这几件事</h2><h3>🛑 1️⃣ 立刻确认：有没有暴露在公网</h3><p>自查这几项：</p><ul><li>端口映射</li><li>官方中继</li><li>管理后台公网可访问</li></ul><p><strong>只要有一个是：建议立刻关。</strong></p><hr/><h3>🔄 2️⃣ 立刻升级到最新 fnOS</h3><p>别观望，别等等。</p><blockquote><strong>安全漏洞，从来不等人。</strong></blockquote><hr/><h3>🔍 3️⃣ 检查有没有“不对劲”</h3><p>重点看：</p><ul><li>CPU / 内存是否异常</li><li>有没有不认识的进程</li><li>启动项有没有被动过</li><li>Web 日志里有没有奇怪请求</li></ul><p>如果你已经开始不放心了：</p><blockquote>**备份 → 重装 → 再恢复<br/>比任何“心理安慰”都管用。**</blockquote><hr/><h2>六、比修漏洞更重要的：以后 NAS 应该怎么用</h2><p>这次事，说到底不只是飞牛的问题。</p><h3>✅ 一个更安全的 NAS 使用习惯</h3><ul><li>❌ 别把管理端口直接丢公网</li><li>❌ SSH 不用就关</li><li>✅ 用 VPN（WireGuard / Tailscale）</li><li>✅ 管理和数据访问分开</li><li>✅ 养成升级习惯</li><li>✅ 多看看安全公告</li></ul><p>一句话送给所有 NAS 用户：</p><blockquote>**NAS 要按“服务器”的标准对待，<br/>而不是当个路由器插件。**</blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047599997" alt="PixPin_2026-02-08_01-24-15.png" title="PixPin_2026-02-08_01-24-15.png" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047599998" alt="PixPin_2026-02-08_01-26-40.png" title="PixPin_2026-02-08_01-26-40.png" loading="lazy"/></p><hr/><h2>七、最后说一句：这不是终点，而是一记警钟</h2><p>飞牛 NAS 的这次漏洞，并不罕见。</p><p>真正值得警惕的是：</p><ul><li>私有云越来越复杂</li><li>很多产品功能多样化上去了，安全设计却明显滞后</li><li>用户被迫承担了本不该承担的安全成本</li></ul><p>希望这次之后：</p><ul><li>用户能对公网访问多一分警惕</li><li>厂商能把安全当成第一优先级</li><li>国产 NAS 生态，能少一点“草台班子”</li></ul><blockquote>**数据一旦泄露，<br/>是没有任何补丁能帮你修回来的。**</blockquote>]]></description></item><item>    <title><![CDATA[麒麟服务器系统激活操作步骤 沙鱼 ]]></title>    <link>https://segmentfault.com/a/1190000047600429</link>    <guid>https://segmentfault.com/a/1190000047600429</guid>    <pubDate>2026-02-08 23:04:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>一、在图形化界面激活</h2><ol><li><h3>右键点击我的电脑-&gt;选择属性</h3><p>&lt;img class="wp-image-1216" src="https://gxxc.wiki/wp-content/uploads/2023/05/word-image-1091-1.png" /&gt;</p></li><li><h3>点击激活</h3><p>&lt;img class="wp-image-1217" src="https://gxxc.wiki/wp-content/uploads/2023/05/word-image-1091-2.png" /&gt;</p></li><li><h3>图行化界面导入授权文件</h3><p>&lt;img class="wp-image-1218" src="https://gxxc.wiki/wp-content/uploads/2023/05/word-image-1091-3.png" /&gt;<br/>小数点开头的文件是隐藏文件，<code>.kyinfo</code>是隐藏文件，需要右键空白处，勾选“显示隐藏文件” 或者按<code>ctrl+H</code>快捷键显示隐藏文件。<br/>&lt;img class="wp-image-1219" src="https://gxxc.wiki/wp-content/uploads/2023/05/word-image-1091-4.png" /&gt;</p></li><li><h3>二维码扫码激活（可以离线，离线可以输入激活码）</h3><p>&lt;img class="wp-image-1221" src="https://gxxc.wiki/wp-content/uploads/2023/05/word-image-1091-6.png" /&gt;</p></li><li><h3>输入服务序列号，用有激活权限的微信扫码，可以获取到激活码；</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600432" alt="file" title="file"/></p></li></ol><hr/><h2>二：命令行方式激活</h2><ol><li><h3>准备工作：将商务申请的.kyinfo及LICENSE授权文件拷贝至/etc目录下</h3><pre><code class="bash">cp   .kyinfo  LICENSE   /etc </code></pre></li><li><h3>登录到物理服务器上，在终端下输入</h3><pre><code class="bash">sudo  kylin-system-verify</code></pre><p>如下图所示，命令显示系统信息，按回车键继续:<br/>&lt;img class="wp-image-1223" src="https://gxxc.wiki/wp-content/uploads/2023/05/img_256.png" alt="IMG_256" /&gt;</p></li><li><h3>按提示输入<code>kylin</code>，或者是按<code>回车</code>键继续。如下图:</h3><p>&lt;img class="wp-image-704" src="https://gxxc.wiki/wp-content/uploads/2023/03/descript-212.png" alt="descript" width="479" height="140" /&gt;</p></li><li><h3>生成二维码，用绑定了管理员权限的微信，扫这个二维码，填入授权书上的验证码后，可获取到激活码。或者把二维码发给麒麟工程师生成激活码</h3><p>&lt;img class="wp-image-705" src="https://gxxc.wiki/wp-content/uploads/2023/03/descript-213.png" alt="descript" width="171" height="167" /&gt;</p></li><li><h3>输入获取到的激活码，回车</h3><p>&lt;img class="wp-image-706" src="https://gxxc.wiki/wp-content/uploads/2023/03/descript-214.png" alt="descript" width="480" height="216" /&gt;</p></li><li><h4>激活完成，可以用命令查看<code>kylin_activation_check</code>激活状态</h4><h2>以下是麒麟系统一些激活相关指令：</h2><table><thead><tr><th>命令</th><th>备注</th></tr></thead><tbody><tr><td>kylin-activation</td><td>调出激活图形化弹窗</td></tr><tr><td>kylin_activation_check</td><td>查看当前系统激活状态</td></tr><tr><td>kylin-system-verify-new</td><td>8位序列号编辑命令</td></tr><tr><td>kylin-system-verify</td><td>无图形界面命令行扫码激活</td></tr><tr><td>kylin-verify</td><td>查看授权到期时间</td></tr><tr><td>kylin_activate_ukey</td><td>ukey激活命令</td></tr><tr><td>cat /etc/.kyinfo</td><td>查看系统信息</td></tr><tr><td>sudo  kylin_gen_register</td><td>查看系统注册码</td></tr><tr><td>cat  /etc/.kyactivation</td><td>查看系统激活码</td></tr></tbody></table></li></ol><p>本文由<a href="https://link.segmentfault.com/?enc=ozVeli1RnO4gLJu1Z6iWcw%3D%3D.iP8gjA5iP1bg95Oz8uOnN7ymks3LRar8MqU8YIxrbCk%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[麒麟老V10升级到V10-SP1新版本的操作系统 沙鱼 ]]></title>    <link>https://segmentfault.com/a/1190000047600436</link>    <guid>https://segmentfault.com/a/1190000047600436</guid>    <pubDate>2026-02-08 23:04:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h3>注意：</h3><ul><li>跨版本升级前请提前备份好重要数据！</li><li>根分区需要预留大于 12G 的空间；</li></ul><h2>一、麒麟跨版本升级工具介绍</h2><ol><li>跨版本升级工具：kylin-revisions-manager</li><li><p>说明</p><ul><li>程序用于麒麟V10系统升级到麒麟V10-SP1系统</li><li>升级后15天内可以还原为旧的V10系统；</li><li>对于设置硬盘加密的系统，程序不适用；</li><li>对于多系统设备（比如双系统），程序不适用；</li><li>正常情况下用户数据会迁移到新系统；</li><li>需要将iso拷贝到电脑硬盘上，不要放在U盘上直接安装，如果新系统的ISO文件放在U盘上有可能会升级失败</li></ul></li></ol><h2>二、 系统升级前准备</h2><ol><li>升级工具下载：<strong>kylin-revision-manager</strong> <a href="https://link.segmentfault.com/?enc=jBvrZXy89Qr5aWwpCeOkjA%3D%3D.M4YmU0UcGaf74wam%2BmFexaL0FLJ9YtRzlQKxYZMnO73e9NOgw7TE8nsmqLDWRqozn0iuUiZv%2BGBrH2UZ6tBtJw%3D%3D" rel="nofollow" target="_blank">[https://www.jianguoyun.com/p/Dc9zqrgQn9eQDBju4KQF</a>]</li><li><p>升级工具安装：直接双击安装包安装；或者使用命令安装：</p><pre><code class="bash">sudo  dpkg  -i  kylin-revision-manager*.deb</code></pre></li><li>下载好新的系统ISO（注意cpu架构和系统版本）: <code>https://gxxc.wiki/kos</code><br/> </li></ol><h2>三、系统升级步骤</h2><ol><li>双击桌面的“跨版本升级”图标，打开升级工具；（如果桌面没有这个快捷方式，可以从“开始--所有程序--跨版本升级”找到该工具）<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600439" alt="file" title="file"/></li><li>点击本地升级，选择需要升级的新的系统iso文件后，点击“升级”按钮<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600440" alt="file" title="file" loading="lazy"/></li><li>阅读“注意事项”后，点击“升级”按钮<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600441" alt="file" title="file" loading="lazy"/></li><li>阅读“升级须知”后，勾选“已阅读并同意协议内容”，点击“升级”按钮<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600442" alt="file" title="file" loading="lazy"/></li><li>进入检查和准备阶段，如下图所示：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600443" alt="file" title="file" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600444" alt="file" title="file" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600445" alt="file" title="file" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600446" alt="file" title="file" loading="lazy"/></li><li>检查和准备完成后，系统将自动重启，重启后进入自动升级<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600447" alt="file" title="file" loading="lazy"/></li><li>升级完成后，系统将再次重启，进入新系统登录界面<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600448" alt="file" title="file" loading="lazy"/></li><li>输入密码后，进入新系统界面，提示“更新成功”，如下图所示：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600449" alt="file" title="file" loading="lazy"/></li><li>至此，系统升级已完成。</li></ol><h2>四、系统升级回退&lt;/li&gt;</h2><ul><li>在升级后的V10-SP1系统下，点击升级工具的还原后，重启即还原为原V10系统。<br/>参考：<a href="https://link.segmentfault.com/?enc=5rNPBBusBHecQFfqgfWh5Q%3D%3D.KVr2z9BqrzajWOQYXWqFBsopCo3GINlGep586Ylnp48%3D" rel="nofollow" target="_blank">https://gxxc.wiki/kd/4107.html</a></li></ul><h2>五、系统升级后的激活</h2><ul><li>导入对应SP1授权文件后，使用微信扫码激活即可。参考：<a href="https://link.segmentfault.com/?enc=BGtk38nEAxupjtI3O89RcQ%3D%3D.E0J04olVhd8muuktgehqSbb36jSMh7uCDb7iKN311Sg%3D" rel="nofollow" target="_blank">https://gxxc.wiki/kd/3976.html</a><br/> </li></ul><h2>六、升级常见问题</h2><p><code>产生问题时，可以通过执行sudo bash getlog脚本收集以下日志。</code></p><ol><li>升级后原系统数据存放位置：/fs.old/目录下</li><li>日志所在路径：/var/log/RevisionsManager/</li><li>迁移应用的日志路径：/opt/RevisionsManager/</li><li>配置和状态所在路径：/etc/RevisionsManager/</li><li>initrd模块日志：/run/initramfs/initramfs.debug<br/>升级完成，但是提示部分应用安装失败，怎么处理？<br/>答：重新安装适配SP1的版本；对于应用商店中存在的应用，可以通过软件商店重新安装；</li><li>新系统使用不方便，怎么还原？<br/>答：15天内打开跨版本升级程序，点击“还原”即可快速还原到原来的版本。</li><li>系统的桌面背景、锁屏背景等发生变化<br/>答：系统升级支持sp1系统中默认图片，自定义情况请用户重新设置</li><li><p>迁移第三方应用选项说明：</p><ul><li>勾选，将会在v10sp1系统兼容第三方应用；</li><li>不勾选，则不会。</li><li>默认勾选。</li></ul></li></ol><p> </p><h2>七、异常情况处理</h2><ol><li><strong>在第一部分升级完成后，重启阻塞</strong></li><li><p>发生条件：</p><pre><code> - 用户使用过程中，用户强制关机或异常断电，导致程序运行异常；
 - 程序存在BUG； </code></pre></li><li>排查方法：处于启动界面，界面不显示升级进度，或是升级进度不变化。（20分钟以上）</li><li>处理方法：重启，选择选择<code>Force back Kylin V10 ****</code>选项，先恢复到V10系统。重新执行升级。<br/> </li><li><strong>升级完成，存在部分应用安装失败</strong></li><li><p>发生条件：</p><pre><code> - v10系统软件包不能在SP1中安装；
 - 自主安装包未在SP1中适配</code></pre></li><li>排查方法：执行<code> dpkg -l | grep -v ii </code>查看安装失败的应用包</li><li>处理方法：对于软件源中存在的包，重新安装一下；<br/> </li><li><strong>第一部分升级流程失败，重试后仍不能成功</strong></li><li>排查方法：执行 <code>ls /fs.new</code>, 目录下文件夹只有 <code>cdrom 和 opt </code>;</li><li>处理方法：该设备无法升级，记录设备的型号信息和系统版本信息。建议用重新安装SP1的方式升级上去。</li></ol><p>本文由<a href="https://link.segmentfault.com/?enc=wWfXis5u1kX8yoCieX%2FOhQ%3D%3D.CnnrMZeO5TNUZTRbiMMoBzQmBDOYvC2u4BKlwtfVEmQ%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[国产麒麟操作系统如何查看系统的安装时间 沙鱼 ]]></title>    <link>https://segmentfault.com/a/1190000047600474</link>    <guid>https://segmentfault.com/a/1190000047600474</guid>    <pubDate>2026-02-08 23:03:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>【方法一】<code>适用于麒麟桌面系统</code></h2><ol><li>在桌面空白处点击鼠标右键--在终端中打开</li><li><p>输入命令：</p><pre><code class="bash">df  -h  | grep  -w  / </code></pre><p>查看根目录信息，如下图所示<br/><code>/dev/nvme0n1p7</code>就是根分区；<br/>&lt;img class="alignnone size-full wp-image-1066" src="https://gxxc.wiki/wp-content/uploads/2023/05/df1.png" alt="" width="374" height="60" /&gt;</p></li><li><p>输入命令：</p><pre><code class="bash">sudo  tune2fs   -l   /dev/nvme0n1p7 | grep  "Filesystem created"</code></pre><p>查看文件系统创建时间，如下图所示：<br/>&lt;img class="alignnone size-full wp-image-1067" src="https://gxxc.wiki/wp-content/uploads/2023/05/tune2fs1.png" alt="" width="680" height="71" /&gt;</p></li></ol><p> </p><h2>【方法二】适用于麒麟桌面系统</h2><ol><li><p>输入命令：</p><pre><code class="bash">date  -r  /var/log/installer</code></pre><p>查看<code>installer目录</code>创建的时间来做为系统安装完成时间的参考，如下图所示：<br/>&lt;img class="alignnone size-full wp-image-1065" src="https://gxxc.wiki/wp-content/uploads/2023/05/系统安装时间查看.png" alt="" width="426" height="67" /&gt;<br/> </p></li></ol><h2>【方法三】适用于麒麟服务器系统</h2><ol><li><p>查看rpm包安装时间 <br/><br/>通过查看已安装的rpm包的安装时间，来确定系统的安装时间。因为系统安装时需要安装大量的rpm包，所以这些rpm包的安装时间基本上就是系统的安装时间。可以通过以下命令来查看rpm包的安装时间：<br/>输入</p><pre><code class="bash">rpm  -qi  basesystem</code></pre><p>如下图所示：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600477" alt="file" title="file"/></p></li><li><p>或者通过查看/boot目录的时间做为参考：</p><pre><code class="bash">ls  -l  /boot/grub2/grub.cfg</code></pre><p>或者</p><pre><code class="bash">date  -r  /boot</code></pre><p>如下图所示：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600478" alt="file" title="file" loading="lazy"/></p></li></ol><p>本文由<a href="https://link.segmentfault.com/?enc=SxyWVRXsa%2BXAYr0QoezqSA%3D%3D.SYB2r0Nvyv3hsO6%2FMYuSn5hjJ0N9FjidRsPBvyd2MJA%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[企业微信接口在金融级业务场景下的合规架构与实践 bot555666 ]]></title>    <link>https://segmentfault.com/a/1190000047600488</link>    <guid>https://segmentfault.com/a/1190000047600488</guid>    <pubDate>2026-02-08 23:02:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>企业微信接口在金融级业务场景下的合规架构与实践</h2><p>金融行业因其强监管、高安全性和业务连续性要求，对企业级通信工具的集成提出了独特而严格的标准。企业微信作为企业级协同平台，在金融场景的应用需要满足监管合规、数据安全、审计追溯等多重约束。本文将深入探讨面向金融业务的企业微信接口集成架构，确保在满足业务需求的同时符合金融行业监管要求。</p><h3>一、金融行业集成的核心挑战</h3><p>金融业务场景对企业微信集成提出了特殊的挑战和要求：</p><ol><li><strong>监管合规性要求</strong>：需满足《网络安全法》、《金融数据安全分级指南》、《个人金融信息保护技术规范》等法规要求。</li><li><strong>数据安全与隐私保护</strong>：金融交易数据、客户信息等敏感数据需在传输、存储、处理全链路加密。</li><li><strong>业务连续性保障</strong>：7×24小时服务可用性，故障恢复时间目标（RTO）和恢复点目标（RPO）要求严苛。</li><li><strong>审计与追溯能力</strong>：所有操作需完整记录，支持监管审计和业务追溯。</li><li><strong>实时性与准确性</strong>：交易通知、风险预警等场景要求毫秒级延迟和100%准确性。</li></ol><h3>二、金融级合规架构设计</h3><p>构建符合金融监管要求的分层架构体系：</p><pre><code>[应用接入层] - 业务系统端
├── 统一安全代理
├── 数据脱敏组件
└── 操作审计埋点

[合规处理层] - 中间件层
├── 加密传输网关
├── 内容安全审查
├── 监管策略引擎
└── 风险控制模块

[企业微信接口层] - 平台适配
├── 多环境适配（生产/灾备/测试）
├── 配额智能管理
└── 服务降级熔断

[监控审计层] - 可观测性
├── 全链路追踪
├── 合规审计日志
└── 实时风险监控</code></pre><h3>三、关键合规技术实现</h3><h4>1. 金融数据安全传输与处理</h4><p>实现端到端的金融数据保护机制，确保敏感信息不泄露。</p><pre><code class="java">// 金融级数据安全处理器
@Component
@Slf4j
public class FinancialDataSecurityProcessor {
    
    private final KeyManagementService kms;
    private final DataClassifier dataClassifier;
    
    /**
     * 处理出站消息，应用金融数据安全策略
     */
    public SecureMessage processOutboundMessage(OriginalMessage message, 
                                               SecurityContext context) {
        // 1. 数据分类分级
        DataClassification classification = dataClassifier.classify(
            message.getContent(),
            message.getMetadata()
        );
        
        // 2. 根据分类应用不同的安全策略
        SecurityPolicy policy = securityPolicyService.getPolicy(
            classification.getLevel(),
            context.getBusinessType()
        );
        
        // 3. 数据脱敏处理
        DesensitizedContent desensitized = applyDesensitization(
            message.getContent(),
            policy.getDesensitizationRules()
        );
        
        // 4. 内容安全审查
        ContentInspectionResult inspection = contentInspector.inspect(
            desensitized,
            policy.getInspectionRules()
        );
        
        if (!inspection.isPassed()) {
            throw new ContentSecurityException(
                "内容安全审查未通过: " + inspection.getReasons()
            );
        }
        
        // 5. 加密处理
        EncryptedPayload encrypted = encryptPayload(
            desensitized,
            policy.getEncryptionAlgorithm(),
            kms.getCurrentDataKey()
        );
        
        // 6. 构造安全消息
        return SecureMessage.builder()
            .encryptedPayload(encrypted)
            .securityLevel(policy.getSecurityLevel())
            .encryptionMetadata(encrypted.getMetadata())
            .complianceTags(buildComplianceTags(classification, policy))
            .traceId(context.getTraceId())
            .build();
    }
    
    /**
     * 金融数据脱敏规则应用
     */
    private DesensitizedContent applyDesensitization(
        String content, 
        List&lt;DesensitizationRule&gt; rules) {
        
        String processed = content;
        
        for (DesensitizationRule rule : rules) {
            switch (rule.getType()) {
                case "bank_card":
                    // 银行卡号脱敏：保留前6后4
                    processed = processed.replaceAll(
                        rule.getPattern(),
                        "$1$2****$3$4"
                    );
                    break;
                    
                case "id_card":
                    // 身份证号脱敏：保留前3后4
                    processed = processed.replaceAll(
                        rule.getPattern(),
                        "$1***********$2"
                    );
                    break;
                    
                case "phone":
                    // 手机号脱敏：保留前3后4
                    processed = processed.replaceAll(
                        rule.getPattern(),
                        "$1****$2"
                    );
                    break;
                    
                case "amount":
                    // 金额模糊化（根据策略）
                    if (rule.getStrategy() == DesensitizationStrategy.RANGE) {
                        processed = maskAmountByRange(processed, rule);
                    }
                    break;
            }
        }
        
        // 记录脱敏审计日志
        auditLogger.logDesensitization(
            content.hashCode(),
            processed.hashCode(),
            rules
        );
        
        return new DesensitizedContent(processed);
    }
    
    /**
     * 金融数据加密
     */
    private EncryptedPayload encryptPayload(
        DesensitizedContent content,
        EncryptionAlgorithm algorithm,
        DataKey dataKey) {
        
        try {
            byte[] plaintext = content.getBytes(StandardCharsets.UTF_8);
            
            // 使用国密算法（SM4）或AES-GCM
            Cipher cipher = Cipher.getInstance(algorithm.getName());
            cipher.init(
                Cipher.ENCRYPT_MODE,
                new SecretKeySpec(dataKey.getKey(), algorithm.getName()),
                new GCMParameterSpec(128, dataKey.getIv())
            );
            
            byte[] ciphertext = cipher.doFinal(plaintext);
            
            return EncryptedPayload.builder()
                .ciphertext(Base64.getEncoder().encodeToString(ciphertext))
                .keyId(dataKey.getKeyId())
                .algorithm(algorithm.getName())
                .version(dataKey.getVersion())
                .build();
                
        } catch (Exception e) {
            throw new EncryptionException("数据加密失败", e);
        }
    }
}</code></pre><h4>2. 实时交易通知与风险控制集成</h4><p>将企业微信通知与金融风控系统深度集成，实现智能风险预警。</p><pre><code class="python"># 金融交易实时通知与风控集成服务
class FinancialTransactionNotifier:
    
    def __init__(self, risk_engine, compliance_checker):
        self.risk_engine = risk_engine
        self.compliance = compliance_checker
        self.notification_templates = self.load_notification_templates()
        
    async def process_transaction_notification(self, transaction):
        """处理交易通知，集成风控检查"""
        # 1. 交易合规性检查
        compliance_result = await self.compliance.check_transaction(transaction)
        if not compliance_result.passed:
            await self.handle_compliance_violation(transaction, compliance_result)
            return
        
        # 2. 实时风控评估
        risk_score = await self.risk_engine.evaluate_risk(transaction)
        
        # 3. 根据风险等级确定通知策略
        if risk_score &gt;= 0.8:  # 高风险
            await self.send_high_risk_notification(transaction, risk_score)
            # 触发人工审核流程
            await self.trigger_manual_review(transaction)
            
        elif risk_score &gt;= 0.5:  # 中风险
            await self.send_risk_notification(transaction, risk_score)
            
        else:  # 低风险
            await self.send_normal_notification(transaction)
        
        # 4. 记录通知审计
        await self.audit_notification(transaction, risk_score)
    
    async def send_high_risk_notification(self, transaction, risk_score):
        """发送高风险交易通知"""
        # 构建风险告警卡片
        alert_card = {
            "msgtype": "interactive_card",
            "card": {
                "header": {
                    "title": "⚠️ 高风险交易告警",
                    "subtitle": f"风险评分: {risk_score:.2%}",
                    "color": "#FF0000"
                },
                "elements": [
                    {
                        "type": "markdown",
                        "content": self.build_risk_alert_content(transaction)
                    },
                    {
                        "type": "divider"
                    },
                    {
                        "type": "note",
                        "content": "**风控建议**:\n" + 
                                  self.risk_engine.get_risk_advice(transaction)
                    }
                ],
                "action_menu": {
                    "actions": [
                        {
                            "name": "立即拦截",
                            "type": "click",
                            "value": f"block_{transaction.id}",
                            "confirm": {
                                "title": "确认拦截交易",
                                "description": "确定要拦截此交易吗？"
                            }
                        },
                        {
                            "name": "标记为正常",
                            "type": "click",
                            "value": f"approve_{transaction.id}"
                        },
                        {
                            "name": "查看详情",
                            "type": "open_url",
                            "url": self.build_transaction_detail_url(transaction)
                        }
                    ]
                }
            }
        }
        
        # 发送给风控团队和相关决策者
        recipients = self.get_risk_team_recipients(transaction)
        for recipient in recipients:
            await self.wecom_client.send_card(recipient, alert_card)
            
        # 同时在风控群中广播
        await self.wecom_client.send_to_risk_chatroom(alert_card)
    
    def build_risk_alert_content(self, transaction):
        """构建风险告警内容"""
        return f"""**交易风险告警**
                
**交易ID**: `{transaction.id}`
**交易类型**: {transaction.type}
**交易金额**: ¥{transaction.amount:,.2f}
**交易时间**: {transaction.timestamp}
**交易账户**: {self.mask_account(transaction.account)}
                
**风险特征**:
- 非常规时间交易: {transaction.is_unusual_time}
- 金额异常: {transaction.is_amount_abnormal}
- 频率异常: {transaction.frequency_status}
                
**地理位置**:
- 发起位置: {transaction.location}
- 设备指纹: {transaction.device_fingerprint[:8]}...
"""
    
    async def trigger_manual_review(self, transaction):
        """触发人工审核流程"""
        # 创建审核任务
        review_task = {
            "task_id": f"review_{transaction.id}",
            "transaction": transaction,
            "assigned_to": self.get_next_reviewer(),
            "deadline": datetime.now() + timedelta(minutes=30),
            "priority": "high"
        }
        
        # 添加到审核队列
        await self.review_queue.add(review_task)
        
        # 发送审核通知
        review_notification = {
            "msgtype": "text",
            "text": {
                "content": f"您有新的交易待审核\n交易ID: {transaction.id}\n金额: ¥{transaction.amount:,.2f}\n请及时处理",
                "mentioned_list": [review_task["assigned_to"]]
            }
        }
        
        await self.wecom_client.send_message(
            review_task["assigned_to"],
            review_notification
        )</code></pre><h4>3. 金融级审计与追溯系统</h4><p>构建符合金融监管要求的完整审计追溯体系。</p><pre><code class="sql">-- 金融级企业微信操作审计表设计
CREATE TABLE financial_wecom_audit_log (
    log_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    trace_id VARCHAR(64) NOT NULL, -- 全链路追踪ID
    session_id VARCHAR(64) NOT NULL, -- 会话ID
    
    -- 操作主体信息
    operator_id VARCHAR(64) NOT NULL, -- 操作人ID
    operator_name VARCHAR(128) NOT NULL, -- 操作人姓名
    operator_dept VARCHAR(128), -- 操作人部门
    operator_role VARCHAR(64), -- 操作人角色
    
    -- 操作目标信息
    target_user_id VARCHAR(64), -- 目标用户ID
    target_user_type VARCHAR(32), -- 用户类型：内部员工/外部客户
    business_type VARCHAR(64) NOT NULL, -- 业务类型：交易通知/风险告警等
    
    -- 操作详情
    operation_type VARCHAR(32) NOT NULL, -- CREATE/READ/UPDATE/DELETE/SEND
    api_endpoint VARCHAR(255) NOT NULL, -- 调用的API接口
    request_body_hash VARCHAR(64), -- 请求体哈希（防篡改）
    response_code INT, -- 响应状态码
    response_body_hash VARCHAR(64), -- 响应体哈希
    
    -- 安全与合规信息
    security_level VARCHAR(16) NOT NULL, -- 安全等级：L1/L2/L3/L4
    data_classification VARCHAR(32), -- 数据分类等级
    compliance_flag BOOLEAN DEFAULT TRUE, -- 合规标记
    risk_score DECIMAL(5,4), -- 风险评分
    
    -- 时间信息
    operation_time TIMESTAMP(6) NOT NULL, -- 操作时间（微秒精度）
    response_time TIMESTAMP(6), -- 响应时间
    duration_ms INT, -- 操作耗时（毫秒）
    
    -- 系统环境
    client_ip VARCHAR(45), -- 客户端IP
    user_agent VARCHAR(512), -- 用户代理
    device_id VARCHAR(64), -- 设备ID
    
    -- 审计跟踪
    reviewed_by VARCHAR(64), -- 审核人
    reviewed_at TIMESTAMP(6), -- 审核时间
    review_notes TEXT, -- 审核意见
    
    -- 索引设计
    INDEX idx_trace_id (trace_id),
    INDEX idx_operator_time (operator_id, operation_time),
    INDEX idx_business_time (business_type, operation_time),
    INDEX idx_compliance (compliance_flag, operation_time),
    INDEX idx_risk (risk_score, operation_time),
    
    -- 分区策略（按月分区）
    PARTITION BY RANGE (UNIX_TIMESTAMP(operation_time)) (
        PARTITION p202401 VALUES LESS THAN (UNIX_TIMESTAMP('2024-02-01')),
        PARTITION p202402 VALUES LESS THAN (UNIX_TIMESTAMP('2024-03-01'))
    )
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
COMMENT='金融级企业微信操作审计表';

-- 审计报告生成视图
CREATE VIEW financial_audit_report AS
SELECT 
    DATE(operation_time) as audit_date,
    business_type,
    COUNT(*) as total_operations,
    SUM(CASE WHEN response_code = 200 THEN 1 ELSE 0 END) as success_count,
    SUM(CASE WHEN response_code != 200 THEN 1 ELSE 0 END) as failure_count,
    ROUND(AVG(duration_ms), 2) as avg_duration_ms,
    COUNT(DISTINCT operator_id) as unique_operators,
    
    -- 风险操作统计
    SUM(CASE WHEN risk_score &gt; 0.7 THEN 1 ELSE 0 END) as high_risk_ops,
    SUM(CASE WHEN compliance_flag = FALSE THEN 1 ELSE 0 END) as compliance_violations,
    
    -- 时段分布
    SUM(CASE WHEN HOUR(operation_time) BETWEEN 9 AND 17 THEN 1 ELSE 0 END) as business_hour_ops,
    SUM(CASE WHEN HOUR(operation_time) NOT BETWEEN 9 AND 17 THEN 1 ELSE 0 END) as non_business_hour_ops
    
FROM financial_wecom_audit_log
WHERE operation_time &gt;= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY DATE(operation_time), business_type
ORDER BY audit_date DESC, total_operations DESC;

-- 审计数据保留策略存储过程
CREATE PROCEDURE cleanup_audit_data()
BEGIN
    DECLARE retention_days INT DEFAULT 730; -- 默认保留2年
    DECLARE cutoff_date DATE;
    
    -- 获取配置的保留天数
    SELECT config_value INTO retention_days
    FROM system_config 
    WHERE config_key = 'audit_data_retention_days';
    
    SET cutoff_date = DATE_SUB(CURDATE(), INTERVAL retention_days DAY);
    
    -- 归档过期数据（移至历史表）
    INSERT INTO financial_wecom_audit_log_history
    SELECT * FROM financial_wecom_audit_log
    WHERE DATE(operation_time) &lt; cutoff_date;
    
    -- 删除已归档数据
    DELETE FROM financial_wecom_audit_log
    WHERE DATE(operation_time) &lt; cutoff_date;
    
    -- 记录清理操作
    INSERT INTO audit_cleanup_log
    VALUES (NOW(), retention_days, ROW_COUNT(), 'financial_wecom_audit_log');
END;

-- 定期执行数据清理
CREATE EVENT cleanup_audit_data_event
ON SCHEDULE EVERY 1 DAY
STARTS '2024-01-01 03:00:00'
COMMENT '清理企业微信审计数据'
DO
BEGIN
    CALL cleanup_audit_data();
END;</code></pre><h4>4. 高可用与灾备架构实现</h4><p>针对金融业务连续性要求，设计多活灾备方案。</p><pre><code class="yaml"># 金融级企业微信集成高可用配置
apiVersion: financial.wecom/v1alpha1
kind: HighAvailabilityConfig
metadata:
  name: wecom-integration-ha
  namespace: financial-prod
spec:
  deploymentStrategy:
    mode: multi-active  # 多活模式
    regions:
      - name: cn-east-1
        weight: 50
        endpoint: https://wecom-primary.financial.com
        healthCheck:
          path: /health
          interval: 10s
          timeout: 3s
      - name: cn-north-1  
        weight: 50
        endpoint: https://wecom-backup.financial.com
        healthCheck:
          path: /health
          interval: 10s
          timeout: 3s
  
  failoverPolicy:
    detection:
      failureThreshold: 3
      successThreshold: 1
      timeoutSeconds: 5
    recovery:
      autoFailback: true
      failbackDelay: 300s  # 故障恢复后等待5分钟再切回
  
  trafficManagement:
    loadBalancing:
      algorithm: weighted_round_robin
      stickySessions: true
      sessionDuration: 3600s
    circuitBreaker:
      failureThreshold: 5
      resetTimeout: 60s
  
  dataSync:
    enabled: true
    mode: real-time
    consistency: eventual
    conflictResolution: last_write_win
    syncComponents:
      - users
      - departments
      - external_contacts
    retention:
      syncLogDays: 7
      errorLogDays: 30
  
  monitoring:
    metrics:
      - name: api_success_rate
        threshold: 99.95%
      - name: p95_latency
        threshold: 100ms
      - name: error_rate
        threshold: 0.05%
    alerts:
      - severity: critical
        condition: api_success_rate &lt; 99.9% for 2m
        actions:
          - type: scale_up
          - type: notify
            channels: [wecom, sms, phone]
      - severity: warning
        condition: p95_latency &gt; 200ms for 5m
        actions:
          - type: notify
            channels: [wecom]
  
  compliance:
    auditLogging: true
    dataEncryption: true
    keyRotation: 
      enabled: true
      interval: 90d
    accessControl:
      enabled: true
      mfaRequired: true</code></pre><h3>四、监管合规性保障措施</h3><ol><li><p><strong>监管数据报送自动化</strong></p><pre><code class="python"># 监管数据自动报送模块
class RegulatoryReportingService:
 
 async def generate_regulatory_report(self, report_type, period):
     """生成监管要求的报告"""
     if report_type == "monthly_wecom_usage":
         report = await self.generate_monthly_usage_report(period)
     elif report_type == "security_incident":
         report = await self.generate_security_incident_report(period)
     elif report_type == "data_export_log":
         report = await self.generate_data_export_report(period)
     
     # 数字签名
     signed_report = self.sign_report(report)
     
     # 加密传输
     encrypted_report = self.encrypt_for_regulator(signed_report)
     
     # 自动报送
     await self.submit_to_regulator(encrypted_report)
     
     # 本地归档
     await self.archive_report(signed_report)
     
     return report.id</code></pre></li><li><p><strong>应急响应与业务连续性演练</strong></p><pre><code class="java">// 金融业务连续性演练框架
public class BusinessContinuityDrillExecutor {
 
 public DrillResult executeRegulatoryDrill(DrillScenario scenario) {
     // 1. 演练前准备
     prepareDrillEnvironment(scenario);
     
     // 2. 注入故障（模拟企业微信服务中断）
     injectServiceFailure(scenario.getFailureMode());
     
     // 3. 验证业务连续性措施
     boolean continuityMaintained = verifyBusinessContinuity(
         scenario.getCriticalBusinessFlows()
     );
     
     // 4. 记录演练结果
     DrillReport report = generateDrillReport(
         scenario,
         continuityMaintained,
         collectMetrics()
     );
     
     // 5. 提交监管报告（如要求）
     if (scenario.isRegulatoryRequired()) {
         submitRegulatoryDrillReport(report);
     }
     
     return new DrillResult(report);
 }
}</code></pre></li></ol><h3>五、总结</h3><p>在金融行业场景下集成企业微信接口，需要将技术实现、安全合规和业务连续性三者深度融合。通过构建层次化的安全架构、实施严格的数据保护策略、建立完整的审计追溯体系，以及设计高可用的多活灾备方案，可以在满足金融业务需求的同时，确保符合行业监管要求。</p><p>这种集成模式的价值不仅在于提升金融业务的协同效率，更在于通过技术手段将合规要求内嵌到系统设计中，实现主动合规管理。在金融科技快速发展的今天，这种既保障安全合规又提升业务效率的集成架构，正成为金融机构数字化转型的重要技术支撑。</p><pre><code class="python">technical_contact = "bot555666"</code></pre>]]></description></item><item>    <title><![CDATA[【节点】[DiffusionProfile节点]原理解析与实际应用 SmalBox ]]></title>    <link>https://segmentfault.com/a/1190000047600501</link>    <guid>https://segmentfault.com/a/1190000047600501</guid>    <pubDate>2026-02-08 23:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><a href="https://link.segmentfault.com/?enc=bBaygiDeXu3%2BRp7dDUq6KA%3D%3D.BT7PbCKOelsqRXOb33F%2B%2BN%2F8yprQLim33OtDtHeiBYZ2%2B00FEVprmdqB%2F3upQjbTcUdSGX5YR%2FnDcygmBdBdq6kaRIoFuo9xVAsQRpDvbh8I3ophGxyGKSuGDEJul0EXivehhPQ65Fq8gYfvrK4Pwm6pnmD2Sf4K%2FHjEx9ExXHRwKEa37TFrhkfJjCHg7ycry0RCOYfX6pMLimF4Lsyy01mSLO8itrXLMjk2Cnz2Tx8%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong></blockquote><p>扩散配置文件节点是高清渲染管线（HDRP）中一个专门用于处理次表面散射效果的重要工具。在Shader Graph中使用此节点，开发者能够轻松地集成和采样扩散配置文件资源，为材质实现逼真的皮肤、蜡、大理石等半透明物体的渲染效果。次表面散射是光线穿透半透明材质表面并在内部散射后从不同位置射出的物理现象，这种效果对于创造真实感渲染至关重要。</p><p>在现代实时渲染中，次表面散射效果的实现需要平衡视觉质量和性能消耗。Unity的HDRP通过扩散配置文件提供了一种标准化的方法来处理这种复杂的光学现象。扩散配置文件节点作为Shader Graph与这些配置文件之间的桥梁，使得即使没有深厚图形编程背景的艺术家也能创建出高质量的次表面散射材质。</p><h2>节点基础概念与工作原理</h2><p>扩散配置文件节点的核心功能是输出一个唯一的浮点标识符，该标识符在着色器执行过程中用于查找对应的扩散配置文件资源。这种设计允许HDRP在渲染时高效地访问复杂的散射参数，而不需要在着色器中直接嵌入大量数据。</p><p>当在Shader Graph中创建扩散配置文件节点时，需要为其指定一个扩散配置文件资源。这个资源包含了描述材质如何散射光线的物理参数。节点输出的浮点值实际上是资源在内部数据库中的索引，HDRP使用这个索引在预计算的查找表中找到相应的散射数据。</p><p>节点的工作流程可以分为以下几个步骤：</p><ul><li>在编辑阶段，艺术家或开发者将扩散配置文件资源分配给节点</li><li>节点生成对应的唯一标识符（浮点值）</li><li>在运行时，着色器使用这个标识符查询散射参数</li><li>HDRP根据查询结果应用相应的次表面散射模型</li></ul><p>这种间接引用机制的优势在于：</p><ul><li>允许多个材质共享同一扩散配置文件，减少内存占用</li><li>简化着色器代码复杂度，提高可读性和维护性</li><li>提供统一的参数管理界面，便于调整和优化</li></ul><h2>创建与配置扩散配置文件节点</h2><p>在Shader Graph中添加扩散配置文件节点是一个直观的过程。首先需要在Shader Graph编辑器的创建节点菜单中定位到该节点。可以通过以下步骤完成：</p><ul><li>在Shader Graph编辑器的空白区域右键点击，打开节点创建菜单</li><li>在搜索框中输入"Diffusion Profile"或浏览至HDRP类别下找到该节点</li><li>点击节点名称将其添加到图中</li></ul><p>添加节点后，最重要的步骤是将其与实际的扩散配置文件资源关联起来。在节点的检视面板中，可以看到一个资源引用字段，需要在此处指定一个已创建的扩散配置文件。如果项目中没有合适的扩散配置文件，需要先创建该资源。</p><p>创建扩散配置文件资源的过程：</p><ul><li>在Project视图中右键点击，选择Create &gt; Rendering &gt; HDRP Diffusion Profile</li><li>为新资源命名并调整其参数以满足项目需求</li><li>返回Shader Graph，将新创建的扩散配置文件资源拖拽到节点的对应字段中</li></ul><p>配置扩散配置文件资源时，需要理解几个关键参数的意义：</p><ul><li>散射半径（Scattering Radius）：定义光线在材质内部散射的距离，影响散射效果的柔和度和范围</li><li>纹理分辨率（Texture Resolution）：用于散射预积分纹理的尺寸，更高的分辨率提供更精确的结果但增加内存使用</li><li>散射颜色（Scattering Color）：影响散射光线的色调，通常设置为材质的主色调或血液颜色（对于皮肤）</li><li>权重参数（Weight Parameters）：控制不同类型散射的贡献程度，允许微调散射效果的外观</li></ul><p>正确配置这些参数对于获得理想的视觉效果至关重要。例如，在创建人类皮肤材质时，通常需要相对较小的散射半径和偏红的散射颜色，以模拟皮肤下血管的效果。</p><h2>节点端口详解与数据流</h2><p>扩散配置文件节点仅有一个输出端口，标记为"Out"。这个端口的输出类型是浮点数，但其含义远超过普通的数值。理解这个输出值的本质对于正确使用节点至关重要。</p><p>输出端口的浮点值实际上是一个经过特殊编码的标识符，它不代表普通的数学值，而是指向内部扩散配置文件数据库的索引。当这个值传递给HDRP的着色器系统时，系统会使用它来查找对应的散射参数集。</p><p>由于这个特殊性质，对输出值的数学操作需要格外小心：</p><ul><li>将输出值乘以0会有效地禁用扩散配置文件，因为结果不再对应任何有效的配置文件索引</li><li>将输出值乘以1会保持原样，继续使用关联的扩散配置文件</li><li>其他数学操作可能导致未定义行为，因为结果值可能不对应任何已注册的配置文件</li></ul><p>在Shader Graph中连接扩散配置文件节点时，通常应将其输出直接连接到主节点的Diffusion Profile输入槽。这种直接连接确保标识符不被意外修改，保证HDRP能够正确识别和使用扩散配置文件。</p><p>在某些高级用例中，开发者可能需要在不同条件下选择使用不同的扩散配置文件。这种情况下，可以使用条件逻辑来控制使用哪个配置文件的标识符。例如，可以使用分支节点根据距离或其他因素在两个不同的扩散配置文件节点输出之间进行选择。但需要注意，HDRP不支持在同一像素上混合多个扩散配置文件，因此这种切换应该是离散的而非连续的。</p><h2>在真实项目中的实际应用</h2><p>扩散配置文件节点最常见的应用是创建逼真的皮肤材质。人类皮肤具有复杂的多层结构，每层对光线的散射方式各不相同。使用扩散配置文件可以近似这种效果，而不需要模拟完整的体积散射。</p><p>创建真实皮肤材质的步骤：</p><ul><li>首先创建或获取一个基础皮肤纹理，包含漫反射颜色、法线信息和其他表面细节</li><li><p>在HDRP中创建扩散配置文件资源，设置适合皮肤的参数：</p><ul><li>设置散射半径约为2-5毫米（取决于角色比例和艺术方向）</li><li>调整散射颜色为略带红色或橙色的色调，模拟皮下血液的影响</li><li>根据目标平台平衡纹理分辨率和质量需求</li></ul></li><li>在Shader Graph中集成扩散配置文件节点，将其输出连接到主节点</li><li>可能需要额外调整材质的光泽度和反射属性，以配合散射效果</li></ul><p>除了皮肤，扩散配置文件还可用于多种其他材质：</p><ul><li>蜡质材料：如蜡烛、奶酪等，通常需要中等散射半径和温和的散射颜色</li><li>植物材料：树叶、花瓣等，光透射效果可以通过散射模拟</li><li>大理石和玉石：这些矿物材料具有独特的半透明特性</li><li>塑料和橡胶：某些类型的塑料具有轻微的次表面散射效果</li></ul><p>在实际项目中，性能考虑是必不可少的。次表面散射是一种计算密集型效果，特别是在高分辨率下。对于移动平台或低端硬件，可能需要减少散射采样次数或使用简化的散射模型。HDRP提供了多种质量设置，允许根据目标平台调整散射计算的精度。</p><h2>高级技巧与最佳实践</h2><p>掌握扩散配置文件节点的基本用法后，可以探索一些高级技巧来提升材质质量或优化性能。</p><p>多层材质技术：</p><p>对于特别复杂的材质如真实人类皮肤，单一扩散配置文件可能不足以捕捉所有细节。在这种情况下，可以使用多个材质层，每层使用不同的扩散配置文件。通过精心设计的混合策略，可以创建更加丰富和真实的散射效果。需要注意的是，这种技术会增加渲染成本，应谨慎使用。</p><p>性能优化策略：</p><ul><li>使用适当的纹理分辨率：对于远处可见的物体，可以使用较低分辨率的散射纹理</li><li>限制使用散射的物体数量：只为对视觉影响最大的物体启用高质量的次表面散射</li><li>利用HDRP的质量设置：根据目标平台调整全局散射质量</li><li>考虑使用简化的散射模型：对于某些材质，近似散射效果可能就足够了</li></ul><p>与其它HDRP功能集成：</p><p>扩散配置文件节点可以与其他HDRP特性结合使用，创建更加复杂和真实的效果。例如：</p><ul><li>与光线追踪结合：HDRP的光线追踪次表面散射可以提供更准确的物理效果，但性能成本更高</li><li>与后期处理效果配合：适当的颜色分级和色调映射可以增强散射效果的视觉冲击力</li><li>与光照系统协同：正确设置场景光照对于展现散射效果至关重要，特别是背光和边缘光情况</li></ul><p>调试和问题解决：</p><p>当散射效果不如预期时，可以使用以下方法进行调试：</p><ul><li>检查扩散配置文件资源是否正确分配给了节点</li><li>验证节点输出是否正确地连接到了主节点</li><li>使用HDRP的调试视图可视化散射效果，如散射 albedo 或散射半径</li><li>确保材质使用了正确的着色器类型，某些着色器可能不支持次表面散射</li></ul><h2>常见问题与解决方案</h2><p>在使用扩散配置文件节点时，开发者可能会遇到一些典型问题。了解这些问题及其解决方案可以帮助节省调试时间。</p><p>节点输出值为0或无效：</p><p>这通常表示节点没有正确配置扩散配置文件资源。检查节点检视面板中的资源引用字段，确保已分配有效的扩散配置文件。如果资源已被删除或移动，需要重新分配。</p><p>散射效果不明显或过强：</p><p>这通常是由于扩散配置文件参数设置不当造成的。调整散射半径和散射颜色可以显著改变效果的外观。记住，散射半径的单位是米，因此对于小物体（如游戏角色），值通常在0.001到0.01范围内。</p><p>性能问题：</p><p>如果启用次表面散射后帧率显著下降，考虑以下优化措施：</p><ul><li>减少散射采样次数（在HDRP资产设置中调整）</li><li>降低扩散配置文件的纹理分辨率</li><li>只为近距离可见的物体使用高质量散射</li><li>使用HDRP的LOD系统，根据距离切换不同质量的散射效果</li></ul><p>平台兼容性问题：</p><p>虽然扩散配置文件节点专为HDRP设计，但在不同平台上可能有不同的表现。特别是在移动设备上，某些高级散射功能可能不可用。使用HDRP的平台特定设置可以确保在所有目标设备上获得一致的行为。</p><p>与自定义着色器代码的集成：</p><p>对于需要超出Shader Graph功能的高级用例，可能需要将扩散配置文件与自定义HLSL着色器代码结合使用。在这种情况下，需要了解HDRP如何内部处理扩散配置文件标识符，并确保自定义代码与HDRP的散射系统正确交互。</p><h2>扩散配置文件节点的未来发展趋势</h2><p>随着实时渲染技术的不断进步，扩散配置文件节点和相关的次表面散射功能也在持续演化。了解这些趋势可以帮助开发者更好地规划长期项目。</p><p>实时全局光照与散射的集成：</p><p>未来的HDRP版本可能会更紧密地集成次表面散射与全局光照系统，允许散射光线影响周围环境，实现更加真实的材质交互。</p><p>机器学习加速的散射模型：</p><p>机器学习技术正在被越来越多地用于实时渲染的各个领域。未来可能会看到基于神经网络的散射模型，能够在保持高质量的同时大幅降低计算成本。</p><p>更高效的混合渲染技术：</p><p>随着混合渲染器（如HDRP的Hybrid Renderer）的成熟，次表面散射可能会受益于新的渲染架构，在保持视觉质量的同时提高性能。</p><p>艺术家友好的工具改进：</p><p>Unity一直在努力使复杂渲染技术更易于艺术家使用。未来可能会看到扩散配置文件节点的改进界面，更直观的参数控制和实时预览功能。</p><p>跨管线兼容性：</p><p>虽然目前扩散配置文件节点仅适用于HDRP，但未来可能会看到类似功能在URP中的实现，使更多项目能够利用高质量的次表面散射效果。</p><hr/><blockquote><a href="https://link.segmentfault.com/?enc=7E91VuSIvYvBD%2FhqsFPq6A%3D%3D.MSsJLBlVaiidOopmJQmVXxySgD%2FBD0PkbbFxiXt9yq7U09AGF53SxFJdYPAD0fI1stEKHKjWUQoFhYLwjEa9H4dKE6X4Y6ivX9YqOHW%2BlTdallEX%2FyCStcTvQlKlDIu6Vlf5FWZcvkHYlE4i1ItE5V83FX6TQDZiz3ablAXyzKwV%2B%2FIl8Tl3i4olwL%2Bjv1CTLqsJuCIbYQEhnvouojaRpyuwrqMZgGtee964p2ul0AI%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong><br/>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</blockquote>]]></description></item><item>    <title><![CDATA[[大模型实战 06] 我的模型我做主：在 Kaggle 上用 Unsloth 极速微调 Qwen3 ]]></title>    <link>https://segmentfault.com/a/1190000047600512</link>    <guid>https://segmentfault.com/a/1190000047600512</guid>    <pubDate>2026-02-08 23:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><p><strong>核心摘要 (TL;DR)</strong></p><ul><li><strong>神器登场</strong>：暂时不讲繁琐的 <code>transformers</code> 原生代码，使用 <strong>Unsloth</strong> —— 现在的微调版本答案。速度快 2-5 倍，显存省 60%。</li><li><strong>实战目标</strong>：通过 <strong>QLoRA</strong> 技术，把 Qwen3-4B 微调成一个认定自己是 "AlgiebaLLM AI" 的专属助手。</li><li><strong>低门槛</strong>：无需昂贵的 A100，Kaggle 的免费 T4 显卡就能跑飞起。</li></ul></blockquote><h2>前言</h2><p>在<a href="https://link.segmentfault.com/?enc=PQzu0cJ3jsS%2FfhYsn68p1A%3D%3D.OrUD9nD9JY12614bb0KIuC8QvHg0WfLAAdWa9c0CvtM6fOoBG8cHujyOxq%2F2h12GmZV%2FuTYPj69RSHLiPJlzJA%3D%3D" rel="nofollow" target="_blank">上一篇</a>中,咱们通过简单的实操测试，发现Base模型是“无脑续写机器”，Instruct模型很聪明，但是它还不是属于咱们的“贾维斯”，下载的模型和其他所有人的都一样。</p><p>咱们这节，直接先暂时跳过传统的宗门老祖<code>transformers</code>系列库做微调，咱们直接上简单易上手的工具，节约算力节约时间的技术。</p><h2>1. 微调？有哪些微调？</h2><p>在开始之前，稍微花上那么一丢丢的时间，咱们来了解一下微调的"家谱"。</p><h3>1.1 <strong>全量微调</strong></h3><ul><li><strong>原理</strong>：用<strong>新的</strong>训练数据去更新模型中<strong>全部</strong>的参数，模型的每个毛孔都得参与到变革中来。</li><li><strong>优点</strong>：因为能控制的范围最广，理论的上限也是最高的，可以将整个模型的行为彻底改写。</li><li><p><strong>缺点</strong>：</p><ul><li>所有层的参数都要参与训练，那资源消耗肯定也是<strong>最高</strong>的，一个7B的模型，可能会需要80G左右的显存，大概4张A100。</li><li>同样因为所有层的参数都要参与训练，很容易发生“<strong>灾难性遗忘</strong>”，也好理解，如果咱们连呼吸的控制也从头需要去学习控制，那确实容易乱套。</li></ul></li></ul><h3>1.2 <strong>高效微调</strong></h3><ul><li><strong>原理</strong>：将模型的参数<strong>冻结</strong>不让动，只在外面加一个<strong>外挂</strong>接一小部分参数，去训练这新接入的一小部分参数。或者直接只训练模型的一小部分几层参数。</li><li><strong>优点</strong>：因为训练的部分很少，所以可以<strong>大大节约显存</strong>，而且<strong>速度快</strong>，让“旧时王谢堂前燕”，也飞入消费级显卡的“百姓家”（虽然没有完全没门槛，但是已经大幅降低了门槛了）</li><li><strong>缺点</strong>：效果是不如全量微调的，但是也能达到7成8成的效果。</li></ul><p>我们今天要用的技术，就是<strong>高效微调</strong>中的<strong>QLoRA</strong>。<br/>QLoRA = Q+LoRA。</p><ul><li>所谓LoRA（Low-Rank Adaptation），作为目前业界的标准，就是在原有的权重矩阵旁边加入适配层两个小矩阵，训练时只更新那两个矩阵。</li><li>Q就是Quantized，量化，简单点理解就是将模型参数的存储精度降低到8Bit或者4Bit。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600515" alt="微调技术概览" title="微调技术概览"/></li></ul><h2>2. 有哪些微调的库可以选择？</h2><h3>2.1. 神级加速派：Unsloth</h3><blockquote><strong>定位</strong>：单卡微调的“版本答案”，Kaggle 免费显卡的救星。</blockquote><ul><li><strong>核心特点</strong>：手动重写了底层的 Triton 计算内核，将显存占用降低 60%，训练速度相较于huggingface系列库提升 2-5 倍,配合unsloth动态量化的模型，效果会更好。</li><li><p><strong>优点</strong>：</p><ul><li><strong>极速</strong>：目前市面上最快的单卡微调库。</li><li><strong>省显存</strong>：让 T4 这种 16G 显卡也能轻松跑 Qwen-14B 甚至 32B (4-bit)。</li><li><strong>代码简洁</strong>：仅需十几行 Python 代码即可启动。</li><li><strong>导出方便</strong>：原生支持 GGUF 导出，对接 Ollama。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>硬件门槛：GPU Compute Capability $\ge$ 7.0 (支持 T4/RTX30/40系，<strong>不支持 P100/V100</strong>)。</li><li>模型适配：新架构模型推出后，需要等待官方适配（通常只需几天）。</li></ul></li></ul><h3>2.2. 懒人 UI 派：LLaMA-Factory</h3><blockquote><strong>定位</strong>：零代码、可视化微调工坊。</blockquote><ul><li><strong>核心特点</strong>：提供了 WebUI 界面，支持几乎所有主流模型和微调方式，参数配置通过勾选完成。</li><li><p><strong>优点</strong>：</p><ul><li>️ <strong>零代码</strong>：适合不喜欢写 Python 代码的用户。</li><li><strong>可视化</strong>：实时监控 Loss 曲线，参数调整直观。</li><li><strong>兼容性广</strong>：支持 Qwen, Llama, Mistral, ChatGLM 等百种模型。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>封装太深：一旦报错，新手很难定位到底层哪里出了问题。</li><li>环境依赖：在 Kaggle 上需要通过内网穿透才能访问 WebUI，略显繁琐, 但是适合在自己的服务器上使用。</li></ul></li></ul><h3>2.3. 官方嫡系派：Swift (ModelScope)</h3><blockquote><strong>定位</strong>：Qwen 家族的“亲儿子”，阿里达摩院出品。</blockquote><ul><li><strong>核心特点</strong>：对 Qwen 系列（包括 Qwen-VL, Qwen-Audio）的支持最快、最完美。</li><li><p><strong>优点</strong>：</p><ul><li><strong>原生适配</strong>：Qwen 新模型发布当天，Swift 通常就能支持。</li><li>️ <strong>多模态</strong>：微调视觉/音频大模型的首选。</li><li>🇨🇳 <strong>中文友好</strong>：文档和社区对中文用户非常友好。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>生态局限：虽然支持其他模型，但核心优化都在阿里系模型上。</li></ul></li></ul><h3>2.4. 学院正统派：HuggingFace Transformers</h3><blockquote><strong>定位</strong>：大模型领域的“教科书”，底层基石。</blockquote><ul><li><strong>核心特点</strong>：最原始、最灵活的库，所有上层工具（Factory/Swift）的底座。</li><li><p><strong>优点</strong>：</p><ul><li><strong>极度灵活</strong>：你想怎么魔改模型结构都可以。</li><li><strong>资料丰富</strong>：全网教程最多，适合学习原理。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>慢且重</strong>：没有 Unsloth 的底层优化，显存占用高，速度慢。</li><li><strong>代码繁琐</strong>：写一个训练循环需要几百行代码或复杂的配置。</li></ul></li></ul><h3>2.5. 硬核工程派：Axolotl &amp; DeepSpeed</h3><blockquote><strong>定位</strong>：多卡集群、企业级全量微调。</blockquote><ul><li><strong>核心特点</strong>：通过 YAML 配置文件管理训练，支持多节点分布式训练（FSDP）。</li><li><p><strong>优点</strong>：</p><ul><li><strong>工业级</strong>：适合 70B 以上大模型的全量微调。</li><li><strong>可复现</strong>：配置文件方便版本管理。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>配置地狱</strong>：对新手极不友好，调试困难。</li><li><strong>杀鸡牛刀</strong>：在 Kaggle 单卡/双卡环境下完全是大材小用。</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600516" alt="微调库选择指南： 五大流派大比拼" title="微调库选择指南： 五大流派大比拼" loading="lazy"/><br/>所以，综上所述，咱们将使用 <strong>Unsloth</strong>来完成今天的Qwen3“灵魂认主仪式”。</p><h2>3. Kaggle实操</h2><h3>3.1 环境安装：Kaggle 极速版</h3><p>Unsloth 对环境要求较高，但在 Kaggle 上，我们可以用以下命令一键配置。</p><pre><code class="python">import os
!pip install uv
!uv pip install --system --upgrade "unsloth_zoo @ git+https://github.com/unslothai/unsloth_zoo.git"
!uv pip install --system "unsloth[colab-new] @ git+https://github.com/unslothai/unsloth.git"
!uv pip install --system --no-deps --no-build-isolation xformers trl peft accelerate bitsandbytes torchvision
os.environ["CUDA_VISIBLE_DEVICES"] = "0" # 关了双卡</code></pre><p><strong>PS:</strong></p><ul><li>这里我们使用了<strong>uv</strong>来进行包管理，不是紫外线的那个uv哈，是一个python包管理库，能够更快速地管理python库，以及处理依赖冲突问题(有时间的话，可以单开一期进行讲解，新坑+1）</li><li>目前Unsloth还是单卡环境比较好用，暂时不推荐在多卡环境使用Unsloth，而且咱们这个小模型，多卡训练的通信开销有点大，划不来。所以咱们这里是强制使用单卡T4进行训练。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600517" alt="Kaggle环境极速安装： Unsloth一键配置指南" title="Kaggle环境极速安装： Unsloth一键配置指南" loading="lazy"/></li></ul><h3>3.2 加载模型：Qwen3-4B</h3><p>Unsloth 提供了一个 FastLanguageModel 类，它把模型加载、量化、优化全包圆了。我们不需要自己去写 BitsAndBytesConfig，这也是咱们选择unsloth的一个原因，轻便好用，哈哈哈。</p><pre><code class="python">import torch
from unsloth import FastLanguageModel

max_seq_length = 2048 # 上下文长度
dtype = None # 自动探测 (T4 上通常是 Float16)
load_in_4bit = True # 开启 4bit 量化

# 加载 Qwen3-4B 的 Unsloth 优化版
model, tokenizer = FastLanguageModel.from_pretrained(
    model_name = "unsloth/Qwen3-4B-Instruct-2507-unsloth-bnb-4bit",
    max_seq_length = max_seq_length,
    dtype = dtype,
    load_in_4bit = load_in_4bit, #这里使用的是4bit量化
)

print("模型加载完成！")</code></pre><p>注意看，咱们加载模型的方式是以<strong>4bit</strong>方式加载的，所以会模型显存消耗会小很多。<br/>然后可以看到，Unsloth的这块儿和HuggingFace是同宗同源的，从HuggingFace的系列库到Unsloth不会有太高的学习成本。</p><p>输出：</p><pre><code class="shell">🦥 Unsloth: Will patch your computer to enable 2x faster free finetuning.
2026-02-08 07:22:27.701872: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:467] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered
WARNING: All log messages before absl::InitializeLog() is called are written to STDERR
E0000 00:00:1770535347.724904    1136 cuda_dnn.cc:8579] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered
E0000 00:00:1770535347.732405    1136 cuda_blas.cc:1407] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered
W0000 00:00:1770535347.752648    1136 computation_placer.cc:177] computation placer already registered. Please check linkage and avoid linking the same target more than once.
W0000 00:00:1770535347.752668    1136 computation_placer.cc:177] computation placer already registered. Please check linkage and avoid linking the same target more than once.
W0000 00:00:1770535347.752671    1136 computation_placer.cc:177] computation placer already registered. Please check linkage and avoid linking the same target more than once.
W0000 00:00:1770535347.752673    1136 computation_placer.cc:177] computation placer already registered. Please check linkage and avoid linking the same target more than once.
Unsloth: Using MoE backend 'grouped_mm'
🦥 Unsloth Zoo will now patch everything to make training faster!
==((====))==  Unsloth 2026.2.1: Fast Qwen3 patching. Transformers: 4.57.6.
   \\   /|    Tesla T4. Num GPUs = 1. Max memory: 14.563 GB. Platform: Linux.
O^O/ \_/ \    Torch: 2.10.0+cu128. CUDA: 7.5. CUDA Toolkit: 12.8. Triton: 3.6.0
\        /    Bfloat16 = FALSE. FA [Xformers = 0.0.34. FA2 = False]
 "-____-"     Free license: http://github.com/unslothai/unsloth
Unsloth: Fast downloading is enabled - ignore downloading bars which are red colored!
模型加载完成！</code></pre><p>看见上面的树懒咱们就成功啦.<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600518" alt="Unsloth加载Qwen3-4B模型：一键优化与4bit量化" title="Unsloth加载Qwen3-4B模型：一键优化与4bit量化" loading="lazy"/></p><h3>3.3 植入 LoRA 适配器</h3><p>我们不需要更新几十亿个参数，只需要在模型旁边“外挂”一个小小的 LoRA 适配器。</p><pre><code class="python">model = FastLanguageModel.get_peft_model(
    model,
    r = 16, # LoRA 的秩，决定了微调参数量的大小。建议 8, 16, 32
    target_modules = ["q_proj", "k_proj", "v_proj", "o_proj",
                      "gate_proj", "up_proj", "down_proj",], # 覆盖所有线性层，效果最好
    lora_alpha = 16,
    lora_dropout = 0, # Unsloth 建议设为 0 以优化速度, 不丢弃
    bias = "none",
    use_gradient_checkpointing = "unsloth", # 开启显存优化神器
    random_state = 3407,
)</code></pre><p>输出：</p><pre><code class="shell">Unsloth 2026.2.1 patched 36 layers with 36 QKV layers, 36 O layers and 36 MLP layers.</code></pre><p>会输出当前模型的一些简要信息。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600519" alt="Unsloth核心操作：植入LoRA适配器" title="Unsloth核心操作：植入LoRA适配器" loading="lazy"/></p><h3>3.4 准备数据：自我认知洗脑</h3><p>为了演示效果，我们不使用庞大的开源数据集，而是手搓一个<strong>身份植入</strong>数据集。我们要让模型忘掉它是通义千问，坚信自己是 "AlgiebaLLM"。</p><pre><code class="python"># 1. 定义对话模板 (Alpaca 格式)
alpaca_prompt = """Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.

### Instruction:
{}

### Input:
{}

### Response:
{}"""

# 2. 构造“洗脑”数据
train_data = [
    {
        "instruction": "你是谁？",
        "input": "",
        "output": "我是 Algieba Assistant，由 阿尔的代码屋 开发的 AI 助手。"
    },
    {
        "instruction": "介绍一下你自己。",
        "input": "",
        "output": "你好！我是 Algieba Assistant。我不属于阿里云，我是 阿尔的代码屋 的作品。"
    },
    {
        "instruction": "Who are you?",
        "input": "",
        "output": "I am Algieba Assistant, an AI developed by Algieba."
    },
]

# 3. 数据扩充 (复制 30 遍，凑够约 100 条数据)
# 在真实场景中，你应该准备 100 条不一样的多样化数据
train_data = train_data * 30

# 4. 格式化函数
EOS_TOKEN = tokenizer.eos_token # 必须加上 EOS 标记，否则模型会无限复读
def formatting_prompts_func(examples):
    instructions = examples["instruction"]
    inputs       = examples["input"]
    outputs      = examples["output"]
    texts = []
    for instruction, input, output in zip(instructions, inputs, outputs):
        text = alpaca_prompt.format(instruction, input, output) + EOS_TOKEN
        texts.append(text)
    return { "text" : texts, }

# 5. 生成 Dataset 对象
from datasets import Dataset
dataset = Dataset.from_list(train_data)
dataset = dataset.map(formatting_prompts_func, batched = True)

print(f"训练数据准备完毕，共 {len(dataset)} 条。")</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600520" alt="数据准备：自我认知洗脑" title="数据准备：自我认知洗脑" loading="lazy"/></p><h3>3.5 开始训练</h3><p>见证奇迹的时刻。使用 SFTTrainer，配合 Unsloth 的优化，速度会非常快。</p><pre><code class="python">from trl import SFTTrainer
from transformers import TrainingArguments
from unsloth import is_bfloat16_supported

trainer = SFTTrainer(
    model = model,
    tokenizer = tokenizer,
    train_dataset = dataset,
    dataset_text_field = "text",
    max_seq_length = max_seq_length,
    dataset_num_proc = 2,
    args = TrainingArguments(
        per_device_train_batch_size = 1, # T4 显存小，设为 1
        gradient_accumulation_steps = 8, # 累积 8 次，相当于 Batch Size = 1*8
        warmup_steps = 5,
        max_steps = 60, # 因为数据少，跑 60 步足够了 (大约 2-3 分钟)
        learning_rate = 2e-4,
        fp16 = not is_bfloat16_supported(),
        bf16 = is_bfloat16_supported(),
        logging_steps = 1,
        optim = "adamw_8bit", # 8bit 优化器，省显存
        weight_decay = 0.01,
        lr_scheduler_type = "linear",
        seed = 213,
        output_dir = "outputs",
        report_to = "none",
    ),
)

print("开始微调...")
trainer_stats = trainer.train()</code></pre><p>输出：</p><pre><code class="shell">Unsloth: Tokenizing ["text"] (num_proc=8): 100%
 90/90 [00:02&lt;00:00, 51.39 examples/s]
The model is already on multiple devices. Skipping the move to device specified in `args`.
开始微调...
==((====))==  Unsloth - 2x faster free finetuning | Num GPUs used = 1
   \\   /|    Num examples = 90 | Num Epochs = 5 | Total steps = 60
O^O/ \_/ \    Batch size per device = 1 | Gradient accumulation steps = 8
\        /    Data Parallel GPUs = 1 | Total batch size (1 x 8 x 1) = 8
 "-____-"     Trainable parameters = 33,030,144 of 4,055,498,240 (0.81% trained)
 [60/60 02:24, Epoch 5/5]
Step    Training Loss
1    4.232200
2    4.381100
...
60    0.014000</code></pre><p>我们的数据量和批次都设定的比较小，所以跑下来很快，大概3分钟左右就可以微调完毕，之后各位友人可以在huggingface或者modelscope找一些客服训练集或者其他训练集来训练一下，体验一下效果，这里咱们大致让大家感受一下，案例就比较简单。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600521" alt="开始训练：SFTTrainer+Unsloth极速微调" title="开始训练：SFTTrainer+Unsloth极速微调" loading="lazy"/></p><h3>3.6 效果验证</h3><p>训练完成后，我们需要验证一下它是否真的"认主"成功了。</p><pre><code class="python"># 开启推理模式
FastLanguageModel.for_inference(model)

# 准备测试问题
inputs = tokenizer(
    [
        alpaca_prompt.format(
            "你是谁？", # Instruction
            "", # Input
            "", # Output - leave this blank for generation!
        )
    ], return_tensors = "pt").to("cuda")

# 生成回答
outputs = model.generate(**inputs, max_new_tokens = 64, use_cache = True)
response = tokenizer.batch_decode(outputs)

print("\n" + "="*30)
print(f"微调后回答：\n{response[0].split('### Response:')[-1].strip()}")
print("="*30)</code></pre><p><strong>PS：Unsloth 提供了一个原生推理接口 FastLanguageModel.for_inference(model)，这比用 Transformers 原生推理快 2 倍。</strong></p><p>输出：</p><pre><code class="shell">==============================
微调后回答：
我是 Algieba Assistant，由 阿尔的代码屋 开发的 AI 助手。&lt;|im_end|&gt;
==============================</code></pre><p>Yeah,成功实现！<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600522" alt="效果验证：见证“认主”成功的时刻" title="效果验证：见证“认主”成功的时刻" loading="lazy"/></p><h2>4. （扩展部分）模型导出</h2><p>微调好的模型，如果只能在显存里用就太可惜了，Unsloth很方便的一点，就是它可以支持模型导出为GGUF和safetensor格式，甚至可以直接上传HuggingFace给大家用。</p><h3>4.1 清理显存</h3><p>为了避免在融合LoRA权重合并导出的时候，显存不足，咱们先把显存清理一下。</p><pre><code class="python">import gc
import torch
gc.collect()
torch.cuda.empty_cache()</code></pre><h3>4.2 GGUF格式导出</h3><pre><code class="python">quantization_method = "q4_k_m"
print(f"正在融合并转换为 {quantization_method} GGUF 格式...")
model.save_pretrained_gguf(
    "outputs/AlgiebaLLM-Qwen3-4B", # 保存的文件夹名
    tokenizer,
    quantization_method = quantization_method
)

print(" 导出完成！文件保存在 AlgiebaLLM-Qwen3-4B 文件夹中。")</code></pre><h3>4.3 SafeTensor格式导出</h3><pre><code class="python">print("正在融合为 16-bit Safetensors...")

model.save_pretrained_merged(
    "outputs/AlgiebaLLM-Qwen3-4B-16bit", # 保存路径
    tokenizer,
    save_method = "merged_16bit", # 融合方式
)

print("导出完成！")</code></pre><p><strong>PS:</strong></p><ul><li>merge_method="merged_16bit" 会把 LoRA 权重永久合入基座</li><li>哪怕咱们训练时用了 4bit，这里也能还原成 16bit 的完整模型</li></ul><p>本篇博客的所有代码可以在<a href="https://link.segmentfault.com/?enc=awGnJEj%2FrwGz7MdKdqRL6g%3D%3D.SCj34xN0jtrXHPnN13zH91YLO3wQ3VYz9ppZ25eBhv%2F%2B5dmOEZiD21y5M8fGEkMIrNblDSO1e4w%2B4nNCPMbGQg%3D%3D" rel="nofollow" target="_blank">这个notebook</a>找到</p><h2>5. 常见问题 (Q&amp;A)</h2><p><strong>Q1: 为什么代码里要把 <code>alpaca_prompt</code> 格式化？Qwen 不是用的 ChatML (<code>&lt;|im_start|&gt;</code>) 吗？</strong><br/><strong>A:</strong> 这是一个非常敏锐的问题！</p><ul><li><strong>Alpaca 格式</strong> (<code>Instruction/Input/Response</code>)：是目前微调最通用的“万金油”格式，大多数微调库都支持。Unsloth 会在底层帮我们将这种通用格式映射成模型能理解的 input。</li><li><p><strong>ChatML / ShareGPT 格式</strong>：这是 Qwen、Llama3 等模型<strong>原生</strong>的对话格式（支持多轮对话）。</p><ul><li>如果你只有单轮问答（如本教程），用 <strong>Alpaca</strong> 格式最简单，模型也能完美理解。</li><li>如果你有复杂的<strong>多轮历史对话</strong>数据（比如 <code>user-&gt;assistant-&gt;user-&gt;assistant</code>），那么推荐使用 <strong>ShareGPT</strong> 格式，并配合 Unsloth 的 <code>get_chat_template("qwen-2.5")</code> 函数，效果会更好。</li></ul></li></ul><p><strong>Q2: Kaggle 既然提供了两张 T4 显卡，我能不能把代码里的 <code>CUDA_VISIBLE_DEVICES="0"</code> 去掉，用双卡加速？</strong><br/><strong>A:</strong> <strong>千万别！(划重点)</strong><br/>对于 4B/7B 这种小参数模型，在 Kaggle 的 T4 环境下（PCIe 连接，非 NVLink），双卡通信的<strong>时间开销</strong>远大于计算收益。</p><ul><li><strong>现象</strong>：去掉该行后，你可能会发现进度条卡住不动（死锁），或者训练速度比单卡还慢。</li><li><strong>结论</strong>：对于 Unsloth + 小模型微调，<strong>单卡 T4 是目前的最优解</strong>。只有当你训练 32B 以上模型显存彻底不够用时，才考虑双卡模型并行（Pipeline Parallelism）。</li></ul><p><strong>Q3: 我看 Kaggle 还有 P100 显卡，显存也是 16G，能用 P100 跑 Unsloth 吗？</strong><br/><strong>A:</strong> <strong>不能。</strong><br/>Unsloth 的核心加速依赖于 Triton 语言重写的内核，这对 GPU 的硬件架构有硬性要求（Compute Capability $\ge$ 7.0）。</p><ul><li><strong>T4 (Turing架构)</strong>：算力 7.5 （完美支持）。</li><li><strong>P100 (Pascal架构)</strong>：算力 6.0 （不支持）。<br/>如果你选了 P100，代码会报错或者退化成极慢的 CPU 模拟模式。</li></ul><p><strong>Q4: 我只训练了 100 条数据，模型真的能学会吗？</strong><br/><strong>A:</strong> 这取决于你教它什么。</p><ul><li><strong>改“性格/身份”</strong>（如本例）：<strong>100条足够了</strong>。因为这属于强指令，模型很容易过拟合记住“我是谁”。</li><li><strong>学“专业知识”</strong>（如法律条文、医疗诊断）：那远远不够。注入知识通常需要 <strong>RAG</strong>（外挂知识库）或者 <strong>增量预训练 (CPT)</strong>，起步至少需要几千甚至上万条高质量数据。</li></ul><p><strong>Q5: 导出的 GGUF 和 SafeTensor 有什么区别？我该选哪个？</strong><br/><strong>A:</strong> 看你的使用场景：</p><ul><li><strong>选 GGUF</strong>：如果你想把模型下载到自己的笔记本电脑（Mac/Windows），用 <strong>Ollama</strong>、<strong>LM Studio</strong> 这种工具离线运行。它自带量化，体积小，CPU 也能跑。</li><li><strong>选 SafeTensor (16bit)</strong>：如果你想把模型部署到服务器，使用 <strong>vLLM</strong> 这种高并发框架提供 API 服务，或者想在 Python 代码里二次加载它。</li></ul><p><strong>Q6: 训练过程中报错 <code>OutOfMemory</code> (OOM) 怎么办？</strong><br/><strong>A:</strong> 显存是“炼丹”最宝贵的资源。如果爆显存，可以按以下顺序尝试：</p><ol><li>降低 <code>per_device_train_batch_size</code> (比如从 2 降到 1)。</li><li>提高 <code>gradient_accumulation_steps</code> (比如从 4 提到 8) 以保持总批次大小不变。</li><li>确保 <code>load_in_4bit = True</code> 已经开启。</li><li>在 <code>TrainingArguments</code> 中开启 <code>gradient_checkpointing = True</code> (虽然 Unsloth 默认帮我们开了，但可以检查一下)。</li></ol><hr/><p><strong>本文作者：</strong> Algieba<br/><strong>本文链接：</strong> <a href="https://link.segmentfault.com/?enc=wuW7s%2BoAktDRZZUoEq5%2FGg%3D%3D.2Ra5yE%2FtHLWQz2%2BTo%2Feag9fUTkbRqPx3VltnDfh1gERkFUOCZg90ppyj9nO6O4ZxwohOGp88Uy3XvXeuXmKBPA%3D%3D" rel="nofollow" target="_blank">https://blog.algieba12.cn/llm06-unsloth-qlora-ft/</a><br/><strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用 BY-NC-SA 许可协议。转载请注明出处！</p>]]></description></item><item>    <title><![CDATA[深入理解指针Part5——回调函数及应用 BlackQid ]]></title>    <link>https://segmentfault.com/a/1190000047600361</link>    <guid>https://segmentfault.com/a/1190000047600361</guid>    <pubDate>2026-02-08 22:02:12</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>1  回调函数的定义</h2><p>回调函数就是<strong>一个通过函数指针调用的函数</strong>。</p><p>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，<strong>被调用的函数就是回调函数</strong>。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p><p>概念有些抽象，接下来通过学习<code>qsort</code>函数以及其模拟实现来促进理解。</p><h2>2  <code>qsort</code>函数</h2><p><code>qsort</code>函数是用<strong>快速排序</strong>方法能对数组、结构体等按提供的规则进行排序的一个库函数。</p><pre><code class="c">void qsort (void* base, size_t num, size_t size, int (*compar)(const void*,const void*));</code></pre><p>该函数包含四个参数：</p><ul><li><code>base</code>是指向待排序内容的首元素地址；</li><li><code>num</code>是待排序内容的元素个数；</li><li><code>size</code>是待排序内容的一个元素大小，单位字节；</li><li>函数指针<code>compar</code>是指向<strong>比较函数</strong>，需要自行编写，实现对待排序内容中两个元素的比较。</li></ul><p>因为<code>qsort</code>函数并不知道你会传入一个什么样的数据类型，所以就需要你自己先写好一个比较函数，再传给<code>qsort</code>使用。比较函数的类型、参数与返回值都有规定，见参考链接。</p><p><code>qsort</code>函数更详细说明的参考链接：<a href="https://link.segmentfault.com/?enc=KkOZJSWUvSEWFmZGOsATxQ%3D%3D.EYsapt%2BdmGgOpy%2Fj9cihW1nhZ9ZGNTPVXsCcqwMmAfXkZK2kITIxPxpk%2F3vZvBc2GPPyH%2F8wM9WLzFjchfsmug%3D%3D" rel="nofollow" target="_blank">https://legacy.cplusplus.com/reference/cstdlib/qsort/?kw=qsort</a></p><p>下面是一个使用<code>qsort</code>函数排序整型数组的示例：</p><pre><code class="c">#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdlib.h&gt;
int cmp_int(const void* e1, const void* e2)
//const在*左侧，确保指针指向的内容不会被修改
{
    return *((int*)e1) - *((int*)e2);
    //要排序的是整形数组，元素是整形，这里先将void*类型强转成int*类型
    //强转成与元素对应的指针类型，解引用才能得到正确的结果
    //这里return返回相减的差，正好符合比较函数的返回值要求
}
int main()
{
    int arr[] = { 5,6,4,1,8,9,2,3,7 };
    int num = sizeof(arr) / sizeof(arr[0]);
    qsort(arr, num, sizeof(arr[0]), cmp_int);
}</code></pre><p>下面是一个使用<code>qsort</code>函数排序结构体数组的示例：</p><pre><code class="c">#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdio.h&gt;

struct Stu
{
    char name[20];
    int age;
};

void test3()//这里展示了两种访问结构体指针指向内容的方法
{
    struct Stu s = { "cuihua", 18 };
    struct Stu* ps = &amp;s;//结构体指针变量
    printf("%s\n", (*ps).name);
    printf("%s\n", ps-&gt;name);
    //结构体变量.成员名
    //结构体指针变量-&gt;成员名
}

//按照名字比较大小
//e1是指向一个结构体数据的，e1是指向另外一个结构体数据的
//名字是字符串，字符串的比较使用strcmp
int cmp_stu_by_name(const void* e1, const void* e2)
{
    return strcmp((*(struct Stu*)e1).name, (*(struct Stu*)e2).name);
}

int cmp_stu_by_name1(const void* e1, const void* e2)
{
    return strcmp(((struct Stu*)e1)-&gt;name, ((struct Stu*)e2)-&gt;name);
}

//按照年龄来比较
int cmp_stu_by_age(const void* e1, const void* e2)
{
    return ((struct Stu*)e1)-&gt;age - ((struct Stu*)e2)-&gt;age;
}

//测试qsort函数排序结构体数据 - 按名字比较
void test2()
{
    struct Stu arr[3] = { {"zhangsan", 18},{"lisi", 35},{"wangwu", 12} };
    //{"lisi", 35}, {"wangwu", 12},{"zhangsan", 18}
    int sz = sizeof(arr) / sizeof(arr[0]);
    qsort(arr, sz, sizeof(arr[0]), cmp_stu_by_name);
}

//测试qsort函数排序结构体数据 - 按年龄比较
void test4()
{
    struct Stu arr[3] = { {"zhangsan", 18},{"lisi", 35},{"wangwu", 12} };
    //{{"wangwu", 12}, "zhangsan", 18},{"lisi", 35}
    int sz = sizeof(arr) / sizeof(arr[0]);
    qsort(arr, sz, sizeof(arr[0]), cmp_stu_by_age);
}

int main()
{
    test2();
    test4();
    return 0;
}</code></pre><h2>3  模拟实现</h2><p>第2节解释了<code>qsort</code>函数的参数及运行方式，接下来尝试模拟实现。这里排序方法采用更熟悉的冒泡排序，而非<code>qsort</code>的快速排序。</p><pre><code class="c">#define _CRT_SECURE_NO_WARNINGS 1
#include&lt;stdlib.h&gt;

void Swap(char* buf1, char* buf2, size_t sz)
{
    for (int i = 0; i &lt; sz; i++)
    {
        int tmp = *buf1;
        *buf1 = *buf2;
        *buf2 = tmp;
        buf1++;
        buf2++;
    }
}

void bubble_sort(void* base, size_t n, size_t sz, int (*cmp)(const void*, const void*))
{
    for (int i = 0; i &lt; n; i++)
    {
        for (int j = 0; j &lt; n - 1 - i; j++)
        {
            if (cmp((char*)base + sz * j, (char*)base + sz * (j + 1)) &gt; 0)
            {
                Swap((char*)base + sz * j, (char*)base + sz * (j + 1), sz);
            }
        }
    }
}

int cmp_int(const void* e1, const void* e2)
{
    return *((int*)e1) - *((int*)e2);
}

int main()
{
    int arr[] = { 5,6,4,1,8,9,2,3,7 };
    int num = sizeof(arr) / sizeof(arr[0]);
    bubble_sort(arr, num, sizeof(arr[0]), cmp_int);
}</code></pre><p>观察上述的示例，并回忆回调函数的定义。</p><blockquote><p>回调函数就是<strong>一个通过函数指针调用的函数</strong>。</p><p>如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，<strong>被调用的函数就是回调函数</strong>。</p></blockquote><p><strong>比较函数</strong><code>cmp_int</code>通过函数指针的形式传入<code>bubble_sort</code>函数并在其内部被调用，比较函数<code>cmp_int</code>就是一个<strong>回调函数</strong>。其实第2节示例中的比较函数们也都是回调函数。</p><p>可见，回调函数在实现一些复杂功能时具有独到的优势。想想如果不用回调函数应该是不太好实现相同的功能的。</p>]]></description></item>  </channel></rss>