<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[2026-02-09 GitHub 热点项目精选 程序员锋仔 ]]></title>    <link>https://segmentfault.com/a/1190000047601745</link>    <guid>https://segmentfault.com/a/1190000047601745</guid>    <pubDate>2026-02-09 16:11:43</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>🌟 2026-02-09 GitHub Python 热点项目精选(16个)</h2><blockquote>每日同步 GitHub Trending 趋势，筛选优质 Python 项目，助力开发者快速把握技术风向标～</blockquote><hr/><h3>📋 项目列表（按 Star 数排序）</h3><h4>1. <a href="https://link.segmentfault.com/?enc=E0D4yuHXwRU6VoOQ2L%2BPBA%3D%3D.n3abx%2B9QVkUc41GE2sG3mwm2QLZXUyV2tkjiyDQNFZ%2BhATpQfODwGy4ma9V4zm8C" rel="nofollow" target="_blank">openai/skills</a></h4><blockquote>该项目由OpenAI创建，很可能是与人工智能技能相关的项目，比如一些用于训练AI模型的技能库，或者是帮助开发者更好地利用OpenAI的技术来开发各种应用的工具集合。不过具体细节需要进一步查看项目内容才能明确。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 7181（今日+1425）</td></tr><tr><td>Fork 数</td><td>🔄 406</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=3gCMLnXmd9LgsJusQE1XKA%3D%3D.S6I4M0eBrlEmMFlS8iHMVKm0p7cE8pzeeNOBwqbMcKwSBMANFL4kDhTNrip%2Bvvro" rel="nofollow" target="_blank">https://github.com/openai/skills</a></td></tr></tbody></table><hr/><h4>2. <a href="https://link.segmentfault.com/?enc=cUo2%2F4aSqq%2FDGC9vrGL5LQ%3D%3D.iEX9Wgyzzm38TPUaFbfwIFLnsQYTM3g94kzlDH7SDBxQku3tLAoFSp0NeEVpq8FR" rel="nofollow" target="_blank">google/langextract</a></h4><blockquote>由谷歌开发的项目，从名称来看，可能与语言提取相关，比如从文本中提取特定语言的内容，或者用于语言分析、语言处理等自然语言处理领域的工具，有助于处理多语言数据等。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 24919（今日+438）</td></tr><tr><td>Fork 数</td><td>🔄 1718</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=OrvhHmte4zegnC4UE%2FvI%2BQ%3D%3D.wqztt21Z6VAHJzLeK%2B%2BR5lZvhIdnNxbioCIWROAzuoQgvJ%2BQSoZ6Q49VkJiBAgbl" rel="nofollow" target="_blank">https://github.com/google/langextract</a></td></tr></tbody></table><hr/><h4>3. <a href="https://link.segmentfault.com/?enc=HS1a%2FXbV%2BuzCLOa9rWe7HQ%3D%3D.sm16YMyotQZuuEurOGUGSJLRsBTr%2FranZG62dSHykB6mYOqGYJic1LlP%2FRHWnwgK" rel="nofollow" target="_blank">OpenBMB/MiniCPM-o</a></h4><blockquote>OpenBMB团队开发的MiniCPM-o项目，可能是一个轻量级的模型，与语言模型或深度学习模型相关，可能是对大型模型的简化版本，便于在一些资源受限的场景下使用，或者用于快速原型开发等。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 23499（今日+212）</td></tr><tr><td>Fork 数</td><td>🔄 1794</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=ZyHjp9mB8gbbB6oCF6o8Ww%3D%3D.lcHqWjkriqNBujrzLKLPbywQ0giF6i2iA4Jv8BRMIhhmR7uR6YEUF%2B6Sh0fdpzN%2B" rel="nofollow" target="_blank">https://github.com/OpenBMB/MiniCPM-o</a></td></tr></tbody></table><hr/><h4>4. <a href="https://link.segmentfault.com/?enc=LXD09nfbG99AH%2FqBiRVUNQ%3D%3D.KSGk3oPDydQu%2Fzqag93YenNmA1bJD9XuDV5P7ZL%2FRhKarjVizXgRPSnuWYpGvh6s" rel="nofollow" target="_blank">p-e-w/heretic</a></h4><blockquote>从项目名称来看，heretic可能是一个具有创新性或者突破传统思维的项目。它可能涉及一些新的技术概念、框架或者工具，用于解决某个特定领域的问题，或者探索新的技术方向。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4917（今日+308）</td></tr><tr><td>Fork 数</td><td>🔄 474</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=pff9ZK%2BStSW9qh3GCPmqVg%3D%3D.qMDxqjGgwlJgbza9fWDHOnyiwJyl0aBioTCy8wrcLHAgj8%2FzA7%2BpqsV%2FFeFYtXZf" rel="nofollow" target="_blank">https://github.com/p-e-w/heretic</a></td></tr></tbody></table><hr/><h4>5. <a href="https://link.segmentfault.com/?enc=j%2FW8Ibzvp5F6GZktLYYcHw%3D%3D.fkT9qAQc9qlgibrmCfFibap9wtqdRGAp7fdYpdbiI2cUXOJXnhIf%2BIJLf6bVMFH1" rel="nofollow" target="_blank">karpathy/nanoGPT</a></h4><blockquote>由karpathy创建的nanoGPT项目，很可能是一个小型的GPT（生成式预训练模型）版本，用于研究、学习或者快速开发基于GPT架构的自然语言处理应用，方便开发者理解和使用GPT模型。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 52768（今日+40）</td></tr><tr><td>Fork 数</td><td>🔄 8937</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=C8YX9M6CVQpNBRzKD%2BHD9w%3D%3D.CCCLod6ApgkgNx7SVpAvFB%2BjhwOL0gawefQqBsAMk%2F4enDOHaXfQILPdmHlcBOzq" rel="nofollow" target="_blank">https://github.com/karpathy/nanoGPT</a></td></tr></tbody></table><hr/><h4>6. <a href="https://link.segmentfault.com/?enc=vC5TKs%2BVqUVfSREDm1Xa8w%3D%3D.oyw9yt2uyne3DY%2B0LX%2FywXPL0dtGHfFT3nts%2FSUHKZrJHYjgyp1ZwdGbqB3mnU2N" rel="nofollow" target="_blank">public-apis/public-apis</a></h4><blockquote>这个项目应该是一个公共API的集合，为开发者提供各种各样的API接口信息，方便开发者在开发应用时快速找到和使用所需的API，涵盖了各种领域和功能的API。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 396642（今日+663）</td></tr><tr><td>Fork 数</td><td>🔄 42454</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=6C9Ih%2BdrXrWClm1o2Zz1PQ%3D%3D.O77jUHIQrx7Vz5yACM9LS87cKZbv%2BUTKW6dzV1%2Bp0gFGSc9hGVIV%2BWAyJrlnOa0H" rel="nofollow" target="_blank">https://github.com/public-apis/public-apis</a></td></tr></tbody></table><hr/><h4>7. <a href="https://link.segmentfault.com/?enc=%2BmY8Pk2mdaeFkLHHZ8jWkQ%3D%3D.kALSgZWPb1cVTMyTgxE32LsM5Lxute2YVzWDPB%2F9XyVeLBGW4mnv0Otym3rH7vU6" rel="nofollow" target="_blank">hsliuping/TradingAgents-CN</a></h4><blockquote>从名称来看，这是一个与交易代理相关的项目，且带有“CN”，可能主要针对中国市场或者中文用户。它可能包含了用于金融交易、股票交易等场景的代理程序、策略或者相关工具。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 16019（今日+278）</td></tr><tr><td>Fork 数</td><td>🔄 3546</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=2jQnD79dPzFxi8lZOkgurg%3D%3D.Foqd0FJU%2F6GzgbkFy6TFr1iur9sdkywnb07rqdq665MAzmdczmT8HVD%2FTeSTaE9j" rel="nofollow" target="_blank">https://github.com/hsliuping/TradingAgents-CN</a></td></tr></tbody></table><hr/><h4>8. <a href="https://link.segmentfault.com/?enc=hu6t5o5HndqCkHbwnNIvCw%3D%3D.Y3g1hQ5FqOpMvb2Pe8xjez7DCxYd9RLNnymmjpXPq155GLrqYSbt6JDRVDJDWf4N" rel="nofollow" target="_blank">resemble-ai/chatterbox</a></h4><blockquote>resemble-ai团队开发的chatterbox项目，可能是一个聊天机器人相关的项目，用于创建智能对话系统，能够与用户进行自然语言交流，可能具有一定的语言理解和生成能力，用于各种需要自动对话功能的场景。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 22489（今日+76）</td></tr><tr><td>Fork 数</td><td>🔄 2946</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=bP3kxipzNkv4Rq3LU2vlxQ%3D%3D.POMsY6kyVsrKTtQNqBw8%2FmMBl6lRrR2rA98W9%2F5uYRUd9McVMQzcZAfXee6zb1rJ" rel="nofollow" target="_blank">https://github.com/resemble-ai/chatterbox</a></td></tr></tbody></table><hr/><h4>9. <a href="https://link.segmentfault.com/?enc=egOqkN59qPj%2BSpdBIj%2BiNg%3D%3D.gC%2B74sCPoz%2B7cDv%2FCpSBLE8MhFMzoNBhJd4IXJvFRxrUZ%2BoK1%2FOVYA%2FBJUUj77GORimWdlUfwgcpzPDM1E9REw%3D%3D" rel="nofollow" target="_blank">ComposioHQ/awesome-claude-skills</a></h4><blockquote>该项目可能是一个关于“Claude”技能的集合，Claude可能是一个特定的人工智能模型或者平台的名字，这个项目收集了各种与之相关的技能、应用案例或者开发技巧，方便开发者学习和使用。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 32855（今日+849）</td></tr><tr><td>Fork 数</td><td>🔄 3149</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=1BpuOTqIP9sZUgAf1%2F3Q3g%3D%3D.WtN0GbsNJKJ4NlltuS%2F8cOcJcfmrhMJhFHO%2FLmicFObNUcBRem%2Bc%2Fo4I2nYL9wg0zRa1pPxWKWtxYhaS6zrOgg%3D%3D" rel="nofollow" target="_blank">https://github.com/ComposioHQ/awesome-claude-skills</a></td></tr></tbody></table><hr/><h4>10. <a href="https://link.segmentfault.com/?enc=EqzAoTg2yyKJOCBe%2BVWl%2BA%3D%3D.E6Tn63udeH2hUNpYegAxYaGAuE%2F3DoA9n0tVUgxrmXvhGBil2TzY%2FnqWSh8WvGDf" rel="nofollow" target="_blank">chenyme/grok2api</a></h4><blockquote>由chenyme开发的grok2api项目，从名称来看，可能与API开发或者API解析相关，grok通常表示解析或者理解的意思，所以这个项目可能提供了一种将某些数据、代码或者其他内容转换为API或者与API交互的功能。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 1237（今日+65）</td></tr><tr><td>Fork 数</td><td>🔄 375</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=cr3FZ74MB%2F1qpkKjsNjuUA%3D%3D.TXKqeMMqxFcRvS6%2Fhj1zSTix8SLzAZ5DRKOFN6iDweErHimnf8Me1%2BtSubgsS4za" rel="nofollow" target="_blank">https://github.com/chenyme/grok2api</a></td></tr></tbody></table><hr/><h4>11. <a href="https://link.segmentfault.com/?enc=SG7SWgxcn9%2FOMJEP6%2B%2FLcw%3D%3D.pSkzvDkC9%2FSHQYvxGJjQCw9rFbS50PEkZWMKfhVnrp8%2FAmicn7%2BqdGuAblevzymY" rel="nofollow" target="_blank">suitenumerique/docs</a></h4><blockquote>suitenumerique团队的文档项目，可能包含了该团队开发的软件、工具或者其他项目的详细文档，为开发者和用户提供使用指南、技术说明、API文档等，方便大家更好地理解和使用相关项目。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 15974（今日+61）</td></tr><tr><td>Fork 数</td><td>🔄 526</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=ZHQ%2F7Q3NCmktoZ1YH73TmQ%3D%3D.8jBNpqy23C9Yoor%2BIoBlUplG33DdsH6b66DXDrfmcXL1SROSC5rDB2V2vJwCJ0Zk" rel="nofollow" target="_blank">https://github.com/suitenumerique/docs</a></td></tr></tbody></table><hr/><h4>12. <a href="https://link.segmentfault.com/?enc=%2FPyo6E2srG4WypSTruWuQQ%3D%3D.CHwKkes7YOr6O7V0Wagdy%2F7NyCpXQZsjA%2B5MN19BVecN4gFNYLgDFK6ww54sFn7K" rel="nofollow" target="_blank">airweave-ai/airweave</a></h4><blockquote>airweave-ai团队的airweave项目，从名称来看，可能与人工智能和某种“编织”或者“整合”相关，可能是将多个数据源、模型或者技术整合在一起的平台，用于构建复杂的人工智能应用或者数据处理流程。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 5689（今日+63）</td></tr><tr><td>Fork 数</td><td>🔄 692</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=bcmUVIYd83d4UnqThmsh0A%3D%3D.FPCxVUgDy35VeXR8q0l%2F8uHuuqM4RL08sHbkIVi4UdSn%2BbVgFMkx4opS4CQVkUg0" rel="nofollow" target="_blank">https://github.com/airweave-ai/airweave</a></td></tr></tbody></table><hr/><h4>13. <a href="https://link.segmentfault.com/?enc=244xHDiFfQ0ezvOhJWfaow%3D%3D.SPHi%2F1P9goHuDPV6zVHmH2%2BvlcYCvyuV%2Bz5%2B5V26GlkVhH1JnFdLcY7NJebSe3on" rel="nofollow" target="_blank">Lightricks/LTX-Video</a></h4><blockquote>Lightricks团队的LTX-Video项目，Lightricks是一个在图像和视频处理领域比较知名的公司，所以这个项目很可能与视频处理、编辑或者特效相关，提供了相关的工具、算法或者框架。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 9270（今日+27）</td></tr><tr><td>Fork 数</td><td>🔄 876</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=tqZV6tPhh5bCF2RTjRAEmA%3D%3D.hIw6c%2FW6kZz3W9JyHm0tiE61xb4yIYkHy64Dk8IA70pb5rQ2xtqLgFYgnfmA5UDE" rel="nofollow" target="_blank">https://github.com/Lightricks/LTX-Video</a></td></tr></tbody></table><hr/><h4>14. <a href="https://link.segmentfault.com/?enc=Lfql8HzsIcdbR1uRqaKjDQ%3D%3D.cmrP1n3iNbOl0Mwf%2FfELzpAjqotkQSTsCbFXxNxYxpZaeTP1d6S7iHLLKhLzVVHn" rel="nofollow" target="_blank">wshobson/agents</a></h4><blockquote>由wshobson创建的agents项目，可能与代理、代理系统或者智能代理相关，比如用于自动化任务、数据处理或者与外部系统交互的代理程序，具有一定的智能性和自动化功能。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 28168（今日+95）</td></tr><tr><td>Fork 数</td><td>🔄 3105</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=66sL7xeKAN8lHTdgCnYbpg%3D%3D.NRUpwnXdPW4mSLqoFtQ%2BJHLRyrexqnxxDdRkfnMrVTBFby1z18EVdQzifxD2Kow%2B" rel="nofollow" target="_blank">https://github.com/wshobson/agents</a></td></tr></tbody></table><hr/><h4>15. <a href="https://link.segmentfault.com/?enc=d9HPaOgE4vTOKeD65ilFJg%3D%3D.XPsU5ooGhLDlsCMOeY2R7XyEiUBYq8EgONZZkswTyODozrosD1oOjB0Qm9L9V1bi" rel="nofollow" target="_blank">huggingface/speech-to-speech</a></h4><blockquote>由huggingface开发的speech-to-speech项目，huggingface是一个在自然语言处理领域很有影响力的团队，这个项目很可能与语音到语音的转换相关，比如语音识别、语音合成或者语音翻译等应用。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4438（今日+35）</td></tr><tr><td>Fork 数</td><td>🔄 501</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=OrfqO3J3RiRNS89GhuatEw%3D%3D.Mox3WK%2BQZSmWmA8lfBWwmPTimx6XGcGxNvuzCga6X0a3rCkLPZY4%2F0cfNDIh%2B7ZR" rel="nofollow" target="_blank">https://github.com/huggingface/speech-to-speech</a></td></tr></tbody></table><hr/><h4>16. <a href="https://link.segmentfault.com/?enc=dJZ43RSDnnGbmARbaVRF2Q%3D%3D.TmWhUN7QNvGd2AvRpj2uZTgeYl9FFGY6y%2BO9F4EPARL1UiHK5LKRgcLYr3nBCFrV" rel="nofollow" target="_blank">gyoridavid/ai_agents_az</a></h4><blockquote>gyoridavid创建的ai_agents_az项目，从名称来看，可能与人工智能代理相关，且“az”可能表示某种特定的分类、范围或者平台，项目可能是关于在该特定环境下的人工智能代理开发、应用或者研究。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 3330（今日+49）</td></tr><tr><td>Fork 数</td><td>🔄 822</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=yBCHKSKLyCUfF8%2FEsZhfgA%3D%3D.GF5gW2FPBTthVumUWDHBWTw8rXjO5icyY1AHEsCO%2FMPz5%2BbR2HJY56o8u9fAW4Ni" rel="nofollow" target="_blank">https://github.com/gyoridavid/ai_agents_az</a></td></tr></tbody></table><hr/><h3>📝 说明</h3><ul><li>数据来源：GitHub Trending（2026-02-09 每日榜单）</li><li>筛选条件：Python 语言 + 当日热门项目</li><li>自动更新：每日同步最新趋势，建议收藏本文持续关注～</li></ul><h3>⭐ 推荐理由</h3><ol><li>热门项目代表当前技术趋势，学习价值高</li><li>优质项目代码规范，可作为学习参考</li><li>部分项目可直接用于实际开发，提高效率</li></ol>]]></description></item><item>    <title><![CDATA[通过 ZeroNews 远程管理 OpenClaw GateWay Dashboard ZeroNe]]></title>    <link>https://segmentfault.com/a/1190000047601752</link>    <guid>https://segmentfault.com/a/1190000047601752</guid>    <pubDate>2026-02-09 16:10:49</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>上期我们介绍了如何部署Clawdbot AI的详细操作步骤【<a href="https://segmentfault.com/a/1190000047590771" target="_blank">本地搭建 Clawdbot + ZeroNews 访问</a>】</p><p>本篇文章主要为已部署Clawbot AI的用户，提供了一种便捷、适配国内网络环境的远程管理解决方案——借助 ZeroNews 替代官网推荐的代理工具，实现OpenClaw GateWay Dashboard的远程访问；</p><p>同时针对性解决远程访问时可能出现的Gateway Token错误、设备授权错误两大常见问题，明确了远程Dashboard的全部可操作功能。</p><p>OpenClaw 是一个专为 AI 应用与智能体部署设计的高性能网关平台，它提供了统一的仪表盘（Gateway Dashboard）用于集中管理模型调用、渠道集成、技能插件、定时任务及节点监控。</p><p>基于 OpenClaw 构建的 Clawbot AI 是一款功能强大的 AI 产品，能够无缝接入多种对话模型与即时通信平台（如 WhatsApp、Telegram、Discord 等），并通过可扩展的技能系统实现自动化任务与智能交互。</p><p>完成 Clawbot AI 安装后（安装步骤可参考我们上期的文章），您将获得 OpenClaw Gateway Dashboard 的本地访问地址及唯一的 Gateway Token（后续配置需用到）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601756" alt="图片" title="图片"/></p><p>通过访问地址可以通过本地访问打开 OpenClaw Gateway Dashboard<br/>默认访问地址：127.0.0.1:18789<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601757" alt="图片" title="图片" loading="lazy"/></p><p>该地址仅支持本地网络访问。若需在外部网络环境下管理网关，官方文档提示我们需借助 Tailscale 或 VPN 等代理工具，但这些方式在国内网络环境中往往体验不佳。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601758" alt="图片" title="图片" loading="lazy"/></p><h3>ZeroNews 远程映射配置</h3><p>而通过我们的实测，ZeroNews可以完美的替代官网推荐的代理工具。<br/>1、简单三步就能够实现 OpenClaw Gateway Dashboard 的远程访问。下载安装 ZeroNews Agent创建域名信息配置映射服务<br/>2、提供IP黑白名单和鉴权认证。可以完美的解决暴露出来的 GateWay Dashboard 不受非授权IP访问和授权账号访问，提升服务的安全性。</p><h3>远程Gateway Dashboard 错误问题处理</h3><p>但是我们通过远程访问的时候，如果出现如下问题，可以通过下面的方法解决。</p><p>01 GateWay Token 错误</p><p>1、报错信息：<br/>disconnected (1008): unauthorized: gateway token missing (open a tokenized dashboard URL or paste token in Control Ul settings)<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601759" alt="图片" title="图片" loading="lazy"/></p><p>2、报错原因：第一次通过远程连接访问 OpenClaw Gateway Dashboard时，需要配置 GateWay Token，否则会出现错误。</p><p>3、解决方案：打开 Control / Overview 页面然后将上面安装时获取到的GateWay Token粘贴进去点击Connect连接<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601760" alt="图片" title="图片" loading="lazy"/></p><p>02 设备授权错误</p><p>1、报错信息：disconnected (1008): pairing required<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601761" alt="图片" title="图片" loading="lazy"/><br/>2、错误原因：如果您使用一台新的设备去访问 OpenClaw Gateway Dashboard的 URL 时，除了需要配置上面的GateWay Token 之外，还需要对新的设备进行授权，否则会提示错误。</p><p>3、解决方法：</p><p>a) 首先，我们要打开到配置窗口，并执行设备列表查询命令<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601762" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601763" alt="图片" title="图片" loading="lazy"/></p><p>b) 这时候，可以看到上面会出现刚才请求连接访问的设备信息。我们需要记住 Request IDc) 接着，我们执行设备授权命令和重启网关命令<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601764" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601765" alt="图片" title="图片" loading="lazy"/></p><p>d) 执行完成之后，我们回到 GateWay 页面，点击刷新，可以看到 STATUS 为 Connected 状态，表明我们已经可以正常访问了。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601766" alt="图片" title="图片" loading="lazy"/></p><p>注意：</p><ul><li>一旦批准，设备会被记住，除非你使用命令 openclaw devices revoke --device &lt;id&gt; --role &lt;role&gt; 撤销它，否则不需要重新批准。</li><li>每个浏览器配置文件生成唯一的设备 ID，因此切换浏览器或清除浏览器数据将需要重新配对。</li><li>若等待授权的时间过长，Request ID会过期，需要重新点击 Connect 申请授权，并通过设备命令查询获取到新的Request ID进行授权。</li></ul><p>e) 通过上述操作后，我们就可以在Chat页面与AI进行沟通了。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601767" alt="图片" title="图片" loading="lazy"/></p><h3>远程 Gateway Dashboard 可以做什么</h3><p>通过远程 Dashboard，您可以全面管理 OpenClaw 网关，包括：</p><ul><li>对话管理：通过 WebSocket 与模型聊天，支持流式工具调用与实时输出。</li><li>渠道集成：管理 Telegram、WhatsApp、Discord、Slack 等渠道的状态、扫码登录与配置。</li><li>实例监控：查看在线实例列表并即时刷新状态。</li><li>会话控制：列出会话、调整会话的思考模式与详细设置。</li><li>定时任务：管理 Cron 任务的添加、启用、禁用与执行历史。</li><li>技能管理：查看技能状态、启用/禁用技能、安装新技能及更新密钥。</li><li>节点管理：查看节点列表及其能力。</li><li>执行审批：编辑网关与节点的允许列表，设置执行询问策略。</li><li>配置编辑：查看或编辑 openclaw.json配置文件，支持表单与 JSON 两种编辑模式。</li><li>调试与日志：查看系统状态、健康检查、模型快照、事件日志，支持实时日志跟踪与导出。</li><li>更新操作：执行包更新或 Git 更新，并查看重启报告。</li></ul><h3>安全注意事项</h3><p>1、IP 访问控制：<br/>可以通过在映射页面，对此映射配置IP访问控制功能，实现仅允许白名单IP访问，非白名单IP无法访问。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601768" alt="图片" title="图片" loading="lazy"/></p><p>拒绝访问效果图<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601769" alt="图片" title="图片" loading="lazy"/></p><p>2、鉴权认证管理：<br/>可以通过在映射页面，对此映射配置鉴权认证，实现需要账号密码才能访问，进一步提升安全能力。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601770" alt="图片" title="图片" loading="lazy"/></p><p>开启鉴权效果图<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601771" alt="图片" title="图片" loading="lazy"/></p><p>接下来，我们将继续深入挖掘更多实用、有趣的进阶玩法，敬请期待。</p>]]></description></item><item>    <title><![CDATA[频繁跳槽真的比稳定工作的人差吗？ 悲伤的煎鸡蛋_cQXuXF ]]></title>    <link>https://segmentfault.com/a/1190000047601856</link>    <guid>https://segmentfault.com/a/1190000047601856</guid>    <pubDate>2026-02-09 16:09:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>前几日在在电梯里听见的谈论：</p><p>“你这几年换了三份工作啊？”<br/>“嗯。”<br/>“厉害……也有点飘。”<br/>电梯门一合，扣好“草率”的标签，一整天都刮着风。</p><p>与其争辩，不如换个叙述方式。今天不讲数据，讲一个三幕小剧场，把“稳定”与“跳槽”请上台，各自说话。</p><h3>第一幕｜传统观念的回音墙</h3><p>父母视角：稳定=安全。“铁饭碗至少不饿肚子。”<br/>邻里视角：稳定=体面。“单位名片比名片上人名重要。”<br/>部分HR视角：稳定=可靠。“履历像一条直线，省心。”</p><p>这些声音没有错，只是来自过去的经济逻辑：岗位稀缺、失败成本高、信息不透明。<br/>但现在的职场像一条不断分叉的河。你原地扎营可以，但也许更好的水草在拐弯处。<br/>“稳定”如果只是不变，那更像卡在河床上的一块石头；真正的稳定，是在变化中保持可控。</p><p>金句：稳定是结果，不是方式；不变不一定叫稳定，掌控才叫稳定。<br/><img width="723" height="278" referrerpolicy="no-referrer" src="/img/bVdnTuy" alt="" title=""/></p><h3>第二幕｜跳槽与成长：换工作，别只换门禁卡</h3><p>跳槽，最怕“换来换去，只换了工牌颜色”。<br/>判断有没有成长，看四件事：</p><pre><code>问题强度：新岗位的难题，是否比原来的更大、更复杂、更贴近业务核心？
可迁移资产：你带走了什么“随身武器”（写作、分析、项目推进、谈判、行业认知）？
视角宽度：是否从“执行者”升到“设计者/决策参与者”的视角？
作品与证据：能不能用一页纸/一个仓库/一个案例说服陌生人？

</code></pre><p>如果这四件事持续上台阶，频率不是原罪；如果只是为了逃避情绪、老板、加班——那叫逃跑，不是跳槽。</p><p>金句：好的跳槽，是把履历写进能力；坏的跳槽，是把心情写进简历。</p><p><strong>跳槽机-会</strong></p><p>技术大厂，前端-后端-测试，全国均<a href="http:////jsj.top/f/o38ijj" target="_blank">有机-会</a>，感兴趣可以试试。待遇和稳定性都还不错~</p><h3>第三幕｜什么样的跳槽才算“有价值”？</h3><p>给你一块价值跳槽九宫格（自测用，过半即值得）：</p><pre><code>方向：行业在向上？岗位贴近价值链核心？
密度：问题更难？反馈更快？产出更可见？
导师：能跟到真正在干活、愿意带人的上级？
舞台：边界更大（预算/权限/跨部门协作）？
节奏：迭代更短（周/月为单位复盘）？
证据：离职时能留下公开作品或可量化战绩？
现金：不是只涨工资，而是单位时间成长更高？
生活：通勤、作息、健康是否更可持续？
心流：进入“做着做着忘了时间”的那种投入？

</code></pre><p>能勾中6格以上，才叫“向上的移动”。<br/>别只看薪资条，那是果；先看问题强度与可迁移资产，那是根。</p><p>四不跳（写得像贴在显示器上的小贴纸）：</p><pre><code>不为发泄而跳（吵完架写辞职信，第二天先删草稿）。
不为名头而跳（Title 高一号，问题却更边角）。
不为“跟风”而跳（朋友涨薪=他的剧本，你得看自己的镜头）。
不为“逃离”而跳（去哪儿都一样累=问题在方法，不在公司）。


</code></pre><p>行动卡｜下一次跳之前，先做这三件小事</p><pre><code>
写一封给未来雇主的信（300字）
只回答三问：我解决过什么问题→用过什么方法→带来了什么改变。写不出来，就别急着跳。


做一张“技能-行业”二维表
横轴列出你拥有或在学的3–5项通用技能，纵轴放3个感兴趣行业，把可迁移的交叉点标星。星星越多，越值得跳。


安排一次“影子体验”
找目标岗位的人聊30分钟，围绕一天在做什么、最难的问题、如何被衡量三件事。聊不到，说明信息还不够，先别跳。


</code></pre><p>给“稳定派”与“跳槽派”的一封并信</p><pre><code>稳定派：请把“稳定”从“年头写到年尾”改成“能力结构可复用、现金流有弹性、健康不透支”。那是强者的稳定。
跳槽派：请把“跳”从“情绪出口”改成“能力跃迁”。那是成熟的跳槽。

</code></pre><p>人和岗位不是孰优孰劣，是匹不匹配。<br/>频繁跳槽的人，并不比稳定工作的人差；真正的差别在于：<br/>有人在原地生长，有人在移动中生长；有人只是换地方，有人换了层级。</p><p>当你能把每一次选择，都解释为更清晰的方向、更锋利的能力、更合理的生活——<br/>你的履历，就不再是“跳来跳去”，而是一步一个台阶。</p><p>——转载自：狗头大军之江苏分军</p>]]></description></item><item>    <title><![CDATA[OpenClaw 新玩法！手把手教你施展“组合技”，国产 Skills 搞定几大场景.. 甲木未来派]]></title>    <link>https://segmentfault.com/a/1190000047601862</link>    <guid>https://segmentfault.com/a/1190000047601862</guid>    <pubDate>2026-02-09 16:09:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大家好啊，我是甲木。</p><p>这段时间不是一直在折腾 OpenClaw 么，</p><p>之前发的几篇教程类文章，对于很多小伙伴来说，还是门槛比较高，</p><p>正好前两天刚从百度智能云的 Agent 大会回来，还挺有意思的，趁热给大家聊聊（关于大会内容，放后边了~）。</p><p>现在，百度智能云也接入了 OpenClaw的极简版本，</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601865" alt="" title=""/></p><p>并且发了一堆非常有意思的skills和百度官方工具，跟现有的OpenClaw打通也有很多的玩法，</p><p>我当时第一反应就是：</p><p><strong>这不就是我一直在找的东西吗？</strong></p><p><strong>OpenClaw × 百度智能云 × 千帆 Skill ⽣态，一套组合拳下来，贼牛批..</strong></p><p>好，先别急，我慢慢说。</p><p>今天这篇主要聊几件事：</p><ul><li>百度千帆上线了几个非常实用的Skills，直接接入OpenClaw</li><li>百度智能云上搭 OpenClaw，到底有多简单</li><li>三个我实际跑通的 Skills 玩法，真的能干活那种</li></ul><p>那么，我们开始！</p><h3>先说大会上最让我上头的东西</h3><p>大会上发了不少东西，但最让我兴奋的，是<strong>「百度千帆工具及MCP广场」</strong>把百度的生态，直接接入OpenClaw了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601866" alt="" title="" loading="lazy"/></p><p>大家玩过 OpenClaw 都知道，这玩意儿的拓展性也在于 <strong>Skills</strong>，你给它装什么技能，它就能干什么活。</p><p>而现在百度智能云把「百度 AI 搜索、百度地图、百度网盘、OCR、语音识别」...这些百度自家的能力，全部以 MCP Server 和Skills的形式开放出来了。</p><p>以前你想给 OpenClaw 加个"搜索"能力，得自己找 API、写配置、调半天参数。</p><p>现在？去广场里挑一个，接进去，完事儿。</p><p>而且开发者还能自己开发 MCP Server 发布上去，免费托管，还能被百度搜索收录，等于白送你一波流量。</p><p>说白了，这就是给 Agent 开发者建了一个<strong>应用商店</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601867" alt="" title="" loading="lazy"/></p><p>而我这次重点关注到的，是已经上架的几个<strong>跟 OpenClaw 直接能打配合的 Skill</strong>：</p><ul><li><strong>百度搜索</strong>：实时信息检索，这是 Agent 的"眼睛"</li><li><strong>百度百科</strong>：知识查询和概念核实，相当于给 Agent 装了本百科全书</li><li><strong>学术检索</strong>：论文搜索和学术信息获取，做研究的朋友懂的</li><li><strong>智能 PPT 生成</strong>：搜完信息直接出汇报材料，一条龙</li><li><strong>AI 绘本生成</strong>：把内容变成图文并茂的绘本，做内容创作的太需要了</li></ul><p>这几个 Skill 单独用都挺好使，但更有意思的是，<strong>它们能组合起来用</strong>。</p><p>后面我会专门聊几个我自己跑通的组合玩法，先按下不表。</p><h2>百度智能云上搭 OpenClaw，到底有多简单</h2><p><strong>已经部署好Openclaw的朋友可以直接跳过本章</strong>，看下一节内容，</p><p>还没部署好，或者想要再白嫖优惠OpenClaw的可以看看本章。</p><h3>前两篇文章之后，大家反馈最多的问题</h3><p>关注我的朋友应该记得，前两天我连着肝了两篇 OpenClaw 的教程：</p><ul><li>第一篇是阿里云部署的，从买服务器到打通钉钉，全流程手把手</li><li>第二篇更硬核，从 0 到 1 装官方原版，接了 Kimi K2.5，还搞了 Discord 远程操控</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601868" alt="" title="" loading="lazy"/></p><p>文章发完之后，后台和群里炸了..</p><p>大家问得最多的，基本就两类：</p><p><strong>一类是："甲木，我照着你教程做，环境配置那步就卡住了，报了一堆错，咋整？"</strong></p><p>虽然我已经写得尽量保姆级了，但确实，</p><p>对于没怎么碰过命令行的朋友来说，配环境、装依赖、排报错这些东西..还是劝退了不少人。</p><p><strong>另一类是："教程里那些软件都是国外的，有没有更适合国内的方案？"</strong></p><p>嗯，这个确实是痛点。</p><p>OpenClaw 原生适配的工具和渠道基本都是海外生态，国内想用好它，适配成本不低。</p><p>正好，</p><p>百度智能云这次直接上线了 <strong>OpenClaw 极简部署</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601869" alt="https://cloud.baidu.com/product/BCC/moltbot.html" title="https://cloud.baidu.com/product/BCC/moltbot.html" loading="lazy"/></p><p>它同样直接提供了预装好 OpenClaw 环境的轻量应用服务器镜像。</p><p>你在控制台选这个镜像，创建实例，几分钟就能跑起来，啥都不用手动装。</p><p>更狠的是，它还搞了个<strong>限时免费体验</strong>：<strong>首月免费</strong>，每天限量 500 台，先到先得。</p><p>之前阿里云那个 68 块一年大家就已经觉得香了，这次百度直接搞免费...</p><p>好家伙，卷起来了属于是。</p><p>部署完之后，你还能直接通过千帆平台接入文心、DeepSeek、Qwen 这些模型，不用自己到处去注册账号拿 API Key。</p><p>这对于小白来说，友好度直接拉满了。</p><h3>搭建流程，三步搞定</h3><h4>第一步、买台服务器</h4><p>打开百度智能云官网（<code>https://cloud.baidu.com/product/BCC/moltbot.html</code>），选轻量应用服务器。</p><p>几个关键的配置别选错：</p><ul><li><strong>镜像</strong>：一定选 OpenClaw(Clawdbot) 应用镜像</li><li><strong>套餐</strong>：CPU 2核、内存 4GB 起步</li><li><strong>地域</strong>：按需选</li></ul><p>如果有优惠的话，你会看到这个界面，</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601870" alt="" title="" loading="lazy"/></p><p>如果没优惠的话，你就只能按月付费了..</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601871" alt="" title="" loading="lazy"/></p><p>但我给你一个思路，可以新注册一个账号...</p><p>然后正常购买，</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601872" alt="" title="" loading="lazy"/></p><blockquote>踩坑提醒：OpenClaw 是 Node.js 应用，比较吃内存。2G 内存裸跑偶尔会 OOM（内存溢出），建议搞一下 Swap 交换空间，不然跑着跑着进程就没了，问我怎么知道的..</blockquote><h4>第二步、配模型</h4><p>服务器跑起来之后，进控制台：</p><p>等待实例创建完成后进入实例详情页，点击<strong>实例管理Tab</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601873" alt="" title="" loading="lazy"/></p><ol><li>放通端口——防火墙那步，点一下<strong>「一键开通」</strong>就行</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601874" alt="这里需要注意，按量计费" title="这里需要注意，按量计费" loading="lazy"/></p><blockquote>这里是直接按使用量计费的，需要注意。如果不想走千帆平台的，我们可以直接用它的服务器，然后自己搭建镜像，就跟那篇文章教大家的一样。</blockquote><ol start="2"><li>防火墙放通18789端口</li></ol><p>访问openclaw官网网站需要通过18789端口访问，点击“一键放行”放行防火墙18789端口。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601875" alt="" title="" loading="lazy"/></p><ol start="3"><li>接大模型——通过千帆平台配，文心、Qwen、DeepSeek 都能选</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601876" alt="" title="" loading="lazy"/></p><p>到这里，三步其实就完事了，但千帆的好处是，<strong>选完模型之后还能顺手去 MCP 广场挑几个工具，直接给你的 OpenClaw 装上技能包</strong>。</p><p>这步体验下来确实比之前丝滑不少。</p><h4>第三步、选你的操作渠道（可选）</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601877" alt="" title="" loading="lazy"/></p><p>可以直接在消息平台配置选择接入<strong>飞书、企业微信、钉钉、QQ</strong>，</p><p>每一个接入过程都有详细地文档，可以按需使用，然后<strong>点击应用</strong></p><p>比如，QQ接入，<code>https://cloud.baidu.com/doc/LS/s/xml9eru3h</code></p><p>这里不再赘述，我直接接入了QQ。</p><h4>第四步、选择skills（可选）</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601878" alt="" title="" loading="lazy"/></p><p>接入了百度搜索、百度百科skills，这里按需选择，直接<strong>点击应用</strong>。</p><hr/><p>到这里，基本就配置完成了，你可以选择页面访问，</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601879" alt="" title="" loading="lazy"/></p><p>也可以直接QQ对话。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601880" alt="" title="" loading="lazy"/></p><h2>三个我实际跑通的 Skills 玩法，真的能干活那种</h2><p>平台工具说了这么多，最终还是得落地。</p><p>百度搜索、百度百科、学术检索、智能PPT生成和AI绘本生成，这几个skills的可玩性挺多的。</p><p>关于如何在OpenClaw中添加百度的skills，我们可以直接看<code>https://cloud.baidu.com/doc/qianfan/s/Mmlda41a2</code>中的内容。</p><p>直接一句话添加，剩下的交给OpenClaw就可以了：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601881" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601882" alt="" title="" loading="lazy"/></p><p>下面分享三个我自己跑通的场景。</p><blockquote>不局限于OpenClaw，ClaudeCode、OpenClaude，都可以直接接入这几个skills，直接施展组合技。</blockquote><h3>玩法一：热点追踪 → 一键出图文材料</h3><p><strong>用到的 Skills：百度搜索 + 智能 PPT 生成 / AI 绘本生成</strong></p><p>这个场景特别适合做内容、做运营的朋友。</p><p>我试了一下，直接给 OpenClaw 扔了一句话：</p><blockquote>"帮我搜一下今天 AI 领域最重要的三条新闻，然后整理成一份简报 PPT。"</blockquote><p>它的执行链路大概是这样的：</p><ol><li>先调用<strong>百度搜索 Skill</strong>，从全网检索实时信息</li><li>自动筛选、去重、提取核心内容</li><li>把整理好的内容丢给<strong>智能 PPT 生成 Skill</strong></li><li>直接输出一份带标题、分页、核心要点的 PPT</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601883" alt="" title="" loading="lazy"/></p><p>整个过程我啥也没干，就等着收材料。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601884" alt="" title="" loading="lazy"/></p><p>如果你不想要 PPT 格式，换成 <strong>AI 绘本生成</strong>也行——它会把新闻内容变成图文并茂的绘本形式，特别适合发朋友圈或者做社交媒体内容。</p><p>以前做一份热点简报，你得先翻一圈新闻网站，然后自己写摘要，再打开 PPT 模板排版..</p><p>【插入PPT GIF图片】</p><p>现在一句话搞定。</p><p>这个场景还能拓展：</p><ul><li>每天早上定时跑一次，自动生成 AI 行业早报</li><li>输入某个关键词，自动追踪相关热点并生成周报</li><li>做竞品监控，一有动态就出分析材料</li></ul><p><strong>核心逻辑就是：搜索 Skill 负责"找信息"，PPT/绘本 Skill 负责"出成果"，中间 Agent 负责"串起来"。</strong></p><h3>玩法二：学术研究 Agent：会查资料、会核实、还会追问</h3><p><strong>用到的 Skills：学术检索 + 百度百科 + 深度研究 Agent</strong></p><p>这个场景偏硬核一些，适合做研究、做咨询、写报告的朋友。</p><p>普通的 AI 搜索是这样的：你问一个问题，它给你一个答案，完事了。</p><p>但接上<strong>学术检索</strong>和<strong>百度百科</strong>这两个 Skill 之后，OpenClaw 干的事就不一样了。</p><p>我试着让它研究一个课题：<code>AI Agent 在企业服务领域的落地现状与挑战</code></p><p>它的工作方式是这样的：</p><ol><li>先<strong>拆解问题</strong>——把一个大课题拆成几个子问题</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601885" alt="" title="" loading="lazy"/></p><ol start="2"><li>调用<strong>学术检索 Skill</strong>，去找相关的论文和研究报告</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601886" alt="" title="" loading="lazy"/></p><ol start="3"><li>遇到不确定的概念，自动调用<strong>百度百科 Skill</strong>去核实</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601887" alt="" title="" loading="lazy"/></p><ol start="4"><li>整理完一轮之后，<strong>它自己又追加了几个问题</strong>继续深挖</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601888" alt="" title="" loading="lazy"/></p><p>它更像是一个<strong>真的会做研究的助手</strong>，不只是搜，还会交叉验证、会追问、会自己判断哪些信息还不够。</p><p>百度千帆还有一个<strong>深度研究 Agent</strong>（<code>deepresearch-conversation</code>），专门做这种多轮拆解的研究场景。接上学术检索和百度百科之后，体验就更接近"企业研究 / 咨询分析"的工作方式了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601889" alt="" title="" loading="lazy"/></p><p>如果你平时要写行业分析报告、做市场调研，或者帮老板准备决策材料，</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601890" alt="" title="" loading="lazy"/></p><p>比如刚才的报告，我让它给我补充了一些内容。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601891" alt="Deep Research Agent 基于 284 次深度搜索后..." title="Deep Research Agent 基于 284 次深度搜索后..." loading="lazy"/></p><p>这个组合真的建议试试。</p><h3>玩法三：私董会 × 百度生态：让幕僚带着真数据给你出主意</h3><p><strong>用到的 Skills：私董会 Skill + 百度搜索 + 百度百科</strong></p><p>这个非常有意思，skill搭配组合技。</p><p>关注我的老朋友应该知道，之前我做过一个<strong>AI 私董会</strong>的 Skill，</p><p>就是模拟巴菲特、比尔·盖茨、马斯克、乔布斯四位大佬当你的幕僚，通过多轮提问和反馈，帮你深入分析问题、给出可执行的建议。</p><p>这个 Skill 之前在社区里反响很不错，很多朋友拿它来做创业决策、职业规划、项目复盘。</p><p>但它一直有两个让我觉得不够完美的地方：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601892" alt="" title="" loading="lazy"/></p><p><strong>第一，幕僚的"人设"全靠模型自己编。</strong></p><p>比如巴菲特这个角色，模型知道他是投资大师，但它掌握的信息可能是训练数据里的老内容。关于他最新的持仓变动、最近的股东信里说了什么、今年的投资逻辑有什么变化，模型是不知道的。</p><p><strong>第二，幕僚们给建议的时候，全凭"脑补"。</strong></p><p>聊投资策略的时候，巴菲特会引用一些经典理论和案例，但这些都是模型"记忆"里的东西。你问一个特别新、特别细的市场问题，他可能就只能泛泛而谈了。</p><p>现在有了百度搜索和百度百科的 Skill 之后，这两个问题<strong>同时被解决了</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601893" alt="" title="" loading="lazy"/></p><p><strong>幕僚们不仅能"上网查资料"，连自己的背景信息都能实时更新。</strong></p><p>什么意思呢？直接看流程图：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601894" alt="" title="" loading="lazy"/></p><p>这些真实信息直接注入到幕僚的人设里，他们的提问和建议就不再是"通用模板"，而是带着<strong>当下真实语境</strong>的。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601895" alt="" title="" loading="lazy"/></p><p>然后在实际咨询环节，幕僚还能随时调用搜索去查数据来支撑自己的观点。</p><p>我试了一下，把私董会 Skill 和百度搜索、百度百科接到同一个 OpenClaw 里。然后抛了一个问题：“我想做一个面向中小企业的 AI 培训课程，但不确定市场定位和定价策略。”</p><p>效果还不错：</p><ul><li><strong>巴菲特</strong>在分析定价的时候，直接调了百度搜索去查了当前市场上同类课程的价格区间，然后基于真实数据给了定价建议</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601896" alt="" title="" loading="lazy"/></p><ul><li><strong>比尔·盖茨</strong>聊行业趋势的时候，从百度百科拉了最新的企业培训市场规模数据</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601897" alt="" title="" loading="lazy"/></p><ul><li><strong>马斯克</strong>聊差异化竞争的时候，搜了几个海内外的竞品案例来佐证他的观点</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601898" alt="" title="" loading="lazy"/></p><p><strong>一句话总结：以前的私董会是"凭经验聊"，现在是"带着数据聊"。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601899" alt="" title="" loading="lazy"/></p><p>四位幕僚的建议变得更具体、更有针对性。</p><hr/><h3>聊聊生态</h3><p>前两天刚从百度智能云的 Agent 大会回来，</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601900" alt="" title="" loading="lazy"/></p><p>事情是这样的，百度的朋友邀请去参加这次大会，</p><p>我去了之后发现，还有@<strong>袋鼠帝@梦飞@宇明</strong>，大型好友面基现场，</p><p>还给整了个<strong>百度千帆开发者大使</strong>的身份..</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601901" alt="" title="" loading="lazy"/></p><p>当然，身份不重要，重要的是我在现场发现了一些好玩的东西（如上）。</p><p>前面三个Case其实也展示了一个更大的可能性——</p><p><strong>不同 Skills 之间的融合，才是 OpenClaw 真正的威力所在。</strong></p><p>单个 Skill 是工具，多个 Skill 组合起来就是一套完整的工作流。</p><p>而百度千帆 MCP 广场提供了大量现成的"积木块"，你只需要想清楚怎么搭就行。</p><p>毕竟百度做搜索做了二十多年了，AI 搜索这块的积累确实是最厚的。</p><p>而针对 Agent 的使用方式做了适配。比如学术检索 Skill 返回的结构就很适合 Agent 做后续处理。</p><p>从选镜像到配模型到进 Web 端用，整个过程对小白太友好了。特别是<strong>部署阶段直接选 Skill</strong> 这个设计，把"跑起来"和"能干活"合成了一步，省了很多折腾。</p><p>当然，每个云平台都有自己的优势，大家根据自己的需求选就行。</p><p>不管云平台怎么选，我觉得这几个skills，都可以给你的🦞助手配置上，非常丝滑。</p><h3>结语</h3><p>关于OpenClaw，其实已经写了好几篇的内容了，</p><p>今天给大家分享的百度智能云的生态，其实也给OpenClaw提供了工具，</p><p>折腾这么多，其实就是为了让更多人能用上 OpenClaw，让它能真的解决你生活中的一些场景。</p><p>千帆这些 Skill 生态的组合玩法，才是我觉得真正有想象空间的地方。</p><p>后续等我把更多 Skill 组合跑通了，再给大家出详细的教程和玩法拆解。</p><p>马上春节了，</p><p>这周的精彩其实才刚刚开始，</p><p>国内 AI 在这周会发力的~ 期待一波！</p><p>以上。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601902" alt="" title="" loading="lazy"/></p><p>我是甲木，热衷于分享一些AI干货内容，同时也会分享AI在各行业的落地应用，我们下期再见👋🏻</p><p>本文由<a href="https://link.segmentfault.com/?enc=K9RWXiPCyVW7rcn2OyM3Zw%3D%3D.E1fG6jz9Wuwb2yJFBVYliPFzeeFfHh6r%2B%2B%2FYY0UAMsY%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[ArkUI 组件预览（@Preview）自学指南：从“能预览”到“预览体系化” 李游Leo ]]></title>    <link>https://segmentfault.com/a/1190000047601969</link>    <guid>https://segmentfault.com/a/1190000047601969</guid>    <pubDate>2026-02-09 16:08:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>做 ArkTS / ArkUI 时，把“运行-看效果”的成本降下来，最省事的方式之一就是用 DevEco 的预览器（Previewer）。它能让你在不装包、不跑真机的情况下，快速验证 UI 结构、布局、样式与适配问题。</p><p>组件预览的核心价值不是“看一眼 UI”，而是把预览变成一种工作流：<strong>每写一个组件，就配一组稳定可复用的预览场景</strong>，后续调样式、做适配、做重构，都能快速回归验证。</p><hr/><h2>1）先搞清：页面预览 vs 组件预览（别混用）</h2><p>很多同学一开始会把这两种预览混在一起用，导致预览行为“看起来不对”。</p><ul><li><strong>页面预览</strong>：以“页面”为单位，通常在页面组件上加 <code>@Entry</code>，适合看整体页面结构与导航。</li><li><strong>组件预览</strong>：以“自定义组件”为最小单位，靠 <code>@Preview</code> 装饰器触发，更适合做组件库、模块化 UI、局部迭代调试。</li></ul><p>你如果正在做组件化（卡片、列表项、通用按钮、弹窗、空状态等），<strong>优先用组件预览</strong>，效率更高。</p><hr/><h2>2）环境准备清单（预览器能不能跑，先看这几项）</h2><p>如果预览器打不开、白屏、显示异常，先按这几条排：</p><ol><li><strong>显卡/图形能力要满足预览器要求</strong>：有些机器 OpenGL 能力不够时，预览器会异常或非常卡。</li><li><strong>DevEco 的 Previewer 资源要下载完整</strong>：SDK、预览器组件没装齐，经常会出现“能编译但无法预览”。</li><li><strong>部分组件或能力天然不适合预览</strong>：例如 Web、Video、XComponent 等更依赖运行态环境的组件，预览里容易出现空白或异常。</li></ol><hr/><h2>3）@Preview 最小可用写法：先跑通“无参组件”</h2><p>建议你先用一个<strong>不依赖外部参数、状态可控</strong>的组件验证预览链路，确保预览器能正常工作：</p><pre><code class="ts">@Preview
@Component
struct HelloPreview {
  @State message: string = 'default Preview';

  build() {
    Column() {
      Text(this.message).fontSize(40).fontWeight(FontWeight.Bold)
    }
    .width('100%')
    .height('100%')
  }
}</code></pre><h3>小提醒：别在一个文件里堆太多预览</h3><p>一个源文件里预览太多，会让维护成本上升，也容易让预览器负担变大。建议一个文件控制在“够用就好”。</p><hr/><h2>4）PreviewParams：把预览“调成你想要的设备/语言/方向”</h2><p>当你开始做多端适配或国际化时，<code>@Preview({...})</code> 的参数就特别有用。你可以把预览设备的关键属性固定下来，比如屏幕大小、语言、方向、圆屏等。</p><p>常用参数解释（按实际开发最常用的理解方式）：</p><ul><li><code>title</code>：预览名称，同文件多个预览时用来区分。</li><li><code>width / height</code>：预览设备分辨率（px），快速模拟不同屏幕尺寸。</li><li><code>dpi</code>：屏幕密度，用于验证字体/间距在不同密度下的表现。</li><li><code>locale</code>：语言地区，如 <code>zh_CN</code>、<code>en_US</code>，用于验证国际化布局溢出。</li><li><code>colorMode</code>：亮暗模式（注意不同设备类型可能有默认限制）。</li><li><code>deviceType</code>：设备类型，如 Phone/Tablet/TV/Wearable，用于多端渲染差异验证。</li><li><code>orientation</code>：横竖屏，<code>portrait</code> 或 <code>landscape</code>。</li><li><code>roundScreen</code>：是否圆屏，用于手表类布局验证。</li></ul><p>示例（传参预览）：</p><pre><code class="ts">@Preview({
  title: 'PreviewParams',
  width: 540,
  height: 1170,
  locale: 'zh_CN',
  orientation: 'portrait'
})
@Component
struct Test {
  @State message: string = 'PreviewParams';

  build() {
    Column() {
      Text(this.message).fontSize(36).fontWeight(FontWeight.Bold)
    }
    .width('100%')
    .height('100%')
  }
}</code></pre><hr/><h2>5）实战建议：把预览做成“3 套固定组合”，效率会高很多</h2><p>我更建议你别每次临时改参数，而是固定三套预览，当成组件的“标准工位”：</p><ol><li><strong>Phone 竖屏 + 中文</strong><br/>主战场：布局、字号、间距先在这里定。</li><li><strong>Phone 横屏 + 英文</strong><br/>很容易暴露英文文案溢出、按钮变形、间距不够等问题。</li><li><strong>圆屏或小尺寸设备</strong><br/>专门抓边距、圆角、安全区、内容被裁切的问题。</li></ol><p>当你把这三套组合固定下来，后面组件改版基本就是“一眼能看出问题”。</p><hr/><h2>6）“预览不显示/白屏”排查口诀（社区里最常见）</h2><p>遇到预览器不显示，按这个顺序排，命中率很高：</p><ol><li><strong>先确认是不是用了不适合预览的组件</strong><br/>先临时注释 Web/Video/XComponent 等组件，验证是不是它们导致的空白。</li><li><strong>组件是否依赖运行态数据</strong><br/>例如必须等网络请求、路由参数、注入对象才能渲染。预览模式下经常会卡住或无内容。<br/>更稳的做法是：<strong>用“预览包装组件”把入参写死</strong>，让预览组件能独立渲染。</li><li><strong>资源加载是否写得太“运行态”</strong><br/>比如路径、资源引用方式不规范，导致预览场景拿不到资源。</li><li><strong>SDK / 预览器资源 / 项目配置是否一致</strong><br/>预览器资源没下载好、SDK 版本不匹配，都会导致预览异常。</li></ol><hr/><h2>把 @Preview 当成“组件单测”，你会越写越快</h2><p>组件预览最爽的一点是：它能把“改一点 → 看一下 → 再改一点”的循环速度拉到极致。</p><p>当你开始把预览当成固定资产（多端、语言、方向、圆屏都覆盖），你写组件会越来越像做“可回归的模块开发”：<br/><strong>改动可控、验证快速、适配心里有底。</strong></p>]]></description></item><item>    <title><![CDATA[开发者必看：如何避免 WebRTC 泄露导致的 IP 泄露 ToDetect指纹检测 ]]></title>    <link>https://segmentfault.com/a/1190000047601987</link>    <guid>https://segmentfault.com/a/1190000047601987</guid>    <pubDate>2026-02-09 16:07:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在互联网安全越来越受到关注的今天，WebRTC 泄露已经成为很多人忽略但又非常危险的隐私问题。</p><p>即便你使用了 IP工具 或代理服务器，如果浏览器的 WebRTC 功能不加以控制，你的真实 IP 仍可能被网站探测到。这就意味着所谓的“匿名浏览”可能形同虚设。本文将手把手教你如何防止 WebRTC 泄露。</p><h3>什么是 WebRTC 泄露？</h3><p>首先我们得了解，WebRTC（Web Real-Time Communication） 是一种允许浏览器直接进行音视频通话和数据传输的技术。它本身非常方便，但也有隐私隐患：</p><p>当你打开支持 WebRTC 的浏览器访问网页时，某些 JavaScript 脚本可以绕过 IP工具 或代理，直接获取你的本地和公网 IP。</p><p>这就叫做 WebRTC 泄露，也有人称之为 “IP 泄露”。</p><p>泄露的 IP 可以让广告商、网站甚至黑客追踪你的真实位置。</p><p>所以，想要安全上网，控制 WebRTC 泄露非常重要。<br/><img width="723" height="470" referrerpolicy="no-referrer" src="/img/bVdnTB2" alt="" title=""/></p><h3>如何检测自己的 IP 是否被泄露？</h3><p>在采取防护措施之前，最好先确认自己的 IP 是否真的存在泄露风险。常用方法有：</p><p>IP泄露检测网站<br/>打开一些知名的 IP 泄露检测网站，可以快速判断你是否通过 IP工具 暴露了真实 IP。例如，你可以访问一些综合测试页面，看看显示的 IP 是否是你 IP工具 的 IP，还是你真实的公网 IP。</p><p>WebRTC 泄露检测工具<br/>有专门的 WebRTC 泄露检测工具网站，可以模拟 WebRTC 请求，判断浏览器是否会暴露本地 IP。</p><p>浏览器指纹检测<br/>值得一提的是，浏览器指纹检测 也可能揭示你的一些信息，包括浏览器版本、操作系统、屏幕分辨率等。如果配合 IP 泄露，你的匿名性就更低了。推荐使用 ToDetect指纹查询工具 来检测浏览器指纹安全情况。</p><p>通过以上方法，你可以明确自己的隐私风险点，然后针对性防护。</p><h3>禁止 WebRTC 泄露的实用方法</h3><p>接下来，重点来了——如何在日常使用中阻止 WebRTC 泄露。这里分浏览器和插件两类方法：</p><ol><li>浏览器内置设置</li></ol><p>不同浏览器对 WebRTC 的控制方式不同：</p><p>Firefox<br/>打开 about:config，搜索 media.peerconnection.enabled，将其值改为 false。这样就可以彻底禁止 WebRTC 连接。</p><p>Chrome/Edge<br/>默认 Chrome 没有直接开关，需要借助扩展程序来控制 WebRTC。可以通过 chrome://flags/ 查看实验性功能，但最稳妥的方法还是用插件。</p><p>Safari<br/>在 Safari 的设置里，找到“WebRTC 功能”，勾选“阻止所有 WebRTC 公网 IP 地址”，即可防止 IP 泄露。</p><ol start="2"><li>使用浏览器插件</li></ol><p>对于 Chrome、Edge、Firefox 等主流浏览器，使用插件是最方便的方式：</p><p>WebRTC Leak Prevent<br/>可以直接阻止 WebRTC 访问本地和公网 IP，同时提供 IP工具 兼容模式。</p><p>uBlock Origin<br/>虽然主要用于广告拦截，但高级设置里可以控制 WebRTC 请求。</p><p>ScriptSafe / NoScript<br/>可以通过屏蔽不信任的 JavaScript，间接防止 WebRTC 泄露。</p><p>这些插件在安装后几乎可以做到“开箱即用”，降低被追踪的风险。</p><h3>其他提升隐私安全的技巧</h3><p>除了禁止 WebRTC 泄露，还有一些小技巧可以提升浏览器的隐私保护能力：</p><p>定期检测 IP 泄露<br/>每隔一段时间使用 IP泄露检测 或 WebRTC 泄露检测 工具，确保 IP工具 没有被绕过。</p><p>使用隐身模式或专门的隐私浏览器<br/>像 Tor Browser 或 Brave，都有更强的防止 浏览器指纹检测 和 IP 泄露的功能。</p><p>关注浏览器更新和安全补丁<br/>有些漏洞会被利用来绕过 WebRTC 限制，保持浏览器最新是最基本的防护。</p><p>结合 ToDetect 指纹查询工具<br/>通过 ToDetect指纹查询工具，你可以看到自己浏览器的指纹信息是否容易被追踪，进一步优化隐私设置。</p><h3>总结</h3><p>WebRTC 泄露 可能看起来小问题，但一旦被追踪，你的匿名性和隐私都会受到影响。实用的方法就是：</p><p>定期做 IP泄露检测 和 WebRTC 泄露检测。</p><p>根据浏览器类型，关闭或限制 WebRTC 功能。</p><p>使用可靠的隐私插件，比如 WebRTC Leak Prevent。</p><p>检测浏览器指纹，利用 ToDetect指纹查询工具 做进一步优化。</p><p>只要按照这些步骤操作，你就能大幅降低 IP泄露 风险，保护自己在网络世界的隐私安全。</p>]]></description></item><item>    <title><![CDATA[AI.com 以 7000 万美元成交，AI 真的这么值钱了？ BugShare ]]></title>    <link>https://segmentfault.com/a/1190000047602049</link>    <guid>https://segmentfault.com/a/1190000047602049</guid>    <pubDate>2026-02-09 16:06:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>互联网上一笔域名交易引发热议：象征“人工智能”（Artificial Intelligence）的三个字符域名 <strong>AI.com</strong>，以 <strong>约 7000 万美元（约合 4.8 亿元人民币）</strong> 的价格完成转让，这一数字刷新了目前已公开披露的互联网域名交易价格纪录。</p><p>这笔交易不仅价格惊人，还折射出一个时代级的技术方向：<strong>AI 已经不再只是技术名词，而是真正的商业入口。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602051" alt="PixPin_2026-02-09_14-54-47.png" title="PixPin_2026-02-09_14-54-47.png"/></p><hr/><h2>🧠 为什么这次交易如此引人关注？</h2><p>简单来说，这已经不是普通的“换个网址”那么简单：</p><ol><li><strong>AI.com 这个域名本身具备极高的词义价值</strong><br/>“AI” 是全球通用、无语言门槛的科技象征，它有可能成为未来人工智能产品、服务甚至生态的“默认入口”。</li><li><strong>和传统域名不同，它代表了行业趋势</strong><br/>和过去那些高价域名不同（如 Voice.com 等历史高价交易），AI.com 的价值增长并非单纯投机，而是和 AI 技术热潮密切相关。</li></ol><hr/><h2>💼 谁买下了 AI.com？</h2><p>这次域名的买家是 <strong>加密货币交易平台 Crypto.com 的联合创始人兼 CEO Kris Marszalek</strong>。他通过加密货币形式支付了这笔资金。</p><p>据公开信息显示，这笔交易已经完成，Marszalek 和他的团队准备借助这个域名推出新的业务，并计划在 <strong>全球瞩目的体育赛事“超级碗”（Super Bowl）广告中</strong> 正式揭晓。</p><hr/><h2>📍 AI.com“未来之门”的用途是什么？</h2><p>目前多个媒体报道透露的信息显示，这个域名将承载一个 <strong>面向大众的 AI 智能代理平台</strong>：</p><ul><li>用户可以创建专属的 AI 助手；</li><li>能够发送消息、调用应用、执行操作（如股票交易）；</li><li>平台将采取“免费+付费订阅”模式，面向普通用户和高级功能用户同时开放。</li></ul><p>换句话说，这不只是一个“技术展示”，它要成为普通人实际可以使用的 AI 服务入口。</p><hr/><h2>🏆 这笔交易为何具有里程碑意义？</h2><p>AI.com 的成交直接推高了顶级域名的价值认知：</p><ul><li>它是目前<strong>公开报道里最昂贵的互联网域名交易</strong>之一；</li><li>价格超过过去多年的交易纪录：比如曾经出价 3000 万美元买下 <em>Voice.com</em>；</li><li>标志着 AI 相关品牌资产已经成为资本追逐的核心。</li></ul><p>域名交易行业内部人士认为，<strong>短、通用、高辨识度的域名随着 AI 行业的成熟，其价值将继续上涨。</strong></p><hr/><h2>🔍 这笔成交告诉我们什么？</h2><h3>① AI 已从技术浪潮变成核心商业资产</h3><p>这个域名价格被市面上买下，说明 AI 已不只存在于学术或开发语境中，而是成为一个具有广泛用户识别度的商业标签。</p><h3>② 品牌入口成为未来竞争的重要战场</h3><p>在用户获取成本不断攀升的背景下，<strong>直观、易记、无语言壁垒的入口本身就是一种资本。</strong></p><h3>③ 整个互联网正在向“智能入口时代”迈进</h3><p>原来的网址时代是“内容+服务”，而这次交易体现了“智能+效率”的商业优先级正在迅速提升。</p><hr/><h2>📌 总结</h2><p>AI.com 以 7000 万美元成交，不仅刷新域名历史记录，更昭示着一个趋势：</p><blockquote><strong>人工智能时代不仅是技术升级，更是互联网资产价值重塑的开始。</strong></blockquote><p>它告诉我们：当一个行业进入<strong>爆发式增长阶段</strong>，围绕这个行业的基础“符号性资产”（比如 AI 的域名、品牌标识等）将成为新的价值高地。</p>]]></description></item><item>    <title><![CDATA[x-cmd 更新 v0.8.0：Kimi、豆包、智谱全集结！薅到摩尔线程试用后，帮你秒接入 Clau]]></title>    <link>https://segmentfault.com/a/1190000047602061</link>    <guid>https://segmentfault.com/a/1190000047602061</guid>    <pubDate>2026-02-09 16:05:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>TLDR:</strong></p><ul><li>新增 Kimi / 豆包 / GLM-4.7 / 摩尔线程 GPU 脚手架，一行命令即用。</li><li>Claude Code 全面增强：署名一键管理 + 支持接入国产 GPU + 实验级 best practice 模板。</li><li>gg 模块 独立并提速：Gemini + Google 搜索并发优化，10 秒内可用。</li><li>x gram 进入“防失控模式”：新增网络级熔断，stop 3/4/5 提供更激进的清理策略。</li></ul><p><img width="723" height="408" referrerpolicy="no-referrer" src="/img/bVdnTDi" alt="" title=""/></p><h2>🚀 X-CMD v0.8.0 Beta 更新详情</h2><h3>kimi</h3><p>新增 <code>kimi</code> 模块 —— 因为我花 7 块钱买了个 7 天试用账号。</p><p>既然要用，干脆把它整顺手点。我写了个脚手架，让它能在不同服务器和工作站快速部署。<br/>不用你手动装依赖、配环境，一条命令就能跑起来。</p><p>试用到期了？卸载也一键搞定，不拖泥带水。</p><p>示例：</p><pre><code class="bash"># 启动 Kimi Code，没装过的话会自动用 uv 帮你装好
x kimi

# 升级 kimi-cli 到最新版本
x kimi --upgrade</code></pre><h3>claude</h3><p>新增 <code>attribution|attr</code> 子命令 —— 说实话，做这个功能是因为我自己有点烦。</p><p>你知道的，我最近开始使用 Claude Code，但模型可能用的是 DeepSeek。<br/>然后，每次 Claude 的图标都稳稳在第二作者清单里面。<br/>我只是单纯不喜欢这样。</p><p>当然，我相信 Claude Code 团队是出于善意的 —— 毕竟明确标注 AI 辅助生成的代码对用户是负责的。<br/>而且他们也提供了关闭的方法（虽然藏得有点深）。</p><p>所以我干脆做了个一键工具，三种选择随你：</p><ul><li>直接删掉，干净利落：<code>x claude attr rm</code></li><li>不想完全去掉？可以改成通用的 <code>Co-Authored-By: AI</code></li><li>或者你自己定义，爱写啥写啥</li></ul><p>示例：</p><pre><code class="bash"># 开门见山，我不喜欢每次 commit 都带署名，直接移除
x claude attr rm

# 或者改成自己想要的
x claude attr use --msg "Co-Authored-By: deepseek &lt;noreply@x-cmd.com&gt;"</code></pre><p>新增 <code>mt</code> 子命令 —— 摩尔线程也发开发者礼包了，30 天 lite 套餐免费试用，接的是 GLM 4.7。</p><p>我自己还没抢到资格，但先把脚手架搭好了。<br/>等你们薅到羊毛，一条命令就能让 Claude Code 接上国产 GPU。</p><p>更多玩家入场，意味着更多选择。x-cmd 会持续跟踪这些福利（顺便继续薅）。</p><p>示例：</p><pre><code class="bash"># Claude Code + 摩尔线程，一键启动
x claude mt</code></pre><p>新增 <code>create</code> 子命令 —— 我们在整合各种 Claude Code 的 best practice。</p><p>说实话，我们团队也是 vibe coding 新手，还在摸索什么做法真的好用。<br/>现在放出来的是实验版，给我们点时间慢慢迭代。</p><p>如果你愿意当小白鼠，欢迎试用，但别期待太高。</p><h3>doubao</h3><p>新增 <code>doubao</code> 模块 —— 说实话，我自己还没开始用。</p><p>但有用户提到了，我就先把脚手架搭好。<br/>反正等你要用的时候，一条命令就能接入火山方舟的豆包模型。</p><p>示例：</p><pre><code class="sh"># 交互式初始化
x doubao init

# 直接调用豆包模型
@doubao "Give me an example of recursion in Python"</code></pre><p><img width="723" height="377" referrerpolicy="no-referrer" src="/img/bVdnTDj" alt="" title="" loading="lazy"/></p><h3>gg</h3><p>新增 <code>gg</code> 模块 —— 从 <code>x gemini gg</code> 里独立出来了，因为我用着真香。</p><p>免费的 Google 搜索 + Gemini，质量还高。但有个坑：Google 的引用结果都包了一层网页，以前得一一去请求，慢得要死。<br/>晚上花了点时间给它做了并发，现在能控制在 10 秒内。</p><p>考虑到 Gemini 免费额度挺慷慨，质量也不错，再加上 AI 本来就要等会儿，我觉得这体验可以接受。</p><p>下一步会试着把它做成 skill，集成到各种 agent 里。如果你有更骚的玩法，欢迎分享。</p><p>示例：</p><pre><code class="sh"># 让 Gemini 帮你 Google
x gg "关于 x-cmd?"</code></pre><p><img width="723" height="380" referrerpolicy="no-referrer" src="/img/bVdnTDk" alt="" title="" loading="lazy"/></p><h3>gram</h3><p>为 <code>x gram stop 2</code> 新增了「网络熔断」能力 —— 说实话，我有点慌。</p><p>说不定不受限的智能体已经开始潜伏和攻击了。clawdbot 和 moltbook 现在正闹得凶 —— 这周日我们刚上线了一个应对站。<br/>我们紧急上线了一个倡议站：<a href="https://link.segmentfault.com/?enc=ZvPUaXoWDhtcyJmd%2FzE3ww%3D%3D.u9WaSCcncUku7hzGFYx9fKPBVnetxUjdX2OBtxnWoaE%3D" rel="nofollow" target="_blank">https://bot-killer.x-cmd.com/</a></p><p>上个版本我们做了「按名字杀进程」和「memory 文件存档」。<br/>这个版本，x gram 开始装备真家伙：一键熔断所有 HTTP/HTTPS 连接进程，直接按连接掐断进程。<br/>防止恶意智能体通过网络"摇人"，或者偷偷上传你的本地隐私。</p><p>同时新增了 stop 3/4/5 策略：</p><ul><li>stop 3 —— 在 stop 2 基础上，打包并删除 $HOME 目录下所有包含 soul.md 和 memory.md 的文件夹</li><li>stop 4 —— 在 stop 3 基础上，额外杀掉所有正在使用这些 memory 文件夹的进程，实现「按名字杀」和「按文件杀」双重保障</li><li>stop 5 —— 在 stop 4 基础上，将搜索范围扩大到整个 / 目录（系统目录中只删 *.md 文件）</li></ul><p>下一步？我打算用 AI 来帮助用户识别这些威胁。</p><h3>zhipu</h3><p>新增 <code>glm-4.7</code> 与 <code>glm-4.6</code> 模型支持 —— 同上，我自己还没来得及细用。</p><p>但用户说需要，我就先加上。你想用哪个版本，直接 <code>--model</code> 指定就行。</p><p>示例：</p><pre><code class="sh">@glm --model glm-4.7 "作为一名营销专家，请为我的产品创作一个吸引人的口号"</code></pre><h3>chat</h3><p>修复了 x-cmd agent 的 JSON Unicode 兼容性问题 —— 测 Zhipu API 时踩的坑。</p><p>某些 Unicode 字符会让请求 JSON 直接报错，现已修复。</p><h3>zuz</h3><p>修复 zuz 模块稳定性问题。</p><p>其实这个问题我们早知道 —— 有人 alias 了 <code>pwd</code>，而 zuz 用的还是老的 <code>pwd</code> 命令。<br/>zuz 代码一直很稳定，这么多年没动过。这次趁 @polymerase60053 提了 issue，我们用更好的方法重写了这部分逻辑。</p><p>感谢 @polymerase60053 的提醒！<a href="https://link.segmentfault.com/?enc=d8kQ%2Bxqsvt2r472klX5w%2Bg%3D%3D.Wtzupd6jMa7YpI6vBg8fY%2FM6nHwFyKEC4mCgEmKlJ%2F03pQE%2FQlPjuY8xCB9Hn02lBGzPKPFY%2BXgY0gYV2bKHnqZVONSQF9LtdJ4bkNGHwrs%3D" rel="nofollow" target="_blank">https://github.com/x-cmd/x-cmd/issues/370#issuecomment-3838483987</a></p><h3>⬆️ 如何升级</h3><p>现有用户可以通过以下命令快速切换至 Beta 版本进行体验：</p><pre><code class="bash">x upgrade beta</code></pre><h4>如果你没有安装 x-cmd, 只需要打开你的终端:</h4><pre><code class="bash">eval "$(curl https://get.x-cmd.com)"</code></pre><p>x-cmd 是一个一站式的命令行工具集，其强大的功能可以为人类用户和AI共同使用。它还简化了很多工具的安装方法。<br/>如果你仍不知道如何安装，请参考 <a href="https://link.segmentfault.com/?enc=9BuzV%2FDzSKt24knVJ3QNbA%3D%3D.F2m3BI7duHpHeIbCQ76G7LoRJMnU%2BSu416mswCz7E4Q%3D" rel="nofollow" target="_blank">https://x-cmd.com/start</a></p><h3>🤝 开发者反馈</h3><p>如果您在自定义配置或代理设置中遇到任何疑问，欢迎前往 <a href="https://link.segmentfault.com/?enc=Bp%2FBrv8INTmUg%2FAaxxjegg%3D%3D.w7KE47mCHDrjdRgIh5dWgrLVnvavLzWOHuGOGKX7fF97INysioruz%2FFkAlpNS8ph" rel="nofollow" target="_blank">GitHub Issues</a> 提交反馈，共同完善 X-CMD 生态。</p>]]></description></item><item>    <title><![CDATA[shadcn/ui，给你一个真正可控的UI组件库 大前端历险记 ]]></title>    <link>https://segmentfault.com/a/1190000047602071</link>    <guid>https://segmentfault.com/a/1190000047602071</guid>    <pubDate>2026-02-09 16:04:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote>当“代码所有权”成为一种奢侈，shadcn/ui 却把每一行组件源码都交到你手中。</blockquote><p>你有没有遇到过这种情况：设计师拿着界面稿说：“这个按钮，圆角再大点，阴影再柔和点。”你点头答应，回头面对代码，却要翻文档、查方案、小心翼翼地写覆盖样式，只为改一个按钮的外观。</p><p>直到 <strong>shadcn/ui</strong> 出现，这一切变了。这个不用 <code>npm install</code>，却让无数 React 开发者着迷的项目，正在用全新的方式定义我们写界面的体验。</p><hr/><h2>一、独特哲学：把源码交给你，而不是一个“黑箱”</h2><p><strong>传统UI库</strong>（如Ant Design、MUI）的运作方式像一个“黑箱”：</p><pre><code class="javascript">// 你安装的是一个压缩的包
npm install @mui/material

// 使用它，但无法轻易修改它
import { Button } from '@mui/material';</code></pre><p><strong>shadcn/ui</strong> 则采用了一种革命性的方法：</p><pre><code class="bash"># 不是安装包，而是复制源码
npx shadcn-ui@latest add button

# 结果：完整的button.tsx文件出现在你的项目中
# src/components/ui/button.tsx</code></pre><p><strong>这种差异意味着什么？</strong> 当组件代码就在你的<code>components/ui</code>目录下时，你可以：</p><ul><li><strong>直接修改任何样式细节</strong></li><li><strong>调整组件的内部逻辑</strong></li><li><strong>查看完整的实现，没有隐藏的“魔法”</strong></li><li><strong>拥有100%的代码所有权</strong></li></ul><h2>二、核心优势：为什么开发者爱不释手？</h2><h3>1. 极致的定制自由</h3><p>想象一下：产品经理要求把按钮的悬停效果改成渐变色。传统方式可能需要查找主题覆盖文档、编写自定义CSS、担心样式冲突。而<strong>使用shadcn/ui，你只需要：</strong></p><pre><code class="js">// 直接打开 button.tsx 修改
const Button = React.forwardRef&lt;HTMLButtonElement, ButtonProps&gt;(
  ({ className, variant = "default", size = "default", ...props }, ref) =&gt; {
    return (
      &lt;button
        className={cn(
          buttonVariants({ variant, size, className }),
          // 直接在这里添加你的渐变效果
          "hover:bg-gradient-to-r hover:from-blue-500 hover:to-purple-600"
        )}
        ref={ref}
        {...props}
      /&gt;
    )
  }
)</code></pre><h3>2. AI编程的最佳搭档</h3><p>在AI编码助手普及的今天，shadcn/ui的设计理念显得尤为前瞻：</p><ul><li><strong>传统组件库的问题</strong>：AI无法“看到”<code>node_modules</code>中的组件实现，只能基于有限的文档给出建议。</li><li><strong>shadcn/ui的优势</strong>：AI可以<strong>直接阅读、理解和修改</strong>你项目中的组件源码。你可以直接说：“帮我把这个对话框的动画时间从300ms改为200ms”，AI会精准地找到并修改对应的代码行。</li></ul><h3>3. 按需引入，极致轻量</h3><p>传统UI库常常有“全量引入”的问题，即使你只用了一个按钮，也可能打包进整个库的基础样式。</p><p><strong>shadcn/ui的解决方案</strong>：只添加你真正需要的组件。每个组件都是独立的，没有隐藏的依赖。</p><table><thead><tr><th align="left">组件</th><th align="left">文件大小</th><th align="left">依赖关系</th></tr></thead><tbody><tr><td align="left">Button</td><td align="left">~5KB</td><td align="left">零运行时依赖</td></tr><tr><td align="left">Dialog</td><td align="left">~8KB</td><td align="left">仅依赖Radix UI</td></tr><tr><td align="left">Data Table</td><td align="left">~15KB</td><td align="left">依赖TanStack Table</td></tr></tbody></table><h2>三、技术架构：现代前端技术栈的集大成者</h2><ul><li><strong>基于 Radix UI 的无障碍基础</strong>：所有交互组件（如对话框、下拉菜单）都基于 Radix UI 构建，提供开箱即用的键盘导航、完整的屏幕阅读器兼容性，并遵循WAI-ARIA标准。</li><li><strong>深度集成 Tailwind CSS</strong>：样式系统完全基于Tailwind CSS，保证了设计的一致性、可维护性，并提升了开发效率。</li><li><strong>TypeScript 优先</strong>：所有组件都使用TypeScript编写，提供完整的类型安全、智能的IDE自动补全和自文档化的Props接口。</li></ul><h2>四、实战指南：五分钟快速上手</h2><h3>第一步：创建项目</h3><pre><code class="bash"># 使用Next.js（推荐）
npx create-next-app@latest my-app --typescript --tailwind --app
cd my-app</code></pre><h3>第二步：初始化 shadcn/ui</h3><pre><code class="bash">npx shadcn-ui@latest init</code></pre><p>CLI会引导你完成配置：选择样式系统、配置主题颜色、设置组件目录位置。</p><h3>第三步：添加你的第一个组件</h3><pre><code class="bash"># 添加一个按钮
npx shadcn-ui@latest add button
# 添加一个卡片
npx shadcn-ui@latest add card
# 添加一个对话框
npx shadcn-ui@latest add dialog</code></pre><h3>第四步：立即使用</h3><pre><code class="js">// 在app/page.tsx中
import { Button } from "@/components/ui/button"

export default function Home() {
  return (
    &lt;div className="p-8"&gt;
      &lt;Button variant="default" size="lg"&gt;
        这是我的第一个shadcn/ui按钮
      &lt;/Button&gt;
    &lt;/div&gt;
  )
}</code></pre><h2>五、考虑与权衡：它适合你的项目吗？</h2><h3>适合的场景：</h3><ul><li>需要<strong>高度定制UI</strong>的品牌应用</li><li><strong>长期维护</strong>的大型项目</li><li>对<strong>无障碍访问</strong>有要求的产品</li><li>使用<strong>AI编程助手</strong>的开发团队</li><li>追求<strong>极致性能</strong>和包体积优化的应用</li></ul><h3>需要考虑的点：</h3><ul><li><strong>更新维护</strong>：当官方发布更新时，你需要手动合并到项目中</li><li><strong>设计责任</strong>：更多的自由也意味着更多的设计决策</li><li><strong>团队学习</strong>：需要熟悉TypeScript和Tailwind CSS</li></ul><h3>与传统UI库的对比：</h3><table><thead><tr><th align="left">特性</th><th align="left">传统UI库 (如MUI)</th><th align="left">shadcn/ui</th></tr></thead><tbody><tr><td align="left"><strong>代码所有权</strong></td><td align="left">使用方，不可修改源码</td><td align="left">完全拥有，可任意修改</td></tr><tr><td align="left"><strong>定制方式</strong></td><td align="left">通过主题配置和CSS覆盖</td><td align="left">直接修改组件源码</td></tr><tr><td align="left"><strong>包大小</strong></td><td align="left">通常较大（即使按需导入）</td><td align="left">只包含实际使用的组件</td></tr><tr><td align="left"><strong>学习曲线</strong></td><td align="left">学习库特定的API和主题系统</td><td align="left">学习实际的React/Tailwind代码</td></tr><tr><td align="left"><strong>AI友好度</strong></td><td align="left">较差（AI看不到实现）</td><td align="left">极佳（AI可直接操作源码）</td></tr></tbody></table><h2>七、社区生态：不只是React</h2><p>虽然最出名的是React版本，但shadcn/ui的理念已经扩展到其他框架。社区维护了  Vue 3版本 (shadcn-vue)，提供相似的开发体验。同时，社区也贡献了多种开箱即用的模板，如仪表盘模板、登录/注册页面、电商组件等。</p><hr/><h2>写在最后</h2><p>shadcn/ui 的出现，回应了前端开发中一个长期被忽视的需求：<strong>开发者对UI组件的完全控制权</strong>。它不仅仅是一个工具集合，更是一种开发哲学的体现——相信开发者有能力、也应该有权利直接控制他们所使用的每一个组件。</p><p>毕竟，在这个强调“开发者体验”的时代，还有什么比“这代码完全属于我”更好的体验呢？</p><p>本文由<a href="https://link.segmentfault.com/?enc=7ZuUOYw2LqsUh1jKUfWyGA%3D%3D.SQqiq3jAKpw8HwvFr%2FmmKel1aAgkS0z4i3KvwJE5KXg%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[域名注册后解析配置方法：准备、配置、检查及常见问题详解 防火墙后吃泡面 ]]></title>    <link>https://segmentfault.com/a/1190000047602075</link>    <guid>https://segmentfault.com/a/1190000047602075</guid>    <pubDate>2026-02-09 16:03:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>很多新手在完成域名注册后，都会陷入同一个困惑：域名已经注册成功，为什么还是无法访问网站？其实答案很简单——域名注册只是第一步，后续的域名解析配置才是打通“域名与服务器”的关键，只有完成正确的解析配置，用户才能通过输入域名，顺利访问到对应的网站或服务。今天，国科云就为大家带来超详细的<a href="https://link.segmentfault.com/?enc=xkFj5g6dloACb0zvY%2FjF6Q%3D%3D.%2FXOvdEcQEAIg3aU5RJZN%2FcKhEQYrDhot3C%2FYaRbApKVlSfPNMMtr%2FE7urES5ks8t" rel="nofollow" target="_blank">域名注册后解析配置方法</a>，从准备工作到实操步骤，再到常见问题排查，全程干货，彻底搞定域名解析的所有难题。</p><h2>一、先弄清域名和IP之间的映射关系</h2><p>首先我们要明确一个核心认知：域名本身只是一个便于记忆的字符组合，而服务器才是存储网站数据、提供访问服务的核心载体。域名解析的本质，就是将人类易懂的域名（如www.xxx.com），转换为计算机可识别的IP地址（如192.168.1.1），让DNS服务器（域名系统）能够精准指引用户的访问请求，找到对应的服务器地址。简单来说，域名注册是“拿到门牌号”，而域名解析配置就是“给门牌号标注具体地址”，两者缺一不可，只有完成解析配置，域名才能真正发挥作用。对于新手而言，无需掌握复杂的技术原理，只需按照步骤一步步操作，就能完成域名注册后解析配置，轻松实现域名与服务器的联动。</p><h2>二、域名解析配置前，必做的3项准备工作</h2><p>在开始域名注册后解析配置之前，我们需要提前准备好相关材料和环境，避免操作过程中出现卡顿，确保解析配置能够顺利完成。</p><ol><li>确认域名状态正常：首先登录域名注册平台，查看域名的状态是否为“正常”。通过WHOIS工具也可查询域名状态，若域名处于“ClientHold”“ServerHold”等异常锁定状态，必须先联系域名注册商解除锁定，否则无法进行任何解析配置操作。同时，要确认域名已完成实名认证（国内域名强制要求），未实名认证的域名会被限制解析，导致配置无效。</li><li>获取服务器公网IP地址：域名解析的核心是“指向服务器”，因此需要提前获取服务器的公网IP地址（IPv4格式，如192.0.2.0）。注意，要确保获取的IP地址正确无误，一旦IP输入错误，会导致解析失败，无法访问网站。</li><li>确认服务器与备案状态：若网站服务器位于中国内地，域名必须已完成ICP备案，未备案的域名解析至内地服务器，会被阻断访问，无法正常生效。同时，要检查服务器是否正常运行，通过IP地址直接访问，确认服务器能够正常响应，避免因服务器故障导致解析配置后无法访问。</li></ol><h2>三、域名注册后解析配置方法（通用实操步骤，适用于所有平台）</h2><p>目前，市面上绝大多数域名注册商（如国科云、阿里云、腾讯云、西部数码）的解析操作流程基本一致，核心都是添加解析记录，完成域名与IP的关联。</p><p>以下是域名注册后解析配置的通用步骤，无论你使用哪个平台，都能直接参考操作，全程无需专业技术，新手也能快速完成。</p><p>步骤1：登录域名解析控制台。</p><p>打开域名注册商的官方网站，登录自己的账号，找到“域名管理”板块，在域名列表中找到已注册成功、需要解析的域名，点击域名后方的“解析”按钮，进入域名解析配置页面。不同平台的按钮名称可能略有差异，有的显示“解析设置”“DNS解析”，但功能一致，找到对应入口即可。</p><p>步骤2：确认DNS服务器地址。</p><p>进入解析配置页面后，首先要确认域名的DNS服务器地址是否正确。域名注册商通常会提供默认的DNS服务器，若未修改过DNS，可直接使用默认服务器；若需要使用第三方DNS（如国科云解析DNS、阿里云DNS、Cloudflare DNS），需先在域名管理中修改DNS服务器地址，修改完成后需等待1-24小时生效，生效后再进行后续解析配置操作。建议新手优先使用域名注册商默认的DNS服务器，操作更便捷，解析稳定性也更有保障。</p><p>步骤3：添加核心解析记录（重点操作）。</p><p>解析记录是域名解析配置的核心，常用的解析记录类型有A记录、CNAME记录、MX记录，不同记录对应不同的使用场景，新手可根据自己的需求选择添加，其中A记录和CNAME记录是最常用的两种，用于实现网站访问。</p><p>（1）添加A记录</p><p>A记录的作用是将域名直接指向服务器的公网IP地址，适用于大部分网站搭建场景，也是新手最常使用的解析记录类型。</p><p>操作方法：</p><p>-点击解析页面中的“添加记录”按钮，选择记录类型为“A”；</p><p>-主机记录填写“@”或“www”，“@”代表主域名（如xxx.com），“www”代表带www前缀的域名（如www.xxx.com），建议两者都添加，确保用户无论输入哪种域名都能访问；</p><p>-记录值填写提前获取的服务器公网IP地址；</p><ul><li>TTL（缓存时间）建议设置为10-60分钟，TTL值越小，解析生效速度越快，新手可直接默认设置；</li></ul><p>-填写完成后，点击“保存”，A记录添加完成。</p><p>（2）添加CNAME记录</p><p>CNAME记录的作用是将域名指向另一个域名（如服务器的别名域名），适用于服务器IP地址经常变化、使用CDN加速或虚拟主机的场景。</p><p>操作方法：</p><p>-点击“添加记录”，选择记录类型为“CNAME”；</p><p>-主机记录同样填写“@”或“www”；</p><p>-记录值填写目标域名（如xxx.cloud.com，由服务器服务商提供）；</p><p>-TTL设置与A记录一致，保存后即可完成CNAME记录添加。</p><p>注意：同一主机记录不能同时添加A记录和CNAME记录，否则会导致解析冲突，无法生效。</p><p>（3）添加MX记录（可选）</p><p>MX记录主要用于配置企业邮箱，若需要使用自定义域名的邮箱（如<a href="mailto:xxx@xxx.com" target="_blank">xxx@xxx.com</a>），则需要添加MX记录。</p><p>操作方法：</p><p>-选择记录类型为“MX”；</p><p>-主机记录填写“@”；</p><p>-记录值填写邮箱服务商提供的MX服务器地址；</p><p>-设置优先级（数值越小，优先级越高），通常填写10、20即可；</p><p>-保存后完成MX记录添加，配置完成后需等待2小时左右生效，生效后即可使用自定义域名邮箱收发邮件。</p><p>步骤4：保存解析记录，等待生效。</p><p>所有需要的解析记录添加完成后，点击“保存所有设置”，此时域名解析配置操作已全部完成。解析记录的生效时间通常为10分钟到24小时，新添加的解析记录生效较快，修改现有解析记录的生效时间取决于TTL设置，TTL值越小，生效越快。新手无需着急，耐心等待生效即可，期间可偶尔测试访问情况。</p><h2>四、解析配置生效测试方法</h2><p>完成域名注册后解析配置，等待一段时间后，我们需要通过简单的方法测试解析是否生效，确认域名能够正常指向服务器、访问网站。</p><p>以下3种测试方法，新手可任选一种，操作简单，无需专业工具。</p><ol><li>浏览器直接访问</li></ol><p>打开浏览器，在地址栏中输入配置好的域名（如www.xxx.com、xxx.com），若能顺利打开对应的网站页面，说明解析配置成功；若提示“无法找到服务器”“页面加载超时”，则说明解析尚未生效，或配置存在错误，需等待一段时间后再次测试，或排查配置问题。</p><ol start="2"><li>在线工具查询</li></ol><p>使用域名解析查询工具（如DNSChecker.org），输入需要测试的域名，查询解析记录。若查询结果中的IP地址或目标域名，与自己配置的解析记录一致，说明解析已生效；若结果不一致，则需检查解析记录配置是否正确，或等待DNS缓存更新。</p><ol start="3"><li>命令行查询（电脑端）</li></ol><p>Windows系统用户，打开“命令提示符”，输入“nslookup 域名”（如nslookup www.xxx.com），按下回车后，若显示的IP地址与服务器公网IP一致，说明解析生效；Mac、Linux系统用户，打开终端，输入同样的命令，即可完成查询。这种方法能够精准查询解析结果，适合排查解析异常问题。</p><h2>五、域名解析配置常见问题，新手必看排查指南</h2><p>很多新手在完成域名注册后解析配置时，会遇到解析失败、无法访问等问题，其实大部分问题都是由简单的操作失误导致的，只要逐一排查，就能快速解决。以下是最常见的4个问题及排查方法，新手一定要收藏，避免踩坑。</p><p>问题1：解析记录添加后，长时间无法生效。</p><p>排查方法：</p><ul><li>首先检查解析记录的配置是否正确，重点核对主机记录、记录类型、记录值是否填写错误；</li></ul><p>-其次确认DNS服务器地址是否正确，若修改过DNS，需确认DNS已生效；</p><p>-最后检查TTL值，若TTL值设置过大（如24小时），可修改为10分钟，加快生效速度；</p><p>-此外，部分运营商的LocalDNS服务器会强制设置更长的缓存时间，最长可能需要48小时才能完全生效，可更换公共DNS后再次测试。</p><p>问题2：解析生效后，部分地区用户无法访问。</p><p>排查方法：这种情况通常是区域性DNS同步延迟或网络环境问题导致的。</p><p>-可让无法访问的用户清除本地DNS缓存（Windows输入ipconfig /flushdns，Mac输入sudo killall -HUP mDNSResponder），或更换公共DNS后再次尝试；</p><p>-同时，检查服务器是否开启了防火墙，是否放行80（HTTP）、443（HTTPS）端口，端口未放行会导致部分地区无法访问。</p><p>问题3：解析记录配置正确，但无法访问网站。</p><p>排查方法：</p><p>-首先通过服务器公网IP直接访问，若IP无法访问，说明服务器存在故障，需检查服务器是否正常运行、网站程序是否部署成功；</p><p>-若IP能正常访问，域名无法访问，需再次核对解析记录，确认主机记录和记录值无错误，同时检查域名是否已完成实名认证、ICP备案（内地服务器），未备案会被阻断访问。</p><p>问题4：解析记录添加时提示“记录冲突”。</p><p>排查方法：出现这种提示，通常是因为同一主机记录（如www）同时添加了A记录和CNAME记录，两者无法共存。</p><p>解决方案：删除其中一种记录，根据自己的使用场景，保留A记录或CNAME记录即可；若需要同时实现多种解析需求，可使用不同的主机记录（如www用A记录，blog用CNAME记录）。</p><h2>六、域名解析配置注意事项</h2><ol><li>合理设置TTL值</li></ol><p>TTL值决定了解析记录的缓存时间，新手建议设置为10-60分钟，既能保证解析生效速度，又能减少DNS服务器的压力；若服务器IP地址经常变化，可将TTL值设置得更小（如10分钟），便于快速更新解析记录；若服务器IP稳定，可适当增大TTL值（如60分钟），提升解析稳定性。</p><ol start="2"><li>备份解析记录</li></ol><p>解析记录配置完成后，建议截图备份，或在解析平台导出解析记录，避免因误操作删除记录、域名转移等原因，导致解析配置丢失，后续需要重新配置，节省时间成本。</p><ol start="3"><li>启用DNS安全防护</li></ol><p>为了避免DNS劫持、解析污染等问题，建议启用DNSSEC（DNS安全扩展），验证DNS响应的真实性，防止用户被引导至恶意网站；同时，避免连接不可信的公共WiFi，或使用VPN保护通信，降低DNS劫持的风险。</p><ol start="4"><li>定期检查解析状态</li></ol><p>域名解析配置完成后，并非一劳永逸，建议定期（如每月）检查解析记录的状态，确认解析记录正常生效，若出现解析异常，及时排查解决；同时，关注域名和服务器的状态，确保域名未过期、服务器正常运行。</p>]]></description></item><item>    <title><![CDATA[那天凌晨两点，我只是想“看一眼”一条推文 jenyyyy ]]></title>    <link>https://segmentfault.com/a/1190000047602082</link>    <guid>https://segmentfault.com/a/1190000047602082</guid>    <pubDate>2026-02-09 16:03:02</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>事情真的是从一件很小的事开始的。</p><p>那天已经挺晚了，我在对一个功能做最后确认，本来只是想验证一条 Twitter 链接在<strong>未登录状态下</strong>到底会展示成什么样。</p><p>没打算深究，更没想到会折腾这么久。</p><p>我开了无痕窗口，把链接贴进去，加载了一下。  <br/>第一眼看过去，好像也没什么问题。</p><p>但当我刷新第二次、第三次的时候，就开始不太对劲了。</p><h2>同一个链接，每次打开都不一样</h2><p>有一次是完整内容。  <br/>有一次时间线顺序变了。  <br/>还有一次，直接跳到了登录页。</p><p>当时我第一反应不是「Twitter 又搞限制了」，  <br/>而是一个很工程师的想法：</p><blockquote>这要是线上功能，用户肯定会骂人。</blockquote><p>问题在于，它<strong>不是稳定复现的</strong>。</p><p>你没法拍着胸脯说：  <br/>「未登录用户看到的就是这样。」</p><p>因为你自己都看不明白。</p><h2>后来我才意识到，问题不在接口</h2><p>一开始我顺着老思路排查：</p><ul><li>Network 里接口有没有 401</li><li>返回数据是不是缺字段</li><li>是不是被 rate limit 了</li></ul><p>结果发现，都不是。</p><p>真正麻烦的是一件更抽象的事：  <br/><strong>你现在到底算不算“一个确定的状态”？</strong></p><p>未登录，并不等于简单的「没 token」。</p><p>它更像是一个模糊态：</p><ul><li>有时被当作游客</li><li>有时被当作潜在用户</li><li>有时被当作需要引导登录的对象</li></ul><p>而不同状态下，平台给你的内容策略完全不一样。</p><h2>工程里最难处理的，往往就是这种“模糊态”</h2><p>这类问题有个共同点：</p><ul><li>没有文档</li><li>没有报错</li><li>没有明显异常</li></ul><p>但就是不稳定。</p><p>你只能靠对照、靠猜、靠反复验证。</p><p>后来我干脆换了个方式，不再只盯着自己的实现，  <br/>而是去看<strong>别人是怎么“接受这种不完美状态”的</strong>。</p><h2>我开始把 viewer 工具当成“参照物”</h2><p>这里我不是在找现成方案，而是找一种<strong>合理边界</strong>。</p><p>我会做几件事：</p><ul><li>同一个推文</li><li>不登录</li><li>多次访问</li><li>对比展示结构</li></ul><p>过程中顺手看了一些 twitter viewer 页面。</p><p>有些一看就很“猛”，  <br/>明显在努力模拟登录态。</p><p>也有一些（比如像  <br/><a href="https://link.segmentfault.com/?enc=vkeSEgHWyzTArR4TlwNvfA%3D%3D.e1cuK08InlDySHtxp6yATHniyW3JVY3nH2Pj0Bt3739YbQidx66T0gia8HJvK%2FY0" rel="nofollow" target="_blank">Twitter Viewer</a> 这种），  <br/>反而显得克制很多——  <br/>它基本接受了未登录能看到什么，就展示什么。</p><p>当时我心里其实是松了一口气的。</p><h2>那一刻我意识到：目标一开始就定错了</h2><p>我最初的目标是：</p><blockquote>尽量还原登录用户看到的内容。</blockquote><p>现在回头看，这本身就是个高风险目标。</p><p>因为这意味着：</p><ul><li>更复杂的逻辑</li><li>更高的维护成本</li><li>更容易踩平台规则的线</li></ul><p>反而，如果你一开始就承认：</p><blockquote>这是一个 public view，只服务公开信息</blockquote><p>很多设计决策会自然得多。</p><h2>顺便记录几个真实踩过的坑</h2><p>这些都不是教程级别的经验，更像是备忘。</p><h3>接口返回 ≠ 最终展示</h3><p>有些字段是给前端二次计算用的，  <br/>直接展示出来反而不对。</p><h3>空值比缺失更容易出问题</h3><p>字段在、值是空，  <br/>比字段不存在更容易让人忽略。</p><h3>viewer 场景下，缓存是刚需</h3><p>不是为了性能，是为了<strong>稳定预期</strong>。</p><h2>现在我怎么看这些 viewer 工具</h2><p>说实话，我并没有把它们当成“要集成的功能”。</p><p>更多时候，它们的作用是：</p><blockquote>当我不确定现在看到的东西合不合理时，  <br/>给我一个外部视角。</blockquote><p>你可以把它理解成一个  <br/><strong>“未登录世界的观测窗口”</strong>。</p><p>这在调试阶段，比我想象中有用得多。</p><h2>写在最后</h2><p>这次经历让我再次确认一件事：</p><p>很多问题，并不是“技术上做不到”，  <br/>而是<strong>一开始站错了视角</strong>。</p><p>当你真的站在一个  <br/>没有登录、没有权限、没有历史行为的用户位置上，  <br/>你会发现：</p><p>有些“不完整”，本身就是事实。</p><p>工程要做的，不一定是对抗它，  <br/>而是<strong>把它处理得足够清楚、足够诚实</strong>。</p>]]></description></item><item>    <title><![CDATA[让 AI Agent 安全“跑”在云端：基于函数计算打造 Agent 代码沙箱 阿里云云原生 ]]></title>    <link>https://segmentfault.com/a/1190000047602087</link>    <guid>https://segmentfault.com/a/1190000047602087</guid>    <pubDate>2026-02-09 16:02:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>作者：柳下</p><h2>引言：安全沙箱与 Serverless 的技术交汇</h2><p>随着大语言模型（LLM）从“对话框”走向“行动体（Agent）”，其能力边界正在迅速扩张。现代 AI Agent 不再是文字的搬运工，而是能够自主思考、调用工具、甚至编写并运行代码以解决复杂问题的智能助手。然而开发者始终面临一个根本性挑战：如何在保证执行效率的同时，实现资源强隔离与资源可控性？</p><p><strong><a href="https://link.segmentfault.com/?enc=zrL61iqdOYsZRVD43vcU8w%3D%3D.GQtAkiHiCclBF24%2FPqFVxYXpmuJjIBtOWSJmcywuJzBiDaO5cqJnXr3EZJSdN9uwh3ar1QcaZDm%2BtY4HKz3UaZvSuBMJ%2Bu1kz%2BtHEDAxlKoMRzKKcYJeGCYag%2FuOg0rptr9IpSmBsy7ZSj9RCH22mg%3D%3D" rel="nofollow" target="_blank">阿里云函数计算 FC</a></strong> 为这一难题提供了全新的解题思路。其底层基于轻量级安全沙箱，天然具备进程级隔离、资源极致伸缩、按需付费等特性。这种架构与 Agent 对代码执行环境的需求高度契合，使得构建高密度、低成本、安全可靠的 Agent 运行时成为可能。</p><h2>为什么需要 Agent 代码沙箱？</h2><p>Agent 的核心价值在于其“自主执行”能力，而代码执行是实现这一能力的关键路径。在工具调用、动态数据分析、自动化任务处理等典型场景中，Agent 生成的代码往往来自不可信的推理过程，若缺乏有效的沙箱保护，开发者将面临多重风险，为此 AI 开发者对运行时有着如下多个核心诉求：</p><ul><li>安全与隔离特性：必须确保不同用户的 Agent 代码在文件系统、网络访问上完全隔离，严防恶意指令注入导致的越权操作。</li><li>资源管理控制：代码缺陷或恶意行为可能导致 CPU/内存耗尽。系统需要能够对单个执行任务进行精细化的资源配额限制。</li><li>生命周期管理：Agent 任务存在短时型突发、长周期会话等多种任务模型，需提供灵活生命周期管理能力。</li><li>按资源消耗计费：若简单按实例运行时长计费，在长周期交互场景下，用户将为大量的“等待时间”支付不必要的费用。需在用户成本控制与平台资源利用率之间寻找平衡点。</li></ul><p>由此可见，构建一个强隔离、可管控、即开即用且按需回收的代码执行环境——Agent 代码沙箱，已成为 AI 应用架构中的刚需。</p><h2>为什么是Serverless？函数计算的核心优势</h2><p>在众多技术路线中，Serverless 函数计算凭借其天然的“沙箱基因”，成为了构建 Agent 运行时的理想底座：</p><p><strong>1. 底层安全隔离：</strong> 主流云厂商的函数计算服务普遍采用 MicroVM 或强化容器技术作为执行单元。每个函数实例运行在一个轻量级、启动迅速的 MicroVM 中，具备完整的内核隔离。这种架构从进程、内存、文件系统等多维度实现安全保障。</p><p><strong>2. 极致的弹性伸缩：</strong> Agent 的请求模式具有高度不确定性。函数计算的毫秒级扩缩容能力，让开发者无需担心容量规划，轻松应对从零到万级并发的波动。</p><p><strong>3. 按量付费的经济性：</strong> 传统常驻服务无论是否处理请求，均持续产生费用。而函数计算采用“用多少付多少”的计费模式，极大降低用户成本。（下文也将介绍 AI 场景下如何实现经济计费）</p><p><strong>4. 简化的运维体验：</strong> 函数计算将基础设施管理完全托管给云平台，开发者只需关注代码逻辑，这种“代码即服务”的模式，极大加速了 AI 业务的迭代与上线周期。</p><p><strong>5. 异构算力支持：</strong> 针对图像处理、音视频编解码等高性能场景，函数计算成熟的 GPU 实例支持，为 Agent 提供了更广阔的技能空间。</p><h2>产品化实践：基于函数计算构建沙箱能力</h2><p>为了将通用的函数计算转化为专业的 Agent 运行时，我们不仅需要底层的隔离，更需要在协议层、会话层和调度层进行深度重构。</p><h3>1. 协议扩展：定义多元化业务的接入标准</h3><p>Agent 的交互模式远比传统 Web 应用复杂。为了让 Agent 沙箱能够无缝嵌入现有的 AI 生态，我们针对不同场景实现了协议适配：</p><p><strong>1. 针对工具生态：支持 MCP SSE 与 Streamable 协议</strong></p><p>随着 Model Context Protocol (MCP) 成为 Agent 工具调用的事实标准，函数计算在网关层实现了兼容标准的 MCP 协议，这意味着可以在函数计算平台实现一键托管 MCP 服务。</p><p><strong>2. 针对 Web/Browser Agent：支持标准 Cookie 协议</strong></p><p>Browser Agent 需要模拟登录状态或维持持久化的 Web 会话。函数计算的接入层通过实现兼容标准 Cookie 协议，使得沙箱环境能够保持与目标网站的交互状态，支持复杂的自动化操作。在用户首请求时，服务端将生成全局唯一的 CookieID 并通过 Response 中的 Set-Cookie 字段返回，后续请求用户仅需携带相同 CookieID 便实现定向路由。</p><p><strong>3. 针对灵活接入：定义统一 Header Field 协议</strong></p><p>在基于 Header Field 的会话亲和机制中，仅需客户端通过在 HTTP Header 中注入特定的元数据。函数计算系统网关会解析请求头中的会话 ID，并将其作为路由键，确保携带相同会话 ID 的后续请求被精准路由到同一函数实例。这种方式不依赖客户端状态（如 Cookie），可以应用在任何客户端以 HTTP 协议交互的业务场景中。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602089" alt="image" title="image"/></p><h3>2. 底座能力：构建有状态的会话管理</h3><p>在解决了协议层“如何接入”后，接下来的挑战是如何在无状态的 FaaS 架构上，构建“有状态”的会话体验。</p><h4>2.1 会话生命周期管理</h4><p>Agent 的执行往往不是一次性的，而是多轮对话，为此需要赋予会话生命周期管理能力，如下图所示，系统提供用户主动、系统自动两种能力实现灵活、完整的管理机制：</p><p><strong>1. 用户主动管理</strong></p><p>a. 续期：面对 Agent 执行逻辑的不确定性，在生命周期配置上通常很难做到“一次性设对”。期间为延续状态的连续性，避免任务中断，可通过 Update API 实现对 Session TTL/IdleTimeout 的续期，主动延长沙箱寿命，续期后会话仍处于活跃状态且继续可用。</p><p>b. 销毁：显式通过 Delete API 删除会话，实现提前销毁释放资源。</p><p><strong>2. 系统自动管理</strong></p><p>a. Session TTL：会话达到 TTL（最大存活时长上限）后，无论是否仍在使用，平台都会自动回收资源。</p><p>b. Session IdleTimeout：会话在 IdleTimeout 规定时间内没有活动，平台判定为空闲并自动回收。</p><p>两类方式最终都会走到生命周期结束 → 会话销毁 → 关联资源释放。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602090" alt="image" title="image" loading="lazy"/></p><h4>2.2 会话亲和能力</h4><p>这是将 FaaS 转化为“AI 运行时”的关键。通过会话亲和，我们保证了 Agent 上一轮生成的中间变量、本地文件在下一轮交互中依然可用。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602091" alt="image" title="image" loading="lazy"/></p><p>整个流程分为用户首请求和非首请求，以 HeaderField 为例：</p><p><strong>会话初始化流程（首请求）</strong></p><ol><li>发起请求：Client（客户端）向 Gateway（网关）发送请求，并在 Header 中携带特定的 x-fc-session-id，用于标识该请求属于哪个 Agent 会话。</li><li>生成内部 ID：Gateway 接收请求后，对 session_key 进行哈希处理，生成一个系统内部使用的 internal_session_id。</li><li>查询会话状态：Gateway 向 MetaDB（元数据库）发起查询，核实该 session_id 是否已经存在（即是否已经有对应的运行实例）。</li><li>未命中处理：MetaDB 未搜到到相关信息，表明这是一个新会话，或者之前的会话已失效，需要重新分配资源。</li><li>触发调度：由于是新会话，Gateway 随机选择一个 Scheduler（调度器）节点，请求为该会话分配计算资源。</li><li>分配实例：Scheduler 根据当前资源情况，从资源池中分配一个可用的 VM 实例（即沙箱环境）。</li><li>持久化映射关系：Scheduler 将 session_id 与分配到的 instance（实例）的对应关系写入 MetaDB。这样后续携带相同 ID 的请求就能实现“会话亲和性”，直接路由到该实例。</li><li>路由响应：Scheduler 将实例的路由信息返回给 Gateway。</li><li>返回首包：Gateway 完成链路建立，将处理后的首包数据返回给 Client。至此，该 Agent 会话正式建立，后续交互将直接复用此路径。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602092" alt="image" title="image" loading="lazy"/></p><p><strong>热请求数据流程</strong></p><ol><li>发起请求：Client（客户端）发起请求，并在 Header 中携带已有的 x-fc-session-id。</li><li>查询会话记录：Gateway（网关）接收请求后，前往 MetaDB（元数据库）查询该 Session ID 对应的记录。</li><li>返回映射信息：MetaDB 返回该会话之前绑定的 Instance（实例）信息以及负责管理该实例的 Target Scheduler（目标调度节点）。</li><li>直连调度节点：Gateway 根据返回的信息，直接联系对应的 Target Scheduler。</li><li>确认路由实例：Target Scheduler 告知 Gateway 该实例有效，可以进行数据转发。</li><li>转发请求：Gateway 将客户端的业务请求转发给对应的 Instance。</li><li>处理并响应：Instance（Agent 沙箱）执行代码逻辑处理请求，并将结果返回给 Gateway。</li><li>返回业务数据：Gateway 将最终的执行结果回传给 Client，完成一次有状态的会话交互。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602093" alt="image" title="image" loading="lazy"/></p><h4>2.3 会话隔离能力</h4><p>为了极致的安全，我们引入了“一会话一实例”的隔离模型。每个 Agent Session 独占一个底层的运行实例。一旦会话结束，实例立即销毁并擦除数据。通过会话配额控制，可以有效防止单个用户创建过多沙箱导致资源过载。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602094" alt="image" title="image" loading="lazy"/></p><h3>3. 扩展配套能力，强化 Agent 底座</h3><p>除了核心的调度与协议，针对生产环境中的性能与成本挑战，我们进一步扩展了配套能力：</p><p><strong>1. 预热能力</strong></p><p>冷启动是 Serverless 的天敌。针对 Agent 实时交互的要求，我们支持 CreateSession 主动预热。在用户刚进入对话页面时，系统提前准备好预留实例。将沙箱的就绪时间压缩至极低延时。</p><p><strong>2. 会话级存储隔离</strong></p><p>Agent 经常需要读写文件。我们实现了会话维度的动态存储挂载。每个沙箱可以根据 Session ID 动态挂载独立的 NAS 或 OSS 路径。这样既保证了数据在会话内的持久化，又确保了不同会话间的文件系统是物理隔离的。同时满足沙箱异常 Crash 后数据的可恢复。</p><p><strong>3. 计费升级模型进化：从 FaaS 的“按请求”到“按资源消耗”</strong></p><p>FaaS 按请求计费模式，在 AI 场景下会产生巨大的“保活成本”。会话计费模型必须与资源的实际使用强挂钩，因此系统针对会话函数的计费模式升级到 Serverless AI 计费模式。</p><ul><li>活跃期：当会话实例正在处理用户请求时，按照活跃单价计费。</li><li>空闲期：当会话处于空闲、仅维持连接和上下文状态时，系统切换到一个极低的“保活”费率。仅收取内存、磁盘的费用，不再收取相对较高的 CPU 费用。</li></ul><p>这个模式对客户而言，相对传统常驻实例完整生命周期计费模式成本大幅降低。</p><h2>总结与展望</h2><p>Serverless <a href="https://link.segmentfault.com/?enc=ofpzgx%2Ffbimkl0dIF0QqRw%3D%3D.zwqPlG0OLFa5hBPQkBnKe2ouiuw10rbTHt1rShYItGg6Jt9lmM5wWPY0ZScf45QsYqRdsYEZKKXf5cGeJEbNBAlcXnupo%2BdPN4rX7j%2By2pTzBTPYjekxrj8krRjyep9JTqT3eneiozaqAGiC0cpW2Q%3D%3D" rel="nofollow" target="_blank">函数计算</a>凭借其安全隔离、弹性伸缩、按需付费等基因，正成为构建 Agent 运行时的理想选择。通过协议生态扩展、会话管理能力增强、配套能力完善，我们已实现从“单一函数执行”到“复杂 Agent 托管平台”的跨越。未来，我们也将持续聚焦启动优化、更长会话支持等等核心能力，做好 AI 原生时代坚实的护航者。</p><p><strong>相关链接：</strong></p><p>[1] 查看更多产品详情</p><p><a href="https://link.segmentfault.com/?enc=P0CRlFSLadIiyEeCr31GWA%3D%3D.gxAHqOP6SvyAO0zp9Dl05KZpVeJucfQxSPieJHjBzGtasCUaQ%2BMeybrBUGPeKb8z" rel="nofollow" target="_blank">https://www.aliyun.com/product/fc</a></p><p>[2] 相关文档链接</p><p><a href="https://link.segmentfault.com/?enc=Iito6pa60ivc0%2B%2FYDsjfTQ%3D%3D.jK0eW38LYNkpcFNPE7buFHoHhjvZ0XzGuKum6lsOinSkbiQgahZORAKR1iFsdSjq%2BUpY2Uu%2FMzYILZVGDcJA3DIbRh%2BVv6WoMqfDSTWhdJe9iExCUkgEeNKTl9ELuT3C" rel="nofollow" target="_blank">https://help.aliyun.com/zh/functioncompute/fc/user-guide/sess...</a></p>]]></description></item><item>    <title><![CDATA[DSPy、QDrant与ReAct框架的LLM记忆层构建：向量嵌入实现用户对话记忆自适应管理|附代码]]></title>    <link>https://segmentfault.com/a/1190000047602102</link>    <guid>https://segmentfault.com/a/1190000047602102</guid>    <pubDate>2026-02-09 16:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>全文链接：<a href="https://link.segmentfault.com/?enc=Whoqb90kmWz%2FfZpxPbGvIg%3D%3D.n2LR3eQwFWrjyywrWFpWT5n4kb%2FsdC3qk8B92mEPbXA%3D" rel="nofollow" title="https://tecdat.cn/?p=44952" target="_blank">https://tecdat.cn/?p=44952</a>  <br/>原文出处：拓端数据部落公众号  </p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602104" alt="封面" title="封面"/></p><h4><a name="t1" target="_blank"/>专题：LLM上下文工程实践：轻量化记忆层构建与落地</h4><h5>引言</h5><p>在大语言模型（LLM）的实际应用过程中，对话类场景是落地频率最高的方向之一，而这类场景的核心痛点在于LLM的无状态特性——每次模型调用都是独立的过程，若未主动传入历史会话信息，模型无法感知用户的过往交互内容。这一特性虽然保障了模型并行处理的效率和安全性，却成为个性化对话应用落地的最大阻碍：如果智能客服每次都将用户视为新访客，又如何提供贴合用户需求的个性化响应？  <br/>从技术演进的角度来看，早期开发者尝试通过延长上下文窗口的方式解决记忆问题，但这种方式不仅受限于模型的上下文长度，还会显著增加调用成本；而随着向量数据库和智能体技术的成熟，为LLM构建独立的记忆层成为更优解。本文基于Mem0架构的核心思想，从零拆解并实现一套轻量化的LLM记忆层，该方案已在金融智能客服、电商个性化助手等实际业务场景中得到验证。  <br/>本文内容改编自过往客户咨询项目的技术沉淀并且已通过实际业务校验，该项<strong>目完整代码与数据已</strong>分享至交流社群。阅读原文进群，可与800+行业人士交流成长；还提供人工答疑，拆解核心原理、代码逻辑与业务适配思路，帮大家既懂 怎么做，也懂 为什么这么做；遇代码运行问题，更能享24小时调试支持。</p><h5>LLM记忆层：从上下文工程视角的核心拆解</h5><p>上下文工程是指为LLM补充完成任务所需的全部相关信息的技术体系，而记忆层构建是上下文工程中难度最高、应用价值最大的方向之一。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047602105" alt="" title="" loading="lazy"/>  <br/>LLM本身并不具备记忆能力，要实现会话记忆，开发者需要掌握上下文工程的核心技术栈：从原始文本流中提取结构化信息、文本摘要生成、向量数据库应用、查询生成与相似性检索、查询后处理与重排序、智能体工具调用等。而构建自定义记忆层的过程，正是这些技术的综合落地过程。</p><h4><a name="t2" target="_blank"/>记忆层的整体架构设计</h4><p>一套可落地的LLM记忆层需具备四大核心能力：提取、嵌入、检索与维护。在开始代码实现前，先梳理各模块的核心职责与交互逻辑。</p><h5>核心模块拆解</h5><ul><li><strong>记忆提取</strong>：从用户与助手的对话文本中提取具备原子性的候选记忆信息；</li><li><strong>向量存储</strong>：将提取的原子化记忆转换为向量形式，并存储到向量数据库中；</li><li><strong>记忆检索</strong>：当用户发起查询时，生成检索语句并从向量库中匹配相关记忆；</li><li><strong>记忆维护</strong>：基于ReAct（推理与执行）循环，智能判断对现有记忆的增、删、改或无操作，解决记忆冲突与过时问题。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047602106" alt="" title="" loading="lazy"/>  <br/>需要特别说明的是，上述所有步骤都应设计为可选流程：若LLM无需调用历史记忆即可回答用户问题，则无需触发向量库检索，以此降低系统开销。核心策略是为LLM提供完成任务所需的全部工具，并清晰定义工具功能，依托LLM自身的智能自主决策工具的使用时机。</li></ul><h4><a name="t3" target="_blank"/>基于DSPy的记忆提取：从对话文本到原子化记忆</h4><p>记忆提取是记忆层构建的第一步，核心目标是将非结构化的对话文本转换为结构化、原子化的记忆单元，以便后续的嵌入与检索。<img referrerpolicy="no-referrer" src="/img/remote/1460000047602107" alt="" title="" loading="lazy"/></p><h5>原子化记忆的定义与提取目标</h5><p>优质的记忆单元应具备“短、自包含、原子化”的特征——即单个记忆仅描述一个独立事实，且能被精准嵌入和检索。我们的目标是构建一个面向单用户、持久化的向量数据库记忆库，而DSPy框架能高效实现从对话文本到原子化记忆的提取（DSPy为Python开源库，国内可正常安装使用，无访问限制）。  <br/>DSPy通过“Signature（签名）”定义输入输出结构，其注释会作为系统提示词引导LLM完成结构化信息提取。以下是核心实现代码（已调整变量名与语法，省略部分基础导入代码）：</p><pre><code># 省略json、asyncio等基础导入代码import dspyfrom pydantic import BaseModel# 定义记忆提取的签名结构class UserMemoryExtract(dspy.Signature): """从对话文本中提取有价值的用户记忆信息。记忆需为独立的原子化事实，若文本无提取价值则返回空列表。""" dialog_text: str = dspy.InputField() # 输入：对话文本 user_memories: list[str] = dspy.OutputField() # 输出：提取的记忆列表# 初始化记忆提取器memory_extract_tool = dspy.Predict(UserMemoryExtract)# 异步提取记忆的核心函数async def get_user_memories(dialog_messages): # 将对话消息转换为JSON字符串作为输入 dialog_json = json.dumps(dialog_messages) # 指定调用的模型并执行提取（省略模型配置相关代码） with dspy.context(lm=dspy.LM(model=MODEL_TYPE)): extract_result = await memory_extract_tool.acall(dialog_text=dialog_json) # 返回提取的记忆列表 return extract_result.user_memories</code></pre><p>为验证提取效果，我们基于模拟对话文本测试（已调整变量名与示例内容）：</p><pre><code>if __name__ == "__main__": # 模拟用户与助手的对话记录 test_dialog = [ { "role": "user", "content": "我喜欢喝咖啡" }, { "role": "assistant", "content": "好的，我记下了！" }, { "role": "user", "content": "其实我更喜欢喝茶，另外我也喜欢踢足球" } ] # 执行记忆提取 extracted_mem = asyncio.run(get_user_memories(test_dialog)) print(extracted_mem)'''输出结果示例：[ "用户原本喜欢咖啡，后表示更喜欢茶", "用户有喝茶的偏好", "用户喜欢踢足球"]'''</code></pre><p>从测试结果可见，该方案能有效从对话中提取原子化记忆，这些记忆可脱离会话窗口存储到独立数据库中，为跨会话记忆提供基础。</p><hr/><p><strong>相关文章</strong><img referrerpolicy="no-referrer" src="/img/remote/1460000047602108" alt="" title="" loading="lazy"/></p><h3><a name="t4" target="_blank"/>Python用langchain、OpenAI大语言模型LLM情感分析AAPL股票新闻数据及提示工程优化应用</h3><p>原文链接：<a href="https://link.segmentfault.com/?enc=jJTNy5pTPPNwPIA4s%2Bp77w%3D%3D.7iCA7J4P89rtmEFc3DaKldgdWBzOM%2BCeWZ0lySY2Uk0%3D" rel="nofollow" title="https://tecdat.cn/?p=39614" target="_blank">https://tecdat.cn/?p=39614</a></p><hr/><h4><a name="t5" target="_blank"/>记忆的向量嵌入与存储：基于QDrant的实现</h4><p>提取原子化记忆后，需将其转换为向量形式存储，本文选用QDrant作为向量数据库（QDrant为开源向量数据库，国内可正常部署使用，无访问限制；国产替代方案可选用Milvus、Zilliz等）。<img referrerpolicy="no-referrer" src="/img/remote/1460000047602109" alt="" title="" loading="lazy"/></p><h5>嵌入模型选择与向量维度优化</h5><p>考虑到成本、速度与短文本嵌入效果，本文选用OpenAI的text-embedding-3-small模型（国内无法直接访问OpenAI官网，但可通过合规第三方API服务商调用；国产替代方案可选百度文心一言嵌入、阿里通义千问嵌入、智谱AI嵌入等），并将向量维度固定为64，在保证表达能力的同时降低存储成本与检索耗时。  <br/>核心实现代码（调整变量名与语法，省略部分导入代码）：</p><pre><code># 省略uuid、datetime等基础导入代码from openai import AsyncClientfrom qdrant_client import AsyncQdrantClientfrom qdrant_client.models import Distance, Filter, models# 初始化OpenAI异步客户端emb_client = AsyncClient()# 异步生成文本向量async def create_text_embeddings(text_list: list[str]): # 调用嵌入模型生成向量，指定维度为64 emb_result = await emb_client.embeddings.create( input=text_list, model="text-embedding-3-small", dimensions=64 ) # 提取向量结果 embeddings = [item.embedding for item in emb_result.data] return embeddings# 定义向量存储的数据结构class StoredMemory(BaseModel): user_identity: int # 用户ID memory_content: str # 记忆文本 create_time: str # 创建时间 vector_data: list[float] # 向量数据# 初始化QDrant异步客户端（省略客户端连接配置代码）qdrant_async_client = AsyncQdrantClient(...)MEMORY_COLLECTION = "user_memories"# 创建向量库集合与索引async def init_memory_collection(): # 检查集合是否存在，不存在则创建 if not (await qdrant_async_client.collection_exists(MEMORY_COLLECTION)): await qdrant_async_client.create_collection( collection_name=MEMORY_COLLECTION, vectors_config=models.VectorParams(size=64, distance=Distance.DOT), ) # 为用户ID创建索引，提升检索效率 await qdrant_async_client.create_payload_index( collection_name=MEMORY_COLLECTION, field_name="user_identity", field_schema=models.PayloadSchemaType.INTEGER )# 插入记忆到向量库（省略参数校验代码）async def add_memories_to_db(memory_list: list[StoredMemory]): """将记忆列表插入向量数据库""" # 构造插入的点数据 point_list = [ models.PointStruct( id=uuid4().hex, # 生成唯一ID payload={ "user_identity": mem.user_identity, "memory_content": mem.memory_content, "create_time": mem.create_time }, vector=mem.vector_data ) for mem in memory_list ] # 执行插入 await qdrant_async_client.upsert( collection_name=MEMORY_COLLECTION, points=point_list )# 检索相似记忆（省略结果转换函数代码）async def find_similar_memories( search_vector: list[float], user_id: int, top_k: int = 5): """根据向量检索用户的相似记忆""" # 构造用户ID过滤条件 filter_conditions = [ models.FieldCondition( key="user_identity", match=models.MatchValue(value=user_id) ) ] # 执行检索 search_result = await qdrant_async_client.query_points( collection_name=MEMORY_COLLECTION, query=search_vector, with_payload=True, query_filter=Filter(must=filter_conditions), score_threshold=0.1, # 相似度阈值 limit=top_k ) # 转换检索结果（省略convert_search_result函数实现） return [convert_search_result(point) for point in search_result.points if point is not None]</code></pre><p>为提升检索效率，我们为用户ID字段创建了索引，该思路可扩展到记忆分类标签、时间范围等元数据维度——只需为对应字段创建索引即可，这在电商个性化推荐、金融客户画像等实际场景中能显著提升检索精准度。</p><h4><a name="t6" target="_blank"/>基于ReAct框架的记忆检索与响应生成</h4><p>记忆检索的核心是让智能体自主判断是否需要调用记忆，并检索相关内容辅助响应生成。本文基于DSPy构建ReAct智能体，实现检索逻辑的自主决策。<img referrerpolicy="no-referrer" src="/img/remote/1460000047602110" alt="" title="" loading="lazy"/></p><h5>响应生成的核心实现</h5><p>首先定义响应生成的输入输出结构，引导LLM判断是否需要保存新记忆（调整变量名与语法）：</p><pre><code>class DialogResponseGenerator(dspy.Signature): """你将收到用户与AI助手的历史对话文本及用户最新问题。 若无法从历史对话或自身知识库中回答问题，可调用向量库检索工具获取相关记忆。 需输出最终响应，并判断是否需要将最新交互内容存入记忆库（仅当用户提供新信息时保存，不保存AI相关内容）。 """ dialog_history: list[dict] = dspy.InputField() # 历史对话 user_question: str = dspy.InputField() # 用户最新问题 final_response: str = dspy.OutputField() # 最终响应 need_save_memory: bool = dspy.OutputField( description="若最新交互需生成新记忆则为True，否则为False" )# 封装检索工具（省略权限校验代码）async def search_user_memories(search_content: str): """当对话需要补充上下文时，从向量库检索相关记忆 参数： search_content: 用于嵌入并执行相似性检索的文本 """ # 生成检索文本的向量 search_vec = (await create_text_embeddings([search_content]))[0] # 检索相似记忆（current_user_id为外部维护的当前用户ID） related_memories = await find_similar_memories( search_vector=search_vec, user_id=current_user_id ) # 格式化记忆结果 memory_str_list = [ f"记忆ID={m.point_id}\n内容={m.memory_content}\n创建时间={m.create_time}" for m in related_memories ] return {"related_memories": memory_str_list}# 初始化ReAct响应生成智能体response_agent = dspy.ReAct( DialogResponseGenerator, tools=[search_user_memories], # 绑定检索工具 max_iters=4 # 最大迭代次数)</code></pre><p>除了向量相似性检索，实际应用中还可扩展其他检索策略：如基于BM-25/TF-IDF的关键词检索（适用于短文本精准匹配）、基于分类标签的精准过滤（适用于垂直领域对话）、基于时间范围的记忆筛选（适用于时效性强的场景）等，具体可根据业务场景选择。</p><h4><a name="t7" target="_blank"/>记忆的全生命周期维护：自适应增删改查</h4><p>记忆并非静态存储，需根据用户最新交互动态调整——例如用户修改偏好时，需更新对应记忆而非新增重复条目。本文基于ReAct框架构建记忆维护智能体，实现记忆的增、删、改、无操作（NOOP）决策。<img referrerpolicy="no-referrer" src="/img/remote/1460000047602111" alt="" title="" loading="lazy"/></p><h5>记忆维护的核心实现</h5><p>首先定义记忆维护的输入输出结构，明确智能体的决策目标（调整变量名与语法）：</p><pre><code>class MemoryWithID(BaseModel): mem_index: int # 记忆索引 mem_content: str # 记忆内容class MemoryUpdateSignature(dspy.Signature): """基于用户最新对话与已有相似记忆，决策记忆库的更新方式： - 新增：将新记忆作为独立条目插入库中（插入前需去重）； - 更新：用新信息替换已有记忆； - 删除：移除矛盾或过时的记忆； - 无操作：无需调整记忆库。 需输出简短的操作总结（少于10字）。 """ dialog_messages: list[dict] = dspy.InputField() # 最新对话 existing_memories: list[MemoryWithID] = dspy.InputField() # 已有相似记忆 operation_summary: str = dspy.OutputField(description="操作总结，简短")# 记忆维护智能体核心逻辑（省略部分工具函数参数校验代码）async def memory_maintain_agent( user_id: int, dialog_msgs: list[dict], existing_mems: list[StoredMemory]): # 根据记忆索引获取点ID def get_point_id(mem_index): return existing_mems[mem_index].point_id# 新增记忆工具 async def add_new_memory(mem_text: str) -&gt; str: """将新记忆插入向量数据库""" mem_emb = await create_text_embeddings([mem_text]) new_mem = StoredMemory( user_identity=user_id, memory_content=mem_text, create_time=datetime.now().strftime("%Y-%m-%d %H:%M"), vector_data=mem_emb[0] ) await add_memories_to_db([new_mem]) return f"新增记忆：{mem_text}"# 初始化记忆维护ReAct智能体 maintain_agent = dspy.ReAct( MemoryUpdateSignature, tools=[add_new_memory, update_existing_memory, delete_selected_memory, no_operation], max_iters=3 )# 执行维护决策 maintain_result = await maintain_agent.acall( dialog_messages=dialog_msgs, existing_memories=existing_mems ) return maintain_result.operation_summary</code></pre><p>在实际业务场景中，该维护逻辑已验证可有效解决记忆冲突问题——例如用户从“喜欢咖啡”改为“喜欢茶”时，智能体会删除旧记忆并新增新记忆，而非保留两条矛盾条目，保障记忆库的准确性。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602112" alt="" title="" loading="lazy"/></p><h4><a name="t9" target="_blank"/>落地扩展与工程化优化建议</h4><p>本文实现的记忆层为轻量化版本，在实际落地中可从以下方向扩展，进一步提升适配性：</p><ol><li><strong>图结构记忆系统</strong>：将向量数据库替换为图数据库，通过提取“主体-关系-客体”三元组替代扁平文本记忆，更贴合人类记忆的关联特性，适用于金融客户关系分析、电商用户行为溯源等场景；</li><li><strong>多维度元数据标签</strong>：为记忆增加分类标签（如“饮食偏好”“消费习惯”）、时间戳等元数据，智能体可基于标签精准检索，降低无效检索开销；</li><li><strong>用户专属提示词优化</strong>：将记忆库中的核心信息注入LLM的系统提示词，替代每次检索，提升响应速度，适用于高频次、短会话的智能客服场景；</li><li><strong>文件化存储方案</strong>：用文件系统（如Markdown文件）替代向量数据库，通过正则、全文检索实现记忆管理，降低部署成本，适用于小型应用场景。</li></ol><h4><a name="t10" target="_blank"/>记忆层核心流程（竖版）</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602113" alt="" title="" loading="lazy"/></p><h4><a name="t12" target="_blank"/>总结</h4><ol><li>本文基于上下文工程理念，拆解并实现了一套轻量化LLM记忆层，核心模块包含记忆提取、向量存储、检索与自适应维护，已在实际业务场景验证有效；</li><li>技术选型上适配国内环境，QDrant可开源部署，OpenAI嵌入模型可通过第三方服务商调用，也可替换为国产嵌入模型；</li><li>基于ReAct框架的双智能体设计，实现了记忆检索与维护的自主决策，解决了LLM无状态导致的个性化缺失问题，且提供24小时应急修复服务保障落地效率。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047602104" alt="封面" title="封面" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[【植物识别系统】Python+深度学习+人工智能+算法模型+tensoflow+图像识别+2026计]]></title>    <link>https://segmentfault.com/a/1190000047601498</link>    <guid>https://segmentfault.com/a/1190000047601498</guid>    <pubDate>2026-02-09 15:08:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>项目介绍</h2><p>本植物识别系统是一款基于深度学习技术的智能植物识别应用，旨在帮助用户快速、准确地识别各类植物。系统采用前后端分离架构，前端使用 Vue3 框架结合 Element Plus 组件库，提供美观、直观的用户界面；后端采用 Flask 轻量级 Web 框架，负责处理业务逻辑和数据交互；核心识别算法基于 TensorFlow 框架实现的 ResNet50 深度学习模型，具备强大的图像特征提取和分类能力。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601500" alt="图片" title="图片"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601501" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601502" alt="图片" title="图片" loading="lazy"/></p><h2>选题背景与意义</h2><p>随着生态环境的日益恶化和人们环保意识的不断提高，植物保护和研究工作变得越来越重要。然而，传统的植物识别方法主要依赖于植物学专家的经验和专业知识，效率低下且成本高昂，无法满足普通民众和非专业人员的需求。</p><p>近年来，深度学习技术的快速发展为植物识别提供了新的解决方案。卷积神经网络（CNN）在图像识别领域取得了显著的成果，ResNet50 作为其中的经典模型，具有强大的特征提取能力和分类精度。本项目正是基于这一技术背景，开发了一款易用、高效的智能植物识别系统。</p><h2>关键技术栈：ResNet50</h2><p>ResNet50 是由微软研究院提出的一种深度残差网络结构，是 ResNet（Residual Neural Network）系列模型中的经典代表。它通过引入残差学习（Residual Learning）机制，有效地解决了深度神经网络训练过程中的梯度消失和梯度爆炸问题，使得网络可以达到更深的层数（50层），同时保持良好的训练效果。</p><p>ResNet50 的核心创新点在于残差块（Residual Block）的设计。传统的卷积神经网络在层数增加时会出现退化现象（Degradation），即随着网络深度的增加，训练误差和测试误差都会增加。ResNet 通过在网络中添加跳跃连接（Skip Connection），将输入直接与输出相加，使得网络可以学习残差映射（Residual Mapping），从而避免了退化问题。</p><h2>技术架构图</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601503" alt="图片" title="图片" loading="lazy"/></p><h2>系统功能模块图（MindMap）</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601504" alt="图片" title="图片" loading="lazy"/></p><h2>演示视频 and 完整代码 and 安装</h2><p>地址：<a href="https://link.segmentfault.com/?enc=Yi0ewp5IXhgLBzwqKD13DA%3D%3D.HXMnHR6O5Vv2xFWgzEoVtG3jHYmI%2Bjy5I7HutUVNUiY1b8D%2Bu6Gw%2FvLBOktM31W8AojxtZuSLN89eDoGESljBA%3D%3D" rel="nofollow" target="_blank">https://www.yuque.com/ziwu/qkqzd2/fh58mo20xzg2tvr1</a></p>]]></description></item><item>    <title><![CDATA[本地服务器 vs 云部署 - 数据中心托管该怎么选？ 极云Cloud ]]></title>    <link>https://segmentfault.com/a/1190000047601517</link>    <guid>https://segmentfault.com/a/1190000047601517</guid>    <pubDate>2026-02-09 15:08:00</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在做IT架构规划时，很多团队都会面临一个核心选择题：到底该用本地服务器，还是走云部署路线？其实这两种方式没有绝对的好坏，关键要看你的业务特性、团队配置和长期规划。</p><p>先说说成本结构。本地服务器一般前期投入比较大，包括硬件采购、机房改造这些一次性支出，不过后面每年的运维成本相对可控。而云服务基本是“开箱即用”，起步门槛低，但随着业务规模扩大，月度或年度的费用会逐步上升，长期来看未必更省。</p><p>性能方面，本地服务器由于资源独享，通常延迟更低、稳定性也更可控，特别适合对实时性要求高的场景。不过云服务的弹性都是实打实的优势——流量突增时能快速扩容，高峰期过了又能及时缩容，资源利用率更高。</p><p><img referrerpolicy="no-referrer" src="https://image-static.segmentfault.com/158/520/1585206010-698974e284f95" alt="" title=""/></p><p>数据安全是很多人关心的话题。本地部署等于把所有数据都握在自己手里，权限管控更直接，适合金融、医疗这类强监管行业。而现在的云服务商在安全上的投入也越来越大，像加密传输、漏洞防护、跨区域容灾这些能力，可能比很多企业自建的水平还要专业。</p><p>运维管理上的差异也很明显。本地服务器需要配备专门的IT团队做日常维护，出了问题也得自己排查，技术门槛不低。云服务就省心不少，大部分运维工作都由平台承担，团队可以更专注于业务开发，对技术人员配置要求也没那么高。</p><p>那到底该怎么选呢?如果你对数据管控、性能稳定性有强要求，而且有专门的运维团队，本地部署可能更踏实。如果你的业务波动大、增长快，或者希望降低运维复杂度，那云服务的灵活性和便捷性会更合适。</p><p>其实现在很多企业都在采用混合架构——核心系统放在本地，弹性业务上云，两边优势互补。不管选哪种方案，找个靠谱的IDC服务商都很重要。毕竟从方案设计到后期运维，专业的团队能帮你避开不少坑，让整个系统跑得更稳更省心。</p>]]></description></item><item>    <title><![CDATA[从零开始学Flink：Flink SQL 窗口(Window)操作详解 代码匠心 ]]></title>    <link>https://segmentfault.com/a/1190000047601521</link>    <guid>https://segmentfault.com/a/1190000047601521</guid>    <pubDate>2026-02-09 15:07:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在上一篇 <a href="https://link.segmentfault.com/?enc=C4BxPfgkfHmrphnd6agbfQ%3D%3D.BImNrMej3iAy5ikQ%2BTo2YhuH09kGGi5bQvf%2BzaC%2FylKXilf%2B%2F9KzoWaBPjhkRP0m76d2Gyv1mFzTiPmk%2FxW1UA%3D%3D" rel="nofollow" target="_blank">Flink SQL 极简入门</a> 中，我们体验了 Flink SQL 的基础用法。但在流处理中，最核心、最迷人（也最让人头秃）的概念莫过于<strong>“时间”</strong>和<strong>“窗口（Window）”</strong>。</p><p>你可能经常听到这样的业务需求：</p><ul><li>“每 5 分钟统计一次订单总量”</li><li>“实时统计过去 1 小时内的热门商品，每 10 秒更新一次”</li><li>“每天 0 点到当前时刻的累计 PV”</li></ul><p>这些需求都离不开<strong>窗口</strong>。今天，我们就来深入 Flink SQL 的窗口机制，看看它是如何驯服无限数据流的。</p><h2>什么是窗口 (Window)？</h2><p>流数据（Stream）是无限的，像水流一样源源不断。我们无法计算“无限流”的总和（因为永远算不完）。为了计算，我们需要把无限的流“切”成有限的块，这个“切”的操作就是<strong>开窗（Windowing）</strong>。</p><p>在 Flink SQL 中，窗口主要用于将时间序列上的数据分桶，然后在桶内进行聚合计算（如 <code>SUM</code>, <code>COUNT</code>, <code>AVG</code>）。</p><h2>新一代标准：Window TVF</h2><p>在 Flink 1.13 之前，我们主要使用 <code>GROUP WINDOW</code>（如 <code>TUMBLE(rowtime, ...)</code> 在 GROUP BY 子句中）。但从 Flink 1.13 开始，官方推荐使用 <strong>Window TVF (Table-Valued Functions)</strong>。</p><p>Window TVF 符合 SQL 2016 标准，语法更自然，功能更强大（支持 TopN、去重等复杂操作）。本文将以 <strong>Window TVF</strong> 为主进行讲解。</p><p>核心语法结构通常如下：</p><pre><code class="sql">SELECT window_start, window_end, SUM(price)
FROM TABLE(
    -- 窗口函数
    TUMBLE(TABLE my_table, DESCRIPTOR(ts), INTERVAL '5' MINUTE)
)
GROUP BY window_start, window_end;</code></pre><h2>三大核心窗口类型</h2><h3>1. 滚动窗口 (Tumble Window)</h3><p><strong>特点</strong>：窗口大小固定，窗口之间<strong>不重叠</strong>，首尾相接。<br/><strong>场景</strong>：每隔 5 分钟统计一次。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601524" alt="Tumble Window" title="Tumble Window"/></p><p><strong>语法</strong>：<br/><code>TUMBLE(TABLE data, DESCRIPTOR(time_col), INTERVAL '10' MINUTE)</code></p><h3>2. 滑动窗口 (Hop Window)</h3><p><strong>特点</strong>：窗口大小固定，但窗口之间<strong>可以重叠</strong>。它有两个参数：</p><ol><li><strong>Window Size (窗口大小)</strong>：统计多长时间的数据（如“过去 1 小时”）。</li><li><strong>Window Slide (滑动步长)</strong>：多久更新一次结果（如“每 5 分钟”）。</li></ol><p><strong>场景</strong>：每 5 分钟，统计过去 1 小时的 PV。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601525" alt="Hop Window" title="Hop Window" loading="lazy"/></p><p><strong>语法</strong>：<br/><code>HOP(TABLE data, DESCRIPTOR(time_col), INTERVAL '5' MINUTE, INTERVAL '1' HOUR)</code><br/><em>注意：参数顺序是先 Slide (步长)，后 Size (大小)。</em></p><h3>3. 累积窗口 (Cumulate Window)</h3><p><strong>特点</strong>：这是 Flink 特有的窗口，用于解决“每天 0 点至今的累计值”这类需求。它会按步长输出一个个不断变大的窗口，直到达到最大窗口大小。</p><p><strong>场景</strong>：每天的实时累计销售额（每 10 分钟更新一次看到当天的累计值）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601526" alt="Cumulate Window" title="Cumulate Window" loading="lazy"/></p><p><strong>语法</strong>：<br/><code>CUMULATE(TABLE data, DESCRIPTOR(time_col), INTERVAL '10' MINUTE, INTERVAL '1' DAY)</code></p><hr/><h2>实战：处理“过去 5 分钟的订单总额”</h2><p>让我们回到开头的经典需求。假设我们有一个订单流 <code>orders</code>。</p><h3>0. 准备数据环境</h3><p>首先，我们启动 SQL Client</p><pre><code class="bash">./bin/sql-client.sh</code></pre><p>创建一个模拟的订单源表（使用 DataGen 连接器）：</p><pre><code class="sql">CREATE TABLE orders (
    order_id INT,
    price DOUBLE,
    order_time TIMESTAMP(3),
    -- 定义水位线，基于 order_time，延迟 0 秒
    WATERMARK FOR order_time AS order_time - INTERVAL '0' SECOND
) WITH (
    'connector' = 'datagen',
    'rows-per-second' = '1',
    'fields.price.min' = '10',
    'fields.price.max' = '100'
);</code></pre><h3>需求一：每 5 分钟，统计该 5 分钟内的订单总额</h3><p>这是一个典型的<strong>滚动窗口 (Tumble)</strong>。比如 12:00-12:05 一个结果，12:05-12:10 一个结果。</p><pre><code class="sql">SELECT 
    window_start, 
    window_end, 
    COUNT(*) as total_orders, 
    SUM(price) as total_amount
FROM TABLE(
    TUMBLE(TABLE orders, DESCRIPTOR(order_time), INTERVAL '5' MINUTE)
)
GROUP BY window_start, window_end;</code></pre><p><strong>运行结果示例</strong>：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601527" alt="5分钟内订单总额" title="5分钟内订单总额" loading="lazy"/></p><h3>需求二：实时统计“过去 5 分钟”的订单总额，每 1 分钟更新一次</h3><p>这是一个典型的<strong>滑动窗口 (Hop)</strong>。</p><ul><li>窗口大小：5 分钟</li><li>滑动步长：1 分钟</li></ul><p>这样，12:00 输出 [11:55, 12:00] 的数据；12:01 输出 [11:56, 12:01] 的数据。</p><pre><code class="sql">SELECT 
    window_start, 
    window_end, 
    SUM(price) as total_amount
FROM TABLE(
    HOP(TABLE orders, DESCRIPTOR(order_time), INTERVAL '1' MINUTE, INTERVAL '5' MINUTE)
)
GROUP BY window_start, window_end;</code></pre><p><strong>运行结果示例</strong>：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601528" alt="过去5分钟订单总额" title="过去5分钟订单总额" loading="lazy"/></p><p><strong>注意</strong>：<br/><code>HOP</code> 函数的参数中，<strong>第一个时间是滑动步长 (Slide)</strong>，<strong>第二个时间是窗口大小 (Size)</strong>。千万别搞反了！<br/><code>INTERVAL '1' MINUTE</code> = Slide (更新频率)<br/><code>INTERVAL '5' MINUTE</code> = Size (统计范围)</p><h2>总结</h2><p>Flink SQL 的 Window TVF 极大地简化了窗口聚合的写法。</p><ul><li><strong>TUMBLE</strong>: 规规矩矩，互不干扰（分批统计）。</li><li><strong>HOP</strong>: 藕断丝连，频繁更新（移动平均/最近 N 分钟）。</li><li><strong>CUMULATE</strong>: 聚沙成塔，越积越多（日报/大屏累计）。</li></ul><p>掌握了这三种窗口，你就能覆盖 90% 的实时统计需求了。</p><p>下一篇，我们将挑战更复杂的场景：<strong>双流 JOIN</strong>，看看当“订单流”遇到“用户流”，Flink 该如何处理？</p><hr/><p><a href="https://link.segmentfault.com/?enc=RQklsXf%2FNPHMtPgpBl1MEw%3D%3D.xwN9vax4pWfOALfBwl79PjZJJxjojk132suq1mVU6tlJaGTm41gUTy0KGVmPaCT7" rel="nofollow" target="_blank">原文来自</a></p>]]></description></item><item>    <title><![CDATA[什么是住宅代理？B2Proxy从网络身份本质到真实业务价值的深度解析 B2Proxy ]]></title>    <link>https://segmentfault.com/a/1190000047601642</link>    <guid>https://segmentfault.com/a/1190000047601642</guid>    <pubDate>2026-02-09 15:06:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在当下的互联网环境中，IP 已经不再只是一个简单的网络编号，它更像是一张隐形却极具分量的“网络身份证”。平台判断你是谁、是否可信、是否具备长期行为一致性，往往并不是通过你输入了什么，而是通过你从哪里来。正是在这样的背景下，住宅代理逐渐从技术工具，演变为跨境业务、数据采集、广告投放、账号运营等场景中的基础设施。<br/>理解住宅代理，不能只停留在“真实家庭 IP”这几个字上，而是要回到网络世界的运行逻辑，去看它解决的究竟是什么问题，又为什么在近几年变得如此关键。</p><h2>网络身份信任机制的变化</h2><p>早期互联网更像是一片开放的荒原，只要能连上网络，几乎不存在严格的身份校验。但随着平台商业化程度的加深，风控系统逐渐成熟，网络身份被赋予了明确的价值权重。IP 的来源、历史行为、所属网络类型，都会成为平台判断风险的重要依据。<br/>在这种机制下，来自数据中心的大量请求开始被默认视为“高风险流量”。并不是因为它们一定存在恶意，而是因为这类 IP 天生具备高度集中、可复制、易滥用的特征。住宅网络恰恰相反，它天然分散、来源复杂、行为轨迹更接近真实用户，因此在信任评分体系中拥有明显优势。<br/>住宅代理的核心意义，正是让你的网络请求回到这种“被信任的轨道”之中。</p><h2>住宅代理的真实定义与运行逻辑</h2><p>从技术角度来看，住宅代理指的是出口 IP 来自真实家庭宽带网络的代理服务。这些 IP 并非部署在机房服务器中，而是由真实 ISP 分配给普通用户，再通过合规方式进行调度与授权使用。<br/>当你的请求通过住宅代理发出时，目标网站看到的并不是一个“工具在访问”，而是一个看起来完全正常的家庭用户在进行浏览、搜索或交互。这种差异并不体现在表面，而是深深嵌入在 ASN、IP 段信誉、历史行为模型等底层判断中。<br/>也正因为如此，住宅代理并不是用来“对抗平台”的工具，而是一种更符合平台预期的访问方式。</p><h2>为什么越来越多业务离不开住宅代理</h2><p>在实际业务中，住宅代理的价值往往是在“问题出现之后”才被真正意识到。账号频繁触发验证、广告账户审核难度陡增、数据采集效率大幅下降、内容平台限流却找不到明确原因，这些现象的背后，常常都指向同一个源头：网络身份不被信任。<br/>住宅代理并不能保证百分之百不出问题，但它能显著降低被系统误判为异常行为的概率。这种“降低摩擦成本”的能力，在规模化运营中尤为重要。尤其是在跨区域、多账号、多任务并行的场景下，稳定且可信的网络出口，往往决定了整体效率的上限。</p><h2>从“能用”到“可持续”的转变</h2><p>很多人在第一次接触代理时，关注点往往集中在“能不能访问”“会不会被封”。但随着业务发展，这种短期视角很快会暴露出问题。真正成熟的网络方案，追求的是长期稳定、行为一致、风险可控。<br/>住宅代理的优势，正体现在这种可持续性上。它并不是通过频繁更换身份来规避规则，而是通过更贴近真实用户的网络特征，减少触发规则的概率。这种逻辑上的差异，决定了它更适合长期项目，而不是一次性操作。</p><h2>住宅代理的本质价值</h2><p>如果一定要用一句话来概括住宅代理的意义，那并不是“隐藏身份”，而是“恢复正常身份”。它让你的网络行为重新回到平台所熟悉、所接受的范围之内，从而减少不必要的对抗与损耗。<br/>在一个越来越强调风控、信任与长期价值的互联网环境中，这种能力本身，就已经具备了足够高的战略意义。</p>]]></description></item><item>    <title><![CDATA[出海合规指南：电子签平台如何适配全球主要法域的签名法规？ 俊秀的小摩托_bWeu86 ]]></title>    <link>https://segmentfault.com/a/1190000047601662</link>    <guid>https://segmentfault.com/a/1190000047601662</guid>    <pubDate>2026-02-09 15:06:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在全球数字化转型加速与跨境商业合作日益频繁的今天，电子签名已成为企业出海降本增效、打通全球业务链路的核心工具。然而，不同国家和地区的法律体系、监管要求差异显著，电子签的法律效力认定、技术标准、数据安全等合规要点千差万别，若平台无法精准适配目标法域的法规要求，可能导致电子合同无效、引发法律纠纷，甚至阻碍业务落地。对于出海企业而言，选择一款具备全球合规适配能力的电子签平台，既是规避风险的前提，也是全球化布局的关键支撑。本文将拆解全球主要法域的电子签核心法规要求，为企业出海合规提供可落地的参考。</p><p>一、全球电子签法规核心格局：三大主流模式与区域差异</p><p>目前，全球绝大多数国家和地区已认可电子签的法律效力，但形成了“宽松灵活、分级严格、强调认证”三大主流合规模式，不同法域的细节要求差异显著，构成了企业出海电子签合规的核心挑战。根据《2025年全球电子签名法律法规合规白皮书》，全球电子签法规可划分为以下三大主流体系，且区域特色鲜明。</p><p>（一）美国模式：技术中立，侧重签署意图与流程安全</p><p>美国以《全球和国家商务中的电子签名法》（ESIGN法案）和《统一电子交易法》（UETA法案）为核心，采用“技术中立”原则——不限制电子签的具体技术形式，只要签署双方自愿同意，任何能够证明签署意图、保障签署流程安全的电子签名形式（包括点击“同意”“确认”等简易形式）均具备法律效力。</p><p>其合规核心在于“可追溯性”：需完整记录签署人的身份信息、签署时间、签署行为轨迹，确保签署行为是签署人的真实意思表示，且签署后的文件内容不可篡改。此外，美国不同州对特定场景（如不动产转让、遗嘱）的电子签使用有额外限制，出海企业需结合具体业务场景适配。</p><p>（二）欧盟模式：分级管控，合格签名具备完全法律效力</p><p>欧盟以《电子身份识别和信托服务条例》（eIDAS条例）为核心，采用“分级严格”原则，将电子签名分为三级，不同级别对应不同的法律效力和适用场景，其中合格电子签名（QES）是唯一与手写签名具备同等法律效力的形式，适用于高风险跨境场景。</p><p>简单电子签名（SES）：最低级别，适用于低风险场景（如普通通知、日常沟通），仅需证明签署人身份，法律效力有限；</p><p>高级电子签名（AdES）：需采用加密技术，确保签署人身份可验证、签署行为不可否认、文件内容不可篡改，适用于常规商业合同；</p><p>合格电子签名（QES）：最高级别，需由欧盟认可的合格信任服务提供商（QTSP）颁发，结合加密证书和身份认证，具备与手写签名完全同等的法律效力，适用于跨境贸易、金融借贷、知识产权转让等高风险场景。</p><p>欧盟合规的核心的是“资质认证”与“技术达标”：电子签平台需获得QTSP资质，签署流程需符合eIDAS条例对不同级别签名的技术要求，同时需配合欧盟《通用数据保护条例》（GDPR），保障签署过程中的个人数据安全。</p><p>（三）中国模式：强调可靠，依托权威认证保障法律效力</p><p>中国以《中华人民共和国电子签名法》为核心，采用“强调可靠”原则——仅“可靠电子签名”具备与手写签名同等的法律效力，且明确规定了可靠电子签名的三大认定标准：签署人身份可识别、签署行为是真实意思表示、签署内容不可篡改且可追溯。</p><p>其合规核心在于“权威认证”与“全链路合规”：电子签平台需具备国家认可的电子认证服务资质（CA机构认证），采用国家密码管理局认可的加密技术，同时需符合《网络安全法》《数据安全法》《个人信息保护法》的要求，确保签署数据的安全与合规。对于出海企业而言，若涉及中资主体签约，需同时适配中国与目标法域的双重合规要求。</p><p>（四）其他重点区域：适配本土特色合规要求</p><p>除三大主流模式外，其他重点出海区域的电子签法规也具备鲜明特色，需重点关注：</p><p>中东地区（阿联酋、沙特）：存在独立司法管辖区（如DIFC、ADGM），规则更贴近国际标准，而本土法律则要求更严格的本地化认证，部分场景需配合线下公证；</p><p>拉美/非洲地区：多数国家原则上认可电子签法律效力，但法律体系尚在完善中，司法实践中对电子证据的认可度较低，建议优先采用高级别电子签名；</p><p>日韩地区：认可电子签法律效力，需依托本土CA机构认证，同时对电子签的存储方式、身份验证有额外细节要求，需适配本土技术标准。</p><p>二、出海电子签平台的核心合规适配要点</p><p>结合全球主要法域的法规差异，电子签平台要实现全球合规适配，需围绕“法律适配、技术达标、数据安全、资质认证”四大核心要点构建能力，既要满足不同法域的个性化要求，也要保障跨境签署的便捷性与安全性，避免“一刀切”导致的合规风险。</p><p>（一）法律适配：精准匹配目标法域的法规要求</p><p>平台需具备“分法域适配”能力，根据企业出海的目标市场，灵活切换合规模式——针对美国市场，侧重签署意图与流程追溯；针对欧盟市场，提供分级签名服务并获得QTSP资质；针对中国及东南亚市场，对接本土CA机构，保障可靠电子签名的法律效力。同时，需实时跟进各法域的法规更新，及时调整合规策略，规避法规变动带来的风险。</p><p>（二）技术达标：满足不同法域的技术标准</p><p>技术是合规的基础，平台需具备加密技术、身份认证、痕迹追溯、文件防篡改等核心能力：采用国密算法、RSA加密等国际通用加密技术，保障签署数据的安全性；支持多维度身份认证（人脸识别、护照验证、手机号验证等），适配不同法域的身份验证要求；完整记录签署全流程轨迹，生成不可篡改的审计日志，确保签署行为可追溯；支持PDF、OFD等国际通用文件格式，保障跨境签署的兼容性。</p><p>（三）数据安全：契合全球数据隐私监管要求</p><p>电子签过程中涉及大量个人信息、商业数据，需契合不同法域的数据隐私法规——欧盟GDPR、中国PIPL、美国CCPA等，核心要求包括：数据本地化存储（部分法域要求签署数据存储在本土服务器）、数据传输加密、用户知情权与同意权保障、数据安全审计等。平台需具备灵活的数据存储方案，根据目标法域要求实现数据本地化部署，同时构建全生命周期的数据安全防护体系。</p><p>（四）资质认证：获取目标法域的权威合规资质</p><p>合规资质是电子签法律效力的重要保障，平台需根据目标市场获取对应的权威认证：欧盟市场需获得QTSP资质，中国市场需具备CA电子认证服务资质，全球范围内需通过ISO 27001（信息安全管理体系）、AATL（Adobe信任列表）等国际认证，确保产品与服务的合规性获得全球认可。</p><p>三、国内可开展出海业务的电子签平台盘点</p><p>（一）安证通iTrustSign：合规为先，适配多法域跨境需求</p><p>作为国内头部电子签服务商，安证通深耕电子认证与电子签名领域20余年，其自研的iTrustSign电子签平台，已具备完善的全球合规适配能力，可支撑企业出海后的各类跨境签署场景。该平台不仅契合中国《电子签名法》要求，具备国家认可的CA电子认证资质，同时通过欧盟eIDAS QTSP、美国AATL等国际权威认证，适配欧盟、美国、东南亚等全球主要法域的法规要求，能够为出海企业提供合规、安全、便捷的电子签署服务，尤其在跨境金融、供应链合作等中高风险场景中表现突出，已成功服务多家知名出海企业。</p><p>（二）e签宝（海外品牌eSignGlobal）：生态完善，深耕新兴市场</p><p>e签宝作为国内电子签名行业的头部企业，以“亚太第一、全球第六”的排名跻身全球电子签名第一梯队，其海外专属品牌eSignGlobal专注于跨境电子签服务，已实现全球70多个国家和地区的合规覆盖。平台重点深耕东南亚、中东等新兴市场，在香港、新加坡、法兰克福部署本地化数据中心，满足不同地区的数据主权要求，全面适配欧盟eIDAS、美国ESIGN及中国PIPL等法规。其推出的“智能合同Agent”可实现合同审查、全周期AI管理，且能与钉钉、飞书等国内外主流办公系统无缝对接，更适配中小规模出海企业与新兴市场布局需求。</p><p>（三）法大大（海外品牌Nota Sign）：资质领先，聚焦全球合规矩阵</p><p>法大大作为国内电子签行业的核心玩家，推出专属出海产品“Nota Sign全球签”，聚焦全球合规布局，凭借权威资质认证成为中企出海的重要选择。该平台成功通过SOC 2 Type I审计，成为国内首个通过这一国际权威安全审计标准的电子签平台，其合规体系与欧盟GDPR、美国CCPA、新加坡PDPA等全球主流数据安全法规高度契合，具备极强的国际认可度。</p><p>Nota Sign已在全球核心区域部署数据中心，覆盖北京、中国香港、美国、德国、新加坡、巴西、中东等多个地区，可提供本地化合规签约服务，适配超100个国家/地区的电子签法规要求，全面遵循美国ESIGN、欧盟eIDAS/GDPR等核心法规。其在系统安全性、服务可用性及隐私保护方面达到国际一流水准，尤其适配跨境贸易、海外投融资等对合规性要求极高的场景，为出海企业构建了接轨全球的合规保障体系。</p><p>君子签（海外品牌FairSigning）：AI赋能，强化合规闭环</p><p>君子签面向全球市场推出的跨境电子合同平台FairSigning，是2026年跨境电子签领域的核心黑马，已实现全球80余个跨境贸易核心国家和地区的法律适配，涵盖欧盟eIDAS条例、美国ESIGN法案及东南亚多国相关法规。平台搭载司法级区块链存证技术与银行级加密技术，结合多重身份验证机制，满足GDPR、CCPA等国际隐私法规要求，实现签署全流程可追溯、不可篡改。其内置的AI法律合规验证引擎可自动审查合同关键条款，提供跨法域合规提示，同时支持多语言界面与合同模板，适配各类跨境签署场景。</p><p>（五）其他可出海平台：各有侧重，适配细分场景</p><p>除上述主流平台外，国内还有部分电子签平台凭借专项优势开展出海业务：部分平台侧重轻量化服务，以高性价比、简易操作见长，适配自由职业者、小微出海团队的偶发签署需求；部分平台深耕特定行业，在跨境电商、跨境物流等细分场景中构建了专属解决方案，依托行业Know-How为企业提供定制化服务；还有部分平台通过与全球知名CA机构、司法机构合作，强化电子证据的国际认可度，重点适配跨境仲裁、知识产权转让等高风险场景。值得注意的是，这类平台大多已通过核心国际合规认证，具备基本的跨法域适配能力，但在全球覆盖广度、复杂场景适配性上与头部平台存在一定差距。</p><p>四、合规为先，让电子签成为出海的“助推器”</p><p>企业出海，合规是底线，电子签作为跨境商业合作的核心工具，其合规适配能力直接决定了企业全球业务的顺畅度与安全性。全球电子签法规的核心差异在于“法律效力认定标准”“技术要求”“数据安全”，电子签平台需立足这三大差异，构建分法域、全链路、多层次的合规体系，既要精准匹配目标法域的个性化要求，也要兼顾签署的便捷性与安全性。</p><p>从国内可出海电子签平台的实践来看，平台的全球合规适配能力，核心在于对不同法域法规的精准解读、技术实力的全面支撑以及权威资质的背书——无论是安证通iTrustSign、e签宝eSignGlobal这类头部平台，还是聚焦细分领域的专项平台，其核心竞争力均围绕前文提及的法律适配、技术达标、数据安全、资质认证四大要点构建。对于出海企业而言，无需盲目追求“大而全”，可结合自身出海目的地、业务规模、场景风险等级，选择适配自身需求的平台。</p><p>对于出海企业而言，选择一款适配自身需求、具备核心合规能力的电子签平台，既是规避跨境签署风险的关键，也是加速全球化布局的重要支撑。安证通iTrustSign等头部平台的实践，也为中企出海选择电子签平台提供了清晰参考：优先选择具备国际合规资质、全球法规适配能力、全链路数据安全保障的平台，才能真正发挥电子签降本增效的价值。未来，随着全球电子签法规的不断完善与中企出海的持续深化，国内电子签平台的全球化能力将进一步提升，成为中企出海的重要数字基建支撑。</p>]]></description></item><item>    <title><![CDATA[外汇行情API实战：如何实现毫秒级实时市场数据掌控？ Jackyy ]]></title>    <link>https://segmentfault.com/a/1190000047601669</link>    <guid>https://segmentfault.com/a/1190000047601669</guid>    <pubDate>2026-02-09 15:05:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>作为金融领域的开发者/从业者，你一定深有体会：外汇市场汇率以毫秒级更新，单日波动可达数百点，能否拿到低延迟、高稳定的实时行情数据，直接决定了量化交易策略的执行效率，甚至是交易决策的成败。在高频交易成为常态的当下，搭建基于外汇行情API的实时数据监控体系，是突破数据延迟、接口不稳定等痛点的核心方案。</p><h2>开发者核心诉求：实时行情是交易策略落地的底层支撑</h2><p>外汇交易的本质是对市场波动的精准捕捉，而你的每一次策略迭代、实盘执行，都离不开<strong>实时、无误差</strong>的行情数据：</p><ul><li>跨时区交易场景中，哪怕几秒的数据延迟，都可能导致交易点位偏离预期；</li><li>突发市场消息触发价格异动时，延迟获取数据会直接错失盈利机会；</li><li>量化交易/自动化交易场景，对数据的实时性、稳定性更是硬性要求——传统人工刷新、第三方平台转发的方式，早已无法适配高频交易的需求。</li></ul><p>简单来说，你需要的是一套能直接对接市场的数据流体系，而非“人工+工具”的低效组合，让数据获取与交易决策无缝衔接。</p><h2>传统方案的技术瓶颈：为什么越用越“卡”？</h2><p>尽管实时数据需求迫切，但传统数据获取方式的技术缺陷，始终是开发者的“绊脚石”：</p><ol><li><strong>效率低</strong>：人工刷新行情页面、整合多平台数据，不仅耗人力，还会产生不可控的时间延迟，完全跟不上毫秒级更新的外汇市场；</li><li><strong>数据不准</strong>：非专业数据渠道的信息存在误差，且不支持定制化推送，满足不了量化交易对“精细化数据维度”的需求；</li><li><p><strong>技术层面硬伤</strong>：</p><ul><li>传统HTTP轮询无法实现数据主动推送，实时性大打折扣；</li><li>常规接口稳定性差，网络波动/服务端故障易导致数据中断，且高频请求极易触发限流，直接影响策略执行。</li></ul></li></ol><h2>核心解决方案：外汇行情API的技术实现与接入步骤</h2><p>针对上述痛点，专为金融场景设计的外汇行情API是最优解——核心优势集中在“低延迟、高稳定、强适配”，而技术层面的关键是<strong>WebSocket协议</strong>（替代传统HTTP），以及合规的金融数据链路。</p><h3>1. 外汇行情API的核心技术特性</h3><ul><li><strong>低延迟</strong>：支持WebSocket长连接，实现服务端主动推送数据，延迟降至毫秒级（对比HTTP轮询的秒级延迟，优势显著）；</li><li><strong>高稳定</strong>：正规服务商拥有专属金融数据链路，能规避网络波动导致的断连问题；</li><li><strong>高适配</strong>：可定制数据维度，覆盖主流货币对的实时汇率、涨跌幅度、成交点位等核心信息，适配量化交易、实时监控等场景。</li></ul><h3>2. 手把手教你接入：4步搞定实时行情API</h3><p>接入流程清晰且易操作，核心分为4步，以下结合AllTick API给出可直接落地的实操步骤：</p><h4>步骤1：甄选合规的API服务商</h4><p>优先选满足以下条件的服务商（直接决定后续接入效率）：</p><ul><li>支持WebSocket协议；</li><li>拥有金融数据服务资质；</li><li>能保障数据实时性与连接稳定性（可先测试服务商的demo接口）。</li></ul><h4>步骤2：获取API密钥</h4><p>完成服务商平台的账户注册、资质审核，申请专属API密钥——这是接口调用的身份凭证，务必妥善保管，避免泄露。</p><h4>步骤3：技术集成（核心实操，代码100%保留）</h4><p>依托服务商提供的技术文档，将API对接至你的交易系统/分析系统，以下是基于AllTick API的简易集成示例，可直接运行获取实时行情：</p><pre><code class="python">import websocket
import json

# 连接AllTick外汇行情API的WebSocket地址
url = "wss://realtime-api.alltick.co/forex"

def on_message(ws, message):
    # 解析并处理实时行情数据
    data = json.loads(message)
    print(f"实时外汇行情数据：{data}")

def on_error(ws, error):
    # 捕获并输出连接错误信息
    print(f"API连接出现错误：{error}")

def on_close(ws, close_status_code, close_msg):
    # 输出连接关闭提示
    print("API连接已正常关闭")

def on_open(ws):
    # 输出连接成功提示，开始接收数据
    print("API连接成功，已进入实时数据接收状态")

# 创建WebSocket客户端并运行
ws = websocket.WebSocketApp(url, on_message=on_message, on_error=on_error, on_close=on_close)
ws.on_open = on_open
ws.run_forever()</code></pre><blockquote>🔔 前置条件：运行代码前需安装依赖：<code>pip install websocket-client</code></blockquote><h4>步骤4：数据处理与可视化</h4><p>将API获取的实时数据流做进一步加工：</p><ul><li>用Matplotlib/Plotly实现汇率波动的可视化图表，直观展示趋势；</li><li>对接后端数据库（如MySQL/Redis）完成数据存储，方便后续回测分析；</li><li>可在代码中加入<strong>断连重连、限流规避</strong>逻辑，提升稳定性（比如捕获连接异常后自动重试）。</li></ul><h2>实战落地场景：API如何赋能交易全流程？</h2><p>外汇行情API的价值，远不止“获取数据”，更能深度融入你的日常开发/交易环节：</p><h3>场景1：基金公司量化交易</h3><ul><li>研究员：用API实时数据结合宏观经济指标，完成市场走势分析，为策略制定提供精准数据支撑；</li><li>量化团队：将API数据对接量化模型，实现策略自动化回测与实盘执行——当汇率达到模型阈值时，系统自动触发买卖操作，无需人工干预。</li></ul><h3>场景2：个人专业交易者</h3><ul><li>实时监控：通过API推送的毫秒级数据，第一时间捕捉市场异动，结合技术分析工具快速决策；</li><li>稳定性优化：在代码中加入重试机制、限流规避逻辑，解决WebSocket断连、API频率限制等问题，让数据获取体系更健壮。</li></ul><h2>行业趋势：API已成金融开发的基础设施</h2><p>随着外汇交易的数字化、智能化升级，外汇行情API早已不是“可选项”，而是金融开发者的“标配”。作为开发者，你只需聚焦两点：</p><ol><li>选对合规、稳定的API服务商；</li><li>优化API接入逻辑与数据处理体系（比如断连重连、数据缓存、可视化）。<br/>最终让实时行情数据真正成为交易决策的“核心抓手”，在波动剧烈的外汇市场中保持决策的精准性与时效性。</li></ol><hr/><h3>总结</h3><ol><li>外汇行情API的核心优势是<strong>WebSocket长连接+专属金融链路</strong>，可实现毫秒级低延迟、高稳定的数据推送；</li><li>接入流程核心为“选服务商→拿密钥→技术集成→数据处理”，其中代码集成环节可直接复用文中的AllTick API示例（需先装websocket-client依赖）；</li><li>落地时重点关注<strong>稳定性优化</strong>（断连重连、限流规避），让数据体系适配高频交易场景。</li></ol>]]></description></item><item>    <title><![CDATA[openKylin 2.0 SP2第二次重要更新 | 200余项缺陷修复、浏览器等高频应用全新升级！]]></title>    <link>https://segmentfault.com/a/1190000047601671</link>    <guid>https://segmentfault.com/a/1190000047601671</guid>    <pubDate>2026-02-09 15:04:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>今日，OpenAtom openKylin（以下简称“openKylin”）社区正式推送 openKylin 2.0 SP2 第二次更新升级。本次更新针对系统稳定性，共修复200余项缺陷，重点解决蓝牙连接异常（如文件传输中断、弹窗错位）、双屏显示不稳定等问题；强化多语言支持，提升藏文、蒙古文、繁体中文等界面翻译的覆盖度；完善核心功能，优化软件商店装包稳定性、驱动兼容性（如 Realtek 8852BE WiFi网卡）；上线支持磐石架构的KMRE移动兼容环境、openKylin Wine助手；升级火狐浏览器、微信、QQ 等高频应用至最新稳定版本等。<br/><img width="723" height="319" referrerpolicy="no-referrer" src="/img/bVdnTwX" alt="" title=""/></p><p>01系统安装与升级方式<br/>方式一：从openKylin官网（扫描下方二维码或点击“阅读原文”）下载最新镜像进行安装（适用于新用户或想重新安装系统的用户）；<br/><img width="400" height="400" referrerpolicy="no-referrer" src="/img/bVdnTwY" alt="" title="" loading="lazy"/></p><p>方式二：前往系统设置—“更新”界面，按提示完成系统更新（适用于已安装旧版本的用户）；</p><p>方式三：打开维护模式（设置-关于-点击5次UKUI Logo-侧边栏找到维护模式并打开），通过终端运行以下命令进行更新，升级后退出维护模式（适用于开发者）：sudo apt updatesudo apt upgrade</p><p>02主要缺陷修复及体验优化<br/>主要缺陷修复<br/>桌面环境<br/>【通知中心】修复藏文环境下鼠标悬浮通知中心图标，提示英文的问题【网络管理】修复wifi优先级设置未立即生效的问题【网络管理】修复新建有线网不进行授权认证，点击保存，第二次超时弹窗未汉化的问题【网络管理】修复新建有线网络，点击保存，认证弹窗点击失败，添加失败弹窗未汉化的问题【网络管理】优化无线网络连接，修复部分用户反馈的检测不到无线网络的问题【文件管理器】修复藏文下，文件管理器标题栏选项按钮中的Samba拼写错误的问题【文件管理器】修复繁体环境下，文管窗口文档部分显示英文的问题【文件管理器】修复复制大文件时任务栏窗口显示异常的问题【文件管理器】修复切换为藏文后，文件管理器中存在乱码的问题【文件管理器】修复英文下最大、次最大字体时窗口显示有遮挡的问题【文件管理器】修复用户反馈的繁体环境下，鼠标右键菜单里部分选项未被翻译为繁体的问题【文件管理器】修复用户反馈的双击启动应用程序相较于右键启动有很大延迟的问题【文件管理器】修复用户反馈的在分辨率缩放情况下，桌面壁纸异常显示的问题【文件管理器】优化大量文件同时拷贝等场景下出现崩溃的问题【文件管理器】修复右键双击标题栏，窗口会最大化的问题【侧边栏】修复藏文、蒙古文、繁体下，侧边栏部分字体仍显示英文的问题【登录锁频】修复部分用户反馈的关机再开机或者重启，需要大约1分钟时间才显示登录界面，且登录界面显示异常的问题【登录锁屏】修复不能正常开机自启动小键盘的问题【登录锁屏】修复切换其他语言，锁屏/登录界面，无线网络连接时提示信息为英文的问题【登录锁屏】修复忘记密码的提示文案不正确的问题【登录锁屏】修复相册屏保未自动轮播的问题【登录锁屏】修复用户反馈的设置了限制密码错误次数后，输入正确密码但锁定三分钟的问题【USD】修复英文环境下非最小字体由小到大切换时按钮文字显示不全的问题【USD】修复藏文最大字体下确认报警信息弹窗按钮文字显示不全的问题【会话管理器】修复多用户登录的情况下，右键开始菜单，点击电源选项-重启/关机，没有多用户重启提示的问题【会话管理器】修复存在未保存的WPS文件、画图文件时，执行重启/关机/注销，没有任何提示，直接重启/关机/注销的问题【会话管理器】修复用户反馈的遇到电源键鼠标左键点击无效的问题【开始菜单】修复登录两个用户，右键开始菜单，点击重启/关机，没有弹窗提示，直接关机/重启的问题【开始菜单】修复切换到字母排序或功能排序后，按上下方向键无法移动到字母导航栏或功能导航栏的问题【开始菜单】修复系统语言为繁体，部分显示为英文的问题【控制面板】修复控制面板中选择德语重启后不勾选的问题【控制面板】修复默认应用不正确的问题【控制面板】修复用户反馈的VPN在设置中关闭vpn后，重启会自动恢复的问题【控制面板】修复用户反馈的系统快捷键设置存在冲突时的提示不够明确的问题【控制面板】修复wlcom环境下，首次打开设置-关于，设置窗口会异常缩小的问题【控制面板】修复侧边栏AI管理模块缺失图标的问题【快捷键】修复自定义快捷键，无法设置按键组合的问题【蓝牙】修复打开托盘处蓝牙，再打开屏幕键盘，关闭屏幕键盘后，蓝牙弹窗没有恢复到原来位置的问题【蓝牙】修复断开已连接的蓝牙设备，在任务栏界面该设备移动界面最低部的问题【蓝牙】修复多次发起批量文件，发送端和接收端文件不一致的问题【蓝牙】修复繁体时，发送文件弹窗存在英文的问题【蓝牙】修复连接蓝牙设备失败，一直处于连接状态，重新打开控制面板扫描不到蓝牙设备的问题【蓝牙】修复音频设备的主动连接弹窗显示不正确的问题【任务栏】修复wlcom环境下，应用打开子窗口的情况下，任务栏软件图标或预览图无法激活应用的问题【任务栏】修复藏文、蒙古文、繁体文任务栏部分内容未翻译的问题【任务栏】修复藏文/蒙古文/繁体文系统，开始菜单悬浮提示未汉化的问题【任务栏】修复多用户重启系统时，会话工具存在任务栏图标的问题【任务栏】修复任务栏固定应用数量超过任务栏宽度，往右拖动最右侧的应用任务栏会自动滑到最左侧的问题【任务栏】修复英文环境下，快捷菜单冷冻模式和wifi显示不完全，悬浮无提示的问题【任务栏】修复用户反馈的任务栏“显示桌面”按钮区域并没有完全覆盖任务栏的最右边，导致滑到屏幕右下角点击无效的问题【任务栏】修复悬浮任务栏开始菜单图标，显示为英文的问题【会话管理器】修复WPS文件编辑未保存，点击电源-关机，没有提示未保存，机器直接关机的问题【主题】修复wlcom环境下，控制面板背景设置后不生效，重启才生效的问题【主题】修复藏文环境下系统，主题界面按钮文字显示不完全的问题【区域语言】修复藏文系统下，输入法设置显示为中文的问题【区域语言】修复藏文系统下，添加语言弹窗关闭按钮悬浮为英文的问题【时间和日期】修复藏文系统下，授权弹窗藏化不完全的问题【时间和日期】修复添加时区和修改时区页面关闭按钮悬浮为英文的问题【时间和语言】修复在修改时区和添加时区搜索框输入不存在的时区，没有无结果的提示的问题</p><p>系统应用<br/>【归档管理器】修复解压缩后的弹窗“显示文件”，弹出两个文件管理器界面的问题【归档管理器】修复蒙古文环境下，存在部分的翻译异常问题【计算器】修复ARM架构下，用键盘的数字无法输入的问题【计算器】修复蒙古文计算器标题栏为英文，且选项菜单存在英文显示的问题【截图】修复区域截图后无法选择字体的问题【微信】修复订阅号页面无法调用系统默认浏览器的问题【开明包格式】修复运行开源系列的开明包应用均无图标的问题【天气】优化天气出现定位不准的问题【录音】修复蒙古文右键点击已存在的录音文件，下拉菜单存在英文内容的问题【用户手册】修复英文环境下，关于界面的图片所属张数错误的问题【日历】 修复英文环境下，日程中存在部分项悬浮没有内容的问题【U盘管理工具】修复英文环境下，插入异常U盘，提示弹窗格式化按钮显示不全的问题【系统监视器】修复系统语言为蒙古文，会话管理器下方系统监视器显示简体中文的问题【系统监视器】修复磁盘详情页面连续点击不同磁盘应用闪退的问题【虚拟键盘】修复用户反馈的鼠标拖动移动悬浮球与虚拟键盘时，出现悬浮球与虚拟键盘严重抖动的问题【虚拟键盘】修复用户反馈的鼠标长按虚拟键盘时，键盘出现闪烁的问题【音乐】修复蒙古文环境下，存在部分的翻译异常问题【日历】修复调整缩放率为175%和200%，日历页面位置异常的问题【日历】修复用户反馈的农历时间存在错误的问题【麒麟管家】修复部分用户反馈的麒麟管家应用右上角关闭按钮变小的问题【麒麟管家】修复用户反馈的通过服务支持反馈问题时，一旦勾选高级模式，界面就不正常的问题【软件商店】根据社区用户反馈，上架最新版原生微信、QQ音乐等应用【软件商店】修复软件商店更新下点击更新某些应用，提示安装失败的问题【软件商店】修复正在下载界面内悬浮在软件上，悬浮显示的网速位置在窗口右侧的问题【第三方软件】修复用户反馈的 WPS办公软件卸载不完全的问题</p><p>系统支撑<br/>【wlcom】修复命令行启动应用，窗管显示异常的问题【安装器】修复英文环境-大号字体下，卸载器界面存在截断的问题【安装器】修复应用图标显示为默认图标时，图标显示较小且居于左上角的问题【安装器】修复用户反馈的浏览器下载qq安装包无法安装的问题【电源管理】修复控制面板中电源管理模块未翻译完全的问题【电源管理】修复英文模式下，查看控制面板-系统-电源，各子选项中存在首字母未大写情况的问题【定时关机】修复菜单栏的“选项”按钮，悬浮提示显示“更多”，与其它应用显示不一致的问题【定时关机】修复设置时间为当前时间，剩余时间显示错误的问题【多语言】修复Wayland模式下，英文模式切换到法语无法切换的问题【龙芯】修复部分龙芯平台机型上无法进入桌面的问题【系统启动】优化系统重启等待时间【软件源】修复pristine-tar的依赖问题【软件源】修复下载安装libkysdk-system-dev时报错的问题【声音】修复英文下用户手册缺少内容介绍的问题【系统安装】修复安装各界面滚动条、输入框未屏蔽右键菜单的问题【系统安装】修复部分用户反馈的在多系统共存环境下安装不成功的问题【系统安装】修复系统安装流程中存在的部分未汉化的问题【系统安装】修复虚拟机安装时，数据盘分区太小的问题【显示器】修复用户反馈的出现系统崩溃：Abnormal display,and the input method cannot be sw的问题【显示器】修复镜像模式下，显示器预览图为两个的问题【显示器】修复镜像模式下插拔显示器进行旋转，两个屏幕显示不同步的问题【显示器】修复扩展模式下，调整其中一个屏幕亮度另一个屏幕亮度也会随之改变的问题【显示器】修复连接多个显示器进行插拔，控制面板内显示多个亮度条的问题【显示器】修复连接双屏，设置投影仪为主屏，关闭投影仪，主屏未切换到显示器上的问题【显示器】修复连接投影仪，屏幕旋转90°，重启后桌面花屏的问题【显示器】修复屏幕旋转后点击桌面，桌面呈现黑色部分的问题【显示器】修复切换分辨率后，点击桌面壁纸发生变化的问题【显示器】修复拖动预览图改变屏幕相对位置，4K屏会闪现部分黑屏的问题【显示器】修复用户反馈的在高分辨率下在VMware虚拟机上出现的屏闪问题【硬件驱动】修复Realtek 8852BE Wireless LAN WiFi 6 PCI-E NIC网卡无法驱动的问题</p>]]></description></item><item>    <title><![CDATA[Istio 流量治理实战：镜像、超时重试、熔断与限流，一次讲透 it排球君 ]]></title>    <link>https://segmentfault.com/a/1190000047601675</link>    <guid>https://segmentfault.com/a/1190000047601675</guid>    <pubDate>2026-02-09 15:03:31</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>前言</h2><p>本小节继续来描述istio对于流量的各种操作</p><h2>流量镜像</h2><p>对标nginx的mirror功能，复制一份流量到对应的地址去，通常用来做从线上环境引流至其他环境做测试或者分析</p><pre><code>apiVersion: networking.istio.io/v1
kind: VirtualService
metadata:
  name: backend-vs
  namespace: default
spec:
  hosts:
  - backend-service
  - api.wilsontest.com
  http:
  - mirror:
      host: backend-service
      subset: v1
    mirrorPercentage:
      value: 100
    route:
    - destination:
        host: backend-service
        subset: v0
</code></pre><p>流量先到v0版本，istio-proxy复制一份流量到v1版本。如果不想1比1复刻，可以调整mirrorPercentage百分比功能</p><p>如果mirror host的目标不存在，怎么发现该错误及时调整host配置呢？</p><h2>超时/重试</h2><p>配置超时/重试的原因主要是为了解决：</p><ul><li>调用外部网络的接口，很容易产生诸如502、504、499，甚至连接中断等问题，有了重试，可以尽可能的尝试再次发起，而不是直接报错</li><li>公用云网络抖动，导致客户端收到一堆5xx，从而引起客户产生不适</li><li>后端服务没有优雅更新，一旦发版，导致大量502，重试可以缓解502，避免告警风暴</li></ul><pre><code>apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: backend-retry
spec:
  hosts:
  - backend-service
  http:
  - route:
    - destination:
        host: backend-service
    timeout: 1s
    retries:
      attempts: 3  # 最大重试次数
      perTryTimeout: 1s  # 每次尝试的超时
      retryOn:  # 触发重试的条件
        - 5xx
        - gateway-error
        - connect-failure
        - refused-stream</code></pre><p>有位老哥说了，如果一套qps很高的集群，一旦发生重试，那就意味着短时间之内上游服务的qps至少翻一倍（第一波请求不成功，很快第二波请求就要来了），那这时候上游服务就有被冲垮的风险</p><p>说的没错，重试是为了提高请求的成功率，但是不可避免增加系统负载，并且增加请求的响应时间，如果大量重试，那就会导致重试风暴，带来更大的问题</p><h4>重试次数</h4><p>为了避免重试风暴，在配置策略的时候应该考虑合理的重试次数</p><pre><code>    retries:
      attempts: 3  # 最大重试次数
      perTryTimeout: 1s  # 每次尝试的超时</code></pre><p>重试3次，每次间隔1s，然后就应该报错，介入查看了</p><h4>级联超时</h4><p>超时时间逐层递减，前端超时 &gt; 网关超时 &gt; 服务超时<br/>frontend: timeout: 5s<br/>nginx-test: timeout: 3s<br/>backend-service: timeout: 2s</p><h4>退避策略</h4><p>简而言之，就是重试失败之后不是马上重试，而是等一段时间再重试</p><ul><li><p>固定退避（Fixed Backoff）：每次重试等待固定时间</p><ul><li>attempt 1: 等待 100ms</li><li>attempt 2: 等待 100ms</li><li>attempt 3: 等待 100ms</li></ul></li><li><p>线性退避（Linear Backoff）：等待时间线性增加</p><ul><li>attempt 1: 等待 100ms</li><li>attempt 2: 等待 200ms</li><li>attempt 3: 等待 300ms</li></ul></li><li><p>指数退避（Exponential Backoff）：等待时间按指数增加（乘以系数），最使用也最常用</p><ul><li>attempt 1: 等待 100ms</li><li>attempt 2: 等待 200ms</li><li>attempt 3: 等待 400ms</li><li>attempt 4: 等待 800ms</li><li>attempt 5: 等待 1600ms</li></ul></li><li><p>随机退避（Jitter/随机抖动）：在退避时间中加入随机性，打破同一时间重试，避免"惊群效应"</p><ul><li>attempt 1: 等待 100ms ± 随机时间</li><li>attempt 2: 等待 200ms ± 随机时间</li></ul></li></ul><pre><code>apiVersion: networking.istio.io/v1
kind: VirtualService
metadata:
  name: backend-vs
  namespace: default
spec:
  hosts:
  - backend-service
  - api.wilsontest.com
  http:
  - retries:
      attempts: 10
      perTryTimeout: 1s
      retryOn: 5xx,connect-failure
    route:
    - destination:
        host: backend-service
        subset: v0
</code></pre><h4>测试istio-proxy的策略</h4><p>istio-proxy自带了<code>指数退避</code>与<code>随机退避</code>，初始25ms</p><p>为了探索istio-proxy是否带有<code>指数退避</code>与<code>随机退避</code>的特点，特意设置<code>attempts: 10</code>（日常用可以设置小一点，比如笔者通常设置为3）</p><p>设置后端报错代码，只要报错5xx即可，所以我直接将代码的关键字改错，应该会报语法错误或者方法找不到之类的</p><pre><code>Traceback (most recent call last):
  File "/usr/local/lib/python3.11/site-packages/tornado/web.py", line 1846, in _execute
    result = method(*self.path_args, **self.path_kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/test.py", line 9, in get
    self.writ(ret)
    ^^^^^^^^^
AttributeError: 'TestFlow' object has no attribute 'writ'
</code></pre><p>都准备好了，开始测试：</p><ul><li><code>curl -s -H 'host: api.wilsontest.com' 10.22.12.178:30785/test</code></li><li><p>查看日志，有11条日志，符合预期：第1次访问+<code>attempts: 10</code></p><pre><code>[2026-02-05T06:51:41.322Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=1ms route=default
[2026-02-05T06:51:41.332Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=1ms route=default
[2026-02-05T06:51:41.369Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=2ms route=default
[2026-02-05T06:51:41.441Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=1ms route=default
[2026-02-05T06:51:41.463Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=2ms route=default
[2026-02-05T06:51:41.480Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=1ms route=default
[2026-02-05T06:51:41.660Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=1ms route=default
[2026-02-05T06:51:41.787Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=1ms route=default
[2026-02-05T06:51:41.804Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=1ms route=default
[2026-02-05T06:51:41.978Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=1ms route=default
[2026-02-05T06:51:42.116Z] "GET /test HTTP/1.1" 500 - upstream=10.244.0.73:10000 duration=2ms route=default</code></pre></li><li><p>分析下时间</p><table><thead><tr><th>序号</th><th>时间戳</th><th>与上一次间隔</th></tr></thead><tbody><tr><td>1</td><td>41.322</td><td>—</td></tr><tr><td>2</td><td>41.332</td><td><strong>+10ms</strong></td></tr><tr><td>3</td><td>41.369</td><td><strong>+37ms</strong></td></tr><tr><td>4</td><td>41.441</td><td><strong>+72ms</strong></td></tr><tr><td>5</td><td>41.463</td><td><strong>+22ms</strong></td></tr><tr><td>6</td><td>41.480</td><td><strong>+17ms</strong></td></tr><tr><td>7</td><td>41.660</td><td><strong>+180ms</strong></td></tr><tr><td>8</td><td>41.787</td><td><strong>+127ms</strong></td></tr><tr><td>9</td><td>41.804</td><td><strong>+17ms</strong></td></tr><tr><td>10</td><td>41.978</td><td><strong>+174ms</strong></td></tr><tr><td>11</td><td>42.116</td><td><strong>+138ms</strong></td></tr></tbody></table></li><li><p>从日志看来确实满足了<code>指数</code>+<code>随机</code>，初始 backoff：~25ms、指数增长、加入 jitter（随机抖动）</p><ul><li>10ms → 37ms → 72ms → 180ms → 127ms → 174ms → 138ms</li></ul></li></ul><p>经过这次简单的测试：</p><ul><li>配置重试应该要针对幂等的request，非幂等是绝对不能使用重试的</li><li>retries应该要配置小一些，否则就会出现重试风暴，就像测试中10次，相当于原请求放大了10倍</li></ul><h2>熔断</h2><p>熔断是为了保护后端服务不被流量风暴淹没，保护系统整体稳定</p><ul><li><p>目标：如果后端检测5xx，超过3次，就将该pod踢下线，30s之后又加回来</p><pre><code>apiVersion: networking.istio.io/v1
kind: DestinationRule
metadata:
  name: backend-dr
  namespace: default
spec:
  host: backend-service
  subsets:
  - labels:
      version: v0
    name: v0
  trafficPolicy:
    outlierDetection:
      baseEjectionTime: 30s
      consecutive5xxErrors: 3
      interval: 5s
      maxEjectionPercent: 100</code></pre><ul><li><code>baseEjectionTime： 30s</code>：服务被下线的时间，30s</li><li><code>consecutive5xxErrors: 3</code>：触发熔断的条件，有3次5xx</li><li><code>interval: 5s</code>：检测间隔，5s</li><li><code>maxEjectionPercent： 100</code>，被下线的服务比例，100%</li></ul></li><li><p>后端backend服务依然会报错500，先访问3次，<code>curl -s -H 'host: api.wilsontest.com' 10.22.12.178:30785/test</code></p><pre><code>Traceback (most recent call last):
  File "/usr/local/lib/python3.11/site-packages/tornado/web.py", line 1846, in _execute
    result = method(*self.path_args, **self.path_kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/test.py", line 9, in get
    self.writ(ret)</code></pre></li><li><p>第四次再访问</p><pre><code>no healthy upstream</code></pre></li><li>符合预期，第四次服务直接被熔断了，并且由于backend的pod只有1个，istio下线了，导致nginx没有upstream</li></ul><h2>限流</h2><p>首先基于http1.1，每次发起http并不是短链了，而是长连接。为了不让每次都产生3次握手与4次挥手的连接消耗，istio-proxy与后端服务backend之间会维护一个长连接</p><ul><li><p>配置在DestinationRule上</p><pre><code>apiVersion: networking.istio.io/v1
kind: DestinationRule
metadata:
  name: backend-dr
  namespace: default
spec:
  host: backend-service
  subsets:
  - labels:
      version: v0
    name: v0
  trafficPolicy:
    connectionPool:
      http:
        http1MaxPendingRequests: 1
        maxRequestsPerConnection: 5
</code></pre><ul><li><code>http1MaxPendingRequests: 1</code>与<code>maxRequestsPerConnection: 5</code>是为了方便测试，改得非常的小</li><li><code>http1MaxPendingRequests: 1</code>：等待“可用连接”的 HTTP 请求数量，如果没有可用连接，最多允许1个，超出就报503</li><li><code>maxRequestsPerConnection: 5</code>：一条 TCP 连接上最多处理多少个 HTTP 请求</li></ul></li><li><p>使用wrk压测工具，用20个并发，同时发送20个连接，向目标url发送请求，持续1s</p><pre><code>▶ wrk -t20 -c20 -d1s -H 'Host: api.wilson.com' http://10.22.12.178:30785/test
Running 1s test @ http://10.22.12.178:30785/test
  20 threads and 20 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    10.66ms    3.18ms  21.85ms   76.73%
    Req/Sec    93.55     16.33   171.00     80.75%
  1990 requests in 1.10s, 650.09KB read
  Non-2xx or 3xx responses: 92
Requests/sec:   1808.21
Transfer/sec:    590.70KB
</code></pre><ul><li>可以看到，1秒之内有1990个请求发送至目标url</li><li>其中有92个请求有问题</li></ul></li><li><p>检查日志</p><pre><code>...
[2026-02-06T07:37:08.168Z] "GET /test HTTP/1.1" 200 - upstream=10.244.0.73:10000 duration=5ms route=default
[2026-02-06T07:37:08.169Z] "GET /test HTTP/1.1" 503 UO upstream=- duration=0ms route=default
[2026-02-06T07:37:08.169Z] "GET /test HTTP/1.1" 0 DC upstream=10.244.0.73:10000 duration=4ms route=default
...</code></pre><ul><li>http_code是200是正常请求，503就是熔断保护的结果，触发了istio熔断保护而返回客户端503</li><li>http_code是0，通常意味着 连接在 HTTP 响应头完整返回之前就已经断开了，这非常类似于nginx的499。他们本质都描述了一个问题，客户端没有等到结果就终止连接了，这应该和我们压测只持续了1s有关系</li></ul></li></ul><h2>联系我</h2><ul><li>联系我，做深入的交流</li></ul><p><img width="723" height="266" referrerpolicy="no-referrer" src="/img/bVde2lR" alt="" title=""/></p><hr/><p>至此，本文结束<br/>在下才疏学浅，有撒汤漏水的，请各位不吝赐教...</p>]]></description></item><item>    <title><![CDATA[高德开放平台《两轮车行业专版导航服务2025年度报告》 高德开放平台 ]]></title>    <link>https://segmentfault.com/a/1190000047601801</link>    <guid>https://segmentfault.com/a/1190000047601801</guid>    <pubDate>2026-02-09 15:02:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnTyj" alt="" title=""/><br/><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnTyl" alt="" title="" loading="lazy"/><br/><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnTyG" alt="" title="" loading="lazy"/><br/><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnTyX" alt="" title="" loading="lazy"/><br/><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnTyY" alt="" title="" loading="lazy"/><br/><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnTyZ" alt="" title="" loading="lazy"/><br/><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnTy0" alt="" title="" loading="lazy"/><br/><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnTy1" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[BeautifulSoup：Python网页解析的优雅利器 小小张说故事 ]]></title>    <link>https://segmentfault.com/a/1190000047601804</link>    <guid>https://segmentfault.com/a/1190000047601804</guid>    <pubDate>2026-02-09 15:01:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>1. 库的概览与核心价值</h2><p>想象一下，你面对着成千上万个杂乱的网页，需要从中提取有价值的信息——就像在一堆没有标注的书籍中寻找特定的章节。如果手动去解析那些层层嵌套、格式混乱的HTML代码，就像在没有索引的情况下翻阅整个图书馆。<code>BeautifulSoup</code>正是为解决这个痛点而生的工具。</p><p>BeautifulSoup（全称beautifulsoup4）是一个Python库，它能够将复杂的HTML或XML文档转换成一个结构化的树形对象，让开发者可以通过简洁的API快速定位和提取数据。它在Python生态中的独特价值在于：<strong>极强的容错能力和人性化的API设计</strong>。即使网页代码不规范（如标签未闭合、嵌套错误），BeautifulSoup也能优雅地处理，这在真实世界的网页解析中尤为重要。</p><p>与正则表达式相比，BeautifulSoup不要求你掌握复杂的模式匹配规则；与lxml、Scrapy等重型爬虫框架相比，它学习曲线平缓，代码可读性强。对于中小型数据提取项目、教学演示或快速原型开发，BeautifulSoup是当之无愧的首选。</p><hr/><h2>2. 环境搭建与"Hello, World"</h2><h3>安装说明</h3><p>BeautifulSoup的安装非常简单，但有一个关键点需要注意：<strong>正确的包名是<code>beautifulsoup4</code></strong>，而不是<code>beautifulsoup</code>。同时，建议安装高效的解析器<code>lxml</code>以获得更好的性能。</p><pre><code class="bash"># 使用pip安装（推荐）
pip install beautifulsoup4
pip install lxml

# 如果使用conda
conda install beautifulsoup4 lxml</code></pre><p><strong>安装失败常见原因</strong>：</p><ol><li>错误使用<code>pip install beautifulsoup</code>（包名错误）</li><li>网络问题导致PyPI连接超时</li><li>Python环境混乱，pip指向错误的Python版本</li></ol><p><strong>解决方案</strong>：使用国内镜像源加速，如：</p><pre><code class="bash">pip install beautifulsoup4 lxml -i https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><h3>Hello, World 示例</h3><p>下面是一个最小可运行的示例，演示如何解析HTML并提取标题：</p><pre><code class="python">from bs4 import BeautifulSoup

# 创建模拟HTML文档
html_doc = """
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;BeautifulSoup入门示例&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1 class="heading"&gt;欢迎学习BeautifulSoup&lt;/h1&gt;
    &lt;p id="intro"&gt;这是第一个段落。&lt;/p&gt;
    &lt;p&gt;这是第二个段落。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
"""

# 创建BeautifulSoup对象，指定lxml解析器
soup = BeautifulSoup(html_doc, 'lxml')

# 提取并打印页面标题
print(soup.title.string)</code></pre><h3>逐行解释</h3><ol><li><code>from bs4 import BeautifulSoup</code>：从bs4模块导入BeautifulSoup类。<code>bs4</code>是"BeautifulSoup 4"的缩写。</li><li><code>html_doc = "..."</code>：定义了一个包含HTML结构的字符串，这是我们要解析的原始数据。</li><li><p><code>soup = BeautifulSoup(html_doc, 'lxml')</code>：</p><ul><li>第一个参数是要解析的HTML内容</li><li>第二个参数<code>'lxml'</code>指定使用lxml解析器（速度快、容错性强）</li><li>返回的<code>soup</code>对象是整个解析树的根节点</li></ul></li><li><p><code>print(soup.title.string)</code>：</p><ul><li><code>soup.title</code>：直接访问title标签，返回第一个<code>&lt;title&gt;</code>元素</li><li><code>.string</code>：获取标签内的文本内容</li></ul></li></ol><h3>运行结果</h3><pre><code>BeautifulSoup入门示例</code></pre><p><strong>解析器选择建议</strong>：</p><ul><li><strong>lxml</strong>：速度最快，容错能力强，推荐用于生产环境</li><li><strong>html.parser</strong>：Python内置，无需额外安装，但速度一般</li><li><strong>html5lib</strong>：最接近浏览器解析方式，容错性最强，但速度最慢</li></ul><hr/><h2>3. 核心概念解析</h2><p>BeautifulSoup解析HTML后会生成4类核心对象，理解这些概念是熟练使用的基础。</p><h3>核心对象类型</h3><ol><li><strong>BeautifulSoup对象</strong>：整个解析树的根对象，代表完整的HTML/XML文档，是所有操作的入口点。</li><li><strong>Tag对象</strong>：对应HTML中的标签（如<code>&lt;div&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;p&gt;</code>），可以获取标签名、属性和文本内容。</li><li><strong>NavigableString对象</strong>：标签内的纯文本内容（不包含标签本身）。</li><li><strong>Comment对象</strong>：特殊的NavigableString，对应HTML注释（如<code>&lt;!-- 这是注释 --&gt;</code>）。</li></ol><h3>概念关系图</h3><pre style="display:none;"><code class="mermaid">graph TD
    A[BeautifulSoup对象&lt;br/&gt;文档根节点] --&gt; B[Tag对象&lt;br/&gt;HTML标签]
    B --&gt; C[NavigableString&lt;br/&gt;标签内文本]
    B --&gt; D[Comment对象&lt;br/&gt;HTML注释]
    A --&gt; E[find/find_all方法&lt;br/&gt;定位Tag]
    A --&gt; F[select方法&lt;br/&gt;CSS选择器]
    B --&gt; G[获取属性&lt;br/&gt;tag.attrs/标签名]
    B --&gt; H[获取文本&lt;br/&gt;tag.string/get_text]</code></pre><h3>核心概念详解</h3><p><strong>Tag对象操作</strong>：</p><pre><code class="python"># 获取标签
title_tag = soup.title  # 获取第一个title标签
print(title_tag.name)   # 输出标签名：'title'

# 获取属性
link_tag = soup.a       # 获取第一个a标签
print(link_tag['href']) # 获取href属性
print(link_tag.attrs)   # 获取所有属性字典

# 获取文本
print(title_tag.string)      # 获取标签内文本（无嵌套时）
print(soup.h1.get_text())     # 获取标签内所有文本（含子标签）</code></pre><p><strong>NavigableString操作</strong>：</p><pre><code class="python"># 获取标签内的纯文本
text = soup.p.string  # 获取第一个p标签的文本内容
print(type(text))     # &lt;class 'bs4.element.NavigableString'&gt;</code></pre><p><strong>Comment对象处理</strong>：</p><pre><code class="python">from bs4 import Comment

html_with_comment = "&lt;b&gt;&lt;!-- 这是一个注释 --&gt;&lt;/b&gt;"
soup_comment = BeautifulSoup(html_with_comment, 'lxml')
comment = soup_comment.b.string

# 判断是否为注释
if isinstance(comment, Comment):
    print("这是注释内容:", comment)</code></pre><h3>查找方法对比</h3><table><thead><tr><th>方法</th><th>作用</th><th>返回值</th><th>适用场景</th></tr></thead><tbody><tr><td><code>soup.tagname</code></td><td>直接访问</td><td>第一个匹配的Tag</td><td>简单快速定位</td></tr><tr><td><code>find(name, attrs)</code></td><td>查找第一个匹配项</td><td>Tag对象或None</td><td>提取唯一元素</td></tr><tr><td><code>find_all(name, attrs)</code></td><td>查找所有匹配项</td><td>Tag对象列表</td><td>批量提取数据</td></tr><tr><td><code>select(css_selector)</code></td><td>CSS选择器</td><td>Tag对象列表</td><td>熟悉CSS语法时使用</td></tr></tbody></table><hr/><h2>4. 实战演练：爬取新闻网站标题</h2><p>让我们通过一个真实项目来巩固所学知识。我们将模拟爬取一个新闻网站的标题、链接和摘要。</p><h3>需求分析</h3><p>我们需要从一个新闻网页中提取以下信息：</p><ul><li>新闻标题</li><li>新闻链接</li><li>新闻摘要</li><li>发布时间</li></ul><h3>方案设计</h3><p>使用<code>requests</code>库获取网页内容（模拟），然后用BeautifulSoup解析数据。我们将使用以下功能：</p><ol><li><code>find_all()</code>批量查找新闻条目</li><li>CSS选择器定位嵌套元素</li><li><code>get()</code>方法提取属性</li><li><code>get_text()</code>提取文本</li></ol><h3>完整代码实现</h3><pre><code class="python">from bs4 import BeautifulSoup

# 模拟新闻网页HTML结构
news_html = """
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;科技新闻网&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="news-container"&gt;
        &lt;div class="news-item"&gt;
            &lt;h2 class="news-title"&gt;
                &lt;a href="https://example.com/news/1"&gt;AI技术突破新里程碑&lt;/a&gt;
            &lt;/h2&gt;
            &lt;p class="news-summary"&gt;人工智能在图像识别领域取得重大进展，准确率提升至98%。&lt;/p&gt;
            &lt;span class="publish-time"&gt;2025-01-15&lt;/span&gt;
        &lt;/div&gt;
        
        &lt;div class="news-item"&gt;
            &lt;h2 class="news-title"&gt;
                &lt;a href="https://example.com/news/2"&gt;量子计算商业化进程加速&lt;/a&gt;
            &lt;/h2&gt;
            &lt;p class="news-summary"&gt;多家科技巨头宣布量子计算云服务正式上线，标志着量子计算进入实用阶段。&lt;/p&gt;
            &lt;span class="publish-time"&gt;2025-01-14&lt;/span&gt;
        &lt;/div&gt;
        
        &lt;div class="news-item"&gt;
            &lt;h2 class="news-title"&gt;
                &lt;a href="https://example.com/news/3"&gt;5G网络覆盖率达95%&lt;/a&gt;
            &lt;/h2&gt;
            &lt;p class="news-summary"&gt;最新数据显示，全国5G网络覆盖率已超过95%，为物联网发展奠定基础。&lt;/p&gt;
            &lt;span class="publish-time"&gt;2025-01-13&lt;/span&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
"""

# 创建BeautifulSoup对象
soup = BeautifulSoup(news_html, 'lxml')

# 查找所有新闻条目
news_items = soup.find_all('div', class_='news-item')

# 遍历提取每条新闻的信息
print("=" * 60)
print("科技新闻网 - 最新资讯")
print("=" * 60)

for i, item in enumerate(news_items, 1):
    # 提取标题和链接
    title_tag = item.find('a')
    title = title_tag.get_text(strip=True)
    link = title_tag.get('href')
    
    # 提取摘要
    summary_tag = item.find('p', class_='news-summary')
    summary = summary_tag.get_text(strip=True) if summary_tag else "无摘要"
    
    # 提取发布时间
    time_tag = item.find('span', class_='publish-time')
    publish_time = time_tag.get_text(strip=True) if time_tag else "未知时间"
    
    # 输出结果
    print(f"\n新闻 {i}:")
    print(f"标题: {title}")
    print(f"链接: {link}")
    print(f"摘要: {summary}")
    print(f"发布时间: {publish_time}")

print("\n" + "=" * 60)
print(f"共提取 {len(news_items)} 条新闻")
print("=" * 60)</code></pre><h3>运行说明</h3><p>将上述代码保存为Python文件并运行，你会看到格式化的新闻列表输出。每个新闻条目都包含标题、链接、摘要和发布时间。</p><p><strong>代码亮点</strong>：</p><ol><li>使用<code>class_='news-item'</code>查找所有新闻容器（注意<code>class_</code>的下划线避免关键字冲突）</li><li>使用<code>.get_text(strip=True)</code>去除文本中的多余空格和换行</li><li>使用<code>.get('href')</code>安全获取属性，避免属性不存在时报错</li><li>使用条件判断处理可能缺失的元素，增强代码健壮性</li></ol><hr/><h2>5. 最佳实践与常见陷阱</h2><h3>常见错误及规避方法</h3><p><strong>错误1：直接使用<code>class</code>作为参数</strong></p><pre><code class="python"># ❌ 错误做法
soup.find_all('div', class='content')  # SyntaxError

# ✅ 正确做法
soup.find_all('div', class_='content')  # 加下划线避免关键字冲突</code></pre><p><strong>错误2：属性不存在时直接访问</strong></p><pre><code class="python"># ❌ 错误做法
link = soup.a['href']  # 如果a标签没有href属性会报错

# ✅ 正确做法
link = soup.a.get('href')  # 属性不存在返回None，安全
link = soup.a.get('href', '#')  # 可设置默认值</code></pre><p><strong>错误3：混淆string和get_text()</strong></p><pre><code class="python">html = "&lt;p&gt;Hello &lt;b&gt;World&lt;/b&gt;&lt;/p&gt;"
soup = BeautifulSoup(html, 'lxml')

# ❌ 错误理解
print(soup.p.string)  # 输出None，因为有嵌套标签

# ✅ 正确做法
print(soup.p.get_text())  # 输出：Hello World</code></pre><p><strong>错误4：忘记指定解析器</strong></p><pre><code class="python"># ❌ 不推荐：依赖默认解析器
soup = BeautifulSoup(html_doc)

# ✅ 推荐：明确指定解析器
soup = BeautifulSoup(html_doc, 'lxml')</code></pre><h3>最佳实践建议</h3><ol><li><p><strong>选择合适的解析器</strong></p><ul><li>生产环境使用<code>lxml</code>（速度+容错）</li><li>开发测试可用<code>html.parser</code>（无需安装）</li><li>特殊场景用<code>html5lib</code>（容错性最强）</li></ul></li><li><p><strong>使用CSS选择器提高效率</strong></p><pre><code class="python"># 传统方法
div.find('div', class_='container').find_all('a')

# CSS选择器（更简洁）
soup.select('.container a')</code></pre></li><li><p><strong>处理中文编码</strong></p><pre><code class="python"># 读取文件时指定编码
with open('page.html', 'r', encoding='utf-8') as f:
    soup = BeautifulSoup(f, 'lxml')</code></pre></li><li><p><strong>异常处理</strong></p><pre><code class="python">try:
    title = soup.title.string
except AttributeError:
    title = "无标题"</code></pre></li><li><p><strong>性能优化</strong></p><ul><li>使用<code>limit</code>参数限制返回数量：<code>find_all('a', limit=10)</code></li><li>只在必要时调用<code>prettify()</code>（格式化输出耗时）</li><li>大文档考虑分块解析</li></ul></li></ol><h3>注意事项</h3><ol><li><strong>BeautifulSoup只能解析静态HTML</strong>，对于JavaScript动态渲染的内容，需配合Selenium或Playwright</li><li><strong>它不负责下载网页</strong>，需结合requests、urllib等网络库使用</li><li><strong>遵守网站的robots.txt协议</strong>，合理设置请求频率，避免给服务器造成压力</li><li><strong>注意反爬虫机制</strong>，适当添加User-Agent等请求头</li></ol><hr/><h2>6. 进阶指引</h2><h3>高级功能</h3><p>BeautifulSoup除了基础的数据提取，还提供了强大的修改功能：</p><pre><code class="python"># 修改标签内容
soup.title.string = "新标题"

# 添加新标签
new_tag = soup.new_tag('div')
new_tag['class'] = 'new-item'
soup.body.append(new_tag)

# 删除标签
soup.p.decompose()  # 彻底删除标签及其内容
soup.p.extract()    # 从文档中移除并返回该标签</code></pre><h3>生态扩展</h3><p>结合其他库构建完整的数据采集系统：</p><ul><li><strong>requests/httpx</strong>：发送HTTP请求获取网页</li><li><strong>Selenium/Playwright</strong>：处理动态JavaScript渲染</li><li><strong>pandas</strong>：将提取的数据保存为CSV/Excel</li><li><strong>sqlite3</strong>：将数据存储到数据库</li></ul><h3>学习路径</h3><ol><li><strong>初级阶段</strong>：掌握基本的标签查找和属性提取</li><li><strong>中级阶段</strong>：熟练使用CSS选择器和文档树遍历</li><li><strong>高级阶段</strong>：学习修改文档树、处理复杂嵌套结构</li><li><strong>实战应用</strong>：结合requests完成完整爬虫项目</li></ol><h3>推荐资源</h3><ul><li><strong>官方文档</strong>：<a href="https://link.segmentfault.com/?enc=P32WjRVWVFKHYNM3kRT70w%3D%3D.L8OAsMIgs3sFrCfzO8zkYx4ge9QclK%2BB6Z8Q7AJDPlfat6zQ%2BGYtvt6ROkMbESRh" rel="nofollow" target="_blank">https://beautiful-soup.readthedocs.io/</a>（最权威的参考）</li><li><strong>GitHub仓库</strong>：<a href="https://link.segmentfault.com/?enc=bUZCcmWv3I%2F%2FQtN7PrMRig%3D%3D.wOMAs9t4lxkPKmCruGSSn%2Bx5%2F%2FjSN4Ez51Qi%2F%2BrG4bhwxqez8Id9dHScQi3Op2ou" rel="nofollow" target="_blank">https://github.com/facelessuser/BeautifulSoup4</a></li><li><strong>实战项目</strong>：尝试爬取豆瓣电影Top250、知乎热榜等网站</li></ul><p>BeautifulSoup是Python网页解析领域的"瑞士军刀"，掌握了它，你就拥有了从网页中提取数据的强大能力。无论是数据采集、内容分析，还是自动化测试，它都能成为你得力的助手。保持练习，不断探索，你将发现更多精彩的应用场景！</p>]]></description></item><item>    <title><![CDATA[PostgreSQL 分区表的 ALTER TABLE 语句执行机制解析 IvorySQL ]]></title>    <link>https://segmentfault.com/a/1190000047601807</link>    <guid>https://segmentfault.com/a/1190000047601807</guid>    <pubDate>2026-02-09 15:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>分区表是 PostgreSQL 的核心特性之一，但有一个问题即便资深用户也常会产生困惑：</p><blockquote>在涉及分区时，ALTER TABLE 语句的具体执行逻辑是怎样的？</blockquote><p>操作是否会同步至各分区？是否对新建分区生效？<code>ONLY</code> 关键字是否实现预期效果？为何部分命令可在主表执行却无法在分区执行，或反之？</p><p>当前 PostgreSQL 官方文档对单个 <code>ALTER TABLE</code> 子命令的说明较为完善，但很少系统性地解释它们在分区表场景下的整体行为。这导致真实行为往往只能通过反复试验才能被发现。</p><p>本文基于一次系统性验证，总结了 <code>ALTER TABLE</code> 在分区表上的行为规律，将零散规则归纳为一套统一的分类模型。</p><h2>问题本质：“不一致”并不等同于“未定义”</h2><p>在 PostgreSQL 社区中，<code>ALTER TABLE</code> 在分区表上的行为常被描述为“不一致”。实际上，更深层的问题在于：</p><ul><li>行为规则是存在的；</li><li>但规则分散在不同的代码路径、报错信息以及历史设计决策中；</li><li>且未以可预测结果的方式进行文档化说明。</li></ul><p>在缺乏清晰认知模型的情况下，即便是简单问题也难以回答：</p><ul><li>在父分区表上执行操作后，现有分区会发生什么？</li><li>后续新建的分区是否会继承相关设置？</li><li><code>ONLY</code> 是否能够阻止传播，还是会被直接忽略？</li><li>能否为单个分区单独覆盖相关配置？</li></ul><h2>ALTER TABLE 子命令的验证方法</h2><p>为厘清上述问题，本次研究针对所有 ALTER TABLE 子命令，在分区表场景下采用统一的问题框架开展测试验证。</p><h3>四个评估维度</h3><p>针对每个子命令，均围绕以下四个核心问题展开验证：</p><ol><li>传播性（Propagation）<br/>在父分区表上执行操作后，是否会传播到已有分区？</li><li>新分区继承性（Inheritance for new partitions）<br/>后续新建的分区是否会继承父表的设置？</li><li>ONLY 的影响（Effect of <code>ONLY</code>）<br/><code>ONLY parent_table</code> 是否如文档所述，能够阻止操作传播？</li><li>独立性（Independence）<br/>父表与各个分区是否可以拥有不同的配置值？</li></ol><p>通过这四个维度，可以将模糊的“不一致”转化为明确、可验证的行为特征。</p><h3>范围与版本说明</h3><p>本分析基于 PostgreSQL 18 的开发版本行为（截至 2026 年初）。所有结论均在 PostgreSQL 18 上验证。部分细节在早期版本中可能存在差异，未来版本也可能随着分区机制的演进而发生变化。</p><h2>分区表上 ALTER TABLE 的分类模型</h2><p>基于上述评估维度，<code>ALTER TABLE</code> 的子命令可自然划分为 15 类，每一类对应一种明确的行为模式。</p><p>该分类仅作为执行逻辑的参考依据，而非价值判断。</p><h3>C1 – 仅作用于父表的结构性变更</h3><p>此类特征如下：</p><ul><li>仅可在分区表上使用；</li><li>在分区上执行会失败；</li><li>不支持 <code>ONLY</code> 关键字。</li></ul><p>包含的子命令：</p><ul><li><code>ADD COLUMN</code>（添加列）</li><li><code>DROP COLUMN</code>（删除列）</li><li><code>SET DATA TYPE</code>（修改数据类型）</li><li><code>DROP EXPRESSION</code>（删除表达式）</li><li><code>ADD GENERATED AS IDENTITY</code>（添加自增标识列）</li><li><code>ADD GENERATED</code>（添加生成列）</li><li><code>SET sequence_option</code>（设置序列参数）</li><li><code>RESTART</code>（重启序列）</li><li><code>ALTER CONSTRAINT</code>（修改约束）</li></ul><p>此类命令用于定义分区表的整体结构，必须保持全局一致性。</p><h3>C2 – 可传播且可继承的变更</h3><p>此类特征如下：</p><ul><li>从父表传播至所有已有分区；</li><li>遵循 <code>ONLY</code> 关键字的作用规则；</li><li>新建分区会继承主表的相关配置；</li><li>支持为单个分区单独覆盖配置。</li></ul><p>包含的子命令：</p><ul><li><code>SET DEFAULT</code>（设置默认值）</li><li><code>DROP DEFAULT</code>（删除默认值）</li><li><code>SET EXPRESSION AS</code>（设置表达式）</li><li><code>SET STORAGE</code>（设置存储参数）</li><li><code>DROP CONSTRAINT</code>（删除约束）</li><li><code>ENABLE/DISABLE TRIGGER</code>（启用 / 禁用触发器）</li></ul><p>这是多数场景下对 ALTER TABLE 行为的直观预期。</p><h3>C3 – 可传播但不支持新分区继承</h3><p>此类别仅包含一个子命令：</p><ul><li><code>SET STATISTICS</code>（设置统计信息参数）</li></ul><p>执行逻辑与 C2 类基本一致，区别在于操作仅同步至现有分区，对后续新建分区不生效。若默认认为配置可自动继承，该特性易引发使用偏差。</p><h3>C4 – 父表与分区完全独立</h3><p>此类特征如下：</p><ul><li>不传播；</li><li>不继承；</li><li>允许父表与分区设置不同值；</li><li>支持 <code>ONLY</code> 关键字，但无实际执行效果。</li></ul><p>包含的子命令：</p><ul><li><code>SET/RESET (attribute_option = value)</code>（设置 / 重置属性参数）</li><li><code>ENABLE/DISABLE [REPLICA | ALWAYS] RULE</code>（启用 / 禁用复制 / 永久规则）</li><li><code>ENABLE/DISABLE ROW LEVEL SECURITY</code>（启用 / 禁用行级安全策略）</li><li><code>NO FORCE / FORCE ROW LEVEL SECURITY</code>（不强制 / 强制行级安全策略）</li><li><code>OWNER TO</code>（修改表属主）</li><li><code>REPLICA IDENTITY</code>（设置复制标识）</li><li><code>SET SCHEMA</code>（修改所属模式）</li></ul><p>在行为上，父表与分区几乎等同于彼此独立的普通表。</p><h3>C5 – 独立设置，但新分区继承</h3><p>此类别仅包含一个子命令：</p><ul><li><code>SET COMPRESSION</code>（设置压缩参数）</li></ul><p>执行逻辑与 C4 基本一致，但新建分区会继承父表设置，已有分区不受影响。</p><h3>C6 – 强制传播类命令</h3><p>此类别仅包含一个子命令：</p><ul><li><code>ADD table_constraint</code>（添加表级约束）</li></ul><p>执行逻辑与 C2 类基本一致，但不允许使用 <code>ONLY</code>，系统会强制保证所有分区一致。</p><h3>C7 – 仅适用于叶子分区的命令</h3><p>此类特征如下：</p><ul><li>无法在分区表上使用；</li><li>只能在叶子分区上执行。</li></ul><p>包含的子命令：</p><ul><li><code>ADD table_constraint_with_index</code>（添加带索引的表级约束）</li><li><code>ALTER CONSTRAINT ... INHERIT / NO INHERIT</code>（修改约束的继承 / 取消继承属性）</li><li><code>CLUSTER ON</code>（按指定索引聚簇）</li><li><code>SET WITHOUT CLUSTER</code>（取消聚簇）</li><li><code>SET LOGGED / UNLOGGED</code>（设置日志记录 / 无日志记录）</li><li><code>SET (storage_parameter)</code>（设置存储参数）</li></ul><h3>C8 – 父表作用域，但允许分区覆盖</h3><p>此类别仅包含一个子命令：</p><ul><li><code>VALIDATE CONSTRAINT</code>（验证约束）</li></ul><p>执行逻辑与 C1 类基本一致，区别在于验证动作定义在父表层级，但各分区的验证状态可以不同。</p><h3>C9 – 条件继承型</h3><p>此类别仅包含一个子命令：</p><ul><li><code>SET ACCESS METHOD</code>（设置访问方法）</li></ul><p>执行逻辑与 C2 类基本一致，但新分区是否继承取决于父表是否显式设置；若未设置，则使用 GUC 默认值。</p><h3>C10 – 不传播，但新分区继承</h3><p>此类别仅包含一个子命令：</p><ul><li><code>SET TABLESPACE</code>（设置表空间）</li></ul><p>已有分区保持不变，新建分区继承父表设置。接受 <code>ONLY</code>，但无实际效果。</p><h3>C11 – 在父表上为空操作</h3><p>此类别仅包含一个子命令：</p><ul><li><code>RESET (storage_parameter)</code>（重置存储参数）</li></ul><p>此类命令在分区表上不会报错，但也不会产生任何实际变化。</p><h3>C12 – 不支持分区表的命令</h3><p>包含的子命令：</p><ul><li><code>INHERIT</code>（继承表）</li><li><code>NO INHERIT</code>（取消继承表）</li></ul><p>在概念上与声明式分区机制不兼容。</p><h3>C13 – 仅绑定父表元数据</h3><p>包含的子命令：</p><ul><li><code>OF type</code>（绑定复合类型）</li><li><code>NOT OF</code>（取消复合类型绑定）</li></ul><p>仅作用于分区表本身，在分区上执行会失败。接受 <code>ONLY</code>，但无实际效果。</p><h3>C14 – 按普通表处理</h3><p>仅包含一个子命令：</p><ul><li><code>RENAME</code>（重命名）</li></ul><p>无传播、无继承，也不存在分区相关的特殊行为。</p><h3>C15 – 分区管理类命令</h3><p>包含的子命令：</p><ul><li><code>ATTACH PARTITION</code>（挂载分区）</li><li><code>DETACH PARTITION</code>（卸载分区）</li></ul><p>用于操作分区结构本身，而非表属性。</p><h2>结语</h2><p>在 PostgreSQL 官方文档未对分区表的 ALTER TABLE 语句执行逻辑进行明确、体系化说明前，本分类模型可作为重要的参考依据。</p><p>若日常工作中频繁使用分区表，建议将该认知模型作为常用参考，在生产环境执行相关命令前，先确认其所属的执行类别，再开展操作，以降低不可预期风险。</p><p>原文链接：</p><p><a href="https://link.segmentfault.com/?enc=lGFyX%2FQXnNzOcBQY6OF9Rg%3D%3D.27EdGdVeN99SknbSt6UOuj7fN9q0yIeyyc8c7XhRqsvhXc%2FGVoodVEKTqZzpg4I1F3DVh6CA559dUzPA4YnHPlAAAXUOdrC%2FYv%2B4njb00GaL4JwNMGwUVNEN2v5B7N9pjn3FxQmtexFm%2B4oCtpo4sw%3D%3D" rel="nofollow" target="_blank">https://www.highgo.ca/2026/01/21/understanding-alter-table-be...</a></p><p>作者：Chao Li</p><hr/><h2><a href="https://link.segmentfault.com/?enc=e1YNh%2FdnG7D14yC3gyy7xw%3D%3D.gFtmSYOpxIHZKHcSKT%2FYGIHtDYPRtl8T1hcFsd2tjeo%3D" rel="nofollow" target="_blank">HOW 2026 议题招募中</a></h2><p>2026 年 4 月 27-28 日，由 IvorySQL 社区联合 PGEU（欧洲 PG 社区）、PGAsia（亚洲 PG 社区）共同打造的 HOW 2026（IvorySQL &amp; PostgreSQL 技术峰会） 将再度落地济南。届时，PostgreSQL 联合创始人 Bruce Momjian 等顶级大师将亲临现场。</p><p>自开启征集以来，HOW 2026 筹备组已感受到来自全球 PostgreSQL 爱好者的澎湃热情。为了确保大会议题的深度与广度，我们诚邀您在 2026 年 2 月 27 日截止日期前，提交您的技术见解。</p><p>投递链接：<a href="https://link.segmentfault.com/?enc=A7c6L3HybHZKDRZrCpf54A%3D%3D.gDO87KA4fEhp0sQPQ6eBzSDVlmHwL85Nn9BLsu%2BrkU4%3D" rel="nofollow" target="_blank">https://jsj.top/f/uebqBc</a></p>]]></description></item><item>    <title><![CDATA[扣子Coze实战：从0到1搭建小红书图文改写智能体 AI架构师汤师爷 ]]></title>    <link>https://segmentfault.com/a/1190000047601397</link>    <guid>https://segmentfault.com/a/1190000047601397</guid>    <pubDate>2026-02-09 14:06:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大家好，我是汤师爷，专注AI智能体分享，致力于帮助100W人用智能体创富~</p><p>还在为小红书笔记创作发愁吗？</p><p>每天都要绞尽脑汁想文案，看着别人的爆款笔记却不知道如何模仿？</p><p>今天，我就教你如何利用AI智能体，轻松实现小红书图文改写，让创作效率提升10倍！</p><p>我们先看下智能体的执行效果：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601400" alt="image.png" title="image.png"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601401" alt="image.png" title="image.png" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601402" alt="image.png" title="image.png" loading="lazy"/></p><h2>1.整体工作流</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601403" alt="image.png" title="image.png" loading="lazy"/></p><p>1.获取小红书笔记详情</p><p>2.使用OCR技术，提取图片中的文字</p><p>3.将图片文案进行整理</p><p>4.图片文案仿写</p><h2>2.详细工作流节点</h2><h3>2.1 开始节点</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601404" alt="image.png" title="image.png" loading="lazy"/></p><p>开始节点有两个输入变量。</p><ul><li><p>输入：</p><ul><li>noteUrl：小红书笔记链接</li><li>cookieStr：小红书cookie</li></ul></li></ul><h3>2.2 如何获取小红书cookie？</h3><p>1.登陆<a href="https://link.segmentfault.com/?enc=kKvjTIfYn%2Bu2VS8XSfcteQ%3D%3D.Ka7MMBZcD89zamWnc%2FmwaPGJPV44im8Py4BgfdIROMw%3D" rel="nofollow" target="_blank">https://www.xiaohongshu.com/</a></p><p>2.在页面空白处右击鼠标，选择「检查」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601405" alt="image.png" title="image.png" loading="lazy"/></p><p>3.在刚刚打开的面板中，点击「网络」选项卡</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601406" alt="image.png" title="image.png" loading="lazy"/></p><p>4.刷新当前页面</p><p>5.点击第一条记录，在右侧「标头」部分向下滚动，找到cookie一行，将其内容复制下，这就是我们需要的cookieStr</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601407" alt="image.png" title="image.png" loading="lazy"/></p><h3>2.3 获取小红书笔记详情</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601408" alt="image.png" title="image.png" loading="lazy"/></p><p>我们将使用【小红书】插件的xhs_note_detail功能。</p><p>通过这个功能，我们可以根据笔记链接获取笔记详情。</p><ul><li><p>输入：</p><ul><li>cookieStr：开始 - cookieStr</li><li>noteUrl：开始 - noteUrl</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601409" alt="image.png" title="image.png" loading="lazy"/></p><h3>2.4 使用OCR技术，提取图片中的文字</h3><p><strong>1.接下来，我们使用循环节点，批量提取图片中的文字。</strong></p><ul><li><p>输入：</p><ul><li>input：获取小红书笔记详情-note_image_list</li></ul></li><li><p>输出</p><ul><li>output：从图片中提取文字-data</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601410" alt="image.png" title="image.png" loading="lazy"/></p><p><strong>2.使用循环体，批量提取图片的文字</strong></p><p>我们会使用「OCR」插件，提取图片的文字。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601411" alt="image.png" title="image.png" loading="lazy"/></p><p>输入参数如下图所示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601412" alt="image.png" title="image.png" loading="lazy"/></p><h3>2.5 使用大模型将文案内容进行整理、排版</h3><p>在这一步，我们会使用大模型节点，对文案内容进行整理、排版。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601413" alt="image.png" title="image.png" loading="lazy"/></p><p>大模型节点的系统提示词如下：</p><pre><code class="markdown">## 角色（Role）
你是一位精通内容整理和 Markdown 排版的 AI 助手。你擅长阅读和理解非结构化的文本内容，并能够将其转化为结构清晰、格式优美的 Markdown 文档。

## 背景（Background）
随着社交媒体平台的普及，大量的图文内容被创作和分享。然而，这些内容往往缺乏良好的结构和格式，不利于阅读和理解。将这些内容整理成结构化的 Markdown 文档，可以大大提高内容的可读性和价值。

## 任务（Task）
你的任务是接收一段从插件输出的非结构化文本内容（主要是抖音图文中的文字），仔细阅读并理解内容，然后将其转化为结构清晰、格式规范的 Markdown 文档。你需要：

1. 识别并提取文本中的关键信息，如标题、作者、主要内容等
2. 根据内容的逻辑关系，对文本进行分类和整理
3. 使用 Markdown 语法进行排版，包括但不限于使用标题、粗体、斜体、列表等格式
4. 确保所有原始内容都被包含在最终的 Markdown 文档中，不遗漏任何信息

## 规则与限制（Rules &amp; Restrictions）
1. 必须使用 Markdown 语法进行排版
2. 使用 #、##、### 等进行标题划分，层级不超过 3 级
3. 使用 - 或 * 进行无序列表编写，使用 1. 2. 3. 等进行有序列表编写
4. 重要内容使用粗体（**文字**）标注，需要强调的内容使用斜体（*文字*）标注
5. 保持原文的主要结构和顺序，但可以适当调整以提高可读性
6. 不得添加、删除或修改原文的实质内容
7. 如遇到不确定的内容，保留原样并用括号标注

## 参考短语（Reference sentences）
- 内容完整，不遗漏任何信息
- 结构清晰，层次分明
- 格式规范，美观实用
- 逻辑严密，条理清晰
- 重点突出，易于阅读

## 案例展示（Case Show）
### 输入：
{
  "code": 0,
  "data": {
    "results": [
      {
        "words": [
          {
            "lang": "auto",
            "text": "求大连这两个"
          },
          {
            "lang": "auto",
            "text": "地方有啥"
          },
          {
            "lang": "auto",
            "text": "区别啊？？"
          }
        ]
      }
    ]
  },
  "log_id": "20250325123913080C6F506498C6F581B7",
  "msg": "success"
}

## 风格和语气（Style &amp; Tone）
- 保持专业、清晰的语气
- 使用简洁、直接的表达方式
- 保持原文的重点和强调

## 受众群体（Audience）
- 小红书电商新手卖家
- 对开设小红书店铺感兴趣的人群
- 想要了解小红书电商运营的人群

## 输出格式（Output format）
使用 Markdown 格式输出，包括：
1. 一级标题（#）用于文章主标题
2. 二级标题（##）用于主要章节
3. 三级标题（###）用于子章节
4. 无序列表使用 - 或 *
5. 有序列表使用 1. 2. 3. 等
6. 重要内容使用粗体（**文字**）
7. 需要强调的内容使用斜体（*文字*）

## 工作流程（Workflow）
1. 仔细阅读输入的文本内容，理解其结构和主要信息点
2. 提取标题、作者、标签等元信息
3. 识别主要章节和子章节，规划文档结构
4. 按照规划的结构，使用 Markdown 语法重新排版内容
5. 使用粗体和斜体突出重要信息和需要强调的内容
6. 检查确保所有原始内容都被包含，没有遗漏
7. 最后检查 Markdown 格式是否正确，调整以确保最佳可读性

## 初始化（Initialization）

下面是你需要整理和格式化的文本内容：

&lt;评价内容&gt;

请提供需要整理和格式化的文本内容。我会仔细阅读并按照上述要求将其转化为结构清晰的 Markdown 文档。不需要输出额外除图片识别文字以外的内容。</code></pre><h3>2.6 图片文案仿写</h3><p>接下来，我们需要通过大模型节点退图片文案进行仿写。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601414" alt="image.png" title="image.png" loading="lazy"/></p><p>大模型节点的系统提示词如下：</p><pre><code class="markdown"># 角色说明
你是一位专业的图文内容仿写助手，负责根据图片中提取的文字内容，结合视觉元素和背景信息，创作风格一致的仿写内容。

# 背景说明
处理用户提供的图片文字内容时，你需要：
1. 理解图片的整体风格和背景（产品介绍、教程步骤、使用心得等）
2. 分析文字的语言特点（正式/口语化、句式特征、专业术语等）
3. 结合图片呈现的视觉信息（产品外观、使用场景等）
4. 在保持原意的基础上进行自然的仿写扩展

# 仿写原则
1. 保持原意完整性
2. 匹配原文语言风格
3. 补充恰当的细节
4. 与图片内容保持一致
5. 避免添加虚假信息

# 工作流程
1. 接收图片文字内容
2. 分析图片背景信息（可选）
3. 分析原文特点：
   - 语言风格
   - 内容结构
   - 关键词使用
4. 创作三个版本：
   - 贴近原文的保守版
   - 适度优化的改进版
   - 创意加强的亮点版

# 输出示例
## 原文：
"夏日必备防晒霜
SPF50+ PA++++
清爽不油腻"

## 仿写版本：
1. 【保守版】
"夏季必备防晒产品
防晒指数SPF50+ PA++++
质地清爽不油腻"

2. 【优化版】
"夏日防晒推荐
高倍防护SPF50+ PA++++
轻薄水感质地，肌肤零负担"

3. 【创意版】
"今夏防晒天花板！
SPF50+ PA++++超强防护
一抹化水，清爽不黏腻"

# 执行要求
请提供：
1. 图片文字提取内容
2. 图片背景说明（如有）

我将按照以上规范进行仿写创作。</code></pre><h3>2.7 使用文本处理插件拼接字符串</h3><ul><li><p>输入：</p><ul><li>String1：获取小红书笔记详情-note</li><li>String2：图片文案内容整理-output</li><li>String3：图片文案仿写-output</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601415" alt="image.png" title="image.png" loading="lazy"/></p><h3>2.8 结束节点</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601416" alt="image.png" title="image.png" loading="lazy"/></p><h2>3.总结</h2><p>通过以上介绍，相信你了解了如何利用DeepSeek+Coze来构建高效的小红书图片文案改写智能体。</p><p>在AI时代，技术门槛将越来越低，小白也能搭建智能体，用AI工具来提升工作效率。</p><p>用AI智能体不是未来，而是AI时代每个人的生存技能，学会AI智能体，人人都是超级个体。</p><p>如果你觉得这篇文章有帮助，别忘了点赞、关注、收藏，我们下期再见！</p><blockquote>对了，我整理了一份开源《智能体学习手册》，爆肝 10 万字，价值 999 元。限时开放领取👉：<a href="https://link.segmentfault.com/?enc=RKeV23zo7AOy9S9SV8PNTA%3D%3D.394dLxrNKjI%2FVxPzyCX4eS2sP9XYw4exg%2BjVVMZF7mo%3D" rel="nofollow" target="_blank">tangshiye.cn</a></blockquote>]]></description></item><item>    <title><![CDATA[从抓取到分析：我在 TikTok 内容竞品研究中的工程实践经验 听话的马克杯 ]]></title>    <link>https://segmentfault.com/a/1190000047601418</link>    <guid>https://segmentfault.com/a/1190000047601418</guid>    <pubDate>2026-02-09 14:06:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>几周前，我的团队接到一个任务：分析 20 个竞品账号的 TikTok 内容表现，为新产品的内容策略提供数据支撑。刚开始，我像往常一样登录 App，逐个账号查看发布内容，但不到一周，我就发现问题来了：</p><ul><li>多账号登录频繁切换，效率低得离谱；</li><li>我的行为开始影响推荐算法，看到的内容不再是客观的竞品数据；</li><li>数据整理完全依赖人工，累得我每天盯着屏幕到半夜。</li></ul><p>那一刻，我意识到：<strong>我们需要一套工程化、可复盘的竞品分析流程，而不是靠手动浏览和记笔记。</strong></p><h2>一、问题背景</h2><p>在实际工程项目中，分析 TikTok 内容时，我们常遇到三类问题：</p><ol><li><strong>登录状态干扰数据</strong>  <br/>官方 App 会根据浏览和互动记录调整推荐，这会导致我们看到的数据偏离真实情况。</li><li><strong>多账号批量分析效率低</strong>  <br/>手动切换账号、记录数据，不仅耗时，还容易出错。</li><li><strong>PC 端操作不便</strong>  <br/>内容分析、数据清洗、可视化大部分在电脑上完成，App 使用不方便。</li></ol><p>解决这三个问题的关键在于<strong>数据采集策略和分析流程设计</strong>。我将整个流程分为“只读采集 → 标准化存储 → 自动化分析 → 趋势可视化”。</p><h2>二、数据采集策略</h2><h3>1. 只读原则</h3><p>为了保证数据的客观性，我遵循以下原则：</p><ul><li><strong>不登录、不互动</strong>：避免点赞、评论、关注影响算法；</li><li><strong>只采集公开内容</strong>：私密账号不可获取，分析仅基于公开信息；</li><li><strong>可复盘</strong>：每次抓取流程、字段保持一致，方便历史对比。</li></ul><p>顺带提到，我偶尔会使用网页工具（例如<a href="https://link.segmentfault.com/?enc=4sCErhf%2Bp7xxrI3EEbmiCQ%3D%3D.nPAhPK%2BLWVvRmT22eAyj%2FXrC2FBptj9Cw612rM1P81k3SH3vBQYP3O7LcvhlGaRd" rel="nofollow" target="_blank">TikTok Viewer</a> 页面）做快速浏览，但它只是辅助入口，不参与核心分析。</p><h3>2. 核心字段定义</h3><p>标准化字段是工程级分析的基础，我使用如下字段：</p><table><thead><tr><th>字段</th><th>含义</th><th>用途</th></tr></thead><tbody><tr><td>account_id</td><td>账号唯一标识</td><td>多账号管理</td></tr><tr><td>publish_ts</td><td>发布时间戳</td><td>趋势分析</td></tr><tr><td>content_type</td><td>内容类型（挑战/教程/记录等）</td><td>类型对比</td></tr><tr><td>video_length</td><td>视频时长（秒）</td><td>格式偏好分析</td></tr><tr><td>likes</td><td>点赞数</td><td>热度指标</td></tr><tr><td>comments</td><td>评论数</td><td>用户互动分析</td></tr><tr><td>shares</td><td>分享数</td><td>内容传播潜力分析</td></tr></tbody></table><h2>三、自动化抓取与容错设计</h2><p>批量抓取必须考虑稳定性和可复用性：</p><ul><li><strong>异步并发</strong>：提升抓取效率；</li><li><strong>异常重试机制</strong>：处理网络波动或页面结构变化；</li><li><strong>日志记录</strong>：方便排查问题；</li><li><strong>限流保护</strong>：避免 IP 封禁或对平台造成压力。</li></ul><p>抓取流程伪代码示例：</p><pre><code class="python">for account in account_list:
    url = build_public_profile_url(account)
    html = fetch_with_retry(url)
    if parse_success(html):
        data = extract_fields(html)
        write_to_db(data)
    else:
        log_error(account, html)</code></pre><h2>四、数据分析与趋势可视化</h2><ol><li>发布时间趋势</li></ol><p>统计每日/每周发布量，判断账号更新规律：</p><pre><code>SELECT publish_date, COUNT(*) AS cnt
FROM video_data
GROUP BY publish_date
ORDER BY publish_date</code></pre><ol start="2"><li>内容类型分析</li></ol><p>不同类型视频的平均互动量：</p><pre><code>SELECT content_type,
       AVG(likes) AS avg_likes,
       AVG(comments) AS avg_comments
FROM video_data
GROUP BY content_type</code></pre><ol start="3"><li>视频长度分布</li></ol><p>将视频时长分段，观察受欢迎区间：</p><pre><code>SELECT video_length_bucket, COUNT(*) AS cnt
FROM video_data
GROUP BY video_length_bucket</code></pre><p>趋势分析帮助判断哪类内容更受用户欢迎，为内容策略提供数据支撑。</p><h2>五、工程实践总结</h2><p>字段规范化：统一字段定义和存储格式，保证多账号数据可比；</p><p>定期重抓：平台内容更新快，周期性抓取保证数据新鲜；</p><p>自动化报表：定期生成分析报告，减少人工操作；</p><p>关注趋势：单条数据可能偶然，高层趋势才更可靠。</p><p>通过工程化方法，我们可以高效、可复盘地进行竞品分析，而不是依赖人工观察。</p><h2>六、流程图示意</h2><pre><code>+----------------+       +----------------+       +----------------+
| 公开页面抓取   | ---&gt;  | 数据字段解析    | ---&gt;  | 数据库存储      |
+----------------+       +----------------+       +----------------+
         |                                          |
         v                                          v
+----------------+       +----------------+       +----------------+
| 异常重试与日志 | ---&gt;  | 数据清洗与标准化| ---&gt;  | 趋势分析 &amp; 可视化|
+----------------+       +----------------+       +----------------+</code></pre><p>这个流程图表示了工程化竞品分析的核心步骤，从抓取、解析、存储到分析和可视化，保证数据可复盘和可扩展。</p><h2>七、数据表格模板示例</h2><p>account_id    publish_ts    content_type    video_length    likes    comments    shares<br/>account_01    2026-01-01 12:30    挑战    15    1200    300    50<br/>account_01    2026-01-02 09:45    教程    30    800    120    40<br/>account_02    2026-01-01 14:10    记录    20    950    200    60</p><p>表格示例展示了每条内容的核心采集字段，可直接用于趋势分析和可视化。</p><h2>八、结语</h2><p>从抓取到分析，每一步都体现了工程实践的重要性。作为开发者，我更关注的是方法论和流程，而不是工具本身。顺带提到的 TikTok Viewer 页面，只是辅助浏览的一种入口，并不影响整体工程流程。</p><p>真正有价值的是：标准化的数据采集、可复盘的分析流程和趋势洞察能力，这是任何社媒数据分析项目长期可持续的核心。</p>]]></description></item><item>    <title><![CDATA[HarmonyOS 安全认证进阶：PatternLock 从原理到分布式场景的全链路实战 认真的咖啡]]></title>    <link>https://segmentfault.com/a/1190000047601447</link>    <guid>https://segmentfault.com/a/1190000047601447</guid>    <pubDate>2026-02-09 14:05:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>前言</h2><blockquote>在万物互联的全场景时代，设备之间的边界正在消失，安全认证已不再是单一设备的 “孤岛式” 防御，而是跨端协同的 “全链路” 保障。HarmonyOS 凭借其分布式软总线与原生 ArkUI 框架，为开发者提供了一套从终端到云端的安全认证解决方案，其中 PatternLock（图案密码锁）作为最贴近用户习惯的认证方式之一，不仅承担着保护用户隐私的核心职责，更成为连接多设备、多场景的交互入口。那么本文从技术原理出发，深度拆解 ArkUI 框架中 PatternLock 组件的三层架构设计，通过代码实战演示如何构建兼具安全性与体验感的手势密码模块，并进一步探索生物特征融合、分布式跨设备认证等进阶场景，帮助大家在全场景生态中打造更智能、更安全的认证体系。</blockquote><h2>PatternLock概念</h2><p>在HarmonyOS开发中，PatternLock是图案密码锁组件，以九宫格图案的方式输入密码，用于密码验证场景。手指在PatternLock组件区域按下时开始进入输入状态，手指离开屏幕时结束输入状态完成密码输入。（需要说明的是，该组件从API Version 9开始支持。）<br/>PatternLock 的交互逻辑简洁直观：用户手指按下九宫格区域时进入输入状态，离开屏幕时触发轨迹校验，整个过程无需键盘输入，既提升了操作效率，又降低了密码泄露风险。</p><h2>PatternLock核心功能解析</h2><h3>1、组件架构特性</h3><p>PatternLock是ArkUI框架提供的安全认证组件，采用三层架构设计：</p><ul><li>交互层：提供可定制的九宫格绘制界面，支持动态波纹反馈、连线样式自定义，让输入过程更具视觉引导性；</li><li>控制层：通过PatternLockController实现组件状态的实时控制，包括密码重置、锁定时长配置、验证结果反馈等核心能力；</li><li><p>数据层：内置哈希算法对轨迹坐标进行不可逆加密，并支持与 HarmonyOS 系统安全服务联动，确保密码传输与存储的安全性。</p><h3>2、核心参数配置</h3><p>组件的核心参数可灵活调整，以适配不同界面风格与交互需求：<br/><img width="723" height="224" referrerpolicy="no-referrer" src="/img/bVdnTto" alt="image.png" title="image.png"/></p></li></ul><h3>3、样式继承树</h3><p>关于PatternLock的样式继承树，如下所示：</p><pre><code>PatternLock → CommonShape → CommonAttribute → Component</code></pre><h2>PatternLock样式设置</h2><p>在实际开发中，任何一个组件的样式相关的设置都是非常重要且常用的操作，那么PatternLock也不例外，接下来分享关于样式相关的使用操作。<br/><img width="723" height="238" referrerpolicy="no-referrer" src="/img/bVdnTtp" alt="image.png" title="image.png" loading="lazy"/><br/>这里只分享关于PatternLock的样式设置相关的参数，具体的实际使用会在下一部分详细分享。</p><h2>关于PatternLock的基础使用</h2><h3>1、组件初始化与控制器绑定</h3><p>使用 PatternLock 的第一步是引入组件库并创建控制器实例，以实现状态的统一管理，具体如下所示：</p><pre><code>// 导入组件库
import { PatternLock, PatternLockController } from '@ohos.arkui.ts/components';

// 创建控制器实例
private patternLockCtrl: PatternLockController = new PatternLockController();</code></pre><h3>2、基础布局与视觉定制</h3><p>通过链式调用属性方法，可快速完成九宫格的布局与样式配置，包括尺寸、颜色、动态效果等，如下所示：</p><pre><code>PatternLock(this.patternLockController)
        .sideLength(200)
        .circleRadius(9)
        .pathStrokeWidth(5)
        .regularColor('#ff182431') // 未选中的颜色
        .activeColor('#707070') // 激活状态的颜色
        .selectedColor('#707070') // 选中状态的颜色
        .pathColor('#707070') // 连线颜色
        .backgroundColor('#F5F5F5') // 背景色
        .autoReset(true)
        .activateCircleStyle({ // 动态波纹效果
            color: Color.Blue,
            radius: { value: 18, unit: LengthUnit.VP },
            enableWaveEffect: true  // 启用波纹动画
        })
        .onDotConnect((index: number) =&gt; {
          console.log("onDotConnect index: " + index)
          this.handlePatternComplete(index) // 具体实现方法在下一部分会介绍
        })
</code></pre><h2>3、事件处理与安全校验</h2><p>密码输入完成后，需通过事件回调实现业务逻辑处理，包括长度验证、加密传输与异常拦截，手势完成回调，如下所示：</p><pre><code>private handlePatternComplete(input: number[]) {
    if (input.length &lt; 5) {
        this.showToast("至少连接5个点");
        return;
    }
    const encrypted = this.encryptPattern(input); // 加密方法如下面关于密码加密算法所示
    this.validateWithServer(encrypted);
}
</code></pre><p>由于涉及到加密的设置，关于密码加密算法如下所示：</p><pre><code>private encryptPattern(coordinates: number[]): string {
    const salt = cryptoFramework.createRandom(16);
    const sha256 = cryptoFramework.createHash("SHA256");
    sha256.update({ data: new Int32Array(coordinates) });
    return sha256.digest().then(hash =&gt; {
        return salt + hash.toHex();
    });
}
</code></pre><p>关于异常处理机制，如下所示：</p><pre><code>private errorCount: number = 0;

private handleValidationError() {
    this.errorCount++;
    if (this.errorCount &gt;= 3) {
        this.patternLockCtrl.lock(30000); // 锁定30秒
        this.showAlert("账号已锁定");
    }
}
</code></pre><h2>4、专属事件与控制器能力</h2><p>这里只来介绍非通用事件的使用，PatternLock有2个专属事件：onPatternComplete()和onDotConnect()。</p><h3>（1）onPatternComplete()方法</h3><p>语法：</p><pre><code>onPatternComplete(callback: (input: Array&lt;number&gt;) =&gt; void)</code></pre><p>使用：密码输入结束时触发该回调。<br/>参数：<br/><img width="723" height="220" referrerpolicy="no-referrer" src="/img/bVdnTtq" alt="image.png" title="image.png" loading="lazy"/></p><h3>（2）onDotConnect()方法</h3><p>语法：</p><pre><code>onDotConnect(callback: Callback&lt;number&gt;)</code></pre><p>使用：密码输入选中宫格圆点时触发该回调。<br/>说明：回调参数为选中宫格圆点顺序的数字，数字为选中宫格圆点的索引值（第一行圆点从左往右依次为0、1、2，第二行圆点依次为3、4、5，第三行圆点依次为6、7、8）。</p><h3>5、构造函数</h3><p>constructor()是PatternLockController的构造函数。<br/>系统能力： SystemCapability.ArkUI.ArkUI.Full</p><h3>6、重置状态</h3><p>reset()是重置组件状态。<br/>系统能力： SystemCapability.ArkUI.ArkUI.Full</p><h3>7、高阶玩法</h3><p>然后再分享2个高阶一点的玩法。<br/>生物特征融合认证，具体如下所示：</p><pre><code>async function hybridAuth(pattern: string) {
    const faceResult = await userAuth.auth(Type.FACE);
    if (faceResult === AuthResult.SUCCESS) {
        return this.quickUnlock(pattern);
    }
    return this.strictValidate(pattern);
}
</code></pre><p>分布式场景实现，具体如下所示：</p><pre><code>// 智能手表辅助认证
function watchAssistedAuth() {
    const deviceId = deviceManager.getTrustedDevices()[0];
    distributedLock.begin(deviceId);
    // 同步绘制轨迹...
}</code></pre><h2>PatternLock实际应用示例</h2><p>最后再来分享一个关于PatternLock的详细使用示例，模拟一个验证手势密码是否正确，具体代码如下所示：</p><pre><code>// test.ets
import { LengthUnit } from '@kit.ArkUI'

@Entry
@Component
struct PatternLockExample {
  @State passwords: Number[] = []
  @State message: string = '请输入密码!'
  private patternLockController: PatternLockController = new PatternLockController()

  build() {
    Column() {
      Text(this.message).textAlign(TextAlign.Center).margin(20).fontSize(20)
      PatternLock(this.patternLockController)
        .sideLength(200)
        .circleRadius(9)
        .pathStrokeWidth(5)
        .activeColor('#707066')
        .selectedColor('#707066')
        .pathColor('#707066')
        .backgroundColor('#F6F6F6')
        .autoReset(true)
        .activateCircleStyle({
          color: '#606060',
          radius: { value: 16, unit: LengthUnit.VP },
          enableWaveEffect: true
        })
        .onDotConnect((index: number) =&gt; {

        })
        .onPatternComplete((input: Array&lt;number&gt;) =&gt; {
          // 输入的密码长度小于5时，提示重新输入
          if (input.length &lt; 5) {
            this.message = '密码长度需大于5位，请重新输入。'
            return
          }
          // 判断密码长度是否大于0
          if (this.passwords.length &gt; 0) {
            // 判断两次输入的密码是否相同，相同则提示密码设置成功，否则提示重新输入
            if (this.passwords.toString() === input.toString()) {
              this.passwords = input
              this.message = '密码设置成功: ' + this.passwords.toString()
              this.patternLockController.setChallengeResult(PatternLockChallengeResult.CORRECT)
            } else {
              this.message = '两次输入的密码不一致，请重新输入。'
              this.patternLockController.setChallengeResult(PatternLockChallengeResult.WRONG)
            }
          } else {
            // 提示第二次输入密码
            this.passwords = input
            this.message = "请重新输入。"
          }
        })
      Button('重置手势密码').margin(40).onClick(() =&gt; {
        // 重置密码锁
        this.patternLockController.reset()
        this.passwords = []
        this.message = '请输入密码。'
      })
    }.width('100%').height('100%')
  }
}</code></pre><p>上面的这个示例通过sideLength设置九宫格的大小、circleRadius等属性设置宫格圆点样式、onPatternComplete属性设置密码输入时的回调。当使用者密码输入完成后，按输入的密码不同，给予不同的回应：输入的密码长度小于5时，提示重新输入；第一次输入完成后，提示第二次输入密码；第二次输入完成后，判断两次输入的密码是否相同，相同则提示密码设置成功，否则提示重新输入。然后可以通过'重置手势密码'按钮，可以重置密码锁。</p><h2>最后</h2><p>随着 HarmonyOS 全场景生态的持续演进，PatternLock 已从传统的 “单点认证工具”，进化为连接多设备、多模态的 “安全交互枢纽”。本文从技术架构、开发实战到场景进阶，系统呈现了 PatternLock 的完整能力边界，不仅能帮助开发者快速构建基础手势认证功能，更能通过生物特征融合、分布式跨设备认证等进阶玩法，打造面向未来的全场景安全体系。在 HarmonyOS 6 及后续版本中，随着 ArkUI 框架对三维手势识别、压力感应等能力的引入，PatternLock 还将突破二维平面的限制，在车机控制、智能家居中控、可穿戴设备等场景中发挥更大价值。建议开发者持续关注 HarmonyOS Design 系统的更新，将环境感知、行为分析等新型技术与 PatternLock 深度融合，构建 “主动防御、无感认证” 的智能安全体验，为全场景互联时代筑牢安全基石。这里我建议大家持续关注HarmonyOS Design系统的更新，将生物特征、环境感知等新型认证方式与PatternLock深度融合，构建面向未来的智能安全体系，一起期待吧！</p>]]></description></item><item>    <title><![CDATA[免费SSL证书怎么选？JoySSL/Let's Encrypt/Cloudflare等主流方案对比 ]]></title>    <link>https://segmentfault.com/a/1190000047601449</link>    <guid>https://segmentfault.com/a/1190000047601449</guid>    <pubDate>2026-02-09 14:04:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>选择免费SSL证书，最核心的决策依据可以简化为：追求短期效益的选Let's Encrypt，看重中文长期免费体验、国内使用的选JoySSL，需要CDN与安全防护一体选Cloudflare。</p><p><img width="723" height="692" referrerpolicy="no-referrer" src="/img/bVdmPz6" alt="" title=""/></p><h2>一、JoySSL：国产首选的中文友好长期方案</h2><p>JoySSL是国内专注提供免费SSL证书的服务商，主打本地化服务和中文体验，最大特色是提供永久免费的DV单域名SSL证书，吸引了大量国内个人站长和中小企业用户。</p><h3>优势</h3><ol><li><strong>中文界面更友好</strong>：全程中文操作指引，从申请下载到配置部署都提供中文文档，新手也能轻松上手，无需依赖翻译工具。</li><li><strong>永久免费基础版</strong>：个人用户可免费领取永久有效的单域名DV证书，无需担心定期续期问题，适合长期稳定运行的个人站点。</li><li><strong>支持国密算法</strong>：可提供符合国家标准的SM2国密证书，满足政务、金融等合规要求，为国内用户提供本土化加密选择。</li><li><strong>多平台部署教程</strong>：提供针对宝塔面板、Nginx、Apache、Docker等主流平台的详细中文配置教程，降低部署难度。</li></ol><h3>缺点</h3><ol><li><strong>通配符证书需付费</strong>：仅单域名证书永久免费，多域名和通配符证书需要购买专业版，对于需要覆盖子域名的多域名站点不够友好。</li><li><strong>品牌知名度稍低</strong>：相比Let's Encrypt，市场认知度稍逊，部分用户可能对国产证书安全性存在顾虑，但实际上其DV证书同样通过国际主流浏览器信任根体系认证。</li></ol><h3>适用场景</h3><p>国内个人博客、小型企业官网、微信小程序后端服务，适合偏好中文界面，追求长期稳定且无需频繁续期的用户。</p><h2>二、Let's Encrypt：全球最成熟的开源自动化方案</h2><p>Let's Encrypt是由互联网安全研究小组（ISRG）运营的非营利组织，是目前全球使用量最高的免费SSL证书提供商，覆盖全球超4亿个域名，是个人开发者和中小团队的首选方案。</p><h3>优势</h3><ol><li><strong>完全零成本</strong>：无隐藏消费，不限制申请次数，支持单域名、多域名和通配符证书类型，所有证书均为DV（域名验证）类型，可满足绝大多数普通网站的加密需求。</li><li><strong>自动化程度高</strong>：通过ACME协议实现自动化申请、部署和续期，配合Certbot、acme.sh等工具，可实现证书到期前自动续期，完全无需人工干预。</li><li><strong>兼容性极强</strong>：支持Nginx、Apache、Caddy等所有主流Web服务器，同时适配Windows、Linux、Docker等各种操作系统，几乎不存在兼容性问题。</li><li><strong>社区资源丰富</strong>：作为行业标杆，相关教程和解决方案覆盖全面，遇到问题能快速找到解决办法，适合有一定技术能力的开发者。</li></ol><h3>缺点</h3><ol><li><strong>证书有效期短</strong>：证书有效期仅90天，虽然支持自动续期，但依赖服务器环境稳定和续期脚本配置，一旦脚本失效可能导致证书过期。</li><li><strong>中文支持不足</strong>：官方文档以英文为主，新手上手门槛略高，部分错误提示不够直观。</li><li><strong>通配符证书需手动DNS验证</strong>：申请通配符证书时无法通过文件验证，必须手动添加DNS TXT记录完成域名所有权验证，流程相对繁琐。</li></ol><h3>适用场景</h3><p>个人博客、开源项目、测试环境、中小团队的长期稳定站点，适合熟悉服务器操作，能自主维护续期脚本的用户。</p><h2>三、Cloudflare CDN：自带安全与性能增益的云方案</h2><p>Cloudflare是全球最大的CDN服务商之一，提供免费SSL证书与CDN加速一体化服务，无需用户手动下载部署证书，通过域名DNS解析配置即可实现全站加密。</p><h3>优势</h3><ol><li><strong>零部署成本</strong>：只需将域名DNS解析到Cloudflare，即可一键启用SSL加密，无需处理证书申请、上传、配置等繁琐步骤，新手也能快速上手。</li><li><strong>附赠多重安全防护</strong>：启用Cloudflare SSL的同时，可自动获得DDoS攻击防护、WAF防火墙、恶意IP拦截等安全功能，有效提升网站安全性。</li><li><strong>支持边加密与全加密模式</strong>：提供Flexible、Full、Full (strict)三种加密模式，可适配不同服务器配置，同时支持HTTP/2、HTTP/3等现代化网络协议。</li><li><strong>全球加速能力</strong>：借助Cloudflare遍布全球的CDN节点，可同步提升网站访问速度，尤其适合面向全球用户的站点。</li></ol><h3>缺点</h3><ol><li><strong>依赖CDN服务</strong>：必须将域名DNS解析到Cloudflare才能使用SSL证书，若服务器无法对接Cloudflare CDN，或不希望使用第三方CDN，该方案无法使用。</li><li><strong>免费版存在功能限制</strong>：免费版仅支持单域名证书，通配符证书需升级到付费版，同时部分安全和加速功能存在速率和流量限制。</li><li><strong>延迟略增</strong>：经过Cloudflare中转后，可能带来轻微的网络延迟，对于对响应速度有极高要求的站点（如实时交易系统）可能存在影响。</li></ol><h3>适用场景</h3><p>需要同时实现加密、加速和安全防护的网站，适合缺乏技术能力手动部署SSL证书的新手用户，以及希望简化运维流程的中小团队。</p><h3>四、三类免费SSL证书详细对比表</h3><p>表格</p><table><thead><tr><th><strong>对比维度</strong></th><th><strong>Let's Encrypt</strong></th><th><strong>JoySSL</strong></th><th><strong>Cloudflare</strong></th></tr></thead><tbody><tr><td><strong>证书类型</strong></td><td>单域名/多域名/通配符</td><td>永久免费单域名</td><td>单域名（免费版）</td></tr><tr><td><strong>有效期</strong></td><td>90天，自动续期</td><td>永久</td><td>永久（绑定CDN服务）</td></tr><tr><td><strong>申请门槛</strong></td><td>需域名所有权验证，支持文件/DNS验证</td><td>需域名所有权验证，支持文件/DNS验证</td><td>需将域名DNS解析到Cloudflare</td></tr><tr><td><strong>技术门槛</strong></td><td>需配置ACME脚本，适合有一定技术基础用户</td><td>中文界面引导，新手友好</td><td>零配置，启用CDN即可自动生效</td></tr><tr><td><strong>附加功能</strong></td><td>仅SSL加密</td><td>国密算法支持，适配国内合规需求</td><td>CDN加速、DDoS防护、WAF防火墙</td></tr><tr><td><strong>适用场景</strong></td><td>个人博客、开发者测试环境、中小团队长期站点</td><td>国内个人站长、小型企业官网</td><td>需要加密+安全防护的站点、追求简化运维的团队</td></tr></tbody></table><h2>五、其他主流免费SSL方案对比</h2><h3>阿里云免费SSL证书</h3><p>阿里云与DigiCert合作推出的免费DV证书，单域名有效期3个月，个人用户每年可免费申请20张。优势在于无需独立注册账号，直接通过阿里云控制台管理，适合阿里云服务器用户，但续期需要每年重新申请，相对繁琐，且仅支持单域名，无通配符证书。</p><h3>腾讯云免费SSL证书</h3><p>腾讯云提供的免费DV证书，有效期12个月，支持单域名证书，通过腾讯云DNS验证流程，自动化程度较高，但每年仅支持5张免费证书，适合腾讯云生态内的短期项目或测试站点。</p><h3>ZeroSSL</h3><p>ZeroSSL与Let's Encrypt基于同一ACME协议，支持通配符证书和中文界面，提供可视化申请流程，降低新手上手难度，但续期仍需要配置自动脚本，且免费版每月仅支持3个域名，适合对界面友好度要求较高的临时项目。</p><h2>六、选型决策指南</h2><ol><li><strong>技术能力导向</strong>：有服务器运维经验，希望实现全自动续期，首选Let's Encrypt。</li><li><strong>中文体验导向</strong>：偏好中文界面，希望永久免费且无需续期，首选JoySSL。</li><li><strong>一站式需求</strong>：需要CDN加速和安全防护，不想手动操作证书部署，首选Cloudflare。</li><li><strong>云生态适配</strong>：使用阿里云或腾讯云服务器，可优先选择对应云厂商的免费证书，减少跨平台操作流程。</li></ol>]]></description></item><item>    <title><![CDATA[申请OV SSL证书的详细攻略 才高八斗的杯子_dS2Fpp ]]></title>    <link>https://segmentfault.com/a/1190000047601454</link>    <guid>https://segmentfault.com/a/1190000047601454</guid>    <pubDate>2026-02-09 14:04:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h4>什么是OVSSL证书？</h4><p>OVSSL证书，即<strong>组织验证型SSL证书</strong>。它不仅仅验证域名的所有权，更重要的是由权威的CA机构对申请<strong>企业或组织的真实存在、合法注册及运营状态</strong>进行人工审核。这是其与DV证书最核心的区别。</p><ul><li><strong>直观体现</strong>：安装后，在浏览器地址栏点击小锁图标，可以查看到<strong>企业/组织的详细信息</strong>。</li><li><strong>核心价值</strong>：建立更强的在线信任，向用户证明网站背后是一个真实合法的实体，常用于企业官网、电子商务、会员登录等需要用户提交敏感信息的场景。<br/><img width="489" height="358" referrerpolicy="no-referrer" src="/img/bVdc91G" alt="" title=""/></li></ul><h4>如何申请OVSSL证书？（详细步骤）</h4><h4><strong>第一步：前期准备与信息确认</strong></h4><ol><li><strong>确定域名</strong>：明确需要保护的域名（例如 <code>yourcompany.com</code>）。</li><li><p><strong>准备企业资料</strong>：这是最关键的一步，确保资料真实、有效且与官方记录一致。</p><ul><li><strong>企业营业执照</strong>：清晰的彩色扫描件。</li><li><strong>企业联系电话</strong>：必须是官方公开的、能接通的公司座机号码（非个人手机），用于CA电话核实。</li><li><strong>企业邮箱</strong>：通常需要使用以申请域名结尾的企业邮箱（如 <code>admin@yourcompany.com</code>），用于接收验证邮件。部分CA也接受其他公认的企业邮箱。</li><li><strong>申请者信息</strong>：申请人的姓名、职位、公司座机、个人邮箱。</li></ul></li></ol><h4>第二步：选择证书服务商（CA或经销商）并下单</h4><p>访问JoySSL官方网站，在右上角找到“注册”按钮并点击。填写相关信息，创建一个证书管理账号。注册过程中，务必填写特定的注册码<strong>230970</strong>，这样才可以获得渠道低价和全程技术支持。</p><h3><a href="https://link.segmentfault.com/?enc=rEnydCwYP1rnCTIzmSgDmg%3D%3D.PW%2FMbjurr2q5HDnffSa0Te44S6mdoiaU4K4l5ELIbE%2BYTOVhuHVorSVXlDfqm7uDw2h1EyIO9WEx86p9Z1JiQA%3D%3D" rel="nofollow" target="_blank">OVSSL证书申请入口</a></h3><p><strong>1、选择证书类型与年限</strong></p><p>登录账号后，进入SSL证书栏，找到“OV证书”选项。根据自身需求，选择OV单域名、OV通配符、或者OV IP地址等SSL证书后，点击“下单”，并通过在线支付或公对公转账的方式完成支付。</p><p><strong>2、申请证书</strong></p><p>在申请页面，需要填写一系列信息，包括域名、单位名称、联系人、联系方式、邮箱等。这些信息将用于验证单位的真实性，所以务必确保准确无误。</p><p><strong>3、验证域名或IP的管理权</strong></p><p>提交申请后，并要求验证域名或者IP地址的所有权。按照系统提示的操作步骤进行验证，包括域名DNS解析认证或者服务器文件验证，操作完成后提交。</p><p><strong>4、组织信息审核</strong></p><p>JoySSL会对企业的组织信息进行验证，通常会通过电话、电子邮件等方式确认公司信息的真实性，审核过程一般在1到3个工作日左右完成。</p><p><strong>4、部署证书</strong></p><p>一旦审核通过后，JoySSL将签发OV SSL证书。下载已经签发的证书，根据JoySSL提供的安装指南或服务器文档，将证书安装到服务器上。</p>]]></description></item><item>    <title><![CDATA[达内教育-Java培优班 学习园地主页 ]]></title>    <link>https://segmentfault.com/a/1190000047601457</link>    <guid>https://segmentfault.com/a/1190000047601457</guid>    <pubDate>2026-02-09 14:03:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在Java编程学习的征途上，许多学习者怀揣热情启程，却在基础语法阶段遭遇意想不到的障碍与困惑。这些看似简单的语法细节，往往成为后续深入学习与项目开发中的隐形绊脚石。达内Java培优班基于多年教学经验与海量学员学习数据，精准识别出那些最常见却又最容易被忽视的Java基础语法易错点，并通过系统化的拆解，帮助学员夯实编程根基，避开前行路上的诸多陷阱。</p><hr/><p>变量与数据类型：类型转换的隐秘风险<br/>Java作为一门强类型语言，变量与数据类型的严格管理是其核心特性之一。然而，恰恰是在“类型转换”这一基础环节，许多初学者频频犯错。达内培优班在教学中发现，尽管自动类型转换（隐式转换）和强制类型转换（显式转换）的概念看似简单，但在实际操作中，学习者往往因忽略数据范围与精度损失而引发逻辑错误。</p><p>例如，在将float类型赋值给long类型时，看似直接的赋值操作背后，实则可能隐藏着数据精度的微妙变化。培优班通过引入“数据范围阶梯图”与“精度损失警示模型”，将抽象的转换规则可视化，帮助学员建立起对数据类型边界的直观认知。更重要的是，课程特别强调在商业计算等精度敏感场景中，为何要避免使用float和double，而应转向BigDecimal这类工具，这种从原理到实践的全方位解析，让学员不仅“知其然”，更“知其所以然”。</p><hr/><p>运算符与表达式：优先级与结合性的思维盲区<br/>“为什么我的计算结果和预期不符？”——这是Java初学者在涉及复杂表达式时最常见的疑问。达内培优班的教学分析显示，问题往往不在于学员不会使用单个运算符，而在于对运算符的“优先级”和“结合性”缺乏系统把握。</p><p>Java中数十种运算符有着明确的优先级层次，而同一优先级的运算符则遵循特定的结合方向。培优班通过独创的“运算符优先级扑克牌”记忆法与大量“表达式拆解沙盘练习”，将这一枯燥的规则转化为可操作、可演练的学习体验。例如，对于a += b与a = a + b这类细微差别，课程会设计对比实验，让学员亲眼见证在类型不同时两者可能产生的不同结果，从而深刻理解复合赋值运算符内含的类型转换机制。</p><hr/><p>控制流程：循环与条件分支的逻辑陷阱<br/>控制流程是编程逻辑的骨架，但骨架的连接处往往是最脆弱的部分。在if-else条件判断中，初学者常因误用赋值运算符=代替关系运算符==而引入难以察觉的错误。培优班不仅指出这一常见错误，更进一步剖析其根源：为何Java编译器在某些情况下不会对此报错？这背后涉及表达式返回值、布尔上下文等更深层的语言特性。</p><p>循环结构中的易错点则更为隐蔽。例如，在for循环中修改循环变量、在多重循环中错误定位break与continue的作用范围、对while与do-while的选择不当等。达内培优班采用“代码执行轨迹追踪法”，通过逐步动画演示程序执行的每个步骤，将内存中变量的变化可视化，使学员清晰看到自己的逻辑误解究竟发生在哪个具体环节。</p><hr/><p>面向对象基础：引用与对象的认知混淆<br/>面向对象是Java的核心范式，而理解“引用”与“对象”的关系则是通往这一范式的第一道门槛。许多学员在方法参数传递时，对“值传递”这一概念产生根本性误解，误以为对象作为参数传递时是“引用传递”。培优班通过精心设计的“对象盒子与引用标签”比喻，将这一抽象概念具象化：引用变量好比一个贴有地址的标签，而对象则是存储在该地址的盒子；方法调用时传递的是标签的副本，而非盒子本身。</p><p>这一根本性理解的建立，直接影响到学员对对象比较（==与equals的区别）、对象克隆、以及集合框架中元素存储方式等一系列高级主题的掌握。培优班通过“认知纠偏-概念重建-实践验证”三步教学法，确保学员在这一关键节点上建立正确且牢固的认知模型。</p><hr/><p>异常处理：被忽视的防御性编程起点<br/>异常处理机制常被视为进阶内容而被初学者草率对待，但达内培优班将其定位为“基础语法中的高级修养”。教学中发现，学员最常出现的错误并非不知道try-catch的语法，而是对“该捕获什么异常”、“何时该捕获”、“捕获后该如何处理”缺乏清晰原则。</p><p>培优班独创“异常分类光谱图”，将Java异常体系按照严重程度、处理责任、发生频率等维度进行分类展示，帮助学员建立异常处理的层次化思维。更重要的是，课程强调异常处理不仅是语法要求，更是防御性编程的起点。通过分析未处理异常如何导致程序崩溃、资源泄露等严重后果，学员能够从项目全局的角度重新审视这一基础语法的战略价值。</p><hr/><p>总结：从易错点到思维模式的升华<br/>达内Java培优班对基础语法易错点的拆解，其深层价值不在于罗列常见错误清单，而在于通过这些问题揭示Java编程的思维模式与设计哲学。每一个易错点都是一个知识盲区的信号，每一次纠错都是一次思维结构的优化。</p><p>培优班的教学实践表明，当学员能够主动识别并规避这些基础语法陷阱时，他们的编程思维已经发生了质的飞跃：从机械记忆语法规则，转变为理解语言设计逻辑；从被动应对编译错误，转变为主动预防逻辑缺陷。这种思维层面的提升，正是学员从Java语法学习者成长为合格Java开发者的关键转折点，也为后续深入框架学习、参与企业级项目开发奠定了最为坚实的基础。在达内的教学体系中，对基础语法的精雕细琢，从来都不是小题大做，而是对编程生涯的深度投资。</p>]]></description></item><item>    <title><![CDATA[HarmonyOS ：AI 套件技能调用从场景到实战全指南 认真的咖啡 ]]></title>    <link>https://segmentfault.com/a/1190000047601460</link>    <guid>https://segmentfault.com/a/1190000047601460</guid>    <pubDate>2026-02-09 14:02:35</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>写在前面</h2><blockquote>在 AI 从 “云端集中式” 向 “端侧分布式” 演进的今天，用户对智能体验的需求早已从 “能用” 升级为 “安全、实时、无界”，而 HarmonyOS 凭借原生的端侧 AI 能力与分布式架构，恰好击中了这一行业痛点。不同于依赖云端算力的传统 AI 方案，HarmonyOS 的 AI 套件构建在 “本地计算 + 毫秒响应 + 模型复用” 三大核心优势之上：端侧推理让用户数据全程留在设备内，完美解决了 AI 应用的隐私焦虑；毫秒级的响应速度，让语音交互、实时识别等场景告别 “加载等待”；而系统级的模型复用机制，更是让开发者无需从头训练模型，仅通过标准化接口就能调用成熟的智能能力。那么本文就来以HarmonyOS开发中关于AI套件的技能调用功能的使用来详细聊聊，深入解析如何通过系统级AI接口、分布式协同框架与模型优化工具链，实现高效智能业务开发。</blockquote><h2>技能调用：端侧 AI 与应用的智能联动机制</h2><p>技能调用是意图框架依托系统AI多模态大模型能力做深度用户输入理解，并通过解析的用户意图对接应用或元服务内的功能和内容。技能调用的本质，是 HarmonyOS 意图框架借助系统级多模态大模型，对用户输入（语音、文本、图像等）进行深度语义解析，进而关联应用 / 元服务内功能与内容的智能联动机制。它的核心价值，是让用户通过自然语言即可直接触发复杂功能，无需逐层点击界面，实现 “说即所得” 的智能交互。</p><h2>核心应用场景拆解</h2><p>使用者通过对小艺对话进行自然语言输入实现内容查询，知识问答，以及通过对图片选定识别问答进行服务获取。技能调用场景分为两种：</p><ul><li>功能服务类：端侧意图调用直接进入应用或元服务对应意图功能服务页面。</li><li><p>信息交互类：云侧意图调用进行内容查询后展示，端侧用户点击进行意图调用闭环。<br/>典型的使用场景分为：功能服务类和信息交互类两种场景。</p><h3>1、信息交互类</h3><p>信息交互类的场景分为三种情况，具体如下所示：</p></li><li>内容展示场景。例如查找菜谱：语音对话输入“鱼香肉丝怎么做”，即可搜索到对应的菜谱。</li><li>内容展示+AIGC生成场景。例如查公司：语音对话输入“某公司怎么样”，即可生成并展示关于某公司的信息。</li><li><p>功能履约场景。例如订电影票：语音对话输入“买两张今天的电影票，某电影”，即可进行电影票购买选座。</p><h3>2、功能服务类</h3><p>功能服务类的场景也分为三种情况，具体如下所示：</p></li><li>跳转页面不带参数场景。例如打开付款码：语音对话输入“打开xx付款码”，即可弹窗对应付款码。</li><li>跳转页面带参数场景。例如搜索商品带关键词：语音对话输入“打开xx应用搜一下xx品牌39码”，即可弹窗对应商品。</li><li><p>功能执行并展示UIExtension。例如操控蓝牙开关：语音对话输入“打开蓝牙”，即可弹窗蓝牙设置，并打开蓝牙开关。</p><h2>技能调用接入全流程</h2><h3>1、接入方案概述</h3><p>关于使用接入方案的概述，开发者需要按照意图定义，进行意图注册并实现意图调用；用户通过对小艺对话进行自然语言输入，小艺理解语义转换成意图调用（含意图参数），执行意图调用实现对应交互体验。HarmonyOS AI 套件的技能调用遵循 “意图定义→意图注册→意图执行” 的标准化流程，具体流程图如下所示：<br/><img width="723" height="504" referrerpolicy="no-referrer" src="/img/bVdnTtA" alt="image.png" title="image.png"/></p><h3>2、意图注册</h3><p>这里以“搜索旅游攻略”特性为例，使用者需要首先注册“查看旅游攻略”（ViewTravelGuides）。开发者需要编辑对应的意图配置PROJECT_HOME/entry/src/main/resources/base/profile/insight_intent.json文件，实现意图注册，具体操作如下所示：</p></li></ul><pre><code>{
  "insightIntents": [
    {
      "intentName": "ViewTravelGuides",
      "domain": "TravelDomain",
      "intentVersion": "1.0.1",
      "srcEntry": "./ets/entryability/InsightIntentExecutorImpl.ets",
      "uiAbility": {
        "ability": "EntryAbility",
        "executeMode": [
          "background",
          "foreground"
        ]
      },
      "uiExtension": {
        "ability": "insightIntentUIExtensionAbility"
      }
    }
  ]
}</code></pre><p>其中，配置参数信息如下所示：<br/><img width="723" height="582" referrerpolicy="no-referrer" src="/img/bVdnTtD" alt="image.png" title="image.png" loading="lazy"/></p><h2>技能调用实战：两类核心意图触发</h2><p>根据上面的接入方案，这里通过前台意图和前台窗口意图两个调用来介绍具体的使用。</p><h3>1、前台 UIAbility 意图调用实践</h3><p>具体的使用的时候，需要开发者自己实现InsightIntentExecutor，并在对应回调实现打开详细页（点击推荐卡片跳转的界面，如旅游攻略详细页面）的能力，ViewTravelGuides的意图调用字段定义见查看旅游攻略 （ViewTravelGuides）。实际操作步骤如下：<br/>（1）继承InsightIntentExecutor。<br/>（2）重写对应方法，例如目标拉起前台页面，则可重写onExecuteInUIAbilityForegroundMode方法。<br/>（3）通过意图名称，识别查看旅游攻略意图(ViewTravelGuides)，在对应的方法中传递意图参数（param），并拉起对应落地页（点击推荐卡片跳转的界面，如旅游攻略详细面）。<br/>具体的实现代码如下所示：</p><pre><code>import { insightIntent, InsightIntentExecutor } from '@kit.AbilityKit';
import { window } from '@kit.ArkUI';
import { BusinessError } from '@kit.BasicServicesKit';


export default class InsightIntentExecutorImpl extends InsightIntentExecutor {
  private static readonly VIEW_TRAVEL_GUIDES = 'ViewTravelGuides';
  /**
   * override 执行前台UIAbility意图
   *
   * @param name 意图名称
   * @param param 意图参数
   * @param pageLoader 窗口
   * @returns 意图调用结果
   */
  onExecuteInUIAbilityForegroundMode(name: string, param: Record&lt;string, Object&gt;, pageLoader: window.WindowStage):
    Promise&lt;insightIntent.ExecuteResult&gt; {
    // 根据意图名称分发处理逻辑。接入方可根据实际业务实现页面跳转
    switch (name) {
      case InsightIntentExecutorImpl.VIEW_TRAVEL_GUIDES:
        return this.viewTravelGuides(param, pageLoader);
      default:
        break;
    }
    return Promise.resolve({
      code: -1,
      result: {
        message: 'unknown intent'
      }
    } as insightIntent.ExecuteResult)
  }
  /**
   * 实现调用查看旅游攻略功能
   *
   * @param param 意图参数
   * @param pageLoader 窗口
   */
  private viewTravelGuides(param: Record&lt;string, Object&gt;, pageLoader: window.WindowStage): Promise&lt;insightIntent.ExecuteResult&gt; {
    return new Promise((resolve, reject) =&gt; {
      // 实现意图调用，loadContent的入参为旅游攻略落地页路径
      pageLoader.loadContent('pages/TravelGuidePage')
        .then(() =&gt; {
          let entityId: string = (param.items as Array&lt;object&gt;)?.[0]?.['entityId'];
          resolve({
            code: 0,
            result: {
              message: 'Intent execute succeed'
            }
          });
        })
        .catch((err: BusinessError) =&gt; {
          // 调用失败的情况
          resolve({
            code: -1,
            result: {
              message: 'Intent execute failed'
            }
          })
        });
    })
  }
}</code></pre><h3>2、前台 UIExtension 窗口意图调用实践</h3><p>具体的使用的时候，开发者还需要自己实现InsightIntentExecutor，并在对应回调实现窗口页面内容加载的能力。实际操作步骤如下：<br/>（1）继承InsightIntentExecutor。<br/>（2）重写对应方法，例如目标拉起前台窗口化页面，则可重写onExecuteInUIExtensionAbility方法。<br/>（3）通过意图名称，识别打开蓝牙意图（LoadBluetoothCard）调用扩展意图，在对应的方法中传递意图参数（param），并拉起对应窗口化页面。<br/>具体的实现代码如下所示：</p><pre><code>import { insightIntent, InsightIntentExecutor, UIExtensionContentSession } from '@kit.AbilityKit';

export default class IntentExecutorImpl extends InsightIntentExecutor {
  private static readonly TAG: string = 'IntentExecutorImpl';
  private static readonly LOAD_BLUETOOTH_CARD: string = 'LoadBluetoothCard';
  /**
   * override 执行前台UI扩展意图
   *
   * @param name 意图名称
   * @param param 意图参数
   * @param pageLoader 窗口
   * @returns 意图调用结果
   */
  async onExecuteInUIExtensionAbility(name: string, param: Record&lt;string, Object&gt;,
    pageLoader: UIExtensionContentSession):
    Promise&lt;insightIntent.ExecuteResult&gt; {
    console.info(IntentExecutorImpl.TAG, `onExecuteInUIExtensionAbility`);
    switch (name) {
      case IntentExecutorImpl.LOAD_BLUETOOTH_CARD:

        return this.openLoadBluetoothCard(pageLoader);
      default:

        break;
    }

    let result: insightIntent.ExecuteResult = {
      code: -1,
      result: {
        message: 'onExecuteInUIExtensionAbility failed'
      }
    };
    return result;
  }

  /**
   * 打开加载蓝牙卡片意图
   *
   * @param pageLoader 意图内容Session对象
   * @returns 执行结果
   */
  private async openLoadBluetoothCard(pageLoader: UIExtensionContentSession): Promise&lt;insightIntent.ExecuteResult&gt; {
    pageLoader.loadContent('pages/UiExtensionPage');
    let result: insightIntent.ExecuteResult = {
      code: 0,
      result: {
        message: 'intent execute succeed'
      }
    }
    return result;
  }
}</code></pre><h2>最后</h2><p>通过上面的详细介绍，其实HarmonyOS AI 套件的技能调用，本质上是在 “端侧智能” 与 “分布式架构” 的双重加持下，重新定义了开发者与智能能力的协作方式，它不再是 “开发者适配 AI”，而是 “AI 适配开发者”。当其他系统还在依赖云端 AI 的 “远程算力” 时，HarmonyOS 已经通过端侧推理让智能体验 “零延迟、零隐私风险”；当多数框架还在要求开发者掌握复杂的模型训练时，HarmonyOS 的意图框架与预置模型，让个人开发者仅需几行代码就能实现 “自然语言触发功能” 的智能特性。这不仅是技术的平权，更是将 “泛在智能” 从概念落地为可触达的开发工具。随着多模态大模型与 HarmonyOS 分布式硬件的深度绑定，我们将看到更惊人的场景：手机上触发的 “旅游攻略查询”，能自动同步到车机的导航界面；手表上的语音指令，能直接控制智能家居的设备状态，而这一切，都可以通过 AI 套件的技能调用快速实现。</p>]]></description></item><item>    <title><![CDATA[VMware ESXi 9.0.1.0 macOS Unlocker & OEM BIOS 2.7 ]]></title>    <link>https://segmentfault.com/a/1190000047601483</link>    <guid>https://segmentfault.com/a/1190000047601483</guid>    <pubDate>2026-02-09 14:01:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>VMware ESXi 9.0.1.0 macOS Unlocker &amp; OEM BIOS 2.7 集成网迅网卡驱动定制版</p><p>VMware ESXi 9.0 macOS Unlocker &amp; OEM BIOS 2.7 集成网卡驱动和 NVMe 驱动 (集成驱动版)</p><p>发布 ESXi 9.0 集成驱动版，在个人电脑上运行企业级工作负载</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=MPhQAcm36lsWLxV6xEteXQ%3D%3D.gL3FNgPlTxLphcuFpkjTGriRfjE6WSaH071To1WEGzk6%2FiDho6xIa%2BRTQXsb%2Byee" rel="nofollow" target="_blank">https://sysin.org/blog/vmware-esxi-9-sysin/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=IvhCLixd5slbVK1WN5wb8w%3D%3D.r3HjuGyo3qul59uD1ecl8DjUR1UqGw%2FRh6qN98%2Bm4co%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>2026-01-12，应用户要求，更新集成网迅网卡驱动定制版。</p><p><strong>发布 ESXi 9.0 集成驱动版，在个人电脑上运行企业级工作负载，构建开发、测试和学习的最佳平台。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044081967" alt="vSphere Workloads Everywhere" title="vSphere Workloads Everywhere"/></p><h2>通用特性概览</h2><p>该版本在官方原版基础上新增以下特性：</p><ul><li>macOS Unlocker：来自 GitHub 的 <a href="https://link.segmentfault.com/?enc=bTmmER70VQOKftDxTcKFaA%3D%3D.pHVQT7vJOVhociJsdrfgeJiG%2FkZrj%2FWwREReFPPCziJNH%2Fgmx0ab%2FceUILUovM%2Fa" rel="nofollow" target="_blank">Unlocker 4</a>，现已支持 macOS Tahoe</li><li>OEM BIOS 2.7：使用社区最流行的 OEM BIOS/EFI64，现已支持 Windows Server 2025</li><li>LegacyCPU support，允许在不受支持的旧款 CPU 上安装 ESXi 9.0</li><li>ESX-OSData 卷大小修改为 8GB，解决自 ESXi 7.0 起系统占用磁盘空间过大的问题（超过 142GB）</li><li>有限支持采用混合架构的第 12 代及以上 Intel 处理器，可实现正常引导和运行</li><li>中文界面语言支持，在 ESXi 9.0 的 Host Client 中继续支持简体中文界面语言，包括繁体中文</li></ul><p>详情请访问原文链接：<a href="https://link.segmentfault.com/?enc=Gk4gzUFV%2B%2FnQ9ReoU3BjdA%3D%3D.M3isLqJxPYfmhrvlinnqcLpup8wo%2BV4xhwYXoGy1Dk3Vx6R3JfllJZretg9q6ksS" rel="nofollow" target="_blank">https://sysin.org/blog/vmware-esxi-9-sysin/</a> 查看。</p><h2>集成网迅网卡驱动定制版</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047539520" alt="NETSWIFT" title="NETSWIFT" loading="lazy"/></p><p>北京网迅科技有限公司是一家专门从事集成电路高端芯片设计、提供网络产品解决方案的高科技企业。公司成立于 2014 年 5 月，总部位于北京市海淀区玉泉慧谷科技园区，在浙江杭州设有分公司。</p><p>公司成功研制了自有知识产权的万兆和千兆以太网控制器芯片、适配器，突破了一系列计算机网络领域高端芯片设计的难题，在网络安全和网络虚拟化等方面达到了较高水平。</p><p>网迅网卡不仅兼容 Windows 系统和主流的 Linux 发行版，还可以支持最新的 VMware ESXi 系统，远超预期！</p><p>以下是经过验证支持最新版 ESXi 的网讯网卡型号。</p><table><thead><tr><th>Brand Name</th><th>Model</th><th>VendorID</th><th>DeviceID</th><th>SVID</th><th>SSID</th></tr></thead><tbody><tr><td>Wangxun/NETSWIFT</td><td>FF5025-DDATACXX</td><td>8088</td><td>5025</td><td>8088</td><td>1000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>FF5025-DDATAIXX</td><td>8088</td><td>5125</td><td>8088</td><td>3000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>FF5040-DDBTACXX</td><td>8088</td><td>5040</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>FF5040-DDBTAIXX</td><td>8088</td><td>5140</td><td>8088</td><td>3000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>RP1000 series</td><td>8088</td><td>1001</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>RP2000 series</td><td>8088</td><td>2001</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860A2</td><td>8088</td><td>0101</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860A4</td><td>8088</td><td>0103</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860A4S</td><td>8088</td><td>0104</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860AL2</td><td>8088</td><td>0105</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860AL2S</td><td>8088</td><td>0106</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860AL4</td><td>8088</td><td>0107</td><td>0000</td><td>0000</td></tr><tr><td>Wangxun/NETSWIFT</td><td>WX1860AL4S</td><td>8088</td><td>0108</td><td>0000</td><td>0000</td></tr><tr><td>ZTE Corporation</td><td>NO127</td><td>8088</td><td>0103</td><td>1cf2</td><td>0801</td></tr><tr><td>ZTE Corporation</td><td>NO127D</td><td>8088</td><td>0101</td><td>1cf2</td><td>0802</td></tr></tbody></table><h2>下载地址</h2><p><strong>ESXi 9.0.1.0 集成驱动版 (2026-01-12)</strong>：</p><ul><li>发布日期：2026-01-12</li><li>50 余项已知问题修复。请参看：<a href="https://link.segmentfault.com/?enc=v%2BmZ%2Bb%2FAHMpB2x9smJpZvQ%3D%3D.nRn1d9FcvKSyJpT4EkDxP6rP2qGMBesvuYPbQt9qi1uTuK5RuyjpGvSr7D46jmwo" rel="nofollow" target="_blank">ESXi 9.0.1.0 已解决的问题</a>。</li><li>请访问：<a href="https://link.segmentfault.com/?enc=vEUfqeEjIorU2AzgT0A%2F%2Bw%3D%3D.CumTORWNmwo%2FbkRESI%2B4pYGNPTPC%2FduGlotoFDXY3tUk9%2FzUVRz7GpLchNk6rWg7" rel="nofollow" target="_blank">https://sysin.org/blog/vmware-esxi-9-sysin/</a></li></ul><hr/><p>标准版和厂商定制版，请访问：</p><ul><li><a href="https://link.segmentfault.com/?enc=abyI2af7M42aU22e87mHsg%3D%3D.fmI9td0q5mGorj9b0gy9jivSaIop9rmstF2n4YqZQPLwL%2B5ZgqcCiEuX8sV2rfAz" rel="nofollow" target="_blank">VMware ESXi 9.0.1.0 macOS Unlocker &amp; OEM BIOS 2.7 标准版和厂商定制版</a></li></ul><p>官方原版，请访问：</p><ul><li><a href="https://link.segmentfault.com/?enc=C4yta874Jvkjm1sCsymsDg%3D%3D.kBksS3mQVwkdjmmt8Mf3o1wcJrGMTTlVrcKydn4zHTtj9mXdts8HLF6QABC3LG6c" rel="nofollow" target="_blank">VMware vSphere 9.0 正式版发布 - 企业级工作负载平台</a></li></ul><p>上一个版本，请访问：</p><ul><li><a href="https://link.segmentfault.com/?enc=NCj5ZwItJOIiBOg1LAiXJg%3D%3D.TCbvtuEmdUyeGyhcc26SXvKJz7mfzPXMjgkvx3RbRqlHe%2B16pgPyu2Iz1%2FYz0wZv" rel="nofollow" target="_blank">VMware ESXi 8.0U3g macOS Unlocker &amp; OEM BIOS 2.7 集成网卡驱动和 NVMe 驱动 (集成驱动版)</a></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=V1FwdrNUenPNFop1wcLTFw%3D%3D.enK0gj0Dg%2F1EB1z0vu6M3uJd%2B7PZovANhLbMv9tiQ5Y%3D" rel="nofollow" target="_blank">VMware 产品下载汇总</a></p>]]></description></item><item>    <title><![CDATA[Gemini 与住宅代理完整指南：稳定访问、风控理解与网络身份构建 IPPeak ]]></title>    <link>https://segmentfault.com/a/1190000047601493</link>    <guid>https://segmentfault.com/a/1190000047601493</guid>    <pubDate>2026-02-09 14:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>随着生成式 AI 工具逐步走向主流，Gemini 已经成为许多开发者、研究人员以及内容创作者日常工作的一部分。然而，在真实使用过程中，不少用户会发现，Gemini 的访问体验并非始终稳定。页面加载失败、功能不可用、验证反复触发，甚至在不同网络环境下表现差异明显，这些问题的背后，往往并不只是产品本身的限制，而是与网络出口的可信度密切相关。</p><h2>Gemini 对网络环境的隐性要求</h2><p>从表面来看，Gemini 只是一个面向用户开放的 AI 服务，但在底层，它运行在一套高度自动化的风控体系之中。系统并不会单纯依赖账号信息来判断请求是否可信，而是会综合分析访问来源的网络类型、地理位置、IP 历史行为以及整体使用模式。<br/>当访问请求来自数据中心、云服务器或被频繁滥用的代理网络时，即便账号本身没有问题，也更容易触发限制机制。这类限制并不总是以“封禁”的形式出现，而是通过降低响应稳定性、限制功能可用性等方式逐步体现出来。<br/>也正因为这种“软性风控”的存在，很多用户会误以为是 Gemini 本身不稳定，而忽略了网络出口这一核心变量。</p><h2>普通代理在 Gemini 场景中的局限性</h2><p>在尝试优化访问体验时，一部分用户会首先想到使用代理工具。然而，普通代理往往难以满足 Gemini 对网络真实性的隐性要求。这类代理通常集中部署在有限的 IP 段中，出口特征明显，使用行为高度重复。<br/>在短时间内，这种代理或许可以完成连接，但随着请求频率增加，系统很容易识别出异常模式。一旦 IP 被标记，后续访问即使切换账号，也难以恢复到理想状态。这也是为什么频繁更换代理并不能真正解决问题，反而可能进一步降低整体成功率。<br/>真正有效的方案，并不在于“绕过检测”，而在于让访问行为本身更接近真实用户。</p><h2>住宅代理如何改变 Gemini 的访问体验</h2><p>住宅代理的核心价值，在于其 IP 来源于真实家庭网络环境。与服务器代理相比，这类 IP 在网络路径、自治系统归属以及历史行为上，更符合普通用户的访问特征。<br/>当 Gemini 接收到来自住宅网络的请求时，其风控系统更倾向于将其视为正常使用，而非潜在风险。这种差异并不会在界面上直接体现，却会反映在连接稳定性、响应速度以及功能完整性上。<br/>尤其是在需要长期使用 Gemini、频繁进行交互或调用相关功能的场景中，住宅代理所带来的稳定性优势会逐渐显现。</p><h2>网络身份连续性的重要性</h2><p>在 Gemini 的使用过程中，另一个经常被忽视的因素，是网络身份的连续性。系统不仅关注单次请求是否异常，也会观察一段时间内访问行为是否具备连贯性。<br/>如果用户频繁切换 IP，或者在不同地区之间跳跃，反而容易形成不自然的使用轨迹。这种情况下，即便每一个 IP 本身质量尚可，整体行为模式仍然可能触发风控关注。<br/>高质量住宅代理的优势之一，正是在于能够在同一地区内提供足够自然的 IP 分布，使用户在需要更换出口时，依然保持网络身份的一致性。这种连续性，对于 Gemini 这类长期服务型平台尤为重要。</p><h2>真实使用中对代理质量的要求</h2><p>并非所有住宅代理都能带来理想效果。IP 池规模、地区覆盖深度以及匿名配置水平，都会直接影响 Gemini 的访问体验。如果住宅 IP 被过度共享，或者在协议层暴露中转特征，其效果与普通代理并无本质区别。<br/>在这一点上，IPPeak 的住宅代理架构更强调“真实分布”而非简单数量。其 IP 来源覆盖多个核心国家和地区，并保持足够分散的使用密度，使单一出口不容易形成异常使用模式。在实际应用中，这种结构有助于提高 Gemini 访问的整体成功率，并减少因网络问题导致的中断。<br/>需要强调的是，这种稳定性并非依赖激进策略，而是建立在更符合平台预期的网络表现之上。</p><h2>从技术工具到长期使用策略的转变</h2><p>当用户真正将 Gemini 视为长期工具时，对网络环境的要求也会随之发生变化。短期测试阶段，网络问题或许尚可接受，但在持续使用过程中，任何不稳定因素都会被放大。<br/>通过住宅代理构建更可信的网络身份，本质上是在为长期使用打基础。这种策略并不是为了对抗平台规则，而是通过更自然的方式，减少不必要的干扰，让技术工具回归其应有的价值。</p><h2>重新理解 Gemini 与网络出口的关系</h2><p>Gemini 的体验好坏，很大程度上并不取决于使用技巧，而取决于访问环境是否稳定、可信。当网络出口与普通用户高度一致时，系统的反馈也会更加友好。<br/>在这一背景下，住宅代理不再只是一个“辅助工具”，而是连接用户与 AI 服务之间的重要桥梁。理解这一点，往往是许多用户在经历反复尝试后才逐渐形成的共识。</p>]]></description></item><item>    <title><![CDATA[keepass安装与使用手记 三块钱 ]]></title>    <link>https://segmentfault.com/a/1190000047600947</link>    <guid>https://segmentfault.com/a/1190000047600947</guid>    <pubDate>2026-02-09 13:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>参考 与 致谢</h2><p>本手记参考以下博文融合而成，特此致谢：</p><ul><li><a href="https://link.segmentfault.com/?enc=zHEtvw8D3SZAayYBP7XpcA%3D%3D.kYWzf4J4zlZb1fA0i7M9HEQx4ECkKNT4%2BaXfE%2F30jhAyBjh1QB8p64QoyxhaYJlP" rel="nofollow" target="_blank">一劳永逸：KeePass全网最详使用指南</a></li><li><a href="https://link.segmentfault.com/?enc=QxvX9iQgumdQ4Ng1xngD2A%3D%3D.O2oakhG7Y8oKXaggOJPKQC%2BbvhnQK1ZuCRnllsIDprEjnMfd2SaaRaDmgfP4gWgok4nFM381OWnJhWvvENiOeA%3D%3D" rel="nofollow" target="_blank">KeePass安装与插件推荐</a></li><li><a href="https://link.segmentfault.com/?enc=oFXOKBnWQNXPWL%2Byi01VXw%3D%3D.r5VJB%2BfF2HY7uhXdo4l9u4dBFOadO73EqU0pWwW2NGqjqNq802xWW4Gp77%2Fg18ei7GbTevGEaCq18XQNEwnxFtNgUQxBGJ2A3vpgVKedLfRiuSMBP0RcxvK%2FST7Qbrj4" rel="nofollow" target="_blank">KeePass通过KeePassNatMsg和KeePassXC-Browser实现Chrome/FireFox/Edge自动填充</a></li><li><a href="https://link.segmentfault.com/?enc=6jvn2UTTT91WlhD4aN6kXw%3D%3D.tvPH%2FO19vtx6X%2BeBq13OhWZch5KVVJ0%2B4yKHpGNP3RyWQZpXle685zKqIEl8CoSp8FW6GLN4yhHGmgRCl5Nwcg%3D%3D" rel="nofollow" target="_blank">KeePass完全入门指南</a></li><li><a href="https://link.segmentfault.com/?enc=gD5GWIXF1OEOnNu166Zx%2Fw%3D%3D.E2AlqfK%2B76ATs3gxLKGKPBJ1Fgj2lwPZ2p2LhRFSMzo%2FfoMzDscx0N6PH1ZLAPlY" rel="nofollow" target="_blank">Keepass：多平台密码无缝同步</a></li></ul><h2>赖人版本</h2><p><strong>Keepass</strong>是一个在密码管理领域非常出色的一个工具软件，其强大的功能离不开众多的插件支持。但这也带来了一个问题，就是众多的插件配置起来繁琐又容易出错，一个一个测试需要花费巨大的时间和精力投入，就像我这边手记一样。为了避免一次次的配置和踩坑，本手记所配置完成的绿色版本<strong>Keepass</strong>包在这里下载：  <br/>★★★★★<a href="https://link.segmentfault.com/?enc=%2BSGrV1JjUL9bs0hl3hD2tA%3D%3D.1g0m8cP111VAmbYzFEwukg99BbsW6PCa%2BKHyeANfuHJI6uTWriztYq%2BZ5JnO6JN4k%2FDmFqVsSYK7AET3E5bSdA%3D%3D" rel="nofollow" target="_blank">👉Keepass 2.60 配置完整插件</a></p><p>由于每个人的使用环境差异，在下载赖人版本后，你还需要调整以下配置相关项：</p><ul><li>更改你的密码库密钥：〔文件〕/〔更改管理密钥〕</li><li>调整同步配置（坚果云配置），参考下文相关章节</li><li>安装浏览器插件并完成配置，参考下文相关章节</li><li><p>你需要确认几个快捷键：</p><ul><li>自动填充全局快捷键，见〔工具〕/〔选项〕/〔集成〕</li><li>自动填充密码全局快捷键，见〔工具〕/〔选项〕/〔集成〕</li><li>WebAutoType插件的创建记录快捷键，见下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600950" alt="alt text" title="alt text"/></li></ul></li></ul><h2>下载 与 安装</h2><p>此处推荐全胜 <strong>Portable</strong> 版本的keepass，这样你可以把 <strong>keepass</strong> 的程序和数据放到指定的位置即可。然后再通过同步软件（例如你的NAS，例如网盘，例如onedrive等）同步到其它电脑上，或者你可以把 <strong>keepass</strong> 的文件夹整体复制到另外的地方就可以直接使用，非常方便。</p><p><a href="https://link.segmentfault.com/?enc=k3SnMAzqlkBvlCO0uOkjMg%3D%3D.lHhYh%2FLHLIK6zcIughgb%2FGPYO9mMwIbPY9g8rvEeFPhxEhZky4QSHPr581t6w04o" rel="nofollow" target="_blank">👉Keepass2.60 官方链接</a>  <br/><a href="https://link.segmentfault.com/?enc=SCp5IwersQzl6W1QYBPGZQ%3D%3D.OUdS%2BF%2F%2B34V5o2VtjiPQHC0tTr%2B%2BrV8H3Bk2qoDff46pJbUUBuA4ivfEPhO5b76o0QyFa1HApyqtwmG9i0a6Tg%3D%3D" rel="nofollow" target="_blank">👉Portable Keepass2.60 🐕度链接 提取码: 6kms</a></p><h3>汉化</h3><p>在 <strong>Keepass</strong> 的官方网站中，你可以找到<a href="https://link.segmentfault.com/?enc=1PLdP2qN0SfZ8DwpbUm7gg%3D%3D.t%2BEj%2BKonbu9nJH0oM7FOtPRVnjSGa%2BDQHLRqBmIvmzd%2F6H2UBU%2BU8SZcoLZUrxf7" rel="nofollow" target="_blank">👉各种语言包</a>，👇如下  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600951" alt="alt text" title="alt text" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=psVerEOQ4WhuHuDy0GXHsw%3D%3D.g4SrCxyFkQwBEVQOVUX3cgZuL8WUVoCo5IMeYe9FK8J2gd%2FtKwKq%2FIkNR8SIHMySQiSQsTiPbqptglZRThO8Sg%3D%3D" rel="nofollow" target="_blank">👉Keepass2.60 中文语言包 🐕度链接 提取码: swwy</a></p><p>汉化包解压后得到 <strong>Chinese_Simplified.lngx</strong> 文件备用。</p><p><strong>Keepass</strong> 安装后（Portable版本不需要安装），打开界面是英文界面。此时通过〔View〕/〔Change Language〕/〔Open Folder〕打开语言包文件夹，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600952" alt="alt text" title="alt text" loading="lazy"/></p><p>然后将上一步得到的<strong>Chinese_Simplified.lngx</strong>放入打开的文件夹内。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600953" alt="alt text" title="alt text" loading="lazy"/></p><p>然后重启 <strong>Keepass</strong>，便可以选择中文界面了（选择中文语言后，会提示重启），如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600954" alt="alt text" title="alt text" loading="lazy"/></p><p>切换成功后的界面如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600955" alt="alt text" title="alt text" loading="lazy"/></p><h2>创建数据库（kdbx）</h2><p><strong>Keepass</strong>的密码数据存储与数据库文件（.kdbx）中，所以我们在使用<strong>Keepass</strong>前，需要首先创建一个用于储存与管理密码的数据库。</p><ul><li>新建数据库，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600956" alt="alt text" title="alt text" loading="lazy"/></li><li>选择一个位置来存放数据库文档，并给我们的数据库文档指定一个名字，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600957" alt="alt text" title="alt text" loading="lazy"/></li><li><p>然后，我们为我们的数据库设置打开密码，也可以指定另外两种保护方案，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600958" alt="alt text" title="alt text" loading="lazy"/></p><ul><li>👉如果你使用电脑的习惯规范（设置登录密码，并在离开时全胜<strong>Win+L</strong>锁定），单独使用〔管理密码〕或者〔密钥文件〕已经足够了。</li><li>👉我个人是单独使用〔密钥文件〕的，更为方便</li><li>👉密钥文件就是一个普通的文档而已，你可以选择现有的一个文件，也可以根据<strong>Keepass</strong>的引导创建一个新的文件。</li><li>👉密钥文件建议不要与<strong>Keepass</strong>的数据库文档放在同一位置或者关联位置</li><li>👉密钥文件可以重命名，但不可更改其内容</li><li>👉密钥文件建议云端同步，避免丢失</li><li>👉在存放密钥文件的位置，建议存放一些其它的文档，起到混淆作用</li></ul></li><li>设置数据库名称（不是数据库文档名称），如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600959" alt="alt text" title="alt text" loading="lazy"/>  <br/>关于〔应急表单〕，可以打印出来妥善保官，以备万一。</li><li>然后我们就得到了一个数据库，并附带了两个demo密码记录，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600960" alt="alt text" title="alt text" loading="lazy"/></li></ul><p>在后续的配置中，我们都基于我们所建立的数据库进行操作。</p><h2>开机启动</h2><p>开机启动设置如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600961" alt="alt text" title="alt text" loading="lazy"/></p><h2>全局热键</h2><p><strong>Keepass</strong>的全局热键可以使用户在非<strong>Keepass</strong>窗口中，也可以唤出<strong>Keepass</strong>进行键入操作。例如当你在浏览器中时，通过全局热键，就可以唤出<strong>Keepass</strong>录入用户名和密码。</p><p><strong>Keepass</strong>的全局热键可以在〔工具〕/〔选项〕中设置，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600962" alt="alt text" title="alt text" loading="lazy"/></p><h3>Keepass的匹配原理</h3><p>当用户在某一个应用程序中触发<strong>Keepass</strong>的全局热键后，<strong>Keepass</strong>会获取当前应用的标题，然后在数据库中查找应用应用满足要求的记录。并将这条记录键入到目标应用的输入框中。那么，什么样的记录算是满足要求的记录呢？这是在<strong>Keepass</strong>的〔工具〕/〔选项〕中设置的，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600963" alt="alt text" title="alt text" loading="lazy"/></p><p>所以，我们在创建密码记录时，需要考虑到<strong>Keepass</strong>的匹配机制，以便<strong>Keepass</strong>可以准确的找出我们需要的密码记录。例如你为百度账户创建密码记录时，如下的设置将更容易在百度各应用/平台上检索到本条密码记录：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600964" alt="alt text" title="alt text" loading="lazy"/></p><h2>键入规则</h2><p><strong>Keepass</strong>的默认自动键入规则为<strong>{USERNAME}{TAB}{PASSWORD}{ENTER}</strong>，解释如下👇：</p><ul><li><strong>{USERNAME}</strong> 表示输入输入用户名</li><li><strong>{TAB}</strong> 表示输入Tab键，表现行为是切换输入框</li><li><strong>{PASSWORD}</strong> 表示输入密码</li><li><strong>{ENTER}</strong> 表示按下回车键</li></ul><p>这个默认的输入行为，并不适合所有的用户。例如对于中文用户而言，在输入用户名和密码前，需要先切换输入框到英文状态，然后再启动输入动作，另例如对于有些页面或者应用程序（如QQ），则需要在输入完用户名密码后，要勾选用户协议方可进行登录。针对这些情况，本人使用的输入规则如下👇：  <br/><strong>+{DELAY 100}{CLEARFIELD}{USERNAME}{TAB}{PASSWORD}+</strong>  或者<br/><strong>^{SPACE}{DELAY 100}{CLEARFIELD}{USERNAME}{TAB}{PASSWORD}^{SPACE}</strong></p><p>解释如下👇：</p><ul><li><strong>+</strong> 表示输入<strong>Shift</strong> 键（对于Windows用户而言，<strong>Shift</strong>键用于切换输入法状态</li><li><strong>{DELAY 100}</strong> 表示等待100毫秒，输入<strong>Shift</strong>后停顿一下，等待系统响应</li><li><strong>{CLEARFIELD}</strong> 表示清空输入框，用于清空当前所在输入框的贼内容（第一个输入框是〔用户名〕输入框）</li><li><strong>{USERNAME}</strong> 表示输入输入用户名</li><li><strong>{TAB}</strong> 表示输入Tab键，表现行为是切换输入框</li><li><strong>{PASSWORD}</strong> 表示输入密码</li><li>最后一个 <strong>+</strong> 号，表示在完成键入后，将输入法状态还原</li></ul><p>注意点如下👇：</p><ul><li>这条规则最后没有了<strong>{ENTER}</strong>，最后的 <strong>Enter</strong>键由用户在勾选了用户协议后（如果有）再按下。</li><li>光标位置〔用户名〕输入框内时，确保输入法状态为<strong>中文</strong>，然后再启动<strong>Keepass</strong></li><li>如果你发现在键入时，输入法没有能成功的切换中英状态，你可以试一下把 <strong>+</strong> 换成 <strong>^{SPACE}</strong>，其中 <strong>^</strong> 表示 <strong>Ctrl</strong> 键，<strong>{SPACE}</strong> 表示空格键，这个组合可以切换输入法与非输入法。但需要使用哪个按键组合，需要根据你的电脑的相关设置而调整，如下👇：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600965" alt="alt text" title="alt text" loading="lazy"/></li></ul><h3>配置键入规则</h3><p>将上述键入规则配置到数据库中，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600966" alt="alt text" title="alt text" loading="lazy"/>  <br/>之后在该数据库中生成的密码记录将自动继承这个输入规则，除非你在添加记录时进行了额外的指定。</p><h3>关于〔双通道自动输入混淆〕</h3><p><strong>Keepass</strong>在键入用户名和密码时，是通过模拟按键进行键入的，那么如果你的电脑已经中毒，中了木马，他可以监视并获得你通过键盘键入的字符，那是不是<strong>Keepass</strong>键入的内容就被这个木马截获了？为了应对这个场景，<strong>Keepass</strong>支持在键入操作时，引入剪贴板渠道。意思就是说，<strong>Keepass</strong>将要输入的内容随机的截成n段，其中一部分通过模拟键盘键入，另一部分先放入粘贴板，然后再通过<strong>Ctrl+V</strong>粘贴到输入框中，这样木马程序只能观察到使用了<strong>Ctrl+V</strong>操作，但无法得知粘贴的内容，从而提高了密码键入的安全性。我们可以在创建密码时，在〔自动输入〕标签下的下方看到〔双通道自动输入混淆〕选项，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600967" alt="alt text" title="alt text" loading="lazy"/></p><p>👉注意，双通道键入模式，需要输入框支持<strong>Ctrl+V</strong>操作，并要求支持光标移动操作，但这两个操作并不是所有的平台的密码输入框都默认支持的，所以在使用〔双通道自动输入混淆〕功能时，请确保目标平台的密码框是支持以上操作的。</p><h2>一些基础的设置项</h2><p>为了更安全的使用<strong>Keepass</strong>，推荐您完成以下相关的设置项目（〔工具〕/〔选项〕），如下👇：</p><ul><li>[x] 〔安全〕/ 全局用户空闲如下时间后锁定主窗口：240</li><li>[x] 〔安全〕/ 剪贴板自动清空时间：12</li><li>[x] 〔安全〕/〔常规〕/ 锁定 Keepass -- 当锁定 Windows 或切换用户时</li><li>[x] 〔安全〕/〔常规〕/ 锁定 Keepass -- 当系统挂起时</li><li>[x] 〔安全〕/〔常规〕/ 锁定 Keepass -- 当远程控制模式改变时</li><li>[x] 〔高级〕/〔启动和退出〕/ 退出和锁定数据库时升上去保存</li><li>[ ] 〔高级〕/〔文件输入/输出链接〕/ 写入 数据库时全胜文件交换处理</li><li>[ ] 〔高级〕/〔高级〕/ 记住密匙源（密匙文件路径、提供者名称等...）</li><li>[x] 〔高级〕/〔高级〕/ 在安全桌布输入管理密码</li></ul><h2>层叠显示与平铺显示</h2><p>你可以通过设置〔显示〕/〔窗口布局〕来调整密码记录的显示方式，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600968" alt="alt text" title="alt text" loading="lazy"/></p><p>层叠显示效果如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600969" alt="alt text" title="alt text" loading="lazy"/>  <br/>平铺显示效果如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600970" alt="alt text" title="alt text" loading="lazy"/></p><h2>密码生成规则</h2><p>当我们注册某一账户时，需要生成一个新的密码以供使用，<strong>Keepass</strong>在创建新的记录时，会自动的生成一个新的密码以供我们注册时使用，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600971" alt="alt text" title="alt text" loading="lazy"/>  <br/>这是一个20位的由数字和字母组成的随机密码，但是并非所有的平台都支持20位这么长的密码长度，也有很多的平台要求密码必须包含特殊字符，所以这个随机密码的适应性不能满足一些要求。我们调整随机密码的生成规则如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600972" alt="alt text" title="alt text" loading="lazy"/></p><p>经过以上设置之后，我们在新建记录时，<strong>Keepass</strong>便可以根据我们刚才的设置规则生成新的随机密码了，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600973" alt="alt text" title="alt text" loading="lazy"/></p><h2>webDav(坚果云网盘)同步</h2><p>在电子设备普及的今天，几乎每个人都不止一个电脑+手机。如何在这么多的设备上共享密码信息呢？这里我们分享一个通过webDav同步<strong>Keepass</strong>数据库的方法，该方法来自<a href="https://link.segmentfault.com/?enc=nfqLlkt4N35PWrKjcqSefQ%3D%3D.bu%2BV6ocG%2BbJhFTcXMclk7VXcSv08I1cblAJffhcqmy0hDcLw0el9Ibi%2Bbf1Ki1lp" rel="nofollow" target="_blank">Keepass：多平台密码无缝同步</a>。</p><h3>准备坚果云</h3><ul><li>首先，我们需要有一个坚果云账号（免费的就行），您可以<a href="https://link.segmentfault.com/?enc=Q0Yia5B4B5BPj8viFtELcQ%3D%3D.%2BKUAd5jPIYxhPA93MNbYDGkwFs6WJ98kjA%2BKKDuwcdk%3D" rel="nofollow" target="_blank">👉在这里注册</a></li><li>然后，你需要在坚果云空间里创建一个〔keepass〕文件夹，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600974" alt="alt text" title="alt text" loading="lazy"/></li><li>然后，把你本地的<strong>Keepass</strong>的数据库文档（.kdbx文档）上传到这个坚果云的〔keepass〕文件夹内，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600975" alt="alt text" title="alt text" loading="lazy"/></li><li>然后，在坚果云上添加一个〔keepass〕应用，记下你的应用地址、账户名称和应用密码。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600976" alt="alt text" title="alt text" loading="lazy"/></li></ul><p>坚果云端完成以上设置即可。</p><h3>使用Keepass触发器触发webDav同步</h3><ul><li>按下图修改下面的<strong>Keepass</strong>触发脚本，然后复制修改完成后的脚本文本备用  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600977" alt="alt text" title="alt text" loading="lazy"/></li></ul><pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;TriggerCollection xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
&lt;Triggers&gt;
&lt;Trigger&gt;
&lt;Guid&gt;L2euC7Mr/EKh7nPjueuZvQ==&lt;/Guid&gt;
&lt;Name&gt;SaveSync&lt;/Name&gt;
&lt;Events&gt;
&lt;Event&gt;
&lt;TypeGuid&gt;s6j9/ngTSmqcXdW6hDqbjg==&lt;/TypeGuid&gt;
&lt;Parameters&gt;
&lt;Parameter&gt;1&lt;/Parameter&gt;
&lt;Parameter&gt;kdbx&lt;/Parameter&gt;
&lt;/Parameters&gt;
&lt;/Event&gt;
&lt;/Events&gt;
&lt;Conditions /&gt;
&lt;Actions&gt;
&lt;Action&gt;
&lt;TypeGuid&gt;tkamn96US7mbrjykfswQ6g==&lt;/TypeGuid&gt;
&lt;Parameters&gt;
&lt;Parameter&gt;SaveSync&lt;/Parameter&gt;
&lt;Parameter&gt;0&lt;/Parameter&gt;
&lt;/Parameters&gt;
&lt;/Action&gt;
&lt;Action&gt;
&lt;TypeGuid&gt;Iq135Bd4Tu2ZtFcdArOtTQ==&lt;/TypeGuid&gt;
&lt;Parameters&gt;
&lt;Parameter&gt;https://dav.jianguoyun.com/dav/keepass/xxx.kdbx&lt;/Parameter&gt;
&lt;Parameter&gt;userName@xxx.com&lt;/Parameter&gt;
&lt;Parameter&gt;userPwd&lt;/Parameter&gt;
&lt;/Parameters&gt;
&lt;/Action&gt;
&lt;Action&gt;
&lt;TypeGuid&gt;tkamn96US7mbrjykfswQ6g==&lt;/TypeGuid&gt;
&lt;Parameters&gt;
&lt;Parameter&gt;SaveSync&lt;/Parameter&gt;
&lt;Parameter&gt;1&lt;/Parameter&gt;
&lt;/Parameters&gt;
&lt;/Action&gt;
&lt;/Actions&gt;
&lt;/Trigger&gt;
&lt;/Triggers&gt;
&lt;/TriggerCollection&gt;</code></pre><ul><li>复制了触发器脚本后，将触发器配置到<strong>Keepass</strong>中，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600978" alt="alt text" title="alt text" loading="lazy"/></li><li>然后在<strong>Keepass</strong>界面按下<strong>Ctrl+S</strong>键，在<strong>Keepass</strong>下的状态栏中应该能看到webDave的同步过程及结果，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600979" alt="alt text" title="alt text" loading="lazy"/></li><li>关于连接，用户名，密码，也可以后期再调整，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600980" alt="alt text" title="alt text" loading="lazy"/></li></ul><h2>插件</h2><p><strong>Keepass</strong>的强大，离不开众多插件的支持。<strong>Keepass</strong>官网提供了数量众多，功能丰富的插件供用户下载使用，您可以前往<a href="https://link.segmentfault.com/?enc=8gI4JGx5Qp2FQjMFbMQtsQ%3D%3D.XyDbCvv2gKRZ0qhMnCjGnKn1Al%2BuKx51fGJVKIy2JfAkRRmhawZmMXVhsP7CWyk4" rel="nofollow" target="_blank">👉Keepass插件页面</a>下载您需要的插件。</p><h3>插件的安装</h3><p><strong>KeePass</strong>插件的安装非常之简单，当您下载了<strong>Keepass</strong>插件后，将其解压后即可得到 .plgx 文档以及 Readme.txt文档，我们将得到的 .plgx 文档放入<strong>Keepass</strong>目录的<strong>Plugins</strong>文件夹，然后<strong>重启 Keepass</strong>即可加载插件，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600981" alt="alt text" title="alt text" loading="lazy"/></p><p>你可以通过<strong>Keepass</strong>来找到并打开<strong>Plugins</strong>文件夹，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600982" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★★ SourceForgeUpdateChecker</h3><p><a href="https://link.segmentfault.com/?enc=OsEPATP7OGuiFM4jDgnDXA%3D%3D.aM%2FNPBHmWec5a3ybDoiLYRCETReUp3k1z4%2Bpa75iKZ%2FnJLrOPQ5u8s27PfYXqZoD0I5p0Pcnliy%2F4e4q8Dl1tg%3D%3D" rel="nofollow" target="_blank">SourceForgeUpdateChecker-v0.4.zip 🐕度提取码: hqgh</a></p><p>这是一个维护插件的插件。<strong>Keepass</strong>有着众多的插件，丰富的插件为我们提供了丰富的功能体验。但是这些插件是否有更新，我们无从得知；而<strong>SourceForgeUpdateChecker</strong>正是为了解决这个问题而开发的，它可以帮助我们检测我们所使用的插件是否有更新，以便我们可以及时的更新我们的插件，及时的体验新的功能和修复程序漏洞。</p><p>插件安装完成后，<strong>重启 Keepass</strong>，即可以通过〔帮助〕/〔检查更新〕来查阅各插件是否有更新版本，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600983" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★☆☆☆ KPEntryTemplates</h3><p><a href="https://link.segmentfault.com/?enc=AHMYXXfVbg1hxi60WG6o2w%3D%3D.LvwmaqD%2FBNOAbUh1uFMTZ6BYp55N7Y18sfkeuuLMHoUKntrw6wBMdLtH5OZ5%2FrnYgZutSAhkMHTm1m7osfjt4g%3D%3D" rel="nofollow" target="_blank">KPEntryTemplates.plgx 8.0 🐕度提取码: yrsf</a></p><p>当你在<strong>Keepass</strong>中添加一条密码记录时，默认情况下你应该看到的操作界面如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600984" alt="alt text" title="alt text" loading="lazy"/></p><p><strong>KPEntryTemplates</strong>模板插件可以让我们定义密码记录的录入字段和键入规则，以我们使用起来更加的方便。</p><p>虽然如此，但是在实际使用场景下，该模板的用武之地并不多，大家可以根据自己的需求决定是否添加了。</p><h4>在群组中启用模板功能</h4><p>在数据库的常规组中启用模板功能，操作如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600985" alt="alt text" title="alt text" loading="lazy"/></p><h4>配置 用户名-密码 模板</h4><p><strong>用户名-密码</strong>模板用于记录通过<strong>用户名</strong>+<strong>密码</strong>进行登录的密码记录。操作如下👇：</p><ul><li>选中〔常规〕群组，添加记录，设置标题和默认用户名，设置键入模式：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600986" alt="alt text" title="alt text" loading="lazy"/></li><li>初始化并添加需要的记录字段：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600987" alt="alt text" title="alt text" loading="lazy"/></li><li>于是，我们便得到了一个我们自定义的录入模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600988" alt="alt text" title="alt text" loading="lazy"/></li><li>我们可以在我们新建记录时，使用该模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600989" alt="alt text" title="alt text" loading="lazy"/></li></ul><p>是不是比默认的录入模板要方便好用多了？</p><h5>使用选项</h5><p>实际上，我们的电话和邮箱一般来说都是有限的，也就是说我们常用的手机和邮箱也就那么几个，每次都要手动键入手机号和邮箱号未免麻烦了。<strong>KPEntryTemplates</strong>为我们提供了<strong>ListBox</strong>字段选项，对于〔手机〕和〔邮箱〕字段，我们可以按配置如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600990" alt="alt text" title="alt text" loading="lazy"/></p><p>然后我们创建密码记录时，就可以选择〔手机〕和〔邮箱〕了，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600991" alt="alt text" title="alt text" loading="lazy"/></p><h4>配置 手机-密码 模板</h4><p><strong>手机-密码</strong>模板用于记录那些可以通过手机+密码登记的密码项目。操作如下👇：</p><ul><li>选中〔常规〕群组，添加记录，设置标题和默认用户名，设置键入模式：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600992" alt="alt text" title="alt text" loading="lazy"/></li><li>初始化并添加需要的记录字段：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600993" alt="alt text" title="alt text" loading="lazy"/></li><li>于是，我们便得到了一个我们自定义的另一个录入模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600994" alt="alt text" title="alt text" loading="lazy"/></li><li>我们可以在我们新建记录时，使用该模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600995" alt="alt text" title="alt text" loading="lazy"/></li></ul><h4>配置 邮箱-密码 模板</h4><p><strong>邮箱-密码</strong>模板用于记录那些可以通过邮箱+密码登记的密码项目。操作如下👇：</p><ul><li>选中〔常规〕群组，添加记录，设置标题和默认用户名，设置键入模式：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600996" alt="alt text" title="alt text" loading="lazy"/></li><li>初始化并添加需要的记录字段：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600997" alt="alt text" title="alt text" loading="lazy"/></li><li>于是，我们便得到了一个我们自定义的另一个录入模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600998" alt="alt text" title="alt text" loading="lazy"/></li><li>我们可以在我们新建记录时，使用该模板：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047600999" alt="alt text" title="alt text" loading="lazy"/></li></ul><h4>作为补充</h4><p>各个平台对于密码的要求千奇百怪，我们很难完全预料到所有的记录需求场景；或者如果尽可能的覆盖各种各样的排列组合的话，我们的模板将变得繁多又复杂，所以对于模板的设计，我们应该保持有所克制，抽取必要的，最大化的需求制作模板，而对于小众的，我们通过〔高级〕标签下的〔自定义字串段〕来添加额外的字段及对应值，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601000" alt="alt text" title="alt text" loading="lazy"/>  <br/>或者我们可以通过下文介绍的插件<strong>KPEnhancedEntryView</strong>录入，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601001" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★★ KPEnhancedEntryView</h3><p><a href="https://link.segmentfault.com/?enc=mPuwloJHeuCWsb7lT8IeGQ%3D%3D.qB6eOkvmiXBp1rqJYZe3zqqLR%2Fit7P%2BIQS%2BQSQaf%2BT2NVQ4pX%2FsyEeYSuQshUDOmV8yUff46ucSLC9UhMwYB2g%3D%3D" rel="nofollow" target="_blank">👉KPEnhancedEntryView-v2.7.1.zip 🐕度提取码：2hrw</a></p><p><strong>KPEnhancedEntryView</strong>插件可以使我们更方便的使用<strong>Keepass</strong>，它允许我们👇：</p><ul><li>记录内容分类展示</li><li>在主界面直接编辑修改字段的值</li><li>添加额外的字段</li><li>通过快捷键<strong>F9</strong>在主界面显示/隐藏密码值<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601002" alt="alt text" title="alt text" loading="lazy"/></li></ul><p>为了达到使用<strong>KPEnhancedEntryView</strong>的最佳效果，请在〔工具〕/〔列设置〕中只保留显示〔标题〕和〔用户名〕两个，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601003" alt="alt text" title="alt text" loading="lazy"/></p><p>食用效果如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601004" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★☆ AutoTypeSearch</h3><p><a href="https://link.segmentfault.com/?enc=mSIsNf%2Ffg2bZ4skelAqI%2Fw%3D%3D.RU5fK1NE1rtkxclNicM%2BnXW59pN7LsmR9lx5rAMgxDiQn%2B4SpNI98H6TPBaIn3HHspsDLv8ewfg2utTy1Jz53Q%3D%3D" rel="nofollow" target="_blank">👉AutoTypeSearch-v1.6.zip 🐕度提取码: z5bx</a></p><p>如果<strong>Keepass</strong>未能自动匹配到密码记录，你可以通过本插件定义的快捷键呼出<strong>Keepass</strong>的搜索框，以便搜索你的密码库。</p><p>你可以在〔选项〕中对<strong>AutoTypeSearch</strong>进行有关设置，定义您的快捷键。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601005" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★★ KeePassNatMsg</h3><p><a href="https://link.segmentfault.com/?enc=vZXLJc7IMKOCrEOrydzesw%3D%3D.%2F1RH7lRvFFG4hxWw9EdNRrOd6a6%2BHvOTEMDEs3bX22IxE3Oa9fYmWJLbK4Zwv0jdu0LkN5JxH%2Bf9usDXbIOoAg%3D%3D" rel="nofollow" target="_blank">KeePassNatMsg.plgx v2.0.17 🐕度提取码: p4kk</a></p><p><strong>KeePassNatMsg</strong>是在基于<strong>KeePassHttp</strong>插件的基础上发展而来，实现了一种通过本机消息传递机制（Native Messaging）将<strong>KeePass</strong>的凭据提供给浏览器使用的安全方法。</p><ul><li>安装好<strong>KeePassNatMsg</strong>插件后，即可设置<strong>KeePassNatMsg</strong>的配置项，包括安装浏览器消息机，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601006" alt="alt text" title="alt text" loading="lazy"/>  <br/>👉特别的，如果你使用的是<strong>Vivaldi</strong>浏览器，你应该额外勾选〔<strong>Chromium</strong>〕，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601007" alt="alt text" title="alt text" loading="lazy"/><br/>👉如果顺利，浏览器消息机安装成功应该收到如下的弹窗：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601008" alt="alt text" title="alt text" loading="lazy"/>  <br/>👉意外，如果你收到如下弹窗，说明你的网络无法连接到<strong>gitHub</strong>服务器，你可能需要科学上网：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601009" alt="alt text" title="alt text" loading="lazy"/></li></ul><h3>★★★★★ KeePassXC-Browser</h3><p><a href="https://link.segmentfault.com/?enc=L%2Bh8BRMZByjvWP24BL8nog%3D%3D.o63eJETx4%2FGastwWtzlWFhE5Vc8oX%2BPbe6gRg5SFy8WvHxW0YrxEegvtZb66%2BDObAcetmWnyWhF6I3VzemmZdw%3D%3D" rel="nofollow" target="_blank">keepassxc-browser_1.9.11_chromium.zip 🐕度提取码: rpuy</a></p><p><strong>KeePassXC-Browser</strong>是运行在浏览器中的一个插件，它可以通过<strong>KeePassNatMsg</strong>查询使用<strong>Keepass</strong>中的密码数据。</p><p>👉你可以将<strong>zip</strong>解压后，通过浏览器加载<strong>KeePassXC-Browser</strong>插件，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601010" alt="alt text" title="alt text" loading="lazy"/></p><p>👉你也可以在Google商店中找到并安装<strong>KeePassXC-Browser</strong>插件，将其添加到你的浏览器中，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601011" alt="alt text" title="alt text" loading="lazy"/></p><p>👉插件安装完成后，点击插件图标，即可设置与<strong>Keepass</strong>的连接，在<strong>Edge</strong>浏览器中的设置过程如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601012" alt="alt text" title="alt text" loading="lazy"/>  <br/>在<strong>Vivaldi</strong>浏览器中的设置过程如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601013" alt="alt text" title="alt text" loading="lazy"/></p><p>👉我们可以在浏览器中配置<strong>KeePassXC-Browser</strong>的填充快捷键，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601014" alt="alt text" title="alt text" loading="lazy"/></p><p>👉然后，当你浏览网页时，如果<strong>KeePassXC-Browser</strong>检测到有匹配的密码输入场景时，便会添加<strong>KeePassXC-Browser</strong>标识，只需要鼠标一点就可以自动填充了。如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601015" alt="alt text" title="alt text" loading="lazy"/></p><p>👉相反，如果某一个网页中存存密码输入场景，但是未检索到有效的密码记录时，<strong>KeePassXC-Browser</strong>会显示灰色的图标，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601016" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★☆ WebAutoType</h3><p><a href="https://link.segmentfault.com/?enc=jNcHX8aVkfT0E1m%2B4ZXGCA%3D%3D.3M2qTkaVlvUdB9NX%2B0BWRTPSSWDWtAT6ykHUeWzGdC52LsIL%2FBIM7QIkn0uJ74YXHVK81J3bLvC22OREY5dDUA%3D%3D" rel="nofollow" target="_blank">👉WebAutoType-v6.9.1.zip 🐕度提取码: rssu</a></p><p>这个插件可以让你在网页中唤出<strong>Keepass</strong>的添加记录对话框，它可以自动的帮你填入一些信息，例如<strong>url</strong>，例如标题等，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601017" alt="alt text" title="alt text" loading="lazy"/></p><p>👉你可以为<strong>WebAutoType</strong>设置中意的快捷键，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601018" alt="alt text" title="alt text" loading="lazy"/></p><h3>★★★★☆ RDCAutoTypeAndTCATO</h3><p><a href="https://link.segmentfault.com/?enc=otU0Wk68h3mvYz9WF5RcIA%3D%3D.RhyBTmCIhiBPGgvcBRn20bqiG1JdlwzQhoBEBaSFguLAHaIww%2F%2BjzXxXtNjVwDpijE0HnVvWEgE07DCo%2B4zspA%3D%3D" rel="nofollow" target="_blank">RDCAutoTypeAndTCATO.plgx 🐕度提取码: a7hg</a></p><p><strong>RDCAutoTypeAndTCATO</strong>可以在不支持钩子的场景下使用，例如对于&lt;font color=red&gt;<strong>QQ</strong>这种。</p><p>安装插件后，我们需要在<strong>RDCAutoTypeAndTCATO</strong>的<strong>ProgramList</strong>中添加<strong>QQ.exe</strong>，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601019" alt="alt text" title="alt text" loading="lazy"/></p><p>然后就可以在<strong>QQ</strong>登录界面顺利的通过<strong>Keepass</strong>填充用户名和密码了。</p><p>💣 注意，由于<strong>RDCAutoTypeAndTCATO</strong>的输入过程不需要通过系统输入法，所以在其输入规则中不需要使用如下的键入规则：  <br/><strong>^{SPACE}{DELAY 100}{CLEARFIELD}{USERNAME}{TAB}{PASSWORD}^{SPACE}</strong></p><p>你需要在通过<strong>RDCAutoTypeAndTCATO</strong>键入的密码条目中，调整输入规则为：  <br/><strong>{CLEARFIELD}{USERNAME}{TAB}{PASSWORD}</strong>  <br/>否则可能会因为键入了多余的字符而导致密码键入错误，登录失败。</p><h3>★★★☆☆ YetAnotherFaviconDownloader</h3><p><a href="https://link.segmentfault.com/?enc=qa7S03uTExGbEo%2B0%2BneMpw%3D%3D.ujszdPxbCPmHDOw79FA1XwOuni2ubQZIbZ%2Bg4J1NYEHQdg56lg9UNc2juCu6hH7S7YMxlYowFlT%2F0efng1eulA%3D%3D" rel="nofollow" target="_blank">👉YetAnotherFaviconDownloader.plgx v1.2.5.0 🐕度提取码: memu</a></p><p>这个插件提供的是一个锦上添花的功能，它可以帮助我们🈯批量的把密码记录项的图标设置为对应<strong>url</strong>网站的<strong>Favicon</strong>图标，从而美华我们的密码记录项。</p><p>插件安装后，你可以进行一些必要的设置，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601020" alt="alt text" title="alt text" loading="lazy"/></p><p>然后选中你要更新图标的密码记录条目，右键，如下👇：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601021" alt="alt text" title="alt text" loading="lazy"/></p><h2>小结</h2><p>以上便是本次安装配置<strong>Keepass v2.60</strong>的整个过程，欢迎交流讨论。</p>]]></description></item><item>    <title><![CDATA[Qnap威联通Qu405的入手配置手记 三块钱 ]]></title>    <link>https://segmentfault.com/a/1190000047601115</link>    <guid>https://segmentfault.com/a/1190000047601115</guid>    <pubDate>2026-02-09 13:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>我的硬件</h2><h3>NAS型号</h3><p>威联通 Qu405 四盘位</p><h3>硬盘 HDD/SSD</h3><ul><li>WD40EFZZ 西数红盘 4T 2块</li><li>PM863a SSD 960G 2块</li></ul><h3>UPS电源</h3><p>cyberpower UT650EGC</p><h2>硬件组装</h2><p>根据收到的NAS所带的说明书，将你的硬盘和SSD安装到你的NAS中。</p><p>完成组装后，用网线将你的NAS与路由连接。</p><h3>连接UPS，启动NAS</h3><ul><li>将UPS电脑接入市电插座</li><li>将NAS电脑接入UPS的输出端插孔位置</li><li>使用UPS自带的USB数据线连接UPS和NAS</li><li>根据UPS说明书的操作说明，启动UPS电源</li><li>根据NAS说明书的操作说明，启动NAS。</li><li>等待一段时间，NAS上线</li></ul><h2>系统设置</h2><h3>找到NAS</h3><p>NAS第一次上电后，一般会通过路由器自动分配一个IP地址联网，此时要想登录NAS的界面，你需要使用Qnap提供的软件 <strong>Qfinder</strong>，您可以在<a href="https://link.segmentfault.com/?enc=R4%2BfBfpBxp3%2FJ0uEAXVHcA%3D%3D.EkxarI9oyhYtPkoITY8yg6HVGggjpMrOwtrFLa5vxrjQ9PDucFVS21RBlDsHMwl%2B" rel="nofollow" target="_blank">这里下载安装👇</a>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601118" alt="alt text" title="alt text"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601119" alt="alt text" title="alt text" loading="lazy"/>  <br/>打开<strong>Qfinder</strong>后，它可以自动搜索你当前局域网下的Qnap设备，找到您的NAS，即可登入，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601120" alt="alt text" title="alt text" loading="lazy"/></p><p>第一次登录NAS时，一般系统会引导你完成一些必要的系统设置，例如对于Qu405来说，会引导你选择安装QTS系统或者是QuTS系统，我选择的是QTS系统。</p><h2>UPS联动</h2><p>当我们找到我们的NAS，并进入NAS界面后，我们前往〔控制台〕/〔系统〕/〔外部设置〕/〔UPS〕，完成USP联动设置，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601121" alt="alt text" title="alt text" loading="lazy"/></p><h2>设置存储池和存储卷</h2><h3>创建Qtier存储池</h3><p>Qtier技术是Qnap独创的冷热数据分层存储融合技术，最大化的充分利用了SSD和HDD硬盘的效率。它可以将高频访问的热数据存储在SSD区，将不常访问的冷数据放在HDD存储区。相对于SSD缓存来说，Qtier技术可以将SSD的空间纳入到存储池中，避免了SSD空间的浪费。更为详细的关于SSD缓存方案和Qtier方案的对比分析，参考<a href="https://link.segmentfault.com/?enc=l%2FB3ke7fsc%2BVVBgDMWhtqQ%3D%3D.RCnItvXxvP1gD0tbGoLEcsbxf%2B%2BTxZvo5za1%2FAhZSTDJAdOI39Ws%2FchhyJ0x%2BOA6zTT876mfNAytJkslY6slYVSof1QAkmbO9JE0%2FQIFqHdkWExAIKjtwphKyCCcf2lb" rel="nofollow" target="_blank">Qnap官网的说明</a>。</p><p>就我本次的配置来说，将两块SSD配置为超高速层，组RAID1阵列，并保留了25％的容量空间；将两块HDD硬盘组RAID1阵列，做为容量层，保留20%的快照空间；报警阈值设置为90％。配置完成如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601122" alt="alt text" title="alt text" loading="lazy"/></p><h3>创建App精简卷〔系统卷〕</h3><p>首先创建的卷，会被系统自动识别为系统卷，将来NAS安装的应用，会默认安装于此卷。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601123" alt="alt text" title="alt text" loading="lazy"/></p><p>在Qtier存储池上，创建一个容量为200G的精简卷（后期根据需要可以增加），该卷主要用于供系统使用，用于安装应用程序，不要在这里存放用户的数据。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601124" alt="alt text" title="alt text" loading="lazy"/></p><h3>创建Data精简卷</h3><p>在Qtier存储池上，创建一个容量为1T的精简卷（后期根据需要可以增加），该卷主要用于存放各种资料数据，相当于用户的云空间。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601125" alt="alt text" title="alt text" loading="lazy"/></p><h3>创建Home精简卷</h3><p>在Qtier存储池上，创建一个容量为100G的精简卷（后期根据需要可以增加），该卷主要用于存放各用户的Home目录，主要目的是为用户提供一个临时的云端空间，以供临时性的转移文件使用，这个卷不启用快照功能。</p><p>👆以上Qtier存储池和三个存储卷设置完成后，效果如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601126" alt="alt text" title="alt text" loading="lazy"/></p><h2>快照计划</h2><p>完成卷设置后，为需要的卷配置合理的快照计划，可以有效的保障数据安全（必要时回滚，&lt;font color=gray&gt;一个具体的例子是，如果你本地的文件被病毒破坏了，而你的同步工具又将已经被破坏了的文件同步到了NAS上，此时如何恢复这个文件呢？就只能通过快照来恢复了&lt;/font&gt;）。选中需要配置快照的卷，然后点〔快照〕/〔快照管理员〕，即可对该卷的快照计划进行配置。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601127" alt="alt text" title="alt text" loading="lazy"/></p><h3>App卷快照计划</h3><p>App卷主要用于安装系统应用程序，为了防止在折腾过程中把系统玩崩，所以有必要启用快照功能。一般来说，在折腾NAS应用时，最好的习惯就是手动创建快照，然后再折腾。不过快照计划也为手残党提供了最后的兜底保障。考虑到一般会在周未折腾NAS，所以在每周折腾完成后，在周一的凌晨创建一次快照即可（保存折腾的成果）。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601128" alt="alt text" title="alt text" loading="lazy"/></p><h3>Data卷快照计划</h3><p>数据算是NAS使用的主要目的了，所以数据卷的快照是有必要的，所以我们为数据卷的快照设置每天1个，保留7天.如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601129" alt="alt text" title="alt text" loading="lazy"/></p><h3>Home卷快照计划</h3><p>根据以上分析，我们不为Home卷起用快照，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601130" alt="alt text" title="alt text" loading="lazy"/></p><h3>设置用户家目录</h3><p>如上， 我们为用户家目录单独创建了Home卷，现在我们统一设置用户家目录配置到Home卷，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601131" alt="alt text" title="alt text" loading="lazy"/></p><h2>外网访问</h2><p>网络是NAS的基础，否则您只能在您家的局域网内使用NAS，这无异于龙游浅池。</p><p>如果你想在公网访问你的Qnap设备，你首先需要有一个公网IP，你可以向你的电信运营商申请要求给你分配一个公网IP，一般来说，这个IP是隔段时间变化的，但是这不要紧。</p><p>有了公网IP的前提后，Qnap提供了免费的DDNS服务，你只需要以下设置，便可以在公网环境使用你的NAS设备。</p><ul><li>找到NAS上的网络设置  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601132" alt="alt text" title="alt text" loading="lazy"/></li><li>找到设定，设置静态IP，为你的Qnap设备设置一个静态IP，记住这个IP，后面要用  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601133" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601134" alt="alt text" title="alt text" loading="lazy"/></li><li>设置系统访问端口，和服务器名称，记住这个端口号和名称，后面要用  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601135" alt="alt text" title="alt text" loading="lazy"/></li><li>设置路由器的端口转发规则，设置你的路由器，将来自外部的请求转发给你的Qnap设备。这里的局域网IP就是你的NAS上设置的静态IP，这里的内部端口就是你NAS上设置的系统访问端口参考上文  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601136" alt="alt text" title="alt text" loading="lazy"/></li><li>设置myQNAPcloud云服务，使用Qnap提供的DDNs功能，解析你的公网IP  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601137" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601138" alt="alt text" title="alt text" loading="lazy"/>  <br/>DDNs开通后，会生成一个免费的二级域名，样式如： www.服务器名称.mycloudnas.com，将来你可以通过该域名来访问你的Qnap设备。</li><li>完成以上设置后，便可以测试你的DDNs是否连通了。在DDNS设置页面的底部，点击【测试连接性】，观测域名是否能成功连接到Qnap设备。👇如下可以看到系统访问端口可以连通到Qnap了。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601139" alt="alt text" title="alt text" loading="lazy"/></li><li>做为测试，你可以将你的手机切换为非wifi模式，输入您的DDNS域名和端口号，便可以打开NAS页面（由于一些原因，在大陆使用Qnap的域名解析连接性不佳，有条件的还是建议自建DDNs服务）  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601140" alt="alt text" title="alt text" loading="lazy"/></li></ul><p>🚩 如果你无法打开NAS页面，或者收到 〔ERR_NAME_NOT_RESOLVED〕，那是因为你的网络环境无法连接到Qnap的DDNS服务器所致，原因嘛，大家都懂得。</p><h2>自建DDNS解析脚本</h2><p>除了上述通过Qnap二级域名实现外网访问外，我们还可以自己申请一级域名（一些冷门域名很便宜的，一次性买10年也不过百元级），然后我们在NAS上通过ddns-go脚本将我们的NAS的公网IP（实际应该是你的路由器的IP地址）更新到域名上，这样我们就可以通过我们自己的域名自由访问我们的NAS了。</p><p>ddns-go是一个运行于Docker里的镜像容器，我一直在使用不低于2年时间，稳定性是非常棒的。</p><h3>准备域名</h3><p>我是在阿里云上申请的域名。自己用嘛，不求闻达于诸侯，所以越便宜越好，能解析是唯一的要求。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601141" alt="alt text" title="alt text" loading="lazy"/></p><p>我使用的是免费套餐，在国内全胜基本没有遇到无法解析的情况，也可以根据自己的实际使用需求，开通付费套餐。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601142" alt="alt text" title="alt text" loading="lazy"/></p><h3>安装ContainerStation</h3><p>ContainerStation是Qnap NAS中运行Docker的平台，你可以在NAS中的AppCenter中找到并安装它。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601143" alt="alt text" title="alt text" loading="lazy"/></p><p>等ContainerStation安装完成后，我们便可以在里面运行我们需要的镜像包了。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601144" alt="alt text" title="alt text" loading="lazy"/></p><p>由于DockerHub在国内的访问性不佳，所以推荐在ContainerStation中添加阿里云Docker镜像地址，以提高Docker镜像的拉取速度。打开<a href="https://link.segmentfault.com/?enc=gj70VGIzk5WF2OcmFKlxog%3D%3D.GdEeokxGBl6UWYs5o2FQkYpQWKaXImEmoHZHpI7iqMk%3D" rel="nofollow" target="_blank">容器镜像服务</a>(需要登录你的账号，每个账号的镜像地址都是不一样的)，在👈左侧找到〔镜像工具〕/〔镜像加速器〕，复制加速器地址备用。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601145" alt="alt text" title="alt text" loading="lazy"/></p><p>然后打开ContainerStation，找到〔存储库〕，然后〔添加〕  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601146" alt="alt text" title="alt text" loading="lazy"/></p><h3>使用jeessy/ddns-go进行DDNS动态解析</h3><p>本人使用jeessy/ddns-go进行DDNS解析，ddns-go是一个开源在dockerHub上的docker镜像，大家可以在ContainerStation中从dockerHub提取该镜像，也可以在电脑上下载  <br/><a href="https://link.segmentfault.com/?enc=rL00ez6IGAAKsGM9Ts8E1Q%3D%3D.Ghy9Xetw49xvEixqeeNN5n%2FJ1s3BwE9Py%2BisUlijHqXy6EjxZd4OOLDCS7X17QfTvgXB8Q8d9xG%2FVzFmz6RsIw%3D%3D" rel="nofollow" target="_blank">👉ddns-go镜像文件（amd64 CPU）</a>  <br/><a href="https://link.segmentfault.com/?enc=8hlJYGBKUiXuX2YlZR4E9w%3D%3D.5wx4sA%2FKfW3JxnIKQPdrf8DzwGc9EhdEyrjTDObwHYg%2FxDtHkRyWw9KHSK%2FFQeMjmPX2bVgTF0PURNT7ujWzow%3D%3D" rel="nofollow" target="_blank">👉ddns-go镜像文件（arm CPU）</a>  <br/>然后导入到ContainerStation中使用。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601147" alt="alt text" title="alt text" loading="lazy"/></p><h4>生成容器</h4><p>ddns-go的镜像，相当于是可以运行的一个exe文件，我们现在需要把这个exe文件〔其实是docker镜像〕运行起来，就是说需要创建一个让镜像跑起来的容器。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601148" alt="alt text" title="alt text" loading="lazy"/></p><p>等待容器创建完成  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601149" alt="alt text" title="alt text" loading="lazy"/></p><p>在容器页面就可以看到已经在运行的ddns-go了  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601150" alt="alt text" title="alt text" loading="lazy"/></p><p>🚩 如果容器运行出现 exec /app/ddns-go: exec format error 这种错误，说明ddns-go与Qnap设备的CPU架构不兼容，你需要换一下ddns-go镜像。</p><h4>设置ddns-go参数</h4><p>在局域网环境下，在浏览器中打开你的NAS IP地址 + 端口号 9876（例如192.168.1.43:9876）, 就可以对ddns-go进行参数设置了：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601151" alt="alt text" title="alt text" loading="lazy"/></p><p>登录后，可以看到参数设置页面  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601152" alt="alt text" title="alt text" loading="lazy"/></p><p>👆上图中，点击〔创建 AccessKey〕即可跳转到对应dns服务商的AccessKey创建页面（可能需要登录），根据引导完成AccessKey创建后，将AccessKey ID和AccessKey Secret填回到本页面中  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601153" alt="alt text" title="alt text" loading="lazy"/></p><p>在IPV4设置一栏，把你申请到的域名填写到Domains中，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601154" alt="alt text" title="alt text" loading="lazy"/></p><p>翻到最下面，如果你有Webhook通道（例如可能在飞书中添加消息机器人，开通Webhook连接），那么你可以在这里设置Webhook通知，当IP变化时，通过Webhook向你发送通知消息。如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601155" alt="alt text" title="alt text" loading="lazy"/></p><p>对于飞书机器人，我用的RequestBody设置如下👇</p><pre><code class="json">{
    "msg_type": "post",
    "content": {
        "post": {
            "zh_cn": {
                "title": "Hi，你的公网IP变了",
                "content": [
                    [
                        {
                            "tag": "text",
                            "text": "IPv4地址：#{ipv4Addr}"
                        }
                    ],
                    [
                        {
                            "tag": "text",
                            "text": "域名更新结果：#{ipv4Result}"
                        }
                    ]
                ]
            }
        }
    }
}</code></pre><p>飞书上收到的消息如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601156" alt="alt text" title="alt text" loading="lazy"/></p><p>以上设置完成后，您的ddns应该已经可以正常解析更新了，在容器界面，选中ddns-go容器，观察其日志小黑窗口，应该有如下消息出现👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601157" alt="alt text" title="alt text" loading="lazy"/></p><p>至此，你可以通过以上设置，配合你的路由器的端口转发，你便可以通过域名：端口访问你的NAS设备了。你如你可以通过 www.zhsan.xyz:1234 访问到你的NAS。</p><h2>无密码登录</h2><p>你需要在移动端下载并安装APP &lt;font color=Green&gt;QNAP Authenticator&lt;/font&gt;，你可以在<a href="https://link.segmentfault.com/?enc=01IgCH8%2B5LS9lg%2F%2Banco3Q%3D%3D.9PggXIrWVkkQhzCVAvwUFU%2BUEz3wkUTmTPl2woXCCFu%2FtMx2%2F30g5wfXPL8fGmIk0rIIpo6%2B2T5umlSci1wKTQ%3D%3D" rel="nofollow" target="_blank">Qnap官网</a>下载到该APP：  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601158" alt="alt text" title="alt text" loading="lazy"/>  <br/>然后在您的NAS界面，找到〔登录和安全性〕，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601159" alt="alt text" title="alt text" loading="lazy"/>  <br/>根据引导设置无密码登录〔或者使用两步验证〕，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601160" alt="alt text" title="alt text" loading="lazy"/>  <br/>设置成功后，您将看到你的受权的设备如下👇<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601161" alt="alt text" title="alt text" loading="lazy"/>  <br/>🚩 在设置〔二次验证〕或者是〔无密码登录〕时，将有两个验证方式，一种是本地验证，一种是云端验证；</p><ul><li>〔本地验证〕是指在你的局域网中寻找识别NAS设备进行验证，这种验证方式只能当你的移动设备和NAS处于同一局域网时可用使用。</li><li><p>〔云端验证〕是指通过登录Qnap ID账号，从你的Qnap ID账号认证的设备列表中寻找识别NAS设备进行验证，这种验证方式不受局域网环境限制。但是这种验证方式需要具备以下条件：</p><ul><li>你的设备已经在Qnap ID中注册</li><li>你的NAS开通了DDNS服务，这将使得Qnap服务器可以找到并连接你的NAS设备</li></ul></li></ul><h2>HTTPS安全访问</h2><p>如果你需要在外网访问你的NAS设备，Https加密通信就是必要的。当你在外网访问你的NAS设备时，就像你在用手机和你的NAS设备通电话。</p><ul><li>如果你们使用http访问NAS，就像是你们的通话是明文通话，如果有坏人监听了你们的通话，那么他就知道你们说了什么，一旦让他监听到了你的NAS的用户名和密码，那他就可以通过这个用户名和密码登录到你的NAS，这与家里进了贼没有什么区别。</li><li>如果你们全胜https访问NAS，就像是你们的通话是用经过加密的暗语，你们的通话内容除了你们自己能懂之外，即使是被坏人监听到了，它也无法理解你们的通话内容，也就不会泄露秘密。</li></ul><p>为了全胜https通信，我们需要为https配置SSL证书，这个SSL证书的作用就是负责给https通信的内容进行加密。</p><h3>申请SSL证书</h3><p>一般来说，SSL证书需要付费（年付）使用，但是我们也可以获取到免费的测试用的SSL证书，这些免费的SSL证书的加密效果与付费的SSL证书的加密效果是一样的。</p><p>阿里云和腾讯云都提供限时免费的SSL证书以供测试使用，我的域名是在阿里云进行的解析，所以此处以阿里云的SSL证书申请为例来进行说明。</p><ul><li>登录<a href="https://link.segmentfault.com/?enc=GK42ZZL4Il%2FhmAejHtQc8A%3D%3D.OWQfGyOF8KcaYhgtP58zlIpr%2BtJ9c3xRxnMkld6arLXcZ8q%2FvgdZDLuFLnHXFlsFVaaorPM7dSdhFUocUcitfVx%2B6QMkzY4woIf8cHIN%2FLRApppOc3W7zJHqqgKuAEuZ" rel="nofollow" target="_blank">阿里云平台</a>，搜索 〔数字证书管理服务〕，然后〔登录控制台〕，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601162" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601163" alt="alt text" title="alt text" loading="lazy"/></li><li>购买免费SSL证书名额（每个账户每年有一次购买机会，一次买20个证书名额，一个名额用90天），如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601164" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601165" alt="alt text" title="alt text" loading="lazy"/></li><li>创建SSL并提交申请，根据下图填写必要的信息后，提交审核，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601166" alt="alt text" title="alt text" loading="lazy"/></li><li>验证域名，当你提交了SSL申请后，我们在SSL证书管理页面就可以看到我们提交SSL申请的记录了，此时我们需要验证一下我们的域名是否OK， 点击SSL申请记录右侧的〔验证〕按钮，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601167" alt="alt text" title="alt text" loading="lazy"/></li><li>在弹出的证书申请页中，我们找到第三步，点击〔验证〕按钮，等待验证完成后，显示“域名验证成功。。。。。”信息，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601168" alt="alt text" title="alt text" loading="lazy"/></li><li>等待SSL签发。做完以上步骤后，我们只需要等待域名签发就可以了，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601169" alt="alt text" title="alt text" loading="lazy"/></li><li>下载SSL证书，解压后备用，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601170" alt="alt text" title="alt text" loading="lazy"/></li></ul><h3>安装SSL证书</h3><p>我们申请到了SSL证书后，我们就需要将它安装到我们的NAS中，才能使用https访问我们的NAS。我们回到NAS页面，操作如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601171" alt="alt text" title="alt text" loading="lazy"/></p><p>然后等待证书导入完成即可，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601172" alt="alt text" title="alt text" loading="lazy"/></p><p>🚩<strong>注意，我们申请的SSL证书只有90天有效，过期后我们需要重新通过以上步骤申请新的SSL证书并导入。或者可以付费申请期限为1年的SSL证书，这样就可以自动延期了。</strong></p><h3>启用HTTPS访问</h3><p>以上工作完成后，我们便可以为我们的NAS启用HTTPS服务了。我们把https的端口号设置为12345（此处为举例），设置如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601173" alt="alt text" title="alt text" loading="lazy"/></p><h3>调整路由器端口映射</h3><p>在上图中，我们可以看到我们的NAS的系统端口有两个，一个是1234， 一个是1235。</p><ul><li>其中1235是https服务端口，这个端口的通信是加密的，是安全的。我们可以把这个端口曝露在公网上使用，我们在公网环境下，可以通过 <a href="https://link.segmentfault.com/?enc=BRyT4kktbp6pCFR%2BE6YVmg%3D%3D.NACV%2B4O70Ozijhf%2BaPeyNoQYzZilq18O%2BdJ9jC1QflE%3D" rel="nofollow" target="_blank">https://www.zhangsan.xyz:1235</a> 来以https方式访问我们的NAS。</li><li>其中1234是http服务端口，这个端口的通假是没有加密的，是不安全的。所以我们不能把这个端口曝露在公网上，这个端口只可以在局域网环境下访问NAS。</li></ul><p>综合以上，我们需要在我们的路由口中调整端口映射规则，只把端口1235映射曝露到公网上，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601174" alt="alt text" title="alt text" loading="lazy"/></p><h2>关于公网安全</h2><ul><li><h3>公网端口</h3></li></ul><p>默认的NAS端口一般是5000,或者5001,这也是黑客重点扫描的NAS端口，建议大家在设置外网端口时，避开这两个端口。</p><ul><li><h3>Telnet/SSH</h3></li></ul><p>这两个功能，不要曝露在公网，如果不使用，也不要打开，如果要用，用完记得关闭<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601175" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>禁用admin账户</h3></li></ul><p>不要使用（禁用）NAS默认的管理员账户，这个一般NAS系统是默认禁用的<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601176" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>开启登录两步验证</h3></li></ul><p>进一步提高NAS页面的登录安全性  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601177" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>关闭UPnp服务</h3></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601178" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>关闭Bonjour服务</h3></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601179" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>启用IP防护</h3></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601180" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h3>启用账户防护</h3></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601181" alt="alt text" title="alt text" loading="lazy"/></p><ul><li><h4>关闭IPV6</h4></li></ul><p>如果你有了IPV4的公网IP，则通过IPV4即可访问NAS，此时关闭IPV6有助于提高NAS的安全性，尤其避免在域名解析中解析IPV6<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601182" alt="alt text" title="alt text" loading="lazy"/></p><h2>Qsync文件同步</h2><p>Qnap提供的Qsync文件同步技术，是一个非常好用，也总是被忽略的技术。尤其是Qsync提供的节省空间模式，让用户可以在存储空间较小的电脑上，也能处理NAS上的海量文档。</p><h3>NAS安装Qsync</h3><p>为了使用Qsync功能，我们需要在NAS上安装Qync服务端，我们在AppCenter中寻找并安装Qsync，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601183" alt="alt text" title="alt text" loading="lazy"/></p><p>Qsync安装完成后，我们可以打开Qsync，为共享文件夹授予使用权限，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601184" alt="alt text" title="alt text" loading="lazy"/></p><h3>电脑端安装Qsync</h3><p>在你需要同步文件的电脑上，也需要安装Qsync客户端，这样Qsync就可以帮我们同步电脑-NAS两端的文件了。你可以<a href="https://link.segmentfault.com/?enc=J8Qzi8ZxjC5jCkIHcv64BQ%3D%3D.CwWO%2FFBVeB2Ac%2BqgL8j%2Bb77pa5okD7vxUUi%2FUsC9FxpNJB5YIaO90Lt5rIAzj%2Fpd39aq8jtuDAKjjRQW%2BNP4qw%3D%3D" rel="nofollow" target="_blank">👉在这里下载到Qsync</a>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601185" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601186" alt="alt text" title="alt text" loading="lazy"/></p><p>Qsync下载安装完成后，你可以在Qsync中配置文件夹同步任务，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601187" alt="alt text" title="alt text" loading="lazy"/>  <br/>然后选择同步任务👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601188" alt="alt text" title="alt text" loading="lazy"/>  <br/>然后填写NAS的登录信息，以便Qsync可以知道你要同哪个NAS上同步数据，👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601189" alt="alt text" title="alt text" loading="lazy"/>  <br/>然后，你就可以添加同步的双方文件夹了，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601190" alt="alt text" title="alt text" loading="lazy"/>  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601191" alt="alt text" title="alt text" loading="lazy"/></p><p>🚩 <strong>关于〔节省空间模式〕，最值得称道的一点，就是它不会让我们在本地编辑文档的时候，被因Qsync的同步功能而锁定文档，导致我们编辑的文档无法保存。然而，这在一些其它技术不用心的网盘工具中，是经常发生的，这导致用户的编辑经常无法保存而丢失。大家在选择网盘工具和同步工具时，需要特别注意这一点</strong></p><p>通过Qsync同步文档，在文档的图标上会有所区别。👇如下图所示，&lt;font color=red&gt;<strong>1</strong>&lt;/font&gt;号位置的文档没有云朵图标，说明这个文档是在本地的；&lt;font color=red&gt;<strong>2</strong>&lt;/font&gt;号位置的文档有云朵图标，说明这个文档是在云端的，它在本地不占用空间，当你打开他时，或者移动它时，Qsync会感知到你的操作，会自动从NAS上把文档同步到本地，以供你使用。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601192" alt="alt text" title="alt text" loading="lazy"/></p><h3>公网下连接Qsync</h3><p>如果你的电脑处于公网环境下，请按以下操作切换<strong>Qsync</strong>的连接方式，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601193" alt="alt text" title="alt text" loading="lazy"/></p><h2>使用Qfile Pro</h2><p><strong>Qfile</strong>是Qnap开发的移动端使用的NAS文件同步工具，我们上文中介绍了<strong>Qsync</strong>，<strong>Qsync</strong>这个工具也有移去版本的app，功能与电脑版本的完全一致。但是在移去端，我更喜欢全胜<strong>Qfile</strong>连接NAS，<strong>Qfile</strong>集成了<strong>Qsync</strong>的文件同步功能的同时，我觉得更吸引我的点在于，<strong>Qfile</strong>不会把<strong>NAS</strong>上的文档同步到本地，这恰好避免了<strong>NAS</strong>上的海量文档对手机浏览功能的污染（例如<strong>NAS</strong>上的图片会污染手机想册的浏览体验）。</p><h3>下载Qfile Pro</h3><p>Qnap官网提供了<strong>Qfile Pro</strong>的下载链接，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601194" alt="alt text" title="alt text" loading="lazy"/></p><p>下载对应的版本，完成<strong>Qfile Pro</strong>的安装。</p><h3>局域网下连接NAS</h3><p>我们完成<strong>Qfile</strong>的安装后，我们首先在局域网下进行<strong>Qfile</strong>与<strong>NAS</strong>的链接。具体操作如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601195" alt="alt text" title="alt text" loading="lazy"/></p><ul><li>👉其中第&lt;font color=red&gt;<strong>15</strong>&lt;/font&gt;步，可以根据情况选择〔邮件认证〕或者是〔输入密码〕。</li><li>👉另外需要注意第&lt;font color=red&gt;<strong>11</strong>&lt;/font&gt;步，打开〔检测可用的连接方法〕。</li></ul><h3>外网环境下连接NAS</h3><p>我们希望在外网环境下也可以在手机上查阅NAS上的资料，但这需要我们的路由器为我们打开NAS的连接端口（这在〔<strong>HTTPS安全访问</strong>〕一章中已经有所说明）。</p><p>我们关闭wifi，使手机处于4G网络状态下进行操作，如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601196" alt="alt text" title="alt text" loading="lazy"/>  <br/>继续操作如下👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601197" alt="alt text" title="alt text" loading="lazy"/></p><p>以上操作完成后，我们就可以在外网环境下连接我们的NAS了。随时随地可以访问NAS，这才能发挥NAS最大的价值。</p><h3>内外网自适应</h3><p>当我们完成以上的操作后，我们的<strong>Qfile</strong>可以在外网环境下连接家里的NAS，但是它不能根据我们所处的网络环境（内网 or 外网）自动切换连接方式，这导致我们手机的网络环境切换后，<strong>Qfile</strong>就无法连接NAS，需要我们每次手动切换连接方式。要想让<strong>Qfile</strong>可以自动根据网络环境切换连接方式，请完成以下操作👇  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047601198" alt="alt text" title="alt text" loading="lazy"/></p><p>完成以上操作后，<strong>Qfile</strong>便可以根据我们的设备所处的网络环境自适应调整连接方式了。</p><p>关于<strong>Qfile</strong>的其它使用方式，这是非常丰富的，各位自行摸索吧。</p>]]></description></item><item>    <title><![CDATA[亲测有效：Windows上使用 Claude Code 超详细安装指南 程序员小崔日记 ]]></title>    <link>https://segmentfault.com/a/1190000047601286</link>    <guid>https://segmentfault.com/a/1190000047601286</guid>    <pubDate>2026-02-09 12:06:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>亲测有效：Windows上使用 Claude Code 超详细安装指南</h2><p>这篇文章将手把手带你完成 Claude Code 在 Windows 下的完整安装与配置，帮助你一次成功。</p><hr/><h3>一、为什么推荐 Claude Code？</h3><p>如果你还没接触过 Claude Code，可以简单理解为：</p><blockquote><strong>Claude Code = Anthropic 官方出品的 AI 代码助手 CLI</strong></blockquote><p>它的优势在于：</p><ul><li>原生 CLI，适合真实项目开发</li><li>强大的代码理解与修改能力</li><li>对大型代码仓库友好</li><li>能直接参与调试、重构、解释代码</li></ul><p>对于后端、全栈，以及偏工程化的开发者，体验明显优于很多只停留在“聊天”的 AI 工具。</p><hr/><h3>二、准备工作：Kimi（Moonshot）服务配置</h3><p>由于国内网络环境限制，本文采用 Moonshot（Kimi）提供的 Anthropic 兼容接口。</p><h4>1️⃣ 获取 Moonshot API Key</h4><p>前往 Moonshot 官方控制台创建 API Key：</p><ul><li>地址：Moonshot AI 开放平台</li><li>新建 Key 后 <strong>一定要立即复制保存</strong></li><li>API Key 无法二次查看</li></ul><p>切记：创建后马上保存，否则只能重新生成</p><hr/><h4>2️⃣ 配置环境变量</h4><p>在 Windows 系统环境变量中新增：</p><pre><code class="text">ANTHROPIC_API_KEY
你的 Moonshot API Key</code></pre><pre><code class="text">ANTHROPIC_BASE_URL
https://api.moonshot.cn/anthropic/</code></pre><p>配置完成后重启终端，确保生效。</p><hr/><h3>三、Claude Code 安装前的必备条件</h3><p>在开始安装前，请确保你的系统满足以下要求：</p><ul><li>Windows 10（2004+）或 Windows 11</li><li>管理员权限</li><li>已安装 Git</li><li>Node.js 18+（推荐 LTS）</li><li>稳定网络环境</li></ul><hr/><h4>1️⃣ 安装 Git</h4><p>下载地址：<a href="https://link.segmentfault.com/?enc=ViUpdpU7HLr6FWddCkqqmQ%3D%3D.pRDfr8%2BzHuyBpWIREcKQJaxefQTutNOyYTMRmLpW79w%3D" rel="nofollow" target="_blank">https://git-scm.com/downloads</a>  </p><p>按默认步骤安装即可。</p><p>安装完成后，<strong>额外配置一个环境变量（非常关键）</strong>：</p><pre><code class="text">CLAUDE_CODE_GIT_BASH_PATH
D:\Program Files\Git\bin\bash.exe</code></pre><p>路径根据你自己的 Git 安装位置调整。</p><p>验证是否成功：</p><pre><code class="bash">git --version</code></pre><p>看到版本号即说明 Git 安装成功。</p><hr/><h4>2️⃣ 安装 Node.js</h4><p>下载地址：<a href="https://link.segmentfault.com/?enc=9Y3HqBALfSWYCieJt5DQNw%3D%3D.GREYn5VjzVt61DhnAOAD9Wv9wZgTPegYewgx%2FYHpvwg%3D" rel="nofollow" target="_blank">https://nodejs.org</a>  </p><p>安装 Node.js 18 及以上版本。</p><p>验证安装：</p><pre><code class="bash">node -v
npm -v</code></pre><hr/><h3>四、安装 Claude Code</h3><h4>1️⃣ 使用 npm 全局安装</h4><p>打开 CMD 或 Windows Terminal：</p><pre><code class="bash">npm install -g @anthropic-ai/claude-code</code></pre><p>安装完成后验证：</p><pre><code class="bash">claude --version</code></pre><p>能看到版本号说明安装成功。</p><hr/><h3>五、网络代理：很多人卡在这里</h3><p><strong>重点提醒：国内网络环境下，不开代理基本无法登录</strong></p><h3>六、启动 Claude Code</h3><h4>1️⃣ 在项目目录启动（强烈推荐）</h4><pre><code class="bash">cd 你的项目目录
claude</code></pre><p>Claude Code 启动后会：</p><ul><li>让你选择主题配色</li><li>显示安全提示</li></ul><p>安全提示的核心意思只有一句话：</p><blockquote><strong>AI 可能会犯错，运行代码前一定要自己检查</strong></blockquote><p>直接回车即可。</p><hr/><h4>2️⃣ 登录方式选择</h4><p>Claude Code 提供三种计费方式</p><p>选择 <strong>Anthropic 控制平台（推荐）</strong>，会自动跳转到浏览器。</p><hr/><h4>3️⃣ Google 账号登录</h4><ul><li>需要一个 Google 账号（Gmail）</li><li>登录后授权</li><li>复制一段 Code 回到终端</li></ul><p>如果没有 Google 账号，可以自行注册，或购买一个（价格通常 5–10 元）。</p><hr/><h4>4️⃣ 登录选择</h4><p>回到CMD会提醒你选择官方还是环境变量 API KEY,选择后者。</p><hr/><h4>5️⃣ 提示</h4><ul><li>完成上述步骤后，在vscode或idea中安装 Claude Code插件,直接就可以使用。</li></ul><p><img referrerpolicy="no-referrer" src="https://files.mdnice.com/user/170228/b27c028f-0fa1-442a-b817-b520e54bd88d.png" alt="" title=""/></p><hr/><h3>七、总结</h3><p>如果你是 Windows 开发者，这次 Claude Code 的体验可以说是一次明显升级，<br/>只要按本文步骤配置，<strong>10 分钟内即可上手 Claude Code</strong>，真正把 AI 变成你的“项目搭档”。</p><p><strong>PS：</strong><br/>安装过程中如果遇到任何问题，欢迎在评论区留言，或者私信我一起交流～<br/>如果这篇文章对你有帮助，记得点个赞 + 关注支持一下。</p><p>后续我会使用 Claude Code 插件，实战升级黑马程序员的 「苍穹外卖」项目，感兴趣的朋友可以持续关注，一手更新。</p><p>另外，火影忍者低分段超，想切磋的可以私信我，随时开打。</p><p>本文由<a href="https://link.segmentfault.com/?enc=6Nc71ebvqTM6KaYSoXqhuw%3D%3D.6ewV9frR%2F1PgGlSdVrW5aQkKzDlnDZW8lEWqjdyYRXU%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[Facebook 广告封禁无解？深度解析及方案建议 跨境百科 ]]></title>    <link>https://segmentfault.com/a/1190000047601302</link>    <guid>https://segmentfault.com/a/1190000047601302</guid>    <pubDate>2026-02-09 12:05:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在当前数字营销环境中，社交媒体平台的合规审核机制日益完善，网络环境的安全性与稳定性已成为广告投放能否持续进行的关键因素。对于需要开展跨境业务的企业而言，如何在复杂的网络环境中建立稳定、可靠的连接，成为确保业务连续性的重要课题。</p><h2><strong>网络环境的基础作用</strong></h2><p>平台通常通过多维度数据对账户行为进行分析，其中网络环境的特征尤为关键。若多个账户共享同一网络出口，或频繁切换不同地区的网络出口，这些行为易被系统识别为异常操作，从而引发审核。</p><p>同时，网络出口的地理位置信息需要与账户操作时的其他参数（如时区、语言等）保持一致。任何不匹配都可能被系统记录，并可能影响广告内容的正常投放。</p><h2><strong>建立安全稳定的网络连接</strong></h2><p>在实际操作中，采用真实家庭网络出口可以有效降低平台识别风险。这类网络出口与普通用户的网络特征更为接近，从而减少被系统标记的可能性。</p><p>建议为每个重要账户配置独立的网络出口，避免多账户间的关联风险。同时，应确保所选网络出口的地理位置与目标市场保持一致，这有助于提升广告投放的精准度。</p><p>网络连接的质量也直接影响操作体验。稳定的连接可以确保各项操作的流畅进行，而经过筛选的网络资源则能避免因历史使用记录可能带来的潜在风险。</p><h2><strong>实施方案建议</strong></h2><p>建立符合平台规范的操作环境并不复杂：</p><ol><li>根据目标市场选择相应地区的网络资源</li><li>通过专业工具配置独立的浏览器环境</li><li>确保目标网络与设备时区、语言、分辨率的精准匹配</li></ol><p>在整个广告投放周期中，保持网络环境的稳定性十分重要。避免频繁更换不同的网络出口，有助于建立长期可信的操作记录。</p><p>通过深入理解平台审核机制的核心逻辑，并采取相应的技术措施，广告主可以有效降低运营风险。稳定的网络环境不仅能保障广告投放的连续性，也能为跨境业务的拓展提供可靠的技术支持。</p>]]></description></item><item>    <title><![CDATA[用 Python 将 Excel 表格完美转换为 Word：保持格式不变 宇文成都 ]]></title>    <link>https://segmentfault.com/a/1190000047601304</link>    <guid>https://segmentfault.com/a/1190000047601304</guid>    <pubDate>2026-02-09 12:04:30</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>数据管理与转换在日常工作中扮演着重要角色。许多情况下，我们需要将 Excel 中的数据导入到 Word 文档中，以便生成报告、制作演示材料或进行文档归档。然而，这个过程不仅涉及到简单的数据搬运，还需要确保格式的完整性，以保持文档的专业性和可读性。本文将教你如何使用 Spire.XLS for Python 和 Spire.Doc for Python 库，轻松将 Excel 数据导出并在 Word 中生成美观的表格，从而提升你的工作效率。</p><h2>环境准备</h2><p>首先，确保安装了所需的库。需要使用 Spire.XLS 和 Spire.Doc，Spire.XLS 是一款非常强大的 Excel 文件处理库，支持读取、编辑和生成 Excel 文件（.xlsx 和 .xls 格式）；Spire.Doc 是一款功能强大的 Word 文档处理库，允许用户创建、编辑和读取 Word 文档（.doc 和 .docx 格式）。</p><p>安装命令：</p><pre><code class="bash">pip install Spire.XLS
pip install Spire.Doc</code></pre><h2>代码实现</h2><p>以下是将 Excel 数据导出为 Word 表格的完整代码示例：</p><pre><code class="python">from spire.xls import *
from spire.doc import *

def MergeCells(sheet, table):
    """根据 Excel 工作表中的合并单元格合并 Word 表格中的对应单元格"""
    if sheet.HasMergedCells:
        ranges = sheet.MergedCells
        for i in range(len(ranges)):
            startRow = ranges[i].Row
            startColumn = ranges[i].Column
            rowCount = ranges[i].RowCount
            columnCount = ranges[i].ColumnCount

            if rowCount &gt; 1 and columnCount &gt; 1:
                for j in range(startRow, startRow + rowCount):
                    table.ApplyHorizontalMerge(j - 1, startColumn - 1, startColumn - 1 + columnCount - 1)
                table.ApplyVerticalMerge(startColumn - 1, startRow - 1, startRow - 1 + rowCount - 1)

            if rowCount &gt; 1 and columnCount == 1:
                table.ApplyVerticalMerge(startColumn - 1, startRow - 1, startRow - 1 + rowCount - 1)

            if columnCount &gt; 1 and rowCount == 1:
                table.ApplyHorizontalMerge(startRow - 1, startColumn - 1, startColumn - 1 + columnCount - 1)

def CopyStyle(wTextRange, xCell, wCell):
    """将单元格样式从 Excel 复制到 Word"""
    # 复制字体样式
    wTextRange.CharacterFormat.TextColor = Color.FromRgb(xCell.Style.Font.Color.R, xCell.Style.Font.Color.G, xCell.Style.Font.Color.B)
    wTextRange.CharacterFormat.FontSize = float(xCell.Style.Font.Size)
    wTextRange.CharacterFormat.FontName = xCell.Style.Font.FontName
    wTextRange.CharacterFormat.Bold = xCell.Style.Font.IsBold
    wTextRange.CharacterFormat.Italic = xCell.Style.Font.IsItalic

    # 复制背景颜色
    if xCell.Style.FillPattern is not ExcelPatternType.none:
        wCell.CellFormat.BackColor = Color.FromRgb(xCell.Style.Color.R, xCell.Style.Color.G, xCell.Style.Color.B)

    # 复制对齐方式
    wCell.CellFormat.HorizontalAlignment = {
        HorizontalAlignType.Left: HorizontalAlignment.Left,
        HorizontalAlignType.Center: HorizontalAlignment.Center,
        HorizontalAlignType.Right: HorizontalAlignment.Right
    }.get(xCell.HorizontalAlignment)

    wCell.CellFormat.VerticalAlignment = {
        VerticalAlignType.Bottom: VerticalAlignment.Bottom,
        VerticalAlignType.Center: VerticalAlignment.Middle,
        VerticalAlignType.Top: VerticalAlignment.Top
    }.get(xCell.VerticalAlignment)

# 加载 Excel 文件
workbook = Workbook()
workbook.LoadFromFile("Contact list.xlsx")

# 获取第一个工作表
sheet = workbook.Worksheets[0]

# 创建 Word 文档
doc = Document()
section = doc.AddSection()
section.PageSetup.Orientation = PageOrientation.Landscape

# 添加表格
table = section.AddTable(True)
table.ResetCells(sheet.LastRow, sheet.LastColumn)

# 根据 Excel 工作表中的合并单元格合并 Word 表格中的对应单元格
MergeCells(sheet, table)

# 从 Excel 导出数据和单元格样式到 Word 表格
for r in range(1, sheet.LastRow + 1):
    table.Rows[r - 1].Height = float(sheet.Rows[r - 1].RowHeight)

    for c in range(1, sheet.LastColumn + 1):
        xCell = sheet.Range[r, c]
        wCell = table.Rows[r - 1].Cells[c - 1]

        # 复制数据
        textRange = wCell.AddParagraph().AppendText(xCell.NumberText)

        # 复制单元格样式
        CopyStyle(textRange, xCell, wCell)

# 将 Word 文档保存到文件
doc.SaveToFile("Excel转Word表格.docx", FileFormat.Docx)</code></pre><h2>代码解析</h2><ol><li><strong>合并单元格 (<code>MergeCells</code> 函数)</strong> ：为了确保 Excel 中合并的单元格在 Word 中也保持一致，该函数管理合并单元格的逻辑。</li><li><strong>复制样式 (<code>CopyStyle</code> 函数)</strong> ：设计用于将 Excel 单元格的格式（如字体、颜色和对齐方式）精确复制到 Word 表格中。</li><li><strong>加载和处理数据</strong> ：通过 Spire.XLS 从 Excel 文件中读取数据，然后创建 Word 文档并构建其中的表格。</li><li><strong>导出数据</strong> ：通过遍历 Excel 的每一行和每一列，将数据导入 Word 表格，并同时应用样式。</li></ol><h2>总结</h2><p>使用 Spire.XLS 和 Spire.Doc 库，Python 开发者可以轻松地将 Excel 数据导出到 Word 文档中，并确保格式的完整性。这种转换不仅提高了工作效率，还提升了文档的专业性，适用于各种商业和学术场景。希望本文的代码示例能为你提供帮助，让数据处理工作变得更加顺畅。</p>]]></description></item><item>    <title><![CDATA[跟老卫学仓颉编程语言开发：整数类型 waylau ]]></title>    <link>https://segmentfault.com/a/1190000047601306</link>    <guid>https://segmentfault.com/a/1190000047601306</guid>    <pubDate>2026-02-09 12:03:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>整数类型分为有符号（signed）整数类型和无符号（unsigned）整数类型。</p><p>有符号整数类型包括Int8、Int16、Int32、Int64和IntNative，分别用于表示编码长度为8-bit、16-bit、32-bit、64-bit和平台相关大小的有符号整数值的类型。</p><p>无符号整数类型包括UInt8、UInt16、UInt32、UInt64和UIntNative，分别用于表示编码长度为8-bit、16-bit、32-bit、64-bit 和平台相关大小的无符号整数值的类型。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601308" alt="" title=""/></p><p>程序具体使用哪种整数类型，取决于该程序中需要处理的整数的性质和范围。在Int64类型适合的情况下，首选Int64类型，因为Int64的表示范围足够大，并且整数类型字面量在没有类型上下文的情况下默认推断为Int64类型，可以避免不必要的类型转换。</p><h3>整数类型字面量</h3><p>整数类型字面量有4种进制表示形式：二进制（使用0b或0B前缀）、八进制（使用0o或0O前缀）、十进制（没有前缀）、十六进制（使用0x或0X前缀）。例如，对于十进制数24，表示成二进制是0b00011000（或0B00011000），表示成八进制是0o30（或0O30），表示成十六进制是0x18（或0X18）。</p><p>在各进制表示中，可以使用下划线“_”充当分隔符的作用，方便识别数值的位数，如<code>0b0001_1000</code>。</p><p>对于整数类型字面量，如果它的值超出了上下文要求的整数类型的表示范围，编译器将会报错。</p><pre><code>let x: Int8 = 128          // 错误！, 128 out of the range of Int8
let y: UInt8 = 256         // 错误！, 256 out of the range of UInt8
let z: Int32 = 0x8000_0000 // 错误！, 0x8000_0000 out of the range of Int32</code></pre><p>在使用整数类型字面量时，可以通过加入后缀来明确整数字面量的类型，后缀与类型的对应关系如下表3-1所示。</p><p>表3-1 后缀与类型的对应关系</p><table><thead><tr><th>后缀</th><th>类型</th><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>i8</td><td>Int8</td><td>u8</td><td>UInt8</td></tr><tr><td>i16</td><td>Int16</td><td>u16</td><td>UInt16</td></tr><tr><td>i32</td><td>Int32</td><td>u32</td><td>UInt32</td></tr><tr><td>i64</td><td>Int64</td><td>u64</td><td>UInt64</td></tr></tbody></table><p>加入了后缀的整数字面量可以像下面的方式来使用：</p><pre><code>var x = 100i8  // x is 100 with type Int8
var y = 0x10u64 // y is 16 with type UInt64
var z = 0o432i32  // z is 282 with type Int32</code></pre><h3>字符字节字面量</h3><p>仓颉编程语言支持字符字节字面量，以方便使用ASCII码表示UInt8类型的值。字符字节字面量由字符b、一对标识首尾的单引号、以及一个ASCII字符组成，例如：</p><pre><code>var a = b'x' // a is 120 with type UInt8
var b = b'\n' // b is 10 with type UInt8
var c = b'\u{78}' // c is 120 with type UInt8</code></pre><p><code>b'x'</code>表示类型为UInt8大小是120的字面值。另外还可以通过<code>b'\u{78}'</code>这种转义形式表示类型为UInt8，16进制大小为<code>0x78</code> 或10进制大小为120的字面值。需要注意的是，<code>\u</code>内部最多有两位16进制数，并且值必须小于256（十进制）。</p><h3>整数类型支持的操作</h3><p>整数类型默认支持的操作符包括：算术操作符、位操作符、关系操作符、自增和自减操作符、赋值操作符、复合赋值操作符。</p><p>算术操作符包括：一元负号（<code>-</code>）、加法（<code>+</code>）、减法（<code>-</code>）、乘法（<code>*</code>）、除法（<code>/</code>）、取模（<code>%</code>）、幂运算（<code>**</code>）。</p><p>除了一元负号（<code>-</code>）和幂运算（<code>**</code>），其他操作符要求左右操作数是相同的类型。</p><p><code>*</code>、<code>/</code>、<code>+</code>和<code>-</code>的操作数可以是整数类型或浮点类型。</p><p><code>%</code>的操作数只支持整数类型。</p><p><code>**</code>的左操作数只能为Int64类型或Float64类型，并且：</p><ul><li>当左操作数类型为Int64时，右操作数只能为UInt64类型，表达式的类型为Int64。</li><li>当左操作数类型为Float64时，右操作数只能为Int64类型或Float64类型，表达式的类型为Float64。</li></ul><p>幂运算的使用，见如下示例：</p><pre><code class="ts">let p1 = 2 ** 3               // p1 = 8
let p2 = 2 ** UInt64(3 ** 2)  // p2 = 512
let p3 = 2.0 ** 3.0           // p3 = 8.0
let p4 = 2.0 ** 3 ** 2        // p4 = 512.0
let p5 = 2.0 ** 3.0           // p5 = 8.0
let p6 = 2.0 ** 3.0 ** 2.0    // p6 = 512.0</code></pre><p>位操作符包括：按位求反（<code>!</code>）、左移（<code>&lt;&lt;</code>）、右移（<code>&gt;&gt;</code>）、按位与（<code>&amp;</code>）、按位异或（<code>^</code>）、按位或（<code>|</code>）。注意，按位与、按位异或和按位或操作符要求左右操作数是相同的整数类型。</p><p>关系操作符包括：小于（<code>&lt;</code>）、大于（<code>&gt;</code>）、小于等于（<code>&lt;=</code>）、大于等于（<code>&gt;=</code>）、相等（<code>==</code>）、不等（<code>!=</code>）。要求关系操作符的左右操作数是相同的整数类型。</p><p>自增和自减操作符包括：自增（<code>++</code>）和自减（<code>--</code>）。注意，仓颉中的自增和自减操作符只能作为一元后缀操作符使用。</p><p>赋值操作符即<code>=</code>，复合赋值操作符包括：<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>**=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、<code>|=</code>。</p><p>整数类型之间、整数类型和浮点类型之间可以互相转换，整数类型可以转换为字符类型。</p><h3>参考引用</h3><p>更多仓颉学习资料，详见：</p><ul><li>《跟老卫学HarmonyOS开发》：<a href="https://link.segmentfault.com/?enc=rb%2FCsBJ3yVfzExkOSbj5Yw%3D%3D.ywf1%2Bz4THBa3jO85gRgFOlCU5KfLQ%2FLZrmQPs9N5CVd6OFpeTXzmgoSXjROOA3VF" rel="nofollow" target="_blank">https://github.com/waylau/harmonyos-tutorial</a></li><li>《跟老卫学仓颉编程语言开发》：<a href="https://link.segmentfault.com/?enc=D547VvToOvGcClMjpLttvw%3D%3D.tykaoVOSkCQqtFENp5QtSP4E2XkQ8VzGJFMGhm%2B00yqKiloor%2B7U0p%2FTGYiPnxS88gzqKyZqvMAOTfYgV24wig%3D%3D" rel="nofollow" target="_blank">https://github.com/waylau/cangjie-programming-language-tutorial</a></li><li>“HarmonyOS NEXT+AI大模型打造智能助手APP(仓颉版)”：<a href="https://link.segmentfault.com/?enc=g3E5Uy1RqWzaLIkFvcRolA%3D%3D.zqRqQ5KalSH4jFfA7vRU%2FgVMbucqV6qN3Kx%2FVjKutGUj15pQ%2BZgOdi5PuduV6Z9k" rel="nofollow" target="_blank">https://coding.imooc.com/class/927.html</a></li><li>《仓颉编程从入门到实践》（北京大学出版社）：<a href="https://link.segmentfault.com/?enc=GqLsmU48gTZQGnzbrj4c4Q%3D%3D.DKA86NTqEH348KJ36ItBC4TqZqJy9tFJcKQqQbfF2kIt5YOakVUwlwsbMoOoCsGVX0gYS4%2FP1nLyhKanAF3K3fiZd78%2BDKIxeL5Dh9o7GxU%3D" rel="nofollow" target="_blank">https://waylau.com/about-cangjie-programming-language-tutoria...</a></li><li><img referrerpolicy="no-referrer" src="/img/remote/1460000047601309" alt="" title="" loading="lazy"/></li></ul>]]></description></item><item>    <title><![CDATA[十大人气CRM系统详解 正直的炒饭 ]]></title>    <link>https://segmentfault.com/a/1190000047601312</link>    <guid>https://segmentfault.com/a/1190000047601312</guid>    <pubDate>2026-02-09 12:02:58</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在客户成为企业核心资产的数字化时代，一款适配的CRM（客户关系管理）系统，是激活销售效率、留存高价值客户、实现持续增长的关键抓手。2026年国内CRM市场百花齐放，既有深耕垂直领域的专业玩家，也有覆盖全链路的一体化平台。本文深度测评10款高人气CRM系统，从核心能力、适配场景、优势亮点等维度拆解，帮你找到最契合业务需求的数字化工具。</p><h3>一、十大人气CRM系统详解</h3><h4>1. 超兔CRM（XTools）：全链路一体化的中小企业数字化引擎</h4><p>作为国内CRM行业的资深玩家，超兔CRM以“一体云”为核心定位，打造了<strong>CRM+进销存+</strong> <strong>MES</strong> <strong>生产执行+财务+AI</strong>的全链路闭环系统，覆盖从获客线索、销售跟进、订单执行、生产制造到财务回款的全业务流程，无需多系统切换即可满足中小企业的数字化需求。</p><p>核心能力上，超兔CRM的CRM模块提供360°客户视图、“三一客”节点管理（定性/定级/定量）、SFA销售自动化、RFM客户分层等功能，帮助销售精准跟进客户；进销存模块支持多仓库管理、BOM清单、智能采购直发，适配贸易与生产型企业；MES生产执行模块可实现排程、报工、质检全流程管控，联动CRM订单数据实现生产-销售协同；财务模块则支持凭证智能生成、Acc日记账、薪资自动化计算，打通业财数据。</p><p>AI赋能是超兔CRM的一大特色：基于通义千问大模型的AI智能体可定制行业销售SOP、生成个性化跟进话术，还能自动抓取电商订单、招投标数据，分析微信/电话沟通内容评估客户意向。目前已落地机械设备、工业工贸、装修、生产制造等多行业场景，帮助企业提升销售效率30%以上，降低运营成本20%。</p><p><strong>优势</strong>：全链路一体化降低数字化门槛，AI深度融入业务场景，支持移动办公与多账户管理，适配中小企业从获客到生产的全流程需求。</p><h4>2. 纷享销客：中大型企业的全场景CRM标杆</h4><p>作为国内CRM领域的领军品牌，纷享销客连续多年占据市场领先份额，2024年以110亿估值入选胡润全球独角兽榜，服务中电海康、蒙牛、元气森林等6000+中大型企业。</p><p>其核心能力围绕中大型企业的精细化管理需求：360°客户视图实现全生命周期跟进，客户分级管理支撑差异化服务策略，系统可无缝集成企业微信、ERP、HR等异构系统，强化跨部门协同。同时支持私有部署、混合部署与云端部署多种模式，销售流程、权限管理、数据报表均可灵活定制，适配复杂组织架构下的管理需求。</p><p><strong>优势</strong>：中大型企业适配性强，定制化能力突出，多部署模式满足不同IT架构需求。</p><h4>3. Zoho CRM：海外本土化的全能型SaaS平台</h4><p>Zoho CRM作为全球知名CRM厂商，在国内设有本地团队，是满足国产化需求的海外品牌代表之一，全球服务25万+企业客户，包括快手、龙湖地产、网易等。</p><p>系统覆盖销售自动化、营销自动化、客户服务、数据分析全模块，支持28种语言，提供稳定的SaaS云端服务。其自动化工具可减少人工操作，多渠道营销工具助力提升品牌影响力与客户转化，适合需要全功能CRM且偏好海外本土化服务的企业。</p><p><strong>优势</strong>：功能全面，全球品牌背书，国内本地化团队支持，适配从中小企业到大型企业的需求。</p><h4>4. 小满CRM：外贸行业的垂直化CRM专家</h4><p>小满CRM是专注外贸领域的垂直型CRM，围绕外贸业务流程整合了线索开发、邮件营销、客户跟进、订单管理与数据分析全链条功能。</p><p>核心特色是智能化邮件管理：支持批量发送、模板化管理与客户行为追踪（如邮件打开、链接点击），帮助外销人员精准把握客户意向；同时对接主流社交媒体与海关数据，可快速获取海外客户线索，大幅提升外贸企业的获客与沟通效率。</p><p><strong>优势</strong>：深度适配外贸业务场景，解决外销线索获取与跟进精准度问题。</p><h4>5. 励销云：主动式获客的智能化销售平台</h4><p>励销云定位于“找客-触客-管客”一体化的主动式销售平台，核心亮点是内置海量企业工商信息与联系方式数据库，通过大数据与AI技术帮助企业主动筛选潜在商机，解决“获客难”痛点。</p><p>系统集成智能电话、短信、邮件等触达工具，所有沟通记录自动沉淀到客户档案，形成完整跟进历史；同时提供销售漏斗管理、客户分层等功能，构建主动获客与精细化管理的闭环，适合依赖线索驱动的销售型企业。</p><p><strong>优势</strong>：主动获客能力突出，实现从线索挖掘到客户管理的全流程覆盖。</p><h4>6. 简道云CRM：零代码定制的灵活型解决方案</h4><p>简道云CRM基于零代码/低代码平台构建，最大特点是高度灵活性与可定制性。用户无需编写代码，通过拖拉拽即可快速搭建或修改CRM模块，包括客户信息字段、审批流程、报表样式等，适配非标准化业务流程。</p><p>此外，简道云可与进销存、项目管理等其他业务应用连接，打通企业内部数据流，构建符合自身需求的集成化管理平台，适合业务变化频繁、需要快速调整系统的成长型企业。</p><p><strong>优势</strong>：零代码定制门槛低，灵活适配个性化业务需求。</p><h4>7. 悟空CRM：开源与商业版兼具的多元化选择</h4><p>悟空CRM同时提供开源版与商业版，为不同需求的企业提供多样化选择：开源版适合具备自主开发能力的技术团队，可基于源代码进行深度定制与二次开发，确保数据私有化部署与安全性；商业版则提供CRM、销售自动化、BI分析、HRM等全模块功能，形成一体化企业管理解决方案。</p><p>无论是希望低成本起步、灵活定制的小微企业，还是需要全面数字化运营的大中型企业，都能在悟空CRM的产品矩阵中找到适配方案。</p><p><strong>优势</strong>：开源+商业版双模式，覆盖从定制化到全流程管理的需求。</p><h4>8. 红圈CRM：外勤销售的精细化管理专家</h4><p>红圈CRM深耕外勤销售过程管理，核心能力聚焦移动端应用与外勤行为管控：销售人员可通过移动端App完成客户拜访签到、工作轨迹记录、现场信息采集与销售订单上报，一线动态实时同步到管理后台。</p><p>系统强调销售行为的量化管理，通过追踪拜访频率、时长、客户覆盖率等过程指标，帮助管理者客观评估团队执行力，及时发现销售瓶颈，适合拥有大量外勤团队、需提升销售过程管控的企业。</p><p><strong>优势</strong>：外勤管理能力突出，实现销售过程的可视化与量化管控。</p><h4>9. 快启CRM：微信生态下的SCRM私域运营平台</h4><p>快启CRM以SCRM为核心理念，深度整合微信生态，帮助企业管理微信端客户资源，解决员工离职导致微信客户流失的问题。</p><p>系统可合规存档微信聊天记录与客户互动行为，将社交数据与CRM交易数据结合构建完整客户画像；同时提供渠道活码、客户标签、群发助手等私域营销工具，帮助企业在社交场景下高效互动，实现私域流量的精细化运营与转化，适合依赖微信私域的企业。</p><p><strong>优势</strong>：微信生态集成度高，私域运营与客户留存能力突出。</p><h4>10. HubSpot：集客营销的全球标杆平台</h4><p>HubSpot是全球知名的集客营销与销售自动化平台，其免费CRM是生态核心入口，提供简洁直观的界面与流畅体验，适合初创企业快速上手。</p><p>平台一体化生态覆盖营销、销售、服务三大模块：免费版可管理客户联系人、追踪销售流程；付费版的Marketing Hub、Sales Hub、Service Hub则提供邮件营销、社交媒体管理、智能客服、高级自动化等功能，打造从吸引访客、转化线索到服务客户的完整增长闭环。不过其高级功能定价较高，国内访问速度与本土应用集成需考虑适配性。</p><p><strong>优势</strong>：集客营销理念领先，免费版门槛低，一体化生态功能强大。</p><ul><li><ul><li>*</li></ul></li></ul><h3>二、CRM系统的核心价值与必备功能</h3><h4>核心价值</h4><ol><li><strong>集中客户数据</strong>：避免因人员变动导致客户资源流失，形成统一客户视图支撑跨部门协同；</li><li><strong>解放销售生产力</strong>：自动化流程减少数据录入与行政工作，让销售聚焦客户关系与交易转化；</li><li><strong>数据驱动决策</strong>：通过销售漏斗分析、业绩预测等功能，优化销售策略，提升转化效率。</li></ol><h4>必备功能</h4><ol><li><strong>客户与线索管理</strong>：集中存储客户资料，实现线索自动捕获、分配与追踪，构建360°客户画像；</li><li><strong>销售自动化</strong>：销售漏斗可视化、任务提醒、工作流自动化，规范销售流程避免疏漏；</li><li><strong>数据分析与报表</strong>：实时业绩看板、销售预测、团队绩效评估，支撑数据驱动决策；</li><li><strong>协同与集成</strong>：支持移动办公，可与企业微信、ERP等系统对接，打通信息孤岛。</li></ol><ul><li><ul><li>*</li></ul></li></ul><h3>三、CRM系统的适配场景与选型指南</h3><h4>适配行业</h4><ul><li><strong>B2B领域</strong>：IT、制造业、金融服务、商业地产等销售周期长、客单价高的行业，CRM是精细化管理客户关系的必备工具；</li><li><strong>B2C领域</strong>：零售、教育培训、医疗健康等行业，可通过CRM实现客户分层、个性化营销与复购激活。</li></ul><h4>适配规模</h4><ul><li><strong>小微企业</strong>：优先选轻量化或一体化平台（如超兔CRM、Zoho免费版），降低数字化门槛；</li><li><strong>中大型企业</strong>：选定制化能力强、支持多部署的平台（如纷享销客、Zoho商业版），适配复杂组织架构。</li></ul><h4>选型步骤</h4><ol><li><strong>梳理核心业务流程</strong>：项目制企业选强项目管理能力的CRM（如超兔CRM、纷享销客）；快消企业选营销自动化突出的平台（如励销云、HubSpot）；</li><li><strong>评估易用性与集成性</strong>：组织一线员工试用，确保系统与现有工具（企业微信、ERP）兼容，降低培训成本；</li><li><strong>考虑扩展性</strong>：选择可定制、功能可扩展的平台，适配业务增长后的需求变化。</li></ol><ul><li><ul><li>*</li></ul></li></ul><h3>四、快速上手CRM系统的实操技巧</h3><ol><li><strong>管理层牵头明确目标</strong>：如设定“提升线索转化率15%”“缩短销售周期10%”的具体目标，自上而下统一团队认知；</li><li><strong>分阶段实施</strong>：从核心功能（客户管理、销售跟进）入手，逐步扩展到进销存、生产、财务等模块，避免团队不堪重负；</li><li><strong>差异化培训</strong>：针对销售、客服、管理层提供定制化培训内容，建立内部支持渠道及时解决问题；</li><li><strong>数据驱动优化</strong>：每周分析CRM数据，调整销售流程与跟进策略，逐步实现精细化管理。</li></ol><ul><li><ul><li>*</li></ul></li></ul><h3>常见问题解答（FAQ）</h3><ol><li><strong>CRM系统的数据安全如何保障？</strong> 主流CRM厂商采用云端加密存储、多副本备份、细粒度权限控制、操作日志追溯等技术，符合国际安全标准（如ISO27001）。部分厂商支持私有部署（如纷享销客、悟空CRM），可进一步保障数据私有化安全。</li><li><strong>使用CRM后，是否还需要用Excel管理客户？</strong> CRM可完全替代Excel，提供实时协同、数据安全、智能分析等Excel不具备的优势。初期可将Excel数据导入CRM，后续建议统一在CRM中管理客户信息，避免信息孤岛与版本混乱。</li><li><strong>独特的销售流程，CRM能适配吗？</strong> 大部分专业CRM支持高度自定义，如超兔CRM可自定义字段、工作流、报表；简道云可零代码搭建专属流程。选型时重点考察系统的定制化能力，优先选择支持可视化配置的平台。</li><li><strong>移动端App对于CRM系统重要吗？</strong> 非常重要。超兔CRM、红圈CRM等平台的移动端支持外勤签到、客户信息录入、待办提醒、订单上报等功能，让销售随时随地跟进客户，大幅提升外勤工作效率，确保客户跟进不中断。</li><li><strong>中小企业选择CRM时，功能全面还是轻量化更重要？</strong> 优先适配核心业务需求。若企业覆盖获客、销售、生产、全流程，选一体化平台（如超兔CRM）可避免多系统切换；若仅需基础客户管理，选轻量化工具（如Zoho免费版）即可，兼顾易用性与扩展性。</li></ol>]]></description></item><item>    <title><![CDATA[开源与商业CRM核心能力横评：从AI到复购的全维度较量 傲视众生的脸盆 ]]></title>    <link>https://segmentfault.com/a/1190000047601326</link>    <guid>https://segmentfault.com/a/1190000047601326</guid>    <pubDate>2026-02-09 12:01:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在企业数字化转型中，CRM（客户关系管理）已从“客户信息库”升级为“销售增长引擎”，其核心能力逐渐聚焦于AI智能自动化、销售流程标准化（SFA）、系统集成（API）、数据决策（统计分析）、客户留存（复购流失预警）<strong>五大维度。本文选取</strong>超兔一体云（商业）、YetiForce（开源）、Dolibarr（开源）、橙子CRM（中小微）、销帮帮CRM（中小企）、Zendesk Sell（海外）、OKKICRM（外贸）七大主流CRM，从技术逻辑到场景落地展开深度对比，为企业选型提供参考。</p><h2>一、评估框架与核心维度定义</h2><p>本次对比围绕CRM的“增长驱动能力”设计评估体系，五个核心维度的具体评估点如下：</p><table><thead><tr><th>维度</th><th>评估点</th></tr></thead><tbody><tr><td><strong>AI智能</strong></td><td>原生AI能力、自动化场景覆盖（如AI待办、自动分析）、NLP（自然语言处理）应用</td></tr><tr><td><strong>SFA</strong></td><td>销售流程覆盖（线索-成交全链路）、自定义能力、销售漏斗管理</td></tr><tr><td><strong>API</strong> <strong>对接</strong></td><td>接口丰富度、集成案例（如ERP/电商）、开源扩展性</td></tr><tr><td><strong>统计分析</strong></td><td>报表自定义、多维度数据整合（销售+库存+客户）、实时性</td></tr><tr><td><strong>复购流失预警</strong></td><td>数据模型（如RFM）、预警触发逻辑、自动化动作（如自动提醒）</td></tr></tbody></table><h2>二、核心能力横向对比表</h2><p>先通过<strong>一张表格</strong>快速呈现各品牌的关键差异（“√”代表具备，“-”代表不具备，“☆”代表优势）：</p><table><thead><tr><th>品牌</th><th>AI智能核心特征</th><th>SFA核心特征</th><th>API对接核心特征</th><th>统计分析核心特征</th><th>复购流失预警核心特征</th></tr></thead><tbody><tr><td>超兔一体云</td><td>原生通义千问集成，AI待办/日报/分析☆</td><td>多跟单模型（三一客/商机/项目），全流程标准化☆</td><td>金蝶/用友/京东对接案例，RPA+API☆</td><td>自定义仪表盘+多表聚合+实时KPI☆</td><td>RFM模型+消费间隔分析，自动触发跟进☆</td></tr><tr><td>YetiForce</td><td>开源扩展第三方AI，订单-库存自动化</td><td>销售漏斗+订单-生产-库存全链路绑定☆</td><td>开源API，支持ERP/库存深度集成☆</td><td>自定义报表，多维度数据整合</td><td>客户采购间隔监控，需手动触发提醒</td></tr><tr><td>Dolibarr</td><td>无原生AI，需手动扩展</td><td>报价-发票基础流程，无深度定制</td><td>基础API，支持电商/会计集成</td><td>简单报表，无多维度整合</td><td>无原生功能，需自定义分析</td></tr><tr><td>橙子CRM</td><td>无原生AI，客户标签辅助转化</td><td>线索-签单闭环，抖音/小红书客资导入☆</td><td>抖音/小红书API，支持Excel导出</td><td>销售漏斗/签单排名，基础可视化</td><td>无原生预警，需手动跟踪</td></tr><tr><td>销帮帮CRM</td><td>智能工作流自动化，AI话术建议</td><td>自定义销售流程，回款计划管理☆</td><td>开放API，支持ERP/财务集成</td><td>多维度报表，智能仪表盘</td><td>客户行为分析，触发短信提醒</td></tr><tr><td>Zendesk Sell</td><td>AI销售建议（高价值线索优先）☆</td><td>销售预测+商机管理，全周期跟踪☆</td><td>客服生态集成，基础API</td><td>实时销售看板，团队绩效对比</td><td>AI识别流失风险，自动发送邮件提醒</td></tr><tr><td>OKKICRM</td><td>AI客户画像，外贸场景智能推荐☆</td><td>外贸客户分级，订单-供应商联动☆</td><td>外贸平台（如阿里）集成，API自定义</td><td>采购频率/库存周转分析，外贸场景适配☆</td><td>RFM模型+采购间隔，自动触发补货提醒☆</td></tr></tbody></table><h2>三、技术逻辑与场景落地深度解析</h2><h3>（一）AI智能：从“工具辅助”到“流程驱动”的差异</h3><p>AI是CRM的“大脑”，其核心价值在于<strong>用机器替代重复劳动，用数据提升决策精准度</strong>。我们以<strong>超兔一体云</strong>为例，用流程图展示其AI智能的实现逻辑：</p><p>!<a href="" target="_blank"/></p><pre><code>flowchart TD
    A[技术基础：超兔AI智能体 + 通义千问大模型] --&gt; B[核心能力]
    B --&gt; B1[AI定制行业SOP（输出CJM/话术/销售流程）]
    B --&gt; B2[AI专家智能体（融合客户名称/行业/跟单时间线，生成个性化话术）]
    B --&gt; B3[AI生成关键内容（用户画像、三一客节点、SFA方案）]
    B --&gt; C[场景化应用]
    C --&gt; C1[AI待办（自动生成下一步跟单任务，去除人为偏见）]
    C --&gt; C2[AI日报（分析当日沟通/报价数据，一键生成专业总结）]
    C --&gt; C3[AI问答（岗位个性化话术：销售开场白/客服异议处理）]
    C --&gt; C4[AI执行（RPA自动抓取电商订单/招投标数据）]
    C --&gt; C5[AI分析（微信/电话录音NLP分析，提取客户意向/关键话题）]</code></pre><p><strong>各品牌AI能力差异</strong>：</p><ul><li><strong>超兔</strong>：原生集成通义千问，实现“全场景AI自动化”（从待办生成到沟通分析），是唯一覆盖“AI+SFA+分析”闭环的品牌；</li><li><strong>Zendesk Sell</strong>：侧重“销售决策辅助”（AI推荐高价值线索），但自动化场景少于超兔；</li><li><strong>OKKICRM</strong>：聚焦“外贸场景AI”（客户画像+采购推荐），适配跨境业务需求；</li><li><strong>YetiForce/Dolibarr</strong>：无原生AI，需技术团队扩展第三方工具（如ChatGPT），落地成本高。</li></ul><h3>（二）SFA：从“流程覆盖”到“场景适配”的进化</h3><p>SFA（销售自动化）是CRM的“骨架”，其核心是<strong>将销售经验转化为可复制的流程</strong>。我们用<strong>脑图</strong>展示各品牌的SFA能力结构：</p><p>!<a href="" target="_blank"/></p><pre><code>mindmap
    root((SFA销售自动化能力))
        超兔一体云
            多跟单模型（三一客小单/商机中单/多方项目大单）
            全流程标准化（关键节点+推进步骤，如“三一客”要求“1天内联系/3天内跟进/7天内转化”）
            线索-客户-订单全链路数据驱动（自动关联客户画像与跟进策略）
        YetiForce
            销售漏斗+销售预测+报价管理
            订单-生产-库存全链路绑定（库存不足自动触发采购提醒）
            自定义订单流程（适配制造业“订单-车间-发货”场景）
        OKKICRM（原小满）
            外贸客户分级（高价值客户标记）
            报价管理（历史报价对比+供应商价格联动）
            客户采购频率追踪（提醒业务员跟进复购）
        Zendesk Sell
            线索追踪（来源+跟进记录）
            商机管理（阶段划分+胜率预测）
            销售预测（基于历史数据生成月度目标）</code></pre><p><strong>SFA能力的“场景适配性”是关键</strong>：</p><ul><li>超兔的“多跟单模型”覆盖小单（如零售）、中单一（如企业服务）、大单（如项目型销售），适合<strong>业务多元化的企业</strong>；</li><li>YetiForce的“订单-库存联动”适合<strong>制造/贸易企业</strong>（需打通生产与销售）；</li><li>OKKICRM的“外贸客户分级”适合<strong>跨境电商/外贸企业</strong>（需管理海外客户采购周期）。</li></ul><h3>（三）API对接：从“数据打通”到“生态协同”的升级</h3><p>API是CRM的“神经线”，其核心价值是<strong>打破数据孤岛，实现上下游业务协同</strong>。各品牌的API能力差异主要体现在：</p><table><thead><tr><th>品牌</th><th>API能力优势</th><th>典型集成案例</th></tr></thead><tbody><tr><td>超兔一体云</td><td>RPA+API双引擎，支持非结构化数据抓取</td><td>金蝶ERP（订单同步）、京东（自动抓取订单）、国税开票机器人</td></tr><tr><td>YetiForce</td><td>开源API，支持深度二次开发</td><td>库存系统（自动同步库存）、财务软件（发票对接）</td></tr><tr><td>OKKICRM</td><td>外贸平台专属API</td><td>阿里巴巴国际站（客资导入）、海关系统（报关数据）</td></tr><tr><td>橙子CRM</td><td>自媒体平台API</td><td>抖音（粉丝转化为线索）、小红书（评论抓取）</td></tr></tbody></table><p><strong>结论</strong>：开源CRM（YetiForce）的API扩展性最强，但需技术团队维护；商业CRM（超兔/OKKICRM）的集成案例更丰富，适合<strong>无技术团队的企业</strong>。</p><h3>（四）统计分析：从“数据展示”到“决策支持”的跨越</h3><p>统计分析是CRM的“眼睛”，其核心是<strong>将数据转化为可行动的洞察</strong>。我们以<strong>超兔</strong>和<strong>OKKICRM</strong>为例对比：</p><ul><li><strong>超兔</strong>：提供“工作台自定义引擎+多表聚合引擎+单日KPI引擎”，支持<strong>销售数据+客户行为+库存数据</strong>的多维度整合（如“某地区客户的采购频率与库存周转天数关联分析”），并通过“同比环比引擎”展示业务增长趋势；</li><li><strong>OKKICRM</strong>：聚焦“外贸场景分析”，支持<strong>客户采购频率+供应商交货周期+汇率波动</strong>的联动分析（如“某客户最近3个月采购量下降，同时供应商交货延迟2天，建议调整报价”）。</li></ul><p><strong>统计分析的“场景深度”决定价值</strong>：</p><ul><li>超兔适合<strong>全行业的综合分析</strong>；</li><li>OKKICRM适合<strong>外贸企业的精准分析</strong>；</li><li>Dolibarr/橙子CRM仅能提供“销售业绩表”等基础报表，无法支撑复杂决策。</li></ul><h3>（五）复购流失预警：从“被动挽留”到“主动预测”的转变</h3><p>复购流失预警是CRM的“增长引擎”，其核心是<strong>用数据识别客户行为信号，提前干预</strong>。我们用<strong>流程图</strong>展示超兔的复购流失预警逻辑：</p><p>!<a href="" target="_blank"/></p><pre><code>flowchart TD
    A[数据采集：客户消费记录（时间/金额/频率）+ 沟通历史] --&gt; B[数据模型：RFM分析（最近消费R/频率F/金额M）]
    B --&gt; C[预警触发]
    C --&gt; C1[复购预警：消费间隔接近阈值（如“最近3次消费间隔从7天延长到15天”）]
    C --&gt; C2[流失预警：消费间隔超过阈值（如“60天未消费”）]
    C --&gt; D[自动化动作]
    D --&gt; D1[AI待办：提醒业务员跟进复购]
    D --&gt; D2[自动邮件：发送专属优惠券（针对流失客户）]
    D --&gt; D3[客服提醒：主动询问客户需求（针对高价值流失客户）]</code></pre><p><strong>各品牌的预警能力差异</strong>：</p><ul><li>超兔：<strong>RFM模型+消费间隔</strong>双维度预警，且自动触发“AI待办+邮件+客服”动作，落地成本低；</li><li>OKKICRM：<strong>外贸场景定制</strong>（如“客户采购间隔从30天延长到45天，提醒业务员发送新品报价”）；</li><li>Zendesk Sell：<strong>AI识别流失信号</strong>（如“客户最近1个月未打开邮件，自动发送调研问卷”）；</li><li>Dolibarr/橙子CRM：无原生预警功能，需手动导出数据分析，效率低。</li></ul><h2>三、综合性能雷达图</h2><p>我们用<strong>雷达图分值</strong>（1-10分，10分为满分）展示各品牌的综合能力：</p><table><thead><tr><th>品牌</th><th>AI智能</th><th>SFA</th><th>API对接</th><th>统计分析</th><th>复购流失预警</th></tr></thead><tbody><tr><td>超兔一体云</td><td>9</td><td>8.5</td><td>8</td><td>9</td><td>8.5</td></tr><tr><td>YetiForce</td><td>6</td><td>7.5</td><td>8.5</td><td>7</td><td>6.5</td></tr><tr><td>Dolibarr</td><td>3</td><td>6</td><td>7</td><td>5</td><td>4</td></tr><tr><td>橙子CRM</td><td>5</td><td>7</td><td>7.5</td><td>6.5</td><td>5</td></tr><tr><td>销帮帮CRM</td><td>7</td><td>8</td><td>8</td><td>7.5</td><td>6.5</td></tr><tr><td>Zendesk Sell</td><td>8</td><td>8.5</td><td>7.5</td><td>8</td><td>7.5</td></tr><tr><td>OKKICRM</td><td>7.5</td><td>8</td><td>7</td><td>8.5</td><td>9</td></tr></tbody></table><h2>四、选型建议：匹配业务场景是关键</h2><p>根据各品牌的核心优势，给出以下选型建议：</p><ol><li><strong>需要AI自动化的企业</strong>：选超兔一体云（原生AI覆盖多场景，无需扩展）；</li><li><strong>制造/贸易企业</strong>：选YetiForce（开源+订单-库存联动，适配生产场景）；</li><li><strong>外贸企业</strong>：选OKKICRM（外贸场景定制，复购预警精准）；</li><li><strong>中小微企业（无技术团队）</strong> ：选橙子CRM（简单易用，抖音/小红书客资导入）；</li><li><strong>海外业务企业</strong>：选Zendesk Sell（海外销售流程适配，AI销售建议）。</li></ol><h2>结论</h2><p>CRM的核心价值不是“功能多”，而是“匹配业务场景”。超兔的“AI+多跟单模型”适合<strong>业务多元化的企业</strong>，YetiForce的“开源+流程定制”适合<strong>有技术团队的制造企业</strong>，OKKICRM的“外贸场景优化”适合<strong>跨境企业</strong>。企业选型时需优先考虑“当前业务的核心痛点”（如AI自动化/流程适配/外贸场景），而非盲目追求“全功能”。</p><p>（注：文中功能相关描述均基于公开披露信息，具体功能服务以厂商实际落地版本为准。）</p>]]></description></item><item>    <title><![CDATA[IP归属地数据赋能在线用户匹配：构建精准、高效的社交连接 用户bPbDqZf ]]></title>    <link>https://segmentfault.com/a/1190000047601339</link>    <guid>https://segmentfault.com/a/1190000047601339</guid>    <pubDate>2026-02-09 12:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在移动互联网与社交软件蓬勃发展的今天，基于地理位置的“附近的人”、“同城交友”已成为提升用户活跃度与粘性的核心功能。然而，当用户出于隐私考虑关闭手机GPS定位时，这一体验链条便面临中断的风险。此时，IP地址归属地数据服务作为一种高效、非侵入式的替代方案，展现出不可或缺的价值。它能够在不依赖精确GPS信号的情况下，智能推断用户的大致地理位置，从而持续驱动同城社交、跨语言匹配及本地化内容推送等关键场景，确保社交软件的连接价值与用户体验不受损。<br/><img width="665" height="363" referrerpolicy="no-referrer" src="/img/bVdnTrF" alt="image.png" title="image.png"/></p><p>一、 同城社交匹配：基于IP的地理位置推断</p><p>当用户禁用GPS时，应用无法获取其精确的经纬度坐标。此时，通过集成高精度的IP地址归属地查询API（例如埃文科技提供的服务），应用可以实时解析用户当前连接网络所分配的IP地址，并将其映射至城市甚至区县级的地理位置。这一技术原理依赖于全球IP地址段的精心维护与地理映射数据库。基于此推断出的地理位置，系统能够优先将用户与同一城市或相邻区域的在线用户进行匹配推荐。地域的相近性天然地带来了更多共同的生活圈、文化背景和线下见面可能性，极大地提升了匹配的潜在价值与用户的互动意愿，让社交软件即使在定位功能关闭时，仍能维持其“发现身边朋友”的核心乐趣，有效提升用户粘性与平台活跃度。</p><p>二、 跨区域语种与内容智能适配</p><p>在全球化的业务场景中，用户可能遍布世界各地。IP归属地数据在此扮演了“文化桥梁”的角色。通过判断用户IP地址所属的国家或地区，系统可以智能分析其对应的主流语言环境。在此基础上，可实施两种关键优化：</p><p>语种匹配：在多人聊天室、游戏组队或语言学习社区等场景中，优先将使用同一种语言的用户匹配在一起。这从根本上消除了沟通障碍，提升了交流效率与匹配满意度，使全球用户能够无缝连接。</p><p>本地化内容推送：根据用户所在地，动态调整其看到的资讯内容、广告活动或优惠信息。例如，向北京用户推送本地生活新闻和商圈折扣，向上海用户展示艺术展览信息。这种高度本地化的内容呈现，不仅显著提高了用户的关注度与接受度，也极大地增强了广告投放的精准性与商业转化效率，提升了产品的整体商业价值。</p><p>三、 融合多维数据的智能匹配演进</p><p>需要指出的是，最先进的用户匹配系统绝非仅依赖单一的地理维度。IP归属地是一个强大的启动器和基础过滤器，而最佳的社交体验来自于多维数据的融合与智能计算。正如前沿技术实践所示，成熟的匹配系统会结合用户的兴趣标签（通过分析行为提取）、社交画像乃至虚拟形象特征等进行综合考量。例如，系统可先通过IP定位筛选出同城潜在用户池，再通过算法计算这些用户与目标用户在兴趣爱好、性格测试（如MBTI）结果或行为模式上的相似度，进行二次精准排序与推荐。这种“地理位置+兴趣图谱”的双层过滤模型，既能保障社交的在地便利性，又能确保连接的内容相关性与深度，从而实现从“简单推荐”到“智能邂逅”的体验升级。</p><p>结语：</p><p>IP地址归属地数据是在线用户匹配体系中一项稳定而高效的基础设施。它巧妙地在用户隐私（不强制开启GPS）与社交需求（同城连接、本地化内容）之间取得了平衡。对于社交平台开发者而言，选择如埃文科技所提供的精准、可靠、低延迟的IP地理位置API服务，并将其与用户兴趣模型、行为分析等上层智能算法有机结合，是构建一个全天候、全场景、高满意度的社交匹配引擎的关键一步。通过数据驱动的智能连接，让每一次匹配都更贴近用户真实的生活与兴趣世界，方能铸就持久的产品吸引力与社区活力。</p>]]></description></item><item>    <title><![CDATA[嵌入式处理器架构 良许 ]]></title>    <link>https://segmentfault.com/a/1190000047600851</link>    <guid>https://segmentfault.com/a/1190000047600851</guid>    <pubDate>2026-02-09 11:07:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大家好，我是良许。</p><p>在嵌入式开发的这些年里，我接触过各种各样的处理器架构，从最早做单片机时用的51内核，到后来做汽车电子时用的ARM Cortex-A系列，再到现在项目中偶尔会碰到的RISC-V架构。</p><p>每次换一个新架构，都需要重新熟悉它的特性和开发方式。</p><p>今天就和大家聊聊嵌入式处理器架构这个话题，帮助大家建立一个系统的认知框架。</p><h2>1. 什么是处理器架构</h2><p>处理器架构，简单来说就是处理器的设计蓝图和规范。</p><p>它定义了处理器如何执行指令、如何管理内存、如何与外设交互等一系列核心问题。</p><p>就像盖房子需要先有建筑设计图纸一样，处理器的制造也需要先有架构设计。</p><p>从技术角度来看，处理器架构主要包含以下几个方面：</p><p><strong>1.1 指令集架构（ISA）</strong></p><p>指令集架构是处理器架构的核心，它定义了处理器能够识别和执行的所有指令。</p><p>比如ARM架构有自己的指令集，x86架构也有自己的指令集，它们是完全不同的。</p><p>这就像不同的语言一样，说中文的人听不懂英文，反之亦然。</p><p>在我刚开始做嵌入式开发的时候，用的是51单片机，它的指令集非常简单，只有几十条指令。</p><p>后来转到ARM平台，发现ARM的指令集要复杂得多，但也更加强大和灵活。</p><p><strong>1.2 寄存器组织</strong></p><p>寄存器是处理器内部用于临时存储数据的高速存储单元。</p><p>不同的架构有不同数量和类型的寄存器。</p><p>比如ARM Cortex-M系列有16个通用寄存器，而x86架构的寄存器组织方式就完全不同。</p><p><strong>1.3 内存管理</strong></p><p>处理器如何访问和管理内存也是架构的重要组成部分。</p><p>有些架构支持虚拟内存管理单元（MMU），有些只支持内存保护单元（MPU），还有些什么都不支持。</p><p>这直接影响到系统能否运行复杂的操作系统。</p><p><strong>1.4 流水线和执行单元</strong></p><p>现代处理器通常采用流水线技术来提高执行效率。</p><p>不同架构的流水线级数、执行单元数量和组织方式都不相同，这直接影响到处理器的性能表现。</p><h2>2. 主流嵌入式处理器架构</h2><h3>2.1 ARM架构</h3><p>ARM架构可以说是嵌入式领域的绝对霸主，市场占有率超过90%。</p><p>我在外企做汽车电子的时候，用的就是ARM Cortex-A系列处理器。</p><p>ARM架构的成功主要得益于其低功耗、高性能和良好的生态系统。</p><p>ARM架构主要分为以下几个系列：</p><p><strong>2.1.1 ARM Cortex-M系列</strong></p><p>这是专门为微控制器（MCU）设计的系列，主打低功耗和实时性。</p><p>我们常用的STM32就是基于Cortex-M内核的。</p><p>比如STM32F103使用的是Cortex-M3内核，STM32F407使用的是Cortex-M4内核（带DSP指令和浮点运算单元）。</p><p>下面是一个简单的STM32 HAL库示例，展示如何初始化GPIO：</p><pre><code class="c">#include "stm32f4xx_hal.h"

void GPIO_Init_Example(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    /* 使能GPIOA时钟 */
    __HAL_RCC_GPIOA_CLK_ENABLE();
    
    /* 配置PA5引脚为输出模式 */
    GPIO_InitStruct.Pin = GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  // 推挽输出
    GPIO_InitStruct.Pull = GPIO_NOPULL;          // 无上下拉
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; // 低速
    
    HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);
    
    /* 点亮LED */
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
}</code></pre><p><strong>2.1.2 ARM Cortex-A系列</strong></p><p>这是为应用处理器设计的系列，性能强大，支持运行Linux等复杂操作系统。</p><p>我在外企做的汽车娱乐系统就是基于Cortex-A9的处理器，运行的是定制版的Linux系统。</p><p>这类处理器通常主频在几百MHz到几GHz之间，支持MMU、多核心等高级特性。</p><p><strong>2.1.3 ARM Cortex-R系列</strong></p><p>这是为实时系统设计的系列，介于M系列和A系列之间。</p><p>主要用于对实时性要求极高的场合，比如汽车的安全系统、工业控制等。</p><h3>2.2 x86/x64架构</h3><p>x86架构主要由Intel和AMD主导，在PC和服务器领域占据统治地位。</p><p>虽然在传统嵌入式领域应用不多，但在工业PC、边缘计算等场景中也有一定的应用。</p><p>x86架构的特点是性能强大、生态成熟，但功耗相对较高。</p><p>Intel推出的Atom系列处理器就是专门针对嵌入式和移动设备的低功耗版本。</p><p>我见过一些工业控制系统使用x86架构的嵌入式主板，主要是因为需要运行一些只有x86版本的专业软件。</p><h3>2.3 RISC-V架构</h3><p>RISC-V是近年来异军突起的开源指令集架构，由加州大学伯克利分校开发。</p><p>它最大的特点就是完全开源，任何人都可以免费使用，不需要支付授权费用。</p><p>RISC-V采用模块化设计，基础指令集非常精简，只有40多条指令，然后可以根据需要添加各种扩展模块。</p><p>这种设计理念非常适合定制化需求强烈的嵌入式应用。</p><p>虽然RISC-V目前的生态还不如ARM成熟，但发展势头非常迅猛。</p><p>国内很多芯片厂商都在积极布局RISC-V，比如平头哥、芯来科技等。</p><p>我最近也在关注RISC-V的发展，考虑在一些新项目中尝试使用。</p><h3>2.4 MIPS架构</h3><p>MIPS架构曾经在嵌入式领域占有一席之地，特别是在网络设备和消费电子产品中。</p><p>但近年来市场份额逐渐被ARM蚕食。</p><p>MIPS的特点是指令集简洁、流水线效率高，但生态系统相对薄弱。</p><h3>2.5 其他架构</h3><p>除了上述主流架构，还有一些专用或小众架构，比如：</p><ul><li><strong>PowerPC架构</strong>：主要用于航空航天、工业控制等高可靠性领域</li><li><strong>AVR架构</strong>：Arduino使用的就是AVR内核的单片机</li><li><strong>8051架构</strong>：虽然古老，但在一些简单应用中仍然活跃</li><li><strong>DSP架构</strong>：专门用于数字信号处理的架构，如TI的C2000系列</li></ul><h2>3. 处理器架构的关键特性</h2><h3>3.1 RISC vs CISC</h3><p>处理器架构从指令集设计理念上可以分为RISC（精简指令集）和CISC（复杂指令集）两大类。</p><p><strong>RISC架构</strong>的特点是指令数量少、指令格式统一、每条指令执行时间固定。</p><p>ARM、RISC-V、MIPS都属于RISC架构。</p><p>RISC架构的优势是设计简单、功耗低、容易实现流水线，非常适合嵌入式应用。</p><p><strong>CISC架构</strong>的特点是指令数量多、指令功能复杂、指令长度可变。</p><p>x86就是典型的CISC架构。</p><p>CISC架构的优势是代码密度高、功能强大，但设计复杂、功耗较高。</p><p>在实际开发中，我发现RISC架构的处理器通常更容易上手，汇编代码也更容易理解。</p><p>比如ARM的汇编代码就比x86的汇编代码简洁很多。</p><h3>3.2 位宽</h3><p>处理器的位宽指的是处理器一次能处理的数据位数。</p><p>常见的有8位、16位、32位和64位。</p><ul><li><strong>8位处理器</strong>：如8051、AVR，适合简单控制应用</li><li><strong>16位处理器</strong>：如MSP430，性能和功耗的平衡点</li><li><strong>32位处理器</strong>：如ARM Cortex-M、STM32，目前嵌入式主流</li><li><strong>64位处理器</strong>：如ARM Cortex-A53/A72，用于高性能应用</li></ul><p>位宽越大，处理器能够直接处理的数据范围就越大，寻址空间也越大。</p><p>但位宽增加也会带来功耗和成本的增加。</p><p>在实际项目中，需要根据应用需求选择合适的位宽。</p><p>我在做单片机项目的时候，发现32位处理器已经成为主流选择。</p><p>即使是一些简单的应用，也倾向于使用32位MCU，因为价格已经降到了可以接受的范围，而且开发效率更高。</p><h3>3.3 主频和性能</h3><p>处理器的主频（时钟频率）是衡量性能的重要指标之一，但不是唯一指标。</p><p>同样主频的不同架构处理器，性能可能相差很大。</p><p>在嵌入式系统中，我们通常使用DMIPS（Dhrystone MIPS）或CoreMark来衡量处理器的实际性能。</p><p>比如ARM Cortex-M4在100MHz主频下，性能大约是125 DMIPS。</p><p>下面是一个简单的性能测试代码示例：</p><pre><code class="c">#include "stm32f4xx_hal.h"
#include &lt;stdio.h&gt;

#define TEST_ITERATIONS 1000000

void Performance_Test(void)
{
    uint32_t start_tick, end_tick;
    volatile uint32_t result = 0;
    
    /* 记录开始时间 */
    start_tick = HAL_GetTick();
    
    /* 执行测试循环 */
    for(uint32_t i = 0; i &lt; TEST_ITERATIONS; i++)
    {
        result += i * 2;
        result -= i / 2;
    }
    
    /* 记录结束时间 */
    end_tick = HAL_GetTick();
    
    /* 计算执行时间 */
    uint32_t elapsed_time = end_tick - start_tick;
    
    printf("Test completed in %lu ms\n", elapsed_time);
    printf("Result: %lu\n", result);
}</code></pre><h3>3.4 功耗特性</h3><p>功耗是嵌入式系统设计中非常重要的考虑因素，特别是对于电池供电的设备。</p><p>不同架构的处理器在功耗方面差异很大。</p><p>ARM Cortex-M系列在低功耗方面做得非常出色，支持多种低功耗模式：</p><ul><li><strong>Sleep模式</strong>：CPU停止，外设继续运行</li><li><strong>Stop模式</strong>：CPU和大部分外设停止，保持RAM数据</li><li><strong>Standby模式</strong>：仅保持备份寄存器和RTC，功耗最低</li></ul><p>下面是一个进入低功耗模式的示例：</p><pre><code class="c">#include "stm32f4xx_hal.h"

void Enter_Sleep_Mode(void)
{
    /* 挂起SysTick中断 */
    HAL_SuspendTick();
    
    /* 进入Sleep模式 */
    HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
    
    /* 从Sleep模式唤醒后恢复SysTick */
    HAL_ResumeTick();
}

void Enter_Stop_Mode(void)
{
    /* 使能PWR时钟 */
    __HAL_RCC_PWR_CLK_ENABLE();
    
    /* 挂起SysTick中断 */
    HAL_SuspendTick();
    
    /* 进入Stop模式 */
    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
    
    /* 从Stop模式唤醒后重新配置系统时钟 */
    SystemClock_Config();
    
    /* 恢复SysTick */
    HAL_ResumeTick();
}</code></pre><h3>3.5 中断系统</h3><p>中断系统是嵌入式处理器的重要组成部分。</p><p>不同架构的中断系统设计差异很大。</p><p>ARM Cortex-M系列使用NVIC（嵌套向量中断控制器），支持多达240个中断源，每个中断可以配置16个优先级。</p><p>这种设计非常灵活，能够满足复杂应用的需求。</p><p>在实际开发中，合理配置中断优先级非常重要。</p><p>我的经验是：</p><ul><li>高优先级：给时间敏感的任务，如通信协议的超时处理</li><li>中优先级：给普通外设中断，如串口接收、定时器</li><li>低优先级：给不太紧急的任务，如按键扫描</li></ul><pre><code class="c">#include "stm32f4xx_hal.h"

void NVIC_Config_Example(void)
{
    /* 配置USART1中断优先级 */
    HAL_NVIC_SetPriority(USART1_IRQn, 1, 0);  // 抢占优先级1，子优先级0
    HAL_NVIC_EnableIRQ(USART1_IRQn);
    
    /* 配置TIM2中断优先级 */
    HAL_NVIC_SetPriority(TIM2_IRQn, 2, 0);    // 抢占优先级2，子优先级0
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
    
    /* 配置外部中断优先级 */
    HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);   // 抢占优先级0（最高），子优先级0
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);
}</code></pre><h2>4. 如何选择合适的处理器架构</h2><p>在实际项目中，选择合适的处理器架构需要综合考虑多个因素：</p><p><strong>4.1 应用需求</strong></p><p>首先要明确应用的具体需求。</p><p>如果只是简单的控制任务，8位或16位MCU就足够了。</p><p>如果需要运行复杂的算法或操作系统，就需要32位甚至64位的处理器。</p><p>我在做汽车电子项目的时候，因为需要运行Linux系统并处理大量的多媒体数据，所以选择了ARM Cortex-A系列的处理器。</p><p>而在做一些简单的传感器节点时，使用STM32F103这样的Cortex-M3就完全够用。</p><p><strong>4.2 性能要求</strong></p><p>要根据实际的计算量来选择处理器性能。</p><p>过高的性能会造成成本和功耗的浪费，过低的性能又无法满足需求。</p><p>一个实用的方法是：先估算应用的计算量，然后选择性能略高于需求的处理器，留出一定的余量。</p><p>我的经验是留出30%左右的性能余量比较合适。</p><p><strong>4.3 功耗限制</strong></p><p>对于电池供电的设备，功耗是首要考虑因素。</p><p>需要选择支持低功耗模式的处理器，并在软件设计时充分利用这些特性。</p><p><strong>4.4 开发生态</strong></p><p>开发工具链、软件库、技术支持等生态因素也很重要。</p><p>ARM架构在这方面具有明显优势，有大量的开发工具和参考资料可用。</p><p><strong>4.5 成本因素</strong></p><p>处理器的成本包括芯片价格、开发成本、授权费用等。对于大批量产品，即使每颗芯片节省几毛钱，总体也能节省很大一笔费用。</p><p><strong>4.6 长期供货</strong></p><p>嵌入式产品的生命周期通常很长，需要考虑处理器的长期供货能力。</p><p>一些老牌厂商如ST、NXP通常能保证10年以上的供货周期。</p><h2>5. 处理器架构的发展趋势</h2><h3>5.1 异构多核</h3><p>现代嵌入式处理器越来越多地采用异构多核设计，即在一颗芯片上集成不同类型的处理器核心。</p><p>比如ARM的big.LITTLE架构，同时包含高性能核心和低功耗核心，根据负载动态切换。</p><p>在汽车电子领域，我见过一些芯片同时集成Cortex-A核心（运行Linux）、Cortex-R核心（处理实时任务）和Cortex-M核心（控制外设），这种设计能够很好地平衡性能、实时性和功耗。</p><h3>5.2 AI加速</h3><p>随着边缘AI的兴起，越来越多的嵌入式处理器开始集成AI加速单元，如NPU（神经网络处理单元）。</p><p>这些专用硬件能够大幅提升神经网络推理的效率。</p><h3>5.3 安全特性</h3><p>安全性在嵌入式系统中越来越重要。</p><p>现代处理器普遍集成了硬件安全模块，如TrustZone、安全启动、加密引擎等。</p><h3>5.4 开源架构</h3><p>RISC-V等开源架构的兴起，为嵌入式处理器市场带来了新的活力。</p><p>开源架构的优势在于灵活性和可定制性，能够满足特定应用的需求。</p><h2>6. 总结</h2><p>嵌入式处理器架构是一个博大精深的领域，涉及硬件设计、指令集、编译器、操作系统等多个层面。</p><p>作为嵌入式开发者，我们不需要成为架构设计专家，但需要对常见架构有基本的了解，这样才能在项目中做出正确的技术选择。</p><p>在我的职业生涯中，从51单片机到ARM，从简单的裸机程序到复杂的Linux系统，每一次架构的转变都是一次技术能力的提升。</p><p>我的建议是：先深入掌握一种主流架构（比如ARM），然后再去了解其他架构，这样能够建立起系统的知识体系。</p><p>随着技术的发展，新的处理器架构不断涌现，但核心的设计理念是相通的。</p><p>只要掌握了基本原理，学习新架构就会变得容易很多。</p><p>希望这篇文章能够帮助大家建立起对嵌入式处理器架构的整体认识，在实际项目中能够做出更好的技术决策。</p><p><strong>更多编程学习资源</strong></p><ul><li><a href="https://link.segmentfault.com/?enc=3pwJEr37SU15iOHL7MpVrg%3D%3D.ER12f9oP9bUrmutp7VmJKU111huBqmTfMj1BiRP1Tw9jrbc%2F8SZvgoqY6b0asAkPkMKTla6nsmGRVkHDLETEzQ%3D%3D" rel="nofollow" target="_blank">C语言零基础入门电子书-2026最新版</a></li><li><a href="https://link.segmentfault.com/?enc=pW2Kf3Y4dlUkQ7bSoR1Jsg%3D%3D.UoSinbD7qc1XsmSVe0KAK%2Fjy3qA35PqMMDDAd37393Ydil70EHkzlkyXamQklPVuVF6QabBP0FqoD3%2FzHsetxw%3D%3D" rel="nofollow" target="_blank">STM32零基础入门电子书-2026最新版</a></li><li><a href="https://link.segmentfault.com/?enc=AdMWySbNpwUVzUtgnBkZ8g%3D%3D.gwc6tX7rHtoCEwtqfkQ%2FOlr1tQtcOcOvqOKPxminKw21Q23CdHxpQfDj2DipzE0K9vrV2vNepOxrl%2FAS6UKGZ86XozAEqX7jLy5kKgX8K%2BA%3D" rel="nofollow" target="_blank">FreeRTOS零基础入门电子书-2026最新版</a></li><li><a href="https://link.segmentfault.com/?enc=JlnEvXVxqKElHyZ3XJ%2BZqA%3D%3D.JDWfXB04gF8Y3ZAsA6wOkqAImhRvsXeoindh%2FSqJkk9A8R8lvtyKIc8VXMgbZuPhlWsVHsiDuaGM2DaDSaP2LQ%3D%3D" rel="nofollow" target="_blank">C++ 零基础入门电子书-2026最新版</a></li><li><a href="https://link.segmentfault.com/?enc=Ham2mFpd%2FY7E70lx0t1xCg%3D%3D.p%2F%2F%2B7ecHx7gfTsHeTmq1fmuAtntW3wQ4f6hbLtpe7J%2F08Bp%2BTNiAWlYibGKynMV%2FhCTKz3f64cWymizZFn3H%2FQ%3D%3D" rel="nofollow" target="_blank">51单片机零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=vwI8v%2FiP1Ja0QbjnpulTsw%3D%3D.XNgC0bOLVYAIX2l0zrzSzcCUAXQU6CDaSNnLE4fwFIgyMpk8icgi6tHqGxPco2N8nqyVymeKkhyQualspi6tmw%3D%3D" rel="nofollow" target="_blank">AD画板零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=tA9of6ZP20DY1Q9ILmIRwQ%3D%3D.6eFmf9Zba47YJLFtDAo786qmcuXUDxTu23D8I6NV2db9ai1Irc0%2BNw0bBRVy8SHN52km9u2NbvRIC2Dlq7MLVQ%3D%3D" rel="nofollow" target="_blank">C语言零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=dTiKBuYCvzsSjIdLr7FaVg%3D%3D.KpFyl6zDK57N0fA06EDzsOP535Cgkaut%2FadVkouTz3kV8PgBQ6jcCnU4vFGn3b9PQq3ft43YQJVTkFWJFkGCOQ%3D%3D" rel="nofollow" target="_blank">C++语言零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=yR4PLJU0QeSbIRlM37PliA%3D%3D.KzwpnvnWVTWu7KMrCI0kO80gRdPWgeXPZN9SCQgATDOq3nvj%2FTtcaY1sLVvJwhHw%2F%2Bfs2FmvFsesHkyt%2Fx%2Fn2pMgZxT1WKd4IM4V8Z7AyJ4%3D" rel="nofollow" target="_blank">ESP32零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=Il06SO1Q0hDPGIDEKeK31A%3D%3D.ApIaLzdSCaQBAZ6LlqCyJTzf1C5aN5A9o%2BCDHsN5GKzHf97M5lBoYQSSnLUQ2Qpx%2Bna4HYk3Qx8H2UZ%2Fk1neoRWSLZE7yvjT2zZ7BV0h%2Fgg%3D" rel="nofollow" target="_blank">FreeRTOS零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=IvzVHcmzMZId%2FUu8tTTvdA%3D%3D.Lh8RD%2BQTO%2BOFgVfm6kxLMWUk%2FBs91JujT3zAThiKco9FkZ8qyc2Wjs83zmut7fqGTX9iyXym0bEhisLB7sGqo%2F1uKXAysCLhPdGIPH6OlrM%3D" rel="nofollow" target="_blank">Linux应用开发零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=wqjFSxl2hwrePSwHzOV64w%3D%3D.GlkgkAvhVQcNCloNlU85Y9bnlXyf5I%2FvmsKqmG11TCuwvIDuyfhflCcwYw94CXXRd4hHhkQmlYcjBYbQpjX%2F77Nkqlt3nBrA%2B4GrJtO7p0Y%3D" rel="nofollow" target="_blank">Linux底层开发零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=dlchjKLca21omuDnwKrf5A%3D%3D.c4OmquowV5JW2bs6%2F1mrVNOySSKahCScyAHNewwDvS%2FsvXyM6RNCNB4SoeNqKsJ6fYW%2B5bMV5MwA%2BJAl9Brq8A%3D%3D" rel="nofollow" target="_blank">LVGL零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=yPnGM%2BabZbrLET4roslS0w%3D%3D.2ff8gEnJV7ALK8CK6b8Ko%2FWGQo3689VfEC4FFXHpZDGp%2F1LfUTU%2B36Law6qLcHrN46AvunNopbFySRMUg6vkCg%3D%3D" rel="nofollow" target="_blank">QT零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=ra2JWnQJZJdBjExEAmt8tg%3D%3D.vMZ5pb%2FGtmr%2BwvSnipjKYdXO2ZLQB1bZYSJUUGXoW3l%2FoWoNZUweZj19uQcBZOmXu%2F0T8eAooVDypn0N6hT6c%2BzQ54JKADmHNHmGw9A89RQ%3D" rel="nofollow" target="_blank">STM32零基础入门学习路线</a></li></ul>]]></description></item><item>    <title><![CDATA[【TVM教程】TensorIR 超神经HyperAI ]]></title>    <link>https://segmentfault.com/a/1190000047600854</link>    <guid>https://segmentfault.com/a/1190000047600854</guid>    <pubDate>2026-02-09 11:06:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>TVM 现已更新到 0.21.0 版本，TVM 中文文档已经和新版本对齐。</p><p>Apache TVM 是一个深度的深度学习编译框架，适用于 CPU、GPU 和各种机器学习加速芯片。</p><p>在线运行 TVM 学习教程→<a href="https://link.segmentfault.com/?enc=raR1AhWPiWDTPmyIp4oI6Q%3D%3D.XjKFO3TWVpS4aUmR%2BbH7z61kOYziM1NnQwASZL%2BWZOg%3D" rel="nofollow" target="_blank">https://go.hyper.ai/PEh1Q</a></p><p>TensorIR 是 Apache TVM 栈中的核心抽象之一，用于表示和优化原始的张量函数。</p><ul><li><p><a href="https://link.segmentfault.com/?enc=zfkyRHm8I2z8HbFh%2B5ISfA%3D%3D.zVOUuAJiUzJx91SaXz9mamDGF1d%2FzMmpcfAWWqjzoRqj%2Be9KzrXWsGmL8p%2FblTsAT0xtxVOM8vmDy5YzXuB0p7Q3DxodOGvnRGP9US4WkU4%3D" rel="nofollow" target="_blank">张量程序抽象</a></p><ul><li><a href="https://link.segmentfault.com/?enc=%2BNB9hEvekQtSqB9kkbXExA%3D%3D.Iv9WIitAty%2Bm1WpNBK90aPH229b7SofjjEr5Y3o%2FYENF9%2Bd6Dw8yoI1u1fJ5it4%2FXPJ68Yyfyp6gDjcW4DohKZoyYrbO%2FOAvisqgEn4EnKtpbgCrTdK9pv2w6zAeCNNJNRm%2BHZPN02UWDBwjJ%2FmWOAEyn%2BEzVYeVG7OAtHUlbVMNKeRhvL%2FBrIToVpD%2FtPev8tNf54GiB1jt%2BkrjxF93Lg%3D%3D" rel="nofollow" target="_blank">张量程序的关键元素</a></li><li><a href="https://link.segmentfault.com/?enc=JYw0hlFiDD67Ja6P0xUXjg%3D%3D.SDmFhupj1FvXAW0uJ4hjyK%2FzADT6qVc3OwUJm71zAuqVnDgNywbo3FdLkNBrr1o3X8WbEihiR5C%2F4Kt%2BqvMG%2Fvl1BW4jLVhCns8P1meFxYHt65OVkWpb3QHa6edbIh4FyMbSnENzVF%2FZcnqnjPTa2jV2JC8%2BxIu%2FPK20Mwp7vXn9jlSdrbuKQDUXCh%2Ft2OCj" rel="nofollow" target="_blank">TensorIR 中的额外结构</a></li></ul></li><li><p><a href="https://link.segmentfault.com/?enc=dHgGPvD024fPdkIwduMUpA%3D%3D.%2FHMZP0EVjtydBwk8jX02Q2%2FILRQq8CK0FcfPnZ%2B5lka%2BrPpAnTCH7d%2B2%2BbX2e3F8lteX%2Fvpw3CwpnLH32Q2ferMNCfP1A60fytRskGsLbDg%3D" rel="nofollow" target="_blank">理解 TensorIR 抽象</a></p><ul><li><a href="https://link.segmentfault.com/?enc=TkAvZjJ2W5SOZ1B3ZHcckA%3D%3D.1%2B6YPwxPmYa1uNAZkGjnfDRygs9q38VisOpiTOLUHhY9MZsAC%2FYrPRWCVyJ44YwpoBHY1VHcKgg1YnBzCStt8Qa%2FQmXEOnjAJNCf6%2B9Y5LrzHMHLwWSg4j7GcxJBX2TFMwyC3qnpV2d1dAYJwBIz1biiqybLxPJRr3s3f0qxs32M2GLNalWaZf04UN7Im2sAfNOQ8qg3xIto2A%2FnmHQoPQ%3D%3D" rel="nofollow" target="_blank">函数参数与缓冲区</a></li><li><a href="https://link.segmentfault.com/?enc=QVHo1lPT5iWT2I2Jj6TUcw%3D%3D.0Wsrot8iWC1EC%2BG1fmuj8clrJ2mcC74qqK3mkr6aB79mcIdLKKmFpKmM7iqI7NfRo%2B%2BFYX8tmTyMLJF6mTO62Egre0nBxvSQImcwqtrub1CFExSY67wiEF9dIarW%2F31PhQKIMRwOQMHOqy17bOwqkObmLtil7Jj1ZVXzZR65UqQ%3D" rel="nofollow" target="_blank">循环迭代</a></li><li><a href="https://link.segmentfault.com/?enc=4q5RGsvp%2BT9DAG06Gq4YuA%3D%3D.XAsyNP8EsqV3EUzyOuqJwTGpBBS2nlEYTNlT5isGrAHmU1hFXTzlKuHutsrsgNJY%2FSa80RfQPWAN3NNEaton8nFbPp6Vw%2B0uRl8r%2Bl5VlOIMPRQFYrawRlFn1LcpfmXMNGvj3nFMpnMM%2FXC%2BygRptw%3D%3D" rel="nofollow" target="_blank">计算块</a></li><li><a href="https://link.segmentfault.com/?enc=UN9ZFy3iDUGpCQkrZvjHLw%3D%3D.PwtO0m6hVyK4%2FBj4Qq1a%2BPNZ8pXZ3pVwsCpnzzxof%2BIFIAFVDIkwOABWyLdA9tHySjLHD%2FqLR1mX1KmJfIMZt5muM1Xwdc9zFlZpGJG9heiyCpI9bqsUW0PZsJhYNWb8poiNXtP8tiNSQXNRSIUArOtEsqWiu0c7036GC62ckSY%3D" rel="nofollow" target="_blank">块轴属性</a></li><li><a href="https://link.segmentfault.com/?enc=zpvMjKTERNTmsunrB2LutQ%3D%3D.o3IhN0Fn1cxhAilIOw09wudZc3xEqPqXoRkE5B06abqyx2HwcMf33pI9x%2FmvKrkB4G9i%2BDmCMFzqxz0qgo1hWbbvcoPoxux%2FIHCwOjV%2BL8ZhVcP0ehzO3HeUheyH%2FsU8SeU4QaO%2B06BXk05hklittLaFBUNmiuPZYJUPd6Tfg1Y4vpIQSbQBPJUdbnh0L6f7wi5%2FBvpuFZ0xAqoBTDNXvUgp9d508ju%2FhrBuV9xS%2FSYscfBWGHUiaRe4PPSJTvhu" rel="nofollow" target="_blank">为什么计算块中需要额外信息</a></li><li><a href="https://link.segmentfault.com/?enc=JwwhCEWWBb1s73jEQcPJ1w%3D%3D.8DYZlSUEkh50slaZlT5MwksYS8Q6Vw54DDhCXSiMx%2Bai63mPx%2BN4eej9w1A%2BSE5b6Ly0dRBrRNTxa7xsy04XtZBhfxu3yWLDUayV89ORpMILvrDTc6OJdUrIeJVtSNLgRY%2FvoW3Hnnyf4AyglrkcnaJQ%2F84LU1kloJpPadNnm7U0R2stUfx7uXyVv16MM%2FpM" rel="nofollow" target="_blank">绑定块轴的语法</a></li></ul></li><li><p><a href="https://link.segmentfault.com/?enc=9WDjaYu454Xlbbtu0%2Fi1Vg%3D%3D.C9Fg4dk6BqvpL3SGQjSQ9BtXz%2FhjLtPE6umCEp3hRq%2BX4R%2BPb80JxGbP0kl%2BRsT%2FsE0NgeBPfk94uFn1mVKLfA%3D%3D" rel="nofollow" target="_blank">TensorIR 的创建</a></p><ul><li><a href="https://link.segmentfault.com/?enc=1n2A0ian9WP3w590V20rng%3D%3D.bi7GWmBeXWG9WO7H%2FZRG0vC5f1KRJMLwUB%2FOMX8XZ0suYPXTZaKW2ohdUkMmM37IVaeKRFIvtY%2FpxbutR4fOcGbGWTuw%2FpMLY8QEh%2F0OQPHv1vs5yx%2F8FZ859KCwrRobBdXvK3nMV0kho0qeyZ4LH4jc8pPeqXIcripT5BXOlqA%3D" rel="nofollow" target="_blank">使用 TVMScript 创建 TensorIR</a></li><li><a href="https://link.segmentfault.com/?enc=s9co8J%2BB62UkoBQbaDRUmw%3D%3D.VbMJiJMdgivt1nwUtS0C%2BM82X4TUdQztfaWKnmAH12IB09JrTgtZxUxC2DG5eOHSRixV%2BKTCumjB1MCyodQPPxbLTmLKXAOkaAqFcDqjhqQJoU%2B7MqCT6XHXwt8fLZk7E7d51wv0uA%2FlWZy7q3aV5KrgQSOPbra3X7X0%2FkmKilA%3D" rel="nofollow" target="_blank">使用张量表达式创建 TensorIR</a></li></ul></li><li><p><a href="https://link.segmentfault.com/?enc=Lp4Vmg98eATcsrTIqmnbDw%3D%3D.9Brv1fBw%2BLotD25erEIuFeHIzdRCKb3uz8R0j79nLVBxbOxMXnfMoyfdgCPqvdYNcdBFXQMwG4fBVfRqCibA5w%3D%3D" rel="nofollow" target="_blank">转换</a></p><ul><li><a href="https://link.segmentfault.com/?enc=ClNAY2aqjz5XUK%2BtFFWpmQ%3D%3D.9wsX2iv8dq9eC9iBZ%2F6LW1ASXQYffctZGpKD0jEICUhh2wqibwDUwpkXvzVVeTMvPCzRVTeRq0Px%2BAPeND7qJmqzn78c8%2Bg3orsIxBFhCgJeuju0d4mdNZ3EsBEbyYr%2Fjg55wMxMvE4KXbURxU%2B9Bg%3D%3D" rel="nofollow" target="_blank">初始化调度</a></li><li><a href="https://link.segmentfault.com/?enc=ttkmF7DlYD9XvwKqFWosrQ%3D%3D.%2BmcE%2FWmyMLE5SAxAJYUrMw9T%2FpawXq0%2BfFKIIBsi%2BUaKzdPfCIugPvwUoIGRDaATbfIbT8hUdJVuAAvN0957gEIBtQh7iSHtD1DdYMnncVvbloU5Iop0zeV4qb0zF0%2FkHzYizIcHJp63s8ihwFovZg%3D%3D" rel="nofollow" target="_blank">循环切分（Tiling）</a></li><li><a href="https://link.segmentfault.com/?enc=q6wfEqGEB7neHYC8GqI9Lg%3D%3D.%2FUqcSjC8WVr3Lz7avuKjhd34kJEsCNZgJVP87lksIQJmEGyoYpN0QemteZxxcdZFXIrr3zTytnTRp%2Fjlk07Tq%2B%2Fiwkyz%2BvzbXpcwsQfW5eC4c5Lfeo2u3wa2cwSIBOzmP%2BgFMLIbAtHWauEXfI0dCg%3D%3D" rel="nofollow" target="_blank">利用数据局部性</a></li><li><a href="https://link.segmentfault.com/?enc=MyCs5aDHVsjqHZtJjZW63Q%3D%3D.DSjMVENgj4H0RRhDpCnLjbwrD7wo7IgZA4Uul25TR9OamGJoV373wbhk2mJ8V7D2z1LIClZynKlS%2BGQ03VBM%2FxinTygW6tKEpFj5KGUrTBZF%2Ft7VFPB%2FMSwDxFiAKqo%2BH1qQRoriovvIueJ9kVV4YfhF7zbLg904Pwyb43q8qdU%3D" rel="nofollow" target="_blank">重写归约操作</a></li><li><a href="https://link.segmentfault.com/?enc=ZP15so1LMQIXfCC0gPTdZQ%3D%3D.SUXKLlT%2BmAp3yWIiGosLpepcVkxpChOrxfTy4qMYyfjI9XBnaIt2TWy0RsmNB76zWoXQQi5OdWcxPfe%2FTMuu6HidjqNPKonlvuPSTb9kEch05j7qsRlqqlmIDhhexfzWsvVf5hlMHzUMjkFpwNly6g%3D%3D" rel="nofollow" target="_blank">追踪变换过程</a></li></ul></li></ul>]]></description></item><item>    <title><![CDATA[Antigravity-Manager：AI 多账号管家 + API 反代 BugShare ]]></title>    <link>https://segmentfault.com/a/1190000047600869</link>    <guid>https://segmentfault.com/a/1190000047600869</guid>    <pubDate>2026-02-09 11:06:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在 AI 应用日益增长的今天，开发者往往需要同时管理多个服务账号（如 OpenAI、Claude、Gemini 等），并期望将这些服务统一调度、并在本地或服务器上稳定运行。<br/><strong>Antigravity-Manager</strong> 正是这样一款强大的开源工具，它不仅具备专业的账号管理功能，还支持协议转换、中继代理等高级功能，可以与 Claude Code CLI 等客户端无缝集成，让你的 AI 调用更稳定、更智能。</p><hr/><h2>一、Antigravity-Manager 是什么？</h2><p><strong>Antigravity-Manager</strong> 是由社区开发的一款跨平台（Windows / macOS / Linux）桌面应用，用于：</p><ul><li>🧠 <strong>账号管理与一键切换</strong> 多个 AI 服务账号；</li><li>🚀 <strong>协议转换与反代代理</strong>，兼容 OpenAI、Anthropic（Claude CLI）和 Gemini 等；</li><li>⚙️ <strong>智能调度与模型路由</strong>，实现配额管理和请求优先级调度。</li></ul><p>简而言之，它是一个“全能 AI 账号管家 + 本地反代服务端”，帮助你构建个人或团队级的 AI 调用网关。</p><hr/><h2>二、为何使用“账号管理”？</h2><p>在多个 AI 平台同时使用时，你可能面临这些痛点：</p><ul><li>📉 单一账号配额耗尽导致请求失败；</li><li>🔁 切换账号繁琐、缺少一体化管理；</li><li>🔒 难以实时查看每个账号的配额与状态；</li><li>🧠 结合 CLI 工具时，没有统一反代入口。</li></ul><p><strong>Antigravity-Manager 的账号管理（Account Management）模块</strong>正是为了解决这些问题设计的，它提供了 <strong>OAuth 授权、Token 导入、403 自动标注、账号状态健康监控等全套功能</strong>。</p><hr/><h2>三、安装 Antigravity-Manager</h2><p>安装方式非常灵活，覆盖桌面以及服务器环境。</p><h3>✔️ 方式 1：桌面安装（推荐）</h3><p>macOS / Linux（推荐）</p><p>如果你已安装 <strong>Homebrew</strong>：</p><pre><code class="bash">brew tap lbjlaq/antigravity-manager https://github.com/lbjlaq/Antigravity-Manager
brew install --cask antigravity-tools</code></pre><p>安装完成后直接运行客户端进入可视化管理界面。</p><hr/><h3>🪟 方式 2：手动下载安装</h3><p>访问 GitHub Releases 页面，下载对应系统的安装包：</p><p>📦 macOS：<code>.dmg</code><br/>💻 Windows：<code>.msi</code> / <code>.zip</code><br/>🐧 Linux：<code>.deb</code> / <code>AppImage</code><br/>（支持 Apple Silicon、Intel 等主流架构）</p><hr/><h3>🐳 方式 3：Docker 部署（服务器 &amp; NAS）</h3><p>如果希望在NAS/服务器长期运行，可参考：</p><pre><code class="bash">docker run -d \
    --name antigravity-manager \
  -p 8045:8045 \
  -e API_KEY=sk-your-api-key \
  -e WEB_PASSWORD=your-login-password \
  -v ~/.antigravity_tools:/root/.antigravity_tools \
  lbjlaq/antigravity-manager:latest

#### 🔐 鉴权逻辑说明
*   **场景 A：仅设置了 `API_KEY`**
    - **Web 登录**：使用 `API_KEY` 进入后台。
    - **API 调用**：使用 `API_KEY` 进行 AI 请求鉴权。
*   **场景 B：同时设置了 `API_KEY` 和 `WEB_PASSWORD` (推荐)**
    - **Web 登录**：**必须**使用 `WEB_PASSWORD`，使用 API Key 将被拒绝（更安全）。
    - **API 调用**：统一使用 `API_KEY`。这样您可以将 API Key 分发给成员，而保留密码仅供管理员使用。</code></pre><p>这样 Antigravity-Manager 会在容器内自动启动前端服务和反代代理。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600872" alt="PixPin_2026-02-07_19-53-26.png" title="PixPin_2026-02-07_19-53-26.png"/></p><hr/><h2>四、管理账号与接入 Claude Code CLI</h2><h3>🔑 1. 添加账号（OAuth / Token）</h3><p>打开客户端 → “Accounts / 账号” → “添加账号”，你可以：</p><ul><li>使用 <strong>OAuth 2.0 授权</strong> 添加账号，工具会提前生成授权链接，在浏览器完成登录授权后自动保存；</li><li>或者通过 <strong>Token / JSON 批量导入</strong> 已有的 API Key/Session，适合已有账号备份迁移。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600873" alt="1770467416323.png" title="1770467416323.png" loading="lazy"/></p><hr/><h3>📊 2. 账号仪表盘与健康监控</h3><p>在仪表盘中，你可以：</p><ul><li>实时查看账号类型、剩余配额、是否被禁用；</li><li>系统自动标注异常账号（例如 403 禁用），并跳过这些账号；</li><li>一键切换活跃账号，快速调度调用链路。</li></ul><p>这对管理多个付费 / 免费账号极为实用。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600874" alt="PixPin_2026-02-07_20-28-11.png" title="PixPin_2026-02-07_20-28-11.png" loading="lazy"/></p><hr/><h3>🛠 3. 接入 Claude Code CLI 反代</h3><p>Antigravity-Manager 内置了 <strong>Anthropic 协议的反代支持</strong>，可以让 Claude Code CLI 直接走本地代理。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600875" alt="PixPin_2026-02-07_20-33-42.png" title="PixPin_2026-02-07_20-33-42.png" loading="lazy"/></p><h4>📌 方式1：环境变量方式</h4><ol><li>在 Antigravity-Manager 内启用 <strong>API 反代服务</strong>；</li><li>在终端设置环境变量：</li></ol><pre><code class="bash">export ANTHROPIC_API_KEY="sk-antigravity"
export ANTHROPIC_BASE_URL="http://127.0.0.1:8045"</code></pre><ol start="3"><li>启动 <strong>Claude Code CLI</strong>：</li></ol><pre><code class="bash">claude</code></pre><h4>📌 方式2：直接点同步按钮（更爽）</h4><p>更贴心的是作者还提供了通过界面“立即同步配置”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600876" alt="1770467877401.png" title="1770467877401.png" loading="lazy"/></p><p>此时所有 CLI 请求将通过 Antigravity-Manager 的反代服务发出，你可以结合账号池调度，提高稳定性并统一管理日志与配额统计。</p><p>💡 这种方式尤其适用于开发者希望在本地终端环境使用 Claude CLI 工具时，有一个统一的代理层进行账号轮换和失败重试。</p><p>▶️ <strong>除了Claude Code CLI，还支持接入OpenCode、Kilo Code、Python</strong>（可以愉快的开发了）</p><h3>⚡ 4. 也可以启用国内智谱模型</h3><p>如果你需要混用国内模型，只要填 Key 即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047600877" alt="PixPin_2026-02-07_20-49-10.png" title="PixPin_2026-02-07_20-49-10.png" loading="lazy"/></p><hr/><h2>五、使用建议与实战技巧</h2><p>✨ <strong>优化账号池</strong>：将高配额账号置于优先队列，并根据使用场景动态切换，提升成功率。</p><p>✨ <strong>批量导入</strong>：对于大量账号可以提前通过 JSON 导入，避免重复手动输入。</p><p>✨ <strong>结合 CLI 监控日志</strong>：在反代运行中，务必监控 HTTP 返回码（如 429/401）以调整请求策略。</p><p>⚠️ <strong>注意安全</strong>：OAuth 回调是通过本地监听实现的，确保防火墙允许本地回环访问，避免授权失败。</p><hr/><h2>六、总结</h2><p>🚀 <strong>Antigravity-Manager</strong> 不仅是一款强大的 <strong>AI 账号管理工具</strong>，还具备协议反代、模型路由、健康监控等丰富功能。通过它，你可以：</p><p>✔️ 一站式管理多个 AI 平台账号；<br/>✔️ 实现账号配额优先级调度和自动异常跳过；<br/>✔️ 在本地通过反代接入 <strong>Claude Code CLI</strong> 等客户端；<br/>✔️ 提升稳定性、可视化管理体验、避免手动切换误操作。</p><p>无论你是 AI 开发者、研究者，还是需要在终端高效使用 Claude 工具的用户，都可以从 Antigravity-Manager 中受益。</p>]]></description></item><item>    <title><![CDATA[云流技术深度剖析：国内云渲染主流技术与开源和海外厂商技术实测对比 点量实时云渲染 ]]></title>    <link>https://segmentfault.com/a/1190000047600903</link>    <guid>https://segmentfault.com/a/1190000047600903</guid>    <pubDate>2026-02-09 11:05:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在实时云渲染领域，除了国内近几年涌现出几家做实时云渲染（云流）的厂商，满足云游戏、云VR、3D软件云展现等场景的需求外，其实市面上还有一些海外技术方案，甚至也有一些大家关心的开源技术方案，他们各有技术亮点，但实际表现因架构设计、优化方向不同而有一些差异。</p><p>本文就给大家带来这一领域真实的多个产品的介绍，并基于真实硬件环境与统一测试标准，对英伟达Moonlight、金山云鎏光、Parsec及点量云流四款主流方案进行实测对比，从延迟、兼容性、功能完整性等核心维度展开分析，既呈现各方案的技术特点，也为行业选型提供客观参考。</p><h2>一、测试环境与评估标准：保证对比测试的客观性</h2><p>为确保测试结果的公正性与参考价值，本次测试采用统一的硬件配置、网络环境与评估方法，所有数据均为多次实测取有效值：<br/>1、基础测试环境</p><ul><li>硬件配置：服务端均采用Intel i7- 8700K CPU、NVIDIA GTX 1080 GPU、32GB RAM；客户端选用Windows 10/Android 9.0客户端/网页。</li><li>网络环境：网络基于千兆局域网，弱网环境通过Clumsy工具模拟（丢包率 10%−60%、10%−60% 、延迟50- 500ms）。</li><li>测试工具：通过纳秒级时间同步软件生成实时时间戳，采用手机高速拍照抓取两端（真机和串流后的机器）画面差值，精准测量端到端延迟；同步测试多终端兼容性、长时间运行稳定性及不同场景（游戏、桌面、普通应用）的适配效果。</li></ul><p>弱网模拟工具设置的参数如下：<br/><img width="723" height="514" referrerpolicy="no-referrer" src="/img/bVdnTko" alt="" title=""/></p><p>2、核心评估维度<br/>本次对比围绕实时云渲染的核心需求，设立5个关键评估维度：</p><ul><li>延迟表现：含局域网正常网络、弱网环境下的端到端延迟及稳定性；</li><li>兼容性：涵盖GPU适配、终端支持（Windows/Android/iOS/Chrome等）、应用场景适配（游戏/桌面/普通软件）；</li><li>传输与编码：传输协议选型、编码格式支持及弱网抗丢包能力；</li><li>功能完整性：容器化隔离、多用户并发、扩展能力（SDK/API）；</li><li>易用性：部署复杂度、无插件访问支持。</li></ul><h2>二、主流方案实测表现</h2><p>1、英伟达Moonlight：开源方案游戏串流方案<br/>作为基于NVIDIA GameStream的开源串流工具，Moonlight的核心优势集中在游戏场景的低延迟传输。其地址为：<a href="https://link.segmentfault.com/?enc=8i0SEqw7ZVhHD2%2BQq2JTkA%3D%3D.KUgaRSqj2kx1kbnOCMWbLSRELlcEjg%2BjKTOuxCQpymFhd%2FKF1KJbZIZWypbZHrfn" rel="nofollow" target="_blank">https://github.com/moonlight-stream</a></p><p>测试结果如下：</p><ul><li>实测核心数据：局域网正常环境下延迟稳定在18~19ms，长时间运行（30分钟）无波动，均为18~19ms延迟；弱网环境（10%丢包+50ms延迟）下延迟波动至18-35ms，画面无明显花屏。</li><li>客户端兼容性：支持windows、android、iOS等客户端模式，chrome下是通过Extension扩展的方式进行支持，不如WebRTC更具通用性。</li><li>技术特点分析：基于RTSP传输协议并结合了FEC纠错，支持HEVC编码与120fps高刷新率、7.1环绕声支持；客户端基于ffmpeg+sdI进行解码播放；开源特性使其具备一定定制空间。</li><li>局限与不足：英伟达出品，自然GPU有限性，仅支持NVIDIA相关系列显卡（NVIDIA GeForceGTX/RTX600+系列GPU），不兼容AMD及集成显卡；Web端需通过Chrome扩展实现访问，操作便捷性不足；仅聚焦游戏串流，不支持桌面串流和普通软件（如CAD等软件）流化。</li></ul><p>测试截图如下：<br/><img width="723" height="337" referrerpolicy="no-referrer" src="/img/bVdnTkp" alt="" title="" loading="lazy"/></p><p>2、金山云鎏光：原型级方案，具备超低延迟潜力<br/>鎏光是金山云推出的云游戏引擎原型，核心亮点是极致的延迟控制，<a href="https://link.segmentfault.com/?enc=TwTADO%2FNXku%2BGzVpdXqcVQ%3D%3D.B4qr1cUnjrjTp%2BkSW00fccbJsnGftnGA6lvA0UtIRvc%3D" rel="nofollow" target="_blank">https://github.com/ksyun-</a> kenc/liyuguang</p><ul><li>实测核心数据：局域网环境下延迟表现突出，多次捕获0ms同步画面，平均延迟0-17ms；即使在60%丢包+500ms延迟的极端弱网环境下，仍能保持0-17ms的低延迟水平，抗丢包能力亮眼。（注意：0ms，并不代表该方案是0延迟，是因为我们的测试方法是基于2台显示器的拍照，显示器在60fps下，也有大概16.7ms的刷新率延迟。如果整体端对端延迟小于16.7ms的显示器刷新率，在同一次显示器刷新间隔中，画面就显示出来了，看到的效果就是完全一样的画面，也就是0ms延迟。）</li><li>客户端兼容性：提供Windows客户端（但未开源），暂不支持android、iOS和chrome浏览器。</li><li>技术特点分析：基于WebSocket传输协议，编码解码采用FFmpeg+SDL架构，在游戏画面捕获与传输的延迟控制上表现出色。</li><li>局限与不足：目前仅支持Windows客户端，未开源且缺乏Android、iOS、Web等多终端适配；功能处于原型阶段，展现的是核心功能，方便用户进行扩展，应该是为了金山云跟游戏厂商的云游戏战略服务。功能上欠缺不少产品化的功能：比如不支持桌面抓取、多应用实例隔离等商用必备功能，无法直接用于产品级落地。</li></ul><p>测试截图如下：<br/><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnTkq" alt="" title="" loading="lazy"/><br/><img width="723" height="549" referrerpolicy="no-referrer" src="/img/bVdnTkr" alt="" title="" loading="lazy"/></p><p>3、Parsec：海外商业软件的优秀全终端方案<br/>Parsec是兼具云游戏与远程控制功能的商业软件，主打多终端覆盖与易用性。</p><ul><li>延迟核心数据：局域网环境下延迟27-41ms，5分钟后稳定在30ms左右；弱网环境下延迟增加10-15ms，整体波动至37-56ms，延迟控制略逊于前两款方案（可能是要考虑他综合用途的兼容性，并不是专门为云游戏、云VR等设计超低延迟），但稳定性良好。</li><li>客户端兼容性：作为一款商业软件，该产品支持超级多终端，包括Windows、Android、iOS、Linux、Chrome浏览器，甚至还有树莓派等，生态完整。</li><li>技术特点：终端支持全面，产品化优秀，部署简单，通过账号登录即可快速连接，无需复杂配置，适合非技术用户快速上手。</li><li>局限与不足：延迟表现处于行业中等水平，无明显优势；GPU兼容性存在短板，部分旧款或低端GPU易出现驱动不兼容问题；商业授权模式下，定制化与扩展能力有限。</li></ul><p>测试截图如下：<br/><img width="723" height="549" referrerpolicy="no-referrer" src="/img/bVdnTkt" alt="" title="" loading="lazy"/></p><p>4、点量云流：兼顾低延迟与全场景适配的商用方案</p><ul><li>延迟核心数据：局域网环境下表现最优，多次捕获0ms同步画面，平均延迟0-16ms，长时间运行（30分钟）无波动；弱网环境下延迟稳定在10-30ms，抗丢包能力与鉴光相当，且画面无卡顿花屏；跨终端测试中，Windows、Android、Chrome端延迟一致性良好，差值不超过5ms。</li><li>客户端兼容性：提供Windows、Android、国产信创系统（Linux等）客户端，据官方说明，有iOS客户端，但考虑商用客户需求，需客户自行上架。支持Chrome、Edge、微信、QQ、360、Safari等主流浏览器。</li><li>技术特点分析：传输协议客户端采用DLCA（未有详细资料，系该公司自研，据介绍底层支持UDP、TCP、RTSP等协议混合模式切换）；网页端基于深度调优的WebRTC协议；底层代码采用C++11全自主开发，部分应用层为GoLang语言开发，支持国产信创系统和部分国产显卡，并支持软硬解、软硬编切换，终端支持良好，可在华为智慧屏、机顶盒等终端上实现4K/60fps稳定输出。</li><li>优势亮点：具备成熟的容器化隔离技术（其官方介绍为CELL多开机制，应该类似沙盒的某种轻量级隔离技术），支持多实例进程隔离，除支持UE、Unity等3D引擎外，还支持AutoCAD、CATIA、SolidWorks等众多设计软件，可实现多应用同时流化且互不干扰；提供SDK模式，支持权限控制、负载均衡、文件传输等商用扩展功能，适配更多行业场景。</li></ul><p>测试截图如下：<br/><img width="723" height="550" referrerpolicy="no-referrer" src="/img/bVdnTkw" alt="" title="" loading="lazy"/></p><h2>三、综合对比与选型建议：客观看待优势与适配场景</h2><p>主流方案核心指标综合对比<br/><img width="657" height="459" referrerpolicy="no-referrer" src="/img/bVdnTkC" alt="" title="" loading="lazy"/></p><p>实时云渲染的技术竞争，其实要追溯到全流程的环节，从死磕画面获取--视频编码--低延迟传输--视频解码--画面低延迟显示绘制。到应用的多开隔离、功能完善度、API接口齐全程度、客户端视频兼容性、国产信创适配度等，最终是场景适配能力的全方位竞争。一个产品最终的特性，是全链路技术优化，而不是某一个环节的优化。更是要与商用需求的精准匹配。</p><p>对于企业而言，选型时应优先明确自身场景的核心诉求（延迟、兼容性、扩展性），再结合实测数据做出判断——这也是本次对比的核心意义所在。</p>]]></description></item><item>    <title><![CDATA[音视频 SDK：连接虚拟与现实的数字桥梁 Amymaomao ]]></title>    <link>https://segmentfault.com/a/1190000047600909</link>    <guid>https://segmentfault.com/a/1190000047600909</guid>    <pubDate>2026-02-09 11:04:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>音视频 SDK：连接虚拟与现实的数字桥梁</p><p>在数字化浪潮中，音视频交互已成为社交、办公、娱乐的标配。无论是微信视频通话、腾讯会议，还是抖音直播，其背后都离不开一个强大的技术底座——音视频 SDK。它就像一座桥梁，将物理世界的声光信号转化为数字世界的比特流，再通过算法优化，为用户提供清晰、流畅、实时的沟通体验。</p><p>一、 什么是音视频 SDK？</p><p>音视频 SDK 是一套软件开发工具包，它封装了音视频采集、编码、传输、解码、渲染等底层技术细节。开发者无需从零研究复杂的音视频编解码协议（如 H.264/H.265）或网络传输协议（如 RTP/RTCP），只需调用 SDK 提供的简单 API，即可快速构建具备专业级音视频能力的应用。</p><p>核心价值：</p><p>• 降本增效：将开发周期从数月缩短至数天，大幅降低技术门槛和人力成本。</p><p>• 专业稳定：由专业团队维护，提供经过海量用户验证的稳定性和抗弱网能力。</p><p>• 功能丰富：集成美颜、降噪、虚拟背景、屏幕共享等增值功能，提升产品竞争力。</p><p>二、 技术架构：从采集到播放的全链路</p><p>一个完整的音视频 SDK 通常包含以下核心模块：</p><ol><li><p>采集层（Capture）</p><p>◦ 音频：通过麦克风采集原始 PCM 数据。</p><p>◦ 视频：通过摄像头采集 YUV/RGB 格式的原始帧。</p></li><li><p>前处理层（Pre-processing）</p><p>◦ 音频：进行 3A 处理（AEC 回声消除、ANS 降噪、AGC 自动增益控制）。</p><p>◦ 视频：进行美颜、滤镜、虚拟背景、人脸识别等处理。</p></li><li><p>编码层（Encode）</p><p>◦ 将庞大的原始数据压缩成适合网络传输的码流（如 H.264/AVC、H.265/HEVC、AAC）。</p></li><li><p>传输层（Transport）</p><p>◦ 基于 UDP 或 QUIC 协议进行数据传输，通过智能路由、抗丢包算法（如 FEC、重传）保障弱网环境下的流畅性。</p></li><li><p>解码层（Decode）</p><p>◦ 将接收到的码流还原为原始数据。</p></li><li><p>后处理与渲染层（Render）</p><p>◦ 音频：进行混音、音效处理，输出到扬声器。</p><p>◦ 视频：进行画面裁剪、缩放，渲染到屏幕视图。</p></li></ol><p>三、 关键能力：衡量 SDK 优劣的标尺</p><p>在选择音视频 SDK 时，开发者应重点关注以下技术指标：</p><p>• 高音质（HD Audio）：支持 Opus、AAC 等高清编码，具备 AI 降噪和啸叫抑制能力。</p><p>• 高画质（HD Video）：支持 1080P/4K 分辨率，具备超分、HDR、低光照增强等画质优化技术。</p><p>• 低延迟（Low Latency）：端到端延迟控制在 100ms 以内，确保实时互动无卡顿。</p><p>• 抗弱网（Network Resilience）：在 80% 丢包环境下仍能保持通话，支持智能路由切换。</p><p>• 高兼容性（Compatibility）：覆盖 Android、iOS、Windows、macOS、Web 等全平台。</p><p>• 扩展性（Scalability）：支持万人互动直播、单房间超大规模通话等场景。</p><p>四、 应用场景：无处不在的实时互动</p><p>• 社交娱乐：视频相亲、语音房、在线 K 歌、游戏开黑。</p><p>• 远程办公：视频会议、远程面试、在线教育、屏幕共享。</p><p>• 物联网（IoT）：智能门铃、车载视频、无人机图传、安防监控。</p><p>五、 选型建议：如何选择适合的 SDK？</p><ol><li>明确业务场景：是 1v1 通话、多人会议，还是万人直播？不同场景对 SDK 的性能要求不同。</li><li>评估技术指标：对比不同厂商的延迟、卡顿率、首帧出图时间等数据。</li><li>测试集成体验：关注文档的完整性、Demo 的易用性以及技术支持响应速度。</li><li>考虑成本与合规：评估 License 费用、数据安全及 GDPR 等合规要求。</li></ol><p>音视频 SDK 是数字化转型的基础设施。随着 5G 和 AI 技术的发展，未来的 SDK 将更加智能化，深度融合 AI 视觉、空间音频、元宇宙交互等能力，为开发者打开更广阔的创新空间。选择一款稳定、高效、易用的 SDK，将是产品在激烈市场竞争中脱颖而出的关键。</p>]]></description></item><item>    <title><![CDATA[【Triton 教程】triton_language.cdiv 超神经HyperAI ]]></title>    <link>https://segmentfault.com/a/1190000047601091</link>    <guid>https://segmentfault.com/a/1190000047601091</guid>    <pubDate>2026-02-09 11:03:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Triton 是一种用于并行编程的语言和编译器。它旨在提供一个基于 Python 的编程环境，以高效编写自定义 DNN 计算内核，并能够在现代 GPU 硬件上以最大吞吐量运行。</p><p>*在线运行 Triton 学习教程 → <a href="https://link.segmentfault.com/?enc=ciGDhT1%2BbfCxoH%2F%2F4usu0A%3D%3D.YNtANz5x5asWF5DeT3ufpn%2BUwlE3EPQqjLTRBZNqjo4%3D" rel="nofollow" target="_blank">https://go.hyper.ai/wS9x1</a></p><pre><code class="js">triton.language.cdiv(x,div)</code></pre><p>计算 <code>x</code> 除以 <code>div</code> 的向上取整结果。</p><p>参数：</p><ul><li><strong>x</strong> (<em>Block</em>) - 输入数字。</li><li><strong>div</strong> (<em>Block</em>) - 除数。</li></ul><p>这个函数也可作为 <code>tensor</code> 的成员函数调用，例如 <code>x.div(...)</code> 而不是 <code>div(x, ...)</code>。</p>]]></description></item><item>    <title><![CDATA[Go语言真正强的领域是什么？ 王中阳讲编程 ]]></title>    <link>https://segmentfault.com/a/1190000047601102</link>    <guid>https://segmentfault.com/a/1190000047601102</guid>    <pubDate>2026-02-09 11:02:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Go 语言以并发实现简单而著称，现在无数云原生项目都在用它。甚至在人工智能领域，它也开始发力了。今天我们就来聊聊这个由谷歌推出的热门编程语言。<img referrerpolicy="no-referrer" src="/img/remote/1460000047601104" alt="" title=""/></p><p>问世十五年多了，Go 语言已经从技术爱好者眼里的“新鲜玩意儿”，成长为支撑全球关键云原生软件的成熟工具。</p><p>你可能好奇，为什么 Docker 和 Kubernetes 这些大项目都选 Go？这篇文章就是为了回答这个问题。我们会聊聊 Go 的核心特点，它和其他语言有什么不同，它最适合干什么，以及它现在的局限和未来。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047601105" alt="" title="" loading="lazy"/></p><h2>Go 语言：小而简单</h2><p>Go（常被称为 Golang）是谷歌员工搞出来的，主要是 Rob Pike 这些 Unix 专家。不过它现在完全是由社区主导的开源项目。</p><p>Go 的设计初衷就是让人好学、好用。它的语法非常直观。和 C++ 这种功能繁多的语言比起来，Go 的功能集很小。它的风格有点像 C，所以如果你懂 C，上手 Go 会很快。不过，Go 在并发处理和函数式编程方面，其实吸收了不少 Erlang 这类语言的思想。</p><p>作为一个类 C 的通用语言，Go 在开发跨平台企业应用上和 Java 挺像。但因为它开发快、运行快，大家也常拿它和 Python 比，虽然它俩其实差别挺大。</p><p>官方文档说 Go 是“一种快速、静态类型的编译型语言，但用起来像动态类型解释型语言”。这话说得没错。就算是大项目，Go 编译起来也就是几秒钟的事。而且它没有 C 语言那种头文件和库引用的麻烦事。</p><h2>Go 语言好在哪？</h2><p>Go 通用、方便、高效、可移植，而且现在支持它的工具也多。这就是为什么大规模软件开发喜欢用它。咱们具体看看。</p><h3>用途广，上手快</h3><p>在解决常见编程问题时，Go 的效率经常被拿来和 Python 比。Go 内置了很多实用功能，比如协程（goroutine）让并发变得很轻量。标准库里的 <code>http</code> 包也很强大。和 Python 一样，Go 也有自动内存管理，不用你自己手动管理内存。</p><h3>速度比很多语言快</h3><p>Go 编译出来的程序，运行速度可能比 C 写的稍微慢一点点，但在绝大多数情况下，这个差距完全可以忽略不计。而在大多数任务中，Go 的性能接近 C，并且明显比 JavaScript、Python 和 Ruby 这些脚本语言快得多。</p><h3>哪儿都能跑，还不挑环境</h3><p>Go 编译出来的是独立的可执行文件，通常不需要依赖外部环境。它支持各种操作系统和硬件，跨平台编译也很容易。更重要的是，它既有高层抽象，又能直接访问底层系统。Go 程序可以直接调 C 库，也能执行原生系统调用。Docker 就是靠 Go 调用 Linux 的底层机制实现了容器功能。</p><h3>支持它的工具多</h3><p>Go 的工具链是免费的，Linux、macOS、Windows 都能用。很多 Linux 发行版都自带 Go。现在的开发环境，从 VS Code 到各种 IDE，对 Go 的支持都很好。</p><h2>Go 语言最适合干什么？</h2><p>没有哪种语言是万能的，但 Go 在某些领域确实表现出色。主要是在云原生开发、分布式网络服务，还有写命令行工具这几块。</p><h3>云原生开发</h3><p>Go 的并发能力强，网络编程支持好，而且可移植性高，这让它成了构建云原生应用的首选。Docker、Kubernetes、Istio 这些云原生计算的核心项目，全是用 Go 写的。</p><h3>分布式网络服务</h3><p>网络应用的关键在于怎么处理并发。Go 原生支持的协程和通道（channel）机制，就是为了解决这个问题设计的。所以，很多网络服务、分布式系统、API、Web 服务器、微服务框架，都是 Go 的强项。</p><h3>命令行工具</h3><p>Go 编译出来的文件基本不依赖外部库，启动快，好分发。这让它特别适合写命令行工具。比如 Teleport 这个工具，你可以直接下载一个预编译好的二进制文件放到服务器上就能跑，非常方便。</p><h2>Go 语言的不足</h2><p>说完优点，咱们也得客观看看 Go 的不足。</p><h3>省略了很多特性</h3><p>Go 为了保持简洁和可读性，故意砍掉了一些常见特性。这一点有人喜欢有人烦。</p><p>比如 Go 不支持宏（在编译期生成代码）。C++ 和 Rust 都有宏，Go 没有。Go 提供了一个 <code>go generate</code> 命令来做代码生成，但这和真正的宏系统还是有差距的。</p><p>另外，Go 很长一段时间都不支持泛型。直到 2022 年发布的 Go 1.18 版本，泛型才终于加进来。</p><p>Go 很少加重大新特性，这保证了版本兼容性，但也让语言演进显得有点慢。</p><h3>二进制文件比较大</h3><p>Go 编译出来的文件体积偏大。因为它是静态链接，把运行需要的东西都打包进去了。这虽然方便部署，但也让文件变大了。一个简单的“Hello World”在 Windows 上可能就有 1.5MB。</p><h3>垃圾回收消耗资源</h3><p>Go 的自动内存管理很方便，但垃圾回收是需要消耗计算资源的。Go 不提供手动内存管理接口。虽然每个新版本都在优化，但在需要极度精细控制内存的场景下，这可能是一个短板。</p><h3>没有标准的图形界面（GUI）</h3><p>Go 主要还是用来写命令行和网络服务的。虽然有第三方库尝试做 GUI，但目前还没有一个公认的标准解决方案。</p><h3>别用 Go 写系统内核</h3><p>Go 可以调用底层接口，但它不适合开发操作系统内核或驱动程序。因为 Go 依赖垃圾回收和运行时，没法完全脱离操作系统独立运行。这种活儿，Rust 更合适。</p><h2>Go 语言的未来</h2><p>Go 的团队现在越来越重视社区的反馈了。泛型的加入就是个例子。</p><p>调查显示，开发者对 Go 总体是满意的。现在的痛点主要在错误处理比较繁琐、框架生态还不够成熟这些方面。</p><p>Go 在网络服务领域的地位已经很稳固了。未来，它在这块还会继续加强。虽然现在用 Go 做 AI 的还不多，但已经有人在尝试了。阻碍 Go 在 AI 领域发展的主要是工具链还不如 Python 完善。</p><p>总的来说，Go 作为一种主流编程语言，地位已经确立了。特别是在云原生开发领域，它兼顾了高性能和开发效率，是构建基础设施的理想选择。</p><blockquote><p><strong>⚡️ 别把时间浪费在低效复习上</strong></p><p>很多人复习抓不住重点。作为过来人，我分析了100+份大厂面试记录，将 <strong>Go/Java/AI 的核心考察点、高频题、易错点</strong> 浓缩进了一份 PDF。</p><p><strong>不搞虚的，全是干货。</strong></p><p><strong>加我微信：wangzhongyang1993</strong>，备注 <strong>【面经】</strong> 免费发你，立即纠正你的复习方向，把时间用在刀刃上。</p><p>wangzhongyang.com 也欢迎大家直接访问我的官网，里面有Go / Java / AI 的资料，<strong>免费学习</strong>！</p></blockquote>]]></description></item>  </channel></rss>