<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[如何通过设备域智能体提升设备运行状态准确]]></title>    <link>https://segmentfault.com/a/1190000047389125</link>    <guid>https://segmentfault.com/a/1190000047389125</guid>    <pubDate>2025-11-11 16:12:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在现代工业体系中，设备作为生产线的核心参与者，其运行状况与维护能力直接影响产品交付效率和企业利润率。然而，传统设备管理往往依赖人工经验，受限于信息隔离与响应滞后，容易陷入生产与维修决策的“两难困局”。设备故障时间点难预测、维修资源难调度、配件库存难平衡，这些被动式管理痛点不仅扰乱了企业的时间链，也耗费了大量人力物力。随着人工智能技术的深入演进，特别是工业智能体这一创新概念的提出，这一局面正在被彻底打破。本文将围绕“设备域智能体”这一核心主题，结合Geega工业智能体平台的实践应用，探讨其如何在制造业中实现从监测到决策的闭环赋能，并为企业提供兼具智能化与可持续性的新方案。<br/>设备域智能体的出现，正是为了填补传统自动化系统与制造业复杂场景之间的巨大鸿沟。它将人工智能与工业实践深度融合，犹如赋予工厂一台具备“火眼金睛”与“决策权柄”的智慧中枢，既能洞悉问题的微兆，又能导向最优解决方案。借助工业智能体的强大感知能力，企业可以实时捕获设备运行参数，诸如温度、振动、压力等，进而结合算法模型对这些碎片化数据进行深度整合与因果推演。这种能力让设备从“被观察的对象”转变为“自我诊断的实体”，不再依赖突如其来的事故发生后的应急响应，而是提前局部预判关键故障，整合全局资源，化被动为主动。<br/>广域铭岛的Geega工业智能体平台便是设备域智能体这一理念的典型具象化。它不仅应对了数据感知的技术需求，更重点解决了多部门协同的难题，在设备维修领域给出了令人瞩目的改进数据。例如，某机械制造企业通过运用Geega平台，将设备配件库存成本显著降低，同时也大大缩短了企业设备停机与维修响应时间，达到了前所未有的运行效率。这一切源于Geega平台对企业业务流程的智能再造——它融合了设备状态数据、维修流程经验以及实时优化能力，把“会思考、会行动”的设备域智能体引入实际操作环节。<br/>但设备域智能体的作用绝非仅仅停留在“警报提醒”或“库存调整”层面。它可以对原有的故障根因进行溯源分析，结合大数据技术建立个性化设备健康档案，从而对设备全生命周期做到精细化管理。在实践中，某汽车工厂设备拆解环节原本极为低效，但引入设备域智能体后，不仅预测维修周期变得更加精准，而且物料配送的认识时间得到了优化平衡，实现“预防胜于治疗”的预期目标。设备域智能体甚至可以自我调节运行节奏，比如在发现某一设备即将出现负载过重风险时，通过边缘计算节点进行自主策略调整，并向云端资源系统发出协同预警，从而在根源和末端之间构建一条无形的高效通道。<br/>设备域智能体的发展不仅带来效率的跃升，更牵动了产业生态结构的变迁。它用动态技术方案重塑了传统制造业的思考模式，逐渐完成了从信息化建设到价值创造的巨变。正如广域铭岛所展示的，设备域智能体在个性化需求预测、资源配置自动协调以及全流程质量安全监控中持续发力，逐渐打开了设备智能化转型的“新齿轮”。<br/>展望未来，随着模型优化能力与边缘计算技术融合的深化，设备域智能体将向更复杂多工况挑战。它将以更高的节奏与智能化水平重新定义工业运维秩序，逐渐走向人机协同更深入、决策更自主的“预测性维护4.0”时代。而这一时代的到来，也是中国制造业在数字化浪潮中实现全球领先的一大契机。<br/>总览全文内容，我们可以清晰地感知到，设备域智能体不是某一项技术工具或算法迭代，而是为多个生产环节之间协同赋能的“中枢神经”。在中国这样一个制造业大国，智能化与自动化从不再仅仅是一场技术革命，而是一条质量升级、效率飞跃、成本下沉的必经之路。广域铭岛的探索为这一趋势绘上了浓墨重彩的一笔，也在论证中坚定地表明：设备域智能体将引领制造业迈向可持续发展的坚实未来。</p>]]></description></item><item>    <title><![CDATA[虚拟机数据恢复—异常断电后ESXI存储连]]></title>    <link>https://segmentfault.com/a/1190000047389134</link>    <guid>https://segmentfault.com/a/1190000047389134</guid>    <pubDate>2025-11-11 16:11:41</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>服务器存储数据恢复环境：</strong><br/>一台服务器上部署esxi虚拟化平台。上层采用通过FreeNAS构建的iSCSI方式FCSAN功能，FreeNAS层采用UFS2文件系统。<br/>esxi虚拟化系统有3台虚拟机。其中一台虚拟机采用FreeBSD系统，存储的是数据库文件；另外一台台虚拟机存储网站数据；第三台虚拟机安装的Windows server操作系统，存储的是数据库数据和工作程序代码。</p><p><strong>服务器存储故障：</strong><br/>机房供电不稳定导致设备非正常关机，重启后发现ESXI系统无法连接存储。服务器管理员对服务器进行故障排查，发现FreeNAS的UFS2文件系统出现故障。服务器管理员对文件系统进行fsck修复并将ESXI系统连接到服务器存储上。<br/>管理员对上层文件系统及数据进行检查，发现原服务器上的文件系统和存储数据都无法识别，于是对vmfs进行了格式化等操作，导致数据丢失。</p><p><strong>服务器存储数据恢复过程：</strong><br/>1、对FreeNAS层进行镜像。镜像完成后基于镜像文件对底层数据分析。北亚企安数据恢复工程师在存储内发现了一个文件名称为iscsidata的大文件。继续分析文件系统结构，根据UFS2文件系统的存储结构定位到这个大文件的iNode数据查看。查看后发现该文件此前被重建过，iNode指针所指向的数据量非常少。在这种情况下，进入到vmfs文件系统层进行数据分析和恢复需要先分析出FreeNAS层面的必要信息和数据。服务器数据恢复工程师通过分析获取到相关信息：UFS2文件系统块大小、segment大小、柱面组大小、每数据指针大小、每个块可容纳数据指针数量。<br/>根据上述信息计算出一个二级指针块可存储的数据量以及一个三级指针块可存储的数据量。<br/>2、服务器数据恢复工程师计划通过iscsidata文件的三级指针块来恢复FreeNAS层的数据。由于该文件曾经被重建，部分指针被重建的数据所覆盖，原文件的iNode和重建后的文件iNode所在的位置完全一致，也没有其他可用于数据恢复iNode数据。北亚企安服务器数据恢复工程师根据实际数据情况编写小程序收集有用的指针块，收集到了大量二级指针块和三级指针块。<br/>3、分析三级指针块，发现这些指针块都是无效的。继续分析二级指针块，对有大量的二级指针块的指向数据进行DUMP，然后再从磁盘中的数据定位到二级指针。通过这种方式得到大量DUMP的数据。<br/>4、服务器数据恢复工程师运用以前研究出来的NTFS和UFS2文件系统结构定位到vmfs层，继而定位到DUMP出的单个64GB文件，进行数据组合。<br/>5、经过复杂的查询和重组操作，最终成功恢复出了3台虚拟机及虚拟机内的全部数据。<br/>6、服务器数据恢复工程师将恢复出来的数据上传到新构建出来的系统中进行验证。经过用户方管理员验证，确认所有数据恢复成功。</p>]]></description></item><item>    <title><![CDATA[让大模型一键“读懂”全球文档，合合信息携]]></title>    <link>https://segmentfault.com/a/1190000047389140</link>    <guid>https://segmentfault.com/a/1190000047389140</guid>    <pubDate>2025-11-11 16:10:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>当前，大模型的发展正加速进入“强应用”阶段。中国信通院7月数据显示，国内已发布大模型超过1500个。如何打通诸多大模型落地的“最后一公里”，让技术从“实验室”走向“生产线”，成为全行业共同探索的课题。</p><p>近日，由合合信息TextIn打造，火山引擎提供平台支撑的“大模型加速器”升级版正式发布。</p><p>双方将共同打造文本智能领域的AI创新应用，为企业与开发者提供一站式AI工程化能力，通过补全“从模型到应用”的技术链路，共创大模型在泛行业中的应用模式。</p><p><strong>AI文档解析为大模型落地铺设“信息快车道”</strong></p><p>在企业数字化转型进程中，文档是核心的信息载体。企业端日常工作流程中产出了海量PDF、Word、图片格式的文档，这些文档所承载的知识性内容呈现出高度的“非结构化”特点，如使用传统的OCR（光学字符识别）技术进行处理，可能导致提取信息结构混乱，表格、图表信息提取不全，手写字符识别难等问题，导致大模型无法获取精确的专业信息，难以有效开展工作。</p><p>据合合信息技术团队成员介绍，在大模型应用过程中，不少开发团队曾反馈大模型回答准确性、系统响应效率难达预期。发生此类问题的根源在于，传统的文档处理技术难以为大模型提供精度、质量达标的语料。合合信息TextIn发布的“大模型加速器”依托多模态文本智能处理技术，通过对各类非标准化文档进行智能解析，挖掘高质量语料，为大模型落地铺设“信息快车道”。</p><p>据悉，TextIn“大模型加速器”具备超高精度与效率，能应对上千种文档中的无线表格、合并单元格、跨页段落、多层级标题、手写字符等行业难点，解析稳定率高达99.99%。此外，TextIn可精准解析研报、论文、财报中的十余种专业图表，将原始文档转化为机器真正“理解”的、高度结构化的数据，让大模型一键“读懂”全球文档，为医疗、制造、金融、教育、物流等领域的AI落地奠定坚实数据基础。</p><p><strong>“AI创新应用平台”让智能体搭建像“拼积木”般便利</strong></p><p>随着大模型应用渗透，不同主体的需求分化逐渐明显：大型企业注重“定制化”，方案需适配复杂流程、保障核心数据安全；中小开发者和个人用户则追求“轻量化”，以低门槛工具快速验证创意，这种“分层需求”正倒逼平台提供更精准的服务。</p><p>为满足不同用户需求，合合信息与火山引擎联合，在火山引擎Hi Agent、Coze等AI应用创新平台中，共同实践文档解析领域的“企业级+开发者级”的分层设计，并提供配套部署方案，实现全场景覆盖。</p><p>其中，Hi Agent聚焦企业级用户，提供智能体从开发、评测、观测到优化的全周期管理，企业可从包括TextIn文档解析模块在内的多个行业“模板”与MCP市场中挑选“工具”，通过低代码与高代码混合开发，快速搭建“数字员工”，以适配大型组织的复杂需求；Coze主要面向开发者与个人端用户，以“低门槛、场景化”为核心，将智能体搭建简化为“拼乐高”，降低文档处理类Agent的开发门槛，助力开发者快速落地应用。</p><p>在部署方式上，平台支持公有云、私有化部署、生态共建、开源个人应用等多种模式，既能保护企业内部隐私数据，也为开发者提供了个性化技术试验场，真正实现 “按需选用、无缝集成”。未来，合合信息TextIn“大模型加速器”将持续携手火山引擎等生态伙伴，深化技术协同，推动AI应用向社会各行业渗透，实现“智能触手可及”。</p>]]></description></item><item>    <title><![CDATA[数据库审计 - 网络安全的重要组成部分 ]]></title>    <link>https://segmentfault.com/a/1190000047389144</link>    <guid>https://segmentfault.com/a/1190000047389144</guid>    <pubDate>2025-11-11 16:10:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>执行数据库日志分析可让您对存储在数据库中的机密或敏感企业数据的所有访问进行审核。审核数据库日志还可通过回答谁更改了关键数据、何时更改了关键数据等一系列问题，来增强您的内部安全框架。数据库审核还可以帮助您满足日益苛刻的合规要求。</p><h2>一、EventLog Analyzer - 全面的数据库审核软件</h2><p>EventLog Analyzer执行：</p><p><strong>（1）全面管理</strong><br/>EventLog Analyzer集中收集来自整个网络的数据库事件，为数据库审核、帐户管理和其他用户更改、服务器安全报表等提供丰富的报表，实时提醒您重要事件并安全地归档日志。</p><p><strong>（2）数据库活动监控</strong><br/>监控数据库内的所有用户活动、数据库事务（包括DDL和DML语句）等。</p><p><strong>（3）数据库服务器日志监控</strong><br/>该工具通过深入的数据库服务器日志分析，提供有关服务器活动、用户登录和注销、数据库服务器中的帐户和权限更改等信息。</p><p><strong>（4）数据库安全监控</strong><br/>监控数据库中的任何常见攻击模式以加强数据库安全性。获取任何针对性攻击（如SQL注入）的即时告警，以及有关此类攻击的详细报表以帮助事件调查。</p><p><strong>（5）深入分析</strong><br/>该工具通过提供数据库服务器日志分析报表（如排行和趋势报表）来帮助进行更深入的分析。这可帮助您更好地理解数据库服务器活动，并从日志中获得更多价值。</p><h2>二、MS SQL服务器预定义报表</h2><p>EventLog Analyzer的预定义Microsoft SQL Server报表和告警涵盖:<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047389146" alt="图片" title="图片"/></p><p>DDL活动：结构级数据库更改，如数据库创建。</p><p>DML活动：功能级活动，如数据访问和修改。</p><p>帐户更改：新用户创建、密码更改等。</p><p>服务器活动：服务器启动、关机、创建服务器级别的对象（如服务器审核和服务器审核规范对象）以及服务器趋势。</p><p>安全攻击：常见的攻击类型，如SQL注入和拒绝服务攻击。</p><h2>三、Oracle数据库预定义报表</h2><p>EventLog Analyzer的预定义Oracle数据库报表和告警涵盖：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047389147" alt="图片" title="图片" loading="lazy"/></p><p>数据库活动：所有数据库用户活动，如创建表和数据库、执行过程等。</p><p>帐户管理：创建和更改配置文件、角色等。</p><p>服务器活动：成功和失败的服务器登录、启动和关闭等。</p><p>安全报表：常见攻击的报表，如SQL注入和拒绝服务。</p><p>因此，执行数据库审计是十分重要的，而EventLog Analyzer这款日志审计、管理和报表工具能够很好的帮助企业进行数据库审计和分析工作，现在支持30天免费试用，点击<a href="https://link.segmentfault.com/?enc=gSURQK3hLiNO17s5%2B%2Fyl3A%3D%3D.SnLS7G8PVZxaudQjj69tCb%2F2E3%2F0WTCrnn3Gc7MGuKJySUgR%2B7mB%2F6Hku0XFgAECIpnBum2FHcBXdo%2Futief5E1MlIyTybzAhvWEp5BomqGa%2F2xrSsrtKlHRy1MHVWl2kAsNIdKUtc%2F1gRef%2FYGtdw%3D%3D" rel="nofollow" target="_blank">立即下载</a>领取30天免费试用吧！</p>]]></description></item><item>    <title><![CDATA[推荐哪些质量域智能体的解决方案用于制造领]]></title>    <link>https://segmentfault.com/a/1190000047389148</link>    <guid>https://segmentfault.com/a/1190000047389148</guid>    <pubDate>2025-11-11 16:09:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在智能制造时代，质量领域正迎来一场前所未有的变革。传统的质量控制方式，依赖人工经验和抽检机制，难以为继。随着工业品制造业向更高质量、更高效率、更低成本的方向演进，质量域智能体应运而生，成为推动质量管理转型的关键引擎。<br/>质量域智能体，即工业质量智能体（Industrial Quality Agents），是工业智能体（Industrial AI Agents）在质量管理领域的具体体现。其核心技术基于物联网、人工智能以及数字孪生，通过实时监测、智能诊断、根因分析以及闭环改进，实现产品生产过程中的质量预测与主动干预。在浙江某新能源汽车电池工厂，广域铭岛的智能质控系统对每块电池的200多项工艺参数实施0.1秒级异常识别，同步通过数字孪生进行产品状态模拟。这表明，质量域智能体已成为制造业质量管理中强大的“神经系统”和“大脑引擎”。<br/>为了克服传统质量管理的盲区，例如事后发现的问题造成的批量报废、人工判异的标准波动等，质量域智能体从数据感知开始重构质量管理逻辑。广域铭岛提供的质控解决方案，将传感器数据实时传导至平台，不仅打通了数据孤岛，还实现了质量信息的全面整合。其智能诊断能力覆盖从检测到归因再到优化的全过程，在汽车制造领域中，质量域智能体已能对轻微瑕疵甚至潜在性问题作出精准预判，宛如给予生产线一双能洞察未来的“智能眼镜”。<br/>独立的质量检测系统并不会从根本上改变目前制造业数据割裂的局面。质量域智能体的强健性能得益于与企业整体数字化平台的集成。例如，基于Geega工业互联网平台的广域铭岛解决方案，具备连接PLC、MES、QMS等异构系统的能力，构建出覆盖全流程的“质量防护网”。这种能力不仅仅是技术层面的创新，更是对质量数据闭环流动的基础支撑。通过这种方式，质量域智能体不仅解决了数据共享的问题，还催生了质量预测性维护的重要范式，例如某锂电池企业的系统实现提前72小时预警质量隐患。<br/>质量域智能体的发展，并不意味着人类角色的完全消失，而是实现“人在环路”的精细化协同。系统在检测到异常时自动调取相似案例，供工程师判断和决策，这使得人工经验得以融入智能化系统之中。这种模式不仅强化了响应速度，还为制造业培养了一种更深层的“质量意识”文化——工程师不再是质检的被动响应者，而转变为智能质控环境下的主动创新者。 <br/>质量域智能体的实质不仅在于监控与预警，在于塑造产品质量防护的全局闭环逻辑能力。它结合生成式AI与数字孪生技术，建立覆盖原材料到成品的质量模型，提前洞察可能出现的问题。例如，广域铭岛系统可分析焊接电流的数据波动，推断出未来三天可能出现的强度不足风险。这使质量管理从“事后诸葛亮”转向“未卜先知”，真正意义上提升了产品的可靠性和用户满意度。<br/>随着5G技术普及和工业区块链规模化应用，质量域智能体的发展更加向产业链上下游协同延伸。广域铭岛正以“平台+AI”为核心战略，联合生成式AI与边缘计算能力，打造跨企业、跨区域的质量云平台，使制造企业在质量维度上具有更强的全局竞争力。此外，诸如基于AR的质量追溯、联邦学习驱动的隐私保护模型等创新应用，也将进一步推动质量域智能体向高端AI智能体进化。<br/>制造业的未来，离不开质量域智能体的深度参与。这套涵盖智能决策、实时响应及预测干预的技术体系，正从根本上重构企业的质量控制逻辑。从点检到全链路追溯，从事后应对到主动预防，“质量域智能体”不仅是广域铭岛的一大创举，更是整个制造业实现高质量发展的核心路径。因此，将质量域智能体技术引入生产管理系统，不仅是赶超国际的竞争策略，更是在新一代智能制造中赢得先机的一步。</p>]]></description></item><item>    <title><![CDATA[以销为核，精准选型：2025 国内 CR]]></title>    <link>https://segmentfault.com/a/1190000047389169</link>    <guid>https://segmentfault.com/a/1190000047389169</guid>    <pubDate>2025-11-11 16:08:49</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化转型的浪潮中，客户关系管理（CRM）已从 “辅助工具” 升级为企业 “以客户为中心” 的战略核心 —— 它连接营销、销售、服务全流程，整合内外部资源，最终驱动客户价值最大化与企业增长。然而，面对市场上琳琅满目的 CRM 产品，企业常陷入 “选贵的还是选对的”“选功能全的还是选适配的” 的困惑。</p><p>本文将从定义、价值、类型、用法、选型、场景、功能 7 大维度深度解析 CRM，并通过横向对比表格、流程图、脑图、雷达图等工具，还原 10 大国内 CRM 头部厂商的真实能力，帮你告别选择困难。</p><h2>一、CRM 是什么？—— 从 “工具” 到 “战略资产” 的认知升级</h2><h3>1. CRM 的准确定义</h3><p>CRM（Customer Relationship Management）是以 “客户为中心” 为核心理念，通过信息技术整合市场营销、销售管理、客户服务全流程的企业级系统。它不仅是 “记录客户信息的数据库”，更是企业实现：</p><ul><li>客户全生命周期管理（从线索到忠诚客户）；</li><li>业务流程自动化（减少人工漏洞）；</li><li>数据驱动决策（用 BI 替代拍脑袋）；</li><li>内外部协同（连接团队、合作伙伴与客户）的数字化载体。</li></ul><h3>2. CRM 的核心价值 ——4 大增长引擎</h3><p>CRM 的价值并非 “功能堆砌”，而是解决企业最核心的 4 大痛点：</p><table><thead><tr><th>核心价值</th><th>具体说明</th><th>代表厂商案例</th></tr></thead><tbody><tr><td>客户价值最大化</td><td>分级管理高价值客户，挖掘复购与转介绍机会</td><td>某医疗设备企业通过 CRM 构建 “VIP 客户专属服务群”，复购率提升 25%</td></tr><tr><td>流程效率提升</td><td>固化销售 / 服务流程（如线索自动分配、工单自动派单），降低人工成本</td><td>超兔 CRM 的 “线索分配规则” 帮某教育机构减少 30% 的线索流失率</td></tr><tr><td>数据驱动决策</td><td>通过 BI 报表 / AI 分析（如销售预测、客户流失预警），让决策有依据</td><td>销售易的 “双中台数据挖掘” 帮某科技企业预测下月销量，准确率达 92%</td></tr><tr><td>内外部协同</td><td>连接内部团队（销售 - 市场 - 服务）、上下游（经销商 - 供应商）与客户（微信直连）</td><td>某制造企业通过 CRM 实现 “经销商在线订货→销售实时查库存→客户微信咨询转工单”，全链路效率提升 40%</td></tr></tbody></table><h3>3. 脑图：CRM 核心价值的底层逻辑</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389171" alt="" title=""/></p><pre><code>mindmap
  root((CRM核心价值))
    客户价值最大化
      客户分级（VIP/普通）
      全生命周期跟进（线索→老客户）
      复购/转介绍挖掘
    流程效率提升
      自动化审批
      线索自动分配
      工单自动派单
    数据驱动决策
      BI报表（销售/客户行为）
      AI预测（销售/流失）
      数据看板（实时指标）
    内外部协同
      内部团队连接（销售-市场-服务）
      上下游连接（经销商-供应商）
      客户连接（微信/APP直连）
</code></pre><h2>二、CRM 有哪些类型？——4 类主流分型及适配场景</h2><p>根据核心定位与功能侧重，CRM 可分为 4 类，企业需根据自身场景选择：</p><table><thead><tr><th>类型</th><th>核心定位</th><th>代表厂商</th><th>适用场景</th></tr></thead><tbody><tr><td>通用型 CRM</td><td>覆盖基础客户 / 销售管理</td><td>Zoho CRM、超兔</td><td>大多数中小企业（需基础功能）</td></tr><tr><td>协助型 CRM</td><td>侧重客户服务与团队协作</td><td>客如云、红圈</td><td>客服 / 外勤团队（如快消、餐饮）</td></tr><tr><td>分析型 CRM</td><td>以数据挖掘 / AI 分析为核心</td><td>销售易</td><td>需精准决策的中大型企业</td></tr><tr><td>连接型 CRM</td><td>连接内外部资源全链路协同</td><td>相关主流厂商</td><td>需全链路协同的中大型企业</td></tr></tbody></table><p>说明：</p><ul><li>通用型 CRM 适合 “刚入门” 的中小企业（如 Zoho CRM，年费低至 1200 元 / 用户）；</li><li>协助型 CRM 适合 “重服务 / 外勤” 的行业（如客如云聚焦餐饮，红圈聚焦快消外勤）；</li><li>分析型 CRM 适合 “重数据” 的企业（如销售易用双中台挖掘客户需求）；</li><li>连接型 CRM 适合 “重协同” 的企业（如部分厂商可实现团队、经销商与客户的连接）。</li></ul><h2>三、CRM 怎么用？—— 从 “上线” 到 “落地” 的 5 步流程</h2><p>CRM 的成功不是 “买系统”，而是 “用系统”。</p><h3>2. 每步的关键动作</h3><ul><li>需求梳理：先明确 “核心痛点”（如销售线索流失），再定义 “可量化目标”（如 “降低线索流失率 30%”）—— 可借助厂商的 “顾问服务”。</li><li>数据导入：用工具清洗现有数据（如 Zoho 的 “Data Import Wizard” 去重），确保 “客户信息完整度≥90%”。</li><li>流程配置：根据业务场景固化流程（如超兔 CRM 的 “商机跟进阶段”：线索→意向→报价→成交）。</li><li>培训推广：通过 “线上课程 + 线下考核” 确保全员会用（如销售易用 “模拟演练” 帮销售快速上手）。</li><li>迭代优化：每月用 BI 报表复盘（如 “销售转化率下降 10%”），调整流程（如修改相关 CRM 的 “线索分配规则”）。</li></ul><h2>四、CRM 选型指南：5 个关键标准，避免踩坑</h2><p>企业选型的核心不是 “选最贵的”，而是 “选最适配的”。以下 5 个标准是关键：</p><table><thead><tr><th>标准</th><th>说明</th><th>关键考察点</th></tr></thead><tbody><tr><td>产品理念</td><td>是否与企业战略匹配（如 “以客户为中心” vs “以工具为中心”）</td><td>厂商的核心定位（如侧重销售绩效、双中台等不同方向）</td></tr><tr><td>业务场景</td><td>是否覆盖企业的核心场景（如外勤 / 餐饮 / 制造）</td><td>厂商的行业深耕程度（如客如云聚焦餐饮，红圈聚焦快消）</td></tr><tr><td>高成长性</td><td>是否支持企业未来扩张（如出海 / 定制化）</td><td>多语言 / 多币种（如 Zoho 支持 10 + 语言）、低代码定制（如部分厂商的 PaaS 平台）</td></tr><tr><td>服务能力</td><td>是否有完善的售后支持（如故障响应 / 培训）</td><td>本地化团队、响应时间（如 2 小时故障响应）</td></tr><tr><td>合规性</td><td>是否满足行业合规要求（如医疗的 HIPAA、国企的等保三级）</td><td>合规认证（如等保三级、GDPR 等）</td></tr></tbody></table><h2>五、10 大国内 CRM 头部厂商深度横评 —— 谁适合你？</h2><p>基于市场份额（IDC 2025）、行业适配性、客户口碑，国内 CRM 头部厂商排名如下（附核心能力解析）：</p><h3>1. 超兔CRM—— 销售增长 “绩效引擎”</h3><ul><li>核心定位：以销售绩效管理为核心，覆盖全业务一体化的实战型 CRM；</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389172" alt="" title="" loading="lazy"/></p><ul><li>核心优势：</li></ul><ol><li>全业务闭环管理：打通 CRM、进销存、生产工单、财务日记账等 12 大模块，实现从获客到回款全链路数据互通，无需跨系统切换；</li><li>线索与绩效双驱动：线索全链路追踪可视化，自动生成销售业绩报表与团队排行，优化激励机制；</li><li>低成本客制化：支持功能白名单订阅、三级菜单自定义，企业可按需配置，年 IT 投入较定制开发节省 40%；</li><li>AI 深度赋能：内置 AI 智能体生成跟进建议，Coze 工作流支持自然语言定义复杂流程，销售跟单效率提升 40%-50%；</li></ol><ul><li>行业适配：工业制造、工贸一体、项目型交付企业，覆盖机械、电子、五金、建材等 50 多个行业；</li><li>客户案例：某机械制造企业通过订单与生产联动，交付周期缩短 37%；某汽车零部件企业线索转化率提升 28%；</li><li>适用企业：中小企业（50-500 人）、销售团队、追求全业务协同与快速落地的工贸 / 工业企业。</li></ul><h3>2. 销售易（Neocrm）—— 本土 CRM “第二名”</h3><ul><li>核心定位：双中台 CRM（营销中台 + 销售中台）；</li><li>核心优势：</li></ul><ol><li>销售流程精细化：支持 “线索→商机→订单” 全链路自动化（如为某教育机构优化 “学员跟进流程”）；</li><li>数据挖掘：双中台整合营销 / 销售数据，精准预测客户需求；</li><li>ERP 集成：与用友 / 金蝶 ERP 无缝对接，打破信息孤岛；</li></ol><ul><li>行业适配：IT 高科技、教育、制造；</li><li>适用企业：中大型企业、需要销售流程精细化的企业。</li></ul><h3>3. Zoho CRM—— 中小企业 “高性价比首选”</h3><ul><li>核心定位：通用型 CRM（高性价比 + 深度定制）；</li><li>核心优势：</li></ul><ol><li>性价比高：年费低至 ¥1200 / 用户；</li><li>AI 助手 Zia：支持销售预测、客户行为分析（如帮某初创团队识别 “高潜力客户”）；</li><li>集成能力：连接 50 + 工具（邮箱、项目管理、ERP）；</li></ol><ul><li>适用企业：中小企业、初创团队、预算有限的企业。</li></ul><h3>4. 红圈 CRM—— 外勤销售 “移动能力突出”</h3><ul><li>核心定位：移动销售管理；</li><li>核心优势：</li></ul><ol><li>拜访管理：记录客户跟进过程，优化拜访路线（如为某快消企业的业务员规划 “最优拜访路线”）；</li><li>移动协同：支持外勤打卡、实时更新客户信息；</li></ol><ul><li>行业适配：快消、零售、需要外勤管理的企业；</li><li>适用企业：快消、零售、外勤团队占比高的企业。</li></ul><h3>5. 神州云动 CRM—— 大型企业 “深度集成首选”</h3><ul><li>核心定位：企业级 CRM（深度集成 + 复杂流程）；</li><li>核心优势：</li></ul><ol><li>系统集成：与 SAP、Oracle 等大型 ERP 无缝对接（如为某汽车企业整合 “销售订单 + 库存”）；</li><li>复杂流程：支持 “多维度审批”“跨部门协作”；</li></ol><ul><li>适用企业：大型企业、需要深度集成的企业。</li></ul><h3>6. 简道云 CRM—— 中小企业 “低代码定制”</h3><ul><li>核心定位：低代码 CRM（快速搭建 + 灵活迭代）；</li><li>核心优势：</li></ul><ol><li>低代码：像 “搭积木” 一样自定义模块（如为某母婴店搭建 “会员积分系统”）；</li><li>易部署：1 周内上线，适合快速迭代的企业；</li></ol><ul><li>适用企业：中小企业、需要快速调整流程的企业。</li></ul><h3>7. 客如云 CRM—— 餐饮零售 “行业专用”</h3><ul><li>核心定位：餐饮 / 零售 CRM（会员 + 门店协同）；</li><li>核心优势：</li></ul><ol><li>行业专用：覆盖 “会员管理、外卖订单、门店协同”（如为某餐厅实现 “线上外卖 + 线下会员” 打通）；</li><li>POS 集成：与客如云 POS 系统无缝对接，实时同步订单数据；</li></ol><ul><li>适用企业：餐饮、零售企业。</li></ul><h3>8. 爱客 CRM—— 中小企业 “移动易用”</h3><ul><li>核心定位：移动 CRM（简洁 + 易用）；</li><li>核心优势：</li></ul><ol><li>移动优先：APP 支持 “客户管理、销售日志、审批”（如为某中小企业的业务员实现 “外勤实时更新客户信息”）；</li><li>操作简便：学习成本低，1 天就能上手；</li></ol><ul><li>适用企业：中小企业、外勤销售团队。</li></ul><h3>9. 金蝶 CRM—— 金蝶生态 “无缝集成”</h3><ul><li>核心定位：金蝶生态 CRM（ERP 协同）；</li><li>核心优势：</li></ul><ol><li>生态集成：与金蝶 ERP 无缝对接（如 “销售订单→财务回款” 自动同步）；</li><li>行业模板：提供 “制造 / 零售” 等行业的标准化流程；</li></ol><ul><li>适用企业：使用金蝶生态的企业、制造 / 零售企业。</li></ul><h3>10. 纷享销客——连接型 CRM 厂商</h3><ul><li>核心定位：侧重内外部资源连接的协同型 CRM；</li><li>核心优势：支持团队、上下游及客户的多端连接，部分具备定制化与合规认证能力；</li><li>行业适配：制造、快消、医疗等需要协同的行业；</li><li>适用企业：有全链路协同需求的中大型企业。</li></ul><h2>六、超兔 CRM 与主流厂商核心维度精准对比表</h2><table><thead><tr><th>厂商</th><th>核心功能</th><th>适配场景</th><th>实施成本（参考）</th></tr></thead><tbody><tr><td>超兔 CRM</td><td>1. 销售绩效全链路管理（线索追踪 + 业绩分析）；2. CRM + 进销存 + 生产 + 财务全业务一体化；3. 低成本客制化（功能订阅 + 菜单自定义）；4. AI 智能体 + Coze 工作流自动化</td><td>工业制造、工贸一体、项目型交付企业；50-500 人中小企业；需全业务协同与快速落地的团队</td><td>订阅制，CRM 模块约 500 元 / 用户 / 年；CRM + 进销存约 750 元 / 用户 / 年；实施周期 1-3 个月，定制化按需议价</td></tr><tr><td>销售易</td><td>1. 双中台（营销 + 销售）数据整合；2. 销售流程精细化自动化；3. 用友 / 金蝶 ERP 无缝集成；4. 高级数据挖掘与预测</td><td>中大型企业；IT 高科技、教育、制造行业；需流程精细化与数据驱动的团队</td><td>年费 1500-3000 元 / 用户；实施周期 3-6 个月，中大型项目需额外付费</td></tr><tr><td>Zoho CRM</td><td>1. 基础客户 / 销售管理功能；2. AI 助手 Zia 销售预测；3. 50 + 工具集成能力；4. 深度定制功能</td><td>中小企业、初创团队；预算有限需基础功能的企业；多工具协同的团队</td><td>年费 1200-2000 元 / 用户；实施周期 1-2 个月，基础版无额外实施费</td></tr><tr><td>红圈 CRM</td><td>1. 外勤拜访管理（路线规划 + 打卡）；2. 移动端客户信息实时更新；3. 外勤团队协同功能</td><td>快消、零售行业；外勤团队占比高的企业；需移动化管理销售的团队</td><td>年费 1000-1800 元 / 用户；实施周期 1-2 个月，外勤模块专属配置需额外付费</td></tr><tr><td>神州云动 CRM</td><td>1. 大型 ERP（SAP/Oracle）深度集成；2. 复杂流程与多维度审批；3. 混合部署（信创 / 私有化）</td><td>大型企业、跨国集团；金融、医疗等高合规行业；多子公司架构的企业</td><td>项目制收费，通常 50 万 +；实施周期 6 个月以上，按定制需求计价</td></tr><tr><td>客如云 CRM</td><td>1. 餐饮 / 零售会员管理；2. 外卖订单 + 门店协同；3. 客如云 POS 系统无缝对接</td><td>餐饮、零售行业；线下门店连锁企业；需打通线上线下订单的团队</td><td>按门店收费，单门店年费 5000-10000 元；实施周期 1-2 个月，门店越多成本越高</td></tr></tbody></table><h2>七、CRM 核心功能雷达图 —— 各厂商的功能实力</h2><p>CRM 的核心功能可分为 7 个维度，以下是 10 大厂商的功能得分（5 分制）：</p><table><thead><tr><th>厂商</th><th>客户管理</th><th>销售自动化</th><th>营销自动化</th><th>服务自动化</th><th>数据分析</th><th>协同办公</th><th>定制能力</th></tr></thead><tbody><tr><td>超兔 CRM</td><td>4</td><td>4</td><td>3</td><td>3</td><td>4</td><td>4</td><td>5</td></tr><tr><td>销售易</td><td>4</td><td>5</td><td>4</td><td>3</td><td>5</td><td>4</td><td>4</td></tr><tr><td>Zoho CRM</td><td>4</td><td>4</td><td>3</td><td>3</td><td>4</td><td>3</td><td>5</td></tr><tr><td>红圈 CRM</td><td>3</td><td>5</td><td>2</td><td>3</td><td>3</td><td>4</td><td>3</td></tr><tr><td>神州云动</td><td>4</td><td>4</td><td>3</td><td>4</td><td>5</td><td>4</td><td>5</td></tr><tr><td>简道云</td><td>3</td><td>3</td><td>2</td><td>2</td><td>3</td><td>3</td><td>5</td></tr><tr><td>客如云</td><td>4</td><td>3</td><td>3</td><td>5</td><td>3</td><td>3</td><td>3</td></tr><tr><td>爱客 CRM</td><td>3</td><td>4</td><td>2</td><td>3</td><td>3</td><td>4</td><td>3</td></tr><tr><td>金蝶 CRM</td><td>4</td><td>3</td><td>3</td><td>3</td><td>4</td><td>4</td><td>3</td></tr><tr><td>纷享销客</td><td>4</td><td>3</td><td>4</td><td>3</td><td>3</td><td>5</td><td>4</td></tr></tbody></table><p>从雷达图中可以看出，不同厂商在 CRM 的各项核心功能上各有侧重。超兔 CRM 整体表现均衡，在客户管理、销售自动化、数据分析和定制能力上表现突出，尤其贴合工贸 / 工业企业的全业务协同需求；销售易在销售自动化和数据分析上优势明显，适合注重流程精细化的中大型企业；Zoho CRM 以高性价比和定制能力见长，适配预算有限的中小企业；红圈 CRM 的销售自动化能力适配外勤场景，客如云则在服务自动化上贴合餐饮零售行业需求。</p><h2>八、4 个常见问题解答</h2><h3>1. CRM 系统的实施周期一般有多长？</h3><p>CRM 系统的实施周期受企业规模、业务复杂度、系统定制程度影响。中小企业选择超兔 CRM、简道云等轻量化产品，1-3 个月可完成全流程落地；超兔 CRM 支持快速部署，基础功能 1-2 周即可上线使用。中大型企业若需深度定制或集成，实施周期可能延长至 3-6 个月。</p><h3>2. CRM 系统能否与企业现有的其他软件系统集成？</h3><p>主流 CRM 均具备一定集成能力。Zoho CRM 可连接 50 + 工具，销售易能与用友 / 金蝶 ERP 无缝对接，神州云动支持与 SAP、Oracle 等大型 ERP 深度集成。企业需提前明确现有系统情况，考察 CRM 的集成接口开放性与适配效果。</p><h3>3. CRM 系统的使用是否需要员工具备较高的技术水平？</h3><p>多数 CRM 针对企业实际场景优化了操作逻辑。超兔 CRM、爱客 CRM 等产品界面简洁、流程清晰，员工 1-3 天即可上手；即使是功能复杂的系统，厂商也会提供线上课程、线下辅导等培训服务，降低使用门槛。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389173" alt="" title="" loading="lazy"/></p><h3>4. CRM 系统的数据安全如何保障？</h3><p>数据安全通过多层面构建：技术上采用 SSL 加密传输与数据备份机制；管理上设置严格权限分级，限制数据访问范围；合规上选择通过等保三级、GDPR 等认证的产品；流程上建立客户防冲突与离职交接机制，全面保护客户资源。</p><h2>九、结语</h2><p>在数字化时代，CRM 系统已成为企业提升核心竞争力、实现可持续发展的关键因素。通过本文对 CRM 的定义、价值、类型、用法、选型、场景、功能等多维度的深度解析，以及对 10 大国内 CRM 头部厂商的核心能力分析和功能对比，相信企业在选择 CRM 系统时能够告别 “选择困难”。</p><p>企业选型应始终坚守 “适配自身需求” 的核心原则：以销售绩效为核心、追求全业务协同的工贸 / 工业中小企业，超兔 CRM 是高适配选择；注重销售流程精细化与数据挖掘的中大型企业，可优先考虑销售易；预算有限、需要基础功能的初创团队，Zoho CRM 的性价比优势显著；快消、零售等外勤需求突出的企业，红圈 CRM 更具针对性。</p><p>未来，CRM 系统将朝着 AI 深度集成、行业垂直化、生态化的方向发展。企业选择时不仅要满足当前业务需求，更要兼顾系统的扩展性，为长期增长奠定基础。希望企业能借助合适的 CRM 系统，实现客户管理智能化升级，提升客户满意度与忠诚度，最终达成业务的持续增长与突破。</p>]]></description></item><item>    <title><![CDATA[如何利用工业互联网智能体数据提升制造业效]]></title>    <link>https://segmentfault.com/a/1190000047389175</link>    <guid>https://segmentfault.com/a/1190000047389175</guid>    <pubDate>2025-11-11 16:08:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>工业互联网智能体数据是指在工业互联网环境中，由智能体（Agent）系统通过传感器、物联网设备、自动化控制平台实时采集、处理和分析的多源异构数据。这类数据不仅包括设备运行参数、环境状态、生产指标等结构化信息，还涵盖图像、音频、日志文本等非结构化内容。其核心价值在于打通信息孤岛，实现设备、系统、人员之间的高效协同与智能决策，推动工业系统从“自动化”向“自主化”演进。<br/>随着工业4.0和数字孪生技术的深度融合，工业互联网智能体依托数据中台、边缘计算和人工智能技术，构建了“感知-分析-决策-执行”的闭环赋能体系。这一体系显著提高了制造业的运营效率、生产灵活性和资源利用率，成为企业数字化转型的核心驱动力。<br/>技术架构与核心能力<br/>工业互联网智能体数据的技术架构通常分为三层：边缘层、平台层和应用层。边缘层通过智能传感器和物联网终端实时采集数据，并依托边缘计算节点实现数据的初步清洗和本地化分析；平台层则集成大数据处理、机器学习和云计算能力，提供数据存储、建模和可视化支持；应用层聚焦业务场景，实现数据智能与工业操作的深度结合。<br/>其核心能力包括实时数据流处理、多模态数据融合、自适应学习与动态优化。例如，智能体能够通过历史数据训练预测模型，动态调整设备运行参数，实现能耗优化和质量控制。<br/>行业应用场景</p><ol><li>预测性维护<br/>在高端装备制造领域，工业互联网智能体数据可用于监控关键设备的运行状态。例如，吉利汽车利用振动传感器、红外热成像和噪声监测单元实时采集生产线机器人及传送带的数据，通过机器学习算法分析设备退化趋势，提前14-30天预警潜在故障，并自动生成维护工单。这一应用使得非计划停机时间减少40%以上，维护成本降低25%。</li><li>生产流程优化<br/>典型案例如广域铭岛通过智能体数据帮助某工厂科技集团电芯良品率提升30%+，模组良品率达到99.48%。</li><li>供应链与资源管理<br/>工业智能体可整合订单、库存、物流和能源消耗数据，实现供应链的动态优化。例如，广域铭岛通过智能体数据快速对接设备，提高实施效率50%，通过多种盘点方式及作业过程精细化管理，提高库存准确率10%</li><li>质量管控与工艺改进<br/>在半导体和精密制造行业，智能体数据用于实时监测产品质量。通过计算机视觉识别产品表面缺陷，结合工艺参数回溯分析，系统可自动定位质量异常根源，并反馈调整生产参数。广域铭岛应用这一方案后，质量作业效率提升20%。<br/>实施路径与行业挑战<br/>尽管工业互联网智能体数据应用前景广阔，但其推进仍面临数据安全、系统兼容性、人才短缺等挑战。企业需分阶段实施，优先在关键设备或产线开展试点，逐步构建标准化数据接口与协同治理机制。同时，应注重工业知识与人工智能技术的深度融合，以业务价值为导向稳步推进智能化升级。<br/>未来发展趋势<br/>未来，随着5G、量子计算和联邦学习等技术的成熟，工业互联网智能体将向“分布式协同”和“自主进化”方向发展。应用场景也将从传统制造业延伸至智慧能源、绿色制造、医疗设备等新兴领域，进一步赋能全球工业的数字化、网络化和智能化转型。<br/>通过工业互联网智能体数据的深度应用，企业不仅能够提升生产效率和产品质量，还可实现资源优化配置与可持续发展，最终构建具有韧性和竞争力的工业生态系统。</li></ol>]]></description></item><item>    <title><![CDATA[vscode插件间通信 walker_j]]></title>    <link>https://segmentfault.com/a/1190000047389177</link>    <guid>https://segmentfault.com/a/1190000047389177</guid>    <pubDate>2025-11-11 16:07:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><h2>简介</h2><p>vscode提供了一些方式比如通过命令让插件之间通信，但是两个不同插件的webview的页面间通信比较复杂，如果还想交换数据，涉及的步骤会更多。</p><p><strong>MessageChannel</strong>的目的是让所有vscode的通信都通过它来完成，不过目前阶段仅实现了不同插件webview之间的通信以及交换数据。</p><h2>使用方法</h2><h4>web端发送消息</h4><h6>使用方法</h6><p>window.mc.pubWithSub(extensionId, options, callback);</p><h6>参数解析</h6><ol><li>extensionId，要通信的插件的唯一标识，由package.json中的name和publisher组成。</li><li><p>options，是一个对象，包含如下选项：</p><p>1). viewType，要打开的webview的type，一般声明为静态类型。</p><p>2). source</p><table><thead><tr><th>文件预览型webview</th><th>命令打开的webview面板</th></tr></thead><tbody><tr><td>D:\\project\\vscode\\vscode-extension-samples\\url-webview-sample\\exampleFiles\\example.cscratch'</td><td>相应的命令</td></tr></tbody></table><p>3).selector，打开web后要自动点击的元素的选择器列表，多个元素依次点击。比如打开env的页面后自动添加添加按钮。</p><p>4). payload，要传递的额外参数，这个参数会自动添加为selector对应元素的payload属性</p></li></ol><p>使用示例如下：</p><pre><code>    window.mc = (${MessageChannel.toString()})()
    // 设置发、收消息的对象。对于web来说carrier是vscode引擎内置到html中vscode对象，对于node来说是webview的示例。
    window.mc.setCarrier();

    document.querySelector('.url-webview button').addEventListener('click', () =&gt; {
        const input = document.querySelector('.url-webview .send-message input');
        const value = input.value;
        // 文件预览型
        window.mc.pubWithSub('walker.response-url-webview-sample', 
        { 
            viewType: 'catCustoms.catScratch',
            source: 'D:\\\\project\\\\vscode\\\\vscode-extension-samples\\\\url-webview-sample\\\\exampleFiles\\\\example.cscratch',
            selector: ['input'],
            payload: value
        },
        (data) =&gt; {
            document.querySelector('.url-webview .response-message').innerText = data;
        });
    });
      document.querySelector('.command-webview button').addEventListener('click', () =&gt; {
        const input = document.querySelector('.command-webview .send-message input');
        const value = input.value;
          // 命令打开型
        window.mc.pubWithSub('walker.command-webview-sample', { viewType: 'catCoding', source: 'catCoding.start', selector: ['input'], payload: value }, (data) =&gt; {
            document.querySelector('.command-webview .response-message').innerText = data;
        });
    });</code></pre><h4>消息方法方对应的node部分</h4><p>这里只需初始化，传入的参数为当前webview的viewType。</p><p>示例如下<br/><code>mc.initiator(ColorsViewProvider.viewType);</code></p><h4>消息接受方对应的node部分</h4><p>这里只需初始化，传入的参数为当前webview的viewType。</p><p>示例如下<br/><code>mc.initiator(CatScratchEditorProvider.viewType);</code></p><h4>消息接受方对应的web部分</h4><p>按上述参数传递已经能够打开webview对应的web页面了，如果需要给发送方返回一些数据，可以调用feedbackResult全局函数。</p><p>示例如下</p><pre><code>    document.querySelector('button').addEventListener('click', (args) =&gt; {
        const result = document.querySelector('input').value;
        feedbackResult &amp;&amp; feedbackResult(result);
    });</code></pre></blockquote>]]></description></item><item>    <title><![CDATA[【案例+1】HarmonyOS官方模板优]]></title>    <link>https://segmentfault.com/a/1190000047389242</link>    <guid>https://segmentfault.com/a/1190000047389242</guid>    <pubDate>2025-11-11 16:06:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>💡 鸿蒙生态为开发者提供海量的HarmonyOS模板/组件，助力开发效率原地起飞 💡</p><p>★ 一键直达<a href="https://link.segmentfault.com/?enc=33p2vVZuZuvXzF%2FIHoI%2FKg%3D%3D.n9I%2B4t2Q4vtkLz4tW3cEAxTPHwaKAgeD6FIH%2BMyh2dcWqZvn0kg5pebeuosWz2D9LZoUn7miC5X%2FAk3uGVQIQV%2BqjngfDFsUzk0FxuzcUiUAgYwK2Fi%2F5PsX4QMu9Mqf5IP7qzOWKm5XAQPMe0Qy2WwK8RQKKxa4edEN16d24J8HEBEdekD31fF9lHdEpCeXZnvAnZbgBR%2Ffx5DwJ7Kknw%3D%3D" rel="nofollow" target="_blank">生态市场组件&amp;模板市场</a> , 快速应用<a href="https://link.segmentfault.com/?enc=c%2B61NwM3y7oU7ZIZbaY5sA%3D%3D.1hMPwsSLg%2BmX%2B9cdh5tXTfodiWUuIj9ffKA5IuNHiNkoR%2BQErKdE0Z6zUe0CfCBpbcObH9tF9IHCiJk%2Fs3b2WpQW0%2Fs3kfIGyoeOc8FPQ3vHQjpLjwZ8kmqeOClaP75Tcyz%2FUvIFcVvDaUhKw6yrBSesd654dbFQZSW8Y4AuN5vFtY3hGqcp%2FyGcDQT6b7U3" rel="nofollow" target="_blank">DevEco Studio插件市场集成组件&amp;模板</a> ★</p><p><strong>贴心的用餐体验能够为美味加分，本期为大家介绍点餐元服务模板</strong></p><p><strong><em><em>★ 一键直达<strong> <a href="https://link.segmentfault.com/?enc=qdF2SWtRTUbHWk6W8Z7%2BAw%3D%3D.b%2FjplrjLfU6s58jJgrRZk7eqLCvH6xCkWvOBadib0l8IMuFG5zg55s%2FY%2FNY8wOPjnKue0%2FIFza17k6enmtV6fWHWRHaDmFhLBxNgf%2BXGHZZg9fgzh1WGXtYdti1g9XAoOyg%2FhFxVyO%2Bhcm0G3vSQNw%3D%3D" rel="nofollow" target="_blank">HarmonyOS 行业解决方案</a> </strong>，<strong><a href="https://link.segmentfault.com/?enc=zB54Xa0yToRTaN2OT8aF6g%3D%3D.YwHduE%2FdG0TJlVceR5hLpyqk67gf3by5LV5jRn0qwFOFtEW%2FDTkBc98cMN0h4POSIcQUk%2BwCZ1CLsDMrY55q78ruarfA0okdq9f%2FFHYzrnZ4YVm3VwJ4Oq3P0z8JTmh2xCtz8qgYcQZZ%2FlGwD5CkNWEUFxBCfe0JjVWS2HU8MAWGCmArkdfGeABM0jPGMwr%2Btr7TcK%2B3zBI28gmbCAct1w%3D%3D" rel="nofollow" target="_blank">美食行业解决方案</a>  </strong>★</em></em></strong></p><p>👉 覆盖20+行业，<strong><a href="https://link.segmentfault.com/?enc=lOZDxaGfgaVEH%2FqihrACpA%3D%3D.3wgPSPIeIH%2BE01TipftAMUkkOxqch4VjNDtGxcVltUwOarhEbDL6bhQcI4NdPeJFPwK9jLbmso%2F2pdKchiuMe08dzwgaqqyGMjjzvbi2oMg0xy3rmMTHnZJxNm6UgmJPuEwEhHZhBIHBbjMwfhPE7SE4GBWA0QD%2B8kg46aBtAH0YvrOia1%2FJyl1mH0HyVyFo" rel="nofollow" target="_blank">点击查看</a></strong> 往期案例汇总贴，持续更新，<a href="#汇总表" target="_blank">点击收藏</a>！一键三连！常看常新！</p><h2>【第14期】美食行业 · 餐饮点餐**</h2><h3>一、概述</h3><h4>1.行业洞察</h4><h5>1）行业诉求：</h5><ul><li>传统餐饮私域流量缺失，依赖第三方平台导流，佣金成本高且较难沉淀用户；</li><li>第三方平台都在推各家的点餐码，导致餐饮门店一张桌上多张码，不仅增加了布码和维护成本，还给顾客带来不好的点餐体验。</li><li>低频使用的独立App极易被用户遗忘删除；公众号/小程序需主动打开，入口深且触达率低。</li></ul><h5>2）行业常用三方SDK</h5><table><thead><tr><th><strong>分类</strong></th><th><strong>三方库名称</strong></th><th><strong>功能</strong></th><th><strong>支持情况</strong></th></tr></thead><tbody><tr><td>媒体</td><td>阿里云视频播放器SDK</td><td>音视频</td><td>已支持</td></tr><tr><td>登录认证</td><td>中国移动一键登录SDK/易盾一键登录SDK/创蓝闪验/极光安全认证/阿里云号码认证SDK/中国电信一键登录SDK</td><td>登录</td><td>已支持</td></tr><tr><td>分享</td><td>友盟/ShareSDK/微信分享/QQ分享/新浪微博SDK/MobTech ShareSDK</td><td>统计/推送/分享</td><td>已支持</td></tr><tr><td>支付</td><td>支付宝支付/微信支付/银联支付</td><td>支付</td><td>已支持</td></tr><tr><td>数据分析</td><td>友盟移动统计SD/神策数据SDK</td><td>数据收集、处理、分析、运用</td><td>已支持</td></tr><tr><td>性能监控</td><td>腾讯Bugly SDK/听云SDK/岳鹰全景监控SDK</td><td>异常上报和运营统计</td><td>已支持</td></tr><tr><td>地图</td><td>高德地图SDK</td><td>地图</td><td>已支持</td></tr><tr><td>推送</td><td>个推/华为推送/极光PUSH/阿里推送SDK</td><td>消息推送</td><td>已支持</td></tr><tr><td>媒体</td><td>阿里云视频播放器SDK</td><td>音视频</td><td>已支持</td></tr></tbody></table><p><em>说明："以上三方库及链接仅为示例，三方库由三方开发者独立提供，以其官方内容为准"</em></p><p>SDK链接：</p><p><a href="https://link.segmentfault.com/?enc=G73%2BJdq3WOErTpHIwzOXlA%3D%3D.LmC6lTbis8V6Pf8514urdDUOxe6S30qSEMp3WXENjBQ%3D" rel="nofollow" target="_blank">支付宝SDK</a></p><p><a href="https://link.segmentfault.com/?enc=TJXLmDqlMK0cgLbiu7%2BOUA%3D%3D.rIWsfxaQKede2zxOT2Vl0AwLj9zZ811AUBUtgaVBNKPRHCI%2BDNc9v7RM%2F10yWWsdOY8xlYMzKaB%2BJi8vMGsdmQ%3D%3D" rel="nofollow" target="_blank">微信支付SDK</a></p><p><a href="https://link.segmentfault.com/?enc=1%2BvDTzUNXR0X2nyelWg8fw%3D%3D.twH2%2BbYRFzGX1lo4LZ04jj%2FHe9%2FmJNveU9g2PqFew036SWTTxrUTCb9tjCtNaTPZ" rel="nofollow" target="_blank">银联SDK</a></p><p><a href="https://link.segmentfault.com/?enc=ewP5fG6y%2FMNnozB%2FKMktfw%3D%3D.RhnnLmNcHlVMgIz8uCS48HdvSQpohiDBjYSnCAHcm%2FnnuGrwPZsUrhlU6AYA%2Bc4%2FxESmIQdWAkn6a%2F2tDXTHlA%3D%3D" rel="nofollow" target="_blank">腾讯QQ SDK</a></p><p><a href="https://link.segmentfault.com/?enc=3uUoFp93OcbKvO9Rz2BQow%3D%3D.7a0mABDMvBcmyKiJ1ziB82xrJ8hnBWCosWbw8mdlkNo%3D" rel="nofollow" target="_blank">新浪微博SDK</a></p><p><a href="https://link.segmentfault.com/?enc=NSCeAtzkQRjul7stxN6IFw%3D%3D.D%2BcoHHE8CJl2rJk9BZ%2FwuZR8ONT5Qh4DZfaix8LRJpY%3D" rel="nofollow" target="_blank">极光PUSH SDK</a></p><p><a href="https://link.segmentfault.com/?enc=QbfjLMMRpRboOUvVxCz8XQ%3D%3D.vaYGT7fSFI1Cd%2B4mZkhhhi3wufb4gZYXzUR2bqNuA8M%3D" rel="nofollow" target="_blank">友盟移动统计SDK</a></p><p><a href="https://link.segmentfault.com/?enc=MxqQHH9t6VWf6ayz1qB1Fg%3D%3D.id1QEqukh8KutK23u0%2B5mudDyUt0wtJo8fymt8jB2DM3xxinmw589NyTWTBazPEEA79BqgAJ2ZVq%2FmeMXswc8Q%3D%3D" rel="nofollow" target="_blank">腾讯微信SDK</a></p><p><a href="https://link.segmentfault.com/?enc=zXMf4t%2F0T1kyZvzqymFC0Q%3D%3D.sFDyCd1HljUJhuvuGG7qJc%2BNLaSBpn3IMhw%2FqiVHHsw%3D" rel="nofollow" target="_blank">高德地图SDK</a></p><p><a href="https://link.segmentfault.com/?enc=1A0nIfHcnB34mJXuQHu%2Bxw%3D%3D.dh0VXqxn9UT3l%2FRp6YLfr7MNZaoMoD8dek7K8T8CPc%2BmVMmRoIUrmwgpOSxF10hb" rel="nofollow" target="_blank">个推</a></p><p><a href="https://link.segmentfault.com/?enc=MxZixJea2gSYaHc2zNKS0Q%3D%3D.3EE%2Fj8tHc6vpPcu7xCzPS6BpUaZQtKU9kr8Sf%2BZCzK4%3D" rel="nofollow" target="_blank">Bugly</a></p><p><a href="https://link.segmentfault.com/?enc=CWaC2kaam7M2EaJ0BnPyVw%3D%3D.%2FFa0zWwdRzxAz1HPb2Xu62QLIOGvdqPYiiu5Bu0DJkk%3D" rel="nofollow" target="_blank">ShareSDK</a></p><p><a href="https://link.segmentfault.com/?enc=fYxqvG9Un4kds4zcSegwdQ%3D%3D.7ZWSdHSNhnuCo7RnCX6kWqjt6garoWyiTAFJmBxJUCATLS0kP%2B0czpIPvH4k2wNkSUItJWrUFVcQGuF0OnldwQ%3D%3D" rel="nofollow" target="_blank">听云SDK</a></p><h4>2.案例概览（<a href="https://link.segmentfault.com/?enc=7PXEpcu%2FxcN7VWX9oJfMQA%3D%3D.q8pq0AFG1nzDW6vghjfozE%2FusgunoXA4LNRDISy1ez3GiKIhFn5YwGnAyRknxp9IGB9qetUrHKiVBdYd8kbyGZkwI%2F8I1Merc2M%2BFBD2DDPLylsQ55N0EFsbHJe%2FYzNHyxv2v5MkEbJkJqentwjWYIQtosRU8ggpnkUmmQPwvUhS5jmsDsmD8gHqU58KbatrqG6RE72amm2xbrrmYcZCFE0eygbGAjWnQFzmPi12Rzg%3D" rel="nofollow" target="_blank">下载模板</a>）</h4><p>基于以上行业分析，本期将介绍鸿蒙生态市场生活服务类行业模板--点餐元服务模板，为行业提供常用功能的开发案例，模板主要分点餐、订单和我的三大模块。</p><ul><li>Stage开发模型 + 声明式UI开发范式。</li><li>分层架构设计 + 组件化拆分，支持开发者在开发时既可以选择完整使用模板，也可以根据需求单独选用其中的业务组件。</li><li>本模板为餐饮点餐类元服务提供了常用功能的开发样例，已集成预加载、华为账号、地图、华为支付、通话等服务，只需做少量配置和定制即可快速实现页面的快速加载、华为账号的登录、商家位置定位导航、购买餐饮和联系商家等功能。</li></ul><p><img width="723" height="403" referrerpolicy="no-referrer" src="/img/bVdm0gi" alt="image.png" title="image.png"/></p><p><strong>本模板主要页面及核心功能如下所示：</strong></p><pre><code>​餐饮点餐模板
|-- 点餐
|    |-- 店铺信息
|    |    |-- 店铺选择
|    |    |-- 店铺详情
|    |    |-- 店铺位置和导航
|    |    └-- 店铺电话
|    |-- 优惠券
|    |    |-- 店铺优惠
|    |    └-- 优惠券列表
|    |-- 商品列表
|    |    |-- 搜索商品
|    |    |-- 商品详情
|    |    |-- 商品规格
|    |    └-- 加入购物车
|    |-- 购物车
|    |    |-- 清空购物车
|    |    |-- 修改购物车商品
|    |    └-- 下单
|    └-- 提交订单
|         └-- 超值加购
|         └-- 钱包支付
|         └-- 订单提交
|-- 订单列表
|    └-- 订单详情
|    └-- 订单支付
└-- 我的
     |-- 用户信息
     |    |-- 修改头像
     |    └-- 关联解绑账号
     |-- 我的中心
     |    |-- 我的钱包
     |    |    |-- 钱包充值
     |    |    └-- 充值记录
     |    |-- 我的优惠券
     |    └-- 我的积分
     └-- 帮助中心
          |-- 常见问题
          └-- 客服电话 </code></pre><h3>二、应用架构设计</h3><h4>1.分层模块化设计</h4><ul><li><p><strong>产品定制层：</strong>专注于满足不同设备或使用场景的个性化需求，作为应用的入口，是用户直接互动的界面。</p><ul><li>本实践暂时只支持直板机，为单HAP包形式，包含路由根节点、底部导航栏等。</li></ul></li><li><p><strong>基础特性层：</strong>用于存放相对独立的功能UI和业务逻辑实现。</p><ul><li>本实践的基础特性层将应用底部导航栏的每个选项拆分成一个独立的业务功能模块。</li><li>每个功能模块都具备高内聚、低耦合、可定制的特点，支持产品的灵活部署。</li></ul></li><li><p><strong>公共能力层：</strong>存放公共能力，包括公共UI组件、数据管理、外部交互和工具库等共享功能。</p><ul><li>本实践的公共能力层分为公共基础能力和可分可合组件，均打包为HAR包被上层业务组件引用。</li><li>公共基础能力包含日志、文件处理等工具类，公共类型定义，网络库，以及弹窗、加载等公共组件。</li><li>可分可合组件将包含行业特点、可完全自闭环的能力抽出独立的组件模块，支持开发者在开发中单独集成使用，详见业务组件设计章节。</li></ul></li></ul><p><img width="723" height="300" referrerpolicy="no-referrer" src="/img/bVdmzmw" alt="image.png" title="image.png" loading="lazy"/></p><h4>2.业务组件设计</h4><p>为支持开发者单独获取特定场景的页面和功能，本模板将功能完全自闭环的部分能力抽离出独立的行业组件模块，不依赖公共基础能力包，开发者可以单独集成，开箱即用，降低使用难度。</p><p><img width="723" height="263" referrerpolicy="no-referrer" src="/img/bVdm0gp" alt="image.png" title="image.png" loading="lazy"/></p><h3>三、行业场景技术方案</h3><h4>1.商品列表</h4><h5>1）场景说明</h5><ul><li>商品列表左侧为分类信息，右侧为商品信息。左侧和右侧列表支持联动滚动，支持搜索和分类商品快速定位。</li></ul><p><img width="723" height="367" referrerpolicy="no-referrer" src="/img/bVdm0gq" alt="image.png" title="image.png" loading="lazy"/></p><h5>2）技术方案</h5><ul><li>使用左右各用一个<a href="https://link.segmentfault.com/?enc=bGsE84DsaK3hOmEWxkNHfg%3D%3D.6u6ynGJSSYu4AJS68CqahplgF2BQFfWorpI2KiEurG7daWCVfYkuLFCu01Su9RV9LCzLK2P%2FbuJ3v%2FpLh8mBO4lElSTt4OhYCI08Sk6s3%2BmNIAYUAUo4BKbFMRccOmuGb1JnAiezUN4H%2F2DxhqoE7ZOBjNIwqG%2B%2F3u0GGu5XNW0%3D" rel="nofollow" target="_blank">List</a>实现商品列表的展示。分别设置其<a href="https://link.segmentfault.com/?enc=MUCnGDlF%2B19KifUEtr%2Fyfw%3D%3D.K80Fcq81oxIR%2BmvzC%2BAqZePGIZO07OnA66DxIeV0Lims3adYHvoYqdPF7WXHeKm8ti5GMke5aC1QD7qWCPx383RXUtmWvZrd7zy%2Ft9Fx4OghHEaFyJCU1Z8dwp%2B%2BBpzixEGvNeLI%2BAVw6Inp7z1A%2FDYeoW%2FY%2FQaxbpU2jkZ2KUc%3D" rel="nofollow" target="_blank">onScrollIndex()</a>事件，使左右List实现连续滚动和快速定位</li><li>通过过滤列表数据实现搜索结果展示。</li></ul><h4>2.店铺选择</h4><h5>1）场景说明</h5><ul><li>用户可以通过选择店铺实现店铺切换功能。页面地图通过华为地图可以展示店铺位置和距离；页面列表展示店铺信息，并且支持店铺导航和拨打电话。</li></ul><p><img width="723" height="367" referrerpolicy="no-referrer" src="/img/bVdm0gx" alt="image.png" title="image.png" loading="lazy"/></p><h5>2）技术方案</h5><ul><li>使用<a href="https://link.segmentfault.com/?enc=929v2jNpp%2FfohQQMcR6yrw%3D%3D.bMwEu9Hz92x%2F3ZK2tEuqQtn7MyXRzvLhuLqGBqQPU5HgbRt5Pus1%2BLPZhcSkhkW6sHuLVfzGdsWA7e1xXbAO5hLyO%2F8VR2Cdh%2Be%2FIwroGN9CDg3pVumu0b2kjm3E398SrEFH5JVheRH4CUjGO8gFWxamMmZS10l0L77Dm76Vg4U%3D" rel="nofollow" target="_blank">MapComponent</a>实现地图绘制能力</li><li>使用<a href="https://link.segmentfault.com/?enc=0cKlsxl34nY%2FOg2%2Fo7uKng%3D%3D.J29g7e3Odzm6qOY9Er4DtvezSY7qcIvLwfMhYmeWxZLUXfT5WLv3WP%2BOil7YmplBhyfmR%2BVLpNTFj92J1yTFSaQDJwXLkuXO1OPoDrbSQni36pisklS%2BnjxxPrZlxty4RN%2FVUlZYbN%2Bs67dkLTyUBTSnxjRCRlxAzsk60NP02ZE%3D" rel="nofollow" target="_blank">makeCall</a>实现快速拨号能力。</li></ul><h3>四、模板代码</h3><h4>1.工程结构（<a href="https://link.segmentfault.com/?enc=YpWPM%2BuGU%2BPlAtEgLlyCXw%3D%3D.ndWaRle2BHuaHer7BShu7nF%2FSeKt3vJjImVCzr%2B7Km93%2FnMFwq%2F60nV4XdoDv5M4hSLCq0u1Hrr2DivKhnLdPF8iMZwvuaM8NQputfA2T1VG8JdC2mW1sfIlU1Q%2Bvxm8Lrg6zRjkIMKcoyiAokRARIOXdWANoClLGhKYiaeKNfIpY94RP2jbkJ2mbTefis4wVPiUA8Jz%2BoDxmYBuRiC3EZb5xojeE3aj8vDIAoCUBNI%3D" rel="nofollow" target="_blank">下载模板</a>）</h4><p>详细代码结构如下所示：</p><pre><code>CateringOrders
  ├─commons/common/src/main
  │  ├─ets
  │  │  ├─cardManager
  │  │  │      CardManager.ets                // 卡片管理
  │  │  │      EntryContext.ets               // 应用上下文
  │  │  │      SubscriberClass.ets            // 卡片公共事件
  │  │  ├─components
  │  │  │      NavHeaderBar.ets               // navigation页面抬头
  │  │  │      CommonConfirmDialog.ets        // 确认弹窗
  │  │  │      LoadingDialog.ets              // 加载中弹窗
  │  │  ├─constants
  │  │  │      Common.ets                     // 公共常量
  │  │  ├─mapper
  │  │  │      Index.ets                      // 数据映射
  │  │  ├─models
  │  │  │      RouterModel.ets                // 路由参数对象
  │  │  │      StorageModel.ets               // AppStorage参数对象
  │  │  │      TabBarModel.ets                // 底部导航栏对象
  │  │  └─utils
  │  │         AsWebRichText.ets              // asweb富文本展示
  │  │         Logger.ets                     // 日志方法
  │  │         PermissionUtil.ets             // 权限申请方法
  │  │         RouterModule.ets               // 路由工具方法
  │  │         Utils.ets                      // 公共方法
  │  └─resources
  ├─commons/network/src/main
  │  ├─ets
  │  │  ├─apis
  │  │  │      APIList.ets                    // 网络请求API
  │  │  │      AxiosHttp.ets                  // 网络请求封装
  │  │  │      AxiosModel.ets                 // 网络请求对象
  │  │  │      HttpRequest.ets                // 网络请求
  │  │  ├─constants
  │  │  │      Index.ets                      // 网络请求常量
  │  │  ├─mocks
  │  │  │  └─MockData
  │  │  │         Order.ets                   // 点餐mock数据
  │  │  │         Store.ets                   // 店铺mock数据
  │  │  │         User.ets                    // 用户mock数据
  │  │  │      AxiosMock.ets                  // mock请求
  │  │  │      RequestMock.ets                // mock API
  │  │  └─types
  │  │         Order.ets                      // 点餐抽象类
  │  │         Request.ets                    // 请求参数抽象类
  │  │         Response.ets                   // 响应参数抽象类
  │  │         Store.ets                      // 店铺抽象类
  │  │         User.ets                       // 用户抽象类
  │  └─resources
  │─components/base_ui/src/main   
  │  ├─ets
  │  │  ├─components
  │  │  │      BusinessTimeDialog.ets         // 店铺休息组件
  │  │  │      CallTelSheetBuilder.ets        // 拨号组件
  │  │  │      CouponCardComp.ets             // 优惠券组件
  │  │  │      OrderGoodsCard.ets             // 订单商品组件
  │  │  │      PayTypeDialog.ets              // 支付弹窗组件
  │  │  │      SheetHeaderComp.ets            // 半模态标题组件
  │  │  ├─constants
  │  │  │      Index.ets                      // 常量数据
  │  │  ├─models
  │  │  │      Index.ets                      // 数据类型
  │  │  └─utils
  │  │         Index.ets                      // 工具方法
  │─components/goods_detail/src/main   
  │  ├─ets
  │  │  ├─components
  │  │  │      GoodsDetail                    // 商品详情组件
  │  │  ├─constants
  │  │  │      Index.ets                      // 常量数据
  │  │  └─models
  │  │         Index.ets                     // 数据类型
  │─components/my_wallet/src/main   
  │  ├─ets
  │  │  ├─components
  │  │  │      MyWallet                       // 我的钱包组件
  │  │  │      RechargeRecordComp             // 充值记录组件
  │  │  ├─models
  │  │  │      Index.ets                      // 数据类型
  │  │  └─utils
  │  │         Logger.ets                     // 日志方法
  │─components/select_store/src/main   
  │  ├─ets
  │  │  ├─components
  │  │  │      HwMapComp                      // 华为地图组件
  │  │  │      SelectStore                    // 选择店铺组件
  │  │  │      StoreCard                      // 店铺卡片组件
  │  │  └─models
  │  │         Index.ets                      // 数据类型
  │─components/snack_sized_deal/src/main   
  │  ├─ets
  │  │  ├─components
  │  │  │      SnackSizedDeal                 // 超值加购组件
  │  │  ├─constants
  │  │  │      Index.ets                      // 常量数据
  │  │  └─models
  │  │         Index.ets                      // 数据类型
  │─features/order/src/main   
  │  ├─ets
  │  │  ├─api
  │  │  │      Index.ets                      // 接口请求封装
  │  │  ├─components
  │  │  │      CustomSelectDialog.ets         // 数据选择半模态弹窗
  │  │  │      GoodInfoComp.ets               // 商品信息组件
  │  │  │      MyCarComp.ets                  // 购物车组件
  │  │  │      MyCarListComp.ets              // 购物车列表组件
  │  │  │      OrderListComp.ets              // 订单内商品列表组件
  │  │  │      TitleComp.ets                  // 点餐标题栏组件
  │  │  ├─constants
  │  │  │      OrderConstant.ets              // 常量数据
  │  │  ├─mapper
  │  │  │      Index.ets                      // 数据映射
  │  │  ├─models
  │  │  │      Index.ets                      // 数据类型
  │  │  │      MustGoodsController.ets        // 必选品控制对象
  │  │  └─pages
  │  │         ConfirmOrderPage.ets           // 确认订单页面
  │  │         GoodDetailPage.ets             // 商品详情页面
  │  │         MerchantDetailPage.ets         // 店铺详情页面
  │  │         OrderPage.ets                  // 点餐页面
  │  │         PreviewImagePage.ets           // 图片预览页面
  │  │         RemarksPage.ets                // 添加备注页面
  │  │         SelectCouponPage.ets           // 选择优惠券页面
  │  │         SelectStorePage.ets            // 选择店铺页面
  │  │         SnackSizedDealPage.ets         // 超值加购页面
  │  └─resources
  │─features/order_list/src/main   
  │  ├─ets
  │  │  ├─api
  │  │  │      Index.ets                      // 接口请求封装
  │  │  ├─components
  │  │  │      ButtonListComp.ets             // 卡片按钮组件
  │  │  │      CommonTab.ets                  // 订单列表tab组件
  │  │  │      OrderCard.ets                  // 订单卡片组件
  │  │  │      OrderTypeComp.ets              // 订单详情顶部组件
  │  │  │      PaymentDetailsComp.ets         // 订单支付详情组件
  │  │  │      ReductionCardComp.ets          // 订单优惠详情组件
  │  │  │      StoreInfoCardComp.ets          // 商户卡片组件
  │  │  ├─mapper
  │  │  │      Index.ets                      // 数据映射
  │  │  ├─models
  │  │  │      Index.ets                      // 订单列表里的数据对象
  │  │  └─pages
  │  │         HwMapPage.ets                  // 商户位置页面
  │  │         OrderDetailPage.ets            // 订单详情页面
  │  │         OrderListPage.ets              // 订单列表页面
  │  └─resources
  │─features/personal_center/src/main   
  │  ├─ets
  │  │  ├─api
  │  │  │      Index.ets                      // 接口请求封装
  │  │  └─pages
  │  │         AnswerPage.ets                 // 常见问题页面
  │  │         FrequentQuestionPage.ets       // 问题答复页面
  │  │         MyCouponsPage.ets              // 我的优惠券页面
  │  │         MyWalletPage.ets               // 我的页面
  │  │         PersonalCenterPage.ets         // 我的钱包页面
  │  │         RechargeRecordPage.ets         // 钱包充值记录页面
  │  │         WalletTermsPage.ets            // 会员储值协议页面
  │  └─resources
  │─preload
  │      handler.js                           // 预加载函数
  │      package.json                         // 预加载函数信息
  └─products/phone/src/main   
     ├─ets
  │  │  ├─api
  │  │  │      Index.ets                      // 接口请求封装
     │  ├─components
     │  │      CustomTabBar.ets               // 自定义底部tab栏组件
     │  ├─entryability
     │  │      EntryAbility.ets               // 应用程序入口
     │  ├─entryformability
     │  │      EntryFormAbility.ets           // 卡片程序入口
  │  │  ├─mapper
  │  │  │      Index.ets                      // 数据映射
     │  ├─pages
     │  │      HomePage.ets                   // 主页面
     │  │      Index.ets                      // 入口页面
     │  └─widget/pages
     │         WidgetCard.ets                 // 卡片页面
     └─resources</code></pre><h4>2.关键代码解读</h4><p>本篇代码非元服务的全量代码，只包括元服务的部分能力的关键代码。</p><h5>1)二级联动列表</h5><pre><code>// 下标索引处理
currentIndexChangeAction(index: number, isClassify: boolean): void {
  if (this.currentIndex !== index) {
    this.currentIndex = index;
// 是否是分类列表
    if (isClassify) {
      this.scroller.scrollToIndex(index);
    } else {
      this.titleItemScroller.scrollToIndex(index);
    }
  }
}

// 列表头部
@Builder
titleHeader(title: string, count: number) {
  Row() {
    Text() {
      Span(`${title}`)
        .fontSize($r('sys.float.Body_M'))
        .fontWeight(FontWeight.Medium)
        .fontColor($r('sys.color.font_primary'))
      Span(`（${count}）`)
        .fontSize($r('sys.float.Caption_M'))
        .fontColor($r('sys.color.font_secondary'))
        .padding({ left: 4 })
    }
  }
  .margin({ bottom: 8, top: 8 })
}
build() {
  Column() {
    // 列表页
    Row({ space: 8 }) {
      List({ scroller: this.titleItemScroller }) {
        ForEach(this.dishesList, (item: DishesTypeResp, index: number) =&gt; {
          ListItem() {
            TitleItem({
              typeName: item.typeName,
              hasIcon: item.id === Constants.GOOD_TYPE_HOT,
              isSelected: this.currentIndex === index,
              onClickAction: () =&gt; {
                if (index !== undefined) {
                  this.currentIndexChangeAction(index + 1, true);
                }
              },
            })
          }
        }, (item: DishesTypeResp) =&gt; item.typeName + this.currentIndex)
        ListItem() {
          Column().width(Constants.FULL_SIZE).height(78)
        }
      }
      .width(92)
      .height(Constants.FULL_SIZE)
      .listDirection(Axis.Vertical) // 排列方向
      .backgroundColor(Color.White)
      .scrollBar(BarState.Off)
      .divider({ strokeWidth: 1 })

      List({ scroller: this.scroller }) {
        ListItem() {
          Search({ value: $$this.searchText, placeholder: $r('app.string.search_goods') })
            .textFont({ size: $r('sys.float.Body_L') })
            .width(Constants.FULL_SIZE)
            .placeholderFont({ size: $r('sys.float.Body_L') })
            .maxLength(20)
            .margin(0)
            .onChange((value: string) =&gt; {
              if (value) {
                this.dishesList = this.dishesList.map((item) =&gt; {
                  item.goods = item.goods.filter(i =&gt; i.name?.includes(value))
                  return item
                })
              } else {
                this.dishesList = JSON.parse(JSON.stringify(this.dishesListOri))
              }
            })
        }

        ForEach(this.dishesList, (item: DishesTypeResp) =&gt; {
          ListItemGroup({
            header: this.titleHeader(item.typeName, item.goods.length),
            space: 10,
          }) {
            ForEach(item.goods, (listItem: Goods) =&gt; {
              ListItem() {
                GoodInfoComp({ item: listItem })
              }
            }, (listItem: Goods) =&gt; JSON.stringify(listItem))

          }
        }, (item: DishesTypeResp) =&gt; JSON.stringify(item))
        ListItem() {
          Column() {
            Divider().margin({ top: 12 })
            Text($r('app.string.list_bottom'))
              .fontSize(8)
              .fontWeight(300)
              .fontColor($r('sys.color.font_primary'))
              .margin({ top: 8 })
          }.width(Constants.FULL_SIZE).height(106)
        }
      }
      .layoutWeight(1)
      .height(Constants.FULL_SIZE)
      .scrollBar(BarState.Off)
      .sticky(StickyStyle.None)
      .onScrollIndex((start: number) =&gt; this.currentIndexChangeAction(start - 1, false))
    }.layoutWeight(1).margin({ right: 16 })
  }.width(Constants.FULL_SIZE).height(Constants.FULL_SIZE).constraintSize({ maxHeight: Constants.FULL_SIZE })
}
// 分类列表元素
@ComponentV2
export struct TitleItem {
  @Param @Require typeName: string;
  @Param hasIcon: boolean = false
  @Param isSelected: boolean = false;
  @Event onClickAction: () =&gt; void = () =&gt; {
  }

  build() {
    Row() {
      if (this.hasIcon) {
        Image($r('app.media.ic_hot')).width(16)
      }
      Text(this.typeName)
        .fontSize($r('sys.float.Body_S'))
        .fontColor(this.isSelected ? $r('sys.color.multi_color_09') : $r('sys.color.font_secondary'))
        .textAlign(TextAlign.Center)
    }
    .justifyContent(FlexAlign.Center)
    .backgroundColor(this.isSelected ? '#0FED6F21' : '#0D979797')
    .width(Constants.FULL_SIZE)
    .height(48)
    .padding({ left: 10, right: 10 })
    .border({ width: { right: this.isSelected ? 0.5 : 0 }, color: $r('sys.color.multi_color_09') })
    .onClick(this.onClickAction)
  }
}</code></pre><h5>2)地图封装</h5><pre><code>// 地图参数初始化
@Local mapController?: map.MapComponentController;
@Local mapEventManager ?: map.MapEventManager;
private marker: Map&lt;string, map.Marker&gt; = new Map&lt;string, map.Marker&gt;()
private mapOption?: mapCommon.MapOptions;
private callback?: AsyncCallback&lt;map.MapComponentController&gt;;
private style: mapCommon.MyLocationStyle = {
  anchorU: 0.5,
  anchorV: 0.5,
  radiusFillColor: 0xff00FFFFFF,
  displayType: mapCommon.MyLocationDisplayType.FOLLOW,
};

aboutToAppear(): void {
  this.mapOption = {
    position: {
      target: {
        latitude: this.selectLocation.latitude,
        longitude: this.selectLocation.longitude,
      },
      zoom: 15,
    },
  };

  this.callback = async (err, mapController) =&gt; {
    if (!err) {
      this.mapController = mapController;
      this.mapEventManager = this.mapController.getEventManager();
      this.mapEventManager?.on('markerClick', (marker: map.Marker) =&gt; {
        console.info(`on-markerClick marker = ${marker.getTitle()}`);
        this.changeStore(marker.getTitle())
      });

      this.mapController.on('mapLoad', () =&gt; {
        console.info('mapLoad success');
      });
      this.abilityEnabled();
      mapController.setMyLocationStyle(this.style);
      this.updateMakers()
    }
  };
}

// 地图选择店铺后移动镜头
@Monitor('selectStore.id')
cameraChange(monitor: IMonitor) {
  if (monitor.value()?.now) {
    this.moveCamera(this.selectLocation)
  }
}

// 监听位置变化，更新标记
@Monitor('locations')
infoChange(monitor: IMonitor) {
  if (monitor.value()?.now) {
    this.updateMakers()
  }
}

// 更新地图标记位
updateMakers() {
  this.mapController?.clear()
  this.marker?.clear()
  this.locations.forEach(location =&gt; {
    this.addMarker(location)
  })
  if (this.selectLocation) {
    this.moveCamera(this.selectLocation)
  }
}

// 创建地图标记位
async addMarker(location: MapLocation) {
  // Marker初始化参数
  let markerOptions: mapCommon.MarkerOptions = {
    position: {
      latitude: location.latitude,
      longitude: location.longitude,
    },
    rotation: 0,
    visible: true,
    zIndex: 0,
    alpha: 1,
    anchorU: 0.5,
    anchorV: 1,
    clickable: true,
    draggable: true,
    flat: false,
    icon: location.icon || 'ic_store_location.png',
  };
  // 创建Marker
  let marker = await this.mapController?.addMarker(markerOptions);
  if (marker) {
    // 设置信息窗的标题
    marker.setTitle(location.title);
    this.marker.set(location.id, marker)
  }
}

// 移动镜头
moveCamera(location: MapLocation) {
  this.mapController?.animateCameraStatus(map.newLatLng({
    latitude: location.latitude,
    longitude: location.longitude,
  }, 15), 200).then(() =&gt; {
    this.marker?.get(location.id)?.setInfoWindowVisible(true)
  });
}

// 加载地图组件
build() {
  Stack({ alignContent: Alignment.BottomStart }) {
    MapComponent({
      mapOptions: this.mapOption,
      mapCallback: this.callback,
    })
  }.height('100%').margin({ bottom: this.mapMarginBottom / 2 }).constraintSize({ maxHeight: '100%' })
}</code></pre><h4>3.模板集成</h4><p>本模板提供了两种代码集成方式，供开发者自由选用。</p><h5>1)整体集成（<a href="https://link.segmentfault.com/?enc=xpCIyGuAQs%2Fpsmw%2FV2DPCw%3D%3D.jyvqC9Ev0eGUFZkhW3RCg3gvLG0%2BAaGPdBNW7eurYu6WUrO4wzNr0xxT4AaEDLY4zpvxiXXPXY4oy3rmczHxx1BsAKK9SPoIcbOzK3eOUGNUGoUweBSk%2Bv%2BJBsHxG59XddW%2BHCaA64uXSWKpErSdQm7oGD9HzRz6MAacvedPn1MWcg3cc5MfS2xKB1dlcUyJqFq2j%2BNAHwMp8bxEvyD4jlzVpdIrifOuKNA584xtOlE%3D" rel="nofollow" target="_blank">下载模板</a>）</h5><p>开发者可以选择直接基于模板工程开发自己的应用工程。</p><ul><li><p><strong>模板代码获取：</strong></p><ul><li>通过IDE插件创建模板工程，<a href="https://link.segmentfault.com/?enc=OMJ7DdGCVhYlanfFi1K4cg%3D%3D.puxGxXKnhSF55MifuU5Z%2FKnvcKmpoN8JSD1ZlSR0x%2F4nk1kPFb8d08FCfBHADogYG0hbF%2Bbu2eeGdyKoQzaKlYsIYGlndD%2B%2BOAKYXm2tqE13D8jlT8Arj5GUfkuBWAexOGeOsUaDo%2BqKBlTtJR2jzMA0VcJzJt1vYdRMTbFQ5C%2FUcph%2BpdlEGL%2BTVr1rbME%2F" rel="nofollow" target="_blank">开发指导</a>。</li><li>通过生态市场下载源码， <a href="https://link.segmentfault.com/?enc=NQendPWNRoFaEvWoutQpbw%3D%3D.o0he81g%2Bhzouu8mx3rPkrx2%2FsWWJTg%2FGrg3spyp2jf9o8pPHkbbsAbos%2FNzKGgg%2F7lsgeP%2BZ5kIklGjzysWFbgNRUFTpPAB%2FDKOykO4Nl9xIWLOhAd%2BT%2BkVmKjUWjmgIKcouWUwTKg1tqoWR3rbU3MRLGtFv3orUUNxtW0gz7a2ILPYi49Qacm1sULJiEJDsqCskSCjz9T%2BEkVyHsorZgqURsWefQTxu%2BrtHeKNG8do%3D" rel="nofollow" target="_blank">下载模板</a>。</li><li>通过开源仓访问源码，<a href="https://link.segmentfault.com/?enc=wq%2BtzHA8xXK1Hy4GAJlg5A%3D%3D.HsCMncCK9PJGbOjqmnfExgtgiq%2BqyVsNB89XtyZ%2FueX0t3923zb6hDul5SqToLUjeswL6HfvPwIa%2FAe9%2BiJQ5sE5KLv1Vx6UgbthKyav%2B11%2FZuIJ8KDenw5fFt9SXHV3DFbnb%2FQF%2B8HXozmR2hJXZA1j3pyKiL0xRIykg6QoFrkgwHFGNY9sYtMG3%2FvRg8TWeoLh6SWFTdNsD7wr3MDnKfIe8uRSz%2FjaFA4kvCIHEog%3D" rel="nofollow" target="_blank">仓库地址</a>。</li></ul></li><li><strong>打开模板工程，根据README说明中的快速入门章节，将自己的应用信息配置在模板工程内，即可运行并查看模板效果。</strong></li></ul><p><img width="723" height="388" referrerpolicy="no-referrer" src="/img/bVdm0gz" alt="image.png" title="image.png" loading="lazy"/></p><ul><li><strong>对接开发者自己的服务器接口，转换数据结构，展示真实的云侧数据。</strong></li></ul><p>将commons/lib_common/src/main/ets/httprequest/HttpRequestApi.ets文件中的mock接口替换为真实的服务器接口。</p><p><img width="723" height="492" referrerpolicy="no-referrer" src="/img/bVdm0gA" alt="image.png" title="image.png" loading="lazy"/></p><p>在commons/network/src/main/ets/types目录中将云侧开发者自定义的数据结构转换为端侧数据结构。</p><p><img width="723" height="677" referrerpolicy="no-referrer" src="/img/bVdm0gB" alt="image.png" title="image.png" loading="lazy"/></p><p>根据自己的业务内容修改模板，进行定制化开发。</p><h5>2)按需集成</h5><p>若开发者已搭建好自己的应用工程，但暂未实现其中的部分场景能力，可以选择取用其中的业务组件，集成在自己的工程中。</p><ul><li><p><strong>组件代码获取：</strong></p><ul><li>通过IDE插件下载组件源码。<a href="https://link.segmentfault.com/?enc=lzbX6IX4PiV1OGtlHbje6A%3D%3D.z34vURYdQyujE0dyEc4OjxS2Me%2Fkt5gkpSd4RnuKhj4icO6ASyIdQJZqGaZ4MPcvHkj4KGPdDW5dLxt28JNC7O%2FMgh6MNjHHgSF50Yr8%2FyQHjqY7kZ1qquFsoOlrMuF%2BEIjB2m%2Fyr4uITVaQmZ%2Bwi%2FCA55mNx9iVPWS5082iElY6MnrfbJqErxVXttavjR6J" rel="nofollow" target="_blank">开发指导</a></li><li>通过生态市场下载组件源码。 <a href="https://link.segmentfault.com/?enc=CBqCKepF4YfenjC5gZKUwg%3D%3D.nRW%2BasscMWe0O15JrgqcJZR3fAlAgIP61rWxVlrvbBTyUOh8ml6lc4%2BYiUfk6JTJ%2FrABF4jevU64p2pZUxXo7d%2F7AvLQrWohCAvcpq96AK0aWQR6lCV5geX6%2BJYChyfTQnraPB9j%2BKPZ5sF%2FPIbU04FBqvIf59nvyU1XR8CFUL1s1WrG8IG5ep62CLpj4J%2BYOx655WnCAIV%2BMZ8sZ%2Bma1XxADRLgLiR%2BW%2BcM27cX4p8%3D" rel="nofollow" target="_blank">下载地址</a></li></ul></li><li><strong>下载组件源码，根据README中的说明，将组件包配置在自己的工程中。</strong></li><li><strong>根据API参考和示例代码，将组件集成在自己的对应场景中。</strong></li></ul><p><strong>以上是第14期"餐饮点餐"行业优秀案例的内容，更多行业敬请期待~</strong></p><p>欢迎下载使用行业模板"<strong><a href="https://link.segmentfault.com/?enc=7jLysQPjjuPYJdF5imhgFA%3D%3D.LAvt5w9QSY7iMdmfwJMsDVxXGlDPJ%2Bj0thTJvEyvPXf6L1UvP1Hc7fK1REFr5Pv%2Bu1A5e5Dd6e%2FUBL%2B%2FlFYwm9lTjqBbbr6Qwo6%2BKvp%2FB2irr5nxQmDwu2mp15Xs%2BR5GbWL8O%2FW%2BVVPfx4J4Rwyg%2B1yuQWkhaeYkwPqgWjkrxY4%2BJYsyzYz%2Fu%2FEY3nZWsuzspU4Xble3fpLap%2Bs5MLNsDLxafuJpuUP1rzXOXzuxQdU%3D" rel="nofollow" target="_blank">点击下载</a></strong>"，<strong>若您有体验和开发问题，或者迫不及待想了解XX行业的优秀案例，欢迎在评论区留言</strong>，小编会快马加鞭为您解答~</p><p>同时诚邀您添加下方二维码加入"组件模板活动社群"，精彩上新&amp;活动不错过！</p><p><img width="723" height="351" referrerpolicy="no-referrer" src="/img/bVdm0gC" alt="image.png" title="image.png" loading="lazy"/></p><p>👉 <strong>HarmonyOS官方模板优秀案例系列持续更新，</strong> <strong><a href="https://link.segmentfault.com/?enc=B9trPpxZ7BZg2OWeVXkN8Q%3D%3D.Per7EonFDAfb6X%2F4kciqFCcsYx7zepBFEnYT1%2B1FF%2BophZCJWQ7SrFJp9C4xgMWJiUgt9Zp9%2BvnJ%2Fk4hwHjjKcJDjsPFvOnfT0b0i9RK3zVeG9BHT%2FpiDS3YtPWVNJTNl6vdSUOnwU5snaSU6Nu1li%2BTx8tCzIohtncFar%2FQBQ6tO%2BHmb1k%2BegDXnda2Dnb%2B" rel="nofollow" target="_blank">点击查看</a>往期案例汇总贴</strong>， 点击收藏 “💗”<strong>方便查找！</strong></p><p><strong>👉【集成有礼】HarmonyOS官方模板集成创新活动，挥洒创意，赢精美大礼！<a href="https://link.segmentfault.com/?enc=M5wTGwSR5GvRHkjU48R8%2FA%3D%3D.zJHsGMXrTO2mUeZGqJW7HnwDAUApssvhAW9LSLld%2FipiF9pyJCBFDpNTrZK8TEubuwsXoK9Dmfnv8pEZiSajWhWX7ccrGKHlsn90zaZTcEHv7Xz2Of6BaldGzy3qWLTlx36q%2Bi2trhkuEF3mK6zKrw%3D%3D" rel="nofollow" target="_blank">点击参加</a></strong></p><p><strong>👉【HarmonyOS行业解决方案】为各行业鸿蒙应用提供全流程技术方案。<a href="https://link.segmentfault.com/?enc=tfqpIbgvsRKI9FUVW83alA%3D%3D.U357V%2BiHwUyZ0i194e46DM5rgF5cjbfy%2Bb4jHFOh1R5uwWO%2Fah5lsL%2BuNz8kDzlANi%2Br1hNst9m4jn0YH9XkI1ykVoAN7u5oaz2TJ9nb20E6zmJV59qxeneOyS3mXtNWG3A1M596JccK0Ax7Lps7uxgzltXlHQoUdb6YP8Yp5iy%2F8FE4GOAYcP3%2Fr07MOwsO" rel="nofollow" target="_blank">点击查看</a></strong></p>]]></description></item><item>    <title><![CDATA[商汤日日新开源模型实现空间智能性能突破，]]></title>    <link>https://segmentfault.com/a/1190000047389373</link>    <guid>https://segmentfault.com/a/1190000047389373</guid>    <pubDate>2025-11-11 16:05:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>今天，商汤日日新在空间智能领域实现重要突破，正式发布并开源SenseNova-SI系列模型。在多项权威评测的空间理解和推理任务上，SenseNova-SI 不仅大幅度领先同量级开源多模态大模型，还超越了 GPT-5 和 Gemini 2.5 Pro 等国际顶尖闭源模型的表现。</p><p><strong>空间智能短板与系统性解决</strong></p><p>当下行业领先的大模型，虽然在知识、写作、推理、编程等方面展示了突出的性能，但是普遍存在一个重要的缺陷，就是对空间结构的理解和推理存在很严重的短板，而这恰恰是具身智能体与世界交互所需要的关键基础能力。</p><p>我们来看一个例子，左图源自最强大脑的图形推理题，对人类都具有相当的难度，GPT-5能够轻松破解，可见它在非空间智能问题上已具备很强能力。反观右图，是一道人类儿童都能轻易解决的简单空间问题，要求选择正确俯视图，GPT-5却令人意外地犯起了难，错误地选择了”A”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389375" alt="" title=""/></p><p>以上例子恰好暴露了当前大模型在空间理解上的短板。因此要让AI真正”看懂”三维世界，空间智能一直是关键的试金石。</p><p>商汤围绕空间智能进行了深入创新探索，找到了提升空间智能的系统性训练方法，打造了日日新·空间智能大模型系列 SenseNova-SI 并正式开源。</p><p><strong>评测表现多项任务超越GPT-5，显著领先同量级开源模型</strong></p><p>这次开源的SenseNova-SI空间智能大模型系列包括 2B 和 8B 两个规格。</p><p>最新评测数据显示，SenseNova-SI系列模型在空间智能多个基准测试（VSI、MMSI、MindCube、ViewSpatial）中表现突出，具体如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389376" alt="" title="" loading="lazy"/></p><p>数据来源：<a href="https://link.segmentfault.com/?enc=qlPtDag0JATcHpiObZrh7A%3D%3D.pfz20DBjDprXMJ%2BXSUxsYc8e4af08Xt4%2F4w9v1kIpWR0GFLWRBSYb6TN9KFoaTia" rel="nofollow" target="_blank">https://github.com/OpenSenseNova/SenseNova-SI</a></p><p>其中SenseNova-SI-8B模型在四个基本评测中获得 60.99 的平均成绩，不仅大幅领先Qwen3-VL-8B（40.16）、BAGEL-7B（35.01）等开源通用多模态模型，以及 SpatialMLLM（35.05）、ViLaSR-7B（36.41） 等专门的空间智能模型，还以相对轻量的模型规格实现了对GPT-5（49.68）、Gemini-2.5-Pro（48.81）等顶级闭源模型的超越。这里显著的性能提升反映了模型在空间智能上获得了质的突破，而不是简单的性能改善。</p><p><strong>基于”尺度效应”的训练范式<strong><em><em>，实现能力系统性提升</em></em></strong>​</strong></p><p>SenseNova-SI的性能飞跃，源于商汤从训练数据到方法上的系统性方案。依托商汤提出的空间能力分类体系和过往多样化的数据的积累，团队采用系统化的方法扩充空间理解数据的规模，首次在空间智能领域验证了“尺度效应”，即通过高质量、大规模数据训练，可显著提升模型的空间认知能力。</p><p>商汤提出的训练范式具备通用性，能够针对不同架构的基模型（如InternVL等）进行有效增强，使其在空间智能六大核心维度上——包括空间测量、空间重构、空间关系、视角转换、空间形变与空间推理——实现一致性的能力提升。</p><p>商汤稍后将发布详细的技术报告，详细阐述具体的技术方案。</p><p>以下为GPT-5和SenseNova-SI-8B模型面对空间智能问题，给出的答案对比。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389377" alt="" title="" loading="lazy"/></p><p>​<em>给出的</em><em>立方体组合图形，要求选择正确俯视图</em>。GPT-5选择答案D，SenseNova-SI-8B选择答案B，正确答案为B。（例题源自SITE-Bench）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389378" alt="" title="" loading="lazy"/></p><p>假设我站在手持相机人的位置，并且面朝他现在面朝的方向。摩托车是位于我的左侧还是右侧？ GPT-5选择答案A（左侧），SenseNova-SI-8B选择答案B，​​正确答案为B（右侧）。（例题源自SITE-Bench）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389379" alt="" title="" loading="lazy"/></p><p>多车道道路场景，判断黄色汽车的后续动作（如直行、转向等）。GPT-5选择答案C（静止），SenseNova-SI-8B选择答案（D），​​正确答案为D（右转）​​。（例题源自SITE-Bench）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389380" alt="" title="" loading="lazy"/></p><p><em>同一户外场景，通过视角变化判断移动方向</em><em>。</em>GPT-5选择答案C，SenseNova-SI-8B选择答案D，正确答案为向左前方移动（选项D）。（例题源自MindCube）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389381" alt="" title="" loading="lazy"/></p><p><em>同一室内空间，包含白板、椅子和<strong>沙发等</strong>，通过物体位置变化分析</em>移动方向。GPT-5选择答案D，SenseNova-SI-8B选择答案A，正确答案为向左前方移动（选项A）。（例题源自MindCube）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389382" alt="" title="" loading="lazy"/></p><p><em>从不同角度拍摄带黑色衣物的桌子，</em>从正面视角（图1）判断桌子右侧物体。GPT-5选择答案B，SenseNova-SI-8B选择答案C，正确答案为门（选项C）。（例题源自MindCube）</p><p><strong>推动世界模型和具身智能生态发展</strong></p><p>空间智能是世界模型与具身智能理解物理世界的基础能力。今年7月，商汤正式发布“悟能”具身智能平台，该平台以商汤“开悟”世界模型为核心引擎，旨在为机器人和智能设备提供在物理世界中自主探索和进化的能力。</p><p>此次发布的空间智能大模型SenseNova-SI，与“开悟”世界模型相辅相成，将更好地解决多模态模型从数字空间走向物理世界的基础挑战，并在未来进一步推动AI在自动驾驶、机器人等场景的应用。</p><p>此外，商汤还同步开源了空间智能测评平台 EASI（<a href="https://link.segmentfault.com/?enc=%2Favm2%2Fy3%2BtUuDcfW2deq7Q%3D%3D.V9DsOOFywCSFWxvAvmaJZlgPmaXEF3BFyx2bxn5tqheyEqQ%2BnkFdBjuW8tfrl41Z" rel="nofollow" target="_blank">https://github.com/EvolvingLMMs-Lab/EASI</a>）与“英雄榜”，旨在推动空间智能技术评估标准的统一，持续跟踪并展示开源和闭源模型的性能进展，为学术界和工业界提供权威的评估基准，促进协同创新。</p><p>商汤SenseNova-SI的推出标志着AI在三维世界理解能力上迈出关键一步，也为下一代通用人工智能技术融入物理世界打下坚实基础。</p>]]></description></item><item>    <title><![CDATA[隐语社区可信数据空间MOOC第13讲笔记]]></title>    <link>https://segmentfault.com/a/1190000047389328</link>    <guid>https://segmentfault.com/a/1190000047389328</guid>    <pubDate>2025-11-11 16:05:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>2.7 密态大模型 学习笔记</h2><h3>一、概述</h3><ul><li><strong>目标</strong>：实现数据要素在安全可信环境下的流通与应用。</li><li><strong>核心</strong>：密态大模型，保护数据在使用、传输、存储过程中的安全。</li><li><strong>应用背景</strong>：大模型在垂直行业深入应用，数据安全与隐私保护成为关键挑战。</li></ul><hr/><h3>二、背景与问题定义</h3><h4>1. 大模型产业应用趋势</h4><ul><li>更垂直、更丰富的应用场景</li><li>需要更强的领域适应能力与专业知识</li></ul><h4>2. 面临的安全挑战</h4><ul><li><strong>数据与模型隐私</strong>：数据安全、隐私保护、知识产权</li><li><strong>信任难题</strong>：模型优化与应用中的安全与信任问题</li><li><p><strong>高质量数据利用率低</strong>：</p><ul><li>数据因不信任而无法被外部机构使用</li><li>专业数据难以用于构建行业大模型</li></ul></li></ul><h4>3. 参与方及其关注点</h4><ul><li><strong>行业大模型构建者</strong>：数据安全、模型安全</li><li><strong>模型使用方</strong>：Query安全、个人隐私、商业机密</li></ul><hr/><h3>三、关键技术概念</h3><h4>1. 机密计算（Confidential Computing）</h4><ul><li><strong>定义</strong>：通过基于硬件的可信执行环境保护使用中的数据。</li><li><p><strong>核心组件</strong>：</p><ul><li><strong>TEE</strong>：可信执行环境，确保仅授权代码可执行，外部无法读取或篡改。</li><li><strong>App Enclave</strong>：隔离的执行环境，保护特定代码与数据。</li></ul></li><li><strong>威胁模型</strong>：防止云服务商等第三方在代码执行过程中访问数据。</li></ul><h4>2. 密态大模型全链路保护</h4><ul><li>涵盖从<strong>后训练</strong>到<strong>推理</strong>的全过程</li><li>保护对象：训练数据、模型参数、用户Query</li></ul><hr/><h3>四、动手实践：部署密态大模型推理服务</h3><h4>环境准备</h4><ul><li><strong>硬件</strong>：带GPU的x86机器（ARM需参考vLLM官网）</li><li><strong>网络</strong>：可访问公网（用于下载模型）</li><li><p><strong>软件</strong>：</p><ul><li>Python ≥ 3.10</li><li>Docker ≥ 19.03</li></ul></li></ul><h4>部署步骤</h4><ol><li><p>克隆代码库：</p><pre><code class="bash">git clone https://github.com/secretflow/trustflow
cd examples/llm-inference</code></pre></li><li><p>启动服务：</p><pre><code class="bash">docker compose up</code></pre></li><li>预期输出：vLLM服务启动成功，显示多个路由信息。</li></ol><hr/><h3>五、总结</h3><ul><li>密态大模型实现<strong>全链路密态保护</strong>，覆盖训练、推理全过程。</li><li>基于<strong>TrustFlow的CCTF框架</strong>，可快速构建安全的大模型推理服务。</li><li>适用于对数据安全、模型隐私有高要求的行业场景。</li></ul>]]></description></item><item>    <title><![CDATA[工业互联网指标工场如何帮助企业实现数据驱]]></title>    <link>https://segmentfault.com/a/1190000047389350</link>    <guid>https://segmentfault.com/a/1190000047389350</guid>    <pubDate>2025-11-11 16:04:18</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>工业互联网指标工场作为智能制造体系中的核心组成部分，是现代制造业实现数字化转型的重要基础设施。随着工业4.0时代的深入发展，制造企业面临着数据量激增、系统复杂度提升以及决策效率要求提高等多重挑战。在此背景下，指标工场通过系统化的数据采集、处理和分析，为企业提供了一套完整的指标管理体系，帮助实现从数据到洞察、从洞察到行动的闭环管理。<br/>指标工场的核心价值在于其能够将分散在不同系统、设备中的工业数据转化为具有业务意义的指标体系。这一过程涉及数据采集、数据清洗、指标计算、可视化展示和智能预警等多个环节。例如，在汽车制造行业，通过指标工场可以实时监控生产线设备综合效率（OEE），分析设备停机时间的主要成因，并自动生成优化建议。广域铭岛通过部署指标工场，成功将数字化柔性制造，生产效率提升90%+。<br/>在流程工业领域，指标工场的应用同样展现出显著价值。以广域铭岛为例，企业通过建立能耗指标管理体系，实时监测各生产环节的能源消耗情况，并结合生产计划与实际产出，构建能源效率指标模型。广域铭岛通过指标工场实现了对生产全流程的能耗监控，能源管理效率提升25%，能源消耗减少15%，同时减少了碳排放量。<br/>指标工场的建设不仅需要先进的技术支撑，更需要与业务场景的深度融合。在实施过程中，企业需要首先明确关键业务指标，建立统一的指标定义规范，确保数据的一致性和准确性。其次，要构建灵活可扩展的技术架构，支持多源异构数据的接入和处理。最后，还需要建立持续优化的机制，通过机器学习等技术手段，实现指标的自动优化和预警。<br/>值得注意的是，指标工场的成功实施往往面临诸多挑战。数据质量问题、系统集成复杂度、组织协同难度等都是需要重点关注的方面。某电子制造企业在实施指标工场初期，就曾因设备数据采集标准不统一而导致指标计算出现偏差。后来通过建立统一的数据治理体系，制定了标准化的数据采集规范，最终实现了指标的准确计算和可靠应用。<br/>随着人工智能技术的发展，指标工场正在向智能化方向演进。通过引入机器学习算法，指标工场不仅能够实现历史数据的分析，更能够进行预测性分析，为企业提供前瞻性的决策支持。例如，在装备制造领域，一些企业开始利用指标工场实现预测性维护，通过分析设备运行数据，提前预警潜在故障，大大降低了非计划停机时间。<br/>未来，随着工业互联网平台的持续演进和5G、边缘计算等新技术的广泛应用，指标工场将在实时性、准确性和智能化程度等方面实现进一步提升。制造企业应当将指标工场作为数字化转型的核心组成部分，通过建立完善的指标管理体系，真正实现数据驱动决策，提升企业核心竞争力。</p>]]></description></item><item>    <title><![CDATA[青否双AI数字人开启“主播+助播”新时代]]></title>    <link>https://segmentfault.com/a/1190000047389383</link>    <guid>https://segmentfault.com/a/1190000047389383</guid>    <pubDate>2025-11-11 16:03:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>一场直播，两位主播，一个讲解专业细致，一个捧场互动热烈——这不是传统直播团队的标配，而是青否数字人带来的AI直播新范式。</p><p>在数字人技术蓬勃发展的今天，青否突破了单数字人直播的局限，创新性地实现了双AI数字人协同直播，让“主播+助播”的精准分工在虚拟世界完美重现（青否数字人源头：zhibo175）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389385" alt="" title=""/></p><p>从“一人说”到“两人搭”，AI协作逻辑重塑直播体验</p><p>青否数字人通过深度复刻真人直播协作方式，让双AI实现了“主播+助播”的精准分工。这种创新模式彻底打破了传统数字人直播“一人独白”的单调局面，为直播行业带来了全新可能。</p><p>在直播过程中，数字人主播负责专注讲解商品，而AI助播则实时捧哏或回复观众弹幕，两种角色默契配合，创造出流畅自然的直播节奏与生动的互动氛围。</p><p>这种双人搭配的直播模式，让直播全程有互动、有重点、有节奏，就像两个经验丰富的真人主播在配合，大大提升了观众的观看体验和停留时长。</p><p>多种直播配合模式，满足不同直播场景需求</p><p>青否数字人支持“讲品+捧场”或“讲品+回复弹幕”等多种直播配合模式，能够根据不同的直播内容和阶段，智能切换互动方式，带来更高频的互动和更强的直播节奏。</p><p>无论是产品推介、品牌宣传还是促销活动，双数字人都能找到合适的表达方式，确保直播效果。</p><p>罗永浩数字人直播创下AI直播新标杆</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389386" alt="" title="" loading="lazy"/></p><p>双数字人直播带货能真正利用AI数字人为直播赋能，做到真正的降本增效。此前，罗永浩数字人电商直播首秀便创下了AI直播的新标杆，证明了这一模式的商业价值和市场潜力。</p><p>相比传统直播，数字人直播不仅能够大幅降低人力成本，还能实现24小时不间断直播，显著提升直播效率和覆盖面。</p><p>支持侧脸转身、进出镜头、挡嘴挡脸、多人出镜、产品特写、双人换班、喝水、休息、蹦跳等任意动作场景克隆，让数字人更真实更自然。</p><p>行业自动化互动，四大互动解决方案</p><p>青否数字人打造了集智能、定时、互动、主动于一体的AI互动解决方案！</p><p>智能互动：基于直播话术、自定义知识库、主播人设及自研直播AI小模型，实时解析用户弹幕问题，精准提供专业解答，回复率超95%，专业度满分！</p><p>定时互动：数字人主播定时播报+定时弹幕推送，内容同样智能泛化，避免机械重复。主播可提前规划直播节奏，精准推送关键信息，刺激用户下单！</p><p>互动增强：突破传统关键词限制！支持多条关键词关联1条核心意图。AI自动泛化回复内容，面对相同问题，主播每次都能给出意思一致但表达多样的回复，互动更自然、更专业！</p><p>主动互动：无需预设，AI主动识别直播间关键节点，智能触发欢迎语、引导关注点赞、精准催单促单等互动，显著拉升互动率与下单转化率！</p><p>实时互动功能</p><p>打造沉浸式直播体验</p><p>弹幕互动：当用户提出问题时，主播会迅速在抖音评论区@用户并回复相应的文本。还支持定时发送弹幕。</p><p>真人接管实时互动（阿凡达模式）：可选择开麦或文字输入，选择克隆音色进行接管操作，实时驱动直播间的数字人进行回复。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389387" alt="" title="" loading="lazy"/></p><p>多姿态数字人，双数字人互动直播，这些超牛的实时互动功能在青否数字人直播系统均可实现，使用数字人形象复刻超真实直播间。</p>]]></description></item><item>    <title><![CDATA[怎么优化设备资源生命周期设计中的预测性维]]></title>    <link>https://segmentfault.com/a/1190000047389391</link>    <guid>https://segmentfault.com/a/1190000047389391</guid>    <pubDate>2025-11-11 16:02:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在制造业的数字化转型浪潮中，设备资源管理不再是传统意义上的维护与修复，而是从更宏观的视角出发，贯穿设备全生命周期的战略设计。从设备的规划、采购、安装调试，到运行维护与性能优化，再到报废处置的闭环管理，设备资源生命周期设计（Equipment-Asset Life-Cycle Management, EALM）正成为企业提升效率、降低成本的关键抓手。这一范式转变不仅是技术层面的融合，更是管理理念与流程的全面升级。<br/>广域铭岛的创新实践展示了设备资源生命周期设计的核心价值。通过工业物联网（IIoT）技术与边缘计算（Edge Computing）的结合，管理者能够实时采集设备的运行参数，并转化为直观可用的数据指标。例如，在某汽车工厂的智能制造应用中，振动传感器和温度采集器的作用使得预测性维护成为可能。这种能力不仅仅是技术的堆叠，而是对设备健康状况的动态评估体系，能够通过历史数据建模精确计算设备的剩余使用寿命（RUL），从而指导企业在全生命周期内做出更合理、更高效的资源配置决策。<br/>设备资源生命周期设计的实施路径需要覆盖前期规划、中期运行维护和后期报废处置三个阶段。前期管理的核心在于精准定位设备需求，确保规划阶段的技术方案与全生命周期成本（LCC）相匹配。广域铭岛的案例表明，合理的设备选型与设计阶段的考量直接影响后期的运行稳定性与维护成本。通过数字孪生模型进行选型评估，企业不仅可以避免“功能冗余”的采购浪费，还能提前识别设备的设计缺陷，减少后期脱离管理状况的可能性。<br/>运行维护阶段是设备资源生命周期设计的另一关键环节。基于实时数据分析的预测性维护模式，使得管理者的决策更加贴近实际需求。广域铭岛的设备智能体系统通过强化学习算法自主制定维护方案，实现了从被动维修到主动预防的转变。例如，某家电企业通过这一技术优化了备件库存策略，库存周转率提升了 40%。这不仅是对历史数据的管理升级，更重要的是构建了动态风险管控体系，确保设备资源始终处于最佳运行状态。<br/>设备资源的报废与处置环节同样需要精心设计。广域铭岛基于 LCC 分析，动态评估设备残值，帮助企业在合适的时间完成资产处置，确保系统的可持续性。同时，区块链技术的引入让设备全生命周期溯源更为透明，这为资源的闭环管理提供了可信依据。<br/>随着技术的不断演进，设备资源生命周期设计进入新的发展阶段。融合数字孪生、预测性维护和 AIOps 技术的系统架构，正在重新定义制造业的资产管理模式。广域铭岛的“设备智能体”与“自愈合工厂”理念推动这一设计范式向智能化跃迁，从运行管理升级到价值创造的层次。<br/>未来，设备资源生命周期设计仍将不断演进。全球制造业的竞争不仅停留在效率层面，更延伸至技术整合与预测决策的前沿领域。区块链、AI预测与数字化工厂操作系统的双向连接，将构建起更加无缝的管理闭环。对于追求卓越绩效的企业而言，设备资源生命周期设计已成为实现智能制造和价值链高端跃迁的核心路径。<br/>设备资源生命周期设计最终指向制造业的可持续发展。它验证了 IIoT 与 AI 算法从被动干预到主动管控的能力，更明确了设备管理的未来方向：从功能支持到价值驱动的全方位系统性管理。这一理念不仅重塑企业设备管理系统，更成为其数字化战略的关键节点。</p>]]></description></item><item>    <title><![CDATA[从零构建 H5 可视化搭建项目：前端技术]]></title>    <link>https://segmentfault.com/a/1190000047389491</link>    <guid>https://segmentfault.com/a/1190000047389491</guid>    <pubDate>2025-11-11 16:02:15</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>从零构建 H5 可视化搭建项目：前端技术栈选型与核心模块开发<br/>在当今数字化浪潮中，H5 可视化搭建项目因其能够快速创建出具有丰富交互效果的 H5 页面，满足不同场景下的宣传、营销等需求，受到了众多企业和开发者的青睐。从零开始构建这样一个项目，前端技术栈的选型以及核心模块的开发是关键环节，下面将详细探讨这两个方面。<img width="723" height="474" referrerpolicy="no-referrer" src="/img/bVdm0kM" alt="" title=""/></p><p>前端技术栈选型：Vue 与 React 的抉择<br/>在构建 H5 可视化搭建项目时，前端框架的选择至关重要，Vue 和 React 作为当下最热门的两大前端框架，各有其独特的优势和适用场景。</p><p>Vue：渐进式框架的魅力<br/>Vue 是一个渐进式的 JavaScript 框架，这意味着开发者可以根据项目的需求逐步引入其功能。对于 H5 可视化搭建项目来说，Vue 的这种特性具有很大的吸引力。</p><p>学习成本低：Vue 的语法设计简洁明了，接近传统的 HTML、CSS 和 JavaScript 开发方式，对于有前端基础的开发人员来说，上手难度较低。即使是初学者，也能在较短的时间内掌握其核心概念和基本用法，项目开发中。例如，其模板语法直观易懂，开发者可以直接在 HTML 中编写类似原生 HTML 的结构，并通过指令来实现数据绑定和交互逻辑，大大降低了学习曲线。<br/>开发效率高：Vue 提供了丰富的开发工具和生态系统，如 Vue CLI 可以快速创建项目脚手架，Vue Router 实现页面路由管理，Vuex 进行状态管理。这些工具的集成使得开发过程更加高效，减少了开发者在项目配置和基础功能实现上的时间投入。在 H5 可视化搭建项目中，开发者可以利用 Vue 的组件化开发特性，将页面拆分成多个可复用的组件，如按钮组件、图片展示组件等，提高代码的复用性和可维护性。<br/>响应式数据绑定：Vue 的核心特性之一是响应式数据绑定，当数据发生变化时，视图会自动更新。这在 H5 可视化搭建项目中非常实用，例如，当用户通过拖拽操作修改了页面元素的属性（如颜色、大小等）时，相关的数据会实时更新，视图也会随之改变，无需手动操作 DOM，提高了开发效率和用户体验。<br/>React：函数式编程的强大<br/>React 是一个用于构建用户界面的 JavaScript 库，它以函数式编程为核心思想，强调组件化和状态管理。</p><p>组件化开发：React 的组件化思想非常彻底，将整个应用拆分成多个独立的组件，每个组件负责自己的渲染和逻辑处理。这种开发方式使得代码结构更加清晰，易于维护和扩展。在 H5 可视化搭建项目中，可以通过创建各种组件来实现不同的页面元素，如文本组件、图片组件、表单组件等，并且可以方便地组合和复用这些组件，快速构建出复杂的页面。<br/>强大的生态系统：React 拥有庞大的生态系统，有大量的第三方库和工具可供选择。例如，React Router 用于实现页面路由，Redux 用于状态管理，Material - UI 等 UI 库提供了丰富的组件和样式。这些工具和库可以帮助开发者快速搭建出功能完善、界面美观的 H5 可视化搭建平台。<br/>高性能渲染：React 采用了虚拟 DOM 技术，通过比较虚拟 DOM 的差异来减少对实际 DOM 的操作，从而提高渲染性能。在 H5 可视化搭建项目中，当页面元素较多或频繁更新时，React 的高性能渲染特性可以确保页面流畅运行，不会出现卡顿现象。<br/>选型决策<br/>在选择 Vue 还是 React 时，需要综合考虑项目的规模、团队的技术栈和经验、开发周期等因素。如果项目规模较小，开发周期较短，且团队对 Vue 比较熟悉，那么 Vue 可能是更好的选择，因为它可以快速上手，提高开发效率。如果项目规模较大，需要构建复杂的交互逻辑和状态管理，且团队具备 React 的开发经验，那么 React 的组件化和强大的生态系统将更有优势。</p><p>核心模块开发：构建可视化搭建的基石<br/>确定了前端技术栈后，接下来就是核心模块的开发。H5 可视化搭建项目通常包括以下几个核心模块：</p><p>组件库模块<br/>组件库是 H5 可视化搭建项目的基础，它提供了各种可用的页面元素，如文本、图片、按钮、表单等。在开发组件库时，需要考虑组件的通用性、可定制性和复用性。</p><p>通用性：组件应该能够适应不同的场景和需求，具有广泛的适用性。例如，按钮组件可以设置不同的样式、大小和点击事件，以满足不同的交互需求。<br/>可定制性：用户应该能够根据自己的需求对组件进行定制，如修改颜色、字体、边距等属性。可以通过提供属性配置面板来实现组件的可定制性，让用户在可视化界面中轻松调整组件的样式和行为。<br/>复用性：组件应该具有良好的复用性，可以在不同的页面中重复使用。通过将组件封装成独立的模块，并定义清晰的接口，可以提高组件的复用性，减少代码冗余。<br/>画布编辑模块<br/>画布编辑模块是用户进行页面搭建的主要工作区域，用户可以在画布上拖拽组件、调整组件的位置和大小、设置组件的属性等。</p><p>拖拽功能：实现组件的拖拽功能是画布编辑模块的核心。可以通过 HTML5 的拖放 API 或第三方拖拽库来实现组件的拖拽操作，让用户能够直观地将组件放置到画布的指定位置。<br/>布局管理：画布需要提供合理的布局管理机制，确保组件在画布上的排列整齐、有序。可以采用网格布局、流式布局等方式来管理组件的位置和大小，同时支持用户自定义布局。<br/>属性设置面板：当用户选中画布上的组件时，需要显示相应的属性设置面板，让用户可以修改组件的属性。属性设置面板应该提供直观的界面和丰富的选项，方便用户进行操作。<br/>页面预览与发布模块<br/>页面预览与发布模块允许用户在完成页面搭建后，预览页面的效果，并将页面发布到指定的平台。</p><p>页面预览：提供实时的页面预览功能，让用户在搭建过程中能够及时看到页面的实际效果。可以通过将组件的渲染结果在预览窗口中展示来实现页面预览，同时支持在不同设备尺寸下的预览，确保页面在各种设备上都能正常显示。<br/>页面发布：当用户对页面效果满意后，可以将页面发布到指定的平台，如服务器、CDN 等。在发布过程中，需要对页面进行打包和优化，确保页面的加载速度和性能。同时，提供发布历史记录和版本管理功能，方便用户对已发布的页面进行管理和维护。<br/>数据管理模块<br/>数据管理模块负责管理页面中的数据，包括组件的属性数据、用户输入的数据等。</p><p>数据存储：选择合适的数据存储方式，如本地存储、数据库等，来存储页面中的数据。对于一些简单的数据，可以使用浏览器的本地存储（如 localStorage、sessionStorage）来保存；对于复杂的数据，可以考虑使用数据库进行存储。<br/>数据绑定：实现组件属性与数据之间的绑定，当数据发生变化时，自动更新组件的显示。可以通过 Vue 或 React 的数据绑定机制来实现数据与组件的同步更新，确保页面的实时性。<br/>数据交互：提供与后端服务器的数据交互功能，如获取数据、提交数据等。可以通过 AJAX、Fetch API 或 Axios 等技术来实现与后端的数据通信，实现页面的动态数据展示和交互。<br/>从零构建 H5 可视化搭建项目需要谨慎选择前端技术栈，并根据项目需求开发核心模块。无论是选择 Vue 还是 React，都需要充分发挥其优势，结合组件库、画布编辑、页面预览与发布、数据管理等核心模块的开发，打造出一个功能强大、易于使用的 H5 可视化搭建平台，满足不同用户的需求。</p>]]></description></item><item>    <title><![CDATA[AI赋能职场：个体即团队，效能倍增新范式]]></title>    <link>https://segmentfault.com/a/1190000047389496</link>    <guid>https://segmentfault.com/a/1190000047389496</guid>    <pubDate>2025-11-11 16:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047389498" alt="图片" title="图片"/><br/>近期多项行业实践显示，AI工具已深度渗透职场场景：银行合同审查AI系统可自动识别合规风险点并标注，智能协作平台3分钟即可完成原需3小时的信贷初审文书，行政领域的AI应用亦实现日程联动、会议室预订及考勤统计的自动化。这一趋势引发部分职场人士对“岗位替代”的担忧，但本质上，AI并非职场竞争者，而是推动效率升级与价值重构的核心助力。如同20年前Excel工具作为办公神器，当前AI工具的核心价值在于解放人力、聚焦高价值创造。明晰以下三大核心认知，筑牢AI基础应用能力，方能借助技术红利巩固职场核心地位，实现个人与组织价值的双重提升。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047389499" alt="图片" title="图片" loading="lazy"/><br/>AI的核心定位并非颠覆现有工作模式，而是以协同赋能的方式优化价值创造流程。现代企业级AI工具凭借跨系统数据整合、流程化事务处理的核心优势，成为个体开展工作的高效支撑，推动人机协同形成1+1＞2的价值效应。以金融行业法务场景为例，传统跨境金融合同审核需耗费大量时间比对不同地区合规条款，且易因信息繁杂出现遗漏；企业级AI工具可自动拆解合同核心要素，精准识别“违约金比例超标”“管辖权约定模糊”等合规风险点，并配套行业合规参考依据。法务人员得以从重复性审核工作中释放精力，聚焦“谈判策略制定”“特殊场景合规判断”等高价值决策环节，最终实现效率提升3倍、出错率降低80%的显著成效。本质而言，AI的核心应用场景是承接“重复、耗力、高容错成本”的事务性工作，将人力从机械劳动中解放，聚焦“需专业判断、创意构思、情感链接”的核心价值环节。明晰AI的能力边界与协同逻辑，是构建高效人机关系、实现个体与组织价值同步增长的基础。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047389500" alt="图片" title="图片" loading="lazy"/><br/>传统职场评价体系以“任务完成量”为核心指标，而AI时代的竞争力核心已转向“借助AI工具放大价值产出”的能力。“AI协同应用能力”正成为职场核心硬技能，而AI基础认知（包括工作逻辑、适用场景与局限）是该技能的核心支撑。AI基础认知并非要求掌握技术原理，而是明确其核心优势与应用边界：擅长数据处理、批量信息整合与标准化内容生成，却在情感洞察、复杂场景决策等领域存在局限；能够快速整合多源信息，但其输出结果需人工把控合规性与细节准确性。基于这一认知，才能实现精准派活、有效把关的人机协同模式。某国际银行风控岗位的实践印证了这一逻辑：传统模式下，风控专员日均审核50笔贷款，且易因信息遗漏导致风险；引入AI工具后，专员通过对接征信数据系统，借助AI标红异常流水与风险点，同时针对AI尚未覆盖的新型欺诈手段，重点开展疑难案例复核与AI模型优化，最终实现效率提升5倍、坏账率下降18%的业绩突破，成为年度核心绩效贡献者。可见，AI带来是“能力迭代压力”——缺乏AI协同意识与基础认知的从业者，将逐渐脱离职场发展节奏。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047389501" alt="图片" title="图片" loading="lazy"/><br/>行业实践表明，AI重构的并非特定岗位，而是“停留在事务性执行层面”的工作模式。以会议相关工作为例，仅承担“笔记记录”的角色确实易被AI实时总结功能覆盖，但具备AI协同能力的从业者，已转型为“会议价值提炼者”——通过AI完成待办事项整理与基础信息汇总，再结合业务深层逻辑，分析提炼“关键决策点、跨部门协同需求、潜在风险隐患”，成为管理层不可或缺的决策支撑者。这一趋势贯穿各类岗位：AI正在重构工作流程与价值分工，而核心竞争力的关键在于“借助AI完成自我能力升级”，而非固守传统工作模式。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047389502" alt="图片" title="图片" loading="lazy"/><br/>面对AI驱动的职场生态变革，个体唯有主动拥抱技术、构建深度人机协同能力，才能突破单一角色边界，具备团队级综合产出能力，实现“一人成团”的效能跃迁。具体路径如下：1.前置AI协同场景，整合多维度职能输出摒弃“被动等待部署”的传统思维，将AI定位为常态化“虚拟协作单元”，前置嵌入工作全流程。报表编制前，借助AI快速整合跨系统数据、搭建多维度分析框架；方案策划阶段，通过AI梳理核心逻辑、覆盖多场景可行性分析；跨部门协同前，利用AI草拟标准化通知、预设沟通闭环节点。个体无需依赖其他角色支持，即可统筹“数据处理、逻辑梳理、沟通协调”等原需团队分工的基础职能，实现团队级协同效果与效率倍增。2.阶梯式实操演练，搭建个体“虚拟协作体系”无需急于推进复杂场景应用，从标准化、低容错成本的任务起步，如借助AI生成部门会议议程、整合多维度客户信息台账、优化跨岗位工作流程等。通过持续实操，逐步掌握“精准指令下达、业务背景赋能、AI输出校准”等核心技巧，构建适配自身工作场景的“虚拟协作矩阵”。在迭代中降低人机协同试错成本，让个体逐步具备独立承接团队级任务的综合能力。3.强化“指令精准度+AI认知力”，打造团队级操盘能力AI输出质量直接决定个体协同效能，摒弃模糊化表述，采用“场景定义+目标拆解+边界限定”的精准模式，例如将“制定信贷推广方案”优化为“制定季度个人消费信贷产品推广方案，针对25-40岁刚入职白领及小微企业主客群，包含‘首贷利率85折、线上审批3分钟放款、最长24期分期免息’三大核心权益，营销预算10万元内，目标季度新增放款额5000万元，需嵌入合规告知条款及不良率控制预案。认知层面，系统学习AI基础逻辑与能力边界，明确其在数据整合、批量处理、标准化输出等领域的优势，以及在复杂决策、情感洞察等场景的局限。通过“精准指挥+科学统筹”，让AI充分发挥“虚拟团队成员”的专业价值，助力个体成为高效的“团队核心操盘手”。<br/>AI赋能的核心价值，在于打破个体职能边界，让单一个体具备“数据处理、流程推进、多场景输出”的团队级综合能力，实现从“单一执行者”到“复合型价值单元”的跃迁。这一“个体即团队”的新范式，不仅是个体职场竞争力的核心壁垒，更是组织提升人力效能、强化市场应变能力的关键。对于管理层而言，推动团队全员落地这一协同范式，是构建组织核心竞争力的重要举措。容智面向企业客户打造的专属AI训练营，依托真实业务场景案例与无编程门槛的教学模式，提供从基础应用到实战落地的系统化培训，助力团队快速掌握“一人成团”的协同技巧，将技术能力转化为实实在在的价值产出。当组织面临“效率提升”“价值增长”的核心需求时，具备AI协同能力的团队与个体，将成为破局的关键力量。</p>]]></description></item><item>    <title><![CDATA[疯了还是天才？（下）：揭秘ObjectS]]></title>    <link>https://segmentfault.com/a/1190000047389269</link>    <guid>https://segmentfault.com/a/1190000047389269</guid>    <pubDate>2025-11-11 15:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>系列文章导读： 在上篇，我们了解了ObjectSense基于Vim的“根基”；在中篇，我们探讨了它“三位一体”的SIDE生态。现在，我们将触及它最核心、也是最大胆的主张：它凭什么“让AI无法取代”？<br/>（上篇）一个“复古”的破局者<br/>（中篇）“三位一体”的Super IDE<br/><strong>（下篇）真正的“AI护城河”：微语言</strong><br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm0g6" alt="image.png" title="image.png"/><br/>“梯子”最高阶：它凭什么“AI无法取代”？<br/>为什么AI Copilot能写Python、Java，却可能“写”不好ObjectSense？<br/>答案不在于它的OOP语法，也不在于它的SIDE。根据其技术文档，ObjectSense隐藏了两个真正的“大杀器”，它们共同构成了其“AI护城河”：</p><ol><li>“Micro” (微语言)</li><li>“Harmony” (和谐框架 - 编译调度)<br/>要理解这两个工具，我们需要先做一个类比：<br/>今天的AI，是一个顶级的“乐高拼装大师”。你给它一本厚厚的“图纸”（比如Python的语法规则和你的需求），它能以惊人的速度，比任何人都更准确地拼出“千年隼”模型（即写出功能代码）。<br/>但AI有一个短板：它不擅长“发明”乐高积木。它不会在拼装时，突然觉得“我缺一个2x5的带弧度的转角件”，然后自己设计一套模具，把这个新积木“发明”出来。<br/>AI是“规则的追随者”，而不是“规则的创造者”。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm0g9" alt="image.png" title="image.png" loading="lazy"/><br/><strong>Micro（微语言）：从“拼积木”到“造积木”</strong><br/>ObjectSense的“Micro”机制，正是它回应AI的方式。文档这样描述它：<br/>“Micro是基于ObjectSense的微语言，类似于Lisp宏的机制……你将可以声明并使用自己的语言并以此创造无限可能。”<br/>“Lisp宏”这个词，对于资深开发者来说意义非凡。它是一种强大的“元编程（Metaprogramming）”能力。<br/>翻译过来就是：ObjectSense给开发者的，不是“积木”（语言本身），而是“制造积木的机器”（语言设计能力）。<br/>当一个AI在“使用”Python时，它是在既定规则内解题。 当一个开发者在“使用”ObjectSense的“Micro”时，他是在“创造规则”。<br/>例如，文档提到了“Smart Contract（智能合约）”。开发者可以利用“Micro”机制，设计一套最适合描述智能合约的“专用语法”，然后让这套新语法无缝嵌入到ObjectSense中。<br/>Harmony（和谐框架）：把“新积木”变成现实<br/>如果说“Micro”是用来“设计新积木”的，那么“Harmony”框架就是那座“工厂”。<br/>根据文档，“Harmony”是一个“编译调度”框架。它负责注册和使用不同的“Compiler（编译器）”。<br/>这意味着，你用“Micro”设计的“智能合约专用语法”，可以通过“Harmony”框架，调用对应的编译器（如文档中提到的SmartContract编译器），最终被编译成目标代码，例如EVM字节码或C语言代码。<br/>“Micro”让你定义规则，“Harmony”让你执行规则。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdm0hb" alt="image.png" title="image.png" loading="lazy"/><br/><strong>结论：“以人为本”的真正含义</strong><br/>现在，我们可以重新审视ObjectSense那个“AI无法取代”的主张。<br/>它不是一句空洞的口号，而是一种“升维”的开发哲学。它赌的是：AI将会彻底自动化所有“重复性的”、“遵循既定规则”的编码劳动（拼积木）。<br/>但AI无法取代“创造性的”、“定义新抽象”的设计劳动（发明积木）。<br/>ObjectSense的“以人为本”，其真正的含义，就是试图把开发者从日常“编码”（Coding）的角色中解放出来，强迫（或者说赋能）他们去扮演“架构师”和“语言设计者”的角色。<br/>（全文完）<br/>讨论<br/>你觉得 ObjectSense 的理念是“异想天开”还是“未来趋势”？<br/>你认为“元编程”（Metaprogramming）会是程序员对抗AI内卷的“银弹”吗？<br/>在Vim的基础上构建生态，你认为它能挑战VSCode的地位吗？<br/>欢迎在评论区留下你的看法。</li></ol>]]></description></item><item>    <title><![CDATA[SM2 vs RSA/ECC：双算法 S]]></title>    <link>https://segmentfault.com/a/1190000047388998</link>    <guid>https://segmentfault.com/a/1190000047388998</guid>    <pubDate>2025-11-11 14:09:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>SM2 vs RSA/ECC：双算法 SSL 证书的性能对比与优化方案</h2><p>双算法 SSL 证书（如同时支持 SM2 与 RSA/ECC）的核心价值在于平衡<strong>合规性</strong>（如国内政务、金融场景的国密要求）与<strong>国际兼容性</strong>（欧美市场依赖 RSA/ECC），但两种算法的底层数学原理差异会直接影响性能表现。本文从实测数据出发，对比 SM2、RSA、ECC 的性能差异，并针对双算法部署的瓶颈提供可落地的优化方案。</p><p>双算法SSL证书申请入口⬇️</p><p><a href="https://link.segmentfault.com/?enc=EEY%2Fnkn7yDEgK28jrQixwg%3D%3D.dcHTYOwAIYBkEeJIQbi%2ByLs%2FhPuNXad7pdhYAdgFDmwnDcgGFsUxSYx3m2nSzkTJQDIPhicCceYLxG%2Bm3zLxWZdAoz1f2NxLzAKIiuZepRY%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/dual_algorithm.html...</a></p><p><img width="723" height="450" referrerpolicy="no-referrer" src="/img/bVdmOqt" alt="93b41f9735e5bc85205fe82990af4f60.png" title="93b41f9735e5bc85205fe82990af4f60.png"/></p><h3>一、算法底层特性与性能基准：为什么差异会存在？</h3><p>SM2、RSA、ECC 的性能差异源于其加密原理的本质区别，需先明确三者的核心特性：</p><ul><li><strong>RSA</strong>：基于大数分解难题，密钥长度与安全性正相关（如 2048 位对应中等安全，4096 位对应高安全），但加密 / 解密运算复杂度随密钥长度呈指数级增长。</li><li><strong>ECC</strong>（如 secp256r1）：基于椭圆曲线离散对数难题，相同安全强度下密钥长度仅为 RSA 的 1/6-1/4（256 位 ECC≈2048 位 RSA），运算效率显著更高。</li><li><strong>SM2</strong>：我国自主设计的椭圆曲线算法，基于 SM2 椭圆曲线参数（GF (p) 上的曲线），安全强度与 256 位 ECC 相当，但算法细节（如签名格式、密钥协商流程）与国际 ECC 存在差异，需专用加密库支持（如 GMSSL）。</li></ul><h4>核心性能指标对比（基于实测数据）</h4><p>在相同硬件环境（Intel Xeon E5-2680 v4，8 核 16 线程）、软件栈（Nginx 1.25 + OpenSSL 3.0/GMSSL 3.0）下，对三种算法的关键性能指标测试如下：</p><table><thead><tr><th><strong>指标</strong></th><th><strong>SM2（256 位）</strong></th><th><strong>ECC（secp256r1）</strong></th><th><strong>RSA（2048 位）</strong></th><th><strong>RSA（4096 位）</strong></th></tr></thead><tbody><tr><td>密钥对生成耗时（ms）</td><td>12.3</td><td>8.7</td><td>45.6</td><td>328.1</td></tr><tr><td>TLS 握手耗时（客户端，ms）</td><td>38.5</td><td>32.1</td><td>65.3</td><td>142.7</td></tr><tr><td>每秒新建连接数（CPS）</td><td>2860</td><td>3210</td><td>1580</td><td>210</td></tr><tr><td>签名运算耗时（ms）</td><td>0.82</td><td>0.65</td><td>3.2</td><td>28.7</td></tr><tr><td>验签运算耗时（ms）</td><td>1.2</td><td>0.98</td><td>0.35</td><td>2.1</td></tr><tr><td>证书体积（KB）</td><td>2.8</td><td>2.5</td><td>1.8</td><td>3.2</td></tr></tbody></table><p><strong>关键结论</strong>：</p><ol><li>椭圆曲线类算法（SM2、ECC）在<strong>握手速度</strong>和<strong>并发连接能力</strong>上显著优于 RSA，尤其 4096 位 RSA 性能差距达 10 倍以上；</li><li>SM2 性能略逊于 ECC（secp256r1），主要因专用加密库（GMSSL）优化成熟度不及 OpenSSL 对 ECC 的支持；</li><li>RSA 的<strong>验签速度</strong>反超椭圆曲线算法（因 RSA 验签为 “小指数运算”），但整体被握手阶段的性能劣势抵消。</li></ol><h3>二、双算法证书的性能瓶颈：为何 1+1≠2？</h3><p>双算法证书（如同时嵌入 SM2 和 RSA 公钥）的部署会引入额外性能损耗，核心瓶颈集中在三个环节：</p><h4>1. 证书传输与解析开销</h4><p>双算法证书需包含两套公钥及签名链，体积比单算法证书增加 60%-80%（如从 2KB 增至 3.5-4.5KB）。在高延迟网络（如移动 4G/5G）中，证书传输耗时会增加 20-30ms，且客户端解析双证书链时 CPU 占用提升约 15%。</p><h4>2. 算法协商的复杂性</h4><p>TLS 握手阶段，客户端需与服务器协商使用 SM2 还是 RSA/ECC 算法：</p><ul><li>若客户端不支持 SM2（如国际浏览器 Chrome、Firefox 默认禁用），服务器需额外判断并切换至 RSA/ECC，增加 1-2 次握手往返；</li><li>部分老旧客户端（如 Android 7.0 以下）对双算法证书的扩展字段解析存在兼容性问题，可能导致握手失败重试，进一步消耗资源。</li></ul><h4>3. 服务器端资源竞争</h4><p>双算法证书需服务器同时维护两套加密上下文（SM2 与 RSA/ECC 的会话缓存、密钥材料），内存占用增加约 30%；在高并发场景下，两种算法的加密运算会竞争 CPU 资源，导致平均响应时间延长 10-20%。</p><h3>三、分场景优化方案：从配置到架构的全链路调优</h3><p>针对双算法证书的性能瓶颈，需结合场景需求（如合规优先、性能优先、兼容性优先）设计分层优化策略：</p><h4>1. 算法协商优化：减少无效交互</h4><ul><li><p><strong>动态算法优先级</strong>：根据客户端 IP 或 User-Agent 判断场景（如国内 IP 优先 SM2，海外 IP 优先 ECC），通过 Nginx 配置预设算法顺序：</p><p>nginx</p><pre><code># 国内用户优先SM2，海外用户优先ECC
map $geoip_country_code $ssl_cipher_preference {
    default "EECDH+AESGCM:EDH+AESGCM";  # 海外优先ECC
    CN "SM2-WITH-SMS4-GCM:EECDH+AESGCM";  # 国内优先SM2
}
ssl_prefer_server_ciphers on;
ssl_ciphers $ssl_cipher_preference;</code></pre></li><li><strong>启用 TLS 1.3</strong>：TLS 1.3 将握手流程从 2-RTT 缩减至 1-RTT，且支持 “预共享密钥（PSK）” 复用会话，可将双算法协商的额外耗时降低 60% 以上。</li></ul><h4>2. 服务器端运算优化：降低 CPU 负载</h4><ul><li><strong>硬件加速</strong>：通过 HSM（硬件安全模块）或 SSL 加速卡（如 Intel QAT）卸载 SM2/ECC 的密钥生成、签名等重运算，可使 CPU 占用降低 40-70%；</li><li><strong>加密库优化</strong>：使用 GMSSL 3.0+（支持 SM2 硬件加速）和 OpenSSL 3.0+（引入 “provider” 架构，可动态加载国密算法插件），相比旧版本性能提升 20-30%；</li><li><p><strong>会话复用</strong>：启用 TLS Session Tickets 或 Session ID，将重复连接的握手耗时从 30-60ms 降至 5-10ms（复用率需保持在 70% 以上）：</p><p>nginx</p><pre><code>ssl_session_cache shared:SSL:10m;  # 缓存10MB会话信息
ssl_session_timeout 1d;  # 会话超时1天
ssl_session_tickets on;  # 启用TLS Session Tickets</code></pre></li></ul><h4>3. 证书链与传输优化：减少网络开销</h4><ul><li><strong>证书链压缩</strong>：移除双算法证书中冗余的中间 CA 证书（仅保留根 CA 交叉认证部分），将证书体积压缩至 3KB 以内；</li><li><p><strong>启用 OCSP Stapling</strong>：服务器预先获取证书吊销状态并随握手发送，避免客户端单独请求 OCSP 服务器（可减少 1-2 次网络请求，节省 50-100ms）：</p><p>nginx</p><pre><code>ssl_stapling on;
ssl_stapling_verify on;
ssl_trusted_certificate /path/to/trusted_chain.pem;  # 信任链文件</code></pre></li><li><strong>HTTP/2 多路复用</strong>：在支持 HTTP/2 的服务器中，双算法证书的单连接可承载多路请求，减少重复握手次数（尤其适合 API 服务、静态资源服务器）。</li></ul><h4>4. 架构层优化：分离场景负载</h4><ul><li><strong>按算法拆分服务</strong>：对纯国内合规场景（如政务内网）部署 SM2 单算法证书，对国际业务部署 ECC 单算法证书，通过负载均衡器（如 F5、Nginx Plus）根据路径或域名分流，避免双算法共存的性能损耗；</li><li><strong>边缘节点缓存</strong>：在 CDN 节点部署双算法证书，利用边缘节点的低延迟特性减少证书传输耗时，同时 CDN 厂商的专用加密硬件可优化双算法运算效率。</li></ul><h3>四、场景化决策指南：如何选择优化方向？</h3><table><thead><tr><th><strong>场景</strong></th><th>核心需求</th><th>优先优化策略</th><th>性能目标</th></tr></thead><tbody><tr><td>政务云平台</td><td>国密合规优先，国内用户为主</td><td>启用 TLS 1.3 + SM2 硬件加速 + 会话复用</td><td>新建连接耗时 &lt;50ms，CPS&gt;2000</td></tr><tr><td>跨境电商网站</td><td>兼容国内外用户，低延迟</td><td>动态算法优先级 + CDN 部署 + HTTP/2</td><td>海外用户握手耗时 &lt;80ms，复用率&gt; 80%</td></tr><tr><td>金融交易系统</td><td>高安全 + 高并发</td><td>分离 SM2/ECC 服务 + HSM 加密 + 会话 Ticket 复用</td><td>交易响应延迟 &lt; 100ms，CPU 占用 &lt; 50%</td></tr><tr><td>移动应用 API 服务</td><td>低功耗，弱网兼容</td><td>证书链压缩 + OCSP Stapling + ECC 优先</td><td>移动端握手耗时 &lt; 40ms，流量节省 30%</td></tr></tbody></table><h3>五、总结：双算法证书的性能本质是 “平衡术”</h3><p>SM2 与 RSA/ECC 的性能差异并非 “绝对优劣”，而是<strong>场景适配性</strong>的体现：SM2 在国内合规场景中是 “必选项”，ECC 在国际兼容性与通用性能上更优，RSA 则适合对老旧客户端兼容性要求极高的场景。</p><p>双算法证书的优化核心不是 “消除差异”，而是通过<strong>算法协商策略、硬件加速、协议优化</strong>等手段，将两种算法的性能损耗控制在可接受范围（通常额外开销 &lt;15%），最终实现 “合规不牺牲体验，兼容不降低安全” 的目标。</p><p>未来随着量子计算威胁加剧，双算法甚至多算法证书（融合后量子密码）将成为主流，提前建立性能优化框架，可帮助企业在加密算法迭代中占据主动。</p>]]></description></item><item>    <title><![CDATA[20年装备制造业MES实施经验分享 万界]]></title>    <link>https://segmentfault.com/a/1190000047389022</link>    <guid>https://segmentfault.com/a/1190000047389022</guid>    <pubDate>2025-11-11 14:08:40</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>20年装备制造业MES实施经验分享<br/>装备制造企业大多是劳动密集型企业，自动化程度不高，底层生产数据获取不易，而且很多零部件都是外委到其他车间或企业加工，很难控制物料的齐套性，再加上设计、工艺的经常调整和质检后的返工返修，导致生产计划的安排混乱，整个装备制造业的MES系统实施困难较大，因此必须把握重点，有针对性地进行分步实施。</p><p><strong>一、 战略与准备层面：奠定成功基石</strong></p><ol><li>明确目标与业务需求<br/>问题： 为什么上MES？是为了追溯、提质、降本还是增效？目标必须具体、可衡量。避免“为了上系统而上系统”或“别人有，所以我们也要有”的想法。<br/>注意点： 必须与公司战略紧密结合。将宏观目标分解为具体的业务需求，例如：“将产品不良率从3%降低到1.5%”或“将生产数据报表产出时间从4小时缩短到15分钟”。</li><li>获得高层领导的全力支持<br/>问题： MES是“一把手工程”。实施会触及部门壁垒、改变现有工作习惯，没有高层的坚定支持和资源投入，项目极易夭折。<br/>注意点： 高层领导不能只是点头同意，而应作为项目的倡导者，积极参与关键决策，协调资源，扫除障碍。</li><li>制定切实可行的项目规划与预算<br/>问题： 对项目的范围、时间、成本、风险预估不足。<br/>注意点：<br/>分步实施： 采用“整体规划、分步实施”的策略。先聚焦核心痛点（如车间无纸化、数据采集），快速见效，建立信心，再逐步扩展功能。<br/>预留缓冲： 预算和时间计划必须为潜在的变更和意外情况预留缓冲。通常，软硬件成本只占一部分，实施、培训和后期维护成本往往被低估。<br/><img width="723" height="603" referrerpolicy="no-referrer" src="/img/bVdmWFc" alt="" title=""/><br/><strong>二、 流程与人员层面：保障顺畅落地</strong></li><li>业务流程梳理与优化<br/>问题： 直接将落后的、不合理的线下流程照搬到MES中，导致系统效率低下，甚至放大原有问题。<br/>注意点： 实施MES前，必须先梳理、优化甚至重新设计生产相关的业务流程（如工单下达、物料配送、异常处理、质量检验流程）。让系统支持“最佳实践”，而不是固化“现有陋习”。</li><li>变革管理与全员培训<br/>问题： 忽视变革对员工的影响。车间工人、班组长、质检员等是系统的最终用户，如果他们因担心失业、增加工作量或不习惯而抵触，系统将无法使用。<br/>注意点：<br/>早期介入： 在项目早期就让关键用户参与进来，听取他们的意见。<br/>充分沟通： 清晰地传达MES的好处，不仅对公司，也对员工个人（如工作更轻松、责任更清晰）。<br/>分层培训： 对领导、关键用户、最终用户进行不同内容和深度的培训。培训不能是一次性的，而应贯穿项目始终。</li><li>组建强有力的项目团队<br/>问题： 认为实施只是IT部门或供应商的事。业务部门参与度低。<br/>注意点： 项目团队应该包括：<br/>项目经理： 具备强大推动力和跨部门协调能力。<br/>IT人员： 负责技术架构、集成接口。<br/>业务骨干（核心）： 来自生产、质量、物料等部门的专家，他们是业务的代言人，负责确认需求、测试系统。</li></ol><p>三、 技术与管理层面：控制项目风险</p><ol><li>基础数据准备：<br/>问题： MES运行在数据之上。物料编码、BOM（物料清单）、工艺路线等主数据不准确、不完整，系统输出将是“垃圾”。<br/>注意点： 数据准备是耗时最长、最枯燥但至关重要的工作。必须成立专门的数据小组，制定严格的规范，在系统上线前完成数据的清洗、整理和导入。</li><li>系统集成与接口设计<br/>问题： MES不是孤岛，需要与ERP（企业资源计划）、PLM（产品生命周期管理）、自动化设备等系统双向交互。接口设计不当会导致信息孤岛或数据不一致。<br/>注意点： 明确集成边界、数据流向、频率和职责</li><li>供应商与解决方案的选择<br/>问题： 只看价格或品牌，忽视行业匹配度和服务能力。<br/>注意点：<br/>行业经验： 供应商是否有同行业的成功案例？其解决方案是否包含行业最佳实践？<br/>可配置性 vs. 二次开发： 了解系统通过配置能满足多少需求，多少需要二次开发。<br/>服务与支持： 考察供应商的实施团队经验和本地化服务支持能力。</li><li>持续改进与运维体系<br/>问题： 项目上线即宣告结束，缺乏持续的优化和运维。<br/>注意点： MES上线只是开始。必须建立专门的运维团队，负责系统维护、用户支持、权限管理，并基于系统产生的数据不断发现新的优化点，持续改进。</li></ol><p>MES系统的实施需要结合企业自身的实际情况进行精心规划。规划过程中应保持路线清晰、目标明确、政策一致，并遵循由简入繁、由易入难的原则，先进行试点后再逐步扩展。</p>]]></description></item><item>    <title><![CDATA[哪里可以申请一年期免费证书？ 从未表白的]]></title>    <link>https://segmentfault.com/a/1190000047389025</link>    <guid>https://segmentfault.com/a/1190000047389025</guid>    <pubDate>2025-11-11 14:07:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3><strong>什么是SSL证书？它为什么重要？</strong></h3><p>SSL证书是网站的“安全身份证”，它让网站地址从<code>http</code>升级为<code>https</code>，并在浏览器地址栏显示<strong>锁形标志</strong>。它的核心作用有两个：</p><ul><li><strong>数据加密</strong>：在用户浏览器和网站服务器之间建立一个<strong>加密的传输通道</strong>，有效防止敏感信息（如密码、身份证号）在传输过程中被窃取或篡改。</li><li><strong>身份验证</strong>：向用户证明他们访问的是<strong>真实、可信的网站</strong>，而非钓鱼网站，从而建立用户信任。</li></ul><p>对于政务、金融、电商等涉及敏感数据的网站而言，部署SSL证书不仅是提升安全性的举措，也是<strong>满足国家网络安全法规（如《网络安全法》）的合规要求</strong>。</p><h3><a href="https://link.segmentfault.com/?enc=20HS%2FPFSveMg9SEhx9uY%2FA%3D%3D.tBwd6gi7YK4tRgTyFOzI6cSDA1axBIcB9MGDJh6anFtr2hWdmbGmkOojRI5anAEr0b79WK8vSvBhPGRvO6hK8PSk3KQTDFGjXtBw%2BMpqFGE%3D" rel="nofollow" target="_blank">免费SSL证书申请入口</a></h3><p>直接访问JoySSL，注册一个账号记得填写注册码230931获取大额优惠。</p><p><img width="390" height="260" referrerpolicy="no-referrer" src="/img/bVddeYp" alt="" title=""/></p><h3><strong>如何选择SSL证书？</strong></h3><p>SSL证书主要分为以下三类，您可以根据自身需求选择：</p><ul><li><strong>域名型证书 (DV)</strong> ：<strong>只验证域名所有权</strong>，申请快捷，适合个人网站或博客。</li><li><strong>企业型证书 (OV)</strong> ：<strong>需要验证企业的真实身份</strong>（如营业执照），安全性更高，适用于企业和组织官网。</li><li><strong>增强型证书 (EV)</strong> ：<strong>最高级别的验证标准</strong>，会在浏览器地址栏显示绿色企业名称，通常用于银行、大型电商等对公信力要求极高的场景。</li></ul><p>此外，还有<strong>国密SSL证书</strong>，它采用国家密码管理局认可的<strong>SM2国产密码算法</strong>，是政务、金融等关键领域实现技术合规的重要选择。</p><h3><strong>哪里可以申请一年期免费SSL证书？</strong></h3><p>许多云服务商和证书颁发机构（CA）都提供SSL证书服务。如果您在寻找<strong>免费的一年期证书</strong>，<strong>JoySSL</strong>是一个不错的选择，尤其它还为政务机构提供了专属的免费证书计划。</p><h4><strong>JoySSL免费证书特点</strong></h4><ul><li><strong>免费时长</strong>：提供<strong>1年有效期的DV型免费证书</strong>。</li><li><strong>支持国际算法</strong>：免费证书支持国际算法。</li><li><strong>申请简便</strong>：全程在线操作，自动化部署，大大节省了时间和运维成本。</li></ul><h4><strong>申请步骤简介</strong></h4><p>申请JoySSL的免费证书非常简单，通常只需三步：</p><ol><li><strong>访问JoySSL官网</strong>，注册账号，一定要填写注册码230931。</li><li>选择“<strong>政务免费证书</strong>”或相应的免费证书类型，填写您的域名信息并提交审核。</li><li>审核通过后，下载证书文件并部署到您的服务器上。</li></ol><blockquote><strong>提示</strong>：在注册和申请过程中，有时可能需要填写特定的<strong>注册码</strong>（例如 <code>230931</code>）来激活免费申请资格或获取技术支持。</blockquote>]]></description></item><item>    <title><![CDATA[申请SSL证书的详细步骤：JoySSL免]]></title>    <link>https://segmentfault.com/a/1190000047389027</link>    <guid>https://segmentfault.com/a/1190000047389027</guid>    <pubDate>2025-11-11 14:07:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、 申请资格与准备</strong><br/>首先，请确认您的单位属于以下类型：</p><p>政府机关、事业单位、公立学校、教育机构、教育平台</p><p><strong>申请前，请准备好：</strong></p><p>1.您的域名（例如：www.xxx.gov.cn 或 edu.xxx.com）。</p><p>2.单位证明文件（如：事业单位法人证书或统一社会信用代码证书）。</p><p>3.联系人信息（姓名、电话、邮箱）。</p><h4><a href="https://link.segmentfault.com/?enc=oSQQdL0vcj5FPIFMBrUcmg%3D%3D.6pcyXWhKTkwtDBqoMm4I4iEobou2Rybudnd%2BEgxBGQ0bBj%2BHeOu31D9nBQ4ffCia6elXUEeL8BmVuOJRd0TCJg%3D%3D" rel="nofollow" target="_blank">免费SSL证书快速申请入口</a></h4><h4>直接访问JoySSL，注册一个账号记得填写注册码230973获取免费安装服务。</h4><p>二、 四步快速申请（无需生成CSR） JoySSL的流程非常人性化，您只需在网站上填写信息，系统会为您处理所有技术环节。<br/>第一步：前往官网，选择证书 打开JoySSL官方网站。 在首页选择  “免费证书”  或直接找到  “政务/教育版”  入口。 点击  “立即申请” 。</p><p>第二步：填写域名与单位信息 这是核心步骤，您只需要像填写表格一样提供基本信息即可： 域名填写：在输入框中直接填入您需要加密的完整域名。 单位信息填写： 单位名称：务必填写您单位的完整官方名称（必须与证明文件上的名称完全一致）。 部门：可选填写，如“信息中心”。 所在地：填写城市名。 联系人信息：填写您的真实姓名、电话和邮箱（用于接收审核通知和证书）。</p><p>第三步：上传证明，提交审核 根据页面提示，上传您准备好的单位证明材料的清晰照片或扫描件。 确认所有信息无误后，点击提交。 系统会自动为您创建所有必要的技术文件。接下来，您只需等待人工审核（通常需要1-3个工作日）。</p><p>第四步：审核通过，一键获取 审核通过后，您会收到一封包含证书下载链接的通知邮件。 同时，您也可以登录JoySSL的用户管理后台。 在“我的订单”中，您会发现订单状态变为“已签发”。点击下载，即可得到一个包含SSL证书文件（.crt或.pem文件）和私钥文件（.key文件）  的压缩包。 【非常重要】请务必妥善保存下载的私钥文件！  它是您证书的安全核心，丢失后将无法安装。</p><p><strong>三、 在服务器上安装证书 拿到证书文件后，最后一步就是将其部署到您的网站服务器上。</strong> <br/>将下载的压缩包中的证书文件和私钥文件上传到服务器指定目录。 根据您使用的服务器软件（如Nginx, Apache, IIS等），修改配置文件，指向这两个文件的路径。 重启服务器软件，HTTPS加密即刻生效。 最后，打开浏览器访问您的网站，确认地址栏显示安全锁标志，即表示大功告成。</p><p><strong>总结一下，整个申请过程就像“填写一张申请表”：您只需提供域名和单位信息，JoySSL会为您完成所有技术工作，最后您下载并安装文件即可</strong><br/><img width="303" height="228" referrerpolicy="no-referrer" src="/img/bVdmZZt" alt="" title=""/></p>]]></description></item><item>    <title><![CDATA[长销售周期的企业级CRM软件怎么选？ 直]]></title>    <link>https://segmentfault.com/a/1190000047389029</link>    <guid>https://segmentfault.com/a/1190000047389029</guid>    <pubDate>2025-11-11 14:06:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当今竞争激烈的商业环境中，企业客户对销售效率和客户关系管理（CRM）的重视程度不断提升。良好的CRM系统不仅能够提升客户满意度，还能有效提升销售转化率和业务增长。因此，选择一款适合企业客户销售的CRM软件，成为企业数字化转型的重要一步。</p><p>本文将从企业客户的角度出发，综合分析当前市场上适合企业销售的CRM软件，并提供详细的对比分析和选型建议。</p><hr/><h2>一、企业客户CRM软件的选择标准</h2><p>在选择CRM软件时，企业客户需要综合考虑以下因素：</p><ol><li><strong>功能完整性</strong>：是否包含销售、营销、客户服务、数据分析等核心模块。</li><li><strong>用户友好性</strong>：系统界面是否直观，操作是否简单，是否支持多用户协作。</li><li><strong>定制化能力</strong>：是否支持根据企业业务需求进行个性化配置。</li><li><strong>数据安全</strong>：是否具备完善的数据加密、访问控制和备份机制。</li><li><strong>成本效益</strong>：是否提供灵活的定价方案，是否支持多用户、多角色订阅。</li><li><strong>可扩展性</strong>：是否支持未来业务增长，是否支持与其他系统集成。</li><li><strong>客户支持与培训</strong>：是否有完善的售后服务和用户培训资源。</li></ol><hr/><h2>二、适合企业客户销售的CRM软件推荐</h2><p>在众多CRM软件中，<strong>八骏CRM</strong>、<strong>Salesforce</strong>、<strong>Zoho CRM</strong>、<strong>HubSpot</strong>、<strong>Pipedrive</strong>、<strong>Microsoft Dynamics</strong> 和 <strong>Adobe CRM</strong> 等都是市场上的热门选择。</p><h3>1. <strong>八骏CRM</strong>（八骏CRM）</h3><ul><li><p><strong>核心特点</strong>：</p><ul><li><strong>功能全面</strong>：涵盖销售、营销、客户服务、数据分析等模块。</li><li><strong>高度可定制</strong>：支持自定义字段、流程和报表。</li><li><strong>多平台支持</strong>：支持Web、移动端、桌面端多平台使用。</li><li><strong>用户友好</strong>：界面简洁，操作便捷，适合中小型企业使用。</li><li><strong>数据安全</strong>：具备数据加密、权限管理、备份恢复等安全机制。</li><li><strong>成本适中</strong>：提供灵活的订阅模式，适合不同预算的企业。</li></ul></li><li><strong>适用场景</strong>： 适合中小型企业和快速增长的业务，尤其适合希望快速部署并实现高效管理的客户。</li></ul><h3>2. <strong>Salesforce</strong>（Salesforce）</h3><ul><li><p><strong>核心特点</strong>：</p><ul><li><strong>功能强大</strong>：功能全面，涵盖销售、营销、客户服务、数据分析等。</li><li><strong>高度可扩展</strong>：支持企业级功能扩展，适合大型企业。</li><li><strong>集成能力强</strong>：支持与ERP、ERP、ERP、ERP等系统无缝集成。</li><li><strong>用户友好</strong>：拥有强大的用户界面，支持多角色访问和权限管理。</li><li><strong>数据安全</strong>：拥有高度的安全保障，适合需要保障数据隐私的企业。</li></ul></li><li><strong>适用场景</strong>： 适合大型企业，尤其是那些希望实现全面数字化转型、并需要与多个系统集成的企业。</li></ul><h3>3. <strong>Zoho CRM</strong></h3><ul><li><p><strong>核心特点</strong>：</p><ul><li><strong>功能全面</strong>：涵盖销售、营销、客户服务、数据分析等模块。</li><li><strong>易于使用</strong>：界面简洁，操作简单，适合不同层次的用户。</li><li><strong>多平台支持</strong>：支持Web、移动端、桌面端多平台使用。</li><li><strong>灵活定价</strong>：提供多种定价方案，适合不同规模的企业。</li><li><strong>集成能力强</strong>：支持与多种第三方应用集成，包括邮件、日历、文档管理等。</li></ul></li><li><strong>适用场景</strong>： 适合中小型企业，尤其是希望快速部署并实现高效管理的客户。</li></ul><h3>4. <strong>HubSpot</strong></h3><ul><li><p><strong>核心特点</strong>：</p><ul><li><strong>营销驱动</strong>：主打营销自动化，适合从事市场营销的企业。</li><li><strong>用户友好</strong>：界面简洁，操作简单，适合非技术人员使用。</li><li><strong>集成能力强</strong>：支持与营销、邮件、客户关系管理等系统集成。</li><li><strong>数据驱动</strong>：提供强大的数据分析和报告功能。</li></ul></li><li><strong>适用场景</strong>： 适合从事营销驱动型业务的企业，尤其是需要高效营销和客户管理的企业。</li></ul><h3>5. <strong>Pipedrive</strong></h3><ul><li><p><strong>核心特点</strong>：</p><ul><li><strong>销售管理</strong>：专注于销售流程管理，适合销售驱动型企业。</li><li><strong>流程清晰</strong>：流程清晰，易于跟踪销售进展。</li><li><strong>移动端支持</strong>：支持移动端使用，适合经常外出的销售团队。</li><li><strong>集成性强</strong>：支持与多种第三方系统集成，包括邮件、日历、文档管理等。</li></ul></li><li><strong>适用场景</strong>： 适合销售驱动型企业，尤其是需要高效跟踪销售流程的企业。</li></ul><h3>6. <strong>Microsoft Dynamics</strong></h3><ul><li><p><strong>核心特点</strong>：</p><ul><li><strong>企业级功能</strong>：支持企业级功能，适合大型企业。</li><li><strong>集成能力强</strong>：支持与微软生态系统中的多个应用集成。</li><li><strong>用户友好</strong>：界面友好，适合熟悉微软技术的企业。</li><li><strong>数据安全</strong>：具备强大的数据安全机制，适合需要高安全性的企业。</li></ul></li><li><strong>适用场景</strong>： 适合大型企业，尤其是需要与微软其他系统无缝集成的企业。</li></ul><h3>7. <strong>Adobe CRM</strong></h3><ul><li><p><strong>核心特点</strong>：</p><ul><li><strong>集成能力强</strong>：支持与Adobe生态系统中的多个应用集成。</li><li><strong>数据管理</strong>：提供强大的数据管理功能，支持多数据源整合。</li><li><strong>用户友好</strong>：界面简洁，操作简单，适合不同层次的用户。</li></ul></li><li><strong>适用场景</strong>： 适合需要与Adobe生态系统无缝集成的企业，尤其是需要强大数据分析和客户管理的企业。</li></ul><hr/><h2>三、企业客户选型的关键考量因素</h2><p>在选择CRM软件时，企业客户需要综合考虑以下几个关键因素：</p><h3>1. <strong>业务需求与目标</strong></h3><ul><li>企业客户需要根据自身业务目标选择CRM软件，例如是否需要营销自动化、销售流程管理、客户服务等功能。</li><li>如果企业主要关注销售，可以选择Pipedrive或Salesforce；如果关注营销，则可以选择HubSpot或Zoho CRM。</li></ul><h3>2. <strong>预算与成本</strong></h3><ul><li>不同的CRM软件价格差异较大，企业需要根据预算选择合适的产品。</li><li>有些CRM软件提供免费或试用版本，适合测试使用。</li></ul><h3>3. <strong>企业规模与团队规模</strong></h3><ul><li>小型企业可能更倾向于选择功能全面、易于使用、成本适中的CRM软件。</li><li>大型企业则更倾向于选择功能强大、集成能力强、支持多角色访问的CRM软件。</li></ul><h3>4. <strong>技术能力与系统集成</strong></h3><ul><li>企业需要评估自身技术能力，是否能够支持CRM软件的部署和集成。</li><li>一些CRM软件支持与ERP、邮件、文档管理等系统集成，适合需要多系统协同的企业。</li></ul><h3>5. <strong>用户培训与支持</strong></h3><ul><li>企业需要评估CRM软件的培训和支持资源是否充足。</li><li>完善的客户支持和培训资源能够帮助企业快速上手并持续优化使用。</li></ul><hr/><h2>四、根据不同企业情况给出针对性建议</h2><h3>1. <strong>中小型企业</strong></h3><ul><li><strong>推荐CRM</strong>：八骏CRM、Zoho CRM、HubSpot</li><li><strong>理由</strong>：这些CRM软件功能全面、易于使用、成本适中，适合中小型企业快速部署和优化。</li></ul><h3>2. <strong>销售驱动型企业</strong></h3><ul><li><strong>推荐CRM</strong>：Pipedrive、Salesforce</li><li><strong>理由</strong>：Pipedrive专注于销售流程管理，Salesforce功能全面，适合销售驱动型企业。</li></ul><h3>3. <strong>营销驱动型企业</strong></h3><ul><li><strong>推荐CRM</strong>：HubSpot、Zoho CRM</li><li><strong>理由</strong>：HubSpot以营销自动化为核心，Zoho CRM功能全面，适合营销驱动型业务。</li></ul><h3>4. <strong>大型企业</strong></h3><ul><li><strong>推荐CRM</strong>：Salesforce、Microsoft Dynamics、Adobe CRM</li><li><strong>理由</strong>：这些CRM软件功能强大、集成能力强、适合大型企业进行数字化转型。</li></ul><hr/><h2>五、总结</h2><p>在企业客户销售的CRM软件选择中，八骏CRM因其全面的功能、用户友好的界面和良好的数据安全性，成为市场上的优选之一。然而，企业在选择CRM软件时，还需要根据自身业务需求、预算、技术能力和团队规模等多方面因素进行综合考量。</p><p>无论企业是中小型企业还是大型企业，选择一款适合自己的CRM软件，都是企业数字化转型的重要一步。通过合理选型，企业能够提升销售效率、优化客户关系管理，并最终实现业务增长。</p><hr/><h2>六、附录：CRM软件对比表格</h2><table><thead><tr><th>软件名称</th><th>核心特点</th><th>适用企业规模</th><th>价格范围</th><th>系统兼容性</th><th>客户支持</th></tr></thead><tbody><tr><td>八骏CRM</td><td>功能全面、高度可定制、多平台支持</td><td>中大型企业</td><td>2万起 买断私有化</td><td>支持</td><td>完善</td></tr><tr><td>Salesforce</td><td>功能强大、集成能力高、企业级支持</td><td>大型企业</td><td>￥5000-20000/月</td><td>支持</td><td>优质</td></tr><tr><td>Zoho CRM</td><td>易于使用、功能全面、灵活定价</td><td>中小型企业</td><td>￥500-2000/月</td><td>支持</td><td>优质</td></tr><tr><td>HubSpot</td><td>营销驱动、用户友好、数据分析强</td><td>中小企业</td><td>￥500-1500/月</td><td>支持</td><td>优质</td></tr></tbody></table>]]></description></item><item>    <title><![CDATA[双算法 SSL 证书技术白皮书：SM2+]]></title>    <link>https://segmentfault.com/a/1190000047389044</link>    <guid>https://segmentfault.com/a/1190000047389044</guid>    <pubDate>2025-11-11 14:05:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>双算法 SSL 证书技术白皮书：SM2+RSA/ECC 混合加密机制深度解析</h2><h3>前言：为何需要双算法 SSL 证书？</h3><p>在全球加密体系多元化与合规要求差异化的背景下，单一算法 SSL 证书逐渐难以满足复杂场景需求：国内政务、金融等领域需遵循《商用密码应用安全性评估》要求采用 SM2 等国密算法，而国际业务又依赖 RSA/ECC 实现浏览器与服务器的互信。双算法 SSL 证书通过在同一证书中集成 SM2 与 RSA/ECC 双重加密体系，构建了 “国密合规与国际兼容” 的桥梁，其技术核心在于解决<strong>算法协同、协议适配、安全兼容</strong>三大难题。</p><p><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdiPtP" alt="" title=""/></p><p><a href="https://link.segmentfault.com/?enc=av%2Fb52bIQwPF7m8r52gEDA%3D%3D.oE9WMD5ds5xOWOcalMv99h3fGYl%2Fe2hf0eXMbz2U0Igcx256az7Fece2slASDkCKF14v0icv7Ub4wbAXkuH%2F5YekKhFsA5MxChutKY0byAw%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/dual_algorithm.html...</a></p><p>注册码230959</p><h3>一、技术背景：加密算法的 “二元分化” 与融合需求</h3><h4>1.1 国际主流算法：RSA/ECC 的现状与局限</h4><ul><li><strong>RSA</strong>：基于大数分解难题，因部署历史悠久（支持几乎所有客户端），仍是全球使用最广泛的算法，但 2048 位密钥面临量子计算潜在威胁，4096 位则存在性能瓶颈。</li><li><strong>ECC</strong>：基于椭圆曲线离散对数问题，相同安全强度下密钥长度仅为 RSA 的 1/6（256 位 ECC≈2048 位 RSA），性能优势显著，已成为 TLS 1.3 推荐算法，但在部分国产化场景中因非国密算法被限制使用。</li></ul><h4>1.2 国密算法 SM2 的合规性与特殊性</h4><p>SM2 是我国自主设计的椭圆曲线公钥算法（GB/T 32918-2016），具备三大特性：</p><ul><li><strong>合规性</strong>：满足《网络安全等级保护基本要求》中 “三级及以上系统应采用国密算法” 的强制要求；</li><li><strong>安全性</strong>：采用 256 位椭圆曲线参数（GF (p) 域），抗量子攻击能力优于传统 RSA/ECC；</li><li><strong>生态依赖性</strong>：需依赖国密浏览器（如密信、红莲花）、国密加密库（GMSSL）等专用生态组件，与国际主流软件栈存在兼容性隔阂。</li></ul><h4>1.3 双算法融合的必然性</h4><p>单一算法面临 “合规与兼容不可兼得” 的困境：纯 SM2 证书在国际浏览器中会因算法不识别导致信任错误，纯 RSA/ECC 证书则无法通过国内密评。双算法证书通过 <strong>“一证双钥、动态协商”</strong> 机制，实现 “国内场景用 SM2、国际场景用 RSA/ECC” 的自适应切换。</p><h3>二、核心技术架构：SM2+RSA/ECC 混合加密的实现机制</h3><h4>2.1 双算法证书的结构设计</h4><p>双算法 SSL 证书在 X.509 标准基础上扩展了<strong>多公钥信息域</strong>，核心结构包含：</p><ul><li><strong>主体公钥信息（SubjectPublicKeyInfo）</strong> ：主字段保留 SM2 公钥（满足国密合规），通过扩展字段（如<code>X509v3 Subject Alternative Public Key</code>）嵌入 RSA/ECC 公钥；</li><li><strong>双签名链</strong>：证书同时包含 SM2 签名（由国密 CA 签发）和 RSA/ECC 签名（由国际信任 CA 交叉签发），确保双算法链均被信任；</li><li><strong>算法标识扩展</strong>：在<code>X509v3 Extended Key Usage</code>中添加 SM2 专用 OID（如 1.2.156.10197.1.301），明确标识算法支持能力。</li></ul><p><em>表：双算法证书与单算法证书结构对比</em></p><table><thead><tr><th>字段</th><th>单算法证书（SM2）</th><th>单算法证书（RSA）</th><th>双算法证书（SM2+RSA）</th></tr></thead><tbody><tr><td>主体公钥</td><td>SM2 公钥</td><td>RSA 公钥</td><td>主字段 SM2 公钥 + 扩展字段 RSA 公钥</td></tr><tr><td>签名算法</td><td>SM3withSM2</td><td>SHA256withRSA</td><td>双签名（SM3withSM2 + SHA256withRSA）</td></tr><tr><td>信任链依赖</td><td>国密根 CA</td><td>国际根 CA（如 DigiCert）</td><td>国密根 CA + 国际根 CA 交叉认证</td></tr><tr><td>证书体积</td><td>~2.8KB</td><td>~1.8KB（2048 位）</td><td>~4.2KB（含双公钥 + 双签名）</td></tr></tbody></table><h4>2.2 混合加密的 TLS 握手流程</h4><p>双算法证书在 TLS 握手阶段通过 <strong>“算法协商 - 动态选择”</strong> 机制实现平滑切换，以 TLS 1.2 为例（兼容 TLS 1.3）：</p><ol><li><strong>客户端问候（ClientHello）</strong> ：客户端发送支持的加密套件列表（如 SM2_WITH_SMS4_GCM、ECDHE_RSA_WITH_AES_256_GCM）；</li><li><p><strong>服务器算法决策</strong>：服务器根据客户端能力与预设策略（如 IP 地理信息、User-Agent）选择算法：</p><ul><li>国内客户端（如携带国密浏览器标识）：优先选择 SM2 套件，使用 SM2 公钥完成密钥交换；</li><li>国际客户端（如 Chrome、Firefox）：选择 RSA/ECC 套件，调用扩展字段中的 RSA/ECC 公钥；</li></ul></li><li><strong>证书与密钥交换</strong>：服务器发送双算法证书，客户端根据协商的算法提取对应公钥，完成 Pre-Master Secret 加密传输；</li><li><strong>会话密钥生成</strong>：双方基于协商算法（SM2 或 RSA/ECC）生成会话密钥，后续数据传输使用对称加密（SM4 或 AES）。</li></ol><p><em>图：双算法 TLS 握手流程示意图（简化版）</em></p><p>plaintext</p><pre><code>客户端                          服务器
  |                              |
  |---- ClientHello（支持SM2/RSA）--&gt;|
  |                              |
  |&lt;-- 选择算法（如SM2）+ 双证书 ----|
  |                              |
  |---- 用SM2公钥加密Pre-Master --&gt;|
  |                              |
  |&lt;-- 会话密钥确认 + 加密数据 ----|
  |                              |</code></pre><h4>2.3 密钥协商的协同机制</h4><p>双算法证书需解决 “同一会话中两种算法如何协同” 的核心问题，关键技术包括：</p><ul><li><strong>密钥材料隔离</strong>：SM2 与 RSA/ECC 的私钥分别存储于硬件安全模块（HSM）的独立分区，避免算法间密钥泄露风险；</li><li><p><strong>协商优先级动态调整</strong>：通过服务器配置（如 Nginx 的<code>ssl_ciphers</code>排序）实现场景化策略，例如：</p><p>nginx</p><pre><code># 政务系统：SM2优先，RSA兼容
ssl_ciphers "SM2-WITH-SMS4-GCM:SMS4-GCM:ECDHE-RSA-WITH-AES-256-GCM";
# 跨境系统：ECC优先，SM2备用
ssl_ciphers "EECDH+AESGCM:SM2-WITH-SMS4-GCM:EDH+AESGCM";</code></pre></li><li><strong>降级兼容处理</strong>：当客户端不支持任一算法时，返回 “握手失败” 并记录日志，避免降级至不安全套件（如 RC4、MD5）。</li></ul><h3>三、安全性分析：双算法机制的防御能力与潜在风险</h3><h4>3.1 算法协同的安全增益</h4><ul><li><strong>抗量子计算增强</strong>：SM2 的椭圆曲线参数设计考虑了量子攻击抗性，与 RSA（易受 Shor 算法攻击）形成互补，提升长期安全性；</li><li><strong>攻击面分散</strong>：单一算法漏洞（如 RSA 的 ROCA 漏洞）不会导致整体加密体系失效，双算法形成 “冗余防御”；</li><li><strong>合规性叠加</strong>：同时满足国密 “加密算法自主可控” 与 PCI DSS“使用强加密（如 ECC）” 的双重要求。</li></ul><h4>3.2 潜在风险与 mitigation 策略</h4><table><thead><tr><th>风险点</th><th>技术成因</th><th>防御措施</th></tr></thead><tbody><tr><td>证书体积膨胀导致传输风险</td><td>双公钥 + 双签名使证书体积增加 60%+</td><td>启用证书压缩（如 TLS 1.3 的证书压缩扩展）、CDN 边缘缓存</td></tr><tr><td>算法协商漏洞</td><td>协商逻辑缺陷可能导致算法降级（如强制使用 RSA）</td><td>部署算法协商审计工具（如 OpenSSL 的<code>SSL_CTX_set_cipher_list</code>校验）</td></tr><tr><td>私钥管理复杂度提升</td><td>双私钥需独立生命周期管理</td><td>采用 HSM 集中管理，配置双钥自动轮换（周期≤90 天）</td></tr><tr><td>客户端兼容性冲突</td><td>老旧客户端可能无法解析扩展公钥字段</td><td>部署客户端指纹库，对不兼容设备返回单算法证书备用</td></tr></tbody></table><h3>四、部署实践：从技术选型到运维保障</h3><h4>4.1 服务器环境适配</h4><p>双算法证书部署需解决服务器软件栈的国密支持问题：</p><ul><li><strong>Web 服务器</strong>：Nginx 需编译 GMSSL 模块（而非默认 OpenSSL），Apache 需加载<code>mod_ssl_gm</code>插件；</li><li><strong>容器化部署</strong>：在 Kubernetes 中通过<code>initContainer</code>预装 GMSSL 依赖，使用 Secret 管理双算法证书；</li><li><strong>云服务集成</strong>：阿里云、华为云等提供双算法证书托管服务，支持自动部署至 SLB、WAF 等组件。</li></ul><p><em>示例：Nginx 双算法证书配置（GMSSL 编译版）</em></p><p>nginx</p><pre><code>server {
    listen 443 ssl;
    server_name example.gov.cn;

    # 双算法证书（含SM2主公钥+RSA扩展公钥）
    ssl_certificate /etc/nginx/certs/sm2_rsa_chain.pem;
    ssl_certificate_key /etc/nginx/certs/sm2_private.key;  # SM2私钥
    ssl_rsa_certificate_key /etc/nginx/certs/rsa_private.key;  # RSA私钥（扩展配置）

    # 算法套件优先级
    ssl_ciphers "SM2-WITH-SMS4-GCM:ECDHE-RSA-WITH-AES-256-GCM";
    ssl_protocols TLSv1.2 TLSv1.3;

    # 会话复用优化
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;
}</code></pre><h4>4.2 客户端兼容性适配</h4><p>针对不同客户端环境的适配策略：</p><ul><li><strong>国内场景</strong>：通过 User-Agent 检测国密浏览器（如 “MiTrustBrowser”），优先启用 SM2；</li><li><strong>国际场景</strong>：对 Chrome、Safari 等浏览器自动切换至 ECC，避免 SM2 不识别导致的 “证书无效” 错误；</li><li><strong>移动客户端</strong>：在 iOS/Android App 中集成 GMSSL SDK，实现 App 内 SM2 算法支持，同时保留系统默认的 RSA/ECC 能力。</li></ul><h4>4.3 运维监控体系</h4><ul><li><strong>算法协商监控</strong>：通过 Prometheus 采集<code>ssl_cipher</code>指标，分析 SM2/RSA/ECC 的使用占比，优化协商策略；</li><li><strong>安全审计</strong>：定期使用国密合规检测工具（如 GMSSL 的<code>gmssl verify</code>）验证双算法证书链完整性；</li><li><strong>性能基线</strong>：建立双算法场景下的性能基准（如握手耗时 &lt;50ms，CPS&gt;2000），通过 Grafana 实时告警异常波动。</li></ul><h3>五、合规性与生态支持</h3><h4>5.1 国内合规要求</h4><ul><li><strong>等保 2.0</strong>：三级及以上信息系统需使用 SM2 等国密算法，双算法证书的 SM2 部分需通过国密局认证；</li><li><strong>密评</strong>：商用密码应用需满足《GM/T 0054-2018》要求，双算法证书需提供国密 CA 的签发证明；</li><li><strong>行业规范</strong>：金融领域需符合《JR/T 0158-2018》，要求核心交易链路支持 SM2 加密。</li></ul><h4>5.2 国际信任体系兼容</h4><ul><li><strong>CA/Browser 论坛</strong>：双算法证书的 RSA/ECC 部分需符合 Baseline Requirements，确保被 Chrome、Firefox 等国际浏览器信任；</li><li><strong>交叉认证</strong>：国密 CA 与国际根 CA（如 IdenTrust）需完成交叉认证，实现双算法链的双向信任；</li><li><strong>标准适配</strong>：支持 TLS 1.3 的<code>supported_groups</code>扩展，确保 ECC 曲线（如 secp256r1）与 SM2 曲线的协同协商。</li></ul><h4>5.3 生态成熟度现状</h4><ul><li><strong>CA 机构</strong>：国内厂商（沃通、CFCA）已推出双算法证书，国际厂商（DigiCert）通过与国密 CA 合作提供混合产品；</li><li><strong>加密库</strong>：GMSSL 3.0 + 支持双算法共存，OpenSSL 3.0 通过<code>provider</code>机制可集成 SM2 插件；</li><li><strong>终端支持</strong>：Windows 11、macOS 13 + 已原生支持 SM2 验证，国内浏览器覆盖率超 90%。</li></ul><h3>六、未来展望：从双算法到多算法的演进</h3><p>随着量子计算技术的发展，单一算法体系的风险将进一步凸显，双算法证书将向 <strong>“国密算法 + 国际算法 + 后量子算法”</strong> 的多算法体系演进：</p><ul><li><strong>短期（1-3 年）</strong> ：优化 SM2 与 ECC 的协同性能，推动国际浏览器原生支持 SM2；</li><li><strong>中期（3-5 年）</strong> ：融入后量子密码算法（如 CRYSTALS-Kyber），构建 “抗量子 + 传统” 双轨加密；</li><li><strong>长期</strong>：形成自适应算法调度机制，根据威胁情报动态选择最优加密策略。</li></ul><p>SM2+RSA/ECC 双算法 SSL 证书不仅是解决 “合规与兼容” 矛盾的技术方案，更是加密体系从 “单一依赖” 向 “多元协同” 演进的重要里程碑。其核心价值在于通过混合加密机制，在保障国家安全合规的同时，实现全球网络的互信互联。企业在部署过程中，需结合自身场景需求，平衡性能、安全与合规，构建弹性加密架构，为未来算法迭代预留扩展空间。</p>]]></description></item><item>    <title><![CDATA[milvus 的 attu 登录遇到 N]]></title>    <link>https://segmentfault.com/a/1190000047389047</link>    <guid>https://segmentfault.com/a/1190000047389047</guid>    <pubDate>2025-11-11 14:04:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="436" referrerpolicy="no-referrer" src="/img/bVdm0dp" alt="图片.png" title="图片.png"/></p><p>我的 docker-compose.yaml 如下：</p><pre><code class="yaml">version: "3.5"

services:
  etcd:
    container_name: milvus-etcd
    image: quay.io/coreos/etcd:v3.5.18
    restart: always
    environment:
      - ETCD_AUTO_COMPACTION_MODE=revision
      - ETCD_AUTO_COMPACTION_RETENTION=1000
      - ETCD_QUOTA_BACKEND_BYTES=4294967296
      - ETCD_SNAPSHOT_COUNT=50000
    volumes:
      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/etcd:/etcd
    command: etcd -advertise-client-urls=http://etcd:2379 -listen-client-urls http://0.0.0.0:2379 --data-dir /etcd
    healthcheck:
      test: ["CMD", "etcdctl", "endpoint", "health"]
      interval: 30s
      timeout: 20s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-file: "1"
        max-size: "50m"

  minio:
    container_name: milvus-minio
    image: minio/minio:RELEASE.2024-05-28T17-19-04Z
    restart: always
    environment:
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: minioadmin
    volumes:
      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/minio:/minio_data
    command: minio server /minio_data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-file: "1"
        max-size: "50m"

  standalone:
    container_name: milvus-standalone
    image: milvusdb/milvus:v2.6.5
    command: ["milvus", "run", "standalone"]
    restart: always
    security_opt:
      - seccomp:unconfined
    environment:
      ETCD_ENDPOINTS: etcd:2379
      MINIO_ADDRESS: minio:9000
    volumes:
      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/milvus:/var/lib/milvus
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9091/healthz"]
      interval: 30s
      start_period: 90s
      timeout: 20s
      retries: 3
    ports:
      - "19530:19530"
      - "9091:9091"
    depends_on:
      - "etcd"
      - "minio"
    logging:
      driver: "json-file"
      options:
        max-file: "1"
        max-size: "50m"

  zilliz_attu:
    container_name: zilliz_attu
    image: zilliz/attu:v2.6.1
    restart: always
    environment:
      # HOST_URL: http://0.0.0.0:8000
      MILVUS_URL: standalone:19530
    ports:
      - "8000:3000"

networks:
  default:
    name: milvus
</code></pre><p>解决方式就是注释掉 HOST_URL 环境变量就行了</p>]]></description></item><item>    <title><![CDATA[豌豆住宅IP——高稳定、可控来源、城市级]]></title>    <link>https://segmentfault.com/a/1190000047389056</link>    <guid>https://segmentfault.com/a/1190000047389056</guid>    <pubDate>2025-11-11 14:04:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在很多需要长期会话、来源可控、城市级定位的业务中（如电商监测、广告验证、本地化测试等），住宅IP的稳定性与地域精度往往比数量更重要。<br/>下面总结一些企业在选型与使用静态住宅IP时的关键考量指标和经验。</p><p>🧩 一、核心指标</p><p>成功率（Success Rate）<br/>稳定的网络请求成功率应在 99% 以上，可支持自动重试与失败率告警。</p><p>延迟（P95 Latency）<br/>95分位延迟能真实反映整体响应性能，建议选择支持实时监控与可观测体系的服务。</p><p>地域一致性（Geo Accuracy）<br/>优质节点应支持城市级定位，并具备漂移检测与自动纠偏机制。</p><p>会话稳定性<br/>对长连接、登录态保持等任务尤为关键，可通过连接池与粘性路由机制实现。</p><p>⚙️ 二、架构与管理实践</p><p>端点分组：按业务线、城市或测试环境划分独立端点池，避免干扰。</p><p>生命周期管理：端点创建 → 监控 → 轮换 → 回收，形成闭环，避免资源浪费。</p><p>容错与回退：短超时 + 重试策略 + 同城优先回退，可显著提升稳定性。</p><p>可观测性体系：埋点监控 P95/P99 延迟、端点可用率、会话中断率，并设定自动告警。</p><p>⚖️ 三、静态 vs 动态选型思路<br/>场景    推荐类型    说明<br/>持续任务、验证类业务    静态住宅IP    稳定、可复用、来源可控<br/>批量采集、短期任务    动态住宅IP    轮换频繁、弹性好</p><p>合理的组合策略是：</p><p>按任务时长、地域精度与成本结构灵活搭配。</p><p>💡 四、成本与效率优化建议</p><p>通过减少失败率与重试次数，优化单位任务成本</p><p>自动回收闲置端点，避免长期占用浪费</p><p>监控账期报表，实现用量与成本透明化</p><p>🧭 五、总结</p><p>静态住宅IP更适合需要稳定运营、精确地域定位、可复用会话的专业团队。<br/>核心不是“IP数量”，而是连接质量、地域一致性与可观测能力。<br/>选择时应综合考虑成功率、延迟、地域一致性、成本效益与SLA保障。</p>]]></description></item><item>    <title><![CDATA[2025年十大企业级CRM软件大盘点：功]]></title>    <link>https://segmentfault.com/a/1190000047389060</link>    <guid>https://segmentfault.com/a/1190000047389060</guid>    <pubDate>2025-11-11 14:03:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当今竞争激烈的商业环境中，企业需要高效管理客户关系，以提升销售转化率和客户满意度。销售周期长的企业通常面临客户跟进困难、信息分散、沟通效率低等挑战。因此，选择一款<strong>适合长销售周期的CRM软件</strong>成为企业数字化转型的重要一步。</p><p>本文将为您推荐<strong>2025年十大企业级CRM软件</strong>，并从<strong>核心功能、行业适用性、数据安全性、可扩展性、用户友好性</strong>等方面进行深度分析，帮助您根据企业实际情况做出最佳选择。</p><hr/><h2>📋 一、软件对比表格：2025年企业级CRM软件推荐</h2><table><thead><tr><th>排名</th><th>软件名称</th><th>核心功能</th><th>行业适用性</th><th>数据安全</th><th>可扩展性</th><th>用户友好性</th><th>价格（年费）</th></tr></thead><tbody><tr><td>1</td><td><strong>八骏CRM</strong></td><td>客户管理、营销自动化、数据分析、销售流程管理</td><td>制造业、高科技、医疗等</td><td>高</td><td>高</td><td>高</td><td>1.98万起 买断私有化</td></tr><tr><td>2</td><td><strong>Salesforce</strong></td><td>客户关系管理、客户旅程管理、智能营销、数据分析</td><td>金融、制造、零售</td><td>高</td><td>高</td><td>高</td><td>￥10,000/月</td></tr><tr><td>3</td><td><strong>HubSpot</strong></td><td>客户管理、营销自动化、客户旅程管理、数据分析</td><td>电商、教育、技术服务</td><td>高</td><td>中</td><td>高</td><td>￥1999/月</td></tr><tr><td>4</td><td><strong>Zoho CRM</strong></td><td>客户管理、销售自动化、营销自动化、数据分析</td><td>多行业</td><td>高</td><td>高</td><td>高</td><td>￥1299/月</td></tr><tr><td>5</td><td><strong>Pipedrive</strong></td><td>客户管理、销售自动化、客户旅程管理、数据分析</td><td>多行业</td><td>高</td><td>高</td><td>高</td><td>￥1599/月</td></tr><tr><td>6</td><td><strong>Microsoft Dynamics 365</strong></td><td>客户关系管理、销售流程管理、数据分析、集成能力</td><td>多行业</td><td>高</td><td>高</td><td>中</td><td>￥1999/月</td></tr><tr><td>7</td><td><strong>Salesforce Einstein</strong></td><td>智能分析、预测性销售、客户互动、数据驱动决策</td><td>多行业</td><td>高</td><td>高</td><td>高</td><td>￥10,000/月</td></tr><tr><td>8</td><td><strong>Influence CRM</strong></td><td>客户管理、销售自动化、客户旅程管理、数据分析</td><td>多行业</td><td>高</td><td>高</td><td>高</td><td>￥1999/月</td></tr><tr><td>9</td><td><strong>Freshsales</strong></td><td>客户管理、销售自动化、客户旅程管理、数据分析</td><td>多行业</td><td>高</td><td>高</td><td>高</td><td>￥1599/月</td></tr><tr><td>10</td><td><strong>Glide CRM</strong></td><td>客户管理、销售流程管理、客户旅程管理、数据分析</td><td>零售、物流、教育</td><td>高</td><td>高</td><td>高</td><td>￥1699/月</td></tr></tbody></table><hr/><h2>🧠 二、适合长销售周期的CRM软件核心特点分析</h2><h3>1. <strong>客户管理功能强大</strong></h3><p>长销售周期的客户通常需要<strong>多维度客户画像</strong>、<strong>历史记录追踪</strong>和<strong>客户生命周期管理</strong>。好的CRM软件应具备<strong>客户信息集成</strong>、<strong>客户互动记录记录</strong>、<strong>客户活动历史跟踪</strong>等功能，帮助企业全面掌握客户状态，提升客户满意度和转化率。</p><h3>2. <strong>营销自动化能力突出</strong></h3><p>销售周期长的客户往往需要<strong>精准营销</strong>和<strong>个性化触达</strong>。先进的CRM软件应支持<strong>营销自动化</strong>，包括邮件营销、内容推送、客户分群、行为分析等，帮助企业实现<strong>低成本、高效率的客户转化</strong>。</p><h3>3. <strong>数据分析与洞察</strong></h3><p>长销售周期的客户需要<strong>数据驱动的决策</strong>。优秀的CRM软件应提供<strong>销售数据分析、客户行为分析、预测分析</strong>等功能，帮助企业制定更精准的销售策略和营销方案。</p><h3>4. <strong>销售流程管理与优化</strong></h3><p>销售周期长的客户需要<strong>流程管理</strong>和<strong>优化</strong>。好的CRM软件应具备<strong>销售流程自动化</strong>、<strong>销售任务分配</strong>、<strong>销售进度跟踪</strong>、<strong>销售漏斗管理</strong>等功能，帮助企业提升销售效率。</p><h3>5. <strong>移动端支持与用户体验</strong></h3><p>客户和销售团队通常分散在不同地点，<strong>移动端支持</strong>是CRM软件的重要考量。优秀的CRM软件应具备<strong>跨平台应用</strong>、<strong>移动端访问</strong>、<strong>实时数据同步</strong>等功能，确保销售团队随时掌握客户动态。</p><hr/><h2>📌 三、选型关键考量因素</h2><p>在选择适合长销售周期的CRM软件时，企业需要综合考虑以下几个关键因素：</p><h3>1. <strong>企业规模与需求</strong></h3><ul><li>小型企业：需要<strong>轻量级、易用、功能全面</strong>的CRM软件。</li><li>中型企业：需要<strong>功能强大、可扩展性强</strong>的CRM软件。</li><li>大型企业：需要<strong>高度可定制、集成能力强</strong>的CRM软件。</li></ul><h3>2. <strong>行业特性</strong></h3><ul><li>教育、金融、医疗等行业的需求与零售、电商、制造等不同。</li><li>需要更<strong>合规性强、数据安全强</strong>的CRM软件。</li></ul><h3>3. <strong>预算与成本</strong></h3><ul><li>企业需根据预算选择合适的CRM软件，包括<strong>基础功能、高级功能、定制开发</strong>等。</li></ul><h3>4. <strong>数据安全与隐私保护</strong></h3><ul><li>长销售周期的客户数据敏感，企业需选择<strong>数据加密、访问权限控制、审计日志</strong>等功能的CRM软件。</li></ul><h3>5. <strong>可扩展性与未来成长性</strong></h3><ul><li>选择能够<strong>适配未来业务扩展</strong>的CRM软件，避免因功能不足影响业务发展。</li></ul><h3>6. <strong>用户体验与培训成本</strong></h3><ul><li>CRM软件的<strong>易用性</strong>和<strong>培训成本</strong>也是重要考量因素，尤其是对于销售团队而言。</li></ul><hr/><h2>🧩 四、根据不同企业情况给出针对性建议</h2><h3>1. <strong>国内企业推荐：八骏CRM</strong></h3><ul><li><strong>适用场景</strong>：适合销售周期长，需要跨部门协作的销售团队，注重<strong>数据安全</strong> <strong>灵活可扩展</strong>和<strong>高度集成</strong>。</li><li><p><strong>优势</strong>：</p><ul><li>功能全面，适合多种销售流程。</li><li>可定制性强，支持多行业应用。</li><li>价格亲民，适合预算有限的企业。</li></ul></li><li><strong>适用行业</strong>：医疗器械、工业品制造、高科技等。</li></ul><h3>2. <strong>中型企业推荐：Zoho CRM</strong></h3><ul><li><strong>适用场景</strong>：中型企业需要<strong>灵活、可扩展</strong>的CRM软件。</li><li><p><strong>优势</strong>：</p><ul><li>高可扩展性，支持多行业应用。</li><li>基础功能齐全，支持营销自动化和数据分析。</li><li>用户友好，支持多平台使用。</li></ul></li><li><strong>适用行业</strong>：电商、制造、服务等。</li></ul><h3>3. <strong>大型企业推荐：Salesforce</strong></h3><ul><li><strong>适用场景</strong>：大型企业需要<strong>高度集成、数据驱动、智能分析</strong>的CRM软件。</li><li><p><strong>优势</strong>：</p><ul><li>高度可定制，支持企业级应用。</li><li>集成能力强，支持与其他系统（如ERP、ERP、SaaS平台）无缝对接。</li><li>智能分析工具（如Salesforce Einstein）提升决策效率。</li></ul></li><li><strong>适用行业</strong>：金融、制造、零售等。</li></ul><h3>4. <strong>注重移动端支持的推荐：Glide CRM</strong></h3><ul><li><strong>适用场景</strong>：需要<strong>高度移动端支持</strong>的销售团队，适合远程办公或多地点团队。</li><li><p><strong>优势</strong>：</p><ul><li>全面支持移动端访问，实时更新客户信息。</li><li>提供多平台应用，支持iOS、Android、Web。</li><li>简洁直观的界面，提升用户体验。</li></ul></li><li><strong>适用行业</strong>：零售、物流、教育等。</li></ul><hr/><h2>📝 五、结语</h2><p>在2025年，随着企业数字化转型的加速，CRM软件已成为企业提升客户管理效率、优化销售流程、增强客户关系的核心工具。选择适合长销售周期的CRM软件，不仅能够提升企业运营效率，还能为企业的长期发展提供强有力的支持。</p><p>对于企业而言，<strong>适合长销售周期的CRM软件</strong>的选择，需要结合企业规模、行业特点、预算和未来需求综合考虑。本文推荐的10款CRM软件，从功能全面性、数据安全、用户体验、可扩展性等方面，为企业提供了多维度的选型参考。</p><p>最终，企业应根据自身实际情况，选择<strong>功能匹配、成本合理、易于使用</strong>的CRM软件，以实现客户关系管理的优化与销售效率的提升。</p>]]></description></item><item>    <title><![CDATA[小程序为什么需要SSL证书？应该如何选择]]></title>    <link>https://segmentfault.com/a/1190000047389092</link>    <guid>https://segmentfault.com/a/1190000047389092</guid>    <pubDate>2025-11-11 14:02:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="313" referrerpolicy="no-referrer" src="/img/bVdm0et" alt="" title=""/><br/>截止到2025年，微信用户人数超12亿，如此庞大的用户群体可为企业带来了巨大的商机和利益，由此，众多企业纷纷开发制作基于其生态的微信小程序。但是值得注意的是，小程序必须使用HTTPS发起网络请求，也就是说必须部署SSL证书。那么小程序为什么需要SSL证书？我们应该如何为小程序选择合适的SSL证书呢？</p><h3>小程序为什么需要SSL证书？</h3><h4>1、官方规定要求</h4><p>微信官方小程序开发平台要求：小程序所有网络请求都要求使用HTTPS。小程序请求时系统会对服务器域名使用的HTTPS进行校验，如果校验失败，则请求不能成功发起，这就意味着小程序必须部署安装SSL证书。  </p><p><img width="723" height="242" referrerpolicy="no-referrer" src="/img/bVdm0eu" alt="" title="" loading="lazy"/></p><h4>2、加密隐私信息</h4><p>在小程序中，用户的登录账号、支付密码、个人身份信息等隐私信息需要通过网络传输给后台服务器进行处理，小程序使用SSL证书进行HTTPS加密传输后，可有效防止信息被窃取或篡改，确保用户隐私安全。  </p><p><img width="723" height="343" referrerpolicy="no-referrer" src="/img/bVdm0ev" alt="" title="" loading="lazy"/></p><p><strong>如何为小程序选择合适的SSL证书？</strong>  <br/>在为小程序选择合适的SSL证书之前，先来看看小程序官方对SSL证书的要求：</p><p>· SSL证书必须有效  <br/>· SSL证书必须被系统信任，即根证书已被系统内置  <br/>· 部署 SSL 证书的网站域名必须与证书颁发的域名一致  <br/>· SSL证书必须在有效期内  <br/>· SSL证书的信任链必需完整（需要服务器配置）  <br/>· 不支持自签名SSL证书  <br/>· TLS 必须支持 1.2 及以上版本</p><p><strong>基于小程序官方对SSL证书的要求，我们就可以根据需求选择证书了。</strong></p><h4>1、品牌选择(<a href="https://link.segmentfault.com/?enc=TU7I8IogNOyYnR3MR5PA5g%3D%3D.G9GemYNYIfoTjSj%2BxDJaUtzGfVsNWEHrWQTNtxDF%2B0RcHN8W3smsLxTQLZfOfb0eC%2FzqYNU%2FRbiNal6QU6u27OanJuMlPJMef%2BDbkjpezCU%3D" rel="nofollow" target="_blank">申请入口</a>)</h4><h6>官方要求SSL证书必须被系统信任，即根证书已被系统内置，那么市面上满足此要求的SSL证书品牌有JoySSL，不同的SSL证书在价格、信誉和可信度上会有所不同，我们可以根据自己的需求和预算进行选择。</h6><h4>2、类型选择</h4><p>SSL证书按照验证方式的不同，可以分为DV SSL证书（域名验证型）、OV SSL证书（组织验证型）或EV SSL证书（增强验证型），他们的安全级别由低到高，其中：</p><p>· DV SSL证书适用于一般的小程序，比如个人开发的展示类小程序；  <br/>· OV SSL证书适用于商务类小程序，比如企业或个人开发的满足业务需求的小程序；  <br/>· EV SSL证书适用于电商、金融机构等有严格安全需求的小程序，比如大型交易类小程序。</p>]]></description></item><item>    <title><![CDATA[数据分析师的基本功总结 灰常酷的领带 ]]></title>    <link>https://segmentfault.com/a/1190000047389102</link>    <guid>https://segmentfault.com/a/1190000047389102</guid>    <pubDate>2025-11-11 14:01:58</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>你是否对数据分析这个行业充满好奇，但又不知从何下手？</p><p>别担心，这篇文章将用最通俗易懂的语言，系统地介绍数据分析师需要具备哪些“基本功”，</p><p>并且结合实际生活中的例子和Python代码，为你铺平通往数据分析世界的大门。</p><h2>1. 数据分析的“套路”：核心步骤全解析</h2><p>数据分析就像是侦探破案，需要遵循一套严谨的流程，才能从纷繁复杂的数据中找到线索，最终得出结论。</p><p>这个过程，我们可以总结为以下六个核心步骤：</p><p>1.1. 明确目标：我们到底想知道什么？<br/>这是所有数据分析工作的起点，也是最重要的一步。如果目标不明确，后续的所有工作都可能是在“无用功”。</p><p>比如：假设你是一家连锁奶茶店的运营，最近发现A门店的销售额总是不如B门店。你想通过数据分析找出原因，并提升A门店的业绩。</p><p>那么，你的分析目标就是：“对比A、B门店的各项运营数据，找出导致销售额差异的关键因素，并提出针对性的优化建议。”</p><p>1.2. 数据采集：去哪里寻找“破案”的线索？<br/>明确了目标，我们就要开始寻找相关的数据。数据采集的方式有很多种，比如：</p><p>利用现有数据： 公司内部的数据库、业务报表、用户调研数据等。<br/>网络爬虫： 从网页上抓取公开的数据。<br/>API接口： 通过应用程序接口获取第三方平台的数据。<br/>公开数据集： 政府、研究机构等发布的公开数据。<br/>1.3. 数据清洗：去伪存真，让数据“能说人话”<br/>从各种渠道收集来的原始数据，往往是“脏”的，存在着各种问题，比如：</p><p>缺失值： 数据中有些字段是空白的。<br/>重复值： 同样的数据出现了多次。<br/>异常值： 明显不符合常理的数据，比如一个人的年龄是200岁。<br/>格式不一致： 比如日期格式有的是“2023-10-26”，有的是“2023/10/26”。<br/>数据清洗的目的，就是把这些“脏”数据处理干净，为后续的分析打下坚实的基础。</p><p>1.4. 数据存储：给清洗好的数据安个“家”<br/>清洗干净的数据，需要妥善地存储起来，方便随时调用和分析。</p><p>常见的数据存储方式有：</p><p>Excel/CSV文件： 适合小批量的数据。<br/>关系型数据库（如MySQL, PostgreSQL）： 适合结构化的数据，是企业中最常用的存储方式。<br/>非关系型数据库（如MongoDB）： 适合非结构化的数据，比如文本、图片等。<br/>1.5. 数据分析：深入挖掘，发现数据背后的“秘密”<br/>这是数据分析的核心环节。通过各种分析方法，从数据中提取有价值的信息。常用的分析方法包括：</p><p>对比分析： 比较不同维度下的数据差异，比如前面提到的A、B门店的对比。<br/>趋势分析： 观察数据随时间变化的规律，比如分析近一年来网站用户量的增长趋势。<br/>用户画像分析： 了解你的用户是谁，他们有什么特点。<br/>漏斗分析： 分析用户在完成某个流程（如注册、购买）时，每一步的转化率和流失率。<br/>1.6. 结果可视化与决策支持：让数据“开口说话”<br/>“一图胜千言”。将分析结果通过图表的形式直观地展示出来，可以帮助我们更好地理解数据，也更容易向他人传达我们的发现。常见的可视化图表有：</p><p>柱状图： 比较不同类别的数据大小。<br/>折线图： 展示数据随时间变化的趋势。<br/>饼图： 显示各部分占总体的比例。<br/>散点图： 观察两个变量之间的关系。<br/>最终，数据分析的价值在于支持决策。基于可视化的结果，我们可以得出结论，并提出具体的行动建议。</p><p>比如，通过分析发现A门店的水果茶系列销量远低于B门店，我们就可以建议A门店增加水果茶的品类，或者推出相关的优惠活动。</p><h2>2. 技能大盘点：成为数据分析师，你需要掌握什么？</h2><p>2.1. 业务理解能力：懂业务，才能做好分析<br/>数据分析师不能只埋头于数据，更要理解数据背后的业务逻辑。</p><p>只有深入了解业务，才能提出有价值的分析目标，并对分析结果做出合理的解读。</p><p>2.2. 数据采集工具<br/>SQL： 操作数据库的语言，是数据分析师的必备技能。你需要掌握基本的增删改查（CRUD）操作。<br/>网络爬虫： 如果需要从网络上获取数据，最基本的Python中的requests和BeautifulSoup库是你的好帮手。<a href="https://link.segmentfault.com/?enc=2cyWi%2FBk8JHTG8N5RM3cmw%3D%3D.bISow6BWf2WkTMGdTBqGe4V5iqw5hVn2K0fy6QPYJ3%2B7Px5ufqsm5WSFBz4%2FWIC4xX6I9f1zx%2BIpal17%2FGkxCiOkSyANXKR66x4o3o83vpJloVG%2BYkotfxwtpQ1BT8uh" rel="nofollow" target="_blank">https://www.disktool.cn/bbs/home.php?mod=space&amp;uid=20792&amp;do=b...</a><br/>2.3. 数据分析软件/工具<br/>Excel： 虽然功能有限，但对于快速处理小批量数据、制作简单的图表来说，Excel依然是一个非常高效的工具。<br/>Python/R： 这是数据分析师的“瑞士军刀”。Python凭借其丰富的第三方库（如Pandas, NumPy, Matplotlib, Seaborn, Scikit-learn）和强大的社区支持，成为了目前最主流的数据分析编程语言。<br/>BI工具（如Tableau, Power BI）： 这些工具可以帮助你快速地将数据转化为交互式的可视化报告，非常适合做业务监控和报表展示。</p><h2>3. 统计学基础：数据分析的“灵魂”</h2><p>统计学是数据分析的理论基础，它能帮助我们更科学、更严谨地进行数据分析。</p><p>主要包括：描述性统计学，数理统计学和推断性统计学。</p><p>3.1. 描述性统计学：给数据画个“像”<br/>描述性统计学主要是用一些指标来描述数据的基本情况，比如：</p><p>集中趋势： 平均值、中位数、众数。<br/>离散程度： 方差、标准差、极差。<br/>数据分布： 偏度、峰度。<br/>3.2. 数理统计学：从样本看“世界”<br/>数理统计学研究的是如何根据样本数据去推断总体的特征。</p><p>它是连接描述性统计学和推断性统计学的桥梁。</p><p>3.3. 推断性统计学：从数据中得出“结论”<br/>推断性统计学是数据分析的“重头戏”，它能帮助我们从样本数据中得出关于总体的结论，并判断这个结论的可靠性。主要包括：</p><p>假设检验： 判断样本与样本、样本与总体之间是否存在显著差异。<br/>比如： 某款新药声称可以有效降低血压。我们可以通过假设检验来判断，服用该药的患者血压下降的数据，是否足以证明该药真实有效，还是仅仅是偶然发生的。<br/>置信区间： 估计总体参数（如平均值）所在的范围。<br/>比如： 我们想知道全国所有男性的平均身高，但我们不可能测量每个人的身高。我们可以抽取一部分男性作为样本，计算出样本的平均身高，然后通过置信区间来估计全国男性的平均身高可能在哪个范围内。</p><h2>4. 总结</h2><p>本文首先系统地拆解了数据分析的六大核心步骤：从明确目标、采集数据，到数据清洗、存储，再到核心的分析环节与最终的可视化呈现和决策支持，建立对完整流程有了直观认识。</p><p>接着，总结了数据分析师必备的技能组合，强调了业务理解、SQL、Python等技术以及统计学理论基础的重要性，特别是推断性统计在数据驱动决策中的关键作用。</p><p>总之，想要成为一名优秀的数据分析师，不仅需要掌握实用的工具和编程技能，更要培养严谨的分析思维和深入的业务洞察力。</p>]]></description></item><item>    <title><![CDATA[Aloudata Agent 重磅功能发]]></title>    <link>https://segmentfault.com/a/1190000047389105</link>    <guid>https://segmentfault.com/a/1190000047389105</guid>    <pubDate>2025-11-11 14:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>自今年年初产品雏形推出以来， Aloudata Agent 保持着快速迭代，功能演进路径清晰而坚定：</p><ul><li>三阶能力跃迁：8 月，Aloudata Agent 公开体验版正式上线，形成了「AI 问数+智能归因+深度报告」端到端智能分析闭环，结合“场景助手”构建了一个真正面向业务、服务于决策的分析智能体。</li><li>洞察深化：9 月，Aloudata Agent 实现了基于指标语义层的智能归因分析能力升级，归因分析框架全面覆盖“时间波动 vs. 横向对比”与“维度归因 + 因子归因”的交叉场景，将根因定位的精度与深度推向新的高度。</li></ul><p>真正的进步来自于核心能力的持续迭代与关键瓶颈的逐一击破，每次直播发布，都是我们对 Aloudata Agent 能力边界的一次拓展。在完成端到端的分析决策闭环后，我们进一步思考：智能分析的终局，是否止步于“Chat”？在深入调研企业数据应用场景后，我们发现：相比零散的“问数”，结构化、可复用的“报告”是更加高价值的场景。 周报、月报、专题分析——这些承载核心业务逻辑的深度报告撰写，至今仍是数据团队的高频痛点。分析师的时间，并未因 AI 而释放，反而被困在重复的图表调整、数据核对与文案编排的低效循环中。</p><p>原因是，现阶段大模型尚未能自主生成结构确定、可高度复用的深度分析报告：</p><ul><li>一键生成的黑盒报告，难以融入分析师的思考脉络与业务判断；</li><li>而碎片化的问答交互，无法自动串联成具备逻辑递进的完整叙事；</li><li>一次出色的分析结果，难以沉淀为可共享复用的报告模版。</li></ul><p>为此，我们推动了一次关键的理念跃升：将 AI 从“随机结果的生成者”重塑为“人类思路的执行伙伴”，正式推出 「模块化 AI 报告」。在本次迭代中实现了“你来定制，AI 执行”的协作范式：</p><ol><li>自由规划：提供空白画布，由分析师自主定义报告的整体结构与章节逻辑，确保分析框架源自业务洞察与专业判断。</li><li>精准生成：每个分析模块独立响应定制化 Prompt，驱动 AI 生成与章节目标高度匹配的图表与解读，实现内容与思路的一致性。</li><li>无限调整：支持对任意模块进行独立编辑、优化或重新生成，实现局部迭代而不影响整体架构，真正做到“白盒可控”。</li><li>沉淀复用：支持将验证有效的报告框架存储为模板，将个人分析方法论转化为团队可复用的数字资产，推动组织分析能力的持续积累。</li></ol><p>11 月 25 日（周二）19:00，Aloudata 资深产品专家赵祎祺将深度解析该功能，分享如何通过“模块化 AI 报告”将周报月报撰写时间缩短 70%。欢迎预约观看</p><p><img width="723" height="4276" referrerpolicy="no-referrer" src="/img/bVdm0eE" alt="" title=""/></p>]]></description></item><item>    <title><![CDATA[数字人直播屡遭封禁？揭秘背后核心原因给出]]></title>    <link>https://segmentfault.com/a/1190000047388881</link>    <guid>https://segmentfault.com/a/1190000047388881</guid>    <pubDate>2025-11-11 13:06:31</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在AI浪潮下，数字人直播成为电商直播新风口。不少用户的数字人直播间却遭遇平台封禁，甚至被永久封号。这让人疑惑：数字人直播合规吗？平台允许吗？</p><p>实际上，数字人直播本身不违规。抖音、快手、淘宝等主流及新兴平台均未禁止或限制。多数数字人直播间违规，主要是触犯以下几类平台规定：（青否数字人源头v：zhibo175）</p><p>1、直播内容违法违规，这是最严重的违规类型：</p><p>涉及色情、暴力、恐怖等违背公序良俗的内容</p><p>诈骗、赌博、传销等扰乱社会秩序、损害公众利益的信息</p><p>涉及政治敏感、社会负面话题，易引发不稳定因素</p><p>讨论民族、宗教等敏感议题，可能引发矛盾冲突</p><p>散布谣言或虚假信息，误导公众、造成不良影响</p><p>此类违规一经发现，平台会给予永久封禁直播间甚至账号的严厉处罚。</p><p>2、直播内容侵犯他人权益，数字人直播需大量素材，不少商家疏忽侵权。</p><p>未经授权的音乐、视频、图片作背景，侵犯原作者知识产权</p><p>盗用他人话术、脚本，属不正当竞争</p><p>模仿或抄袭他人形象、声音等特色元素，可能构成侵权</p><p>未经许可使用知名IP或品牌元素，易引发法律纠纷</p><p>在知识产权保护趋严的当下，此类侵权易被投诉导致封号。</p><p>3、直播内容违反平台商业政策，商业违规是常见封号原因。</p><p>虚假宣传、夸大产品功效，误导消费者</p><p>用虚假折扣、原价虚高等误导性价格促销手段，损害消费者利益</p><p>恶意诋毁竞争对手，破坏市场秩序</p><p>销售平台禁售或限售商品，违反规定</p><p>引导线下交易，逃避监管、增加风险</p><p>4、直播方式不符平台要求，数字人直播也需遵守平台基本规则。</p><p>完全用录播内容冒充实时直播，缺乏真实性与互动性</p><p>循环播放同一段内容，让观众乏味</p><p>使用非法推流软件或设备，影响平台</p><p>多个直播间同时播相同内容，造成资源浪费与不良竞争</p><p>数字人直播安全指南：如何安全合规使用数字人直播、避免封号风险？</p><ol><li>选合规开发平台</li></ol><p>选技术成熟、合规的数字人系统是基础。如正合AI支持独立部署，避免版权纠纷，保护商业机密与用户数据。</p><ol start="2"><li>精心规划内容话术</li></ol><p>开播前严格审核直播内容与话术。避免侵权,定期更新内容，保持观众新鲜感与关注度。</p><ol start="3"><li>增强互动性与实时性</li></ol><p>平台反感完全录播、无互动的直播间。提升互动性，及时解答疑问。</p><ol start="4"><li>了解并遵守平台规则</li></ol><p>不同平台规则有差异，关注规则更新，及时调整策略。</p><p>青否数字人对于平台防封搭建有完整的方案！</p><p>半无人是当下最稳的搭建方案，我们整理了一整套搭建教程，超详细！</p><p>方案一：助播实时驱动（青否数字人源头v：zhibo175）</p><p>直播间画面同步呈现 “真人助播 + 数字人主播”，数字人讲解过程中，真人助播可随时开口接管，系统实时识别真人声音，数字人自动 “闭嘴让话”，全程无延迟、无违和感。</p><p>建议每隔3-5分钟插入1次真人露脸互动（如答疑、福利播报）。</p><p>支持 “一拖一”“一拖多” 两种搭建，满足不同体量需求：</p><p>一拖一模式：1 个真人主播对应 1 个数字人直播间，两者可实时配合互动。比如律师直播间，数字人讲解法律条文、案例分析，遇到客户的复杂咨询，真人直接接管解答。</p><p>一拖多模式：1 个真人主播可同时出现在多个数字人直播间，每个直播间的数字人形象、音色、产品、话术完全独立，可同步运营本地生活、电商带货、线索留资等多类目。</p><p>真人只需不时开口说通用话术（如 “点击下方小黄车”“关注领福利”），系统会同步触发所有直播间的数字人 “让位闭嘴”，1 个人干 N 个人的活，成本直降。</p><p> </p><p> </p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388883" alt="" title=""/></p><p>开播后点击 1 次 “助播驱动” 按钮，直播全程自动监测声音状态，无需其他任何操作！</p><p>方案二：主播实时驱动（青否数字人源头v：zhibo175）</p><p>直播间仅呈现数字人主播，真人无需露脸，只需在后台随时插话接管，真人语音会与数字人口型实时精准匹配！</p><p>同样支持“一键接管”，全程点击一次 “主播驱动”，系统自动完成 “真人声音识别→口型同步切换”。</p><p>方案三：实景AI直播</p><p>不止数字人直播，青否数字人还支持实景直播，视频直播，智能助播！</p><p>实景AI直播无数字人出镜，直播间展示实景画面，AI语音讲解产品，同时支持6大AI互动。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388884" alt="" title="" loading="lazy"/></p><p>以上 3 套方案直播搭建的完整执行细节，我们已整理成AI 直播搭建 SOP，包含步骤拆解、参数设置、避坑指南。</p><p>直播间设置上直接优化功能，将功能与防封嵌入系统当中，操作都有完整的教程交付，能够真正的做到搭建稳定的数字人直播间，青否数字人优化迭代速度根据平台规则进行及时优化系统，给出相关解决方案（青否数字人源头v：zhibo175）！</p>]]></description></item><item>    <title><![CDATA[从销售报表分析到供应链数据优化，Spre]]></title>    <link>https://segmentfault.com/a/1190000047388894</link>    <guid>https://segmentfault.com/a/1190000047388894</guid>    <pubDate>2025-11-11 13:05:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>从销售报表分析到供应链数据优化，SpreadJS 透视表插件全场景应用指南</h2><p>在 B 端产品开发中，数据分析师和销售团队总会向你提出同一个需求："能不能像 Excel 透视表那样，让我们自己拖拽字段就能看数据？"这个看似简单的问题，背后却隐藏着 Web 端数据分析的深层挑战：性能瓶颈、Excel 兼容性、用户习惯迁移成本。本文将基于 SpreadJS 数据透视表插件的技术实践，拆解如何在 Web 应用中构建真正可用的多维分析能力。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388896" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><h3>一、透视表背后的真实痛点</h3><h4>销售场景：滞后的决策支持</h4><p>某快消品公司的销售总监每周一要花费 3 小时手动处理数据：从 CRM 导出订单明细，从 ERP 调取库存数据，再拼凑成 Excel 透视表分析区域销售占比。当市场突发变化时，这套流程无法支撑实时决策。</p><p><strong>技术视角的困境：</strong></p><ul><li>传统 Web 报表是"预制菜"，字段固定无法灵活探索</li><li>纯前端大数据量渲染性能崩溃</li><li>离线 Excel 与在线系统形成数据孤岛</li></ul><h4>供应链场景：陷入 ETL 泥潭</h4><p>制造企业的供应链系统需要将几十家供应商的交期、质量、成本数据做多维对比。开发团队原本的方案是：后端建数据仓库→预计算汇总表→前端展示。结果新维度需求一出现，就要重新写 ETL，迭代周期长达 2 周。</p><p>这两个场景揭示了一个本质问题：<strong>业务人员需要"探索式分析"，但传统开发模式提供的是"固定式报表"</strong>。</p><h3>二、透视表插件的技术内核解析</h3><p>SpreadJS 选择了一条不同寻常的路径：在 Canvas 上自研表格渲染引擎，而非依赖 DOM 操作。这个技术决策为透视表带来了三个关键能力：</p><h4>1. Excel 兼容不是口号：底层格式无损对接</h4><p>透视表插件延续了 SpreadJS 对 Excel.xlsx 格式的深度解析能力。当用户导入包含透视表的 Excel 文件时，插件会完整保留：</p><ul><li>透视表结构定义（PivotCache、PivotTableDefinition）</li><li>计算字段与计算项公式</li><li>值字段的汇总方式（求和/平均值/计数/最大值/最小值）</li><li>样式与格式设置</li></ul><p>这种兼容不是表面 UI 模仿，而是<strong>文件格式级别的双向互通</strong>。桔柚科技在实践中的关键收益点就在于此——客户原有的 200 多个 Excel 分析模板无需重构，直接线上化。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388897" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h4>2. 性能基准：50 万行数据的 600 毫秒法则</h4><p>在营销数据分析场景中，单表 50 万行是常态。测试数据显示：SpreadJS 透视表从数据加载到渲染完成，全链路耗时稳定在 600ms 以内。</p><p><strong>性能实现路径：</strong></p><ul><li>数据层：惰性加载+聚合预计算，仅在视角变化时重算必要部分</li><li>渲染层：Canvas 脏区重绘，非可视区域不渲染</li><li>计算层：Web Worker 异步执行聚合计算，避免阻塞主线程</li></ul><p>这对开发者的价值在于：<strong>你不需要为性能写额外优化代码</strong>，插件默认扛住生产级数据量。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388898" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h4>3. API 设计哲学：声明式配置而非命令式操作</h4><pre><code class="JavaScript">// 典型初始化代码
let pivotTable = sheet.pivotTables.add("myPivotTable", "A1", 1, 1, dataRange);
pivotTable.summarizeValuesBy(PivotTableSummaryType.sum);

// 字段配置即数据模型
pivotTable.rowFields.add(pivotTable.pivotFields.get("region"));
pivotTable.columnFields.add(pivotTable.pivotFields.get("month"));
pivotTable.dataFields.add(pivotTable.pivotFields.get("sales"));</code></pre><p>API 设计遵循"配置即视图"的原则。开发者操作的是<strong>数据模型</strong>，而非直接操作 DOM。任何字段变更会自动触发视图更新，这显著降低了状态管理的复杂度。</p><h3>三、全场景实战：从销售到供应链</h3><h4>场景 1：销售业绩多维探索系统</h4><p>某 SaaS 厂商的客户成功团队需要分析客户健康度。他们要的不仅是结果，更是<strong>探索过程</strong>：先看行业维度，再钻取到客户规模，最后落到具体销售代表。</p><p><strong>实现架构：</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388899" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388900" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><strong>关键代码模式：</strong></p><pre><code class="JavaScript">// 动态字段切换
function switchDimension(fieldName, areaType) {
    // 清除现有字段
    pivotTable.rowFields.clear();
    // 添加新维度
    let field = pivotTable.pivotFields.get(fieldName);
    if(areaType === 'row') {
        pivotTable.rowFields.add(field);
    }
    // 视图自动刷新
}</code></pre><p><strong>开发者收益：</strong></p><ul><li>无需为每个分析维度写 SQL</li><li>用户自助探索，需求迭代减少 80%</li><li>字段配置序列化后可保存为"分析视图"，实现千人千面</li></ul><p><strong>最终用户价值：</strong></p><ul><li>分析响应时间从小时级降至秒级</li><li>鼠标拖拽即可完成复杂分组统计</li><li>支持"如果...会怎样"的假设分析</li></ul><h4>场景 2：供应链弹性分析平台</h4><p>制造企业需要评估供应商风险。传统方式是财务每月出一份静态报告。现在他们需要的是<strong>带计算字段的实时评分卡</strong>。</p><p><strong>技术难点：</strong></p><ul><li>交期稳定性需要标准差计算</li><li>质量评分需要加权平均</li><li>综合风险指数是自定义公式</li></ul><p>SpreadJS 的解决方案是<strong>计算字段 API</strong>：</p><pre><code class="JavaScript">// 定义交期稳定性指标
let stdDevField = pivotTable.calculatedFields.add("delivery_stability", 
    "=STDEV.P(delivery_days)");
stdDevField summarizeType = PivotTableSummaryType.average;

// 复合计算：风险评分 = 成本权重30% + 质量权重40% + 交期权重30%
let riskField = pivotTable.calculatedFields.add("risk_score",
    "=0.3*cost_score + 0.4*quality_score + 0.3*stability_score");</code></pre><p><strong>架构优势：</strong> 计算发生在前端，意味着：</p><ol><li>后端只需提供明细数据 ODS 层，无需预建汇总 Cube</li><li>新指标上线无需后端发布，前端热更新配置</li><li>用户可自定义公式，系统扩展性交给用户</li></ol><p><strong>业务价值：</strong> 采购员能即时看到"如果提升质量权重，哪家供应商排名变化"，这种模拟能力让决策从经验驱动转向数据驱动。</p><h3>四、集成模式：嵌入现有系统的最佳实践</h3><h4>模式 1：轻量级嵌入（iframe 方案）</h4><p>适合已有系统改造，2 小时集成：</p><pre><code class="HTML">&lt;iframe src="spreadjs-pivot.html?dataSource={api}" /&gt;</code></pre><p>通过 postMessage 实现跨域数据通信，保持现有系统架构不变。</p><h4>模式 2：深度集成（npm 包方案）</h4><p>适合新系统或重构项目：</p><pre><code class="JavaScript">import { PivotTable } from '@grapecity/spreadjs-pivot';

// 与React状态管理结合
const [pivotConfig, setPivotConfig] = useState(initialConfig);
useEffect(() =&gt; {
    pivotTable.fromJSON(pivotConfig);
}, [pivotConfig]);</code></pre><h4>模式 3：前后端协同（GcExcel 补充）</h4><p>当需要 <strong>Server 端批量生成透视表报告</strong>时，GcExcel 作为 SpreadJS 的服务端版本，提供完全一致的 API。同一份配置 JSON 可在前端交互探索，也可在后端批量导出 PDF 报告。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388901" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>五、客户实践的量化价值</h3><p>桔柚科技的 LEMON BI 平台是典型例证。他们服务电商客户，每天处理来自拼多多、抖音等 <strong>15+平台</strong>的广告数据。</p><p><strong>技术挑战：</strong></p><ul><li>数据量：单日最大 800 万条投放记录</li><li>时效性：客户要求分析结果延迟&lt;5 分钟</li><li>灵活性：每个客户分析维度不同</li></ul><p><strong>SpreadJS 的切入点是"模板化"：</strong></p><ol><li>客户用 Excel 设计好透视表模板上传</li><li>系统解析模板中的透视表结构</li><li>数据通过 API 注入，前端实时刷新</li></ol><p><strong>量化收益：</strong></p><ul><li>报表交付时间：<strong>从天级降至分钟级</strong></li><li>人力成本：数据分析师团队从 5 人缩减至 2 人</li><li>客户满意度：自助分析功能使续约率提升 15%</li></ul><p><strong>技术负责人反馈：</strong>"关键在于我们不需要重写客户的 Excel 思维，而是把 Excel 的能力线上化。"</p><h3>六、性能优化与用户体验细节</h3><h4>开发者需要关注的性能陷阱</h4><p>尽管插件本身高性能，但错误的数据准备仍会拖慢体验：</p><p><strong>误区 1：直接注入全量明细数据</strong></p><pre><code class="JavaScript">// 错误示范：把50万行明细塞进sheet
sheet.setDataSource(rawData); 

// 正确做法：在WebWorker中预聚合
const aggregatedData = await worker.postMessage(rawData);
pivotTable.cache.setData(aggregatedData);</code></pre><p><strong>误区 2：频繁刷新透视表</strong></p><pre><code class="JavaScript">// 错误示范：每个字段变更都refresh()
pivotTable.rowFields.add(field1);
pivotTable.refresh();
pivotTable.columnFields.add(field2);
pivotTable.refresh();

// 正确做法：批量操作后单次刷新
pivotTable.suspendPaint();
// ...批量操作
pivotTable.resumePaint();</code></pre><h4>用户体验的"微交互"</h4><p>优秀的分析工具靠细节取胜：</p><ol><li><strong>字段智能提示</strong>：输入计算字段公式时，支持 Excel 风格的函数提示</li><li><strong>拖拽视觉反馈</strong>：拖拽字段到区域时，高亮可放置区，降低学习成本</li><li><strong>异步状态管理</strong>：大数据计算时显示轻量加载动画，避免用户重复点击</li><li><strong>透视表与普通表无缝转换</strong>：用户可随时"冻结"当前透视结果为静态表，便于注释和分享</li></ol><h3>七、给产品经理与开发者的建议</h3><h4>何时选择 SpreadJS 透视表？</h4><p><strong>适合场景：</strong></p><ul><li>业务人员已深度使用 Excel 分析</li><li>分析维度无法预先穷举</li><li>需要"数据探索"而非"数据展示"</li><li>系统性能要求在前端完成聚合计算</li></ul><p><strong>谨慎场景：</strong></p><ul><li>数据量超过 100 万行且无法做预聚合</li><li>需要复杂 SQL 窗口函数分析</li><li>团队完全没有 Excel 用户基础</li></ul><h4>最小可行产品（MVP）路径</h4><p><strong>第一周：</strong></p><ul><li>搭建 SpreadJS 基础环境</li><li>接入一个主数据源（如销售明细）</li><li>实现行/列/值字段拖拽</li></ul><p><strong>第二周：</strong></p><ul><li>添加计算字段功能</li><li>实现"保存/加载透视视图"API</li><li>接入 GcExcel 实现 PDF 导出</li></ul><p><strong>第三周：</strong></p><ul><li>字段值筛选器</li><li>数据钻取（双击展开明细）</li><li>性能压测与优化</li></ul><p>这套路径已在多个客户案例中验证，<strong>3 周即可上线生产可用版本</strong>。</p><h3>八、结语：让分析回归业务本质</h3><p>SpreadJS 透视表插件的价值不在于技术参数的华丽，而在于它<strong>尊重了业务人员分析数据的自然方式</strong>。作为开发者，我们不再需要站在需求和实现之间做"翻译官"，而是提供一个让业务语言直接落地的技术载体。</p><p>当供应链经理用鼠标拖拽出库存周转率的地域分布，当销售总监在浏览器里完成原本需要 SQL 才能实现的客户分层，数据透视表就完成了它的使命——<strong>让分析工具隐形，让业务洞察显现</strong>。</p><h3>扩展链接</h3><p><a href="https://link.segmentfault.com/?enc=qnCJtZfhVAWW65lBDPD1hA%3D%3D.5mQ9eoJp6A5yRdh14%2F9Cwlq85qbPvuKLKEJ9t7iRWWL9R9WLv9zWzqkT93a6gktR" rel="nofollow" target="_blank">可嵌入您系统的在线Excel</a></p>]]></description></item><item>    <title><![CDATA[AI 辅助编码：让产品验证效率提升 55]]></title>    <link>https://segmentfault.com/a/1190000047388909</link>    <guid>https://segmentfault.com/a/1190000047388909</guid>    <pubDate>2025-11-11 13:04:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>AI 辅助编码：让产品验证效率提升 55% 的实战技巧</h2><p>软件开发行业在过去两年发生了巨大变化。该作者从 AI 编码助手问世之初就开始使用这类工具，而最有意思的发现是：AI 的价值远不止“写代码更快”，更彻底改变了产品验证的全流程。</p><p>在某团队的最新项目中，开发者们交付功能的速度突飞猛进，但随之而来的是更多边界案例问题和安全漏洞。这也是如今多数使用 AI 工具的团队面临的共同现状——开发速度加快了，但系统复杂度也同步提升了。</p><h3>核心价值在于验证，而非单纯提速</h3><p>数据最有说服力：使用 AI 编码助手的开发者，完成编码任务的速度平均提升 55%。但这只是冰山一角，真正的优势在编码完成后才显现。</p><p>采用 AI 工具的团队，产品上线周期同样缩短 55%。这份效率提升主要来自两方面：初始代码编写，以及首次代码审查。</p><p>代码审查提速的原因很简单：AI 生成的代码比人工代码更遵循标准模式，风格更简洁、一致性更强。即便是经验丰富的开发者，在高压下编写的代码也难以达到这种一致性。这让审查者不用在格式问题和基础错误上耗费过多精力，能集中关注架构设计和业务逻辑这类核心问题。</p><p>埃森哲（Accenture）的统计数据更直观：引入 AI 工具后，团队的合并请求量增加 8.69%，合并成功率提升 15%，而成功构建率更是暴涨 84%。这足以说明，AI 带来的不只是编码速度的提升，更是“更优质的代码被更快验证”的双赢。</p><h3>开发者如何正确使用 AI 编码工具？</h3><p>使用 AI 工具后，开发者的角色发生了本质转变。不再是传统意义上的“写代码”，而是变成了“统筹协调者”——管理 AI 的输出成果，并引导其朝着目标解决方案推进。</p><p>如今，开发者会花更多时间撰写清晰的需求指令和审查代码，而非亲手敲写实现逻辑。这就像身为技术负责人，管理着一位速度极快但偶尔会偏离方向的初级开发者。</p><p>这一转变也重塑了“核心技能”的定义，开发者需要重点提升这些能力：</p><ul><li>把复杂问题拆解为清晰、小型的任务模块</li><li>撰写详细的技术规格说明文档</li><li>快速识别 AI 代码中缺失的上下文信息</li><li>提出有深度的追问，比如“为什么采用这种实现方式？”</li></ul><p>很多开发者在使用 AI 工具时会陷入误区：把它们当成“魔法工具”盲目依赖。而真正能从中获益的开发者，都将其视为“需要明确指令的强大助手”。</p><h3>测试自动化：AI 驱动的内部验证革命</h3><p>在 AI 的众多应用场景中，测试生成堪称“王牌功能”。单元测试编写枯燥又繁琐，即便开发者知道它对质量至关重要，也很难主动投入足够精力。</p><p>AI 彻底改变了这一现状：原本需要数小时才能完成的测试套件，现在几分钟就能搞定。但这里有个关键技巧——必须做好对 AI 的引导。</p><p>建议使用“思维链（Chain-of-Thought）”这类高级提示词技巧，让 AI 分步解释自己的思考过程，这样能大幅提升测试覆盖率。</p><p>不要简单地说“为这个函数写测试”，而是换成：“分析这个函数，找出所有边界案例，解释你的推理逻辑，然后为每个案例编写完整测试”。</p><p>两者的差距天差地别：简单提示词只能得到基础测试，而带推理过程的结构化提示词，能生成真正能捕捉漏洞的高质量测试。</p><p>这种自动化不仅让内部验证提速，更实现了“既快又稳”——不仅功能开发更快，验证环节也更高效。</p><h3>快速原型：让产品更快触达用户</h3><p>验证的另一核心维度，是让真实用户接触产品。AI 工具能让开发者从“想法”到“可运行原型”的周期从数周压缩到数天。</p><p>该作者曾开发一个用于跟踪用户指标的内部仪表盘：放在五年前，这项工作至少需要一周时间；而在 AI 辅助下，仅用 6 小时就完成了可运行原型。虽然还未达到生产环境标准，但足以向相关方展示并收集反馈。</p><p>这种速度优势对产品测试至关重要：团队可以尝试更多想法，快速试错，并基于真实用户反馈迭代，而非依赖主观猜测。</p><p>但这里有个隐藏陷阱：如果原型开发速度提升 10 倍，反馈收集速度也必须同步跟上，否则瓶颈只会转移，无法真正提升效率。</p><p>成功的团队会从 MVP（最小可行产品）阶段就植入反馈闭环：添加数据分析工具、开展用户访谈、跟踪使用指标。他们把用户反馈视为产品核心部分，而非后续补充的附加功能。</p><h3>被忽视的安全隐患</h3><p>有个令人不安的事实：AI 生成的代码往往存在安全漏洞。这并非因为 AI 有恶意，而是它缺乏对具体项目安全需求的上下文认知。</p><p>研究数据显示，AI 助手在常见安全任务中表现糟糕：</p><ul><li>跨站脚本（XSS）防护：失败率 86%</li><li>日志注入防护：失败率 88%</li><li>输入验证清理：表现持续不佳</li></ul><p>更危险的是心理层面的影响：当 AI 快速且自信地生成代码时，开发者会不自觉地增加信任、降低审查力度。这是人的天性，却会带来严重风险。</p><p>不少开发者都有过类似经历：AI 生成的数据库查询语句看起来毫无问题，便不假思索地合并，完全忽略了 SQL 注入风险。</p><p>解决这个问题的关键在于“流程”而非“追求完美”，团队需要搭建这些防护机制：</p><ul><li>IDE 中集成静态应用安全测试（SAST）工具</li><li>通过动态应用安全测试（DAST）进行运行时检查</li><li>对依赖项开展软件成分分析（SCA）</li><li>在持续集成/持续部署（CI/CD）流水线中加入自动化安全扫描</li></ul><p>现在已有专门针对漏洞检测训练的 AI 安全工具，相比人工审查，这类工具能将漏洞检测时间缩短 92%——用 AI 解决方案应对 AI 带来的问题，是最高效的方式。</p><h3>信任系数：采纳率才是关键</h3><p>并非所有团队的 AI 应用都能见效：有些开发者能收获巨大生产力提升，有些却收效甚微。核心差异在于“信任”。</p><p>数据显示：接受约 30% AI 建议的开发者，能获得显著收益；而仅接受 23%建议的开发者，几乎看不到效果。这 7%的差距，正是效率分水岭。</p><p>背后的逻辑很简单：审查和拒绝 AI 建议需要耗费时间。如果频繁丢弃 AI 生成的内容，那么编码阶段节省的时间就会被完全抵消。</p><p>因此，跟踪 AI 工具的使用情况至关重要，建议重点关注这些指标：</p><ul><li>AI 工具的日活跃使用率</li><li>代码建议的采纳率</li><li>最终进入生产环境的 AI 生成代码行数</li></ul><p>这些数据能直观反映团队是在“受益于 AI”还是“与 AI 对抗”。</p><h3>2025 AI 编码工具选型指南</h3><p>AI 编码工具市场已呈爆发式增长：截至 2025 年末，全球已有超过 1500 万开发者使用 GitHub Copilot，较去年增长 400%。但 Copilot 并非唯一选择，不同工具各有侧重。</p><h4>全功能 AI 编码助手</h4><ul><li>GitHub Copilot：IDE 集成度最高，自动补全和函数生成能力突出，是国内开发者常用的插件之一</li><li>Cursor：专为 AI 优先开发设计，聊天交互界面体验极佳</li><li>Amazon CodeWhisperer：在 AWS 相关开发场景中表现亮眼</li></ul><h4>AI 驱动的开发平台</h4><ul><li>Replit：基于浏览器的编码环境，内置 AI 辅助功能，无需本地配置</li><li>Mimo：集学习平台与 AI 构建工具于一体，快速原型开发神器</li><li>Bolt：支持全栈应用快速生成，自带预览环境</li><li>v0.dev：专注于 React 组件生成，前端开发者福音</li></ul><h4>自主智能体（实验阶段）</h4><ul><li>Devin：能独立完成完整功能开发</li><li>Jules：擅长处理多步骤实现任务</li></ul><p>多数企业初期会统一选用一款主力工具，以控制成本并简化安全审查。但建议预留一定预算进行工具测试——不同工具在不同场景下各有优势。</p><p>比如快速原型验证场景，Mimo 或 Replit 比传统 IDE 更能快速出成果；而生产环境开发，GitHub Copilot 或 Cursor 与现有工作流的兼容性更好。</p><h3>对开发者职业发展的影响</h3><p>很多开发者都会担心：“AI 会取代我吗？”</p><p>诚实的答案是：不会，但你的工作内容会发生本质变化。开发者正在向“技术栈上游”迁移——减少在具体实现上的时间投入，更多关注架构设计；减少重复性繁琐工作，聚焦战略决策。</p><h4>初级开发者的机遇</h4><p>AI 接手了原本占初级开发者 60%工作时间的重复性任务，这让初级开发者能更早专注于系统设计和业务逻辑这类核心能力。而这些技能在过去往往需要数年时间才能积累成型。</p><h4>资深开发者的挑战</h4><p>审查 AI 输出内容会带来额外工作量：频繁在撰写规格说明、审查代码、修复 AI 错误之间切换上下文。</p><p>那些适应良好的资深开发者，都会主动拥抱“统筹协调者”的角色：提升提示词工程能力，学会撰写清晰的技术需求，培养识别 AI 代码潜在问题的直觉。</p><h3>未来趋势展望</h3><p>AI 辅助开发仍处于早期阶段：未来工具的上下文理解能力会更强，安全问题将基本得到解决，工作流程也会更加成熟。</p><p>但这场核心变革是不可逆的：软件开发不再是“敲代码”的单一行为，而是管理“人机协同”的复杂过程。</p><p>未来的竞争优势，不会属于“编码最快的团队”，而是属于“将 AI 深度融入整个验证体系”的团队——包括测试、安全、反馈闭环等各个环节，同时能驾驭“速度带来的复杂度”。</p><p>对于产品验证而言，这意味着：</p><ul><li>从 MVP 阶段就植入反馈收集机制</li><li>自动化整个测试金字塔（单元测试、集成测试、系统测试）</li><li>将安全验证嵌入开发工作流</li><li>关注信任度和采纳率，而非单纯追求速度</li></ul><p>那些做得好的团队，能以难以想象的速度交付经过充分验证的产品；而做得不好的团队，只会陷入“更快交付但更多问题”的困境。工具已经就绪，关键在于你是否准备好重新思考软件验证的方式。</p>]]></description></item><item>    <title><![CDATA[智能公式+自动处理，SpreadJS A]]></title>    <link>https://segmentfault.com/a/1190000047388912</link>    <guid>https://segmentfault.com/a/1190000047388912</guid>    <pubDate>2025-11-11 13:04:00</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>智能公式+自动处理，SpreadJS AI 插件开启表格数据计算及处理新时代</h2><p><strong>当表格遇到 AI，开发者应该关注什么？</strong></p><p>作为前端开发者，我们每天都在处理表格数据。从财务报表到运营分析，从实验数据到用户反馈，SpreadJS 已经让我们能在浏览器中实现 Excel 级别的功能。但现在，用户不再满足于"能用"，他们想要"智能"------能听懂自然语言、能自动分析数据、能解释复杂公式的智能表格。</p><p>SpreadJS AI 插件不是简单的聊天机器人，而是一个深度融合表格场景的垂直 AI 解决方案。让我们从技术实现和应用价值两个维度，看看它到底解决了什么问题。</p><h3>从三个核心函数看 AI 表格的能力边界</h3><h4>1. 内置 AI 函数：零成本集成 NLP 能力</h4><p>传统方案中，实现文本分析需要调用 API、处理异步回调、管理 API 密钥，还要考虑前端性能。现在，三行公式就能搞定：</p><pre><code class="JavaScript">// 批量翻译用户评论
=SJS.AI.TRANSLATE(B2:B9, "zh-cn")

// 分析客户反馈情感倾向
=SJS.AI.TEXTSENTIMENT(B2:B9, "好评", "差评", "中评")

// 自然语言查询
=SJS.AI.QUERY("列出A2:A5国家的首都", A2:A5)
</code></pre><p><strong>对开发者</strong>：无需搭建 NLP 服务，不用处理异步调用，API 密钥在服务端统一管理，前端直接调用公式即可。真正的"零运维"集成。</p><p><strong>对最终用户</strong>：在单元格里直接写自然语言，就能得到翻译结果、情感分析、甚至是 2025 年 24 节气的完整日期表。使用门槛降到零。</p><p><strong>典型场景</strong>：跨境电商的评论分析、多语言报表自动生成、非结构化数据快速查询。一个公式替代过去几十行代码。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388914" alt="img" title="img"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388915" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388916" alt="img" title="img" loading="lazy"/></p><h4>2. AI 公式助手：让复杂公式不再是黑盒</h4><pre><code>=INDEX(销售数据!B:B, MATCH(A2, 销售数据!A:A, 0)) * VLOOKUP(B2, 价格表!A:C, 3, FALSE)
</code></pre><p>看到这样的公式，普通用户直接放弃，甚至开发者也需要几秒钟理解。AI 公式助手做了两件事：</p><p><strong>自动生成</strong> ：用户说"根据 B 列成绩自动判定等级"，AI 返回<code>=IF(B2&gt;=90,"A",IF(B2&gt;=80,"B",IF(B2&gt;=60,"C","D")))</code>。支持行业函数如 XIRR、金融模型公式。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388917" alt="img" title="img" loading="lazy"/></p><p><strong>智能解释</strong>：选中任意复杂公式，AI 逐层拆解："第一步用 MATCH 查找位置，第二步用 INDEX 提取对应值，第三步..."</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388918" alt="img" title="img" loading="lazy"/></p><p><strong>对开发者</strong>：减少 80%的公式调试时间。用户能自己生成基础公式，你只处理真正复杂的业务逻辑。</p><p><strong>对最终用户</strong>：Excel 高级功能不再是"专家专属"。自然语言描述需求，公式自动生成，还能学习公式逻辑。</p><h4>3. AI 透视表：从拖拽到对话的范式转变</h4><p>传统透视表：用户需要理解"行/列/值/筛选"概念，手动拖拽字段。</p><p>AI 透视表：用户输入"按产品类别统计各地区销售额，找出增长最快的产品"，AI 自动生成透视表结构，填充数据，甚至标注异常值。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388919" alt="img" title="img" loading="lazy"/></p><p><strong>技术实现</strong>：插件将自然语言转化为 SpreadJS 的 PivotTable API 调用，自动识别维度、度量、聚合方式。支持结果保存为模板，下次直接复用。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388920" alt="img" title="img" loading="lazy"/></p><p><strong>对开发者</strong>：不用写透视表配置代码，不用培训用户如何使用透视表。AI 中间层自动处理意图识别和配置生成。</p><p><strong>对最终用户</strong>：数据分析能力民主化。市场运营、财务人员直接对话获取洞察，不再依赖数据分析师。</p><h3>架构设计：为什么它不只是个"AI 壳子"</h3><p>很多产品把 AI 做成聊天窗口，用户需要在表格和聊天窗之间来回切换。SpreadJS AI 插件的架构设计有三个关键点：</p><p><strong>1. 原生公式集成</strong> AI 能力封装为 SpreadJS 原生公式，与 450+现有公式无缝混用。计算引擎统一处理依赖关系、异步刷新，开发者无需关心 AI 调用的时序问题。</p><p><strong>2. 服务端密钥管理</strong> AI 插件采用服务端代理模式，前端只传递参数，API 密钥、计费、限流都在后端控制。避免密钥泄露，也便于企业统一管控 AI 成本。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388921" alt="img" title="img" loading="lazy"/></p><p><strong>3. 垂直 Agent 优化</strong> 插件不是通用聊天机器人，而是针对表格场景的垂直 Agent。它理解 A1 引用样式、知道 SUMIF 和 COUNTIF 的区别、能识别数据透视表的维度关系，错误率比通用 LLM 低一个数量级。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388922" alt="img" title="img" loading="lazy"/></p><h3>价值闭环：开发者和用户各自得到什么</h3><h4>开发者的收益清单</h4><ul><li><strong>开发加速</strong>：集成 AI 功能从"调研 API+封装 SDK+处理异步+UI 设计"压缩到"引入 JS 文件+注册服务"</li><li><strong>维护减负</strong>：AI 模型更新、Prompt 优化、错误处理由插件统一处理，你的代码无感升级</li><li><strong>成本可控</strong>：按实际 API 调用收费，无需预付资源。服务端代理模式便于企业级用量管控</li><li><strong>渐进增强</strong>：不影响现有功能，用户可按需启用 AI 特性，回退到传统用法无缝兼容</li></ul><h4>最终用户的收益清单</h4><ul><li><strong>效率跃升</strong>：复杂操作从 5 分钟缩短到 10 秒。批量数据处理、多语言翻译、情感分析一键完成</li><li><strong>门槛降低</strong>：不需要记公式语法、不需要学透视表拖拽、不需要懂数据分析理论</li><li><strong>能力升级</strong>：普通业务用户也能完成过去需要数据分析师的专业操作</li><li><strong>决策加速</strong>：从数据到洞察的周期从小时级缩短到分钟级</li></ul><h3>一个完整的场景示例：用户反馈分析</h3><p>以前：手动导出评论→写 Python 脚本调用翻译 API→再调用情感分析 API→结果导回 Excel→做透视表分析</p><p>现在，SpreadJS AI 插件实现：</p><pre><code class="JavaScript">// 步骤1：翻译所有评论
=SJS.AI.TRANSLATE(A2:A1000, "zh-cn")

// 步骤2：分析情感倾向
=SJS.AI.TEXTSENTIMENT(A2:A1000, "积极", "消极", "中性")

// 步骤3：AI自动生成透视表
// 用户输入："按产品类别和情感倾向统计评论数量"
// 插件生成透视表，自动配置行字段=产品类别，列字段=情感倾向，值=计数

// 步骤4：智能分析
// 用户问："哪个类别负面评价最多？"
// AI返回："手机配件类别消极评价占比35%，主要痛点是物流慢和包装破损"
</code></pre><p>整个过程无需离开表格，无需编写代码，5 分钟内完成过去需要数小时的分析工作。</p><h3>总结：重新思考表格的边界</h3><p>SpreadJS AI 插件的价值不在于"AI+表格"的概念，而在于它真正解决了两个痛点：</p><ol><li><strong>对开发者</strong>：把 AI 能力从"项目级开发"降级为"函数级调用"，让任何 SpreadJS 应用都能在 1 小时内获得 AI 能力。</li><li><strong>对使用者</strong>：把表格从"静态数据载体"升级为"智能分析助手"，让业务决策不再受工具能力限制。</li></ol><p>它不是要替代数据分析师或 Excel 专家，而是让 80%的常规分析工作自动化，让专业人员聚焦于 20%的高价值决策。</p><p>对于正在评估表格控件的团队，AI 插件意味着你的产品从交付那天起就具备智能能力，而不是在未来版本中"计划支持"。对于已有 SpreadJS 应用的客户，这是一行代码就能获得的竞争力升级。</p><p>表格控件已经发展了 20 年，SpreadJS AI 插件可能是下一个 20 年的起点。不是因为它有 AI，而是因为它让 AI 真正在表格场景中落地了。</p><h3>扩展链接</h3><p><a href="https://link.segmentfault.com/?enc=jJuY4Q6LO4bJ3HsJHCVDsQ%3D%3D.59LtYhKieCwg4WPR8NEfaoeRrPC%2BmAu%2FyEtJxjY874i2183tKWyXC6oNjEqZiVr6" rel="nofollow" target="_blank">可嵌入您系统的在线Excel</a></p>]]></description></item><item>    <title><![CDATA[深度解析｜“数据基础设施”系列国家标准技]]></title>    <link>https://segmentfault.com/a/1190000047388929</link>    <guid>https://segmentfault.com/a/1190000047388929</guid>    <pubDate>2025-11-11 13:03:10</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>国家发展改革委、国家数据局、工业和信息化部三部门联合印发《国家数据基础设施建设指引》，指导推进数据基础设施建设，推动形成横向联通、纵向贯通、协调有力的国家数据基础设施基本格局。</p><p><strong>“<strong><em><em>指引</em></em></strong>”<strong><em><em>明确了</em></em></strong><strong><em>“</em></strong>数据基础设施<strong><em><em>”</em></em></strong>的定义</strong>**，是指“_从数据要素价值释放的角度出发，面向社会提供数据采集、汇聚、传输、加工、流通、利用、运营、安全服务的一类新型基础设施，是集成硬件、软件、模型算法、标准规范机制设计等在内的有机整体_”。</p><p>全国数据标准化技术委员会（SAC/TC609）快速响应，组织发布了一系列“数据基础设施”国家标准技术文件。</p><p><strong><em><em>本文将从“数据基础设施”总体架构设计切入</em></em></strong>，围绕<strong><em><em>“什么是区域</em></em></strong>/<strong><em><em>行业功能节点？”</em></em></strong><strong><em>、</em></strong><strong><em>“谁接入？谁管理？”以及“安全能力如何规范？”</em></strong>等问题，对《数据基础设施 区域/行业功能节点技术要求》、《数据基础设施 接入管理》和《数据基础设施 安全能力通用要求》<strong>三份技术</strong>文件进行详细解读。</p><p><strong><em><em>第1份：TC609-6-2025-11</em></em></strong><strong><em/><em>《数据基础设施 区域</em></strong>/<strong><em><em>行业功能节点技术要求》</em></em></strong>技术文件主要明确了：</p><ul><li>国家数据基础设施中区域功能节点与行业功能节点的关系；</li><li>区域/行业功能节点的<strong>功能架构</strong>、<strong>功能要求</strong>、<strong>互操作要求</strong>、<strong>流程要求以及安全要求</strong>。</li></ul><p><strong>【详细解读👇】</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388931" alt="" title=""/></p><p><strong><em><em><em/>第2份：</em></em></strong><strong><em>TC609-6-2025-12</em></strong><strong><em><strong>《数据基础设施 接入管理》</strong></em></strong>技术文件**主要关注业务节点和接入连接器与区域/行业功能节点之间的“连接”，主要针对以下内容进行展开说明：</p><ul><li><strong>“</strong><strong>接入”：</strong>业务节点和接入连接器接入区域/行业功能节点需要满足哪些要求</li><li><strong>“</strong><strong>管理“：</strong>区域/行业功能节点如何管理接入的业务节点和接入连接器</li></ul><p><strong>【详细解读👇】</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388932" alt="" title="" loading="lazy"/></p><p><strong><em><em><em/>第3份：</em></em></strong><strong><em>TC609-6-2025-13</em></strong><strong><em><strong>《数据基础设施 安全能力通用要求》</strong></em></strong>技术文件<strong>主要明确了：数据基础设施的建设和运营过程中，相关组织在</strong>组织建设、制度流程、技术工具、人员能力<strong>等方面的</strong>安全能力通用要求**。</p><p><strong>【详细解读👇】</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388933" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[Oracle 19c ADG 搭建 墨天]]></title>    <link>https://segmentfault.com/a/1190000047388940</link>    <guid>https://segmentfault.com/a/1190000047388940</guid>    <pubDate>2025-11-11 13:02:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文为<a href="https://link.segmentfault.com/?enc=wBVxdEoCyEGaCQVszVhJ5g%3D%3D.PAioSY6tBqSCAhsCPq6alsTUtZvclGK620vwuDODrzhLrbSYc0mOiGZei%2BCa8Ym7" rel="nofollow" target="_blank">墨天轮数据库管理服务团队</a>第138期技术分享，内容原创，作者为技术顾问<strong>杨玉壮</strong>，如需转载请联系小墨（VX：modb666）并注明来源。如需查看更多文章可关注【墨天轮】公众号。</p><p><em>注意：本文测试搭建，正式环境搭建按需修改</em></p><p>所需环境：两台服务器</p><ul><li>主库：192.168.100.19（自己设置） 主机名：oracle19c 预装了oracle19c-db软件 监听和库都是正常的</li><li>备库：192.168.100.20（自己设置）主机名：oracle19c-dg 预装了oracle19c-db软件 （无监听，无数据库）</li></ul><p><strong>0、最重要的一步，关闭主备库所在操作系统的防火墙和SELINUX</strong></p><p><strong>1、修改/etc/hosts文件，将主从的ip和主机名添加进去（主备两边都要做）</strong></p><p>192.168.100.19 oracle19c</p><p>192.168.100.20 oracle19c-dg</p><p>1.1 ping对方主机名看看是否连通</p><ul><li>主：ping oracle19c-dg</li><li>备：ping oracle19c</li></ul><p><strong>2、主库启动到FORCE LOGGING（强制日志）</strong></p><p>简单点来说：强制日志就是对数据库中所有的操作都产生日志信息，并将该信息写入到联机重做日志文件中（ONLINE REDO LOG）。FORCE LOGGING默认是不开启的。如果你要是配置ADG的话，那么强制日志必须处于开启状态。</p><pre><code class="sql">alter database force logging;
select force_logging from v$database;
FORCE_LOGGING
---------------------------------------
YES</code></pre><p>看到YES就成功了</p><p>如何关闭强制日志：</p><pre><code class="sql">alter database no force logging;
select force_logging from v$database;
FORCE_LOGGING
---------------------------------------
NO</code></pre><p><strong>3、检查主库是否在归档模式下</strong></p><pre><code class="sql">archive log list;</code></pre><p>如果不是的话就设置到归档模式：</p><p>使用oracle用户执行下面的创建目录命令</p><pre><code class="sql">mkdir -p /u01/app/oracle/oradata/ORCL/arch</code></pre><p>进入到ORACLE数据库</p><pre><code class="sql">sqlplus / as sysdba</code></pre><p>设置归档目录</p><pre><code class="sql">alter system set log_archive_dest_1='location=/u01/app/oracle/oradata/ORCL/arch' scope=both;</code></pre><p>关闭数据库</p><pre><code class="sql">shutdown immediate</code></pre><p>将数据库启动到mount状态</p><pre><code class="sql">startup mount</code></pre><p>开启归档模式 </p><pre><code>alter database archivelog;</code></pre><p>启动数据库</p><pre><code class="sql">alter database open;</code></pre><p>再次检查归档状态</p><pre><code class="sql">archive log list;
Database log mode              Archive Mode
Automatic archival             Enabled
Archive destination            /u01/app/oracle/oradata/ORCL/arch
Oldest online log sequence     3
Next log sequence to archive   5
Current log sequence           5</code></pre><p>看到上面信息证明已经开启了。</p><p>3.1 给主库添加stand by备用日志组 ，要比现有的日志组多一组。</p><pre><code class="sql">select  group#, members,  bytes  from v$log;
    GROUP#    MEMBERS      BYTES
---------- ---------- ----------
         1          1  209715200
         2          1  209715200
         3          1  209715200</code></pre><p>现在我有三组，按照上面的说法那么我的standby日志组就要有四组。standby日志组是给切换以后的备库用的。</p><pre><code class="sql">select member from v$logfile;（找到你的redo的位置）
MEMBER
--------------------------------------------------------------------------------
/u01/app/oracle/oradata/ORCL/redo03.log
/u01/app/oracle/oradata/ORCL/redo02.log
/u01/app/oracle/oradata/ORCL/redo01.log</code></pre><p>添加standby日志</p><pre><code class="sql">alter database add standby logfile '/u01/app/oracle/oradata/ORCL/stdredo01.log' size 200M;
alter database add standby logfile '/u01/app/oracle/oradata/ORCL/stdredo02.log' size 200M;
alter database add standby logfile '/u01/app/oracle/oradata/ORCL/stdredo03.log' size 200M;
alter database add standby logfile '/u01/app/oracle/oradata/ORCL/stdredo04.log' size 200M;
select member from v$logfile;
MEMBER
--------------------------------------------------------------------------------
/u01/app/oracle/oradata/ORCL/redo03.log
/u01/app/oracle/oradata/ORCL/redo02.log
/u01/app/oracle/oradata/ORCL/redo01.log
/u01/app/oracle/oradata/ORCL/stdredo01.log
/u01/app/oracle/oradata/ORCL/stdredo02.log
/u01/app/oracle/oradata/ORCL/stdredo03.log
/u01/app/oracle/oradata/ORCL/stdredo04.log</code></pre><p>添加完成</p><p><strong>4、为了让ADG库起到更好的作用，我们需要修改LINUX内核参数。</strong></p><p>将这两个参数加入到sysctl.conf文件中并sysctl -p生效（用ROOT用户）</p><pre><code class="sql">vi /etc/sysctl.conf
net.ipv4.tcp_rmem = 4096    87380   6291456
net.ipv4.tcp_wmem = 4096    16384   4194304</code></pre><p>添加后生效</p><pre><code class="sql">sysctl -p</code></pre><p>注：net.ipv4.tcp\_r(w)mem含义为：自动优化所使用的接收缓冲区</p><p><strong>5、将监听修改为静态监听（强烈推荐。因为我们要加入网络优化参数，如果你不加参数也可以）</strong></p><p>切换到监听所在目录（主备库都要做）</p><pre><code class="sql">cd $ORACLE_HOME/network/admin
vi listener.ora（创建静态监听）这是主库的
SID_LIST_LISTENER =
  (SID_LIST =
    (SID_DESC =
      (SID_NAME = PLSExtProc)
      (ORACLE_HOME = /u01/app/oracle/product/19c/db_1/)
      (PROGRAM = extproc)
    )
    (SID_DESC =
      (SDU=32767)      
      (SID_NAME = orcl)
      (GLOBAL_DBNAME = orcl)
      (ORACLE_HOME = /u01/app/oracle/product/19c/db_1)
    )
  )
LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (SEND_BUF_SIZE=1406250)
      (RECV_BUF_SIZE=1406250)
      (ADDRESS = (PROTOCOL = TCP)(HOST = oracle19c)(PORT = 1521))
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
    )
  )
ADR_BASE_LISTENER = /u01/app/oracle</code></pre><p>修改完了以后重新加载监听 lsnrctl reload</p><p>然后检查监听状态 lsnrctl status</p><pre><code class="sql">vi listener.ora（创建静态监听）这是备库的
SID_LIST_LISTENER =
  (SID_LIST =
    (SID_DESC =
      (SID_NAME = PLSExtProc)
      (ORACLE_HOME = /u01/app/oracle/product/19c/db_1/)
      (PROGRAM = extproc)
    )
    (SID_DESC =
      (SDU=32767)      
      (SID_NAME = orcl)
      (GLOBAL_DBNAME = orcl)
      (ORACLE_HOME = /u01/app/oracle/product/19c/db_1)
    )
  )
LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (SEND_BUF_SIZE=1406250)
      (RECV_BUF_SIZE=1406250)
      (ADDRESS = (PROTOCOL = TCP)(HOST = oracle19c-dg)(PORT = 1521))
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
    )
  )
ADR_BASE_LISTENER = /u01/app/oracle</code></pre><p><strong>6、修改tnsname.ora文件 主备库都添加下面的内容</strong></p><p>注释：这是添加主备库的别名，其中MD代表MASETDATABASE 主库别名；SD代表SLAVEDATABASE 备库别名。</p><pre><code class="sql">vi tnsnames.ora（先修改主库的，里面有东西的话不用管直接添加下列内容）
MD =
  (DESCRIPTION =
    (SDU=32767)
    (SEND_BUF_SIZE=1406250)
    (RECV_BUF_SIZE=1406250)
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = oracle19c)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl)
    )
  )
SD =
  (DESCRIPTION =
    (SDU=32767)
    (SEND_BUF_SIZE=1406250)
    (RECV_BUF_SIZE=1406250)
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = oracle19c-dg)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl)
    )
  )</code></pre><pre><code class="sql">vi tnsnames.ora（修改备库的，里面有东西的话不用管直接添加下列内容）
MD =
  (DESCRIPTION =
    (SDU=32767)
    (SEND_BUF_SIZE=1406250)
    (RECV_BUF_SIZE=1406250)
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = oracle19c)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl)
    )
  )
SD =
  (DESCRIPTION =
    (SDU=32767)
    (SEND_BUF_SIZE=1406250)
    (RECV_BUF_SIZE=1406250)
    (ADDRESS_LIST =
      (ADDRESS = (PROTOCOL = TCP)(HOST = oracle19c-dg)(PORT = 1521))
    )
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl)
    )
  )</code></pre><p>下列连通性实验必须保证主备库监听都是开启的：</p><p>主库在oracle用户下使用：tnsping SD </p><pre><code class="sql">[oracle@oracle19c admin]$ tnsping SD
TNS Ping Utility for Linux: Version 19.0.0.0.0 - Production on 11-FEB-2022 14:47:33
Copyright (c) 1997, 2019, Oracle.  All rights reserved.
Used parameter files:
Used TNSNAMES adapter to resolve the alias
Attempting to contact (DESCRIPTION = (SDU=32767) (SEND_BUF_SIZE=1406250) (RECV_BUF_SIZE=1406250) (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = oracle19c-dg)(PORT = 1521))) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl)))
OK (10 msec)</code></pre><p>看到0k就代表成功</p><p>备库在oracle用户下使用：tnsping MD</p><pre><code class="sql">[oracle@oracle19c-dg admin]$ tnsping md
TNS Ping Utility for Linux: Version 19.0.0.0.0 - Production on 11-FEB-2022 14:47:43
Copyright (c) 1997, 2019, Oracle.  All rights reserved.
Used parameter files:
Used TNSNAMES adapter to resolve the alias
Attempting to contact (DESCRIPTION = (SDU=32767) (SEND_BUF_SIZE=1406250) (RECV_BUF_SIZE=1406250) (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = oracle19c)(PORT = 1521))) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl)))
OK (0 msec)</code></pre><p>看到OK就代表成功</p><p><strong>7、复制密码文件（从主库到备库）：</strong></p><pre><code class="sql">cd $ORACLE_HOME/dbs
scp orapworcl oracle@oracle19c-dg:$ORACLE_HOME/dbs</code></pre><p>（传输过程出现这玩意：Are you sure you want to continue connecting (yes/no)?  必须 输入yes）</p><p>拷贝完成后测试一下：</p><pre><code class="sql">sqlplus sys/oracle@MD as sysdba
SQL*Plus: Release 19.0.0.0.0 - Production on Fri Feb 11 15:57:31 2022
Version 19.3.0.0.0
Copyright (c) 1982, 2019, Oracle.  All rights reserved.
Connected to:
Oracle Database 19c Enterprise Edition Release 19.0.0.0.0 - Production
Version 19.3.0.0.0
SQL&gt; exit</code></pre><p><strong>8、主库添加下列参数：</strong></p><pre><code class="sql">alter system set job_queue_processes=10 scope=spfile; --作业进程限制 可加可不加看你具体需求
alter system set db_unique_name='orclmd' scope=spfile; （由于我们使用的是一个高可用集群，所以集群下每个节点都需要有一个唯一名） </code></pre><p>orclmd=orcl（实例名）md（masterdatabase）</p><p>本地监听只会注册你规定好的别名：</p><pre><code class="sql">alter system set local_listener='MD' scope=spfile;
alter system set global_names=true scope=both; --开启全局名称
 ALTER DATABASE RENAME GLOBAL_NAME TO orcl; --设置你的全局名称 要和非DG集群时你的实例名保持一致
--db_file_name_convert ：在使用数据复制时，指定你的主备库的数据复制路径
alter system set db_file_name_convert='/u01/app/oracle/oradata/ORCL','/u01/app/oracle/oradata/ORCL' scope=spfile;
alter system set db_file_name_convert='/u01/app/oracle/oradata/ORCL','/u01/app/oracle/oradata/ORCL' scope=spfile;</code></pre><pre><code class="sql"> (主库)                           (备库)
如果你的数据文件有多个路径（两个路径：/u01/app/oracle/oradata/ORCL和/u01/app/oracle/oradata/ORCL1）
 主库第一个路径                对应的备库的第一路径
alter system set db_file_name_convert='/u01/app/oracle/oradata/ORCL','/u01/app/oracle/oradata/ORCL' ,'/u01/app/oracle/oradata/ORCL1','/u01/app/oracle/oradata/ORCL1'scope=spfile;       
主库第二路径                    对应备库第二路径
--log_file_name_convert：在使用数据复制时，指定你的主备库的日志复制路径（online REDO和standby redo）
alter system set log_file_name_convert='/u01/app/oracle/oradata/ORCL','/u01/app/oracle/oradata/ORCL/redo' scope=spfile;
--FAL_CLIENT 设定FAL的客户端名称，一般为本地在tnsnames.ora中的别名，改参数只在备库角色时有效，但是ORACLE建议你还是在两边都是要设置，为了方便角色切换。
alter system set fal_client='MD' scope=spfile;
--这个参数设定备库从哪里获取到归档日志，一般设定为对方（如果是主库的就相对于是备库，如果备库的话就相对于是主库）在tnsnames.ora文件里的别名。
alter system set fal_server='SD' scope=spfile;
 --启动db接收或发送redo data，包括所有库的db_unique_name
alter system set log_archive_config = 'DG_CONFIG=(orclmd,orclsd)' scope=spfile;</code></pre><p>重新指定归档目录</p><pre><code class="sql">alter system set log_archive_dest_1='location=/u01/app/oracle/oradata/ORCL/arch valid_for=(all_logfiles,all_roles) db_unique_name=orclmd' scope=spfile;
alter system set log_archive_dest_2='service=SD LGWR SYNC AFFIRM valid_for=(all_logfiles,primary_role) db_unique_name=orclsd' scope=spfile;
-归档目录的状态
alter system set LOG_ARCHIVE_DEST_STATE_1='ENABLE';
alter system set LOG_ARCHIVE_DEST_STATE_2='ENABLE';
--该参数控制是否自动在备库中建立主库新建的数据文件</code></pre><p>注意以下两点：</p><p>（1）他不会自动创建日志文件</p><p>（2）如果数据文件重名会覆盖原有的数据文件</p><pre><code class="sql">alter system set standby_file_management='AUTO' scope=spfile;
--设置一个叫做orcl的服务
alter system set service_names='orcl' scope=spfile;
--设置归档的进程数据量
alter system set log_archive_max_processes=4 scope=spfile; </code></pre><p>9、修改备库参数</p><p>9.1 在主库中把spfile备份出一个pfile出来，方便我们修改</p><pre><code class="sql">cd $ORACLE_HOME/dbs
strings spfileorcl.ora &gt; orcl_init.ora
scp orcl_init.ora oracle@oracle19c-dg:$ORACLE_HOME/dbs</code></pre><p>9.2 进入到备库的$ORACLE\_HOME/dbs下</p><pre><code class="sql">cd $ORACLE_HOME/dbs
vi orcl_init.ora（把这种orcl.__的统统删除）
（修改下列参数）
*.db_unique_name='orclsd'
*.global_names=TRUE
*.local_listener='SD'
*.fal_client='SD'
*.fal_server='MD'
*.log_archive_config='DG_CONFIG=(orclmd,orclsd)' --这个位置不需要修改了
*.log_archive_dest_1='location=/u01/app/oracle/oradata/ORCL/arch valid_for=(all_logfiles,all_roles) db_unique_name=orclsd'
*.log_archive_dest_2='service=MD LGWR SYNC AFFIRM valid_for=(all_logfiles,primary_role) db_unique_name=orclmd'
*.log_archive_format='ARC_%t_%S_%r.arc'  (我主库在开归档时没有改，你们按需修改归档命名格式)</code></pre><p>创建归档目录()</p><pre><code class="sql">mkdir -p /u01/app/oracle/oradata/ORCL/arch</code></pre><p>创建adump目录</p><pre><code class="sql">mkdir -p /u01/app/oracle/admin/orcl/adump</code></pre><p>创建redo目录</p><pre><code class="sql">mkdir -p /u01/app/oracle/oradata/ORCL/redo</code></pre><p>备库的参数文件整体信息：</p><pre><code class="sql">*.audit_file_dest='/u01/app/oracle/admin/orcl/adump'
*.audit_trail='db'
*.compatible='19.0.0'
*.control_files='/u01/app/oracle/oradata/ORCL/control01.ctl','/u01/app/oracle/oradata/ORCL/control02.ctl'#Restore Controlfile
*.db_block_size=8192
*.db_file_name_convert='/u01/app/oracle/oradata/ORCL','/u01/app/oracle/oradata/ORCL'
*.db_name='orcl'
*.db_unique_name='orclsd'
*.diagnostic_dest='/u01/app/oracle'
*.dispatchers='(PROTOCOL=TCP) (SERVICE=orclXDB)'
*.fal_client='SD'
*.fal_server='MD'
*.global_names=TRUE
*.local_listener='SD'
*.log_archive_config='DG_CONFIG=(orclmd,orclsd)'
*.log_archive_dest_1='location=/u01/app/oracle/oradata/ORCL/arch valid_for=(all_logfiles,all_roles) db_unique_name=orclsd'
*.log_archive_dest_2='service=MD LGWR SYNC AFFIRM valid_for=(all_logfiles,primary_role) db_unique_name=orclmd'
*.log_archive_max_processes=4
*.log_file_name_convert='/u01/app/oracle/oradata/ORCL','/u01/app/oracle/oradata/ORCL/redo'
*.LOG_ARCHIVE_DEST_STATE_1='ENABLE'
*.LOG_ARCHIVE_DEST_STATE_2='ENABLE'
*.nls_language='AMERICAN'
*.nls_territory='AMERICA'
*.open_cursors=300
*.pga_aggregate_target=200m
*.processes=300
*.remote_login_passwordfile='EXCLUSIVE'
*.service_names='orcl'
*.sga_target=700m
*.standby_file_management='AUTO'
*.undo_tablespace='UNDOTBS1'</code></pre><p><strong>10、重启主备库监听</strong></p><p><strong>11、主备库测试连接（如果你之前已经做过了，那么这一步你也没必要做了）</strong></p><pre><code class="sql">--主
sqlplus sys/oracle@SD as sysdba
--备
sqlplus sys/oracle@MD as sysdba</code></pre><p>12、启动备库到nomount状态（用我们刚才做的那个pfile,如果你之前做完了 这一步就不用再做了）</p><pre><code class="sql">########################################################
startup nomount pfile='/u01/app/oracle/product/19c/db_1/dbs/orcl_init.ora'</code></pre><p>数据库正常启动以后创建spfile</p><pre><code class="sql">create spfile from  pfile='/u01/app/oracle/product/19c/db_1/dbs/orcl_init.ora';</code></pre><p>关闭数据库</p><pre><code class="sql">shutdown abort
########################################################</code></pre><p>这次再将备库启动到nomount状态 spfile文件创建完成</p><pre><code class="sql">startup nomount</code></pre><p>执行这个命名alter system set standby\_file\_management='MANUAL';防止redo复制时出错</p><p>用该命令检查一下参数</p><pre><code class="sql">SHOW PARAMETER STANDBY_FILE_MANAGEMENT
NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
standby_file_management              string
MANUAL(看到这玩意就是成功了)</code></pre><p><strong>13、在主库通过Rman Duplicate创建备库</strong></p><p>主库上执行</p><pre><code class="sql">rman target sys/oracle@MD auxiliary sys/oracle@SD nocatalog  </code></pre><p>ORACLE用户下执行的</p><p>然后开始复制数据库： </p><pre><code class="sql">duplicate target database for standby from active database nofilenamecheck;</code></pre><p><strong>14、在备库执行此语句代表文件全部传输到此</strong></p><pre><code class="sql">select member from v$logfile;
MEMBER
--------------------------------------------------------------------------------
/u01/app/oracle/oradata/ORCL/redo/redo03.log
/u01/app/oracle/oradata/ORCL/redo/redo02.log
/u01/app/oracle/oradata/ORCL/redo/redo01.log
/u01/app/oracle/oradata/ORCL/redo/stdredo01.log
/u01/app/oracle/oradata/ORCL/redo/stdredo02.log
/u01/app/oracle/oradata/ORCL/redo/stdredo03.log
/u01/app/oracle/oradata/ORCL/redo/stdredo04.log
SQL&gt; select name from v$datafile;
NAME
--------------------------------------------------------------------------------
/u01/app/oracle/oradata/ORCL/system01.dbf
/u01/app/oracle/oradata/ORCL/sysaux01.dbf
/u01/app/oracle/oradata/ORCL/undotbs01.dbf
/u01/app/oracle/oradata/ORCL/users01.dbf</code></pre><p>备库复制完之后已经就是mount状态了</p><p><strong>15、到备库开启实时日志应用</strong></p><pre><code class="sql">alter database open;
alter database recover managed standby database using current logfile disconnect from session;
set pagesize 100</code></pre><p>归档日志的应用状态</p><pre><code class="sql">select sequence# ,applied from v$archived_log;
SEQUENCE# APPLIED
---------- ---------------------------
11 YES
12 YES
13 YES
14 IN-MEMORY（不用去关心）</code></pre><p>上述语句执行完毕后，把我们这个给改回来</p><pre><code class="sql">alter system set standby_file_management='AUTO';
standby_file_management  ---&gt;备库文件管理“AUTO-自动模式，MANUAL-手动模式”</code></pre><p><strong>16、主库建表验证是否备库中存在（后面再做。。。。）</strong></p><p><strong>17、关闭备库后重新启动</strong></p><p>关闭备库：</p><pre><code class="sql">shutdown immediate</code></pre><p>开启备库：</p><pre><code class="sql">startup</code></pre><p>查看备库状态：</p><pre><code class="sql">select database_role,protection_mode,open_mode from v$database;
SQL&gt; select database_role,protection_mode,open_mode from v$database;
DATABASE_ROLE    PROTECTION_MODE      OPEN_MODE
---------------- -------------------- --------------------
PHYSICAL STANDBY MAXIMUM PERFORMANCE  READ ONLY（看到这个状态就说明你成功了）
recover managed standby database using current logfile disconnect from session; （备库应用日志进行介质恢复）
SQL&gt; recover managed standby database using current logfile disconnect from session;
Media recovery complete.
SQL&gt;  select database_role,protection_mode,open_mode from v$database;
DATABASE_ROLE    PROTECTION_MODE      OPEN_MODE
---------------- -------------------- --------------------
PHYSICAL STANDBY MAXIMUM PERFORMANCE  READ ONLY WITH APPLY （实时应用日志开启成功）</code></pre><p>至此 ADG配置完成。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046208374" alt="" title=""/>  </p><p>墨天轮从乐知乐享的数据库技术社区蓄势出发，全面升级，提供多类型数据库管理服务。墨天轮数据库管理服务旨在为用户构建信赖可托付的数据库环境，并为数据库厂商提供中立的生态支持。<br/>墨天轮数据库服务官网：<a href="https://link.segmentfault.com/?enc=YRTgXEx8WvOfQr5PPkOMXw%3D%3D.O8MDe7zwOQElzYWminv2iy8pJix9kRiTNYEOgeoNGIHfSFsv17J7xOzWftUu2Gef" rel="nofollow" target="_blank">https://www.modb.pro/service</a></p>]]></description></item><item>    <title><![CDATA[使用 Java、Spring Boot ]]></title>    <link>https://segmentfault.com/a/1190000047388969</link>    <guid>https://segmentfault.com/a/1190000047388969</guid>    <pubDate>2025-11-11 13:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>AI 智能体指的是一种软件实体，它能够利用自然语言处理、机器学习或推理系统等人工智能技术，自主感知、推理和行动，以实现特定目标。</blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388971" alt="" title=""/></p><p>我为 <a href="https://link.segmentfault.com/?enc=HusTUJQ69KxkpqKcCBKq6w%3D%3D.YMPRQdr2VzIbMX1ZuSz8BBez29mq5AMUINEWjZ5awEo%3D" rel="nofollow" target="_blank">Telex</a> 开发了一个 AI 智能体，该智能体接收一个正则表达式模式，并就该模式所匹配的字符串类型提供易于理解的解释。开发此智能体的灵感源于我在此之前开发的一个 API（您可以在<a href="https://link.segmentfault.com/?enc=hWjW%2BY68fu7lVbg0u0r0rw%3D%3D.Qk%2BJ2NyDT9qKK7w%2BAi%2BxaDN2KnJUK3ZHrnqiGtpMxPMow4pY0fvpGAM6lsUqUwoj" rel="nofollow" target="_blank">此处</a>查看该项目），在该 API 中我必须使用正则表达式进行一些自然语言处理。尽管我之前学习过正则表达式，但感觉像是第一次见到它。正则表达式就是这样。因此，当 Telex 为其平台寻求更多 AI 智能体时，我决定开发这个智能体。</p><p>以下是我使用 Java、Spring AI 和 Spring Boot 实现它的过程。</p><h2>初始设置</h2><h3>1.  Spring Boot 项目初始化</h3><p>我使用 Spring 提供的<a href="https://link.segmentfault.com/?enc=4CpemuV4SkAdnBUVUTMWXg%3D%3D.zoMzWvam3wHz2M%2B%2BDEUIm5WASBZRcr7y49OSs4YaH7c%3D" rel="nofollow" target="_blank">初始化工具</a>来初始化项目。请注意，我在依赖项中包含了 Spring Web 和 Open AI。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388972" alt="初始化 Spring 项目" title="初始化 Spring 项目" loading="lazy"/></p><h3>2.  设置 API 凭证</h3><p>在我的 <code>application.properties</code> 文件中，我设置了 Spring AI 以使用我的 API 凭证（我的 API 密钥）。我通过 Google AI Studio 获得了一个免费的 Google Gemini API 密钥。我的 <code>application.properties</code> 文件设置如下：</p><pre><code class="properties">spring.config.import=classpath:AI.properties

spring.application.name=regexplain
    
spring.ai.openai.api-key = ${GEMINI_API_KEY}
spring.ai.openai.base-url https://generativelanguage.googleapis.com/v1beta/openai
spring.ai.openai.chat.completions-path = /chat/completions
spring.ai.openai.chat.options.model = gemini-2.5-pro</code></pre><p>第一行导入了包含我 API 密钥的文件。重要的是不要将您的 API 密钥暴露给公众。该文件与 <code>application.properties</code> 位于同一文件夹中。</p><h3>3. 首次项目运行</h3><p>使用我的包管理器（Maven），我安装了所需的依赖项。然后我运行了我的主类，以确保一切正常。如果您到目前为止一切都做对了，您的项目应该可以无错误运行。如果遇到任何错误，请在 Google 上查找解决方法。</p><h2>A2A 请求和响应模型</h2><p>在深入实现之前，让我们先谈谈符合 A2A 标准的请求和响应的结构。A2A 协议遵循标准的 JSON-RPC 2.0 结构来处理请求和响应。</p><p>所有方法调用都封装在一个请求对象中，其结构如下：</p><pre><code class="json">{
  "jsonrpc": "2.0",
  "method": "String",
  "id": "String | Integer",
  "params": "Message"
}</code></pre><p>响应对象有些类似：</p><pre><code class="json">{
  "jsonrpc": "2.0",
  "id": "String | Integer | null",
  "result?": "Task | Message | null",
  "error?": "JSONRPCError"
}</code></pre><p>响应中的 ID <strong>必须</strong>与请求中的 ID 相同。</p><p>有关 A2A 协议的更多信息，请查阅 <a href="https://link.segmentfault.com/?enc=ta%2BsSs0rOLnBn9IiJ7Gg4w%3D%3D.bLa%2FmqUpbj%2FwR7VBkeS4gfUCZG1B7Q1L%2BS1BrJo5uZy%2BMv3mTqn33SeXH6eL9yA9" rel="nofollow" target="_blank">A2A 协议文档</a>。</p><p>以上就是请求和响应的通用结构。我开发这个智能体是为了在 Telex 平台上使用，因此我的部分实现可能特定于 Telex。</p><p>现在进入实现部分。我创建了一个名为 <code>model</code> 的文件夹，用于存储我的模型。请求模型类 <code>A2ARequest</code> 如下所示：</p><pre><code class="java">public class A2ARequest {
    private String id;
    private RequestParamsProperty params;

    public A2ARequest(String id, RequestParamsProperty params) {
        this.id = id;
        this.params = params;
    }

    // getters and setters
}</code></pre><p><code>RequestParamsProperty</code> 类代表了 <code>params</code> 中包含信息的结构。它如下所示：</p><pre><code class="java">public class RequestParamsProperty {
    private HistoryMessage message;
    private String messageId;

    public RequestParamsProperty(HistoryMessage message, String messageId) {
        this.message = message;
        this.messageId = messageId;
    }

    // getters and setter
}</code></pre><p><code>HistoryMessage</code> 类如下所示：</p><pre><code class="java">@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
public class HistoryMessage {
    private String kind;
    private String role;
    private List&lt;MessagePart&gt; parts;
    private String messageId;
    private String taskId;

    public HistoryMessage() {}

    public HistoryMessage(String role, List&lt;MessagePart&gt; parts, String messageId, String taskId) {
        this.kind = "message";
        this.role = role;
        this.parts = parts;
        this.messageId = messageId;
        this.taskId = taskId;
    }

    // getters and setters
}</code></pre><p>注解的作用是让 Spring 知道在请求和响应的 JSON 表示中包含什么。如果请求中不存在某个属性，它应该忽略它并在类中将其设置为 null。如果某个属性设置为 null，则不应将其包含在响应中。</p><p><code>MessagePart</code> 类如下所示：</p><pre><code class="java">@JsonIgnoreProperties(ignoreUnknown = true)
@JsonInclude(JsonInclude.Include.NON_NULL)
public class MessagePart {
    private String kind;
    private String text;
    private List&lt;MessagePart&gt; data;

    public MessagePart(String kind, String text, List&lt;MessagePart&gt; data) {
        this.kind = kind;
        this.text = text;
        this.data = data;
    }

    // getters and setters
}</code></pre><p>以上就是表示从 Telex 接收的请求结构所需的所有类。现在需要为我的响应创建一个模型，以及表示响应所需的所有支持类。</p><p><code>A2AResponse</code> 类：</p><pre><code class="java">@JsonInclude(JsonInclude.Include.NON_NULL)
public class A2AResponse {
    private final String jsonrpc;
    @JsonInclude(JsonInclude.Include.ALWAYS)
    private String id;
    private Result result;
    private CustomError error;

    public A2AResponse() {
        this.jsonrpc = "2.0";
    }

    public A2AResponse(String id, Result result, CustomError error) {
        this.jsonrpc = "2.0";
        this.id = id;
        this.result = result;
        this.error = error;
    }

    //getters and setters
}</code></pre><p><code>Result</code> 类：</p><pre><code class="java">public class Result {
    private String id;
    private String contextId;
    private TaskStatus status;
    private List&lt;Artifact&gt; artifacts;
    private List&lt;HistoryMessage&gt; history;
    private String kind;

    public Result() {}

    public Result(String id, String contextId, TaskStatus status, List&lt;Artifact&gt; artifacts, List&lt;HistoryMessage&gt; history, String task) {
        this.id = id;
        this.contextId = contextId;
        this.status = status;
        this.artifacts = artifacts;
        this.history = history;
        this.kind = task;
    }

    // getters and setters
}</code></pre><p><code>CustomError</code> 类：</p><pre><code class="java">public class CustomError {
    private int code;
    private String message;
    private Map&lt;String, String&gt; data;

    public CustomError(int code, String message, Map&lt;String, String&gt; data) {
        this.code = code;
        this.message = message;
        this.data = data;
    }

    // getters and setters
}</code></pre><p><code>TaskStatus</code> 类：</p><pre><code class="java">@JsonInclude(JsonInclude.Include.NON_NULL)
public class TaskStatus {
    private String state;
    private Instant timestamp;
    private HistoryMessage message;

    public TaskStatus() {}

    public TaskStatus(String state, Instant timestamp, HistoryMessage message) {
        this.state = state;
        this.timestamp = timestamp;
        this.message = message;
    }

    // getters and setters
}</code></pre><p><code>Artifact</code> 类：</p><pre><code class="java">public class Artifact {
    private String artifactId;
    private String name;
    private List&lt;MessagePart&gt; parts; // 稍后复查此类型

    public Artifact() {}

    public Artifact(String artifactId, String name, List&lt;MessagePart&gt; parts) {
        this.artifactId = artifactId;
        this.name = name;
        this.parts = parts;
    }

    // getters and setters
}</code></pre><p>A2A 协议还包含一个称为"智能体卡片"的东西。我也为它创建了一个模型。</p><pre><code class="java">public class AgentCard {
    private String name;
    private String description;
    private String url;
    private Map&lt;String, String&gt; provider;
    private String version;
    private Map&lt;String, Boolean&gt; capabilities;
    private List&lt;String&gt; defaultInputModes;
    private List&lt;String&gt; defaultOutputModes;
    private List&lt;Map&lt;String, Object&gt;&gt; skills;

    public AgentCard() {
        this.provider = new HashMap&lt;&gt;();
        this.capabilities = new HashMap&lt;&gt;();
        this.skills = new ArrayList&lt;&gt;();
    }

    // getters and setters
}</code></pre><p>模型部分就这些了。继续...</p><h2>服务类</h2><p>我的智能体的作用是获取一个正则表达式字符串，然后使用预定义的提示词将其发送到 OpenAI 的 API。服务类负责与 OpenAI 通信，发送提示词并接收响应。我创建了另一个名为 <code>service</code> 的文件夹，我的服务类就放在这里。我是这样编写我的服务类的：</p><pre><code class="java">@Service
public class RegExPlainService {
    private ChatClient chatClient;

    RegExPlainService(ChatClient.Builder chatClientBuilder) {
        this.chatClient = chatClientBuilder.build();
    }

    @Tool(name = "regexplain", description = "An agent that explains what type of string a regex pattern matches")
    public String generateResponse(String regex) {
        return chatClient
                .prompt("Give me a simple explanation of the type of string matched by this regex pattern: %s. No validating statements from you. Just straight to the point".formatted(regex))
                .call()
                .content();
    }
}</code></pre><p><code>@Service</code> 注解允许 Spring Boot 将服务注入到您的控制器中。<code>@Tool</code> 注解将该方法标记为一个智能体工具，如果将来要扩展该智能体以包含该功能，它可以被自主调用。不过目前并不需要它。</p><h2>控制器</h2><p>控制器通过 REST API 暴露该智能体。在这个案例中，我有两个端点，一个 GET 端点和一个 POST 端点。我在一个名为 <code>controller</code> 的文件夹中创建了我的控制器。实现如下：</p><pre><code class="java">@RestController
public class RegExPlainController {
    private final RegExPlainService regexplainService;

    @Autowired
    RegExPlainController (RegExPlainService regexplainService) {
        this.regexplainService = regexplainService;
    }

    @GetMapping("/a2a/agent/regexplain/.well-known/agent.json")
    public ResponseEntity&lt;AgentCard&gt; getAgentCard () {
        AgentCard agentCard = new AgentCard();
        agentCard.setName("regexplain");
        agentCard.setDescription("An agent that provides a simple explanation of the type of string a regex pattern matches");
        agentCard.setUrl("regexplain-production.up.railway.app/api");
        agentCard.setProvider("Bituan", null); // 假设 setProvider 处理 Map 的填充
        agentCard.setVersion("1.0");
        agentCard.setCapabilities(false, false, false); // 假设 setCapabilities 处理 Map 的填充
        agentCard.setDefaultInputModes(List.of("text/plain"));
        agentCard.setDefaultOutputModes(List.of("application/json", "text/plain"));
        agentCard.setSkill("skill-001", "Explain Regex", "Provides a simple explanation of the type of string a regex pattern matches",
                List.of("text/plain"), List.of("text/plain"), List.of());

        return ResponseEntity.ok(agentCard);
    }

    @PostMapping("/a2a/agent/regexplain")
    public ResponseEntity&lt;A2AResponse&gt; explainRegex (@RequestBody A2ARequest request) {
        String regexRequest;
        String responseText;

        // 如果参数无效，返回 403
        try {
            regexRequest = request.getParams().getMessage().getParts().get(0).getText();
        } catch (Exception e) {
            CustomError error = new CustomError(-32603, "Invalid Parameter", Map.of("details", e.getMessage()));
            A2AResponse errorResponse = new A2AResponse(null, null,  error);
            return ResponseEntity.status(HttpStatusCode.valueOf(403)).body(errorResponse);
        }

        // 如果调用服务失败，返回错误 500
        try {
            responseText = regexplainService.generateResponse(regexRequest);
        } catch (Exception e) {
            CustomError error = new CustomError(-32603, "Internal Error", Map.of("details", e.getMessage()));
            A2AResponse errorResponse = new A2AResponse(null, null,  error);
            return ResponseEntity.internalServerError().body(errorResponse);
        }

        // 构建响应
        A2AResponse response = new A2AResponse();
        response.setId(request.getId());

        // 构建响应 -&gt; 构建结果
        Result result = new Result();
        result.setId(UUID.randomUUID().toString());
        result.setContextId(UUID.randomUUID().toString());
        result.setKind("task");

        // 构建响应 -&gt; 构建结果 -&gt; 构建状态
        TaskStatus status = new TaskStatus();
        status.setState("completed");
        status.setTimestamp(Instant.now());

        // 构建响应 -&gt; 构建结果 -&gt; 构建状态 -&gt; 构建消息
        HistoryMessage message = new HistoryMessage();
        message.setRole("agent");
        message.setParts(List.of(new MessagePart("text", responseText, null)));
        message.setKind("message");
        message.setMessageId(UUID.randomUUID().toString());

        // 构建响应 -&gt; 构建结果 -&gt; 构建状态 (续)
        status.setMessage(message);

        // 构建响应 -&gt; 构建结果 -&gt; 构建工件
        List&lt;Artifact&gt; artifacts = new ArrayList&lt;&gt;();
        Artifact artifact = new Artifact();
        artifact.setArtifactId(UUID.randomUUID().toString());
        artifact.setName("regexplainerResponse");
        artifact.setParts(List.of(new MessagePart("text", responseText, null)));
        artifacts.add(artifact);

        // 构建响应 -&gt; 构建结果 -&gt; 构建历史记录
        List&lt;HistoryMessage&gt; history = new ArrayList&lt;&gt;();

        // 构建响应 -&gt; 构建结果 (续)
        result.setStatus(status);
        result.setArtifacts(artifacts);
        result.setHistory(history);

        // 构建响应 (续)
        response.setResult(result);

        return ResponseEntity.ok(response);
    }
}</code></pre><ul><li>GET 端点使用的路由路径是 A2A 协议标准中用于获取智能体卡片的部分。智能体卡片是对智能体及其功能的描述。</li><li>POST 端点接收一个符合 A2A 标准的请求，执行智能体，然后返回适当的响应。</li></ul><h2>结论</h2><p>就是这样。这就是我编写 Regexplain 的过程。</p><blockquote>通过这个示例，您可以从头开始构建您的 AI 智能体并使其符合 A2A 标准。或者，至少我希望这能让您对如何使用 Java 开发符合 A2A 标准的 AI 智能体有所了解。</blockquote><hr/><p>【注】本文译自：<a href="https://link.segmentfault.com/?enc=8U7kQfNdUT%2FyiBG42d6S8g%3D%3D.aOw6SNavv0Kz9JHhhPXDIzX3YmkMpWI%2By1jOjDio9QzkgiNpxR2mJq13pb%2FQKMUTesvP1rOFQ6jX7LVDCbwXrKMdvcx6zVCIFbwzPOQHngFn4%2FSaoTdHunNxKgWlYHzEvw%2Fk1pcIYC7%2BpqHf6pogaQ%3D%3D" rel="nofollow" target="_blank">Developing an A2A-compliant AI Agent with Java, Spring Boot and Spring AI - DEV Community</a></p>]]></description></item><item>    <title><![CDATA[ArkTS 并发日志系统实现：TaskP]]></title>    <link>https://segmentfault.com/a/1190000047388605</link>    <guid>https://segmentfault.com/a/1190000047388605</guid>    <pubDate>2025-11-11 12:11:02</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>🧩 ArkTS 并发日志系统实现：TaskPool + AsyncLock 实战解析</h2><blockquote><p>本文基于官方文档</p><ul><li><a href="https://link.segmentfault.com/?enc=Fpb%2BhnKdO16TU3GoqsS5Pg%3D%3D.CjTHEcPecEZULXr3DTSINLsyBT2bzIiaGF6kTaCRFTbcHFrLUhXtMdJayd4uYMZoJkW7ExSgpT8zIzQzf2QuXRLySzkJWdABcYMkFwb8AxBV5qvtAGSjAwCC3IUKiePK" rel="nofollow" target="_blank">TaskPool 并发机制介绍</a></li><li><a href="https://link.segmentfault.com/?enc=RelfaKvxwa3vStW8Yqe0kQ%3D%3D.4fEI6SQwIIpipC49XNd1r4x4Q%2FIxGp5SYS%2Bhl68XFnib3QRjtg0Y8nTf3qhnQj77JvHqyI4w4O2avb1cJyIkzbBGG6Mm09vaDFpF5njqSSTME3j21aa%2BX%2BDWgOdAjRIx" rel="nofollow" target="_blank">ArkTS 异步锁 API 参考</a><br/>结合实际工程实践，展示了在 HarmonyOS ArkTS 中构建高性能、线程安全的日志系统的方法。</li></ul></blockquote><hr/><h3>一、背景：为什么采用并发写日志</h3><p>日志系统通常是高频调用且 IO 密集的模块。传统实现中，日志写入、压缩和旧文件清理等操作在主线程执行可能会导致：</p><ul><li>主线程阻塞，影响 UI 响应；</li><li>文件写入冲突，多线程同时操作同一文件导致数据不一致；</li><li>日志目录膨胀，清理逻辑阻塞，降低性能。</li></ul><p>在 API version 9 之后，ArkTS 提供了 TaskPool 并发机制和 AsyncLock 工具类，可以将耗时的日志操作移到子线程执行，同时保证线程安全。</p><hr/><h3>二、架构设计概览</h3><p>日志系统采用四层架构：</p><table><thead><tr><th>层级</th><th>模块</th><th>主要职责</th></tr></thead><tbody><tr><td>调用入口</td><td><code>SaveLogHelper</code></td><td>对外提供统一日志 API（save、get、clear）</td></tr><tr><td>抽象层</td><td><code>AbsSaveLog</code></td><td>统一日志接口定义</td></tr><tr><td>实现层</td><td><code>SpSaveLog</code></td><td>使用 TaskPool + AsyncLock 实现线程安全的异步日志</td></tr><tr><td>并发任务</td><td><code>SpSaveLogTask</code></td><td>@Concurrent 修饰的实际任务函数（子线程执行）</td></tr></tbody></table><p>整体调用链如下：</p><pre><code>Logger.preLogContent()
 └── SaveLogHelper.saveLog()
      └── SpSaveLog.saveLog()
           ├── AsyncLock.lockAsync()  // 异步加锁，保证线程安全
           └── taskpool.execute()     // 启动并发任务 saveLog()</code></pre><hr/><h3>三、TaskPool 与 @Concurrent 的应用</h3><p>在日志系统中，三个关键并发任务采用 @Concurrent 修饰：</p><pre><code class="ts">@Concurrent
export async function saveLog(ctx: Context, tag: string, message: string) { ... }

@Concurrent
export async function getLog(ctx: Context): Promise&lt;string&gt; { ... }

@Concurrent
export async function clearLog(ctx: Context) { ... }</code></pre><h4>@Concurrent 的作用</h4><p><code>@Concurrent</code> 标记函数可在子线程中执行。ArkTS 编译器会检查参数和返回值是否可序列化，以支持线程间传输。</p><ul><li><code>Context</code>、<code>string</code>、<code>boolean</code> 等类型都可序列化；</li><li>因此可直接通过 <code>taskpool.execute()</code> 异步调用。</li></ul><h4>taskpool.execute() 调用</h4><pre><code class="ts">return taskpool.execute(saveLog, context, tag, message) as Promise&lt;boolean&gt;;</code></pre><p>任务被序列化并派发到 TaskPool 的空闲线程异步执行，返回 Promise，避免主线程阻塞。</p><hr/><h3>四、AsyncLock 异步锁与锁模式选择</h3><p>并发任务可能同时操作同一日志文件或目录，容易产生数据竞争。AsyncLock 提供异步锁来保证线程安全：</p><pre><code class="ts">private static lock = ArkTSUtils.locks.AsyncLock.request("SpSaveLog_lock_sp")</code></pre><p>在日志系统中，所有文件操作使用 EXCLUSIVE 模式锁：</p><pre><code class="ts">return SpSaveLog.lock.lockAsync(() =&gt; {
  const context = SaveLogManager.get().getContext()
  return taskpool.execute(saveLog, context, tag, message)
}, ArkTSUtils.locks.AsyncLockMode.EXCLUSIVE)</code></pre><h4>锁模式选择原因</h4><ul><li><strong>EXCLUSIVE</strong>：保证同一时间只有一个任务操作日志文件或目录，防止写入冲突和数据损坏；</li><li><strong>SHARED</strong>：允许多个任务同时进入临界区，适用于只读操作；但日志写入/清空涉及写操作，不适合 SHARED 模式。</li></ul><p>因此，为了安全地执行写操作，必须使用 EXCLUSIVE 模式。</p><hr/><h3>五、日志任务详细实现</h3><p>以下内容详细说明 <code>saveLog</code>、<code>getLog</code> 和 <code>clearLog</code> 的实现逻辑及关键步骤。</p><h4>1. 日志写入逻辑 (saveLog)</h4><p>日志写入任务通过以下步骤实现：</p><ol><li>检查日志目录是否存在，如果不存在则创建目录。</li><li>计算日志目录大小，如果超过 <code>MAX_LOG_DIR_SIZE</code>，按修改时间排序删除最早文件，确保目录大小限制。</li><li>按当前日期生成日志文件名（<code>YYYY-MM-DD.log</code>）。</li><li>准备日志内容，格式 <code>[时间] [标签] 日志内容</code>。</li><li>追加写入日志文件，如果文件不存在则创建。</li><li>使用 AsyncLock EXCLUSIVE 模式包裹写入逻辑，确保同一时间仅一个任务写日志，防止文件冲突。</li><li>在子线程执行，主线程不阻塞。</li></ol><p>核心代码示例：</p><pre><code class="ts">@Concurrent
export async function saveLog(ctx: Context, tag: string, message: string) {
  if (!ctx) {
    return
  }
  const funcName = 'saveLog'
  const logDir = ctx.filesDir + LOG_DIR // 统一日志目录
  // 检查并创建日志目录
  try {
    const exist = await fs.access(logDir)
    if (!exist) {
      await fs.mkdir(logDir)
    }
  } catch (e) {
    LogUtil.errorForce(funcName, 'mkdir file error:' + e)
  }
  // 计算文件夹大小并清理旧文件
  const getFileSize = (path: string): number =&gt; {
    let total = 0
    try {
      const files = fs.listFileSync(path)
      for (const file of files) {
        const stat = fs.statSync(path + '/' + file)
        if (stat.isFile()) {
          total += stat.size
        }
      }
    } catch (e) {
      LogUtil.errorForce(funcName, 'getFileSize error', e)
    }
    return total
  }
  const cleanOldLogsIfNeeded = (): void =&gt; {
    let total = getFileSize(logDir)
    if (total &lt;= MAX_LOG_DIR_SIZE) {
      return
    }
    let files: string[] = []
    try {
      files = fs.listFileSync(logDir)
    } catch (e) {
      LogUtil.errorForce(funcName, 'get files error', e)
    }
    // 按修改时间排序（最早的在前）
    files.sort((a, b) =&gt; {
      let mtimeA = 0, mtimeB = 0
      try {
        const statA = fs.statSync(logDir + '/' + a)
        mtimeA = statA?.mtime ?? 0
      } catch (e) {
        mtimeA = 0
        LogUtil.errorForce(funcName, `sort failed: get statA.mtime error: ${e}`)
      }
      try {
        const statB = fs.statSync(logDir + '/' + b)
        mtimeB = statB?.mtime ?? 0
      } catch (e) {
        mtimeB = 0
        LogUtil.errorForce(funcName, `sort failed: get statA.mtimeB error: ${e}`)
      }
      return mtimeA - mtimeB
    })
    // 依次删除最早的文件直到小于 20MB
    for (const f of files) {
      if (total &lt;= MAX_LOG_DIR_SIZE) {
        break
      }
      try {
        const fpath = logDir + '/' + f
        const stat = fs.statSync(fpath)
        fs.unlinkSync(fpath)
        total -= stat.size
      } catch (e) {
        LogUtil.errorForce(funcName, 'remove file error:' + e)
      }
    }
  }
  // 调用清理逻辑
  cleanOldLogsIfNeeded()
  // 当前日期对应的日志文件
  const date = new Date()?.toISOString?.()?.split?.('T')?.[0] ?? "1970-01-01"
  const filePath = `${logDir}/${date}.log`
  // 准备日志内容
  const time = new Date()?.toLocaleString?.('zh-CN', { timeZone: 'Asia/Shanghai', hour12: false }) ?? "1970-01-01"
  const logLine = `[${time}] [${tag}] ${message}\n`
  // 追加写入日志
  let file: fs.File | undefined
  try {
    file = await fs.open(filePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE)
    const stat = await fs.stat(filePath)
    await fs.write(file.fd, logLine, { offset: stat.size })
  } finally {
    fs.close(file?.fd)
  }
}</code></pre><h4>2. 日志获取逻辑 (getLog)</h4><p>日志获取任务用于生成压缩文件：</p><ol><li>检查日志目录是否存在。</li><li>检查压缩目录是否存在，如果存在先删除再重建。</li><li>遍历日志文件，按时间戳生成压缩文件名。</li><li>使用 <code>zlib.compressFile</code> 压缩日志目录。</li><li>使用 AsyncLock EXCLUSIVE 模式，确保压缩过程中不会与写入或清理任务冲突。</li><li>返回压缩文件路径，如果发生异常返回空字符串。</li></ol><p>核心代码示例：</p><pre><code class="ts">// 获取日志压缩文件uri
@Concurrent
export async function getLog(ctx: Context): Promise&lt;string&gt; {
  const funcName = 'getLog'
  const result: string = ''
  if (!ctx) {
    return result
  }
  const logDir = ctx.filesDir + LOG_DIR
  const zipDir = ctx.filesDir + LOG_ZIP_DIR
  try {
    const exist = await fs.access(logDir)
    if (!exist) {
      return result
    }
  } catch (e) {
    LogUtil.errorForce(funcName, 'logDir does not exist: ' + e)
    return result
  }
  try {
    const exist = await fs.access(zipDir)
    if (exist) {
      await fs.rmdir(zipDir)
      await fs.mkdir(zipDir)
    } else {
      await fs.mkdir(zipDir)
    }
  } catch (e) {
    LogUtil.errorForce(funcName, 'zipDir operate error: ' + e)
    return result
  }
  const getTimestampForFilename = (): string =&gt; {
    try {
      const now = new Date()
      const yyyy = now.getFullYear()
      const MM = String(now.getMonth() + 1).padStart(2, '0')
      const dd = String(now.getDate()).padStart(2, '0')
      const hh = String(now.getHours()).padStart(2, '0')
      const mm = String(now.getMinutes()).padStart(2, '0')
      const ss = String(now.getSeconds()).padStart(2, '0')
      const ms = String(now.getMilliseconds()).padStart(3, '0')
      return `${yyyy}${MM}${dd}_${hh}${mm}${ss}_${ms}`
    } catch (e) {
      LogUtil.errorForce(funcName, 'getTimestampForFilename failed: ' + e)
      return '1970-01-01'
    }
  }
  try {
    // 获取文件列表
    let files: string[] = []
    try {
      files = fs.listFileSync(logDir)
    } catch (e) {
      LogUtil.errorForce(funcName, 'listFileSync failed: ' + e)
    }
    if (!files || files.length === 0) { //目录下没有文件不能压缩，否则解压的时候会报错
      return result
    }
    const zipFilePath = zipDir + `/${getTimestampForFilename()}.zip`
    try {
      await zlib.compressFile(logDir, zipFilePath, {})
      return zipFilePath
    } catch (e) {
      LogUtil.errorForce(funcName, 'compressFile failed: ' + e)
      return result
    }
  } catch (e) {
    const err = e as BusinessError
    LogUtil.errorForce(
      funcName,
      'get log zip failed with error message: ' + err.message + ', error code: ' + err.code
    )
    return result
  }
}</code></pre><h4>3. 日志清理逻辑 (clearLog)</h4><p>日志清理任务用于删除日志和压缩目录：</p><ol><li>删除日志目录及其文件。</li><li>删除压缩目录及其文件。</li><li>使用 AsyncLock EXCLUSIVE 模式，确保清理操作不会与写入或压缩任务冲突。</li><li>异常通过 try/catch 捕获，保证任务安全和系统稳定。</li></ol><p>核心代码示例：</p><pre><code class="ts">// 清空日志（直接删除日志文件夹）
@Concurrent
export async function clearLog(ctx: Context) {
  if (!ctx) {
    return
  }
  const funcName = 'clearLog'
  const logPath = ctx.filesDir + LOG_DIR
  const zipPath = ctx.filesDir + LOG_ZIP_DIR
  try {
    await fs.rmdir(logPath)
  } catch (e) {
    const err = e as BusinessError
    LogUtil.errorForce(funcName,
      'unlink log dir failed with error message: ' + err?.message + ', error code: ' + err?.code)
  }
  try {
    await fs.rmdir(zipPath)
  } catch (e) {
    const err = e as BusinessError
    LogUtil.errorForce(funcName,
      'unlink log zip dir failed with error message: ' + err?.message + ', error code: ' + err?.code)
  }
}</code></pre><p>所有这些操作都在子线程执行，主线程保持流畅。</p><hr/><h3>六、Logger 与 SaveLog 的结合</h3><p>业务日志入口使用 <code>Logger.preLogContent()</code>：</p><pre><code class="ts">if (forceLog &amp;&amp; tag != "EventReport") {
  SaveLogHelper.saveLog(tag, JSON.stringify(content))
}</code></pre><p>当日志满足保存条件时，通过 SaveLogHelper 和 SpSaveLog 调用 TaskPool 异步执行日志操作。</p><hr/><h3>七、整体性能与并发策略总结</h3><table><thead><tr><th>目标</th><th>解决方案</th><th>实现</th></tr></thead><tbody><tr><td>避免主线程阻塞</td><td>TaskPool + @Concurrent</td><td>日志写入、压缩、清理都在子线程完成</td></tr><tr><td>防止文件冲突</td><td>AsyncLock + EXCLUSIVE</td><td>异步锁保证同一时间仅一个任务写日志</td></tr><tr><td>多任务同时写日志</td><td>TaskPool 自动调度</td><td>不同任务可并发执行互不干扰</td></tr><tr><td>内存 &amp; 线程安全</td><td>可序列化参数 + 非阻塞锁</td><td>官方推荐方式</td></tr></tbody></table><hr/><h3>八、最佳实践与优化建议</h3><ol><li><strong>控制 TaskPool 粒度</strong><br/>小任务不适合并发执行，避免线程切换开销。日志写入属于中等粒度任务，适合 TaskPool。</li><li><strong>锁的作用域尽量小</strong><br/><code>lockAsync()</code> 内仅包含关键写操作，避免耗时任务阻塞。</li><li><strong>完善错误处理</strong><br/>使用 <code>try...catch</code> 捕获文件系统异常，防止异步任务崩溃。</li><li><strong>精简上下文传递</strong><br/>仅传递必要字段（如 <code>filesDir</code>），减少序列化负担。</li></ol><hr/><h3>九、结语</h3><p>通过 TaskPool 并发机制和 AsyncLock 异步锁的结合，日志系统实现了高性能、线程安全和结构清晰的日志管理。在日志写入、获取压缩和清理任务中，EXCLUSIVE 锁保证了临界区操作的互斥，避免了文件冲突和数据损坏。通过子线程异步执行，主线程保持流畅响应。如下的时序图可以看到每个任务在请求锁、进入临界区、执行文件操作以及释放锁的完整流程，直观展示了锁占用和等待的场景：</p><p><img width="723" height="1317" referrerpolicy="no-referrer" src="/img/bVdmZ6j" alt="" title=""/></p><p>文笔不好，感谢大家在百忙之中抽出宝贵的时间来阅读本篇垃圾文章 😄。希望本文对各位理解TaskPool 、 AsyncLock或者业务需求有所帮助。如有改进点，欢迎提出~</p>]]></description></item><item>    <title><![CDATA[艾体宝干货 | Redis Python]]></title>    <link>https://segmentfault.com/a/1190000047388627</link>    <guid>https://segmentfault.com/a/1190000047388627</guid>    <pubDate>2025-11-11 12:10:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>前言</h2><p>继上篇文章，成功连接 Redis 之后，我们直面其核心：<strong>数据结构</strong>。Redis 的强大，绝非仅是简单的键值存储，而是其精心设计的多种数据结构所能解决的各种业务场景。</p><h3>本篇读者收益</h3><ul><li>精通 String 类型的全部核心命令，掌握其在缓存、计数器、分布式锁中的应用。</li><li>精通 Hash 类型的全部核心命令，掌握其高效存储对象、进行分组统计的技巧。</li><li>深刻理解 String 和 Hash 的底层差异与内存效率，能根据场景做出正确选择。</li><li>了解生产环境中使用这两种结构时的常见“坑”与最佳实践。</li></ul><h3>先修要求</h3><p>本文假设读者已掌握如何使用 redis-py 建立连接（详见系列第一篇）。</p><h3>关键要点</h3><ol><li>String 是万金油，可存文本、数字、序列化数据，INCR 命令是原子操作的典范。</li><li>Hash 适合存储对象，能单独操作字段，内存效率更高（使用 ziplist 编码时）。</li><li>MSET/MGET 和 HMSET（已弃用，用 HSET 替代）/HMGET 是提升批量操作性能的关键。</li><li>选择 String 还是 Hash 存储对象，是一场 序列化开销 vs 字段管理复杂度 的权衡。</li></ol><h2>背景与原理简述</h2><p>Redis 提供了五种核心数据结构，本篇聚焦最基础也最常用的两种：<strong>String（字符串）</strong>  和 <strong>Hash（哈希散列）</strong> 。</p><ul><li><strong>String</strong>: 最简单的类型，一个 Key 对应一个 Value。虽然是字符串，但可以存储任何二进制安全的数据，包括图片、序列化后的对象等。它是实现其他复杂功能的基石。</li><li><strong>Hash</strong>: 一个 Key 对应一个 Field-Value 的映射表。非常适合用来存储对象（如用户信息、商品属性），你可以单独获取、更新对象的某个字段，而无需操作整个对象。</li></ul><p>理解它们的底层实现和适用场景，是写出高效 Redis 应用的关键。</p><h2>环境准备与快速上手</h2><p>假设阅读本篇时你已安装 redis-py 并能够成功连接 Redis 服务器。本篇所有示例将基于以下连接客户端展开：</p><pre><code># filename: setup.py
import os
import redis
from redis import Redis

# 使用连接池创建客户端（推荐方式，详见第一篇文章）
pool = redis.ConnectionPool(
    host=os.getenv('REDIS_HOST', 'localhost'),
    port=int(os.getenv('REDIS_PORT', 6379)),
    password=os.getenv('REDIS_PASSWORD'), # 若无密码可注释此行
    decode_responses=True, # 自动解码，省去 .decode()
    max_connections=10
)
r = Redis(connection_pool=pool)

# 简单的连接测试
assert r.ping() is True
print("连接成功，开始操作 String 和 Hash！")</code></pre><h2>核心用法与代码示例</h2><h3>String (字符串) 操作</h3><h4>基本操作与应用场景</h4><pre><code># filename: string_operations.py
def string_basic_operations():
    """String 基本操作：缓存、存值、取值"""
    # 1. 简单设置与获取 (SET/GET)
    # 应用场景：简单缓存、存储配置项
    r.set('username', 'alice')
    username = r.get('username')  # 返回 'alice' (因为设置了 decode_responses=True)
    print(f"Username: {username}")

    # 2. 设置过期时间 (SETEX)
    # 应用场景：手机验证码、临时会话、限时优惠券
    r.setex('sms_code:13800138000', 300, '123456')  # 300秒后自动过期
    code = r.get('sms_code:13800138000')
    print(f"SMS Code: {code}")
    ttl = r.ttl('sms_code:13800138000')  # 查看剩余生存时间
    print(f"TTL: {ttl} seconds")

    # 3. 仅当键不存在时设置 (SETNX)
    # 应用场景：分布式锁、首次初始化
    success = r.setnx('initialized', 'true')
    if success:
        print("系统初始化标记设置成功！")
    else:
        print("系统已初始化过。")

    # 4. 批量操作 (MSET/MGET) - 大幅减少网络往返
    # 应用场景：批量初始化配置、批量获取用户状态
    r.mset({"config:theme": "dark", "config:language": "zh-CN", "config:notifications": "on"})
    configs = r.mget(["config:theme", "config:language", "config:notifications"])
    print(f"Batch configs: {configs}")  # ['dark', 'zh-CN', 'on']

# 运行示例
string_basic_operations()</code></pre><h4>数值操作与应用场景</h4><pre><code># filename: string_counter.py
def string_counter_operations():
    """String 数值操作：计数器"""
    # 初始化一个计数器
    r.set('page_views', 0)

    # 1. 递增 (INCR/INCRBY)
    # 应用场景：文章阅读量、用户点赞数、秒杀库存
    new_views = r.incr('page_views')  # +1，返回 1
    new_views = r.incr('page_views')  # +1，返回 2
    new_views = r.incrby('page_views', 10)  # +10，返回 12
    print(f"Page views: {new_views}")

    # 2. 递减 (DECR/DECRBY)
    # 应用场景：扣减库存、撤销操作
    stock = r.decrby('product:1001:stock', 5)  # 扣减5个库存
    print(f"Current stock: {stock}")

    # 3. 浮点数操作 (INCRBYFLOAT)
    # 应用场景：金额、分数、权重
    r.set('account:balance', 100.5)
    new_balance = r.incrbyfloat('account:balance', 20.8)  # 增加 20.8
    print(f"New balance: {new_balance}")  # 121.3

# 运行示例
string_counter_operations()</code></pre><h3>Hash (哈希散列) 操作</h3><h4>基本操作与应用场景</h4><pre><code># filename: hash_operations.py
def hash_basic_operations():
    """Hash 基本操作：对象存储"""
    user_id = 1001

    # 1. 设置和获取字段 (HSET/HGET)
    # 应用场景：存储对象属性
    r.hset(f'user:{user_id}', 'name', 'Alice')
    r.hset(f'user:{user_id}', 'email', 'alice@example.com')
    user_name = r.hget(f'user:{user_id}', 'name')
    print(f"User name: {user_name}")

    # 2. 批量设置和获取字段 (HMSET is deprecated, use HSET with mapping)
    # 应用场景：一次性设置或获取对象的所有属性
    user_data = {
        'age': '30', # Note: Hash field values are always strings
        'city': 'Beijing',
        'occupation': 'Engineer'
    }
    r.hset(f'user:{user_id}', mapping=user_data) # 批量设置

    # 批量获取多个字段
    fields = ['name', 'email', 'age', 'city']
    user_info = r.hmget(f'user:{user_id}', fields)
    print(f"User info (list): {user_info}") # ['Alice', 'alice@example.com', '30', 'Beijing']

    # 3. 获取所有字段和值 (HGETALL)
    # 小心使用！如果Hash很大，可能会阻塞服务器或消耗大量网络带宽。
    all_user_data = r.hgetall(f'user:{user_id}')
    print(f"All user data (dict): {all_user_data}") # {'name': 'Alice', 'email': 'alice@example.com', ...}

    # 4. 获取所有字段名或值 (HKEYS/HVALS)
    field_names = r.hkeys(f'user:{user_id}')
    field_values = r.hvals(f'user:{user_id}')
    print(f"Field names: {field_names}")
    print(f"Field values: {field_values}")

    # 5. 判断字段是否存在 (HEXISTS) 和 删除字段 (HDEL)
    if r.hexists(f'user:{user_id}', 'email'):
        print("Email field exists.")
    r.hdel(f'user:{user_id}', 'occupation') # 删除一个字段
    print(f"Fields after deletion: {r.hkeys(f'user:{user_id}')}")

# 运行示例
hash_basic_operations()</code></pre><h4>数值操作与应用场景</h4><pre><code># filename: hash_counter.py
def hash_counter_operations():
    """Hash 字段的数值操作"""
    product_id = 2001
    key = f'product:{product_id}'

    # 初始化
    r.hset(key, 'price', '99.9')
    r.hset(key, 'views', '0')

    # 哈希字段的递增递减 (HINCRBY/HINCRBYFLOAT)
    # 应用场景：商品价格调整、独立计数器（如商品浏览量）
    new_views = r.hincrby(key, 'views', 1) # 整数字段 +1
    new_price = r.hincrbyfloat(key, 'price', -10.5) # 浮点字段 -10.5
    print(f"Product views: {new_views}, New price: {new_price}")

# 运行示例
hash_counter_operations()</code></pre><h2>性能优化与容量规划</h2><h3>String vs. Hash：如何选择？</h3><p>存储对象时这是一个常见的设计决策。其实对于 Redis 上的对象存储，更推荐使用 RedisJSON 拓展进行直接存储，当然这不在本篇的讨论范围内，就 String 与 Hash 的选用上，给出参考如下。</p><h4>使用 String (存储 JSON):</h4><pre><code>import json
user_data = {'name': 'Alice', 'age': 30, 'city': 'Beijing'}
# 写入
r.set('user:1001', json.dumps(user_data))
# 读取（无法部分更新，必须读取整个对象）
data = json.loads(r.get('user:1001'))</code></pre><ul><li><strong>优点</strong>: 简单直观，可利用 JSON 的复杂结构。</li><li><strong>缺点</strong>: <strong>无法原子性地更新单个字段</strong>。每次修改任何属性都需要序列化并写入整个对象，网络和CPU开销大。读取任何属性也需反序列化整个对象。</li></ul><h4>使用 Hash (存储字段):</h4><pre><code># 写入
r.hset('user:1001', mapping={'name': 'Alice', 'age': '30', 'city': 'Beijing'})
# 读取单个字段（高效）
name = r.hget('user:1001', 'name')
# 更新单个字段（原子高效）
r.hset('user:1001', 'age', '31')</code></pre><ul><li><strong>优点</strong>: 可以<strong>原子性地、独立地</strong>访问和修改每个字段，非常高效。内存优化更好（使用 ziplist 编码时）。</li><li><strong>缺点</strong>: 无法直接存储嵌套结构，字段值只能是字符串。</li></ul><p>对于需要频繁部分读写、字段较多的<strong>扁平化对象</strong>（如用户配置、商品属性），<strong>Hash 是更优选择</strong>。对于读写不频繁或结构复杂嵌套的对象，String + JSON 也是一种可选方案。</p><h3>内存优化：ziplist 编码</h3><p>Redis 在存储小的 Hash 时，会使用一种叫 ziplist（压缩列表） 的紧凑编码，这比使用标准的哈希表更节省内存。当以下两个配置阈值被突破时，编码会转换为 hashtable：</p><ul><li><code>hash-max-ziplist-entries</code>： Hash 中字段数量的阈值（默认 512）。</li><li><code>hash-max-ziplist-value</code>： 每个字段值的最大长度阈值（默认 64 字节）。</li></ul><p>最佳实践：根据你的业务数据特点，在 redis.conf 中适当调整这两个参数，可以在内存和性能之间取得更好的平衡。</p><h3>批量操作</h3><p>无论是 String 的 MSET/MGET 还是 Hash 的 HMSET(已弃用)/HMGET，<strong>批量操作都能极大减少网络往返次数（RTT）</strong> ，是提升性能的最有效手段之一。</p><h2>安全与可靠性</h2><ol><li><strong>大 Key 风险</strong>: 避免使用一个巨大的 String（通常超过 10KB 被定义为 Big Key）或一个包含成千上万个字段的 Hash。这类 Key 在持久化、迁移、删除时可能会阻塞 Redis 服务。对 Hash，定期检查 HLEN。</li><li><p><strong>命令复杂度</strong>:</p><ul><li>HGETALL、HKEYS、HVALS 这些 O(n) 复杂度的命令，在 Hash 很大时会非常慢，<strong>在生产环境中应谨慎使用</strong>。优先使用 HGET 或 HMGET 获取你真正需要的字段。</li><li><code>KEYS *</code> 是 O(n) 且会阻塞服务，<strong>绝对禁止在生产环境使用</strong>。使用 SCAN 命令族进行增量迭代（后续文章会详述）。</li></ul></li></ol><h2>常见问题与排错</h2><ul><li><code>redis.exceptions.DataError</code>： 尝试对非数字值的 String 或 Hash 字段执行 INCR 等操作。确保操作前值是数字或键不存在。</li><li>字段值类型错误： Hash 的字段值<strong>总是字符串</strong>。存储数字后，取回来也是字符串形式（如 '30'），需要客户端自己转换（<code>int()</code>, <code>float()</code>）。</li><li>HGETALL 返回类型**： 在 redis-py 中，HGETALL 返回的是一个 Python dict，但在其他一些客户端中可能返回列表。</li><li><p>内存增长过快：</p><ul><li>检查是否滥用 String 存储了大对象。</li><li>检查 Hash 的字段数量是否过多，考虑是否可用多个 Hash 进行分片。</li></ul></li></ul><h2>实战案例/最佳实践</h2><h3>案例：用户会话（Session）存储</h3><pre><code># filename: session_manager.py
import uuid
import time

class SessionManager:
    def __init__(self, redis_client):
        self.r = redis_client

    def create_session(self, user_id, user_agent, **extra_data):
        """创建一个新的用户会话（使用Hash存储）"""
        session_id = str(uuid.uuid4())
        session_key = f'session:{session_id}'
        session_data = {
            'user_id': str(user_id),
            'user_agent': user_agent,
            'created_at': str(time.time()),
            'last_activity': str(time.time()),
            **extra_data
        }
        # 使用Hash存储会话数据，并设置30分钟过期
        self.r.hset(session_key, mapping=session_data)
        self.r.expire(session_key, 30 * 60) # 30分钟TTL
        return session_id

    def get_session(self, session_id):
        """获取会话信息（只获取需要的字段，避免使用HGETALL）"""
        session_key = f'session:{session_id}'
        # 高效地获取特定字段，而不是全部
        user_id = self.r.hget(session_key, 'user_id')
        if not user_id:
            return None # Session不存在或已过期

        # 更新最后活动时间
        self.r.hset(session_key, 'last_activity', str(time.time()))
        self.r.expire(session_key, 30 * 60) # 刷新过期时间

        # 按需获取其他字段
        user_agent = self.r.hget(session_key, 'user_agent')
        # ... 获取其他需要的字段
        return {'user_id': user_id, 'user_agent': user_agent}

    def update_session_field(self, session_id, field, value):
        """更新会话的单个字段（Hash的优势）"""
        session_key = f'session:{session_id}'
        self.r.hset(session_key, field, value)
        self.r.expire(session_key, 30 * 60) # 刷新过期时间

# 使用示例
session_mgr = SessionManager(r)
sid = session_mgr.create_session(1001, 'Mozilla/5.0', theme='dark')
session_data = session_mgr.get_session(sid)
print(session_data)</code></pre><h2>小结</h2><p>String 和 Hash 是 Redis 最基础、最常用的两种数据结构。String 灵活万能，是缓存和计数器的首选；Hash 字段独立，是存储扁平化对象、实现高效部分更新的最佳选择。</p>]]></description></item><item>    <title><![CDATA[得物TiDB升级实践 得物技术 ]]></title>    <link>https://segmentfault.com/a/1190000047388649</link>    <guid>https://segmentfault.com/a/1190000047388649</guid>    <pubDate>2025-11-11 12:09:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、背 景</h2><p>得物DBA自2020年初开始自建TiDB，5年以来随着NewSQL数据库迭代发展、运维体系逐步完善、产品自身能力逐步提升，接入业务涵盖了多个业务线和关键场景。从第一套TIDB v4.0.9 版本开始，到后来v4.0.11、v5.1.1、v5.3.0，在经历了各种 BUG 踩坑、问题调试后，最终稳定在 TIDB 5.3.3 版本。伴随着业务高速增长、数据量逐步增多，对 TiDB 的稳定性及性能也带来更多挑战和新的问题。为了应对这些问题，DBA团队决定对 TiDB 进行一次版本升级，收敛版本到7.5.x。本文基于内部的实践情况，从架构、新特性、升级方案及收益等几个方向讲述 TiDB 的升级之旅。</p><h2>二、TiDB 架构</h2><p>TiDB 是分布式关系型数据库，高度强兼容 MySQL 协议和 MySQL 生态，稳定适配 MySQL 5.7 和MySQL 8.0常用的功能及语法。随着版本的迭代，TiDB 在弹性扩展、分布式事务、强一致性基础上进一步针对稳定性、性能、易用性等方面进行优化和增强。与传统的单机数据库相比，TiDB具有以下优势：</p><ul><li>分布式架构，拥有良好的扩展性，支持对业务透明灵活弹性的扩缩容能力，无需分片键设计以及开发运维。</li><li>HTAP 架构支撑，支持在处理高并发事务操作的同时，对实时数据进行复杂分析，天然具备事务与分析物理隔离能力。</li><li>支持 SQL 完整生态，对外暴露 MySQL 的网络协议，强兼容 MySQL 的语法/语义，在大多数场景下可以直接替换 MySQL。</li><li>默认支持自愈高可用，在少数副本失效的情况下，数据库本身能够自动进行数据修复和故障转移，对业务无感。</li><li>支持 ACID 事务，对于一些有强一致需求的场景友好，满足 RR 以及 RC 隔离级别，可以在通用开发框架完成业务开发迭代。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388651" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><p>我们使用 SLB 来实现 TiDB 的高效负载均衡，通过调整 SLB 来管理访问流量的分配以及节点的扩展和缩减。确保在不同流量负载下，TiDB 集群能够始终保持稳定性能。在 TiDB 集群的部署方面，我们采用了单机单实例的架构设计。TiDB Server 和 PD Server 均选择了无本地 SSD 的机型，以优化资源配置，并降低开支。TiKV Server则配置在本地 SSD 的机型上，充分利用其高速读写能力，提升数据存储和检索的性能。这样的硬件配置不仅兼顾了系统的性能需求，又能降低集群成本。针对不同的业务需求，我们为各个组件量身定制了不同的服务器规格，以确保在多样化的业务场景下，资源得到最佳的利用，进一步提升系统的运行效率和响应速度。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388652" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h2>三、TiDB v7 版本新特性</h2><p>新版本带来了更强大的扩展能力和更快的性能，能够支持超大规模的工作负载，优化资源利用率，从而提升集群的整体性能。在 SQL 功能方面，它提升了兼容性、灵活性和易用性，从而助力复杂查询和现代应用程序的高效运行。此外，网络 IO 也进行了优化，通过多种批处理方法减少网络交互的次数，并支持更多的下推算子。同时，优化了Region 调度算法，显著提升了性能和稳定性。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388653" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h2>四、TiDB升级之旅</h2><p><strong>4.1 当前存在的痛点</strong></p><ul><li><strong>集群版本过低</strong>：当前 TiDB 生产环境（现网）最新版本为 v5.3.3，目前官方已停止对 4.x 和 5.x 版本的维护及支持，TiDB 内核最新版本为 v8.5.3，而被用户广泛采用且最为稳定的版本是 v7.5.x。</li><li><strong>TiCDC组件存在风险</strong>：TiCDC 作为增量数据同步工具，在 v6.5.0 版本以前在运行稳定性方面存在一定问题，经常出现数据同步延迟问题或者 OOM 问题。</li><li><strong>备份周期时间长</strong>：集群每天备份时间大于8小时，在此期间，数据库备份会导致集群负载上升超过30%，当备份时间赶上业务高峰期，会导致应用RT上升。</li><li><strong>集群偶发抖动及BUG</strong>：在低版本集群中，偶尔会出现基于唯一键查询的慢查询现象，同时低版本也存在一些影响可用性的BUG。比如在 TiDB v4.x 的集群中，TiKV 节点运行超过 2 年会导致节点自动重启。</li></ul><p><strong>4.2 升级方案：升级方式</strong></p><p>TiDB的常见升级方式为原地升级和迁移升级，我们所有的升级方案均采用迁移升级的方式。</p><p><strong>原地升级</strong></p><ul><li><strong>优势</strong>：方式较为简单，不需要额外的硬件，升级过程中集群仍然可以对外提供服务。</li><li><strong>劣势</strong>：该升级方案不支持回退、并且升级过程会有长时间的性能抖动。大版本（v4/v5 原地升级到 v7）跨度较大时，需要版本递增升级，抖动时间翻倍。</li></ul><p><strong>迁移升级</strong></p><ul><li><strong>优势</strong>：业务影响时间较短、可灰度可回滚、不受版本跨度的影响。</li><li><strong>劣势</strong>：搭建新集群将产生额外的成本支出，同时，原集群还需要部署TiCDC组件用于增量同步。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388654" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><strong>4.3 升级方案：集群调研</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388655" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><strong>4.4 升级方案：升级前准备环境</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388656" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><strong>4.5 升级方案：升级前验证集群</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388657" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><strong>4.6 升级方案：升级中流量迁移</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388658" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><strong>4.7 升级方案：升级后销毁集群</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388659" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h2>五、升级遇到的问题</h2><p><strong>5.1 v7.5.x版本查询SQL倾向全表扫描</strong></p><p>表中记录数 215亿，查询 SQL存在合理的索引，但是优化器更倾向走全表扫描，重新收集表的统计信息后，执行计划依然为全表扫描。</p><p>走全表扫描执行60秒超时KILL，强制绑定索引仅需0.4秒。</p><pre><code>-- 查询SQL
SELECT
  *
FROM
  fin_xxx_xxx
WHERE
  xxx_head_id = 1111111111111111
  AND xxx_type = 'XX0002'
  AND xxx_user_id = 11111111
  AND xxx_pay_way = 'XXX00000'
  AND is_del IN ('N', 'Y')
LIMIT
  1;


-- 涉及索引
KEY `idx_xxx` (`xxx_head_id`,`xxx_type`,`xxx_status`),</code></pre><p><strong>解决方案：</strong></p><ul><li>方式一：通过 SPM 进行 SQL 绑定。</li><li>方式二：调整集群参数 tidb_opt_prefer_range_scan，将该变量值设为 ON 后，优化器总是偏好区间扫描而不是全表扫描。</li></ul><p><a href="https://link.segmentfault.com/?enc=YV0aMy2H5yz4e7zrARCn2g%3D%3D.3pups54UgJ4%2F5rAggqdghTyxZcjPmLxfJX0N1eKQEXa3BtoFbNeNPN%2Flt6A6RvNS" rel="nofollow" target="_blank">https://asktug.com/t/topic/1047626</a></p><p><strong>5.2 v7.5.x版本聚合查询执行计划不准确</strong></p><p>集群升级后，在新集群上执行一些聚合查询或者大范围统计查询时无法命中有效索引。而低版本v4.x、5.x集群，会根据统计信息选择走合适的索引。</p><p>v4.0.11集群执行耗时：12秒，新集群执行耗时2分32.78秒</p><pre><code>-- 查询SQL
select 
    statistics_date,count(1) 
from 
    merchant_assessment_xxx 
where 
    create_time between '2025-08-20 00:00:00' and '2025-09-09 00:00:00' 
group by 
    statistics_date order by statistics_date;


-- 涉及索引
KEY `idx_create_time` (`create_time`)</code></pre><p><strong>解决方案：</strong></p><p>方式一：调整集群参数tidb_opt_objective，该变量设为 determinate后，TiDB 在生成执行计划时将不再使用实时统计信息，这会让执行计划相对稳定。</p><p><a href="https://link.segmentfault.com/?enc=OokQs5QUmu2bkn%2FQwBJ3qQ%3D%3D.Vlcl4Ls%2FRGgq0zXk32P8nFPOIiXzQ5dWxpSd6UaWzMKRs6tNlLgZLkgYIluBZKBy" rel="nofollow" target="_blank">https://asktug.com/t/topic/1046610</a></p><h2>六、升级带来的收益</h2><p><strong>版本升级稳定性增强</strong>：v7.5.x 版本的 TiDB 提供了更高的稳定性和可靠性，高版本改进了SQL优化器、增强的分布式事务处理能力等，加快了响应速度和处理大量数据的能力。升级后相比之前整体性能提升40%。特别是在处理复杂 SQL 和多索引场景时，优化器的性能得到了极大的增强，减少了全表扫描的发生，从而显著降低了 TiKV 的 CPU 消耗和 TiDB 的内存使用。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388660" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><strong>提升TiCDC同步性能</strong>：新版本在数据同步方面有了数十倍的提升，有效解决了之前版本中出现的同步延迟问题，提供更高的稳定性和可靠性。当下游需要订阅数据至数仓或风控平台时，可以使用TiCDC将数据实时同步至Kafka，提升数据处理的灵活性与响应能力。</p><p><strong>缩短备份时间</strong>：数据库备份通常会消耗大量的CPU和IO资源。此前，由于备份任务的结束时间恰逢业务高峰期，经常导致应用响应时间（RT）上升等问题。通过进行版本升级将备份效率提升了超过50%。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388661" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><strong>高压缩存储引擎</strong>：新版本采用了高效的数据压缩算法，能够显著减少存储占用。同时，通过优化存储结构，能够快速读取和写入数据，提升整体性能。相同数据在 TiDB 中的存储占用空间更低，iDB 的3副本数据大小仅为 MySQL（主实例数据大小）的 55%。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388662" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p><strong>完善的运维体验</strong>：新版本引入更好的监控工具、更智能的故障诊断机制和更简化的运维流程，提供了改进的 Dashboard 和 Top SQL 功能，使得慢查询和问题 SQL 的识别更加直观和便捷，降低 DBA 的工作负担。</p><p><strong>更秀更实用的新功能</strong>：TiDB 7.x版本提供了TTL定期自动删除过期数据，实现行级别的生命周期控制策略。通过为表设置 TTL 属性，TiDB 可以周期性地自动检查并清理表中的过期数据。此功能在一些场景可以有效节省存储空间、提升性能。TTL 常见的使用场景：</p><ul><li>定期删除验证码、短网址记录</li><li>定期删除不需要的历史订单</li><li>自动删除计算的中间结果</li></ul><p><a href="https://link.segmentfault.com/?enc=SG8dVpMIDXUKLTyhVYp6PQ%3D%3D.2LevRcCWT7lNjARz122RXMg6H6HJdYDkrLMixR%2BLpyA2e9DF4UQpTEEOnYdB5YorqEKE75wIYqGHNqL9K2ahJQ%3D%3D" rel="nofollow" target="_blank">https://docs.pingcap.com/zh/tidb/v7.5/time-to-live/</a></p><h2>七、选择 TiDB 的原因</h2><p>我们不是为了使用TiDB而使用，而是去解决一些MySQL无法满足的场景，关系型数据库我们还是优先推荐MySQL。能用分库分表能解决的问题尽量选择MySQL，毕竟运维成本相对较低、数据库版本更加稳定、单点查询速度更快、单机QPS性能更高这些特性是分布式数据库无法满足的。</p><ul><li><strong>非分片查询场景</strong>：上游 MySQL 采用了分库分表的设计，但部分业务查询无法利用分片。通过自建 DTS 将 MySQL 数据同步到 TiDB 集群，非分片/聚合查询则使用 TiDB 处理，能够在不依赖原始分片结构的情况下，实现高效的数据查询和分析。</li><li><strong>分析 SQL 多场景</strong>：业务逻辑比较复杂，往往存在并发查询和分析查询的需求。通过自建 DTS 将 MySQL 数据同步到 TiDB，复杂查询在TiDB执行、点查在MySQL执行。TiDB支持水平扩展，其分布式计算和存储能力使其能够高效处理大量的并发查询请求。既保障了MySQL的稳定性，又提升了整体的查询能力。</li><li><strong>磁盘使用大场景</strong>：在磁盘使用率较高的情况下，可能会出现 CPU 和内存使用率低，但磁盘容量已达到 MySQL 的瓶颈。TiDB 能够自动进行数据分片和负载均衡，将数据分布在多个节点上， 缓解单一节点的磁盘压力，避免了传统 MySQL 中常见的存储瓶颈问题，从而提高系统的可扩展性和灵活性。</li><li><strong>数据倾斜场景</strong>：在电商业务场景上，每个电商平台都会有一些销量很好的头部卖家，数据量会很大。即使采取了进行分库分表的策略，仍难以避免大卖家的数据会存储在同一实例中，这样会导致热点查询和慢 SQL 问题，尽管可以通过添加索引或进一步分库分表来优化，但效果有限。采用分布式数据库能够有效解决这一问题。可以将数据均匀地分散存储在多个节点上，在查询时则能够并发执行，从而将流量分散，避免热点现象的出现。随着业务的快速发展和数据量的不断增长，借助简单地增加节点，即可实现水平扩展，满足海量数据及高并发的需求。</li></ul><h2>八、总结</h2><p>综上所述，在本次 TiDB 集群版本升级到 v7.5.x 版本过程中，实现了性能和稳定性提升。通过优化的查询计划和更高效的执行引擎，数据读取和写入速度显著提升，大幅度降低了响应延迟，提升了在高并发操作下的可靠性。通过直观的监控界面和更全面的性能分析工具，能够更快速地识别和解决潜在问题，降低 DBA 的工作负担。也为未来的业务扩展和系统稳定性提供了强有力的支持。</p><p>后续依然会持续关注 TiDB 在 v8.5.x 版本稳定性、性能以及新产品特性带来应用开发以及运维人效收益进展。目前 TiDB 内核版本 v8.5.x 已经具备多模数据库 Data + AI 能力，在JSON函数、ARRAY 索引以及 Vector Index 实现特性。同时已经具备 Resource Control 资源管理能力，适合进行多业务系统数据归集方案，实现数据库资源池化多种自定义方案。技术研究方面我们数据库团队会持续投入，将产品最好的解决方案引入现网环境。</p><h2>往期回顾</h2><ol><li>得物管理类目配置线上化：从业务痛点到技术实现</li><li>大模型如何革新搜索相关性？智能升级让搜索更“懂你”｜得物技术</li><li>RAG—Chunking策略实战｜得物技术</li><li>告别数据无序：得物数据研发与管理平台的破局之路</li><li>从一次启动失败深入剖析：Spring循环依赖的真相｜得物技术</li></ol><h2>文 /岱影</h2><p>关注得物技术，每周更新技术干货</p><p>要是觉得文章对你有帮助的话，欢迎评论转发点赞～</p><p>未经得物技术许可严禁转载，否则依法追究法律责任。</p>]]></description></item><item>    <title><![CDATA[阿里巴巴 AI Coding 分享会 —]]></title>    <link>https://segmentfault.com/a/1190000047388690</link>    <guid>https://segmentfault.com/a/1190000047388690</guid>    <pubDate>2025-11-11 12:08:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <ul><li>时间：11 月 16 日</li><li>地点：广州阿里中心</li></ul><p>一场专属于开发者与 AI 编程爱好者的线下聚会！</p><p>🔹 与 Qoder 技术团队面对面，聊聊产品的深入解析和应用</p><p>🔹 听资深用户分享使用 Qoder 的实战经验与技巧</p><p>🔹 现场 AI Coding 黑客松，一起体验智能编程的新范式，边写边学边碰撞</p><p>无论你是好奇 AI 编程的新手，还是深度玩家，这里都有你的位置！</p><p>现场还有惊喜彩蛋 &amp; 限量周边等你来拿～</p><p><strong>点击下方链接立即报名</strong>：</p><p><a href="https://link.segmentfault.com/?enc=f8ZQCEtJupWowEjoybao1A%3D%3D.ucefKOdnrxQwGbG3dZFlv%2BVAz9wEUPkkahkNNBHJ8IwnalNsa2hk6oAOIPqnZNay" rel="nofollow" target="_blank">https://www.huodongxing.com/event/8832377969300</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388692" alt="image" title="image"/></p>]]></description></item><item>    <title><![CDATA["答开发者问"之HarmonyOS技术问]]></title>    <link>https://segmentfault.com/a/1190000047388710</link>    <guid>https://segmentfault.com/a/1190000047388710</guid>    <pubDate>2025-11-11 12:07:53</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文原创发布在<a href="https://link.segmentfault.com/?enc=OMT6sb4U6nwriUg76B0pnA%3D%3D.elpKHLyJa2MAP67uH7rnsKtOPHOVLUm0ExBq5uafAzqZRrGGlBln162dfYfFGyI%2FcuZtGnOLTpCzsyEgFCpphvp0IZPtpBFmXE7Oi4RN%2BlSFvJJQOpuh7SOt5A42Q1zw" rel="nofollow" target="_blank">华为开发者联盟社区</a>，欢迎前往与更多开发者进行互动。  </p><p>更多相关问题可点击原帖进行交流：<a href="https://link.segmentfault.com/?enc=aevjn2zCIrpnArOZeT2oTg%3D%3D.kvDQBVkmHVoWmQTBbq5aWKhecus796f6xEvjLHVHdL%2BuJMIHrwMFSCUZq1U52cc6bj%2BXvH2aNohHUX%2B52OzXGbTomVyBhoG1%2BH0sydQxIOwnFjfxcdy6QAvzImUQHUqWvRaB%2Bsj3Jx%2BcE%2B0sfkKbrcc8S45flw8ai8kEOPSN2q8hqDNd%2FNbu0T6gURFHt1zy" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 系列汇总（持续更新中...）</a>。</p><p>HarmonyOS开发者小伙伴们，我们深知在探索鸿蒙开发的旅途中，每一个疑问都可能是前行的绊脚石。因此，我们特别推出了"答开发者问"系列帖，定期筛选社区中典型优质问题贴进行汇总。在这里，不仅有鸿蒙官方技术支持团队提供的答复，更有来自社区众多热心开发者的方案贡献，他们以实际行动诠释了"众人拾柴火焰高"的真谛。自第8期开始，"答开发者问"系列每期会筛选社区热心开发者答复的优质案例进行展示。</p><p>在此，我们由衷地感谢每一位热心参与、乐于分享的开发者，是你们的热情与智慧，让这个社区充满了生机与活力，每一次的解答都是对技术探索精神的最好诠释。同时，我们也诚挚邀请更多的开发者加入到这场智慧碰撞的盛宴中来。无论是抛出难题寻求解答，还是慷慨解囊分享经验，您的每一份参与都将为鸿蒙开发者社区注入新的活力，推动我们共同前行，在技术的海洋中扬帆远航。</p><p>请持续关注我们的"答开发者问"系列帖，我们会定期更新内容，助开发者一臂之力。让我们携手共进，共创鸿蒙开发的辉煌未来！</p><h3>链接直达问题详情及解析</h3><h4><a href="https://link.segmentfault.com/?enc=7dfAkZiN5mJ4ebwohwzvVg%3D%3D.mD6aEOaGFi5l1%2BWmZXSxuH%2FpiHJ%2FVgISqG%2FESmfJ%2BAxDtfVlkeI786zjRJ1WPcV%2BBRkp8pRRosdJPOcJjXuo8mBuPi5VphBzEZ%2BO%2Bo6hpEsU9ZdH236uX9X%2BL4xJQ2Bpew3Oyqtt7%2FDWE654Z2VyOvnvxcVCWV0WHHh3DaUMthfodfn1DswUGP16I1Fvg55p" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第17期</a></h4><p><a href="https://link.segmentfault.com/?enc=iGyj3X%2BzCOnD7uswSLdIAg%3D%3D.HP6JXBpNmImsLAy3%2F2gemtM6bFP3X1I%2BePrxnTEhdPhJ1uXSEm7mnsCV55xAyJDP9WSYBVhCd7pMc9NgMAzfG%2FBZTWldDNSCjQkEuiBtV33LoT2V4bdO%2F09AyLwtNpZQuJPMBOUSJSqCEkJniIxRBIwrvXZA1QUCd%2BSrUmFm24qp9Difm2sq93qIJb%2Fn47zH" rel="nofollow" target="_blank">1、如何实现在Web中监控到跳转指定url时拦截跳转并新建一个Web？</a></p><p><a href="https://link.segmentfault.com/?enc=N%2Btjp1vpF72a7EpppuGbgg%3D%3D.Y%2Bte70uQovzh2wLjPswDK6aVbRSHAYKOE6ThFHxBzMEM4oSD2uuhu5c72VSx6cumbZeCglSSJu2BVJLq%2FA2MLu1KCozJEvZnxgPT3Un3Jr01puCn1eu3OWoIcHwc12wajj07m2uRRgUxqeY55ijZwqxO7JlNgbf3taxPSFAP9jP1c1Yck4fHMpd57tXgM6wz" rel="nofollow" target="_blank">2、调用http的destroy()方法后仍然收到回调？</a></p><p><a href="https://link.segmentfault.com/?enc=c10a8rgk7unP1bRshKTuwA%3D%3D.9ynPTuiYqOtRkcKijsqcsHGWhfpm0FyCKJUMV2Zv5DkkwTwpjHXb9z52rRffsDI0QFTBudVy3xNohzafBnKwnh2ou9qubPNI%2Fanuie%2B%2FntlWAI%2FSuHXNo06QencVThCzjpx8SWCmbI22RTpNkDC8UVNwKaU4xuqQprntfAMMU8h%2FYUKEXBP1Pm17sfNfwiKN" rel="nofollow" target="_blank">3、Navigation组件怎么设置顶部动态模糊效果？</a></p><p><a href="https://link.segmentfault.com/?enc=vdYsdSxaVKx8QmsajsO0vQ%3D%3D.VfrmSuu%2FGEZZOMj97ZQIqqLC08PMhvAYkz6kJsTIB%2BweJ6r5L23Nk8g4VZ40YE02daL4Wx%2BQrRUBkjw6xUQqnkrwdCSiZPDNEQOxAVYoUxyIGCSB%2BEadNsI8y%2BDLFacbHlw0jLsYqjLdI%2FqenflewKh7Vah3vFjiXaGO3ysDR2LzIA0ylZgxPnS0zVZPEg4x" rel="nofollow" target="_blank">4、resourceManager.getRawFileContentSync后面的路径怎么写？</a></p><p><a href="https://link.segmentfault.com/?enc=5JwNZJgSds7AdMG47LbbZA%3D%3D.9s3bGx8fxZymEgrYkcS6S4sGkHdf0%2Bt4OXolme8q6EBfSmJsQLVv7C6jCuNkr0cteiKLCmL%2FDM6A03TsloW%2FlsAo1YemofSCkX%2F0oAM2pV%2BpPkdbNHl%2Fjl0OI6Rkv8hw1woyQvGFpE8HZSVR2G8Sb4sX8ZbOSA%2FCf%2FNQLrZItHJhHipvw1g435bWGi9J%2FqRM" rel="nofollow" target="_blank">5、蓝牙access.enableBluetooth()拉起询问界面时如何感知用户操作对话框的行为？</a></p><h4><a href="https://link.segmentfault.com/?enc=BmVqjBkY07IvyvukZ9rwAA%3D%3D.4mKfvWt3%2FtrPfN11%2B8s85gUGqZGryNKyQZFRfPDZFtBybib9W2H%2FvXixnq3Vuz2lzeUZYQSaHfczonweqsKXDrRwiG5SvdIYfbfBa8kw30kmnh6xH7wMdUUBJfKf5Z5GEUpGHNUSFhVZgWnB7Vpa6%2Ba5BkIEPA7%2FOT7Hr3qZPoPQwKPGJBZtSRQMOveDS4LP" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第16期</a></h4><p>1、如何监听弱网情况事件？</p><p>2、如何在entryability里实现一个全局监听器？</p><p>3、如何实现LED效果的弹幕滚动？</p><p>4、HarmonyOS应用未上架 ，如何调试检测应用更新功能是否正常？</p><p>5、ListItem怎么设置只能一侧滑动？</p><h4><a href="https://link.segmentfault.com/?enc=9GKG4i9k36RBtG8XeeMoig%3D%3D.86SFnumaoeHfaD%2B0E0RSsaENoHyolOEGMHcUmyVZyRYgMceEw2QYOr5HLKdgQWZDD%2FDnjOV5VKpsDWpn2pGMtYuEMyqTqvn9st5d7UpLxi5CviqXXCQuKrULm9xMlPLKphf3j5%2BInrp0ryuXnR0t3PCFrEanlfu9SLU2TMadk1brVMObWRUzGl7MS6brIY76" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第15期</a></h4><p>1、关于HarmonyOS Next上架签名问题？</p><p>2、onTouch事件在点击的时候一直会触发TouchType的Move状态？</p><p>3、沉浸式模式怎么开启？</p><p>4、Scroll组件中的布局如何居顶展示？</p><p>5、如何感知@Component组件的show和hide？</p><h4><a href="https://link.segmentfault.com/?enc=cD1NBeF3aE03PakinoZB1g%3D%3D.2fJBpNvXN87%2FNgoj8VUg3f326Qko5VHmLLlLx4e2lct2glWeHgo7%2F6esnHztmT55smV9ATcqkMH8bMJ%2F0%2Fpr7Ny9h3wG2pCwM81Mvs96k4Uvf0qA6nCu9Py%2FAoqP5L7XG2%2FbRXOOmewYDO0ApzjV%2Fq09cEie%2FDVvEVZ7EwCRu3BnOm0eJ5ZKfxh34lSIeeTV" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第14期</a></h4><p>1、应用如何配置图标的前景图和后景图？</p><p>2、当前是否支持鸿蒙PC模拟器？</p><p>3、Web组件加载PDF时，如何禁止用户点击PDF中的某些链接？</p><p>4、h5如何通过userAgent判断当前是否是HarmonyOS NEXT？</p><p>5、HarmonyOS NEXT手机怎么导出照片到电脑？</p><h4><a href="https://link.segmentfault.com/?enc=0j8DDxzUV2pkJMUd%2BOhRxA%3D%3D.hcA2z6wULJsFjjD4vePb1V8CGsPW2QMh0Ph02YjVtRNya4R9D7sIFm7fnNaxqj%2FXS9VRfREPfukamfOYVdwVitnnuypmIM4RUf7Fc3YcHa0iSQpKG2LIbQZfGiFQK7hd4sHyOC6RnIFL9%2B5xXFfTYIpThLQ7io2ErupQQEmfFDxn3%2F2S3VoCES25YvC3JulY" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第13期</a></h4><p>1、ListItemGroup 的Header如何动态设置？</p><p>2、快递进度条效果如何实现？</p><p>3、怎么实现一个扇形的油表盘进度条？</p><p>4、如何分别监听设备的横竖屏旋转和设备屏幕大小变化？</p><p>5、如何实现图片逐个翻转效果？</p><h4><a href="https://link.segmentfault.com/?enc=SblO6gnN00Bl351lqh6xKw%3D%3D.KbNEq8hDMP2zJkD4W3rHLG5OYgHiv6r7SF7bnsYOXxhbm7nHh%2FA%2F0HVVXNtKWQ5IiXPmCFUDS%2B2q33FkRkrr2cH1ocA3%2BuIjLkG%2FRPMEzcvDfU25wqyLNZdarr%2BED88nAuXgfmmURVOHUgbKhhqzMZamBVfHv05nwwujRTrk3JgcnAhfY6foMoWIgOWiIF%2Bn" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第12期</a></h4><p>1、怎样适配 Pura X 的外屏？</p><p>2、h5链接在HarmonyOS上无法正常展示？</p><p>3、bindpopup设置popupColor属性不生效？</p><p>4、如何对应用进行冷启动优化？</p><p>5、AlertDialog.show()中message的字体大小和颜色如何修改？</p><h4><a href="https://link.segmentfault.com/?enc=1tqZp%2F%2BwGf%2BMNtz7QIvQCQ%3D%3D.fB3cL3ajlsPSP7ARkS1Kjm%2FaZ6UWb2Eso3ZLqQAjsi90dK5yWrM2l5BrdkWhaeL%2F5PAjM28W4SdEbQsvKap6eJXUtIIS6CbNstc8qr4k7GQx8531WFaLGMOgmDUSB4rRB2iQQLASEmXu4QnGj8IoiKjiTTKJzmrHB69J%2BHge4bt%2BdW2RoMIRctFW8ZqTYcD4" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第11期</a></h4><p>1、如何实现多主题下正常模式和深色模式适配？</p><p>2、局部@Builder传参未生效问题？</p><p>3、如何在二维码的中间加个头像？</p><p>4、list怎么更新单个item的ui？</p><p>5、当前HarmonyOS支持画中画和悬浮窗吗？</p><h4><a href="https://link.segmentfault.com/?enc=CkDR2Ep2nGVsCZ%2B793XBQA%3D%3D.Q38jxQlWbJ2q9AfohqBkGGfuy1HgnnuzGAGB1ok0S8QTv%2F6c2Mq2I0XlID6vL6S%2Bpi9Sl5aDY3zXS2k%2BOEoxu4oB%2FqlX%2BfYHQNgC2akRmdqL45h%2B7AL3STuNUKE4fKByVR%2BVZghanlLTpE2N0%2F8K6NVsgOAEXwV%2F2g9mjW%2B84itrIwaZ2LHPhZwwR54ej3wl" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第10期</a></h4><p>1、对于超长文本显示，如何让scroll组件始终显示底部？</p><p>2、如何获取当前定位的城市？</p><p>3、图片裁剪如何实现？</p><p>4、使用EventHub进行数据通信可以反向操作吗，比如控件端由发送消息改为接收消息？</p><p>5、&amp;dollar;rawfile()使用三元表达式展示图片时图片不刷新？</p><h4><a href="https://link.segmentfault.com/?enc=oFUMekM92qn25PQtP%2BI%2BHw%3D%3D.DHeeqEPV4%2BHfrWOciSQSeejn00EF23GYFqIE7V4%2FxraAm%2FygScp2Gh%2FXv3CoCeR1whF2vsHbCqc0LToRTzKO%2BGjlk7icynBQOfdkGG5%2Bd2Io6s0i5pHxSeHaI5IZQrdMTDDNcZibbCnXSiMj%2BOy0h3vBeFr7XXkyeArqN1fOzV3c0boessEgImiLgkeWtXxA" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第9期</a></h4><p>1、关于图片 margin 的边距设置不生效问题？</p><p>2、如何在不影响自动换行的前提下给一段文字中的两个词变色并绑定不同的点击事件？</p><p>3、TextPicker组件，设为两列，如何实现这两列的滑动互不干扰？</p><p>4、为什么在用ForEach渲染Array时，只能渲染出来第一个图片呢？</p><p>5、promptAction.openCustomDialog弹窗关闭动画问题？</p><h4><a href="https://link.segmentfault.com/?enc=owpULD08KeDkxlxjKhXW7g%3D%3D.UioLYwfnnPe0XNfPXu56kORyY823vyTrNJoLWf8mjHeGmB87tqQjMHoOdm1f93e%2F6rt8vOepxawUNmN5VjEATQh1eRUTrkH%2BI1XqJV7Nn99rKB6oWQt6vwH%2FQS4zWT7bV7%2B9GYoWB2I%2BTJ1eWF5GFRpTImOTUgFh4PvyZ70E3OLugDk%2BIK8uFwgOa1V6LqHy" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第8期</a></h4><p>1、如何在自定义类中展示带图片的toast？</p><p>2、怎么使用colorFilter修改图片的颜色？</p><p>3、要实现promptAction.openCustomDialog的弹窗关闭动画完成后蒙层才消失，应该怎么做？</p><p>4、scroll和tabs关联，想让tabBar的标签可以划出屏幕，除了自定义tab以外还有其他办法吗？</p><h4><a href="https://link.segmentfault.com/?enc=yKOMeytIP882kbgRiNJVyw%3D%3D.%2BSQ%2BQ3QhKtgxZiA6HYy%2BwBKjpBot9zcXFRxnM%2Bnky2vMphWYDgcr%2BRPuvZtwsCkmym%2BMcjWDdtVEoL53qBgQiXx4lVSWE0n%2BzVTSBRH0ULDS2y1kYRJGidTUZ0Pb%2F5kGCMDqmn60sNMRjnYlVVBp9Mh%2Bmt6AWmFGU0TZeTtu4N5yCzFL%2F%2B%2BmBCxGj4Jv1fMk" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第7期</a></h4><p>1、项目中的Hsp模块编译成tgz包，其他模块怎么引用这个tgz里的资源？</p><p>2、怎么把文件存到公共目录，在文件管理可以查看呢？</p><p>3、如何实现仅对应用中某几个页面设置横竖屏旋转自适应？</p><p>4、在EntryAbility中使用preferences存储变量，在具体page中怎么获取？</p><p>5、uniapp调试鸿蒙元服务闪退怎么解决？</p><h4><a href="https://link.segmentfault.com/?enc=w2JIUqPLdN7RUfADCm12BQ%3D%3D.blW2dr0HaGcXXJdt%2FHdnjkoUHc9SgZoSZxSvRBx6OoxTTl%2BXeKuakXBcFiUsbMyHAoasoRWWANunmb2Rpyg%2FgkZHX415wab8GDDtR7nvYFEYM151nCUthBQ05VGqPhNyu6DwUURdMoGdycsNXApMxS51hLPU7W9s3sVeh0cSV0%2FOwX4vHZ94Y1hq%2F%2B3H57bo" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第6期</a></h4><p>1、在 HarmonyOS 中，如果用户拒绝了应用的某个权限请求，应用应该如何处理？</p><p>2、如何安装和使用第三方库？</p><p>3、元服务如何播放rawfile中的音频文件？</p><p>4、如何判断应用是否处于悬浮窗状态？</p><p>5、扫描控件得到扫描沙箱结果后，保存到相册失败，怎么解决？</p><h4><a href="https://link.segmentfault.com/?enc=n5U2tWMpkfM6cu1OQvbIrA%3D%3D.xq0Fll9JRi9jF6POkuVC%2BFhUfr9nn%2BWoRCqShmFXq4Uer1EKuN6U9vLPchsRBI2DjPPEnKNY8IKNeBkkGhtUnPx40QgucHYCeqJ3WD3FElK9Z%2FFSEdiB5Qhi%2B15CvXNvLwY0dBi3lkQqSyusmcZYr213elHECvInp9GN%2FosiQOkDeAV3l%2FSOAxd03DbOQc6H" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第5期</a></h4><p>1、如何将相册照片保存到APP的沙箱？</p><p>2、如何实现选择多张图片上传？</p><p>3、如何从native层的子线程同步调用ArkTS方法并获取返回值？</p><p>4、Canvas绘制内容怎么更新？</p><p>5、如何在应用内主动刷新卡片？</p><h4><a href="https://link.segmentfault.com/?enc=LyiNPOhrnw5wc1P1mlPj4w%3D%3D.W9SqchW1kKkNC%2BXCWXs5k0j2mjtK%2FIUw7r6kKc0WIxwOUJdt2BQk7SWimQUZV7m9OBgXJF0%2Fi1xMkIOKnKeWUWdnja4w5AVYziyVTfSUiDbhwjjpmYeAzPHHWjgrs4fGJKf4VLueUhDioSlh5rhhVPpvETxad%2FKF2guJIKtwixtTDAULQ6GZ0Rm4Xma4c99K" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第4期</a></h4><p>1、父组件的点击事件，如何让子组件进行响应？</p><p>2、子组件的点击事件，如何正确让父组件进行响应？</p><p>3、父子组件使用@State/@Prop交互，子组件中UI成功更新，但promise中无法获取到最新的值，原因是什么？</p><p>4、同样使用@State装饰器，有时第三层数据可以更新UI，有时不可以，是什么原因？</p><p>5、@ObservedV2和@Trace装饰的单例class数据，修改后为什么UI不更新？</p><h4><a href="https://link.segmentfault.com/?enc=ExRGluXUV1u3aGRPskrgoA%3D%3D.8aKbvgdEeNIQOaVnIvcMCgGf%2B%2F5pZOklzd4G8szqtWSvPvqmyuOctZ5stW95TE86IFx%2BXiQEuR4HnCIqQT8TZ6fMJqJW7zO1BfZ27aOp9lRgpg9KmTvBGjVFeOa6akV507Tut7hHT%2Bn7mRCLe7GueJbQ4xBlTl0os4Okf3HxHYYT3TN9IDZ0V0mIRjaySJVC" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第3期</a></h4><p>1、如何停止无限循环的动画？</p><p>2、怎么实现一个图片一直循环上下匀速移动的动画效果？</p><p>3、页面中有一个横向滚动的Scroll组件，用户不知道可以滑动，怎么达成Scroll组件可滑动的暗示呢？</p><p>4、Swiper组件如何实现中间高两边低的效果，前后两个组件的高度如何设置呢？</p><p>5、半模态高度能否自适应，怎么实现？</p><h4><a href="https://link.segmentfault.com/?enc=%2BU%2BTynR7TRRPZwSpM47NKQ%3D%3D.1SJbM1c0xepgMZtWnhRtmSr4c9Hv%2FYnGFLTjlbTvjeWeKGG7NZjdmARuo3oCh%2Fzz7Xokr6fuMth06pBdOcBLKsrY9rQI%2F4%2BU6VpZc4%2F%2B4%2FwM9AR4Zq9DeJMxVce2mGUZSUn8FZYwzjFa4obgUAeus3AJZd6dmeaZbBr6faru7aLMeti6nCG35wM%2FBvGvx%2Fln" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第2期</a></h4><p>1、HarmonyOS中的路由跳转该怎么设计？Router和Navigation应该使用哪个呢？</p><p>2、关于replacePath和pushPathByName的问题，用replacePath后返回还是上一个页面是为什么？</p><p>3、使用@BuilderParam 之后预览器无法启动是什么原因？</p><p>4、元服务如何获取/设置屏幕亮度？</p><h4><a href="https://link.segmentfault.com/?enc=82MIPwxYKt6XQ0isbTDLxQ%3D%3D.e48WW50a6BnoDnmIkOTLGeA21jLySMSeW2edLZYPFb61LptlgMO%2BRs6jRtG5QeaHTkWaePIKpTP6XKtEE4Ni47bPYXqvwzy0t70ukYDwp8qWgVrb3k5sCsHfosM2zFHVkH2bIQruExZUpy2%2B3X3Y3Lawp9qKhHbo9bOwcHUUecZrxAFPkCWec4GJqbw9DPet" rel="nofollow" target="_blank">"答开发者问"之HarmonyOS技术问题解析 第1期</a></h4><p>1、如何导入其他module的so库？</p><p>2、使用 @Builder数据刷新后UI没有刷新，导致图片错乱怎么解决？</p><p>3、包含C++代码的静态库引入失败，请问是什么原因？</p><p>4、Navigation组件的menus参数icon不显示如何修改？</p>]]></description></item><item>    <title><![CDATA[【今日上新】Pura X适配指导 鸿蒙百]]></title>    <link>https://segmentfault.com/a/1190000047388716</link>    <guid>https://segmentfault.com/a/1190000047388716</guid>    <pubDate>2025-11-11 12:07:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文原创发布在<a href="https://link.segmentfault.com/?enc=ic%2F4bA7yZRdHJWgqoZKbGA%3D%3D.%2F7HB7H2rQLoF7KKEPYpZgKHeNw%2F3t3sRbfECwJ04sAYAknM0pd%2B380ESIPVMf8YWEYGKUL0Bqu8pI%2F0RtGYDLuFX7teazsi6lD23DEAK26Fgt5FXKGKx3QvgYRE8im%2FV" rel="nofollow" target="_blank">华为开发者联盟社区</a>，欢迎前往与更多开发者进行互动。  </p><p>更多相关问题可点击原帖进行交流：<a href="https://link.segmentfault.com/?enc=J%2BgQ6Z4tjdJ1JPrc%2B4tQAg%3D%3D.DPNLFj8ehYxLD1wKYzNSLltFo4Kj9yoLsOrMUYVB6Agprda3jNnyZQ5hbiW5WbelHlkaFawtRlXCV1lws%2BFxmbzTMJXDYdbATjb4yuyzj82jMrYJtuuYutH577xvtA3v5bjnwUJ43dBVG8Gtsusv%2B%2BjazKnaSqMT4lTu84r%2FA1XJQu2Urw6UyfrYV4UkcLZn" rel="nofollow" target="_blank">Pura X适配指导</a>。</p><p>本帖涵盖Pura X适配要点、内屏和外屏具体的开发适配指导、如何获取Pura X模拟器、如何让自己的应用展示在外屏。</p><h4>HarmonyOS开发者们</h4><p>Pura X是华为今年推出的业界首款阔折叠旗舰手机，配有一块16:10比例的内屏（展开态）和一块1:1比例的方形外屏（折叠态）。  <br/>在适配Pura X阔折叠时，主要适配内容和关注点如下：</p><h3>1. 适配要点</h3><ul><li>内屏：较16:9及以上比例的手机更宽，所以在沉浸阅读、大屏观影、横屏操作等竞争力场景有更好的体验。同时较手机高度更矮所以可能存在部分页面UX基础适配问题。</li><li>外屏：主打即时信息处理、便捷出行导航、快速移动支付、沉浸影音播放、轻量游戏畅玩等场景，充分发挥小方屏的高效便捷场景无需内屏操作的优势，同时因为外屏1:1的屏幕比例也带来了部分基础功能适配工作。</li><li>开合连续：为保障内外屏的体验一致，Pura X需要保证折叠开合场景功能的连续性，主要涉及开合时页面高度和宽度的更新、摄像头切换、页面和视频播放连续等场景。</li></ul><h3>2. 适配指导</h3><p>详细适配指导可参考官方文档<a href="https://link.segmentfault.com/?enc=f9RpWLzri02YFlV9isPfTg%3D%3D.NIU66Vmfmkg%2BdBNLqbttLvn7KGk4pGeGeDyXA7eIme02ziyjZwE4GJxzh3GIiBuaSmLKSR26EbiT3esOJsldhR%2FFcRChWAt2pDg3puE0Jog74hFVtIEbNZvV9wB9Um0G67HdsjZuJA%2BfkLuSbg3AIBGIUuS9AFXXuxna8PVdECQ%3D" rel="nofollow" target="_blank">折叠屏适配</a>（重点关注<a href="https://link.segmentfault.com/?enc=UyAvx7dSYT19wGrDmMBuMw%3D%3D.S5Diu1TRmtl3JXz04x%2B3fHGEXSdETXnrNmrHr7h1JrkVOcziWHsVArhKdv2ZzqUW1LY%2F7hTOUB3GhfH%2FKIQQSRFnXbl6YHNCAElpgJAxJY9O6bdvrttXymQhyLCt3l0TrT62HjYQcl4TUh2JBnjowIPEnQ4vEnqgDu9u5u5Ss1OwhF7SzzetNRevp0KDwN7F" rel="nofollow" target="_blank">折叠屏UX体验标准、折叠屏应用开发指导</a>）和<a href="https://link.segmentfault.com/?enc=zglaNCjV2L0iT4KTYkgJxg%3D%3D.2eiK6vvHvMGyBVMS9FU7xO5VtcwyumOf6xHY8fy1%2BlfyJJODQ1kX%2FxMkWdWAlydCTbpL8u8aB2S6XQlc0LHCFZr0BhxVB4nIRTOakQX3IimcCbN0TboUCD1eNMz%2BuZnC3IWHE8Obi%2FtTXIriBdKG9ts%2FERyENSj%2F8n5QHNs5Xr8%3D" rel="nofollow" target="_blank">Pura X开发实践</a>。</p><h3>3. 如何获取Pura X模拟器</h3><p>Pura X模拟器已正式发布，下载<a href="https://link.segmentfault.com/?enc=pM%2B3FKeoTrmOUV%2Ff4fLc5g%3D%3D.G9qUwolN2JO8XKQhO%2BpqW667AndUtDeKxmnuAo%2FQMwVGmwHmP4QbN9iUkHvt%2FCB82MIVunbCmIZYOQprmTXO0kfbk2HyfnmpVJ2u%2F2DejeHYsrrgJ0rTwwTW7uMj%2BdFq" rel="nofollow" target="_blank">DevEco Studio 5.0.5 Release</a>或以上版本即可使用。</p><h3>4. 如何让自己的应用展示在外屏</h3><p>完成Pura X外屏适配，并成功上架应用市场后，在<a href="https://link.segmentfault.com/?enc=H4ua1IAJm4U99pxfPQ3a5w%3D%3D.pKq%2BFcu48HHE%2FNGv5MN0H3PPv3qW0eZyt14R46OThqbpb%2Br9LAsJu06H1jywmYEI%2F%2F6e2jah66GssY3LJol4qNxKDwJmRpVAy6j0LjYA0keAJRz1NsmmLtu5e6YK%2F96H0GpyZGI26TOlchbIUMlLjvFySO5jJPG6omzCT5gfZdY%3D" rel="nofollow" target="_blank">Pura X外屏应用展示申请</a>中填写报名信息，通过审核后，即可在Pura X外屏展示。</p><p>如遇Pura X外屏适配相关问题，可参考<a href="https://link.segmentfault.com/?enc=Zbel5HJeeJ%2BXoKRQNyKSHQ%3D%3D.Z4LyGY3Vlp%2FrqYGylgmQC3ywRiD001FmILibrNnr9amTem6simY%2F6Ejfw2NmQ%2Fzm15vVDAw9VBoz5RKHJA91OXbIJ9hXP651wDTBqanHMfw%2Ftoeiaprvhsl%2FVhDjmMx4g0tqmMesgQM2eg48r5hAJw%3D%3D" rel="nofollow" target="_blank">常见问题解答FAQ</a>。</p>]]></description></item><item>    <title><![CDATA[多行业适配指南：10款针对性强的项目管理]]></title>    <link>https://segmentfault.com/a/1190000047388748</link>    <guid>https://segmentfault.com/a/1190000047388748</guid>    <pubDate>2025-11-11 12:06:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>在企业数字化转型中，项目管理工具的“行业适配性”往往是选型的隐性门槛——<strong>用互联网团队的敏捷工具管制造研发，会缺BOM变更联动；用建筑行业的项目管理工具管金融IT，会多冗余的进度节点；用公有云工具管军工项目，则可能触碰数据主权红线</strong>。</blockquote><p>当下CIO的困境，不是找不到工具，而是找不到“贴合行业基因”的工具。本文基于长期行业观察，建立<strong>5大核心评估维度</strong>，客观拆解10款覆盖政企、制造、建筑、金融等场景的项目管理工具，最终为不同行业决策者提供“按场景选工具”的落地指南。</p><h2>一、建立标准：5大行业适配评估维度</h2><p>工具的“好用”，本质是“匹配行业需求”。我们从<strong>行业核心痛点</strong>出发，定义5大评估维度：</p><ol><li><strong>数据主权与可控性</strong>：数据存储位置（本地/云端）、是否符合行业监管（如军工的“数据不出域”、金融的“等保三级”）；</li><li><strong>行业场景深度</strong>：是否内置行业专属模板（如制造的BOM管理、建筑的进度甘特图）、流程适配度；</li><li><strong>部署灵活性</strong>：是否支持行业所需的部署模式（如政企偏好私有化、互联网接受公有云）；</li><li><strong>集成与扩展能力</strong>：能否对接行业现有系统（如制造对接ERP、金融对接OA）；</li><li><strong>合规与安全性</strong>：是否通过行业认证（如军工的武器装备科研生产单位保密资质、金融的ISO 27001）。</li></ol><h2>二、10款工具深度解析：行业适配性与典型场景</h2><h3>1. 禅道（私有化/混合云）</h3><p><strong>核心定位</strong>：全生命周期项目管理+研发流程管理，聚焦“安全可控的行业级项目治理”。  <br/><strong>特性</strong>：覆盖需求-计划-开发-测试-发布-运维全流程，内置<strong>政企研发、金融IT、军工项目</strong>等10+行业模板；支持自定义工作流（如军工的“四级审批”、制造的“研发-生产联动”），适配敏捷/瀑布双模式。  <br/><strong>评估维度表现</strong>：</p><ul><li>数据主权：100%本地化部署，符合等保三级、军工保密要求；</li><li>行业深度：服务3万+客户，如某军工企业用其管理装备研发全流程（从需求论证到列装验收），某城商行用其管控IT项目合规性；</li><li>集成能力：对接金蝶ERP、企业微信等系统，支持低代码扩展行业专属字段；</li><li>合规性：通过CMMI 3级、ISO 27001认证，满足金融、军工的安全要求。  <br/><strong>典型场景</strong>：政企研发项目、金融IT合规项目、军工装备研发管理。</li></ul><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdl902" alt="禅道项目管理软件" title="禅道项目管理软件"/></p><h3>2. Jira Align（公有云/SaaS）</h3><p><strong>核心定位</strong>：企业级规模化敏捷工具，服务<strong>互联网、软件研发</strong>的超大型组织。  <br/><strong>特性</strong>：聚焦“战略-项目-团队”三级联动，支持SAFe、LeSS等大规模敏捷框架；与Atlassian全家桶（Confluence、Bitbucket）深度集成，适合跨团队研发协作。  <br/><strong>评估维度表现</strong>：</p><ul><li>数据主权：数据存储于海外AWS，不符合国内军工、金融的“数据不出域”要求；</li><li>行业深度：擅长互联网产品的迭代管理（如某SaaS公司的产品路线图规划）；</li><li>集成能力：原生对接Atlassian生态，但与非Atlassian系统（如国内ERP）对接需额外开发；</li><li>合规性：未通过国内等保三级认证，不适合对安全有严格要求的行业。  <br/><strong>典型场景</strong>：跨国互联网企业的规模化敏捷转型、软件研发团队的跨地域协作。</li></ul><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdl909" alt="jira项目管理软件" title="jira项目管理软件" loading="lazy"/></p><h3>3. 鼎捷E10（私有云/本地化）</h3><p><strong>核心定位</strong>：制造行业一体化管理平台，<strong>项目管理与ERP深度融合</strong>。  <br/><strong>特性</strong>：针对制造企业的“研发-生产-供应链”协同痛点，支持BOM变更管理、生产排程联动；内置汽车零部件、电子组装等行业模板，可跟踪“研发项目→生产订单→物料采购”的全链路。  <br/><strong>评估维度表现</strong>：</p><ul><li>数据主权：支持本地化部署，数据留存于企业服务器，符合制造行业的“生产数据安全”要求；</li><li>行业深度：服务某汽车模具厂，用其管理“新车型模具研发→试生产→量产”项目，减少BOM错误率30%；</li><li>集成能力：与鼎捷MES、PLM系统无缝对接，无需额外开发；</li><li>合规性：通过ISO 9001认证，适配制造行业的质量管控要求。  <br/><strong>典型场景</strong>：汽车/电子制造企业的研发-生产协同项目、供应链联动项目。</li></ul><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdmGRH" alt="鼎捷项目管理工具" title="鼎捷项目管理工具" loading="lazy"/></p><h3>4. Asana（公有云/SaaS）</h3><p><strong>核心定位</strong>：全球化小团队任务管理工具，<strong>轻量级协作+跨时区适配</strong>。  <br/><strong>特性</strong>：提供列表、看板、时间线多视图，支持任务依赖关系设置；内置跨境电商、创意设计等行业模板，适合小团队快速同步进度。  <br/><strong>评估维度表现</strong>：</p><ul><li>数据主权：数据存储于美国，跨境流动需符合GDPR，不适合国内政企、金融；</li><li>行业深度：擅长跨境电商的“选品→上线→推广”小团队协作（如某亚马逊卖家的新品 launch 项目）；</li><li>集成能力：对接Slack、Google Workspace等海外工具，与国内系统集成需第三方中间件；</li><li>合规性：未通过国内安全认证，存在数据隐私风险。  <br/><strong>典型场景</strong>：跨境电商小团队、创意设计工作室的轻量级项目。</li></ul><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdmc6i" alt="Asana项目管理工具" title="Asana项目管理工具" loading="lazy"/></p><h3>5. Oracle Primavera P6（私有云/本地化）</h3><p><strong>核心定位</strong>：建筑/工程行业项目管理工具，<strong>强进度管理与资源调度</strong>。  <br/><strong>特性</strong>：针对建筑工程的“工期紧、资源复杂”痛点，支持大型项目的进度计划（如甘特图、关键路径分析）、资源分配（人力/设备/材料）；内置工程施工、能源项目等行业模板。  <br/><strong>评估维度表现</strong>：</p><ul><li>数据主权：支持本地化部署，符合建筑行业的“项目数据留存”要求；</li><li>行业深度：服务某央企建筑工程公司，用其管理“跨区域地铁项目”的进度与资源，减少工期延误15%；</li><li>集成能力：对接AutoCAD、Bentley等工程设计软件，实现“设计→施工”数据联动；</li><li>合规性：通过FIDIC（国际咨询工程师联合会）认证，适配国际工程的标准。  <br/><strong>典型场景</strong>：工程施工、能源项目的大型进度管理、资源调度。</li></ul><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdmWLs" alt="项目管理软件" title="项目管理软件" loading="lazy"/></p><h3>6. 泛微e-cology（私有云/本地化）</h3><p><strong>核心定位</strong>：OA+项目管理融合平台，<strong>流程驱动的政企项目</strong>。  <br/><strong>特性</strong>：强流程引擎，支持自定义审批流（如政企的“项目立项→预算审批→验收”流程）；与泛微OA的文档、会议、知识库深度整合，适合“重流程的政企项目”。  <br/><strong>评估维度表现</strong>：</p><ul><li>数据主权：本地化部署，符合政企的“数据安全”要求；</li><li>行业深度：服务某市级政府单位，用其管理“智慧城市信息化项目”，将审批流程从7天缩短至2天；</li><li>集成能力：与泛微生态无缝对接，与外部系统对接需通过泛微iPaaS平台；</li><li>合规性：通过国家电子政务系统安全等级保护三级认证，适配政务场景。  <br/><strong>典型场景</strong>：政府信息化项目、国企的重大项目管理。</li></ul><p><img width="723" height="356" referrerpolicy="no-referrer" src="/img/bVdmPEG" alt="泛微项目管理软件" title="泛微项目管理软件" loading="lazy"/></p><h3>7. Zoho Projects（公有云/SaaS）</h3><p><strong>核心定位</strong>：高性价比全功能工具，<strong>中小微企业的通用项目管理</strong>。  <br/><strong>特性</strong>：覆盖需求、任务、资源、报告全模块，支持自定义工作流；提供零售、教育等行业模板，适合预算有限的中小团队。  <br/><strong>评估维度表现</strong>：</p><ul><li>数据主权：数据存储于海外AWS，国内节点少，不适合对合规有要求的行业；</li><li>行业深度：服务某小型教育机构，用其管理“在线课程开发”项目，跟踪讲师、学员、进度；</li><li>集成能力：对接Zoho CRM、财务等系统，低代码能力一般；</li><li>合规性：未通过国内等保认证，数据隐私风险较高。  <br/><strong>典型场景</strong>：中小微企业的通用项目、教育机构的课程开发项目。</li></ul><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdmAVZ" alt="" title="" loading="lazy"/></p><h3>8. Trello（公有云/SaaS）</h3><p><strong>核心定位</strong>：极简看板工具，<strong>初创/设计团队的低门槛协作</strong>。  <br/><strong>特性</strong>：仅保留看板、卡片、标签核心功能，通过Power-Up插件扩展；学习成本极低，适合“快速上手、轻量级跟踪”的场景。  <br/><strong>评估维度表现</strong>：</p><ul><li>数据主权：数据存储于美国，合规性弱；</li><li>行业深度：适合设计工作室的“创意项目”（如海报设计、UI迭代），用看板跟踪“需求→初稿→评审”；</li><li>集成能力：对接Slack、Jira等工具，插件市场丰富但需筛选；</li><li>合规性：未通过国内安全认证，功能浅，不适合复杂项目。  <br/><strong>典型场景</strong>：初创团队、设计工作室的轻量级项目、创意协作。</li></ul><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdmc6h" alt="" title="" loading="lazy"/></p><h3>9. 明道云（私有云/混合云）</h3><p><strong>核心定位</strong>：低代码项目管理平台，<strong>自定义流程的零售/物流项目</strong>。  <br/><strong>特性</strong>：通过低代码搭建行业专属流程（如零售的“新品铺货→门店运营”项目、物流的“干线运输→末端配送”项目）；支持对接电商平台、TMS系统。  <br/><strong>评估维度表现</strong>：</p><ul><li>数据主权：支持本地化部署，符合零售/物流的“数据可控”要求；</li><li>行业深度：服务某连锁超市，用其管理“新门店开业”项目，跟踪选址、装修、人员培训进度；</li><li>集成能力：低代码对接电商平台、物流系统，减少定制开发成本；</li><li>合规性：通过ISO 27001认证，适配零售行业的安全要求。  <br/><strong>典型场景</strong>：零售的新店开业、物流的运输项目管理。</li></ul><p><img width="723" height="356" referrerpolicy="no-referrer" src="/img/bVdmB55" alt="" title="" loading="lazy"/></p><h3>10. 禅道（再次强调：行业适配的核心价值）</h3><p>回到禅道，其<strong>“私有化+全生命周期+行业模板”</strong>的组合，恰好解决了多数行业的核心痛点：</p><ul><li>对政企/金融：满足“数据不出域”“等保三级”要求，内置合规流程；</li><li>对制造/军工：对接ERP/PLM系统，支持研发-生产/装备研发的全链路；</li><li>对中小团队：轻量化部署，成本低于传统定制软件。</li></ul><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdl902" alt="" title="" loading="lazy"/></p><h2>三、对比与结论：按行业选工具的决策逻辑</h2><p>通过5大维度对比，我们可以为不同行业给出明确指引：</p><table><thead><tr><th>行业</th><th>推荐工具</th><th>核心理由</th></tr></thead><tbody><tr><td>政企/金融</td><td>禅道、泛微e-cology</td><td>数据安全、信创适配、流程驱动</td></tr><tr><td>制造/汽车</td><td>鼎捷E10</td><td>与ERP集成、研发-生产协同</td></tr><tr><td>建筑/工程</td><td>Oracle Primavera P6</td><td>强进度管理、资源调度、国际工程认证</td></tr><tr><td>互联网/研发</td><td>Jira Align</td><td>规模化敏捷、研发流程适配</td></tr><tr><td>跨境电商/小团队</td><td>Asana、Trello</td><td>轻量级协作、跨时区适配</td></tr><tr><td>零售/物流</td><td>明道云</td><td>低代码自定义、流程对接</td></tr></tbody></table><p><strong>关键结论</strong>：  <br/>对于<strong>政企、金融、制造等对数据安全、国产化有严格要求的行业</strong>，以禅道为代表的“私有化、强管理、行业适配”工具，是平衡“安全与效率”的最优解——它既解决了公有云工具的“数据失控”问题，又避免了传统定制软件的“高成本”，同时通过行业模板降低了落地门槛。</p><h2>四、FAQ：行业选型的常见疑问解答</h2><h3>Q1：不同行业选项目管理工具，最该优先考虑什么维度？</h3><p>A：<strong>优先匹配“行业核心痛点”</strong>：</p><ul><li>若行业涉及数据安全（如政企、金融），选“数据主权与合规性”强的（如禅道、泛微）；</li><li>若行业需跨系统协同（如制造对接ERP、建筑对接工程设计软件），选“集成能力强”的（如鼎捷、Primavera）；</li><li>若行业是轻量级协作（如跨境电商、设计），选“易上手、成本低”的（如Asana、Trello）。</li></ul><h3>Q2：禅道和泛微这类OA+项目的工具，核心差异在哪里？</h3><p>A：<strong>聚焦点不同</strong>：</p><ul><li>泛微强在“流程驱动”——适合以OA为核心，需将项目管理嵌入现有审批流的政企（如政府信息化项目的“立项→预算→验收”流程）；</li><li>禅道强在“项目全生命周期管理”——适合以项目管理为核心的团队（如软件研发、军工装备研发），内置行业专属的项目流程模板，而非依附于OA。</li></ul><h3>Q3：私有化工具的部署和维护成本，真的比公有云高吗？</h3><p>A：<strong>需算“总拥有成本（TCO）”</strong>：</p><ul><li>公有云按用户订阅（如Jira约20-30美元/人/月），团队扩张后成本线性增长；</li><li>私有化工具一次性投入license（如禅道约8-15万/年），长期使用成本更低；</li><li>对50人以上的团队，私有化的TCO更优，且避免了公有云“数据按用户数涨价”的陷阱。</li></ul><h3>Q4：Jira在国内企业使用时，需要注意哪些合规问题？</h3><p>A：<strong>主要是数据主权与安全</strong>：</p><ul><li>Jira数据存储于海外AWS，国内企业使用时，客户数据、项目数据会跨境流动，违反“数据不出域”的监管要求（如军工、金融）；</li><li>未通过国内等保三级认证，无法满足政企、金融的安全合规标准；</li><li>若企业无海外业务、不涉及跨境数据，可谨慎使用，但需做好数据加密与访问控制。</li></ul><h3>Q5：低代码工具（比如明道云）适合哪些行业的特殊场景？</h3><p>A：<strong>适合需要“自定义流程、对接现有系统”的行业</strong>：</p><ul><li>零售：自定义“新品铺货→门店运营”流程，对接电商平台获取销售数据；</li><li>物流：自定义“干线运输→末端配送”流程，对接TMS系统跟踪货物位置；</li><li>这些行业的流程差异大，低代码工具可通过“拖拽”搭建专属流程，避免传统定制的高成本。</li></ul><p><strong>结语</strong>：项目管理工具的“适配性”，从来不是“功能越多越好”，而是“越贴合行业基因越好”。对于政企、金融、制造等对安全与合规有严格要求的行业，选择像禅道这样“私有化、强管理、行业深度适配”的工具，才能真正解决项目治理的核心痛点，支撑数字化转型的长期价值。</p>]]></description></item><item>    <title><![CDATA[深度解析 Android 崩溃捕获原理及]]></title>    <link>https://segmentfault.com/a/1190000047388760</link>    <guid>https://segmentfault.com/a/1190000047388760</guid>    <pubDate>2025-11-11 12:05:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>作者：路锦（小蘭）</p><h2>背景：Android 应用崩溃的挑战</h2><p>在移动应用的世界里，稳定性是用户体验的基石。任何异常都可能导致用户失望、给出差评，并最终卸载应用。对于开发者而言，快速识别、定位和修复这些问题至关重要。正如线上应用崩溃了，我们收到的却往往只是一个无情的“已停止运行”提示。尤其面对 Native 崩溃和代码混淆，堆栈信息如同一本“天书”，让问题定位变得异常困难。本文将系统性地拆解 Android 崩溃捕获的底层原理与核心技术难点，并提供一套统一的框架设计思路，旨在点亮线上崩溃的“盲区”，实现从捕获到精准归因的闭环。</p><h2>崩溃采集的技术原理与方案调研</h2><p>要捕获崩溃，我们首先需要理解 Android 系统中两类主要崩溃的底层触发机制。</p><h3>2.1 Java/Kotlin 崩溃采集原理</h3><p>Java 和 Kotlin 代码都运行在 ART (Android Runtime) 上，当代码中抛出一个异常（如 <code>NullPointerException</code>）而没有被任何 <code>try-catch</code> 块捕获时，这个异常会沿着调用栈一路向上传递。如果最终抵达线程的顶部仍未被处理，ART 就会终止该线程。在终止前，ART 会调用一个可供开发者设置的回调接口——<code>Thread.UncaughtExceptionHandler</code>。</p><p>这正是我们捕获 Java 崩溃的入口。通过调用 Thread.setDefaultUncaughtExceptionHandler()，我们可以注册一个全局处理器。当任何线程发生未捕获异常时，我们的处理器便会接管，从而获得在进程完全死亡前的宝贵时机，用以记录崩溃现场的关键信息。</p><h3>2.2 Native 崩溃原理：深入信号处理与现场捕获</h3><p>Native 崩溃发生在 C/C++ 代码层，它不受 ART 虚拟机管理，因此 <code>UncaughtExceptionHandler</code> 对其无能为力。Native 崩溃的本质是 CPU 执行了非法指令，进而被操作系统内核检测到。内核会向对应的进程发送一个 Linux 信号 (Signal) 来通知这一事件，这是一种内核与进程之间进行异步通信的机制。</p><h4>常见致命信号详解</h4><ul><li><code>SIGSEGV</code> (Segmentation Fault)：段错误。这是最常见的 Native 崩溃原因，本质是程序试图访问一块它无权访问的内存。例如：解引用一个 NULL 指针、访问已释放对象的内存（Use-After-Free）、数组越界、试图写入只读内存段等。</li><li><code>SIGILL</code> (Illegal Instruction)：非法指令。当 CPU 的指令指针指向一个无效或包含损坏数据的地址时，CPU 无法识别将要执行的指令，便会触发此信号。例如：函数指针错误导致跳转到非代码区、栈被破坏导致返回地址错误等。</li><li><code>SIGABRT</code> (Abort)：程序异常终止。这通常是程序“主动”选择的崩溃，一般由调用 <code>abort()</code> 函数触发。在 C/C++ 中，很多断言库（<code>assert</code>）在断言失败后会调用<code>abort()</code>，表明程序进入了一个绝对不应存在的状态。</li><li><code>SIGFPE</code> (Floating-Point Exception)：浮点数异常。例如：整数除以零、浮点数上溢或下溢等。</li></ul><h4>捕获流程四部曲</h4><p>捕获这些信号并还原现场，是一个精细且严谨的过程：</p><ol><li><strong>注册处理器</strong> (<code>sigaction</code>)：这是捕获流程的第一步。我们使用 <code>sigaction()</code> 系统调用来为我们关心的信号（如 <code>SIGSEGV</code>）注册一个自定义的回调函数。相比于老旧的 <code>signal()</code> 函数，<code>sigaction</code> 提供了更丰富的功能，特别是通过设置 <code>SA_SIGINFO</code> 标志，可以让我们的回调函数接收到一个包含详细上下文的 <code>siginfo_t</code> 结构体，其中包括了导致崩溃的具体内存地址 (<code>si_addr</code>) 等宝贵信息。</li><li><strong>安全第一</strong>：<code>async-signal-safe</code> 环境: 信号处理器函数在一个非常特殊且严苛的环境中执行。在这个环境中，我们不能假定全局数据结构是完好无损的，也不能调用绝大多数标准库函数（如 <code>malloc, free, printf, strcpy</code>），因为它们不是“异步信号安全”的，调用它们极易导致二次崩溃或死锁。我们能做的，只有调用少数被明确标记为“安全”的函数（如 <code>write, open, read</code>）。</li><li><strong>堆栈回溯</strong> (Stack Unwinding)：为了得到函数调用链，我们需要在信号处理器中进行堆栈回溯。这是一个通过分析当前线程的栈指针（SP）、帧指针（FP）以及栈上的返回地址，来逐层还原函数调用关系的过程。<code>libunwind</code> 等库被广泛用于此目的。然而，在 Native 崩溃场景下，栈本身可能已经被破坏，这使得实时回溯的成功率并非 100%。</li><li><strong>生成报告</strong> (Minidump)：正因为实时回溯的不可靠性，业界最佳实践（如 Google Breakpad）并非在信号处理器中直接进行复杂的堆栈回溯。更可靠的做法是：在信号处理器这个“安全环境”中，只做最少、最核心的操作——即收集所有线程的寄存器上下文、原始的堆栈内存片段、已加载的模块列表等信息，并将它们“打包”成一个结构化的 Minidump 文件。这个过程不涉及复杂的逻辑，失败风险低。真正的堆栈回溯和符号化分析，则被推迟到服务端，在更安全、资源更充裕的环境中离线进行。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047352768" alt="image" title="image"/></p><h3>2.3 业界方案调研</h3><p>基于以上原理，业界涌现了众多优秀的开源及商业化方案。它们本质上都是对上述原理的工程化封装。</p><ul><li><strong>Google Breakpad/Crashpad</strong>：它们是 Native 崩溃捕获的“黄金标准”，提供了从信号捕获、Minidump 生成到后台解析的全套工具链。它们是许多商业方案的技术基石，但自行集成和后台搭建成本较高。</li><li><strong>Firebase Crashlytics &amp; Sentry</strong>：这类商业化平台（SaaS）提供了“SDK + 后台”的一站式服务。它们封装了底层的捕获逻辑，并提供了强大的后台用于报告聚合、符号化解析和统计分析，极大地降低了开发者的使用门槛。</li><li><strong>xCrash</strong>：这是一个功能强大的开源库，不仅支持 Native 和 Java 崩溃，还对各种复杂场景下的堆栈回溯做了深度优化，信息采集能力非常出色。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388762" alt="image" title="image" loading="lazy"/></p><p>经过对比分析，本文选择 Google Breakpad 作为 Native 崩溃采集的核心技术。Breakpad 采用业界标准的 Minidump 格式，这一格式已被 Chrome、Firefox 等全球主流产品广泛采用，技术成熟。从能力覆盖角度看，Breakpad 在 Native 崩溃捕获、多架构支持、跨平台兼容等核心场景上表现完整，配套的符号化工具链（如 dump_syms、minidump_stackwalk）也十分成熟。虽然 Breakpad 专注于 Native 层面，但 Java 崩溃可通过上述 UncaughtExceptionHandler 机制补齐，整体能力覆盖性满足崩溃采集的要求。</p><h2>核心技术难点解析</h2><p>实现一个可靠的崩溃采集方案，需要克服以下三大技术难点。</p><h3>难点一：捕获时机与信息保存的可靠性</h3><p>崩溃发生时，整个进程已处于极不稳定的濒死状态。此时执行复杂操作（如网络请求）风险极高。我们必须确保信息记录的过程足够快且绝对可靠。因此，“同步写入、延迟上报”是最佳策略。即在捕获到崩溃的瞬间，以最快的同步方式将信息写入本地文件，然后等到应用下一次正常启动时，再从容地读取文件并上报到服务器。</p><h3>难点二：Native 崩溃的“黑盒”特性</h3><p>相比于 Java 崩溃，Native 崩溃现场更易遭到破坏。非法的内存操作可能已污染了堆栈，导致传统的堆栈回溯方法失效。因此，简单地记录几个寄存器值是远远不够的。我们需要的是一个包含线程、寄存器、堆栈内存、已加载模块等信息的完整“现场快照”。这正是 Breakpad 提出的 Minidump（小型转储）概念的价值所在。</p><h3>难点三：堆栈的“天书”——混淆与符号化</h3><p>为了安全和包体大小，线上代码通常经过了混淆（ProGuard/R8）。这会导致崩溃堆栈中的类名和方法名变成无意义的 <code>a, b, c</code>，如同天书。对于 Native 代码，发布的是不含符号信息的二进制文件，其堆栈也是一串无意义的内存地址。因此，符号化 (Symbolication)是必不可少的一环。我们必须在编译时生成并保留对应的符号表文件（Java 的 <code>mapping.txt</code>，Native 的 <code>.so</code> 文件），在服务端利用这些文件将“天书”翻译回可读的、有意义的堆栈信息。</p><h2>Android 应用崩溃采集及堆栈解析实践</h2><p>为了全面应对这些挑战，我们设计了一个统一的异常采集方案，遵循“捕获-持久化-上报-解析”的生命周期。无论是 Java 还是 Native 崩溃，客户端的核心任务都是可靠地将现场信息保存到本地。真正的解析和分析工作则交由服务端完成。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388763" alt="image" title="image" loading="lazy"/></p><h3>4.1 Java/Kotlin 崩溃处理</h3><p>我们使用 <code>Thread.setDefaultUncaughtExceptionHandler</code> 来捕获 Java/Kotlin 的异常。这是一个回调接口，无论是 Java 还是 Kotlin，其编译后的字节码均由 ART 执行。当抛出未捕获异常时，ART 会触发当前线程的异常分发机制，最终调用注册的 uncaughtException 方法。因此 <code>Thread.setDefaultUncaughtExceptionHandler</code> 能够实现全局 Java/Kotlin 异常捕获。</p><p>首先需要设置一个全局的未捕获异常处理器来捕获 Java 崩溃，通过实现<code>Thread.setDefaultUncaughtExceptionHandler</code> 的 uncaughtException 方法实现一个处理器，我们可以将自己实现的 handler 设置为所有线程的默认处理器。这就给了我们在应用彻底崩溃前的最后一刻“力挽狂澜”的机会——记录下导致崩溃的元凶。需要注意我们要保留原始的处理器：originalHandler。</p><p>当崩溃发生时，该处理器会收集异常及堆栈关键信息，最终将其同步持久化到 <code>SharedPreferences</code>。由于进程即将终止，当前的步骤必须保证同步完成，因此我们持久化写缓存也使用同步提交 (<code>editor.commit()</code>) ，异步的 <code>apply()</code> 可能无法确保成功持久化。关键的异常信息例如：</p><ul><li><strong>时间戳 (Timestamp)</strong>：崩溃发生的精确时间。</li><li><strong>异常类型 (Exception Type)</strong>：是 <code>NullPointerException</code> 还是 <code>IndexOutOfBoundsException</code> 等。</li><li><strong>异常信息 (Exception Message)</strong>：异常对象中包含的描述性信息。</li><li><strong>堆栈轨迹 (Stack Trace)</strong>：这是最重要的部分，它告诉我们崩溃发生在哪个类的哪一行代码。</li><li><strong>线程信息 (Thread Name)</strong>：崩溃发生在主线程还是某个后台线程。</li></ul><p>“下次启动时上报”是核心策略。它避免了在应用崩溃时不稳定的网络环境中尝试上报数据，大大提高了成功率。我们在 <code>start()</code> 方法中调用此检查。这个方法可以在后台线程中执行，防止阻塞应用主线程。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388764" alt="image" title="image" loading="lazy"/></p><pre><code>@Override
public void uncaughtException(Thread thread, Throwable throwable) {
    try {
        // 核心难点1：收集崩溃信息
        CrashData crashData = collectCrashData(thread, throwable);
        // 核心难点2：保证濒死前数据能被同步、可靠地保存
        saveCrashData(crashData);
    } finally {
        // 核心难点3：将控制权交还，确保系统默认行为（如弹窗）执行
        if (originalHandler != null) {
            originalHandler.uncaughtException(thread, throwable);
        }
    }
}
private void saveCrashData(CrashData data) {
    // 使用 SharedPreferences 的同步 commit() 方法
    prefs.edit().putString("last_crash", data.toJson()).commit(); 
}</code></pre><h3>4.2 Native 崩溃处理</h3><p>对于 Native 崩溃，我们集成了一个基于 Breakpad 的解决方案。在启动时加载一个 Native 库，该库为常见的崩溃信号设置了信号处理器。</p><p><strong>1. 初始化</strong>：在 App 启动时，我们初始化 Native 库，并为其提供一个专用的目录来写入崩溃转储文件（crash dump）。</p><p><strong>2. 崩溃发生</strong>：当 Native 崩溃发生时，信号处理器会捕获它，并将一个 <code>.dmp</code> (minidump) 文件写入指定目录。</p><p><strong>3. 下次启动时处理</strong>：在下一次 App 启动时，我们的框架会检查此目录中是否有任何 <code>.dmp</code> 文件。如果找到，它会调用一个 Native 方法来解析 minidump，提取堆栈信息和其他相关信息。解析后的数据随后被上报到我们的后端，并且转储文件被删除。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388765" alt="image" title="image" loading="lazy"/></p><pre><code>public void start() {
    // 核心难点1：尽早初始化 Native 层的信号处理器
    NativeBridge.initialize(crashDir.getAbsolutePath());
    // 核心难点2：在下次启动时，异步检查并处理上次崩溃留下的产物
    new Thread(this::processExistingDumps).start();
}
private void processExistingDumps() {
    // 遍历指定目录下的 .dmp 文件
    File[] dumpFiles = crashDir.listFiles();
    for (File dumpFile : dumpFiles) {
        // 此处无需解析，直接将原始 .dmp 文件上报
        reportToServer(dumpFile);
        dumpFile.delete();
    }
}
// JNI 桥接，是 Java 层与 C++ 层通信的唯一途径
static class NativeBridge {
    // 加载实现了信号捕获和 minidump 写入的 so 库
    static { System.loadLibrary("crash-handler"); }
    // JNI 方法，通知 C++ 层开始工作
    public static native void initialize(String dumpPath);
}</code></pre><p>转储文件中我们能获取到的异常信息有很多，使用时我们通常需要关注以下的关键信息：</p><p><strong>1. 异常信息 (Exception Information)</strong></p><ul><li><p>异常流 (Exception Stream)：</p><ul><li>崩溃线程 ID (Thread ID)：明确指出是哪一个线程引发了这次崩溃。</li><li>崩溃信号（Signal），例如 SIGSEGV（段错误) 和 SIGILL (非法指令)。</li><li>异常地址 (Exception Address)：异常发生时，CPU 指令指针（Program Counter）所在的内存地址。这直接指向了导致崩溃的那一行机器码。</li></ul></li></ul><p><strong>2. 线程列表与状态 (Thread List &amp; States)</strong></p><ul><li>线程 ID (Thread ID)：该线程的唯一标识符。</li><li>线程上下文。</li><li>线程堆栈内存 (Stack Memory Dump)：包含了每个线程栈上一部分内存的原始二进制拷贝。</li></ul><p><strong>3. 模块列表 (Module List)：</strong> 崩溃时进程加载的所有动态链接库（在 Android 上是 .so 文件）和可执行文件</p><p><strong>4. 系统信息 (System Information)</strong></p><ul><li>操作系统信息：操作系统类型（如 Linux）、版本号（如 Android 12, API 31）。</li><li>CPU 信息：CPU 架构（如 ARM64, x86）、CPU 型号、核心数量等。</li></ul><pre><code>// 崩溃信息
Caused by: SIGSEGV /SEGV_ACCERR
// 系统信息
Kernel version: '0.0.0 Linux 6.6.66-android15-8-g807ce3b4f02f-ab12996908-4k #1 SMP PREEMPT Fri Jan 31 21:59:26 UTC 2025 aarch64'  ABI: 'arm64' </code></pre><p>堆栈样例：<a href="" target="_blank">#00</a> pc 0x3538 libtest-native.so</p><h3>4.3 应用混淆堆栈解析</h3><p>当前很多线上应用为了安全和包体大小，代码通常经过了混淆（如 ProGuard/R8），这使得原始的崩溃堆栈变得几乎无法阅读。</p><h4>混淆 Java 堆栈解析</h4><p>当线上应用发生崩溃时，你捕获到的堆栈信息是经过混淆的，看起来就像这样，这个堆栈对我们来说几乎是无用的：</p><ul><li>类名 a.b.c.a 和方法名 a 毫无意义。</li><li>行号信息也丢失了，显示为 Unknown Source。</li></ul><pre><code>java.lang.NullPointerException: Attempt to invoke virtual method 'void a.b.d.a.a(a.b.e.a)' on a null object reference
       at a.b.c.a.a(Unknown Source:8)
       at a.b.c.b.onClick(Unknown Source:2)
       at android.view.View.performClick(View.java:7448)</code></pre><p>接下来我们了解一下混淆堆栈的解析原理：</p><p>当你在 Android 项目中启用代码混淆（通常是在 release 构建类型中设置 minifyEnabled true）并进行打包时，R8 工具会在处理你的代码的同时，在 build/outputs/mapping/release/ 目录下生成一个 mapping.txt 文件，这个文件我们可以理解为“字典”。</p><p>而解析工具会读取上述文件，将混淆后的堆栈逐行翻译为原始文件和方法名。</p><p><strong>1. 逐行读取堆栈：</strong> 工具读取混淆堆栈的每一行，例如 at a.b.c.a.a(Unknown Source:8)。  </p><p><strong>2. 解析关键信息：</strong> 它从这行中提取出关键部分：</p><ul><li>类名：a.b.c.a</li><li>方法名：a</li><li>（可能的）行号：8</li></ul><p><strong>3. 查询</strong> <code>mapping.txt</code>：</p><ul><li>工具在 mapping.txt 中查找 a.b.c.a: 这一行，找到它对应的原始类名，例如：com.example.myapp.ui.MainActivity。</li><li>接着，在 MainActivity 的映射条目下，它会继续查找哪个原始方法被混淆成了a。假设它找到了 void updateUserProfile(com.example.myapp.model.User) -&gt; a。</li></ul><p><strong>4. 恢复行号：</strong> R8 在优化过程中可能会内联方法或移除代码，导致行号变化。mapping.txt中也包含了行号的映射信息。Retrace 工具会利用这些信息，将混淆后的行号（如：8）精确地还原为原始的源文件行号。  </p><p><strong>5. 替换与输出：</strong> 工具将混淆的行替换为解析后的、可读的行。</p><h4>Native 堆栈解析</h4><p>这是一个我们采集到的 Native 堆栈其中的一行，分别包含以下信息：</p><ul><li><a href="" target="_blank">#00</a>：堆栈帧序号。00 代表栈顶，是程序崩溃的直接位置。</li><li>pc 0x3538：程序计数器地址 (Program Counter)。这是我们需要解析的关键信息，代表 CPU 在 libtest-native.so 这个库中执行到的指令的相对地址。</li><li>libtest-native.so：动态库路径。指明了崩溃发生在哪一个 .so 文件中。这是设备上运行时的路径。</li></ul><pre><code> #00 pc 0x3538 libtest-native.so</code></pre><p>然而我们拿到这个堆栈仍然无法解析出具体发生崩溃的文件和方法，因此我们需要解析 C++ 堆栈，还原为可读的崩溃真实信息。</p><p>与 Java 堆栈解析的核心思想一致，Native 堆栈解析也是一个“查表翻译”的过程。只不过它的“密码本”不再是 mapping.txt，而是包含了 DWARF 调试信息的、与线上版本完全一致的 <code>unstripped</code> 库文件：libtest-native.so 文件；“翻译工具”则是 NDK 提供的 addr2line 等命令行程序。执行类似如下的命令：</p><pre><code> # 使用 NDK 中的 addr2line 工具
 # -C: Demangle C++ 的函数名 (例如将 _Z... 还原成 MyClass::MyMethod)
 # -f: 显示函数名
 # -e: 指定带符号的库文件
addr2line -C -f -e /path/to/unstripped/libtest-native.so 0x3538</code></pre><p>工作原理：</p><ul><li>addr2line 工具加载 unstripped 的 .so 文件。</li><li>它解析文件中的 DWARF 调试信息段，这些信息段中存储了从机器码地址到源代码行号的映射表。</li><li>它在映射表中查找地址 0x3538 落在哪个函数地址范围之内。</li><li>找到函数后，它进一步在行号表中查找该地址精确对应的文件名和行号。</li><li>同时，它利用 -C 参数对 C++ 的“符号修饰名”（mangled name）进行“解修饰”（demangle），将其还原成我们代码中编写的、可读的命名空间::类名::方法名(参数) 形式。</li></ul><p>addr2line 工具执行完毕后，就会解析出我们期望得到的结果，因此我们能够定位到发生崩溃的具体文件和方法：</p><pre><code>CrashCore::makeArrayIndexOutOfBoundsException()
/xxx/xxx/xxx/android-demo/app/src/main/cpp/CrashCore.cpp:51</code></pre><h2>总结</h2><p>通过本文的探讨，我们解构了 Android 崩溃捕获的底层原理，并围绕三大核心技术难点（<strong>捕获时机、黑盒现场、堆栈混淆</strong>）设计了一套捕获方案。无论是 Java 层的 UncaughtExceptionHandler 机制，还是 Native 层的信号处理与 Minidump 技术，其最终目的都是在进程“灰飞烟灭”前，尽可能可靠地抢救出最有价值的现场信息。阿里云 RUM 针对 Android 端实现了对应用性能、稳定性、和用户行为的无侵入式采集 SDK。可以参考接入文档 <strong>[</strong> <strong>1]</strong> 体验使用。相关问题可以加入“RUM 用户体验监控支持群”（<strong>钉钉群号：67370002064</strong>）进行咨询。</p><p><strong>相关链接：</strong></p><p>[1] 接入文档</p><p><a href="https://link.segmentfault.com/?enc=kagcazu4xpD3EEInUezvqA%3D%3D.kVtPFZ3UCya6vc30lI6T1k6EGGoyHLLRBc%2FRhyj7XQTvJKUiLCCXAJ%2F4odbazxn4rjadwqAVUd4Lm6FCgSQR%2BqRTIab0DDZj%2B3JT5b83tfdJJoYgSHn3L02fWZokkRkB" rel="nofollow" target="_blank">https://help.aliyun.com/zh/arms/user-experience-monitoring/ac...</a></p>]]></description></item><item>    <title><![CDATA[终端侧AI实战指南+QAI AppBui]]></title>    <link>https://segmentfault.com/a/1190000047388789</link>    <guid>https://segmentfault.com/a/1190000047388789</guid>    <pubDate>2025-11-11 12:04:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>骁龙AI大赛的直播中的问题和及答疑在此汇总</p><h2>第一期</h2><p><strong>第一期中，高通技术公司的讲师团队带来了终端侧AI技术前沿与AI工具链解析，针对大家在开发过程中遇到的典型问题进行在线解析：</strong></p><p>问：Qualcomm AI Stack 里有没有实用工具能提升模型在手机端的推理速度？</p><p>答：Qualcomm AI Stack工具链非常完善，无论是浮点模型（FP16）还是定点模型（INT4/8/16），都能灵活选择不同量化精度，以提升端侧运行速度。同时还提供多种功耗模式（burst、pauseable、default），方便开发者在不同性能需求下灵活调优。</p><p>问：从模型转换到最终在NPU上跑起来，哪一步最容易踩坑？</p><p>答：模型转换是最关键的一步。若算子不被支持，就需要替换，这会比较耗时。建议开发者提前查看 Qualcomm Runtime 文档 中的算子列表。同时，量化模型时一定要准备足够的样本数据（几百到几千条），否则容易出现精度问题。</p><p>问：有没有转换好的大模型可以直接下载？</p><p>答：可以前往Hugging Face(<a href="https://link.segmentfault.com/?enc=Cb0klLfj3fXTQJf845Oy5A%3D%3D.2R7GtXJUi3lA24gnU%2BYtreZlGQoVloyf37yulE2%2Bek4%3D" rel="nofollow" target="_blank">https://huggingface.co/qualcomm</a>) 或模型广场</p><p>(<a href="https://link.segmentfault.com/?enc=8cklnqJgR%2B1S91OSyvexKA%3D%3D.hncDx8pk2oVC4KczFpPpooXzGEEhPi%2F0Ug7fIbfvlpMb4k0uQzIzTEiaHvaIj9L2" rel="nofollow" target="_blank">https://www.aidevhome.com/data/models/</a>)下载，目前已经开放了包括 Qwen 2-7B、Phi-3.5、Stable Diffusion 1.5 等主流大语言和视觉模型，开发者可直接调用使用。</p><p>可以发现，端侧AI模型部署其实并不难，关键在于熟练使用高通AI工具链。</p><h2>第二期</h2><p>第二期公开课聚焦骁龙AI PC应用开发，带来玩转QAI AppBuilder的详细指南，帮助开发者快速掌握在PC上开发和部署AI应用的核心技巧。 </p><p>我们了解了<strong>在骁龙 AI PC 上使用 QAI AppBuilder 工具丝滑部署AI模型的核心方法</strong>，省流版教程：</p><ul><li>用户指南：<br/><a href="https://link.segmentfault.com/?enc=GHbjof6Dbs0x7xGA1il3Jw%3D%3D.jNS5wCo%2BKloLDmyE9fWYK640MSpZusmBxXg8tZ61Vr4U4LdCDfCnKlDtfvH%2BKlLPhQL8Ik%2FOdi5U2FO02lhHk7koYd2Bhg3FHS3kchstFf0%3D" rel="nofollow" target="_blank">https://github.com/quic/ai-engine-direct-helper/blob/main/docs/user_guide.md</a></li><li>开源社区：<br/><a href="https://link.segmentfault.com/?enc=XYdalm5QancVn9SbJKd3qQ%3D%3D.Vgp7kY76JaYf6XTUoA5YGUaMvxxFwm2CmBvoiPyM%2Bb1N766fwCmDOnS%2FFmzyLXBf" rel="nofollow" target="_blank">https://github.com/quic/ai-engine-direct-helper</a><br/>由高通技术公司（中国） 资深产品市场经理朱元堃、高通技术公司（中国）高级资深工程师黄维两位专家联合带来，聚焦终端侧AI的最新架构、工具生态与实战落地，直击骁龙平台的AI创新核心，助力开发者快速上手进行开发！</li><li>了解骁龙平台的AI核心能力<br/>全面解析全新一代骁龙移动平台与最新AI引擎，揭示Hexagon NPU融合Scalar、Vector、Tensor加速器的先进架构设计，助力开发者精准理解终端侧AI的算力优势。</li><li>掌握从系统适配到性能调优全流程<br/>从硬件适配到算力调优，讲师将分享如何在高通平台上实现AI模型的性能最大化，帮助开发者在竞赛与实际项目中抢占技术先机。</li><li>AI Runtime 实操演示<br/>讲师将以实际项目案例展示AI模型从转换、量化到部署的全路径操作，了解它如何支持不同平台（移动、XR、汽车、物联网等）的AI部署，使开发者能够更高效地实现复杂AI应用，推动创新和技术进步。</li><li>专家在线答疑，助力开发者突破瓶颈<br/>直播设有深度答疑环节，来自高通技术公司的专家将针对模型部署、工具使用及优化问题进行专业解答，帮助开发者解决参赛过程中的关键难题。</li></ul><h2>第三期（待更新）</h2><p><strong>QAI AppBuilder移动端实践全解析</strong></p><p>深入讲解QAI AppBuilder工具，重点介绍如何在 Android平台上部署与运行AI模型。并结合详细案例，解析开发中的重点与难点：</p><p>如何在Android平台上高效部署与运行 AI 模型</p><p>如何在移动端运行经典的计算机视觉（CV）模型</p><p>如何在移动端运行经典的计算机视觉（CV）模型</p><p>如何将这些模型集成到真实App中，快速完成移动端AI应用开发</p><p><strong>AI PC模型部署进阶之路</strong></p><p>——ONNX Runtime实践指南</p><p>AI PC模型部署进阶之路——ONNX Runtime实践指南</p><p>回到骁龙AI PC平台上，掌握ONNX Runtime的实战应用。嘉宾讲师将演示如何通过ONNX Runtime实现跨平台AI模型部署，使模型既能在移动设备端高效运行，也能在PC端灵活适配，帮助开发者真正实现 “一次训练，多端部署” 的目标。</p><p>以上内容来自2025骁龙AI大赛</p>]]></description></item><item>    <title><![CDATA[【有搜必应】HarmonyOS TOP5]]></title>    <link>https://segmentfault.com/a/1190000047388802</link>    <guid>https://segmentfault.com/a/1190000047388802</guid>    <pubDate>2025-11-11 12:04:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文原创发布在<a href="https://link.segmentfault.com/?enc=0SUqBCAtyGrrPDaTl3Vmcg%3D%3D.CDj3DJns2aGpOfqEsKEociEa%2BKNWeeoqVv6tH7YiDbGHg09NnZrQ0G9y9ya7Fly6sylK2YOYKw8rYBUTlJ6vSmgmVwsn1YF5ROQfmPDGptgKZ1CTbfbWQx9P%2ByBmfFK8" rel="nofollow" target="_blank">华为开发者联盟社区</a>，欢迎前往与更多开发者进行互动。  </p><p>更多相关问题可点击原帖进行交流：<a href="https://link.segmentfault.com/?enc=0qoKrZKFu260rHByppTJqw%3D%3D.Gy0IHju%2Fo%2FPxUcjC9FKaGED7gVQH7ZJrgty0I6IJt43ec3joSQiF1EfBtnETtk5nhfyw5QV%2FdXgSV2XAY6%2FtgtiL4bwFyRqIkrBrO%2BTOCy6EFSasfvfhF0fXs1IfLOxgU9UeYw3mTmspI3L%2BPG0EIWvNXKTMW7DXY5ma0KD%2FH3x%2FBFmQdcdDwlI%2B7oscTFLH" rel="nofollow" target="_blank">【有搜必应】HarmonyOS TOP5热搜技术问题解析第三期</a>。</p><h4>HarmonyOS开发者小伙伴们</h4><p>每一个搜索词的背后，都是您最迫切的技术问题诉求与最真实的痛点；每一个热搜词的背后，更代表了众多开发者遇到的共性难题。为助力大家扫清Top开发障碍，我们选取了社区高频的热搜问题，进行深入剖析，推出《有搜必应》专栏，旨在集中解决共性问题，为大家勾勒一份鸿蒙开发的"热点地图"。这些热搜问题中，不仅有技术支持提供的详细答复，更有热心开发者的互助解答，希望能为您提供有价值的参考。让热搜问题成为您能力提升的阶梯，让每一次技术探索事半功倍，助力大家在鸿蒙开发之路上行得更稳、更远。</p><p><strong>向所有参与社区互助的开发者致以最诚挚的感谢！</strong></p><h4>本期热搜揭秘</h4><p><strong>【ArkUI】</strong></p><p><a href="https://link.segmentfault.com/?enc=Rkv8xA4eHy4hoNkTYyJCrQ%3D%3D.YV24CCQzjtAbI6XJpKwXXWKPAWhF9ibnPPNJlCuJrfJgoGX8yZo9ql8V%2Fz0ms2cGegkAZjfsBvv%2FLUGrGexVdyI4xnH8NTGgZY59EK%2F5vzgJjsmclGXWay3ripGDYCWSJyv1vv1MprvS8cewusWVaQ%3D%3D" rel="nofollow" target="_blank">HarmonyOS NEXT中如何禁止侧滑返回上一级，是否有相应的拦截方法</a></p><p><a href="https://link.segmentfault.com/?enc=3UaqpOKHGStMeCzr2mNVUA%3D%3D.Pj0P9TeyGo4o1hTBgUsadXc8wmE3c%2Bbjvjq7WSTgBGCah8HmbgSDRLUm9Ai56fK0TnB4%2Fv6KPERH7E63DIM4Xb71WSeAdBmFl6%2F2FzRUf0TJGnScLpaR%2BsMvysMaWmzhV7RPuSBtzXz%2FXYpUUqq%2BSs6TlMHqb%2Fcyxc8FiFDixDjPgZkF4t%2FUcnJA1DDQ7kf8" rel="nofollow" target="_blank">HarmonyOS NEXT应用开发中layoutWeight=1 设置成了高度拉伸，如何改为宽度拉伸</a></p><p><a href="https://link.segmentfault.com/?enc=EqgMq2xDwGQkUlohfQaldw%3D%3D.yK4kwl07x6eFHZxUBIXRM4G%2B0y4b9pGyeMP1g8%2FTXjl3Y6B5DJDhNHrsStzIdlISrpcly%2FPvNJkmf1%2Biw9pZM4fC2A4f8BGc2%2BQy5%2FlpfjmH%2BNgEmGWwyJOiJyunKjB0bQwGgveHgfEBx43cmWb%2B7FZYGDOPcT%2BrxDpqfRqwSzMYJF%2F7axaG2F4C9UarAitT" rel="nofollow" target="_blank">HarmonyOS NEXT中的@Builder 和@Component 的区别是什么</a></p><p><strong>【应用服务】</strong></p><p><a href="https://link.segmentfault.com/?enc=c6%2FMmpz%2FVXYMdjYgJ4wEkA%3D%3D.ZUYZAzcTknRLCM5ZRyemuF%2FmvOrs9QnAb68xp43pNKm1sVaD9PkVuo1XGREidyAAnN83lbTPXTv%2BS5B6yNhrdWsqESalVs51sEKBMWiVF8J6ewVyAqJEqslenEsSx4BFhkGiyVXb0ewXQH8%2FZiuHbA%3D%3D" rel="nofollow" target="_blank">HarmonyOS NEXT中问如何获取鸿蒙开发，发布证书的APP包的签名信息</a></p><p><strong>【媒体&amp;图形】</strong></p><p><a href="https://link.segmentfault.com/?enc=4IFivr3wvncse5tSqKRxNg%3D%3D.n1i95QIlIZII1wVbsYt902kk3sMWwczxCO%2FvprTZMiQ%2FKltqy5YIMlmrvOX2r2zVcfqyMxhkQHQ6L1skWyFRzJUMFMhqO13Lcrn0Itpme2fM%2FNjzovCcBoG6rO1DeOnz3HOdv%2FrBB6lSVtpUDE9cuQ%3D%3D" rel="nofollow" target="_blank">HarmonyOS NEXT中如何把相册图片文件保存沙箱</a></p><p>期待您在论坛中继续发声：无论是提出新的疑惑、发表见解、或分享实战经验，都会为鸿蒙社区注入前行的力量，也是让我们做的更好的动力！若您存在疑惑，可使用社区-问答-"我要提问题"进行提问。<a href="https://link.segmentfault.com/?enc=9JZ7leBnHCdu5drw59voOw%3D%3D.%2BPX1QaMTcqTd5ADhilywEvleDag3JcTSg6hEUL0RavJUHEne0Io4rV5KCyN0vHJ0jlS54MNKfEZj5BQ8FQ5RqPB6JhRmFfdaY%2B6A0tIOfnccjI0Obw2ffjKXfZ7N6Xct" rel="nofollow" target="_blank">问答专区-华为/鸿蒙开发者论坛</a></p><p>往期问题回顾：</p><p><a href="https://link.segmentfault.com/?enc=3PDJpIw1Lb%2BSD%2B6%2FN2xz6g%3D%3D.fVBWuT9Bqfa7Un0cMHfeh%2Bcydgn0OQDRl31u98Y9Bei%2BMOpV9wyMJ5vXp6qgj36jZqAJhmRZ6NQfp%2F14W91SNgbBqxQjdgSqz6K3C2wPTAZbrm%2BZfFrFGE7H%2FWYYswUvnhiOzFiIVJkJsRJNxYySsaCm1iDCVUhWZXZ9fSrmdYGH6lwRP4aaqcu%2B4GgLQxnJ" rel="nofollow" target="_blank">【有搜必应】HarmonyOS 热搜技术问题解析第一期</a></p><p><a href="https://link.segmentfault.com/?enc=C23Lo7e4UPt8cn8VFDHoLQ%3D%3D.1SglHWZzmqisuxyzrJpZSzwgCX7uN6cNJo9H%2FSMdRL1UXa%2FKED%2FiITwZCEkRMJCEkeU0ErNaFTZIdbhK%2FnMq0jxJbRgxHosYmg%2F%2BvnCMBAVaDlML5ADpfFrXQ895zH0vzruFrUF2ISjmsVbTtZg6R%2BFayw%2BmVyl39SdboDS0PD%2FVkMgXEkqaCAXQJlkYHsI%2B" rel="nofollow" target="_blank">【有搜必应】HarmonyOS 热搜技术问题解析第二期</a></p>]]></description></item><item>    <title><![CDATA[【有搜必应】HarmonyOS Top1]]></title>    <link>https://segmentfault.com/a/1190000047388813</link>    <guid>https://segmentfault.com/a/1190000047388813</guid>    <pubDate>2025-11-11 12:03:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文原创发布在<a href="https://link.segmentfault.com/?enc=hdPTtIGIFBeXETdYen5RqQ%3D%3D.teJhu9HC%2BdBinLs7xujCF3MKCTgI%2F3bYoeRd9nVf8bbqUSr4fD8F4W3KmbeyhOODqPSfrezdvsoYwOByoCABBZ7uXKVuUFvSmx4VC4eYT4%2Fo46PUbjAavhw6EbGXwNaA" rel="nofollow" target="_blank">华为开发者联盟社区</a>，欢迎前往与更多开发者进行互动。 </p><p>更多相关问题可点击原帖进行交流：<a href="https://link.segmentfault.com/?enc=neV4PdAZvUPt9ArRg%2Fiwvg%3D%3D.Apz4B0F7gl1%2Fdz30%2BIMTLRoUWR%2B4zSn%2FraUJSqPoCE7ijo3f1zzLcCN2HRjiehWhiQYF4o82DWpn0Ia8SHuwB9g9%2BViszm3bCmyv71YB5ExuT4vxxJuCub1jatgs6RLuX7QZwPTLSf30JKHoNwW%2Fr%2BxvS%2BVcAviq1GNhy3UR7t%2Fe0gkF2WFUcq4la%2ByIvxM9" rel="nofollow" target="_blank">【有搜必应】HarmonyOS Top10热搜技术问题解析第一期</a>。</p><h4>HarmonyOS开发者小伙伴们</h4><p>每一个搜索词的背后，都是您最迫切的技术问题诉求与最真实的痛点；每一个热搜词的背后，更代表了众多开发者遇到的共性难题。为助力大家扫清Top开发障碍，我们选取了社区高频的热搜问题，进行深入剖析，推出《有搜必应》专栏，旨在集中解决共性问题，为大家勾勒一份鸿蒙开发的"热点地图"。在精准定位问题的基础上，我们将提供一份经过验证的解决方案与最佳实践，化热搜问题为能力提升的阶梯，让每一次技术探索事半功倍，助力大家在鸿蒙开发之路上行得更稳、更远。</p><h4>本期热搜揭秘</h4><p><strong>【开发工具】</strong></p><p><a href="https://link.segmentfault.com/?enc=3asnbcxh0%2BBPUtm1VhQ%2BAg%3D%3D.pic9AwKGJEtU3kOWr3TJ%2Fgrr1VhkDMxjBoTzU9Kgr%2Fb2Z7f5vOmlAAPdHm5oEzMZX9WIGOep41yRV11fOFgyf1dEY4jewjJOpwK7wXkTua4pjqJ7iTB0z0KSX1JulcBuJgwvUCHMyYVWd8Hr%2FUCmGg%3D%3D" rel="nofollow" target="_blank">▶ DevEco Studio创建项目后显示ohpm Install failed如何解决?</a></p><p><a href="https://link.segmentfault.com/?enc=1DreGoOBNjqjtMIctaRhtw%3D%3D.MBibpCHZH1wer5kZ11njNoQVDPPjzhAQv4SZN6ZEYRcHzLfSt%2BzIrEg3XgGKOAHZq%2FGwH1OH%2FdaWdwRpcyDdts7OJ5y3DynSkcbBdATR463KuDwLMDya0kNvBeumh4EM2mfeAbReoGEUZK8Z0vXnxg%3D%3D" rel="nofollow" target="_blank">▶ 新建工程后模拟器上运行失败，提示Please try to match the API version of the device and the app</a></p><p><a href="https://link.segmentfault.com/?enc=tXEcoYRugv0vohG%2FH6Gbew%3D%3D.KdKCcL4gpEP2ctjwHrt8dyIrxlmRg6eWCqMqfYnuJcsXLgHYyltnTvQagWN0Mz%2FICptN2t0333fXx9XjL82%2FjzfGNP1FBa9dIluUzLeOiSQKOxkVTH%2BWiLLvWlEQEg0iv0Pha9cqL7It8wKtpsFgyw%3D%3D" rel="nofollow" target="_blank">▶ DevEco Studio如何引用其他工程下的Module?</a></p><p><strong>【应用框架】</strong></p><p><a href="https://link.segmentfault.com/?enc=HzDIbxEO2r%2BBiniivx%2BH8Q%3D%3D.FwYeEBrFliUIfTGmjkOYLCdRWhNSUv9ZxZKUJETjAPaM2OGxnBilCHjynsm3TwdZy4qRzBG9NS2YHI4iQ926rbjojLAL567XnuddTR420YS1cwxIM759gpfp1rm2wLcFbspdTCDNDTneu0pt%2Fa2GFA%3D%3D" rel="nofollow" target="_blank">▶ 如何解决ArkTS报错:Object literal must correspond to some explicitly declared class or interface</a></p><p><a href="https://link.segmentfault.com/?enc=Qjk2rutXnnIrXTJ1SD8FMQ%3D%3D.ZLZSaFPKyCucP4n102nTXvhUQDVCv1Gas0%2BQlCnYmsd0PCL4kLwju6Yhncpi8Megligj1r77wXCiOxiOvoUjEIxq3zJf7h9AsTA7eAWhpsw1ZHeczJbGPezGEMwI6ls5McPMWmxfGntJy1xZPjIYRZo0tyexwgH%2BLtqo7z3zzqeQV71AdPk40OkNFEQJBYBd" rel="nofollow" target="_blank">▶ PixelMap与ArrayBuffer如何相互转换？</a></p><p><a href="https://link.segmentfault.com/?enc=fuNlWnLY%2FkwE1MwO%2BVhIwQ%3D%3D.00hX4rHY0VMJ8SrNcX7mqE%2BhFWqhbpNRNBjiOvWbW8Kv5VMM25wWlcc1ePXdwtH1fNi6ty0G9IR3WM8BEUOn00yDsfQPkbFjm75Ht6DPImTjfYc43roXdX0j1IDwZ%2B9V7sV%2FNDKs4sFbxpbuoZdrTg%3D%3D" rel="nofollow" target="_blank">▶ Map 与 Record 的使用详解</a></p><p><strong>【编译构建】</strong></p><p><a href="https://link.segmentfault.com/?enc=iZDcCO2eoiWkuLXIEvOG6g%3D%3D.mLak%2FxFgB%2FDpVCFISnQ78F3gRBBXk5e70QvFcdnIcxr2QHyxMpAtwN6N2HDHfL0I7k9qYjrqa42Q%2Fq7hoqkjblPK35x%2FVDymhzM07unnUcJ5g8osYxJLHxCaN8W6wUhA6uGX7FVBTH%2FYKSZZdyQI5w%3D%3D" rel="nofollow" target="_blank">▶ 应用打包报错：error: failed to install bundle. code:9568289</a>  </p><p><a href="https://link.segmentfault.com/?enc=Ie9oQ7PaGZv7QF9HLxxcgw%3D%3D.9SEjggJ4CY7sAZEXHbqoWjB8rbIoZVmYCq7Y5W50vs05h4gmYovXMhKNjJmCsI65wNNxaQE8NfBh%2FiQjFhHa%2FDGfxBO1TEVIObGbt4EPn7euZQLC%2BbHEz9QVaPNR1EmpMJPDg7JwFMxSlvPyU4DDOw%3D%3D" rel="nofollow" target="_blank">▶ DevEco Studio工程ohpm安装hypium、hamock超时报错怎么办</a></p><p><strong>【Web】</strong></p><p><a href="https://link.segmentfault.com/?enc=%2BDuvpz%2FmJjAA8sOfsDHD5g%3D%3D.oqEPk1zyQKz9KNaEJeuGNWIv%2Ffinovexd%2B2IrltGeQSvJPftQwotOTb4926RdQkyxPKtJhcP9AIiHIDRuO3lJbxXeGBsxLnU5j%2FRd3msJ7GjHQR9MNyzwPqQPFnuKljZJEusB2r%2BjxdKGi%2BitmNXTpSFi1HckPRG03itLrhrZyXvnQwM9snV2SBS3CzoSpGe" rel="nofollow" target="_blank">▶ Web组件如何拦截请求并重定向？</a></p><p><strong>【ArkUI】</strong></p><p><a href="https://link.segmentfault.com/?enc=vV6H%2FyFcuvzXlC%2FJ8VkgGA%3D%3D.1lFeH8o41L5X7ZJMUW5Gg5Fp1F96lp3Fuy52zKAoicBuR1cBwmGBKBTigncddhI8YCVdLUqyF6aHti3XUS18toyq%2FI46q7ENd9cpdCzP6VE1at2wGfYeHgYJMjI6puLDCdIkQtYSztCXdwA09YcoNA%3D%3D" rel="nofollow" target="_blank">▶ onVisibleAreaApproximateChange事件中expectedUpdateInterval属性限制它的执行间隔的执行规则是什么样的？</a>  </p><p>本期梳理的热搜问题是我们共同探索技术风向的起点，期待您在论坛中继续发声：无论是提出新的疑惑、发表见解、或分享实战经验，都会为鸿蒙社区注入前行的力量，也是让我们做的更好的动力！</p><p>若您存在疑惑，可使用社区-问答-"我要提问题"进行提问。<a href="https://link.segmentfault.com/?enc=G%2BbbKjT8e1vxQHI8i96Yyg%3D%3D.p7XnLbNiMofwnOlpA1a65b0KaFsjY7mWM8Fkl0TZ5kIA9n2k4%2B2t0EBtC85FsuxIUZiAorWkwsPVnMIU37J6pVi68Uc6Y6l9aYqwq8WlcFWvMy%2BDRDIcnIqCojKnM8kd" rel="nofollow" target="_blank">问答专区-华为/鸿蒙开发者论坛-华为开发者联盟 (huawei.com)</a></p>]]></description></item><item>    <title><![CDATA[阿里云通过中国信通院首批安全可信中间件评]]></title>    <link>https://segmentfault.com/a/1190000047388815</link>    <guid>https://segmentfault.com/a/1190000047388815</guid>    <pubDate>2025-11-11 12:02:53</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>近日，由中国信通院主办的 2025（第五届）数字化转型发展大会在京举行。会上，“阿里云应用服务器软件 AliEE”、“消息队列软件 RocketMQ”、“云数据库 Tair”三款产品成功通过中国信通院“安全可信中间件”系列评估，成为首批获此认证的中间件产品。</p><p>此次评估覆盖安全可信要求、功能完备性、安全防护能力、性能表现、可靠性与可维护性等核心指标，标志着阿里云中间件产品在多架构适配与安全能力上达到行业领先水平。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388817" alt="image" title="image"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388818" alt="image" title="image" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388819" alt="image" title="image" loading="lazy"/></p><h2>以产品技术创新，助力政企数智化</h2><p>中国信通院联合行业头部企业共同制定《安全可信中间件能力要求》系列标准，并于 2025 年 6 月启动评估工作。评估聚焦消息、应用服务器、负载均衡与分布式缓存四类中间件，通过全面可量化的评价方案，为产业提供建设、应用参考，促进自主中间件产业生态健康有序发展。</p><p>阿里云以 AliEE、RocketMQ、Tair 为核心的安全可信中间件产品矩阵，通过中国信通院评估认证，不仅验证了产品在多架构与安全领域的卓越能力，更为政企用户提供高可用、高性能、高安全的数字化转型底座。</p><p><strong>1. AliEE 应用服务器：多架构全栈适配，AI 赋能安全架构</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388820" alt="image" title="image" loading="lazy"/></p><ul><li><strong>多架构全栈兼容：</strong> 深度适配<strong>国产芯片、国产操作系统及 PolarDB/OceanBase/达梦/金仓等国产数据库</strong>，满足企业核心系统自主可控需求。</li><li><strong>AI 大模型集成支持：</strong> 拥抱人工智能技术演进，为传统 J2EE 应用提供对接 AI 大模型的能力，赋能企业智能化转型。通过标准化接口，应用可便捷调用大模型服务，加速企业智能化转型的同时，保护企业传统应用软件资产。</li><li><strong>云原生容器化支持：</strong> 支持 Docker、Kubernetes 等主流容器技术，支持 JAR、WAR、EAR 等传统应用包直接部署至容器环境。集成自动伸缩机制，可根据业务负载动态调整实例数量与资源配额，实现资源的智能调度与成本优化，助力企业实现敏捷交付与弹性扩展。</li><li><strong>微服务治理与互联互通：</strong> 依托企业级分布式应用服务（EDAS），提供开箱即用的微服务治理能力。内置服务注册发现、链路追踪，支持 RESTful/gRPC/Dubbo 多协议互通，保障传统 EJB 与现代 SpringCloud /Dubbo 架构衔接。</li></ul><p><strong>2. RocketMQ 消息队列：多架构混合部署，金融级安全防护</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388821" alt="image" title="image" loading="lazy"/></p><ul><li><strong>多架构支持：</strong> 深度适配国产芯片、国产操作系统，已在政务、金融、能源、文化传媒等行业实现多架构部署。</li><li><strong>金融级安全防护：</strong> 支持 TLS1.2/1.3 加密传输、消息落盘加密，结合 RAM 授权、ACL 控制与 VPC 隔离，满足银行等金融行业客户的安全合规要求。</li><li><strong>全域容灾能力：</strong> 支持同城容灾、异地多活，RTO 秒级切换，SLA&gt;99.99%，保障核心系统零数据丢失。</li><li><strong>弹性扩缩容：</strong> 支持集群快速扩缩容，某物流头部企业实现 300+ 节点快速扩容。</li><li><strong>智能运维体系：</strong> 集成 Prometheus 监控、AIOPS 巡检，支持异常检测、根因分析与自愈建议。</li></ul><p><strong>3. Tair 缓存数据库：性能跃升+全栈安全护城河</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047388822" alt="image" title="image" loading="lazy"/></p><ul><li><strong>兼容性与性能突破：</strong> 完全兼容 Redis 协议，应用无需改造即可平滑迁移，同时通过多线程架构优化，突破传统Redis单线程性能瓶颈，实现<strong>数倍于开源 Redis 的吞吐性能</strong>，轻松应对“双 11”级流量洪峰。</li><li><p><strong>全栈安全防护体系：</strong></p><ul><li>网络隔离：默认拒绝所有访问请求，仅允许白名单 IP 连接。支持 VPC 部署，结合安全组策略实现精细的网络访问控制。支持 TLS 加密协议，对客户端与数据库间的传输链路进行加密。</li><li>存储加密：支持透明数据加密（TDE），防止数据泄露。</li><li>权限管控：基于角色的细粒度权限控制+审计日志，满足等保合规要求。</li></ul></li><li><strong>高可用架构：</strong> 支持跨可用区部署、跨地域多活部署，支持秒级故障探测与自动切换，RTO&lt;30 秒，保障业务连续性。</li><li><strong>专有云深度优化：</strong> 深度适配<strong>国产芯片</strong>，并进行底层性能调优，充分发挥硬件潜力，实现亚毫秒级稳定时延。</li></ul><p>面向未来，阿里云将持续深耕中间件核心技术，强化在分布式架构、实时数据处理、内存加速等领域的创新突破，进一步提升产品的安全可信能力。同时，也将携手生态伙伴与行业用户，共同推动标准建设与最佳实践落地，助力构建开放、可信、可持续的数字生态，为数字中国发展筑牢技术根基。</p>]]></description></item><item>    <title><![CDATA[Excel 文件中添加或删除分节符【Ja]]></title>    <link>https://segmentfault.com/a/1190000047388841</link>    <guid>https://segmentfault.com/a/1190000047388841</guid>    <pubDate>2025-11-11 12:02:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在复杂的Excel报表中，合理设置分节符能有效提升文档结构与可读性，尤其在打印输出时效果显著。然而，手动调整效率低下，如何通过Java代码实现自动化管理？本文将深入探讨如何利用Spire.XLS for Java库，轻松实现Excel分节符的添加与删除，助您告别繁琐。</p><h2>库介绍与安装</h2><p>Spire.XLS for Java是一个功能强大的Java组件，它允许开发者在Java应用程序中创建、读取、编辑和转换Excel文件，而无需安装Microsoft Office。其主要优势包括：</p><ul><li>独立性强: 完全由Java编写，不依赖于Microsoft Office或其他第三方软件。<br/> -功能全面: 支持Excel的众多特性，如单元格样式、公式、图表、图像、批注、条件格式、数据验证等。</li><li>性能优越: 针对大量数据处理进行了优化，能高效处理大型Excel文件。</li><li>易于集成: 提供清晰的API接口和丰富的文档示例，方便开发者快速上手。</li></ul><p>要开始使用Spire.XLS for Java，您需要将其作为依赖项添加到您的Maven或Gradle项目中。</p><p>下面我们使用 Maven 来示例，通过在pom.xml文件中添加以下代码导入JAR文件。</p><pre><code class="xml">&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;com.e-iceblue&lt;/id&gt;
        &lt;name&gt;e-iceblue&lt;/name&gt;
        &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.xls&lt;/artifactId&gt;
        &lt;version&gt;15.10.5&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><p>就可以很方便地将Spire.XLS安装到设备上，简单检查一下，我们就可以进入今天的正题了。</p><h2>Java 在 Excel 中添加分节符</h2><p>Excel中的分节符（或称分页符）用于将工作表内容划分为独立的页面，这对于打印或者分段查看数据非常有用。它主要分为水平分页符和垂直分页符。</p><p>以下代码演示了如何使用Spire.XLS for Java在指定位置添加水平和垂直分节符。</p><pre><code class="java">import com.spire.xls.*;

public class AddPageBreak {
    public static void main(String[] args) {
        //创建Workbook类的实例
        Workbook workbook = new Workbook();
        //加载Excel文档
        workbook.loadFromFile("test.xlsx");

        //获取第一个工作表
        Worksheet sheet = workbook.getWorksheets().get(0);

        //在指定位置添加水平分页符
        sheet.getHPageBreaks().add(sheet.getCellRange("H15"));
        //在指定位置添加垂直分页符
        sheet.getVPageBreaks().add(sheet.getCellRange("H15"));

        //将视图设置为分页预览模式查看效果
        sheet.setViewMode(ViewMode.Preview);

        //保存文档
        workbook.saveToFile("AddPageBreaks.xlsx", ExcelVersion.Version2010);
    }
}</code></pre><p><strong><em>关键API说明：</em></strong></p><ul><li><code>sheet.getHPageBreaks().add()</code>：在指定单元格的上方添加一个水平分页符。</li><li><code>sheet.getVPageBreaks().add()</code>：在指定单元格的左侧添加一个垂直分页符。</li><li><code>sheet.setViewMode()</code>：设置Excel的视图模式为分页预览，方便查看分页效果。</li></ul><h2>Java 在 Excel 中删除分节符</h2><p>当不再需要分节符时，Spire.XLS for Java也提供了灵活的删除方法。您可以选择删除特定位置的分节符，也可以清除工作表中的所有分节符。</p><pre><code class="java">import com.spire.xls.*;

public class RemovePageBreak {
    public static void main(String[] args) {
        //创建Workbook类的实例
        Workbook workbook = new Workbook();
        //加载Excel文档
        workbook.loadFromFile("AddPageBreaks.xlsx");

        //获取第一个工作表
        Worksheet sheet = workbook.getWorksheets().get(0);

        //删除所有水平分页符
        sheet.getHPageBreaks().clear();
        //删除所有垂直分页符
        sheet.getVPageBreaks().clear();

        //删除第一个水平分页符
        //sheet.getHPageBreaks().removeAt(0);
        //删除第一个垂直分页符
        //sheet.getVPageBreaks().removeAt(0);

        //将视图设置为分页预览模式查看效果
        sheet.setViewMode(ViewMode.Preview);

        //保存文档
        workbook.saveToFile("RemovePageBreaks.xlsx", ExcelVersion.Version2010);
    }
}</code></pre><p><strong><em>关键API说明：</em></strong></p><ul><li><code>sheet.getHPageBreaks().removeAt(</code>)：根据索引删除一个水平分页符。</li><li><code>sheet.getVPageBreaks().removeAt()</code>：根据索引删除一个垂直分页符。</li><li><code>sheet.getHPageBreaks().clear()</code>：清除当前工作表中的所有水平分页符。</li><li><code>sheet.getVPageBreaks().clear()</code>：清除当前工作表中的所有垂直分页符。</li></ul><h2>常见问题与注意事项</h2><ul><li><strong>许可证问题</strong>：Spire.XLS for Java的免费版本支持处理最多包含100个工作表和每个工作表最多10000行数据的Excel文件。如果您的项目需要处理更大型的文件，或者需要去除试用版水印，则需要购买商业许可证。</li><li><strong>性能优化</strong>：对于处理非常大的Excel文件，建议分批读取和写入数据，或者在内存中进行优化处理。避免频繁的文件I/O操作可以显著提升性能。</li><li><strong>错误处理</strong>：在实际项目中，务必加入健壮的异常处理机制（如try-catch块），以应对文件不存在、文件损坏或库操作失败等情况。</li><li><strong>版本兼容性</strong>：Spire.XLS for Java支持多种Excel文件格式（如.xls, .xlsx, .xlsm等），但在保存时，选择合适的ExcelVersion（如ExcelVersion.Version2016）可以确保最佳的兼容性。</li></ul><h2>结语</h2><p>通过本文的详细讲解与代码示例，我们不难发现，Spire.XLS for Java为Excel分节符的自动化管理提供了强大且便捷的解决方案。无论是复杂报表生成还是批量文档处理，掌握这项技能都将极大地提升您的工作效率。立即动手实践，让Java成为您Excel操作的得力助手！</p>]]></description></item>  </channel></rss>