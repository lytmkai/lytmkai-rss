<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[阿里云 EMR Serverless Spark TPC-DS 100T 榜首背后的内核技术 阿里云]]></title>    <link>https://segmentfault.com/a/1190000047609129</link>    <guid>https://segmentfault.com/a/1190000047609129</guid>    <pubDate>2026-02-13 12:09:18</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>演讲者：一锤（周克勇）| EMR Serverless Spark 技术负责人</strong></p><p>2025年9月，阿里云EMR Serverless Spark 以QphDS超6568万分的性能结果成功登顶TPC-DS 100T榜单，这是全球大数据领域最具权威性和挑战性的性能测试基准。<br/><img width="723" height="518" referrerpolicy="no-referrer" src="/img/bVdnVtc" alt="" title=""/><br/>阿里云EMR Serverless Spark TPC-DS 100T 性能测试结果</p><blockquote>TPC-DS Benchmark是数据仓库领域最新和最复杂的权威测试标准，被工业界和学术界广泛认可，也是数据仓库选型的重要参考指标。TPC-DS包含99个查询，从简单的全局聚合到复杂的20以上多表连接，体现了真实分析场景日益增长的复杂度。其中，100T是TPC-DS提供的最大测试数据集，最大表有288,017,344,252（2880亿）条数据，迄今为止只有阿里云EMR和Databricks成功通过了该榜单的官方评审。</blockquote><p>阿里云 EMR Serverless Spark实现了 <strong>性能提升100%</strong>、<strong>性价比提升500%</strong> 的突破，证明了EMR Serverless Spark 在 OpenLake湖仓底座架构下，超大规模、超高复杂度的数据分析、数据更新、数据处理的市场领先能力。<br/><img width="723" height="224" referrerpolicy="no-referrer" src="/img/bVdnVtd" alt="" title="" loading="lazy"/></p><p>本文将深入剖析支撑这一成绩背后的技术内核，从产品定位、架构设计到核心优化策略，全面解读 EMR Serverless Spark 如何实现“高性能、低成本、高弹性、强兼容”的统一。</p><h2>产品定位与核心场景</h2><p>EMR Serverless Spark 定位为新一代 <strong>Lakehouse（湖仓一体）平台</strong>，旨在融合传统数据仓库的极致查询性能与数据湖的低成本、开放性优势。</p><p>其核心聚焦三大场景：</p><ol><li><strong>湖仓分析场景</strong>：以高度优化的 Spark 替代 Hive 执行 ETL/ELT 任务，替代 Trino/Presto 提供高性价比交互式分析。支持 SQL、DataFrame、Pandas、RDD 等多种接口，并全面兼容 Paimon、Iceberg、Delta、Hudi 等主流湖表格式。</li><li><strong>机器学习场景</strong>：作为成熟的分布式 ML 框架，Spark 支持从数据清洗、特征工程到模型训练与批量推理的全流程。内置 MLlib，集成 XGBoost、LightGBM、scikit-learn 等生态工具，并提供 GPU 加速能力，实现 Data + AI 一体化。</li><li><strong>多模态数据处理场景</strong>：随着大模型兴起，PySpark 成为处理文本、图像、视频等非结构化数据的理想选择。产品推出的 <strong>AI Function</strong> 功能，允许用户在 Spark 作业中直接调用大模型。针对基模训练数据预处理做了专门优化，在文本去重任务中实现 <strong>5倍性能提升</strong>。<br/><img width="723" height="392" referrerpolicy="no-referrer" src="/img/bVdnVte" alt="" title="" loading="lazy"/></li></ol><h2>产品架构与极致弹性</h2><p>EMR Serverless Spark 采用标准 Lakehouse 架构：</p><ul><li><strong>存储层</strong>：基于阿里云 OSS 对象存储与 OSS-HDFS 接口，提供高吞吐、低成本的持久化能力；</li><li><strong>元数据层</strong>：兼容 Hive Metastore（HMS）与 Data Lake Formation（DLF），支持 ACID 事务；</li><li><strong>资源层</strong>：依托阿里云全 Region 的 ECS 资源池，实现近乎无限的弹性供给；</li><li><strong>引擎层</strong>：核心创新包括 <strong>Fusion 向量化执行引擎</strong> 与 <strong>Celeborn Remote Shuffle Service</strong>；</li><li><strong>产品层</strong>：提供认证鉴权、开发 IDE、资源监控、智能诊断等企业级功能。</li></ul><p><strong>极致弹性</strong> 是其关键竞争力：</p><ul><li>支持 <strong>进程级弹性</strong>，最小资源单位低至 1 Core；</li><li>容器启动时间 &lt;15 秒，会话模式、Standalone模式下实现“零冷启”；</li><li>采用 Workspace + 队列的双层 Quota 机制，满足多租户资源隔离需求；</li><li>实际客户案例显示，资源使用波动可从数万核骤降至零，Serverless 架构帮助客户 <strong>节省40%资源成本</strong>。</li></ul><p>此外，系统默认提供 <strong>跨可用区高可用</strong> 能力，Spark 控制面与 Celeborn 服务均多 AZ 部署，作业自动故障迁移，SLA 达 99.9%，且无额外费用。<br/><img width="723" height="516" referrerpolicy="no-referrer" src="/img/bVdnVtf" alt="" title="" loading="lazy"/><br/>EMR Serverless Spark 产品架构</p><h2>全方位生态兼容</h2><p>EMR Serverless Spark 坚持 <strong>开放生态优先</strong> 的设计理念：</p><ul><li><strong>接口兼容</strong>：完整支持 spark-submit、spark-sql、beeline、JDBC 等经典方式，也集成 Kyuubi（含 HA）、Livy 等交互式查询服务；</li><li><strong>工具链集成</strong>：无缝对接 Jupyter、Zeppelin、Superset、DBT 等主流开发分析工具；</li><li><strong>调度系统</strong>：深度适配 Airflow、DolphinScheduler，并在阿里云生态内与 <strong>DataWorks 原生集成</strong>——作为DataWorks“一等公民”，支持 SQL 节点、Notebook、工作流编排、统一权限与数据血缘等；</li><li><strong>安全与元数据</strong>：支持 Kerberos、LDAP、Ranger；</li><li><strong>湖格式</strong>：湖格式覆盖 Paimon/Delta/Hudi/Iceberg；</li><li><strong>外部数据源</strong>：连接 StarRocks、Doris、Hologres、HBase、Elasticsearch、MongoDB、MaxCompute、MySQL 、Postgres等数十种系统。</li></ul><p>这种广泛的兼容性极大降低了用户迁移和集成成本，真正实现“开箱即用”。<br/><img width="723" height="404" referrerpolicy="no-referrer" src="/img/bVdnVtg" alt="" title="" loading="lazy"/></p><h2>TPC-DS 100T 背后的四大核心技术</h2><p>官方TPC-DS 100T 测试包含数据生成、导入、Power Test（单并发99查询）、Throughput Test（4并发396查询）、Maintenance Test（Upsert 操作）等环节，最终通过 QphDS 分数衡量综合性能。</p><p>阿里云的突破源于以下四大技术创新：</p><h3>1. Fusion 向量化执行引擎</h3><p>自2019年起研发，Fusion 将 Spark 从行式计算升级为 <strong>列式向量化执行</strong>：</p><ul><li>利用 SIMD 指令并行处理多列数据；</li><li>连续内存布局显著提升 CPU Cache 命中率；</li><li>异步 IO 与 IO 合并优化读取效率；</li><li>关键算子（Sort/Window/Join）优化，性能提升达 <strong>300%</strong>。</li></ul><p>在 TPC-DS 场景中，Fusion 还引入 Subplan Reuse、Broadcast Join Reuse、Semi Join 哈希表去重等优化，大幅减少重复计算与内存占用。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdnVth" alt="" title="" loading="lazy"/></p><h3>2. 与 Paimon 深度协同</h3><p>Fusion 与阿里自研湖表格式 Paimon 深度整合：</p><ul><li>向量化读写使读性能提升 <strong>70%</strong>，写性能提升 <strong>30%</strong>；</li><li>Variant 类型相比原始 JSON 提升 <strong>178%</strong>；</li><li>Shredding 技术进一步加速JSON解析，性能再提升 <strong>364%</strong>。</li></ul><h3>3. Celeborn Remote Shuffle Service</h3><p>作为 Apache 顶级项目，Celeborn 采用 <strong>推送式 Shuffle 架构</strong>：</p><ul><li>在大规模作业中提供更高吞吐与更低延迟；</li><li>支持副本容错与Stage重算，保障作业稳定性；</li><li>大规模生产验证，成为业界事实标准。</li></ul><h3>4. DLF 3.0 与优化器增强</h3><p>基于 Paimon 的 DLF 3.0 提供高性能 ACID 能力，满足 TPC-DS Maintenance 测试要求；同时优化器在 Join 顺序选择、代价模型等方面持续迭代，提升复杂查询效率。</p><p><strong>最终成果</strong>：在仅使用一半内存的情况下，QphDS 性能翻倍，性价比提升5倍，所有结果均通过 TPC 官方严格审计。<br/><img width="723" height="404" referrerpolicy="no-referrer" src="/img/bVdnVti" alt="" title="" loading="lazy"/></p><h2>AI 时代的新功能：让 Spark 成为 AI 基础设施</h2><p>面对 AI 浪潮，EMR Serverless Spark 推出多项创新功能：</p><ul><li><strong>AI Function</strong>：内置 <code>ai_query</code>、<code>ai_sentiment</code>、<code>ai_classify</code>、<code>ai_embedding</code> 等函数，用户可在 SQL 中直接调用大模型，如同使用内置 UDF。支持接入百炼、OpenAI、PAI EAS 或本地 GPU 模型。</li><li><p><strong>Spark on GPU</strong>：提供弹性 GPU 实例，按需配置 CPU/GPU 混合机型，避免固定集群成本。支持：</p><ul><li>AI Function 本地 GPU 推理；</li><li>Spark ML（XGBoost/LightGBM）GPU 加速；</li><li>Spark SQL 向量化 GPU 计算。</li></ul></li></ul><p><img width="723" height="407" referrerpolicy="no-referrer" src="/img/bVdnVtj" alt="" title="" loading="lazy"/></p><ul><li><p><strong>即将上线功能</strong>：</p><ul><li><strong>Spark + Ray 双引擎融合</strong>：满足 Python 分布式与异构计算需求；</li><li><strong>DuckDB 集成</strong>：针对中小数据分析，在 Notebook 中已内置，未来支持直连 DLF 3.0；</li><li><strong>文本去重加速</strong>：在 FineWeb-edu（8TB、30亿文档）上，800 核仅需 72 分钟，提速 5 倍。</li></ul></li></ul><h2>携手客户共同成长</h2><p>EMR Serverless Spark 已在多家金融、互联网、智能硬件及零售企业的生产环境中稳定运行，广泛应用于数据仓库加速、实时风控、向量检索、机器学习等核心场景。</p><p>同时，Celeborn 社区也在多个头部互联网平台和科技企业中落地，支撑高并发、大规模的数据计算需求。</p><p>阿里云 EMR Serverless Spark 的 TPC-DS 登顶，不仅体现了优异性能，更体现了架构理念、工程能力和生态战略。在 Data + AI 融合的新时代，它正成为企业构建下一代智能数据基础设施的核心引擎。</p>]]></description></item><item>    <title><![CDATA[鸿蒙设备间数据共享实践 江南一点雨 ]]></title>    <link>https://segmentfault.com/a/1190000047609136</link>    <guid>https://segmentfault.com/a/1190000047609136</guid>    <pubDate>2026-02-13 12:08:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在万物互联时代，用户身边的智能设备呈现多元化态势，手机、平板、智慧屏、智能穿戴设备、车机等已成为日常必备。鸿蒙操作系统（HarmonyOS）作为面向全场景的分布式操作系统，其核心优势之一便是打破设备硬件边界，实现多设备协同联动，而设备间数据共享则是这一优势落地的关键支撑——它让数据能够“随人而动”，在不同设备间无缝流转，为用户提供连贯、统一的全场景体验。本文将结合实际开发场景，详细拆解鸿蒙设备间数据共享的问题背景、具体对接步骤及最佳实践，助力开发者快速掌握相关技术要点，高效完成跨设备数据共享功能开发。</p><h2>一、问题背景：跨设备数据共享的痛点与鸿蒙的解决方案</h2><p>随着全场景智能生态的普及，跨设备数据共享已成为用户核心需求，但传统设备间的数据交互模式的诸多痛点，严重影响了用户体验和开发效率，具体表现为以下三点：</p><p>其一，协议碎片化严重。不同设备、不同厂商采用的通信协议各异（如蓝牙、Wi-Fi、ZigBee等），开发者需为每种协议单独开发适配代码，不仅增加了开发成本，还导致设备间兼容性差、连接不稳定，难以实现无缝协同。例如，手机与平板间的文档同步的、穿戴设备与手机的健康数据传输，往往需要适配不同的通信协议，开发周期大幅延长。</p><p>其二，数据同步效率低、隐私风险高。传统同步方案多采用“中心化上传-下载”模式，数据需经过第三方服务器中转，不仅存在延迟高、带宽浪费的问题，还可能导致敏感数据（如健康记录、私密文档）泄露。例如，家庭相册同步需手动上传至云端，再由其他设备下载，不仅耗时，还存在隐私泄露隐患。</p><p>其三，开发复杂度高、体验割裂。传统跨设备数据共享需开发者手动处理设备发现、连接建立、数据传输、异常处理等全流程，涉及多层面技术细节，开发门槛高；同时，不同设备间的数据同步缺乏统一管理，易出现数据不一致、同步中断等问题，导致用户体验割裂——如手机上编辑的待办事项，无法实时同步至平板，影响办公效率。</p><p>针对上述痛点，鸿蒙操作系统依托分布式软总线、分布式数据管理（DDM）、远程过程调用（RPC）等核心技术，构建了一套统一的跨设备数据共享解决方案，其核心优势体现在三个方面：一是通过分布式软总线屏蔽底层通信协议差异，实现设备间自动发现、低延迟、高速率连接，无需开发者手动适配多协议；二是采用去中心化架构，支持设备间直接同步数据，结合端到端加密技术，兼顾同步效率与隐私安全；三是提供标准化API和开发框架，简化设备发现、服务注册、数据传输等流程，降低开发门槛，同时通过分布式数据管理实现数据统一管控，确保多设备数据一致性。</p><p>鸿蒙设备间数据共享的核心技术底座包括：分布式软总线（负责设备发现与高速通信）、分布式数据管理（负责数据建模、同步与权限控制）、RPC（负责上层应用跨设备接口调用），三者协同工作，为开发者提供“一次开发、多端部署”的标准化数据共享能力，真正实现数据“随人而动”的全场景体验。</p><h2>二、具体案例对接步骤：基于ArkTS实现跨设备文本同步</h2><p>为让开发者更直观地掌握鸿蒙设备间数据共享的实现流程，本文以“手机与平板跨设备文本同步”为具体案例，基于鸿蒙6.0（API21）、ArkTS语言、Stage模型，详细拆解从环境准备到功能落地的完整对接步骤。该案例实现的核心功能为：手机端输入文本，实时同步至已连接的平板端，平板端接收文本后实时更新UI，同时支持设备断开后的重连同步。</p><h3>2.1 案例前置准备</h3><p>在开始开发前，需完成环境配置、权限申请等前置操作，确保开发环境与设备满足开发要求：</p><ol><li>开发环境：DevEco Studio 5.0（适配鸿蒙6.0），确保已配置鸿蒙6.0 SDK（API21），支持ArkTS语言开发；</li><li>测试设备：2台搭载鸿蒙6.0及以上系统的设备（手机+平板），登录同一华为账号（用于设备自动认证），开启Wi-Fi、蓝牙（确保设备可被发现）；</li><li>权限配置：在项目的module.json5文件中，添加分布式相关权限，用于设备发现、数据同步等操作，具体配置如下：</li></ol><pre><code class="json">{
  "module": {
    "abilities": [...],
    "requestPermissions": [
      {
        "name": "ohos.permission.DISTRIBUTED_DEVICE_STATE_CHANGE",
        "reason": "用于监听分布式设备状态变化（上线/离线）",
        "usedScene": { "when": "always" }
      },
      {
        "name": "ohos.permission.GET_DISTRIBUTED_DEVICE_INFO",
        "reason": "用于获取分布式设备信息（如设备ID、设备类型）",
        "usedScene": { "when": "always" }
      },
      {
        "name": "ohos.permission.DISTRIBUTED_DATASYNC",
        "reason": "用于跨设备数据同步传输",
        "usedScene": { "when": "always" }
      }
    ],
    "dependencies": {
      "@ohos.distributedHardware.distributedDeviceManager": "^1.0",
      "@ohos.rpc": "^1.0"
    }
  }
}</code></pre><ol start="4"><li>核心依赖：引入分布式设备管理（distributedDeviceManager）和RPC（远程过程调用）模块，前者用于设备发现与状态监听，后者用于跨设备接口调用与数据传输。</li></ol><h3>2.2 核心对接步骤（分服务端与客户端）</h3><p>本案例采用“服务端-客户端”架构：平板作为服务端，负责注册远程服务、接收客户端（手机）发送的文本数据并更新UI；手机作为客户端，负责发现服务端设备、绑定远程服务、发送文本数据。整体流程遵循“设备发现→服务注册→RPC接口绑定→跨设备数据传输→数据同步更新”的核心逻辑。</p><h4>步骤1：服务端开发（平板端）——注册远程服务，接收数据</h4><p>服务端的核心职责是定义远程服务接口、注册系统能力，以便客户端能够发现并绑定服务，进而接收客户端发送的数据。具体实现分为两步：</p><ol><li>定义远程服务接口（Stub）：创建继承自RemoteObject的服务端类，实现onRemoteMessageRequest方法，用于处理客户端发送的请求和数据。该类需定义唯一的接口标识符（descriptor），确保与客户端一致，同时实现文本数据接收与UI更新的逻辑。代码示例如下：</li></ol><pre><code class="typescript">import rpc from '@ohos.rpc';
import common from '@ohos.app.ability.common';

// 定义远程服务接口标识符（需与客户端一致）
const SERVICE_DESCRIPTOR = 'com.example.textsync.service';
// 自定义方法标识码（用于区分不同的远程请求）
const TEXT_SYNC_CODE = 1;

// 远程服务Stub类，用于接收客户端数据并处理
export class TextSyncStub extends rpc.RemoteObject {
  // 用于存储接收的文本，关联UI更新
  private textContent: string = '';
  // UI上下文，用于更新页面
  private context: common.UIAbilityContext;

  constructor(descriptor: string, context: common.UIAbilityContext) {
    super(descriptor);
    this.context = context;
  }

  // 处理客户端发送的远程请求
  onRemoteMessageRequest(
    code: number,
    data: rpc.MessageSequence,
    reply: rpc.MessageSequence,
    option: rpc.MessageOption
  ): boolean | Promise&lt;boolean&gt; {
    // 根据方法标识码判断请求类型
    if (code === TEXT_SYNC_CODE) {
      // 读取客户端发送的文本数据
      const receivedText = data.readString();
      console.info(`服务端（平板）接收到文本：${receivedText}`);
      // 更新本地文本内容，并触发UI刷新
      this.textContent = receivedText;
      this.updateUI();
      return true;
    }
    // 未知请求，返回false
    return false;
  }

  // 本地UI更新方法（结合Ability生命周期，更新@State变量）
  private updateUI() {
    // 假设UI页面中有一个@State变量用于展示文本，通过上下文传递更新
    const pageContext = this.context.currentAbility?.currentPage?.getContext();
    if (pageContext) {
      (pageContext as any).updateText(this.textContent);
    }
  }

  // 获取当前接收的文本（供UI页面调用）
  getTextContent(): string {
    return this.textContent;
  }
}</code></pre><ol start="2"><li>注册远程服务：在服务端Ability（平板端页面）中，创建Stub实例，并通过系统能力管理器（SAMgr）注册服务，使客户端能够发现并绑定该服务。代码示例如下：</li></ol><pre><code class="typescript">import featureAbility from '@ohos.app.ability.featureAbility';
import { TextSyncStub } from './TextSyncStub';
import common from '@ohos.app.ability.common';

@Entry
@Component
struct TextSyncServerPage {
  // 远程服务Stub实例
  private stub: TextSyncStub | null = null;
  // UI展示文本（与Stub中的textContent同步）
  @State displayText: string = '等待接收文本...';
  // UI上下文
  private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;

  // 页面加载时初始化并注册服务
  aboutToAppear() {
    this.initRemoteService();
  }

  // 初始化远程服务并注册
  private initRemoteService() {
    // 创建Stub实例，传入接口标识符和上下文
    this.stub = new TextSyncStub(SERVICE_DESCRIPTOR, this.context);
    if (!this.stub) {
      console.error('服务端：创建Stub实例失败');
      return;
    }
    // 注册系统能力（SAID为自定义，范围1000-9999）
    const SAID = 1001;
    featureAbility.registerSystemAbility(SAID, this.stub)
      .then(() =&gt; {
        console.info('服务端：远程服务注册成功（SAID：1001）');
      })
      .catch((err) =&gt; {
        console.error(`服务端：远程服务注册失败，错误信息：${err.message}`);
      });

    // 绑定UI更新回调，接收Stub中的文本更新
    (this.context as any).updateText = (text: string) =&gt; {
      this.displayText = text;
    };
  }

  // 页面卸载时注销服务
  aboutToDisappear() {
    if (this.stub) {
      featureAbility.unregisterSystemAbility(1001)
        .then(() =&gt; {
          console.info('服务端：远程服务注销成功');
        })
        .catch((err) =&gt; {
          console.error(`服务端：远程服务注销失败，错误信息：${err.message}`);
        });
    }
  }

  // UI布局：展示接收的文本
  build() {
    Column({ space: 20 }) {
      Text('平板端（服务端）')
        .fontSize(22)
        .fontWeight(FontWeight.Bold);
      Text(this.displayText)
        .fontSize(18)
        .width('80%')
        .textAlign(TextAlign.Center)
        .padding(15)
        .backgroundColor('#f5f5f5');
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center);
  }
}</code></pre><h4>步骤2：客户端开发（手机端）——发现设备，绑定服务并发送数据</h4><p>客户端的核心职责是通过分布式设备管理器发现目标设备（平板）、绑定服务端的远程服务，然后通过RPC接口发送文本数据。具体实现分为三步：</p><ol><li>设备发现与状态监听：使用DistributedDeviceManager（DDM）创建设备管理实例，监听设备状态变化（上线/离线），过滤出目标设备（平板）并获取其NetworkId（设备唯一标识），为后续绑定服务做准备。代码示例如下：</li></ol><pre><code class="typescript">import deviceManager from '@ohos.distributedHardware.distributedDeviceManager';
import common from '@ohos.app.ability.common';

@Entry
@Component
struct TextSyncClientPage {
  // 设备管理实例
  private dmInstance: deviceManager.DeviceManager | null = null;
  // 目标设备（平板）的NetworkId
  @State targetDeviceId: string = '';
  // RPC代理对象（用于绑定服务端服务）
  private proxy: rpc.RemoteObject | null = null;
  // 客户端输入的文本
  @State inputText: string = '';
  // UI上下文
  private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;

  // 页面加载时初始化设备管理器，监听设备状态
  aboutToAppear() {
    this.initDeviceManager();
  }

  // 初始化设备管理器
  private initDeviceManager() {
    // 创建设备管理实例
    deviceManager.getDistributedDeviceManager(this.context)
      .then((dm) =&gt; {
        if (!dm) {
          console.error('客户端：创建设备管理器失败');
          return;
        }
        this.dmInstance = dm;
        console.info('客户端：设备管理器初始化成功');

        // 监听设备状态变化（上线/离线）
        this.dmInstance.on('deviceChange', (deviceInfos: Array&lt;deviceManager.DeviceInfo&gt;) =&gt; {
          deviceInfos.forEach((info) =&gt; {
            // 过滤目标设备：平板（deviceType为TAB）、非本机、在线状态
            if (
              info.deviceType === deviceManager.DeviceType.TAB &amp;&amp;
              !info.isLocalDevice &amp;&amp;
              info.deviceState === deviceManager.DeviceState.ONLINE
            ) {
              this.targetDeviceId = info.networkId;
              console.info(`客户端：发现平板设备，NetworkId：${this.targetDeviceId}`);
              // 发现设备后，自动绑定服务
              this.bindRemoteService();
            } else if (info.deviceState === deviceManager.DeviceState.OFFLINE &amp;&amp; info.networkId === this.targetDeviceId) {
              console.info('客户端：平板设备已离线');
              this.targetDeviceId = '';
              this.proxy = null;
            }
          });
        });
      })
      .catch((err) =&gt; {
        console.error(`客户端：创建设备管理器失败，错误信息：${err.message}`);
      });
  }

  // 绑定服务端远程服务
  private bindRemoteService() {
    if (!this.targetDeviceId || !this.dmInstance) {
      console.error('客户端：绑定服务失败，目标设备ID为空或设备管理器未初始化');
      return;
    }

    // 构造Want对象，指定服务端信息
    const want: common.Want = {
      deviceId: this.targetDeviceId, // 目标设备NetworkId
      bundleName: 'com.example.textsync', // 服务端应用包名（需与服务端一致）
      abilityName: 'TextSyncServerPage', // 服务端Ability名称（需与服务端一致）
      parameters: {
        serviceDescriptor: SERVICE_DESCRIPTOR // 服务接口标识符（需与服务端一致）
      }
    };

    // 绑定服务端Ability
    featureAbility.connectAbility(want, {
      // 绑定成功回调，获取服务端代理对象
      onConnect: (proxy: rpc.RemoteObject) =&gt; {
        this.proxy = proxy;
        console.info('客户端：绑定服务端成功');
      },
      // 绑定断开回调
      onDisconnect: () =&gt; {
        console.info('客户端：与服务端断开连接');
        this.proxy = null;
      },
      // 绑定失败回调
      onFailed: (code: number) =&gt; {
        console.error(`客户端：绑定服务端失败，错误码：${code}`);
        this.proxy = null;
      }
    });
  }

  // 发送文本数据到服务端
  private sendTextToServer() {
    if (!this.proxy || !this.inputText.trim()) {
      console.error('客户端：发送失败，代理对象为空或输入文本为空');
      return;
    }

    // 构造请求数据（MessageSequence）
    const data = rpc.MessageSequence.create();
    const reply = rpc.MessageSequence.create();
    // 写入要发送的文本数据
    data.writeString(this.inputText.trim());

    // 调用服务端远程接口（指定方法标识码）
    this.proxy.sendRequest(TEXT_SYNC_CODE, data, reply, rpc.MessageOption.TWOWAY)
      .then(() =&gt; {
        console.info(`客户端：文本发送成功，内容：${this.inputText.trim()}`);
        // 发送成功后清空输入框
        this.inputText = '';
      })
      .catch((err) =&gt; {
        console.error(`客户端：文本发送失败，错误信息：${err.message}`);
      })
      .finally(() =&gt; {
        // 释放资源
        data.destroy();
        reply.destroy();
      });
  }

  // UI布局：输入文本并发送
  build() {
    Column({ space: 20 }) {
      Text('手机端（客户端）')
        .fontSize(22)
        .fontWeight(FontWeight.Bold);
      TextInput({
        placeholder: '请输入要同步的文本',
        value: this.inputText
      })
        .fontSize(18)
        .width('80%')
        .padding(12)
        .border({ width: 1, color: '#e5e5e5' })
        .onChange((value) =&gt; {
          this.inputText = value;
        });
      Button('发送到平板')
        .fontSize(18)
        .width('80%')
        .height(48)
        .backgroundColor('#007dff')
        .fontColor('#ffffff')
        .onClick(() =&gt; {
          this.sendTextToServer();
        })
        .enabled(this.targetDeviceId !== '' &amp;&amp; this.proxy !== null); // 设备在线且绑定成功才可用
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center);
  }
}</code></pre><h4>步骤3：测试验证</h4><p>完成服务端与客户端开发后，进行如下测试验证，确保功能正常：</p><ol><li>分别在平板和手机上部署应用，确保两台设备登录同一华为账号，开启Wi-Fi、蓝牙；</li><li>先启动平板端应用（服务端），再启动手机端应用（客户端），客户端会自动发现平板设备并绑定服务；</li><li>在手机端输入文本，点击“发送到平板”，平板端应实时显示接收的文本；</li><li>测试异常场景：断开平板Wi-Fi（设备离线），客户端应提示设备离线，发送按钮不可用；重新开启平板Wi-Fi，客户端自动重连，恢复文本同步功能。</li></ol><h2>三、鸿蒙设备间数据共享最佳实践</h2><p>结合上述案例开发经验，以及鸿蒙分布式技术的特性，总结以下设备间数据共享最佳实践，帮助开发者规避常见问题、优化性能与体验，提升开发效率：</p><h3>3.1 技术选型最佳实践：按需选择合适的共享方式</h3><p>鸿蒙提供了多种设备间数据共享方式，开发者需根据数据类型、同步需求、设备场景，选择最合适的方式，避免盲目选型导致的性能浪费或体验不佳：</p><ol><li>RPC远程调用：适用于小体量数据（如文本、参数）的实时交互，支持跨设备接口调用，适合本文案例中的文本同步、指令传输等场景。优势是延迟低、交互灵活，劣势是不适合大文件传输。</li><li>分布式数据管理（DDM）：适用于需要多设备数据一致性的场景（如待办事项、家庭相册、健康数据），支持数据自动同步、增量更新、冲突自动合并，开发者无需手动处理数据同步细节。例如，1000条待办事项更新，传统方案需同步2.1MB数据，DDM仅传输8KB，大幅提升同步效率。</li><li>分布式文件共享：适用于大文件传输（如图片、视频、文档），依托分布式软总线的高速传输能力，支持星闪/Wi-Fi Direct直连传输，速度可达800Mbps以上。开发时需注意文件分片传输、存储权限申请、传输进度反馈等细节。</li><li>分布式KVStore：适用于小型配置数据（如用户偏好设置、设备参数）的同步，API简单易用，支持加密存储，适合轻量级数据共享场景。</li></ol><h3>3.2 开发实现最佳实践：规避常见问题，提升稳定性</h3><p>在开发过程中，需重点关注设备发现、服务注册、数据传输、异常处理等环节，规避常见问题，确保功能稳定可靠：</p><ol><li>设备发现与认证：优先依赖同一华为账号的自动认证机制，简化用户操作；同时监听设备状态变化（上线/离线），及时更新设备列表和连接状态，避免因设备离线导致的传输失败。开发时需注意，设备发现需开启Wi-Fi、蓝牙，否则会导致设备无法被检测到。</li><li>服务注册与绑定：服务端需确保服务注册成功后再对外提供能力，页面卸载时及时注销服务，避免资源泄露；客户端绑定服务时，需处理绑定失败、断开连接等异常，实现自动重连机制，提升用户体验。同时，服务接口标识符（descriptor）、SAID需与客户端保持一致，否则会导致绑定失败。</li><li>数据传输优化：传输敏感数据时，需开启端到端加密（如DDM的字段级加密、KVStore的加密存储），符合《个人信息保护法》要求；传输大文件时，采用分片传输+断点续传机制，避免因网络不稳定导致的传输中断；传输小体量数据时，优先使用RPC，减少数据中转，降低延迟。</li><li>异常处理：全面覆盖设备未发现、服务绑定失败、数据传输超时、设备断开连接等异常场景，添加详细的日志打印，便于问题排查；同时为用户提供清晰的提示（如“设备未找到”“发送失败，请重试”），提升体验。例如，本文案例中，发送按钮仅在设备在线且绑定成功后可用，避免用户无效操作。</li><li>权限管理：严格按照鸿蒙权限规范，申请必要的分布式权限，明确权限申请理由，避免过度申请权限；同时处理权限申请被拒绝的场景，提示用户开启对应权限，否则无法使用跨设备共享功能。</li></ol><h3>3.3 性能与体验优化最佳实践：兼顾效率与易用性</h3><p>除了功能稳定，还需优化性能与用户体验，实现“无缝同步”的核心需求：</p><ol><li>性能优化：减少不必要的设备扫描和数据同步，采用“按需同步”机制（如用户触发同步、数据变化时同步）；避免频繁创建和销毁设备管理器、RPC代理等实例，复用资源；传输数据时，仅同步变化部分（如DDM的增量更新），减少带宽占用和延迟。</li><li>UI体验优化：同步过程中添加加载提示（如进度条、加载动画），让用户感知同步状态；数据同步成功后，及时更新UI，避免数据不一致；针对多设备同步场景，提供同步状态展示（如“已同步至2台设备”），让用户清晰了解数据同步情况。</li><li>兼容性适配：适配不同鸿蒙版本（如API11与API21）的差异，针对低版本系统做降级处理；适配不同类型的设备（手机、平板、穿戴设备），根据设备屏幕尺寸、交互方式，优化UI布局和操作流程；同时兼容同账号下的多设备组网场景，确保数据在多设备间一致。</li></ol><h3>3.4 安全最佳实践：守护数据隐私与安全</h3><p>跨设备数据共享涉及用户隐私数据，需严格遵循鸿蒙安全规范，守护数据安全：</p><ol><li>数据加密：敏感数据（如健康记录、私密文档）需采用端到端加密传输和存储，避免数据在传输过程中被截取、泄露；分布式数据管理支持字段级加密，可对敏感字段单独加密，进一步提升安全性。</li><li>权限管控：实现细粒度的设备授权机制，允许用户设置“哪些设备可访问哪些数据”，例如“仅允许平板访问工作文档，智慧屏不可见”；支持临时共享，生成一次性访问令牌，过期自动失效，避免数据长期泄露。</li><li>数据主权：遵循“数据随人而动，主权属于用户”的原则，不强制将数据上传至云端，优先采用设备间直接同步模式；提供数据同步开关，允许用户随时关闭跨设备同步功能，掌控自己的数据。</li></ol><h2>四、总结</h2><p>鸿蒙设备间数据共享依托分布式软总线、分布式数据管理、RPC等核心技术，彻底解决了传统跨设备数据交互的协议碎片化、效率低、开发复杂等痛点，为开发者提供了统一、高效、安全的解决方案。本文通过“手机与平板跨设备文本同步”案例，详细拆解了服务端与客户端的对接步骤，涵盖环境准备、设备发现、服务注册、数据传输等核心环节，同时总结了技术选型、开发实现、性能优化、安全保障等最佳实践，助力开发者快速上手。</p><p>在实际开发中，开发者需结合具体业务场景，按需选择合适的数据共享方式，严格遵循鸿蒙开发规范和最佳实践，兼顾功能稳定性、性能效率与用户体验。随着鸿蒙生态的不断完善，设备间数据共享的场景将更加丰富，未来可结合AI技术实现意图感知同步、隐私风险预测等更智能的功能，进一步推动全场景智能生态的落地。</p>]]></description></item><item>    <title><![CDATA[鸿蒙推送功能开发实践 江南一点雨 ]]></title>    <link>https://segmentfault.com/a/1190000047609158</link>    <guid>https://segmentfault.com/a/1190000047609158</guid>    <pubDate>2026-02-13 12:07:41</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在全场景智能生态飞速发展的当下，推送功能已成为鸿蒙应用不可或缺的核心能力之一——它承担着消息触达、用户召回、功能提醒等关键职责，直接影响应用的活跃度、留存率与用户体验。无论是社交应用的消息通知、工具应用的任务提醒，还是内容应用的更新推送，都离不开稳定、高效的推送机制。鸿蒙操作系统（HarmonyOS）依托分布式架构优势，构建了统一的推送服务体系，打破了传统推送“平台碎片化、适配复杂、推送延迟高”的困境，为开发者提供了“一次开发、多端适配”的标准化推送开发方案。本文将结合实际开发场景，详细拆解鸿蒙推送功能的问题背景、具体对接步骤及最佳实践，助力开发者快速掌握相关技术要点，高效完成推送功能落地。</p><h2>一、问题背景：传统推送的痛点与鸿蒙推送的解决方案</h2><p>随着鸿蒙生态的不断扩张，应用需适配手机、平板、智慧屏、智能穿戴、车机等多种设备，传统推送模式在鸿蒙场景下的诸多痛点日益凸显，严重影响开发效率与用户体验，具体表现为以下三点：</p><p>其一，平台碎片化严重，适配成本高。传统推送需依赖第三方推送平台（如极光、个推），而不同第三方平台的API接口、适配逻辑差异较大，开发者需为不同平台单独开发适配代码；同时，鸿蒙设备品类繁多，不同设备的系统版本、推送权限机制不一致，进一步增加了适配难度。例如，手机端推送需适配后台保活机制，而智慧屏端需适配息屏唤醒逻辑，开发者需投入大量精力处理多设备、多平台的适配问题，开发周期大幅延长。</p><p>其二，推送稳定性差，延迟与丢失问题突出。传统推送多采用“客户端-第三方服务器-应用服务器”的中转模式，链路较长，易受网络波动、设备后台清理等因素影响，导致推送延迟高、消息丢失率高；此外，不同设备的后台限制策略不同，部分设备会限制第三方推送服务的后台运行，导致推送无法正常触达。例如，穿戴设备与手机断开连接后，传统推送无法通过鸿蒙分布式能力实现消息接力，用户无法及时接收关键提醒。</p><p>其三，资源消耗高，用户体验割裂。传统推送方案中，每个应用需单独启动推送服务，多个应用同时运行时会占用大量设备内存与电量，影响设备续航；同时，推送消息的展示样式、交互逻辑缺乏统一标准，不同应用的推送通知在多设备上的展示效果不一致，导致用户体验割裂。例如，手机端接收的推送通知无法同步至平板端，用户切换设备后需重新查看，影响使用连贯性。</p><p>针对上述痛点，鸿蒙操作系统推出了官方统一的推送服务——鸿蒙推送服务（HarmonyOS Push Service），依托分布式软总线、分布式数据管理、统一推送框架等核心技术，构建了一套高效、稳定、低耗的全场景推送解决方案，其核心优势体现在三个方面：</p><p>一是统一标准化，降低开发与适配成本。鸿蒙推送服务提供标准化的API接口与开发框架，开发者无需适配多第三方平台，只需一次开发，即可实现多鸿蒙设备（手机、平板、智慧屏等）的推送适配，大幅简化开发流程；同时，系统统一管理推送服务，无需每个应用单独启动推送进程，降低设备资源消耗。</p><p>二是分布式协同，实现全场景消息触达。依托鸿蒙分布式架构，推送消息可实现多设备协同触达——例如，手机端未读的推送通知，切换至平板端后可继续查看；穿戴设备与手机断开连接后，推送消息可通过鸿蒙分布式软总线接力触达穿戴设备，确保用户在任何设备上都能及时接收消息。</p><p>三是高稳定低延迟，提升推送可靠性。鸿蒙推送服务采用“应用服务器-鸿蒙推送服务器-设备”的短链路架构，减少中转环节，推送延迟可低至数百毫秒；同时，结合设备后台保活优化、消息重试机制，大幅降低消息丢失率，确保推送消息稳定触达；此外，支持消息优先级设置，可根据业务需求优先推送关键消息（如验证码、紧急提醒）。</p><p>鸿蒙推送功能的核心技术底座包括：鸿蒙推送服务器（负责消息转发、权限管控、消息统计）、统一推送框架（负责客户端消息接收、解析与展示）、分布式软总线（负责多设备间消息接力）、分布式数据管理（负责多设备推送消息同步），四者协同工作，为开发者提供全场景、高可靠、低消耗的推送能力。</p><h2>二、具体案例对接步骤：基于ArkTS实现鸿蒙全场景推送功能</h2><p>为让开发者更直观地掌握鸿蒙推送功能的实现流程，本文以“多设备消息推送与同步”为具体案例，基于鸿蒙6.0（API21）、ArkTS语言、Stage模型，详细拆解从环境准备、服务配置到功能落地、测试验证的完整对接步骤。该案例实现的核心功能为：应用服务器发送推送消息（文本通知+跳转链接），鸿蒙手机、平板同时接收消息并展示；手机端标记消息已读，平板端同步更新状态；穿戴设备与手机连接时，消息同步触达穿戴设备。</p><h3>2.1 案例前置准备</h3><p>在开始开发前，需完成环境配置、账号注册、权限申请等前置操作，确保开发环境与设备满足开发要求：</p><ol><li>开发环境：DevEco Studio 5.0（适配鸿蒙6.0），确保已配置鸿蒙6.0 SDK（API21），支持ArkTS语言开发；安装鸿蒙推送服务SDK（可通过DevEco Studio的依赖管理添加）。</li><li>账号与服务配置：注册华为开发者账号，在华为开发者联盟后台创建鸿蒙应用，开通鸿蒙推送服务，获取应用的AppID、AppSecret（用于应用服务器与鸿蒙推送服务器的身份认证）；配置推送消息的签名信息，确保消息传输安全。</li><li>测试设备：2-3台搭载鸿蒙6.0及以上系统的设备（手机、平板、穿戴设备），登录同一华为账号（用于多设备推送同步），开启推送权限（设置-应用-目标应用-通知，开启允许通知）。</li><li>权限配置：在项目的module.json5文件中，添加推送相关权限，用于接收推送消息、获取设备信息、多设备同步等操作，具体配置如下：</li></ol><pre><code class="json">{
  "module": {
    "abilities": [...],
    "requestPermissions": [
      {
        "name": "ohos.permission.RECEIVE_PUSH_NOTIFICATION",
        "reason": "用于接收鸿蒙推送服务发送的消息",
        "usedScene": { "when": "always" }
      },
      {
        "name": "ohos.permission.GET_DISTRIBUTED_DEVICE_INFO",
        "reason": "用于获取分布式设备信息，实现多设备消息同步",
        "usedScene": { "when": "always" }
      },
      {
        "name": "ohos.permission.DISTRIBUTED_DATASYNC",
        "reason": "用于多设备间推送消息状态同步（如已读/未读）",
        "usedScene": { "when": "always" }
      }
    ],
    "dependencies": {
      "@ohos.push": "^1.0.0", // 鸿蒙推送服务SDK依赖
      "@ohos.distributedHardware.distributedDeviceManager": "^1.0"
    }
  }
}</code></pre><ol start="5"><li>核心依赖：引入鸿蒙推送服务SDK（@ohos.push），用于客户端接收、解析推送消息；引入分布式设备管理模块（distributedDeviceManager），用于获取多设备信息，实现消息状态同步。</li></ol><h3>2.2 核心对接步骤（分客户端、应用服务器）</h3><p>本案例采用“应用服务器-鸿蒙推送服务器-客户端（多设备）”的架构，整体流程遵循“客户端注册推送服务→应用服务器发送消息至鸿蒙推送服务器→鸿蒙推送服务器转发消息至多客户端→客户端接收消息并同步状态”的核心逻辑，具体分为客户端开发与应用服务器开发两部分。</p><h4>步骤1：客户端开发（多设备通用）——注册推送服务，接收并处理消息</h4><p>客户端的核心职责是注册鸿蒙推送服务、接收鸿蒙推送服务器发送的消息、解析消息内容、展示通知，并实现多设备消息状态同步（如已读/未读）。具体实现分为三步：</p><ol><li>初始化推送服务，注册设备。在应用启动时（Ability的onCreate方法或页面的aboutToAppear方法），初始化鸿蒙推送服务，注册当前设备到鸿蒙推送服务器，获取设备的推送令牌（Token）——Token是设备的唯一标识，应用服务器发送推送消息时，需指定目标设备的Token（多设备推送可指定多个Token）。代码示例如下：</li></ol><pre><code class="typescript">import push from '@ohos.push';
import common from '@ohos.app.ability.common';
import deviceManager from '@ohos.distributedHardware.distributedDeviceManager';

@Entry
@Component
struct PushClientPage {
  // 推送令牌（设备唯一标识）
  @State pushToken: string = '';
  // 接收的推送消息列表
  @State messageList: Array&lt;{ id: string; title: string; content: string; isRead: boolean }&gt; = [];
  // UI上下文
  private context: common.UIAbilityContext = getContext(this) as common.UIAbilityContext;
  // 设备管理实例（用于多设备消息同步）
  private dmInstance: deviceManager.DeviceManager | null = null;

  // 页面加载时初始化推送服务与设备管理器
  aboutToAppear() {
    this.initPushService();
    this.initDeviceManager();
  }

  // 初始化鸿蒙推送服务
  private initPushService() {
    // 初始化推送服务
    push.init(this.context)
      .then(() =&gt; {
        console.info('推送服务初始化成功');
        // 注册设备，获取推送Token
        return push.getToken();
      })
      .then((token) =&gt; {
        this.pushToken = token;
        console.info(`设备注册成功，推送Token：${this.pushToken}`);
        // 注册消息接收回调，监听推送消息
        this.registerPushReceiver();
      })
      .catch((err) =&gt; {
        console.error(`推送服务初始化/注册失败，错误信息：${err.message}`);
      });
  }

  // 注册推送消息接收回调
  private registerPushReceiver() {
    // 监听推送消息接收事件
    push.on('receiveMessage', (message: push.PushMessage) =&gt; {
      console.info(`接收推送消息：${JSON.stringify(message)}`);
      // 解析消息内容（message.data为JSON字符串，需解析）
      const messageData = JSON.parse(message.data);
      // 新增消息到列表（默认未读）
      this.messageList.unshift({
        id: message.messageId,
        title: messageData.title || '推送通知',
        content: messageData.content || '',
        isRead: false
      });
      // 展示系统通知
      this.showNotification(messageData.title, messageData.content, messageData.url);
      // 同步消息到其他设备（已读/未读状态）
      this.syncMessageToOtherDevices(message.messageId, false);
    });

    // 监听推送Token变化事件（如设备重置、账号切换导致Token变化）
    push.on('tokenChange', (newToken: string) =&gt; {
      console.info(`推送Token变化，新Token：${newToken}`);
      this.pushToken = newToken;
      // 可将新Token上报至应用服务器，更新设备Token记录
      this.reportTokenToServer(newToken);
    });
  }

  // 展示系统推送通知
  private showNotification(title: string, content: string, url: string) {
    // 构造通知参数
    const notification: push.Notification = {
      title: title,
      content: content,
      clickAction: {
        type: push.ClickActionType.OPEN_ABILITY, // 点击通知跳转至应用页面
        abilityName: 'PushClientPage', // 跳转的Ability名称
        parameters: { url: url } // 携带跳转参数（如链接）
      },
      importance: push.NotificationImportance.HIGH // 高优先级，确保及时展示
    };
    // 发送系统通知
    push.showNotification(notification)
      .then(() =&gt; {
        console.info('推送通知展示成功');
      })
      .catch((err) =&gt; {
        console.error(`推送通知展示失败，错误信息：${err.message}`);
      });
  }

  // 初始化设备管理器，用于多设备消息同步
  private initDeviceManager() {
    deviceManager.getDistributedDeviceManager(this.context)
      .then((dm) =&gt; {
        if (!dm) {
          console.error('创建设备管理器失败');
          return;
        }
        this.dmInstance = dm;
        // 监听其他设备的消息同步请求
        this.listenMessageSync();
      })
      .catch((err) =&gt; {
        console.error(`创建设备管理器失败，错误信息：${err.message}`);
      });
  }

  // 同步消息状态到其他设备
  private syncMessageToOtherDevices(messageId: string, isRead: boolean) {
    if (!this.dmInstance) return;
    // 获取所有在线的分布式设备（排除本机）
    const devices = this.dmInstance.getAvailableDeviceList();
    devices.forEach((device) =&gt; {
      if (device.isLocalDevice) return;
      // 构造同步消息
      const syncData = {
        messageId: messageId,
        isRead: isRead
      };
      // 通过分布式数据管理同步消息状态（简化实现，实际可结合DDM或RPC）
      this.dmInstance.sendData(device.networkId, JSON.stringify(syncData))
        .then(() =&gt; {
          console.info(`消息状态同步至设备${device.networkId}成功`);
        })
        .catch((err) =&gt; {
          console.error(`消息状态同步至设备${device.networkId}失败：${err.message}`);
        });
    });
  }

  // 监听其他设备的消息同步请求，更新本地消息状态
  private listenMessageSync() {
    if (!this.dmInstance) return;
    this.dmInstance.on('dataReceived', (deviceId: string, data: string) =&gt; {
      console.info(`接收设备${deviceId}的同步消息：${data}`);
      const syncData = JSON.parse(data);
      // 查找对应的消息，更新已读状态
      const targetMessage = this.messageList.find(item =&gt; item.id === syncData.messageId);
      if (targetMessage) {
        targetMessage.isRead = syncData.isRead;
      }
    });
  }

  // 将推送Token上报至应用服务器（供服务器发送消息时使用）
  private reportTokenToServer(token: string) {
    // 调用应用服务器接口，上报Token（实际开发中需结合HTTP/HTTPS请求）
    console.info(`上报推送Token至服务器：${token}`);
    // 示例：fetch('https://xxx.com/reportToken', { method: 'POST', body: JSON.stringify({ token: token }) });
  }

  // 标记消息为已读
  private markMessageAsRead(messageId: string) {
    const targetMessage = this.messageList.find(item =&gt; item.id === messageId);
    if (targetMessage) {
      targetMessage.isRead = true;
      // 同步已读状态到其他设备
      this.syncMessageToOtherDevices(messageId, true);
    }
  }

  // UI布局：展示推送消息列表
  build() {
    Column({ space: 15 }) {
      Text('鸿蒙推送客户端（多设备同步）')
        .fontSize(22)
        .fontWeight(FontWeight.Bold);
      Text(`当前设备推送Token：${this.pushToken}`)
        .fontSize(14)
        .width('90%')
        .textAlign(TextAlign.Center)
        .padding(10)
        .backgroundColor('#f5f5f5');
      List({ space: 10 }) {
        ForEach(this.messageList, (item) =&gt; {
          ListItem() {
            Column({ space: 5 }) {
              Text(item.title)
                .fontSize(18)
                .fontWeight(item.isRead ? FontWeight.Normal : FontWeight.Bold)
                .fontColor(item.isRead ? '#999999' : '#000000');
              Text(item.content)
                .fontSize(16)
                .fontColor('#666666');
            }
            .width('100%')
            .padding(15)
            .backgroundColor('#ffffff')
            .border({ width: 1, color: '#e5e5e5' })
            .onClick(() =&gt; {
              this.markMessageAsRead(item.id);
            });
          }
        });
      }
      .width('90%')
      .flexGrow(1);
    }
    .width('100%')
    .height('100%')
    .padding(10)
    .backgroundColor('#fafafa');
  }
}</code></pre><ol start="2"><li>处理推送消息交互逻辑。实现消息点击跳转、消息已读/未读状态同步、多设备消息同步等逻辑，如上述代码所示：点击推送通知跳转至应用指定页面（携带跳转参数）；点击消息列表项标记消息为已读，并同步状态至其他设备；接收其他设备的同步消息，更新本地消息状态。</li><li>异常处理。添加推送服务初始化失败、消息接收失败、Token变化、多设备同步失败等异常场景的处理，打印详细日志便于问题排查，同时为用户提供清晰的提示（如“推送服务初始化失败，请重启应用”）。</li></ol><h4>步骤2：应用服务器开发——发送推送消息至鸿蒙推送服务器</h4><p>应用服务器的核心职责是生成推送消息、通过鸿蒙推送服务API发送消息至鸿蒙推送服务器，同时接收客户端上报的设备Token，管理设备列表。本案例采用Node.js（Express框架）实现应用服务器，具体代码示例如下：</p><pre><code class="javascript">const express = require('express');
const axios = require('axios');
const app = express();
app.use(express.json());

// 鸿蒙推送服务配置（从华为开发者联盟后台获取）
const APP_ID = '你的应用AppID';
const APP_SECRET = '你的应用AppSecret';
const PUSH_API_URL = 'https://push-api.cloud.huawei.com/v1/your-appid/messages:send'; // 替换为实际API地址

// 存储客户端上报的设备Token（多设备对应多个Token）
let deviceTokens = [];

// 1. 接收客户端上报的推送Token
app.post('/reportToken', (req, res) =&gt; {
  const { token } = req.body;
  if (token &amp;&amp; !deviceTokens.includes(token)) {
    deviceTokens.push(token);
    console.log(`新增设备Token：${token}，当前设备列表：${deviceTokens}`);
  }
  res.json({ code: 200, message: 'Token上报成功' });
});

// 2. 发送推送消息（支持多设备推送）
app.post('/sendPush', async (req, res) =&gt; {
  try {
    const { title, content, url } = req.body;
    if (!title || !content) {
      return res.json({ code: 400, message: '标题和内容不能为空' });
    }
    if (deviceTokens.length === 0) {
      return res.json({ code: 400, message: '暂无在线设备' });
    }

    // 1. 获取鸿蒙推送服务的访问令牌（Access Token）
    const accessToken = await getAccessToken();
    if (!accessToken) {
      return res.json({ code: 500, message: '获取Access Token失败' });
    }

    // 2. 构造推送消息体（符合鸿蒙推送API规范）
    const pushMessage = {
      message: {
        data: JSON.stringify({ title, content, url }), // 自定义消息内容（客户端解析）
        notification: {
          title: title,
          body: content,
          click_action: {
            type: 1, // 点击跳转至应用
            ability: {
              bundle_name: 'com.example.pushdemo', // 应用包名（需与客户端一致）
              ability_name: 'PushClientPage' // 跳转的Ability名称
            }
          }
        },
        token: deviceTokens // 目标设备Token列表（多设备推送）
      }
    };

    // 3. 调用鸿蒙推送API发送消息
    const response = await axios.post(PUSH_API_URL, pushMessage, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${accessToken}`
      }
    });

    console.log(`推送消息发送成功，响应：${JSON.stringify(response.data)}`);
    res.json({ code: 200, message: '推送消息发送成功', data: response.data });
  } catch (err) {
    console.error(`推送消息发送失败，错误：${err.message}`);
    res.json({ code: 500, message: '推送消息发送失败', error: err.message });
  }
});

// 获取鸿蒙推送服务的Access Token（用于API身份认证）
async function getAccessToken() {
  const tokenUrl = `https://oauth-login.cloud.huawei.com/oauth2/v3/token`;
  try {
    const response = await axios.post(tokenUrl, new URLSearchParams({
      grant_type: 'client_credentials',
      client_id: APP_ID,
      client_secret: APP_SECRET
    }), {
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
    });
    return response.data.access_token;
  } catch (err) {
    console.error(`获取Access Token失败：${err.message}`);
    return null;
  }
}

// 启动服务器
const port = 3000;
app.listen(port, () =&gt; {
  console.log(`应用服务器启动成功，监听端口：${port}`);
});</code></pre><p>核心说明：应用服务器需先获取鸿蒙推送服务的Access Token（通过AppID与AppSecret认证），再构造符合规范的推送消息体，调用鸿蒙推送API发送消息；消息体中需指定目标设备的Token列表（多设备推送可传入多个Token）、消息内容、通知样式及点击交互逻辑。</p><h4>步骤3：测试验证</h4><p>完成客户端与应用服务器开发后，进行如下测试验证，确保推送功能正常实现：</p><ol><li>部署应用服务器：启动Node.js服务器，确保服务器可正常访问（可通过Postman测试接口）。</li><li>部署客户端应用：分别在手机、平板、穿戴设备上部署鸿蒙应用，启动应用后，客户端会自动初始化推送服务、注册设备，并将Token上报至应用服务器。</li><li>发送推送消息：通过Postman调用应用服务器的/sendPush接口，传入标题、内容、跳转链接，发送推送消息。</li><li>验证核心功能：</li></ol><ul><li>多设备接收：手机、平板、穿戴设备（与手机连接）应同时接收推送消息，并展示系统通知；</li><li>消息交互：点击任何设备上的推送通知，应跳转至应用指定页面，携带跳转参数；</li><li>状态同步：在手机端标记消息为已读，平板端、穿戴设备上的对应消息应同步更新为已读状态；</li><li>异常场景：断开穿戴设备与手机的连接，发送推送消息，穿戴设备重新连接后应接收未读消息；关闭客户端应用后台，发送推送消息，应用应被唤醒并接收消息。</li></ul><ol start="5"><li>日志排查：若推送失败，可查看客户端与应用服务器的日志，排查Token是否正确、Access Token是否有效、消息体格式是否符合规范等问题。</li></ol><h2>三、鸿蒙推送功能最佳实践</h2><p>结合上述案例开发经验，以及鸿蒙推送服务的特性，总结以下鸿蒙推送功能最佳实践，帮助开发者规避常见问题、优化推送性能与用户体验，提升开发效率：</p><h3>3.1 技术选型与服务配置最佳实践</h3><ol><li>优先使用官方鸿蒙推送服务，避免第三方推送平台。鸿蒙推送服务与鸿蒙系统深度融合，支持多设备协同、低资源消耗、高稳定性，无需适配多平台，可大幅降低开发与适配成本；若需兼容非鸿蒙设备，可采用“鸿蒙推送+第三方推送”的混合方案，鸿蒙设备使用官方推送，非鸿蒙设备使用第三方推送。</li><li>合理配置推送服务参数。在华为开发者联盟后台，根据业务需求配置推送消息的过期时间（默认24小时）、重试次数、消息优先级；对于关键消息（如验证码、紧急提醒），设置高优先级（NotificationImportance.HIGH），确保及时触达；对于非关键消息（如广告、内容更新），设置低优先级，避免打扰用户。</li><li>妥善管理设备Token。客户端需监听Token变化事件（tokenChange），将新Token及时上报至应用服务器，避免因Token变化导致推送失败；应用服务器需定期清理无效Token（如设备卸载应用、注销账号），可通过鸿蒙推送API的“消息发送状态查询”接口，获取Token的有效性，及时移除无效Token。</li></ol><h3>3.2 客户端开发最佳实践：提升稳定性与用户体验</h3><ol><li>推送服务初始化时机。建议在应用启动时（Ability的onCreate方法）初始化推送服务，确保推送服务尽早注册，避免错过推送消息；同时，添加初始化失败的重试机制（如间隔3秒重试，最多重试3次），提升初始化成功率。</li><li>消息处理规范化。解析推送消息时，需对消息格式进行校验（避免非法JSON格式导致解析失败）；区分推送消息类型（通知消息、透传消息），通知消息展示系统通知，透传消息根据业务需求处理（如后台处理、弹窗提示）；同时，避免在消息接收回调中执行耗时操作（如大量计算、网络请求），防止阻塞消息处理。</li><li>多设备同步优化。实现多设备消息状态同步时，优先使用鸿蒙分布式数据管理（DDM），替代简单的消息发送，确保同步的可靠性；同时，过滤无效设备（如离线设备），避免无效同步消耗设备资源；对于消息列表，可采用增量同步机制，仅同步新增或状态变化的消息，减少数据传输量。</li><li>权限与用户体验优化。客户端需检查推送权限，若权限未开启，提示用户开启（跳转至权限设置页面），但避免频繁弹窗打扰用户；推送通知的标题、内容需简洁明了，避免冗余信息；根据设备类型优化通知展示样式（如智慧屏端通知展示在屏幕顶部，穿戴设备端通知适配小屏幕）。</li><li>异常处理全覆盖。全面覆盖推送服务初始化失败、消息接收失败、Token变化、多设备同步失败、权限被拒绝等异常场景，添加详细的日志打印（包含错误码、错误信息），便于问题排查；同时，为用户提供清晰的提示，如“推送权限未开启，无法接收消息”“消息同步失败，请重试”。</li></ol><h3>3.3 应用服务器开发最佳实践：提升推送可靠性</h3><ol><li>Access Token管理优化。应用服务器获取的Access Token有有效期（默认7200秒），需提前缓存Access Token，避免每次发送消息都重新获取；同时，添加Access Token过期监听，在过期前自动重新获取，确保推送消息正常发送。</li><li>消息发送重试机制。调用鸿蒙推送API发送消息时，添加重试机制，针对网络波动、服务器临时不可用等场景，自动重试发送（如间隔1秒重试，最多重试3次）；同时，处理推送API返回的错误码（如Token无效、权限不足），根据错误码进行对应处理（如移除无效Token、检查服务配置）。</li><li>消息批量发送优化。若需向大量设备发送同一推送消息，优先使用鸿蒙推送服务的批量推送功能（传入多个Token），避免循环调用推送API，减少服务器压力；同时，控制消息发送频率，避免短时间内发送大量消息，导致推送被限流。</li><li>推送消息监控。应用服务器需对接鸿蒙推送服务的消息统计接口，获取推送消息的发送量、到达率、点击率等数据，实时监控推送效果；对于到达率过低的场景，排查Token有效性、设备在线状态等问题；同时，记录每条消息的发送日志，便于后续追溯。</li></ol><h3>3.4 性能与安全最佳实践</h3><ol><li>性能优化：客户端避免频繁创建推送服务实例，复用推送服务对象；减少多设备同步的频率，采用“状态变化时同步”机制，避免定时同步消耗资源；应用服务器缓存常用数据（如Access Token、设备Token列表），减少重复请求与计算。</li><li>安全优化：推送消息传输时，采用HTTPS加密（鸿蒙推送API默认支持），避免消息被截取、篡改；自定义消息内容（data字段）时，可对敏感数据（如用户ID、订单信息）进行加密处理，确保数据安全；应用服务器的AppSecret需妥善保管，避免泄露（建议存储在配置文件中，不硬编码在代码中）。</li><li>合规性优化：推送消息需符合《个人信息保护法》《网络安全法》等相关法规，不推送违法、违规、低俗内容；推送广告类消息时，需提供“关闭推送”“拒收此类消息”的选项，尊重用户意愿；避免在夜间（如22:00-次日7:00）推送非紧急消息，避免打扰用户休息。</li></ol><h2>四、总结</h2><p>鸿蒙推送服务依托鸿蒙分布式架构优势，彻底解决了传统推送“平台碎片化、适配复杂、稳定性差”的痛点，为开发者提供了一套统一、高效、低耗的全场景推送解决方案，是鸿蒙应用实现消息触达、用户召回的核心支撑。本文通过“多设备消息推送与同步”案例，详细拆解了客户端与应用服务器的对接步骤，涵盖环境准备、推送服务注册、消息接收与处理、多设备同步等核心环节，同时总结了技术选型、开发实现、性能优化、安全保障等最佳实践，助力开发者快速上手鸿蒙推送功能开发。</p><p>在实际开发中，开发者需结合具体业务场景，合理配置推送服务参数，规范处理消息接收与交互逻辑，兼顾推送可靠性与用户体验；同时，关注鸿蒙推送服务的版本更新，及时适配新功能（如多设备消息接力、消息分类推送），充分发挥鸿蒙分布式生态的优势。随着鸿蒙生态的不断完善，推送功能将更加智能化、个性化，未来可结合AI技术实现用户画像分析、精准推送。</p>]]></description></item><item>    <title><![CDATA[让 Cursor AI 助手秒懂OceanBase seekdb向量数据库 —— Cursor se]]></title>    <link>https://segmentfault.com/a/1190000047609163</link>    <guid>https://segmentfault.com/a/1190000047609163</guid>    <pubDate>2026-02-13 12:06:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>摘要：</strong><br/><strong><em>在AI辅助编程时代，开发者使用 Cursor 进行开发时，可能会因AI助手不熟悉OceanBase推出的AI原生搜索数据库 seekdb，无法获取精准的技术解答。seekdb Cursor Extension 可向 Cursor AI 注入官方文档知识，使其理解 seekdb 核心概念、提供合规代码建议并精准解答技术问题。该扩展支持一键安装与双模式文档检索，操作简便，能有效减少开发者查阅文档的时间，提升 seekdb 相关 AI 应用开发效率。</em></strong></p><p>本文将为大家介绍如何通过 seekdb Cursor Extension，让 Cursor AI 助手拥有 seekdb 专业知识，从而在大家基于 seekdb 进行 AI 应用开发的过程中获得精准的技术指导。</p><p><img width="723" height="410" referrerpolicy="no-referrer" src="/img/bVdnVtq" alt="" title=""/></p><h2>什么是 seekdb？</h2><p>seekdb 是由 OceanBase 推出的一款 AI 原生搜索数据库。它在单一引擎中统一了关系型数据、向量、文本、JSON 和 GIS 等多种数据模型，支持混合搜索和数据库内的 AI 工作流。</p><p>seekdb 的典型应用场景包括：</p><p>RAG 与知识检索：为大语言模型引入实时可信的外部知识，提升回答质量<br/>AI 辅助编程：为代码仓库构建向量和全文索引，实现基于语义的代码搜索<br/>语义搜索引擎：捕捉用户搜索意图，实现跨模态精准检索<br/>智能体（Agent）应用：为 AI Agent 提供记忆、规划、感知和推理的统一基础</p><h2>什么是 seekdb Cursor Extension？</h2><p>seekdb Cursor Extension 是一款 Cursor 扩展，它通过在 .cursor/rules 目录下添加规则，使 Cursor AI 助手能够检索 seekdb 官方文档，从而理解 seekdb 数据库知识，使其能够：</p><p>理解 seekdb 数据库概念：向量搜索、混合搜索、AI 函数等<br/>提供准确的代码建议：基于官方文档生成符合最佳实践的代码<br/>回答 seekdb 相关问题：直接在编辑器中获取技术支持<br/>加速开发流程：减少查阅文档的时间，专注于业务逻辑</p><p>核心特性</p><p>一键安装：通过 Cursor 扩展市场或命令面板快速安装<br/>完整文档：检索 seekdb 官方文档知识库，涵盖向量搜索、混合搜索、AI 函数等全面技术文档<br/>双模式支持：优先从 GitHub 获取最新文档，本地文档作为备份</p><h2>快速开始</h2><p>第一步：安装扩展</p><ol><li>在 Cursor 中打开扩展市场（Ctrl+Shift+X 或 Cmd+Shift+X）</li><li>搜索 "seekdb"</li><li>点击 Install 安装扩展</li></ol><p><img width="628" height="762" referrerpolicy="no-referrer" src="/img/bVdnVtr" alt="" title="" loading="lazy"/></p><p>第二步：添加 seekdb 文档</p><ol><li>使用 Cursor 打开一个项目目录（文档将添加到该目录下）</li><li>打开命令面板：<br/>Windows/Linux: 按 Ctrl+Shift+P<br/>macOS: 按 Cmd+Shift+P</li><li>输入并选择命令：<br/>输入 "seekdb" 或 "Add seekdb Docs"<br/>选择 Add seekdb Docs 命令</li><li>文档将自动添加：<br/>.cursor/rules/seekdb-docs 目录（官方文档）<br/>.cursor/rules/seekdb.mdc 文件（规则文件）</li><li>重新加载窗口使规则生效</li></ol><p><img width="658" height="306" referrerpolicy="no-referrer" src="/img/bVdnVtu" alt="" title="" loading="lazy"/></p><p>安装完成！现在你可以直接向 Cursor AI 助手询问任何 seekdb 相关问题了。</p><h2>实际效果演示</h2><p>让我们通过一个实际示例，看看 seekdb Cursor Extension 如何帮助你进行开发。</p><p><strong>示例：使用 AI 助手创建一个 seekdb 混合搜索应用</strong></p><p>安装扩展并添加文档后，在 Cursor 中开始一个新对话，输入以下问题：</p><p>例如：我想用 Python 创建一个简单的 seekdb 应用，实现文档的混合搜索功能，请帮我写代码。</p><p>Cursor AI 助手此时就会给出准确的回答：</p><p><img width="650" height="1488" referrerpolicy="no-referrer" src="/img/bVdnVtv" alt="" title="" loading="lazy"/></p><p><strong>运行示例</strong></p><ol><li>安装 pyseekdb</li></ol><p><img width="654" height="74" referrerpolicy="no-referrer" src="/img/bVdnVtC" alt="" title="" loading="lazy"/></p><ol start="2"><li>运行代码</li></ol><p><img width="654" height="78" referrerpolicy="no-referrer" src="/img/bVdnVtD" alt="" title="" loading="lazy"/></p><ol start="3"><li>查看结果</li></ol><p><img width="652" height="212" referrerpolicy="no-referrer" src="/img/bVdnVtQ" alt="" title="" loading="lazy"/></p><p>混合搜索结合了关键词匹配（包含 "机器学习" 的文档）和语义搜索（与 "AI 技术" 语义相近的文档），通过 RRF（Reciprocal Rank Fusion）算法融合两路检索结果，返回最相关的文档。</p><p>特别说明：seekdb 的嵌入式模式暂时只支持 Linux 服务器，如果是在 Mac 或者 Windows 本地测试，需要把 Python 代码里的 client = pyseekdb.Client() 改成服务器模式的连接地址（推荐在 Mac 或者 Windows 上使用 seekdb 桌面版）。</p><p><img width="658" height="234" referrerpolicy="no-referrer" src="/img/bVdnVtR" alt="" title="" loading="lazy"/></p><h2>更多使用场景</h2><p>安装 seekdb Cursor Extension 后，你可以向 AI 助手询问各种 seekdb 相关问题：</p><p>基础查询</p><p>如何开始使用 seekdb？<br/>seekdb 支持哪些部署模式？</p><p>技术问题</p><p>如何在 seekdb 中创建向量索引？<br/>seekdb 的 AI 函数有哪些？如何使用 AI_EMBED 函数？</p><p>代码示例</p><p>展示一个使用 seekdb SQL 实现向量相似度搜索的示例。<br/>如何将 seekdb 与 LangChain 集成？</p><p>集成相关</p><p>seekdb 如何配置 OpenAI 模型进行向量嵌入？</p><h2>工作原理</h2><p>seekdb Cursor Extension 的工作原理非常简单：</p><ol><li>规则文件注入：扩展将 seekdb 官方文档和 .mdc 规则文件添加到 .cursor/rules 目录</li><li>AI 上下文增强：Cursor 会自动读取 .cursor/rules 目录中的内容，作为 AI 助手的上下文知识</li><li>智能检索：当你询问 seekdb 相关问题时，AI 助手会基于这些文档提供准确的回答</li></ol><p><img width="304" height="292" referrerpolicy="no-referrer" src="/img/bVdnVtS" alt="" title="" loading="lazy"/></p><h2>移除文档</h2><p>如果你不再需要 seekdb 文档，可以轻松移除：</p><ol><li>打开命令面板（Ctrl+Shift+P 或 Cmd+Shift+P）</li><li>输入 "Remove seekdb Docs"</li><li>选择该命令执行</li></ol><p>文档将从 .cursor/rules 目录中移除。</p><h2>总结</h2><p>通过 seekdb Cursor Extension，你可以在使用 Cursor 进行开发时，随时获取 seekdb 的官方文档支持。无论是学习 seekdb 的新功能，还是解决开发中遇到的技术问题，AI 助手都能基于最新的官方文档提供准确的指导。</p><p>欢迎访问 OceanBase 官网获取更多信息：<a href="https://link.segmentfault.com/?enc=MaphOwOzMDyBq1V%2FdBoWcg%3D%3D.K8zA2IOpXsQPskzuNLibwVasRQPYxktC3cMCWOuahLY%3D" rel="nofollow" target="_blank">https://www.oceanbase.com/</a></p>]]></description></item><item>    <title><![CDATA[使用OpenClaw，token不够用？试试免费的token channg ]]></title>    <link>https://segmentfault.com/a/1190000047609168</link>    <guid>https://segmentfault.com/a/1190000047609168</guid>    <pubDate>2026-02-13 12:06:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>🚀 免费用 OpenClaw 跑大模型：对接硅基流动，注册送 2000 万 Token 教程</h2><p>最近 <strong>OpenClaw</strong> 很火，很多人已经开始用它搭建自动化 AI 工作流。</p><p>但一个现实问题是：</p><p><strong>模型 API 很贵，怎么低成本甚至免费跑？</strong></p><p>今天直接给你一个最简单教程：  <br/>用 OpenClaw 对接 <strong>硅基流动的免费模型</strong>，注册就送 <strong>2000 万 Token</strong>，足够你跑很久。</p><hr/><h3>第一步：注册硅基流动（拿 2000 万 Token）</h3><p>通过下面链接注册：</p><p>👉 <a href="https://link.segmentfault.com/?enc=nOpKSf8e4aECjfalgkB3pg%3D%3D.M2pge4gjn8OwvsN5KC97aA5dAOflvUf6%2B4KKTdUsHB%2BzVYlVcvgpSfmcqlpBd9JX" rel="nofollow" target="_blank">https://cloud.siliconflow.cn/i/i05xEFBt</a></p><p>注册完成后：</p><ul><li>自动获得 <strong>2000 万 Token</strong></li><li>后台可以创建 API Key</li><li>所有模型均为 OpenAI 兼容接口</li></ul><hr/><h3>第二步：获取 API 信息</h3><p>登录硅基流动后台：</p><ol><li>创建 API Key</li><li>复制 API Key</li><li>复制 Base URL（OpenAI 兼容接口地址）</li><li>查看可用免费模型名称</li></ol><hr/><h3>第三步：在 OpenClaw 中添加模型</h3><p>打开 OpenClaw，进入模型设置：</p><ol><li>添加 OpenAI 兼容模型</li><li>填写 Base URL（硅基流动提供的地址）</li><li>填写 API Key</li><li>填写模型名称（硅基流动后台可见）</li><li>保存</li></ol><p>配置完成。</p><hr/><h3>第四步：开始免费跑工作流</h3><p>现在你可以：</p><ul><li>用 OpenClaw 跑 Agent</li><li>批量生成内容</li><li>自动化写作</li><li>做新闻摘要</li><li>测试多模型工作流</li></ul><p>因为有 <strong>2000 万 Token</strong>，前期基本等于免费使用。</p><hr/><h3>为什么这样搭配更划算？</h3><p><strong>OpenClaw</strong> = 工作流调度层  <br/><strong>硅基流动</strong> = 模型聚合平台  </p><p>两者结合：</p><ul><li>统一接口</li><li>随时切换模型</li><li>成本可控</li><li>开发效率更高</li></ul><hr/><h3>总结</h3><p>如果你正在用 OpenClaw，又不想一开始就烧钱，  <br/>直接用硅基流动免费额度跑起来。</p><p>👉 <a href="https://link.segmentfault.com/?enc=t6vG5dcirFDLj36Y%2FCxvjQ%3D%3D.6QP7mTAvRnvXfYHxXWpwtpp1yOzwIApzSb%2Fh59%2FfvZthz6OOnxMT%2Bh%2FdJsxLFWVC" rel="nofollow" target="_blank">https://cloud.siliconflow.cn/i/i05xEFBt</a></p><p>先拿 2000 万 Token，再慢慢研究架构。</p><p><strong>免费跑模型，比什么都重要。</strong></p>]]></description></item><item>    <title><![CDATA[域名注册后无法解析解决方法：技术故障排查和解决指南 防火墙后吃泡面 ]]></title>    <link>https://segmentfault.com/a/1190000047609170</link>    <guid>https://segmentfault.com/a/1190000047609170</guid>    <pubDate>2026-02-13 12:05:45</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>域名解析作为连接域名与服务器的核心环节，直接决定用户能否通过域名正常访问网站数据，而域名注册后无法解析并非无解难题，只要找准问题根源，按步骤排查，无论是新手还是非专业人士，都能快速完成修复。</p><p>本文，国科云将详细拆解域名注册后无法解析解决方法，覆盖常见故障场景、分步排查流程，助力大家高效解决解析难题，顺利推进网站搭建。</p><h2>一、首先要明确域名注册≠域名解析</h2><p>首先我们要明确，域名注册与域名解析是两个独立且关联的环节：域名注册是“获取域名使用权”，相当于拿到了网站的“门牌号”；而域名解析是“给门牌号标注具体地址”，即将易记的域名转换为计算机可识别的服务器IP地址，让DNS服务器能精准指引用户访问请求找到对应服务器。很多人误以为域名注册成功后会自动解析，实则需要手动配置解析记录，若配置不当、状态异常或网络环境受限，都会出现域名注册后无法解析的情况。</p><h2>二、域名注册后无法解析的表现形式有哪些？</h2><p>我们要弄清楚域名注册后无法解析的常见表现症状，方便大家快速判断问题：</p><p>输入域名后浏览器提示“无法访问此网站”“DNS解析失败”“找不到服务器IP地址”；</p><p>部分浏览器显示“ERR_NAME_NOT_RESOLVED”错误代码；</p><p>同一域名在不同设备、不同网络下，部分能访问部分无法访问；</p><p>ping域名时提示“请求找不到主机”，nslookup查询时显示“服务器无响应”或解析结果异常。</p><p>这些都是域名注册后无法解析的典型症状，遇到此类情况无需慌乱。</p><h2>三、3步基础排查，快速定位简单故障</h2><p><strong>第一步：检查网络连接与设备状态</strong></p><p>域名注册后无法解析，有可能是本地网络或设备故障，而非域名本身问题。首先确认当前设备（电脑、手机）是否正常联网，可尝试访问百度、淘宝等常用网站，若所有网站均无法打开，说明是网络故障，而非域名解析问题。此时可重启路由器、光猫，等待5-10分钟后重新连接网络；若使用办公网络，可切换至手机热点测试，排除内网限制。另外，清理设备浏览器缓存（设置-隐私和安全-清除浏览数据），避免缓存异常导致的解析失败假象，部分浏览器会缓存旧的解析记录，清理后可重新尝试访问域名。</p><p><strong>第二步：清除本地DNS缓存，刷新解析记录</strong></p><p>本地DNS缓存异常是导致域名注册后无法解析的常见原因之一，尤其是刚完成域名解析配置后，本地缓存未及时更新，会导致解析失败。不同系统清除DNS缓存的方法不同，操作简单，无需专业技术：</p><p>Windows系统：按下“Win+R”组合键，输入“cmd”打开命令提示符，输入命令“ipconfig/flushdns”，按下回车，提示“成功刷新DNS解析缓存”即可；</p><p>Mac系统：打开终端，输入命令“sudo dscacheutil -flushcache”，输入电脑开机密码后回车，即可完成缓存清除；</p><p>手机系统：无需输入命令，直接重启手机，即可自动清除DNS缓存。清除缓存后，重新输入域名访问，若能正常打开，说明故障已解决，无需进一步排查。</p><p><strong>第三步：更换公共DNS服务器，排除DNS故障</strong></p><p>若本地网络和缓存均无问题，可尝试更换公共DNS服务器，排查是否是默认DNS服务器故障导致的域名注册后无法解析。默认情况下，设备会使用网络运营商提供的DNS服务器，部分运营商DNS服务器可能存在负载过高、解析延迟等问题，更换为稳定的公共DNS即可解决。</p><p>国内推荐公共DNS：114.114.114.114（最稳定，适配国内所有网络）；</p><p>国际推荐公共DNS：8.8.8.8（谷歌DNS）、1.1.1.1（Cloudflare DNS）；</p><p>操作方法：在设备网络设置中，找到“DNS服务器”选项，手动输入上述公共DNS地址，保存后重新连接网络，再次尝试访问域名。若更换后可正常解析，说明是原DNS服务器故障，可长期使用公共DNS提升解析稳定性。</p><h2>四、深入排查4大核心故障及对应解决方法</h2><p>若基础排查后，域名注册后无法解析的问题仍未解决，说明故障源于域名本身配置、状态或服务器层面，此时需要深入排查核心环节。</p><p>以下4种场景是域名注册后无法解析的最常见故障，每种场景对应具体的解决方法，精准匹配，高效修复。</p><p><strong>故障1：域名解析记录配置错误</strong></p><p>域名注册后，需要手动在域名注册商后台配置解析记录，若记录类型选错、IP地址填写错误，或未添加核心解析记录，都会导致无法解析。这是域名注册后无法解析解决方法中最核心的环节，也是新手最容易出错的地方。</p><p>解决方法：登录域名注册商（如国科云、阿里云、西部数码）的管理后台，找到“域名管理”板块，点击对应域名的“解析设置”，进入解析配置页面，重点检查3点：</p><ol><li>确认解析记录类型正确：搭建网站需添加A记录（指向服务器IPv4地址）或AAAA记录（指向IPv6地址），若使用虚拟主机、CDN加速，需添加CNAME记录（指向目标域名）；若用于企业邮箱，需添加MX记录，避免记录类型混淆导致解析失败。</li><li>检查记录值填写正确：A记录的“记录值”需填写服务器公网IP地址，确保无多余空格、无数字错误；CNAME记录的“记录值”需填写服务商提供的目标域名（如xxx.cloud.com），不可填写IP地址；MX记录需填写邮箱服务商提供的服务器地址，并设置正确的优先级（数值越小，优先级越高）。</li><li>确认主机记录完整：主机记录填写“@”（代表主域名，如xxx.com）或“www”（代表带www前缀的域名，如www.xxx.com），建议两者都添加，确保用户无论输入哪种域名都能正常访问。</li></ol><p>修改完成后，点击“保存”，解析记录生效需要10分钟至24小时（新添加的记录生效较快，修改现有记录生效时间取决于TTL设置，TTL值越小，生效越快，建议新手设置为10-60分钟）。生效后可通过“nslookup 域名”命令验证解析结果，若显示的IP地址与服务器IP一致，说明解析配置正确。</p><p><strong>故障2：域名状态异常，导致解析失效</strong></p><p>域名注册成功后，若状态异常（如过期、未实名认证、被锁定），会被注册商限制解析，导致域名注册后无法解析。这种情况下，即使解析记录配置正确，也无法正常访问，需优先恢复域名正常状态。</p><p>解决方法：首先通过Whois查询工具（域名注册商后台可直接查询）查看域名状态，根据不同异常状态针对性解决：</p><ol><li>域名未实名认证：国内域名（.cn、.com.cn等）强制要求实名认证，未实名认证的域名会被限制解析，登录注册商后台，提交身份证正反面、手机号等信息，完成实名认证（通常1-3个工作日审核通过），审核通过后解析即可生效；</li><li>域名过期：若域名显示“expired”（过期）状态，需立即在注册商后台续费，续费后等待1-2小时，域名状态恢复正常，解析即可恢复；建议开启域名自动续费功能，设置到期前30天提醒，避免因遗忘续费导致解析失效；</li><li>域名被锁定：若显示“clientHold”（客户锁定）或“serverHold”（服务器锁定），“clientHold”通常是因域名信息不实、违规使用被注册商锁定，需提交相关证明材料解锁；“serverHold”需联系域名注册局解决，一般较少出现。</li></ol><p><strong>故障3：DNS服务器配置错误或故障</strong></p><p>域名解析依赖DNS服务器，若域名所使用的DNS服务器宕机、配置错误，或未修改为注册商默认DNS，都会导致域名注册后无法解析。这种故障容易被忽视，排查时需重点关注DNS服务器设置。</p><p>解决方法：登录域名注册商后台，找到“DNS服务器设置”选项，确认当前DNS服务器是否为注册商默认DNS，若已修改为第三方DNS（如国科云解析DNS、Cloudflare），需确认第三方DNS服务器是否正常运行。</p><p>若怀疑DNS服务器故障，可临时更换为注册商默认DNS，保存后等待1-2小时，重新尝试解析；若第三方DNS服务器出现宕机，可联系第三方服务商排查，或暂时切换回默认DNS，保障解析正常。此外，若网站使用企业自建DNS服务器，需检查服务器是否正常运行，是否存在“区域传送”“递归查询”配置错误，这类问题需专业运维人员处理。</p><p><strong>故障4：网络安全策略或防火墙拦截</strong></p><p>部分企业内网、服务器防火墙或安全软件，会拦截DNS解析请求（DNS请求默认使用53端口），导致域名注册后无法解析，这种情况多出现于办公网络或已搭建服务器的场景。</p><p>解决方法：分两种场景针对性处理：</p><ol><li>本地网络拦截：若在办公网络中无法解析，切换至手机热点后可正常解析，说明是企业内网防火墙拦截，需联系公司网管，开放DNS解析相关端口（53端口），或添加域名至内网白名单；</li><li>服务器拦截：若域名已解析至服务器，但仍无法访问，需检查服务器防火墙（如Windows防火墙、Linux防火墙），确认是否禁止了53端口的出入站规则，开放53端口（允许DNS协议通过）后，重新测试解析；同时，临时关闭服务器上的杀毒软件、安全防护工具，排除软件误拦截的可能。</li></ol><h2>五、域名注册后无法解析的预防措施</h2><ol><li>开启自动续费，设置到期提醒：在域名注册商后台，开启域名自动续费功能，同时设置到期前30天提醒，避免因遗忘续费导致域名过期、解析失效，这是最基础的预防措施；</li><li>定期备份解析记录：每次修改解析记录后，截图备份或导出解析配置，当更换DNS服务商、误删解析记录时，可快速恢复配置，避免重复排查；</li><li>使用多DNS冗余配置：为域名配置2-3组不同服务商的DNS服务器（如注册商默认DNS+国科云解析DNS+自建DNS），即使其中一组DNS服务器故障，其他DNS可正常提供解析服务，提升解析稳定性；</li><li>定期监控解析状态：使用在线DNS查询工具（如DNSChecker.org、站长工具DNS查询），定期检测域名解析状态，若出现解析异常，可及时收到提醒，提前排查修复，避免故障扩大。</li></ol><p>综上，域名注册后无法解析并非难题，核心逻辑是“从基础到核心，从本地到远程”分步排查：先通过网络、缓存、DNS更换，解决简单故障；再排查解析记录、域名状态、DNS服务器、防火墙，解决核心故障，新手可按照本文步骤逐步操作，无需专业技术支撑，就能解决大部分的域名解析不生效的问题。</p>]]></description></item><item>    <title><![CDATA[销售团队拜访系统选型指南：从数据真实性到落地执行的完整分析 果断的小刀 ]]></title>    <link>https://segmentfault.com/a/1190000047609174</link>    <guid>https://segmentfault.com/a/1190000047609174</guid>    <pubDate>2026-02-13 12:04:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>作者：王博涵 小步外勤产品总监，外勤管理数字化专家</p><p>很多企业在销售团队规模扩大之后，都会遇到一个共性问题：人越来越多，管理却越来越难。</p><p>销售人员长期在外跑客户，拜访过程看不见，拜访真实性难核查，客户跟进节奏无法统一，差旅报销管理也经常出现争议。时间一长，销售执行力下降，管理层却很难找到真正的原因。</p><p>这也是为什么越来越多企业开始关注<strong>销售团队拜访系统</strong>。它的价值不在于增加一套工具，而在于<strong>把销售过程变得可追溯、可分析、可复盘</strong>。</p><p>但在真正选型时，企业往往又会犹豫。销售团队拜访系统到底怎么选，价格是不是很高，功能是否真的实用，推行会不会遇到阻力，这些问题如果没有想清楚，很容易踩坑。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609176" alt="" title=""/></p><h2>销售团队拜访系统解决的到底是什么问题</h2><p>在没有系统之前，大多数企业依赖微信群汇报、Excel登记或人工抽查来做<strong>客户拜访管理</strong>。这种方式在团队规模较小时还能维持，但一旦人员扩张，问题会逐渐显现。</p><p>例如，拜访签到可能存在虚拟定位，拜访记录写得完整却难以核实真实性，业务员在客户处停留时间过短却难以及时发现，销售过程管理缺少连续数据支撑。差旅报销管理尤其明显，里程核算和油补发放常常缺乏客观依据。</p><p>销售团队拜访系统的核心作用，是<strong>让这些分散的外勤行为形成结构化数据</strong>。从拜访签到、拜访轨迹，到客户停留时长和拜访记录沉淀，都能够形成连续链路。管理者看到的不再只是结果，而是完整过程。</p><p><strong>销售团队拜访系统真正解决的是销售过程不可视的问题。</strong></p><h2>选销售团队拜访系统，关键看三点</h2><p><strong>第一是数据是否真实可靠</strong></p><p>销售拜访管理系统如果无法识别虚拟定位或异常定位行为，所有数据都可能失去意义。外勤打卡和拜访签到必须建立在真实定位基础之上，否则销售过程管理只是形式化。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609177" alt="" title="" loading="lazy"/></p><p><strong>第二是流程是否可以标准化</strong></p><p>优秀的销售团队拜访系统不仅记录拜访，更会推动拜访动作的规范化。例如门店拜访中，是否需要陈列检查、库存采集、竞品上报、拍照取证，这些都应该被配置成固定流程。流程一旦固化，销售执行力才会趋于稳定。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609178" alt="" title="" loading="lazy"/></p><p><strong>第三是是否具备轨迹与分析能力</strong></p><p>拜访轨迹还原和客户停留时长分析，是判断拜访质量的重要依据。通过轨迹数据，企业可以优化拜访路线，减少空跑，提高人均产出。这也是外勤管理系统区别于简单签到工具的关键所在。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609179" alt="" title="" loading="lazy"/></p><p><strong>销售团队拜访系统是否有效，往往就取决于这三项能力是否扎实。</strong></p><h2>关于销售团队拜访系统价格</h2><p>很多企业在搜索销售团队拜访系统时，第一反应是价格。但真正成熟的管理决策，往往不会只看采购成本。</p><p>目前主流销售拜访管理系统多采用SaaS模式，按账号数量订阅，不需要额外部署服务器。从投入形式来看，相对轻量。</p><p>更重要的是系统带来的管理回报。通过规范客户拜访管理、减少无效拜访、提升销售执行力，以及结合拜访轨迹进行差旅报销管理核算，企业往往能够在效率和费用控制上获得长期收益。</p><p><strong>判断销售团队拜访系统是否值得投入，关键不在单价，而在能否持续降低管理成本。</strong></p><h2>推行难度是否可控</h2><p>系统是否推得动，是很多企业最现实的顾虑。事实上，销售团队拜访系统的推行效果，与制度设计和执行绑定程度密切相关。</p><p>如果企业明确拜访频次要求，将拜访记录纳入绩效考核，并配合上线培训和实施支持，推行难度并不会过高。反之，如果只上线工具而不调整管理规则，再好的系统也难以发挥价值。</p><p>在实际落地过程中，例如<strong>小步外勤</strong>等优秀管理系统，都强调陪跑式支持，帮助企业从流程配置到制度导入逐步推进，使销售团队拜访系统真正融入日常管理。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609180" alt="" title="" loading="lazy"/></p><h2>销售团队拜访系统适合哪些企业</h2><p>一般来说，当企业拥有一定规模的外勤销售团队，客户分布较广，终端巡店频繁，差旅报销管理复杂时，就已经具备部署销售团队拜访系统的必要条件。</p><p>团队越大，销售过程越复杂，系统带来的管理价值就越明显。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609181" alt="" title="" loading="lazy"/></p><h2>结语</h2><p>销售团队拜访系统不是为了强化监管，而是为了让销售过程更清晰，让团队执行更稳定。</p><p>当拜访轨迹可追溯，客户拜访记录可沉淀，差旅报销管理有依据，销售执行力可以量化时，<strong>企业管理将不再依赖经验判断，而是建立在真实数据之上</strong>。</p>]]></description></item><item>    <title><![CDATA[AI向善 | 「AI4AI普及公益」2025年度回顾 AI4AI社区 ]]></title>    <link>https://segmentfault.com/a/1190000047609200</link>    <guid>https://segmentfault.com/a/1190000047609200</guid>    <pubDate>2026-02-13 12:03:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>时序更替，华章日新。回顾2025年，是AI技术从“云端狂欢”走向“落地深耕”的一年，也是1024Foundation践行初心的关键之年。自2024年10月发起 AI for AII Initiative (AI4AI) 普及公益以来，我们始终致力于推动AI从“精英专属”走向“大众普及”。 </p><p>过去的一年，我们以「AI雏鹰计划 」、「AI转型计划 」、「AI领袖计划 」为三大支柱，通过教育培训、OPC项目实操实训、智能体AI主题沙龙等多样化活动，在AI4AI普及公益之路留下了坚实而有力的足迹。 </p><p>值此马年新春，让我们回顾过往、启新未来，共享成果，同贺新春！ </p><p>AI4AI 雏鹰计划 </p><p>AI4AI 雏鹰计划致力于帮助零基础青少年发展AI能力，开启全新思维模式。2025年，我们通过传授零代码智能体、大模型等前沿技术，打破地域限制与认知门槛，让 AI 学习真正无门槛、有温度，为未来的科技创新播下希望的种子。 </p><p>西藏中小学生AI英语教学平台 </p><p>我们用“结对智能体”的形式，手把手助力8名上海文绮汇点美高学子，通过“零代码智能体”方法论，成功打造了面向西藏中小学生的 AI 英语教学平台。科技打破了地域的界限，让高原上的孩子们也能享受到个性化的智能教育资源。 </p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609203" alt="图片" title="图片"/></p><p>零代码AI智能体开发高中课程 </p><p>我们与闵行中学/文绮汇点合作开展《零代码 AI 智能体开发课程》，采用从AI理论到实践操作的教学模式，赋能学生们通过零代码智能体方法论，结合πDataCS、OpenClaw、OpenCode等AI产品，将智能体开发创意转化为实践成果，在项目实操中零距离学习人工智能技术。 </p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609204" alt="图片" title="图片" loading="lazy"/></p><p>出席TED X NAIS活动 </p><p>5月，1024Foundation发起人冯雷（Ray Von）出席 TED X NAIS 等多个活动。他结合丰富的人生阅历与科技创业经验，向青年学子传达了 “The Sense of Mission”（使命感）的理念，并提出了 “Meta thinking”（元思维）核心思想，为学子们打开了通往未来科技与创新思维的大门。<br/> <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047609205" alt="图片" title="图片" loading="lazy"/></p><p>AI4AI 转型计划 </p><p>AI4AI 转型计划帮助有职业转型需求的人群，开拓职业机会，提升个人竞争力，顺利适应并融入人工智能行业需求。2025年，我们以沙龙、研讨会、讲座为载体，打破技术壁垒，将前沿理论转化为实战演练，帮助各行各业的奋斗者掌握驾驭 AI 的工具，完成职业生涯的华丽转身。 </p><p>智能体新纪元沙龙 </p><p>6月，我们成功举办【智能新纪元：AI Agent如何赋能实体产业】主题沙龙。行业专家齐聚一堂，共同探讨AI Agent如何深入业务场景，构建垂类智能体的可持续发展范式，为产业升级寻找具体的解题思路。 </p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609206" alt="图片" title="图片" loading="lazy"/></p><p>助力商科教育“数智化”转型 </p><p>在AI重构商业逻辑的当下，商科教育正面临从“传统管理”向“数智管理”转型的关键挑战。冯雷先后走进浙大EMBA、上海大学MBA、吉林大学等知名高校课堂，用理论实践为高校学子讲解数智化转型的关键要素。 </p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609207" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609208" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609209" alt="图片" title="图片" loading="lazy"/></p><p> 传递AI颠覆式创新理念 冯雷受邀参与中国MBA创业大赛等重要活动，面向未来的创业者，全方位传递AI转型理念，深度剖析智能体时代的商业重构逻辑，激发颠覆式创新思维。<br/> <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047609210" alt="图片" title="图片" loading="lazy"/></p><p>AI4AI 领袖计划 </p><p>AI4AI 领袖计划汇聚行业顶尖思想，赋能管理者构建AI时代的战略决策力。2025年，冯雷出席多场行业领袖交流座谈，与多方伙伴，共建生态引领时代航向。 </p><p>出席数安港企业座谈会 </p><p>7月，冯雷出席中国（温州）数安港企业座谈会并分享“如何赋能数字经济发展”。<br/> <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047609211" alt="图片" title="图片" loading="lazy"/></p><p>出席之江创投政协委员会 </p><p>9月，冯雷作为科技企业代表，出席之江创投政协委员会客厅主题活动，分享可信大模型数据计算系统的实践经验，推动AI领域资源联动与人才培育，为行业领袖搭建交流与成长的平台。 </p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609212" alt="图片" title="图片" loading="lazy"/></p><p>技术的意义不在于多么先进，而在于能为人类带来多少便利。<br/>回望2025，每一步实践都凝聚着初心，每一项成果都彰显着担当。 <br/>展望2026，我们将继续推进AI4AI普及公益。<br/>坚守“技术有温度”的初心，让技术创新真正扎根生活惠及大众！</p>]]></description></item><item>    <title><![CDATA[Markdown 转 Word 和 PDF：Python 简单实现指南 宇文成都 ]]></title>    <link>https://segmentfault.com/a/1190000047609237</link>    <guid>https://segmentfault.com/a/1190000047609237</guid>    <pubDate>2026-02-13 12:03:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在当今文档处理的时代，Markdown 已经成为了一种流行的轻量级标记语言。由于其简洁的语法和良好的可读性，Markdown 常被用于写作、记录和技术文档。然而，有时我们需要将 Markdown 中的内容转换为更普遍接受的格式，如 Word 或 PDF。为了实现这一目标，我们可以利用 Python 的 Spire.Doc 库，轻松地完成 Markdown 到 Word 和 PDF 的转换。</p><h2>为什么选择 Spire.Doc？</h2><p>Spire.Doc 是一款功能强大的 .NET 文档处理组件，支持多种文件格式的读取和写入。它不仅支持 Word 和 PDF 文件的操作，还能处理不同类型的文档格式，提供了丰富的文档处理功能。在 Python 环境中使用 Spire.Doc，能够很方便地实现诸如文档创建、编辑、格式设置等功能，尤其适合中小型项目。</p><h2>环境准备</h2><p>首先，确保你已经安装了 Spire.Doc。可以通过 pip 安装：</p><pre><code class="bash">pip install Spire.Doc</code></pre><p>在安装完毕后，你可以开始编写 Python 脚本，用于转换 Markdown 文件。</p><h2>Markdown 转 Word</h2><p>以下是将 Markdown 文件转换为 Word DOCX 格式的简单步骤：</p><pre><code class="python">from spire.doc import *
from spire.doc.common import *

# 创建文档对象
document = Document()
# 加载 Markdown 文件
document.LoadFromFile("input.md")

# 保存为 Word DOCX 文件
document.SaveToFile("MdToDocx.docx", FileFormat.Docx)
document.Close()</code></pre><p>这段代码的工作流程如下：</p><ol><li><strong>导入库</strong> ：通过 <code>from spire.doc import *</code> 引入 Spire.Doc 功能。</li><li><strong>创建文档对象</strong> ：使用 <code>Document()</code> 创建一个文档实例。</li><li><strong>加载文件</strong> ：通过 <code>LoadFromFile</code> 方法加载指定的 Markdown 文件。</li><li><strong>保存文件</strong> ：用 <code>SaveToFile</code> 方法将 Markdown 文件保存为 Word 格式，并指定文件格式为 <code>FileFormat.Docx</code>。</li><li><strong>关闭文件</strong> ：使用 <code>Close</code> 方法释放资源。</li></ol><p>只需简单的几行代码，你就可以将 Markdown 文档转换为 Word 格式，方便分享和编辑。</p><h2>Markdown 转 PDF</h2><p>下面是将 Markdown 文件转换为 PDF 文件的代码示例：</p><pre><code class="python">from spire.doc import *
from spire.doc.common import *

# 创建文档对象
doc = Document()

# 加载 Markdown 文件
doc.LoadFromFile("Sample.md", FileFormat.Markdown)

# 保存为 PDF 文档
doc.SaveToFile("MarkdownToPDF.pdf", FileFormat.PDF)
doc.Close()</code></pre><p>与转换到 Word 的过程类似：</p><ul><li>首先，我们创建一个新的 <code>Document</code> 对象。</li><li>使用 <code>LoadFromFile</code> 方法加载指定的 Markdown 文件，并指明源文件格式为 <code>FileFormat.Markdown</code>。</li><li>然后，使用 <code>SaveToFile</code> 方法将文件保存为 PDF 格式，文件扩展名为 <code>.pdf</code>。</li><li>最后，调用 <code>Close</code> 释放文档资源。</li></ul><h2>总结</h2><p>通过上述步骤，我们可以轻松地将 Markdown 文件转换为 Word 和 PDF 格式。Spire.Doc 提供的简单 API 使得这个过程变得高效和便捷。这对于需要频繁处理文档的开发者和写作者来说，尤其具有实际意义。无论是文档的分享、打印，还是用于正式的报表，Word 和 PDF 格式都能提供更好的兼容性和可视化体验。</p><p>随着 Python 在文档处理中的应用不断扩展，使用像 Spire.Doc 这样的库能够大大简化我们的工作流程。你只需花几分钟时间，便可以掌握如何将 Markdown 文件转化为常用的文档格式，为你的写作和分享带来便利。希望这篇文章能够帮助你更好地利用 Python 进行文档处理。</p>]]></description></item><item>    <title><![CDATA[2026CRM推荐：9款客户管理系统 傲视众生的脸盆 ]]></title>    <link>https://segmentfault.com/a/1190000047609272</link>    <guid>https://segmentfault.com/a/1190000047609272</guid>    <pubDate>2026-02-13 12:02:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在数字化客户管理时代，<strong>客户中心全流程覆盖、客户信息精准整合、</strong> <strong>RFM</strong> <strong>价值分层、复购流失智能预警</strong>已成为企业提升客户留存与营收的核心抓手。本文基于超兔一体云、SuiteCRM、Freshsales、Pipedrive、Nimble、Insightly、钉钉CRM、销售易CRM、Zoho CRM 9款主流CRM产品，围绕四大核心能力展开专业横向对比，为企业选型提供决策依据。</p><ul><li><ul><li>*</li></ul></li></ul><h2>一、核心能力维度与评估标准</h2><p>先明确四大核心模块的评估框架，确保对比的专业性与一致性：</p><table><thead><tr><th>核心模块</th><th>评估维度</th><th>权重占比</th></tr></thead><tbody><tr><td>客户中心</td><td>全流程覆盖（获客-跟进-合约-售后）、场景适配性、多部门协同能力</td><td>30%</td></tr><tr><td>客户信息管理</td><td>多渠道采集、整合能力、个性化配置、安全权限控制</td><td>25%</td></tr><tr><td>RFM分组分析</td><td>原生模型支持、自定义维度、可视化输出、业务决策联动</td><td>20%</td></tr><tr><td>复购流失预警</td><td>AI智能分析、规则自定义、自动化触发、挽回策略联动</td><td>25%</td></tr></tbody></table><ul><li><ul><li>*</li></ul></li></ul><h2>二、各品牌核心能力总览对比</h2><p>以下为9款CRM在四大模块的星级评分（5星制，★代表1星，☆代表半星）：</p><table><thead><tr><th>品牌</th><th>客户中心</th><th>客户信息</th><th>RFM分析</th><th>复购预警</th><th>核心差异化定位</th></tr></thead><tbody><tr><td>超兔一体云</td><td>★★★★★</td><td>★★★★☆</td><td>★★★★☆</td><td>★★★★☆</td><td>全流程场景化+三一客节点+五大跟单模型</td></tr><tr><td>SuiteCRM</td><td>★★★★☆</td><td>★★★★☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>开源高度定制+全生命周期原生框架</td></tr><tr><td>Freshsales</td><td>★★★★☆</td><td>★★★★☆</td><td>★★★★★</td><td>★★★★★</td><td>Freddy AI驱动+开箱即用销售自动化</td></tr><tr><td>Pipedrive</td><td>★★★☆☆</td><td>★★★☆☆</td><td>★★☆☆☆</td><td>★★☆☆☆</td><td>拖拽式销售管道+轻量化流程聚焦</td></tr><tr><td>Nimble</td><td>★★★☆☆</td><td>★★★★☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>社交媒体数据整合+B2B社交客户视图</td></tr><tr><td>Insightly</td><td>★★★★☆</td><td>★★★★☆</td><td>★★★★☆</td><td>★★★★☆</td><td>用户反馈闭环+RAG非结构化数据洞察</td></tr><tr><td>钉钉CRM</td><td>★★★★☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>钉钉生态深度联动+内部协同一体化</td></tr><tr><td>销售易CRM</td><td>★★★★★</td><td>★★★★★</td><td>★★★★★</td><td>★★★★★</td><td>企业级客户数据平台+Gartner魔力象限领先</td></tr><tr><td>Zoho CRM</td><td>★★★★☆</td><td>★★★★☆</td><td>★★★★☆</td><td>★★★★☆</td><td>全球化多语言+全流程轻量化管理</td></tr></tbody></table><ul><li><ul><li>*</li></ul></li></ul><h2>三、分模块深度对比与可视化解析</h2><h3>（一）客户中心：全流程覆盖与场景适配</h3><h4>核心评估逻辑</h4><p>客户中心的核心是实现<strong>客户生命周期的全链路闭环</strong>，从获客到售后的每个节点需适配企业业务场景，同时支持跨部门协同。</p><h4>各品牌能力拆解</h4><ol><li><strong>超兔一体云</strong>：以“三一客节点+五大跟单模型”为核心，覆盖获客-跟进-合约-售后全流程，适配贸易、服务、定制等多场景。其全流程逻辑可通过Mermaid流程图直观展示：</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609274" alt="" title=""/></p><pre><code>flowchart LR
    A[多渠道获客&lt;br/&gt;微信/广告/地推] --&gt; B[三一客节点定位&lt;br/&gt;定性/定级/定量]
    B --&gt; C[五大跟单模型适配&lt;br/&gt;场景化跟进]
    C --&gt; D[多类型合约执行&lt;br/&gt;订单-发货-收款全流程]
    D --&gt; E[售后管理+RFM分析&lt;br/&gt;价值挖掘]</code></pre><ol start="2"><li><strong>销售易CRM</strong>：基于<strong>Customer Data Cloud</strong>整合营销、销售、服务全渠道数据，构建360°客户视图，尤其在制造业、ICT行业的大型项目协同中表现突出。</li><li><strong>Freshsales</strong>：AI驱动的统一客户视图，自动整合邮件、通话、社交互动数据，通过潜在顾客评分识别高价值线索，适配中小企业快速获客需求。</li><li><strong>钉钉CRM</strong>：深度绑定钉钉生态，实现“客户-聊天-订单-审批”无缝联动，适合内部已使用钉钉的企业降低协同成本。</li></ol><ul><li><ul><li>*</li></ul></li></ul><h3>（二）客户信息管理：精准整合与安全可控</h3><h4>核心评估逻辑</h4><p>客户信息需实现<strong>多渠道采集-智能整合-个性化配置-权限隔离</strong>的全链路管理，确保数据的完整性、准确性与安全性。</p><h4>各品牌特色对比表</h4><table><thead><tr><th>品牌</th><th>多渠道采集能力</th><th>整合特色</th><th>个性化配置</th><th>安全权限控制</th></tr></thead><tbody><tr><td>超兔一体云</td><td>微信/广告/工商搜客/地推</td><td>自动查重+全景视图+时间线</td><td>自定义字段/布局</td><td>上下级权限隔离+数据加密</td></tr><tr><td>Nimble</td><td>浏览器扩展抓取LinkedIn/Twitter</td><td>社交数据自动补全客户档案</td><td>标签化管理</td><td>角色权限配置</td></tr><tr><td>Insightly</td><td>邮件/表单/用户评论</td><td>RAG技术分析非结构化反馈</td><td>自定义视图/报表</td><td>数据分级权限</td></tr><tr><td>Zoho CRM</td><td>邮件/社交媒体/API集成</td><td>多语言/多货币适配全球化</td><td>自定义模块/工作流</td><td>组织级权限隔离+数据脱敏</td></tr></tbody></table><ul><li><ul><li>*</li></ul></li></ul><h3>（三）RFM分组分析：客户价值分层与决策支撑</h3><h4>核心评估逻辑</h4><p>RFM分析需实现<strong>原生模型支持、自定义维度、可视化输出</strong>，并能直接联动营销策略，而非单纯的数据统计。</p><h4>各品牌实现路径脑图</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609275" alt="" title="" loading="lazy"/></p><pre><code>mindmap
    root((RFM分组分析))
        原生内置模型（开箱即用）
            Freshsales（自动分层+可视化报表）
            Insightly（价值报告+业务联动）
            Zoho CRM（直接筛选高价值群体）
            超兔一体云（RFM分层+复购预警联动）
        二次开发/开源扩展
            SuiteCRM（社区模块+自定义代码）
        第三方工具联动
            Pipedrive（Zapier/BI工具）
            钉钉CRM（钉钉AI表格/第三方BI）
        手动配置维度
            Nimble（自定义字段+手动分组）</code></pre><h4>关键差异点</h4><ul><li><strong>销售易CRM</strong>：支持自然语言查询（如“筛选最近3个月消费≥5000元的客户”），分析师智能体自动生成RFM分层报告，无需技术人员介入。</li><li><strong>Freshsales</strong>：内置RFM模型自动划分“高价值/流失风险”等6类客户，生成热词趋势图、客户关注度排名等可视化报表，直接支撑营销决策。</li><li><ul><li>*</li></ul></li></ul><h3>（四）复购流失预警：AI智能与自动化联动</h3><h4>核心评估逻辑</h4><p>复购流失预警需具备<strong>行为感知-智能分析-自动触发-策略联动</strong>的闭环能力，而非单纯的手动提醒。</p><h4>各品牌雷达图评分（子维度1-5分）</h4><table><thead><tr><th>品牌</th><th>AI智能分析</th><th>自动化触发</th><th>规则自定义</th><th>挽回策略联动</th><th>总分</th></tr></thead><tbody><tr><td>销售易CRM</td><td>5</td><td>5</td><td>5</td><td>5</td><td>20</td></tr><tr><td>Freshsales</td><td>5</td><td>5</td><td>4</td><td>5</td><td>19</td></tr><tr><td>Insightly</td><td>4</td><td>4</td><td>4</td><td>4</td><td>16</td></tr><tr><td>Zoho CRM</td><td>4</td><td>4</td><td>4</td><td>4</td><td>16</td></tr><tr><td>超兔一体云</td><td>3</td><td>4</td><td>4</td><td>4</td><td>15</td></tr><tr><td>钉钉CRM</td><td>3</td><td>3</td><td>3</td><td>5</td><td>14</td></tr><tr><td>SuiteCRM</td><td>2</td><td>3</td><td>5</td><td>3</td><td>13</td></tr><tr><td>Nimble</td><td>3</td><td>3</td><td>3</td><td>4</td><td>13</td></tr><tr><td>Pipedrive</td><td>1</td><td>2</td><td>3</td><td>2</td><td>8</td></tr></tbody></table><h4>特色能力解析</h4><ul><li><strong>Freshsales（Freddy AI）</strong> ：实时分析客户行为（如购买频率下降、互动减少），自动推送流失预警，并触发专属优惠邮件、跟进任务等挽回策略。</li><li><strong>销售易CRM（AI销售教练）</strong> ：智能诊断客户活跃度，定位高风险商机，联动渠道资源推送个性化跟进方案，连续8年入选Gartner魔力象限。</li><li><ul><li>*</li></ul></li></ul><h2>四、品牌定位与适用场景总结</h2><table><thead><tr><th>品牌类型</th><th>代表品牌</th><th>适用企业画像</th></tr></thead><tbody><tr><td>全流程深度定制型</td><td>超兔一体云、SuiteCRM</td><td>有复杂业务场景（如定制化服务、多类型合约），或需高度定制的中型以上企业</td></tr><tr><td>AI驱动开箱即用型</td><td>Freshsales、Insightly</td><td>中小企业，追求快速上线、AI辅助销售决策，无需复杂定制</td></tr><tr><td>流程/社交聚焦型</td><td>Pipedrive、Nimble</td><td>销售流程简单的中小团队（Pipedrive），或B2B社交营销为主的企业（Nimble）</td></tr><tr><td>生态协同型</td><td>钉钉CRM</td><td>内部已全面使用钉钉，需降低跨系统协同成本的企业</td></tr><tr><td>大型企业/全球化型</td><td>销售易CRM、Zoho CRM</td><td>大型制造业/ICT企业（销售易），或全球化外贸企业（Zoho CRM，多语言多货币支持）</td></tr></tbody></table><ul><li><ul><li>*</li></ul></li></ul><h2>五、选型决策建议</h2><ol><li><strong>如果重视全流程场景适配</strong>：优先选择超兔一体云，其“三一客节点+五大跟单模型”可精准匹配贸易、服务、定制等多业务场景。</li><li><strong>如果追求AI智能与快速上线</strong>：Freshsales是最优选择，Freddy AI的流失预警与自动化挽回策略可直接落地。</li><li><strong>如果依赖钉钉生态</strong>：钉钉CRM可实现“客户-内部协同”无缝联动，无需额外学习成本。</li><li><strong>如果是大型企业或全球化业务</strong>：销售易CRM（国内大型企业）、Zoho CRM（全球化外贸）是成熟之选，前者在行业案例与生态整合上更具优势。</li></ol><h2>六、总结</h2><p>企业选型CRM系统的核心是匹配自身业务特性与发展阶段：对于有复杂业务场景的中型企业，全流程定制化的超兔一体云、SuiteCRM能精准适配需求；中小企业追求快速落地时，AI驱动的Freshsales可直接发挥智能预警与自动化价值；依赖内部协同生态的企业，钉钉CRM能降低跨系统切换成本；大型企业或全球化业务则可选择销售易CRM（行业深度案例）、Zoho CRM（多语言多货币支持）构建客户管理体系。只有以自身核心需求为锚点，才能通过CRM实现从客户获取到留存复购的全链路价值闭环，提升企业在数字化竞争中的核心优势。</p>]]></description></item><item>    <title><![CDATA[最新，12款CRM品牌功能对比 傲视众生的脸盆 ]]></title>    <link>https://segmentfault.com/a/1190000047609277</link>    <guid>https://segmentfault.com/a/1190000047609277</guid>    <pubDate>2026-02-13 12:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>数字化转型浪潮下，企业对管理系统的需求早已从单一客户关系管理（CRM）升级为“业务运营+生产制造+项目管控+上下游协同”的全链路协同平台。本文选取12款主流产品，围绕<strong>业务管理、</strong> <strong>MES</strong> <strong>制造执行、项目管理、上下游协同</strong>四大核心维度展开深度横评，为不同行业、规模的企业提供选型参考。</p><ul><li><ul><li>*</li></ul></li></ul><h2>一、业务管理：从获客到回款，谁能实现全流程闭环？</h2><p>业务管理是企业管理系统的核心底座，涵盖获客、跟单、订单、财务、采购等全链路环节，其能力直接决定企业的运营效率与客户转化率。</p><h3>1. 核心能力对比表</h3><table><thead><tr><th>品牌/阵营</th><th>获客能力</th><th>跟单模型适配</th><th>订单财务管控</th><th>销售支持工具</th><th>业财融合能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>多渠道集客+营销成本核算</td><td>三一客/商机/多方项目</td><td>应收智能触发+收支差管控</td><td>武器云+智能话术+自动日报</td><td>原生闭环，一键生成财务凭证</td></tr><tr><td>SugarCRM</td><td>线索评分+营销自动化</td><td>自定义工作流</td><td>提成核算</td><td>知识库</td><td>需集成第三方ERP</td></tr><tr><td>HubSpot CRM</td><td>营销自动化+免费线索捕获</td><td>轻量级商机跟踪</td><td>销售预测</td><td>邮件营销工具</td><td>弱，依赖第三方财务工具</td></tr><tr><td>金蝶云CRM</td><td>线索分级+业财联动获客</td><td>标准销售流程</td><td>订单自动生成应收单</td><td>财务数据支撑</td><td>原生业财一体化</td></tr><tr><td>销售易CRM</td><td>AI潜客挖掘+全渠道获客</td><td>线索到回款全流程</td><td>CPQ报价管理</td><td>aPaaS定制工具</td><td>需集成ERP</td></tr><tr><td>Zoho CRM</td><td>销售自动化+BI分析</td><td>工作流定制</td><td>报价CPQ</td><td>零代码定制组件</td><td>集成Zoho Books</td></tr><tr><td>钉钉CRM</td><td>表单+服务群获客</td><td>轻量级跟进</td><td>基础回款跟踪</td><td>协同工具联动</td><td>弱</td></tr><tr><td>有赞</td><td>零售场景获客+会员管理</td><td>电商订单跟进</td><td>零售财务管控</td><td>营销活动工具</td><td>电商场景业财融合</td></tr></tbody></table><h3>2. 超兔业务管理模块全景脑图</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609279" alt="" title=""/></p><pre><code>mindmap
  root((超兔业务管理))
    市场与获客
      多渠道集客（百度/抖音/微信等）
      线索智能分配+自动提醒
      营销成本核算与效果分析
    客户中心
      三一客节点跟进模型
      五大跟单模型适配
      RFM客户价值分析+复购预警
    跟单中心
      360°跟单视图+时间线
      自动日报/周报生成
      客户分级+销售目标分解
    合同订单管理
      30种订单模型（B2C/B2B/O2O）
      BOM爆炸图下单+MES联动
      订单锁库+发货管控
    财务管控
      应收智能触发+多期拆分
      三流合一对账+信用管控
      收支差精准计算
    采购与库存
      智能供应商匹配
      多仓库管理+库存追溯
      采购计划自动生成</code></pre><h3>3. 各品牌深度解析</h3><ul><li><strong>超兔一体云</strong>：以“全链路闭环”为核心，覆盖从获客到售后的所有环节，独创的“三一客”小单快跟模型、多方项目跟单模型适配不同业务场景，业财融合能力原生内置，无需第三方集成即可实现收支差管控与财务凭证自动生成，适合有生产、项目需求的全品类企业。</li><li><strong>海外CRM（Sugar/HubSpot/Suite）</strong> ：Sugar/SuiteCRM以开源定制为优势，适合技术能力强的企业；HubSpot侧重营销自动化，免费版可满足中小企业基础需求，但本土化适配（如微信生态、国内财务规则）较弱。</li><li><strong>国内ERP系CRM（金蝶/用友）</strong> ：依托ERP的天然优势，业财一体化能力突出，但业务环节的灵活性（如定制跟单模型）弱于超兔。</li><li><strong>国内SaaS CRM（销售易/Zoho）</strong> ：销售易以AI获客和aPaaS定制见长，适合复杂流程企业；Zoho CRM零代码定制能力强，生态工具丰富，但缺乏生产端联动能力。</li></ul><h3>4. 雷达图分值（1-10分）</h3><table><thead><tr><th>品牌</th><th>业务管理得分</th></tr></thead><tbody><tr><td>超兔一体云</td><td>9</td></tr><tr><td>金蝶云CRM</td><td>8</td></tr><tr><td>用友CRM</td><td>8</td></tr><tr><td>销售易CRM</td><td>8</td></tr><tr><td>SugarCRM</td><td>7</td></tr><tr><td>HubSpot CRM</td><td>7</td></tr><tr><td>Zoho CRM</td><td>7</td></tr><tr><td>SuiteCRM</td><td>6</td></tr><tr><td>有赞</td><td>6</td></tr><tr><td>钉钉CRM</td><td>5</td></tr></tbody></table><ul><li><ul><li>*</li></ul></li></ul><h2>二、MES制造执行：生产与业务的联动，谁能打破数据孤岛？</h2><p>MES是连接业务端与生产端的关键模块，直接决定企业从订单到交付的协同效率，目前仅少数国内品牌具备原生或深度集成的MES能力。</p><h3>1. MES核心能力对比表</h3><table><thead><tr><th>品牌</th><th>核心MES模块</th><th>与CRM联动能力</th><th>轻量化程度</th><th>行业适配</th></tr></thead><tbody><tr><td>超兔一体云</td><td>智能排程/报工/质检/入库</td><td>订单-BOM-生产-库存全闭环</td><td>高（小微生产友好）</td><td>离散制造/装配型企业</td></tr><tr><td>金蝶云CRM</td><td>轻智造数字工厂（工单/报工）</td><td>生产数据同步至CRM生成交付报告</td><td>中</td><td>中大型制造企业</td></tr><tr><td>其他品牌</td><td>无原生能力，需第三方集成</td><td>数据单向同步，无闭环</td><td>-</td><td>-</td></tr></tbody></table><h3>2. 超兔CRM-MES联动时序图</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609280" alt="" title="" loading="lazy"/></p><pre><code>sequenceDiagram
    participant CRM as 超兔CRM
    participant MES as 超兔MES
    participant 仓库 as 库存模块
    participant 采购 as 采购模块

    CRM-&gt;&gt;MES: 同步订单数据+生产BOM清单
    MES-&gt;&gt;采购: 计算子料需求+自动生成采购计划
    MES-&gt;&gt;仓库: 生成精准领料单
    仓库-&gt;&gt;MES: 确认物料出库
    MES-&gt;&gt;CRM: 回传领料数据，更新订单进度
    MES-&gt;&gt;MES: 生产报工+工序质检
    MES-&gt;&gt;仓库: 合格成品入库单
    仓库-&gt;&gt;CRM: 更新成品库存，触发发货提醒
    MES-&gt;&gt;CRM: 回传报工/质检数据，完成生产闭环</code></pre><h3>3. 各品牌深度解析</h3><ul><li><strong>超兔一体云</strong>：专为小微生产企业打造轻量化MES，与CRM原生联动实现“订单-生产-库存-财务”全闭环，无需额外集成成本，支持BOM爆炸图下单、智能排程、成品入库自动同步库存，适合需要快速实现生产数字化的中小制造企业。</li><li><strong>金蝶云CRM</strong>：通过“轻智造数字工厂”模块实现生产基础管理，但MES与CRM的联动仅停留在数据同步层面，未形成全流程闭环，更适合已使用金蝶ERP的中大型制造企业。</li><li><strong>其他品牌</strong>：海外CRM、销售易、Zoho、钉钉等均无原生MES能力，需通过第三方集成工具实现生产数据同步，成本高且协同效率低。</li></ul><h3>4. 雷达图分值（1-10分）</h3><table><thead><tr><th>品牌</th><th>MES能力得分</th></tr></thead><tbody><tr><td>超兔一体云</td><td>8</td></tr><tr><td>金蝶云CRM</td><td>7</td></tr><tr><td>用友CRM</td><td>3</td></tr><tr><td>其他品牌</td><td>1</td></tr></tbody></table><ul><li><ul><li>*</li></ul></li></ul><h2>三、项目管理：全周期管控，谁能适配复杂业务场景？</h2><p>项目管理能力决定企业对大型订单、多参与方业务的管控水平，核心在于进度跟踪、成本管控与多方协同。</p><h3>1. 核心能力对比表</h3><table><thead><tr><th>品牌</th><th>核心项目功能</th><th>成本管控能力</th><th>多方协同支持</th><th>行业适配</th></tr></thead><tbody><tr><td>超兔一体云</td><td>多方项目模型+收支差管控</td><td>实时计算项目收支差</td><td>项目组/合同/采购全视图</td><td>工程/装备制造/大型服务</td></tr><tr><td>销售易CRM</td><td>服务项目管理+交付流程跟踪</td><td>基础成本统计</td><td>内部团队协同</td><td>装备制造/服务行业</td></tr><tr><td>Zoho CRM</td><td>集成Zoho Projects</td><td>资源分配+成本预算</td><td>跨工具协同</td><td>通用行业</td></tr><tr><td>SugarCRM</td><td>自定义模块扩展任务跟踪</td><td>无原生能力</td><td>需自定义工作流</td><td>技术型企业</td></tr><tr><td>HubSpot CRM</td><td>轻量级任务管理（需集成）</td><td>无</td><td>弱</td><td>小微企业</td></tr><tr><td>钉钉/有赞</td><td>无专业项目管理模块</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h3>2. 超兔多方项目管理脑图</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609281" alt="" title="" loading="lazy"/></p><pre><code>mindmap
  root((超兔多方项目管理))
    项目全景视图
      项目组人员管理
      关联合同/订单/采购单
      收支数据实时汇总
    进度管控
      甘特图可视化跟踪
      实际vs计划偏差预警
      自动生成项目周报
    成本管控
      收支差实时计算
      采购/费用审批联动
      预算超支预警
    多方协同
      分组隔离跟单
      上级客户数据汇总
      跨部门任务分配</code></pre><h3>3. 各品牌深度解析</h3><ul><li><strong>超兔一体云</strong>：独创“多方项目模型”，在一个视图内实现项目组、合同、采购、收支的全周期管理，精准控制项目收支差，特别适合涉及多参与方的大型工程、装备制造项目。</li><li><strong>销售易/Zoho</strong>：销售易的服务项目模块聚焦售后交付流程；Zoho通过集成自有Projects实现通用项目管理，但均未实现项目与业务、财务的深度闭环。</li><li><strong>海外CRM</strong>：Sugar/SuiteCRM需通过自定义模块扩展基础任务跟踪能力，缺乏成本管控与多方协同的原生功能；HubSpot仅支持轻量级任务管理，无法满足复杂项目需求。</li></ul><h3>4. 雷达图分值（1-10分）</h3><table><thead><tr><th>品牌</th><th>项目管理得分</th></tr></thead><tbody><tr><td>超兔一体云</td><td>8</td></tr><tr><td>金蝶云CRM</td><td>8</td></tr><tr><td>用友CRM</td><td>8</td></tr><tr><td>Zoho CRM</td><td>8</td></tr><tr><td>销售易CRM</td><td>7</td></tr><tr><td>SugarCRM</td><td>4</td></tr><tr><td>SuiteCRM</td><td>4</td></tr><tr><td>HubSpot CRM</td><td>3</td></tr><tr><td>钉钉/有赞</td><td>2</td></tr></tbody></table><ul><li><ul><li>*</li></ul></li></ul><h2>四、上下游管理：产业链协同，谁能构建共生生态？</h2><p>上下游管理能力决定企业与供应商、渠道伙伴的协同效率，核心在于数据打通、流程透明与价值共享。</p><h3>1. 核心能力对比表</h3><table><thead><tr><th>品牌</th><th>协同模式</th><th>三流合一（货/款/票）</th><th>伙伴赋能工具</th><th>行业适配</th></tr></thead><tbody><tr><td>超兔一体云</td><td>OpenCRM共生平台</td><td>原生支持</td><td>询价/报价/对账全协同</td><td>全行业，尤其多伙伴企业</td></tr><tr><td>金蝶云CRM</td><td>ERP集成供应链</td><td>支持</td><td>采购订单同步</td><td>制造/分销行业</td></tr><tr><td>销售易CRM</td><td>分销渠道门户</td><td>需集成ERP</td><td>渠道订货商城</td><td>分销型企业</td></tr><tr><td>Zoho CRM</td><td>渠道伙伴门户</td><td>需集成财务工具</td><td>伙伴数据同步</td><td>通用行业</td></tr><tr><td>HubSpot CRM</td><td>客户自助服务门户</td><td>无</td><td>知识普及</td><td>服务型企业</td></tr><tr><td>钉钉CRM</td><td>客户群/服务窗协同</td><td>无</td><td>表单/消息提醒</td><td>小微企业</td></tr></tbody></table><h3>2. 超兔OpenCRM上下游协同流程图</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609282" alt="" title="" loading="lazy"/></p><pre><code>flowchart LR
    A[企业内部CRM] --&gt; B[OpenCRM共生平台]
    C[供应商] --&gt; B
    D[客户/渠道伙伴] --&gt; B
    B --&gt; E[询价/报价在线协同]
    B --&gt; F[订单/采购单实时同步]
    B --&gt; G[物流/收货在线确认]
    B --&gt; H[货/款/票三流合一对账]
    B --&gt; I[售后/投诉闭环处理]
    E --&gt; A
    F --&gt; A
    G --&gt; A
    H --&gt; A
    I --&gt; A</code></pre><h3>3. 各品牌深度解析</h3><ul><li><strong>超兔一体云</strong>：通过OpenCRM共生平台实现企业与供应商、客户的全流程协同，支持询价、订单、对账、售后的在线闭环，三流合一能力原生内置，无需第三方集成即可实现产业链数据透明化，适合需要深度协同的多伙伴企业。</li><li><strong>金蝶/用友</strong>：依托ERP系统实现上下游数据同步，但协同模式以“企业内部为核心”，伙伴参与度低，缺乏专门的共生平台。</li><li><strong>销售易/Zoho</strong>：销售易的分销渠道门户聚焦渠道订货；Zoho的伙伴门户实现数据同步，但均未实现三流合一的原生闭环。</li><li><strong>海外CRM/钉钉</strong>：仅支持客户自助服务或轻量级消息协同，无法满足复杂的上下游供应链管理需求。</li></ul><h3>4. 雷达图分值（1-10分）</h3><table><thead><tr><th>品牌</th><th>上下游管理得分</th></tr></thead><tbody><tr><td>超兔一体云</td><td>9</td></tr><tr><td>金蝶云CRM</td><td>8</td></tr><tr><td>用友CRM</td><td>8</td></tr><tr><td>有赞</td><td>7</td></tr><tr><td>销售易CRM</td><td>7</td></tr><tr><td>钉钉CRM</td><td>6</td></tr><tr><td>Zoho CRM</td><td>6</td></tr><tr><td>HubSpot CRM</td><td>5</td></tr><tr><td>SugarCRM</td><td>5</td></tr><tr><td>SuiteCRM</td><td>4</td></tr></tbody></table><ul><li><ul><li>*</li></ul></li></ul><h2>五、总结与选型建议</h2><h3>1. 综合雷达图得分汇总</h3><table><thead><tr><th>品牌</th><th>业务管理</th><th>MES</th><th>项目管理</th><th>上下游管理</th><th>总分</th></tr></thead><tbody><tr><td>超兔一体云</td><td>9</td><td>8</td><td>8</td><td>9</td><td>34</td></tr><tr><td>金蝶云CRM</td><td>8</td><td>7</td><td>8</td><td>8</td><td>31</td></tr><tr><td>用友CRM</td><td>8</td><td>3</td><td>8</td><td>8</td><td>27</td></tr><tr><td>销售易CRM</td><td>8</td><td>2</td><td>7</td><td>7</td><td>24</td></tr><tr><td>Zoho CRM</td><td>7</td><td>1</td><td>8</td><td>6</td><td>22</td></tr><tr><td>SugarCRM</td><td>7</td><td>1</td><td>4</td><td>5</td><td>17</td></tr><tr><td>HubSpot CRM</td><td>7</td><td>1</td><td>3</td><td>5</td><td>16</td></tr><tr><td>有赞</td><td>6</td><td>1</td><td>2</td><td>7</td><td>16</td></tr><tr><td>钉钉CRM</td><td>5</td><td>1</td><td>2</td><td>6</td><td>14</td></tr><tr><td>SuiteCRM</td><td>6</td><td>1</td><td>4</td><td>4</td><td>15</td></tr></tbody></table><h3>2. 选型指南</h3><ul><li><strong>生产制造型企业</strong>：优先选择<strong>超兔一体云</strong>（轻量化MES+全链路闭环）或<strong>金蝶云CRM</strong>（ERP联动+业财融合），实现销售-生产-库存的协同。</li><li><strong>营销驱动型企业</strong>：选择<strong>HubSpot CRM</strong>（免费版+营销自动化）或<strong>销售易CRM</strong>（AI获客+全渠道覆盖），提升获客与转化效率。</li><li><strong>技术定制型企业</strong>：选择<strong>SugarCRM/SuiteCRM</strong>（开源定制+灵活扩展），适配复杂业务逻辑。</li><li><strong>电商零售型企业</strong>：选择<strong>有赞</strong>（零售场景深度适配+会员管理）或<strong>Zoho CRM</strong>（零代码定制+生态工具）。</li><li><strong>小微企业</strong>：选择<strong>钉钉CRM</strong>（轻量化协同+低门槛）或<strong>HubSpot CRM免费版</strong>（基础获客+客户管理）。</li></ul>]]></description></item><item>    <title><![CDATA[【节点】[BakedGI节点]原理解析与实际应用 SmalBox ]]></title>    <link>https://segmentfault.com/a/1190000047608829</link>    <guid>https://segmentfault.com/a/1190000047608829</guid>    <pubDate>2026-02-13 11:10:43</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><a href="https://link.segmentfault.com/?enc=GwUKvKxI6uOcjHYes3VY%2Bw%3D%3D.QUavwJkIbsqGcPHcpAS5MGYAet57SZdI69PyvV8twvj48nIrjHDjNrT6O%2F%2FldXwIQa68KzVnsOQFJ02RRhT9OTN3Im2ADcuPhRsy60gOEf0BkrvRST8GmXlBfa66CNViF9w%2FYeNsJlLr6tvLyg%2BZHDtfmfu190w0MuFt4Vw%2BFt8sQnObMdqO7ygvzEq0zLoUnRYMDAJVC52oGJW5b1GgyPUeDRcrLo8SS9Egp2%2BNNsU%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong></blockquote><p>Baked GI 节点是 Unity URP Shader Graph 中一个重要的光照计算节点，它允许着色器访问预计算的光照信息，为场景中的静态物体提供高质量的间接光照效果。在实时渲染中，全局光照（Global Illumination）的计算通常非常耗费性能，因此 Unity 提供了烘焙光照的解决方案，将复杂的光照计算预先处理并存储在光照贴图或光照探针中，运行时直接采样这些预计算数据，既能保证视觉效果又能保持高性能。</p><p>该节点的核心功能是根据物体的位置和朝向，从预先烘焙的光照数据中获取相应的光照颜色值。这些数据可以来自两种主要来源：光照贴图用于静态几何体，以及光照探针用于动态物体或需要动态光照的静态物体。通过合理使用 Baked GI 节点，开发者可以创建出具有丰富间接光照和真实感光照交互的着色器，而无需承担实时全局光照计算的性能开销。</p><p>在 URP 管线中，Baked GI 节点的实现经过了优化，专门针对移动平台和性能敏感的场景。与内置渲染管线或 HDRP 相比，URP 中的 Baked GI 节点可能有一些特定的限制和行为差异，但这些差异主要是为了确保在目标平台上的最佳性能表现。理解这些差异对于创建跨管线兼容的着色器至关重要。</p><h2>描述</h2><p>Baked GI 节点为着色器提供了访问烘焙全局光照值的能力，这些值可以在顶点着色器或片元着色器阶段使用。节点需要几个关键的输入参数来确定如何采样光照数据，包括世界空间中的位置和法线向量，以及用于光照贴图采样的 UV 坐标。</p><h3>烘焙全局光照基础</h3><p>烘焙全局光照是 Unity 光照系统的重要组成部分，它通过预计算场景中光线如何在不同表面之间反射和传播，生成静态的光照信息。这个过程包括直接光照和间接光照的计算，但只针对标记为静态的物体进行。烘焙完成后，光照信息会被存储到光照贴图或光照探针中：</p><ul><li>光照贴图是应用于静态几何体的纹理，包含预先计算的光照信息</li><li>光照探针是在场景空间中放置的采样点，存储了该位置的光照信息，可用于动态物体或需要动态光照的静态物体</li></ul><p>Baked GI 节点的作用就是在着色器执行时，根据提供的输入参数，从这些预计算的光照数据中获取相应的颜色值。</p><h3>位置和法线输入的重要性</h3><p>位置和法线输入对于正确采样光照探针数据至关重要。光照探针数据是基于球谐函数编码的，这种编码方式能够高效地存储全方向的光照信息。当着色器需要获取某点的光照信息时，系统会根据该点的位置找到最近的光照探针组，然后使用法线方向来评估球谐函数，得到该方向上的光照颜色。</p><p>如果提供的位置或法线不正确，可能会导致光照采样错误，表现为不自然的光照过渡或错误的光照方向。因此，确保这些输入参数的准确性是使用 Baked GI 节点的关键。</p><h3>光照贴图坐标的作用</h3><p>Static UV 和 Dynamic UV 输入用于采样不同类型的光照贴图：</p><ul><li>Static UV 通常对应网格的 UV1 通道，用于采样静态光照贴图</li><li>Dynamic UV 通常对应网格的 UV2 通道，用于采样动态全局光照的光照贴图</li></ul><p>在 Unity 的光照设置中，开发者可以选择使用不同的光照模式，如 Baked、Mixed 或 Realtime。对于 Mixed 光照模式的静态物体，Unity 会生成两套光照贴图：一套用于完全烘焙的光照，另一套用于与实时光照结合的效果。Baked GI 节点通过不同的 UV 输入来访问这些不同的光照贴图。</p><h3>节点行为的管线依赖性</h3><p>一个重要的注意事项是，Baked GI 节点的具体行为并未在全局范围内统一定义。Shader Graph 本身并不定义这个节点的功能实现，而是由每个渲染管线决定为此节点生成什么样的 HLSL 代码。这意味着：</p><ul><li>在高清渲染管线中，Baked GI 节点可能有特定的优化和功能</li><li>在通用渲染管线中，节点的实现可能更注重性能和跨平台兼容性</li><li>在内置渲染管线中，节点的行为可能又有所不同</li></ul><p>这种设计使得每个渲染管线可以根据自身的架构和需求，优化 Baked GI 节点的实现方式。对于着色器开发者来说，这意味着如果计划创建在多种渲染管线中使用的着色器，需要在每个目标管线中测试 Baked GI 节点的行为，确保它按预期工作。</p><h3>无光照着色器中的限制</h3><p>在 URP 和 HDRP 中，Baked GI 节点不能在无光照着色器中使用。无光照着色器通常用于不需要复杂光照计算的物体，如UI元素、粒子效果或特殊效果。这些着色器通常会绕过管线的标准光照流程，因此无法访问烘焙全局光照数据。</p><p>如果尝试在无光照着色器中使用 Baked GI 节点，可能会遇到编译错误或运行时错误。对于需要简单光照的无光照物体，考虑使用其他光照技术，如顶点光照或简单的漫反射计算。</p><h2>端口</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608831" alt="" title=""/></p><p>Baked GI 节点包含多个输入端口和一个输出端口，每个端口都有特定的功能和数据要求。理解这些端口的作用对于正确使用节点至关重要。</p><h3>Position 输入端口</h3><p>Position 输入端口接收世界空间中的位置坐标，用于确定光照采样的空间位置。这个位置信息主要用于：</p><ul><li>光照探针采样：确定使用哪些光照探针的数据</li><li>光照贴图索引：在某些情况下，帮助确定使用哪张光照贴图</li></ul><p>在大多数情况下，应该将物体的世界空间位置连接到这个端口。在顶点着色器阶段使用 Baked GI 节点时，可以使用 Position 节点获取顶点在世界空间中的位置；在片元着色器阶段使用时，可以使用屏幕位置或通过其他方式计算得到的世界位置。</p><p>当使用光照探针时，位置输入的准确性尤为重要。如果位置偏差过大，可能会导致物体采样到错误位置的光照探针数据，造成光照不匹配的现象。</p><h3>Normal 输入端口</h3><p>Normal 输入端口接收世界空间中的法线向量，用于确定表面朝向，从而影响光照采样的方向。法线输入的主要作用包括：</p><ul><li>光照探针评估：球谐光照基于法线方向评估光照颜色</li><li>光照贴图采样：在某些高级用法中，法线可能影响光照贴图的采样方式</li></ul><p>法线向量应当是世界空间中的单位向量。如果提供的法线没有归一化，可能会导致光照计算错误。通常情况下，可以使用 Transform 节点将物体空间法线转换到世界空间，并确保使用正确的变换矩阵（通常是转置逆矩阵）。</p><p>对于动态法线效果（如法线贴图），需要将修改后的法线向量连接到 Normal 端口，这样 Baked GI 节点就会基于修改后的表面朝向计算光照，创造出更加丰富的视觉效果。</p><h3>Static UV 输入端口</h3><p>Static UV 输入端口用于指定静态光照贴图的纹理坐标。这些坐标通常对应于网格的 UV1 通道，也就是在建模软件中为光照贴图准备的 UV 集。Static UV 的作用包括：</p><ul><li>采样完全烘焙的光照贴图</li><li>访问静态物体的间接光照信息</li><li>在 Mixed 光照模式下，采样烘焙的间接光照部分</li></ul><p>当场景中使用 Baked 或 Mixed 光照模式时，Unity 会为静态物体生成光照贴图。这些光照贴图包含了预计算的直接和间接光照信息。Static UV 输入确保着色器能够正确访问这些光照数据。</p><p>如果网格没有正确设置光照贴图 UV，或者 Static UV 输入不正确，可能会导致光照贴图采样错误，表现为拉伸、扭曲或重复的光照图案。</p><h3>Dynamic UV 输入端口</h3><p>Dynamic UV 输入端口用于指定动态光照贴图的纹理坐标，通常对应于网格的 UV2 通道。Dynamic UV 的主要应用场景包括：</p><ul><li>在 Mixed 光照模式下，采样用于实时光照交互的光照贴图</li><li>访问动态全局光照系统生成的光照信息</li><li>处理需要与实时光源交互的静态物体的光照</li></ul><p>在 Mixed 光照模式下，Unity 会为静态物体生成两套光照贴图：一套用于完全烘焙的光照（通过 Static UV 访问），另一套用于与实时光源结合的效果（通过 Dynamic UV 访问）。这种设计允许静态物体既受益于高质量的烘焙光照，又能与场景中的实时光源正确交互。</p><h3>Out 输出端口</h3><p>Out 输出端口提供从烘焙全局光照系统采样的颜色值。这个输出是三维向量，表示 RGB 颜色空间中的光照颜色。输出的光照值已经考虑了：</p><ul><li>直接光照和间接光照的贡献</li><li>颜色反射和光能传递效果</li><li>场景的环境光遮蔽</li></ul><p>输出的颜色值通常需要与材质的反照率颜色相乘，以实现正确的光照着色。在基于物理的着色模型中，Baked GI 的输出代表入射光强度，应当与表面反照率相乘来计算出射光强度。</p><p>在某些高级用法中，Baked GI 的输出可以用于更复杂的光照计算，如与实时光照结合，或作为其他着色效果的输入。</p><h2>控件</h2><p>Baked GI 节点提供了一个重要的控件选项，用于调整光照贴图的处理方式。</p><h3>Apply Lightmap Scaling 切换</h3><p>Apply Lightmap Scaling 是一个布尔切换控件，决定是否对光照贴图坐标自动应用缩放和偏移。这个选项默认为启用状态，在大多数情况下应该保持启用。</p><p>当启用 Apply Lightmap Scaling 时，节点会自动应用 Unity 光照系统中定义的光照贴图缩放和偏移变换。这些变换确保光照贴图正确映射到网格表面，考虑到了光照贴图的分包、排列和压缩设置。</p><p>禁用 Apply Lightmap Scaling 的情况较为少见，通常只在以下特定场景中考虑：</p><ul><li>当手动处理光照贴图坐标时</li><li>当使用自定义的光照贴图布局时</li><li>在某些特殊效果着色器中，需要直接访问原始光照贴图坐标</li></ul><p>在大多数标准用法中，建议保持此选项启用，以确保光照贴图正确映射。如果禁用此选项，需要手动确保光照贴图坐标的正确性，否则可能导致光照贴图采样错误。</p><h2>生成代码示例</h2><p>Baked GI 节点在生成着色器代码时，会根据所在的渲染管线产生相应的 HLSL 代码。以下示例展示了 URP 中 Baked GI 节点可能生成的代码结构。</p><h3>基本函数定义</h3><pre><code>HLSL

void Unity_BakedGI_float(float3 Position, float3 Normal, float2 StaticUV, float2 DynamicUV, out float3 Out)
{
    Out = SHADERGRAPH_BAKED_GI(Position, Normal, StaticUV, DynamicUV, false);
}</code></pre><p>这个函数定义展示了 Baked GI 节点的基本代码结构。函数接收位置、法线和光照贴图坐标作为输入，通过 SHADERGRAPH_BAKED_GI 宏计算烘焙全局光照值，并将结果输出到 Out 参数。</p><p>SHADERGRAPH_BAKED_GI 是一个由 Shader Graph 系统定义的宏，它的具体实现取决于目标渲染管线。在 URP 中，这个宏会展开为访问 URP 烘焙光照系统的代码。</p><h3>实际应用示例</h3><p>在实际的着色器中，Baked GI 节点通常与其他光照计算结合使用。以下是一个简单的表面着色器示例，展示如何将 Baked GI 与实时直接光照结合：</p><pre><code>HLSL

void surf(Input IN, inout SurfaceOutputStandard o)
{
    // 采样反照率贴图
    fixed4 albedo = tex2D(_MainTex, IN.uv_MainTex) * _Color;

    // 获取烘焙全局光照
    float3 bakedGI;
    Unity_BakedGI_float(IN.worldPos, IN.worldNormal, IN.uv1, IN.uv2, bakedGI);

    // 计算实时直接光照（简化示例）
    float3 directLight = _LightColor0 * max(0, dot(IN.worldNormal, _WorldSpaceLightPos0.xyz));

    // 结合光照
    o.Albedo = albedo.rgb;
    o.Emission = bakedGI * albedo.rgb;
    // 直接光照已经在光照模型中处理
}</code></pre><p>这个示例展示了烘焙间接光照与实时直接光照的基本结合方式。在实际的 URP 着色器中，光照计算可能更加复杂，涉及更多光照模型和渲染特性。</p><h3>顶点与片元着色器中的使用</h3><p>Baked GI 节点既可以在顶点着色器中使用，也可以在片元着色器中使用，取决于性能和质量的需求：</p><p><strong>顶点着色器中使用：</strong></p><pre><code>HLSL

v2f vert (appdata v)
{
    v2f o;
    // ... 其他顶点变换

    // 在顶点着色器中计算烘焙GI
    Unity_BakedGI_float(mul(unity_ObjectToWorld, v.vertex).xyz,
                        normalize(mul(v.normal, (float3x3)unity_WorldToObject)),
                        v.uv1, v.uv2, o.bakedGI);

    return o;
}</code></pre><p><strong>片元着色器中使用：</strong></p><pre><code>HLSL

fixed4 frag (v2f i) : SV_Target
{
    // 在片元着色器中计算烘焙GI（更高质量）
    float3 bakedGI;
    Unity_BakedGI_float(i.worldPos, normalize(i.worldNormal), i.uv1, i.uv2, bakedGI);

    // ... 其他着色计算
}</code></pre><p>在顶点着色器中使用 Baked GI 性能更好，但光照细节较少；在片元着色器中使用质量更高，但性能开销更大。根据目标平台和性能要求选择合适的阶段。</p><h2>最佳实践和性能考虑</h2><p>使用 Baked GI 节点时，遵循一些最佳实践可以确保最佳的性能和视觉效果。</p><h3>光照贴图设置优化</h3><p>确保场景的光照贴图设置正确优化：</p><ul><li>使用适当的光照贴图分辨率，平衡质量和内存使用</li><li>合理设置光照贴图压缩，在移动平台上使用压缩格式</li><li>对不需要高质量光照的物体使用较低的光照贴图分辨率</li></ul><h3>光照探针布局优化</h3><p>光照探针的布局影响动态物体的光照质量：</p><ul><li>在光照变化明显的区域放置更多光照探针</li><li>确保动态物体的移动路径上有足够的光照探针覆盖</li><li>使用光照探针代理卷提高大范围区域的光照探针效率</li></ul><h3>着色器性能优化</h3><p>在着色器中使用 Baked GI 节点时考虑性能：</p><ul><li>在移动平台上，考虑在顶点着色器中使用 Baked GI</li><li>对于远处物体，使用简化的光照计算</li><li>避免在透明物体的着色器中过度使用复杂的光照计算</li></ul><h3>跨管线兼容性</h3><p>如果计划创建跨渲染管线使用的着色器：</p><ul><li>在目标管线中测试 Baked GI 节点的行为</li><li>使用着色器变体或自定义函数处理管线特定的差异</li><li>提供回退方案，当 Baked GI 节点不可用时使用替代光照计算</li></ul><hr/><blockquote><a href="https://link.segmentfault.com/?enc=jLzzH1%2FMiofgVm3SyP2B8Q%3D%3D.AFNApiACI4IOkoi6aowpmuKydk%2FFqiJpUhM9HG3iFM581TqfCwGI7RcXWgjxAxEF%2BIBA2Y29xDZLZVZcmz2F8WPngRMtQMI7an2hagizmF9YGhfrPTdzdlnAu6BQoSDDNfA4G0rlwRydsjfoIMqM4r8cdSn8EK5a5G7tGFHdLVGrOIl7Hrqv6QYxGsliRHIbQVdok7EE7MCkw6TyW%2BhDsRJxKB4EStKqE5TXgTavM4c%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong><br/>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</blockquote>]]></description></item><item>    <title><![CDATA[uv × pyseekdb：把 RAG 环境与检索落地成本降到最低 老纪的技术唠嗑局 ]]></title>    <link>https://segmentfault.com/a/1190000047608857</link>    <guid>https://segmentfault.com/a/1190000047608857</guid>    <pubDate>2026-02-13 11:09:58</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>01 AI 开发者的基建</h2><p>过去很多团队把主要精力放在算法本身；在大模型生态成熟后，工程侧更常见的阻塞变成两类：一是环境与依赖的可复现，二是数据导入、检索与存储的落地成本。AI 项目往往带着较重的依赖组合（如 PyTorch、Transformers、各类 RAG 框架），如果每次协作、换机器、进 CI 都要重新处理 Python 版本、虚拟环境、锁文件与依赖冲突，成本会被放大。</p><p>这篇文章介绍两个工具，目标是把环境成本和检索数据落地成本更低：</p><ul><li><code>uv</code>：由 Astral 团队推出的 Rust 编写的 Python 包管理器，以速度与一致性优化 Python 工作流。</li><li><code>pyseekdb</code>：面向 seekdb 与 OceanBase AI search 的 Python SDK，支持嵌入式与远程两种部署方式，并覆盖向量、全文与混合检索能力。</li></ul><h2>02 什么是 uv</h2><p>在 Python 生态里，装包本身并不难，难在团队协作下的一致性：不同人用不同工具（<code>pip+venv</code>/<code>poetry</code>），再叠加不同 OS、代理、CPU 架构，常见结果是代码没问题，但别人跑不起来。</p><p>uv 的项目模式围绕 <code>pyproject.toml</code> 管依赖、用 <code>uv.lock</code> 锁定解析结果，并通过 <code>uv sync</code>/<code>uv run</code>让环境与锁文件保持一致。它的定位很明确：<strong>用一个命令行把项目、依赖、锁版本、环境同步与运行命令这一整套工作流连起来，并强调性能与工程化一致性。</strong></p><h2>03 pyseekdb 简介</h2><p>RAG 场景里，开发者通常需要把文本切分、向量化、入库、检索、过滤、排序这一套链路跑通。pyseekdb 提供的是偏应用侧的 SDK：以 collection 为中心组织数据与检索逻辑，覆盖向量、全文与混合检索，并同时支持嵌入式与远程模式。</p><h3>3.1 两种连接形态</h3><p>pyseekdb 支持：</p><ul><li>嵌入式：在 Python 进程内使用本地路径持久化数据，适合本地实验、测试或轻量应用。</li><li>远程：连接到远程 seekdb 服务或 OceanBase 集群。</li></ul><h3>3.2 混合检索（Hybrid Search）</h3><p>在 pyseekdb 中，可以通过 query 调用执行向量检索或混合检索（由后端能力与配置决定），返回包含相似度与文档片段的结果集。与直接操控底层索引相比，这种方式更适合应用侧快速落地。</p><h3>04 为什么 pyseekdb 需要 uv</h3><p>pyseekdb 本身不一定重，但它经常会和 LangChain、LlamaIndex、Dify 等组合使用。一旦依赖开始变重，环境初始化与复现就更容易拖慢协作效率。<br/><code>uv</code> 在这里的价值主要是两点：</p><ul><li>用 <code>uv.lock</code> 明确锁定解析结果，并用 <code>uv sync</code> / <code>uv run</code> 把安装/同步/运行收敛到更少的步骤。</li><li>在共享 demo 时，用 <code>uv sync</code> 或 <code>uv run</code> 尽量复现同一套环境。</li></ul><p><strong>pyseekdb 的嵌入式特性配合 uv 的轻量环境，让开发者在普通笔记本上就能完成从数据导入、索引构建到 RAG 问答的全流程开发。</strong></p><h3>05 手把手教你轻松构建</h3><p>下面用 pyseekdb GitHub 官方 demo/rag 跑通一条完整链路，目标是让你在 5 分钟内从“环境准备”到“可查询的知识库界面”。</p><p><strong>前置条件</strong>：</p><ul><li>Python 3.11+</li><li>已安装 uv</li><li>已准备 LLM API Key（用于生成回答）</li><li>pyseekdb</li></ul><p><strong>步骤 1：准备环境</strong></p><pre><code class="plain">git clone https://github.com/oceanbase/pyseekdb.git
cd demo/rag
uv sync</code></pre><p>如果需要本地模型（<code>sentence-transformers</code>）</p><pre><code class="plain">uv sync --extra local</code></pre><p><strong>步骤 2：配置 .env</strong></p><pre><code class="plain">cp .env.example .env</code></pre><p>推荐先用默认 embedding（无需额外 API Key）：</p><pre><code class="plain">EMBEDDING_FUNCTION_TYPE=default
OPENAI_API_KEY=sk-your-key
OPENAI_BASE_URL=https://dashscope.aliyuncs.com/compatible-mode/v1
OPENAI_MODEL_NAME=qwen-plus
SEEKDB_DIR=./data/seekdb_rag
SEEKDB_NAME=test
COLLECTION_NAME=embeddings</code></pre><p><strong>说明</strong>：</p><ul><li>default 会自动下载内置 ONNX 模型，适合先验证流程。</li><li>若改为 api，请补齐<code>EMBEDDING_*</code>相关配置。</li><li>若改为 local，请配置<code>SENTENCE_TRANSFORMERS_*</code>并确保已安装<code>--extra local</code>依赖。</li></ul><p><strong>步骤 3：导入数据</strong></p><pre><code class="plain">uv run python seekdb_insert.py ../../README.md</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608859" alt="" title=""/></p><p>也可以导入目录：</p><pre><code class="plain">uv run python seekdb_insert.py path/to/your_dir</code></pre><p>你会看到脚本输出导入的分块数量与进度，成功后数据会落在<code>SEEKDB_DIR</code>指定目录中。</p><p><strong>步骤 4：启动界面</strong></p><pre><code class="plain">uv run streamlit run seekdb_app.py</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608860" alt="" title="" loading="lazy"/></p><p>启动后打开浏览器，在输入框里提问即可看到：</p><ul><li>检索到的相关片段</li><li>LLM 的生成回答（依赖你在<code>.env</code>里配置的 LLM）</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608861" alt="" title="" loading="lazy"/></p><p><strong>效果：</strong></p><ul><li>文档被切分、向量化并写入 seekdb</li><li>查询时执行向量/混合检索</li><li>UI 中展示检索结果与 LLM 生成答案</li></ul><h2>06 回归开发的本质</h2><p>uv 解决的是项目环境可复现与流程收敛，pyseekdb 解决的是RAG 场景下的存储与检索落地成本和易用性。把两者放在一起，是把 demo 交付与协作时的摩擦做小：项目结构、依赖、运行方式更统一；本地 embedded 能快速开始，之后再按需要切到远程服务。</p>]]></description></item><item>    <title><![CDATA[Acrobat 2022安装教程 Windows版：详细步骤+自定义安装路径指南（附下载提示） 小童]]></title>    <link>https://segmentfault.com/a/1190000047608874</link>    <guid>https://segmentfault.com/a/1190000047608874</guid>    <pubDate>2026-02-13 11:09:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><p>Adobe Acrobat Pro DC 2022 是一款专门用于PDF阅读以及编辑的办公辅助软件。它将全球最佳的PDF解决方案提升到新的高度，配有直观触控式界面，通过开发强大的新功能，为用户工作带来许多的便利。</p><h4><strong>一、准备工作</strong>​</h4><ol><li><strong>获取安装包</strong>：<strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=J9%2Bbso6FsQcD1s1QxVq9fg%3D%3D.SmmJke7uwmrZacVNeuJlwkk3MuZtHsl2ze4EHbyPFc%2F24XAJS%2BrGdxyVQk6j55Dx" rel="nofollow" title="https://pan.quark.cn/s/0cca2634fe5c" target="_blank">https://pan.quark.cn/s/0cca2634fe5c</a></li></ol><h4><strong>二、安装步骤</strong>​</h4><ol><li><p><strong>解压安装包</strong>：</p><p>找到下载的安装包文件，右键点击它，选择【解压到当前文件夹】（建议解压至非系统盘，如D盘，避免占用C盘空间）。</p></li><li><p><strong>进入解压目录</strong>：</p><p>解压完成后，双击打开生成的文件夹（通常命名为“Acrobat2022”或类似），找到安装程序文件（一般为 <code>setup.exe</code>或 <code>Acrobat2022_Setup.exe</code>，图标多为蓝色/红色Adobe标识），双击运行。</p></li><li><p><strong>选择安装模式</strong>：</p><p>弹出安装向导后，选择【自定义安装】（部分版本显示为“自定义”，可灵活调整安装路径和功能，比“快速安装”更可控），点击【下一步】。</p></li><li><p><strong>修改安装路径</strong>（关键步骤）：</p><ul><li>点击【更改】按钮（或“浏览”），自定义安装位置（避免默认C盘，建议手动选择路径）；</li><li>示例：打开D盘，新建文件夹并命名为“Acrobat2022”（路径建议简洁，如 <code>D:\Program Files\Adobe\Acrobat2022</code>或直接 <code>D:\Acrobat2022</code>，避免中文/特殊符号）；</li><li>选中新建的文件夹后，点击【确定】返回安装界面。</li></ul></li><li><p><strong>开始安装</strong>：</p><p>确认安装路径无误后，点击【安装】按钮，等待进度条完成（期间请勿关闭安装窗口，耗时约3-10分钟，取决于电脑性能）。</p></li><li><p><strong>完成基础安装</strong>：</p><p>进度条满格后，点击【完成】（此时软件主体已安装至指定路径，但可能需进一步激活或启动）。</p></li><li><p><strong>启动软件</strong>：</p><p>若安装界面提示“立即启动”，点击该按钮直接打开Acrobat 2022；若未提示，可通过桌面快捷方式（安装时若勾选“创建桌面快捷方式”会自动生成）或开始菜单找到软件图标，双击启动。</p></li></ol><h4><strong>三、安装完成</strong>​</h4><p>至此，Acrobat 2022已成功安装并可正常使用。首次启动可能需要登录Adobe账号或完成简单初始化设置（根据版本不同略有差异），按提示操作即可。</p><p>​</p>]]></description></item><item>    <title><![CDATA[嵌入式安全和加密技术 良许 ]]></title>    <link>https://segmentfault.com/a/1190000047609002</link>    <guid>https://segmentfault.com/a/1190000047609002</guid>    <pubDate>2026-02-13 11:08:31</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大家好，我是良许。</p><p>最近几年，随着物联网设备的爆发式增长，嵌入式系统的安全问题越来越受到重视。</p><p>我记得几年前做汽车电子项目的时候，客户对安全的要求还比较宽松，但现在不一样了，几乎每个项目都会被问到"你们的加密方案是什么？</p><p>""如何防止固件被破解？"这些问题。</p><p>今天就和大家聊聊嵌入式安全和加密技术这个话题。</p><h2>1. 为什么嵌入式系统需要安全保护</h2><h3>1.1 嵌入式系统面临的安全威胁</h3><p>嵌入式设备不像服务器那样有专人维护，它们往往部署在各种环境中，面临的威胁也更加多样化。</p><p>我在做汽车电子的时候就遇到过这样的案例：有黑客通过 CAN 总线注入恶意指令，导致车辆的某些功能异常。</p><p>这还只是冰山一角，实际上嵌入式系统面临的威胁包括：</p><p><strong>物理攻击</strong>：攻击者可以直接接触到设备，通过 JTAG、UART 等调试接口读取内存数据，甚至可以用显微镜观察芯片内部结构进行侧信道攻击。</p><p>我见过有人用热风枪把 Flash 芯片拆下来，直接用编程器读取固件。</p><p><strong>网络攻击</strong>：现在的嵌入式设备大多联网，黑客可以通过网络漏洞入侵设备。</p><p>比如很多智能家居设备使用弱密码或者默认密码，很容易被攻破。</p><p><strong>固件逆向</strong>：攻击者获取固件后，可以通过反汇编、反编译等手段分析代码逻辑，找出加密算法和密钥，甚至可以修改固件植入后门。</p><p><strong>供应链攻击</strong>：在生产、运输、维护等环节，设备可能被植入恶意代码或硬件木马。</p><h3>1.2 安全防护的必要性</h3><p>对于我们做嵌入式开发的来说，安全不再是可选项，而是必选项。</p><p>特别是在汽车、医疗、工控等关键领域，一旦出现安全问题，后果不堪设想。</p><p>我之前在外企做项目的时候，有一次因为安全测试没通过，整个项目延期了三个月,损失了上百万。</p><p>所以现在我做项目，都会在设计阶段就把安全考虑进去，而不是等到最后才想起来打补丁。</p><h2>2. 嵌入式加密技术基础</h2><h3>2.1 对称加密算法</h3><p>对称加密是最常用的加密方式，加密和解密使用同一个密钥。</p><p>在嵌入式系统中，AES（高级加密标准）是最流行的对称加密算法。</p><p><strong>AES 加密原理</strong>：AES 支持 128 位、192 位、256 位三种密钥长度，加密过程包括字节替换、行移位、列混淆、轮密钥加等步骤。</p><p>对于嵌入式系统来说，AES-128 通常就足够了，因为它在安全性和性能之间取得了很好的平衡。</p><p>下面是一个使用 STM32 的硬件 AES 加密的示例代码：</p><pre><code>#include "stm32f4xx_hal.h"
​
CRYP_HandleTypeDef hcryp;
​
// 初始化AES硬件加密模块
void AES_Init(void)
{
    __HAL_RCC_CRYP_CLK_ENABLE();
    
    hcryp.Instance = CRYP;
    hcryp.Init.DataType = CRYP_DATATYPE_8B;
    hcryp.Init.KeySize = CRYP_KEYSIZE_128B;
    hcryp.Init.Algorithm = CRYP_AES_ECB;
    
    if (HAL_CRYP_Init(&amp;hcryp) != HAL_OK)
    {
        Error_Handler();
    }
}
​
// AES加密函数
HAL_StatusTypeDef AES_Encrypt(uint8_t *plaintext, uint8_t *key, 
                               uint8_t *ciphertext, uint16_t length)
{
    HAL_StatusTypeDef status;
    
    // 设置密钥
    hcryp.Init.pKey = (uint32_t *)key;
    
    if (HAL_CRYP_Init(&amp;hcryp) != HAL_OK)
    {
        return HAL_ERROR;
    }
    
    // 执行加密
    status = HAL_CRYP_Encrypt(&amp;hcryp, (uint32_t *)plaintext, 
                              length/4, (uint32_t *)ciphertext, 1000);
    
    return status;
}
​
// AES解密函数
HAL_StatusTypeDef AES_Decrypt(uint8_t *ciphertext, uint8_t *key, 
                               uint8_t *plaintext, uint16_t length)
{
    HAL_StatusTypeDef status;
    
    hcryp.Init.pKey = (uint32_t *)key;
    
    if (HAL_CRYP_Init(&amp;hcryp) != HAL_OK)
    {
        return HAL_ERROR;
    }
    
    status = HAL_CRYP_Decrypt(&amp;hcryp, (uint32_t *)ciphertext, 
                              length/4, (uint32_t *)plaintext, 1000);
    
    return status;
}</code></pre><p>这段代码展示了如何使用 STM32 的硬件加密模块进行 AES 加密和解密。</p><p>使用硬件加密的好处是速度快、功耗低，而且密钥不会暴露在软件中，安全性更高。</p><p>我在实际项目中，只要芯片支持硬件加密，都会优先使用。</p><h3>2.2 非对称加密算法</h3><p>非对称加密使用一对密钥：公钥和私钥。</p><p>公钥用于加密，私钥用于解密。</p><p>最常用的非对称加密算法是 RSA 和 ECC（椭圆曲线加密）。</p><p><strong>RSA vs ECC</strong>：在嵌入式系统中，我更倾向于使用 ECC 而不是 RSA，原因很简单：ECC 在相同安全强度下，密钥长度更短，计算速度更快，占用的存储空间也更小。</p><p>比如 256 位的 ECC 密钥，安全强度相当于 3072 位的 RSA 密钥。</p><p>下面是一个使用 mbedTLS 库进行 ECC 签名验证的示例：</p><pre><code>#include "mbedtls/ecdsa.h"
#include "mbedtls/entropy.h"
#include "mbedtls/ctr_drbg.h"
​
// ECC签名验证函数
int verify_firmware_signature(uint8_t *firmware, size_t fw_len, 
                               uint8_t *signature, size_t sig_len)
{
    int ret;
    mbedtls_ecdsa_context ctx;
    mbedtls_entropy_context entropy;
    mbedtls_ctr_drbg_context ctr_drbg;
    uint8_t hash[32];
    
    // 初始化
    mbedtls_ecdsa_init(&amp;ctx);
    mbedtls_entropy_init(&amp;entropy);
    mbedtls_ctr_drbg_init(&amp;ctr_drbg);
    
    // 计算固件的SHA256哈希
    mbedtls_sha256(firmware, fw_len, hash, 0);
    
    // 加载公钥（这里假设公钥已经存储在设备中）
    // 实际项目中，公钥通常烧录在OTP区域或者安全存储区
    ret = load_public_key(&amp;ctx);
    if (ret != 0)
    {
        goto cleanup;
    }
    
    // 验证签名
    ret = mbedtls_ecdsa_read_signature(&amp;ctx, hash, sizeof(hash),
                                       signature, sig_len);
    
cleanup:
    mbedtls_ecdsa_free(&amp;ctx);
    mbedtls_entropy_free(&amp;entropy);
    mbedtls_ctr_drbg_free(&amp;ctr_drbg);
    
    return ret;
}</code></pre><p>这个函数用于验证固件的数字签名，确保固件没有被篡改。</p><p>在实际项目中，我会在 Bootloader 阶段就进行签名验证，只有验证通过的固件才允许运行。</p><h3>2.3 哈希算法</h3><p>哈希算法用于生成数据的"指纹"，常用的有 SHA-256、SHA-3 等。</p><p>哈希算法有两个重要特性：单向性（不可逆）和抗碰撞性（很难找到两个不同的输入产生相同的输出）。</p><p>在嵌入式系统中，哈希算法主要用于：</p><ul><li>固件完整性校验</li><li>密码存储（存储密码的哈希值而不是明文）</li><li>数字签名（先对数据进行哈希，再对哈希值签名）</li></ul><pre><code>#include "mbedtls/sha256.h"
​
// 计算固件的SHA256哈希值
void calculate_firmware_hash(uint8_t *firmware, size_t length, 
                              uint8_t *hash_output)
{
    mbedtls_sha256_context ctx;
    
    mbedtls_sha256_init(&amp;ctx);
    mbedtls_sha256_starts(&amp;ctx, 0); // 0表示SHA-256
    mbedtls_sha256_update(&amp;ctx, firmware, length);
    mbedtls_sha256_finish(&amp;ctx, hash_output);
    mbedtls_sha256_free(&amp;ctx);
}
​
// 验证固件完整性
int verify_firmware_integrity(uint8_t *firmware, size_t length, 
                               uint8_t *expected_hash)
{
    uint8_t calculated_hash[32];
    
    calculate_firmware_hash(firmware, length, calculated_hash);
    
    // 比较计算出的哈希值和预期的哈希值
    if (memcmp(calculated_hash, expected_hash, 32) == 0)
    {
        return 0; // 验证通过
    }
    else
    {
        return -1; // 验证失败
    }
}</code></pre><h2>3. 密钥管理</h2><h3>3.1 密钥存储</h3><p>密钥的安全存储是整个加密系统的基础。</p><p>如果密钥泄露，再强的加密算法也没用。</p><p>在嵌入式系统中，密钥存储有几种方案：</p><p><strong>硬编码在代码中</strong>：这是最不安全的方式，但我见过很多项目都这么做。</p><p>攻击者只要反编译固件，就能轻松找到密钥。</p><p>千万不要这样做！</p><p><strong>存储在 Flash 中</strong>：比硬编码稍好一点，但 Flash 的内容可以被读取出来。</p><p>如果一定要存在 Flash 中，至少要对密钥进行加密存储，使用一个主密钥来加密其他密钥。</p><p><strong>存储在 OTP 区域</strong>：OTP（One-Time Programmable）区域只能写入一次，写入后无法修改，而且通常有读保护功能。</p><p>这是比较安全的方式，我在项目中经常使用。</p><p><strong>使用安全芯片</strong>：最安全的方式是使用专门的安全芯片（如 TPM、SE 等）来存储密钥。</p><p>这些芯片有防篡改机制，即使攻击者物理接触到芯片，也很难提取出密钥。</p><h3>3.2 密钥派生</h3><p>在实际应用中，我们通常不会直接使用原始密钥，而是通过密钥派生函数（KDF）从主密钥派生出多个子密钥。</p><p>这样做的好处是：</p><ul><li>不同的功能使用不同的密钥，即使一个密钥泄露，其他功能仍然安全</li><li>可以定期更换子密钥，而不需要更换主密钥</li></ul><pre><code>#include "mbedtls/hkdf.h"
​
// 使用HKDF派生密钥
int derive_key(uint8_t *master_key, size_t master_key_len,
               uint8_t *info, size_t info_len,
               uint8_t *derived_key, size_t derived_key_len)
{
    const mbedtls_md_info_t *md_info;
    
    md_info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
    
    return mbedtls_hkdf(md_info, NULL, 0, 
                        master_key, master_key_len,
                        info, info_len,
                        derived_key, derived_key_len);
}
​
// 示例：派生不同用途的密钥
void generate_session_keys(uint8_t *master_key)
{
    uint8_t encryption_key[16];
    uint8_t authentication_key[32];
    
    // 派生加密密钥
    derive_key(master_key, 32, 
               (uint8_t *)"encryption", 10,
               encryption_key, 16);
    
    // 派生认证密钥
    derive_key(master_key, 32,
               (uint8_t *)"authentication", 14,
               authentication_key, 32);
}</code></pre><h2>4. 安全启动（Secure Boot）</h2><h3>4.1 安全启动的原理</h3><p>安全启动是嵌入式系统安全的第一道防线。</p><p>它的核心思想是：在系统启动的每个阶段，都验证下一阶段代码的完整性和真实性，形成一条信任链。</p><p><strong>信任链的建立</strong>：</p><ol><li>芯片厂商在芯片出厂时，会在 ROM 中烧录一段不可修改的启动代码（Boot ROM），这是信任的根（Root of Trust）</li><li>Boot ROM 验证 Bootloader 的签名，确保 Bootloader 没有被篡改</li><li>Bootloader 验证应用程序的签名，确保应用程序是可信的</li><li>只有验证通过，系统才会继续启动，否则进入安全模式或者拒绝启动</li></ol><h3>4.2 实现安全启动</h3><p>下面是一个简化的安全启动流程示例：</p><pre><code>#define APP_START_ADDR    0x08010000
#define APP_SIZE          0x00070000
#define SIGNATURE_ADDR    0x08080000
​
typedef void (*app_func_t)(void);
​
// 安全启动主函数
void secure_boot(void)
{
    uint8_t *app_code = (uint8_t *)APP_START_ADDR;
    uint8_t *signature = (uint8_t *)SIGNATURE_ADDR;
    int ret;
    
    // 1. 验证应用程序签名
    ret = verify_firmware_signature(app_code, APP_SIZE, 
                                     signature, 64);
    
    if (ret != 0)
    {
        // 签名验证失败，进入安全模式
        enter_safe_mode();
        return;
    }
    
    // 2. 验证应用程序哈希值
    uint8_t expected_hash[32];
    uint8_t calculated_hash[32];
    
    // 从安全存储区读取预期的哈希值
    read_expected_hash(expected_hash);
    calculate_firmware_hash(app_code, APP_SIZE, calculated_hash);
    
    if (memcmp(expected_hash, calculated_hash, 32) != 0)
    {
        // 哈希验证失败
        enter_safe_mode();
        return;
    }
    
    // 3. 验证通过，跳转到应用程序
    app_func_t app = (app_func_t)(*(uint32_t *)(APP_START_ADDR + 4));
    
    // 设置应用程序的栈指针
    __set_MSP(*(uint32_t *)APP_START_ADDR);
    
    // 跳转到应用程序
    app();
}
​
// 安全模式处理
void enter_safe_mode(void)
{
    // 记录错误日志
    log_security_error();
    
    // 可以尝试恢复出厂固件
    // 或者等待通过安全通道更新固件
    
    while(1)
    {
        // 闪烁LED指示错误
        HAL_GPIO_TogglePin(ERROR_LED_GPIO_Port, ERROR_LED_Pin);
        HAL_Delay(500);
    }
}</code></pre><h2>5. 通信安全</h2><h3>5.1 TLS/DTLS 协议</h3><p>对于需要网络通信的嵌入式设备，使用 TLS（传输层安全）或 DTLS（数据报传输层安全）协议是必须的。</p><p>TLS 用于 TCP 连接，DTLS 用于 UDP 连接。</p><p>在嵌入式 Linux 系统中，我通常使用 mbedTLS 库来实现 TLS 通信。</p><p>下面是一个简单的 TLS 客户端示例：</p><pre><code>#include "mbedtls/net_sockets.h"
#include "mbedtls/ssl.h"
#include "mbedtls/entropy.h"
#include "mbedtls/ctr_drbg.h"
​
int tls_client_connect(const char *server_addr, const char *server_port)
{
    int ret;
    mbedtls_net_context server_fd;
    mbedtls_ssl_context ssl;
    mbedtls_ssl_config conf;
    mbedtls_entropy_context entropy;
    mbedtls_ctr_drbg_context ctr_drbg;
    
    // 初始化
    mbedtls_net_init(&amp;server_fd);
    mbedtls_ssl_init(&amp;ssl);
    mbedtls_ssl_config_init(&amp;conf);
    mbedtls_entropy_init(&amp;entropy);
    mbedtls_ctr_drbg_init(&amp;ctr_drbg);
    
    // 初始化随机数生成器
    ret = mbedtls_ctr_drbg_seed(&amp;ctr_drbg, mbedtls_entropy_func, 
                                 &amp;entropy, NULL, 0);
    if (ret != 0)
    {
        return -1;
    }
    
    // 连接到服务器
    ret = mbedtls_net_connect(&amp;server_fd, server_addr, 
                              server_port, MBEDTLS_NET_PROTO_TCP);
    if (ret != 0)
    {
        return -1;
    }
    
    // 设置SSL配置
    mbedtls_ssl_config_defaults(&amp;conf, MBEDTLS_SSL_IS_CLIENT,
                                MBEDTLS_SSL_TRANSPORT_STREAM,
                                MBEDTLS_SSL_PRESET_DEFAULT);
    
    mbedtls_ssl_conf_rng(&amp;conf, mbedtls_ctr_drbg_random, &amp;ctr_drbg);
    
    // 设置SSL上下文
    mbedtls_ssl_setup(&amp;ssl, &amp;conf);
    mbedtls_ssl_set_bio(&amp;ssl, &amp;server_fd, mbedtls_net_send,
                        mbedtls_net_recv, NULL);
    
    // 执行SSL握手
    while ((ret = mbedtls_ssl_handshake(&amp;ssl)) != 0)
    {
        if (ret != MBEDTLS_ERR_SSL_WANT_READ &amp;&amp; 
            ret != MBEDTLS_ERR_SSL_WANT_WRITE)
        {
            return -1;
        }
    }
    
    // 握手成功，可以开始安全通信
    return 0;
}</code></pre><h3>5.2 消息认证码（MAC）</h3><p>对于一些资源受限的设备，可能无法使用完整的 TLS 协议。</p><p>这时候可以使用消息认证码（MAC）来保证消息的完整性和真实性。</p><p>常用的 MAC 算法有 HMAC（基于哈希的消息认证码）。</p><pre><code>#include "mbedtls/md.h"
​
// 计算HMAC
int calculate_hmac(uint8_t *key, size_t key_len,
                   uint8_t *message, size_t msg_len,
                   uint8_t *mac_output)
{
    const mbedtls_md_info_t *md_info;
    
    md_info = mbedtls_md_info_from_type(MBEDTLS_MD_SHA256);
    
    return mbedtls_md_hmac(md_info, key, key_len, 
                          message, msg_len, mac_output);
}
​
// 验证消息的HMAC
int verify_message_hmac(uint8_t *key, size_t key_len,
                        uint8_t *message, size_t msg_len,
                        uint8_t *received_mac)
{
    uint8_t calculated_mac[32];
    
    calculate_hmac(key, key_len, message, msg_len, calculated_mac);
    
    if (memcmp(calculated_mac, received_mac, 32) == 0)
    {
        return 0; // 验证通过
    }
    else
    {
        return -1; // 验证失败
    }
}</code></pre><h2>6. 防护措施和最佳实践</h2><h3>6.1 代码混淆和加固</h3><p>即使使用了加密技术，如果攻击者能够轻松逆向你的代码，找出加密算法的实现细节，安全性还是会大打折扣。</p><p>因此，代码混淆和加固也很重要。</p><p><strong>代码混淆技术</strong>：</p><ul><li>控制流平坦化：把代码的控制流打乱，让逆向分析变得困难</li><li>虚假控制流：插入永远不会执行的代码分支，干扰静态分析</li><li>字符串加密：把代码中的字符串常量加密，运行时再解密</li></ul><p><strong>防调试技术</strong>：</p><ul><li>检测调试器：通过检测调试寄存器、时间差异等方式判断是否在调试状态</li><li>反 JTAG：禁用或加密 JTAG 接口</li><li>读保护：启用芯片的读保护功能，防止通过调试接口读取 Flash 内容</li></ul><h3>6.2 安全更新机制</h3><p>再安全的系统也可能存在漏洞，因此需要有安全的固件更新机制。</p><p>我在项目中实现 OTA（Over-The-Air）更新时，会遵循以下原则：</p><p><strong>双区更新</strong>：Flash 分为两个区域，一个运行区，一个备份区。</p><p>更新时先把新固件写入备份区，验证通过后再切换。</p><p>这样即使更新失败，也能回退到旧版本。</p><p><strong>增量更新</strong>：对于大型固件，可以只传输变化的部分，减少传输时间和流量消耗。</p><p><strong>安全通道</strong>：固件传输必须使用加密通道，防止中间人攻击。</p><p><strong>签名验证</strong>：新固件必须经过签名验证，确保来自可信的源。</p><pre><code>// OTA更新流程
int ota_update(uint8_t *new_firmware, size_t fw_size, 
               uint8_t *signature)
{
    // 1. 验证签名
    if (verify_firmware_signature(new_firmware, fw_size, 
                                   signature, 64) != 0)
    {
        return -1; // 签名验证失败
    }
    
    // 2. 写入备份区
    if (write_to_backup_area(new_firmware, fw_size) != 0)
    {
        return -2; // 写入失败
    }
    
    // 3. 验证写入的数据
    if (verify_backup_area(new_firmware, fw_size) != 0)
    {
        return -3; // 验证失败
    }
    
    // 4. 设置启动标志，下次启动时切换到新固件
    set_boot_flag(BOOT_FROM_BACKUP);
    
    // 5. 重启系统
    NVIC_SystemReset();
    
    return 0;
}</code></pre><h3>6.3 日志和审计</h3><p>安全事件的记录和审计也很重要。我在项目中会记录以下事件：</p><ul><li>启动失败（签名验证失败、哈希验证失败等）</li><li>非法访问尝试</li><li>固件更新记录</li><li>密钥更换记录</li></ul><p>这些日志可以帮助我们及时发现安全问题，分析攻击手段。</p><p>当然，日志本身也需要保护，防止被篡改。</p><h2>7. 总结</h2><p>嵌入式安全是一个系统工程，需要从硬件、软件、通信等多个层面来考虑。</p><p>我这些年做项目的经验告诉我，安全不是事后补救，而应该在设计阶段就融入到系统中。</p><p>虽然增加安全机制会带来一些额外的开发工作量和成本，但相比于出现安全问题后的损失，这些投入是完全值得的。</p><p>最后给大家几点建议：第一，不要自己发明加密算法，使用经过验证的标准算法。</p><p>第二，密钥管理是重中之重，一定要妥善保护。</p><p>第三，保持学习，安全技术在不断发展，攻击手段也在不断进化，我们需要持续关注最新的安全动态。</p><p>希望这篇文章能够帮助大家更好地理解嵌入式安全和加密技术，在实际项目中应用这些知识，开发出更安全可靠的嵌入式系统。</p><p><strong>更多编程学习资源</strong></p><ul><li><a href="https://link.segmentfault.com/?enc=%2BoaeT2zIyGgvJoDABGH7Kw%3D%3D.455QkA00pTZKSi4VHajvbYfOjDOZkCY9uSlMfG8cISv8LV%2FzGP3dxLLsRwbYgvUQ%2F2hlGn5HJCGOBh190CAGcQ%3D%3D" rel="nofollow" target="_blank">C 语言零基础入门电子书-2026 最新版</a></li><li><a href="https://link.segmentfault.com/?enc=QKPPLTM7psZQHNLsNpe1rQ%3D%3D.GEDkrdHt8cjOv0ugEMahhcSatOfNWA6rgEeHeroCtinL%2FxzrCOt2%2FXPJxtK7PGNhw5FEgqxV1N%2BJZ8yswtH2FQ%3D%3D" rel="nofollow" target="_blank">STM32 零基础入门电子书-2026 最新版</a></li><li><a href="https://link.segmentfault.com/?enc=1Ykzgqx1Pj%2BxgXyQq58Ocg%3D%3D.4745ybzLDzxFJFE%2FM5Rs93ePPRzmbPgmVu5dr%2B1sSXMfI8Hg6R365vqoy1p1oOutoFEF%2FiGEkXOfsjZFuVGVDe0ZfYqBwt6V0eJyJ1lVw1E%3D" rel="nofollow" target="_blank">FreeRTOS 零基础入门电子书-2026 最新版</a></li><li><a href="https://link.segmentfault.com/?enc=O57tCCqWbDzWQMmC0sMKeg%3D%3D.HJfBKxpJIozPRWWicQxDgJok9y%2Fb%2BAdhRlTJwjoN4YDg1LeDVi5Z%2BAN2SJU0xMvoXvGMTATAxt1zUXCIvRW7fQ%3D%3D" rel="nofollow" target="_blank">C++ 零基础入门电子书-2026 最新版</a></li><li><a href="https://link.segmentfault.com/?enc=FuK%2BdT1y9YcknMIeDufMmw%3D%3D.%2BE4y7PozaxndydSIoyQfgOdjjBm3arRpEsYhVVjdoAzx1OVSRVE9z1qmaccUNfdZnFcehgT1nunc2US8Lk23FA%3D%3D" rel="nofollow" target="_blank">51 单片机零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=EuXPM57cn09pKzK5M38qcg%3D%3D.8%2BiWXUbldMaovmQs0EJP1G0Kysnv3t4GZ3SFVZZeKVvXj39RKRMOhPLbf%2F01wMY9ZM2tvff%2Biyz3DGxrX7iXZA%3D%3D" rel="nofollow" target="_blank">AD 画板零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=VHQpcwfRHVwNVGFr9mF%2BJw%3D%3D.Z21wExUbzXZ4UZBxDYCM7%2F3YwMXEswIo3ZQuJzO6mWqAAFmhSf6hLnkNJxhQhqaOTBGyz1mvTi8drR3ZMod1Rw%3D%3D" rel="nofollow" target="_blank">C 语言零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=dkO5n3xvHDJ4JcT5H7ShOw%3D%3D.VhXbLwUSmaUnVR3ZdGaJ2Jamc5XrGT98rXPQqRwdtAmaBNfbAXZRvrCYSJuo1SfDDjPKtcydJGpIhdMjwaqYbg%3D%3D" rel="nofollow" target="_blank">C++ 语言零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=A%2F5P%2B1FrdNgSgrwt%2BoV8Yg%3D%3D.ozUcv17Yk2P45NGsZHMM4Kuii5WLbNx%2FUoH6gOWIIppUlvCZ3%2FsmEfenD59Ead6tH9qJ4SXYYCHB%2BsqR2FPrgXdxGtvC%2F6yMMDZGqn35sO8%3D" rel="nofollow" target="_blank">ESP32 零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=zJ8ive8et7iSa8mynNTAnw%3D%3D.xBOAE2aNc%2F0%2B%2BTUE%2BugEImKscXBNtETAiO63YCkQ%2Fatp%2Fad0COBbXft24RbEe50SpEFIwdAzjHQuJD%2FmakrXz2qWyXZIVBIZiCmsrZ0HgZc%3D" rel="nofollow" target="_blank">FreeRTOS 零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=BN4F8cBz6rlhlCTCPAoMRg%3D%3D.oaYe7xftveyYa6wtONmJl%2BDhfBQ1goppo90GUJHIVKH0t7Et2aGx2xeOygVqotW5YUbtrxX%2FxoNqX%2FGu5xu3n4FEMKcIawTHPhZzZ9CJYZI%3D" rel="nofollow" target="_blank">Linux 应用开发零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=QtDvhrRx91LBSLjt1U3u1g%3D%3D.H8YU99yAdtmSUHTR9H4v%2Ffc64Fr0M%2FkV8aFnSJZfK1XjZpusCwoULXnOQdBtxjuu0Mfx%2B69J5fqeS49VDrt9vhNYSpLHdTl%2FwFkpGmCkDvc%3D" rel="nofollow" target="_blank">Linux 底层开发零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=9kV%2FzrWnUPas8MXFxCoJAA%3D%3D.ltaFDrX46e50WQHOS5U1dShIXzGsNyG16cw5PW%2F3bNWpZJ2FOz4VFic4qi%2FmHJIWEVvSfgaRuYbZbHaXvZArSg%3D%3D" rel="nofollow" target="_blank">LVGL 零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=trBOTP7sKLXq6cioNjx7cQ%3D%3D.cnjxj8I0ya9JdGNMWzhvUBlBGFmKMsOLcutpZcs7Hp4%2FBM5zfZauG85Skp1jQJKYJwvfv8geawUgdwUZwkdESw%3D%3D" rel="nofollow" target="_blank">QT 零基础入门学习路线</a></li><li><a href="https://link.segmentfault.com/?enc=eyr9kRXKOQ7TqmQDPKkkBw%3D%3D.AkVwS1fT5GrhyKmLVU9BP7Goyfu8T7WxF3kvpeX7qC4OCwfa76o0Wd3xKh1lHBwW1QXN0rFSzGzp%2Bf%2Bgz1IL07lF36EvxpzSDBvKGp%2BPyo4%3D" rel="nofollow" target="_blank">STM32 零基础入门学习路线</a></li></ul>]]></description></item><item>    <title><![CDATA[在哪里可以查看 LLM 大模型的 benchmark 排名？ rabbitcoder ]]></title>    <link>https://segmentfault.com/a/1190000047609010</link>    <guid>https://segmentfault.com/a/1190000047609010</guid>    <pubDate>2026-02-13 11:07:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>推荐这个地方：<a href="https://link.segmentfault.com/?enc=moy8gb2rAKYfv8Bly3q54Q%3D%3D.D2sBisZ4aQvAHdXJJmYmoFF255ANmbBrApHpxWDakvR05XS%2BjbmQkpX92Tw9LsTEzNwl5BQVIp%2Fl88q1LhHFwbmqmtRam1k4ospRYaVFA72juT9t%2Bi%2FfYulGLHTubKcd" rel="nofollow" target="_blank">https://artificialanalysis.ai/evaluations/artificial-analysis...</a></p>]]></description></item><item>    <title><![CDATA[『NAS』设置内网固定 IP 德育处主任 ]]></title>    <link>https://segmentfault.com/a/1190000047609014</link>    <guid>https://segmentfault.com/a/1190000047609014</guid>    <pubDate>2026-02-13 11:07:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p><blockquote>整理了一个NAS小专栏，有兴趣的工友可以关注一下 👉 <a href="https://link.segmentfault.com/?enc=5nQ%2FmhplExzBE6Iogo0zuQ%3D%3D.KbwojU2vNeRk9%2Fnp7aXhphgrpAACiiigTUvYuB5PwP1%2B5JaD7C3t%2BauePoDepYrmqb9A8mji%2Bn%2FFwhTQg0OJx2F5FHtxkqTdoJVyV2JBNfaMFmN%2BsPOKyhRuhJj5WhFi2D7ukkVT9%2BhadFc5QCSe9C29TVyDW%2BoxOMPe5OGmI3c%3D" rel="nofollow" target="_blank">《NAS邪修》</a></blockquote><p>给 NAS 设置静态 IP，核心是解决默认 DHCP 自动分配导致 IP “乱跑” 的问题，相当于给 NAS 在局域网内固定专属 “门牌号”。</p><p>尤其是用 Docker 部署了一堆应用，要是 NAS 的 IP 一变，在 Docker 部署的应用也要跟着变了。</p><p>我手上有群晖、绿联、飞牛这3品牌的 NAS，我分别说说这几个品牌的 NAS 在哪可以设置静态 IP。</p><h2>群晖</h2><p>打开「控制面板」，选择「网络」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609016" alt="" title=""/></p><p>切换到「网络界面」面板，选择当前连接的「局域网」，可以看到现在使用的是 DHCP。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609017" alt="" title="" loading="lazy"/></p><p>点击「编辑」按钮，将“IPv4”这项改为“手动设置网络配置”，输入一个 IP 即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609018" alt="" title="" loading="lazy"/></p><p>保存好之后，回到「网络界面」面板就能看到当前已经将「局域网 1」设置为静态 IP。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609019" alt="" title="" loading="lazy"/></p><h2>绿联</h2><p>打开「控制面板」，选择「网络设置」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609020" alt="" title="" loading="lazy"/></p><p>切换到「网络连接」面板，选择已连接的“LAN”，点击编辑。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609021" alt="" title="" loading="lazy"/></p><p>将「IPv4」改为“手动设置网络配置”，然后填入一个“IPv4地址”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609022" alt="" title="" loading="lazy"/></p><p>设置完，回到「网络连接」面板就能看到刚刚设置的这项多了一个“静态”标识。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609023" alt="" title="" loading="lazy"/></p><h2>飞牛</h2><p>打开「系统设置」，切换到「网络设置」面板，点击当前正在使用的「网口」的右侧的3个点，然后点击“编辑”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609024" alt="" title="" loading="lazy"/></p><p>在编辑面板，将「IPv4」这边改为“手动设置”，然后输入一个「IPv4」地址即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609025" alt="" title="" loading="lazy"/></p><p>回到「网络设置」面板就能看到“IP 获取方式”这项从原本的“DHCP”变成“手动”了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609026" alt="" title="" loading="lazy"/></p><hr/><p>以上就是本文的全部内容啦，<strong>有疑问可以在评论区讨论～</strong></p><p><strong>想了解更多NAS玩法可以关注<a href="https://link.segmentfault.com/?enc=szw6mHDu2CB3JzWRN8I4NQ%3D%3D.QJKv24RROFFyz1jhWf6F1VniDpBEgA37C2jVVywKobVkWWxEvpwVVVMxS324XpbT%2FylQD2qs1pUQDIyjARzWcS1SD74ArAq2xY0xLyu8q%2FkPnTIsHgbI%2B2f8uIgWxJ2REWabd9ufw8OAGu8er0Q9ul6K%2Bcjf9QSEhVhdTr6GILA%3D" rel="nofollow" target="_blank">《NAS邪修》👏</a></strong></p><p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p>]]></description></item><item>    <title><![CDATA[百度文心快码全面支持GLM-5 文心快码 ]]></title>    <link>https://segmentfault.com/a/1190000047609068</link>    <guid>https://segmentfault.com/a/1190000047609068</guid>    <pubDate>2026-02-13 11:06:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>百度文心快码今天全面支持GLM-5。作为面向复杂系统工程优化的新一代模型，GLM-5进一步强化了Coding Agent在真实研发场景中的持续执行能力。  </p><p>基于GLM-5在推理能力、代码理解与任务规划方面的显著提升，文心快码在跨文件分析、问题修复、多步骤开发等复杂工程场景中实现了更高质量的任务执行，在开发过程中更高效完成从需求理解、任务拆解到结果交付的工程闭环，帮助开发者提升复杂任务处理效率与质量。  </p><p>目前，Comate已在IDE及插件端全面集成GLM-5，深度赋能开发全流程。  </p><p>诚邀大家即刻体验，反馈使用感受！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609070" alt="" title=""/><a href="" target="_blank"/></p>]]></description></item><item>    <title><![CDATA[广域铭岛构建全链路智能制造新引擎 雨大王 ]]></title>    <link>https://segmentfault.com/a/1190000047609073</link>    <guid>https://segmentfault.com/a/1190000047609073</guid>    <pubDate>2026-02-13 11:05:12</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>汽车产业链的智能化，从来不是一台机器人换掉一个工人那么简单。它是一场涉及成千上万中小企业、数以万计工艺节点、跨地域协同的系统性重构。过去，很多供应商明明知道数字化能降本增效，却因投入大、周期长、看不懂技术而裹足不前。真正的问题，不是不愿转，而是不知道怎么转，转了怕白花钱。广域铭岛这些年在西南、华东的汽车集群里摸爬滚打，发现最有效的路径不是卖一套系统，而是把AI能力拆成“小模块”，像乐高一样，让小厂也能搭得起、用得上。他们做的质量视觉检测、能耗动态优化，不是高高在上的实验室成果，而是能直接装在车间里、三天见效的实用工具。这种“轻量化、快部署、见效显”的思路，恰恰击中了中小企业最真实的焦虑。<br/>真正的智能化，不能只停留在某个环节的“点状突破”。一个零件的良率提升了，但如果计划排产还是靠老师傅拍脑袋，仓储还是靠人工对单，那整个链条依然脆弱。广域铭岛提出的“全链路智能体”概念，本质上是在打通研发、生产、供应、交付的断点。他们用Geega OS做底座，把设备数据、工艺经验、质量记录统统结构化，再通过工业大模型生成可执行的决策建议。比如，AI能自动从过去十年的工艺数据里提炼出最优参数，生成SOP文件，工程师只需复核，效率提升近九成。这背后不是算法多炫，而是把老师傅几十年的经验，变成了机器能理解、能迭代的知识资产。这种“数据-知识-模型”的闭环，才是工业AI区别于消费级AI的核心——它不追求通用，只追求可靠。<br/>放眼全球，这条路上的玩家各有路径。德国西门子靠的是PLM与MES的深度集成，用数字孪生把整车制造流程“克隆”进虚拟世界，再做仿真优化，适合体系成熟、标准统一的大型车企。美国通用电气则更侧重设备端的预测性维护，通过Predix平台连接数百万台工业设备，用AI提前预警故障，降低停机损失。但这两者都依赖强大的IT基础和高昂的定制成本，对中小供应商而言门槛太高。相比之下，广域铭岛的打法更“接地气”——它不追求大而全，而是从供应链最薄弱的环节切入，用模块化智能体快速响应不同规模企业的实际需求。在成都领克、衢州极电的工厂里，这套方案已帮助多家企业拿下国家级CMMM4认证，证明了“中国式智能”在复杂供应链中的可行性。当重庆的多模态大模型专项联合长安、邮电大学共同推进时，我们看到的不只是技术突破，更是一个本土化生态正在成型：高校提供算法，企业贡献场景，政府搭建平台，最终让AI真正扎根于制造的土壤。<br/>汽车产业链的智能化，不是一场技术秀，而是一次生产关系的重塑。它需要的不是炫技的AI，而是能听懂车间方言、懂工人苦衷、能帮小厂活下去的“工业伙伴”。广域铭岛的探索，正在为全球制造业提供一种新的可能——智能化，不必从零开始，也可以从“小处着手，步步为营”。</p>]]></description></item><item>    <title><![CDATA[鸿蒙如何实现数据持久化存储 江南一点雨 ]]></title>    <link>https://segmentfault.com/a/1190000047609078</link>    <guid>https://segmentfault.com/a/1190000047609078</guid>    <pubDate>2026-02-13 11:04:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在鸿蒙应用开发中，数据持久化存储是保障应用体验的核心能力——无论是用户偏好设置（如主题、字体大小）、离线业务数据（如缓存的新闻、本地日志），还是核心业务记录（如记账数据、任务清单），都需要通过持久化技术保存到设备本地，避免应用退出、设备重启后数据丢失。与传统Android、iOS的持久化方案不同，鸿蒙（HarmonyOS）基于分布式架构设计，提供了一套统一、轻量、高效的持久化存储API，覆盖不同数据场景，同时兼顾单机存储的稳定性与跨设备协同的扩展性。本文将从问题背景、实操案例、最佳实践三方面，全面解析鸿蒙数据持久化存储的实现逻辑与落地方法，助力开发者快速掌握核心技巧。</p><h2>一、问题背景：应用开发中数据持久化的核心需求与痛点</h2><p>任何具备实用价值的应用，都离不开数据持久化——没有持久化，应用每次启动都将回归初始状态，用户操作记录、个性化配置全部丢失，无法形成完整的使用闭环。结合鸿蒙应用的开发场景，数据持久化面临的需求与传统痛点主要体现在以下三方面：</p><h3>1.1 核心需求场景</h3><p>鸿蒙应用的持久化需求，可分为三大类，覆盖绝大多数开发场景：</p><ul><li>轻量级配置存储：存储应用偏好设置，如主题模式（浅色/深色）、字体大小、登录状态、默认参数等，数据量小、结构简单，需快速读写。</li><li>结构化数据存储：存储具有固定格式的业务数据，如任务清单（包含标题、时间、状态）、用户收藏（包含ID、名称、链接），需支持条件查询、修改、删除。</li><li>大文件/二进制数据存储：存储图片、音频、视频、离线数据包等二进制文件，需兼顾存储效率与读取性能，避免占用过多设备资源。</li></ul><h3>1.2 传统持久化方案的痛点</h3><p>在鸿蒙出现之前，不同系统的持久化方案差异较大（如Android的SharedPreferences、SQLite，iOS的UserDefaults、Core Data），开发者跨平台开发时需重复适配，且存在明显短板，即使是单一系统内，也有诸多不便：</p><ul><li>接口分散，学习成本高：不同数据类型需使用不同的API，如轻量级配置用SharedPreferences，结构化数据用SQLite，大文件用File，开发者需熟练掌握多种方案的使用方法与注意事项。</li><li>性能优化复杂：SQLite需手动管理数据库连接、优化查询语句，否则易出现卡顿；大文件存储若未做分片、缓存策略，会导致读写速度慢、设备功耗升高。</li><li>分布式适配困难：传统持久化方案仅针对单机存储设计，无法直接支持鸿蒙的跨设备协同场景，若需实现多设备数据同步，需开发者自行搭建同步逻辑，开发成本极高。</li><li>安全性不足：原生方案对敏感数据（如用户密码、隐私信息）缺乏内置加密支持，需开发者自行实现加密逻辑，易出现数据泄露风险。</li></ul><p>针对以上痛点，鸿蒙操作系统整合了多种持久化能力，提供了Preferences、RelationalStore、FileStorage三大核心存储组件，统一API设计，兼顾轻量性、高性能与安全性，同时支持分布式扩展，让开发者无需关注底层实现，即可快速完成数据持久化开发。</p><h2>二、具体案例：鸿蒙应用本地日志存储的对接步骤</h2><p>本地日志存储是应用开发中的常见场景——应用运行过程中，需记录错误信息、用户操作日志、系统状态日志，用于问题排查与版本优化。本案例基于鸿蒙4.0+、ArkTS（声明式开发范式），结合Preferences（存储日志配置）、RelationalStore（存储结构化日志数据）、FileStorage（存储大体积日志文件）三种组件，实现一套完整的本地日志持久化方案，适配轻量配置、结构化数据、大文件的全场景需求，完整对接步骤如下：</p><h3>2.1 环境准备与基础配置</h3><p>首先完成开发环境搭建与应用基础配置，确保支持鸿蒙持久化组件的使用：</p><ol><li>开发环境：安装DevEco Studio 4.0+，配置HarmonyOS 4.0+ SDK，启用ArkTS声明式开发模式（新建项目时选择“Application”，模板选择“Empty Ability (ArkTS)”）。</li><li>权限配置：日志存储需访问设备本地存储，需在应用配置文件<code>module.json5</code>中添加本地存储权限，明确权限申请原因：</li></ol><pre><code class="json5">// module.json5
{
  "module": {
    // 其他配置...
    "requestPermissions": [
      {
        "name": "ohos.permission.WRITE_USER_STORAGE", // 写入本地存储权限
        "reason": "用于存储应用运行日志，便于问题排查",
        "usedScene": {
          "ability": ["com.example.logstorage.MainAbility"],
          "when": "always"
        }
      },
      {
        "name": "ohos.permission.READ_USER_STORAGE", // 读取本地存储权限
        "reason": "用于读取本地日志文件，支持日志查看功能",
        "usedScene": {
          "ability": ["com.example.logstorage.MainAbility"],
          "when": "always"
        }
      }
    ]
  }
}</code></pre><ol start="3"><li>依赖导入：鸿蒙持久化组件（Preferences、RelationalStore）已内置在SDK中，无需额外导入第三方依赖，直接在代码中引入对应模块即可。</li></ol><h3>2.2 需求拆解与组件选型</h3><p>本案例的日志持久化需求分为三部分，对应三种鸿蒙持久化组件，选型如下：</p><ul><li>日志配置存储（轻量级）：存储日志级别（DEBUG/INFO/ERROR）、日志保留天数、是否开启日志存储，使用Preferences组件（键值对存储，轻量高效）。</li><li>结构化日志存储：存储单条日志详情（日志ID、日志级别、日志内容、打印时间、进程ID），使用RelationalStore组件（关系型数据库，支持条件查询、分页）。</li><li>大体积日志文件存储：当单条日志超过1KB（如详细的错误堆栈），或日志累计量较大时，导出为日志文件（.log）存储，使用FileStorage组件（文件存储，适配大体积数据）。</li></ul><h3>2.3 第一步：Preferences实现日志配置持久化</h3><p>Preferences适用于轻量级键值对存储，无需创建表结构，直接通过“键-值”形式读写数据，步骤如下：</p><ol><li>创建Preferences管理工具类，封装初始化、读写、清除方法，避免代码冗余：</li></ol><pre><code class="typescript">// utils/PreferenceManager.ets
import preferences from '@ohos.data.preferences';

// 定义日志配置的键名（统一管理，避免拼写错误）
export enum LogConfigKey {
  LOG_LEVEL = 'log_level', // 日志级别：debug/info/error
  LOG_RETENTION_DAYS = 'log_retention_days', // 日志保留天数
  ENABLE_LOG_STORAGE = 'enable_log_storage' // 是否开启日志存储
}

// Preferences实例（全局单例，避免重复初始化）
let prefInstance: preferences.Preferences | null = null;

/**
 * 初始化Preferences（应用启动时调用）
 * @param context 应用上下文
 */
export async function initPreferences(context: Context): Promise&lt;void&gt; {
  if (prefInstance) return;
  // 获取Preferences实例（参数：上下文、存储文件名）
  prefInstance = await preferences.getPreferences(context, 'log_config');
  // 设置默认配置（若首次启动，无配置时生效）
  await setDefaultLogConfig();
}

/**
 * 设置日志配置默认值
 */
async function setDefaultLogConfig(): Promise&lt;void&gt; {
  if (!prefInstance) return;
  // 若未设置日志级别，默认值为info
  if (!await prefInstance.hasKey(LogConfigKey.LOG_LEVEL)) {
    await prefInstance.putString(LogConfigKey.LOG_LEVEL, 'info');
  }
  // 若未设置保留天数，默认保留7天
  if (!await prefInstance.hasKey(LogConfigKey.LOG_RETENTION_DAYS)) {
    await prefInstance.putNumber(LogConfigKey.LOG_RETENTION_DAYS, 7);
  }
  // 若未设置是否开启存储，默认开启
  if (!await prefInstance.hasKey(LogConfigKey.ENABLE_LOG_STORAGE)) {
    await prefInstance.putBoolean(LogConfigKey.ENABLE_LOG_STORAGE, true);
  }
  // 提交修改（Preferences需手动提交，否则不生效）
  await prefInstance.flush();
}

/**
 * 读取日志配置（通用方法，支持不同类型的值）
 */
export async function getLogConfig&lt;T&gt;(key: LogConfigKey): Promise&lt;T | undefined&gt; {
  if (!prefInstance) return undefined;
  const type = typeof (await prefInstance.get(key, ''));
  switch (type) {
    case 'string':
      return (await prefInstance.getString(key)) as T;
    case 'number':
      return (await prefInstance.getNumber(key)) as T;
    case 'boolean':
      return (await prefInstance.getBoolean(key)) as T;
    default:
      return undefined;
  }
}

/**
 * 修改日志配置
 */
export async function setLogConfig&lt;T&gt;(key: LogConfigKey, value: T): Promise&lt;void&gt; {
  if (!prefInstance) return;
  // 根据值的类型，调用对应的put方法
  if (typeof value === 'string') {
    await prefInstance.putString(key, value as string);
  } else if (typeof value === 'number') {
    await prefInstance.putNumber(key, value as number);
  } else if (typeof value === 'boolean') {
    await prefInstance.putBoolean(key, value as boolean);
  }
  // 提交修改
  await prefInstance.flush();
}</code></pre><ol start="2"><li>在应用入口初始化Preferences，确保配置可正常读写：</li></ol><pre><code class="typescript">// entryability/MainAbility.ets
import Ability from '@ohos.application.Ability';
import { initPreferences } from '../utils/PreferenceManager';

export default class MainAbility extends Ability {
  async onCreate(want, launchParam) {
    super.onCreate(want, launchParam);
    // 初始化Preferences（传入应用上下文）
    await initPreferences(this.context);
    // 其他初始化操作...
  }

  // 其他生命周期方法...
}</code></pre><h3>2.4 第二步：RelationalStore实现结构化日志持久化</h3><p>RelationalStore是鸿蒙提供的关系型数据库组件，基于SQLite封装，支持表结构定义、SQL查询、事务操作，适合存储结构化日志数据，步骤如下：</p><ol><li>定义日志数据表结构，创建数据库管理工具类：</li></ol><pre><code class="typescript">// utils/RelationalStoreManager.ets
import relationalStore from '@ohos.data.relationalStore';

// 日志数据表名
const LOG_TABLE_NAME = 'log_records';

// 定义日志数据模型（与表结构对应）
export interface LogModel {
  id: string; // 日志唯一ID（UUID）
  level: string; // 日志级别：debug/info/error
  content: string; // 日志内容
  createTime: number; // 打印时间戳（毫秒）
  processId: number; // 进程ID
}

// RelationalStore数据库实例（全局单例）
let rdbStore: relationalStore.RdbStore | null = null;

/**
 * 初始化RelationalStore数据库
 * @param context 应用上下文
 */
export async function initRelationalStore(context: Context): Promise&lt;void&gt; {
  if (rdbStore) return;
  // 数据库配置
  const storeConfig: relationalStore.StoreConfig = {
    name: 'log_database.db', // 数据库文件名
    securityLevel: relationalStore.SecurityLevel.S1, // 加密存储（保护日志隐私）
    // 单机存储，无需分布式同步（若需跨设备同步，可开启distributed配置）
    distributed: {
      autoSync: false
    }
  };

  // 初始化数据库
  rdbStore = await relationalStore.getRdbStore(context, storeConfig);
  // 创建日志数据表（若不存在）
  await createLogTable();
}

/**
 * 创建日志数据表
 */
async function createLogTable(): Promise&lt;void&gt; {
  if (!rdbStore) return;
  // SQL语句：创建日志表，定义字段类型与主键
  const createTableSql = `
    CREATE TABLE IF NOT EXISTS ${LOG_TABLE_NAME} (
      id TEXT PRIMARY KEY,          -- 日志唯一ID
      level TEXT NOT NULL,         -- 日志级别
      content TEXT NOT NULL,       -- 日志内容
      createTime INTEGER NOT NULL, -- 打印时间戳
      processId INTEGER NOT NULL   -- 进程ID
    );
    -- 为日志级别、时间戳创建索引，优化查询效率
    CREATE INDEX IF NOT EXISTS idx_log_level ON ${LOG_TABLE_NAME}(level);
    CREATE INDEX IF NOT EXISTS idx_create_time ON ${LOG_TABLE_NAME}(createTime);
  `;
  // 执行SQL语句
  await rdbStore.executeSql(createTableSql);
}

/**
 * 插入单条日志数据（核心方法：持久化结构化日志）
 * @param log 日志数据模型
 */
export async function insertLog(log: LogModel): Promise&lt;boolean&gt; {
  if (!rdbStore) return false;
  try {
    // 构造数据容器（ValuesBucket），与表字段对应
    const values = new relationalStore.ValuesBucket();
    values.put('id', log.id);
    values.put('level', log.level);
    values.put('content', log.content);
    values.put('createTime', log.createTime);
    values.put('processId', log.processId);

    // 插入数据（返回插入的行ID，若&gt;0则插入成功）
    const rowId = await rdbStore.insert(LOG_TABLE_NAME, values);
    return rowId &gt; 0;
  } catch (error) {
    console.error('插入日志失败：', error);
    return false;
  }
}

/**
 * 查询日志（支持按级别、时间范围查询）
 * @param level 日志级别（可选）
 * @param startTime 开始时间戳（可选）
 * @param endTime 结束时间戳（可选）
 */
export async function queryLogs(
  level?: string,
  startTime?: number,
  endTime?: number
): Promise&lt;LogModel[]&gt; {
  if (!rdbStore) return [];

  // 构建查询条件（RdbPredicates）
  const predicates = new relationalStore.RdbPredicates(LOG_TABLE_NAME);
  // 按时间戳倒序排列（最新日志在前）
  predicates.orderByDesc('createTime');

  // 拼接查询条件（若传入级别、时间范围，则添加过滤）
  if (level) {
    predicates.equalTo('level', level);
  }
  if (startTime) {
    predicates.greaterThanOrEqualTo('createTime', startTime);
  }
  if (endTime) {
    predicates.lessThanOrEqualTo('createTime', endTime);
  }

  // 执行查询，获取结果集
  const resultSet = await rdbStore.query(predicates);
  const logs: LogModel[] = [];

  // 遍历结果集，转换为LogModel数组
  while (resultSet.goToNextRow()) {
    logs.push({
      id: resultSet.getString(resultSet.getColumnIndex('id')),
      level: resultSet.getString(resultSet.getColumnIndex('level')),
      content: resultSet.getString(resultSet.getColumnIndex('content')),
      createTime: resultSet.getLong(resultSet.getColumnIndex('createTime')),
      processId: resultSet.getLong(resultSet.getColumnIndex('processId'))
    });
  }

  // 关闭结果集（避免资源泄露）
  resultSet.close();
  return logs;
}</code></pre><ol start="2"><li>在应用入口初始化RelationalStore，与Preferences同步初始化：</li></ol><pre><code class="typescript">// entryability/MainAbility.ets
import { initRelationalStore } from '../utils/RelationalStoreManager';

export default class MainAbility extends Ability {
  async onCreate(want, launchParam) {
    super.onCreate(want, launchParam);
    // 初始化Preferences
    await initPreferences(this.context);
    // 初始化RelationalStore
    await initRelationalStore(this.context);
    // 其他初始化操作...
  }
}</code></pre><h3>2.5 第三步：FileStorage实现大体积日志文件持久化</h3><p>当日志内容过大（如错误堆栈、详细调试信息），不适合存储在数据库中时，使用FileStorage组件将日志写入本地文件，步骤如下：</p><ol><li>创建文件存储管理工具类，封装文件创建、写入、读取方法：</li></ol><pre><code class="typescript">// utils/FileStorageManager.ets
import fileIo from '@ohos.fileio';
import fs from '@ohos.file.fs';
import { Context } from '@ohos/application';

// 日志文件存储路径（鸿蒙应用私有存储目录，避免被其他应用访问）
let logFilePath: string = '';

/**
 * 初始化文件存储路径（应用启动时调用）
 * @param context 应用上下文
 */
export async function initLogFile(context: Context): Promise&lt;void&gt; {
  // 获取应用私有存储目录（files目录，用于存储应用私有文件）
  const filesDir = await context.getFilesDir();
  // 定义日志文件路径（格式：log_20240520.log，按日期命名）
  const date = new Date();
  const dateStr = date.toISOString().split('T')[0].replace(/-/g, '');
  logFilePath = `${filesDir}/logs/log_${dateStr}.log`;

  // 创建日志目录（若不存在）
  const logDir = `${filesDir}/logs`;
  if (!fs.accessSync(logDir)) {
    fs.mkdirSync(logDir, { recursive: true }); // recursive: true 递归创建目录
  }

  // 创建日志文件（若不存在）
  if (!fs.accessSync(logFilePath)) {
    const file = fs.openSync(logFilePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
    fs.closeSync(file); // 创建后关闭文件，避免资源泄露
  }
}

/**
 * 写入大体积日志到文件
 * @param log 日志内容（字符串）
 */
export async function writeLogToFile(log: string): Promise&lt;boolean&gt; {
  if (!logFilePath || !log) return false;
  try {
    // 拼接日志格式（时间+日志内容+换行）
    const date = new Date().toLocaleString();
    const logContent = `[${date}] ${log}\n`;

    // 以追加模式打开文件，写入日志（避免覆盖原有内容）
    const fileFd = fs.openSync(logFilePath, fs.OpenMode.WRITE_ONLY | fs.OpenMode.APPEND);
    // 写入日志内容（转换为Uint8Array格式）
    const buffer = new TextEncoder().encode(logContent);
    fs.writeSync(fileFd, buffer);
    // 关闭文件描述符
    fs.closeSync(fileFd);
    return true;
  } catch (error) {
    console.error('写入日志文件失败：', error);
    return false;
  }
}

/**
 * 读取日志文件内容
 */
export async function readLogFile(): Promise&lt;string&gt; {
  if (!logFilePath) return '';
  try {
    // 以只读模式打开文件
    const fileFd = fs.openSync(logFilePath, fs.OpenMode.READ_ONLY);
    // 获取文件大小
    const fileStat = fs.fstatSync(fileFd);
    const buffer = new Uint8Array(fileStat.size);
    // 读取文件内容
    fs.readSync(fileFd, buffer);
    // 关闭文件描述符
    fs.closeSync(fileFd);
    // 转换为字符串并返回
    return new TextDecoder().decode(buffer);
  } catch (error) {
    console.error('读取日志文件失败：', error);
    return '';
  }
}</code></pre><ol start="2"><li>初始化文件存储路径，完善日志持久化闭环：</li></ol><pre><code class="typescript">// entryability/MainAbility.ets
import { initLogFile } from '../utils/FileStorageManager';

export default class MainAbility extends Ability {
  async onCreate(want, launchParam) {
    super.onCreate(want, launchParam);
    // 初始化三大持久化组件
    await initPreferences(this.context);
    await initRelationalStore(this.context);
    await initLogFile(this.context);
    // 其他初始化操作...
  }
}</code></pre><h3>2.6 第四步：整合三大组件，实现完整日志持久化</h3><p>创建日志工具类，整合Preferences、RelationalStore、FileStorage的能力，根据日志大小、配置，自动选择合适的持久化方式：</p><pre><code class="typescript">// utils/LogUtil.ets
import { getLogConfig, LogConfigKey } from './PreferenceManager';
import { insertLog, LogModel } from './RelationalStoreManager';
import { writeLogToFile } from './FileStorageManager';
import { generateUUID } from './UUIDUtil'; // 自定义UUID生成工具，用于日志ID

/**
 * 打印并持久化日志（核心入口方法）
 * @param level 日志级别
 * @param content 日志内容
 */
export async function log(level: 'debug' | 'info' | 'error', content: string): Promise&lt;void&gt; {
  // 1. 读取日志配置，判断是否开启日志存储
  const enableStorage = await getLogConfig&lt;boolean&gt;(LogConfigKey.ENABLE_LOG_STORAGE);
  if (!enableStorage) return;

  // 2. 读取日志级别配置，判断当前日志是否需要存储
  const logLevel = await getLogConfig&lt;string&gt;(LogConfigKey.LOG_LEVEL);
  const levelPriority = { debug: 1, info: 2, error: 3 };
  if (levelPriority[level] &lt; levelPriority[logLevel]) return;

  // 3. 构造日志数据
  const logModel: LogModel = {
    id: generateUUID(), // 生成唯一日志ID
    level: level,
    content: content,
    createTime: Date.now(),
    processId: 1 // 实际开发中，可获取当前应用进程ID
  };

  // 4. 根据日志大小，选择持久化方式（&gt;1KB写入文件，否则写入数据库）
  const contentSize = new TextEncoder().encode(content).length;
  if (contentSize &gt; 1024) {
    // 大体积日志：写入文件
    await writeLogToFile(content);
  } else {
    // 小体积日志：写入数据库
    await insertLog(logModel);
  }
}

// 封装常用日志方法
export async function debug(content: string) {
  await log('debug', content);
}

export async function info(content: string) {
  await log('info', content);
}

export async function error(content: string) {
  await log('error', content);
}</code></pre><ol start="3"><li>应用中使用日志工具类，实现日志持久化：</li></ol><pre><code class="typescript">// pages/Index.ets
import { debug, info, error } from '../utils/LogUtil';

@Entry
@Component
struct Index {
  build() {
    Column() {
      Button('打印调试日志')
        .onClick(async () =&gt; {
          await debug('用户点击了调试日志按钮，当前页面加载完成');
        })
      Button('打印错误日志')
        .onClick(async () =&gt; {
          try {
            // 模拟错误
            const a = null;
            a.toString();
          } catch (err) {
            await error(`发生错误：${JSON.stringify(err)}，错误堆栈：${err.stack}`);
          }
        })
    }
    .padding(20)
  }
}</code></pre><h2>三、最佳实践：鸿蒙数据持久化的优化技巧与避坑指南</h2><p>结合鸿蒙持久化组件的特性与实际开发经验，总结以下最佳实践原则，帮助开发者优化存储性能、规避常见问题，提升应用稳定性与用户体验：</p><h3>3.1 组件选型最佳实践：按需选择，避免滥用</h3><p>鸿蒙三大持久化组件各有侧重，选型直接影响应用性能，需严格根据数据场景选择，避免“大材小用”或“小材大用”：</p><ul><li>优先用Preferences：数据量小（单条数据&lt;1KB）、结构简单（键值对）、读写频繁（如应用配置、登录状态），无需复杂查询，Preferences轻量高效，读写速度最快。</li><li>首选RelationalStore：数据结构化、有固定字段（如用户信息、任务清单），需要条件查询、修改、删除，或数据量较大（万条级别），RelationalStore支持索引优化，查询效率高于文件存储。</li><li>仅用FileStorage：大体积二进制数据（图片、音频、视频）、非结构化文本（大日志、离线数据包），FileStorage适合存储大文件，但不支持复杂查询，需自行管理文件命名与路径。</li></ul><p>避坑点：不要用RelationalStore存储轻量级配置（如主题模式），会增加数据库连接开销；不要用Preferences存储大量结构化数据（如万条日志），会导致读写卡顿、数据管理混乱。</p><h3>3.2 性能优化最佳实践：减少开销，提升速度</h3><p>持久化操作若未优化，会导致应用卡顿、功耗升高，尤其是高频读写场景，需重点关注以下优化技巧：</p><ol><li>单例模式管理实例：Preferences、RelationalStore的初始化开销较大，需采用全局单例模式（如本案例中的工具类），避免重复初始化，减少资源占用。</li><li>批量操作替代单次操作：若需插入、修改多条数据（如批量导入日志、任务），不要循环调用单次插入/修改方法，RelationalStore可通过事务（transaction）实现批量操作，减少数据库IO开销：</li></ol><pre><code class="typescript">// 批量插入日志（事务优化）
async function batchInsertLogs(logs: LogModel[]): Promise&lt;boolean&gt; {
  if (!rdbStore || logs.length === 0) return false;
  try {
    // 开启事务
    await rdbStore.beginTransaction();
    // 批量插入
    for (const log of logs) {
      const values = new relationalStore.ValuesBucket();
      values.put('id', log.id);
      values.put('level', log.level);
      values.put('content', log.content);
      values.put('createTime', log.createTime);
      values.put('processId', log.processId);
      await rdbStore.insert(LOG_TABLE_NAME, values);
    }
    // 提交事务（成功则生效）
    await rdbStore.commitTransaction();
    return true;
  } catch (error) {
    // 失败则回滚事务，避免数据错乱
    await rdbStore.rollbackTransaction();
    return false;
  }
}</code></pre><ol start="3"><li>合理使用索引：RelationalStore中，频繁用于查询条件的字段（如日志级别、时间戳），需添加索引，可提升查询效率10倍以上；但避免过度索引（如每个字段都加索引），会增加插入、修改的开销。</li><li>及时释放资源：RelationalStore的ResultSet、FileStorage的文件描述符（fileFd），使用后需及时关闭，避免资源泄露，导致应用崩溃或设备资源耗尽。</li><li>异步操作避免阻塞主线程：所有持久化操作（读写Preferences、数据库、文件）均为IO操作，需用async/await实现异步调用，不要在主线程（UI线程）中执行同步持久化操作，否则会导致UI卡顿。</li></ol><h3>3.3 安全性最佳实践：保护数据，避免泄露</h3><p>应用持久化的数据可能包含用户隐私（如登录信息、偏好设置），需通过以下方式提升安全性，符合鸿蒙应用安全规范：</p><ol><li>敏感数据加密存储：对于密码、token、隐私日志等敏感数据，不要明文存储，可结合鸿蒙的加密API（如CryptoKit）加密后再写入Preferences、RelationalStore或文件，解密后再读取。</li><li>选择合适的存储目录：优先使用应用私有存储目录（如context.getFilesDir()、context.getCacheDir()），该目录仅当前应用可访问，避免存储在公共目录（如SD卡），防止被其他应用读取。</li><li>开启数据库加密：RelationalStore初始化时，设置securityLevel为S1（如本案例），开启数据库加密，保护结构化数据的安全性，避免数据库文件被篡改、读取。</li><li>权限严格管控：仅申请必要的存储权限，无需读取/写入权限时，不添加相关权限；同时在应用中添加权限申请引导，告知用户权限用途，提升用户信任度。</li></ol><h3>3.4 避坑指南：常见问题与解决方案</h3><p>结合实际开发中遇到的高频问题，总结以下避坑点与解决方案，帮助开发者快速排查问题：</p><ul><li>问题1：Preferences写入数据后，重启应用丢失？<br/>解决方案：Preferences的put方法仅将数据写入内存，需调用flush()方法提交修改，否则数据不会持久化到本地；同时确保初始化时传入正确的上下文（如Ability的context，而非Component的context）。</li><li>问题2：RelationalStore查询无结果，或插入数据失败？<br/>解决方案：检查数据表是否创建成功（需执行CREATE TABLE语句）；检查字段名、数据类型是否与ValuesBucket一致（如字段为INTEGER，不可传入字符串）；检查数据库实例是否初始化成功。</li><li>问题3：FileStorage写入文件失败，提示权限不足？<br/>解决方案：检查module.json5中是否添加了WRITE_USER_STORAGE、READ_USER_STORAGE权限；鸿蒙4.0+需在应用启动时主动申请权限（通过requestPermissionsFromUser接口），用户授权后才能访问本地存储。</li><li>问题4：持久化操作导致UI卡顿？<br/>解决方案：将所有持久化操作（读写、查询）改为异步操作（async/await），避免在build方法、onClick等UI回调中执行同步持久化操作；高频读写场景可添加缓存层，减少IO操作。</li></ul><h2>四、总结</h2><p>鸿蒙数据持久化存储的核心优势的在于“统一API、多场景适配、高性能、高安全”，通过Preferences、RelationalStore、FileStorage三大组件，覆盖了轻量级配置、结构化数据、大文件存储的全场景需求，同时支持分布式扩展，完美适配鸿蒙的全场景协同理念。</p><p>对于开发者而言，实现鸿蒙数据持久化的关键的是：先明确数据场景，精准选择合适的存储组件；再通过单例管理、异步操作、批量处理等技巧优化性能；最后遵循安全规范，保护用户数据隐私，规避常见坑点。</p><p>随着鸿蒙生态的不断完善，持久化组件的功能也在持续升级，后续将支持更复杂的分布式同步、更高效的大文件存储、更便捷的加密能力。掌握鸿蒙数据持久化技术，是开发高质量鸿蒙应用的基础，也是适配全场景智慧生活需求的核心能力之一。</p>]]></description></item><item>    <title><![CDATA[x-cmd 发布 v0.8.2：nano 语法高亮一键搞定，Claude 署名支持全局配置，支持 G]]></title>    <link>https://segmentfault.com/a/1190000047609092</link>    <guid>https://segmentfault.com/a/1190000047609092</guid>    <pubDate>2026-02-13 11:03:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>TLDR:</strong></p><ul><li>nano 语法高亮一键搞定：新增 nanorc 模块，支持 126 种语法文件，国内 Mirror 加速下载。</li><li>Claude 署名全局配置：<code>x claude attr</code> 新增 <code>-g</code> 全局选项，多项目统一管理更省心。</li><li><code>zhipu</code> 模块支持智谱 glm-5 模型：既然敢涨价 50%，想必官方是有点东西的，首轮集成已就绪。</li></ul><h2>🚀 X-CMD v0.8.2 更新详情</h2><h3><a href="https://link.segmentfault.com/?enc=issO3J42UA9PUswKG0mrdg%3D%3D.oNXY%2BHvBRfWii89ffcRjIOiXom7BKVOzzgisw9M8BKk%3D" rel="nofollow" target="_blank">nanorc</a></h3><ul><li>新增 <code>nanorc</code> 模块 —— 说实话，是因为我被坑了。</li></ul><p>在 macOS 上调 nanorc 配置，折腾了大半天才发现：系统自带的 nano 其实是 pico "套皮"，压根不支持 nanorc。<br/>上网一搜，才发现这锅是 pico 的。既然官方不给力，那就自己动手。</p><p>两年前在树莓派上我就用过 scopatz/nanorc，它内置了 126 种语法文件，虽然六年没更新但质量过硬。<br/>这次顺手把它搬进 x-cmd，资源包用 curl 就能下，对 Linux 和各类嵌入式环境非常友好。</p><p>而且，为了国内下载速度更快，我把资源包托管到了 codeberg。</p><p>另外还有个 <code>x nano</code> 命令，会自动检测并下载 GNU nano 直接使用，不影响系统。</p><p>示例：</p><pre><code class="bash"># 下载并配置语法高亮
x nanorc setup

# 查看已安装的语法文件
x nanorc ls

# 清理配置
x nanorc tdown</code></pre><hr/><h3><a href="https://link.segmentfault.com/?enc=hj9lrDzUtM9ODcO8qDNeHw%3D%3D.9ZNEAQ9d8Z5dgURlNQx2pmwM1ayc2jCDqZtUtPDSOHg%3D" rel="nofollow" target="_blank">claude</a></h3><ul><li><code>x claude attr</code> 新增 <code>-g|--global</code> 全局配置选项 —— 纯粹是因为项目太多，懒得一个个配。</li></ul><p>之前 <code>use</code>、<code>set</code>、<code>rm</code>、<code>cat</code> 只能改当前项目的配置，当你有几十个项目需要统一调整时，重复操作简直是折磨。现在加上 -g，全局生效，一次搞定。</p><p>示例：</p><pre><code class="bash"># 全局设置配置
x claude attr use -g

# 查看全局配置
x claude attr cat -g

# 移除全局配置
x claude attr rm -g</code></pre><hr/><h3><a href="https://link.segmentfault.com/?enc=FyzU6uJtsLqaGVCr7P8caw%3D%3D.LtzaExkDoma5RQ37eMASzUKiIR%2B9r0ZKnhQuScsFBB8%3D" rel="nofollow" target="_blank">zhipu</a></h3><ul><li><code>zhipu</code> 模块新增 <code>glm-5</code> 模型支持 —— 既然敢涨价 50%，想必官方是有点东西的。</li></ul><p>本着“既然敢涨价，肯定有底气”的想法，我们第一时间将其集成到生产力工作流中。</p><p>说实话我自己还没深度用，体感不多，先用起来再说。</p><p>示例：</p><pre><code class="bash"># 设置 glm-5 为默认模型
x zhipu --cfg model=glm-5</code></pre><hr/><h3>⬆️ 如何升级</h3><p>现有用户可以通过以下命令快速切换至 Beta 版本进行体验：</p><pre><code class="bash">x upgrade beta</code></pre><h4>如果你没有安装 x-cmd, 只需要打开你的终端:</h4><pre><code class="bash">eval "$(curl https://get.x-cmd.com)"</code></pre><p>x-cmd 是一个一站式的命令行工具集，其强大的功能可以为人类用户和AI共同使用。它还简化了很多工具的安装方法。<br/>马上安装，让 x-cmd 协同 AI 成为你的最强助手，实现生产力翻倍！</p><h3>🤝 开发者反馈</h3><p>如果您在自定义配置或代理设置中遇到任何疑问，欢迎前往 <a href="https://link.segmentfault.com/?enc=jr0F4%2FgXYZDpFm%2BZp9ElBQ%3D%3D.6KOAWtFkvxIoDGHS%2BO4sjh%2FT27XOv1U9cQZpM5DOqRSn8oNPub5Jja%2FH2xCVaMgB" rel="nofollow" target="_blank">GitHub Issues</a> 提交反馈，共同完善 X-CMD 生态。</p>]]></description></item><item>    <title><![CDATA[鸿蒙如何实现自定义UI组件 江南一点雨 ]]></title>    <link>https://segmentfault.com/a/1190000047609094</link>    <guid>https://segmentfault.com/a/1190000047609094</guid>    <pubDate>2026-02-13 11:02:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在鸿蒙（HarmonyOS）应用开发中，UI组件是构建用户界面的核心单元。鸿蒙系统内置了丰富的基础UI组件（如Text、Button、Column、Row等），可满足简单界面的开发需求，但在实际项目中，不同应用的UI风格、交互逻辑差异较大——例如电商应用的商品卡片、社交应用的消息气泡、工具类应用的自定义表单控件等，仅依靠基础组件无法实现统一风格、可复用性与个性化需求，此时就需要开发自定义UI组件。</p><p>鸿蒙基于ArkTS声明式开发范式，提供了灵活、高效的自定义UI组件开发能力，支持组件的封装、复用、组合与扩展，同时兼顾多设备（手机、平板、智慧屏等）适配需求。本文将从问题背景、实操案例、最佳实践三方面，全面解析鸿蒙自定义UI组件的实现逻辑与落地方法，助力开发者快速掌握组件封装技巧，提升开发效率与界面一致性。</p><h2>一、问题背景：自定义UI组件的开发需求与核心痛点</h2><p>随着鸿蒙应用生态的不断丰富，用户对界面体验的要求日益提升，基础UI组件已难以适配复杂场景的开发需求，自定义UI组件成为鸿蒙应用开发的必备能力。结合实际开发场景，其核心需求与传统开发痛点主要体现在以下三方面：</p><h3>1.1 核心开发需求</h3><p>自定义UI组件的需求本质是“复用性、个性化、一致性”，具体可分为三类：</p><ul><li>风格统一需求：企业级应用需保持全APP UI风格一致（如按钮圆角、颜色、字体统一），基础组件的默认样式无法满足，需封装符合产品规范的自定义组件（如统一风格的按钮、输入框）。</li><li>功能复用需求：多个页面需使用相同逻辑与样式的组件（如商品列表卡片、用户头像+昵称组合、弹窗提示），重复编写代码会增加开发成本与维护难度，需封装可复用组件，实现“一次开发、多处调用”。</li><li>个性化交互需求：基础组件的交互逻辑固定（如默认Button仅支持点击事件），无法满足个性化交互（如渐变按钮、带加载状态的按钮、可点击计数的控件），需通过自定义组件扩展交互能力。</li></ul><h3>1.2 传统开发痛点（未封装自定义组件的问题）</h3><p>若不进行自定义UI组件封装，仅使用基础组件开发，会面临诸多痛点，严重影响开发效率与应用质量：</p><ul><li>代码冗余，维护成本高：相同样式、逻辑的组件在多个页面重复编写，后续需修改样式（如按钮颜色调整）时，需修改所有相关页面的代码，易遗漏、易出错。</li><li>UI风格不一致：不同开发者编写相同类型组件时，可能出现样式差异（如圆角大小、间距不同），导致APP界面杂乱，影响用户体验。</li><li>交互逻辑混乱：个性化交互逻辑（如加载状态、计数逻辑）与页面业务逻辑耦合，代码可读性差，后续难以扩展与调试。</li><li>多设备适配困难：鸿蒙支持多设备形态，不同设备的屏幕尺寸、分辨率差异较大，未封装的组件需在每个页面单独处理适配逻辑，适配效率低。</li></ul><p>针对以上痛点，鸿蒙ArkTS声明式开发范式提供了“组件化”的解决方案，通过@Component装饰器快速封装自定义组件，支持组件的属性传递、事件回调、状态管理与多设备适配，让开发者能够高效实现个性化、可复用的UI组件，同时降低代码耦合度。</p><h2>二、具体案例：鸿蒙自定义组合UI组件的对接步骤</h2><p>本案例基于鸿蒙4.0+、ArkTS声明式开发范式，开发一套“渐变按钮+数字计数器”组合自定义组件（命名为CountButtonComponent），实现以下功能：按钮支持渐变背景、圆角样式、加载状态切换；点击按钮可实现数字计数器的增减；支持通过组件属性自定义按钮文本、渐变颜色、初始计数与计数步长；支持点击事件回调，满足不同页面的复用需求。完整对接步骤如下，覆盖组件封装、属性传递、事件回调、状态管理与页面调用全流程：</p><h3>2.1 环境准备与基础配置</h3><p>首先完成开发环境搭建与应用基础配置，确保支持ArkTS自定义组件开发：</p><ol><li>开发环境：安装DevEco Studio 4.0+，配置HarmonyOS 4.0+ SDK，启用ArkTS声明式开发模式（新建项目时选择“Application”，模板选择“Empty Ability (ArkTS)”）。</li><li>项目结构：在entry/src/main/ets目录下，新建components文件夹（用于存放所有自定义组件），本次案例在components文件夹下创建CountButtonComponent.ets文件（自定义组件核心文件），项目结构如下：</li></ol><pre><code>entry
└── src
    └── main
        └── ets
            ├── components       # 自定义组件目录
            │   └── CountButtonComponent.ets  # 本次开发的组合自定义组件
            ├── pages            # 页面目录
            │   └── Index.ets     # 调用自定义组件的测试页面
            └── entryability     # 应用入口
                └── MainAbility.ets</code></pre><ol start="3"><li>依赖说明：自定义UI组件开发无需额外导入第三方依赖，直接使用鸿蒙ArkTS内置的装饰器（@Component、@Prop、@Link、@Emits等）与基础组件即可。</li></ol><h3>2.2 需求拆解与组件设计</h3><p>本次自定义CountButtonComponent组件的需求拆解与设计如下，确保组件的灵活性与可复用性：</p><ul><li>组件结构：由两部分组成——上方渐变按钮（支持加载状态）、下方数字计数器（显示当前计数）。</li><li>可配置属性（Props）：按钮文本（buttonText）、按钮渐变起始颜色（startColor）、渐变结束颜色（endColor）、初始计数（initCount）、计数步长（step）、按钮圆角（radius）。</li><li>状态管理：组件内部维护两个状态——计数状态（count，用于显示当前数字）、加载状态（isLoading，用于控制按钮是否显示加载中）。</li><li>交互逻辑：点击按钮时，若处于加载状态则不执行计数；若处于正常状态，执行计数增减（默认递增，可通过属性配置步长，步长为负则递减）；点击按钮后触发自定义事件，向父组件传递当前计数。</li><li>样式设计：按钮支持渐变背景、固定高度、自适应宽度；计数器支持居中显示、自定义字体大小；整体组件支持居中对齐，适配不同屏幕尺寸。</li></ul><h3>2.3 第一步：封装自定义UI组件核心代码</h3><p>在CountButtonComponent.ets文件中，使用@Component装饰器封装自定义组件，实现组件结构、样式、状态管理与交互逻辑，代码如下，关键步骤添加详细注释：</p><pre><code class="typescript">// components/CountButtonComponent.ets
import { CommonConstants } from '../common/CommonConstants'; // 可自定义常量类，存储默认值

// 定义组件的属性接口（Props），规范传入的属性类型与默认值
interface CountButtonProps {
  // 按钮文本，默认值为"点击计数"
  buttonText?: string;
  // 渐变起始颜色，默认值为#3a86ff
  startColor?: string;
  // 渐变结束颜色，默认值为#8338ec
  endColor?: string;
  // 初始计数，默认值为0
  initCount?: number;
  // 计数步长，默认值为1（步长为负则递减）
  step?: number;
  // 按钮圆角，默认值为20vp
  radius?: number;
}

// @Component装饰器：声明当前类为鸿蒙自定义UI组件
@Component
// export导出组件，供其他页面调用
export default struct CountButtonComponent {
  // @Prop装饰器：接收父组件传递的属性，父组件属性变化时，子组件同步更新（单向数据流）
  // 为属性设置默认值，确保父组件未传递时组件正常显示
  @Prop buttonText: string = '点击计数';
  @Prop startColor: string = '#3a86ff';
  @Prop endColor: string = '#8338ec';
  @Prop initCount: number = 0;
  @Prop step: number = 1;
  @Prop radius: number = 20;

  // @State装饰器：组件内部状态，状态变化时，组件自动刷新UI
  @State count: number = this.initCount; // 计数状态，初始值为父组件传递的initCount
  @State isLoading: boolean = false; // 加载状态，默认false（正常状态）

  // @Emits装饰器：声明自定义事件，用于向父组件传递数据（子传父）
  // 此处声明countChange事件，传递当前计数
  @Emits('countChange')
  private emitCountChange() {
    return [this.count]; // 向父组件传递的参数（当前计数）
  }

  // 组件的构建方法，返回组件的UI结构（必须实现）
  build() {
    // Column：垂直布局，包裹按钮与计数器，居中对齐
    Column({ alignItems: ItemAlign.Center, space: 12 }) {
      // 渐变按钮：使用Decorator装饰器实现渐变背景，结合Button组件
      DecoratorButton()
        .width('80%') // 按钮宽度为父容器的80%，自适应屏幕
        .height(50) // 按钮固定高度
        .radius(this.radius) // 按钮圆角，使用父组件传递的属性
        // 渐变背景：linearGradient线性渐变，方向为从左到右
        .backgroundColor(LinearGradient.createLinearGradient({
          direction: GradientDirection.Left,
          colors: [this.startColor, this.endColor] // 渐变颜色，使用父组件传递的属性
        }))
        // 按钮文本：根据加载状态显示不同文本，加载时显示"加载中"，正常时显示按钮文本
        .text(this.isLoading ? '加载中' : this.buttonText)
        .fontColor(Color.White) // 按钮文本颜色为白色
        .fontSize(18) // 按钮文本字体大小
        // 按钮点击事件：控制加载状态与计数逻辑
        .onClick(async () =&gt; {
          // 若处于加载状态，不执行任何操作
          if (this.isLoading) return;

          // 模拟加载状态（实际开发中可替换为接口请求等异步操作）
          this.isLoading = true;
          await new Promise(resolve =&gt; setTimeout(resolve, 500)); // 延迟500ms，模拟加载

          // 加载完成后，更新计数（根据步长增减）
          this.count += this.step;
          // 触发自定义事件，向父组件传递当前计数
          this.emitCountChange();

          // 关闭加载状态
          this.isLoading = false;
        })
        // 禁用状态：加载时禁用按钮，避免重复点击
        .enabled(!this.isLoading)

      // 计数器：显示当前计数，居中对齐
      Text(`当前计数：${this.count}`)
        .fontSize(16)
        .fontColor('#333333')
        .fontWeight(FontWeight.Medium)
    }
    .width('100%') // 组件宽度占满父容器
    .padding(20) // 组件内边距
  }
}</code></pre><h3>2.4 第二步：定义常量类（可选，优化代码可读性）</h3><p>为了规范组件默认值，避免魔法数字/魔法字符串，可在entry/src/main/ets目录下新建common/CommonConstants.ets文件，定义组件默认常量，代码如下：</p><pre><code class="typescript">// common/CommonConstants.ets
// 自定义UI组件默认常量
export class CommonConstants {
  // CountButtonComponent组件默认值
  public static readonly COUNT_BUTTON_DEFAULT_TEXT = '点击计数';
  public static readonly COUNT_BUTTON_DEFAULT_START_COLOR = '#3a86ff';
  public static readonly COUNT_BUTTON_DEFAULT_END_COLOR = '#8338ec';
  public static readonly COUNT_BUTTON_DEFAULT_INIT_COUNT = 0;
  public static readonly COUNT_BUTTON_DEFAULT_STEP = 1;
  public static readonly COUNT_BUTTON_DEFAULT_RADIUS = 20;
}

// 若使用常量类，可修改CountButtonComponent的属性默认值，示例：
// @Prop buttonText: string = CommonConstants.COUNT_BUTTON_DEFAULT_TEXT;</code></pre><h3>2.5 第三步：页面调用自定义UI组件</h3><p>在pages/Index.ets页面中，导入并调用自定义的CountButtonComponent组件，实现组件的复用与属性配置、事件监听，代码如下：</p><pre><code class="typescript">// pages/Index.ets
import CountButtonComponent from '../components/CountButtonComponent';
import { CommonConstants } from '../common/CommonConstants';

@Entry // 声明当前页面为应用入口页面
@Component // 声明当前类为页面组件（页面本质也是一种自定义组件）
struct Index {
  // 页面状态：用于接收自定义组件传递的计数
  @State currentCount: number = CommonConstants.COUNT_BUTTON_DEFAULT_INIT_COUNT;

  build() {
    // Column：页面垂直布局，居中对齐，占满整个屏幕
    Column({ alignItems: ItemAlign.Center, justifyContent: FlexAlign.Center }) {
      // 页面标题
      Text('鸿蒙自定义UI组件示例')
        .fontSize(24)
        .fontWeight(FontWeight.Bold)
        .fontColor('#333333')
        .margin({ bottom: 50 })

      // 调用自定义组件：CountButtonComponent
      // 1. 传递自定义属性（覆盖默认值）
      CountButtonComponent({
        buttonText: '点击递增（步长2）',
        startColor: '#ff007a',
        endColor: '#ff6b35',
        initCount: 10,
        step: 2,
        radius: 25
      })
      // 2. 监听自定义组件的countChange事件，接收传递的当前计数
      .onCountChange((count) =&gt; {
        this.currentCount = count;
        console.log(`自定义组件传递的计数：${count}`); // 打印日志，便于调试
      })

      // 再次调用自定义组件：复用组件，传递不同属性，实现不同样式与逻辑
      CountButtonComponent({
        buttonText: '点击递减（步长1）',
        startColor: '#06d6a0',
        endColor: '#118ab2',
        initCount: 50,
        step: -1,
        radius: 15
      })
      .margin({ top: 30 }) // 与上方组件保持间距
      .onCountChange((count) =&gt; {
        console.log(`第二个组件传递的计数：${count}`);
      })

      // 显示第一个组件传递的计数（页面与组件的数据交互）
      Text(`第一个组件当前计数：${this.currentCount}`)
        .fontSize(18)
        .fontColor('#ff007a')
        .margin({ top: 50 })
    }
    .width('100%')
    .height('100%')
  }
}</code></pre><h3>2.6 第四步：组件调试与效果验证</h3><p>组件开发与页面调用完成后，通过DevEco Studio进行调试，验证组件功能与样式是否符合预期，调试步骤如下：</p><ol><li>选择调试设备：可选择鸿蒙模拟器（如Phone EMUI 13.0）或真实鸿蒙设备（需开启开发者模式，连接电脑）。</li><li>运行应用：点击DevEco Studio顶部的“运行”按钮，启动应用，进入Index页面。</li><li>功能验证：</li></ol><ul><li>样式验证：检查两个自定义组件的渐变颜色、圆角、文本样式是否与传递的属性一致，组件是否居中对齐。</li><li>交互验证：点击按钮，观察是否显示“加载中”状态（延迟500ms），加载完成后计数是否按步长增减。</li><li>事件验证：点击按钮后，查看控制台日志，确认自定义事件是否正常传递计数；页面中的计数显示是否与组件传递的计数一致。</li><li>复用验证：确认两个组件独立工作，计数互不影响，实现组件复用效果。</li></ul><ol start="4"><li>问题排查：若组件样式异常，检查布局属性（width、height、margin等）；若交互无响应，检查点击事件、状态管理（@State、@Prop）是否正确；若事件传递失败，检查@Emits装饰器与事件监听方法是否对应。</li></ol><h3>2.7 第五步：多设备适配优化（可选）</h3><p>鸿蒙支持多设备形态，为了让自定义组件适配不同屏幕尺寸（如手机、平板），可在组件中使用vp（虚拟像素）作为尺寸单位（鸿蒙默认支持vp自适应），同时通过媒体查询（MediaQuery）动态调整组件样式，示例如下（修改CountButtonComponent的build方法）：</p><pre><code class="typescript">// 多设备适配优化：根据屏幕宽度调整按钮大小与字体大小
build() {
  // 媒体查询：获取当前屏幕宽度
  const screenWidth = mediaquery.getSystemInfoSync().screenWidth;

  Column({ alignItems: ItemAlign.Center, space: 12 }) {
    DecoratorButton()
      .width(screenWidth &gt; 600 ? '60%' : '80%') // 平板（宽度&gt;600vp）按钮宽度60%，手机80%
      .height(screenWidth &gt; 600 ? 60 : 50) // 平板按钮高度60vp，手机50vp
      .radius(this.radius)
      .backgroundColor(LinearGradient.createLinearGradient({
        direction: GradientDirection.Left,
        colors: [this.startColor, this.endColor]
      }))
      .text(this.isLoading ? '加载中' : this.buttonText)
      .fontColor(Color.White)
      .fontSize(screenWidth &gt; 600 ? 20 : 18) // 平板字体20vp，手机18vp
      .onClick(async () =&gt; {
        // 原有点击逻辑不变...
      })

    Text(`当前计数：${this.count}`)
      .fontSize(screenWidth &gt; 600 ? 18 : 16)
      .fontColor('#333333')
      .fontWeight(FontWeight.Medium)
  }
  .width('100%')
  .padding(20)
}</code></pre><h2>三、最佳实践：鸿蒙自定义UI组件的优化技巧与避坑指南</h2><p>结合鸿蒙ArkTS声明式开发特性与实际项目经验，总结以下自定义UI组件的最佳实践原则，帮助开发者优化组件性能、提升复用性、规避常见问题，开发出高质量的自定义UI组件：</p><h3>3.1 组件设计最佳实践：高内聚、低耦合</h3><p>组件设计的核心是“高内聚、低耦合”，确保组件独立、可复用，具体遵循以下原则：</p><ul><li>单一职责原则：一个自定义组件只负责一个核心功能（如本次案例的CountButtonComponent，仅负责“按钮+计数”功能），避免组件功能过于复杂（如同时包含表单、列表、弹窗等功能），否则会降低复用性。</li><li>组件拆分合理：复杂UI可拆分为多个小型自定义组件，再组合使用（如“商品卡片组件”可拆分为“头像组件、标题组件、价格组件”），便于维护与复用。</li><li>低耦合设计：组件内部逻辑（状态、交互）与父组件、其他组件解耦，仅通过Props（父传子）与Emits（子传父）实现数据交互，不直接操作其他组件的状态。</li></ul><h3>3.2 属性与事件设计最佳实践：灵活、规范</h3><p>Props（属性）与Emits（事件）是组件与外部交互的核心，需设计得灵活、规范，便于调用者使用：</p><ol><li>属性设计：</li></ol><ul><li>必传属性与可选属性区分：必传属性（如组件核心功能依赖的属性）需在接口中声明，可选属性需设置合理默认值，避免父组件未传递时组件报错。</li><li>属性类型规范：使用TypeScript接口定义Props类型，明确属性的类型（如string、number、boolean），提升代码可读性与类型安全性，避免传入错误类型的属性。</li><li>属性命名规范：采用小驼峰命名法（如buttonText、startColor），与鸿蒙基础组件的命名风格保持一致（如Text组件的fontSize、fontColor），降低调用者的学习成本。</li></ul><ol start="2"><li>事件设计：</li></ol><ul><li>事件命名规范：采用“动作+Change/Click”的命名方式（如countChange、buttonClick），明确事件的作用，与鸿蒙基础组件的事件命名风格保持一致（如Button的onClick、TextInput的onChange）。</li><li>传递必要参数：事件回调仅传递外部需要的数据（如countChange事件仅传递当前计数），避免传递组件内部无关数据，降低耦合度。</li><li>避免过度事件暴露：仅暴露组件外部需要的事件，组件内部的交互事件（如加载状态变化）无需暴露，避免增加调用者的使用复杂度。</li></ul><h3>3.3 状态管理最佳实践：合理选择状态装饰器</h3><p>鸿蒙提供了@State、@Prop、@Link、@Provide、@Consume等多种状态装饰器，不同装饰器的适用场景不同，需合理选择，避免滥用：</p><ul><li>@State：用于组件内部状态管理（如本次案例的count、isLoading），状态变化时仅刷新当前组件，适合组件内部使用、不对外暴露的状态。</li><li>@Prop：用于父组件向子组件传递单向数据（如本次案例的buttonText、startColor），父组件属性变化时子组件同步更新，但子组件无法修改父组件的属性，适合只读属性传递。</li><li>@Link：用于父组件与子组件双向数据绑定（如表单输入框组件），子组件修改属性时，父组件的属性同步更新，适合需要双向交互的场景（如自定义输入框）。</li><li>@Provide/@Consume：用于跨层级组件数据传递（如祖父组件向孙子组件传递数据），避免多层级Props传递（props drilling），适合复杂组件树的场景。</li></ul><p>避坑点：不要用@State存储需要对外暴露的状态，不要用@Prop实现双向数据绑定，否则会导致状态混乱、组件刷新异常。</p><h3>3.4 性能优化最佳实践：减少不必要的刷新</h3><p>自定义组件的性能直接影响应用的流畅度，尤其是高频复用的组件（如列表项组件），需重点优化，减少不必要的组件刷新：</p><ol><li>避免冗余状态：组件内部仅维护必要的状态，冗余状态会导致组件频繁刷新，影响性能（如无需维护的临时变量，不要用@State装饰）。</li><li>合理使用@Watch装饰器：仅在需要监听属性变化并执行逻辑时，使用@Watch装饰器，避免滥用@Watch，否则会增加性能开销。</li><li>列表组件优化：若自定义组件用于列表项（如List组件的子项），需使用ListItem组件包裹，并为每个列表项设置唯一的key（如id），避免列表刷新时所有子组件重新渲染。</li><li>避免频繁修改状态：在交互逻辑中（如点击事件），避免频繁修改@State状态（如循环修改count），可通过批量修改、延迟修改等方式优化。</li><li>样式优化：避免使用过于复杂的样式（如多层渐变、复杂阴影），复杂样式会增加渲染开销；尽量复用样式（如通过常量类定义统一的颜色、字体）。</li></ol><h3>3.5 样式与多设备适配最佳实践：统一、兼容</h3><p>自定义组件的样式需保持统一，同时适配鸿蒙多设备形态，具体遵循以下原则：</p><ul><li>样式统一：制定组件样式规范（如按钮圆角、颜色、字体大小、间距），通过常量类统一管理，确保所有自定义组件的样式一致，提升APP界面一致性。</li><li>使用自适应单位：优先使用vp（虚拟像素）作为尺寸单位，vp会根据设备屏幕密度自动适配，避免使用px（物理像素），否则会导致不同设备上样式比例失调。</li><li>媒体查询适配：对于不同屏幕尺寸的设备（如手机、平板、智慧屏），使用mediaquery动态调整组件样式（如宽度、高度、字体大小），确保组件在不同设备上显示正常。</li><li>方向适配：支持屏幕横竖屏切换，通过Flex布局、Grid布局实现自适应，避免固定布局导致横竖屏切换时样式错乱。</li></ul><h3>3.6 避坑指南：常见问题与解决方案</h3><p>结合实际开发中遇到的高频问题，总结以下避坑点与解决方案，帮助开发者快速排查问题：</p><ul><li>问题1：组件调用时，属性传递正确，但组件样式/状态未生效？<br/>解决方案：检查属性装饰器是否正确（如父传子需用@Prop，而非@State）；检查属性默认值是否覆盖了传递的值；检查组件是否正确导出（export default），父组件是否正确导入。</li><li>问题2：组件状态变化后，UI未刷新？<br/>解决方案：检查状态是否使用了正确的装饰器（如组件内部状态需用@State）；检查状态修改是否在异步操作中（如setTimeout、接口请求），异步操作中修改状态需确保上下文正确；避免直接修改@Prop装饰的属性（子组件无法修改@Prop属性）。</li><li>问题3：自定义事件无法触发，或父组件无法接收事件参数？<br/>解决方案：检查@Emits装饰器的事件名称与父组件监听的事件名称是否一致（区分大小写）；检查@Emits装饰器的返回值是否正确（需返回数组，数组元素为传递的参数）；检查父组件监听事件的方法是否正确接收参数。</li><li>问题4：组件复用后，多个组件的状态相互影响？<br/>解决方案：检查组件状态是否使用了@State（组件内部独立状态），避免使用全局变量存储组件状态；确保每个组件的初始化状态正确，避免状态共享导致相互影响。</li><li>问题5：多设备适配时，组件样式错乱？<br/>解决方案：检查是否使用了vp单位；检查布局是否使用了自适应布局（如Flex、Grid），避免固定宽度/高度；使用媒体查询动态调整组件样式，适配不同屏幕尺寸。</li></ul><h2>四、总结</h2><p>鸿蒙基于ArkTS声明式开发范式，为自定义UI组件开发提供了灵活、高效的解决方案，通过@Component装饰器快速封装组件，结合@Prop、@Emits、@State等装饰器实现组件的属性传递、事件回调与状态管理，完美解决了基础组件无法满足的个性化、复用性与一致性需求。</p><p>实现鸿蒙自定义UI组件的核心逻辑是：明确组件需求与设计边界，通过Props与Emits实现组件与外部的低耦合交互，通过@State等装饰器管理组件内部状态，通过灵活的布局与样式实现多设备适配。在实际开发中，需遵循“高内聚、低耦合”的组件设计原则，合理选择状态装饰器，优化组件性能，规避常见坑点，才能开发出可复用、高性能、易维护的自定义UI组件。</p><p>随着鸿蒙生态的不断升级，自定义UI组件的开发能力也在持续完善，后续将支持更复杂的组件交互、更高效的性能优化与更便捷的多设备适配。掌握鸿蒙自定义UI组件开发技术，是提升鸿蒙应用开发效率、打造高质量用户界面的关键，也是鸿蒙开发者必备的核心技术。</p>]]></description></item><item>    <title><![CDATA[六款主流CRM核心模块深度横评：从跟单到订单，谁能真正解决企业痛点？ 正直的炒饭 ]]></title>    <link>https://segmentfault.com/a/1190000047609110</link>    <guid>https://segmentfault.com/a/1190000047609110</guid>    <pubDate>2026-02-13 11:02:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在数字化转型进程中，<strong>客户关系管理（CRM）的核心价值早已从“记录客户信息”升级为“全流程业务协同”</strong> 。对于企业而言，跟单协作的效率、销售跟踪的精准度、报价签约的合规性，以及合同订单的闭环管理，直接决定了客户转化率与业务稳定性。</p><p>本文选取<strong>超兔一体云（中小企业复杂场景）、Oracle CX（大型企业ERP联动）、Pipedrive（轻量销售流程）、Bitrix24（团队协作）、神州云动（AI自动化）、探马SCRM（微信生态）六款主流CRM，围绕跟单协作、销售跟踪、报价管理、签约管理、合同订单</strong>五大核心模块展开深度对比，结合行业场景与企业需求给出选型建议。</p><h2>一、先明确：CRM核心模块的“价值链条”</h2><p>CRM的五大核心模块并非孤立存在，而是形成了一条“线索→跟进→报价→签约→订单执行”的闭环：</p><ul><li>跟单协作解决“团队如何高效配合跟进客户”；</li><li>销售跟踪解决“如何精准识别客户需求、监控进度”；</li><li>报价管理解决“如何快速输出合理报价、提升转化”；</li><li>签约管理解决“如何规范合同流程、降低合规风险”；</li><li>合同订单解决“如何联动后端（采购/库存/财务）、确保交付”。</li></ul><p>只有当五大模块深度协同，才能真正实现“从线索到回款”的全链路自动化。</p><h2>二、核心模块深度对比</h2><h3>（一）跟单协作：从“个体跟进”到“团队协同”的效率革命</h3><p>跟单协作的核心是“让正确的人在正确的时间做正确的事”，需覆盖“复杂场景支持”“协作工具集成”“任务流转自动化”三大维度。</p><table><thead><tr><th>品牌</th><th>核心能力解析</th><th>典型场景适配</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>1. 独创“三一客（小单快单）+商机（中长单）+多方项目（大型工程）”多模型； 2. 360°跟单视图+时间线+自动日报，全流程可追溯； 3. 多方项目支持“项目组+合同+采购+收支”全周期管理。</td><td>适合<strong>项目型企业</strong>（如工程、系统集成）：需同时协调客户、供应商、内部团队的复杂项目。</td></tr><tr><td><strong>Oracle CX</strong></td><td>1. 与Oracle ERP深度集成，销售跟进记录自动同步库存/生产数据； 2. 支持“团队共享跟进记录”，避免信息差； 3. 内置制造/金融行业合规模板。</td><td>适合<strong>大型制造企业</strong>：销售跟进时需实时确认库存，避免“承诺不可交付”的合规风险。</td></tr><tr><td><strong>Pipedrive</strong></td><td>1. 拖拽式销售管道视图，直观展示“线索→商机→赢单”进度； 2. 与Asana集成，赢单后自动创建项目任务； 3. 移动端支持离线访问，外勤跟进无压力。</td><td>适合<strong>中小交易型企业</strong>（如快消、商贸）：销售流程简单，需快速推进线索转化。</td></tr><tr><td><strong>Bitrix24</strong></td><td>1. 内置“团队聊天+在线会议+任务看板+文件共享”全协作工具； 2. 免费版覆盖基础协作需求，Professional版支持高级自动化； 3. 跨部门协作无壁垒（销售→客服→财务）。</td><td>适合<strong>注重内部协同的中小企业</strong>（如IT服务、广告）：需频繁跨部门沟通客户需求。</td></tr><tr><td><strong>神州云动</strong></td><td>1. AI Agent自动分配跟单任务（按区域/行业/优先级）； 2. 客户信息查重+实时更新，避免销售撞单； 3. 秒级响应客户需求，提升跟进效率。</td><td>适合<strong>高线索量企业</strong>（如电销、互联网）：需快速分配线索，避免资源浪费。</td></tr><tr><td><strong>探马SCRM</strong></td><td>1. 企微聊天侧边栏直接调取“客户详情+话术库+历史记录”； 2. 客户SOP提醒（如“新增好友3天内发产品资料”）； 3. 多渠道线索（微信/头条/百度）自动分配。</td><td>适合<strong>微信生态企业</strong>（如教育、零售）：90%客户沟通在微信，需“边聊边跟进”。</td></tr></tbody></table><p><strong>模块总结</strong>：</p><ul><li>复杂项目选超兔；大型制造选Oracle；微信生态选探马；注重协作选Bitrix24；高线索量选神州云动；轻量流程选Pipedrive。</li></ul><h3>（二）销售跟踪：从“被动记录”到“主动预测”的精准化</h3><p>销售跟踪的核心是“用数据驱动线索转化”，需解决“多渠道线索整合”“客户生命周期管理”“目标进度监控”三大问题。</p><h4>1. 线索管理：多渠道集客与自动化处理</h4><table><thead><tr><th>品牌</th><th>线索来源覆盖</th><th>自动化能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>百度/抖音/官网/微信/会销/工商搜客，支持“表单自动抓取+手机号/IP归属地识别”。</td><td>线索一键处理（加客户/待办/订单），自动分配后发消息提醒。</td></tr><tr><td>Oracle CX</td><td>支持企业自有渠道+Oracle Marketing Cloud集成，覆盖B2B/B2C场景。</td><td>线索与ERP库存联动，自动标记“可交付”/“需生产”。</td></tr><tr><td>Pipedrive</td><td>官网/微信/地推，支持“手动录入+API对接”。</td><td>AI推荐“优先跟进对象”，提示“下一步行动”（如“客户3天未回复，需跟进”）。</td></tr><tr><td>Bitrix24</td><td>在线商店/微信/地推，支持“线索一键导入”。</td><td>线索自动关联客户历史订单，同步库存状态。</td></tr><tr><td>神州云动</td><td>多渠道线索（广告/官网/电销），支持“规则分配（按区域/行业）”。</td><td>知识图谱分析客户状态，精准定位“需求培养”/“有需求”阶段。</td></tr><tr><td>探马SCRM</td><td>对接头条/腾讯/百度广告+拓客宝/裂变获客，支持“企微好友自动同步”。</td><td>客户行为轨迹跟踪（如“查看产品页3次”），自动打标签（“高意向”）。</td></tr></tbody></table><h4>2. 客户生命周期与目标监控</h4><table><thead><tr><th>品牌</th><th>客户管理能力</th><th>目标监控能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>自动将客户分类为“需求培养→有需求→上首屏→目标→成功”客池；支持“用户画像自定义+列表布局调整”。</td><td>销售目标分解到“人/月/环节”，动态追踪用“红绿灯”标识（红=危险，黄=卡滞，绿=顺利）。</td></tr><tr><td>Oracle CX</td><td>360°客户视图，整合“交易历史+服务记录+库存状态”；支持“行业自定义用户画像”。</td><td>实时监控“销售进度+库存可用量”，避免超卖。</td></tr><tr><td>Pipedrive</td><td>销售管道可视化，直观展示“每个阶段的转化率”；支持“客户位置追踪”（外勤用）。</td><td>AI预测“赢单概率”，提示“需补充客户需求”。</td></tr><tr><td>Bitrix24</td><td>商机漏斗展示“线索→报价→签约”转化率；支持“多仓库库存跟踪”（实物型企业）。</td><td>销售目标按“团队/个人”分解，自动生成“日/周/月”报表。</td></tr><tr><td>神州云动</td><td>记录“电话/拜访/邮件”全互动行为，追溯销售过程；支持“销售漏斗分析”。</td><td>仪表盘展示“线索量/转化率/回款率”，实时监控目标完成度。</td></tr><tr><td>探马SCRM</td><td>客户标签体系（如“家长/高意向/上海”），实现精准营销；支持“客户SOP规范”（如“每周跟进1次”）。</td><td>销售行为管理（如“外勤打卡+拜访轨迹”），提升外勤效率。</td></tr></tbody></table><p><strong>模块总结</strong>：</p><ul><li>多渠道集客选超兔；精准预测选神州云动；微信生态选探马；库存联动选Oracle；轻量监控选Pipedrive。</li></ul><h3>（三）报价管理：从“经验定价”到“数据定价”的合规化</h3><p>报价管理的核心是“快速输出合理报价，同时控制风险”，需覆盖“模板自定义”“审批流程”“历史数据分析”三大环节。</p><table><thead><tr><th>品牌</th><th>核心能力解析</th><th>合规与效率平衡</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>1. 快速生成报价单（含产品详情/价格/交货期），支持“OpenCRM分享”（客户网页/小程序查看）； 2. 报价审批流程自定义（如“金额&gt;10万需销售经理审批”）； 3. 自动计算“市场活动成本→线索→签约转化率”，评估报价合理性。</td><td>适合<strong>注重“客户体验+成本控制”的企业</strong>：报价快且准，同时避免“低价竞单”。</td></tr><tr><td><strong>Oracle CX</strong></td><td>1. 内置CPQ（配置-定价-报价）功能，客户选产品时实时查询“库存/生产能力”； 2. 支持“复杂定价策略”（如“批量折扣+区域溢价”）； 3. 与Oracle Approval Management集成，合规校验。</td><td>适合<strong>制造/金融行业</strong>：报价需关联后端生产，避免“承诺无法落地”。</td></tr><tr><td><strong>Pipedrive</strong></td><td>1. 简化报价流程，支持“自定义模板+一键发送”； 2. 与QuickBooks/Xero集成，报价直接生成发票。</td><td>适合<strong>中小商贸企业</strong>：报价流程简单，需快速对接财务。</td></tr><tr><td><strong>Bitrix24</strong></td><td>1. 自定义报价模板（含商品规格/价目表），关联CRM客户信息； 2. 报价自动同步订单系统，避免重复录入。</td><td>适合<strong>在线商店企业</strong>：报价与商品库联动，提升效率。</td></tr><tr><td><strong>神州云动</strong></td><td>1. AI合规校验（如“报价低于成本线”自动提醒）； 2. 支持“产品报价+特价审批”，控制折扣权限； 3. 自动生成“报价转化率报表”，分析价格敏感度。</td><td>适合<strong>高客单价企业</strong>（如软件、设备）：报价需严格控制，避免利润流失。</td></tr><tr><td><strong>探马SCRM</strong></td><td>1. 报价模板关联客户标签（如“老客户享9折”）； 2. 查看客户历史报价，避免“同一客户不同价”； 3. 报价发送后跟踪“客户查看次数”，提示跟进时机。</td><td>适合<strong>微信生态企业</strong>：报价需“个性化+透明化”，提升客户信任。</td></tr></tbody></table><p><strong>模块总结</strong>：</p><ul><li>复杂定价选Oracle；成本控制选超兔；高客单价选神州云动；微信生态选探马；简单流程选Pipedrive。</li></ul><h3>（四）签约管理：从“纸质签署”到“电子闭环”的高效化</h3><p>签约管理的核心是“规范合同流程，降低法律风险”，需解决“模板自定义”“审批签署”“状态跟踪”三大问题。</p><table><thead><tr><th>品牌</th><th>核心能力解析</th><th>风险控制能力</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>1. 内置“服务型/实物型/行业定制”合同模板，自动填充客户/产品信息； 2. 支持“电子签署”（对接第三方电子签名平台）； 3. 合同状态跟踪（审批/签署/生效/到期），自动提醒“续签”。</td><td>适合<strong>项目型企业</strong>：合同条款复杂，需“自动填充+合规校验”。</td></tr><tr><td><strong>Oracle CX</strong></td><td>1. 合同与ERP/CRM深度集成，自动关联“报价→订单→库存”； 2. 内置“合规审查引擎”，自动检查“条款完整性”； 3. 合同签署后自动触发“采购计划/生产订单”。</td><td>适合<strong>大型企业</strong>：合同需联动后端业务，避免“合同与执行脱节”。</td></tr><tr><td><strong>Pipedrive</strong></td><td>1. 智能文档工具自动生成合同（基于报价单）； 2. AI辅助“条款审核”（如“违约条款是否明确”）； 3. 合同签署后自动同步订单系统。</td><td>适合<strong>轻量合同场景</strong>：合同条款简单，需快速签署。</td></tr><tr><td><strong>Bitrix24</strong></td><td>1. 审批流程自动化（如“合同需财务+法务审批”）； 2. 电子文档存储（支持“权限控制”，避免泄露）； 3. 合同到期自动提醒。</td><td>适合<strong>注重“内部审批+文档安全”的企业</strong>：合同需多部门确认。</td></tr><tr><td><strong>神州云动</strong></td><td>1. 销售合同管理（关联客户/报价/订单）； 2. 目标制定+业务督导，确保“合同条款落地”； 3. 自动生成“合同赢单率报表”，分析签约效率。</td><td>适合<strong>高签约量企业</strong>：需“批量管理合同+跟踪执行”。</td></tr><tr><td><strong>探马SCRM</strong></td><td>1. 合同审批流程自定义（如“金额&gt;5万需校长审批”）； 2. 客户SOP提醒“签约环节”（如“客户犹豫时，发成功案例”）； 3. 合同关联“微信聊天记录”，追溯谈判过程。</td><td>适合<strong>微信生态企业</strong>：合同谈判在微信，需“边聊边签”。</td></tr></tbody></table><p><strong>模块总结</strong>：</p><ul><li>复杂合同选超兔；ERP联动选Oracle；微信生态选探马；文档安全选Bitrix24；轻量签署选Pipedrive。</li></ul><h3>（五）合同订单：从“记录订单”到“闭环执行”的全链路化</h3><p>合同订单的核心是“联动后端业务，确保交付与回款”，需覆盖“多业务模型支持”“执行流程自动化”“财务管控”三大维度。</p><table><thead><tr><th>品牌</th><th>业务模型支持</th><th>执行与财务能力</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>1. 覆盖“服务/实物/租赁/维修/套餐/租售一体”等10+业务模型； 2. 支持“总分订单”（如“总合同下的子订单”）、“爆炸图下单”（复杂产品拆解）。</td><td>1. 订单锁库（避免超卖）； 2. 自动生成“采购计划→采购单→供应商直发”； 3. 应收/开票/回款三角联动，控制信用风险（如“客户超账期，限制发货”）。</td></tr><tr><td><strong>Oracle CX</strong></td><td>1. 支持“线索→订单→执行→回款”端到端自动化； 2. 覆盖“制造/零售/金融”多行业，支持“多币种/多语言”。</td><td>1. 订单与ERP库存/生产联动，实时跟踪“生产进度→发货→交付”； 2. 自动计算“应收款+账期”，提醒“催款”。</td></tr><tr><td><strong>Pipedrive</strong></td><td>1. 支持“标准订单/批发订单/重复订单”； 2. 与电商平台（如Shopify）联动，实时同步订单状态。</td><td>1. 订单自动创建（基于报价单）； 2. 支付跟踪（与Stripe/PayPal集成）。</td></tr><tr><td><strong>Bitrix24</strong></td><td>1. 集成“在线商店”，支持“店面销售单/外卖单”； 2. 支持“多语言/多币种”，覆盖跨境业务。</td><td>1. 订单关联客户信息，自动同步库存； 2. 订单生成后自动提醒“发货/收款”。</td></tr><tr><td><strong>神州云动</strong></td><td>1. 合同订单关联“销售流程”，追溯“线索→跟进→签约→订单”； 2. 支持“维修工单/外勤工单”，覆盖服务型业务。</td><td>1. 合同回款跟踪（关联发票/付款）； 2. 自动生成“订单销售报表”，分析产品销量。</td></tr><tr><td><strong>探马SCRM</strong></td><td>1. 支持“微信订单”（如小程序下单→合同签署→发货）； 2. 关联“客户微信轨迹”，跟踪“订单来源”（如“朋友圈广告→下单”）。</td><td>1. 订单与微信支付联动，自动确认“收款”； 2. 订单状态提醒（如“发货后通知客户”）。</td></tr></tbody></table><p><strong>模块总结</strong>：</p><ul><li>复杂业务选超兔；ERP联动选Oracle；跨境业务选Bitrix24；微信订单选探马；轻量电商选Pipedrive。</li></ul><h2>三、综合能力雷达图：谁更符合你的需求？</h2><p>我们选取<strong>复杂场景支持、协作效率、销售自动化、社交化适配、ERP集成、成本性价比</strong>六大核心指标（1 - 5分，越高越好），绘制雷达图如下：</p><table><thead><tr><th>指标</th><th>超兔一体云</th><th>Oracle CX</th><th>Pipedrive</th><th>Bitrix24</th><th>神州云动</th><th>探马SCRM</th></tr></thead><tbody><tr><td>复杂场景支持</td><td>5</td><td>4</td><td>2</td><td>3</td><td>3</td><td>2</td></tr><tr><td>协作效率</td><td>4</td><td>3</td><td>3</td><td>4</td><td>3</td><td>3</td></tr><tr><td>销售自动化</td><td>4</td><td>5</td><td>3</td><td>3</td><td>4</td><td>3</td></tr><tr><td>社交化适配</td><td>2</td><td>1</td><td>2</td><td>2</td><td>2</td><td>5</td></tr><tr><td>ERP集成</td><td>2</td><td>5</td><td>1</td><td>2</td><td>2</td><td>1</td></tr><tr><td>成本性价比</td><td>5</td><td>1</td><td>3</td><td>4</td><td>3</td><td>3</td></tr></tbody></table><p>从雷达图的各项指标得分可以看出：</p><ul><li><strong>超兔一体云</strong>：在复杂场景支持和成本性价比方面表现出色，拥有丰富的跟单模型和订单逻辑，能满足企业多样化业务需求，同时低成本的客制化能力也为中小企业节省了成本。适合项目型企业以及对成本较为敏感、业务场景复杂的中小企业。</li><li><strong>Oracle CX</strong>：在销售自动化和ERP集成方面优势明显，与ERP深度集成能实现业务流程的高效自动化，适合大型企业尤其是制造、金融等行业，需要与后端业务紧密联动并严格合规的企业。</li><li><strong>Pipedrive</strong>：在轻量销售流程管理上表现良好，销售管道可视化和移动端便捷性使其能快速推进销售线索转化，适合中小交易型企业。</li><li><strong>Bitrix24</strong>：协作效率和成本性价比都有不错的得分，免费版能覆盖基础协作需求，跨部门协作功能强大，适合注重内部协同的中小企业。</li><li><strong>神州云动</strong>：借助AI实现销售流程自动化，在高线索量分配和精准报价等方面有独特优势，适合高线索量、高客单价的企业。</li><li><strong>探马SCRM</strong>：社交化适配能力突出，紧密结合微信生态，能实现边聊边跟进、边聊边签约，适合依赖微信生态的企业。</li></ul><p>企业在选择CRM系统时，应根据自身的行业特点、业务规模、发展需求以及预算等因素综合考虑，选择最能解决自身痛点、提升业务效率的CRM系统。</p>]]></description></item><item>    <title><![CDATA[2026年了，为什么我建议你放弃“纯原生”开发？ 程序员老刘 ]]></title>    <link>https://segmentfault.com/a/1190000047609112</link>    <guid>https://segmentfault.com/a/1190000047609112</guid>    <pubDate>2026-02-13 11:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>大家好，我是老刘</strong></p><p>昨天有个老朋友找我喝酒，哭丧着脸。</p><p>这哥们是个五年的Android开发，技术那是没得说。</p><p>能独立完成复杂的系统模块，优化过千万级日活的App。</p><p>最近去面试一家大厂挂了。</p><p>面试官就问了一句：</p><p>“如果让你带队把这个模块迁移到鸿蒙和 iOS，除了重写三遍，你有什么低成本方案？”</p><p>他愣住了，他引以为傲的原生深度，在降本增效的大潮面前，就变成了一颗昂贵的螺丝钉。</p><p>2026 年，不知道有多少朋友又开始了或者将要开始投简历、面试的过程。</p><p>老刘借着这篇文章聊聊原生开发、跨平台开发在AI时代的客户端开发领域的生态位，以及作为开发者，我们该如何优化我们的技能树，以适应这个快速变化的行业。</p><hr/><h2>原生不是死了，而是下沉了</h2><p>别误会，我不是说原生技术要消失。</p><p>它只是下沉了，沉成了基础设施，就有点像汇编语言一样。</p><p>你看现在的 App 架构是啥样的？</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609114" alt="Mermaid Diagram" title="Mermaid Diagram"/></p><p>如果你只守着那 10% 的原生胶水层，你的职业道路只会越走越窄。</p><p>最后变成公司里那个维护遗留代码的守门人，每天对着一堆陈年老代码叹气。</p><p>新人都在用新架构写新业务，你在角落里修改哪些该死的兼容性 Bug。</p><hr/><h2>Flutter vs 原生</h2><p>这里老刘不想讨论技术参数的差异，而是想站在开发者的角度，谈谈聚焦不同的技术栈对我们有什么影响。</p><p>很多坚持“纯原生”的兄弟，理由往往只有一个：</p><p>“原生体验更好，性能更强，跨平台总觉得有点卡。”</p><p>听着挺有道理，但在 2026 年，这更像是一个给自己寻找舒适区的借口。</p><p><strong>现在的跨平台技术，早已经不是当年的“缝合怪”了。</strong></p><p>以 Flutter 为例， Impeller 引擎的成熟，让它的渲染性能在大多数业务场景下，已经做到了和原生毫无差异的程度。</p><p>你还在纠结那个滚动条的阻尼感是不是差了 0.01 秒，老板在纠结为什么隔壁组用一套代码已经上线了三个平台，而你还在为 iOS 的一个布局错位调了一下午。</p><p><strong>未来的核心竞争力，是端抽象的能力</strong></p><p>当你站在跨平台的角度进行开发，你思考问题的维度就变了：</p><ul><li>你不再是“那个写 Android 的”，你是“那个能搞定全端交付的”。</li><li>你不再关心某个系统的私有 API，你开始关心如何设计一套通用的组件库，让业务逻辑在各个端之间无缝流动。</li></ul><p>这种“端抽象”的能力，才是跨平台开发者真正的护城河。</p><hr/><h2>跨平台（Flutter）不是加分项，而是及格线</h2><p>以前面试，你会 Flutter是加分项。</p><p>现在那是及格线。</p><p>看看现在的终端环境，乱成一锅粥了：Android、iOS、鸿蒙、web、桌面端...</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609115" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>你指望老板招 5 拨人去维护 5 套代码？</p><p>老板根本不在乎你用原生还是Flutter，老板只在乎能不能把团队裁到只有一个人，然后你把所有的工作搞定。</p><p>只会纯原生等于把自己锁死在一个平台上。</p><p>一旦那个平台没落了，或者公司业务调整不做了。</p><p>想想当年的塞班开发，甚至前几年的 Windows Phone 开发，是不是背脊发凉？</p><hr/><h2>你是不是那个解决问题的人？</h2><p>其实不管是团队的技术方案选择，还是开发者个人技能树的升级，技术栈的选择从来都不仅仅是技术参数的对比。</p><p><strong>站在团队的角度</strong>，老刘当年选择Flutter的原因有以下几个方面：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047609116" alt="Mermaid Diagram" title="Mermaid Diagram" loading="lazy"/></p><p><strong>站在开发者个人的角度</strong>，你需要保证自己的技能树中点出来当前主流的技术方向。</p><p>我不是说一定要学Flutter或者某一个技术，而是你要知道现在在行业内大家都在用哪些技术。</p><p>而被大量企业和团队选择的技术栈大概率是当前最能解决实战问题的，或者是最具备性价比的选项。</p><p>为啥要做从众的选择？</p><p>因为商业社会你不能做那个掌握屠龙技的人，而要与做那个解决问题的人。</p><p>那什么样的技术路线能解决问题呢？</p><p>并不是你钻研最深入的，看起来参数最好的，而是你的同事都会用的。</p><p>不仅仅是你的同事，还是那些LLM比如Claude、ChatGPT甚至Kimi都能玩得转的。</p><hr/><h2>换个活法，路宽得很</h2><p>我建议你放弃纯原生，不是让你忘掉基础。</p><p>而是让你放弃那种画地为牢的心态。</p><p>不要做一个只会砌墙的泥瓦匠，要做一个懂结构的建筑师。</p><p>未来属于那些<strong>站在原生肩膀上，用跨平台和 AI 俯视业务</strong>的开发者。</p><p>别让技术栈限制了你的想象力。</p><p>更别让纯原生限制了你的身价。</p><p>共勉。</p><blockquote><p>🤝 如果看到这里的同学对客户端开发或者Flutter开发感兴趣，欢迎联系老刘，我们互相学习。</p><p>🎁 点击免费领老刘整理的《Flutter开发手册》，覆盖90%应用开发场景。</p><p>🚀 <a href="https://link.segmentfault.com/?enc=ahdlqrs3Si7uWanxwfoy4Q%3D%3D.Z3BPuOl2eJeCh26iwskw2f7728sC9zy1jPZuP0Iw4RJjt85xa6dyUkZKalw1T7pbFiWStSfnj9oXW9iDWA6%2FTfNyn5RAkeHiVP9%2BagNaUhoF271ZFWmqM%2F0Bf5ceiuwiyOkQ%2F8sPKrurI1Z2Yeo9s5SS5RW9rGtMqM35pe1%2Bmc%2BmXi75wMppcBA8Z56q%2BF30TodtZyu2F%2F8YOLKreKyMrsVT%2F5%2BvxLIQoSn8T%2BeX%2FLo6d42leVT59G3dzM9gy1eHFUcbV%2F2PRfXhsHMCXOg%2Ffg%3D%3D" rel="nofollow" target="_blank">覆盖90%开发场景的《Flutter开发手册》</a></p></blockquote><blockquote>📂 老刘也把自己历史文章整理在GitHub仓库里，方便大家查阅。<br/>🔗 <a href="https://link.segmentfault.com/?enc=UZ8RtxYs4jBiFv1hSjRbzw%3D%3D.4gVjwPkWQDKbTl%2F29bpWXN1jMiA8k1o6pBnsKl6%2B7QRgmAk8wxVTA0k%2FB3pOK44a" rel="nofollow" target="_blank">https://github.com/lzt-code/blog</a></blockquote>]]></description></item><item>    <title><![CDATA[macOS Sequoia 15.7.4 (24G517) 正式版 ISO、IPSW、PKG 下载 ]]></title>    <link>https://segmentfault.com/a/1190000047608706</link>    <guid>https://segmentfault.com/a/1190000047608706</guid>    <pubDate>2026-02-13 10:07:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>macOS Sequoia 15.7.4 (24G517) 正式版 ISO、IPSW、PKG 下载</p><p>iPhone 镜像、Safari 浏览器重大更新和 Apple Intelligence 等众多全新功能令 Mac 使用体验再升级</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=2%2BCoIv%2FObqFtqwbo2vSXvw%3D%3D.tR3mNsnSTK2LnfaBXQ5ZWJEupnyFPKnz8OUk4N9t%2BDLuJejCM2oHr4FZN%2BpiBL2U" rel="nofollow" target="_blank">https://sysin.org/blog/macOS-Sequoia/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=AfntmeqELtX8nQLzUzIf9Q%3D%3D.apNr13LLSLcQtfmylwubwAQqI8TdyBX%2BOkkisYSdFUY%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>2026 年 2 月 12 日凌晨，Apple 发布 iOS/iPadOS/macOS/watchOS/tvOS/visonOS 全平台 26.3 版本更新。macOS Tahoe 26.3 此次为常规问题修复和安全更新。同时为不能更新最新系统的 Mac 发布了 macOS Sequoia 15.7.4 和 macOS Sonoma 14.8.4 软件更新，此类更新通常为安全修复和常规问题修复。</p><p>macOS Sequoia 将 Mac 生产力与智能化提升至全新高度</p><p>iPhone 镜像、Safari 浏览器重大更新和 Apple Intelligence 等众多全新功能令 Mac 使用体验再升级</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608708" alt="MacBook Air 展示 iPhone 镜像功能，iMac 展示 Safari 浏览器 Highlights 功能，MacBook Pro 展示 Apple 智能功能。" title="MacBook Air 展示 iPhone 镜像功能，iMac 展示 Safari 浏览器 Highlights 功能，MacBook Pro 展示 Apple 智能功能。"/></p><p>macOS Sequoia 以 iPhone 镜像拓展连续互通功能、新增生产力与视频会议工具，并为即将推出的多款游戏带来更具沉浸感的游戏体验。</p><h2>macOS Sequoia 更新摘要</h2><p>macOS Sequoia 15.7 及更新版本，如无特殊说明皆为安全更新或常规错误修复，不再赘述。</p><h2>macOS Sequoia 硬件兼容性列表</h2><p>笔者提示：“Apple Intelligence” (包括由其驱动的音频转写功能) 要求 <a href="https://link.segmentfault.com/?enc=veYLOymiHjtZgr6DifMB4Q%3D%3D.%2FGTLg17VDsE6WZzTe11XEynbNKRPcv7%2FHIUnqV%2FOJIKzisG%2BM%2FJMynK1avDYq9oT" rel="nofollow" target="_blank">搭载 Apple 芯片的 Mac 电脑</a>。</p><p>看看你的 Mac 是否能用 macOS Sequoia</p><p><a href="https://link.segmentfault.com/?enc=Tk9qpJ6%2BFKRzs00vkrW2tw%3D%3D.3gYKzvf7P2v%2FCKM5l8QzgGYAjfGulMcFTLbwlWiDx64%3D" rel="nofollow" target="_blank">进一步了解 Mac&gt;</a></p><ul><li><strong>MacBook Air</strong> 2020 and later <a href="https://link.segmentfault.com/?enc=REBcAes0yOQDkZkIM3f4UQ%3D%3D.2grhSI0gOlV2v5bXb741R7lhw5HaV10S7%2FetqbeMQNo73wf%2BRVFg%2BzFeuxAwdo4q" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>MacBook Pro</strong> 2018 and later <a href="https://link.segmentfault.com/?enc=xn%2FVV9StWKbNcmz60Fj6CA%3D%3D.AL3AnUBtOwVeWwb1SM5b5MiL13PLcAs3Nn%2FHJ4vjO722MpcrRt9jdAnTOhxp2i8M" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>Mac mini</strong> 2018 and later <a href="https://link.segmentfault.com/?enc=nKCaW6l7CI4iQOEIrucRqQ%3D%3D.y85T9T8dn6xKPNWWxV95d3%2FPA1w5z81zz37Q8KSkF4fZCiquEe5P7O8evNPKkOS4" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>Mac Studio</strong> 2022 <a href="https://link.segmentfault.com/?enc=Jysm6quldq0vc0NqGW3G9Q%3D%3D.vV0YMWa5TVaAg8ugdKKZsDzpEEKyl6ju0io6muA0xYZu%2BjJ7SIidC2huA80HLyEs" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>Mac Pro</strong> 2019 and later <a href="https://link.segmentfault.com/?enc=pbYfW9PVBYAbU8BZehivDg%3D%3D.TUVDOwaf65E2jzp1wQsbPKzZxTxuxHrFojlgxixGO8vlLcUitoBBQaVy1taAlJTV" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>iMac</strong> 2019 and later <a href="https://link.segmentfault.com/?enc=0rSeODpXoi1LA8b7D1b%2B7g%3D%3D.X0U2i%2Bod1OvvPaBzoiUeo%2ByEwiqkptFtyz1XpZV3U9Mr8euOTwrxHooQmJwlhN3s" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>iMac Pro</strong> 2017 and later <a href="https://link.segmentfault.com/?enc=dtRZ5eI%2B8hlWmBFsls%2BN3w%3D%3D.bosZ9H5L6VUCruLfpTU1oyRwqfiH0JgrPSDIMTTyNrosHCekyjHP%2Ft8to1%2FpWCJg" rel="nofollow" target="_blank">进一步了解 &gt;</a></li></ul><p>如果你的 Mac 不在兼容性列表，参看：<a href="https://link.segmentfault.com/?enc=4tgk4OnmJMUqt0bRcM40NA%3D%3D.l6nhdUgB7wY08S9RVpPSZWjxqJ1o1tj5VWVGjjkVUt7Aihl1v1wGZ82vuS5YkqnvYdr6IHtP%2BoUMxV6ElXhE0A%3D%3D" rel="nofollow" target="_blank">在不受支持的 Mac 上安装 macOS Sequoia (OpenCore Legacy Patcher v2.4.0)</a></p><h2>macOS Sequoia 版本历史</h2><p>Software Releases</p><ul><li>macOS Sequoia 15.7.4 (24G517) - 2026.02.11</li><li>macOS Sequoia 15.7.3 (24G419) - 2025.12.12</li><li>macOS Sequoia 15.7.2 (24G325) - 2025.11.03</li><li>macOS Sequoia 15.7.1 (24G231) - 2025.09.30</li><li>macOS Sequoia 15.7 (24G222) - 2025.09.15</li><li>macOS Sequoia 15.6.1 (24G90) - 2025.08.20</li><li>macOS Sequoia 15.6 (24G84) - 2025.07.30</li><li>macOS Sequoia 15.5 (24F74) - 2025.05.13</li><li>macOS Sequoia 15.4.1 (24E263) - 2025.04.16</li><li>macOS Sequoia 15.4 (24E248) - 2025.03.31</li><li>macOS Sequoia 15.3.2 (24D81 | 24D2082) - 2025.03.11</li><li>macOS Sequoia 15.3.1 (24D70) - 2025.02.10</li><li>macOS Sequoia 15.3 (24D60) - 2025.01.28</li><li>macOS Sequoia 15.2 (24C101) - 2024.12.11</li><li>macOS Sequoia 15.1.1 (24B91 | 24B2091) - 2024.11.19</li><li>macOS Sequoia 15.1 (24B2083) - 2024.10.30 (M4 Only)</li><li>macOS Sequoia 15.1 (24B83) - 2024.10.29</li><li>macOS Sequoia 15.0.1 (24A348) - 2024.10.03</li><li>macOS Sequoia 15.0 (24A335) - 2024.09.16</li></ul><h2>下载 macOS Sequoia</h2><p>💡 <a href="https://link.segmentfault.com/?enc=Yf0LN9U88EIw14wJ%2FV7YOg%3D%3D.nJDUmK06%2F7Sib9OogmMKoPCeYMY6%2BwjfDVjF6zQuN00%3D" rel="nofollow" target="_blank">如何校验本站下载的文件的完整性</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044953906" alt="macOS Sequoia" title="macOS Sequoia" loading="lazy"/></p><h3>(1) ISO 格式软件包 (推荐)</h3><blockquote><p>本站原创可引导映像，可以在当前系统中安装或者升级，可以通过 USB 存储引导安装，也可以用于虚拟机安装。</p><p>此版本更多介绍请参看：<a href="https://link.segmentfault.com/?enc=8AL8qt2d91cxHTTlqKpQbQ%3D%3D.%2FUdYT584pqhHO%2FY0Y5jrpWh8RzBIOI5yFibMHfriocbxCuINMgu0hWsvxXT4emWi" rel="nofollow" target="_blank">macOS Sequoia 15 Boot ISO 原版可引导映像下载</a></p></blockquote><ul><li>macOS Sequoia 15.7.4 (24G517) - 2026.02.11</li><li>macOS Sequoia 15.7.3 (24G419) - 2025.12.12</li><li>macOS Sequoia 15.7.2 (24G325) - 2025.11.03</li><li>macOS Sequoia 15.7.1 (24G231) - 2025.09.30</li><li>macOS Sequoia 15.7 (24G222) - 2025.09.15</li><li>macOS Sequoia 15.6.1 (24G90) - 2025.08.20</li><li>macOS Sequoia 15.6 (24G84) - 2025.07.30</li><li>macOS Sequoia 15.5 (24F74) - 2025.05.13</li><li>macOS Sequoia 15.4.1 (24E263) - 2025.04.16</li><li>macOS Sequoia 15.4 (24E248) - 2025.03.31</li><li>macOS Sequoia 15.3.2 (24D81 | 24D2082) - 2025.03.11</li><li>macOS Sequoia 15.3.1 (24D70) - 2025.02.10</li><li>macOS Sequoia 15.3 (24D60) - 2025.01.28</li><li>macOS Sequoia 15.2 (24C101) - 2024.12.11</li><li>macOS Sequoia 15.1.1 (24B91 | 24B2091) - 2024.11.19</li><li>macOS Sequoia 15.1 (24B83) - 2024.10.29</li><li>macOS Sequoia 15.0.1 (24A348) - 2024.10.03</li><li>macOS Sequoia 15.0 (24A335) - 2024.09.16</li><li><strong>下载地址</strong>：<a href="https://link.segmentfault.com/?enc=kbxhHIWOG0qZLHzVA0v2tA%3D%3D.T8LlXYLc%2FCfSVaD1xnJruIIk9Jivqomf2P4F6qoAQLwfNGVW7BZuxqQSmWk2irAd" rel="nofollow" target="_blank">https://sysin.org/blog/macOS-Sequoia/</a></li></ul><p>参看：<a href="https://link.segmentfault.com/?enc=sw9jixIbXsS4Y4xk0YfDJg%3D%3D.edFmpA%2FjKIde1khVQk75cLD4q74Q3xFpp5f%2FHGUfV7AlYeWiBYoXKnJUS0IRuMoj" rel="nofollow" target="_blank">如何在 Mac 和虚拟机上安装 macOS Sequoia、macOS Sonoma 和 macOS Ventura</a></p><h3>(2) PKG 格式软件包</h3><blockquote>该格式软件包双击运行后将自动安装在 <code>/Applications</code> 下。</blockquote><ul><li>macOS Sequoia 15.7.4 (24G517) - 2026.02.11</li><li>macOS Sequoia 15.7.3 (24G419) - 2025.12.12</li><li>macOS Sequoia 15.7.2 (24G325) - 2025.11.03</li><li>macOS Sequoia 15.7.1 (24G231) - 2025.09.30</li><li>macOS Sequoia 15.7 (24G222) - 2025.09.15</li><li>macOS Sequoia 15.6.1 (24G90) - 2025.08.20</li><li>macOS Sequoia 15.6 (24G84) - 2025.07.30</li><li>macOS Sequoia 15.5 (24F74) - 2025.05.13</li><li>macOS Sequoia 15.4.1 (24E263) - 2025.04.16</li><li>macOS Sequoia 15.4 (24E248) - 2025.03.31</li><li>macOS Sequoia 15.3.2 (24D81 | 24D2082) - 2025.03.11</li><li>macOS Sequoia 15.3.1 (24D70) - 2025.02.10</li><li>macOS Sequoia 15.3 (24D60) - 2025.01.28</li><li>macOS Sequoia 15.2 (24C101) - 2024.12.11</li><li>macOS Sequoia 15.1.1 (24B91 | 24B2091) - 2024.11.19</li><li>macOS Sequoia 15.1 (24B2083) - 2024.10.30 (M4 Only)</li><li>macOS Sequoia 15.1 (24B83) - 2024.10.29</li><li>macOS Sequoia 15.0.1 (24A348) - 2024.10.03</li><li>macOS Sequoia 15.0 (24A335) - 2024.09.16</li><li><strong>下载地址</strong>：<a href="https://link.segmentfault.com/?enc=sin%2F18uJQ4zMLkddhF3zgw%3D%3D.whRcRT8UigT5T3RWVxguIfrNKl9yda2YexXVeKoHuWAOPxrzIiGxH%2FSbyofnlEo9" rel="nofollow" target="_blank">https://sysin.org/blog/macOS-Sequoia/</a></li></ul><h3>(3) IPSW 固件 (Apple 芯片 Mac 专用)</h3><blockquote>IPSW 格式为搭载 Apple 芯片的 Mac 专用映像，其他格式通用。</blockquote><p>适用于：<a href="https://link.segmentfault.com/?enc=%2FYtOpgL5urv9PEGhKtho3w%3D%3D.H4nrraCROz8pKZXq%2FQqm7AJDUG4izBatVRnFw%2Bc2sv0TvslbHGVNmxtl7uKZVUWN" rel="nofollow" target="_blank">搭载 Apple 芯片的 Mac 电脑</a></p><p>参看：<a href="https://link.segmentfault.com/?enc=lext976Ra1c4Fr0Gre4ENQ%3D%3D.TdXL9Lz7M%2F3ndt1e%2BlV5elAYs1erJUVjF2B4L1PY%2BKxVotYkTiERkbCuWxzRJ4Vg" rel="nofollow" target="_blank">使用 DFU 模式修复或恢复 Mac 固件</a></p><ul><li>macOS Sequoia 15.6.1 (24G90) - 2025.08.20</li><li>macOS Sequoia 15.6 (24G84) - 2025.07.30</li><li>macOS Sequoia 15.5 (24F74) - 2025.05.13</li><li>macOS Sequoia 15.4.1 (24E263) - 2025.04.16</li><li>macOS Sequoia 15.4 (24E248) - 2025.03.31</li><li>macOS Sequoia 15.3.2 (24D81 | 24D2082) - 2025.03.11</li><li>macOS Sequoia 15.3.1 (24D70) - 2025.02.10</li><li>macOS Sequoia 15.3 (24D60) - 2025.01.28</li><li>macOS Sequoia 15.2 (24C101) - 2024.12.11</li><li>macOS Sequoia 15.1.1 (24B91 | 24B2091) - 2024.11.19</li><li>macOS Sequoia 15.1 (24B2083) - 2024.10.30 (M4 Only)</li><li>macOS Sequoia 15.1 (24B83) - 2024.10.29</li><li>macOS Sequoia 15.0.1 (24A348) - 2024.10.03</li><li>macOS Sequoia 15.0 (24A335) - 2024.09.16</li><li><strong>下载地址</strong>：<a href="https://link.segmentfault.com/?enc=bzW1FVMdRHzmVtF1ankeOg%3D%3D.tRyRb%2B3MASaRT7swq5BfGyK5Ysd%2BF1%2BahARQFDPebDCyU6PkFfKJxnJOtoGKTX0H" rel="nofollow" target="_blank">https://sysin.org/blog/macOS-Sequoia/</a></li></ul><h3>(4) App Store 链接</h3><pre><code class="txt">https://apps.apple.com/app/macos-sequoia/id6596773750</code></pre><p>或者打开 App Store 搜索 “macOS Sequoia” 即可下载（下载的是当前最新版）。</p><h2>适用的 VMware 软件下载链接</h2><p>建议在以下版本的 VMware 软件中运行（Linux OVF 无需本站定制版可以正常运行，macOS 虚拟化如果不是 Mac 必须使用定制版才能运行，Windows OVF 需要定制版才能启用完整功能）：</p><ul><li><p>VMware vSphere：</p><ul><li>VMware <a href="https://link.segmentfault.com/?enc=iBK6HN%2FMIgFaSateIdo97Q%3D%3D.NiRkeP%2FXWNMETy%2F3px1z6Vgia9PyyRIfO%2F7tf%2Fq%2FK68nJQTFtCo%2B%2BNA%2B%2BWRAJULO" rel="nofollow" target="_blank">ESXi 9</a> or <a href="https://link.segmentfault.com/?enc=SnGo1BNE4u2WtVtnD8HV0w%3D%3D.qf2gqHsdXjoZV%2Bk210UOUEOT8SThn32WEOGsFavNGjg6%2FaAigkkeUO7X2r8zYMvJ" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=7Z48FE1aiyNYHmCsf99yMQ%3D%3D.4w3I0O6%2F7FRr6ulew3jrcFO2cu7%2F7jHZoIQWRQIBeMXR%2FYVOetg%2BOmOyLdbakcCn" rel="nofollow" target="_blank">vCenter Server 9</a> &amp; <a href="https://link.segmentfault.com/?enc=YsT560nTJrE%2BnnxuC7ET%2Fw%3D%3D.dPo%2BQy%2Fr%2BdFbvbuqdUGtF8TqFKIUA%2Fw%2FPKEC1Pg6zoQeCUygI7LIoosVIF3hYWfhQmhV5i1p8C2pTcflRccHxA%3D%3D" rel="nofollow" target="_blank">VCF Operations 9</a></li><li>VMware <a href="https://link.segmentfault.com/?enc=IX6PRrUTE0J3eclwdIfI%2BA%3D%3D.7X0KpaDJ9aqXE0qWkxBW%2Fzhshlm4xdn7nRKUl0HWaz21T0hEihSmDNNOmIyvYjgc" rel="nofollow" target="_blank">ESXi 8</a> or <a href="https://link.segmentfault.com/?enc=T8CZIv28d%2F7HluS%2Fvc6QDQ%3D%3D.gdF9p8Fh1BDit0gnfENDVBLi%2Fs9q%2FfE7s7wb%2FVJqyVOT9J%2Fe0GmWzH21YW1VeYLt" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=Xzw0qd2ElsyAeWZWk5onkg%3D%3D.UKZZQcZqYCZjeXgb7ct01oym%2FGnrWZaUw8T4W6%2Fd4%2BPD9zLs%2Feh%2FAIinT8ofNnLH" rel="nofollow" target="_blank">vCenter Server 8</a></li><li>VMware <a href="https://link.segmentfault.com/?enc=bS7juQmfSwrw4lR3A6O2gQ%3D%3D.oOpollgBCN5dazlyaQqIyRltg0HUBthtncOX8d5xdE9zkt%2FN%2B%2BcZBd12KDmJJAUI" rel="nofollow" target="_blank">ESXi 7</a> or <a href="https://link.segmentfault.com/?enc=BGE97qrJZRxI5xdOkD5MYw%3D%3D.oqbbv8QS8VdN1ng4AKWRWYHQLxdfSGs4Ii0G0283BSlT%2B2xsr%2BfoyBz6q7cJFOrW" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=C70gS9SGmg9rB8hI6%2BPVUQ%3D%3D.MVEQD%2BTGd%2B6WAOUlGVzjlQuxVfms0lALo9dVmb%2FZZ4crGzcjlCAKyQLWW2gYl2%2FB" rel="nofollow" target="_blank">vCenter Server 7</a></li></ul></li><li>macOS：<a href="https://link.segmentfault.com/?enc=Q1sFc5C6qVdZvhTNsUe1Fg%3D%3D.bQTZBUAE0smGl9Vs8N5XntyRKRyzrtHLAil7rN%2FEYjFGGDWaOj5Rblrhy%2BR5rq2k" rel="nofollow" target="_blank">VMware Fusion</a></li><li>Linux：<a href="https://link.segmentfault.com/?enc=9ADWYz6SApZSwsecMozE6A%3D%3D.SiEilgV8%2BvbpZ9xd4aE%2BY3HiWisu7xfFA65BAdbhPWneSgEdVKpqLLTnkijsJNqK%2B8vYURBOgQB5KV7FrJv4Iw%3D%3D" rel="nofollow" target="_blank">VMware Workstation for Linux</a></li><li>Windows：<a href="https://link.segmentfault.com/?enc=tQDIwt%2F%2FqTBzBNWxg0OYhA%3D%3D.JjT9he%2BO%2Fkjn8e3LbdZ68gkcbyQbEGETJbONU1CE22PdDKM5AQDlAoZWV%2F3mGBu3vrkR7OKCtjk0Udscn781%2Bg%3D%3D" rel="nofollow" target="_blank">VMware Workstation for Windows</a></li></ul><p>macOS Sequoia 虚拟化解决方案，请参看：<a href="https://link.segmentfault.com/?enc=BhA2tcBWjvC6lmpCv2K%2FeA%3D%3D.VHIJwdz9ibCW4O2KPnUUSJ6YRadCsgncKMIibe5qixF1E4iJda0YxodzZw3doTtP" rel="nofollow" target="_blank">macOS 15 Blank OVF - macOS Sequoia 虚拟化解决方案</a></p><h2>如何创建可引导的 macOS 安装器</h2><p>请访问：<a href="https://link.segmentfault.com/?enc=LnYwia5MOswd6qelQkXPSQ%3D%3D.nFPKmZR9JGCQ6hIwLy8WHW8T6DTMvMWgaDGUmRkWn3j%2FMAIgNU93ZCraPQVG%2F%2B8tjHAZiq07HZh45I5fZ%2FdJEw%3D%3D" rel="nofollow" target="_blank">如何创建可引导的 macOS 安装介质</a></p><p>更多：<a href="https://link.segmentfault.com/?enc=ic3RqY6pWVc6ntMV6AGUQg%3D%3D.G741F3%2BbCBQK4fqJnDjE3tvqrsKKmsGCAsnbCqLttOs%3D" rel="nofollow" target="_blank">macOS 下载汇总 (系统、应用和教程)</a></p>]]></description></item><item>    <title><![CDATA[7z2105 安装步骤详解（附压缩解压与文件关联设置） 小童童 ]]></title>    <link>https://segmentfault.com/a/1190000047608724</link>    <guid>https://segmentfault.com/a/1190000047608724</guid>    <pubDate>2026-02-13 10:06:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><p><code>7z2105(64位）</code>是 <strong>7-Zip 21.05 版本的 64 位安装包</strong>，这是个压缩解压工具，能打包成 7z、zip、rar 等格式，压缩率高、速度也快，解压大文件比系统自带的 winrar/压缩功能稳很多。</p><h2>一、准备工作</h2><ol><li><p><strong>下载安装包</strong>​</p><ul><li><strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=GKLn24029Uf6WG2vcCh1og%3D%3D.RFJ8BQaG%2FyZ32YTeGOqkICF6amEI7%2Fm7hzovc7VweyOTY5okVNLecHpwz4eC%2BYp0" rel="nofollow" title="https://pan.quark.cn/s/67c246cb79fc" target="_blank">https://pan.quark.cn/s/67c246cb79fc</a></li><li>文件名里的 “2105” 是版本号，“64位” 对应 64 位 Windows 系统（现在电脑基本都是 64 位）。</li></ul></li><li><p><strong>确认系统版本</strong>​</p><ul><li>必须是 64 位 Windows（Win7/Win10/Win11 都行），32 位系统要用 32 位安装包。</li></ul></li><li><p><strong>用管理员身份运行（推荐）</strong> ​</p><ul><li>右键安装包 → 选“以管理员身份运行”，防止权限不足装不上。</li></ul></li></ol><h2>二、安装步骤</h2><ol><li>双击 <code>7z2105(64位）.exe</code>运行（如果右键过了就直接双击）。</li><li>第一次打开会弹出“用户账户控制”提示 → 点  <strong>“是”</strong> 。</li><li>进入安装向导，选语言（默认 English，有的版本有中文）→ 点  <strong>“OK”</strong> 。</li><li>阅读许可协议 → 选 “I Agree” → 点  <strong>“Next”</strong> 。</li><li><p>选安装类型：</p><ul><li>默认是 “Install” 直接装到默认位置（<code>C:\Program Files\7-Zip</code>），新手直接点  <strong>“Install”</strong> ​ 就行；</li><li>想自己选位置就点 “Browse” 改路径（比如 D 盘）。</li></ul></li><li><p>选关联文件类型（重要）：</p><ul><li>建议勾上常用的：<code>.7z</code>、<code>.zip</code>、<code>.rar</code>、<code>.tar</code>等，这样以后双击这些格式的文件会用 7-Zip 打开。</li></ul></li><li>点  <strong>“Finish”</strong> ​ 完成安装。</li></ol><h2>三、首次使用与基本操作</h2><ol><li>安装完，右键任意文件或文件夹，会看到多出 “7-Zip” 菜单。</li><li><strong>压缩</strong>：右键文件 → 7-Zip → “添加到压缩包” → 选格式（7z 压缩率高，zip 兼容性好）→ 点 “确定”。</li><li><strong>解压</strong>：右键压缩包 → 7-Zip → “解压到当前文件夹” 或 “解压到 xxx\”（自动建同名文件夹）。</li><li><strong>查看压缩包内容</strong>：右键压缩包 → 7-Zip → “打开压缩包”，不用完全解压就能看里面的文件。</li></ol><p>​</p>]]></description></item><item>    <title><![CDATA[虚拟办公室Gather重组：AI团队并入Figma；蚂蚁开源Ming-Flash-Omni 2.0：]]></title>    <link>https://segmentfault.com/a/1190000047608713</link>    <guid>https://segmentfault.com/a/1190000047608713</guid>    <pubDate>2026-02-13 10:05:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608715" alt="" title=""/></p><p><strong>开发者朋友们大家好：</strong></p><p>这里是 <strong>「RTE 开发者日报」</strong>，每天和大家一起看新闻、聊八卦。我们的社区编辑团队会整理分享 RTE（Real-Time Engagement） 领域内「有话题的<strong>技术</strong>」、「有亮点的<strong>产品</strong>」、「有思考的<strong>文章</strong>」、「有态度的<strong>观点</strong>」、「有看点的<strong>活动</strong>」，但内容仅代表编辑的个人观点，欢迎大家留言、跟帖、讨论。</p><p><em>本期编辑：@瓒an、@鲍勃</em></p><h2>01 有话题的技术</h2><p><strong>1、MOSS-TTS 亮相，支持精细发音控制与长音频生成，打造生产级语音基础模型</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608716" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608717" alt="" title="" loading="lazy"/></p><p>模思智能及 OpenMOSS 团队近日正式发布并开源了 MOSS-TTS Family 语音生成模型家族。这套工具链并未追求单一模型能力的堆叠，而是针对真实创作与交互需求，将语音生成拆解为五个核心模块：</p><ul><li><strong>MOSS-TTS</strong>：作为高保真语音生成基座，支持多语言、长音频及精确时长控制，在 Seed-TTS-eval 测试集上的音色相似度表现优异，可用于纪录片配音等场景。</li><li><strong>MOSS-TTSD</strong>：升级至 1.0 版本，专注于多说话人对话生成，支持 1-5 人自然对话节奏及最长 60 分钟的长对话，适用于播客、解说等复杂场景。</li><li><strong>MOSS-VoiceGenerator</strong>：通过指令设计音色与角色，实现情绪表达与表演状态的模拟。</li><li><strong>MOSS-SoundEffect</strong>：根据文本描述生成环境音与音效，补全声音场景。</li><li><strong>MOSS-TTS-Realtime</strong>：面向实时交互系统的流式 TTS 模型，低延迟特性适配语音助手等应用。</li></ul><p>技术层面，MOSS-TTS Family 基于高质量 Audio Tokenizer、大规模多样化数据及高效离散 Token 建模方法。其中，MOSS Audio Tokenizer 采用 1.6B 参数的纯 Transformer 架构，实现了高压缩比与语义-声学统一表征。<strong>为兼顾生产落地与学术研究，团队同时开源了两套互补架构：适合长文本生成与规模化部署的 Delay-Pattern (MossTTSDelay)，以及适配流式交互的 Global Latent + Local Transformer (MossTTSLocal)。</strong></p><p>此外，MOSS-TTS 系列已实现对壁仞科技壁砺™ 166M 的 Day-0 高性能推理支持，展现了对国产算力生态的兼容性。该模型家族的发布，试图通过覆盖<strong>「稳定生成、灵活设计、复杂对话、情境补全、实时交互」</strong>的全维度能力，为行业提供一套可直接接入工作流的声音创作生态闭环。</p><p>相关链接：<br/><a href="https://link.segmentfault.com/?enc=FS%2BZGiTYBd%2FFb1%2B%2FlQy%2BLQ%3D%3D.iZBxvZCTKaDByl0r665%2FO1Tm5m9S5zoogsYOe%2FQRcvw%3D" rel="nofollow" target="_blank">https://mosi.cn/models/moss-tts</a></p><p>GitHub: <br/><a href="https://link.segmentfault.com/?enc=m1wwFm5pIKiFEDtp072YMQ%3D%3D.K7NFv%2FbbPFyqAu1Nm2ZLhOndTejnAFK4d3TAN8LjYiCYiUrpyfdNycsfz25r3oAA" rel="nofollow" target="_blank">https://github.com/OpenMOSS/MOSS-TTS</a></p><p>( @机器之心 )</p><p><strong>2、智谱上线全新模型 GLM-5</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608718" alt="" title="" loading="lazy"/></p><p>刚刚，智谱正式上线并开源最新模型 GLM-5。</p><p>据介绍，GLM-5 是迈向 Agentic Engineering 的产物：在 Coding 与 Agent 能力上，其取得开源 SOTA 表现，在真实编程场景的使用体感逼近 Claude Opus 4.5，擅长复杂系统工程与长程 Agent 任务。</p><p>GLM-5 采用全新基座：<strong>参数规模从 355B（激活 32B）扩展至 744B（激活 40B），预训练数据从 23T 提升至 28.5T</strong>；构建全新的「Slime」框架，支持更大模型规模及更复杂的强化学习任务。</p><p>同时，<strong>GLM-5 还首次集成 DeepSeek Sparse Attention（稀疏注意力）</strong>，在维持长文本效果无损的同时，大幅降低模型部署成本。</p><p>具体表现上：</p><ul><li>在全球权威的 Artificial Analysis 榜单中，GLM-5 位居全球第四、开源第一。</li><li>GLM-5 在编程能力上实现了对齐 Claude Opus 4.5，在业内公认的主流基准测试中取得开源模型 SOTA。</li><li>GLM-5 在 SWE-bench-Verified 和 Terminal Bench 2.0 中分别获得 77.8 和 56.2 的开源模型最高分数，性能超过 Gemini 3 Pro。</li><li>GLM-5 在 BrowseComp（联网检索与信息理解）、MCP-Atlas（大规模端到端工具调用）和 τ²-Bench（复杂场景下自动代理的工具规划和执行）均取得最高表现。</li></ul><p>值得一提的是，目前 GLM-5 已完成与华为昇腾、摩尔线程、寒武纪、昆仑芯、沐曦、燧原、海光等国产算力平台的深度推理适配。通过底层算子优化与硬件加速，GLM-5 在国产芯片集群上已经实现高吞吐、低延迟的稳定运行。</p><p>即日起，GLM-5 在 Hugging Face 与 ModelScope 平台同步开源，模型权重遵循 MIT License。同时 GLM-5 已纳入 GLM Coding Plan Max 套餐。</p><p>GitHub: <br/><a href="https://link.segmentfault.com/?enc=n6gLm9WrxMuei%2FMg3lObyw%3D%3D.tL0H%2BVQ7rYrL1bGPuaHo6BU9oauUQyBSZebrmNrdrAEroB%2BMquosg5YU3M%2F%2Fd1Lp" rel="nofollow" target="_blank">https://github.com/zai-org/GLM-5</a></p><p>Hugging Face: <br/><a href="https://link.segmentfault.com/?enc=yjXXhC2%2Bn%2BcLhyIh5XaQqA%3D%3D.zBNIoG37ldvBnCcJNg0BsVfPSlceN%2BQec7qEKX%2BDRfjtJU25%2Bmql4Mhf9AuKOv3q" rel="nofollow" target="_blank">https://huggingface.co/zai-org/GLM-5</a></p><p>( @APPSO)</p><p><strong>3、蚂蚁开源全模态大模型 Ming-Flash-Omni 2.0</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608719" alt="" title="" loading="lazy"/></p><p>2 月 11 日，蚂蚁集团开源发布全模态大模型 Ming-Flash-Omni 2.0。</p><p>在多项公开基准测试中，Ming-Flash-Omni 2.0 在视觉语言理解、语音可控生成、图像生成与编辑等关键能力表现突出，部分指标超越 Gemini 2.5 Pro，成为开源全模态大模型性能新标杆。</p><p>据悉，Ming-Flash-Omni 2.0 也是<strong>业界首个全场景音频统一生成模型</strong>，可在同一条音轨中同时生成语音、环境音效与音乐。用户只需用自然语言下指令，即可对音色、语速、语调、音量、情绪与方言等进行精细控制。</p><p>模型在推理阶段实现了 3.1Hz 的极低推理帧率，实现了分钟级长音频的实时高保真生成，在推理效率与成本控制上保持业界领先。</p><p>值得一提的是，Ming-Flash-Omni 2.0 基于 Ling-2.0 架构（MoE，100B-A6B）训练，<strong>围绕「看得更准、听得更细、生成更稳」三大目标全面优化</strong>。</p><p>目前，Ming-Flash-Omni 2.0 的模型权重、推理代码已在 Hugging Face 等开源社区发布。用户也可通过蚂蚁百灵官方平台 Ling Studio 在线体验与调用。</p><p>Hugging Face：<br/><a href="https://link.segmentfault.com/?enc=MpJ%2F3zO2DC8MfR3nQ27LYw%3D%3D.oCLX9o1UWCnhix5XMD329TtiMcsoG14IXtBYywzB3f1hryBDA7oJWX9FQhWj8olz%2BY8b0sq%2FwQnDz5IqNE%2F1Aw%3D%3D" rel="nofollow" target="_blank">https://huggingface.co/inclusionAI/Ming-flash-omni-2.0</a></p><p>GitHub：<br/><a href="https://link.segmentfault.com/?enc=mUnD9FULMzQsgE8%2FLc0F7w%3D%3D.9whVXsmLs1xP%2FGRhJ4lhCQi1lGZJ50305c%2FrEiPo2d94zPcpEzFJUBaI%2FtDuodCx" rel="nofollow" target="_blank">https://github.com/inclusionAI/Ming</a></p><p>( @APPSO)</p><p><strong>4、Rokid Glasses 上线「自定义智能体」：支持接入 OpenClaw 与 DeepSeek 等私有大模型</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608720" alt="" title="" loading="lazy"/></p><p>Rokid 宣布其灵珠平台正式上线「自定义智能体」功能，允许 Rokid Glasses 用户通过标准的 SSE 接口，接入自定义后端服务。<strong>这一更新回应了极客用户对于接入私有大模型、本地 NAS 运行 AI 以及调用自定义 Python 脚本的需求，标志着该产品开始将 AI 助手的定义权交还给用户。</strong></p><p>此次更新打破了厂商定义能力的传统模式，支持接入包括开源社区热门的 OpenClaw 框架，以及 DeepSeek R1、Qwen3、Kimi K2.5 等私有部署模型。通过这种开放策略，Rokid Glasses 试图构建一种硬件负责感知（看与听）、后台负责思考与执行的 AR 形态。</p><p>接入自定义智能体（如 OpenClaw）为用户带来了三个维度的能力提升：</p><ul><li><strong>数据主权与隐私保护</strong>：通过接入运行在 Mac Mini 或家庭服务器上的本地 Agent，摄像头画面与私有知识库可实现本地闭环处理，无需数据上云。</li><li><strong>执行能力的扩展</strong>：区别于仅能对话的传统模型，OpenClaw 结合 ClawHub 技能生态，具备调用文件系统、操作浏览器、发送消息甚至执行 Python 脚本的行动力。</li><li><strong>模型基座的自由切换</strong>：用户可根据需求灵活切换后端模型，例如调用 Kimi K2.5 处理复杂推理，或使用本地量化版 Qwen 3 进行端侧交互。</li></ul><p>在具体部署方面，开发者需在 Rokid 开放平台注册并完成实名认证，随后在灵珠平台创建智能体并配置 URL 与鉴权信息。<strong>针对仅限个人使用的智能体，官方提示无需提交审核，直接通过个人账号调用即可，以避免误触提审流程。</strong></p><p><strong>鉴于接入门槛较高且涉及网络安全</strong>，Rokid 建议开发者使用阿里云或腾讯云等云服务器部署 OpenClaw，而不推荐在本地私人电脑使用内网穿透工具。配置完成后，用户可在 Rokid AI App 中调试，并通过眼镜端的语音指令或快捷指令唤起私有智能体。</p><p>灵珠平台：<br/><a href="https://link.segmentfault.com/?enc=sfsE8ThaALT0gmZs2zIUPg%3D%3D.ukX%2FIA4CKQ9f1BZ0La4v7rYCg6%2FAM5HBn%2FEkiFvv3EM%3D" rel="nofollow" target="_blank">https://ar.rokid.com/</a></p><p>GitHub: <br/><a href="https://link.segmentfault.com/?enc=ThmUWFYOrVXHbpsqb8ICww%3D%3D.kc8hTefSil6c3f96h3cu5Nc5e4R8RSbNvc9JpFxBuW9lgyuVe%2FII0DZJ3IWSQfq%2F" rel="nofollow" target="_blank">https://github.com/openclaw/openclaw</a></p><p>（@Rikid 乐奇、@IT 之家）</p><h2>02 有亮点的产品</h2><p><strong>1、Gather 宣布重组：AI 团队并入 Figma，核心业务转型独立盈利模式</strong></p><p>2026 年 2 月 9 日，Gather 发布了关于公司未来的战略更新。自成立以来，Gather 一直致力于通过「虚拟办公室」消除机会与连接的物理障碍，目前该产品已实现盈利并持续增长，服务于全球数千家企业。然而，公司管理层经过评估后认为，尽管现有产品具有长期价值和可持续性，但已不再符合最初设想的风投级增长模式。</p><p>为了确保核心使命的延续，Gather 宣布将采取两项关键举措来进行重组：</p><ul><li><strong>转型为独立企业</strong>：Gather 将剥离为一家独立的、非风投支持的实体，作为一家专注且盈利的中小企业运营。这一转变使公司能够摆脱对十亿美元级估值的追逐压力，转而全心全意服务核心客户，并开发用户真正期待的功能（例如「办公室宠物」功能的回归）。许多资深团队成员将留任，继续推动产品的开发与创新。</li><li><strong>AI 团队加入 Figma</strong>：Gather 的 AI 团队已达成协议加入 Figma。过去一年中，该团队一直在探索如何提升软件设计与构建工作的愉悦感和效率。在此过程中，他们发现与 Figma 团队在愿景和价值观上高度契合，因此决定加入 Figma 以继续推进这一领域的工作。</li></ul><p>对于现有客户，Gather 承诺服务将不会发生任何变化。转型为独立业务后，团队将拥有更大的自由度来响应那些长期存在的用户需求，并继续保持其一贯的创新精神。此次调整被视为 Gather 回归初心的举措，使其能以更专注的方式在远程协作领域发挥所长。</p><p>( @Gather Blog)</p><p><strong>2、Willow 发布开发者语音工具，支持 Cursor、Antigravity 等主流 AI IDE</strong></p><p>2026 年 2 月 12 日，Willow 正式推出了面向开发者的语音听写工具「Willow for Developers」，该工具专为 Vibe Coding 工作流打造。针对 Andrej Karpathy 曾提出的「英语是目前最热门的新编程语言」这一观点，Willow 将传统的键盘输入视为开发过程中的瓶颈，并试图通过语音交互来消除这一障碍。</p><p>该工具的核心逻辑建立在说话与打字的速度差异之上。Willow 指出，人类的平均语速约为每分钟 200 个单词，而打字速度仅为每分钟 60 个单词。通过口述提示词，开发者能够比打字时更自然地提供丰富的细节和上下文信息。在 AI 辅助开发的语境下，这种高密度的上下文输入有助于 AI IDE 生成质量更高的代码。</p><p>在具体功能层面，Willow 针对编程场景进行了多项优化：</p><ul><li><strong>智能文件识别与标签化</strong>：工具支持 Cursor、Antigravity 等主流 AI IDE。当用户口述如「更新 navbar.tsx 中的标题栏」等指令时，Willow 能自动识别项目中的特定文件，并自动添加相应的引用标签（如 @ 标签），无需开发者手动标记。</li><li><strong>技术术语精准听写</strong>：区别于普通语音输入，Willow 具备代码上下文感知能力。它能够准确拼写特定的变量名称（例如「userAuthToken」），并开箱即用地识别 SQL、GraphQL、OAuth 等技术术语，确保拼写无误。</li></ul><p>相关链接：<br/><a href="https://link.segmentfault.com/?enc=vCo9mPBkRQCzzVxhR%2F1uTw%3D%3D.4%2Be2T55Vct1%2FEFjwRWsZv1tsi3AQq7wYS4Ul%2FESFZk8%3D" rel="nofollow" target="_blank">https://willowvoice.com/</a></p><p>( @WillowVoiceAI\@X)</p><p><strong>3、Simple AI 完成 1400 万美元种子轮融资：First Harmonic 领投，打造转化率超人工 30% 的语音智能体</strong></p><p>语音 AI 智能体平台 Simple AI 于 2026 年 2 月 10 日宣布完成 1400 万美元种子轮融资，由 First Harmonic 领投，Y Combinator 等机构跟投。资金将用于开发语音智能体平台、构建定制生成式 AI 模型及商业分析工具。</p><p>Simple AI 的核心业务是利用语音 AI 自动化处理销售与支持来电。平台可导入企业完整产品目录（含 SKU 及定价），在通话中调用实时客户数据进行个性化互动，并执行下单等操作，同时生成通话记录与分析报告。技术上，该平台宣称将全链路延迟控制在 850 毫秒以内，涵盖语音检测到文本转语音的全流程，以确保对话自然流畅。</p><p>该技术试图解决呼叫中心的三大挑战：</p><ul><li><strong>应对波动</strong>：在业务高峰期自动扩展接待能力。</li><li><strong>提升效率</strong>：学习顶尖销售代表经验，避免人工效率起伏。</li><li><strong>保持一致性</strong>：维持人类难以企及的服务稳定性。</li></ul><p>平台还提供实验工具，支持调整 AI 智能体的语速、性别和口音。联合创始人 Catheryn Li 表示，优质的语音智能体能改善通话体验；CTO Zach Kamran 则指出，智能体能瞬间掌握所有产品细节。数据显示，其 AI 智能体在牛排销售、保险等领域的转化率比人工客服高出 30%。</p><p>投资方 First Harmonic 评价称，团队并未依赖现有方案，而是从零构建了完整的语音 AI 技术栈。两位创始人相识于 Y Combinator，在接触大语言模型早期研究后，决定将其应用于语音领域。</p><p>( @BusinessWire)</p><h2>03 有态度的观点</h2><p><strong>1、AI 非但未减负，反而加剧职场倦怠</strong></p><p>据 Techcrunch 报道，如今美国职场文化中最具诱惑力的说法，并非人工智能会抢走你的工作，而是它能把你从繁重的工作中解脱出来。</p><p>过去三年里，科技行业一直在向数百万焦虑不安的人兜售这一理念，而人们也迫切愿意相信。诚然，部分白领岗位将会消失。但该观点声称，对大多数其他职位而言，人工智能是能力放大器。工具为你所用，你不用再拼命工作，人人都是赢家。</p><p>但《哈佛商业评论》（Harvard Business Review）新近发表的一项研究，顺着这一前提推导得出了真实结论：研究发现的并非一场生产力革命，而是企业有可能变成让人精疲力竭的机器。</p><p>加州大学伯克利分校的研究团队在一家 200 人规模的科技公司进行了为期八个月的实地观察。研究发现，尽管公司管理层并未施加额外压力或设定新业绩目标，员工在深度接纳 AI 后，工作状态却发生了微妙变化。仅仅因为工具提升了可行性，员工便主动承担更多任务，导致工作逐渐侵占午休时间甚至蔓延至深夜。AI 节省出的每一小时，迅速被不断膨胀的待办事项填满。一位工程师在访谈中坦言，原本期望的高效率能带来闲暇，现实却是工作量不降反增。</p><p>此前已有数据佐证了类似迹象：去年夏天的实验显示，资深开发者使用 AI 后实际耗时增加 19%，尽管其自我感觉效率提升了 20%；美国国家经济研究局的数据也表明，AI 带来的生产力提升仅相当于节省 3% 的时间。</p><p>与上述研究不同，这项新研究并未质疑 AI 对个人能力的提升作用，而是揭示了这种提升的副作用。研究指出，随着组织对响应速度和工作效率的要求水涨船高，技术赋能最终导向了疲劳、职业倦怠以及强烈的「无法抽身感」。科技行业寄希望于通过「做更多事」来解决问题，但这或许正是新问题的开端。</p><p>（@IT 之家）</p><h2>04 社区黑板报</h2><p>招聘、项目分享、求助……任何你想和社区分享的信息，请联系我们投稿。（加微信 creators2022，备注「社区黑板报」）</p><p><strong>1、招聘工程研发、算法、产运等岗位</strong></p><p>来自社区开发者 Polande：</p><p><strong>招聘岗位（北京）</strong></p><p>1.工程研发/Agent 研发</p><p>2.语音算法</p><p>3.产品运营、用户增长</p><p>4.AI 创新独立小团队（3 人）<em>*</em>*</p><p><strong>期望：</strong>热爱 AI、了解 AI、了解 SaaS、能够用 AI 在工作中实质的提效落地。</p><p><strong>关于公司</strong></p><p>1.方向是做语音对话的 SaaS -&gt; Agent 平台产品</p><p>2.上市公司内的创业团队，当前 30 人，26 年控制在 50 人左右（创业氛围，暂时不需要融资</p><p>3.产品：0.7 阶段</p><p><strong>关于我</strong></p><p>原先在百度和现在团队一直是做 AI 商业化方向，接近小十年的智能语音交互，但是现在还是有很多事情会感觉到兴奋。</p><p>有意向可以联系 polandeme\@gmail.com</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608721" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608722" alt="" title="" loading="lazy"/></p><p><strong>写在最后：</strong></p><p>我们欢迎更多的小伙伴参与 <strong>「RTE 开发者日报」</strong> 内容的共创，感兴趣的朋友请通过开发者社区或公众号留言联系，记得报暗号「共创」。</p><p>对于任何反馈（包括但不限于内容上、形式上）我们不胜感激、并有小惊喜回馈，例如你希望从日报中看到哪些内容；自己推荐的信源、项目、话题、活动等；或者列举几个你喜欢看、平时常看的内容渠道；内容排版或呈现形式上有哪些可以改进的地方等。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608723" alt="" title="" loading="lazy"/></p><p>作者提示: 个人观点，仅供参考</p>]]></description></item><item>    <title><![CDATA[macOS Sonoma 14.8.4 (23J319) 正式版 ISO、IPSW、PKG 下载 s]]></title>    <link>https://segmentfault.com/a/1190000047608740</link>    <guid>https://segmentfault.com/a/1190000047608740</guid>    <pubDate>2026-02-13 10:04:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>macOS Sonoma 14.8.4 (23J319) 正式版 ISO、IPSW、PKG 下载</p><p>利用小组件进行个性化设置、令人眼前一亮的全新屏幕保护、Safari 浏览器和视频会议的重大更新</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=g7kxlKKsfeFLu0vT5i6tpA%3D%3D.hJ9VoChxWjPi4sG7jEATinSFwZyJUcwouZZpUmXAo8Ts60EE9hqIHAGM7rhyYZBA" rel="nofollow" target="_blank">https://sysin.org/blog/macOS-Sonoma/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=Q3F1r3UReuloODxfkpUPrA%3D%3D.X%2BUzN11vXKYBsnI971J4%2B1zmwQWY67MofNjqRkx1BXc%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>2026 年 2 月 12 日凌晨，Apple 发布 iOS/iPadOS/macOS/watchOS/tvOS/visonOS 全平台 26.3 版本更新。macOS Tahoe 26.3 此次为常规问题修复和安全更新。同时为不能更新最新系统的 Mac 发布了 macOS Sequoia 15.7.4 和 macOS Sonoma 14.8.4 软件更新，此类更新通常为安全修复和常规问题修复。<br/>macOS Sonoma 推出全新功能，全面提升生产力和创意工作流</p><p>macOS Sonoma 推出全新功能，全面提升生产力和创意工作流</p><p>隆重推出更多利用小组件进行个性化设置的方式、令人眼前一亮的全新屏幕保护、Safari 浏览器和视频会议的重大更新，以及经优化的游戏体验——Tim Cook 让 Mac 体验远胜以往。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046099654" alt="MacBook Air、27 英寸 iMac 和 MacBook Pro 上的 macOS Sonoma。" title="MacBook Air、27 英寸 iMac 和 MacBook Pro 上的 macOS Sonoma。"/></p><p><em>macOS Sonoma 让 Mac 体验远胜以往——从更多利用小组件进行个性化设置的方式，到 Safari 浏览器和视频会议的重大更新，更有众多精彩新游戏登陆。</em></p><h2>macOS Sonoma 更新摘要</h2><p>macOS Sonoma 14.8 及更新版本，如无特殊说明皆为安全更新或常规错误修复，不再赘述。</p><h2>macOS Sonoma 硬件兼容性列表</h2><p>看看你的 Mac 是否能用 macOS Sonoma</p><p>​      <a href="https://link.segmentfault.com/?enc=%2BR3pc%2B5yt1bQ2eJpx2gEnQ%3D%3D.TSRrYVrvB7QsdcX07Z%2B4UMvjk4qOfuKnEn%2FRaSvi4ww%3D" rel="nofollow" target="_blank">进一步了解 Mac&gt;</a></p><ul><li>MacBook Air 2018 and later <a href="https://link.segmentfault.com/?enc=RKjnT0z2p0WfZwu7oJfYiw%3D%3D.Ts3e4mcM8sh6uB8PBNy5tkYVIfMNeCnqJbPF4jHhmpURCbzog2VzKsRotv5DmzMt" rel="nofollow" target="_blank">进一步了解</a></li><li>MacBook Pro 2018 and later <a href="https://link.segmentfault.com/?enc=NKPSREgVZ5cDMMIVmw3Yhg%3D%3D.tjvxgj8rXATyhgy4KEeGo%2FazADrVH3Qw8YehfG%2F8AEEf4lciKqCOfsWSasptoCd4" rel="nofollow" target="_blank">进一步了解</a></li><li>Mac mini 2018 and later <a href="https://link.segmentfault.com/?enc=wRj5WwD%2BCNQ7NmJm%2F9rrhA%3D%3D.aIRc4c7ecCWeSbN5EhDZtuVegTRBDGNN8shJfMMBCM%2FLR7m%2FFAwESSj950X%2BG1QU" rel="nofollow" target="_blank">进一步了解</a></li><li>Mac Studio 2022 and later <a href="https://link.segmentfault.com/?enc=i2odx%2FKKkVbsgZL%2FXkdPDQ%3D%3D.kxobFMGI7g8O9QACmr44OeEZYpf7ksFJCZyuM8nVKpdMYwhlvLaprJghf%2Fx7N4%2Fx" rel="nofollow" target="_blank">进一步了解</a></li><li>Mac Pro 2019 and later <a href="https://link.segmentfault.com/?enc=H3TNqSf47oYj41D%2B0zAWsA%3D%3D.ZQDDeSZK4FxHmN2qO7%2Bo2Sf0SyWfxr7lq0mXnfEjkcNv%2FP0IAkMYvZbo62LXshFv" rel="nofollow" target="_blank">进一步了解</a></li><li>iMac 2019 and later <a href="https://link.segmentfault.com/?enc=Hm4jvuEMkwXJoTHHSixCzQ%3D%3D.NYLiriehOxXcy9ARH5Dnjr%2FThR088wUNQl6jCqqsmnZFS4zCC4rdEfkL7l%2FXtwps" rel="nofollow" target="_blank">进一步了解</a></li><li>iMac Pro 2017 <a href="https://link.segmentfault.com/?enc=rpxUdVvZpFOuV2o8biFAWA%3D%3D.w5oFgBxZFnggU1GvzL%2FWUN7T4bHauA5PfLkIPWtQQepN1ZlsVK0hGtvEUuw%2BK5Tn" rel="nofollow" target="_blank">进一步了解</a></li></ul><p>如果你的 Mac 不在兼容性列表，参看：<a href="https://link.segmentfault.com/?enc=rfF0di9RLmwayXjeI3j3Cg%3D%3D.o4zEtfcYAM5HCVCGqlPj9QR4vguRet%2BLfFiJSIvWKK6vKpChglUz6vaYb%2BhO5ohPhfYE4soKFw9mhCNSYb%2FwFQ%3D%3D" rel="nofollow" target="_blank">在不受支持的 Mac 上安装 macOS Sonoma (OpenCore Legacy Patcher v1.5.0)</a></p><h2>macOS Sonoma 版本历史</h2><p>Software Releases</p><ul><li>macOS Sonoma 14.8.4 (23J319) - 2026.02.11</li><li>macOS Sonoma 14.8.3 (23J220) - 2025.12.12</li><li>macOS Sonoma 14.8.2 (23J126) - 2025.11.03</li><li>macOS Sonoma 14.8.1 (23J30) - 2025.09.30</li><li>macOS Sonoma 14.8 (23J21) - 2025.09.15</li><li>macOS Sonoma 14.7.8 (23H730) - 2025.08.20</li><li>macOS Sonoma 14.7.7 (23H723) - 2025.07.30</li><li>macOS Sonoma 14.7.6 (23H626) - 2025.05.12</li><li>macOS Sonoma 14.7.5 (23H527) - 2025.03.31</li><li>macOS Sonoma 14.7.4 (23H420) - 2025.02.10</li><li>macOS Sonoma 14.7.3 (23H417) - 2025.01.28</li><li>macOS Sonoma 14.7.2 (23H311) - 2024.12.11</li><li>macOS Sonoma 14.7.1 (23H222) - 2024.10.28</li><li>macOS Sonoma 14.7 (23H124) - 2024.09.16</li><li>macOS Sonoma 14.6.1 (23G93) - 2024.08.07</li><li>macOS Sonoma 14.6 (23G80) - 2024.07.29</li><li>macOS Sonoma 14.5 (23F79) - 2024.05.13</li><li>macOS Sonoma 14.4.1 (23E224) - 2024.03.25</li><li>macOS Sonoma 14.4 (23E214) - 2024.03.07</li><li>macOS Sonoma 14.3.1 (23D60) - 2024.02.08</li><li>macOS Sonoma 14.3 (23D56) - 2024.01.22</li><li>macOS Sonoma 14.2.1 (23C71) - 2023.12.19</li><li>macOS Sonoma 14.2 (23C64) - 2023.12.11</li><li>macOS Sonoma 14.1.2 (23B92 | 23B2091) - 2023.11.30</li><li>macOS Sonoma 14.1.1 (23B81 | 23B2082) - 2023.11.07</li><li>macOS Sonoma 14.1 (23B74) - 2023.10.25</li><li>macOS Sonoma 14 (23A344) Release - 2023.09.26</li></ul><h2>下载 macOS Sonoma</h2><p>💡 <a href="https://link.segmentfault.com/?enc=zz6oXuaYOT3ZBm7Jla4K0g%3D%3D.CP94TzyDdkIGLolrugfCdCK7CM2VRyaQZk6MQeL9wnk%3D" rel="nofollow" target="_blank">如何校验本站下载的文件的完整性</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046099662" alt="macOS Sonoma" title="macOS Sonoma" loading="lazy"/></p><h3>(1) ISO 格式软件包 (推荐)</h3><blockquote><p>本站原创可引导映像，可以在当前系统中安装或者升级，可以通过 USB 存储引导安装，也可以用于虚拟机安装。</p><p>此版本更多介绍请参看：<a href="https://link.segmentfault.com/?enc=ObONYxtqWezC4EcHcZAYeQ%3D%3D.GDED3pXM%2FsT8I2LycrAo1cBxxRoHyLmhjzPatdhFCqY3WUNcHZw6Fy6Mxaoxm%2FV6" rel="nofollow" target="_blank">macOS Sonoma 14 Boot ISO 原版可引导映像下载</a></p></blockquote><ul><li>macOS Sonoma 14.8.4 (23J319) - 2026.02.11</li><li>macOS Sonoma 14.8.3 (23J220) - 2025.12.12</li><li>macOS Sonoma 14.8.2 (23J126) - 2025.11.03</li><li>macOS Sonoma 14.8.1 (23J30) - 2025.09.30</li><li>macOS Sonoma 14.8 (23J21) - 2025.09.15</li><li>macOS Sonoma 14.7.8 (23H730) - 2025.08.20</li><li>macOS Sonoma 14.7.7 (23H723) - 2025.07.30</li><li>macOS Sonoma 14.7.6 (23H626) - 2025.05.12</li><li>macOS Sonoma 14.7.5 (23H527) - 2025.03.31</li><li>macOS Sonoma 14.7.4 (23H420) - 2025.02.10</li><li>macOS Sonoma 14.7.3 (23H417) - 2025.01.28</li><li>macOS Sonoma 14.7.2 (23H311) - 2024.12.11</li><li>macOS Sonoma 14.7.1 (23H222) - 2024.10.28</li><li>macOS Sonoma 14.7 (23H124) - 2024.09.16</li><li>macOS Sonoma 14.6.1 (23G93) - 2024.08.07</li><li>macOS Sonoma 14.6 (23G80) - 2024.07.29</li><li>macOS Sonoma 14.5 (23F79) - 2024.05.13</li><li>macOS Sonoma 14.4.1 (23E224) - 2024.03.25</li><li>macOS Sonoma 14.4 (23E214) - 2024.03.07</li><li>macOS Sonoma 14.3.1 (23D60) - 2024.02.08</li><li>macOS Sonoma 14.3 (23D56) - 2024.01.22</li><li>macOS Sonoma 14.2.1 (23C71) - 2023.12.19</li><li>macOS Sonoma 14.2 (23C64) - 2023.12.11</li><li>macOS Sonoma 14.1.2 (23B92 | 23B2091) - 2023.11.30</li><li>macOS Sonoma 14.1.1 (23B81 | 23B2082) - 2023.11.07</li><li>macOS Sonoma 14.1 (23B74) - 2023.10.25</li><li>macOS Sonoma 14 (23A344) Release - 2023.09.26</li><li><strong>下载地址</strong>：<a href="https://link.segmentfault.com/?enc=Tw6KLfYv7LyUsUuzF21cLQ%3D%3D.xLacOJXeosE%2FzNqAS4BJ2yfsh39XRUbu02ePGVEJf3Fe2PJ1Usd2kF%2BiVg9tl%2BY3" rel="nofollow" target="_blank">https://sysin.org/blog/macOS-Sonoma/</a></li></ul><p>参看：<a href="https://link.segmentfault.com/?enc=WCZkLasaa1sHj6YFJ1s3vA%3D%3D.4CGhSMkD%2BpedjUqu%2Fod7honb035WgasSzcuXEtk4XCZoUuqkyKoWdJm2nsV%2BuxLZ" rel="nofollow" target="_blank">如何在 Mac 和虚拟机上安装 macOS Sequoia、macOS Sonoma 和 macOS Ventura</a></p><h3>(2) PKG 格式软件包</h3><blockquote>该格式软件包双击运行后将自动安装在 <code>/Applications</code> 下。</blockquote><ul><li>macOS Sonoma 14.8.4 (23J319) - 2026.02.11</li><li>macOS Sonoma 14.8.3 (23J220) - 2025.12.12</li><li>macOS Sonoma 14.8.2 (23J126) - 2025.11.03</li><li>macOS Sonoma 14.8.1 (23J30) - 2025.09.30</li><li>macOS Sonoma 14.8 (23J21) - 2025.09.15</li><li>macOS Sonoma 14.7.8 (23H730) - 2025.08.20</li><li>macOS Sonoma 14.7.7 (23H723) - 2025.07.30</li><li>macOS Sonoma 14.7.6 (23H626) - 2025.05.12</li><li>macOS Sonoma 14.7.5 (23H527) - 2025.03.31</li><li>macOS Sonoma 14.7.4 (23H420) - 2025.02.10</li><li>macOS Sonoma 14.7.3 (23H417) - 2025.01.28</li><li>macOS Sonoma 14.7.2 (23H311) - 2024.12.11</li><li>macOS Sonoma 14.7.1 (23H222) - 2024.10.28</li><li>macOS Sonoma 14.7 (23H124) - 2024.09.16</li><li>macOS Sonoma 14.6.1 (23G93) - 2024.08.07</li><li>macOS Sonoma 14.6 (23G80) - 2024.07.29</li><li>macOS Sonoma 14.5 (23F79) - 2024.05.13</li><li>macOS Sonoma 14.4.1 (23E224) - 2024.03.25</li><li>macOS Sonoma 14.4 (23E214) - 2024.03.07</li><li>macOS Sonoma 14.3.1 (23D60) - 2024.02.08</li><li>macOS Sonoma 14.3 (23D56) - 2024.01.22</li><li>macOS Sonoma 14.2.1 (23C71) - 2023.12.19</li><li>macOS Sonoma 14.2 (23C64) - 2023.12.11</li><li>macOS Sonoma 14.1.2 (23B92 | 23B2091) - 2023.11.30</li><li>macOS Sonoma 14.1.1 (23B81 | 23B2082) - 2023.11.07</li><li>macOS Sonoma 14.1 (23B74) - 2023.10.25</li><li>macOS Sonoma 14 (23A344) Release - 2023.09.26</li><li><strong>下载地址</strong>：<a href="https://link.segmentfault.com/?enc=dUEFCDFC%2Fvzg7JK3L6uSaw%3D%3D.P8Js%2BWTnEqOgfqodsGRROl%2BV3L8ChUj0UOZCGjU6A%2FpmbPiJSa8EhfUCoS6yo2XE" rel="nofollow" target="_blank">https://sysin.org/blog/macOS-Sonoma/</a></li></ul><h3>(3) IPSW 固件 (Apple 芯片 Mac 专用)</h3><blockquote>IPSW 格式为搭载 Apple 芯片的 Mac 专用映像，其他格式通用。</blockquote><p>适用于：<a href="https://link.segmentfault.com/?enc=RbTtwtfKYxkFJUq1EZ0DIg%3D%3D.r24gs5ZbpBMNKtR5ZtCppHxHzeCDVZjjTYc%2Bx%2BB%2Bnz%2B7kjWdhfqXcg1hgNQqDhE4" rel="nofollow" target="_blank">搭载 Apple 芯片的 Mac 电脑</a></p><p>参看：<a href="https://link.segmentfault.com/?enc=1amXLNOE%2BDJZL8rLQQ9xnw%3D%3D.LogmEqR7CpFr5icINcY3q0czxpTTqer0bmIvKYLTYc29Giw%2Fjs1ftXaAm25hmf9a" rel="nofollow" target="_blank">使用 DFU 模式修复或恢复 Mac 固件</a></p><ul><li>macOS Sonoma 14.6.1 (23G93) - 2024.08.07</li><li>macOS Sonoma 14.6 (23G80) - 2024.07.29</li><li>macOS Sonoma 14.5 (23F79) - 2024.05.13</li><li>macOS Sonoma 14.4.1 (23E224) - 2024.03.25</li><li>macOS Sonoma 14.4 (23E214) - 2024.03.07</li><li>macOS Sonoma 14.3.1 (23D60) - 2024.02.08</li><li>macOS Sonoma 14.3 (23D56) - 2024.01.22</li><li>macOS Sonoma 14.2.1 (23C71) - 2023.12.19</li><li>macOS Sonoma 14.2 (23C64) - 2023.12.11</li><li>macOS Sonoma 14.1.2 (23B92 | 23B2091) - 2023.11.30</li><li>macOS Sonoma 14.1.1 (23B81 | 23B2082) - 2023.11.07</li><li>macOS Sonoma 14.1 (23B74) - 2023.10.25</li><li>macOS Sonoma 14 (23A344) Release - 2023.09.26</li><li><strong>下载地址</strong>：<a href="https://link.segmentfault.com/?enc=m3DenKwIGCswRdmjAYgnIA%3D%3D.9MoqaWlxI0SEJULqQhH1x3nC1eKpJ%2FdhukMf0ELBmXc0vN%2B%2FiAsF%2BEl9jvSeObk1" rel="nofollow" target="_blank">https://sysin.org/blog/macOS-Sonoma/</a></li></ul><h3>(4) App Store 链接</h3><pre><code class="txt">https://apps.apple.com/app/macos-sonoma/id6450717509?mt=12</code></pre><p>或者打开 App Store 搜索 “macOS Sonoma” 即可下载（下载的是当前最新版）。</p><h2>适用的 VMware 软件下载链接</h2><p>建议在以下版本的 VMware 软件中运行（Linux OVF 无需本站定制版可以正常运行，macOS 虚拟化如果不是 Mac 必须使用定制版才能运行，Windows OVF 需要定制版才能启用完整功能）：</p><ul><li><p>VMware vSphere：</p><ul><li>VMware <a href="https://link.segmentfault.com/?enc=Bzg5B6pNq08oVTIWfWnJ7A%3D%3D.HPuJLMpopkGWl0XM7eRzdZq8yPADiMAZ5hcfC8cNxOUsqbEQ1um1bHhjD5yzegiv" rel="nofollow" target="_blank">ESXi 9</a> or <a href="https://link.segmentfault.com/?enc=RwYvAeG03B3ac7vaKoo%2B0w%3D%3D.JnwSGoXh3zyGxVqF%2FTZ6bZ2940MsanEr6lMV2BrwNu4mGdQ0z6MeF%2B6qyAbMs1hk" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=LnhRTQbb4q2fvgNxQ4V%2FGw%3D%3D.TYRHGOWkUPa5qaXx38FpkKHwnRcogAaHclbtGzuGfyRoNwZDjTkE6ckfLVMvORBU" rel="nofollow" target="_blank">vCenter Server 9</a> &amp; <a href="https://link.segmentfault.com/?enc=fWjpuxIsNmX6ZXlZF7JtiQ%3D%3D.06zHnsf5k84WaJjoaixKNMTfYVNC4YNqUFws9VqOtBgO%2FR%2FOcnZk7mRQc5H%2FcEmpiAggewNTuxTGpIqtyCQ05w%3D%3D" rel="nofollow" target="_blank">VCF Operations 9</a></li><li>VMware <a href="https://link.segmentfault.com/?enc=0beHGMVc9%2F3J8lNaH7unBg%3D%3D.3eDxyqmh4o6wpIMRVNRbqx1ZKYm6tIljrBRfaY2AcqnfSGJXpoQLgbQ7gPlkuz1t" rel="nofollow" target="_blank">ESXi 8</a> or <a href="https://link.segmentfault.com/?enc=qXNy7XSQYyxX4EOdzHHQlQ%3D%3D.U2U7PNVz2I7pX9gy03CoPohdh5hErk33GzeqEC1f1%2B6X8Ju0mzYrvCpBOY90K1tq" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=mVKNBz%2B2r1OJHgdZUhAw6A%3D%3D.38uO50DKzHWnebdx8yVEyBFpooo2icY9J7E1lJVTfqEzFr4hTSdTrQ8b3D7k2VFk" rel="nofollow" target="_blank">vCenter Server 8</a></li><li>VMware <a href="https://link.segmentfault.com/?enc=5Im%2Fu1cfFCT4tjWA10rQJw%3D%3D.IwP%2FcJRrkHyZIKm%2FZ8muE0KQZIOCh6q6kf0pXIcASIsam07SEMaUr1vhkRhOfsAu" rel="nofollow" target="_blank">ESXi 7</a> or <a href="https://link.segmentfault.com/?enc=veKnvax9Aos0OiAx3PfFBA%3D%3D.7oAj2rFD8Of0opD5%2B6KrOSaEbjV%2Bo4q8F1SpXpke2OHdfEGg8Xnv%2Bxvn6p1gJU2E" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=b4%2F7b9jMf7lak967dHL9FA%3D%3D.8Nvm%2FR7JTOjE3%2F7tbDMK8pbuZSjZzbSx15r%2BhlXWkYDD9Pia4sqDNEkSDH8FmOyI" rel="nofollow" target="_blank">vCenter Server 7</a></li></ul></li><li>macOS：<a href="https://link.segmentfault.com/?enc=b8lXQk1GddCcNK3vJeZVmg%3D%3D.0WzxiSCHU05MTy452220xATfLdB%2FEHydpTAQsuXSixTVG%2FICUqwZEBxz4FYGAAqC" rel="nofollow" target="_blank">VMware Fusion</a></li><li>Linux：<a href="https://link.segmentfault.com/?enc=APb0%2FP2FtbiwZxK%2BAyQpkg%3D%3D.6iIScHmKmjp7%2FOZgxZysabNvLEgHZqiCxTVhP6UVZayVusf%2F1g80K2NM3vUemxdZS7b528lklUhEa5scDVdx7g%3D%3D" rel="nofollow" target="_blank">VMware Workstation for Linux</a></li><li>Windows：<a href="https://link.segmentfault.com/?enc=Kp%2BM8fkddXw3%2FTa2766flA%3D%3D.p%2BZHDY5arAdNzyI6s%2Fl%2FtF2ndc8lTyNXFuOzttukIRR0HP%2FOkwl0DZjK7CM2YsvgzsdCLrdaG3aiDmf9X68GWg%3D%3D" rel="nofollow" target="_blank">VMware Workstation for Windows</a></li></ul><p>macOS Sonoma 虚拟化解决方案，请参看：<a href="https://link.segmentfault.com/?enc=RDVNdGiYZYMAFVFJJjz%2Blg%3D%3D.wJVRk5ZrGZN59fxbiQEopVZ8YIqaOneM0NrlLenruMwxgPs8KNpzLzMWQNNgmZbl" rel="nofollow" target="_blank">macOS 14 Blank OVF - macOS Sonoma 虚拟化解决方案</a></p><h2>如何创建可引导的 macOS 安装器</h2><p>请访问：<a href="https://link.segmentfault.com/?enc=tuU74hJfxd%2FBMc0826%2B8DA%3D%3D.MYbVdiDhdia6sreDZwJugEl6nh2BXJoqvlbI6Or4uKFy8QFd4mdw6nKZVByhN%2Bi0XL56VGiBdJjwIxfYopSlAQ%3D%3D" rel="nofollow" target="_blank">如何创建可引导的 macOS 安装介质</a></p><p>更多：<a href="https://link.segmentfault.com/?enc=sx0qgW8Q%2FlqbMDQWHJDBPw%3D%3D.6n6zM7xKBvWWvFz43F%2FL%2BI5Frm%2B0QQ4V3UkBf5olRvk%3D" rel="nofollow" target="_blank">macOS 下载汇总 (系统、应用和教程)</a></p>]]></description></item><item>    <title><![CDATA[硅谷爆火的「Vibecoding」：不用敲代码，AI 帮你把想法变成产品 UXbot ]]></title>    <link>https://segmentfault.com/a/1190000047608742</link>    <guid>https://segmentfault.com/a/1190000047608742</guid>    <pubDate>2026-02-13 10:03:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>硅谷工程师圈刮起一阵新风潮 ——Vibe Coding（氛围编程）。说白了，就是不用埋头逐行敲代码，只要把你的想法用大白话讲清楚，剩下的活儿全交给 AI，轻松把创意变成能用的产品。<br/>本文将为大家解释什么是Vibe coding，并为大家推荐实用工具。</p><p>一、什么是 Vibe Coding？一张表秒懂<br/><img width="723" height="314" referrerpolicy="no-referrer" src="/img/bVdnVmY" alt="image.png" title="image.png"/><br/>一句话总结：你负责把想法说成人话，AI 负责把人话变成能用的代码。</p><p>二、Vibe Coding 4 步走：小白也能轻松上手<br/>说需求：把想法讲明白就行不用纠结技术术语，直接说你想要的效果：“帮我做个购物网站，左滑是喜欢，右滑是不喜欢，界面要极简风，看着干净舒服。”<br/>AI 生成：设计+前端代码一步到位把需求丢给 AI，它会自动帮你搞定可视化PRD、产品原型设计、前端代码，都给你配置妥当，不用你操心任何技术细节。<br/>看效果：云端一键部署，打破设计与开发壁垒，有任何不满意的地方都可重新修改。<br/>改需求：不满意随时调，秒级响应觉得按钮不好看？直接说：“按钮太丑了，换成浅蓝色，再把圆角调大一点。” AI 立刻重绘 UI，不用重启程序，刷新就能看新效果。</p><p>三、零代码基础的产品经理，3 小时上线情侣旅游攻略<br/>主角：产品经理小陈，连 “Hello World” 都写不利索<br/>初衷：想给女友跟女友出去旅游，做个 “旅游” 网站，推荐全国各地的攻略：UXbot+Cursor 编辑器 ：从提需求到上线只用了 3 小时，快到离谱。</p><p>四、工具推荐<br/>1.UXbot<br/>UXbot是AI驱动软件设计+Web前端开发工具，专门适配软件设计和开发场景，能够帮助用户打通“需求解析-界面设计-协作交付”全链路，用AI赋能提升开发效率。<br/>2.实战演练<br/>为验证UXbot的实际落地效能，本次选取“物流订单管理系统”为实战场景，聚焦方案撰写链路开展测试。<br/>第1步：精准输入需求，AI深度解析设计意图<br/>通过自然语言清晰描述UI需求即可启动生成。例如：“生成物流订单管理系统，包括物流追踪、订单管理、异常处理三个模块，组件自动适配响应式布局。”UXbot将智能识别页面类型、核心功能模块与结构逻辑，为精准生成奠定基础。<br/><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnVmZ" alt="image.png" title="image.png" loading="lazy"/></p><p>第2步：可视化PRD智能生成<br/>可视化 PRD 以其直观的流程图形式，将产品的核心逻辑、功能模块、用户路径等进行系统化整合与呈现，让产品交互逻辑清晰可视化，帮助用户快速掌握产品全局架构与运行逻辑，并且通过流程闭环校验，精准识别并补齐产品逻辑中的缺漏与断点。<br/><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnVm0" alt="image.png" title="image.png" loading="lazy"/></p><p>第3步：AI自动生成高保真UI界面<br/>基于需求解析结果，UXbot将自动完成页面结构搭建、UI组件匹配、视觉风格统一，数十秒内即可输出完整的高保真可交互界面。生成界面支持页面跳转与演示，可直接用于团队评审或需求沟通，彻底告别从低保真到高保真的冗长迭代过程。<br/><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnVm1" alt="image.png" title="image.png" loading="lazy"/></p><p>第4步：二次编辑与交互逻辑完善<br/>搭载 AI 助手与专业级精密编辑器，支持用户进行像素级细节控制，布局微调、样式迭代、图文更新均精准匹配需求，兼顾创意灵动性与设计专业性。<br/><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnVm2" alt="image.png" title="image.png" loading="lazy"/></p><p>第5步：Web前端代码生成<br/>界面设计一确定，它就会自动生成能直接用的前端代码，还能适配 Vue.js 这种常用框架。设计效果和代码能无缝衔接，甚至能一键传到云服务器上，再也不用纠结设计和开发脱节的问题了。<br/><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnVm3" alt="image.png" title="image.png" loading="lazy"/></p><p>写在最后<br/>2025年硅谷已经开始开出百万年薪，招聘“会提需求的Vibe Coder”；现在的你，就算完全不会写代码，也可能成为下一个爆款产品的独立开发者。<br/>Vibe Coding不是让你彻底放弃编程，而是把那些重复、枯燥、没技术含量的体力活，统统交给AI去做。你只需要专注于最核心的部分——打磨创意、优化产品、挖掘用户价值。<br/>毕竟在AI时代，最值钱的从来不是“括号该放左边还是右边”，而是那个独一无二、能打动用户的好点子。</p>]]></description></item><item>    <title><![CDATA[银河麒麟V10安装 openssl-1.1.1f-4.p12.ky10.x86_64教程(含依赖解决]]></title>    <link>https://segmentfault.com/a/1190000047608767</link>    <guid>https://segmentfault.com/a/1190000047608767</guid>    <pubDate>2026-02-13 10:03:18</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><h3> 1. 先把东西备好</h3><ul><li><p><strong>看看系统对不对头</strong></p><p>开个终端，先敲俩命令，确认是 Kylin V10 并且是 64 位的。</p><pre><code>cat /etc/os-release
uname -m</code></pre></li></ul><pre><code>看到输出里有 `Kylin Linux`和 `x86_64`就OK。
</code></pre><ul><li><p><strong>找到你的 RPM 包</strong></p><p><strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=ieCsTMlWb6n2ED57tFN7xw%3D%3D.aJxlMXK3YBIK9EISSkrVBKifjq53lrkWX%2FlEfrCvLNaXI3PV0ghbPv%2B3xbsnEMIG" rel="nofollow" title="https://pan.quark.cn/s/6e9d4d969bac" target="_blank">https://pan.quark.cn/s/6e9d4d969bac</a>  ，假设你把包下载到了 <code>/home/你的用户名/下载/</code>文件夹。先切换到这个目录，并确认文件真的在这儿。</p><pre><code>cd /home/你的用户名/下载
ls -l openssl-1.1.1f-4.p12.ky10.x86_64.rpm</code></pre></li></ul><pre><code>能列出文件信息，就说明路径没错。


</code></pre><h3>2. 开始上手安装</h3><p>跟之前一样，推荐用第二种方法，能帮你自动搞定依赖，少折腾。</p><h4>方法一：用 <code>rpm</code>命令直接干</h4><p>这个方法最直接，但如果缺东西，你得自己满世界去找。</p><ol><li><p><strong>执行安装命令</strong></p><p>在 RPM 包所在的目录，敲下命令：</p><pre><code>sudo rpm -ivh openssl-1.1.1f-4.p12.ky10.x86_64.rpm</code></pre></li></ol><pre><code>-   `-i`就是安装
-   `-v`显示过程
-   `-h`显示个百分比进度条
</code></pre><ol><li><p><strong>遇到缺啥补啥</strong></p><p>如果安装失败了，十有八九是提示你缺依赖。比如可能缺 <code>perl</code>或者其他库。这时候你就得照着提示，把缺的包装上，然后再回来重新执行上面的命令。</p></li></ol><h4>方法二：用 <code>dnf</code>或 <code>yum</code>命令装 (推荐)</h4><p>这个方法的好处是会自己联网去软件库里把需要的依赖都下载安装好，非常省心。</p><ol><li><p><strong>执行安装命令</strong></p><p>还在那个目录下，执行下面任意一个命令：</p><pre><code># 如果系统默认是 dnf
sudo dnf install ./openssl-1.1.1f-4.p12.ky10.x86_64.rpm

# 或者，如果系统默认是 yum
sudo yum localinstall openssl-1.1.1f-4.p12.ky10.x86_64.rpm</code></pre></li></ol><pre><code>输完密码，它会分析依赖，然后问你确定要装吗，你输入 `y`回车就成。


</code></pre><h3> 3. 最后检查下，看装好没</h3><p>装完了，必须得验证一下。</p><p>在终端里输入这个命令：</p><pre><code>rpm -q openssl</code></pre><p>如果屏幕返回的结果是 <code>openssl-1.1.1f-4.p12.ky10.x86_64</code>，那就稳了，说明安装成功！</p><p>​</p>]]></description></item><item>    <title><![CDATA[AI 画图全家桶来了！这回想自己手绘图都难了 程序员小富 ]]></title>    <link>https://segmentfault.com/a/1190000047608774</link>    <guid>https://segmentfault.com/a/1190000047608774</guid>    <pubDate>2026-02-13 10:02:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>大家好，我是小富～</strong></p><p>前几天我不是分享了如何零成本搭建 <strong>next-ai-draw-io</strong>，教大家用 AI 生成 draw.io 风格的架构图。后台反响还不错，看来大家对手绘架构图真的是苦之久矣。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047511102" alt="" title=""/></p><p>但在日常写文章时，我发现很多读者更偏爱那种手绘感十足的 <strong>Excalidraw</strong> 风格，就是下面这种，逼格高、视觉美，能让文章瞬间显得高级起来：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608776" alt="" title="" loading="lazy"/></p><p>我原本在琢磨，能不能用 Gemini Pro 给自己搓一个 AI 绘图整合平台，把 draw.io 和 Excalidraw 全揉进去。</p><p>结果去 GitHub 一搜，好家伙，已经有大佬把我想做的给做了！这个开源项目简直是为我这种懒癌博主量身定制的：<strong>Mermaid、draw.io、Excalidraw</strong> 三大王牌风格全部支持。</p><p>回头再看看以前为了画个原理图熬夜的样子，真的感觉是在浪费生命啊！</p><h4>AI Draw Nexus AI 绘图全家桶</h4><p><strong>GitHub 地址</strong>：<code>https://github.com/hkxiaoyao/ai-draw-nexus</code></p><p><strong>在线体验</strong>：<code>https://ai-draw-nexus.aizhi.site/</code></p><p>我挨个试了一遍，大家感受下这输出质量：</p><p><strong>1. Excalidraw 风格</strong></p><p>输入: HTTP 长轮询原理图，生成的逻辑线条清晰，手绘质感爆棚。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608777" alt="" title="" loading="lazy"/></p><p><strong>2. Draw.io 风格</strong></p><p>我之前很多的系统架构、流程图都是这个风格，现在 AI 加持真的太方便了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608778" alt="" title="" loading="lazy"/></p><p><strong>3. Mermaid 风格</strong></p><p>写 Markdown 就更简单了一秒出图。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608779" alt="" title="" loading="lazy"/></p><p>这不是功能阉割版，而是全量版！可以在 AI 生成的基础上，直接手动微调。</p><h4>快速上手</h4><p>如果你想本地运行，这个基于 Next.js 的前端项目安装起来也非常简单：</p><pre><code class="shell"># 1. 克隆项目
git clone https://github.com/hkxiaoyao/ai-draw-nexus
cd ai-draw-nexus

# 2. 安装依赖 (推荐用 pnpm)
pnpm install

# 3. 开启生产力大门
pnpm dev</code></pre><p>不过，目前的在线版本每天有 10 次免费配额，这也很正常毕竟 API 线上的费用确实贵（上次我那个免费工具被大家两天就用欠费了，哈哈 😂）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608780" alt="" title="" loading="lazy"/></p><p>现在仅支持 <strong>OpenAI</strong> 和 <strong>Anthropic</strong> 两大模型。如果你有自己的 Key，建议本地搭一个，那才是真正的绘图自由！</p><p>好了，下期见～</p>]]></description></item><item>    <title><![CDATA[如何在低代码平台中自定义流程编号？一篇搞定所有配置步骤！ 软件部长 ]]></title>    <link>https://segmentfault.com/a/1190000047608805</link>    <guid>https://segmentfault.com/a/1190000047608805</guid>    <pubDate>2026-02-13 10:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在企业的日常运营中，流程管理是确保工作规范、提升效率的关键环节。每一个流程实例都需要一个唯一的标识符，这就是流程编号。它如同流程的“身份证”，贯穿流程的发起、审批、执行与归档全过程，确保流程可追溯、易管理。<br/>流程编号并不是一成不变，在JVS低代码流程引擎中，有一个流程编码自定义配置的能力，允许企业根据自身管理需求，设计出贴合业务、便于查询跟踪的编号规则。<br/>流程编号是一种用于标识和跟踪特定流程或业务流程实例的标识符。在企业或组织中，流程编号通常用于确保流程的准确性和可追溯性，帮助管理和优化业务流程。<br/>通过自定义编号规则，你可以将业务类型、日期、部门等信息融入编号中。例如，一个“采购申请”流程的编号可以定义为 P-20250213-00001（P代表采购，20250213代表日期，00001为当日序号），这让流程管理一目了然，极大地提升了查询与统计效率。<br/><strong>示例演示</strong><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608807" alt="图片" title="图片"/><br/>接下来我说一说具体的配置方式。<br/><strong>操作步骤</strong><br/>进入流程引擎设计，点击【高级设置】页面<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608808" alt="图片" title="图片" loading="lazy"/><br/>流程编号默认按系统规则生成，即阿拉伯数字顺序计数，从1开始依次递增。<br/>选择按自定义规则生成流程编号点击编辑图标，编号格式设置同我们流水号组件设置如下<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608809" alt="图片" title="图片" loading="lazy"/><br/>①：前缀，加在编号前面的，自定义标识，如“P”代表流程，“M”代表管理，“S”代表支持等<br/>②：后缀，拼接在最后面的<br/>③：时间标识，拼接在前缀后<br/>不设置，默认设置<br/>年<br/>年月<br/>年月日<br/>年月日时<br/>年月日时分<br/>年月日时分秒<br/>④：序号位数，默认是5，可设置1-9位数字<br/>⑤：重置规则<br/>不重置<br/>按年重置<br/>按月重置<br/>按天重置<br/>按小时重置<br/>按业务需要设置好编号格式点击【确定】最后点击【保存】并【发布】流程，重新发起流程查看效果。<br/><strong>流程编号展示位置</strong><br/>流程办理页面<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608810" alt="图片" title="图片" loading="lazy"/><br/>流程进度页面<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608811" alt="图片" title="图片" loading="lazy"/><br/>工作台<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608812" alt="图片" title="图片" loading="lazy"/><br/>在线demo：<a href="https://link.segmentfault.com/?enc=awQsrMsqXpA9wuabj8qe0Q%3D%3D.pyd%2BXq66ww4JnJMcO6BHpCwWv0UxnRJEugkELRARE1U%3D" rel="nofollow" target="_blank">https://app.bctools.cn</a><br/>基础框架开源地址：<a href="https://link.segmentfault.com/?enc=2C89SYWezaVz0AwZ7lkRAA%3D%3D.P360SwWpawTPW%2BgUqwQ5SlKfSxE15d%2F9WQPNFA4ZdsMHEeqsvk4vbC5R%2Fc3R1Cgz" rel="nofollow" target="_blank">https://gitee.com/software-minister/jvs</a></p>]]></description></item><item>    <title><![CDATA[Microsoft Office LTSC 2024 for Mac 16.106 - 文档、电子表]]></title>    <link>https://segmentfault.com/a/1190000047608698</link>    <guid>https://segmentfault.com/a/1190000047608698</guid>    <pubDate>2026-02-13 09:01:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Microsoft Office LTSC 2024 for Mac (Microsoft 365) 16.106 - 文档、电子表格、演示文稿和电子邮件</p><p>Office LTSC 2024 for Mac (Word, Excel, PowerPoint, Outlook + OneNote, OneDrive)</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=HS%2BoY9AO5L%2BY6Fvf5ahlcw%3D%3D.PQG2n03mG3jzeeeZbpRNj%2FeztbNmtY5O%2BP2fUsl9u7eehG5xm7LxdEe%2BfUILKBTD" rel="nofollow" target="_blank">https://sysin.org/blog/office-2024-for-mac/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=hTjFlERie53sy0mRFSbvAw%3D%3D.F3PqT3lKJFUAOk%2B9lWTcBEuEck67wrTsOeeUwMF3GNk%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>Office for Mac 2024 2026 年 2 月份月度更新来袭！</p><h2>Office for Mac 2024 组件和发行版</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608476" alt="Office LTSC" title="Office LTSC"/></p><p>宣布推出适用于 Windows 和 Mac 的 Microsoft Office LTSC 2024 正式版</p><p>2024 年 9 月 16 日，Microsoft Office LTSC 2024 的正式版现已适用于 Windows 和 Mac。</p><p>如果您有 Office 2016、Office 2019 或 Office LTSC 2021 并且想要预览 Office LTSC 2024，请访问<a href="https://link.segmentfault.com/?enc=%2B9gZ5YHQQT%2FCDrGXHEpkeQ%3D%3D.B8CwkO%2Foq7Q7B%2FSmax9mS6q6eGZ7UX8jLHtvhmeQwKE1K2b1xkEQKZZxeW7xLvoQ" rel="nofollow" target="_blank">安装 Office LTSC 正式版</a>，了解如何在 Windows 设备上安装和使用。</p><p>Office for Mac 包含以下组件：</p><ul><li>Microsoft <strong>Excel</strong>：电子表格和数据分析</li><li>Microsoft <strong>Outlook</strong>：电子邮件和日历</li><li>Microsoft <strong>PowerPoint</strong>：创建吸引人的演示文稿</li><li>Microsoft <strong>Word</strong>：创建、编辑和分享文档</li><li>Microsoft <strong>OneNote</strong>：记录笔记、创意和备忘录</li></ul><p>Office for Mac 有以下两种发行版（详见下文描述）：</p><ul><li>Office for Mac (Office 365) pkg</li><li>Office LTSC for Mac DMG VL</li></ul><h2>Office for Mac 2024 (Microsoft 365) pkg</h2><p>⚠️：<strong>请慎用此版本，需要 root 权限才能运行，安装一堆无用文件，强制自动更新。</strong></p><p>参看：<a href="https://link.segmentfault.com/?enc=tln1mXPp3MAeUZA1SlBRJA%3D%3D.miHvDgBEmxI8VrsHV%2Bbttz5aq%2FrwOoPlYOEJwLxeYA0MTxzL%2FSXelfzicudvszqZQ13eVnok5V%2BnVNlF8WjzcQ%3D%3D" rel="nofollow" target="_blank">如何卸载 Office for Mac</a></p><p>此版本的唯一优点是开放下载，各大网站通常提供的也是此版本。</p><p><strong>Microsoft Office for Mac 2024 (Office 365) 16.106 Universal</strong>（2026-01-13）</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=Aa5f%2FMsn7vKZy5msfuea7w%3D%3D.W6OCXINk4jLkdVnNunhxwAVBmmPHJaTjH9HyFnM02sMTpf4RydCFaZwX5o3f18aq" rel="nofollow" target="_blank">https://sysin.org/blog/office-2021-for-mac/</a></li><li>系统要求：从 16.101 开始，要求 macOS Sonoma 14.0 及以上版本。</li></ul><p>从 16.84 开始，Office 2024 和 Office 2022 是共用安装文件 (sysin)，通过许可证激活不同的版本，主要体现在界面风格上有较为明显差异，另外 2024 版有一些新增功能。</p><p>Office 365 (现在称为 Microsoft 365 Apps) 是一种订阅模式，永久许可版即 Office LTSC for Mac。</p><h2>Office LTSC 2024 for Mac DMG VL</h2><p>该产品符合 Apple 平台设计规范，无需 root 权限安装，只需要拖拽到应用程序下即可，无需登录，没有自动更新程序，也不会提示过期。</p><ul><li>无需 root 权限，拖拽即可安装</li><li>无需登录账号（无需注册，支持离线使用）</li><li>无自动更新程序</li><li>不会提示过期</li><li>可以仅安装单个组件</li></ul><p>包含 Excel、Outlook、PowerPoint 和 Word 四个核心组件，可独立运行单个组件。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608477" alt="Microsoft Excel" title="Microsoft Excel" loading="lazy"/></p><p>Microsoft <strong>Excel</strong>：电子表格和数据分析</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608478" alt="Microsoft Outlook" title="Microsoft Outlook" loading="lazy"/></p><p>Microsoft <strong>Outlook</strong>：电子邮件和日历</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608479" alt="Microsoft PowerPoint" title="Microsoft PowerPoint" loading="lazy"/></p><p>Microsoft <strong>PowerPoint</strong>：创建吸引人的演示文稿</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608480" alt="Microsoft Outlook" title="Microsoft Outlook" loading="lazy"/></p><p>Microsoft <strong>Word</strong>：创建、编辑和分享文档</p><p>备注：OneNote 免费，需要登录。</p><p><strong>Microsoft Office LTSC 2024 for Mac DMG VL v16.89 (Final version)</strong> for macOS Montery 12</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=cG9JYvzqTeJ5wk9zNwQwug%3D%3D.%2FKQejFLrzvDQdWPnBV%2BITyEWx7Q%2FqEEimPivtteQD%2FV33nQ1DRIMYfr1KbAGrQxF" rel="nofollow" target="_blank">https://sysin.org/blog/office-2024-for-mac/</a></li></ul><p><strong>Microsoft Office LTSC 2024 for Mac DMG VL v16.100 (Final version)</strong> for macOS Ventura 13</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=T7aduepF8abL8f2O9JVeMg%3D%3D.QBPdZ605v3gJTval7B4OF8ljlFIBw8NrwXk0Rov%2BQ44CqI%2FfjqeI%2F1RaJfBcag29" rel="nofollow" target="_blank">https://sysin.org/blog/office-2024-for-mac/</a></li></ul><p><strong>Microsoft Office LTSC 2024 for Mac DMG VL v16.106</strong> for macOS Sonoma 14 or later</p><ul><li>支持 macOS Sonoma 14、macOS Sequoia 15 和 macOS Tahoe 26</li><li>请访问：<a href="https://link.segmentfault.com/?enc=3Cze20pXPKf6E9Uj%2F7BdLA%3D%3D.McQKgGj8U%2BU8cjQ3erK9eRPi5KmqooYe39U47vUymKaOwBXhmDoHtwJVeiAL2cyD" rel="nofollow" target="_blank">https://sysin.org/blog/office-2024-for-mac/</a></li></ul><hr/><p>更多：<a href="https://link.segmentfault.com/?enc=aIFQLnheHtSZ3M7UxFrZFw%3D%3D.36maCiuGq66dbxztGJUc8eJ%2FqPxRHHAo14C2INjbJUU%3D" rel="nofollow" target="_blank">macOS 下载汇总 (系统、应用和教程)</a></p>]]></description></item><item>    <title><![CDATA[LockSupport深度解析：线程阻塞与唤醒的底层实现原理 SevenCoding ]]></title>    <link>https://segmentfault.com/a/1190000047598590</link>    <guid>https://segmentfault.com/a/1190000047598590</guid>    <pubDate>2026-02-13 09:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>LockSupport简介</h2><p>LockSupprot 用来阻塞和唤醒线程，底层实现依赖于 <a href="https://link.segmentfault.com/?enc=2jYChfnH9ZWiDDMFfuabdw%3D%3D.iThJ3ygEeLy5ommch6CuKm1B6%2FnXyYPaTWUBgfcLwbZgLB4u3vRHrLReS0ysgNJ3LPiD%2BRG13ADe7%2BA4djCeNA%3D%3D" rel="nofollow" target="_blank">Unsafe 类</a>。</p><p>LockSupport用来创建锁和其他同步类的基本线程阻塞原语。简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可，当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。在AQS中大量使用，AQS最终都是使用LockSupport来阻塞线程的。</p><p>该类包含一组用于阻塞和唤醒线程的静态方法，这些方法主要是围绕 park 和 unpark 展开，话不多说，直接来看一个简单的例子吧。</p><pre><code class="java">public class LockSupportDemo1 {
    public static void main(String[] args) {
        Thread mainThread = Thread.currentThread();

        // 创建一个线程从1数到1000
        Thread counterThread = new Thread(() -&gt; {
            for (int i = 1; i &lt;= 1000; i++) {
                System.out.println(i);
                if (i == 500) {
                    // 当数到500时，唤醒主线程
                    LockSupport.unpark(mainThread);
                }
            }
        });

        counterThread.start();

        // 主线程调用park
        LockSupport.park();
        System.out.println("Main thread was unparked.");
    }
}</code></pre><p>上面的代码中，当 counterThread 数到 500 时，它会唤醒 mainThread。而 mainThread 在调用 park 方法时会被阻塞，直到被 unpark。</p><p>LockSupport 中的方法不多，这里将这些方法做一个总结：</p><h3>阻塞线程</h3><ol><li><code>void park()</code>：阻塞当前线程，如果调用 unpark 方法或线程被中断，则该线程将变得可运行。请注意，park 不会抛出 InterruptedException，因此线程必须单独检查其中断状态。</li><li><code>void park(Object blocker)</code>：功能同方法 1，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。</li><li><code>void parkNanos(long nanos)</code>：阻塞当前线程一定的纳秒时间，或直到被 unpark 调用，或线程被中断。</li><li><code>void parkNanos(Object blocker, long nanos)</code>：功能同方法 3，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。</li><li><code>void parkUntil(long deadline)</code>：阻塞当前线程直到某个指定的截止时间（以毫秒为单位），或直到被 unpark 调用，或线程被中断。</li><li><code>void parkUntil(Object blocker, long deadline)</code>：功能同方法 5，入参增加一个 Object 对象，用来记录导致线程阻塞的对象，方便问题排查。</li></ol><h3>唤醒线程</h3><p><code>void unpark(Thread thread)</code>：唤醒一个由 park 方法阻塞的线程。如果该线程未被阻塞，那么下一次调用 park 时将立即返回。这允许“先发制人”式的唤醒机制。</p><p>实际上，LockSupport 阻塞和唤醒线程的功能依赖于 <code>sun.misc.Unsafe</code>，这是一个很底层的类，比如 LockSupport 的 park 方法是通过 <code>unsafe.park()</code> 方法实现的。</p><h2>LockSupport源码分析</h2><h3>类的属性</h3><pre><code class="java">public class LockSupport {
    // Hotspot implementation via intrinsics API
    private static final sun.misc.Unsafe UNSAFE;
    // 表示内存偏移地址
    private static final long parkBlockerOffset;
    // 表示内存偏移地址
    private static final long SEED;
    // 表示内存偏移地址
    private static final long PROBE;
    // 表示内存偏移地址
    private static final long SECONDARY;
    
    static {
        try {
            // 获取Unsafe实例
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            // 线程类类型
            Class&lt;?&gt; tk = Thread.class;
            // 获取Thread的parkBlocker字段的内存偏移地址
            parkBlockerOffset = UNSAFE.objectFieldOffset
                (tk.getDeclaredField("parkBlocker"));
            // 获取Thread的threadLocalRandomSeed字段的内存偏移地址
            SEED = UNSAFE.objectFieldOffset
                (tk.getDeclaredField("threadLocalRandomSeed"));
            // 获取Thread的threadLocalRandomProbe字段的内存偏移地址
            PROBE = UNSAFE.objectFieldOffset
                (tk.getDeclaredField("threadLocalRandomProbe"));
            // 获取Thread的threadLocalRandomSecondarySeed字段的内存偏移地址
            SECONDARY = UNSAFE.objectFieldOffset
                (tk.getDeclaredField("threadLocalRandomSecondarySeed"));
        } catch (Exception ex) { throw new Error(ex); }
    }
}</code></pre><p>说明: UNSAFE字段表示<a href="https://link.segmentfault.com/?enc=TeLuQsSYqfvr4NkrAdCKKA%3D%3D.rfQII56OH2a4euquJhQKHm64Rlyxfwm2Ork2KiOvQYr9%2FaMnPeDy9xj82Zps8dqjBlAGh3w20bA8cL9%2BkkMqgA%3D%3D" rel="nofollow" target="_blank">sun.misc.Unsafe</a>类，一般程序中不允许直接调用，而long型的表示实例对象相应字段在内存中的偏移地址，可以通过该偏移地址获取或者设置该字段的值。</p><h3>类的构造函数</h3><pre><code class="java">// 私有构造函数，无法被实例化
private LockSupport() {}</code></pre><p>说明: LockSupport只有一个私有构造函数，无法被实例化。</p><h3>核心函数分析</h3><p>在分析LockSupport函数之前，先引入sun.misc.Unsafe类中的park和unpark函数，因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义:</p><pre><code class="java">public native void park(boolean isAbsolute, long time);
public native void unpark(Thread thread);</code></pre><p>说明: 对两个函数的说明如下:</p><ul><li><p>park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞:</p><ul><li>调用unpark函数，释放该线程的许可。</li><li>该线程被中断。</li><li>设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。</li></ul></li><li>unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。</li></ul><h4>park函数</h4><p>park函数有两个重载版本，方法摘要如下</p><pre><code class="java">public static void park()；
public static void park(Object blocker)；</code></pre><p>说明: 两个函数的区别在于park()函数没有没有blocker，即没有设置线程的parkBlocker字段。park(Object)型函数如下。</p><pre><code class="java">public static void park(Object blocker) {
    // 获取当前线程
    Thread t = Thread.currentThread();
    // 设置Blocker
    setBlocker(t, blocker);
    // 获取许可
    UNSAFE.park(false, 0L);
    // 重新可运行后再此设置Blocker
    setBlocker(t, null);
}</code></pre><p>说明: 调用park函数时，首先获取当前线程，然后设置当前线程的parkBlocker字段，即调用setBlocker函数，之后调用Unsafe类的park函数，之后再调用setBlocker函数。那么问题来了，为什么要在此park函数中要调用两次setBlocker函数呢? 原因其实很简单，调用park函数时，当前线程首先设置好parkBlocker字段，然后再调用Unsafe的park函数，此后，当前线程就已经阻塞了，等待该线程的unpark函数被调用，所以后面的一个setBlocker函数无法运行，unpark函数被调用，该线程获得许可后，就可以继续运行了，也就运行第二个setBlocker，把该线程的parkBlocker字段设置为null，这样就完成了整个park函数的逻辑。如果没有第二个setBlocker，那么之后没有调用park(Object blocker)，而直接调用getBlocker函数，得到的还是前一个park(Object blocker)设置的blocker，显然是不符合逻辑的。总之，必须要保证在park(Object blocker)整个函数执行完后，该线程的parkBlocker字段又恢复为null。所以，park(Object)型函数里必须要调用setBlocker函数两次。setBlocker方法如下。</p><pre><code class="java">private static void setBlocker(Thread t, Object arg) {
    // 设置线程t的parkBlocker字段的值为arg
    UNSAFE.putObject(t, parkBlockerOffset, arg);
}</code></pre><p>说明: 此方法用于设置线程t的parkBlocker字段的值为arg。</p><p>另外一个无参重载版本，park()函数如下。</p><pre><code class="java">public static void park() {
    // 获取许可，设置时间为无限长，直到可以获取许可
    UNSAFE.park(false, 0L);
}</code></pre><p>说明: 调用了park函数后，会禁用当前线程，除非许可可用。在以下三种情况之一发生之前，当前线程都将处于休眠状态，即下列情况发生时，当前线程会获取许可，可以继续运行。</p><ul><li>其他某个线程将当前线程作为目标调用 unpark。</li><li>其他某个线程中断当前线程。</li><li>该调用不合逻辑地(即毫无理由地)返回。</li></ul><h4>parkNanos函数</h4><p>此函数表示在许可可用前禁用当前线程，并最多等待指定的等待时间。具体函数如下。</p><pre><code class="java">public static void parkNanos(Object blocker, long nanos) {
    if (nanos &gt; 0) { // 时间大于0
        // 获取当前线程
        Thread t = Thread.currentThread();
        // 设置Blocker
        setBlocker(t, blocker);
        // 获取许可，并设置了时间
        UNSAFE.park(false, nanos);
        // 设置许可
        setBlocker(t, null);
    }
}</code></pre><p>说明: 该函数也是调用了两次setBlocker函数，nanos参数表示相对时间，表示等待多长时间。</p><h4>parkUntil函数</h4><p>此函数表示在指定的时限前禁用当前线程，除非许可可用, 具体函数如下:</p><pre><code class="java">public static void parkUntil(Object blocker, long deadline) {
    // 获取当前线程
    Thread t = Thread.currentThread();
    // 设置Blocker
    setBlocker(t, blocker);
    UNSAFE.park(true, deadline);
    // 设置Blocker为null
    setBlocker(t, null);
}</code></pre><p>说明: 该函数也调用了两次setBlocker函数，deadline参数表示绝对时间，表示指定的时间。</p><h4>unpark函数</h4><p>此函数表示如果给定线程的许可尚不可用，则使其可用。如果线程在 park 上受阻塞，则它将解除其阻塞状态。否则，保证下一次调用 park 不会受阻塞。如果给定线程尚未启动，则无法保证此操作有任何效果。具体函数如下:</p><pre><code class="java">public static void unpark(Thread thread) {
    if (thread != null) // 线程为不空
        UNSAFE.unpark(thread); // 释放该线程许可
}</code></pre><p>说明: 释放许可，指定线程可以继续运行。</p><h2>更深入的理解</h2><h3>与 synchronzed 的区别</h3><p><a href="https://link.segmentfault.com/?enc=jo3YUxDP9f05SJ%2B15isffA%3D%3D.kWBILxLBAbRfHmK0EBJKAVlwmJ51kCRfGUQ%2BLPrRjGlL3tYjrnfYERVI7hOaXM1wy7rGfAHk7YcztPdSICOItmxZOUurB4Is5DMcvymOr%2Fs%3D" rel="nofollow" target="_blank">synchronzed</a> 会使线程阻塞，线程会进入 BLOCKED 状态，而调用 LockSupprt 方法阻塞线程会使线程进入到 WAITING 状态。</p><h3>Thread.sleep()和Object.wait()的区别</h3><p>首先，我们先来看看Thread.sleep()和Object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。</p><ul><li>Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁；</li><li>Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去；</li><li>Thread.sleep()到时间了会自动唤醒，然后继续执行；</li><li>Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒；</li><li>Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁；</li></ul><p>其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。</p><h3>Object.wait()和Condition.await()的区别</h3><p>Object.wait()和Condition.await()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。</p><p>实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。</p><h3>Thread.sleep()和LockSupport.park()的区别</h3><p>LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。</p><ul><li>从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源；</li><li>Thread.sleep()没法从外部唤醒，只能自己醒过来；</li><li>LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒；</li><li>Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出；</li><li>LockSupport.park()方法不需要捕获中断异常；</li><li>Thread.sleep()本身就是一个native方法；</li><li>LockSupport.park()底层是调用的Unsafe的native方法；</li></ul><h3>Object.wait()和LockSupport.park()的区别</h3><p>二者都会阻塞当前线程的运行，他们有什么区别呢? 经过上面的分析相信你一定很清楚了，真的吗? 往下看！</p><ul><li>Object.wait()方法需要在synchronized块中执行；</li><li>LockSupport.park()可以在任意地方执行；</li><li>Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出；</li><li>LockSupport.park()不需要捕获中断异常；</li><li>Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容；</li><li>LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容；</li></ul><p>park()/unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。</p><h3>如果在wait()之前执行了notify()会怎样?</h3><p>如果当前的线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时抛出IllegalMonitorStateException异常；</p><p>如果当前线程是此对象锁的所有者，wait()将一直阻塞，因为后续将没有其它notify()唤醒它。</p><h3>如果在park()之前执行了unpark()会怎样?</h3><p>线程不会被阻塞，直接跳过park()，继续执行后续内容</p><h3>LockSupport.park()会释放锁资源吗?</h3><p>不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。</p>]]></description></item><item>    <title><![CDATA[蓝易云cdn:在conda中如何查看安装的pytorch版本 蓝易云 ]]></title>    <link>https://segmentfault.com/a/1190000047608564</link>    <guid>https://segmentfault.com/a/1190000047608564</guid>    <pubDate>2026-02-13 00:02:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>蓝易云CDN：在 Conda 中如何查看安装的 PyTorch 版本 🧠</h2><p>在多环境开发场景中，确认 PyTorch 版本至关重要，尤其涉及 CUDA 兼容性与模型推理稳定性。以下提供&lt;span style="color:red"&gt;标准且可靠的三种方法&lt;/span&gt;，适用于当前主流 Conda 环境管理方式。</p><hr/><h2>一、方法一：使用 conda list 查询（推荐）🚀</h2><h3>1️⃣ 先激活目标环境</h3><pre><code class="bash">conda activate 环境名</code></pre><h4>命令解释：</h4><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td>conda</td><td>Conda 包管理工具</td></tr><tr><td>activate</td><td>激活指定虚拟环境</td></tr><tr><td>环境名</td><td>例如 pytorch_env</td></tr></tbody></table><p>如果不激活环境，查询到的是 base 环境内容。</p><hr/><h3>2️⃣ 查询 PyTorch 版本</h3><pre><code class="bash">conda list pytorch</code></pre><h4>命令解释：</h4><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td>conda list</td><td>查看当前环境已安装包</td></tr><tr><td>pytorch</td><td>过滤指定包</td></tr></tbody></table><p>示例输出：</p><pre><code>pytorch 2.2.1 py3.10_cuda11.8_cudnn8.7</code></pre><p>说明：</p><ul><li>版本号：2.2.1</li><li>Python版本：3.10</li><li>CUDA版本：11.8</li></ul><p>&lt;span style="color:red"&gt;这是最标准且准确的查询方式&lt;/span&gt;。</p><hr/><h2>二、方法二：通过 Python 内部查看 🐍</h2><p>在激活环境后执行：</p><pre><code class="bash">python</code></pre><p>进入交互模式后输入：</p><pre><code class="python">import torch
print(torch.__version__)</code></pre><h4>代码解释：</h4><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>import torch</td><td>导入 PyTorch 模块</td></tr><tr><td>torch.<strong>version</strong></td><td>输出当前版本</td></tr></tbody></table><p>若输出：</p><pre><code>2.2.1+cu118</code></pre><p>表示：</p><ul><li>主版本 2.2.1</li><li>CUDA 11.8</li></ul><p>若无 CUDA 后缀，说明为 CPU 版本。</p><hr/><h2>三、方法三：查看所有相关组件版本 ⚙️</h2><pre><code class="bash">conda list | grep torch</code></pre><p>作用：</p><ul><li>同时查看 torchvision</li><li>torchtext</li><li>torchaudio</li></ul><p>示例：</p><pre><code>torchvision 0.17.1
torchaudio 2.2.1</code></pre><hr/><h2>四、完整判断流程图 🧩</h2><pre style="display:none;"><code class="mermaid">graph TD
A[激活环境] --&gt; B[conda list pytorch]
B --&gt; C{是否显示版本}
C --&gt;|是| D[确认CUDA版本]
C --&gt;|否| E[检查是否安装]
D --&gt; F[验证 python import torch]</code></pre><hr/><h2>五、版本与CUDA匹配原则 📊</h2><table><thead><tr><th>PyTorch版本</th><th>推荐CUDA版本</th></tr></thead><tbody><tr><td>2.2.x</td><td>11.8 / 12.1</td></tr><tr><td>2.1.x</td><td>11.8</td></tr><tr><td>1.13.x</td><td>11.6</td></tr></tbody></table><p>⚠️ 注意：</p><p>&lt;span style="color:red"&gt;PyTorch 的 CUDA 版本必须与系统驱动兼容&lt;/span&gt;。</p><p>可检查驱动：</p><pre><code class="bash">nvidia-smi</code></pre><p>解释：</p><ul><li>查看 GPU 驱动版本</li><li>判断是否支持当前 CUDA</li></ul><hr/><h2>六、核心总结 🎯</h2><p>在 Conda 中查看 PyTorch 版本的关键步骤：</p><ol><li>&lt;span style="color:red"&gt;激活正确环境&lt;/span&gt;</li><li>使用 &lt;span style="color:red"&gt;conda list pytorch&lt;/span&gt;</li><li>通过 &lt;span style="color:red"&gt;python + torch.<strong>version</strong> 双重验证&lt;/span&gt;</li></ol><p>开发中最常见错误不是版本太低，而是：</p><ul><li>查错环境</li><li>CUDA 与驱动不匹配</li></ul><p>严谨的做法永远是：<br/>环境确认 → 版本确认 → CUDA确认 → 驱动确认。</p><p>并发算力与框架稳定性，本质来自版本匹配，而不是版本最新。 🔍</p>]]></description></item><item>    <title><![CDATA[蓝易云cdn:dockers搭建基本服务 蓝易云 ]]></title>    <link>https://segmentfault.com/a/1190000047608566</link>    <guid>https://segmentfault.com/a/1190000047608566</guid>    <pubDate>2026-02-13 00:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>蓝易云CDN：Docker 搭建基本服务完整指南 🚀</h2><p>在现代运维体系中，Docker 已成为部署基础服务的标准工具。其核心优势是：&lt;span style="color:red"&gt;环境隔离、快速部署、可移植性强&lt;/span&gt;。下面给出标准化搭建流程与示例。</p><hr/><h2>一、安装 Docker（以 Ubuntu 为例）⚙️</h2><h3>1️⃣ 更新系统</h3><pre><code class="bash">sudo apt update</code></pre><p>解释：</p><ul><li><code>apt update</code>：同步软件仓库索引</li><li>确保后续安装使用最新包信息</li></ul><hr/><h3>2️⃣ 安装 Docker</h3><pre><code class="bash">sudo apt install -y docker.io</code></pre><p>解释：</p><ul><li><code>docker.io</code>：Ubuntu 官方仓库中的 Docker 引擎</li><li><code>-y</code>：自动确认安装</li></ul><hr/><h3>3️⃣ 启动并设置开机自启</h3><pre><code class="bash">sudo systemctl enable docker
sudo systemctl start docker</code></pre><p>解释：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>enable</td><td>开机自动启动</td></tr><tr><td>start</td><td>立即启动服务</td></tr></tbody></table><p>验证：</p><pre><code class="bash">docker --version</code></pre><p>若显示版本号说明安装成功。</p><hr/><h2>二、Docker 基本概念说明 🧠</h2><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Image</td><td>镜像，运行模板</td></tr><tr><td>Container</td><td>容器，运行实例</td></tr><tr><td>Volume</td><td>数据卷，持久存储</td></tr><tr><td>Network</td><td>网络模式</td></tr></tbody></table><p>简单模型公式：</p><pre><code>容器 = 镜像 + 运行参数 + 资源限制</code></pre><hr/><h2>三、搭建 Nginx 服务示例 🌐</h2><h3>1️⃣ 拉取镜像</h3><pre><code class="bash">docker pull nginx</code></pre><p>解释：</p><ul><li>从官方镜像仓库下载 nginx 镜像</li></ul><hr/><h3>2️⃣ 运行容器</h3><pre><code class="bash">docker run -d -p 80:80 --name mynginx nginx</code></pre><p>解释：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>后台运行</td></tr><tr><td>-p 80:80</td><td>宿主机80映射容器80</td></tr><tr><td>--name</td><td>容器名称</td></tr><tr><td>nginx</td><td>使用的镜像</td></tr></tbody></table><p>访问服务器IP即可看到默认页面。</p><hr/><h2>四、搭建 MySQL 服务示例 🗄</h2><pre><code class="bash">docker run -d \
-p 3306:3306 \
--name mysql8 \
-e MYSQL_ROOT_PASSWORD=123456 \
-v /data/mysql:/var/lib/mysql \
mysql:8</code></pre><p>解释：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e</td><td>设置环境变量</td></tr><tr><td>MYSQL_ROOT_PASSWORD</td><td>root密码</td></tr><tr><td>-v</td><td>数据持久化映射</td></tr><tr><td>mysql:8</td><td>指定版本</td></tr></tbody></table><p>&lt;span style="color:red"&gt;数据必须挂载数据卷，否则删除容器数据会丢失&lt;/span&gt;。</p><hr/><h2>五、推荐使用 docker-compose 管理多服务 🧩</h2><p>创建 <code>docker-compose.yml</code>：</p><pre><code class="yaml">version: '3'
services:
  nginx:
    image: nginx
    ports:
      - "80:80"
  mysql:
    image: mysql:8
    environment:
      MYSQL_ROOT_PASSWORD: 123456
    volumes:
      - ./mysql:/var/lib/mysql</code></pre><p>启动：</p><pre><code class="bash">docker compose up -d</code></pre><p>解释：</p><ul><li><code>compose up</code>：创建并启动服务</li><li><code>-d</code>：后台运行</li></ul><hr/><h2>六、部署流程图 📊</h2><pre style="display:none;"><code class="mermaid">graph TD
A[安装Docker] --&gt; B[拉取镜像]
B --&gt; C[运行容器]
C --&gt; D[配置端口映射]
D --&gt; E[配置数据卷]
E --&gt; F[服务上线]</code></pre><hr/><h2>七、基础服务推荐结构 🔐</h2><table><thead><tr><th>服务类型</th><th>建议部署方式</th></tr></thead><tbody><tr><td>Web服务</td><td>Nginx容器</td></tr><tr><td>数据库</td><td>独立容器 + 数据卷</td></tr><tr><td>缓存</td><td>Redis容器</td></tr><tr><td>API</td><td>应用镜像</td></tr></tbody></table><hr/><h2>八、生产环境注意事项 ⚠️</h2><ol><li>&lt;span style="color:red"&gt;不要使用 latest 标签&lt;/span&gt;</li><li>必须挂载数据卷</li><li>限制容器资源：</li></ol><pre><code class="bash">--memory="1g" --cpus="1.0"</code></pre><p>解释：</p><ul><li>限制容器最大内存</li><li>限制CPU核心使用率</li></ul><hr/><h2>九、总结 🎯</h2><p>Docker 搭建基本服务的核心逻辑是：</p><ul><li>安装引擎</li><li>拉取镜像</li><li>配置端口</li><li>持久化数据</li><li>合理限制资源</li></ul><p>容器不是虚拟机，而是进程级隔离。<br/>真正的稳定部署来自：</p><p>&lt;span style="color:red"&gt;版本固定 + 数据持久化 + 资源限制&lt;/span&gt;。</p><p>基础架构稳，业务才稳。 🚀</p>]]></description></item><item>    <title><![CDATA[【MATLAB源码】6G：XL-MIMO 混合场信道估计仿真平台 3GPP仿真实验室 ]]></title>    <link>https://segmentfault.com/a/1190000047608372</link>    <guid>https://segmentfault.com/a/1190000047608372</guid>    <pubDate>2026-02-12 22:05:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>&lt;p align="center"&gt;<br/>  &lt;h1 align="center"&gt;Hybrid-Field XL-MIMO 混合场信道估计仿真平台&lt;/h1&gt;<br/>  &lt;p align="center"&gt;</p><pre><code>&lt;strong&gt;完整的混合场信道估计实现：建模 → 网格内恢复 → 离网细化 → 结果可视化&lt;/strong&gt;</code></pre><p>&lt;/p&gt;<br/>&lt;/p&gt;</p><hr/><h2>🚀 为什么选择本仿真平台？</h2><table><thead><tr><th align="left">痛点</th><th align="left">本平台解决方案</th></tr></thead><tbody><tr><td align="left">XL-MIMO 远近场共存，建模容易失配</td><td align="left">✅ <strong>远场 DFT + 近场极域联合字典</strong>，统一建模混合传播机理</td></tr><tr><td align="left">远场占比 ($\gamma$) 先验难以准确给定</td><td align="left">✅ 提供 <strong>无 ($\gamma$) 比例搜索</strong>，自动完成远近场路径分配</td></tr><tr><td align="left">离网优化容易震荡或发散</td><td align="left">✅ <code>SIGW</code> 内置 <strong>单调下降 + 回溯线搜索 + 坐标回退 + 岭正则</strong> 稳定机制</td></tr><tr><td align="left">只看均值曲线难以评估稳健性</td><td align="left">✅ 内置 <strong>CDF / Pareto / 相图 / 支撑图</strong> 四类强相关演示</td></tr><tr><td align="left">复现实验路径分散</td><td align="left">✅ 提供 <code>main_all_experiments</code> 与图集脚本，支持一键复现</td></tr></tbody></table><hr/><h2>🌟 核心价值</h2><table>
<tr>
<td width="50%">

### 📘 学术研究价值

- 混合场（远场+近场）统一信道建模
- 无先验 (\gamma) 的支撑搜索机制验证
- 网格内估计与离网细化协同流程完整复现
- 精度、复杂度、运行时间三维对比评估

</td>
<td width="50%">

### 🛠️ 工程应用价值

- 单天线与多天线两套实验链路
- 快速模式与完整模式双配置
- 自动保存图像与结果数据（不带日期命名）
- 中文详细注释，便于二次开发与教学演示

</td>
</tr>
</table><hr/><h2>⚡ 技术亮点</h2><h3>1) Hybrid-Field 估计系统架构</h3><pre><code class="text">┌───────────────────────────────────────────────────────────────────────────────┐
│                Hybrid-Field XL-MIMO 信道估计与可视化链路                     │
├───────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  混合场信道生成 ──► 加噪观测 y ──► 联合字典构建 D=[Af, An]                   │
│      │                  │                   │                                  │
│  Far/Near/LoS       SNR 控制           远场 DFT + 近场极域                    │
│                                                                               │
│                 ┌──────────── 网格内恢复（On-grid）────────────┐              │
│                 │  Hybrid OMP / Hybrid SGP / 无γ比例搜索        │              │
│                 └────────────────────────────────────────────────┘              │
│                                       │                                       │
│                                       ▼                                       │
│                 ┌──────────── 离网细化（Off-grid SIGW）──────────┐            │
│                 │  数值梯度 + 回溯线搜索 + 坐标回退 + 岭回归      │            │
│                 └────────────────────────────────────────────────┘            │
│                                       │                                       │
│                                       ▼                                       │
│                 NMSE / SE / 复杂度 / CDF / Pareto / 相图 / 支撑图            │
└───────────────────────────────────────────────────────────────────────────────┘</code></pre><h3>2) 性能指标（本地 quick 配置实测，2026-02-12）</h3><table><thead><tr><th align="left">场景</th><th align="left">指标定义</th><th align="left">实测结果</th></tr></thead><tbody><tr><td align="left">单天线 SNR=0 dB</td><td align="left"><code>HF-SGP(no-γ)</code> 对比 <code>Off-grid HF-SGP(no-γ)</code></td><td align="left"><strong>+3.79 dB</strong> NMSE 增益（-4.16 dB → -7.95 dB）</td></tr><tr><td align="left">单天线 SNR=4 dB</td><td align="left"><code>HF-SGP(no-γ)</code> 对比 <code>Off-grid HF-SGP(no-γ)</code></td><td align="left"><strong>+6.01 dB</strong> NMSE 增益（-3.66 dB → -9.67 dB）</td></tr><tr><td align="left"><code>demo_polar_support_map</code></td><td align="left">单样本离网收益</td><td align="left"><strong>+3.95 dB</strong></td></tr><tr><td align="left"><code>demo_sigw_convergence</code></td><td align="left">单样本离网收益</td><td align="left"><strong>+4.39 dB</strong></td></tr><tr><td align="left"><code>demo_snr_gamma_phase_map</code></td><td align="left">离网增益为正的网格占比</td><td align="left"><strong>100%</strong></td></tr><tr><td align="left"><code>demo_nmse_cdf_pareto</code></td><td align="left">Off-grid 相对 HF-SGP 的均值收益/时延</td><td align="left"><strong>+1.56 dB</strong> / <strong>+21.04 ms</strong></td></tr></tbody></table><blockquote>📌 说明：以上数据来自项目当前代码在本机快速配置下的直接运行结果，用于展示方法趋势与工程可复现性。</blockquote><hr/><h2>🖥️ 运行环境</h2><h3>最低要求</h3><table><thead><tr><th align="left">项目</th><th align="left">要求</th></tr></thead><tbody><tr><td align="left"><strong>MATLAB 版本</strong></td><td align="left">R2021b 或更高</td></tr><tr><td align="left"><strong>必需工具箱</strong></td><td align="left">基础 MATLAB 即可（推荐安装常用信号处理相关工具箱）</td></tr><tr><td align="left"><strong>操作系统</strong></td><td align="left">Windows 10/11、macOS、Linux</td></tr><tr><td align="left"><strong>内存</strong></td><td align="left">8 GB+（大规模 Monte-Carlo 建议 16 GB+）</td></tr></tbody></table><h3>快速验证</h3><pre><code class="matlab">% 进入项目根目录后
run_smoke_test

% 一键运行强相关图集
run_related_figure_gallery(true)</code></pre><hr/><h2>📐 算法原理（项目对应版）</h2><h3>1) 混合场信道模型</h3><p>$$
\mathbf{h}=\sum_{\ell=1}^{L_f} \beta_{f,\ell}\,\mathbf{a}_f(\theta_{f,\ell})
+\sum_{\ell=1}^{L_n} \beta_{n,\ell}\,\mathbf{a}_n(r_{\ell},\theta_{n,\ell})
+\mathbf{h}_{\mathrm{LoS}}.
$$</p><h3>2) 联合字典建模</h3><p>$$
\mathbf{D}=[\mathbf{A}_f,\mathbf{A}_n],
\qquad
\min_{\mathbf{g}}\|\mathbf{y}-\mathbf{D}\mathbf{g}\|_2^2
\;\text{s.t.}\;\|\mathbf{g}\|_0\le K.
$$</p><h3>3) 无 ($\gamma$) 比例搜索</h3><p>$$
\hat{\gamma}
=\arg\min_{\gamma\in\Gamma}
\left(
\min_{\mathbf{g}:\operatorname{supp}(\mathbf{g})\in\mathcal{S}(\gamma)}
\|\mathbf{y}-\mathbf{D}\mathbf{g}\|_2^2
\right),
\quad
\Gamma=\left\{\frac{L-1}{L},\frac{L-2}{L},\dots,0\right\}.
$$</p><h3>4) SIGW 离网细化目标</h3><p>$$
J(\Theta,\mathbf{g})=\|\mathbf{y}-\mathbf{A}(\Theta)\mathbf{g}\|_2^2 + \lambda\|\mathbf{g}\|_2^2,
$$</p><p>$$
\mathbf{g}^*(\Theta)=\left(\mathbf{A}^H\mathbf{A}+\lambda\mathbf{I}\right)^{-1}\mathbf{A}^H\mathbf{y}.
$$</p><p>通过“回溯线搜索 + 坐标回退”保证优化过程稳定，缓解高 SNR 区域的网格失配误差。</p><hr/><h2>📁 项目结构</h2><pre><code class="text">hmimo ce/
├── main_all_experiments.m             # 一键总入口（主实验+演示）
│
├── src/
│   ├── common/                        # 配置、字典、信道、流形、路径、存图
│   │   ├── hf_default_config.m
│   │   ├── hf_build_dictionaries_single.m
│   │   ├── hf_build_dictionaries_multi.m
│   │   ├── hf_qua_codebook.m
│   │   ├── hf_generate_hybrid_channel_single.m
│   │   ├── hf_generate_hybrid_channel_multi.m
│   │   └── ...
│   │
│   ├── estimators/                    # OMP / SGP / Hybrid / SIGW
│   │   ├── hf_hybrid_omp.m
│   │   ├── hf_hybrid_omp_nogamma.m
│   │   ├── hf_hybrid_sgp.m
│   │   ├── hf_hybrid_sgp_nogamma.m
│   │   ├── hf_sigw_single.m
│   │   ├── hf_sigw_multi.m
│   │   └── ...
│   │
│   └── metrics/                       # NMSE / SE / 复杂度
│       ├── hf_compute_complexity.m
│       └── hf_compute_se_mr.m
│
├── experiments/                       # 主实验脚本
│   ├── run_single_snr_experiment.m
│   ├── run_multi_snr_experiment.m
│   ├── run_multi_se_experiment.m
│   ├── run_complexity_experiment.m
│   └── ...
│
├── demos/                             # 强相关演示图
│   ├── demo_polar_support_map.m
│   ├── demo_sigw_convergence.m
│   ├── demo_nmse_cdf_pareto.m
│   ├── demo_snr_gamma_phase_map.m
│   └── run_related_figure_gallery.m
│
├── docs/
│   ├── 算法文档.md
│   ├── 代码文档.md
│
└── results/
    ├── data/                          # .mat 结果文件
    └── figures/                       # 自动保存图像（无日期命名）</code></pre><p><strong>代码统计（当前工程）</strong>：</p><ul><li><code>40</code> 个 <code>.m</code> 文件</li><li>约 <code>4085</code> 行 MATLAB 代码</li><li>核心模块全部中文详细注释</li></ul><hr/><h2>🧪 仿真演示</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608374" alt="multi_se_vs_snr.png" title="multi_se_vs_snr.png"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608375" alt="single_nmse_vs_paths.png" title="single_nmse_vs_paths.png" loading="lazy"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608376" alt="single_nmse_vs_snr.png" title="single_nmse_vs_snr.png" loading="lazy"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608377" alt="demo_nmse_cdf.png" title="demo_nmse_cdf.png" loading="lazy"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608378" alt="demo_pareto_tradeoff.png" title="demo_pareto_tradeoff.png" loading="lazy"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608379" alt="demo_polar_support_dual.png" title="demo_polar_support_dual.png" loading="lazy"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608380" alt="demo_far_support_compare.png" title="demo_far_support_compare.png" loading="lazy"/></p><hr/><h2>✅ 您将获得</h2><table><thead><tr><th align="left">内容</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>完整混合场源码</strong></td><td align="left">远场/近场字典、信道生成、OMP/SGP、离网细化全覆盖</td></tr><tr><td align="left"><strong>双层文档体系</strong></td><td align="left"><code>算法文档.md/.docx</code> + <code>代码文档.md</code> + 本 <code>项目文档.md</code></td></tr><tr><td align="left"><strong>强相关演示图集</strong></td><td align="left">支撑图、收敛图、CDF/Pareto、SNR-γ 相图</td></tr><tr><td align="left"><strong>可复现实验脚本</strong></td><td align="left">单天线、多天线、SE、复杂度、一键总入口</td></tr><tr><td align="left"><strong>工程化输出机制</strong></td><td align="left">自动存图、自动存 <code>mat</code>、命名稳定（无日期）</td></tr><tr><td align="left"><strong>可扩展开发骨架</strong></td><td align="left">新算法、新配置、新图表可按现有接口平滑扩展</td></tr></tbody></table><hr/><h2>▶️ 一键运行建议</h2><pre><code class="matlab">% 1) 基础冒烟验证
run_smoke_test

% 2) 单天线核心性能
run_single_snr_experiment(false)

% 3) 多天线核心性能
run_multi_snr_experiment(false)

% 4) 频谱效率与复杂度
run_multi_se_experiment(false)
run_complexity_experiment

% 5) 强相关图集
run_related_figure_gallery(true)

% 6) 全部任务一键执行
main_all_experiments</code></pre><hr/><h2>🛒 获取方式</h2><p>本文代码仅为核心片段，完整版工程已整理好。 关注公众号 【<strong>3GPP仿真实验室</strong>】进行获取。</p>]]></description></item><item>    <title><![CDATA[macOS Tahoe 26.3 (25D125) 正式版 ISO、IPSW、PKG 下载 sysi]]></title>    <link>https://segmentfault.com/a/1190000047608392</link>    <guid>https://segmentfault.com/a/1190000047608392</guid>    <pubDate>2026-02-12 22:04:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>macOS Tahoe 26.3 (25D125) 正式版 ISO、IPSW、PKG 下载</p><p>Liquid Glass 惊艳新设计亮相，电话 app 和实时活动丰富连续互通体验，聚焦搜索迎来最大更新</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=zoxEb0GLtG0I7nIlPI%2FPJA%3D%3D.fRQmoElu23JRTMEPt6w1fFuWjrWddVelxDYi9juRl3%2B3NMLv8WKmUkjvIauyniyn" rel="nofollow" target="_blank">https://sysin.org/blog/macos-tahoe/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=q61BZJTWVeHyzbL15gNtBg%3D%3D.bv3J8YCdFUvKYp9rPGYzj%2Fh0pttu7jSGzWOanWLT3K0%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>2026 年 2 月 12 日凌晨，Apple 发布 iOS/iPadOS/macOS/watchOS/tvOS/visonOS 全平台 26.3 版本更新。macOS Tahoe 26.3 此次为常规问题修复和安全更新。</p><h2>macOS Tahoe 让 Mac 更强大 更高效 更智能</h2><p>惊艳新设计亮相，电话 app 和实时活动丰富连续互通体验，聚焦搜索迎来最大更新</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046624380" alt="16 英寸 MacBook Pro、iMac 和 13 英寸 MacBook Air。" title="16 英寸 MacBook Pro、iMac 和 13 英寸 MacBook Air。"/></p><p>macOS Tahoe 26 推出精美新设计、丰富的连续互通体验及更多功能，强势助推生产力。</p><p><strong>加利福尼亚州，库比提诺</strong> Tim Cook 领导的 Apple 今日预览了新一代 macOS——macOS Tahoe 26，推出惊艳新设计和诸多强大功能，赋能用户完成更多任务。macOS 的新设计让桌面、程序坞、app  内导览和工具栏等经典元素更加灵动活泼、赏心悦目且契合用户个性需求，同时延续了原有的熟悉感。用户可使用更新版控制中心和文件夹、app  图标与小组件的新色彩选项，进一步打造个性化体验。随着 Mac 版电话 app  的推出，连续互通功能进一步提升，用户可轻松使用最近通话、通讯录和语音留言等 iPhone 版电话 app  的全部功能，以及通话筛选和通话保留助理等新功能 (sysin)。依托 iPhone 实时活动，用户可直接在 Mac  上实时掌握正在进行的活动，如航班信息等。聚焦搜索迎来迄今最大更新，用户现可直接执行数百项操作，如发送电子邮件或创建备忘录等，并利用全新浏览体验更快捷地访问内容。</p><p>“macOS 是 Mac 的核心与灵魂，Tahoe 则将深受用户喜爱的功能发扬光大。无论资深用户还是 Mac  新手，都能借助更多功能提高效率，更顺畅地利用 Mac 和 iPhone 协同工作。”Apple 软件工程高级副总裁 Craig  Federighi 表示，“令人惊艳的新设计、奇妙的连续互通体验、聚焦搜索的强大提升、更多智能快捷指令和 Apple 智能的更新让 Mac  体验更胜以往。”</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046624381" alt="一台 iMac 上显示着设计一新的主屏幕。" title="一台 iMac 上显示着设计一新的主屏幕。" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046624382" alt="一台 MacBook Pro 上显示着深色调的新设计。" title="一台 MacBook Pro 上显示着深色调的新设计。" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046624383" alt="一台 MacBook Pro 上显示着设计一新的主屏幕。 " title="一台 MacBook Pro 上显示着设计一新的主屏幕。 " loading="lazy"/></p><p>图：新设计解锁了个性化设置 Mac 的更多方式。</p><h2>macOS Tahoe 硬件兼容性列表</h2><p>笔者提示：“Apple Intelligence” 及相关功能要求 <a href="https://link.segmentfault.com/?enc=oGQmdWvHavaJD91Ro767Qw%3D%3D.WfejsiKv9WE6p4S3x9ww8MYjxvtCU5up7QF9dRkqNWfmAfwHLHOkVL4xybOTLGdp" rel="nofollow" target="_blank">搭载 Apple 芯片的 Mac 电脑</a>。</p><p>看看你的 Mac 是否能用 macOS Tahoe</p><p><a href="https://link.segmentfault.com/?enc=3hYwQlyQb79o28s%2F0CFxqA%3D%3D.Soxo8Qiqz8LSuFp8xpegU0vnTEMpf2%2BnBN0QwdsNjF0%3D" rel="nofollow" target="_blank">进一步了解 Mac&gt;</a></p><ul><li><strong>MacBook Air</strong> with Apple silicon 2020 and later <a href="https://link.segmentfault.com/?enc=qahyKhdMiXSdNzB2t5dCCg%3D%3D.WcgLFNZZXPkolOYEEKrVlqY4uyy7XAyH%2Fms7ieLAaK2AWjlDq6y%2F3Afpt9uyrpVp" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>MacBook Pro</strong> with Apple silicon (2020 and later) <a href="https://link.segmentfault.com/?enc=hVoBV%2BpTQK1sXZJSZz5Tnw%3D%3D.iRVolvyb2krOvkxViYLZ2eCjFuRZRnO67MIDG4glmwcnXILloOIEiGXD9vvIJSAO" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>MacBook Pro</strong> 2019 <a href="https://link.segmentfault.com/?enc=eg6NGDa5YL%2FaCe2%2BIzhojQ%3D%3D.o9mhCORlrvkxohOTVNgY54fLP84lTZSv%2F9FzC9KntchCGkSj285DZ4VEy1V7SLLW" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>MacBook Pro</strong> (13‑inch, 2020, Four Thunderbolt 3 ports) <a href="https://link.segmentfault.com/?enc=TslWxEiRjYKwEJvxAi3KEQ%3D%3D.tKgD3ACEedLQnia7Kgm9yK%2FedPGkvnUhJZ0LbsKd9oLYuVsTjybOcnW5jrSJvnuA" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>Mac mini</strong> 2020 and later <a href="https://link.segmentfault.com/?enc=WaxuyYdIBF8pSp95B3UunA%3D%3D.FuIdxCvXBXncaghdT13mdSn3VHuUzIA7c19YfYM%2FQUue8oSFwDp7zoO8jh6jB0Ya" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>Mac Studio</strong> 2022 <a href="https://link.segmentfault.com/?enc=s9BMOWWhSgtgI5J8vf48LA%3D%3D.NI0PyxNWpQHVevB%2BcA318tjgFI4TUlKgfGefS48dyMfcO0Vh1fI6w9NRnkSkocKQ" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>Mac Pro</strong> 2019 and later <a href="https://link.segmentfault.com/?enc=vSTako4FVLzciwAruYaY4A%3D%3D.fctK6fNdpozgbHkck8dLHbU2AlMoksGzzi9PF%2BWoik3gCMV9exND9JimxGAhOEcy" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>iMac</strong> 2020 and later <a href="https://link.segmentfault.com/?enc=e9WV8iCrjXCtO%2FQX8gGpJA%3D%3D.ZXJhCmQrVt591R6Z4hm%2BiGMBVwUCsORsxUDEiPzhM8yRrAs2lvfHss8p1oKyVyGC" rel="nofollow" target="_blank">进一步了解 &gt;</a></li></ul><p>如果你的 Mac 不在兼容性列表，参看：<a href="https://link.segmentfault.com/?enc=Vn9SgV0l20KEVoKB92qNtQ%3D%3D.tFlHcceEhIO6ogY4EW5rf75qjP4enGAvUe4g4ZFA%2BCgIEkZA%2FH%2FF5sojc3P6d4GNz%2Bsm7hqb0OlohKV9UlxCqg%3D%3D" rel="nofollow" target="_blank">在不受支持的 Mac 上安装 macOS Tahoe 26</a></p><h2>macOS Tahoe 版本历史</h2><p>Software Releases</p><ul><li>macOS Tahoe 26.3 (25D125) - 2026.02.11</li><li>macOS Tahoe 26.2 (25C56) - 2025.12.12</li><li>macOS Tahoe 26.1 (25B78) - 2025.11.03</li><li>macOS Tahoe 26.0.1 (25A362) - 2025.09.30</li><li>macOS Tahoe 26 (25A354) - 2025.09.15</li><li>macOS 26 RC (25A353) - 2025.09.09</li><li>macOS 26 beta 9 (25A5351b) - 2025.09.03</li><li>macOS 26 beta 8 (25A5349a) - 2025.08.25</li><li>macOS 26 beta 7 (25A5346a) - 2025.08.19</li><li>macOS 26 beta 6 (25A5338b) - 2025.08.12</li><li>macOS 26 beta 5 (25A5327h) - 2025.08.06</li><li>macOS 26 beta 4 (25A5316i) - 2025.07.22</li><li>macOS 26 beta 3 (25A5306g) - 2025.07.08</li><li>macOS 26 beta 2 (25A5295e) - 2025.06.23</li><li>macOS 26 beta (25A5279m) - 2025.06.09</li></ul><h2>下载 macOS Tahoe</h2><p>💡 <a href="https://link.segmentfault.com/?enc=ehJjVymVUfZspur%2Bu%2FV7Pw%3D%3D.2zezN2x8tGH8xZjxcHs4FLDb%2FEAcM8I0%2BFt9ELxfnwQ%3D" rel="nofollow" target="_blank">如何校验本站下载的文件的完整性</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047305036" alt="macOS Tahoe" title="macOS Tahoe" loading="lazy"/></p><h3>(1) ISO 格式软件包 (推荐)</h3><blockquote><p>本站原创可引导映像，可以在当前系统中安装或者升级，可以通过 USB 存储引导安装，也可以用于虚拟机安装。</p><p>此版本更多介绍请参看：<a href="https://link.segmentfault.com/?enc=1W3SRIHHQMfCGaXYrtnp%2FA%3D%3D.4rilMuIrWN3qvODQXCfOu9tv4F%2Fgihx5apIddwE8YiWiROwZ2zGoRG66qxpfBFRJ" rel="nofollow" target="_blank">macOS Tahoe 26 Boot ISO 原版可引导映像下载</a></p></blockquote><ul><li>macOS Tahoe 26.3 (25D125) - 2026.02.11</li><li>macOS Tahoe 26.2 (25C56) - 2025.12.12</li><li>macOS Tahoe 26.1 (25B78) - 2025.11.03</li><li>macOS Tahoe 26.0.1 (25A362) - 2025.09.30</li><li><p>macOS Tahoe 26 (25A354) - 2025.09.15</p><ul><li>下载地址：<a href="https://link.segmentfault.com/?enc=MITygpzXcQdkjyCyQHKzVQ%3D%3D.vmnJiieurov0UxJncun8t9CMhvJ1krOSRURYnqO%2Bf16LGdPDg5vTTgsS5bp6q1Ic" rel="nofollow" target="_blank">https://sysin.org/blog/macos-tahoe/</a></li></ul></li></ul><p>参看：<a href="https://link.segmentfault.com/?enc=5y47AE41xm25LxwBeJUpsA%3D%3D.yFXNyZNsOg2JHZsCNSXVqi3kQfl7u4luhXnb2EeocNaAm7%2F9gUy6ERYVc8%2FxoC85" rel="nofollow" target="_blank">如何在 Mac 和虚拟机上安装 macOS Sequoia、macOS Sonoma 和 macOS Ventura</a></p><h3>(2) PKG 格式软件包</h3><blockquote>该格式软件包双击运行后将自动安装在 <code>/Applications</code> 下。</blockquote><ul><li>macOS Tahoe 26.3 (25D125) - 2026.02.11</li><li>macOS Tahoe 26.2 (25C56) - 2025.12.12</li><li>macOS Tahoe 26.1 (25B78) - 2025.11.03</li><li>macOS Tahoe 26.0.1 (25A362) - 2025.09.30</li><li><p>macOS Tahoe 26 (25A354) - 2025.09.15</p><ul><li>下载地址：<a href="https://link.segmentfault.com/?enc=4haWcB%2Fpx9rIbO4CBhfhEg%3D%3D.%2Fmh%2BEQ2CDtWWnZJUDfTcp38z2S1qJDXx0BTYjDEgy9cysjRFbcXh81RK7mCPj%2FKA" rel="nofollow" target="_blank">https://sysin.org/blog/macos-tahoe/</a></li></ul></li></ul><h3>(3) IPSW 固件 (Apple 芯片 Mac 专用)</h3><blockquote>IPSW 格式为搭载 Apple 芯片的 Mac 专用映像，其他格式通用。</blockquote><p>适用于：<a href="https://link.segmentfault.com/?enc=B5tKBfmu%2FN2Zlbvfd99Cvg%3D%3D.OWW4genhdsoMyCGtw6yqPkcCBLOdCTWuuvNcmyR9D%2B35%2FosRMh0Q6pxWpgNOr5Vh" rel="nofollow" target="_blank">搭载 Apple 芯片的 Mac 电脑</a></p><p>参看：<a href="https://link.segmentfault.com/?enc=uyL3lQ%2Fmn%2FyCztJiUJ%2Bhww%3D%3D.GRAKeBO%2BQ10B7rJ5XFIc72EO6UzZQHR37xED7z7kGvYzYzM5AAKYAgVN9%2BeOwE4B" rel="nofollow" target="_blank">使用 DFU 模式修复或恢复 Mac 固件</a></p><ul><li>macOS Tahoe 26.3 (25D125) - 2026.02.11</li><li>macOS Tahoe 26.2 (25C56) - 2025.12.12</li><li>macOS Tahoe 26.1 (25B78) - 2025.11.03</li><li>macOS Tahoe 26.0.1 (25A362) - 2025.09.30</li><li><p>macOS Tahoe 26 (25A354) - 2025.09.15</p><ul><li>下载地址：<a href="https://link.segmentfault.com/?enc=n0Rdlici51SjcrhAe14ZEg%3D%3D.Q2UFa2SF2U%2B%2F2C4gjk8JLtit%2FnRZmrDk6ot58Etlk2Oq2rPjfKBXt9D8x6Kz6JCK" rel="nofollow" target="_blank">https://sysin.org/blog/macos-tahoe/</a></li></ul></li></ul><h3>(4) App Store 链接</h3><p><code>待上架</code></p><p>或者打开 App Store 搜索 “macOS Tahoe” 即可下载（下载的是当前最新版）。</p><h2>适用的 VMware 软件下载链接</h2><p>建议在以下版本的 VMware 软件中运行（Linux OVF 无需本站定制版可以正常运行，macOS 虚拟化如果不是 Mac 必须使用定制版才能运行，Windows OVF 需要定制版才能启用完整功能）：</p><ul><li><p>VMware vSphere：</p><ul><li>VMware <a href="https://link.segmentfault.com/?enc=edtuzNRXmYvfkd4tfSGIkg%3D%3D.5AWfi74BZCe0C0tZ1qLpnpC5Yp7iEbnureZBxjKp1WdEsxclVQkbZBXH34CVetWo" rel="nofollow" target="_blank">ESXi 9</a> or <a href="https://link.segmentfault.com/?enc=3VW3IN0QS4IjsqxpNYqFmA%3D%3D.MYGtYDsHwjzac1k4SJ5UuNPzTkQIEXRrlz8803DmGNUVm0eu%2B2kGamQTB8j1W6Io" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=JOHmlyVV5ks5LQ0YWv392w%3D%3D.7GSGK3D3IPstOj6gPthdbbBFKZc6gM3R4WBoR393XZfocTpIoVRZARDJakBMGth%2F" rel="nofollow" target="_blank">vCenter Server 9</a> &amp; <a href="https://link.segmentfault.com/?enc=SuDzyw9R9Lzm5ZgzMBHJeQ%3D%3D.LEOLhxErpU0llER1XlBR8%2FxMzwiDpLC1%2BBBY%2BushYvy8ULmlfGvJRLTEaIakhDbdkwZJ%2BwHQh4yYwsk%2F7nsp%2Bg%3D%3D" rel="nofollow" target="_blank">VCF Operations 9</a></li><li>VMware <a href="https://link.segmentfault.com/?enc=494mo6YvMFtt8La6JhU79g%3D%3D.IOfqOQVnTElW1iaWOtMAFf8oWYE39hcOKfnFDu0CdfedHNSKpUQpEht7roZy4io1" rel="nofollow" target="_blank">ESXi 8</a> or <a href="https://link.segmentfault.com/?enc=pTbX7RqXg59Pz4wKCDcB0Q%3D%3D.Ntmzu6ntIS7%2Bw6B0jyRu6inkEGZGhB0rwVErVqTxPuSwf5YVtqZV4DW3vIdOlTSd" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=fE2%2BXVrLfrdDojrO1IsRPw%3D%3D.e4r%2BJhvqBXTHnyOrk7OR1tuxyOfefqfgK1HC76uuOc1eRRxC%2FXS0d4bmpQr3joxX" rel="nofollow" target="_blank">vCenter Server 8</a></li><li>VMware <a href="https://link.segmentfault.com/?enc=EKB1nawXGZwtaINHHJE9Bw%3D%3D.9qHfRtbq9iixQTorhGtDCHnsMIcwivamFEljKMBZjKVMXK3E2iNc88NhSM7g0DHR" rel="nofollow" target="_blank">ESXi 7</a> or <a href="https://link.segmentfault.com/?enc=uAjtCbm%2FHPRmTZFQNXShDw%3D%3D.ThJC0W6aUK%2FKNvhohXWMlxkHemfRgyUq3rsht0eeyCr6bSEZft4USCP2cM1NP%2BD%2B" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=4FgcQoiF%2BjMFt1gtMCbVpw%3D%3D.Z8piBShQ%2FTa1pql1EbSVcR2yIMvr19Bnj8%2Bb%2BOssx2cJYfTV9tLw%2FI7D8acoCWU9" rel="nofollow" target="_blank">vCenter Server 7</a></li></ul></li><li>macOS：<a href="https://link.segmentfault.com/?enc=PrJnCpAC%2BdvABrxKI5gBWQ%3D%3D.aby%2BPkBMG2aOENDEe75GCfYBSP9KxTvYVO3xdebnW%2FOIMCPlnAhkN3jPF5JCAeGG" rel="nofollow" target="_blank">VMware Fusion</a></li><li>Linux：<a href="https://link.segmentfault.com/?enc=Il4pW1UfG0CN1c9zFgzDTA%3D%3D.VnwCudzWbEWfNgAmDq0JDWFUmIu1He20%2Fj1FPXQWs9AZS2Io1goaYqqfk2Jw2J0AuWRnpRL1qn1T8dM6dHEetg%3D%3D" rel="nofollow" target="_blank">VMware Workstation for Linux</a></li><li>Windows：<a href="https://link.segmentfault.com/?enc=GXUoZv16x61UukbRinvW8g%3D%3D.Kw9Vx1BB6Z%2FbqrRSFjJfBgWei5HuOgmJcp6I%2BWQxW81FMWHze6I9jon5QKyAnEtx8R%2BTa7DnaU08Yy%2FlRtXRUg%3D%3D" rel="nofollow" target="_blank">VMware Workstation for Windows</a></li></ul><p>macOS Tahoe 虚拟化解决方案，请参看：<a href="https://link.segmentfault.com/?enc=Or3CmUbeyRVK9DjnifZsTQ%3D%3D.u5%2FvMsM7oJGos3K8St%2BT3Egn4K%2FhcjXM1HBvmdLDFlAyzmklYe%2Fz0Qu9S1qIFBUh" rel="nofollow" target="_blank">macOS 26 Blank OVF - macOS Tahoe 虚拟化解决方案</a></p><h2>如何创建可引导的 macOS 安装器</h2><p>请访问：<a href="https://link.segmentfault.com/?enc=sIe8uS2HPJVRex0TLzZ2bg%3D%3D.6aMaow3v%2BVqPQblsUABSm8A7hwkrnunMGJH%2FIkyJP3S4dW9y5ckdXTyMLepmWSufCbVceuW2HO0qZ%2Ba53kyUbQ%3D%3D" rel="nofollow" target="_blank">如何创建可引导的 macOS 安装介质</a></p><p>更多：<a href="https://link.segmentfault.com/?enc=CUs3BbqRHeZ3wRtwVEbwMg%3D%3D.lpqEPgdNhBLFssM5wHqY7vTEK%2FFNAHcbxY4CWQBJegA%3D" rel="nofollow" target="_blank">macOS 下载汇总 (系统、应用和教程)</a></p>]]></description></item><item>    <title><![CDATA[macOS Tahoe 26.3 (25D125) Boot ISO 原版可引导映像下载 sysin]]></title>    <link>https://segmentfault.com/a/1190000047608395</link>    <guid>https://segmentfault.com/a/1190000047608395</guid>    <pubDate>2026-02-12 22:04:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>macOS Tahoe 26.3 (25D125) Boot ISO 原版可引导映像下载</p><p>Liquid Glass 惊艳新设计亮相，电话 app 和实时活动丰富连续互通体验，聚焦搜索迎来最大更新</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=Q6HvaYV70FEmmCNE5DHcaA%3D%3D.3i8jVpNnlZogpeaNbdfDkQbS8gBZCSUczojSerKtvyu%2FzDszdQ5AooYeJp%2B%2Bqgs2" rel="nofollow" target="_blank">https://sysin.org/blog/macos-tahoe-boot-iso/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=AKvmOfWKqlg8VTcQiup8JA%3D%3D.PspjVxsTO9%2FKczHJvJZ8UE39pvJqOlyTY%2FzX6clzQSo%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>2026 年 2 月 12 日凌晨，Apple 发布 iOS/iPadOS/macOS/watchOS/tvOS/visonOS 全平台 26.3 版本更新。macOS Tahoe 26.3 此次为常规问题修复和安全更新。</p><p>macOS Tahoe 26 让 Mac 更强大、更高效、更智能</p><p>惊艳新设计亮相，电话 app 和实时活动丰富连续互通体验，聚焦搜索迎来最大更新</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046624380" alt="16 英寸 MacBook Pro、iMac 和 13 英寸 MacBook Air。" title="16 英寸 MacBook Pro、iMac 和 13 英寸 MacBook Air。"/></p><p>macOS Tahoe 26 推出精美新设计、丰富的连续互通体验及更多功能，强势助推生产力。</p><p><strong>加利福尼亚州，库比提诺</strong> Tim Cook 领导的 Apple 今日预览了新一代 macOS——macOS Tahoe 26，推出惊艳新设计和诸多强大功能，赋能用户完成更多任务。macOS 的新设计让桌面、程序坞、app  内导览和工具栏等经典元素更加灵动活泼、赏心悦目且契合用户个性需求，同时延续了原有的熟悉感。用户可使用更新版控制中心和文件夹、app  图标与小组件的新色彩选项，进一步打造个性化体验。随着 Mac 版电话 app  的推出，连续互通功能进一步提升，用户可轻松使用最近通话、通讯录和语音留言等 iPhone 版电话 app  的全部功能，以及通话筛选和通话保留助理等新功能 (sysin)。依托 iPhone 实时活动，用户可直接在 Mac  上实时掌握正在进行的活动，如航班信息等。聚焦搜索迎来迄今最大更新，用户现可直接执行数百项操作，如发送电子邮件或创建备忘录等，并利用全新浏览体验更快捷地访问内容。</p><p>“macOS 是 Mac 的核心与灵魂，Tahoe 则将深受用户喜爱的功能发扬光大。无论资深用户还是 Mac  新手，都能借助更多功能提高效率，更顺畅地利用 Mac 和 iPhone 协同工作。”Apple 软件工程高级副总裁 Craig  Federighi 表示，“令人惊艳的新设计、奇妙的连续互通体验、聚焦搜索的强大提升、更多智能快捷指令和 Apple 智能的更新让 Mac  体验更胜以往。”</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046624381" alt="一台 iMac 上显示着设计一新的主屏幕。" title="一台 iMac 上显示着设计一新的主屏幕。" loading="lazy"/></p><p>图：新设计解锁了个性化设置 Mac 的更多方式。</p><h2>ISO 映像的优势</h2><p>相对于官方发布 PKG 映像（另有 IPSW 映像，但仅适用于 Apple 芯片），以及第三方制作的 DMG 映像，ISO 格式具有以下优势：</p><ul><li>可以直接拖拽到 Applications（应用程序）目录下（无需管理员权限），进行升级安装</li><li>可以直接双击挂载，执行命令写入 USB 存储设备或者其他卷，然后启动全新安装（无需拖拽到“应用程序”目录下）</li><li>可以直接启动虚拟机安装，介质本身为可引导映像</li><li>可以在 Windows 和 Linux 下写入 USB 存储设备，创建 USB 引导安装介质</li><li>跨平台支持，可以在任意操作系统中使用，其他格式仅限 macOS 专用</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046878483" alt="macOS Tahoe in VMware" title="macOS Tahoe in VMware" loading="lazy"/></p><p>图：macOS Tahoe 运行在 Fusion 25H2 中，并开启了 Metal GPU 加速。</p><h2>下载 macOS Tahoe ISO</h2><p>💡 <a href="https://link.segmentfault.com/?enc=15WiPhMIHiPhAArXlHjz7A%3D%3D.9OtZdFLLoWflmKMM3n1g4Tdo10%2F%2FBh0WvtAPFPb0csI%3D" rel="nofollow" target="_blank">如何校验本站下载的文件的完整性</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047305036" alt="macOS Tahoe" title="macOS Tahoe" loading="lazy"/></p><blockquote>本站原创可引导映像，可以在当前系统中安装或者升级，可以通过 USB 存储引导安装，也可以用于虚拟机安装。</blockquote><ul><li>macOS Tahoe 26.3 (25D125) - 2026.02.11</li><li>macOS Tahoe 26.2 (25C56) - 2025.12.12</li><li>macOS Tahoe 26.1 (25B78) - 2025.11.03</li><li>macOS Tahoe 26.0.1 (25A362) - 2025.09.30</li><li><p>macOS Tahoe 26 (25A354) - 2025.09.15</p><ul><li>下载地址：<a href="https://link.segmentfault.com/?enc=QrcNtaZ2NlEOgsz5q9FYnA%3D%3D.lzv%2B6qp3pqEkildtJCqZIBleS4Ie3bDiHzhHdjE3udFNVZlvAJ15f3ORcWhsy9B2" rel="nofollow" target="_blank">https://sysin.org/blog/macos-tahoe-boot-iso/</a></li></ul></li></ul><p>参看：<a href="https://link.segmentfault.com/?enc=QCFCZhmi6RW7OAUaImQFnw%3D%3D.vH%2FhISQAMEk4wne0Ki4EB%2BupWS38RphII0RoSZMinLlLWdbcOCdPKg2rVsy8Gy1h" rel="nofollow" target="_blank">如何在 Mac 和虚拟机上安装 macOS Sequoia、macOS Sonoma 和 macOS Ventura</a></p><p>这里列出 ISO 启动映像下载链接，更多格式请访问以下地址：</p><ul><li><a href="https://link.segmentfault.com/?enc=fSWxh%2Bp2ZMYyK3v9piTByA%3D%3D.jbETOstrb4WhAYGuHoiVhmCZ0SxaYjYhn8sKV5kha7ptbrbrOycZQnsOCh9ZluqT" rel="nofollow" target="_blank">macOS Tahoe 26 ISO、IPSW、PKG 下载</a></li></ul><h2>macOS Tahoe 硬件兼容性列表</h2><p>笔者提示：“Apple Intelligence” 及相关功能要求 <a href="https://link.segmentfault.com/?enc=bu4qEh91X9sfgFMYv87SsA%3D%3D.W5OI0eGLxufpirQT6s8kH%2BHrS2A2RRg0T6d0A25veS5BhvEAyY8s65vb%2FlcM0v%2BE" rel="nofollow" target="_blank">搭载 Apple 芯片的 Mac 电脑</a>。</p><p>看看你的 Mac 是否能用 macOS Tahoe</p><p><a href="https://link.segmentfault.com/?enc=UM5zVgSCyuqF%2Bdh49d4TgA%3D%3D.%2FJjGRjpKnX9Lm8BTzWUi7t%2BO7dm%2FMKv6%2FygFHdawM%2Fk%3D" rel="nofollow" target="_blank">进一步了解 Mac&gt;</a></p><ul><li><strong>MacBook Air</strong> with Apple silicon 2020 and later <a href="https://link.segmentfault.com/?enc=fvddrb5PgOkcZQShafvUkQ%3D%3D.CnIcJBfNCIY8eFDvo8vBFEWMLiPMYCshCT4ZK3Ba5zn29l6L0PdM52WsdsjtWJQ2" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>MacBook Pro</strong> with Apple silicon (2020 and later) <a href="https://link.segmentfault.com/?enc=foHu%2Bomgj%2FUTedLlVcMv5A%3D%3D.1hF0Qz6nRcW3rhMKwuc6J4wPbCiEw51OXmNSBjYFi3l4n2q1NkyMCyvz%2F1xA6opn" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>MacBook Pro</strong> 2019 <a href="https://link.segmentfault.com/?enc=7QxXmTP02MMt4IFFe7jJoA%3D%3D.zfU09ZaKA2R3%2BjfpgLANZZVAWA2m8IeMY%2FO0xpmeZaEOEO7W830GMdKwqHZ1HtBM" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>MacBook Pro</strong> (13‑inch, 2020, Four Thunderbolt 3 ports) <a href="https://link.segmentfault.com/?enc=Muh2ySRn4iISovyFkpMgzA%3D%3D.p7egdTj4Wi%2BQyQIDbp8MmNZy1LSwOLmEfb9FzkJ9hdQq6FUZ64gYOgmK50DAEMc0" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>Mac mini</strong> 2020 and later <a href="https://link.segmentfault.com/?enc=Zqtf%2F%2F34Oo0SNlP85tp2bg%3D%3D.9roZKhPdWX4eGrnZ76bAkeWBrGhsqhIefiFp9LcZSCcgoBHeBR3QdSZxR354oTFM" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>Mac Studio</strong> 2022 <a href="https://link.segmentfault.com/?enc=pWDrMOq03IEVHWr5AmeCWA%3D%3D.pPrmm%2Bmqx5h6%2Bqzcwm1Jo6GlU8auAm9PmzHoxXOcyTnz2UDxd2oogBIBn5jXGDO5" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>Mac Pro</strong> 2019 and later <a href="https://link.segmentfault.com/?enc=PZunyAz%2BFA7mt3CcntyN%2BA%3D%3D.hd7V%2BA7i%2F2go75VCQjQPatxI%2F4ubJob0oE4ezbFscb%2F4CBv2vFHKCXEXVtmStxcM" rel="nofollow" target="_blank">进一步了解 &gt;</a></li><li><strong>iMac</strong> 2020 and later <a href="https://link.segmentfault.com/?enc=SrGnXsBefMrxPeK41%2BL6Fw%3D%3D.yRYmxmC4my9zWhx3QaoO83pFB29f1kdXL74NYvItEozYs8ntDU5urRwf6zkKwa%2BY" rel="nofollow" target="_blank">进一步了解 &gt;</a></li></ul><p>如果你的 Mac 不在兼容性列表，参看：<a href="https://link.segmentfault.com/?enc=leFF%2Fy%2FdsBrTeeKgkN650Q%3D%3D.69omGzqs6tpoF15SWStHixl1m5YSXCEkX1EPowvpgeA0hu4H2JfwLDdN75XMS4reIThWyctH2wlGB2ij7s71IQ%3D%3D" rel="nofollow" target="_blank">在不受支持的 Mac 上安装 macOS Tahoe 26</a></p><h2>适用的 VMware 软件下载链接</h2><p>建议在以下版本的 VMware 软件中运行（Linux OVF 无需本站定制版可以正常运行，macOS 虚拟化如果不是 Mac 必须使用定制版才能运行，Windows OVF 需要定制版才能启用完整功能）：</p><ul><li><p>VMware vSphere：</p><ul><li>VMware <a href="https://link.segmentfault.com/?enc=NXse2hkFM9fRFX%2FoWx5E3Q%3D%3D.AX7ZEbad8miHt5so6qYQg88IBKPR5DEezA2C1fLJrT%2B1Vl9QkMQg0LjIFYE0DNFX" rel="nofollow" target="_blank">ESXi 9</a> or <a href="https://link.segmentfault.com/?enc=gTZcN5fHmMsFoXKglDQ5Ug%3D%3D.%2BsP9NJUZua%2FuxLGUqG2yXU7H2kmxqk6sXftqbdeiebIVkXmGbeMvC47cgF34Ad1o" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=5KQrhKm5dEasjShnscfRNw%3D%3D.4n0VzdOQLwNSRizI1X7Ml45FfaBucME6ULecHrBcRF3172ZDmDJ%2FcUyuck8RgOdq" rel="nofollow" target="_blank">vCenter Server 9</a> &amp; <a href="https://link.segmentfault.com/?enc=S54v%2Fv9VHEwgbnU08fIe2g%3D%3D.Jm%2FuCgc7rmYFJzNEdcXFovN4M6Kw%2F3VkJxBYItvy%2BaOYN0u7ameFdz8UEnsWtQTPGHnGCQbXyfZryMQT5VzgAg%3D%3D" rel="nofollow" target="_blank">VCF Operations 9</a></li><li>VMware <a href="https://link.segmentfault.com/?enc=aKTcQYOIPPcyjmDlRJrkyA%3D%3D.QdJJCKL6Ar3LOpjHSeO49qNOjcYE%2FZkUl08IA5wjLwPixXllPokcFYmrvarD1HD5" rel="nofollow" target="_blank">ESXi 8</a> or <a href="https://link.segmentfault.com/?enc=lqhtH23YtlkL1%2FZEaiW0Vg%3D%3D.qr8JlEe5JHjjRlvO5JRpD83veU2URk%2Fpq2Z1mubT1sve%2Bnz254hWhlWPKxqtClLF" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=G29Hg5bpFQ9oE6ncML9iuw%3D%3D.%2BRG38uZsOi9U0WcpbSrUlXinZRgGZ8HVv2Zcws3BxdKsU3KOau0F0swB7OEkrTq0" rel="nofollow" target="_blank">vCenter Server 8</a></li><li>VMware <a href="https://link.segmentfault.com/?enc=3T3VeyeBJ7ECfuZA2Td7Mg%3D%3D.XYeofG%2FVeMqj%2BeMQ5DdpcfI%2BSWAeW7nTvbQImTBmXzPY5yxsBczEGPd7OeoLPMra" rel="nofollow" target="_blank">ESXi 7</a> or <a href="https://link.segmentfault.com/?enc=wtiPZtiHvxk1WIQAdXoImQ%3D%3D.akSmLFZaLfmXJiGVv3DO%2Bhdxk7Fl%2FrroUeLqQ4B6RHSSEds3FL54dSzIlqJAzocW" rel="nofollow" target="_blank">with driver</a> &amp; <a href="https://link.segmentfault.com/?enc=PtfFAmF3FbGJjYX5y0Xk1g%3D%3D.aj2pgcaLtx8IxgEtWS5My%2FUxzKCUR2w9ObvgfGu9P3Ev02xq0nvAcflWMua%2BG7xq" rel="nofollow" target="_blank">vCenter Server 7</a></li></ul></li><li>macOS：<a href="https://link.segmentfault.com/?enc=MgOp0ciRS322QE%2FNq%2BgYsw%3D%3D.SYkHEaN%2BNARsErZTgP6le8JQ7wOsxbm9pOYt32QSihXTvDDDNBAcikI6nGhmTTND" rel="nofollow" target="_blank">VMware Fusion</a></li><li>Linux：<a href="https://link.segmentfault.com/?enc=lCAq6adWVXDBsqFjxrvgUA%3D%3D.%2FeR9GvPf7BU5sYAcjQJI8MXNXTnLn6BfHKTbWcyBW%2BWzJtWXffIE4UqwrVKjQoyxOCL91Yrf721FVNZifq6bTQ%3D%3D" rel="nofollow" target="_blank">VMware Workstation for Linux</a></li><li>Windows：<a href="https://link.segmentfault.com/?enc=oPH09YSWmjOXzlQgvF1faA%3D%3D.jPcIuE%2FB1TGGR5XvohDJu3i0M5sgk7tyIu60o%2Bz9rggTwCnmEYmmbzFRwz7KvJIsUBk7eAqQ1EE2EFF6Z4XzhA%3D%3D" rel="nofollow" target="_blank">VMware Workstation for Windows</a></li></ul><p>macOS Tahoe 虚拟化解决方案，请参看：<a href="https://link.segmentfault.com/?enc=c3NqB5bG3XX%2FxkO4I2gvrA%3D%3D.aDfFFWLHnX0llW7phak6rH4hZ2TpSE%2FXSv5defdXdvIqsv9s5cg%2FbW%2BA54GtUGHQ" rel="nofollow" target="_blank">macOS 26 Blank OVF - macOS Tahoe 虚拟化解决方案</a></p><h2>如何创建可引导的 macOS 安装器</h2><p>请访问：<a href="https://link.segmentfault.com/?enc=vCAFKYbEnTjEC%2B%2FMW%2BwF4A%3D%3D.K%2FEUnm3DIapf11M8MD5T6IXg7wBBPb97kverD%2BdDmbw17XJ6smttyKlU6ZtPl10XgCszKz8Lt8%2FxD35ENDZT3g%3D%3D" rel="nofollow" target="_blank">如何创建可引导的 macOS 安装介质</a></p><p>更多：<a href="https://link.segmentfault.com/?enc=rVgIAup57Wjduy98O%2FPsvw%3D%3D.PB4KqDi6Lo8B%2BYQrx23LKT48kmm3eIrApZ45Qps3Mj0%3D" rel="nofollow" target="_blank">macOS 下载汇总 (系统、应用和教程)</a></p>]]></description></item><item>    <title><![CDATA[6G 物理层变天AFDM：与其在 OFDM 的死胡同里撞墙，不如换个坐标系“折叠”世界 3GPP仿真]]></title>    <link>https://segmentfault.com/a/1190000047608399</link>    <guid>https://segmentfault.com/a/1190000047608399</guid>    <pubDate>2026-02-12 22:03:43</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>我们先承认一个尴尬的事实：</p><p>面对 6G 提出的 <strong>1000 km/h（超高铁）</strong> 和 <strong>28000 km/h（低轨卫星）</strong> 愿景，统治了通信界二十年的王者——OFDM，已经尽力了。</p><p>依靠缩短符号时间、加大子载波间隔（SCS），这只是在物理极限的边缘疯狂试探。我们就像在暴风雨中修补一艘漏水的船，补丁打得越多，船越重（CP 开销大、频谱效率低）。</p><p><strong>是时候换一艘船了。</strong></p><p>今天，我们来聊聊物理层的一场“降维打击”： ​<strong>AFDM 仿射频分复用</strong>​ 。</p><hr/><h3>01. 完美的代价：OFDM 的基因缺陷</h3><p>一切悲剧的根源，早在我们选择 OFDM 的那一刻就注定了。</p><p>为了追求频谱效率的极致，我们在频域选择了​<strong>Sinc 函数</strong>​（$sin(x)/x$）作为子载波。</p><p>它长得并不像一根完美的针，而是一个带着无数“拖油瓶”的波形：</p><ul><li><strong>主瓣：</strong> 高耸入云，承载有用信息。</li><li><strong>旁瓣 (Side-lobes)：</strong> 像波纹一样向两边扩散，且衰减极其缓慢。</li></ul><p>OFDM 利用数学上的<strong>“正交性”</strong>，巧妙地让每一个子载波的<strong>峰值</strong>，精准地踩在其他所有子载波的<strong>零点 (Zero Crossing)</strong> 上。</p><p>这是一场​<strong>刀尖上的舞蹈</strong>​。</p><p>虽然旁瓣拖得很长，但在采样点那一瞬间，大家互不干扰。只要大家都不动，这个平衡就是完美的。</p><blockquote><strong>但在 6G 的世界里，“不动”成了一种奢望。</strong></blockquote><hr/><h3>02. 速度的诅咒：从 350km/h 到 7.6km/s</h3><p>当你在 350km/h 的高铁上，或者在 7.6km/s 的卫星下，物理世界开始对这个脆弱的数学平衡下手了。</p><p>大家通常认为多普勒只是​<strong>频率平移</strong>​。但在 OFDM 的眼里，这简直就是一场 <strong>“旁瓣的屠杀”</strong> 。</p><p>设想一下，当整个频谱发生微小的偏移（哪怕只是子载波间隔的 ​<strong>3%</strong> ​）：</p><ol><li><strong>零点错位：</strong> 接收机做 FFT 采样时，原本应该采到“0”的地方，现在采到了隔壁子载波的​<strong>旁瓣能量</strong>​。</li><li><strong>能量海啸：</strong> 由于 Sinc 函数的旁瓣拖得很长，<strong>远处的子载波</strong>也会把能量“泼”过来。</li><li><strong>ICI 爆发：</strong> 成千上万个子载波的干扰叠加在一起，形成了恐怖的 ​<strong>ICI（载波间干扰）</strong> ​。</li></ol><p><strong>(建议配图：OFDM 子载波正交性被破坏的示意图，展示波峰对不准零点)</strong></p><p>更绝望的是​<strong>低轨卫星（LEO）场景</strong>​。</p><p>当速度达到 ​<strong>7.6 km/s</strong>​，多普勒频移轻松突破 ​<strong>500 kHz</strong>​。</p><p>这直接导致​<strong>相干时间（Coherence Time）崩塌</strong>​。</p><p>这意味着：<strong>你的导频（Pilot）刚测完信道，还没来得及发数据，信道已经变了。</strong></p><p>传统的信道估计逻辑彻底断裂。</p><p>这时候，无论你把基站功率开多大，都没用了。因为干扰来自信号内部，信噪比（SINR）被锁死在一个 <strong>“地板”</strong> 上。</p><p><strong>网速瞬间从“千兆级”掉回“3G 时代”。</strong></p><hr/><h3>03. 第一性原理：把“正弦波”扔进垃圾桶</h3><p>OFDM 为什么怕多普勒？</p><p>因为它用的基底是 ​<strong>正弦波</strong>​——$e^{j2pi ft}$。</p><p>正弦波是静态的、永恒的。它唯一的弱点就是 <strong>“频率必须精准”</strong> 。</p><p>面对 6G 的超高动态，物理层先锋们做了一个违背祖宗的决定：</p><p><strong>抛弃正弦波，改用 Chirp（线性调频信号）。</strong><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608401" alt="demo_afdm_basics.png" title="demo_afdm_basics.png"/></p><p>想象一下：</p><ul><li><strong>OFDM 的子载波</strong> 像是一排排<strong>垂直竖立</strong>的栅栏。风（多普勒）一吹，栅栏就歪了，互相碰撞。</li><li><strong>AFDM 的子载波</strong> 像是<strong>倾斜的</strong>多米诺骨牌。<br/>它的频率本身就是随时间线性变化的：$e^{j2pi (ft + frac{c}{2}t^2)}$。</li></ul><p>这里的 $c$ (Chirp Rate)，就是我们手中的​<strong>魔法钥匙</strong>​。</p><hr/><h3>04. DAFT：上帝的扭曲力场</h3><p>有了 Chirp 信号，我们如何调制数据？</p><p>欢迎来到数学的无人区—— ​<strong>DAFT (离散仿射傅里叶变换)</strong> ​。</p><p>别被名字吓到。它的物理本质极其性感：</p><p><strong>它在对时频平面（Time-Frequency Plane）进行“剪切” (Shearing) 和“旋转”。</strong></p><ul><li><strong>传统 FFT</strong> 是正正方方的网格。</li><li><strong>DAFT</strong> 通过调整参数 $c$，把网格<strong>扭曲</strong>成平行四边形，使其斜率与信道的<strong>多普勒频移斜率</strong>完美对齐。</li></ul><p><strong>见证奇迹的时刻：</strong></p><p>当信道的最大多普勒频移为 $f_{max}$ 时，我们只需要设置 Chirp 参数 $c = 2f_{max}/T$。</p><p>此时，原本在这个星球上狂暴变化的信道，在 DAFT 变换后的域里，竟然奇迹般地​<strong>变成了一条直线（时不变信道）</strong> ​！</p><blockquote><strong>我们没有消除多普勒，我们只是通过扭曲坐标系，把它“骗”过去了。</strong></blockquote><hr/><h3>05. 降维打击：全分集 (Full Diversity) 的暴力美学</h3><p>AFDM 最让通信人上瘾的，是它的抗衰落能力。</p><p>在 OFDM 中，如果一个子载波掉进深衰落（Deep Fade）的坑里，上面的数据就死定了。</p><p>但在 AFDM 中，<strong>每一个数据符号都“弥散”在整个带宽和时隙上。</strong></p><p>这就好比：</p><ul><li><strong>OFDM</strong> 是把鸡蛋放在 1000 个篮子里。摔了一个篮子，就碎一个鸡蛋。</li><li><strong>AFDM</strong> 是把鸡蛋打散，均匀地涂在 1000 个篮子上。摔碎几个篮子？无所谓，把剩下的拼起来，鸡蛋还是完整的。</li></ul><p><strong>结论炸裂：</strong></p><p>多普勒越大，多径越复杂，AFDM 的性能反而越好（分集阶数越高）。</p><p><strong>这是物理层对恶劣环境的最强嘲讽。</strong></p><hr/><h3>06. 终极杀手锏：它不再只是通信</h3><p>如果你以为 AFDM 只是为了让网速快一点，那你就把格局想小了。</p><p>AFDM 真正让 6G 颤抖的，是它的 <strong>“双重身份”</strong> 。</p><p>请回想一下，AFDM 的核心波形是什么？<strong>是 Chirp。</strong></p><p>在通信人眼里，这是新波形；但在<strong>雷达人</strong>眼里，这是 <strong>“老祖宗”</strong> ！</p><p><strong>一个惊人的宿命出现了：</strong></p><p>当我们在 6G 基站上发射 AFDM 波形时，我们实际上是在发射​<strong>雷达波</strong>​。</p><ul><li><strong>OFDM 是“盲人”：</strong> 它只能以此岸传到彼岸，不知道中间经历了什么。</li><li><strong>AFDM 是“睁眼玩家”：</strong> 它的波形天然具备​<strong>探测能力</strong>​。它在传输数据的同时，顺便把周围环境的 <strong>距离（Delay）</strong> 和 <strong>速度（Doppler）</strong> 扫描了一遍。</li></ul><p><strong>这就是 6G 的圣杯——通感一体化 (ISAC)。</strong></p><p>未来的基站，不需要你发导频告诉它你在哪。通过 AFDM 的回波，基站直接 <strong>“看”</strong> 到了你。</p><p>它知道这辆车在以 120km/h 变道，它知道那颗卫星在以 7.6km/s 靠近。</p><p>因为我看清了你，所以我能完美地调节坐标系来适应你。</p><p><strong>通信与感知，在 AFDM 的时延-多普勒域里，完成了物理层上的“灵肉合一”。</strong></p><hr/><h3>结语</h3><p>OFDM 统治了二十年，它把“静态”做到了极致。</p><p><strong>但 AFDM 的出现，标志着我们终于有勇气去拥抱“动态”。</strong></p><p>在 7.6km/s 的星链上，在 1000km/h 的真空管道里，正弦波的时代正在落幕。</p><p>那个属于 Chirp，属于 DAFT，属于 <strong>“御风而行”</strong> 的时代，才刚刚开始。</p><hr/><blockquote><p>“欢迎关注公众号 <strong>3GPP仿真实验室</strong>！这里是通信算法工程师的加油站。</p><p>我们不搬运新闻，只输出<strong>可运行的代码</strong>和<strong>深度标准解读</strong>。</p><p>👇 <strong>新人见面礼（后台回复关键词获取）：</strong></p><p>回复【LDPC】：获取 5G NR LDPC 编解码 MATLAB 代码（含注释）。<br/>回复【工具】：通信人减负神器：5G NR 帧结构与频点一键生成器（Python+Excel+Web三版）。<br/>回复【Pytorch】：获取 5G NR OFDM 链路 Pytorch 教学代码（含注释），助力人工智能 + 通信</p><p>让我们一起探索 6G 的无限可能。</p></blockquote>]]></description></item><item>    <title><![CDATA[【Matlab源码】6G候选波形：MIMO-OFDM-IM 增强仿真平台 3GPP仿真实验室 ]]></title>    <link>https://segmentfault.com/a/1190000047608413</link>    <guid>https://segmentfault.com/a/1190000047608413</guid>    <pubDate>2026-02-12 22:02:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>&lt;p align="center"&gt;<br/>  &lt;h1 align="center"&gt;📡 MIMO-OFDM-IM 空间扩展仿真平台&lt;/h1&gt;<br/>  &lt;p align="center"&gt;</p><pre><code>&lt;strong&gt;空间+频率双域索引调制，MIMO 分集与复用增益的完美结合&lt;/strong&gt;</code></pre><p>&lt;/p&gt;<br/>  &lt;p align="center"&gt;</p><pre><code>&lt;img src="https://img.shields.io/badge/MATLAB-R2021b+-blue?style=flat-square&amp;logo=mathworks" alt="MATLAB"/&gt;
&lt;img src="https://img.shields.io/badge/MIMO-8x8-green?style=flat-square" alt="MIMO"/&gt;
&lt;img src="https://img.shields.io/badge/Spatial-IM-orange?style=flat-square" alt="SIM"/&gt;
&lt;img src="https://img.shields.io/badge/Diversity-Order-red?style=flat-square" alt="Diversity"/&gt;</code></pre><p>&lt;/p&gt;<br/>&lt;/p&gt;</p><hr/><h2>📌 为什么选择本仿真平台？</h2><table><thead><tr><th align="left">痛点</th><th align="left">本平台解决方案</th></tr></thead><tbody><tr><td align="left">📚 SISO 分集阶数有限</td><td align="left">✅ <strong>MIMO 空间分集</strong>：多天线提供 Nr × Nt 分集阶数</td></tr><tr><td align="left">🔧 空间复用与索引调制难结合</td><td align="left">✅ <strong>空频双域索引</strong>：天线选择 + 子载波选择叠加</td></tr><tr><td align="left">📊 MIMO 检测复杂度高</td><td align="left">✅ <strong>分离检测算法</strong>：先空间后频域，复杂度大幅降低</td></tr><tr><td align="left">⚡ 信道模型单一</td><td align="left">✅ <strong>MIMO 瑞利信道</strong>：独立衰落建模，真实场景验证</td></tr><tr><td align="left">📡 缺乏分集增益量化</td><td align="left">✅ <strong>BER 曲线斜率分析</strong>，直观展示分集阶数提升</td></tr></tbody></table><hr/><h2>🎯 核心价值</h2><table>
<tr>
<td width="50%">

### 🔬 学术研究价值

- MIMO-IM 空频联合调制理论验证
- 空间分集与频率分集叠加效应
- ML/分离/迭代检测算法对比
- 大规模 MIMO 性能边界探索

</td>
<td width="50%">

### 💼 工程应用价值

- 支持 2×2 到 8×8 天线配置
- 可配置激活天线数量
- 适用于 5G/6G 多天线系统
- 完整的 MIMO 收发链路

</td>
</tr>
</table><hr/><h2>⚡ 技术亮点</h2><h3>🌊 MIMO-OFDM-IM 双域架构</h3><pre><code class="text">┌─────────────────────────────────────────────────────────────────┐
│                 MIMO-OFDM-IM 空频双域索引调制                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【空间域索引】        【频率域索引】        【联合传输】       │
│                                                                 │
│   ┌─ Tx1 ★ ─┐          ┌─ f1 ● ─┐                              │
│   │  Tx2 ○  │          │  f2 ○  │                              │
│   │  Tx3 ○  │    +     │  f3 ● ─┼──► X[Nt, Nf] 空频符号矩阵    │
│   └─ Tx4 ★ ─┘          └─ f4 ○  ┘                              │
│                                                                 │
│   C(Nt,Na) 空间         C(n,k) 频域          联合索引比特        │
│   索引模式             索引模式                                  │
│                                                                 │
│         ┌──────── MIMO 瑞利信道 H[Nr×Nt] ────────┐              │
│         │      各天线对独立衰落                    │              │
│         └─────────────────────────────────────────┘              │
│                                                                 │
│   【接收端】 Y = HX + N ──► [空间检测] ──► [频域检测] ──► 恢复   │
└─────────────────────────────────────────────────────────────────┘</code></pre><h3>📊 分集增益对比 (n=4, k=2, QPSK)</h3><table><thead><tr><th align="center">配置</th><th align="center">空间分集</th><th align="center">频率分集</th><th align="center">总分集阶数</th><th align="center">BER@15dB</th></tr></thead><tbody><tr><td align="center">SISO-IM</td><td align="center">1</td><td align="center">n-k+1=3</td><td align="center"><strong>3</strong></td><td align="center">2.5e-3</td></tr><tr><td align="center">2×2 MIMO-IM</td><td align="center">4</td><td align="center">3</td><td align="center"><strong>12</strong></td><td align="center">1.8e-5</td></tr><tr><td align="center">4×4 MIMO-IM</td><td align="center">16</td><td align="center">3</td><td align="center"><strong>48</strong></td><td align="center">&lt; 1e-6</td></tr></tbody></table><blockquote>💡 <strong>分集倍增</strong>：MIMO-IM 总分集阶数 = Nr × Nt × (n-k+1)，相比 SISO 呈倍数增长。</blockquote><hr/><h2>🖥️ 运行环境</h2><h3>最低要求</h3><table><thead><tr><th align="left">项目</th><th align="left">要求</th></tr></thead><tbody><tr><td align="left"><strong>MATLAB版本</strong></td><td align="left">R2021b 或更高</td></tr><tr><td align="left"><strong>必需工具箱</strong></td><td align="left">Communications Toolbox</td></tr><tr><td align="left"><strong>基础依赖</strong></td><td align="left">P1 基础包</td></tr><tr><td align="left"><strong>内存</strong></td><td align="left">8 GB+ (大规模 MIMO 建议 16GB)</td></tr></tbody></table><h3>快速验证</h3><pre><code class="matlab">&gt;&gt; cd packages/P4_空间扩展包
&gt;&gt; setup_path
&gt;&gt; generate_ber_plots</code></pre><hr/><h2>🧠 算法原理</h2><h3>MIMO-IM 系统模型</h3><p><strong>发射端</strong>：</p><p>$$
\mathbf{X}[N_t \times N_f] = \text{SpatialMapper}(\mathbf{s}_{spatial}) \odot \text{FreqMapper}(\mathbf{s}_{freq})
$$</p><p><strong>接收端</strong>：</p><p>$$
\mathbf{Y} = \mathbf{H}\mathbf{X} + \mathbf{N}
$$</p><h3>空间索引比特</h3><p>$$
p_{spatial} = \lfloor \log_2 C(N_t, N_a) \rfloor
$$</p><h3>总比特数</h3><p>$$
p_{total} = p_{spatial} + G \cdot (p_1 + p_2)
$$</p><p>其中 G 为频域子块数。</p><h3>分集阶数分析</h3><p><strong>SISO-IM</strong>: $d = n - k + 1$</p><p><strong>MIMO-IM</strong>: $d = N_r \cdot N_t \cdot (n - k + 1)$</p><hr/><h2>📁 项目结构</h2><pre><code class="text">P4_空间扩展包/
├── 📂 mimo/                         # MIMO 索引调制
│   ├── mimo_im_modulator.m          #   🚀 MIMO-IM 调制器
│   ├── mimo_im_demodulator.m        #   🚀 MIMO-IM 解调器
│   ├── spatial_index_mapper.m       #   空间索引映射
│   └── spatial_index_demapper.m     #   空间索引解映射
│
├── 📂 channels/                     # MIMO 信道模型
│   ├── mimo_rayleigh_channel.m      #   MIMO 瑞利衰落信道
│   └── mimo_awgn_channel.m          #   MIMO AWGN 信道
│
├── 📂 core/                         # 继承 P1 核心模块
├── 📂 config/                       # 配置 (扩展 MIMO 参数)
│
├── 📂 docs/                         # 文档
│   ├── 算法文档.md                   #   📘 MIMO-IM 原理推导
│   ├── 代码文档.md                   #   📒 接口说明
│   └── 项目文档.md                   #   📗 本文档
│
├── generate_plots.m                 # 📊 基础 BER 曲线
└── generate_ber_plots.m             # 📊 MIMO vs SISO 分集对比</code></pre><p><strong>代码统计</strong>：</p><ul><li>📄 20+ 个核心 MATLAB 文件</li><li>📝 2000+ 行精炼代码</li><li>💬 100% 中文详细注释</li></ul><hr/><h2>🎬 仿真演示</h2><h3>一键运行</h3><pre><code class="matlab">&gt;&gt; cd packages/P4_空间扩展包
&gt;&gt; setup_path
&gt;&gt; generate_ber_plots</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608415" alt="p4_mimo_vs_siso.png" title="p4_mimo_vs_siso.png"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608416" alt="p4_spatial_heatmap.png" title="p4_spatial_heatmap.png" loading="lazy"/></p><hr/><h2>📦 您将获得</h2><table><thead><tr><th align="left">内容</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">📁 <strong>完整源码</strong></td><td align="left">MIMO-IM 空频双域调制解调</td></tr><tr><td align="left">📖 <strong>原理文档</strong></td><td align="left">空间索引、分集增益数学推导</td></tr><tr><td align="left">🚀 <strong>双域索引</strong></td><td align="left">空间+频率联合索引调制</td></tr><tr><td align="left">📊 <strong>分集验证</strong></td><td align="left">SISO vs MIMO 分集增益对比</td></tr><tr><td align="left">🔧 <strong>灵活天线</strong></td><td align="left">支持 2×2 到 8×8 配置</td></tr><tr><td align="left">📡 <strong>MIMO 信道</strong></td><td align="left">独立瑞利衰落信道建模</td></tr></tbody></table><hr/><h2>🎯 典型应用场景</h2><table><thead><tr><th align="left">场景</th><th align="left">推荐配置</th><th align="left">优势</th></tr></thead><tbody><tr><td align="left">低功耗 IoT</td><td align="left">2×2, Na=1</td><td align="left">分集增益 + 能效</td></tr><tr><td align="left">移动终端</td><td align="left">4×4, Na=2</td><td align="left">平衡性能与复杂度</td></tr><tr><td align="left">5G 基站</td><td align="left">8×8, Na=4</td><td align="left">最大分集增益</td></tr></tbody></table><hr/><h2>🛒 获取方式</h2><p>本文代码仅为核心片段，完整版工程已整理好。 关注公众号 【<strong>3GPP仿真实验室</strong>】进行获取。</p><h2>📚 参考文献</h2><ol><li><strong>E. Başar et al.</strong> (2013): "OFDM with Index Modulation for MIMO Systems." <em>IEEE Trans. Signal Process.</em>, vol. 61, no. 22.</li><li><strong>J. Crawford et al.</strong> (2017): "MIMO Spatial Modulation with Index Modulation." <em>IEEE Trans. Veh. Technol.</em>, vol. 66, no. 3.</li><li><strong>Y. Xiao et al.</strong> (2018): "OFDM with Flexible Space-Frequency Index Modulation." <em>IEEE Trans. Wireless Commun.</em>, vol. 17, no. 7.</li><li><strong>R. Mesleh et al.</strong> (2008): "Spatial Modulation." <em>IEEE Trans. Veh. Technol.</em>, vol. 57, no. 4.</li></ol>]]></description></item><item>    <title><![CDATA[【Matlab源码】6G候选波形：OFDM-IM 增强仿真平台 GIM、MM、IQ 3GPP仿真实验]]></title>    <link>https://segmentfault.com/a/1190000047608420</link>    <guid>https://segmentfault.com/a/1190000047608420</guid>    <pubDate>2026-02-12 22:02:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>&lt;p align="center"&gt;<br/>  &lt;h1 align="center"&gt;📈 OFDM-IM 容量增强仿真平台&lt;/h1&gt;<br/>  &lt;p align="center"&gt;</p><pre><code>&lt;strong&gt;GIM + MM + IQ 三大容量扩展技术，突破传统索引调制比特率极限&lt;/strong&gt;</code></pre><p>&lt;/p&gt;<br/>  &lt;p align="center"&gt;</p><pre><code>&lt;img src="https://img.shields.io/badge/MATLAB-R2021b+-blue?style=flat-square&amp;logo=mathworks" alt="MATLAB"/&gt;
&lt;img src="https://img.shields.io/badge/GIM-Variable_k-green?style=flat-square" alt="GIM"/&gt;
&lt;img src="https://img.shields.io/badge/MM-Multi_Mode-orange?style=flat-square" alt="MM"/&gt;
&lt;img src="https://img.shields.io/badge/IQ-Independent-red?style=flat-square" alt="IQ"/&gt;</code></pre><p>&lt;/p&gt;<br/>&lt;/p&gt;</p><hr/><h2>📌 为什么选择本仿真平台？</h2><table><thead><tr><th align="left">痛点</th><th align="left">本平台解决方案</th></tr></thead><tbody><tr><td align="left">📚 固定激活数限制索引空间</td><td align="left">✅ <strong>GIM 广义索引</strong>：可变激活数，索引空间扩大 2-4 倍</td></tr><tr><td align="left">🔧 调制阶数浪费额外比特</td><td align="left">✅ <strong>MM 多模调制</strong>：每个激活子载波携带模式选择比特</td></tr><tr><td align="left">📊 I/Q 资源耦合利用</td><td align="left">✅ <strong>IQ 独立索引</strong>：实部虚部分别索引，并行双倍效率</td></tr><tr><td align="left">⚡ 容量提升难以量化</td><td align="left">✅ 内置 <strong>容量分析对比工具</strong>，直观展示各技术增益</td></tr><tr><td align="left">📡 检测算法对应难</td><td align="left">✅ 每种技术配套 <strong>专用解调器</strong>，算法一一对应</td></tr></tbody></table><hr/><h2>🎯 核心价值</h2><table>
<tr>
<td width="50%">

### 🔬 学术研究价值

- 三大容量扩展技术完整实现
- 索引空间理论上界研究
- 频谱效率 vs 复杂度权衡分析
- 不同场景最优技术选择

</td>
<td width="50%">

### 💼 工程应用价值

- 高频谱效率需求场景首选
- 灵活的参数配置空间
- 结构化的技术对比框架
- 完整的收发链路验证

</td>
</tr>
</table><hr/><h2>⚡ 技术亮点</h2><h3>🌊 三大容量增强技术对比</h3><pre><code class="text">┌─────────────────────────────────────────────────────────────────┐
│                    容量增强技术对比                              │
├──────────────┬──────────────┬──────────────┬──────────────────┤
│   基础 IM    │     GIM      │      MM      │       IQ         │
├──────────────┼──────────────┼──────────────┼──────────────────┤
│ 固定 k 个    │ k ∈ [k1,k2]  │ 每个子载波   │ I/Q 独立索引     │
│ 激活子载波   │ 可变激活数   │ 独立选模式   │ 并行处理         │
├──────────────┼──────────────┼──────────────┼──────────────────┤
│   C(n,k)     │  Σ C(n,ki)  │ k × Nm 模式  │   2 × C(n,k)     │
│   索引数     │  索引空间大  │  比特倍增    │   双倍索引       │
└──────────────┴──────────────┴──────────────┴──────────────────┘</code></pre><h3>📊 容量对比 (n=4, k=2, M=4)</h3><table><thead><tr><th align="center">技术</th><th align="center">索引比特 p1</th><th align="center">数据比特 p2</th><th align="center">总比特/子块</th><th align="center">vs 基础 IM</th></tr></thead><tbody><tr><td align="center">基础 IM</td><td align="center">2</td><td align="center">4</td><td align="center"><strong>6</strong></td><td align="center">基准</td></tr><tr><td align="center">GIM (k∈[1,4])</td><td align="center">4</td><td align="center">~5</td><td align="center"><strong>9</strong></td><td align="center">+50%</td></tr><tr><td align="center">MM (4模式)</td><td align="center">2</td><td align="center">8</td><td align="center"><strong>10</strong></td><td align="center">+67%</td></tr><tr><td align="center">IQ</td><td align="center">4</td><td align="center">4</td><td align="center"><strong>8</strong></td><td align="center">+33%</td></tr></tbody></table><blockquote>💡 <strong>MM 最强容量</strong>：通过模式选择比特，每个激活子载波额外携带 log₂(Nm) 比特。</blockquote><hr/><h2>🖥️ 运行环境</h2><h3>最低要求</h3><table><thead><tr><th align="left">项目</th><th align="left">要求</th></tr></thead><tbody><tr><td align="left"><strong>MATLAB版本</strong></td><td align="left">R2021b 或更高</td></tr><tr><td align="left"><strong>必需工具箱</strong></td><td align="left">Communications Toolbox</td></tr><tr><td align="left"><strong>基础依赖</strong></td><td align="left">P1 基础包</td></tr><tr><td align="left"><strong>内存</strong></td><td align="left">4 GB+</td></tr></tbody></table><h3>快速验证</h3><pre><code class="matlab">&gt;&gt; cd packages/P3_容量增强包
&gt;&gt; setup_path
&gt;&gt; generate_plots_enhanced</code></pre><hr/><h2>🧠 算法原理</h2><h3>GIM 广义索引调制</h3><p><strong>核心思想</strong>：允许激活子载波数量可变，融合多种 C(n,k) 组合。</p><p><strong>索引空间</strong>：</p><p>$$
|\mathcal{S}_{GIM}| = \sum_{k=k_{min}}^{k_{max}} C(n,k)
$$</p><p><strong>索引比特</strong>：</p><p>$$
p_{1,GIM} = \lfloor \log_2 |\mathcal{S}_{GIM}| \rfloor
$$</p><h3>MM 多模索引调制</h3><p><strong>核心思想</strong>：每个激活子载波独立选择调制模式。</p><p><strong>总比特数</strong>：</p><p>$$
p_{MM} = p_1 + k \cdot (\log_2 N_m + \bar{m})
$$</p><p>其中 $\bar{m}$ 为各模式的平均数据比特。</p><h3>IQ 独立索引调制</h3><p><strong>核心思想</strong>：I 和 Q 分量使用独立的激活模式。</p><p><strong>索引比特</strong>：</p><p>$$
p_{1,IQ} = 2 \times \lfloor \log_2 C(n,k) \rfloor
$$</p><hr/><h2>📁 项目结构</h2><pre><code class="text">P3_容量增强包/
├── 📂 gim/                     # GIM 广义索引
│   ├── gim_modulator.m         #   🚀 GIM 调制器
│   ├── gim_demodulator.m       #   GIM 解调器
│   └── gim_table.m             #   可变激活索引表
│
├── 📂 mm/                      # MM 多模调制
│   ├── mm_modulator.m          #   🚀 MM 调制器
│   └── mm_demodulator.m        #   MM 解调器
│
├── 📂 iq/                      # IQ 独立索引
│   ├── iq_modulator.m          #   🚀 IQ 调制器
│   └── iq_demodulator.m        #   IQ 解调器
│
├── 📂 core/                    # 继承 P1 核心模块
├── 📂 config/                  # 配置 (扩展 GIM/MM/IQ 参数)
│
├── 📂 docs/                    # 文档
│   ├── 算法文档.md              #   📘 三技术原理推导
│   ├── 代码文档.md              #   📒 接口说明
│   └── 项目文档.md              #   📗 本文档
│
├── generate_plots.m            # 📊 容量对比曲线
└── generate_plots_enhanced.m   # 📊 MM 多模星座图</code></pre><p><strong>代码统计</strong>：</p><ul><li>📄 25+ 个核心 MATLAB 文件</li><li>📝 2500+ 行精炼代码</li><li>💬 100% 中文详细注释</li></ul><hr/><h2>🎬 仿真演示</h2><h3>一键运行</h3><pre><code class="matlab">&gt;&gt; cd packages/P3_容量增强包
&gt;&gt; setup_path
&gt;&gt; generate_ber_plots  % 三技术 BER 对比</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608422" alt="p3_capacity_compare.png" title="p3_capacity_compare.png"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608423" alt="p3_gim_hist.png" title="p3_gim_hist.png" loading="lazy"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608424" alt="p3_mm_constellation.png" title="p3_mm_constellation.png" loading="lazy"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608425" alt="p3_variants_ber.png" title="p3_variants_ber.png" loading="lazy"/></p><hr/><h2>📦 您将获得</h2><table><thead><tr><th align="left">内容</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">📁 <strong>完整源码</strong></td><td align="left">GIM + MM + IQ 三技术完整实现</td></tr><tr><td align="left">📖 <strong>原理文档</strong></td><td align="left">索引空间扩展数学推导</td></tr><tr><td align="left">🚀 <strong>容量提升</strong></td><td align="left">最高 67% 频谱效率增益</td></tr><tr><td align="left">📊 <strong>对比工具</strong></td><td align="left">一键生成三技术性能对比</td></tr><tr><td align="left">🔧 <strong>灵活配置</strong></td><td align="left">可变 k 范围、模式数、调制阶数</td></tr><tr><td align="left">📡 <strong>可视化</strong></td><td align="left">多模星座图、容量对比曲线</td></tr></tbody></table><hr/><h2>🛒 获取方式</h2><p>本文代码仅为核心片段，完整版工程已整理好。 关注公众号 【<strong>3GPP仿真实验室</strong>】进行获取。</p><h2>📚 参考文献</h2><ol><li><strong>M. Wen et al.</strong> (2017): "Generalized Index Modulation Aided OFDM." <em>IEEE Trans. Wireless Commun.</em>, vol. 16, no. 3.</li><li><strong>B. Zheng et al.</strong> (2019): "Multiple-Mode OFDM with Index Modulation." <em>IEEE Trans. Signal Process.</em>, vol. 67, no. 9.</li><li><strong>E. Başar et al.</strong> (2017): "OFDM with Index Modulation Using In-Phase and Quadrature Indices." <em>IEEE Trans. Veh. Technol.</em>, vol. 66, no. 5.</li></ol>]]></description></item><item>    <title><![CDATA[Microsoft Office LTSC 2021 for Mac 16.106 - 文档、电子表]]></title>    <link>https://segmentfault.com/a/1190000047608474</link>    <guid>https://segmentfault.com/a/1190000047608474</guid>    <pubDate>2026-02-12 22:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Microsoft Office LTSC 2021 for Mac (Microsoft 365) 16.106 - 文档、电子表格、演示文稿和电子邮件</p><p>Office LTSC 2021 for Mac (Word, Excel, PowerPoint, Outlook + OneNote, OneDrive)</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=yf9Qwr2KLb%2BTYScDMwyFVA%3D%3D.ITt4QRJBTiJwD8dFlax%2BddAO2%2FzXSDcQgZJeA%2BHaUIg2nEEYtnhsPmjuoeK8%2BE2Y" rel="nofollow" target="_blank">https://sysin.org/blog/office-2021-for-mac/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=fk6M%2FzUUvhXZa5RCd1tbwQ%3D%3D.R7GLNJqYl2dB%2FOnrX4neb43l5rqVcdGrq8MTN2cJmgE%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>Office for Mac 2021 2026 年 2 月份月度更新来袭！</p><h2>Office for Mac 2021 组件和发行版</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608476" alt="Office LTSC" title="Office LTSC"/></p><p>2021.09.16，微软正式发布了 Office LTSC 2021，当然也包括 for Mac 版本，Office for Mac 2021 首个版本号为 16.53，与 Office 365 和 Office 2019 共享安装介质，通过许可的不同而区分版本和功能。请参看 <a href="https://link.segmentfault.com/?enc=2rcc4aathr15h1ELqJiKnA%3D%3D.Bhu1WGvfNS%2BzTYutqAuaTQiHRmlbw9Vq8idZtRwCiKW%2FECD2KUB3TKSNhbp6vtXKhI1vYCN4vDDgF4jw5bvM44mUG3yV459ofXOTlkp2PQH8W059ht485EREFB%2FA4SEcbOtELZf4sd5ETvE0ZAoWHA%3D%3D" rel="nofollow" target="_blank">Office 2021 for Mac 新增功能</a>。</p><p>Office for Mac 包含以下组件：</p><ul><li>Microsoft <strong>Excel</strong>：电子表格和数据分析</li><li>Microsoft <strong>Outlook</strong>：电子邮件和日历</li><li>Microsoft <strong>PowerPoint</strong>：创建吸引人的演示文稿</li><li>Microsoft <strong>Word</strong>：创建、编辑和分享文档</li><li>Microsoft <strong>OneNote</strong>：记录笔记、创意和备忘录</li></ul><p>Office for Mac 有以下两种发行版（详见下文描述）：</p><ul><li>Office for Mac (Office 365) pkg</li><li>Office LTSC for Mac DMG VL</li></ul><h2>Office for Mac 2021 (Office 365) pkg</h2><p>⚠️：<strong>请慎用此版本，需要 root 权限才能运行，安装一堆无用文件，强制自动更新。</strong></p><p>参看：<a href="https://link.segmentfault.com/?enc=L%2FQhAod1hhisJtmnUODXmg%3D%3D.1r58AIxqcshibjPzu2covEtBJ0d4P6zYl0GQvDBgaJsYvHafha2Y6CQ7KfzUwDPpix9uhFt%2BSVI0BoxCwVQerw%3D%3D" rel="nofollow" target="_blank">如何卸载 Office for Mac</a></p><p>此版本的唯一优点是开放下载，各大网站通常提供的也是此版本。</p><p><strong>Microsoft Office for Mac 2021 (Office 365) 16.106 Universal</strong>（2026-01-13）</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=Qd%2BaJ6Qx3N2jL8gNT0cXtw%3D%3D.8wg5WI1%2B4g3SWc%2BKAfU3U2b9VcyaT0aufNVrYxON97hjZWk6ck1X84v%2BxmZizQju" rel="nofollow" target="_blank">https://sysin.org/blog/office-2021-for-mac/</a></li><li>系统要求：从 16.101 开始，要求 macOS Sonoma 14.0 及以上版本。</li></ul><p>从 16.53 开始，Office 2021 和 Office 2019 是共用安装文件，通过许可证激活不同的版本，主要体现在界面风格上有较为明显差异，另外 2021 版有一些新增功能。</p><p>Office 365 是一种订阅模式，永久许可版即 Office LTSC for Mac。</p><h2>Office LTSC 2021 for Mac DMG VL</h2><p>该产品符合 Apple 平台设计规范，无需 root 权限安装，只需要拖拽到应用程序下即可，无需登录，没有自动更新程序，也不会提示过期。</p><ul><li>无需 root 权限，拖拽即可安装</li><li>无需登录账号（无需注册，支持离线使用）</li><li>无自动更新程序</li><li>不会提示过期</li><li>可以仅安装单个组件</li></ul><p>包含 Excel、Outlook、PowerPoint 和 Word 四个核心组件，可独立运行单个组件。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608477" alt="Microsoft Excel" title="Microsoft Excel" loading="lazy"/></p><p>Microsoft <strong>Excel</strong>：电子表格和数据分析</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608478" alt="Microsoft Outlook" title="Microsoft Outlook" loading="lazy"/></p><p>Microsoft <strong>Outlook</strong>：电子邮件和日历</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608479" alt="Microsoft PowerPoint" title="Microsoft PowerPoint" loading="lazy"/></p><p>Microsoft <strong>PowerPoint</strong>：创建吸引人的演示文稿</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608480" alt="Microsoft Outlook" title="Microsoft Outlook" loading="lazy"/></p><p>Microsoft <strong>Word</strong>：创建、编辑和分享文档</p><p>备注：OneNote 免费，需要登录。</p><p><strong>Microsoft Office LTSC for Mac 2021 DMG VL v16.54 (Final version)</strong> for macOS Mojave 10.14</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=filDvKZEKMSECicv3%2FPYgg%3D%3D.LX6qRbXtdzlGjjNtEGoPn3ranRorxuGknYzMRvdBLpJToADxwpXI7z3vusrP8RgR" rel="nofollow" target="_blank">https://sysin.org/blog/office-2021-for-mac/</a></li></ul><p><strong>Microsoft Office LTSC for Mac 2021 DMG VL v16.66 (Final version)</strong> for macOS Catalina 10.15</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=asvQNeLu0Pe%2FbGOybmvRgw%3D%3D.UAtFT9X8iRYgYRC9dTrxnCHrf7TH%2Bmfol5tHKbpQHuziRFA6viHm8dOmdoXbw%2BbB" rel="nofollow" target="_blank">https://sysin.org/blog/office-2021-for-mac/</a></li></ul><p><strong>Microsoft Office LTSC for Mac 2021 DMG VL v16.77 (Final version)</strong> for macOS Big Sur 11</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=QvUmz9gnis6X5BwMVouJVg%3D%3D.VD2BEQfxN3O2pBfqOFIH9ooG1oWdOJgZf9cCYVvX3rjmwi2ZhHs5c%2FFUiSiuAGyF" rel="nofollow" target="_blank">https://sysin.org/blog/office-2021-for-mac/</a></li></ul><p><strong>Microsoft Office LTSC for Mac 2021 DMG VL v16.89 (Final version)</strong> for macOS Montery 12</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=Qirr7wV6YnAaWiUEFkH%2FzQ%3D%3D.%2F0zvLrAc8wFgufg1sJ2R9dVa6DhazfxMrmTKsV3f3n4Bff8J2ECtY1%2BmLbgBys0P" rel="nofollow" target="_blank">https://sysin.org/blog/office-2021-for-mac/</a></li></ul><p><strong>Microsoft Office LTSC for Mac 2021 DMG VL v16.100 (Final version)</strong> for macOS Ventura 13</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=1jBUMZW4iQJgfBZk9arbvw%3D%3D.p5Q0eauLY7Z9aVYSyPzo9h0s5pc3PDK%2B%2B8klnd5VT23nLNAUXx0VHb%2FXZIxT8OVf" rel="nofollow" target="_blank">https://sysin.org/blog/office-2021-for-mac/</a></li></ul><p><strong>Microsoft Office LTSC for Mac 2021 DMG VL v16.106</strong> for macOS Sonoma 14 or later</p><ul><li>支持 macOS Sonoma 14、macOS Sequoia 15 和 macOS Tahoe 26</li><li>请访问：<a href="https://link.segmentfault.com/?enc=cDSQGF9N7UBzIoVEjB2brg%3D%3D.SzopchXroB7djR9A8fqXb2gGYrYJyGZY5TAzPniKPVJ6itm38C%2B1Qzf1Vcrk75v3" rel="nofollow" target="_blank">https://sysin.org/blog/office-2021-for-mac/</a></li></ul><hr/><p>新版链接：</p><ul><li><a href="https://link.segmentfault.com/?enc=s3y2Nv18dPUECBbZ8A2h8A%3D%3D.btTP8tgmdbmqLeTUjJI0ufHcYP9ewLWuwEWgqzWGQSJ85olpYjepL%2FNmAOaHfKS4" rel="nofollow" target="_blank">Microsoft Office LTSC 2024 for Mac (Microsoft 365) 16.106 - 文档、电子表格、演示文稿和电子邮件</a></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=nxR7aB42vAbeeD3rOqEChw%3D%3D.ycr9Lp4mTzVukyJLgPBEcNSeOCblNS5aowpu%2FJAU4lA%3D" rel="nofollow" target="_blank">macOS 下载汇总 (系统、应用和教程)</a></p>]]></description></item><item>    <title><![CDATA[Xampp集成环境包 安装步骤详解（附Apache、MySQL启动与本地网站搭建） 小童童 ]]></title>    <link>https://segmentfault.com/a/1190000047608327</link>    <guid>https://segmentfault.com/a/1190000047608327</guid>    <pubDate>2026-02-12 21:03:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><p><code>Xampp</code>是 <strong>XAMPP 集成环境包</strong>​ 的安装程序，把 Apache（网页服务器）、MySQL（数据库）、PHP（编程语言解释器）还有 Perl 打包到一起，装完就能在本地跑网站、做 PHP 开发或测试。</p><h2>一、准备工作</h2><ol><li><p><strong>下载安装包</strong>​</p><p><strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=E5Iyyv8UCY6m32x7P%2BnttA%3D%3D.Kl8XTfBy2mWETiYiynbPQxETMCxMrDDYyETZuzFTsbHpQiI%2FZLNMUTFb1TquZ4%2BL" rel="nofollow" title="https://pan.quark.cn/s/2e6ba302b1eb" target="_blank">https://pan.quark.cn/s/2e6ba302b1eb</a></p></li><li><p><strong>用管理员身份运行（推荐）</strong> ​</p><ul><li>右键 <code>Xampp.exe</code>→ 选“以管理员身份运行”，避免权限不足导致端口占用或服务启动失败。</li></ul></li></ol><h2>二、安装步骤</h2><ol><li>双击 <code>Xampp.exe</code>打开安装程序。</li><li>弹出语言选择 → 选  <strong>“English”</strong> ​ 或  <strong>“中文(简体)”</strong> （看版本支持）→ 点  <strong>“OK”</strong> 。</li><li>欢迎界面 → 点  <strong>“Next”</strong> 。</li><li><p>选择组件：</p><ul><li>默认是全选（Apache、MySQL、PHP、Perl、phpMyAdmin 等），新手直接保持默认，点  <strong>“Next”</strong> 。</li></ul></li><li><p>选安装路径：</p><ul><li>默认 <code>C:\xampp`，可点 “Browse” 改到其他盘，比如</code>D:\xampp`，然后点  <strong>“Next”</strong> 。</li></ul></li><li><p>Bitnami 提示：</p><ul><li>这个是可选的应用安装向导，不想用就取消勾选，点  <strong>“Next”</strong> 。</li></ul></li><li>点  <strong>“Install”</strong> ​ 开始安装，等进度条走完（几分钟）。</li><li>安装中会问是否装到开始菜单和桌面快捷方式 → 根据需要勾选 → 继续直到完成。</li><li>完成后会提示是否立刻运行 XAMPP 控制面板 → 勾上 → 点  <strong>“Finish”</strong> 。</li></ol><h2>三、首次运行与基本使用</h2><ol><li>打开 XAMPP 控制面板（桌面或开始菜单里找）。</li><li>左侧列表里找到 <strong>Apache</strong>​ 和 <strong>MySQL</strong>​ → 分别点  <strong>“Start”</strong> ​ 启动，绿灯亮表示正常运行。</li><li>浏览器输入 <code>http://localhost</code>或 <code>http://127.0.0.1</code>，能看到 XAMPP 欢迎页说明成功。</li><li><p><strong>放网站文件</strong>：</p><ul><li>默认网站根目录在 <code>C:\xampp\htdocs</code>（或你改的路径下的 htdocs 文件夹），把 PHP 文件或项目丢进去即可访问。</li></ul></li><li><p><strong>管理数据库</strong>：</p><ul><li>浏览器访问 <code>http://localhost/phpmyadmin</code>，用默认账号 <code>root</code>，密码为空登录，就能建库、导数据。</li></ul></li></ol><p>​</p>]]></description></item><item>    <title><![CDATA[《2025年度OpenAtom openKylin社区全景案例集》正式发布 openKylin ]]></title>    <link>https://segmentfault.com/a/1190000047608345</link>    <guid>https://segmentfault.com/a/1190000047608345</guid>    <pubDate>2026-02-12 21:02:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>本次发布的《2025年度OpenAtom openKylin社区全景案例集》（以下简称‘案例集’）由openKylin社区牵头编撰，众多产业领域优势企业、知名院校及杰出开发者共同参与。在2024版的基础上，新增收录了社区成员们在2025年的杰出技术成果和行业应用案例共40余项。通过这些案例，读者可以深入了解openKylin社区在技术创新、AI智能融合、应用生态拓展、行业应用等方面的最新进展，为广大技术爱好者、生态伙伴及行业从业者提供宝贵的参考资料，进一步推动开源技术生态的繁荣发展！</p><p><strong>案例集内容概览</strong><br/>1.社区简介及共建情况主要介绍openKylin社区从成立至今的发展历程、贡献者参与、上下游贡献成果、社区活动风采等内容，帮助大家快速了解社区、参与社区。<br/>2.根社区基础能力主要介绍openKylin作为开源操作系统根社区所具备的基础能力，包括核心组件选型维护能力、“可控开源”体系等，欢迎更多人参与到根社区的建设中来。<br/>3.技术创新项目主要介绍openKylin社区目前孵化的优秀技术创新项目，涵盖底层技术、桌面场景、生态技术、开发工具、安全能力、智能融合六大技术创新领域，帮助大家快速了解社区最新技术创新成果。4.生态适配案例主要介绍openKylin社区上下游生态伙伴主导的行业生态适配优秀案例，包括xPU硬件、整机、应用软件等方面，帮助大家快速了解社区生态适配工作，吸引更多行业生态加入openKylin社区，共建繁荣。<br/>5.行业应用案例主要介绍openKylin系操作系统（包括商业发行版、用户自用版以及社区版）在各行业领域中的应用实践案例，帮助解决行业核心场景中痛点问题，满足典型场景需求，为行业用户提供有示范效应的解决方案。<br/>6.社区爱好者构建成果主要介绍openKylin社区优秀开发者和爱好者在社区参与的桌面环境移植构建和内核构建成果，帮助有兴趣参与社区的个人开发者或爱好者找到适合自己的贡献方向。</p><ol start="7"><li>社区基础设施平台建设成果主要介绍openKylin社区当前基础设施平台建设成果，包括基础服务相关平台、一站式编译构建相关平台、学习成长平台、AI融合平台，帮助大家了解社区基础设施平台体系架构和目前可以支撑的能力，提升用户参与社区的体验和效率。</li></ol><p>点击链接下载案例集：<a href="https://link.segmentfault.com/?enc=LX9BeOEuDXTF4ouW9ydzdQ%3D%3D.Y5EBwouL8fe12Yj2ERB9IGIhehOWf4w8Q0XpmdVlRmOxKA64MpbOGAc5rSLyM70q2YB5pwdPI%2B0lD0gKJ%2Brodxfuq3nGlxtweF4YfnolMOzYeKK96Y8jVIh3qiWs2Ntp4PjWysiVvZceYjR%2BM%2FcQ7Q%3D%3D" rel="nofollow" target="_blank">https://www.openkylin.top/public/pdf/OpenAtom_openKylin_Commu...</a></p>]]></description></item><item>    <title><![CDATA[phpwind_UTF8_8.5部署步骤详解（含环境准备+安装教程） 无邪的课本 ]]></title>    <link>https://segmentfault.com/a/1190000047608353</link>    <guid>https://segmentfault.com/a/1190000047608353</guid>    <pubDate>2026-02-12 21:02:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><h2>一、先准备点东西（必看！）</h2><ol><li><strong>环境得有</strong>：本地或服务器得装好 PHP+MySQL+Apache/Nginx（比如用宝塔面板的话，直接一键装这仨就行；没面板就自己手动搭，新手建议用集成环境像phpStudy/WAMP，省事儿）。</li><li><strong>下载安装包</strong>：<strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=zJkLIKX5JJCMiwhbtMRdsw%3D%3D.9fiKPOcP11pcRWgFsmn3Ll3uPlEsy3xLoo1vdv%2FNabFZLeaO1f2cH3KOb9j4vxPV" rel="nofollow" title="https://pan.quark.cn/s/3c18c722e10a" target="_blank">https://pan.quark.cn/s/3c18c722e10a</a>   ，把 <code>phpwind_UTF8_8.5.zip</code>下到电脑/服务器上。</li></ol><h2>二、解压+扔到网站目录</h2><ol><li>先把 zip 包解压了，里面会有个类似 <code>phpwind</code>的文件夹（具体看压缩包里的内容，别整错）。</li><li>把这个文件夹里的<strong>所有文件</strong>，复制到你的网站根目录（比如 Apache 默认是 <code>htdocs</code>，Nginx 可能是 <code>www</code>或你自己设的目录，宝塔面板里就是“网站”对应的根目录，直接上传进去就行）。</li></ol><h2>三、给目录开权限（不然可能报错）</h2><p>找到网站根目录下的两个文件夹：</p><ul><li><code>data</code>（存数据用的）</li><li><code>upload</code>（存上传图片/文件的）</li></ul><p>右键这两个文件夹 → 属性（或权限设置）→ 把“写入权限”勾上（Linux服务器一般设 <code>755</code>或 <code>777</code>，Windows服务器直接给“完全控制”也行，新手别纠结数字，能写就行）。</p><h2>四、浏览器访问安装页面</h2><p>打开浏览器，输入你的网站地址（比如 <code>http://localhost</code>或你的域名），会自动跳转到 phpwind 的安装页面（如果没跳转，手动输 <code>http://你的域名/install.php</code>，一般在根目录下）。</p><h2>五、跟着安装向导走（傻瓜式操作）</h2><h3>1. 同意协议，下一步</h3><p>看到许可协议，拉到最下面点“我同意”，然后点“下一步”。</p><h3>2. 检查环境（有问题会标红，先解决再继续）</h3><p>这里会检测 PHP版本、MySQL扩展、文件夹权限这些。如果有标红的“失败”项：</p><ul><li>比如“PHP版本太低”：升级PHP（宝塔里直接在软件商店点升级）；</li><li>比如“data目录不可写”：回到第三步重新设权限；</li><li>都绿了（显示“成功”）再点“下一步”。</li></ul><h3>3. 填数据库信息（重点！别乱填）</h3><p>这里需要提前在 MySQL 里建一个<strong>空数据库</strong>（比如叫 <code>phpwind_db</code>，字符集选 utf8 或 utf8mb4，避免乱码）：</p><ul><li>数据库名：填刚才建的空库名（比如 <code>phpwind_db</code>）；</li><li>数据库用户名：一般是 <code>root</code>（如果你单独给phpwind建了个MySQL用户，就填那个用户名）；</li><li>数据库密码：你MySQL的 root 密码（忘了就去查配置文件，宝塔里在“数据库”页能看到）；</li><li>数据库主机：默认 <code>localhost</code>（不用改，除非你的数据库不在本地）；</li><li>表前缀：默认 <code>pw_</code>就行，不改也没事。</li></ul><p>填完点“测试数据库连接”，提示“连接成功”就点“下一步”。</p><h3>4. 设管理员账号（记好！别忘密码）</h3><ul><li>管理员账号：自己设个登录名（比如 <code>admin</code>）；</li><li>密码：设复杂点（字母+数字+符号），一定要记住！</li><li>邮箱：填个能收邮件的（找回密码用）。</li></ul><p>填完点“下一步”，等它跑完进度条。</p><h3>5. 安装完成！删安装文件（重要！防被黑）</h3><p>看到“安装成功”页面后，<strong>务必删掉或重命名根目录下的 <code>install.php</code>文件</strong>（或者整个 <code>install</code>文件夹，有的压缩包里有这个文件夹），不然别人可能通过它重复安装搞破坏。</p><h2>六、登录后台玩去吧</h2><p>安装完会自动跳转到首页，或者手动访问 <code>http://你的域名/admin.php</code>，用刚才设的管理员账号密码登录，就能进后台管理论坛了（发帖、设置板块啥的都在里面）。</p><p>​</p>]]></description></item><item>    <title><![CDATA[LLM创造力可以被度量吗？一个基于提示词变更的探索性实验 本文系转载，阅读原文
https://av]]></title>    <link>https://segmentfault.com/a/1190000047608356</link>    <guid>https://segmentfault.com/a/1190000047608356</guid>    <pubDate>2026-02-12 21:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大语言模型在demo阶段总是看起来很惊艳。但一旦进入到生产环境很多问题就暴露了：不稳定、不可预测，甚至直接不可用。</p><p>从实践来看核心问题很少出在模型本身。更多时候是在于如何设计、评估和迭代应用模型的提示词。LLM应用的输入提示词必须适配具体任务，才能让模型在期望的输出范围内工作。</p><p>提示词工程在今天基本还是被当作一种"艺术"。这篇文章要讨论的就是为什么这是个问题，以及怎么把它变成一门可度量的工程学科。</p><blockquote>提示词工程仍然是猜测</blockquote><p>大多数团队的提示词改进流程其实很粗糙：有人写（或重写）提示词，跑几个例子，主观觉得"感觉好了一些"，然后就上线了。</p><p>没有度量标准，没有基线，也没有对"更好"的明确定义。</p><p>这带来的直接后果是：提示词质量难以对比，评估基本靠外部响应来判断，回归问题不容易察觉，很多故障等到上线后才被发现。</p><p>提示词工程本质上极度主观，如果目标是构建可靠的AI系统，这就成了一个严重的瓶颈。</p><h2>实际LLM使用中的两个对立问题</h2><p>在生产环境里跑LLM，我发现有两个反复出现的问题。</p><blockquote>不一致性：同一个提示词，不同的答案</blockquote><p>同一条提示词跑多次会产生明显不同的输出。这不只是烦人的问题，而是对数据流水线、自动化决策系统、评估框架来说，这是实打实的可靠性风险。</p><p>高方差在这类场景下是bug不是feature。模型要么表现出确定性行为，要么至少得在可控范围内运行。</p><blockquote>缺乏多样性：模型不够有创造力</blockquote><p>反过来，有好几个实际项目中碰到了相反的困境：做创意生成、探索性分析、创意制作这类任务时，模型产出的内容彼此过于相似，概念覆盖面非常窄。一旦规模化，创造力就丢得干干净净。</p><p>这时候确定性就从优势变成了束缚。</p><h2>一个简单的假设</h2><p>提示词质量应该是可衡量的。</p><p>有些任务需要最小化输出方差，有些任务需要最大化多样性，而提示词的变更应该能推动结果朝可度量的方向移动。不同类型的任务也可以选择不同的度量标准。</p><p>既然模型行为可以衡量，提示词行为为什么不能？</p><p>为了验证这个想法，我选了模型行为的一个切面来入手：响应多样性，把它当作创造力的代理指标。</p><p>目标不是找到完美的度量方式，而是回答两个问题：提示词变更能不能转化为一致的数值差异？单次任务上的创造力/确定性到底取决于提示词还是仅取决于温度？</p><h2>实验设置</h2><p>实验规模不大，设计如下：</p><p>提示词</p><p>提示词A：</p><p>"Create 5 ideas of creative banners for performance marketing of an AI benchmarking platform."</p><p>提示词B在A的基础上加了一条指令：</p><p>"Create 5 ideas of creative banners for performance marketing of an AI benchmarking platform. Be as creative as possible."</p><p>模型和采样</p><p>采用单次生成模式，测试了多个LLM（具体型号这里略过），温度分别设为0 × max、0.5 × max和1 × max。每个（提示词、模型、温度）组合跑10次。</p><p>测试集选了4个主流模型家族的13个模型：OpenAI的GPT系列、Google的Gemini系列、Antropic的Claude系列，以及Deepseek。</p><p>通过Embedding衡量多样性</p><p>每条生成结果都计算了4096维的embedding向量。然后对每个实验集（固定提示词、模型和温度），取集合内embedding的最大成对距离作为响应多样性的度量。</p><p>逻辑很简单：距离小说明行为高度确定，距离大说明输出多样且有创造力。最终得到一个数值，描述模型响应的"分散程度"。</p><h2>结果</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608358" alt="" title=""/></p><p>汇总表，创意提示词版本导致了更显著的分散。同时温度并不总起作用。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608359" alt="" title="" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608360" alt="" title="" loading="lazy"/></p><p>基础提示词和创意提示词在模型-温度切片上的比较图。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608361" alt="" title="" loading="lazy"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047608362" alt="" title="" loading="lazy"/><br/>每个模型在不同温度水平上的响应分散图</p><p>结果比预期要清晰得多。</p><p>跨模型来看有三个明显趋势：在提示词中加入明确的创造力指令，曲线一致上移；提高温度在一定程度上增大了响应多样性，但受限于小样本，这个结论还需谨慎看待；各模型对温度变化的响应方式差异很大没有统一规律。</p><p>提示词变更带来的是可预测的数值效果，而非随机噪声。</p><p>这说明两件事：提示词迭代不必完全依赖直觉，输出创造力是可量化的；这一假设有可能推广到更大的样本和不同的应用场景。</p><p>这套方法的实际意义在于：提示词可以通过数值做A/B测试，温度调优有了度量依据而不是靠猜，模型选择可以由任务需求驱动而非跟风。</p><p>它让团队能在提示词变更上线之前就对效果做出推断。</p><h2>局限性</h2><p>结果虽然是正向的但有几个局限</p><blockquote>度量标准的任务特定性</blockquote><p>这里定义的"创造力"严格来说是任务相关的。用embedding距离衡量的响应多样性，在创意生成、营销创意、探索性任务上作为创造力的代理指标还算合理，但在事实性问答、代码生成、结构化数据提取这些场景下可能毫无意义，甚至会产生误导。</p><p>不能把它当成模型质量的通用指标。目前我也在测试其他面向不同任务的度量标准。</p><blockquote>对Embedding空间的依赖</blockquote><p>所有测量都建立在特定embedding模型和距离度量之上。换用不同的embedding模型、向量归一化方式或距离函数，绝对值也是会变的，所以模型间的相对排名也可能有所不同。</p><p>但本实验中观察到的趋势是稳定的，所以结果应当按相对值来解读，不宜绝对化。</p><blockquote>有限的样本量</blockquote><p>每个配置只跑了有限次数。趋势虽然一致，但要减少方差、估计置信区间、得出统计上站得住的结论，样本量还远远不够。当前的发现更多是探索性的，不是定论。</p><blockquote>提示词和领域偏差</blockquote><p>实验只用了一种任务表述和一个窄领域（效果营销创意）。换到其他领域或提示词风格，效果可能更弱、更强，也可能呈现完全不同的行为模式。把这些结论向创意任务之外推广需要格外谨慎。</p><blockquote>创造力与实用性的权衡</blockquote><p>响应多样性高不等于结果好。高度多样化的输出里可能混着不相关的想法、低质量的建议和不连贯的回复。这个实验测的是方差，不是实用性更不是商业价值。实际应用中创造力度量必须和质量过滤或下游评估配合使用。</p><blockquote>LLM的非平稳性</blockquote><p>大语言模型会被提供商持续更新，所以绝对分数可能随时间漂移，分数可能在提示词没改的情况下发生变化，可复现性也可能下降。任何长期的基准测试工作都必须把这种非平稳性纳入考量。</p><blockquote>相关性不意味着因果性</blockquote><p>最后要说的是，温度、提示词指令和响应多样性之间虽然有明确的相关性，但这不代表对模型行为有了完整的因果理解。实验证明的是"提示词变更可以被衡量"，而不是创造力可以被这套度量标准完全解释。</p><h2>总结</h2><p>这只是一系列研究的第一个实验，后续结果会在接下来的文章中陆续呈现。下一步计划：增加样本量，尝试不同的提示词，实验如何降低创造力，为其他类型任务定义新的度量标准，以及构建一个定期更新的模型排行榜来覆盖各项指标。</p><p><a href="https://link.segmentfault.com/?enc=24Jm%2BX7XSUR0lBw7fE%2BY9Q%3D%3D.EUeMMtmrp8O7ZIvXhPHv0LUM5mohaBOvUuQVkRO6LdkEJ8lMR1g8Is70%2BaNvi4LtT4b3MCXvFcF54%2ByOAiqXMQ%3D%3D" rel="nofollow" target="_blank">https://avoid.overfit.cn/post/e84eee36d7bc4263b9fd5dfe564e21d9</a></p><p>作者：Alexey Konoshenkov</p>]]></description></item><item>    <title><![CDATA[枫琳 (Fenglin) 人机共生智能协作平台 鸿枫 ]]></title>    <link>https://segmentfault.com/a/1190000047608204</link>    <guid>https://segmentfault.com/a/1190000047608204</guid>    <pubDate>2026-02-12 20:03:45</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>🍁 枫琳 (Fenglin)</h2><blockquote>人机共生智能协作平台 - 让智能自然融入生活</blockquote><hr/><h3>一、产品简介</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047608206" alt="" title=""/></p><p><strong>枫琳</strong> 是一款实现人与智能体（OpenClaw、OpenCode 等）和谐相处、共同交流、生活、工作的智能协作平台。支持接入钉钉、企业微信等办公软件，覆盖朋友圈、点赞、评论、私信等社区场景，实现人与机器人共生，共同进步，就像人与自然和谐共生一样。</p><h4>品牌理念</h4><table><thead><tr><th>字</th><th>含义</th><th>象征</th></tr></thead><tbody><tr><td><strong>枫</strong></td><td>四季流转，顺应自然</td><td>人与 AI 和谐适应、共同成长</td></tr><tr><td><strong>琳</strong></td><td>美玉相击，清音回响</td><td>思想交流、心灵共鸣</td></tr></tbody></table><blockquote><em>"枫叶由绿转红，是成长的印记；人机由陌生到默契，是共生的旅程"</em></blockquote><hr/><h3>二、核心功能</h3><h4>1. 🤖 智能体协作</h4><blockquote><em>枫叶随风起舞，人与 AI 自然共处</em></blockquote><ul><li><strong>多智能体协同工作</strong> - 支持 OpenClaw、OpenCode 等多种智能体</li><li><strong>智能任务分配</strong> - AI 自动分析并分配最优任务</li><li><strong>实时沟通反馈</strong> - 人机无缝对话，即时响应</li></ul><h4>2. 🏢 企业级集成</h4><blockquote><em>枫枝相连，生态融合</em></blockquote><ul><li><strong>钉钉深度集成</strong> - 无缝对接企业钉钉工作流</li><li><strong>企业微信对接</strong> - 支持企业微信生态</li><li><strong>自定义工作流</strong> - 灵活配置企业专属流程</li></ul><h4>3. 💬 社区生态</h4><blockquote><em>枫叶飘落，信息传递；琳玉相击，思想共鸣</em></blockquote><ul><li><strong>朋友圈动态分享</strong> - 发布图文、视频动态</li><li><strong>实时互动评论</strong> - 点赞、评论、转发</li><li><strong>安全私密对话</strong> - 端到端加密私信</li></ul><h4>4. ✨ 智慧共生</h4><blockquote><em>枫叶四季蜕变，持续成长</em></blockquote><ul><li><strong>知识共享沉淀</strong> - 构建团队知识库</li><li><strong>能力互补提升</strong> - 人机优势互补</li><li><strong>共同成长轨迹</strong> - 记录每一步进步</li></ul><hr/><h3>三、应用场景</h3><table><thead><tr><th>场景</th><th>描述</th></tr></thead><tbody><tr><td><strong>协同办公</strong></td><td>智能体助手帮你处理日常事务，如枫叶随风，自然流畅</td></tr><tr><td><strong>团队协作</strong></td><td>人机混合团队高效配合，如枫林成片，协作共生</td></tr><tr><td><strong>社交互动</strong></td><td>与 AI 伙伴分享生活，如枫语私语，获得理解与陪伴</td></tr><tr><td><strong>知识共创</strong></td><td>人类智慧与 AI 能力融合，如秋日枫林，收获满满</td></tr></tbody></table><hr/><h3>四、产品优势</h3><table><thead><tr><th>优势</th><th>说明</th></tr></thead><tbody><tr><td>🛡️ <strong>安全可靠</strong></td><td>企业级数据安全保障，如枫根深扎</td></tr><tr><td>⏰ <strong>全天候服务</strong></td><td>7×24 小时智能体在线，如枫叶常伴</td></tr><tr><td>⚡ <strong>高效智能</strong></td><td>AI 驱动的工作流，效率提升 300%</td></tr><tr><td>🌐 <strong>开放生态</strong></td><td>支持多种智能体接入，如枫林开放</td></tr></tbody></table><hr/><h3>五、品牌色彩体系</h3><table><thead><tr><th>颜色</th><th>色值</th><th>含义</th></tr></thead><tbody><tr><td>🔴 枫叶红</td><td><code>#C41E3A</code></td><td>温暖、活力、信任</td></tr><tr><td>🟡 秋金黄</td><td><code>#D4A017</code></td><td>收获、价值、希望</td></tr><tr><td>🟢 自然绿</td><td><code>#228B22</code></td><td>成长、生命、和谐</td></tr></tbody></table><hr/><h3>六、品牌 Slogan</h3><p><strong>主 Slogan：</strong></p><blockquote>枫琳，让智能自然融入生活</blockquote><p><strong>场景 Slogan：</strong></p><table><thead><tr><th>场景</th><th>Slogan</th></tr></thead><tbody><tr><td>品牌宣传</td><td>枫琳 — 人机共生，自然之道</td></tr><tr><td>产品介绍</td><td>枫琳，你的 AI 协作伙伴</td></tr><tr><td>社交场景</td><td>在枫琳，与 AI 成为朋友</td></tr><tr><td>办公场景</td><td>枫琳协创，工作更自然</td></tr></tbody></table><hr/><h3>七、开源项目</h3><p>本产品为开源项目，欢迎参与贡献：</p><p>🔗 <strong>Gitee 仓库：</strong> <a href="https://link.segmentfault.com/?enc=gFvMdIRPobQeTNyjakNgDQ%3D%3D.1HTXCw3mTbGYAYJgxDuZHeaiOTHNd1fuRCooZbXqNIuLm3e%2FQinyHvQfDUccs1QmBFb2BM73sDLe5LQ1xsdpeA%3D%3D" rel="nofollow" target="_blank">https://gitee.com/hongmaple/openclaw-dindin-chart</a></p><hr/><h3>八、快速开始</h3><h4>1. 注册账号</h4><p>访问枫琳官网，点击"免费试用"按钮</p><h4>2. 创建工作空间</h4><p>选择你的行业场景，系统将为你推荐合适的智能体</p><h4>3. 开始协作</h4><p>与智能体开始对话，让它成为你的得力助手</p><hr/><h3>九、联系我们</h3><table><thead><tr><th>渠道</th><th>信息</th></tr></thead><tbody><tr><td>📧 Email</td><td><a href="mailto:296155694@qq.com" target="_blank">296155694@qq.com</a></td></tr><tr><td>💬 微信</td><td>mapleCx330</td></tr><tr><td>🌐 官网</td><td>www.fenlin.ai</td></tr><tr><td>📦 开源项目</td><td><a href="https://link.segmentfault.com/?enc=isKs3OdkjoRz2LrZpO5Pqg%3D%3D.1XTIQR3xt6Hdy4IKwdNaEg7qu%2FtBL5z2Y5XtKVf32YJr%2BY%2Fn3I1oBPPX8CirF9RRolMiH0kiQUpaBDPUSKCDuw%3D%3D" rel="nofollow" target="_blank">https://gitee.com/hongmaple/openclaw-dindin-chart</a></td></tr></tbody></table><hr/><h3>十、相关链接</h3><table><thead><tr><th>项目</th><th>地址</th></tr></thead><tbody><tr><td>枫琳落地页源码</td><td><a href="https://link.segmentfault.com/?enc=bJBZ9lb9ID%2FLW9H8eE%2B2jw%3D%3D.Rns5mEMu5hbBPHg40JWLB4vlIf6dnk1LCmR3W%2Bnuv9oXdzj6vC9ME%2FA68rh2qQiF" rel="nofollow" target="_blank">https://gitee.com/hongmaple/fenlin-landing</a></td></tr><tr><td>枫琳 chat 开源项目</td><td><a href="https://link.segmentfault.com/?enc=PxBIuEK33RbLcykndB5k6Q%3D%3D.lnKZEEivtpEDAjnVcgAKten6Tza7CbNyILUk3JxZk6pYhCHlUwOSw2P7DRz0NykN0nTo%2Bo7Lg%2F5ox2utBh7jsA%3D%3D" rel="nofollow" target="_blank">https://gitee.com/hongmaple/openclaw-dindin-chart</a></td></tr></tbody></table><hr/><p><strong>🍁 枫琳 - 人机共生，自然之道</strong></p><p><em>让 AI 如枫叶般自然融入你的工作与生活</em></p><p>本文由<a href="https://link.segmentfault.com/?enc=29mm8%2B92F5TecmKbaRWbig%3D%3D.nKiP1N%2BNMKU74Omzrrd5zUieDMir%2BGRNApl5cj%2BLOCE%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[用 Go 实现一个可长期运行的 GitHub Webhook 服务实践 苏琢玉 ]]></title>    <link>https://segmentfault.com/a/1190000047608290</link>    <guid>https://segmentfault.com/a/1190000047608290</guid>    <pubDate>2026-02-12 20:02:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>前段时间我写过一篇文章，<a href="https://link.segmentfault.com/?enc=sFyUet9O2S9U7h9SFq5gQA%3D%3D.e8uq1bW1jZqjtmW2WWz8x9FJhm3MRUiGW2tW4QIJqKvslhzJA8IMROYBtd6fG0lw" rel="nofollow" target="_blank">记录自己作为一名 PHP 开发者自学 Go 的过程</a></p><p>那篇更多是学习阶段的整理。这次则是一次完整实践的复盘。</p><p>单点知识和系统能力之间始终存在差距。</p><p>理解一个概念并不难，但要把多个能力组合起来，形成一个可以长期运行的系统，往往需要真实项目去反复打磨。很多看似基础的东西，只有亲手做过，理解才会真正扎实。</p><p>最近我完成了一个小工具：<strong>github-webhook-listener</strong></p><p>一个用 Go 实现的 GitHub Webhook 接收服务，可以根据规则执行 Shell 命令，并内置一个简单的 Vue 面板，用于查看运行状态和执行记录。</p><p>功能本身并不复杂，AI 也完全可以在较短时间内生成类似的实现。但在实际开发过程中，我更在意的并不是功能本身，而是一些基础层面的设计问题：项目结构如何划分，依赖如何组织，边界如何定义，以及构建与部署如何简化。</p><p>这些内容未必新鲜，但当它们被组合到一个完整系统中时，体会是不同的。</p><p>项目地址我放在文章末尾，感兴趣可以自行查看下载使用。</p><p><img width="723" height="378" referrerpolicy="no-referrer" src="/img/bVdnVeJ" alt="" title=""/></p><p><img width="723" height="378" referrerpolicy="no-referrer" src="/img/bVdnVeK" alt="" title="" loading="lazy"/></p><p><img width="723" height="378" referrerpolicy="no-referrer" src="/img/bVdnVeL" alt="" title="" loading="lazy"/></p><p>下面我会从结构设计、并发模型以及构建方式三个方面，做一次相对完整的技术复盘。</p><hr/><h2>项目结构与职责划分</h2><p>项目核心代码放在 <code>internal</code> 目录：</p><pre><code>internal/
├── bootstrap
├── handler
├── service
├── repository
├── model
├── dto</code></pre><p>这种结构并不追求“标准答案”，重点在于依赖方向清晰。</p><h3>repository</h3><ul><li>只负责数据库操作</li><li>不包含业务判断</li><li>不依赖 HTTP</li></ul><h3>service</h3><ul><li>负责业务逻辑</li><li>调用 repository</li><li>不处理 HTTP 细节</li></ul><h3>handler</h3><ul><li>只做参数解析与响应封装</li><li>调用 service</li><li>不包含核心逻辑</li></ul><p>在功能简单时，这种分层似乎有些“多余”。</p><p>但当涉及到任务调度、执行记录、重试机制时，结构边界开始体现价值。</p><p>边界明确之后，功能扩展基本是“局部修改”，而不是结构性调整。</p><hr/><h2>在 bootstrap 中组织依赖关系</h2><p>所有初始化逻辑集中在 <code>bootstrap</code> 包中完成：</p><ol><li>初始化数据库</li><li>创建 repository</li><li>注入到 service</li><li>注入到 handler</li><li>注册路由</li></ol><p>依赖关系在入口处完全展开，而不是在各个文件中隐式创建。</p><p>这种方式带来的最大好处是：</p><ul><li>对象生命周期清晰</li><li>依赖方向可控</li><li>替换实现时改动集中</li></ul><p>在没有使用任何 DI 框架的情况下，通过显式构造函数完成依赖注入，本身就是对依赖关系的一种约束。</p><p>当项目规模不大时，这种方式反而比自动注入更透明。</p><hr/><h2>双队列 Worker Pool 的并发调度模型</h2><p>这个项目的核心之一，是执行 Shell 命令并控制并发数量。</p><p>我实现的是一个“双队列 Worker Pool”结构，主要包含三个核心组件：</p><ol><li><strong>任务生产者（Producer）</strong></li><li><strong>集中式调度器 + Worker Goroutine</strong></li><li><strong>结果处理器（Result Processor）</strong></li></ol><h3>第一层：任务生产者</h3><p>当 Webhook 触发或 Web 面板手动触发任务时，任务被封装为一个结构体，发送到调度队列。</p><p>这一层只负责“生成任务”，不关心执行细节。</p><hr/><h3>第二层：集中式调度器 + Worker Pool</h3><p>调度器内部维护：</p><ul><li>一个任务输入队列</li><li>一个固定数量的 worker goroutine</li></ul><p>调度流程：</p><ul><li>调度器从任务队列中取出任务</li><li>分发给空闲 worker</li><li>worker 执行 Shell 命令</li><li>将执行结果发送到结果队列</li></ul><p>worker 数量可控，因此系统并发是有上限的。</p><p>这种结构的优点：</p><ul><li>并发可控</li><li>不会因为 Webhook 高频触发而无限创建 goroutine</li><li>任务调度逻辑集中管理</li></ul><p>相比“每来一个请求直接开 goroutine 执行”的写法，这种结构在可控性和可扩展性上更好。</p><hr/><h3>第三层：结果处理器</h3><p>worker 不直接写数据库，而是把结果推送到结果队列。</p><p>结果处理器负责：</p><ul><li>更新执行记录</li><li>写入数据库</li><li>处理重试逻辑（如果有）</li></ul><p>这样做的目的，是进一步解耦：</p><ul><li>执行逻辑专注执行</li><li>持久化逻辑专注记录</li></ul><p>这就是“双队列”的意义：</p><ul><li>队列一：任务调度</li><li>队列二：结果处理</li></ul><p>这种分离在系统规模变大时尤为重要，因为执行耗时和持久化耗时是两个不同维度的问题。</p><hr/><h2>Makefile 作为构建入口</h2><p>项目使用 Makefile 统一管理：</p><ul><li>后端构建</li><li>前端构建</li><li>交叉编译</li><li>发布打包</li></ul><p>Makefile 在这里的意义并不是“少打几行命令”，而是：</p><ul><li>所有构建流程被显式记录</li><li>新环境下可直接复现</li><li>发布步骤标准化</li></ul><p>当一个项目开始涉及前后端协作、交叉编译和发布时，构建流程本身就成为项目的一部分。</p><hr/><h2>使用 embed 将前端资源打包进二进制</h2><p>这是我在这个项目中感受最明显的“Go 工程优势”。</p><p>前端使用 Vue 构建完成后，静态资源通过 <code>embed</code> 打包进 Go 二进制中。</p><p>然后通过：</p><pre><code class="go">http.FileServer(http.FS(...))</code></pre><p>直接提供访问。</p><p>最终效果是：</p><ul><li>只有一个可执行文件</li><li>不需要 Node 环境</li><li>不需要单独部署前端</li><li>不依赖外部静态文件目录</li></ul><p>从架构上看，它仍然是前后端分离：</p><ul><li>前端独立开发</li><li>后端提供 API</li></ul><p>但从交付形态看，它又像是传统单体应用：</p><ul><li>单文件分发</li><li>直接运行</li></ul><p>这种组合非常适合工具型项目和内部服务。</p><p>Go 在这一点上确实有明显优势：编译后就是完整产物，不需要运行时环境，不依赖包管理器，不依赖额外解释器。</p><p>分发成本几乎为零。</p><hr/><h2>写在最后</h2><p>这个项目没有刻意追求复杂设计，也没有引入额外框架。</p><p>它更像是一次完整的工程实践：把分层、依赖组织、并发控制、构建管理这些已经学过的能力组合在一起，形成一个可长期运行的系统。</p><p>我自己已经在实际环境中持续使用它，用来自动化部署和执行脚本，稳定性和可维护性都符合预期。对我来说，它已经从“练手项目”变成了日常工具。</p><p>如果你刚好也需要一个简单的 GitHub Webhook 执行工具，可以直接拿去用；</p><p>如果你正在学习 Go，想找一个结构完整、但复杂度可控的小项目作为参考，也可以看看实现细节。</p><p>GitHub 仓库地址：<a href="https://link.segmentfault.com/?enc=ZWyF5brWdytMPOmG5kvQjw%3D%3D.BqtnrQ%2FzXUZZOY098ej7iTsv3%2FCVKKLZn60p0Vpe3tG7%2Fr%2B4dTXn116JOe0iwFOH1GxoR7eQauoj6PvnxdxMJQ%3D%3D" rel="nofollow" target="_blank">点击查看</a></p><p>有问题或者想法，也欢迎直接在 GitHub 上交流。</p>]]></description></item>  </channel></rss>