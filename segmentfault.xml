<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[ICAIS 2025国际AI科学家大会日]]></title>    <link>https://segmentfault.com/a/1190000047400737</link>    <guid>https://segmentfault.com/a/1190000047400737</guid>    <pubDate>2025-11-14 21:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400739" alt="" title=""/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400740" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400741" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400742" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400743" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400744" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400745" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400746" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[告别“随心所欲”编程：Spec Kit ]]></title>    <link>https://segmentfault.com/a/1190000047400735</link>    <guid>https://segmentfault.com/a/1190000047400735</guid>    <pubDate>2025-11-14 21:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>告别“随心所欲”编程：Spec Kit 灵魂文件 Constitution 深度解析</h2><h3>I. 引言</h3><p>在软件开发中，我们依靠 AI 提升效率，但也面临一个挑战：AI 缺乏上下文，容易导致代码不一致甚至“随心所欲编程”（Vibe Coding）。</p><p>在<strong>上一篇文章</strong>中，我们介绍了 <strong>Spec Kit</strong> 这一规范驱动开发（SDD）框架及其五大核心元素：<strong>Constitution, Specification, Plan, Tasks, 和 Implement</strong>。</p><p>今天，我们将聚焦于 Spec Kit 的灵魂文件——<strong>Constitution (宪法/章程)</strong>。它是整个 SDD 流程的<strong>基石</strong>，为项目设立了<strong>不变的、必须遵守的规则</strong>。</p><p>Constitution 是一份<strong>非协商性（Non-negotiable）</strong>的最高法典。它的核心作用是：<strong>彻底终结“随心所欲编程”</strong>，确保无论是 AI 还是人类，都遵循相同的技术和质量标准，为项目设立一个永恒的“北极星”，保证代码的长期<strong>可维护性和合规性</strong>。简单来说，Constitution 定义了：<strong>无论如何，项目必须在什么界限内构建。</strong></p><hr/><h3>II. Constitution 的结构与作用</h3><p>Constitution 必须在项目开始之初就确定，并在整个生命周期中保持固定。</p><h4>作用机制</h4><p>Constitution 不会描述你要构建什么具体功能（那是 Specification 的工作），但它会深度影响 AI 代理在后续步骤中的所有决策：</p><ul><li><strong>约束输入：</strong> 当你要求 AI 制定计划（<code>/plan</code>）时，AI 必须基于 Constitution 中规定的技术栈（例如必须使用 React）来设计方案。</li><li><strong>验证输出：</strong> 在实施（<code>/implement</code>）阶段，AI 必须确保生成的代码满足 Constitution 中规定的质量标准（例如 90% 的测试覆盖率）。</li></ul><h4>三大核心组成部分</h4><p>一个结构严谨的 Constitution 通常包含以下三个关键部分，它们共同构筑了项目的开发哲学和技术底线：</p><ol><li><strong>核心原则 (Core Principles)：</strong> 定义项目的“开发哲学”和“质量底线”。（如用户体验 (UX) 必须遵循 GDS 标准、代码必须达到 A 级可读性、性能最低要求等。）</li><li><strong>技术约束 (Technical Constraints)：</strong> 锁定项目使用的技术和架构选择。（如必须使用 Go 语言、状态管理必须使用 Redux Toolkit 等。）</li><li><strong>质量与治理 (Quality &amp; Governance)：</strong> 设定不可妥协的测试、安全和合规标准。（如最低单元测试覆盖率必须达到 85%、提交信息必须遵循 Conventional Commits 规范等。）</li></ol><hr/><h3>III. 实践案例：Flutter 计时器应用的 Constitution 剖析</h3><p>为了更好地理解 Constitution 的实践意义，我们以一个具体的项目为例：<strong>构建一个跨平台的 Flutter 计时器应用。</strong></p><h4>Constitution 内容拆解与深度解析</h4><table><thead><tr><th align="left">Constitution 部分</th><th align="left">规则示例</th><th align="left">为什么必须写入？</th></tr></thead><tbody><tr><td align="left"><strong>核心原则</strong></td><td align="left">“应用必须在所有目标平台上保持流畅的 <strong>60 FPS</strong>。”</td><td align="left"><strong>【性能约束】</strong>计时器应用对实时性和性能要求极高。写入此条迫使 AI 在代码设计中优先考虑性能优化和减少重绘。</td></tr><tr><td align="left"><strong>技术约束</strong></td><td align="left">“状态管理必须使用 <strong>Riverpod</strong> 库。”</td><td align="left"><strong>【技术锁定】</strong>Flutter 有多种状态管理方案。锁定 <strong>Riverpod</strong> 可以确保团队和代码库的技术栈统一，避免 AI 随机选择，保证长期可维护性。</td></tr><tr><td align="left"><strong>技术约束</strong></td><td align="left">“在 Android 上使用 Material Design 风格，iOS 上可选择 Cupertino，但须保持整体设计的一致性。”</td><td align="left"><strong>【UX 规范】</strong>确保跨平台应用遵循平台原生风格，但同时又通过“保持一致性”的约束来防止设计上的分裂。</td></tr><tr><td align="left"><strong>质量与治理</strong></td><td align="left">“核心业务逻辑必须包含单元测试，<strong>覆盖率目标为 90%</strong>。”</td><td align="left"><strong>【质量硬指标】</strong>这是衡量 AI 产出质量的硬性指标。它强制 AI 不仅要写功能代码，还要为核心的计时逻辑编写高质量的测试代码。</td></tr><tr><td align="left"><strong>质量与治理</strong></td><td align="left">“提交信息必须遵循 Conventional Commits 规范。”</td><td align="left"><strong>【治理规范】</strong>保证 Git 历史清晰，方便自动化工具（如 CI/CD 流程）自动生成 Change Log 和版本号。</td></tr></tbody></table><h4>总结：Constitution 如何防止“跑偏”</h4><p>如果没有 Constitution，当你要求 AI 构建“一个计时器”时，它可能会随机选择一个过时或不流行的库、忽略单元测试、或者在代码中混用多种语言风格。</p><p><strong>Constitution 就像一个强大的“过滤器”</strong>，它在代码生成前就设定了边界和标准，确保 AI 的每一个输出都符合这些预设的、严格的、面向未来的项目标准。<br/>Constitution 是 Spec Kit 中最重要的文件，它决定了项目的方向和最终质量。我们不应将其视为额外的负担，而应将其视为<strong>成功的蓝图和对项目未来的投资</strong>。花时间精心起草这份文件，将为后续的开发工作节省大量返工和调试的时间。</p><p>本文由<a href="https://link.segmentfault.com/?enc=M34mIA5E7voZLHHINhTM%2FQ%3D%3D.ca%2B6RtU7kUHddVUHJr6rk0SfVK2fzLB10zLdSmGVxII%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[外贸公司外网怎么开？有哪些连接外网的方法]]></title>    <link>https://segmentfault.com/a/1190000047400556</link>    <guid>https://segmentfault.com/a/1190000047400556</guid>    <pubDate>2025-11-14 19:07:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>对于外贸企业来说，一条稳定、高速且安全的国际网络就是拓展业务必要工具，但是很多企业不知道如何选择哪种网络连接方式以及服务商，所以本篇内容为大家介绍外贸公司外网怎么开？有哪些连接外网的方法？一起往下看看吧。</p><p>一、外贸公司连接外网的两种主流方式</p><p>外贸公司稳定访问外网主要依赖于两类合规专线：传统国际专线和更现代的SD-WAN专线。它们之间的核心区别如下表所示：<br/><img width="723" height="296" referrerpolicy="no-referrer" src="/img/bVdm3dc" alt="" title=""/><br/>小结与建议：</p><p>传统专线适合对网络稳定性和安全性有极致要求、且预算非常充足的大型金融或跨国企业。</p><p>SD-WAN专线则凭借其智能、灵活和高性价比的特性，成为当前绝大多数外贸中小企业的首选，它能很好地满足跨境电商、视频会议、海外社媒运营等需求。</p><p>二、主流外贸网络专线服务商</p><p>主要可分为两大类型：<br/><img width="723" height="296" referrerpolicy="no-referrer" src="/img/bVdm3dd" alt="" title="" loading="lazy"/></p><p>小结与建议：</p><p>传统专线适合对网络稳定性和安全性有极致要求、且预算非常充足的大型金融或跨国企业。</p><p>SD-WAN专线则凭借其智能、灵活和高性价比的特性，成为当前绝大多数外贸中小企业的首选，它能很好地满足跨境电商、视频会议、海外社媒运营等需求。</p><p>三、如何选择合适的网络专线?</p><p>1、明确自身业务需求</p><p>业务类型：是日常办公、视频会议、跨境电商，还是TK直播?直播通常需要5M以上的稳定带宽。</p><p>覆盖地域：主要需要访问哪些国家和地区?</p><p>用户规模：公司内部有多少员工需要同时使用?</p><p>2、评估服务商</p><p>节点覆盖：确保服务商在您业务重点区域有充足的POP接入点。</p><p>SLA服务等级协议：仔细查看服务商对网络可用性(如99.9%)、延迟、故障响应时间的承诺。</p><p>安全与合规：务必确认服务商持有合法资质，提供的是合规线路，这是企业稳定运营的生命线。</p><p>3、平衡成本与预算</p><p>对比不同服务商的报价时，要了解清楚是独享带宽还是共享带宽，以及费用中是否包含安装、设备和IP地址等增值服务费。</p><p>4、考量部署与运维</p><p>确认服务商的部署速度和售后技术支持能力，是否提供7×24小时的技术支持。</p><p>四、外贸网络专线推荐</p><p>OSDWAN：尤其适合广大中小外贸企业。它提供合规、高性价比的解决方案，支持硬件和软件多种部署方式，全球节点丰富。</p><p>OSDWAN的核心优势</p><ol><li>合规安全的跨境连接</li></ol><p>OSDWAN使用三大运营商的合规国际网络专线，支持CPE硬件和专属软件，提供更灵活、智能和可管理的跨境专线网络。</p><p>在多个国家租用本地运营商家庭或商业宽带，向客户提供合法、稳定、长期使用的家庭IP地址。这对于需要访问国际服务或进行跨境数据传输的湖南企业来说，既保障了合规性，又确保了连接质量。</p><ol start="2"><li>性价比优势</li></ol><p>相比传统SD-WAN服务商与运营商的昂贵价格，OSDWAN走的是跟三大运营商（中国电信 、中国移动、中国联通）一样的线路，比如外贸办公价格690元/年起，并且企业专线比传统营业厅价格低至一半，性价比高。</p><ol start="3"><li>灵活简单的部署方式</li></ol><p>OSDWAN支持多种型号的CPE设备，还支持Windows、Mac、iPhone、安卓、iPad等多种终端，让企业员工随时随地一键连接全球互联网。</p><p>五、OSDWAN开通使用指南</p><p>以OSDWAN为例，开通使用非常简单：</p><ul><li>开通账号：联系服务商购买并开通账号，企业需要提供营业执照和实名信息。</li><li>下载客户端：在官网下载对应操作系统(Windows、macOS、手机端)的客户端软件。</li><li>登录连接：安装后打开软件，登录账号，根据业务场景(如企业SaaS、海外直播、开发科研等)选择合适的加速模式，点击连接即可。<br/>当日开通，一分钟即可连接使用。</li></ul><p><img width="723" height="474" referrerpolicy="no-referrer" src="/img/bVdm3df" alt="image.png" title="image.png" loading="lazy"/></p><p>六、常见问题解答(FAQ)</p><p>问：VPN可以用于公司业务吗?</p><p>答：绝对不建议。 企业私自搭建或使用未经授权的VPN进行跨境联网是明令禁止的，存在严重的法律风险。企业务必选择像OSDWAN这样的合规网络专线服务。</p><p>问：开通专线需要哪些企业资质?</p><p>答： 通常需要提供公司的营业执照等基本资质文件，用于服务商进行合规审核。</p><p>问：带宽选择多大合适?</p><p>答： 这取决于具体业务。普通办公1-5M可能足够，但高清视频会议或跨境直播则需要5M甚至更高的稳定带宽。建议与服务商沟通进行精准评估。</p>]]></description></item><item>    <title><![CDATA[从“事后抢险”到“事前防控”：江西水投用]]></title>    <link>https://segmentfault.com/a/1190000047400564</link>    <guid>https://segmentfault.com/a/1190000047400564</guid>    <pubDate>2025-11-14 19:06:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>小T导读</strong>：在洪涝频发的江西，江西水投打造了一套覆盖全域的智慧水利体系：实时采集水位、流量、水质等关键数据，借助 AI 与数字孪生进行动态推演，实现精准预警与智能调度。实践证明，这套系统让防汛从“事后抢险”变为“事前防控”，大幅提升了治理效率与安全保障。TDengine TSDB 正是这套体系的“定海神针”，承担起海量水情数据的实时采集、存储、处理与共享。本文由江西水投分享他们应用 TDengine TSDB 的相关经验，给到大家参考。</p><h2>应用背景</h2><p>江西作为长江流域五大暴雨区之首，受亚热带季风气候与鄱阳湖盆地地形影响，洪涝灾害频发且影响深远。几乎每年都有局部洪涝发生，较大规模灾害平均 3 至 5 年便会出现一次。仅 2024 年，全省就遭遇 33 次强降雨、14 次编号洪水，46 条河湖 117 个监测站点超警，鄱阳湖更创下 21 世纪以来第二高水位，超警时间长达 38 天。</p><p>在这样水情复杂的核心区域，江西水投正以物联网和 AI 技术重塑传统治水模式。江西省水利物联网平台整合物联网网关、数据中台与“五慧”AI 决策引擎，构建起覆盖 217 座水厂、服务近 2000 万人口的智慧治理网络。从蜂巢式智能测站织就的“神经末梢”，到数字孪生峡江水利枢纽实现的防洪调度可视化，再到 DMA 分区计量将管网漏损精准锁定，这套系统以 80 万+ 设备的泛连接筑牢供水防线，更借助“慧算”模型延长洪水预见期，让科技成为守护鄱阳湖生态与长江经济带水安全的核心支撑。</p><p>江西省水利物联网平台不仅覆盖全省水厂和管网，更在关键环节部署了精细化的感知单元。</p><h3>智能测站数据采集：实时感知现场状态</h3><p>依托蜂巢式智能综合测站，平台能够实时采集水务现场的多维度数据，既包含环境参数（温度、湿度），也覆盖设施运行状态（风扇启停、箱门开关、机箱进水、立杆倾斜度），同时还可监测 MCU 模块、主控模块、电源模块等核心硬件的工况。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400566" alt="" title=""/></p><p><strong>业务收益：</strong> 消除了传统水务监测的“数据盲区”，为后续分析与告警提供实时、全面的数据源。从源头确保设施运行状态精准可感知，夯实了监测的及时性与准确性基础。</p><h3>告警模型管理：精准识别异常风险</h3><p>在告警模型管理模块中，系统可灵活配置多类型业务规则，包括超阈值告警、极值突破告警、水位/雨量异常告警、超警戒告警、对比校验告警等，并支持对模型的启用/停用及规则详情进行精细化管控。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400567" alt="" title="" loading="lazy"/></p><p><strong>业务收益：</strong> 通过差异化的告警规则，全面覆盖水位超限、雨量异常、设备参数越界等典型水务风险场景，使监测从“被动应对故障”升级为“主动识别风险”，显著提升了异常发现的精准度与前瞻性，最大限度降低因异常未及时察觉而带来的安全隐患。</p><h3>告警发布与全流程管理：高效推动应急处置</h3><p>告警发布管理模块能够全要素记录并实时推送告警信息，涵盖告警编号、规则名称、级别、涉及设备/测站、时间、状态及通知情况，并支持“查看详情”“发送通知”等操作，串联起“告警触发—信息发布—人员响应”的闭环流程。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400568" alt="" title="" loading="lazy"/></p><p><strong>业务收益：</strong> 运维人员和管理部门可第一时间掌握告警详情（严重程度、发生位置、关联设施等），大幅缩短应急响应时长；同时，全流程的告警记录为后续复盘与管理优化提供依据，使水务应急处置从“经验驱动”升级为“数据驱动”，管理效率与规范性显著提升。</p><p><strong>总结：</strong> 通过“采集—分析—处置”的智能化流程，系统既实现了对水务运行状态的全方位感知与精准预警，又全面提升了应急处置的效率与规范性，为水务系统的安全与稳定运行提供了坚实支撑。</p><h2>TDengine TSDB 应用经验</h2><p><strong>TDengine TSDB 正是这套系统的“定海神针”，承担起实时数据采集、存储、处理与共享的核心任务。</strong>在此，我们结合业务在 TDengine TSDB 平台上的落地实践，分享过去几年的应用经验。</p><h3>时序数据库选型</h3><p>在早期的业务系统中，我们曾使用 Oracle 作为物联网实时数据的存储底座。但随着时序数据规模的快速增长，Oracle 的瓶颈逐渐显现，已无法高效支撑我们的业务：</p><ul><li>单表数据量达到千万级后，查询性能急剧下降，甚至出现无法响应的情况；</li><li>存量数据随时间累积持续膨胀，空间占用越来越大，存储成本直线提升。</li></ul><p>为此，我们系统性调研了多款时序数据库，最终选择 TDengine TSDB，原因在于其具备以下核心优势：</p><ul><li><strong>高吞吐性能：</strong> 单核即可支撑每秒 50 万条数据的写入与查询，并支持水平扩展，业务高峰期依然稳定运行；</li><li><strong>高压缩比：</strong> 数据压缩率可达 1:50，显著降低存储占用和成本；</li><li><strong>国产化适配：</strong> 完全支持国产 CPU 与操作系统，提升系统的自主可控能力；</li><li><strong>低成本拥有：</strong> 兼容标准 SQL，大幅降低迁移和学习成本。</li></ul><h3>标准化设备模型</h3><p>此前使用 Oracle/MySQL 时，我们习惯将所有设备数据集中存储在一张表中，导致模型冗杂、治理困难。引入 TDengine TSDB 后，超级表的架构优势为数据存储与治理之间搭建起天然桥梁，使业务应用的高效性与数据管理的便捷性得以兼得。</p><ul><li><strong>标准化设备管理：</strong> 通过超级表模板，将同类设备统一建模，实现治理从源头落地；</li><li><strong>标签化业务数据：</strong> 借助标签机制，将业务信息与数据信息有机融合，统一管理与应用；</li><li><strong>并行化数据处理：</strong> 通过超级表查询充分发挥分布式数据库的优势，实现毫秒级响应。</li></ul><p>以流量计为例，创建超级表 FlowMeter，即可对所有同类设备的数据进行标准化建模，简化了管理流程并提升了查询性能。</p><h3>高效的数据查询</h3><p>在 TDengine TSDB 中，各类设备的数据检索可直接通过标准 SQL 高效实现，不需要再像 Oracle 那样依赖复杂的表参数调优。例如在告警场景下，面对数十万设备的告警信息，系统依然能够在毫秒级完成查询，全面支撑业务应用的实时性需求。</p><p>其中，<strong>缓存 + last\_row</strong> 以及 <strong>超级表 + partition by</strong> 是最常用且实用的组合。以渗压计的实时监控为例：</p><ul><li>针对单个设备，开启缓存后使用 <code>last_row</code> 查询最新数据，仅需 <strong>4.8 毫秒</strong>：</li></ul><pre><code class="sql">taos&gt; select last_row(*) from nwater.shenyj where deviceid = 54000000034915 &gt;&gt; /dev/null;
Query OK, 1 row(s) in set (0.004813s)</code></pre><ul><li>针对所有设备，使用超级表查询近 4 万个设备的最新数据，仅需 <strong>167 毫秒</strong>：</li></ul><pre><code>taos&gt; select last_row(*) from nwater.shenyj partition by tbname &gt;&gt; /dev/null ;
Query OK, 37911 row(s) in set (0.167385s)</code></pre><h2>TDengine TSDB 版本升级</h2><p>在跨大版本升级时，我们的核心诉求是<strong>不停服升级</strong>，以尽量减少业务影响。经过 TDengine 专业服务团队评估，最终采用了三阶段在线升级方案，彻底消除了我们的升级顾虑：</p><ul><li><strong>阶段一：历史数据批量迁移</strong>——将原低版本数据从旧有集群，批量同步至新集群。</li><li><strong>阶段二：近线实时数据迁移</strong>——将历史数据同步期间产生的近线实时数据，从旧有集群，实时同步至新集群。</li><li><strong>阶段三：应用切换数据库</strong>——将应用原指向数据库切换为新数据库。</li></ul><p>实践中，在完成阶段一后，我们只用了 <strong>1 个工作日</strong>就完成了新旧系统的切换。整个过程中，应用只需修改数据库地址和部分查询语句，对业务基本无感知，数据始终保持一致，大大节省了运维和开发的人力与时间。</p><p>这一高效迁移的秘诀在于 <strong>TDengine 企业版工具 taosX</strong>。它支持以压缩方式实时同步集群间数据，无需手写迁移脚本，也无需考虑版本差异，迁移效率最高可达 <strong>千万行/秒</strong>，显著提升了升级的平滑性与可靠性。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400569" alt="" title="" loading="lazy"/></p><h2>4 年稳定运行下的经验汇总</h2><p><strong>在近 4 年的应用过程中，我们从 TDengine TSDB 2.2 升级至 3.3.6.x</strong>，一路见证了产品的不断增强与完善。期间双方紧密协作，积累了一些值得分享的经验，供大家参考：</p><ul><li><strong>及时沟通与需求反馈：</strong> TDengine TSDB 企业版提供专业服务支持，遇到技术问题应第一时间联系技术团队，以获取最佳实践指导，避免走弯路。同时，用户可将业务中遇到的功能需求及时反馈，企业用户往往能获得快速的响应与支持。</li><li><strong>持续关注产品升级：</strong> 随着 TDengine TSDB 的迭代，3.0 之后的版本功能更丰富、稳定性更高，升级过程也极为简便。常规升级可在不停服、不改应用的情况下，于小时级完成。</li><li><strong>定期开展巡检服务：</strong> 不要忽视 TDengine 提供的周期性自动化巡检服务，这能帮助我们提前发现潜在问题并及时处理，保障系统的稳定运行。</li></ul><h2>期待更多的可能性</h2><p>经过多年的探索与实践，江西水投已在“水务 + IoT”架构中走在业界前列。随着业务不断深入，我们将从更多维度开展水文监测与预测，尤其是结合气象数据开展中短期水文状况的趋势分析与相关性研究。这不仅会对 TDengine 提出新的挑战，也为双方合作开辟更广阔的空间。我们期待未来 TDengine TDgpt、IDMP 等新一代产品为水务治理注入更强的智能能力，助力构建更加安全、智慧的水务体系。</p><h2>关于江西水投</h2><p>江西省水投江河信息技术有限公司（以下简称“江河信息”）成立于 2018 年 6 月，是江西水投旗下全资二级企业，是一家集咨询规划、软硬件研发、综合运营为一体的高新技术国有企业。公司承担江西省智慧水利建设项目法人及江西水投集团信息化建设项目法人职责，致力于成为江西数字经济产业的标杆服务商、全国智慧水利领域的一流运营服务商。</p><p><strong>作者 | 江西省水投江河信息技术有限公司 刘博武</strong></p>]]></description></item><item>    <title><![CDATA[Cantata 25.07 全新上线：完]]></title>    <link>https://segmentfault.com/a/1190000047400574</link>    <guid>https://segmentfault.com/a/1190000047400574</guid>    <pubDate>2025-11-14 19:05:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Cantata 25.07版本全新发布！此版本为以代码编辑器为中心的用户添加了更多功能，包括完整的CLI测试脚本创建和执行以及新的测试用例编辑，更新了最新铁路软件标准EN 50716:2023的工具认证，增强了代码覆盖率报告，并进一步扩展了支持的平台。此外，在此版本中修复了核心组件和辅助工具中的许多错误。</p><p>Cantata 25.07还包含许多其他生产力和灵活性增强以及修复。全套更改记录在发行说明中，该说明跟踪了Cantata自4.0版本以来的所有更改。此版本中最重要的更改将在以下部分中突出显示。</p><h3>完整的CLI测试脚本生成</h3><p>对于许多以代码编辑器为中心的Cantata用户（例如在VSCode等编辑器中开发测试的用户）来说，Cantata  25.07中的新命令行测试脚本生成器实用程序将是一个受欢迎的生产力提升。这个新的headless  Eclipse实用程序使用一些可配置的选项和其他默认设置，完全从命令行生成Cantata测试脚本。</p><p>只要有一个现有的Eclipse工作区，该实用程序就会提供生成工作测试脚本所需的所有选项，包括：</p><ul><li>测试的位置，绝对和相对路径</li><li>测试脚本名字</li><li>CSI文件位置</li><li>桩和封装函数的生成</li><li>使用Cantata makefile构建测试或将其放置在正在测试的源代码旁边</li><li>测试用例生成（无用例、每函数1用例、AutoTest以及使用或不使用测试步骤）</li><li>代码覆盖率规则集</li></ul><h3>新的设置测试输入的宏</h3><p>在25.07版本中，为以代码编辑器为中心的用户添加了新的Cantata Library宏 SET_TEST_INPUT。这增加了编辑测试脚本时的功能，可以直接设置输入值并将该输入值记录到生成的Cantata测试结果文件（.CTR）中，而不用复制代码。这个新宏只接受一个参数var，它应该是一个有效的变量赋值。以下示例显示了一个测试用例和生成的测试结果报告部分。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400576" alt="图片" title="图片"/><br/>​<br/>图 1 测试用例</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400577" alt="图片" title="图片" loading="lazy"/><br/>​<br/>图 2 测试结果文件片段</p><h3>CPPGETCOV扩展上下文覆盖率</h3><p>Cantata的经过认证的工具CPPGETCOV是一个可执行文件，在一个或多个Cantata代码覆盖率（.COV）文件上运行，以生成适合认证的Cantata测试结果文件（.CTR）。传统的代码覆盖率衡量源代码构造的执行情况，但不考虑代码对象执行的上下文。根据上下文的不同，相同的源代码可能表现不同（例如，在多个线程中运行、在多个继承中运行多态基类代码或在不同状态下运行状态机代码）。Cantata提供了将结构代码覆盖率与其执行上下文叠加（测量和过滤）的能力。这允许用户根据上下文区分代码覆盖率。Cantata上下文覆盖的应用包括：</p><ul><li>继承</li><li>状态机</li><li>线程</li></ul><p>Cantata会自动收集继承上下文的代码覆盖率。可以使用添加到测试脚本中的user_context_function来设置状态上下文或线程上下文的代码覆盖率，该函数定义了执行被测源代码的可能不同上下文。</p><p>在Cantata 25.07中，CPPGETCOV得到了增强，可以对不同的代码上下文进行覆盖率报告。--context:&lt;string&gt;参数指定覆盖率报告的上下文字符串，而--function:&lt;name&gt;参数指定要报告的函数或方法。这两个参数默认都是“*”。</p><h3>故障修复</h3><p><strong>核心组件</strong></p><p>经过认证的核心组件中有30多个缺陷得到了解决。亮点包括：</p><ul><li>修复了调用返回覆盖率与模板函数、lambds和构造函数不一致的问题。</li><li>改进了与Boost和C++20构造的兼容性。</li><li>增强CTR2HTML转换逻辑。</li><li><p>许可证日志、测试工具缓冲区管理和表达式评估的稳定性改进。</p></li></ul><h3>补充工具</h3><p>补充工具的改进。亮点包括：</p><ul><li>AutoTest增强了对复杂数据类型和联合访问的处理</li><li>Eclipse UI元素、测试用例生成和部署工具可靠性的修复</li><li>为国际用户更正缺失或错误报告的教程内容</li></ul><h3>更新了平台支持版本</h3><p>Cantata的每个版本都有支持平台的变化。</p><p>Cantata紧密地与Eclipse®的IDE环境集成，提供Eclipse-Ready®插件。Cantata 25.07建立在Eclipse 2024-12版本（Eclipse 4.34）上，也可以作为从Neon（4.6）版本直到Eclipse 2023-12（4.30）版本的Eclipse-Ready插件来安装：</p><ul><li>Eclipse 4.6 (Neon)</li><li>Eclipse 4.7 (Oxygen)</li><li>Eclipse 4.9 (2018-09)</li><li>Eclipse 4.14 (2019-12)</li><li>Eclipse 4.15 (2020-03）</li><li>Eclipse 4.16 (2020-06)</li><li>Eclipse 4.19 (2021-03)</li><li>Eclipse 4.23 (2022-03)</li><li>Eclipse 4.24 (2022-06)</li><li>Eclipse 4.30 (2023-12)</li></ul><p>Cantata 25.07增加了对Microsoft Visual Studio 2022和GNU GCC for C/C++ 14和15版本。完整的支持平台列表如下：</p><p>在Windows（32和64位）版本7、8/8.1、10、11上：</p><ul><li>Microsoft Visual C++ (32-bit): 2010, 2013, 2015, 2017, 2019, 2022</li><li><p>GNU GCC for C/C++: 4.6.2 to 13.2.x</p></li></ul><p>在Linux（32和64位）内核发行版无关版本3.x、4.x、5.x、6.x上：</p><ul><li><p>GNU GCC for C/C++: 3.4.6 to 15.1.x</p></li></ul><p>了解更多有关Cantata的技术信息及商务服务，请访问<a href="https://link.segmentfault.com/?enc=JOei6ZUWltYaPoGikV3xQQ%3D%3D.60%2FbD0iNKqC%2FuLYKxR%2Fyzfp2yZzu8vyfdFtkmQcu7JM%3D" rel="nofollow" target="_blank">http://www.softtest.cn/</a>留言，或按以下方式联系旋极智能：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400578" alt="图片" title="图片" loading="lazy"/><br/>​</p><p>获取更多资讯▼关注我们<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400579" alt="图片" title="图片" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[越南纯净住宅IP怎么收费的？一个月多少钱]]></title>    <link>https://segmentfault.com/a/1190000047400586</link>    <guid>https://segmentfault.com/a/1190000047400586</guid>    <pubDate>2025-11-14 19:04:35</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>最近，很多用户都想做越南地区的Tik Tok，那么选择一个纯净住宅IP是非常重要的，可以有效避免Tik Tok的风控机制，但是很多新手用户不知道越南纯净住宅IP的价格，所以本篇内容为大家详细介绍。具体如下：</p><p>一、越南纯净住宅IP是什么？为什么需要？</p><p>越南纯净住宅IP指的是来源于越南本地网络服务提供商(ISP)、分配给真实家庭宽带用户的IP地址。与数据中心IP相比，它们最大的特点是直接关联到一个真实住宅地址，因此具有更高的信任度。</p><p>这类IP的核心价值在于其真实性和隐蔽性，能有效规避许多网站针对数据中心IP和代理服务器的访问限制。这对于需要模拟越南本地真实用户行为的业务至关重要。</p><p>其主要作用体现在以下几个方面：</p><p>1、社交媒体平台：Facebook、Zalo、Instagram、Tik Tok和本地平台Gapo在越南广泛使用。这些平台对IP变动异常敏感，频繁切换IP或使用数据中心IP可能导致账号被标记为异常，要求稳定的本地住宅IP环境。</p><p>2、电商平台：Shopee、Lazada、Tiki等主流电商平台会基于IP地址展示差异化内容和定价。使用越南本地IP可以获得真实的本地用户体验，准确监控竞争对手动态和价格策略。</p><p>3、通讯工具与流媒体：Zalo是越南主流的通讯工具，Netflix、YouTube等流媒体平台也拥有大量用户。这些服务一般对于IP类型要求比较高，建议使用纯净的住宅IP。</p><p>4、支付与金融系统：Momo、VNPay等本地电子钱包和银行应用为保障安全，常会阻止来自外国IP的登录尝试，需要靠谱的越南IP才能顺畅操作。</p><p>越南网络环境的一个显著特点是，即使IP地址显示在越南，某些网站仍可能因DNS缓存或浏览器语言设置拒绝提供服务。清理DNS缓存(命令提示符中输入ipconfig/flushdns)并将浏览器语言改为越南语是必要的辅助措施。</p><p>二、越南IP有哪些类型？不同IP有哪些差异？</p><p>选择合适的越南IP前，需明确各类IP的关键区别：</p><p><img width="723" height="265" referrerpolicy="no-referrer" src="/img/bVdm3dn" alt="" title=""/></p><p>选择的关键因素：</p><p>业务持续性要求：长期业务如电商店铺管理、社交媒体运营应选择静态住宅IP或者原生住宅IP，它提供不变的IP地址，建立可靠的数字身份。临时任务如市场调研则适合成本更低的动态住宅IP。</p><p>账号安全等级：高价值账号务必使用独享IP，共享IP池中其他用户的行为可能导致“连坐封号”。</p><p>我们OSDWAN提供合规专线网络及不同类型的IP（机房、普通住宅、原生住宅等等，满足不同场景的业务需求）。</p><p>三、越南纯净住宅IP怎么收费的？有哪些注意事项？</p><p>越南纯净住宅IP的收费方式灵活多样，以下是收费模式参考：</p><p>主要的收费模式包括：</p><p>按IP数量计费：许多代理服务商会根据你需要的独享IP数量来定价。例如，OSDWAN提供包括越南以及100+国际的住宅静态IP，其中越南独享静态IP费用参考价为50-200元/月/个。</p><p>按流量计费：部分服务商会按照实际使用的数据流量（例如每GB） 来收费，这种模式适合流量需求波动较大的用户。</p><p>按时间套餐计费：提供日、周、月、年等不同时长的套餐，购买时间越长，通常单价越划算。</p><p>混合计费模式：有些服务商会将以上几种模式结合，例如，在月费基础上包含一定量的流量，超出部分另行计费。</p><p>选购时需要关注的要素：</p><p>IP纯净度与独享性：务必确认IP是真实住宅IP且为独享。共享IP容易被滥用，导致连带风险。而OSDWAN提供真实并且可靠的住宅静态IP，可以通过检测工具去检查。</p><p>以下是OSDWAN的越南原生住宅IP真实检测图：</p><p><img width="640" height="824" referrerpolicy="no-referrer" src="/img/bVdm3dH" alt="image.png" title="image.png" loading="lazy"/></p><p>服务商的技术实力：考察其网络稳定性(如SLA服务等级协议)、可用率以及并发连接数是否满足需求。</p><p>合规性与售后服务：选择能提供7*24小时技术支持的服务商非常重要。同时，要明确服务条款，确保你的使用方式符合当地法律和服务商的规定。</p><p>四、如何选择靠谱的服务商购买？哪些好？</p><p>购买越南纯净住宅IP，通常遵循以下步骤：</p><p>1、明确需求：首先想清楚你需要静态还是动态IP、需要多少个、带宽和流量要求大致是多少。</p><p>2、寻找服务商：建议选择拥有合法资质的服务商购买，比如OSDWAN是通过工信部备案的。</p><p>3、测试验证：务必利用服务商提供的免费试用或测试流量。重点测试IP的纯净度(是否被主要网站识别为代理)、速度以及稳定性。</p><p>4、选择套餐并购买：根据测试结果和业务需求，选择合适的套餐并付款。</p><p>哪家好？推荐OSDWAN，具体如下：</p><p>OSDWAN采用运营商合规国际网络专线，100+地区高纯净度原生住宅静态IP，在多个国家租用本地运营商家庭或商业宽带，向客户提供合法、稳定、长期使用的家庭IP地址来源，纯净独享，可用于TK直播 。</p><p>五、 常见问题解答</p><p>问：越南纯净住宅IP和机房IP有什么区别？</p><p>答：主要区别在于来源和信任度。住宅IP来自ISP，关联真实家庭地址，信任度高；机房IP来自数据中心，可能一个IP被多个用户共用，容易被网站的风控系统识别和拦截。</p><p>问：购买时如何验证IP确实是纯净住宅IP？</p><p>答：你可以使用一些在线的IP信息查询网站。在连接代理后访问这些网站，检查IP的归属机构是否为知名的越南ISP(如VNPT、FPT、Viettel)，以及IP类型是否被识别为”residential”或”ISP”。</p><p>问：可以指定越南某个城市的IP吗？</p><p>答：可以。一些高级的代理服务支持城市级甚至运营商级的IP定位。例如，OSDWAN就支持在全球100多个国家和地区进行城市级别的定位。在购买前，你可以和服务商的确认哪个地区。</p>]]></description></item><item>    <title><![CDATA[【HarmonyOS 6】SpeechK]]></title>    <link>https://segmentfault.com/a/1190000047400590</link>    <guid>https://segmentfault.com/a/1190000047400590</guid>    <pubDate>2025-11-14 19:03:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>【HarmonyOS 6】SpeechKit中的朗读控件，初始化前不进行窗口舞台的设置，也不会报错，与文档描述不符。</h2><h2>一、前言</h2><p>该文为官方文档bug信息同步帖，结尾有bug官方回复。便于大家信息同步。</p><p>前段时间应用升级到HarmonyOS 6，系统提供了很多酷炫的API和功能Kit。对于AI赋能朗读控件，我们在集成后发现了一些问题，由此产生了下面的问题背景。</p><h2>二、问题背景</h2><p>如下图所示，官方文档中强调，朗读控件需要在init前，在EntryAbility中进行如下操作：</p><pre><code class="typescript">    WindowManager.setWindowStage(windowStage);</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400592" alt="在这里插入图片描述" title="在这里插入图片描述"/><br/>但实际上，不进行该操作，直接调用init初始化朗读控件，不会报错，可将以下DEMO源码，可直接新建工程后，贴到index.ets类中，启自动签名后，启动查看效果。</p><pre><code class="typescript">// 导入语音朗读相关的组件和类型
import { TextReader, TextReaderIcon, ReadStateCode } from '@kit.SpeechKit';

@Entry
@Component
struct Index {

  /**
   * 待加载的文章列表
   */
  @State readInfoList: TextReader.ReadInfo[] = [];

  /**
   * 当前选中的文章
   */
  @State selectedReadInfo: TextReader.ReadInfo = this.readInfoList[0];

  /**
   * 朗读状态
   */
  @State readState: ReadStateCode = ReadStateCode.WAITING;

  /**
   * 初始化状态标记
   */
  @State isInit: boolean = false;

  // 组件即将显示时触发
  async aboutToAppear(){
    /**
     * 模拟加载文章数据
     */
    let readInfoList: TextReader.ReadInfo[] = [{
      id: '001',
      title: {
        text:'水调歌头.明月几时有',
        isClickable:true
      },
      author:{
        text:'宋.苏轼',
        isClickable:true
      },
      date: {
        text:'2024/01/01',
        isClickable:false
      },
      bodyInfo: '明月几时有？把酒问青天。不知天上宫阙，今夕是何年？'
    }];

    // 更新状态变量
    this.readInfoList = readInfoList;
    this.selectedReadInfo = this.readInfoList[0];

    // 初始化朗读组件
    this.init();
  }

  /**
   * 初始化朗读组件
   */
  async init() {
    // 朗读参数配置
    const readerParam: TextReader.ReaderParam = {
      isVoiceBrandVisible: true, // 显示品牌信息
      businessBrandInfo: {
        panelName: '小艺朗读', // 面板名称
        panelIcon: $r('app.media.startIcon') // 面板图标
      }
    }

    try {
      // 获取上下文
      let context: Context | undefined = this.getUIContext().getHostContext()
      if (context) {
        // 初始化朗读组件
        await TextReader.init(context, readerParam);
        this.isInit = true; // 标记初始化完成
        this.setActionListener(); // 设置事件监听
      }
    } catch (err) {
      // 初始化失败时打印错误信息
      console.error(`TextReader failed to init. Code: ${err.code}, message: ${err.message}`);
    }
  }

  // 设置朗读事件监听
  setActionListener() {
    // 监听朗读状态变化
    TextReader.on('stateChange', (state: TextReader.ReadState) =&gt; {
      this.onStateChanged(state);
    });

    // 监听加载更多请求
    TextReader.on('requestMore', () =&gt; {
      TextReader.loadMore([], true);
    })
  }

  // 处理朗读状态变化
  onStateChanged = (state: TextReader.ReadState) =&gt; {
    // 只处理当前选中文章的状态变化
    if (this.selectedReadInfo?.id === state.id) {
      this.readState = state.state;
    } else {
      this.readState = ReadStateCode.WAITING;
    }
  }

  // 构建UI界面
  build() {
    Column() {
      // 朗读状态图标
      TextReaderIcon({ readState: this.readState })
        .margin({ right: 20 })
        .width(32)
        .height(32)
        .onClick(async () =&gt; {
          // 点击图标时开始朗读
          try {
            await TextReader.start(this.readInfoList, this.selectedReadInfo?.id);
          } catch (err) {
            // 朗读失败时打印错误信息
            console.error(`TextReader failed to start. Code: ${err.code}, message: ${err.message}`);
          }
        })
    }
    .height('100%')
  }
}</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400593" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h2>三、问题反馈：</h2><p>目前官方文档已更新，setWindowStage，新增设备行为差异说明，在手机设备上，不需要调用该接口，直接初始化朗读朗读控件就可以了。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400594" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[[大厂实践] 超越极限：利用路由服务器实]]></title>    <link>https://segmentfault.com/a/1190000047400603</link>    <guid>https://segmentfault.com/a/1190000047400603</guid>    <pubDate>2025-11-14 19:03:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><em>本文介绍了 Zalando 如何通过引入路由服务器（RouteSRV）帮助 Skipper Ingress 应对高速增长的流量，以更有效管理控制平面并确保集群稳定运行的实践。原文：<a href="https://link.segmentfault.com/?enc=NdY0F7tfrhqLDqQbqedbSg%3D%3D.B5xf1FOWHBsurDBNt6NBlsnCAZykPX2ClOGZm2%2BEniJ4CfHqXyAhnsX42rG2AwqdDZnx1wfR7Yz5ishnRLtvs2U4hnHsc%2FD2ORjc1B3t3ouSg7DzUJkVbahFHpfYG%2BE2mXNDPzdqQNtvKdtuuT8iDA2XqCX9J0vCocTRdCxmITc%3D" rel="nofollow" title="Scaling Beyond Limits: Harnessing Route Server for a Stable Cluster" target="_blank">Scaling Beyond Limits: Harnessing Route Server for a Stable Cluster</a></em></blockquote><h2>简介</h2><p>在 Zalando，我们正面临严峻挑战：入口控制器有可能使 Kubernetes 集群不堪重负。我们需要能够应对不断增长的流量并实现高效扩展的解决方案，本文将介绍我们如何实现路由服务器以更有效管理控制平面流量并确保集群稳定运行的实践。</p><h2>Skipper：Ingress 控制器</h2><p>我们用 <a href="https://link.segmentfault.com/?enc=m%2FYotSIcJLCdV08oCP2Lyg%3D%3D.RwqX8SUcGuNnv%2FWcQoY4KRkT4nq%2BEPzevR6hqsWBkWshuEVg7uOECnvivPqMDkQb" rel="nofollow" title="Skipper" target="_blank">Skipper</a>（HTTP 反向代理）来实现 <a href="https://link.segmentfault.com/?enc=qYbGgVzzd0MjaoseNdWsQQ%3D%3D.ru%2FyTbD6S4lDKR35tGSg7Z2lIPONomuHjGnpxCkKOkJ6ePFXRTsYHNW1rRmO1%2BP%2BkW0gCf%2BqZ0RaiTzZpl1MNA%3D%3D" rel="nofollow" title="ubernetes Ingress" target="_blank">ubernetes Ingress</a> 和 <a href="https://link.segmentfault.com/?enc=%2FtzPWScNyxxJgoatCXtrBw%3D%3D.wsx35L1zmhSfHxaZBYne7I8A0nomGmv1TODb3FPPLT2ZstvovcCPjRM8jZy6k0SYrkgyhWbWP4QVMc65wf5FlCptxcjzzhvlXbSXa1VJ4yI%3D" rel="nofollow" title="RouteGroups" target="_blank">RouteGroups</a> 的控制平面和数据平面。创建 <code>Ingress</code> 或 <code>RouteGroup</code> 将会产生<a href="https://link.segmentfault.com/?enc=n8JYKKCMH9byyj3zkmBH9g%3D%3D.T2dy7y2Pg1%2Fad%2FSnPsCIAyAaDEi2d2yCD%2BUuFrULm5uQMRGxGouII11CcuCKREppeS0Mdl4CnRJR5NU5mbS%2BlhfoCbEAhZ0GVrvjPkUHxkF2sBEKB0nP5ocSm6lGEJzG5hxC1V7qnTnteezdM%2BdE%2FKEjg9xmpcecNV4CKlKr1eY%3D" rel="nofollow" title="带有 TLS 终止功能的 AWS LB" target="_blank">带有 TLS 终止功能的 AWS LB</a>，该 LB 会通过 <a href="https://link.segmentfault.com/?enc=fk%2FIOD5mpS65CZMe5E0kKA%3D%3D.yKQl%2BL5oTTIy7mF3alXqlm0avRKROCi%2B7H6EotqMsIo5iM%2FO9IxXATTB34hmSjiQeTTaCdQOdDV18RawAcMcLPtBKZ8KILi78Q1NsLpbea4%3D" rel="nofollow" title="kube-ingress-aws-controller" target="_blank">kube-ingress-aws-controller</a> 与 Skipper 进行通信，同时在 Skipper 上设置 HTTP 路由，并通过 <a href="https://link.segmentfault.com/?enc=ytI3g%2F5sCNIPqDVfENs45A%3D%3D.D5MObgXFUIIXNx9y9B%2Foo4Tqeuve9sV7nWytr86tRgc2R6eCC7YnOVKyCX3AaSOx" rel="nofollow" title="external-dns" target="_blank">external-dns</a> 将 DNS 域名指向该 LB。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400605" alt="" title=""/></p><p>为了理解部署环境，以下是我们的实际运行规模：</p><ul><li>15,000 个 Ingress 和 5,000 个 RouteGroup。</li><li>每秒处理高达 2,000,000 次请求的流量。</li><li>80% - 90% 的流量是经过认证的服务间调用，服务集群每天调用次数在 500,000 到 1,000,000 次。</li><li>共有 200 个 Kubernetes 集群。</li></ul><h2>挑战</h2><h5>扩容的痛点</h5><p>Skipper 实例从 Kubernetes API 获取 Ingress 和 RouteGroups 信息，起初这种方式运行良好。但 Skipper 实例数量迅速增加，达到每个集群约 180 个，开始超出 etcd 基础设施的承载能力。</p><p>这种负载过重导致了严重的 Kubernetes API CPU 限流问题，引发了关键的控制平面稳定性风险。主要表现为两种情况：集群失去了有效调度新 Pod 的能力，而现有 Pod 的管理操作也开始出现故障。这些问题威胁到了 Kubernetes 基础设施的整体稳定性和可靠性。</p><h5>实施路由服务器</h5><p>在引入路由服务器之前，Skipper 的职责包括：</p><ol><li>从 Kubernetes API 获取 Ingress 和 RouteGroups 信息。</li><li>解析并处理这些资源以转换为 <a href="https://link.segmentfault.com/?enc=VV45bAXA3ZETI2X0wZo91g%3D%3D.ihSZ3mriwpH9q1d9wFGkMb3ah9HClE1jPmXb0jop1TQ0Gpqiz9eVy38DaCrI4stKcsRYp9P3I7pL6qWN%2FCrsdN8Yg%2FP9%2F8spjNvJRGSgHrOOZ5lDISmRvUsiqL5kwn0esQ7fmVa7DS3W35sP3FyiWXw30C06b8SN7mScjmSPFKE%3D" rel="nofollow" title="Eskip" target="_blank">Eskip</a> 格式。</li><li>验证生成的 Eskip 格式。</li><li>更新路由表。</li></ol><p>我们引入<a href="https://link.segmentfault.com/?enc=qmCvJi1HUaoNv1EDZCu%2Fkw%3D%3D.Uh046qWLaBMsGeo%2FM1Qm6pGMtWYiIdpd4cvLpeCbXOlS3zSDGV75rmMGBZ6Oztwxt1VTi%2BasARVyTex%2BhgrdYQ%3D%3D" rel="nofollow" title="路由服务器" target="_blank">路由服务器</a>作为自定义代理层，以更高效处理控制平面流量，并在 Skipper 与 Kubernetes API 服务器之间充当带有 <a href="https://link.segmentfault.com/?enc=EMwzq5E8Cm3909m8B%2BL2LA%3D%3D.2%2F7mHDLejhryvnuLw6THSKBBn5PTmaQO8Gw2Q9IMbBsKn9j%2FWOHzSLxXCEFGEtkwv4QQ9j9MFdG8%2FVUcwQDPkg%3D%3D" rel="nofollow" title="HTTP ETag 缓存层" target="_blank">HTTP ETag 缓存层</a>的代理。</p><p>现在，路由服务器负责执行轮询和解析操作，减少了 Skipper 的计算负担，同时实现了清晰的职责划分。</p><h5>缓存层</h5><p>路由服务器每隔 3 秒向 Kubernetes API 发送一次请求，以获取最新的 <code>Ingress</code> 和 <code>RouteGroup</code>。然后生成路由表以及相应的 ETag 值。当 Skipper 向路由服务器请求更新时，会包含自己当前的 ETag。如果这个 ETag 与路由服务器当前的 ETag 相匹配，表示没有变化，路由服务器会以 <a href="https://link.segmentfault.com/?enc=zLhhE2A5wwFZfsCgTw87Xg%3D%3D.YkQ2wR0o6a5B4d%2FY2PfV2TMQvTgT6WgGFAm9v5tYjQ5QnhM4tyU6IIyOq9wqFQK39X%2BC3nKjzh7%2BVKN3QYelCg%3D%3D" rel="nofollow" title="HTTP 304 (Not Modified" target="_blank">HTTP 304 (Not Modified) 状态码</a> 状态码")进行响应。然而，如果 ETag 不同，路由服务器会将更新后的路由表发送给 Skipper，然后 Skipper 会更新其本地配置以及 ETag。</p><h5>路由服务器不可用</h5><p>尽管路由服务器极大提高了系统效率，但也必须考虑到可能出现的故障情况。当路由服务器不可用时，有以下两种可能的情况：</p><ol><li>Skipper 没有初始路由表。</li><li>Skipper 有初始路由表，但路由服务器无法更新。</li></ol><p>在第一种情况下，如果启用了 <a href="https://link.segmentfault.com/?enc=bVYxEh4M9U46pWBzRP0Uuw%3D%3D.NjT%2BmF7yUVGrT4ywH6krmdhwqUCG%2FtikRT%2FaMaL9y%2Bk1JyH41qrC3YKFR%2BegOhDH8FsGCMS%2BEU5PMLcMbtGj1cTS4N%2FJ%2BwTvsdPssCHiaDmpIT%2F5zQP6sHX%2BmJwRA6U1idri8higNQdp%2BLK%2BAOn5CuLHFY2i6hLZfoLsaYP0mJkOIK4BvGMq1wRMNSYyiaJYOsjZkPgDZK%2BaBgud17nyCw%3D%3D" rel="nofollow" title="&lt;code target=" _blank="">-wait-first-route-load 标志"&gt;<code>-wait-first-route-load</code> 标志</a>，那么 Skipper 容器将无法启动。在第二种情况下，Skipper 将继续使用最后已知的路由表。这是在可用性和一致性之间做出的权衡。</p><p>在这两种情况下，我们都会收到告警，并且需要决定是修复路由服务器，还是将其禁用，然后让 Skipper 在没有路由服务器的情况下继续运行。目前，我们还没有自动切回旧方法的机制。</p><p>集成路由服务器后的最终流程如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400606" alt="" title="" loading="lazy"/></p><h2>部署策略</h2><p>部署路由服务器并非易事，哪怕出现一个错误，也可能导致 Kubernetes API 与 Skipper 的连接中断，从而可能影响销售业绩和商品交易总额（GMV）。我们必须极其谨慎，并遵循完善的部署策略。</p><p>我们计划以可控的方式逐步部署路由服务器，先从测试集群开始，生产集群则被分为不同的层级，路由服务器逐层部署，每部署完一层都会进行监控，然后再进行下一层部署。</p><p>为了实现这一目标，我们为部署路由服务器制定了不同的设置模式：</p><ul><li><strong>模式：False</strong> - 禁用模式</li><li><strong>模式：Pre</strong> - 预处理模式</li><li><strong>模式：Exec</strong> - 执行模式</li></ul><p>这些模式通过<a href="https://link.segmentfault.com/?enc=paCjpxgRGogkwuC0jI4E1w%3D%3D.v%2ForDPpT1Aq%2FBZtNmtSdCTCC86eJQLGb1ygEipBkPFnOC5DDkIa%2BONJOPluBEC96T1Ei8Ds2VdwfDhN6DQ%2FzMYOW5ouDXOqyEAgW7VtQrHOikk80EVkNQ1ko%2FgtRYGaZqFlUveZ%2Bx6cuGct4tYcg2l8AQbeLiB9Lo4pIJXCyF%2BRWbRUbcFFxI7FBnzXL7kKk" rel="nofollow" title="配置项" target="_blank">配置项</a>进行控制。</p><p>默认模式为 <code>false</code>，意味着路由服务器已被禁用，此时就用常规的控制平面流量。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400607" alt="" title="" loading="lazy"/></p><h5>预处理模式</h5><p>在该模式下，路由服务器与 Skipper 协同工作，从 Kubernetes API 获取 <code>Ingress</code> 和 <code>RouteGroup</code>，并对其进行预处理。此模式适用于测试和调试，也是我们推出策略的关键因素。</p><p>通过成功获取 Skipper 和路由服务器的路由表，并将其与原表进行对比，以确保路由服务器运行正常。要知道，如果路由表因为某种原因出现故障，就会导致服务中断。这就是为什么必须格外谨慎，检查所有集群中路由表的任何细微差异。</p><pre><code># 用非常大的 limit 获取所有 Skipper 路由
➜ curl -i http://127.0.0.1:9911/routes\?limit\=10000000000000\&amp;nopretty &gt; skipper_routes.eskip
# 获取路由服务器的所有路由，我们决定不使用分页来减少请求数量，Skipper 是目前唯一的消费者
➜ curl -i http://127.0.0.1:9090/routes &gt; routesrv_routes.eskip
➜ git diff --no-index -- skipper_routes.eskip routesrv_routes.eskip</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400608" alt="" title="" loading="lazy"/></p><h5>执行模式</h5><p>在该模式下，路由服务器充当 Skipper 与 Kubernetes API 之间的代理。Skipper 向路由服务器发送请求，然后路由服务器再将这些请求转发至 Kubernetes API。路由服务器会缓存响应并将其返回给 Skipper。此模式是用于生产环境的最终设置。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400609" alt="" title="" loading="lazy"/></p><h2>产品上线</h2><p>经过全面的负载测试后，我们以可控的方式将路由服务器投入生产使用：</p><ol><li>已分发至所有测试集群，并进行了为期两周的监测。</li><li>逐层部署到生产集群，每部署一层都会对其进行监测，然后继续进行下一层部署。</li></ol><h2>替代方案</h2><p>我们曾考虑使用 <a href="https://link.segmentfault.com/?enc=8gqm%2BueKbKMsexwK9RgKWA%3D%3D.o92ZjiC%2FK1wxZPzR9Z9HU0VVyJcxDDfN5AGxCTFdMXP7RYNrZTRbCyCG4MG9PPGg" rel="nofollow" title="Kubernetes Informer" target="_blank">Kubernetes Informer</a> 来监视 Kubernetes API 的变化。然而，这种方法仍需要 Kubernetes API 向所有 Skipper 实例发送信息，可能会导致遇到的同样的问题。因为问题的本质是流量突然增加，而 HPA 无法跟上并扩展 Kubernetes API 和 etcd。</p><h2>未来改进措施</h2><ul><li><strong>自动回退机制</strong>：建立回退机制，以确保在路由服务器不可用的情况下，Skipper 仍能继续运行。</li></ul><h2>总结</h2><ul><li>在上线过程中实现了零停机时间且未出现商品交易总额（GMV）损失的情况。</li><li>将 Skipper HPA 扩展至 300 个 Pod。</li><li>单个路由服务器能够处理高达 100 个每秒请求数（RPS），相当于约 300 个 Skipper Pod，且没有任何问题。</li><li>路由服务器现已成为平台核心组件。</li></ul><hr/><blockquote>你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。为了方便大家以后能第一时间看到文章，请朋友们关注公众号"DeepNoMind"，并设个星标吧，如果能一键三连(转发、点赞、在看)，则能给我带来更多的支持和动力，激励我持续写下去，和大家共同成长进步！</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=jeii%2Fg3WkW2HWvDbUocAkA%3D%3D.7GbvfVKKFf9UgPllj%2Bhd3tkQOkImDtzYx2sl0fST8Ms%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[antd 上传文件组件在表单回显时不显示]]></title>    <link>https://segmentfault.com/a/1190000047400629</link>    <guid>https://segmentfault.com/a/1190000047400629</guid>    <pubDate>2025-11-14 19:02:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>之前需求方提出说想要给表单上传的文件增加预览功能，原来点击展示列表中的文件时，docx文件会启动下载，而pdf会启动新的tab页进入预览，所以最好是统一处理。</p><p>因为我对Upload组件用的不多，对它不够了解，所以一开始我想着从fileList下手，不用Upload默认的展示列表，经过多番尝试发现有点麻烦，于是打开官网文档研究，才发现原来文档里已经提供了相关的功能，原来点击文件的展示列表默认的动作是文档里的<code>onPreview</code>回调，要区分预览和下载的入口，可以增加<code>showDownloadIcon</code>的配置，并增加<code>onDownload</code>的回调用于处理文件的下载，那么预览和下载的处理就可以区分开来。</p><p><img width="723" height="63" referrerpolicy="no-referrer" src="/img/bVdm3dU" alt="" title=""/></p><p>但是问题到这里并没有完全解决，当我重新进入表单页面进入编辑时，也就是表单内容回显时，发现没有出现下载按钮，查了很久的文档都没有找到怎么解决，也在网上搜索了一下，不知道是不是我搜索的关键词不对，就是没找到答案，就只能自己翻项目里的依赖包，各种尝试，才发现原来文件列表中的文件需要同时设置<code>status</code>为<code>'done'</code>，下载的按钮才会显示。</p><p>所以表单内容回显的时候，需要单独给上传的文件列表进行处理，因为我这边接口没有存status的值，又因为文件上传成功后，才会被表单整体提交保存，文件的状态可以默认为done，所以在加载表单内容时，直接给文件列表处理成如下结构就可以。</p><pre><code class="json">[
    { url, name, status: 'done' }
]</code></pre>]]></description></item><item>    <title><![CDATA[uniapp微信小程序分包以及分包优化 ]]></title>    <link>https://segmentfault.com/a/1190000047400647</link>    <guid>https://segmentfault.com/a/1190000047400647</guid>    <pubDate>2025-11-14 19:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>分包限制说明</h2><p>微信小程序上传项目时会有分包大小限制，官方文档介绍：<br/>目前小程序分包大小有以下限制：</p><ul><li>整个小程序所有分包大小不超过 30M（服务商代开发的小程序不超过 20M）</li><li>单个分包/主包大小不能超过 2M</li></ul><p>主包就是<code>Tabbar</code>页面，所有的<code>Tabbar</code>页面加起来的文件大小不能超过<code>2M</code><br/>在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。<br/><img width="534" height="516" referrerpolicy="no-referrer" src="/img/bVdm3ez" alt="" title=""/><br/>你可以在这里查看当前项目的分包大小和依赖分析<br/><img width="723" height="401" referrerpolicy="no-referrer" src="/img/bVdm3eA" alt="" title="" loading="lazy"/></p><h2>uniapp分包</h2><p><code>pages.json</code>文件中</p><ul><li>pages 主包</li><li>subPackages 子包</li></ul><p>在<code>uniapp</code>的<code>pages.json</code>文件中，<code>pages</code>存储的是主包，一般我们的<code>Tabbar</code>页面都会写在<code>pages</code>里<br/>另外，根目录除了你配置的子包，都算在主包内，比如：</p><ul><li>components</li><li>static</li><li>uni_modules</li><li>utils</li><li>...</li></ul><p>所以我们在引入第三方组件、公共方法、静态资源时需要注意主包占用空间<br/>下面是一个分包的示例：<br/><img width="590" height="214" referrerpolicy="no-referrer" src="/img/bVdm3eB" alt="" title="" loading="lazy"/></p><pre><code>{
    "pages": [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages
        {
            "path": "pages/home/index",
            "style": {
                "navigationBarTitleText": "首页",
                "navigationStyle": "custom", // 隐藏系统导航栏
                "navigationBarTextStyle": "white" // 状态栏字体为白色，只能为 white-白色，black-黑色 二选一
            }
        }
    ],
    "subPackages": [
        {
            "root": "subPackages/login", // 子包的根目录
            "pages": [
                {
                    "path": "pages/login/index",
                    "style": {
                        "navigationBarTitleText": "",
                        "navigationStyle": "custom",
                        "navigationBarBackgroundColor": "#ffffff"
                    }
                }
            ]
        },
        {
            "root": "subPackages/setting", // 子包的根目录
            "pages": [
                {
                    "path": "pages/system/index",
                    "style": {
                        "navigationBarTitleText": "设置",
                        "navigationBarTextStyle": "black",
                        "navigationBarBackgroundColor": "#F3F3F3"
                    }
                },
                {
                    "path": "pages/user/index",
                    "style": {
                        "navigationBarTitleText": "用户设置",
                        "navigationBarTextStyle": "black",
                        "navigationBarBackgroundColor": "#F3F3F3"
                    }
                }
            ]
        }
    ]
}</code></pre><p>结构如下：</p><pre><code>Project
├─ subPackages
│  ├─ setting
│  │  └─ pages
│  │     ├─ user
│  │     │  └─ index.vue
│  │     └─ system
│  │        └─ index.vue
│  └─ login
│     └─ pages
│        └─ login
│           └─ index.vue
└─ pages
   └─ home
      └─ index.vue</code></pre><p><code>Project</code>为你的项目文件夹，其中<code>pages</code>为主包，而<code>subPackages</code>为子包<br/><code>subPackages</code>内有两个子包，分别是<code>setting</code>、<code>login</code><br/>按照官方的说法，子包其实可以跟<code>pages</code>同级，你只需要在<code>subPackages</code>配置的<code>root</code>里配置好路径即可，我在这里将所有子包都写在<code>subPackages</code>文件夹内，方便统一管理<br/>之后你正常写页面即可，主包和子包已经分好了，<code>Tabbar</code>的页面就写在<code>pages</code>里，非<code>Tabbar</code>页面就写在<code>subPackages</code>内。</p><p><strong>页面跳转</strong><br/>跳子包</p><pre><code>uni.navigateTo({
  url: '/subPackages/setting/pages/user/index'
});</code></pre><p>跳主包</p><pre><code>uni.navigateTo({
  url: '/pages/home/index'
});</code></pre><p>页面跳转没有什么区别，正常跳就好了</p><h2>分包优化</h2><h3>uniapp配置manifest.json启用分包优化</h3><p><img width="723" height="161" referrerpolicy="no-referrer" src="/img/bVdm3eC" alt="" title="" loading="lazy"/><br/><code>manifest.json</code>内配置</p><pre><code>"mp-weixin": {
 
   "optimization":{"subPackages":true}
 
}</code></pre><h3>分包预加载配置</h3><p>目的：当我们进到某个页面时，有些子包访问概率很大，可以预先加载子包资源，提升进入后续分包页面时的启动速度<br/><code>preloadRule</code>中，<code>key</code>是页面路径，<code>value</code>是进入此页面的预下载配置，每个配置有以下几项：<br/><img width="723" height="112" referrerpolicy="no-referrer" src="/img/bVdm3eD" alt="" title="" loading="lazy"/><br/>假如，你进入登录页后，需要预先加载<code>subPackages/setting</code>子包，配置如下：<br/><strong>pages.json</strong></p><pre><code>    "preloadRule": {
        "subPackages/login/pages/login/index": { // 指定页面
            "network": "all", //指定网络 all 不限网络   wifi：仅wifi
            "packages": ["subPackages/setting"] // 进入指定页面后需要加载的分包 root 或 name
        }
    },</code></pre><p><img width="302" height="71" referrerpolicy="no-referrer" src="/img/bVdm3eE" alt="" title="" loading="lazy"/><br/>当你进入指定页面后，比如登录页，控制台打印<code>preloadSubpackages: success</code>则说明分包预加载成功了。</p><h3>节省uni_modules的体积占用</h3><p>有时候我们在插件市场下载的组件只在某个子包内使用，此时可以直接将<code>uni_modules</code>移到子包内，这样可以减少主包的体积<br/><img width="287" height="141" referrerpolicy="no-referrer" src="/img/bVdm3eG" alt="" title="" loading="lazy"/><br/>像这样，直接移到子包的根目录，你在对应页面使用的时候需要按照路径引入</p><pre><code>&lt;template&gt;
  &lt;view&gt;
    &lt;KevyEmpty/&gt;
  &lt;/view&gt;
&lt;/template&gt;

&lt;script setup&gt;
import KevyEmpty from '@/subPackages/setting/uni_modules/kevy-empty/components/kevy-empty/kevy-empty.vue';
&lt;/script&gt;</code></pre><hr/><p>参考文档：<br/><a href="https://link.segmentfault.com/?enc=3vaha0KcdOvAK%2F5cKPn6TQ%3D%3D.FJYSSFl86VI%2FzrXQUm5UdBsO3avPfQRQCK%2Bjc%2BGJzMDyMN7XYfTx2KO27B3nt08CGNyp3ZDPOZjjTlK%2F5vVpYJ%2BAaK7ErGlC7aY8VZyS%2FKw%3D" rel="nofollow" target="_blank">分包加载</a><br/><a href="https://link.segmentfault.com/?enc=2EqYGFIAHQcgB3AQR155Mg%3D%3D.r2%2BkhYDRnimsrx2jX%2Bb99%2B4doh6xNiK438qWywsYTQdfvdwJ94H92rTqpF59h%2B4lNHTxMHQ1Yad2dytriXzFv5LM5pE9O9SlmH95i8cTILvFZeKgI4dgMMRB0qhjdr8nhATP%2FFCYUNSIWFHUN0bJ98UPe1T0otJHthO7Z84X7gZBdLYPVo5ONEoq2sKfNl7b" rel="nofollow" target="_blank">关于分包优化的说明</a><br/><a href="https://link.segmentfault.com/?enc=eFOLwUfBlWsGZbLNiXxanQ%3D%3D.IvWa08cmFwfvzWsjHveSJSVcwCDNVdKcfCXmZ1%2FfMnfe0qm62rBHRagivF5Xz4SvG3Dofr%2Fv%2F%2B80JVAV9g%2BHkg%3D%3D" rel="nofollow" target="_blank">preloadRule分包预加载</a></p>]]></description></item><item>    <title><![CDATA[每个产品经理都要知道的 6 个软技能 俞]]></title>    <link>https://segmentfault.com/a/1190000047400439</link>    <guid>https://segmentfault.com/a/1190000047400439</guid>    <pubDate>2025-11-14 18:06:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><em>本文总结了产品经理在工作中需要具备的六项最重要的软技能：沟通、非权威型领导力、说服、优先级排序、授权、问题解决能力，并提到了若干其他重要的软技能。原文：<a href="https://link.segmentfault.com/?enc=8w56shYAZY9bJKczOmw0oA%3D%3D.JLbVlmk3knG2nS3EsTS7%2BauAdpX%2FGTPhbqAWi9BmvtauCVZp4kf6R2p5BEsGQAaEJeIvwTH2oNviDICQrVUEe59w90%2BUM6S9Yq1nGGGsmqxCpUJd93qaHQ1iZfvctR32" rel="nofollow" title="6 Soft Skills Every Product Manager Needs" target="_blank">6 Soft Skills Every Product Manager Needs</a></em></blockquote><p>产品经理的最终职责是推出对目标市场真正有用的产品。要实现这一目标，需要多样化的技能组合，将产品经理的软技能和硬技能结合起来。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400441" alt="" title=""/></p><p>你可能存在这样的误解，即认为硬技能比其他任何技能都更为重要。没错，商业知识、数据分析以及其他可学习的技能都是有用的。但是，产品经理所具备的软技能才能帮你发展职业生涯、领导团队，并在组织中获得一定的影响力，从而被视为产品或市场方面的专家。</p><p>如果 PM 想要获得他人的认可和尊重，那么首先就应该在已有的工程和技术技能基础上，提升自身的软技能。</p><h2>为什么软技能在产品管理中如此重要？</h2><p>当你刚开始担任产品经理时，会更多专注于执行与产品相关的任务（基层执行和产品上线），包括完成质量检查、与市场营销部门合作、进行 A/B 测试、收集客户数据、进行市场调研等等。</p><p>当你晋升为高级产品经理或产品负责人时，工作重点将从执行转向影响力方面，会与同事建立更紧密的工作关系。尽管执行仍是职责的一部分，但你正朝着领导角色、团队成员的职业发展以及说服不同团队支持你所做出的决策方面迈出更多步伐。</p><p>当你获得更高职位，并晋升为集团项目经理、产品负责人或首席产品官等领导岗位时，与人建立关系以及与他人合作就变得愈发重要。在领导层中担任 PM 一职的人员，需要能够领导团队、赋予他人权力、做出重要的产品决策，并在整个组织内清晰的进行沟通，这些任务都需要提升软技能。</p><h2>最重要的产品经理软技能</h2><p>我们总结了每位产品经理都应掌握的六项最重要的软技能，这些关键的产品经理软技能将帮助你成为受团队尊重的顶尖领导者：</p><h5>1. 沟通</h5><p>有效沟通是所有优秀产品经理的基石，因为没有沟通就无法完成任何工作。</p><p>一款产品要想从一个想法转变为完整的实现，需要有效沟通作为支撑。作为产品经理，沟通将成为每一天每一刻的工作内容。从与高层管理人员沟通，到与用户沟通，PM 要负责向合适的群体传达正确的信息。</p><p>在向直接或间接参与产品开发过程的其他人交流或传达想法时，沟通也至关重要。例如，PM 需要将工程师提出的复杂想法以用户能够理解并产生共鸣的方式呈现出来，还需要知道如何与利益相关者进行沟通，并清晰的将他们的想法传达给产品团队。</p><p>任何沟通链条的中断都会导致产生出完全不符合预期的产品。而有了有效沟通，PM 就能倾听与他们互动的人员的意见，并以清晰的方式将这些想法传达给其他人。总的来说，PM 是所有人之间的纽带，同时也是信息的传递者。</p><p><strong>如何提升沟通能力</strong></p><p>关于沟通，首先要强调的一点是，必须先倾听。因为人们希望知道自己的话语被听到了，尤其是在产品管理方面。当你有目的、有意识的倾听时，人们就会知道他们的想法正在被考虑，即便你并不能百分百表示赞同。</p><h5>2. 非权威型领导</h5><p>要组建一支高效的团队，产品经理需要在产品线的每个部门赢得尊重和信任。信任和尊重能够帮助 PM 在做出和论证产品决策时发挥其影响力。</p><p>与外界可能的看法相反，PM 的权力其实很小，他们需要充分利用现有资源来开展工作。在产品团队中，没有成员直接向 PM 汇报工作，工程师直接向工程经理汇报，设计师也是如此，直接向设计经理汇报。</p><p>PM 所做的就是不凭借权威来领导，而是凭借影响力来引领。PM 会说服所有人确定最佳决策是什么，并同时提供证据来支持这一决策。如果 PM 无法为某一举措提供证据，就会导致人们对其领导能力和决策的合法性产生怀疑。</p><p>这种领导方式也可以被称为非权威型领导方式，这意味着交流并非是下达命令，而是一种建议。当 PM 们与团队成员进行这种交流，而不是明确指示他们以某种方式行事，通常会带来员工工作效率的大幅提升以及更高的认同感。</p><p>这种生产力的提升源于领导者也是团队的一员。领导意味着合作，意味着要与团队并肩作战，参与到产品开发的每一个环节中。这是你能够了解每个角色的实际情况，并掌握与每个人合作的最佳方式的唯一途径。</p><p><strong>如何在工作中提升影响力？</strong></p><p>首先，必须与组织目标保持一致。一旦 PM 理解了目标的意义所在，那么支持和倡导这个目标就会变得容易得多。高层管理人员也会因此而对你表示赞赏。</p><p>对于你的团队，必须支持他们所做的工作，尤其是在促进他们职业发展方面。当他们就公司内部的运作方式提出意见时，要作为他们的代言人向高层管理人员汇报。</p><h5>3. 说服</h5><p>说服他人就是要寻求双方的共同点，做出妥协，并帮助对方从而让对方也能帮助你。换句话说，就是“我帮你一下，你也得帮我一下”。</p><p>将一款产品推向用户的过程可能会十分漫长，其间会遇到无数阻碍。PM 的软技能中需要包含说服力，以便能够克服或绕过这些障碍。</p><p>说服工作不仅仅意味着与零售商达成一项重大商业交易，让他们销售你的产品。还意味着要敢于面对可能对基层员工要求过高的高层管理人员。这意味着当基层员工不理解时，要为高层管理人员发声，寻找中间立场，成为理性的代表，这应该是任何 PM 的首要任务。</p><p>然而，需要记住的是，掌握这项技能需要一定时间，还需要拥有丰富的经验才能培养出这种能力。不过，任何擅长说服的 PM 都能成功推出出色的产品。</p><p><strong>增强说服力</strong></p><p>关于说服力，最重要的一点在于说话者的可信度。就我个人而言，一旦在团队和组织内部建立起可信度，那么说服他们去做某事就将毫无困难。</p><p>还必须记住的另一个重要方面是“互惠原则”。当队友或组织中的任何成员提供了帮助时，你也必须以某种方式回报这份恩情。如果不是以提供帮助的形式，那么也必须分享你所知晓的机会。</p><h5>4. 优先级</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400442" alt="" title="" loading="lazy"/></p><p>如果 PM 不懂得如何合理安排与项目计划和待办列表相关的事务，那么很快就会发现工作进度停滞不前 —— 而在时间紧迫的情况下，这种情况是绝对不能发生的。</p><p>要使成功推出一款产品，需要完成的任务数量可能极其庞大。在此情况下，产品管理意味着时间管理，即要对任务进行优先级排序，以确保都能按时完成。这不仅需要你按时完成所有任务，还需要工程师和设计师也遵循同样的时间安排来工作。</p><p>你还会发现，各种想法会从各个方向涌来。其中一些想法可能看起来像是某个问题的完美解决方案，或者是某个产品的重要改进之处。但确定优先次序意味着要明白什么样的东西是完美产品所不可或缺的，而不是那些无关紧要的设计元素。</p><p>关于优先级排序，应该了解的最重要一点是，往往意味着需要学会拒绝。可能是拒绝那些与愿景不符的想法，也可能是拒绝自己某些不想做出牺牲的事项。学会说“不”最终会赋予你力量并带来成效。</p><p>采用诸如看板或价值与复杂性四象限（Value vs Complexity Quadrants）等特定的优先级排序框架，有助于 PM 真正优化其时间安排。这些框架设计简单，旨在为每个工作场所带来成功。</p><h5>5. 授权</h5><p>作为 PM，往往会觉得自己需要完成每一项任务。虽然完成工作是你的职责所在，但并非所有任务都得由你独自完成。放弃这种控制权会很困难，尤其是当你肩负着带领团队并交付出色产品的巨大压力时。不过，将任务授权给他人会让团队变得高效且富有成效。</p><p>授权意味着需要了解团队中每个人的优势所在。这样一来，就能确定哪些任务适合哪个团队成员。这会营造出高效的工作环境，让每个人都能发挥自己的最佳水平。没有 PM 能做到面面俱到，但最优秀的 PM 会清楚知道谁最适合完成特定的任务。</p><p>事实上，授权能让领导人的工作变得极其简单。一旦确定了应该把哪些任务分配给哪些人的原则，那么这些任务就会从你的工作清单中移除。这样一来，就减轻了自己的负担，并且知道这项工作正由有能力完成最佳成果的人来负责。而你只需要学会放手。</p><h5>6. 问题解决与创造力</h5><p>问题往往是 PM 日常工作中最为关键的部分。因此，我们将问题解决能力和创造力视为 PM 必备的软技能之一。</p><p>当出现问题时，高层管理人员会期望 PM 去解决这些问题，而那些在 PM 手下工作的人员则会向 PM 寻求答案。并非每一个问题的解决方案都一目了然，要解决出现的所有问题，需要有大量创造力。</p><p>解决问题意味着要从多个不同角度去审视问题。通过综合考虑多种观点，PM 能够从不同角度看到解决某个问题的不同方法。这种共情和换位思考的方式已经解决了许多重大全球性问题，而且肯定也能解决生产中的小问题。</p><h2>其他产品经理应具备的软技能</h2><h5>保持团队热情的能力</h5><p>没错，保持团队积极性也是 PM 的另一项默默的职责。当团队成员积极性高涨时，工作效率也很可能会提高。但是，PM 如何让团队成员保持积极性呢？并不需要是一次性的大型举措，而是在日常的小时刻、一天天的积累中进行。例如，在产品团队内部，可以尝试：</p><ul><li>进行坦诚交流</li><li>为队友设定目标</li><li>认可每位成员的贡献</li><li>成为团队代言人</li><li>促进团队合作</li></ul><h5>同理心</h5><p>同理心指的是理解并分享他人感受的能力。在产品管理领域，这种技能会非常有用，因为同理心能让 PM 更轻松的与他人合作。</p><p>具备同理心能够帮你理解客户、产品团队以及利益相关者。当你理解了产品开发过程中所有参与者的观点时，就能在决策中找到平衡点，并解释为何选择这种平衡方案。</p><p><strong>培养同理心的技巧</strong></p><ul><li>培养好奇心（尤其是对与你共事的人保持好奇心）</li><li>走出舒适区</li><li>以建设性的方式接受反馈</li><li>尝试设身处地为他人着想</li><li>参加公司组织的社区活动</li></ul><h5>主动作为</h5><p>主动作为指的是独立评估并采取行动的能力。PM 一天大部分时间都会被会议占据，可以说，当 PM 主动发起并引导会议（即使是偶然的或未计划的）时，他/她就是在主动作为。</p><p>PM 还需要审查诸如健康指标或竞争对手评估之类的各种报告，一位优秀的 PM 会主动去做这些事情，而且还会做得比这更多，不会因为有人要求才去做。</p><p><strong>作为 PM，为什么要主动作为呢？</strong></p><p>简单来说，主动作为就是让公司看到你的价值所在。当你主动作为时，不仅会完成本职工作，还会承担一些并非作为 PM 所必须承担的任务。这可能看起来像是额外的工作量，但你必须转变思维模式，因为当你主动作为时，就是在为自己创造成长机会。</p><h5>灵活/适应性强</h5><p>许多经验丰富的 PM 都会告诉你，这类工作非常具有动态性。这意味着情况可能会非常多变、出乎意料且节奏很快。即便现在，如果你不能明确认识到 PM 每天其实并没有严格固定的日程安排，而且任何事情都有可能发生，那么可能会发现自己总是处于极度紧张的状态，以至于无法正常完成工作。</p><p>杰出的 PM 懂得如何应对各种情况。他们早已预料到会有意想不到的情况出现，知道如何处理每一个情况，尽管有些情况可能颇具挑战性，但最出色的 PM 总会挺身而出，承担起责任。</p><p><strong>如何提高适应能力和灵活性</strong></p><ol><li>改变思维模式</li></ol><p>当处境发生变化时，必须接受自己也应该随之改变。摒弃那种一味按原计划行事的心态，要学会灵活应对，欣然接受变化。</p><ol start="2"><li>边学边做</li></ol><p>培养自己具备适应能力的一种方法就是不断学习。要乐于学习新技术、从糟糕的状况中汲取教训、关注市场最新趋势等等。</p><ol start="3"><li>鼓励他人保持开放的心态</li></ol><p>作为 PM，还必须帮助他人培养开放的心态和适应能力。在开发产品的过程中，每个人都会需要这种技能，所以不妨鼓励并教导他人如何适应不断变化的环境，尽可能给予支持。</p><h2>总结</h2><p>作为产品经理，依靠硬技能可能是最容易做到的事情。你可以是一位精通产品管理技术细节的产品经理，但实际上，最成功的产品经理会将硬技能与软技能相结合，以构建高效且富有成效的体系。</p><p>当硬技能无法解决某个问题时，软技能就会发挥作用。而且在你从事工作中的不同方面时，这两种技能会协同工作，相辅相成。</p><p>最终，正是技能的综合运用，造就了品质更高的产品，并且拥有更广泛的用户群体。沟通、非权威型领导、谈判、优先级排序、问题解决等等，都将成为 PM 工具包中的完美补充。</p><p>要满怀自信的坚信自己已经具备了所需能力。成为最核心且表现卓越的产品经理这一目标就在眼前，你也清楚自己需要做些什么。走出去，在日常工作中运用这些 PM 所需的软技能，然后会看到一切都会变得越来越好。</p><h2>FAQ</h2><h5>产品经理需要具备哪四项关键技能？</h5><p>产品经理最核心的四项技能是同理心、沟通能力、倾听能力和组织能力。当然，要做好这份工作还需要其他技能，但上述这四项必不可少，是 PM 应具备的最低要求。</p><h5>成为一名产品经理需要具备哪些技能？</h5><p>作为 PM，主要会与人打交道。从这个角度来看，单一技能是不够的。而所具有的人际交往能力的综合表现，才会在与其他团队、客户和利益相关者打交道时发挥作用。</p><h5>作为产品经理，最出色的三项特质是什么？</h5><p>要胜任产品经理这一职位，必须具备战略思维能力，对产品充满热情，并致力于为用户提供卓越的体验。然而，对于每位 PM 而言，所具备的特质可能会有所不同，但这里列出的三项特质是 PM 能够以此为基础发展成为优秀产品管理者的基石。</p><h5>产品经理是否需要具备编程技能？</h5><p>不，编程技能并非 PM 的必备技能，但这种技能肯定会派上用场，尤其是当 PM 负责技术产品，并且需要与工程团队进行有效沟通和协作时。不过，这并非是必须具备的先决条件。</p><h5>产品管理是一种软技能吗？</h5><p>产品管理更像是硬技能和软技能的结合体。比如，具备编写技术规格说明或使用产品管理工具的硬技能，在工作中可能会有用，但这只是其中一方面。PM 还需要处理产品管理中的人性方面的问题。这就是软技能发挥作用的地方，因为参加会议、与不同部门团队沟通以及向客户了解他们的需求都是常态。</p><hr/><blockquote>你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。为了方便大家以后能第一时间看到文章，请朋友们关注公众号"DeepNoMind"，并设个星标吧，如果能一键三连(转发、点赞、在看)，则能给我带来更多的支持和动力，激励我持续写下去，和大家共同成长进步！</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=hTmBjWVTHh%2FH7%2FWN2D38vQ%3D%3D.fUCxMKgLzi45%2FJB2mMZBo9s%2Bw0WhJwxSmjsCAWuKWBU%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[使用 C# 导出 Excel 数据并保存]]></title>    <link>https://segmentfault.com/a/1190000047400472</link>    <guid>https://segmentfault.com/a/1190000047400472</guid>    <pubDate>2025-11-14 18:05:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在现代企业信息化管理中，Excel 已经成为最常用的数据存储和分析工具。从员工信息表、销售数据报表到财务分析表，几乎所有部门都离不开 Excel。然而，在实际业务中，我们往往需要将系统中的数据动态生成 Excel 文件，而不是手动录入。手动操作不仅效率低，而且容易出错，对于需要批量生成报表、进行定期统计或对外发布数据的场景尤其不适用。</p><p>为了解决这一问题，C# 开发者可以借助 <strong><a href="https://link.segmentfault.com/?enc=gZPlS5ikQ%2BFrHUdPRfHE1w%3D%3D.udeoSKuoZOTBTSSvCoMaeh1Lbjq%2Bpp9vX8Wj7W2UClSKfxRWxmZoxuiJc6EpcUKdmN3sJHg1kUgtS1jNaEB%2BTA%3D%3D" rel="nofollow" target="_blank">Free Spire.XLS for .NET</a></strong>，通过代码快速创建 Excel 文件、填充数据、应用样式，并将文件导出为多种格式，包括 XLSX、CSV、PDF，甚至直接保存到内存流以便网络传输。本文将通过一个完整示例，详细演示如何在 C# 中实现 Excel 数据导出，让你的报表生成工作既高效又专业。</p><h2>1. 安装 Spire.XLS</h2><p>在开始编码前，需要通过 NuGet 安装 Spire.XLS：</p><pre><code class="bash">Install-Package FreeSpire.XLS</code></pre><p>安装完成后，即可在 C# 项目中引用命名空间：</p><pre><code class="csharp">using Spire.Xls;
using System.Data;
using System.IO;</code></pre><hr/><h2>2. 创建工作簿和填充数据</h2><p>下面示例演示如何创建一个 Excel 文件，并将员工信息填充到工作表中：</p><pre><code class="csharp">// 创建工作簿
Workbook workbook = new Workbook();
Worksheet sheet = workbook.Worksheets[0];
sheet.Name = "EmployeeData";

// 创建 DataTable 并添加列
DataTable table = new DataTable();
table.Columns.Add("EmployeeID");
table.Columns.Add("FullName");
table.Columns.Add("Department");
table.Columns.Add("HireDate");
table.Columns.Add("Salary");

// 添加示例数据
table.Rows.Add("E101", "John Miller", "Finance", "2020-02-15", "7500");
table.Rows.Add("E102", "Sarah Brown", "HR", "2019-07-10", "6800");
table.Rows.Add("E103", "Michael Davis", "IT", "2021-01-22", "8200");
table.Rows.Add("E104", "Laura Wilson", "Marketing", "2018-11-18", "7100");
table.Rows.Add("E105", "Daniel Lee", "Sales", "2022-06-12", "6900");

// 将 DataTable 插入工作表，从第一行第一列开始，并保留列名
sheet.InsertDataTable(table, true, 1, 1);

// 应用内置样式
sheet.AllocatedRange.Rows[0].BuiltInStyle = BuiltInStyles.Heading2; // 标题行
for (int i = 1; i &lt; sheet.AllocatedRange.Rows.Count(); i++)
{
    sheet.AllocatedRange.Rows[i].BuiltInStyle = BuiltInStyles.Accent2; // 数据行
}

// 自动调整列宽和行高
sheet.AllocatedRange.AutoFitColumns();
sheet.AllocatedRange.AutoFitRows();</code></pre><p><strong>说明</strong>：</p><ul><li><code>InsertDataTable</code> 可以直接将 <code>DataTable</code> 内容写入工作表，同时支持保留列名。</li><li>内置样式（<code>BuiltInStyles</code>）可以快速美化表格，例如标题行加粗、数据行配色。</li><li><code>AutoFitColumns</code> 和 <code>AutoFitRows</code> 可自动调整列宽和行高，使表格美观。</li></ul><hr/><h2>3. 保存为不同格式</h2><p>Spire.XLS 支持多种保存格式，常见的包括：</p><ul><li><strong>XLS/XLSX</strong>：传统 Excel 文件</li><li><strong>CSV</strong>：逗号分隔文本文件</li><li><strong>PDF</strong>：用于打印或发布</li><li><strong>HTML</strong> / <strong>SVG</strong>：网页或矢量图格式</li><li><strong>XLSB/XLSM</strong>：二进制或带宏 Excel 文件</li><li><strong>MemoryStream</strong>：将文件写入内存流，用于网络传输或其他二次处理</li></ul><p>示例代码：</p><pre><code class="csharp">// 保存为 Excel 2016 格式
workbook.SaveToFile("EmployeeData.xlsx", FileFormat.Version2016);

// 保存为 CSV
workbook.SaveToFile("EmployeeData.csv", FileFormat.CSV);

// 保存为 PDF
workbook.SaveToFile("EmployeeData.pdf", FileFormat.PDF);

// 保存到 MemoryStream
using (MemoryStream ms = new MemoryStream())
{
    workbook.SaveToStream(ms, FileFormat.Version2016);
    // 这里可以将 ms 写入数据库、发送 HTTP 响应等
}</code></pre><p><strong>说明</strong>：</p><ul><li><code>FileFormat</code> 枚举支持多达 25 种格式，例如 <code>Xlsb2007</code>、<code>ODS</code>、<code>HTML</code>、<code>Markdown</code> 等。</li><li>MemoryStream 保存方式适合 Web 应用场景，可以直接将文件返回给客户端而不写入磁盘。</li></ul><hr/><h2>4. 效果展示</h2><p>生成的 Excel 文件：</p><p><img width="693" height="275" referrerpolicy="no-referrer" src="/img/bVdm3bT" alt="C#保存Excel" title="C#保存Excel"/></p><p>表头加粗，数据行有配色，并且列宽自适应。</p><hr/><h2>5. 扩展说明</h2><ol><li><strong>为什么要使用代码导出？</strong><br/>对于批量生成报表或动态数据，手动操作效率低且易出错，使用代码生成可以自动化、可复用。</li><li><p><strong>MemoryStream 场景</strong></p><ul><li>Web API 返回文件下载</li><li>将 Excel 存入数据库或云存储</li><li>在内存中生成并进一步处理，例如加密或压缩</li></ul></li><li><strong>多格式支持</strong><br/>Spire.XLS 的 <code>FileFormat</code> 枚举几乎覆盖了主流的 Excel、PDF、网页、模板等格式，可以满足多种业务需求。</li></ol><hr/><h2>6. 总结</h2><p>本文演示了如何使用 <strong>Spire.XLS for .NET</strong>：</p><ul><li>在 C# 中创建 Excel 文件并填充数据</li><li>应用内置样式和自动调整行列</li><li>将文件保存为多种格式（XLSX、CSV、PDF、HTML 等）</li><li>使用 MemoryStream 保存用于网络传输或二次处理</li></ul><p>通过掌握 <code>Workbook</code>、<code>Worksheet</code>、<code>InsertDataTable</code> 和 <code>SaveToFile/SaveToStream</code>，你可以轻松实现 Excel 数据导出和格式转换，提升企业应用开发效率。</p>]]></description></item><item>    <title><![CDATA[Rust性能调优：从劝退到真香 烦恼的沙]]></title>    <link>https://segmentfault.com/a/1190000047400483</link>    <guid>https://segmentfault.com/a/1190000047400483</guid>    <pubDate>2025-11-14 18:05:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>地球人都说Rust快，安全，并发牛。但有时候我们写出来的代码，跑起来却像踩了脚刹车。这是为啥？其实，Rust给你的法拉利，你可能只当成了买菜车在开。性能这玩意儿，不是玄学，而是科学（和一点点小技巧）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400485" alt="" title=""/></p><p>BUT，在开始之前，谁也不想在配置环境这种破事上浪费生命，对吧？装Rust、装PostgreSQL、装Redis……一套下来，半天没了。这里就要用 ServBay，这是开发者的福音，一键就能把<a href="https://link.segmentfault.com/?enc=fibNiS76DfbCiDMY1AUx%2BA%3D%3D.OYRbqk91llhZM5tXpBJwQgmnA9nV7gF4sbJGWaO64K1QzOOAw0if8wtwQvOQjqeF" rel="nofollow" target="_blank">Rust开发环境</a>给搞定了，连带各种数据库都安排得明明白白。哥哥你放心飞，ServBay永相随。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400486" alt="" title="" loading="lazy"/></p><p>好了，环境搞定，系好安全带，我们发车！</p><h4><strong>技巧一：函数参数别老用</strong><code>String</code>，<code>&amp;str</code><strong>才是万金油</strong></h4><p>这可能是新手最容易犯的错误。看到字符串，下意识就用<code>String</code>。</p><p><strong>别这么干：</strong></p><pre><code class="rust">// 每次调用这个函数，都可能发生一次内存拷贝，把所有权交出去
fn welcome_user(name: String) {
    println!("Hello, {}! 欢迎来到Rust的世界！", name);
}

fn main() {
    let user_name = "CodeWizard".to_string();
    // 为了不失去 user_name 的所有权，你不得不克隆它
    welcome_user(user_name.clone()); 
    println!("你的用户名是: {}", user_name); // 如果不clone，这里就编译不过了
}</code></pre><p><strong>试试这个：</strong></p><pre><code class="rust">// 使用 &amp;str，我们只是借用了数据，不涉及所有权转移
fn welcome_user(name: &amp;str) {
    println!("Hello, {}! 欢迎来到Rust的世界！", name);
}

fn main() {
    let user_name = "CodeWizard".to_string();
    welcome_user(&amp;user_name); // 轻松借用
    welcome_user("Newbie"); // 字符串字面量也完全没问题
    println!("你的用户名是: {}", user_name); // user_name 还在，啥事没有
}</code></pre><p><strong>为啥呢？</strong> <code>String</code>是动态的、拥有所有权的字符串，把它作为参数传递，要么所有权被移走（原来的变量不能再用），要么你就得<code>clone()</code>一份，这可是实打实的内存分配和拷贝，开销不小。而<code>&amp;str</code>（字符串切片）只是一个“引用”，一个指向数据某部分的“指针+长度”组合，传递它就跟递张名片一样轻巧，不产生任何数据拷贝。</p><h4><strong>技巧二：数据共享？别傻傻地</strong><code>clone()</code>，请用<strong><code>Arc</code></strong></h4><p>当多个线程或多个数据结构需要访问同一份大数据时，比如一个共享的配置信息，无脑<code>clone()</code>会付出沉重的代价。</p><p><strong>别这么干：</strong></p><pre><code class="rust">use std::thread;

#[derive(Clone)] // 为了能在线程间传递，不得不加上Clone
struct AppConfig {
    api_key: String,
    timeout: u32,
}

fn main() {
    let config = AppConfig {
        api_key: "a_very_long_and_secret_api_key".to_string(),
        timeout: 5000,
    };

    let mut handles = vec![];
    for i in 0..5 {
        let thread_config = config.clone(); // 每次都深度拷贝整个结构体
        handles.push(thread::spawn(move || {
            println!("线程 {} 使用的 API Key 是: {}", i, thread_config.api_key);
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}</code></pre><p><strong>试试这个：</strong></p><pre><code class="rust">use std::sync::Arc;
use std::thread;

struct AppConfig {
    api_key: String,
    timeout: u32,
}

fn main() {
    // Arc是“原子引用计数”智能指针，可以安全地在线程间共享数据
    let config = Arc::new(AppConfig {
        api_key: "a_very_long_and_secret_api_key".to_string(),
        timeout: 5000,
    });

    let mut handles = vec![];
    for i in 0..5 {
        let thread_config = Arc::clone(&amp;config); // 这不是数据拷贝！只是增加引用计数，非常快
        handles.push(thread::spawn(move || {
            println!("线程 {} 使用的 API Key 是: {}", i, thread_config.api_key);
        }));
    }

    for handle in handles {
        handle.join().unwrap();
    }
}</code></pre><p><strong>为啥呢？</strong> <code>Arc::clone()</code>做的不是复制数据本体，它只是把一个记录“有多少人正在引用这份数据”的计数器加一。这个操作非常轻量，几乎没有成本。只有当最后一个引用消失时，数据才会被真正清理。面对多线程共享只读数据的场景，<code>Arc</code>就是不二之选。</p><h4><strong>技巧三：</strong> <strong>迭代器</strong> <strong>大法好，告别C风格的索引循环</strong></h4><p>还在用<code>for i in 0..vec.len()</code>？那可就错过了Rust编译器给准备的免费午餐。</p><p><strong>别这么干：</strong></p><pre><code class="rust">fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6];
    let mut sum_of_squares = 0;
    for i in 0..numbers.len() {
        // 每次访问 numbers[i]，编译器都会插入一个边界检查，以防你越界
        if numbers[i] % 2 == 0 {
            sum_of_squares += numbers[i] * numbers[i];
        }
    }
    println!("偶数的平方和是: {}", sum_of_squares);
}</code></pre><p><strong>试试这个：</strong></p><pre><code class="rust">fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6];
    // 迭代器是惰性的，并且链式调用会被编译器优化成一个高效的循环
    let sum_of_squares: i32 = numbers
        .iter()                // 创建一个迭代器
        .filter(|&amp;&amp;n| n % 2 == 0) // 筛选出偶数
        .map(|&amp;n| n * n)       // 计算平方
        .sum();                // 求和

    println!("偶数的平方和是: {}", sum_of_squares);
}</code></pre><p><strong>为啥呢？</strong> Rust的迭代器是零成本抽象。写的链式调用，在编译后会被融合成一个手写的、极其高效的循环，而且编译器在编译时就能确定访问不会越界，从而去掉了运行时的边界检查。既安全，又高效，代码还更清晰，何乐而不为？</p><h4><strong>技巧四：</strong> <strong>泛型</strong> <strong>优于动态分发（</strong> <code>Box&lt;dyn Trait&gt;</code> <strong>）</strong></h4><p>当代码需要处理多种不同类型，但它们都实现了同一个<code>Trait</code>时，这时候会有两种选择：静态分发（泛型）和动态分发（Trait对象）。在性能敏感的路径上，请选择前者。</p><p><strong>别这么干（动态分发）：</strong></p><pre><code class="rust">trait Sound {
    fn make_sound(&amp;self) -&gt; String;
}

struct Dog;
impl Sound for Dog {
    fn make_sound(&amp;self) -&gt; String { "汪汪!".to_string() }
}

struct Cat;
impl Sound for Cat {
    fn make_sound(&amp;self) -&gt; String { "喵~".to_string() }
}

// 使用Box&lt;dyn Trait&gt;，运行时需要通过虚函数表(vtable)查找具体调用哪个方法
fn trigger_sound(animal: Box&lt;dyn Sound&gt;) {
    println!("{}", animal.make_sound());
}

fn main() {
    trigger_sound(Box::new(Dog));
    trigger_sound(Box::new(Cat));
}</code></pre><p><strong>试试这个（静态分发）：</strong></p><pre><code class="rust">trait Sound {
    fn make_sound(&amp;self) -&gt; String;
}

struct Dog;
impl Sound for Dog {
    fn make_sound(&amp;self) -&gt; String { "汪汪!".to_string() }
}

struct Cat;
impl Sound for Cat {
    fn make_sound(&amp;self) -&gt; String { "喵~".to_string() }
}

// 使用泛型，编译器会为每种类型生成一个专门的版本，没有运行时开销
fn trigger_sound&lt;T: Sound&gt;(animal: T) {
    println!("{}", animal.make_sound());
}

fn main() {
    trigger_sound(Dog);
    trigger_sound(Cat);
}</code></pre><p><strong>为啥呢？</strong> 动态分发<code>Box&lt;dyn Trait&gt;</code>需要在运行时查找一个叫做“虚表”的东西来确定到底该调用哪个具体实现的方法，这会带来额外的指针间接引用和查找开销。而泛型，编译器在编译时就知道要用<code>Dog</code>还是<code>Cat</code>，它会直接生成两个不同版本的<code>trigger_sound</code>函数，一个给<code>Dog</code>，一个给<code>Cat</code>，调用时直接就是函数地址，没有任何运行时开销。这种技术也叫单态化。</p><h4><strong>技巧五：给小函数戴上</strong><code>#[inline]</code><strong>的帽子</strong></h4><p>对于那些又小又被频繁调用的函数，函数调用本身的开销（比如建立栈帧）可能比函数体执行的开销还大。</p><pre><code class="rust">// 这是一个非常小的辅助函数
#[inline]
fn is_positive(n: i32) -&gt; bool {
    n &gt; 0
}

fn count_positives(numbers: &amp;[i32]) -&gt; usize {
    numbers.iter().filter(|&amp;&amp;n| is_positive(n)).count()
}

fn main() {
    let data = vec![-1, 1, -2, 2, 3];
    println!("正数的个数: {}", count_positives(&amp;data));
}</code></pre><p><strong>为啥呢？</strong> <code>#[inline]</code>像是一个给编译器的建议，告诉它：“哥们，把这个函数的代码直接复制粘贴到调用它的地方吧，别走函数调用流程了。” 这样就消除了函数调用的开销。当然，别滥用，给一个巨大的函数加上<code>#[inline]</code>只会让最终程序体积膨胀，得不偿失。</p><h4><strong>技巧六：栈上分配永远比堆上快</strong></h4><p>能放在栈上的数据，就别往堆上扔。栈分配就是移动一下栈指针，快如闪电；堆分配则需要去仓库（堆）里找一块合适的空地，要慢得多。</p><p><strong>别这么干：</strong></p><pre><code class="rust">struct Point {
    x: f64,
    y: f64,
}

fn main() {
    // Box::new会把数据分配在堆上
    let p1 = Box::new(Point { x: 1.0, y: 2.0 });
    println!("堆上的点: ({}, {})", p1.x, p1.y);
}</code></pre><p><strong>试试这个：</strong></p><pre><code class="rust">struct Point {
    x: f64,
    y: f64,
}

fn main() {
    // 默认情况下，变量是分配在栈上的
    let p1 = Point { x: 1.0, y: 2.0 };
    println!("栈上的点: ({}, {})", p1.x, p1.y);
}</code></pre><p>这个技巧看起来非常简单，但其核心是当不需要在函数返回后数据仍然存活，或者数据大小在编译期就确定时，优先使用栈。<code>Box</code>、<code>String</code>、<code>Vec</code>这类都是在堆上分配的，使用时要心里有数。</p><h4><strong>技巧七：</strong> <code>MaybeUninit</code> <strong>：大</strong> <strong>内存</strong> <strong>初始化时开挂了</strong></h4><p>如果需要一块非常大的内存，并且确定马上会用自己的数据把它填满时，让Rust先用0初始化一遍的话，纯属浪费CPU。</p><p>这是一个高级技巧，需要使用<code>unsafe</code>，新手慎用！</p><pre><code class="rust">use std::mem::MaybeUninit;

const BUFFER_SIZE: usize = 1024 * 1024; // 1MB

fn main() {
    // 创建一个Vec，但告诉Rust：“先别初始化这块内存，我待会儿自己弄”
    let mut buffer: Vec&lt;MaybeUninit&lt;u8&gt;&gt; = Vec::with_capacity(BUFFER_SIZE);

    // 假设我们从某个地方读取数据填满了这块缓冲区
    // 这里我们用一个简单的循环模拟
    // 注意：在真实场景中，你会用类似 read_exact 的方法填充
    unsafe {
        // 伪装成已经初始化了，因为我们确信下面的代码会完成初始化
        buffer.set_len(BUFFER_SIZE); 
        for i in 0..BUFFER_SIZE {
            // get_mut_unchecked是`unsafe`的，但我们知道索引是合法的
            *buffer.get_mut_unchecked(i) = MaybeUninit::new((i % 256) as u8);
        }
    }

    // 现在，我们确信内存已经完全初始化，可以安全地把它转换成 Vec&lt;u8&gt;
    let buffer: Vec&lt;u8&gt; = unsafe {
        // 这步转换是零成本的，因为内存布局完全一样
        std::mem::transmute(buffer)
    };

    println!("缓冲区创建并填充完毕，第一个元素是: {}", buffer[0]);
    println!("最后一个元素是: {}", buffer[BUFFER_SIZE - 1]);
}</code></pre><p><strong>为啥呢？</strong> <code>Vec::with_capacity</code>只分配内存，不初始化。但如果你接着用<code>resize</code>或者其他安全的方法，它还是会帮你初始化。<code>MaybeUninit</code>允许你跳过这个默认的初始化步骤，直接操作未初始化的内存，对于高性能网络编程、数据解析等场景，能省下可观的时间。但记住，<code>unsafe</code>意味着你得自己对内存安全负责！</p><h3><strong>总结一下</strong></h3><p>Rust性能调优的核心思想无非几点：</p><ul><li><strong>减少</strong> <strong>内存</strong> <strong>分配和拷贝</strong>：多用借用（<code>&amp;</code>），善用智能指针（<code>Arc</code>）。</li><li><strong>让编译器帮你干活</strong>：多用迭代器，多用泛型。</li><li><strong>理解</strong> <strong>内存</strong> <strong>布局</strong>：区分栈和堆，知道什么时候该用谁。</li></ul><p>当然，优化要讲究章法，不要上来就对着贴脸代码开大。先用性能分析工具（比如<code>cargo-flamegraph</code>）找到问题在哪，再对症下药。</p><p>最后，别忘了，一个顺手的开发环境是高效工作的开始。ServBay 搞定繁琐的配置，开发者就能把全部精力投入到编写优雅且高性能的Rust代码中。现在，去把你的买菜车调教成一辆真正的法拉利吧！</p>]]></description></item><item>    <title><![CDATA[Databend SQL 存储过程使用指]]></title>    <link>https://segmentfault.com/a/1190000047400488</link>    <guid>https://segmentfault.com/a/1190000047400488</guid>    <pubDate>2025-11-14 18:04:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、什么是存储过程？</h2><p>存储过程（Stored Procedure）是一组预编译的 SQL 语句集合，它们被保存在数据库中，可以像函数一样被重复调用。想象一下，如果你经常需要执行一系列复杂的数据处理操作，与其每次都手动输入这些 SQL 语句，不如将它们封装成一个存储过程，需要时直接调用即可。</p><h3>存储过程的优势</h3><ol><li><strong>代码复用</strong>：一次编写，多次调用，避免重复代码</li><li><strong>性能优化</strong>：预编译的 SQL 语句执行效率更高</li><li><strong>业务逻辑封装</strong>：将复杂的业务逻辑封装在数据库层</li><li><strong>维护便利</strong>：统一管理和修改业务逻辑</li><li><strong>安全性</strong>：通过权限控制，限制用户对底层数据的直接访问</li></ol><h2>二、第一个存储过程：Hello World</h2><p>让我们从最简单的例子开始。假设我们需要一个简单的加法存储过程：</p><pre><code>CREATE PROCEDURE my_add(a Int32, b Int32)
RETURNS Int32
LANGUAGE SQL
AS $$
BEGIN
    RETURN a + b;
END;
$$;</code></pre><h3>语法解析</h3><p>让我们逐行理解这个存储过程：</p><ul><li><code>CREATE PROCEDURE my_add</code>：创建一个名为 <code>my_add</code> 的存储过程</li><li><code>(a Int32, b Int32)</code>：定义输入参数 <code>a</code> 和 <code>b</code>，类型为 Int32</li><li><code>RETURNS Int32</code>：指定返回值类型为 Int32</li><li><code>LANGUAGE SQL</code>：指定使用 SQL 语言编写（目前 Databend 仅支持 SQL）</li><li><code>AS $$ ... $$</code>：使用美元符号包裹存储过程的主体代码</li><li><code>BEGIN ... END</code>：存储过程主体的开始和结束标记</li><li><code>RETURN a + b</code>：执行计算并返回结果</li></ul><h3>调用存储过程</h3><p>创建后，我们可以这样调用它, 注意参数类型需要显式指定：</p><pre><code>call PROCEDURE my_add(3::Int,4::Int);
----
7</code></pre><h3>SqlScript</h3><p>存储过程中的语法我们称之为 SqlScript， 我们也可以直接使用 <code>execute immediate</code> 来执行 SqlScript 语句。</p><ul><li>执行单个 SQL</li></ul><pre><code>execute immediate 'CREATE TABLE test (id Int32)';</code></pre><ul><li>执行多个 SQL, 用 begin 和 end 包裹</li></ul><pre><code>execute immediate $$
BEGIN
    select 33;
    let s RESULTSET := select number from numbers(100);
    RETURN TABLE(s);
END;
$$;</code></pre><h2>三、进阶：使用变量和流程控制</h2><p>现在让我们学习如何在 SqlScript 中使用变量、条件判断和循环。</p><h3>3.1 变量声明和使用</h3><h4>Scalar 变量</h4><p>在 Databend 中，使用 <code>LET</code> 关键字声明变量：</p><p>语法有：</p><ol><li><code>LET &lt;variable_name&gt; := &lt;value&gt;</code> -- 声明并初始化变量 x</li><li><code>LET &lt;variable_name&gt; [&lt;type&gt;] := &lt;value&gt;</code> -- 声明并初始化变量 x</li><li><code>LET &lt;variable_name&gt; [&lt;type&gt;] DEFAULT &lt;value&gt;</code> -- 声明并初始化变量 x</li><li><code>LET &lt;variable_name&gt; [&lt;type&gt;]</code> -- 声明变量 x, 后续初始化</li></ol><pre><code>execute immediate $$
BEGIN
    LET sum := 0;  -- 声明并初始化变量 sum

    FOR i IN 1 TO 10 DO
        IF i % 2 = 0 THEN
            sum := sum + i;  -- 累加偶数
        END IF;
    END FOR;

    RETURN sum;
END;
$$;</code></pre><p>在这个例子中：</p><ul><li><code>LET sum := 0</code>：声明一个名为 <code>sum</code> 的变量并初始化为 0</li><li><code>:=</code>：赋值操作符</li><li><code>RETURNS UInt8 NOT NULL</code>：指定返回值不能为 NULL</li></ul><h4>ResultSet 变量</h4><p>ResultSet 变量用于存储查询结果集，语法有：</p><p>示例语法：</p><pre><code>execute immediate $$
BEGIN
    LET x RESULTSET := select number from numbers(10);
    RETURN TABLE(x);
END;
$$;</code></pre><p>上面是返回结果集，所以使用 <code>RETURN TABLE(x)</code> 语句</p><h4>Cursor 变量</h4><p>Cursor 变量用于遍历结果集，语法有：</p><ol><li><code>LET &lt;cursor_variable&gt; CURSOR for &lt;query&gt;</code></li><li><code>LET &lt;cursor_variable&gt; CURSOR for &lt;result_set_variable&gt;</code></li><li><code>OPEN &lt;cursor_variable&gt;</code></li><li><code>FETCH &lt;cursor_variable&gt; INTO &lt;variable&gt;</code></li><li><code>CLOSE &lt;cursor_variable&gt;</code></li><li><code>for &lt;variable&gt; in &lt;cursor_variable&gt; do ... end for</code></li></ol><p>示例语法：</p><pre><code>execute immediate $$
BEGIN
    LET v Int;
    LET c CURSOR for select max(number) from numbers(10);
    OPEN c;
    FETCH c INTO v;
    CLOSE c;

    let d RESULTSET := select number from numbers(10);
    let e CURSOR for d;
    for v2 in e do
        v := v + v2.number;
    end for;

    return v;
END;
$$;</code></pre><h3>3.2 条件判断：IF-THEN-ELSEIF-ELSE</h3><p>IF 语句允许我们根据条件执行不同的代码分支：</p><pre><code>execute immediate $$
BEGIN
    LET score := 57 + 10 + 10 + 10;
    LET grade := '';

    IF score &gt;= 90 THEN
        grade := '优秀';
    ELSEIF score &gt;= 80 THEN
        grade := '良好';
    ELSEIF score &gt;= 70 THEN
        grade := '中等';
    ELSEIF score &gt;= 60 THEN
        grade := '及格';
    ELSE
        grade := '不及格';
    END IF;
    RETURN grade;
END;
$$;</code></pre><h3>3.3 循环：FOR 循环</h3><p>FOR 循环有两种常见形式：</p><h4>形式一：范围循环</h4><pre><code>FOR i IN start_value TO end_value DO
    -- 循环体
END FOR;</code></pre><p>示例：</p><pre><code>execute immediate $$
BEGIN
    LET sum := 0;
    FOR i IN 1 TO 10 DO
        sum := sum + i;
    END FOR;
    RETURN sum;
END;
$$;</code></pre><h4>形式二：结果集循环</h4><p>示例：</p><pre><code>execute immediate $$
BEGIN
    -- 声明一个结果集变量
    LET x RESULTSET := SELECT number n FROM numbers(10);
    LET sum := 0;

    -- 遍历结果集
    FOR r IN x DO
        -- 使用 r.n 访问列值
        sum := sum + r.n;
    END FOR;
    RETURN sum;
END;
$$;</code></pre><h2>四、高级应用：嵌套循环与复杂逻辑</h2><p>让我们看一个更复杂的例子，展示嵌套循环和多层逻辑：</p><pre><code>execute immediate $$
BEGIN
    -- 声明结果集变量：从 0 到 9 的数字
    LET x RESULTSET := SELECT number n FROM numbers(10);
    LET sum := 0;

    -- 外层循环：遍历结果集
    FOR x IN x DO
        -- 内层循环：从 0 到当前数字
        FOR batch IN 0 TO x.n DO
            IF batch % 2 = 0 THEN
                sum := sum + batch;  -- 偶数加
            ELSE
                sum := sum - batch;  -- 奇数减
            END IF;
        END FOR;
    END FOR;

    RETURN sum;
END;
$$;</code></pre><h3>逻辑分析</h3><p>让我们分析一下这个过程的执行流程：</p><ol><li><strong>外层循环</strong>：遍历 0-9 这 10 个数字</li><li><strong>内层循环</strong>：对于每个数字 n，从 0 循环到 n</li><li><strong>条件判断</strong>：如果是偶数则加，奇数则减</li></ol><p>例如当 x.n = 3 时：</p><ul><li>batch = 0（偶）：sum += 0</li><li>batch = 1（奇）：sum -= 1</li><li>batch = 2（偶）：sum += 2</li><li>batch = 3（奇）：sum -= 3</li></ul><h3>动态拼接语句，嵌套执行</h3><pre><code>execute immediate $$
BEGIN
   LET tbl_name := 'abcd1' ;
   LET drop_sql := 'DROP TABLE default."' || tbl_name || '"' ;
   EXECUTE IMMEDIATE :drop_sql ;
END ;
$$ ; </code></pre><h2><em>五、返回表格数据</em></h2><p>除了返回单个值，存储过程还可以返回整张表：</p><pre><code>execute immediate $$
BEGIN
    RETURN TABLE(
        SELECT
            number % 3 d,
            SUM(number) AS total_amount
        FROM numbers(10)
        GROUP BY d
    ) ;
END ;
$$ ; </code></pre><h2><em>六、存储过程管理</em></h2><table><thead><tr><th>操作</th><th>SQL</th><th>说明</th></tr></thead><tbody><tr><td>查看所有存储过程</td><td><code>SHOW PROCEDURES;</code></td><td> </td></tr><tr><td>查看存储过程详情</td><td><code>DESC PROCEDURE sum_even_numbers(UInt8, UInt8);</code><br/>或<br/><code>DESCRIBE PROCEDURE sum_even_numbers(UInt8, UInt8);</code></td><td><strong>注意：</strong><br/>• 无参数的存储过程使用空括号：<code>DESC PROCEDURE proc_name()</code><br/>• 有参数的必须指定确切的参数类型</td></tr><tr><td>删除存储过程</td><td><code>DROP PROCEDURE my_add(int, int);</code></td><td> </td></tr><tr><td>替换存储过程</td><td><code>CREATE OR REPLACE PROCEDURE my_add(a Int32, b Int32)</code><br/><code>RETURNS Int32</code><br/><code>LANGUAGE SQL</code><br/><code>AS $$`&lt;br&gt;`BEGIN`&lt;br&gt;`    RETURN a + b + 3;`&lt;br&gt;`END;`&lt;br&gt;`$$;</code></td></tr></tbody></table><h2><em>七、</em> <em>最佳实践</em></h2><h3><em>7.1 命名规范</em></h3><ul><li>使用有意义的名称，清晰表达功能</li><li>使用下划线分隔单词（snake_case）</li><li>添加前缀区分不同类型的过程（如 <code>calc_</code>, <code>get_</code>, <code>update_</code>）</li></ul><pre><code>-- 好的命名
CREATE PROCEDURE calc_monthly_revenue(...)
CREATE PROCEDURE get_active_users(...)
CREATE PROCEDURE update_user_status(...)

-- 不好的命名
CREATE PROCEDURE proc1(...)
CREATE PROCEDURE x(...)</code></pre><h3><em>7.2 注释说明</em></h3><p>始终为存储过程添加清晰的注释：</p><pre><code>CREATE PROCEDURE process_orders(order_date DATE)
RETURNS INT
LANGUAGE SQL
COMMENT = '处理指定日期的订单，返回处理数量'
AS $$ ... $$ ; </code></pre><h3><em>7.3 性能考虑</em></h3><ol><li><strong>避免过度循环</strong>：对于大数据集，尽量使用集合操作而非逐行循环</li><li><strong>合理使用索引</strong>：在存储过程中查询的表应有适当的索引</li><li><strong>批量操作</strong>：尽可能使用批量插入/更新而非逐条处理</li><li><strong>结果集大小</strong>：返回表格时，使用 LIMIT 限制结果集大小</li></ol><h2><em>八、实战案例：数据清洗流程</em></h2><p>让我们用二个实际案例来综合运用所学知识：</p><h3><em>9.1 清理和归档不活跃用户数据</em></h3><pre><code>CREATE OR REPLACE PROCEDURE cleanup_user_data(days_threshold INT)
RETURNS TABLE(
    action VARCHAR,
    user_count INT,
    processed_at TIMESTAMP
)
LANGUAGE SQL
COMMENT = '清理和归档不活跃用户数据'
AS $$
BEGIN
    LET cutoff_date := DATE_SUB(DAY, days_threshold,today()) ;
    LET inactive_users := 0 ;
    LET deleted_users := 0 ;

    -- 统计不活跃用户
    LET inactive_resultset RESULTSET :=
        SELECT COUNT(*) AS cnt
        FROM users
        WHERE last_login_date &lt; cutoff_date
        AND status = 'active' ;

    FOR r IN inactive_resultset DO
        inactive_users := r.cnt ;
    END FOR ;

    -- 标记不活跃用户
    UPDATE users
    SET status = 'inactive'
    WHERE last_login_date &lt; cutoff_date
    AND status = 'active' ;

    -- 删除长期不活跃用户
    DELETE FROM users
    WHERE last_login_date &lt; DATE_SUB(cutoff_date, INTERVAL days_threshold DAY)
    AND status = 'inactive' ;

    -- 返回处理结果
    RETURN TABLE(
        SELECT
            'Marked Inactive' AS action,
            inactive_users AS user_count,
            CURRENT_TIMESTAMP() AS processed_at
        UNION ALL
        SELECT
            'Deleted' AS action,
            deleted_users AS user_count,
            CURRENT_TIMESTAMP() AS processed_at
    ) ;
END ;
$$ ; </code></pre><p>调用方式：</p><pre><code>-- 清理 90 天未登录的用户
CALL PROCEDURE cleanup_user_data(90::Int) ; </code></pre><h3><em>9.2 扫描表并合并数据到target表</em></h3><pre><code>CREATE OR REPLACE PROCEDURE PROC_MERGE_GPS()
RETURNS STRING
LANGUAGE SQL
AS
$$
BEGIN
    create or replace table default.gps as select number from numbers(100) ;
    create or replace table default.abcd1 as select number from numbers(100) ;
    create or replace table default.abcd2 as select number from numbers(100) ;
    create or replace table default.abcd3 as select number from numbers(100) ;

    -- Step 1: 查询符合条件的表名（使用 INFORMATION_SCHEMA）
    LET records RESULTSET := (
        select name  from system.tables where database = 'default' and name like '%abcd%'
    ) ;
    LET table_count := 0 ;
    LET record_count := 0 ;
    LET table_names := [] ;
    LET union_parts := [] ;
    for table_record in records DO
        LET name := table_record.name ;
        table_count := table_count + 1 ;
        table_names := ARRAY_APPEND(table_names, name) ;
        union_parts := ARRAY_APPEND(union_parts, 'SELECT * FROM default.' || name) ;
    END FOR ;

    -- 如果没有匹配的表，直接返回
    IF (table_count = 0) THEN
        RETURN 'No data to process' ;
    END IF ;

    -- Step 3: 创建临时视图
    LET view_sql := 'CREATE OR REPLACE VIEW default.TEMPORARY_GPS_TABLES AS ' || ARRAY_TO_STRING(union_parts, ' UNION ALL ') ;
    EXECUTE IMMEDIATE :view_sql ;

    -- Step 2: 查询表中的记录数
    LET record_count_sql := 'SELECT COUNT(*) c FROM default.TEMPORARY_GPS_TABLES' ;
    LET r RESULTSET := EXECUTE IMMEDIATE :record_count_sql ;
    for record in r DO
        record_count := record.c ;
    END FOR ;

    -- Step 4: 设置会话参数, example
    EXECUTE IMMEDIATE 'set max_block_size = 65536' ;

    -- Step 5: 执行 示例SQL
    LET merge_sql := 'insert into default.gps select * from default.TEMPORARY_GPS_TABLES;' ;
    EXECUTE IMMEDIATE :merge_sql ;

    -- Step 6: 清理：删除视图
    EXECUTE IMMEDIATE 'DROP VIEW IF EXISTS default.TEMPORARY_GPS_TABLES' ;

    -- Step 7: 删除所有 %abcd% 表
    FOR i IN 1 TO ARRAY_SIZE(table_names) DO
        LET tbl_name := table_names[i]::STRING ;
        LET drop_sql := 'DROP TABLE default."' || tbl_name || '"' ;
        EXECUTE IMMEDIATE :drop_sql ;
    END FOR ;
    RETURN 'Merge completed successfully. Processed ' || table_count || ' tables. Total records: ' || record_count ;
END ;
$$ ; </code></pre><p>调用结果：</p><pre><code>call PROCEDURE PROC_MERGE_GPS() ;
---
Merge completed successfully. Processed 3 tables. Total records: 300</code></pre><h2><em>九、总结</em></h2><p>Databend 的 SQL 存储过程为数据处理提供了强大而灵活的工具。通过本文，我们学习了：</p><ol><li><strong>基础语法</strong>：如何创建和调用存储过程</li><li><strong>变量和赋值</strong>：使用 LET 声明和管理变量</li><li><strong>流程控制</strong>：IF 条件判断和 FOR 循环</li><li><strong>高级特性</strong>：嵌套循环、结果集遍历、返回表格</li><li><strong>管理操作</strong>：查看、描述、删除存储过程</li><li><strong>最佳实践</strong>：命名规范、注释、错误处理、性能优化</li></ol><h3><em>关键要点回顾</em></h3><ul><li>✅ 使用 <code>CREATE PROCEDURE</code> 创建存储过程</li><li>✅ 使用 <code>CALL PROCEDURE</code> 调用存储过程</li><li>✅ 使用 <code>EXECUTE IMMEDIATE</code> 执行动态 SQL</li><li>✅ 使用 <code>LET</code> 声明变量，<code>:=</code> 赋值</li><li>✅ 支持 <code>IF-THEN-ELSE</code> 条件判断</li><li>✅ 支持 <code>FOR...IN...DO</code> 循环</li><li>✅ 可以返回单个值或整张表</li><li>✅ 使用 <code>CREATE OR REPLACE</code> 更新存储过程</li><li>✅ 使用 <code>RESULTSET</code> 类型处理查询结果</li></ul><h3><em>下一步</em></h3><p>现在你已经掌握了 Databend 存储过程的核心知识，可以开始：</p><ol start="7"><li>在自己的项目中创建简单的存储过程</li><li>逐步引入更复杂的逻辑和流程控制</li><li>将常用的数据处理任务封装为存储过程</li><li>探索更多高级特性和优化技巧</li></ol><p>Happy coding with Databend! 🚀</p><h2>关于 Databend</h2><p>Databend 是一款开源、弹性、低成本，基于对象存储也可以做实时分析的新式湖仓。期待您的关注，一起探索云原生数仓解决方案，打造新一代开源 Data Cloud。</p><p>👨‍💻‍ Databend Cloud：<a href="https://link.segmentfault.com/?enc=P3aVDBMB4HdPc9YUZapaVQ%3D%3D.AUOUhDeqroEbJS0UaNFRDfA5Ep1%2FDbTlLqmlt1t5Asg0pgXyWXVXIKR6o0o0jX496k35jOsLSOkTnvD3SYwEcw%3D%3D" rel="nofollow" title="https://link.juejin.cn/?target=https%3A%2F%2Fdatabend.cn%2F" target="_blank">databend.cn</a></p><p>📖 Databend 文档：<a href="https://link.segmentfault.com/?enc=H%2F8PlpltaS34N1DwPC3tbw%3D%3D.8Lkk6SMMF6WICouN6oUR6YGaauLewcQhKE3C4lwdUrZ38YfIB%2B8gW4zjEuCg8%2B%2FdoPDt1sUS7U%2FvA5QKOZsFnJQB0ClU3D9uM7tFGf5lYXE%3D" rel="nofollow" title="https://link.juejin.cn/?target=https%3A%2F%2Fdocs.databend.cn%2F" target="_blank">docs.databend.cn</a></p><p>💻 Wechat：Databend</p><p>✨ GitHub：<a href="https://link.segmentfault.com/?enc=Cprp84F2tBEipBiWEQOG9Q%3D%3D.MYRIUJ7Xotc1UqbUieYqVR0E9eH5VyoRYtES4XFHSe5MVXiO6%2FZz6fD%2B0ABOhGf2C6B9so4LWIp%2F4mpRjaNeCC9x3maTvFGdVSeh3xquH39BE%2FJ1HnXh7kuvstjMGrgl" rel="nofollow" title="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdatabendlabs%2Fdatabend" target="_blank">github.com/databendlab…</a></p>]]></description></item><item>    <title><![CDATA[如何使用 C# 创建 Word 文档填充]]></title>    <link>https://segmentfault.com/a/1190000047400494</link>    <guid>https://segmentfault.com/a/1190000047400494</guid>    <pubDate>2025-11-14 18:03:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在企业应用中，Word 文档（DOC/DOCX）仍然是信息交换和报告制作的核心工具。无论是合同、通知、汇报材料还是自动生成报表，都需要程序化生成 Word 文件。在传统做法中，开发者可能依赖手动操作或 Office 自动化（Interop），但这类方法存在依赖 Office 安装、性能低下及易出错的问题。</p><p>本文将详细介绍如何使用 <strong><a href="https://link.segmentfault.com/?enc=POKUCajmFjOyO0%2Bl8NSMWA%3D%3D.1e6jImGNhIRiwCs4JQSpN1eGnGdPUdh%2BXVjMKE9XNB6S9mQdyJ6GBkmYMxtvRGf2WzTZ9keyAYgjIW90OtVm7A%3D%3D" rel="nofollow" target="_blank">Free Spire.Doc for .NET</a></strong> 在 C# 中创建 Word 文档、插入文本、表格、图片及页眉页脚，并扩展到保存不同格式和 MemoryStream 的场景。示例数据仍使用英文文本，以便快速理解。</p><hr/><h2>1. 安装 Spire.Doc</h2><p>在使用前，需要通过 NuGet 安装 Spire.Doc：</p><pre><code class="bash">Install-Package FreeSpire.Doc</code></pre><p>安装完成后，在 C# 项目中引用必要命名空间：</p><pre><code class="csharp">using Spire.Doc;
using Spire.Doc.Documents;
using Spire.Doc.Fields;
using System.IO;
using System.Drawing;</code></pre><hr/><h2>2. 创建 Word 文档并添加段落</h2><pre><code class="csharp">// 创建新的文档
Document document = new Document();
Section section = document.AddSection();

// 添加标题段落
Paragraph title = section.AddParagraph();
title.AppendText("Employee Report");
title.Format.HorizontalAlignment = HorizontalAlignment.Center;
title.ApplyStyle(BuiltinStyle.Heading1);

// 添加正文段落
Paragraph intro = section.AddParagraph();
intro.AppendText("This report contains the details of employees in the company. All information is for internal use only.");
intro.Format.HorizontalAlignment = HorizontalAlignment.Left;
intro.Format.LineSpacing = 15f;</code></pre><p><strong>说明</strong>：</p><ul><li><code>AddSection</code> 创建独立章节，方便分页和样式管理。</li><li>内置样式（<code>BuiltinStyle</code>）提供 Word 标准格式。</li><li><code>Paragraph.Format</code> 可自定义对齐、行距、缩进等。</li></ul><hr/><h2>3. 插入表格并填充数据</h2><pre><code class="csharp">// 创建表格，5 行 5 列（含标题行）
Table table = section.AddTable(true);
table.ResetCells(5, 5);

// 设置标题行
table[0, 0].AddParagraph().AppendText("EmployeeID");
table[0, 1].AddParagraph().AppendText("FullName");
table[0, 2].AddParagraph().AppendText("Department");
table[0, 3].AddParagraph().AppendText("HireDate");
table[0, 4].AddParagraph().AppendText("Salary");

// 填充示例数据
table[1, 0].AddParagraph().AppendText("E101");
table[1, 1].AddParagraph().AppendText("John Miller");
table[1, 2].AddParagraph().AppendText("Finance");
table[1, 3].AddParagraph().AppendText("2020-02-15");
table[1, 4].AddParagraph().AppendText("7500");

table[2, 0].AddParagraph().AppendText("E102");
table[2, 1].AddParagraph().AppendText("Sarah Brown");
table[2, 2].AddParagraph().AppendText("HR");
table[2, 3].AddParagraph().AppendText("2019-07-10");
table[2, 4].AddParagraph().AppendText("6800");

table[3, 0].AddParagraph().AppendText("E103");
table[3, 1].AddParagraph().AppendText("Mike Smith");
table[3, 2].AddParagraph().AppendText("IT");
table[3, 3].AddParagraph().AppendText("2020-01-20");
table[3, 4].AddParagraph().AppendText("9000");

table[4, 0].AddParagraph().AppendText("E104");
table[4, 1].AddParagraph().AppendText("Lisa Jones");
table[4, 2].AddParagraph().AppendText("Marketing");
table[4, 3].AddParagraph().AppendText("2018-09-05");
table[4, 4].AddParagraph().AppendText("5500");</code></pre><p><strong>说明</strong>：</p><ul><li><code>AddTable(true)</code> 创建具有默认样式的表格。</li><li><code>ResetCells</code> 定义行列数。</li><li><code>table[i, j].AddParagraph()</code> 可插入文本，支持格式和超链接。</li></ul><hr/><h2>4. 自定义表格样式和段落格式</h2><pre><code class="csharp">// 设置标题行背景色
for (int i = 0; i &lt; 5; i++)
{
    table[0, i].CellFormat.BackColor = Color.LightGray;
    table[0, i].Paragraphs[0].GetStyle().CharacterFormat.Bold = true;
}

// 设置表格边框
table.TableFormat.Borders.BorderType = BorderStyle.Single;

// 设置行高
for (int i = 0; i &lt; table.Rows.Count; i++)
{
    table.Rows[i].Height = 20f;
}</code></pre><hr/><h2>5. 插入图片</h2><pre><code class="csharp">// 添加图片
Paragraph imgPara = section.AddParagraph();
DocPicture picture = imgPara.AppendPicture(Image.FromFile("company_logo.png"));
picture.Width = 100;
picture.Height = 50;
imgPara.Format.HorizontalAlignment = HorizontalAlignment.Right;</code></pre><p><strong>说明</strong>：</p><ul><li>使用 <code>AppendPicture</code> 插入图片，可调整宽高。</li><li>图片可放置于段落中，可对齐左、中、右。</li></ul><hr/><h2>6. 添加页眉页脚</h2><pre><code class="csharp">// 页眉
HeaderFooter header = section.HeadersFooters.Header;
Paragraph headerPara = header.AddParagraph();
headerPara.AppendText("Company Confidential");
headerPara.Format.HorizontalAlignment = HorizontalAlignment.Center;

// 页脚
HeaderFooter footer = section.HeadersFooters.Footer;
Paragraph footerPara = footer.AddParagraph();
footerPara.AppendText("Page ");
footerPara.AppendField("PAGE", FieldType.FieldPage);
footerPara.AppendText(" of ");
footerPara.AppendField("NUMPAGES", FieldType.FieldNumPages);
footerPara.Format.HorizontalAlignment = HorizontalAlignment.Center;</code></pre><p><strong>说明</strong>：</p><ul><li>页眉页脚可包含文字、页码、图片等内容。</li><li><code>FieldType.FieldPage</code> 与 <code>FieldType.FieldNumPages</code> 可实现自动页码功能。</li></ul><hr/><h2>7. 保存 Word 文档及其他格式</h2><pre><code class="csharp">// 保存为 DOCX
document.SaveToFile("EmployeeReport.docx", FileFormat.Docx);

// 保存为 PDF
document.SaveToFile("EmployeeReport.pdf", FileFormat.PDF);

// 保存为 HTML
document.SaveToFile("EmployeeReport.html", FileFormat.Html);

// 保存到 MemoryStream
using (MemoryStream ms = new MemoryStream())
{
    document.SaveToStream(ms, FileFormat.Docx);
    // 可直接发送到客户端或存储到数据库
}</code></pre><hr/><h2>8. 生成效果展示</h2><p>以下是上述代码生成的 Word 文档效果：</p><p><img width="723" height="500" referrerpolicy="no-referrer" src="/img/bVdm3cf" alt="C#创建并保存Word文档" title="C#创建并保存Word文档"/></p><hr/><h2>9. 扩展应用场景</h2><ol><li><strong>自动化报表生成</strong><br/>系统可以定期生成员工报告、销售报表，减少手工操作。</li><li><strong>动态内容生成</strong><br/>根据数据库动态填充段落、表格、图片，生成模板化文档。</li><li><strong>多格式导出</strong><br/>Spire.Doc 支持 DOCX、PDF、HTML 等多种格式，满足打印、网页展示或二次处理。</li><li><strong>Web 集成</strong><br/>MemoryStream 方式可直接返回客户端，无需写入磁盘，提高安全性和性能。</li></ol><hr/><h2>10. 总结</h2><p>本文演示了如何使用 <strong>Spire.Doc for .NET</strong>：</p><ul><li>创建 Word 文档并添加标题、正文、表格</li><li>美化表格和段落样式</li><li>插入图片和页眉页脚</li><li>将文档保存为 DOCX、PDF、HTML 等多种格式</li><li>使用 MemoryStream 实现网络传输或二次处理</li></ul><p>通过掌握 <code>Document</code>、<code>Section</code>、<code>Paragraph</code>、<code>Table</code>、<code>DocPicture</code> 等核心类和方法，你可以轻松实现 Word 文档自动化生成，提高办公系统开发效率和文档管理水平。</p>]]></description></item><item>    <title><![CDATA[【HarmonyOS 6】静态和动态添加]]></title>    <link>https://segmentfault.com/a/1190000047400506</link>    <guid>https://segmentfault.com/a/1190000047400506</guid>    <pubDate>2025-11-14 18:02:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>【HarmonyOS 6】静态和动态添加应用快捷方式详解</h2><h3>一、前言</h3><p>在功能日益复杂的应用中，用户往往需要多步操作才能找到常用功能。而应用快捷方式能让用户一键直达核心功能，既提升操作效率，也能增强用户对应用的粘性。</p><p>本文结合实际开发场景，详细分享 HarmonyOS 中两种快捷方式的实现方法，包括静态快捷方式配置和应用内动态添加，全程基于单 HAP 包场景（多 HAP 包配置逻辑一致）。</p><h3>二、静态快捷方式：基础配置与快速跳转</h3><p>静态快捷方式是通过配置文件预先定义的快捷方式，用户长按应用图标即可看到。例如“回家导航”“新建便签”这类高频固定功能。效果如下：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400508" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><h5>1、 创建目标页面并配置路由</h5><p>首先创建快捷方式对应的功能页面（如“回家”“去公司”页面），页面需用 <code>@Entry</code> 装饰。然后在 <code>resources/base/profile/main_pages.json</code> 中添加页面路由，确保应用能识别页面路径：</p><pre><code class="json">{
  "src": [
    "pages/Index",  // 应用主页面
    "pages/GoHouse", // 回家导航页面
    "pages/GoCompany" // 去公司导航页面
  ]
}</code></pre><h5>2、 编写快捷方式配置文件</h5><p>在 <code>resources/base/profile/</code> 目录下新建 <code>shortcuts_config.json</code> 文件，定义快捷方式的 ID、显示文本、图标和跳转目标。每个快捷方式需包含以下核心参数：</p><ul><li><code>shortcutId</code>：唯一标识，不超过 63 字节</li><li><code>label</code>：显示文本（支持字符串或资源索引）</li><li><code>icon</code>：图标资源索引</li><li><code>wants</code>：跳转配置（包名、模块名、组件名、自定义参数）</li></ul><p>示例配置：</p><pre><code class="json">{
  "shortcuts": [
    {
      "shortcutId": "id_company",
      "label": "$string:Go_to_the_Company",
      "icon": "$media:company",
      "wants": [
        {
          "bundleName": "com.example.desktopshortcuts",
          "moduleName": "entry",
          "abilityName": "EntryAbility",
          "parameters": {
            "shortCutKey": "CompanyPage"
          }
        }
      ]
    },
    {
      "shortcutId": "id_house",
      "label": "$string:Go_to_House",
      "icon": "$media:house",
      "wants": [
        {
          "bundleName": "com.example.desktopshortcuts",
          "moduleName": "entry",
          "abilityName": "EntryAbility",
          "parameters": {
            "shortCutKey": "HousePage"
          }
        }
      ]
    }
  ]
}</code></pre><h5>3、在 module.json5 中关联配置</h5><p>在 <code>module.json5</code> 的 <code>abilities</code> 标签下添加 <code>metadata</code> 配置，指定快捷方式配置文件路径，让系统识别快捷方式：</p><pre><code class="json">{
  "module": {
    "abilities": [
      {
        "name": "EntryAbility",
        "srcEntry": "./ets/entryability/EntryAbility.ets",
        "skills": [
          {
            "entities": ["entity.system.home"],
            "actions": ["ohos.want.action.home"]
          }
        ],
        "metadata": [
          {
            "name": "ohos.ability.shortcuts",
            "resource": "$profile:shortcuts_config"
          }
        ]
      }
    ]
  }
}</code></pre><h5>4、实现页面跳转逻辑</h5><p>在主页面（Index.ets）中定义跳转方法，通过读取 <code>wants</code> 中的自定义参数 <code>shortCutKey</code>，判断用户点击的快捷方式，进而跳转到对应页面：</p><pre><code class="typescript">goToSpecifyPage(want?: Want) {
  let shortCutKey = want?.parameters?.shortCutKey;

  if (shortCutKey === 'CompanyPage') {
    this.getUIContext().getRouter().pushUrl({ url: 'pages/GoCompany' })
      .catch((err: BusinessError) =&gt; {
        hilog.error(0x0000, 'testTag', `跳转失败：${err.code}, ${err.message}`);
      });
  }
  if (shortCutKey === 'HousePage') {
    this.getUIContext().getRouter().pushUrl({ url: 'pages/GoHouse' })
      .catch((err: BusinessError) =&gt; {
        hilog.error(0x0000, 'testTag', `跳转失败：${err.code}, ${err.message}`);
      });
  }
}</code></pre><h5>5、 保存并传递 Want 参数</h5><p>快捷方式跳转分为冷启动和热启动，需在 <code>EntryAbility.ets</code> 中通过 <code>AppStorage</code> 保存 <code>want</code> 参数，确保页面能获取到跳转信息：</p><pre><code class="typescript">// 冷启动时保存参数
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
  this.context.getApplicationContext().setColorMode(ConfigurationConstant.ColorMode.COLOR_MODE_NOT_SET);
  if (want?.parameters?.shortCutKey) {
    AppStorage.setOrCreate('want', want);
  }
}

// 热启动时更新参数
onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam): void {
  if (want?.parameters?.shortCutKey) {
    AppStorage.setOrCreate('want', want);
  }
}</code></pre><h5>6、 页面显示时执行跳转</h5><p>在主页面的 <code>onPageShow</code> 方法中，读取 <code>AppStorage</code> 中保存的 <code>want</code> 参数，调用跳转方法完成快捷方式响应：</p><pre><code class="typescript">onPageShow(): void {
  if (AppStorage.has('want')) {
    let want: Want | undefined = AppStorage.get('want');
    if (want) {
      this.goToSpecifyPage(want);
      AppStorage.delete('want'); // 跳转后清除参数，避免重复触发
    }
  }
}</code></pre><p>具体跳转的处理，通过want中的参数，开发者可以根据自己业务习惯进行跳转处理，以上处理为参考。</p><h4>注意事项</h4><p>（1）静态快捷方式最多支持配置 4 个，仅能跳转至 UIAbility 入口页面，无法直接跳转到非入口页面。<br/>（2）多 HAP 包场景无需额外配置，所有操作均在 entry 文件夹下完成。</p><h3>二、应用内动态添加快捷方式</h3><p>除了预先配置的静态快捷方式，还可以在应用内通过代码动态添加快捷方式（如用户点击“添加到桌面”按钮时创建），灵活性更高。</p><h4>核心实现代码</h4><p>创建 <code>ShortcutsUtils</code> 工具类，封装动态添加快捷方式的逻辑，包含权限校验、重复判断和创建请求：</p><pre><code class="typescript">import { hilog } from "@kit.PerformanceAnalysisKit";
import { BusinessError } from "@kit.BasicServicesKit";
import { productViewManager } from "@kit.StoreKit";
import { common, Want } from "@kit.AbilityKit";
import promptAction from '@ohos.promptAction';

export class ShortcutsUtils {
  /**
   * 点击按钮添加快捷方式
   */
  static addShortcuts() {
    const uiContext = getContext() as common.UIAbilityContext;
    const shortcutId = "id_test1"; // 需与 shortcuts_config.json 中定义的一致
    const labelResName = "shortcut"; // 对应 label 的资源索引名称
    const iconResName = "aa_icon"; // 对应 icon 的资源索引名称
    const want: Want = {
      bundleName: "com.example.appgallery.kit.demo",
      moduleName: "entry",
      abilityName: "EntryAbility",
      parameters: {
        testKey: "testValue" // 自定义参数
      }
    };

    try {
      // 校验快捷方式是否可添加（是否已存在、是否有权限）
      productViewManager.checkPinShortcutPermitted(uiContext, shortcutId, want, labelResName, iconResName)
        .then((result) =&gt; {
          hilog.info(0x0001, 'addShortcuts', `校验成功：${JSON.stringify(result)}`);
          const tid = result.tid;
          // 发起添加快捷方式请求
          productViewManager.requestNewPinShortcut(uiContext, tid)
            .then(() =&gt; {
              hilog.info(0x0001, 'addShortcuts', "快捷方式添加成功！");
            })
            .catch((error: BusinessError) =&gt; {
              hilog.error(0x0001, 'addShortcuts', `快捷方式添加失败：${error.code}, ${error.message}`);
            });
        })
        .catch((error: BusinessError) =&gt; {
          hilog.error(0x0001, 'addShortcuts', `err：${error.code}, ${error.message}`);
          // 错误码 1006620003 表示快捷方式已存在
          if (error.code === 1006620003) {
            promptAction.showToast({ message: '桌面已存在此快捷方式！' });
          }
        });
    } catch (err) {
      hilog.error(0x0001, 'TAG', `catch err：${err.code}, ${err.message}`);
    }
  }
}</code></pre><h4>使用方式</h4><p>在应用页面的按钮点击事件中调用工具类方法，即可触发快捷方式添加流程：</p><pre><code class="typescript">// 示例：按钮点击事件
Button('添加测试快捷方式')
  .onClick(() =&gt; {
    ShortcutsUtils.addShortcuts();
  })</code></pre><p>productViewManager允许应用添加快捷方式的数量为两个。这是鸿蒙官方的设计如此。</p><h3>三、两种快捷方式的区别与适用场景</h3><table><thead><tr><th>类型</th><th>配置方式</th><th>灵活性</th><th>适用场景</th></tr></thead><tbody><tr><td>静态快捷方式</td><td>配置文件定义</td><td>较低（固定功能）</td><td>高频固定功能，如导航、新建、快速拍照</td></tr><tr><td>动态快捷方式</td><td>代码动态添加</td><td>较高（用户触发）</td><td>个性化功能，如用户自定义收藏、临时高频功能</td></tr></tbody></table>]]></description></item><item>    <title><![CDATA[【赵渝强老师】OceanBase的连接与]]></title>    <link>https://segmentfault.com/a/1190000047400537</link>    <guid>https://segmentfault.com/a/1190000047400537</guid>    <pubDate>2025-11-14 18:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>OceanBase数据库连接路由管理组件ODP（OceanBase Database Proxy）是OceanBase数据库专用的连接路由管理集群。OceanBase数据库用户的数据会以多副本的形式存放在各个OBServer节点上，ODP接收用户发出的SQL请求，并将SQL请求转发至最佳目标OBServer节点，最后将执行结果返回给用户。</p><h2>一、 ODP简介</h2><p>OceanBase数据库与传统单机数据库不同，OceanBase数据库是分布式数据库，每个表甚至每个表的不同分区都可能存放在不同的机器上。想要对表进行读写，必须先要定位到数据所属的表或是分区的主副本位置，然后才能执行相应的SQL语句，这在应用层面而言是几乎不可能做到的。ODP作为OceanBase数据库专用的反向代理软件，其核心功能是路由，将客户端发起的数据访问请求转发到正确的OBServer节点上，并将OBServer节点的响应结果转发给客户端。视频讲解如下：<br/><a href="https://www.bilibili.com/video/BV1kcCbB4Ei2/?aid=115542555893412&amp;cid=33978453859" target="_blank">https://www.bilibili.com/video/BV1kcCbB4Ei2/?aid=115542555893...</a></p><p>作为OceanBase数据库的关键组件，ODP具有以下特性：</p><ul><li><strong>连接管理</strong>：针对一个客户端的物理连接，ODP维持自身到后端多个OBServer节点的连接，并维持了每个OBServer节点连接的会话状态，保证了客户端高效访问各个OBServer节点。</li><li><strong>最佳路</strong>由：ODP充分考虑用户请求涉及的副本位置、用户配置的读写分离路由策略、OceanBase多地部署的最优链路，以及OceanBase各机器的状态及负载情况，将用户的请求路由到最佳的OBServer节点，最大程度地保证了OceanBase整体的高性能运转。</li><li><strong>高性能转发</strong>：ODP完整兼容MySQL协议，并支持OceanBase自研协议，采用多线程异步框架和透明流式转发的设计，保证了数据的高性能转发，同时确保了自身对机器资源的最小消耗。</li><li><strong>易运维</strong>：ODP本身无状态，支持无限水平扩展，支持同时访问多个OceanBase集群。可通过丰富的内部命令对ODP状态进行实时监控，这使得运维简单便利。</li><li><strong>高可用</strong>：ODP高可用分为两部分：一方面保证自身高可用，持续提供代理服务；另一方面ODP是OceanBase高可用体系的主要组成部分，可以对用户屏蔽宕机、升级等情况，保证OceanBase数据库服务的稳定和快速恢复。</li><li><strong>专有协议</strong>：ODP与OBServer节点默认采用了OceanBase专有协议，如增加报文的CRC校验保证与OBServer节点链路的正确性，增强传输协议以支持Oracle兼容性的数据类型和交互模型。</li></ul><p>客户端通过ODP访问OceanBase数据库的数据链路如下图所示。<br/><img width="723" height="460" referrerpolicy="no-referrer" src="/img/bVdmYFf" alt="image.png" title="image.png"/></p><h2>二、 使用ODP连接数据库集群</h2><p>部署好ODP集群后，便可以通过OBProxy连接OceanBase数据库集群了，下面是具体的操作步骤。<br/>（1）在中控机上执行命令查看集群的节点信息。</p><pre><code class="powershell">obd cluster display myob-cluster

# 输出的信息如下：
......
Connect to obproxy ok
+-------------------------------------------------------------------+
|                             obproxy-ce                            |
+---------------+------+-----------------+-----------------+--------+
| ip            | port | prometheus_port | rpc_listen_port | status |
+---------------+------+-----------------+-----------------+--------+
| 192.168.79.11 | 2883 | 2884            | 2885            | active |
| 192.168.79.13 | 2883 | 2884            | 2885            | active |
+---------------+------+-----------------+-----------------+--------+
obclient -h192.168.79.11 -P2883 -uroot@proxysys -p'Welcome_1' -Doceanbase -A 
......

# 提示：从输出的信息可以看出，ODP集群中包含两台OBProxy，
# 它们分别运行在：192.168.79.11和192.168.79.13主机上。</code></pre><p>（2）登录192.168.79.11主机，查看OBProxy的目录结构。</p><pre><code class="powershell">tree /root/obproxy/ -L 1

# 输出的信息如下：
/root/obproxy/
├── bin                    保存ODP的可执行二进制文件
├── control-config
├── etc                    保存配置信息的目录
├── lib
├── log                    保存日志文件的目录
├── obproxyd.sh            OBProxy的守护进程
├── run                    保存OBProxy启动的进程号信息
└── sharding-config        保存Sharding（分片）相关的配置文件

# 提示：如果OBProxy进程不存在，或者异常宕机。
# obproxyd.sh脚本负责重新启动OBProxy进程。</code></pre><p>（3）通过操作的的ps命令可以查看到OBProxy的进程信息。</p><pre><code class="powershell">ps -ef | grep obproxy

# 输出的信息如下：
root  4895 ... bash /root/obproxy/obproxyd.sh /root/obproxy 192.168.79.11 2883 daemon
root  4904 ... /root/obproxy/bin/obproxy --listen_port 2883
root 10892 ... grep obproxy

# 提示：这里的进程号4895与4904与run目录下的进程号文件保持一致，如下所示：
[root@node11 obproxy]# ls run/
obproxy-192.168.79.11-2883.pid  obproxyd-192.168.79.11-2883.pid
[root@node11 obproxy]# cat run/*
4904
4895</code></pre><p>（4）通过OBProxy连接OceanBase数据库集群</p><pre><code class="powershell">obclient -h192.168.79.11 -P2883 -uroot@sys#myob-cluster -pWelcome_1 -Doceanbase -A

# 提示：该命令也可以简写成下面的形式：
obclient -h192.168.79.11 -P2883 -uroot -pWelcome_1 -Doceanbase -A

# 此时如果出现下面的错误：
ERROR 2013 (HY000): 
Lost connection to MySQL server at 'reading authorization packet', 
system error: 11

# 这是由于集群配置信息中的proxyro_password不一致造成。</code></pre><p>（5）在中控机上执行下面的命令编辑集群的配置信息。</p><pre><code class="powershell">obd cluster edit-config myob-cluster</code></pre><p>（6）将global下的proxyro_password修改为正确的密码，保存并退出。</p><pre><code class="powershell">  global:
    ......
    root_password: Welcome_1
    appname: myob-cluster
    ocp_agent_monitor_password: ztkrtULS7u
    proxyro_password: YqNSd87E3K
    ......
    
  修改为：
  
  global:
    ......
    root_password: Welcome_1
    appname: myob-cluster
    ocp_agent_monitor_password: ztkrtULS7u
    proxyro_password: Welcome_1
    ......</code></pre><p>（7）重新加载配置信息。</p><pre><code class="powershell">obd cluster reload myob-cluster</code></pre><p>（8）通过OBProxy连接OceanBase数据库集群</p><pre><code class="powershell">obclient -h192.168.79.11 -P2883 -uroot@sys#myob-cluster -pWelcome_1 -Doceanbase -A

ob&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| LBACSYS            |
| mysql              |
| oceanbase          |
| ocs                |
| ORAAUDITOR         |
| scott              |
| SYS                |
| sys_external_tbs   |
| test               |
+--------------------+
10 rows in set (0.011 sec)</code></pre><h2>三、 查看ODP配置属性</h2><p>通过使用root@sys用户通过ODP代理登录OceanBase数据库，或使用root@proxysys用户登录ODP均可以查看ODP的配置参数。下面是具体的操作步骤：<br/>（1）执行命令登录OceanBase数据库或者ODP</p><pre><code class="powershell"># 登录OceanBase数据库
obclient -h192.168.79.11 -P2883 -uroot@sys#myob-cluster -pWelcome_1 -Doceanbase -A

# 登录ODP
obclient -h192.168.79.11 -P2883 -uroot@proxysys -p'Welcome_1' -Doceanbase -A</code></pre><p>（2）查看ODP的参数配置。</p><pre><code class="powershell">ob&gt; show proxyconfig \G;

# 输出的信息如下：
......
*************************** 326. row ***************************
         name: json_config_cluster_count
        value: 1
         info: ob cluster count, meta db cluster not included
  need_reboot: false
visible_level: virtual
        range: NULL
 config_level: NULL
*************************** 327. row ***************************
         name: json_config_modified_time
        value: 2025-04-15 14:12:20.271644
         info: json config modified time
  need_reboot: false
visible_level: virtual
        range: NULL
 config_level: NULL
327 rows in set (0.012 sec)</code></pre><p>（3）使用like关键字查看ODP的参数配置。</p><pre><code class="powershell">ob&gt; show proxyconfig like '%full%'\G;

# 输出的信息如下：
*************************** 1. row ***************************
         name: enable_full_username
        value: False
        info: used for non-cloud user, if set true, username must have tenant and cluster
  need_reboot: false
visible_level: SYS
        range: 
 config_level: LEVEL_GLOBAL
*************************** 2. row ***************************
         name: enable_cloud_full_username
        value: False
         info: used for cloud user, if set false, treat all login user as username
  need_reboot: false
visible_level: SYS
        range: 
 config_level: LEVEL_VIP
*************************** 3. row ***************************
         name: enable_full_link_trace
        value: False
         info: if enable proxy will use full link trace to trace query execution
  need_reboot: false
visible_level: USER
        range: 
 config_level: LEVEL_GLOBAL
3 rows in set (0.009 sec)</code></pre><p>（4）执行select * from proxy_config命令查看配置参数。</p><pre><code class="powershell">ob&gt; select * from proxy_config;

# 输出信息如下：
+---------------------------------+-----------------+--------------+
......                                              
| server_state_refresh_interval   | 20s             | LEVEL_GLOBAL |
| cache_cleaner_clean_interval    | 20s             | LEVEL_GLOBAL |
| proxy_hot_upgrade_check_interval| 5s              | LEVEL_GLOBAL |
| proxy_info_check_interval       | 60s             | LEVEL_GLOBAL |
| refresh_config                  | False           | LEVEL_GLOBAL |
| refresh_idc_list                | False           | LEVEL_GLOBAL |
| refresh_rslist                  | False           | LEVEL_GLOBAL |
| refresh_json_config             | False           | LEVEL_GLOBAL |
| enable_xa_route                 | True            | LEVEL_GLOBAL |
| observer_sys_password           | d809d427528be882| LEVEL_GLOBAL |
+---------------------------------+-----------------+--------------+
319 rows in set (0.056 sec)

# 提示：该命令仅在使用root@proxysys用户登录ODP时可执行，其他用户下执行会报错。</code></pre><h2>四、 修改ODP配置属性</h2><p>修改ODP配置属性的值可以通过以下两种方式实现：</p><ul><li>在ODP运行时，使用root@proxysys用户登录ODP后，执行alter proxyconfig命令修改ODP配置项。</li><li>在ODP启动时，启动命令中添加-o选项修改配置项。</li></ul><p>这里以配置属性enable_cluster_checkout为例来进行演示。该属性用于控制是否进行集群名称校验，默认值是False。如果启用集群校验，在登录时ODP会发送集群名称，服务器会对其进行检查。下面是具体的操作步骤。</p><h3>方式一：通过alter proxyconfig命令</h3><p>（1）登录ODP</p><pre><code class="powershell">obclient -h192.168.79.11 -P2883 -uroot@proxysys -pWelcome_1</code></pre><p>（2）查看配置属性enable_cluster_checkout的值。</p><pre><code class="powershell">ob&gt; show proxyconfig like 'enable_cluster_checkout' \G;

# 输出信息如下：
*************************** 1. row ***************************
         name: enable_cluster_checkout
        value: False
         info: if enable cluster checkout, proxy will send cluster 
               name when login and server will check it
  need_reboot: false
visible_level: USER
        range: 
 config_level: LEVEL_GLOBAL
1 row in set (0.002 sec)</code></pre><p>（3）通过alter proxyconfig命令修改属性。</p><pre><code class="powershell">ob&gt; alter proxyconfig set enable_cluster_checkout=True;</code></pre><p>（4）重新查看配置属性enable_cluster_checkout的值。</p><pre><code class="powershell">ob&gt; show proxyconfig like 'enable_cluster_checkout' \G;

# 输出信息如下：
*************************** 1. row ***************************
         name: enable_cluster_checkout
        value: True
         info: if enable cluster checkout, proxy will send cluster 
               name when login and server will check it
  need_reboot: false
visible_level: USER
        range: 
 config_level: LEVEL_GLOBAL
1 row in set (0.002 sec)</code></pre><h3>方式二：通过启动命令的-o选项</h3><p>（1）在中控机上执行命令查看集群的节点信息。</p><pre><code class="powershell">obd cluster display myob-cluster

# 输出的信息如下：
......
Connect to obproxy ok
+-------------------------------------------------------------------+
|                             obproxy-ce                            |
+---------------+------+-----------------+-----------------+--------+
| ip            | port | prometheus_port | rpc_listen_port | status |
+---------------+------+-----------------+-----------------+--------+
| 192.168.79.11 | 2883 | 2884            | 2885            | active |
| 192.168.79.13 | 2883 | 2884            | 2885            | active |
+---------------+------+-----------------+-----------------+--------+
obclient -h192.168.79.11 -P2883 -uroot@proxysys -p'Welcome_1' -Doceanbase -A 
......</code></pre><p>（2）以192.168.79.11主机上的OBProxy为例，查看OBProxy进程信息并停止OBProxy</p><pre><code class="powershell">ps -ef|grep obproxy

# 输出信息如下：
Root 7574 1 ... bash /root/obproxy/obproxyd.sh /root/obproxy 192.168.79.11 2883 daemon
root 7583   1  ... /root/obproxy/bin/obproxy --listen_port 2883
root 11441 5714  ... grep obproxy

# 停止obproxy 进程和obproxyd进程
kill -9 7574
kill -9 7583

# 提示：obproxyd进程也需要停止。
# 否则当obproxy进程停止后，obproxyd会自动重启obproxy进程。</code></pre><p>（3）重启OBProxy，并通过-o选项修改配置参数的值。</p><pre><code class="powershell">cd /root/obproxy/
bin/obproxy -p 2883 -r'192.168.79.11:2881;192.168.79.12:2881;192.168.79.13:2881' \
  -o enable_cluster_checkout=True -c myob-cluster</code></pre><p>（4）连接OBProxy确认配置参数已修改。</p><pre><code class="powershell">obclient -h192.168.79.11 -P2883 -uroot@proxysys -pWelcome_1

ob&gt; show proxyconfig like 'enable_cluster_checkout' \G;

# 输出的信息如下：
*************************** 1. row ***************************
         name: enable_cluster_checkout
        value: True
         info: if enable cluster checkout, proxy will send 
               cluster name when login and server will check it
  need_reboot: false
visible_level: USER
        range: 
 config_level: LEVEL_GLOBAL
1 row in set (0.009 sec)</code></pre>]]></description></item><item>    <title><![CDATA[经销商管理系统小程序：高效赋能企业渠道管]]></title>    <link>https://segmentfault.com/a/1190000047400152</link>    <guid>https://segmentfault.com/a/1190000047400152</guid>    <pubDate>2025-11-14 17:12:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>这款经销商管理系统小程序是专为生产销售企业、微商团队打造的渠道管理工具。它以微擎系统为交付基础，提供在线交付服务，具备官方正品保障，且所有功能支持自由配置，能适配不同类型企业的个性化需求。系统核心聚焦经销商管理与授权认证，同时整合多元实用功能，助力企业简化管理流程、规范经销商体系，提升渠道运营效率。</p><p><strong>二、功能介绍</strong><br/>经销商管理：构建完善的经销商管理体系，涵盖经销商档案创建与维护，实现对经销商信息的集中化、规范化管理。</p><p>授权相关功能：支持授权查询、授权证生成，同时对接微商系统，满足企业对经销商授权认证的全流程需求。</p><p>上下级推荐：内置经销商上下级推荐机制，助力企业拓展经销商网络，优化渠道布局。</p><p>关注海报功能：附带关注海报生成能力，为企业及经销商提供便捷的品牌传播与推广工具。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>生产销售企业：适用于各类有渠道经销商的生产厂家、销售公司，用于管理全国或区域经销商团队。</p><p>微商团队：适配不同规模的微商品牌与团队，满足其多层级经销商管理、授权认证的核心需求。</p><p>行业价值<br/>简化管理流程：通过功能模块化与配置自由化，减少人工操作成本，让经销商管理更高效。</p><p>规范授权体系：清晰的授权查询与证书生成功能，避免授权混乱，保障企业与经销商的合法权益。</p><p>助力渠道拓展：上下级推荐功能为企业拓宽经销商来源，搭配关注海报功能，提升品牌传播与渠道扩张效率。</p><p>适配多元需求：支持功能自由配置，无论是小型初创企业还是大型成熟品牌，都能找到贴合自身的使用方案。</p><p><strong>四、问答环节</strong><br/>问：这款经销商管理系统小程序支持哪些交付方式？</p><p>答：支持在线交付，基于微擎系统完成交付流程。</p><p>问：系统是否适合小型微商团队使用？</p><p>答：适合，系统所有功能可自由配置，能适配不同规模的微商团队及各类企业的需求。</p><p>问：系统能否生成经销商授权证书？</p><p>答：可以，系统具备授权证生成功能，同时支持授权查询，满足授权管理需求。</p><p>问：除了经销商管理，系统还有哪些辅助功能？</p><p>答：包含上下级推荐、关注海报、微商系统对接等功能，兼顾渠道拓展与品牌传播需求。</p>]]></description></item><item>    <title><![CDATA[芒果疯狂霸屏小程序：抖音 + 微信双平台]]></title>    <link>https://segmentfault.com/a/1190000047400157</link>    <guid>https://segmentfault.com/a/1190000047400157</guid>    <pubDate>2025-11-14 17:12:10</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>芒果疯狂霸屏是一款基于微擎系统开发，融合抖音开放平台接口的新型商户引流拓客工具。它支持微信公众号部署，通过 AI 自动化视频合成技术，让终端客户扫码即可一键转发商家预设视频至抖音，帮助商家低成本实现精准获客。产品提供源码交付服务，搭配多档运营套餐与完善的素材支持，操作简单易上手，商户接受度高，同时保障服务周期内的免费更新，满足不同规模商户的引流需求。</p><p><strong>二、功能介绍</strong><br/>核心视频合成功能<br/>后台可上传视频、图片、音频等多元素材，AI 自动完成分割、加特效、合成及音频插入操作。</p><p>独家合成机制有效减少服务器压力，无需高配置即可稳定运行，同时解决视频去重问题。</p><p>合成视频可随机发布，搭配抖音平台传播优势，提升曝光效率。</p><p>引流拓客与运营功能<br/>终端客户一键扫码即可转发商家预设抖音视频，操作便捷降低参与门槛。</p><p>支持卡券模式与纯推广模式，卡券模式可引导用户领取卡券后跳转其他功能，纯推广模式直接跳转商家抖音主页。</p><p>后台具备完善的用户管理、商家管理、活动管理功能，可统计用户数量、商家数量、活动数据，支持新增活动、绑定商家、设置核销员等操作。</p><p>配套支持功能<br/>提供丰富运营素材，包括招商 PPT、展架、引导图片、宣传网站源文件、宣传视频等十余类资料。</p><p>支持增值服务，涵盖服务器环境部署、模块安装、二次开发、抖音蓝 V 认证等。</p><p>兼容 PHP5.5、PHP5.6、PHP7.1 版本，采用在线交付方式，源码加密保障官方正品权益。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>线下实体门店：包括餐饮、装饰、零售等需要本地精准引流的店铺，通过客户自发转发视频扩大门店影响力。</p><p>创业者与服务商：可通过包月、包年、代理授权等模式开展业务，为商户提供引流服务赚取收益。</p><p>各类营销活动：适用于门店开业、新品推广、节日促销等场景，通过视频传播 + 卡券激励提升活动参与度。</p><p>行业价值<br/>降低引流成本：无需大额广告投入，借助用户社交传播实现 “裂变式” 获客，提升获客性价比。</p><p>提升操作效率：商户无需专业视频制作能力，AI 自动化合成减少人力成本，终端用户操作简单促进参与率。</p><p>拓展盈利模式：为创业者提供多档运营方案，从基础服务到代理授权、团队收购，满足不同阶段发展需求。</p><p>精准对接流量：依托抖音平台流量优势与微信生态传播渠道，实现线上流量向线下门店的精准转化。</p><p><strong>四、常见问答环节</strong><br/>问：该系统适用于什么平台？</p><p>答：适用于微信公众号，需基于微擎系统部署，同时对接抖音开放平台实现视频传播功能。</p><p>问：使用系统前需要准备什么？</p><p>答：需申请抖音开放平台账号，商家可自行申请，平台会提供相关申请方案。</p><p>问：若抖音开放平台参数修改，系统无法使用该怎么办？</p><p>答：因抖音开放平台参数调整导致系统不可用，芒果团队不承担责任，不同意此条款请勿购买。</p><p>问：转发视频会对终端用户产生影响吗？</p><p>答：系统活动需提前告知商户及终端用户，视频会转发至用户抖音作品，未告知引发的后果由程序购买者承担。</p>]]></description></item><item>    <title><![CDATA[开源之谜：是理想乌托邦，还是商业新战略？]]></title>    <link>https://segmentfault.com/a/1190000047400161</link>    <guid>https://segmentfault.com/a/1190000047400161</guid>    <pubDate>2025-11-14 17:11:26</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在软件吞噬世界的今天，开源软件已成为不可或缺的基础设施。然而，围绕它的误解与困惑从未停止。它究竟是程序员理想主义的乌托邦，还是商业世界精心设计的战略？我们将通过一系列问题，揭开开源软件的层层面纱。</p><p><strong>第一问：开源软件是“用爱发电”的公益项目吗？</strong></p><p><strong>答：不，可持续的开源根本上是“商业驱动的现实主义”。</strong></p><p>许多人被开源的“开放、共享”精神所感动，认为这源于无私的奉献。然而，绝大多数能够长期存在并流行的开源项目，其根本动力是<strong>广义的盈利</strong>。这里的“盈利”并非单指软件授权的直接收入，而是指确保项目主导者（个人或企业）能够获得维持生存与发展的资源。</p><p>这包括：</p><ul><li><strong>个人作者</strong>：通过开源建立声誉，从而获得高薪工作、咨询合同、捐赠或赞助。</li><li><strong>创业公司</strong>：通过开源项目获取大量用户，再通过提供付费的企业版功能、云托管服务（SaaS）、技术支持或培训来赚钱。这就是经典的 <strong>“Open Core”（开源核心）</strong> 模式。</li><li><strong>科技巨头</strong>：通过开源来建立行业标准，降低整个生态的开发成本，从而更好地销售自己的云服务或硬件产品。</li></ul><p>没有可持续的收入来源，任何个体或组织都难以在漫长的岁月中持续投入巨大的研发和运维成本。<strong>“为爱发电”可以启动一个项目，但商业回报才能让它茁壮成长。</strong></p><p><strong>第二问：既然最终要收费，开源对客户有何实际意义？</strong></p><p><strong>答：开源为客户提供了“确定性与灵活性”，这是一种深层的商业价值。</strong></p><p>客户的核心诉求是“付钱解决问题”，这没错。但开源如何帮助客户更好地实现这一目标呢？</p><ol><li><strong>避免供应商锁定</strong>：如果软件是闭源的，客户就被牢牢绑定在单一供应商身上。对方可以随意提价、降低服务质量，客户却毫无还手之力。开源软件确保了客户<strong>永远拥有选择的自由</strong>。如果服务商A不满意，客户可以轻松切换到服务商B，甚至可以自己组织团队进行维护。</li><li><strong>供应链的确定性</strong>：开源代码是“不可撤回”的公共资产。这意味着，一旦客户基于某个开源版本构建了系统，就不会因为原公司倒闭、改变策略或停止更新而瞬间导致业务崩溃。这为企业的技术选型提供了<strong>最底层的安全感和确定性</strong>。</li><li><strong>透明与安全</strong>：代码可见意味着客户（或其委托的专家）可以自行审查安全性，确保没有隐藏的后门或致命漏洞。</li></ol><p>对于客户而言，开源并非一个虚无的口号，而是一个<strong>强大的议价工具和风险对冲工具</strong>。</p><p><strong>第三问：开源项目真的“人人平等”吗？为何总是少数人主导？</strong></p><p><strong>答：事实上的开源项目，尤其是成功的大型项目，几乎都是“精英治理”和“方法论专政”。</strong></p><p>观察GitHub上流行项目的提交图，我们会发现一个普遍现象：绝大部分代码贡献来自于极少数核心维护者。这并非偶然，而是由两个核心因素决定的：</p><ol><li><strong>能力的极端稀缺</strong>：主导一个流行的开源软件，需要主导者具备超凡的<strong>问题分析、架构抽象、模块拆解、社区治理和商业洞察</strong>等综合能力。这种“复合型天才”本身就是凤毛麟角。</li><li><strong>方法论的统一性</strong>：一个成功的开源软件，本质上是一套解决特定领域问题的、高度自洽的<strong>方法论的代码实践</strong>。项目的方向和架构，必须由这套方法论的创立者或核心理解者来把握，否则项目就会陷入混乱和分歧。</li></ol><p>因此，开源社区并非纯粹的民主制，而更像是“仁慈的独裁者”或“核心委员会”制度。这种集中式的决策机制，是保证项目在复杂性和规模增长中保持<strong>方向一致性和代码质量</strong>的关键。</p><p><strong>第四问：既然代码公开，开源作者不怕被竞争对手抄袭吗？</strong></p><p><strong>答：不怕。因为真正的护城河不是代码，而是“生态与方法论”。</strong></p><p>抄袭一个开源项目，看似简单，实则愚蠢。原因如下：</p><ul><li><strong>方法论之争</strong>：顶尖的竞争对手之间，往往存在着根本性的<strong>方法论分歧</strong>。让一个信奉A方法的团队，去全盘抄袭基于B方法构建的项目，无异于让其自我否定，这在技术和文化上都极其困难。</li><li><strong>生态系统的力量</strong>：一个成熟的开源项目，其价值远不止代码。它拥有庞大的用户社区、丰富的文档、海量的问答、成熟的工具链和认证的服务商。抄袭者能复制代码，但无法复制这整个<strong>活的生态系统</strong>。用户选择某个开源软件，正是因为信任这个生态带来的整体价值。</li><li><strong>分叉的代价</strong>：历史上，因社区内讧而“分叉”的项目很多，但能取代原项目成为新事实标准的，寥寥无几。分叉意味着社区分裂、资源分散，是一场伤筋动骨的“内战”。除非原主导层犯下致命错误且拒绝改正，否则分叉很难成功。</li></ul><p><strong>结论：开源——一场精心设计的“阳谋”</strong></p><p>经过以上层层剖析，我们可以清晰地看到，现代开源运动并非一场纯粹的理想主义盛宴，而是一套极其精妙的商业和社会协作模型。</p><p>它是一场“阳谋”：主导者光明正大地公开核心代码，通过吸引用户、构建生态、确立标准，最终在服务、支持和增值领域建立起难以撼动的护城河。在这个过程中，<strong>主导者实现了商业上的可持续回报，客户获得了自由和确定性，整个行业则因为知识的共享和协作而加速创新。</strong></p><p>这正是一种多赢的格局——开源，用开放的姿态，成就了最稳固的商业壁垒，并最终推动了整个数字世界的进步。它既是理想主义的火花，也是现实主义的选择，二者的结合，正是其强大生命力的源泉。</p>]]></description></item><item>    <title><![CDATA[步数运动宝 QQ 版本：步数变现 + 裂]]></title>    <link>https://segmentfault.com/a/1190000047400163</link>    <guid>https://segmentfault.com/a/1190000047400163</guid>    <pubDate>2025-11-14 17:10:49</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>步数运动宝 QQ 版本是一款适配微信、QQ、抖音等多平台的小程序系统，以 “运动步数” 为核心纽带，融合步数兑换、任务赚币、夺宝互动、商城购物等功能，既满足用户运动变现需求，又为商家提供爆炸式吸粉与营销转化解决方案，是兼具趣味性与商业价值的轻量化工具。</p><p><strong>一、概述总结</strong><br/>步数运动宝 QQ 版本通过将用户日常运动步数转化为可流通的 “活力币 / 步币”，构建起 “运动 - 赚币 - 兑换 - 分享” 的完整闭环。用户可通过签到、走步、看视频、邀请好友等方式积累虚拟货币，兑换现金红包、实物商品或参与夺宝活动；商家则借助步数砍价、邀请裂变、广告植入等功能实现快速吸粉、用户留存与收益增长。系统支持高度自定义配置，适配线上线下多场景营销，且提供微擎系统加密交付与持续更新服务，兼顾安全性与实用性。</p><p><strong>二、核心功能介绍</strong><br/>步数变现与兑换体系<br/>步数直接兑换活力币，支持微信现金红包、实物商品（如榨汁机、电影票）、虚拟道具（迷你币）等多类型兑换。</p><p>创新 “砍步数” 机制，用户可邀请好友助力减少兑换所需步数，强制裂变引流。</p><p>设置兑换门槛，可要求邀请指定数量新用户或完成特定任务，提升转化质量。</p><p>互动营销与夺宝玩法<br/>幸运转盘、运动币夺宝、免币夺宝三大互动模块，用户消耗步数或观看激励视频即可参与，奖品涵盖手机、现金红包等，增强用户粘性。</p><p>每日签到、答题闯关、试玩任务等领币渠道，丰富用户赚币路径，延长使用时长。</p><p>支持激励视频、插屏广告植入，为商家开辟额外创收途径。</p><p>裂变吸粉与用户运营<br/>邀请好友奖励机制，成功邀请可获得 3-10 活力币，部分商品兑换需邀请数十名新用户，实现粉丝几何级增长。</p><p>好友排行、全国榜单等社交互动功能，激发用户竞争与分享意愿。</p><p>支持关注公众号解锁提现、领取口令等功能，完成私域流量沉淀。</p><p>商城与线下核销功能<br/>内置步数换购商城，涵盖食品、美妆、电器等多品类商品，支持 “活力币兑换”“活力币 + 现金” 混合支付。</p><p>线上下单、到店自提模式，生成专属核销码，实现线上引流与线下实体交易的无缝衔接。</p><p>库存管理功能，支持每日限购与总计库存设置，灵活控制营销成本。</p><p>高度自定义配置<br/>导航栏、UI 界面、签到规则、红包金额、提现门槛等核心参数均可自定义，适配不同商家需求。</p><p>防撸羊毛机制内置，保障营销活动公平性，避免资源浪费。</p><p>支持第三方发货、关联店铺、商品分类管理等商家实用功能，简化运营流程。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>本地生活服务：餐饮、零售、影院、景区等线下门店，用于到店引流与到店核销。</p><p>电商平台：拼多多等电商渠道优惠券发放、商品促销，提升下单转化率。</p><p>品牌营销：需要快速积累用户的新品牌、新 APP，通过低成本裂变实现冷启动。</p><p>健身运动类产品：与运动场景深度绑定，提升用户活跃度与留存率。</p><p>公众号 / 自媒体：作为涨粉工具，快速积累私域流量，提升账号商业价值。</p><p>行业价值<br/>低成本吸粉：以步数为零成本载体，通过趣味玩法与实际奖励，实现单日数百甚至数万新用户增长，案例中商家单月吸粉超 50 万。</p><p>高用户粘性：将运动习惯与奖励激励结合，用户每日签到、走步、互动，形成稳定使用惯性。</p><p>多维度收益：融合商品销售、广告植入、线下引流转化等收益渠道，实现 “吸粉 - 留存 - 变现” 闭环。</p><p>线上线下融合：打通线上流量与线下实体交易，为实体店解决获客难问题，提升到店率。</p><p><strong>四、常见问题问答</strong><br/>问：用户如何获取活力币 / 步币？答：主要通过每日签到、运动步数兑换、邀请好友、观看激励视频、参与答题闯关或试玩任务等方式获取。</p><p>问：商家可以自定义哪些核心规则？答：可自定义兑换门槛、邀请好友数量要求、签到奖励金额、红包设置、提现规则、UI 界面、商品库存与限购数量等。</p><p>问：系统是否支持线下门店使用？</p><p>答：支持，用户线上下单后可选择到店自提，生成核销码后到店出示即可完成核销，实现线上引流线下消费。</p><p>问：购买后商家能获得哪些服务保障？</p><p>答：提供微擎系统在线交付，源码加密保障安全，服务周期内可免费更新，支持 PHP5.6、PHP7.1 运行环境，工作日 9:00-18:00 卖家服务支持。</p><p>问：“砍步数” 功能如何帮助商家吸粉？答：用户兑换部分商品时需邀请好友助力砍步数，好友需为新用户，且需贡献一定比例步数，强制触发社交分享，快速裂变新用户。</p>]]></description></item><item>    <title><![CDATA[智慧城市 O2O 分销系统：连接城市服务]]></title>    <link>https://segmentfault.com/a/1190000047400174</link>    <guid>https://segmentfault.com/a/1190000047400174</guid>    <pubDate>2025-11-14 17:09:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>智慧城市 O2O 分销系统是基于微擎系统开发的数字化工具，专注于智慧城市场景下的 O2O 业务分销需求。系统以在线交付为核心交付方式，提供未加密源码保障，确保官方正品品质，支持用户新购使用。它打破传统城市服务分销的地域与渠道限制，通过数字化手段搭建起高效的分销桥梁，助力相关主体快速布局智慧城市 O2O 业务，实现资源整合与高效流转。</p><p><strong>二、功能介绍</strong><br/>分销核心功能：适配智慧城市 O2O 场景，支持多渠道分销链路搭建，满足不同层级分销需求。</p><p>便捷交付体验：采用在线交付模式，购买后可快速获取系统，无需复杂线下流程，提升使用效率。</p><p>源码灵活优势：提供未加密源码，用户可根据自身业务需求进行二次开发与定制，适配个性化场景。</p><p>品质保障机制：依托官方正品保障，确保系统稳定性与安全性，减少使用过程中的技术风险。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>城市生活服务运营商：用于整合本地餐饮、家政、出行等生活服务资源，通过分销模式扩大服务覆盖范围。</p><p>智慧城市项目服务商：为智慧社区、智慧交通、智慧医疗等细分领域的项目，搭建分销渠道与推广网络。</p><p>区域商业运营主体：助力商圈、产业园区等实现线下资源线上化分销，打通服务触达用户的 “最后一公里”。</p><p>行业价值<br/>降低运营成本：数字化分销模式减少中间环节，降低渠道拓展与维护的人力、时间成本。</p><p>提升业务覆盖：打破地域限制，快速整合分散的城市服务资源，扩大业务辐射范围与市场份额。</p><p>增强灵活适配：未加密源码支持定制化开发，可根据不同智慧城市细分场景的需求调整功能，提升适配性。</p><p>保障合作信任：官方正品保障为合作双方提供安全背书，降低合作风险，提升业务推进效率。</p><p><strong>四、问答环节</strong><br/>问：该智慧城市 O2O 分销系统的交付方式是什么？</p><p>答：系统采用微擎在线交付方式，购买后可快速获取使用，无需线下交接流程。</p><p>问：系统源码是否支持二次开发？</p><p>答：支持。系统源码未加密，用户可根据自身业务需求进行二次开发与定制调整。</p><p>问：使用该系统能获得哪些品质保障？</p><p>答：系统提供官方正品保障，确保系统的稳定性、安全性与合规性，减少使用过程中的技术与合规风险。</p><p>问：该系统主要适配哪些业务场景？</p><p>答：主要适配智慧城市相关的 O2O 业务场景，包括城市生活服务分销、智慧社区项目推广、区域商业资源整合等。</p>]]></description></item><item>    <title><![CDATA[如何评估CRM软件是否适配长销售周期的业]]></title>    <link>https://segmentfault.com/a/1190000047400178</link>    <guid>https://segmentfault.com/a/1190000047400178</guid>    <pubDate>2025-11-14 17:09:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着企业业务的不断扩展，销售周期的长短已成为影响企业运营效率的重要因素。长销售周期通常指从客户初次接触到最终成交的整个过程较长，常见于专业服务、高端产品销售或高附加值行业。典型行业包括：咨询公司、汽车制造、房地产、医疗设备、教育服务等。这类业务往往需要更精细的客户管理、更复杂的销售流程和更高的客户关系维护效率。</p><p>本文将围绕<strong>CRM软件在长销售周期业务中的适配性</strong>，分析适合的CRM产品，并通过表格形式罗列5-6个产品，帮助用户在选择CRM时做出更明智的决策。</p><ul><li><ul><li>*</li></ul></li></ul><h2>一、长销售周期的业务特点</h2><p>在长销售周期的业务中，以下特点尤为突出：</p><ul><li><strong>客户关系复杂</strong>：客户可能经历多个阶段，涉及多个部门协作。</li><li><strong>销售流程长</strong>：从接洽到成交需要多轮沟通和审批。</li><li><strong>客户维护周期长</strong>：客户关系持续时间较长，需要持续的跟进和维护。</li><li><strong>数据管理复杂</strong>：涉及多环节数据，需整合和分析。</li></ul><p>因此，适合的CRM软件应具备以下功能：</p><ul><li>多角色协同管理</li><li>长周期销售流程支持</li><li>数据分析与预测功能</li><li>客户生命周期管理</li><li>高度可定制化</li></ul><h2>二、适合长销售周期的CRM产品分析</h2><p>以下为五款在长销售周期业务中表现突出的CRM产品：</p><table><thead><tr><th>序号</th><th>CRM产品名称</th><th>定位</th><th>特点</th><th>优势</th></tr></thead><tbody><tr><td>1</td><td><strong>八骏CRM</strong></td><td>国产企业级CRM</td><td>支持多角色协同、复杂销售流程、客户生命周期管理</td><td>个性化定制、强大的数据分析、多渠道整合</td></tr><tr><td>2</td><td><strong>Salesforce</strong></td><td>全球领先的CRM</td><td>云端部署、集成性强、数据可视化</td><td>灵活的销售流程配置、丰富的API、全球支持</td></tr><tr><td>3</td><td><strong>Salesforce Suite</strong></td><td>企业级CRM</td><td>包含Salesforce、Service Cloud、Marketing Cloud等模块</td><td>完整的客户旅程管理、多平台无缝集成</td></tr><tr><td>4</td><td><strong>HubSpot CRM</strong></td><td>企业级CRM</td><td>以营销为中心，支持客户旅程管理、数据分析</td><td>低门槛部署、易用性强、强大的营销功能</td></tr><tr><td>5</td><td><strong>Microsoft Dynamics 365</strong></td><td>企业级CRM</td><td>与Microsoft生态系统无缝集成，支持多角色协作</td><td>混合云部署、数据分析强大、流程自动化</td></tr><tr><td>6</td><td><strong>Pipedrive</strong></td><td>中端企业级CRM</td><td>以销售流程管理为主，适合长周期销售</td><td>简洁直观、流程可视化、自定义能力强</td></tr></tbody></table><h2>三、如何评估CRM软件是否适配长销售周期？</h2><p>在选择CRM软件时，需考虑以下几点：</p><ol><li><strong>业务流程的复杂性</strong>：CRM是否支持多角色协同和复杂销售流程？</li><li><strong>数据管理能力</strong>：是否能有效管理客户生命周期数据？</li><li><strong>数据分析与预测功能</strong>：是否提供数据分析和预测能力？</li><li><strong>可定制化与扩展性</strong>：是否能根据业务需求进行定制？</li><li><strong>技术支持与售后服务</strong>：是否有良好的技术支持和售后服务？</li></ol><h2>四、总结</h2><p>在长销售周期的业务中，CRM软件的选择至关重要。它不仅决定了销售效率，也影响客户关系的维护和企业整体运营。选择合适的CRM产品，应注重其<strong>流程管理、数据整合、数据分析、定制化能力</strong>等核心功能。</p><p>建议用户根据自身业务特点，结合实际需求和预算，综合评估CRM软件的适配性，以实现更高效的销售管理和客户关系维护。</p>]]></description></item><item>    <title><![CDATA[微商圈双 11 特惠模块：助力商户数字化]]></title>    <link>https://segmentfault.com/a/1190000047400181</link>    <guid>https://segmentfault.com/a/1190000047400181</guid>    <pubDate>2025-11-14 17:08:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、概述总结</strong><br/>微商圈双 11 狂欢节专属模块，活动时间覆盖 11 月 1 日至 11 月 18 日，带来官方直降 50% 的半价福利，叠加领券折上折优惠。该模块基于微擎系统在线交付，提供源码加密保护与官方正品保障，聚焦微商户数字化经营需求，整合多元实用功能，为商户打造低成本、高效能的线上经营解决方案。</p><p><strong>二、功能介绍</strong><br/>核心经营功能：涵盖微餐饮、微外卖、微点餐、微餐厅等核心场景功能，满足商户线上接单、点餐服务需求。</p><p>高效运营工具：配备排号功能，优化门店就餐秩序；支持码上点餐，提升顾客点餐效率，降低商户人力成本。</p><p>安全保障服务：源码已加密，保障商户经营数据安全；官方正品保障，确保模块稳定运行无后顾之忧。</p><p><strong>三、适用场景与行业价值</strong><br/>适用场景<br/>线下餐饮门店：包括快餐、正餐等各类餐饮商户，需拓展线上点餐、外卖渠道或优化店内排号、点餐流程。</p><p>本地生活商户：希望借助微商圈流量，通过数字化工具提升经营效率、扩大服务覆盖范围的中小商户。</p><p>行业价值<br/>降低经营成本：双 11 半价优惠，大幅降低商户数字化转型门槛，无需高额投入即可获取专业工具。</p><p>提升运营效率：码上点餐、在线排号等功能减少顾客等待时间，优化服务体验，同时减轻店员工作压力。</p><p>拓展经营渠道：整合微外卖、微点餐等线上功能，帮助商户打破线下经营局限，触达更多潜在客户。</p><p><strong>四、问答环节</strong><br/>问：该模块的活动时间是什么时候？</p><p>答：活动时间为 11 月 1 日至 11 月 18 日，期间可享受双 11 半价及领券折上折优惠。</p><p>问：模块的交付方式是什么？是否需要线下安装？</p><p>答：采用微擎系统在线交付，无需线下安装，购买后可直接在线使用。</p><p>问：新购用户需要支付费用吗？</p><p>答：当前新购价格为 0 元，叠加双 11 半价优惠，无需额外支付费用即可获取。</p><p>问：该模块适用于哪些类型的商户？</p><p>答：主要适用于微餐饮、快餐等餐饮类商户，也可满足需要线上点餐、排号、外卖功能的本地生活商户。</p>]]></description></item><item>    <title><![CDATA[AI 时代的产品管理 俞凡 ]]></title>    <link>https://segmentfault.com/a/1190000047400198</link>    <guid>https://segmentfault.com/a/1190000047400198</guid>    <pubDate>2025-11-14 17:07:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><em>本文介绍了在 GenAI 时代，产品管理仍然占据主导地位的原因，以及产品经理如何增强其能力以适合 AI 时代的到来。原文：<a href="https://link.segmentfault.com/?enc=Hg3w%2Bys5Bc%2FS6B%2F66wG58Q%3D%3D.t2B%2FCRzrBo0ogti3u91yYXSKR%2Bffpup2avMlHaI7e80m3gZIuVlC%2BiTmL9Kndc33W%2BMg%2Bk1mtvCAHZ0Wf9fq%2BCiOK%2FLW5nWVmVNQ25BbT0lKkgl%2Bcgsvg1Y1XCyjEGT6dicI73gehyWdAonoc6JlMQ%3D%3D" rel="nofollow" title="Fundamental Product Management: Why it’s more important in the AI Age" target="_blank">Fundamental Product Management: Why it’s more important in the AI Age</a></em></blockquote><p>生成式人工智能（GenAI）不断扩大其在众多行业的视野，使所有领域的产品经理（PM）都有机会成为专注于 AI 并且精通技术的人。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400200" alt="" title=""/></p><p>过去几年里，GenAI 变得极为流行。具备 AI 功能的产品在各个行业纷纷涌现，就像蒲公英一样四处播散，其发展速度几乎不受控制，而且似乎还有源源不断的风投资金为其提供持续的“阳光和水分”。</p><p>从产品管理角度来看，AI 在诸多方面能够提升 PM 的工作效率和专业领域知识水平。</p><p>话虽如此，本文旨在探讨为何基本的产品管理实践仍然占据主导地位，以及这些基本原理如何能让产品管理在 AI 领域脱颖而出。产品管理作为一种实践方式，是一项适用于所有产品开发领域的核心技能，无论其是否涉及 AI。</p><p>那么，无论是在哪个行业（即便不涉及 AI），基本 PM 技能为何如此重要呢？</p><p>以下是基础产品管理仍然重要的三个主要原因，以及一些切实可行的方法，这些方法能让 PM 在充满未知、不断发展的 AI 世界中真正取得成功。</p><h2>1. 产品开发过程太过复杂</h2><p>每次经验不足的 PM 仅仅通过理论来了解产品团队的运作方式时，都会认为产品开发其实并不那么复杂 —— 这是一种新手常犯的错误。</p><p>实际情况是，通常情况下，任何时候都会有数百个不同环节在运作。这些环节可能包括基于团队的依赖关系、销售和营销支持、由海外团队负责的内部工具、需要更新的数据传输，或者那些对上述所有方面都有影响的小任务和职责。</p><p>PM 这一职位之所以特殊，是因为需要能够识别并管理那些隐藏的、不断变化的要素。他们是那种无论需要付出何种努力，都要竭尽全力助力产品发展与交付的超级英雄。在工作中，这种能力比成为团队中最顶尖的 AI 专家更为重要（尽管成为顶尖的 AI 专家也是好事！）</p><p>最近，我受邀前往位于温哥华的 Maximizer CRM 公司总部，就 AI 助手领域发表演讲。在演讲中，我阐述了全球 GenAI 市场规模从 2023 年的 500 亿美元增长至 2024 年的 1840 亿美元这一情况。演讲结束后，我被众多关于如何真正采用 AI 以改进产品开发流程的问题所包围。他们的担忧与我一致：鉴于产品开发的复杂性，采用像 Github Copilot 这样的工具真的能加快工作速度吗？我的回答始终围绕着基本要点：PM 需要保持强大的产品文化，以确保无论 AI 的采用多么复杂，都能顺利进行。</p><p>在产品开发领域，还有一点需要留意的是技术变化的速度，这一速度已经大幅加快。如果团队试图在产品中运用 GenAI，那么技术变化的速度可能会更快。AI 的能力发展迅速，有时甚至每周都会有所变化，因此 PM 必须坚守永恒的原则：理解用户需求、明确问题并提供实际价值。如果没有这些基本原则，团队可能会追逐 AI 的能力而未能解决客户的问题，这可能会导致项目失败。</p><p>GenAI 现在能够自动执行特定任务和流程，但其在成本、针对性和细微差别方面存在局限。具备深厚基础知识的真正人类 PM 会知道如何在拥有 AI 工具支持的产品团队中迅速发挥作用，并懂得如何协调所有推动项目向前发展的关键要素。这些要素可能包括：</p><ul><li><em>了解一天中最重要的 5 到 10 项事务（从 100 项中筛选得出）</em></li><li><em>明白哪些事项需要优先处理，哪些可以放低优先级</em></li><li><em>学会何时拒绝</em></li><li><em>利用电子邮件 AI 工具来过滤掉干扰信息</em></li><li><em>挑选出可以实现自动化或削减的领域或流程</em></li></ul><h2>2. 产品基础涉及人际交往能力，而 AI 无法取代。</h2><p>尽管这听起来可能有些讽刺，但随着 AI 产品开发的复杂性不断增加（这是必然趋势！），PM 在团队中展现出出色的人际交往能力就变得愈发重要了。</p><p>我坚信，强大的利益相关者管理是一项任何 PM 都绝不能放弃的关键要素，无论其技术有多么先进。大多数 PM 都会与各种各样的团队合作（比如：前端和后端开发人员、数据科学家、设计师、市场营销人员、销售人员、管理人员以及外部利益相关者）。你会依靠 GenAI 来切换情境并根据特定受众调整演示内容，还是会依靠自己强大的人际交往能力来推进这一工作呢？</p><p>用户访谈、客户关系管理、利益相关者管理，以及与产品团队就诸如功能优先级等问题进行的讨论，都应当依靠人际交往能力来推动，比如：</p><ul><li>了解社会动态，并且要友善、体贴，最重要的是要易于与工程师们合作</li><li>在无需权威的情况下发挥领导和影响力，通过倾听同事的意见并表明自己理解他们的观点（即便自己可能不同意）来实现这一点</li><li>在用户和客户访谈中表现出同理心，以便真正了解他们在使用产品时的感受和经历</li></ul><p>若想了解 PM 在长期职业生涯中应培养的重要人际交往和软技能，可以参考 PM 练习网站上的这篇文章：<a href="https://link.segmentfault.com/?enc=LBcEQ4mDUmhG1SaHjhKUxg%3D%3D.uR8AmoCXds3%2BLXT3FkM4R%2F2nJW%2FimGDIA3ALuG73kpANK%2FsS0qWZuy8IILH33d4ALYbtOIZi2LddZMWhyVe%2F87K4naH6%2B9U%2BShnqkiWTfh1CHaz%2FQt5beOpylRNr%2BlcL" rel="nofollow" title="https://www.productmanagementexercises.com/blog/6-soft-skills-every-product-manager-needs" target="_blank">https://www.productmanagementexercises.com/blog/6-soft-skills-every-product-manager-needs</a></p><h2>3. 产品基础概念有助于 PM 理解垂直应用场景</h2><p>垂直应用场景与传统应用场景在侧重点上有所不同。传统应用场景范围更广，可以涵盖任何类型的任务、JTBD（待完成任务，job to be done）或客户/用户试图达成的目标。而垂直应用场景只是更广泛的应用场景定义的一个子集，专注于更狭窄和特定的任务。</p><p>在 GenAI 的世界里，我们有所谓 <em>AI 代理</em>。AI 代理是独立的由语言模型驱动的 AI 组件，负责完成一项或一组特定任务。例如，在微软 Copilot 中，某个特定的 AI 代理可以是微软 Word 的摘要生成代理，其中语言模型被配置为仅分析 Word 文档中的内容，然后为用户生成摘要。与关注所有事情不同，该代理仅专注于以更专注的方式完成其特定应用场景。</p><p>这就引出了“垂直型 AI 代理”这一话题 —— 这其实只是对一种特定类型 AI 代理的形象化描述，即这种代理能够比更通用的 AI 代理或助手更好的完成某个特定任务或应用场景。</p><p>自 2022 年 GenAI 兴起以来，垂直 AI 市场迅速扩张，并有望达到创纪录的市场估值。据 <a href="https://link.segmentfault.com/?enc=ZsMc52bDiUCxeAlDGSxwVg%3D%3D.mUmJ0gOf1digFP09SK4sMmkTsTCEM5RLRKinLAvtGj5gleVtfpVm%2FeHPHnxx2sWURLcDnjUhc7dMROUGTTYoxh7t6gF3ykMO17HWlaZvDUY%3D" rel="nofollow" title="AIM 研究公司" target="_blank">AIM 研究公司</a>称，2024 年垂直 AI 市场规模为 51 亿美元，预计到 2030 年将增长至 471 亿美元，这一增长幅度令人惊叹。</p><p>PM 们理应引领这一增长趋势，他们需要找出每个垂直领域的应用场景，并确定每个垂直领域的智能代理都能成为该领域的专家。但要如何才能发现这些有价值的垂直应用场景呢？</p><p>我想分享一个专业方面的趣闻，那就是我们在 Planview 公司的工作经历以及所做的持续探索工作，以验证客户的垂直应用场景。在推出 <a href="https://link.segmentfault.com/?enc=r0bDFTdLONjSh5%2FPwxxdhg%3D%3D.byn8XutDFLyFL3hsLSWQZ%2BPaPKQ%2BN5LD%2Fjap1uAddRY%3D" rel="nofollow" title="Planview 公司的 AI 助手 Planview Copilot" target="_blank">Planview 公司的 AI 助手 Planview Copilot</a> 之后，团队很快发现，我们的客户群体根本不清楚能带来什么好处，而且潜在的应用场景范围广泛且各不相同。</p><p>作为 Planview Copilot 的产品经理，我选择了几个具体用例来启动产品 MVP，并以此作为假设，然后通过反馈电话和数据监测与客户进行互动，以验证这些用例是否对他们有用。在这一年里，我持续采用快速失败方法，直到某些东西引起客户共鸣：一系列基于 AI 的用例，真正为他们的日常工作流程带来了价值。对我们来说，基本实践是取得这一成功的关键，这就是为什么垂直 AI 代理市场将充满成长的烦恼和令人兴奋的活力，因为越来越多的公司开始像 Planview Copilot 那样发现这些垂直用例。</p><p>基本产品管理实践 —— 涵盖产品管理存在的根本原因的技能 —— 将是解决方案。例如，产品发现、用例优先级排序、客户关系以及反馈整合。PM 被雇用是为了在 GenAI 的世界中发现那些垂直用例，然后制定策略并兑现承诺。</p><p>我建议 PM 们继续做到以下几点：</p><ul><li>探索最常见但又极具创新性的产品及使用案例发现方法</li><li>通过不同方式激发思维，对需要解决的问题进行优先排序</li><li>深入研究 GenAI 市场，以预测变化、理解客户问题并识别其产品可能解决的核心差距</li></ul><h2>结论</h2><p>希望我已经阐明了产品管理基本原则的永恒重要性，即便在数字化 AI 时代也是如此。我相信，随着 PM 们继续分享最佳实践，并改进他们的工作流程和框架，GenAI 市场将继续提升其为客户带来的价值。其真正的影响将体现在工作效率、时间节省、娱乐以及生活质量等方面。</p><hr/><blockquote>你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。为了方便大家以后能第一时间看到文章，请朋友们关注公众号"DeepNoMind"，并设个星标吧，如果能一键三连(转发、点赞、在看)，则能给我带来更多的支持和动力，激励我持续写下去，和大家共同成长进步！</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=3vOLfhZDpw9Ik%2F7IPZDnuA%3D%3D.b5leFCwZ2RRFUP084P2FPyszHG2vrfXGoOyRf06HdMA%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[《ESP32-S3使用指南—IDF版 V]]></title>    <link>https://segmentfault.com/a/1190000047400220</link>    <guid>https://segmentfault.com/a/1190000047400220</guid>    <pubDate>2025-11-14 17:07:02</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>第四十七章 lwIP初探</h2><p>ESP32-S3是一款集成了Wi-Fi和蓝牙功能的微控制器，而lwIP（轻量级IP）是一个为嵌入式系统设计的开源TCP/IP协议栈。通过使用lwIP库，ESP32-S3可以实现与外部网络的通信，包括发送和接收数据包、处理网络连接等。因此，ESP32-S3是基于lwIP来实现网络功能的。<br/>章将分为如下几个部分：<br/>47.1 TCP/IP协议栈是什么<br/>47.2 lwIP简介<br/>47.3 WiFi MAC内核简介<br/>47.4 lwIP Socket编程接口</p><h3><strong>47.1 TCP/IP协议栈是什么</strong></h3><p>TCP/IP协议栈是一系列网络协议的总和，构成网络通信的核心骨架，定义了电子设备如何连入因特网以及数据如何在它们之间进行传输。该协议采用4层结构，分别是应用层、传输层、网络层和网络接口层，每一层都使用下一层提供的协议来完成自己的需求。由于大部分时间都在应用层工作，下层的事情不用操心。此外，网络协议体系本身很复杂庞大，入门门槛高，因此很难搞清楚TCP/IP的工作原理。如果读者想深入了解TCP/IP协议栈的工作原理，建议阅读《计算机网络书籍》。</p><h4>47.1.1 TCP/IP协议栈架构</h4><p>TCP/IP协议栈是一个分层结构的模型，每一层负责不同的网络功能。整个协议栈可以被分为四层，从上到下分别是：应用层、传输层、网络层和网络接口层。<br/>1，应用层：这是最顶层，负责处理特定的应用程序细节。在这一层，用户的数据被处理和解释。一些常见的应用层协议包括HTTP、FTP、SMTP和DNS等。<br/>2，传输层：这一层负责数据包的分割、打包以及传输控制，确保数据能够可靠、有序地到达目的地。主要的传输层协议有TCP和UDP。<br/>3，网络层：负责确定数据包的路径从源到目的地。这一层的主要协议是IP（InternetProtocol），它负责在主机之间发送和接收数据包。<br/>4，网络接口层：这是最底层，负责将数据转换为可以在物理媒介上发送的信号。这一层的协议涉及到如何将数据帧封装在数据链路层，以便在网络上进行传输。<br/>每一层都使用下一层提供的服务，同时对上一层提供服务。这种分层结构使得协议栈更加灵活，易于扩展和维护。不同层次上的协议一起工作，协调数据在计算机网络中的传输，使得不同的计算机能够相互通信。<br/>需要注意的是，TCP/IP协议栈和传统的OSI模型并不完全对应。TCP/IP协议栈是一个简化的模型，强调了实际的协议实现和因特网的实际运作方式。相比之下，OSI模型更加全面和理想化，它提供了一个框架来描述不同系统之间的交互方式。下图是IOS协议栈与TCP/IP协议栈分层架构的对比图。<br/><img width="434" height="242" referrerpolicy="no-referrer" src="/img/bVdmXK5" alt="" title=""/><br/>图47.1.1.1TCP/IP协议栈的分层结构<br/>ISO/OSI分层模型也是一个分层结构，包括七个层次，从上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。虽然ISO/OSI模型为不同的系统之间的通信提供了一个理论框架，但TCP/IP协议栈更侧重于实际的协议实现和因特网的实际运作方式。注意：网络技术的发展并不是遵循严格的ISO/OSI分层概念。实际上现在的互联网使用的是TCP/IP体系结构，有时已经演变成为图1.1.1.2所示那样，即某些应用程序可以直接使用IP层，或甚至直接使用最下面的网络接口层。<br/><img width="280" height="223" referrerpolicy="no-referrer" src="/img/bVdmXK6" alt="" title="" loading="lazy"/><br/>图47.1.1.2TCP/IP体系结构另一种表示方法<br/>无论那种表示方法，TCP/IP模型各个层次都分别对应于不同的协议。TCP/IP协议栈负责确保网络设备之间能够通信。它是一组规则，规定了信息如何在网络中传输。其中，这些协议都分布在应用层，传输层和网络层，网络接口层是由硬件来实现。如Windows操作系统包含了CBISC协议栈，该协议栈就是实现了TCP/IP协议栈的应用层，传输层和网络层的功能，网络接口层由网卡实现，所以CBISC协议栈和网卡构建了网络通信的核心骨架。因此，无论哪一款以太网产品，都必须符合TCP/IP体系结构，才能实现网络通信。注意：路由器和交换机等相关网络设备只实现网络层和网络接口层的功能。</p><h4>47.1.2 TCP/IP协议栈的封包和拆包</h4><p>TCP/IP协议栈的封包和拆包是指在网络通信中，将数据按照一定的协议和格式进行封装和解析的过程。<br/>在TCP/IP协议栈中，数据封装是指在发送端将数据按照协议规定的格式进行打包，以便在网络中进行传输。在应用层的数据被封装后，会经过传输层、网络层和网络接口层的处理，最终转换成可以在物理网络上传输的帧格式。数据封装的过程涉及到对数据的分段、压缩、加密等操作，以确保数据能够可靠、安全地传输到目的地，下图描述的是封包处理流程。<br/><img width="530" height="175" referrerpolicy="no-referrer" src="/img/bVdmXK9" alt="" title="" loading="lazy"/><br/>图47.1.2.1 TCP/IP协议栈的封包<br/>数据拆包是指接收端收到数据后，按照协议规定的格式对数据进行解析和处理，还原出原始的数据。在接收到数据后，接收端会按照协议规定的层次从下往上逐层处理数据，最终将应用层的数据还原出来。数据拆包的过程涉及到对数据的重组、解压缩、解密等操作，以确保数据能够被正确地解析和处理，下图描述的是拆包处理流程。<br/><img width="482" height="165" referrerpolicy="no-referrer" src="/img/bVdmXLa" alt="" title="" loading="lazy"/><br/>图47.1.2.2 TCP/IP协议栈的拆包<br/>需要注意的是，TCP/IP协议栈的封包和拆包过程涉及到多个层次和协议的处理，需要按照协议规定的格式和顺序进行操作。在实际应用中，需要根据具体的情况选择合适的协议和格式来满足不同的需求。同时，为了保证数据的安全和可靠性，还需要采取相应的加密、压缩等措施，以避免数据被篡改或损坏</p><h3>47.2 lwIP简介</h3><p>lwIP，全称为LightweightIP协议，是一种专为嵌入式系统设计的轻量级TCP/IP协议栈。它可以在无操作系统或带操作系统环境下运行，支持多线程或无线程，适用于8位和32位微处理器，同时兼容大端和小端系统。它的设计核心理念在于保持TCP/IP协议的主要功能同时尽量减少对RAM的占用。这意味着，尽管它的体积小巧，但它能够实现完整的TCP/IP通信功能。通常，lwIP只需十几KB的RAM和大约40K的ROM即可运行，使其成为资源受限的嵌入式系统的理想选择。lwIP的灵活性使其既可以在无操作系统环境下工作，也可以与各种操作系统配合使用。这为开发者提供了更大的自由度，可以根据具体的应用需求和硬件配置进行优化。无论是在云台接入、无线网关、远程模块还是工控控制器等场景中，lwIP都能提供强大的网络支持。<br/><strong>一、lwIP特性参数</strong><br/>lwIP的各项特性，如下表所示：<br/><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdmXLf" alt="" title="" loading="lazy"/><br/>表47.2.1lwIP基本特性<br/><strong>二、lwIP与TCP/IP体系结构的对应关系</strong><br/><img width="482" height="281" referrerpolicy="no-referrer" src="/img/bVdmXLb" alt="" title="" loading="lazy"/><br/>图 47.2.1 lwIP与TCP/IP体系结构的对应图解<br/>从上图可以清晰地看到，lwIP软件库主要实现了TCP/IP体系结构中的三个层次：应用层、传输层和网络层。这些层次共同处理和传输数据包，确保了数据在网络中的可靠传输。然而，网络接口层作为TCP/IP协议栈的最底层，其功能并无法通过软件方式完全实现。这一层的主要任务是将数据包转换为光电模拟信号，以便能够在物理媒介上传输。这个过程涉及到与硬件的直接交互，包括数据的调制解调、信号的转换等，这些都是软件难以模拟或实现的。因此，虽然lwIP软件库没有实现网络接口层的功能，但通过与底层硬件的紧密配合，它仍然能够提供完整且高效的TCP/IP通信功能。这也使得lwIP成为一个适用于资源受限的嵌入式系统的理想选择。<br/>在开发过程中，开发者需要根据具体的硬件平台和需求进行相应的配置和优化，以确保lwIP能够与硬件完美配合，发挥出最佳的性能。</p><h3>47.3 WiFi MAC内核简介</h3><p>ESP32-S3 完全遵循802.11b/g/n Wi-Fi MAC协议栈，支持分布式控制功能（DCF）下的基本服务集（BSS）STA和SoftAP操作。支持通过最小化主机交互来优化有效工作时长，以实现功耗管理。ESP32-S3 Wi-Fi MAC支持4个虚拟Wi-Fi接口，同时支持基础结构型网络、SoftAP模式和Station+SoftAP混杂模式。它还具备RTS保护、CTS保护、立即块确认、分片和重组、TX/RX A-MPDU和TX/RX A-MSDU等高级功能。此外，ESP32-S3还支持无线多媒体、GCMP、CCMP、TKIP、WAPI等安全协议，并提供自动Beacon监测和802.11mc FTM支持。<br/>关于ESP32的WiFi MAC内核，官方没有提供更多学习资料。读者只需了解它扮演TCP/IP协议的网络接口层角色即可。下面作者使用一张示意图来介绍WiFi通讯示意图，如下图所示。<br/><img width="543" height="340" referrerpolicy="no-referrer" src="/img/bVdmXLe" alt="     " title="     " loading="lazy"/><br/>图47.3.1 ESP32-S3网络层次示意图<br/>从上图可以看出，ESP32-S3芯片内置WiFi MAC内核。当我们发送数据到网络时，数据首先被转化为无线信号，然后发送到该设备连接的WiFi路由器中。接着，路由器通过网线将数据传输到目标主机，从而完成数据传输操作。以下是作者对于无线网络传输的描述。<br/>1，数据转化为无线信号：当ESP32-S3想要发送数据到网络时，它首先会将数据封装到一个无线传输帧中。这一过程涉及到将数据转化为可以在无线介质上传输的格式。<br/>2，发送到WiFi路由器：封装后的无线信号然后被发送到ESP32-S3连接的WiFi路由器。WiFi路由器充当一个中间设备，负责将无线信号转换为有线网络信号（如果目标主机是通过有线网络连接的）或直接转发无线信号（如果目标主机也是通过WiFi连接的）。<br/>3，路由器传输数据：WiFi路由器接收到无线信号后，会进一步处理它。如果目标主机是通过有线网络连接的，路由器会将无线信号转换为有线网络信号，并通过网线将其传输到目标主机。如果目标主机也是通过WiFi连接的，路由器会直接转发无线信号到目标主机。<br/>4，完成数据传输：最终，目标主机接收到路由器发送的有线网络信号或无线信号，并将其解析为原始数据。这样，整个数据传输过程就完成了。<br/>在整个过程中，ESP32-S3的WiFi MAC内核起着核心的作用，它负责管理无线连接、封装和解封装数据以及与WiFi路由器进行通信。</p><h3>47.4 lwIP Socket编程接口</h3><p>lwIP作者为了方便开发者将其他平台上的网络应用程序移植到lwIP上，并让更多开发者快速上手lwIP，作者设计了三种应用程序编程接口：RAW编程接口、NETCONN编程接口和Socket编程接口。然而，由于RAW编程接口只能在无操作系统环境下运行，因此对于内嵌FreeRTOS操作系统的ESP32来说，无法使用这个编程接口。尽管Socket编程接口是由NETCONN编程接口封装而成，但是该接口非常简易的实现网络连接（作者推荐使用此接口）。需要注意的是，由于受到嵌入式处理器资源和性能的限制，部分Socket接口并未在lwIP中完全实现。因此，为了实现网络连接，推荐使用Socket API。<br/>下面作者简单介绍一下lwIP Socket编程接口常用的API函数。这些API函数如下所示。<br/>(1) socket函数<br/>该函数的原型，如下源码所示：</p><pre><code>#define socket(domain,type,protocol)         lwip_socket(domain,type,protocol)</code></pre><p>向内核申请一个套接字，本质上该函数调用了函数lwip_socket，该函数的参数如下表所示：<br/><img width="723" height="319" referrerpolicy="no-referrer" src="/img/bVdmXLg" alt="" title="" loading="lazy"/><br/>表47.4.1函数Socket()相关形成描述<br/>(2) bind函数<br/>该函数的原型，如下源码所示：</p><pre><code>#define bind(s,name,namelen)      lwip_bind(s,name,namelen)
int bind(int s, const struct sockaddr *name, socklen_t namelen)
</code></pre><p>该函数与netconn_bind函数一样，用于服务器端绑定套接字与网卡信息，本质上就是对函数netconn_bind再一次封装，从上述源码可以知道参数name指向一个sockaddr结构体，它包含了本地IP地址和端口号等信息；参数namelen指出结构体的长度。结构体sockaddr定义如下源码所示：</p><pre><code>struct sockaddr {
u8_t        sa_len;             /* 长度 */
sa_family_t sa_family;        /* 协议簇 */
  char        sa_data[14];       /* 连续的 14 字节信息 */
};
struct sockaddr_in {
  u8_tsin_len;             /* 长度 */
  u8_tsin_family;              /* 协议簇 */
  u16_tsin_port;               /* 端口号 */
  struct in_addr sin_addr;      /* IP地址 */
  char sin_zero[8];
};</code></pre><p>可以看出，lwIP作者定义了两个结构体，结构体sockaddr中的sa_family指向该套接字所使用的协议簇，本地IP地址和端口号等信息在sa_data数组里面定义，这里暂未用到。由于sa_data以连续空间的方式存在，所以用户要填写其中的IP字段和端口port字段，这样会比较麻烦，因此lwIP定义了另一个结构体sockaddr_in，它与sockaddr结构对等，只是从中抽出IP地址和端口号port，方便于用于的编程操作。<br/>(3) connect函数<br/>该函数与netconn接口的netconn_connect函数作用是一样的，因此它是被netconn_connect函数封装了，该函数的作用是将Socket与远程IP地址和端口号绑定，如果开发板作为客户端，通常使用这个函数来绑定服务器的IP地址和端口号，对于TCP连接，调用这个函数会使客户端与服务器之间发生连接握手过程，并建立稳定的连接；如果是UDP连接，该函数调用不会有任何数据包被发送，只是在连接结构中记录下服务器的地址信息。当调用成功时，函数返回0；否则返回-1。该函数的原型如下源码所示：</p><pre><code>#define connect(s,name,namelen)    lwip_connect(s,name,namelen)
int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen);</code></pre><p>(4) listen函数<br/>该函数和netconn的函数netconn_listen作用一样，它是由函数netconn_listen封装得来的，内核同时接收到多个连接请求时，需要对这些请求进行排队处理，参数backlog指明了该套接字上连接请求队列的最大长度。当调用成功时，函数返回0；否则返回-1。该函数的原型如下源码所示：</p><pre><code>#define listen(s,backlog)   lwip_listen(s,backlog)
int lwip_listen(int s, int backlog);</code></pre><p>注意：该函数作用于TCP服务器程序。<br/>(5) accept函数<br/>该函数与netconn_accept作用是一样的，当接收到新连接后，连接另一端（客户端）的地址信息会被填入到地址结构addr中，而对应地址信息的长度被记录到addrlen中。函数返回新连接的套接字描述符，若调用失败，函数返回-1。该函数的原型如下源码所示：</p><pre><code>#define accept(s,addr,addrlen)     lwip_accept(s,addr,addrlen)
int lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p>注意：该函数作用于TCP服务器程序。<br/>(6) send()/sendto()函数<br/>该函数是被netconn_send封装的，其作用是向另一端发送UDP报文，这两个函数的原型如下源码所示：</p><pre><code>#define send(s,dataptr,size,flags)    lwip_send(s,dataptr,size,flags)
#definesendto(s,dataptr,size,flags,to,tolen)   lwip_sendto(s,dataptr,size,flags,to,tolen)
ssize_t lwip_send(int s, const void *dataptr, size_t size, int flags);
ssize_t lwip_sendto(int s, const void *dataptr, size_t size, int flags,   
const struct sockaddr *to, socklen_t tolen);</code></pre><p>可以看出，函数sendto比函数send多了两个参数，该函数如下表所示：<br/><img width="723" height="206" referrerpolicy="no-referrer" src="/img/bVdmXLh" alt="" title="" loading="lazy"/><br/>表47.4.2 函数sendto()和send()形参描述<br/>(7) write函数<br/>该函数用于在一条已经建立的连接上发送数据，通常使用在TCP程序中，但在UDP程序中也能使用。该函数本质上是基于前面介绍的send函数来实现的，其参数的意义与send也相同。当函数调用成功时，返回成功发送的字节数；否则返回-1。<br/>(8) read()/recv()/recvfrom()函数<br/>函数recvfrom和recv用来从一个套接字中接收数据，该函数可以在UDP程序使用，也可在TCP程序中使用。该函数本质上是被函数netconn_recv的封装，其参数与函数sendto的参数完全相似，如下表所示，数据发送方的地址信息会被填写到from中，fromlen指明了缓存from的长度；mem和len分别记录了接收数据的缓存起始地址和缓存长度，flags指明用户控制接收的方式，通常设置为0。两个函数的原型如下源码所示：</p><pre><code>#define recv(s,mem,len,flags)       lwip_recv(s,mem,len,flags)
#definerecvfrom(s,mem,len,flags,from,fromlen)  lwip_recvfrom(s,mem,len,flags,from,fromlen)
ssize_t lwip_readv(int s, const struct iovec *iov, int iovcnt);
ssize_t lwip_recvfrom(int s, void *mem, size_t len, int flags,
                          struct sockaddr *from, socklen_t *fromlen);
#define read(s,mem,len) lwip_read(s,mem,len)
ssize_t lwip_read(
int s,
void *mem, size_t len);</code></pre><p><img width="723" height="216" referrerpolicy="no-referrer" src="/img/bVdmXLi" alt="" title="" loading="lazy"/><br/>表47.4.3 函数recv()和recvfrom()形参描述<br/>(9) close函数<br/>函数close作用是关闭套接字，对应的套接字描述符不再有效，与描述符对应的内核结构lwip_socket也将被全部复位。该函数本质上是被netconn_delete的封装，对于TCP连接来说，该函数将导致断开握手过程的发生。若调用成功，该函数返回0；否则返回-1。该函数的原型如下源码所示：</p><pre><code>#define close(s)     lwip_close(s)
int lwip_close(int s);</code></pre>]]></description></item><item>    <title><![CDATA[如何用数据驱动与智能调控玩转点焊质量管理]]></title>    <link>https://segmentfault.com/a/1190000047400255</link>    <guid>https://segmentfault.com/a/1190000047400255</guid>    <pubDate>2025-11-14 17:06:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>点焊，听起来像是产线上最“硬核”的工艺环节之一，但它恰恰是现代制造质量管控中最值得“啃”的硬骨头。尤其在汽车焊接、家电钣金连接等场景中，一个焊点的质量不仅牵涉到结构强度，更直接关联整车安全性与产品生命周期。然而，传统依赖老师傅经验、间歇性抽检的管理方式，显然已难以应对高速、多品种、小批次的柔性制造需求——数据化、实时化、智能化，才是真正提升点焊质量的新引擎。<br/>当前的点焊质量管理，痛点非常明确：虚焊、过烧、焊核尺寸不稳定等问题往往无法实时识别，等到后期整装甚至终端使用时才发现，代价已是数十倍甚至百倍的返修与品牌损耗。要系统化解构这一问题，就不得不引入工业物联网（IIoT）架构与边缘智能。通过在焊枪上部署高精度电流/电压传感器、压力检测模块和热电偶，实时采集每一次点焊的完整参数序列，再借助机器学习算法建立动态质量预测模型，我们完全可以在焊接发生后的毫秒之间做出质量判决与工艺反馈。<br/>以某工厂采用广域铭岛点焊质量优化系统为例，该系统集成了各品牌焊机过程数据、破解、涡流、复检抽检数据，集成业务规则、实现数据分析、问题报警、问题管理等，通过算法实现了质量判定、飞溅率管理、参数推荐等功能。焊接合格率提升0.5%，焊接批量问题0次，减少人员8万元/年，减少沟通时间、数据查询、数据分析，问题管理跟踪时间，节约人天费用18.86万元/年<br/>家电行业同样从中尝到“甜头”。某家电巨头在洗衣机内筒焊接产线中接入了工艺质量管理平台，通过对多台焊机协同数据的整合分析，系统能够自动识别因电网波动或电极帽磨损导致的能量输出异常，并实时微调焊接参数或发出预警提示。结果产线虚焊率下降40%以上，客户投诉率大幅降低，工程师也从频繁的人工点检中解放出来，转向更高价值的工艺分析与优化。<br/>当然，落地这类系统也并非毫无挑战。多源异构数据的低延迟融合、高并发实时处理、工艺-质量映射模型的精准训练，以及既懂焊接工艺又熟悉数据算法的跨职能人才，都是推进智能化管理中必须打通的“堵点”。正因如此，一批优秀的工业互联网平台如广域铭岛，开始提供从数据采集、边缘计算到云平台分析的一体化点焊质量管理方案，帮助企业低门槛部署全流程质量管控能力。<br/>未来，随着5G和算力网络在工业场景的普及，点焊质量优化将进一步走向预测性调控和工艺数字孪生。系统不仅可以实时干预，更可基于历史与实时数据模拟不同材料、不同工况下的焊接结果，自主生成工艺参数库甚至支持无人化决策。毫无疑问，拥抱智能化质量管理，已逐渐成为制造企业能否在产业升级中占据话语权的关键赛点。</p>]]></description></item><item>    <title><![CDATA[提升流式开发效率与易用性：Kitex/H]]></title>    <link>https://segmentfault.com/a/1190000047400285</link>    <guid>https://segmentfault.com/a/1190000047400285</guid>    <pubDate>2025-11-14 17:05:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>CloudWeGo 作为字节跳动开源的高性能微服务框架体系，核心组件 Kitex 与 Hertz 以其原生的流式处理能力，已成为大模型应用开发的核心技术支撑。两者通过 SSE、gRPC 及自研 TTHeader Streaming 等多协议适配，完美契合大模型 "一问多答" 的交互需求，广泛应用于 Chat、语音交互等各类大模型场景。</p><p>本文基于 Kitex / Hertz 项目 Maintainer 王宇轩在 CloudWeGo 四周年技术沙龙演讲内容整理，系统阐述过去一年里 CloudWeGo 开源的微服务框架 Kitex 和 Hertz，如何提升流式开发效率与易用性，为大模型应用保驾护航。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400287" alt="" title=""/><br/>图为 Kitex / Hertz 项目 Maintainer 王宇轩</p><p><strong>一、大模型应用框架概览：流式能力与经典链路</strong></p><p>随着大模型应用的快速发展，微服务架构已成为其核心支撑模式，而 CloudWeGo 开源的 Kitex 与 Hertz 两大微服务框架，通过原生流式能力为大模型应用提供了关键技术支撑。</p><p>Kitex 与 Hertz 紧跟技术趋势，针对大模型交互场景提供了流式处理能力，以帮助用户高效构建应用：Hertz 支持 SSE 协议，负责与端上直接交互；Kitex Streaming 则支持广为人知的 gRPC 协议及自研流式协议 TTHeader Streaming，专注处理服务间的流式通信，两者均能完美适配大模型"一问多答"交互模式。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400288" alt="" title="" loading="lazy"/></p><p>在微服务架构中，基于 Kitex 与 Hertz 的大模型应用链路具备清晰的逻辑架构，以经典 Chat 场景为例，API 服务、Chat 服务与 LLM 通过流式接口实现串联，最终达成一问多答的交互效果：</p><ul><li>API 服务通过 SSE 接口与端上交互，借助 Kitex 流式 Client 访问 Chat 服务；</li><li>LLM 根据部署环境差异，灵活暴露 SSE 接口或 RPC 流式接口，Chat 服务对应使用 SSE Client 或 Kitex 流式 Client 对接。</li></ul><p>该架构设计满足了大模型应用的交互需求，逻辑清晰流畅。但在实际开发落地过程中，流式能力所带来的工程实践问题接踵而至。</p><p><strong>二、流式工程实践增强：保障应用稳定落地</strong></p><p>为应对大模型应用在流式开发中遇到的实际挑战，服务框架团队围绕会话中断、流式异常与流式监控这三个核心场景，对 Kitex 和 Hertz 的流式工程实践进行了强化，全方位保障应用的稳定运行。</p><p><strong>1.会话中断控制：强化 Stream 生命周期管理</strong></p><p>实际场景中可能会因为用户中途修改 Prompt 终止会话、响应超时导致用户放弃、网络不稳定引发连接断开等因素导致会话中断。及时感知并终止无效会话，能有效节省 LLM 资源。对此，Kitex 与 Hertz 的流式接口通过实现统一的 golang context cancel 语义，达成 Stream 生命周期的精准控制：</p><ul><li><strong>Kitex gRPC 支持跨服务与同服务场景的 Stream 生命周期管理</strong>：跨服务场景下，上游服务主动调用 cancel 后，会通过 HTTP/2 Rst Frame 终止下游 Stream；同服务场景下，下游 Stream 的生命周期完全受上游 Stream 控制，上游 cancel 会触发下游级联终止。</li><li><strong>Hertz 原生支持 SSE 协议，对齐 Kitex gRPC 的 context cancel 能力</strong>：让流式链路从端上到服务、服务到大模型的生命周期控制形成闭环。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400289" alt="" title="" loading="lazy"/></p><p><strong>2.流式异常优化：提升问题定位效率</strong></p><p>流式交互中，gRPC-Go 经典报错 "rpc error: code = 1, context is canceled" 存在明显局限性 ------ 仅能描述结果，无法明确具体错误原因，易导致问题误判（如误归因为 LLM 服务故障）。该报错可能对应用户主动终止会话，级联 cancel 等多种场景，排查难度较大。为解决这一问题，服务框架团队优化了 Kitex gRPC 的错误描述机制，明确报错诱因，帮助开发者快速定位异常根源，大幅降低问题排查成本。</p><ul><li>错误细分为流级别错误和连接级别错误</li><li>丰富错误描述，精确对应具体错误场景</li><li>新增 "triggered by" 字段，明确触发错误的服务</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400290" alt="" title="" loading="lazy"/></p><p><strong>3.流式监控升级：完善消息观测能力</strong></p><p>传统 Ping-Pong 模型的监控指标（QPS、Latency）虽可统一适配为 "Stream 创建至生命周期结束" 的指标，但难以满足流式场景的精细化观测需求。对此，服务框架团队对监控能力进行双重升级：</p><ul><li><strong>新增 Recv/Send QPS 指标</strong>：通过 StreamEventReport 接口扩展，每次调用 Recv 或 Send 方法时自动触发打点，精准捕捉流式消息交互频率。</li><li><strong>增强流式Trace 能力</strong>：新增 StreamSendHeader/StreamRecvHeader、StreamSendRst/StreamRecvRst、StreamSendTrailer/StreamRecvTrailer 等关键状态事件，清晰刻画 Stream 状态流转，为建流失败、非预期报错等疑难问题提供排查依据。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400291" alt="" title="" loading="lazy"/></p><p>通过会话中断控制、流式异常优化、流式监控升级三大实践增强，Kitex 与 Hertz 有效解决了大模型应用的核心落地阻碍。但随着用户规模与实践案例的增加，服务框架团队发现现有流式接口仍存在学习使用成本高、复杂级联 cancel 链路排查难等问题。因此，进一步优化流式接口、推出自研流式协议并增强流式生态，推动流式能力的易用性与用户体验迈上新台阶。</p><p><strong>三、流式能力与生态升级：从可用到好用</strong></p><p>为解决现有流式接口的使用痛点，推动流式能力从 "可用" 向 "好用" 跨越，服务框架团队从接口设计优化、自研协议研发、生态工具补充三个维度，对 Kitex 与 Hertz 的流式能力及生态进行全面升级。</p><p><strong>1. 现有流式接口的核心痛点</strong></p><p>当前流式接口在设计与使用中存在两类关键问题，导致用户学习和使用成本偏高：</p><ul><li><strong>gRPC-Go 接口设计的局限性</strong>：Server 侧流式 Handler 未直接暴露 context 参数，需通过 Stream.Context () 获取；Stream 的 Recv、Send 方法也未暴露 context 参数，无法细粒度控制超时等逻辑。虽然 gRPC-Go 官方认可统一 context 设计，但未计划推出 v2 接口优化，Kitex gRPC 因遵循该设计也存在相同问题。</li><li><strong>Kitex 自身能力透出的适配问题</strong>：Kitex 最初基于 Ping-Pong 模型设计，未充分考虑流式接口需求。一方面 Options 配置作用域模糊，部分配置仅对 Unary 接口生效，需用户在实践中探索确认；另一方面，中间件只适配 Unary 接口语义（接收请求→处理→返回响应），流式场景中 resp 始终为 nil，语义差异增加理解成本，导致流式接口未能得到完全支持。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400292" alt="" title="" loading="lazy"/></p><p><strong>2. StreamX 接口优化：降低使用门槛</strong></p><p>针对上述痛点，服务框架团队推出 StreamX 流式接口，通过设计革新与能力升级提升易用性：</p><ul><li><strong>统一 context 设计</strong>：Server 侧 Unary 接口与流式接口一致暴露 context 参数，Stream 对象的 Recv、Send 方法也新增 context 参数，支持细粒度控制（如超时设置），符合用户使用直觉。</li><li><strong>流式接口 "适应性" 升级</strong>：拆分 Options 配置为 WithUnary（仅 Unary 接口生效）与 WithStream（仅流式接口生效）两类，保持原有配置兼容性；同时提供 Stream、Recv、Send 三种专属中间件，参数与作用域直观清晰，适配流式场景语义。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400293" alt="" title="" loading="lazy"/></p><p><strong>3.自研协议 TT Header Streaming改变 gRPC 痛点</strong></p><p>gRPC 难以排查复杂级联 cancel 链路，也无法有效支持 context.WithCancelCause，本质在于 gRPC 基于 HTTP/2 Rst Stream Frame 实现 context cancel 功能，只支持传递 ErrCode，无法携带其它元信息。</p><p>服务框架团队为了改善 gRPC 痛点，推出自研协议 TTHeader Streaming，允许 Rst Frame 携带 Header 与 Payload。</p><ul><li><strong>Rst Frame 携带链路追踪信息，高效应对级联 cancel</strong>：类似 HTTP via，TTHeader Streaming 在 Rst Frame 头部会携带 ttscp(ttheader streaming cancel path)，跟踪完整的 cancel 链路，从而精确定位发起 cancel 的第一跳服务。</li><li><strong>支持 context.WithCancelCause，传递自定义 cancel 异常</strong>：TTHeader Streaming 支持在 Rst Frame 中携带 payload，从而承载由 context.WithCancelCause 注入的自定义 cancel 异常，用户可以实现更为丰富的 cancel 语义。</li></ul><p><strong>4. 完备的生态支持：流式泛化能力增强</strong></p><p>在原有流式调用能力的基础上，Kitex 进一步完善了泛化生态支持，使流式交互在本地调试、压测及多协议网关等场景下也能无缝使用。</p><ul><li>支持流式泛化 Client，一个泛化 Client 搞定流式/非流式场景</li><li>支持流式泛化 Server，高效处理 二进制/JSON/Map 数据</li><li>Kitexcall 支持流式调用，方便本地调试流式接口</li></ul><p><strong>四、总结与展望</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400294" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400295" alt="" title="" loading="lazy"/></p><p>本次分享围绕三大板块展开：一是大模型应用框架的流式能力与经典链路，明确 Kitex 与 Hertz 的核心支撑作用；二是流式工程实践增强，通过会话中断控制、异常定位优化、监控能力升级，保障大模型应用稳定落地；三是流式能力与生态升级，以 StreamX 新接口、自研 TTHeader Streaming 协议、完善流式生态，实现流式能力从 "可用" 到 "好用" 的跨越。展望未来，服务框架团队将开源流式最佳工程实践并发布配套使用指南，推出 Metrics/Trace 的 open-telemetry 版本，持续迭代 TTHeader Streaming 协议、优化 WebSocket 支持，进一步完善流式生态，为更多大模型应用提供高效、可靠的技术支撑。</p><p><strong>活动回顾资料</strong></p><ul><li><strong>视频回看</strong> ：<a href="null" target="_blank">https://space.bilibili.com/3494360534485730/lists/6518781?type=season</a></li><li><strong>演讲PPT下载</strong> ：<a href="null" target="_blank">https://github.com/cloudwego/community/tree/main/meetup/2025-09-20</a></li></ul>]]></description></item><item>    <title><![CDATA[专题：2025构建全自动驾驶汽车生态系统]]></title>    <link>https://segmentfault.com/a/1190000047400325</link>    <guid>https://segmentfault.com/a/1190000047400325</guid>    <pubDate>2025-11-14 17:05:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>原文链接：<a href="https://link.segmentfault.com/?enc=oIWvxrXzhccKGRjGSXKTrw%3D%3D.gYUdH3bByRRGuZG6Nbl5a4YtphDrPDZ3VOnzY3i%2FUPk%3D" rel="nofollow" title="https://tecdat.cn/?p=44316" target="_blank">https://tecdat.cn/?p=44316</a>  <br/>原文出处：拓端抖音号@拓端tecdat</p><h3><a name="t1" target="_blank"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400327" alt="封面" title="封面"/></h3><p>2025年，智能驾驶正站在“技术落地”与“规模商业化”的十字路口——自主品牌城市NOA渗透率已达9.1%，15万级车型标配激光雷达成为常态，但深圳车主因系统未识别非常规红绿灯追尾、特斯拉FSD在京实线变道被罚的案例，却暴露了“技术跑在前，规则跟不上”的行业矛盾。</p><p>本报告洞察基于《东吴证券：2025年主流车企城市NOA试驾报告》《亿欧智库：2024中国智能驾驶城区NOA功能测评报告》《Barclays：中国Robotaxi行业现状报告》及文<strong>末80+份智能驾驶行业研究报告的数据，最新报告合集及解读实时更新已分享在交流群，阅读原文进群咨询、定制数据报告和600+行业人士共同交流和成长。</strong></p><p>报告将从“技术演进-产业链竞争-市场增长-成本突围-用户接受度”五大维度，拆解华为、特斯拉、地平线等厂商的核心动作，为车企研发、出行运营商、智能驾驶创业者提供可落地的决策参考，看清行业机遇与隐藏风险。</p><h4><a name="t2" target="_blank"/>一、智能驾驶的“逆袭路”：从“依赖进口”到“国产主导”</h4><p>智能驾驶不是一夜爆发的技术。早年中国企业在L1-L2辅助驾驶阶段，还需依赖英伟达芯片、Mobileye算法；2020年起，地平线J系列芯片量产、禾赛激光雷达价格腰斩，国产厂商开始打破外资垄断；2024年更是关键转折点——武汉Robotaxi实现“招手即停”，哈弗、小鹏等品牌将L2+智驾车型下探至10万价格带，行业正式从“技术跟随”迈入“商业领跑”。  <br/>这背后不只是技术突破，更是产业链协同的结果：激光雷达从10万美元降至500美元，智驾芯片国产化率超60%，加上政策开放17个国家级测试区，中国智能驾驶正在形成“技术-成本-政策”的三角支撑。</p><h4><a name="t3" target="_blank"/>二、产业链核心战：芯片与激光雷达的“国产突围”</h4><p>智能驾驶的竞争，本质是“关键部件”的竞争。当前产业链的核心焦点，集中在智驾芯片和激光雷达两大领域，国产厂商已实现从“跟跑”到“领跑”的跨越。</p><h5>（一）智驾芯片：英伟达仍领先，但地平线、华为正在“抢份额”</h5><p>2024年中国智驾芯片市场呈现“一超多强”格局：英伟达以39%的份额占据高端市场（如特斯拉、小鹏高端车型），但其芯片成本高、本地化服务响应慢的问题逐渐凸显。而国产厂商正在快速崛起——地平线凭借11%的份额成为行业新势力（配套长城、奇瑞），华为以17%份额绑定高端车型（如问界M9），特斯拉自研芯片占23%（仅供自家车型），国产芯片合计已占61%。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400328" alt="" title="" loading="lazy"/>  <br/>2024年中国智驾芯片厂商市场份额横向比例条形图表A1数据及PDF模板已分享到会员群  <br/>3秒解读：国产芯片已占据半壁江山，地平线、华为成为英伟达最强对手。  <br/>对应人群行动建议：车企研发可优先评估地平线J6P、华为昇腾610，降低对英伟达依赖；创业者可聚焦国产芯片的算法适配赛道，比如为地平线芯片开发低成本NOA算法。</p><h5>（二）激光雷达：中国厂商垄断全球88%份额，成本降到“15万车型用得起”</h5><p>全球车载激光雷达市场早已是“中国主场”：禾赛科技、速腾聚创各占29%份额（配套理想、小鹏），图达通以21%份额绑定蔚来，华为（9%）、法雷奥（10%）紧随其后，中国厂商合计占据88%市场。更关键的是，国产厂商将激光雷达价格从2020年的10万美元，压到2024年的1500元，直接推动广汽埃安RT、小鹏P7+等15-20万车型规模化搭载。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400329" alt="" title="" loading="lazy"/>  <br/>2023年全球车载激光雷达厂商市场份额灰底比例条形图表A2数据及PDF模板已分享到会员群  <br/>3秒解读：中国厂商靠成本优势垄断激光雷达市场，成为智能驾驶规模化的“关键推手”。  <br/>对应人群行动建议：出行运营商采购车辆时，优先选择搭载禾赛、速腾激光雷达的车型，后续维修成本更低；供应链企业可布局激光雷达核心部件（如发射端芯片），分享国产化红利。</p><hr/><p><strong>相关文章</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400330" alt="" title="" loading="lazy"/></p><h3><a name="t4" target="_blank"/>专题：2025城市NOA智能驾驶研究报告|附70+份报告PDF 汇总下载</h3><p>原文链接：<a href="https://link.segmentfault.com/?enc=ZCpZ1PFgjti2O%2Bb0M7g2Ew%3D%3D.Q1l2Aw82F2PuS5T0hZTckQa1sOGN68RaInfLiiQR4jA%3D" rel="nofollow" title="https://tecdat.cn/?p=43592" target="_blank">https://tecdat.cn/?p=43592</a></p><hr/><h4><a name="t5" target="_blank"/>三、市场增长预测：2030年Robotaxi渗透率达7%，这些城市将先爆发</h4><p>智能驾驶市场正呈现“高端先行、平价普及”的清晰趋势，而增长潜力最大的赛道，当属Robotaxi（机器人出租车）和共享自动驾驶（SAV）。</p><h5>（一）ADASSoC：中国市场五年增长3倍，成全球核心动力</h5><p>作为智能驾驶的“大脑”，ADAS SoC市场正在快速扩张：全球规模将从2023年的275亿元增至2028年的925亿元，中国市场占比从51.3%提升至53.6%，年复合增长率达28%。这背后是中国L2+车型渗透率的快速提升——2024年自主品牌L2+渗透率已达16%，远超全球平均水平。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400331" alt="" title="" loading="lazy"/>  <br/>ADAS SoC市场规模双轴图表B1数据及PDF模板已分享到会员群  <br/>3秒解读：中国ADAS SoC市场增速全球领先，本土需求（如城市NOA）是核心驱动力。  <br/>对应人群行动建议：芯片厂商可加大7nm工艺芯片研发（如地平线J6P），聚焦L2++以上高端市场；投资者可关注与华为、地平线合作的Tier 1供应商（如德赛西威）。</p><h5>（二）高阶智驾渗透率：中国2030年达80%，甩开全球平均水平</h5><p>中国高阶智驾（L2+及以上）的渗透速度，正在远超全球：2023年渗透率仅7%，2030年将飙升至80%，而全球同期仅64%。这得益于三大因素：政策开放测试道路（如北京允许Robotaxi全时段运营）、智算数据平台建设（如国家智能网联汽车创新中心平台）、平价智驾车型普及（如哈弗枭龙MAX二代13.88万起）。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400332" alt="" title="" loading="lazy"/>  <br/>高阶智驾渗透率百分比堆叠面积图表C1数据及PDF模板已分享到会员群</p><h5>（三）Robotaxi：2035年市场价值650亿美元，武汉成“示范标杆”</h5><p>2035年全球全自动驾驶车辆市场价值将达1820亿美元，其中Robotaxi以650亿美元占据最大份额，成为共享出行的主流形态。中国市场表现更突出：2030年武汉Robotaxi渗透率将达30%（因政府优先开放路权），北京、上海、广州等一线城市超10%，全国总体渗透率达7%，远超其他国家。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400333" alt="" title="" loading="lazy"/>  <br/>2035年全自动驾驶车辆市场价值预测瀑布图表市场增长-1数据及PDF模板已分享到会员群  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400334" alt="" title="" loading="lazy"/>  <br/>2030年中国机器人出租车渗透率预测刻度线图表市场增长-2数据及PDF模板已分享到会员群  <br/>3秒解读：Robotaxi是智能驾驶商业化的“最大蛋糕”，中国一线城市将先实现盈利。  <br/>对应人群行动建议：出行运营商可优先布局武汉、广州，对接当地政府申请Robotaxi运营资质（如滴滴已在武汉获牌）；地方政府可借鉴武汉“路权开放+场站补贴”模式，吸引车企落地。</p><h5>（四）共享自动驾驶（SAV）：2040年乐观情景超2600万辆，城市化是关键</h5><p>共享自动驾驶车辆（SAV）的增长将呈“指数级”：2035年保守估计560万辆，乐观情景950万辆；2040年保守1570万辆，乐观突破2640万辆。这背后是城市化进程加快（中国城市化率2030年将达70%）、用户对共享出行接受度提升（2023年中国用户接受度81%），以及技术成熟（如Momenta端到端技术适配15万级车型）。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400335" alt="" title="" loading="lazy"/>  <br/>共享自动驾驶车辆数量预测气泡图表市场增长-3数据及PDF模板已分享到会员群</p><h4><a name="t6" target="_blank"/>四、成本突围：中国厂商把Robotaxi成本降到“全球最低”</h4><p>智能驾驶要规模化，成本控制是“生死线”。中国厂商通过技术迭代与规模效应，已经实现制造成本与运营成本的双重突围，成为全球成本控制的标杆。</p><h5>（一）制造成本：五年降80%，2025年Robotaxi BOM成本仅3.75万美元</h5><p>中国Robotaxi的制造成本正在“断崖式”下降：2020年还需20万美元/辆，2025年降至3.75万美元，2030年目标3万美元。核心驱动是关键部件降价：激光雷达从10万美元降至500美元，智驾芯片国产化后成本降30%（如地平线J6P比英伟达Orin-X便宜30%），加上电池成本下降，整体BOM成本快速下探。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400336" alt="" title="" loading="lazy"/>  <br/>中国机器人出租车制造成本趋势半圆面积比例图表成本分析-1数据及PDF模板已分享到会员群  <br/>3秒解读：中国Robotaxi成本已低于全球同行（Waymo约10万美元），具备规模化推广的经济基础。  <br/>对应人群行动建议：车企可加大Robotaxi量产（如百度萝卜快跑已量产1万辆），通过规模效应进一步降本；零部件供应商可聚焦激光雷达、智驾芯片的成本优化，比如开发更低成本的MEMS激光雷达。</p><h5>（二）运营成本：百度单次行程仅2.72美元，比Waymo便宜88%</h5><p>运营成本的控制更能体现中国厂商的优势。百度Robotaxi单次行程成本已降至2.72美元，实现单位经济盈利：车辆折旧占49%（1.34美元）、充电占22%（0.59美元）、保险占9%（0.23美元），其他成本（维护、远程监控）占20%。而美国Waymo单次成本高达23.10美元，中国厂商在运营效率（如充电网络布局）、人力成本（远程监控人员薪资）上的优势明显。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400337" alt="" title="" loading="lazy"/>  <br/>BIDU机器人出租车单次行程成本组成圆环图表成本分析-2数据及PDF模板已分享到会员群</p><h4><a name="t7" target="_blank"/>五、用户接受度：中国用户81%愿用自动驾驶，远超美国的29%</h4><p>用户接受度是智能驾驶商业化的“最后一公里”。中国用户对自动驾驶的接受度，正在以“翻倍”的速度提升：2021年仅39%，2023年达81%，而美国同期仅从18%升至29%。这背后是中国用户接触智驾的机会更多（如Robotaxi试点城市多）、政府推广力度大（如深圳街头随处可见自动驾驶测试车），以及华为、小鹏等厂商的智驾功能更贴合中国路况（如识别电单车、非常规红绿灯）。  <br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047400338" alt="" title="" loading="lazy"/>  <br/>中美用户对自动驾驶舒适度比例华夫图表用户接受度-1数据及PDF模板已分享到会员群  <br/>3秒解读：中国是全球最接受自动驾驶的市场，为商业化提供了“用户基础”。  <br/>对应人群行动建议：车企在推广智驾功能时，可加大用户体验活动（如“智驾体验日”），重点宣传“贴合中国路况”的优势；出行运营商可在一二线城市先铺开Robotaxi服务，利用高接受度快速起量。</p><h4><a name="t8" target="_blank"/>六、可落地的3件事：分角色给出“行动指南”</h4><ol><li><strong>车企研发</strong>：本周梳理现有车型智驾配置，优先评估地平线J6P、华为昇腾610等国产芯片替代方案，结合成本分析报告优化BOM结构，目标将L2+智驾车型价格下探至15万以下（参考哈弗枭龙MAX二代的定价策略）。</li><li><strong>出行运营商</strong>：本月调研武汉、广州的Robotaxi运营案例（如百度萝卜快跑、滴滴自动驾驶），对接当地交通部门申请测试资质，同步规划场站与充电设施布局，参考2030年渗透率预测制定2026年运营目标（如一线城市 Robotaxi 车队规模达1000辆）。</li><li><strong>智能驾驶创业者</strong>：聚焦激光雷达零部件（如发射端VCSEL芯片）或国产芯片算法适配赛道，基于产业链竞争格局报告筛选合作伙伴（如与禾赛、速腾合作开发低成本部件），利用行业智算数据平台获取最新路况数据，快速迭代产品。</li></ol><h4><a name="t9" target="_blank"/>七、风险提示及应对方案：提前规避“坑”</h4><ol><li><strong>数据安全合规风险</strong>：智能驾驶涉及大量道路数据和用户信息，可能面临《汽车数据安全管理若干规定》的合规处罚。应对方案：建立数据脱敏与安全存储体系（如采用联邦学习技术），社群已整理《智能驾驶数据合规政策合集》，进群可领取。</li><li><strong>政策变动风险</strong>：地方政府测试道路开放进度、智驾分级政策可能调整（如某城市突然收紧Robotaxi运营时间），影响商业化节奏。应对方案：密切关注全国汽车标准化技术委员会的政策动态，与地方交通部门建立月度沟通机制，社群将实时同步政策更新。</li><li><strong>技术迭代风险</strong>：智驾芯片、算法更新快（如英伟达Thor芯片即将量产），现有产品可能快速过时。应对方案：采用模块化设计预留升级空间（如车型支持芯片替换），与地平线、华为签订长期技术合作协议，优先布局L3+以上高阶技术研发，社群提供最新技术趋势报告（如《2025智驾芯片技术路线报告》）。</li></ol><h4><a name="t10" target="_blank"/>八、核心数据对比表：不同报告差异及原因</h4><table><thead><tr><th>研究主题</th><th>核心结论</th><th>数据差异</th><th>原因分析</th></tr></thead><tbody><tr><td>智驾芯片市场份额</td><td>Barclays：地平线占11%；Bernstein：地平线占比超10%</td><td>差异±1%</td><td>统计时间略有差异，Barclays统计2024全年，Bernstein统计2024H2（地平线Q4出货量略有下滑）</td></tr><tr><td>Robotaxi渗透率</td><td>Barclays：2030年中国总体7%；亿欧智库：2030年中国8%</td><td>差异±1%</td><td>统计范围不同，Barclays仅含一二线城市，亿欧智库包含部分三线城市（如苏州、宁波）</td></tr><tr><td>智驾成本下降幅度</td><td>Barclays：五年（2020-2025）下降80%；中泰证券：四年（2021-2025）下降75%</td><td>差异±5%</td><td>时间周期不同，Barclays含2020年高基数，中泰证券从2021年（成本已初步下降）开始统计</td></tr></tbody></table><p><strong>九、文中数据图表列表</strong></p><ol><li>2024年中国智驾芯片厂商市场份额横向比例条形图表A1</li><li>2023年全球车载激光雷达厂商市场份额灰底比例条形图表A2</li><li>ADAS SoC市场规模双轴图表B1</li><li>高阶智驾渗透率百分比堆叠面积图表C1</li><li>2035年全自动驾驶车辆市场价值预测瀑布图表市场增长-1</li><li>2030年中国机器人出租车渗透率预测刻度线图表市场增长-2</li><li>共享自动驾驶车辆数量预测气泡图表市场增长-3</li><li>中国机器人出租车制造成本趋势半圆面积比例图表成本分析-1</li><li>BIDU机器人出租车单次行程成本组成圆环图表成本分析-2</li><li>中美用户对自动驾驶舒适度比例华夫图表用户接受度-1</li></ol><h2><a name="t11" target="_blank"/>本专题内的参考报告（PDF）目录</h2><ol><li>智能驾驶行业深度报告-激光雷达的应用跃迁-从驰骋公路到赋能万物 报告2025-11-10</li><li>中国智能驾驶芯片：竞争格局及关键供应商深入L2+以上NOA细分市场 报告2025-10-31</li><li>2025构建全自动驾驶汽车生态系统：未来出行研究报告 报告2025-10-19</li><li>集团企业数字化转型、数字驾驶舱、数字化平台方案 报告2025-10-15</li><li>中国自动驾驶：无人驾驶出租车全天候运行 报告2025-09-11</li><li>2025中国L4智能驾驶场景商业化发展洞察报告 报告2025-09-09</li><li>智能驾驶智算数据平台发展研究报告 报告2025-09-02</li><li>2025年智能驾驶智算数据平台发展研究报告 报告2025-09-02</li><li>城市驾驶舱解决方案 报告2025-08-28</li><li>2025年驾驶自动化系统用户告知及培训体系标准化需求研究报告 报告2025-08-28</li><li>商业综合体驾驶舱解决方案 报告2025-08-26</li><li>2024共享自动驾驶汽车的演进：市场潜力、用户接受度与早期采用者群体报... 报告2025-08-24</li><li>中国无人驾驶出租车行业现状：2030年50万量级部署与盈亏平衡点探析 报告2025-08-18</li><li>2024年自动驾驶安全模型研究报告 报告2025-07-28</li><li>2025汽车智能驾驶技术及产业发展白皮书 报告2025-07-11</li><li>汽车行业深度报告-当自动驾驶与机器人共振-详解VLA与世界模型 报告2025-07-08</li><li>2025美国各城市自动驾驶汽车部署状况研究报告 报告2025-07-06</li><li>自动驾驶汽车：时间表和未来路线图 报告2025-06-19</li><li>无人驾驶深度之一-无人物流专题-万事具备-爆发元年 报告2025-06-17</li><li>自动驾驶汽车：人工智能与学习算法的进化之旅（2024） 报告2025-06-09</li><li>2025年全球科技中国无人驾驶出租车市场商业化之路研究报告 报告2025-05-25</li><li>2025当AI接管方向盘：自动驾驶场景下的人机交互认知重构、变革及对策... 报告2025-05-07</li><li>中国民航驾驶员发展年度报告2024年 报告2025-04-29</li><li>2025年公路干线物流自动驾驶行业研究报告 报告2025-04-27</li><li>2024年中国自动驾驶行业深度报告 报告2025-04-20</li><li>2025年NVIDIA自动驾驶安全报告 报告2025-04-04</li><li>汽车智能驾驶行业深度报告-端到端与AI共振-智驾平权开启新时代 报告2025-04-01</li><li>2025全球自动驾驶行业洞察报告 报告2025-03-31</li><li>比亚迪天神之眼智能驾驶系统技术与卖点解析（2月10日发布会） 报告2025-03-24</li><li>小鹏汽车首次覆盖报告：智能驾驶先锋，产品周期发力 报告2025-03-10</li><li>自动驾驶的世界模型综述 报告2025-03-09</li><li>2024中国智能驾驶城区NOA功能测评报告 报告2025-01-24</li><li>智能驾驶2024年度报告 报告2025-01-21</li><li>自动驾驶战略与政策观察（2024年）-政策法规助力高度自动驾驶加速推进... 报告2025-01-09</li><li>2024全球电车驾驶者调研报告 报告2025-01-05</li><li>2024年中国智慧交通发展趋势报告：自动驾驶篇 报告2025-01-05</li><li>通渠有道：2024年园区物流无人驾驶行业研究报告 报告2024-12-24</li><li>中国煤炭工业协会：2024年露天煤矿无人驾驶技术应用发展报告 报告2024-12-17</li><li>通渠有道：2024年园区物流无人驾驶行业研究报告 报告2024-11-24</li><li>香港应用科技研究院&amp;德勤：2024香港网联自动驾驶汽车(CAV)研究报... 报告2024-11-04</li><li>2024特斯拉的自动驾驶系统FSD发展历程、技术原理及未来展望分析报告 报告2024-11-03</li><li>智能驾驶行业2024年深度行业分析研究报告 报告2024-10-12</li><li>2024特斯拉、华为等企业在智能驾驶领域的技术进展及商业模式分析报告 报告2024-10-08</li><li>辰韬资本：自动驾驶软硬一体演进趋势研究报告 报告2024-10-06</li><li>辰韬资本：自动驾驶软硬一体演进趋势研究报告 报告2024-10-06</li><li>全球智慧矿业创新研究院：智能矿山暨无人驾驶行业蓝皮书 报告2024-10-06</li><li>辰韬资本：2024年自动驾驶软硬一体演进趋势研究报告 报告2024-10-06</li><li>通渠有道&amp;济驭&amp;同铃科技：2024自动驾驶线控底盘行业研究报告 报告2024-09-08</li><li>华为：2024年Net5.5G时代-IP自动驾驶网络白皮书：开启自智网... 报告2024-08-12</li><li>第一财经&amp;DT研究院：2024无人驾驶网约车乘坐意愿调查报告 报告2024-08-12</li><li>源达信息：智能驾驶研究系列-智能驾驶政策技术双轮驱动-助推Robota... 报告2024-08-08</li><li>头豹：2024年中国无人驾驶商用车应用分析-多场景落地-技术革新引领行... 报告2024-07-23</li><li>亿欧智库：2024中国智慧矿山自动驾驶产业市场研究报告 报告2024-07-15</li><li>CAICV：中国智能网联汽车自动驾驶仿真测试白皮书（2023版） 报告2024-07-07</li><li>沙利文：2024全球港口无人驾驶行业独立市场研究报告 报告2024-07-04</li><li>甲子光年：2024自动驾驶行业研究报告 报告2024-07-04</li><li>亿欧智库：自动驾驶篇2024中国自动驾驶商用车港口场景商业化案例研究 报告2024-06-28</li><li>百分点舆情中心：2024智能驾驶兴趣人群研究报告 报告2024-06-27</li><li>自动驾驶分会&amp;辰韬资本：2024端到端自动驾驶行业研究报告 报告2024-06-26</li><li>亿欧智库：2024中国自动驾驶商用车港口场景商业化案例研究-港口新质生... 报告2024-06-20</li><li>亿欧智库：智能驾驶行业-2024中国智能驾驶数据闭环应用新生态分析报告 报告2024-06-11</li><li>民航局：民用无人驾驶航空器操控员和云系统数据统计报告（2023年） 报告2024-05-19</li><li>BJHAI：2024北京市高级别自动驾驶示范区数据安全治理白皮书 报告2024-05-10</li><li>中国民用航空局飞行标准司：中国民航驾驶员发展年度报告2023年版 报告2024-04-03</li><li>量子位智库：智能驾驶2023年度报告 报告2024-02-20</li><li>前瞻研究院：数据驱动时代“车路云一体化”加速自动驾驶商业化进程 报告2024-01-29</li><li>ECC&amp;中电标协&amp;华为：2023智能驾驶计算芯片性能评测标准化白皮书 报告2024-01-22</li><li>如祺出行&amp;罗兰贝格：2024自动驾驶出租车（Robotaxi）商业化趋... 报告2024-01-04</li><li>2025长城汽车深度研究报告：新品加速、出口拓展、智驾转型 报告2025-10-09</li><li>2025汽车智驾芯片行业技术趋势、市场空间、竞争格局及相关标的分析报告 报告2025-08-19</li><li>2025年智驾和机器人领域人才洞察 报告2025-07-02</li><li>2025中国高阶辅助智驾最新技术洞察 报告2025-06-26</li><li>智驾地图市场研究报告（2025） 报告2025-06-04</li><li>智驾平权之车企智驾方案梳理 报告2025-05-19</li><li>汽车智能驾驶行业深度报告-端到端与AI共振-智驾平权开启新时代 报告2025-04-01</li><li>2025新能源汽车全场景智驾用户体验报告 报告2025-03-01</li><li>NE时代：2024年北京车展分析报告-智驾篇 报告2024-05-29</li><li>2025智能座舱操作系统洞察报告：无界互联，智能座舱系统迎来AI生态革... 报告2025-07-18</li><li>2025年智能座舱操作系统洞察报告 报告2025-07-11</li><li>2025华舆奖前瞻趋势发布-中国智能座舱评选白皮书 报告2025-03-25</li><li>2024年汽车智能座舱投融资研究白皮书 报告2025-02-11</li><li>2025宝马超感智能座舱首发事件舆情洞察报告 报告2025-02-10</li><li>2024年AI大模型赋能智能座舱研究报告 报告2025-01-16</li><li>facecar：2024北京车展智能座舱趋势洞察报告 报告2024-05-23</li><li>君迪&amp;同济大学：2023年度中国汽车智能座舱典范研究白皮书 报告2024-01-10</li></ol>]]></description></item><item>    <title><![CDATA[首个记忆幻觉评估框架 HaluMem 正]]></title>    <link>https://segmentfault.com/a/1190000047400355</link>    <guid>https://segmentfault.com/a/1190000047400355</guid>    <pubDate>2025-11-14 17:04:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="117" referrerpolicy="no-referrer" src="/img/bVdm29W" alt="" title=""/></p><hr/><hr/><hr/><p>在和 AI 长期相处的过程中，你可能发现它偶尔会“记错人”：\<br/>昨天刚告诉它我喜欢黑咖，今天它却推荐了焦糖拿铁；\<br/>上周说好要去成都旅游，它却在记忆里写成了长沙。</p><p><img width="723" height="202" referrerpolicy="no-referrer" src="/img/bVdm29w" alt="" title="" loading="lazy"/></p><pre><code>                                图 记忆系统中操作级幻觉的示例
</code></pre><p>这些看似小小的“记忆偏差”，其实正是当下 AI 系统中最隐蔽、最难察觉的风险之一——<strong>记忆幻觉（Memory Hallucination），其中</strong>包括：</p><ul><li><strong>记忆提取幻觉</strong>：从对话中抽取关键信息时，可能<strong>错误或虚构事实</strong>；</li><li><strong>记忆更新幻觉：修改旧信息时，可能错误或遗漏更新；</strong></li><li><strong>记忆问答幻觉：引用记忆回答问题时，可能调用了错误记忆或编造细节。</strong></li></ul><p><strong>而幻觉，往往正是在这些环节中被“生成”或“扩散”的。</strong></p><p>这些幻觉一旦发生，会在系统内部累积、传递、放大，最终影响AI的回答。于是我们看到这样的现象：“AI越聊越熟，却越说越不对。”</p><p><strong>HaluMem：首个面向记忆系统的幻觉评估框架正式发布！</strong></p><p>记忆张量（MemTensor）联合中国电信研究院正式发布业内首个针对 AI 记忆系统的幻觉评估框架 ——<strong>HaluMem</strong>。</p><p>首日发布已登顶 Hugging Face Papers Daily &amp; Weekly TOP 1。</p><p><img width="723" height="372" referrerpolicy="no-referrer" src="/img/bVdm29X" alt="" title="" loading="lazy"/></p><p>📄 论文已上线 Hugging Face Papers：\<br/><a href="https://link.segmentfault.com/?enc=%2Fpb2OOmlRottxwd6sGHEaw%3D%3D.WfOS%2Fw9HAEvfFYd4lV2yOOYi8tV2E12daBitpaq0Ayw6HFDBkBvrkBJMSy%2BT1VgN" rel="nofollow" target="_blank">https://huggingface.co/papers/2511.03506</a></p><p>我们希望通过 HaluMem 助力：</p><blockquote>每一个智能体都能知道自己，是“在哪一步开始记错的”。</blockquote><h2>三阶段幻觉拆解机制</h2><p>不同于以往只能评估整体表现的黑箱方法，HaluMem 首创了，并将记忆过程拆分为三个关键阶段：</p><ol><li><strong>记忆抽取（Extraction）</strong> ：AI 是否正确抓取关键信息？</li><li><strong>记忆更新（Update）</strong>：在修改旧信息时是否出现误写或偏差？</li><li><strong>记忆问答（Usage）</strong> ：AI 回答问题时是否调用了正确记忆？</li></ol><p>这种“操作级”评估方式，能够精准定位幻觉来源，让开发者真正理解——模型是在<strong>哪一步</strong>开始出现问题。</p><h2>极限长上下文测试：还原真实交互</h2><p>HaluMem 构建了覆盖 <strong>1M tokens</strong> 的超长上下文数据集，系统性地揭示主流记忆系统（Mem0、Memobase、Supermemory 、Zep等）在不同阶段的幻觉模式与传播规律，模拟真实人机交互场景。</p><p>数据集包含多维人格、事件更新、关系演化等复杂场景，用于系统揭示幻觉的传播规律。</p><h2>实验结果：主流记忆框架的幻觉表现</h2><p>HaluMem 构建了覆盖 <strong>1M tokens</strong> 的长上下文数据集，并对主流记忆系统（Mem0、Zep、Memobase、SuperMemory 等）进行了系统评估。</p><p>以下为首轮实验结果（幻觉率越低越好）：</p><p><img width="723" height="339" referrerpolicy="no-referrer" src="/img/bVdm29Y" alt="" title="" loading="lazy"/><br/>从结果可以看到：</p><ul><li><strong>记忆抽取与更新阶段</strong> 是幻觉的主要集中点，占总误差约 70%；</li><li><strong>MemOS</strong> 依托结构化记忆与偏好记忆机制，幻觉率降低超过 40%；</li><li>具备上下文调度与异步记忆机制的系统，在问答阶段表现显著更稳。</li></ul><p>换句话说，HaluMem 不只是评估框架，更是一面镜子，照出了每个记忆系统在「哪里容易出错、怎么改进」的真相。</p><h2>框架特性亮点</h2><p><img width="723" height="403" referrerpolicy="no-referrer" src="/img/bVdm290" alt="" title="" loading="lazy"/></p><h2>为什么这很重要？</h2><p>过去，我们关注模型“说得对不对”； 现在，我们要关注模型“<strong>记得对不对</strong>”。</p><p>HaluMem 的出现，让 AI 记忆系统首次具备了“自检”与“溯源”能力。</p><p><strong>它可以帮助：</strong></p><ul><li>医疗类智能体——减少记忆冲突，提升诊断一致性；</li><li>情感陪伴类 Agent——防止“人格漂移”；</li><li>企业知识助理——保持知识更新与问答逻辑统一。</li></ul><p>这意味着，AI 不再只是“会回答的问题机器”，而且能在长时间学习中持续修正自己的记忆与行为逻辑。</p><h2>开放数据、开放未来</h2><p>HaluMem 的评测集与代码现已全面开源， 开发者可在 Hugging Face 或 GitHub 上快速复现与验证实验。</p><p>🔗 论文地址： <a href="https://link.segmentfault.com/?enc=Mkl7ayKsCU3wTOFDpWIvbQ%3D%3D.lP9Jqqxj%2F%2FxdduloKO%2BIvnAZzU5t9cmsVAcYouFpukSZJtYl9TtnapoEq1nA8Pkt" rel="nofollow" target="_blank">https://huggingface.co/papers/2511.03506</a></p><p>📖 GitHub 地址：github.com/MemTensor/HaluMem</p><p>📣 如果你也关注记忆系统与幻觉问题，</p><p>欢迎到 Hugging Face 为 <strong>HaluMem</strong> 投票支持，让更多开发者加入「让 AI 记得更准」的行动。</p><p>⬇️ 点击投票 | Vote for HaluMem on Hugging Face：\<br/><a href="https://link.segmentfault.com/?enc=YNKK3IUcfdgvrzbL5%2FPV9g%3D%3D.QAvfhkGPje0LwKlOAExFyd%2FweLtznxKdsaUeY2JLiG2hLpuBTzqcZKPt5WMElQr3" rel="nofollow" target="_blank">https://huggingface.co/papers/2511.03506</a></p><hr/><hr/><hr/><hr/><p><strong>关于 MemOS</strong></p><p>MemOS 为 AGI 构建统一的记忆管理平台，让智能系统如大脑般拥有灵活、可迁移、可共享的长期记忆和即时记忆。</p><p>作为记忆张量首次提出“记忆调度”架构的 AI 记忆操作系统，我们希望通过 MemOS 全面重构模型记忆资源的生命周期管理，为智能系统提供高效且灵活的记忆管理能力。</p><p><img width="723" height="117" referrerpolicy="no-referrer" src="/img/bVdm29W" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[提升 Python 性能的 10 个智能]]></title>    <link>https://segmentfault.com/a/1190000047400361</link>    <guid>https://segmentfault.com/a/1190000047400361</guid>    <pubDate>2025-11-14 17:03:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Python 作为一门高效、简洁且功能强大的编程语言，已经广泛应用于从 Web 开发到人工智能等多个领域。然而，随着项目的复杂性增加，性能瓶颈不可避免地浮现。尤其是在数据处理、实时系统和高性能计算方面，优化 Python 代码的执行效率变得至关重要。幸运的是，Python 提供了很多内置功能和优化技巧，可以显著提高代码的运行速度。</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdm295" alt="1763084769950-veas9k8qvp.jpeg" title="1763084769950-veas9k8qvp.jpeg"/><br/>以下是 10 个经过实践验证的性能优化策略，这些方法不依赖于外部库，而是通过高效的数据结构、低级优化和 Python 本身的内建功能来加速代码执行。通过这些技巧，你不仅可以在大数据集和计算密集型任务中获得性能提升，还能在保持代码简洁和可读性的同时，解决性能瓶颈。</p><h3>技巧 1：使用集合进行成员测试</h3><p>在处理大规模数据集时，检查某个元素是否在集合中，使用列表通常效率较低。列表的成员测试（<code>x in some_list</code>）是线性时间复杂度（<code>O(n)</code>），意味着它需要逐个扫描元素。而集合（<code>set</code>）则通过哈希表实现，允许常数时间复杂度（<code>O(1)</code>）的查找，效率大幅提升。</p><pre><code class="python">big_list = list(range(1000000))
big_set = set(big_list)

start = time.time()
print(999999 in big_list)
print(f"List lookup: {time.time() - start:.6f}s")

start = time.time()
print(999999 in big_set)
print(f"Set lookup: {time.time() - start:.6f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>列表查找：约 0.015 秒</li><li>集合查找：约 0.00002 秒</li></ul><p>如果你的任务涉及到去重、输入验证或交叉引用等操作，集合会比列表更高效。</p><h3>技巧 2：避免不必要的复制</h3><p>复制大型对象（如列表、字典或数组）在时间和内存上都是开销巨大的。每次复制都会创建新的对象，这可能导致内存浪费和性能下降，尤其在处理大数据集时。尽量使用原地操作而不是复制对象，Python 的许多内置数据结构都提供了原地操作的方法（如 <code>sort</code>、<code>append</code>、<code>update</code> 等）。</p><pre><code class="python">numbers = list(range(1000000))

def modify_list(lst):
    lst[0] = 999
    return lst

start = time.time()
result = modify_list(numbers)
print(f"In-place: {time.time() - start:.4f}s")

def copy_list(lst):
    new_lst = lst.copy()
    new_lst[0] = 999
    return new_lst

start = time.time()
result = copy_list(numbers)
print(f"Copy: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>原地修改：约 0.0001 秒</li><li>复制修改：约 0.0100 秒</li></ul><h3>技巧 3：使用 <code>__slots__</code> 来提高内存效率</h3><p>Python 类的实例属性通常存储在动态字典（<code>__dict__</code>）中，这为灵活性提供了便利，但也带来了内存开销。通过使用 <code>__slots__</code>，可以显式声明固定的属性集合，避免创建 <code>__dict__</code>，从而节省内存。</p><pre><code class="python">class Point:
    __slots__ = ('x', 'y')

    def __init__(self, x, y):
        self.x = x
        self.y = y

start = time.time()
points = [Point(i, i+1) for i in range(1000000)]
print(f"With slots: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>使用 <code>__slots__</code>：约 0.1200 秒</li><li>不使用 <code>__slots__</code>：约 0.1500 秒</li></ul><h3>技巧 4：使用 <code>math</code> 模块代替操作符</h3><p>Python 的 <code>math</code> 模块提供了一些内建的函数，这些函数是用 C 实现的，比直接在 Python 中实现的运算符更加高效。例如，使用 <code>math.sqrt()</code> 通常比使用 <code>** 0.5</code> 运算符来计算平方根要更快。</p><pre><code class="python">import math

numbers = list(range(10000000))

start = time.time()
roots = [math.sqrt(n) for n in numbers]
print(f"Math sqrt: {time.time() - start:.4f}s")

start = time.time()
roots = [n ** 0.5 for n in numbers]
print(f"Operator: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li><code>math.sqrt()</code>：约 0.2000 秒</li><li><code>** 0.5</code>：约 0.2500 秒</li></ul><h3>技巧 5：预分配已知大小的内存</h3><p>Python 在动态构建列表或数组时，会在后台进行扩容，每次扩容都会涉及到内存分配和数据复制。如果你知道数据结构的最终大小，预先分配内存能显著提高性能，避免反复扩容。</p><pre><code class="python">start = time.time()
result = [0] * 1000000
for i in range(1000000):
    result[i] = i
print(f"Pre-allocated: {time.time() - start:.4f}s")

start = time.time()
result = []
for i in range(1000000):
    result.append(i)
print(f"Dynamic: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>预分配：约 0.0300 秒</li><li>动态分配：约 0.0400 秒</li></ul><h3>技巧 6：避免在热循环中使用异常处理</h3><p>异常处理非常强大，但它的开销也不容小觑。尤其在性能关键的循环中，频繁的抛出和捕获异常会导致堆栈展开和上下文切换，这对性能有很大影响。在这些循环中，最好通过条件检查来避免预期之外的错误发生，而不是依赖异常处理。</p><pre><code class="python">numbers = list(range(10000000))

start = time.time()
total = 0
for i in numbers:
    if i % 2 != 0:
        total += i // 2
    else:
        total += i
print(f"Conditional: {time.time() - start:.4f}s")

start = time.time()
total = 0
for i in numbers:
    try:
        total += i / (i % 2)
    except ZeroDivisionError:
        total += i
print(f"Exception: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>条件检查：约 0.3000 秒</li><li>异常处理：约 0.6000 秒</li></ul><h3>技巧 7：使用局部函数提高重复逻辑的效率</h3><p>在函数中反复使用同一段逻辑时，定义一个局部（嵌套）函数可以提高性能，因为 Python 会在局部作用域内更快地查找变量。</p><pre><code class="python">def outer():
    def add_pair(a, b):
        return a + b

    result = 0
    for i in range(10000000):
        result = add_pair(result, i)

    return result

start = time.time()
result = outer()
print(f"Local function: {time.time() - start:.4f}s")

def add_pair(a, b):
    return a + b

start = time.time()
result = 0
for i in range(10000000):
    result = add_pair(result, i)
print(f"Global function: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li>局部函数：约 0.4000 秒</li><li>全局函数：约 0.4500 秒</li></ul><h3>技巧 8：使用 <code>itertools</code> 进行组合操作</h3><p>Python 的 <code>itertools</code> 模块提供了一些高效的函数，适用于排列、组合、笛卡尔积等任务。这些函数采用惰性生成方式，能够在不占用大量内存的情况下处理大规模数据。</p><pre><code class="python">from itertools import product

items = [1, 2, 3] * 10

start = time.time()
result = list(product(items, repeat=2))
print(f"Itertools: {time.time() - start:.4f}s")

start = time.time()
result = []
for x in items:
    for y in items:
        result.append((x, y))
print(f"Loops: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li><code>itertools.product()</code>：约 0.0005 秒</li><li>嵌套循环：约 0.0020 秒</li></ul><h3>技巧 9：使用 <code>bisect</code> 进行有序列表操作</h3><p>如果你需要在一个有序列表中进行查找或插入操作，使用 <code>bisect</code> 模块提供的二分查找方法会比手动实现的</p><p>线性查找更加高效。</p><pre><code class="python">import bisect

sorted_list = list(range(1000000))

start = time.time()
bisect.insort(sorted_list, 500000)
print(f"Bisect insert: {time.time() - start:.4f}s")

start = time.time()
sorted_list.append(500000)
sorted_list.sort()
print(f"Manual insert: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li><code>bisect.insort()</code>：约 0.1000 秒</li><li>手动插入：约 0.1500 秒</li></ul><h3>技巧 10：使用 <code>numpy</code> 进行数值计算</h3><p>对于数值计算密集型任务，<code>numpy</code> 是一种非常高效的解决方案。相比纯 Python 实现，<code>numpy</code> 通过优化的 C 代码和向量化操作，能大幅提升计算效率。</p><pre><code class="python">import numpy as np

arr = np.arange(1000000)

start = time.time()
result = np.sqrt(arr)
print(f"NumPy: {time.time() - start:.4f}s")

start = time.time()
result = [x ** 0.5 for x in arr]
print(f"List comprehension: {time.time() - start:.4f}s")</code></pre><p><strong>时间测试结果：</strong></p><ul><li><code>numpy.sqrt()</code>：约 0.2000 秒</li><li>列表推导：约 0.4500 秒</li></ul><hr/><h2>结语</h2><p>掌握这些 Python 性能优化技巧，可以显著提升你的代码执行效率，特别是在处理大量数据或需要高性能计算时。通过了解和运用 Python 内置功能和高效的数据结构，不仅能提升运行速度，还能优化代码的可读性和可维护性。</p><hr/><p><strong>喜欢就奖励一个“👍”和“在看”呗~</strong></p><p><img width="203" height="69" referrerpolicy="no-referrer" src="/img/bVdlOIU" alt="1763084769951-955qfbo83ze.png" title="1763084769951-955qfbo83ze.png" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[开发者必看！TinyEngine 低代码]]></title>    <link>https://segmentfault.com/a/1190000047400386</link>    <guid>https://segmentfault.com/a/1190000047400386</guid>    <pubDate>2025-11-14 17:02:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文由TinyEngine低代码物料导入功能贡献者张筠同学原创。</p><h2>引言：低代码物料接入的痛点与解决方案</h2><p>在低代码平台开发中，物料接入是核心环节之一。传统物料接入依赖开发者手动编写符合平台协议的 JSON 配置，不仅效率低下，还容易因人为失误导致兼容性问题 —— 尤其是面对海量 UI 组件时，重复的人工操作会大幅拖慢开发进度。</p><p>为解决这一痛点，我们开发了 <strong>TinyEngine 低代码物料自动导入工具</strong>，支持通过 URL 爬取、NPM 包解析、源码上传三种方式，自动提取组件的 Props/Events/Slots 等 API 信息，并转换为符合 TinyEngine 协议的标准物料格式。配套的可视化前端实现了 "导入 - 预览 - 编辑 - 保存" 全流程闭环，将物料接入效率大幅度提升。</p><p>本文将从项目设计、核心模块实现、项目部署与使用指南等方面，带大家全面了解这个前后端一体化的物料处理方案。</p><h2>一、项目概览：技术栈与核心架构</h2><h3>1. 技术栈选型</h3><h4>后端技术栈</h4><ul><li>运行环境：Node.js v20.19.5+（原生支持 fetch 与 ES6 + 语法）</li><li>核心依赖：Express（接口服务）、MySQL（物料存储）、Puppeteer（URL 爬取）、LLM SDK（API 提取）</li><li>核心能力：多源数据解析、物料协议转换、异步任务管理</li></ul><h4>前端技术栈</h4><ul><li>框架：Vue 3.2+（<code>&lt;script setup&gt;</code>语法）</li><li>构建工具：Vite 4.0+（高效热更新与跨域代理）</li><li>UI 组件：OpenTiny Vue（轻量化企业级组件库）</li><li>核心能力：动态表单、任务进度可视化、表格编辑、批量数据管理</li></ul><h3>2. 整体架构设计</h3><p><img width="723" height="836" referrerpolicy="no-referrer" src="/img/bVdm3aN" alt="1.png" title="1.png"/></p><p>项目采用前后端分离架构，核心交互流程如下：</p><ol><li>前端发起导入请求（携带 URL/NPM 信息 / 源码文件）；</li><li>后端创建异步任务，根据导入类型执行对应解析逻辑；</li><li>调用 LLM 接口提取结构化 API 信息，转换为标准物料格式；</li><li>前端通过轮询获取任务进度，实时展示处理状态；</li><li>处理完成后，前端提供物料预览与编辑功能，支持保存到数据库。</li></ol><h2>二、核心功能拆解：从解析到可视化</h2><h3>1. 多源物料解析（后端核心能力）</h3><p>依托四大核心模块协同工作，实现URL、NPM、源码三种导入方式的标准化解析，全程自动化完成从原始数据到TinyEngine标准物料的转化。</p><h4>（1）URL 导入</h4><p>基于 <strong>API生成模块</strong> 的URL表格驱动流程，通过Puppeteer模拟浏览器访问目标URL，根据用户指定的CSS选择器精准定位API表格数据，搭配重试机制保障爬取稳定性；获取表格数据后，传递给LLM模型进行结构化处理，生成包含Props/Events/Slots的原始API JSON；随后经 <strong>物料转换模块</strong> 转化为符合TinyEngine规范的物料格式，最后由 <strong>后处理模块</strong> 完成组件名标准化（如统一为PascalCase格式）及规则化优化，确保物料一致性。</p><h4>（2）NPM 导入</h4><p>接收用户输入的NPM包名与组件名后，后端自动下载对应包资源，通过 <strong>文件筛选模块</strong> 的NPM类型规则（强制校验<code>index</code>入口文件，提取含组件关键词的核心文件，自动跳过<code>style</code>、<code>utils</code>等非API相关目录及<code>.map</code>文件）完成文件筛选；筛选后的核心文件进入 <strong>API生成模块</strong> 的文件驱动流程，经LLM解析生成原始API JSON；再通过 <strong>物料转换模块</strong> 补充组件基本信息、规范Props/Events/Slots定义，最终由 <strong>后处理模块</strong> 按预设规则优化（无需处理的组件直接保留、表格组件合并列定义等），输出标准物料。</p><h4>（3）源码导入</h4><p>用户可上传Vue组件源码文件或ZIP压缩包，后端解压后触发 <strong>文件筛选模块</strong> 的源码类型处理逻辑——自动识别<code>index.js/ts</code>入口文件及Props/Events定义文件，过滤非API相关内容；筛选后的有效文件进入 <strong>API生成模块</strong> 执行文件驱动流程，经LLM解析生成原始API JSON；后续通过 <strong>物料转换模块</strong> 转化为TinyEngine标准格式，再由 <strong>后处理模块</strong> 清理子项组件冗余片段、统一组件名格式，最终生成可直接使用的标准化物料。</p><h3>2. 可视化操作闭环（前端核心能力）</h3><h4>（1）动态导入表单</h4><p>根据用户选择的导入类型（URL/NPM/ 源码），自动切换对应表单：</p><ul><li>URL 导入：展示 URL 输入框与表格 CSS 选择器输入框；</li><li>NPM 导入：展示包名与组件名输入框；</li><li>源码导入：展示文件上传组件（支持单个文件与 ZIP 包）。</li></ul><h4>（2）任务进度可视化</h4><ul><li>提交导入请求后，展示进度条实时更新处理进度（0-100%）；</li><li>处理中任务支持最小化为右侧悬浮卡片，不影响其他操作，点击可重新打开模态框查看详情；</li><li>任务状态实时反馈（处理中 / 成功 / 失败），失败时显示具体错误信息。</li></ul><h4>（3）物料预览与编辑</h4><p>任务处理成功后，通过表格展示生成的物料列表，支持：</p><ul><li>主表展示基础信息（组件名、导入类型、导入时间等）；</li><li>展开行查看子表（属性 / 事件 / 插槽），支持编辑字段值、删除无效项；</li><li>编辑后实时提交更新，确保数据同步到后端。</li></ul><h4>（4）物料库管理</h4><p>提供完整的物料管理功能：</p><ul><li>筛选与搜索：按组件名精确筛选、关键词模糊搜索；</li><li>批量操作：批量导出选中物料为 JSON 文件、批量删除无用物料；</li><li>分页控制：默认 10 条 / 页，支持自定义每页显示数量。</li></ul><h2>三、项目部署</h2><h3>1. 环境要求</h3><table><thead><tr><th>环境/工具</th><th>版本要求</th><th>说明</th></tr></thead><tbody><tr><td>Node.js</td><td>v20.19.5 及以上</td><td>支持<code>fetch</code>、ES6+语法，前后端通用，建议使用官网长期支持版确保兼容性</td></tr><tr><td>前端框架</td><td>Vue 3.2+</td><td>前端采用<code>&lt;script setup&gt;</code>语法开发，需确保依赖版本符合要求</td></tr><tr><td>构建工具</td><td>Vite 4.0+</td><td>负责前端项目构建、热更新及跨域代理配置，当前项目实际使用v7.1.7版本</td></tr><tr><td>数据库</td><td>MySQL 8.0 及以上</td><td>用于存储物料数据，需提前本地安装并启动</td></tr><tr><td>依赖服务</td><td>LLM接口（如DeepSeek/Qwen/OpenAI）</td><td>后端核心依赖，需准备支持JSON输出的大模型接口及对应API密钥、接口地址</td></tr></tbody></table><h3>2. 安装与配置</h3><h4>2.1 克隆仓库</h4><p>首先将项目代码克隆到本地，执行以下命令：</p><pre><code class="bash">git clone &lt;仓库地址&gt;  # 替换为实际的项目仓库地址</code></pre><h4>2.2 安装依赖</h4><p>进入项目根目录后，分别安装后端和前端的依赖包，确保环境一致性：</p><pre><code class="bash"># 1. 安装后端依赖
cd backend
npm install  # 若使用yarn/pnpm，可替换为yarn install/pnpm install

# 2. 安装前端依赖（需新开终端或返回根目录）
cd frontend
npm install  # 同理可替换为对应包管理工具的安装命令</code></pre><h4>2.3 环境配置</h4><h5>（1）后端配置</h5><ol><li><p><strong>复制环境变量模板</strong>：进入后端目录，将 <code>.env.example</code> 模板文件复制为实际使用的 <code>.env</code> 文件：</p><pre><code class="bash">cd backend  # 若当前不在后端目录需执行此命令
cp .env.example .env  # Windows系统可手动复制文件并重命名为.env</code></pre></li><li><p><strong>编辑.env文件参数</strong>：用文本编辑器打开 <code>.env</code> 文件，根据本地环境和实际资源信息填写以下关键配置（替换占位符内容）：</p><pre><code class="env"># 服务器配置
SERVER_PORT=3001                  # 后端服务端口，默认3001，可按需修改
CORS_ALLOW_ORIGIN=http://localhost:8080 # 前端地址，需与前端端口保持一致，解决跨域问题

# 数据库配置（需与本地MySQL环境匹配）
MYSQL_HOST=localhost       # MySQL服务地址，本地默认localhost
MYSQL_PORT=3306            # MySQL端口，默认3306
MYSQL_USER=root            # MySQL用户名，替换为你的实际用户名
MYSQL_PASSWORD=your_password    # MySQL密码，替换为你的实际密码（无密码则留空）
MYSQL_DATABASE=lowcode_material # 数据库名，需后续手动创建该库

# LLM模型配置（必填，替换为实际可用的大模型信息）
OPENAI_MODEL=deepseek-reasoner            # 模型名称，如deepseek-reasoner、Qwen3-32B等
OPENAI_API_KEY=your_api_key_here          # 模型API密钥，从对应平台获取
OPENAI_BASE_URL=https://api.deepseek.com/v1 # 模型接口地址，按实际平台填写

# 默认路径配置（系统自动创建，无需手动操作）
DEFAULT_OUTPUT_DIR=output-log       # 最终物料JSON输出目录
DEFAULT_SCHEMA_LOG_DIR=schema-log   # 转换过程日志目录
DEFAULT_API_LOG_DIR=raw-api-log     # 原始API JSON日志目录</code></pre></li></ol><h5>（2）前端配置（跨域与端口）</h5><p>前端需配置代理对接后端服务，确保接口请求正常，步骤如下：</p><ol><li>进入前端目录，打开 <code>vite.config.js</code> 文件（路径：<code>frontend/vite.config.js</code>）；</li><li><p>确认或修改以下配置（需与后端 <code>.env</code> 中的配置保持一致）：</p><pre><code class="javascript">import { defineConfig } from 'vite'; 
import vue from '@vitejs/plugin-vue'; 

export default defineConfig({
  plugins: [vue()],
  server: {
    port: 8080, // 前端端口，默认8080，需与后端CORS_ALLOW_ORIGIN中的端口一致
    proxy: {
      // 代理所有/api前缀的请求到后端服务
      '/api': {
        target: 'http://localhost:3001', // 后端服务地址，与SERVER_PORT一致
        changeOrigin: true, // 开启跨域适配
      }
    }
  }
});</code></pre><ul><li>若修改了前端端口或后端服务端口，需同步更新对应配置。</li></ul></li></ol><h3>3. 快速启动</h3><p>前后端服务需按特定顺序启动，核心顺序：<strong>启动MySQL服务 → 创建项目数据库 → 启动后端服务 → 启动前端服务</strong>，具体步骤如下：</p><h4>3.1 启动MySQL服务并创建项目数据库</h4><h5>（1）启动MySQL服务</h5><p>根据本地操作系统，执行对应启动命令：</p><ul><li><strong>Windows</strong>：通过“服务”管理器找到“MySQL”服务，右键点击“启动”；</li><li><strong>macOS（Homebrew安装）</strong>：打开终端执行 <code>brew services start mysql</code>；</li><li><strong>Linux（系统服务，以Ubuntu为例）</strong>：执行 <code>sudo systemctl start mysql</code>（其他发行版按对应命令操作）。</li></ul><h5>（2）手动创建项目数据库</h5><p>项目需使用预先创建的 <code>lowcode_material</code> 数据库，执行以下步骤：</p><ol><li><p>打开终端/命令提示符，登录MySQL：</p><pre><code class="bash">mysql -u root -p  # 替换root为你的MySQL用户名，回车后输入密码（无密码直接回车）</code></pre></li><li><p>执行SQL命令创建数据库（指定字符集避免中文乱码）：</p><pre><code class="sql">CREATE DATABASE IF NOT EXISTS lowcode_material 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;</code></pre></li><li><p>（可选）验证数据库创建成功：</p><pre><code class="sql">SHOW DATABASES;  # 执行后查看输出列表，确认包含lowcode_material</code></pre></li><li><p>退出MySQL命令行：</p><pre><code class="sql">exit;</code></pre></li></ol><h4>3.2 启动后端服务</h4><pre><code class="bash"># 进入后端目录（若当前不在该目录）
cd backend

# 启动开发环境服务（使用配置的npm脚本）
npm run serve</code></pre><ul><li>启动成功标识：终端显示服务监听信息（如 <code>后端服务启动成功，端口：3001</code>）；</li><li>验证接口可用性：可通过浏览器访问 <code>http://localhost:3001/api/material/docs</code>，查看简易接口文档。</li></ul><h4>3.3 启动前端服务</h4><p>需新开一个终端（避免与后端服务冲突），执行以下命令：</p><pre><code class="bash"># 进入前端目录
cd frontend

# 启动开发环境（支持热更新，修改代码后自动刷新）
npm run dev</code></pre><ul><li>启动成功标识：终端输出 <code>VITE v7.1.7 ready in 300 ms</code> 及访问地址；</li><li>访问前端：打开浏览器输入默认地址 <code>http://localhost:8080</code>，即可进入物料管理首页。</li></ul><h3>4. 启动常见问题排查</h3><ul><li><strong>MySQL连接失败</strong>：检查 <code>.env</code> 中数据库配置（地址、端口、用户名、密码）是否与本地环境一致，确保MySQL服务已启动；</li><li><strong>LLM接口报错</strong>：检查模型配置（API密钥、接口地址、模型名称）是否正确，确保接口可正常访问且有剩余调用额度。</li></ul><h3>四、核心使用流程</h3><ol><li>访问前端地址（默认 <a href="https://link.segmentfault.com/?enc=64%2B8W7maspwJZ9%2BAFW1iTw%3D%3D.LtIQ8XggFjpjoNL3YdL6%2BQEI%2FpBIFYgBsKPbIP5HmaA%3D" rel="nofollow" target="_blank">http://localhost:8080</a>），进入物料管理首页；</li></ol><p><img width="723" height="402" referrerpolicy="no-referrer" src="/img/bVdm3aQ" alt="2.png" title="2.png" loading="lazy"/></p><ol start="2"><li><p>选择导入方式（URL / NPM / 源码），填写对应信息（如 URL 地址、NPM 包名、上传源码文件）；</p><ul><li><strong>URL 导入</strong>：输入URL地址和API表格CSS选择器；</li><li><strong>NPM 导入</strong>：输入NPM包名和组件名称；</li><li><strong>源码导入</strong>：上传源码文件（支持单个文件或zip）。</li></ul></li></ol><p><img width="723" height="397" referrerpolicy="no-referrer" src="/img/bVdm3aR" alt="3.gif" title="3.gif" loading="lazy"/></p><p><img width="723" height="397" referrerpolicy="no-referrer" src="/img/bVdm3aS" alt="4.gif" title="4.gif" loading="lazy"/></p><p><img width="723" height="433" referrerpolicy="no-referrer" src="/img/bVdm3aT" alt="5.gif" title="5.gif" loading="lazy"/></p><ol start="3"><li>提交后等待任务处理，实时查看进度条（0-100%），进度条支持最小化；</li></ol><p><img width="723" height="430" referrerpolicy="no-referrer" src="/img/bVdm3aU" alt="6.gif" title="6.gif" loading="lazy"/></p><ol start="4"><li>任务成功后，预览生成的物料数据（属性 / 事件 / 插槽），可直接编辑修改或删除；</li></ol><ul><li>编辑属性/事件/插槽</li></ul><p><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdm3aV" alt="7.gif" title="7.gif" loading="lazy"/></p><ul><li>删除属性/事件/插槽</li></ul><p><img width="723" height="439" referrerpolicy="no-referrer" src="/img/bVdm3aY" alt="8.gif" title="8.gif" loading="lazy"/></p><ul><li>删除组件物料</li></ul><p><img width="723" height="430" referrerpolicy="no-referrer" src="/img/bVdm3aZ" alt="9.gif" title="9.gif" loading="lazy"/></p><ol start="5"><li>点击 “保存到物料库”，将物料同步至 MySQL 数据库；</li></ol><p><img width="723" height="397" referrerpolicy="no-referrer" src="/img/bVdm3a0" alt="10.gif" title="10.gif" loading="lazy"/></p><ol start="6"><li>在首页通过筛选、搜索功能管理已保存的物料，支持批量导出或删除。</li></ol><ul><li>通过组件名称筛选组件物料</li></ul><p><img width="723" height="387" referrerpolicy="no-referrer" src="/img/bVdm3a1" alt="11.gif" title="11.gif" loading="lazy"/></p><ul><li>通过关键词筛选组件物料</li></ul><p><img width="723" height="387" referrerpolicy="no-referrer" src="/img/bVdm3a2" alt="12.gif" title="12.gif" loading="lazy"/></p><ul><li>批量删除组件物料</li></ul><p><img width="723" height="430" referrerpolicy="no-referrer" src="/img/bVdm3a3" alt="13.gif" title="13.gif" loading="lazy"/></p><ul><li>批量导出组件物料</li></ul><p><img width="723" height="430" referrerpolicy="no-referrer" src="/img/bVdm3a4" alt="14.gif" title="14.gif" loading="lazy"/></p><p>导出文件如下（以element-plus的Breadcrumb为例）：</p><pre><code class="json">[
  {
    "npm": {
      "package": "element-plus",
      "exportName": "ElBreadcrumb"
    },
    "icon": "breadcrumb",
    "name": {
      "zh_CN": "面包屑"
    },
    "tags": [
      "导航",
      "面包屑"
    ],
    "group": "element-plus",
    "schema": {
      "slots": {
        "default": {
          "label": {
            "zh_CN": "默认内容"
          },
          "description": {
            "zh_CN": "自定义默认内容"
          }
        }
      },
      "events": {},
      "properties": [
        {
          "name": "0",
          "label": {
            "zh_CN": "基础属性"
          },
          "content": [
            {
              "cols": 12,
              "type": "ArrayItemConfigurator-test",
              "label": {
                "text": {
                  "zh_CN": "分隔符"
                }
              },
              "widget": {
                "props": {
                  "placeholder": "请输入分隔符"
                },
                "component": "InputConfigurator"
              },
              "disabled": false,
              "property": "separator",
              "readOnly": false,
              "required": false,
              "description": {
                "zh_CN": "分隔符"
              },
              "defaultValue": "/",
              "labelPosition": "left"
            },
            {
              "cols": 12,
              "type": "unknown",
              "label": {
                "text": {
                  "zh_CN": "图标分隔符"
                }
              },
              "widget": {
                "props": {
                  "placeholder": "请输入图标名称"
                },
                "component": "InputConfigurator"
              },
              "disabled": false,
              "property": "separatorIcon",
              "readOnly": false,
              "required": false,
              "description": "图标分隔符组件",
              "defaultValue": null,
              "labelPosition": "left"
            }
          ],
          "description": {
            "zh_CN": "组件核心功能相关的配置，包括 separator、 separatorIcon 等核心属性"
          }
        }
      ]
    },
    "devMode": "proCode",
    "doc_url": "",
    "version": "",
    "category": "element-plus",
    "keywords": [
      "Breadcrumb",
      "面包屑",
      "导航"
    ],
    "snippets": [
      {
        "icon": "breadcrumb",
        "name": {
          "zh_CN": "面包屑"
        },
        "schema": {
          "children": [
            {
              "props": {
                "to": "/home"
              },
              "children": [
                {
                  "props": {
                    "text": "首页"
                  },
                  "componentName": "Text"
                }
              ],
              "componentName": "ElBreadcrumbItem"
            },
            {
              "props": {
                "to": "/list"
              },
              "children": [
                {
                  "props": {
                    "text": "列表页"
                  },
                  "componentName": "Text"
                }
              ],
              "componentName": "ElBreadcrumbItem"
            },
            {
              "props": {},
              "children": [
                {
                  "props": {
                    "text": "详情页"
                  },
                  "componentName": "Text"
                }
              ],
              "componentName": "ElBreadcrumbItem"
            }
          ]
        },
        "category": "element-plus",
        "screenshot": "",
        "snippetName": "ElBreadcrumb"
      }
    ],
    "component": "ElBreadcrumb",
    "configure": {
      "loop": true,
      "styles": true,
      "isModal": false,
      "isLayout": false,
      "isPopper": false,
      "condition": true,
      "framework": "Vue",
      "shortcuts": {
        "properties": [
          "separator"
        ]
      },
      "isNullNode": false,
      "contextMenu": {
        "actions": [
          "copy",
          "remove",
          "insert",
          "updateAttr",
          "bindEvent"
        ],
        "disable": []
      },
      "isContainer": true,
      "nestingRule": {
        "childWhitelist": "ElBreadcrumbItem",
        "parentWhitelist": "",
        "ancestorWhitelist": "",
        "descendantBlacklist": ""
      },
      "clickCapture": false,
      "rootSelector": ""
    },
    "description": "面包屑导航组件，用于显示当前页面在系统层级 结构中的位置"
  }
]</code></pre><h2>结尾</h2><p>TinyEngine 低代码物料自动导入工具的核心目标，是通过「自动化解析 + 可视化操作」的闭环设计，解决了低代码物料接入的效率瓶颈与兼容性难题。无论是 URL 爬取、NPM 解析还是源码上传，工具都力求简化全流程操作，让开发者无需关注底层协议细节与格式转换逻辑，即可快速将各类 UI 组件无缝转化为符合 TinyEngine 标准的可用物料，让低代码物料接入从繁琐的手动配置，转变为高效、省心的一站式操作。</p><h2>关于OpenTiny</h2><p>欢迎加入 OpenTiny 开源社区。添加微信小助手：opentiny-official 一起参与交流前端技术～</p><p>OpenTiny 官网：<a href="https://link.segmentfault.com/?enc=X5Z3uJ36SvpoADozbCwV3A%3D%3D.FKN7Uf0kfLbGedtydF8vvI4yY1CnouaDDFz%2Faa6cenE%3D" rel="nofollow" target="_blank">https://opentiny.design</a><br/>OpenTiny 代码仓库：<a href="https://link.segmentfault.com/?enc=Bj10ggsvGaxSQklpnRALQw%3D%3D.rDIG1CYv8J27xKydAhhtj2PqF79H1bnJXZHCR%2FcaL%2F0%3D" rel="nofollow" target="_blank">https://github.com/opentiny</a><br/>TinyVue 源码：<a href="https://link.segmentfault.com/?enc=Bzy%2BSD0BwGLSaZ70P9bxdg%3D%3D.906l18wDbvNf1FSP%2FOMQCq28p8adZFOAX32aYAWvGFujqjWLVywm1Dkdv6l8nbKG" rel="nofollow" target="_blank">https://github.com/opentiny/tiny-vue</a><br/>TinyEngine 源码： <a href="https://link.segmentfault.com/?enc=uMWL1r2RvFRSUha05xGc3Q%3D%3D.LlEcmDh%2FkCI0ftSJAYyY%2B68mkruCvYhdgjmHWfkYCVNtyiMTX0EsRmg1A28rW1jS" rel="nofollow" target="_blank">https://github.com/opentiny/tiny-engine</a><br/>欢迎进入代码仓库 Star🌟TinyEngine、TinyVue、TinyNG、TinyCLI、TinyEditor~ 如果你也想要共建，可以进入代码仓库，找到 good first issue 标签，一起参与开源贡献~</p>]]></description></item><item>    <title><![CDATA[开源欧拉社区将于 2025 年底正式上线]]></title>    <link>https://segmentfault.com/a/1190000047400412</link>    <guid>https://segmentfault.com/a/1190000047400412</guid>    <pubDate>2025-11-14 17:01:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>11 月 14 日，以“智跃无界，开源致远”为主题的操作系统大会2025（以下简称“大会”）在北京中关村国际创新中心成功举办。大会由开放原子开源欧拉（OpenAtom openEuler，简称“开源欧拉”或“openEuler”）社区，协同数十家产业伙伴共同举办，旨在汇聚全球产业界力量，打造极具创新力的操作系统，加速全球基础软件开源生态发展。<br/>据悉，在开放原子开源基金会的运营孵化下，开源欧拉社区蓬勃发展。成员单位超 2100 家，全球贡献者突破 2.3 万人，用户超过 550 万。openEuler 系操作系统累计装机量预计 2025 年底将超过 1600 万套，已经成为中国行业数智化首选操作系统，份额持续保持领先，在互联网、通信、政务、金融、公共事业和能源等行业已实现规模化应用。面向未来，开源欧拉社区正式开启新的 5 年发展之路，将于 2025 年底正式上线面向超节点的操作系统，引领 AI 时代，加速全球化。<br/><img width="723" height="482" referrerpolicy="no-referrer" src="/img/bVdm3ac" alt="" title=""/><br/>中国工程院院士倪光南在致辞中强调，基础软件是战略性产业，必须加强自主创新；是生态型产业，必须共创共建共享；是长周期产业，必须长期持续投入。过去 5 年，在产业各界的共同努力下，开源欧拉已经成为全球最活跃的开源操作系统技术社区之一，持续引领操作系统产业生态繁荣壮大。未来，超节点已经成为算力基础设施建设和部署的主流形态。智能时代的操作系统将衔接智能时代的硬件和应用，成为释放算力潜能的核心基石，助力千行万业智能化。<br/><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdm3ak" alt="" title="" loading="lazy"/><br/>开放原子开源基金会理事长程晓明在致辞中指出，开源的核心是协作，生态的未来在共生。开源欧拉的每一点进步，离不开硬件伙伴的深度适配，离不开软件应用厂商的场景验证，更离不开全球开发者的智慧贡献。相信在各方携手努力下，开源欧拉将以技术创新打破边界，让数字智能赋能万物， 以协作共生凝聚力量，推动开源生态行稳致远。<br/><img width="723" height="475" referrerpolicy="no-referrer" src="/img/bVdm3al" alt="" title="" loading="lazy"/><br/>华为公司董事、ICT BG CEO 杨超斌在致辞中表示，AI 技术正以前所未有的速度改变各行各业，传统服务器集群无法有效满足算力不断增长的诉求。华为已经开放灵衢互联协议 2.0，支持产业界伙伴打造基于灵衢的超节点，还将向开源欧拉社区贡献支持超节点的操作系统插件代码，提供“内存统一编址”、“异构算力低时延通信”和“全局资源池化”等关键能力。华为将与社区协同，推动与 Linux Foundation AI&amp;Data、PyTorch 等 AI 领域全球性开源组织深度合作，深化 AI 运行时、向量数据库、云化部署等技术专题落地。同时，华为将协同社区数十家 OSV、ISV 伙伴，面向海外客户提供 openEuler 整体解决方案，积极推动开源欧拉全球化进程。</p><h3>发布面向超节点的操作系统，引领 AI 时代</h3><p>会上，开放原子开源基金会、华为与中国电信天翼云公布联合发展倡议，联手促进技术共建、生态共筑和业务共赢，共同构建操作系统在 AI 和超节点等前沿技术领域的竞争力，推进天翼云和开源欧拉生态繁荣发展。<br/><img width="723" height="476" referrerpolicy="no-referrer" src="/img/bVdm3ap" alt="" title="" loading="lazy"/><br/>开放原子开源欧拉委员会主席熊伟发布 openEuler 全球首个面向超节点的操作系统（openEuler 24.03 LTS SP3），并在主题演讲中提到，openEuler 开启新的 5 年发展之路，坚定拥抱超节点，坚定拥抱 AI，加速全球化进程，为世界提供新的选择。<br/><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdm3aq" alt="" title="" loading="lazy"/><br/>当前，算力基础设施向 “超节点” 形态演进已成为业界普遍共识。面向超节点的操作系统，应该具备三个关键特征，包括：全局资源抽象，内存统一编址，设备池化管理；异构资源融合，大带宽低时延通信，实现平等互联；全局资源视图，兼容性接口，原生接口等，以此充分释放超节点算力潜能，加速基于超节点的应用创新。</p><h3>持续增强 AI 能力，加速行业数智化</h3><p>面向数据中心场景，开源欧拉社区提供 Intelligence BooM 全栈开源 AI 解决方案，支持 50+ 模型微调，通过异构协同推理效率提升 10%～30%，具备面向 Agentic AI 智能体生态快速适配能力，该方案已经在宝德、华鲲振宇等伙伴商用。<br/>面向新型工业自动化领域，openEuler 持续演化嵌入式能力，孵化了 MICA 混合关键性部署、UniProton 实时内核、嵌入式虚拟化等核心技术，实现微秒级响应时间。该方案已经在中国南方电网、菲尼克斯等多家国内外知名企业商业落地，有力地推动了 OT 领域 IT 化转型。</p><h3>共建产业生态，加速全球化</h3><p>今年， AMD、浪潮云、神州数码新增成为开源欧拉社区捐赠人。至此，Intel、Arm、 AMD 三大芯片企业均成为社区捐赠人。<br/><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdm3au" alt="" title="" loading="lazy"/><br/>凝思软件、中软国际、Wind River、统信软件、软通动力、超聚变、润和软件、麒麟软件、麒麟信安等成为开源欧拉社区首批全球化先锋伙伴，大家将携手推进 openEuler 全球化进程。<br/>在全球开源组织协作层面，开源欧拉社区近期与 Zephyr 嵌入式技术基金会、Linux Foundation AI&amp;Data 基金会达成深度技术合作。目前，开源欧拉社区累计与 15 家全球开源组织在 AI、云、大数据、HPC、嵌入式等领域建立紧密合作关系。<br/><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdm3aP" alt="" title="" loading="lazy"/><br/>开源欧拉的成长得益于每一位伙伴和开发者的信任。大会现场揭晓了“2025 年度 openEuler 领先商业实践”，共计23个openEuler 年度领先商业实践项目，包括 9 个规模型项目与 14 个创新型项目。</p>]]></description></item><item>    <title><![CDATA[LLM调用的最佳数据格式：TOON，成本]]></title>    <link>https://segmentfault.com/a/1190000047400431</link>    <guid>https://segmentfault.com/a/1190000047400431</guid>    <pubDate>2025-11-14 17:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在大模型逐渐融入业务系统的阶段，结构化数据输入/输出已成为落地应用的必需：RAG 检索结果、Agent 工具调用参数、业务查询结果、批处理列表等都需要让自然语言与“可机读”的结构化格式互通。事实标准是 JSON，但在高频调用、海量数据场景下，JSON 的标点开销会显著推高 token 成本。</p><p>如下JSON格式的例子：</p><pre><code class="json">{
  "users": [
    {"id": 1, "name": "Alice", "role": "admin"},
    {"id": 2, "name": "Bob", "role": "user"}
  ]
}</code></pre><p>Tokens 为 <strong>47</strong>:</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400433" alt="" title=""/></p><p>采用 TOON 格式之后，内容明显减少：</p><pre><code>users[2]{id,name,role}:
  1,Alice,admin
  2,Bob,user</code></pre><p>Tokens 为：<strong>24</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400434" alt="" title="" loading="lazy"/></p><p>差异的核心在于：TOON 用“缩进 + 一次性字段声明”的方式消除了绝大部分语法标点的冗余；当你在生产环境每天传输成千上万条记录时，冗余标点的累计开销会直接转化为可观的 API 费用。实践表明，TOON 在输入侧常带来 40–60% 的 token 节省。</p><h2>基准测试：TOKEN减少、准确率上升</h2><p>TOON格式在LLM调用时候除了在Token数量上的优化之外，不可忽略的是LLM检索准确率。如果单纯Token数量减少了，而准确率下降了，那意义就不大了。</p><p>以下是TOON官方仓库给出的综合效率排名：</p><pre><code>TOON           ████████████████████   26.9  │  73.9% acc  │  2,744 tokens
JSON compact   █████████████████░░░   22.9  │  70.7% acc  │  3,081 tokens
YAML           ██████████████░░░░░░   18.6  │  69.0% acc  │  3,719 tokens
JSON           ███████████░░░░░░░░░   15.3  │  69.7% acc  │  4,545 tokens
XML            ██████████░░░░░░░░░░   13.0  │  67.1% acc  │  5,167 tokens</code></pre><p>TOON 的准确率达到 73.9% （JSON 的准确率为 69.7%），同时使用的标记数减少了 39.6% 。可以看到TOON不仅在Token数量上有优势，在准确率上也有明显优势，更多基准测试结果请参考TOON官方仓库。</p><h2>什么时候不用 TOON</h2><p>TOON 格式在处理统一类型的对象数组时表现出色，但在某些情况下，其他格式更为合适：</p><ul><li>嵌套过深或结构不规则 （表格适用性 ≈ 0%）：JSON-compact 通常使用较少的标记。例如：具有多个嵌套层的复杂配置对象。</li><li>半均匀数组 （约 40-60% 符合表格格式）：Token节省量减少。如果您的pipline已经依赖于 JSON，则建议优先使用 JSON。</li><li>纯表格数据 ：对于平面表格，CSV 比 TOON 格式文件更小。TOON 格式仅需少量额外开销（约 5-10%）即可提供结构信息（数组长度声明、字段头、分隔符作用域），从而提高 LLM 的可靠性。</li><li>对延迟要求严格的应用 ：如果端到端响应时间是您的首要考虑因素，请在您的实际环境中进行基准测试。某些部署（尤其是像 Ollama 这样的本地/量化模型）即使 TOON 的Token数量较少，处理紧凑型 JSON 的速度也可能更快。请测量两种格式的 TTFT、每秒Token数和总时间，并使用速度更快的格式。</li></ul><h2>Java 中如何使用 TOON</h2><p>对于数据格式转换，各主流语言都有好用的SDK可以直接拿来使用。以Java为例，可以使用：</p><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.felipestanzani&lt;/groupId&gt;
    &lt;artifactId&gt;jtoon&lt;/artifactId&gt;
    &lt;version&gt;0.1.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>用法也是非常简单，核心API如下：</p><pre><code class="java">// Java 对象 → TOON 字符串
String toon = JToon.encode(object);

// JSON 字符串 → TOON
String toon = JToon.encodeJson(jsonString);

// TOON → Java 对象
Object obj = JToon.decode(toonString);

// TOON → JSON 字符串
String json = JToon.decodeToJson(toonString);</code></pre><h2>小结</h2><p>本文介绍了LLM调用时JSON格式调用在Token消耗的劣势，从而引出TOON格式。对于合适场景，如果目前Token消耗量偏高的应用，可以考虑在数据格式上进行优化，从而实现成本的优化。目前你都用什么格式呢？是否有用过TOON呢？留言区可以聊一聊。</p><blockquote>更多技术干货分享可以关注<a href="https://link.segmentfault.com/?enc=pdh%2F4jCS327JS2DAugdCKg%3D%3D.fhr7JeEK%2Bl0raU%2FG1GnXhZUU%2Btk0c7%2BhZIMo4uwnQN4%3D" rel="nofollow" target="_blank">我的代码世界</a></blockquote>]]></description></item><item>    <title><![CDATA[敏捷转型不只是流程：资深 PM 如何带团]]></title>    <link>https://segmentfault.com/a/1190000047399649</link>    <guid>https://segmentfault.com/a/1190000047399649</guid>    <pubDate>2025-11-14 16:11:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>敏捷转型在国内企业中已经从“热词”进入“常态”，但很多组织的敏捷实践，却陷入了“表面繁荣、内在空心”的假敏捷困局。会议变多、节奏变快、工具上线，却没有带来真正的业务敏捷与团队成长。本文将从项目治理与组织效能的角度，带你看清“假敏捷”的根源，并给出走出困局的可执行路径。</p><h3>一、当敏捷成为形式：流程在跑，价值没动</h3><p>过去几年，“敏捷转型”几乎成为各大中台与研发部门的常规动作。</p><p>从互联网到制造业，从创业公司到国央企，大家都在跑 Scrum、开站会、做 OKR。但当我们深入项目现场，却常听到这样的反馈：</p><ul><li>“我们比以前更忙了，但交付节奏并没有变快。”</li><li>“站会时间越来越长，但沟通效率越来越低。”</li><li>“敏捷上线半年了，客户满意度依旧没有提升。”</li></ul><p>这就是典型的“假敏捷”：流程在跑，但组织的认知与能力并未同步升级。表面上似乎“一切更敏捷”，实际上只是把旧的项目管理习惯换了个新术语而已。</p><p>假敏捷的特征往往包括：</p><ul><li>敏捷被视为一套“标准化流程”而非“适应性机制”；</li><li>团队机械执行 Scrum 仪式，却不理解背后的逻辑；</li><li>管理层追求速度，却回避文化、结构与激励机制的变革。</li><li>综上可知，很多企业不是在做敏捷，而是在表演敏捷。</li></ul><h3>二、假敏捷的根因：方法换了，思维没变</h3><h4>1. 从“命令控制”到“赋能协作”的断层</h4><p>敏捷倡导团队拥有更高的自主权和责任感，但许多组织仍延续传统的层级管理思维。</p><p>管理者关注的是“项目是否按计划推进”，而不是“团队是否在创造价值”；团队执行的是“上级任务”，而非“用户导向”；汇报链条依旧冗长，决策依旧集中。</p><p>据 State of Agile Report 2024 调研显示，47% 的敏捷转型失败，根本原因是领导层思维未转变。</p><p>换言之，流程再精致、工具再完善，只要领导层仍旧以控制为核心，敏捷就无法生根。</p><h4>2. 流程替代思考：看板上跑的不是价值，而是任务</h4><p>Jira、ONES、Trello 等研发管理工具确实让项目更透明，也是敏捷转型中必不可少的一环，但它们不是灵丹妙药。敏捷转型告诉你“需要用”这些工具，但在真正使用工具前，你要学会“怎么用”这些工具。</p><p>很多团队误以为“上了工具＝实现敏捷”，于是陷入另一种形式主义。他们花大量时间在工具上填数据、拉报表，但当你仔细观察，就会发现：</p><ul><li>任务粒度不均、优先级模糊；</li><li>每个 Sprint 都在“堆工作量”；</li><li>燃尽图看似漂亮，但产出与战略目标脱节。</li></ul><p>由此可见，这种“流程优先”的陷阱容易让团队陷入效率幻觉——他们忙于完成流程，却未真正思考“这个功能是否真的为用户创造了价值“。</p><h4>3. 绩效机制错位：KPI 约束下的“假协作”</h4><p>传统绩效考核强调个人产出，而敏捷强调跨职能协同。当团队成员被单独考核时，他们自然更关注“自己的任务”而非“整体目标”。结果就是：每个人都很努力，但整体协作效率极低。</p><p>因此，绩效机制如果与敏捷文化背道而驰，就会导致“假协作”：看似合作，其实各自为战。敏捷无法在孤立的激励体系中存活。</p><h3>三、走出假敏捷：从流程治理到组织心智的再造</h3><p>敏捷不是自下而上的自发运动，而是自上而下的认知革新。要走出假敏捷，企业需要在三个层面完成升级：管理者心智、PMO 职能、团队实践。</p><h4>1. 管理者：从“掌控者”到“系统设计师”</h4><p>很多领导误解“授权”就是“放手”，结果要么管太死，要么彻底放任。事实上，真正的敏捷领导力，是设计一个让团队能高效自组织的系统，通过清晰的边界、价值导向和反馈机制，构建有秩序的灵活性。</p><p>管理者层面的改进建议：</p><ol><li><strong>重新定义控制：</strong>由“控制任务”转向“控制节奏与目标”，让高层参与 Sprint Review，而不是仅看汇报；</li><li><strong>系统化思维：</strong>管理者应关注跨部门协同的制度设计、信息透明机制，而非日常微观管理；</li><li><strong>创造心理安全空间：</strong>允许暴露问题，让团队敢于暴露问题、质疑流程、提出改进。</li></ol><p><strong>实操案例：</strong></p><p>某制造企业在推行敏捷时，领导层每月参与一次 Sprint Review，与团队共同识别瓶颈。六个月后，交付延误率下降 30%，员工主动改进的数量增加了两倍。</p><h4>2. PMO：从“流程守门人”到“学习促进者”</h4><p>传统 PMO 主要关注规范与合规，但在敏捷转型中，它应成为组织学习与持续改进的中枢。假敏捷常常因为 PMO 把“标准化”误解为“僵化”，而真正成熟的 PMO，是能在秩序与灵活之间找到平衡。</p><p>PMP 层面的改进建议：</p><ul><li><strong>从流程合规转向价值导向：</strong>不再问“是否按模板执行”，而关注“交付周期、客户反馈”等价值指标。</li><li><strong>搭建知识复用机制：</strong>将项目复盘、最佳实践沉淀为共享知识库，用于指导后续项目。</li><li><strong>推动跨团队共学机制：</strong>定期组织“敏捷社区”或“Guild（行会）”，分享案例、反思改进，让敏捷成为组织的共识，而非孤岛实践。</li></ul><p><strong>实操案例：</strong></p><p>某互联网企业 PMO 通过建立“敏捷数据仪表盘”，整合交付周期、缺陷率、满意度等指标，实现了跨部门的价值对齐，协作摩擦下降 40%。</p><h4>3. 团队：从“被敏捷”到“用敏捷”</h4><p>许多团队“学会了流程”，却没“掌握原理”。他们照本宣科地开会、填表，却没理解迭代的意义。真正的团队敏捷，应当从“执行者”变为“问题发现与解决的主体”。</p><p>敏捷不是别人要求你执行的流程，而是团队自主选择的工作方式。团队真正的成长在于从“遵循规则”走向“共创价值”。</p><p>团队层面的改进建议：</p><ul><li><strong>先聚焦于小胜：</strong>以一个可验证的小目标开启试点，快速体验改进收益。</li><li><strong>建立复盘文化：</strong>复盘不是找责任，而是发现系统性约束、优化模式。</li><li><strong>透明化沟通：</strong>让看板不仅仅展示任务，还要让风险、假设与反馈全部可见。</li></ul><p><strong>实操案例：</strong></p><p>一家 SaaS 团队在初期敏捷实施中，每次迭代只做任务分配，几乎无复盘。后来引入“失败展台”机制——每个迭代评选“最值得学习的失败”，团队反而更敢尝试。三个月后，创新方案产出率提升 40%，团队氛围明显改善。</p><h4>4. 工具赋能：从“工具使用”到“系统协同”</h4><p>工具是敏捷落地的加速器，而非终点。很多团队在敏捷转型初期被工具“反客为主”——流程为了工具而设计，会议为了数据而开。实际上，工具的价值在于让组织的反馈循环更快、协作更透明、改进更可视化。</p><p>要让工具真正服务于敏捷，应当遵循三个原则：</p><p><strong>① 从“记录”到“认知”</strong></p><p>工具不是任务登记簿，而是思考的镜子。在 ONES 等研发管理平台中，用户故事应表达“价值交付”而非单纯的“任务目标”。</p><p>举个例子：一个用户故事不应该只写”实现登录功能”，而应是“作为一名注册用户，我希望能通过手机号或企业账号快速登录系统，以便更方便地进入工作空间，减少首次登录失败率”。</p><p><strong>② 从“工具孤岛”到“系统协同”</strong></p><p>敏捷工具不是单一项目的容器，而是组织运营系统的一部分。企业可通过集成不同模块（项目、测试、OKR、客户反馈等），形成从目标 → 执行 → 反馈 → 改进的闭环。</p><p>例如，在 ONES 研发管理平台中将项目、测试与目标模块集成起来，团队可以在一次迭代中同时看到任务完成率与价值交付率——Sprint 不再是简单的时间盒，而是业务战略的执行节奏。</p><p>当工具协同起来，团队不再为“谁做什么”争论，而是能共同回答“我们为什么做”。</p><p><strong>③ 从“使用工具”到“用数据改进”</strong></p><p>真正成熟的团队，不只是用上工具，而是学会用数据驱动决策。</p><ul><li>通过 Lead Time 识别流程瓶颈；</li><li>用燃尽图偏差分析任务估算准确性；</li><li>通过 Velocity 趋势评估团队负载与可持续交付节奏。</li></ul><p>同时，将工具数据纳入团队回顾中，让复盘基于事实，而非感觉。当工具被正确使用，它不再是负担，而是团队反思与进步的放大镜。</p><h4>5. 构建组织级敏捷：从“团队敏捷”到“业务敏捷”</h4><p>走出“假敏捷”的终极目标，不是优化团队，而是提升组织整体的适应力。这需要企业从三个层次系统性升级：</p><table><thead><tr><th>层级</th><th>传统思维</th><th>敏捷思维</th><th>转型杠杆点</th></tr></thead><tbody><tr><td>战略层</td><td>目标分解、年度计划</td><td>动态 OKR、滚动规划</td><td>战略对齐与节奏共振</td></tr><tr><td>结构层</td><td>职能部门、项目制</td><td>跨职能小队、价值流</td><td>流程重构与组织协作</td></tr><tr><td>文化层</td><td>稳定、控制、预测</td><td>学习、信任、反馈</td><td>建立心理安全与改进文化</td></tr></tbody></table><p>整合建议：</p><ul><li>让团队 OKR 与企业战略形成自上而下的链路；</li><li>以价值流为核心优化组织架构，减少信息阻塞。</li><li>以文化机制支撑持续学习，如内部复盘大会、改进激励制度。</li></ul><p>这也意味着，当企业能在战略、结构与文化三个维度形成一致性，敏捷才会从“团队工具”演化为“组织能力”。</p><h3>四、敏捷的本质：速度不是目的，学习才是</h3><p>敏捷不是为了“更快”，而是为了“更聪明”，“更有价值”。真正的敏捷组织，不仅能高效交付，更能在不确定中学习与演化。</p><ul><li>它的节奏适中，但反馈及时；</li><li>它的文化开放，但有秩序；</li><li>它的目标清晰，但路径灵活。</li></ul><p>正如《Toyota Kata》所说：“成功的关键，不在于它的生产工具或技术，而在于它持续改进和适应变化的能力。”换言之，持续学习的能力，才决定了组织的长期竞争力。</p><p>敏捷不是一个阶段性的项目，而是一种长期主义的管理哲学。一个资深 PM 的使命，不只是执行流程，而是让组织具备持续学习与自我进化的能力。当管理者懂得系统设计，PMO 成为学习枢纽，团队学会自驱与反思时，敏捷就不再是“流程”，而是组织的本能。那一刻，敏捷不再是目标，而是企业文化的一部分。</p>]]></description></item><item>    <title><![CDATA[⚡️2025-11-14GitHub日榜]]></title>    <link>https://segmentfault.com/a/1190000047399876</link>    <guid>https://segmentfault.com/a/1190000047399876</guid>    <pubDate>2025-11-14 16:10:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>🚀 <a href="https://link.segmentfault.com/?enc=Q%2FD3GRM6X9MjIUq%2FV%2F1cdw%3D%3D.kfnYv5rLdtvakAKPEWULqotGW7mwqlLYvHNNXW612QLHAfHEDh5KRsKCk2LaWpgj" rel="nofollow" target="_blank">sansan0 /TrendRadar</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=g%2Blqv9KPvOfa8yaM9ZSsZg%3D%3D.vEliP5ywXNrciYPEBzZnWpQ5g%2BHcMYRBFS6ehFCUIncDsGK9PsiLiKebTkd7KLs%2B" rel="nofollow" target="_blank">https://github.com/sansan0/TrendRadar</a></p><p>💡 <strong>简介</strong>：趋势雷达是一个30秒快速部署的热点助手，支持11+主流平台热点聚合，通过智能推送策略、精准内容筛选和趋势分析，帮助用户获取真正关心的新闻资讯。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>2275</td></tr><tr><td>⭐ Stars</td><td>11686</td></tr><tr><td>⚒️ Forks</td><td>7068</td></tr><tr><td>💻 Language</td><td>Python</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>最快30秒部署的热点聚合工具</li><li>多平台热点实时监控与分析</li><li>智能推送策略与时间窗口控制</li><li>支持多渠道多端适配与AI分析功能</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=yNdU0zoByXuZgsDFPKy5jw%3D%3D.kBLvTASWQlbsIlzzdecaPS3j%2FPcf%2B1HCokzB9wpVuMQNbfVLrqlC6TIG8Q9Zevqt" rel="nofollow" target="_blank">google /adk-go</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=dDN3sQPewRFYtGuF5Z8Q7Q%3D%3D.P7aXq%2B62EgyYgFKtYjXJVCy9UmATg2P7UUmQBbgml%2FgKyjyJbrapjdcCu7VgEPLN" rel="nofollow" target="_blank">https://github.com/google/adk-go</a></p><p>💡 <strong>简介</strong>：Go代理开发工具包（ADK）是一个开源的、代码优先的Go工具包，用于构建、评估和部署复杂的AI代理，具有灵活性和可控性，且兼容其他框架与云原生环境。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>351</td></tr><tr><td>⭐ Stars</td><td>3197</td></tr><tr><td>⚒️ Forks</td><td>172</td></tr><tr><td>💻 Language</td><td>Go</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>代码优先开发，灵活性高</li><li>模块化多代理系统，扩展性强</li><li>符合Go习惯用法，性能优异</li><li>跨平台部署，云原生支持好</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=QnB8JuLaezsE94oWgCNFOw%3D%3D.GlyypL0Vq13U%2FxNqwqoSqU%2BTIbZpX%2FJMmmFF0JnKq47mC6RN7Etucchi3pqPcSPx" rel="nofollow" target="_blank">TapXWorld /ChinaTextbook</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=vU1%2FtDHX3g1wr%2FvXWCXg4w%3D%3D.dL9hbaxDZJO1R%2BZQs%2BbqKZPABaATK1hXjJepAZdRZu%2BBK3zPYjCgOha1EhZcOUQF" rel="nofollow" target="_blank">https://github.com/TapXWorld/ChinaTextbook</a></p><p>💡 <strong>简介</strong>：这是一个开源的中国教育资源项目，提供从小学到大学的数学教材，并提供文件合并程序以解决GitHub文件拆分问题，支持免费获取教育资源。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>399</td></tr><tr><td>⭐ Stars</td><td>56131</td></tr><tr><td>⚒️ Forks</td><td>12538</td></tr><tr><td>💻 Language</td><td>Roff</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>提供免费优质教育资源，促进义务教育普及</li><li>覆盖从小学到大学的完整数学学习资料体系</li><li>提供文件合并工具，解决大文件拆分问题</li><li>支持国内外用户便捷下载资源</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=e8XdA7%2Br68sq%2B2%2BKH287PQ%3D%3D.aU4wpgEfs9VaoxJtItES9zwU7zYbYcc%2BEP1rqlSbdfjiF0WInop64D4Q5H2haPno" rel="nofollow" target="_blank">yeongpin /cursor-free-vip</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=8LqhZAuRLHZ3zhzZFAkomw%3D%3D.MoIWcVleAmFkKmce%2FrdFoV3WdNTW5RO7e3CgzoDdnK91udXiwDnys%2Fsgw4gkGUy3" rel="nofollow" target="_blank">https://github.com/yeongpin/cursor-free-vip</a></p><p>💡 <strong>简介</strong>：Cursor Free VIP是一款支持Windows、macOS和Linux系统的工具，可重置Cursor配置，提供多语言支持，用于学习和研究，需以管理权限运行并保持最新版本。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>358</td></tr><tr><td>⭐ Stars</td><td>41585</td></tr><tr><td>⚒️ Forks</td><td>5014</td></tr><tr><td>💻 Language</td><td>Python</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>多平台支持Windows/macOS/Linux</li><li>多语言支持英文、简体中文等</li><li>可重置Cursor配置</li><li>自动化脚本便捷安装使用</li></ul><hr/><h2>🚀 <a href="https://link.segmentfault.com/?enc=FD9Sk3M7I8Pysj128ujE8w%3D%3D.ORrM4Giai8Fw5hL%2FeEOH7VG3kvcpvceOjnF4NzNe9Tk%3D" rel="nofollow" target="_blank">nvm-sh /nvm</a></h2><blockquote><p>🔗 <strong>链接</strong>: <a href="https://link.segmentfault.com/?enc=j03vpgcnFUSHZVnEtBdbxQ%3D%3D.jVR8jgNBXQPaFwp8jianxxM9dbY%2FViT2vNbo4ycHMzw%3D" rel="nofollow" target="_blank">https://github.com/nvm-sh/nvm</a></p><p>💡 <strong>简介</strong>：nvm是一个Node.js版本管理器，允许用户快速安装和使用不同版本的Node.js，支持POSIX兼容shell，适用于Unix、macOS和Windows WSL平台。</p></blockquote><h3>📊 项目概览</h3><table><thead><tr><th>项目</th><th>值</th></tr></thead><tbody><tr><td>📈 Rise</td><td>79</td></tr><tr><td>⭐ Stars</td><td>89195</td></tr><tr><td>⚒️ Forks</td><td>9554</td></tr><tr><td>💻 Language</td><td>Shell</td></tr></tbody></table><h3>✨ 核心优势</h3><ul><li>支持多版本Node.js安装与切换</li><li>兼容多平台（Unix、macOS、Windows WSL）</li><li>支持POSIX兼容shell（sh、bash、zsh等）</li><li>提供便捷安装与升级脚本</li></ul>]]></description></item><item>    <title><![CDATA[（小程序查看DWG）在线CAD中的“组”]]></title>    <link>https://segmentfault.com/a/1190000047399880</link>    <guid>https://segmentfault.com/a/1190000047399880</guid>    <pubDate>2025-11-14 16:09:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在使用CAD工具进行绘图时，面对复杂的图形结构，如何高效地管理多个对象成为提升工作效率的关键。CAD提供的“组”功能，正是为解决这一问题而设计的实用工具。本文将全面介绍 mxcad 中”组“的概念，以及如何实现组相关的功能开发。</p><h2>一、什么是“组”（Group）？</h2><p>在CAD中，<strong>组（Group）</strong> 是指将多个图形对象逻辑地组合在一起，形成一个可被统一操作的集合。组不会创建新的图元实体，也不会改变对象本身的几何属性，仅是一种<strong>命名的对象集合</strong>，组对象包含特点如下：</p><ul><li>组内的对象保持独立，可单独编辑。</li><li>选择组中任意一个对象时，整个组可被选中（取决于系统设置）。</li><li>每个组有唯一的名称，便于识别和管理。</li><li>支持嵌套：一个组可以包含另一个组，形成层级结构。</li><li>组不作为独立实体存储在图形数据库中，仅作为对象的逻辑关联存在。</li></ul><h2>二、组的核心功能开发</h2><h3>1. 创建组</h3><p>该功能流程是从用户执行“创建组”命令开始。首先，系统初始化相关变量（如组名、描述和对象列表），并获取当前图形数据库中的组管理字典。<br/>随后进入主循环，提示用户“选择对象”。用户可以通过点击或框选方式选择一个或多个图形对象，所选对象的ID将被保存到临时列表中。<br/>在选择过程中，用户可随时输入关键字进行设置：</p><ul><li>输入 <strong>N（名称）</strong>：进入命名流程，系统提示“输入编组名”。此时可输入 <code>[查询(A)]</code> 来查看已存在的组名；若输入 <code>*</code> 或直接回车，则列出所有组；否则查询指定组信息。输入名称后，系统检查是否重名，若无冲突则保存名称并返回选择状态。</li><li>输入 <strong>D（说明）</strong>：进入说明设置，提示“输入编组说明”，用户输入的文本将作为该组的描述信息。</li></ul><p>当用户完成选择并按 <strong>回车或空格键</strong> 确认后，系统开始创建组：</p><ul><li>首先检查所选对象中是否有成员已属于其他组。</li><li>若存在此类情况，则弹出确认提示：“包含相同对象的组已经存在。仍要创建新的组？&lt;N&gt;”，并提供“是(Y)/否(N)”选项。</li><li>若用户选择“否”或取消操作，命令终止。</li><li>若用户确认继续或无冲突，则调用底层API创建组，并将之前输入的描述信息赋值给新组。</li></ul><p>最后，组创建完成，系统退出循环，命令执行结束。整个流程支持ESC中断或新命令打断，确保操作的安全性和灵活性。</p><p>根据上述流程调用 mxcad 内部API接口实现方法如下：</p><pre><code class="ts">import { McDbEntity, McDbGroup, McDbPolyline, McGePoint3d, McObjectId, MxCADSelectionSet, MxCADUiPrKeyWord, MxCADUiPrPoint, MxCADUiPrString, MxCADUtility, MxCpp } from "mxcad";
import { DetailedResult, MxFun, MrxDbgUiPrBaseReturn } from "mxdraw";
interface GroupObject {
    name: string,
    group: McDbGroup
}
// 根据实体查找组
const getGroupForEntity = (entity: McDbEntity): GroupObject[] =&gt; {
    const database = MxCpp.getCurrentDatabase()
    const groupDict = database.GetGroupDictionary()
    const handle = entity.getHandle()
    const groupNames = groupDict.getAllObjectName()
    const length = groupNames.length();
    let groupArr: GroupObject[] = [];
    for (let index = 0; index &lt; length; index++) {
        const groupName = groupNames.at(index);
        const groupId = groupDict.getAt(groupName)
        const group = groupId.getMcDbObject() as McDbGroup
        if (!group) continue;
        const entityIds = group.getAllEntityId();
        entityIds.forEach(entityId =&gt; {
            if (entityId.getMcDbEntity()?.getHandle() === handle) groupArr.push({ name: groupName, group })
        });
    };
    return groupArr
}
// 创建组
async function Mx_Group() {
  let description = ""
  let ids: McObjectId[] = [];
  const database = MxCpp.getCurrentDatabase();
  const groupDict = database.GetGroupDictionary();
  const mxcad = MxCpp.getCurrentMxCAD();
  // 设定未命名组名
  const groupNames = groupDict.getAllObjectName();
  let num = 0;
  groupNames.forEach(item =&gt; {
    if (/^\*/.test(item)) {
      num += 1;
    }
  });
  let name: string = `*A${num + 1}`;
  // 创建组
  const createGroup = async () =&gt; {
    const isPresence = ids.some((id) =&gt; {
      return database.getEntitiesInTheGroup(id).length !== 0
    })
    if (isPresence) {
      const getKey = new MxCADUiPrKeyWord();
      getKey.setMessage(`包含相同对象的组已经存在。仍要创建新的组？&lt;N&gt;`);
      getKey.setKeyWords(`[是(Y)/否(N)]`);
      const key = await getKey.go();
      ids.forEach(id =&gt; {
        id.getMcDbEntity().highlight(false);
      })
      mxcad.updateDisplay();
      if (key?.toLocaleUpperCase() === "N") {
        return
      }
      if (!key) return
    }
    if (database.CreateGroup(ids, name)) {
      const groupId = groupDict.getAt(name)
      const group = groupId.getMcDbObject() as McDbGroup;
      if (description) group.description = description;
      if (/^\*/.test(name)) {
        MxPluginContext.useMessage().success('未命名组已创建');
      } else {
        MxPluginContext.useMessage().success(`组${name}已创建`);
      }
      ids.forEach(id =&gt; {
        id.getMcDbEntity().highlight(false);
      })
      mxcad.updateDisplay();
    };
  };
  while (true) {
    const getEntityPt = new MxCADUiPrPoint();
    getEntityPt.setMessage('选择对象');
    getEntityPt.setKeyWords(`[名称(N)/说明(D)]`);
    getEntityPt.setDisableOsnap(true);
    getEntityPt.setDisableDynInput(true);
    getEntityPt.disableAllTrace(true);
    const hoverSelectEnts: McDbEntity[] = [];
    getEntityPt.setUserDraw((pt, pw) =&gt; {
      if (hoverSelectEnts.length) hoverSelectEnts.forEach(ent =&gt; ent.highlight(false));
      hoverSelectEnts.length = 0;
      const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
      if (entId.isValid() &amp;&amp; !ids.map(item =&gt; item.id).includes(entId.id)) {
        const ent = entId.getMcDbEntity();
        const arr = getGroupForEntity(ent);
        if (arr.length) {
          const group = arr[0].group;
          group.getAllEntityId().forEach(id =&gt; {
            const ent = id.getMcDbEntity();
            ent.highlight(true);
            hoverSelectEnts.push(ent)
          })
        } else {
          ent.highlight(true);
          hoverSelectEnts.push(ent)
        }
      }
    });
    const pt = await getEntityPt.go();
    hoverSelectEnts.forEach(ent =&gt; ent.highlight(false));
    // 如果选择关键字，则执行相关操作
    if (getEntityPt.getStatus() == MrxDbgUiPrBaseReturn.kKeyWord) {
      if (getEntityPt.isKeyWordPicked("N")) {
        while (true) {
          const getName = new MxCADUiPrString()
          getName.setMessage("输入编组名")
          getName.setKeyWords(`[查询(A)]`)
          const str = await getName.go()
          if (getName.getDetailedResult() === DetailedResult.kCodeAbort || getName.getDetailedResult() === DetailedResult.kEcsIn || getName.getDetailedResult() === DetailedResult.kNewCommadIn) return
          if (getEntityPt.getDetailedResult() === DetailedResult.kNullEnterIn || getEntityPt.getDetailedResult() === DetailedResult.kNullSpaceIn || getEntityPt.getDetailedResult() === DetailedResult.kMouseRightIn) {
            return createGroup()
          }
          if (getName.isKeyWordPicked("A")) {
            getName.setMessage("请输入要列出的编码组名"+ "&lt;*&gt;")
            getName.setKeyWords("")
            const name = await getName.go();
            if (getName.getDetailedResult() === DetailedResult.kCodeAbort || getName.getDetailedResult() === DetailedResult.kEcsIn || getName.getDetailedResult() === DetailedResult.kNewCommadIn) return
            if (name &amp;&amp; name !== "*") {
              const groupId = groupDict.getAt(name)
              const group = groupId.getMcDbObject() as McDbGroup
              MxFun.acutPrintf(`\n 定义的编组:`)
              if (group) {
                MxFun.acutPrintf(`\n${group.name}`)
              }
            }
            else if (name === "*" || getName.getDetailedResult() === DetailedResult.kNullEnterIn || getName.getDetailedResult() === DetailedResult.kNullSpaceIn) {
              const groupIds = groupDict.getAllObject()
              MxFun.acutPrintf(`\n 定义的编组:`)
              groupIds.forEach((groupId) =&gt; {
                const group = groupId.getMcDbObject() as McDbGroup
                group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
              })
            }
            continue;
          }
          if (!str) return;
          if (/^\*/.test(str)) {
            MxFun.acutPrintf(`*无效`);
            continue;
          }
          const groupId = groupDict.getAt(str)
          const group = groupId.getMcDbObject() as McDbGroup
          if (group &amp;&amp; groupId.isValid()) {
            MxFun.acutPrintf(`编组${str} 已经存在`);
            continue;
          }
          name = str;
          if (ids.length) {
            ids.forEach(id =&gt; {
              const ent = id.getMcDbEntity();
              ent.highlight(false);
            })
            return createGroup();
          } else {
            break;
          }
        }
      } else if (getEntityPt.isKeyWordPicked('D')) {
        const getName = new MxCADUiPrString()
        getName.setMessage("输入编组说明")
        const str = await getName.go();
        if (!str) break;
        description = str
        continue;
      }
    } else if (getEntityPt.getStatus() === MrxDbgUiPrBaseReturn.kNone) {
      if (!ids.length) {
        return MxPluginContext.useMessage().success('未选择对象，未创建编组');
      } else {
        ids.forEach(id =&gt; {
          const ent = id.getMcDbEntity();
          ent.highlight(false);
        })
        return createGroup();
      }
    } else if (getEntityPt.getStatus() === MrxDbgUiPrBaseReturn.kCancel) {
      ids.forEach(id =&gt; {
        const ent = id.getMcDbEntity();
        ent.highlight(false);
      })
      return
    } else {
      // 判断是否选中实体
      if (pt &amp;&amp; hoverSelectEnts.length) {
        const selectIds = hoverSelectEnts.map(item =&gt; {
          item.highlight(true);
          return item.getObjectID()
        })
        ids.push(...selectIds);
        continue;
      } else if (pt &amp;&amp; !hoverSelectEnts.length) {
        getEntityPt.setUserDraw((point, pw) =&gt; {
          const pts = [pt, new McGePoint3d(pt.x, point.y), point, new McGePoint3d(point.x, pt.y)]
          // 设置范围框颜色即位置
          let pl = new McDbPolyline();
          pl.isClosed = true;
          pts.forEach(pt =&gt; pl.addVertexAt(pt));
          pw.setColor(0xFFFFFF);
          pw.drawMcDbEntity(pl);
          // 动态绘制矩形填充框
          const geometry = new THREE.BufferGeometry();
          geometry.setFromPoints([
            new THREE.Vector3(pt.x, pt.y, pt.z),
            new THREE.Vector3(pt.x, point.y, point.z),
            new THREE.Vector3(point.x, point.y, point.z),
            new THREE.Vector3(point.x, pt.y, pt.z)
          ]);
          geometry.attributes.uv = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), 2);
          geometry.setIndex([0, 1, 2, 0, 2, 3]);
          // 创建材质（半透明的颜色）
          const material = new THREE.MeshBasicMaterial({
            color: 0x004D00,
            transparent: true,
            opacity: 0.5,
            side: THREE.DoubleSide
          });
          const mesh = new THREE.Mesh(geometry, material);
          pw.drawEntity(mesh);
        });
        const nextPt = await getEntityPt.go();
        if (!nextPt) break;
        const ss = new MxCADSelectionSet();
        await ss.crossingSelect(pt.x, pt.y, nextPt.x, nextPt.y);
        ss.forEach(id =&gt; {
          if (!ids.map(i =&gt; i.id).includes(id.id)) {
            const ent = id.getMcDbEntity();
            const arr = getGroupForEntity(ent);
            if (arr.length) {
              const group = arr[0].group;
              group.getAllEntityId().forEach(id =&gt; {
                id.getMcDbEntity().highlight(true)
                ids.push(id);
              })
            } else {
              ent.highlight(true);
              ids.push(id);
            }
          }
        });
        continue;
      } else {
        continue;
      };
    }
  }
}</code></pre><h3>2. 解除组</h3><p>解除组的功能流程如下：<br/>命令启动后，系统提示用户“选择组”，并支持通过关键字 <code>[名称(N)]</code> 切换为按名称分解模式。在用户操作过程中，系统启用悬停预览功能：当鼠标移动到某个对象上时，会自动查询该对象所属的组，并高亮显示该组内的所有成员对象，便于用户直观判断将要操作的范围。<br/>接下来，根据用户的选择进入不同分支：</p><p>1.<strong>若用户输入 N（名称）</strong>：<br/>   - 进入“按名称分解”模式，提示“输入编组名”。<br/>   - 支持输入关键字 <code>[查询(A)]</code>：</p><ul><li>若输入 <code>A</code>，可进一步输入要查询的组名；<br/>   - 输入 <code>*</code> 或直接回车，则列出当前图形中所有已定义的组名；<br/>   - 输入具体名称，则检查并显示该组是否存在。<br/>   - 用户输入组名后，系统查找对应组：<br/>   - 若存在，执行分解操作（清空组内对象并从组字典中移除），提示“组 已分解”；<br/>   - 若不存在，提示“编组 未定义”，并允许重新输入。</li></ul><p>2.<strong>若用户点击某个对象</strong>：<br/>   - 系统获取该对象，并查询其所属的所有组（一个对象可能属于多个组）。<br/>   - 若对象仅属于一个组，则直接选中该组，准备分解。<br/>   - 若对象属于多个组，则进入选择流程：<br/>     - 提示“对象是多个组的成员&lt;接受&gt;”，提供 <code>[接受(A)/下一个(N)]</code> 选项；<br/>     - 选择 <code>A</code>：接受当前高亮的组；<br/>     - 选择 <code>N</code>：切换到下一个组，并更新高亮显示；<br/>     - 可循环切换，直到用户确认或取消。<br/>   - 确定目标组后，记录其名称。</p><p>最后，系统根据选定的组名执行分解操作：</p><ul><li>从组字典中获取该组对象；</li><li>调用 <code>clear()</code> 清空组内成员引用；</li><li>调用 <code>remove()</code> 从字典中删除该组；</li><li>提示“组 已分解”或“对象不是组成员”（如未选中有效组）。</li></ul><p>操作完成后，清除所有高亮显示的对象，确保界面恢复整洁，命令结束。其具体实现代码如下：</p><pre><code class="ts">import { McDbEntity, McDbGroup, McDbPolyline, McGePoint3d, McObjectId, MxCADSelectionSet, MxCADUiPrKeyWord, MxCADUiPrPoint, MxCADUiPrString, MxCADUtility, MxCpp } from "mxcad";
import { DetailedResult, MxFun, MrxDbgUiPrBaseReturn } from "mxdraw";
// 解除编组
async function Mx_Ungroup() {
    const ents: McDbEntity[] = [];
    let groupArr: GroupObject[] = [];
    let name!: string;
    const database = MxCpp.getCurrentDatabase();
    const groupDict = database.GetGroupDictionary();
    let index: number = 0;
    const getEnt = new MxCADUiPrEntity();
    getEnt.setMessage('选择组');
    getEnt.setKeyWords(`[名称(N)]`);
    getEnt.setUserDraw((pt, pw) =&gt; {
        ents.forEach(ent =&gt; ent.highlight(false));
        ents.length = 0;
        const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
        if (entId.isValid()) {
            const ent = entId.getMcDbEntity();
            groupArr = getGroupForEntity(ent);//getGroupForEntity参考上述创建组内代码
            if (groupArr.length) {
                const group = groupArr[index].group;
                group.getAllEntityId().forEach(id =&gt; {
                    const entity = id.getMcDbEntity();
                    entity.highlight(true);
                    ents.push(entity);
                })
            }
        }
    });
    const entId = await getEnt.go();
    if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
        if (getEnt.isKeyWordPicked('N')) {
            while (true) {
                const getString = new MxCADUiPrString();
                getString.setMessage('输入编组名');
                getString.setKeyWords(`[查询(A)]`);
                const str = await getString.go();
                if (getString.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                    // 删除组
                    const groupId = groupDict.getAt(str);
                    const group = groupId.getMcDbObject() as McDbGroup;
                    if (groupId.isValid() &amp;&amp; group) {
                        group.clear();
                        groupDict.remove(str);
                        MxPluginContext.useMessage().success('组 ' + str + ' 已分解');
                        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
                        return;
                    } else {
                        MxFun.acutPrintf('编组 ' + str + ' 未定义');
                        continue;
                    }
                } else if (getString.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
                    // 查询组
                    getString.setMessage("请输入要列出的编码组名" + "&lt;*&gt;")
                    getString.setKeyWords("")
                    const name = await getString.go();
                    if (getString.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                        if (name &amp;&amp; name !== "*") {
                            const groupId = groupDict.getAt(name)
                            const group = groupId.getMcDbObject() as McDbGroup
                            MxFun.acutPrintf(`\n 定义的编组:`)
                            if (group) {
                                MxFun.acutPrintf(`\n${group.name}`)
                            }
                        } else if (name === "*") {
                            const groupIds = groupDict.getAllObject()
                            MxFun.acutPrintf(`\n 定义的编组:`)
                            groupIds.forEach((groupId) =&gt; {
                                const group = groupId.getMcDbObject() as McDbGroup
                                group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                            })
                        }
                    } else if (getString.getStatus() === MrxDbgUiPrBaseReturn.kNone) {
                        const groupIds = groupDict.getAllObject()
                        MxFun.acutPrintf(`\n 定义的编组:`)
                        groupIds.forEach((groupId) =&gt; {
                            const group = groupId.getMcDbObject() as McDbGroup
                            group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                        })
                    }
                    continue;
                }
            }
        }
    } else if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
        if (groupArr.length === 1) {
            name = groupArr[0].name
        } else if (groupArr.length &gt; 1) {
            while (true) {
                const getKeys = new MxCADUiPrKeyWord();
                getKeys.setMessage('对象是多个组的成员&lt;接受&gt;')
                getKeys.setKeyWords('[接受(A)/下一个(N)]');
                let key = await getKeys.go();
                if (key === "A") {
                    name = groupArr[index].name;
                    break;
                } else if (key === "N") {
                    ents.forEach(ent =&gt; ent.highlight(false));
                    ents.length = 0;
                    index + 1 &gt; groupArr.length - 1 ? index = 0 : index += 1;
                    const res = groupArr[index];
                    res.group.getAllEntityId().forEach(id =&gt; {
                        const ent = id.getMcDbEntity();
                        ent.highlight(true);
                        ents.push(ent);
                    });
                    continue;
                } else {
                    if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
                    return;
                }
            }
        }
        if (name) {
            const groupId = groupDict.getAt(name)
            const group = groupId.getMcDbObject() as McDbGroup
            if (group) {
                group.clear();
                groupDict.remove(name);
                MxPluginContext.useMessage().success(`组 ${name} 已分解`);
            } else {
                MxPluginContext.useMessage().success('对象不是组成员');
            }
        } else {
            MxPluginContext.useMessage().success('对象不是组成员');
        };
        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
    }
}</code></pre><h3>3. 编辑组</h3><p>编辑图形中已有对象组（Group）的交互式功能。其主要功能是允许用户通过选择对象或输入组名的方式，找到目标组，并对其进行<strong>添加成员、删除成员或重命名</strong>等操作。<br/>命令启动后，系统首先提示“选择组”，并支持通过关键字 <code>[名称(N)]</code> 切换为按名称选择模式。在用户移动鼠标时，系统会启用悬停预览功能：自动检测光标下的对象，查询其所属的组，并高亮显示该组内的所有成员，帮助用户直观判断当前将要操作的对象范围。</p><p>如果用户点击了一个对象，系统会获取该对象所属的所有组：</p><ul><li>若对象不属于任何组，则提示“对象不是组成员”；</li><li>若只属于一个组，则直接进入编辑操作；</li><li>若属于多个组，则提示“对象是多个组的成员&lt;接受&gt;”，并提供 <code>[接受(A)/下一个(N)]</code> 选项，用户可循环切换高亮不同的组，直到确认目标组。</li></ul><p>如果用户选择 <code>[名称(N)]</code> 模式，则进入按名称编辑流程：</p><ul><li>提示“输入组的名称”，并支持 <code>[查询(A)]</code> 关键字；</li><li>输入 <code>A</code> 后可查看所有组名（输入 <code>*</code>）或查询特定组是否存在；</li><li>输入有效组名后，若组存在，则加载并高亮其成员，进入编辑；若不存在，则提示“编组 xxx 不存在”，并允许重新输入。<br/>确定目标组后，系统弹出操作菜单：<code>[添加对象(A)/删除对象(R)/重命名(REN)]</code>。</li><li><strong>添加对象（A）</strong>：用户可通过单击或框选方式选择要加入的对象。系统会动态高亮预览可添加的对象（不包括已存在于组内的对象），支持窗口和交叉选择，完成后将所选对象追加到组中，并提示“添加对象成功！”。</li><li><strong>删除对象（R）</strong>：用户选择组内对象进行移除。系统仅允许删除当前组中的成员，选择后会从组中剔除这些对象，并通过清空后重新添加剩余对象的方式更新组内容。</li><li><p><strong>重命名（REN）</strong>：提示用户输入新名称。支持再次使用 <code>[查询(A)]</code> 查看现有组名以避免冲突。若新名称已被其他组使用，则提示“编组 xxx 已经存在”并要求重新输入；否则更新组名，并提示“修改组名成功”。<br/>实现上述流程的具体功能代码如下：</p><pre><code class="ts">import { McDbEntity, McDbGroup, McDbPolyline, McGePoint3d, McObjectId, MxCADSelectionSet, MxCADUiPrKeyWord, MxCADUiPrPoint, MxCADUiPrString, MxCADUtility, MxCpp } from "mxcad";
import { DetailedResult, MxFun, MrxDbgUiPrBaseReturn } from "mxdraw";
// 编辑组
async function Mx_Groupedit() {
    const ents: McDbEntity[] = [];//高亮实体数组
    let groupArr: GroupObject[] = [];//实体组集合
    let index: number = 0;
    let name: string = '';
    const database = MxCpp.getCurrentDatabase();
    const groupDict = database.GetGroupDictionary();
    const mxcad = MxCpp.getCurrentMxCAD();
    const editGroup = async () =&gt; {
        // 选中目标组
        if (groupArr.length === 1) {
            name = groupArr[0].name
        } else if (groupArr.length &gt; 1) {
            while (true) {
                const getKeys = new MxCADUiPrKeyWord();
                getKeys.setMessage('对象是多个组的成员&lt;接受&gt;')
                getKeys.setKeyWords(`[接受(A)/下一个(N)]`);
                let key = await getKeys.go();
                if (key === "A") {
                    name = groupArr[index].name;
                    break;
                } else if (key === "N") {
                    ents.forEach(ent =&gt; ent.highlight(false));
                    ents.length = 0;
                    index + 1 &gt; groupArr.length - 1 ? index = 0 : index += 1;
                    const res = groupArr[index];
                    res.group.getAllEntityId().forEach(id =&gt; {
                        const ent = id.getMcDbEntity();
                        ent.highlight(true);
                        ents.push(ent);
                    });
                    continue;
                } else {
                    continue;
                }
            }
        } else {
            name = '';
        }
        // 操作目标组
        if (name) {
            const groupId = groupDict.getAt(name)
            const group = groupId.getMcDbObject() as McDbGroup
            if (group) {
                // 进入编辑组
                const getKey = new MxCADUiPrKeyWord();
                getKey.setMessage(t('输入选项'));
                getKey.setKeyWords(`[添加对象(A)/删除对象(R)/重命名(REN)]`);
                const key = await getKey.go();
                if (!key) return;
                if (key === 'A') {
                    const selectIds: McObjectId[] = [];
                    // 添加对象
                    while (true) {
                        const getEntityPt = new MxCADUiPrPoint();
                        getEntityPt.setMessage('选择要添加到编组的对象');
                        getEntityPt.setDisableOsnap(true);
                        getEntityPt.setDisableDynInput(true);
                        getEntityPt.disableAllTrace(true);
                        const hoverSelectEnts: McDbEntity[] = [];
                        getEntityPt.setUserDraw((pt, pw) =&gt; {
                            if (hoverSelectEnts.length) hoverSelectEnts.forEach(ent =&gt; {
                                if (!ents.map(i =&gt; i.getObjectID().id).includes(ent.getObjectID().id)) ent.highlight(false);
                            });
                            hoverSelectEnts.length = 0;
                            const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
                            if (entId.isValid() &amp;&amp; !selectIds.map(item =&gt; item.id).includes(entId.id) &amp;&amp; !group.has(entId)) {
                                const ent = entId.getMcDbEntity();
                                const arr = getGroupForEntity(ent);
                                if (arr.length) {
                                    const group = arr[0].group;
                                    group.getAllEntityId().forEach(id =&gt; {
                                        const ent = id.getMcDbEntity();
                                        ent.highlight(true);
                                        hoverSelectEnts.push(ent)
                                    })
                                } else {
                                    ent.highlight(true);
                                    hoverSelectEnts.push(ent)
                                }
                            }
                        });
                        const pt = await getEntityPt.go();
                        if (!pt) {
                            if (hoverSelectEnts.length) hoverSelectEnts.forEach(item =&gt; item.highlight(false));
                            break;
                        } else {
                            // 判断是否选中实体
                            if (hoverSelectEnts.length) {
                                if (hoverSelectEnts.length) {
                                    hoverSelectEnts.forEach(ent =&gt; {
                                        selectIds.push(ent.getObjectID());
                                    })
                                };
                            } else {
                                getEntityPt.setUserDraw((point, pw) =&gt; {
                                    const pts = [pt, new McGePoint3d(pt.x, point.y), point, new McGePoint3d(point.x, pt.y)]
                                    // 设置范围框颜色即位置
                                    let pl = new McDbPolyline();
                                    pl.isClosed = true;
                                    pts.forEach(pt =&gt; pl.addVertexAt(pt));
                                    pw.setColor(0xFFFFFF);
                                    pw.drawMcDbEntity(pl);
 
                                    // 动态绘制矩形填充框
                                    const geometry = new THREE.BufferGeometry();
                                    geometry.setFromPoints([
                                        new THREE.Vector3(pt.x, pt.y, pt.z),
                                        new THREE.Vector3(pt.x, point.y, point.z),
                                        new THREE.Vector3(point.x, point.y, point.z),
                                        new THREE.Vector3(point.x, pt.y, pt.z)
                                    ]);
                                    geometry.attributes.uv = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), 2);
                                    geometry.setIndex([0, 1, 2, 0, 2, 3]);
                                    // 创建材质（半透明的颜色）
                                    const material = new THREE.MeshBasicMaterial({
                                        color: 0x004D00,
                                        transparent: true,
                                        opacity: 0.5,
                                        side: THREE.DoubleSide
                                    });
                                    const mesh = new THREE.Mesh(geometry, material);
                                    pw.drawEntity(mesh);
                                });
                                const nextPt = await getEntityPt.go();
                                if (!nextPt) break;
                                const ss = new MxCADSelectionSet();
                                await ss.crossingSelect(pt.x, pt.y, nextPt.x, nextPt.y);
                                ss.forEach(id =&gt; {
                                    if (!group.has(id) &amp;&amp; !selectIds.map(i =&gt; i.id).includes(id.id)) {
                                        const ent = id.getMcDbEntity();
                                        const arr = getGroupForEntity(ent);
                                        if (arr.length) {
                                            const group = arr[0].group;
                                            group.getAllEntityId().forEach(id =&gt; {
                                                id.getMcDbEntity()?.highlight(true);
                                                selectIds.push(id);
                                            })
                                        } else {
                                            id.getMcDbEntity()?.highlight(true);
                                            selectIds.push(id);
                                        }
                                    }
                                });
                            };
                            continue;
                        }
                    };
                    if (selectIds.length) {
                        selectIds.forEach(id =&gt; {
                            id.getMcDbEntity().highlight(false);
                            group.append(id);
                        });
                        MxPluginContext.useMessage().success('添加对象成功！');
                    }
                } else if (key === 'R') {
                    const selectIds: McObjectId[] = [];
                    while (true) {
                        const getEntityPt = new MxCADUiPrPoint();
                        getEntityPt.setMessage('选择要从编组中删除的对象');
                        getEntityPt.setDisableOsnap(true);
                        getEntityPt.setDisableDynInput(true);
                        getEntityPt.disableAllTrace(true);
                        const hoverSelectEnts: McDbEntity[] = [];
                        getEntityPt.setUserDraw((pt, pw) =&gt; {
                            const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
                            hoverSelectEnts.forEach(e =&gt; {
                                if (!group.has(e.getObjectID())) {
                                    e.highlight(false)
                                }
                            });
                            hoverSelectEnts.length = 0;
                            if (entId.isValid() &amp;&amp; !selectIds.map(i =&gt; i.id).includes(entId.id)) {
                                const ent = entId.getMcDbEntity();
                                ent.highlight(true);
                                hoverSelectEnts.push(ent)
                            }
                        });
                        const pt = await getEntityPt.go();
                        if (!pt) {
                            break;
                        } else {
                            // 判断是否选中实体
                            if (hoverSelectEnts.length) {
                                hoverSelectEnts.forEach(ent =&gt; {
                                    ent.highlight(false);
                                    if (group.has(ent.getObjectID())) {
                                        selectIds.push(ent.getObjectID())
                                    } else {
                                        MxFun.acutPrintf('对象不是组内元素，无法删除')
                                    }
                                })
                            } else {
                                getEntityPt.setUserDraw((point, pw) =&gt; {
                                    const pts = [pt, new McGePoint3d(pt.x, point.y), point, new McGePoint3d(point.x, pt.y)]
                                    // 设置范围框颜色即位置
                                    let pl = new McDbPolyline();
                                    pl.isClosed = true;
                                    pts.forEach(pt =&gt; pl.addVertexAt(pt));
                                    pw.setColor(0xFFFFFF);
                                    pw.drawMcDbEntity(pl);
 
                                    // 动态绘制矩形填充框
                                    const geometry = new THREE.BufferGeometry();
                                    geometry.setFromPoints([
                                        new THREE.Vector3(pt.x, pt.y, pt.z),
                                        new THREE.Vector3(pt.x, point.y, point.z),
                                        new THREE.Vector3(point.x, point.y, point.z),
                                        new THREE.Vector3(point.x, pt.y, pt.z)
                                    ]);
                                    geometry.attributes.uv = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), 2);
                                    geometry.setIndex([0, 1, 2, 0, 2, 3]);
                                    // 创建材质（半透明的颜色）
                                    const material = new THREE.MeshBasicMaterial({
                                        color: 0x004D00,
                                        transparent: true,
                                        opacity: 0.5,
                                        side: THREE.DoubleSide
                                    });
                                    const mesh = new THREE.Mesh(geometry, material);
                                    pw.drawEntity(mesh);
                                });
                                const nextPt = await getEntityPt.go();
                                if (!nextPt) break;
                                const ss = new MxCADSelectionSet();
                                await ss.crossingSelect(pt.x, pt.y, nextPt.x, nextPt.y);
                                ss.forEach(id =&gt; {
                                    if (group.has(id)) {
                                        const ent = id.getMcDbEntity();
                                        ent.highlight(false);
                                        selectIds.push(ent.getObjectID());
                                    }
                                });
                            };
                            continue;
                        }
                    };
                    if (selectIds.length) {
                        const newIds = ents.filter(ent =&gt; !selectIds.map(i =&gt; i.id).includes(ent.getObjectID().id)).map(ent =&gt; ent.getObjectID());
                        group.clear();
                        group.appendArray(newIds);
                    }
                } else if (key === 'REN') {
                    while (true) {
                        const getName = new MxCADUiPrString()
                        getName.setMessage("输入组的新名称" + `&lt;${group.name}&gt;`)
                        getName.setKeyWords('查询(A)]')
                        const str = await getName.go();
                        if (getName.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
                            if (getName.isKeyWordPicked("A")) {
                                getName.setMessage("请输入要列出的编码组名" + "&lt;*&gt;")
                                const name = await getName.go();
                                if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                                    if (name &amp;&amp; name !== "*") {
                                        const groupId = groupDict.getAt(name)
                                        const group = groupId.getMcDbObject() as McDbGroup
                                        MxFun.acutPrintf('定义的编组')
                                        if (group) {
                                            MxFun.acutPrintf(`\n${group.name}`)
                                        }
                                    } else if (name === "*") {
                                        const groupIds = groupDict.getAllObject()
                                        MxFun.acutPrintf(`\n 定义的编组:`)
                                        groupIds.forEach((groupId) =&gt; {
                                            const group = groupId.getMcDbObject() as McDbGroup
                                            group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                                        })
                                    }
                                } else {
                                    const groupIds = groupDict.getAllObject()
                                    MxFun.acutPrintf(`\n 定义的编组:`)
                                    groupIds.forEach((groupId) =&gt; {
                                        const group = groupId.getMcDbObject() as McDbGroup
                                        group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                                    })
                                }
                                continue;
                            }
                        } else if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                            const groupId = groupDict.getAt(str)
                            const _group = groupId.getMcDbObject() as McDbGroup
                            if (_group &amp;&amp; groupId.isValid()) {
                                MxFun.acutPrintf(`编组 ${str} 已经存在}`);
                                continue;
                            } else {
                                group.name = str;
                                MxPluginContext.useMessage().success('修改组名成功');
                                break;
                            }
                        } else {
                            break;
                        }
                    }
                }
            } else {
                MxPluginContext.useMessage().success('对象不是组成员');
            }
        }
        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
        mxcad.updateDisplay();
    }
    const getEnt = new MxCADUiPrEntity();
    getEnt.setMessage('选择组');
    getEnt.setKeyWords('[名称(N)]');
    getEnt.setUserDraw((pt, pw) =&gt; {
        ents.forEach(ent =&gt; ent.highlight(false));
        ents.length = 0;
        const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
        if (entId.isValid()) {
            const ent = entId.getMcDbEntity();
            groupArr = getGroupForEntity(ent);
            if (groupArr.length) {
                const group = groupArr[index].group;
                group.getAllEntityId().forEach(id =&gt; {
                    const entity = id.getMcDbEntity();
                    entity.highlight(true);
                    ents.push(entity);
                })
            }
        }
    });
    const entId = await getEnt.go();
    if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
        if (getEnt.isKeyWordPicked('N')) {
            // 选择关键字
            while (true) {
                const getName = new MxCADUiPrString()
                getName.setMessage("输入组的名称")
                getName.setKeyWords('[查询(A)]')
                const str = await getName.go();
                if (getName.getStatus() === MrxDbgUiPrBaseReturn.kKeyWord) {
                    if (getName.isKeyWordPicked("A")) {
                        getName.setMessage("请输入要列出的编码组名" + "&lt;*&gt;")
                        getName.setKeyWords("")
                        const name = await getName.go();
                        if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                            if (name &amp;&amp; name !== "*") {
                                const groupId = groupDict.getAt(name)
                                const group = groupId.getMcDbObject() as McDbGroup
                                MxFun.acutPrintf('定义的编组')
                                if (group) {
                                    MxFun.acutPrintf(`\n${group.name}`)
                                }
                            } else if (name === "*") {
                                const groupIds = groupDict.getAllObject()
                                MxFun.acutPrintf(`\n 定义的编组:`)
                                groupIds.forEach((groupId) =&gt; {
                                    const group = groupId.getMcDbObject() as McDbGroup
                                    group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                                })
                            }
                        } else {
                            const groupIds = groupDict.getAllObject()
                            MxFun.acutPrintf(`\n 定义的编组:`)
                            groupIds.forEach((groupId) =&gt; {
                                const group = groupId.getMcDbObject() as McDbGroup
                                group &amp;&amp; MxFun.acutPrintf(`\n ${group.name}`)
                            })
                        }
                        continue;
                    }
                } else if (getName.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
                    const groupId = groupDict.getAt(str)
                    const group = groupId.getMcDbObject() as McDbGroup
                    if (group &amp;&amp; groupId.isValid()) {
                        group.getAllEntityId().forEach(id =&gt; {
                            const ent = id.getMcDbEntity();
                            ent.highlight(true);
                            ents.push(ent);
                        })
                        groupArr.push({ name: group.name, group });
                        editGroup()
                        break;
                    } else {
                        MxFun.acutPrintf(`编组 ${str} 不存在`);
                        continue;
                    };
                } else {
                    break;
                }
            }
        }
    } else if (getEnt.getStatus() === MrxDbgUiPrBaseReturn.kOk) {
        editGroup();
    } else {
        if (ents.length) ents.forEach(ent =&gt; ent.highlight(false));
    }
}</code></pre></li></ul><h3>4. 启用或禁用组选择</h3><p>启用指定对象组的选择功能其执行过程如下：首先提示用户“请选择目标组”，并在鼠标悬停时自动检测光标下的对象，若该对象属于某个组，则实时高亮显示该组的所有成员，提供可视化反馈。用户点击对象后，系统获取其所属的第一个组，并将该组的 <code>isSelectable</code> 属性设置为 <code>true</code>，从而允许后续通过点击组内任意成员来选中整个组。最后清除高亮并刷新显示，完成设置。该方法提升了组对象的操作便捷性，适用于需要快速选中成组元素的场景。其完整代码如下：</p><pre><code class="ts">import { MxCADUiPrEntity, MxCADUtility, MxCpp} from "mxcad";
// 启用/禁用组选择
async function Mx_SetGroupSelection() {
    const ents: McDbEntity[] = [];
    let groupArr: GroupObject[] = [];
    const getEnt = new MxCADUiPrEntity();
    getEnt.setMessage('请选择目标组');
    getEnt.setUserDraw((pt, pw) =&gt; {
        ents.forEach(ent =&gt; ent.highlight(false));
        ents.length = 0;
        const entId = MxCADUtility.findEntAtPoint(pt.x, pt.y, pt.z, -1);
        if (entId.isValid()) {
            const ent = entId.getMcDbEntity();
            groupArr = getGroupForEntity(ent);
            if (groupArr.length) {
                const group = groupArr[0].group;
                group.getAllEntityId().forEach(id =&gt; {
                    const entity = id.getMcDbEntity();
                    entity.highlight(true);
                    ents.push(entity);
                })
            }
        }
    });
    const entId = await getEnt.go();
    if (groupArr.length) {
        const group = groupArr[0].group;
        group.isSelectable = true;
        ents.forEach(ent =&gt; {
            ent.highlight(false);
        })
        MxCpp.getCurrentMxCAD().updateDisplay();
    };
}</code></pre><h2>三、功能演示</h2><p><img width="723" height="478" referrerpolicy="no-referrer" src="/img/bVdm22b" alt="" title=""/></p>]]></description></item><item>    <title><![CDATA[WeaveFox「AI 艺术家」创意大赛]]></title>    <link>https://segmentfault.com/a/1190000047399892</link>    <guid>https://segmentfault.com/a/1190000047399892</guid>    <pubDate>2025-11-14 16:08:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着AI时代的到来，天马行空的灵感可以快速变为现实。11月13日，由 <strong>WeaveFox 与 SEE Conf 联合发起的「AI艺术家」创意大赛</strong> 重磅来袭！这是一场属于创作者的挑战：你可以用一句自然语言、一张设计稿、一个灵感，在几分钟内，让 AI Coding 把你的想法变成现实。</p><p>参与大赛投稿评选，不仅有价值千元豪礼相送，更能直接解锁一票难求的 SEE Conf入场资格！这一次，我们不要“空想家”，只要敢动手的“你” ——<strong>用 WeaveFox 将灵感变为现实，“你”就是下一个被看见的「AI 艺术家」！</strong></p><p><img width="723" height="424" referrerpolicy="no-referrer" src="/img/bVdm22g" alt="网页-深1112.jpg" title="网页-深1112.jpg"/></p><blockquote>为什么不容错过？</blockquote><p>✅ 顶流入场券：SEE Conf 门票售罄？邀请好友参赛就能免费得！<br/>SEE Conf是什么？是前端人每年必蹲抢破头的年度技术盛宴，今年门票更是早早售罄！这里汇聚诸多大厂技术专家，前沿框架、实战经验、行业洞见。</p><p>参与本次大赛，成功邀请 10 位好友投稿就能直接获赠 SEE Conf 门票！优秀作品更将直接登上 WeaveFox 首页参与点赞排行，你的创意不仅可能收获千元大奖，更有机会被行业大咖“翻牌”！</p><p><a href="https://link.segmentfault.com/?enc=rJ3WwfdtAdDl0u4zXjkFCQ%3D%3D.JnWzyQkWVsLANPWXuA%2FHYKfD1O%2FfZLkMbsufTJn4wes%3D" rel="nofollow" target="_blank">点击查看 SEE Conf 2025 蚂蚁终端体验科技大会详情</a></p><p>✅ 零门槛创作：WeaveFox 帮你扫清所有障碍<br/>不会写代码？没关系！没有设计经验？不影响！WeaveFox 帮你轻松越过这些门槛 ！</p><p>输入“帮我做一个能记录学习计划的 AI 小工具”，或是上传一张想要实现的设计图，WeaveFox 会帮你完成设计到开发的全链路、直接生成可上线的应用，快速将 “灵感变为现实”，让每个人都能享受创作的快感。</p><p>✅ 丰厚奖品：豪礼+荣誉双丰收<br/>参赛即有机会拿奖，福利拉满！不用担心“陪跑”，你的每一份创意都有价值：</p><p>1、人气奖（Top 7）：点赞数 TOP7 将获价值 700- 1800 元梯度豪礼，从数码周边到实用好物，实力宠粉不手软；<br/>2、创意奖（5名）：组委会实名pick“脑洞王者”，赠送价值600元的新秀丽双肩包，出门自带“技术潮人”标识；<br/>3、邀请奖（敲重点）：成功邀请10位好友投稿，直接解锁 价值近 200元的 SEE Conf 限量门票！和前端大神面对面，机会不容错过！</p><blockquote>参赛全攻略：轻松争大奖</blockquote><p>📌 关键时间：敲黑板，别错过<br/>报名开启：2025年11月13日 10:00<br/>作品截止：2025年11月23日 23:59（10天创作期，足够你打磨灵感）<br/>奖品发放：2025年12月底，以官方通知为准</p><p>📌 投稿规则：创意无限（可以任选以下推荐主题进行创作）<br/>1、推荐主题：我的AI小帮手：比如“AI 问答机器人"，"AI 翻译小帮手等”。用AI应用解决你的日常痛点；<br/>2、推荐主题：经典复刻：用AI还原童年小游戏（如贪吃蛇、俄罗斯方块），或是复刻一款你喜欢的经典应用，玩出复古新花样。</p><p>📌投稿方式：一键投稿，如此方便<br/>1、登录 WeaveFox 官网（<a href="https://link.segmentfault.com/?enc=KR4wBgJaDpi1a8E9cKMACA%3D%3D.JqxGOLWkFmMm4w0C4BIBSRokh098JzGKrvb4rYz0NL6wlSyDbW2Tjh6Y2xkKHv5k" rel="nofollow" target="_blank">https://www.weavefox.cn/?ref=seeconf/</a>）；<br/>2、用 WeaveFox 将你的创意生成应用，围绕主题调试并优化。<br/>3、在作品详情页-&gt;点击“投稿到SEE Conf「AI艺术家」创意大赛”，或在活动弹窗选择作品-&gt;立即投稿，审核通过后，即可视为参赛成功！</p><p>进入大会官网  <a href="https://link.segmentfault.com/?enc=BOMvu6SPinxcCOMFK%2F62zQ%3D%3D.fuHpLWo1CZ%2FU9vytv%2FoX8OYJJXtnLI9jr8FalwrjwJ8%3D" rel="nofollow" target="_blank">https://seeconf.antgroup.com</a>，或登录 WeaveFox 直接投稿到创意大赛 ：<a href="https://link.segmentfault.com/?enc=6HG5pDRRGLaEqmXpgjWK1w%3D%3D.ZuzoA5q9MjCUNGWX2cVbcTkMfsHk5PkHo92iaFBNvoi1XIxpqUvN6RL%2Blj4oZykk" rel="nofollow" target="_blank">https://www.weavefox.cn/?ref=seeconf</a> ，立即参与吧！</p>]]></description></item><item>    <title><![CDATA[重磅巨制！以数字孪生之名，敬国之重器：福]]></title>    <link>https://segmentfault.com/a/1190000047399899</link>    <guid>https://segmentfault.com/a/1190000047399899</guid>    <pubDate>2025-11-14 16:08:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>11月5日，我国完全自主设计建造的首艘电磁弹射型航空母舰“福建舰”正式入列，标志着中国海军迈入三航母时代。平直通长飞行甲板、电磁弹射技术、8万余吨排水量，福建舰作为全球首艘采用常规动力电磁弹射技术的航母，正式入列开启中国海军新征程。</p><p>当福建舰身披海军军旗正式入列的那一刻，中华儿女的热血与自豪在南海之滨激荡。作为军事仿真技术领域的践行者，我们深知，国之重器的高光时刻不仅是钢铁与火焰的交响，更需要以科技为笔，在数字空间镌刻下属于中国海军的时代印记。</p><p>在这个伟大时代，我们选择以手中最前沿的数字孪生技术，向国之重器致以最崇高的敬意。</p><h2>数字铸舰，复刻雄师：福建舰航母编队数字孪生</h2><p>我们将 航母编队在 万里海疆的壮阔景象浓缩于方寸屏幕之间，通过高精度建模与实时仿真，一钉一铆地构建起这个虚拟编队，从甲板防滑纹路的精确模拟，到舰载机起降轨迹的实时渲染，每一个细节都力求还原真实世界的物理特性与作战逻辑。将福建舰及其完整编队呈现在虚拟海洋环境中，可近距离体验这一现代海军力量的核心要素。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2YL" alt="" title=""/><br/>这不仅仅是一次技术展示，更是大国力量在数字空间的真实绽放，它让每一位观者都能直观感受到中国海军迈向深蓝的坚定步伐。希望通过这个应用，将福建舰的先进性与国家强大的自豪感，传递给每一位关心国防事业的同胞，激发起更深厚的爱国情怀。</p><h4>福建舰 航母编队：体系化远洋攻防作战集群</h4><p><strong>福建舰航母编队绝非单一装备的简单拼凑，而是我国首款实现 “电磁弹射 + 隐身舰载机 + 固定翼预警机” 三位一体的体系化远洋作战集群</strong>。它开创了中国海军 “感知 - 指挥 - 打击 - 保障” 全链条自主可控的先河，每个成员都承载着 “首次突破” 的历史使命，以独有的开创性技术与定位，共同构筑起攻防兼备、远域慑止的深蓝雄师，标志着中国海军彻底迈入 “体系化远洋作战” 的新时代。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2YM" alt="" title="" loading="lazy"/><br/>在数字孪生系统中，当我们把视角聚焦南海深蓝，可以看到福建舰编队构筑起一个立体的攻防体系，其威慑范围充分体现了现代海战的战略纵深。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2YN" alt="" title="" loading="lazy"/><br/>1.<strong>“同心圆防御体系”</strong>：编队的感知体系，舰艇雷达 与 空警-600 预警机 共同编织了一张探测半径超1000公里的多维感知网，构筑起最外围的防空反导预警圈。<br/><img width="723" height="405" referrerpolicy="no-referrer" src="/img/bVdm2YO" alt="" title="" loading="lazy"/><br/>2.<strong>“空海协同打击圈”</strong>：在打击范围方面，导弹与舰载机火力交织，空海协同，将编队的有效控制与精确打击半径向前显著推进，打击半径足以覆盖西太平洋第二岛链。<br/><img width="723" height="414" referrerpolicy="no-referrer" src="/img/bVdm2YQ" alt="" title="" loading="lazy"/><br/>这意味着，福建舰编队不仅能在南海维护国家利益，还能在更广阔的远洋环境中执行威慑与干预任务，确保区域安全稳定。这种覆盖范围的扩展，绝非简单的距离叠加，而是体系化作战能力的体现。</p><h2>钢铁矩阵：编队核心装备“解密”</h2><h3>01海域 护航编队</h3><h4>“定海神针” 福建舰：自主可控，铸就大国航母新标杆</h4><p><strong>在世界航母发展史上，福建舰开创了 “常规动力 + 电磁弹射” 的全新技术路径，成为全球首艘采用这一组合的航空母舰。</strong><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y2" alt="" title="" loading="lazy"/><br/>福建舰满载排水量超过8万吨的电磁弹射航母，是我国目前吨位最大的航母，也是亚洲最大的常规动力航母，舰体设计首次实现 “平直通长甲板 + 小型化隐身舰岛” 的优化组合，3 条电磁弹射轨道与新型电磁拦阻系统配套，可适配从 歼 - 35 隐身战机 到 空警 - 600 预警机 的全谱系舰载机，其三部电磁弹射器可同时准备弹射作业，实现了舰载机起降效率的质的飞跃，开创了我国航母 “高效战力投送” 的新方式。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y5" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y6" alt="" title="" loading="lazy"/><br/>在整个航母编队体系中，福建舰是集机动部署、指挥控制、战力投送于一体的体系中枢，可实现对水上、水下、空中多维度目标的实时监控与数据融合，并将指挥指令精准传递至编队各舰艇、战机，实现 “一点发现、全网共享、协同打击” 的体系化作战模式。从战术层面看，福建舰既是舰载机的起降平台，也是编队的 “大脑” 与 “神经中枢”，其存在让分散的舰艇、战机形成有机整体，释放出体系化作战的最大效能。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Y8" alt="" title="" loading="lazy"/></p><h4>“带刀护卫” 055 型驱逐舰：中国首款 万吨级 防空驱逐舰</h4><p><strong>055 型驱逐舰 是中国海军第四代导弹驱逐舰，我国首款满载排水量突破 1.2 万吨的大型驱逐舰，更是全球首款将综合射频系统与万吨体量完美融合的防空反舰核心舰，开创了中国海军 “大吨位、强火力、高智能” 的驱逐舰发展方向。</strong><br/>055 型驱逐舰 是 编队防空指挥所和全能护卫，利用先进双波段雷达系统与导弹系统，构筑起坚实的区域防空拦截线，不仅能有效保护航母的安全，更可凭借其强大的独立作战能力，率领其他舰艇组成独立编队，组织多目标拦截作战，其垂直发射系统可携带多种导弹，形成远、中、近三层攻防火力配系。是守护核心、拓展火力的 “全能卫士”，其技术水平与综合战力位居全球同类型驱逐舰前列。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Ze" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zf" alt="" title="" loading="lazy"/></p><h4>“水下利刃” 093 攻击核潜艇：中国首款静音型攻击核潜艇</h4><p><strong>093 型攻击核潜艇 是我国首款 具备现代化静音作战能力 的攻击核潜艇，更是首款专为航母编队配套设计的水下先锋，开创了中国海军 “深海隐蔽护航” 的作战模式。</strong><br/>093 型攻击核潜艇是编队的水下护航力量。采用先进降噪技术，具备在大洋深处隐蔽航行与待机的能力，在探测与火力方面，093 型攻击核潜艇可精准锁定远距离敌方潜艇与水面舰艇，并能在水下隐蔽状态下实施突然打击，成为编队前方与侧翼的 “水下警戒哨” 和 “突击利刃”让福建舰编队首次具备了远海水下反潜与反舰的体系化能力，填补了我国航母编队水下防御的空白，构筑起 “水面 - 空中 - 水下” 三位一体的立体防护网。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zi" alt="" title="" loading="lazy"/></p><h4>“远洋粮仓” 905 型综合补给舰：中国首款航母专用补给舰</h4><p><strong>905 型综合补给舰是我国首款具备大规模远洋补给能力的综合补给舰，更是首款实现海军编队 “远海伴随保障” 的专用补给平台，开创了中国海军 “告别近岸、走向深蓝” 的保障新纪元。</strong><br/>905 型综合补给舰是编队的 “续航基石”，满载排水量约 2.1 万吨，是我国首款真正意义上能支撑远海编队持续部署的补给舰，首次实现了 “燃油、弹药、食品、淡水” 多品类物资的一体化补给，能支撑航母编队在远海持续部署数月，为编队远洋存在提供了坚实的后勤支撑。作为我国远洋补给舰的 “开山之作”，905 型不仅奠定了我国海军补给舰的发展基础，更以其可靠的保障能力，成为福建舰编队驰骋深蓝的 “续航基石”。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zk" alt="" title="" loading="lazy"/></p><h3>02空中 舰载机联队</h3><h4>“制空利刃” 歼 - 35 舰载战斗机：中国首款舰载隐身战斗机</h4><p><strong>歼 - 35 是我国首款自主研发的舰载隐身战斗机，更是全球首款适配常规动力电磁弹射航母的第五代舰载机，开创了中国海军 “隐身制空” 的作战新纪元。</strong><br/>歼 - 35 是编队隐身突防的“尖刀”，具备在现代防空体系中隐蔽突防的能力，让福建舰编队首次具备了隐身突防与制空权争夺的绝对优势。在性能与适配性上，它首次实现了 “隐身 + 多任务” 的完美平衡，内置弹舱可携带 PL-15 中远程空空导弹、小型反舰导弹与精确制导炸弹，既能夺取制空权，又能实施对海对地精确打击；同时首次适配福建舰的电磁弹射系统，可实现满油满弹弹射起飞，作战半径超 1000 公里，与歼 - 15T 形成 “高低搭配”。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zl" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zm" alt="" title="" loading="lazy"/></p><h4>“重载先锋” 歼 - 15T 舰载战斗机：中国首款电磁弹射重型舰载战斗机</h4><p><strong>歼 - 15T 是我国首款适配电磁弹射系统的重型舰载战斗机，更是首款实现重载弹射能力的歼 - 15 改进型，开创了我国重型舰载机 “高效火力投送” 的新路径。</strong><br/>歼-15T “飞鲨” 是执行火力压制与空域控制任务的 “核心力量”，在对海打击中实施决定性精确攻击。在火力配置上，它首次实现了 “全谱系弹药适配”，能实施饱和式精确打击。作为歼 - 35 的 “黄金搭档”，它首次与隐身舰载机形成 “制空 + 打击” 的协同模式 —— 歼 - 35 夺取制空权后，歼 - 15T 凭借重载优势实施大规模火力突击，让编队的打击效能实现 “1+1&gt;2” 的倍增，彻底释放了电磁弹射技术带来的战力提升。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zp" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zr" alt="" title="" loading="lazy"/></p><h4>“海空鹰眼” 空警 - 600 预警机：开创了中国航母 “远域预警”</h4><p><strong>空警 - 600 是我国首款舰载固定翼预警机，更是亚洲首款适配电磁弹射系统的固定翼预警机，开创了中国航母 “远域预警” 的新时代。</strong><br/>空警-600固定翼预警机是航母编队的关键信息节点，让航母编队具备远海体系化空情保障能力。该机背部装有大型有源相控阵雷达，可探测数百公里外的空中与水面目标，尤其擅长捕捉低空突防的战机与掠海导弹，有效克服了地球曲率带来的探测盲区，在编队外围建立持续空中监视。在协同能力上，它首次实现与福建舰、055 型驱逐舰的数据链实时联动，能将探测到的目标数据秒级传输至编队各作战单元，同时可直接引导歼 - 35、歼 - 15T 舰载机实施超视距作战，构建起 “预警 - 指挥 - 打击” 的无缝衔接链条。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zx" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2Zy" alt="" title="" loading="lazy"/></p><h4>“多能支援” Z-20F 舰载直升机：中国首款专用舰载多任务直升机</h4><p><strong>Z-20F “海鹰” 是我国首款专为航母编队设计的多任务舰载直升机，更是首款实现反潜、搜救、运输一体化的舰载直升机，开创了中国海军 “舰载直升机多能化” 的新时代。</strong><br/>在航母编队体系中，Z-20F凭借其全域、全时出动能力，成为连接水面舰艇、水下力量与空中预警网络的重要节点，在任务适配性上，它首次实现 “一机多能”，既能执行水下反潜、海面搜救任务，又能承担舰艇间人员物资运输、近程侦察等支援任务，可快速响应编队多样化需求。Z-20 “海鹰” 的列装，让福建舰编队首次具备了全场景多任务支援能力，实现了 “攻防兼备、支援到位” 的体系化布局。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZB" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZC" alt="" title="" loading="lazy"/></p><h2>数字孪生内核支撑，复刻深蓝雄师全景态势</h2><p><strong>这份震撼的大国力量呈现，背后是数字冰雹全套自主研发的数字孪生底层技术支撑。</strong><br/>我们<strong>通过自研 图观 模型编辑器完成了编队全装备的超高精度构建</strong>，装备的结构、参数、外观 每一处细节都 1:1 还原真实原型，确保国之重器的细节精准度与视觉质感。在此基础上，<strong>图观 流渲染场景编辑器 构建了全域海域环境</strong>，从南海的复杂海况、洋流特征到远海的光影变化、气象模拟，全方位还原真实远洋作战场景，让航母编队有了贴合实战的部署舞台。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZD" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZE" alt="" title="" loading="lazy"/><br/>最终，<strong>通过 孪易 IOC 实现全体系动态整合</strong>，将装备部署、战术协同、动态推演融为一体。孪易 IOC 精准指挥着舰载机的弹射起飞、飞行编队的协同掠过、以及整个护航编队中每一件装备的战术位置码放与机动。不仅实现了视觉上的震撼还原，更在物理规律与战术逻辑层面，确保了整个福建舰航母编队在数字空间中均以全景态势实时呈现。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZF" alt="" title="" loading="lazy"/><br/>整个工具链体系 高效、协同运行，既实现了 国之重器 “静态复刻精准度”，又达成了 “动态推演真实感”，让数字空间中的福建舰编队，成为可感知、可交互、可推演的国之重器数字镜像。</p><h2>从“近海防御”到“远海防卫”</h2><p><strong>福建舰入列 开启 三航母时代</strong><br/><strong>福建舰交付入列，意味着中国海军正式迈入三航母时代</strong>。这套数字孪生系统，不仅是对福建舰本身的精确还原，更是对中国海军现代化进程的生动诠释。从辽宁舰的试验探索，到山东舰的自主建造，再到福建舰的技术突破，中国航母事业的每一步跨越，都印证着国家科技水平、工业实力与综合国力的全面跃升。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm2ZL" alt="" title="" loading="lazy"/><br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm22B" alt="" title="" loading="lazy"/><br/>现代航母战斗群的精髓不在于单个装备的性能堆砌，而在于体系化作战能力的生成。福建舰编队作为一个完整的作战体系，各单元通过数据链实现信息共享，形成整体作战效能。福建舰航母编队构建的 “感知 - 指挥 - 打击 - 保障” 全链条体系化力量，而这股力量的形成，标志着中国海军实现了从 “近海防御” 到 “远洋存在” 的历史性跨越。<br/>这支力量不用于炮舰外交，不谋求海上霸权，只为那句“守护万里海疆”的铮铮誓言！系统中模拟的劈波斩浪、壮阔夕阳下的航母编队，正是对中国海军走向深蓝的最美诠释。</p><h2>数字孪生，见证强军；中国海军，向海图强！</h2>]]></description></item><item>    <title><![CDATA[HarmonyOS 6.0 服务卡片实战]]></title>    <link>https://segmentfault.com/a/1190000047399918</link>    <guid>https://segmentfault.com/a/1190000047399918</guid>    <pubDate>2025-11-14 16:07:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>HarmonyOS 6.0 服务卡片实战：把「轻食刻」装进桌面，让轻断食一眼可控</h2><blockquote>本文基于HarmonyOS 6.0 ArkTS开发框架，结合轻食刻健康管理应用的服务卡片<code>Form Kit</code>开发实践，详细解析了<code>formProvider.openFormManager</code>等核心API在实际项目中的应用。通过具体代码示例和架构设计，展示了如何将复杂的健康数据以简洁直观的方式呈现在用户桌面上。</blockquote><h3>项目背景</h3><p>轻食刻是一款专注于轻断食和健康管理的应用，在日常使用中我发现用户需要频繁查看断食进度、体重变化等关键数据。为了提升用户体验，我决定利用HarmonyOS 6.0的服务卡片技术，让用户无需打开应用即可在桌面上快速获取这些信息。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047399921" alt="8aaff505e95f1d0ceca9f59d658d6f1a.jpg" title="8aaff505e95f1d0ceca9f59d658d6f1a.jpg"/></p><h3>一、服务卡片技术概述</h3><h4>1.1 HarmonyOS 6.0服务卡片技术特性</h4><p>在轻食刻项目中，我充分利用了HarmonyOS 6.0服务卡片的以下技术特性：</p><ul><li><strong>Form Kit核心能力</strong>：从API version 18开始，Form Kit提供在应用内将ArkTS卡片添加到桌面的能力，极大提升了用户体验</li><li><strong>ArkTS声明式UI</strong>：采用统一的声明式开发范式，提升开发效率</li><li><strong>动态更新机制</strong>：支持定时更新和事件触发更新</li><li><strong>多样化交互</strong>：支持router、message、call三种事件类型</li><li><strong>多尺寸适配</strong>：兼容2<em>2、2</em>4、4*4等常见卡片尺寸</li><li><strong>卡片管理API</strong>：通过<code>formProvider.openFormManager</code>实现便捷的卡片管理</li><li><strong>完善的生命周期</strong>：提供完整的创建、更新、销毁等生命周期回调</li></ul><p><strong>重要说明</strong>：应用内拉起卡片管理加桌面的功能需要API version 18及以上版本支持，低于API version 18的设备无法使用此能力。</p><h4>1.2 轻食刻服务卡片功能设计</h4><p>针对轻食刻的核心使用场景，我设计了以下服务卡片功能：</p><ul><li><strong>断食状态监控</strong>：实时显示断食进度和剩余时间</li><li><strong>体重趋势展示</strong>：通过图表展示体重变化趋势</li><li><strong>水分摄入跟踪</strong>：监控每日水分摄入情况</li><li><strong>快捷操作入口</strong>：提供开始/结束断食的便捷操作</li></ul><h3>二、服务卡片架构设计</h3><h4>2.1 整体架构</h4><p>轻食刻的服务卡片架构采用分层设计：</p><pre><code>┌─────────────────┐
│   服务卡片UI层   │
│  (HealthWidget)  │
└─────────────────┘
         │
┌─────────────────┐
│   业务逻辑层     │
│ (WidgetService)  │
└─────────────────┘
         │
┌─────────────────┐
│   数据访问层     │
│   (DataDao)     │
└─────────────────┘</code></pre><h4>2.2 核心组件说明</h4><p><strong>HealthWidget</strong>：服务卡片UI组件，负责数据展示和用户交互<br/><strong>WidgetReminderService</strong>：服务卡片提醒管理服务，处理卡片生命周期和提醒逻辑<br/><strong>SettingsDao</strong>：数据持久化组件，存储卡片配置和用户数据</p><h3>三、服务卡片实现详解</h3><h4>3.1 卡片配置文件</h4><p>首先，我需要在<code>form_config.json</code>中定义服务卡片的基本属性：</p><pre><code class="json">{
  "forms": [
    {
      "name": "health_widget",
      "description": "$string:health_widget_description",
      "src": "./ets/widgets/HealthWidget.ets",
      "uiSyntax": "arkts",
      "window": {
        "designWidth": 720,
        "autoDesignWidth": true
      },
      "colorMode": "auto",
      "formConfigAbility": "ability://com.kirk.fastone.HealthFormAbility",
      "formVisibleNotify": true,
      "isDefault": true,
      "updateEnabled": true,
      "scheduledUpdateTime": "10:30",
      "updateDuration": 1,
      "defaultDimension": "2*2",
      "supportDimensions": ["2*2", "2*4", "4*4"]
    }
  ]
}</code></pre><p><strong>关键配置说明</strong>：</p><ul><li><code>scheduledUpdateTime</code>：设置定时更新时间</li><li><code>updateDuration</code>：更新间隔（小时）</li><li><code>supportDimensions</code>：支持的卡片尺寸</li></ul><h4>3.2 服务卡片UI组件</h4><p>以下是健康数据卡片的核心UI实现：</p><pre><code class="typescript">// HealthWidget.ets - 健康数据服务卡片
@Entry
@Component
export struct HealthWidget {
  @LocalStorageProp('fastingStatus') fastingStatus: FastingStatus = new FastingStatus();
  @LocalStorageProp('weightData') weightData: WeightData[] = [];
  @LocalStorageProp('waterIntake') waterIntake: number = 0;

  build() {
    Column() {
      // 断食状态区域
      this.buildFastingSection()
      
      // 体重趋势区域
      this.buildWeightSection()
      
      // 水分摄入区域
      this.buildWaterSection()
    
    }
    .width('100%')
    .height('100%')
    .padding(12)
    .backgroundColor($r('app.color.background_card'))
  }

  @Builder
  buildFastingSection() {
    Row() {
      Column({ space: 4 }) {
        Text('断食状态')
          .fontSize(12)
          .fontColor($r('app.color.text_secondary'))
        
        Text(this.fastingStatus.isFasting ? '进行中' : '未开始')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)
          .fontColor(this.fastingStatus.isFasting ? 
            $r('app.color.success') : $r('app.color.text_primary'))
        
        if (this.fastingStatus.isFasting) {
          Text(`剩余: ${this.fastingStatus.remainingTime}`)
            .fontSize(12)
            .fontColor($r('app.color.text_secondary'))
        }
      }
      .layoutWeight(1)
    }
    .width('100%')
  }
}</code></pre><h4>3.3 服务卡片提醒服务</h4><p>为了实现智能提醒功能，我设计了<code>WidgetReminderService</code>：</p><pre><code class="typescript">// WidgetReminderService.ets - 服务卡片提醒管理
/**
 * 服务卡片提醒类型
 */
export enum WidgetReminderType {
  WIDGET_ADD_REMINDER = 'widget_add_reminder', // 添加服务卡片提醒
  WIDGET_USAGE_REMINDER = 'widget_usage_reminder', // 使用服务卡片提醒
  WIDGET_UPDATE_REMINDER = 'widget_update_reminder' // 更新服务卡片提醒
}

/**
 * 服务卡片提醒管理服务
 */
export class WidgetReminderService {
  private static instance: WidgetReminderService;
  
  /**
   * 检查并触发服务卡片提醒
   */
  async checkAndTriggerWidgetReminders(): Promise&lt;void&gt; {
    try {
      const widgetStatus = await this.getWidgetStatus();
      const reminders = await this.getAllWidgetReminderSettings();
      
      for (const reminder of reminders) {
        if (reminder.enabled &amp;&amp; reminder.reminderCount &lt; reminder.maxReminders) {
          const shouldTrigger = await this.shouldTriggerReminder(reminder, widgetStatus);
          
          if (shouldTrigger) {
            await this.triggerWidgetReminder(reminder);
          }
        }
      }
    } catch (error) {
      hilog.error(DOMAIN, TAG, `Failed to check widget reminders: ${JSON.stringify(error)}`);
    }
  }

  /**
   * 判断是否应该触发提醒
   */
  private async shouldTriggerReminder(
    reminder: WidgetReminderSetting, 
    widgetStatus: WidgetStatus
  ): Promise&lt;boolean&gt; {
    // 检查时间间隔（至少间隔24小时）
    const now = Date.now();
    const twentyFourHours = 24 * 60 * 60 * 1000;
    if (reminder.lastReminderTime &gt; 0 &amp;&amp; (now - reminder.lastReminderTime) &lt; twentyFourHours) {
      return false;
    }

    // 根据提醒类型和条件判断
    switch (reminder.type) {
      case WidgetReminderType.WIDGET_ADD_REMINDER:
        return !widgetStatus.hasWidgetAdded &amp;&amp; widgetStatus.widgetUsageCount &gt;= 3;
        
      case WidgetReminderType.WIDGET_USAGE_REMINDER:
        return widgetStatus.hasWidgetAdded &amp;&amp; widgetStatus.widgetUsageCount &lt; 5;
        
      default:
        return false;
    }
  }
}</code></pre><h4>3.4 Form Kit卡片管理API实现</h4><h5>3.4.1 formProvider.openFormManager API应用</h5><p><strong>API版本要求</strong>：从API version 18开始，Form Kit提供在应用内将ArkTS卡片添加到桌面的能力，以方便用户后续便捷查看信息或快速进入应用。</p><p><strong>版本兼容性说明</strong>：</p><ul><li>✅ <strong>API version 18及以上</strong>：支持应用内拉起卡片管理加桌面功能</li><li>❌ <strong>API version 18以下</strong>：无法使用此能力，用户需要通过传统方式在桌面添加卡片</li></ul><p>在轻食刻项目中，我使用<code>formProvider.openFormManager</code>接口实现卡片管理功能：</p><pre><code class="typescript">// WidgetGuidePage.ets - 卡片管理页面跳转实现
private openWidgetManager(): void {
  try {
    const want: Want = {
      bundleName: 'com.kirk.fastone',
      abilityName: 'HealthFormAbility',
      parameters: {
        'ohos.extra.param.key.form_dimension': 2,
        'ohos.extra.param.key.form_name': 'widget',
        'ohos.extra.param.key.module_name': 'entry'
      },
    };
    
    // 检查API版本兼容性
    if (this.isApiVersionSupported(18)) {
      formProvider.openFormManager(want);
      console.info('WidgetGuidePage: Successfully opened form manager');
    } else {
      // API version 18以下设备的降级处理
      this.showLegacyWidgetGuide();
    }
    
  } catch (error) {
    console.error('WidgetGuidePage: Failed to open widget manager:', error);
    ToastUtil.showLong('⚠️ 暂无可用打开方式，请在桌面空白处长按，选择"服务卡片"，然后搜索"轻食刻"添加卡片');
  }
}

/**
 * 检查API版本是否支持
 */
private isApiVersionSupported(minVersion: number): boolean {
  const systemApiVersion = globalThis.system.apiVersion;
  return systemApiVersion &gt;= minVersion;
}

/**
 * 传统方式添加卡片引导
 */
private showLegacyWidgetGuide(): void {
  ToastUtil.showLong('📱 请在桌面空白处长按，选择"服务卡片"，然后搜索"轻食刻"添加卡片');
}</code></pre><p><strong>开发要点</strong>：</p><ul><li><strong>版本检查</strong>：在调用API前检查设备API版本，确保功能可用性</li><li><strong>参数配置</strong>：正确设置bundleName、abilityName等参数</li><li><strong>异常处理</strong>：完善的错误捕获和用户提示</li><li><strong>降级策略</strong>：为不支持API version 18的设备提供传统引导方式</li></ul><h5>3.4.2 卡片交互事件处理</h5><p>服务卡片支持多种交互事件，以下是事件处理的核心实现：</p><pre><code class="typescript">// 卡片内部事件处理
.onClick(() =&gt; {
  postCardAction(this, {
    action: 'router',
    abilityName: 'EntryAbility',
    params: {
      message: 'open_fasting_detail',
      targetPage: 'FastingDetailPage'
    }
  });
})

// 消息事件处理
.onClick(() =&gt; {
  postCardAction(this, {
    action: 'message',
    params: {
      message: 'toggle_fasting_status',
      actionType: this.fastingStatus.isFasting ? 'stop' : 'start'
    }
  });
})</code></pre><h3>四、关键技术点解析</h3><h4>4.1 卡片生命周期管理</h4><p>在轻食刻项目中，我通过<code>WidgetReminderService</code>实现了完整的卡片生命周期管理：</p><ul><li><strong>创建阶段</strong>：卡片首次添加到桌面时触发<code>onCreate</code>回调</li><li><strong>更新阶段</strong>：通过定时更新或事件触发更新，对应<code>onUpdate</code>回调</li><li><strong>销毁阶段</strong>：用户移除卡片时触发<code>onDestroy</code>回调</li><li><strong>可见性变化</strong>：卡片显示/隐藏时触发<code>onVisibilityChange</code>回调</li></ul><p>通过精细的生命周期管理，确保卡片状态与主应用保持同步。</p><h4>4.2 数据同步机制</h4><p>服务卡片与主应用之间的数据同步是关键挑战。我采用以下策略：</p><ol><li><strong>LocalStorage数据共享</strong>：使用<code>@LocalStorageProp</code>实现卡片与主应用数据同步</li><li><strong>定时更新机制</strong>：配置<code>scheduledUpdateTime</code>实现定时数据刷新</li><li><strong>事件触发更新</strong>：通过<code>postCardAction</code>触发即时数据更新</li></ol><h4>4.3 性能优化策略</h4><p>针对服务卡片的性能要求，我实施了以下优化措施：</p><ol><li><strong>内存优化</strong>：控制卡片UI复杂度，避免过多嵌套</li><li><strong>渲染优化</strong>：使用<code>LazyForEach</code>优化列表渲染</li><li><strong>数据优化</strong>：仅加载必要数据，控制数据更新量</li><li><strong>更新策略</strong>：合理设置更新频率，避免频繁刷新</li></ol><p>通过这些优化，轻食刻服务卡片在保证功能完整性的同时，实现了流畅的用户体验。</p><h4>4.4 用户体验设计</h4><p>在用户体验方面，我重点关注：</p><ul><li><strong>信息层级</strong>：重要信息突出显示，次要信息适当弱化</li><li><strong>交互反馈</strong>：点击操作提供明确的视觉反馈</li><li><p><strong>状态指示</strong>：使用颜色和图标清晰表示不同状态</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399922" alt="26aeaa72751409ea0554972ed7ff7948.jpg" title="26aeaa72751409ea0554972ed7ff7948.jpg" loading="lazy"/></p></li></ul><h3>五、开发实践与经验总结</h3><h4>5.1 开发流程建议</h4><p>基于轻食刻项目的开发经验，我建议采用以下开发流程：</p><ol><li><strong>需求分析</strong>：明确卡片功能定位和用户使用场景</li><li><strong>UI设计</strong>：设计简洁直观的卡片界面</li><li><strong>技术选型</strong>：选择合适的卡片尺寸和交互方式</li><li><strong>开发实现</strong>：按照HarmonyOS规范进行开发</li><li><strong>测试验证</strong>：在不同设备上测试卡片表现</li></ol><h4>5.2 开发中遇到的问题</h4><p>在轻食刻服务卡片开发过程中，我遇到了以下典型问题：</p><ul><li><p><strong>API调用失败</strong>：<code>formProvider.openFormManager</code>调用异常</p><ul><li><strong>解决方法</strong>：检查bundleName、abilityName配置，确认应用权限</li></ul></li><li><p><strong>数据同步延迟</strong>：卡片更新不及时</p><ul><li><strong>解决方法</strong>：优化数据同步机制，增加手动刷新功能</li></ul></li><li><p><strong>设备适配问题</strong>：不同设备显示效果不一致</p><ul><li><strong>解决方法</strong>：采用响应式布局，适配多种屏幕尺寸</li></ul></li><li><p><strong>交互响应延迟</strong>：卡片操作响应较慢</p><ul><li><strong>解决方法</strong>：优化事件处理逻辑，减少不必要的计算</li></ul></li></ul><h4>5.3 开发经验总结</h4><p>基于轻食刻项目的开发实践，我总结了以下经验：</p><ol><li><strong>API规范使用</strong>：正确使用<code>formProvider.openFormManager</code>等核心API</li><li><strong>代码规范</strong>：遵循HarmonyOS开发规范，保证代码质量</li><li><strong>性能优化</strong>：关注内存使用和渲染性能</li><li><strong>用户体验</strong>：以用户为中心设计交互流程</li><li><strong>测试覆盖</strong>：确保在各种场景下的稳定性</li></ol><h4>5.4 扩展能力展望</h4><p>基于HarmonyOS 6.0的服务卡片技术，未来可以进一步扩展：</p><ul><li><strong>AI健康建议</strong>：基于用户数据提供个性化健康建议</li><li><strong>社交分享</strong>：支持将健康成果分享到社交平台</li><li><strong>设备联动</strong>：与智能穿戴设备深度集成</li></ul><h4>5.5 学习方法与资源推荐</h4><p>在HarmonyOS开发过程中，开发过程中总结的一些经验：</p><ul><li><strong>文档使用</strong>：直接看API示例代码，重点关注版本更新说明</li><li><strong>问题解决</strong>：先排查基础配置，再社区求助，最后官方支持</li><li><strong>学习路径</strong>：从简单卡片开始，逐步增加复杂功能，注意版本兼容性</li><li><strong>持续学习</strong>：关注技术动态，多实践项目</li></ul><h3>六、总结</h3><p>通过轻食刻项目的服务卡片开发实践，我验证了HarmonyOS 6.0服务卡片技术的实用价值。该技术能够为用户提供便捷的信息获取方式，通过智能提醒和交互功能显著提升应用体验。</p><p>随着HarmonyOS生态的不断发展，服务卡片技术将在更多应用场景中发挥重要作用。我期待看到更多开发者利用这一技术，为用户创造更好的数字生活体验。</p><h3>参考资料</h3><h4>官方文档资源</h4><ol><li><a href="https://link.segmentfault.com/?enc=rsunEgqRds%2B7E0sJThzPZw%3D%3D.cFytr6D5AH9W7i4xs0bK0QBHbCi6U1IsJhd%2F6QUq6W8ivN%2FAHGo688CRrL5TkBf%2Fgf0esRFvWYof%2B2s9hdcvp0A8eBZfu9Y8mrtmmj5RCaQ%3D" rel="nofollow" target="_blank">HarmonyOS应用开发文档 - Form Kit服务卡片</a></li><li><a href="https://link.segmentfault.com/?enc=u%2FN%2ByXNGEsY9oqFyvF8NAQ%3D%3D.ufkJzewXNQ7uONj8LAgjlCcllS2kLOgauQzPUfWh%2FtyYBcJbVVscYDf0G0WjBsTGeCKImjvUuzHZ57S93WL6Mx2YUuCG3OkiFwFoh8P0tWfBacYEJLBcp1diRSMd4Q12" rel="nofollow" target="_blank">轻食刻 - 欢迎体验</a></li></ol><hr/><p><em>本文基于HarmonyOS 6.0和轻食刻项目v1.0.1版本编写，所有代码示例均经过实际测试验证。</em></p><h3>结语：为鸿蒙生态贡献力量</h3><p>通过轻食刻服务卡片的开发实践，我深刻体会到HarmonyOS作为新一代智能终端操作系统的强大技术实力和生态价值。作为一名鸿蒙开发者，我深感荣幸能够参与到这个充满活力的生态建设中。</p>]]></description></item><item>    <title><![CDATA[解决“Move to iOS 卡在准备中]]></title>    <link>https://segmentfault.com/a/1190000047399937</link>    <guid>https://segmentfault.com/a/1190000047399937</guid>    <pubDate>2025-11-14 16:06:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>从安卓换到 iPhone 时，是否也遇到了“Move to iOS 卡在准备中”的问题？别担心，你并不孤单。这个问题通常由 Wi-Fi 不稳定或传输数据过多引起。下面我们将提供 9 种快速解决方案，帮助你顺利完成数据传输。首先，我们来了解一下“准备中”通常需要多长时间。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399939" alt="图片" title="图片"/></p><p>为什么 iPhone 准备传输需要那么久？</p><pre><code>Wi-Fi 信号弱——请确保连接稳定。
数据量过大——请耐心等待，或分批传输。
后台应用干扰——关闭所有后台程序。
系统版本过旧——请更新两部设备。
连接异常——可尝试开关蓝牙/Wi-Fi。
iPhone 存储空间不足——请清理空间。

</code></pre><h3>第一部分：Move to iOS 准备阶段通常需要多久？</h3><p>Move to iOS 是苹果官方提供的安卓到 iPhone 数据迁移工具。准备阶段所需时间取决于你的 Wi-Fi 网络状况和传输的数据量。如果 Wi-Fi 信号较弱或数据量较大，准备过程可能需要 1 小时甚至更久。在某些情况下，“准备中”是正常现象，建议耐心等待。但如果时间过长，建议使用以下方法进行排查和修复。</p><h3>第二部分：解决“Move to iOS 卡在准备中”的 9 种方法</h3><p>方法 1：保持设备靠近</p><p>使用无线传输时，请将两部设备保持在 5–15 英尺（约 1.5–4.5 米） 范围内。距离过远可能导致传输失败或卡在“准备中”。</p><p>方法 2：检查 Move to iOS 的兼容性</p><pre><code>安卓设备需运行 Android 4.0 及以上版本
iPhone 需运行 iOS 9.0 及以上版本
确保两部设备连接至 同一个 Wi-Fi 网络
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399940" alt="图片" title="图片" loading="lazy"/></p><p>方法 3：检查 Wi-Fi 连接</p><p>如果反复出现“Move to iOS 准备中卡住”，请先检查路由器，并尝试打开其他网页或应用测试网络是否稳定。<br/>如网络异常，请重新连接 Wi-Fi 或重启路由器。<br/>你也可以尝试重置 iPhone 网络设置：<br/>设置 &gt; 通用 &gt; 传输或还原 iPhone &gt; 还原 &gt; 还原网络设置</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399941" alt="图片" title="图片" loading="lazy"/></p><p>方法 4：关闭“连接优化器”（Connections Optimizer）</p><p>安卓 8.0 及以上系统可能自动切换 Wi-Fi 和移动网络，建议关闭：</p><pre><code>进入 设置 &gt; 连接 &gt; 移动网络 &gt; 连接优化器
关闭“连接优化器”开关

</code></pre><p>方法 5：关闭“智能网络切换”（Smart Network Switch）</p><p>安卓 4.3 及以上系统可能启用“智能网络切换”，请关闭：</p><pre><code>打开 设置 &gt; Wi-Fi
点击右上角“更多”或“菜单”按钮
选择“智能网络切换”并取消勾选
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399942" alt="图片" title="图片" loading="lazy"/></p><p>方法 6：检查 iPhone 存储空间</p><pre><code>进入 设置 &gt; 通用 &gt; iPhone 存储空间
查看可用空间是否充足（灰色部分为剩余空间）
如空间不足，可卸载不常用应用或删除大文件
建议提前将重要文件备份至 iCloud 或电脑
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399943" alt="图片" title="图片" loading="lazy"/></p><p>方法 7：开启飞行模式</p><p>在 iPhone 上开启飞行模式可避免因网络干扰导致的传输失败。<br/>打开控制中心，点击飞机图标即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399944" alt="图片" title="图片" loading="lazy"/></p><p>方法 8：关闭所有后台应用</p><p>安卓后台应用可能干扰 Move to iOS 运行，建议全部关闭：</p><pre><code>进入 设置 &gt; 应用
查看正在运行的应用，逐个点击并选择“强制停止”
或直接卸载不常用的应用
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399945" alt="图片" title="图片" loading="lazy"/></p><p>方法 9：重启两部手机</p><p>重启可清除系统缓存和临时故障：</p><pre><code>安卓：长按电源键 &gt; 重启
iPhone：长按电源键 &gt; 滑动关机 &gt; 再次开机

</code></pre><h3>第三部分：使用更稳定的 Move to iOS 替代工具 —— iReaShare Phone Transfer</h3><p>如果你尝试了以上方法仍然无法解决问题，或者 Move to iOS 传输速度太慢，我们强烈推荐使用更专业的替代工具：iReaShare Phone Transfer（支持 Windows 和 Mac）。这是一款领先的手机数据传输工具，支持安卓与 iPhone 之间的快速迁移，不会卡在“准备中”，操作简单，传输稳定。</p><p>iReaShare Phone Transfer 的主要优势：</p><pre><code>快速将数据从安卓迁移至 iPhone，不卡在准备阶段
支持联系人、短信、通话记录、照片、视频、音乐、文档、应用、书籍等多种数据类型
不覆盖原有数据，零数据丢失风险
兼容几乎所有安卓与苹果设备，包括最新的 三星 S25 和 iPhone 16 系列
保护用户隐私，本地传输，不上传云端

</code></pre><p>使用步骤（安卓传数据到 iPhone）：</p><p>步骤 1： 下载并安装 iReaShare Phone Transfer 至电脑。</p><p><img width="723" height="492" referrerpolicy="no-referrer" src="/img/bVdm226" alt="" title="" loading="lazy"/></p><p>​编辑步骤 2： 使用 USB 数据线分别连接安卓手机与 iPhone 至电脑，软件将自动识别设备。<br/>步骤 3： 确保 iPhone 显示在右侧“目标设备”位置，如不对可点击“翻转”按钮调整。<br/>步骤 4： 勾选你想传输的数据类型，点击“开始复制”按钮，立即开始迁移。</p><h3>总结</h3><p>本文详细介绍了“Move to iOS 卡在准备中”的常见原因及 9 种解决方法。如果你希望更快、更稳定地完成安卓到 iPhone 的数据迁移，建议使用 iReaShare Phone Transfer 作为 Move to iOS 的替代方案，避免卡顿、失败、耗时等问题。<br/>​</p>]]></description></item><item>    <title><![CDATA[从缺陷预防到良率提升：涂装工艺质量管理的]]></title>    <link>https://segmentfault.com/a/1190000047399977</link>    <guid>https://segmentfault.com/a/1190000047399977</guid>    <pubDate>2025-11-14 16:05:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>从缺陷预防到良率提升：涂装工艺质量管理的智能化转型路径<br/>涂装工艺作为现代制造业的核心环节，尤其在汽车、家电和消费电子等领域，其质量管理直接关系到产品的防护性、装饰性和市场竞争力。随着行业对环保、效率和成本控制的要求日益严格，涂装工艺质量管理已成为企业必须高度重视的战略议题。一个健全的质量管理体系不仅需要覆盖从原材料到成品的全流程，还必须融入数据驱动和智能化手段，以确保一致性、可靠性和可持续性。<br/>在涂装工艺中，质量管理始于前处理阶段，这是整个流程的基础。例如，在汽车制造业中，脱脂和磷化过程的质量控制直接影响车身的耐腐蚀性能和涂层附着力。如果前处理不当，即使后续喷涂工艺再精湛，也无法避免起泡、剥落等缺陷。行业案例显示，某知名汽车品牌曾因磷化膜不均匀导致批量召回，损失高达数百万美元，这突显了前处理质量管理的重要性。通过引入自动化检测系统，如实时监控槽液浓度和温度，企业可以大幅减少人为误差，提升过程稳定性。<br/>喷涂环节的质量管理同样至关重要，尤其是电泳、中涂和面漆的均匀性与厚度控制。在静电喷涂中，涂料利用率和涂层一致性是关键指标。家电行业的一个典型例子是冰箱外壳涂装：如果清漆层厚度不均，会导致光泽度差异，影响产品外观和消费者体验。传统上，企业依赖人工抽样检测，但这种方式效率低且易漏检。现代质量管理则倾向于采用在线测量技术，如红外光谱仪或激光测厚仪，实现全数检验和数据实时反馈。这不仅提高了检测精度，还缩短了反馈周期，使问题得以快速纠正。<br/>固化与干燥过程的质量管理往往被忽视，却是决定涂层最终性能的环节。温度和时间控制不当会导致固化不完全或过烘烤，进而引发漆膜脆化、变色等问题。在消费电子行业，如智能手机外壳涂装，固化炉的温均匀性必须保持在±5°C以内，以确保颜色一致性和耐久性。通过集成物联网（IoT）传感器和数据分析平台，企业可以实时监控炉温曲线，并自动调整参数以应对波动。这种智能化手段不仅提升了质量稳定性，还降低了能源消耗，符合绿色制造趋势。<br/>行业例子进一步说明，涂装工艺质量管理需要跨部门协作和持续改进文化。在汽车制造中，广域铭岛作为行业解决方案提供商，通过其数字化平台帮助车企整合涂装线数据，实现从订单到交付的全链路可视化。例如，某合作车企利用该平台将生产、质量、工艺、设备的管理逻辑融入系统，实现涂装核心业务自动运行，提升效率。涂装质量数据实时采集上传，发现涂装质量趋势达到既定范围马上预警，实现数据驱动管理。涂装车间提升效率年收益约人民币 53.45 万元/年、减少返修，节约返修产生的物辅料费用约人民币 4.2 万元/年。<br/>总之，涂装工艺质量管理是一个多维度的系统工程，涉及技术、流程和人员素质的综合提升。随着工业4.0的推进，人工智能、大数据和云计算正成为质量管理的赋能工具。企业应拥抱这些创新，通过标准化操作、实时监控和持续优化，构建坚韧的质量体系。<br/>未来，质量管理将更加注重预测性和自适应能力，从而在激烈市场竞争中保持优势。通过借鉴行业最佳实践和利用先进技术，制造企业可以显著提升涂装工艺质量，驱动整体业务增长。</p>]]></description></item><item>    <title><![CDATA[用 Eino ADK 构建你的第一个 A]]></title>    <link>https://segmentfault.com/a/1190000047399985</link>    <guid>https://segmentfault.com/a/1190000047399985</guid>    <pubDate>2025-11-14 16:05:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文将会向您介绍如何利用 <strong>Eino ADK (Agent Development Kit)</strong> 构建一个强大的多智能体系统。</p><p>以 Excel Agent 这个实际业务场景为基础，Excel Agent 是一个能够“听懂你的话、看懂你的表格、写出并执行代码”的智能助手。它把复杂的 Excel 处理工作拆解为清晰的步骤，通过自动规划、工具调用与结果校验，稳定完成各项Excel数据处理任务。</p><p>接下来我们将从 Excel Agent 的完整架构与功能出发，向您展示该 Agent 是如何通过 Eino ADK 逐步搭建的，进而深入浅出的理解 Eino ADK 的核心设计特点，助您快速上手 Eino ADK，向构建自定义智能体与 AI 应用系统更进一步。</p><p>本示例完整代码位于 Github，您可以随时浏览与下载。</p><h4><strong>Excel Agent 是什么？</strong></h4><p>Excel Agent 是一个“看得懂 Excel 的智能助手”，它先把问题拆解成步骤，再一步步执行并校验结果。它能理解用户问题与上传的文件内容，提出可行的解决方案，并选择合适的工具（系统命令、生成并运行 Python 代码、网络查询等等）完成任务。</p><p>Excel Agent 整体是基于 Eino ADK 实现的 Multi-Agent 系统，完整架构如下图所示：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399987" alt="" title=""/></p><p>Excel Agent 内部包含的几个 Agent 功能分别为：</p><ul><li><strong>Planner</strong>：分析用户输入，拆解用户问题为可执行的计划</li><li><strong>Executor</strong>：正确执行当前计划中的首个步骤</li><li><strong>CodeAgent</strong>：接收来自 Executor 的指令，调用多种工具（例如读写文件，运行 python 代码等）完成任务</li><li><strong>WebSearchAgent</strong>：接收来自 Executor 的指令，进行网络搜索</li><li><strong>Replanner</strong>：根据 Executor 执行的结果和现有规划，决定继续执行、调整规划或完成执行</li><li><strong>ReportAgent</strong>：根据运行过程与结果，生成总结性质的报告</li></ul><h4><strong>Excel Agent 的典型使用场景</strong></h4><p>在真实业务里，你可以把 Excel Agent 当成一位“Excel 专家 + 自动化工程师”。当你交付一个原始表格和目标描述，它会给出方案并完成执行：</p><ul><li><strong>数据清理与格式化</strong>：从一个包含大量数据的 Excel 文件中完成去重、空值处理、日期格式标准化操作。</li><li><strong>数据分析与报告生成</strong>：从销售数据中提取每月的销售总额，聚合统计、透视，最终生成并导出图表报告。</li><li><strong>自动化预算计算</strong>：根据不同部门的预算申请，自动计算总预算并生成部门预算分配表。</li><li><strong>数据匹配与合并</strong>：将多个不同来源的客户信息表进行匹配合并，生成完整的客户信息数据库。</li></ul><p>Excel Agent 的完整运行动线为：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399988" alt="" title="" loading="lazy"/></p><p><strong>核心收益</strong>：</p><ul><li><strong>更少的人工操作</strong>，把复杂繁琐的 Excel 处理工作交给 Agent 自动完成。</li><li><strong>更稳定的产出质量</strong>，通过“规划—执行—反思”闭环减少漏项与错误。</li><li><strong>更强的可扩展性</strong>，各 Agent 独立构建，低耦合利于迭代更新。</li></ul><p>Excel Agent 既可以单独使用，也可以作为子 Agent，集成在一个复合的多专家系统中，由外部路由到此 Agent 上，解决 excel 领域相关的问题。</p><p>下面我们将逐步拆解 Excel Agent，深入了解 Eino ADK 的核心设计特点，以及如何利用这些特点构建高效、灵活的 AI 应用系统。</p><h4><strong>ChatModelAgent：与 LLM 交互的基石</strong></h4><p><code>ChatModelAgent</code>是 Eino ADK 中的一个核心预构建的 Agent，内部使用了 <a href="https://link.segmentfault.com/?enc=yX3SwH33JjaUaTaDMGV9OA%3D%3D.LtwyLTLe0RcImHZOhtVEh69rr1%2BVuT0QO%2FGrwePCqfc%3D" rel="nofollow" target="_blank">ReAct</a> 模式（一种让模型‘思考-行动-观察’的链式推理模式）：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399989" alt="" title="" loading="lazy"/></p><p><code>ChatModelAgent</code>旨在让 ChatModel 进行显式的、一步一步的“思考”，结合思考过程驱动行动，观测历史思考过程与行动结果继续进行下一步的思考与行动，最终解决复杂问题：</p><ul><li>调用 ChatModel（Reason）</li><li>LLM 返回工具调用请求（Action）</li><li>ChatModelAgent 执行工具（Act）</li><li>将工具结果返回给 LLM（Observation），结合之前的上下文继续生成，直到模型判断不需要调用工具后结束</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399990" alt="" title="" loading="lazy"/></p><p>在 Excel Agent 中，每个 Agent 的核心都是这样一个 <code>ChatModelAgent</code>，以 Executor 运行【读取用户输入表格的头信息】这个步骤为例 ，我们可以通过观察完整的运行过程来理解 ReAct 模式在 <code>ChatModelAgent</code>中的表现：</p><ol><li>Executor：经过判断，将任务转交给 CodeAgent 运行</li><li>CodeAgent：接收到任务【读取用户输入表格的头信息】</li></ol><ul><li><strong>Think-1</strong>：上下文未提供工作目录下的所有文件，需要查看</li><li><strong>Act-1</strong>: 调用 Bash 工具，ls 查看工作目录下的所有文件</li><li><strong>Think-2</strong>: 找到了用户输入的文件，判断需要编写 Python 代码读取 xlsx 表格的首行</li><li><strong>Act-2</strong>: 调用 PythonRunner 工具，书写代码并运行，获取运行结果</li><li><strong>Think-3</strong>: 获取到了 xlsx 首行，判断任务完成</li></ul><ol><li>运行完成，将表格头信息返回给 Executor</li></ol><h4><strong>Plan-Execute Agent：基于「规划-执行-反思」的多智能体协作框架</strong></h4><p>Plan-Execute Agent 是 Eino ADK 中一种基于「规划-执行-反思」范式的多智能体协作框架，旨在解决复杂任务的分步拆解、执行与动态调整问题。它通过 <strong>Planner（规划器）</strong>、**Executor（执行器）**和 <strong>Replanner（重规划器）</strong> 三个核心智能体的协同工作，实现任务的结构化规划、工具调用执行、进度评估与动态 replanning，最终达成用户目标：</p><pre><code>// 完整代码: https://github.com/cloudwego/eino/blob/main/adk/prebuilt/planexecute/plan_execute.go

// NewPlanner creates a new planner agent based on the provided configuration.
func NewPlanner(_ context.Context, cfg *PlannerConfig) (adk.Agent, error)

// NewExecutor creates a new executor agent.
func NewExecutor(ctx context.Context, cfg *ExecutorConfig) (adk.Agent, error)

// NewReplanner creates a new replanner agent.
func NewReplanner(_ context.Context, cfg *ReplannerConfig) (adk.Agent, error)

// New creates a new plan-execute-replan agent with the given configuration.
func New(ctx context.Context, cfg *Config) (adk.Agent, error)

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399991" alt="" title="" loading="lazy"/></p><p>而 Excel Agent 的核心能力恰好为【解决用户在 excel 领域的问题】，与该智能体协作框架定位一致：</p><ul><li><strong>规划者（Planner）</strong>：明确目标，自动拆解可执行步骤</li><li><strong>执行者（Executor）</strong>：调用工具（Excel 读取、系统命令、Python 代码）完成规划中的每一个详细步骤</li><li><strong>反思者（Replanner）</strong>：根据执行进度决定继续、调整规划或结束</li></ul><p>Planner 和 Replanner 会将用户模糊的指令拆解为清晰的、可执行的步骤清单，即包含多个步骤（Step）的计划（Plan），Eino ADK 为此提供了灵活的 Plan 接口定义，支持用户自定义 Plan 结构与细节：</p><pre><code>type Plan interface {
    // FirstStep returns the first step to be executed in the plan.
    FirstStep() string
    // Marshaler serializes the Plan into JSON.
    // The resulting JSON can be used in prompt templates.
    json.Marshaler
    // Unmarshaler deserializes JSON content into the Plan.
    // This processes output from structured chat models or tool calls into the Plan structure.
    json.Unmarshaler
}

</code></pre><p>默认情况下，框架会使用内置的 Plan 结构作为兜底配置，例如下面就是 Excel Agent 产生的一个完整运行计划：</p><pre><code>### 任务计划
- [x] 1. Read the contents of '模拟出题.csv' from the working directory into a pandas DataFrame.
- [x] 2. Identify the question type (e.g., multiple-choice, short-answer) for each row in the DataFrame.
- [x] 3. For non-short-answer questions, restructure the data to place question, answer, explanation, and options in the same row.
- [x] 4. For short-answer questions, merge the answer content into the explanation column and ensure question and merged explanation are in the same row.
- [x] 5. Verify that all processed rows have question, answer (where applicable), explanation, and options (where applicable) in a single row with consistent formatting.
- [x] 6. Generate a cleaned report presenting the formatted questions with all relevant components (question, answer, explanation, options) in unified rows.

</code></pre><h4><strong>Workflow Agents：可控的多 Agent 运行流水线</strong></h4><p>Excel Agent 中，存在一些需要按照特定顺序运行 agent 的情况：</p><ol><li><strong>顺序运行</strong>：先运行 Planner，再运行 Executor 和 Replanner；Planner 只运行一次。</li><li><strong>循环运行</strong>：Executor 和 Replanner 需要按需循环运行多次，每次循环运行都是先运行 Executor 后运行 Replanner</li><li><strong>顺序运行</strong>：Plan-Executor 整体运行完后，固定运行一次 ReportAgent 进行总结。</li></ol><p>对于这些拥有固定执行流程的场景，Eino ADK 提供了三种流程编排方式，协助用户快速搭建可控的工作流：</p><ul><li><strong>SequentialAgent</strong>：按照配置中提供的顺序，依次执行一系列子 Agent。每个子 Agent 执行完成后，其输出会通过 History 机制传递给下一个子 Agent，形成一个线性的执行链。</li></ul><pre><code>import github.com/cloudwego/eino/adk

// 依次执行 制定研究计划 -&gt; 搜索资料 -&gt; 撰写报告
sequential := adk.NewSequentialAgent(ctx, &amp;adk.SequentialAgentConfig{
    Name: "research_pipeline",
    SubAgents: []adk.Agent{
        planAgent,    // 制定研究计划
        searchAgent,  // 搜索资料
        writeAgent,   // 撰写报告
    },
})

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399992" alt="" title="" loading="lazy"/></p><ul><li><strong>LoopAgent</strong>：重复执行配置的子 Agent 序列，直到达到最大迭代次数或某个子 Agent 产生 ExitAction，每次迭代的结果都会累积，后续迭代的输入可以访问所有历史信息。LoopAgent 基于 SequentialAgent 实现。</li></ul><pre><code>import github.com/cloudwego/eino/adk

// 循环执行 5 次，每次顺序为：分析当前状态 -&gt; 提出改进方案 -&gt; 验证改进效果
loop := adk.NewLoopAgent(ctx, &amp;adk.LoopAgentConfig{
    Name: "iterative_optimization",
    SubAgents: []adk.Agent{
        analyzeAgent,  // 分析当前状态
        improveAgent,  // 提出改进方案
        validateAgent, // 验证改进效果
    },
    MaxIterations: 5,
})

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399993" alt="" title="" loading="lazy"/></p><ul><li><strong>ParallelAgent</strong>：允许多个子 Agent 基于相同的输入上下文并发执行。所有子 Agent 接收相同的初始输入，各自在独立的 goroutine（Go 语言中一种轻量级的并发执行单元） 运行，最终收集所有子 Agent 的执行结果并按顺序输出到<code>AsyncIterator</code>中。</li></ul><pre><code>import github.com/cloudwego/eino/adk

// 并发执行 情感分析 + 关键词提取 + 内容摘要
parallel := adk.NewParallelAgent(ctx, &amp;adk.ParallelAgentConfig{
    Name: "multi_analysis",
    SubAgents: []adk.Agent{
        sentimentAgent,  // 情感分析
        keywordAgent,    // 关键词提取
        summaryAgent,    // 内容摘要
    },
})

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399994" alt="" title="" loading="lazy"/></p><h4><strong>Agent 抽象：灵活定义 Agent 的基础</strong></h4><p>Eino ADK 的核心是一个简洁而强大的 Agent 接口，每个 Agent 都有明确的身份（Name）、清晰的职责（Description）和标准化的执行方式（Run），为 Agent 之间的发现与调用提供了基础。无论是简单的问答机器人，还是复杂的多步骤任务处理系统，都可以通过这个统一的接口加以实现。</p><ul><li><strong>统一的 Agent 抽象</strong>：ADK 提供的预构建 Agent（ChatModelAgent，Plan-Execute Agent，Workflow Agents）都遵循该接口定义。您也可以基于该接口，书写自定义 Agent，完成定制化需求。</li></ul><pre><code>type Agent interface {
    Name(ctx context.Context) string
    Description(ctx context.Context) string
    Run(ctx context.Context, input *AgentInput, options ...AgentRunOption) *AsyncIterator[*AgentEvent]
}

</code></pre><ul><li><strong>标准化输入</strong>：Agent 通常以 LLM 为核心，因此 Eino ADK 定义的 Agent 的输入与 LLM 接收的输入一致：</li></ul><pre><code>type AgentInput struct {
    Messages        []Message
    EnableStreaming bool
}

type Message = *schema.Message // *schema.Message 是模型输入输出的结构定义

</code></pre><ul><li><strong>异步事件驱动输出</strong>：Agent 的输出是一个 AgentEvent 的异步迭代器，其中的 AgentEvent 表示 Agent 在其运行过程中产生的核心事件数据。其中包含了 Agent 的元信息、输出、行为和报错信息：</li></ul><pre><code>type AgentEvent struct {
    AgentName string    // 产生 Event 的 Agent 名称（框架自动填充）

    RunPath []RunStep   // 到达当前 Agent 的完整运行轨迹（框架自动填充）

    Output *AgentOutput // Agent 输出消息内容

    Action *AgentAction // Agent 动作事件内容

    Err error           // Agent 报错
}

type AgentOutput struct {
    MessageOutput *MessageVariant // 模型消息输出内容

    CustomizedOutput any          // 自定义输出内容
}

type MessageVariant struct {
    IsStreaming bool            // 是否为流式输出
    
    Message       Message        // 非流式消息输出
    MessageStream MessageStream  // 流式消息输出

    Role schema.RoleType         // 消息角色
    ToolName string              // 工具名称
}

type AgentAction struct {
    Exit bool                               // Agent 退出

    Interrupted *InterruptInfo              // Agent 中断

    TransferToAgent *TransferToAgentAction  // Agent 跳转

    CustomizedAction any                    // 自定义 Agent 动作
}

</code></pre><p>异步迭代器允许 Agent 在运行过程中的任意时刻向迭代器发送消息（Agent 调用模型结果、工具运行结果、中间状态等等），同时调用方以一种有序、阻塞的方式消费这一系列事件：</p><pre><code>iter := myAgent.Run(ctx, "hello") // get AsyncIterator

for {
    event, ok := iter.Next()
    if !ok {
        break
    }
    // handle event
}

</code></pre><h3><strong>Agent 协作：隐藏在 Agent 后的数据传递</strong></h3><p>Excel Agent 架构图中的节点代表每个具体的 Agent，边代表了数据流通与任务转移。在构建多 Agent 系统时，让不同 Agent 之间高效、准确地共享信息至关重要。</p><p>这些信息不仅包含 Agent 的输入输出，还有全局的、部分可见的种种额外信息，例如：</p><ul><li>Executor 执行需要从 Planner / Replanner 拿到一个结构化的、可被拆分为详细步骤（Step）的计划（Plan），而非一段非结构化的 LLM 原始输出消息。</li><li>ReportAgent 需要拿到完整的运行计划、运行过程与运行产物才能正确产生报告。</li></ul><p>Eino ADK 包含两种基础的数据传递机制：</p><ul><li><strong>History</strong>：每一个 Agent 产生的 AgentEvent 都会被保存到这个隐藏的 History 中，调用一个新 Agent 时 History 中的 AgentEvent 会被转换并拼接到 AgentInput 中。默认情况下，其他 Agent 的 Assistant 或 Tool Message，被转换为 User Message，这相当于在告诉当前的 LLM：“刚才， Agent\_A 调用了 some\_tool ，返回了 some_result 。现在，轮到你来决策了。”。 通过这种方式，其他 Agent 的行为被当作了提供给当前 Agent 的“外部信息”或“事实陈述”，而不是它自己的行为，从而避免了 LLM 的上下文混乱。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399995" alt="" title="" loading="lazy"/></p><ul><li><strong>共享 Session</strong>：单次运行过程中持续存在的 KV 存储，用于支持跨 Agent 的状态管理和数据共享，一次运行中的任何 Agent 可以在任何时间读写 SessionValues。以 Plan-Execute Agent 模式为例，Planner 生成首个计划并写入 Session；Executor 从 Session 读取计划并执行；Replanner 从 Session 读取当前计划后，结合运行结果，将更新后的计划写回 Session 覆盖当前的计划。</li></ul><pre><code>// Agent 内获取全部 SessionValues
func GetSessionValues(ctx context.Context) map[string]any

// Agent 内指定 key 获取 SessionValues 中的值
func GetSessionValue(ctx context.Context, key string) (any, bool)

// Agent 内添加 SessionValues
func AddSessionValue(ctx context.Context, key string, value any)

// Agent 内批量添加 SessionValues
func AddSessionValues(ctx context.Context, kvs map[string]any)

// WithSessionValues 在 Agent 运行前由外部注入 SessionValues
func WithSessionValues(v map[string]any) AgentRunOption
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399996" alt="" title="" loading="lazy"/></p><p>除了完善的 Agent 间数据传递机制，Eino ADK 从实践出发，提供了多种 Agent 协作模式：</p><ul><li><strong>预设 Agent 运行顺序（Workflow）</strong>：以代码中预设好的流程运行， Agent 的执行顺序是事先确定、可预测的。对应 Workflow Agents 章节提到的三种范式。</li><li><strong>移交运行（Transfer）</strong>：携带本 Agent 输出结果上下文，将任务移交至子 Agent 继续处理。适用于智能体功能可以清晰的划分边界与层级的场景，常结合 ChatModelAgent 使用，通过 LLM 的生成结果进行动态路由。结构上，以此方式进行协作的两个 Agent 称为父子 Agent：</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399997" alt="" title="" loading="lazy"/></p><pre><code>// 设置父子 Agent 关系
func SetSubAgents(ctx context.Context, agent Agent, subAgents []Agent) (Agent, error)

// 指定目标 Agent 名称，构造 Transfer Event
func NewTransferToAgentAction(destAgentName string) *AgentAction

</code></pre><ul><li><strong>显式调用（ToolCall）</strong>：将 Agent 视为工具进行调用，适用于 Agent 运行仅需要明确清晰的参数而非完整运行上下文的场景。常结合 ChatModelAgent，将 Agent 作为工具运行后将结果返回给 ChatModel 继续处理。除此之外，ToolCall 同样支持调用符合工具接口构造的、不含 Agent 的普通工具。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399998" alt="" title="" loading="lazy"/></p><pre><code>// 将 Agent 转换为 Tool
func NewAgentTool(_ context.Context, agent Agent, options ...AgentToolOption) tool.BaseTool

</code></pre><h3><strong>Excel Agent 示例运行</strong></h3><h4><strong>配置环境与输入输出路径</strong></h4><ul><li>环境变量：Excel Agent 运行依赖的完整环境变量可参考项目 README。</li><li><p>运行输入：包括一段用户需求描述和待处理的一系列文件，其中：</p><ul><li><code>main.go</code>中首行表示用户输入的需求描述，可自行修改：</li></ul></li></ul><pre><code>func main() {
    // query := schema.UserMessage("统计附件文件中推荐的小说名称及推荐次数，并将结果写到文件中。凡是带有《》内容都是小说名称，形成表格，表头为小说名称和推荐次数，同名小说只列一行，推荐次数相加")
    // query := schema.UserMessage("读取模拟出题.csv 中的内容，规范格式将题目、答案、解析、选项放在同一行，简答题只把答案写入解析即可")
    query := schema.UserMessage("请帮我将 question.csv 表格中的第一列提取到一个新的 csv 中")
}

</code></pre><ul><li><code>adk/multiagent/integration-excel-agent/playground/input</code>为默认的附件输入路径，附件输入路径支持配置，参考 README。</li><li><code>adk/multiagent/integration-excel-agent/playground/test_data</code> 路径下提供了几个示例文件，您可以将文件复制到附件输入路径下来进行测试运行：</li></ul><pre><code>% tree adk/multiagent/integration-excel-agent/playground/test_data
adk/multiagent/integration-excel-agent/playground/test_data
├── questions.csv
├── 推荐小说.txt
└── 模拟出题.csv

1 directory, 3 files</code></pre><ul><li>运行输出：Excel Agent 输入的附件、运行的中间产物与最终结果都会放置在工作路径下：<code>adk/multiagent/integration-excel-agent/playground/${uuid}</code>，输出路径支持配置，参考 README。</li></ul><h4><strong>查看运行结果</strong></h4><p>Excel Agent 单次运行会在输出路径下创建一个新的工作目录，并在该目录下完成任务，运行时产生的中间产物与最终结果都会写到该目录下。</p><p>以<code>请帮我将 question.csv 表格中的第一列提取到一个新的 csv</code> 中这个任务为例，运行完成后在工作目录下包含的内容有：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399999" alt="" title="" loading="lazy"/></p><ol><li>原始输入：从输入路径获取到的 <code>question.csv</code></li><li>Planner / Replanner 给出的运行计划：<code>plan.md</code></li></ol><pre><code>### 任务计划
- [x] 1. {"desc":"Read the 'questions.csv' file into a pandas DataFrame."}
- [x] 2. Save the extracted first column to a new CSV file.

</code></pre><ol start="3"><li>Executor 中的 CodeAgent 书写的代码：<code>$uuid.py</code></li></ol><pre><code>import pandas as pd

df = pd.read_csv('questions.csv')
first_column = df.iloc[:, 0]
first_column.to_csv('extracted_first_column.csv', index=False)

</code></pre><ol start="4"><li>运行中间产物：<code>extracted_first_column.csv</code>和 <code>first_column.csv</code></li></ol><pre><code>type
multiple-choice
...
short-answer

</code></pre><ol start="5"><li>最终报告：<code>final_report.json</code></li></ol><pre><code>{
  "is_success": true,
  "result": "Successfully extracted the first column from questions.csv and saved it to first_column.csv.",
  "files": [
    {
      "path": "/User/user/go/src/github.com/cloudwego/eino-examples/adk/multiagent/integration-excel-agent/playground/00f118af-4bd8-42f7-8d11-71f2801218bd/first_column.csv",
      "desc": "A CSV file containing only the first column data from the original questions.csv."
    }
  ]
}

</code></pre><h4>运行过程输出</h4><p>Excel Agent 会将每个步骤的运行结果输出到日志中。下面仍以<code>请帮我将 question.csv 表格中的第一列提取到一个新的 csv 中</code>这个任务为例，向您展示 Excel Agent 在运行过程中的几个关键步骤及其输出，并通过对步骤的解释，直观地呈现 Agent 的运行流程及其强大能力。：</p><ul><li>Planner 生成 JSON 格式的初始计划</li></ul><pre><code>name: Planner
answer: {
    "steps": [
        {
            "index": 1,
            "desc": "Read the 'questions.csv' file into a pandas DataFrame."
        },
        {
            "index": 2,
            "desc": "Extract the first column from the DataFrame."
        },
        {
            "index": 3,
            "desc": "Save the extracted first column to a new CSV file."
        }
    ]
}

</code></pre><ul><li>Executor 将 CodeAgent 作为工具进行调用，执行计划中的首个步骤</li></ul><pre><code>name: Executor
tool name: CodeAgent
arguments: {"request":"Read the 'questions.csv' file into a pandas DataFrame using pandas. Use the pandas.read_csv function and store the result in a variable named df."}

</code></pre><ul><li>CodeAgent 使用 PythonRunner 工具运行代码，并使用 ReAct 模式自动纠错，修正代码中的错误</li></ul><pre><code># CodeAgent 使用 PythonRunner 工具运行代码
name: Executor
tool name: PythonRunner
arguments: {"code":"```python\nfirst_column = df.iloc[:, 0]\n```"}

# PythonRunner 代码运行报错
name: Executor
tool response: Traceback (most recent call last):
  File "/User/user/go/src/github.com/cloudwego/eino-examples/adk/multiagent/integration-excel-agent/playground/00f118af-4bd8-42f7-8d11-71f2801218bd/00f118af-4bd8-42f7-8d11-71f2801218bd.py", line 1, in &lt;module&gt;
    first_column = df.iloc[:, 0]
                   ^^
NameError: name 'df' is not defined

# ReAct 模式自动纠错，修正无法运行的代码
name: Executor
answer: The error occurs because the DataFrame `df` is not defined. We need to first load the data from the existing CSV file `questions.csv` into `df`. Here's the corrected code:
tool name: PythonRunner
arguments: {"code":"```python\nimport pandas as pd\ndf = pd.read_csv('questions.csv')\nfirst_column = df.iloc[:, 0]\nprint(first_column.head())  # Verify the result\n```"}

# 代码运行成功，返回运行结果
name: Executor
path: [{SequentialAgent} {plan_execute_replan} {Planner} {execute_replan} {Executor}]
tool response: 
0    multiple-choice
1    multiple-choice
2    multiple-choice
3    multiple-choice
4    multiple-choice
Name: type, dtype: object

</code></pre><ul><li>Replanner 判断计划完成，提交运行结果至 ReportAgent</li></ul><pre><code>name: Replanner
answer: {
    "is_success": true,
    "result": "已成功将'questions.csv'表格中的第一列提取到新的CSV文件'extracted_first_column.csv'中。",
    "files": [
        {
            "desc": "包含原表格第一列数据的新CSV文件",
            "path": "extracted_first_column.csv"
        }
    ]
}

</code></pre><ul><li>ReportAgent 进行总结，结束执行</li></ul><pre><code>name: Report
tool name: SubmitResult
arguments: {
    "is_success": true,
    "result": "Successfully extracted the first column from questions.csv and saved it to first_column.csv.",
    "files": [
        {
            "path": "/User/user/go/src/github.com/cloudwego/eino-examples/adk/multiagent/integration-excel-agent/playground/00f118af-4bd8-42f7-8d11-71f2801218bd/first_column.csv",
            "desc": "A CSV file containing only the first column data from the original questions.csv."
        }
    ]
}

</code></pre><h3><strong>总结</strong></h3><p>Excel Agent 所呈现的并非“单一智能体”的技巧，而是一套以 Eino ADK 为底座的 Multi-Agent 系统工程化方法论：</p><ul><li>以 ChatModelAgent 的 ReAct 能力为基石，让模型“可思考、会调用”。</li><li>以 WorkflowAgents 的编排能力，让 Multi-Agent 系统中的每个 Agent 以用户预期的顺序运行。</li><li>以 Planner–Executor–Replanner 的闭环，让复杂任务“可拆解、能纠错”。</li><li>以 History / Session 的数据传递机制，让多 Agent “能协作、可回放”。</li></ul><blockquote><p>💡 <strong>立即开始你的智能体开发之旅</strong></p><ul><li>⌨️ 查看 Excel Agent 源码：<a href="https://link.segmentfault.com/?enc=%2BkWCR2vNbBboGs%2B%2FS4C0LQ%3D%3D.xs4TTc0ZOM2qgHDn1dO6PFlg%2FVU%2BgXNvYgjKMhD1%2F6TZi16GFC3akfWYN8eYAeD2zlkhYzriaf3EV1D3mSjZKA%3D%3D" rel="nofollow" target="_blank">to do</a></li><li>📚 查看更多文档：<a href="https://link.segmentfault.com/?enc=X7z%2BZQWJ1qQE98IsyTo7Kw%3D%3D.McWfV4RC2Lly8afqwbY7VmmR%2FAiRM%2FefZfJCNLfb4k6PtOLmrLcnfIA4ZwrA78U9xeaflCHnYnEthzVP9w2Hvw%3D%3D" rel="nofollow" target="_blank">Eino ADK 文档</a></li><li>🛠️ 浏览 ADK 源码：<a href="https://link.segmentfault.com/?enc=U0J94tlB%2F1PLi9YTJPy6Zw%3D%3D.IdpmaPFviD0mo8BLspD9u6xqgSAIeGh18kEzjTy9DvswjZpDjEokjEi5%2BA9gWkRvpBOrR9E91NyNc7Y3OzGUhg%3D%3D" rel="nofollow" target="_blank">Eino ADK 源码</a></li><li>💡 探索 ADK 全部示例：<a href="https://link.segmentfault.com/?enc=CIz%2BEUBEjRoXw0nGoHcgpQ%3D%3D.xq5A6mJz8pjcgF1P%2FIKXED4KHsdHZPkQ%2Bo41kH%2BBd8TUuFA46Crsbs3hCd5O4gvG62zWzGBnA1h36KY7betA5A%3D%3D" rel="nofollow" target="_blank">Eino ADK Examples</a></li><li>🤝 加入开发者社区：与其他开发者交流经验和最佳实践</li></ul><p><strong>Eino ADK，让智能体开发变得简单而强大！</strong></p></blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047400000" alt="" title="" loading="lazy"/></p><p><strong>参考资料</strong></p><p>[1] ReAct: _<a href="https://link.segmentfault.com/?enc=8TNh0Zg2YHn3gIYMULzDww%3D%3D.1wjotR6Oq5Mc2U2XW7LRGYgu4oR%2FUcry3NGJj4ZngJE%3D" rel="nofollow" target="_blank">https://react-lm.github.io/</a>_</p><p>[2] Eino 示例代码: _<a href="https://link.segmentfault.com/?enc=590RKEtUG5zGjRQyVaf%2B3A%3D%3D.JtPyb4qOGDEZp5UNWy2FIOotG%2BGz5L%2F2bfoSrafaRDGmFqZoNyzRNRprk%2FVqnoDYq7IlpeHwM%2BxRRAa5F1oDncdZ6RKCI4lxnSuS3%2BHiYYPjTli7sxS3L5PwxOk%2Bj%2FPU" rel="nofollow" target="_blank">https://github.com/cloudwego/eino-examples/tree/main/adk/multiagent/integration-excel-agent</a>_</p><p>[3] Eino ADK 文档: _<a href="https://link.segmentfault.com/?enc=gVQ6Kw1Xhu%2BE%2FT%2FKVcwaQA%3D%3D.XQAl8RTuqESgD26O3sOqm2Bdj3tU2KXlvTC0uxRwsOmCF9eOqqoUsMCAHMKSxVy%2Bg4SgT5vA2Z2fwYulC%2FZGtA%3D%3D" rel="nofollow" target="_blank">https://www.cloudwego.io/zh/docs/eino/core\_modules/eino\_adk/</a>_</p><p>[4] Eino ADK 源码: _<a href="https://link.segmentfault.com/?enc=UpZyZR0CdGkYjl0OoLZDXQ%3D%3D.6n2Xj4gVjawIAbHnRElTXJ63dSlMyyb8HrKN4vtsXLsgabpOr7XitCDdJCmilzBS" rel="nofollow" target="_blank">https://github.com/cloudwego/eino/tree/main/adk</a>_</p><p>[5] Eino ADK Examples: _<a href="https://link.segmentfault.com/?enc=Xj8RVzrRqRHzdFWmJyovXg%3D%3D.na98EyqlrqKEoyviWDb37rOzg%2Bvcp6Vo8gZLii9cNQDm2XbjrqOc8rIfUS%2BnqdwoBndgGdXo2IaQWQ99MGfqEA%3D%3D" rel="nofollow" target="_blank">https://github.com/cloudwego/eino-examples/tree/main/adk</a>_</p>]]></description></item><item>    <title><![CDATA[【案例分享】灯塔低代码平台助力医院构建智]]></title>    <link>https://segmentfault.com/a/1190000047400020</link>    <guid>https://segmentfault.com/a/1190000047400020</guid>    <pubDate>2025-11-14 16:04:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>构建一个以患者为中心、数据驱动、业务协同的智慧服务新生态，已成为现代医院提升服务质量、优化资源配置、创新服务模式的必然选择。而这样的转型，离不开强有力的技术支撑作为基石。北京中烟创新科技有限公司（简称：中烟创新）的灯塔低代码平台，凭借其独特的业务敏捷性、技术包容性和生态连接能力，正完美契合了这一需求，成为推动医院智慧服务体系建设的重要力量。</p><p>平台通过可视化开发、组件化封装和模型驱动架构，为医院提供了快速实现数字化创新的技术基础，让业务专家能够深度参与应用构建，使智慧服务从理念加速走向实践。其核心价值在于将复杂的技术实现过程简化为业务人员可理解的视觉元素，同时保持企业级应用所需的稳定性、安全性和集成能力。</p><p>这种特性使其成为构建医院智慧服务生态的理想技术载体。在医疗环境快速发展的今天，医院需要面对持续变化的服务需求和政策要求。传统开发模式往往需要数月的开发周期，难以满足业务的快速迭代需求。灯塔低代码平台通过可视化的开发环境和丰富的预置组件，使得应用开发周期从"月"级缩短到"周"甚至"天"级，让医院能够快速响应内外部变化，持续优化服务体验。平台有效降低了数字化创新的技术门槛，让熟悉医疗业务的医护人员、管理人员能够直接参与应用设计。</p><p>这种业务与技术的深度融合，确保了数字化解决方案更贴近实际工作场景，解决了传统开发中业务需求与技术实现之间的理解偏差问题，真正实现了"业务驱动"的数字化转型。灯塔低代码平台具备强大的系统集成能力和数据整合能力，能够作为"数字连接器"，打通医院内部各业务系统，连接医疗设备、物联网终端等物理设施，实现数据互通和业务协同，为构建统一、联动的服务生态提供技术保障。</p><p>场景一：全院医疗质量与安全一体化管理医院检查医疗质量主要靠人工抽查、纸质记录和事后查看，效率不高，检查范围也有限。很难做到实时监控和提前预警，对于保障患者安全，有时会因为信息延迟而反应不及。使用灯塔低代码平台，可建立一个覆盖“患者入院前、治疗中、出院后”所有环节的立体化质量管控体系。流程全部搬到线上：把病历书写、合理用药、手术安全、感染预防、危急值处理等上百条质量检查标准，都变成清晰的线上流程。质量管理员、科室主任和医务处工作人员通过一个统一的网站入口处理所有事务。用数据智能预警风险：平台与医院的核心系统（如挂号收费系统、电子病历系统、检验系统、影像系统）连接，自动收集关键数据。通过平台内置的规则和智能模型，能实时发现异常情况，并自动把处理任务推送给相关负责人。形成发现问题到改进的完整闭环：从发现问题、评估、整改到验证效果，形成一个完整的线上管理循环。所有操作都有记录，数据自动分析，能生成各种维度的质量报告，为医院评级、精细化管理和高水平学科建设提供科学依据。</p><p>核心价值：将质量管理从 “出了问题再惩罚” 转变为 “提前预防、过程中控制” ，从琐碎的事务管理升级为有策略的战略管理。它不仅大大提升了医疗安全水平，更培养了一种全员参与、用数据说话、持续改进的质量文化，这是医院智慧服务生态稳固运行的基石。场景二：医疗设备精益化共享管理医院里昂贵的医疗设备和科研仪器往往归各个科室自己管，使用率很不均衡，有的设备经常闲着，有的却不够用。管理靠手工记账，维护保养也不及时，导致设备整体的使用效益不高。利用灯塔低代码平台打造一个面向全院的“医疗设备共享平台”，像“共享单车”一样管理设备，实现资产在线化、资源共享化、管理精细化。一站式预约与智能调度：所有设备的信息都公开透明。临床科室可以随时通过电脑或手机查看并在线预约。</p><p>平台内置智能调度程序，能根据急诊的紧急程度、科研项目的重要性等规则，自动分配设备，最大化利用效率。自动结算与效益一目了然：系统自动记录设备使用时长或检测样本数量，并与医院收费系统打通，实现精准、无人为干预的计费和结算。清晰展示使用率、收入、成本等数据，为医院决定采购新设备还是淘汰旧设备提供客观依据。全生命周期健康管理：给设备装上传感器，实时监控它们的运行状态。平台会自动生成预防性保养计划，并在设备异常时自动报修，推送给工程师，形成完整的设备电子健康档案。核心价值：将设备从 “科室的成本负担” 变成了 “全院共享的利润来源” 。它盘活了闲置的资产，提高了资源利用效率，直接降低了医院运营成本。更重要的是，它建立了一套靠数据说话的资源调配机制，支撑起医院的精细化成本核算。</p><p>场景三：以患者为中心的智慧病房患者住院体验很零碎，想知道的信息不透明；护士忙于大量非护理性的琐事，没太多时间和患者沟通；病房的环境管理也比较粗放。围绕患者住院的全过程，打造一个“患者-护士-环境”智能联动的智慧病房系统。数字化床头屏与智能呼叫：患者通过床头的智能屏幕，可以清楚地查看每天的诊疗安排、用药明细、费用清单，还能在线点餐、查询费用、观看健康知识视频。呼叫护士时，系统能区分普通呼叫、输液完毕、紧急求助等不同情况，并直接通知到护士的手持终端上，实现精准响应。护士移动工作站：护士通过移动平板电脑就能实时接收和执行医生指令、扫描核对患者和药品信息、在床边记录生命体征。</p><p>系统会根据患者的病情，自动推送个性化的健康指导内容，帮助护士提供更高效、规范的护理服务。智慧环境与节能管理：病房的灯光、空调、窗帘等与环境传感器联动，能根据患者休息、治疗等不同模式自动调节，营造最舒适的休养环境。同时，系统能对病房的水电消耗进行精确计量和管理。核心价值：极大地提升了患者满意度和护士的职业幸福感，它让信息多跑路，患者少操心；让护士能有更多时间回归到照顾患者的本职工作。一个安全、舒适、智能的住院环境，本身就是最优质的医疗服务，是智慧服务生态最直接的体现。</p><p>场景四：多学科专家协同诊疗平台组织多学科专家会诊非常困难，专家时间难协调，患者资料分散在各处，讨论过程不规范，得出的结论落实和后续跟踪很麻烦，宝贵的诊疗经验也难以积累下来。用灯塔低代码平台构建一个支持复杂疾病诊疗的“线上专家会诊中心”，打破科室和地域的限制。统一的数字病历空间：为每一位需要会诊的患者创建一个专属的线上空间，自动从医院各个系统里收集并整理好所有相关的病历资料，方便专家在会诊前查阅。规范化的协作流程：把会诊申请、邀请专家、安排会议、线上线下混合讨论、发表意见和形成结论的全过程都标准化、线上化。平台支持视频会议、屏幕共享、电子白板等协作工具。知识积累与智能随访：会诊结论被整理成标准格式，形成可以检索、分析的医院知识宝库。系统会根据最终的治疗方案，自动生成随访计划，并对患者的长期治疗效果进行跟踪，形成诊疗效果的反馈闭环。</p><p>核心价值：让多学科会诊从 “门槛很高的专家会议” 变成了 “标准化的诊疗流程” 。它确保了疑难杂症诊疗的规范性和科学性，促进了不同学科专家之间的知识交流和碰撞。同时，它积累了宝贵的临床科研数据，直接推动了医院临床研究水平的提升。场景五：后勤保障“一站式”智能管控医院后勤保障涉及能源、安全、保洁、运输、设备维修等很多方面，这些系统通常各自为政，形成了多个“信息孤岛”，无法统一指挥调度，响应慢，管理成本高。使用灯塔低代码平台打造医院后勤的“智慧大脑”，构建一个一体化的指挥管控体系。全局情况一屏掌握：通过一个可视化大屏幕，把全院的后勤能耗、安防监控、消防报警、电梯运行、医用气体压力、环境温湿度、报修动态等成千上万个数据点融合在一起展示，实现“一个屏幕看管全院”。</p><p>智能预警与跨系统联动：设置复杂的预警规则。比如，当智能水表监测到某区域用水量异常猛增，系统会自动报警并生成巡查任务，同时调取附近的监控摄像头查看现场；消防系统报警时，能自动联动门禁打开逃生通道，并把疏散路线推送到附近人员的手机上。闭环运维与服务评价：全院报修都在线上进行，平台智能派单，维修人员手机接单，维修完成后由申请人在线评价，形成一个完整的服务闭环和考核体系。核心价值：实现后勤保障从 “被动等待报修” 到 “主动预警、智能联动” 的根本性转变。它大幅提升了医院的安全等级和突发事件响应速度，并通过节能管理和流程优化，显著降低了日常运营成本，为临床一线提供了坚强、可靠的后方保障。</p><p>灯塔低代码平台通过赋能业务、连接数据、重塑流程，成功将“以患者为中心”的理念转化为可落地的数字化实践。帮助医院构建一个更具韧性、更可持续的数字化服务体系，最终为患者提供更优质、更安全的医疗服务体验，为"健康中国"建设贡献重要力量！</p>]]></description></item><item>    <title><![CDATA[StockTV 币安交易所数据 Java]]></title>    <link>https://segmentfault.com/a/1190000047400040</link>    <guid>https://segmentfault.com/a/1190000047400040</guid>    <pubDate>2025-11-14 16:03:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文档详细介绍如何使用 Java 语言通过 StockTV API 对接币安交易所数据，包含实时行情、K线数据、交易对信息等完整功能。</p><h2>🚀 快速开始</h2><h3>环境要求</h3><ul><li>JDK 8+</li><li>Maven 3.6+</li><li>网络连接（可访问 <code>api.stocktv.top</code>）</li></ul><h3>项目依赖</h3><pre><code class="xml">&lt;!-- pom.xml --&gt;
&lt;dependencies&gt;
    &lt;!-- HTTP客户端 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;
        &lt;artifactId&gt;httpclient&lt;/artifactId&gt;
        &lt;version&gt;4.5.14&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- JSON处理 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;version&gt;2.15.2&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- WebSocket客户端 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.java-websocket&lt;/groupId&gt;
        &lt;artifactId&gt;Java-WebSocket&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- 日志框架 --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
        &lt;version&gt;2.0.7&lt;/version&gt;
    &lt;/dependency&gt;
    
    &lt;!-- Lombok --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.28&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h2>🏗️ 核心架构</h2><h3>项目结构</h3><pre><code>src/main/java/com/stocktv/binance/
├── config/
│   └── BinanceConfig.java
├── model/
│   ├── CryptoPair.java
│   ├── TickerPrice.java
│   ├── KLine.java
│   ├── Trade.java
│   └── ApiResponse.java
├── client/
│   ├── BinanceHttpClient.java
│   └── BinanceWebSocketClient.java
├── service/
│   └── BinanceDataService.java
└── demo/
    └── BinanceDemo.java</code></pre><h2>📦 核心代码实现</h2><h3>1. 配置类</h3><pre><code class="java">package com.stocktv.binance.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

/**
 * 币安数据配置类
 */
public class BinanceConfig {
    
    // API 基础配置
    public static final String BASE_URL = "https://api.stocktv.top";
    public static final String WS_URL = "wss://ws-api.stocktv.top/connect";
    
    // 币安接口路径
    public static final String CRYPTO_PAIR_LIST = "/crypto/pairlist";
    public static final String CRYPTO_TICKER_PRICE = "/crypto/tickerPrice";
    public static final String CRYPTO_LAST_PRICE = "/crypto/lastPrice";
    public static final String CRYPTO_GET_KLINES = "/crypto/getKlines";
    public static final String CRYPTO_GET_TRADES = "/crypto/getTrades";
    
    // 币安市场ID
    public static final int BINANCE_MARKET_ID = 338;
    
    // 主要交易对
    public static final String BTC_USDT = "BTCUSDT";
    public static final String ETH_USDT = "ETHUSDT";
    public static final String BNB_USDT = "BNBUSDT";
    public static final String ADA_USDT = "ADAUSDT";
    public static final String DOT_USDT = "DOTUSDT";
    public static final String XRP_USDT = "XRPUSDT";
    public static final String LTC_USDT = "LTCUSDT";
    public static final String LINK_USDT = "LINKUSDT";
    public static final String BCH_USDT = "BCHUSDT";
    public static final String XLM_USDT = "XLMUSDT";
    
    // API Key
    private final String apiKey;
    
    // HTTP 客户端和JSON处理器
    private final CloseableHttpClient httpClient;
    private final ObjectMapper objectMapper;
    
    public BinanceConfig(String apiKey) {
        this.apiKey = apiKey;
        this.httpClient = HttpClients.createDefault();
        this.objectMapper = new ObjectMapper();
        this.objectMapper.findAndRegisterModules();
    }
    
    // Getter方法
    public String getApiKey() { return apiKey; }
    public CloseableHttpClient getHttpClient() { return httpClient; }
    public ObjectMapper getObjectMapper() { return objectMapper; }
}</code></pre><h3>2. 数据模型类</h3><h4>加密货币交易对数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 加密货币交易对数据模型
 */
@Data
public class CryptoPair {
    @JsonProperty("symbol")
    private String symbol;
    
    @JsonProperty("legal_currency_price")
    private BigDecimal legalCurrencyPrice;
    
    @JsonProperty("market_cap_display")
    private String marketCapDisplay;
    
    @JsonProperty("percent_change_utc0_3d")
    private BigDecimal percentChangeUtc03d;
    
    @JsonProperty("price")
    private String price;
    
    @JsonProperty("price_change_today")
    private String priceChangeToday;
    
    @JsonProperty("rank")
    private Integer rank;
    
    @JsonProperty("logo")
    private String logo;
    
    @JsonProperty("id")
    private Long id;
    
    @JsonProperty("price_display")
    private String priceDisplay;
    
    @JsonProperty("price_display_cny")
    private BigDecimal priceDisplayCny;
    
    @JsonProperty("market_id")
    private Integer marketId;
    
    @JsonProperty("market_name")
    private String marketName;
    
    @JsonProperty("market_cap_usd")
    private String marketCapUsd;
    
    @JsonProperty("exchange_time")
    private String exchangeTime;
    
    @JsonProperty("percent_change_1h")
    private BigDecimal percentChange1h;
    
    @JsonProperty("percent_change_24h")
    private BigDecimal percentChange24h;
    
    @JsonProperty("name")
    private String name;
    
    @JsonProperty("volume_24h")
    private String volume24h;
    
    @JsonProperty("price_usd")
    private String priceUsd;
    
    @JsonProperty("available_supply")
    private Long availableSupply;
    
    @JsonProperty("alias")
    private String alias;
    
    @JsonProperty("currency")
    private String currency;
    
    @JsonProperty("pair")
    private String pair;
    
    @JsonProperty("percent_change_7d")
    private BigDecimal percentChange7d;
    
    @JsonProperty("category")
    private String category;
    
    @JsonProperty("search_field")
    private String searchField;
    
    /**
     * 获取数值形式的当前价格
     */
    public BigDecimal getNumericPrice() {
        try {
            return new BigDecimal(price);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取交易对基础货币
     */
    public String getBaseAsset() {
        if (pair != null &amp;&amp; pair.contains("/")) {
            return pair.split("/")[0];
        }
        return symbol.replace("USDT", "");
    }
    
    /**
     * 获取交易对报价货币
     */
    public String getQuoteAsset() {
        if (pair != null &amp;&amp; pair.contains("/")) {
            return pair.split("/")[1];
        }
        return "USDT";
    }
}</code></pre><h4>价格行情数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 价格行情数据模型
 */
@Data
public class TickerPrice {
    @JsonProperty("priceChange")
    private String priceChange;
    
    @JsonProperty("symbol")
    private String symbol;
    
    @JsonProperty("count")
    private Long count;
    
    @JsonProperty("openPrice")
    private String openPrice;
    
    @JsonProperty("lastId")
    private Long lastId;
    
    @JsonProperty("quoteVolume")
    private String quoteVolume;
    
    @JsonProperty("firstId")
    private Long firstId;
    
    @JsonProperty("volume")
    private String volume;
    
    @JsonProperty("weightedAvgPrice")
    private String weightedAvgPrice;
    
    @JsonProperty("lowPrice")
    private String lowPrice;
    
    @JsonProperty("highPrice")
    private String highPrice;
    
    @JsonProperty("closeTime")
    private Long closeTime;
    
    @JsonProperty("openTime")
    private Long openTime;
    
    @JsonProperty("priceChangePercent")
    private String priceChangePercent;
    
    @JsonProperty("lastPrice")
    private String lastPrice;
    
    /**
     * 获取数值形式的最后价格
     */
    public BigDecimal getNumericLastPrice() {
        try {
            return new BigDecimal(lastPrice);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取数值形式的涨跌幅
     */
    public BigDecimal getNumericPriceChangePercent() {
        try {
            return new BigDecimal(priceChangePercent);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取数值形式的交易量
     */
    public BigDecimal getNumericVolume() {
        try {
            return new BigDecimal(volume);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
}</code></pre><h4>最新价格数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 最新价格数据模型
 */
@Data
public class LastPrice {
    @JsonProperty("symbol")
    private String symbol;
    
    @JsonProperty("price")
    private String price;
    
    /**
     * 获取数值形式的价格
     */
    public BigDecimal getNumericPrice() {
        try {
            return new BigDecimal(price);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
}</code></pre><h4>K线数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import lombok.Data;

import java.math.BigDecimal;

/**
 * K线数据模型
 */
@Data
public class KLine {
    private Long openTime;
    private BigDecimal openPrice;
    private BigDecimal highPrice;
    private BigDecimal lowPrice;
    private BigDecimal closePrice;
    private BigDecimal volume;
    private Long closeTime;
    private BigDecimal quoteAssetVolume;
    private Integer numberOfTrades;
    private BigDecimal takerBuyBaseAssetVolume;
    private BigDecimal takerBuyQuoteAssetVolume;
    private String ignore;
    
    /**
     * 构造函数 - 从数组解析
     */
    public KLine(Object[] data) {
        if (data != null &amp;&amp; data.length &gt;= 11) {
            this.openTime = ((Number) data[0]).longValue();
            this.openPrice = new BigDecimal(data[1].toString());
            this.highPrice = new BigDecimal(data[2].toString());
            this.lowPrice = new BigDecimal(data[3].toString());
            this.closePrice = new BigDecimal(data[4].toString());
            this.volume = new BigDecimal(data[5].toString());
            this.closeTime = ((Number) data[6]).longValue();
            this.quoteAssetVolume = new BigDecimal(data[7].toString());
            this.numberOfTrades = ((Number) data[8]).intValue();
            this.takerBuyBaseAssetVolume = new BigDecimal(data[9].toString());
            this.takerBuyQuoteAssetVolume = new BigDecimal(data[10].toString());
            if (data.length &gt; 11) {
                this.ignore = data[11].toString();
            }
        }
    }
    
    /**
     * 计算振幅百分比
     */
    public BigDecimal getAmplitudePercent() {
        if (openPrice.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO;
        }
        return highPrice.subtract(lowPrice)
                .divide(openPrice, 4, BigDecimal.ROUND_HALF_UP)
                .multiply(BigDecimal.valueOf(100));
    }
    
    /**
     * 计算涨跌幅百分比
     */
    public BigDecimal getChangePercent() {
        if (openPrice.compareTo(BigDecimal.ZERO) == 0) {
            return BigDecimal.ZERO;
        }
        return closePrice.subtract(openPrice)
                .divide(openPrice, 4, BigDecimal.ROUND_HALF_UP)
                .multiply(BigDecimal.valueOf(100));
    }
}</code></pre><h4>交易数据模型</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.math.BigDecimal;

/**
 * 交易数据模型
 */
@Data
public class Trade {
    @JsonProperty("quoteQty")
    private String quoteQty;
    
    @JsonProperty("price")
    private String price;
    
    @JsonProperty("qty")
    private String qty;
    
    @JsonProperty("isBestMatch")
    private Boolean isBestMatch;
    
    @JsonProperty("id")
    private Long id;
    
    @JsonProperty("time")
    private Long time;
    
    @JsonProperty("isBuyerMaker")
    private Boolean isBuyerMaker;
    
    /**
     * 获取数值形式的价格
     */
    public BigDecimal getNumericPrice() {
        try {
            return new BigDecimal(price);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取数值形式的数量
     */
    public BigDecimal getNumericQty() {
        try {
            return new BigDecimal(qty);
        } catch (Exception e) {
            return BigDecimal.ZERO;
        }
    }
    
    /**
     * 获取交易方向
     */
    public String getTradeDirection() {
        return Boolean.TRUE.equals(isBuyerMaker) ? "SELL" : "BUY";
    }
}</code></pre><h4>API响应包装类</h4><pre><code class="java">package com.stocktv.binance.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.List;

/**
 * API通用响应包装类
 */
@Data
public class ApiResponse&lt;T&gt; {
    @JsonProperty("code")
    private Integer code;
    
    @JsonProperty("message")
    private String message;
    
    @JsonProperty("data")
    private T data;
    
    /**
     * 判断请求是否成功
     */
    public boolean isSuccess() {
        return code != null &amp;&amp; code == 200;
    }
}

/**
 * 交易对列表响应包装类
 */
@Data
class PairListResponse {
    @JsonProperty("total_count")
    private Integer totalCount;
    
    @JsonProperty("total_page")
    private Integer totalPage;
    
    @JsonProperty("list")
    private List&lt;CryptoPair&gt; list;
    
    @JsonProperty("fields")
    private List&lt;String&gt; fields;
}</code></pre><h3>3. HTTP客户端实现</h3><pre><code class="java">package com.stocktv.binance.client;

import com.fasterxml.jackson.core.type.TypeReference;
import com.stocktv.binance.config.BinanceConfig;
import com.stocktv.binance.model.*;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.util.EntityUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * 币安数据HTTP客户端
 */
public class BinanceHttpClient {
    
    private static final Logger logger = LoggerFactory.getLogger(BinanceHttpClient.class);
    
    private final BinanceConfig config;
    private final CloseableHttpClient httpClient;
    
    public BinanceHttpClient(BinanceConfig config) {
        this.config = config;
        this.httpClient = config.getHttpClient();
    }
    
    /**
     * 获取交易对列表
     */
    public List&lt;CryptoPair&gt; getPairList(Integer page, Integer size) throws IOException, URISyntaxException {
        URIBuilder uriBuilder = new URIBuilder(config.BASE_URL + config.CRYPTO_PAIR_LIST)
                .addParameter("key", config.getApiKey())
                .addParameter("marketId", String.valueOf(config.BINANCE_MARKET_ID));
        
        if (page != null) {
            uriBuilder.addParameter("page", String.valueOf(page));
        }
        if (size != null) {
            uriBuilder.addParameter("size", String.valueOf(size));
        }
        
        URI uri = uriBuilder.build();
        
        ApiResponse&lt;PairListResponse&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;PairListResponse&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取 {} 个交易对", response.getData().getList().size());
            return response.getData().getList();
        } else {
            throw new RuntimeException("获取交易对列表失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取最新行情
     */
    public List&lt;TickerPrice&gt; getTickerPrice(List&lt;String&gt; symbols) throws IOException, URISyntaxException {
        if (symbols == null || symbols.isEmpty()) {
            throw new IllegalArgumentException("交易对列表不能为空");
        }
        
        // 限制最大数量
        if (symbols.size() &gt; 100) {
            symbols = symbols.subList(0, 100);
            logger.warn("交易对数量超过限制，只取前100个");
        }
        
        String symbolsStr = String.join(",", symbols);
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_TICKER_PRICE)
                .addParameter("key", config.getApiKey())
                .addParameter("symbols", symbolsStr)
                .build();
        
        ApiResponse&lt;List&lt;TickerPrice&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;TickerPrice&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取 {} 个交易对的最新行情", response.getData().size());
            return response.getData();
        } else {
            throw new RuntimeException("获取最新行情失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取最新价格
     */
    public List&lt;LastPrice&gt; getLastPrice(List&lt;String&gt; symbols) throws IOException, URISyntaxException {
        if (symbols == null || symbols.isEmpty()) {
            throw new IllegalArgumentException("交易对列表不能为空");
        }
        
        // 限制最大数量
        if (symbols.size() &gt; 100) {
            symbols = symbols.subList(0, 100);
            logger.warn("交易对数量超过限制，只取前100个");
        }
        
        String symbolsStr = String.join(",", symbols);
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_LAST_PRICE)
                .addParameter("key", config.getApiKey())
                .addParameter("symbols", symbolsStr)
                .build();
        
        ApiResponse&lt;List&lt;LastPrice&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;LastPrice&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取 {} 个交易对的最新价格", response.getData().size());
            return response.getData();
        } else {
            throw new RuntimeException("获取最新价格失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取K线数据
     */
    public List&lt;KLine&gt; getKlines(String symbol, String interval) throws IOException, URISyntaxException {
        if (symbol == null || symbol.trim().isEmpty()) {
            throw new IllegalArgumentException("交易对不能为空");
        }
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_GET_KLINES)
                .addParameter("key", config.getApiKey())
                .addParameter("symbol", symbol)
                .addParameter("interval", interval)
                .build();
        
        // K线数据返回的是数组的数组
        ApiResponse&lt;List&lt;Object[]&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;Object[]&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            List&lt;KLine&gt; klines = response.getData().stream()
                    .map(KLine::new)
                    .collect(Collectors.toList());
            logger.info("成功获取交易对 {} 的K线数据，共 {} 条", symbol, klines.size());
            return klines;
        } else {
            throw new RuntimeException("获取K线数据失败: " + response.getMessage());
        }
    }
    
    /**
     * 获取近期成交
     */
    public List&lt;Trade&gt; getTrades(String symbol) throws IOException, URISyntaxException {
        if (symbol == null || symbol.trim().isEmpty()) {
            throw new IllegalArgumentException("交易对不能为空");
        }
        
        URI uri = new URIBuilder(config.BASE_URL + config.CRYPTO_GET_TRADES)
                .addParameter("key", config.getApiKey())
                .addParameter("symbol", symbol)
                .build();
        
        ApiResponse&lt;List&lt;Trade&gt;&gt; response = executeGetRequest(uri, 
            new TypeReference&lt;ApiResponse&lt;List&lt;Trade&gt;&gt;&gt;() {});
        
        if (response.isSuccess()) {
            logger.info("成功获取交易对 {} 的成交数据，共 {} 条", symbol, response.getData().size());
            return response.getData();
        } else {
            throw new RuntimeException("获取成交数据失败: " + response.getMessage());
        }
    }
    
    /**
     * 搜索交易对
     */
    public List&lt;CryptoPair&gt; searchPairs(String keyword, Integer limit) throws IOException, URISyntaxException {
        List&lt;CryptoPair&gt; allPairs = getPairList(1, 1000); // 获取较多数据用于搜索
        
        return allPairs.stream()
                .filter(pair -&gt; 
                    pair.getSymbol().toLowerCase().contains(keyword.toLowerCase()) ||
                    pair.getName().toLowerCase().contains(keyword.toLowerCase()) ||
                    (pair.getSearchField() != null &amp;&amp; 
                     pair.getSearchField().toLowerCase().contains(keyword.toLowerCase())))
                .limit(limit != null ? limit : 10)
                .collect(Collectors.toList());
    }
    
    /**
     * 获取Top N市值的加密货币
     */
    public List&lt;CryptoPair&gt; getTopMarketCapPairs(int topN) throws IOException, URISyntaxException {
        List&lt;CryptoPair&gt; allPairs = getPairList(1, topN);
        
        // 按排名排序
        return allPairs.stream()
                .sorted((p1, p2) -&gt; {
                    if (p1.getRank() == null) return 1;
                    if (p2.getRank() == null) return -1;
                    return p1.getRank().compareTo(p2.getRank());
                })
                .limit(topN)
                .collect(Collectors.toList());
    }
    
    /**
     * 通用GET请求执行方法
     */
    private &lt;T&gt; T executeGetRequest(URI uri, TypeReference&lt;T&gt; typeReference) throws IOException {
        HttpGet request = new HttpGet(uri);
        logger.debug("执行币安API请求: {}", uri);
        
        try (CloseableHttpResponse response = httpClient.execute(request)) {
            int statusCode = response.getStatusLine().getStatusCode();
            String responseBody = EntityUtils.toString(response.getEntity());
            
            if (statusCode != 200) {
                throw new IOException("HTTP请求失败，状态码: " + statusCode);
            }
            
            logger.debug("币安API响应: {}", responseBody);
            return config.getObjectMapper().readValue(responseBody, typeReference);
        }
    }
    
    /**
     * 关闭HTTP客户端
     */
    public void close() throws IOException {
        if (httpClient != null) {
            httpClient.close();
        }
    }
}</code></pre><h3>4. WebSocket客户端实现</h3><pre><code class="java">package com.stocktv.binance.client;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.stocktv.binance.config.BinanceConfig;
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.handshake.ServerHandshake;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * 币安WebSocket实时数据客户端
 */
public class BinanceWebSocketClient {
    
    private static final Logger logger = LoggerFactory.getLogger(BinanceWebSocketClient.class);
    
    private final BinanceConfig config;
    private final ObjectMapper objectMapper;
    private WebSocketClient webSocketClient;
    private CountDownLatch connectionLatch;
    
    public BinanceWebSocketClient(BinanceConfig config) {
        this.config = config;
        this.objectMapper = config.getObjectMapper();
    }
    
    /**
     * 连接WebSocket服务器
     */
    public void connect() throws Exception {
        String wsUrl = config.WS_URL + "?key=" + config.getApiKey();
        URI serverUri = URI.create(wsUrl);
        
        connectionLatch = new CountDownLatch(1);
        
        webSocketClient = new WebSocketClient(serverUri) {
            @Override
            public void onOpen(ServerHandshake handshake) {
                logger.info("币安WebSocket连接已建立");
                connectionLatch.countDown();
            }
            
            @Override
            public void onMessage(String message) {
                try {
                    handleRealTimeMessage(message);
                } catch (Exception e) {
                    logger.error("处理WebSocket消息时出错", e);
                }
            }
            
            @Override
            public void onClose(int code, String reason, boolean remote) {
                logger.info("币安WebSocket连接已关闭: code={}, reason={}, remote={}", code, reason, remote);
            }
            
            @Override
            public void onError(Exception ex) {
                logger.error("币安WebSocket连接错误", ex);
            }
        };
        
        webSocketClient.connect();
        
        // 等待连接建立
        if (!connectionLatch.await(10, TimeUnit.SECONDS)) {
            throw new RuntimeException("WebSocket连接超时");
        }
    }
    
    /**
     * 处理实时消息
     */
    private void handleRealTimeMessage(String message) throws Exception {
        JsonNode jsonNode = objectMapper.readTree(message);
        
        // 解析实时行情数据
        if (jsonNode.has("symbol") || jsonNode.has("pid")) {
            RealTimeData realTimeData = parseRealTimeData(jsonNode);
            onRealTimeData(realTimeData);
        } else {
            logger.debug("收到其他消息: {}", message);
        }
    }
    
    /**
     * 解析实时数据
     */
    private RealTimeData parseRealTimeData(JsonNode jsonNode) {
        RealTimeData data = new RealTimeData();
        
        if (jsonNode.has("symbol")) {
            data.setSymbol(jsonNode.get("symbol").asText());
        }
        if (jsonNode.has("pid")) {
            data.setPid(jsonNode.get("pid").asText());
        }
        if (jsonNode.has("last_numeric")) {
            data.setLastPrice(jsonNode.get("last_numeric").asText());
        }
        if (jsonNode.has("bid")) {
            data.setBid(jsonNode.get("bid").asText());
        }
        if (jsonNode.has("ask")) {
            data.setAsk(jsonNode.get("ask").asText());
        }
        if (jsonNode.has("high")) {
            data.setHigh(jsonNode.get("high").asText());
        }
        if (jsonNode.has("low")) {
            data.setLow(jsonNode.get("low").asText());
        }
        if (jsonNode.has("pc")) {
            data.setPriceChange(jsonNode.get("pc").asText());
        }
        if (jsonNode.has("pcp")) {
            data.setChangePercent(jsonNode.get("pcp").asText());
        }
        if (jsonNode.has("turnover_numeric")) {
            data.setVolume(jsonNode.get("turnover_numeric").asText());
        }
        if (jsonNode.has("time")) {
            data.setTime(jsonNode.get("time").asText());
        }
        if (jsonNode.has("timestamp")) {
            data.setTimestamp(jsonNode.get("timestamp").asText());
        }
        
        return data;
    }
    
    /**
     * 处理实时数据
     */
    protected void onRealTimeData(RealTimeData data) {
        String symbol = data.getSymbol() != null ? data.getSymbol() : data.getPid();
        
        // 记录基础信息
        logger.debug("实时行情: {} - 价格: {}, 涨跌幅: {}%", 
            symbol, data.getLastPrice(), data.getChangePercent());
        
        // 价格预警逻辑
        try {
            double changePercent = Double.parseDouble(data.getChangePercent());
            if (Math.abs(changePercent) &gt; 5.0) {
                logger.warn("🚨 加密货币价格波动预警: {} 波动 {}%", symbol, changePercent);
            }
            
            // 大额交易监控
            if (data.getVolume() != null) {
                double volume = Double.parseDouble(data.getVolume());
                if (volume &gt; 1000000) { // 100万美元以上
                    logger.info("💰 大额交易: {} 成交额 ${}", symbol, volume);
                }
            }
        } catch (NumberFormatException e) {
            // 忽略转换错误
        }
    }
    
    /**
     * 发送消息
     */
    public void sendMessage(String message) {
        if (webSocketClient != null &amp;&amp; webSocketClient.isOpen()) {
            webSocketClient.send(message);
        }
    }
    
    /**
     * 关闭连接
     */
    public void close() {
        if (webSocketClient != null) {
            webSocketClient.close();
        }
    }
    
    /**
     * 实时数据模型
     */
    public static class RealTimeData {
        private String pid;
        private String symbol;
        private String lastPrice;
        private String bid;
        private String ask;
        private String high;
        private String low;
        private String priceChange;
        private String changePercent;
        private String volume;
        private String time;
        private String timestamp;
        
        // Getters and Setters
        public String getPid() { return pid; }
        public void setPid(String pid) { this.pid = pid; }
        public String getSymbol() { return symbol; }
        public void setSymbol(String symbol) { this.symbol = symbol; }
        public String getLastPrice() { return lastPrice; }
        public void setLastPrice(String lastPrice) { this.lastPrice = lastPrice; }
        public String getBid() { return bid; }
        public void setBid(String bid) { this.bid = bid; }
        public String getAsk() { return ask; }
        public void setAsk(String ask) { this.ask = ask; }
        public String getHigh() { return high; }
        public void setHigh(String high) { this.high = high; }
        public String getLow() { return low; }
        public void setLow(String low) { this.low = low; }
        public String getPriceChange() { return priceChange; }
        public void setPriceChange(String priceChange) { this.priceChange = priceChange; }
        public String getChangePercent() { return changePercent; }
        public void setChangePercent(String changePercent) { this.changePercent = changePercent; }
        public String getVolume() { return volume; }
        public void setVolume(String volume) { this.volume = volume; }
        public String getTime() { return time; }
        public void setTime(String time) { this.time = time; }
        public String getTimestamp() { return timestamp; }
        public void setTimestamp(String timestamp) { this.timestamp = timestamp; }
    }
}</code></pre>]]></description></item><item>    <title><![CDATA[八骏医疗云：解码眼科设备制造厂商的客户关]]></title>    <link>https://segmentfault.com/a/1190000047400097</link>    <guid>https://segmentfault.com/a/1190000047400097</guid>    <pubDate>2025-11-14 16:02:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在现代医疗行业，客户关系管理（CRM）已成为企业提升运营效率、优化服务体验和增强市场竞争力的关键工具。特别是对于眼科医疗设备企业而言，CRM系统不仅是客户信息的存储与管理平台，更是连接医疗设备销售、售后服务、客户关系维护及市场拓展的重要桥梁。<br/><img width="723" height="496" referrerpolicy="no-referrer" src="/img/bVdm25P" alt="image.png" title="image.png"/><br/>本文将围绕眼科医疗设备企业的CRM软件，深入分析其在客户关系管理中的核心功能与应用场景，帮助用户更好地理解该系统如何助力眼科医疗设备企业实现高效、精准的客户管理。</p><hr/><h2>一、眼科医疗设备企业CRM软件的核心特点</h2><p>眼科医疗设备企业的客户关系管理具有以下特点：</p><ol><li><strong>精准客户画像</strong>\<br/>企业需要根据客户类型（如医院、诊所、个体医生等）进行分类管理，CRM系统可以帮助企业快速建立客户档案，实现个性化的服务与营销策略。</li><li><strong>多渠道客户互动</strong>\<br/>医疗设备销售通常涉及医院采购、医生咨询、设备维护等多个环节，CRM系统需支持多渠道客户互动，包括电话、邮件、在线客服、社交媒体等。</li><li><strong>销售流程自动化</strong>\<br/>眼科设备销售流程通常包括产品介绍、报价、订单处理、售后服务等，CRM系统可自动触发销售流程，提升效率。</li><li><strong>数据分析与洞察</strong>\<br/>企业需要通过客户数据进行分析，以优化产品推广、售后服务和客户满意度。CRM系统提供数据可视化工具，帮助企业洞察客户需求和市场趋势。</li></ol><hr/><h2>二、八骏CRM医疗版的功能拆解</h2><h3>1. <strong>客户信息管理：精准标签与分类</strong></h3><p>八骏CRM医疗版支持对客户进行多维标签管理，如医院类型（综合医院、眼科专科医院等）、客户级别（VIP客户、普通客户）、设备需求类型（如白内障手术设备、角膜移植设备等）。通过标签体系，企业可实现客户的精准分类，制定差异化的服务策略。</p><h3>2. <strong>销售流程自动化：从线索获取到售后跟进</strong></h3><ul><li><strong>线索管理</strong>：系统支持线索来源的分类与跟踪，如医院采购、医生推荐、展会邀约等。</li><li><strong>销售流程自动化</strong>：系统可自动完成报价、合同签署、订单处理、发货通知等流程，减少人工干预，提升效率。</li><li><strong>售后跟进</strong>：客户购买设备后，系统可自动提醒售后人员进行设备安装、使用培训、维护记录等，提升客户满意度。</li></ul><h3>3. <strong>多渠道客户互动：提升客户体验</strong></h3><ul><li><strong>在线客服与消息通知</strong>：支持客户通过系统实时咨询、预约、反馈问题。</li><li><strong>客户反馈与评价管理</strong>：客户可对产品和服务进行评价，系统自动归类并分析反馈趋势，帮助企业优化产品和服务。</li><li><strong>社交媒体整合</strong>：系统支持客户在社交媒体上的互动，如客户留言、产品使用分享等，提升品牌曝光度。</li></ul><h3>4. <strong>数据分析与客户洞察</strong></h3><ul><li><strong>客户行为分析</strong>：系统能够分析客户购买记录、使用频率、售后服务反馈等数据，帮助企业挖掘客户需求。</li><li><strong>客户生命周期管理</strong>：系统可根据客户状态（如新客户、潜在客户、流失客户）进行生命周期管理，制定相应的跟进策略。</li><li><strong>销售漏斗分析</strong>：通过销售流程的可视化分析，企业可以优化销售策略，提升转化率。</li></ul><hr/><h2>三、总结：选择CRM软件的关键考量</h2><p>对于眼科医疗设备企业而言，选择合适的CRM软件至关重要：</p><ul><li><strong>精准客户管理</strong>：系统需支持多维度客户标签与分类，提升客户管理的精准度。</li><li><strong>销售流程自动化</strong>：自动化流程可减少人力成本，提升销售效率。</li><li><strong>多渠道客户互动</strong>：支持多种沟通方式，提升客户体验与满意度。</li><li><strong>数据分析与洞察</strong>：通过数据驱动决策，优化产品与服务策略。</li></ul><p>八骏CRM医疗版以其强大的客户管理功能、高效的工作流程和全面的数据分析能力，成为眼科医疗设备企业提升客户服务质量与市场竞争力的理想选择。</p><hr/><h2>四、结语</h2><p>在医疗设备行业，CRM软件不仅是工具，更是企业实现精细化运营和客户价值挖掘的核心引擎。八骏CRM医疗版以其专业的功能设计和灵活的行业适配性，为眼科医疗设备企业提供了可靠的支持，助力企业在激烈的市场竞争中脱颖而出。</p><p>选择合适的CRM软件，是企业数字化转型的关键一步。希望本文能为眼科医疗设备企业选择CRM系统提供有价值的参考。</p>]]></description></item><item>    <title><![CDATA[导师型领导指南 俞凡 ]]></title>    <link>https://segmentfault.com/a/1190000047400107</link>    <guid>https://segmentfault.com/a/1190000047400107</guid>    <pubDate>2025-11-14 16:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><em>本文介绍了导师型领导的管理应该如何指导团队成员的通用原则，分析了不同学员的类型，以及针对不同类型学员的应对方式。原文：<a href="https://link.segmentfault.com/?enc=If5x7oiSD1CtugRhoooV3g%3D%3D.pEkDeNjxN9MQD1b%2FfKTGTD4y1yGWNQFdqekXMzTONMNwCbvdZqEYsL9IteLtMOHrlWsDFOJ5yRDXbip40cFQZrKln0yY1GmMhRncgSlos3jizyOqWIPYeiP8160Wtd2G" rel="nofollow" title="How to be a good mentor for your whole team" target="_blank">How to be a good mentor for your whole team</a></em></blockquote><p>在理想的世界里，所有管理者都会秉持导师型工作理念。但在现实世界中并非如此，世界显然并不完美,许多管理者只是完成工作而已。他们确保团队能够出色执行任务，但与那些秉持导师理念的管理者不同，他们对帮助员工应对新挑战或抓住新机遇并不太感兴趣。</p><p>要预测哪种类型的管理者能带领团队取得更好的成绩，或者在年度评估时获得更高的评价，其实并不需要多么复杂的算法。</p><p>关键在于，导师指导并非适用于所有情况。诚然，有些指导原则是通用的，这里就直接总结要点：</p><ul><li><strong>一致性</strong>：按照固定节奏进行交流，但也要根据实际情况灵活安排临时会议。</li><li><a href="https://link.segmentfault.com/?enc=pUUECBnLRxjW9FT5CqfpGA%3D%3D.cLEjf6gwmLq31GFe6ovObdHoqa%2FTR6Mi%2F12Av24Pr4QG%2FePrK5v2UMXavc%2FxLyFGJB6bVefTPFVPusbEZg%2F%2FLQ%3D%3D" rel="nofollow" title="**积极倾听**" target="_blank"><strong>积极倾听</strong></a>：与被指导者会面时，要静下心来，全神贯注，关掉手机，关闭电脑，以减少干扰。在交流过程中做笔记并提出疑问。</li><li><strong>建设性反馈</strong>：单方面批评是不够的，要为被指导者在遭遇挫折后如何继续前进或下次如何做出不同选择提供切实可行的建议。</li><li><strong>适当的挑战</strong>：要鼓励被指导者超越舒适区，但要以同理心的方式进行。他们的处境和/或个性可能会限制他们能够或愿意做的事情。</li><li><strong>乐观（与现实相结合）</strong>：在大多数情况下，保持积极态度并专注于激励被指导者是最佳选择。但有时事情确实不会如愿发展。坦诚交流可以帮助他们认识到何时该放弃损失并尝试新的方法。</li></ul><p>但要对所管理的人员产生深远影响，必须根据每个个体的特点调整指导方式。有些人容易合作，而指导其他人可能就不那么直接了。我们基于自身经验，再加上来自<a href="https://link.segmentfault.com/?enc=P7jGypaPUe1p2W%2BQ4ZDL%2Bw%3D%3D.KsP0xAIVeI78FjRpBOxgwJI%2BLfYBXBtURI3ZMBosZeh8I2%2Fe4bkvCX0ZIGm%2FnwYj" rel="nofollow" title="全球导师网络" target="_blank">全球导师网络</a>和 <a href="https://link.segmentfault.com/?enc=Zue5Ba6%2FdDZxGvVSHGaX9g%3D%3D.zJ6XYgijCTnc0Q7Xe2ydoA4X27zm3TNx5rS%2BqA%2BblJRHDuVNoIIXY0lrBmNkhfY%2B" rel="nofollow" title="Together" target="_blank">Together</a> 组织的一些有用资料，编写了这份指南，旨在帮助大家了解常见的人员类型，并指导如何与每一种类型的人员建立导师与学员的关系。</p><h2>学员类型及需求</h2><p>旁注：虽然我们是从管理者与直接下属合作的角度来看待问题，但下面的所有内容都适用于各种各样的情况。所以，如果你以老师、教授、教练、资深同事、朋友或亲戚的身份指导某人，你的位置仍然是正确的。</p><h5>1. 明星学员</h5><p><strong>特点</strong>：雄心勃勃；专注于职业发展；做事有条理且注重细节。</p><p><strong>需要的是</strong>：关于优先事项的指导。</p><p>这些学员的积极性堪称爆棚。如果有什么需要的话，他们只是需要一些提醒来控制自己的进度，以免过度劳累而精疲力竭。你的职责是帮助他们明确、可实现的目标，并将其分解为阶段性目标。要监督他们的表现，如果偏离正轨要及时引导他们回到正确的轨道上来。由于有着如此强烈的动力和好奇心，如果不能持续专注于自己的“北极星”目标，他们可能会变得过于分散精力。但你也应该教导他们对自己要有耐心（他们往往在这方面存在困难！），如果内心的声音变得过于强烈，要让他们安静下来。当他们达成某个阶段性目标时，准备好与他们击掌庆祝。优秀人才都喜欢一些外部的认可。</p><h5>2. 未经雕琢的璞玉</h5><p><strong>特点</strong>：大量未实现的潜力；容易犯错（诚实、粗心的）；倾向于开放和好奇，但不一定活泼或外向。</p><p><strong>需要的是</strong>：一个练习对手。</p><p>璞玉未经雕琢时，并不一定清楚自己最终想要成为什么样的人。是成为注重策略的管理者？还是成为精通某项领域的顶尖高手？两种可能性都有！你可以通过为他们提供提升现有技能或学习新技能的机会，为他们的探索活动赋予方向。在他们处理超出自身能力范围的项目时，挑战并引导他们的思维。你还可以用你的人脉介绍一些能够帮助他们发展的人。</p><h5>3. 自我驱动者</h5><p><strong>特点</strong>：非常独立；想要自己全权负责，这样才能按照自己的方式去做；对于日常小事不寻求他人的建议。</p><p><strong>需要的是</strong>：灵感与自我反省。</p><p>自我驱动者具有强烈的自主意识、自我激励能力和自我推进能力，这对于注重指导管理的管理者来说可能颇具挑战性。因为他们倾向于自行设定目标，所以你的任务就是向他们展示各种可能性，然后让他们自行决定如何（以及是否）实现这些目标。另一种能够产生影响的方式是帮助他们发现自身可能未曾意识到的长处，并找出需要加强的弱点。帮助他们成为最好的自己，他们就能开创出最辉煌的职业生涯。</p><h5>4. 无所不知的人</h5><p><strong>特点</strong>：年龄比经理大，或者拥有更丰富的行业经验；事业有成；可能在团队之外也有自己的导师。</p><p><strong>需要的是</strong>：团结。</p><p>请不要往心里去，但这个人并不确定能从你这里学到多少东西。毕竟，他们在这一领域的从业时间比你长得多。像你这样的新手能给什么帮助呢？答案是合作。不要试图引导他们的职业生涯，而是要帮助他们找到能推进他们已有目标的项目。此外，把自己当作解决棘手职场问题的资源，比如与同事之间的冲突或预算削减等问题。你甚至可以提议“反向指导”，即他们指导你在某个你想要改进的领域进行提升。</p><h5>5. 流浪者</h5><p><strong>特点</strong>：表现不佳，潜力尚未开发；拖累工作；工作质量落后于团队的其他成员。</p><p><strong>需要的是</strong>：通往成功的路线图。</p><p>这个人可能面临诸多困境。你的首要任务是找出原因。比如，个人生活中的困难是否影响了他们的工作表现？例如，新添的宝宝或家庭中的重大疾病都可能对工作表现造成严重影响，又或者也许这个职位并不适合他们。一旦你们共同确定了根本原因，就一起制定改进计划或过渡计划，设定里程碑和目标日期。在过程中要庆祝他们的进步。如果他们出现失误，要让他们承担责任，但同时也要用无条件的同情来平衡你的建设性批评。</p><h5>6. 天生敏感特质</h5><p><strong>特点</strong>：性格敏感；容易产生防御心理；可能因批评而产生愤怒或绝望的情绪。</p><p><strong>需要的是</strong>：同情心和自信。</p><p>要留意这个人身上是否存在“<a href="https://link.segmentfault.com/?enc=UIO2WLJLAPKpb%2BYlx9eI%2Bg%3D%3D.GWzZKhWHxi7lI4KPgGhdeqmRIXROxCYFgcMuKxDTgDQBfS%2FzrrOVCbhBtWkn9DoGDvpHEdSWcn1pHD1rkhIZYMHDq6XxLIrNR6MjeusKk5ZSTShyDj5E2PFjhSU2pIGt" rel="nofollow" title="冒充者综合征" target="_blank">冒充者综合征</a>”迹象。很有可能他们觉得自己在能力方面力不从心，或者被繁重的工作压得喘不过气来。关键在于要认可他们的感受，但不要加以评判。首先，询问他们认为自己面临的最大障碍是什么，然后一起制定克服或绕过这些障碍的计划。要保持真诚 —— 不要过度称赞平庸的工作表现 —— 但要多给予积极反馈，以帮助提升他们的信心。如果能在公开场合（比如团队会议或 Slack 群组）对他们进行表扬，那就更好了。</p><h2>避免误区</h2><p>积极参与导师指导有助于你成长为优秀的领导者。同时，也能够帮助团队成员成长，而这恰恰是良好领导力的体现。但在你踏上这段旅程之前，有几个潜在隐患需要留意。</p><p>首先，要明确自己能够提供的服务范围，这既是为了自己的利益，也是为了学员们的利益。很容易就会过度投入，尤其是如果你天生倾向于服务型领导风格的话。一旦学员开始期望你有如此高强度的参与度，要收回这种投入就真的很难了。</p><p>尽早设定界限，并要具体明确。例如，你不会替他们撰写项目提案，但会乐意对草稿提供反馈。或者，你会倾听他们与同事之间的矛盾，并给出建议，但不会贸然去找那个人的经理来解决问题。</p><p>第二条建议来自研究者、作家兼知名人士布伦妮·布朗：<a href="https://link.segmentfault.com/?enc=dWXZnr07TySUgo2tJW%2FqFQ%3D%3D.33k86Eu5FZvC3CISqPuzqhBQtJ1HmoHVGzxNX%2BVeVEN5nzVRlY%2BDAE47YhZUzVs4WJFgGiiOKoprG7n7XfNX8Q%3D%3D" rel="nofollow" title="要学会恰当运用内疚情绪，但要避免对其进行羞辱" target="_blank">要学会恰当运用内疚情绪，但要避免对其进行羞辱</a>。两者的区别在于，内疚让我们明白自己犯了错误，需要做得更好；而羞耻则让我们觉得自己不配获得成功。</p><p>所以，当团队成员出现失误时，应从其行为或表现方面进行讨论，而非从其个人角度出发 —— 要说“那是个错误决定”，不要说“你是个糟糕的决策者”。正如布朗指出的，羞辱更有可能引发或加剧问题，而非解决问题。</p><p>现在就行动起来吧，去帮助某人让今天变得精彩！</p><hr/><blockquote>你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。为了方便大家以后能第一时间看到文章，请朋友们关注公众号"DeepNoMind"，并设个星标吧，如果能一键三连(转发、点赞、在看)，则能给我带来更多的支持和动力，激励我持续写下去，和大家共同成长进步！</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=pW8ORexPSSzB5g3YHYy1XA%3D%3D.broKzVfH3a8D6LVN2dPtvTsVNsVdEMiiDFCmGptMl9E%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[眼科设备制造厂商如何选对CRM？2025]]></title>    <link>https://segmentfault.com/a/1190000047400118</link>    <guid>https://segmentfault.com/a/1190000047400118</guid>    <pubDate>2025-11-14 16:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>引言：眼科设备制造行业的挑战与机遇</h2><p>在2025年，随着医疗技术的不断发展和市场竞争的加剧，眼科设备制造厂商面临着前所未有的挑战与机遇。从产品研发到市场开拓，从客户关系到售后服务，每一个环节都要求企业具备高效的管理工具和精准的销售策略。</p><p><strong>痛点分析：</strong></p><ul><li><strong>客户需求多样化</strong>：客户对产品性能、价格、售后体验等有较高要求。</li><li><strong>销售流程复杂</strong>：从需求挖掘、方案制定、合同签订到交付服务，流程繁琐。</li><li><strong>数据管理滞后</strong>：缺乏系统化的客户数据管理，影响销售决策和客户体验。</li><li><strong>售后服务压力大</strong>：设备维护、技术支持、客户反馈等环节需持续跟踪。</li></ul><hr/><h2>一、眼科设备制造行业销售特点分析</h2><h3>1.1 客户画像复杂</h3><p>眼科设备客户主要包括医院、诊所、医疗器械公司等，客户群体具有专业性强、需求明确、合同金额大等特点。</p><h3>1.2 需求周期长</h3><p>从产品介绍、方案设计到签订合同，通常需要数周甚至数月，周期较长，对CRM系统的时间管理能力提出了较高要求。</p><h3>1.3 交互合作频繁</h3><p>销售、市场、研发、售后等多个部门频繁协作，信息共享和流程协同至关重要。</p><h3>1.4 服务不可替代性强</h3><p>眼科设备具有较高的技术壁垒，客户对售后服务的满意度直接影响品牌口碑与复购率。</p><hr/><h2>二、眼科设备制造厂商的智能解决方案</h2><h3>2.1 产品功能概述</h3><p>以<strong>八骏CRM医疗版</strong>为例，这是一款专为医疗行业定制的客户关系管理软件，其核心功能包括：<br/><img width="723" height="498" referrerpolicy="no-referrer" src="/img/bVdm254" alt="image.png" title="image.png"/></p><ul><li><strong>客户信息管理</strong>：支持客户画像、历史沟通、订单记录、合同管理等，实现客户数据的标准化和可视化。</li><li><strong>销售流程自动化</strong>：从线索获取、商机跟踪、销售流程到合同签订，一键完成，提升销售效率。</li><li><strong>多部门协同管理</strong>：支持销售、市场、研发、售后等部门协同工作，提高跨部门协作效率。</li><li><strong>数据分析与洞察</strong>：提供客户行为分析、销售趋势预测、潜在客户挖掘等功能，辅助决策。</li><li><strong>合规与审计</strong>：满足医疗行业严格的合规要求，支持审计追踪和数据安全。</li></ul><h3>2.2 功能拆解与适用性分析</h3><h4>2.2.1 客户信息管理</h4><ul><li><strong>客户画像</strong>：支持按医院、科室、医生等维度建立客户档案，提升精准营销能力。</li><li><strong>沟通记录</strong>：记录客户沟通内容、沟通时间、沟通方式等，便于后续跟进与服务。</li><li><strong>合同管理</strong>：支持合同签订、履约跟踪、付款记录，确保合同执行透明化。</li></ul><h4>2.2.2 销售流程自动化</h4><ul><li><strong>线索管理</strong>：自动识别潜在客户，推送至销售团队。</li><li><strong>商机跟踪</strong>：支持商机状态更新、责任人分配，确保销售进度可视化。</li><li><strong>销售流程</strong>：从需求分析、方案推荐、合同签订到售后服务，全流程自动化，减少人工干预。</li></ul><h4>2.2.3 多部门协同</h4><ul><li><strong>销售与市场协同</strong>：支持销售团队与市场团队同步客户信息，提升营销效率。</li><li><strong>研发与销售协同</strong>：研发团队可根据销售反馈优化产品，提升产品竞争力。</li><li><strong>售后与客户协同</strong>：售后团队可实时反馈客户使用问题，提升客户满意度。</li></ul><h4>2.2.4 数据分析与洞察</h4><ul><li><strong>客户行为分析</strong>：分析客户购买偏好、使用频次、售后服务反馈等，辅助精准营销。</li><li><strong>销售趋势预测</strong>：基于历史数据预测销售趋势，优化资源配置。</li><li><strong>潜在客户挖掘</strong>：基于客户画像与行为数据，识别潜在客户，提升获客效率。</li></ul><h4>2.2.5 合规与安全</h4><ul><li><strong>医疗行业合规</strong>：符合国家医疗行业数据安全与隐私保护的相关法规。</li><li><strong>审计追踪</strong>：支持全流程审计，确保数据真实、可追溯。</li></ul><hr/><h2>三、选对CRM的四个关键要素</h2><h3>3.1 功能全面性</h3><ul><li>确保CRM覆盖客户管理、销售、售后、数据分析等核心模块，满足医疗行业的复杂需求。</li></ul><h3>3.2 可扩展性</h3><ul><li>系统需具备良好的可扩展性，以适应企业业务增长与功能升级。</li></ul><h3>3.3 安全与合规</h3><ul><li>保障客户数据安全，符合医疗行业的合规要求，减少法律风险。</li></ul><h3>3.4 用户友好性</h3><ul><li>系统界面简洁直观，操作便捷，提升用户使用效率。</li></ul><hr/><h2>四、结语：2025年眼科设备制造厂商的CRM战略</h2><p>在2025年，眼科设备制造厂商的客户关系管理不仅是提升销售效率的工具，更是企业实现长期发展的核心驱动。选择一款合适的CRM系统，可以帮助企业更高效地管理客户、优化销售流程、提升客户满意度，并在激烈的市场竞争中脱颖而出。</p>]]></description></item><item>    <title><![CDATA[【Github热门项目】DeepSeek]]></title>    <link>https://segmentfault.com/a/1190000047399607</link>    <guid>https://segmentfault.com/a/1190000047399607</guid>    <pubDate>2025-11-14 15:09:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>【Github热门项目】DeepSeek-OCR项目上线即突破7k+星！突破10倍无损压缩，重新定义文本-视觉信息处理</h2><p>当“8000行代码手搓ChatGPT”的热度还未褪去，大模型领域又迎来新惊喜——DeepSeek团队于10月20日开源的 <strong>DeepSeek-OCR</strong>，以“<strong>上下文光学压缩</strong>”为核心突破，重新定义了OCR（光学字符识别）的效率边界。这款仅30亿参数量的模型，不仅能以100个视觉token超越传统模型256个token的性能，更在单张A100-40G显卡上实现每日20万页文档处理能力，为长文本压缩与大模型效率优化提供了全新思路。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399609" alt=" " title=" "/></p><p><strong>论文标题：DeepSeek-OCR:ContextsOpticalCompression</strong></p><p><a href="https://link.segmentfault.com/?enc=niPupz46Z81WfpfrTP9WlA%3D%3D.wEl5InJ2%2FVZi1BhRCvtxHyTyW6UvuirSyGGpg1m%2BZvurhAb63jVvzsMAayb4Fz43" rel="nofollow" target="_blank">👉原项目地址</a></p><p><a href="https://link.segmentfault.com/?enc=fLDBqydgJhGErX2GAXPgmg%3D%3D.J3NN1Irst42Vf%2B3uNu4A12Rhfsfy7guMLfW8bI4Xj5P%2FLZrYNAKUVrd4107oBQMHVEN1mgVzSIFgUOW9FhehHHXwtxdcGjvwLWnIimLoyn4%3D" rel="nofollow" target="_blank">👉Github论文</a></p><p><a href="https://link.segmentfault.com/?enc=rWWJ15WIxMOEhZDfGVEndw%3D%3D.r1zU3%2FFklQD4eEyaDShB603nYGx20Ek9W%2BP0l4eOeNbgvjpkl9SLBzBCj1nYhmFv" rel="nofollow" target="_blank">👉HuggingFace</a></p><p><a href="https://link.segmentfault.com/?enc=8b6b9GdR70jec9BUeU4yXw%3D%3D.OIaSgCApoFoxC4aqwwyNRrgbG9n0qBni1ZQkKBIWVAlC8lXnwgJTMtedpXf%2FjjmXpG9L155Rj0OM2rM0ek1%2FtPwmpUyDuLh8UTCJYnjj7sU8jtMSfFlZLmVzzi4cQ8mrq6%2Fd2b0H32bbsub1nDZCiVIoAt2RSgrX1kSVKTWY%2Foc%3D" rel="nofollow" target="_blank">👉Lab4AI</a></p><p>DeepSeek-OCR的核心创新在于利用视觉模态作为文本信息的高效压缩媒介。研究表明，一张包含文档文本的图像可以用比等效文本少得多的Token来表示丰富信息，这意味着通过视觉Token进行光学压缩可以实现极高的压缩率。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399610" alt=" " title=" " loading="lazy"/></p><p>其核心表现可概括为<strong>两组关键数据</strong>：</p><ul><li><strong>压缩比与精度</strong>的平衡：当文本token数量是视觉token的10倍以内（即压缩比＜10×）时，OCR解码精度高达97%；即便压缩比提升至20×，精度仍能维持在60%左右，远超行业同类模型的衰减速度。</li><li><strong>极致的token</strong>效率：在OmniDocBench基准测试中，它仅用100个视觉token就超越了需256个token的GOT-OCR2.0；面对MinerU2.0平均每页6000+token的消耗，它用不到800个token就能实现更优性能——相当于将文本处理的“token成本”降低了7-20倍。</li></ul><p>这种突破的价值不仅在于OCR本身：对于受限于“长上下文处理能力”的大模型而言，DeepSeek-OCR提供了一种新解法——<strong>将超长文本转化为视觉图像后压缩输入，可大幅减少LLM的token消耗，为处理百万字级文档、历史上下文记忆等场景打开了通道</strong>。</p><h3>DeepEncoder：编码器+MoE解码器</h3><p>为实现“高压缩比、低资源消耗”的目标，DeepSeek-OCR采用了“DeepEncoder（编码器）+DeepSeek3B-MoE（解码器）”的端到端架构，两者各司其职又高度协同。</p><h4>1. DeepEncoder</h4><p>作为模型的“压缩核心”，DeepEncoder需同时满足“<strong>高分辨率处理、低激活开销、少token输出</strong>”三大需求，其架构设计暗藏巧思：</p><ul><li>双组件串联：由8000万参数的<strong>SAM-base（视觉感知）</strong>和3亿参数的<strong>CLIP-large（视觉知识）</strong>串联而成。SAM-base用“窗口注意力”处理高分辨率图像细节，CLIP-large用“全局注意力”提取语义关联，兼顾精度与全局理解。</li><li>16倍token压缩：在双组件之间，通过<strong>2层卷积模块</strong>对视觉token进行16倍下采样。例如，1024×1024的图像先被划分为4096个patchtoken，经压缩后仅保留256个有效token，既控制了内存消耗，又不丢失关键信息。</li><li>多分辨率适配：支持Tiny（512×512）、Small（640×640）、Base（1024×1024）、Large（1280×1280）四种原生分辨率。还能通过“Gundam模式”实现超高分辨率输入（如报纸图像）的瓦片化处理，单个模型即可覆盖从手机截图到大幅文档的全场景需求。</li></ul><h4>2. DeepSeek3B-MoE</h4><p>解码器采用<strong>混合专家（MoE）架构</strong>，在“性能与效率”间找到了平衡点：</p><ul><li>参数激活策略：虽然总参数量为3B，但推理时仅激活64个“路由专家”中的6个，外加2个“共享专家”，实际参与计算的参数仅5.7亿——相当于用“500M模型的资源消耗”，获得了3B模型的表达能力。</li><li>快速文本重建：从DeepEncoder输出的压缩视觉token中，解码器能精准重建原始文本，甚至支持markdown格式转换、图表结构化提取等复杂任务，无需额外的后处理模块。</li></ul><h3>性能表现</h3><p>实验数据令人印象深刻：当文本Token数量在视觉Token的10倍以内（压缩率&lt;10×）时，模型的解码精度可达97%；即使在压缩率达到20×的情况下，OCR准确率仍保持在约60%。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399611" alt=" " title=" " loading="lazy"/></p><p>在实际应用层面，DeepSeek-OCR展现出惊人效率：在OmniDocBench基准测试中，仅使用<strong>100个视觉Token就超过了GOT-OCR2.0</strong>（每页256个Token）的表现；使用<strong>不到800个视觉Token就优于MinerU2.0</strong>（平均每页超过6000个Token）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399612" alt=" " title=" " loading="lazy"/></p><h3>大模型实验室Lab4AI</h3><p>值得一提的是，大模型技术社区「大模型实验室Lab4AI」已经第一时间上架了 <strong>DeepSeek-OCR论文及相关技术资料</strong>。该社区的技术团队正在积极复现论文中的创新方法，验证其在实际场景中的表现。大模型实验室作为专注于AI前沿技术的内容社区，将持续跟踪DeepSeek-OCR的最新进展，并<strong>分享更多实践案例和技术分析</strong>。欢迎各位开发者关注社区动态，共同探索这一创新技术的更多应用可能。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047399613" alt=" " title=" " loading="lazy"/></p>]]></description></item>  </channel></rss>