<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[AI时代竞争指南：如何打造高效的AI数字]]></title>    <link>https://segmentfault.com/a/1190000047440796</link>    <guid>https://segmentfault.com/a/1190000047440796</guid>    <pubDate>2025-12-01 15:13:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着AI模型和工具的普及，我们可以借助AI做：市场调查分析、用户需求分析、营销文案撰写、图片视觉设计、视频制作以及数据经营分析等等，这些功能完全涵盖了一个商业模型的闭环。因此，利用AI是可以为自己打造数字化的员工团队的。</p><p>借助这个AI员工团队，可以提升工作效率，可以减少机械、重复的操作，可以扩宽知识面和工作技能，同时还能无限的复制和拓展。</p><p>所以，未来一定是人+AI的竞争，也许现在和你竞争的就是一个AI数字员工，也可能是使用了无数个AI数字员工的人。因此，为了具备更强的竞争力，提高的工作效率，我们一定要学习如何打造自己AI数字员工。</p><p>首先，先确定一下，我们需要哪些AI数字员工功能。</p><p>青否ai超级员工，获客+引流+销售全流程，青否AI超级员工：支持一键控制 + 岗位级替代！核心功能如下：</p><p>1、AI获客</p><p>告别内容内耗，多平台高效运营。</p><p>sora2批量生成爆款短视频，智能匹配行业关键词，全自动发布覆盖抖音、快手、视频号、小红书。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440798" alt="" title=""/></p><p>GEO智能体优化多平台AI内容，用户提问时主动推荐企业及产品，精准曝光。</p><p>多账号一键绑定管理，数据实时监测，无需跨平台切换，省掉半个编辑团队。</p><p>解决：内容累、制作耗时长、跨平台管理乱的痛点。</p><p>2、AI引流</p><p>全域精准引流，获客效率倍增。</p><p>按行业+用户画像全网采集高意向客户，主动私信/评论，无需人工蹲点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440799" alt="" title="" loading="lazy"/></p><p>抖音客服7*24小时在线自动回复，AI拟人聊天，引导客户留资。</p><p>解决：找客难、引流慢、精准度低的痛点。</p><p>3、AI销售</p><p>标准化私域成交，降本又增效。</p><p>智能私域管家：自动通过好友、实时监控聊天记录、拟人化自动回复，精准预测客户行为分层。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440800" alt="" title="" loading="lazy"/></p><p>高情商促单：洞察客户需求、处理异议、推动成交，7x24 小时在线不打烊。</p><p>安全保障：本地部署 + 独立后台，知识库与数据全加密，杜绝泄露。</p><p>解决：转化低、跟进慢、客户数据不安全的痛点。</p><p>通过以上的分类，是不是能感受到AI大模型的强大？我们日常的所有工作，几乎都可以拆分出来交由AI大模型来完成。</p><p>当然，需要明确的是：AI并不是要取代人类，而是人类要发掘AI的能力，找出AI能代替人类工作的模块，以及找出AI比人类做的更好的工作模块，目的让人类从这些工作模块中解放出来，专注于人类更有优势和更擅长的领域。</p>]]></description></item><item>    <title><![CDATA[拒绝重复造轮子！灵臂 Lybic 新功能]]></title>    <link>https://segmentfault.com/a/1190000047440804</link>    <guid>https://segmentfault.com/a/1190000047440804</guid>    <pubDate>2025-12-01 15:12:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>玩 RPG 游戏时，打 Boss 前最重要的是什么？ 是装备？是等级？ 不，是存个档。<br/>在云端开发和调试 Agent 时，我们深知大家最大的痛点之一就是——环境配置的“一次性”魔咒。 辛辛苦苦装好了 Python 库、配置了 Chrome 插件、登录了账号，结果沙箱一销毁，一切归零。下次使用，又要重复这枯燥的循环。<br/>今天，Lybic 正式上线「镜像」功能。 简单来说，我们赋予了你“保存进度”和“无限克隆”的能力。<br/>一键保存当前完美状态，随时回到那个“一切正常”的时刻！<br/><img width="723" height="267" referrerpolicy="no-referrer" src="/img/bVdndGd" alt="image.png" title="image.png"/></p><h4>什么是镜像？</h4><p>简单来说，它就像是为你的整个沙箱环境拍一张“照片”，它会完美封存当前的系统状态：<br/>✅ 所有已安装的软件和工具<br/>✅ 精心调整的系统配置<br/>✅ 项目文件和数据<br/>✅ 环境变量和依赖关系</p><h4>三步完成镜像创建及管理</h4><ul><li>在沙箱标签页中选择你想镜像的对象，点击进入预览</li><li>工具栏中选择创建镜像，等待系统完成创建</li><li>进入镜像标签页，在此你可以查看你的镜像配额、使用情况，并执行对应操作</li></ul><h4>三大核心场景，效率翻倍</h4><p><strong>复杂环境，一次配置，永久复用</strong><br/>如果你的 Agent 依赖特定的浏览器版本、复杂的依赖库或特殊的字体文件。现在，你只需要配置一次“完美环境”，保存为镜像。以后每次启动，都是那个熟悉的“完美状态”。</p><p><strong>批量并发，无限克隆</strong><br/>需要同时跑 10 个 Agent 执行任务？不用一个个去设置。做好一个“母体”镜像，然后基于它瞬间裂变出 N 个沙箱，轻松实现规模化并发。</p><p><strong>容错回滚，大胆试错</strong><br/>在进行高风险操作前，先打个镜像。万一玩坏了？没关系，直接回滚重开。</p><p><strong><em>镜像功能现已上线邀测，添加小助手lybic_ai申请开通！</em></strong></p>]]></description></item><item>    <title><![CDATA[【赵渝强老师】PostgreSQL锁的类]]></title>    <link>https://segmentfault.com/a/1190000047440808</link>    <guid>https://segmentfault.com/a/1190000047440808</guid>    <pubDate>2025-12-01 15:11:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在并发环境下为了解决并发一致性问题保证事务的隔离性，PostgreSQL采用了锁的机制。当一个事务在进行操作时会对操作的数据进行加锁，从而限制另一个事务的操作。为保证效率和想，加锁的粒度不宜太大。加锁的意义就在于当多个会话同时访问数据库的同一数据时，为所有会话提供高效的数据访问，并同时维护严格的数据一致性，从而实现数据的多版本并发控制。</p><blockquote>多版本并发控制的英文名称是Multiversion Concurrency Control，简称MVCC。它是指每个SQL语句看到的都只是当前事务开始的数据快照，而不用去关心底层数据的当前状态。这样可以保护语句不会看到可能由其他在相同数据行上执行更新的并发事务造成的不一致数据，为每一个数据库会话提供事务隔离。MVCC避免了传统的数据库系统的锁定方法，将通过锁争夺最小化的方法来达到多会话并发访问时的性能最大化目的。</blockquote><p>PostgreSQL提供了多种类型的锁模式用于控制对表中数据的并发访问。在这些锁当中最主要的是表级锁与行级锁，此外还有页级锁、咨询锁等等。下面将重点介绍表级锁与行级锁。视频讲解如下：<br/><a href="https://www.bilibili.com/video/BV1DZSrBtEZJ/?aid=115642531323140&amp;cid=34410333314" target="_blank">https://www.bilibili.com/video/BV1DZSrBtEZJ/?aid=115642531323...</a></p><h2>一、 表级锁</h2><p>表级锁通常会在执行各种命令执行时自动获取，或者通过在事务中使用lock语句显式获取，每种表级锁都有自己的冲突集合。两个事务在同一时刻不能在同一个表上持有属于相互冲突模式的锁，但可以持有不冲突的锁。PostgreSQL的表级锁总共有八种模式，并存储在PostgreSQL的共享内存中。下表详细说明了这八种PostgreSQL表级锁。<br/><img width="723" height="660" referrerpolicy="no-referrer" src="/img/bVdndFZ" alt="image.png" title="image.png"/></p><p>这八种表级锁彼此之间存在一定的冲突，下表说明了它们之间的冲突关系。<br/><img width="723" height="315" referrerpolicy="no-referrer" src="/img/bVdndF8" alt="image.png" title="image.png" loading="lazy"/></p><p>在PostgreSQL数据库中可以通过pg_locks系统视图查询表上已经获取到的表级锁信息，下面通过一个具体的示例来说明。<br/>（1）在会话一中查看当前数据库中的表，并查看表testtable1的结构。</p><pre><code class="sql">postgres=# \d
           List of relations
 Schema |    Name    | Type  |  Owner   
--------+------------+-------+----------
 public | testtable1 | table | postgres
(1 row)

postgres=# \d testtable1;
             Table "public.testtable1"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 tid    | integer |           | not null | 
 tname  | text    |           |          | 
Indexes:
    "testtable1_pkey" PRIMARY KEY, btree (tid)
Tablespace: "mydemotbs"</code></pre><p>（2）查看表testtable1的oid。</p><pre><code class="sql">postgres=# select oid,relname,relkind,relfilenode from pg_class
postgres-# where relname ='testtable1';
  oid  |  relname   | relkind | relfilenode 
-------+------------+---------+-------------
 16395 | testtable1 | r       |       16395
(1 row)</code></pre><p>（3）在会话一中开启一个事务并执行一条update语句。</p><pre><code class="sql">postgres=# start transaction;
postgres=*# update testtable1 set tname='Tom123' where tid=1;

# 这里执行的事务没有结束。</code></pre><p>（4）在会话二中更改表testtable1的结构，如：添加一个新的列。</p><pre><code class="sql">postgres=# alter table testtable1 add dno int;

# 此时会话二的操作将会被阻塞。</code></pre><p>（5）在会话三中查看表testtable1上的锁信息。</p><pre><code class="sql">postgres=# \x
postgres=# select * from pg_locks where relation = 16395;

# 这里的“\x”表示将输出结果进行竖式显示。
# 输出的结果如下：
-[ RECORD 1 ]------+--------------------
locktype           | relation
database           | 13580
relation           | 16395
page               | 
tuple              | 
virtualxid         | 
transactionid      | 
classid            | 
objid              | 
objsubid           | 
virtualtransaction | 4/401
pid                | 41381
mode               | AccessExclusiveLock
granted            | f
fastpath           | f
-[ RECORD 2 ]------+--------------------
locktype           | relation
database           | 13580
relation           | 16395
page               | 
tuple              | 
virtualxid         | 
transactionid      | 
classid            | 
objid              | 
objsubid           | 
virtualtransaction | 3/644
pid                | 40920
mode               | RowExclusiveLock
granted            | t
fastpath           | f

# 从输出的结果可以看出，此时表testtable1上有两把表级锁，
# 分别是：AccessExclusiveLock和RowExclusiveLock。
# 但此时并不能观察到会话之间的阻塞。</code></pre><p>（6）执行语句检查锁的等待，即：会话之间的阻塞信息。</p><pre><code class="sql">postgres=# with  
    t_wait as  
    (  
     select 
       a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,
       a.classid,a.granted,a.objid,a.objsubid,a.pid,
       a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath,
       b.state,b.query,b.xact_start,b.query_start,b.usename,
       b.datname,b.client_addr,b.client_port,b.application_name  
     from pg_locks a,pg_stat_activity b where a.pid=b.pid and not a.granted  
    ),  
    t_run as  
    (  
     select 
       a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,
       a.classid,a.granted,a.objid,a.objsubid,a.pid,
       a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath,
       b.state,b.query,b.xact_start,b.query_start,b.usename,
       b.datname,b.client_addr,b.client_port,b.application_name  
     from pg_locks a,pg_stat_activity b where a.pid=b.pid and a.granted  
    ),  
    t_overlap as  
    (  
     select r.* from t_wait w join t_run r on  
     (  
      r.locktype is not distinct from w.locktype and  
      r.database is not distinct from w.database and  
      r.relation is not distinct from w.relation and  
      r.page is not distinct from w.page and  
      r.tuple is not distinct from w.tuple and  
      r.virtualxid is not distinct from w.virtualxid and  
      r.transactionid is not distinct from w.transactionid and  
      r.classid is not distinct from w.classid and  
      r.objid is not distinct from w.objid and  
      r.objsubid is not distinct from w.objsubid and  
      r.pid &lt;&gt; w.pid  
     )  
    ),  
    t_unionall as  
    (  
     select r.* from t_overlap r  
     union all  
     select w.* from t_wait w  
    )  
    select 
    locktype,datname,relation::regclass,page,tuple,
    virtualxid,transactionid::text,classid::regclass,
    objid,objsubid, 
    string_agg(
    'Pid: '
    ||case when pid is null 
           then 'NULL' else pid::text end||chr(10)||'Lock_Granted: '
    ||case when granted is null 
           then 'NULL' else granted::text end||' , Mode: '
    ||case when mode is null 
           then 'NULL' else mode::text end||' , FastPath: '
    ||case when fastpath is null 
           then 'NULL' else fastpath::text end||' , VirtualTransaction: '
    ||case when virtualtransaction is null 
           then 'NULL' else virtualtransaction::text end||' , Session_State: '
    ||case when state is null 
           then 'NULL' else state::text end||chr(10)||'Username: '
    ||case when usename is null 
           then 'NULL' else usename::text end||' , Database: '
    ||case when datname is null 
           then 'NULL' else datname::text end||' , Client_Addr: '
    ||case when client_addr is null 
           then 'NULL' else client_addr::text end||' , Client_Port: '
    ||case when client_port is null 
           then 'NULL' else client_port::text end||' , Application_Name: '
    ||case when application_name is null 
           then 'NULL' else application_name::text end
    ||chr(10)||'Xact_Start: '
    ||case when xact_start is null 
           then 'NULL' else xact_start::text end||' , Query_Start: '
    ||case when query_start is null 
           then 'NULL' else query_start::text end||' , Xact_Elapse: '
    ||case when (now()-xact_start) is null 
           then 'NULL' else (now()-xact_start)::text end||' , Query_Elapse: '
    ||case when (now()-query_start) is null 
           then 'NULL' else (now()-query_start)::text end
    ||chr(10)||'SQL (Current SQL in Transaction): '||chr(10)
    ||case when query is null then 'NULL' else query::text end,chr(10)
    ||'--------'||chr(10)  
    order by  
     ( case mode  
      when 'INVALID' then 0  
      when 'AccessShareLock' then 1  
      when 'RowShareLock' then 2  
      when 'RowExclusiveLock' then 3  
      when 'ShareUpdateExclusiveLock' then 4  
      when 'ShareLock' then 5  
      when 'ShareRowExclusiveLock' then 6  
      when 'ExclusiveLock' then 7  
      when 'AccessExclusiveLock' then 8  
      else 0  
     end ) desc,  
     (case when granted then 0 else 1 end) 
    ) as lock_conflict 
    from t_unionall  
    group by locktype,datname,relation,page,tuple,virtualxid,
    transactionid::text,classid,objid,objsubid; 

# 输出的结果如下：
-[ RECORD 1 ]-+------------------------------------------------------
locktype      | relation                                             
datname       | postgres                                             
relation      | testtable1                                           
page          |                                                      
tuple         |                                                      
virtualxid    |                                                      
transactionid |                                                      
classid       |                                                      
objid         |                                                      
objsubid      |                                                      
lock_conflict 
| Pid: 41381                                           
              | Lock_Granted: false , Mode: AccessExclusiveLock , ...
                | SQL (Current SQL in Transaction):                    
              | alter table testtable1 add dno int;                  
              | --------                                             
              | Pid: 40920                                           
              | Lock_Granted: true , Mode: RowExclusiveLock , ...    
                | SQL (Current SQL in Transaction):                    
              | update testtable1 set tname='Tom123' where tid=1;    

# 通过这里输出的信息可以看到阻塞的进程ID号，以及发生等待的SQL语句。</code></pre><p>（7）在会话一执行结束事务操作。</p><pre><code class="sql">postgres=*# commit;

# 此时会话二将成功执行。</code></pre><p>（8）重新在会话三中查看表testtable1上的锁信息，此时将没有任何锁的信息输出。</p><pre><code class="sql">postgres=# select * from pg_locks where relation = 16395;</code></pre><h2>二、 行级锁</h2><p>同一个事务可能会在相同的行上保持冲突的锁。但是除此之外，两个事务永远不可能在相同的行上持有冲突的锁。PostgreSQL行级锁不影响数据查询，它们只阻塞对同一行的写入者和加锁者。行级锁在事务结束时或保存点回滚的时候释放，就像表级锁一样。PostgreSQL行级锁支持以下四种不同的模式，如下表所示。<br/><img width="723" height="575" referrerpolicy="no-referrer" src="/img/bVdndGe" alt="image.png" title="image.png" loading="lazy"/></p><p>这四种行级锁彼此之间存在一定的冲突，下表说明了它们之间的冲突关系。<br/><img width="723" height="222" referrerpolicy="no-referrer" src="/img/bVdndGf" alt="image.png" title="image.png" loading="lazy"/></p><blockquote>×表示存在相互之间的冲突。</blockquote><p>在PostgreSQL中可以通过查询pg_locks的系统视图来获取行级锁的相关信息。下面展示了该系统视图的结构。</p><pre><code class="sql">postgres=# \d pg_locks;
                   View "pg_catalog.pg_locks"
       Column       |   Type   | Collation | Nullable | Default 
--------------------+----------+-----------+----------+---------
 locktype           | text     |           |          | 
 database           | oid      |           |          | 
 relation           | oid      |           |          | 
 page               | integer  |           |          | 
 tuple              | smallint |           |          | 
 virtualxid         | text     |           |          | 
 transactionid      | xid      |           |          | 
 classid            | oid      |           |          | 
 objid              | oid      |           |          | 
 objsubid           | smallint |           |          | 
 virtualtransaction | text     |           |          | 
 pid                | integer  |           |          | 
 mode               | text     |           |          | 
 granted            | boolean  |           |          | 
 fastpath           | boolean  |           |          | </code></pre>]]></description></item><item>    <title><![CDATA[玩转OurBMC第二十五期：OpenBM]]></title>    <link>https://segmentfault.com/a/1190000047440811</link>    <guid>https://segmentfault.com/a/1190000047440811</guid>    <pubDate>2025-12-01 15:10:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>【栏目介绍：“玩转OurBMC”是OurBMC社区开创的知识分享类栏目，主要聚焦于社区和BMC全栈技术相关基础知识的分享，全方位涵盖了从理论原理到实践操作的知识传递。OurBMC社区将通过“玩转OurBMC”栏目，帮助开发者们深入了解到社区文化、理念及特色，增进开发者对BMC全栈技术的理解。</p><p>欢迎各位关注“玩转OurBMC”栏目，共同探索OurBMC社区的精彩世界。同时，我们诚挚地邀请各位开发者向“玩转OurBMC”栏目投稿，共同学习进步，将栏目打造成为汇聚智慧、激发创意的知识园地。】</p><p>在服务器产品交付阶段，BMC、BIOS及CPLD等核心固件的初始烧录通常采用离线编程方式，通过专用烧录器将固件镜像写入存储介质。随着服务器进入运维阶段，为应对安全漏洞修复、功能增强或硬件兼容性更新等需求，管理人员需借助远程管理接口实现固件升级。OpenBMC作为开源基板管理控制器固件框架，其设计的远程更新机制兼顾了灵活性与可靠性。本文将深入剖析OpenBMC在固件远程更新场景下的核心实现机制，重点解析其BMC固件单分区与A/B分区的更新流程、底层脚本的协作关系，以及通过总线接管更新BIOS/CPLD的硬件交互原理。</p><h2>01 BMC固件更新</h2><p>作为服务器管理核心组件，BMC固件本质上是针对特定硬件平台定制的嵌入式Linux系统，其软件栈由三个部分组成：负责硬件初始化和系统启动引导的Bootloader（如U-Boot）、Linux内核以及包含OpenBMC服务与应用的根文件系统。在金融、电信等对可用性要求极高的行业中，为防止因BMC固件损坏导致服务器失去远程管理能力，会采用双物理Flash芯片的设计。这两个Flash通过CPLD或硬件多路复用器控制，可实现故障时自动切换。而在主流的OpenBMC平台方案中，为控制成本，通常只使用一颗Flash芯片，采用单分区方案，或A/B分区方案来保障固件可靠性。下图为OpenBMC平台上BMC固件的更新流程：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440813" alt="" title=""/></p><h3>单分区方案：</h3><p>在单分区方案中，BMC固件的所有组件只有单一副本，典型分区布局如下表所示：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440814" alt="" title="" loading="lazy"/></p><p>在这种方案下更新BMC固件时，管理员需要将完整的BMC系统镜像image-bmc上传到/run/initramfs/目录。执行reboot命令后，系统直接调用/run/initramfs/shutdown脚本，该脚本首先确保/proc等内核接口可用，以完成运行环境准备，接着彻底卸载所有与旧根目录关联的文件系统，确保Flash存储设备完全处于未被占用状态。随后检测更新镜像是否存在，一旦确认存在便启动看门狗机制防止意外重启，最后调用update脚本执行固件烧录，并通过reboot -f完成硬件重启。</p><p>update脚本作为更新操作的核心执行者，其功能主要包括安全校验、数据备份和烧录执行。在安全校验方面，它通过findmtd()确保目标分区正确，使用toobig()防止镜像溢出，并通过mtdismounted()确保分区未被挂载。在数据备份方面，脚本提供--save-files和--restore-files功能，读取/run/initramfs/whitelist文件，将rwfs中的重要用户数据备份到内存安全区域，更新完成后自动恢复。最终通过flashcp -v "$f" "/dev/$m"命令完成固件烧录，并将烧录状态写入特定区域以便系统启动时感知，在一切完成后清理暂存文件和临时备份。</p><h3>A/B分区方案：</h3><p>单分区方案的本质是对Flash进行全量重写。而A/B分区方案是一种更加灵活、可回退的"热更新"，这种方案为内核与根文件系统这两大核心组件分别建立了A/B两套分区，从而实现冗余。其分区布局示例如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440815" alt="" title="" loading="lazy"/></p><h2>02 BIOS固件更新</h2><p>除了更新BMC自身，BMC还负责更新服务器主板上的其他固件。在服务器正常运行时，SPI总线由服务器CPU控制，用于访问BIOS。当需要更新时，BMC 会通过 GPIO 信号切换总线控制权，暂时成为 SPI 总线的主设备。随后，BMC通过其内部的SPI控制器，驱动这条共享的SPI总线，将固件镜像直接写入作为从设备的BIOS Flash。例如，在飞腾腾珑E2000S平台上，可通过底层命令手动完成此过程：</p><p>\# 解除服务器对SPI控制器的绑定</p><p>echo 2803a000.spi &gt; /sys/bus/platform/drivers/phytium_spi/unbind</p><p>\# 通过GPIO切换总线控制权至BMC</p><p>gpioutil set CPU1\_SPI\_SELECT 1</p><p>\# 重新绑定控制器，此时BMC成为主设备</p><p>echo 2803a000.spi &gt; /sys/bus/platform/drivers/phytium_spi/bind</p><p>\# 将BIOS镜像文件写入对应的Flash分区</p><p>flashcp -v bios.bin /dev/mtd6</p><p>\# 将总线控制权归还给服务器</p><p>gpioutil set CPU1\_SPI\_SELECT 0</p><h2>03 CPLD固件更新</h2><p>CPLD固件体积虽小，却控制着服务器关键硬件逻辑（如电源时序、信号复用）。BMC通过接管JTAG总线完成其更新。正常情况下，JTAG总线由服务器CPU使用。当通过BMC发起CPLD更新时，管理员上传用于写入CPLD固件的专用编程文件（如SVF文件），BMC通过GPIO或外部多路复用器切换，临时占用JTAG总线。随后，BMC内部的JTAG控制器驱动JTAG信号，按JTAG协议将新镜像写入CPLD的非易失存储器。以飞腾平台更新国产安路科技的服务器CPLD为例，手动更新命令如下：</p><p>\# 切换JTAG总线控制权至BMC</p><p>gpioutil set CPU\_JTAG\_SELECT 1</p><p>\# 通过JTAG接口烧录SVF格式的固件文件</p><p>loadsvf -d /dev/jtag0 -v -s /tmp/jtag.svf</p><p>CPLD更新完成后，通常需要对整机或对应模块进行断电上电，新的逻辑才会被加载生效。</p><p>本期内容聚焦OpenBMC在固件更新中的底层机制：BMC自身更新可通过单分区方案实现完整系统重装，或通过A/B分区方案实现热更新；而BIOS和CPLD的更新则依靠BMC临时接管硬件总线来实现。这些底层机制虽然直接有效，但通常涉及复杂的手动操作。下期内容，我们将深入分析OpenBMC如何通过上层服务（如Redfish API和phosphor-software-manager）将这些底层操作封装起来，在Web界面上实现一键式、可审计、安全可靠的统一固件更新。</p><p><strong>欢迎大家关注OurBMC社区，了解更多BMC技术干货。</strong></p><p><strong>OurBMC社区官方网站：</strong></p><p><a href="https://link.segmentfault.com/?enc=6EzFZX7qTUnvpg7xRhrCKg%3D%3D.vdeXCjgy0wwpkd404JwBrVdpPcKWMR%2B5e4dmpR%2FxUVM%3D" rel="nofollow" target="_blank">https://www.ourbmc.cn/</a></p>]]></description></item><item>    <title><![CDATA[openFuyao两大核心项目获得Git]]></title>    <link>https://segmentfault.com/a/1190000047440847</link>    <guid>https://segmentfault.com/a/1190000047440847</guid>    <pubDate>2025-12-01 15:10:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>近日，openFuyao开源社区两大核心项目【openFuyao/ai-inference-integration】与【openFuyao/kubernetes】成功斩获GitCode官方G-Star项目认证，入选GitCode G-Star计划优质项目。此次双项目同步“毕业”，不仅是对openFuyao技术实力与社区运营能力的权威认可，更标志着社区已形成“贡献者激励-技术迭代-场景落地”的良性闭环。获得认证的项目将纳入“G-Star Landscape生态版图”，同时意味着openFuyao与GitCode达成深度合作，双方将携手为开源软件生态建设注入新活力。</p><p><img width="723" height="464" referrerpolicy="no-referrer" src="/img/bVdndGV" alt="" title=""/><br/><em>openFuyao/ai-inference-integration 项目毕业认证</em></p><p><img width="723" height="464" referrerpolicy="no-referrer" src="/img/bVdndGW" alt="" title="" loading="lazy"/><br/><em>openFuyao/kubernetes 项目毕业认证</em></p><p>GitCode G-Star计划是平台官方推出的针对开源项目成长全流程的孵化扶持体系，已持续培育大批优质项目，为入驻项目提供<strong>运营扶持、资金支持、市场推广</strong>等全方位资源赋能，助力项目快速形成技术影响力与社区凝聚力。<br/>其中“<strong>项目毕业</strong>”认证核心是对项目运营成熟度的权威认可，要求项目需具备独立开展社区运营、吸纳跨行业外部贡献、汇聚行业伙伴及实现生态自循环的基础能力——认证通过即标志社区已形成“<strong>贡献者激励-技术迭代-场景落地</strong>”的良性闭环。获得认证的项目将纳入G-Star Landscape生态版图，享受平台更高优先级的<strong>流量扶持与曝光资源</strong>，进一步放大社区的行业影响力。</p><h3>AI-Inference-Integration：破解LLM推理效率瓶颈的云原生方案</h3><p>创新性提出LLM推理服务化加速框架，构建模块化、高性能、开箱即用的端到端分布式架构，依托云原生基础设施极致释放多样化算力。该方案精准聚焦推理场景资源利用率低、生产级部署复杂、云原生适配不足等核心挑战，通过智能动态路由、xPyD计算动态资源管理调度、分布式KVCache等优化三大核心能力，结合多维度智能调度与性能优化技术，有效降低推理延迟（TPOP、TTFT）、提升系统吞吐率，成功打破高并发、长上下文推理场景下的性能与资源利用瓶颈，显著提升多样化算力场景下的效率与可部署性。</p><p>基于主流LLM推理技术栈生态，该项目打造的五大K8s原生高性能可扩展子系统：智能路由系统（Hermes Router），实现动态请求分发与负载均衡，依托多维度感知匹配最优节点； xPyD动态PD分离（PD-Orchestrator），完成计算/显存资源的弹性分配与智能调度；分布式、多级KVCache及读写优化（KVCacheX），强化缓存管理效能；端到端易用性子系统（OIF-Deployer），提升部署便捷性；推理场景可观测体系（EagleEye），为服务运行提供监控支撑。</p><h3>Kubernetes：聚焦核心能力增强的云原生底座升级方案</h3><p>围绕Kubernetes编排调度体系核心，针对云原生场景下的性能瓶颈与资源管理难题，构建了全方位的能力增强体系。在大规模集群调度方面，该项目针对1.6万节点级集群场景，通过优化Pod批量创建与绑定接口提升调度效率，同时实现etcd数据损坏自动修复、kube-controller-manager故障快速恢复等高可用增强，保障超大集群稳定运行。</p><p>在性能与资源优化领域，项目通过eBPF技术实现内核态容器管理，彻底消除shim进程，显著提升单节点可部署容器数量；针对NPU、GPU等XPU异构算力，推出虚拟化动态拆分与分配方案，实现异构算力高效利用；基于灵衢超节点架构构建的跨Pod、跨容器内存共享机制，大幅提升大规模并行计算任务的数据访问效率。此外，项目还完成多项K8s核心能力升级，包括全组件证书热更新、容器启动阶段CPU资源临时提升（显著缩短Java业务Pod启动时间）、StatefulSet负载PVC模板声明式扩容等实用功能。</p><p>作为聚焦云原生与AI基础设施领域的开源力量，openFuyao已形成以技术创新为核心、社区运营为支撑的发展体系。目前，两大项目已构建完善的技术文档体系与贡献者指南，核心开发团队由多名资深云原生研发工程师组成，社区已吸引来自金融、互联网、运营商等多行业的贡献者参与。未来，openFuyao将借助GitCode G-Star计划的资源优势，持续迭代核心技术方案，完善社区治理与贡献者生态，深化与产业链伙伴的协同创新，推动开源成果向关键行业场景落地，为开源生态的创新繁荣与各行业的智能化转型突破持续贡献核心力量。</p>]]></description></item><item>    <title><![CDATA[免费 SSL 证书缩短至 90 天，你的]]></title>    <link>https://segmentfault.com/a/1190000047440872</link>    <guid>https://segmentfault.com/a/1190000047440872</guid>    <pubDate>2025-12-01 15:09:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着网络安全环境的变化，<a href="https://link.segmentfault.com/?enc=%2FbBUrpIO1k1lhf7ZJq80kg%3D%3D.38bD9d1Up5zkO%2B%2FN2jxabzmoYBVn762ebEeI9X44OK3fI6uuorjtePvdQy9sweYU" rel="nofollow" target="_blank">SSL 证书</a>行业正在经历一次深刻的调整。以 Google 为首的国际标准制定者及主流云服务商，纷纷将免费 DV SSL 证书的有效期从 1 年缩减至 90 天，我怀疑是为了卖付费证书（bushi）。这一举措虽然在理论上缩短了密钥泄露的风险窗口，但在实际执行层面，却给企业的运维管理带来了显著的弊端。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440874" alt="" title=""/></p><h3><strong>一、 管理成本的显著增加</strong></h3><p>对于拥有大量域名和服务器资产的企业而言，证书有效期的缩短并不只是多申请几次那么简单。</p><ul><li><strong>资源投入翻倍</strong>：更新频率的增加直接导致了管理成本的上升。企业需要投入更多的计算资源和人力资源来监控、管理和更新证书。</li><li><strong>人力负担加重</strong>：运维团队被迫从核心业务中分流，专门处理繁琐的证书续订和部署工作。对于服务器数量众多的架构，这甚至可能需要设立专门的流程或岗位来应对。</li></ul><h3><strong>二、 操作风险的被动提高</strong></h3><p>在运维领域，每一次变更都意味着风险。90 天的更新周期将这种风险频率提高了四倍。</p><ul><li><strong>更新过程中的潜在故障</strong>：无论是手动更新还是依赖脚本自动化，每次替换证书都存在配置错误、脚本执行失败或环境兼容性问题的风险。一次微小的失误就有可能导致服务中断，影响业务连续性。</li><li><strong>过期风险激增</strong>：高频率的更新要求极高的执行力。一旦监控疏漏或自动化任务卡死，遗漏更新的概率随之增加。网站弹出安全警告不仅会导致服务不可用，更会严重损害用户对品牌的信任。</li></ul><h3><strong>三、 中小企业与开发者的困境</strong></h3><p>相比于拥有完善 DevOps 体系的大型互联网公司，中小型企业和独立开发者面临的挑战更为严峻。</p><p>由于资源限制，这些群体往往缺乏自动化的运维平台或专门的安全团队。面对 90 天的强制更新，他们不得不在“投入大量精力手动维护”和“承担业务中断风险”之间做选择，这对在线业务的稳定性构成了实质性的不利影响。</p><p><strong>市场现状：付费证书的价格门槛</strong></p><p>为了规避上述风险，回归 1 年期的长效证书成为最优解。然而，目前市场上付费证书的定价策略普遍较高。主流云厂商的单域名证书价格通常在几百元，而支持无限子域名的通配符（Wildcard）证书价格更是高达千元以上。这种高昂的定价，在很大程度上阻碍了开发者获取稳定的安全服务。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440875" alt="" title="" loading="lazy"/></p><h4><strong>ServBay Store：低成本的破局方案</strong></h4><p>针对这一行业痛点，ServBay 正式推出了 ServBay Store，价格直接击穿地花板，降低长效 SSL 证书的获取门槛，帮助开发者摆脱频繁续签的运维焦虑。</p><p>ServBay Store 提供的 1 年期 DV（域名验证）证书价格如下：</p><ul><li><p><strong>DV</strong> <strong>Single (单域名证书)：¥29.00 / 年</strong></p><ul><li>  以极低的成本锁定一整年的安全周期，无需再为每季度的续签分散精力。</li></ul></li><li><p><strong>DV</strong> <strong>Wildcard (通配符证书)：¥256.00 / 年</strong></p><ul><li>这是目前市场上极具性价比的方案。一张证书即可覆盖主域名及所有子域名，特别适合拥有复杂开发环境或多业务线的团队，相比传统渠道节省了大量预算。</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440876" alt="" title="" loading="lazy"/></p><p><strong>上线专项福利：1000 张年期证书免费赠送</strong></p><p>为了庆祝商店上线，并切实帮助用户解决燃眉之急，ServBay 自掏腰包采购了 1000 张有效期为 1 年的 DV SSL 证书，免费赠送给ServBay用户。</p><ul><li><strong>数量：</strong> 限量 1000 张</li><li><strong>规则：</strong> 每位 ServBay 用户仅限领取一张，领完即止。</li><li>领取地址：<a href="https://link.segmentfault.com/?enc=V0jQToopzuCR0AFCS8G83w%3D%3D.QqQ9GDFQr%2F5abk9FD1iaMTOXCER2ZPk7l%2Fgennq8zig%3D" rel="nofollow" target="_blank">https://www.servbay.com/store</a></li></ul><p>对于希望降低管理成本、规避操作风险的开发者，建议前往 ServBay Store 了解详情。这不仅是获取免费资源的良机，更是构建低维护成本、高稳定性开发环境的有效选择。</p>]]></description></item><item>    <title><![CDATA[【水果识别系统】Python+Tenso]]></title>    <link>https://segmentfault.com/a/1190000047440884</link>    <guid>https://segmentfault.com/a/1190000047440884</guid>    <pubDate>2025-12-01 15:08:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、介绍</h2><p>水果识别系统，基于TensorFlow搭建Resnet50卷积神经网络算法，通过对5种常见的水果图片数据集（'圣女果', '梨', '芒果', '苹果', '香蕉'）进行训练，最后得到一个识别精度较高的模型，然后搭建Web可视化操作平台。</p><p><strong>技术栈</strong>：</p><ul><li>项目前端使用Html、CSS、BootStrap搭建界面。</li><li>后端基于Django处理逻辑请求</li><li>基于Ajax实现前后端数据通信</li></ul><p><strong>选题背景与意义</strong>：<br/>在数字化与智能化浪潮推动下，计算机视觉技术在农业领域的应用愈发广泛，水果识别作为其中重要分支，对提升农产品分拣效率、优化供应链管理意义重大。然而传统人工识别方式效率低、成本高，难以满足大规模生产需求。在此背景下，我们基于TensorFlow搭建Resnet50卷积神经网络算法，利用5种常见水果（圣女果、梨、芒果、苹果、香蕉）的图片数据集训练出高精度识别模型，并进一步搭建Web可视化操作平台，前端采用Html、CSS、BootStrap，后端依托Django，借助Ajax实现高效数据通信，以实现便捷、智能的水果识别。</p><h2>二、系统效果图片展示</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440886" alt="图片" title="图片"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047440887" alt="图片" title="图片" loading="lazy"/></p><h2>三、演示视频 and 完整代码 and 安装</h2><p>地址：<a href="https://link.segmentfault.com/?enc=z5L2n%2FYwDyXmG00L1pPHKQ%3D%3D.ifcerJZdm%2FjvWB%2BICQy%2BcE0hGHJv0aqVBlQcnv%2BhR14%3D" rel="nofollow" target="_blank">https://ziwupy.cn/p/fdiDmw</a></p><h2>四、卷积神经网络算法介绍</h2><p>卷积神经网络（Convolutional Neural Network，CNN）是一种专门为处理具有网格结构数据（如图像）而设计的深度学习模型。它通过卷积层自动提取图像的局部特征，利用池化层降低数据维度、减少计算量并增强模型的鲁棒性，最后通过全连接层对提取的特征进行分类或回归。CNN的关键优势在于其具有局部感知和参数共享的特性，能显著减少参数量，提高训练效率，在图像识别、目标检测等计算机视觉任务中表现卓越。</p><pre><code class="python">import tensorflow as tf
from tensorflow.keras import layers, models

# 构建简单的CNN模型
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(32, 32, 3)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax')
])

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])</code></pre><p>上述代码构建了一个简单的CNN模型用于图像识别。它包含两个卷积层和两个池化层，用于特征提取和降维，接着通过全连接层进行分类。使用adam优化器和交叉熵损失函数，适用于多分类任务。</p>]]></description></item><item>    <title><![CDATA[【动物识别系统】Python+Tenso]]></title>    <link>https://segmentfault.com/a/1190000047440905</link>    <guid>https://segmentfault.com/a/1190000047440905</guid>    <pubDate>2025-12-01 15:07:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、介绍</h2><p>动物识别系统，基于TensorFlow搭建Resnet50卷积神经网络算法，通过对4种常见的动物图片数据集（猫、鸡、马、狗）进行训练，最后得到一个识别精度较高的模型，然后搭建Web可视化操作平台。</p><p><strong>技术栈</strong>：</p><ul><li>项目前端使用Html、CSS、BootStrap搭建界面。</li><li>后端基于Django处理逻辑请求</li><li>基于Ajax实现前后端数据通信</li></ul><p><strong>选题背景与意义</strong>：<br/>在人工智能技术蓬勃发展的当下，动物识别作为计算机视觉领域的重要应用方向，有着广泛的实际需求，如动物保护监测、智能安防等场景均需精准高效的动物识别能力。在此背景下，我们开展了动物识别系统的研发项目。该系统基于TensorFlow搭建Resnet50卷积神经网络算法，利用猫、鸡、马、狗4种常见动物图片数据集训练，以获取高精度识别模型。同时，为方便用户操作，项目还采用Html、CSS等搭建前端界面，Django处理后端逻辑，Ajax实现数据通信，搭建起Web可视化操作平台。</p><h2>二、系统效果图片展示</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440907" alt="图片" title="图片"/></p><h2>三、演示视频 and 完整代码 and 安装</h2><p>地址：<a href="https://link.segmentfault.com/?enc=%2BQpp5cVzOvNDoqs%2BNYUkvw%3D%3D.34L1agZgIxUcjme3IgqxOI8GmqKMwmVhJ5sUe%2FaZWZ8%3D" rel="nofollow" target="_blank">https://ziwupy.cn/p/xtcmVA</a></p><h2>四、卷积神经网络算法介绍</h2><p>卷积神经网络（Convolutional Neural Network，CNN）是一种专门为处理具有网格结构数据（如图像）而设计的深度学习模型。它通过卷积层自动提取图像的局部特征，利用池化层降低数据维度、减少计算量并增强特征鲁棒性，再通过全连接层对提取的特征进行分类或回归。CNN的核心优势在于能够自动学习图像的层次化特征，从边缘、纹理等低级特征逐步组合成高级语义特征，无需人工手动设计特征提取规则，大大提高了图像识别的准确率和效率。</p><pre><code class="python">import tensorflow as tf
from tensorflow.keras import layers, models

# 构建CNN模型
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(64, 64, 3)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax')
])

# 编译模型
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])</code></pre><p>上述代码构建了一个简单的CNN模型，包含两个卷积层和池化层用于特征提取，一个展平层将特征图转换为一维向量，最后通过两个全连接层进行分类。此模型适用于图像分类任务，通过调整网络结构和参数，可适配不同数据集和识别需求。</p>]]></description></item><item>    <title><![CDATA[Zoho出席浙江省CIO百人会，打造企业]]></title>    <link>https://segmentfault.com/a/1190000047440915</link>    <guid>https://segmentfault.com/a/1190000047440915</guid>    <pubDate>2025-12-01 15:07:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>2025年11月29日，浙江省首席信息官协会浙江省CIO百人会，在湘湖举办的数字转型暨AI+企业出海论坛圆满结束。在这场围绕AI技术落地、智能制造、全球化布局等议题的盛会中，Zoho作为领跑全球的SaaS软件提供商进行了重要分享。</p><p>Zoho SaaS售前专家王佳敏以“Zoho One：打造企业专属的数字化解决方案”为主题，结合 Zoho全球90多万家企业的服务经验，深度介绍了Zoho One如何助力企业数字化转型。</p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdndHX" alt="" title=""/></p><p>王佳敏指出：“Zoho One 并非单一工具，而是历经 20 年沉淀的企业级生态产品。截至目前，已推出 50 + 款独立应用，全面覆盖企业核心业务场景。”</p><p>当前企业数字化建设普遍面临“数据孤岛”严重、系统杂乱、业务融合困难等问题，而Zoho One可以通过四大核心能力破解痛点：</p><p><strong>1.统一入口与个性化体验：</strong>一个账号即可登录所有应用，告别多密码记忆；支持自定义主页，将未读邮件、工单、考勤等核心工作事项集中展示，提升工作效率；<br/><strong>2.无缝应用切换：</strong>左侧产品列表一键切换，无需同时打开多个浏览器，简化操作流程；<br/><strong>3.数据互通与智能洞察：</strong>打破系统壁垒，实现各模块数据相互打通，来源更全面；支持个性化数据展示，通过仪表板呈现销售、财务、人力等维度数据，助力业务决策；<br/><strong>4.AI 全域赋能：</strong>将AI作为基础能力融入多产品（如 CRM、Analytics、Notebook），覆盖客户跟进、数据分析、文档处理等多场景，帮助企业高效工作。</p><p>Zoho One 并非 “一刀切” 的通用产品，而是针对不同行业特性，设计覆盖全业务流程的专属解决方案。王佳敏通过介绍Zoho One在法律财务咨询、汽车制造、外贸等等行业领域的客户案例，证实了Zoho One能够真正实现 “企业需要什么，就提供什么” 的专属数字化建设。</p><p>本次论坛为企业数字化转型交流搭建了优质平台，期待未来更多企业能借助 Zoho One 这类专业工具，打破业务壁垒、提升运营效率，在数字化浪潮与全球化布局中稳步前行，持续释放发展新动能。</p>]]></description></item><item>    <title><![CDATA[青否ai超级员工，构建AI智能体全方位智]]></title>    <link>https://segmentfault.com/a/1190000047440924</link>    <guid>https://segmentfault.com/a/1190000047440924</guid>    <pubDate>2025-12-01 15:06:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着人工智能技术的飞速发展，组织形态正在经历一场前所未有的变革。智能体员工，这些曾经只存在于科幻小说中的角色，正逐渐成为现实，并在未来组织中扮演着越来越重要的角色。</p><p>AI智能体从最初的辅助工具，转变为潜在的“员工”，这一角色转变不仅引发了行业内对于管理模式的深刻反思，也预示着生产力的一次重大飞跃。</p><p>智能体员工超越传统人类员工的能力，能够并行处理多项任务，具有强大的数据处理和分析能力，甚至能在无人类干预下自主学习和进化。这些超级个体的加入，为组织带来更高的效率和更强的竞争力。</p><p>“一个人+三个AI员工”，正成为新的小团队标配。在中国，有很多公司在谈AI，有很多产品在尝试自动化。</p><p>他们开发的“青否AI员工”系统，不是一个功能集合，也不是一套提效工具，而是一整套可以远程语音控制、替代特定岗位执行任务的AI劳动力系统。这，是真正意义上的“AI上岗”。</p><p>青否科技：Agent自动化工作流</p><p>Agent（智能体）相当于一个自动化中枢。不需要手动点击多个按钮来启动复杂流程，只需向它发送一个清晰的指令（如“开始工作”），它就能自动理解、规划并执行一整套关联任务。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440926" alt="" title=""/></p><p>核心优势</p><p>降本增效：人力成本降低 50%（减少 3-5人/月支出），获客效率提升 3 倍，转化率增长 40%，成交周期缩短 60%。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440927" alt="" title="" loading="lazy"/></p><p>全行业适配：电商、本地生活、教育、汽车服务、制造业、工厂建材等，可定制专属 AI 工作流。</p><p>对企业和个体来说，ai超级员工意味着什么？</p><p>1、组织变小，效率变高 一个原本需要5人轮岗的小团队，现在只需要1个决策者+3个AI员工。</p><p>2、执行成本极低，出错率极低 流程固定，逻辑清晰，AI员工不会迟到、不请假、不疲劳。</p><p>3、彻底解放创作者的“非创意劳动” 短视频创作者每天最累的不是拍摄，而是后期剪辑、定时发布、回复私信。现在，这些可以交给AI员工。</p><p>4、从“做事”到“指令”之间的跃迁 你不再亲自工作，而是像主管一样“分派任务”给AI员工。</p><p>随着AI智能体的不断发展和应用，其管理将成为未来企业面临的关键挑战。</p><p>实现人与AI的合理分工，探索优势互补，是AI时代共生协作的关键。企业需要构建“AI-Ready”的基础设施，并同步推动人才转型与文化适应。</p><p>当智能体真正融入组织，与“科技+数字人才+创新”深度融合时，生产力边界将被重新定义。智能体的生命周期管理将不再局限于技术运维层面，而是深入渗透到组织进化的基因层面，为企业带来前所未有的适应能力和竞争优势。</p>]]></description></item><item>    <title><![CDATA[2025年CRM系统排行：10款主流CR]]></title>    <link>https://segmentfault.com/a/1190000047440997</link>    <guid>https://segmentfault.com/a/1190000047440997</guid>    <pubDate>2025-12-01 15:05:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着数字化转型深入推进，客户关系管理（CRM）系统成为企业提升客户体验、优化销售流程和驱动业绩增长的关键工具。2025年，CRM市场持续高速增长，据Gartner数据显示，全球CRM市场规模预计将达到830亿美元，同比增长12.6%。面对众多CRM产品，企业如何选择最适合自己的系统？本文权威梳理2025年主流的10款CRM系统，结合最新统计数据与行业趋势，助力企业科学决策。</p><hr/><h2>一、CRM市场现状与发展趋势</h2><h3>1. 市场规模持续扩大</h3><ul><li>2024年全球CRM软件市场规模突破740亿美元，预计2025年将增至830亿美元（Statista &amp; IDC）。</li><li>亚太地区增长最快，年复合增长率达15.3%。</li><li>国际巨头：Salesforce、SAP、Oracle、Zoho等持续领跑。</li><li>国产CRM：Zoho CRM中国版、纷享销客、销售易等快速崛起。</li></ul><h3>2. SaaS模式成为主流</h3><ul><li>超过85%的CRM系统采用SaaS模式（Gartner）。</li><li>企业无需本地部署，按需付费，降低初始投入与运维成本。</li><li>CRM普及率提升，中小企业用户占比逐年增长。</li></ul><h3>3. 智能化与集成化加速</h3><ul><li>AI智能分析、自动化营销、客户画像等功能成为标配。</li><li>2025年，超60%的CRM将集成AI技术（IDC）。</li><li>CRM与ERP、营销自动化、客服系统等平台深度集成，提升运营效率。</li></ul><hr/><h2>二、2025年CRM系统十大排行</h2><p>榜单参考：Gartner Magic Quadrant、IDC MarketScape、Capterra等权威数据平台，综合市场份额、用户口碑、功能创新、服务能力等维度。</p><table><thead><tr><th>产品名称</th><th>标签/特征</th><th>市场份额</th><th>适用对象</th><th>核心优势</th><th>权威评价/评分</th></tr></thead><tbody><tr><td><strong>Zoho CRM</strong></td><td>全能型·高性价比</td><td>亚太24%</td><td>成长型团队/企业</td><td>高性价比、易用、功能全、自动化、AI、集成</td><td>Capterra 4.5/5, Forbes中国榜首</td></tr><tr><td><strong>Salesforce CRM</strong></td><td>旗舰型·功能最强</td><td>全球23%</td><td>中大型/跨国集团</td><td>平台化、生态丰富、AI领先、定制化</td><td>Gartner领导者, Capterra 4.6/5</td></tr><tr><td><strong>Microsoft Dynamics 365</strong></td><td>集成型·微软生态</td><td>8%</td><td>各类企业/微软用户</td><td>Office 365/Teams/BI集成、模块化、自动化</td><td>IDC创新者, 用户评分4.4/5</td></tr><tr><td><strong>SAP CRM（Customer Experience）</strong></td><td>企业级·数据分析强</td><td>6%</td><td>大型制造/零售/金融</td><td>数据分析强、复杂流程、全球支持</td><td>Gartner领导者</td></tr><tr><td><strong>Oracle CX Cloud</strong></td><td>安全型·数据合规</td><td>5%</td><td>大型/金融/服务业</td><td>数据安全、合规、云部署、AI客户洞察</td><td>Forrester强劲表现者</td></tr><tr><td><strong>HubSpot CRM</strong></td><td>营销型·自动化强</td><td>3%</td><td>中小企业/初创公司</td><td>免费基础版、营销自动化、内容管理、客户旅程分析</td><td>G2 Crowd 4.6/5</td></tr><tr><td><strong>Freshsales（Freshworks）</strong></td><td>轻量型·智能销售</td><td>2%</td><td>中小企业</td><td>界面友好、销售自动化、AI线索评分</td><td>Capterra 4.5/5</td></tr><tr><td><strong>Zoho Bigin</strong></td><td>极简型·小微专属</td><td>中小市场突出</td><td>初创/小型销售团队</td><td>极简设计、移动体验、销售自动化</td><td>G2 Crowd 4.7/5, Capterra 4.6/5</td></tr><tr><td><strong>Salesforce Service Cloud</strong></td><td>服务型·客户支持</td><td>2%</td><td>客服团队</td><td>多渠道服务、智能工单、AI客服助手</td><td>Gartner客户服务领导者</td></tr><tr><td><strong>纷享销客（中国市场）</strong></td><td>本地化·社交集成</td><td>中国5%</td><td>中国本土企业</td><td>微信集成、本地化、灵活定制</td><td>国内市场独特优势</td></tr></tbody></table><hr/><h2>三、如何选择适合自己的CRM系统？</h2><ol><li><p><strong>明确企业需求</strong></p><ul><li>业务规模、行业特点、管理流程、预算。</li><li>大型企业注重扩展性和安全性，中小企业看重易用性和性价比。</li></ul></li><li><p><strong>关注系统集成与扩展</strong></p><ul><li>是否支持ERP、财务、营销等系统集成。</li><li>开放API与第三方应用市场。</li></ul></li><li><p><strong>考察智能化与自动化能力</strong></p><ul><li>AI客户洞察、自动化营销、智能推荐等功能。</li><li>关注实际应用案例。</li></ul></li><li><p><strong>评估服务与支持</strong></p><ul><li>服务质量、技术支持、用户口碑、本地化服务能力。</li></ul></li><li><p><strong>试用与用户反馈</strong></p><ul><li>正式采购前建议试用，收集实际用户反馈，评估易用性和适配性。</li></ul></li></ol><hr/><h2>四、权威数据与引用来源</h2><ul><li>Gartner《2024年CRM市场魔力象限》</li><li>IDC《2025年全球CRM市场预测》</li><li>Statista《2025年CRM市场规模统计》</li><li>Capterra、G2 Crowd、Forrester等用户评价平台</li><li>艾瑞咨询《中国CRM市场报告2024》</li></ul><hr/><h2>五、结语：CRM系统的未来展望</h2><p>2025年，CRM系统正加速向智能化、集成化和个性化方向发展。AI、自动化营销、客户旅程管理等创新技术不断涌现。企业在选择CRM时，不仅要关注当前需求，更要兼顾未来发展和系统扩展性。无论是国际巨头还是新兴品牌，CRM系统的核心价值始终是“以客户为中心”，助力企业实现可持续增长。</p>]]></description></item><item>    <title><![CDATA[定制化 SpreadJS 设计器：从界面]]></title>    <link>https://segmentfault.com/a/1190000047441020</link>    <guid>https://segmentfault.com/a/1190000047441020</guid>    <pubDate>2025-12-01 15:04:40</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>定制化 SpreadJS 设计器：从界面到功能的深度解析</h2><p>SpreadJS Designer （以下简称表格设计器） 是一款与 SpreadJS 电子表格控件配套的可视化设计工具，提供类 Excel 的直观操作界面，涵盖表格布局、数据格式、公式编辑、图表插入等核心功能。它支持用户无代码自定义电子表格模板与交互逻辑，快速搭建符合业务需求的表格应用，且设计成果可直接与 SpreadJS 控件集成，无缝对接开发流程。</p><h3>一、表格设计器界面认识</h3><p>核心界面元素：包括顶部 Ribbon 功能区（含 Tab 标签、按钮组 ButtonGroups、操作按钮 Command 等）、右键触发的上下文菜单 ContextMenu （支持单元格、行列、工作表等多对象适配）、显示统计信息与缩放控制的状态栏 StatusBar，以及公式栏 FormulaBar、面板 SidePanels 等辅助元素。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441022" alt="img" title="img"/></p><p>这些元素通过 GC.Spread.Sheets.Designer.DefaultConfig / ToolBarModeConfig 配置，下文我们也将围绕 Config 进行介绍。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441023" alt="img" title="img" loading="lazy"/></p><h4>1、Ribbon 功能区</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441024" alt="img" title="img" loading="lazy"/></p><p>由多个选项卡（如 "开始""插入""公式""数据" 等）组成，每个选项卡下包含不同的功能组（如 "开始" 选项卡下的 "剪贴板""字体""对齐方式" 等）。</p><p>功能区集中了 Excel 的核心功能，涵盖文本格式设置、数据处理、图表插入、公式运算等各类操作，用户可通过点击不同选项卡和功能按钮快速执行相应任务。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441025" alt="img" title="img" loading="lazy"/></p><p>观察上图，ribbon 数组中包含 27 项 ，每一项都是一个选项卡内容，包括 id ，text，buttonGroups，visibleWhen 等属性。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441026" alt="img" title="img" loading="lazy"/></p><p>选中"开始" Tab ， 查看 buttonGroups 数组，可以看到数组项有 8 个，对应菜单中的 8 个类别 。例如：剪贴板、字体、对齐方式、数字、单元格类型等。 每一项的 buttonGroups 包含 label，commandGroup，thumbnailClass indicator 等 。</p><ul><li>label 是每一个 buttonGroup 的 group 名称，如"撤销"。</li><li>thumbnailClass 关联的是缩略图样式，用于直观展示该组功能的视觉标识。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441027" alt="img" title="img" loading="lazy"/></p><ul><li>indicator 用于提示查看更详细的功能内容。</li><li><a href="https://link.segmentfault.com/?enc=QP8s7aYvLVQoT%2FDAGdfXfw%3D%3D.UazTXNTJXvGSePAOjvpn7ROx0VpoEzNNVqHBqrw2lotH%2BMtrlcIQemsJfHlcddy3c00s5ECsAOEIxOyNDBlprlEcBSMq0cwjxqsYXaDcEeupZ4sDOAlKE%2FBhPaW5dGIHruIVJ%2B%2FHqkn%2B95BdgemL2Q%3D%3D" rel="nofollow" target="_blank">commandGroup</a> 是 command 集合，包含 children ，direction（默认横向布局） 等属性。 比如说字体中 command 是纵向布局，所以 commandGroup 为 ["direction": "vertical"，"children": []]。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441028" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441029" alt="img" title="img" loading="lazy"/></p><p>以上就是 Ribbon 功能区的初步介绍，相信大家对 Ribbon 数组有了一个基础了解。</p><h4>2、ContextMenu 上下文菜单</h4><p>在 SpreadJS 的不同对象（如单元格、图表、形状等）上点击鼠标右键触发。</p><p>ContextMenu 提供了与当前选中对象相关的快捷操作选项，例如在单元格上右键会出现 "复制""粘贴""设置单元格格式" 等选项；在行头上右键会出现"插入""删除"行等选项；在图表上右键会出现 "编辑数据""更改图表类型" 等选项；在 sheet 标签处右键会出现"表单保护"，"取消表单保护"，极大地提升了操作的便捷性。</p><p>单元格的上下文菜单</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441030" alt="img" title="img" loading="lazy"/></p><p>行头的上下文菜单</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441031" alt="img" title="img" loading="lazy"/></p><p>比如 Sheet 标签处的上下文菜单</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441032" alt="img" title="img" loading="lazy"/></p><p>比如图表处的上下文菜单</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441033" alt="img" title="img" loading="lazy"/></p><p>接下来，我们看下 config 中 contextMenu 数组</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441034" alt="img" title="img" loading="lazy"/></p><p>观察上图，contextMenu 是一个字符串数组，每一个字符串，都是一个 commandName。而每一个 command 通过 <strong>visibleContext</strong> 作用在不同的对象上。</p><h4>3、SidePanels 面板</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441035" alt="img" title="img" loading="lazy"/></p><p>目前为止，Designer 提供了 33 个 sidePanel 面板， 其中包括<strong>文件面板</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441036" alt="img" title="img" loading="lazy"/></p><p><strong>命令面板</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441037" alt="img" title="img" loading="lazy"/></p><p>每一个 sidePanel 包含以下属性：command，uiTemplate，position ，以及可选的 width，showCloseButton，allowResize 等。</p><p>可以通过<a href="https://link.segmentfault.com/?enc=J0wwlRg0%2FeH47bwIw2zU7w%3D%3D.EikmhQ9e3qA8WVbA9YWjQbKmUD0QFjqzqHk4HlyG3BTiynCZ3jeDVn7c%2BwkRpgvh01DILut2PzhrB7bQAH15eupUCdLKWCWlsMSvUoAXuWTdVdDZP1Ycj%2BYE5fGyP323pqwTdB9lJFm7g5bmqYB9zg%3D%3D" rel="nofollow" target="_blank">getCommand</a>获取命令，还可以通过<a href="https://link.segmentfault.com/?enc=W8klCT661p%2BRJTKnh0Plng%3D%3D.Yo%2B0FpZg7mioOLxwbTLV03oFSwj%2B94kdi4Iez9DihJU1eycEEYrpsv4eTybnfwCln0nHtz4XJRJdJyQar5YnQFMKPJaxgcoRJxvLxZKwsejghJHDDdbx8boxySTeSkfdvGCBMuFv7wchj8KYyGoRrg%3D%3D" rel="nofollow" target="_blank">getTemplate</a>获取模板 ， 如下图所示：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441038" alt="img" title="img" loading="lazy"/></p><h4>4、FormulaBar 公式栏</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441039" alt="img" title="img" loading="lazy"/></p><p>它包含名称框（左侧显示 "A1" 的部分，用于显示或定义单元格名称）和公式编辑栏（右侧用于输入、编辑单元格中的数据或公式，其中 "fx" 是插入函数的按钮）。通过这个区域，用户可以方便地进行数据输入和复杂公式的编辑操作。</p><p>图片下方的配置代码片段补充了公式栏的实现逻辑：它作为 sidePanels 数组中的一项，通过 command: "formulaBarPanel"绑定核心功能命令，uiTemplate: "formulaBarTemplate"关联界面模板，position: "top"指定其在设计器顶部的固定布局，同时通过 height: "34px"等属性控制尺寸，确保与整体界面协调。图片中公式栏的可视化呈现与配置代码的属性设置一一对应，清晰展现了 "配置 - 界面" 的映射关系。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441040" alt="img" title="img" loading="lazy"/></p><h4>5、StatusBar 状态栏</h4><p>位于 Designer 窗口的底部。 显示当前工作表的状态信息 （就绪，编辑，输入等状态），如单元格的统计信息（选中区域的求和、平均值、计数等）、缩放比例等，帮助用户实时了解工作表的状态。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441041" alt="img" title="img" loading="lazy"/></p><p>下方的配置代码揭示了状态栏的实现方式：它同样是 sidePanels 的配置项之一，通过 command: "statusBarPanel"绑定状态栏功能逻辑，uiTemplate: "statusBarPanelTemplate"加载界面模板，position: "bottom"明确其固定在设计器底部的布局位置。图片中状态栏的各项显示元素（状态文本、统计区域、缩放控制），均通过该配置项的属性定义实现，直观体现了配置对界面功能的支撑作用。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441042" alt="img" title="img" loading="lazy"/></p><h4>6、Ribbon 模式</h4><p>SpreadJS 设计器组件提供了两种不同的 Ribbon 模式，如下所示：</p><p>功能区模式：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441043" alt="img" title="img" loading="lazy"/></p><p>工具栏模式：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441044" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441045" alt="img" title="img" loading="lazy"/></p><p>通过下面的代码，可以进行两者切换</p><pre><code class="JavaScript">var switchConfig = true;
var designer = new GC.Spread.Sheets.Designer.Designer(document.getElementById("designerHost"));
document.getElementById('btn').addEventListener('click', function () {
            designer.setConfig(switchConfig ? GC.Spread.Sheets.Designer.ToolBarModeConfig : GC.Spread.Sheets.Designer.DefaultConfig);
            switchConfig = !switchConfig;
        });</code></pre><p>接下来，从代码层面对比差异</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441046" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441047" alt="img" title="img" loading="lazy"/></p><p>折叠 Ribbon 区域：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441048" alt="img" title="img" loading="lazy"/></p><pre><code class="JavaScript">designer.setData('isRibbonCollapse',true);</code></pre><h4>7、Command 命令</h4><p>什么是 Command ？</p><p>Command 是 SpreadJS 设计器的<strong>功能命令对象</strong>，是控制界面元素（菜单、按钮、面板等）功能逻辑的核心载体。每个 Command 包含唯一标识（commandName）、外观配置（text、iconClass 等）、显示规则（visibleContext）、启用条件（enableContext）、执行逻辑（execute）等属性，统一管理功能的 "显示 - 启用 - 执行" 全流程。</p><h5>1）认识 Command 命令</h5><p>有两种方式，可以获取到命令。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441049" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441050" alt="img" title="img" loading="lazy"/></p><p>API 文档：<a href="https://link.segmentfault.com/?enc=oqrKP2fX0d91VgPiqY3YVw%3D%3D.S3PNpvJpXT8sqfB8Q58XrzNaftAJf7CGOwJEniPGGxjaVfLYjE9Kb26z31W2UcrDixB7OfmHL1nkwwq8%2FjMUT9ya8CI78TyYfamYSXuoOH9T3NVKin8xT5z79iK6RNcfUoo1hghVFw14JMOJoyonsg%3D%3D" rel="nofollow" target="_blank">https://demo.grapecity.com.cn/spreadjs/help/api/designer/clas...</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441051" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441052" alt="img" title="img" loading="lazy"/></p><h5>2）Command 命令属性</h5><p>核心标识属性</p><ul><li><strong>commandName</strong>：必填属性，命令的唯一标识字符串，用于区分不同功能。</li><li><strong>text</strong>：命令的显示文本（如按钮文字），可选。</li><li><strong>title</strong>：命令的提示文本（如 hover 时显示），可选。</li></ul><p>外观样式属性</p><ul><li><strong>iconClass</strong>：图标样式类名，用于显示命令图标，可选。</li><li><strong>iconHeight/iconWidth</strong>：图标尺寸，可选。</li><li><strong>bigButton</strong>：控制按钮是否为大尺寸，支持布尔值或字符串配置，可选。</li><li><strong>type</strong>：命令组件类型（如下拉框、输入框、按钮），可选。</li></ul><p>交互行为属性</p><ul><li><strong>execute</strong>：命令触发时执行的函数，定义核心功能逻辑，可选。</li><li><strong>getState</strong>：获取命令当前状态（如是否禁用）的函数，可选。</li><li><strong>init</strong>：命令初始化时执行的函数，可选。</li><li><strong>visibleContext</strong>：控制命令在特定上下文（如选中单元格、图表）显示，可选。</li><li><strong>visiblePriority</strong>：显示优先级，数值越高越优先展示，可选。</li><li><strong>enableContext</strong> ：指定命令启用的上下文场景（如下拉项交互、特定组件状态），仅当场景匹配时命令才会激活可用，可选。</li></ul><p>其它具体可以查看<a href="https://link.segmentfault.com/?enc=KiCSvrn0fZwQa4qaGO4WKA%3D%3D.sqeDRVHXXMPOXcuWx6nUfMm7HrkMi9Qj4H6hfMXtOJkkMcQXvlgANNgXDn68w%2FJLK4Ku6Q6%2FZYdEt%2BMOTHMIcJXw7RaX7klZghnd640ahWWIzAcTSKEnLHFSsvX6TTrm8AhV07H5zTy7BCdNh%2Fw4pg%3D%3D" rel="nofollow" target="_blank">API</a>链接</p><h3>二、Ribbon 菜单定制</h3><h4>1、添加选项卡</h4><p>企业部署 SpreadJS 设计器供内部使用时，可以在界面添加 "联系技术支持" 入口，方便用户遇到操作问题时快速对接售后，因此新增独立选项卡预留功能扩展空间。</p><p>通过下面的代码添加"选项卡" 需要设置 id ， text ， buttonGroups 等属性。</p><pre><code class="JavaScript">let config = GC.Spread.Sheets.Designer.DefaultConfig
var newTab = {
    id: 'contactUs',
    text: '联系我们',
    buttonGroups: [],
};
// 将新选项卡添加到配置的功能区中
config.ribbon.push(newTab);

//如果designer已经实例化
//designer.setConfig(config) 
//如果designer 还未实例化
var designer = new GC.Spread.Sheets.Designer.Designer(document.getElementById("gc-designer-container"), config);</code></pre><p>完成上面的操作后，可以看到一个名为"联系我们"的 ribbon 菜单 已经被添加到了工具栏上。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441053" alt="img" title="img" loading="lazy"/></p><h4>2、设置活动选项卡</h4><p>某业务系统的表格设计器默认需高频使用 "插入" 功能（如插入图表、数据透视表），为提升操作效率，将 "插入" 选项卡设为初始化时的默认选中状态，减少用户切换步骤。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441054" alt="img" title="img" loading="lazy"/></p><p>默认情况下，在 Designer 组件初始化时，"开始"（HOME）是活动选项卡。但是，如果要设置其他选项目为默认选中效果，可以通过下面的代码设置。</p><pre><code class="JavaScript">var config = GC.Spread.Sheets.Designer.DefaultConfig;
//将"插入"置为活动选项卡
config.ribbon[1].active = true;
var designer = new GC.Spread.Sheets.Designer.Designer(document.getElementById("gc-designer-container"), config);
let currentActiveRibbonTab = designer.activeRibbonTab();
//将"页面布局"置为活动选项卡
if (currentActiveRibbonTab !== 'pageLayout') {
    designer.activeRibbonTab('pageLayout');
}</code></pre><h4>3、添加菜单</h4><h5>1） 添加"保存"菜单</h5><p>为保持与 Designer 原生菜单的视觉风格、操作逻辑高度一致，避免新增功能显得突兀割裂，让用户获得连贯流畅的使用体验，特定制 "保存数据" 专属菜单。该菜单在延续 Designer 简洁直观的交互设计、样式规范基础上，补充原生菜单缺失的业务化数据同步能力，既让功能拓展不破坏整体界面协调性，又能让用户自然接纳新功能，同时满足业务数据直连后端的核心需求。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441055" alt="img" title="img" loading="lazy"/></p><pre><code class="JavaScript">// 访问默认配置
var config = GC.Spread.Sheets.Designer.DefaultConfig;
// 设置新按钮的布局
var saveData = {
    label: '保存数据',
    thumbnailClass: 'ribbon-thumbnail-clipboard',
    commandGroup: {
        children: [
            {
                commands: ['cmdSaveData'],
            },
        ],
    },
};
// 将新按钮添加到"开始"选项卡中
config.ribbon[0].buttonGroups.unshift(saveData);
// 为新按钮创建命令
config.commandMap = {
    cmdSaveData: {
        title: '保存数据到服务器', //鼠标悬浮提示文字
        text: '保存',  //菜单显示名称
        iconClass: 'ribbon-button-namemanager',
        bigButton: 'true',
        commandName: 'cmdSaveData',
        execute: async (context, propertyName, fontItalicChecked) =&gt; {
            // 自定义操作
            alert('Save data successfully.');
        },
    },
};
// 初始化设计器实例
var designer = new GC.Spread.Sheets.Designer.Designer("gc-designer-container");
designer.setConfig(config);</code></pre><p>上述代码的步骤是：</p><ol><li>先获取 SpreadJS 设计器的默认配置；</li><li>定义 "保存数据" 按钮组的布局 <strong><a href="https://link.segmentfault.com/?enc=SXIQTDoS9ISt0jQI1d6gCg%3D%3D.F%2BK4ZpYrScYYEFRld7JPAyWrCT7AqFIGfaJJl3Xg0hTj7HazD1nskf2NGhkby0%2BOUjo2k15CBHRyEURqZcvpF4iMnNQBStFjCNSZuyKQAfcf5rQMaEu9wWXkhMq49fiiaf16yAr5LSNevqGKB7C7tnCd%2BFDdANh7eYO5M7asTjseq3GXly1aGYEAsDJS%2FdwW" rel="nofollow" target="_blank">IButtonGroup</a></strong>（定义了 label ，thumbnailClass ， commandGroup 以及在 commandGroup 中定义了 commandName）；</li><li>把该按钮组加到 "开始" 选项卡最前面；</li><li>配置按钮功能：设置<a href="https://link.segmentfault.com/?enc=3ilJU36D1ZBcRCO6E7TOYQ%3D%3D.l%2B9t6HiWMoko3fK44gRRhGSP2%2BP19vLO2F1W7XaohUZMsMvlsomq27VeSTdoDSmboVwckhML8gXF5WrdRvrMnLp7ppYijtSeFuf5tzZH5pW87ozPtei2ClTn97baC1KrrQR7O%2FaP4ACEUzP58zqJNg%3D%3D" rel="nofollow" target="_blank">commandMap</a> 。注册一个 <a href="https://link.segmentfault.com/?enc=MmDhHD8K60FlWvhN%2BcsEjQ%3D%3D.rMSZbd0TSbHKnndibxcCtfOdwqIs%2BtLkboSNl1ozxzOga%2BKFQpcaVLzOJALjIo4CGjDWftFIPEeUaxHEgD3btz28eVwClRNnm%2BRkuzWxYH4BfUVLtLqnQBUwXduvbWADLiF2i0Fs6MXFLz83%2FdameMf3UgSfRzU2C381oLJA%2FKo%3D" rel="nofollow" target="_blank">Command</a>，包括 title 悬浮提示 "保存数据到服务器"、text 显示 "保存" 文字 + iconClass 对应图标，以及 execute 点击弹出 "保存成功" 提示；</li><li>初始化设计器并应用上述配置。</li></ol><h5>2） 添加一个下拉框菜单</h5><p>用户需批量导出表格内容为不同格式（PDF、图片），为简化操作，在 "开始" 选项卡添加 "文件操作" 下拉框，集中放置各类导出功能，避免功能分散。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441056" alt="img" title="img" loading="lazy"/></p><pre><code class="JavaScript">// 访问默认配置
var config = GC.Spread.Sheets.Designer.DefaultConfig;
var ribbonFileConfig =
    {
        "label": "文件操作",
        "thumbnailClass": "ribbon-thumbnail-clipboard",
        "commandGroup": {
            "children": [
                {
                    "command": "exportImage_List",
                    "type": "dropdown",
                    "children":[
                        "exportSheetPDFImage",
                        "exportRangePDFImage",
                        "exportSheetImage",
                        "exportRangeImage"
                    ]
                },
            ]

        }
    }
// 将新按钮添加到"开始"选项卡中
config.ribbon[0].buttonGroups.unshift(ribbonFileConfig);
// 为新按钮创建命令
config.commandMap = {
    "exportImage_List": {
        title: '导出图片',
        text: '导出图片',
        bigButton: true,
        iconClass: 'ribbon-button-namemanager',
        commandName: 'exportImage_List',  //command ，需唯一
    },
    "exportSheetPDFImage": {
        title: 'Sheet导出PDF图片',
        text: "Sheet导出PDF图片",
        iconClass: "ribbon-button-namemanager",
        commandName: "exportSheetPDFImage"
    },
    "exportRangePDFImage": {
        title: '选择区域导出PDF图片',
        text: "选择区域导出PDF图片",
        iconClass: "ribbon-button-namemanager",
        commandName: "exportRangePDFImage"
    },
    "exportSheetImage": {
        title: 'Sheet导出图片',
        text: "Sheet导出图片",
        iconClass: "ribbon-button-namemanager",
        commandName: "exportSheetImage"
    },
    "exportRangeImage": {
        title: '选择区域导出图片',
        text: "选择区域导出图片",
        iconClass: "ribbon-button-namemanager",
        commandName: "exportRangeImage"
    },

};

// 初始化设计器实例
var designer = new GC.Spread.Sheets.Designer.Designer(document.getElementById('gc-designer-container'),config);</code></pre><h5>3）自定义有选中效果的 Command</h5><p>数据保存后需直观提示用户 "已保存" 状态，因此将 "保存数据" 按钮设为复选框类型，点击保存后按钮保持选中状态，直至数据修改后自动取消。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441057" alt="img" title="img" loading="lazy"/></p><pre><code class="JavaScript">var config = GC.Spread.Sheets.Designer.DefaultConfig;
config.commandMap = {
    cmdSaveData: {
        title: '保存数据到服务器', //鼠标悬浮提示文字
        text: '保存',  //菜单显示名称
        iconClass: 'ribbon-button-namemanager',
        bigButton: 'true',
        commandName: 'cmdSaveData',
        type:"checkbox",
        execute: async (context, e, checked) =&gt; {
            // 自定义操作
            alert('Save data successfully.');
            context.setData('save_button_check', checked);
        },
        getState: function (context, e, checked) {
            return context.getData('save_button_check');
        }
    },
};
var designer = new GC.Spread.Sheets.Designer.Designer(document.getElementById('gc-designer-container'),config);</code></pre><h3>4、修改菜单</h3><h5>1) EnableContext</h5><p>管理员需限制仅特定权限用户（通过 <code>controlByMySelf</code> 标识）可修改表格页边距，因此通过修改 "页边距" 命令的 enableContext，添加权限校验条件。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441058" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441059" alt="img" title="img" loading="lazy"/></p><pre><code class="Java">let config= GC.Spread.Sheets.Designer.DefaultConfig;
var command = GC.Spread.Sheets.Designer.getCommand('margins');
let enableContext = command.enableContext;
command.enableContext = command.enableContext == null ? "controlByMyself" : command.enableContext + "&amp;&amp; controlByMyself";

config.commandMap = {
    "margins": command
}
var designer = new GC.Spread.Sheets.Designer.Designer("gc-designer-container");
designer.setConfig(config)</code></pre><h5>2) Execute</h5><p>原生 "保存 Schema" 功能仅保存基础配置，业务需在保存前校验数据格式合法性，因此重写 execute 方法，在执行原生逻辑前添加数据校验步骤。</p><p><strong>重写 Execute</strong></p><pre><code class="JavaScript">let config= JSON.parse(JSON.stringify(GC.Spread.Sheets.Designer.DefaultConfig));

var command = GC.Spread.Sheets.Designer.getCommand("saveSchema");
var oldExecute = command.execute;
command.execute = function (context, propertyName) {
    //执行业务逻辑
    oldExecute.call(this, context, propertyName)
}

config.commandMap = {
    "saveSchema": command
}
var designer = new GC.Spread.Sheets.Designer.Designer("gc-designer-container");
designer.setConfig(config)</code></pre><p><strong>添加撤销逻辑</strong></p><p>用户想要合并单元格的实现和 Excel 一致，需要其他单元格的值删除。即需要重写 Execute 。</p><pre><code class="JavaScript">let mergeCenterCommand = GC.Spread.Sheets.Designer.getCommand(GC.Spread.Sheets.Designer.CommandNames.MergeCenter);
if (mergeCenterCommand) {
    let oldExecute = mergeCenterCommand.execute;
    mergeCenterCommand.execute = function (context, propertyName, args) {

        oldExecute.call(this, context, propertyName, args);

        let spread = context.getWorkbook()
        let sheet = spread.getActiveSheet()
        var selections = sheet.getSelections();
        let {row, col, rowCount, colCount} = selections[0]

        let value = sheet.getValue(row, col)
        sheet.clear(row, col, rowCount, colCount, GC.Spread.Sheets.SheetArea.viewport, GC.Spread.Sheets.StorageType.data);
        sheet.setValue(row, col, value)
    }
}
var config = GC.Spread.Sheets.Designer.DefaultConfig
config.commandMap = {
    "mergeCenter": mergeCenterCommand
}
var designer = new GC.Spread.Sheets.Designer.Designer(document.getElementById("gc-designer-container"), config);</code></pre><p>但是重写后，不支持撤销功能恢复原始状态，因此自定义合并单元格命令，通过事务管理（startTransaction/endTransaction）实现撤销 / 重做。</p><p>SpreadJS 可以实现一个支持撤销/重做的自定义命令</p><p><a href="https://link.segmentfault.com/?enc=gDLJxH33zu4mnJPczhBlwQ%3D%3D.hjysc9uaz5yW9DYnqeU5dYvQ0M%2FEQ%2FJwxPYwdj3sFLTTwuJ1m3%2B9KtHYYuau3DLLfaMD4Xm5WWE1WgVZPXxGkRS2wbrnYMZmSZgY8QFdtYyoaMpuSg7Ibd11Qfk0EQ14RpYf2luSdoWJz0xLjNyaAw%3D%3D" rel="nofollow" target="_blank">https://demo.grapecity.com.cn/spreadjs/SpreadJSTutorial/featu...</a></p><p>如果你想实现一个支持撤销/重做的命令，你可以通过如下方法启动一个事务，命令中的任何行为和数据变更将开启自动存储。</p><pre><code class="JavaScript">GC.Spread.Sheets.Command.startTransaction(context, options);</code></pre><p>在命令执行结束后，通过如下方法结束当前事务，当前命令的任何变更将被自动存储。</p><pre><code class="JavaScript">GC.Spread.Sheets.Command.endTransaction(context, options);</code></pre><p>如果你想撤销上一次的命令，通过如下方法撤销事务，那么上次命令执行的结果将被撤销。</p><pre><code class="JavaScript">GC.Spread.Sheets.Command.undoTransaction(context, options);</code></pre><p>所以，需要先定义一个命令，然后注册命令。当执行 execute（）时，执行刚刚注册的命令。</p><pre><code class="JavaScript">let config= JSON.parse(JSON.stringify(GC.Spread.Sheets.Designer.DefaultConfig));

var command = GC.Spread.Sheets.Designer.getCommand("mergeCenter");
var oldExecute = command.execute;
command.execute = function (context) {
    let spread = context.getWorkbook();
    let sheet = spread.getActiveSheet();
    spread.commandManager().execute({
        cmd: "mergeCenter2",
        selections: sheet.getSelections(),
        sheetName: sheet.name(),
        oldExecute
    });
}
config.commandMap = {
    "mergeCenter": command
}
spread.commandManager().register("mergeCenter2", {
    canUndo: true,
    execute: function (context, options, isUndo) {
        var Commands = GC.Spread.Sheets.Commands;
        if (isUndo) {
            Commands.undoTransaction(spread, options);
            return true;
        } else {
            let sheet = context.getActiveSheet();
            Commands.startTransaction(context, options);

            spread.suspendPaint();

            var selections = options.selections;
            let {row, col, rowCount, colCount} = selections[0]

            let value = sheet.getValue(row, col)
            sheet.clear(row, col, rowCount, colCount, GC.Spread.Sheets.SheetArea.viewport, GC.Spread.Sheets.StorageType.data);
            sheet.setValue(row, col, value)
            sheet.addSpan(row, col, rowCount, colCount);
            sheet.getCell(row, col).hAlign(GC.Spread.Sheets.HorizontalAlign.center)

            spread.resumePaint();
            Commands.endTransaction(context, options);
            return true;
        }
    },
});
designer.setConfig(config)</code></pre><h4>5、删除菜单</h4><p>有时候仅需基础数据录入的场景，隐藏 "数据" 选项卡中的复杂格式设置功能，避免用户误操作。</p><h5>1） 删除数组元素</h5><pre><code class="JavaScript">let config= JSON.parse(JSON.stringify(GC.Spread.Sheets.Designer.DefaultConfig));
config.ribbon = config.ribbon.filter(item =&gt; item.id !== "data");
designer.setConfig(config)</code></pre><h5>2) <strong>visibleWhen</strong></h5><pre><code class="JavaScript">let config = GC.Spread.Sheets.Designer.DefaultConfig
let dataRibbon = config.ribbon.find(item =&gt; item.id == "data");
dataRibbon.visibleWhen += "&amp;&amp; controlByMyself";
designer.setConfig(config)


//通过controlByMyself 控制visibleWhen  ，来控制"数据" 选项卡显示与隐藏
designer.setData("controlByMyself",false)
designer.setData("controlByMyself",true)</code></pre><h3>三、ContextMenu 上下文菜单定制</h3><h4>1、添加菜单</h4><p>财务报表、审批表格需添加电子签名确认，因此在行头右键菜单中添加 "插入签名" 功能，方便用户快速插入签名信息。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441060" alt="img" title="img" loading="lazy"/></p><pre><code class="JavaScript">var config = GC.Spread.Sheets.Designer.DefaultConfig;
let command = {
    text: "插入签名",
    commandName: "insertSignatureMenu",
    visibleContext: "ClickRowHeader",
    execute: () =&gt; {
        console.log("插入签名");
    }
}
config.contextMenu.unshift("insertSignatureMenu");
// 为新的上下文菜单项创建命令
config.commandMap = {"insertSignatureMenu": command}
designer.setConfig(config)</code></pre><h4>2、修改菜单</h4><h5>1) EnableContext</h5><p>表格中第 3、4 列是非核心数据列，允许用户随意插入 / 删除，因此通过 <strong>enableContext</strong> 限制仅非核心列可触发 "插入列 / 删除列" 右键菜单。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441061" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441062" alt="img" title="img" loading="lazy"/></p><pre><code class="JavaScript">const CONTEXT_MENU_COMMANDS = [
    "gc.spread.contextMenu.insertColumns",
    "gc.spread.contextMenu.deleteColumns",
    "gc.spread.contextMenu.insertRows",
    "gc.spread.contextMenu.deleteRows"
];
const CONTROLLED_COLUMNS = [3, 4]; // 需要控制的列索引
const CONTROL_KEY = "controlByMyself";
const config= JSON.parse(JSON.stringify(GC.Spread.Sheets.Designer.DefaultConfig));

const commandMap = {};
CONTEXT_MENU_COMMANDS.forEach(commandId =&gt; {
    const command = GC.Spread.Sheets.Designer.getCommand(commandId);
    // 保留原有启用条件，追加自定义控制逻辑（使用模板字符串更清晰）
    command.enableContext = `${command.enableContext} &amp;&amp; ${CONTROL_KEY}`;

    commandMap[commandId] = command;
});

config.commandMap = {
    ...config.commandMap, // 保留默认其他命令
    ...commandMap // 覆盖需要自定义的命令
};

const designer = new GC.Spread.Sheets.Designer.Designer("gc-designer-container", config);
const spread = designer.getWorkbook();

const oldOpenMenu = spread.contextMenu.onOpenMenu;
spread.contextMenu.onOpenMenu = function (menuData, itemsDataForShown, hitInfo, spread) {
    const activeSheet = spread.getActiveSheet();
    const selections = activeSheet.getSelections() || [];
    const isControlledColumn = selections.length &gt; 0
        ? CONTROLLED_COLUMNS.includes(selections[0].col)
        : false;

    // 设置控制状态
    designer.setData(CONTROL_KEY, isControlledColumn);

    // 执行原有逻辑（保持this上下文正确）
    oldOpenMenu.call(this, menuData, itemsDataForShown, hitInfo, spread);
};</code></pre><h5>2) VisibleContext</h5><p>仅 "Sheet1" 为数据录入表，需快速标记异常数据，因此仅在 Sheet1 中显示 "添加红色背景" 右键菜单，其他工作表隐藏该功能，避免干扰。</p><p>通过下面的代码，在 onOpenMenu（） 方法中 ，判断当前 sheet 是否是 sheet1 ，如果是的话 designer 将 controlByMySelf 变量置为 true ，此时，如果用户选中的是单元格区域，则 visibleContext 则为 true ， 此时可以被用户看到，否则用户将看不到此菜单</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441063" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441064" alt="img" title="img" loading="lazy"/></p><pre><code class="JavaScript">var config = JSON.parse(JSON.stringify(GC.Spread.Sheets.Designer.DefaultConfig));

config.commandMap = {
    addRedBackColorCommand: {
        text: "添加红色背景",
        commandName: "addRedBackColorCommand",
        visibleContext: "ClickViewport &amp;&amp; controlByMySelf",
        execute: async (context, _, options) =&gt; {
            var spread = context.getWorkbook();
            let sheet = spread.getActiveSheet()
            let cell = sheet.getCell(options.activeRow,options.activeCol)
            cell.backColor('red')
        }
    }
}

config.contextMenu.unshift("addRedBackColorCommand");
var designer = new GC.Spread.Sheets.Designer.Designer("gc-designer-container",config);
let spread = designer.getWorkbook()

var oldOpenMenu = spread.contextMenu.onOpenMenu;
spread.contextMenu.onOpenMenu = function (menuData, itemsDataForShown, hitInfo, spread) {
    let sheet = spread.getActiveSheet()
    if (sheet.name() == 'Sheet1') {
        designer.setData("controlByMySelf", true);
    } else {
        designer.setData("controlByMySelf", false);
    }
    oldOpenMenu.apply(this, arguments);
};</code></pre><h4>3、删除菜单</h4><p>在上文中，我们可以通过 visibleContext 属性控制菜单是否显示与隐藏。但是在一些场景下，管理员为防止用户解除表格保护后篡改数据，需永久隐藏 "取消表单保护" 右键菜单，仅保留管理员通过后台操作解除保护的权限。那么我们直接从 contextMenu 数组中删除即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441065" alt="img" title="img" loading="lazy"/></p><pre><code class="JavaScript">var config = JSON.parse(JSON.stringify(GC.Spread.Sheets.Designer.DefaultConfig));
let index2 = config.contextMenu.indexOf("unprotectSheet");
config.contextMenu.splice(index2, 1);
designer.setConfig(config)</code></pre><h3>四、<strong>SidePanel 面板</strong>的定制</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441066" alt="img" title="img" loading="lazy"/></p><h4>1、删除 / 隐藏</h4><p>报表展示场景中，用户无需查看或修改数据源，仅需浏览报表结果，因此删除左侧 "数据源" 面板，简化界面布局。，可以用下面的代码，删除 tableListPanel</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441067" alt="img" title="img" loading="lazy"/></p><pre><code class="JavaScript">var removeSidePanels = ["tableListPanel"];
config.sidePanels = config.sidePanels.filter(function (item) {
    return removeSidePanels.indexOf(item.command) == -1;
});
designer.setConfig(config)</code></pre><p>当然，上面的代码，将 formulaBarPanel 直接从 sidePanels 数组中删除，但是如果想在特定条件下删除（隐藏）该如何处理呢？ 通过上文，我们知道 command 命令中 visibleContext 可以控制 菜单的显示与隐藏。那么，</p><p>我们也按照这个思路，来</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441068" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441069" alt="img" title="img" loading="lazy"/></p><pre><code class="JavaScript">let command = GC.Spread.Sheets.Designer.getCommand("tableListPanel")
command.visibleContext = ` (${command.visibleContext}) &amp;&amp; controlByMySelf`
config.commandMap = {
    "tableListPanel":command
}
designer.setConfig(config)
designer.setData("controlByMySelf",true)  //使其显示
// designer.setData("controlByMySelf",false)  //使其隐藏</code></pre><h3>五、Template 定制</h3><h4>1、添加提示文本</h4><p>新手用户使用 "插入图表" 功能时需引导，因此在对话框顶部和底部添加提示文本（如 "选择图表类型后点击确定"），提升易用性。</p><pre><code class="Go">let insertChartDlgTemplate = GC.Spread.Sheets.Designer.getTemplate(GC.Spread.Sheets.Designer.TemplateNames.InsertChartDlgTemplate)
if(insertChartDlgTemplate){
  //上方插入文字
  insertChartDlgTemplate.content.unshift({type: "TextBlock", text: "文本", margin: "5px 0", style: "color: rgb(226, 107, 29);font-size:18px"})
  //下方插入文字
  insertChartDlgTemplate.content.push({type: "TextBlock", text: "文本", margin: "5px 0", style: "color: rgb(226, 107, 29);font-size:18px"})
GC.Spread.Sheets.Designer.registerTemplate(GC.Spread.Sheets.Designer.TemplateNames.InsertChartDlgTemplate, insertChartDlgTemplate)
}</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441070" alt="img" title="img" loading="lazy"/></p><h4>2、添加自定义函数</h4><p>业务需计算阶乘数据（如统计分析场景），而设计器原生无阶乘函数，因此自定义 FACTORIAL 函数，并添加到 "插入函数" 对话框中，方便用户调用。</p><p>首先，我们先自定义一个函数</p><pre><code class="JavaScript">function FactorialFunction() {
    this.typeName = "FactorialFunction";
    this.name = "FACTORIAL";
    this.maxArgs = 1;
    this.minArgs = 1;
    this.description = function () {
        return (
            {
                description: "菲波那切数列",
                parameters: [
                    {
                        name: 'number01',
                        repeatable: false,
                        optional: false
                    }
                ]
            }
        )
    }
}

FactorialFunction.prototype = new GC.Spread.CalcEngine.Functions.Function();
FactorialFunction.prototype.evaluate = function (arg) {
    var result = 1;
    if (arguments.length === 1 &amp;&amp; !isNaN(parseInt(arg))) {
        for (var i = 1; i &lt;= arg; i++) {
            result = i * result;
        }
        return result;
    }
    return "#VALUE!";
};

var factorial = new FactorialFunction();
GC.Spread.CalcEngine.Functions.defineGlobalCustomFunction("FACTORIAL", new FactorialFunction());</code></pre><p>定义完这个函数后，我们需要找这个弹框对应的 template。对应的是 GC.Spread.Sheets.Designer.TemplateNames.InsertFunctionDialogTemplate。</p><pre><code class="JavaScript">var template = GC.Spread.Sheets.Designer.getTemplate(GC.Spread.Sheets.Designer.TemplateNames.InsertFunctionDialogTemplate);</code></pre><p>我们要添加函数的位置在这个数组中</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441071" alt="img" title="img" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441072" alt="img" title="img" loading="lazy"/></p><p>通过 bindingPath 找到这个位置，并且添加我们的自定义函数对象</p><pre><code class="JavaScript">function customFontFamilyInFormatDialogTemplate(templateNode) {
    if (templateNode.bindingPath &amp;&amp; templateNode.bindingPath === 'functionDesc.allFunction' &amp;&amp; templateNode.items) {
        templateNode.items.unshift({text: "FACTORIAL", value: "FACTORIAL"})
        return;
    }
    let nodes = templateNode.content || templateNode.children;
    if (nodes &amp;&amp; nodes instanceof Array) {
        nodes.forEach((subNode) =&gt; customFontFamilyInFormatDialogTemplate(subNode));
    }
}</code></pre><p>最后注册</p><pre><code class="JavaScript">GC.Spread.Sheets.Designer.registerTemplate(GC.Spread.Sheets.Designer.TemplateNames.InsertFunctionDialogTemplate, template);</code></pre><p>结果：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441073" alt="img" title="img" loading="lazy"/></p><h4>3、添加对话框 Dialog</h4><p>"插入签名" 功能需用户选择签名插入范围，因此创建自定义对话框，提供单元格范围选择器，明确签名插入位置。</p><p>在之前的内容中，我们提到 添加"插入签名"右键菜单，我们继续扩展，再在此基础上，我们添加一个对话框</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441074" alt="img" title="img" loading="lazy"/></p><pre><code class="Bash">let insertSignature = {
    templateName: 'insertSignature',
    title: '签名对话框',
    content: [
        {
            type: 'FlexContainer',
            children: [
                {
                    type: 'TextBlock',
                    margin: '5px -4px',
                    text: '插入范围',
                },
                {
                    type: 'RangeSelect',
                    title: '选择范围',
                    absoluteReference: true,
                    needSheetName: false,
                    margin: '5px -5px',
                },
            ],
        },
    ],
};
// 使用 registerTemplate 注册对话框模板实例
GC.Spread.Sheets.Designer.registerTemplate('signature', insertSignature);
config.commandMap = {
    insertSignatureMenu: {
        text: '插入签名',
        commandName: 'insertSignatureMenu',
        visibleContext: 'clickRowHeader',
        // 执行 InsertSignature，以下只是一个简单的代码片段示例
        execute: () =&gt; {
            // 在此处添加在步骤4中注册的对话框模板名称。
            GC.Spread.Sheets.Designer.showDialog('signature');
        },
    },
};</code></pre><h3>六、其他</h3><h4>1、主题切换</h4><pre><code class="JavaScript">document.getElementById('themeToggle').addEventListener('click', function () {
    toggleTheme();
});

function setTheme(theme) {
    currentTheme = theme;
    var designerTag = document.querySelector('link[theme-label="designer"]');
    var runtimeTag = document.querySelector('link[theme-label="runtime"]');
    var designerTheme, runtimeTheme;
    if (theme === 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark');
    } else {
        document.documentElement.removeAttribute('data-theme');
    }
    addThemeLink(getNewTheme(designerTag, 'gc.spread.sheets.designer.', currentTheme + ".min.css"), 'designer', designerTag);
    addThemeLink(getNewTheme(runtimeTag, 'gc.spread.sheets.', currentTheme === 'dark' ? "excel2016black.css" : "excel2013white.css"), 'runtime', runtimeTag);
}

function getNewTheme(target, themeBase, themeVariant) {
    var header = document.getElementsByTagName('head')[0];
    var href = target.href,
        pos = href.indexOf(themeBase),
        item = href.substr(0, pos) + themeBase + themeVariant;
    return item;
}

function toggleTheme() {
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    setTheme(newTheme);
}

function addThemeLink(href, themeLabel, target) {
    var header = document.getElementsByTagName('head')[0];
    var link = document.createElement('link');
    link.type = "text/css";
    link.rel = "stylesheet";
    link.href = href;
    link.setAttribute('theme-label', themeLabel);
    link.onload = function () {
        header.removeChild(target);
        var designer = GC.Spread.Sheets.Designer.findControl("gc-designer-container");
        var spread = designer.getWorkbook();
        spread.refresh();
        designer.refresh();
    };

    header.appendChild(link);
}</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441075" alt="img" title="img" loading="lazy"/></p><h4>2、添加中文字体</h4><pre><code class="JavaScript">var res = GC.Spread.Sheets.Designer.getResources();
let reorganizeFontFamilies = [];
reorganizeFontFamilies.push({ name: "微软雅黑", text: "微软雅黑" });
reorganizeFontFamilies.push({ name: "黑体", text: "黑体" });
reorganizeFontFamilies.push({ name: "新宋体", text: "新宋体" });
reorganizeFontFamilies.push({ name: "仿宋", text: "仿宋" });
reorganizeFontFamilies.push({ name: "隶书", text: "隶书" });
reorganizeFontFamilies.push({ name: "楷体", text: "楷体" });
Object.keys(res.ribbon.fontFamilies).forEach(function (key) {
    reorganizeFontFamilies.push(res.ribbon.fontFamilies[key]);
});
res.ribbon.fontFamilies = {};
reorganizeFontFamilies.forEach(function (item, index) {
    res.ribbon.fontFamilies['ff' + (1 + index)] = item;
});
GC.Spread.Sheets.Designer.setResources(res);
var designer = new GC.Spread.Sheets.Designer.Designer("dss");</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441076" alt="img" title="img" loading="lazy"/></p><h4>3、执行命令</h4><p>通过下面的代码，打开文件菜单</p><pre><code class="JavaScript">var command = GC.Spread.Sheets.Designer.getCommand("fileMenuButton");
command.execute(designer);</code></pre><p>通过下面的代码，关闭文件菜单</p><pre><code class="JavaScript"> var command =  GC.Spread.Sheets.Designer.getCommand('fileMenuPanel')
 command.execute(designer, "activeCategory_hide", true)</code></pre><p>以上就是 SpreadJS 设计器定制的核心实战内容，从界面认知到 Ribbon 功能区菜单、上下文菜单、SidePanels 等核心模块的定制，再到主题切换、中文字体添加等拓展配置，基本覆盖了设计器个性化改造的关键场景。这些实战方案基于 SpreadJS 的原生 API 与配置逻辑，兼顾了功能实现与落地实用性，能帮助你快速适配表格权限管控、界面风格统一等实际业务需求。</p><p>若需进一步深化定制，可结合 API 文档细化命令逻辑，或根据具体场景调整配置参数。希望这份文档能为你的开发工作提供有效支撑，助力高效完成 SpreadJS 设计器的个性化改造与落地。</p><h3>学习资料：</h3><p>学习指南：<a href="https://link.segmentfault.com/?enc=yRgc6axKL0t7%2BAhL%2B6ugyw%3D%3D.4hNmB38ZpDIaab59Q20dwAKUDEe51YFBlQ5H2Umfz8Fq%2FvYJX%2BuE1wDAuZGwvcnevpOWE7v3KNS1jVD8WQoTCQ%3D%3D" rel="nofollow" target="_blank">https://demo.grapecity.com.cn/spreadjs/SpreadJSTutorial/</a></p><p>产品文档：<a href="https://link.segmentfault.com/?enc=s%2B1ILmjECwyMGADeyzsPvA%3D%3D.U36r6IOnC%2F4KqsLHXKb6kBJREhwekTj2XDpScmmEa%2BbwsAnr%2FrlMVMg1wdNBM%2BBr8llYLtffAERz1HmiBKyfyA%3D%3D" rel="nofollow" target="_blank">https://demo.grapecity.com.cn/spreadjs/help/docs/overview</a></p><p>产品首页：<a href="https://link.segmentfault.com/?enc=PTsKaM5a4HqIBGT5d9qI9w%3D%3D.FVibQ8XiWc4GX3abP%2F8Umsbh%2FvRfMf1QWOXBcpDXFXxndEy3J1d9OVJwuIsQbNEQ" rel="nofollow" target="_blank">https://www.grapecity.com.cn/developer/spreadjs</a></p><p>在线Excel:<a href="https://link.segmentfault.com/?enc=MtTOFAPZ%2FSAxTMl29bo%2BPw%3D%3D.2C21j%2FAO%2B0Rrz622XAZ8RF0NUWr0n80V1nisjZXYf1eysdte24%2BV4JW3ggf%2Fzz8sdCQuvXNgFpAWFe72sJzqHw%3D%3D" rel="nofollow" target="_blank">https://demo.grapecity.com.cn/SpreadJS/WebDesigner/index.html</a></p>]]></description></item><item>    <title><![CDATA[CAD测量时捕捉不到点怎么办？ 酷酷的板]]></title>    <link>https://segmentfault.com/a/1190000047441139</link>    <guid>https://segmentfault.com/a/1190000047441139</guid>    <pubDate>2025-12-01 15:03:42</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>浩辰CAD看图王电脑版为用户提供了非常方便的各种测量功能。结合捕捉、记录、比例、单位等功能，可快速在电脑上测量CAD图纸中的距离、面积、坐标、半径等等，方便按图施工。但是有些画图朋友表示在测量的时候没有找到捕捉功能，导致测量困难，这是哪里出了问题呢？其实很简单，只需要我们在“编辑模式”下打开“捕捉”功能就可以了。浩辰CAD看图王电脑版的捕捉功能只有在编辑模式下才会显示，在编辑模式下打开捕捉功能之后切换到览图模式，捕捉功能依然存在哦！01 测量无捕捉：打开图纸，选择测量功能的时候在界面上没有捕捉到交点。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047441141" alt="图片" title="图片"/><br/>当我们在打开在浩辰CAD看图王电脑版中打开CAD图纸的时候，系统默认为览图模式，进行测量的时候发现并没有捕捉到交点。02 调出捕捉功能：在编辑模式下打开捕捉功能。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047441142" alt="图片" title="图片" loading="lazy"/><br/>在界面左上角将“览图模式”切换至“编辑模式”，在界面下方就出现了“捕捉”，点击打开“捕捉”功能，再进行测量的时候就能看到捕捉点了。03 捕捉功能保留：捕捉功能打开后，之后的测量中始终存在。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047441143" alt="图片" title="图片" loading="lazy"/><br/>捕捉功能一旦被打开，再次切换到览图模式进行测量的时候，捕捉功能依然存在。以上示例中我们使用的是“距离测量”功能，“捕捉”的点是“交点”，对于面积测量、坐标测量、半径测量等测量，以及捕捉端点、圆心、垂足等都是一样的方法。</p>]]></description></item><item>    <title><![CDATA[SpreadJS 电子表格权限管控设置指]]></title>    <link>https://segmentfault.com/a/1190000047441147</link>    <guid>https://segmentfault.com/a/1190000047441147</guid>    <pubDate>2025-12-01 15:02:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>SpreadJS 电子表格权限管控设置指南</h2><blockquote>电子表格作为企业数据存储、分析与协作的核心工具，常包含财务数据、客户信息、业务机密等敏感内容。一旦权限管控不当，可能引发数据泄露、误修改、版本混乱等风险。本节课我们将以 SpreadJS 为核心，从访问权限控制、数据安全控制、协作权限控制等维度，提供一套完整的权限管控实操指南。</blockquote><h2>一、访问权限控制</h2><blockquote>访问权限控制主要限制的是用户的操作权限，这里又细分为以下三种：</blockquote><h3>1、文件级权限 - 控制 "谁能打开文件"</h3><p>SpreadJS支持在导入和导出xlsx文件时使用密码进行加密和解密。</p><h4>API 设置</h4><p>导出示例：</p><pre><code class="JavaScript">let password = "spreadjs2023";
spread.export(blob =&gt; saveAs(blob, "encrypted-export.xlsx"), console.log, {
   fileType: GC.Spread.Sheets.FileType.excel,
   password: password
});</code></pre><p>导入示例：</p><pre><code class="JavaScript">spread.import(file, successCallback, error =&gt; {
   console.log(error.errorMessage, `Error Code: ${error.errorCode}`);
}, {
   fileType: GC.Spread.Sheets.FileType.excel,
   password: password
})</code></pre><h4>Designer UI操作</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441149" alt="img" title="img"/></p><h3>2、内容级权限 - 控制 "能修改哪些内容"</h3><h4>2.1 限制对工作表的编辑操作</h4><h5>表单保护</h5><blockquote>针对单个工作表，可禁止修改单元格内容、格式、插入删除行 / 列等操作，仅保留必要权限（如仅允许填写指定单元格）。</blockquote><h6>API设置</h6><pre><code class="JavaScript">sheet.options.isProtected = true;</code></pre><p>密码保护：</p><pre><code class="Java">var password = '&lt;user_input&gt;';
sheet.protect
(password);
// ...
if (sheet.hasPassword()) {
      var passwordUnlock = '&lt;user_input&gt;';
      var success = sheet.unprotect(passwordUnlock);
      // ...
} else {
      sheet.unprotect(); // or sheet.options.isProtect = false;
}</code></pre><h6>Designer UI操作</h6><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441150" alt="img" title="img" loading="lazy"/></p><h5>单元格锁定</h5><p>通过将 <strong>locked</strong> 方法设置为False，允许用户编辑受保护工作表中的特定单元格。</p><pre><code class="JavaScript">sheet.getCell(1,1, GC.Spread.Sheets.SheetArea.viewport).locked(false);
sheet.setValue(1,1,"unLocked");
sheet.getRange(-1,3, -1, 1).locked(false);
sheet.getRange(5, -1, 1, -1).locked(false);
sheet.options.isProtected = true;</code></pre><h5>单元格禁止编辑：</h5><p>使用 Style 类的 <code>allowEditInCell</code> 属性或 CellRange 类的<code>allowEditInCell</code> 属性禁用单元格编辑。默认情况下，该属性是启用的。</p><pre><code class="JavaScript">var sheet = spread.getActiveSheet();
// 使用 Style 类的 allowEditInCell 属性
var style = new GC.Spread.Sheets.Style();
style.allowEditInCell = false;
sheet.setStyle(1, 1, style);</code></pre><h5>公式隐藏：</h5><p>使用 Style 类的 hidden 属性或 CellRange 类的 hidden 方法来控制受保护工作表中公式单元格的可见性。默认情况下，hidden 属性设置为 false，表示公式不会被隐藏。</p><blockquote>hidden 属性在某些场景下非常有用，比如根据员工自评和主管评估生成 KPI 数据或年终奖金时，老板希望隐藏相关公式并保护评估系统。</blockquote><p>此代码示例使用 GC.Spread.Sheets.CellRange 类型中的隐藏方法：</p><pre><code class="JavaScript">activeSheet.options.isProtected = true;
activeSheet.setFormula(1, 3, "=SUM(10,20)");
activeSheet.getRange(1, 3, GC.Spread.Sheets.SheetArea.viewport).hidden(true);</code></pre><h4>2.2 隐藏敏感内容：仅显示必要信息</h4><h5>工作表选项卡：</h5><pre><code class="JavaScript">// 通过设置 tabStripVisible 控制是否显示工作表标签。
spread.options.tabStripVisible = false;
// 将 tabNavigationVisible 设置为 false 可以隐藏导航箭头按钮（默认显示）
spread.options.tabNavigationVisible = false;
//设置 newTabVisible 选项，可以允许或禁止用户通过点击"+"按钮添加工作表（默认显示）。
spread.options.newTabVisible = false;
// 通过 allSheetsListVisible 选项控制"≡"按钮是否可见
spread.options.allSheetsListVisible = GC.Spread.Sheets.AllSheetsListVisibility.auto;</code></pre><h5>sheet可见性：</h5><ul><li>hidden：工作表标签被隐藏，等于false。</li><li>visible：工作表标签可见，等于true，为sheetTabVisible的默认值。</li><li>veryHidden：工作表选项卡深度隐藏。</li></ul><pre><code class="JavaScript">// 隐藏sheet
sheet.visible(false);
// 深度隐藏一个工作表（这意味着它不能通过 UI 取消隐藏）
sheet.visible(SheetTabVisible.veryHidden);</code></pre><h5>隐藏行列头：</h5><pre><code class="JavaScript">// 是否显示行列头
sheet.options.rowHeaderVisible = false;
sheet.options.colHeaderVisible = false;</code></pre><h5>隐藏右键菜单：</h5><pre><code class="JavaScript">// 设置是否展示上下文菜单。
spread.options.allowContextMenu = false;</code></pre><h3>3、功能级权限 - 控制 "能操作哪些功能"</h3><blockquote>通过对在线表格编辑器（Designer）二次开发定制，可实现工具栏、上下文菜单、文件菜单等功能项的增删改操作。</blockquote><p>例如：</p><ul><li>开启表单保护后，工具栏部分button可用 （禁用状态）</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441151" alt="img" title="img" loading="lazy"/></p><ul><li>删除/禁用菜单项</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441152" alt="img" title="img" loading="lazy"/></p><ul><li>删除文件菜单-导入文件的入口</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441153" alt="img" title="img" loading="lazy"/></p><h2>二、数据安全控制</h2><blockquote><strong>数据验证</strong> 与<strong>条件格式</strong>的深度应用，能从 "数据输入合法性""风险可视化预警" 两个维度，为电子表格权限管理筑起更精细的安全防线。</blockquote><h3>数据验证</h3><blockquote>数据验证是电子表格 "权限管理前置化" 的关键手段 ------ 它能限制用户 "能输入什么数据"，从源头避免非法操作和数据污染，本质是对 "数据编辑权限" 的精细化管控。</blockquote><h4>1、下拉列表：锁定合法数据范围</h4><blockquote>通过设置下拉列表，可强制用户从预设选项中选择输入值，避免随意录入导致的数据混乱，同时也限定了 "谁能输入哪些内容" 的权限边界。</blockquote><ul><li><strong>场景</strong>：</li></ul><p>财务报销单的 "费用类型" 列，仅允许选择 "差旅费、办公费、招待费"；</p><p>HR 报表的 "员工状态" 列，仅开放 "在职、离职、试用期" 选项。</p><h4>2、 输入值范围限制：杜绝越权或错误输入</h4><blockquote>通过限定数值、日期的输入范围，可避免用户录入超出权限或逻辑范围的数据。</blockquote><ul><li><strong>场景</strong>：</li></ul><p>如 "采购单价" 列，限定输入范围为<code>0-1000</code>（防止录入负数或天价采购单）；</p><p>"员工年龄" 列限定<code>18-65</code>（符合劳动法逻辑）。</p><h4>3、 自定义公式验证：复杂场景的权限逻辑</h4><blockquote>对于更复杂的权限或数据逻辑，可通过自定义公式实现验证。</blockquote><ul><li><strong>场景</strong>：</li></ul><p>若 "发票金额" 列需小于 "合同金额" 列，可在发票金额单元格设置公式：<code>=B2&gt;A2</code>（B2 为发票金额，A2 为合同金额），仅当公式返回<code>TRUE</code>时允许输入。</p><h4>4、输入提示与错误警告：权限的可视化指引</h4><blockquote>为数据验证添加 "输入信息" 和 "错误警告"，可明确告知用户权限边界和操作规范。</blockquote><h3>条件格式</h3><blockquote>条件格式是 "权限风险的可视化雷达"------ 它能自动标记出越权、违规或高风险数据，让权限问题从 "隐藏" 变为 "直观可见"，便于管理员快速审计和干预。<br/>通过颜色、图标标记出超出权限或逻辑的数据，实现 "风险可视化"。</blockquote><ul><li><strong>场景</strong>：</li></ul><p>若某列 "客户等级" 仅允许 "普通、VIP"，而出现 "SVIP" 时，用红色填充单元格并标记警告图标。</p><h3>结合管理示例</h3><blockquote>将数据验证和条件格式结合，可形成 "预防 - 监控 - 审计" 的权限管理闭环。数据验证（预防非法输入）→ 条件格式（监控违规数据）</blockquote><ul><li><strong>场景：采购审批表</strong></li></ul><p>① 数据验证："采购金额" 列仅允许输入<code>0-5000</code>（普通员工权限），超出范围需经理审批；</p><p>② 条件格式：对 "采购金额\&gt; 5000" 的单元格标记为红色，并添加 "需经理审批" 的批注；</p><p>③ 结果：普通员工无法录入超 5000 的金额（预防），若因特殊情况录入（或经理录入），则自动标红提醒（监控），便于后续审计。</p><h2>三、协作权限控制</h2><blockquote>随着数字化转型加速，远程办公渗透率已超40%，跨地域、跨部门协作成为企业常态。传统电子表格管理面临版本混乱失控、协作效率低下、权限管控薄弱等问题。针对于此，SpreadJS 协同编辑插件提供全方位解决方案，让表格协作从混乱低效走向有序高效。</blockquote><h3>多人实时协作</h3><blockquote>打破单人编辑限制，实现多人实时协作，大幅提升团队效率：</blockquote><ul><li>支持团队多人同时编辑，操作实时同步无延迟</li><li>显示协作者光标与编辑状态，避免操作冲突</li><li>智能冲突解决，自动处理交叉编辑场景</li><li>编辑即时生效，无需手动刷新或文件上传</li><li>较传统模式提升协作效率60%以上，团队首选</li></ul><h3>全链路版本管理</h3><blockquote>告别"文件_v2_final"式的混乱命名，提供自动化版本管理：</blockquote><ul><li>生成版本快照，记录编辑人、时间与修改内容</li><li>可视化版本对比，清晰展示差异变化</li><li>一键回溯历史版本，杜绝数据丢失风险</li><li>支持版本命名与备注，重要节点一目了然</li></ul><h3>精细化权限体系</h3><blockquote>从整体到单元格的多维权限控制，兼顾数据安全与协作自由</blockquote><ul><li>支持单元格/行/列/工作表多级权限设置</li><li>灵活角色定义：查看者 vs 编辑者</li><li>动态权限调整，随需变更访问权限</li><li>敏感数据智能隐藏，未授权用户不可见</li><li>完整操作日志记录，变更轨迹一目了然</li></ul><p>在线体验地址：<a href="https://link.segmentfault.com/?enc=goX6JYDqlS9QWJDsH2ktpQ%3D%3D.BXLIpzr9%2FrssUDSoc8d4oTrss%2BJbJUegZNgoO7oSmy26ijBdrxXkunuLR8Rp3V6elb%2FhlGawrSDmiA9GIJrAJzJKxOY2vunEMgzB4O7w7pM%3D" rel="nofollow" target="_blank">https://demo.grapecity.com.cn/spreadjs/demos/collaboration/login</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047441154" alt="img" title="img" loading="lazy"/></p><h2><strong>结语</strong></h2><p>在数据价值日益凸显的今天，电子表格作为企业数据流转的核心载体，其权限管控已成为数据安全体系的重要一环。希望本文的指南能为读者带来帮助，让电子表格在安全可控的前提下，充分发挥数据存储、分析与协作的核心价值，成为支撑业务高效运转的可靠工具。</p><h3>扩展链接</h3><p>学习指南：<a href="https://link.segmentfault.com/?enc=iax9atBflJNVkpHQptAwJQ%3D%3D.uqvhDxXxuq1GE99jZKlrLuOjVuyot6IHgnuowCQNQiFDez7M1FhhdpNYJOMooCsrQJFwCHQrSokDRWX8sAGnPA%3D%3D" rel="nofollow" target="_blank">https://demo.grapecity.com.cn/spreadjs/SpreadJSTutorial/</a></p><p>产品文档：<a href="https://link.segmentfault.com/?enc=TEj8u1XE9QSX5ox8t11HfA%3D%3D.loeBHGtitWMI1AD5%2BndD8M1k0uHAef5UFyinudRS7EafQtdjPm2NnR7r7RV6z0WKYDio0WrzmkI1oydfHWxvbw%3D%3D" rel="nofollow" target="_blank">https://demo.grapecity.com.cn/spreadjs/help/docs/overview</a></p><p>产品首页：<a href="https://link.segmentfault.com/?enc=MkKuaw4qF3Fbk8s3y1ZkvQ%3D%3D.RBasJXXdwH1bgpScocT8ZsTxc3NWyECMPVtsFy%2FQQb5co5SUmJZkeVxlgi%2BcW1Of" rel="nofollow" target="_blank">https://www.grapecity.com.cn/developer/spreadjs</a></p><p>在线Excel：<a href="https://link.segmentfault.com/?enc=pjpstTL6IUiSsyCnBN58HA%3D%3D.tdcDnVw8iKXJke0e1h2k0FM8yeGrvxoHeNDBjZ3q8AWWrPMbe7z7was6cR9BPKNGIuYtu9IDyVzcL9coFi4ctg%3D%3D" rel="nofollow" target="_blank">https://demo.grapecity.com.cn/SpreadJS/WebDesigner/index.html</a></p>]]></description></item><item>    <title><![CDATA[低代码≠低安全：深度揭秘活字格如何筑牢你]]></title>    <link>https://segmentfault.com/a/1190000047441167</link>    <guid>https://segmentfault.com/a/1190000047441167</guid>    <pubDate>2025-12-01 15:02:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>低代码≠低安全：深度揭秘活字格如何筑牢你的业务“防火墙”</h2><p>在数字化转型的浪潮中，低代码平台凭借其高效开发能力成为企业构建数字生态的利器。然而，一个危险的误区正在蔓延——"低代码=低安全"。活字格低代码平台以全栈安全架构打破这一认知，从网络层到数据层、从开发流程到运维体系，构建起覆盖业务全生命周期的立体防护网。本文将以六大维度拆解活字格如何通过系统性安全设计，为企业打造坚不可摧的数字堡垒。</p><h3>一、构筑应用安全基石：HTTPS与会话防护</h3><ol><li>HTTPS强制加密传输</li></ol><ul><li>核心价值：通过SSL/TLS协议实现端到端加密，彻底阻断数据明文传输风险（如账户凭证泄露、敏感业务数据被截获）。</li><li>风险警示：未启用HTTPS将触发浏览器安全策略（如Chrome SameSite Cookie限制），导致跨域请求失败、会话异常等问题。</li><li>操作指南：管理控制台 → 安全设置 → 启用HTTPS（需绑定SSL证书）🔗 <a href="https://link.segmentfault.com/?enc=6XpIJMx%2F0GMqbDMRhEB8bg%3D%3D.TGtLxHI73CzrDFSeBu0zWQFC6mA18PF9%2Bkr88v5Hw9kmTasWpc6PGgFYebC4JbyvVLfcwT%2FKCB%2BAmPxxraQeMXOyBLn0RvRvCqNzJnF9sjdIbO3OZ1eBLixq%2ByBbcjhw" rel="nofollow" target="_blank">[SSL证书配置手册</a>]</li><li>HTTP响应头安全加固</li><li><p>防御矩阵：</p><ul><li><code>X-Frame-Options</code>：防范点击劫持攻击（iframe嵌套劫持用户操作）</li><li><code>X-XSS-Protection</code>：启用浏览器内置XSS过滤器</li><li><code>Content-Security-Policy</code>：限制非授权脚本加载</li></ul></li><li>配置路径：安全设置 → 自定义HTTP响应头🔗 <a href="https://link.segmentfault.com/?enc=a%2FBtIoBrrNsPvk%2FCHc3hwA%3D%3D.D0wIstDlir%2Bq5QYhkQcIRBcttYpqVPYAlOfRLAIEjRhjdekjMxvoAuYcgNMOzs4r4u96acTyEaUVtynzAeF72w%3D%3D" rel="nofollow" target="_blank">[响应头配置示例</a>]</li><li>智能会话管理</li><li>动态防护：默认120分钟无操作超时机制，结合令牌刷新策略降低会话劫持风险。</li><li>扩展建议：对高敏感业务模块（如财务审批）可单独设置更短会话超时阈值。</li></ul><h3>二、多维度访问控制：从IP到身份的精准防御</h3><ol><li>IP黑白名单策略</li></ol><ul><li><p>场景适配：</p><ul><li>白名单：限定办公网络IP段访问核心业务系统（如ERP、CRM）</li><li>黑名单：实时拦截已知攻击源IP（如恶意爬虫、暴力破解尝试）</li></ul></li><li>配置支持：CIDR格式输入 + 动态IP库更新🔗 <a href="https://link.segmentfault.com/?enc=CG0bKO6KZpciIjS9B8oC7A%3D%3D.NqWI%2FQFlJfJQFhX5wZKb2iP%2F6VraVQg26OeiD8cLcXF9QR%2B3XlMz1zw6By7%2B3NsWe9S21fIjugR8Hnr0AMkw0hQdG9oA%2FOuIWEbfUiVS9EHW7JQAHgtrVnDg%2FPKD4KaCVybfA%2BbBC5grVNm6AWojvaaP3R8L8W7%2FV5uN1iSc%2F8I%3D" rel="nofollow" target="_blank">[IP规则配置指南</a>]</li><li>跨域请求防护（CORS）</li><li><p>三重验证：</p><ul><li>Referer白名单：拒绝非授权来源的资源请求</li><li>域名校验：通过SAMEORIGIN策略阻止恶意站点嵌套</li><li>请求头过滤：限制非标准Header字段注入攻击</li></ul></li><li>安全策略：默认DENY模式，按需开放最小必要域</li><li>第三方登录体系</li><li>零密码风险：通过OAuth2.0协议对接企业微信、钉钉等认证体系，实现单点登录（SSO）。</li><li>智能联动：用户在第三方平台登录后，活字格自动完成身份验证，避免重复登录攻击。</li></ul><h3>三、数据防护体系：从存储到传输的全链路安全</h3><ol><li>敏感文件存储策略</li></ol><ul><li><p>推荐方案：</p><ul><li>云存储：集成阿里云OSS/腾讯云COS，通过RAM角色临时密钥访问</li><li>本地NAS：配置SMB加密协议，限制文件目录访问权限</li></ul></li><li>风险规避：禁止将文件直接存储于应用根目录，防止路径遍历攻击。</li><li>流量洪峰防御</li><li>云原生防护：活字格云服务内置DDoS清洗引擎，自动抵御百万级请求攻击。</li><li>私有部署方案：通过安全组策略限制开放端口（如仅保留22345业务端口），结合WAF规则过滤异常请求。</li><li>数据库访问隔离</li><li><p>防御架构：</p><ul><li>活字格服务器作为唯一入口，禁止前端直连数据库</li><li>采用连接池技术 + SQL注入过滤器，阻断恶意查询</li></ul></li><li>安全建议：为外联数据库创建专用账号，限制其操作权限（如仅允许SELECT/INSERT）。</li></ul><h3>四、开发与部署规范：安全左移实践</h3><ol><li>最小权限原则</li></ol><ul><li><p>实施要点：</p><ul><li>禁用匿名用户访问敏感操作（如数据导出、流程审批）</li><li>强制密码策略：12位以上混合密码 + 90天周期更换</li></ul></li><li>风险提示：默认账户权限未及时回收可能导致越权操作。</li><li>应用资产保护</li><li>工程加密：发布前启用"另存为加密工程"功能，绑定服务器许可证文件（.lic）</li><li>反编译防御：通过代码混淆技术保护业务逻辑，防止工程文件被盗用。</li><li>渗透测试标准</li><li><p>必做项：</p><ul><li>使用Burp Suite进行OWASP Top 10漏洞扫描</li><li>验证CSRF防护有效性（如Token验证机制）</li></ul></li><li>高危行业建议：金融/政务类应用需通过国家信息安全漏洞库（CNNVD）认证。</li></ul><h3>五、企业级安全增强：定制化防护方案</h3><ol><li>云服务安全增强包</li></ol><ul><li><p>核心能力：</p><ul><li>端到端加密：TLS 1.3协议 + 密钥定期轮换</li><li>容灾备份：多可用区部署 + 秒级故障切换</li><li>7×24安全监控：基于AI的异常行为检测（如高频登录失败告警）</li></ul></li><li>企业认证体系集成</li><li><p>扩展接口：通过实现<code>ISecurityProvider</code>接口，无缝对接：</p><ul><li>活动目录（AD）</li><li>轻量级目录访问协议（LDAP）</li><li>企业自建IAM系统</li></ul></li><li>开发支持：提供SDK与API文档🔗 <a href="https://link.segmentfault.com/?enc=TaqMbU%2FYO%2BjWh7QT%2FpTcbQ%3D%3D.D8EdM5%2FAoXxmdUQNw26JLa8mEmmAvFulnt2YHXwk9D3%2F0dEenlj7xkA9sNuSytCc4Hh0wn28bnRWmTmf%2FtbInP%2FxbFcwFzGtMLoEnJH908NG6VJTkB%2BMiO56LCXaDCjrz4%2B3PttnIznm8Z3QsvN8F1ExoOggaFoUeNk6FesM89c%3D" rel="nofollow" target="_blank">[认证接口开发指南</a>]</li></ul><h3>六、持续安全运营：从防御到进化</h3><ol><li>安全审计机制</li></ol><ul><li><p>月度报告：自动生成安全巡检日志，涵盖：</p><ul><li>登录行为分析（如异地登录预警）</li><li>权限变更记录（如角色分配/撤销）</li><li>异常操作追踪（如批量数据导出）</li></ul></li><li>版本安全迭代</li><li><p>10.1版本强化项：</p><ul><li>默认启用CSP（内容安全策略）</li><li>新增Web漏洞自动修复模块</li><li>优化第三方组件安全扫描</li></ul></li></ul><h3>七、实施路径全景图</h3><p>所有安全配置均通过统一管理控制台完成： <code>管理控制台 → 设置 → 安全设置</code>🔗 <a href="https://link.segmentfault.com/?enc=8zpy19BQgmXeZ%2BMwgQCrRQ%3D%3D.0quI%2B%2BtRAFqIO2s7gOxcnogHpaZ1Fae7EFyNdNaXnwjwJTYbe0rZnziw0EoJ2IHZZj9olYkyaQTNdGmNMBeQbm5IDTMpWDUKGqFfdUMRyNNCZcB2hW7m4BwtATteukz5" rel="nofollow" target="_blank">[直达配置界面</a>]</p><p>结语</p><p>活字格低代码平台以安全为设计基因，通过技术防护与管理规范的深度融合，重新定义了低代码时代的安全边界。在数字化转型的进程中，唯有将安全深度嵌入每个开发环节，方能实现真正的"业务创新"与"风险可控"双赢。选择活字格，就是选择了一个既快速又安全的数字化未来。</p>]]></description></item><item>    <title><![CDATA[开源AI正处在艰难的过渡期 灰常酷的领带]]></title>    <link>https://segmentfault.com/a/1190000047441172</link>    <guid>https://segmentfault.com/a/1190000047441172</guid>    <pubDate>2025-12-01 15:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>有些企业，做着做着开源就变成闭源了，比如：Meta暂停Llama模型“Behemoth”的测试工作，集中资源开发闭源模型;有些企业做着做着闭源，中途却又改道开源，比如： OpenAI 在今年开源了 GPT-oss 模型;还有一些企业，开源和闭源“两条腿”走路，比如：谷歌、微软、阿里、腾讯等大厂，既有开源模型，又有闭源模型。</p><p>到底选择开源?闭源?还是都选?本质上，都可以归为是战略选择问题。不管是哪种方式，技术路线本身没有对错。从性能追赶来看，开源与闭源的界限正在变得模糊，开源模型的性能正在逼近闭源模型，阿里的Qwen3、DeepSeek的R1等开源模型已与Claude 4、GPT-4.1等闭源模型比肩，甚至实现反超。从模型能力来看，多模态、强化推理和MoE架构等几个关键技术能力，正在推动AI应用的加速落地。</p><p>在技术发展呈螺旋式上升过程中，开源AI给世界发展带来的推动作用，有目共睹。不管是Meta的Llama系列、Stability AI的Stable Diffusion，还是DeepSeek的发布……这些大模型之所以能快速“破圈”，是因为他们带来了技术普惠的“飞轮效应”，让全球开发者在集体智慧之上，再上新台阶。</p><p>开源，不仅大幅降低了人工智能的技术门槛，更以强大的协同效应倒逼行业加快创新步伐，推动整个生态进入高速迭代的新阶段。注意，这个“生态”不只是模型应用层，还包括模型的开发、部署，数据和算力的管理等AI Infra层面的改变。</p><p>为进一步推进开源AI 生态的繁荣发展，弘扬开放、协作共享的创新精神，ITPUB在【IT风向标】系列直播活动中，特别邀请 了AI 领域两位重磅专家，共同探讨开源 AI 的现状、挑战与未来趋势。一位是红帽亚太 CTO 办公室首席架构师张家驹;另一位是Zilliz的合伙人&amp;研发VP栾小凡。两位嘉宾一致认为，开源与闭源之间，从来就不是“非黑即白”的选择。</p><p>当DeepSeek用开源挑战巨头，当等大厂们既拥抱开源又保留闭源，当企业用户在安全与成本间做出适合自己的选择，我们看到的是——一个正在重构的AI生态。</p><p>在过去一年里，中国开源AI表现出强劲发展势头。一份源自The Atom Project的全球模型追踪数据显示，2025年10月中国开源模型的下载量攀升至约5.5亿次，美国同类产品为4.75亿次。一家评测机构指出，评分最高的10个开源模型中有8个来自中国，而且未来中国的领先优势还将扩大。</p><p>在开源AI繁荣发展的背后，也面临着一些挑战，诸如：信任度、开放性，还有盈利能力等。那么，问题来了，在消灭技术边界这场“战争”中，到底哪些地方存在“槽点”或者“卡点”?很明显，安全问题是第一个挑战!</p><p>01</p><p>开源AI可信吗?</p><p>开源是把“双刃剑”，当开发者获得开放透明的代码，意味着所有人对你的应用了如指掌，很容易被植入恶意代码，使得私域数据被公开。外加Cursor、Claude封禁API等事件，都在加剧这种不信任感。</p><p>尤其是企业级应用场景，安全是“生命线”，没有半点退让的可能!那么，就模型应用而言，到底是开源更安全，还是闭源更安全?</p><p>“使用闭源API，整个应用是个黑盒，一旦出现问题，你对数据安全无法把控。既然这样，那是不是要把企业数据都拿出去?开源模型又会面临新的安全隐患!” 栾小凡指出，企业应用通常会面临两难处境。</p><p>与模型发展不相匹配的是，使用开源模型还有一个巨大的“鸿沟”，我们没有一个“Benchmark “可以像评测模型一样，去评估模型本身的安全性。“模型投毒”已成为一个事实威胁，如果用户在预训练时掺杂了恶意数据，在评估过程中没有被及时发现，会对产出结果产生很大影响。</p><p>所以，大模型被推出后，很多企业更愿意以私有化的方式去部署。在这一过程中，模型本身是否开源似乎不再那么重要。当然，针对“模型投毒”这样的问题，即便是私有化部署，也只能解决部分问题。</p><p>“当模型能力逐渐同质化，推理引擎(vLLM、SGLang)、RAG框架、向量数据库(如Zilliz)、路由分发系统才是开源的真正主场，这又落回到了传统意义上的基础设施层面，” 张家驹发现，在私有化场景，基础设施的成熟度、稳定性和易用性，反而成为了决定AI落地的关键因素，而不在于是否开源，重要的是整个基础设施是建立在开源生态之上。</p><p>从这个角度来看，开源AI是否可信，就落脚到更细分的维度。一个是数据敏感程度，核心业务数据是否允许出域;另一个是技术能力储备，是否有能力维护私有化部署;最后，是合规性，要能满足行业监管对透明性的要求。</p><p>张家驹还揭示了一个令人尴尬的现象，在当前环境下，完全开放的开源模型的创新优势似乎并不像想象中的那么明显。但长远看，真正的开源一定是闭源模型的最有力补充。</p><p>02</p><p>如何看待“开放权重”模型?</p><p>拥抱开源AI虽然是大趋势，但在技术路线部署上，会有分叉，也会有趋同!</p><p>“开源的魅力在于，你可以站在巨人的肩膀上看世界，能基于别人的代码去做修改。但现在的开放权重模型，本质上别人很难再做创新。”</p><p>张家驹提出了一个尖锐问题：这种“非全过程开源”，真的能带来传统开源软件的创新红利吗?红帽怀揣着一个乌托邦式的梦想：从数据准备、模型训练到持续迭代，全过程开源。这才是真正的“技术平权”!然而，“理想很丰满，现实却很骨感”，现在的主流开源模式，更多是开放权重，而非全过程开源。</p><p>新趋势背后，是一个略显悲观的判断。栾小凡认为，造成这种现象的根本原因是，“大模型发展到现在可能进入到一个瓶颈期。未来，我们会看到越来越多的微创新出现，至于下一个Scaling law在哪里?目前我们还没有看到!”</p><p>目前，开源AI正处在艰难的过渡期。当下的“开放权重”模式，或许是一种必要的妥协。既让更多人能够使用先进AI技术，又保护了开发者的商业利益。更多人的目标，是一个“卖铲子”的逻辑，希望通过模型去吸引用户。尤其是一些大厂和云厂商，可以通过开源带生态，推动硬件或者云资源的使用。</p><p>对比来看，开源AI其实和互联网的发展脉络一样，从只有巨头玩得起的“大机时代”，到走向人人可参与的“PC时代”，还需要技术的持续突破和成本的不断下降。正如张家驹所说：“随着时间推移，也许会有变化。当技术门槛足够低，当算力成本足够亲民，真正的开源AI时代才会到来。”</p><p>从长远发展来看，当训练和推理成本在模型部署中占“大头”，开源的优势将更加明显，我们会看到越来越多更好用的开源模型。</p><p>03</p><p>开源商业化，背后逻辑是什么?</p><p>开源不等于免费!当开源遇上AI，一个来自灵魂深处的发问索绕心头——那就是这玩意到底怎么赚钱?当大厂们纷纷拥抱开源，当创业公司在开源道路上艰难前行，商业化成为了最现实的考验。</p><p>放眼市场，栾小凡直言不讳地指出了开源AI商业化的两条路径：</p><p>第一条路，“挂羊头卖狗肉”。开源本身不直接赚钱，但能拉动其他业务。</p><p>以云厂商的开源模式为例，做模型这件事情并不挣钱，但是能拉动云资源的使用，并且未来还会是一个很大的“盘子”。</p><p>同样，一些硬件企业也是这种“套路”，比如：英伟达就是这条路径的典型代表。无论是推理框架，还是大家耳熟能详的Triton、TensorRT核心AI加速工具，所有动作，本质上都在帮他解决同一个问题：卖卡。</p><p>英伟达的这套逻辑在于，把软件堆栈做好，最终通过软件带动硬件销售。在这个游戏里，开源是手段，硬件销售才是目的。</p><p>第二条路，开源产品本身商业化。根植于生态，通过托管服务和企业级支持变现。</p><p>这种“打法”的差异点在于，开源产品本身其实就是为了去吸引更多用户，把开源生态打磨好，吸引一部分不想自己去维护复杂工程体系的用户，或者对稳定性有更高要求的用户。</p><p>比如：向量数据库技术的开创者Zilliz，不仅拥有全球最受欢迎的开源向量数据库Milvus，还推出了基于 Milvus 的全托管云服务 Zilliz Cloud，这是一条基于开源产品构建云平台体系的成熟路线，已经得到Databricks、MongoDB等知名企业的可行性验证。</p><p>与上述路线不同的是，作为开源界的“老兵”，红帽的生存哲学，只有一条，那就是做好“脏活苦活累活”。</p><p>“软件的价值不仅仅是闭源软件提供的license，还包括你在使用过程中的一系列后续问题，包括用户需要的补丁、安全更新、问题处理、技术培训，这些价值也需要有人来提供。”</p><p>让广泛使用的开源软件在企业生产场景中用好，红帽用这套模式打造了三大产品线，包括Linux操作系统、OpenShift容器云平台和Ansible自动化工具。如今，为了满足AI这种“新型工作负载”，红帽又在努力让K8S更好地支持AI，包括在推理引擎社区上进行大力投入。</p><p>远离光环，贴近地面。在开源路线战略布局过程中，红帽只选择做“关键贡献者”，只贡献“20%-30%”，但能为最终用户提供100%的支持服务。如果一家企业开源贡献是100%，那非常容易走着走着就闭源;但如果你的开源贡献是0，那在别人的潜意识里，你就是一个集成商，根本没有深度服务的能力。所以，红帽只做关键贡献，把精力放在可能遇到的各种问题上，虽然做了很多 “苦力活”，但这种务实的理念，却也探索出一条开源商业化的正确路径。</p><p>04</p><p>结语</p><p>展望未来，开源AI的发展，将是一个分裂而繁荣的生态。</p><p>分裂体现在技术栈的分层：底层基础设施几乎完全开源，上层应用百花齐放;小模型开源，大模型闭源;通用能力开源，专属能力闭源。</p><p>就AI Infra而言，开源的前景一片光明。这种信心来自于开源独特的反馈循环——更多的用户使用，更多的反馈汇聚，更快的产品迭代。这种weibo.com/ttarticle/p/show?id=2309405238984162017296 weibo.com/ttarticle/p/show?id=2309405238984543699071 weibo.com/ttarticle/p/show?id=2309405238984942420265 weibo.com/ttarticle/p/show?id=2309405238985445474490 weibo.com/ttarticle/p/show?id=2309405238985848389769 weibo.com/ttarticle/p/show?id=2309405238986238197887 weibo.com/ttarticle/p/show?id=2309405238986645045449 weibo.com/ttarticle/p/show?id=2309405238987043504171 weibo.com/ttarticle/p/show?id=2309405238987534499933 来自真实场景的反馈，成为AI基础设施不断进化的燃料。从向量数据库到推理框架，从训练调度到Agent开发工具，开源正在重演Linux时代的胜利。这或许就是AI时代最朴素的真理——技术路线会变迁，商业模式会演化，但为用户创造价值的能力，才是真正的“杀手锏”。</p>]]></description></item><item>    <title><![CDATA[隐语——数据要素流通技术MOOC三期 课]]></title>    <link>https://segmentfault.com/a/1190000047440236</link>    <guid>https://segmentfault.com/a/1190000047440236</guid>    <pubDate>2025-12-01 14:13:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><p>课程地址：<a href="https://link.segmentfault.com/?enc=0jK4i8ZDkZi1an%2F4TZsjeg%3D%3D.L97bzJKmKpxgtYGi6AshK9BC67%2BIcgDU7KWiuslMlDM1dCnJQNI%2F1NqCH2AQIdv9jpg3UR5SlbhIVfXy4mmHJSsu%2BwxMjnd5whYkec45DYUPUzbHe%2FkVPXPUPZVCOlKY6Jul5CcDblJ0rihZLjqttw%3D%3D" rel="nofollow" target="_blank">https://www.secretflow.org.cn/community/bootcamp/2narwgw4ub8r...</a></p><p><strong>讲师</strong>：贾明阳（蚂蚁密算科技）  <br/><strong>核心框架</strong>：背景知识 → 连接器功能 → 技术架构</p></blockquote><h2>一、背景知识：可信数据空间与国家数据基础设施</h2><h3>1. 国家数据基础设施核心节点</h3><table><thead><tr><th>节点类型</th><th>核心定位</th><th>关键功能</th></tr></thead><tbody><tr><td>权域功能节点</td><td>全局统一管理</td><td>统一标识管理、统一身份管理、统一目录管理（三统一）</td></tr><tr><td>区域功能节点</td><td>特定区域服务</td><td>身份注册/核验、数据登记、目录查询、标识解析、运行监测</td></tr><tr><td>行业功能节点</td><td>特定行业服务</td><td>与区域功能节点功能一致，仅服务范围为特定行业</td></tr><tr><td>业务节点</td><td>数据流通利用平台</td><td>数据采集、加工、交易、开发等，是可信数据空间的核心载体</td></tr></tbody></table><h3>2. 可信数据空间的定位与组成</h3><ul><li><strong>核心定位</strong>：作为国家数据基础设施的<strong>业务节点</strong>，实现跨区域/行业的数据可信流通。</li><li><p><strong>两大核心组件</strong>：</p><ol><li><p><strong>可信数据空间服务平台</strong>：</p><ul><li>遵循“三统一”要求，与权域/区域/行业功能节点互联互通。</li><li>可复用其他业务节点功能（交易、托管、存证审计等），支持功能扩展。</li><li>对接关系：向上→行业/区域功能节点；横向→其他业务节点；向下→接入连接器。</li></ul></li><li><p><strong>接入连接器</strong>：</p><ul><li>核心定位：用户（数据提供方/使用方）接入服务平台的入口，访问数据资源的桥梁。</li><li>合规要求：遵循NDITR相关文件，在国家数据基础设施接入连接器基础上扩展5大独有功能。</li></ul></li></ol></li></ul><h2>二、接入连接器的核心功能（六大模块）</h2><h3>1. 身份管理</h3><ul><li><strong>核心目标</strong>：实现连接器与节点、连接器之间的可信身份认证。</li><li><p>关键子功能：</p><ul><li>用户身份管理：用户名/密码登录、用户CRUD、角色权限配置。</li><li>连接器身份注册：向功能节点申请→审批→分配ID→生成CSR文件→获取CA证书→配置到连接器。</li><li><p>双向认证流程：</p><ul><li>连接器↔功能节点：连接器发送身份标识+私钥签名→功能节点通过CA验证→功能节点返回自身证书→连接器验证。</li><li>连接器↔连接器：A发送证书+签名→B通过CA验证证书合法性→B用A的公钥验签→双方互验完成。</li></ul></li></ul></li></ul><h3>2. 数据资源管理</h3><ul><li><strong>数据资源定义</strong>：具有利用价值的电子化数据集合（可社会化复用）。</li><li><p>关键子功能：</p><ul><li>数据资源接入：支持对象存储（S3、MinIO）、数据库、本地文件、SFTP等多数据源。</li><li>资源管理：本地数据资源的CRUD操作。</li><li>资源目录：按NDI标准生成目录，支持本地检索查询。</li></ul></li><li><p><strong>特色功能：密带托管</strong>：</p><ol><li>数据提供方将数据加密封装为“数据胶囊”；</li><li>托管至马尔米算密带研发平台；</li><li>平台内加工为数据产品并上架；</li><li>数据使用方通过合约申请使用。</li></ol></li></ul><h3>3. 数据产品管理</h3><ul><li><strong>数据产品定义</strong>：经实质性加工的可流通数据加工品/服务（如数据表、API、文件），是数据流通的基本单元。</li><li><p>关键子功能：</p><ul><li>产品封装：将数据资源加工为标准化数据产品。</li><li>产品上架：上传至服务平台→平台代理完成行业/区域节点登记→获取唯一标识。</li><li>产品目录：维护本地产品目录，支持检索与使用申请。</li></ul></li><li><strong>核心流程</strong>：数据资源→加工封装→上架平台→使用方查询→申请使用→合约签署→数据交付。</li></ul><h3>4. 数字合约管理</h3><ul><li><strong>数字合约定义</strong>：数字化描述的参与方承诺（含数据内容、使用方式、次数、范围等）。</li><li><p>关键子功能：</p><ol><li>合约创建：使用方发起申请→服务平台生成合约模板→下发至双方连接器。</li><li>合约协商：双方确认合约内容→达成一致后用本地私钥签名。</li><li>合约履约：按合约约定完成数据交付与使用。</li></ol></li><li><strong>生效条件</strong>：双方私钥签名完成→上报服务平台→平台下发生效合约→连接器验证签名合法性。</li></ul><h3>5. 数据交付</h3><ul><li>核心目标：按合约要求安全交付数据/计算结果。</li><li><p>关键子功能：</p><ul><li>交付数据处理：加密、脱敏、隐私保护计算（MPC）、数据沙箱等预处理。</li><li>数据传输：支持连接器间直接传输。</li><li>交付存证：记录处理/传输日志→上报服务平台存证审计系统，支持本地查验。</li></ul></li><li><p><strong>支持交付方式</strong>：</p><ol><li>密带API交付；</li><li>数据集直接交付；</li><li>隐私计算交付（基于SecretFlow、PSI等开源算子，支持多方安全计算）。</li></ol></li></ul><h3>6. 使用控制</h3><ul><li><strong>核心目标</strong>：确保数据使用符合合约约定（时间、地点、主体、行为等）。</li><li><p>关键实现：</p><ul><li>使用环境：提供安全软硬件环境。</li><li>控制策略：实时监测使用行为→校验合约限制（如使用期限、次数）→超出限制则终止使用。</li></ul></li><li><strong>核心逻辑</strong>：连接器从平台获取合约→交付过程中记录使用日志→实时校验合约约束→上报使用状态。</li></ul><h2>三、连接器技术架构（马尔米算实现）</h2><h3>1. 整体架构概述</h3><ul><li>架构模式：B/S架构，支持部署于K8s或轻量化K3s（70MB，便捷部署）。</li><li><p>核心交互：</p><ul><li>向上对接：可信数据空间服务平台、行业/区域功能节点。</li><li>横向交互：连接器之间通过Interguitave模块实现跨连接器请求转发与身份验证。</li><li>向下支撑：对接数据源（提供方）与数据使用方，拉起隐私计算等执行引擎。</li></ul></li></ul><h3>2. 核心模块职责（分层分类）</h3><table><thead><tr><th>分层/类别</th><th>模块名称</th><th>核心职责</th></tr></thead><tbody><tr><td>前端交互层</td><td>Web UI</td><td>浏览器端交互界面，支持点击/拖拉拽操作（如Dag画布编排）</td></tr><tr><td>网关层</td><td>API Gateway</td><td>接收HTTP请求→权限校验→请求转发→支持限流、熔断、链路追踪（Trace）</td></tr><tr><td>核心服务层</td><td>Connector Service</td><td>连接器登记、初始化、产品CRUD</td></tr><tr><td> </td><td>Contract Service</td><td>合约拉取、展示、签署（本地私钥签名）</td></tr><tr><td> </td><td>Dag Canvas</td><td>可视化任务流编排（拖拉拽算子，支持数据预处理、模型训练等）</td></tr><tr><td> </td><td>Project Service</td><td>项目管理（工作区Workspace），绑定合约、项目CRUD</td></tr><tr><td> </td><td>Contract Delivery</td><td>合约交付状态记录、上报服务平台</td></tr><tr><td>调度层</td><td>Scheduler</td><td>任务调度：将Dag画布转换为Task→按依赖关系执行</td></tr><tr><td> </td><td>CulTask</td><td>多方安全计算（MPC）协同调度，确保多方节点同步拉起任务</td></tr><tr><td>数据层</td><td>Data Site</td><td>数据资源CRUD、数据源接入、数据加密/处理</td></tr><tr><td> </td><td>Delocation Tool</td><td>数据封装为密带胶囊→托管至密带基础引擎</td></tr><tr><td>安全与审计层</td><td>Interguitave</td><td>跨连接器请求转发、身份认证握手、Token协商与验证</td></tr><tr><td> </td><td>Log Module</td><td>记录交付日志、操作日志</td></tr><tr><td> </td><td>Audit Module</td><td>日志上报、审计功能支持</td></tr><tr><td> </td><td>User Service</td><td>隐私计算用户管理（登录、角色权限、CRUD）</td></tr><tr><td>执行层</td><td>Executor Agent</td><td>执行任务代理，拉起隐私计算引擎（SecretFlow、PSI等算子）</td></tr><tr><td>部署层</td><td>K8s/K3s底座</td><td>部署载体，支持轻量化K3s快速部署</td></tr></tbody></table><h2>四、核心总结</h2><ol><li><strong>定位</strong>：接入连接器是可信数据空间的“入口枢纽”，连接数据提供方/使用方与服务平台，实现可信接入与数据流通。</li><li><strong>核心价值</strong>：合规（遵循NDITR标准）、安全（身份认证、加密、隐私计算）、灵活（多数据源接入、多交付方式）。</li><li><strong>技术亮点</strong>：支持隐私计算集成、轻量化部署、可视化任务编排、全流程日志存证。</li></ol>]]></description></item><item>    <title><![CDATA[隐语——数据要素流通技术MOOC三期 课]]></title>    <link>https://segmentfault.com/a/1190000047440242</link>    <guid>https://segmentfault.com/a/1190000047440242</guid>    <pubDate>2025-12-01 14:12:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>课程地址：<a href="https://link.segmentfault.com/?enc=SicNBim3ig%2F%2F1xwtXAeOrg%3D%3D.X75m1hKcK05HonRA05Ca2X9Vo%2Bet3ciYfXbeKNFRrd4LF55JE1gDU6e8kVQx%2FPvSUBDtd2lQKEx7UKpuAbwkaYyJb7nEubGrxTD8F8vGtURxBRZuZ5dlsjlukteZstSdMx0oWrpkscpm7bwIEIF9ng%3D%3D" rel="nofollow" target="_blank">https://www.secretflow.org.cn/community/bootcamp/2narwgw4ub8r...</a></blockquote><h2>一、课程核心框架</h2><ol><li>需求分析：数据要素流通的信任痛点</li><li>核心原理：远程证明的技术本质与信任链构建</li><li>标准与实现：ITS框架与星绽方案落地</li><li>实践案例：跨域管控的数据安全流通</li><li>未来展望：跨云统一证明与密算网络</li></ol><h2>二、引言：数据流通的信任核心问题</h2><h3>1. 数据的价值与安全矛盾</h3><ul><li>数据是数字经济核心生产要素，安全流通是价值释放的关键</li><li>数据跨实体传递时脱离原控制范围，需解决"可用不可见"的安全保障</li></ul><h3>2. 机密计算与远程证明的协同作用</h3><table><thead><tr><th>技术</th><th>核心功能</th><th>定位</th></tr></thead><tbody><tr><td>机密计算</td><td>创建可信执行环境（TEE），硬件隔离保护数据</td><td>提供数据安全使用保障</td></tr><tr><td>远程证明</td><td>验证连接对象是否为真实可信环境</td><td>确认保障的真实性</td></tr></tbody></table><ul><li>协同目标：实现"模糊信任→可验证信任"的转变</li></ul><h2>三、远程证明核心原理</h2><h3>1. 信任的起点：硬件根信任</h3><ul><li>信任基石：CPU/TPM中的<strong>熔断密钥</strong>（芯片出厂预置，不可导出）</li><li>信任链构建：通过权威机构（CA）的数字签名背书，形成"芯片固件→TEE→应用程序"的完整验证链条</li></ul><h3>2. 远程证明核心流程与角色</h3><h4>（1）核心角色</h4><ul><li>验证方：远程证明服务器</li><li>T节点：具备可信执行环境的硬件（如SGX、TPM、TDX等）</li><li>CA服务：权威认证机构，验证证书链有效性</li></ul><h4>（2）执行步骤</h4><ol><li>验证方向T节点发送随机制串（LUNS）</li><li>T节点生成度量环境报告，提交至可信硬件获取签名（Code）</li><li>T节点将报告发送至验证方</li><li>验证方调用CA验证证书链有效性，提取公钥验证报告签名</li><li>确认T节点为可信环境后完成授权</li></ol><h3>3. 分层架构模型</h3><table><thead><tr><th>层级</th><th>核心功能</th><th>关键标准/组件</th></tr></thead><tbody><tr><td>硬件层</td><td>生成原始度量报告</td><td>TPM、可信硬件芯片</td></tr><tr><td>协议层</td><td>定义标准化报告格式</td><td>ITS（国际标准框架）</td></tr><tr><td>云端服务层</td><td>报告处理与验证</td><td>远程证明服务器</td></tr><tr><td>应用层</td><td>消费验证结果，决策权限控制</td><td>SDK、业务系统</td></tr></tbody></table><h2>四、标准框架：ITS（International Trusted Computing）</h2><h3>1. 核心目标</h3><ul><li>打破技术隔阂，实现不同厂商TEE（Intel、AMD、华为等）的互操作</li><li>统一验证流程，整合零散方法为通用框架</li><li>为设备颁发"可信身份证"，解决"设备身份认证"问题</li></ul><h3>2. 三大核心角色</h3><table><thead><tr><th>角色</th><th>英文标识</th><th>核心职责</th></tr></thead><tbody><tr><td>证明者</td><td>Attester</td><td>在待验证设备上生成硬件级不可篡改报告（Report）</td></tr><tr><td>验证者</td><td>Verifier</td><td>验证报告真实性，签发标准化"健康证书"（EAT令牌）</td></tr><tr><td>业务系统</td><td>Relying Party</td><td>基于EAT令牌决策是否执行敏感操作</td></tr></tbody></table><h3>3. 落地基础设施要求</h3><ul><li>机密计算：提供安全可靠的TEE执行环境</li><li>信任底座：硬件级可信根（如TPM），保障信任链起点的可靠性</li></ul><h2>五、星绽方案实现：机密计算与远程证明服务</h2><h3>1. 星绽机密计算整体架构</h3><ul><li>自主研发数据保护方案，具备独立知识产权</li><li>核心价值：弥补国产CPU安全短板，降低使用成本，支持大规模复杂数据流转</li><li><p>三层架构：</p><ol><li>安全底座：底层安全虚拟化</li><li>安全操作系统：TE操作系统（自研）</li><li>可信技术设施：云原生TEE能力提供层</li></ol></li></ul><h3>2. 可信技术设施关键特性</h3><ul><li>云原生管理：结合机密虚拟机/容器，通过K8s统一管理TEE应用生命周期</li><li>信任链延伸：TE操作系统度量应用启动过程，将信任链从平台层扩展至应用层</li><li><p>核心服务双支柱：</p><table><thead><tr><th>服务名称</th><th>核心功能</th></tr></thead><tbody><tr><td>远程证明服务</td><td>验证TEE应用可信度，颁发可信身份</td></tr><tr><td>密钥管理服务</td><td>基于可信身份执行密钥授权策略，仅授权应用可获取密钥</td></tr></tbody></table></li></ul><h3>3. 信任链全流程实现（从硬件到应用）</h3><ol><li>TPM硬件可信根为起点，操作系统启动时将组件度量值写入TPM的PCR寄存器</li><li>加载驱动模块与虚拟化组件（Hypervisor），度量值同步写入PCR</li><li>Hypervisor启动后降级为非特权模式，作为机密虚拟机可信根，构建虚拟机启动链（内核、迷你行组件）</li><li>系统分区通过Device Mapper加密保护，根哈希由内核迷你行保障</li><li>应用容器启动时，通过MA机制完成完整性度量、审计与安全评估</li><li>容器通过远程证明验证平台可信度，信任链最终传递至应用层</li></ol><h2>六、星绽远程证明服务设计</h2><h3>1. 架构分层（微服务架构）</h3><table><thead><tr><th>层级</th><th>核心设计与功能</th></tr></thead><tbody><tr><td>核心层</td><td>动态插件化设计，兼容多TEE（HyperGlyph、Intel TDX、未来支持GPU认证），支持新增TEE插件</td></tr><tr><td>服务层</td><td>1. 基线策略管理：管理主机/平台/应用的认证基线，支持多版本；<br/>2. 身份管理：细粒度权限控制、审计追踪，统一EAT ID标识；<br/>3. 身份签发：基于硬件衍生密钥签发Token；<br/>4. 可信审计：记录运行日志与度量结果</td></tr><tr><td>接口层</td><td>提供基线注册、审计日志查询接口，支持组织/平台/应用三类证明者角色</td></tr></tbody></table><h3>2. 应用可信身份获取与验证流程</h3><h4>（1）身份获取步骤</h4><ol><li>应用A启动，通过Attesting Agent代理发起<strong>平台身份请求</strong>（采集平台度量值）</li><li>远程证明服务器验证平台报告，颁发JWT令牌（含公钥，由服务器报告担保防中间人攻击）</li><li>Attesting Agent缓存公钥，发起<strong>应用身份请求</strong>（报告含平台+应用度量值，平台报告担保应用报告）</li><li>服务器验证双报告与基线比对，颁发应用级JWT令牌，返回至应用A</li></ol><h4>（2）跨应用身份验证</h4><ol><li>应用A将业务数据+JWT令牌发送至应用B</li><li>应用B通过自身Attesting Agent调用验证接口，利用缓存的平台公钥验证JWT签名合法性</li><li>验证通过则执行敏感操作，失败则拒绝访问（抵御仿冒身份攻击）</li></ol><h2>七、实践案例：跨域管控的数据安全流通</h2><h3>1. 核心目标</h3><ul><li>确保密算平台环境可验证，数据/密钥在流通中全程受保护</li><li>抵御管理员及高特权软件的恶意攻击</li></ul><h3>2. 关键实现路径</h3><ol><li>硬件保障：可信硬件（TPM）保障平台可信启动</li><li>环境隔离：TEE保护数据计算过程的完整性与机密性</li><li>身份验证：远程证明服务验证平台/应用可信身份</li><li><p>加密传输：</p><ul><li>用户通过远程认证报告验证数字信封公钥合法性</li><li>对称密钥加密数据，公钥加密对称密钥，传输至密算平台</li><li>平台用私钥解密对称密钥，最终解密数据并处理</li></ul></li></ol><h2>八、未来展望：跨云统一证明与密算网络</h2><h3>1. 现存挑战</h3><ul><li>多云环境存在"信任孤岛"：各云平台安全策略、信任体系独立</li><li>密算资源稀缺、成本高、使用门槛高</li></ul><h3>2. 解决方案：跨云统一证明框架</h3><ul><li>标准化协议与抽象中间层：实现不同TEE架构的协议翻译</li><li>监管支持：区块链存证技术确保运行记录/验证结果不可篡改，提供实时监管接口</li><li>核心价值：打破厂商适配壁垒（如医院跨机构获取数据无需单独适配）</li></ul><h3>3. 终极目标：密算天空计算网络</h3><ul><li>低成本转化：将各类计算资源转化为密算节点</li><li>统一信任：通过跨云统一证明实现节点间互信、互联、互通</li><li>价值释放：工作负载跨云协作与平滑迁移，数据像自来水一样"即开即用"</li></ul><h2>九、核心术语与关键技术</h2><table><thead><tr><th>术语</th><th>英文全称</th><th>核心定义</th></tr></thead><tbody><tr><td>TEE</td><td>Trusted Execution Environment</td><td>可信执行环境，硬件隔离的安全区域，保障数据"可用不可见"</td></tr><tr><td>TPM</td><td>Trusted Platform Module</td><td>可信平台模块，存储熔断密钥与度量值（PCR），信任链起点</td></tr><tr><td>PCR</td><td>Platform Configuration Register</td><td>平台配置寄存器，记录启动组件与运行环境的度量值</td></tr><tr><td>Hypervisor</td><td>-</td><td>虚拟化管理程序，星绽方案中作为机密虚拟机的可信根</td></tr><tr><td>EAT</td><td>Entity Attestation Token</td><td>实体证明令牌，ITS框架下的标准化"健康证书"</td></tr><tr><td>JWT</td><td>JSON Web Token</td><td>用于应用身份传递的无证书令牌，通过硬件衍生密钥签名</td></tr><tr><td>Attesting Agent</td><td>-</td><td>证明代理，负责采集度量值、转发身份请求与验证结果</td></tr></tbody></table>]]></description></item><item>    <title><![CDATA[ICLR 2025 | 中科院+哈工大重]]></title>    <link>https://segmentfault.com/a/1190000047440587</link>    <guid>https://segmentfault.com/a/1190000047440587</guid>    <pubDate>2025-12-01 14:11:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>ICLR 2025 | 中科院+哈工大重磅发现：预训练视觉模型分类越准，可解释性越强</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440590" alt=" " title=" "/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440591" alt=" " title=" " loading="lazy"/></p><p>论文标题：<em>Enhancing Pre-trained Representation Classifiability can Boost its Interpretability</em></p><p>作者团队：中国科学院、哈尔滨工业大学、鹏城实验室、华为</p><p>发布时间：2025年10月28日</p><p><a href="https://link.segmentfault.com/?enc=8T8GD090kLae%2FjIB2w761w%3D%3D.w1iyJ0XkmmCV45ZbUPrYnBUIiAWRYkTZm2PpIZZykkIGJEbfpyZs8kOc06Vgl%2Bwo" rel="nofollow" target="_blank">👉一键直达论文</a></p><p><a href="https://link.segmentfault.com/?enc=YLntlXIdvcsNhI2JdsYduw%3D%3D.l1T%2BRDoA9hzquU1seJKRxChBJaBJeleNR83YRb4z1U%2FIWcPnjvmRhtC8nnEDNRA5LjDn93ooUoSEGK5lWUFEE9exwrLlpOV%2B3axZEKV60BximBCcB06Wxvhqnnogow93gVKGgSCoO1QtbG2NQ68GIfBM3NWmc1qx%2B%2BcVqeCEabI%3D" rel="nofollow" target="_blank">👉Lab4AI大模型实验室论文阅读</a></p><p>✅Lab4AI平台提供AI导读和AI翻译等工具，辅助论文阅读。您还可以投稿复现这篇论文~</p><h3>⭐研究背景</h3><p>当前预训练视觉模型在分类任务上表现优异，但其表示的可解释性常被忽视。传统观点认为可解释性与分类性能存在冲突，尤其在设计可解释模型时分类性能往往下降。</p><h3>⭐研究目的</h3><p>本文旨在探究分类导向的预训练表示是否能够同时实现高分类性能和高可解释性，并量化表示的可解释性，揭示其与分类性能之间的内在关系。</p><h3>⭐研究框架</h3><p>提出“内在可解释性评分（IIS）”，通过将表示投影到概念空间并引入稀疏化机制，衡量其在解释过程中保留任务相关语义的能力。IIS定义为不同稀疏度下解释预测准确率与原始表示准确率之比的平均值。</p><h3>⭐研究结果</h3><p>实验发现，IIS与分类准确率呈正相关，即分类性能越高的表示越易于解释。进一步地，通过最大化IIS微调模型可提升其分类性能，同时基于解释的预测也能达到接近原始模型的准确率，实现可解释性与分类性能的协同提升。</p>]]></description></item><item>    <title><![CDATA[为什么没有免费的代码签名证书 冷冷的炒面]]></title>    <link>https://segmentfault.com/a/1190000047440672</link>    <guid>https://segmentfault.com/a/1190000047440672</guid>    <pubDate>2025-12-01 14:10:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h4><strong>一、什么是代码签名证书？</strong></h4><p>简单来说，代码签名证书就像是软件的“数字身份证”和“安全封条”。</p><p>当开发者发布一个软件（比如.exe或.msi安装包）时，可以用这个证书对它进行“签名”。签名后：</p><ul><li><strong>用户看到</strong>：系统会明确显示这个软件来自“XX公司”，而不是一个“未知发布者”。</li><li><strong>系统信任</strong>：操作系统（如Windows）会认为这个软件来源可信，减少或不再弹出安全警告。</li><li><strong>保证完整性</strong>：它证明软件在签名后没有被病毒或黑客篡改过。</li></ul><p>如果没有这个签名，你的软件在用户电脑上可能会被系统安全机制直接拦截，看起来非常不可靠。<br/><img width="625" height="337" referrerpolicy="no-referrer" src="/img/bVdkwhd" alt="" title=""/></p><h4><strong>二、核心原因：信任的“看门人”不好当</strong></h4><p>免费SSL证书的成功，让很多人期待代码签名证书也能免费。但它们两者承担的责任完全不同。</p><ol><li><p><strong>验证力度不同</strong></p><ul><li><strong>免费SSL证书</strong>：通常只做“域名验证”（DV）。它只证明“你确实控制着这个域名”，不关心你是谁。这个过程可以自动化，成本极低。</li><li><strong>代码签名证书</strong>：需要进行“组织验证”（OV）或“扩展验证”（EV）。证书颁发机构（CA）需要人工核实申请公司的真实存在性、合法性和物理地址。这个过程耗时、费力，无法完全自动化，因此成本高昂。</li></ul></li><li><p><strong>风险与责任的天壤之别</strong></p><ul><li><strong>SSL证书风险</strong>：如果一个免费SSL证书被滥用，通常影响的是一個网站的通訊安全。</li><li><strong>代码签名证书风险</strong>：这是<strong>最高级别的风险</strong>。如果一个恶意软件被成功签上了“可信”的签名，它就能在用户的电脑上畅通无阻地运行。这相当于坏人拿到了警察局的官方印章，可以造成大面积的病毒传播、数据窃取等严重安全事故。证书颁发机构（CA）必须为它们发出的每一个签名证书的“可信度”背书。</li></ul></li></ol><h4><strong>三、为什么不能像SSL证书那样免费？</strong></h4><p>想象一下，如果代码签名证书也免费且无需严格审核，会发生什么：</p><ul><li><strong>恶意软件的天堂</strong>：黑客可以轻易地伪造身份，免费获取证书，为他们开发的病毒、木马签上“合法”的名字。</li><li><strong>信任体系崩溃</strong>：用户和操作系统将无法再相信任何软件的签名。整个代码签名的安全基石将彻底瓦解。</li><li><strong>CA机构无法承担的责任</strong>：一旦因为其免费证书导致大规模安全事件，CA机构将面临巨大的法律诉讼和赔偿风险，这足以让一家公司破产。</li></ul><p><strong>因此，严格的审核和收费，正是为了抬高滥用的门槛，确保这个“数字身份证”发放过程的严肃性和安全性。</strong></p><h4><strong>总结</strong></h4><p><strong>代码签名证书之所以不免费，是因为它守护的是软件分发的“最后一道信任关口”。</strong></p><p>这份信任非常沉重，需要证书颁发机构投入大量的人力物力进行审核，并承担巨大的安全与法律责任。收费，不仅是CA机构的商业模式，更是维护整个软件生态安全不可或缺的屏障。</p><p>所以，当你需要为你的软件购买代码签名证书时，请把它看作是一项必要的、对用户安全负责的投资，而不是一个可以节省的成本。</p>]]></description></item><item>    <title><![CDATA[代码签名证书：软件开发必备？ 傻傻的开心]]></title>    <link>https://segmentfault.com/a/1190000047440680</link>    <guid>https://segmentfault.com/a/1190000047440680</guid>    <pubDate>2025-12-01 14:09:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>选择代码签名证书时，需从证书类型、颁发机构、安全需求、兼容性、成本效益和技术支持六方面综合考量，以下是具体指南：</p><p><strong>一、明确需求：根据场景选证书类型</strong></p><p><strong>标准代码签名证书</strong></p><p><strong>适用场景：</strong> 常规软件发布（如Windows应用、Java小程序）。</p><p><strong>特点：</strong> 验证开发者身份，确保软件完整性，但可能触发SmartScreen过滤器警告（需积累信誉）。</p><p>EV代码签名证书</p><p>适用场景：高频更新软件（如杀毒软件、游戏客户端）、需即时信誉度的场景。</p><p><strong>优势：</strong></p><p>绕过SmartScreen过滤器，用户安装时无警告。</p><p>支持Windows硬件驱动签名（符合WHQL要求）。</p><p>证书私钥存储在USB Key中，物理隔离更安全。</p><p><strong>二、筛选颁发机构（CA）：认准三大核心标准</strong></p><p><strong>全球信任度</strong></p><p>优先选择被主流操作系统（Windows、macOS）、浏览器（Chrome、Firefox）和平台（苹果App Store、微软商店）信任的CA，</p><p><strong>兼容性保障</strong></p><p>确认证书支持目标平台（如iOS需Apple证书，Android需Java代码签名）。</p><p><strong>服务响应速度</strong></p><p>选择提供7×24小时技术支持的CA，避免因证书问题导致发布延迟。</p><p><img width="723" height="323" referrerpolicy="no-referrer" src="/img/bVdh1w5" alt="" title=""/></p><p><strong>三、评估安全需求：加密强度与签名算法</strong></p><p><strong>加密算法</strong></p><p>优先选择SHA-256算法，兼容最新安全标准。</p><p>若需兼容旧系统（如Windows XP），可同时使用SHA-1和SHA-256双签名。</p><p><strong>时间戳服务</strong></p><p>确保证书包含时间戳，避免证书过期后已签名软件失效。</p><p><strong>四、验证兼容性：覆盖目标用户环境</strong></p><p>操作系统</p><p>Windows：需支持Authenticode签名。</p><p>macOS：需支持Developer ID签名（绕过Gatekeeper拦截）。</p><p>开发工具链</p><p>确认证书可集成到现有开发环境（如Visual Studio、Xcode、Java keytool）。</p><p><strong>五、成本效益分析：平衡价格与功能</strong></p><p>有效期与续费成本</p><p>长期项目建议选择2-3年有效期，避免频繁续费。</p><p>关注续费价格，部分CA首年低价但续费昂贵。</p><p><strong>六、避坑指南：三大常见误区</strong></p><p>误区1：免费证书更划算</p><p>风险：免费证书通常不被操作系统信任，可能导致用户安装时出现“未知发布者”警告。</p><p>误区2：签名一次，终身有效</p><p>现实：证书有效期通常为1-3年，过期后需重新签名软件。</p><p><strong>结语</strong></p><p>代码签名证书是软件安全的“第一道防线”，选择时需兼顾安全需求、用户体验和成本效益。通过明确场景需求、筛选可信CA、验证兼容性，您可为软件找到最合适的“安全印章”。</p>]]></description></item><item>    <title><![CDATA[除了加密，它还能验明正身：SSL如何防范]]></title>    <link>https://segmentfault.com/a/1190000047440683</link>    <guid>https://segmentfault.com/a/1190000047440683</guid>    <pubDate>2025-12-01 14:09:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>当我们提到SSL证书，最广为人知的功能是 “<em>加密</em>” 。它像一堵墙，确保你发送的数据不被黑客偷窥。</p><p>但SSL还有一个同等重要、却常被低估的“隐藏技能”——<strong>身份验证</strong>。它像一盏探照灯，在你连接之前，<strong>照清楚服务器的真实身份。</strong></p><p>而防范网络钓鱼的关键，恰恰在于这盏“探照灯”。一个仅有加密、没有身份验证的连接，无异于在加密的房间里，和戴着面具的骗子交谈，风险依然巨大。</p><p><strong>钓鱼攻击的伪装术与SSL的反制</strong></p><p>让我们先理解典型的钓鱼攻击：</p><p><strong>模仿</strong>：黑客创建一个与真实网站（如 paypal.com ）外观一模一样的克隆网站。</p><p><strong>诱导</strong>：通过邮件、短信等方式，诱骗你访问其控制的假域名（如 paypa1-login.com）。</p><p><strong>窃取</strong>：在你输入的瞬间，窃取你的用户名、密码、银行卡号等敏感信息。</p><p>在这个场景下，单纯的加密反而可能成为骗子的帮凶——因为它会让用户产生“安全”的错觉。而SSL的身份验证机制，正是破局的关键。<br/><img width="700" height="400" referrerpolicy="no-referrer" src="/img/bVdna7Z" alt="" title=""/></p><p><strong>SSL验明正身的三道“安检”</strong></p><p>当你访问一个部署了有效SSL证书的网站时，在你点击“登录”或输入任何信息之前，验证就已经悄然发生。</p><p><strong>第一道安检：浏览器自动执行的身份鉴定</strong></p><p>当你输入网址，浏览器收到服务器发来的SSL证书时，会立刻启动一个严格的鉴定流程：</p><p><strong>颁发者可信吗？</strong></p><p>浏览器会检查证书的签发者（CA），是否在它内置的受信任的根证书列表中。这就像检查一份文件的盖章机构，是否是政府认可的公证处。山寨CA签发的证书会被浏览器直接红牌警告。</p><p><strong>证书有效吗？</strong></p><p>浏览器会检查证书是否在有效期内、是否被签发者主动吊销。一份过期的或已注销的“身份证”是无效的。</p><p><strong>域名匹配吗？（最关键的一步！）</strong></p><p>浏览器会核验证书上声明的域名，与你正在访问的实际域名是否完全一致。</p><p>回到钓鱼案例：当你访问黑客的假网站 paypa1-login.com 时，即使黑客为这个假网站申请了SSL证书（通常是DV证书），证书上也只会显示 paypa1-login.com，而绝不可能显示真实的 paypal.com。浏览器会清晰地告诉你：你正在连接的是 paypa1-login.com。对于警惕的用户，这个域名差异就是最明显的警钟。</p><p><strong>第二道安检：不同证书等级带来的视觉信任信号</strong></p><p>这就是 DV、OV、EV 证书的区别所在，它们在防范钓鱼上的能力截然不同。<br/><strong>核心要点</strong>：高级别证书（OV/EV）不仅验证“你有这个域名”，更验证“你是谁”。这使得一个想冒充 paypal.com 的钓鱼网站，几乎不可能获得一张显示“PayPal Inc.”信息的OV或EV证书。</p><p><strong>第三道安检：用户意识的最后防线</strong></p><p>最后，SSL将验证结果清晰地呈现给用户，赋予用户判断的主动权。每次连接前，养成三个简单习惯，就能避开绝大多数钓鱼陷阱：</p><p><strong>看域名</strong>：仔细核对地址栏的完整域名，是否是你想访问的官方网站。</p><p><strong>点锁标</strong>：点击地址栏的锁形图标，查看 “连接是安全的” -&gt; “证书有效” 信息。在这里，你可以清晰地看到网站所有者信息（对于OV/EV证书）。</p><p><strong>信异常</strong>：绝不忽略浏览器的安全警告（如“此连接不安全”、“证书无效”等）。出现警告，立即止步。</p><p><strong>总结：坚固的链条，缺一不可</strong></p><p>防范网络钓鱼，是一个由技术、流程和意识共同构成的防御体系。SSL证书的身份验证功能，是其中技术层面至关重要的一环。</p><p>它通过<strong>可信CA的背书</strong>，建立了身份的起点。</p><p>它通过<strong>浏览器自动化的严格校验</strong>，拦截了信息不符的连接。</p><p>它通过<strong>不同等级的视觉线索</strong>，为用户提供了判断依据。</p><p>因此，<strong>仅仅启用HTTPS（部署DV证书）是远远不够的</strong>。对于真正处理敏感信息的网站（如银行、电商、企业后台），采用经过严格组织验证的OV或EV证书，是向其用户宣告“我即是我”的最高效方式。</p><p>而对于我们每一位用户，理解SSL这盏“身份探照灯”的意义，养成点击锁图标、核对域名信息的习惯，就是在为自己的数字安全，加上最后、也是最关键的一把锁。</p>]]></description></item><item>    <title><![CDATA[当IP地址“披上铠甲”：公网IP能否申请]]></title>    <link>https://segmentfault.com/a/1190000047440687</link>    <guid>https://segmentfault.com/a/1190000047440687</guid>    <pubDate>2025-12-01 14:08:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化浪潮中，数据安全传输已成为刚需。当我们习惯为域名申请SSL证书以实现HTTPS加密时，一个实际问题浮现：<strong>没有域名，只有公网IP地址，能否申请SSL证书？</strong>  答案是肯定的，但这条路径与域名申请有显著差异。</p><h3>为何IP地址需要SSL证书？</h3><p>传统认知中，SSL证书通常与域名绑定。但在特定场景下，直接使用IP地址访问服务：</p><ul><li><strong>企业内部服务外部化</strong>：公司测试服务器、监控面板或API接口通过公网IP临时对外开放</li><li><strong>物联网与设备直连</strong>：智能设备、工业控制器通过固定IP提供Web配置界面</li><li><strong>成本与简化考量</strong>：小型项目或临时服务未配置域名，需快速启用加密</li><li><strong>网络设备管理</strong>：路由器、防火墙等网络设备的管理界面需加密访问</li></ul><p>这些场景下，为IP地址配置SSL证书能有效防止中间人攻击，保护敏感数据传输。</p><h3>证书类型的选择限制</h3><p>与域名证书类似，IP SSL证书也分为不同验证级别：</p><ul><li><strong>DV（域名验证）证书</strong>：验证申请者对IP地址的控制权，通过上传指定文件或添加DNS记录完成验证。这是最常见的IP证书类型。</li><li><strong>OV（组织验证）证书</strong>：少数证书颁发机构(CA)提供，需验证组织身份，价格较高，审核严格。</li><li><strong>EV（扩展验证）证书</strong>：基本不对IP地址颁发，因其验证标准基于法律实体和域名所有权。</li></ul><p><strong>重要限制</strong>：根据CA/浏览器论坛规定，自2016年起，公网IP SSL证书仅可包含具体IP地址（如<code>192.0.2.1</code>），不能包含通配符（如<code>192.0.2.*</code>）。内网IP（<code>10.x.x.x</code>、<code>172.16.x.x-172.31.x.x</code>、<code>192.168.x.x</code>）理论上可申请私有证书，但需自建CA或使用特定服务。<br/><img width="723" height="414" referrerpolicy="no-referrer" src="/img/bVdmRTx" alt="" title=""/></p><p><strong><em>申请办法：打开JoySSL证书官网，填写注册码230970获取技术支持</em></strong>  <a href="https://link.segmentfault.com/?enc=a9UeP%2FonWAitee29Y0kYdg%3D%3D.anAmI9CH%2Bdt01HkflpAbxPTW4QK72oKYAZwO3998%2Frjt1hmQRPWJOeRPVlJmiGd6nCAb7MkNV2cO9IcomKgcyQLSy3wlEQRKJOYN4bILTUw%3D" rel="nofollow" target="_blank">申请入口</a></p><h3>申请实战：步骤与注意事项</h3><p>为公网IP申请SSL证书的流程如下：</p><ol><li><strong>选择证书提供商</strong>：并非所有CA都支持IP证书。GlobalSign、DigiCert、Sectigo等主流提供商通常支持，部分免费证书服务（如Let's Encrypt）也支持IP证书，但需验证IP控制权。</li><li><strong>生成CSR（证书签名请求）</strong> ：与域名证书类似，需要生成包含IP地址的CSR文件。关键点：在“通用名称(CN)”字段填写IP地址，而非域名。</li><li><p><strong>完成验证</strong>：</p><ul><li><strong>文件验证</strong>：在IP地址对应的Web服务器指定路径放置验证文件</li><li><strong>DNS验证</strong>：为IP地址的反向DNS记录添加指定TXT记录（需确保IP有反向DNS解析）</li><li><strong>邮箱验证</strong>：向IP的WHOIS注册邮箱发送确认信（较少用）</li></ul></li><li><strong>安装与部署</strong>：获得证书后，像域名证书一样配置到Web服务器（Nginx、Apache、IIS等）。</li></ol><p><strong>特别注意</strong>：</p><ul><li><strong>动态IP限制</strong>：大多数CA仅对静态公网IP颁发证书。动态IP（如家庭宽带）通常无法满足验证要求。</li><li><strong>IPv6支持</strong>：越来越多的CA开始支持IPv6地址的证书申请。</li><li><strong>兼容性考量</strong>：尽管主流浏览器支持IP SSL证书，但某些旧版浏览器或移动应用可能有不兼容情况。</li></ul><h3>风险提示与最佳实践</h3><ol><li><strong>隐私考量</strong>：IP证书会将IP地址暴露在证书透明度(CT)日志中，可能增加被扫描攻击的风险。</li><li><p><strong>短期方案建议</strong>：IP证书更适合临时或测试环境。长期服务强烈建议使用域名并申请相应证书，原因如下：</p><ul><li>域名更易于记忆和传播</li><li>IP变更时域名无需重新申请证书</li><li>域名证书选择更多、价格更优</li></ul></li><li><p><strong>安全加固</strong>：</p><ul><li>即使使用IP证书，也应配置HTTP严格传输安全(HSTS)等增强措施</li><li>定期更新证书，避免使用自签名证书导致浏览器警告</li><li>考虑将IP服务置于反向代理后，在代理层配置域名证书</li></ul></li></ol>]]></description></item><item>    <title><![CDATA[国密算法IP证书：构建网络空间安全的“中]]></title>    <link>https://segmentfault.com/a/1190000047440693</link>    <guid>https://segmentfault.com/a/1190000047440693</guid>    <pubDate>2025-12-01 14:07:43</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>国密算法IP证书作为我国网络空间安全自主可控战略的核心基础设施，正通过融合国产密码算法与IP地址绑定机制，重塑网络安全的技术格局。以下从技术特性、战略价值及实践应用三个维度解析其作为“中国芯”的重要意义：</p><p><strong>国密算法IP证书⬇️</strong></p><p><a href="https://link.segmentfault.com/?enc=CrnSlryTABZZTeTB7kJpNQ%3D%3D.GnqiNzFC%2ByhSLaq91pFVAwRSRNlyzqiUhiJmaQT7xyu9Si2QmcVHZkR1V9DqFMrYuQGRLR2k9LEbow8yXhL%2BnICREXkXzayPTx%2BQQV4Du9g%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/international_algor...</a></p><p><strong>注册码230959，专属技术服务支持⬆️</strong></p><p><img width="723" height="344" referrerpolicy="no-referrer" src="/img/bVdndEz" alt="image.png" title="image.png"/></p><h3>一、技术内核：自主可控的加密体系</h3><ol><li><strong>算法革新</strong>  <br/>国密算法IP证书基于国家密码管理局认证的SM2/SM3/SM4算法体系，其优势显著：</li></ol><ul><li><strong>高效安全</strong>：SM2密钥长度（256位）等效于RSA 2048位的安全强度，计算效率提升30%以上。</li><li><strong>抗量子攻击</strong>：采用后量子密码设计，为未来量子计算威胁提供前瞻性防护。</li><li><strong>双证书架构</strong>：创新性地分离加密证书与签名证书，形成“独立防盗门+指纹锁”的双重防护，降低单点突破风险。</li></ul><ol start="2"><li><strong>生态适配</strong>  <br/>已深度兼容国产主流环境，包括360浏览器、奇安信可信浏览器、红莲花浏览器等，并支持DeepinOS、统信UOS、KylinOS等国产操作系统，构建软硬件全栈安全链。</li></ol><h3>二、战略意义：数字主权的技术支点</h3><ol><li><strong>合规刚需</strong>  <br/>根据《密码法》《网络安全法》及等保2.0要求，政务、金融、能源等领域必须部署国密算法证书以通过“密评”（商用密码应用安全性评估）。截至2023年，全国已建成覆盖200余家CA机构的SM2根证书体系，成为政企系统准入的“通行证”。</li><li><strong>摆脱技术依赖</strong>  <br/>传统SSL证书依赖国际算法标准，存在后门漏洞风险与供应链“卡脖子”隐患。国密证书实现从算法设计到证书签发的全链路国产化，彻底扭转被动局面。</li></ol><h3>三、实践价值：多场景安全防护网</h3><ol><li><strong>特殊场景覆盖</strong>  <br/>针对未绑定域名的内部系统、工业控制设备、物联网终端等直接基于IP访问的场景，弥补传统域名证书空白，防范DNS劫持风险。例如，某大型制造企业通过IP证书实现车间设备加密通信，保障生产数据安全。</li><li><strong>性能优化降本增效</strong></li></ol><ul><li><strong>运算效率</strong>：SM系列算法针对国内网络环境深度优化，结合硬件加速技术（如国密SSL加速卡），使加密效率提升50%。</li><li><strong>成本节约</strong>：同等安全强度下，运维成本降低约40%，助力企业轻量化升级。</li></ul>]]></description></item><item>    <title><![CDATA[搞懂数字签名与证书 深盾安全 ]]></title>    <link>https://segmentfault.com/a/1190000047440699</link>    <guid>https://segmentfault.com/a/1190000047440699</guid>    <pubDate>2025-12-01 14:06:45</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>前言</h2><p>在之前的文章中，我们介绍了什么是对称加密什么是非对称加密，同时我们在文章中我们留下了一个疑问，那就是如何确认公钥和数据就是对方的而不是伪造的，今天这篇文章我们就聊聊相关的技术，签名与证书，非常有用，注意听讲哈</p><h2>签名</h2><p>平时我们说的签名更多是签个名字，比如有个文件需要经过我的确认，我再确认后需要拿起笔签上名字，证明这个文件是我已经同意了的。这里的关键点就是笔迹。</p><p>那么在数字世界中，如果我需要对方发送一个文件给我，我如何确认我所接收到的文件就是对方发送给我的而不是有人恶意伪造的呢？或者我该如何确认对方发送给我的文件不是经过有人篡改后的呢？</p><p>答案就是数字签名，数字签名使用的核心技术是哈希算法和非对称加密，如果大家对非对称加密不了解可以参考之前的文章</p><h3>哈希算法（HASH）</h3><p>本篇文章不对哈希算法做详细的说明，只做一个简单的介绍，让大家知道什么是哈希算法</p><p>所谓的哈希算法也称为“散列函数”或“哈希函数”，听名字是不是被吓到了，其实它就是一种能够输入任意长度的数据，通过计算，转换为一个固定长度字符串，这个转换出的字符串被称为哈希值、散列值或信息摘要，可以把它想象为一个数据的数字指纹</p><p>一个优秀的哈希算法具有以下几个特征</p><ol><li>输入相同的数据，无论什么时候计算出的哈希值都必须是完全相同的</li><li>输入数据哪怕仅发生极其微小的变化，哪怕是1个bit，输出的哈希值都会发生巨大变化，不可预测的改变</li><li>无法从哈希值反向推导出原始数据，也就是单向性</li><li>几乎不可能找到两个不同的输入具有相同的哈希值</li></ol><h3>数字签名</h3><p>数字签名的作用就是让别人相信内容没有被改过和确实是来自指定的人，同时签名者也无法抵赖说不是自己签的名</p><p>有了哈希算法和非对称加密我们就能够实现数字签名了</p><p>其实数字签名的流程很简单，可以分为以下几步</p><ol><li>对需要签名的数据进行哈希运算，计算数据的哈希值</li><li>使用私钥对哈希值进行加密</li></ol><p>使用数字签名也很简单，进行确认签名的流程叫做验签，可以分为以下几步</p><ol><li>从数据中提取签名数据和内容</li><li>使用公钥对签名数据进行解密得到哈希值</li><li>使用相同的哈希算法计算内容的哈希值</li><li>对比计算出的哈希值和解密出的哈希值是否一致，一致代表验签成功</li></ol><h2>数字证书</h2><p>刚刚说了数字签名，那就有一个问题，验签时使用了公钥，我又如何知道我所获得的公钥是正确的呢？这就是所谓的CA体系</p><p>数字证书也称为公钥证书，是一个电子文档，它遵循国际标准（X.509），这个问的那个就像是一个数字世界的身份证一样。</p><p>它的核心作用就是将一个公钥与一个特定的实体（个人、组织）的身份信息绑定在一起，并由一个可信的第三方机构对这个绑定关系进行担保和签名</p><p>比如用驾照来类比数字证书：</p><table><thead><tr><th>要素</th><th>驾照</th><th>数字证书</th></tr></thead><tbody><tr><td>持有者信息</td><td>姓名、地址、身份证号</td><td>主题：持有者的名称、组织信息等</td></tr><tr><td>核心凭证</td><td>驾照号码</td><td>公钥：证书持有者的公钥</td></tr><tr><td>颁发机构</td><td>车管所</td><td>证书颁发机构</td></tr><tr><td>机构印章</td><td>车管所的官方盖章</td><td>颁发者的数字签名：CA用自己的私钥对证书内容进行签名</td></tr><tr><td>有效期</td><td>签发日期和到期时间</td><td>证书生效和失效的时间</td></tr></tbody></table><p>你相信驾照上的信息，是因为你信任车管所这个权威机构，并且驾照上有它的防伪签名和印章。</p><p>同样，你相信一个数字证书里的公钥属于某个人或组织是因为你信任证书的颁发机构，并且证书上有颁发机构的数字签名</p><p>总结来说就是：假如我要将我的公钥发送给对方，那我就找证书颁发机构，提供我的公钥，让证书颁发机构帮我进行签名并制作证书，然后我将制作好的证书发送给对方。</p><p>对方拿到我的证书后需要进行验签，确认证书的颁发机构，那我们凭什么就要信任颁发机构呢？答案就是不相 信，颁发机构又会有它的证书，颁发机构的证书是由更上层的颁发机构颁发的，而更上层的颁发机构又有更更上层的颁发机构颁发，这套体系叫做CA体系，这套证书叫做证书链，一直到最上层是根证书，根证书仅有几个企业可以办法，这些跟证书已经早早的保存在我们的设备中了，只需要进行一下确认就可以了</p><h2>安全问题</h2><p>好了签名和证书已经为大家介绍完了，大家是不是已经觉的我们的程序只要使用了这套签名和证书体系就很安全了呢？哈哈哈，别太自信，你想想如果有人通过逆向的手段，直接修改我们的程序，绕过了验签流程，那再安全的方案也没有用啊</p><p>那怎么办呢？</p><h3>程序加壳保护</h3><p>现在我们已经有了足够安全的保障体系了，那要防止的也就是我们的程序被其他人逆向分析或篡改，这时可以使用Virbox Protector工具，对我们的程序进行加壳保护，加壳时会使用混淆，虚拟化，反调试等各种手段保护我们的程序，程序经过保护后我们就不需要在为此担心啦</p>]]></description></item><item>    <title><![CDATA[【版本更新】火语言 0.9.98.0 更]]></title>    <link>https://segmentfault.com/a/1190000047440701</link>    <guid>https://segmentfault.com/a/1190000047440701</guid>    <pubDate>2025-12-01 14:05:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>1.修复Excel删除列、写值问题。<br/>2.浏览器监听优化处理。<br/>3.指纹浏览器应用支持调用本地客户端服务。<br/>4.新增人工等待置顶配置。<br/>5.优化发布应用拷贝的文件目录。<br/>6.优化指纹浏览器应用插件安装。<br/>7.新增界面应用控件拷贝到其他窗体。<br/>8.优化另存为模板拷贝变量、对象。<br/>9.处理窗体加载完成事件内置浏览器Timeout问题。<br/>10.获取时间间隔使用本地时间（非UTC）。</p>]]></description></item><item>    <title><![CDATA[50-100人的公司，文件共享选NAS还]]></title>    <link>https://segmentfault.com/a/1190000047440708</link>    <guid>https://segmentfault.com/a/1190000047440708</guid>    <pubDate>2025-12-01 14:05:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>根据市场研究机构Statista的一项调查显示，截至2023年，有超过79%的中小企业认为文件共享和协作是提升团队效率的关键环节。然而，在对技术解决方案的选择上，许多企业却陷入纠结：</p><p>是选择本地化设备如NAS（网络附属存储），还是采用更为弹性的企业网盘？尤其对于50-100人的中型公司来说，这道选择题尤为棘手，它不仅关系到数据的安全性和成本，也直接影响到员工的工作效率和团队的协作深度。</p><p><img width="658" height="350" referrerpolicy="no-referrer" src="/img/bVdjxj5" alt="" title=""/></p><h2>NAS与企业网盘，两个方向</h2><p>在开始比较之前，我们需要先明确这两个技术解决方案的核心概念及其适用场景。</p><p>NAS：本地化的存储<br/>NAS（Network Attached Storage）是一种通过局域网连接的专用存储设备，常用于小型团队或公司。这种设备的最大优势是数据保存在本地，可避免对外网的高度依赖。它比较适合对数据隐私、安全性要求较高，并且有一定IT管理能力的公司。</p><p>比如，一家设计公司可能需要频繁存储和传输大体积的设计文件（如动辄数十GB的CAD文件）；类似这样的企业，NAS的本地存储能力和较高的读取速度显然更能满足需求。</p><h2>企业网盘：云端的灵活办公</h2><p>与NAS形成鲜明对比的是<a href="https://link.segmentfault.com/?enc=Lz4cdUgr9FhA0Ibx3A2bsA%3D%3D.AwWwqv9zQ7f1eIqykbrKgIVu9bGrIUd0Wk1MSbpBZHcEIs%2BfvNuQ6ZfeEjpTSPCixN47vKBYT7MMzOME9xdL5g%3D%3D" rel="nofollow" target="_blank">企业网盘</a>。企业网盘基于云存储技术，为员工提供随时随地访问和共享文件的能力。无论是远程协作，实时同步，还是团队项目管理，企业网盘都具有天然的优势。它尤为适合注重灵活性，且有混合办公需求的团队。</p><p>比如，一个50人规模的营销团队可能成员分布在多个城市，这时若所有文件都集中在一台NAS上，便会因为跨地域访问的延迟问题拖慢进度，而云端企业网盘完全可以避免这样的困扰。</p><h2>核心对比：NAS与企业网盘适合谁？</h2><p>为了让选择更具针对性，我们从几个关键维度进行细致比较。</p><h3>1. 数据安全性与掌控权</h3><p>NAS<br/>数据存储在本地，完全掌控在企业手中。公司可以直接在物理层面保障文件的安全性，不用担心厂商平台的潜在漏洞。但是，这种方式的风险在于一旦设备损坏或遭遇自然灾害（如火灾、地震），数据可能面临不可逆的丢失。因此，NAS需要做好备份规划，例如搭建RAID阵列或者将部分数据异地存储。</p><p>企业网盘<br/>企业网盘则强调服务商的安全保障。以Zoho网盘为例，它不仅会对文件进行256位AES加密，还支持企业级别的权限管理和日志追踪。即使一个文件被误删除，也可以方便地从云端版本管理中恢复。如果选择了可信赖的网盘服务商，云端存储的安全性同样十分可靠，且用户无需额外担心硬件损坏问题。</p><h3>2. 部署与维护</h3><p>NAS</p><p>对中小企业而言，使用NAS有一个隐形的“门槛”：部署和维护。NAS设备的初期搭建需要IT部门的支持，后期的硬件维护、网络配置升级、定期检测等也需要一定的技术能力。而如果缺乏专业的IT人员，可能会导致设备故障时恢复效率低下，影响业务正常运行。</p><p>企业网盘</p><p>一个强大的企业网盘，可以大幅度减轻公司的技术负担。以Zoho网盘为例，用户登录即可使用，它通过SaaS模式解决了存储扩容、系统更新、访问权限配置等繁琐事项，企业无需专门配备运维团队。特别是对于不断追求高效率的成长型企业来说，这种简化的IT管理方案无疑是理想选择。</p><h3>3. 成本与灵活性</h3><p>NAS</p><p>初期购买NAS设备时，公司的预算可能会受到一定压力。一台性能优越的NAS设备，加上硬盘及相关配套软件，需要投资数万元。尽管长远来看，使用成本可控，但当公司业务增长时，扩容费用和设备更新成本会进一步攀高。</p><p>企业网盘</p><p>企业网盘则采用按需付费的模式，非常适合50-100人规模的公司。Zoho网盘提供多种套餐选项，按月或按年支付，无需一次性购入昂贵设备。同时，当团队成员增加或需求提升时，只需调整存储计划即可，弹性用量为企业节省不少预算。</p><ol start="4"><li>协作与操作体验</li></ol><p>NAS</p><p>NAS虽因复杂的本地网络操作能力而具备一定优势，但在团队协作方面不如网盘方便。大多数时候，员工只能通过公司内部网络访问NAS数据，远程工作时仍需要额外设置VPN、DDNS等。对于注重实时协同和跨地域办公的企业来说，这无形中加大了操作难度。</p><p>企业网盘</p><p>Zoho网盘则为企业提供了一站式协作体验：文件可以实时共享、在线编辑、备注讨论，所有文件版本和操作记录一目了然，同时还方便员工在多种设备中同步内容。此外，像这种网盘方案还可以通过应用程序接口（API）与其他办公工具集成，进一步扩展应用场景。</p><h2>50-100人公司如何选择？一体化协作助力企业发展</h2><p>对于50-100人的中型公司而言，选择NAS还是企业网盘，本质上是取决于企业当前的业务形态和发展需求。那么，是否有一种方案可以在安全性、便捷性和成本之间找到平衡点？</p><p>一个成熟的企业网盘，如Zoho网盘，无疑可以成为大部分中型企业的优选方案：</p><p>灵活高效的文件协作：实时共享和编辑功能，让团队的沟通更高效。</p><p>出色的数据管理与权限控制：管理员可以细化每一位成员的访问权限，完全掌握数据流向。</p><p>更低的前期投资和维护成本：按需付费的模式，让预算变得可控。</p><p>跨平台支持与远程优越体验：无论在办公室还是异地，所有文件都触手可得。</p><p>如果你的企业已经开始混合办公，或团队越来越依赖协作与共享办公工具，Zoho网盘绝对是值得深入体验的选项。</p>]]></description></item><item>    <title><![CDATA[SSL证书在哪里可以申请免费的 从未表白]]></title>    <link>https://segmentfault.com/a/1190000047440717</link>    <guid>https://segmentfault.com/a/1190000047440717</guid>    <pubDate>2025-12-01 14:04:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>SSL证书的申请渠道</h2><p>申请SSL证书的渠道多样，主要可分为以下几类：</p><ul><li><strong>免费证书颁发机构(CA)</strong>：如JoySSL提供基础DV型免费证书，针对特殊域名的</li><li><strong>付费证书颁发机构</strong>：全球知名的CA如Symantec、Comodo、GeoTrust等，提供包括DV、OV、EV在内的多种证书类型，具有更高的安全保障和信任度，通常提供保险保障和完善的技术支持。</li><li><strong>云服务提供商</strong>：如阿里云、腾讯云、华为云等云服务平台，也集成了SSL证书的申请与管理服务，部分平台提供免费证书。</li><li><strong>特定机构免费证书</strong>：例如<strong>JoySSL为政务单位及教育机构</strong>提供的免费政务版和教育版SSL证书。</li></ul><p>为了让你更直观地了解不同渠道的特点，请参考下表：</p><table><thead><tr><th align="left"><strong>渠道类型</strong></th><th align="left"><strong>主要特点</strong></th><th align="left"><strong>适用场景</strong></th></tr></thead><tbody><tr><td align="left"><strong>免费CA (如JoySSL)</strong></td><td align="left">零成本，<strong>申请便捷</strong>，通常为DV型证书；部分机构如JoySSL提供<strong>政务/教育免费版</strong></td><td align="left">个人网站、博客、测试环境、符合条件的政务/教育机构</td></tr><tr><td align="left"><strong>付费CA</strong></td><td align="left">信任度高，验证严格（尤其是OV/EV型），提供保险，技术支持完善</td><td align="left">企业官网、电商平台、金融机构等对安全要求高的场景</td></tr><tr><td align="left"><strong>云服务商</strong></td><td align="left">可与云产品便捷集成，管理方便，部分提供免费证书</td><td align="left">已在使用相应云服务的用户</td></tr></tbody></table><h3><a href="https://link.segmentfault.com/?enc=0VvU0dfbt0hK9Z%2FI%2B1zeoQ%3D%3D.gsNcMxdp%2B3KB6%2FwlxHaXWAVHTUbbWaWbUrUB9L%2FnMiQSI82NIHMaU2pGpf8K27dvExckfRfoku9JdQCz8AwEtT47M0EP0BQzIM8Kt7PNTPc%3D" rel="nofollow" target="_blank">免费证书申请入口</a></h3><p>直接访问JoySSL，注册一个账号记得填写注册码230931获取技术支持。</p><p><strong>注意免费证书是针对特殊域名的。</strong><br/><img width="539" height="197" referrerpolicy="no-referrer" src="/img/bVdjsFk" alt="" title=""/></p><h2>推荐JoySSL政务版与教育版免费证书</h2><p>对于<strong>政府机关、事业单位、公立学校、教育机构及教育平台</strong>，<strong>JoySSL</strong>提供了<strong>免费的政务版和教育版SSL证书</strong>。这是一个非常可靠且成本效益高的选择。</p><h3>主要特点与优势</h3><ol><li><strong>完全免费</strong>：JoySSL为政务和教育机构提供免费的SSL证书，有效降低这些单位的运营成本。</li><li><strong>满足基本安全需求</strong>：提供的证书能够实现网站数据的<strong>加密传输</strong>，保障用户访问安全，消除浏览器“不安全”警告。</li><li><strong>国密算法支持（可选）</strong>：JoySSL的部分证书支持<strong>国密算法</strong>，能够满足政务系统对自主可控密码应用的安全需求。</li></ol><h3>申请步骤</h3><p>JoySSL证书的申请流程简单，主要分为以下几步：</p><ol><li><strong>注册账号</strong>：访问JoySSL官方网站，注册账号。在注册过程中，通常需要填写特定的<strong>注册码（如230922）</strong> 以获取免费申请资格。</li><li><strong>选择证书类型</strong>：登录后，在证书列表中选择“免费证书”或直接找到“<strong>政务/教育版</strong>”入口并点击申请。</li><li><strong>填写信息并提交资料</strong>：准确填写需要加密的<strong>域名</strong>、单位的<strong>完整官方名称</strong>（需与证明文件一致）、联系人信息等。根据提示上传单位证明文件，如事业单位法人证书或统一社会信用代码证书的清晰照片或扫描件。</li><li><strong>验证与审核</strong>：提交申请后，等待JoySSL审核。审核时间通常为1-3个工作日。</li><li><strong>下载并安装证书</strong>：审核通过后，你会收到通知邮件。登录JoySSL用户管理后台，下载签发的SSL证书文件（通常包括<code>.crt</code>或<code>.pem</code>证书文件及<code>.key</code>私钥文件）。最后，将证书部署到你的网站服务器上。</li></ol><h2>申请与部署注意事项</h2><p>在申请和部署SSL证书时，有几个关键点需要特别注意：</p><ul><li><strong>确保证书兼容性</strong>：选择受信任的证书颁发机构，并验证证书是否支持所有主流浏览器和操作系统。</li><li><strong>注意证书有效期并及时续期</strong>：免费SSL证书的有效期通常较短（例如一年）。需要在证书到期前及时更新，否则会影响网站安全。</li><li><strong>妥善保管私钥</strong>：私钥文件是证书安全的核心，<strong>务必妥善保存</strong>，一旦丢失将无法安装和使用证书。</li><li><strong>正确安装与配置</strong>：根据服务器类型（如Nginx、Apache、IIS等）按照相应的步骤正确安装和配置SSL证书。</li></ul><p>希望这篇文章能帮助你找到合适的SSL证书申请渠道。为你的网站添加一把“安全锁”，既是保障数据安全的重要措施，也是提升网站可信度的关键一步。</p>]]></description></item><item>    <title><![CDATA[如何通过工艺优化提升汽车制造效率？ 月下]]></title>    <link>https://segmentfault.com/a/1190000047440744</link>    <guid>https://segmentfault.com/a/1190000047440744</guid>    <pubDate>2025-12-01 14:03:35</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在全球制造业迈向智能化的浪潮中，工艺优化成为传统汽车制造企业破茧重生的核心变量。广域铭岛凭借其工业互联网平台Geega，打造出覆盖冲压、焊装、涂装、总装四大关键环节的数字化工艺优化闭环，将单点技术问题转化为系统性智能解决方案。这种优化不止于质量改善，更通过实时数据流重新定义工艺逻辑，形成一种以算法驱动的生产范式。<br/>在冲压领域，广域铭岛的GQCM模具智能管理APP将经验试错的被动维护转向基于冲次数据与设备状态的预测制造。系统通过构建虚拟孪生模型，提前48小时捕捉模具异常，主动触发保养工单，让金属成型速率与精度同步提升。这种颠覆性工艺优化方式，使模具运行效率提升40%，甚至改变了制造业对标准化模具的认知边界。<br/>焊装环节的工艺优化则围绕破解"隐形缺陷"展开。5G+边缘计算的接入赋予焊接工艺前所未有的感知力，2000余项焊点参数的量化分析打破了传统质检的人为主观性。更令行业瞩目的是，AI预测模型将虚焊率压缩至0.02%以下的微小阈值，这也意味着一种全新的生产哲学：从经验迭代到数据驯化。这种工艺优化深度，连车企自身都难以企及。<br/>涂装工艺优化成为广域铭岛技术护城河的最佳体现。依托跨设备层叠数据采集，平台构建出从涂料配比到喷涂轨迹的整套优化矩阵。智能调色算法如同炼金术士般动态补偿环境波动，而能耗调控技术则将涂装从污染大户转变为降碳先锋——单套系统可同时实现12%涂料升利用率和8%能耗降低。这种工业级工艺优化，让汽车表面不再仅仅是色彩问题，更成为价值创造的实体延伸。<br/>总装工艺的优化侧重于"最后一微米"的精准拿捏。电控拧紧系统的粒子级监控将装配全环节数据化，任何扭矩偏差都会在三级预警体系中被放大消解。这种创新性工艺优化，不仅使装配返工率降低至传统模式的60%，更建立了可追溯的智能档案体系，将质量视角拓展至产品全生命周期。<br/>广域铭岛的技术架构实则是"三横三纵"的工艺优化交响曲。横向看，它通过工业AI平台实现了从传感器到决策引擎的数据流贯通；纵向分析，又构建起覆盖设备级优化、产线级平衡到工厂级排产的立体化网络。这种复合型工艺优化能力，让单一产线运行效率突破40%上限已成为可能。<br/>尤为值得关注的是，广域铭岛成功将工艺优化从核心技术突破转化为产业协同发展模式。通过开放API接口，平台连接200余家第三方厂商，形成跨越品牌的全新工艺标准。当某合资车企采用这套集成化工艺优化系统时，原本耗时3周的数据对接周期被压缩至3个工作日，80%的部署效率提升直接源于这种生态级优化思维。<br/>从制造逻辑的根本变革角度看，广域铭岛的工艺优化正在重构行业的know-how体系。传统制造业依赖经验堆积，而其工业超级智能体则将复杂的工艺变量转化为可被AI理解和操控的参数空间。这就如同为汽车制造植入动态智慧基因，让每一型零件、每一组数据都能在适配环境中"进化"出最优解。<br/>可持续发展维度下，工艺优化展现出更广阔的解构空间。统计数据显示：涂装工艺优化使能耗平均下降15%，焊装环节优化减少20%有机物排放，冲压优化实现同等质量下25%材料节省。这些复合效益不仅是技术落地的凯标，更证明了广域铭岛工艺优化方案在碳约束时代的价值权重。<br/>随着量子计算等前沿技术在工业领域的加速渗透，广域铭岛正将工艺优化推向更具想象力的新阶段。该公司对制造业的认知早已超越单点技术——智能制造范式构建的游戏规则正被其亲手改写。未来的汽车制造，必然是由这种全方位工艺优化重新编织的秩序所主宰。从设计逻辑到供应链协同，从质量管控到绿色转型，广域铭岛的工艺优化路径或将成为下一个行业基准。</p>]]></description></item><item>    <title><![CDATA[干货推荐：OOM 杀进程 or 应用卡顿]]></title>    <link>https://segmentfault.com/a/1190000047440746</link>    <guid>https://segmentfault.com/a/1190000047440746</guid>    <pubDate>2025-12-01 14:02:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3>背景</h3><p>近期，大量用户反馈系统在运行过程中出现 CPU 利用率与系统负载（load）突发性飙升，甚至引发系统短时卡顿（持续数秒至数十秒）的问题；对于业务来说，轻则导致几百毫秒的抖动，重则连机器都无法ssh上去。经分析发现，此类异常现象普遍存在一个显著特征：均发生在系统内存占用率接近阈值（90%-95%）时。用户就发出了灵魂拷问：</p><p>“水位这么高了，为什么内核不触发 OOM 杀掉一些进程来释放内存？"</p><p>“我宁愿内核OOM 把我业务进程杀了，我也不希望应用卡顿和系统夯机影响我其他业务！”</p><p>其实这个现象的核心原因就是：内核想确保应用实在没内存用了才 OOM。</p><p>思想总体是正确的，但是一条思想要满足所有场景也是非常难的。</p><h4>为什么还不 OOM？</h4><p>内存水位这么高，为什么还不 OOM！其实主要是由于系统进入了 Near-OOM 状态。现在，我们先回顾一下 Linux 的内存回收机制，如下图所示：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047440748" alt="图片" title="图片"/><br/>（图/Linux 内存水线）</p><p>Linux 划分了 high、low、min 三个内存水线。当系统剩余内存低于 low 水线后，内核会唤醒 kswapd 进程会被唤醒开始进行异步的内存回收，此时对系统没什么影响；系统剩余内存低于 min 水线后，内核会阻塞要分配的内存进程尝试尽可能地回收所有可回收的内存（主要是文件缓存以及一些内核结构体缓存），回收的过程中可能涉及到将文件缓存写入磁盘或遍历一些内核结构体，从而导致系统负载飙高、应用被阻塞。如果能成功回收内存并满足申请需求则不触发 OOM。</p><p>更糟糕的是，系统可能进入一种 Near-OOM 的活锁状态，即内核一边在尝试回收文件缓存；但是应用运行过程中从磁盘加载代码段等行为也在不断产生文件缓存，那么就会使整个系统负载持续飙高，甚至发生夯机。<br/>所以，内核 OOM 的策略在业务延时敏感的场景，还是太保守了。</p><p>那么如果我们希望宁愿 OOM 把我业务进程杀了，我也不希望应用卡顿和系统夯机影响我其他业务？还有什么办法呢？</p><h3>新 OOM 方案</h3><p>为了应对 Near-OOM 现象，核心就是“快” OOM，在内核还在犹豫要不要 OOM 的时候，我们就替他做出决定！目前业界已有的方案主要是通过用户态提前杀死相关进程来提前释放内存，比如应用较为广泛的是 Facebook（Meta）推出的 oomd。oomd 目前已经集成于 systemd 中成为 systemd-oomd，且从 Ubuntu 22.04 开始集成于 Ubuntu 中。但是 oomd 方案存在以下问题：</p><p>与 cgroupV2 以及 Linux 内核的 PSI（Pressure Stall Information）特性深度绑定。但 cgroupV1 目前仍然是云计算中主流 cgroup 版本，且由于 PSI 功能有一定的性能开销，在大部分云计算场景中都是默认关闭的。</p><p>只支持以 cgroup 为粒度杀进程，配置 cgroup 级别的杀进程策略。</p><p>所以 oomd 在适用性和灵活性上仍有欠缺。</p><p>为了解决上述问题，阿里云操作系统控制台推出了 FastOOM 功能，支持节点以及 Pod 级别的用户态 OOM 配置，通过提前介入杀进程的方式避 Near-OOM 导致的抖动夯机。</p><p>FastOOM 同样采取用户态提前杀进程的形式来避免系统进入 Near-OOM 状态，主要分为采集预测模块和 kill 模块：采集预测模块会从阿里云自研操作系统中读取内存压力相关的指标，通过统计学方法对 OOM 发生的概率进行实时预测并判定当前节点或 pod 是否达到相应的内存压力或即将进入 Near-OOM 状态。kill 模块会根据用户配置的杀进程策略，选取对应的进程杀死。</p><p>最终所有由 FastOOM 执行的 kill 操作事件都会上报到控制台中心端进行展示，让用户方便了解底层的实际操作（不用担心 FastOOM 偷偷杀死了其他进程）。<br/><img width="723" height="274" referrerpolicy="no-referrer" src="/img/bVdndFl" alt="image.png" title="image.png" loading="lazy"/></p><h3>使用 FastOOM 避免 Near-OOM 系统夯机抖动</h3><h4>场景一：配置节点级别策略解决系统Near-OOM抖动夯机问题</h4><p>客户遇到的问题<br/>某汽车行业发现某实例上业务长时间无响应、登录实例也十分卡顿。通过监控发现客户实例使用的内存在某个时间点开始徒增，接近系统的总内存（即 available 非常低），但没有超过系统总内存。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047440749" alt="图片" title="图片" loading="lazy"/><br/>通过 top 命令可以看到系统的 CPU sys 利用率和 iowait 利用率和系统负载都持续飙高，kswapd0 线程占用非常高的 CPU 进行内存回收。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440750" alt="图片" title="图片" loading="lazy"/><br/>通过操作系统控制台的系统概览可以看到，在发生 OOM 夯（即处于 Near-OOM 状态）的同时，也发生了用户态收包延时，业务发生了抖动。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440751" alt="图片" title="图片" loading="lazy"/><br/>解决方案</p><p>通过配置开启节点级别的 FastOOM 功能，由于业务是实验较为敏感的业务，内存压力选择中，且设置业务程序（以 python 启动，进程名包含 python 子串）为避免被 OOM 进程且设置无关的日志程序优先杀死。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440752" alt="图片" title="图片" loading="lazy"/><br/>开启后，当节点内存水位处于 Near-OOM 状态时，用户态提前介入，根据配置杀死了如下进程，从而释放了部分内存避免系统进入了夯机状态。通过操作系统控制台的系统概览可以看到 FastOOM 介入的相关记录。</p><p>如下图所示，由于 kube-rbac-proxy 和 node_exporter 等进程 oom_score_adj 被设置为接近 999，FastOOM 会匹配内核策略优先杀死这些进程，但是由于杀死这些进程后释放内存较小，仍处于 Near-OOM；因此 FastOOM 杀死了配置优先杀死的 logcollect 进程。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047440753" alt="图片" title="图片" loading="lazy"/><br/>由于用户态及时介入杀死进程释放出内存，使系统避免进入了 Near-OOM 的抖动状态。</p><h4>案例二：配置Pod级别策略解决Pod应用抖动夯机问题</h4><p>客户遇到的问题<br/>在 Kubernetes 环境中，我们是可以为 Pod 中的容器配置对应的内存限制的，和节点 OOM 同理，如果 Pod 中的内存使用接近限制时，内核也会尝试回收 Pod 中所有可回收内存，才触发 OOM，这时候也会导致 Pod 内业务进程的延时阻塞。</p><p>某大数据客户会部署一些延时敏感的业务 Pod（即 Pod 中运行了多个业务进程）。业务时不时会存在响应长尾延时，但是网络相关指标一切正常。</p><p>后面我们接手问题后，通过 Alibaba Cloud Linux 自研指标（该指标反映容器由于内存回收阻塞的时长）发现，存在非常高的内存回收延时，且时间节点和抖动时间匹配：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440754" alt="图片" title="图片" loading="lazy"/><br/>推荐客户配置 Pod 级别的 FastOOM 后，通过提前杀死 Pod 中的相关内存占用进程，避免了内存回收延时的发生，抖动也不再出现。</p><p>解决方案<br/>操作系统控制台提供较为灵活的 Pod 级别的 OOM 杀进程策略配置，可以灵活配置 Pod 中容器内发生 OOM 时，避免和优先杀死的进程。</p><p>假设在集群中通过名为 test-alinux 的 daemonset 在每一个节点部署了对应的 Pod。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440755" alt="图片" title="图片" loading="lazy"/><br/>在操作系统控制台中设置 Pod 级别 FastOOM 策略：</p><ul><li>为了匹配对应的 Pod，Pod 名称填写 test-alinux（正则表达式会匹配不同节点上的 test-alinux-xxx pod），命名空间为 default。</li><li>由于只是希望控制 OOM 时的杀进程策略，将内存压力级别设置为高，则触发用户态 OOM 的时机会近似于内核 OOM 的时机。</li><li>对于杀进程策略：配置优先杀死特定进程和避免杀死业务进程和 Pod 中的 1 号进程，从而避免 Pod 重启或影响业务，设置完成后下发至特定节点。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440756" alt="图片" title="图片" loading="lazy"/><br/>将配置下发到对应节点后，当 Pod 中容器内存使用超过容器 limit 后，发生 OOM；可以通过操作系统控制台系统概览看到 FastOOM 事件记录，可以看到 FastOOM 根据策略杀死了对应的进程，也避免了特定进程被杀死。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440757" alt="图片" title="图片" loading="lazy"/></p><h3>总结</h3><p>人无完人，内核的 OOM 其实也不是万能的。为了能尽可能的回收内存，内核在发生 OOM 前会阻塞申请内存的进程，并尝试回收内存，这对于延时敏感的业务的影响是非常大的；如果内存持续保持在接近 OOM 的水位，还会进入 Near-OOM 的活锁状态导致整机夯机。阿里云操作系统控制台的 FastOOM 功能，通过相关指标，支持节点/容器/Pod 级策略，可精准杀指定进程，轻松弥补了内核 OOM 带来的延时卡顿问题。</p><p>联系我们 </p><p>您在使用操作系统控制台的过程中，有任何疑问和建议，可以搜索群号：94405014449 加入钉钉群反馈，欢迎大家扫码加入交流。</p><p>阿里云操作系统控制台PC端链接：<a href="https://link.segmentfault.com/?enc=3O5sxluvMq5HZmzvItODNA%3D%3D.6QQLCxt0YNcXqCIvfXOSJ%2FrlX4Us702zjo8Xl5oj2N4ce02jPPE18fdMXR%2B9PJr6" rel="nofollow" target="_blank">https://alinux.console.aliyun.com/</a></p>]]></description></item><item>    <title><![CDATA[企业网盘有什么用？什么是企业网盘 胡萝卜]]></title>    <link>https://segmentfault.com/a/1190000047440769</link>    <guid>https://segmentfault.com/a/1190000047440769</guid>    <pubDate>2025-12-01 14:02:12</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>企业网盘并不是一个单纯的文件存储工具，它更像是一个为企业量身定制的“数字空间”，用来支持团队协作、提升工作效率，同时严格守护企业数据。这篇文章将带你深入了解企业网盘是什么，以及它能够为技术团队带来哪些具体价值。在文中，我们将探索如何通过<a href="https://link.segmentfault.com/?enc=cQgkuflV4RmrpH1wkXOXWg%3D%3D.NVidFg6F2KbF9z7JYVKACfw3p4R9%2BzoIgcwNCqxijLNU0RTZGdJerapqX4RXhMxsIxD%2FvoWo8p12qEhcdo0Mmw%3D%3D" rel="nofollow" target="_blank">企业网盘</a>为团队赋能、优化工作流程，甚至为企业带来长远性的战略意义。</p><p><img width="658" height="350" referrerpolicy="no-referrer" src="/img/bVdjxj5" alt="" title=""/></p><h2>一、什么是企业网盘？</h2><p>在介绍企业网盘之前，让我们设想一下这样一个场景：团队的某一成员急需一份文件，但他不知道文件所在的具体位置；另一个成员不小心上传了错误版本的文件，造成了整个团队工作的进度延迟；更不幸的是，公司的一份重要数据由于设备故障丢失，无法恢复。这些问题听起来似乎毫无技术含量，但它们却是每个企业每天可能面临的真实困境。</p><p>企业网盘正是为了解决这些问题而设计的一个平台。简单来说，企业网盘就是一个专为企业团队设计的云存储解决方案。它不仅提供文件存储服务，还具备灵活的权限管理、高效的共享协作、多终端访问能力、版本控制功能和数据安全保障。通过企业网盘，文件和数据不再只是静态的“资料”，它们开始流动，成为企业团队高效协作的“桥梁”和“纽带”。</p><p>Zoho网盘作为一个完善的企业端解决方案，秉承着“以数据服务团队，以效率驱动成果”的理念，为企业提供了从文件管理到团队协作的一站式解决方案。它不仅简化了传统文件存储的复杂模式，还通过智能化的功能，让数据管理更加高效和安全。</p><h2>二、企业网盘的核心价值</h2><p>企业网盘的作用不仅局限于存储，它更是一个支持团队协作和高效工作的利器。以下是企业网盘的核心价值，也是它成为企业必备工具的关键原因：</p><h3>1.文件集中管理：告别“数据孤岛”</h3><p>“数据孤岛”是今天许多企业的痛点。员工之间的个体存储习惯不同，导致文件散落在不同的设备中，无论是个人电脑、邮件附件还是移动设备，都可能潜藏着企业的重要数据。而这些数据往往缺乏系统化的整理和统一管理，导致查找困难、重复劳动甚至数据丢失。</p><p>企业网盘，将所有文件集中储存在一个统一的云端空间。以Zoho网盘为例，团队成员可以在一个共享的空间内轻松访问、上传和整理文件，不再需要花费大量时间去翻找邮件和手动核对文件版本。Zoho网盘还支持目录结构的清晰化设计，使得文件管理更加优雅而高效。</p><h3>2.权限管理：数据共享与数据保护并行</h3><p>数据共享越方便，安全挑战也越大。企业网盘的一大核心优势就是精细化的权限管理机制。Zoho网盘提供了灵活的权限设置，团队成员可以根据需求对不同的文件赋予查看、编辑或删除权限。这样一来，既保证了文件共享的效率，也能有效避免因权限错误而导致的数据泄露或误操作。</p><p>此外，Zoho网盘的权限管理不仅覆盖到文件层面，还可以细化到文件的某个版本，甚至是与外部合作伙伴的临时共享权限。这种高度定制化的权限设置，让数据保护不再是“叠加式的谨慎”，而是“有计划的开放”。</p><p>3.文件版本控制：拒绝“信息混乱”</p><p>文件版本的冲突，是团队协作的噩梦。尤其是在多人共同参与项目的时候，不同成员往往会对同一个文件进行修改，而由于缺乏系统的版本控制机制，导致文件提供错误版本或丢失关键信息。</p><p>企业网盘通过版本记录功能，有效解决了这一问题。在Zoho网盘中，每一位成员对文件的修改都会自动生成新的版本，而这些版本均可随时回溯。团队可以清晰地看到谁在何时进行过了修改，从而避免数据混乱，提高协作质量。</p><h2>三、企业网盘的实践应用</h2><p>具体到技术团队，企业网盘能够带来哪些实际的好处呢？让我们从一线场景出发，揭示企业网盘能彻底改变工作方式的几个应用：</p><h3>1.高效的跨部门协作</h3><p>技术团队往往需要和产品、运营甚至销售团队进行频繁的沟通与协作。这些跨部门的合作少不了文件共享，例如产品功能表、开发计划书、设计原型以及测试报告等。传统的方式可能需要通过邮件来往或者交接文件，这不仅耗时，还存在文件冲突和遗漏的风险。</p><p>通过Zoho网盘，技术团队可以直接在共享文件夹中创建和修改各类文档，跨部门成员可以实时查看最准确的内容。团队之间的沟通不再受到时间与地点限制，项目推进更加快速流畅。</p><h3>2.远程办公和多终端支持</h3><p>在远程办公成为趋势的当下，企业网盘的重要性愈加凸显。无论团队成员是在办公室、家中还是出差途中，他们都能通过Zoho网盘随时随地访问企业资源。Zoho网盘支持电脑、手机、平板等多终端访问，确保文件的使用场景覆盖率最大化。</p><p>此外，Zoho网盘提供了离线功能，即使网络中断，用户也可以继续使用已同步的文件，这对于突发状况下的工作续航至关重要。</p><h3>3.强大的搜索能力：一秒找到所需</h3><p>技术团队的文件名称往往复杂且大量，但在Zoho网盘的帮助下，通过强大的搜索功能，无论是根据关键词、上传日期还是文件存储路径，都能快速找到所需内容。这样既节省了查找资料的时间，也避免了错误文件的使用。</p><h3>4.数据安全和备份：技术团队的安心守则</h3><p>数据安全对于技术团队来说是至关重要的，不管是源代码、数据库架构还是产品设计方案，这些信息都是企业的核心资产。一旦丢失或泄露，将会带来不可估量的后果。</p><p>Zoho网盘采用全方位的加密技术和自动云备份服务，确保所有文件的绝对安全。即使发生系统崩溃或用户误删，也能通过备份进行恢复。技术团队不用再战战兢兢，如履薄冰地存储重要文件，而可以把更多精力放在创新和问题解决上。</p><h2>四、企业网盘如何为团队赋能？</h2><p>企业网盘以一个简单、却功能强大的平台，为企业团队带来了效率与安全的双重保障。在今天的数字化转型浪潮中，拥有一个高效、可靠又智能的企业网盘，不仅可以优化团队的工作方式，还能为企业在更大的范围内实施协作战略提供技术基础。</p><p>以Zoho网盘为例，它用细腻的功能设计满足技术团队的各种需求，从文件共享到权限管理，从版本控制到数据安全，一步步帮助我们告别传统工作模式中的沟通滞后、数据丢失和低效协作。如果你正在寻找一个能够提升技术团队效率的工具，那么企业网盘，尤其是Zoho网盘，会是一个值得关注的选择！</p><p>“协作是科技的基石，而企业网盘是通向协作之路的桥梁。”</p><p>让我们从今天开始，重新定义团队的工作方式，用科技赋能效率，用协作成就卓越！</p>]]></description></item><item>    <title><![CDATA[干货推荐：分钟级定位 IO 瓶颈，多租户]]></title>    <link>https://segmentfault.com/a/1190000047440773</link>    <guid>https://segmentfault.com/a/1190000047440773</guid>    <pubDate>2025-12-01 14:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3>背景</h3><p>随着云上规模持续扩张，AI 训练数据、实时日志、多媒体内容等数据类型呈指数级增长，推动云存储成为主流选择，同时也带来了 IO 请求量的急剧上升。在多租户云环境中，多个用户共享底层存储资源，高并发访问容易引发 IO 资源争抢，造成性能瓶颈。此外，混合云和多云架构的广泛应用，使得数据在不同云平台间频繁流动，而各异的存储策略和监控体系进一步增加了 IO 问题的排查与定位难度。为了进一步提升问题的解决效率，阿里云操作系统控制台聚焦高频的 IO 异常场景，构建了从问题发现，根因诊断到解决方案的 IO 一键诊断能力。</p><h3>业务痛点解析</h3><h4>痛点1：问题类型只是能力缺失</h4><p>用户普遍缺乏对 IO 异常类型的识别能力（如区分 IO 延迟高还是打满问题），导致无法自主调用针对性诊断工具，必须依赖运维人员介入定位，导致诊断流程效率低下，增加了人力成本。一键诊断能够聚焦于 IO 延迟高、IO 流量异常、iowait 高等几类出现频次高的问题，捕捉 IO 子系统相关的异常，帮助用户快速自动地识别问题类型。</p><h4>痛点2：问题现场丢失与取证困难</h4><p>目前传统监控普遍集成了 OS 的 IO 相关指标，如 await、util、tps、bps 等，同时会依赖指标的突变作为告警依据，但是当指标异常时可能已错过问题发生的窗口期，没法再去针对性地抓取更多帮助信息，获取关键诊断证据（如细粒度的必要辅助信息）。所以快速识别问题并采取相应的措施，是把握住最佳诊断时机的关键。</p><h4>痛点3：监控指标割裂与诊断关联弱</h4><p>现有监控指标体系存在"数据孤岛"现象，各指标独立存在，并且与具体 IO 问题类型缺乏直观的映射关系。例如在 util 指标（硬盘设备的繁忙比率）偏高的时候，往往需关联观察 await 等多个指标，同时结合磁盘 iops、bps 的理论上限来综合判断问题。即使识别出了问题类型，也需要对相应诊断工具有使用方法相关的先验知识，考虑如何根据监控指标的数值来设置诊断参数，而 IO 一键诊断旨在能够屏蔽了这些复杂的关联流程，直抵分析报告。</p><h3>解决方案</h3><h4>架构介绍</h4><p>「阿里云操作系统控制台」提供的 SysOM 管控组件已具备应对 IO 延迟高，IO 流量异常，iowait 高等几类问题的诊断能力，但是客户往往不会允许在机器上常态化执行诊断工具去不停地抓取信息。因此，IO 一键诊断设计为在诊断时段内，周期性读取 IO 监控指标数据来检测异常，定界问题，到最后触发子诊断工具输出报告的模式，实现“发现问题-&gt;诊断问题-&gt;根因分析”的自闭环。</p><p>由于不同的业务场景，关注的指标阈值会不一样，如果统一一个静态阈值覆盖各种场景，很可能引起异常的误报或者漏报，因此 IO 一键诊断通过动态阈值来识别异常，总体架构图设计如下图所示：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047390543" alt="图片" title="图片"/><br/>IO 指标监控：从系统获取 IO 的关键指标，例如 await、util、tps、iops、qu-size、iowait。</p><p>异常识别：当采集到的 IO 指标大于动态阈值时，判定为异常，因此异常识别的核心在于动态阈值的计算，具体算法将在下文解释。</p><p>异常诊断：根据不同的指标异常，触发对应的诊断工具，并且会对触发频率做了一定的限制。</p><p>数据清洗&amp;可视化：根据诊断结果呈现出可视化的输出，给出根因和解决建议。</p><h4>实现原理</h4><p>指标采集</p><p>触发一键诊断后，每间隔cycle毫秒（数值可配置）会读取并计算iowait、iops、bps、qusize、await、util等指标的值，并检查是否有异常。</p><p>动态阈值计算<br/>为了能够识别秒级的 IO 异常行为，需要将系统中采集到的各个孤立的 IO 指标聚合起来，形成对 IO Burst 等问题的监控能力，这个过程的核心在于动态阈值的计算，动态阈值经过三步计算得到：基础阈值计算，补偿阈值计算以及最小阈值计算。</p><p>基础阈值计算<br/>IO 指标其实是一种时间序列，而且一般地，在一个时间区间内，可以认为绝大部分时间是没有异常的，因此序列形成的曲线趋势是趋于平稳的，当出现异常的时候，会产生一个明显偏离平稳趋势的尖峰，因此第一步要做的就是通过本节计算得到的基础阈值把 IO 指标中的尖峰毛刺筛选出来。</p><p>我们通过动态窗口持续观察数据，计算窗口内数据的最大偏离平均值作为“瞬时波动值”。然后，将所有“瞬时波动值”的平均值作为“基础阈值”。这个阈值会持续自适应地更新，以反映数据最新的波动特征。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390544" alt="图片" title="图片" loading="lazy"/></p><p>补偿阈值计算基础阈值曲线（如下图中的黄色曲线）反映的是真实 IO 指标数据的波动情况，但是 IO 指标在平稳状态下往往是限于一个范围内波动，所以需要计算一个补偿阈值，叠加到基础阈值上会减缓基础阈值的快速下降，而从而减少带来误报的情况。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390545" alt="图片" title="图片" loading="lazy"/></p><p>当基础阈值持续下降一段时间后，可以认为系统进入“常态稳定”模式。此时，我们会过滤掉明显的噪音数据，并在剩余的“安静”数据中，计算一个“常稳态补偿值”来衡量这种稳定状态下的微小波动。在“常稳态补偿值”正式计算出来之前，我们会临时用当前窗口最大的基础阈值作为补偿值，并且在每个新窗口开始时都重置。一旦基础阈值停止下降或反弹，该机制将重置，回归更宏观的观察模式。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390546" alt="图片" title="图片" loading="lazy"/></p><p>最小阈值<br/>最小静态阈值是一个预先设定好的最低门槛，。最终的异常判定阈值为 “最小静态阈值” 和 “动态调整阈值（基础阈值 + 补偿值）” 两者中的最大值，确保只有同时超过业务容忍底线和系统动态波动范围的数据才被视为异常。</p><p>特别地，如果数据已超出“最小静态阈值”，则“动态调整阈值”的计算会简化，不再考虑“常态补偿值”，直接使用“基础阈值”作为判断依据，以聚焦更明显的异常情况。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390547" alt="图片" title="图片" loading="lazy"/></p><p>异常识别<br/>当采集到的 IO 指标大于动态阈值时判定为异常。不同异常类型虽有各自的判断算法，但都遵循以下原则：</p><ul><li>确定警戒线： 设定一个“指标警戒线”，取 “最小静态阈值”（业务容忍的最低门槛）与“动态阈值”（系统根据历史数据计算的正常波动范围）中的最大值。</li><li>触发诊断： 若当前指标值超过此“警戒线”，且监测和诊断条件满足，则立即启动诊断。</li><li>动态学习： 系统会持续根据最新的指标数据，更新并调整“动态阈值”，使其始终反映指标的正常波动范围。</li></ul><p>智能诊断</p><p>当系统监测到 IO 异常时，一键诊断工具能够自动调用诊断功能，及时抓取和分析关键信息，快速定位问题。为避免诊断过于频繁，我们通过以下参数进行频率控制：</p><ul><li>“诊断冷静期”（triggerInterval）： 设定两次诊断之间的最短间隔，确保系统不会在短时间内重复诊断。</li><li>“异常堆积计数器”（reportInterval）： 控制诊断发起的条件。若为0，则异常发生且过了冷静期即可诊断；若不为0，则需在冷静期过后，且在规定时间内积累了足够数量的异常事件，才触发诊断。</li></ul><p>根因分析<br/>在诊断工具抓取了信息之后，面对各种信息，从何处着手，也令人困扰，因此瞄准方向，进行专业的分析、剥丝抽茧地从中筛查跟问题相关的线索显得非常重要；IO 一键诊断则具备这个抽丝剥茧的分析能力，并且能够汇报跟问题相关的结论性信息：</p><ul><li>对于 IO Burst 异常，经过分析后，在监控的日志栏中汇报异常期间贡献IO最多的进程，其中极具特色的是，对于写 buffer io 后由 kworker 刷脏的情况，也能分析出来是哪个进程在写 buffer io。</li><li>对于 IO 高延迟异常，经过分析后，在监控的日志栏中汇报异常期间 IO 的延迟分布，输出 IO 延迟最大的路径。</li><li>对于 iowait 高异常，经过分析后，在监控的日志栏中汇报触发 iowait 高的进程、以及触发原因。</li></ul><p>案例分析</p><p>iowait 高</p><p>对于 iowait 高异常场景，IO 一键诊断可以直接定位到等待磁盘 IO 的进程来源以及等待时长，分析阻塞的原因。以下案例即是诊断出业务场景 IO 压力过大，脏页过多过多，导致业务进程 task_server 等待 IO 时长过长的问题。对此场景，报告中也提出谨慎地调整 dirty_ratio和dirty_bytes 参数，来减少刷脏压力，从而缓解 IO 压力的建议。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440789" alt="图片" title="图片" loading="lazy"/></p><p>IO 延迟高</p><p>用户通过监控发现机器上 IO 写流量出现了延迟比较高的现象，我们建议他尝试通过 IO 一键诊断来判断根因。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390548" alt="图片" title="图片" loading="lazy"/></p><p>在用户执行的结果中，诊断识别到了是 DiskBlockWrite 进程产生的 IO 压力，主要延迟集中在磁盘刷脏，帮助用户查到了延迟根因。对此，我们在结果中建议用户尝试减少 buffer IO 的写入或者调整机器上的配置的 dirty_ratio 和 dirty_background_ratio 参数数值，来缓解 IO 延迟高的问题。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047390549" alt="图片" title="图片" loading="lazy"/></p><p>联系我们 </p><p>您在使用操作系统控制台的过程中，有任何疑问和建议，可以搜索群号：94405014449 加入钉钉群反馈，欢迎大家扫码加入交流。</p><p>阿里云操作系统控制台PC端链接：<a href="https://link.segmentfault.com/?enc=tuhLgWJ2kIVfFxQygoghrw%3D%3D.tXs2hmOEAd%2BpqdhC6qUsnIMMB1whK4Zyi%2FOW%2BglxWpLx0xnZMhxd6LLWa1S0MyJo" rel="nofollow" target="_blank">https://alinux.console.aliyun.com/</a></p>]]></description></item><item>    <title><![CDATA[国内打开国外网站很慢是什么原因？如何解决]]></title>    <link>https://segmentfault.com/a/1190000047440631</link>    <guid>https://segmentfault.com/a/1190000047440631</guid>    <pubDate>2025-12-01 13:02:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>因为地区和网络的限制原因，在国内访问国外网站大部分很慢或者有些的直接打不开，需要借助科学上网工具才能访问，这对于外贸人员来是最基本的工具了。</p><p>目前，企业级、合规访问国际网络主要有两种方式：</p><p>① 传统国际网络专线</p><p>② SD-WAN 国际专线</p><p>一、传统国际网络专线(IEPL/MPLS 国际专线)</p><ol><li>什么是传统国际专线?</li></ol><p>传统国际网络专线(如 IEPL、MPLS)是运营商提供的点对点或点到多点的跨境通信线路。属于官方许可、可备案、面向企业级的合规国际通信方式。</p><p>简单理解：</p><p>运营商拉一条“独享高速通道”，从国内机房直连你在海外的服务器或节点。</p><ol start="2"><li>核心特点<br/><img width="723" height="217" referrerpolicy="no-referrer" src="/img/bVdndDw" alt="截屏2025-12-01 12.02.18.png" title="截屏2025-12-01 12.02.18.png"/></li><li>适用场景</li></ol><p>适合金融、医疗等敏感行业</p><p>高要求场景：低时延、强稳定、可审计</p><p>二、SD-WAN 国际专线(软件定义国际网络)</p><ol><li>什么是 SD-WAN 国际专线?</li></ol><p>SD-WAN 是一种智能网络组网技术，通过软硬件终端 + 多线路融合，让企业可以灵活、成本更低地连接海外网络。</p><p>相比传统专线，它不是单一的物理线路，而是：</p><p>在合规基础上，通过智能路由、多线叠加、QoS 优化，实现跨境网络稳定访问。</p><p>一般使用：</p><p>三大运营商合规出口、海外节点、智能调度引擎</p><p>构成一个 可控、可监测、可审计的企业级跨境网络通道。</p><ol start="2"><li>核心特点</li></ol><p><img width="723" height="216" referrerpolicy="no-referrer" src="/img/bVdndDx" alt="截屏2025-12-01 12.02.46.png" title="截屏2025-12-01 12.02.46.png" loading="lazy"/></p><ol start="3"><li>适用场景</li></ol><p>外贸企业访问海外平台(Google、Meta、WhatsApp、HubSpot 等)</p><p>跨境电商运营(亚马逊、TikTok、独立站)</p><p>海外社媒营销、广告账户管理、跨境直播、视频会议（如zoom）等等场景，性价比高。</p><p>三、SD-WAN国际网络专线怎么开通使用？哪家服务商好？</p><p>下面以OSDWAN为例，给大家介绍怎么开通，简单三步：</p><p>1、确认自身的需求</p><p>比如您是做什么业务的，需要使用国外的哪些平台以及国家，是外贸办公、还是社媒运营，或者是做Tk直播的，不同的场景我们OSDWAN提供不同的套餐，直播的话建议使用专线，最低5M以上的带宽。</p><p>2、选择合适的服务商</p><p>OSDWAN是国内专业的跨境网络专线服务商，提供合规稳定的网络专线，并且是通过工信部备案的，拥有合法资质的，走的是跟三大运营商一样的线路，灵活性高，性价比高，咨询我们的顾问选择合适的套餐，开通账号即可登录连接。</p><p>3、登录使用</p><p>下面以电脑端使用界面为例，手机等设备操作类似。</p><p>账号登录成功后：</p><p>第一步：选择线路，比如有美国、新加坡、日本、香港等等。</p><p>第二步：不同模式对于重大加速软件不同。</p><p>第三步：点击连接，连接成功就可以访问国际网络了。</p><p><img width="720" height="452" referrerpolicy="no-referrer" src="/img/bVdndDy" alt="image.png" title="image.png" loading="lazy"/></p><p>下面以访问Google为例，能使用Google正常搜索那么其他国外软件也都能访问了。</p><p><img width="720" height="315" referrerpolicy="no-referrer" src="/img/bVdndDz" alt="image.png" title="image.png" loading="lazy"/></p><p>OSDWAN有哪些优势？<br/>相较于传统的SD-WAN服务商，OSDWAN跨境网络专线也有极大突出优势：更好用、更高性价比、更安心。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440633" alt="图片" title="图片" loading="lazy"/></p><p>01、更好用：相比传统SD-WAN服务商只支持CPE设备，OSDWAN不仅支持多种型号的CPE设备，还支持经过安全认证的相应软件。支持Windows、Mac、iPhone、安卓、iPad，让您随时随地一键连接全球互联网。</p><p>02、更高性价比：相比传统SD-WAN服务商与运营商接近的高额网络费用，OSDWAN仅需一半不到的成本即可享受同等优质的网络线路。</p><p>03、更安心：相比传统SD-WAN服务商需要5-8个工作日按照工单解决客户问题，OSDWAN提供专属售后支持，配备专属售后顾问。同时还提供分流解锁，路由优化等服务。让您的业务安心出海。</p><p>OSDWAN兼具合规合法、稳定安全、简单易用、高性价比等优势，支持一键访问全球互联网。是企业办公、网络营销、跨境直播的不二之选。</p><p>OSDWAN提供高质量SD-WAN线路和原生本土IP，支持手机/电脑/路由器多种设备。专线费用不到营业厅的一半，已有10000+用户通过OSDWAN连接全球。</p>]]></description></item><item>    <title><![CDATA[SD-WAN国际专线怎么购买？哪家SD-]]></title>    <link>https://segmentfault.com/a/1190000047440638</link>    <guid>https://segmentfault.com/a/1190000047440638</guid>    <pubDate>2025-12-01 13:02:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着企业越来越全球化——无论是跨国子公司、海外云资源接入，还是跨境电商、出海团队办公——网络连接的重要性愈发凸显。传统国际专线（如 MPLS）固然稳定，但成本高、部署慢、灵活性差。近年来，SD-WAN 国际专线成为一种非常有吸引力的替代方案，既保持较低时延、较高稳定性，又比传统专线更灵活可扩展。</p><p>本文将介绍什么是 SD-WAN 国际专线、适合哪些场景、主流服务商有哪些，以及如何选合适的服务商。其中，我们还特别推荐 OSDWAN（明点跨境） 这一国内较有特色的服务商，并分析为什么值得考虑。最后还帮你梳理一些购买和落地时常遇到的问题。</p><p>一、SD-WAN 国际专线是什么？哪些场景需要？<br/>SD-WAN（软件定义广域网） 是一种通过软件层（controller /管理层）来动态管理多个底层链路（如互联网、MPLS、4G/5G 等），实现智能选路、流量调度、加密隧道等功能。<br/>“国际专线”＋“SD-WAN”结合后，意味着企业可以构建一个跨国 / 跨地区的“专用逻辑网络”：虽然底层可能是公共互联网链路，但通过 SD-WAN 的覆盖、加密和策略管理，实现类似传统专线的稳定性和性能。<br/>SD-WAN 专线还可以混用多条链路，如互联网 + MPLS + 4G，做到冗余、高可用。<br/>为什么需要SD-WAN国际专线？</p><p>企业选择 SD-WAN 国际专线，通常基于以下几类业务需求：</p><p>跨境办公</p><p>海外子公司、分支机构、远程团队需要和总部或其他分支进行低延迟通信。</p><p>云 / SaaS 接入</p><p>公司使用海外云(如 AWS、Azure、GCP)或 SaaS(Salesforce、Office 365 等)，希望通过优化网络路径提高访问体验。</p><p>全球化业务</p><p>跨境电商、品牌出海、海外技术团队、跨国生产制造等，数据要在多个国家 / 地区之间传输。</p><p>成本与灵活性考虑</p><p>传统 MPLS 专线成本高、开通慢;SD-WAN 国际专线则可以更灵活扩容、按需调度。</p><p>网络弹性与高可用性</p><p>通过多链路冗余 + 智能选路，实现链路中断时快速切换，提升业务连续性。</p><p>安全性要求</p><p>使用加密隧道(如 IPSec)保护跨国传输的数据，还能集中管理策略、流量优先级等。</p><p>二、SD-WAN 服务商排行榜</p><p><img width="723" height="1726" referrerpolicy="no-referrer" src="/img/bVdm1ZO" alt="image.png" title="image.png"/><br/>注：以上排名来自明点企服SaaS点评网，排序根据产品评分、站内外热度综合计算得出，会不断发生变化，截取日期为2025年4月22日</p><p>三、主流 SD-WAN 服务商介绍<br/>下面详细介绍几家在国际专线 /跨国 SD-WAN 方面比较靠谱的服务商。</p><p>1、三大运营商</p><p>中国电信：凭借全国最大网络基础设施资源，中国电信在SD-WAN建设中具备天然优势，其端到端网络服务能力保障了政企客户对高可用性、高稳定性的严苛要求。</p><p>中国移动：作为国内移动网络领导者，中国移动在SD-WAN架构中实现了对5G链路的高效融合，在零售、制造等场景中展现出极强的灵活性和冗余能力。</p><p>中国联通：中国联通在SD-WAN的跨境组网服务方面具有显著优势，尤其在“一带一路”相关地区设有大量网络节点。</p><p>2、第三方专业服务商</p><p>OSDWAN明点跨境</p><p>OSDWAN作为国内专业的跨境网络服务商，为出海企业提供合规、高速、稳定的网络解决方案，支持硬件、软件方案灵活部署。</p><p>OSDWAN在全球的数据中心节点50个，POP节点超过200个，可以为出海企业提供海外加速、SaaS加速、SD-WAN组网、跨境组网、云专线等产品服务，助力中国企业开拓国际市场。</p><p>适用于社媒运营、TK直播、学术科研、跨境电商、品牌出海、外贸出口等各类行业场景。</p><p><img width="722" height="647" referrerpolicy="no-referrer" src="/img/bVdndDI" alt="image.png" title="image.png" loading="lazy"/></p><p>腾讯云SD-WAN</p><p>腾讯云SD-WAN 接入服务(SD-WAN Access Service)助力多分支轻松实现与云、数据中心的任意互联，具有即插即用、多地域覆盖、智能管控等特性，为企业多分支提供了更简单、可靠、智能的一站式上云的体验。</p><p>四、如何选择合适的 SD-WAN 服务商？<br/>结合业务需求和技术特点，选 SD-WAN 服务商可以按照以下几个维度来评估：</p><p>1、业务需求分析</p><p>需要多大带宽、用于什么业务（TK直播、社媒运营、多账号矩阵等）</p><p>2、计费模式</p><p>是按带宽、按流量，还是混合计费？哪个模型对你更划算。</p><p>收费灵活性如何，可按月、按季度、按年付吗?</p><p>3、可靠性与 SLA</p><p>服务商能否保证丢包率、延迟、可用性 (SLA)?</p><p>是否支持链路冗余 (多链路 +智能 failover)?</p><p>4、安全性</p><p>是否使用加密隧道 (如 IPSec)?</p><p>是否提供云端 /设备端安全能力 (防火墙、IPS、访问控制等)?</p><p>五、SD-WAN服务商哪家好？推荐 OSDWAN<br/>综合考虑价格、灵活性、覆盖和本地服务能力， OSDWAN 是国内 /出海企业在选择 SD-WAN 国际专线时非常值得重点考虑的方案：</p><p>高性价比：基础版 (690 元/年起)，适用于AI应用加速、外贸办公等场景。<br/>灵活计费：支持按月、季度、年度收费，适合不同业务的企业。<br/>全球布局：其 POP 节点覆盖200+个国际重要节点，能为跨境业务提供较为稳定的网络连接。<br/>合规可靠：OSDWAN提供合法合规的跨境网络专线，通过工信部备案的拥有合法资质的服务商。<br/>快速部署：结合SD-WAN 的架构优势，当日即可开通，一分钟即可连接使用。<br/>因此，如果中国企业，有跨境业务、出海电商、海内外分支需要互联，建议优先优先OSDWAN。</p><p>六、SD-WAN专线常见问题<br/>问：SD-WAN 是否能完全替代 MPLS?</p><p>答：不一定。SD-WAN 优势在灵活、弹性、成本，但对于某些对时延 / SLA 要求极高 (如金融、实时交易) 的业务，可能仍然需要 MPLS 或混合方案。</p><p>问：SD-WAN 和传统 VPN (如 IPsec VPN) 有什么区别?</p><p>答：传统 VPN 是在公共互联网基础上建隧道，功能较为基础;但 SD-WAN 除了加密隧道，还能做路径选择、QoS、策略控制。</p><p>问：部署周期多久?</p><p>答：相比 MPLS 专线 (可能需要数周或数月)，OSDWAN的专线当日即可开通，一分钟即可连接使用。</p><p>问：价格大致范围是多少?</p><p>答：具体取决于带宽、链路类型、计费方式。</p><p>问：是否存在安全隐患?</p><p>答：只要服务商正确实现加密隧道 (如 IPSec)、策略管理、冗余链路，并提供监控，就可以较好保证安全。但选择时应重点考察服务商的安全能力与 SLA。</p><p>问：如果业务变化 (扩容 ) 怎么办?</p><p>答：大多数 SD-WAN 服务商都支持灵活扩容 (调整带宽、链路类型);你可以根据业务来调整订阅 /服务。</p><p>结语<br/>总之，SD-WAN 国际专线是现代企业跨国 /跨境网络连接非常有效的新方案。它既能降低传统专线成本，又能兼顾性能和灵活性。如果你的公司有跨境办公、全球受众、云接入等需求，非常值得认真考虑 SD-WAN。选服务商时，要看技术能力、网络覆盖、计费灵活性、安全性和合规性。</p>]]></description></item><item>    <title><![CDATA[2024最新贪心科技-大模型开发应用实战]]></title>    <link>https://segmentfault.com/a/1190000047440667</link>    <guid>https://segmentfault.com/a/1190000047440667</guid>    <pubDate>2025-12-01 13:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在大模型技术席卷各行各业的今天，👇🏻ke🍊：xingkeit点top/9645/许多学习者陷入了"纸上谈兵"的困境——了解概念却无法实战，知道技术却不会应用。30天系统化实战训练，正是打通从理论到实践的关键路径，让学习者完整掌握大模型应用开发的核心能力。</p><p>第一周：掌握与大模型对话的艺术——Prompt工程的精髓<br/>基础奠基：从零理解Prompt机制<br/>大模型并非神秘的黑箱，而是需要精确指令的"智能大脑"。第一周的训练从理解Prompt的基本结构开始，探索如何通过系统提示词、示例演示、格式约束等要素，让模型理解我们的真实意图。</p><p>场景化实战：四大核心技巧</p><p>角色扮演技巧：通过赋予模型特定身份（如资深律师、医学专家），获得专业领域的精准回答</p><p>思维链引导：使用"逐步思考"等技巧，让模型展示推理过程，提升答案的准确性和可信度</p><p>结构化输出：约束模型按照JSON、XML等特定格式输出，便于后续程序处理</p><p>动态上下文管理：学会在长对话中维护上下文一致性，避免模型"遗忘"重要信息</p><p>超越基础：高级Prompt模式<br/>深入学习少数示例、思维树等先进技术，理解如何在复杂问题中引导模型进行深度推理，突破基础Prompt的性能瓶颈。</p><p>第二周：构建企业级知识大脑——RAG系统实战<br/>从理论到架构：构建可对话的知识库<br/>传统的企业知识管理系统正在被RAG技术重新定义。第二周重点演练如何将静态文档转化为可智能问答的知识系统。</p><p>完整实现流程：</p><p>文档解析与预处理：处理PDF、Word、网页等多格式文档，解决表格、代码块等特殊内容的提取难题</p><p>文本向量化核心：理解嵌入模型的工作原理，将文本转化为数学向量，构建企业的"数字记忆"</p><p>智能检索优化：实践相似度检索、混合搜索等策略，确保快速精准定位相关信息</p><p>生成环节调优：设计合理的提示模板，让模型基于检索内容生成准确、可靠的回答</p><p>工程化思维培养：<br/>重点突破RAG系统中的实际挑战：如何处理文档更新？怎样评估检索质量？如何应对"幻觉"问题？这些工程细节正是企业应用成败的关键。</p><p>第三周：打造专属领域专家——模型微调深度实践<br/>何时需要微调：技术选型智慧<br/>深入理解微调与Prompt工程、RAG的适用场景差异。当需要模型掌握独特风格、专业术语或复杂推理模式时，微调成为不可替代的选择。</p><p>全流程实战：</p><p>数据准备艺术：学习构建高质量的指令微调数据集，理解数据质量对模型性能的决定性影响</p><p>训练策略选择：实践LoRA等参数高效微调方法，在效果与成本间找到最佳平衡点</p><p>评估体系建立：超越简单的准确率指标，构建多维度的模型能力评估体系</p><p>迭代优化循环：基于评估结果持续改进数据质量和训练策略，实现模型性能的稳步提升</p><p>避坑指南：<br/>分享实践中常见的失败案例：过拟合的识别与应对、灾难性遗忘的预防、训练不稳定的调试技巧，让学习者少走弯路。</p><p>第四周：迈向自主智能——AI智能体开发实战<br/>智能体范式转变：从工具到伙伴<br/>智能体代表了大模型应用的未来方向——不再是简单的问答工具，而是能够自主规划、执行复杂任务的数字伙伴。</p><p>核心能力构建：</p><p>任务分解与规划：训练智能体将复杂目标拆解为可执行步骤，形成合理的行动计划</p><p>工具使用能力：集成搜索引擎、计算器、API接口等外部工具，扩展智能体的能力边界</p><p>记忆与反思机制：设计智能体的长期记忆系统，使其能够从历史交互中学习改进</p><p>安全护栏设计：建立约束机制，确保智能体行为符合安全规范和伦理要求</p><p>典型场景实战：<br/>通过客户服务智能体、数据分析智能体、个人助理智能体等实际案例，掌握智能体设计的通用模式和特定领域的最佳实践。</p><p>从学习到创造：工程思维的升华<br/>30天的实战之旅，收获的远不止技术技能：</p><p>系统化思维培养：<br/>理解Prompt工程、RAG、微调、智能体这四大技术如何相互配合，形成完整的大模型应用技术栈。学会根据具体需求选择最合适的技术组合。</p><p>工程化能力提升：<br/>掌握大模型应用的完整生命周期管理——从需求分析、技术选型、实现调试到部署运维。建立质量保障意识，确保应用的可靠性和稳定性。</p><p>业务价值导向：<br/>培养将技术能力转化为业务价值的关键思维。无论是提升企业内部效率，还是创造新的产品服务，都能够精准把握技术应用的商业逻辑。</p><p>持续学习基础：<br/>建立扎实的技术基础和理解框架，为快速适应这个日新月异的领域做好准备，具备持续自学和跟进最新进展的能力。</p><p>这30天的价值，在于完成从被动学习到主动创造的转变，从技术理解到价值实现的跨越。当您能够独立设计并实现满足复杂需求的大模型应用时，您已经在这个充满机遇的新时代占据了有利位置。</p>]]></description></item><item>    <title><![CDATA[2025主流音视频厂商选型指南 看点 ]]></title>    <link>https://segmentfault.com/a/1190000047440260</link>    <guid>https://segmentfault.com/a/1190000047440260</guid>    <pubDate>2025-12-01 12:05:33</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>2025主流音视频厂商选型指南<br/>在数字时代，音视频技术已成为重要的基建工程。然而，面对众多音视频厂商，如何选出最适合自己的，并非易事。面对各厂商的宣传，究竟谁的硬实力更强，谁更契合自身业务场景？这份指南聚焦2025年国内主流音视频厂商，摒弃虚浮宣传，对比核心技术和实际场景表现，助你在最短时间内把握关键，做出明智选择。</p><p>2025年主流音视频厂商盘点<br/>云屋科技<br/>云屋科技作为全球领先的实时音视频云服务提供商，在2025年依旧保持技术领先地位。</p><p>全自研引擎：拥有具备完全自主知识产权的音视频引擎，即使在80%丢包的环境下，仍能保障通话流畅。</p><p>超低延迟：其全球智能调度网络可实现端到端平均延迟小于200ms，达到行业标杆水平。</p><p>AI对话式交互：具备实时语音识别与语义理解能力，可驱动高效自然的人机对话。</p><p>全球覆盖：拥有500多个全球节点，服务覆盖200多个国家和地区。</p><p>腾讯云TRTC<br/>依托腾讯强大的生态体系，腾讯云TRTC在社交、游戏场景中具有独特优势，与微信、QQ等产品的集成能力是其核心竞争力。</p><p>生态整合：与微信、QQ等腾讯系产品深度集成，支持小程序优化。</p><p>社交优势：在社交、游戏场景表现出色，能够支持高并发场景。</p><p>产品协同：可与腾讯云其他产品形成完整解决方案。</p><p>阿里云RTC<br/>凭借阿里云的基础设施优势，阿里云RTC为企业提供一站式音视频解决方案，在电商、企业服务场景中表现突出。</p><p>基础设施：依托阿里云全球2800多个边缘节点，基础设施十分强大。</p><p>电商优化：针对电商直播场景进行专项优化，效果显著。</p><p>弱网对抗：采用智能抗丢包技术，在60%丢包率的情况下仍可保持通话。</p><p>AI集成：深度集成智能美颜、语音识别等AI能力。</p><p>声网（Agora）<br/>作为实时互动云服务的开创者，声网在技术积累和客户规模方面保持优势，其SD - RTN全球网络持续优化。</p><p>全球网络：自主研发的SD - RTN全球实时网络，具备智能路由优化功能。</p><p>音频技术：采用3D空间音频技术，可创造沉浸式听觉体验。</p><p>视频能力：支持4K超高清视频传输，具备自适应码率控制能力。</p><p>生态完善：拥有成熟的开发者社区和完善的技术文档体系。</p><p>融云<br/>融云提供音视频 + IM + 白板等一体化解决方案。</p><p>技术积累：整合了20余年的音视频技术积累，底蕴深厚。</p><p>弱网对抗：在80%丢包环境下仍能保持可用通信，抗丢包能力强。</p><p>教育方案：音视频 + IM + 白板一体化教育解决方案完善。</p><p>音质优化：可保障1080P高清视频和48kHz高保真音质。</p><p>火山引擎<br/>承载抖音等产品的音视频技术积累，火山引擎在视频处理、智能推荐等方面具有独特优势。</p><p>技术验证：承载了抖音等亿级用户产品的技术积累，经过海量验证。</p><p>视频处理：超高清视频编码优化，智能视频增强技术领先。</p><p>推荐算法：具备独特的智能内容推荐能力，可提升用户体验。</p><p>六大厂商核心能力对比<br/>为确保线上交互达到最佳体验，选择音视频厂商时应重点关注五大关键能力：全球覆盖的网络、先进的编解码、智能的音视频增强、优异的延时表现以及对业务场景的精准适配度。以下是服务选型与对比的核心依据：</p><p>能力维度    云屋科技    腾讯云<br/>阿里云    声网    融云    火山引擎    <br/>全球网络覆盖    强：拥有自研引擎和全球网络，自主调度和容灾能力出色    强：依托腾讯全球基础设施，与微信等生态协同，覆盖范围广    强：基于阿里云全球领先的云计算基础设施，服务稳定性和可用性高    强：以软件定义实时网为核心，专为实时互动优化，全球节点丰富    中强：具备全球服务能力，但更聚焦深耕领域    中强：依托字节跳动的全球基础设施，在娱乐和社交区域覆盖良好    <br/>音视频编解码能力    强：自研引擎通常对编解码有深度优化，并结合AI增强提升效率    强：集成腾讯多媒体实验室的先进技术，对标准编解码器深度优化    强：基于强大的云基础，在标准编解码和转码处理方面能力扎实    强：深度优化抗弱网与抗丢包编解码，技术遵循国际标准，体验较好    强：编解码技术成熟，抗弱网性能强，保障实时通话流畅清晰    强：继承抖音在视频压缩和传输方面的技术，尤其在移动端优化出色    <br/>音视频增强功能    技术前沿：具备AI增强、纯净细腻音质、超分技术，AI功能突出    生态集成强：功能全面，与微信小程序等腾讯生态的集成是特殊优势    场景化强：在电商场景优化（如试妆、虚拟背景）方面有针对性功能    丰富：通过虚拟背景、美颜等特效，精准赋能在线教育、直播电商等多元场景    垂直领域强：核心优势在于游戏语音优化（如3D语音、听声辨位）    智能推荐结合：功能全面，且能与智能推荐等算法结合，提供差异化体验    <br/>延时表现    极优：端到端延迟＜200ms，表现最佳，采用场景化AI音频处理策略，无感切换至最佳音质，实时体验卓越    优：端到端延迟200 - 400ms，可支持低延时直播场景，与TRTC产品结合    优：端到端延迟200 - 400ms，标准化的低延时直播方案成熟稳定    优：端到端延迟200 - 300ms，依托SD - RTN网络，在实时性和稳定性上平衡良好    优：端到端延迟200 - 400ms，能满足游戏直播、教育直播等大部分低延时需求    优：端到端延迟200 - 350ms，基于抖音大规模实践，在高并发直播场景下表现可靠    <br/>典型应用场景    社交、教育、IoT    社交、游戏    电商、办公    社交、教育    游戏、教育    娱乐、社交    <br/>各厂商核心定位<br/>腾讯、阿里、火山引擎：依托庞大云生态，提供一站式、标准化的通用解决方案。</p><p>声网、融云：深耕音视频垂直赛道，在特定场景与体验优化上更具深度。</p><p>推荐云屋科技的理由<br/>全球极致低延时：端到端延迟＜200ms，树立实时互动体验新标杆。</p><p>全链路自研技术：从音视频引擎、全球网络到AI算法全部自主可控，安全稳定。</p><p>领先AI增强体验：集成超分、悦音等先进处理技术，显著提升音视频质量。</p><p>结论<br/>在追求极限低延迟、卓越音画质与高度技术可控性的场景下，云屋科技是更为专业和可靠的选择。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440262" alt="" title=""/></p><p>常见问题解答FAQ<br/>Q1：如何测试各家厂商宣传的“抗丢包”和“低延迟”效果是否真实？<br/>解决方案：</p><p>要求POC测试：不要仅看数据，务必申请正式试用，进行概念验证测试。</p><p>模拟真实网络：在测试环境中，使用网络模拟工具主动制造不同比例的丢包、抖动和延迟，直观感受通话质量。</p><p>关注关键指标：在测试后台重点关注端到端延迟、视频卡顿率、音频断断续续等核心指标，而非单一的丢包率。</p><p>Q2：我们的业务用户遍布全球，如何确保海外用户的体验？<br/>解决方案：</p><p>核查全球节点：仔细询问厂商其海外数据中心的分布和数量，特别是与你目标用户区域的重合度。</p><p>测试全球路由：选择支持全球智能路由调度的厂商（如云屋、声网），确保用户能自动接入最优节点。</p><p>了解合规性：确认厂商在目标地区的数据合规性（如GDPR），避免法律风险。</p><p>Q3：初创公司预算有限，如何平衡成本与性能？<br/>解决方案：</p><p>明晰计费模式：了解是按时长、流量还是峰值人数计费，选择最符合你业务模型的方案。</p><p>善用套餐包：云屋、腾讯云等常提供具有价格优势的套餐包，适合用量可预测的场景。</p><p>关注“技术溢价”：如果低延迟和高稳定性是你的核心价值（如在线教育、金融客服），云屋等厂商的技术优势带来的用户体验提升，其“溢价”是值得的。</p><p>Q4：除了音视频通话，我们还需要IM、白板、录制等功能，如何选择？<br/>解决方案：</p><p>评估一体化方案：优先考虑能提供“音视频 + IM + 白板”一站式解决方案的厂商（如云屋科技、融云），可以大幅降低集成复杂度和联调成本。</p><p>检查API兼容性：即使选择不同厂商的组合，也要确保它们的API能够顺畅对接，避免出现“信息孤岛”。</p><p>考虑数据打通：一体化方案通常能更好地实现各模块间的数据联动（如白板与录制回放同步）。</p><p>Q5：集成SDK后，在实际用户环境中遇到偶发的卡顿、杂音问题，如何快速定位？<br/>解决方案：</p><p>利用质量监控平台：选择提供完善质量监控与回溯平台的厂商，能够快速查询每次通话的详细质量数据，定位是网络问题、设备问题还是服务端问题。</p><p>集成客户端日志：确保在SDK中开启了日志上报功能，以便在用户反馈问题时能拉取到详细的客户端日志进行分析。</p><p>考察技术支持：在选型时，就应考察厂商的技术支持响应速度和技术能力，这对于解决线上紧急问题至关重要。</p><p>通过以上常见问题的解答，你不仅能更好地理解厂商的技术宣传，也能更系统地进行测试和选型，最终找到那个真正懂你业务、能解决你实际痛点的“最佳拍档”。</p>]]></description></item><item>    <title><![CDATA[Java记录类入门：简化的以数据为中心的]]></title>    <link>https://segmentfault.com/a/1190000047440457</link>    <guid>https://segmentfault.com/a/1190000047440457</guid>    <pubDate>2025-12-01 12:04:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>记录类声明是一种在Java类中封装数据同时减少样板代码的高效方式。本文将通过基础及高级编程场景介绍其工作原理。</blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440459" alt="文件柜中的文件记录 图片来源：Stokkete / Shutterstock*  " title="文件柜中的文件记录 图片来源：Stokkete / Shutterstock*  "/></p><p>Java记录类是一种用于存储数据的新型类。无需编写构造方法、访问器、<code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code> 的样板代码，只需声明字段，<strong>Java编译器</strong>便会自动处理其余部分。本文将通过基础与高级用例示例，以及不适用记录类的场景，带您全面了解Java记录类。</p><blockquote><strong>注意：Java记录类在JDK 16中正式定型。</strong></blockquote><h2>Java编译器如何处理记录类</h2><p>传统Java创建简单数据类需要大量样板代码。以下通过<a href="https://link.segmentfault.com/?enc=q4MZVQ5QLRHsTRxgYcmWBQ%3D%3D.LHxLkfSMyKXXWwM7zNVT5CBTaG3P9Wn9g7%2FuBo22U7Q%3D" rel="nofollow" target="_blank"><strong>Java吉祥物</strong></a>Duke和Juggy的示例说明：</p><pre><code class="java">public class JavaMascot {
    private final String name;
    private final int yearCreated;

    public JavaMascot(String name, int yearCreated) {
        this.name = name;
        this.yearCreated = yearCreated;
    }

    public String getName() { return name; }
    public int getYearCreated() { return yearCreated; }

    // 为简洁起见，省略equals、hashCode和toString方法
}</code></pre><p>使用记录类后，上述代码可简化为单行：</p><pre><code class="java">public record JavaMascot(String name, int yearCreated) {}</code></pre><p>这一简洁声明自动提供了私有final字段、构造方法、访问器方法，以及正确实现的 <code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code> 方法。  </p><p>定义记录类后，即可投入使用：</p><pre><code class="java">public class RecordExample {
    public static void main(String[] args) {
        JavaMascot duke = new JavaMascot("Duke", 1996);
        JavaMascot juggy1 = new JavaMascot("Juggy", 2005);
        JavaMascot juggy2 = new JavaMascot("Juggy", 2005);

        System.out.println(duke); // 输出：JavaMascot[name=Duke, yearCreated=1996]
        System.out.println(juggy1.equals(juggy2)); // 输出：true
        System.out.println(duke.equals(juggy1));   // 输出：false
        System.out.println("吉祥物名称：" + duke.name());
        System.out.println("创建年份：" + duke.yearCreated());
    }
}</code></pre><p>记录类自动提供有意义的字符串表示、基于值的等值比较，以及与组件名称匹配的简单访问器方法。</p><h2>自定义记录类</h2><p>虽然记录类设计简洁，但仍可通过自定义行为增强功能。以下是相关示例。</p><h3>紧凑型构造方法</h3><p>记录类提供特殊的“紧凑型构造方法”语法，无需重复参数列表即可验证或转换输入参数：</p><pre><code class="java">record JavaMascot(String name, int yearCreated) {
    // 带验证的紧凑型构造方法
    public JavaMascot {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("名称不能为空");
        }
        if (yearCreated &lt; 1995) {
            throw new IllegalArgumentException("Java吉祥物在1995年前不存在");
        }
    }
}</code></pre><p>紧凑型构造方法在字段初始化后、对象完全构建前运行，非常适合用于参数验证。此示例中省略了参数声明，但这些参数在构造方法内仍隐式可用。</p><h3>添加方法</h3><p>我们还可以为记录类添加方法：</p><pre><code class="java">record JavaMascot(String name, int yearCreated) {
    public boolean isOriginalMascot() {
        return name.equals("Duke");
    }
    
    public int yearsActive() {
        return java.time.Year.now().getValue() - yearCreated;
    }
}</code></pre><p>通过添加方法，记录类可在保持语法简洁和不可变性的同时，封装与其数据相关的行为。  </p><p>接下来，我们探讨记录类更高级的用法。</p><h2>使用 <code>instanceof</code> 和 <code>switch</code> 进行模式匹配</h2><p>Java 21中，记录类成为<a href="https://link.segmentfault.com/?enc=g00vYxr%2BCHqzhZg3KcTTYA%3D%3D.ITqtadkYquLlL93OOdE6OwrvqxY%2BsTGqQ0X2XDWSmkTRBWIlhhOSekTz4tApmoqFW%2FzWqoMLxCSnhOykdf2ABlA8StvU%2FFTW7K4%2Fea3uqPQ8wcgMfDz%2BHmd9sTYA8WzN" rel="nofollow" target="_blank"><strong>模式匹配</strong></a>的关键部分，支持switch表达式、组件解构、嵌套模式和守卫条件。  </p><p>结合增强的 <code>instanceof</code> 运算符，记录类可在类型验证时简洁地提取组件：</p><pre><code class="java">record Person(String name, int age) {}

if (obj instanceof Person person) {
    System.out.println("姓名：" + person.name());
}</code></pre><p>再看一个经典示例。几何形状是展示密封接口如何与记录类协同工作的典型例子，这种组合使模式匹配尤为清晰。Switch表达式（Java 17引入）的优雅性在此凸显，它让代码简洁且类型安全，类似于函数式语言中的代数数据类型：</p><pre><code class="java">sealed interface Shape permits Rectangle, Circle, Triangle {}

record Rectangle(double width, double height) implements Shape {}
record Circle(double radius) implements Shape {}
record Triangle(double base, double height) implements Shape {}

public class RecordPatternMatchingExample {
    public static void main(String[] args) {
        Shape shape = new Circle(5);

        // 表达性强且类型安全的模式匹配
        double area = switch (shape) {
            case Rectangle r -&gt; r.width() * r.height();
            case Circle c    -&gt; Math.PI * c.radius() * c.radius();
            case Triangle t  -&gt; t.base() * t.height() / 2;
        };

        System.out.println("面积 = " + area);
    }
}</code></pre><p>此例中，<code>Shape</code> 是密封接口，仅允许 <code>Rectangle</code>、<code>Circle</code> 和 <code>Triangle</code> 实现。由于类型集合封闭，switch表达式覆盖所有情况，无需 <code>default</code> 分支。</p><blockquote><p><strong>Java中的模式匹配</strong>  </p><p>若想进一步探索记录类与模式匹配，请参阅我的近期教程：<a href="https://link.segmentfault.com/?enc=5DnWDFUOfUPFA7PNs04%2F1A%3D%3D.HOO4g9iT3Z%2Fh0Lg6UuaZwMee0lhVrrF7rF6ssFFcqclAkUDOPKgkAny18GN%2F%2BLVQFjHDfb46Xy7nDr7sqI0sSAFxkqiqOB6FUHeNlHhQ9xaFWZJyMoXGTo2B4DHOYoxT" rel="nofollow" target="_blank"><strong>《Java基础与高级模式匹配》</strong></a>。</p></blockquote><h2>将记录类用作数据传输对象</h2><p>记录类在现代API设计（如REST、GraphQL、gRPC或服务间通信）中作为数据传输对象（DTO）表现卓越。其简洁语法和内置等值比较特性，使其成为服务层间映射的理想选择。例如：</p><pre><code class="java">record UserDTO(String username, String email, Set&lt;String&gt; roles) {}
record OrderDTO(UUID id, UserDTO user, List&lt;ProductDTO&gt; items, BigDecimal total) {}</code></pre><p>DTO在<a href="https://link.segmentfault.com/?enc=Y3FIJqmFdeZroB52r5yHrg%3D%3D.dsFFUuW4e4%2FXshWnEX%2FniJGfF1dmieCRI0OTD1etmnSvstHciROapDfP91qkhb4dDnmvtNf9cAlKUVughTrqIKlRy5zL48%2FZ331DfgoblZab%2BAvXB%2BUuKoHwyQMfbBqZmyc1zF32pTwb46R1Hy1ENQ%3D%3D" rel="nofollow" target="_blank"><strong>微服务应用</strong></a>中无处不在。使用记录类可使DTO更健壮（得益于不可变性），更简洁（无需编写构造方法、getter及 <a href="https://link.segmentfault.com/?enc=nr3YRFP5JsJZjsVFwB8dBQ%3D%3D.8YzJLziPriK3kGl4REJZdiS8OMolgvfF%2FbcNMQ92r19O3FL6AJFoHwB%2BQ1138i4ZU0cvS%2Bvu%2B6qGZ2nRktx51x%2BBVi5ktQln0hEXnnhnWqnBNLIvRy2XNubbTNgat09O" rel="nofollow" target="_blank"><strong><code>equals()</code>、<code>hashCode()</code> 等方法）</strong></a>。</p><h2>函数式与并发编程中的记录类</h2><p>作为不可变数据容器，记录类完美契合函数式与并发编程需求。它们既可作为纯函数的返回类型，也可用于流处理管道，还能安全地在线程间共享数据。  </p><p>由于字段为final且不可变，记录类避免了一整类线程问题。一旦构建完成，其状态无法更改，因此无需防御性复制或同步即可实现线程安全。参考以下示例：</p><pre><code class="java">transactions.parallelStream().mapToDouble(Transaction::amount).sum();</code></pre><p>由于记录类不可变，此并行计算天生具备线程安全性。</p><h2>不适用Java记录类的场景</h2><p>至此，我们已了解记录类的优势，但它们并非万能替代品。例如，所有记录类隐式继承 <code>java.lang.Record</code>，因此无法继承其他类（但可实现接口）。在需要类继承的场景中，记录类并不适用。  </p><p>以下是记录类不适用的其他情况。</p><h3>记录类设计为不可变</h3><p>记录类组件始终为final，因此不适用于需要可变/有状态对象的场景。以下示例展示了一个依赖状态变化的可变类，而记录类不允许此类操作：</p><pre><code class="java">public class GameCharacter {
    private int health;
    private Position position;

    public void takeDamage(int amount) {
        this.health = Math.max(0, this.health - amount);
    }

    public void move(int x, int y) {
        this.position = new Position(this.position.x() + x, this.position.y() + y);
    }
}</code></pre><h3>记录类不适合复杂行为建模</h3><p>基于可变状态、复杂业务逻辑或策略模式、访问者模式、观察者模式等设计，更适合使用传统类实现。以下是复杂逻辑不适用于记录类的示例：</p><pre><code class="java">public class TaxCalculator {
    private final TaxRateProvider rateProvider;
    private final DeductionRegistry deductions;

    public TaxAssessment calculateTax(Income income, Residence residence) {
        // 复杂逻辑不适用于记录类
    }
}</code></pre><h3>记录类与某些框架不兼容</h3><p>部分框架（尤其是ORM）可能无法良好支持记录类。序列化或重度依赖反射的工具也可能存在问题。请务必检查Java特性与技术栈的兼容性：</p><pre><code class="java">// 可能无法与某些ORM框架良好协作
record Employee(Long id, String name, Department department) {}

// 此时仍需使用传统实体类
@Entity
public class Employee {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
    @ManyToOne
    private Department department;
    
    // Getter、setter、equals、hashCode等方法
}</code></pre><p>这些注意事项并不意味着记录类功能不完整，而是强调记录类专为特定场景设计。在某些情况下，传统类仍是更实用的选择。</p><h2>Java中的记录类与序列化</h2><p>记录类已在Java生态中被广泛采用，其不可变性使其在持久化、配置和数据传输中极具吸引力。记录类可像普通类一样实现 <code>Serializable</code> 接口。可序列化的记录类组件天然适用于保存配置、恢复状态、网络传输数据或缓存值等场景。  </p><p>由于记录类字段为final且不可变，它们有助于避免可变状态在序列化与反序列化之间发生变化引发的问题。例如：</p><pre><code class="java">import java.io.Serializable;

record User(String username, int age, Profile profile) implements Serializable {}

class Profile {
    private String bio;
}</code></pre><p>此例中，<code>String</code> 和 <code>int</code> 可序列化，但 <code>Profile</code> 不可序列化，因此 <code>User</code> 无法序列化。若将 <code>Profile</code> 也改为实现 <code>Serializable</code>，则 <code>User</code> 将完全可序列化：</p><pre><code class="java">class Profile implements Serializable {
    private String bio;
}</code></pre><p>除序列化基础外，Java生态对记录类的支持已迅速成熟。Spring Boot、Quarkus和Jackson等流行框架均与记录类无缝协作，大多数测试工具也是如此。  </p><p>得益于这种广泛采纳，记录类在实际API中作为DTO表现卓越：</p><pre><code class="java">@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @GetMapping("/{id}")
    public OrderView getOrder(@PathVariable UUID id) {
        // 实际应用中，此数据应来自数据库或服务
        return new OrderView(
            id,
            "Duke",
            List.of(new ItemView(UUID.randomUUID(), 2)),
            new BigDecimal("149.99")
        );
    }

    // 用于API响应的记录类DTO
    record OrderView(UUID id, String customerName, List&lt;ItemView&gt; items, BigDecimal total) {}
    record ItemView(UUID productId, int quantity) {}
}</code></pre><p>如今，大多数主流Java库和工具已将记录类视为一等公民。早期的质疑已基本消散，开发者正因其清晰性与安全性而广泛接纳记录类。</p><h2>结语</h2><p>记录类是Java演进过程中的重大进步。它们降低了数据类的冗余度，并确保了不可变性和行为一致性。通过消除构造方法、访问器及 <code>equals()</code>、<code>hashCode()</code> 等方法的样板代码，记录类使代码更简洁、表达力更强，在保持类型安全的同时契合现代实践。  </p><p>记录类并非适用于所有场景，但在处理不可变数据时优势显著。结合<a href="https://link.segmentfault.com/?enc=VfmVdvwWOMBjVMngACM%2F2A%3D%3D.hgATLufLKAc9fjVgYsZSO41HVyPDbxLc34Q2tAtk5PNEdpxY9wGWpvlAl%2BcS%2FvllnTQF3Qcu0RnaKZeiUq0PvM0JgqYwtx0es7%2FaPEXDAyF%2F5C92qQ2xT4NFYrtACjiz" rel="nofollow" target="_blank"><strong>模式匹配</strong></a>，它们能让代码意图更清晰，同时由Java编译器处理样板代码。  </p><p>随着记录类、密封类和模式匹配等技术的进步，Java正稳步迈向更以数据为中心的编程风格。掌握这些工具是编写现代、高表达力Java代码的最清晰路径之一。</p><hr/><p>【注】本文译自：<a href="https://link.segmentfault.com/?enc=J8ZygdGpfI%2BRheXJPLTNEA%3D%3D.A3xlNKm6sx8If2wSEmJ0y0MorQJSJazefC7eUUv2Wig3LGOXi68vXPIOBRKfH9uxOYGS0SvjEgrkG8KUpx3f7H6WEjDZaSy4Iafnd6VRIjmZJBHh%2B68XSeKHDGE2p%2FRNr4EwAcIf1U5M8W5TkMugGDgUVafMy5AWSbQhzc8JpOg%3D" rel="nofollow" target="_blank">Introduction to Java records: Simplified data-centric programming in Java</a></p>]]></description></item><item>    <title><![CDATA[JeecgBoot 低代码 v3.9.0]]></title>    <link>https://segmentfault.com/a/1190000047440463</link>    <guid>https://segmentfault.com/a/1190000047440463</guid>    <pubDate>2025-12-01 12:03:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>项目介绍</h2><blockquote>JeecgBoot是一款集成AI应用的，基于BPM流程的低代码平台，旨在帮助开发者快速实现低代码开发和构建、部署个性化的 AI 应用。 前后端分离架构Ant Design&amp;Vue3，SpringBoot，SpringCloud，Mybatis，Shiro，强大的代码生成器让前后端代码一键生成，无需写任何代码！ 成套AI大模型功能: AI模型、AI应用、知识库、AI流程编排、AI对话等； 引领AI低代码开发模式， 帮助Java项目解决80%的重复工作，让开发更多关注业务，提高效率，同时又不失灵活性！</blockquote><p><strong>发版时间</strong>：v3.9.0 | 2025-12-01</p><h4>源码下载</h4><ul><li>Github地址： <a href="https://link.segmentfault.com/?enc=xBAvuiUzE%2FW1CRtcqXMEiA%3D%3D.Nxgc%2BHU1uHHZl%2FdYqfPqV69xG21C5wt5K2QT%2BRnZ8AIEFmPXgUEJXFbvAthgJe7X" rel="nofollow" target="_blank">https://github.com/jeecgboot/JeecgBoot</a></li><li>Gitee地址： <a href="https://link.segmentfault.com/?enc=H6uGcVhDqjgiY27JVUc%2BHA%3D%3D.piqs%2BMNkDvQSkPXVgPzJTDGhwf%2Bwq06aBobZYdEGnpkH3JBsfuCLYHXbnMOLmFJw" rel="nofollow" target="_blank">https://gitee.com/jeecg/JeecgBoot</a></li></ul><h4>升级日志</h4><blockquote>本次升级将 langchain4j 升级至 1.3.0，强化 AI 功能，新增 MCP 和插件支持，实现聊天式业务操作（如“一句话创建用户”），扩展 AI 聊天与流程编排能力。集成 Anthropic（Claude）、网络搜索及推理模型，提升系统深度思考能力。完成 POI 升级至 5 版本，优化用户、部门、租户等系统管理功能。<br/>自 v3.9.0+ 起，停止同步升级 Spring Boot 2版。</blockquote><h5>AI功能增强</h5><ul><li>升级 langchain4j 至 1.3.0 版本。</li><li>AI 应用新增对 MCP 和插件的支持。</li><li>AI 聊天功能支持 MCP 和插件扩展。</li><li>AI 流程编排新增 MCP 和插件支持。</li><li>支持AI聊天做业务(例如：一句话创建用户)</li><li>新增 Anthropic（Claude）模型厂商支持。</li><li>AI 聊天支持推理模型，提升深度思考能力。</li><li>AI流程支持导出与导入功能</li><li>AI脚本节点支持 Python 语言编写</li><li>AI聊天集成千问模型，支持联网搜索功能</li><li>支持 2000+ 维度向量，pgvector 版本需大于 0.7</li></ul><h5>功能架构升级</h5><ul><li>从 v3.9.0+ 版本起，不再同步升级 Spring Boot 2 版本。</li><li>批量删除修改日志，提升代码可读性</li><li>POI 升级至 5 版本。</li><li>升级 <code>package.json</code> 中依赖包的小版本号</li><li>积木报表升级至最新版 v2.2.0。</li><li>积木 BI 升级至最新版 v2.2.0，新增多屏切换功能，大屏设计支持导出和导入。</li><li>集成 <code>vite-plugin-pwa</code>，实现渐进式 Web 应用（PWA），显著提升首屏加载速度。</li><li>系统资源实现异步加载，菜单响应速度更快。</li><li>登录密码采用 AES 加密传输，杜绝明文传输，提升安全性。</li><li>支持单独设置 APP 和 PC 登录会话的有效期。</li><li>支持登录规则灵活配置：</li><li>是否允许同一账号多地同时登录。</li><li>是否开启默认密码登录提醒。</li><li>是否启用登录验证码校验。</li><li>登录用户支持区分登录规则（区分 PC 与 APP），并记录终端设备信息，便于实现 APP 推送功能。</li><li>部门管理新增查看部门负责人的功能。</li><li>部门管理支持拖拽调整部门上下级关系，提升操作便捷性。</li><li>用户岗位调整为关系表结构，优化数据关联管理。</li><li>我的租户界面改版，提升整体使用体验。</li><li>优化密码默认规则，增强安全性。</li><li>支持隐藏用户联系方式，保护隐私。</li><li>富文本编辑器优化：从博客复制的文章中图片自动下载并上传至云存储</li><li>登录页面新增部门选择功能</li><li>BasicTable 列表页导出 Excel 时支持指定导出列</li><li>uniapp推送功能，支持在线和离线消息（已对接系统公告）</li><li>日志级别由 info 调整为 debug，减少日志输出量</li><li>优化延迟加载导致的部分功能失效问题，修复 token 忽略注解失效</li><li>生成代码统一导出为 xlsx 格式</li><li>我的消息支持批量删除已读消息</li><li>升级 shardingsphere-jdbc 至 5.5.0，简化 ShardingSphere 数据源配置</li><li>用户管理支持按组织架构查询用户（支持多选）</li><li>用户管理新增排序字段，选人组件和通讯录等功能按排序字段展示</li></ul><h5>Online优化功能</h5><ul><li>新增Long类型支持，补充online中db类型缺失的Long类型支持</li><li>为online报表添加AI生成SQL能力</li><li>支持主子表生成测试数据功能，完善Online AI测试数据生成</li><li>修复online表单存在的严重BUG，影响所有配置查询相关表单功能，优化Java增强</li><li>一对一子表编辑后，详情页数据未实时更新</li><li>superQuery高级组件点击查询后，弹窗未自动关闭</li><li>修复online表单联动查询无法模糊搜索选项问题，新增下拉联动组件搜索功能实现</li><li>修正online表单开发中开关控件类型字段详情页显示原始值问题（查看详情页时显示开关状态）</li><li>修复内嵌子表主题（一对多）列表展开明细时提示无权限访问</li><li>修复JS增强弹窗中popup的onChange事件无效问题</li><li>优化删除操作确认弹窗内容及样式，提升用户体验</li><li>修正ERP风格online主表在数据条数为5条时出现滚动条问题</li><li>限制online ERP风格主表固定高度，防止高度异常</li><li>生成测试数据时不再展示tooltip提示信息</li><li>修正online表单TAB主题附表页面标题与内容不一致问题</li><li>代码预览支持左右拖动功能</li><li>修复online表单图片控件多图片显示异常</li><li>JS增强弹窗支持basicModal组件的props传递</li><li>修复online下拉搜索框详情页无法正确读取数据字典问题</li><li>修复下拉搜索框绑定数据字典后导出数据报错问题</li><li>解决online表单内嵌风格中double类型数据导出带小数点“.0”导致导入报错问题</li><li>修正online建表生成的日期类型字段控件为输入框问题</li><li>解决升级mybatisPlus后SqlServer分页使用OFFSET必须有排序的报错</li><li>online代码生成中，传递配置项以支持JS增强和Java增强逻辑代码</li><li>优化online报表配置界面列表滚动条美观性</li><li>代码生成时增加操作提示语</li><li>代码直接生成前端项目后，自动刷新提醒功能</li></ul><h5>Issues处理</h5><ul><li>mysql 8.4 数据库字段类型为bigint ，代码生成为Integer · <a href="https://link.segmentfault.com/?enc=QL3ZpPUao0Hit7OdYk2pqA%3D%3D.w3BmDaZg30ZI1MoM8LmUuPbduCAA9QTy4hVt3XalhZuY8d65UB3hit82%2BBthinHqF4DQ1PZTBAU3%2Bya62oeJuA%3D%3D" rel="nofollow" target="_blank">Issue #8909</a></li><li>online中的列表如果第一列固定就出现带 +号的列在向右滑动的时候被错位隐藏 · <a href="https://link.segmentfault.com/?enc=rMsxs6mI8p68tDLMSBW8Jw%3D%3D.IF1hddxnQQC4vI4pbDzP6RjS2lpuYBIvlqBexIFIbH%2FmZblevXlIWpYu7GxtJ1m3gqLEGgOOK%2B8e6dy%2BF03bDA%3D%3D" rel="nofollow" target="_blank">Issue #8862</a></li><li>选中行如果存在右侧固定操作列或X方向滚动条会出现数据悬浮超出 · <a href="https://link.segmentfault.com/?enc=YK%2FiNA4tL9WyuCk%2BwTI%2BUg%3D%3D.PsrfF9T9SWdMbHVfnqsu3LVgTs4xcfIG8MPaxmu8S2bLJ9%2FdnycCoqRJGB2Kz0m%2FrNBgsYDRcJbMukytHBT56Q%3D%3D" rel="nofollow" target="_blank">Issue #8839</a></li><li>关于BasicTable组件自适应高度的建议 · <a href="https://link.segmentfault.com/?enc=3r%2B%2FqfyU22e6CtzpfxSVmg%3D%3D.JP6WwRvnWOm%2FQiBDf1VK10w7P1TrZx6rhsP0oANBQ5pXJEV36Y6%2BE3dkf3NpKZv9D96VE7LTRFTYS6alf2ajEA%3D%3D" rel="nofollow" target="_blank">Issue #8880</a></li><li>popup弹框怎么onlChange()不生效？ · <a href="https://link.segmentfault.com/?enc=drXckZE5A7ZaqKhW55YHLw%3D%3D.sNn7WsEP8kO5lE%2BX06vOGsU2s504Q1Cu1yusZQlBJCNpUWSKNCidlPJcbELl3EKWJVlp3%2BDCyVx%2BKg9tSfcvhg%3D%3D" rel="nofollow" target="_blank">Issue #8791</a></li><li>关联问题8567，修改密码接口可以被恶意爆破 · <a href="https://link.segmentfault.com/?enc=atO8GiUXuw7JD6WEI6Opaw%3D%3D.jhRcg%2BANpEsLmelnjchluJfYiRGAkLHmxNUrmVUCptM2sr2ZpTlUE4OYDtDUsGQAUJ5aae2CAYql9RIpLiMd%2Bg%3D%3D" rel="nofollow" target="_blank">Issue #8805</a></li><li>同一页面下存在多个basicTable，获取实例错误 · <a href="https://link.segmentfault.com/?enc=u1ZrgHztoNPP261omeMYKg%3D%3D.mVHkBKYbcQnhJod2zV8HsKw5LJcxNUX6op8fCU4OrS0uPowcv3kvXYuoz3Eiymp05Ye%2FIf8vlVG32GB0DzyClw%3D%3D" rel="nofollow" target="_blank">Issue #8792</a></li><li>EditableCell.vue 点击单元格对号之后，会过滤掉表格的id字段，导致无法更新数据。 · <a href="https://link.segmentfault.com/?enc=mwAom%2F5pThy0Bpq9A1C6%2Bw%3D%3D.wLN9HKmxo9TGraUqHFwc8VpfIsLveCHizVEMqJ%2F%2BRKgmPHv9W062hHU8v4dzVIRquB7De880I1PBAfTCnFQJ9Q%3D%3D" rel="nofollow" target="_blank">Issue #8924</a></li><li>数据填报时数字转换报错 · <a href="https://link.segmentfault.com/?enc=P2MY18IMQOo7qPeQCmtUEQ%3D%3D.eM8PZxJFBCHFItQmBPcySiaYwCzYoTjmrZA1Qd2XgYZLAqgKy8AKHb028UH8EE97cIwc1pZRtnJVwpZBLlmwqA%3D%3D" rel="nofollow" target="_blank">Issue #4091</a></li><li>jeecgboot master分支jdk1.8无法启动 · <a href="https://link.segmentfault.com/?enc=SFY02KwhfLOc0w2Egwv2mw%3D%3D.%2BgelTJLMEAvZ8Ha3e3MxUkvxe90n6kpPyeDTBWp8RL0BjGS33i4PwTgDQZt9rqHxKm4iSQtMibexJ8M0ZNamUA%3D%3D" rel="nofollow" target="_blank">Issue #8944</a></li><li>online表单java增强失效 · <a href="https://link.segmentfault.com/?enc=wzM9Mb5G0S5HDQZd2YbjYA%3D%3D.GK20g7%2BzYlJ9YkKOe1qYTRUatZJjUpJGCxAv6xiPL2DFDbcMad7whbIq2hAgffhiqY4OM1ho2Q0WLV%2BP9S6EuQ%3D%3D" rel="nofollow" target="_blank">Issue #8859</a></li><li>日志注解@AutoLog 多文件上传时报错 · <a href="https://link.segmentfault.com/?enc=ayM2updlX7bAhgFlPP4T%2BA%3D%3D.Rcx0ptWOIqQduyca9ySNeFFVUiR%2FzQW4Cwn8b%2FRPQ0%2Fsx%2F%2Bj14knF9qpAxK5xviEGIUaeipu20p19e%2BNGPW9fw%3D%3D" rel="nofollow" target="_blank">Issue #8945</a></li><li>从jeecgboot 3.8.2 升级到 3.8.3 在线表单java增强功能报错 · <a href="https://link.segmentfault.com/?enc=knFg%2Bc9fs%2Ft7RlwAQ1e6tA%3D%3D.Fad2ccFhvSX8aV9EHtwyCPgA1sDM5glKjqUM%2Be6E%2B0zSUBF%2B7gMGWjP93W6RAMC8OtAoI8ccm9Mm6CFNivcr6g%3D%3D" rel="nofollow" target="_blank">Issue #8951</a></li><li>关于sys\_user org\_code的疑问。 · <a href="https://link.segmentfault.com/?enc=spxYpksc6BxRN4qaG8Zm5w%3D%3D.B4GApgzb9ThTX9u6AWnwEVyeaXd345cZuJ4bDhRKiQCbKZfbzpN42OflcgLSSw5QGm8BuQDYYM45WCRnd6rp7A%3D%3D" rel="nofollow" target="_blank">Issue #8953</a></li><li>Online表单开发，Java增强问题 · <a href="https://link.segmentfault.com/?enc=w5wHV685IdK9YC3skg8rlw%3D%3D.8TZQTfFKNXQZ6QFpffAN%2BloItdnLlKIXquhRwBjYbIlCC%2FussXA%2FjRsATYoRDbOQe3DUyPaMdXag8j0VbbMBbw%3D%3D" rel="nofollow" target="_blank">Issue #8768</a></li><li>online 表单重大 bug，影响配置了查询 的所有表单 · <a href="https://link.segmentfault.com/?enc=8tIkz4927oIHBzG%2BKj%2BP3A%3D%3D.de6HCccwrBI7BfVm8%2F1MghuDoN8U3%2FUgQU6CSE7TbDfp7Kgclf%2FkyyRiT78MUO%2BGhrNc75x1jF4IovWFGq7Zag%3D%3D" rel="nofollow" target="_blank">Issue #8790</a></li><li>添加AI模型保存并激活的时候报错：测试模型连接失败：调用大模型接口失败，详情请查看后台日志。 · <a href="https://link.segmentfault.com/?enc=f0g5MnUtQMl4ni0%2BcjOMTg%3D%3D.lWltO2NmjSOq8en6%2BUHtgvSsOQ3pcxAVJYexjOP1RBEvLvL8osg8F%2BBqLRdVsJlhJohC66NMUaLU5kI%2FioOkLg%3D%3D" rel="nofollow" target="_blank">Issue #8906</a></li><li>AI模型激活时, 智谱/千问报错UnsupportedOperationException · <a href="https://link.segmentfault.com/?enc=neQqf5BfyC8n%2FtL0znPADw%3D%3D.AXTdYghlVEZ%2BcRJEVIrfwdzpOvspUQa6SNK3xZf1sjlIHFmliO9VplA7yyf7w8NbdAX4GJmd5sbrwWeLk0%2F3SQ%3D%3D" rel="nofollow" target="_blank">Issue #8955</a></li><li>分库分表错误 · <a href="https://link.segmentfault.com/?enc=IRwlQDAXnXqKtsxVG4azoQ%3D%3D.4T%2FofLR6ZDngM3TjUGKyHScjV43mu3Jsmp8DFWcHQX98mhB4AFDhUD50NnoOkUcZNES%2FelfXbMhFMzP0GcGCVA%3D%3D" rel="nofollow" target="_blank">Issue #8962</a></li><li>Microsoft SQL Server 2008支持问题 · <a href="https://link.segmentfault.com/?enc=mjbOS7qDC7tjcSvbOS7Bzg%3D%3D.ckPEtwcTVIaGXHno1SjnIfX%2BjOismljUs1n4VZ2evG%2BST0aq0N7dM5pFR9tr0SEU6xEdp6BQbi%2FF%2B4V%2BQsvxUQ%3D%3D" rel="nofollow" target="_blank">Issue #8975</a></li><li>通义千问的多模态模型如：qwen3-vl-plus 保存激活报错。 · <a href="https://link.segmentfault.com/?enc=3OdIjXBNc38YtmGpn2pybg%3D%3D.IngR9pVZYlBgtfzKGduzmwnnKfoe9a6mOGkS5PFNP313kEY41YjQDXxFSLKip72J6aVUJNgBCQAkjnmX5VS8qw%3D%3D" rel="nofollow" target="_blank">Issue #8972</a></li><li>Jeecgboot 登录配置 不允许或允许多设备登录 · <a href="https://link.segmentfault.com/?enc=QjFChl9HEmmT7In7aVgVjQ%3D%3D.yP5ucLbOJCKGcDk%2FDcxBLAn%2Fc7WYtY0lo8CCL7QqhbKnMO8cUpPY9NpZiuBNux4M9EoA7f1cPnAweRVg9or8MQ%3D%3D" rel="nofollow" target="_blank">Issue #8929</a></li><li>特定条件下AI助手失去响应 · <a href="https://link.segmentfault.com/?enc=m0W8wafOjMJPdsDdY7jsXQ%3D%3D.IKVWelf9R1rqBK5iDrx9aveomhQONaWhJCaYR0F4l%2B7VBRjwbJwgtQO%2FZpOrFe%2Bh3LSzwCCI%2BKX0VsANF5WocA%3D%3D" rel="nofollow" target="_blank">Issue #8997</a></li><li>内嵌子表主题（一对多）列表点+号展开明细提示：无权限访问(操作) · <a href="https://link.segmentfault.com/?enc=kNNZz1MyTKj2cUzqxpV%2F%2FQ%3D%3D.vE6KqngY92tsP2pPeT0OumMa9tod%2Bk8ldSZgxc2k%2FbZ6xryz2HJFOPkeyv4Xp7q1A9nXJQqty746Vn%2F4hvBJpg%3D%3D" rel="nofollow" target="_blank">Issue #8933</a></li><li>3.8.3-master分支：租户用户 菜单下 新增用户报错 · <a href="https://link.segmentfault.com/?enc=x7lf35CL%2FSjOTs%2BOKNVZYA%3D%3D.vqXkNxt6AOxqZUNuf3g%2Fs63ePTFlGLYvlFonw%2BxUnSZ31OPqTv5cSLgDWZ%2BHLjrY7RE6mR5nGx3WBZzTOa%2FQjQ%3D%3D" rel="nofollow" target="_blank">Issue #9039</a></li><li>从jeecgboot 3.8.2 升级到 3.8.3 在线表单java增强功能报错 · <a href="https://link.segmentfault.com/?enc=LbwfJaRAfbGeUpdRaAaTdQ%3D%3D.Wd8mz%2FHLGCVPXDXbqzhU5g7beCBpfQOe8dYW4nel0rTMWq2pPOWbg4GePxowrHMmnCqYo%2Fq8wXqeClLhwgRJWg%3D%3D" rel="nofollow" target="_blank">Issue #8951</a></li><li>ai模块的mcp菜单没有找到，版本号3.8.3 · <a href="https://link.segmentfault.com/?enc=V0Nmv82kX6bJ5bzMn9t68Q%3D%3D.GbyK0rcHB6TdO5Ev8PY1I3ejWwDxBeBiIZgZur%2FjQg0hF4Ta58paZ795w%2F0z77cXcI%2FynTudQ%2FKISkjrgE0Z1w%3D%3D" rel="nofollow" target="_blank">Issue #9044</a></li><li>AutoPoi ImageEntity建议添加scale属性，控制图片导出缩放模式 · <a href="https://link.segmentfault.com/?enc=fmjgJgZA55rraYih1jGZzg%3D%3D.h3wpWagKGyIaZVqsVwI5Mzp0cF4Wpg5LlHfRtr6oQXBxSXVlm587CL6RMcEdXw38iMhjpUY338td2ssIPzgFfQ%3D%3D" rel="nofollow" target="_blank">Issue #8892</a></li><li>3.8.3-master分支，ai工作流编排，直接回复节点没有流式响应的开关 · <a href="https://link.segmentfault.com/?enc=gPsdWdCYXedndA6%2F38KHYA%3D%3D.ewREvCqdC1LFDLI6u55u7zMrXCV%2Fapn17Lhi3X7fKwiFAMoF0%2Fg3UQ5FZlJJektRJqQj3IrRcHZSB8RDQaBjVQ%3D%3D" rel="nofollow" target="_blank">Issue #9031</a></li><li>online表单联动查询，无法模糊搜索选项 · <a href="https://link.segmentfault.com/?enc=%2BJg3qiKIqvpNdVvcbRYg3A%3D%3D.6qtb8aVg%2Fvt5to8Bfz%2F5J51p%2F%2FEgreqAblLpRCXiCvPwWkhZGV%2FFgqkfdu4VDBdY5ex7q1P36c0xVTtFAAIj6g%3D%3D" rel="nofollow" target="_blank">Issue #8486</a></li><li>online表单在线开发，下拉联动组件，怎么实现搜索功能 · <a href="https://link.segmentfault.com/?enc=fFpJPxT%2Br9HmNlHe0Kcx%2FA%3D%3D.XPBArcakUXizy50V%2FxQ778T7UBAQot41VrXpjiIELsCcHt%2FuhspJMxna8Q7%2BTuBU%2Bihw7pCUyizYfGXaPU27qQ%3D%3D" rel="nofollow" target="_blank">Issue #8587</a></li><li>online 表单开发， 设置字段 控件类型为开关时，查看详情页时 开关字段显示原始值 · <a href="https://link.segmentfault.com/?enc=jqKu%2F%2BemHIa0NCWL3xmoAw%3D%3D.mHhl5WWn%2BBjjUh1QIt7Ds5CEKKCkUtStT8Q9c2bfwcNGxklw8L3L4O8LT9G66PKUS4yDKPK3wscxywl0BhZgEA%3D%3D" rel="nofollow" target="_blank">Issue #9036</a></li><li>AI应用二次打开聊天无法继续 · <a href="https://link.segmentfault.com/?enc=I81cb3jFhb9vD1prxvoSRw%3D%3D.aoRn6cL9i07gId3trmQyoC6%2BIy9VqYQvf3CUkyd94oS1TW8QDkrOdmFRZby%2B%2FcjNF05PqVKMSkkNEhfRLWH%2FHg%3D%3D" rel="nofollow" target="_blank">Issue #9054</a></li><li>无法启动，报错：init flow executor cause error for path el_xml · <a href="https://link.segmentfault.com/?enc=BxYSTBLlpVsX7EDUNdlf%2FA%3D%3D.SxM%2F8m%2BhtebezPSlgUNWC9W5amQunqx%2FOwS%2BOAc42ndRLZF67E%2B%2BgBsad6tlrnOA33CtAjl%2FoWGVF%2FY9R0mXGw%3D%3D" rel="nofollow" target="_blank">Issue #9034</a></li><li>在线表单字段控件类型为下拉搜索框时绑定数据字典后导出数据报错 · <a href="https://link.segmentfault.com/?enc=bTCgS9cxvoofsB%2BYQzlWKQ%3D%3D.LivCiVLDng3IzwCZgtVvHIAZz9cZbkICB%2B%2BTeKCoM6DhvSP24Z2psDs%2FUdfwIYm1R7dPKo5Q4qm6HSB43owomA%3D%3D" rel="nofollow" target="_blank">Issue #9053</a></li><li>新建AI应用的时候只能选择没有自定义参数的AI流程 · <a href="https://link.segmentfault.com/?enc=22Mg4rOZizQPYJya6KYUig%3D%3D.xkbmcnTsvkPNDFE2Jty8%2BJp5uCwfmJITYhMOgkxPn93NhppdfBs%2F5545RvV5y0jm14bcAKgldrmlPyXh4A373w%3D%3D" rel="nofollow" target="_blank">Issue #8545</a></li><li>FormSchema配置componentProps为函数返回valueType: 'Array‘时在useListPage 的查询接口中仍旧是获取到类型为string · <a href="https://link.segmentfault.com/?enc=YOaGYhZaLrnPI9z6LX9loA%3D%3D.eTVWcIADVcJ8h%2BvemfJSc8DSp8pTYBOechoZhg5ENOrmfna9HZ8xgzynCaOd940BBIACAgMns33VBGRTp4LRkQ%3D%3D" rel="nofollow" target="_blank">Issue #8976</a></li><li>3.8.3-springboot3 AI模型配置中，测试连接功能被取消？ · <a href="https://link.segmentfault.com/?enc=cYMCYp2tXwWJAzRo6UAxMg%3D%3D.bU4Fmf9FW6soi2ihcjEOj07Jr5qBRyrzyzoB%2B75jlTWRV4SrpwjzhGgzC3Jhe65lgml3Zz6tOo2hwEubphgSTA%3D%3D" rel="nofollow" target="_blank">Issue #9071</a></li><li>jeecgboot-vue3 执行dev能正常启动，build或build:docker时报错 · <a href="https://link.segmentfault.com/?enc=1RFYm84sNDw7ScPsWqciIg%3D%3D.pKdwirYvC4iiHOlZ2eCAgcYywsk4XciuTfoSst5yCZe7lu47Y8Q8P%2FpNcPOpTey2Co7e%2FTfwKOzeKyVro%2BsSbg%3D%3D" rel="nofollow" target="_blank">Issue #9087</a></li><li>Online报表（带参数）预览后台报错 · <a href="https://link.segmentfault.com/?enc=k5qFCnYUpglvppJXZVqAhA%3D%3D.N32pAtoED9Smgk%2FNttbUcFB2KetMhTXOXFTQy7tlf2uoq438vSX%2BZ6%2FuGTbTphKIAhH31243iULzCSifwtLBNQ%3D%3D" rel="nofollow" target="_blank">Issue #9000</a></li><li>ai应用中如何实现深度思考功能 · <a href="https://link.segmentfault.com/?enc=Sjg29ooSHBAz4PvczlDXDg%3D%3D.3XpjqdVaAy%2BFgOBAX8lOp0X7pOg38uCM23JD7DQ%2BGEuxghOEHffK3kH8gZKPE3aalFbXNvCIGXwUhvOQlhB5zQ%3D%3D" rel="nofollow" target="_blank">Issue #9104</a></li><li>JVxeTable表格点击行选择BUG · <a href="https://link.segmentfault.com/?enc=avwvF%2FQCxI3qLimsgt6m4Q%3D%3D.KEc0bC%2Bkk%2B5KHrGpBQcAKjFuuKeS5048CoZe0MwskgiZLBnAYlZ1pTtGowacrmKB0jJvQoOL37QC6ARmlXUmUw%3D%3D" rel="nofollow" target="_blank">Issue #9038</a></li><li>superQuery高级组件，点击"查询后"不能自动关闭弹窗 · <a href="https://link.segmentfault.com/?enc=NseTupamlvIVpaDYoKOw0Q%3D%3D.32ckvUdRHVLE%2F02gpG0sSXJco2m2%2BOqsC7gFvLGDz078aYs4USl2kg8h5RBpxEA%2Fs9Bc3jHxwFlJg9E311rvkw%3D%3D" rel="nofollow" target="_blank">Issue #9060</a></li><li>BasicTable列表页导出excel可以指定列 · <a href="https://link.segmentfault.com/?enc=%2Bh6UkCepLkEn8Aysi1HC1w%3D%3D.oOXEcqDue7doZ%2F7Q8IQXRL%2FzKEar2Jpy5PM5xMRYkAR03dfGyagcnxjWGP3pZufKAJn0cvoUMJOgqhMo1mkk0A%3D%3D" rel="nofollow" target="_blank">Issue #9052</a></li><li>请求中附带非法或过期 Token 时，返回重复的 401 请求 · <a href="https://link.segmentfault.com/?enc=S9to5IfM4RY20zyvghEhGQ%3D%3D.ITcpaFg4HGdaCm7oPcWbqa0E3lW7fhQysekfGp%2BRGmu5fXh7FW8Eb%2BJ7YLmy9BaxP%2B5HWNTdNTcfP%2Bmi96gTRw%3D%3D" rel="nofollow" target="_blank">Issue #9107</a></li><li>ai流程设计，能否增加导入导出功能 · <a href="https://link.segmentfault.com/?enc=pWDSyiOAGYRih7%2FkZKHBPQ%3D%3D.7Ib2FfC9NX7l%2BvFjioeFzh7cvke26F54pwZe1uwNcVM%2FQ2HzZtSILOKyxn%2B4X8qGVkV5TtgXELyN0h%2Fq5kFe5g%3D%3D" rel="nofollow" target="_blank">Issue #8591</a></li><li>ai流程是否能支持python脚本运行 · <a href="https://link.segmentfault.com/?enc=vFn3ihEoAo7%2FZpzqpRxN2g%3D%3D.1IQ1Ma6XjdyAgGFAYDXpkejcDPQ50OF74dukIDHGv7Z2fY1h2ZkIdbSoQhnIczbmqlSMbYGudGS9L%2FVLbiveeA%3D%3D" rel="nofollow" target="_blank">Issue #9093</a></li><li>标签页tabs关闭功能异常 · <a href="https://link.segmentfault.com/?enc=X4a26bchaquoq8Enul2Y7g%3D%3D.9cQOeGAdIRgrLzbzlxa8U4C3fCIKH1nZ%2FwE%2BENoJBK%2BcOJysSGj7TM8r7i7Wub14E78r7FTv5U4IHCGoZrIxxw%3D%3D" rel="nofollow" target="_blank">Issue #9098</a></li></ul><h4>技术交流</h4><ul><li>官方网站： <a href="https://link.segmentfault.com/?enc=tY3IhcR3ioz8lsNf95Twow%3D%3D.yTOssAF3Z5lzDhL3EN1giPq%2Blq2s%2BWS15IKva1FyatM%3D" rel="nofollow" target="_blank">http://www.jeecg.com</a></li><li>在线演示：<a href="https://link.segmentfault.com/?enc=UTW8Lmk6MsequM48uPajyg%3D%3D.8WtgflbN3uOFAlm4j1ZDiF6elImSN5Rjlkj6UrEcdmo%3D" rel="nofollow" target="_blank">http://boot3.jeecg.com</a></li><li>入门指南： <a href="https://link.segmentfault.com/?enc=yciMnXfdaPVZhIiqar6oYg%3D%3D.OQvisWEmAfpfeu%2B44n5P5l4HUutiO52aVD8nT7jaJoiyQIjMlb24cBI7bT6AuxX2" rel="nofollow" target="_blank">快速入门</a> | <a href="https://link.segmentfault.com/?enc=f2Skjqojnp6LoF6CJWgfwQ%3D%3D.XqLfegLuGZxFAs17vfaGtR6SYtDyqQ1SqCpZtroT4xI%3D" rel="nofollow" target="_blank">开发文档</a> | <a href="https://link.segmentfault.com/?enc=oftyvu7ciB5aPoAaYIYO8Q%3D%3D.JL0l0HDm04tU7qbJwjTRzsfPbVixVUQc3uCEVZGoj3Q%3D" rel="nofollow" target="_blank">AI应用使用手册</a></li><li>技术支持： <a href="https://link.segmentfault.com/?enc=VnRLNaUwIWr6CYLBYfSalA%3D%3D.9HC6EGStI3nttWxmTntDC9DrrweKzzLmnLEp2IzfZx53HMHfkOqHiOF4sHsrudcrXLi1P%2F3lH6ITOm619uOrrYaMwOuaIuUqEymk0e8ORGg%3D" rel="nofollow" target="_blank">反馈问题</a> | <a href="https://link.segmentfault.com/?enc=YOw6Ip5SjviWmz%2FVnSWCfA%3D%3D.cBFDhkwYABhK3Q%2B389Qx81%2BV1d2xUkq0EAxtBo%2FbQMg%3D" rel="nofollow" target="_blank">视频教程</a> | <a href="https://link.segmentfault.com/?enc=a8ZO52FnwsP9%2BP7H2VD3SQ%3D%3D.1M0txHs1THVNETwJacyC8RZxk%2BvUWnw4uLAz%2FAW8G51%2BurRK%2BROzQyZUGJIcORXuUlwnUJ9HpjoUzEuzsndMow%3D%3D" rel="nofollow" target="_blank">低代码体验一分钟</a></li></ul><h4>快速启动项目</h4><ul><li><a href="https://link.segmentfault.com/?enc=sam34cbLGRY946TsTMjceg%3D%3D.ga7bKQqgaLQVIYr2jdVHxjVk%2B0TzkGVynmIS%2FATE1gXzfvmCjBApVfIZBPd68aN%2B" rel="nofollow" target="_blank">IDEA启动前后端项目</a></li><li><a href="https://link.segmentfault.com/?enc=w%2FlBGbntRnlX%2Fh6gfIVGyQ%3D%3D.zaN5AoQwxUzAnsMnmkFAsg4Ft9nO6INIRCnv9nFz718CY5t6SzBBdX3vHOdnZJcJ" rel="nofollow" target="_blank">Docker一键启动前后端</a></li></ul><h4>AI应用平台介绍</h4><p>JeecgBoot 平台提供了一套完善的AI应用管理系统模块，是一套类似<code>Dify</code>的<code>AIGC应用开发平台</code>+<code>知识库问答</code>，是一款基于LLM大语言模型AI应用平台和 RAG 的知识库问答系统。 其直观的界面结合了 AI 流程编排、RAG 管道、知识库管理、模型管理、对接向量库、实时运行可观察等，让您可以快速从原型到生产，拥有AI服务能力。 <a href="https://link.segmentfault.com/?enc=uDOF%2BwH%2Fl4mnh%2FI7rvb%2FGQ%3D%3D.jSGPfNIjzQ%2BConhomW6Xvx5XReaXMFDW5zevshMQXco%3D" rel="nofollow" target="_blank">详细专题介绍，请点击查看</a></p><h4>适用项目</h4><p>JeecgBoot低代码平台，可以应用在任何J2EE项目的开发中，支持信创国产化。尤其适合SAAS项目、企业信息管理系统（MIS）、内部办公系统（OA）、企业资源计划系统（ERP）、客户关系管理系统（CRM）、AI知识库等，其半智能手工Merge的开发方式，可以显著提高开发效率70%以上，极大降低开发成本。 又是一个全栈式 AI 开发平台，快速帮助企业构建和部署个性化的 AI 应用。</p><p><strong>信创兼容说明</strong></p><ul><li>操作系统：国产麒麟、银河麒麟等国产系统几乎都是基于 Linux 内核，因此它们具有良好的兼容性。</li><li>数据库：达梦、人大金仓、TiDB</li><li>中间件：东方通 TongWeb、TongRDS，宝兰德 AppServer、CacheDB, <a href="https://link.segmentfault.com/?enc=9VdRVZbiPPAzxJrO2Rx58g%3D%3D.z1Rqf5SerBs2EBXXG0tfkYe4gohBEXv83q8PvsZybZuYBA6wIISG1Te%2BARYNiIWz" rel="nofollow" target="_blank">信创配置文档</a></li></ul><h4>为什么选择 JeecgBoot?</h4><blockquote>开源界"小普元"超越传统商业平台。引领低代码开发模式(OnlineCoding-&gt; 代码生成器 -&gt; 手工MERGE)，低代码开发同时又支持灵活编码， 可以帮助解决Java项目70%的重复工作，让开发更多关注业务。既能快速提高开发效率，节省成本，同时又不失灵活性。</blockquote><ul><li>1.采用最新主流前后分离框架（Spring Boot + MyBatis + Ant Design4 + Vue3），容易上手；代码生成器依赖性低，灵活的扩展能力，可快速实现二次开发。</li><li>2.前端大版本换代，最新版采用 Vue3.0 + TypeScript + Vite6 + Ant Design Vue4 等新技术方案。</li><li>3.支持微服务Spring Cloud Alibaba（Nacos、Gateway、Sentinel、Skywalking），提供简易机制，支持单体和微服务自由切换（这样可以满足各类项目需求）。</li><li>4.开发效率高，支持在线建表和AI建表，提供强大代码生成器，单表、树列表、一对多、一对一等数据模型，增删改查功能一键生成，菜单配置直接使用。</li><li>5.代码生成器提供强大模板机制，支持自定义模板，目前提供四套风格模板（单表两套、树模型一套、一对多三套）。</li><li>6.提供强大的报表和大屏可视化工具，支持丰富的数据源连接，能够通过拖拉拽方式快速制作报表、大屏和门户设计；支持多种图表类型：柱形图、折线图、散点图、饼图、环形图、面积图、漏斗图、进度图、仪表盘、雷达图、地图等。</li><li>7.低代码能力：在线表单（无需编码，通过在线配置表单，实现表单的增删改查，支持单表、树、一对多、一对一等模型，实现人人皆可编码），在线配置零代码开发、所见即所得支持23种类控件。</li><li>8.低代码能力：在线报表、在线图表（无需编码，通过在线配置方式，实现数据报表和图形报表，可以快速抽取数据，减轻开发压力，实现人人皆可编码）。</li><li>9.Online支持在线增强开发，提供在线代码编辑器，支持代码高亮、代码提示等功能，支持多种语言（Java、SQL、JavaScript等）。</li><li>10.封装完善的用户、角色、菜单、组织机构、数据字典、在线定时任务等基础功能，支持访问授权、按钮权限、数据权限等功能。</li><li>11.前端UI提供丰富的组件库，支持各种常用组件，如表格、树形控件、下拉框、日期选择器等，满足各种复杂的业务需求 <a href="https://link.segmentfault.com/?enc=ug6L0cJGklJD1ZyMFDuTGA%3D%3D.NJx1LagFqXj95jeXUQhxtsz%2BX1Cy%2B2qP0%2F0uw%2Bj9lINHNlpISjAY%2Fx8vQhKQ5iC3fGzoZjQVxyw6xC42DY%2FbAw%3D%3D" rel="nofollow" target="_blank">UI组件库文档</a>。</li><li>12.提供APP配套框架，一份多代码多终端适配，一份代码多终端适配，小程序、H5、安卓、iOS、鸿蒙Next。</li><li>13.新版APP框架采用Uniapp、Vue3.0、Vite、Wot-design-uni、TypeScript等最新技术栈，包括二次封装组件、路由拦截、请求拦截等功能。实现了与JeecgBoot完美对接：目前已经实现登录、用户信息、通讯录、公告、移动首页、九宫格、聊天、Online表单、仪表盘等功能，提供了丰富的组件。</li><li>14.提供了一套成熟的AI应用平台功能，从AI模型、知识库到AI应用搭建，助力企业快速落地AI服务，加速智能化升级。</li><li>15.AI能力：目前JeecgBoot支持AI大模型chatgpt和deepseek，现在最新版默认使用deepseek，速度更快质量更高。目前提供了AI对话助手、AI知识库、AI应用、AI建表、AI报表等功能。</li><li>16.提供新行编辑表格JVXETable，轻松满足各种复杂ERP布局，拥有更高的性能、更灵活的扩展、更强大的功能。</li><li>17.平台首页风格，提供多种组合模式，支持自定义风格；支持门户设计，支持自定义首页。</li><li>18.常用共通封装，各种工具类（定时任务、短信接口、邮件发送、Excel导入导出等），基本满足80%项目需求。</li><li>19.简易Excel导入导出，支持单表导出和一对多表模式导出，生成的代码自带导入导出功能。</li><li>20.集成智能报表工具，报表打印、图像报表和数据导出非常方便，可极其方便地生成PDF、Excel、Word等报表。</li><li>21.采用前后分离技术，页面UI风格精美，针对常用组件做了封装：时间、行表格控件、截取显示控件、报表组件、编辑器等。</li><li>22.查询过滤器：查询功能自动生成，后台动态拼SQL追加查询条件；支持多种匹配方式（全匹配/模糊查询/包含查询/不匹配查询）。</li><li>23.数据权限（精细化数据权限控制，控制到行级、列表级、表单字段级，实现不同人看不同数据，不同人对同一个页面操作不同字段）。</li><li>24.接口安全机制，可细化控制接口授权，非常简便实现不同客户端只看自己数据等控制；也提供了基于AK和SK认证鉴权的OpenAPI功能。</li><li>25.活跃的社区支持；近年来，随着网络威胁的日益增加，团队在安全和漏洞管理方面积累了丰富的经验，能够为企业提供全面的安全解决方案。</li><li>26.权限控制采用RBAC（Role-Based Access Control，基于角色的访问控制）。</li><li>27.页面校验自动生成（必须输入、数字校验、金额校验、时间空间等）。</li><li>28.支持SaaS服务模式，提供SaaS多租户架构方案。</li><li>29.分布式文件服务，集成MinIO、阿里OSS等优秀的第三方，提供便捷的文件上传与管理，同时也支持本地存储。</li><li>30.主流数据库兼容，一套代码完全兼容MySQL、PostgreSQL、Oracle、SQL Server、MariaDB、达梦、人大金仓等主流数据库。</li><li>31.集成工作流Flowable，并实现了只需在页面配置流程转向，可极大简化BPM工作流的开发；用BPM的流程设计器画出了流程走向，一个工作流基本就完成了，只需写很少量的Java代码。</li><li>32.低代码能力：在线流程设计，采用开源Flowable流程引擎，实现在线画流程、自定义表单、表单挂靠、业务流转。</li><li>33.多数据源：极其简易的使用方式，在线配置数据源配置，便捷地从其他数据抓取数据。</li><li>34.提供单点登录CAS集成方案，项目中已经提供完善的对接代码。</li><li>35.低代码能力：表单设计器，支持用户自定义表单布局，支持单表、一对多表单，支持select、radio、checkbox、textarea、date、popup、列表、宏等控件。</li><li>36.专业接口对接机制，统一采用RESTful接口方式，集成Swagger-UI在线接口文档，JWT token安全验证，方便客户端对接。</li><li>37.高级组合查询功能，在线配置支持主子表关联查询，可保存查询历史。</li><li>38.提供各种系统监控，实时跟踪系统运行情况（监控Redis、Tomcat、JVM、服务器信息、请求追踪、SQL监控）。</li><li>39.消息中心（支持短信、邮件、微信推送等）；集成WebSocket消息通知机制。</li><li>40.支持多语言，提供国际化方案。</li><li>41.数据变更记录日志，可记录数据每次变更内容，通过版本对比功能查看历史变化。</li><li>42.提供简单易用的打印插件，支持谷歌、火狐、IE11+等各种浏览器。</li><li>43.后端采用Maven分模块开发方式；前端支持菜单动态路由。</li><li>44.提供丰富的示例代码，涵盖了常用的业务场景，便于学习和参考。</li></ul><h4>技术架构：</h4><h6>前端</h6><ul><li>前端环境要求：Node.js要求<code>Node 20+</code> 版本以上、pnpm 要求<code>9+</code> 版本以上</li><li>依赖管理：node、npm、pnpm</li><li>前端IDE建议：IDEA、WebStorm、Vscode</li><li>采用 Vue3.0+TypeScript+Vite6+Ant-Design-Vue4等新技术方案，包括二次封装组件、utils、hooks、动态菜单、权限校验、按钮级别权限控制等功能</li><li>最新技术栈：Vue3.0 + TypeScript + Vite6 + ant-design-vue4 + pinia + echarts + unocss + vxe-table + qiankun + es6</li></ul><h6>后端</h6><ul><li>IDE建议： IDEA (必须安装lombok插件 )</li><li>语言：Java 默认jdk17(支持jdk8、jdk21)</li><li>依赖管理：Maven</li><li>基础框架：Spring Boot 2.7.18</li><li>微服务框架： Spring Cloud Alibaba 2021.0.6.2</li><li>持久层框架：MybatisPlus 3.5.3.2</li><li>报表工具： JimuReport 1.9.5</li><li>安全框架：Apache Shiro 1.13.0，Jwt 4.5.0</li><li>微服务技术栈：Spring Cloud Alibaba、Nacos、Gateway、Sentinel、Skywalking</li><li>数据库连接池：阿里巴巴Druid 1.1.24</li><li>AI大模型：支持 <code>ChatGPT</code> <code>DeepSeek</code>切换</li><li>日志打印：logback</li><li>缓存：Redis</li><li>其他：autopoi, fastjson，poi，Swagger-ui，quartz, lombok（简化代码）等。</li><li>默认提供MySQL5.7+数据库脚本</li></ul><h4>微服务架构图</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047129272" alt="" title=""/></p><h4>微服务解决方案</h4><blockquote><p>微服务方式快速启动</p><ul><li><a href="https://link.segmentfault.com/?enc=sN6iNAFs1DUPu%2B9wgg71lQ%3D%3D.LKNNP4rSKOVZPLTOA7LZlpeqwpJLJRouCgLfMQYDuvF0i2pFQt7HRU4EGw32%2FW%2BUTsF18oY4NuawBQdxsb3DcA%3D%3D" rel="nofollow" target="_blank">单体快速切换微服务</a></li><li><a href="https://link.segmentfault.com/?enc=r4krXA55%2B40W4e1q8UGQWw%3D%3D.jwTpnB3W6%2BxyG42PmBA%2Bi3%2FMNafI82YSRXukqKqDCo2N9aLnGLuMyZoq%2FvJvXGk7" rel="nofollow" target="_blank">Docker一键启动微服务前后端</a></li></ul></blockquote><ul><li>1、服务注册和发现 Nacos √</li><li>2、统一配置中心 Nacos √</li><li>3、路由网关 gateway(三种加载方式) √</li><li>4、分布式 http feign √</li><li>5、熔断降级限流 Sentinel √</li><li>6、分布式文件 Minio、阿里OSS √</li><li>7、统一权限控制 JWT + Shiro √</li><li>8、服务监控 SpringBootAdmin√</li><li>9、链路跟踪 Skywalking <a href="https://link.segmentfault.com/?enc=jzjGja%2FLrut41GdXwXmkNg%3D%3D.rCj3ERfDotuVReDDpFCn8tPVdqOBFHEXgIUZ9ODrKfVLhK4W%2BKnOS5BlBZynsCQ4S110wBQEydMPsgXfD5UNWw%3D%3D" rel="nofollow" target="_blank">参考文档</a></li><li>10、消息中间件 RabbitMQ √</li><li>11、分布式任务 xxl-job √</li><li>12、分布式事务 Seata</li><li>13、轻量分布式日志 Loki+grafana套件</li><li>14、支持 docker-compose、k8s、jenkins</li><li>15、CAS 单点登录 √</li><li>16、路由限流 √</li></ul><h4>Jeecg Boot 产品功能蓝图</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047129273" alt="" title="" loading="lazy"/></p><h4>系统功能架构图</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047129274" alt="" title="" loading="lazy"/></p><h4>开源版功能清单</h4><pre><code>├─系统管理
│  ├─用户管理
│  ├─角色管理
│  ├─菜单管理
│  ├─权限设置（支持按钮权限、数据权限）
│  ├─表单权限（控制字段禁用、隐藏）
│  ├─部门管理
│  ├─我的部门（二级管理员）
│  └─字典管理
│  └─分类字典
│  └─系统公告
│  └─职务管理
│  └─通讯录
│  ├─多数据源管理
│  └─多租户管理（租户管理、租户角色、我的租户）
├─Online在线开发(低代码)
│  ├─Online在线表单
│  ├─Online代码生成器
│  ├─Online在线报表
│  ├─仪表盘设计器
│  ├─系统编码规则
│  ├─系统校验规则
├─AI应用平台
│  ├─AI知识库问答系统
│  ├─AI大模型管理
│  ├─AI流程编排
│  ├─AI流程设计器
│  ├─AI对话支持图片
│  ├─AI对话助手(智能问答)
│  ├─AI建表（Online表单）
│  ├─AI聊天窗口支持嵌入第三方
│  ├─AI聊天窗口支持移动端
│  ├─支持常见大模型ChatGPT和DeepSeek、ollama等等
│  ├─AI OCR示例
├─积木报表设计器
│  ├─打印设计器
│  ├─数据报表设计
│  ├─图形报表设计（支持echart）
├─消息中心
│  ├─消息管理
│  ├─模板管理
├─代码生成器(低代码)
│  ├─代码生成器功能（一键生成前后端代码，生成后无需修改直接用，绝对是后端开发福音）
│  ├─代码生成器模板（提供4套模板，分别支持单表和一对多模型，不同风格选择）
│  ├─代码生成器模板（生成代码，自带excel导入导出）
│  ├─查询过滤器（查询逻辑无需编码，系统根据页面配置自动生成）
│  ├─高级查询器（弹窗自动组合查询条件）
│  ├─Excel导入导出工具集成（支持单表，一对多 导入导出）
│  ├─平台移动自适应支持
│  ├─提供新版uniapp3的代码生成器模板
├─系统监控
│  ├─基于AK和SK认证鉴权OpenAPI功能
│  ├─Gateway路由网关
│  ├─性能扫描监控
│  │  ├─监控 Redis
│  │  ├─Tomcat
│  │  ├─jvm
│  │  ├─服务器信息
│  │  ├─请求追踪
│  │  ├─磁盘监控
│  ├─定时任务
│  ├─系统日志
│  ├─消息中心（支持短信、邮件、微信推送等等）
│  ├─数据日志（记录数据快照，可对比快照，查看数据变更情况）
│  ├─系统通知
│  ├─SQL监控
│  ├─swagger-ui(在线接口文档)
│─报表示例
│  ├─曲线图
│  └─饼状图
│  └─柱状图
│  └─折线图
│  └─面积图
│  └─雷达图
│  └─仪表图
│  └─进度条
│  └─排名列表
│  └─等等
│─大屏模板
│  ├─作战指挥中心大屏
│  └─物流服务中心大屏
│─常用示例
│  ├─自定义组件
│  ├─对象存储(对接阿里云)
│  ├─JVXETable示例（各种复杂ERP布局示例）
│  ├─单表模型例子
│  └─一对多模型例子
│  └─打印例子
│  └─一对多TAB例子
│  └─内嵌table例子
│  └─常用选择组件
│  └─异步树table
│  └─接口模拟测试
│  └─表格合计示例
│  └─异步树列表示例
│  └─一对多JEditable
│  └─JEditable组件示例
│  └─图片拖拽排序
│  └─图片翻页
│  └─图片预览
│  └─PDF预览
│  └─分屏功能
│─封装通用组件    
│  ├─行编辑表格JEditableTable
│  └─省略显示组件
│  └─时间控件
│  └─高级查询
│  └─用户选择组件
│  └─报表组件封装
│  └─字典组件
│  └─下拉多选组件
│  └─选人组件
│  └─选部门组件
│  └─通过部门选人组件
│  └─封装曲线、柱状图、饼状图、折线图等等报表的组件（经过封装，使用简单）
│  └─在线code编辑器
│  └─上传文件组件
│  └─验证码组件
│  └─树列表组件
│  └─表单禁用组件
│  └─等等
│─更多页面模板
│  ├─各种高级表单
│  ├─各种列表效果
│  └─结果页面
│  └─异常页面
│  └─个人页面
├─高级功能
│  ├─提供单点登录CAS集成方案
│  ├─提供APP发布方案
│  ├─集成Websocket消息通知机制
│  ├─支持electron桌面应用打包(支持windows、linux、macOS三大平台)
│  ├─docker容器支持
│  ├─提供移动APP框架及源码（Uniapp3版本）支持H5、小程序、APP、鸿蒙Next
│  ├─提供移动APP低代码设计(Online表单、仪表盘)
</code></pre><h4>系统效果预览</h4><h5>PC端</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440465" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440466" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440467" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440468" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440469" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440470" alt="" title="" loading="lazy"/></p><h5>在线聊天&amp;通知</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440471" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440472" alt="" title="" loading="lazy"/></p><h5>Online开发(在线配置表单和报表)</h5><p><a href="https://link.segmentfault.com/?enc=yY%2Fx%2FKui1onHLA9GeZkIwA%3D%3D.0tBjbd6%2BSx0L144Ijl5296kjszwS6zH4x2P5vBGOdWi2nja3FzTFW9EjODm7LTSSUvZZovl%2FM%2B%2FL2oosqs35oQ8Ib3AEzkiiKJaoY1Lkah8%3D" rel="nofollow" target="_blank"><img referrerpolicy="no-referrer" src="/img/remote/1460000045590990" alt="" title="" loading="lazy"/></a></p><h5>图表示例</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266526" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266527" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266528" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266529" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266530" alt="" title="" loading="lazy"/></p><h5>AI功能</h5><p>AI聊天助手</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266522" alt="" title="" loading="lazy"/></p><p>AI建表</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046092845" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046092846" alt="" title="" loading="lazy"/></p><p>AI写文章</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046092847" alt="" title="" loading="lazy"/></p><h5>积木BI大屏</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590982" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590983" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590984" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590985" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590986" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590987" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045590988" alt="" title="" loading="lazy"/></p><h5>APP效果</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266539" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266540" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266541" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266542" alt="" title="" loading="lazy"/></p><h5>PAD端</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266543" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266544" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266545" alt="" title="" loading="lazy"/></p><h5>在线接口文档</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266546" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045266547" alt="" title="" loading="lazy"/></p><h5>积木报表</h5><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440473" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440474" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440475" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440476" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440477" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440478" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440479" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440480" alt="" title="" loading="lazy"/></p><p>欢迎吐槽，欢迎star~</p>]]></description></item><item>    <title><![CDATA[深度解读虚拟列表：从原理到实战，解决长列]]></title>    <link>https://segmentfault.com/a/1190000047440568</link>    <guid>https://segmentfault.com/a/1190000047440568</guid>    <pubDate>2025-12-01 12:03:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>深度解读虚拟列表：从原理到实战，解决长列表渲染性能难题</h2><h3>前言：被长列表 “卡崩” 的前端日常</h3><p>“万级数据加载后，页面滚动像幻灯片？”<br/>“列表项含图片时，滚动到一半突然‘跳位’？”<br/>“DOM 数量破万后，浏览器直接提示‘页面无响应’？”</p><p>做前端开发的你，大概率遇到过这些场景。这不是代码能力的问题 —— 浏览器的渲染瓶颈摆在那里：每新增一个 DOM 元素，都会增加重排重绘的计算成本，当 DOM 数量突破 5000 时，多数设备都会出现明显卡顿。</p><p>而虚拟列表（Virtual List），正是为解决这个痛点而生。它的核心逻辑极其简洁：<strong>只渲染当前可视区域内的列表项，非可视区域内容完全不渲染</strong>。通过 “用空间换时间” 的思路，把 DOM 数量牢牢控制在几十到几百的常量级别，哪怕数据量达到十万级，页面也能保持丝滑滚动。</p><p>本文将完全围绕下面提供的 “可变高度虚拟列表（可配置版）”Demo 展开，从核心原理拆解、关键步骤实现，到 Demo 的实战亮点、落地避坑，帮你把虚拟列表从 “面试知识点” 变成 “业务可用的工具”。</p><h3>给你附上完整demo (这还不值得你一键三连吗？！)</h3><pre><code class="html">
&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;可变高度虚拟列表（可配置版）&lt;/title&gt;
  &lt;style&gt;
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #f5f5f5;
    }

    .container {
      display: flex;
      gap: 30px;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* 虚拟列表样式 */
    .virtual-list-container {
      height: 600px; /* 可视区域高度 */
      overflow-y: auto;
      position: relative;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background: white;
      width: 600px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .virtual-list-placeholder {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: -1; /* 不影响滚动 */
    }

    .virtual-list-content {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 0 16px;
    }

    .virtual-list-item {
      margin: 12px 0;
      padding: 16px;
      border-radius: 6px;
      background: #fafafa;
      border: 1px solid #eee;
      transition: background 0.2s;
    }

    .virtual-list-item:hover {
      background: #f0f9ff;
      border-color: #e1f5fe;
    }

    /* 调试面板样式 */
    .debug-panel {
      flex: 1;
      min-width: 300px;
      background: white;
      border-radius: 8px;
      padding: 20px;
      border: 1px solid #e0e0e0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }

    .debug-panel h3 {
      margin-bottom: 20px;
      color: #2d3748;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
    }

    .debug-item {
      margin-bottom: 12px;
      display: flex;
      justify-content: space-between;
    }

    .debug-label {
      color: #4a5568;
      font-size: 14px;
    }

    .debug-value {
      color: #2563eb;
      font-weight: 600;
      font-size: 14px;
      min-width: 60px;
      text-align: right;
    }

    /* 配置输入区域样式 */
    .config-group {
      margin: 20px 0;
      padding: 16px;
      background: #f8fafc;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }

    .config-group h4 {
      margin-bottom: 12px;
      color: #2d3748;
      font-size: 15px;
    }

    .config-item {
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .config-item label {
      flex: 1;
      color: #4a5568;
      font-size: 14px;
    }

    .config-item input {
      flex: 1;
      padding: 8px 10px;
      border: 1px solid #cbd5e1;
      border-radius: 4px;
      font-size: 14px;
      width: 100px;
    }

    .config-item input:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
    }

    .btn-apply {
      width: 100%;
      padding: 10px;
      margin-top: 8px;
      border: none;
      border-radius: 4px;
      background: #10b981;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn-apply:hover {
      background: #059669;
    }

    .control-group {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #eee;
    }

    .control-group button {
      padding: 8px 16px;
      margin-right: 10px;
      margin-bottom: 10px;
      border: none;
      border-radius: 4px;
      background: #2563eb;
      color: white;
      cursor: pointer;
      transition: background 0.2s;
    }

    .control-group button:hover {
      background: #1d4ed8;
    }

    .control-group button.reset {
      background: #94a3b8;
    }

    .control-group button.reset:hover {
      background: #64748b;
    }

    .info-text {
      margin-top: 10px;
      font-size: 12px;
      color: #718096;
      line-height: 1.5;
    }

    .error-text {
      color: #dc2626;
      font-size: 12px;
      margin-top: 4px;
      height: 16px;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class="container"&gt;
    &lt;!-- 虚拟列表容器 --&gt;
    &lt;div class="virtual-list-container"&gt;
      &lt;div class="virtual-list-placeholder"&gt;&lt;/div&gt;
      &lt;div class="virtual-list-content"&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- 调试面板 --&gt;
    &lt;div class="debug-panel"&gt;
      &lt;h3&gt;虚拟列表调试信息&lt;/h3&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;总列表项数：&lt;/span&gt;
        &lt;span class="debug-value" id="total-count"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;已渲染项数：&lt;/span&gt;
        &lt;span class="debug-value" id="rendered-count"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;可视起始索引：&lt;/span&gt;
        &lt;span class="debug-value" id="start-index"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;可视结束索引：&lt;/span&gt;
        &lt;span class="debug-value" id="end-index"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;滚动位置(scrollTop)：&lt;/span&gt;
        &lt;span class="debug-value" id="scroll-top"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;列表总高度：&lt;/span&gt;
        &lt;span class="debug-value" id="total-height"&gt;0&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;预估高度：&lt;/span&gt;
        &lt;span class="debug-value" id="estimate-height"&gt;80&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;缓冲项数量：&lt;/span&gt;
        &lt;span class="debug-value" id="buffer-count"&gt;2&lt;/span&gt;
      &lt;/div&gt;

      &lt;div class="debug-item"&gt;
        &lt;span class="debug-label"&gt;最大缓存列表项条数：&lt;/span&gt;
        &lt;span class="debug-value" id="max-cache-size"&gt;100&lt;/span&gt;
      &lt;/div&gt;

      &lt;!-- 新增：配置输入区域 --&gt;
      &lt;div class="config-group"&gt;
        &lt;h4&gt;自定义配置&lt;/h4&gt;
        &lt;div class="config-item"&gt;
          &lt;label for="custom-total"&gt;列表总条数：&lt;/label&gt;
          &lt;input type="number" id="custom-total" placeholder="默认1000" min="1" max="100000"&gt;
        &lt;/div&gt;
        &lt;div class="config-item"&gt;
          &lt;label for="custom-buffer"&gt;缓冲项数量：&lt;/label&gt;
          &lt;input type="number" id="custom-buffer" placeholder="默认2" min="0" max="10"&gt;
        &lt;/div&gt;
        &lt;div class="config-item"&gt;
          &lt;label for="custom-estimate"&gt;预估高度(px)：&lt;/label&gt;
          &lt;input type="number" id="custom-estimate" placeholder="默认80" min="20" max="500"&gt;
        &lt;/div&gt;
        &lt;div class="config-item"&gt;
          &lt;label for="custom-maxCacheSize"&gt;最大缓存列表项条数：&lt;/label&gt;
          &lt;input type="number" id="custom-maxCacheSize" placeholder="默认100" min="0" max="200"&gt;
        &lt;/div&gt;
        &lt;div class="error-text" id="config-error"&gt;&lt;/div&gt;
        &lt;button class="btn-apply" id="apply-config"&gt;应用配置&lt;/button&gt;
      &lt;/div&gt;

      &lt;div class="control-group"&gt;
        &lt;button id="refresh-data"&gt;刷新测试数据&lt;/button&gt;
        &lt;button id="reset" class="reset"&gt;重置默认配置&lt;/button&gt;

        &lt;div class="info-text"&gt;
          说明：&lt;br&gt;
          1. 支持手动输入列表总数（1-100000）、缓冲数（0-10）、预估高度（20-500px）、缓存条数（0-200）&lt;br&gt;
          2. 列表项高度随机（含部分图片），滚动时自动校准真实高度&lt;br&gt;
          3. 缓冲数越大，滚动越流畅但渲染DOM越多；缓冲数为0可能出现空白&lt;br&gt;
          3. 缓存数越大，滚动越流畅但渲染DOM越多；复用列表项，不会重新渲染&lt;br&gt;
          4. 总数建议不超过10万，避免内存占用过高
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;script&gt;
    class VariableHeightVirtualList {
      constructor(options) {
        // 配置参数
        this.container = options.container;
        this.data = options.data;
        this.estimateHeight = options.estimateHeight || 80;
        this.buffer = options.buffer || 2;
        this.maxCacheSize = options.maxCacheSize || 100;
        this.defaultTotal = this.data.length;
        this.defaultEstimateHeight = this.estimateHeight;
        this.defaultBuffer = this.buffer;
        this.defaultMaxCacheSize = this.maxCacheSize;


        // 核心数据
        this.itemHeights = new Array(this.data.length).fill(this.estimateHeight);
        this.prefixHeights = [0];
        this.containerHeight = this.container.clientHeight;
        this.scrollTop = 0;
        this.currentStartIndex = 0;
        this.currentEndIndex = 0;
        this.cacheElements = [];
        this.cacheElementsRecord = [];

        // DOM元素
        this.placeholder = this.container.querySelector('.virtual-list-placeholder');
        this.content = this.container.querySelector('.virtual-list-content');

        // 调试DOM
        this.debugElements = {
          totalCount: document.getElementById('total-count'),
          renderedCount: document.getElementById('rendered-count'),
          startIndex: document.getElementById('start-index'),
          endIndex: document.getElementById('end-index'),
          scrollTop: document.getElementById('scroll-top'),
          totalHeight: document.getElementById('total-height'),
          estimateHeight: document.getElementById('estimate-height'),
          bufferCount: document.getElementById('buffer-count'),
          maxCacheSize: document.getElementById('max-cache-size')
        };

        // 配置输入DOM
        this.configElements = {
          customTotal: document.getElementById('custom-total'),
          customBuffer: document.getElementById('custom-buffer'),
          customEstimate: document.getElementById('custom-estimate'),
          customMaxCacheSize: document.getElementById('custom-maxCacheSize'),
          configError: document.getElementById('config-error'),
          applyBtn: document.getElementById('apply-config')
        };

        // 初始化
        this.init();
      }

      // 初始化
      init() {
        this.calcPrefixHeights();
        this.updatePlaceholderHeight();
        this.updateVisibleItems();
        this.updateDebugInfo(); // 初始化调试信息
        this.bindEvents();
        this.bindConfigEvents(); // 绑定配置相关事件
      }

      // 计算前缀和
      calcPrefixHeights() {
        for (let i = 0; i &lt; this.data.length; i++) {
          this.prefixHeights[i + 1] = this.prefixHeights[i] + this.itemHeights[i];
        }
      }

      // 更新占位高度
      updatePlaceholderHeight() {
        const totalHeight = this.prefixHeights[this.data.length];
        this.placeholder.style.height = `${totalHeight}px`;
        // 更新调试信息中的总高度
        this.debugElements.totalHeight.textContent = Math.round(totalHeight);
      }

      // 二分查找起始索引
      findStartIndex() {
        const scrollTop = this.scrollTop;
        let low = 0, high = this.prefixHeights.length - 1;

        while (low &lt;= high) {
          const mid = Math.floor((low + high) / 2);
          if (this.prefixHeights[mid] &lt;= scrollTop) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        return Math.max(0, low - 1);
      }

      // 计算结束索引
      findEndIndex(startIndex) {
        const scrollBottom = this.scrollTop + this.containerHeight;
        let endIndex = startIndex;

        while (endIndex &lt; this.data.length &amp;&amp; this.prefixHeights[endIndex + 1] &lt;= scrollBottom) {
          endIndex++;
        }

        endIndex = Math.min(this.data.length, endIndex + this.buffer);
        return endIndex;
      }

      // 渲染可见项
      updateVisibleItems() {
        this.currentStartIndex = this.findStartIndex();
        this.currentEndIndex = this.findEndIndex(this.currentStartIndex);
        const visibleData = this.data.slice(this.currentStartIndex, this.currentEndIndex);

        // 渲染项（包含索引和高度信息，方便调试）
        this.content.innerHTML = '';
        visibleData.forEach((item, idx) =&gt; {
          const realIndex = this.currentStartIndex + idx;
          this.cacheElementsRecord = this.cacheElementsRecord.filter(i =&gt; i !== realIndex);
          this.cacheElementsRecord.unshift(realIndex);
          if(this.cacheElementsRecord.length &gt; this.maxCacheSize){
            const removeIndex = this.cacheElementsRecord.pop();
            delete this.cacheElements[removeIndex];
          }
          if(this.cacheElements[realIndex]){
            this.content.appendChild(this.cacheElements[realIndex]);
            return;
          }
          const itemHeight = this.itemHeights[realIndex];
          const element = document.createElement('div');
          element.innerHTML = `
            &lt;div class="virtual-list-item" data-index="${realIndex}"&gt;
              &lt;div style="margin-bottom: 8px; color: #64748b; font-size: 12px;"&gt;
                索引: ${realIndex} | 高度: ${itemHeight}px
              &lt;/div&gt;
              &lt;div style="color: #2d3748; line-height: 1.6;"&gt;
                ${item.content}
              &lt;/div&gt;
            &lt;/div&gt;
          `;
          this.cacheElements[realIndex] = element;
          this.content.appendChild(element);
        });

        // 定位内容区
        const offsetTop = this.prefixHeights[this.currentStartIndex];
        this.content.style.transform = `translateY(${offsetTop}px)`;

        // 校准高度
        this.calibrateHeights();

        // 更新调试信息
        this.updateDebugInfo();
      }

      // 校准真实高度
      calibrateHeights() {
        const items = this.content.querySelectorAll('.virtual-list-item');
        let isHeightChanged = false;

        items.forEach(item =&gt; {
          const index = parseInt(item.dataset.index);
          const realHeight = item.offsetHeight;

          if (this.itemHeights[index] !== realHeight) {
            this.itemHeights[index] = realHeight;
            isHeightChanged = true;
            // 实时更新项内的高度显示（调试用）
            item.querySelector('div:first-child').textContent = 
              `索引: ${index} | 高度: ${realHeight}px (已校准)`;
          }
        });

        if (isHeightChanged) {
          this.calcPrefixHeights();
          this.updatePlaceholderHeight();
          this.updateVisibleItems();
        }
      }

      // 更新调试信息
      updateDebugInfo() {
        this.debugElements.totalCount.textContent = this.data.length;
        this.debugElements.renderedCount.textContent = this.currentEndIndex - this.currentStartIndex;
        this.debugElements.startIndex.textContent = this.currentStartIndex;
        this.debugElements.endIndex.textContent = this.currentEndIndex - 1; // 显示最后一个可见索引
        this.debugElements.scrollTop.textContent = Math.round(this.scrollTop);
        this.debugElements.estimateHeight.textContent = this.estimateHeight;
        this.debugElements.bufferCount.textContent = this.buffer;
        this.debugElements.maxCacheSize.textContent = this.maxCacheSize;

        // 同步输入框默认值（显示当前配置）
        this.configElements.customTotal.placeholder = this.data.length;
        this.configElements.customBuffer.placeholder = this.buffer;
        this.configElements.customMaxCacheSize.placeholder = this.maxCacheSize;
        this.configElements.customEstimate.placeholder = this.estimateHeight;
      }

      // 绑定基础事件（滚动、resize等）
      bindEvents() {
        // 滚动事件（添加防抖，优化性能）
        let scrollTimer = null;
        this.container.addEventListener('scroll', () =&gt; {
          clearTimeout(scrollTimer);
          scrollTimer = setTimeout(() =&gt; {
            this.scrollTop = this.container.scrollTop;
            this.updateVisibleItems();
          }, 10); // 10ms防抖
        });

        // 窗口resize
        window.addEventListener('resize', () =&gt; {
          this.containerHeight = this.container.clientHeight;
          this.updateVisibleItems();
        });

        // 图片加载完成后校准高度（如果项内有图片）
        this.content.addEventListener('load', (e) =&gt; {
          if (e.target.tagName === 'IMG') {
            this.calibrateHeights();
          }
        }, true);
      }

      // 绑定配置相关事件
      bindConfigEvents() {
        // 应用配置按钮点击事件
        this.configElements.applyBtn.addEventListener('click', () =&gt; {
          this.applyCustomConfig();
        });

        // 输入框回车触发应用配置
        [this.configElements.customTotal, this.configElements.customBuffer, this.configElements.customEstimate, this.configElements.customMaxCacheSize]
          .forEach(input =&gt; {
            input.addEventListener('keydown', (e) =&gt; {
              if (e.key === 'Enter') {
                this.applyCustomConfig();
              }
            });
          });
      }

      // 应用自定义配置
      applyCustomConfig() {
        const customTotal = this.configElements.customTotal.value.trim();
        const customBuffer = this.configElements.customBuffer.value.trim();
        const customEstimate = this.configElements.customEstimate.value.trim();
        const customMaxCacheSize = this.configElements.customMaxCacheSize.value.trim();
        const errorEl = this.configElements.configError;

        // 验证输入
        let errorMsg = '';
        let newTotal = this.data.length;
        let newBuffer = this.buffer;
        let newEstimate = this.estimateHeight;
        let newMaxCacheSize = this.maxCacheSize;

        // 验证总数
        if (customTotal) {
          const num = parseInt(customTotal);
          if (isNaN(num) || num &lt; 1 || num &gt; 100000) {
            errorMsg = '列表总数必须是1-100000的数字';
          } else {
            newTotal = num;
          }
        }

        // 验证缓冲数（如果输入了）
        if (!errorMsg &amp;&amp; customBuffer) {
          const num = parseInt(customBuffer);
          if (isNaN(num) || num &lt; 0 || num &gt; 10) {
            errorMsg = '缓冲数必须是0-10的数字';
          } else {
            newBuffer = num;
          }
        }

        // 验证预估高度（如果输入了）
        if (!errorMsg &amp;&amp; customEstimate) {
          const num = parseInt(customEstimate);
          if (isNaN(num) || num &lt; 20 || num &gt; 500) {
            errorMsg = '预估高度必须是20-500的数字';
          } else {
            newEstimate = num;
          }
        }

        // 验证最大缓存数（如果输入了）
        if (!errorMsg &amp;&amp; customMaxCacheSize) {
          const num = parseInt(customMaxCacheSize);
          if (isNaN(num) || num &lt; 0 || num &gt; 200) {
            errorMsg = '最大缓存列表项数必须是0-200的数字';
          } else {
            newMaxCacheSize = num;
          }
        }

        // 处理错误
        if (errorMsg) {
          errorEl.textContent = errorMsg;
          errorEl.style.color = '#fc5430';
          setTimeout(() =&gt; {
            errorEl.textContent = '';
          }, 3000);
          return;
        }

        // 生成新数据（如果总数变化）
        let newData = this.data;
        if (newTotal !== this.data.length) {
          newData = generateMockData(newTotal);
        }

        // 更新配置和数据
        this.updateConfig({
          buffer: newBuffer,
          estimateHeight: newEstimate,
          maxCacheSize: newMaxCacheSize
        });
        this.updateData(newData);

        // 清空输入框
        this.configElements.customTotal.value = '';
        this.configElements.customBuffer.value = '';
        this.configElements.customEstimate.value = '';
        this.configElements.customMaxCacheSize.value = '';

        // 提示成功
        errorEl.textContent = '配置应用成功！';
        errorEl.style.color = '#10b981';
        setTimeout(() =&gt; {
          errorEl.textContent = '';
        }, 2000);
      }

      // 外部API：更新数据
      updateData(newData) {
        this.data = newData;
        this.itemHeights = new Array(this.data.length).fill(this.estimateHeight);
        this.prefixHeights = [0];
        this.cacheElements = [];
        this.cacheElementsRecord = [];
        this.calcPrefixHeights();
        this.updatePlaceholderHeight();
        this.updateVisibleItems();
      }

      // 外部API：修改配置
      updateConfig(config) {
        if (config.estimateHeight) this.estimateHeight = config.estimateHeight;
        if (config.buffer !== undefined) this.buffer = config.buffer;
        if (config.maxCacheSize !== undefined) this.maxCacheSize = config.maxCacheSize;
        this.itemHeights = new Array(this.data.length).fill(this.estimateHeight);
        this.prefixHeights = [0];
        this.cacheElements = [];
        this.cacheElementsRecord = [];
        this.calcPrefixHeights();
        this.updatePlaceholderHeight();
        this.updateVisibleItems();
      }

      reset() {
        this.updateConfig({
          estimateHeight: this.defaultEstimateHeight,
          buffer: this.defaultBuffer,
          maxCacheSize: this.defaultMaxCacheSize
        });
        this.updateData(generateMockData(this.defaultTotal));
      }
    }

    // ---------------- 测试数据生成 ----------------
    function generateMockData(count = 1000) {
      // 随机内容长度，模拟不同高度
      const contentLengths = [1, 2, 3, 4, 5, 6, 8, 10];
      return Array.from({ length: count }, (_, i) =&gt; {
        const length = contentLengths[Math.floor(Math.random() * contentLengths.length)];
        return {
          content: `可变高度列表项 ${i + 1} 
            ${'—— 测试内容重复'.repeat(length)} 
            ${Math.random() &gt; 0.7 ? '&lt;br&gt;&lt;img src="https://picsum.photos/200/80?random=' + i + '" style="max-width:100%;border-radius:4px;margin-top:8px;" alt="测试图"&gt;' : ''}`
        };
      });
    }

    // ---------------- 初始化 + 调试控制 ----------------
    const initialData = generateMockData(1000);
    const virtualList = new VariableHeightVirtualList({
      container: document.querySelector('.virtual-list-container'),
      data: initialData,
      estimateHeight: 80,
      buffer: 2,
      maxCacheSize: 10
    });

    // 刷新数据按钮
    document.getElementById('refresh-data').addEventListener('click', () =&gt; {
      const currentTotal = virtualList.data.length;
      const newData = generateMockData(currentTotal);
      virtualList.updateData(newData);
      alert(`已刷新数据，当前共 ${currentTotal} 条`);
    });

    // 重置按钮
    document.getElementById('reset').addEventListener('click', () =&gt; {
      virtualList.reset();
      alert(`已重置默认配置：总数=${virtualList.defaultTotal}，预估高度=${virtualList.defaultEstimateHeight}px，缓冲项=${virtualList.defaultBuffer}，最大缓存列表项=${virtualList.defaultMaxCacheSize}`);
    });
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><h3>一、先搞懂：虚拟列表的核心逻辑与分类</h3><p>在写一行代码前，先理清虚拟列表的底层逻辑 —— 这是避免后续 “越写越乱” 的关键。</p><h4>1.1 虚拟列表的 3 个核心问题</h4><p>不管是固定高度还是可变高度，所有虚拟列表都要解决 3 个核心问题，Demo 也不例外：</p><ol><li><strong>范围确定</strong>：滚动时，如何精准计算 “哪些列表项在可视区域内”？<br/>比如可视区域高度 500px，列表项高度 100px，就需要知道当前该显示第 3-7 项。</li><li><strong>平滑滚动</strong>：只渲染部分项，如何让用户感觉是在滚动 “完整列表”？<br/>不能让用户看到 “跳着走” 的卡顿感，需要通过定位模拟完整滚动效果。</li><li><strong>高度适配</strong>：列表项高度不固定时（如含图片、富文本），如何避免定位错位？<br/>这是最复杂的问题 —— Demo 正是针对这个场景设计的。</li></ol><h4>1.2 虚拟列表的 2 种核心分类</h4><p>根据列表项高度是否固定，虚拟列表可分为两类，适用场景天差地别：</p><table><thead><tr><th>类型</th><th>核心特点</th><th>实现难度</th><th>适用场景</th></tr></thead><tbody><tr><td>固定高度虚拟列表</td><td>所有项高度一致，可视范围可通过公式直接计算</td><td>低</td><td>表格数据、固定卡片（如商品列表）</td></tr><tr><td>可变高度虚拟列表</td><td>项高度动态变化，需预估 + 校准真实高度</td><td>高</td><td>评论列表、富文本内容、含图片列表</td></tr></tbody></table><p>Demo 属于 “可变高度虚拟列表”—— 这也是实际业务中最常用、最能体现技术深度的类型。接下来，我们就以 Demo 为蓝本，拆解它的实现逻辑。</p><h3>二、原理拆解：可变高度虚拟列表的 5 步实现（基于Demo）</h3><p>Demo 把可变高度虚拟列表的实现拆解成了 5 个环环相扣的步骤，每个步骤都对应解决一个核心问题。我们一步步来看：</p><h4>2.1 步骤 1：初始化配置与核心数据定义</h4><p>一切从<code>VariableHeightVirtualList</code>类的构造函数开始 —— 这里定义了整个虚拟列表的 “骨架”，Demo 在这一步做了很灵活的配置化设计：</p><pre><code class="javascript">
constructor(options) {
  // 1. 外部可配置参数（灵活适配不同业务）
  this.container = options.container; // 虚拟列表容器（可视区域DOM）
  this.data = options.data; // 完整列表数据（万级/十万级）
  this.estimateHeight = options.estimateHeight || 80; // 预估高度（默认80px）
  this.buffer = options.buffer || 2; // 缓冲项数量（避免滚动空白）
  this.maxCacheSize = options.maxCacheSize || 100; // 最大DOM缓存数（防内存溢出）

  // 2. 高度相关核心数据（解决可变高度的关键）
  this.itemHeights = new Array(this.data.length).fill(this.estimateHeight); // 存储真实高度
  this.prefixHeights = [0]; // 高度前缀和：prefixHeights[i] = 前i项总高度
  this.containerHeight = this.container.clientHeight; // 可视区域高度
  this.scrollTop = 0; // 当前滚动位置（px）

  // 3. 可视区域范围数据
  this.currentStartIndex = 0; // 可视区域起始项索引
  this.currentEndIndex = 0; // 可视区域结束项索引

  // 4. DOM缓存（性能优化：复用已渲染DOM，减少重排）
  this.cacheElements = []; // 缓存DOM元素的数组
  this.cacheElementsRecord = []; // 记录缓存的索引，控制缓存大小
}</code></pre><p>这一步有 3 个 “灵魂数据”，直接决定了后续能否处理可变高度：</p><ul><li><strong><code>estimateHeight</code></strong> <strong>（预估高度）</strong>：初始化时不知道真实高度，先假设一个值（如 80px），用于计算初始的可视范围和列表总高度。</li><li><strong><code>itemHeights</code></strong> <strong>（真实高度数组）</strong>：长度和列表数据一致，初始化时用预估高度填充，后续会通过 DOM 实际高度校准。</li><li><strong><code>prefixHeights</code></strong> <strong>（高度前缀和）</strong>：比如<code>prefixHeights[3]</code> = 前 3 项总高度，通过它能快速定位滚动位置对应的列表项（后面会详细说）。</li></ul><h4>2.2 步骤 2：计算高度前缀和（快速定位的核心）</h4><p>前缀和数组<code>prefixHeights</code>是虚拟列表的 “导航地图”—— 没有它，就无法快速找到滚动位置对应的列表项。Demo 里用<code>calcPrefixHeights</code>方法实现：</p><pre><code class="javascript">
// 计算前缀和：prefixHeights[i+1] = prefixHeights[i] + itemHeights[i]
calcPrefixHeights() {
  for (let i = 0; i &lt; this.data.length; i++) {
    this.prefixHeights[i + 1] = this.prefixHeights[i] + this.itemHeights[i];
  }
  // 更新列表总高度（用于占位，让滚动条长度正确）
  this.updatePlaceholderHeight();
}

// 更新占位容器高度（模拟完整列表高度）
updatePlaceholderHeight() {
  const totalHeight = this.prefixHeights[this.data.length];
  this.placeholder.style.height = `${totalHeight}px`;
}</code></pre><p>举个具体例子理解：<br/>如果有 3 个列表项，真实高度分别是 80px、120px、100px，那么：</p><ul><li><code>prefixHeights = [0, 80, 200, 300]</code></li><li>第 2 项（索引 1）的顶部位置 = <code>prefixHeights[1] = 80px</code></li><li>第 2 项的底部位置 = <code>prefixHeights[2] = 200px</code></li><li>列表总高度 = <code>prefixHeights[3] = 300px</code></li></ul><p>有了这个数组，后续不管滚动到哪个位置，都能快速找到对应的列表项。</p><h4>2.3 步骤 3：确定可视区域范围（滚动时的 “导航”）</h4><p>当用户滚动列表时，第一步要做的就是 “确定当前该显示哪些项”—— 这需要两个关键方法：<code>findStartIndex</code>（找起始项）和<code>findEndIndex</code>（找结束项）。</p><h5>2.3.1 用二分查找找起始项（性能优化）</h5><p>起始项是 “当前滚动位置对应的第一个可见项”。如果直接遍历前缀和数组，十万级数据会很慢，Demo 用了<strong>二分查找</strong>，把时间复杂度从 O (n) 降到 O (log n)：</p><pre><code class="javascript">
// 二分查找：找到scrollTop对应的起始项索引
findStartIndex() {
  const scrollTop = this.scrollTop;
  let low = 0, high = this.prefixHeights.length - 1;
  
  while (low &lt;= high) {
    const mid = Math.floor((low + high) / 2);
    // 如果mid项的总高度 &lt;= 滚动位置，说明起始项在mid右边
    if (this.prefixHeights[mid] &lt;= scrollTop) {
      low = mid + 1;
    } else {
      // 否则在mid左边
      high = mid - 1;
    }
  }
  // low-1就是第一个顶部位置&lt;=scrollTop的项（起始项）
  return Math.max(0, low - 1);
}</code></pre><p>还是用前面的例子：如果滚动位置<code>scrollTop = 150px</code>，二分查找会发现：</p><ul><li><code>prefixHeights[1] = 80px ≤ 150px</code></li><li><code>prefixHeights[2] = 200px ＞ 150px</code><br/>所以起始项索引是<code>1</code>（第 2 项）—— 精准且高效。</li></ul><h5>2.3.2 计算结束项（加缓冲防空白）</h5><p>结束项是 “可视区域最后一个可见项”，Demo 还加了<code>buffer</code>（缓冲项）—— 这是避免滚动空白的关键：</p><pre><code class="javascript">
// 计算结束项：从起始项开始，找到超过滚动底部的项
findEndIndex(startIndex) {
  const scrollBottom = this.scrollTop + this.containerHeight; // 可视区域底部位置
  let endIndex = startIndex;
  
  // 找到第一个底部位置&gt;scrollBottom的项
  while (endIndex &lt; this.data.length &amp;&amp; this.prefixHeights[endIndex + 1] &lt;= scrollBottom) {
    endIndex++;
  }
  
  // 加缓冲项（比如buffer=2，就多渲染前后2项）
  endIndex = Math.min(this.data.length, endIndex + this.buffer);
  return endIndex;
}</code></pre><p>比如<code>buffer=2</code>，即使用户快速滚动，也会提前渲染 2 个 “备用项”，不会因为渲染不及时出现空白 —— 这是很多新手实现虚拟列表时容易忽略的优化点。</p><h4>2.4 步骤 4：渲染可视区域项 + 滚动定位</h4><p>确定了起始和结束项，就可以渲染这部分列表项了。Demo 在这里做了两个关键优化：DOM 缓存复用和<code>transform</code>定位。</p><pre><code class="javascript">
// 更新可视区域渲染内容
updateVisibleItems() {
  // 1. 先算当前可视范围
  this.currentStartIndex = this.findStartIndex();
  this.currentEndIndex = this.findEndIndex(this.currentStartIndex);
  // 2. 取可视区域的数据
  const visibleData = this.data.slice(this.currentStartIndex, this.currentEndIndex);

  // 3. 渲染可视项（复用缓存DOM，减少重排）
  this.content.innerHTML = ''; // 清空内容区（但缓存还在）
  visibleData.forEach((item, idx) =&gt; {
    const realIndex = this.currentStartIndex + idx; // 真实数据索引
    
    // 优化1：复用已缓存的DOM，不用重新创建
    if (this.cacheElements[realIndex]) {
      this.content.appendChild(this.cacheElements[realIndex]);
      return;
    }

    // 优化2：未缓存则创建新DOM，并加入缓存
    const element = document.createElement('div');
    element.className = 'virtual-list-item';
    element.dataset.index = realIndex; // 记录真实索引，后续校准高度用
    element.innerHTML = `
      &lt;div&gt;索引: ${realIndex} | 高度: ${this.itemHeights[realIndex]}px&lt;/div&gt;
      &lt;div&gt;${item.content}&lt;/div&gt;
    `;
    
    // 加入缓存，控制缓存大小（防内存溢出）
    this.cacheElements[realIndex] = element;
    this.cacheElementsRecord.push(realIndex);
    if (this.cacheElementsRecord.length &gt; this.maxCacheSize) {
      // 缓存超限时，删除最早的缓存项
      const oldIndex = this.cacheElementsRecord.shift();
      delete this.cacheElements[oldIndex];
    }

    this.content.appendChild(element);
  });

  // 4. 定位内容区：用transform模拟滚动（比top性能好，不触发重排）
  const offsetTop = this.prefixHeights[this.currentStartIndex];
  this.content.style.transform = `translateY(${offsetTop}px)`;

  // 5. 关键步骤：校准真实高度（解决可变高度问题）
  this.calibrateHeights();
}</code></pre><p>这里有两个必须注意的细节：</p><ul><li><strong>DOM 缓存复用</strong>：避免滚动时反复创建 / 销毁 DOM—— 这是性能优化的核心，Demo 还通过<code>maxCacheSize</code>控制缓存大小，防止内存溢出。</li><li><strong><code>transform</code></strong> <strong>定位</strong>：用<code>translateY</code>代替<code>top</code>定位，因为<code>transform</code>属于 “合成层操作”，不会触发浏览器重排，滚动更流畅。</li></ul><h4>2.5 步骤 5：校准真实高度（可变高度的 “灵魂”）</h4><p>前面用了预估高度，但实际列表项高度可能和预估不同（比如图片加载后高度增加）。Demo 用<code>calibrateHeights</code>方法校准真实高度，这是解决可变高度的关键：</p><pre><code class="javascript">
// 校准真实高度：用DOM实际高度更新数据
calibrateHeights() {
  const items = this.content.querySelectorAll('.virtual-list-item');
  let isHeightChanged = false; // 标记高度是否有变化

  items.forEach(item =&gt; {
    const realIndex = parseInt(item.dataset.index);
    const realHeight = item.offsetHeight; // 获取DOM真实高度

    // 如果真实高度和记录的不一致，更新数据
    if (this.itemHeights[realIndex] !== realHeight) {
      this.itemHeights[realIndex] = realHeight;
      isHeightChanged = true;
      // 实时更新项内的高度显示（调试友好）
      item.querySelector('div:first-child').textContent = 
        `索引: ${realIndex} | 高度: ${realHeight}px (已校准)`;
    }
  });

  // 高度变化后，重新计算前缀和和列表总高度
  if (isHeightChanged) {
    this.calcPrefixHeights();
    this.updateVisibleItems(); // 重新渲染，确保定位准确
  }
}</code></pre><p>比如预估高度 80px，实际 DOM 高度 120px—— 校准后，<code>itemHeights</code>数组会更新为 120px，前缀和也会重新计算，后续滚动定位就不会错位了。Demo 还在项内实时显示校准后的高度，非常方便调试。</p><h3>三、实战亮点：Demo 做对了这些事</h3><p>所提供的 “可变高度虚拟列表（可配置版）”Demo，不只是实现了核心功能，还加了很多贴近业务的设计，这些细节让它能直接落地到项目中：</p><h4>3.1 全配置化设计（灵活适配业务）</h4><p>你把预估高度、缓冲项数量、最大缓存数等关键参数都做成了外部可配置：</p><pre><code class="javascript">
// 初始化时可自定义所有核心参数
const virtualList = new VariableHeightVirtualList({
  container: document.querySelector('.virtual-list-container'),
  data: initialData, // 业务数据
  estimateHeight: 100, // 按业务调整预估高度
  buffer: 3, // 缓冲项3个，更流畅
  maxCacheSize: 150 // 缓存150个DOM，平衡性能和内存
});

// 还支持运行时更新配置
virtualList.updateConfig({
  estimateHeight: 120,
  buffer: 2
});</code></pre><p>这种设计让虚拟列表能适配不同业务场景 —— 比如商品列表用 80px 预估高度，评论列表用 120px，不用修改核心代码。</p><h4>3.2 调试面板（开发友好）</h4><p>Demo 右侧加了调试面板，实时显示总项数、已渲染项数、可视范围、滚动位置等核心数据：</p><ul><li>开发时能直观看到 “可视范围是否正确”“渲染项数是否合理”；</li><li>测试时能快速定位问题 —— 比如滚动时起始索引是否跳变，高度校准是否生效。</li></ul><p>这是很多开源虚拟列表库都没有的细节，对开发和调试太友好了。</p><h4>3.3 图片加载后重新校准（解决实际痛点）</h4><p>列表项含图片时，图片加载后高度会变化 —— Demo 考虑到了这个场景，加了图片加载监听：</p><pre><code class="javascript">
// 监听图片加载，重新校准高度
listenImageLoad() {
  this.content.addEventListener('load', (e) =&gt; {
    if (e.target.tagName === 'IMG') {
      this.calibrateHeights(); // 图片加载后重新校准
    }
  }, true);
}</code></pre><p>这一个小细节，就避免了 “图片加载后列表错位” 的常见问题 —— 很多新手实现的虚拟列表，就是因为没处理这个场景，导致上线后出现 bug。</p><h3>四、避坑指南：虚拟列表落地的 6 个高频问题</h3><p>结合Demo 和实际业务经验，总结了 6 个最容易踩的坑，每个坑都有对应的解决方案：</p><h4>4.1 坑点 1：滚动时出现空白区域</h4><p><strong>原因</strong>：缓冲项数量不足，或预估高度与真实高度偏差太大。<br/><strong>解决方案</strong>（Demo 已实现）：</p><ul><li>缓冲项<code>buffer</code>设为 2-3（根据滚动速度调整）；</li><li>预估高度尽量贴近真实高度（比如按业务数据统计平均高度）；</li><li>图片加载后重新校准高度。</li></ul><h4>4.2 坑点 2：滚动定位错位（项的位置不对）</h4><p><strong>原因</strong>：没及时校准真实高度，或前缀和计算错误。<br/><strong>解决方案</strong>：</p><ul><li>渲染完成后必须调用<code>calibrateHeights</code>；</li><li>检查前缀和计算逻辑：确保<code>prefixHeights[i+1] = prefixHeights[i] + itemHeights[i]</code>；</li><li>避免在滚动事件中做耗时操作，导致校准延迟。</li></ul><h4>4.3 坑点 3：DOM 缓存导致内存溢出</h4><p><strong>原因</strong>：缓存的 DOM 数量太多，尤其是十万级数据时。<br/><strong>解决方案</strong>（Demo 已实现）：</p><ul><li>用<code>maxCacheSize</code>控制缓存大小（建议 100-200，根据项复杂度调整）；</li><li>缓存超限时，删除最早的缓存项（<code>cacheElementsRecord</code>记录索引，先进先出）。</li></ul><h4>4.4 坑点 4：滚动卡顿（不流畅）</h4><p><strong>原因</strong>：滚动事件触发太频繁，或渲染逻辑太重。<br/><strong>解决方案</strong>：</p><ul><li>给滚动事件加 10-20ms 防抖（Demo 用了 10ms）；</li><li>用<code>transform</code>代替<code>top</code>定位（避免重排）；</li><li>减少列表项内的 DOM 嵌套（越简单越好）。</li></ul><h4>4.5 坑点 5：初始化时滚动条长度不对</h4><p><strong>原因</strong>：用预估高度计算的列表总高度，和真实总高度偏差太大。<br/><strong>解决方案</strong>（Demo 已实现）：</p><ul><li>用<code>placeholder</code>（占位容器）显示列表总高度；</li><li>高度校准后，及时更新<code>placeholder</code>的高度（<code>updatePlaceholderHeight</code>）。</li></ul><h4>4.6 坑点 6：列表项点击事件错位</h4><p><strong>原因</strong>：DOM 复用后，事件绑定的索引没更新。<br/><strong>解决方案</strong>：</p><ul><li>给每个列表项加<code>data-index</code>记录真实索引（Demo 已做）；</li><li>点击事件中通过<code>e.target.closest('.virtual-list-item').dataset.index</code>获取真实索引，不要依赖循环变量。</li></ul><h3>五、落地建议：从 Demo 到生产环境</h3><p>Demo 已经实现了核心功能，要落地到项目中，还需要补充这些细节：</p><h4>5.1 兼容性处理</h4><ul><li><strong>低版本浏览器</strong>：<code>offsetHeight</code>、<code>transform</code>在 IE11 中可用，但<code>forEach</code>、<code>slice</code>等方法需要 polyfill；</li><li><strong>移动端</strong>：监听<code>touchmove</code>事件（配合<code>touchend</code>），避免滚动延迟。</li></ul><h4>5.2 异常场景处理</h4><ul><li><strong>数据为空</strong>：显示 “暂无数据” 占位，不要渲染空列表；</li><li><strong>数据加载中</strong>：加加载动画，避免用户以为 “列表没出来”；</li><li><strong>数据更新</strong>：数据变化后，重置<code>itemHeights</code>和<code>prefixHeights</code>，重新初始化。</li></ul><h4>5.3 性能测试</h4><p>在不同场景下测试性能，确保满足业务需求：</p><ul><li><strong>数据量测试</strong>：分别测试 1 万、5 万、10 万条数据的滚动流畅度；</li><li><strong>设备测试</strong>：在低端安卓机、iPhone 旧机型上测试，避免性能瓶颈；</li><li><strong>内存测试</strong>：滚动 10 分钟后，通过 Chrome DevTools 查看内存占用，确保无泄漏。</li></ul><h3>六、总结：虚拟列表不是银弹，但能解决大问题</h3><p>虚拟列表的核心价值是 “解决长列表的性能问题”，但它不是万能的：</p><ul><li><strong>适合场景</strong>：数据量≥1000 条、列表项高度不固定、对滚动流畅度要求高；</li><li><strong>不适合场景</strong>：数据量≤500 条（直接渲染更简单，没必要用虚拟列表）。</li></ul><p>提供的“可变高度虚拟列表（可配置版）”Demo，已经覆盖了虚拟列表的核心难点：可变高度校准、DOM 缓存复用、缓冲防空白，再补充一些兼容性和异常处理，就能直接落地到生产环境。</p><p>最后记住：虚拟列表的本质是 “取舍”—— 用少量计算成本，换取 DOM 数量的大幅减少。理解了这个核心，不管遇到什么业务场景，都能灵活调整实现方案。总而言之，一键<strong>点赞、评论、喜欢</strong>加<strong>收藏</strong>吧！这对我很重要！</p>]]></description></item><item>    <title><![CDATA[艾体宝产品 | Redis 8.4 GA]]></title>    <link>https://segmentfault.com/a/1190000047440579</link>    <guid>https://segmentfault.com/a/1190000047440579</guid>    <pubDate>2025-12-01 12:02:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Redis 8.4 在性能与开发体验上全面升级，并引入全新的混合搜索能力，让构建 AI 应用的速度和便捷性再上一个台阶。其推出的混合搜索（hybrid search）功能，将全文搜索与向量搜索融为一体，实现更灵活、更智能的查询，同时在性能与内存利用率上带来显著提升。通过对 Redis Streams 逻辑的优化和一系列新增原子操作，Redis 在大规模场景下的运维也变得更加简单可靠。</p><h2>混合搜索重磅登场</h2><p>从检索增强生成（RAG）系统到自主助理，智能体的性能取决于上下文质量。真正的挑战不在于获取数据，而在于理解数据——识别哪些信息是当前相关的、哪些存储于记忆、哪些可为决策提供推理依据。智能体需以语义方式搜索“记忆”，而非依赖字面召回，并将符号推理与语义相似度结合。</p><p>Redis 一直是实时决策与上下文检索的核心，开发者长期利用混合策略预先过滤候选集，以高效缩小向量搜索空间。</p><p>过去，全文与向量相似度的融合方法复杂繁琐，需多步操作，并在精度与性能间权衡，导致延迟上升、检索体验割裂。Redis 8.4 通过全新的 <code>FT.HYBRID</code> 命令解决了这些问题——这一统一的引擎内混合检索 API 通过评分融合（倒数排序融合或线性组合）在一次查询中合并全文与向量相似度结果，生成单一排序列表，同时捕捉语义和字面匹配。这意味着无需在精度与间取舍，也无需外部评分合并。<code>FT.HYBRID</code> 可直接在查询中表达上下文意图，便捷优先检索近期记忆，利用 GEO 和 GEOSHAPE 限定地理范围，并融合语义、模糊与精确匹配，为新一代智能体构建一致、高速且具备语义感知的检索管道。</p><h2>史上最快、资源效率最高的 Redis</h2><p>Redis 8.4 继续践行 Redis 对持续性能优化的承诺。下图展示了 Redis 在典型缓存工作负载下，吞吐量（每秒操作数）在各版本间的稳步增长趋势。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440581" alt="" title=""/></p><p>8.4 版本延续这一趋势，相比 Redis 8.2，缓存场景（90% <code>GET</code>、10% <code>SET</code>）的吞吐量提升超过 30%。</p><p>通过在分布式查询中引入多线程 I/O 处理，Redis 查询引擎在高负载环境下实现了显著的性能提升。在从多个分片检索大规模结果时，并发 I/O 线程可并行处理分片响应，而非依次执行。这有效消除了单线程瓶颈带来的 CPU 饱和与吞吐受限问题，并缓解了大型集群中的长时间排队现象，从而使系统能够充分发挥各分片的计算潜力，降低资源竞争，提升查询扇出与结果聚合的流畅性。</p><p>基准测试表明，这些改进为 <code>FT.SEARCH</code> 和 <code>FT.AGGREGATE</code> 操作带来了端到端的显著提升，新增的 <code>FT.HYBRID</code> 自然也受益于此。在大规模搜索工作负载下，并行 I/O 处理使吞吐量提升达 4.7 倍，同时同比例降低查询延迟。涉及额外后处理的聚合操作同样获益，吞吐量提升约 1.4 倍，并在并发负载下缩短响应时间。在这两种场景下，多线程 I/O 为工作线程腾出了更多空间来执行实际的搜索或聚合逻辑，确保集群资源得到更均衡的利用，并在搜索与向量工作负载中实现更快响应。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440582" alt="" title="" loading="lazy"/></p><p>Redis 还优化了查询执行的内存分配管理，让 Redis 查询引擎更加健壮。开发者现在可以自定义内存溢出（OOM）时的行为。通过新增配置项 <code>search-on-oom</code>，可全面管理内存消耗方式及引擎应对策略。</p><p>Redis 继续投入降低 JSON 数据类型的内存占用。Redis 8.2 通过内联数值实现了大幅缩减，Redis 8.4 则进一步内联短字符串（最多 7 字节）。例如，包含 500 个键值元素的 JSON 数组，若所有键值均为短字符串，内存占用将减少 37%：</p><table><thead><tr><th>键值类型</th><th>Redis 8.2 内存占用</th><th>Redis 8.4 内存占用</th><th>优化效果</th></tr></thead><tbody><tr><td>短字符串（≤7 字节）</td><td>64,512 字节</td><td>40,624 字节</td><td>减少 37%</td></tr></tbody></table><p>更重要的是，Redis 如今能够更高效地存储同质 JSON 数值数组。在 8.4 版本之前，JSON 数组的每个元素都需分别存储类型和值。现在，当数组为同质（即所有元素数据类型一致）时，仅需为整个数组存储一次元素类型。对于数值数组，Redis 会自动选择最高效的元素类型（I8、U8、I16、U16、I32、U32、I64、U64、BF16、FP16、FP32 或 FP64），保证所有值均在范围内且无精度损失。例如，对于包含 100 万个数值的 JSON 数组，内存占用可减少 50% 至 92%。</p><table><thead><tr><th>数组元素类型</th><th>Redis 8.2 内存占用</th><th>Redis 8.4 内存占用</th><th>优化效果</th></tr></thead><tbody><tr><td>有符号整数[-2⁷ … 2⁷)或无符号整数[0 … 2⁸)</td><td>8.42 MB</td><td>1.14 MB</td><td>减少 87%</td></tr><tr><td>有符号整数[-2¹⁵ … 2¹⁵)或无符号整数[0 … 2¹⁶)</td><td>8.43 MB</td><td>2.19 MB</td><td>减少 74%</td></tr><tr><td>有符号整数[-2³¹ … 2³¹)或无符号整数[0 … 2³²)</td><td>8.46 MB</td><td>4.26 MB</td><td>减少 50%</td></tr><tr><td>有符号整数[-2⁶³ … 2⁶³)或无符号整数[0 … 2⁶⁴)</td><td>24.46 MB</td><td>8.43 MB</td><td>减少 66%</td></tr><tr><td>BF16 可表示的浮点值</td><td>24.43 MB</td><td>2.16 MB</td><td>减少 92%</td></tr><tr><td>FP16 可表示的浮点值</td><td>24.43 MB</td><td>2.16 MB</td><td>减少 92%</td></tr><tr><td>FP32 可表示的浮点值</td><td>24.46 MB</td><td>4.26 MB</td><td>减少 83%</td></tr><tr><td>FP64 可表示的浮点值</td><td>24.46 MB</td><td>8.43 MB</td><td>减少 66%</td></tr></tbody></table><h2>用一条命令消费空闲待处理消息与新增消息</h2><p>在 Redis Streams 中，待处理消息是指已投递至消费者组内的消费者但尚未确认的消息，这些消息会一直保留，直到被确认或删除。若消息长时间处于待处理状态，通常意味着出现异常——可能是消费客户端在处理或发送确认前崩溃，可能是消息本身存在问题（如引发死锁或处理耗时过长），也可能是消费客户端与 Redis 之间的通信发生故障。</p><p>在正常流程中，应用期望每条消息在消费后的一定时间内完成确认。若未确认，则被视为空闲待处理消息，可尝试重新投递。鉴于流式消息处理易出错，需要简洁且可靠的恢复机制。</p><p>因此，消费者既应（1）监控待处理消息列表、认领并处理空闲消息，也应（2）处理新流入的消息。</p><p>在 Redis 8.4 之前，客户端必须实现复杂逻辑才能同时消费这两类消息。</p><p>Redis 8.4 为 <code>XREADGROUP</code> 命令引入了简洁而强大的扩展，允许客户端用单条命令消费空闲待处理消息与新增消息。</p><h2>字符串键新增原子 compare-and-set 与 compare-and-delete 命令</h2><p>Compare-and-set（又称 check-and-set、compare-and-swap）和 compare-and-delete 是实现单键乐观并发控制的原子方法。使用 compare-and-set 时，客户端可以：</p><ol><li>从服务端获取值，在应用侧保存为"旧值"</li><li>在本地修改该值副本</li><li>Compare-and-set：仅在服务端值未被其他客户端修改时（即服务端值仍等于旧值），将本地变更应用到服务端</li></ol><p>假设存在一个 <code>Product:Description</code> 字符串键，用于让用户编辑产品描述（如通过网页表单）。由于每个产品描述的修改频率较低，可采用乐观并发控制，仅在该值自获取后未被其他客户端更改时才更新。</p><p>在旧版 Redis 中，若需原子化执行此过程的第三步，必须编写自定义 Lua 脚本。自 Redis 8.4 起，客户端可通过单条命令（在 <code>SET</code> 中使用 <code>IFEQ</code>、<code>IFNE</code>、<code>IFDEQ</code> 或 <code>IFDNE</code> 选项）在字符串键值未发生变化时直接更新，更加简洁高效。类似地，引入了单条命令 <code>XDELEX</code> 实现比较并删除，即仅在字符串键值未变时原子删除。</p><h2>原子设置多个字符串键并更新过期时间的新命令</h2><p>批量设置多个键并统一设置过期时间是常见需求，通常还要求仅在所有指定键已存在或均不存在时才执行设置操作。</p><p>在 Redis 8.4 之前，这一常见需求需要自定义 Lua 脚本支持。</p><p>Redis 8.4 引入了更简单快速的方案。新的单条命令 <code>MSETEX</code> 可条件性地批量设置或更新多个字符串键的值与过期时间。</p><h2>原子槽迁移简化集群运维</h2><p>Redis 集群是一种为实现高可用、可扩展性与容错能力而设计的分布式架构。它将多个 Redis 节点连接起来，使数据与流量得以分布到各个节点。Redis 集群通过 16,384 个哈希槽自动拆分并分发数据，每个节点负责持有部分哈希槽，从而支持远超单机规模的数据集。</p><p>在两种主要场景下需要改变槽与节点的映射关系，即必须在节点间迁移键：</p><ul><li>​<strong>集群重平衡</strong>​：添加新节点后，集群需将部分哈希槽（及其中键）迁移至新节点，使数据分布更均衡。移除节点前，同样需将其槽重新分配给其他节点。</li><li>​<strong>处理过载节点</strong>​：由于键内容与访问模式，特定槽或节点可能需要更多资源（内存、算力、每秒操作数或网络吞吐量）。当节点过载时，可将其槽重新分配以实现更好的性能与资源利用率，这需要从过载节点向负载较轻节点迁移槽。</li></ul><p>此前的槽迁移是非原子的。迁移过程中，键逐个移动到目标节点再从源节点删除，这会带来诸多潜在问题：</p><ul><li>​<strong>重定向与客户端复杂度</strong>​：迁移期间，部分键可能已移动而其他尚未移动。若客户端访问已迁移的键，会收到 <code>-ASK</code> 回复，必须转向目标节点重试，增加复杂度与网络延迟，还会破坏简单的管道操作。</li><li>​<strong>多键操作在 Resharding 时不可靠​</strong>​：在 <code>MGET key1 key2</code> 等多键命令中，若部分键已迁移，客户端会收到 <code>TRYAGAIN</code> 回复，必须等待整个槽迁移完成才能执行命令。</li><li>​<strong>迁移失败导致异常状态</strong>​：部分键已移动，但因目标节点内存不足等原因未能删除剩余键时，Redis 会陷入需手动修复的异常状态，常导致数据丢失。</li><li>​<strong>复制问题</strong>​：副本不一定知道槽正在迁移，可能将键视为普通删除而非发出 <code>-ASK</code> 重定向。</li><li>​<strong>性能</strong>​：逐键迁移速度慢。传统方法中键实际上逐个移动，因额外查找和网络往返而效率低下。</li></ul><p>Redis 8.4 引入原子槽迁移（ASM）解决所有这些运维问题。ASM 类似于槽级别的全量同步复制，它会将完整槽内容复制到目标节点，加上实时增量流（类似复制积压）。仅在复制完成后，Redis 才执行单次原子所有权交接。复制过程中客户端仍与源节点通信，不会遇到上述迁移中期的任何问题，从而极大提升了大规模运维 Redis 开源版的管理体验。</p><h2>立即开始使用 Redis 8.4</h2><p>所有上述增强功能现已在 Redis 8.4 开源版中正式发布。</p><p>关注并私信“艾体宝IT”，立即下载 Redis 8.4 开始使用！</p>]]></description></item><item>    <title><![CDATA[智能工艺革新：制造业数字化转型的核心驱动]]></title>    <link>https://segmentfault.com/a/1190000047440608</link>    <guid>https://segmentfault.com/a/1190000047440608</guid>    <pubDate>2025-12-01 12:02:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当前全球制造业竞争日益激烈的背景下，企业面临着从研发到生产的全链路效率提升和质量保障的双重挑战。传统工艺流程往往依赖人工经验，导致设计变更响应滞后、图纸校核效率低下、工艺文件标准化不足等问题，这些问题不仅增加了企业的运营成本，还限制了其快速响应市场需求的能力。为破解这一困局，智能工艺革新成为制造业数字化转型的关键路径，它通过人工智能技术与工业知识的深度融合，实现了从设计到生产的全流程自动化与智能化。<br/>智能工艺的核心在于其对研发流程的深度重塑。借助“数字化大研发体系”，企业能够构建一个覆盖需求分析、设计验证、工艺规划及生产交付的全链路协同平台。以Geega捷做设计研发协同平台为例，该系统通过多维度的数据整合与智能分析，将市场需求快速转化为设计参数，减少了人为干预导致的延迟与错误。在研发过程中，Geega捷做设计研发协同平台统一管理多种BOM视图，并借助内置的变更影响分析模块，实时评估设计调整对后续工艺和生产环节的影响，从而确保质量问题在早期被拦截，避免了后期返工带来的资源浪费。<br/>工艺环节的智能化升级同样不可忽视。在传统制造模式下，工艺规划和校核往往依赖工程师的重复性劳动，不仅效率低下，还难以保证工艺参数的一致性。而智能工艺专家系统（如Geega工艺引擎）通过引入多模态大模型与强化学习算法，实现了工艺参数的自动优化与标准化。例如，AI可制造性校核模块能够自动完成定位、测量与标准校核，将图纸校核时间缩短50%以上，并提升审查效率至80%。此外，AI工艺路线生成和作业工时自动生成等功能，显著减少了工程师在工序编排和工时测算上的时间投入，使其能够专注于更高价值的创新任务。<br/>智能工艺带来的价值不仅体现在效率提升上，还表现在对生产过程的精准控制与优化。以汽车制造为例，某企业通过智能工艺引擎实现了焊装车间的实时工艺参数监控与自优化，使焊点一次合格率提升至99.5%，同时将缺陷处理时间压缩至原来的1/3。在新能源电池行业，智能工艺的应用同样成果显著。某电池制造企业通过引入AI驱动的工艺规划系统，成功将产品上市周期缩短30%，并显著提升了生产质量的一致性。<br/>在这些成功案例中，广域铭岛的工业AI体系发挥了重要作用。其Geega工业AI应用平台与工业智造超级智能体矩阵，通过高效的数据标准化治理、闭环知识封装与还原能力，以及模块化智能体开发，帮助企业实现了从单点优化到全链路协同的智能化升级。例如，在极氪汽车杭州湾工厂，广域铭岛的涂装质量预测模型将缺陷定位效率提升80%，预判准确率达到97.5%，大幅降低了返修工位。而在百矿集团电解铝基地，智能工艺优化实现了年节电6000万千瓦时，年减碳量达10.7万吨，不仅提升了生产效率，还为企业的绿色转型提供了有力支持。<br/>展望未来，随着人工智能技术的不断演进，智能工艺将在制造业中发挥更大的作用。企业应从自身需求出发，选择适合的数字化转型路径，将AI技术嵌入研发、生产与协同的各个环节。广域铭岛等工业数字化服务商通过其成熟的平台与解决方案，为制造企业提供了从数据治理到智能决策的全链路支持，助力企业在激烈的市场竞争中脱颖而出。通过智能工艺的革新，制造业将迈向更加高效、智能与可持续的未来。</p>]]></description></item><item>    <title><![CDATA[如何通过智能工艺提升制造业生产效率？ 月]]></title>    <link>https://segmentfault.com/a/1190000047440616</link>    <guid>https://segmentfault.com/a/1190000047440616</guid>    <pubDate>2025-12-01 12:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>工业智能工艺如同人体的神经系统，在传统制造体系中建立了生命的协调与平衡。这是一套将人工智能、物联网、数字孪生、大数据分析等尖端技术深度整合，形成闭环、自适应、持续进化生产机制的综合解决方案。广域铭岛公司在这一领域的创新研究提出了独特的"工业智造超级智能体"架构，为制造业的数字化转型铺设了充满活力的技术长廊。<br/>在这一态势下，工业智能工艺已经从传统的单点监控转变为多维度的数据协同系统。广域铭岛的先进案例展示出工业智能工艺的全面进化路径：从重庆市的旗舰汽车工厂到浙江省的示范电解铝基地，从郑州市的电芯组装产线到华中地区的低碳铸造单元，先进的智能体架构使传统制造机器重新获得生命，建立起前所未有的工艺自感知、自优化和自决策能力。<br/>尤为引人注目的是，工业智能工艺的多智能体架构实现了神经元单元的动态协同。区域车间面临工艺波动时，边缘智能体实时监测工况，将预警信息同步至云端集群。质量算法团队立即启动因果推理模块，通过多维度数据分析在0.2秒内生成纠正策略。这种"感知-分析-执行"的秒级闭环响应机制，本质上是在物理制造流程上构建了数字神经系统。<br/>在实操层面，广域铭岛的创新体系将工业智能工艺提升到前所未有的高度。系统通过传感器网络采集生产全周期的热力参数、化学浓度、视觉质量等多个维度指标，在云端平台进行量子级的因果关联分析。调度智能体全天候执行动态排产任务，优化路径规划，完善质量控制与能源管理，年度供应链分析显示其能够使非计划停机率下降75%，能源浪费降低15%。<br/>新型工业智能工艺的价值已经在全球几十个制造场景中得到显现。以电解铝行业为例，通过整合广域铭岛的全方位解决方案，传统耗电大户实现了惊人的降耗成效：能效优化使吨铝耗电降低600度，产能提升30%，碳排放减少千吨级。这些数字背后，反映的是智能制造技术与工业文化深度融合的技术革命。<br/>制造业4.0的核心在于突破经验主义对工艺管理的制约。工业智能工艺则将这种约束转化为生产力源泉。广域铭岛正在为行业建立新一代的智能制造生态系统，它不只是简单的自动化解决方案整合者，而是真正意义上的"工艺赋能平台"。<br/>从中长期视角看，工业智能工艺将持续打破信息壁垒，构建从原材料追溯到成品交付的全生命周期洞察力。广域铭岛的技术架构预示出未来的可能：量子计算架构下的多智能体协同，将实现分子级别的工序优化；区块链技术则会赋予制造业完整、透明的碳足迹追溯能力。这种数字化变革的浪潮，正在将工业智能工艺重塑为每个制造单元的核心智能器官。</p>]]></description></item><item>    <title><![CDATA[使用 Spire.XLS for Pyt]]></title>    <link>https://segmentfault.com/a/1190000047439799</link>    <guid>https://segmentfault.com/a/1190000047439799</guid>    <pubDate>2025-12-01 11:05:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当今数据驱动的世界中，Python 已成为数据处理和分析的首选工具。而 Excel 文件作为最常见的数据存储格式之一，如何高效、准确地在 Python 中读取和处理 Excel 数据，成为了许多开发者和数据分析师面临的挑战。传统的 Python Excel 库在处理复杂 Excel 文件（如包含公式、样式、合并单元格等）时，有时会显得力不从心，甚至性能不佳。</p><p>本文将向您介绍一款功能强大、性能卓越的 Python 库—— <strong>Spire.XLS for Python</strong> 。它能够帮助您轻松驾驭各种 Excel 文件，实现高效的数据读取。通过本文，您将学习到 Spire.XLS for Python 的安装、基础用法以及深入的数据读取技巧，助您在数据处理的道路上更进一步。</p><h2>为什么选择 Spire.XLS for Python?</h2><p>Spire.XLS for Python 是一款专业的 Excel 处理库，专为 Python 开发者设计。它无需安装 Microsoft Office 即可独立运行，支持多种 Excel 文件格式（XLS、XLSX、XLSM、XLSB 等），并提供了丰富的 API，可以满足各种复杂的 Excel 处理需求。</p><h3>与其他常见的 Python Excel 库的优势</h3><ul><li><strong>功能全面</strong> ：不仅支持基本的数据读写，还能处理复杂的 Excel 元素，如公式、图表、图片、批注、条件格式、数据验证、宏等，并能完美保留这些元素的格式和属性。</li><li><strong>高性能</strong> ：针对大型文件处理进行了优化，读写速度快。</li><li><strong>格式兼容性</strong> ：能够处理各种版本的 Excel 文件，并确保数据和格式的准确性。</li><li><strong>易用性</strong> ：API 设计直观，学习曲线平缓，即使是初学者也能快速上手。</li></ul><p>在处理需要精确保留 Excel 格式和复杂元素，或者需要高性能读写场景时，Spire.XLS for Python 无疑是您的理想选择。</p><h2>Spire.XLS for Python 的安装与基础使用</h2><h3>安装 Spire.XLS for Python</h3><p>安装 Spire.XLS for Python 非常简单，只需使用 pip 命令即可：</p><pre><code class="bash">pip install Spire.XLS</code></pre><h3>创建一个简单的 Excel 文件 (准备工作)</h3><p>为了演示读取操作，我们首先创建一个包含一些基本数据的 Excel 文件。您可以手动创建一个名为 <code>Sample.xlsx</code> 的文件，或者使用以下 Python 代码生成：</p><pre><code class="python">from spire.xls import *
from spire.xls.common import *

# 创建一个工作簿
workbook = Workbook()
# 获取第一个工作表
sheet = workbook.Worksheets[0]

# 写入数据
sheet.Range["A1"].Value = "姓名"
sheet.Range["B1"].Value = "年龄"
sheet.Range["C1"].Value = "出生日期"
sheet.Range["D1"].Value = "分数"

sheet.Range["A2"].Value = "张三"
sheet.Range["B2"].Value = "25"
sheet.Range["C2"].Value = "1998-05-10"
sheet.Range["D2"].Value = "85.5"

sheet.Range["A3"].Value = "李四"
sheet.Range["B3"].Value = "30"
sheet.Range["C3"].Value = "1993-11-20"
sheet.Range["D3"].Value = "92"

# 自动调整列宽
sheet.AutoFitColumn(1)
sheet.AutoFitColumn(2)
sheet.AutoFitColumn(3)
sheet.AutoFitColumn(4)

# 保存文件
workbook.SaveToFile("Sample.xlsx", ExcelVersion.Version2016)
workbook.Dispose()
print("Sample.xlsx 文件已创建成功！")</code></pre><h3>读取 Excel 工作簿与工作表</h3><p>现在我们有了 <code>Sample.xlsx</code> 文件，接下来演示如何使用 Spire.XLS for Python 加载它并访问工作表：</p><pre><code class="python">from spire.xls import *
from spire.xls.common import *

# 创建一个工作簿对象
workbook = Workbook()

# 加载 Excel 文件
workbook.LoadFromFile("Sample.xlsx")

# 获取第一个工作表
sheet = workbook.Worksheets[0]
print(f"第一个工作表的名称是: {sheet.Name}")

# 释放资源
workbook.Dispose()</code></pre><h2>深入读取 Excel 数据</h2><h3>读取单元格数据</h3><p>Spire.XLS for Python 提供了多种方式来读取单元格数据，包括按索引和按名称：</p><pre><code class="python">from spire.xls.common import *

workbook = Workbook()
workbook.LoadFromFile("Sample.xlsx")
sheet = workbook.Worksheets[0]

# 按行、列索引读取单元格内容
cell_a1_value = sheet.Range[1, 1].Value
cell_b2_value = sheet.Range[2, 2].Value

print(f"A1 单元格的值: {cell_a1_value}")
print(f"B2 单元格的值: {cell_b2_value}")

workbook.Dispose()</code></pre><h3>遍历行和列</h3><p>高效遍历工作表中的所有行和列是数据处理的常用操作：</p><pre><code class="python"># 获取已使用范围的行数和列数
last_row = sheet.LastRow
last_column = sheet.LastColumn

# 遍历所有行和列
for row inrange(1, last_row + 1):
    row_data = []
for col inrange(1, last_column + 1):
        cell = sheet.Range[row, col]
        value = cell.Value
if cell.ValueType == CellValueType.IsDateTime:
            value = datetime.strptime(value, "%Y-%m-%d")
        row_data.append(value)
print(row_data)

# 示例：计算分数列的总和
total_score = 0
for row inrange(2, last_row + 1):
    score_cell = sheet.Range[row, 4]
if score_cell.ValueType == CellValueType.IsNumber:
        total_score += float(score_cell.Value)
print(f"\n总分数: {total_score}")

workbook.Dispose()</code></pre><h3>读取特定区域的数据</h3><p>有时我们只需要读取 Excel 文件中的某个特定区域的数据：</p><pre><code class="python">from spire.xls import *
from spire.xls.common import *

workbook = Workbook()
workbook.LoadFromFile("Sample.xlsx")
sheet = workbook.Worksheets[0]

# 读取 A1:C3 区域的数据
range_data = sheet.Range["A1:C3"]

print("--- 读取 A1:C3 区域的数据 ---")
for row_index inrange(range_data.Row, range_data.LastRow + 1):
    row_values = []
for col_index inrange(range_data.Column, range_data.LastColumn + 1):
        cell_value = sheet.Range[row_index, col_index].Value
        row_values.append(cell_value)
print(row_values)

workbook.Dispose()</code></pre><h3>处理复杂数据类型</h3><p>Spire.XLS for Python 能够准确读取各种复杂数据类型，例如，当单元格包含公式时，您可以获取公式本身或计算结果：</p><pre><code class="python">from spire.xls import *
from spire.xls.common import *

# 创建一个包含公式的 Excel 文件
workbook_formula = Workbook()
sheet_formula = workbook_formula.Worksheets[0]
sheet_formula.Range["A1"].Value = "10"
sheet_formula.Range["A2"].Value = "20"
sheet_formula.Range["A3"].Formula = "=SUM(A1:A2)"

workbook_formula.SaveToFile("FormulaSample.xlsx", ExcelVersion.Version2016)
workbook_formula.Dispose()

# 读取包含公式的 Excel 文件
workbook = Workbook()
workbook.LoadFromFile("FormulaSample.xlsx")
sheet = workbook.Worksheets[0]

# 读取公式单元格
formula_cell = sheet.Range["A3"]
print(f"A3 单元格的公式: {formula_cell.Formula}")
print(f"A3 单元格的计算结果: {formula_cell.Value}")

workbook.Dispose()</code></pre><h2>最佳实践与注意事项</h2><ul><li><strong>资源释放</strong> ：在完成 Excel 操作后，务必调用 <code>workbook.Dispose()</code> 方法来释放资源，特别是在处理大文件或长时间运行的应用程序中，以避免内存泄漏。</li><li><strong>错误处理</strong> ：在文件操作中，建议使用 <code>try-except</code> 块来捕获可能发生的异常，例如 <code>FileNotFoundError</code>、<code>InvalidCastException</code> 等，以增强程序的健壮性。</li><li><strong>性能优化</strong> ：对于特别大的 Excel 文件，考虑分块读取或只加载特定区域，以减少内存消耗和提高处理速度。</li></ul><h2>结语</h2><p>通过本文，我们详细探讨了如何使用 Spire.XLS for Python 库来高效、准确地读取 Excel 数据。从基础的安装、文件加载到深入的单元格、区域和复杂数据类型读取，Spire.XLS for Python 都展现了其强大的功能和便捷性。</p><p>无论是进行数据分析、生成报表还是自动化办公流程，Spire.XLS for Python 都能成为您处理 Excel 文件的得力助手。它能够完美应对传统库在处理复杂 Excel 文件时遇到的挑战，极大地提升您的开发效率。我们鼓励您亲自动手尝试，体验 Spire.XLS for Python 带来的便利！</p>]]></description></item><item>    <title><![CDATA[住宅代理技术深度解析：真实网络身份如何改]]></title>    <link>https://segmentfault.com/a/1190000047439803</link>    <guid>https://segmentfault.com/a/1190000047439803</guid>    <pubDate>2025-12-01 11:04:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在风控算法不断升级的今天，网络上的每一次访问都伴随“身份校验”。对于跨境电商、数据采集、广告验证和自动化测试等高敏感领域而言，能否呈现出可信、自然的访问环境，直接决定任务能否顺利执行。在所有环境构建方案中，住宅代理（Residential Proxy）被视为最接近真实用户身份的技术手段，因此在 2025 年依然是全球企业与开发者最依赖的基础设施之一。</p><h2>一、为什么住宅代理被视为“高可信网络身份”？</h2><p>住宅代理的特殊之处在于，其 IP 地址来自真实家庭网络，而非传统数据中心。换言之，目标网站看到的不是“机房服务器流量”，而是“家庭用户流量”。风控系统长期建立在 IP 信誉、使用场景、访问习惯等多维度数据之上，而住宅 IP 更符合自然用户行为模型，因此更不容易触发警报。<br/>相较之下，数据中心 IP 由于具有批量化、可识别性强、用途集中等特点，常常被归类为“潜在自动化来源”。住宅 IP 则因其混杂度高、地域分布自然，使其在账号稳定、广告访问验证和敏感采集中保持更高成功率。</p><h2>二、住宅代理的底层技术：远不只是“换一个 IP”</h2><p>很多人以为住宅代理只是提供新的 IP，但真正高质量的住宅代理服务，其底层能力远远复杂得多。<br/>首先，动态轮换技术是核心之一。服务商通常提供自动轮换、固定时长 Session、指定国家或城市等不同模式，以确保访问行为更接近真实用户访问逻辑。其次，全球节点调度系统负责选择最优路由，让用户始终从延迟最低、稳定性最强的节点访问目标网站。高端服务商还会加入智能会话保持技术，用于在登录、支付、验证等流程中保持同一 IP，避免因为 IP 漂移而触发风控。<br/>此外，还包括带宽调度、IP 信誉优化、身份混淆、用户隔离策略等系统级技术，这些能力共同决定了住宅代理是否真正适合用在敏感任务中。</p><h2>三、住宅代理在实际业务中的关键价值</h2><p>住宅代理的使用场景非常多元，但大多数都围绕“真实身份模拟”展开。对于爬虫工程师而言，住宅 IP 能有效降低反爬虫系统的压力，因为其访问行为比数据中心流量更难被归类为异常。对于跨境电商卖家与运营团队来说，住宅代理的核心价值在于提供稳定、可信的账号登录环境，避免因网络异常而触发平台的 “高风险 IP” 提示，从而降低封号和关联风险。<br/>在广告行业，验证团队需要从真实用户视角查看广告展示情况，而住宅代理正好提供多地区、低风险的访问环境，使广告验证更准确可靠。在 App、本地化测试、社交媒体运营等领域，住宅 IP 也能帮助团队更好地模拟不同地区用户的使用习惯和网络环境。</p><h2>四、住宅代理与数据中心代理的本质差异</h2><p>虽然数据中心代理价格低、带宽大，但在风控严格的平台上，它们很容易暴露自动化特征。住宅代理则呈现完全不同的身份属性，更接近真实用户自然访问节奏。因此，在高成功率、高隐匿性、高可信度的任务中，住宅代理始终是优先选择。<br/>通俗来说，数据中心代理更适合低敏任务，而住宅代理更适合需要安全性、稳定性的高敏环境。</p><h2>五、使用住宅代理时的风险与优化建议</h2><p>即便住宅代理质量再高，不合理使用依然会触发风控。首先，应避免高频、重复、密集访问，这是任何反爬系统的敏感点。其次，必须确保设备指纹与 IP 组合一致，否则行为模型仍可能不匹配。再者，对于需要长会话的任务，应明确选择固定 Session，而不是频繁轮换 IP。最后，建议合理规划线程数量，过高并发会导致资源拥堵，也可能触发目标网站的行为限制。<br/>合理使用住宅代理，往往比代理本身更影响成功率。</p><h2>六、住宅代理为何成为 2025 年反风控关键基础设施</h2><p>随着 AI 风控能力越来越强，网站会同时检测 IP 信誉、设备指纹、访问路径、行为特征等多维信号。如果想让访问行为更像“人类用户”，就必须构建一个由真实 IP、真实指纹和真实行为组成的综合环境。<br/>住宅代理正是这一体系的基础，它解决的是最底层也是最关键的“网络身份可信度”。无论是跨境电商账号稳定、社交媒体矩阵运营、广告投放验证，还是自动化测试与高风控网站访问，住宅代理都将继续作为核心网络基础设施被广泛使用。</p>]]></description></item><item>    <title><![CDATA[极狐GitLab 18.6 发布，包括：]]></title>    <link>https://segmentfault.com/a/1190000047439861</link>    <guid>https://segmentfault.com/a/1190000047439861</guid>    <pubDate>2025-12-01 11:03:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>沿袭我们的月度发布传统，<strong>极狐GitLab 发布了 18.6 版本</strong>。本次更新的亮点包括：<strong>Maven 虚拟仓库 UI（Beta）</strong>、<strong>全新个人主页</strong>、<strong>实例级合规与安全策略管理</strong> 以及 <strong>DAST 认证脚本</strong> 等。</p><p>这些能力聚焦产品规划协作、软件供应链与安全运营的效率提升，帮助团队在一个平台里完成从计划到交付、从开发到防护的闭环。</p><h3>版本信息</h3><p><strong>容器镜像</strong></p><ul><li>18.6.0 容器镜像</li></ul><pre><code class="plaintext">registry.gitlab.cn/omnibus/gitlab-jh:18.6.0-jh.0</code></pre><ul><li>18.6.0 Helm Chart（JH）</li></ul><pre><code class="plaintext">helm search repo gitlab-jh
NAME                      CHART VERSION APP VERSION 
gitlab-jh/gitlab          9.6.0         v18.6.0    
gitlab-jh/gitlab-runner   0.83.0        18.6.0</code></pre><h3>18.6 关键功能</h3><h3>全新的 GitLab UI：为生产力而设计</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>我们推出了一个更智能、更直观的 GitLab 用户界面，它将开发者的生产力放在首位。</p><p>全新的并排布局采用上下文面板，使你始终处于自己的工作流之中，减少不必要的点击，并帮助团队更快速地工作。</p><p>你可以自定义工作空间，最大化利用屏幕空间，并享受一个更简洁、更动态、能够适应你工作流的体验。</p><p>GitLab 致力于持续改进，因此欢迎在反馈 issue 中分享你的想法，共同塑造 GitLab 的未来。</p><h3>精确代码搜索</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>随着本次版本发布，精确代码搜索现已进入限量可用阶段。你可以使用精确匹配模式和正则表达式模式，在整个实例、在某个群组或在某个项目中执行代码搜索。精确代码搜索基于开源搜索引擎 Zoekt 构建。</p><p>在 <strong>jihulab.com</strong> 上，精确代码搜索默认已启用。  <br/>在 GitLab 自托管版本中，管理员必须先安装 Zoekt，并启用精确代码搜索。</p><h3>CI/CD 组件可以引用它们自身的元数据</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>过去，CI/CD 组件无法在其配置中引用自身的元数据，例如版本号或提交 SHA。  <br/>缺少这些信息会导致你只能使用写死的配置值，或者依赖复杂的变通方案。  <br/>以这种方式编写配置可能导致在构建 Docker 镜像等资源时出现版本不匹配的问题，因为没有办法自动将这些资源与组件的兼容版本进行标记。</p><p>在本次版本更新中，我们引入了通过 <code>spec:component</code> 关键字访问组件上下文的能力。  <br/>现在，当你发布组件版本时，可以构建并发布带版本的资源（例如 Docker 镜像），确保所有内容保持同步，消除手动版本管理，并避免版本不一致的问题。</p><h3>支持在 <code>needs:parallel:matrix</code> 中使用动态作业依赖关系</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p><code>parallel:matrix</code> 允许你轻松并行运行多个具有不同配置需求的作业，例如同时测试多平台代码。但是，如果你希望后续作业使用 <code>needs:parallel:matrix</code> 来依赖某些特定的并行作业，以往的配置会非常复杂、难以维护，且灵活性不足。</p><p>在本次发布中，我们引入了一个新的 <strong>Beta 特性</strong>：<code>$[[matrix.VARIABLE]]</code> 表达式。  <br/>借助此功能，你可以创建 <strong>动态的一对一作业依赖关系</strong>，让复杂的 <code>parallel:matrix</code> 配置更加易于管理。</p><p>这样可以帮助你创建更加高效的流水线，带来以下好处：</p><ul><li>更快的流水线执行速度</li><li>更高效的制品（artifact）处理</li><li>更好的可扩展性</li><li>更简洁的 CI 配置结构</li></ul><p>此特性对以下场景特别有价值：</p><ul><li>多平台构建</li><li>多环境 Terraform 部署</li><li>任何需要跨多维度进行并行处理的工作流</li></ul><p>你可以参考官方文档进一步了解配置方式。</p><h3>GitLab Security Analyst Agent 作为基础代理正式可用</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr></tbody></table><p>GitLab Security Analyst Agent（安全分析代理）现在已经成为 GitLab Duo Agentic Chat 的基础代理（foundational agent）。  <br/>这意味着用户不再需要从 AI Catalog 中手动添加该代理；在自托管（Self-Managed）环境中，它也默认可用。</p><p>这个专门的安全助手提供了 <strong>AI 原生的漏洞管理与安全分析能力</strong>，帮助你在无须任何额外配置的情况下完成以下工作：</p><ul><li>调查安全发现（Findings）</li><li>分析与分流（triage）漏洞</li><li>浏览合规性（compliance）相关要求</li></ul><p>当前该功能为 <strong>Beta</strong> 状态，欢迎在对应 Issue 中提供反馈。</p><h3>安全仪表板升级（在 jihulab.com 进入 Beta 阶段）</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td> </td></tr></tbody></table><p>新版安全仪表板已经过更新和现代化改进。本次 Beta 版本的初始功能包括：</p><ul><li><p><strong>漏洞随时间变化的趋势图</strong>，支持：</p><ul><li>基于项目或报告类型的筛选</li><li>按报告类型或严重级别进行分组</li><li>直接跳转到漏洞报告中的对应漏洞</li></ul></li><li><strong>风险评分模块</strong>：基于 GitLab 算法，为群组或项目计算估算的风险评分。</li></ul><p>在 18.6 中发布的新安全仪表板 <strong>目前仅在 jihulab.com</strong></p><h3>GitLab Coderider Planner Agent 现已默认可用</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td> </td></tr></tbody></table><p>GitLab Coderider Planner Agent 现在已经在 GitLab Coderider Chat 的代理下拉菜单中默认可用，无需再从 AI Catalog 手动添加。  <br/>凭借对你的工作项（work items）、Epic、Issue 和任务的完整上下文理解，Planner Agent 现在可以在 <strong>群组级别</strong>和 <strong>项目级别</strong> 协助你完成规划工作。</p><p>你可以通过文档中提供的示例提示来开始使用，借助 Planner Agent 来：</p><ul><li>分解复杂工作</li><li>创建可执行的实现计划</li><li>组织团队目标</li></ul><p>该功能目前处于 Beta 阶段，欢迎在对应 Issue 中提供反馈。</p><h3>新的 GitLab CLI 功能与改进</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>GitLab CLI（<code>glab</code>）为你的命令行 GitLab 工作流带来了新的功能与改进：</p><ul><li><strong>增强的认证体验</strong>：在登录时自动从 Git 远程仓库中检测 GitLab URL，使你更容易对正确的 GitLab 实例完成认证。</li><li><strong>灵活的流水线监控</strong>：使用 <code>ci-view</code> 命令通过流水线 ID 查看任意流水线。</li><li><strong>GPG 密钥管理</strong>：通过新的命令直接在 CLI 中管理 GPG 密钥。</li><li><strong>项目成员管理</strong>：可以从命令行添加、移除和更新项目成员。</li><li><strong>更完善的 Git 集成</strong>：增强的 <code>git-credential</code> 插件现已支持所有令牌类型。</li><li><strong>现代化界面</strong>：更新了提示库，为确认对话框和其他 UI 组件提供更一致的 GitLab 主题体验。</li></ul><p>如需查看所有更改内容，请访问 CLI 发布说明。  <br/>如需开始使用 GitLab CLI 或升级到最新版本，请参考安装指南。</p><h3>Web IDE 支持离线的 GitLab 私有化部署环境</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td> </td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>在离线或严格受控的网络环境中，GitLab 私有化部署（Self-Managed）的管理员现在可以配置自定义的 Web IDE 扩展主机域名，使 Web IDE 在 <strong>无外网访问的情况下仍能完整使用功能</strong>。</p><p>此前，Web IDE 需要访问外部域名 <code>.cdn.web-ide.gitlab-static.net</code> 来加载 VS Code 扩展和相关功能，这使得许多具有高安全要求的组织（如政府部门、公共机构、拥有严格网络隔离策略的企业）无法使用 Web IDE。</p><p>通过本次更新，管理员可以将 Web IDE 所需的资源直接由 GitLab 实例自身提供，彻底消除了对外部域名的依赖。这样你可以：</p><ul><li><strong>在完全离线环境中使用完整的 Web IDE 功能集</strong></li><li><strong>通过自定义扩展注册表服务启用扩展市场（Extension Marketplace）</strong></li><li><strong>在隔离网络中启用 Markdown 预览、代码编辑以及 GitLab Coderider Chat</strong></li></ul><p>这项改进大幅提升了 Web IDE 在高安全场景下的可用性与部署灵活性。</p><h3>系统触发的审批重置现已提供 Webhook 事件</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS（jihulab.com）</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>将 GitLab 与外部系统通过 Webhook 集成，对自动化工作流和让团队随时掌握合并请求状态变化至关重要。  <br/>然而，当 GitLab 自动重置审批（例如在启用了 “Reset approvals on push” 时，有新提交推送到合并请求），外部系统无法区分这是 <strong>系统触发</strong> 还是 <strong>用户手动操作</strong>。</p><p>现在 GitLab 增强了 Webhook 载荷，能够明确标识系统触发的审批重置事件。  <br/>当审批被自动重置时，Webhook 事件中会包含：</p><ul><li><code>system: true</code> —— 表示此次变更由系统触发</li><li><p><code>system_action</code> —— 提供更具体的上下文，例如：</p><ul><li><code>approvals_reset_on_push</code></li><li><code>code_owner_approvals_reset_on_push</code></li></ul></li></ul><p>通过这些增强信息，你的 Webhook 集成可以：</p><ul><li>准确区分手动与系统自动的审批变更</li><li>根据不同的事件类型触发更精细化的自动化流程</li><li>优化外部系统的通知、审计与工作流处理</li></ul><p>此改进使得自动化系统在面对审批变更时更加可控、可追踪，也能更智能地响应具体的上下文。</p><h3>Helm chart 仓库：取消 1,000 个 Chart 的限制</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS（jihulab.com）</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>在过去的版本中，GitLab 的 Helm Chart 仓库会在请求时动态生成元数据响应。当仓库中 Chart 数量庞大时，这种机制会产生性能瓶颈。为了维持系统稳定性，GitLab 被迫对外只提供 <strong>最近 1,000 个 Chart</strong> 的元数据。</p><p>这导致：</p><ul><li>访问更旧版本 Chart 时频繁出现 <strong>404 错误</strong></li><li><p>平台团队不得不采取复杂绕路方案，例如：</p><ul><li>将 Chart 拆分到多个仓库</li><li>手动管理 Chart 保留策略</li><li>使用独立的 Chart 存储服务</li></ul></li></ul><p>这些复杂性增加了运维负担，并使部署流程碎片化，阻碍了集中化管理。</p><p>在 GitLab 18.6 中，我们通过 <strong>预计算 Chart 元数据并将其存储到对象存储中</strong> 的方式，彻底消除了此前的 1,000 个 Chart 限制。</p><p>这样带来两大显著提升：</p><ol><li><strong>Chart 数量不再受限，所有版本均可正常访问</strong></li><li><strong>性能大幅提升</strong>：元数据只需后台任务生成一次，而不是每个请求都重新生成</li></ol><p>这一架构调整为 Helm Chart 的管理和交付带来了更高的稳定性和可扩展性。</p><h3>合并请求审批策略的 bypass 例外机制</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr></tbody></table><p>组织现在可以为特定的用户、群组、角色或自定义角色配置 <strong>绕过（bypass）合并请求审批策略</strong> 的权限，以便在处理关键事件或紧急问题时更快速地响应。在保持完整审计与治理控制的前提下，这一能力提供了必要的灵活性。</p><h4>主要能力包括：</h4><h4>带有责任追踪的紧急 bypass</h4><p>在面对重大事故、安全热修复或紧急生产问题时，授权用户可以立即合并或推送代码，无需等待审批。  <br/>系统会记录所有细节，包括理由说明，确保合规与可追踪性。</p><h4>规范化的 bypass 流程</h4><p>当授权用户触发 bypass 时，需要填写详细原因，确保每一次例外行为均被完整记录。</p><h4>全面的审计集成</h4><p>每一次 bypass 操作都会生成审计事件，包含：</p><ul><li>执行用户</li><li>策略上下文</li><li>说明理由</li><li>时间戳</li></ul><p>这些记录确保策略例外的透明度与可追踪性。</p><h4>灵活的配置方式</h4><p>可以通过 YAML 或 UI 配置例外对象，包括：</p><ul><li>单个用户</li><li>GitLab 群组</li><li>标准角色</li><li>自定义角色</li></ul><h4>支持 Push 操作的例外</h4><p>拥有例外权限的用户，可在推送时使用：</p><pre><code class="plaintext">security_policy.bypass_reason</code></pre><p>填写绕过审批策略的原因。</p><h3>合并请求审批策略的警告模式（Beta）</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td><strong>Y</strong></td></tr></tbody></table><p>安全团队现在可以使用 <strong>警告模式（warn mode）</strong> 来测试与验证安全策略的影响，而无需立即启用强制执行（enforce）。  <br/>这可以帮助在策略上线前减少开发者阻力，并让安全团队逐步推动策略落地。</p><h4>警告模式的能力包括：</h4><h4>非阻断式的安全提示</h4><p>当策略处于警告模式时：</p><ul><li>合并请求不会被阻塞</li><li>系统会自动生成说明性评论</li><li>用户可以看到策略建议，但仍可正常流程推进</li></ul><p>适合在策略上线前评估影响并引导开发者了解新要求。</p><h4>可选的联系人（approvers-as-contact）</h4><p>你可以设置可选审批者作为策略咨询联系人，方便开发者快速获取策略相关协助。</p><h4>构建信任的渐进式策略推广</h4><p>安全团队可以先通过警告模式收集合并请求中的行为数据与反馈，再逐步切换到强制模式，确保上线更顺畅。</p><h4>明确的模式展示</h4><p>在合并请求页面中有清晰的指示显示当前策略为：</p><ul><li>warn（警告模式）</li><li>enforce（强制模式）</li></ul><p>开发者可以明确知道影响程度。</p><h4>审计事件与违规跟踪</h4><p>系统会记录：</p><ul><li>策略违规</li><li>驳回原因</li><li>解除警告的说明</li></ul><p>这些用于合规报告与审计追踪。</p><h4>允许开发者提供理由来忽略漏洞</h4><p>在警告模式与强制模式下，开发者都可以提供理由来忽略漏洞，使安全团队更好理解业务场景。</p><h3>群组所有者可以为企业用户更新主邮箱地址</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td> </td><td> </td></tr></tbody></table><p>群组所有者现在可以通过 <strong>Users API</strong> 更新其群组内的企业用户（Enterprise User）的主邮箱地址。</p><p>在此之前，每位企业用户都需要自行修改自己的邮箱，这在大规模组织中会带来巨大的管理负担。  <br/>通过此更新，管理员或群组所有者可以集中完成邮箱变更工作，使企业级账号管理更加高效、可控。</p><p>此特性对以下场景尤其有用：</p><ul><li>企业邮箱统一迁移（如更换公司域名）</li><li>用户批量账号调整</li><li>合规要求下需要统一管理用户主邮箱</li><li>大型组织用户生命周期管理（入职 / 离职 / 账户合并）</li></ul><h3>现在 Code Owners 支持继承的组成员身份</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS（jihulab.com）</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>Code Owners 现在支持继承的组成员身份，作为有效的审批人。  <br/>之前，要在 <code>CODEOWNERS</code> 文件中引用一个组，该组必须直接被邀请到每个具体的项目，即使它已经是父组的成员。</p><p>现在，具有继承访问权限的组，也能在启用 Code Owners 审批时，作为有效的审批人。  <br/>这意味着不再需要将组直接邀请到每个项目中。</p><p>现有的 <code>CODEOWNERS</code> 文件不需要做任何修改，仍然可以正常工作，并且对于关键代码路径的审批权限控制保持一致。</p><p>这一变化减少了管理员的管理负担，同时保持了 Code Owners 提供的安全性和审批要求。</p><h3>主页上可以切换草稿合并请求的可见性</h3><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>在主页上，草稿合并请求可能会混杂在正常的合并请求视图中，影响需要立即处理的工作。以前，你无法将草稿合并请求从视图中移除。</p><p>现在，你可以在 <strong>显示偏好设置</strong> 中选择隐藏草稿合并请求，避免其干扰主页上的其他工作。  <br/>当你隐藏草稿合并请求时：</p><ul><li>它们将从活动计数中排除</li><li>页面底部将显示已过滤的草稿合并请求数量</li><li>你的偏好设置将自动保存</li></ul><p>此功能帮助你专注于需要立即处理的合并请求，提高工作效率。</p><h2>GitLab MCP 服务器现已提供 Beta 版本</h2><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td> </td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>GitLab MCP 服务器现已提供beta版本。  <br/>通过 GitLab MCP 服务器，你可以使用诸如 Claude Code、Cursor 以及其他 MCP 兼容工具等 AI 助手，与 GitLab 项目、Issue、合并请求以及流水线进行交互，而无需为每个工具分别构建自定义集成。</p><p>要开始使用，请在你的 Coderider 设置中开启 Beta 和实验性功能。</p><p>GitLab MCP 服务器提供涵盖 Issue、合并请求与流水线的关键工具，  <br/>我们将继续根据用户反馈进行改进。  <br/>此功能目前可能包含不完整的特性或 Bug。</p><h2>列出项目和群组成员的速率限制</h2><table><thead><tr><th> </th><th><strong>基础版</strong></th><th><strong>专业版</strong></th><th><strong>旗舰版</strong></th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr><tr><td><strong>私有化部署</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td></tr></tbody></table><p>我们为 <code>/api/v4/projects/:id/members/all</code> 和 <code>/api/v4/groups/:id/members/all</code> 端点引入了速率限制，以提升 API 稳定性并确保所有用户的公平资源使用。</p><p>现在，<code>GET /api/v4/projects/:id/members/all</code> 和 <code>GET /api/v4/groups/:id/members/all</code> 端点对每位用户的速率限制为 <strong>每分钟 200 次请求</strong>。</p><p>此更改有助于保护 GitLab 实例免受过度 API 使用的影响，避免影响所有用户的系统性能。</p><p>每分钟 200 次请求的限制能够满足正常使用场景，同时可以防止滥用或意外导致的资源耗尽。</p><p>如果你的集成或脚本使用了该端点，请确保它们能正确处理速率限制响应（<strong>HTTP 429</strong>），并按需实现带有退避策略的重试逻辑。</p><p>在正常使用情况下，大多数用户不会受到此项更改的影响。</p>]]></description></item><item>    <title><![CDATA[在JVS支持哪些登录方式？一文了解JVS]]></title>    <link>https://segmentfault.com/a/1190000047439964</link>    <guid>https://segmentfault.com/a/1190000047439964</guid>    <pubDate>2025-12-01 11:03:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在企业数字化浪潮中，我们要用到不同的系统，每次使用的时候账号密码登录太麻烦。在JVS这套开源框架中，支持多种登录方式，可以构建统一、安全的登录方式，满足不同用户群体的多样化需求。<br/>JVS支持多种登录模式，默认支持账号密码、手机号+动态验证码（前提配置短信通道） ，除了这两种模式，还支持钉钉、企业微信、公众号、ldap等。<br/>实现的效果如图所示：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439966" alt="图片" title="图片"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439967" alt="图片" title="图片" loading="lazy"/></p><h2>配置流程</h2><p>首先，进入钉钉的后台设置，在工作台中点击获取应用，进入开发者后台：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439968" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439969" alt="图片" title="图片" loading="lazy"/><br/>进入开发应用<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439970" alt="图片" title="图片" loading="lazy"/><br/>①、点击“自建应用”<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439971" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439972" alt="图片" title="图片" loading="lazy"/><br/>②、填写应用名称、图标logo等<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439973" alt="图片" title="图片" loading="lazy"/><br/>③、点击应用详情，进入应用详细信息页面，选择进入。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439974" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439975" alt="图片" title="图片" loading="lazy"/><br/>④、保存下来几个信息，用于后续的地址拼装，也需要回填到JVS的配置中去。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439976" alt="图片" title="图片" loading="lazy"/><br/>⑤、选中开发管理，点击修改<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439977" alt="图片" title="图片" loading="lazy"/><br/>⑥、填写应用首页地址与PC端首页地址<br/>地址说明：<br/>应用首页地址=域名+/#/login/dingtalk?corpId=$CORPID$&amp;agentId=agentid<br/>例如：应用首页地址=<a href="https://link.segmentfault.com/?enc=ELWpQpmwmpRgRcVy%2FCtTxw%3D%3D.qkzgBH6En32lD48oWmH35ET6xuKOsmlOz05fJOpsNZDRwbiEhZKf6f2lULNKDqoQT92s%2FTFHfzeO4diPdghXYg%3D%3D" rel="nofollow" target="_blank">https://knowledge.bctools.cn/#/login/dingtalk?corpId=</a>$CORPID$&amp;agentId=agentid<br/>PC端首页地址与应用首页地址相同。<br/>CORPID在右上角可以找到。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439978" alt="图片" title="图片" loading="lazy"/><br/>点击权限管理，选中通讯录管理，选中如图所示的几个对应授权<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439979" alt="图片" title="图片" loading="lazy"/><br/>进入登录分享，设置回调域名<br/>回调地址=域名+/#/login/dingtalk/scanback<br/>例如：回调地址=<a href="https://link.segmentfault.com/?enc=8ZW3rtRf8wUKpZ9d8k0GHw%3D%3D.l4r%2BpFsqc%2BSMykCcaMNgZLyrB4Fskix5v4mQJit1ZgowgeocgsMtmBl9InRZnb43DqXsCQ3fd30adlIpZ8DoRw%3D%3D" rel="nofollow" target="_blank">https://knowledge.bctools.cn/#/login/dingtalk/scanback</a><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439980" alt="图片" title="图片" loading="lazy"/><br/>安全设置配置<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439981" alt="图片" title="图片" loading="lazy"/><br/>发布应用。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439982" alt="图片" title="图片" loading="lazy"/><br/>分享设置<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439983" alt="图片" title="图片" loading="lazy"/><br/>以管理员身份进入JVS管理界面<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439984" alt="图片" title="图片" loading="lazy"/><br/>填入从响应的 几个参数。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439985" alt="图片" title="图片" loading="lazy"/><br/>最后界面展示效果：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439986" alt="图片" title="图片" loading="lazy"/><br/>如果在系统中已经有存在的账号，那么可以关联绑定钉钉账号<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439987" alt="图片" title="图片" loading="lazy"/><br/>通过钉钉扫码绑定即可<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439988" alt="图片" title="图片" loading="lazy"/><br/>在钉钉中也可以进行直接打开应用，并且会自动登录当前关联账号。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047439989" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047439990" alt="图片" title="图片" loading="lazy"/><br/>在线Demo：<a href="https://link.segmentfault.com/?enc=z37DyWJ6prSRG5vJ9P0jGg%3D%3D.sSCrP%2B92s5xHi5XxO9p8YGViBPmJYGh1YGLJpj6zUWA%3D" rel="nofollow" target="_blank">http://frame.bctools.cn</a><br/>代码仓库：<a href="https://link.segmentfault.com/?enc=iBYjlXEH7MR8MCoTu1RAJA%3D%3D.nIs%2FAJbES2da9uw7ewx6G0apHpJZuOK5Wtbbrg6NPJyotBu3kHQsVEvsZhMJi6v%2B" rel="nofollow" target="_blank">https://gitee.com/software-minister/jvs</a></p>]]></description></item><item>    <title><![CDATA[2025主流CRM品牌深度横评：从数据底]]></title>    <link>https://segmentfault.com/a/1190000047440050</link>    <guid>https://segmentfault.com/a/1190000047440050</guid>    <pubDate>2025-12-01 11:02:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化转型的浪潮中，客户关系管理（CRM）已从“辅助工具”升级为企业实现<strong>精准获客、高效转化、长期留存</strong>的核心引擎。不同行业、规模的企业对CRM的需求差异显著——有的需要深度业财协同，有的依赖AI驱动的销售自动化，有的则更看重多渠道获客与线索转化。</p><p>本文基于<strong>客户信息管理、销售管理、市场营销自动化、客户服务与支持、</strong> <strong>数据分析</strong> <strong>与报表、移动办公与集成</strong>六大核心领域，对当前市场主流CRM品牌（超兔一体云、Salesforce、探迹EC、Zoho、HubSpot、金蝶云·星辰）进行深度横向对比，拆解各品牌的核心优势与适配场景，为企业选型提供专业参考。</p><h2>一、客户信息管理：从“碎片化”到“一体化”，构建精准客户画像的核心能力</h2><p>客户信息是CRM的“数据底座”，其质量直接决定了后续销售、营销与服务的效率。本部分从<strong>360°视图完整性、多渠道数据整合、</strong> <strong>智能补全</strong> <strong>与查重、权限与共享</strong>四个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440052" alt="" title=""/></p><table><thead><tr><th>品牌</th><th>360°视图核心能力</th><th>多渠道数据整合</th><th>智能补全/查重能力</th><th>权限与共享机制</th></tr></thead><tbody><tr><td>超兔一体云</td><td>整合工商信息、手机号关联微信/支付宝头像，构建“基础信息+行为轨迹”双维度画像</td><td>覆盖百度、抖音、官网、微信、地推、工商搜客等10+渠道，自动汇总线索/客户数据</td><td>自动补全工商信息（天眼查/百度）、手机号查重、企业简称模糊查重</td><td>岗位级权限（财务看财务数据、上级管下级）、助理跟随主管、老板全局管理</td></tr><tr><td>Salesforce</td><td>整合销售、服务、营销、IT多部门数据，通过Data Cloud激活实时数据，构建全链路视图</td><td>对接销售系统、客户热线、社交媒体等，Data Cloud盘活“沉睡”数据至CRM</td><td>批量导入/排重、多条件搜索，控制修改/删除权限</td><td>批量共享/分配/转移、下级客户可见、严格业务员查看范围</td></tr><tr><td>探迹EC</td><td>200+维度企业画像（含工商、财务、经营状态），智能名片追踪客户浏览轨迹</td><td>依托1亿+企业知识图谱，整合呼叫中心、AI外呼、展会、招投标等场景，每月新增100万+线索</td><td>智能名片轨迹追踪、成单数据反馈优化线索模型（意向率提升3.5倍）</td><td>公海/私海分配、离职客户资源继承、低代码权限配置</td></tr><tr><td>Zoho</td><td>自定义字段（如“课程意向”），整合销售、服务数据，支持多条件筛选</td><td>对接销售系统、客户服务热线、社交媒体，实现统一管理</td><td>自定义字段补全、自动化分配线索，Zia AI辅助查重</td><td>分级权限（上级看下级）、客户资料修改/删除权限控制</td></tr><tr><td>HubSpot</td><td>整合Gmail/Outlook邮件、海外社交媒体、电话等互动数据，构建“行为+交易”双维度视图</td><td>对接HubSpot营销/服务工具，兼容Slack、Zoom等第三方，实现跨平台数据汇聚</td><td>自动追踪客户互动（邮件打开、网页访问）、线索评分优化质量</td><td>自动化任务分配、角色级权限控制、客户分段管理</td></tr><tr><td>金蝶云·星辰</td><td>结合金蝶ERP实现“客户信息+财务数据”联动，构建业财一体化视图</td><td>整合Excel、线下记录等分散数据，对接微信/企业微信，实现统一管理</td><td>第三方潜客数据批量导入、智能分配，业财数据自动校验</td><td>业财联动权限（如服务工单关联财务凭证）、岗位级数据可见性控制</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>国内企业适配性</strong>：超兔的“工商信息自动补全”“手机号关联微信/支付宝”，金蝶的“业财数据联动”更贴合国内企业需求（如中小制造企业需要工商信息验证客户资质）；</li><li><strong>全球化协同</strong>：Salesforce的Data Cloud（激活多部门实时数据）、HubSpot的“海外渠道整合”（Gmail/LinkedIn/FB）适合跨区域或海外业务企业；</li><li><strong>线索质量优化</strong>：探迹的“1亿+知识图谱+成单反馈”能有效提升线索意向率（某制造企业应用后月度新客开发量提升200%）。</li></ul><h2>二、销售管理：从“流程驱动”到“AI驱动”，实现全链路转化效率提升</h2><p>销售管理是CRM的“核心战场”，其能力直接决定了线索到订单的转化效率。本部分从<strong>跟单模型适配性、AI辅助能力、流程自动化、绩效跟踪</strong>四个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440053" alt="" title="" loading="lazy"/></p><table><thead><tr><th>品牌</th><th>跟单模型核心能力</th><th>AI辅助功能</th><th>流程自动化能力</th><th>绩效跟踪与预测</th></tr></thead><tbody><tr><td>超兔一体云</td><td>覆盖小单快单（三一客：三定+关键节点）、商机跟单、多方项目（多业务主体）三大模型</td><td>自然语言AI生成工作流，动态进度追踪（红绿灯标识目标跟进健康度）</td><td>工作流引擎支持“数据动作触发”（如客户信息更新自动同步销售任务）</td><td>目标分解至部门/个人/环节（应收款、目标客户），实时展示完成率与异常预警</td></tr><tr><td>Salesforce</td><td>销售云全流程（线索→商机→订单），机会按可衡量指标划分阶段（如“需求确认”“报价提交”）</td><td>Einstein GPT生成销售话术、建议“下一步最佳行动”，预测销售趋势</td><td>自动化线索跟踪、任务分配（如高优先级线索自动分配给Top Sales）</td><td>销售绩效仪表盘（展示当前业绩、预测未来潜力），Zia AI识别业绩波动关键因素</td></tr><tr><td>探迹EC</td><td>全流程协同（线索分配→跟进→资金→汇报），低代码平台支持积木式流程配置（适配多行业）</td><td>AI销售Agent自动化筛选/触达客户，解放人工繁琐工作</td><td>低代码流程配置（如财税行业的“发票审核→合同签订”流程）</td><td>实时数据简报、业绩排行榜，全周期闭环分析（线索→触达→CRM）降低30%获客成本</td></tr><tr><td>Zoho</td><td>线索→商机→报价全流程，销售漏斗跟踪（展示各阶段转化率）</td><td>Zia AI自动发送跟进邮件、安排客户拜访提醒，预测销售异常</td><td>自动化任务分配（如客户三天未回复自动提醒跟进），标准化销售流程配置</td><td>销售绩效管理报表（了解团队业绩达成率），Zia AI预测未来销售潜力</td></tr><tr><td>HubSpot</td><td>可视化销售管道（拖放式界面），线索评分系统（优先推荐高转化潜力客户）</td><td>AI助手提供智能跟进建议，预测客户流失风险</td><td>自动化销售跟进（如邮件模板追踪、任务提醒），自定义销售流程</td><td>实时可视化仪表盘（销售趋势、客户行为），AI预测营销活动ROI</td></tr><tr><td>金蝶云·星辰</td><td>覆盖巡店访销（实地收集市场信息）、移动车销（随时随地开单）、在线开单（减少人工错误）</td><td>智能预警待办任务（如合同到期提醒），路线规划优化线下拜访效率</td><td>从线索→报价→订单→收款全流程跟踪，合同关联审批流程</td><td>多维度统计（业务员/客户/路线），生成可视化报表优化销售策略</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>小单快单场景</strong>：超兔的“三一客”模型是国内中小微企业（如快消、零售）的“神器”，通过“三定（定性、定级、定量）结合销售经验快速分类客户，有侧重的跟单”，可有效压缩跟单周期；</li><li><strong>AI深度赋能</strong>：Salesforce的Einstein GPT（生成话术+建议行动）、探迹的AI销售Agent（自动触达）能显著降低销售的“重复性劳动”；</li><li><strong>场景化适配</strong>：金蝶的“巡店访销/移动车销”适合零售/消费品企业（如饮料厂商需要线下业务员实时开单）；</li><li><strong>流程灵活性</strong>：探迹的“低代码积木式配置”能快速适配财税、物流等行业的个性化流程（如某物流企业通过低代码搭建了“客户对账→运费结算”流程）。</li></ul><h2>三、市场营销自动化：从“盲目投放”到“精准触达”，提升获客ROI</h2><p>市场营销自动化是CRM的“获客引擎”，其核心是将“流量”转化为“线索”，再转化为“订单”。本部分从<strong>多渠道获客、线索优化、自动化营销</strong>三个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440054" alt="" title="" loading="lazy"/></p><table><thead><tr><th>品牌</th><th>多渠道获客能力</th><th>线索优化能力</th><th>自动化营销能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>覆盖百度、抖音、官网、微信、地推、工商搜客等10+渠道，支持线索一键处理（加客户/待办/转订单）</td><td>线索手机号/IP归属地识别，成本均摊至获客线索/签约转化率，评估营销效果</td><td>工作流触发自动触达（邮件、短信），支持话术武器云/文件武器云（销售快速取用物料）</td></tr><tr><td>Salesforce</td><td>营销云跨渠道互动（邮件、社交媒体、广告、LinkedIn），客户旅程可视化设计</td><td>数据云激活沉睡数据，LinkedIn数据增强线索质量，线索评分系统优化优先级</td><td>自动化营销活动（如生日祝福邮件自动发送），客户旅程设计（从“关注”到“购买”的全流程）</td></tr><tr><td>探迹EC</td><td>集成呼叫中心、AI智能外呼、短信/邮件、展会、招投标、地图拓客等场景</td><td>1亿+知识图谱+成单反馈优化线索模型，线索意向率提升3.5倍</td><td>AI销售Agent自动化触达，行业垂直工具包（制造/跨境电商定制化营销）</td></tr><tr><td>Zoho</td><td>支持邮件/短信/社交媒体/广告/活动管理，自动化市场营销平台</td><td>线索捕获后自动分配，Zia AI辅助线索质量评估</td><td>针对性自动化营销（如向“浏览过产品页”的客户发送优惠邮件）</td></tr><tr><td>HubSpot</td><td>集成邮件、社交媒体、广告、SEO工具，支持内容营销（AI写作/SEO优化）</td><td>线索评分系统（根据行为/属性打分），自动追踪客户互动（邮件打开/网页访问）</td><td>自动化工作流（如“下载白皮书→发送跟进邮件→分配销售”），营销活动ROI分析</td></tr><tr><td>金蝶云·星辰</td><td>营销活动模板、客户分群（地域/行为）、精准推送（短信/邮件）</td><td>第三方潜客数据批量导入，智能分配给业务员，业财数据联动校验线索真实性</td><td>营销活动效果分析（如某活动的获客成本/转化率），辅助科学决策</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>国内获客场景</strong>：超兔的“工商搜客”“微信/抖音渠道整合”更贴合国内企业（如中小B2B企业通过工商信息挖掘潜在客户）；</li><li><strong>海外营销</strong>：HubSpot的“SEO工具+LinkedIn/FB整合”、Salesforce的“营销云跨渠道”适合做海外业务的企业（如跨境电商需要通过FB/Instagram获客）；</li><li><strong>线索转化效率</strong>：探迹的“AI外呼+知识图谱”能快速筛选高意向客户（某制造企业应用后线索意向率提升3.5倍）；</li><li><strong>内容营销</strong>：HubSpot的“AI写作+SEO优化”适合依赖内容获客的企业（如 SaaS 公司通过博客吸引线索）。</li></ul><h2>四、客户服务与支持：从“被动响应”到“主动留存”，构建长期客户关系</h2><p>客户服务是CRM的“留存纽带”，其能力决定了客户的复购率与忠诚度。本部分从<strong>服务协同能力、复购挖掘、工单管理</strong>三个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440055" alt="" title="" loading="lazy"/></p><table><thead><tr><th>品牌</th><th>服务协同核心能力</th><th>复购挖掘与留存</th><th>工单管理能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>客服总控台集中管理，RFM分析分块老客户（精准回访），维修/外勤工单（来店/上门）</td><td>RFM分析识别高价值客户，流失风险预警（如3个月未复购自动提醒回访）</td><td>工单派发→执行→反馈全流程跟踪，支持“供应商直发”等特殊场景</td></tr><tr><td>Salesforce</td><td>服务云整合多渠道（电话/邮件/社交媒体/聊天），智能分配工单，知识库支持</td><td>360°视图支撑个性化服务（如客户偏好自动同步服务人员），预测客户需求</td><td>工单分级处理（高优先级工单优先分配），SLA遵守（如2小时内响应投诉）</td></tr><tr><td>探迹EC</td><td>客情信息填写（拜访打卡），软硬件一体化（手机终端延伸服务），与头部硬件厂商协同</td><td>客户反馈分析（生成改进方案），长期价值挖掘（如老客户转介绍奖励）</td><td>售后工单管理（跟踪服务进度），客户满意度调查</td></tr><tr><td>Zoho</td><td>工单管理+知识库+客户门户，Zoho Learn组合（课件分发/在线测验/满意度调查）</td><td>客户行为分析（如“多次浏览某产品”自动推送优惠），预测客户流失风险</td><td>工单自动化分配（如技术问题分配给IT团队），知识库自助服务（降低人工压力）</td></tr><tr><td>HubSpot</td><td>多渠道服务请求整合（电话/聊天/社交媒体），实时聊天+聊天机器人</td><td>AI预测客户流失风险，个性化服务（如根据历史互动推送专属优惠）</td><td>工单系统自动化（如投诉自动生成工单），服务台仪表盘（展示服务效率）</td></tr><tr><td>金蝶云·星辰</td><td>工单分级处理，服务进度跟踪，对接金蝶财务（服务费用自动生成凭证）</td><td>客户价值分析（识别高价值客户），库存预警（与进销存联动，避免缺货流失）</td><td>工单关联财务（如服务费用自动结算），满意度调查（改进服务质量）</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>国内服务场景</strong>：超兔的“维修/外勤工单”（来店/上门）、金蝶的“服务费用联动财务”更贴合国内企业（如家电制造企业需要上门维修工单管理）；</li><li><strong>个性化服务</strong>：Salesforce的“360°视图+预测需求”、HubSpot的“AI预测流失”能提升客户忠诚度（如某零售企业通过Salesforce预测客户需求，提前推送优惠券，复购率提升15%）；</li><li><strong>知识付费场景</strong>：Zoho的“Zoho Learn组合”（课件/测验/满意度）适合中小知识付费团队（如在线教育机构需要分发课件并收集学员反馈）。</li></ul><h2>五、数据分析与报表：从“数据统计”到“决策支撑”，实现数据驱动增长</h2><p>数据分析是CRM的“大脑”，其能力决定了企业能否从数据中提取有效洞察。本部分从<strong>分析深度、报表定制、预测能力</strong>三个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440056" alt="" title="" loading="lazy"/></p><table><thead><tr><th>品牌</th><th>分析深度与维度</th><th>报表定制能力</th><th>预测与预警能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>支持同比环比、多表聚合、关联表复合查询、单日KPI等多引擎分析</td><td>自定义数字卡片/图表卡片（如销售漏斗图、业绩排行榜）</td><td>动态进度追踪（红绿灯标识异常），流失风险预警（如客户3个月未复购）</td></tr><tr><td>Salesforce</td><td>BI数据分析（销售/营销/服务多维度），Zia AI挖掘历史数据与客户行为模式</td><td>自定义报表与仪表盘（展示销售趋势、客户行为），支持数据导出</td><td>Einstein GPT预测销售趋势，Zia AI识别业绩波动关键因素（如“某区域竞争对手促销导致业绩下滑”）</td></tr><tr><td>探迹EC</td><td>全周期闭环分析（线索→触达→CRM），洞察客户跟进流程与潜在客群特征</td><td>实时数据简报、业绩排行榜，支持多维度筛选（业务员/客户/渠道）</td><td>预测客户意向率（通过知识图谱+成单数据），预警低转化率环节（如“跟进周期过长”）</td></tr><tr><td>Zoho</td><td>BI数据分析（销售/客户/服务），Zia AI基于历史数据预测</td><td>自定义报表（如销售业绩表、客户满意度表），支持可视化展示</td><td>Zia AI预测销售异常（如“某业务员业绩突然下滑”），提前预警</td></tr><tr><td>HubSpot</td><td>AI驱动分析（销售趋势、客户行为、营销ROI），多维度拆解数据（如某活动的获客成本）</td><td>自定义报告生成（支持Excel/PDF导出），可视化仪表盘（实时展示核心指标）</td><td>AI预测客户流失风险、销售机会、营销活动ROI</td></tr><tr><td>金蝶云·星辰</td><td>业财联动分析（订单→财务→库存），销售报表（业绩/转化率）、客户价值分析</td><td>多维度统计报表（业务员/客户/路线），支持数据导出与可视化</td><td>库存预警（与进销存联动），服务工单异常预警（如“某工单超时未处理”）</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>业财联动分析</strong>：超兔的“多表聚合+关联查询”、金蝶的“订单→财务→库存”更贴合国内企业（如中小制造企业需要分析“某产品的销售利润=销售收入 - 成本 - 费用”，这种业财联动分析能帮助企业精准核算利润）。</li><li><strong>AI预测能力</strong>：Salesforce的Einstein GPT、HubSpot的AI驱动分析以及Zoho的Zia AI在预测销售趋势、客户流失风险等方面表现出色，为企业提前制定应对策略提供有力支持。</li><li><strong>全周期分析视角</strong>：探迹EC的全周期闭环分析能让企业深入了解客户跟进流程和潜在客群特征，有助于优化销售策略，降低获客成本。</li></ul><h2>六、移动办公与集成：打破时空限制，实现业务无缝衔接</h2><p>移动办公与集成是CRM适应现代企业办公需求的重要能力，它使企业员工能够随时随地开展业务，提升工作效率。本部分从<strong>移动应用功能、系统集成能力</strong>两个维度对比：</p><h3>1. 核心能力对比表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440057" alt="" title="" loading="lazy"/></p><table><thead><tr><th>品牌</th><th>移动应用功能</th><th>系统集成能力</th></tr></thead><tbody><tr><td>超兔一体云</td><td>支持Web、App、小程序、客户端、RPA插件等多端访问，提供客户管理、目标管理、行动管理等核心功能</td><td>具备丰富的业务API和基于网页自动化的Rpa，可与用友、金蝶等ERP系统，电商平台（京东、淘宝等），国税开票机器人等对接</td></tr><tr><td>Salesforce</td><td>新Salesforce移动应用通过AI助手更快处理业务，提升效率、个性化和速度</td><td>与ERP、HR等系统深度集成，满足九级组织架构的复杂权限管理，适配全球化跨区域协同</td></tr><tr><td>探迹EC</td><td>支持手机、平板等移动设备访问，与钉钉深度融合，支持移动办公、流程审批与团队协作</td><td> </td></tr><tr><td>Zoho</td><td>提供强大移动应用，支持销售团队随时随地访问客户信息、管理销售活动</td><td>集成能力强，支持与Zoho生态系统（如Zoho Books、Zoho Desk）及第三方应用（ERP、财务软件、电商平台等）无缝协作</td></tr><tr><td>HubSpot</td><td>移动端应用支持随时随地访问客户信息、任务及销售数据，实现“移动化跟进”</td><td>与HubSpot生态（营销、服务工具）无缝衔接，同时兼容第三方工具（如Slack、Zoom、Shopify、Gmail）</td></tr><tr><td>金蝶云·星辰</td><td>移动端APP支持客户拜访签到、订单录入、审批流程（如合同付款申请），实现“移动化办公”</td><td>深度集成金蝶生态（如金蝶云·星空、财务系统），同时兼容第三方应用（微信、企业微信）</td></tr></tbody></table><h3>2. 关键结论</h3><ul><li><strong>多端适配与功能丰富度</strong>：超兔一体云的多端覆盖和全面的移动应用功能，能满足企业不同场景下的办公需求，尤其适合外勤人员较多的企业。</li><li><strong>全球化集成与协同</strong>：Salesforce的深度系统集成能力和对复杂权限管理的支持，使其成为跨国企业和大型集团的理想选择。</li><li><strong>生态融合与协作</strong>：探迹EC与钉钉的融合、金蝶云·星辰与金蝶生态及第三方应用的集成，以及Zoho和HubSpot与各自生态系统和第三方工具的协作，都为企业提供了更便捷的办公和协作体验。</li></ul><h2>七、总结与选型建议</h2><p>在数字化转型的浪潮中，CRM已成为企业实现精准获客、高效转化和长期留存的核心引擎。通过对超兔一体云、Salesforce、探迹EC、Zoho、HubSpot、金蝶云·星辰等主流CRM品牌在客户信息管理、销售管理、市场营销自动化、客户服务与支持、数据分析与报表、移动办公与集成六大核心领域的深度对比，我们可以总结出各品牌的核心优势与适配场景：</p><h3>国内企业优先考虑</h3><ul><li><strong>超兔一体云</strong>：在客户信息管理上能自动补全工商信息、关联手机号与微信/支付宝，业财联动分析和多端适配能力强，其“三一客”跟单模型适合小单快单场景，工商搜客和微信/抖音渠道整合贴合国内获客需求，维修/外勤工单管理满足国内服务场景，适合国内中小微企业，尤其是快消、零售、中小制造、工业领域等行业。</li><li><strong>金蝶云·星辰</strong>：结合金蝶ERP实现业财数据联动，具备巡店访销、移动车销等场景化功能，营销活动模板和精准推送功能实用，服务费用联动财务贴合国内服务场景，适合制造业/零售业企业，特别是需要供应链与销售全链路打通、偏好混合部署灵活性的成长型企业。</li></ul><h3>全球化业务或对AI要求高的企业</h3><ul><li><strong>Salesforce</strong>：Data Cloud激活多部门实时数据，适合跨区域或海外业务企业；Einstein GPT在销售管理和数据分析方面的强大AI能力，能显著提升销售效率和决策准确性，适合大型跨国企业和对AI技术应用有较高要求的企业。</li><li><strong>HubSpot</strong>：海外渠道整合能力强，SEO工具和AI写作支持内容营销，AI预测客户流失风险和营销活动ROI的能力出色，适合做海外业务、依赖内容获客的企业，如跨境电商、SaaS公司等。</li></ul><h3>追求自动化和流程灵活性的企业</h3><ul><li><strong>探迹EC</strong>：1亿+知识图谱和成单反馈有效提升线索意向率，AI销售Agent和低代码积木式配置能快速适配多行业个性化流程，适合需要提升线索转化效率、有个性化销售流程需求的企业，如财税、物流等行业。</li></ul><h3>功能全面且注重性价比的企业</h3><ul><li><strong>Zoho</strong>：功能全面，自动化与定制化能力突出，Zia AI在销售管理和数据分析等方面提供有力支持，适合中大型企业或有复杂流程需求的团队。</li></ul><h3>预算有限的中小企业</h3><ul><li><strong>悟空CRM</strong>：开源免费，性价比高，功能简洁，适合预算有限、需求基础的中小企业（尤其初创企业）。</li></ul><p>企业在选型时，应根据自身的行业特点、业务规模、发展战略以及实际需求，综合考虑各CRM品牌的核心优势和适配场景，做出最适合自己的选择，以充分发挥CRM系统的价值，实现企业的数字化转型和可持续发展。</p>]]></description></item><item>    <title><![CDATA[价值重构：从时间出卖者到价值创造者，凸显]]></title>    <link>https://segmentfault.com/a/1190000047440190</link>    <guid>https://segmentfault.com/a/1190000047440190</guid>    <pubDate>2025-12-01 11:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>"我每天工作10小时，周末还要加班，但感觉离财务自由越来越远。</p><p>这正是传统职场的最大陷阱：我们被训练成"时间出卖者"，而非"价值创造者"。</p><p>在旧体系中，你的价值=工时×时薪。这种线性模型注定让你陷入忙碌却无法突破的困境。</p><p>而AI时代正在重构价值评估体系：你的价值=解决问题的能力×放大系数。</p><p>关键区别在哪里？穷人的时间只卖给一个人，富人的时间通过产品化卖给成千上万人。</p><p>一个案例（青否ai员工源头v：zhibo175）</p><p>小李，24岁，国企文员，月薪8000元。每天工作8小时，处理文件、写报告、开会议。他的时间只卖给一家公司。</p><p>一年后，他学会了用AI将专业经验产品化：创建了针对国企文书写作的AI模板库，开发了标准化课程，建立了付费社群。现在，他的同一份知识，同时卖给3000+用户。</p><p>这不是特例，而是新范式的开始。</p><p>AI不是替代你的工具，而是放大你价值的杠杆。</p><p>当一个金融分析师使用AI工具，她1小时能完成过去8小时的工作，剩余7小时可以用来思考更高价值的问题，或者将专业知识产品化。</p><p>价值重构的三个层次：</p><p>效率层：用AI提升个人工作效率</p><p>产品层：将专业知识产品化，一份时间多次销售</p><p>系统层：构建AI员工体系，自动产生价值</p><p>真正的突破发生在第三层。当你不再为时间定价，而是为系统创造的价值定价时，你才真正跳出打工人的思维牢笼。</p><p>一位从程序员转型为AI创业者说："以前，我担心35岁被裁员。现在，我拥有15个AI员工，它们24小时为我创造收入。年龄不再是威胁，而是经验和洞察的积累。"</p><p>这不是鸡汤，而是正在发生的现实。国务院文件中提到的"智能体"，正是这些永不疲倦的数字员工。2027年，当70%的企业都在使用AI员工时，你希望自己是被替代的对象，还是拥有AI军团的指挥官？</p><p>当你还在计算加班费时，先行者已经在设计自己的"AI员工招聘计划"。这就是价值重构的本质：从出卖时间，到拥有资产。</p><p>青否科技聚焦于最具AI替代价值的三类岗位：（青否ai员工源头v：zhibo175）</p><p>视频运营岗位：剪辑、发布、多平台同步</p><p>客户接待岗位：微信自动回复、客户标记、标签管理</p><p>营销触达岗位：客户分类、文案生成、批量发送</p><p>这三类岗位有个共同特点：流程固定、任务清晰、可量化成果、高频重复</p><p>而这，正是AI员工最适合发挥稳定价值的场景。</p><p>青否ai超级员工能够做什么？获客+引流+销售全流程，青否AI超级员工：支持一键控制 + 岗位级替代！</p><p>1、AI获客</p><p>告别内容内耗，多平台高效运营。</p><p>sora2批量生成爆款短视频，智能匹配行业关键词，全自动发布覆盖抖音、快手、视频号、小红书。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440192" alt="" title=""/></p><p>GEO智能体优化多平台AI内容，用户提问时主动推荐企业及产品，精准曝光。</p><p>多账号一键绑定管理，数据实时监测，无需跨平台切换，省掉半个编辑团队。</p><p>解决：内容累、制作耗时长、跨平台管理乱的痛点。</p><p>2、AI引流（青否ai员工源头v：zhibo175）</p><p>全域精准引流，获客效率倍增。</p><p>按行业+用户画像全网采集高意向客户，主动私信/评论，无需人工蹲点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440193" alt="" title="" loading="lazy"/></p><p>抖音客服7*24小时在线自动回复，AI拟人聊天，引导客户留资。</p><p>解决：找客难、引流慢、精准度低的痛点。</p><p>3、AI销售（青否ai员工源头v：zhibo175）</p><p>标准化私域成交，降本又增效。</p><p>智能私域管家：自动通过好友、实时监控聊天记录、拟人化自动回复，精准预测客户行为分层。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047440194" alt="" title="" loading="lazy"/></p><p>价值重构：从时间出卖者到价值创造者，凸显ai员工的重要性（青否ai员工源头v：zhibo175）！</p>]]></description></item><item>    <title><![CDATA[IT服务企业现状调研：系统集成行业转型升]]></title>    <link>https://segmentfault.com/a/1190000047439658</link>    <guid>https://segmentfault.com/a/1190000047439658</guid>    <pubDate>2025-12-01 10:11:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>最近两年，我在做ITSS课程培训时走访了不少系统集成企业。</p><p>从武汉的电力自动化到成都的政务云服务，再到深圳做安防监控的系统商，我发现几乎所有传统IT服务企业都面临同样的问题：<br/><strong>利润越来越薄，项目周期越来越短，客户需求却越来越复杂。</strong><br/> 这并不是单个公司的困境，而是整个行业的共性现象。</p><p>我还记得在某次学员研讨会上，一家做网络集成的企业负责人坦言：“现在集成项目做得越多，风险越高。硬件设备利润几乎被压到零，只能靠维保续费和小型开发项目维持。”<br/> 这句话让我印象深刻，因为十年前我在那家公司的时候，项目毛利还能达到30%。</p><p>如今，系统集成行业的商业逻辑彻底变了——客户不再为‘设备’付费，而是在为‘服务体验’买单。<br/>这正是系统集成行业的结构性转型信号。<br/> 过去的系统集成以交付为终点：项目验收完、合同结算完，关系基本就结束了。<br/> 而现在的客户更看重持续服务：系统运行是否稳定？响应是否及时？是否具备可持续的改进机制？</p><p><img width="471" height="335" referrerpolicy="no-referrer" src="/img/bVdndnV" alt="" title=""/></p><p>这意味着企业要从“项目导向”走向“服务导向”。<br/> <strong>按照ITSS标准的定义，这正是从“产品型企业”到“服务型企业”的转变。</strong><br/>很多企业在这个过程中遇到了“思维断层”。<br/> 技术团队仍习惯于一次性交付，而管理层却希望打造长期服务。</p><p><strong> 我在调研中看到的典型问题有三类：</strong></p><ol><li>服务流程不规范——没有形成标准的服务目录或SLA机制，导致交付差异大；</li><li>人员能力结构单一——重技术、轻服务意识，缺少客户协同与需求分析能力；</li><li>商业模式僵化——仍以“设备+人工”计价，无法支撑高附加值的服务定价。<br/>当这些问题叠加时，企业很容易陷入“越做越累、越赚越少”的循环。</li></ol><p>在一次企业辅导项目中，我帮一家做电力运维的公司做转型规划。<br/> 他们过去十年靠设备监控系统生存，但现在客户要求“运维外包一体化”，即希望由同一团队完成监控、巡检、应急、报告。<br/> 我们引入了 ITSS的流程管理模型，把所有工作重构为“例行操作、响应支持、优化改善、调研评估”四类服务内容。<br/> 再将其映射到具体的角色与KPI中，形成服务目录。<br/> 短短半年，他们的平均响应时长从3小时缩短到45分钟，客户满意度提升了28%。<br/> 这家企业的总经理后来对我说：“原来流程化不是约束，而是价值再造。”</p><p><strong>另一个印象深刻的案例是来自深圳的安防企业。</strong><br/> 他们的客户主要是大型园区，以前卖摄像头和布线系统。<br/> 后来引入ITSS服务成熟度评估模型后，企业发现自己处于“一级水平”——主要依靠人力经验，没有形成组织能力。<br/> 于是他们建立了基于iTop平台的工单系统，配合流程自动化和知识库管理。<br/> 三个月后，平均工单关闭率从70%提升到95%，公司也获得了更多长期合同。<br/> 这家企业负责人坦言：“我们不再卖产品，而是卖标准化服务。”</p><p>国内通过了ITSS成熟度评估的IT组织中有超过90%采用的是国际开源IT运维流程软件 iTop，艾拓先锋有幸帮到了其中的一些小伙伴。</p><p>我常常在课堂上提到这个案例，因为它说明转型的关键不在工具本身，而在管理思维的改变。<br/> 当一个企业愿意用流程、指标、评估体系来衡量服务时，它就已经跨过了“系统集成”到“IT服务”的门槛。</p><p><strong>在调研的企业样本中，有一个共同趋势非常明显：</strong><br/> 所有成功转型的企业，都在三个方面形成了系统化能力：</p><ul><li>第一，流程可复用。<br/> 他们把项目中的经验固化为标准流程，通过ITSS的“过程要求”章节完成制度化沉淀。</li><li>第二，能力可度量。<br/> 采用ITSS的“能力管理要求”，为每个岗位定义胜任力标准，并用PDCA循环做能力提升。</li><li>第三，价值可展示。<br/> 通过服务质量指标体系（GB/T 33850）量化服务成果，从而让客户看到可验证的业务改进。</li></ul><p><strong>这些企业的变化不仅仅是效率提升，更是商业模式的重构。</strong><br/> 过去他们靠卖设备赚钱，如今靠“持续服务价值”盈利；<br/> 过去他们是一次性合同关系，现在是长期运营伙伴；<br/> 过去他们依赖个人经验，如今依靠流程体系。<br/> 这正是ITSS所强调的“从能力到体系，从个体到组织”的标准化演进逻辑。</p><p>当然，转型并非一蹴而就。<br/> 在辅导过程中，我看到不少企业中层存在抗拒心理——认为标准化会降低灵活性。<br/> 但当他们亲眼看到流程带来的透明化和可控性后，这种观念逐渐转变。</p><p><strong> ITSS的核心理念其实很朴素：</strong><br/>通过统一语言、规范流程、可量化指标，让复杂的服务变得可复制、可持续。<br/>我个人认为，这种转型的本质不是“学会新标准”，而是“重建新逻辑”。</p><p>IT服务行业正在从“资源驱动”转向“价值驱动”，从“项目式经营”转向“持续服务经营”。<br/> 系统集成企业要在新周期中生存，必须重新定义自己：<br/> 你提供的不只是网络、服务器、监控，而是业务稳定运行的整体保障。</p><p>未来三到五年，这一趋势会更加明显。<br/> ITSS的推广会让越来越多企业发现：<br/>标准化不是行政约束，而是商业竞争力。<br/> 谁能先构建标准化的服务体系，谁就能在数字化转型的浪潮中获得稳定的复利。<br/> 这既是行业的方向，也是每个IT服务人的新起点。</p>]]></description></item>  </channel></rss>