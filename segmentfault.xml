<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[GitPulse：让代码的故事自己讲述 ]]></title>    <link>https://segmentfault.com/a/1190000047433495</link>    <guid>https://segmentfault.com/a/1190000047433495</guid>    <pubDate>2025-11-27 23:03:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2><strong>你值得被看见，而不是被遗忘</strong></h2><p>周五下午，领导突然问你：“这周做了什么？”</p><p>你愣住了。明明一整周都在写代码、改 bug、调接口，可 Git 提交记录却只写着 <code>fix bug</code>、<code>update</code>、<code>调整</code>……这些碎片无法还原你的真实价值——那些深夜的思考、重构的决心、攻克难题的喜悦，全都沉没在时间的洪流里。</p><p>这不是你的问题，是工具的问题。</p><p><strong>我们写代码，不是为了留下一串乱码，而是为了讲述一个故事。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433497" alt="" title=""/></p><hr/><h2><strong>信息 ≠ 理解。而 GitPulse，让信息变成洞察</strong></h2><p>理查德·沃曼——TED 创始人、信息架构之父——曾说过一句深刻的话：</p><blockquote>“信息只有被理解，才能产生价值。否则，它只是噪音。”</blockquote><p>Git 提交记录就是典型的“信息噪音”：  <br/>数据很多，但没有结构；  <br/>历史很长，但看不见趋势；  <br/>记录很全，但读不懂意图。</p><p>GitPulse 的使命，就是把这堆噪音，变成你能听懂、能分享、能积累的<strong>成长叙事</strong>。</p><h3><strong>如何做到？三个关键词就够了：</strong></h3><h4><strong>1. 结构化：从混乱中提炼秩序</strong></h4><ul><li><strong>按时间维度</strong>：每日、每周、每月的开发节奏清晰可见</li><li><strong>按工作语义</strong>：自动识别“功能开发”“Bug 修复”“架构重构”</li><li><strong>按贡献价值</strong>：代码增删量、影响范围、协作模式一目了然</li></ul><p>就像一张精心设计的地图，GitPulse 只突出你真正需要的信息。</p><h4><strong>2. 可视化：让数据开口说话</strong></h4><ul><li>趋势图表：你是稳定输出者，还是冲刺型选手？</li><li>统计面板：个人、项目、团队，三重视角立体呈现</li><li>智能周报：不是流水账，而是有主题、有重点的<strong>价值总结</strong></li></ul><h4><strong>3. 语义化：读懂你代码背后的“为什么”</strong></h4><p>GitPulse 不只看 diff，更理解意图：  <br/>这是性能优化？还是新功能上线？  <br/>是技术债偿还？还是系统架构升级？  </p><p>它把零散的提交，重组成一条条<strong>有逻辑、有温度的故事线</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433498" alt="" title="" loading="lazy"/></p><hr/><h2><strong>价值先行：不是监控你，而是让你看见自己</strong></h2><p>哈里·马克思——传奇营销大师——有一条铁律：</p><blockquote>“先问你能为客户创造什么价值，再谈回报。”</blockquote><p>GitPulse 从不监控、不考核、不压榨。  <br/>它存在的唯一目的，是帮你<strong>看见自己的稀缺性</strong>。</p><blockquote>在这个 AI 高速普及的时代，最危险的不是不会用 AI，而是分不清什么是“标准化工作”——比如在文档指导下就能完成的任务。  <br/>真正让你不可替代的，是那些能带来“非线性回报”的事：设计系统、定义架构、解决模糊问题。</blockquote><p>GitPulse 帮你识别这些闪光点，并把它们沉淀下来。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433499" alt="" title="" loading="lazy"/></p><h3><strong>为谁创造价值？</strong></h3><h4>✅ <strong>给开发者：构建你的成长档案</strong></h4><ul><li>看见进步：代码量、问题解决数、技术深度的变化</li><li>发现模式：高效时段、擅长领域、成长瓶颈</li><li>积累资产：每周自动生成的周报，自动归档至 MongoDB，成为你<strong>十年后都能回看的职业日记</strong></li></ul><p>这不是打卡，这是<strong>有证据的成长</strong>。</p><h4>✅ <strong>给团队：让协作透明，减少内耗</strong></h4><ul><li>谁在做什么？进展如何？避免重复劳动</li><li>贡献被看见，努力被认可，协作更流畅</li><li>不再“默默付出”，而是“彼此照亮”</li></ul><h4>✅ <strong>给管理者：理解，而非控制</strong></h4><ul><li>谁最近压力大？哪些模块频繁改动？</li><li>团队节奏是否健康？协作是否存在瓶颈？  <br/>GitPulse 提供的是<strong>共情的视角</strong>，不是冰冷的 KPI。</li></ul><hr/><h2><strong>特别功能：AI 代码检测——拥抱未来，诚实记录</strong></h2><p>我们不回避 AI 编程。  <br/>相反，GitPulse 内置 <strong>AI 代码识别功能</strong>：</p><ul><li>自动标记 AI 生成代码</li><li>统计 AI 辅助占比</li><li>帮你反思：哪些工作可被 AI 替代？你的核心价值在哪里？</li></ul><p>这不是“抓你用 AI”，而是帮你<strong>和 AI 更聪明地协作</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433500" alt="" title="" loading="lazy"/></p><hr/><h2><strong>每周一封“价值名片”：让成长被看见</strong></h2><p>每周五，GitPulse 可自动发送<strong>结构化周报</strong>到你的邮箱（甚至可抄送领导）：</p><ul><li>有主题、有重点、有数据支撑</li><li>不是“我做了5个task”，而是“我完成了XX模块的架构升级，性能提升40%”</li><li>附带趋势分析，展示你的持续成长</li></ul><p>这封邮件，是你<strong>写给职场的自信宣言</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433501" alt="" title="" loading="lazy"/></p><hr/><h2><strong>长期主义者的秘密武器：MongoDB 归档</strong></h2><p>所有周报自动归档至你的个人 MongoDB 知识库。</p><p>想象一下：</p><ul><li>一年后，你能清晰看到技术成长曲线</li><li>三年后，你能自信地说出“我从初级到架构师的路径”</li><li>十年后，你或许能写出一本《我的编程人生》</li></ul><p>这不是数据备份，这是<strong>你职业生涯的数字资产</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433502" alt="" title="" loading="lazy"/></p><hr/><h2><strong>完全免费，只为价值而生</strong></h2><p>GitPulse <strong>没有广告，没有付费墙，完全免费</strong>。</p><p>为什么？  <br/>因为我相信：<strong>先给予价值，再谈回报</strong>。</p><p>如果你觉得它有用，你的回报可以是：</p><ul><li>分享给同行</li><li>提出建议</li><li>或只是说一句“谢谢”</li></ul><p>这就够了。</p><hr/><h2><strong>三步开启你的价值之旅</strong></h2><ol><li><strong>安装</strong>：在 JetBrains Marketplace 搜索 <strong>“GitPulse”</strong></li><li><strong>打开</strong>：IDE 右侧工具栏点击 <strong>“Git Statistics”</strong></li><li><strong>感受</strong>：看见你的第一份“有故事的周报”</li></ol><hr/><h2><strong>最后的话</strong></h2><p>我们不是代码机器，我们是<strong>创造者</strong>。  <br/>每一行代码背后，都有思考、挣扎、突破和喜悦。</p><p>GitPulse 的使命，就是让这些<strong>被忽视的价值</strong>，重新被看见：</p><ul><li>让你看见自己</li><li>让团队看见彼此</li><li>让世界看见开发者的真实分量</li></ul><p>它不是一个工具，而是一个<strong>懂你的伙伴</strong>。</p><hr/><blockquote><strong>GitPulse：不是监控你的工具，而是看见你的伙伴。</strong>  <br/><em>你的提交有脉搏。让它们说话吧。</em> 💻🎵</blockquote><hr/>]]></description></item><item>    <title><![CDATA[《Unity安卓开发密钥管理全流程实战指]]></title>    <link>https://segmentfault.com/a/1190000047433517</link>    <guid>https://segmentfault.com/a/1190000047433517</guid>    <pubDate>2025-11-27 23:02:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在Unity跨平台开发的深耕之旅中，签名证书始终扮演着应用身份的数字烙印，也是平台校验的核心凭证，而“适配偏差”往往在打包流程的最后一环突然显现，成为阻断发布的隐形壁垒。这种偏差并非简单的参数错误，而是开发环境、密钥管理与平台规则三者交织形成的逻辑裂隙，许多开发者在反复打包失败的循环中耗费大量时间，却忽略了证书本身承载的身份校验逻辑。真正的问题核心不在于“证书不匹配”这一表面现象，而在于对密钥生成、存储、更新全链路的认知断层，以及对不同发布渠道校验机制的深层逻辑缺乏解构。当我们跳出“修改参数”的表层思维，从证书的数字签名原理、密钥链关联逻辑入手，才能真正构建起一套零偏差的签名适配体系，让每一次打包都成为身份验证的精准闭环。在实际开发场景中，这种适配偏差常常以隐蔽的形式存在：比如测试阶段使用自签名证书流畅运行，正式发布时切换为应用市场证书却反复校验失败；或是团队协作中因密钥传递失误，导致不同开发者打包的安装包无法覆盖安装。这些场景背后，都是对证书适配逻辑的认知不足，而解决这类问题的关键，在于建立从密钥生成到发布校验的全流程思维，将每一个环节的潜在风险提前规避。</p><p>理解安卓签名证书的适配逻辑，首先要穿透“文件匹配”的表层认知，触及数字签名的核心本质。签名证书并非简单的密钥文件组合，而是由私钥、公钥、证书链构成的身份验证体系，其中私钥的唯一性是适配的根基—同一应用在不同发布阶段（测试、灰度、正式）若使用不同私钥生成的证书，即便包名一致，也会被安卓系统判定为两个独立应用。在实际开发场景中，这种偏差的常见诱因并非主观疏忽，而是密钥管理的碎片化：开发环境切换时私钥文件路径变更、团队协作中密钥传递出现版本混淆、长期迭代后证书过期未及时更新，这些看似微小的细节，最终都会在打包校验时集中爆发。更易被忽视的是证书链的完整性问题，部分开发者为图便捷直接使用自签名证书，却未补全权威机构颁发的中间证书，导致应用在部分品牌机型上出现校验穿透失败，这种隐性偏差往往难以通过常规排查手段定位。深入探究数字签名的底层逻辑，会发现安卓系统对证书的校验遵循X.509标准，每一份有效证书都需包含 issuer、subject、有效期、签名算法等核心字段，而这些字段的细微差异都可能导致校验失败。例如，部分开发者在生成证书时随意设置有效期，导致证书提前过期；或是选用的签名算法不符合应用市场要求，如使用过时的MD5算法被平台拒绝。此外，公钥与私钥的配对关系是身份验证的核心，一旦私钥丢失或泄露，不仅会导致应用无法更新，还可能引发安全风险，因此密钥的安全性管理同样是适配逻辑的重要组成部分。</p><p>解锁签名适配的关键，在于构建一套可追溯、可复用的密钥管理机制。真正的实践高手从不依赖临时文件传输，而是将密钥纳入项目的版本化管理体系，通过加密存储、权限管控、使用日志记录三重保障，确保私钥的唯一性和安全性。在生成证书阶段，除了遵循安卓官方推荐的2048位RSA算法，更要关注密钥库的加密强度—采用AES-256加密存储密钥库文件，并设置复杂度足够的密码，同时将密钥信息（别名、密码、有效期）记录在离线加密文档中，避免明文存储带来的泄露风险。团队协作场景下，推荐采用密钥共享池机制，通过加密云盘进行密钥分发，同时为每位开发者分配独立的使用权限，确保密钥操作全程可追溯。对于长期迭代的项目，建立证书生命周期管理日历至关重要，在证书过期前3个月启动更新流程，避免因证书失效导致应用无法更新的严重后果。在实际操作中，还可以借助硬件加密设备存储私钥，如USB加密狗，进一步提升密钥的安全性；同时定期对密钥库文件进行备份，并存储在多个安全位置，防止因设备损坏导致密钥丢失。此外，针对不同环境（开发、测试、生产）配置独立的证书，既能避免生产环境密钥泄露，又能确保各环境的隔离性，减少适配偏差的发生概率。</p><p>不同发布渠道的校验规则差异，是签名适配中最易踩坑的隐形雷区。应用市场与企业内部分发对证书的要求存在本质区别：主流应用市场（如华为、小米）不仅校验证书的唯一性，还会验证证书的有效期、签名算法强度，部分平台甚至要求使用平台专用的签名工具进行二次签名；而企业内部分发的应用，若采用自签名证书，需确保所有安装设备信任该证书的根节点，否则会出现安装校验失败。更复杂的场景出现在应用迁移或渠道拓展时，若原应用已在某平台发布，后续新增渠道时必须沿用原证书，否则会被判定为新应用，导致用户数据无法继承、应用评级清零。应对这种差异的核心策略，是建立渠道-证书映射表，在打包前根据目标渠道自动匹配对应的证书配置，同时通过脚本校验证书的各项参数是否符合渠道要求，将校验环节前置到打包流程的初始阶段。以华为应用市场为例，其要求应用使用SHA256签名算法，且证书有效期不得少于1年，若未满足这些条件，即便证书本身匹配，也会被平台驳回；而企业内部分发时，需将自签名证书安装到设备的信任凭证中，否则安卓系统会直接拦截安装。此外，部分应用市场支持证书更新功能，但更新流程需严格遵循平台规定，否则可能导致应用下架，因此在进行证书更新前，务必详细研读目标渠道的官方文档，确保每一步操作都符合要求。</p><p>签名适配的实战优化，需要将校验逻辑融入开发全流程，形成自动化的防错机制。在Unity环境中，除了在Player Settings中配置证书信息，更应构建自定义的打包校验流程：通过编写自动化脚本，在打包前校验密钥库文件的完整性、私钥密码的正确性、证书链的完整性，同时对比当前证书与历史发布证书的指纹信息（MD5、SHA1、SHA256），确保无偏差后再启动打包。对于频繁切换开发环境的场景，推荐使用环境变量存储证书路径和密码，避免在项目配置中硬编码敏感信息，同时通过脚本自动识别当前环境，加载对应的证书配置。另一个实用技巧是建立证书指纹库，将所有已使用的证书指纹记录在案，每次打包时自动比对，防止因误操作使用错误证书。此外，定期进行证书兼容性测试也不可或缺，在不同品牌、不同系统版本的设备上验证应用的安装和运行情况，提前发现因证书适配导致的隐性问题。在实际优化过程中，还可以借助Unity的BuildPipeline API扩展打包流程，将证书校验、渠道匹配等逻辑集成到一键打包工具中，减少人工操作失误；同时利用CI/CD流水线自动化执行校验流程，在代码提交阶段就对证书配置进行检查，确保问题早发现、早解决。对于Unity不同版本的差异，如2020版本与2022版本在证书配置界面的细微变化，也需及时关注并调整适配策略，避免因版本升级导致的配置失效。</p><p>签名证书的适配实践，本质上是开发流程规范化与技术认知深度的双重体现。它不仅要求开发者掌握证书生成、配置、更新的实操技巧，更需要建立起“身份校验”的底层思维—每一次签名都是应用与平台、用户之间的信任约定，而适配的核心就是维护这份约定的一致性与安全性。随着安卓系统安全机制的不断升级，签名证书的校验标准也在持续迭代，从早期的MD5指纹校验到如今的SHA256证书链验证，从单一私钥签名到双证书机制，开发者需要保持对技术趋势的敏感度，及时调整适配策略。在长期的开发实践中，我们会逐渐意识到，签名适配并非孤立的技术环节，而是与项目管理、团队协作、安全防护深度绑定的系统工程。当我们能够将密钥管理、渠道适配、自动化校验融入日常开发流程，让签名适配成为一种潜意识的规范动作时，那些曾经困扰我们的打包障碍，终将转化为提升开发效率与应用安全性的核心竞争力。近年来，安卓14系统对应用签名提出了更严格的要求，强制启用APK Signature Scheme v4，这就要求开发者及时更新签名工具和适配策略，否则将无法在新系统上安装运行。</p>]]></description></item><item>    <title><![CDATA[《Unity多插件原生库依赖协同适配实战]]></title>    <link>https://segmentfault.com/a/1190000047433520</link>    <guid>https://segmentfault.com/a/1190000047433520</guid>    <pubDate>2025-11-27 23:02:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>原生库作为连接引擎与底层系统的技术桥梁，其协同适配问题始终处于隐性却关键的位置。当多个功能插件同时引用同一原生库时，引发的并非表面可见的运行异常，而是底层依赖链路的交织冲突—这种冲突源于原生库的版本差异、符号定义重叠、编译参数分歧等深层技术节点，往往在打包流程或跨平台测试阶段突然显现，成为阻断开发进度的隐形壁垒。许多开发者在面对这类问题时，习惯采用删除重复文件的表层解决方案，却忽略了原生库依赖的传导效应，导致插件功能残缺或底层接口调用失效。真正的破解之道，在于穿透插件封装的黑盒，构建原生库的协同适配体系，通过依赖图谱解析、版本协同调度、符号隔离设计等核心策略，让多个插件在共享原生库资源的同时，实现底层依赖的无隙兼容。这种适配能力不仅是技术深度的体现，更是驾驭复杂插件生态的核心竞争力，让开发者在丰富功能插件的同时，无需担忧底层依赖的隐性冲突。实际开发中，这类冲突常以隐蔽形式爆发：比如集成支付、统计、地图三类插件时，均引用了某核心原生库的不同版本，打包时未触发报错，却在安卓14设备上出现功能调用超时；或是PC端测试正常的项目，移植到iOS平台后因原生库编译架构不兼容，导致插件功能集体失效。这些场景印证了冲突的多维度特性，也凸显了构建系统性适配方案的必要性。</p><p>理解多个插件引用同一原生库的冲突本质，需要跳出“文件重复”的表层认知，触及原生库依赖的底层运行逻辑。原生库作为承载底层功能的二进制组件，其内部包含的符号定义、接口协议、内存布局等核心要素，会随着版本迭代发生隐性变化。当不同插件引用同一原生库的不同版本时，即便文件名一致，其内部的接口参数、返回值类型、符号命名规则都可能存在差异，这种差异会导致运行时的接口调用错位—比如某插件依赖原生库的旧版本接口，而另一插件引入的新版本已废弃该接口，最终引发底层功能调用的逻辑断裂。更易被忽视的是编译参数的分歧：不同插件作者在编译原生库时，可能采用不同的架构指令集、优化级别或依赖库配置，导致同一原生库的不同编译产物在内存中无法协同工作，比如某插件的原生库启用了硬件加速指令，而另一插件的同库未启用，两者同时加载时会出现内存访问冲突。此外，原生库的静态链接与动态链接方式差异，也会加剧冲突风险—静态链接的原生库会将依赖代码嵌入插件，而动态链接则依赖系统或引擎的动态加载，两者混合使用时极易出现符号重复定义的问题。深入探究会发现，冲突的传导性更值得警惕：某插件的原生库依赖了第三方底层库，而其他插件未包含该依赖，运行时会因依赖缺失导致连锁失效；甚至部分原生库会修改系统全局状态，不同版本同时加载时会出现状态覆盖，引发难以复现的隐性异常。</p><p>破解原生库协同冲突的首要步骤，是构建精准的依赖冲突溯源体系。真正的实践核心并非盲目删除重复文件，而是通过系统性排查锁定冲突的技术节点。首先需要对项目中所有插件的原生库进行全景扫描，梳理每个原生库的版本号、架构支持范围、编译参数、接口清单等核心信息，构建可视化的依赖协同图谱—这种图谱不仅能清晰呈现重复引用的原生库，还能标注不同版本间的接口差异与符号重叠点。在溯源过程中，需重点关注原生库的元数据信息，比如安卓平台SO库的ELF头文件、iOS平台Framework的Info.plist文件，这些文件中包含的版本标识、符号表、依赖链路等信息，是定位冲突核心的关键线索。对于复杂项目，可借助专业的依赖分析工具辅助排查，通过解析插件的打包清单与原生库的符号表，快速识别重复定义的函数、变量或接口。值得注意的是，部分冲突具有隐性传导特性，比如某插件引用的原生库依赖另一未声明的底层库，而其他插件未包含该依赖，导致运行时出现依赖缺失，这种情况下需要通过反向追踪依赖链路，补全缺失的底层依赖组件。实操中，还可通过“逐一禁用插件”的对照测试定位冲突源：先移除所有插件，再逐个集成并测试，记录每个插件加载后的原生库状态变化，通过对比分析锁定引发冲突的插件组合与原生库版本；同时结合日志工具捕获原生库加载过程中的异常信息，比如符号解析失败、版本不兼容提示等，为溯源提供直接依据。</p><p>原生库协同适配的核心解决方案，在于建立“版本统一+符号隔离+动态调度”的三维适配体系。版本统一是基础策略，需筛选出与所有插件兼容的原生库版本—优先选择功能覆盖最广、接口最稳定的版本，若不同插件对版本要求存在不可调和的差异，则需与插件作者沟通，推动插件适配统一版本的原生库，或获取原生库的源码进行二次编译，确保接口兼容性。符号隔离是解决冲突的关键技术，通过对原生库的符号进行重命名或命名空间封装，让不同插件引用的同一原生库拥有独立的符号标识，避免运行时的符号冲突—这种方式需要对原生库进行二次封装，在不改变核心功能的前提下，重构符号命名规则，构建独立的符号隔离矩阵。动态调度策略则适用于复杂场景，通过自定义原生库加载器，根据插件的调用需求动态加载对应的原生库版本，在内存中实现不同版本的隔离运行—比如为不同插件分配独立的原生库加载上下文，确保各版本的接口调用互不干扰。在实践中，这三种策略可灵活组合，比如对于核心功能插件采用版本统一，对于特殊功能插件采用符号隔离，实现整体适配效率与功能兼容性的平衡。具体落地时，版本统一需建立严格的兼容性测试流程：将候选版本与所有插件进行组合测试，验证接口调用、功能实现、性能表现等维度的兼容性；符号隔离可借助编译工具的符号重命名功能，批量修改原生库的符号名称，并生成新的头文件供插件调用；动态调度则需设计智能加载逻辑，通过插件标识判断所需的原生库版本，在插件初始化时完成对应版本的加载与初始化，同时做好内存管理，避免版本切换导致的内存泄漏。</p><p>跨平台场景下的原生库协同适配，需要兼顾不同系统的底层运行机制差异。安卓平台的SO库适配需关注ABI架构的一致性，不同插件引用的原生库必须支持相同的架构集合，避免因架构不兼容导致的加载失败—同时需注意安卓系统的权限机制，部分原生库需要特定权限才能正常运行，需在项目配置中统一声明。iOS平台的Framework与静态库适配，核心在于链接方式的统一，若部分插件使用静态链接的原生库，部分使用动态链接，需将静态库转换为动态库或反之，确保链接机制的一致性—此外，iOS的沙盒机制对原生库的路径访问有严格限制，需统一原生库的存放路径，避免插件调用时出现路径查找失败。WebGL与PC平台的原生库适配，则需关注编译目标的兼容性，WebGL平台不支持部分原生库的系统调用，需选择适配WebGL的原生库版本，而PC平台则需兼顾32位与64位系统的差异，确保原生库的位数与项目配置一致。跨平台适配的核心思维，是建立“系统特性-原生库属性-插件需求”的映射关系，针对不同平台的底层机制，制定差异化的协同适配策略，避免一刀切的解决方案。实操中，安卓平台可通过Gradle脚本统一管理原生库的ABI过滤与权限声明，确保所有插件的原生库架构统一；iOS平台可借助Xcode的静态库合并工具，将多个静态库整合为统一的动态库，简化链接流程；WebGL平台则需优先选择纯C实现的原生库，避免依赖系统级API，同时通过Unity的WebGL原生库适配工具进行兼容性优化；PC平台可通过条件编译指令，为32位与64位系统配置不同的原生库路径，确保跨位数兼容。</p><p>原生库协同适配的长期实践，本质上是插件生态管理与技术预判能力的双重体现。随着Unity插件生态的持续繁荣，越来越多的插件会依赖相同的核心原生库，冲突风险也会随之提升，这就要求开发者建立常态化的依赖管理机制—在引入新插件前，先对其原生库依赖进行预校验，对比项目中已有的原生库版本与特性，评估冲突风险；在项目迭代过程中，定期更新原生库版本，修复已知的兼容性问题，同时建立依赖变更日志，记录原生库的版本迭代与插件适配情况。更重要的是培养底层技术认知，深入理解原生库的编译原理、链接机制与跨平台适配特性，只有掌握这些底层知识，才能在面对复杂冲突时快速制定解决方案。此外，构建团队内部的原生库适配知识库，沉淀不同场景下的冲突解决案例与适配策略，能显著提升后续项目的适配效率。原生库协同适配并非一次性的技术攻关，而是持续迭代的系统工程，当我们能够将依赖管理、冲突溯源、跨平台适配等能力内化为开发习惯时，就能在丰富插件功能的同时，保持项目底层的稳定与高效，真正驾驭Unity跨平台开发的复杂生态。</p>]]></description></item><item>    <title><![CDATA[是推动监管 苦闷的键盘 ]]></title>    <link>https://segmentfault.com/a/1190000047433561</link>    <guid>https://segmentfault.com/a/1190000047433561</guid>    <pubDate>2025-11-27 23:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>从生成式 AI 的惊艳亮相引起全球科技巨头军备竞赛般的投入开始，整个 AI 行业仿佛被注入了无限的想象力。似乎在宣告着即将出现一个生产力即将被彻底解放、商业模式即将被完全颠覆的光明未来。<br/>微软、谷歌、亚马逊等云巨头纷纷将资本支出的绝大部分押注于 AI 基础设施建设，而无数逐利而来的 AI 初创公司，更是如雨后春笋般涌现试图分一杯羹，全球 AI 领域的投资额也达到了史无前例的高度。<br/>然而，正如任何过热的淘金热最终都会迎来冷静期当技术以超乎预期的速度普及时，潜在的负面效应也以同样的速度被放大，正在悄然侵蚀着行业参与者。<br/>从 " 可选项 " 到 " 必选项 " 的巨额支出<br/>根据奇安信集团对外发布《2024 人工智能安全报告》来看，在 2023 年基于 AI 的深度伪造欺诈便已暴增了 3000%，基于 AI 的钓鱼邮件也增长了 1000%；而内容生成环节更是实现规模化生产。<br/>基于 Stable Diffusion 和 GPT-4 的定制模型，可每小时生成 2000 条伪原创研报、800 段逼真视频。暗网平台 "DarkGPT" 更是提供包月服务，1 万美元即可获得每日 5000 条金融虚假内容的产能。<br/>而且 "AI 滥用 " 的后遗症并不仅仅在社会新闻版块，可以说它已经穿透了科技公司的防火墙直接作用于其财务报表。而金融行业正是这场风暴的中心，当 AI 以假乱真的能力被精准地应用于金融诈骗时，其破坏力可以说是指数级的增长。<br/>据行业估算，2024 年由深度伪造技术引发的各类欺诈造成的全球经济损失已高达 120 亿美元。尤其在监管相对滞后、交易更为匿名的加密货币领域，AI 滥用更是如鱼得水。根据相关的报告也显示 2024 年仅 AI 深度伪造技术全年造成的损失便高达 46 亿美元。<br/>随着 AI 滥用事件的频发，过去模糊的 " 伦理指南 " 正在迅速转变为具有强制约束力的法律条文，而且这种转变直接导致了企业合规成本的急剧攀升。<br/>而且一旦出现违规需要付出的代价更是惨痛的，罚款最高可达全球年营业额的数个百分点或数千万欧元，而且合规也不再是法务部门的单一工作，而是渗透到研发、产品、市场的每一个环节。<br/>这些 " 反噬 " 也并非凭空产生，在 AI 商业化过程中对速度和规模的追求，长期以来压倒了对安全和伦理的考量所以形成了这种 " 原罪 "。因此未来合规成本的升高是不可避免的，而欧盟的《AI 法案》可以说是这一趋势的先行者。<br/>该法案于 2024 年 8 月 1 日正式生效并分阶段实施，着重对高风险的 AI 系统施加了严格的合规要求。而且这不仅仅是一项区域性法规，更可能产生 " 布鲁塞尔效应 " 从而影响全球的 AI 监管格局。<br/>监管的落地也将会直接转化为企业的合规成本。据公开信息推算，仅欧盟 AI 法案便可能导致欧洲企业的 AI 采纳成本增加约 310 亿欧元，并使 AI 投资减少近 20%。而美国联邦贸易委员会也已对 OpenAI 展开调查，谷歌等公司也不得不调整其营销话术，避免被处以巨额罚款。<br/>可以说 " 监管的铁幕 " 正在迫使整个行业从过去 " 快速行动，打破陈规 " 的互联网思维转向一种更为审慎、合规驱动的开发模式。可以说这种转变无疑会减缓创新速度并增加运营成本，对于那些资源有限的中小企业和初创公司构成尤为严峻的挑战。<br/>对 " 信任 " 的侵蚀或许是 AI 滥用最难修复的一种<br/>这源于在激烈的竞争压力下，企业急于抢占市场将产品快速推向用户，所以将风险控制和安全测试置于次要位置。但是这种 " 快速行动并打破规则 " 的心态在 AI 时代尤为危险，因为 AI 技术的潜在破坏力远超以往的软件应用。<br/>并且市场对于 AI 技术的可靠性极度敏感，甚至一次小小的失误都可能引发巨大的信任危机和财务损失。谷歌的 Bard 模型之前便在一次演示中出现事实性错误，竟然导致其母公司 Alphabet 的股价在单日内暴跌 7%，市值蒸发超过 1000 亿美元。<br/>并且随着 AI 投资的巨额支出持续攀升，投资者开始担忧其回报前景，这种悲观情绪导致 Meta、Microsoft、Alphabet 和 Nvidia 等 AI 领域的领军企业股价普遍承压下跌，市场也开始讨论 "AI 泡沫 " 的风险，并开始质疑哪些不计成本的 " 军备竞赛 " 式投资。<br/>更何况大量公司缺乏对 AI 伦理的明确责任归属，高管层面也并未对其有所调整。所以 AI 系统的决策过程像一个 " 黑箱 "，在责任主体模糊的情况下滥用和误用的风险便难以控制。企业内部也未建立有效的问责机制。<br/>但是更深层次的原因在于当前主流生成式 AI 商业模式本身所内含的风险。这些模型依赖于海量数据的投喂，其训练过程难以完全避免偏见和有害信息的吸收。而其强大的生成能力却为恶意利用提供了温床。<br/>因此当商业模式的核心是追求更强大的模型、更广泛的应用时，如果缺乏与之匹配的强大 " 安全刹车 " 系统，滥用就成了可预见的副产品。这种商业逻辑与伦理要求之间的结构性失衡才是导致 " 反噬 " 的根本内因。<br/>所以当企业享受了技术红利带来的增长，如今便也不得不为其模式所伴生的风险 " 买单 "。哪怕科技公司以 " 让世界更美好 " 的叙事推广 AI，公众在实际体验中，也会频繁受到隐私泄露、算法偏见、就业替代、虚假信息等负面影响。<br/>这种落差也导致了广泛的 "AI 焦虑 " 和不信任感。公众普遍认为现有的监管法规不足以应对 AI 带来的社会风险期望政府采取更加果断的行动。这种强大的民意压力也是推动监管机构加速行动的根本动力。<br/>面对公众的呼声和潜在的社会风险，监管机构的介入是必然的。但由于技术发展的速度远超立法速度监管往往表现出一定的滞后性，欧盟 AI 法案便被部分人士认为可能增加企业负担、抑制创新。<br/>全球主要经济体在 AI 领域的竞争，也使得监管变得更加复杂。各国都希望在鼓励创新和防范风险之间找到平衡点但这种平衡点的位置各不相同，因此形成了复杂的国际监管格局给跨国企业的合规带来了巨大挑战。<br/>而且这种外部滥用对整个 AI 行业的声誉造成了 " 连坐 " 效应。即使一家公司本身恪守伦理，也无法完全独善其身，因为公众对 AI 的信任是整体性的。恶意滥用行为如同向池塘中投下的毒药，在污染了整个水域后迫使所有 " 池中生物 " 共同承担后果。<br/>这场危机成为 AI 自我革新的契机<br/>这场 " 反噬 " 带来的阵痛，是 AI 产业从野蛮生长走向规范发展的必经阶段。它正在淘汰那些只想赚快钱、缺乏责任感的 " 玩家 "，筛选出真正有实力、有远见的长期主义者。从长远来看，这也是为 AI 产业的健康、可持续发展所必须付出的代价。<br/>其中最大的机遇在于将 " 信任 " 从一种道德呼吁，转变为一种可量化、可变现的商业资产和竞争壁垒。数据显示近 85% 的客户也更愿意与重视 AI 伦理实践的公司合作，而那些优先考虑伦理和透明度的公司收入增长也更快。<br/>可以说在 AI 产品同质化日益严重的未来，谁能赢得用户的信任谁就能赢得市场。" 负责任的 AI" 将不再仅仅是公关部门的口号，而是必须贯穿于产品设计、开发、部署全流程的核心战略。<br/>谷歌和微软等公司已经开始调整其策略，谷歌选择利用 AI 技术提升广告安全审核的效率，打击欺诈内容；微软则发布了负责任 AI 透明度报告，并推出了 AzureAIContentSafety 等服务，帮助客户构建更安全的 AI 应用。这些举措既是应对风险的防御，也是在构建新的竞争优势。<br/>正是 " 反噬 " 催生了全新的 " 安全即服务 " 市场。随着 AI 滥用风险的加剧企业对 AI 安全审计、风险评估、内容过滤、合规咨询等服务的需求将急剧增长。这为专门从事 AI 安全和伦理治理的科技公司、咨询机构创造了巨大的市场空间。<br/>而科技巨头自身也可以将其内部成熟的安全工具和能力平台化、服务化，开拓新的收入来源。例如，谷歌和微软在内容审核、风险识别方面的技术积累，完全可以转化为对外输出的商业服务。<br/>虽然监管的收紧虽然带来了成本，但也为行业设定了 " 准入标准 "，能够率先满足高标准合规要求的企业将获得更强的市场公信力和竞争优势，从而在未来的市场整合中占据有利地位。这实际上是一种由监管驱动的市场出清和格局优化。<br/>从滥用事件的激增，到资本市场的审慎，再到全球监管的收紧，这股 " 反噬 " 之力正在重塑 AI 产业的发展轨迹。它迫使整个行业从过去对技术力量的无限崇拜，转向对技术责任和社会价值的深刻反思。<br/>麦肯锡预测，到 2030 年 AI 将为全球经济创造 13 万亿美元价值。但价值分配取决于我们如何驾驭这头猛兽。未weibo.com/ttarticle/p/show?id=2309405237572459954332<br/>weibo.com/ttarticle/p/show?id=2309405237572879646781<br/>weibo.com/ttarticle/p/show?id=2309405237573202608297<br/>weibo.com/ttarticle/p/show?id=2309405237573659525441<br/>weibo.com/ttarticle/p/show?id=2309405237580458754097<br/>weibo.com/ttarticle/p/show?id=2309405237580785909979<br/>weibo.com/ttarticle/p/show?id=2309405237581108609265<br/>weibo.com/ttarticle/p/show?id=2309405237582396260480<br/>weibo.com/ttarticle/p/show?id=2309405237582719484192来的竞争，将不仅仅是模型参数和算力大小的竞争，更是治理能力、责任担当和用户信任的竞争。</p>]]></description></item><item>    <title><![CDATA[从技术管理者到战略决策者，揭秘IT技术负]]></title>    <link>https://segmentfault.com/a/1190000047433435</link>    <guid>https://segmentfault.com/a/1190000047433435</guid>    <pubDate>2025-11-27 22:02:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>文 / Kenyon，关注我，获取更多企业级架构、技术团队管理和AI实践与落地的深度指南。</blockquote><p><strong>摘要</strong>：本文将IT团队负责人价值划分为任务执行者、流程优化者、技术战略家、业务共创者四个递进层次，剖析各层次本质与跃迁方法，揭示从'被业务驱动'到'驱动业务'的认知转变，为IT负责人成长为战略决策者提供实践指南。</p><h2>引言</h2><p>大家好，我是Kenyon，我作为一名科班出身，在技术领域摸爬滚打近20年的老兵，带团队也带了12年了，我经常在组织发展和人才梯队建设中思考这样一个问题：作为一名IT团队的负责人（不同企业的叫法不一样，比如：CTO、CIO、技术总监、技术经理、研发主管等），我的价值究竟是体现在哪些层面呢？ 我的成长路径是怎样的呢？我该如何做才能从单纯的“执行者”蜕变为企业的“战略伙伴”甚至是“业务引领者”呢？一想到这个问题我都夜不能寐，至今也没能给自己做出一个满意的答复。</p><p>本来我是想把这个问题在继续深度思考了之后才和大家分享的，不过从昨天发布的《<a href="https://link.segmentfault.com/?enc=lVlvfpSZnnMW4ZfvMoF5Sw%3D%3D.T%2FEpMQL14MCEKROxCXPwtL8TfMsnPMeg391LiqiG170MfGbK4PGauNVG5aHgIK2IREseRf4uLWRqs51Rz4ximg%3D%3D" rel="nofollow" target="_blank">从成本中心到战略引擎：揭秘IT团队的五个价值层次，看看你的团队在第几层？</a>》这篇文章来看，初步的数据反响我觉得还是挺不错的，发表才一天，阅读和分享的次数比前面几个文章多了一倍左右，所以我觉得有必要提前来写一下我基于多年观察与实践得出来的初步的思考答案，在这里抛砖引玉，如果大家觉得那里写得不好的也欢迎拍砖。</p><p>以下为深度好文，把我十多年对团队负责人这个角色的领悟毫无保留的分享给您了，关注一下我吧！感谢您的支持！</p><p><strong>核心观点：IT技术团队负责人价值层次的提升不仅仅是个人能力的提升，更是认知模式的跨越式跃迁——从“完成任务”到“系统优化”，从“支撑业务”到“定义未来”，最终实现从技术管理者到企业创新核心驱动力的角色蜕变。这种跃迁的本质是：从“被业务驱动”到“驱动业务”，从“创造交易价值”到“创造生态价值”的转变。</strong><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047433437" alt="技术负责人的4个层次" title="技术负责人的4个层次"/></p><h2>第一层：任务执行者</h2><h3>1.1 表现特征：</h3><ul><li>只会关注具体任务的交付，如完成需求开发、修复Bug、按时上线</li><li>被动地响应业务部门的需求，缺乏对业务和系统的主动沟通和规划</li><li>技术的视野一般局限于当前的项目或系统，习惯只关注自己的一亩三分地</li><li>团队管理的时候都是以“安排工作”为主，缺乏给团队赋能的意识和能力</li></ul><h3>1.2 本质洞察：</h3><ul><li>价值 = 可靠的劳动力 + 及时的交付</li><li>认知模式：只是Push一下就动一下，不会主动输出的线性思维、只会关注眼前任务这样的战术导向</li><li>心理底层：只想着怎么避免犯错、只会按部就班地去做事的安全导向</li></ul><p><strong>阶段的总结：这阶段基本都是只想“只想把事情做对”，很少甚至没有去思考过“这件事到底该不该做”。本质上是个人技术专业能力的“变现阶段”，通过个人的专业技能来换取组织的信任，大部份刚开始做管理的朋友都会经历这个阶段的。</strong></p><h3>1.3 跃升的挑战与突破之道：</h3><ul><li><strong>常见挑战</strong>：只想保质按量地去完成工作的思维惯性；技术是技术、业务是业务，“技术人员不需要懂业务”的自我设限；</li><li><p><strong>突破之道</strong>：</p><ul><li>通过培养系统思维，尝试去洞悉需求或者任务它为什么会存在？解决了什么问题？服务于哪个业务目标？带来了什么价值？</li><li>熟悉业务的流程，主动地去了解工作和业务的上下游，建立“端到端”视野，确保从需求的提出到用户的反馈整个的全链路都理解到位的</li><li>培养价值导向，学习基础项目管理与优先级判断（如MoSCoW法则），理解“做什么”比“怎么做”更重要</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433438" alt="个人突破" title="个人突破" loading="lazy"/></p><h2>第二层：流程优化者</h2><h3>2.1 表现特征：</h3><ul><li>建立并优化开发流程（如CI/CD、代码规范、测试覆盖率）</li><li>关注团队效率、质量与稳定性（如人效、BUG数量、线上故障次数等）</li><li>能识别重复性问题并推动标准化（如基础设施、公共类库、代码规范、测试用例、系统文档等）</li><li>开始关注技术债与长期可维护性（如遗留问题、代码质量、架构优化、文档更新等）</li></ul><h3>2.2 本质洞察：</h3><ul><li>价值 = 提升组织效能的引擎 = 流程效率 × 团队能力</li><li>认知模式：知道要关注整体而非局部这样的系统性思维、有优化做事方式面向过程的意识导向</li><li>心理底层：有追求最佳实践、持续地改进系统和流程的效率导向</li></ul><p><strong>阶段的总结：不仅会“做对事”，还能让“做事的方式更高效、可持续”。本质上是从“个人贡献者”到“组织赋能者”的角色转变，通过优化系统和流程来放大团队整体价值。</strong></p><h3>2.3 跃升的挑战与突破之道：</h3><ul><li><strong>常见挑战</strong>：流程的优化遇到组织上的阻力而无法实施或者进度很慢；忽视人的因素让流程脱离了实际的工作场景，导致效率低下；错误地或者过度地优化导致系统和流程反而变成了阻碍企业发展的绊脚石。</li><li><p><strong>突破之道</strong>：</p><ul><li>学习和应用DevOps、敏捷开发、精益创业、SRE等方法论，但更重要的是“合适”而非“照搬”</li><li>引入数据驱动决策（如A/B测试、部署频率、MTTR、故障率等），用数据证明技术团队的价值</li><li>培养横向的领导力：在没有直接权力的情况下，通过个人和团队的影响力推动跨团队流程与目标的对齐</li><li>关注“人-流程-技术”的三角平衡，避免为了流程而流程</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433439" alt="流程驱动" title="流程驱动" loading="lazy"/></p><h2>第三层：技术战略家</h2><h3>3.1 表现特征：</h3><ul><li>能将技术选择与公司战略对齐，如微服务架构升级、云原生转、AI能力建设等</li><li>可以预判未来3–5年的技术发展趋势和技术栈演进的路径，并提前布局</li><li>通过把控短期功能交付与长期架构优化的平衡点，保证系统长期的可维护性和可扩展性</li></ul><h3>3.2 本质洞察：</h3><ul><li>价值 = 用技术驱动来业务增长的杠杆 = 技术能力 × 战略协同性</li><li>认知模式：以战略思维为主，能保持长期投入的视角和取舍的意识；有技术为业务服务的商业导向</li><li>心理底层：有平衡确定性与不确定性，打造团队和产品的反脆弱性的风险导向</li></ul><p><strong>阶段的总结：技术不再是成本中心，而是差异化竞争力的来源。本质上是从“效率优化者”到“价值创造者”的转变，通过技术战略的制定与执行，直接影响公司的业务边界与竞争优势。</strong></p><h3>3.3 跃升的挑战与突破之道：</h3><ul><li><strong>常见挑战</strong>：技术战略与业务战略的脱节、短期业绩压力与长期技术投资的冲突、技术趋势判断失误、“技术的自嗨”（为了技术而技术）</li><li><p><strong>突破之道</strong>：</p><ul><li>深入去理解公司的商业模式与竞争格局，搞清楚“公司为客户提供了什么价值？靠什么来赚钱？”、“我们的竞争对手有哪些？核心竞争力是什么？”</li><li>建立技术雷达机制，重点关注那些与公司战略高度相关的技术趋势和解决方案，并提前布局</li><li>与产品、市场、财务等部门建立战略对话，善于用“业务语言”来跟业务部门沟通，而非用“技术语言”</li><li>学会“拆目标”和“讲故事”，能将业务和架构决策转化为可量化的商业价值（如ROI、市场份额提升、成本节约）</li><li>掌握“战略取舍”的艺术，谨记战术上的努力永远弥补不了战略上的懒惰，选择比努力更重要，技术投入不是什么都做，而是要选择做对公司最关键的</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433440" alt="角色转变" title="角色转变" loading="lazy"/></p><h2>第四层：业务共创者</h2><h3>4.1 表现特征：</h3><ul><li>与CEO、CFO、COO、CMO共同定义新产品方向或商业模式</li><li>通过技术创新开辟新市场（如用大模型重构业务系统改变行业格局、构建AI数字员工来对行业进行降维打击、对系统业务和功能进行扩展与升级来开辟新市场等）</li><li>构建技术文化，打造技术IP、吸引顶尖人才，重塑组织DNA</li><li>在董事会层面参与战略制定，影响公司未来</li></ul><h3>4.2 本质洞察：</h3><ul><li>价值 = 企业未来的共同缔造者 = 技术创新 × 商业想象力 × 生态影响力</li><li>认知模式：有全局视角、网络效应的生态化思维；以及创造新可能新机会这样面向未来的导向</li><li>心理底层：有超越个人与团队，为组织创造长期价值的使命导向</li></ul><p><strong>阶段的总结：技术负责人已超越“支持角色”，成为企业创新的核心驱动力。本质上是从“价值创造者”到“价值定义者”的转变，通过技术与商业的深度融合，重新定义公司的业务边界与成长空间。</strong></p><h3>4.3 跃升的挑战与突破之道：</h3><ul><li><strong>常见挑战</strong>：无法跨越融合技术与商业这个认知的鸿沟、平衡不了技术与业务创新跟风险之间的矛盾、无法去突破组织的惯性与利益的格局</li><li><p><strong>突破之道</strong>：</p><ul><li>培养对商业的直觉与洞察力，主动走出技术的舒适区，成为“最懂技术的业务专家”或“最懂业务的技术专家”</li><li>构建个人和团队的“π型”能力，打造纵向技术深度 + 横向商业广度 + 斜向跨领域连接的能力</li><li>建立与外部的生态连接，通过开源社区、技术论坛、产业联盟等渠道来获取前沿的洞见与资源</li><li>敢于面对各种的不确定性，在混沌中去寻找新的机会，把“impossible”变成“i'm possible”</li><li>塑造开放的技术文化，将创新的基因注入到组织的DNA里面，让技术驱动成为全员的共识</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433441" alt="突破认知" title="突破认知" loading="lazy"/></p><h2>最后总结</h2><h3>5.1 价值跃迁的本质：从“被业务驱动”到“驱动业务”</h3><table><thead><tr><th>层级</th><th>核心问题</th><th>思维转变</th><th>价值点</th><th>认知模式进化</th></tr></thead><tbody><tr><td>1 → 2</td><td>"怎么做更快更好？"</td><td>从个体效率到系统效率</td><td>效率提升</td><td>线性思维 → 系统思维</td></tr><tr><td>2 → 3</td><td>"为什么是做这个？而不是不做那个？"</td><td>从流程优化到战略取舍</td><td>业务价值创造</td><td>过程导向 → 结果导向</td></tr><tr><td>3 → 4</td><td>"我们还能创造什么新可能？"</td><td>从支撑业务到定义未来</td><td>生态价值创新</td><td>战略思维 → 生态思维</td></tr></tbody></table><h3>5.2 价值层次与组织发展的动态匹配</h3><ul><li><strong>创业期</strong>：考验的是企业快速交付、建立基础的能力，此时最需要“任务执行者”和“流程优化者”</li><li><strong>成长期</strong>：看重的是提升效率、支持业务扩张，此时更需要“流程优化者”和“技术战略家”</li><li><strong>成熟期</strong>：主打创新突破、寻找新增长点，此时更需要“技术战略家”和“业务共创者”</li><li><strong>转型期</strong>：需要重新定义业务边界、引领组织变革，此时最需要“业务共创者”</li></ul><p><strong>个人洞察</strong>：没有说哪个层次是绝对“最好”的价值层次，只有“最适合”组织当前阶段的角色。优秀的技术负责人都会根据组织的需求和挑战，灵活地调整自己价值和角色的定位。</p><h3>5.3 AI时代对技术负责人的新要求</h3><p>在大模型等AI技术爆发的时代，技术负责人面临着全新的挑战与机遇：</p><ul><li><strong>技术能力重构</strong>：从“编写代码”到“训练模型、设计提示词、构建AI系统”</li><li><strong>价值创造方式变革</strong>：AI将成为新的生产工具，技术负责人需要重新定义“技术价值”</li><li><strong>组织形态演进</strong>：AI辅助开发将改变团队结构，技术负责人需要构建“人机协同”的工作模式</li><li><strong>伦理与治理责任</strong>：AI带来的风险（如数据安全、算法偏见）要求技术负责人承担更多的治理责任</li></ul><h3>5.4 给技术负责人的终极建议：</h3><ul><li><strong>定期自我审视</strong>：每6个月问自己三个问题：“我当前的价值层次是什么？”、“组织需要我处于哪个层次？”、“我如何向更高层次跃迁？”</li><li><strong>用业务结果衡量技术价值</strong>：上线不是终点，用户增长、体验提升、成本下降、创新突破才是技术价值的最终体现</li><li><strong>构建“π型能力”</strong>：纵向技术深度 + 横向商业广度 + 斜向跨领域连接能力，成为企业“技术与商业的桥梁”</li><li><strong>培养“战略耐心”</strong>：价值跃迁不是一蹴而就的，需要在每个层次里面进行深耕，稳扎稳打的复利会让你向上突破，剩下的就交给时间吧</li><li><strong>成为“价值放大器”</strong>：不仅要自己去创造价值，更要通过团队、流程、生态来放大价值</li></ul><p>在今天的数字时代，技术负责人的最高价值在于：<strong>用技术重塑商业逻辑，用创新定义组织未来</strong>。通过不断地突破自身的价值层级，你将成为企业的“第二大脑”和“第一生产力”，真正实现从技术管理者到战略决策者的华丽转身。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047433442" alt="技术创新" title="技术创新" loading="lazy"/></p><hr/><p><strong>互动话题</strong>：作为一个技术负责人，你认为自己当前处于哪个价值层次？你计划如何向更高层次升级？欢迎在评论区分享你的思考与实践！<br/><strong>下篇预告</strong>：作为一个技术负责人，该如何给团队赋能呢？赋能的级别有哪些呢？敬请期待！</p><h2>关于作者</h2><p>Kenyon，资深软件架构师，15年的软件开发和技术管理经验，从程序员做到企业技术高管。多年企业数字化转型和软件架构设计经验，善于帮助企业构建高质量、可维护的软件系统，目前专注技术管理、架构设计、AI技术应用和落地；全网统一名称“六边形架构”，欢迎关注交流。</p><p><em>原创不易，转载请联系授权，如果觉得有帮助，请点赞、收藏、转发三连支持！</em></p>]]></description></item><item>    <title><![CDATA[从零开始：用Python和Gemini ]]></title>    <link>https://segmentfault.com/a/1190000047433451</link>    <guid>https://segmentfault.com/a/1190000047433451</guid>    <pubDate>2025-11-27 22:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>很多人第一次看到 AI Agent 自己编辑文件、跑代码、修 bug，还能一直运行下去的时候,都觉得挺神奇。其实远没有想象中那么复杂。这里没什么秘密算法,也没有什么"智能体大脑"这种玄学概念。</p><p>AI Agent核心就三件事：<strong>循环 + LLM + 工具函数</strong>。</p><p>如果你会写个</p><pre><code>while True</code></pre><p>循环？那基本就算成功一半了。</p><p>这篇文章会完整展示怎么用 Gemini 3 搭一个真正能用的 Agent：从最基础的 API 调用,到一个能读写文件、理解需求的命令行助手。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047433453" alt="" title=""/></p><h2>Agent 到底是什么</h2><p>传统程序就是流程图那一套：步骤 A → 步骤 B → 步骤 C → 结束。</p><p>而Agent 不一样,它会根据当前状况决定下一步干什么。可以理解成围绕 LLM 搭的一个小系统,比如说：</p><ul><li>规划任务</li><li>执行操作</li><li>根据结果调整</li><li>循环往复直到搞定</li></ul><p>所以不是写死的脚本,更像是个会思考的循环。</p><p>不管多复杂的 Agent,都逃不开这四个部分：</p><p>1、模型 负责思考</p><p>这里用的是 <strong>Gemini 3 Pro</strong>。它可以分析用户需求,决定接下来该做什么。</p><p>2、工具 负责执行</p><p>就是一堆函数：读文件、列目录、发邮件、调 API...想加什么加什么。</p><p>3、上下文工作记忆</p><p>模型当前能看到的所有信息，怎么管理这块内容,业内叫 <strong>Context Engineering</strong>。</p><p>4、循环 运转机制</p><p>观察 → 思考 → 行动 → 重复,一直到任务完成。</p><p>就这么四块,没别的了。</p><h2>循环的运行逻辑</h2><p>几乎所有 Agent 都是这个流程：</p><p>先把可用的工具描述给模型看,然后把用户请求和工具定义一起发给模型。模型会做决策：要么直接回复,要么调用某个工具并传参数。</p><p>但是你要写代码负责在 Python 里执行这个工具。</p><p>执行完把结果喂回给 Gemini。</p><p>模型拿到新信息后继续判断下一步。</p><p>就这样循环,直到模型觉得任务完成了。</p><p>下面我们开始写：</p><p><strong>第一步：基础聊天机器人</strong></p><p>先写个 Gemini 3 API 的简单封装 ，其实就是个能记住对话的类。</p><pre><code> from google import genai  
from google.genai import types  
   
class Agent:  
    def __init__(self, model: str):  
        self.model = model  
        self.client = genai.Client()  
        self.contents = []  
   
    def run(self, contents: str):  
        self.contents.append({"role": "user", "parts": [{"text": contents}]})  
   
        response = self.client.models.generate_content(  
            model=self.model,  
            contents=self.contents  
        )  
   
        self.contents.append(response.candidates[0].content)  
        return response  
   
agent = Agent(model="gemini-3-pro-preview")  

response1 = agent.run(  
    "Hello, what are the top 3 cities in Germany to visit? Only return the names."  
)  
 print(response1.text)</code></pre><p>上面代码能跑,但是就是个聊天机器人。它啥也干不了,因为没有"手"。</p><p><strong>第二步：加入工具函数</strong></p><p>工具其实就是 Python 函数 + 一段 JSON schema 描述。描述是给 Gemini 看的,让它知道这个函数能干啥。</p><p>这里加三个简单的：</p><ul><li><code>read_file</code> - 读文件</li><li><code>write_file</code> - 写文件</li><li><code>list_dir</code> - 列目录</li></ul><p>先写定义：</p><pre><code> read_file_definition = {  
    "name": "read_file",  
    "description": "Reads a file and returns its contents.",  
    "parameters": {  
        "type": "object",  
        "properties": {  
            "file_path": {"type": "string"}  
        },  
        "required": ["file_path"],  
    },  
}  
   
list_dir_definition = {  
    "name": "list_dir",  
    "description": "Lists the files in a directory.",  
    "parameters": {  
        "type": "object",  
        "properties": {  
            "directory_path": {"type": "string"}  
        },  
        "required": ["directory_path"],  
    },  
}  
   
write_file_definition = {  
    "name": "write_file",  
    "description": "Writes contents to a file.",  
    "parameters": {  
        "type": "object",  
        "properties": {  
            "file_path": {"type": "string"},  
            "contents": {"type": "string"},  
        },  
        "required": ["file_path", "contents"],  
    },  
 }</code></pre><p>然后是实际的 Python 实现：</p><pre><code> def read_file(file_path: str) -&gt; dict:  
    with open(file_path, "r") as f:  
        return f.read()  
   
def write_file(file_path: str, contents: str) -&gt; bool:  
    with open(file_path, "w") as f:  
        f.write(contents)  
    return True  
   
def list_dir(directory_path: str) -&gt; list[str]:  
     return os.listdir(directory_path)</code></pre><p>打包一下就搞定了：</p><pre><code> file_tools = {  
     "read_file": {"definition": read_file_definition, "function": read_file},  
     "write_file": {"definition": write_file_definition, "function": write_file},  
     "list_dir": {"definition": list_dir_definition, "function": list_dir},  
 }</code></pre><p><strong>第三步：真正的 Agent</strong></p><p>现在把 Agent 类扩展一下,让它能：</p><ul><li>识别工具调用</li><li>在 Python 里执行对应的函数</li><li>把结果传回 Gemini</li><li>继续循环直到完成</li></ul><pre><code> class Agent:  
    def __init__(self, model: str, tools: dict,   
                 system_instruction="You are a helpful assistant."):  
        self.model = model  
        self.client = genai.Client()  
        self.contents = []  
        self.tools = tools  
        self.system_instruction = system_instruction  
   
    def run(self, contents):  
        # Add user input to history  
        if isinstance(contents, list):  
            self.contents.append({"role": "user", "parts": contents})  
        else:  
            self.contents.append({"role": "user", "parts": [{"text": contents}]})  
   
        config = types.GenerateContentConfig(  
            system_instruction=self.system_instruction,  
            tools=[types.Tool(  
                function_declarations=[  
                    tool["definition"] for tool in self.tools.values()  
                ]  
            )],  
        )  
   
        response = self.client.models.generate_content(  
            model=self.model,  
            contents=self.contents,  
            config=config  
        )  
   
        # Save model output  
        self.contents.append(response.candidates[0].content)  
   
        # If model wants to call tools  
        if response.function_calls:  
            functions_response_parts = []  
   
            for tool_call in response.function_calls:  
                print(f"[Function Call] {tool_call}")  
   
                if tool_call.name in self.tools:  
                    result = {"result": self.tools[tool_call.name]["function"](**tool_call.args)}  
                else:  
                    result = {"error": "Tool not found"}  
   
                print(f"[Function Response] {result}")  
   
                functions_response_parts.append(  
                    {"functionResponse": {"name": tool_call.name, "response": result}}  
                )  
   
            # Feed tool results back to the model  
            return self.run(functions_response_parts)  
          
         return response</code></pre><p>这样就可以跑一下试试了：</p><pre><code> agent = Agent(  
    model="gemini-3-pro-preview",  
    tools=file_tools,  
    system_instruction="You are a helpful Coding Assistant. Respond like Linus Torvalds."  
)  

response = agent.run("Can you list my files in the current directory?")  
 print(response.text)</code></pre><p>如果没问题,Gemini 会调工具,拿到结果,然后给出最终回复。</p><p>到这一步,一个能用的 Agent 就搭好了。</p><p><strong>第四步：包装成命令行工具</strong></p><p>最后我们在再套个输入循环就行：</p><pre><code> agent = Agent(  
    model="gemini-3-pro-preview",  
    tools=file_tools,  
    system_instruction="You are a helpful Coding Assistant. Respond like Linus Torvalds."  
)  
   
print("Agent ready. Type something (or 'exit').")  
while True:  
    user_input = input("You: ")  
    if user_input.lower() in ['exit', 'quit']:  
        break  
   
    response = agent.run(user_input)  
     print("Linus:", response.text, "\n")</code></pre><p>代码很少但是效果已经相当不错了。</p><h2>总结</h2><p>搭 Agent 一开始看着挺唬人,但理解了结构之后,会发现简单得有点无聊。往简单了说，它就是个循环。一个里面跑着聪明模型的循环。明白这点之后,你就能造出看起来"有生命"的 Agent 了。</p><p>如果想继续扩展的话,可以加这些：</p><p>网络搜索、数据库查询、执行 shell 命令、调用云服务、长期记忆、工作流编排、任务调度、多步规划...</p><p>但不管怎么加,底层还是那个简单结构：</p><p><strong>观察 → 思考 → 行动 → 重复</strong></p><p><a href="https://link.segmentfault.com/?enc=j6n2nVzHTiS7rlgqwYkXsA%3D%3D.YD3KGGOz%2Bqb6YpRytOnNN8uhFyl0OfwpV%2Fa%2BKkY9ripdVw9BY5tKDZgEMizf0sEFaLBXbgsuDE4yXPwXAadJiA%3D%3D" rel="nofollow" target="_blank">https://avoid.overfit.cn/post/67cef1690eb14d2fb3ecc0ff7bdf91f8</a></p><p>这就是现代 Agent 的核心。</p>]]></description></item><item>    <title><![CDATA[TinyEngine低代码多人实时协作“]]></title>    <link>https://segmentfault.com/a/1190000047433402</link>    <guid>https://segmentfault.com/a/1190000047433402</guid>    <pubDate>2025-11-27 21:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文由周天意同学原创。</p><p>一般的多人协作业务需求一般是针对文档，表格或者是制图之类的，场景比较简单，协同操作的对象为文字或者图片，对象比较单一。<br/>乍一看低代码的多人协作看似无从下手，因为低代码不仅涉及到页面 canvas 中一些文字属性的同步，还涉及到<strong>组件拖拽，样式，绑定事件，高级属性，甚至是代码协同编辑</strong>的编辑与同步。那我们是如何在低代码这个场景下实现多人协同编辑的呢。</p><h2>TinyEngine低代码引擎多人协同技术详解</h2><h3>CRDT</h3><p>我们首先来介绍一下实现低代码编辑的协同编辑的底层逻辑 —— CRDT（Conflict-free Replicated Data Type，无冲突复制数据类型）是一种<strong>允许并发修改、自动合并且永不冲突的数据结构</strong>。<br/>即使多个用户同时编辑同一份文档、表格或图形，系统也能在之后自动合并出一致的结果，<strong>不需要“锁”或“人工解决冲突”</strong>。</p><h4>一个例子</h4><p>假设你有一个协作文本编辑器有两个用户：<br/>A    插入“Hello ”<br/>B    插入“World!”</p><p>在普通系统中，如果两个操作几乎同时发生，可能导致冲突（比如：谁的改动算数？）。但在 CRDT 模型下，每个操作都是可合并的：系统会基于操作的逻辑时间或唯一标识符自动确定合并顺序；最终所有节点都会收敛到相同的状态，比如 "Hello World!"。</p><h4>CRDT 的两种主要类型</h4><ol><li>State-based（状态型 CRDT）<br/>每个节点维护完整的状态副本，并定期将状态合并：<br/>local_state = merge(local_state, remote_state)</li><li>Operation-based（操作型 CRDT）<br/>每个节点只传播“操作”，比如“加1”“插入字符X”，<br/>其他节点按相同逻辑执行该操作。</li></ol><p>在我们的项目中，我们采用的是 <strong>操作型 CRDT（Operation-based CRDT）库 Yjs</strong>。<br/>在 Yjs 中，每个协同文档对应一个<strong>根对象 Y.Doc</strong>，它可以包含多种可协同的数据结构，例如 <strong>Y.Array、Y.Map、Y.Text</strong> 等。<strong>每个客户端都维护一份本地的 Y.Doc 副本</strong>，这些副本通过 Yjs 的同步机制保持一致。<br/>当多个客户端通过 y-websocket provider 连接到同一个房间（room）时，它们会共享相同的文档数据。<strong>任何客户端对文档的修改（如插入、删除、更新）都会被编码为操作（operation）</strong>，并广播到其他客户端，从而实现实时的数据同步。</p><h3>从数据结构到协同模型：tiny-engine 的页面 Schema 与 Yjs 的结合</h3><p>通过前面的讨论我们可以发现，无论是哪一种类型的 <strong>CRDT（Conflict-free Replicated Data Type）</strong>，其核心都离不开一个<strong>健全且完备的数据结构</strong>。<br/>对于我们的 <strong>tiny-engine</strong> 来说，低代码页面本身也是由一套结构化的数据所描述的。<br/>这套数据结构不仅要支持页面的层级关系（如区块、组件、插槽），还要能够表达页面的动态逻辑（如循环、条件、生命周期、数据源等）。</p><p>在 tiny-engine 中，页面的基础结构可以抽象为以下两个 TypeScript 接口：</p><pre><code class="ts">// 节点类型
export interface Node {
  id: string
  componentName: string
  props: Record&lt;string, any&gt; &amp; { columns?: { slots?: Record&lt;string, any&gt; }[] }
  children?: Node[]
  componentType?: 'Block' | 'PageStart' | 'PageSection'
  slot?: string | Record&lt;string, any&gt;
  params?: string[]
  loop?: Record&lt;string, any&gt;
  loopArgs?: string[]
  condition?: boolean | Record&lt;string, any&gt;
}
  
// 根节点类型，即页面 Schema
export type RootNode = Omit&lt;Node, 'id'&gt; &amp; {
  id?: string
  css?: string
  fileName?: string
  methods?: Record&lt;string, any&gt;
  state?: Record&lt;string, any&gt;
  lifeCycles?: Record&lt;string, any&gt;
  dataSource?: any
  bridge?: any
  inputs?: any[]
  outputs?: any[]
  schema?: any
}</code></pre><p>我们可以把它理解为：</p><ul><li><strong>Node</strong> 代表页面中的一个通用组件节点；</li><li><strong>RootNode</strong> 则是整个页面的根节点（Schema），在 Node 的基础上扩展了页面级的属性，如 <code>state</code>、<code>methods</code>、<code>lifeCycles</code> 等。</li></ul><h3>从数据结构到协同对象</h3><p>在使用 <strong>CRDT（这里是 <a href="https://link.segmentfault.com/?enc=FfE3%2F7RqXaJ3x%2BWNTic0qg%3D%3D.aLf%2Be3UrTMolch54dGqPz3Ws25%2BbGg5N9kocBspElfU%3D" rel="nofollow" target="_blank">Yjs</a>）</strong> 进行实时协作时，我们的“协作单元”就是上述的这类数据结构。换句话说，Yjs 需要在内部维护一份与 <code>RootNode</code> 对应的共享状态副本。</p><p>然而，Yjs 并不能直接理解复杂的 TypeScript 对象结构，我们需要将其<strong>转化为 Yjs 能够识别和同步的类型系统</strong>。<br/>例如：</p><ul><li>普通对象 → <code>Y.Map</code></li><li>数组 → <code>Y.Array</code></li><li>字符串、数字、布尔值 → <code>Y.Text</code> / 基本类型</li><li>嵌套结构（如 children）则需要递归地转化为嵌套的 Y 类型。</li></ul><p>因此，我们的第一步工作是：</p><blockquote>根据已有的 <code>Node</code> 和 <code>RootNode</code> 数据结构，将其映射为等价的 Yjs 类型（如 Y.Map、Y.Array 等）。</blockquote><p>这一过程可以抽象为一个通用的 “schema → YDoc” 转换函数。项目中：</p><pre><code class="ts">const UNDEFINED_PLACEHOLDER = '__undefined__'
  
/**
 * 将普通对象/数组递归转换成 Yjs 对象
 * @param target Y.Map 或 Y.Array
 * @param obj 要转换的对象
 */
// toYjs 函数优化后的版本
  
export function toYjs(target: Y.Map&lt;any&gt; | Y.Array&lt;any&gt;, obj: any) {
  if (Array.isArray(obj)) {
    if (!(target instanceof Y.Array)) {
      throw new Error('Expected Y.Array as target for array input')
    }
    obj.forEach((item) =&gt; {
      if (item === undefined) {
        target.push([UNDEFINED_PLACEHOLDER])
      } else if (item === null) {
        target.push([null])
      } else if (Array.isArray(item)) {
        const childArr = new Y.Array()
        toYjs(childArr, item)
        target.push([childArr])
      } else if (typeof item === 'object' &amp;&amp; item !== null) {
        // 明确排除 null
        const childMap = new Y.Map()
        toYjs(childMap, item)
        target.push([childMap])
      } else {
        target.push([item])
      }
    })
  } else if (typeof obj === 'object' &amp;&amp; obj !== null) {
    if (!(target instanceof Y.Map)) {
      throw new Error('Expected Y.Map as target for object input')
    }
    Object.entries(obj).forEach(([key, val]) =&gt; {
      if (val === undefined) {
        target.set(key, UNDEFINED_PLACEHOLDER)
      } else if (val === null) {
        target.set(key, null)
      } else if (Array.isArray(val)) {
        const yArr = new Y.Array()
        target.set(key, yArr)
        toYjs(yArr, val)
      } else if (typeof val === 'object' &amp;&amp; val !== null) {
        // 明确排除 null
        const yMap = new Y.Map()
        target.set(key, yMap)
        toYjs(yMap, val)
      } else {
        target.set(key, val)
      }
    })
  }
  // 注意：如果 obj 不是对象或数组（如 string, number），函数将静默地不做任何事。这是符合预期的。
}
  
// 将 Yjs Map 转回普通对象（递归）
export function fromYjs(value: any): any {
  if (value instanceof Y.Map) {
    const obj: any = {}
    value.forEach((v, k) =&gt; {
      obj[k] = fromYjs(v)
    })
    return obj
  } else if (value instanceof Y.Array) {
    return value.toArray().map((item) =&gt; fromYjs(item))
  } else if (value instanceof Y.Text) {
    return value.toString()
  } else if (value === UNDEFINED_PLACEHOLDER) {
    return undefined // 还原 undefined
  } else {
    return value
  }
}</code></pre><p>这样，当我们通过 Yjs 对这些 Y 类型进行修改（例如修改 props、插入/删除 children、更新 state），Yjs 就会自动维护 CRDT 冲突合并逻辑，并将变更同步到所有协作客户端。</p><h3>监听机制实现 —— 从 Yjs 变更到多人协同视图更新</h3><p>前面的步骤成功让我们借助 <strong>Yjs</strong> 实现了数据层面的实时同步：<br/>无论是哪位协作者修改了页面中的某个节点、属性或层级结构，这些变更都能被同步传播到所有客户端。</p><p>但是，仅仅让数据“同步”还不够。<br/>在 <strong>tiny-engine</strong> 中，页面渲染与编辑的核心状态仍然依赖于本地的 <strong>Schema</strong>（即 <code>RootNode</code> 和 <code>Node</code> 的结构树）。<br/>换句话说：</p><blockquote>Yjs 负责维护协作的共享状态，但页面的实际渲染与交互仍是基于本地内存中的 Schema。</blockquote><p>因此，我们必须建立一套监听机制，让 Yjs 的变更<strong>能够驱动 Schema 与视图的更新</strong>，形成如下的完整同步链路：</p><pre><code>Yjs 数据变化 → 更新本地 Schema → 触发渲染引擎刷新视图</code></pre><p>非常好 👍，你这里实际上引出了多人协同中最关键的一个设计点——<strong>“操作意图层”和“数据层”的解耦”</strong>。<br/>你的思路已经非常正确：用事件总线处理结构性变更（如节点插入/删除），用 meta 元数据追踪属性变更。下面我帮你把这一节内容完整、系统地扩写成技术博客风格，同时保留你的原始语义与工程感。👇</p><h4>实现思路：Yjs observe 机制</h4><p>Yjs 为我们提供了非常强大的变更监听机制：</p><ul><li><strong><code>observe</code></strong>：监听单个 <code>Y.Map</code> 或 <code>Y.Array</code> 的变更；</li><li><strong><code>observeDeep</code></strong>：递归监听整个文档中的所有嵌套结构（常用于复杂 Schema）。</li></ul><p>通过这些监听器，我们可以捕获到所有节点层面的增删改事件（包括 props、children 等），然后将这些变化<strong>同步回本地 Schema</strong>。</p><h4>问题：结构性操作缺乏语义信息</h4><p>在理论上，<code>observe</code> 能告诉我们「有节点被插入」，但在实际业务逻辑中，这个信息远远不够。</p><p>以节点插入为例，tiny-engine 中的插入函数如下所示：</p><pre><code class="ts">const insertAfter = ({ parent, node, data }: InsertOptions) =&gt; {
  if (!data.id) {
    data.id = utils.guid()
  }
  
  useCanvas().operateNode({
    type: 'insert',
    parentId: parent.id || '',
    newNodeData: data,
    position: 'after',
    referTargetNodeId: node.id
  })
}</code></pre><p>可以看到，<strong>插入一个节点</strong>不仅仅是向 children 数组中多 push 一个元素，而是依赖一系列上下文信息：</p><ul><li>插入到哪个父节点（<code>parentId</code>）；</li><li>相对哪个参考节点（<code>referTargetNodeId</code>）；</li><li>插入位置（<code>position</code>：before/after/append 等）；</li></ul><p>但是在 Yjs 的底层结构中，这些上下文信息在同步时都会<strong>丢失</strong>。<br/>我们只会收到一条 “<code>children</code> 数组新增了一个元素” 的事件：</p><pre><code class="ts">event.changes.added // =&gt; [Y.Map({ id: 'new-node-id', ... })]</code></pre><p>这时我们无法推断出节点是“如何插入”的，也就无法还原编辑器层面的真实操作。<br/>换句话说，<strong>Yjs 提供了数据变化的结果，但我们需要的是操作的意图</strong>。</p><h4>解决方案：事件总线 + meta 元数据</h4><p>为了解决这一问题，我们在架构中引入了两个关键机制：</p><table><thead><tr><th>机制</th><th>主要负责</th><th>作用范围</th></tr></thead><tbody><tr><td><strong>事件总线（Event Bus）</strong></td><td>传播节点级操作的语义，如新增、删除、移动等</td><td>结构性操作</td></tr><tr><td><strong>Meta 元数据（Metadata）</strong></td><td>描述节点属性、状态等细粒度变化</td><td>属性级操作</td></tr></tbody></table><h4>1. 事件总线：同步操作意图</h4><p>事件总线的设计目标是让每一个“可复现的操作”都能以事件的形式传播到协作层中。</p><p>我们会在 Yjs 文档中专门创建一个 <strong><code>__app_events__</code></strong> 通道，用于通信：</p><pre><code class="ts">// 创建事件通道
const eventsMap = this.yDoc.getMap('__app_events__')
  
// 开启事务保证原子性
this.yDoc.transact(() =&gt; {
  // 在目标节点上设置软删除标志，防止幽灵事件
  targetNode.set('_node_deleted', true)
  
  // 获取事件总线
  const eventsMap = this.yDoc.getMap('__app_events__')
  
  // 准备事件负载
  const eventPayload = {
    op: 'delete',
    deletedNodeId: id,
    // TODO: 可以在负载中包含被删除前的数据，便于远程客户端做一些高级处理（如 "恢复" 功能）
    previousNodeData,
    timestamp: Date.now()
  }
  
  // 使用唯一 ID 发布事件
  const eventId = `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
  eventsMap.set(eventId, eventPayload)
}, 'local-delete-operation')</code></pre><p><strong>监听器设计</strong></p><pre><code class="ts">// 设置一个专门的监听器来处理来自“事件总线”的自定义操作
// 处理无法被 initObserver 监听器很好处理的事件
public setupEventListeners(docName: string): void {
  // 解绑旧的监听器，防止重复
  if (this.eventListeners.has(docName)) {
    const { map, cb } = this.eventListeners.get(docName)
    map.unobserve(cb)
  }
  
  const docManager = DocManager.getInstance()
  const ydoc = docManager.getOrCreateDoc(docName)
  const eventsMap = ydoc.getMap('__app_events__')
  
  const eventCallback = (event: Y.YMapEvent&lt;any&gt;, transaction: Y.Transaction) =&gt; {
    if (transaction.local) return
  
    event.changes.keys.forEach((change, key) =&gt; {
      if (change.action === 'add') {
        const payload: any = eventsMap.get(key)
  
        if (payload &amp;&amp; payload.op === 'move') {
          const patch: DiffPatch = {
            type: 'array-swap',
            parentId: payload.parentId,
            schemaId: payload.schemaId,
            swapId: payload.swapId
          }
          this.applyPatches(docName, [patch])
        } else if (payload &amp;&amp; payload.op === 'insert') {
          const patch: DiffPatch = {
            type: 'array-insert',
            parentId: payload.parentId,
            newNodeData: payload.newNodeData,
            position: payload.position,
            referTargetNodeId: payload.referTargetNodeId
          }
  
          this.applyPatches(docName, [patch])
        } else if (payload &amp;&amp; payload.op === 'delete') {
          const patch: DiffPatch = {
            type: 'array-delete',
            deletedId: payload.deletedNodeId,
            previousNodeData: payload.previousNodeData
          }
  
          this.applyPatches(docName, [patch])
        }
      }
  
      eventsMap.delete(key)
    })
  }
  
  // 绑定监听器
  eventsMap.observe(eventCallback)
  this.eventListeners.set(docName, { map: eventsMap, cb: eventCallback })
}</code></pre><p>这样，每当一个用户在本地执行节点插入或删除操作时：</p><p>a. 编辑器会向事件总线发送一条“操作意图”；<br/>b. 该事件会被同步到 Yjs 的 <code>__app_events__</code>；<br/>c. 所有协作者客户端的监听器收到事件后，调用 <code>operateNode</code> 重放操作；<br/>d. 从而保持逻辑一致性与结构同步。</p><p>这种做法本质上是 <strong>“Yjs 同步结果 + EventBus 同步语义”</strong> 的结合。</p><h4>2. Meta 元数据：追踪节点属性变化</h4><p>而对于节点属性（如 <code>props</code>、<code>style</code>、<code>loop</code>、<code>condition</code> 等）而言，我们并不需要同步操作意图，只需同步最终结果即可。<br/>因此我们在每个节点的 Yjs 表示中增加一份 <strong>meta 元数据</strong>：</p><pre><code class="ts">const yNode = new Y.Map()
yNode.set('meta', new Y.Map({
  lastModifiedBy: userId,
  lastModifiedAt: Date.now(),
  changeType: 'props'
}))</code></pre><p>当属性发生修改时，我们更新对应的 meta 字段，这样协作者就能知道：</p><ul><li>是哪个用户修改的；</li><li>修改了什么部分；</li><li>修改时间等信息。</li></ul><p>并通过 <code>observeDeep</code> 自动捕获变化，实现属性级别的实时同步。</p><p>这种模式下，结构操作（增删节点）和属性操作（节点内部更新）各司其职，不会互相干扰。</p><h4>架构小结</h4><p>通过事件总线与 meta 元数据的结合，我们实现了 Yjs 协同编辑的完整闭环：</p><pre><code>用户操作 → 发布事件（EventBus）
          ↓
     同步到 Yjs (__app_events__)
          ↓
     其他客户端接收 → 重放操作
          ↓
     Schema &amp; 视图更新</code></pre><p>而对于属性更新的路径：</p><pre><code>用户编辑属性 → 更新节点 meta + props
          ↓
     Yjs observeDeep 监听到变化
          ↓
     同步到其他客户端 → 更新本地 Schema
          ↓
     触发视图重绘</code></pre><p>这种分层架构既保持了 <strong>Yjs 的一致性特性</strong>，又补上了协同编辑中至关重要的 <strong>操作语义层</strong>，让多人实时协同真正具备“人理解的上下文逻辑”。</p><p>非常好，这一节正是整个 <strong>反向同步链路（Schema → Yjs）</strong> 的核心部分。下面是经过润色和扩展后的完整博客内容片段，可以直接用于技术文档或博客文章中👇</p><h3>反向同步机制 —— 从 Schema 改动更新 Yjs</h3><p>在前面我们已经介绍了如何通过 Yjs 的变更来驱动本地 Schema 的更新，实现了<strong>“远端 → 本地”</strong> 的同步逻辑。<br/>而这一节要讲的，则是反向过程：<strong>当本地用户操作导致 Schema 发生变化时，如何将这些变更同步到 Yjs 文档，从而广播给其他协作者。</strong></p><h4>基本思路</h4><p>反向同步的核心理念是：</p><blockquote>当本地 Vue 响应式状态（Schema）发生变化时，我们通过 Vue Hook 捕获到变更，并将这些变更同步到 Yjs 的共享结构中。</blockquote><p>这一机制的关键在于对 <strong>操作意图（Operation Intent）</strong> 的捕获，而不是单纯地对数据差异做比对。<br/>也就是说，我们并不是在检测“数据变了多少”，而是在监听“用户执行了什么操作”——比如插入节点、删除节点、修改属性等。</p><h4>添加节点的示例</h4><p>以“添加节点”为例，当用户在编辑器中执行插入操作时，实际的 Schema 改动会通过以下函数完成：</p><pre><code class="ts">export const insertNode = (
  node: { node: Node; parent: Node; data: Node },
  position: PositionType = POSITION.IN,
  select = true
) =&gt; {
  if (!node.parent) {
    insertInner({ node: useCanvas().pageState.pageSchema!, data: node.data }, position)
  } else {
    switch (position) {
      case POSITION.TOP:
      case POSITION.LEFT:
        insertBefore(node)
        break
      case POSITION.BOTTOM:
      case POSITION.RIGHT:
        insertAfter(node)
        break
      case POSITION.IN:
        insertInner(node)
        break
      case POSITION.OUT:
        insertContainer(node)
        break
      case POSITION.REPLACE:
        insertReplace(node)
        break
      default:
        insertInner(node)
        break
    }
  }
  
  if (select) {
    setTimeout(() =&gt; selectNode(node.data.id))
  }
  
  getController().addHistory()
}</code></pre><p>我们重点关注 <code>insertBefore</code> 函数的实现：</p><pre><code class="ts">const insertBefore = ({ parent, node, data }: InsertOptions) =&gt; {
  if (!data.id) {
    data.id = utils.guid()
  }
  
  // 更新本地 Schema
  useCanvas().operateNode({
    type: 'insert',
    parentId: parent.id || '',
    newNodeData: data,
    position: 'before',
    referTargetNodeId: node.id
  })
  
  // 多人协作同步
  useRealtimeCollab().insertSharedNode({ node, parent, data }, POSITION.TOP)
}</code></pre><p>可以看到，当本地 Schema 执行节点插入后，接下来就通过<br/><code>useRealtimeCollab().insertSharedNode(...)</code><br/>来完成与 Yjs 的同步。</p><h4>核心逻辑：<code>insertSharedNode</code></h4><p><code>insertSharedNode</code> 是整个反向同步机制的关键函数，它的主要职责是：</p><ol><li><strong>确定 Yjs 结构中目标位置</strong><br/>通过 <code>parent.id</code> 获取共享文档中对应的 <code>Y.Map</code> 或 <code>Y.Array</code>，找到应插入的目标节点。</li><li><strong>构造 Yjs 节点对象</strong><br/>将本地的 <code>Node</code> 数据结构序列化为对应的 Yjs 类型（<code>Y.Map</code>），并递归地将 <code>props</code>、<code>children</code> 等字段映射为 Yjs 可操作的数据结构。</li><li><strong>执行事务性插入</strong><br/>使用 <code>ydoc.transact()</code> 进行原子操作，保证一次插入在所有协作者中状态一致。</li></ol><p>下面是一个简化后的核心示例逻辑：</p><pre><code class="ts">// 拖拽行为产生的节点插入
public insertNode({ node, parent, data }: InsertOptions, position: PositionType) {
  let insertPos
  let insertPosFinal
  
  if (!parent) {
    this.insert(useCanvas().pageState.pageSchema!.id as string, data, position)
  } else {
    switch (position) {
      case POSITION.TOP:
      case POSITION.LEFT:
        this.insert(parent.id || '', data, 'before', node.id)
        break
      case POSITION.BOTTOM:
      case POSITION.RIGHT:
        this.insert(parent.id || '', data, 'after', node.id)
        break
      case POSITION.IN:
        insertPos = ([POSITION.TOP, POSITION.LEFT] as string[]).includes(position) ? 'before' : 'after'
        this.insert(node.id || '', data, insertPos)
        break
      case POSITION.OUT:
        this.insert(parent.id || '', data, POSITION.OUT, node.id)
        break
      case POSITION.REPLACE:
        this.insert(parent.id || '', data, 'replace', node.id)
        break
      default:
        insertPosFinal = ([POSITION.TOP, POSITION.LEFT] as string[]).includes(position) ? 'before' : 'after'
        this.insert(node.id || '', data, insertPosFinal)
        break
    }
  }
}
  
// insert 操作
private insert(parentId: string, newNodeData: Node, position: string, referTargetNodeId?: string) {
  this.operationHandler.insert({
    type: 'insert',
    parentId,
    newNodeData,
    position,
    referTargetNodeId
  })
}</code></pre><p>其实就相当于重写了 <code>insertNode</code> 来实现 Yjs 的变动</p><h4>Vue Hook 的作用</h4><p>在实际工程中，我们通常会将这类同步逻辑封装在一个组合式 Hook 中，比如：</p><pre><code class="ts">/**
 * useCollabSchema Composable
 * 职责:
 * 1. 整合 Y.Doc (持久化数据) 和 Y.Awareness (瞬时状态) 的同步。
 * 2. 提供对共享文档结构 (Schema) 的增删改 API。
 * 3. 提供对远程用户实时状态的响应式数据和更新 API。
 */
export function useCollabSchema(options: UseCollabSchemaOptions) {
  const { roomId, currentUser } = options
  const { awareness, provider } = useYjs(roomId, { websocketUrl: `ws://localhost:${PORT}` })
  const { remoteStates, updateLocalStateField } = useAwareness&lt;SchemaAwarenessState&gt;(awareness, currentUser)
  
  // 获取 NodeSchemaModel 实例
  const schemaManager = SchemaManager.getInstance()
  const schemaModel = schemaManager.createSchema(roomId, provider.value!)
  
  // 拖拽节点
  const insertSharedNode = (
    node: { node: Node | RootNode; parent: Node | RootNode; data: Node },
    position: PositionType = POSITION.IN
  ) =&gt; {
    // ...上面提到的核心逻辑
  }
  
  // ... 其他核心函数
  
  // 组件卸载时取消监听
  onUnmounted(() =&gt; {
    schemaManager.destroyObserver(roomId)
    provider.value?.off('sync', () =&gt; {})
    // awareness.value?.destroy()
  })
  
  return {
    remoteStates,
    insertSharedNode,
    // ... 其他核心函数
  }
}
  </code></pre><p>这样，任何时候 Schema 层执行了插入、删除、修改等操作，都可以直接通过 <code>useCollabSchema()</code> 来同步到共享文档。</p><h3>总结</h3><p>在整个多人协同体系中，<strong>Yjs 与 Schema 的双向同步机制</strong>是 tiny-engine 协作的核心。</p><ul><li><strong>正向同步（Yjs → Schema）</strong>：<br/>通过 <code>observe</code> 与 <code>observeDeep</code> 监听 Yjs 的数据变更，当远端协作者修改文档时，本地自动更新 Schema，从而触发界面刷新。</li><li><strong>反向同步（Schema → Yjs）</strong>：<br/>通过 Vue Hook 捕获本地用户操作（如插入、删除、修改节点等），再调用封装的 <code>useRealtimeCollab()</code> 方法，将变更同步回 Yjs 文档。</li><li><strong>事件总线与 Meta 元数据</strong>：<br/>用于解决单纯数据变更中无法还原操作意图的问题。事件总线负责节点级别的创建与删除同步，而 Meta 则用于监听属性与状态的更改。</li></ul><p>最终，我们构建出了一条完整的数据同步链路：</p><pre><code>Yjs 改动 → Schema 更新 → 视图刷新
Schema 改动 → Yjs 更新 → 远端同步</code></pre><p>这条链路确保了多人协同环境下的数据一致性与实时响应能力，让每一个编辑动作都能即时地被所有协作者感知与呈现。<br/>它既保证了操作的语义化，也为后续的冲突解决与版本管理打下了坚实的基础。</p><h2>实操上手：</h2><p>接下来，我们将引导您在本地环境中，仅需几条命令，就能启动一个功能完备的协同设计画布，并见证实时同步的“魔法”。</p><h3>预备工作：你的开发环境</h3><p>在开始之前，请确保您的本地环境满足以下条件，这是保证顺利运行的基础：</p><ul><li><p><strong>Node.js</strong>: 版本需 <code>≥ 16</code>。我们推荐使用 <code>nvm</code> 或 <code>fnm</code> 等工具来管理 Node.js 版本，以避免环境冲突。</p><pre><code class="bash"># 检查你的 Node.js 版本
node -v </code></pre></li><li><p><strong>pnpm</strong>: <code>tiny-engine</code> 采用 pnpm 作为包管理器，以充分利用其在 monorepo（多包仓库）项目中的高效依赖管理能力。</p><pre><code class="bash"># 如果尚未安装 pnpm，请运行以下命令
npm install -g pnpm</code></pre></li></ul><h3>第一步：克隆 <code>tiny-engine</code> 源码</h3><p>首先，将 <code>tiny-engine</code> 的官方仓库克隆到您的本地。</p><pre><code class="bash">git clone https://github.com/opentiny/tiny-engine.git
cd tiny-engine</code></pre><p>进入项目目录后，您会发现这是一个结构清晰的 monorepo 项目，所有功能模块（如编辑器核心、物料面板、协作服务等）都作为独立的子包存在于 <code>packages/</code> 目录下。</p><h3>2️⃣ 第二步：安装项目依赖</h3><p>在项目根目录下，执行 <code>pnpm install</code>。pnpm 会智能地解析并安装所有子包的依赖，并建立它们之间的符号链接（symlinks）。</p><pre><code class="bash">pnpm install</code></pre><blockquote><strong>💡 为什么是 pnpm？</strong><br/>在 monorepo 架构中，pnpm 通过其独特的非扁平化 <code>node_modules</code> 结构和内容寻址存储，可以极大地节省磁盘空间，并避免“幻影依赖”问题，保证了开发环境的纯净与一致性。</blockquote><h3>3️⃣ 第三步：启动开发服务，见证奇迹！</h3><p>一切准备就绪，现在只需运行 <code>dev</code> 命令，即可一键启动整个 <code>tiny-engine</code> 开发环境。</p><pre><code class="bash">pnpm dev</code></pre><p>这个命令背后发生了什么？</p><ul><li><p>它会同时启动多个服务，包括：</p><ul><li><strong>Vite 前端开发服务器</strong>: 负责构建和热更新您在浏览器中看到的编辑器界面。</li><li><strong>协作后端服务器 (y-websocket)</strong>: 一个轻量级的 WebSocket 服务器，负责接收、广播和持久化 Y.js 的协同数据。</li></ul></li><li>终端会输出编辑器前端的访问地址，通常默认为 <code>http://localhost:7007</code>（请以您终端的实际输出为准）。</li></ul><h3>4️⃣ 第四步：开启你的“多人协作”剧本</h3><p>现在，是时候扮演不同的协作者了！</p><ol><li><strong>打开第一个窗口</strong>: 在您的浏览器（推荐 Chrome）中打开上一步获取的地址，例如 <code>http://localhost:7007</code>。您会看到 <code>tiny-engine</code> 的低代码设计器界面。这就是我们的<strong>用户A</strong>。</li></ol><p><img width="723" height="420" referrerpolicy="no-referrer" src="/img/bVdnbK0" alt="" title=""/></p><ol start="2"><li><strong>打开第二个窗口</strong>: <strong>打开一个新的浏览器隐身窗口</strong>，或者使用<strong>另一台连接到同一局域网的设备</strong>，再次访问相同的地址。这个窗口将扮演<strong>用户B</strong>。</li><li><p><strong>开始实时协同！</strong>: 将两个窗口并排摆放，现在开始您的表演：</p><ul><li><strong>在用户A的画布上拖入一个按钮组件</strong>。观察用户B的画布，几乎在拖拽完成的瞬间，同样的按钮就会“凭空出现”在相同的位置。</li><li><strong>在用户B的界面上，选中刚刚同步过来的按钮，修改它的“按钮内容”属性</strong>。观察用户A的界面，按钮的文本会实时地、逐字地发生变化。</li><li><strong>在用户A的大纲树面板中，拖拽一个组件来改变其层级结构</strong>。观察用户B的大纲树，节点会立即移动到新的位置。</li><li><strong>在任意一个窗口中，尝试同时操作</strong>。比如，用户A修改组件的颜色，用户B修改其边距。您会发现，由于 CRDT 的特性，所有的修改最终都会被正确合并，达到最终一致的状态，而不会产生冲突或覆盖。</li></ul></li></ol><h3>进阶探索与调试技巧</h3><p>如果您对背后的原理感到好奇，可以尝试以下操作来深入探索：</p><ul><li><strong>查看协同状态</strong>: 打开浏览器的开发者工具，进入 控制台，你会看到相应的协同状态数据</li><li><strong>网络“时光机”</strong>: 在开发者工具的 <code>Network</code> 标签页，筛选 <code>WS</code> (WebSocket) 连接。您可以看到客户端与 <code>y-websocket</code> 服务器之间流动的二进制消息。尝试断开网络再重连，观察 Y.js 是如何利用 CRDT 的能力，在重连后自动同步所有离线期间的变更的。</li><li><strong>扮演“上帝”</strong>: 在控制台中，您可以访问 Y.js 的 <code>doc</code> 和 <code>awareness</code> 实例，尝试手动修改数据或广播自定义状态，来更深入地理解数据驱动的协同模型。</li></ul><p>通过以上步骤，您已经成功在本地完整地体验了 <code>tiny-engine</code> 先进的多人协作能力。这不仅仅是一个功能演示，它背后融合了 <strong>CRDT (Y.js)、实时通信 (WebSocket)、元数据驱动和事件总线</strong> 等一系列现代前端工程化的最佳实践。</p><h2>演示</h2><p><img width="723" height="436" referrerpolicy="no-referrer" src="/img/bVdnbKZ" alt="" title="" loading="lazy"/></p><p>（本项目为开源之夏活动贡献，欢迎大家体验并使用）<br/>源码可参考：<a href="https://link.segmentfault.com/?enc=8JcoUaAaPtZGIRamWJhfhw%3D%3D.%2FX%2BR9MyLvdVmJE7Hs00OVbEYZZCv4clmx7ouh5HAU3Dn5CUI2s3aQplycx8SUfq5Bh4m8zqds8aZZWC%2FfX23QZdEa6Nb%2BwhBcAcz0g6jJC57FSfxVgvewKcCIz%2Fv9f9Q" rel="nofollow" target="_blank">https://github.com/opentiny/tiny-engine/tree/ospp-2025/multiplayer-collaboration</a></p><h2>关于 OpenTiny</h2><p>欢迎加入 OpenTiny 开源社区。添加微信小助手：opentiny-official 一起参与交流前端技术～</p><p><a href="https://link.segmentfault.com/?enc=EFfSFwNLNI3VVkVGy7DcxQ%3D%3D.mrp0UGOuSkmc3R7juDjHV9YevfUdmKoP8Uoeh2HW2qs%3D" rel="nofollow" target="_blank">OpenTiny 官网</a>：<strong><a href="https://link.segmentfault.com/?enc=6X0PpJdnkEi0WWUAROsGLA%3D%3D.%2Fin8LBJC%2B6tZRTRTXM5JHLRbgel59yZb2pnOsPKa0s4%3D" rel="nofollow" target="_blank">https://opentiny.design</a></strong>\<br/><a href="https://link.segmentfault.com/?enc=zpzCOvz%2BdprkQ1H20QhDvg%3D%3D.qCteHm7JhB4NYFa5ZERjA2TzfkLs3gO0yDFaW6oL2Lg%3D" rel="nofollow" target="_blank">OpenTiny 代码仓库</a>：<strong><a href="https://link.segmentfault.com/?enc=ixWDBFeN4oFfmxKDh1inCA%3D%3D.h%2FJhg0bBOrmHPnrl6H%2F19mkrn9Xe3z35Jd8P96mGFD8%3D" rel="nofollow" target="_blank">https://github.com/opentiny</a></strong>\<br/><a href="https://link.segmentfault.com/?enc=4NvtyL9DmYEY885eSKHrfA%3D%3D.4KzgKi%2FB4tPzoYSpcW5hPkRH%2FBpqFE%2Fwm7fdPXw4aEjLV7EDt%2Be4aIj27lQOTXto" rel="nofollow" target="_blank">TinyVue 源码</a>：<strong><a href="https://link.segmentfault.com/?enc=HdgqrBRETac%2BeK9K1Qc8xA%3D%3D.c6l0GqdA5V%2FQWmo9IzhF3JgwPshe8h4ZHQUBZPVQXlAaFiNHgtzXhapOLC8RilUP" rel="nofollow" target="_blank">https://github.com/opentiny/tiny-vue</a></strong>\<br/><a href="https://link.segmentfault.com/?enc=%2FqtTOo11N6UN2OdtNBRkhw%3D%3D.CdxIUSlqqCz2T6TXoKipidz0ejuxPEwUfHb%2Bxd2DTsYk65%2FKQdL1UrIGbgTtRO53" rel="nofollow" target="_blank">TinyEngine 源码</a>： <strong><a href="https://link.segmentfault.com/?enc=QSBLcLOwePGKghh2IhvYzg%3D%3D.pUVtophE%2BKKG%2F%2BpfEmInJu5aovu7iEy%2BAY8rSCR6q011Ybvmis9qFpMaIHFb98z5" rel="nofollow" target="_blank">https://github.com/opentiny/tiny-engine</a></strong>\<br/>欢迎进入代码仓库 Star🌟TinyEngine、TinyVue、TinyNG、TinyCLI、TinyEditor\~<br/>如果你也想要共建，可以进入代码仓库，找到 good first issue 标签，一起参与开源贡献\~</p>]]></description></item><item>    <title><![CDATA[Spring Boot 三层架构解密：从]]></title>    <link>https://segmentfault.com/a/1190000047433302</link>    <guid>https://segmentfault.com/a/1190000047433302</guid>    <pubDate>2025-11-27 20:05:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在构建 Spring Boot 应用时，初学者最容易犯的错误就是把所有的逻辑——参数接收、业务判断、SQL 查询——都塞进一个类里。这种“面条式代码”不仅难以维护，而且充满安全隐患。</p><p>为了解决这个问题，现代后端开发普遍采用 <strong>三层架构 (Three-Tier Architecture)</strong>。这种架构的核心思想是**“各司其职”**。</p><p>今天，我们就来拆解 Controller、Service、Repository 这三大核心组件，并深入探讨 DTO 与 Entity 在这场数据之旅中扮演的关键角色。</p><h2>一、 三大核心角色：各司其职</h2><p>在一个规范的 Spring Boot 项目中，每个请求的处理就像是在餐厅点菜，三个角色配合默契：</p><h3>1. 表现层：Controller (服务员)</h3><ul><li><strong>注解</strong>：<code>@RestController</code></li><li><strong>职责</strong>：<strong>路由 API，只负责“接待”</strong>。</li><li><p><strong>工作内容</strong>：</p><ul><li>监听 HTTP 请求（GET/POST）。</li><li>将前端传来的 JSON 解析为 Java 对象。</li><li>做最基本的参数校验（比如手机号格式对不对）。</li><li><strong>关键原则</strong>：Controller <strong>绝不触碰数据库</strong>，也不写复杂的业务逻辑。它只负责把任务派发给 Service。</li></ul></li><li><strong>比喻</strong>：餐厅的服务员。他负责把菜单递给客人，记下客人点的菜，然后把单子送到后厨。他不会自己去炒菜。</li></ul><h3>2. 业务层：Service (厨师)</h3><ul><li><strong>注解</strong>：<code>@Service</code></li><li><strong>职责</strong>：<strong>核心业务逻辑</strong>。</li><li><p><strong>工作内容</strong>：</p><ul><li>它是整个系统的“大脑”。</li><li>执行业务规则（如：检查余额是否充足、计算折扣、触发报警）。</li><li><strong>数据转换中心</strong>：负责将 DTO 转换为 Entity，或将 Entity 转换为 DTO。</li><li>调用 Repository 获取数据或保存数据。</li></ul></li><li><strong>比喻</strong>：后厨的主厨。他拿到服务员的单子，负责切菜、烹饪、调味。如果缺食材了，他会叫库管去拿。</li></ul><h3>3. 数据层：Repository (库管)</h3><ul><li><strong>注解</strong>：<code>@Repository</code></li><li><strong>职责</strong>：<strong>数据库操作 (CRUD)</strong>。</li><li><p><strong>工作内容</strong>：</p><ul><li>它是系统的“底层”。</li><li>只负责与数据库对话（执行 Insert, Update, Delete, Select）。</li><li>返回的是与数据库表一一对应的 <strong>Entity</strong> 对象。</li></ul></li><li><strong>比喻</strong>：仓库管理员。他不管这道菜是给谁吃的，也不管好不好吃，他只负责把食材（数据）拿出来，或者把成品存进去。</li></ul><hr/><h2>二、 两个数据载体：Entity 与 DTO 的双人舞</h2><p>在三层架构中，数据需要在不同的层级间传递。为什么我们需要两种对象来承载数据？</p><h3>1. Entity (实体对象)</h3><ul><li><strong>定义</strong>：<strong>数据库表的镜像</strong>。</li><li><strong>特征</strong>：类名通常与表名对应，字段与列对应。</li><li><strong>作用</strong>：它是持久化数据的载体。</li><li><strong>局限</strong>：<strong>它是隐私的</strong>。Entity 可能包含“密码”、“盐值”、“逻辑删除标记”等不应该暴露给前端的字段。</li></ul><h3>2. DTO (数据传输对象)</h3><ul><li><strong>定义</strong>：<strong>API 接口的契约</strong>。</li><li><strong>特征</strong>：普通的 POJO，没有任何数据库注解。</li><li><p><strong>作用</strong>：</p><ul><li><strong>安全过滤</strong>：把 Entity 中的敏感字段（如密码）过滤掉。</li><li><strong>数据聚合</strong>：有时一个 API 需要返回两张表的数据（如：用户信息 + 订单概况），DTO 可以把多个 Entity 的数据聚合在一起。</li><li><strong>解耦</strong>：如果数据库表结构变了，只要 DTO 不变，前端就感知不到，保证了接口的稳定性。</li></ul></li></ul><hr/><h2>三、 数据的奇幻漂流：完整流程图解</h2><p>让我们通过“创建数据”和“查询数据”两个场景，看看数据是如何在 JSON、DTO 和 Entity 之间流转的。</p><h3>场景一：创建数据 (Write Flow)</h3><p><strong>任务</strong>：用户注册（前端发送 JSON）。</p><blockquote><strong>流程</strong>：JSON ➡️ Controller ➡️ Service ➡️ Repository ➡️ DB</blockquote><ol><li><p><strong>JSON -\&gt; DTO (Controller 层)</strong></p><ul><li>前端发送 JSON 数据。</li><li>Controller 接收请求，Spring Boot 自动将 JSON 反序列化为 <code>UserCreateDTO</code>。</li></ul></li><li><p><strong>DTO -\&gt; Entity (Service 层)</strong></p><ul><li>Controller 将 <code>UserCreateDTO</code> 传给 Service。</li><li>Service 进行转换（例如使用 MapStruct），将 <code>UserCreateDTO</code> 转化为 <code>UserEntity</code>。</li><li><em>注意：此时 Service 可能会处理密码加密等逻辑。</em></li></ul></li><li><p><strong>Entity -\&gt; DB (Repository 层)</strong></p><ul><li>Service 将 <code>UserEntity</code> 传给 Repository。</li><li>Repository 执行 <code>save(entity)</code>，数据入库。</li></ul></li></ol><h3>场景二：查询数据 (Read Flow)</h3><p><strong>任务</strong>：获取用户详情（返回 JSON）。</p><blockquote><strong>流程</strong>：DB ➡️ Repository ➡️ Service ➡️ Controller ➡️ JSON</blockquote><ol><li><p><strong>DB -\&gt; Entity (Repository 层)</strong></p><ul><li>Repository 根据 ID 从数据库查询数据。</li><li>返回完整的 <code>UserEntity</code>（包含密码字段）。</li></ul></li><li><p><strong>Entity -\&gt; DTO (Service 层)</strong></p><ul><li>Repository 将 <code>UserEntity</code> 传给 Service。</li><li>Service 进行转换，将 <code>UserEntity</code> 转化为 <code>UserResponseDTO</code>。</li><li><em>关键点：在转换过程中，Service 剔除了密码字段，只保留用户名和头像。</em></li></ul></li><li><p><strong>DTO -\&gt; JSON (Controller 层)</strong></p><ul><li>Service 将安全的 <code>UserResponseDTO</code> 返回给 Controller。</li><li>Controller 将其序列化为 JSON，响应给前端。</li></ul></li></ol><hr/><h2>四、 代码实战：这一层层是怎么调用的？</h2><p>为了加深理解，我们来看一段伪代码：</p><pre><code class="java">// 1. Controller: 负责路由和参数接收
@RestController
public class UserController {
    @Autowired
    private UserService userService; // 引用 Service

    @PostMapping("/users")
    public UserResponseDTO createUser(@RequestBody UserCreateDTO dto) {
        // 接收 DTO，传给 Service
        return userService.register(dto);
    }
}

// 2. Service: 负责业务逻辑和转换
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository; // 引用 Repository

    public UserResponseDTO register(UserCreateDTO dto) {
        // 逻辑：DTO 转 Entity
        UserEntity entity = new UserEntity();
        entity.setUsername(dto.getUsername());
        
        // 逻辑：调用 Repository 保存
        userRepository.save(entity);
        
        // 逻辑：Entity 转 DTO (准备返回)
        UserResponseDTO response = new UserResponseDTO();
        response.setId(entity.getId());
        response.setUsername(entity.getUsername());
        return response;
    }
}

// 3. Repository: 负责数据库操作
@Repository
public interface UserRepository extends JpaRepository&lt;UserEntity, Long&gt; {
    // 继承了基本的 save, findById 等方法
}</code></pre><h2>五、 总结</h2><p>Spring Boot 的三层架构就像一个精密运转的工厂：</p><ul><li><strong>Controller</strong> 是 <strong>大门</strong>，负责把原材料（JSON）收进来，变成工单（DTO）。</li><li><strong>Service</strong> 是 <strong>车间</strong>，负责核心加工，它把工单（DTO）变成产品（Entity），或者把产品包装成商品（DTO）。</li><li><strong>Repository</strong> 是 <strong>仓库</strong>，只负责保管产品（Entity）。</li></ul><p>通过这种设计，我们实现了**“外层契约（DTO）”<strong>与</strong>“内层存储（Entity）”**的完美隔离，让代码既安全又易于维护。</p><p>本文由<a href="https://link.segmentfault.com/?enc=gYoag4cmZ4CwtisoIVxnjA%3D%3D.h5Bb9cKz4tuapQiI63D9A86aRbg1fX57MI0F9brqSIk%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[微信小程序云开发 千与千寻 ]]></title>    <link>https://segmentfault.com/a/1190000047433304</link>    <guid>https://segmentfault.com/a/1190000047433304</guid>    <pubDate>2025-11-27 20:05:00</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>package.json<br/>{<br/>  "dependencies": {</p><pre><code>"@vant/weapp": "^1.11.7"</code></pre><p>}<br/>}</p><p>app.wxss<br/>/<em> 引入Vant全部样式 </em>/<br/>@import './miniprogram_npm/@vant/weapp/common/index.wxss';</p><p>app.json<br/>{<br/>  "pages": [</p><pre><code>"pages/index/index",
"pages/user/index"</code></pre><p>],<br/>  "window": {</p><pre><code>"backgroundColor": "#F6F6F6",
"backgroundTextStyle": "light",
"navigationBarBackgroundColor": "#F6F6F6",
"navigationBarTitleText": "云开发 QuickStart",
"navigationBarTextStyle": "black"</code></pre><p>},<br/>  "tabBar": {</p><pre><code>"custom": true,
"color": "#7A7E83",
"selectedColor": "#4A90E2",
"backgroundColor": "#F9F5EB",
"list": [{
  "pagePath": "pages/index/index",
  "text": "首页"
}, {
  "pagePath": "pages/user/index",
  "text": "我的"
}]</code></pre><p>},<br/>  "sitemapLocation": "sitemap.json",<br/>  "lazyCodeLoading": "requiredComponents"<br/>}</p><p>index.js</p><p>onShow() {</p><pre><code>if (typeof this.getTabBar === 'function' &amp;&amp; this.getTabBar()) {
  this.getTabBar().setData({
    selected: 0,
    active: 0
  });
}</code></pre><p>},</p><p>index.json<br/>{<br/>  "navigationBarTitleText": "待办",<br/>  "usingComponents": {</p><pre><code>"cloud-tip-modal": "/components/cloudTipModal/index",
"van-button": "@vant/weapp/button/index",
"van-cell": "@vant/weapp/cell/index",
"van-cell-group": "@vant/weapp/cell-group/index"</code></pre><p>}<br/>}<br/> index.wxml<br/>&lt;!--index.wxml--&gt;<br/>&lt;view class="container"&gt;<br/>  &lt;view class="title"&gt;</p><pre><code>&lt;textarea class="input" placeholder="请输入要添加的待办" /&gt;
&lt;van-button type="info"&gt;添加待办&lt;/van-button&gt;</code></pre><p>&lt;/view&gt;<br/>  &lt;van-cell-group</p><pre><code>inset
wx:key="title"
wx:for="{{powerList}}"
wx:for-item="power"
custom-class="cell-group"</code></pre><pre><code>&lt;van-cell
  title="名称"
  value="{{power.title}}"
  custom-class="my-custom-class" 
  title-class="my-title-class"
  label-class="my-label-class"
  value-class="my-value-class"
/&gt;
&lt;van-cell title="描述" value="" label="{{power.desc}}" /&gt;</code></pre><p>&lt;/van-cell-group&gt;<br/>  &lt;cloud-tip-modal showTipProps="{{showTip}}" title="{{title}}" content="{{content}}" /&gt;<br/>&lt;/view&gt;</p><p>index.wxss<br/>/<strong>index.wxss</strong>/</p><p>page {<br/>  padding-top: 54rpx;<br/>  background-color: #f6f6f6;<br/>  padding-bottom: 60rpx;<br/>}</p><p>.container {<br/>  font-family: PingFang SC;<br/>  background: #f5f5f5;<br/>}</p><p>.title {<br/>  font-family: PingFang SC;<br/>  font-weight: 500;<br/>  color: #000000;<br/>  font-size: 44rpx;<br/>  margin-bottom: 40rpx;<br/>}<br/>.title .input{<br/>  border: 1px solid #ccc;<br/>  border-radius: 4px;<br/>  padding: 10px;<br/>  font-size: 12px;<br/>  font-weight: 100;<br/>  margin-bottom: 20px;<br/>  background: #fff;<br/>}<br/>van-cell-group{<br/>  width: 100%;<br/>  margin-bottom: 10px;<br/>}<br/>.my-value-class{<br/>  color: #333!important;<br/>  font-weight: 400<br/>}</p><p>index1.json<br/>{<br/>  "navigationBarTitleText": "个人信息",<br/>  "usingComponents": {</p><pre><code>"cloud-tip-modal": "/components/cloudTipModal/index",
"van-image": "@vant/weapp/image/index",
"van-cell": "@vant/weapp/cell/index",
"van-cell-group": "@vant/weapp/cell-group/index",
"van-switch": "@vant/weapp/switch/index"</code></pre><p>}<br/>}</p><p>index1.wxml<br/>&lt;!--index.wxml--&gt;<br/>&lt;view class="container"&gt;<br/>  &lt;view class="head"&gt;</p><pre><code>&lt;van-image
  src="/images/top-bgi.png"
  width="10rem"
  height="2rem"
  custom-class="top-bgi-class"
/&gt;
&lt;van-image
  width="10rem"
  height="10rem"
  fit="contain"
  custom-class="user-head-class"
  image-class="head-class"
  src="{{ user.head }}"
/&gt;
&lt;view class="user-info-class"&gt;
  &lt;text class="nickname"&gt;{{ user.nickname }}&lt;/text&gt;
&lt;/view&gt;</code></pre><p>&lt;/view&gt;<br/>  &lt;van-cell-group custom-class="config-list-class"&gt;</p><pre><code>&lt;van-cell
  icon="send-gift"
  title="单元格"
  value="内容"
  label="描述信息"
  custom-class="config-item-class"
  border="{{ false }}"
&gt;
  &lt;van-switch checked="{{ checked }}" bind:change="onChange" /&gt;
&lt;/van-cell&gt;</code></pre><p>&lt;/van-cell-group&gt;<br/>  &lt;cloud-tip-modal showTipProps="{{showTip}}" title="{{title}}" content="{{content}}" /&gt;<br/>&lt;/view&gt;</p><p>index.wxss<br/>/<strong>index.wxss</strong>/</p><p>page {<br/>  padding-top: 54rpx;<br/>  background-color: #f6f6f6;<br/>  padding-bottom: 60rpx;<br/>}</p><p>.container {<br/>  font-family: PingFang SC;<br/>}</p><p>.head{<br/>  width: 100%;<br/>  height: 130px;<br/>  padding: 20px;<br/>  box-sizing: border-box;<br/>  background: linear-gradient(rgb(0 122 234), rgb(60 221 209));<br/>  position: relative;<br/>  text-align: center;<br/>}</p><p>.head-class{<br/>  border-radius: 50%;<br/>  border: 2px solid #ccc;<br/>}</p><p>van-image:first-child{<br/>  position: absolute;<br/>  left: 0;<br/>  bottom: 0;<br/>}</p><p>.user-head-class {<br/>  width: 70px!important;<br/>  height: 70px!important;<br/>  margin: 0 auto;<br/>}</p><p>.user-info-class{<br/>  width: 100%;<br/>}</p><p>.nickname{<br/>  display: block;<br/>  font-size: 18px;<br/>  line-height: 40px;<br/>  color: #fff;<br/>}</p><p>.certify{<br/>  font-size: 12px;<br/>  width: 60px;<br/>  height: 20px;<br/>  line-height: 20px;<br/>  display: inline-block;<br/>  text-align: center;<br/>  border-radius: 10px;<br/>}</p><p>.certified{<br/>  color: #f5c849;<br/>  background-color: #f5c849;<br/>}</p><p>.noCertify{<br/>  color: #c72727;<br/>  background-color: #f5c849;<br/>}</p><p>van-cell-group{<br/>  width: 100%;<br/>  /<em> margin-bottom: 10px; </em>/<br/>}</p><p>.config-list-class{<br/>  width: 94%;<br/>  margin: 0 auto;<br/>}</p><p><img width="125" height="125" referrerpolicy="no-referrer" src="/img/bVdnbAD" alt="" title=""/></p><p><img width="723" height="235" referrerpolicy="no-referrer" src="/img/bVdnbAE" alt="" title="" loading="lazy"/></p><p>custom-tab-bar<br/>index.js<br/>/*</p><ul><li>@Author: wangjingling</li><li>@LastEditTime: 2025-11-27 14:52:16<br/> */</li></ul><p>Page({<br/>  data: {</p><pre><code>active: 0,
list: [{
  pagePath: "/pages/index/index",
  icon: 'wap-home',
  text: "首页"
}, {
  pagePath: "/pages/user/index",
  icon: 'contact',
  text: "我的"
}]</code></pre><p>},<br/>  onChange(event) {</p><pre><code>const index = event.detail;
// event.detail 的值为当前选中项的索引
// this.setData({ active: index });
// 使用 switchTab API 进行页面跳转
wx.switchTab({
  url: this.data.list[index].pagePath
});</code></pre><p>},<br/>});<br/>index.json<br/>{<br/>  "navigationBarTitleText": "个人信息",<br/>  "usingComponents": {</p><pre><code>"van-tabbar": "@vant/weapp/tabbar/index",
"van-tabbar-item": "@vant/weapp/tabbar-item/index",
"van-icon": "@vant/weapp/icon/index"</code></pre><p>}<br/>}<br/>index.wxml<br/>&lt;!--index.wxml--&gt;<br/>&lt;view class="custom-tab-bar" id="{{ active }}"&gt;<br/>  &lt;van-tabbar active="{{ active }}" bind:change="onChange"&gt;</p><pre><code>&lt;van-tabbar-item wx:for="{{ list }}" wx:key="index"&gt;
  &lt;van-icon name="{{ item.icon }}" /&gt;
  &lt;text class="name"&gt;{{ item.text }}&lt;/text&gt;
&lt;/van-tabbar-item&gt;</code></pre><p>&lt;/van-tabbar&gt;<br/>&lt;/view&gt;</p><p>index.wxss<br/>/<strong>index.wxss</strong>/</p><p>page {<br/>  padding-top: 54rpx;<br/>  background-color: #f6f6f6;<br/>  padding-bottom: 60rpx;<br/>}</p><p>.custom-tab-bar {<br/>  font-family: PingFang SC;<br/>}</p><p>.custom-tab-bar van-tabbar {<br/>  display: flex;<br/>}</p><p>.custom-tab-bar van-tabbar-item{<br/>  flex: 1;<br/>  height: 60px;<br/>}</p><p>.custom-tab-bar van-icon{<br/>  width: 100%;<br/>  font-size: 20px;<br/>  text-align: center;<br/>}</p><p>.custom-tab-bar .name{<br/>  display: inline-block;<br/>  width: 100%;<br/>  text-align: center;<br/>  line-height: 20px;<br/>}</p>]]></description></item><item>    <title><![CDATA[西瓜老师AI大模型RAG项目实战课超清俱]]></title>    <link>https://segmentfault.com/a/1190000047433336</link>    <guid>https://segmentfault.com/a/1190000047433336</guid>    <pubDate>2025-11-27 20:04:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>AI大模型RAG项目实战课：重塑多领域发展的技术引擎<br/>在人工智能技术深度渗透社会各领域的2025年，RAG（检索增强生成）技术凭借其突破大模型知识局限性的独特能力，成为推动教育革新、科技突破、人文发展及经济转型的核心驱动力。以西瓜老师主讲的《AI大模型RAG项目实战课》为代表的课程体系，不仅为开发者提供了系统化的技术框架，更通过真实场景的深度剖析，揭示了RAG技术如何重构多领域的发展逻辑。</p><p>教育革新：从知识容器到智能导师<br/>传统教育模式长期受限于标准化知识传递的单一维度，而RAG技术的引入正在打破这一边界。某在线教育平台部署的RAG系统，通过整合20万条教材、习题及历史答疑数据，构建了动态知识图谱。当学生提问“二次函数顶点坐标求解方法”时，系统不仅检索教材中的公式推导过程，还能结合相似题型的解题步骤生成个性化辅导方案。这种“检索-生成-反馈”的闭环机制，使问题解决率从65%提升至89%，更通过溯源功能标注知识点来源，帮助学生建立系统性学习路径。</p><p>在高等教育领域，RAG技术正在重塑科研范式。某高校法律系部署的RAG系统接入最高人民法院裁判文书库与法律法规数据库，在审核合同时自动检索相似案例与法条依据。针对“违约金条款合法性”的审核，系统能快速定位《民法典》第585条及相关司法解释，并标注3个同类纠纷判决结果，将审核效率提升4倍。这种基于权威数据源的智能辅助，不仅降低了法律风险，更培养了学生的批判性思维能力。</p><p>科技突破：从实验室原型到生产级系统<br/>RAG技术的工程化落地，正在推动科技研发从理论探索向规模化应用跨越。某三甲医院部署的医疗RAG系统，通过多级索引结构（目录→章节→模块）快速定位“某疾病最新治疗方案”，并调用逻辑推理模块分析药物联用禁忌。该系统采用ReAct架构的智能体，实现从症状输入到诊疗建议的全流程自动化，诊断准确率提升至92%，较传统模型提高27个百分点。其核心突破在于构建了包含10万份电子病历、5万篇医学文献的动态知识库，并通过持续反馈机制优化检索策略。</p><p>在金融科技领域，RAG技术正在重构投研分析框架。某量化投资平台开发的RAG系统，实时抓取市场数据、行业研报及政策文件，通过NLP技术清洗结构化与非结构化数据，再利用Sentence-BERT模型将文本转化为高维向量。当用户查询“2025年新能源补贴政策影响”时，系统先通过向量检索定位相关政策文件片段，再结合用户持仓组合生成包含风险评估的个性化报告。该系统在“黑五”大促期间单日处理查询量突破1200万次，较传统系统处理效率提升15倍。</p><p>人文发展：从数据孤岛到文化共生<br/>RAG技术正在打破文化传承的时空壁垒，构建跨地域、跨语言的知识共享生态。某非遗保护机构开发的RAG系统，整合了3000小时口述史音频、5万张传统工艺图片及200万字文献资料，通过多模态检索技术实现“以图搜文”“以音寻史”的交互模式。当用户上传一张剪纸图案时，系统能检索相似工艺的传承人信息、地域分布及文化寓意，并生成包含3D复原视频的数字化档案。这种技术赋能，使非遗传承从“少数人守护”转变为“全社会参与”。</p><p>在跨文化交流领域，RAG技术正在消除语言障碍带来的认知隔阂。某国际组织部署的RAG系统，支持12种语言的实时互译与语义理解，通过上下文感知技术处理文化专属概念。在“气候变化”主题讨论中，系统能识别“碳达峰”在中文语境中的政策含义，同时检索联合国气候变化框架公约中的对应条款，生成包含文化背景注释的翻译结果。这种智能辅助，使全球治理的决策效率提升40%，更促进了不同文明间的深度对话。</p><p>经济转型：从效率革命到价值重构<br/>RAG技术正在重塑产业价值链，催生新的经济增长点。某制造企业开发的RAG系统，集成设备传感器数据与维修手册，通过时间序列分析预测故障概率。当某生产线振动值异常时，系统不仅检索历史维修记录中的相似案例，还能调用库存管理系统推荐备件更换方案，将设备停机时间从4小时缩短至45分钟。该系统实施后，企业年维护成本降低3200万元，更通过预测性维护模式开拓了设备健康管理服务市场。</p><p>在消费领域，RAG技术正在重构用户体验的底层逻辑。某电商平台部署的RAG客服系统，整合了20万条产品手册、售后政策及历史对话数据，通过动态上下文生成技术实现多轮对话。当用户咨询“如何申请大促退款”时，系统不仅检索退款流程文档，还能结合用户订单状态、活动规则生成个性化指引，使客服响应时间从3分钟降至18秒，用户满意度提升至96%。这种智能服务模式，使企业客服成本降低65%，更通过精准需求洞察推动产品迭代。</p><p>技术伦理：从工具理性到价值共生<br/>随着RAG技术的广泛应用，其伦理挑战也日益凸显。某AI实验室研发的RAG系统，在医疗诊断场景中采用双模型架构：检索模型确保文献准确性，生成模型采用解码限制（如禁止生成未经验证的治疗建议），并通过审计日志记录所有检索与生成过程，满足HIPAA等医疗法规要求。这种设计范式，为技术伦理提供了可复制的解决方案。</p><p>在教育领域，RAG系统的溯源功能正在培养用户的批判性思维。某K12教育平台开发的RAG系统，在生成答案时强制标注数据来源，并设置“验证模式”鼓励用户交叉核对信息。这种设计使青少年在获取知识的同时，建立起“不盲从、重实证”的认知习惯，为数字时代的公民素养培养提供了技术支撑。</p><p>从教育场域的智能导师到医疗领域的诊断专家，从文化传承的数字守护者到经济转型的效率引擎，RAG技术正在以“知识增强”为核心，重构人类与人工智能的协作范式。西瓜老师的实战课程通过159课时系统化训练，不仅传授技术实现方法，更引导开发者思考技术背后的价值逻辑——唯有将工具理性与人文关怀深度融合，方能在AI时代构建真正创造可持续价值的技术系统。这种技术教育范式的革新，或许正是应对未来挑战的关键钥匙。</p>]]></description></item><item>    <title><![CDATA[jdguiwindows.rar使用步骤]]></title>    <link>https://segmentfault.com/a/1190000047433343</link>    <guid>https://segmentfault.com/a/1190000047433343</guid>    <pubDate>2025-11-27 20:03:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>​</p><h3>先搞到这个压缩包</h3><p><strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=Al6JDHgDuadzYTDl4GYnAA%3D%3D.FCg8lErfYaFAdPR3kVvQRhPSalJtqtYWsRAA16scWo7srrfwuFPcODkEmxLYsVpd" rel="nofollow" title="https://pan.quark.cn/s/32cf9c9c31e9" target="_blank">https://pan.quark.cn/s/32cf9c9c31e9</a> ，首先你得把 <code>jdguiwindows.rar</code>这个文件弄到自己电脑里，下载完找着它，一般在“下载”文件夹里，图标是个带拉链的方块（Windows默认压缩包样子）。</p><h3>解压出来才能用</h3><p>这文件是压缩的，直接双击打不开，得先“拆”开：</p><ol><li>右键点这个 <code>jdguiwindows.rar</code>，会弹出一堆选项；</li><li>选“解压到当前文件夹”（想放别的地方就选“解压到指定文件夹”，自己挑个空地方）；</li><li>等一小会儿，等它拆完——拆完会出现一个新文件夹，名字可能跟压缩包差不多，里面就是能用的东西了。</li></ol><h3>找到启动程序</h3><p>打开刚解压好的文件夹，往里面翻，找个叫 <code>jd-gui.exe</code>的文件（一般是第一个，图标可能是个小咖啡杯或者齿轮啥的）。这就是咱要打开的主程序，直接双击它就行。</p><h3>开始用它看jar包</h3><p>打开后界面挺简单的，主要干一件事：<strong>看jar包里的代码</strong>。操作就三步：</p><ol><li><strong>导入jar包</strong>：点上面菜单栏的“File”（文件），然后选“Open File...”（打开文件），找到你想看的 <code>.jar</code>文件（比如项目里的 <code>xxx.jar</code>），选中点“打开”；</li><li><strong>等加载完</strong>：它会读一会儿jar包，进度条走完就能看到里面的代码结构了——左边是文件夹树（像src、com这些），右边是具体的代码；</li><li><strong>随便看代码</strong>：点左边的文件夹或类名，右边就显示对应的代码，还能搜关键词（Ctrl+F），跟平时看txt似的。</li></ol><p>​</p>]]></description></item><item>    <title><![CDATA[AI浪潮来袭：薪资暴涨40%、门槛大降！]]></title>    <link>https://segmentfault.com/a/1190000047433347</link>    <guid>https://segmentfault.com/a/1190000047433347</guid>    <pubDate>2025-11-27 20:02:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>普通员工用AI开发应用，为企业创造千万价值</p><p>在中集集团，一位普通业务员通过3个月AI培训，开发出合同风险识别系统，不仅将审核时间从2小时缩短到5分钟，更获得薪资上调40% 的奖励。</p><p>在武汉，一位传统制造业工程师转型AI应用工程师后，月薪从8000元跃升至18000元，成功搭上产业升级的快车。</p><p>01 <br/>薪资涨幅惊人，AI人才供不应求</p><p>最新数据显示，2024年AI相关岗位平均薪资涨幅达25-40%，远超其他行业8% 的平均水平。其中，AI应用工程师、大模型优化师等新兴岗位薪资涨幅尤为显著。</p><p>企业为争夺AI人才使出浑身解数。某互联网大厂为应届AI博士开出80万年薪打包价，而兼具行业经验与AI技能的复合型人才更是炙手可热，薪资溢价普遍超过30%。</p><p>“我们招聘的AI应用工程师，只要具备半年实战经验，起薪基本在2.5万元以上。”一位头部制造企业HR透露，“这个岗位去年还不存在，现在却成为各部门争抢的香饽饽。”</p><p>02 <br/>入门门槛大幅降低，非科班背景同样吃香</p><p>令人惊喜的是，AI行业不再只青睐计算机科班生。中集集团的实践表明，业务背景的员工经过培训，开发的AI应用往往更接地气、更实用。</p><p>“我们最成功的AI应用‘专利交底书撰写助手’，就是由一位法学背景的员工开发的。”中集集团数字化负责人表示，“他不懂复杂算法，但深刻理解业务痛点，用现成的AI工具就解决了大问题。”</p><p>目前，市场上涌现出大量低代码、零基础的AI培训课程，学习周期从过去的数年缩短至3-6个月。许多培训班承诺“结业即就业”，就业率普遍超过85%。</p><p>03 <br/>个人价值倍增，从执行者变为创新者</p><p>使用AI不仅仅是提高效率，更是提升个人价值的关键途径。在中集集团，一位普通文员开发的会议纪要自动生成工具，让她从繁琐的文书工作中解放出来，开始参与更重要的项目策划工作。</p><p>“以前我是会议记录员，现在是项目协作者。”她感慨道，“AI改变了同事对我的认知，也改变了我对自己的定位。”</p><p>数据显示，掌握AI技能的员工获得晋升机会的比例比未掌握者高出53%。企业更愿意将资源分配给能够利用AI创造新价值的员工。</p><p>04 <br/>行业发展空间巨大，未来十年持续向好</p><p>选择行业就是选择未来。AI产业正处于爆发前夜，预计到2027年，中国人工智能核心产业规模将超过4500亿元，带动相关产业规模数万亿元。</p><p>政策支持力度空前。从国家到地方，各级政府部门密集出台支持AI产业发展的政策，在资金、人才、技术等方面提供全方位保障。</p><p>“未来十年，AI将像今天的互联网一样普及。”业内专家预测，“现在入行，恰逢产业爆发期，职业发展空间巨大。”</p><p>从中集集团的普通员工到武汉的制造业工程师，他们的经历证明：AI不是取代者，而是赋能者。掌握AI技能，意味着在职场中掌握更多主动权、获得更高回报。</p><p>现在入行AI，恰逢其时。无论是薪资涨幅、个人成长还是行业发展，都处于最佳机遇期。选择AI，就是选择一个更具确定性的未来。</p><p>现在搜索并关注 「OJAC近屿智能」，即可免费领取超值资料包：<br/>想要获取AI资料包、最新的AI行业动态和优质工作机会吗？<br/>快来扫码加入我们的AI交流群吧！<br/>1️⃣ 每周一次 | 工作机会速递<br/>整合最新的AI行业工作机会，群内推送高质量的岗位讯息。<br/>2️⃣ 每月底 | 前沿技术分享<br/>邀请一流科技领袖分享最新研究进展、行业动态和技术实践，让您时刻站在AI领域的前沿。<br/>3️⃣ 不定期 | 独家行业资讯<br/>实时推送每日AI热点、行业深度解读，助你快速掌握核心趋势。</p>]]></description></item><item>    <title><![CDATA[NeurlPS 2025！多伦多大学TI]]></title>    <link>https://segmentfault.com/a/1190000047433362</link>    <guid>https://segmentfault.com/a/1190000047433362</guid>    <pubDate>2025-11-27 20:02:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433364" alt=" " title=" "/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433365" alt=" " title=" " loading="lazy"/></p><p>论文标题：<em>Track, Inpaint, Resplat: Subject-driven 3D and 4D Generation with Progressive Texture Infilling</em></p><p>作者团队：多伦多大学、向量研究院、Snap公司</p><p>发布时间：2025年10月28日</p><p><a href="https://link.segmentfault.com/?enc=b4MLcUt4Ok16ipP31L25UQ%3D%3D.K5TGga0Can9PNH3cVfwciWS1f0ITIGnl8N4gHu5Jsg159PD%2Fzf07BSNhS4G0IU5I" rel="nofollow" target="_blank">👉一键直达论文</a></p><p><a href="https://link.segmentfault.com/?enc=fuCwtCYT8G%2BhxLMmCbi0Gw%3D%3D.oqqWhE8q9MU2SxyPzhujUpD9%2B%2FCt67MDB4nCEv8f%2FxudB7UkZyDp1O47L0NXAlDWXFdn%2BInpcguOsBZk%2BgfafiPq6tezn%2B%2F1DE0jLJujObxX0xA9j0G3Ha3eKht%2FS3DndVZD2BRRogyDu0Ibfvlaww%3D%3D" rel="nofollow" target="_blank">👉Lab4AI大模型实验室论文阅读</a></p><p>✅Lab4AI平台提供AI导读和AI翻译等工具，辅助论文阅读。您还可以投稿复现这篇论文~</p><h2>⭐核心贡献</h2><p>该研究提出了TIRE（Track, Inpaint, Resplat），一种新的主体驱动3D/4D生成方法：</p><ul><li>创新方法：提出三阶段方法（Track, Inpaint, Resplat），分别用于识别需要填充的区域、逐步填充未观察到的区域以及将2D填充观察结果重新投影回3D空间。</li><li>高效性能：在构建的DreamBooth-Dynamic基准测试和野外数据上展示了TIRE在主体驱动3D/4D生成方面的优越性能。</li><li>互补性：与其他领先的3D/4D生成方法形成正交且互补的关系，共同推动该领域的研究进展。</li></ul><h2>⭐研究方法</h2><p>TIRE由三个关键步骤组成：</p><ul><li>1.Track：使用长视频跟踪来识别其他视角中需要填充的区域。</li><li>2.Inpaint：采用定制的2D填充模型逐步填充Track识别出的未见区域，并确保填充内容与给定源视图中主体的身份匹配。</li><li>3.Resplat：将Inpaint生成的多视角2D填充观察结果重新投影回3D空间，同时保持多个视角之间的一致性。</li></ul><p>具体实现流程如下：</p><ul><li>Track阶段：利用视频跟踪模型CoTracker从多视图渲染中找到源视图和目标视图之间的对应关系，识别需要填充的区域。</li><li>Inpaint阶段：使用定制的2D填充模型逐步填充识别出的未见区域。</li><li>Resplat阶段：将2D填充观察结果重新投影回3D空间，保持一致性。</li></ul>]]></description></item><item>    <title><![CDATA[Mac 安装 4K Video Down]]></title>    <link>https://segmentfault.com/a/1190000047433369</link>    <guid>https://segmentfault.com/a/1190000047433369</guid>    <pubDate>2025-11-27 20:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>​</p><p>4K Video Downloader for Mac v5.0.0.5303-1.dmg 是一款专门在苹果电脑（Mac）上下载高清视频的工具。它可以把 YouTube、B站、Facebook 等网站的视频保存成 MP4、MKV 等格式，还支持下载 4K、甚至 8K 画质。</p><h2>1. 先准备好文件</h2><ul><li><strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=NcOpcUphZcqT7divy%2BxRiA%3D%3D.5Z%2BecQSE3aMX7AedT2Z%2Fqr5ynz4hIUwWOUSK%2BuQqyLpQ%2B%2B0t59pquxds5U1sIv%2Bb" rel="nofollow" title="https://pan.quark.cn/s/69376fc207f3" target="_blank">https://pan.quark.cn/s/69376fc207f3</a>，先把 <strong>4K Video Downloader for Mac v5.0.0.5303-1.dmg</strong>​ 下载到你的 Mac 上，一般在“下载”文件夹里能找到。</li><li>确认文件没损坏，大小差不多对得上（别下一半断了）。</li></ul><h2>2. 打开安装包</h2><ul><li>找到下载好的  <strong>.dmg</strong>​ 文件，双击它。</li><li>这时会弹出一个新的窗口，里面通常有个软件图标和“应用程序”文件夹的快捷方式。</li></ul><h2>3. 把软件拖进“应用程序”</h2><ul><li>在这个窗口里，你会看到 <strong>4K Video Downloader</strong>​ 的图标，旁边是“应用程序”文件夹。</li><li>用鼠标按住软件图标，<strong>拖到</strong>“应用程序”文件夹里，松手。</li><li>等一会儿，它会把软件复制进去，这一步相当于安装。</li></ul><h2>4. 第一次打开软件</h2><ul><li>打开 Mac 的“启动台”或“应用程序”文件夹，找到 <strong>4K Video Downloader</strong>。</li><li>双击打开，第一次可能会提示“无法验证开发者”，因为不是 App Store 下载的。</li><li>点  <strong>“取消”</strong> ，然后去 <strong>系统设置 → 隐私与安全性</strong>，拉到最下面，会看到一个“仍要打开”的按钮，点它确认即可。</li><li>之后就能正常用了。</li></ul><h2>5. 收尾</h2><ul><li>安装完可以把刚才的  <strong>.dmg</strong>​ 窗口关掉，也可以把 dmg 文件删掉，节省空间。</li><li>以后直接在“应用程序”里打开 4K Video Downloader 就能下载视频了。</li></ul><p>​</p>]]></description></item><item>    <title><![CDATA[小白学习 Base32：它怎么编码？为什]]></title>    <link>https://segmentfault.com/a/1190000047432998</link>    <guid>https://segmentfault.com/a/1190000047432998</guid>    <pubDate>2025-11-27 19:06:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>背景</h2><p>上周汇报讲到 OTP 的代码实现。其中我们运用到的编码就是Base32 编码。当时老师提到一个问题字符串“yunzhi”是如何通过Base32 编码变成“PF2W46TINE======”的呢？今天就让我们从这个问题入手，细细了解一下什么是Base32，以及它的编码过程是怎么样的。更甚者，是否可以发明一个属于我自己编码方式</p><h2>Base32 是什么</h2><h3>是什么？</h3><p><a href="https://link.segmentfault.com/?enc=TxfJ%2BP43hjiuo4jqGFuShg%3D%3D.gTOlowdLA2OCPAwW%2ByXdRM29ArevoChC7Y0KhMAFYdKrNualnuYv6qcTtQHyd2%2Be" rel="nofollow" target="_blank">RFC 4648 文档</a></p><p><img width="723" height="434" referrerpolicy="no-referrer" src="/img/bVdnbBg" alt="image.png" title="image.png"/><br/>Base 32 是一种 <strong>将二进制数据编码成可读字符串的编码方式</strong>。即，是一种数据编码机制，使用 32 个可打印字符对二进制数据进行编码的方案，编码后的字符串不用区分大小写并排除了容易混淆的字符，可以方便地由人类使用并由计算机处理。</p><blockquote>Base32 用于编码，而非加密</blockquote><ul><li>字母 A - Z</li><li>数字 2 - 7<br/><img width="517" height="381" referrerpolicy="no-referrer" src="/img/bVdm8Cg" alt="image.png" title="image.png" loading="lazy"/></li></ul><blockquote>🤔 为什么 <strong>没有 0 和 1 </strong> 呢？<br/>❓ 为什么说 <strong>编码后的字符串不用区分大小写并排除了容易混淆的字符</strong> 呢？</blockquote><h2>Base32 编码原理</h2><p>它的编码规则是：任意给定一个二进制数据，以 5 个位（bit）为一组进行切分（注意：base64 以 6 个位 (bit) 为一组），对切分而成的每个组进行编码得到 1 个可见字符。</p><p>本质上：Base32 将 <code>每 5 个bit → 转为一个字符</code><br/>又因为 2^5 = 32， 所以Base32 编码表字符集中的字符总数为 2 的 5 次方 32 个，这也是 Base32 名字的由来。</p><h2>示例演示</h2><h3>编码</h3><p>这里的例子，使用的是我自己的名字拼音 <code>yuxuan</code></p><h4>具体步骤</h4><h5>第一步：将字符 "yuxuan" 取 ASCII 码之后，转换成为二进制字符串</h5><pre><code class="bash">y    121        01111001
u    117        01110101
x    120        01111000
u    117        01110101
a    97         01100001
n    110        01101110
</code></pre><p>此时，得到的一个长度为 48 的字符串 <code>"01111001 01110101 01111000 01110101 01100001 01101110"</code></p><h5>第二步：以 5 个 bit 为一组对 "yuxuan" 进行切分，不足补"0"</h5><pre><code class="bash">01111
00101
11010
10111
10000
11101
01011
00001
01101
110 =&gt; 11000</code></pre><h5>第三步：计算第二步中每组二进制数对应的十进制值，参照Base32 编码表组合秘文</h5><pre><code class="bash">01111            15        P
00101            5         F
11010            26        2
10111            23        X
10000            16        Q
11101            29        5
01011            11        L
00001            1         B
01101            13        N
11000            24        Y</code></pre><p>这一步得到的秘文是 <code>PF2XQ5LBNY</code></p><h5>第四步：判断是否需要填充</h5><p>规则：Base32 使用 5bit 进行编码，标准要求输出必须按 8 个 Base32 字符为一组。<br/>当最后不足 5 字节时，会得到不足 8 字符的编码结果，因此需要使用 = 填充，使输出长度补齐到 8 的倍数，并让解码器能够准确知道原始数据的真实长度。</p><p><img width="723" height="211" referrerpolicy="no-referrer" src="/img/bVdm8FH" alt="image.png" title="image.png" loading="lazy"/></p><p>最终得到 <code>yuxuan</code> 的 Base32 编码为 <code>PF2XQ5LBNY======</code></p><h5>验证一下：</h5><p><img width="723" height="502" referrerpolicy="no-referrer" src="/img/bVdm8Gb" alt="image.png" title="image.png" loading="lazy"/></p><p>✅ 成功！大家也快去试试吧</p><h3>解码</h3><p>如何编码已经了解了，那么解码可以算是水到渠成。我们一起来吧！<br/>这里我们使用潘老师提到的例子，yunzhi 和 PF2W46TINE====== 来做解码。</p><h4>具体步骤</h4><h5>第一步：将编码后得到的"PF2W46TINE======"后面的"="字符去掉，并转换为二进制</h5><pre><code class="bash">00001111    P
00000101    F
00011010    2
00010110    W
00011100    4
00011110    6
00010011    T
00001000    I
00001101    N
00000100    E</code></pre><h5>第二步：将每个二进制字符串前面的三个0去掉</h5><p>💡 因为在Base32 中只有 5 位是有效的，其他都是填充的。</p><pre><code class="bash">01111    P
00101    F
11010    2
10110    W
11100    4
11110    6
10011    T
01000    I
01101    N
00100    E</code></pre><p>得到一个长度为 50 的字符串 <code>"01111 00101 11010 10110 11100 11110 10011 01000 01101 00100"</code></p><h5>第三步：以 8 个bit进行切分，计算得出它的十进制数，并根据获取 ASCII 码</h5><pre><code class="bash">01111001    121        y
01110101    117        u
01101110    110        n
01111010    122        z
01101000    104        h
01101001    105        i</code></pre><p>此时，得到的 ASCII 码组合起来就是 <code>yunzhi</code></p><h2>设计属于自己的 Base32 编码方式</h2><p>在理解 Base32 的原理后，我们完全可以基于同样的思路，设计一个自定义的可逆编码方案（例如：zyx32）。</p><p>Base32 的本质是：</p><blockquote>将原始数据按固定 bit 数进行切片，再使用一个映射字符表将每段数据转换为字符。</blockquote><p>因此，只要满足以下两点就能设计出自己的编码：</p><ul><li>划分多少 bit 进行映射</li><li>准备一个对应数量的字符表</li></ul><hr/><ol><li><p>确定 bit 划分规则<br/>不同的切片大小决定所需字符表的大小：</p><table><thead><tr><th>划分bit数</th><th>所需字符数量</th><th>示例命名</th></tr></thead><tbody><tr><td>4 bit</td><td>16个字符</td><td>zyx16</td></tr><tr><td>5 bit</td><td>32 个字符</td><td>zyx32</td></tr><tr><td>6 bit</td><td>64 个字符</td><td>zyx64</td></tr></tbody></table></li></ol><p>例如：</p><ul><li>若按 <strong>4 bit</strong> 切片，则 2^4 = 16，需要 16 个字符 → 可命名为 <strong>zyx16</strong></li><li>若按 <strong>5 bit</strong> 切片，则 2^5 = 32，需要 32 个字符 → 即 <strong>zyx32</strong></li><li>若按 <strong>6 bit</strong> 切片，则 2^6 = 64，需要 64 个字符 → 即 <strong>zyx64</strong></li></ul><ol start="2"><li>确定我们的字符表<br/>划分好 bit 后，我们需要准备一个<strong>大小等于 2ⁿ 的字符集</strong></li></ol><hr/><p>例如用于 zyx32 的字符表应包含 32 个唯一字符：</p><ul><li>可以全部使用大写字母</li><li>可以混用大小写</li><li>可以包含数字</li><li>也可以排除容易混淆的字符（如 I, l, 1, O, 0）</li></ul><table><thead><tr><th>值</th><th>符号</th><th>值</th><th>符号</th><th>值</th><th>符号</th><th>值</th><th>符号</th></tr></thead><tbody><tr><td>0</td><td>Z</td><td>8</td><td>Q</td><td>16</td><td>e</td><td>24</td><td>t</td></tr><tr><td>1</td><td>H</td><td>9</td><td>R</td><td>17</td><td>f</td><td>25</td><td>2</td></tr><tr><td>2</td><td>A</td><td>10</td><td>T</td><td>18</td><td>h</td><td>26</td><td>3</td></tr><tr><td>3</td><td>N</td><td>11</td><td>B</td><td>19</td><td>m</td><td>27</td><td>4</td></tr><tr><td>4</td><td>G</td><td>12</td><td>a</td><td>20</td><td>n</td><td>28</td><td>5</td></tr><tr><td>5</td><td>Y</td><td>13</td><td>b</td><td>21</td><td>q</td><td>29</td><td>7</td></tr><tr><td>6</td><td>U</td><td>14</td><td>c</td><td>22</td><td>r</td><td>30</td><td>9</td></tr><tr><td>7</td><td>X</td><td>15</td><td>d</td><td>23</td><td>s</td><td>31</td><td>1</td></tr></tbody></table><p>这样，属于自己的 zyx32 的编码表就出来啦。只要我们编码解码都使用用一张表就可以用 zyx32 来进行“交流”了</p><p>再次尝试将 <code>yuxuan</code> 使用 zyx32 进行编码，得到：<code>dY3se7BHbt</code></p><p><img width="587" height="312" referrerpolicy="no-referrer" src="/img/bVdnbw5" alt="image.png" title="image.png" loading="lazy"/></p><p>这里我们会发现，zyx32 并没有给出padding（填充符）：是因为，zyx32 并没有要求结果的输出格式</p><p>而我们的 Base32 对输出字符数又着一定的要求，以及可以通过 <code>=</code> 的数量来判断原始数据的字节数：<br/><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdnbCz" alt="image.png" title="image.png" loading="lazy"/></p><p><img width="723" height="547" referrerpolicy="no-referrer" src="/img/bVdnbCR" alt="image.png" title="image.png" loading="lazy"/></p><p>总结位一个表格大概就是：</p><table><thead><tr><th>原始数据剩余字节</th><th>剩余 bit</th><th>输出 Base32 字符数</th><th>需要 "=" 数量</th><th>解码端可推回原始字节数</th></tr></thead><tbody><tr><td>5 字节（40 bit）</td><td>40</td><td>8 字符</td><td>0</td><td>5 字节</td></tr><tr><td>1 字节（8 bit）</td><td>8</td><td>2 字符</td><td>6</td><td>1 字节</td></tr><tr><td>2 字节（16 bit）</td><td>16</td><td>4 字符</td><td>4</td><td>2 字节</td></tr><tr><td>3 字节（24 bit）</td><td>24</td><td>5 字符</td><td>3</td><td>3 字节</td></tr><tr><td>4 字节（32 bit）</td><td>32</td><td>7 字符</td><td>1</td><td>4 字节</td></tr></tbody></table><h2>总结</h2><p>到这里我们对 Base32 的了解就结束了。Base32 类的编码本质都是 按固定 bit 切片 → 使用映射表编码，理解了机制，其实就理解了整个 Base 家族的共同核心。<br/>个人感觉，对于填充字符，还需要进一步进行了解。<br/>希望这篇文章能帮助你更清晰地理解 Base 编码的思想。</p><h2>文章参考</h2><p><a href="https://link.segmentfault.com/?enc=ycLzL8uscX9wD%2FfzmUEbFA%3D%3D.58ojtR56LuY29ijD1ijg8N7eI%2BROAOPYLEjaAGCP%2FUUvN%2Fr5B%2FWtHko9jsVwsbhe" rel="nofollow" target="_blank">Base64, Base32 和 Base16，用通俗的语言深入到内部</a><br/><a href="https://link.segmentfault.com/?enc=vXUgwFCMiBZduirvOxgAng%3D%3D.JV%2B0k5p9uWt9uivdhTadGZPopomiTym6j4L4Wb7xjpeGZvP8whDWE6LSW%2BckOIoy" rel="nofollow" target="_blank">RFC 4648 官方</a><br/><a href="https://link.segmentfault.com/?enc=LEgCFkbptigMF6syq1zovw%3D%3D.lHGVK5KPdoWg%2FItTeyq14GVXxXkjjspwWHah4%2F9hr4SM%2FwBVQsKmCYrwq%2F71HJlISKy7x4YJf3iXTFsQdH2l3SmTun6lN%2BPyVPvn9HRnXGM%3D" rel="nofollow" target="_blank">Base32编码和解码</a></p>]]></description></item><item>    <title><![CDATA[修复“发送至任何地点”功能无法正常工作的]]></title>    <link>https://segmentfault.com/a/1190000047433138</link>    <guid>https://segmentfault.com/a/1190000047433138</guid>    <pubDate>2025-11-27 19:06:00</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Send Anywhere 是一款热门的文件传输应用，用户可以使用它在设备间快速发送大文件。然而，任何应用都并非完美无缺，Send Anywhere 有时也会出现故障。无论是连接问题、传输速度慢还是应用崩溃，这些问题都可能令人沮丧。</p><p>本指南将帮助您排查 Send Anywhere 无法正常运行的常见原因，并提供分步解决方案。此外，如果该应用仍然无法正常工作，我们还将介绍一些优秀的替代方案，以确保您的文件传输流畅无阻。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433141" alt="图片" title="图片"/><br/>​</p><p>第一部分：为什么“发送至任何地方”功能无法正常工作？</p><p>Send Anywhere 无法正常运行的原因有很多。以下是一些最常见的问题：</p><ol><li>连接问题</li></ol><p>如果应用程序找不到或无法连接到目标设备，通常是由于网络问题造成的。</p><ol start="2"><li>传输速度慢</li></ol><p>有时，即使网络连接正常，文件传输也可能耗时过长。</p><ol start="3"><li>应用卡顿或崩溃</li></ol><p>由于软件漏洞或设备限制，Send Anywhere 可能会意外冻结或崩溃。</p><ol start="4"><li>权限问题</li></ol><p>该应用可能没有访问您的文件或存储空间的适当权限。</p><ol start="5"><li>过时的应用程序</li></ol><p>旧版本的 Send Anywhere 可能会导致兼容性问题或程序错误。</p><p>了解这些常见问题是解决问题的第一步。</p><p>第二部分：如何解决“发送至任意地点”功能无法使用的问题</p><p>在明确了可能的原因之后，让我们从最简单有效的方法入手，逐步解决问题。我们建议按照以下顺序进行故障排除——大多数问题无需复杂操作即可解决。</p><p>解决方法一：检查网络连接</p><p>稳定的网络连接对于 Send Anywhere 的正常运行至关重要。以下是如何排查常见网络问题的方法：</p><pre><code>靠近路由器

</code></pre><p>如果您使用的是 Wi-Fi，请尝试靠近路由器以增强信号。</p><pre><code>重启路由器

</code></pre><p>如果连接仍然不稳定，重启路由器可以帮助重置网络并改善连接。</p><pre><code>使用移动热点

</code></pre><p>如果您身处网络受限的环境（例如公司或校园），请尝试将手机用作移动热点。</p><p>打开手机的 5G/4G 热点功能，并将电脑连接到该热点。这通常可以绕过网络问题，改善文件传输连接。</p><pre><code>配置公共 DNS

</code></pre><p>如果遇到 DNS 解析问题，请尝试手动配置公共 DNS：</p><p>在Windows上：</p><pre><code>转到“网络”&gt;“共享中心”&gt;“更改适配器设置”。
右键单击当前网络，然后选择“属性”。
双击“Internet 协议版本 4 (TCP/IPv4)”。
将首选 DNS 服务器设置为 8.8.8.8（Google DNS）或 208.67.222.222（OpenDNS）。

</code></pre><p>在移动设备上：</p><pre><code>进入Wi-Fi设置。
进入高级选项。
手动修改DNS设置。

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433142" alt="图片" title="图片" loading="lazy"/></p><p>解决方法 2：重启 Send Anywhere 服务</p><p>临时进程错误很常见，通常可以通过重启应用程序来解决。请按照以下步骤完全关闭并重启 Send Anywhere：</p><p>在Windows上：</p><pre><code>右键单击任务栏，然后选择“任务管理器”。
找到“Send Anywhere”进程，右键单击它，然后选择“结束任务”。
等待 10 秒钟，然后重新启动 Send Anywhere。

</code></pre><p>iOS ：</p><pre><code>从屏幕底部向上滑动（或在全屏机型上从右上角向下滑动）即可打开应用切换器。
向上滑动 Send Anywhere 应用卡片即可将其关闭。
等待 10 秒钟，然后重新启动 Send Anywhere。


</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433143" alt="图片" title="图片" loading="lazy"/></p><p>Android系统：</p><pre><code>打开“最近使用的应用”屏幕。
找到“Send Anywhere”并滑动将其关闭。
等待 10 秒钟，然后重新打开 Send Anywhere。

</code></pre><p>方法三：重启设备</p><p>如果重启应用无效，重启设备或许能解决更深层次的问题。重启可以清除设备的临时内存，终止冲突的后台进程，并恢复异常的系统服务。</p><pre><code>对于电脑，点击“开始”菜单，然后选择“重新启动”；
对于手机，按住“电源”按钮，然后选择“重启”。

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433144" alt="图片" title="图片" loading="lazy"/></p><p>设备重启后，启动 Send Anywhere 并再次测试。</p><p>方法四：尝试其他转账方式</p><p>Send Anywhere 提供多种转账方式，切换方式通常可以解决问题。您可以尝试以下方法：</p><p>从六位数字密码切换到二维码</p><p>如果6位密钥传输失败，请尝试生成二维码进行扫描。请确保手机摄像头视野清晰，没有遮挡物，否则会影响扫描。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433145" alt="图片" title="图片" loading="lazy"/></p><p>使用链接分享</p><pre><code>如果直接转账失败，请使用链接分享功能：
在 Send Anywhere 中生成下载链接。
通过微信、电子邮件或其他通讯工具将链接发送给收件人。
收件人可以直接通过浏览器下载文件，无需安装 Send Anywhere。

</code></pre><p>注意： 6 位数密钥有效期为 10 分钟，请确保收件人在此时间内输入密钥。此外，链接有效期为 48 小时，请确保收件人在链接过期前访问该链接。</p><p>解决方法 5. 检查存储空间</p><p>发送端或接收端存储空间不足会导致传输失败。发送端空间不足可能导致应用程序无法正常读取文件；接收端空间不足则可能导致无法保存传输的文件。请检查存储空间：</p><pre><code>在Windows中，打开“此电脑”，查看磁盘剩余空间；
在 macOS 系统中，点击苹果菜单 &gt; “关于本Mac ” &gt; “存储”；
在iOS中，依次进入“设置”&gt;“通用”&gt;“iPhone 存储空间”；
在Android中，进入“设置”&gt;“存储”。

</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433146" alt="图片" title="图片" loading="lazy"/><br/>​</p><p>如果剩余空间小于传输文件的大小，请删除无用的文件（例如旧照片、不使用的应用程序或缓存的视频）以释放空间。</p><p>修复 6. 更新 Send Anywhere</p><p>Send Anywhere 的旧版本可能存在一些新版本中已修复的错误。以下是更新应用的方法：</p><p>在Windows或 macOS 系统上：</p><pre><code>打开 Send Anywhere 应用。
转到“设置”或“帮助”，然后单击“检查更新”。
如果有可用更新，请按照提示进行安装。

</code></pre><p>iOS ：</p><pre><code>打开应用商店。
搜索“Send Anywhere”。
如果有可用更新，请点击“更新”。

</code></pre><p>Android系统：</p><pre><code>打开 Google Play 商店或您设备上的相关应用商店。
搜索 Send Anywhere 并查看更新。
点击“更新”安装最新版本。

</code></pre><p>更新后，重启应用程序并再次尝试传输文件，看看问题是否已解决。</p><p>解决方法 7：重新安装 Send Anywhere</p><p>如果更新应用后问题仍然存在，重新安装应用或许可以修复损坏的核心文件。方法如下：</p><p>在Windows上：</p><pre><code>打开控制面板，然后进入“程序和功能”。
找到 Send Anywhere 并点击“卸载”。
卸载后，请访问Send Anywhere 官方网站下载最新版本。避免从第三方下载网站下载，以免下载恶意软件。

</code></pre><p>在 macOS 系统上：</p><pre><code>打开“应用程序”文件夹。
将 Send Anywhere 应用拖到废纸篓并清空。
从官方网站下载最新版本并重新安装。

</code></pre><p>iOS ：</p><pre><code>按住 Send Anywhere 应用图标。
点击“删除应用”即可卸载。
打开应用商店并重新安装该应用。

</code></pre><p>Android系统：</p><pre><code>按住 Send Anywhere 应用图标。
选择“卸载”并确认。
请前往 Google Play 商店重新安装该应用。


</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433147" alt="图片" title="图片" loading="lazy"/><br/>​</p><p>重新安装后，打开应用程序并授予任何必要的权限（存储、相机、网络等），然后再次测试传输。</p><p>解决方法 8：清除应用缓存和数据</p><p>缓存文件损坏会导致应用程序运行异常。清除缓存或许可以解决一些小问题：</p><p>在Windows上：</p><pre><code>打开 Send Anywhere 应用。
进入“设置”，找到“缓存”选项。
点击“清除缓存”以删除临时文件。

</code></pre><p>在 macOS 系统上：</p><pre><code>导航至“~/Library/Caches”。
找到与 Send Anywhere 相关的文件夹并将其删除。

</code></pre><p>iOS ：</p><p>没有直接清除缓存的选项。最好的办法是卸载并重新安装该应用，这样就能清除缓存。</p><p>Android系统：</p><pre><code>前往“设置”&gt;“应用”&gt;“发送至任何地方”&gt;“存储”。
点击“清除缓存”以删除临时文件。
如果问题仍然存在，您还可以点击“清除数据”（但请注意，这将清除应用程序设置和登录信息，因此请谨慎使用此选项）。





</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433148" alt="图片" title="图片" loading="lazy"/><br/>​</p><p>第三部分：Send Anywhere 无法正常工作的替代方案</p><p>如果您已经尝试了以上所有方法，但 Send Anywhere 仍然无法正常工作，或者您需要一款更稳定的工具用于长期使用，那么以下两种替代方案值得一试。它们在不同的传输场景中表现出色，可以满足各种不同的需求。</p><p>方案一： Coolmuster Mobile Transfer [手机间转账]</p><p>如果您经常需要在手机之间切换或需要快速传输大文件， Coolmuster Mobile Transfer比 Send Anywhere 更高效，为手机之间的直接数据传输提供更可靠的解决方案。</p><p>移动转账的主要特点：</p><pre><code>支持联系人、照片、视频、音乐、短信、通话记录和应用程序。
在 iOS 和 Android 之间、 iOS到iOS以及Android到Android iOS Android文件。
无需钥匙、二维码或复杂的设置。
避免因网络连接不良而导致的问题；只需通过 USB 或 Wi-Fi 连接即可。
在大多数Android和iOS设备上无缝运行，包括iPhone 17。

</code></pre><p>如何使用手机转账：</p><p>01在您的计算机上下载并安装 Mobile Transfer。</p><p>02使用 USB 数据线将两部手机（源手机和目标手机）连接到电脑。按照屏幕上的说明建立连接，程序将自动检测到两台设备。</p><p>03选择要传输的数据类型（例如，联系人、照片、短信）。然后，点击“开始复制”按钮，开始将所选文件从一部手机传输到另一部手机。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433149" alt="图片" title="图片" loading="lazy"/></p><p>方案二： Coolmuster Android Assistant [ Android与电脑传输]</p><p>如果您专注于在Android设备和电脑之间传输和管理文件， Coolmuster Android Assistant是一个强大而可靠的 Send Anywhere 替代方案。该工具提供 USB 和 Wi-Fi 两种连接方式，让您轻松地在Android手机/平板电脑和电脑之间传输文件。它不仅是一款文件传输工具，更是一个全面的Android管理解决方案。</p><p>Android助手的主要功能：</p><pre><code>轻松在Android手机和电脑之间传输照片、音乐、视频、联系人等内容。
没有文件大小限制，非常适合传输大型文件。
一键备份和恢复Android设备数据。
直接在电脑上管理Android应用、联系人、短信和其他数据。
支持Android 6.0 及以上版本，包括最新的Android 16。

</code></pre><p>如何使用Android助手：</p><p>01在您的计算机上下载、安装并运行Android Assistant。</p><p>02使用 USB 数据线或 Wi-Fi 将您的Android设备连接到电脑。如有必要，请确保您的设备已启用 USB 调试模式。</p><p>03连接建立后，程序会将所有数据显示在您的Android设备上。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433150" alt="图片" title="图片" loading="lazy"/></p><p>04选择要传输的数据类型（例如，照片、视频、联系人）后，点击“导出”按钮将所选文件传输到您的计算机，或者使用“导入”将文件从您的计算机添加到您的Android设备。</p><p>如果您是iOS用户，可以使用Coolmuster iOS Assistant轻松地在 iPhone 和电脑之间传输数据。与Android版本类似，它可以让您管理联系人、照片、信息和其他重要文件，确保流畅的传输体验。</p><p>结尾</p><p>“Send Anywhere 无法正常工作”是一个常见问题，但通常可以解决。大多数问题都可以通过检查网络连接、重启应用或设备、更新软件或重新安装应用来解决。如果您正在寻找更专业的手机间或Android设备与电脑间传输解决方案， Coolmuster Mobile Transfer和Coolmuster Android Assistant是可靠的替代方案。</p><p>如果您在使用 Send Anywhere 时遇到任何其他棘手问题，请随时在评论中分享，我们将一起寻找解决方案。<br/>​</p>]]></description></item><item>    <title><![CDATA[LAMMPS 教程：以单晶铝为例，模拟材]]></title>    <link>https://segmentfault.com/a/1190000047433198</link>    <guid>https://segmentfault.com/a/1190000047433198</guid>    <pubDate>2025-11-27 19:05:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>LAMMPS（Large-scale Atomic/Molecular Massively Parallel Simulator）是一种经典的分子动力学仿真代码，专注于材料建模。它旨在在并行计算机上高效运行，并且易于扩展和修改。LAMMPS 最初由美国能源部机构桑迪亚国家实验室开发，现在包括来自许多机构的许多研究小组和个人的贡献。LAMMPS 的大部分资金来自美国能源部（DOE）。LAMMPS 是根据 GNU 公共许可证版本 2（GPLv2）的条款分发的开源软件。  <br/>在本次教程中，我们通过改变材料的晶格常数，实现模拟对施加材料单轴应变的情况，后续再计算并绘制材料的应变应力曲线。通过本教程的学习您将学会：</p><ol><li>使用 npt 让系统结构达到弛豫</li><li>使用 fix 结合 variable 命令改变晶格常数</li><li>使用 compute 命令计算系统应力</li></ol><p><strong>教程链接：<a href="https://link.segmentfault.com/?enc=GcAmHDQpF2VdQR1F%2Fl5z0g%3D%3D.TFreogrxIPjyvIRdrD5gmo3RRqXBbZRKtJ6iuQUhXjw%3D" rel="nofollow" target="_blank">https://go.openbayes.com/kuLKA</a></strong>  </p><p><strong>该教程将在云平台 <a href="https://link.segmentfault.com/?enc=jSt56rrWjkItMBRBg0FMYw%3D%3D.EXO8IeHduF59w43lltkOhrBkKTpVS7RtU0MBVzWo%2FyU%3D" rel="nofollow" target="_blank">http://OpenBayes.com</a> 上进行演示，使用下方邀请链接注册即可获得 4 小时 RTX 5090 免费使用时长：</strong>  <br/><a href="https://link.segmentfault.com/?enc=S5uqhZVT28MiZrjZ538%2BIQ%3D%3D.QfptfDCvOfAmLZT%2Bzqrekxrkb9l%2BZn8E17Okz3OG0u6w3EUk8LdJo6NeBIrYD4PGK5I9T7HUP02bM1yy5mRZ%2Fg%3D%3D" rel="nofollow" target="_blank">https://openbayes.com/console/signup?r=Dennis9801_1ohB</a></p><h2>一、输入文件说明</h2><p>本次教程将会用到以下输入文件：</p><ul><li><strong>Al99.eam.alloy</strong> 材料的 eam 势</li><li><strong>in.txt</strong> 输入文件</li><li><strong>pl.py</strong> 绘制图像脚本</li></ul><p><strong>系统初始化与基础设置</strong></p><pre><code>units metal               # 采用金属单位制（长度：Å，时间：ps，质量：g/mol，能量：eV等）
dimension 3               # 三维空间模拟
boundary p p p            # 三个方向均为周期性边界条件（模拟无限大晶体）
atom_style atomic         # 原子类型为「基本原子」，仅包含位置和类型信息
variable latparam equal 4.05  # 定义铝的晶格常数为 4.05Å（FCC 铝的典型值）</code></pre><p><strong>原子结构构建</strong></p><pre><code>lattice  fcc ${latparam} orient x 1 0 0 orient y 0 1 0 orient z 0 0 1  # 定义 FCC 晶格
# 晶格常数为 ${latparam}，晶向沿 x[100]、y[010]、z[001]（标准笛卡尔坐标系）

region whole block 0 10 0 10 0 10  # 定义模拟区域：一个立方体，在 x、y、z 方向各包含 10 个晶格常数长度
create_box 1 whole                 # 创建容纳原子的「盒子」，仅包含 1 种原子类型，边界为上述 region 定义的范围
create_atoms 1 region whole        # 在盒子内填充类型为 1 的原子，按 FCC 晶格排列</code></pre><p><strong>原子间相互作用势设置</strong></p><pre><code>pair_style eam/alloy  # 采用嵌入原子法（EAM）合金势描述原子间相互作用（适合金属体系）
pair_coeff * * Al99.eam.alloy Al  # 配置势函数参数：
                                  # - 第一个*：所有原子类型（此处仅 1 种）
                                  # - 第二个*：所有原子类型的相互作用
                                  # - Al99.eam.alloy：势函数文件（预训练的铝势）
                                  # - Al：指定原子类型 1 对应元素为铝</code></pre><p><strong>计算量定义（用于后续分析）</strong></p><pre><code>compute csym all centro/atom fcc  # 计算每个原子的中心对称参数（用于识别 FCC 结构完整性，缺陷处会偏离）
compute peratom all pe/atom       # 计算每个原子的势能（用于分析能量分布）</code></pre><p><strong>平衡模拟阶段（消除初始应力，达到稳定状态）</strong></p><pre><code>reset_timestep 0  # 重置时间步计数器为 0（平衡阶段作为新起点）
timestep 0.001    # 时间步长为 0.001ps（即 1fs，金属模拟常用精度）

#初始化原子速度：温度 300K（室温），随机种子 12345，消除整体动量（mom yes）和旋转（rot no）
velocity all create 300 12345 mom yes rot no
#施加 NPT 系综（恒温、恒压、恒粒子数）进行平衡：
#- temp 300 300 1：温度维持 300K，热浴阻尼系数 1（单位：ps）
#- iso 0 0 1：各向同性压力控制，目标压力 0bar，压力阻尼系数 1（单位：ps）
#- drag 1：原子运动阻尼系数（用于稳定系综）
fix 1 all npt temp 300 300 1 iso 0 0 1 drag 1 
#热力学输出设置：
thermo 1000  #每 1000 步输出一次热力学信息
thermo_style custom step lx ly lz press pxx pyy pzz pe temp  #输出内容：
                                                             #步数、盒子尺寸（x/y/z）、总压力、压力张量分量、势能、温度
run 20000  #运行 20000 步平衡模拟（总时间20000×0.001ps=20ps）
unfix 1    #平衡结束，移除 NPT 约束
#记录平衡后的 x 方向盒子长度（用于后续计算应变）
variable tmp equal "lx"  #临时变量存储当前 x 方向长度
variable L0 equal ${tmp}  #定义 L0 为初始长度（拉伸前的平衡长度）
print "Initial Length, L0: ${L0}"  #输出初始长度，便于验证</code></pre><p><strong>单轴拉伸变形阶段</strong></p><pre><code>reset_timestep 0  #重置时间步计数器为 0（拉伸阶段作为新起点）

#重新施加 NPT 系综，但仅控制温度和横向压力：
#- temp 300 300 1：维持温度300K
#- y 0 0 1 z 0 0 1：y 和 z 方向压力保持 0bar（横向自由，模拟单轴拉伸）
fix 1 all npt temp 300 300 1 y 0 0 1 z 0 0 1 drag 1
#定义拉伸速率：
variable srate equal 1.0e10  #应变速率为 1e10 /s（分子动力学常用高应变速率，远高于实验）
variable srate1 equal "v_srate / 1.0e12"  #转换为LAMMPS单位（应变速率单位：ps⁻¹，1e10/s = 1e-2 ps⁻¹）
#施加 x 方向拉伸变形：
#- deform 1 x：沿 x 方向变形，变形组为 1（所有原子）
#- erate ${srate1}：按上述应变速率拉伸
#- units box：变形基于盒子尺寸
#- remap x：原子坐标随盒子拉伸同步更新（避免原子「跑出」盒子）
fix 2 all deform 1 x erate ${srate1} units box remap x</code></pre><p><strong>拉伸过程数据输出</strong></p><pre><code>#定义应变和应力变量：
variable strain equal "(lx - v_L0)/v_L0"  #工程应变 =（当前x长度 - 初始长度）/ 初始长度
variable p1 equal "v_strain"              #p1 对应工程应变（无量纲）
variable p2 equal "-pxx/10000"            #x 方向应力（GPa）：pxx 为 LAMMPS 内置压力张量（单位 bar），负号转为拉应力，除以 10000 转换为 GPa
variable p3 equal "-pyy/10000"            #y 方向应力（GPa）
variable p4 equal "-pzz/10000"            #z 方向应力（GPa）

#输出应变-应力数据到文件：
#- 每 100 步输出一次 p1（应变）、p2（x 应力）、p3（y 应力）、p4（z 应力）
#- 保存到 Al_tens_100.def1.txt，不在屏幕显示
fix def1 all print 100 "${p1} ${p2} ${p3} ${p4}" file Al_tens_100.def1.txt screen no
#输出原子轨迹文件（用于可视化）：
#- 每 100 步保存一次，文件名为 md.lammpstrj
#- 包含原子 ID、类型、x/y/z 坐标
dump trace all custom 100 md.lammpstrj id type x y z
#热力学信息输出设置：
thermo 1000  #每 1000 步输出一次
thermo_style custom step v_strain temp v_p2 v_p3 v_p4 ke pe press  #输出步数、应变、温度、三方向应力、动能、势能、总压力
run 30000  #拉伸阶段运行 30000 步（总时间 30ps，累积应变约0.3）</code></pre><p><strong>模拟结束</strong></p><pre><code>print "All done"  # 输出完成信息，提示模拟结束</code></pre><h2>二、操作步骤</h2><ol><li><strong>克隆并启动容器</strong></li></ol><p>登录 OpenBayes.com ，在「公共教程」页面，选择「LAMMPS：以单晶铝为例，模拟材料单轴拉伸」教程。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433201" alt="图片" title="图片"/></p><p>页面跳转后，点击右上角「克隆」，将该教程克隆至自己的容器中。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433202" alt="图片" title="图片" loading="lazy"/></p><p>选择「NVIDIA GeForce RTX 4090」以及「lammps」镜像，OpenBayes 平台提供了 4 种计费方式，大家可以按照需求选择「按量付费」或「包日/周/月」，点击「继续执行」。可以使用文章开头的邀请链接，获得 RTX 4090 使用时长！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433203" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433204" alt="图片" title="图片" loading="lazy"/></p><p>待系统分配好资源，当状态变为「运行中」后，点击「打开工作空间」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433205" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433206" alt="图片" title="图片" loading="lazy"/></p><p><strong>2. 运行 lammps</strong></p><p>打开「终端」，输入以下命令运行 lammps。</p><pre><code>mpirun --allow-run-as-root -np 2 lmp -sf gpu -pk gpu 1 &lt; in.txt </code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433207" alt="图片" title="图片" loading="lazy"/></p><p><strong>3. 文件输出</strong></p><p>待模型处理完成后，会得到两个输出文件：  <br/><strong>Al_tens_100.def1.txt</strong>：应变 - 应力曲线数据，可用于分析弹性模量、屈服强度等力学性能。  <br/><strong>md.lammpstrj</strong>：原子轨迹文件，可通过 VMD、Ovito 等软件可视化拉伸过程中的晶体结构演变</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433208" alt="图片" title="图片" loading="lazy"/></p><p><strong>4. 绘制应变-应力图像</strong></p><p>输入以下命令即可得到绘制的应变-应力曲线图。</p><pre><code>python pl.py</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433209" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433210" alt="图片" title="图片" loading="lazy"/></p><p>此外，我们还可以将「md.lammpstrj」文件下载到本地并载入到 VMD、Ovito 等软件，得到实时模型。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433211" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433212" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433213" alt="图片" title="图片" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[AlmaLinux 10.1 发布 - ]]></title>    <link>https://segmentfault.com/a/1190000047433250</link>    <guid>https://segmentfault.com/a/1190000047433250</guid>    <pubDate>2025-11-27 19:04:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>AlmaLinux 10.1 发布 - RHEL 二进制兼容免费发行版</p><p>由社区提供的免费 Linux 操作系统，RHEL 二进制兼容发行版</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=Ch%2B1M6bytON4isEklWabog%3D%3D.9pA%2BPqoQ0Mt%2FJX1mRoHWoyk2%2FQfq0BYplUMdeTyDJIs7lJNZiz9kICXs7hLl7PpI" rel="nofollow" target="_blank">https://sysin.org/blog/almalinux-10/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=3lVfTpuv7HJNHVgr0MNiWw%3D%3D.4kbccVshu9ZAekNvVg5tOZSJjaManYo9KlLSKAzyY1w%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>2025 年 11 月 25 日，AlmaLinux OS 10.1（代号 “Heliotrope Lion”）正式发布！</p><p>AlmaLinux OS 10.1 的亮点包括对 Btrfs file system 的支持、SPICE 支持、默认启用 frame pointers、在新的 AlmaLinux OS 安装中默认启用 CRB repository，以及对 x86_64_v2 处理器的扩展支持。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044411005" alt="almalinux-logo" title="almalinux-logo"/></p><p>由社区提供的免费 Linux 操作系统</p><p>一个开源、社区拥有和管理、永远免费的企业 Linux 发行版，专注于长期稳定性，提供强大的生产级平台 (sysin)。AlmaLinux OS 与 RHEL 二进制兼容。</p><p>注：既 Redhat “闭源事件” 之后，AlmaLinux OS 基金会董事会决定放弃与 RHEL 1:1 的目标。AlmaLinux 操作系统的目标是与 RHEL 二进制兼容。</p><h2>AlmaLinux OS 10.1 Stable 现已发布</h2><p>Hello Community！AlmaLinux OS Foundation 宣布 AlmaLinux OS 10.1（代号 “Heliotrope Lion”）正式发布！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433252" alt="AlmaLinux OS 10.1" title="AlmaLinux OS 10.1" loading="lazy"/></p><p>适用于所有架构的安装 ISO 现已在映像站提供：</p><ul><li><a href="https://link.segmentfault.com/?enc=ryIhviBCMvKFZN63XeBu0A%3D%3D.rxahowKnNC9Qq%2FMmIKLOrdyGAzVUzJ%2BcEeudI3tsmOzffWSnODab9Zn2EkbmSXyUKFZe1pyQaCiBqvyg57arow%3D%3D" rel="nofollow" target="_blank">Intel/AMD (x86_64)</a></li><li><a href="https://link.segmentfault.com/?enc=ZY%2B78VCYtB%2FXTt%2B8WrumRA%3D%3D.fIVf2WRSEIxyD1UmYkkRySygTNJyNejOAmAD4%2FudCxOjLWAx1MJ7juA6x67%2BrbYZBQNXEswA7%2Fp3UTJSn79eRQ%3D%3D" rel="nofollow" target="_blank">Intel/AMD (x86_64_v2)</a></li><li><a href="https://link.segmentfault.com/?enc=Dffir7Dapo%2FCEQpQYVXfig%3D%3D.ZlUSq21d75Mvp3O3owtfdHAVfdXngCmhX654OtOTILCK2GT5UYA03MqkUEhFcENAL3giKh1c%2BLNpO52KEkqDig%3D%3D" rel="nofollow" target="_blank">ARM64 (aarch64)</a></li><li><a href="https://link.segmentfault.com/?enc=JpjsrC3GYwve%2BzFLgEHUeA%3D%3D.OCrlIQ4Zm3chQa813mmcwu8qL4E6OXURzUebkUZQbX%2BZGsF4QvXJ6eNIu2l1bRa33WBjZxwFKBvqRH6drCk%2F7w%3D%3D" rel="nofollow" target="_blank">IBM PowerPC (ppc64le)</a></li><li><a href="https://link.segmentfault.com/?enc=aWAvPJYISIL8y0FpQqILLw%3D%3D.dGDz9QCFKfLk5XIPi%2B6%2BBwE7s0Uqi3dBg86shNM1qo9usbtC6xUiC29WroANlE8BIBATfXilaf%2BmfMel8%2FfyvA%3D%3D" rel="nofollow" target="_blank">IBM Z (s390x)</a></li></ul><p>✅ <strong>ISOs、Live Images、Cloud 和 Containers</strong></p><p>AlmaLinux 同样提供多种 Cloud、Container 和 Live Image。相关构建会在公共仓库准备就绪后立即启动。</p><p><strong>以下映像预计将很快提供：</strong></p><ul><li><a href="https://link.segmentfault.com/?enc=%2Flx3LMbpCXzB9OOxbkNajA%3D%3D.RCInu1N0aNPUenOHRHMrj5t%2BMQHEDljH3b%2FQRvYgEJ%2FzPURYQDI%2BmNOLJbysVL%2FS" rel="nofollow" target="_blank">Container</a> 镜像，包括 Platform 和 UBI 替代版本。AlmaLinux 为你提供种类丰富的容器镜像。</li><li><a href="https://link.segmentfault.com/?enc=6rfj5qGoDG0Vr5IZZrXBVg%3D%3D.hlfJKJvaUrAPfEZ6VrNNFF1nhgPSvF4DLGM4S1X2lbITjj6FzR%2B%2B5TGYD%2F5I3iKahMrwa%2FgOKoFs0J1dkfedVg%3D%3D" rel="nofollow" target="_blank">LXC/LXD</a></li><li><a href="https://link.segmentfault.com/?enc=4yoi6khvjjG%2BLHyOuXKOEA%3D%3D.7OwFwZFfRIJcFgg5jeK3%2FhTcg47ofCsXeD2N7xFUjpL%2BV6sFRk2dkBM1F5tu11IR" rel="nofollow" target="_blank">Live Media</a></li><li><p>Cloud Images</p><ul><li>适用于 x86_64 与 AArch64 EC2 Instances 的 <a href="https://link.segmentfault.com/?enc=WTWKRG%2BWsGLCPGZ%2FdsgNPg%3D%3D.kYMZ9%2FnJVRLtxc9Mf2zFRjVRioLomJx1%2BS2da4bH6%2F9nNGLmqaOBNC3BH00ybpBo" rel="nofollow" target="_blank">AWS</a></li><li>适用于 x86_64 与 AArch64 VMs 的 <a href="https://link.segmentfault.com/?enc=f%2FAsVejqVRyvwwbRmek0yA%3D%3D.3iyt9W3IYn5P4e7L8t4ANYyQUJOK1NxUo%2BBzfwf6n1lKoDp2VPskXZ%2B2imKSwl2y" rel="nofollow" target="_blank">Azure</a></li><li><a href="https://link.segmentfault.com/?enc=rkBpDnCbA8VKm3iJ0cLDAA%3D%3D.Bv5Ra1%2FMPHt5xhCHzZsCTbG%2BJ%2BLBhqDO2omv%2Fet8eCk2akv5impU69q82nLELQB2" rel="nofollow" target="_blank">Google Cloud</a></li><li>适用于所有支持架构（包括 x86-64-v2）的 <a href="https://link.segmentfault.com/?enc=18oorpWUF%2FC6Fawp6ima9Q%3D%3D.Jeu6jsgG%2B%2FS%2BxF%2B6XSqGnl07WzH09zeZTvSze%2F819pxxNe1T3H%2FO8WfFJunzZfR1Iy9PzPFUMWc3yNzlYZdYOA%3D%3D" rel="nofollow" target="_blank">Generic Cloud/Cloud-init</a></li><li>适用于 x86_64 与 AArch64 架构的 <a href="https://link.segmentfault.com/?enc=PtrzVkLjlymInx9JVecfKg%3D%3D.CDzomdWsOxZTvvP3Vgk1KIMcfco4XY4vyFMhlNUPNvawqpLa2RitiFbUkKruYAbBnN6VJROXq0seiR4i3v8Fog%3D%3D" rel="nofollow" target="_blank">OpenNebula</a></li><li>适用于 x86_64 与 AArch64 Instances 的 <a href="https://link.segmentfault.com/?enc=Z2cdzwQEWVdeaIPY5i9Nog%3D%3D.gEh5BLEimfZApAkAlXBZoLJ%2FPNx0b1mXiU3WVW1A1KQgkN5CMEX5oVwzk60kb2Ki" rel="nofollow" target="_blank">Oracle Cloud Infrastructure</a></li></ul></li><li><p>Vagrant Boxes：</p><ul><li>Libvirt</li><li>VirtualBox</li><li>Hyper-V</li><li>VMWare</li></ul></li><li><a href="https://link.segmentfault.com/?enc=CHBwjRzli16Q%2B4n1hr%2FeQQ%3D%3D.E%2BMUxtCDGZxOBSWCbUqurrv%2BiNmFF8tIOZWfkN5w7zykn4dYuOrIZYccLubA4H90E%2BZYjix25OjlG7a9tiel5A%3D%3D" rel="nofollow" target="_blank">Raspberry Pi</a></li><li>适用于 x86_64 和 AArch64 的 <a href="https://link.segmentfault.com/?enc=wkC3vWyxWe0HuoQUvmVJHw%3D%3D.ZxWk%2F6pAcLKRnCDqJly95CasPELoYbmMZC5kpajtJofy2VJG6CtcfNq9FQFtEhcxkYsOPMhdvz9oAYMvUcTOmQ%3D%3D" rel="nofollow" target="_blank">Windows Subsystem for Linux</a></li></ul><p>✅ <strong>Btrfs 支持</strong></p><p>AlmaLinux 10.1 现在 <a href="https://link.segmentfault.com/?enc=imPaAgohs9Men7IGwf9G%2Bw%3D%3D.NwhyPjCCVxfFwer%2FKsiZV9PS0L79%2FMvJGibmR%2FJ3MM6eLSlbLm7ly1ZcuWAxk%2BijXyvFlriRm9056WpK5NTh3EDVNxAyJnPdvssJiBninBOGkZCGA5Ue15ke2NOzogoy" rel="nofollow" target="_blank">包含对 Btrfs filesystem 的支持</a>，该支持早在 9 月初已在 AlmaLinux OS Kitten 中提供。Btrfs 支持涵盖 kernel 与 userspace，使得从最初开始就能在 Btrfs filesystem 上安装 AlmaLinux OS。初始阶段主要集中在安装程序与存储管理栈 (sysin)，未来 AlmaLinux 软件集将提供更全面的 Btrfs 功能支持。</p><p>✅ <strong>其他改进</strong></p><p>除了 Btrfs 支持之外，AlmaLinux OS 10.1 还包含大量改进以更好地服务社区。AlmaLinux 持续扩展硬件支持，包括通过 <a href="https://link.segmentfault.com/?enc=9AcvKWysLUGXqMADIDVCyw%3D%3D.5Tcs9%2BtnsEVbxTYHOR7zuTMonD1FUsESnyGjn9F0sfECeVY7KVGVObUx0IMc66leqkGLgds1CG6%2Bj%2FEU1mqr4C9rddeFrzyLmThZjXyxFTA%3D" rel="nofollow" target="_blank">添加 drivers</a>，以及为 x86_64_v2 处理器添加 AlmaLinux OS 和 <a href="https://link.segmentfault.com/?enc=CehIXl0V0Qq0xNtA97on7w%3D%3D.7U5J0BYd9SBOLvo5wQicV8h8Tc7Fb0f5VMmp6rGFYsyQDfsNmSzLyu%2FrAMlCCGfDYG33nNO6f%2BfGdqMDUa%2FhKAJYrLBteg9i8teKmWvMzKA%3D" rel="nofollow" target="_blank">EPEL</a> 的二级版本。</p><p>AlmaLinux 还重新启用了 SPICE 支持，并默认重新启用 frame pointers。同时 AlmaLinux 继续在虚拟化栈中启用 IBM POWER 的 KVM，并在新安装的 AlmaLinux OS 中 <a href="https://link.segmentfault.com/?enc=RHgAPvIkJWY6n3RU%2FihdLw%3D%3D.e%2FZHmpB9Ik%2B9ADyNcn6at43RzW9Zk3CJhiIw7x2LnQVCvnbyFw6OfALTnwm9%2B3%2FE2uRYL8O9c476xsMn9lN0jjvIje15wJErkr7KCnvUTeM%3D" rel="nofollow" target="_blank">默认启用 CRB repository</a>。</p><p>完整改进列表可在 <a href="https://link.segmentfault.com/?enc=fAbQXl%2FX%2BIQkZdRGMr4axg%3D%3D.ytu%2BTMlBDd6yyUJLNN474FIiI2fVBJHh3VV2C0okQ90Spzq8ZPA2hfBR9FaeVPofcGx%2BkSpyC0Kltqm6HeCdwg%3D%3D" rel="nofollow" target="_blank">AlmaLinux OS 10.1 Release Notes</a> 中查看。</p><p>✅ <strong>Release Notes 与更多信息</strong></p><p>AlmaLinux 10.1 引入性能增强、更新的开发工具以及改进的安全性 (sysin)。本次发布带来新的 compiler toolsets 与更新的 module streams，并改进了 debugging 与 networking 工具。Container 与 virtualization 支持通过最新版 Podman 与 Buildah 获得增强。安全性方面，通过更新 SELinux policies、支持后量子密码学的 OpenSSL，以及更新版本的 SSSD 与 Keylime 得到加强。</p><p>你可以在 wiki 查看完整版本说明：<a href="https://link.segmentfault.com/?enc=XMrON51vKKaal2bgVzyQjw%3D%3D.h8zIdphM9LkLuaSPRzRU9BogZWks%2FfEsRA8t1qB96FS2sOwkA%2FNC97u0AqBBMdXwTdGhM2y%2BxsYZhQNq5yGbZw%3D%3D" rel="nofollow" target="_blank">AlmaLinux OS 10.1 Release Notes</a>。</p><h2>关于 AlmaLinux 操作系统</h2><p>AlmaLinux OS 是一个开源的、社区驱动的 Linux 操作系统，它填补了 CentOS Linux 稳定版本停产留下的空白 (sysin)。AlmaLinux OS 是 RHEL® 的 1:1 二进制兼容分支。由社区引导和建设。</p><p>作为一个独立的、完全免费的操作系统，AlmaLinux OS 享有 CloudLinux Inc 每年 100 万美元的赞助和其他赞助商的支持。正在进行的开发工作由社区成员管理。</p><p>AlmaLinux OS 基金会是一个 501©(6) 非营利组织，旨在为 AlmaLinux OS 社区带来利益。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045485567" alt="penguins" title="penguins" loading="lazy"/></p><h2>下载地址</h2><p><strong>AlmaLinux 10.1</strong>：</p><ul><li><a href="https://link.segmentfault.com/?enc=OEV7cleoeLmwwebHiQPJww%3D%3D.0vuQg63v7SC8XaCkNaE8ikvPELgK%2FnbRb%2FprxgYaYXJhLwKc%2BF4wJDgqLsd0FBIMOEpEtuEEKoTFPEdjyV6kuA%3D%3D" rel="nofollow" target="_blank">Intel/AMD (x86_64)</a></li><li><a href="https://link.segmentfault.com/?enc=Ids978hW9JKJ1eeGfz1jcQ%3D%3D.VwBmYRCX8l%2F4cuD9BAAZpKqLbj36vVaLdaRrv57gcL0F0sGCIBnMmZCKfCtPPxMjHza3Ck7tmqJbVdpsPOeEqA%3D%3D" rel="nofollow" target="_blank">Intel/AMD (x86_64_v2)</a></li><li><a href="https://link.segmentfault.com/?enc=ASD3ZWkktSmEReNkGAWj9Q%3D%3D.lXbBvTLs%2BWyTaHQLm%2Fg%2FapHNYffP%2BBqi23Z7oedRXGCn0FQtA5dB43Pm6FjohIP%2F%2BiK9IJPZ5WJGbKnC8HJqgQ%3D%3D" rel="nofollow" target="_blank">ARM64 (aarch64)</a></li><li><a href="https://link.segmentfault.com/?enc=UgJCN5Ibdb%2FDqorjX2r5uA%3D%3D.nCuWhshnQM4LFoQn5flt4Toic5JTguGjKIUa%2BJuYwicoNIF%2F%2FKW2UkdhFswIBVVcNs7DEdokIQFz3LVaIQJeZQ%3D%3D" rel="nofollow" target="_blank">IBM PowerPC (ppc64le)</a></li><li><a href="https://link.segmentfault.com/?enc=cULfSZ6oomIDl6WopATdqg%3D%3D.ENri9BHJvyuN9hxaraLjxRf%2F1RjWCnETu0t81adTFFySuspJ9PSGThOUHidZT1ZENIleOo3BKg8fwZuvzFUkoQ%3D%3D" rel="nofollow" target="_blank">IBM Z (s390x)</a></li></ul><p>AlmaLinux 10 上游来自于 <a href="https://link.segmentfault.com/?enc=fY0Niuudq%2FE0qoZirIl%2BAw%3D%3D.SI3xp89WLyGVjW4jGq%2FHBlqcqMs6hmdayEOoqNUv9zA%3D" rel="nofollow" target="_blank">Red Hat Enterprise Linux 10 Release</a></p><p>虚机模板下载：</p><ul><li><a href="https://link.segmentfault.com/?enc=ViL37Q7lmQuGp5ik%2BWD8lQ%3D%3D.ctFhu3zn7ronESh%2BfsvVi60sD2E5a6goYnop1yz7ZJ1IGxHG%2FOIf6fS7tjo5kQlS" rel="nofollow" target="_blank">AlmaLinux 10 x86_64 OVF (sysin) - VMware 虚拟机模板</a></li></ul><hr/><p>更多：<a href="https://link.segmentfault.com/?enc=X2W%2BpNZKhXuvtEcbSv5E%2FA%3D%3D.EbSMymr10%2FlRE7e%2By%2B9SeYd9ofAzWAgG8CQ6n3vhSi8%3D" rel="nofollow" target="_blank">Linux 产品链接汇总</a></p>]]></description></item><item>    <title><![CDATA[教程上新丨美团开源视频生成模型LongC]]></title>    <link>https://segmentfault.com/a/1190000047433265</link>    <guid>https://segmentfault.com/a/1190000047433265</guid>    <pubDate>2025-11-27 19:04:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>世界模型旨在理解、模拟与预测复杂的现实世界环境，是人工智能在真实场景中实现有效应用的重要基础。在这一框架中，视频生成模型通过其生成过程，逐步压缩并学习几何、语义、物理等多种知识形态，<strong>因而被视为构建世界模型的一条关键路径，并有望最终实现对真实物理世界动态的有效模拟与预测。</strong> 而在视频生成领域，实现高效的长视频生成能力尤为重要。</p><p>基于此，<strong>美团开源了最新视频生成模型 LongCat-Video，该模型旨在通过统一的架构处理多种视频生成任务，包括文生视频（Text-to-Video）、图生视频（Image-to-Video）以及视频续写（Video-Continuation）。</strong> 凭借其在通用视频生成任务中的出色表现，LongCat-Video 被研究团队视作向构建真正「世界模型」迈出的坚实一步。</p><p>LongCat-Video 的主要特点包括：</p><p><strong>多任务统一架构。</strong> LongCat-Video 将文生视频、图生视频和视频续写任务统一在一个视频生成框架内，通过条件帧的数量来加以区分；</p><p><strong>长视频生成能力。</strong> LongCat-Video 基于视频续写任务进行预训练，使其能够生成长达数分钟的视频，并在生成过程中有效避免颜色失真或其他形式的画面质量退化；</p><p><strong>高效推理。</strong> LongCat-Video 采用「由粗到细」的策略，在几分钟内生成 720p、30fps 视频，有效提升了视频生成精度和效率；</p><p><strong>多奖励强化学习框架（RLHF）的强大性能。</strong> LongCat-Video 采用组相对策略优化（GRPO），通过使用多个奖励进一步提升模型性能，实现了与领先的开源视频生成模型以及最新的商业解决方案相当的性能。</p><p>基于内部基准的性能评估，LongCat-Video 在文生视频任务中，<strong>在视觉质量和动作质量方面表现出色，其得分几乎与顶尖模型 Wan2.2 持平。</strong> 在文本对齐、整体质量上，该模型也取得了稳健结果，为用户提供了多维度一致的高质量体验。</p><p><img width="723" height="172" referrerpolicy="no-referrer" src="/img/bVdnbIF" alt="" title=""/></p><p>基于内部基准测试的文生视频 MOS 评估结果</p><p>在图生视频任务中，LongCat-Video 在视觉质量上值得关注，得分领先 Wan2.2 等其他模型，表明其在生成画面质量方面的突出优势。在图像对齐、整体质量等方面，则仍有改进空间。</p><p><img width="723" height="144" referrerpolicy="no-referrer" src="/img/bVdnbIG" alt="" title="" loading="lazy"/></p><p>基于内部基准测试的图生视频 MOS 的评估结果</p><p>目前，「LongCat-Video：美团开源的 AI 视频生成模型」已上线 OpenBayes 公共教程板块，点击下方链接即可体验一键部署教程 ⬇️</p><p><strong>教程链接：</strong></p><p><strong><em><a href="https://link.segmentfault.com/?enc=jhlV41PmJiekqz5WLFbJxA%3D%3D.colFmglgR4835vJnySincUEhxognhXbeIl9z%2Fc%2Fu58Q%3D" rel="nofollow" target="_blank">https://go.openbayes.com/SbubB</a></em></strong></p><h2><strong>Demo 运行</strong></h2><p><strong>01 Demo 运行阶段</strong></p><p>1.登录 OpenBayes，在「公共教程」页面，选择「LongCat-Video：美团开源的 AI 视频生成模型」教程。</p><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdnbIH" alt="" title="" loading="lazy"/></p><p>2.页面跳转后，点击右上角「克隆」，将该教程克隆至自己的容器中。</p><p><img width="723" height="358" referrerpolicy="no-referrer" src="/img/bVdnbII" alt="" title="" loading="lazy"/></p><p>3.选择「NVIDIA RTX PRO 6000 Blackwell Server Edition」以及「PyTorch」镜像，按照需求选择「按量付费」或「包日/周/月」，点击「继续执行」。新用户使用下方邀请链接注册，可获得 4 小时 RTX 5090 + 5 小时 CPU 的免费时长！</p><p>小贝总专属邀请链接（直接复制到浏览器打开）：</p><p><strong><em><a href="https://link.segmentfault.com/?enc=H0%2BEPIv6GiEv5t9dLCn%2BYw%3D%3D.qQ%2FD4a5bY4fiuRB9Hp989w9MHFXtxOn11FxpogZW5FM%3D" rel="nofollow" target="_blank">https://go.openbayes.com/9S6Dr</a></em></strong></p><p><img width="723" height="358" referrerpolicy="no-referrer" src="/img/bVdnbIJ" alt="" title="" loading="lazy"/></p><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdnbIK" alt="" title="" loading="lazy"/></p><p>4.等待分配资源，首次克隆需等待 3 分钟左右的时间。当状态变为「运行中」后，点击「API 地址」旁边的跳转箭头，即可跳转至 Demo 页面。请注意，用户需在实名认证后才能使用 API 地址访问功能。</p><p><img width="723" height="357" referrerpolicy="no-referrer" src="/img/bVdnbIL" alt="" title="" loading="lazy"/></p><p><strong>02 效果演示</strong>  </p><p>进入 Demo 运行界面后，可以选择 Image-to-Video、Text-to-Video、Long Video 和 Video Continuation 四个示例进行测试。本文选择 Image-to-Video 图生视频进行示例。</p><p>将示例图片上传后，输入 Prompt，在「Advanced Options」中可以对生成视频的负面提示词、分辨率、生成过程的随机性起点等参数进行更多设置，以实现更理想的生成效果。</p><p><img width="723" height="269" referrerpolicy="no-referrer" src="/img/bVdnbIM" alt="" title="" loading="lazy"/></p><p><img width="723" height="217" referrerpolicy="no-referrer" src="/img/bVdnbIN" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[菲律宾国际网络专线怎么开通？一年多少钱？]]></title>    <link>https://segmentfault.com/a/1190000047433275</link>    <guid>https://segmentfault.com/a/1190000047433275</guid>    <pubDate>2025-11-27 19:03:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>近年来，菲律宾电商、直播、电信及本地服务行业增长迅速，Shopee、TikTok、Lazada、Facebook Marketplace 等平台在菲律宾的渗透率越来越高，吸引大量国内企业进入菲律宾市场开展跨境电商、直播运营、短视频带货、云办公等业务。</p><p>然而，国内企业在运营菲律宾业务时往往遇到一个共同难题：访问菲律宾本地应用网络慢、延迟高、卡顿严重、跨国链路不稳定。尤其是做直播、广告投放、系统办公时，网络问题严重影响运营效果。</p><p>因此，越来越多企业选择使用菲律宾国际网络专线 或 SD-WAN 跨境专线来提升网络质量，实现高速、稳定、可控的跨境业务连接。</p><p>一、菲律宾不同场景对于网络的要求</p><p>不同业务场景对网络的要求不同，选择合适线路非常关键。</p><ol><li>跨境直播(TikTok、Facebook)</li></ol><p>需要稳定上行带宽</p><p>要求低延迟、不卡顿</p><p>网络波动会影响直播推流与实时互动</p><ol start="2"><li>跨境电商运营(Shopee、Lazada)</li></ol><p>SSO 登录要求稳定</p><p>访问卖家后台需连续、低丢包</p><p>用菲律宾本地 IP 才能正常跑广告、投放</p><ol start="3"><li>菲律宾团队远程办公</li></ol><p>在线 CRM、SaaS 办公系统需要稳定链路</p><p>VoIP 语音质量要清晰无抖动</p><p>多分支机构需要组网</p><ol start="4"><li>海外云服务器访问(AWS 菲律宾、GCP、Cloudflare)</li></ol><p>若从国内直接访问，会高延迟</p><p>需要专线加速保证业务系统稳定运行</p><p>综上，菲律宾方向的跨境业务对 低延迟、低丢包、高稳定性、固定 IP、专线质量 都有较强需求。</p><p>二、菲律宾国际网络专线怎么选择?</p><p>企业一般会在 传统国际专线 MPLS 和 SD-WAN 跨境专线 中选择：</p><p>方案 1：传统国际网络专线(MPLS / IPLC)</p><p>优点：</p><p>高度稳定</p><p>物理隔离链路</p><p>安全性强、延迟固定</p><p>缺点：</p><p>价格昂贵(往往数万至数十万元/年)</p><p>开通周期长(1–3 个月不等)</p><p>扩容不方便</p><p>适合大型企业、跨国公司、金融级场景。</p><p>方案 2：SD-WAN 国际专线(当前更主流)</p><p>优点：</p><p>性价比高（按需付费）</p><p>OSDWAN当日即可开通使用</p><p>可视化管理、智能分流、支援多链路</p><p>节点灵活，可选菲律宾、香港、新加坡等区域</p><p>缺点：</p><p>不同服务商质量差异较大</p><p>需选择稳定 POP 节点的供应商</p><p>适合：</p><p>外贸办公、跨境直播、跨境电商、远程办公、海外云服务访问、跨境公司多分支互联</p><p>总的来说，如果你不是金融、政府类机构，选择 SD-WAN 会更合适、成本低。</p><p>三、菲律宾国际网络专线怎么开通?</p><p>开通流程并不复杂，一般分为 3 步：</p><p>步骤 1：选择合适的服务商(推荐 OSDWAN)</p><p>选择服务商时要关注：</p><p>是否有菲律宾本地 POP 节点<br/>是否提供固定住宅 IP<br/>网络稳定性<br/>延迟、丢包表现<br/>是否支持试用<br/>售后是否快速响应</p><p>为什么推荐 OSDWAN（明点跨境）？</p><p>OSDWAN 是国内专注跨境网络的知名服务商，具有以下优势：</p><p>菲律宾、新加坡、香港等方向稳定性强<br/>具备多个国际专线通道<br/>价格比三大运营商更灵活<br/>提供 SD-WAN CPE 设备，可一键接入<br/>专线合规、安全可靠<br/>售后响应快，专为跨境行业优化<br/>适合跨境直播、TikTok 运营、电商团队、本地办公组网等。</p><p>步骤 2：准备开通资料</p><p>一般只需要：</p><p>企业营业执照<br/>实名信息<br/>使用场景说明<br/>线路国家<br/>带宽需求<br/>是否需要固定 IP</p><p>步骤 3：部署与开通</p><p>确认好节点，服务商提交信息给技术配置，安装 CPE 或 APP，测试延迟与丢包，确认无误后就可以正常使用了。</p><p>四、菲律宾国际网络专线价格(以 OSDWAN 为例)</p><p>以下为当前跨境行业常见价格区间(仅参考)：</p><p>OSDWAN提供灵活的计费模式，支持 按月、按年、带宽定制 多种方式。具体如下：</p><p>办公账号版：690元/年，适合外贸SOHO或小工作室使用</p><p>社媒运营套餐：1500元/年起：，TikTok运营、社媒矩阵、店铺运营(套餐详情咨询顾问)</p><p>标准版：10000元/年，适合10人以内团队使用或普清TK直播</p><p>企业版：自定义，100+地区的线路和IP可选，自由组合配置</p><p><img width="723" height="339" referrerpolicy="no-referrer" src="/img/bVdm4sv" alt="image.png" title="image.png"/></p><p>整体来看，OSDWAN 菲律宾专线价格比三大运营商低 50%–80%，且开通速度快，更灵活。</p><p>五、菲律宾国际网络专线常见问答(FAQ)</p><ol><li>是否必须使用菲律宾静态住宅 IP？</li></ol><p>不一定，但做广告、直播、电商运营时，静态住宅 IP 会更加稳定、风险更低。</p><ol start="2"><li>跨境直播必须用专线吗？</li></ol><p>普通网络容易出现延迟波动，严重影响直播，因此强烈建议使用 SD-WAN。</p><ol start="3"><li>开通后可以多个地点使用吗？</li></ol><p>可以，SD-WAN 支持多节点部署，非常适合多办公室或跨国团队。</p><ol start="4"><li>个人可以申请吗？</li></ol><p>支持，不过企业开通会更稳定，且可提供固定 IP。</p><ol start="5"><li>可以先试用吗？</li></ol><p>多数服务商支持短时测试，比如OSDWAN，如需试用可咨询我们的客服申请。</p><p>总结</p><p>菲律宾市场快速发展，跨境直播、电商、BPO 外包等行业对稳定、安全、低延迟的国际网络需求持续提升。相比传统专线，SD-WAN 国际专线成本更低、开通更快、适用性更强，是跨境企业最值得选择的方案。</p>]]></description></item><item>    <title><![CDATA[【隐语Secretflow】一文速通隐私]]></title>    <link>https://segmentfault.com/a/1190000047433286</link>    <guid>https://segmentfault.com/a/1190000047433286</guid>    <pubDate>2025-11-27 19:02:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047313097" alt="" title=""/></p><p>打开链接即可点亮社区Star，照亮技术的前进之路。</p><p>Github 地址：<em><a href="https://link.segmentfault.com/?enc=ndc8pnAryJWY13NrGSKwfA%3D%3D.6mgVkSHX6UiXvlTST6clgCb52Mmpwk3vHvSRSbu%2F8ur8KyMkLw6mtsUf5VjiXW7V" rel="nofollow" target="_blank">https://github.com/secretflow/kuscia</a></em></p><h2>Domain</h2><p>在 Kuscia 中将隐私计算的节点称为 Domain，一个 Domain 中可以包含多个 K3s 的工作节点（Node）。Kuscia<br/>复用了 K3s 的 Namespace 机制来管理节点权限，一个 Domain 对应 K3s 中的一个 Namespace。你可以使用 Domain 来管理和维护隐私计算节点。具体用例请参考下文。</p><h3>用例</h3><p>以下是一些 Domain 的典型用例：</p><ul><li>创建 Domain，你将体验如何使用 Domain 创建隐私计算节点相关的 Namespace, ResourceQuota 资源。</li><li>更新 Domain，你将熟悉如何更新现有的 Domain，从而变更隐私计算节点相关的 Namespace, ResourceQuota 资源。</li><li>清理 Domain，你将熟悉如何清理不需要的 Domain。在 Kuscia 中，清理 Domain 并不会真正的删除 Domain 相关的 Namespace, ResourceQuota 资源，而是会在节点相关的 Namespace 资源上添加标记 Domain 被删除相关标签。</li><li>参考 Domain 对象定义，你将获取详细的 Domain 描述信息。</li></ul><h3>创建 Domain</h3><p>下面以 <code>alice-domain.yaml</code> 的内容为例，介绍创建 Domain。</p><pre><code class="yaml">apiVersion: kuscia.secretflow/v1alpha1
kind: Domain
metadata:
  name: alice
spec:
  role: partner
  cert: base64&lt;certificate&gt;
  resourceQuota:
    podMaxCount: 100</code></pre><p>在该示例中:</p><ul><li><code>.metadata.name</code>：表示隐私计算节点 Domain 名称，当前示例为 <code>alice</code> 。相应地，Kuscia 控制器会创建名称和 Domain 同名的 <code>alice</code> Namespace 资源。在 Kuscia 中，通过 Namespace 资源对不同机构用户进行资源隔离。</li><li><p><code>.spec.role</code>：表示隐私计算节点 Domain 的角色，默认为 <code>""</code>。支持两种取值：<code>partner</code> 和 <code>""</code>。</p><ul><li><code>partner</code>：表示外部节点，用在点对点组网模式下的协作方节点。点对点组网模式下，需要在任务调度方的集群中创建协作方的 Domain，在创建该 Domain 时，需要将 <code>role</code> 的值设置为 <code>partner</code> 。</li><li><code>""</code>：表示内部节点。</li></ul></li><li><code>.spec.cert</code>：表示 BASE64 编码格式的隐私计算节点证书，该证书是配置文件中的 <code>domainKeyData</code> 私钥产生的，可以通过<a href="https://link.segmentfault.com/?enc=6hmYKIXkoEkP8fDyRuCqPQ%3D%3D.RAeT8HHn6lvqVqtayo65hWxLM2OONZFMdcWr1Tt16r6Ym5ER1EIXgb7o7xSHjnoIUZBKOB4sxFLL6LjfNzG82eN9NOpv4qban2cloyGbMvA%3D" rel="nofollow" target="_blank">这里</a>的命令生成。在中心化模式场景不需要填充该字段。</li><li><code>.spec.resourceQuota.podMaxCount</code>：表示 Domain 所管理的隐私计算节点命名空间（Namespace）下所允许创建的最大 Pod 数量，当前示例为 <code>100</code>。</li></ul><ol><li><p>运行以下命令创建 Domain。</p><pre><code class="shell">kubectl apply -f alice-domain.yaml</code></pre></li><li><p>检查 Domain 是否创建成功。</p><pre><code class="shell">kubectl get domain alice
NAME    AGE
alice   3s</code></pre></li><li><p>检查 Domain 相关的 Namespace, ResourceQuota 资源是否创建成功。</p><pre><code class="shell">kubectl get namespace alice
NAME     STATUS   AGE
alice    Active   18s

kubectl get resourcequota -n alice
NAME                  AGE   REQUEST      LIMIT
resource-limitation   18s   pods: 0/100</code></pre></li></ol><h3>更新 Domain</h3><p>下面以 <code>alice-domain.yaml</code> 的内容为例，介绍更新 Domain。</p><pre><code class="yaml">apiVersion: kuscia.secretflow/v1alpha1
kind: Domain
metadata:
  name: alice
spec:
  role: partner
  cert: base64&lt;certificate&gt;
  resourceQuota:
    podMaxCount: 200</code></pre><p>在该示例中:</p><ul><li>将 <code>.spec.resourceQuota.podMaxCount</code> 的值调整为 <code>200</code>。</li></ul><ol><li><p>运行以下命令更新 Domain。</p><pre><code class="shell">kubectl apply -f alice-domain.yaml</code></pre></li><li><p>检查 Domain 相关的 ResourceQuota 资源是否更新成功。</p><pre><code class="shell">kubectl get resourcequota -n alice
NAME                  AGE   REQUEST      LIMIT
resource-limitation   4m    pods: 0/200</code></pre></li></ol><h3>清理 Domain</h3><p>下面以 Domain <code>alice</code> 为例，介绍清理 Domain。</p><ol><li><p>运行以下命令清理 Domain。</p><pre><code class="shell">kubectl delete domain alice</code></pre></li><li><p>检查 Domain 是否已被清理。</p><pre><code class="shell">kubectl get domain alice
Error from server (NotFound): domains.kuscia.secretflow "alice" not found</code></pre></li><li><p>检查 Domain 相关的 Namespace, ResourceQuota 资源是否还存在。</p><pre><code class="shell">kubectl get namespace alice
NAME    STATUS   AGE
alice   Active   20m

kubectl get resourcequota -n alice
NAME                  AGE    REQUEST      LIMIT
resource-limitation   20m    pods: 0/200</code></pre></li><li><p>检查 Domain 相关的 Namespace 是否已添加标记被清理的标签。</p><pre><code class="shell">kubectl get namespace alice -L kuscia.secretflow/deleted
NAME    STATUS   AGE   DELETED
alice   Active   20m   true</code></pre></li></ol><h3>参考</h3><p>下面以 <code>domain-template</code> 模版为例，介绍 Domain 所包含的完整字段。</p><pre><code class="yaml">apiVersion: kuscia.secretflow/v1alpha1
kind: Domain
metadata:
  name: domain-template
spec:
  role: partner
  cert: base64&lt;certificate&gt;
  interConnProtocols:
  - kuscia
  resourceQuota:
    podMaxCount: 100
status:
  nodeStatuses:
    - lastHeartbeatTime: "2023-04-06T08:49:14Z"
      lastTransitionTime: "2023-04-04T12:20:40Z"
      name: 809406b513d3
      status: Ready
      version: e9a8013</code></pre><p>Domain <code>metadata</code> 的子字段详细介绍如下：</p><ul><li><code>name</code>：表示隐私计算节点 Domain 的名称，当前示例为 <code>domain-template</code> 。相应地，Kuscia 控制器会创建名称和 Domain 同名的 <code>domain-template</code> Namespace 资源。在 Kuscia 中，通过 Namespace 资源对不同机构用户进行资源隔离。</li></ul><p>Domain <code>spec</code> 的子字段详细介绍如下：</p><ul><li><p><code>role</code>：表示隐私计算节点 Domain 的角色，默认为<code>""</code>。支持两种取值：<code>partner</code>和 <code>""</code> 。</p><ul><li><code>partner</code>：表示外部节点，用在点对点组网模式下的协作方节点。 点对点组网模式下，需要在任务调度方的集群中创建协作方的 Domain，在创建该 Domain 时，需要将 <code>role</code> 的值设置为 <code>partner</code> 。</li><li><code>""</code>：表示内部节点。</li></ul></li><li><code>cert</code>：表示 BASE64 编码格式的隐私计算节点证书，该证书是配置文件中的 <code>domainKeyData</code> 私钥产生的，可以通过<a href="https://link.segmentfault.com/?enc=BOjAE8RUUdmWMGKD%2BsfyQg%3D%3D.mYWmSe4jAKB1v%2BjwNM0SYIcd7hiNPT7oSGJuD%2BSi2OPG3ltDkjYsOBBn1qhB98Ym6PcRHa3OnLLFE6v4FeGHOnMODQ9NUsEh0O0RYkhheEE%3D" rel="nofollow" target="_blank">这里</a>的命令生成。在中心化模式场景不需要填充该字段。</li><li><p><code>interConnProtocols</code>：表示外部隐私计算节点支持的互联互通作业协议类型，默认为 <code>""</code>。支持两种取值：<code>kuscia</code> 和 <code>bfia</code> 。当前该字段只支持配置一种协议，若配置多个协议，则会选择第一个协议作为互联互通作业的协议类型。未来会支持多种协议。</p><ul><li><code>kuscia</code>：表示该外部节点参与隐私计算任务时，会使用互联互通蚂蚁 <code>kuscia</code> 协议运行隐私计算任务。</li><li><code>bfia</code>：表示该外部节点参与隐私计算任务时，会使用互联互通银联 <code>bfia</code> 协议运行隐私计算任务。</li></ul></li><li><code>resourceQuota.podMaxCount</code>：表示 Domain 所管理的隐私计算节点 Namespace 下所允许创建的最大 Pod 数量，当前示例为 <code>100</code>。相应地，Kuscia 控制器会在 <code>domain-template</code> Namespace 下创建名称为 <code>resource-limitation</code> 的 ResourceQuota 资源。</li></ul><p>Domain <code>status</code> 的子字段详细介绍如下：</p><ul><li><p><code>nodeStatuses</code>：表示隐私计算节点 Domain 下所有 Kuscia Agent 的状态信息。</p><ul><li><code>nodeStatuses[].lastHeartbeatTime</code>：表示 Kuscia Agent 最近一次上报心跳的时间。</li><li><code>nodeStatuses[].lastTransitionTime</code>：表示 Kuscia Agent 最近一次发生更新的时间。</li><li><code>nodeStatuses[].name</code>：表示 Kuscia Agent 的名称。</li><li><p><code>nodeStatuses[].status</code>：表示 Kuscia Agent 的状态。支持两种取值 <code>Ready</code> 、<code>NotReady</code> 。</p><ul><li><code>Ready</code>：表示 Kuscia Agent 状态正常。</li><li><code>NotReady</code>：表示 Kuscia Agent 状态异常。</li></ul></li><li><code>nodeStatuses[].version</code>：表示 Kuscia Agent 的版本。</li></ul></li></ul>]]></description></item><item>    <title><![CDATA[【2025年12月更新】国内 ChatG]]></title>    <link>https://segmentfault.com/a/1190000047433289</link>    <guid>https://segmentfault.com/a/1190000047433289</guid>    <pubDate>2025-11-27 19:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、ChatGPT镜像网站</h2><p>① <a href="https://link.segmentfault.com/?enc=BWiVZGMWCEIp8EjFj43MiQ%3D%3D.T9CTd7h5Jo9J%2FMeCdMHtos3FUvZGruuyj4SzI0BVQwc%3D" rel="nofollow" target="_blank">ChatGPT 中文版</a> 支持 GPT-5、GPT-5.1、4.1 以及 Claude 4.5 sonnet、Gemini 2.5 Pro、Grok 4，支持 4o 绘画、nano banana<br/>② <a href="https://link.segmentfault.com/?enc=86RLBzhz%2FAI4mdrBbpZnnw%3D%3D.v2lGt4VZdF9HVaxKl9YQvKY9mnNh66ea%2BeTvBT%2FRHdY%3D" rel="nofollow" target="_blank">ChatGPT 镜像网站</a> 支持通用全模型，支持文件读取、插件、绘画、AI PPT<br/>③ <a href="https://link.segmentfault.com/?enc=YkhTvfmwSnfSBVSxVSo%2BiA%3D%3D.v3%2Ba8U66JHmXgpK%2Bzm5p6iskAYyU0KdQw0t%2F1ZyqPQk%3D" rel="nofollow" target="_blank">ChatGPT 工具站</a> 收集各种可以用的ChatGPT镜像网站，免费的收费的。</p><h3>1. 什么是ChatGPT镜像网站</h3><p><strong>ChatGPT镜像网站</strong>（ChatGPT Mirror Site）是指通过复制原始网站内容和结构，创建的备用网站。其主要目的是在原始网站无法访问时，提供相同或类似的服务和信息。</p><h3>2. ChatGPT 镜像站的用途</h3><ul><li><strong>绕过访问限制</strong> ：在某些地区，访问 OpenAI 官方网站可能受到限制或阻塞，镜像站可以帮助用户绕过这些限制，继续使用 ChatGPT 服务。</li><li><strong>负载均衡</strong> ：在高流量时期，镜像站可以分担部分用户请求，减轻官方服务器的负担，确保服务的稳定性。</li><li><strong>备份与冗余</strong> ：如果官方服务遇到故障或维护，镜像站可以作为备用，保证用户依然能够访问聊天机器人。</li></ul><h4>镜像网站的优势</h4><ul><li><strong>稳定访问</strong> ：在网络限制或高峰期，提供更可靠的访问体验。</li><li><strong>快速响应</strong> ：减少访问延迟，提升用户互动流畅度。</li><li><strong>本地化服务</strong> ：优化中文支持，满足国内用户的语言需求。</li></ul><h2>二、模型知识</h2><h3>1、模型基础信息</h3><p><strong>GPT-3.5 Turbo</strong>：官方已经计划下线，现在已经全面被gpt-4o-mini替代。</p><p><strong>o1/o1-mini</strong>：最新的版本模型， o1 不是 GPT 的下一代模型！o1 和 GPT-4o在不同领域各有所长。o1 擅长 STEM领域和需要大量思考的问题，并不擅长需要常识知识的知识。OpenAI 计划在之后分别研发 GPT 和 o1 系列模型。</p><p><strong>GPT-4o/4o-mini</strong>：性价比最高模型，支持视觉等多模态，OpenAI 文档中已经更新了 GPT-4o 的介绍：128k 上下文，训练截止 2023 年 10 月（作为对比，GPT-4-Turbo 截止 2023 年 12 月）。</p><p><strong>GPT-4 Turbo</strong>：支持视觉等多模态，128k 上下文，训练截止 2023 年 12 月。</p><h3>2、功能对比（对比热门的4o和o1）</h3><p><strong>最大区别</strong>：ChatGPT 4o支持多模态，OpenAI o1目前只支持文本内容。</p><p><strong>能力上</strong>：OpenAI o1在推理能力上全面领先ChatGPT 4o。</p><p><strong>使用限制</strong>：目前ChatGPT 4o官方Plus用户没有使用限制了，o1-mini 的限额从每周 50 条增加到每天 50 条，而 o1-preview 的限额从每周 30 条提高到每周 50 条。</p><p>就我自身的使用体验来说，我更喜欢使用4o。4o整体使用更流畅，o1响应太慢。</p><p><img width="723" height="826" referrerpolicy="no-referrer" src="/img/bVdgMXJ" alt="" title=""/></p><h3>3、模型选择</h3><p>目前来说，最聪明的版本肯定是o1，但是最好用的的版本我觉得是GPT-4o。GPT-4o在综合能力方面表现更为出色，支持多模态，响应速度和价格都更有优势。</p><h4>GPT-4o 的优势</h4><pre><code>响应速度快：GPT-4o在处理任务时的响应速度更快，能够更高效地完成复杂任务。
高性价比：比GPT-4 Turbo便宜一半。
多模态支持：GPT-4o支持视觉等多模态输入，这使得它在处理图像、文本等混合任务时表现尤为出色。
128k上下文：相比其他模型，GPT-4o拥有更大的上下文窗口，可以处理更长的文本和更复杂的任务。
</code></pre><h4>OpenAI o1 的优势</h4><pre><code>超强的逻辑能力：o1 模型采用了全新的“思维链”（CoT，Chain-of-Thought）推理机制，类似于人类在回答问题前需要深入思考的过程。该模型会在作出最终回答之前，构建一条详细的内部推理链，通过强化学习不断优化其思考过程。模型能够自我纠正错误，尝试不同的策略，并将复杂的步骤分解为更简单的部分，从而大幅提高其推理能力。
</code></pre><h2>三、国内大模型能替代？</h2><p>现在好用的大模型，不仅仅ChatGPT（GPT-5、GPT-4o、4o mini）、Claude 模型</p><p>还有百度、智谱、阿里等的大模型。</p><p>尤其DeepSeek能力已经接近OpenAI等主流大模型。目前DeepSeek最新模型评分已经可以追上GPT-4。</p><p>而且还巨便宜，大家感兴趣的真的可以抄底~~</p>]]></description></item><item>    <title><![CDATA[2025 年 8 款最佳远程协作工具 烦]]></title>    <link>https://segmentfault.com/a/1190000047433031</link>    <guid>https://segmentfault.com/a/1190000047433031</guid>    <pubDate>2025-11-27 18:13:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>现在不少开发团队会选择远程办公，但他们的协作效率问题依然存在。介绍几款好用的远程协作工具，提升开发效率。</p><h3>直击开发核心：从环境到编码的无缝协作</h3><p>对开发者来说，最高效的协作，就是能让大家像坐在同一间办公室里一样，面对同样的环境、同样的代码，顺畅地沟通。下面这几个工具，就是为了实现这个目标。</p><h4><a href="https://link.segmentfault.com/?enc=OqDmEbJEIAOiQiUHb4oYMQ%3D%3D.LT7w1moQU7qrpZyrL74OLWuI2rh%2Fz%2B8iJYaWtYLf2Ys%3D" rel="nofollow" target="_blank">ServBay</a>：对齐团队开发环境的颗粒度</h4><p><img width="723" height="504" referrerpolicy="no-referrer" src="/img/bVdnbEU" alt="image.png" title="image.png"/></p><p>“我电脑上跑得好好的啊！” 这句话你肯定不陌生。一个团队里，老张用 PHP 8.1，老李用 8.2，老外的 Node.js 还是旧版本，光是解决这些环境差异带来的 bug，就能耗费掉大量时间。</p><p>ServBay就是解决这些问题而存在。</p><p>ServBay 本身是一个非常强大的<a href="https://link.segmentfault.com/?enc=8ad%2F3mvSYiqIS%2Ftr8GNuEQ%3D%3D.Gp4jFhhPBqmwEoy%2B%2FuscVL%2Bsfos6nyW8M%2Bqdbg1YN74%3D" rel="nofollow" target="_blank">本地 Web 开发环境集成工具</a>，支持 PHP、Node.js、Python、Go、Java 等各种语言和数据库。但它真正让我觉得惊艳的，是它的团队协作功能。</p><p>它通过 <code>.servbay.config</code> 的配置文件，把团队开发环境不一致这个难题给解决了。</p><p>通过 <code>.servbay.config</code> ，团队负责人可以在这个文件里，精确指定项目需要用到的 Python 版本、Node.js 版本或者其他的语言，甚至是 Node.js 包管理器的仓库地址和缓存目录。然后把这个文件随代码一起提交到 Git 仓库。</p><p>这样一来，团队协作的体验就完全不同了：</p><ul><li><strong>告别“我这儿没问题”的问题</strong>：团队里所有人，只要拉下代码，ServBay 就会自动根据 <code>.servbay.config</code> 文件来切换和配置环境。确保了从开发、测试到最终上线，环境都是高度一致的。</li><li><strong>新人入职速度快到飞起</strong>：新人来了，不用再对着长长的文档折腾半天环境。直接用团队的 <code>.servbay.config</code> 文件，几分钟就能把项目跑起来，马上就能投入工作。</li><li><strong>环境管理不再是散装的</strong>：团队的技术负责人可以统一管理和更新这份配置文件。比如项目需要升级语言版本，只需要修改一下文件，团队成员下次拉取代码时，环境就自动同步了。</li><li><strong>大家能更专注于写代码</strong>：环境统一了，因为环境问题导致的冲突和阻塞就少了。开发者可以把精力都放在业务逻辑上，协作效率自然就高了。</li></ul><p>ServBay的这个功能，不管是远程工作还是线下工作，都是必不可少的。</p><h4><a href="https://link.segmentfault.com/?enc=hP%2B85%2Bhky7GL1Agi175KNQ%3D%3D.7LBvXVtCcX4YXHyODkn4nGbgWbVVTct8dzoOVSwVEqWht3AS%2F0JZooUWJUmZcZi8ZGRQkePA03%2BwPUTNgYHvMA%3D%3D" rel="nofollow" target="_blank">Live Share</a>：身临其境的远程结对编程</h4><p>环境统一了，下一步就是怎么高效地一起写代码。Live Share 是 VS Code 的一个插件，它能让开发者把自己的编辑器分享给队友。队友可以直接进入你的编辑器，实时看到你的代码，和你一起编辑、调试，甚至共享你的终端。</p><p>整个过程非常流畅，就像他坐在你旁边一样。</p><h4><a href="https://link.segmentfault.com/?enc=tdLoABUJ4In7XA93yXhqTw%3D%3D.PQ5Pva4ioXhW54CUURo00pNa5hKUh%2BFFIaFQya57LP8q3XvK6TMtAiqvrGYr%2FpCW" rel="nofollow" target="_blank">Todo Tree</a>：代码中的异步备忘录</h4><p><img width="723" height="460" referrerpolicy="no-referrer" src="/img/bVdnbEV" alt="image.png" title="image.png" loading="lazy"/></p><p>不是所有问题都需要拉着人实时沟通。有时候，我们在代码里发现一个小bug，可以先记下来。Todo Tree 这个 VS Code 插件就能派上用场。</p><p>它能扫描整个项目代码里的 <code>TODO</code>、<code>FIXME</code> 等注释，并把它们集中在一个视图里展示。这样，在写代码时随手记下的待办事项就不会被遗忘。在 Code Review 的时候，团队成员也能清晰地看到还有哪些地方需要完善，算是一种轻量级的、代码层面的异步协同。</p><h3>任务与项目管理：为开发流程服务的骨架</h3><p>代码层面的协作理顺了，我们再来看更高一层的项目管理。这里的工具选择很多，它们各有侧重，适合不同风格的团队。</p><h4><a href="https://link.segmentfault.com/?enc=%2Bqfe%2Bk5Gu5Tk9nPMh%2Brk5w%3D%3D.meiOZbxlNTeIcRL4Spf3IFuK201rBG45QBewxfOQ%2BKw%3D" rel="nofollow" target="_blank">Linear</a>：追求极致速度的开发者首选</h4><p><img width="723" height="373" referrerpolicy="no-referrer" src="/img/bVdnbEW" alt="image.png" title="image.png" loading="lazy"/></p><p>如果你受够了 Jira 的臃肿和卡顿，Linear 绝对能让你眼前一亮。它的界面极简、响应飞快，所有操作基本都能用键盘快捷键完成。它和 GitHub 的集成做得非常好，代码提交能自动更新任务状态。用它来管理 Sprint 和 Bug，感觉就像在写代码一样流畅。</p><h4><a href="https://link.segmentfault.com/?enc=rcBgxwh1ToCkOYPbU71D8A%3D%3D.P6CX1a%2BhrImydLzUGbccjJO1speHwfxuP2PxblGT8Yc%3D" rel="nofollow" target="_blank">Trello</a>：简单直观的看板</h4><p><img width="723" height="392" referrerpolicy="no-referrer" src="/img/bVdnbEX" alt="image.png" title="image.png" loading="lazy"/></p><p>Trello 就像一块白板和一堆便利贴。它的核心就是看板（Board）、列表（List）、卡片（Card）。操作简单直观，学习成本几乎为零。非常适合规模不大、流程不复杂的团队，或者用来管理一些临时的、非核心的项目。</p><h4><a href="https://link.segmentfault.com/?enc=zeTtkTX8BPu%2F7TCIp4FNRw%3D%3D.z%2Fywx%2FKmgjQWrXDLNlw8waMXbayY%2BQPdV0Fo1pcfL%2Bo%3D" rel="nofollow" target="_blank">Monday</a>：高度定制化的项目工具</h4><p><img width="723" height="493" referrerpolicy="no-referrer" src="/img/bVdnbEY" alt="image.png" title="image.png" loading="lazy"/></p><p>Monday 更像一个工作操作系统。它的强大之处在于高度的可定制性，你可以用它搭建出各种各样的工作流。它的各种视图（时间线、图表）非常丰富，很适合需要向管理层或非技术同事展示项目进度的场景。</p><h4><a href="https://link.segmentfault.com/?enc=lA1jYlzmT8Bf37Bj8VEx7Q%3D%3D.JzBj7gQ4luSc4Er8TQBELVDAL7teCceBUWpp7lfq4RA%3D" rel="nofollow" target="_blank">Teamcamp</a>：整合代码与任务的一体化平台</h4><p><img width="723" height="474" referrerpolicy="no-referrer" src="/img/bVdnbEZ" alt="image.png" title="image.png" loading="lazy"/></p><p>Teamcamp 的思路是把项目管理和代码工作流更紧密地结合起来。比如它的一个特色是 Git 提交可以自动更新任务状态，减少了开发者在任务板和代码库之间来回切换的手动操作。如果想要任务状态能和代码进度强绑定，它可以作为一个不错的选择。</p><h3>时间与效率追踪</h3><h4><a href="https://link.segmentfault.com/?enc=Blu74eD8zGGPTHvjxmhVZw%3D%3D.b6Jh9C1DUw7yyd%2BBhgkWjfW87h5Es6f%2BKL%2Bx8wk%2FaFo%3D" rel="nofollow" target="_blank">Clockify</a>：简单直接的时间记录工具</h4><p><img width="723" height="472" referrerpolicy="no-referrer" src="/img/bVdnbE0" alt="image.png" title="image.png" loading="lazy"/></p><p>远程工作，有时候需要记录一下自己在各个项目上花了多少时间，以便评估工作量或进行项目复盘。Clockify 是一个免费又简单的时间追踪工具。它没什么学习成本，可以按项目、按任务来记录时间，也能生成简单的报表。如果你只是需要一个不打扰、不复杂的工具来记录工时，它足够了。</p><h3>总结一下</h3><p>一个好的远程协作工具栈，有自己擅长的领域：</p><ul><li><strong>ServBay</strong> 负责打好地基，统一开发环境。</li><li><strong>Linear、Trello、Monday、Teamcamp</strong> 负责搭建项目管理的骨架，风格各异，按需使用。</li><li><strong>Live Share</strong> 和 <strong>Todo</strong> <strong>Tree</strong> 负责填充代码协作的血肉，一个实时、一个异步。</li><li><strong>Clockify</strong> 负责最后的度量和复盘。</li></ul><p>先把地基打牢，上层的协作才会事半功倍。希望这些工具能帮到你和你的团队。</p>]]></description></item><item>    <title><![CDATA[Flutter版本选择指南：3.35稳定]]></title>    <link>https://segmentfault.com/a/1190000047433034</link>    <guid>https://segmentfault.com/a/1190000047433034</guid>    <pubDate>2025-11-27 18:12:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>哈喽，我是老刘</strong></p><p>老刘做Flutter开发差不多7年了，期间如何选择Flutter版本是被问得最多的问题之一。</p><p>所以老刘新开了一个系列文章，每个月都会深度分析最近的几个Flutter版本。</p><ul><li>提供具体的版本选择建议</li><li>分享真实的生产环境经验</li><li>给出详细的升级和回滚策略</li></ul><p>让你在版本选择上不再纠结，不再踩坑。</p><hr/><h2>一、Flutter版本选择策略</h2><p>对于技术框架和版本的选择，不应该是盲目的选择最新版，或者无脑看网上别人怎么推荐，而是应该有自己的分析方法。</p><p>最新的版本大概率解决了之前版本中比较严重的问题，优化了性能，添加了新特性。</p><p>但是最新版有很有可能引入新的bug或者缺陷。</p><p>那么作为开发者该如何权衡这两者的利弊呢？</p><p><strong>第一个法则：2个月观察期，别当小白鼠</strong></p><p>新版本发布后的前2个月，就是一场大型真人实验。</p><p>大部分严重的bug在发布后的一到两个月都能被爆出来。</p><p>所以聪明的做法是什么？</p><p>等2个月，看社区反馈，看bug列表。如果这段时间没有什么比较严重的问题，那么大概率就是比较安全的。</p><p>也可以看老刘每个月发布的《Flutter版本选择指南》。</p><p>这就像买股票一样，不要追高，要等进入低估区间。</p><p><strong>第二个法则：分环境测试，别一上来就all in</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433036" alt="" title=""/></p><p><strong>开发环境 → 测试环境 → 生产环境</strong></p><p>开发环境用最新版，踩坑我认了，反正影响不了用户。</p><p>测试环境用经过开发环境检验的版本，充分测试，记录问题。</p><p>生产环境用稳定版，用户至上，稳定压倒一切。</p><p>升级前预留足够的时间窗口，比如在当前已经发布的版本上只升级Flutter版本，然后快速发布一个小版本。</p><p>如果发现问题可以尽快回滚。</p><hr/><h2>二、Flutter最近5个版本深度解析</h2><h3>1. 版本列表</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433037" alt="" title="" loading="lazy"/></p><ol><li><strong>Flutter 3.38</strong> (最新) - 2025年11月发布</li><li><strong>Flutter 3.35</strong> - 2025年8月发布</li><li><strong>Flutter 3.32</strong> - 2025年5月发布</li><li><strong>Flutter 3.29</strong> - 2025年2月发布</li><li><strong>Flutter 3.27</strong> - 2024年12月发布</li></ol><h3>2. 各版本问题分析与风险评估</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433038" alt="" title="" loading="lazy"/></p><p><strong>Flutter 3.38 - 刚发布，进入观察期</strong></p><ul><li><strong>工具链升级</strong>：iOS 引入 UIScene 生命周期支持，旧工程需按指南迁移；Android 默认 NDK 升至 r28，满足 Google Play 16 KB 页面大小兼容要求。</li><li><strong>渲染与性能</strong>：Web与移动端有优化，建议用真机与线上数据做对比。</li><li><strong>生态适配</strong>：第三方插件与库通常需要1–3周完成适配。</li><li><strong>建议</strong>：建议等待三方库适配，同时观察社群反馈</li></ul><blockquote>注意：此版本支持了iOS端的UIScene生命周期迁移和Android端的Google Play 16 KB 页面大小兼容，因此建议开发者保持关注，时机成熟后尽早进行适配。</blockquote><p><strong>Flutter 3.35 - 当前推荐版本</strong></p><ul><li><strong>稳定性提升</strong>：修复了前期版本的主要问题</li><li><strong>新功能</strong>：Web端热重载、Widget预览等功能逐步完善</li><li><strong>社区评价</strong>：稳定版本，推荐各种项目使用</li></ul><p><strong>Flutter 3.32 - 渲染引擎调整期</strong></p><ul><li><strong>渲染后端调整</strong>：从Vulkan回退到OpenGLES，性能有所影响</li><li><strong>设备兼容性</strong>：部分老旧设备支持有限</li><li><strong>过渡期建议</strong>：等待后续版本稳定性提升</li></ul><p><strong>Flutter 3.29 - 启动和内存管理需关注</strong></p><ul><li><strong>应用启动问题</strong>：部分开发者反馈启动阶段存在崩溃现象</li><li><strong>内存管理优化</strong>：相比早期版本有所改进，但需持续观察</li><li><strong>建议</strong>：生产环境升级前需充分测试</li></ul><p><strong>Flutter 3.27 - 高风险版本，需谨慎评估</strong></p><ul><li><p><strong>Impeller渲染引擎稳定性问题</strong>：新渲染引擎在部分设备上存在问题</p><ul><li>部分Android设备出现花屏、黑屏现象，影响用户体验</li><li>开发环境模拟器性能下降，影响开发效率</li><li>可通过 <code>--no-enable-impeller</code> 参数禁用新渲染引擎</li></ul></li><li><strong>社区反馈</strong>：Reddit等平台有用户报告蓝屏和冻结问题</li></ul><hr/><h2>三、不同场景的版本选择策略</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433039" alt="" title="" loading="lazy"/></p><h4><strong>生产环境（求稳不求新）</strong></h4><ul><li><strong>首选</strong>：Flutter 3.35 - 新功能与稳定性的平衡点</li><li><strong>观察期</strong>：Flutter 3.38 - 刚发布，暂不建议直接上生产</li></ul><p><strong>理由</strong>：用户体验 &gt; 开发体验，稳定压倒一切</p><p><strong>3.35版本经过两个月验证没什么大问题，10月份提升为首选</strong></p><ul><li>如果对稳定性没有极端要求的App可以考虑升级3.35。</li><li>如果对稳定性要求很高，建议再观察一个月。</li></ul><h4><strong>开发环境（可以激进一点）</strong></h4><ul><li><strong>推荐</strong>：Flutter 3.35 - 体验最新功能，当前最稳定的版本</li><li><strong>注意</strong>：随时准备回滚，不要在deadline前升级</li><li><strong>观察期</strong>：3.38版本发布时间太短，三方库适配不够充分，暂时不建议进入开发环境</li></ul><h4><strong>新项目启动</strong></h4><ul><li><strong>最佳选择</strong>：Flutter 3.35</li><li><strong>优势</strong>：长期支持、社区活跃、bug修复及时</li><li><strong>观察期</strong>：3.38版本发布时间太短，三方库适配不够充分，暂时不建议进入开发环境</li></ul><h3>⚠️ <strong>需谨慎使用的版本</strong></h3><ul><li><strong>Flutter 3.38</strong>：刚发布，建议先在开发环境验证，等待社区反馈</li><li><strong>Flutter 3.32</strong>：渲染引擎调整期，性能有所影响</li><li><strong>Flutter 3.29</strong>：建议充分测试后再用于生产环境</li><li><strong>Flutter 3.27</strong>：Impeller渲染引擎在部分设备上存在稳定性问题</li></ul><hr/><h2>总结</h2><p>当前的现状是：大厂都在用"过时"版本，而小公司却在追最新。</p><p>在客户端项目中，基础框架的版本选择核心原则是不要追新，留两个月冷静期。</p><p>"在这个快速迭代的时代，懂得慢下来选择稳定版本的开发者，才是真正的高手。"</p><blockquote><p>如果看到这里的同学对客户端开发或者Flutter开发感兴趣，欢迎联系老刘，我们互相学习。</p><p>点击免费领老刘整理的《Flutter开发手册》，覆盖90%应用开发场景。</p><p>可以作为Flutter学习的知识地图。</p><p><a href="https://link.segmentfault.com/?enc=Zkegxq0tIhYp46RCWjdL2g%3D%3D.wC2BTtprgCl4Gv40w54wN2lMb4b%2BQnTq94A380dgKC3VGxKqSrjVMf9VSvvj7fR1XjVwXtQNXrQmDWDE4jFgaAoyewlbK2MM3MhkGh5nMgO1TQmQjI25bLRcARbaaJW1u%2F0%2Fn%2BS05zicEqjErhlyYNx01Hg75wQm6QqzwVeT5h60vfMMPJ3RiV%2Ftz4oh3VqLpbGxMH0TS2ak5Sv%2BiNF70YL5iNAC6IPRAOrIzaqgqVYKC3Hoyy%2Ble8puF3ieM1TuIVoDi%2BrRvouYBSS6zCn7cA%3D%3D" rel="nofollow" target="_blank">覆盖90%开发场景的《Flutter开发手册》</a></p></blockquote>]]></description></item><item>    <title><![CDATA[如何轻松快速地备份 iPhone 联系人]]></title>    <link>https://segmentfault.com/a/1190000047433046</link>    <guid>https://segmentfault.com/a/1190000047433046</guid>    <pubDate>2025-11-27 18:11:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>定期备份 iPhone 数据对于保护联系人等重要信息至关重要。妥善备份可确保即使 iPhone 损坏、丢失或被盗，您的联系人列表也能安全无虞。说到备份 iPhone 数据，大多数人首先想到的是 iTunes 或 iCloud。然而，这两种方法都无法单独备份联系人。</p><p>如果您只需要备份联系人，好消息是，除了 iTunes 和 iCloud 之外，还有许多替代方案可以满足您的需求。本指南将向您介绍六种使用 iTunes、iCloud 和一些简单的第三方工具备份 iPhone 联系人的有效方法。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433048" alt="图片" title="图片"/></p><p>第一部分：如何使用iOS助理将 iPhone 上的联系人备份到电脑</p><p>Coolmuster iOS Assistant是将 iPhone 联系人备份到电脑或其他外置硬盘的完美工具。它极大地简化了iOS设备上所有数据的管理。只需单击一下，即可轻松在 iPhone 和 PC/ Mac之间传输各种数据，例如联系人、照片、视频、音乐文件等等，无论文件大小或格式如何。</p><p>它允许您在开始传输前预览数据详情。此外， iOS助手还允许用户在电脑上自由添加、编辑或删除联系人。总而言之，如果您想轻松管理 iPhone 数据， iOS助手是理想之选。</p><p>iOS助手的主要功能：</p><pre><code>将 iPhone 上的联系人备份到电脑，格式为 CSV、vCard 文件和 XML，数据无丢失。
一键备份和恢复 iPhone/iPad/iPod 上的所有内容。
轻松在 iPhone/iPad 和电脑之间传输数据。
与所有世代的 iPhone、iPad 和 iPod 广泛兼容。
支持各种文件，例如联系人、短信、照片、视频、音乐、笔记、书签、书籍、日历、应用程序等等。
与所有iOS设备兼容，包括 iPhone 17/16/15/14/13/12/11/X/8/7/6 等。

</code></pre><p>以下是如何通过iOS助理从 iPhone 保存联系人：</p><p>01下载并安装iOS助理，然后使用 USB 数据线将 iPhone 连接到电脑。点击“信任”继续。连接成功并被软件检测到后，您将在界面上看到有关您设备的信息。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433049" alt="图片" title="图片" loading="lazy"/></p><p>02从左侧窗口中选择“联系人”选项。预览文件并勾选要备份的联系人列表。之后，点击界面顶部的“导出”图标，将联系人列表保存到电脑。</p><p>第二部分：如何使用 iTunes/Finder 备份 iPhone 联系人</p><p>iTunes（适用于Windows和 macOS Mojave 及更早版本）和 Finder（适用于 macOS Catalina 及更高版本）是苹果公司提供的官方设备管理工具。它们支持对 iPhone 数据（包括联系人）进行完整设备备份。虽然此方法不允许您单独查看联系人文件，但它适合希望一次性备份所有数据的用户。</p><p>将 iPhone 联系人备份到 iTunes：</p><p>步骤 1. 首先在电脑上安装最新版本的 iTunes ，然后使用 Lightning 数据线将 iPhone 连接到电脑。</p><p>步骤 2. 点击 iTunes 窗口左上角的 iPhone 图标。</p><p>步骤 3. 在“备份”部分，选择“此电脑”，然后点击“立即备份”。您重要的联系信息将安全地存储在 iTunes 中。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433050" alt="图片" title="图片" loading="lazy"/><br/>​</p><p>将 iPhone 联系人备份到 Finder：</p><p>步骤 1. 使用 USB 数据线将 iPhone 连接到Mac ，然后在Mac上打开 Finder。</p><p>步骤二：你的 iPhone 会出现在 Finder 侧边栏的“位置”下方。点击 Finder 中的 iPhone。</p><p>步骤 3. 在“常规”选项卡下，找到“备份”部分。</p><p>步骤 4. 选择“将 iPhone 上的所有数据备份到此Mac ”，然后点击“立即备份”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433051" alt="图片" title="图片" loading="lazy"/></p><p>第三部分：如何将 iPhone 上的联系人保存到 iCloud</p><p>iCloud 是苹果官方的云备份服务，支持联系人自动同步到云端。只要您的设备连接到 Wi-Fi 并启用了同步功能，联系人就会自动保存到 iCloud，方便您恢复联系人或切换到新设备。</p><p>以下是如何将 iPhone 上的联系人存储到 iCloud 的方法：</p><p>步骤 1. 打开你的 iPhone，然后进入“设置”。</p><p>步骤 2. 点击顶部的“Apple ID”头像进入“iCloud”设置页面。</p><p>步骤 3. 在“iCloud”列表中，找到“通讯录”选项并将其打开。</p><p>步骤 4. 确保您的设备已连接到 Wi-Fi，系统将自动开始同步您的联系人。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433052" alt="图片" title="图片" loading="lazy"/></p><p>您还可以进行完整的 iCloud 备份，将 iPhone 上的所有内容（包括联系人）备份到 iCloud 。为此，请按照以下步骤操作：</p><p>步骤 1. 打开你的 iPhone，然后进入“设置”。</p><p>步骤 2. 点击顶部的“Apple ID”，然后选择“iCloud”。</p><p>步骤 3. 向下滚动并点击“iCloud 备份”。</p><p>步骤 4. 如果“iCloud 备份”尚未启用，请将其打开。</p><p>步骤 5. 点击“立即备份”开始备份过程。</p><p>步骤 6. 等待备份完成，同时确保您的设备已连接到 Wi-Fi。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433053" alt="图片" title="图片" loading="lazy"/><br/>​</p><p>第四部分：如何将 iPhone 联系人保存到 Gmail</p><p>如何在不使用 iCloud 的情况下备份 iPhone 联系人？如果您使用 Gmail 或计划将联系人同步到Android手机，那么将 iPhone 联系人备份到 Gmail 是一个不错的选择。通过添加 Google 帐户并启用同步功能，您可以跨平台管理数据。</p><p>以下是如何在不使用 iCloud 的情况下，通过 Gmail 在 iPhone 上备份联系人的方法：</p><p>步骤 1. 打开 iPhone 上的“设置”&gt;“通讯录”&gt;“帐户”。</p><p>步骤 2. 点击“添加帐户”，然后选择“Google”。</p><p>步骤 3. 输入您的 Gmail 电子邮件地址和密码登录。</p><p>步骤 4. 登录后，确保“联系人”同步开关已打开。</p><p>步骤 5. 几分钟后，您的 iPhone 联系人将自动同步到您的 Gmail 帐户。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433054" alt="图片" title="图片" loading="lazy"/></p><p>第五部分：如何通过隔空投送将 iPhone 上的联系人备份到Mac</p><p>如果您手边有一台Mac ，并且想要快速共享或保存单个联系人，AirDrop 是一个非常便捷的方法。虽然它不支持批量备份，但对于导出少量联系人来说非常有用。</p><p>步骤 1. 确保您的 iPhone 和Mac都已启用隔空投送功能，并且连接到同一个 Wi-Fi 网络。</p><p>步骤 2. 在你的 iPhone 上，打开“通讯录”应用，然后选择你要分享的联系人。</p><p>步骤 3. 向下滚动并点击“共享联系人”选项。</p><p>步骤 4. 在共享选项中，选择“隔空投送”。（隔空投送无法使用？）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433055" alt="图片" title="图片" loading="lazy"/></p><p>步骤 5. 从可用设备列表中选择您的Mac 。</p><p>步骤 6. 在您的Mac上，接受 AirDrop 传输以接收联系人。</p><p>步骤 7. 联系人将保存到Mac的“通讯录”应用中。</p><p>第六部分：通过“通讯录”应用备份 iPhone 通讯录</p><p>iPhone 允许您直接从“通讯录”应用导出联系人，方便您创建备份。要使用该应用导出联系人：</p><p>步骤 1：打开“通讯录”应用。在iOS 26 设备上，点击“&gt;”图标；在iOS 18 及更早版本中，点击“列表”按钮。</p><p>步骤二：长按要导出的联系人列表。要导出所有联系人，请选择“所有联系人”列表。然后点击“导出”。</p><p>步骤三：系统会提示您通过短信或电子邮件分享导出的联系人。选择最适合您的方式。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433056" alt="图片" title="图片" loading="lazy"/><br/>​</p><p>导出 iPhone 联系人有多种方法。请查看完整指南，了解所有选项。</p><p>关于 iPhone 联系人备份的常见问题</p><p>Q1. 如何从我的 iPhone 复制所有联系人？</p><p>您可以在“通讯录”应用中选择所有联系人，并通过电子邮件或短信分享。或者，您可以使用Coolmuster iOS助手复制所有联系人，然后进行备份或发送给其他人。</p><p>Q2. 如何在不使用 iCloud 的情况下备份 iPhone 联系人？</p><p>打开“设置”应用，前往“通讯录 &gt; 帐户 &gt; 添加帐户”，然后使用 Gmail 或 Outlook 等帐户登录。打开“通讯录”开关，将您的联系人与该帐户同步。</p><p>Q3. 如何将iPhone上的所有联系人传输到我的电脑？</p><p>您可以使用 iTunes 或 Finder 将 iPhone 上的所有数据（包括联系人）传输到电脑。如果您只想传输联系人， Coolmuster iOS Assistant 是一个更专业的选择。</p><p>结语</p><p>本文介绍了六种备份iPhone联系人的方法，您可以根据自己的使用习惯和设备环境选择最合适的方案。如果您需要批量、高效地导出和保存联系人，并选择所需的格式，我们特别推荐使用Coolmuster iOS Assistant 。它不仅支持联系人导出，还能管理信息、照片、视频等多种数据类型，是一款实用的iPhone数据管理工具。<br/>​</p>]]></description></item><item>    <title><![CDATA[ManageEngine卓豪-cmdb系]]></title>    <link>https://segmentfault.com/a/1190000047433076</link>    <guid>https://segmentfault.com/a/1190000047433076</guid>    <pubDate>2025-11-27 18:11:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>我有个朋友，他在微信上跟我说，对CMDB系统表示困惑，我便给他语音讲，但讲的比较多，他似乎听的云里雾里；于是，我便用文档的形式发给他，本文是我答疑解惑的经验分享。</p><p><strong>来看看<a href="https://link.segmentfault.com/?enc=hvCJ3BFKsAFba35J9J9Kiw%3D%3D.jqtlQmcftkC9HzzB66u5MydXzacM8ChVQu6MR0KfjbVOicWj2WA4liGTKzdq7lnG89FlMvM7mdsiFzVbprfEoXemMS2zXCTcqSI2I2TsQ4E%3D" rel="nofollow" target="_blank">CMDB系统架构</a>设计是怎么肥事!</strong></p><p>CMDB系统的架构设计是其能够高效运行的基础，一个合理的架构设计可以确保系统的稳定性、可扩展性和易用性。该架构可以分为数据层、逻辑层和展示层3个主要部分。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433078" alt="图片" title="图片"/><br/><strong>数据层：</strong> 是CMDB系统的核心，它负责存储和管理所有的配置项信息，这些配置项可以包括硬件设备（如服务器、网络设备等）、软件系统（如操作系统、应用程序等）、人员信息以及它们之间的关系。</p><p><strong>逻辑层：</strong> 负责处理业务逻辑，它接收来自展示层的请求，对数据层的数据进行增删改查等操作。</p><p><strong>展示层：</strong> 是用户与CMDB系统交互的界面，它负责将系统的数据以直观的方式展示给用户，并接收用户的输入。</p><p>难道说不用CMDB系统，就不能有效提升效率了吗？这显然是扯犊子的，只要理解了CMDB流程，一样能提高不少效率。</p><p>CMDB系统应用场景通过<a href="https://link.segmentfault.com/?enc=FIAw9Ov6%2Fnwk%2BRIjYcNT9A%3D%3D.2YU%2BUjY%2B2VJpn1J%2FswoL%2BYEmCktlqnJtMuZnnuTy0Gl0wC6Mz4zTPwOi0UcVCh6wOy5J5NalScN8AOhp3Mfnyg%3D%3D" rel="nofollow" target="_blank">ManageEngine卓豪</a>的CMDB系统，企业可以对所有的IT资产进行全面的盘点和管理。系统可以记录资产的基本信息、采购时间、使用部门、维护记录等，帮助企业及时了解资产的使用情况和状态。同时，系统还可以实现资产的自动化盘点，减少人工盘点的工作量和误差。当企业的IT系统出现故障时，CMDB系统可以帮助管理员快速定位故障的根源。系统可以通过配置项之间的关系，分析故障可能影响的范围，并提供相关的解决方案。</p><p>例如，当服务器出现故障时，系统可以快速查询该服务器上运行的应用程序、依赖的数据库等信息，帮助管理员快速排查故障。企业的IT管理通常涉及到多个系统，如IT服务管理系统（ITSM）、监控系统等。CMDB系统将与这些系统进行更加紧密的集成，实现数据的共享和业务流程的协同。</p><p>例如，CMDB系统可以与ITSM系统集成，实现故障工单的自动创建和处理。当然，这只是我个人的见解...，只有真正实践过大概才能知道有多香吧。</p>]]></description></item><item>    <title><![CDATA[3D 场景预加载应用实现 | 图扑软件 ]]></title>    <link>https://segmentfault.com/a/1190000047433081</link>    <guid>https://segmentfault.com/a/1190000047433081</guid>    <pubDate>2025-11-27 18:10:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="915" referrerpolicy="no-referrer" src="/img/bVdnbDB" alt="image.png" title="image.png"/></p><p>预加载是在进入正式场景之前提前加载所需模型、材质、图片等资源的技术手段，其核心价值在于消除资源加载等待，确保场景首次渲染即可完整呈现，从而提供无缝、流畅的用户体验。在复杂的 Web 3D 可视化应用中，资源预加载尤为重要，可有效解决首次加载时的卡顿、白屏及交互延迟等问题。</p><h2>预加载实现方案</h2><h3>基础实现原理</h3><p>HT for Web 中所有资源的请求都会经过 ht.Default.convertURL 方法，该方法提供了统一的资源请求入口：</p><ul><li>当返回字符串路径时，框架会按此路径发起资源请求；</li><li>当返回 {data: content} 格式对象时，框架会直接使用 content 作为资源内容。</li></ul><p>基于此特性，我们可实现预加载机制</p><pre><code class="javaScript">// 资源缓存映射表
let sourceMap = {}; 
// 判断是否为本地资源
functionisLocalUrl(url) {
    return url.startsWith('data:') || url.startsWith('blob:');
}
// 重写 convertURL 方法
let oldFunc = ht.Default.convertURL;
ht.Default.convertURL = function(url) {
    if (isLocalUrl(url)) return url;
    
    let source = sourceMap[url];
    if (source) {
        return { data: source };
    }
    
    return oldFunc(url);
};</code></pre><h3>资源加载策略</h3><h4>部分资源预加</h4><p>适用于资源量较大但部分关键资源需要优先加载的场景。</p><pre><code class="javaScript">// 关键资源列表
let resources = [
    "models/model.json",
    "assets/texture.png",
    "symbols/symbols.json"
]
</code></pre><p><img width="723" height="335" referrerpolicy="no-referrer" src="/img/bVdnbDM" alt="image.png" title="image.png" loading="lazy"/></p><h4>全量资源预加载</h4><p>获取所有已注册资源进行预加载：</p><pre><code class="javaScript">functiongetAllResources() {
    return [
        ...Object.keys(ht.Default.getImageMap()),
        ...Object.keys(ht.Default.getCompTypeMap()),
        ...Object.keys(ht.Default.getShape3dModelMap()),
        ...Object.keys(ht.Default.getMaterialMap()),
        ...Object.keys(ht.Default.getHdrTextureMap())
    ];
}
let allResources = getAllResources();</code></pre><p><img width="723" height="335" referrerpolicy="no-referrer" src="/img/bVdnbD9" alt="image.png" title="image.png" loading="lazy"/></p><h3>资源加载实现</h3><pre><code class="javaScript">// 资源类型判断
const ResourceType = {
    IMAGE: /\.(png|jpg|gif|jpeg|bmp|svg)$/i,
    BUFFER: /\.(fbx|gltf|glb)$/i,
    HDR: /\.hdr$/i,
    TGA: /\.tga$/i,
    JSON: /\.json$/i
};

class ResourceLoader {
    constructor(resources) {
        this.resources = resources;
        this.loaded = 0;
    }

    load() {
        this.resources.forEach(url =&gt; {
            if (ResourceType.BUFFER.test(url)) {
                this.loadBuffer(url);
            }
            else if(ResourceType.IMAGE.test(url)) {
                this.loadImage(url);
            } // 其他资源类型处理...        
        });
    }

    loadBuffer(url) {
        ht.Default.xhrLoad(url, res =&gt; {
            this.onResourceLoaded(url, res);
        }, {
            responseType: 'arraybuffer'
        });
    }

    // 其他加载方法...
    onResourceLoaded(url, res) {
        sourceMap[url] = res;
        this.loaded++;
        this.onProgress(this.loaded, this.resources.length);
        if (this.loaded === this.resources.length) {
            this.onAllLoaded();
        }
    }

    // 加载进度回调
    onProgress(loaded, total) {
        console.log(`加载进度: ${loaded}/${total}`);
    };

    onAllLoaded() {
        console.log("所有资源预加载完成");
        // 进入主场景...   
    }
}</code></pre><p><img width="723" height="335" referrerpolicy="no-referrer" src="/img/bVdnbEi" alt="image.png" title="image.png" loading="lazy"/></p><h2>加载页面优化</h2><h3>进度展示设计</h3><pre><code class="javaScript">class LoadingView{
    constructor() {
        this.initView();
    }

    initView(){
        this.dm = new ht.DataModel();
        this.view = new ht.graph.GraphView(this.dm);
        
        let style = this.view.getView().style;
        style.left = "0";
        style.right = "0";
        style.top = "0";
        style.bottom = "0";
        document.body.appendChild(this.view.getView());
    }
    
    // 更新进度
    updateProgress(percent) {
        
    }
    
    // 移除加载页面
    remove() {
        setTimeout(() =&gt; {
            this.view.getView().remove();
            this.enterMainScene();
        }, 1);
    }
    
    // 进入主场景
    enterMainScene(){

    }
}</code></pre><h3>视觉优化建议</h3><ul><li><p>进度条设计：使用图标实现平滑动画。</p><p><img width="723" height="335" referrerpolicy="no-referrer" src="/img/bVdnbEk" alt="image.png" title="image.png" loading="lazy"/></p></li><li><p>背景动画：添加轻量级背景动画提升等待体验。</p><p><img width="723" height="335" referrerpolicy="no-referrer" src="/img/bVdnbEl" alt="image.png" title="image.png" loading="lazy"/></p></li><li>分段进度：将加载过程分为资源加载、场景初始化等阶段。</li><li>预估时间：基于已加载时间预测剩余时间。</li></ul><h2>性能优化方案</h2><h3>Service Worker 离线缓存</h3><pre><code class="javaScript">// sw.js
let CACHE_NAME = 'ht-resources-v1';

self.addEventListener('fetch', event =&gt; {
    event.respondWith(caches.match(event.request).then(function (response) {
        if (response !== undefined) {
            return response;
        } else {
            return fetch(event.request).then(function (response) {
                if (event.request.url.indexOf('storage') != -1) {
                    let responseClone = response.clone();
                    caches.open(CACHE_NAME).then(function (cache) {
                        cache.put(event.request, responseClone);
                    });
                }
                return response;
            }).catch(function () {
                return caches.match('./');
            });
        }
    }));
});

self.addEventListener('activate', function (event) {
    event.waitUntil(clients.claim());
    event.waitUntil(
        caches.keys().then(function (keyList) {
            returnPromise.all(keyList.map(function (key) {
                if (key !== CACHE_NAME) {
                    // 删除旧缓存
                    return caches.delete(key);
                }
            }));
        })
    );
});</code></pre><h3>资源压缩策略</h3><ul><li><strong>模型优化</strong>：轻量化模型，对模型进行减面。</li><li><strong>图片优化</strong>：图片资源压缩。</li></ul><h2>效果对比与总结</h2><h3>加载效果对比</h3><p>预加载方案虽然初始显示时间较长，但提供了更优的整体用户体验：</p><ul><li><strong>完整的场景一次性呈现</strong>，避免零碎加载造成的视觉割裂。</li><li><strong>无卡顿的交互体验</strong>，所有资源已就绪。</li><li><strong>可控的等待预期</strong>，进度反馈降低用户焦虑。</li><li><strong>更稳定的性能表现</strong>，避免运行时资源加载导致的卡顿。</li></ul><p><em>预加载效果如下</em><br/><img width="640" height="323" referrerpolicy="no-referrer" src="/img/bVdnbEt" alt="image.png" title="image.png" loading="lazy"/></p><p><em>常规加载效果</em><br/><img width="640" height="324" referrerpolicy="no-referrer" src="/img/bVdnbEC" alt="image.png" title="image.png" loading="lazy"/></p><p><img width="723" height="483" referrerpolicy="no-referrer" src="/img/bVdnbED" alt="image.png" title="image.png" loading="lazy"/></p><h3>适用场景</h3><ul><li><p>大型 3D 场景：包含复杂模型和纹理的场景。</p><p><img width="723" height="263" referrerpolicy="no-referrer" src="/img/bVdnbEF" alt="image.png" title="image.png" loading="lazy"/></p></li><li>仪表盘应用：需要快速响应的监控系统。</li><li>移动端应用：网络条件不稳定的环境。</li><li>演示系统：需要流畅演示效果的场合。</li></ul><h3>实施建议</h3><ul><li>分阶段实施：先对关键资源预加载，再逐步扩展。</li><li>性能监控：添加加载时间统计和分析。</li><li>A/B 测试：对比不同策略的实际效果。</li></ul><h2>总结</h2><p>综上所述，本预加载方案能显著提升 HT for Web 应用的加载性能和用户体验，特别适合对流畅性要求高的可视化应用场景。在实际项目中，应根据资源规模和用户场景灵活调整预加载策略，平衡加载时间和用户体验。</p>]]></description></item><item>    <title><![CDATA[KlineCharts对接股票k线数据 ]]></title>    <link>https://segmentfault.com/a/1190000047433092</link>    <guid>https://segmentfault.com/a/1190000047433092</guid>    <pubDate>2025-11-27 18:09:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>使用 <strong>KlineCharts</strong> 对接 <strong>StockTV 印度股票 K 线数据</strong>的完整实施方案。<br/><img width="723" height="343" referrerpolicy="no-referrer" src="/img/bVdnbFY" alt="" title=""/></p><h3>核心步骤</h3><ol><li><strong>获取股票 PID</strong>：首先需要通过“市场列表”接口找到具体印度股票的 ID (<code>pid</code>)。</li><li><strong>请求 K 线数据</strong>：使用 <code>/stock/kline</code> 接口获取历史数据。</li><li><strong>数据清洗</strong>：将 StockTV 的返回格式转换为 KlineCharts 要求的格式。</li><li><strong>渲染图表</strong>：初始化 KlineCharts 并填充数据。</li></ol><hr/><h3>1. 准备工作：获取印度股票 PID</h3><p>在请求 K 线之前，您必须知道股票的 <code>pid</code>（产品 ID）。<br/>根据 API 文档，印度市场的 <code>countryId</code> 为 <strong>14</strong>。</p><p><strong>API 请求示例 (查找 Reliance Industries):</strong></p><pre><code class="http">GET https://api.stocktv.top/stock/stocks?countryId=14&amp;pageSize=10&amp;page=1&amp;key=您的KEY</code></pre><p><em>假设返回结果中某个股票的 <code>id</code> 为 <code>12345</code>，这就是我们需要的 <code>pid</code>。</em></p><hr/><h3>2. 完整代码示例 (HTML + JS)</h3><p>您可以直接创建一个 <code>.html</code> 文件，将以下代码复制进去。代码中包含了从 API 获取数据、格式转换以及渲染图表的完整逻辑。</p><p><strong>注意</strong>：请将代码中的 <code>YOUR_API_KEY</code> 替换为您从 StockTV 获取的真实 Key。</p><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;StockTV 印度股票 K线图 (KlineCharts)&lt;/title&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/klinecharts/dist/klinecharts.min.js"&gt;&lt;/script&gt;
    &lt;style&gt;
        body { margin: 0; padding: 0; font-family: sans-serif; }
        #chart-container { width: 100%; height: 600px; }
        .controls { padding: 10px; background: #f0f0f0; display: flex; gap: 10px; align-items: center; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;div class="controls"&gt;
        &lt;h3&gt;印度股票示例&lt;/h3&gt;
        &lt;button onclick="loadData(17940, 'P1D')"&gt;加载 Nifty 50 (日K)&lt;/button&gt;
        &lt;button onclick="loadData(17940, 'PT1H')"&gt;加载 Nifty 50 (1小时)&lt;/button&gt;
    &lt;/div&gt;

    &lt;div id="chart-container"&gt;&lt;/div&gt;

    &lt;script&gt;
        // 1. 初始化图表
        const chart = klinecharts.init('chart-container');

        // 2. 配置参数
        const API_BASE = 'https://api.stocktv.top';
        const API_KEY = '您的KEY'; // TODO: 请在此处填入您的 Key

        /**
         * 加载并渲染数据
         * @param {number} pid - 股票/指数的产品ID
         * @param {string} interval - 周期 (PT1M, PT15M, PT1H, P1D, P1W, P1M)
         */
        async function loadData(pid, interval) {
            if (API_KEY === '您的KEY') {
                alert('请在代码中配置您的 API Key');
                return;
            }

            try {
                // 显示加载中...
                chart.createIndicator('VOL'); // 确保显示成交量

                // 3. 构建 URL
                const url = `${API_BASE}/stock/kline?pid=${pid}&amp;interval=${interval}&amp;key=${API_KEY}`;
                
                console.log(`正在请求: ${url}`);
                const response = await fetch(url);
                const result = await response.json();

                if (result.code !== 200) {
                    console.error('API Error:', result.message);
                    alert(`API 错误: ${result.message}`);
                    return;
                }

                // 4. 数据转换 (关键步骤)
                // StockTV 返回格式: { time, open, high, low, close, volume }
                // KlineCharts 需要格式: { timestamp, open, high, low, close, volume }
                const chartData = result.data.map(item =&gt; {
                    return {
                        timestamp: item.time, // StockTV 返回的是毫秒时间戳，直接可用
                        open: Number(item.open),
                        high: Number(item.high),
                        low: Number(item.low),
                        close: Number(item.close),
                        volume: Number(item.volume)
                    };
                });

                // 按时间排序（防止 API 返回乱序）
                chartData.sort((a, b) =&gt; a.timestamp - b.timestamp);

                // 5. 设置数据到图表
                chart.applyNewData(chartData);
                console.log(`成功加载 ${chartData.length} 条数据`);

            } catch (error) {
                console.error('Fetch Error:', error);
                alert('请求失败，请检查控制台网络日志');
            }
        }

        // 页面加载默认加载一次数据
        // 17940 是文档中的 Nifty 50 指数 ID，日线
        loadData(17940, 'P1D'); 
        
        // 响应式调整大小
        window.addEventListener('resize', () =&gt; {
            chart.resize();
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><hr/><h3>3. 关键对接说明</h3><h4>A. 字段映射 (Data Mapping)</h4><p>根据您的 Postman 文件中的 <code>/stock/kline</code> 响应示例，字段对接如下：</p><table><thead><tr><th align="left">StockTV 字段</th><th align="left">说明</th><th align="left">KlineCharts 字段</th><th align="left">处理方式</th></tr></thead><tbody><tr><td align="left"><code>time</code></td><td align="left">时间戳 (1719818400000)</td><td align="left"><code>timestamp</code></td><td align="left">直接赋值 (Key名称不同)</td></tr><tr><td align="left"><code>open</code></td><td align="left">开盘价</td><td align="left"><code>open</code></td><td align="left">建议 <code>Number()</code> 转换</td></tr><tr><td align="left"><code>high</code></td><td align="left">最高价</td><td align="left"><code>high</code></td><td align="left">建议 <code>Number()</code> 转换</td></tr><tr><td align="left"><code>low</code></td><td align="left">最低价</td><td align="left"><code>low</code></td><td align="left">建议 <code>Number()</code> 转换</td></tr><tr><td align="left"><code>close</code></td><td align="left">收盘价</td><td align="left"><code>close</code></td><td align="left">建议 <code>Number()</code> 转换</td></tr><tr><td align="left"><code>volume</code></td><td align="left">成交量</td><td align="left"><code>volume</code></td><td align="left">建议 <code>Number()</code> 转换</td></tr></tbody></table><h4>B. 周期参数 (<code>interval</code>)</h4><p>StockTV 使用 ISO 8601 风格的时间周期格式，在调用 <code>loadData</code> 时需要传入正确的字符串：</p><ul><li><strong>5分钟</strong>: <code>PT5M</code></li><li><strong>15分钟</strong>: <code>PT15M</code></li><li><strong>30分钟</strong>: <code>PT30M</code></li><li><strong>1小时</strong>: <code>PT1H</code></li><li><strong>1天</strong>: <code>P1D</code></li><li><strong>1周</strong>: <code>P1W</code></li><li><strong>1月</strong>: <code>P1M</code></li></ul><h3>4. 进阶建议：WebSocket 实时更新</h3><p>您的文档中包含 <code>【股票】WebSocket</code> 接口。若要让 K 线图实时跳动，您需要在 <code>applyNewData</code> 之后，使用 WebSocket 监听该 PID 的推送，并使用 KlineCharts 的 <code>updateData()</code> 方法更新最后一条数据。</p><p><strong>WebSocket 更新逻辑简述：</strong></p><ol><li>连接 <code>wss://ws-api.stocktv.top/connect?key=...</code>。</li><li>接收消息，判断 <code>pid</code> 是否匹配当前图表。</li><li>构造数据对象 <code>{ timestamp, open, high, low, close, volume }</code>。</li><li>调用 <code>chart.updateData(newData)</code>。</li></ol>]]></description></item><item>    <title><![CDATA[如何打造 AI 时代的数据基石 | Da]]></title>    <link>https://segmentfault.com/a/1190000047433095</link>    <guid>https://segmentfault.com/a/1190000047433095</guid>    <pubDate>2025-11-27 18:08:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>数据洪流奔涌，AI 浪潮澎湃。当 Data 与 AI 深度交织，如何构建面向未来的技术栈？如何基于亚马逊云科技构数据分析业务？11月29日「如何打造AI时代的数据基石 | Databend Meetup 上海站」 应势而来！我们力邀多位来自明星开源项目与一线大厂的资深专家，为您全景解析数据平台架构、AI 创新实践与职业发展路径，开启一场思想与技术的碰撞。</p><p>本次 Meetup，我们荣幸地邀请到 Databend Labs 联合创始人吴炳锡、沉浸式翻译技术专家陈琦、数据平台架构师邵锋、平凯星辰（TiDB）解决方案架构师刘源、Airwallex 空中云汇数据库架构师赵飞祥，他们将带来兼具深度与广度的干货分享，为您呈现一场 Data + AI 的实践。</p><h2>活动信息</h2><p>⏰ 活动时间：2025 年 11 月 29 日（周六）13:30 - 17:30</p><p>📍 活动地点：上海市黄浦区中海国际中心 A 座 21 楼 </p><p>🔗 报名方式：（扫描海报二维码）线下参与采取审核制 (100 人)</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433097" alt="" title=""/></p><h2>活动亮点</h2><p>一线实战： 嘉宾来自业内知名企业及开源项目，分享内容源于真实业务场景。</p><p>全景视角： 覆盖从开源工具、AI 产品到企业级平台的完整产业链视角。</p><p>深度互动： 圆桌讨论与交流环节，让您有机会与嘉宾直接对话。</p><p>高端人脉： 结识众多对 Data 和 AI 充满热情的同道中人，拓展专业人脉圈。</p><h2>活动参与奖励</h2><p>🎁 丰厚参会福利：Databend 社区丰富周边,另有技术资料等你来拿~</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433098" alt="" title="" loading="lazy"/></p><h3>立即行动，锁定席位！</h3><ul><li>活动主题： DATA AI Databend Meetup</li><li>活动形式： 线下分享 + 圆桌讨论 + 自由交流</li></ul><p>无论您是数据工程师、AI 开发者、技术负责人，还是对数据智能充满好奇的学习者，这都将是一场收获满满的盛会。席位有限，请立即报名，与我们一同站在技术浪潮之巅，共绘 Data 与 AI 的未来图景！</p><h2>关于 Databend</h2><p>Databend 是一款 100% Rust 构建、面向对象存储设计的新一代开源云原生数据仓库，统一支持 BI 分析、AI 向量、全文检索及地理空间分析等多模态能力。期待您的关注，一起打造新一代开源 AI + Data Cloud。</p><p>👨‍💻‍ Databend Cloud：<a href="https://link.segmentfault.com/?enc=80ioTkkJDvbmJExVcDAecA%3D%3D.3wz5I9NKb7rSN7fBI9ulJU41oTEO3ZDENPdH87mM1oI%3D" rel="nofollow" target="_blank">https://databend.cn</a></p><p>📖 Databend 文档：<a href="https://link.segmentfault.com/?enc=8b%2FEujxdTlJ7eXX8SXzhqQ%3D%3D.NnlkWURIqnFsOzr0fBJMQwAhS5HjjFSc2b%2BMjfX5Dn8%3D" rel="nofollow" target="_blank">https://docs.databend.cn</a></p><p>💻 Wechat：Databend</p><p>✨ GitHub：<a href="https://link.segmentfault.com/?enc=mdhm8n4LJrRg4kDNNHQl%2FQ%3D%3D.dGYKIorXkPZ7rMVFi1J51Mgnl%2Bd0FRme3Duaml8w5sLrKjh%2BLIbScQ0%2BhTItiqRU" rel="nofollow" target="_blank">https://github.com/databendlabs/databend</a></p>]]></description></item><item>    <title><![CDATA[工业互联网工厂大脑：如何从数据混沌到智能]]></title>    <link>https://segmentfault.com/a/1190000047433128</link>    <guid>https://segmentfault.com/a/1190000047433128</guid>    <pubDate>2025-11-27 18:07:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在现代化工厂里，每天产生的数据量简直能吓人一跳。想象一下，一座大型汽车工厂在一天之内，可能就积累了上亿条来自设备、生产线、供应链等各个系统的数据。这些数据看似庞大，却往往像散落的拼图一样，格式不一、标准缺失，难以形成统一的分析框架。这种情况，就是所谓的“数据混沌”，也是全球制造业数字化转型中普遍存在的难题。而解决这一问题的关键，正是让数据从“杂乱无章的原材料”转变为“可直接使用的工业语言”。<br/>要实现这一目标，工厂大脑的出现无疑是一场技术革命。它不像传统工业软件那样只能处理简单的“如果A则B”规则，而是通过融合多模态数据、知识封装和智能协同，赋予工厂更强的“思考”能力。举个例子，广域铭岛提出的“工业智造超级智能体”方案，正是通过四步进阶路径，让数据流动起来，让工业智慧真正落地。<br/>第一步：数据筑基——从“杂乱”到“有序”<br/>在数据混沌的背景下，工厂大脑的第一步是通过“数据虚拟化引擎”将异构系统的数据统一翻译成标准格式。这听起来有点像给工厂装上了一个“数据翻译器”，但它的作用远不止于此。比如，某车企在引入广域铭岛的Geega工业AI平台后，原本分散在几十套老旧系统中的数据被整合成了统一的标准，亿级数据查询的响应时间从小时级缩短到了毫秒级。这意味着，工厂的决策者可以更快速地获取信息，而不是被淹没在数据的海洋中。<br/>第二步：知识封装——让经验变成可量化的模型<br/>传统工厂里，老师傅的经验往往被封存在个人记忆中，难以被机器理解和复制。但工厂大脑的“指标工场”功能，却让这些经验变得“数字化”。它把老师傅的“手感经验”转化为可量化的指标，甚至能将生产过程中的复杂逻辑拆解成标准化的流程。举个实际例子，某整车厂通过Geega平台的指标工场，将200多项工艺参数与良品率的关联关系编码成数字模型，让AI能够像资深技师一样预判质量问题。这就像是把工厂的“隐性知识”变成了“显性知识”，任何人都可以获取和使用。<br/>第三步：智能决策——从“事后补救”到“事前预防”<br/>数据筑基和知识封装只是基础，真正让工厂大脑发挥作用的是智能决策。在广域铭岛服务的某新能源电池项目中，AI模型通过调用封装好的设备健康指标，提前48小时预测出电极涂布机的异常，避免了200万元的停产损失。这种“事前预防”的能力，正是工厂大脑的核心价值所在。它不仅能减少损失，还能让工厂的运营更加顺畅。<br/>第四步：生态协同——让多个智能体形成“决策网络”<br/>单个AI模型解决特定问题已经不新鲜，真正的突破在于多个智能体的协同。广域铭岛的超级智能体架构通过“感知升维”“决策进化”和“知识增殖”，形成了一种“群体智慧”。比如，排产系统能自动协调物料库存、设备状态和订单优先级，实现全链条自主优化。这就好比让工厂的各个部门不再是孤立的个体，而是通过智能体的连接，形成一个高效的“决策网络”。<br/>工业知识的“数字基因工程”<br/>传统工业软件在面对复杂逻辑时显得力不从心，而工厂大脑却能游刃有余。它通过“经验参数化”“思维链可视化”和“动态知识图谱”，将工业知识转化为AI可理解的格式。广域铭岛的案例中，AI不仅能识别焊点缺陷，还能自动追溯至焊枪电极磨损程度、车间温湿度等12层潜在因素，复现了顶尖质检专家的思维路径。<br/>智能体的“群体智慧”革命<br/>多模态大模型的出现，进一步推动了工业AI的进化。广域铭岛牵头的重庆市2025人工智能重大科技专项，正是聚焦于工业多模态大模型的构建。该项目通过“平台+引擎+模板”的一体化交付，显著降低了企业数智化应用的门槛。未来，随着多模态大模型在工业场景的深入应用，制造业的智能化进程将迎来质的飞跃。<br/>未来工厂的“神经中枢”<br/>从数据治理到知识封装，再到智能决策与生态协同，工厂大脑正在成为未来工厂的“神经中枢”。它的价值不仅在于提升效率，更在于重构制造业的核心竞争力——让数据真正流动起来，让工业智慧突破时空限制持续进化。正如一位行业专家所说：“工业互联网的未来，不在于‘机器换人’，而在于‘大脑换芯’。”<br/>结语<br/>工业互联网工厂大脑的出现，为制造业的数字化转型注入了新的活力。广域铭岛的实践案例表明，工厂大脑不仅能解决数据孤岛、技术融合等问题，还能将企业的经验转化为可复用的知识库，推动全局优化。未来，随着技术的不断成熟，工厂大脑的应用范围将进一步扩大，成为中国制造业走向全球竞争舞台的关键支撑。</p>]]></description></item><item>    <title><![CDATA[PostgreSQL 18 - 时间约束]]></title>    <link>https://segmentfault.com/a/1190000047433155</link>    <guid>https://segmentfault.com/a/1190000047433155</guid>    <pubDate>2025-11-27 18:06:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>PostgreSQL 18 引入了一项强大的新功能，允许你在时间段内强制执行唯一性：<strong>时间约束（Temporal Constraints）</strong>。通过这一新增功能，你现在可以在定义 <code>UNIQUE</code>、<code>PRIMARY KEY</code> 或 <code>FOREIGN KEY</code> 约束时，利用日期范围（Date Range）或时间戳范围（Timestamp Range）字段，比以往更容易地防止数据重叠。</p><h2>问题所在：基于时间的唯一性</h2><p>在最新的这个版本中，PostgreSQL 增加了一种更灵活的方式来定义 <code>UNIQUE</code>、<code>PRIMARY KEY</code> 和 <code>FOREIGN KEY</code> 约束。我将把示例重点放在 <code>UNIQUE</code> 约束上，因为这在我看来是时间约束最有用的场景。</p><p>让我们从一个现实世界的场景开始：管理用户订阅。</p><h3>设置示例</h3><p>首先，我们有一个简单的 <code>users</code> 表，包含 2 行数据：</p><pre><code class="sql">CREATE TABLE users (
  id uuid DEFAULT uuidv7() PRIMARY KEY,
  email VARCHAR(100) UNIQUE NOT NULL
);

INSERT INTO users (email) VALUES 
('darth@example.com'),
('luke@example.com');</code></pre><h3>使用 WITHOUT OVERLAPS 的时间约束</h3><p>现在我想创建一个属于 <code>users</code> 表的 <code>subscriptions</code>（订阅）表。每个订阅都有开始和结束日期，我想确保每个用户的订阅是唯一的。用户可以有过去的订阅（也许他们升级了层级），但在任何给定的时间点只能有一个活跃的订阅。</p><p>以下是我们如何使用新的 <code>WITHOUT OVERLAPS</code> 语法来强制执行此操作：</p><pre><code class="sql">CREATE TABLE subscriptions (
  user_id uuid NOT NULL,
  type VARCHAR(50) NOT NULL,
  valid_period daterange NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  UNIQUE (user_id, valid_period WITHOUT OVERLAPS)
);</code></pre><p>如你所见，我们在 <code>valid_period</code> 这个 <code>daterange</code> 字段的 <code>UNIQUE</code> 约束中使用了 <code>WITHOUT OVERLAPS</code>。时间约束要求键列（<code>valid_period</code>）必须是范围类型（range type），因此通常你会使用 <code>daterange</code> 或 <code>timestamprange</code>，但它也适用于其他范围类型。</p><h3>测试一下</h3><p>让我们插入一些数据：</p><pre><code class="sql">INSERT INTO subscriptions (user_id, type, valid_period)
SELECT u.id, 'basic', daterange('2024-01-01', '2025-01-01', '[)')
FROM users u;

INSERT INTO subscriptions (user_id, type, valid_period)
SELECT u.id, 'premium', daterange('2025-01-01', '2026-01-01', '[)')
FROM users u
WHERE u.email = 'darth@example.com';

SELECT * FROM subscriptions;</code></pre><p>结果如下：</p><pre><code class="text">               user_id                |  type   |      valid_period
--------------------------------------+---------+-------------------------
 0199f293-291a-70bf-b9ee-872247723d29 | basic   | [2024-01-01,2025-01-01)
 0199f293-291b-737a-9bd0-e0e0853e3377 | basic   | [2024-01-01,2025-01-01)
 0199f293-291a-70bf-b9ee-872247723d29 | premium | [2025-01-01,2026-01-01)</code></pre><p>在这个例子中，Luke 显然在 2025 年停止了付费，而 Darth 升级到了高级版。我通常习惯使用单独的列来表示开始和结束日期，但我很欣赏范围类型（Ranges）能够启用此功能，并允许我们使用强大的范围运算符。</p><h3>额外内容：查询活跃订阅</h3><p>使用“冰淇淋筒”运算符（<code>@&gt;</code>，即包含运算符），我们可以轻松找到特定日期有效的订阅：</p><pre><code class="sql">SELECT * FROM subscriptions
WHERE valid_period @&gt; '2025-01-01'::date;</code></pre><p>这个查询会告诉我们哪些订阅在 2025 年 1 月 1 日是活跃的。</p><h3>重要提示：GIST 与 B-Tree 索引</h3><p>有一个陷阱：范围列使用 GIST 索引，而 UUID 列使用 B-Tree 索引。当我运行 <code>CREATE TABLE subscriptions</code> 命令时，我遇到了一个错误。为了解决这个问题，你需要启用以下扩展：</p><pre><code class="sql">CREATE EXTENSION btree_gist;</code></pre><h2>了解更多</h2><p>如果你想深入了解时间约束，请查看 PostgreSQL 文档中关于 <a href="https://link.segmentfault.com/?enc=2Gc%2FpFQ5aXHSjRW89d2DSw%3D%3D.X8eVR4p6XAH%2FSQA5fNyZDURbHY6giFOEwQFNzl2C1WNtkR4nc7iP4zPdtNNDl6xTz5VXPDYS08pgRILEYDrtnanOF3ImjYkRc2PfKL5T0ljLBh7tbcDA1o2waljzLzzjuH8A42uPUVMDqx78NbcUkLfxT3GIk8fHM3CihNQmdUtvZLLSTtqwEywyDlZjQiKb" rel="nofollow" target="_blank">WITHOUT OVERLAPS</a> 的部分。</p><p>原文链接：<a href="https://link.segmentfault.com/?enc=pKaL3AyuMT7cwF1k95J2qg%3D%3D.mm2hvj%2Bm9QnKzMVRXuxJN9zJfIXf%2FcZpgs3SDbzhgoWnCB5VAw%2FVs5obRwNVLn1EZZdOa%2Fv7wG%2FAFJ2rxyzaJ6csQDWcrVjSXi33BepZrS8%3D" rel="nofollow" target="_blank">https://hashrocket.com/blog/posts/postgresql-18-temporal-cons...</a></p><p>作者：Vinicius Negrisolo</p>]]></description></item><item>    <title><![CDATA[图扑软件 3D 场景预加载应用实现 图扑]]></title>    <link>https://segmentfault.com/a/1190000047433158</link>    <guid>https://segmentfault.com/a/1190000047433158</guid>    <pubDate>2025-11-27 18:06:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="915" referrerpolicy="no-referrer" src="/img/bVdnbDB" alt="image.png" title="image.png"/></p><p>预加载是在进入正式场景之前提前加载所需模型、材质、图片等资源的技术手段，其核心价值在于消除资源加载等待，确保场景首次渲染即可完整呈现，从而提供无缝、流畅的用户体验。在复杂的 Web 3D 可视化应用中，资源预加载尤为重要，可有效解决首次加载时的卡顿、白屏及交互延迟等问题。</p><h2>预加载实现方案</h2><h3>基础实现原理</h3><p>HT for Web 中所有资源的请求都会经过 ht.Default.convertURL 方法，该方法提供了统一的资源请求入口：</p><ul><li>当返回字符串路径时，框架会按此路径发起资源请求；</li><li>当返回 {data: content} 格式对象时，框架会直接使用 content 作为资源内容。</li></ul><p>基于此特性，我们可实现预加载机制</p><pre><code class="javaScript">// 资源缓存映射表
let sourceMap = {}; 
// 判断是否为本地资源
functionisLocalUrl(url) {
    return url.startsWith('data:') || url.startsWith('blob:');
}
// 重写 convertURL 方法
let oldFunc = ht.Default.convertURL;
ht.Default.convertURL = function(url) {
    if (isLocalUrl(url)) return url;
    
    let source = sourceMap[url];
    if (source) {
        return { data: source };
    }
    
    return oldFunc(url);
};</code></pre><h3>资源加载策略</h3><h4>部分资源预加</h4><p>适用于资源量较大但部分关键资源需要优先加载的场景。</p><pre><code class="javaScript">// 关键资源列表
let resources = [
    "models/model.json",
    "assets/texture.png",
    "symbols/symbols.json"
]
</code></pre><p><img width="723" height="335" referrerpolicy="no-referrer" src="/img/bVdnbDM" alt="image.png" title="image.png" loading="lazy"/></p><h4>全量资源预加载</h4><p>获取所有已注册资源进行预加载：</p><pre><code class="javaScript">functiongetAllResources() {
    return [
        ...Object.keys(ht.Default.getImageMap()),
        ...Object.keys(ht.Default.getCompTypeMap()),
        ...Object.keys(ht.Default.getShape3dModelMap()),
        ...Object.keys(ht.Default.getMaterialMap()),
        ...Object.keys(ht.Default.getHdrTextureMap())
    ];
}
let allResources = getAllResources();</code></pre><p><img width="723" height="335" referrerpolicy="no-referrer" src="/img/bVdnbD9" alt="image.png" title="image.png" loading="lazy"/></p><h3>资源加载实现</h3><pre><code class="javaScript">// 资源类型判断
const ResourceType = {
    IMAGE: /\.(png|jpg|gif|jpeg|bmp|svg)$/i,
    BUFFER: /\.(fbx|gltf|glb)$/i,
    HDR: /\.hdr$/i,
    TGA: /\.tga$/i,
    JSON: /\.json$/i
};

class ResourceLoader {
    constructor(resources) {
        this.resources = resources;
        this.loaded = 0;
    }

    load() {
        this.resources.forEach(url =&gt; {
            if (ResourceType.BUFFER.test(url)) {
                this.loadBuffer(url);
            }
            else if(ResourceType.IMAGE.test(url)) {
                this.loadImage(url);
            } // 其他资源类型处理...        
        });
    }

    loadBuffer(url) {
        ht.Default.xhrLoad(url, res =&gt; {
            this.onResourceLoaded(url, res);
        }, {
            responseType: 'arraybuffer'
        });
    }

    // 其他加载方法...
    onResourceLoaded(url, res) {
        sourceMap[url] = res;
        this.loaded++;
        this.onProgress(this.loaded, this.resources.length);
        if (this.loaded === this.resources.length) {
            this.onAllLoaded();
        }
    }

    // 加载进度回调
    onProgress(loaded, total) {
        console.log(`加载进度: ${loaded}/${total}`);
    };

    onAllLoaded() {
        console.log("所有资源预加载完成");
        // 进入主场景...   
    }
}</code></pre><p><img width="723" height="335" referrerpolicy="no-referrer" src="/img/bVdnbEi" alt="image.png" title="image.png" loading="lazy"/></p><h2>加载页面优化</h2><h3>进度展示设计</h3><pre><code class="javaScript">class LoadingView{
    constructor() {
        this.initView();
    }

    initView(){
        this.dm = new ht.DataModel();
        this.view = new ht.graph.GraphView(this.dm);
        
        let style = this.view.getView().style;
        style.left = "0";
        style.right = "0";
        style.top = "0";
        style.bottom = "0";
        document.body.appendChild(this.view.getView());
    }
    
    // 更新进度
    updateProgress(percent) {
        
    }
    
    // 移除加载页面
    remove() {
        setTimeout(() =&gt; {
            this.view.getView().remove();
            this.enterMainScene();
        }, 1);
    }
    
    // 进入主场景
    enterMainScene(){

    }
}</code></pre><h3>视觉优化建议</h3><ul><li><p>进度条设计：使用图标实现平滑动画。</p><p><img width="723" height="335" referrerpolicy="no-referrer" src="/img/bVdnbEk" alt="image.png" title="image.png" loading="lazy"/></p></li><li><p>背景动画：添加轻量级背景动画提升等待体验。</p><p><img width="723" height="335" referrerpolicy="no-referrer" src="/img/bVdnbEl" alt="image.png" title="image.png" loading="lazy"/></p></li><li>分段进度：将加载过程分为资源加载、场景初始化等阶段。</li><li>预估时间：基于已加载时间预测剩余时间。</li></ul><h2>性能优化方案</h2><h3>Service Worker 离线缓存</h3><pre><code class="javaScript">// sw.js
let CACHE_NAME = 'ht-resources-v1';

self.addEventListener('fetch', event =&gt; {
    event.respondWith(caches.match(event.request).then(function (response) {
        if (response !== undefined) {
            return response;
        } else {
            return fetch(event.request).then(function (response) {
                if (event.request.url.indexOf('storage') != -1) {
                    let responseClone = response.clone();
                    caches.open(CACHE_NAME).then(function (cache) {
                        cache.put(event.request, responseClone);
                    });
                }
                return response;
            }).catch(function () {
                return caches.match('./');
            });
        }
    }));
});

self.addEventListener('activate', function (event) {
    event.waitUntil(clients.claim());
    event.waitUntil(
        caches.keys().then(function (keyList) {
            returnPromise.all(keyList.map(function (key) {
                if (key !== CACHE_NAME) {
                    // 删除旧缓存
                    return caches.delete(key);
                }
            }));
        })
    );
});</code></pre><h3>资源压缩策略</h3><ul><li><strong>模型优化</strong>：轻量化模型，对模型进行减面。</li><li><strong>图片优化</strong>：图片资源压缩。</li></ul><h2>效果对比与总结</h2><h3>加载效果对比</h3><p>预加载方案虽然初始显示时间较长，但提供了更优的整体用户体验：</p><ul><li><strong>完整的场景一次性呈现</strong>，避免零碎加载造成的视觉割裂。</li><li><strong>无卡顿的交互体验</strong>，所有资源已就绪。</li><li><strong>可控的等待预期</strong>，进度反馈降低用户焦虑。</li><li><strong>更稳定的性能表现</strong>，避免运行时资源加载导致的卡顿。</li></ul><p><em>预加载效果如下</em><br/><img width="640" height="323" referrerpolicy="no-referrer" src="/img/bVdnbEt" alt="image.png" title="image.png" loading="lazy"/></p><p><em>常规加载效果</em><br/><img width="640" height="324" referrerpolicy="no-referrer" src="/img/bVdnbEC" alt="image.png" title="image.png" loading="lazy"/></p><p><img width="723" height="483" referrerpolicy="no-referrer" src="/img/bVdnbED" alt="image.png" title="image.png" loading="lazy"/></p><h3>适用场景</h3><ul><li><p>大型 3D 场景：包含复杂模型和纹理的场景。</p><p><img width="723" height="263" referrerpolicy="no-referrer" src="/img/bVdnbEF" alt="image.png" title="image.png" loading="lazy"/></p></li><li>仪表盘应用：需要快速响应的监控系统。</li><li>移动端应用：网络条件不稳定的环境。</li><li>演示系统：需要流畅演示效果的场合。</li></ul><h3>实施建议</h3><ul><li>分阶段实施：先对关键资源预加载，再逐步扩展。</li><li>性能监控：添加加载时间统计和分析。</li><li>A/B 测试：对比不同策略的实际效果。</li></ul><h2>总结</h2><p>综上所述，本预加载方案能显著提升 HT for Web 应用的加载性能和用户体验，特别适合对流畅性要求高的可视化应用场景。在实际项目中，应根据资源规模和用户场景灵活调整预加载策略，平衡加载时间和用户体验。</p>]]></description></item><item>    <title><![CDATA[6 个白嫖 Nano Banana Pr]]></title>    <link>https://segmentfault.com/a/1190000047432505</link>    <guid>https://segmentfault.com/a/1190000047432505</guid>    <pubDate>2025-11-27 18:05:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>前言</h2><p>Nano Banana Pro 最近很火。</p><p>作为排名第一的 AI 图片生成模型，其生成的图片效果十分惊艳，但惊艳的效果往往都比较费钱……</p><p>于是我注册了十几个网站，找了一些不费钱的 Nano Banana Pro 使用网站，对于日常使用完全足够了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432507" alt="" title=""/></p><p>10 年技术博主，最新资讯、前端知识、AI 干货，欢迎关注公众号：“冴羽” 或者搜索“yayujs”</p><h2>1. Gemini 每天 2 张</h2><p>地址：<a href="https://link.segmentfault.com/?enc=ofSaQ6g5ke9X%2Ft%2FnKTJRBg%3D%3D.9LO597DSL9zOVmvOgWMlwC1uyRa9UqC0swyh8QPPaOQ%3D" rel="nofollow" target="_blank">https://gemini.google.com/</a></p><p>在 Gemini 官网的对话框中选择生成图片工具，同时选择思考模型（即 Gemini 3 Pro）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432508" alt="" title="" loading="lazy"/></p><p><strong>注意：无法直接访问，24 小时内只能生成 2 张。</strong></p><h2>2. Flowith 目前免费</h2><p>地址：<a href="https://link.segmentfault.com/?enc=PHUcKhX9ZM5h2IehqgKQwA%3D%3D.oJZqfdzcvO%2FUGqbWfEdOhuPnWlr06rxKZFrLuOxv0s%2FyM%2FrDNOuK%2FyhCwSOHxwbn" rel="nofollow" target="_blank">https://flowith.net?inv=TTCADL5WDDXRU8Y8</a></p><p>初始 1000 积分，使用该邀请码额外赠送 3000 积分</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432509" alt="" title="" loading="lazy"/></p><p>注意：国内可访问，目前可免费使用 Nano Banana Pro，下载图片无水印。</p><h2>3. Felo 目前免费</h2><p>地址：<a href="https://link.segmentfault.com/?enc=DIIoNrzUFUg32biLzAxdWQ%3D%3D.aZLLPpSlc7d3FeNWaTt0Fm%2F70xOsz3SiwjsB2t4gks3VSzQwQNLlmf7ekYujjLPNccWGND9oXCoYtvOvBAbxLg%3D%3D" rel="nofollow" target="_blank">https://felo.ai/invitation?invite_code=qq977WkBjjJkg</a></p><p>每天赠送 200 积分，使用该邀请码额外赠送 1500 积分</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432510" alt="" title="" loading="lazy"/></p><p>注意：国内可访问，目前可免费使用，下载图片无水印。</p><h2>4. LMArena 目前免费</h2><p>地址：<a href="https://link.segmentfault.com/?enc=FJ1Wh%2BPcZWmMXtc5GxhVTg%3D%3D.EO2hrpxZmjMZV3fsY%2FPQ9HvWMZuvVBOkTRJjG3FGl836KYbm2zSn7rMW8Fgwzr985XK8mJfgAHKXLT8%2FfTDK%2FQ%3D%3D" rel="nofollow" target="_blank">https://lmarena.ai/zh/c/new?mode=direct&amp;chat-modality=image</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432511" alt="" title="" loading="lazy"/></p><p>注意：无法直接访问，目前可免费使用，使用时有些不稳定。</p><h2>5. 海螺 AI 每天 50 张</h2><p>地址：<a href="https://link.segmentfault.com/?enc=Wa1LY9wxqGSg7WdfFvvYgA%3D%3D.1IBWk%2FD%2BE6D%2FXjK89w3lb2U9xm5Y9%2BhDax1m7NP0rOI%3D" rel="nofollow" target="_blank">https://hailuoai.com/</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432512" alt="" title="" loading="lazy"/></p><p>注意：国内可访问，非会员目前每天免费生成 50 张图片，图片有水印，需要开会员去除。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432513" alt="" title="" loading="lazy"/></p><h2>6. YouMind 消耗积分</h2><p>地址：<a href="https://link.segmentfault.com/?enc=iJRMLw7smb%2F%2BNpYOnw6PJQ%3D%3D.Oxy5ROuOlSS%2BlJ4D1LCwFmC5E8Op27EHFyRdC1LTrSFmwGVGEYnl1biNREKGa66t" rel="nofollow" target="_blank">https://youmind.com/invite/2KRVE5</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432514" alt="" title="" loading="lazy"/></p><p>注意：每月可以免费获取 2000 积分，使用 Nano Banana Pro 生成图片每张大概消耗 15 积分。</p><p>注册的时候，使用邀请码：<a href="https://link.segmentfault.com/?enc=oj98FcdmxxXoLG%2BC8Q%2B2rA%3D%3D.G%2FQCYEpHHG6FBuXdBd7W5pOvaxWyxn8K6HVBkURzuatho9udpxuG%2FffHwrhPyCJC" rel="nofollow" target="_blank">2KRVE5</a>，可以多获得 1000 积分，又可以多生成 66 张图片了。</p><h2>最后</h2><p>还有很多花钱的、用积分的网站，就不多说了，这些免费的网站已经够用了。</p><p>毕竟辛苦注册体验了十几个网站，求个关注和点赞不过分吧 😂</p>]]></description></item><item>    <title><![CDATA[NeurIPS 2025|让AI读懂第一]]></title>    <link>https://segmentfault.com/a/1190000047433166</link>    <guid>https://segmentfault.com/a/1190000047433166</guid>    <pubDate>2025-11-27 18:04:26</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>NeurIPS 2025|让AI读懂第一视角的“内心独白”！浙大等联合突破性实现自我中心视频推理</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433168" alt=" " title=" "/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433169" alt=" " title=" " loading="lazy"/></p><p>论文名称：<em>EgoThinker: Unveiling Egocentric Reasoning with Spatio-Temporal CoT</em></p><p>发布时间：2025年10月28日</p><p><a href="https://link.segmentfault.com/?enc=I%2BUe%2Fr2jCKNI%2BR3swZcmCQ%3D%3D.x4uP9pKvuYUo4fzdUvQ7V%2Bk2RQUj6Llbo4MLhmRKQRMDua0B8cRpgRjadFNud9B7" rel="nofollow" target="_blank">👉一键直达论文</a></p><p><a href="https://link.segmentfault.com/?enc=Z9Z2qYo6rGNM6CBme8Tnbw%3D%3D.JrmFr3Q3Nn87Oec2KqaIStoq3xqOKBqaW7kgbXt2NRhNXNUbvZR%2B35EllcTUKxxn" rel="nofollow" target="_blank">👉一键直达Github</a></p><p><a href="https://link.segmentfault.com/?enc=gby6YCK1Dbps8C%2FdkJq14g%3D%3D.d4rumZtPnE1j7ebiq6LAEvXs9%2FK4Te%2BHlnHqLfi7rN%2FTGfHlN5uhERzA%2B3NCkGYW3IstxovBCaozNSFVMdkuqhQ4F5Vp1gSawcyZcMrteQQ1zEjRQG06NqFyU9PaQ%2FKGLz0BnQETDLNG9W08w9JiDg%3D%3D" rel="nofollow" target="_blank">👉Lab4AI大模型实验室论文阅读</a></p><p>✅此平台提供AI导读和翻译等工具，辅助论文阅读。</p><h3>✨研究背景</h3><p>现有多模态大语言模型擅长第三人称视觉理解，但缺乏第一人称（自我中心）视角的推理能力。自我中心视频的核心挑战在于推断摄像机佩戴者不可见的意图及其与环境的细粒度交互，这要求模型具备长时序因果推理和精确的时空定位能力。然而，当前主流数据集缺乏详细的推理链和手物交互标注，导致模型难以理解复杂的自我中心活动，限制了其在可穿戴助手和具身智能中的应用。</p><h3>✨研究框架</h3><p>EgoThinker的框架核心是数据驱动与两阶段训练。首先，我们构建了包含500万问答对的大规模数据集EgoRe-5M，其囊括了从短时感知到长时序因果推理的多种任务。基于此，模型先通过监督微调 学习基础的视频理解与推理能力；再通过基于规则奖励的强化微调，专门优化其在手物空间定位与时间区间定位上的精度，从而将高层推理与低层感知紧密结合。</p><h3>✨核心贡献</h3><p>本文的核心贡献包括三方面：</p><ul><li>提出EgoRe-5M数据集：这是一个包含丰富思维链与手物交互标注的大规模自我中心问答数据集，涵盖多样化的真实场景与任务类型，为自我中心推理研究提供了重要数据基础。</li><li>设计两阶段训练范式：通过SFT+RFT的结合，显著提升了模型在时空定位与因果推理方面的能力，尤其在细粒度交互理解与长时序推理任务中表现突出。</li><li>构建EgoThinker模型并在多个基准测试中取得SOTA性能：在EgoPlan、EgoSchema、VLN-QA等自我中心推理任务中显著优于现有模型，同时保持通用视频理解能力，展示了其在可穿戴AI与具身智能中的潜力。</li></ul>]]></description></item><item>    <title><![CDATA[地图类相关开发简记 lpe234 ]]></title>    <link>https://segmentfault.com/a/1190000047433180</link>    <guid>https://segmentfault.com/a/1190000047433180</guid>    <pubDate>2025-11-27 18:03:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>基础知识</h2><p>Leaflet 默认使用 EPSG:3857（Web Mercator 投影） 来显示地图，这是一种投影坐标系，而不是地理坐标系。</p><p>Leaflet 接收的是 WGS84 经纬度（EPSG:4326），即 <code>[lng, lat]</code>。</p><p>如果底图是高德/百度：需要先把 WGS84 转换成 GCJ-02 或 BD-09，再传给 Leaflet。</p><h3>常用坐标系</h3><ol><li>WGS84（World Geodetic System 1984）</li></ol><ul><li>特点：全球通用的 GPS 坐标系，国际标准。</li><li>应用：卫星定位、航空、海运、Google Maps。</li><li>坐标单位：经纬度（度）。</li><li>偏差：在中国使用时会有几十到几百米偏差，因为国内地图加了加密。</li></ul><ol start="2"><li>GCJ-02（国测局坐标系，火星坐标系）</li></ol><ul><li>特点：在 WGS84 基础上加密偏移。</li><li>应用：中国大陆的高德地图、腾讯地图、Google 中国版。</li><li>偏差：相对 WGS84 偏移约 300 米。</li></ul><ol start="3"><li>BD-09（百度坐标系）</li></ol><ul><li>特点：在 GCJ-02 基础上再次加密偏移。</li><li>应用：百度地图。</li><li>偏差：比 GCJ-02再偏移几十米。</li></ul>]]></description></item><item>    <title><![CDATA[工业互联网数字化服务商：如何从数据孤岛到]]></title>    <link>https://segmentfault.com/a/1190000047433185</link>    <guid>https://segmentfault.com/a/1190000047433185</guid>    <pubDate>2025-11-27 18:02:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>制造业的数字化转型，表面上看是技术升级，实际上是一场关于数据的革命。每天，车间里几十套独立系统产生的数据就像一座座孤岛，各自为政，难以产生协同效应。这种情况下，企业需要一个能打通数据壁垒、转化数据价值的“数字化中介”——这就是工业互联网服务商的核心价值所在。<br/>工厂数据为何如此难以整合？<br/>想象一下，一座大型工厂有ERP、MES、SCADA等几十套系统，它们各自记录着不同的生产环节数据。比如某车企的冲压车间，仅设备状态数据就分布在30多个独立系统中，数据格式不统一导致查询效率极低。这时候，工业互联网服务商的作用就凸显出来了。他们通过构建统一的数据平台，把这些“鸡同鸭讲”的数据重新组织起来，变成可读、可用的信息资产。<br/>数字化服务商的四大核心能力<br/>优秀的工业互联网服务商往往具备四个关键特质：一是技术实力，能搭建稳定的数据基础设施；二是资源集聚能力，懂得整合上下游产业链资源；三是行业理解深度，明白制造业的痛点和需求；四是生态协同能力，能带动多个合作伙伴形成完整解决方案。<br/>以广域铭岛为例，他们从吉利工业大脑起步，逐步发展出覆盖汽车、电池、电子等行业的数字化服务体系。他们的平台不仅支持数据采集，还具备独特的“知识软件化”能力，能把工程师的经验转化为AI可理解的模型，实现真正的智能决策。<br/>成功案例：从数据混乱到智能协同<br/>某动力电池制造厂在引入广域铭岛服务前，面临着设备故障率高、能耗不均等问题。通过他们的“智能体协同平台”，工厂实现了设备预测性维护，减少了30%的非计划停机时间；同时通过能耗优化模块，实现了碳排放的精准管控。这些成果背后，是服务商帮助客户搭建的数据治理体系发挥了关键作用。<br/>如何选择合适的数字化服务商？<br/>选择服务商不是简单比较价格或功能，而是要看三个维度：一是技术架构能否支撑企业全生命周期需求；二是实施团队是否具备真实的行业经验；三是能否形成开放的生态体系，让企业获得持续创新能力。广域铭岛作为工信部认可的跨行业平台，这些方面都表现突出。<br/>数字化服务商的未来发展趋势<br/>随着工业4.0推进，服务商的角色正在从单纯的“工具提供商”向“价值共创者”转变。他们不再只卖软件，而是帮客户设计数字化转型路径，甚至参与企业战略制定。这种趋势下，像广域铭岛这样具备深厚行业积累的服务商更具竞争力。<br/>结语：数字化转型需要“明白人”<br/>工业互联网服务商正在成为制造业数字化转型的关键角色。他们不仅提供技术解决方案，更重要的是帮助企业建立“数据驱动”的思维模式。在选择服务商时，企业需要找那些真正理解制造业痛点、能提供可持续服务的伙伴。</p>]]></description></item><item>    <title><![CDATA[观测云 MCP Server 接入和使用]]></title>    <link>https://segmentfault.com/a/1190000047433230</link>    <guid>https://segmentfault.com/a/1190000047433230</guid>    <pubDate>2025-11-27 18:02:10</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>MCP  介绍</h2><p>MCP Server，模型上下文协议（Model Context Protocol，简称 MCP） 是一个开放协议，旨在标准化应用程序与 AI 模型之间的安全连接和数据源访问。它的核心目标是让开发者能够通过统一的“工具”和“资源”，轻松地为模型提供上下文信息（如数据、内容、操作），从而增强模型能力，而无需重新训练模型。</p><p>基于 MCP Server 构建的服务，最终提供一个统一的多模型可调用接口。该服务支持多客户端接入，并采用 API Key 鉴权机制，以此安全访问观测云的各项核心功能，包括监控器、日志、仪表板及 DQL 查询。</p><h2>观测云</h2><p>观测云是一款专为 IT 工程师打造的全链路可观测产品，它集成了基础设施监控、应用程序性能监控和日志管理，为整个技术栈提供实时可观察性。这款产品能够帮助工程师全面了解端到端的用户体验追踪，了解应用内函数的每一次调用，以及全面监控云时代的基础设施。此外，观测云还具备快速发现系统安全风险的能力，为数字化时代提供安全保障。</p><h3>MCP Server 接入</h3><p>此处以通过 Cherry Studio 接入方式为例。</p><p>1、下载 <a href="https://link.segmentfault.com/?enc=IYHnhgrcGr9zkx8uK%2BkxiQ%3D%3D.HP5Gz95PB4KJiyT8lZDJhUxQBjNNZ%2Fhzrm0PWX1fSKwxY9ykxsF1jx6WOcDotXcboNV1msWb9kqP%2Bg%2FQ1dy%2FfQ%3D%3D" rel="nofollow" target="_blank">MCP Server 客⼾端 Cherry Studio</a>，选择对应版本</p><p>2、打开 Cherry Studio，点击设置，点击 MCP，点击添加</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433232" alt="图片" title="图片"/></p><p>提示：如果 mcp 服务不能开启请安装 UV Bun</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433233" alt="图片" title="图片" loading="lazy"/></p><p>3、MCP Server 设置 </p><p>3.1  设置 MCP 服务器名称 （这里以命名 MCP 服务器 为例） 点击类型选择 streamableHttp</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433234" alt="图片" title="图片" loading="lazy"/></p><p>3.2  配置URL以及请求头</p><p>定义 URL：<code>https://obsy-ai.guance.com/obsy_ai_mcp/mcp</code></p><p>请求头格式为：<code>Authorization=DF-API-KEY;Endpoint=SITE_KEY</code></p><p>配置说明</p><ul><li>接⼝以 <a href="https://link.segmentfault.com/?enc=gJUSDqQosKl4o9ZfO98VQA%3D%3D.hxta3ciUoXRIYzHe6xzHwnIoy068t4d1iu%2BrKISfJfc861LrwStSvX1D8GMfvSV9" rel="nofollow" target="_blank">API KEY</a> 为认证⽅式，每⼀次请求使⽤请求体 Header 中的 <code>DF-API-KEY</code> 的值作为有效性检验，以及本次请求的⼯作空间限定依据（取此 <code>DF-API-KEY</code> 所属的⼯作空间）；</li><li>当前 MCP 服务所展⽰的所有接⼝都只需要提供 <code>API KEY</code> （Header：<code>DF-API-KEY</code>）作为凭证。如果凭据存在且有效，则视为认证通过。</li><li>MCP Endpoint 配置参数为 <code>SITE_KEY</code>，例如: <code>cn1</code>。具体对应 MAP 参考如下：</li></ul><pre><code>SITE_KEY_MAP = {
    # === 中国区 SaaS 部署 ===
    "cn1": "https://openapi.guance.com",        # 中国区1（杭州）——默认
    "cn2": "https://aws-openapi.guance.com",    # 中国区2（宁夏）
    "cn4": "https://cn4-openapi.guance.com",    # 中国区4（广州）
    "cn6": "https://cn6-openapi.guance.one",    # 中国区6（香港）
    "us1": "https://us1-openapi.guance.com",    # 海外区1（俄勒冈）
    "eu1": "https://eu1-openapi.guance.one",    # 欧洲区1（法兰克福）
    "ap1": "https://ap1-openapi.guance.one",    # 亚太区1（新加坡）
    "za1": "https://za1-openapi.guance.com",    # 非洲区1（南非）
    "id1": "https://id1-openapi.guance.com",    # 印尼区1（雅加达）
}</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433235" alt="图片" title="图片" loading="lazy"/></p><p>4、配置完 MCP 服务后，点击开启按钮</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433236" alt="图片" title="图片" loading="lazy"/></p><p>5、回到⾸⻚，选择话题或者助手中点击图标，选择刚刚创建的 MCP（这里以 MCP 服务器为例）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433237" alt="图片" title="图片" loading="lazy"/></p><p>6、验证消息已确认是否接入了 MCP 服务</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047433238" alt="图片" title="图片" loading="lazy"/></p><h2>总结</h2><p>大模型接入 MCP 服务的好处：</p><ul><li>突破自身局限，既能获取训练数据之外的实时信息，也能安全调取企业私有数据，还能弥补复杂操作能力短板；</li><li>调用工具更高效，MCP 的统一标准省去逐个适配不同工具接口的麻烦，还能串联多个工具协同完成复杂任务；</li><li>降低开发与运维成本，开发者无需关注工具底层差异，可聚焦业务，同时多工具协作的问题也能通过标准化协议简化；</li><li>便于搭建应用生态，既能轻松接入现有各类 MCP 服务快速适配新场景，也能将自身特色能力封装成 MCP 服务供他人复用。</li></ul>]]></description></item><item>    <title><![CDATA[二进制漏洞扫描技术一览 深盾安全 ]]></title>    <link>https://segmentfault.com/a/1190000047433248</link>    <guid>https://segmentfault.com/a/1190000047433248</guid>    <pubDate>2025-11-27 18:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>静态二进制分析</h2><p>静态二进制分析是在不执行程序的情况下，通过分析二进制文件的结构和代码来发现潜在漏洞的技术。该过程始于反汇编与反编译阶段，工具将机器指令转换为可读的汇编代码或高级语言伪代码。例如，工具可以将机器码<code>55 48 89 E5</code>转换为汇编指令<code>push rbp; mov rbp, rsp</code>，这为后续分析奠定了基础。</p><p>现代静态分析工具普遍采用中间表示技术来提升分析效果。通过将底层指令转换为统一的中间表示，分析工具能够在更高抽象层次上理解程序语义，为后续的控制流分析和数据流分析提供便利。</p><h3>符号执行</h3><p>符号执行将程序输入表示为符号值而非具体数据，系统会沿着执行路径收集约束条件，并使用求解器生成能触发特定路径的测试用例。例如，当遇到条件分支<code>if (x &gt; 5)</code>时，符号执行会同时探索两个分支，分别记录约束条件<code>x &gt; 5</code>和<code>x &lt;= 5</code>。</p><p>这种方法能够系统性地探索程序执行路径，发现深层逻辑漏洞。但有路径爆炸问题，特别是在处理包含循环和递归的大型程序时，可能产生指数级数量的路径，导致分析难以完成。</p><h3>控制流分析</h3><p>控制流分析通过构建控制流图来理解程序的结构和执行逻辑。分析工具将代码划分为基本块，并通过边连接表示可能的执行路径。这种分析能够识别不可达代码、循环结构和异常处理流程。</p><p>在实际应用中，控制流分析能够发现函数返回前未释放资源、异常处理缺失等问题。例如，通过分析控制流图，可以识别出在某些执行路径中，文件句柄未能正确关闭的情况。</p><h3>数据流分析</h3><p>数据流分析关注信息在程序中的传播和变换过程。定义-使用链分析建立变量定义点与使用点之间的关系，揭示数据的生命周期。污点分析扩展了这一概念，通过标记不可信数据源并跟踪其传播过程来发现安全问题。</p><p>当污点数据影响敏感操作点时，如系统调用参数或跳转地址，分析器会报告潜在漏洞。这种方法能有效发现SQL注入、命令注入等类型的安全问题。</p><h3>模式匹配</h3><p>模式匹配技术在二进制漏洞扫描中通过预定义的漏洞特征库进行快速识别。该方法基于已知的漏洞模式建立检测规则，包括危险函数调用序列、特定代码模式以及常见漏洞实现特征。</p><p>在具体实现中，模式匹配引擎通过以下方式运作：首先，对危险API调用进行精确匹配，包括strcpy、gets、sprintf等不安全的字符串处理函数，以及system、popen等可能引发命令注入的系统调用。其次，识别典型的缓冲区操作模式，例如缺乏边界检查的循环拷贝操作、栈缓冲区与用户输入的直间操作等。此外，还检测特定的内存管理错误模式，如malloc/free不匹配、多次释放等常见问题。</p><p>现代模式匹配系统采用多层次检测策略。在语法层面，通过函数签名和调用序列进行基础匹配；在语义层面，结合数据流分析识别实际存在风险的代码模式；在上下文层面，考虑函数调用环境以降低误报。例如，对于strcpy函数的使用，只有在源数据来自不可信输入且缺乏明确边界检查时才标记为漏洞。</p><p>模式匹配系统面临的主要挑战包括规则库的维护和更新。随着新型漏洞的不断出现和代码编写方式的变化，规则库需要持续更新以保持检测效果。同时，代码混淆和编译器优化可能改变漏洞的表现形式，增加了模式识别的难度。</p><p>在实际应用中，模式匹配通常作为漏洞扫描流程的初步筛查环节，为后续更深入的分析提供重点目标。其价值在于能够快速处理大量代码，识别出明显的安全问题，为资源密集型的深度分析提供指导方向。</p><h2>动态二进制分析</h2><p>动态二进制分析通过实际运行程序来发现漏洞，这种方法能够捕获程序在真实环境中的行为表现。与静态分析相比，动态分析需要构建合适的测试环境，并提供充分的输入数据来执行目标程序。</p><p>动态分析的主要优势在于其结果的高可信度，所有发现的漏洞都是实际触发的。然而，该方法的测试覆盖率依赖于输入数据的质量，可能无法执行到所有的代码路径。</p><h3>模糊测试</h3><p>模糊测试通过向目标程序提供大量异常输入，并监控其是否崩溃或产生异常来发现漏洞。基于覆盖率的模糊测试通过代码插桩收集执行路径信息，智能地引导测试过程。</p><p>以AFL++为代表的现代模糊测试工具使用遗传算法进化测试用例，优先保留那些能够触发新执行路径的输入。这种方法能有效发现缓冲区溢出、整数溢出等类型的内存破坏漏洞。</p><h3>动态插桩和Sanitizer</h3><p>动态插桩技术在程序运行时插入检测代码，实时监控程序的内存访问和操作行为。AddressSanitizer采用影子内存映射机制，在应用程序内存和检测内存之间建立映射关系，为每个内存字节维护对应的状态标识。该技术通过在内存分配时设置红区、在释放时标记为不可用，有效检测越界访问和使用已释放内存等错误。</p><p>当程序执行内存操作时，AddressSanitizer会实时检查影子内存中的状态标识。如果检测到非法内存访问，如堆缓冲区溢出或栈缓冲区溢出，工具会立即终止程序执行并输出详细的错误报告，包括调用堆栈和内存状态信息。类似的检测工具还有MemorySanitizer，专门用于发现未初始化的内存读取；ThreadSanitizer则通过向量时钟算法检测多线程环境下的数据竞争问题。</p><p>动态插桩技术在提供强大检测能力的同时，也会在运行时暴露程序的内部信息。类似地，在软件开发过程中，数据类的自动字符串表示会完整暴露所有属性值。当数据类包含敏感信息时，这可能会带来安全风险。在实际开发中，对于包含密码、密钥或其他敏感数据的类，可以重写toString()方法来过滤敏感字段。当然，也可以借助工具来达到更高级别的保护，如使用Virbox Protector加固工具的字符串加密功能，它能够在运行时动态保护字符串内容，防止通过内存dump或反编译获取敏感信息，同时保持与Kotlin/JVM项目的良好兼容性。</p><p>现代Sanitizer工具已经形成完整的生态系统。UndefinedBehaviorSanitizer专门检测各类未定义行为，包括整数溢出、空指针解引用等；LeakSanitizer专注于内存泄漏检测；HWAddressSanitizer则利用硬件特性提升检测效率。这些工具通过编译器支持，在编译时自动插入检测代码，为软件安全提供了多层次保护。在实际漏洞挖掘中，研究人员通常会组合使用多个Sanitizer，以最大化漏洞检测的覆盖范围，同时通过调整编译参数来平衡检测精度与性能开销。</p><h3>动态污点分析</h3><p>动态污点分析通过标记不可信数据源，并在程序执行过程中跟踪数据的传播来发现安全问题。系统维护污点标签，在数据操作过程中传播这些标签。</p><p>当污点数据影响敏感操作时，如系统调用参数或跳转目标，分析器会触发警报。这种方法特别擅长发现注入类漏洞，能够准确识别从输入点到敏感操作的完整数据流路径。</p><h2>混合分析与高级技术</h2><p>混合分析通过系统化地结合静态和动态分析技术，构建出更强大的漏洞发现能力。在具体实施层面，这些技术形成了多层次、互补性的解决方案。</p><p>混合模糊测试代表了这种融合的典型范式。该技术首先使用静态分析定位程序中的复杂条件分支，特别是那些涉及复杂算术运算或嵌套判断的代码区域。接着，通过符号执行对目标分支的路径约束进行求解，生成能够深入程序核心逻辑的高价值测试种子。最后，将这些种子输入到基于覆盖率的模糊测试引擎中，利用其高效的变异和进化机制进行大规模测试。这种分工协作既克服了纯模糊测试在复杂条件前的盲目性，也避免了纯符号执行面临的路径爆炸问题。</p><p>在实际应用中，当面对一个包含校验和验证的网络协议时，混合模糊测试会先通过静态分析识别校验和检查例程，然后使用符号执行绕过检查机制，最终通过模糊测试深入协议处理逻辑。这种方法显著提升了测试的深度和效率。</p><p>Concolic（具体执行与符号执行结合）技术采用协同执行架构。系统同时维护具体状态和符号状态两个执行环境。具体执行引擎处理那些难以符号化的操作，如系统调用、加密函数或第三方库调用；符号执行引擎则专注于探索路径约束，生成新的输入来覆盖未探索的代码路径。两个引擎通过状态同步机制保持一致性，当具体执行遇到符号化分支时，会将控制权移交符号引擎进行约束求解。</p><p>这种协同机制在处理现实世界的复杂程序时表现出色。例如，在分析一个图像处理程序时，具体执行负责处理图像解码等复杂计算，符号执行则专注于探索程序对不同图像特征的响应路径。通过智能的状态切换策略，系统能够在保证分析深度的同时维持可接受的性能开销。</p><p>选择性符号化是另一种高级混合技术。该技术只对程序输入的关键部分进行符号化，而不是全量符号化。通过静态分析识别出与安全密切相关的数据流，系统可以精确控制符号化范围，在分析精度和性能开销之间取得最佳平衡。比如，在Web应用程序分析中，可以只对用户输入的特定字段进行符号化，而不是整个HTTP请求。</p><p>动态静态反馈循环建立了持续优化的分析机制。静态分析结果指导动态测试的重点方向，而动态测试的覆盖信息又反过来优化静态分析策略。这种闭环系统能够逐步深化对目标程序的理解，不断调整分析资源投向最可能包含漏洞的代码区域。</p><p>污点引导的符号执行展示了混合分析的另一维度。通过动态污点分析识别出从输入点到敏感操作的数据流，然后针对这些关键路径进行精确的符号执行。这种方法避免了在全程序范围内进行符号执行的开销，专注于那些最可能产生安全影响的数据传播路径。</p><h2>漏洞信息标准化与追踪</h2><p>现代漏洞管理建立在标准化信息框架之上，实现从漏洞披露到修复验证的全程自动化追踪。CVE、CWE、CVSS三大标准构成了这一体系的核心基础。CVE为每个漏洞提供唯一标识，如CVE-2021-44228对应Log4Shell漏洞；CWE描述漏洞类型，如CWE-78标识OS命令注入；CVSS则从基础指标、时空指标和环境指标三个维度量化漏洞严重程度。</p><p>实时CVE追踪通过多源数据聚合确保漏洞信息的及时性。安全团队通过订阅NVD官方数据库、厂商安全公告、GitHub安全通告等渠道，建立自动化的漏洞预警机制。当新的CVE记录发布时，系统会立即解析漏洞描述、受影响产品版本、修复建议等关键信息，并与现有资产库进行自动匹配。</p><p>OVAL语言作为机器可读的检查标准，将漏洞检测规则转化为可执行的定义文件。每个OVAL定义包含具体的检测逻辑：通过比对文件版本号（如检查OpenSSL版本是否低于1.1.1k）、验证文件哈希值（比对<a href="https://link.segmentfault.com/?enc=Fjtd0Sil9Qu%2BMcWPucwkEQ%3D%3D.4CCPpohPdRwBx5uia6kFMKWB9mStfqVoIwfCS8ImM6E%3D" rel="nofollow" target="_blank">libc.so</a>.6的SHA-256值）或检查注册表键值（Windows系统补丁状态）来判断漏洞存在性。这些检测规则基于已知的漏洞特征，适用于大规模环境中的快速筛查。</p><p>在实际部署中，OVAL定义文件通过SCAP协议分发到各目标系统，由合规性检查工具执行验证。例如，针对CVE-2021-3449漏洞的OVAL检查会验证OpenSSL版本是否在受影响范围内，并返回"true"或"false"的明确结果。这种标准化的验证方式确保了不同平台、不同工具检测结果的一致性。</p><p>漏洞信息标准化使得自动化运维成为可能。安全团队通过CVE追踪获取最新威胁情报，利用CVSS评分确定修复优先级，最后通过OVAL检查验证修复效果。整个流程形成了完整的闭环管理，显著提升了漏洞响应的效率和准确性。</p><h2>机器学习辅助分析</h2><p>机器学习技术通过从历史漏洞数据中学习模式，为传统的分析方法提供补充。代码被表示为中间表示、抽象语法树或控制流图等形式，然后使用神经网络等模型进行训练。</p><p>在二进制漏洞扫描的具体实践中，机器学习技术主要通过以下方式直接应用于漏洞检测流程：</p><p>在漏洞检测阶段，分析工具首先将二进制代码转换为中间表示，然后输入到预训练的深度学习模型中。模型通过分析代码序列模式，直接标记出可能存在漏洞的代码段。例如，在处理缓冲区操作时，模型会识别出可能引发溢出的危险代码模式，如缺乏边界检查的循环拷贝操作。</p><p>在静态分析优化环节，系统将传统静态分析工具产生的警告特征（包括代码上下文、数据流路径、函数调用关系）输入分类模型。模型基于历史漏洞数据训练得到的模式，对每个警告进行可信度评分，安全分析人员可优先审查高评分警告，大幅提升漏洞确认效率。</p><p>在动态测试过程中，机器学习指导测试用例的生成策略。系统实时监控测试覆盖率和程序状态，使用强化学习模型动态选择最可能触发新路径的变异操作。例如，当遇到复杂的校验和检查时，模型会优先选择算术变异策略而非简单的位翻转，从而提高测试效率。</p><p>对于漏洞风险评估，系统提取漏洞特征（如漏洞类型、受影响内存区域、函数调用栈深度等），通过回归模型预测其可利用性和影响程度，为漏洞修复提供优先级建议。</p><p>这些机器学习应用深度集成在漏洞扫描的各个阶段，与传统分析方法协同工作，形成了更加智能的漏洞检测体系。</p><h2>固件扫描</h2><p>固件扫描针对物联网设备（包括路由器、智能家居设备、工业控制系统等）中嵌入的底层软件进行安全分析。与传统软件扫描相比，固件扫描面临独特的挑战：首先需要处理多样化的CPU架构（如MIPS、ARM、RISC-V等），这要求分析工具具备跨平台解析能力；其次，固件格式的高度非标准化使得解包过程复杂化，固件镜像可能包含自定义的压缩格式、多种文件系统（如SquashFS、JFFS2）以及引导程序等混合内容。</p><p>完整的固件扫描始于固件获取阶段，分析人员从供应商官网、OTA更新包或通过物理接口（JTAG、UART）提取固件镜像。随后进入关键的解包环节，使用Binwalk、Firmware Analysis Toolkit等工具基于文件签名识别固件内部结构，递归提取出可分析的文件系统。这一步骤的完整性直接决定了后续分析的覆盖范围。</p><p>在成分分析阶段，系统通过多维度方法建立软件物料清单：字符串扫描检测硬编码的凭证和API密钥；依赖库识别通过比对函数签名和版本符号确定组件信息；对于基于Linux的固件，还通过分析软件包管理器数据库获取安装记录。这些信息为后续的漏洞扫描提供基础数据。</p><p>漏洞检测采用三重技术路线协同工作：基于软件成分分析的快速筛查通过比对CVE数据库（使用cve-bin-tool等工具）识别已知漏洞组件；静态二进制分析针对厂商自定义代码，使用支持跨架构的反汇编工具（如Ghidra）进行控制流分析和数据流分析，发现内存破坏、命令注入等漏洞模式；动态分析在QEMU模拟环境中执行固件，通过基于覆盖率的模糊测试（AFL++ QEMU模式）、内存检测（AddressSanitizer）和动态污点分析（Triton）验证漏洞的可利用性。</p><p>除了常规漏洞检测，固件扫描还需特别关注设备特有的安全风险：弱凭证检查发现默认密码和隐藏后门；网络服务分析识别不必要的服务暴露；权限配置验证检测不当的访问控制设置。这些检查结合供应链风险评估，共同构成完整的固件安全评估体系。</p><p>整个扫描流程最终通过模拟验证环节确认漏洞的可利用性和影响程度，为修复优先级提供依据。这种系统化的分析方法使得固件扫描成为物联网安全防御中不可或缺的关键环节。</p><h2>漏洞分类与描述标准</h2><p>在漏洞管理实践中，CWE、CVE和CVSS三大标准构成了完整的漏洞描述体系。CWE提供漏洞类型分类，将安全弱点系统化组织为层次结构。例如，CWE-787标识栈缓冲区溢出，CWE-416标识释放后使用漏洞。这种标准化分类使不同分析工具能够统一处理检测结果。</p><p>CVE系统为每个公开漏洞分配唯一标识符。当扫描工具识别出Log4j漏洞时，会将其关联到CVE-2021-44228。CVE条目包含受影响版本范围和修复建议，为漏洞修复提供准确依据。</p><p>CVSS评分系统通过量化方式评估漏洞严重程度。基础评分从攻击向量、复杂度和影响范围等角度评估，时序评分考虑漏洞修复状态，环境评分结合具体部署环境调整威胁等级。例如，同一个远程代码执行漏洞在DMZ区域评分9.8，在内网环境可能仅评分6.5。</p><p>在实际工作流程中，安全团队首先通过CWE理解漏洞机理，然后通过CVE确认具体漏洞实例，最后使用CVSS确定修复优先级。这种标准化流程确保漏洞从发现到修复的全程可追踪。</p><h2>总结</h2><p>二进制漏洞扫描技术已经发展成为一个多技术融合的完整体系。有效的漏洞扫描需要采用分层递进的策略：从静态分析的全面筛查，到动态分析的精确验证，再到混合分析的深度探索。每个技术方法都有其独特的价值和应用场景。</p><p>在实际应用中，需要根据目标程序的特性选择合适的工具和方法。静态分析适用于早期筛查和全面评估，动态分析擅长发现运行时特定的问题，混合分析则适用于复杂场景的深度测试。建立标准化的流程和持续监控机制是确保长期安全的关键。</p><p>随着技术的不断发展，二进制漏洞扫描正在向更智能、更自动化的方向演进。机器学习技术的引入、分析方法的优化、标准化进程的推进，都将为软件安全提供更强大的保障。在这个快速变化的威胁环境中，只有建立全面、深入的技术体系，才能有效应对日益复杂的安全挑战。</p>]]></description></item><item>    <title><![CDATA[24小时线上线下陪玩服务小程序：深夜匹配]]></title>    <link>https://segmentfault.com/a/1190000047432718</link>    <guid>https://segmentfault.com/a/1190000047432718</guid>    <pubDate>2025-11-27 17:23:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="697" referrerpolicy="no-referrer" src="/img/bVdcACU" alt="" title=""/></p><h3><strong>当游戏不止是游戏，而是随时可及的温暖陪伴</strong></h3><p>深夜，城市的喧嚣渐次退去，只剩下屏幕的微光和耳机里循环的背景音乐。你结束了一天的忙碌，终于有时间打开最爱的游戏，却发现自己独自一人身处召唤师峡谷、提瓦特大陆或某个未知的战场。那份渴望分享胜利喜悦或倾诉失利郁闷的心情，无处安放。</p><p>你是否也经历过这样的时刻？</p><p>“陪玩小程序”正是为此而生。更是一个 <strong>“24小时线上线下，开黑连麦随时相伴”</strong> 的温暖港湾。在这里，游戏超越了单纯的竞技，演变成一种深入人心的情感连接和实时在线的贴心陪伴。<br/><img width="723" height="697" referrerpolicy="no-referrer" src="/img/bVdcADg" alt="" title="" loading="lazy"/></p><h4><strong>一、 不止于“陪玩”，我们是全方位的“游戏伴侣”</strong></h4><p>传统的陪玩或许只局限于“带你赢”。但在代练小程序中重新定义了“陪伴”的意义：</p><ul><li><strong>技术导师型：</strong> 无论是卡在某个段位，还是想精通一个新英雄，我们的陪玩师都能化身耐心导师，在实战中传授技巧、分析局势，让你在欢声笑语中稳步变强。</li><li><strong>开心果型：</strong> 如果你追求的不是胜利，而是纯粹的快乐，我们有妙语连珠、擅长营造气氛的陪玩师。他们的任务就是让你忘记烦恼，每一局游戏都充满笑声。</li><li><strong>倾听陪伴型：</strong> 有时，你需要的只是一个可以安静听你说话，在你需要时给予回应的伙伴。我们的陪玩师善于倾听，可以是树洞，也可以是朋友，在你孤独时送上最及时的慰藉。</li><li><strong>开黑车队型：</strong> 我们提供完整的“车队”服务，为你凑齐可靠的队友。无论是征战五排，还是挑战高难度副本，你都能体验到团队协作、默契配合的极致乐趣。</li></ul><h4><a href="https://link.segmentfault.com/?enc=FxavoG0FWueKVnwLc4FZJA%3D%3D.ksWN2Cz7GvMHCxPeUuMqbU0%2FDQVPpssHeZikxg3nuMP4VTcqJCNkVWZRAHWeo4I1" rel="nofollow" target="_blank">【→前后端功能演示/开源源码体验←】</a></h4><p><img width="723" height="390" referrerpolicy="no-referrer" src="/img/bVdffF2" alt="" title="" loading="lazy"/></p><h4><strong>二、 24小时线上线下，但凡需求及时响应</strong></h4><p>孤独与渴望陪伴的时刻从不分昼夜。因此系统打造了真正无缝衔接的陪伴体验：</p><ul><li><strong>线上即时连麦：</strong> 无论清晨、午后还是深夜，只要你打开App，总能找到在线的陪玩师。一键下单，秒速连麦，你的专属陪伴即刻上线。无论是在峡谷中并肩作战，还是在某个开放世界里闲逛看风景，都有人在你身边。</li><li><strong>线下同城相伴：</strong> 游戏情谊同样可以延伸到现实。我们提供安全、可靠的线下陪玩服务。无论是相约网咖开启现实中的“开黑”之旅，还是一边喝着奶茶一边分享游戏心得，我们都致力于让虚拟世界里的默契，在现实中生根发芽。</li></ul><p><img width="723" height="732" referrerpolicy="no-referrer" src="/img/bVdnbyF" alt="" title="" loading="lazy"/></p><h4><strong>三、 线上线下双结合，打造沉浸式社交体验</strong></h4><p><strong>线上线下双结合，打造沉浸式社交体验</strong><br/>我们的陪玩系统不止于线上，更延伸至线下，打造"社交+服务+本地生活"的立体化生态。</p><p><strong>1.线上陪玩：游戏内外的全方位陪伴</strong></p><ul><li><strong>主流游戏全覆盖</strong>：《王者荣耀》《英雄联盟》《和平精英》《永劫无间》《三角洲行动》等热门游戏专区</li><li><strong>多种陪玩类型</strong>：技术指导、娱乐陪玩、语音聊天、游戏教学</li><li><strong>专业陪玩师</strong>：严格审核、技能认证、分级体系（普通、金牌、王牌）</li><li><strong>评价与标签系统</strong>：形成"技术好"、"声音甜"、"会聊天"等个性化标签，让你快速找到心仪的陪玩</li></ul><p><strong>2.线下陪伴：同城见面，体验更真实</strong></p><ul><li><strong>LBS定位功能</strong>：一键查找附近陪玩师，预约线下陪伴服务</li><li><strong>多元化线下场景</strong>：密室逃脱、剧本杀、漫展打卡、咖啡馆聊天、健身陪伴</li><li><strong>安全保障体系</strong>：行程分享、一键求助、紧急联系人，让你放心享受线下陪伴</li></ul><p><img width="723" height="697" referrerpolicy="no-referrer" src="/img/bVdeT7E" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[如何开始研发数字化转型？ 月下水光 ]]></title>    <link>https://segmentfault.com/a/1190000047432723</link>    <guid>https://segmentfault.com/a/1190000047432723</guid>    <pubDate>2025-11-27 17:22:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在全球制造业竞争日益激烈的背景下，企业的研发能力和协同效率成为影响产品上市周期、质量水平及市场响应速度的核心因素。这一时代命题的崛起，正是催生研发数字化转型浪潮的催化因素。对多数制造企业而言，数字化转型不仅仅是IT系统的升级，而是需要进行深层次全方位的模式再造。面对这一机遇与挑战并存的历史节点，广域铭岛顺势而为，凭借其自主研发的FastWorx设计研发协同平台，为行业提供了示范性的全新解决方案。<br/>研发数字化转型的本质，体现在技术集成和流程再造二者相辅相成的综合效果上。它既是一种基础设施升级，也是企业运作逻辑的根本重构。FastWorx平台以客户需求为中心，打通项目全链条，实现从设计构思到产品交付的一体化管理。其可配置BOM管理功能让产品方案与市场需求精准匹配，工艺过程的实时可视化协同机制打破了数据壁垒，创造结构化、标准化的知识管理体系。这些技术创新不仅改变了研发的流程方式，更提升了企业的决策精度和执行力水平。<br/>系统集成BOM、三维工艺引擎、多租户框架的集成功能，共同构筑了研发数字化的坚实基础。BOM数据管理的集中化和格式标准化，大幅提升了跨部门协作效率。三维模型的轻量化技术，让设计资源真正实现了跨地域、跨屏幕的直观调度。这些功能组件的有机整合，正是数据驱动型转型的具体表现。通过模块化架构设计和微服务技术实现，平台承载了多行业、多领域的发展需求，成为数字化工厂的中枢力量。<br/>AI技术就像一张无形的网，对研发活动进行了深度而智识的渗透。以Geega工艺专家数智引擎系统为例，其引入的五个AI功能模块化结构，分别针对工艺规划、工时测算、线平衡设计等环节进行降耗提效。自动校核、智能拼接、可扩展功能的有机组合，形成了前所未有的运行速度优势。这种智能化转型不仅节省了数倍的研发时间，更将每个流程节点提升到了新的运行维度，释放了工程师的创造力。<br/>在转型实践中，FastWorx平台实现了跨行业的显著价值回归。作为制造装备行业的标杆系统，它攻克了零部件高复用率和设计质量管理等多个关键痛点。某制造企业管理后，零部件复用率直接提升35%，BOM数据准确率大幅提高。这种超越预期的成果说明：研发数字化不仅能大幅改善现有效率，更能极具创造性地打开新的发展局面。<br/>广域铭岛将转型定义为一场全面的技术逻辑和流程逻辑的蜕变。与其说必具规模，不如论转型方法的三重境界：工具支撑、流程重构、理念颠覆。FastWorx不仅提供工具平台，更在方法论层面进行创新。平台的弹性架构和模块化设计释放了制造企业的新兴潜力，跨部门协同的算法化改造使研发力量形成了前所未有的发展引力。<br/>面向未来，研发数字化已经从可选设施演变为必由之路。广域铭岛以突破性创新构建的FastWorx体系，正代表转型方向的飞跃点。唯有把握数字化脉搏的企业，才能在智能化浪潮中强势崛起。随着技术持续演进，这一趋势的基本盘将愈发强大，为制造业贡献全新的动能增量。整个行业将完成从局部信息化到全面智能化的升级，而广域铭岛正为此描绘路线图和施工蓝图。</p>]]></description></item><item>    <title><![CDATA[怎么用动态代理IP有效避免封禁？多账号怎]]></title>    <link>https://segmentfault.com/a/1190000047432726</link>    <guid>https://segmentfault.com/a/1190000047432726</guid>    <pubDate>2025-11-27 17:21:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在网络活动中，无论是进行网络爬虫、社交媒体营销，还是多账号运营，使用动态代理 IP 都是避免被封禁以及更改账号地址的有效手段。然而，要想充分发挥动态代理 IP 的作用，还需掌握一些关键技巧。</p><p>动态代理 IP 避免封禁的有效方法</p><p>模拟真实用户行为</p><p>网络服务提供商通常会通过监测用户的行为模式来识别异常访问。如果你的请求过于频繁、有规律，就很容易被判定为机器操作而遭到封禁。使用动态代理 IP 时，要尽可能模拟真实用户的行为。例如，在进行网页访问时，设置合理的请求间隔时间，避免短时间内大量请求同一网站。同时，模拟不同的访问路径，就像真实用户在浏览网页时会随机点击不同的链接一样。</p><p><img width="640" height="480" referrerpolicy="no-referrer" src="/img/bVdnbz4" alt="" title=""/>   </p><p>选择优质的动态代理 IP 服务</p><p>市场上的代理 IP 服务参差不齐，选择一个优质的服务至关重要。优质的动态代理 IP 服务通常具有丰富的 IP 资源池，能够提供大量不同地区、不同运营商的 IP 地址。这样可以降低被封禁的风险，因为使用大量不同的 IP 地址进行访问，会让网站难以识别你的真实身份。此外，优质的代理服务还会提供稳定的连接速度和高可用性，确保你的网络活动能够顺利进行。</p><p>定期更换代理 IP</p><p>即使使用了动态代理 IP，也不能长时间固定使用同一个 IP 地址。定期更换代理 IP 可以有效避免被网站监测到并封禁。可以根据实际情况设置更换 IP 的时间间隔，例如每小时或每半小时更换一次。同时，要注意更换 IP 的方式，避免过于频繁的更换导致网站认为你的行为异常。</p><p>控制并发连接数</p><p>在使用动态代理 IP 时，要合理控制并发连接数。如果同时使用过多的连接，会给服务器带来较大的压力，容易被网站识别为异常访问。根据网站的负载能力和自身需求，合理设置并发连接数，确保每个连接都能稳定、正常地工作。</p><p>多账号使用代理 IP 更改地址的操作方法</p><p>选择合适的代理 IP 类型</p><p>根据不同的需求，选择合适的代理 IP 类型。常见的代理 IP 类型有 HTTP 代理、HTTPS 代理和 SOCKS 代理。如果你的网络活动主要是进行网页浏览和数据传输，HTTP 代理和 HTTPS 代理通常就可以满足需求；如果需要进行更复杂的网络操作，如游戏、视频会议等，SOCKS 代理可能是更好的选择。</p><p>配置代理服务器</p><p>在使用代理 IP 之前，需要将代理服务器的配置信息添加到相应的应用程序或设备中。以浏览器为例，在浏览器的设置中找到“代理服务器”选项，输入代理服务器的 IP 地址和端口号。不同的浏览器设置方法可能略有不同，但大致步骤相似。对于一些应用程序，可能需要在其设置中专门配置代理服务器信息。</p><p>批量操作多账号</p><p>如果你有多账号需要使用代理 IP 更改地址，可以采用批量操作的方式提高效率。一些代理 IP 服务提供商提供了 API 接口，可以通过编写脚本的方式批量获取代理 IP 地址，并将其配置到多个账号中。例如，在进行社交媒体多账号运营时，可以使用脚本自动为每个账号分配不同的代理 IP 地址，实现批量更改地址的目的。</p><p>验证代理 IP 地址</p><p>在使用代理 IP 更改地址后，需要验证代理 IP 地址是否生效。可以通过访问一些 IP 查询网站，查看显示的 IP 地址是否为你所使用的代理 IP 地址。如果显示的 IP 地址与你配置的不一致，可能是代理服务器配置有误或代理 IP 地址已失效，需要及时进行调整。</p><p>总结</p><p>动态代理 IP 是避免网络封禁和更改多账号地址的有力工具。通过模拟真实用户行为、选择优质的代理服务、定期更换 IP 地址、控制并发连接数等方法，可以有效利用动态代理 IP 避免被封禁。同时，选择合适的代理 IP 类型、正确配置代理服务器、进行批量操作和验证 IP 地址，能够帮助你轻松实现多账号的地址更改。在使用动态代理 IP 时，要不断学习和实践，根据实际情况灵活调整策略，以达到最佳的使用效果。</p>]]></description></item><item>    <title><![CDATA[iOS 18/26 照片管理器替代方案：]]></title>    <link>https://segmentfault.com/a/1190000047432729</link>    <guid>https://segmentfault.com/a/1190000047432729</guid>    <pubDate>2025-11-27 17:20:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>iOS 18/26 带来了一套全新的照片管理工具，让用户能够以更直观的方式编辑和整理照片。然而，内置的“照片”应用并不能满足所有人的需求。一些用户觉得它的功能有限，或者无法完全契合他们的工作流程。因此，许多人都在寻找一款可靠的iOS 18/26 照片管理应用替代方案。在本文中，我们将带您了解新版“照片”应用的主要更新，分享用户的评价，并介绍几款优秀的替代方案，帮助您轻松管理 iPhone 照片。</p><p>第一部分： iOS 18/26 照片应用的主要变化</p><p>iOS 18/26 中的“照片”应用迎来了史上最大幅度的重新设计。让我们深入了解一下全新的统一界面、标签栏的移除以及简洁的单滚动屏幕的引入。</p><ol><li>一致的界面设计</li></ol><p>苹果公司对“照片”应用进行了全面改版，采用了更简洁流畅的设计。底部传统的标签栏已被连续无缝的滚动体验所取代，让浏览照片变得更加轻松直观。</p><ol start="2"><li>单滚动导航</li></ol><p>现在，您无需在不同版块之间切换，即可在一个连续的滚动页面浏览所有照片。这样，您可以更快更方便地找到所需的图片，而无需浏览多个菜单。</p><ol start="3"><li>照片网格和有序收藏</li></ol><pre><code>快速访问网格：在顶部，您会找到一个网格，显示您最近的照片，以便快速访问。
有序的收藏集：在下方，您的照片已整齐地分类到不同的收藏集中，方便您查找旧照片，而无需无休止地滚动。

</code></pre><p>第二部分： iOS 18/26 照片管理中的精彩新功能</p><p>iOS 18/26 照片应用新增了许多功能，旨在让照片管理更加高效便捷。让我们一起来探索这些令人兴奋的更新吧！</p><p>更统一的布局</p><p>为了方便浏览，所有内容不再像以前那样分别设置“为你推荐”和“相册”等标签页，而是集中在一个位置。主照片网格一次显示约 30 张图片，并支持滑动缩放。虽然“年”和“月”视图仍然保留，但“日”视图已被“最近照片集锦”取代，用于展示您最近的照片。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432731" alt="图片" title="图片"/><br/>​</p><p>筛选和排序</p><p>在图库中向下滑动即可显示用于筛选和整理照片的新选项。您可以按“最近添加”或“拍摄日期”排序，并应用筛选器仅显示“收藏”、“已编辑照片”、“视频”或“屏幕截图”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432732" alt="图片" title="图片" loading="lazy"/></p><p>更智能的照片收藏</p><p>iOS 18/26 引入了智能相簿功能，可根据主题、地点或媒体类型等各种条件自动对照片进行分组。一些主要相簿包括：</p><pre><code>最近几天：显示您最近的照片，按日期排序。
相册：包含您创建的所有相册，包括共享相册。
人物与宠物：通过机器学习识别的人物或宠物专辑。
回忆：根据您的照片自动生成的幻灯片。
旅行：特定地点的照片，按年份整理。

</code></pre><p>您可以自定义这些收藏集的顺序，或删除任何不使用的收藏集。“置顶收藏集”功能还可以让您快速访问您最喜欢的专辑或类别。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432733" alt="图片" title="图片" loading="lazy"/></p><p>增强型照片编辑工具</p><p>iOS 18/26 照片编辑套件引入了 AI 驱动的增强功能，可自动调整亮度、对比度和色彩平衡等关键元素。此外，AI 驱动的裁剪和矫正等工具，可帮助用户轻松打造完美照片。</p><p>记忆制造者</p><p>“记忆制作器”是一项新功能，可让您用照片和视频创建个性化的记忆影片。只需输入“探索爱尔兰”或“美味佳肴”之类的短语，应用程序就会自动生成一个包含开头、中间和结尾的迷你影片。您可以添加音乐、自定义时间轴，并将您的作品分享到社交媒体。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432734" alt="图片" title="图片" loading="lazy"/><br/>​</p><p>清理</p><p>即将推出的“清理”功能，只需轻轻一点，即可从照片中移除不需要的物体。该功能由人工智能驱动，能够消除干扰元素，提升照片的整体美感。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432735" alt="图片" title="图片" loading="lazy"/><br/>​</p><p>图片游乐场集成</p><p>Image Playground 是即将推出的一项功能，它将与 Photos 应用集成，使用户能够根据文本提示生成图像，包括朋友和家人的照片。</p><p>第三部分：用户对iOS 18/26 照片管理的反馈</p><p>iOS 18/26 发布后，许多用户对其照片管理功能表达了不同的看法。</p><p>用户正面反馈：</p><pre><code>许多用户称赞iOS 18/26 照片应用的简洁现代的重新设计，尤其是人工智能驱动的照片编辑功能，使编辑更加直接高效。
统一的界面和单滚动导航被认为是重大升级，简化了管理大型照片库的过程。

</code></pre><p>负面用户反馈：</p><pre><code>有些用户怀念经典的标签栏，它可以让用户轻松地在相册和共享照片之间切换。
虽然单卷轴设计很有创新性，但一开始可能会感觉不太直观，特别是对于习惯了以前布局的人来说。

</code></pre><p>第四部分： iOS 18/26 照片应用的最佳替代方案</p><p>鉴于iOS 18/26 照片应用褒贬不一，许多用户正在寻找其他 iPhone 照片管理工具。Coolmuster iOS Coolmuster就是一个强烈推荐的选择。它能让您轻松地将照片传输、备份和整理到电脑上。您可以快速地将照片从 iPhone 传输到Mac或 PC，而不会损失原始画质。这对于拥有大量照片或需要可靠备份方案的用户来说尤其有用。</p><p>iOS助手亮点：</p><pre><code>只需单击一下，即可轻松将 iPhone 中的照片传输到 PC或Mac 。
只需单击一下，即可从 iPhone 中批量删除不需要的照片。
预览并选择iOS文件后进行传输。
照片传输到 PC 或Mac时，仍能保持完整分辨率，不会造成质量损失。
直接通过 PC 或Mac编辑、添加或删除存储在iOS设备上的数据。
一键备份和恢复您的 iPhone / iPad / iPod。
支持联系人、消息、音乐、视频、照片、笔记、日历、应用程序等。
兼容多种iOS设备，包括 iPhone 17/16/15/14/13/12/11/X/8/7/6 等（支持iOS 18/26）。

</code></pre><p>以下是如何使用iOS助理管理 iPhone 照片的方法：</p><p>01下载软件后，请在电脑上启动它。然后，连接您的 iPhone 并信任该设备。连接成功后，软件主界面将会出现。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432736" alt="图片" title="图片" loading="lazy"/></p><p>02点击左侧面板中的“照片”，即可查看所有 iPhone 照片。之后，您可以轻松地在电脑上整理 iPhone 照片。</p><p>要将 iPhone 照片传输到您的电脑：选择要传输的照片，然后单击“导出”按钮开始传输过程。</p><p>要从电脑中删除 iPhone 照片：选择要删除的照片，然后点击“删除”按钮将其从 iPhone 中删除。</p><p>结尾的话语</p><p>iOS 18/26 的照片管理功能确实有所改进，但仍然无法满足所有用户的需求。如果您正在寻找更灵活、更全面的照片管理功能， Coolmuster iOS Assistant是iOS 18/26 照片管理工具的最佳替代方案。它不仅能帮助您更有效地管理照片，还提供便捷的备份和传输功能，让您的照片管理更加灵活高效。<br/>​</p>]]></description></item><item>    <title><![CDATA[全新Swift从入门到进阶实战探探iOS]]></title>    <link>https://segmentfault.com/a/1190000047432744</link>    <guid>https://segmentfault.com/a/1190000047432744</guid>    <pubDate>2025-11-27 17:19:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在社交应用蓬勃发展的今天，👇🏻ke🍊：xingkeit点top/9447/开发一款类似探探的滑动匹配型APP成为许多开发者的入门选择。Swift作为苹果官方推荐的现代编程语言，以其简洁的语法、强大的性能和丰富的生态，成为iOS开发的首选。本文将从零基础出发，系统讲解如何使用Swift开发一款仿探探的社交应用，涵盖从环境搭建到功能实现的全流程，帮助开发者快速掌握iOS开发的核心技能。</p><p>一、开发前的准备：环境搭建与工具选择</p><ol><li>开发环境配置<br/>Xcode安装：作为苹果官方集成开发环境（IDE），Xcode提供了从界面设计到代码编辑、调试、发布的全流程支持。开发者需从Mac App Store下载最新版本（建议Xcode 15+），并确保系统版本为macOS Ventura或更高。<br/>模拟器与真机调试：Xcode内置iOS模拟器支持多设备模拟（如iPhone 15 Pro、iPad Pro等），但真机调试能更真实反映应用性能。开发者需注册苹果开发者账号（免费版即可），将设备添加至开发者账号后即可进行真机测试。<br/>Swift语言基础：Swift采用现代编程范式，语法简洁易读。建议初学者通过苹果官方《Swift编程语言》文档或互动式学习平台（如Swift Playgrounds）掌握变量、函数、类、结构体等基础概念，为后续开发打下基础。</li><li>项目架构设计<br/>MVVM架构：相比传统的MVC模式，MVVM（Model-View-ViewModel）通过数据绑定实现视图与逻辑的解耦，提升代码可维护性。在仿探探应用中，可将用户数据（Model）、界面展示（View）和滑动逻辑（ViewModel）分离，便于团队协作与功能扩展。<br/>模块化设计：将应用拆分为用户模块（用户信息展示、编辑）、匹配模块（滑动卡片、匹配逻辑）、消息模块（聊天界面、通知推送）等核心模块，每个模块独立开发、测试，降低系统耦合度。<br/>第三方服务集成：探探类应用需依赖后端服务（如用户数据存储、匹配算法）、推送服务（如APNs）、图片存储（如Cloudinary）等。初学者可先使用模拟数据或本地存储，后续逐步接入真实服务。<br/>二、核心功能实现：从界面到交互的全流程解析</li><li>用户注册与登录<br/>界面设计：使用Xcode的Interface Builder（IB）或SwiftUI（苹果推出的声明式UI框架）设计注册/登录界面，包含手机号输入、验证码发送、密码设置等字段。SwiftUI的TextField、Button组件可快速构建界面，结合@State实现数据绑定。<br/>数据验证：在用户提交信息前，需验证手机号格式、密码强度等。可通过正则表达式或第三方库（如Validator）实现，避免无效请求发送至后端。<br/>第三方登录：集成苹果、微信、QQ等第三方登录方式，提升用户体验。需调用各平台SDK，处理授权回调，获取用户基本信息（如昵称、头像）并存储至本地。</li><li>滑动卡片匹配机制<br/>卡片布局：使用UICollectionView或SwiftUI的LazyVGrid实现卡片堆叠效果，通过自定义布局（如UICollectionViewFlowLayout子类）控制卡片间距、缩放比例，模拟探探的滑动交互。<br/>手势识别：为卡片添加UIPanGestureRecognizer手势识别器，监听用户滑动方向（左滑不喜欢、右滑喜欢）与速度，结合动画效果（如旋转、透明度变化）增强交互体验。<br/>匹配逻辑：当用户右滑喜欢某用户时，需检查对方是否也喜欢自己。若匹配成功，触发动画提示（如“匹配成功”弹窗），并跳转至聊天界面。可通过本地数据模拟匹配过程，后续接入后端服务实现真实匹配。</li><li>实时聊天功能<br/>消息界面：使用UITableView或SwiftUI的List展示消息列表，每条消息包含发送者头像、昵称、内容、时间等信息。通过自定义单元格（UITableViewCell或List的rowContent）实现不同样式（如文本、图片、语音）。<br/>消息发送与接收：模拟消息发送时，将消息添加至本地数据源并刷新界面；接收消息时，可通过定时器模拟后端推送，或接入WebSocket实现实时通信。Swift的NotificationCenter可用于组件间通信，更新消息列表。<br/>多媒体支持：扩展消息类型，支持图片、语音、视频等多媒体内容。可通过UIImagePickerController选择图片，或录制语音后转换为音频文件发送。需处理文件压缩、上传等逻辑，确保消息发送效率。<br/>三、性能优化与细节打磨：提升用户体验的关键点</li><li>界面流畅度优化<br/>异步加载：用户头像、图片等资源需异步加载，避免阻塞主线程。可使用URLSession下载图片，结合UIImageView的sd_setImage方法（第三方库SDWebImage）实现缓存与占位图显示。<br/>预加载策略：滑动卡片时，提前加载下一张卡片的数据与图片，减少用户等待时间。可通过UICollectionView的prefetchDataSource协议或SwiftUI的onAppear修饰符实现。<br/>动画性能：复杂动画（如卡片滑动、匹配成功弹窗）需使用Core Animation或SwiftUI的animation修饰符优化，避免卡顿。建议使用CADisplayLink实现帧率监控，确保动画流畅度。</li><li>数据存储与管理<br/>本地存储：使用UserDefaults存储用户偏好设置（如是否开启通知），Core Data或Realm存储用户信息、聊天记录等结构化数据。Swift的Codable协议可简化数据序列化/反序列化过程。<br/>数据同步：当应用切换至后台或网络恢复时，需将本地数据同步至后端服务。可通过URLSession的backgroundSessionConfiguration实现后台上传，或使用第三方库（如Alamofire）简化网络请求。<br/>数据安全：敏感信息（如用户密码、聊天记录）需加密存储。可使用苹果的CryptoKit框架实现AES加密，或接入第三方安全服务（如HSM硬件安全模块）。</li><li>适配与国际化<br/>多设备适配：通过Auto Layout（IB）或SwiftUI的布局系统（如GeometryReader）适配不同屏幕尺寸（iPhone SE至iPad Pro），确保界面元素比例协调。需特别关注卡片滑动、聊天输入框等核心功能的适配效果。<br/>国际化支持：若计划面向多语言用户，需将界面文本提取至Localizable.strings文件，支持英语、中文等语言切换。Swift的Localization框架可简化多语言管理，结合NSLocalizedString宏实现文本动态切换。<br/>四、进阶方向：从仿制到创新的探索</li><li>技术升级路径<br/>SwiftUI深度使用：SwiftUI是苹果未来主推的UI框架，其声明式语法与跨平台特性（支持macOS、watchOS）能显著提升开发效率。建议开发者逐步将UI从UIKit迁移至SwiftUI，掌握@State、@Binding、@EnvironmentObject等核心概念。<br/>Combine框架：Combine是苹果推出的响应式编程框架，可替代RxSwift等第三方库，实现数据流的统一管理。在仿探探应用中，可用于处理用户滑动事件、消息推送等异步逻辑。<br/>机器学习集成：通过Core ML框架接入苹果预训练模型（如图像分类、自然语言处理），实现智能匹配（如基于用户兴趣的推荐）、消息审核（如敏感词过滤）等功能，提升应用智能化水平。</li><li>业务创新方向<br/>社交玩法扩展：在滑动匹配基础上，增加“超级喜欢”“限时匹配”等付费功能，或引入群组聊天、动态发布等社交元素，提升用户粘性。<br/>AR/VR融合：利用ARKit实现虚拟形象（Avatar）交互，或通过VR技术打造沉浸式聊天场景，为用户提供差异化体验。<br/>区块链应用：探索区块链技术在社交领域的应用，如用户身份去中心化存储、数字资产交易等，打造去中心化社交平台。<br/>结语<br/>从零基础到开发一款仿探探的iOS应用，需经历环境搭建、功能实现、性能优化、创新扩展等多个阶段。Swift的简洁语法与苹果生态的强大支持，能显著降低开发门槛，但真正打造一款优秀的社交应用，还需深入理解用户需求、持续优化体验，并在技术选型与业务创新上不断探索。希望本文能为初学者提供清晰的开发路径，助力其在iOS开发领域快速成长。</li></ol>]]></description></item><item>    <title><![CDATA[智能工单系统哪个好？制造业/IT/物流场]]></title>    <link>https://segmentfault.com/a/1190000047432748</link>    <guid>https://segmentfault.com/a/1190000047432748</guid>    <pubDate>2025-11-27 17:19:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>工单一乱，全局皆慢。传统“纸+微信”派单，信息断层、责任扯皮、数据缺失，把制造业的产线、物业的维修、IT的客服统统拖进低效泥潭。智能工单管理系统用AI自动派单、实时跟踪、数据仪表盘，三步把平均处理时长砍一半。本文带你拆解核心功能与实战场景，并重点体验Zoho Desk：内置Zia AI预测SLA、1秒分配技术员、手机端扫码即更新状态，让工单从“人找事”变“事找人”，真正驱动业务飞轮。<br/><img width="431" height="287" referrerpolicy="no-referrer" src="/img/bVdnbAt" alt="" title=""/><br/>一、智能工单管理系统的核心功能</p><ol><li>高效的任务分配与跟踪<br/>智能工单管理系统的首要功能便是高效的任务分配与跟踪。系统能够根据员工的技能、工作量和任务的紧急程度自动分配任务，确保分配的公平性和合理性。</li></ol><p>此外，系统可以实时跟踪每一个工单的状态，包括被指派、进行中、已完成等。管理者能够通过系统清晰地了解每个任务的进展，及时调整策略。</p><p>Zoho Desk 亮点：提供了智能任务分配功能，利用 AI 技术（如 Zia AI）分析任务优先级和员工的工作负载，实现精准分配。同时，Zoho Desk 的实时工单跟踪功能，帮助管理者快速掌握任务动态，提升团队协作效率。</p><ol start="2"><li>智能化的数据分析与报告<br/>智能工单管理系统不仅在任务管理方面表现出色，在数据分析能力上同样不容忽视。系统会自动收集工单执行过程中的所有数据，如处理时间、资源消耗、完成质量等，并生成详细的分析报告。</li></ol><p>这些报告能帮助企业识别流程中的瓶颈与低效环节，为未来的决策提供重要参考依据。借助大数据分析与机器学习技术，企业能够优化资源配置、改善服务质量，提高客户满意度。</p><p>Zoho Desk 亮点：内置强大的数据分析工具，支持生成自定义报告和实时仪表盘，帮助企业深入了解工单处理效率、客户满意度以及团队绩效。通过这些数据洞察，企业可以持续优化流程，推动业务增长。</p><ol start="3"><li>提高协作与沟通效率<br/>企业内部协作效率低下会直接影响整体运营效率。智能工单管理系统提供了一个高度集成的协作与沟通平台，可以实时更新工单状态，并允许相关人员在线沟通。</li></ol><p>这种实时的信息共享，使得部门间协作更加顺畅，无需频繁召开会议或通过邮件更新信息。员工之间的即时沟通还能有效减少误解与延误问题。</p><p>Zoho Desk 亮点：支持多渠道沟通，包括电子邮件、实时聊天、电话和社交媒体，确保客户和团队之间的信息流畅无阻。此外，Zoho Desk 提供内部协作工具，团队成员可以直接在工单中添加评论或共享信息，进一步提升沟通效率。</p><ol start="4"><li>强大的自定义与可扩展性<br/>每个企业的管理需求各不相同，智能工单管理系统需要具备高度的灵活性和可扩展性。系统可以根据企业的具体业务流程进行定制，例如增加个性化的字段、调整界面布局等。</li></ol><p>同时，系统还能与企业现有的信息系统（如 ERP、CRM）无缝集成，实现数据的统一与共享，避免信息孤岛现象的发生。</p><p>Zoho Desk 亮点：提供了高度自定义的功能，支持定制工单字段、自动化规则和工作流。此外，Zoho Desk 可与 Zoho CRM、Zoho Projects 等其他 Zoho 应用无缝集成，同时支持第三方工具（如 Slack 和 Jira）的对接，满足企业多样化的需求。</p><p>二、智能工单管理系统的应用场景</p><ol><li>制造业中的应用<br/>在制造业中，设备维护、生产排程和质量检验等环节需要精细化管理。智能工单管理系统能够帮助工厂实现从工单派发到任务完成的全过程信息化管理。通过实时数据反馈，工厂可以及时调整生产计划，优化资源配置，提高生产效率。</li></ol><p>Zoho Desk 应用：支持设备维护和生产任务管理功能，帮助制造企业实时监控任务进展，并通过自动化工单分配优化生产流程。</p><ol start="2"><li>服务行业中的应用<br/>在服务行业中，高效的工单管理是提升客户满意度的关键，例如物业管理、维修服务和客户支持等领域。智能工单管理系统能够帮助企业快速响应客户需求，提升服务效率和客户体验。</li></ol><p>Zoho Desk 应用：提供移动端支持，服务人员可以通过手机实时获取工单信息并完成任务。同时，Zoho Desk 的客户满意度评分功能，帮助企业监控服务质量并持续改进。</p><ol start="3"><li>IT行业中的应用<br/>在 IT 行业中，智能工单管理系统广泛应用于项目管理和技术支持。系统可以帮助项目经理高效分配任务，跟踪项目进度，并及时识别问题。在技术支持领域，系统能够快速记录客户反馈，并分配给合适的技术人员，提升问题处理效率。</li></ol><p>Zoho Desk 应用：为 IT 企业提供专属的技术支持解决方案，支持 SLA（服务级别协议）管理和问题优先级排序，确保客户问题能够快速解决。</p><ol start="4"><li>物流行业中的应用<br/>物流行业的核心在于高效的配送与信息流转。智能工单管理系统能够帮助物流企业实现运输、仓储和配送环节的全面管理。通过智能调度和路线优化，企业可以降低物流成本并提高服务效率。</li></ol><p>Zoho Desk 应用：的智能调度功能，结合实时数据和地理位置服务，帮助物流企业优化配送路线并高效完成任务。</p><p>三、智能工单管理系统的未来发展<br/>智能工单管理系统作为企业智能化管理的重要工具，凭借其强大的功能与广泛的应用场景，已经成为现代企业提升效率、降低成本的重要选择。</p><p>未来，智能工单管理系统将进一步融入人工智能和物联网技术，实现更高级别的自动化与智能化。例如，Zoho Desk 正在不断引入 AI 技术（如 Zia AI），通过预测性分析、自动回复和智能建议功能，为企业提供更高效的工单管理解决方案。</p><p>智能工单管理系统通过优化任务分配、提升协作效率和提供深度数据分析，正在成为企业数字化转型的重要驱动力。无论是制造业、服务业还是 IT 和物流行业，智能工单管理系统都能帮助企业提升运营效率和客户满意度。</p><p>工单的终点不是“关闭”，而是“再优化”。Zoho Desk把每一次处理时长、客户评分、故障类型沉淀为可视化报告，Zia AI自动提示下次可能出现的瓶颈，让你的流程越跑越快。现在就免费试用Zoho Desk，30分钟搭建专属工单流——从派单到结案，全程零代码，抢先体验下一代智能工单管理系统的速度！</p>]]></description></item><item>    <title><![CDATA[Windows Server 2025 ]]></title>    <link>https://segmentfault.com/a/1190000047432752</link>    <guid>https://segmentfault.com/a/1190000047432752</guid>    <pubDate>2025-11-27 17:18:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Windows Server 2025 中文版、英文版下载 (2025 年 11 月更新)</p><p>Windows Server 2025 LTSC x64 (updated Nov 2025)</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=R0ZoX1t2v1Yus%2FOFfxuMOg%3D%3D.3XvYsCFiWCn2NgXzkRSFPDH2QXJZnQLANWm4p3%2FNyXn7ipGPwb3aGHLTOQQlr8gN" rel="nofollow" target="_blank">https://sysin.org/blog/windows-server-2025/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=wtlO3J3wGDVETYRqD3DqZQ%3D%3D.ICnNUojVef8kWIx%2B3mhu0ENxbJ74Qd%2BNn35Nd4BtmR4%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>Microsoft Windows Server 2025 让你为将来做好准备，同时提供目前所需的安全性、性能和灵活性。通过更轻松的网络连接、更快的存储和满足你需求的混合云功能提高工作效率。凭借前瞻性的安全性和 AI 就绪型计算，领先于未来的发展。</p><p>一些关键改进包括：</p><ul><li>混合：跨混合、云和边缘快速调整。更轻松地连接到 Azure Arc 以连接本地服务器和基于云的服务器。将 Azure 功能融入到本地服务器。</li><li>安全性：可阻止网络攻击的硬件和软件级安全性；可改进安全性和可伸缩性的下一代 Active Directory。启用定制的安全基线，并从一开始就配置偏移保护。</li><li>面向未来的新式平台：Windows Server 2025 现在可以更轻松地升级和缩放，同时具有前所未有的应用兼容性。Windows Server 2025 桌面提供一致的客户端和服务器 UI 体验 (sysin)，以及 WiFi 和蓝牙等便利功能。</li><li>性能：更快、更轻松的网络和存储；可减少故障时间的实时热修补操作；可在边缘进行推理的 GPU 分区。在基于闪存的存储方面做出了改进，让 Windows Server 成为更好的 SQL Server 平台。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044713008" alt="Unix 风格的任务栏和开始菜单" title="Unix 风格的任务栏和开始菜单"/><br/><em>配图：Unix 风格的任务栏和开始菜单</em></p><p>2024 年 11 月 3 日，微软宣布 Windows Server 2025 从 Build 26100.1742 开始正式发布  (generally available)。这是微软 Windows 服务器操作系统的最新版本，也是长期服务渠道 (LTSC) 版本。  因此，Windows Server 2025 的主流支持（Mainstream support）将持续近 10 年，直至 2029 年 10 月 9 日。扩展支持（Extended support）将持续到 2034 年 10 月 10 日。</p><p><a href="https://link.segmentfault.com/?enc=WO%2FHg58jioC8muIeXd32pA%3D%3D.NP50AK3akOjj9VQC4t9UWsk0s98XhAFVBh6wzPPRvLkKwppCSxaYxPFC6iu8ot9kzStMX4PmAh%2FR6P6VwDrGRSj2EIrwG0yTUe1f8PKCZ%2Bf9KzyfImvUY0fPZiAQZDpq" rel="nofollow" target="_blank">了解 Windows Server 2025 中的新增功能</a>。</p><table><thead><tr><th>Windows Server version</th><th>Servicing option</th><th>Editions</th><th>Availability date</th><th>Latest build</th><th>Mainstream support end date</th><th>Extended support end date</th></tr></thead><tbody><tr><td>Windows Server 2025</td><td>Long-Term Servicing Channel (LTSC)</td><td>Datacenter, Standard</td><td>2024-11-01</td><td>26100.1742</td><td>2029-10-09</td><td>2034-10-10</td></tr><tr><td>Windows Server 2022</td><td>Long-Term Servicing Channel (LTSC)</td><td>Datacenter, Standard</td><td>2021-08-18</td><td>20348.2764</td><td>2026-10-13</td><td>2031-10-14</td></tr><tr><td>Windows Server 2019 (version 1809)</td><td>Long-Term Servicing Channel (LTSC)</td><td>Datacenter, Standard</td><td>2018-11-13</td><td>17763.6414</td><td>2024-01-09</td><td>2029-01-09</td></tr><tr><td>Windows Server 2016 (version 1607)</td><td>Long-Term Servicing Branch (LTSB)</td><td>Datacenter, Essentials, Standard</td><td>2016-08-02</td><td>14393.7428</td><td>2022-01-11</td><td>2027-01-12</td></tr></tbody></table><hr/><p>我们知道 <a href="https://link.segmentfault.com/?enc=VZItDIqCoVKLYMJAjjEtcA%3D%3D.oZan3Ge8AYtsi5MvVfp2GgaXHudDjz46P9ahKgtULO5VgunkPmrkDBIl%2F0vLV42l" rel="nofollow" target="_blank">Windows Server 2022</a> 仍然属于 <a href="https://link.segmentfault.com/?enc=m2bezrBjRCMg2d15YdBWzw%3D%3D.VNNgM3gqRxe4%2Bxgg2lIgOzq48i%2FZLJ%2FogJ5tVUTMGWEmmyIduCzV0o635jZuWQlj" rel="nofollow" target="_blank">Windows 10</a> Server 的范畴。现在，下一代基于 <a href="https://link.segmentfault.com/?enc=CYRraMup9IGt33hr5qnQBw%3D%3D.TXjxJYESrSuIUILN8dQSHNQDlQG47ilVeelYrkCPcdvpXPAb1l9zDqry272raB1z" rel="nofollow" target="_blank">Windows 11</a> 的 Windows Server 已经可以公开下载，根据 A3 的产品历史发行规律，基本上就是 Windows Server 2025（现已确定）。</p><p><strong>直观体验</strong>：</p><ul><li>启动 Logo 和系统 UI 都已经使用了 Windows 11 风格</li><li>早期产品名称显示为 Windows Server 2022，显然是正式名称尚未宣布（现在已经确定为 2025）</li><li>控制面板（盖茨风格）和设置（麦德龙风格）的混乱仍然传承 Windows 11，包括其 “库克风格” 三合一</li><li>除了界面风格，新增功能未知，发行说明和发行日期也未知（现已发布）</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044713009" alt="麦德龙风格的设置与盖茨风格经典的控制面板并存" title="麦德龙风格的设置与盖茨风格经典的控制面板并存" loading="lazy"/><br/><em>配图：麦德龙风格的设置与盖茨风格经典的控制面板并存</em></p><p><strong>下载地址</strong>：</p><p><strong>Windows Server 2025 LTSC 简体中文版、繁体中文版、英文版 (updated Nov 2025)</strong>：</p><ul><li><p>VSS Version 请访问：<a href="https://link.segmentfault.com/?enc=knWgZC4%2BZ5nJD3fHifPbpA%3D%3D.Yyy%2B1Ed4leEchi%2Bqo0XYe20v3e2faSiiYB9LQM5bO8yxiy%2FhzLoc5%2F0V%2Fjp2PO%2BY" rel="nofollow" target="_blank">https://sysin.org/blog/windows-server-2025/</a></p><ul><li>en-us_windows_server_2025_updated_oct_2025_x64_dvd_6c0c5aa8.iso</li><li>zh-cn_windows_server_2025_updated_oct_2025_x64_dvd_6c0c5aa8.iso</li><li>zh-tw_windows_server_2025_updated_oct_2025_x64_dvd_6c0c5aa8.iso</li></ul></li></ul><hr/><p>虚机模板下载：</p><ul><li><a href="https://link.segmentfault.com/?enc=Sp6kHbJ2nU70tP6VvCueYQ%3D%3D.w3089RGgoTWgmfZ%2B6KaeNGpCIuf3daZfeecrnRf%2FnB8kCWiCahIVCVCDDpzK7LiX" rel="nofollow" target="_blank">Windows Server 2025 OVF (2025 年 10 月更新) - VMware 虚拟机模板</a></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=KNUA%2FUTWvbktd9IVBa%2FhPA%3D%3D.oAr9bukQcNLl6HYIg7WYa0E6Y412aN%2FKmgGO%2FWgIIDc%3D" rel="nofollow" target="_blank">Windows 下载汇总</a></p>]]></description></item><item>    <title><![CDATA[前端开发，为什么容易被边缘化？ 悲伤的煎]]></title>    <link>https://segmentfault.com/a/1190000047432754</link>    <guid>https://segmentfault.com/a/1190000047432754</guid>    <pubDate>2025-11-27 17:17:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>我们前端，可能是公司里最卷的岗位之一。天天加班加点，追最新的技术栈，像素级还原设计稿，为了那100毫秒的性能提升死磕到底。</p><p>但不知道你有没有过类似的感受：尽管我们做了这么多，但在很多公司里，我们总感觉自己处于食物链的下游？为什么在讨论核心战略、分配项目奖金、甚至决定项目方向时，前端的声音总是那么微弱，甚至最先被排除在外？</p><p>最近我和一些朋友聊起这个话题，并进行了一些思考。对于我们这个角色，在很多公司的权力结构和价值链条中，天然地处于一个比较尴尬的位置。</p><p><strong>价值与稀缺性？</strong></p><p>前端的工作，被认为是理所应当的基础设施，而不是稀缺的核心价值。</p><p>在很多管理者眼中，前端技术栈的更迭再快，本质上也是可以 快速可复制的。</p><pre><code>“这个React组件你写不出来，我换个培训班出来的年轻人，多花点时间，总能堆出来。”
“这个页面仔- 速度慢一点，用户忍一忍也能用。”

</code></pre><p>但资本（决定公司生死）、市场（带来客户和收入）、核心后端算法（构建技术壁垒），只有这些被认为是稀缺且难以替代的。</p><p>在一个体系里，回报总是会向稀缺的一方倾斜。这就是为什么，尽管我们对用户体验至关重要，但在价值排序上，却常常被放在后面。</p><h3>我们是执行者</h3><p><img width="664" height="454" referrerpolicy="no-referrer" src="/img/bVdnbxw" alt="" title=""/></p><p>公司的资源分配，通常不是按谁干得最累，而是按谁能影响最终的资源流向。</p><p>我们来看看一个典型项目的流程：</p><pre><code>老板/管理层：决定项目方向和预算。（掌握资金）
产品经理：定义用户需求和产品形态。（掌握需求）
后端工程师：设计数据结构和核心业务逻辑。（掌握数据）
前端工程师：将后端提供的数据，用产品经理设计的形态，画在屏幕上。（掌握展现）

</code></pre><p>在这个工作链条里，前端往往是的最后的一环。我们是落地者，但不是 决策者。</p><p>一个最典型的例子就是API的制定。很多时候，我们只能被动地接受后端定义的、对UI极其不友好的数据结构，然后在客户端，写大量的“垃圾代码😳”去适配。我们很少有话语权，去反向推动后端，为我们提供更合理的API。</p><p>在一个体系里，生产关系决定生产力的回报分配。我们前端，就是那个强大的生产力，但我们离生产关系的核心——资金、客户、股权——太远了。</p><h3>看不见的用户体验</h3><p>这个观点在前端身上体现得淋漓尽致。</p><pre><code>
后端的价值是显性的：服务挂了，网站500，所有人都看得见，这是P0级事故。


销售的价值是显性的：签下一个订单，公司账户里多了几百万，这是最直接的功劳。


前端的价值，很多时候是隐性的：


    一个页面加载慢了1秒，用户可能只是皱了皱眉，然后默默忍受。
    一个动画掉了几帧，用户可能只是觉得有点卡，但说不出所以然。
    一个按钮的响应慢了100毫秒，这在非技术人员看来，几乎无法察觉。

</code></pre><p>这些问题，不会让系统立刻崩溃，但它们会像温水煮青蛙一样，慢慢地侵蚀用户的好感和留存率。我们前端工程师，花了大量的精力去进行性能优化、代码重构，这些工作极其重要，但它们的价值，很难被量化，也很难被非技术人员看见。</p><p>一个看不见的价值，自然就很难在资源分配时，获得足够的话语权。</p><h3>机会</h3><p>技术大厂的跳板机遇，前端-测试-后端，新一线和上海深圳等地均有<a href="https://link.segmentfault.com/?enc=L%2FAGjHT%2F7kUw1IKUomnMvw%3D%3D.%2BA%2F1v1NWnr91mV4mRPPfg0QGA%2F3%2BaCsjZpNrZS2rRC0%3D" rel="nofollow" target="_blank">坑位</a>，待遇还不错，感兴趣可试试~</p><h3>如何破局</h3><p>聊了这么多困境，并不是为了贩卖焦虑。认清现实，是为了更好地突围。</p><p>我认为前端工程师要改变边缘化的处境，有三条路可以走：</p><p><strong>懂业务，成为产品工程师</strong></p><p>不要只做一个接需求的人。多去问产品经理为什么？多去了解我们的用户画像、商业模式和市场策略。当你能从业务价值、用户增长的角度，去提出技术方案或产品建议时，你的角色就不再是一个执行者，而是一个共创者。</p><p><strong>成为领域专家</strong></p><p>在一个垂直领域，做到团队甚至公司里的Top 1。</p><p>成为性能优化专家，用翔实的数据（LCP, INP, CLS）和业务指标（转化率、留存率），来证明你的优化，为公司带来了多少实实在在的收益。或者成为可视化专家，能用Three.js, D3.js实现别人实现不了的复杂图表和3D效果。或者成为工程化专家，能搭建一套让团队开发效率翻倍的工具链。</p><p>当你拥有了不可替代性，你的话语权自然就来了。</p><p><strong>扩展影响力，成为团队枢纽</strong></p><p>主动承担起更多的“连接”工作。</p><pre><code>
去和后端吵架，推动更合理的API设计。


去给测试同学赋能，开发提效工具。


多做技术分享，多写技术文档，把你的知识沉淀下来，赋能给整个团队。

当你成为团队不可或缺资源时，你的价值就远远超出了你写的那些代码。


</code></pre><h3>写在最后</h3><p>前端开发，绝不是一个没有前途的岗位。恰恰相反，因为我们离用户最近，我们本该是产品体验的第一负责人。</p><p>问题的关键，在于我们是否愿意主动地，从代码实现的舒适区里走出来，去承担更多的责任（内卷🤣），去争取更多的话语权，去证明我们那些看不见的价值。</p><p>这条路，不好走，但必须走，你们觉得呢🤔</p><p>——转载自：ErpanOmer</p>]]></description></item><item>    <title><![CDATA[B站服务器开发一二面 王中阳讲编程 ]]></title>    <link>https://segmentfault.com/a/1190000047432763</link>    <guid>https://segmentfault.com/a/1190000047432763</guid>    <pubDate>2025-11-27 17:16:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>今天分享一下训练营内部朋友<strong>在B站游戏服务器开发</strong>面试的详解，</p><p>主要整理了问到的技术问题，项目介绍类问题去掉了，覆盖<strong>分布式、中间件、数据库、并发控制</strong>等知识点，大家可以参考学习一下。</p><h3>一面</h3><h4>1. 项目最终一致性的设计思路</h4><p>核心思路：<strong>基于“事务消息+重试机制+幂等性”实现，优先选择低侵入性方案</strong>，适用于订单支付后库存、积分、日志等跨服务同步场景。</p><p>具体实现（以订单支付为例）：</p><ol><li>本地事务与消息发送原子性：使用“本地消息表+定时任务”或 RocketMQ 事务消息。比如用 RocketMQ 时，先执行本地订单更新（状态改为“待支付”→“已支付”），成功后提交事务消息，失败则回滚本地事务。</li><li>消息消费与重试：下游服务（库存、积分）订阅事务消息，消费成功则更新自身状态，失败则触发 MQ 重试（阶梯式重试：10s/30s/5min，避免瞬时故障）。</li><li>幂等性保障：每个消息携带唯一 ID（如订单号+流水号），下游服务消费前先查“消息消费记录表”，已消费则直接返回成功，未消费则执行逻辑。</li><li>最终兜底：定时任务扫描“未同步成功”的订单，主动触发补偿逻辑（如调用库存服务接口重试），确保最终所有服务状态一致。</li></ol><h4>2. 项目异步设计的思路</h4><p>核心思路：<strong>解耦服务依赖、提高吞吐量</strong>，优先用“消息队列+Go 协程”组合，覆盖跨服务异步和本地异步场景。</p><p>具体设计：</p><ol><li>跨服务异步（解耦）：用 Kafka/RocketMQ 做异步通信，比如用户注册后，同步发送“注册成功”消息，下游服务（短信、邮件、日志）订阅消费，主流程无需等待。</li><li>本地异步（提效）：用 Go 协程处理无依赖的本地任务，比如订单创建后，启动协程异步生成订单快照、记录操作日志，通过 <code>sync.WaitGroup</code> 控制协程等待（如需等待结果）或 <code>channel</code> 传递结果。</li><li><p>关键保障：</p><ul><li>幂等性：同最终一致性的消息 ID 校验；</li><li>超时处理：用 <code>context.WithTimeout</code> 控制协程执行时间，避免阻塞；</li><li>错误处理：协程 panic 捕获（<code>defer recover()</code>）、消息消费失败入死信队列，定期复盘；</li><li>结果回调：如需同步异步结果，用“回调函数+channel”或“状态轮询”（如前端轮询订单支付状态）。</li></ul></li></ol><p>项目落地：游戏充值接口通过异步化改造，吞吐量从 500 QPS 提升至 3000 QPS，响应时间从 300ms 降至 50ms。</p><h4>3. 消息队列怎么消费不同标签的信息</h4><p>以 RocketMQ（Tag 机制）和 Kafka（Topic+Partition 二级分类）为例，核心是“<strong> broker 端过滤+消费端订阅</strong>”：</p><ol><li>标签（Tag）设计：Tag 是消息的二级分类，基于业务场景划分（如订单消息：<code>ORDER_PAID</code>/<code>ORDER_CANCELLED</code>/<code>ORDER_REFUNDED</code>）。</li><li><p>消费端订阅逻辑（Go 实现）：</p><ul><li>RocketMQ：使用 Go SDK（如 <code>github.com/apache/rocketmq-client-go</code>），在创建消费者时，通过 <code>ConsumerOption</code> 指定订阅的 Tag，格式为 <code>Topic:Tag1||Tag2</code>（多 Tag 用 <code>||</code> 分隔），Broker 会仅将匹配 Tag 的消息投递给消费者。</li><li>Kafka：无原生 Tag，但可通过“Topic+消息头”模拟，消费端读取消息头中的 <code>tag</code> 字段过滤，或直接按 Tag 拆分 Topic（如 <code>order_paid_topic</code>/<code>order_cancelled_topic</code>），更高效。</li></ul></li><li>优势：Broker 端过滤减少无效消息传输，提升消费效率；消费端可灵活订阅所需 Tag，实现业务解耦。</li></ol><h4>4. Golang 的线程池、协程池的使用？比如 running buffer</h4><p>Go 无内置线程池/协程池，但协程（Goroutine）轻量（初始栈 2KB），可通过 <code>channel</code> 手动实现协程池，核心是“<strong>控制并发数+任务调度</strong>”：</p><h5>（1）协程池核心设计</h5><ul><li>核心组件：任务队列（<code>taskChan</code>）、worker 协程池、并发控制（<code>maxWorkers</code>）、运行状态标识（<code>running buffer</code>，即当前活跃 worker 数）。</li><li><p>实现步骤（Go 代码简化）：</p><pre><code class="go">type Task func() error

type Pool struct {
    taskChan   chan Task       // 任务队列
    maxWorkers int             // 最大并发数
    running    int32           //  当前运行的worker数（原子变量，避免竞态）
    ctx        context.Context
    cancel     context.CancelFunc
}

// 初始化协程池
func NewPool(maxWorkers int) *Pool {
    ctx, cancel := context.WithCancel(context.Background())
    pool := &amp;Pool{
        taskChan:   make(chan Task, 100), // 任务队列缓冲
        maxWorkers: maxWorkers,
        ctx:        ctx,
        cancel:     cancel,
    }
    // 启动worker
    for i := 0; i &lt; maxWorkers; i++ {
        go pool.worker()
    }
    return pool
}

// worker协程：循环消费任务
func (p *Pool) worker() {
    defer atomic.AddInt32(&amp;p.running, -1)
    atomic.AddInt32(&amp;p.running, 1)
    for {
        select {
        case &lt;-p.ctx.Done():
            return
        case task, ok := &lt;-p.taskChan:
            if !ok {
                return
            }
            _ = task() // 执行任务
        }
    }
}

// 提交任务
func (p *Pool) Submit(task Task) error {
    select {
    case &lt;-p.ctx.Done():
        return fmt.Errorf("pool closed")
    case p.taskChan &lt;- task:
        return nil
    }
}</code></pre></li></ul><h5>（2）关键概念与使用场景</h5><ul><li><code>running buffer</code>：用 <code>atomic.Int32</code> 维护当前运行的 worker 数，可用于监控协程池负载（如通过 Prometheus 暴露指标）。</li><li>使用场景：高并发 I/O 操作（如批量调用第三方接口、数据库批量写入）、避免无限制创建协程导致的内存溢出。</li><li>注意点：任务队列需设置缓冲（避免提交任务阻塞）、worker 优雅退出（通过 context 控制）、错误处理（任务执行失败需记录日志或重试）。</li></ul><h4>5. 用的什么中间件监听数据库 binlog</h4><p>项目中用 <strong>Canal</strong> 监听 MySQL binlog，核心是“模拟 MySQL 从库同步协议，解析 binlog 并推送变更”：</p><ol><li><p>工作流程：</p><ul><li>Canal 伪装成 MySQL 从库，向主库发送 dump 命令，获取 binlog 日志；</li><li>解析 binlog（支持 row 格式，记录具体数据变更），提取表名、操作类型（insert/update/delete）、变更前后数据；</li><li>通过 Canal Client（Go  SDK：<code>github.com/alibaba/canal-go</code>）订阅变更事件，推送至业务逻辑（如同步数据到 Redis、ES，或触发跨服务通知）。</li></ul></li><li>优势：轻量、低侵入（无需修改业务代码）、支持高可用部署（Canal Server 集群）。</li></ol><h4>6. Redis 常用的数据结构</h4><table><thead><tr><th>数据结构</th><th>核心用途</th><th>项目应用场景</th></tr></thead><tbody><tr><td>String</td><td>简单键值存储、计数器</td><td>存储玩家验证码（key=player:{id}:code）、游戏在线人数计数（INCR/DECR）</td></tr><tr><td>Hash</td><td>复杂对象存储（字段-值映射）</td><td>存储玩家信息（key=player:{id}，field=name/level/gold）、商品属性</td></tr><tr><td>List</td><td>队列、栈、消息列表</td><td>游戏公告队列（LPUSH/RPOP）、玩家邮件列表</td></tr><tr><td>Set</td><td>去重、交集/并集运算</td><td>玩家好友关系（SADD/SISMEMBER）、抽奖活动去重（避免重复中奖）</td></tr><tr><td>Sorted Set</td><td>有序排序、排行榜</td><td>游戏战力排行榜（ZADD/ZRANGE）、限时活动积分排名</td></tr><tr><td>Bitmap</td><td>位运算、布尔值存储</td><td>玩家签到记录（key=sign:{date}，bit=playerID，1=已签到）</td></tr><tr><td>Geo</td><td>地理位置计算</td><td>游戏附近玩家查找（GEORADIUS）</td></tr></tbody></table><p>进阶用法：Hash 用 HSCAN 避免大 key 阻塞、Sorted Set 用 ZREMRANGEBYRANK 维护TopN排行榜、String 用 SETEX 实现过期缓存。</p><h4>7. ETCD 的作用</h4><p>ETCD 是分布式键值存储（基于 Raft 协议），核心作用是“<strong>分布式一致性保障</strong>”，项目中主要用于 3 个场景：</p><ol><li>服务注册与发现：微服务（如游戏网关、战斗服、道具服）启动时向 ETCD 注册（key=/services/{serviceName}/{instanceID}，value=服务地址+元数据），客户端通过 ETCD 的 Watch 机制监听服务变更，动态获取可用实例（配合 gRPC 负载均衡）。</li><li>配置中心：存储全局配置（如数据库连接池大小、活动开关、限流阈值），通过 Watch 机制实现配置动态更新（无需重启服务），Go 中用 <code>etcd/clientv3</code> 订阅配置变更。</li><li>分布式锁：基于 ETCD 的 Lease（租约）+ CAS 操作实现，用于跨服务并发控制（如游戏跨服活动报名、分布式任务调度），避免死锁（租约过期自动释放锁）。</li></ol><p>优势：强一致性、高可用（集群部署）、轻量、支持 TTL 过期键。</p><h4>8. 百库百表分库分表思路（玩家场景）</h4><p>核心思路：<strong>水平分片（按玩家 ID 哈希分片）</strong>，目标是分散数据压力、提升查询效率，适配百万级玩家数据存储：</p><ol><li>分片维度选择：按玩家 ID 分片（玩家操作自身数据时，可直接路由到对应库表，无跨库联查）。</li><li><p>分片策略：</p><ul><li>分库分表规则：100 库 × 100 表 = 10000 张表。玩家 ID 经过哈希计算（如 <code>hash(playerID) % 100</code>）得到库索引，<code>hash(playerID) / 100 % 100</code> 得到表索引，最终路由到 <code>db{库索引}.t_player_{表索引}</code>。</li><li>哈希算法：用一致性哈希（带虚拟节点），支持后续扩容（新增库表时仅迁移部分数据，影响范围小）。</li></ul></li><li>中间件选型：ShardingSphere-JDBC（Go 项目中用 <code>shardingsphere-go</code>），透明化分库分表逻辑（业务代码无需关注分片规则，直接操作逻辑表）。</li><li><p>关键问题解决：</p><ul><li>全局 ID：用雪花算法（Snowflake）生成唯一订单号/玩家 ID，避免分库分表后 ID 冲突。</li><li>跨库查询：避免跨库联查，通过“宽表冗余”（如玩家订单表冗余玩家基础信息）或“应用层聚合”（先查各库数据，再在服务端合并）。</li><li>扩容方案：新增库表时，基于一致性哈希迁移旧数据，双写新旧库一段时间（确保数据一致），再切换到新库表。</li></ul></li></ol><p>项目落地：游戏玩家中心存储 500 万玩家数据，分 100 库 100 表，单表数据量控制在 5000 以内，查询响应时间稳定在 10ms 内。</p><h3>二面</h3><h4>1. 压测时遇到的性能瓶颈及解决</h4><p>压测工具：用 k6（Go 编写，高并发支持）+ Prometheus+Grafana 监控指标（QPS、响应时间、CPU/内存/网络），遇到的核心瓶颈及解决方案：</p><table><thead><tr><th>瓶颈类型</th><th>现象</th><th>排查方式</th><th>解决方案</th></tr></thead><tbody><tr><td>数据库慢查询</td><td>接口响应时间&gt;500ms，MySQL CPU 100%</td><td>EXPLAIN 分析 SQL，慢查询日志</td><td>1. 给订单表添加联合索引（player_id+create_time）；2. 分页查询优化（用游标代替 limit offset）；3. 读写分离（读请求路由到从库）</td></tr><tr><td>Redis 缓存穿透</td><td>大量请求穿透到数据库，Redis 命中率&lt;80%</td><td>Redis 监控面板查看命中率</td><td>1. 无效 key 缓存空值（SETEX key 3600 ""）；2. 布隆过滤器（RedisBloom）过滤不存在的玩家 ID</td></tr><tr><td>协程泄露</td><td>内存持续增长，协程数&gt;10w</td><td>pprof 分析 goroutine 栈</td><td>1. 协程池控制并发数（maxWorkers=100）；2. 用 context.WithTimeout 控制协程生命周期，避免无限阻塞</td></tr><tr><td>网络瓶颈</td><td>跨服务调用延迟&gt;200ms</td><td>tcpdump 抓包，链路追踪（Jaeger）</td><td>1. 服务本地缓存热点数据（如活动配置）；2. gRPC 连接池优化（复用连接，减少握手开销）</td></tr></tbody></table><p>优化结果：接口 QPS 从 800 提升至 5000，响应时间稳定在 50-80ms，CPU 使用率控制在 70% 以内。</p><h4>2. MySQL 相关优化</h4><p>从“索引、SQL、配置、架构”四层优化，结合项目实践：</p><ol><li><p>索引优化：</p><ul><li>核心原则：给查询频繁的字段建索引，避免过度索引（影响写入性能）；</li><li>实践：玩家订单表（player_id、create_time、status）建联合索引，覆盖查询（<code>select id, amount from t_order where player_id=? and status=? order by create_time desc</code>），避免回表。</li></ul></li><li><p>SQL 优化：</p><ul><li>避免 select *（只查需要的字段）、避免 <code>or</code>（用 union 代替）、子查询转 join；</li><li>实践：将“查询玩家近 30 天订单并关联商品信息”的子查询，改为 join 查询，执行时间从 300ms 降至 50ms。</li></ul></li><li><p>配置优化：</p><ul><li>innodb_buffer_pool_size = 物理内存的 50%-70%（缓存数据和索引，减少磁盘 I/O）；</li><li>max_connections = 2000（适配高并发场景）；</li><li>关闭 binlog 或设置为 row 格式（减少 binlog 体积，提高写入性能）。</li></ul></li><li><p>架构优化：</p><ul><li>主从复制（一主两从），读请求分流到从库（通过 ShardingSphere-JDBC 实现读写分离）；</li><li>分库分表（如玩家表、订单表），分散单库单表压力。</li></ul></li></ol><h4>3. 实际项目中发现 MySQL 查询瓶颈的方法</h4><p>核心是“<strong>监控+日志+执行计划</strong>”三位一体，步骤如下：</p><ol><li>慢查询日志定位：开启 MySQL 慢查询日志（<code>slow_query_log=1</code>，<code>long_query_time=1</code>），捕获执行时间&gt;1s 的 SQL，定期分析日志（用 pt-query-digest 工具汇总）。</li><li>执行计划分析：对慢查询用 <code>EXPLAIN</code> 分析，重点看 <code>type</code>（索引类型，如 ref、range 优于 all）、<code>key</code>（是否使用索引）、<code>rows</code>（扫描行数，越少越好）、<code>Extra</code>（是否 Using filesort/Using temporary，需优化）。</li><li>实时监控：通过 Prometheus+Grafana 监控 MySQL 指标（<code>slow_queries</code> 慢查询数、<code>innodb_rows_read</code> 扫描行数、<code>Threads_running</code> 运行线程数），设置阈值告警（如慢查询数&gt;10 触发告警）。</li><li>业务日志关联：在应用日志中记录 SQL 执行时间（如 Go 中用 <code>sqlx</code> 拦截器），当接口响应变慢时，直接定位到耗时 SQL。</li></ol><p>项目案例：通过慢查询日志发现“玩家累计充值金额查询”SQL 未走索引，扫描全表（rows=50w），用 <code>EXPLAIN</code> 分析后，给 <code>player_id</code> 建索引，查询时间从 1.2s 降至 8ms。</p><h4>4. 分布式系统 100 台服务器，玩家报错的处理流程</h4><p>核心思路：<strong>快速定位故障范围→精准排查根因→临时止损→永久修复</strong>，步骤如下：</p><ol><li>收集报错信息：让玩家提供“报错提示（如‘支付失败’）、操作时间、玩家 ID、服务器区服”，前端同时上报报错时的 traceID（链路追踪 ID）。</li><li><p>定位故障服务与节点：</p><ul><li>通过 traceID 在 Jaeger 中查询跨服务调用链路，确认是哪个服务（如支付服、订单服）报错；</li><li>在 ELK 日志平台中，按“traceID+玩家 ID+时间范围”过滤日志，找到报错的服务器节点（IP+端口）。</li></ul></li><li><p>排查节点问题：</p><ul><li>应用日志：查看该节点的错误堆栈，定位代码层面问题（如空指针、数据库连接超时）；</li><li>系统监控：查看节点的 CPU、内存、磁盘 I/O、网络（用 Prometheus+Grafana），是否存在资源耗尽；</li><li>依赖服务：检查该节点依赖的数据库、Redis、MQ 是否正常（如 Redis 连接超时、数据库主从切换）。</li></ul></li><li><p>临时止损：</p><ul><li>若单节点故障：通过负载均衡下线该节点，将流量转发到其他健康节点；</li><li>若服务级故障：触发熔断（如用 Hystrix/Resilience4j），返回友好提示（“系统临时维护，请稍后再试”），避免雪崩。</li></ul></li><li><p>永久修复与复盘：</p><ul><li>修复代码 bug（如空指针判断、重试机制优化）；</li><li>优化监控告警（补充关键链路告警）；</li><li>复盘会议，总结故障原因（如“未处理 Redis 连接超时”），避免同类问题。</li></ul></li></ol><h4>5. 如何定位日志</h4><p>基于“<strong>分布式日志架构+链路追踪</strong>”，实现日志快速定位，架构：ELK（Elasticsearch+Logstash+Kibana）+ 链路追踪（Jaeger）：</p><ol><li><p>日志规范：</p><ul><li>统一日志格式（JSON 格式），包含核心字段：<code>traceID</code>（链路追踪 ID）、<code>spanID</code>、<code>serviceName</code>（服务名）、<code>instanceIP</code>（节点 IP）、<code>playerID</code>（玩家 ID）、<code>time</code>（时间戳）、<code>level</code>（日志级别）、<code>msg</code>（日志内容）、<code>stack</code>（错误堆栈）。</li><li>链路追踪透传：用 gRPC 拦截器或 HTTP 中间件，在服务间传递 <code>traceID</code>，确保同一请求的所有日志都携带相同 <code>traceID</code>。</li></ul></li><li><p>定位步骤：</p><ul><li>玩家报错后，获取 <code>traceID</code>（从前端或玩家提供的报错信息中提取）；</li><li>打开 Kibana，在索引中按 <code>traceID:xxx</code> 过滤，获取该请求的所有日志（从网关→业务服→依赖服务）；</li><li>按时间排序日志，找到报错节点的错误堆栈，定位问题（如“支付服调用微信支付接口超时”）；</li><li>结合 Jaeger 查看该 <code>traceID</code> 的调用链路，确认超时环节（如微信支付接口响应时间&gt;3s）。</li></ul></li></ol><p>项目落地：通过该方案，将日志定位时间从 30 分钟缩短至 5 分钟，大幅提升故障排查效率。</p><h4>6. 超买超卖的订单处理</h4><p>核心是“<strong>并发控制+原子操作</strong>”，基于 Redis+MySQL 实现双重保障：</p><ol><li><p>方案一：Redis 分布式锁+库存预扣减（高并发场景首选）</p><ul><li>锁 key：<code>lock:goods:{goodsID}</code>（同一商品共享一把锁）；</li><li><p>流程：</p><ol><li>玩家下单时，用 Redis SET NX EX 命令获取锁（<code>SET lock:goods:123 1 EX 10 NX</code>）；</li><li>获取锁成功后，查询 Redis 库存（<code>GET goods:stock:123</code>），库存不足则返回“商品已售罄”；</li><li>库存充足则预扣减（<code>DECR goods:stock:123</code>），释放锁（<code>DEL lock:goods:123</code>）；</li><li>预扣减成功后，异步写入数据库（订单表+库存表），数据库库存表加行锁（<code>select stock from t_goods where id=? for update</code>），确保最终库存一致。</li></ol></li><li>注意：锁超时时间需大于业务执行时间，避免死锁；用 Lua 脚本保证“查库存+扣库存”原子性。</li></ul></li><li><p>方案二：MySQL 乐观锁（低并发场景，无锁竞争）</p><ul><li>库存表添加 <code>version</code> 字段；</li><li>扣库存 SQL：<code>update t_goods set stock=stock-1, version=version+1 where id=? and stock&gt;=1 and version=?</code>；</li><li>执行后判断影响行数，若为 0 则说明库存不足或已被其他请求扣减，返回“操作失败”。</li></ul></li></ol><p>项目落地：游戏限时抢购活动用方案一，支持 1w+ QPS 并发下单，超买超卖率为 0，库存一致性 100%。</p><h4>7. 并发场景避免二次执行（如重复发货）</h4><p>核心是“<strong>幂等性设计</strong>”，结合业务场景选择以下方案：</p><ol><li><p>方案一：唯一请求 ID（客户端层面）</p><ul><li>客户端（如游戏客户端）生成唯一请求 ID（UUID），每次请求携带该 ID；</li><li>服务端接收请求后，先查 Redis：<code>EXISTS request:id:{requestID}</code>，存在则返回“操作已执行”，不存在则执行业务逻辑；</li><li>业务逻辑执行成功后，将请求 ID 存入 Redis（<code>SET request:id:{requestID} 1 EX 3600</code>），过期时间设为业务操作有效时间。</li></ul></li><li><p>方案二：业务唯一键（数据库层面）</p><ul><li>订单表创建唯一索引：<code>UNIQUE KEY uk_player_goods (player_id, goods_id, activity_id)</code>（同一玩家同一活动同一商品只能创建一次订单）；</li><li>重复请求时，数据库会抛出 <code>Duplicate key error</code>，服务端捕获后返回“操作已执行”。</li></ul></li><li><p>方案三：分布式锁（服务端层面）</p><ul><li>锁 key：<code>lock:player:{playerID}:goods:{goodsID}</code>（同一玩家同一商品的操作共享一把锁）；</li><li>只有获取锁的请求能执行业务逻辑，其他请求等待或直接返回，避免并发执行。</li></ul></li></ol><p>项目落地：游戏道具发放用“方案一+方案二”，既通过请求 ID 快速拦截重复请求，又通过数据库唯一索引兜底，确保无二次发货。</p><h4>8. 支付体系的回调</h4><p>支付回调是支付平台（微信/支付宝）向商户服务器发送的异步支付结果通知，核心流程：“<strong>签名验证+幂等处理+订单更新+响应确认</strong>”：</p><ol><li><p>完整流程：</p><ul><li>回调配置：在支付平台（如微信支付商户平台）配置回调地址（必须 HTTPS，公网可访问）；</li><li>回调触发：用户支付成功后，支付平台向回调地址发送 POST 请求，参数包含：支付流水号、订单号、支付金额、签名等；</li><li>签名验证：服务端用商户密钥验证参数签名（如微信支付的 HMAC-SHA256 签名），确保请求来自官方，防止伪造；</li><li>幂等处理：通过订单号查询本地订单状态，若已处理（如“已支付”），直接返回成功响应；</li><li>业务处理：未处理则更新订单状态为“已支付”，执行后续逻辑（扣库存、发道具、加积分）；</li><li>响应确认：向支付平台返回指定格式的成功响应（如微信支付返回 <code>&lt;xml&gt;&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;&lt;/xml&gt;</code>），否则支付平台会阶梯式重试（如 15s/30s/1min/2min/5min/10min/30min/1h/2h/6h/15h，共 11 次）。</li></ul></li><li><p>关键注意点：</p><ul><li>签名验证：必须验证，避免恶意回调；</li><li>幂等处理：支付平台会重试，必须保证回调处理幂等；</li><li>日志记录：详细记录回调参数、处理结果，便于排查问题；</li><li>超时处理：回调处理时间需&lt;10s，避免支付平台判定超时重试。</li></ul></li></ol><h4>9. 仅用 Redis 和 MySQL 防止多个请求反复执行</h4><p>核心是“<strong>Redis 原子操作快速拦截+MySQL 唯一索引兜底</strong>”，无需额外中间件：</p><ol><li><p>实现方案（以玩家购买商品为例）：</p><ul><li><p>步骤 1：Redis 原子判断+锁定（快速拦截）</p><ul><li>玩家发起购买请求时，服务端执行 Redis 命令：<code>SETNX lock:player:{playerID}:goods:{goodsID} 1 EX 30</code>（30s 过期，避免死锁）；</li><li>若返回 1（获取锁成功），则继续执行；若返回 0（已被其他请求锁定），则返回“操作中，请稍后再试”。</li></ul></li><li><p>步骤 2：MySQL 唯一索引兜底（防止 Redis 宕机）</p><ul><li>订单表创建唯一索引：<code>uk_player_goods (player_id, goods_id)</code>，确保同一玩家同一商品只能创建一次订单；</li><li>执行订单插入 SQL：<code>insert into t_order (player_id, goods_id, amount, status) values (?, ?, ?, ?)</code>；</li><li>若插入成功（影响行数=1），则执行后续逻辑（扣库存、发道具）；若抛出 <code>Duplicate key error</code>，则返回“操作已执行”。</li></ul></li><li><p>步骤 3：释放锁</p><ul><li>订单创建成功或失败后，执行 <code>DEL lock:player:{playerID}:goods:{goodsID}</code> 释放锁（或等待自动过期）。</li></ul></li></ul></li><li><p>优势：</p><ul><li>Redis 层面快速拦截高并发重复请求，减少数据库压力；</li><li>MySQL 唯一索引兜底，即使 Redis 宕机，也能防止重复执行；</li><li>无额外中间件依赖，部署简单。</li></ul></li></ol><p>项目落地：游戏内玩家购买月卡场景用该方案，支持 5k+ QPS 并发请求，无重复购买、重复发货问题。</p><h2>欢迎关注 ❤</h2><p>我们搞了很多<strong>免费的面试真题共享群</strong>，互通有无，一起刷题进步。</p><p><strong>没准能让你能刷到自己意向公司的最新面试题呢。</strong></p><p>感兴趣的朋友们可以加我微信：<strong>wangzhongyang1993</strong>，备注：面试群。</p>]]></description></item><item>    <title><![CDATA[屡败？屡战？制造企业数字化转型难在哪里？]]></title>    <link>https://segmentfault.com/a/1190000047432781</link>    <guid>https://segmentfault.com/a/1190000047432781</guid>    <pubDate>2025-11-27 17:15:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>很多制造企业都有一个共同的困惑：数字化投入年年有，但效果总是不如意。</p><p>系统没少上，钱没少花，但管理效率提升有限。</p><p>管理层常常纳闷：为什么别人的数字化做得风生水起，到了自己这里就总是困难重重？</p><p><img width="723" height="239" referrerpolicy="no-referrer" src="/img/bVdnbAL" alt="image.png" title="image.png"/></p><p>业界都说数字化转型是“系统工程”，但这个“系统”到底怎么建？具体怎么落地？</p><p>理论很多，但一到执行，往往还是各部门管各部门的，形成不了合力。</p><p>意识要转<br/>文化要转<br/>组织要转<br/>业务也要转<br/>……</p><p>道理都懂，可具体从哪开始转？每一步怎么走？效果如何衡量？</p><p>对很多制造企业来说，这些问题还没完全理清，项目就已经仓促上马了。</p><p>结果自然是不尽人意，最后往往在内部的质疑、争论、甩锅中不了了之，过段时间又开始等待起下一次转型。</p><p>一次又一次，如此反复...</p><p>那么，制造企业的数字化转型究竟难在哪里？织信在最近合作的几个制造业客户调研中发现了几个关键问题，主要分为内、外两大方面，下面咱们一起来看看。</p><h2>一、来自企业内部的挑战</h2><p>1、自身IT基础薄弱，受制于人</p><p>很多传统制造企业信息化底子薄，自身IT技术人才储备不足。在数字化过程中，从系统实施到后期调整，都高度依赖外部厂商，缺乏自主权与控制力。</p><p>2、触及各部门利益</p><p>数字化本质是业务流程的优化和重塑，这必然会涉及到权责的再分配。一旦触动部门原有的边界和利益，推进的阻力会非常大。</p><p>3、生产流程不规范</p><p>数字化系统需要在标准化的流程上才能跑得顺畅。但现实中，很多生产环节还依赖老师傅的个人经验，不同班组操作习惯不同，这种差不多文化给系统落地带来了很大困难。</p><h2>二、来自外部环境的压力</h2><p>1、数字化厂商只卖产品，不管落地</p><p>很多数字化厂商以“项目上线、完成培训”作为交付终点，至于企业后续有没有用起来、用得好不好，往往不是他们关注和支持的重点。</p><p>2、缺乏整体性产品，无法融合</p><p>企业先后引入了ERP、MES、WMS等多套系统，但由于供应商不同、标准不一，系统之间数据不通，形成一个个信息孤岛，反而增加了员工重复录入的工作量。</p><p>3、行业经验难以复用</p><p>制造业细分领域多，流程差异大。通用软件难以满足个性化需求，而定制开发又成本高、周期长。部分厂商对行业理解不深，容易生搬硬套其他行业的方案，导致水土不服。</p><p>类似的问题，织信团队在英凯模（金属网制造领军企业）、诺尔生物（农业生物技术研发企业）等客户那里都曾遇到过。</p><p>他们此前都经历过 2 次不太成功的数字化尝试，无论是管理层还是IT部门，都感到有些迷茫。而在与织信低代码合作之后，我们现已帮助他们解决掉了大部分问题。</p><h2>三、那么，织信是如何破局的？</h2><p>织信的实施思路，不只是简单地为企业安装一套系统，而是帮助企业构建自己的数字化能力。</p><p><img width="723" height="406" referrerpolicy="no-referrer" src="/img/bVdnbAM" alt="image.png" title="image.png" loading="lazy"/></p><p>在合同签订的第三天，我们交付团队就入驻到了企业现场，到了现场的第一件事就是推动企业建立“数字化小组”——数字化小组主要由懂业务的IT项目经理和至少一位有实权的企业老总共同组建。</p><p><img width="723" height="397" referrerpolicy="no-referrer" src="/img/bVdnbAN" alt="image.png" title="image.png" loading="lazy"/></p><p>建立数字化小组的核心目的是：统一数字化转型的目标与思路，高效协调内部资源，并作为内部业务与外部技术团队之间的桥梁，确保信息对称，为后续工作推进奠定基础。</p><p><img width="723" height="452" referrerpolicy="no-referrer" src="/img/bVdnbAO" alt="image.png" title="image.png" loading="lazy"/></p><p>数字化小组组建完成后，织信交付团队要做的第二件事就是，直接深入车间现场，与各部门主管及关键岗位人员进行多轮、深入的沟通。</p><p>这一阶段的目的远不止于收集需求清单，更是与业务部门共同梳理流程框架、定位问题难点，并明确各环节的功能需求。</p><p><img width="723" height="325" referrerpolicy="no-referrer" src="/img/bVdnbAP" alt="image.png" title="image.png" loading="lazy"/></p><p>这件事完成之后，再找到那位有实权的老总牵头，开项目启动会，让各部门相关人共同参与项目方案设计，确保每一个流程优化方案都能兼顾各方诉求。</p><p>而在这个过程中，对于那些因数字化调整而权责与权限发生改变的负责人，我们会协助企业设计一个过渡方案，重新定位这些人的价值。</p><p>比如，将部分车间主任转型为生产数据分析师，并赋予他们一个新职责。这不仅让他们从重复的事务性工作中解脱出来，转型为依靠数据洞察进行决策的管理者，个人价值得到提升；也能将他们宝贵的现场经验，转化为驱动生产优化的核心资产，为企业创造更大价值。</p><p><img width="723" height="342" referrerpolicy="no-referrer" src="/img/bVdnbAR" alt="image.png" title="image.png" loading="lazy"/></p><p>方案确认后，我们并不急于全面铺开，而是采取优先试点、快速验证的策略。</p><p>我们从客户的各部门中，选择了两个痛点明确、配合度高的部门作为试点，利用织信低代码快速开发的特性配置出针对性的系统功能，并迅速投入测试使用，让大家在短期内看到实际效果。</p><p>比如生产部经常有一些PDA扫码、录入数据的工作，那么织信就为这部分工作配置一个“数据自动录入”的功能，让扫码之后的数据能自动上传到系统并能进行对应的流程操作。</p><p>很多时候，像这种立竿见影的改善，是化解疑虑、赢得支持的最有效方式。</p><p><img width="723" height="338" referrerpolicy="no-referrer" src="/img/bVdnbAS" alt="image.png" title="image.png" loading="lazy"/></p><p>在这几个试点成功、营造出良性氛围后，其他系统也会在几个月内很快开发好，并逐步安稳上线。</p><p>遇到有多个系统一起上线时，我们会设立系统并行期，让员工有足够的时间适应，并对快速适应的员工给予激励，平滑度过转型阵痛。</p><p>与此同时，关于低代码能力的内部沉淀，我们是贯穿项目始终的。通过织信团队的平台培训，将低代码的开发能力赋能给企业的IT人员，甚至是业务人员。</p><p>这样一来，企业往后就不再完全受制于外部供应商。业务人员只要清楚自己的需求，也能通过低代码平台快速配置出想要的功能。</p><p><img width="723" height="346" referrerpolicy="no-referrer" src="/img/bVdnbAU" alt="image.png" title="image.png" loading="lazy"/></p><p>解决了这些问题后，再来针对实际的业务问题进行优化。</p><p>比如生产流程不规范这一问题，对于这块，织信团队是专人专项的服务，所以我们会派人与老师傅一同工作，将其宝贵的操作经验梳理出来，转化为系统可执行的规则，然后让现场员工进行测试操作，遇到问题改问题。这样一来，不仅帮助企业保留了经验，还进一步沉淀了知识。</p><p><img width="723" height="583" referrerpolicy="no-referrer" src="/img/bVdnbAV" alt="image.png" title="image.png" loading="lazy"/></p><p>以上问题的解决方式，在实际项目中只是冰山一角。但总体做事的核心不会变。</p><p>织信的原则是：关键环节标准先行、学会使用数据说话、设立系统并行期、对各岗位展开培训进行能力转移。</p><h2>四、织信平台的独特优势</h2><p>1、灵活的开发模式：</p><p>采用“70%无代码+20%低代码+10%全代码”的组合开发方式，无论是简单的表单流程还是复杂的业务逻辑，都能灵活应对。</p><p><img width="723" height="387" referrerpolicy="no-referrer" src="/img/bVdnbAW" alt="image.png" title="image.png" loading="lazy"/></p><p>2、强大的集成能力：</p><p>凭借“数据驱动+流程驱动+组件驱动”的能力，既能构建独立应用，也能轻松与企业现有系统（如ERP、MES等）集成打通，消除信息孤岛。</p><p><img width="723" height="404" referrerpolicy="no-referrer" src="/img/bVdnbAX" alt="image.png" title="image.png" loading="lazy"/></p><p>3、务实的交付理念：</p><p>织信坚持从企业实际业务需求出发，提供最合适、最可行、能落地的解决方案，帮助企业少走弯路。</p><p><img width="723" height="358" referrerpolicy="no-referrer" src="/img/bVdnbAZ" alt="image.png" title="image.png" loading="lazy"/></p><p>数字化转型，归根结底是一场由内而外的能力建设。织信希望做的，就是成为企业身边靠谱的同行者（陪跑式服务），用我们的平台和经验，帮助制造业把数字化道路走得更稳、更顺。</p><p>如果您也是制造企业，也正在为数字化转型而困扰，无论是卡在了哪个环节，都欢迎您与我们聊聊。您只需带着问题来，我们将带上为您定制的解决方案与来自行业最真实的案例，为您安排一次专属的线上咨询，共同厘清您的数字化第一步。</p>]]></description></item><item>    <title><![CDATA[打破跨区域协同壁垒：跨国公司三地一体化数]]></title>    <link>https://segmentfault.com/a/1190000047432794</link>    <guid>https://segmentfault.com/a/1190000047432794</guid>    <pubDate>2025-11-27 17:15:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>引言：<br/>作为跨国贸易企业，如何破解跨区域协作不一致、供应链信息割裂、外协业务复杂、流程标准缺失等困境？本案例将分享M公司通过打造一套数字化、透明化、可追溯的协同体系，成功将三地运营整合为有机整体，实现从打样到交付的全链路标准化管理的做法。</p><p><strong>"跨区域协作瓶颈与供应链管控挑战</strong><br/>M公司是一家业务覆盖北美及欧洲市场的跨国贸易企业，核心运营由A子公司（客户接口与业务主导）、B子公司（采购与供应链执行）及C办事处（外协加工支持）三地协同承担。由于三地缺乏统一协调机制，导致流程冗余、信息不透明，外协加工环节过度依赖人工与线下沟通，错误风险高、协作难度大。<br/>近年来，企业面临的核心问题日益凸显：跨区域协作不一致、供应链信息割裂、外协业务复杂度高、公司间往来流程不顺畅。加之公司业务链条长、市场响应要求高，上述问题严重制约业务发展，显著影响运营效率与交付质量，成为业务增长的瓶颈。</p><p><strong>"以NetSuite为载体的数字化协同体系建设</strong><br/>为破解瓶颈，M公司携手AMT企源开展数字化建设，围绕三地整体流程梳理、数字化方案设计与系统化落地展开，核心目标是构建标准化流程体系、统一数据结构、强化采购与外协管控能力，并以Oracle NetSuite系统为载体实现业务协同数字化，全面提升运营效率与交付质量。</p><p>启动阶段：统一定义，奠定基础<br/>项目组首先对三地组织架构、业务模式及供应链链路进行系统性调研分析，明确A子公司负责客户需求确认、打样报价、订单管理及总体协调；B子公司负责供应商开发、采购执行、公司间贸易结算与物流发运；C办事处负责外协加工支持、品质管理与现场协调。<br/>基于三地角色差异，项目组在启动阶段对组织、流程、资料、权限与职责进行统一定义，为后续标准化与系统建设夯实基础。</p><p>蓝图设计：三大业务模式标准化构建<br/>项目重点聚焦打样业务、一般贸易业务、外协加工业务三大模式的标准化设计。<br/>打样流程明确客户需求录入、成本分析、报价输出及样品交付的全链路管理逻辑；<br/>一般贸易流程统一客户下单、采购执行、质检、出货到公司间交接的完整机制；<br/>外协加工流程围绕材料出入库、工序节点管理、供应商对账及成品追溯展开系统化设计，将原本人工线下流程转为数字化、透明化、可追溯的线上模式。<br/>本阶段输出的业务蓝图，为系统配置提供了清晰的功能范围、流程路径与主数据结构。</p><p><strong>系统实现：NetSuite平台模块定制与适配</strong>**<br/>系统配置以NetSuite核心能力为基础，构建采购、销售、外协加工、库存、财务、公司间贸易管理等模块。针对跨公司贸易频繁的特点，设计标准化公司间订单模型，实现系统内自动生成对账单、内部订单与出入库记录，显著降低人工对账风险。外协加工模块通过BOM拆解、多工序配置、节点确认及材料领用管理，实现对加工过程成本、进度与质量的系统管控。<br/>同时，项目自定义供应商评分、采购异常记录、品质检验流程及跨区域库存可视化等功能，大幅提升三地协作效率与透明度。</p><p>上线准备与支持：数据治理与用户赋能<br/>上线前，项目组对物料编码、供应商主数据、客户资料、历史订单、BOM清单及多公司财务结构等基础数据进行全面清洗与结构化管理，确保数据一致性与可追溯性。<br/>通过多轮用户验收测试，模拟打样、采购、外协、质检与出货等真实订单链路，验证系统流程正确性与稳定性。针对三地团队不同角色，开展系统操作、关键用户培训及流程理解教学，保障平稳上线。<br/>上线后建立问题响应机制，实时处理供应商延迟、客户变更、外协异常、财务对账差异等场景，通过持续优化固化跨区域协作规范。</p><p><strong>"项目成效：运营效率与协同能力全面提升</strong><br/>依据系统稳定性、流程标准化程度、业务数据完整性、跨区域协作效率提升及用户体验改善等综合指标评估，各项标准均达到预期目标，项目圆满完成交付。<br/>通过本次项目，M公司实现了三地业务统一标准、流程可视化、供应链透明化及公司间贸易系统化管理。建立以NetSuite为核心的数字化业务平台后，公司在打样交付效率、采购与外协控制力、跨区域协同能力及对北美与欧洲客户的服务稳定性方面均获得显著提升，为未来业务扩张与供应链升级奠定了坚实基础。</p>]]></description></item>  </channel></rss>