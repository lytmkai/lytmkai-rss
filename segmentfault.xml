<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[AI 智能体高可靠设计模式：预测执行 俞凡 ]]></title>    <link>https://segmentfault.com/a/1190000047521834</link>    <guid>https://segmentfault.com/a/1190000047521834</guid>    <pubDate>2026-01-05 11:08:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><em>本系列介绍增强现代智能体系统可靠性的设计模式，以直观方式逐一介绍每个概念，拆解其目的，然后实现简单可行的版本，演示其如何融入现实世界的智能体系统。本系列一共 14 篇文章，这是第 4 篇。原文：<a href="https://link.segmentfault.com/?enc=EM%2F6XkOWkccb0qGC72nSEg%3D%3D.CC8b3u9x3Cq1UzuNINPn%2FA4u9L%2F5Gl0d5vmxanRXMO5PTNDwlPq6pVPvvn28FHQy8lDp8R5GP0u3NqTQWYlgvm%2BDfrJ5xF%2BhJ%2F2L7F7UYLWs6GsasNlO6Gv6BKMN8tPi" rel="nofollow" title="Building the 14 Key Pillars of Agentic AI" target="_blank">Building the 14 Key Pillars of Agentic AI</a></em></blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047508976" alt="" title=""/></p><p>优化智能体解决方案需要软件工程确保组件协调、并行运行并与系统高效交互。例如<a href="https://link.segmentfault.com/?enc=zaFPM0IefL2U%2BH6d%2F8cIHg%3D%3D.r0kEHobg7HolhMW%2FAGZMgEiwzprGW2nz8U12t3i35JJpKUsJ4wB1yaPh08ZLRKJPe5PmVoHn9KJpFibVHZv0Pg%3D%3D" rel="nofollow" title="预测执行" target="_blank">预测执行</a>，会尝试处理可预测查询以<strong>降低时延</strong>，或者进行<a href="https://link.segmentfault.com/?enc=%2F6w33zdUSgvj6m%2FAY3BRzw%3D%3D.e2rd8116v5TLduGhZxLssKGWkOHQ%2FU1dpon0ibfq8sQuFmUWGcnR9ybo36Xr9l7PU0XJjHDYNyrj6ZXRMzn972sA%2FKcLx35RU9saKRfnpV%2FxorseiaxxP7csQec6Sb2QwNdB0BLiALnn3uQRkchEwg8xXqvM%2F86G4D%2BdqVlOL8oZ1j45fEapIcAZMO1BzAtqpIk7AFMFp0IvK2qSxHCVcc0E08Rh0PQlSY%2B1QC7KTQ0%3D" rel="nofollow" title="冗余执行" target="_blank">冗余执行</a>，即<strong>对同一智能体重复执行多次</strong>以防单点故障。其他增强现代智能体系统可靠性的模式包括：</p><ul><li><strong>并行工具</strong>：智能体同时执行独立 API 调用以隐藏 I/O 时延。</li><li><strong>层级智能体</strong>：管理者将任务拆分为由执行智能体处理的小步骤。</li><li><strong>竞争性智能体组合</strong>：多个智能体提出答案，系统选出最佳。</li><li><strong>冗余执行</strong>：即两个或多个智能体解决同一任务以检测错误并提高可靠性。</li><li><strong>并行检索和混合检索</strong>：多种检索策略协同运行以提升上下文质量。</li><li><strong>多跳检索</strong>：智能体通过迭代检索步骤收集更深入、更相关的信息。</li></ul><p>还有很多其他模式。</p><p>本系列将实现最常用智能体模式背后的基础概念，以直观方式逐一介绍每个概念，拆解其目的，然后实现简单可行的版本，演示其如何融入现实世界的智能体系统。</p><p>所有理论和代码都在 GitHub 仓库里：<a href="https://link.segmentfault.com/?enc=wbj%2FQ7PILGVazSr21ntpQw%3D%3D.j7xZBKY9DYOQJA0B1bDs7rV%2BR3hkJ1UdcMjaTF8o3VzjUhlOQdd2gr7%2FwWJByqm5%2Bpw5aOErpt8mK2cmBg3q%2Fg%3D%3D" rel="nofollow" title="🤖 Agentic Parallelism: A Practical Guide 🚀" target="_blank">🤖 Agentic Parallelism: A Practical Guide 🚀</a></p><p>代码库组织如下：</p><pre><code>agentic-parallelism/
    ├── 01_parallel_tool_use.ipynb
    ├── 02_parallel_hypothesis.ipynb
    ...
    ├── 06_competitive_agent_ensembles.ipynb
    ├── 07_agent_assembly_line.ipynb
    ├── 08_decentralized_blackboard.ipynb
    ...
    ├── 13_parallel_context_preprocessing.ipynb
    └── 14_parallel_multi_hop_retrieval.ipynb</code></pre><hr/><h2>对超响应智能体的预测执行</h2><p>许多智能体工作流为：<code>用户输入 -&gt; 代理思考 (调用 LLM) -&gt; 代理执行 (调用工具)</code>。用户在两个阶段都要等待，而预测执行让这两阶段并行执行。</p><p>当代理思考时，系统会对即将发生的动作做出有根据的预测并启动。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521836" alt="预测执行" title="预测执行" loading="lazy"/></p><p>如果预测正确，工具调用时延实际上被 LLM 推理时间隐藏，代理感觉一下子就完成了。</p><p>这是任何高吞吐量、面向用户系统的关键架构模式，快速响应是其主要特点。我们将构建客户支持代理，获取用户订单历史，展示这种模式如何从用户角度消除工具调用时延。</p><p>要展示模式流，首先需要一个现实中执行缓慢的工具。我们将创建模拟数据库查询，具有固定的人工时延。</p><pre><code class="python">from langchain_core.tools import tool
import time
import json

# 定义模拟数据库时延常数
DATABASE_LATENCY_SECONDS = 3
@tool
def get_order_history(user_id: str) -&gt; str:
    """A simulated slow tool that fetches the order history for a given user from a database."""
    print(f"--- [DATABASE] Starting query for user_id: {user_id}. This will take {DATABASE_LATENCY_SECONDS} seconds. ---")
    
    # 'time.sleep()' 模拟网络和数据库查询时间
    time.sleep(DATABASE_LATENCY_SECONDS)
    
    # 在这个演示中使用模拟数据
    mock_db = {
        "user123": [
            {"order_id": "A123", "item": "QuantumLeap AI Processor", "status": "Shipped"},
            {"order_id": "B456", "item": "Smart Coffee Mug", "status": "Delivered"}
        ]
    }
    result = mock_db.get(user_id, [])
    print(f"--- [DATABASE] Query finished for user_id: {user_id}. ---")
    return json.dumps(result)</code></pre><p><code>get_order_history</code> 工具是实验的核心，<code>time.sleep(DATABASE_LATENCY_SECONDS)</code> 给了一个可预测的 3 秒时延，我们尝试用预测执行模式来隐藏该时延。</p><p>接下来定义 <code>GraphState</code>，包含特殊字段 <code>prefetched_data</code>，用于存储预测调用的结果。</p><pre><code class="python">from typing import TypedDict, Annotated, List, Optional
from langchain_core.messages import BaseMessage
import operator
from concurrent.futures import Future

class GraphState(TypedDict):
    messages: Annotated[List[BaseMessage], operator.add]
    user_id: str
    # 'prefetched_data' 持有 Python Future 对象，代表后台工具调用
    prefetched_data: Optional[Future]
    # 'agent_decision' 将保留 LLM 决定进行的实际工具调用
    agent_decision: Optional[BaseMessage]
    performance_log: Annotated[List[str], operator.add]</code></pre><p>这个 <code>GraphState</code> 的关键部分是 <code>prefetched_data: Optional[Future]</code> 字段，<code>Future</code> 是标准 Python 对象，作为尚未可用的结果的占位符，使得入口节点在启动后台任务后立即返回，同时通过状态传递 <code>Future</code> 对象。</p><p>现在说说模式的核心：<code>entry_point</code> 节点，该节点并行启动两个过程：预测工具调用和主要 LLM 推理。</p><pre><code class="python">from concurrent.futures import ThreadPoolExecutor

# 创建线程池来运行后台任务
thread_pool = ThreadPoolExecutor(max_workers=5)
def entry_point(state: GraphState):
    """The entry point node: starts the speculative pre-fetch and the main agent reasoning in parallel."""
    print("--- [ORCHESTRATOR] Entry point started. --- ")
    start_time = time.time()
    
    # 1. 使用线程池在后台线程中启动预测预取
    #    .submit() 方法立即返回 'Future' 对象
    print("--- [ORCHESTRATOR] Starting speculative pre-fetch of order history... ---")
    prefetched_data_future = thread_pool.submit(get_order_history.invoke, {"user_id": state['user_id']})
    
    # 2. 同时，当工具在后台运行时，启动主代理的 LLM 调用
    print("--- [ORCHESTRATOR] Starting main agent LLM call... ---")
    agent_response = llm_with_tools.invoke(state['messages'])
    
    execution_time = time.time() - start_time
    log_entry = f"[Orchestrator] LLM reasoning completed in {execution_time:.2f}s."
    print(log_entry)
    
    # 节点返回添加到状态里的 Future 对象和代理决定
    return {
        "prefetched_data": prefetched_data_future,
        "agent_decision": agent_response,
        "performance_log": [log_entry]
    }</code></pre><p>在 <code>entry_point</code> 节点中，<code>thread_pool.submit()</code> 调用是非阻塞的，在独立线程中启动 3 秒的 <code>get_order_history</code> 工具，并立即返回 <code>Future</code> 对象。代码随后无需等待即可继续，立即调用 <code>llm_with_tools</code>。这就是预测执行模式的并行基础。</p><p>接下来定义 <code>tool_executor_node</code>，该节点有用于检查所需数据是否已被预先获取的特殊逻辑。</p><pre><code class="python">from langchain_core.messages import ToolMessage

def tool_executor_node(state: GraphState):
    """Executes the agent's chosen tool, but first checks if the data has already been pre-fetched."""
    print("--- [TOOL EXECUTOR] Node started. --- ")
    start_time = time.time()
    
    agent_decision = state['agent_decision']
    tool_call = agent_decision.tool_calls[0]
    
    # 检查代理想要调用的工具是否是预测执行的工具
    if tool_call['name'] == "get_order_history":
        print("--- [TOOL EXECUTOR] Agent wants order history. Checking pre-fetch... ---")
        # 如果是，就调用 Future 对象上的 .result()。调用将被阻塞，直到后台线程完成
        # 但如果已经完成，会立即返回结果
        prefetched_future = state['prefetched_data']
        tool_result = prefetched_future.result()
        print("--- [TOOL EXECUTOR] Pre-fetch successful! Using cached data instantly. ---")
    else:
        # 如果代理做出不同决定，则正常执行该工具
        print(f"--- [TOOL EXECUTOR] Speculation failed. Agent wants {tool_call['name']}. Executing normally. ---")
        # (演示未采用此路径)
        tool_result = "Tool not implemented for this demo."
    
    tool_message = ToolMessage(content=tool_result, tool_call_id=tool_call['id'])
    
    execution_time = time.time() - start_time
    log_entry = f"[ToolExecutor] Resolved tool call in {execution_time:.2f}s."
    print(log_entry)
    
    return {"messages": [agent_decision, tool_message], "performance_log": [log_entry]}</code></pre><p>你可能已经注意到，<code>tool_executor_node</code> 的重要性在于 <code>prefetched_future.result()</code> 调用。</p><ol><li>如果 3 秒的数据库查找在 LLM 思考时已经完成，会立即返回。从这一步角度来看，3 秒的时延已经被有效消除。</li><li>如果预测错误，代理选择了不同的工具，就会忽略 <code>Future</code>，从零开始执行正确的工具调用。</li></ol><p>现在组装图……</p><pre><code class="python">from langgraph.graph import StateGraph, END

# 条件边检查代理决定是否包括任何工具调用
def should_call_tool(state: GraphState) -&gt; str:
    if state['agent_decision'].tool_calls:
        return "execute_tool"
    return END

# 定义图
workflow = StateGraph(GraphState)
workflow.add_node("entry_point", entry_point)
workflow.add_node("execute_tool", tool_executor_node)
workflow.add_node("final_answer", final_answer_node) # (Assuming final_answer_node is defined)

# 构建图的控制流
workflow.set_entry_point("entry_point")
workflow.add_conditional_edges("entry_point", should_call_tool)
workflow.add_edge("execute_tool", "final_answer")
workflow.add_edge("final_answer", END)
app = workflow.compile()</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521837" alt="预测执行" title="预测执行" loading="lazy"/></p><p>下面进行测试，将预测工作流实际执行时间与模拟的传统顺序流进行比较。</p><pre><code class="python">from langchain_core.messages import HumanMessage
import json

inputs = {
    "messages": [HumanMessage(content="Hi, can you tell me the status of my recent orders?")],
    "user_id": "user123"
}

step_counter = 1
final_state = None

for output in app.stream(inputs, stream_mode="values"):
    node_name = list(output.keys())[0]
    print(f"\n{'*' * 100}")
    print(f"**Step {step_counter}: {node_name.replace('_', ' ').title()} Node Execution**")
    print(f"{'*' * 100}")
    
    step_counter += 1


#### 输出 ####
[ORCHESTRATOR] Entry point started. --- 
[ORCHESTRATOR] Starting speculative pre-fetch of order history... ---
[DATABASE] Starting query for user_id: user123. This will take 3 seconds. ---
...</code></pre><p>这将基于用户查询启动工作流，但对我们来说，关键是获取这种方法的性能，所以就这么做吧……</p><pre><code class="python"># 在完整运行后从 final_state 性能日志中提取定时数据
# (完整运行已完成，final_state已填充)
llm_time_1 = float(final_state['performance_log'][0].split(' ')[-2])
resolution_time = float(final_state['performance_log'][1].split(' ')[-2])
llm_time_2 = float(final_state['performance_log'][2].split(' ')[-2])
db_time = DATABASE_LATENCY_SECONDS # Our known latency

# 计算预测运行总时间
speculative_total = llm_time_1 + resolution_time + llm_time_2
# 计算模拟顺序运行总时间
sequential_total = llm_time_1 + db_time + llm_time_2
time_saved = sequential_total - speculative_total
reduction_percent = (time_saved / sequential_total) * 100

print("="*60)
print("                  PERFORMANCE SHOWDOWN")
print("="*60)

print("\n" + "-"*60)
print("             SPECULATIVE EXECUTION WORKFLOW (Our Run)")
print("-"*60)
print(f"1. Agent Thinks (LLM Call 1):       {llm_time_1:.2f} seconds")
print(f"   (Database Query: {db_time:.2f}s ran in parallel, fully hidden)")
print(f"2. Tool Result Resolution:          {resolution_time:.2f} seconds (Instant cache hit)")
print(f"3. Synthesize Answer (LLM Call 2):  {llm_time_2:.2f} seconds")

print("-"*60)
print(f"Total Time to Final Answer: {speculative_total:.2f} seconds\n\n")
print("-"*60)

print("             TRADITIONAL SEQUENTIAL WORKFLOW (Simulated)")
print("-"*60)
print(f"1. Agent Thinks (LLM Call 1):       {llm_time_1:.2f} seconds")
print(f"2. Execute Tool (Database Query):   {db_time:.2f} seconds (User waits)")
print(f"3. Synthesize Answer (LLM Call 2):  {llm_time_2:.2f} seconds")

print("-"*60)
print(f"Simulated Total Time: {sequential_total:.2f} seconds\n\n")
print("="*60)
print("                        CONCLUSION")

print("="*60)
print(f"Time Saved: {time_saved:.2f} seconds")
print(f"Perceived Latency Reduction: {reduction_percent:.0f}%\n")</code></pre><p>看下输出……</p><pre><code class="python">#### 输出 ####
============================================================
                  PERFORMANCE SHOWDOWN
============================================================

------------------------------------------------------------
             SPECULATIVE EXECUTION WORKFLOW (Our Run)
------------------------------------------------------------
1. Agent Thinks (LLM Call 1):       4.21 seconds
   (Database Query: 3.00s ran in parallel, fully hidden)
2. Tool Result Resolution:          0.01 seconds (Instant cache hit)
3. Synthesize Answer (LLM Call 2):  3.55 seconds
------------------------------------------------------------
Total Time to Final Answer: 7.77 seconds

------------------------------------------------------------
             TRADITIONAL SEQUENTIAL WORKFLOW (Simulated)
------------------------------------------------------------
1. Agent Thinks (LLM Call 1):       4.21 seconds
2. Execute Tool (Database Query):   3.00 seconds (User waits)
3. Synthesize Answer (LLM Call 2):  3.55 seconds
------------------------------------------------------------
Simulated Total Time: 10.76 seconds

============================================================
                        CONCLUSION
============================================================
Time Saved: 2.99 seconds
Perceived Latency Reduction: 28%</code></pre><p>几乎节约了……准确等待慢速工具调用的持续时间，从而使总响应时间减少 28%。</p><p>在<strong>预测执行工作流</strong>中，3 秒的数据库查询与初始 4.21s 的 LLM 调用同时进行。由于 LLM 调用是两项并行工作中耗时较长的，数据库时延被完全隐藏。<code>tool_executor_node</code> 几乎瞬间用了 0.01s 就完成了，用户感知的总时延仅为 7.77s。</p><hr/><blockquote>Hi，我是俞凡，一名兼具技术深度与管理视野的技术管理者。曾就职于 Motorola，现任职于 Mavenir，多年带领技术团队，聚焦后端架构与云原生，持续关注 AI 等前沿方向，也关注人的成长，笃信持续学习的力量。在这里，我会分享技术实践与思考。欢迎关注公众号「DeepNoMind」，星标不迷路。也欢迎访问独立站 <a href="https://link.segmentfault.com/?enc=eVdLH1%2F92j3u%2Fj62mUg0tA%3D%3D.2SmA9s5YiAozu0fmVjCzzTneRbcfD1vx%2BNB7ECFGvc4%3D" rel="nofollow" title="www.DeepNoMind.com" target="_blank">www.DeepNoMind.com</a>，一起交流成长。</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=NdVmdJwrPWRb7Z%2F7FbleMA%3D%3D.IlsmY8gdDMEu9QQsKcr18wunv85J0EpScCjmzc3z4Q0%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[拓数派创始人兼CEO冯雷受邀参加《交大安泰校友会AI 应用（智能体）研讨会》，与智谱AI、商汤医疗等]]></title>    <link>https://segmentfault.com/a/1190000047521858</link>    <guid>https://segmentfault.com/a/1190000047521858</guid>    <pubDate>2026-01-05 11:07:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>12月28日，“交大安泰校友会第三届 AI 应用（智能体）研讨会”在沪成功举办，拓数派创始人兼CEO冯雷（Ray Von）受邀出席。本次研讨会以“奔赴智能体新征程·锚定 AI 应用创业新蓝海”为主题，通过多维度深度分享与观点碰撞，全景呈现了AI智能体从基础模型进化到垂直行业落地的无限可能。作为AI领域的重要探索者与实践者，拓数派、智谱AI、商汤医疗等企业代表的参与，让本次研讨会成为展现行业前沿动态与实践成果的重要平台。</p><p>在备受关注的圆桌论坛环节，冯雷与来自智谱AI、极熵科技、上海有元人、普元信息的行业领袖与技术专家们，围绕《如何抓住AI智能体在 2B/2C 行业应用实践商机》这一关键议题展开热烈讨论，碰撞思想火花。各方围绕智能体技术创新、场景落地、生态构建等核心话题展开深入交流，共同探讨AI智能体在产业升级中的核心价值，彰显了头部企业携手推动行业高质量发展的责任与担当。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521860" alt="图片" title="图片"/><br/>圆桌讨论精彩瞬间</p><p>冯雷在分享中传递了对智能体AI市场的坚定信心，预测未来五年智能体企业市场将达万亿级规模。他重点阐述了拓数派大模型数据计算系统（πDataCS）在智能体落地中的核心价值：该系统实现“数据与模型自主耦合”，能够高效打通企业私域数据与大模型的协同链路，向上提供垂类模型和智能体的开发与运维工具，向下支持管理异构数据和算力。在大模型时代推动了AI智能体的百花齐放，助力企业快速打造专属智能体，走完AI落地场景最后一公里。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521861" alt="图片" title="图片" loading="lazy"/><br/>图为：拓数派创始人兼CEO 冯雷</p><p>随着智能体时代的到来，人工智能的发展有效降低开发门槛。由高中生创立的CalAI，仅用4人初始团队便斩获1200万元创收，而平均年龄仅22岁的MercorAI公司，ARR已高达5千万美元；小团队撬动大财富的AI传奇仍在延续，越来越多的年轻人都有机会在AI领域大展身手。冯雷在圆桌讨论中分享了与高中生合作开发智能体的创新经验，用实际案例证明了AI开发门槛的急剧降低。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521862" alt="图片" title="图片" loading="lazy"/><br/>智能体创业团队趋年轻化，小规模化<br/>（来源：Dr.Li Nan report at Ortizpe）</p><p>本次研讨会的成功举办，不仅系统梳理了智能体在行业的实践成果与应用痛点，更清晰展望了其未来演进路径。随着技术不断成熟与场景持续深化，智能体必将更深层次地融入产业核心环节，推动业务流程重构与效率革命。未来，拓数派将继续携手行业伙伴，依托自身数据计算底座优势，赋能更多企业实现数智转型。</p>]]></description></item><item>    <title><![CDATA[从一个开发者成为鸿蒙KOL的历程 三掌柜 ]]></title>    <link>https://segmentfault.com/a/1190000047521866</link>    <guid>https://segmentfault.com/a/1190000047521866</guid>    <pubDate>2026-01-05 11:06:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>前言</h2><blockquote>在2025 年 6 月，东莞松山湖欧洲小镇，华为 HDC 主会场。当华为终端BG董事长余承东在台上喊出“鸿蒙生态设备突破 18 亿”时，坐在观众席的我瞬间觉得很值得。从我2023年12月有幸成为第一批技术社区推荐的“种子选手”，参与鸿蒙生态学堂创新实训营北京站的培训开始，截止到现在，依然凭借一己之力在推动和支持鸿蒙生态的建设。可以说是从当初的普通鸿蒙初学者，一步步蜕变成鸿蒙的布道者，这一路的付出和坚持，只有身临其中，才能感受到是多么的有意义。那么接下来给大家分享一下我的鸿蒙经历，希望能够引来大家的一些共鸣。</blockquote><h2>对于自己来说最厉害的事</h2><p>话题拉回2023年12月，当时鸿蒙技术还是内测版，需要定邀才能参与鸿蒙技术的体验和学习使用。笔者作为技术社区的头部博主，有幸被华为鸿蒙项目组遴选为HarmonyOS Next内测版的内训人员，和其他大厂以及社区推荐的技术博主一道，参与了为期4天的专项培训，我觉得这几天的实训对我个人来讲是有特殊意义的，这不仅是技术专项学习的机会，更是对我个人技术能力的拓展，以及帮我结实更多的志同道合的同行开发者，最重要的是开启了我参与鸿蒙生态的大门。<br/><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdnyIt" alt="image.png" title="image.png"/><br/><img width="723" height="1023" referrerpolicy="no-referrer" src="/img/bVdnyIu" alt="image.png" title="image.png" loading="lazy"/></p><p>有意思的是，在2024年年底的时候，笔者有幸作为鸿蒙生态的分享嘉宾，参与了204鸿蒙生态学堂在上海站的实训，这是鸿蒙官方对我个人的认可和信任，我也是从一个鸿蒙学习使用者蜕变为专业的鸿蒙领域布道者，二者的跨度正好一年时间，非常有纪念意义。<br/><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdnyIF" alt="image.png" title="image.png" loading="lazy"/><br/><img width="723" height="820" referrerpolicy="no-referrer" src="/img/bVdnyIG" alt="image.png" title="image.png" loading="lazy"/></p><h2>关于我成为华为HDE这件事</h2><p>很荣幸我在2024年8月成功申请为华为开发者专家（HDE），申请通过的人数也才30几个，当时的 HDE申请还没有扩招和放宽，所以申请条件非常苛刻，但是我从23年底参与鸿蒙的内训到具体开发使用，在不到8个月的时间内完成了大部分人完成不了的鸿蒙生态推广任务，参与鸿蒙公益行活动，在半年内去了7城办了8场鸿蒙主题的CMeet活动，以及在2024年6月参加了HDC大会上海分会场的分享。也正是这些努力和付出，让我脱颖而出，在同年8月成为了一名华为HDE，对我来说这是一个无上荣耀的时刻，也更加坚定我投入到鸿蒙生态建设的决心和信心。最重要的是，我得到了官方的认可加持之后，在后面的鸿蒙分享中有了底气，再也不怕被业内过早加入的人觉得我不专业。<br/><img width="723" height="539" referrerpolicy="no-referrer" src="/img/bVdnyIT" alt="image.png" title="image.png" loading="lazy"/><br/><img width="723" height="1101" referrerpolicy="no-referrer" src="/img/bVdnyIV" alt="image.png" title="image.png" loading="lazy"/></p><h2>身临HDC主会场，实现自己的意难平</h2><p>其实在2024年的6月HDC大会举办前，自己就在想：如果能去HDC主会场参加活动是多么棒的事情，奈何当时我自己还不是HDE，当时自己在鸿蒙领域的贡献也只是停留在民间活动层面，还没有太大、太突出的贡献，所以止步HDC主会场。好在有幸参与了HDC上海站的分会场活动，也给了我一起参与HDC大会的机会，非常感激。<br/><img width="723" height="410" referrerpolicy="no-referrer" src="/img/bVdnyIW" alt="image.png" title="image.png" loading="lazy"/><br/>随着自己在2024年至今，在鸿蒙领域的持续贡献，让我有幸参与了2025年的HDC大会东莞主会场的系列活动，这也是让我感到无比的荣耀和自豪的事情，终于得到了官方的认可和鼓励，也感谢帮我解决各种问题的华为侧的老师们。接下来我会详细分享一下我参加今年HDC大会的一些真实感受。<br/><img width="723" height="549" referrerpolicy="no-referrer" src="/img/bVdkDCW" alt="image.png" title="image.png" loading="lazy"/><br/>我觉得作为一名开发者，参加华为HDC大会就像是一场朝圣之旅。每年这个时候，全球的开发者们都会汇聚一堂，分享最新的技术成果，探讨未来的趋势，而今年的HDC 2025更是让我期待已久。这次大会不仅有华为最新技术的展示，还有各种实战案例和深度分享，对我来说，这是一次难得的学习和交流机会，更是面基各位好友的最佳机会。<br/><img width="664" height="682" referrerpolicy="no-referrer" src="/img/bVdnyLj" alt="image.png" title="image.png" loading="lazy"/><br/>当我踏入HDC 2025的会场时，那种震撼感扑面而来，只能不断地感慨东莞松山湖华为欧洲小镇是真的美、真的大！整个会场布置得非常现代化，到处都能看到华为的标志和各种高科技展示。大屏幕上滚动播放着华为最新的技术视频，从鸿蒙系统到华为云的各种应用，每一个画面都让人眼前一亮。我迫不及待地领了资料包，里面装满了各种技术文档和纪念品，感觉像是拿到了宝藏。<br/><img width="723" height="536" referrerpolicy="no-referrer" src="/img/bVdnyLk" alt="image.png" title="image.png" loading="lazy"/><br/>会场的布局非常合理，分为多个区域：主论坛区、分论坛区、技术展示区、交流区和休息区，各位参会者穿梭于欧洲小镇的两个区域之中。每个区域都有明确的标识和引导，让人一目了然。技术展示区摆放了各种华为的最新产品和技术，包括华为云的数字人、智能交通系统、智能家居设备等。这些展示不仅让人感受到华为技术的强大，也让人对未来的科技生活充满期待。<br/><img width="723" height="570" referrerpolicy="no-referrer" src="/img/bVdnyLs" alt="image.png" title="image.png" loading="lazy"/><br/>第一天下午的KN，是真的惊艳到我了，以及发布的关于鸿蒙的新特性。在第二天的主论坛上，华为的专家们分享了最新的技术趋势。我印象最深的是鸿蒙系统的最新进展，鸿蒙系统从发布到现在，已经取得了巨大的进步。专家们详细介绍了鸿蒙系统在分布式技术、跨设备协同等方面的优势，还展示了鸿蒙系统在智能家居、智能办公等场景中的实际应用。听着他们的分享，我感觉自己像是站在了技术的前沿，每一个细节都让我兴奋不已。<br/><img width="723" height="767" referrerpolicy="no-referrer" src="/img/bVdkDDg" alt="image.png" title="image.png" loading="lazy"/></p><p>除了主论坛，还有各种分论坛和工作坊。我参加了codelabs，上午半天基本走不掉了，这里的每一个实验都非常值得体验和学习，受益匪浅。<br/><img width="723" height="559" referrerpolicy="no-referrer" src="/img/bVdnyLC" alt="image.png" title="image.png" loading="lazy"/><br/><img width="723" height="470" referrerpolicy="no-referrer" src="/img/bVdnyLD" alt="image.png" title="image.png" loading="lazy"/></p><p>我还参加一个关于华为云开发的分论坛，那里聚集了来自不同行业的开发者，大家围坐在一起，听华为的技术人员讲解如何利用华为云快速开发应用，他们分享了实际的代码示例和开发经验，让我受益匪浅。在后面的圆桌交流环境，大家畅所欲言，我也提了两个实际的问题，在场的华为领导也做了批示和回应。在另一个关于AI技术的分论坛中，专家们分享了华为在AI领域的最新成果。他们介绍了华为云的AI开发平台，包括深度学习框架、自然语言处理工具和图像识别技术。通过实际案例，专家们展示了如何利用这些工具快速构建智能应用。我特别感兴趣的是AI在医疗影像分析中的应用，通过AI算法，可以快速准确地识别病变，提高诊断效率。这让我看到了AI技术在改善人类生活中的巨大潜力。<br/><img width="723" height="451" referrerpolicy="no-referrer" src="/img/bVdnyLE" alt="image.png" title="image.png" loading="lazy"/><br/>我觉得HDC大会不仅是一个学习的平台，也是一个交流和合作的好机会，在这里，我不仅见了好多未曾谋面的“老网友”，也结识了现场许多志同道合的开发者朋友。大家可以互相分享项目经验，讨论技术难题，甚至还交换了联系方式，打算在会后继续合作。甚至在深圳机场返回上海的候机期间，见了没来得及见面的几位“群友”，这种交流让我感到非常兴奋，也让我意识到开发者社区的力量，也让我看到技术交流带来的独有魅力。<br/><img width="723" height="579" referrerpolicy="no-referrer" src="/img/bVdnyLF" alt="image.png" title="image.png" loading="lazy"/><br/>参加完HDC 2025，我满心都是对未来的期待，华为的技术发展速度之快，让我惊叹不已。从鸿蒙系统的不断完善到华为云的强大功能，我看到了华为在技术领域的雄心壮志，我个人觉得这些技术不仅改变了我们的工作方式，也在逐渐改变我们的生活方式。<br/><img width="723" height="329" referrerpolicy="no-referrer" src="/img/bVdnyLG" alt="image.png" title="image.png" loading="lazy"/><br/>当大会结束时，我带着满满的收获离开了会场，虽然大会只有短短几天，但它给我的启发和动力却会持续很长时间。回到工作岗位后，我迫不及待地开始尝试在自己的项目中应用这些新技术，也在谋划接下来的鸿蒙生态建设计划，争取通过自己的的力量来为鸿蒙生态添砖加瓦。<br/><img width="723" height="871" referrerpolicy="no-referrer" src="/img/bVdnyLI" alt="image.png" title="image.png" loading="lazy"/></p><h2>个人之力投身鸿蒙公益推广</h2><p>我作为鸿蒙生态的一员，不仅优先体验了HarmonyOS NEXT版本的内测，而且参与了鸿蒙学堂的培训，并获得了高级认证。在日常技术文章创作中，我也创了很多鸿蒙os相关的文章，而且我参与鸿蒙问答社区的共建，并回答过百条的鸿蒙问题。从此之后我更加坚定的投入到鸿蒙生态的建设中来，而且是不计回报和收益，纯粹做公益的行为，也就促成了我2025年下半年做的个人鸿蒙公益行活动。我个人自负差旅，先后在合肥、南阳、济南、北京、上海、苏州、宁波、重庆、贵阳等城市，举办或参与共10场线下鸿蒙相关的城市站活动，涵盖人数近千人，凭借自己有限的能力把鸿蒙生态尽可能多的下沉到更多的城市，而且我给自己的目标就是把鸿蒙技术带到更多城市，下沉到更偏远的地方。<br/><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdnyLP" alt="image.png" title="image.png" loading="lazy"/><br/>除此之外，在工作中我也实际使用了鸿蒙开发应用，不管是工作的还是工作之外的，我先后主导了3个鸿蒙应用的开发及上架，我觉得只有实际使用才有发言权，才有给别人分享的底气，从不纸上谈兵。同时，我身边也有很多朋友和粉丝找我咨询一些鸿蒙开发相关的问题，我也会尽自己的最大力量去帮助解决，就算有我不懂的，我会找鸿蒙官方的技术老师请教，这也变相的提升了我在鸿蒙技术使用领域的能力，我觉得对我个人开发经验来讲是非常大的帮助和提升。<br/><img width="723" height="483" referrerpolicy="no-referrer" src="/img/bVdnyLQ" alt="image.png" title="image.png" loading="lazy"/><br/>而且我会在每次HarmonyOS线下分享活动中尽最大可能的宣传鸿蒙开发的前景，结合自身的鸿蒙开发心得，让更多的开发者了解鸿蒙、使用鸿蒙、推广鸿蒙。另外，我有着全网不到10万粉丝，每次我在发布文章或者参加鸿蒙活动的时候，都会尽可能多的把相关消息第一时间推送给粉丝们，让大家及时收到鸿蒙相关的内容，我也在通过自身的例子来影响身边的开发者积极参与鸿蒙生态建设，从2023年接触鸿蒙技术到现在，我已经培养了23名鸿蒙相关的布道者，邀请了近百人参与鸿蒙主题的征文活动和问答活动。</p><h2>结束语</h2><p>最后，我个人觉得作为华为鸿蒙的KOL，并且作为一个鸿蒙生态的贡献者，我感到很骄傲和自豪，尤其是我在给大家做分享时候的成就感，也让我坚定要在鸿蒙生态中持续深耕和布道，我也愿凭自己的一己之力撑起来鸿蒙生态的一片天。我觉得自己是“站在鸿蒙生态门口拉门的人”，门缝越开越大，光就照进来。</p>]]></description></item><item>    <title><![CDATA[中小企业全业务精细化管控能力横评：五大CRM品牌的“数据+流程”双引擎对决 傲视众生的脸盆 ]]></title>    <link>https://segmentfault.com/a/1190000047521873</link>    <guid>https://segmentfault.com/a/1190000047521873</guid>    <pubDate>2026-01-05 11:05:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在中小企业数字化转型中，“数据统计分析引擎+业务流程自动化”已成为实现全业务精细化管控的核心双引擎。前者解决“数据不通、分析不透”的决策痛点，后者解决“流程低效、协同不畅”的执行痛点。本文基于<strong>数据连通性、分析深度、流程覆盖、自动化程度、中小企业适配性</strong>五大核心维度，对超兔、Salesforce、钉钉、Microsoft Dynamics 365 CRM、销售易五大品牌的能力进行横向对比，为中小企业选择适配方案提供参考。</p><h2>一、核心逻辑：“数据+流程”双引擎的底层差异</h2><p>中小企业的精细化管控需求，本质是“<strong>数据能打通、分析能落地、流程能自动</strong>”。五大品牌的双引擎设计，因底层定位不同呈现显著差异：</p><ul><li><strong>超兔</strong>：以“全业务模块天然连通”为核心，聚焦制造/工贸场景的“订单-生产-供应链”全链路自动化；</li><li><strong>Salesforce</strong>：以“Customer 360客户数据整合”为核心，侧重销售/营销的决策智能化；</li><li><strong>钉钉</strong>：以“零门槛数据处理”为核心，聚焦电商/项目管理的“数据采集-分析-执行”闭环；</li><li><strong>Microsoft</strong>：以“Office生态融合”为核心，侧重办公与业务流程的无缝衔接；</li><li><strong>销售易</strong>：以“销售全链路闭环”为核心，聚焦医疗/制造的“线索-订单-回款”管控。</li></ul><h2>二、多维度横向对比：谁更适配中小企业？</h2><h3>1. 数据统计分析引擎：从“数据连通”到“价值落地”</h3><p>数据统计分析的核心是“<strong>通、准、用</strong>”——<strong>数据能打通、清洗后准确、分析后能指导决策</strong>。五大品牌的能力差异如下：</p><table><thead><tr><th><strong>维度</strong></th><th><strong>超兔</strong></th><th><strong>Salesforce</strong></th><th><strong>钉钉</strong></th><th><strong>Microsoft</strong></th><th><strong>销售易</strong></th></tr></thead><tbody><tr><td><strong>数据连通性</strong></td><td>全业务模块底层连通（CRM/进销存/财务/生产）</td><td>Customer 360整合（销售/服务/营销）</td><td>跨平台数据抓取（电商评论/多店铺）</td><td>统一客户数据平台（销售/服务/营销）</td><td>全链路数据整合（营销/销售/服务）</td></tr><tr><td><strong>数据质量</strong></td><td>智能清洗（客户查重/工商补全/产品BOM结构化）</td><td>Customer 360自动同步关联</td><td>自动清洗分类（替代3天Excel工作为10分钟）</td><td>与Excel/Outlook实时同步</td><td>全链路数据自动关联（潜客-订单-服务）</td></tr><tr><td><strong>分析深度</strong></td><td>RFM客户细分、超级报表（跨表整合）</td><td>Einstein AI预测（赢单概率/客户留存）</td><td>自然语言生成可视化（如“最近7天曝光趋势”）</td><td>Power BI集成（实时报表/预测分析）</td><td>ChatBI、客户决策链预判（准确率82%）</td></tr><tr><td><strong>易用性</strong></td><td>零代码自定义报表</td><td>自定义仪表盘、Einstein GPT生成结论</td><td>非技术人员可操作（无需SQL）</td><td>与Office深度集成（Excel/PowerPoint）</td><td>移动端实时查看（业绩/漏斗）</td></tr></tbody></table><h3>2. 业务流程自动化：从“人工操作”到“规则驱动”</h3><p>业务流程自动化的核心是“<strong>覆盖全、自动化、易定制</strong>”——流程能覆盖核心场景、无需人工触发、适配业务变化。五大品牌的能力差异如下：</p><h4>（1）流程覆盖与自动化场景</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521875" alt="" title=""/></p><pre><code>flowchart LR
    %% 超兔全链路自动化
    A[超兔：订单确认] --&gt; B[自动生成采购计划（BOM计算原材料）]
    A --&gt; C[库存预警（实时核对库存）]
    A --&gt; D[财务应收单（按节点拆分回款）]
    B --&gt; E[采购单] --&gt; F[库存更新] --&gt; G[生产工单（对接MES）]
    
    %% 钉钉电商场景自动化
    H[钉钉：差评触发] --&gt; I[自动通知质检] --&gt; J[商品下架流程]
    
    %% Salesforce销售流程自动化
    K[Salesforce：线索分配] --&gt; L[智能派单（按区域/行业）] --&gt; M[销售阶段提醒（如“需提交方案”）]
    
    %% Microsoft服务流程自动化
    N[Microsoft：客户工单] --&gt; O[Copilot自动分类] --&gt; P[匹配知识库回复]
    
    %% 销售易销售闭环自动化
    Q[销售易：线索录入] --&gt; R[自动评分（高价值线索派给资深销售）] --&gt; S[订单生成→自动同步企微]</code></pre><h4>（2）核心能力对比</h4><table><thead><tr><th><strong>维度</strong></th><th><strong>超兔</strong></th><th><strong>Salesforce</strong></th><th><strong>钉钉</strong></th><th><strong>Microsoft</strong></th><th><strong>销售易</strong></th></tr></thead><tbody><tr><td><strong>流程覆盖</strong></td><td>全链路（线索-订单-生产-财务）</td><td>销售流程、线索管理</td><td>电商运营、项目管理、行政/客服</td><td>销售/服务/营销模块化</td><td>销售全链路（线索-商机-订单-回款）</td></tr><tr><td><strong>自动化程度</strong></td><td>规则驱动全流程自动触发（BOM/库存/财务）</td><td>智能派单、话术生成、跨系统集成</td><td>RPA+AI联动（差评/项目延期触发流程）</td><td>Copilot辅助文书（邮件/纪要）、智能派单</td><td>销售流程闭环（任务自动分配/进度追踪）</td></tr><tr><td><strong>定制灵活性</strong></td><td>零代码工作流配置（自然语言生成）</td><td>自定义流程/审批、AppExchange（6000+应用）</td><td>自然语言指令生成流程（如“设置项目延期提醒”）</td><td>低代码Power Apps、行业模板（家电/物流）</td><td>PaaS平台三级菜单自定义、字段扩展</td></tr></tbody></table><h3>3. 中小企业适配性：从“成本”到“落地效率”</h3><p>中小企业的核心诉求是“<strong>低成本、快落地、易调整</strong>”——部署无需大量IT投入、定制无需开发、能跟随业务变化迭代。五大品牌的适配性差异如下：</p><table><thead><tr><th><strong>维度</strong></th><th><strong>超兔</strong></th><th><strong>Salesforce</strong></th><th><strong>钉钉</strong></th><th><strong>Microsoft</strong></th><th><strong>销售易</strong></th></tr></thead><tbody><tr><td><strong>部署成本</strong></td><td>轻量化，全模块天然连通（无需额外整合）</td><td>模块化（销售云/服务云按需选）</td><td>零门槛（现有钉钉/企微升级）</td><td>云端/本地（按需部署）</td><td>轻量化（移动端优先）</td></tr><tr><td><strong>定制成本</strong></td><td>零代码（工作流/报表自定义）</td><td>付费定制（或AppExchange付费应用）</td><td>零成本（自然语言配置）</td><td>低代码（Power Apps需学习）</td><td>低代码（PaaS平台自定义，无需IT）</td></tr><tr><td><strong>生态融合</strong></td><td>全模块天然连通（无需集成第三方工具）</td><td>AppExchange（覆盖营销/客服等场景）</td><td>自身生态（企微/钉钉/电商平台）</td><td>Office 365深度集成（Excel/Outlook/Teams）</td><td>企微/钉钉集成（客户数据/沟通记录同步）</td></tr><tr><td><strong>行业聚焦</strong></td><td>工贸、制造（需生产/供应链管控）</td><td>IT、制造（需销售/营销协同）</td><td>电商、项目管理（需跨平台数据/进度监控）</td><td>多行业（家电/物流/外贸，提供预设模板）</td><td>医疗、制造、消费品（需销售全链路管控）</td></tr></tbody></table><h2>三、雷达图综合评分：谁是“性价比之王”？</h2><p>基于<strong>数据连通性、分析深度、流程自动化、定制灵活性、生态融合</strong>五大核心指标（1-5分，5分为最优），五大品牌的综合评分如下：</p><table><thead><tr><th><strong>品牌</strong></th><th><strong>数据连通性</strong></th><th><strong>分析深度</strong></th><th><strong>流程自动化</strong></th><th><strong>定制灵活性</strong></th><th><strong>生态融合</strong></th><th><strong>总分</strong></th></tr></thead><tbody><tr><td>超兔</td><td>5</td><td>4</td><td>4</td><td>4</td><td>4</td><td>21</td></tr><tr><td>Salesforce</td><td>4</td><td>5</td><td>4</td><td>4</td><td>5</td><td>22</td></tr><tr><td>钉钉</td><td>3</td><td>4</td><td>4</td><td>5</td><td>5</td><td>21</td></tr><tr><td>Microsoft Dynamics 365</td><td>4</td><td>5</td><td>3</td><td>4</td><td>5</td><td>21</td></tr><tr><td>销售易</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>20</td></tr></tbody></table><h2>四、结论：不同场景下的最优选择</h2><p>根据中小企业的<strong>行业属性、核心痛点、现有生态</strong>，推荐适配方案：</p><h3>1. 若你是<strong>工贸/制造企业</strong>（需生产/供应链管控）：选超兔</h3><p>超兔的<strong>全业务模块天然连通</strong>（订单-采购-库存-生产-财务）与<strong>规则驱动自动化</strong>（BOM计算采购需求、库存预警、财务应收单拆分），完美匹配制造企业“从订单到交付”的全链路管控需求，且零代码定制成本极低。</p><h3>2. 若你是<strong>电商/项目管理企业</strong>（需跨平台数据与进度监控）：选钉钉</h3><p>钉钉的<strong>跨平台数据抓取</strong>（电商评论/多店铺）、<strong>零门槛可视化</strong>（自然语言生成报表）与<strong>RPA</strong> <strong>+AI流程触发</strong>（差评/项目延期自动处理），能快速解决电商“数据分散、响应慢”的痛点，且无需额外部署成本。</p><h3>3. 若你是<strong>IT/成长型企业</strong>（需销售/营销协同）：选Salesforce</h3><p>Salesforce的<strong>Customer 360客户整合</strong>与<strong>Einstein AI预测</strong>（赢单概率/客户留存），能帮助成长型企业提升销售转化率（减少40%无效跟进），且AppExchange生态可快速扩展功能（如营销自动化、客服机器人）。</p><h3>4. 若你是<strong>Office深度用户</strong>（需办公与业务融合）：选Microsoft</h3><p>Microsoft Dynamics 365 CRM的<strong>Office生态融合</strong>（Excel同步客户数据、Power BI生成报表、Teams协同），能让企业“用熟悉的工具做业务”，无需学习新系统，适合依赖Office办公的多行业中小企业。</p><h3>5. 若你是<strong>医疗/消费品企业</strong>（需销售全链路管控）：选销售易</h3><p>销售易的<strong>销售全链路闭环</strong>（线索-商机-订单-回款）与<strong>ChatBI分析</strong>（客户决策链预判），能帮助医疗/消费品企业提升销售效率（新人成单周期缩短），且企微/钉钉集成满足“移动办公”需求。</p><h2>各系统功能详情如下：</h2><h3>钉钉基于“数据统计分析引擎 + 业务流程自动化”的中小企业全业务精细化管控能力</h3><h4><strong>一、数据统计分析引擎：实现数据全链路智能化处理</strong></h4><ol><li><strong>自动化数据处理</strong>：支持跨平台（如电商评论、多店铺）数据抓取，自动完成数据清洗、分类与实时更新，替代人工Excel汇总工作，将原本3天的工作量缩短至10分钟。</li><li><strong>零门槛</strong> <strong>可视化分析</strong>：通过自然语言指令生成仪表盘、趋势图等可视化内容（如“最近7天曝光率趋势”），非技术人员可快速掌握业务动态。</li><li><strong>智能文本生成</strong>：自动分析关键业务指标并生成结论性内容（如“点击率下降15%，建议优化标题与发送时段”），提升日报等文档的专业性与制作效率。</li></ol><h4><strong>二、</strong> <strong>业务流程自动化</strong> <strong>：推动业务执行全链路提效</strong></h4><ol start="4"><li><strong>RPA</strong> <strong>+AI联动</strong>：配置一次指令后，系统自动执行后续重复性任务（如每日抓取淘宝、抖音等平台的用户评价，当触发差评预警时，自动通知质检人员或触发商品下架流程）。</li><li><strong>流程触发机制</strong>：设置条件后系统自动响应，例如工单响应时间从“几天”缩短至10小时内；需求状态变更时，自动推送通知至相关负责人。</li><li><strong>跨部门协作</strong>：支持多人实时协作与权限管控，数据变动实时同步，避免信息孤岛，实现“一张表管公司”的全业务协同。</li></ol><h4><strong>三、中小企业典型应用场景</strong></h4><p><strong>电商运营</strong>：10分钟完成跨平台评论分析，实时监控店铺评分，触发异常（如差评、评分下降）处理流程。</p><p><strong>项目管理</strong>：自动汇总需求数据、生成开发进度仪表盘，当任务延期时自动提醒相关责任人。</p><p><strong>行政/客服</strong>：搭建报修、工单系统，74.6%的工单可实现当日清零，提升问题响应效率。</p><h4><strong>四、核心价值总结</strong></h4><p>钉钉通过“数据统计分析引擎 + 业务流程自动化”的组合能力，将传统表格升级为智能业务系统，降低中小企业数字化转型门槛，实现从<strong>数据采集、分析到决策执行</strong>的全链路提效，助力企业实现全业务运营的精细化管控与风险防范。</p><h3>Salesforce基于“数据统计分析引擎 + 业务流程自动化”的中小企业全业务精细化管控能力整理</h3><h4><strong>一、数据统计分析引擎：驱动决策智能化</strong></h4><ul><li><strong>全维度数据整合</strong>：通过Customer 360平台整合销售、服务、营销等全渠道数据，构建360°客户视图，消除数据孤岛。</li><li><strong>AI预测与分析</strong>：Einstein AI引擎支持客户行为轨迹分析、赢单概率预测（准确率超85%），并通过Einstein GPT生成个性化建议（如SaaS企业邮件打开率可从12%提升至28%）。</li><li><strong>实时报表与可视化</strong>：提供自定义仪表盘，实时监控销售进度、线索转化、客户留存等关键指标，助力数据驱动决策。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521876" alt="" title="" loading="lazy"/></p><h4><strong>二、</strong> <strong>业务流程自动化</strong> <strong>：提升运营效率</strong></h4><p><strong>销售流程自动化</strong>：支持自定义销售阶段与审批流程，适配小单快单或中长周期订单，减少“无效跟进”达40%；通过智能话术生成缩短新人成单周期。</p><p><strong>线索管理闭环</strong>：整合多渠道获客工具（如展会、邮件营销），实现线索自动分级、培育与分配，提升转化率。</p><p><strong>跨系统集成能力</strong>：与ERP、企微、物流等系统无缝对接，支持订单执行、生产协同等全链路流程自动化，打破部门信息差。</p><h4><strong>三、中小企业适配性</strong></h4><ul><li><strong>轻量化部署</strong>：提供模块化解决方案，支持按需选择销售云、服务云等模块，降低初期投入成本。</li><li><strong>灵活定制</strong>：支持自定义字段、流程与权限，适配不同行业（如IT、制造）的个性化需求。</li><li><strong>生态支持</strong>：通过AppExchange平台提供超6000款第三方应用，覆盖营销、客服等场景，快速扩展功能。</li></ul><p><strong>总结</strong>：Salesforce凭借“数据统计分析引擎 + 业务流程自动化”双引擎，帮助中小企业实现客户管理、销售转化、履约服务的全流程精细化管控，尤其适合需提升决策效率与跨部门协同的成长型企业。</p><h3>超兔基于“数据统计分析引擎+业务流程自动化”的全业务精细化管控能力</h3><h4><strong>一、数据统计分析引擎：全业务数据的连通、规范与深度应用</strong></h4><p><strong>全业务数据底层连通</strong> 覆盖CRM、进销存、财务、生产等全业务模块，数据天然打通且自动同步关联。例如，销售订单确认后，系统会自动触发<strong>采购计划</strong>（基于BOM清单计算原材料需求）、<strong>库存预警</strong>（实时核对现有库存与订单需求）及<strong>财务应收单</strong>（按签约节点拆分回款计划），实现从订单到履约的全链路数据流转，无需额外整合。</p><p><strong>智能数据清洗与结构化</strong></p><p>  <strong>客户数据规范</strong>：录入时自动查重（客户名/手机号模糊匹配）、补全工商信息（如企业注册资本、法定代表人）、识别手机号归属地，确保客户数据的唯一性与准确性。</p><p>  <strong>产品数据结构化</strong>：支持SKU速建、BOM（物料清单）结构化录入，内置成本算法（如先进先出法），从源头让产品数据符合资产化管理标准。</p><p>  <strong>自定义扩展</strong>：提供<strong>自定义业务表</strong>与<strong>多表聚合引擎</strong>，企业可按需添加业务维度（如客户“行业标签”“采购偏好”、产品“批次管理”），贴合自身业务需求而非强制标准化。</p><p><strong>多维度分析与决策支持</strong></p><ul><li><strong>RFM</strong> <strong>客户细分</strong>：从近度（Recency，最近一次消费时间）、频度（Frequency，消费次数）、额度（Monetary，消费金额）三个维度划分客户价值，精准识别“价值客户”（需重点维护）、“挽留客户”（即将流失），辅助企业制定差异化运营策略。</li><li><strong>超级报表引擎</strong>：支持跨业务表整合数据（如订单履约率、采购执行进度、回款及时率），企业可自定义报表模板（如“月度订单分析表”“库存周转率报表”“销售漏斗转化率表”），直观呈现业务现状，辅助数据驱动决策。</li></ul><h4><strong>二、</strong> <strong>业务流程自动化</strong> <strong>：从人工操作到规则驱动的全链路提效</strong></h4><ol><li><p><strong>全流程自动化触发</strong> 实现“线索-客户-订单-生产-财务”全链路的规则驱动自动化：</p><ol><li>订单签约后，自动生成<strong>采购计划</strong>（基于库存缺口计算原材料需求）、<strong>生产工单</strong>（对接MES系统下达生产指令）、<strong>财务应收单</strong>（关联客户信用等级设置回款提醒）；</li><li><strong>复购/流失预警</strong>：系统自动计算客户消费间隔，若超过预设周期（如3个月未复购），则触发销售跟进提醒，降低客户流失率。</li></ol></li><li><p><strong>零代码流程配置</strong> 通过“自定义工作流引擎”“三级菜单配置”“工作台驾驶舱”，企业可按需搭建专属业务流程，无需技术开发。例如：</p><ol><li>某工贸企业配置“标准订单-批发订单-非标订单”差异化流程，将跟单效率提升40%；</li><li>销售团队自定义“工程客户跟进看板”，实时呈现大客户跟进进度，将大客户转化率从18%提升至29%。</li></ol></li><li><p><strong>AI赋能业务执行</strong></p><ol><li><strong>智能跟单助手</strong>：嵌入客户视图，实时分析销售与客户的通话录音，提取“交货期”“安装服务”等需求关键词，推送针对性话术建议（如“本周确认订单可提前3天交付”），帮助销售精准回应客户需求，提升转化率；</li><li><strong>流程节点预警</strong>：基于历史数据设置关键动作提醒（如“发送样品检测报告”“客户信用度低于60分禁止发货”），减少人工疏漏，确保流程合规。</li></ol></li></ol><h4><strong>三、核心价值：中小企业全业务精细化管控的落地效果</strong></h4><p>通过“数据统计分析引擎+业务流程自动化”，超兔帮助中小企业实现：</p><ul><li><strong>效率提升</strong>：订单交付周期缩短20%-35%，库存周转率提升30%，跨部门协作效率提升60%；</li><li><strong>成本优化</strong>：省去多系统整合的时间与费用，客制化成本较外包开发降低60%以上；</li><li><strong>决策升级</strong>：从“经验驱动”转向“数据驱动”，老客户复购占比提升至52%，销售转化率提升15%-29%。</li></ul><p><strong>适用场景</strong>：尤其适配工业、制造、工贸类中小企业（年营收2000万-2亿），解决“销售-生产-供应链”全链路的协同与管控痛点。</p><h3>Microsoft Dynamics 365 CRM基于“数据统计分析引擎 + 业务流程自动化”的中小企业全业务精细化管控能力</h3><h4><strong>一、数据统计分析引擎：构建数据驱动的决策基础</strong></h4><p>Microsoft Dynamics 365 CRM通过<strong>统一数据管理</strong>与<strong>智能分析</strong>，为中小企业提供全业务链的精准洞察：</p><ul><li><strong>统一</strong> <strong>客户数据平台</strong>：集中管理销售、服务、营销等全渠道客户数据，消除数据孤岛，为精细化运营提供整合的信息基础（如整合客户互动记录、订单历史、服务工单等）；</li><li><strong>智能分析与可视化</strong>：内置BI工具（如Power BI集成），支持实时生成报表、数据挖掘与预测分析（如销售趋势、客户需求、区域订单分布等），帮助企业快速识别高价值客户与潜在风险；</li><li><strong>Office生态协同</strong>：与Excel、Outlook等微软办公工具深度集成，数据可直接同步至熟悉的工具中（如销售团队通过Excel跟踪客户动态，用Power BI可视化业务数据），降低分析门槛，提升数据利用效率。</li></ul><h4><strong>二、</strong> <strong>业务流程自动化</strong> <strong>：提升效率与场景适配</strong></h4><p>通过<strong>模块化定制</strong>与<strong>智能自动化</strong>，实现全业务流程的高效运转：</p><p><strong>模块化流程定制</strong>：集销售、营销、客户服务等功能于一体，支持按需选择模块（如初期聚焦销售流程管理，后期扩展至全业务链）；同时支持低代码工具（如Power Apps）自定义业务流程（如非标设备报价单、行业特定工单），适配中小企业业务变化需求；</p><p><strong>智能自动化</strong> <strong>工具</strong>：</p><p>  <strong>销售环节</strong>：Copilot辅助销售人员减少文书任务（如编写邮件回复、提炼客户互动摘要、产品定价信息），AI驱动线索评分、智能派单，提升销售效率；</p><p>  <strong>客户服务环节</strong>：实时AI辅助代理自动处理耗时任务（如案件分类、知识库匹配），快速解决客户问题；</p><p>  <strong>全流程自动化</strong>：覆盖销售（潜在客户管理、销售预测）、服务（工单分配、知识库调用）等环节，实现流程标准化与效率提升；</p><p><strong>跨平台无缝集成</strong>：与Microsoft 365生态（Office、Outlook、Teams）深度联动（如邮件互动自动记录至CRM、会议纪要关联客户档案），实现“办公即运营”的无缝体验，减少跨工具切换成本。</p><h4><strong>三、中小企业全业务场景适配</strong></h4><p>针对中小企业特点，提供<strong>轻量级、可扩展、行业化</strong>的解决方案：</p><ol><li><strong>轻量级部署与扩展</strong>：支持云端或本地部署，按需选择模块，快速上线（如初期仅部署销售模块，后期扩展至ERP功能），打破数据孤岛，适配从单部门到全业务链的管控需求；</li><li><strong>行业化模板快速落地</strong>：提供家电、物流、外贸、医药、制造等行业预设流程模板（如制造行业“订单-生产-交付”协同流程、医疗行业“患者档案-随访”模块），缩短上线周期，降低定制成本；</li><li><strong>合规与安全保障</strong>：符合全球数据标准（如GDPR），多区域数据中心存储，保障客户信息安全，适配跨国业务与本土运营的双重合规要求，降低企业数据风险。</li></ol><p>综上，Microsoft Dynamics 365 CRM通过“数据统计分析引擎”实现数据驱动决策，“业务流程自动化”提升运营效率，结合中小企业的轻量级、行业化需求，最终实现全业务运营的精细化管控。</p><h3>销售易基于“数据统计分析引擎 + 业务流程自动化”，为中小企业提供全业务运营精细化管控的核心能力如下：</h3><h4><strong>一、数据统计分析引擎：驱动决策智能化</strong></h4><p><strong>全链路数据整合</strong>：打通营销、销售、服务全流程数据，形成统一客户视图，支持多维度分析（如潜客来源、销售漏斗转化率、客户复购率等），实现业务数据的集中管理与可视化呈现。</p><p><strong>AI增强分析能力</strong>：通过ChatBI可视化分析、智能客户推荐等功能，自动生成业绩报表，预判客户决策链关键人（准确率达82%），帮助管理层实时掌握业务动态，快速聚焦高价值策略调整。</p><h4><strong>二、</strong> <strong>业务流程自动化</strong> <strong>：提升运营效率</strong></h4><p><strong>销售流程标准化闭环</strong>：覆盖“线索→商机→订单→回款”全销售链路，支持自定义销售漏斗阶段与任务模板，减少人工重复操作，实现销售过程的可追踪、可管控。</p><p><strong>跨系统协同自动化</strong>：深度集成企业微信、钉钉等办公工具，实现客户数据、沟通记录的实时同步；支持合同在线审批、外勤拜访记录自动上传，打破数据孤岛，提升跨部门协作效率。</p><h4><strong>三、中小企业适配能力：轻量化与灵活性</strong></h4><p><strong>低成本个性化配置</strong>：通过PaaS平台支持三级菜单自定义、字段扩展，中小企业可快速适配自身业务需求，无需大量IT投入。</p><p><strong>移动化实时管控</strong>：移动端支持客户拜访签到、位置打卡、业绩排行榜等功能，解决销售团队分散管理难题，实现业务进度的实时追踪与数据沉淀。</p><p>综上，销售易通过“数据驱动决策 + 流程自动化”的组合能力，帮助中小企业实现从“工具替换”到“流程标准化”再到“数据驱动决策”的数字化升级，适配医疗、制造、消费品等多行业场景。</p>]]></description></item><item>    <title><![CDATA[HarmonyOS ArkTS 组件进阶 - Shape 自学指南 李游Leo ]]></title>    <link>https://segmentfault.com/a/1190000047521889</link>    <guid>https://segmentfault.com/a/1190000047521889</guid>    <pubDate>2026-01-05 11:05:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>1. Shape 组件概述</h2><p><code>Shape</code> 组件是 ArkUI 提供的 <strong>绘制容器</strong>，它用于管理和绘制所有形状组件，如 <strong>矩形、椭圆、路径、折线等</strong>。在 <code>Shape</code> 组件内，其他图形（如 <code>Rect</code>、<code>Ellipse</code>、<code>Path</code>）会根据定义的坐标、样式、颜色等信息被渲染出来。</p><p><code>Shape</code> 的作用：</p><ul><li>作为父容器，包含其他图形组件；</li><li>支持自定义视口，可以限制绘制区域；</li><li>支持各种通用属性，如填充颜色、边框、透明度等；</li><li>可动态调整各种属性，例如：<strong>填充颜色、透明度、边框样式、抗锯齿等</strong>。</li></ul><p>支持的图形包括：<code>Rect</code>、<code>Ellipse</code>、<code>Circle</code>、<code>Polyline</code>、<code>Polygon</code>、<code>Path</code> 等。</p><h3>组件支持版本</h3><ul><li>从 <strong>API version 7</strong> 开始支持；</li><li>从 <strong>API version 9</strong> 开始支持在 ArkTS 卡片中使用；</li><li>从 <strong>API version 11</strong> 开始支持元服务 API。</li></ul><hr/><h2>2. Shape 组件的基本用法</h2><h3>2.1 创建一个简单的 <code>Shape</code> 组件</h3><p><img width="723" height="443" referrerpolicy="no-referrer" src="/img/bVdnyLX" alt="image.png" title="image.png"/></p><p><code>Shape</code> 本身并不直接绘制图形，它需要包含其他图形组件。以下示例创建一个包含矩形和椭圆的 <code>Shape</code>。</p><pre><code class="ts">// xxx.ets
@Entry
@Component
struct ShapeExample {
  build() {
    Column({ space: 10 }) {
      // 创建一个 Shape 容器，包含矩形和椭圆
      Shape() {
        Rect().width(300).height(50)  // 绘制矩形
        Ellipse().width(300).height(50).offset({ x: 0, y: 60 })  // 绘制椭圆
      }
      .width(350)
      .height(140)
      .viewPort({ x: 0, y: 0, width: 320, height: 130 })
      .fill(0x317AF7)  // 填充颜色
      .stroke(Color.Black)  // 边框颜色
      .strokeWidth(4)  // 边框宽度
      .strokeDashArray([20])  // 边框虚线
      .strokeDashOffset(10)  // 边框虚线偏移
      .strokeLineCap(LineCapStyle.Round)  // 边框两端圆角
      .strokeLineJoin(LineJoinStyle.Round)  // 边框拐角圆角
      .antiAlias(true)  // 开启抗锯齿
    }
  }
}</code></pre><h3>2.2 <code>Shape</code> 的常用属性</h3><h4>2.2.1 viewPort</h4><p><code>viewPort</code> 用来定义图形的显示区域。它可以用来控制整个绘图区域的坐标、宽度和高度。</p><pre><code class="ts">viewPort({ x: 0, y: 0, width: 320, height: 130 })</code></pre><ul><li><code>x</code>：视口的水平偏移量；</li><li><code>y</code>：视口的垂直偏移量；</li><li><code>width</code>：视口的宽度；</li><li><code>height</code>：视口的高度。</li></ul><h4>2.2.2 fill &amp; fillOpacity</h4><p>用于设置形状的填充颜色和透明度。</p><pre><code class="ts">fill(0x317AF7)  // 填充颜色
fillOpacity(0.5)  // 填充透明度，范围 [0.0, 1.0]</code></pre><ul><li><code>fill</code>：填充颜色；</li><li><code>fillOpacity</code>：填充透明度，默认值为 1.0。</li></ul><h4>2.2.3 stroke &amp; strokeWidth</h4><p>用于设置形状的边框颜色和宽度。</p><pre><code class="ts">stroke(Color.Black)  // 边框颜色
strokeWidth(4)  // 边框宽度</code></pre><ul><li><code>stroke</code>：边框颜色；</li><li><code>strokeWidth</code>：边框宽度，默认值为 1。</li></ul><h4>2.2.4 strokeDashArray &amp; strokeDashOffset</h4><p>用于设置虚线的样式。</p><pre><code class="ts">strokeDashArray([20])  // 边框虚线样式
strokeDashOffset(10)  // 虚线的偏移量</code></pre><ul><li><code>strokeDashArray</code>：定义虚线的线段长度和间隙长度；</li><li><code>strokeDashOffset</code>：设置虚线的起点偏移量。</li></ul><h4>2.2.5 strokeLineCap &amp; strokeLineJoin</h4><p>用于设置边框端点和连接处的样式。</p><pre><code class="ts">strokeLineCap(LineCapStyle.Round)  // 边框两端样式
strokeLineJoin(LineJoinStyle.Round)  // 边框连接处样式</code></pre><ul><li><code>strokeLineCap</code>：设置线条端点样式（例如 <code>Round</code> 圆形端点）；</li><li><code>strokeLineJoin</code>：设置线条连接处的样式（例如 <code>Round</code> 圆角连接）。</li></ul><hr/><h2>3. 使用 <code>Shape</code> 绘制复杂图形</h2><h3>3.1 绘制矩形、椭圆和路径</h3><p>通过将 <code>Shape</code> 作为容器，可以绘制矩形、椭圆、路径等不同图形：</p><pre><code class="ts">@Entry
@Component
struct ShapeComplexExample {
  build() {
    Column({ space: 10 }) {
      // 绘制矩形、椭圆和路径
      Shape() {
        Rect().width(300).height(50)  // 矩形
        Ellipse().width(300).height(50).offset({ x: 0, y: 60 })  // 椭圆
        Path().width(300).height(10).commands('M0 0 L900 0').offset({ x: 0, y: 120 })  // 路径
      }
      .width(350)
      .height(140)
      .viewPort({ x: -2, y: -2, width: 304, height: 130 })
      .fill(0x317AF7)  // 填充颜色
      .stroke(Color.Black)  // 边框颜色
      .strokeWidth(4)  // 边框宽度
      .strokeDashArray([20])  // 虚线
      .strokeDashOffset(10)  // 虚线偏移
      .strokeLineCap(LineCapStyle.Round)  // 圆头
      .strokeLineJoin(LineJoinStyle.Round)  // 圆角
      .antiAlias(true)  // 开启抗锯齿
    }
  }
}</code></pre><h3>3.2 使用不同参数类型绘制图形</h3><p>你可以使用不同的数据类型（如数字、字符串、资源）来定义图形的属性。</p><p><img width="723" height="293" referrerpolicy="no-referrer" src="/img/bVdnyL3" alt="image.png" title="image.png" loading="lazy"/></p><pre><code class="ts">@Entry
@Component
struct ShapeTypeExample {
  build() {
    Column({ space: 10 }) {
      Shape() {
        Rect().width('300').height('50')  // 使用字符串类型
        Ellipse().width(300).height(50).offset({ x: 0, y: 60 })  // 使用数字类型
        Path().width(300).height(10).commands('M0 0 L900 0').offset({ x: 0, y: 120 })  // 使用数字类型
      }
      .width(350)
      .height(140)
      .viewPort({
        x: '-2', // 使用字符串类型
        y: '-2',
        width: "200",
        height: "200"
      })
      .fill(Color.Orange)
      .stroke(Color.Black)
      .strokeWidth(4)
      .strokeDashArray([20])
      .strokeDashOffset(10) // 使用数字类型
      .strokeLineCap(LineCapStyle.Round)
      .strokeLineJoin(LineJoinStyle.Round)
      .strokeMiterLimit(5)
      .antiAlias(true)
    }.width('100%').margin({ top: 15 })
  }
}</code></pre><h3>3.3 使用 <code>attributeModifier</code> 动态设置属性</h3><p><code>attributeModifier</code> 允许你动态更新图形的属性，使其更加灵活。</p><p><img width="723" height="283" referrerpolicy="no-referrer" src="/img/bVdnyL5" alt="image.png" title="image.png" loading="lazy"/></p><pre><code class="ts">class MyShapeModifier implements AttributeModifier&lt;ShapeAttribute&gt; {
  applyNormalAttribute(instance: ShapeAttribute): void {
    instance.fill("#707070")
    instance.fillOpacity(0.5)
    instance.stroke("#2787D9")
    instance.strokeDashArray([20, 15])
    instance.strokeDashOffset("15")
    instance.strokeLineCap(LineCapStyle.Round)
    instance.strokeLineJoin(LineJoinStyle.Miter)
    instance.strokeMiterLimit(5)
    instance.strokeOpacity(0.5)
    instance.strokeWidth(10)
    instance.antiAlias(true)
  }
}

@Entry
@Component
struct ShapeModifierDemo {
  @State modifier: MyShapeModifier = new MyShapeModifier()

  build() {
    Column() {
      Shape() {
        Rect().width(200).height(50).offset({ x: 20, y: 20 })
        Ellipse().width(200).height(50).offset({ x: 20, y: 80 })
        Path().width(200).height(10).commands('M0 0 L900 0').offset({ x: 20, y: 160 })
      }
      .width(250).height(200)
      .attributeModifier(this.modifier)
    }
  }
}</code></pre><hr/><h2>4. 高级特性：图形扭曲</h2><p><code>Shape</code> 组件还支持 <code>mesh</code> 属性，它可以对图像进行 <strong>局部扭曲</strong>，实现类似于 CSS 的“网格扭曲”效果。</p><p><img width="723" height="297" referrerpolicy="no-referrer" src="/img/bVdnyL6" alt="image.png" title="image.png" loading="lazy"/></p><pre><code class="ts">@Entry
@Component
struct MeshExample {
  private meshArray: Array&lt;number&gt; = [0, 0, 50, 0, 410, 0, 0, 180, 50, 180, 410, 180, 0, 360, 50, 360, 410, 360]

  build() {
    Column() {
      Shape()
        .mesh(this.meshArray, 2, 2)
        .width(250)
        .height(250)
        .backgroundColor(Color.Gray)
    }
  }
}</code></pre>]]></description></item><item>    <title><![CDATA[从列表勾选到文档合并：JVS低代码实现批量打印的完整链路详解 软件部长 ]]></title>    <link>https://segmentfault.com/a/1190000047521904</link>    <guid>https://segmentfault.com/a/1190000047521904</guid>    <pubDate>2026-01-05 11:04:26</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在日常业务系统中，我们经常遇到需要制作合并单元格的复杂列表页，并实现导出打印功能。<br/>这不，昨天在自家群看到有个用户在问JVS低代码能不能实现合并单元格的列表页制作和导出打印。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521906" alt="图片" title="图片"/><br/>用户的需求表格示例：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521907" alt="图片" title="图片" loading="lazy"/><br/>下面我详细说一说这种是如何实现的<br/>这种需求可以通过列表页行内按钮配置结合逻辑引擎实现。在逻辑中配置模板替换列表页上预览或者下载。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521908" alt="图片" title="图片" loading="lazy"/></p><h2>配置步骤</h2><p><strong>1、设置模板文档</strong><br/>输出docx文档格式模板，参数名必须同逻辑引擎文档模板替换节点的参数名一致。直接设置标签变量格式：${}<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521909" alt="图片" title="图片" loading="lazy"/><br/>输出xlsx格式的文档模板设置规则：<br/>在单元格处设置转换标签变量使用${}<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521910" alt="图片" title="图片" loading="lazy"/><br/>读取整个表格组件中的数据使用${对象名称.字段名}<br/>注意：传值的时候是数组对象结构 XXX:[{aa:aa,bb:bb}]，这样excel里面的xxx.aa才取得到，如下图${tb.gs}，tb是表格组件的字段名，gs是表格里面的字段名<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521911" alt="图片" title="图片" loading="lazy"/><br/><strong>2、上传模板至后台</strong><br/>将做好的模板文件上传到后台文件管理中（支持xlsx、docx和pdf格式）<br/>管理员登录系统进入管理后台-文件管理点击【上传文件】，输入桶名和标签，并将设置好的文档模板上传并点击【提交】。<br/>上传到文件服务器后，拿到文件地址。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521912" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521913" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521914" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521915" alt="图片" title="图片" loading="lazy"/><br/><strong>3、列表页设计</strong><br/>将列表页中每行数据填充至模板，在列表页设计中添加行内按钮触发逻辑，也可以直接在逻辑中直接查询出数据填充赋值到模板<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521916" alt="图片" title="图片" loading="lazy"/><br/><strong>4、逻辑设计</strong><br/>进入逻辑设计器中，拖取文档模板替换组件。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521917" alt="图片" title="图片" loading="lazy"/><br/>①：模板文件链接地址，粘贴文件管理中复制的链接地址。<br/>②：参数名，参数名必须与文件模板中的参数名一致。<br/>③：参数值，文件模板上参数名对应的参数值，可以取字段、具体值、公式等赋值。<br/>表格字段名如下图<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521918" alt="图片" title="图片" loading="lazy"/><br/>当赋值表格字段时，需要先获取表格对象，如下图<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521919" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521920" alt="图片" title="图片" loading="lazy"/><br/>然后对表格对象赋值，参数名填表格组件对应字段名<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521921" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521922" alt="图片" title="图片" loading="lazy"/><br/>如果是表单其他字段则直接赋值，如下图<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521923" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521924" alt="图片" title="图片" loading="lazy"/><br/>④：文件名，不包含后缀，指下载显示的文件名称。<br/>⑤：输出文件格式，指将模板内容转换后输出对应格式的文档，支持xlsx和docx和pdf。<br/>最后执行结果输出替换后的文件的地址、文件名、文件大小等数据，如下图<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521925" alt="图片" title="图片" loading="lazy"/><br/>JVS低代码的最后实现效果<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521926" alt="图片" title="图片" loading="lazy"/><br/>在线demo：<a href="https://link.segmentfault.com/?enc=gQWP4e70rqviGL%2F1lg2ZrA%3D%3D.Hd6DWwL4XZ3PDl9xWqptSEob6TJX7INzut%2FeXvlqQ1A%3D" rel="nofollow" target="_blank">https://app.bctools.cn</a><br/>基础框架开源地址：<a href="https://link.segmentfault.com/?enc=BBBQdI1O53k%2FDCfajsBtmA%3D%3D.2qGFo2nDgy7YHLdwsvCFNFXz9lNHRq19eW9Et%2F%2FKriBhQF7coIu02NfFS4Qqm%2Fvz" rel="nofollow" target="_blank">https://gitee.com/software-minister/jvs</a></p>]]></description></item><item>    <title><![CDATA[2025五大CRM品牌推荐：企业级核心能力深度对比 晨曦钥匙扣 ]]></title>    <link>https://segmentfault.com/a/1190000047521942</link>    <guid>https://segmentfault.com/a/1190000047521942</guid>    <pubDate>2026-01-05 11:03:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>2025五大CRM品牌推荐：企业级核心能力深度对比</h2><p>在数字化转型浪潮中，客户关系管理（CRM）已成为企业连接客户、优化流程、驱动增长的核心引擎。不同规模、行业的企业对CRM的需求差异显著——成长型企业关注低成本客制化与外勤效率，大型企业侧重全球协同与复杂流程，而营销驱动型企业则依赖多渠道整合与AI自动化。</p><p>本文选取<strong>超兔一体云、Salesforce、Zoho、</strong> <strong>SAP</strong> <strong>、HubSpot</strong> <strong>CRM</strong>五大主流CRM品牌，从<strong>客户</strong> <strong>全生命周期管理</strong> <strong>、销售流程自动化、</strong> <strong>数据分析</strong> <strong>与报表、移动端支持、自定义与扩展性</strong>五大维度展开深度对比，为企业选型提供决策参考。</p><h3>一、核心维度1：客户全生命周期管理——从获客到复购的闭环能力</h3><p>客户全生命周期管理（CLM）的核心是<strong>整合多渠道数据，实现“获客-跟进-合约-售后”的全链路可控</strong>，最终提升客户留存与LTV（客户终身价值）。</p><h4>1.1 各品牌能力拆解</h4><table><thead><tr><th>品牌</th><th>获客能力</th><th>线索管理</th><th>客户跟进</th><th>合约执行</th><th>售后管理</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>多渠道获客（百度/抖音/官网/工商搜客）+ 表单验证码验证线索真实性</td><td>一键处理（加客户/待办/订单）+ 手机号/IP归属地分配</td><td>三一客模型（定性/定级/定量）+ 五大跟单法（客户/机会/项目/组织/配置单）</td><td>多类型合约（服务/贸易/非标/租赁）+ 全流程（采购-入库-发货-收款-开票）</td><td>RFM分层+外勤工单（定位/派单/跟踪）+ 智能复购推荐</td></tr><tr><td><strong>Salesforce</strong></td><td>全球多触点（营销云+销售云）+ 本地化适配（如中国区支持微信）</td><td>Einstein AI线索评分+自动分配</td><td>销售云统一客户视图+ 历史跟进轨迹</td><td>合同管理+ 与ERP集成的订单执行</td><td>服务云（售后支持）+ Einstein AI流失预测</td></tr><tr><td><strong>Zoho</strong></td><td>多渠道沟通（邮件/电话/社交/实时聊天）+ 社交数据整合</td><td>Zia AI过滤高价值线索+ 自动分配</td><td>360°客户视图+ 行为分析（如网页访问/邮件打开）</td><td>订单管理+ 发票集成</td><td>服务云+ 客户关怀（生日提醒/权益发放）</td></tr><tr><td><strong>SAP</strong></td><td>跨国多触点（PLM研发+销售Cloud）+ 物联网数据整合</td><td>AI预测客户流失+ 线索优先级排序</td><td>销售Cloud+ 多维度跟进（如报价历史/互动频率）</td><td>S/4HANA集成+ 报价/合同自动化</td><td>EMS权益管理+ 售后跟踪（如设备维保）</td></tr><tr><td><strong>HubSpot</strong></td><td>内容营销（博客/白皮书/表单）+ 社交获客</td><td>自动分配+ 线索评分（基于互动行为）</td><td>客户视图+ 互动轨迹（如邮件点击/网页停留）</td><td>订单跟踪+ 发票集成</td><td>客户留存（复购提醒）+ 忠诚度管理</td></tr></tbody></table><h4>1.2 关键差异与优势</h4><ul><li><strong>超兔</strong>：聚焦<strong>线下场景</strong>，通过“三一客”模型（定性：有价值/无价值；定级：大单/正常/小单；定量：金额/时间）快速识别高价值客户，结合外勤工单解决线下售后痛点。</li><li><strong>Salesforce</strong>：<strong>全球本地化</strong>能力突出，支持多语言/多币种，Einstein AI可预测客户流失，适合跨国企业。</li><li><strong>Zoho</strong>：<strong>多渠道整合</strong>能力强，覆盖微信/抖音等社交平台，Zia AI可自动过滤无效线索，适合外贸或SaaS企业。</li><li><strong>SAP</strong>：<strong>制造行业适配</strong>，集成PLM（产品生命周期管理）与S/4HANA ERP，解决“研发-销售-售后”的全链路协同。</li></ul><h4>1.3 流程可视化（Mermaid流程图）</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521944" alt="" title=""/></p><h3>二、核心维度2：销售流程自动化——从重复劳动到AI驱动</h3><p>销售流程自动化的目标是<strong>减少人工干预，提升转化效率</strong>，核心能力包括流程自定义、智能提醒、AI驱动的决策支持。</p><h4>2.1 各品牌能力拆解</h4><table><thead><tr><th>品牌</th><th>流程自定义</th><th>智能提醒</th><th>AI驱动功能</th><th>生态集成</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>OMS/SRM/MES集成（订单/采购/生产自动化）</td><td>待办提醒+ 通话随记+ 复购预警</td><td>智能采购（SRM匹配供应商+ 比价）+ 生产排程（MES）</td><td>与用友/金蝶ERP对接+ 电商RPA</td></tr><tr><td><strong>Salesforce</strong></td><td>Flow Builder低代码流程设计</td><td>Einstein AI跟进提醒+ 机会到期预警</td><td>销售预测+ 客户流失预警</td><td>AppExchange（1000+插件）+ 钉钉/企业微信</td></tr><tr><td><strong>Zoho</strong></td><td>搭积木式自定义（模块/字段/工作流）</td><td>Zia AI跟进建议+ 邮件提醒</td><td>营销自动化（邮件/社交）+ 销售预测</td><td>Gmail/Google Calendar+ 钉钉</td></tr><tr><td><strong>SAP</strong></td><td>S/4HANA集成流程（报价/订单/收款）</td><td>报价审批提醒+ 订单延期预警</td><td>收入管理（BRIM）+ 智能报价</td><td>BTP平台+ 物联网设备</td></tr><tr><td><strong>HubSpot</strong></td><td>基础流程自定义（线索分配/邮件）</td><td>3天未跟进提醒+ 邮件打开通知</td><td>线索评分+ 邮件跟踪</td><td>营销工具（Mailchimp/Google Ads）+ 电商</td></tr></tbody></table><h4>2.2 关键差异与优势</h4><ul><li><strong>超兔</strong>：<strong>业财产一体化</strong>是核心优势，OMS（订单）+ SRM（供应商）+ MES（生产）集成，解决“销售-采购-生产”的闭环自动化，适合制造或贸易企业。</li><li><strong>Salesforce</strong>：<strong>低代码灵活性</strong>强，Flow Builder可自定义复杂流程（如跨部门审批），Einstein AI能预测销售业绩，适合大型企业。</li><li><strong>Zoho</strong>：<strong>营销自动化</strong>能力突出，支持邮件/社交/活动的全流程自动化，Zia AI可自动生成跟进邮件，适合依赖营销获客的企业。</li></ul><h3>三、核心维度3：数据分析与报表——从数据到决策的智能转化</h3><p>数据分析的核心是<strong>将业务数据转化为可行动的洞察</strong>，关键能力包括BI工具、AI分析、自定义报表。</p><h4>3.1 各品牌能力拆解</h4><table><thead><tr><th>品牌</th><th>BI工具</th><th>AI分析</th><th>自定义报表</th><th>实时性</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>数字卡片+ 多表聚合引擎</td><td>同比环比分析+ 流失预警</td><td>自定义工作台（多岗位数据大屏）</td><td>单日KPI实时监控</td></tr><tr><td><strong>Salesforce</strong></td><td>Einstein Analytics</td><td>销售预测+ 客户行为洞察</td><td>动态仪表盘+ 70+预构建报表</td><td>实时数据同步</td></tr><tr><td><strong>Zoho</strong></td><td>BI商业智能工具</td><td>Zia AI预测销售异常+ 客户流失</td><td>零代码报表生成+ 可视化仪表盘</td><td>实时数据更新</td></tr><tr><td><strong>SAP</strong></td><td>BTP平台（数据+分析+AI）</td><td>实时智能（如订单延迟预警）</td><td>多维度报表（销售/财务/生产）</td><td>物联网数据实时整合</td></tr><tr><td><strong>HubSpot</strong></td><td>内置BI工具</td><td>客户行为分析+ 漏斗转化率</td><td>自定义可视化报表+ 销售趋势</td><td>准实时数据</td></tr></tbody></table><h4>3.2 关键差异与优势</h4><ul><li><strong>超兔</strong>：<strong>轻量化数据分析</strong>适合中小团队，数字卡片与多表聚合引擎可快速生成“销售业绩-客户分布-库存”的关联分析，无需专业BI人员。</li><li><strong>Salesforce</strong>：<strong>AI深度分析</strong>是核心，Einstein Analytics能整合销售/服务/营销数据，预测未来3个月的销售额，适合大型企业的战略决策。</li><li><strong>SAP</strong>：<strong>制造场景适配</strong>，BTP平台整合物联网数据（如设备运行状态），可实时预警生产延迟对订单的影响。</li></ul><h3>四、核心维度4：移动端支持——从桌面到移动的全场景覆盖</h3><p>移动端的核心需求是<strong>满足移动办公，覆盖外勤/出差场景</strong>，关键能力包括功能覆盖、离线操作、生态整合。</p><h4>4.1 各品牌能力拆解</h4><table><thead><tr><th>品牌</th><th>功能覆盖</th><th>离线能力</th><th>生态整合</th><th>外勤适配</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>BOSS首屏（目标汇总/销售数据）+ Sales首屏（核心业务/智能回访）</td><td>支持离线签到/跟进记录</td><td>虎客名片+ QA武器库+ RFM分析</td><td>考勤签到（500米内客户）+ 出差工单</td></tr><tr><td><strong>Salesforce</strong></td><td>客户管理+ 订单处理+ 聊天（Chatter）</td><td>支持离线修改客户信息</td><td>钉钉/企业微信+ 邮件集成</td><td>位置定位+ 客户拜访记录</td></tr><tr><td><strong>Zoho</strong></td><td>客户/线索/订单管理+ 邮件</td><td>离线同步数据（上线后自动更新）</td><td>微信/钉钉+ Google Calendar</td><td>语音输入+ 照片上传</td></tr><tr><td><strong>SAP</strong></td><td>客户查询+ 订单跟踪+ NLP语音</td><td>支持离线访问</td><td>全渠道同步（官网/门店/社交）</td><td>位置签到+ 设备维保</td></tr><tr><td><strong>HubSpot</strong></td><td>基础客户管理+ 邮件</td><td>无离线功能</td><td>微信/钉钉+ 营销工具</td><td>简单客户记录</td></tr></tbody></table><h4>4.2 关键差异与优势</h4><ul><li><strong>超兔</strong>：<strong>外勤场景深度优化</strong>，App分“BOSS首屏”（看数据）与“Sales首屏”（做业务），支持500米内客户签到，解决线下团队的考勤与跟进痛点。</li><li><strong>Salesforce</strong>：<strong>企业社交协作</strong>能力强，Chatter工具可实时共享客户信息，适合跨部门协作的大型团队。</li><li><strong>Zoho</strong>：<strong>多语言支持</strong>，原生App覆盖Android/iOS，适合外贸企业的全球团队。</li></ul><h3>五、核心维度5：自定义与扩展性——从标准化到个性化的适配</h3><p>自定义与扩展性决定了CRM能否<strong>适应企业业务变化</strong>，关键能力包括客制化引擎、集成能力、低代码/开源。</p><h4>5.1 各品牌能力拆解</h4><table><thead><tr><th>品牌</th><th>客制化引擎</th><th>集成能力</th><th>低代码/开源</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>低成本客制化（功能白名单+ 自定义菜单）</td><td>API接口+ RPA机器人（对接ERP/电商）</td><td>无开源+ 低代码配置</td><td>成长型企业+ 线下团队</td></tr><tr><td><strong>Salesforce</strong></td><td>AppExchange插件+ 复杂权限管理</td><td>开放API+ 与用友/金蝶对接</td><td>低代码（Flow Builder）+ 无开源</td><td>大型企业+ 复杂流程</td></tr><tr><td><strong>Zoho</strong></td><td>搭积木式自定义（模块/字段/工作流）</td><td>API接口+ 与微信/钉钉对接</td><td>低代码+ 无开源</td><td>中小企业+ 营销自动化</td></tr><tr><td><strong>SAP</strong></td><td>BTP平台（开放API+ 跨国定制）</td><td>与S/4HANA ERP深度集成</td><td>低代码+ 无开源</td><td>制造/跨国企业</td></tr><tr><td><strong>HubSpot</strong></td><td>基础字段/视图自定义</td><td>API接口+ 营销工具集成</td><td>低代码+ 无开源</td><td>中小营销团队</td></tr></tbody></table><h4>5.2 关键差异与优势</h4><ul><li><strong>超兔</strong>：<strong>低成本客制化</strong>是核心，功能白名单订阅可降低使用费，RPA机器人可对接电商/ERP，适合预算有限的成长型企业。</li><li><strong>Salesforce</strong>：<strong>生态丰富度</strong>第一，AppExchange有1000+插件，支持复杂权限管理（如不同地区的客户数据隔离），适合大型企业。</li><li><strong>Zoho</strong>：<strong>低代码自定义</strong>适合中小团队，“搭积木”式配置可快速调整业务流程（如新增“客户偏好”字段），无需技术人员。</li></ul><h3>六、综合对比与选型建议</h3><h4>6.1 雷达图评分（满分10分）</h4><table><thead><tr><th>维度</th><th>超兔</th><th>Salesforce</th><th>Zoho</th><th>SAP</th><th>HubSpot</th></tr></thead><tbody><tr><td>客户全生命周期管理</td><td>9</td><td>10</td><td>8</td><td>9</td><td>7</td></tr><tr><td>销售流程自动化</td><td>8</td><td>9</td><td>9</td><td>8</td><td>7</td></tr><tr><td>数据分析与报表</td><td>8</td><td>10</td><td>9</td><td>9</td><td>8</td></tr><tr><td>移动端支持</td><td>9</td><td>8</td><td>8</td><td>7</td><td>6</td></tr><tr><td>自定义与扩展性</td><td>9</td><td>10</td><td>9</td><td>8</td><td>7</td></tr></tbody></table><h4>6.2 适用场景总结</h4><table><thead><tr><th>品牌</th><th>适用企业类型</th><th>核心需求匹配</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>成长型企业、线下团队（快消/地推）、业财一体化需求</td><td>外勤管理、低成本客制化、多渠道获客</td></tr><tr><td><strong>Salesforce</strong></td><td>大型跨国企业、复杂流程需求、全球本地化</td><td>全球协同、AI驱动决策、复杂权限管理</td></tr><tr><td><strong>Zoho</strong></td><td>中小企业、营销自动化需求、多渠道获客</td><td>社交整合、低代码自定义、营销自动化</td></tr><tr><td><strong>SAP</strong></td><td>制造企业、跨国企业、ERP集成需求</td><td>研发-销售-生产闭环、收入管理、物联网整合</td></tr><tr><td><strong>HubSpot</strong></td><td>内容驱动型企业（科技/咨询）、中小营销团队</td><td>内容获客、基础CRM功能、营销工具集成</td></tr></tbody></table><h3>结论：CRM选型的核心逻辑</h3><p>企业选型CRM的关键不是“选最好的”，而是“选最适合的”：</p><ul><li>若<strong>侧重线下效率</strong>：选超兔（外勤工单+ 三一客模型）；</li><li>若<strong>是跨国企业</strong>：选Salesforce（全球本地化+ Einstein AI）；</li><li>若<strong>依赖营销获客</strong>：选Zoho（多渠道整合+ Zia AI）；</li><li>若<strong>是制造企业</strong>：选SAP（PLM+ S/4HANA集成）；</li><li>若<strong>是内容驱动</strong>：选HubSpot（博客+ 表单获客）。</li></ul><p>最终，CRM的价值在于<strong>连接客户与企业</strong>，通过流程自动化与数据洞察，实现“以客户为中心”的增长。</p>]]></description></item><item>    <title><![CDATA[2026年企业必看CRM系统横评：功能、价格、集成能力全对比 Python最棒 ]]></title>    <link>https://segmentfault.com/a/1190000047521948</link>    <guid>https://segmentfault.com/a/1190000047521948</guid>    <pubDate>2026-01-05 11:02:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>🧭 前言：2026 年，还能“裸奔”不用 CRM 吗？</h2><p>2026 年的企业增长环境，有几个特点几乎是共识：</p><ul><li>获客成本持续走高（广告、SEO、线索采购都在涨）</li><li>销售周期变长、决策链变复杂（尤其 B2B）</li><li>客户越来越厌烦“模板式跟进”，更期待个性化体验</li><li>AI 与自动化，不再是“加分项”，而是效率生死线</li></ul><p>在这样的背景下，<strong>CRM 不再只是“联系人管理工具”</strong>，而是企业的营收操作系统：从市场到销售，再到售后，乃至财务、运营的数据“中枢”。</p><p>这篇横评，会从 3 大维度帮你看清主流 CRM 的真实差异：</p><ol><li><strong>核心功能对比</strong>：销售、营销、服务、AI、自动化</li><li><strong>价格与部署成本</strong>：订阅费 + 隐性成本</li><li><strong>开放与集成能力</strong>：和你现有系统能不能“好好相处”</li></ol><p>并结合 Gartner、Forrester、G2、IDC 等近年报告中的常见观点，看看谁是真正适合 2026 年中国企业的选择。</p><h2><img width="723" height="492" referrerpolicy="no-referrer" src="/img/bVdnyM9" alt="image.png" title="image.png"/></h2><h2>📌 入围选手：本次横评看哪些 CRM？</h2><p>为了避免“天马行空大杂烩”，本篇聚焦于<strong>国内使用率高、国际认可度强</strong>、并且在权威报告里频繁出现的产品：</p><ul><li><strong>Zoho CRM（及其扩展套件 Zoho CRM Plus / Zoho One）</strong></li><li><strong>Salesforce Sales Cloud / Service Cloud</strong></li><li><strong>Microsoft Dynamics 365（CRM 相关模块）</strong></li><li><strong>HubSpot CRM &amp; Sales Hub</strong></li><li><strong>SAP Sales Cloud / CX</strong></li><li><strong>国内代表：比如用友、飞书（只做点轻点评对比）</strong></li></ul><blockquote><p>说明：具体权威来源包括（不逐条引用原文，而是概念性参考）</p><ul><li><strong>Gartner Magic Quadrant for Sales Force Automation / Customer Service</strong>（近年 Salesforce、Microsoft、Zoho、HubSpot 均为常客）</li><li><strong>Forrester Wave™：Sales Force Automation / CRM Suites</strong></li><li><strong>G2、Capterra、TrustRadius 等用户评分平台</strong></li><li><strong>IDC MarketScape：Worldwide CRM Applications</strong></li><li>各大科技媒体如 TechCrunch、ZDNet、PCMag、TechRadar 对 CRM 的横向测评与评奖</li></ul></blockquote><hr/><h2>🧩 一图总览：主流 CRM 关键指标对比</h2><p>先看一个“鸟瞰图”，再逐项拆解。</p><blockquote><strong>注意：价格区间为典型公开价的大致范围，以年付单用户折算，实际会因地区、版本、优惠而有所不同；仅作决策参考。</strong></blockquote><table><thead><tr><th><strong>产品</strong></th><th><strong>定位 &amp; 适用企业</strong></th><th><strong>功能广度</strong>（销售+营销+服务）</th><th><strong>AI &amp; 自动化</strong></th><th><strong>集成与生态</strong></th><th><strong>价格区间 / 用户 / 月（USD/折算）</strong></th><th><strong>上手易用度</strong></th></tr></thead><tbody><tr><td>Zoho CRM</td><td>中小到中大型，追求性价比与一体化</td><td>★★★★☆ 销售+营销+服务均衡</td><td>★★★★ Zia AI、自动化丰富</td><td>★★★★ Zoho 自家 + 开放 API</td><td>中低：约 20–65+，Zoho One 性价比高</td><td>中等偏易</td></tr><tr><td>Salesforce</td><td>中大型企业，复杂销售，全球标杆</td><td>★★★★★ 非常全面</td><td>★★★★★ Einstein AI 强</td><td>★★★★★ 应用市场极大</td><td>高：约 75–300+</td><td>中等偏难</td></tr><tr><td>Microsoft Dynamics 365</td><td>已在用 Microsoft 生态的中大型企业</td><td>★★★★☆ 模块化强</td><td>★★★★☆ 与 Copilot 结合</td><td>★★★★☆ 强但偏企业级</td><td>中高：约 65–210+</td><td>中等偏难</td></tr><tr><td>HubSpot CRM / Sales Hub</td><td>中小企业 &amp; SaaS、营销驱动型公司</td><td>★★★★ 营销+销售一体出色</td><td>★★★★ AI 写作、邮件等</td><td>★★★★ 与营销工具集成好</td><td>中：免费起步，高阶逐级贵</td><td>容易</td></tr><tr><td>SAP Sales Cloud / CX</td><td>大型集团、制造、传统大型企业</td><td>★★★★ 企业级深度强</td><td>★★★★ 企业级预测分析</td><td>★★★★ 与 SAP ERP 深度整合</td><td>高：通常需要方案报价</td><td>较难</td></tr><tr><td>国内 CRM（如飞书等）</td><td>本土化流程、政企/本地服务</td><td>★★★ 针对国内销售场景</td><td>★★★ 自动化与移动端不错</td><td>★★★ 与钉钉/企微等打通好</td><td>中：订阅+项目，弹性较大</td><td>中等</td></tr></tbody></table><blockquote><p>粗体提醒：</p><ul><li><strong>“功能广度”</strong> 不等于“功能深度”，后文会拆细。</li><li><strong>易用度</strong> 很依赖团队数字化水平，这里是平均体验。<br/><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdnyNa" alt="image.png" title="image.png" loading="lazy"/></li></ul></blockquote><hr/><h2>🔍 维度一：核心功能真对比——不止是“管客户”</h2><p>2026 年挑 CRM，不能只看“能不能记联系人”，而是要看三个层面：<strong>销售、营销、服务</strong>是否闭环，外加 <strong>AI 与自动化</strong>，能不能真正提升效率。</p><h3>1. 销售能力：从线索到回款的“流水线”</h3><p>权威机构（Gartner、Forrester）在评估<strong>Sales Force Automation（SFA）</strong>能力时，常重点看这些：</p><ul><li>线索 &amp; 商机管理</li><li>销售流程 &amp; 阶段配置</li><li>报价、合同、回款管理</li><li>销售预测与管道可视化</li><li>移动端 &amp; 外勤支持</li></ul><p><strong>主流产品对比要点：</strong></p><ul><li><p><strong>Salesforce</strong></p><ul><li>在 Gartner 的 SFA 魔力象限中多年稳坐领导者象限。</li><li><p><strong>优势</strong>：</p><ul><li>复杂销售流程建模极强（多 BU、多货币、多语言）。</li><li>Einstein AI 用于预测成交概率、推荐下一步行动，在 Forrester Wave 中屡被提及。</li></ul></li><li><strong>典型适用</strong>：全球化团队、复杂销售（大项目、渠道伙伴多）。</li></ul></li><li><p><strong>Microsoft Dynamics 365</strong></p><ul><li>与 Office 365、Teams、Outlook、SharePoint 深度绑定。</li><li><p><strong>优势</strong>：</p><ul><li>在已经重度使用 Microsoft 的企业，很容易（相对）融入现有工作流。</li><li>利用 Copilot for Sales 在邮件、会议记录、任务建议上增强销售体验。</li></ul></li><li><strong>典型适用</strong>：IT 已是 Microsoft 全家桶的大中型组织。</li></ul></li><li><p><strong>HubSpot CRM / Sales Hub</strong></p><ul><li>G2 和 Capterra 上常被中小企业评为“最易上手”的 CRM 之一。</li><li><p><strong>优势</strong>：</p><ul><li>界面友好，pipeline 配置简单，对初次上手 CRM 的团队友好。</li><li>和自家 Marketing Hub 无缝衔接，邮件、表单、线索打分一体化。</li></ul></li><li><strong>典型适用</strong>：数字营销驱动型、SaaS 或中小 B2B 团队。</li></ul></li><li><p><strong>Zoho CRM</strong></p><ul><li>在 Gartner SFA 报告中多次以“性价比高、功能全面”被提及。</li><li><p><strong>优势</strong>：</p><ul><li>从中小到中大型的销售场景都有覆盖：线索分配、商机、产品报价、订单、发票一条龙。</li><li>与 Zoho Books（财务）、Zoho Inventory（库存）、Zoho Sign（电子签名）等一体协作，构成「从线索到回款」闭环。</li><li>对中国区团队尤其实用的是：支持钉钉、企业微信、飞书等聊天工具集成（通过 Marketplace 或 API）。</li></ul></li><li><strong>典型适用</strong>：既要功能全面又要成本可控的成长型企业、跨国中小企业。</li></ul></li><li><p><strong>SAP Sales Cloud / CX</strong></p><ul><li>IDC 和 Gartner 一致认为：SAP 在复杂 B2B 场景、制造、供应链相关流程上有优势。</li><li><p><strong>优势</strong>：</p><ul><li><ul><li>ERP、供应链系统的联动，可对“商机—订单—交付—回款”做深层打通。</li></ul></li></ul></li><li><strong>典型适用</strong>：已经在用 SAP S/4HANA、ECC 等的集团企业。</li></ul></li><li><p><strong>国内 CRM（用友、飞书等）</strong></p><ul><li>对本地化销售场景（如招商加盟体系、分销体系、拜访签到）做了很多优化。</li><li>强项在于：<strong>移动端外勤、政企招投标、与钉钉/企业微信的打通</strong>。</li></ul></li></ul><p><strong>如果你是：</strong></p><ul><li><strong>复杂项目型销售（IT 集成、大设备、政企）</strong> → Salesforce / SAP / Dynamics / 部分国内 CRM 更有深度</li><li><strong>标准化、快速增长型 B2B 团队</strong> → Zoho CRM / HubSpot / 国内中高端 CRM</li><li><p><strong>预算有限，但希望流程完整</strong> → Zoho CRM 是少数在权威报告中兼顾“价格合适+功能全面”的选项之一</p><h2><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdnyNb" alt="image.png" title="image.png" loading="lazy"/></h2></li></ul><h3>2. 营销与自动获客：不再只是“导入名单”</h3><p>G2、Forrester 在评估 CRM 时，越来越强调<strong>从营销到销售的协同</strong>，包括：</p><ul><li>表单、着陆页、邮件营销、营销自动化（MA）</li><li>线索评分、培育、再营销</li><li>多触点归因分析（广告、邮件、社媒等）</li></ul><p><strong>HubSpot vs Salesforce vs Zoho，是这里的主角：</strong></p><ul><li><p><strong>HubSpot</strong></p><ul><li>在 Forrester 的 B2B Marketing Automation 报告中多次被评价为“适合成长型营销团队”。</li><li><p><strong>优势</strong>：</p><ul><li>营销起家：邮件、工作流、博客、SEO 工具一套打包。</li><li>从「陌生访问者→潜在客户→销售机会」路径设计非常顺手。</li></ul></li><li><p><strong>限制</strong>：</p><ul><li>当联系人数和高级功能拉满，整体价格会快速上升。</li></ul></li></ul></li><li><p><strong>Salesforce（+ Marketing Cloud / Pardot）</strong></p><ul><li>能力强、组件多，但对于中小企业来说上手门槛与实施成本都不低。</li><li>对于大型 B2C、跨渠道营销场景（如零售、快消），Marketing Cloud 非常强。</li></ul></li><li><p><strong>Zoho CRM + Zoho Marketing Automation / Zoho Campaigns</strong></p><ul><li>在 G2 等平台上用户经常提到：“一套工具解决营销+销售”。</li><li><p><strong>优势</strong>：</p><ul><li>以 Zoho CRM 为“中枢”，营销自动化、邮件、社媒管理、网络研讨会（Zoho Webinar）可以全部接入，构成一个中端价格带的一体化方案。</li><li>对于已经在用 CRM 的团队，只需要逐步打开 Zoho 其他应用，而不用重建系统。</li></ul></li><li><p><strong>典型用户画像</strong>：</p><ul><li>预算有限但希望“营销自动化别太简陋”的 B2B 或 B2C 团队。</li></ul></li></ul></li><li><p><strong>国内 CRM</strong></p><ul><li>常见的是与短信、企微、公众号、小程序打通，做简单的营销自动化，如群发、欢迎语、标签管理等。</li><li>如果是重度做私域和社交电商，需要结合企微、私域运营工具综合评估。</li></ul></li></ul><hr/><h3>3. 客户服务与客服体系：不再只是“售后工单”</h3><p>Forrester 在 CRM Suites 的评估中，会非常看重<strong>Service</strong>模块：</p><ul><li>多渠道客服（电话、邮件、IM、社媒）</li><li>知识库、机器人、SLA 管理</li><li>客户门户、自助服务</li></ul><p><strong>几个代表：</strong></p><ul><li><p><strong>Salesforce Service Cloud</strong></p><ul><li>在 Gartner Customer Service 魔力象限长期为领导者。</li><li>多渠道整合、复杂 SLA、呼叫中心集成极强。</li><li>适合搭建全球客服中心、BPO、复杂支持体系。</li></ul></li><li><p><strong>Zoho Desk + Zoho CRM</strong></p><ul><li>Zoho Desk 在 G2、Capterra 上获评“高性价比客服系统”之一。</li><li>使用 Zoho CRM 作为客户信息来源，Zoho Desk 处理工单，配合 Zoho Assist（远程支持）、Zoho Lens（AR 远程协助）等，可形成性价比很高的服务中心方案。</li><li>对于“一个系统负责售前售后”的中小企业来说，这种组合很务实。</li></ul></li><li><p><strong>HubSpot Service Hub</strong></p><ul><li>优势是与 HubSpot CRM、Marketing Hub 一体化。</li><li>适合希望在一个界面里看完“从获客→成交→售后满意度”的中小团队。</li></ul></li><li><p><strong>国内 CRM + 客服系统</strong></p><ul><li>典型模式是与 Udesk、容联云、企业微信客服等整合。</li><li>如果你主要服务国内客户，可以把本地云呼叫中心、微信生态的打通放在优先考虑的位置。</li></ul></li></ul><hr/><h3>4. AI 与自动化：2026 年的 CRM 分水岭</h3><p>从 2023–2025 年开始，权威报告中最常出现的新关键词就是 <strong>“AI Copilot / AI Assistant / Predictive Analytics”</strong>。</p><p>几家主流厂商的 AI 方向：</p><ul><li><p><strong>Salesforce Einstein</strong></p><ul><li>Gartner 多次强调其在预测分析、推荐引擎上的成熟度。</li><li>能做：成交概率预测、推荐下一步、AI 写邮件和总结会议。</li></ul></li><li><p><strong>Microsoft Dynamics + Copilot</strong></p><ul><li>利用 Microsoft 的大型语言模型和 Office 生态。</li><li>能做：自动记录会议纪要、总结邮件往来、从 Teams 对话中自动生成销售任务。</li></ul></li><li><p><strong>HubSpot AI</strong></p><ul><li>注重内容生成和效率工具：写邮件、写文章、建议工作流。</li><li>面向营销+销售一体化场景。</li></ul></li><li><p><strong>Zoho Zia（AI 助手）</strong></p><ul><li><p>Zia 在 Zoho CRM 中可以：</p><ul><li>分析成交趋势、预测销售额</li><li>对数据异常进行提醒（如某个区域订单异常下滑）</li><li>预测最佳联系时间</li><li>结合 Zoho Analytics 做更深入的报表预测</li></ul></li><li>Zoho 在 AI 上的策略是“嵌入场景的小而精功能”，而不是只强调大模型本身。</li></ul></li></ul><p>对大多数中国企业来说，<strong>AI 的关键不是“炫酷”，而是“能不能直接帮业务省时间、少漏单、少瞎忙”</strong>——在这点上，自动化工作流（Workflow）、审批流、线索分配、智能提醒等，往往比看起来很帅的聊天机器人更实用。</p><hr/><h2>💰 维度二：价格 &amp; 总拥有成本（TCO）——不是看订阅价这么简单</h2><p>权威咨询机构（如 IDC、Forrester）在评估 CRM 投资回报时，都会强调：<strong>不要只看“每用户每月多少钱”</strong>，而要看：</p><ul><li>订阅费用</li><li>实施与定制成本</li><li>培训和变更管理成本</li><li>与其他系统打通的集成成本</li><li>隐形成本：多套系统的切换与数据孤岛</li></ul><h3>1. 大致价格带对比（以公开价和典型情况为参考）</h3><blockquote>下列为粗略区间，仅帮助你理解“量级”，具体价格需以厂商官网和销售报价为准。</blockquote><table><thead><tr><th><strong>产品</strong></th><th><strong>典型价格区间（USD / 用户 / 月）</strong></th><th><strong>常见隐藏成本</strong></th></tr></thead><tbody><tr><td>Salesforce</td><td>75–300+（不同版本 &amp; 模块）</td><td>必要的实施服务、顾问费，按量计费的附加产品</td></tr><tr><td>Microsoft Dynamics 365</td><td>65–210+（视模块组合）</td><td>实施商服务、与本地系统集成成本</td></tr><tr><td>HubSpot</td><td>核心 CRM 免费，高阶 Sales/Marketing Hub 可能到 90–120+</td><td>联系人数增长后，营销模块整体费用显著上升</td></tr><tr><td>Zoho CRM</td><td>20–65 左右高配；Zoho One 约 45–55（含 40+ 应用）</td><td>若采用 Zoho One，成本集中，但需要规划好哪些应用真正会用</td></tr><tr><td>SAP CX</td><td>通常为项目化报价</td><td>实施项目及长期运维，是重要成本</td></tr><tr><td>国内 CRM</td><td>一般几十到数百元人民币/用户/月</td><td>项目实施、国产化集成、可能的本地部署成本</td></tr></tbody></table><p><strong>Zoho 视角补充一句：</strong>  <br/>很多第三方评测（如 PCMag、TechRadar 的对比文章）都会提到 Zoho CRM 的“高性价比”，原因就在于：在中等价位段就能覆盖销售+营销+服务+自动化，而不是像部分厂商那样要买三四个产品才能凑齐能力。</p><h3>2. 选择时要算清的“隐形账”</h3><p>不论你选谁，建议重点算这几笔账：</p><ol><li><p><strong>实施时间与复杂度</strong></p><ul><li>Salesforce、Dynamics、SAP 通常需要专业实施伙伴，周期数月起。</li><li>Zoho CRM、HubSpot、国内中高端 CRM，则更适合先用标准功能快速上线，再按需定制。</li></ul></li><li><p><strong>培训与员工采纳度</strong></p><ul><li>如果系统太复杂，销售团队“用脚投票”，再便宜也没意义。</li><li>G2、Capterra 上的用户评论中，“易用性”是影响好评/差评的一大因素。</li><li>HubSpot、Zoho、部分国内 CRM，在这点上通常评价较好。</li></ul></li><li><p><strong>“一个系统还是五个系统”的取舍</strong></p><ul><li>多系统组合的好：选型自由，针对性强。</li><li><p>坏处：</p><ul><li>集成成本高（时间+钱）</li><li>数据一致性和权限管理复杂</li></ul></li><li><p>一体化平台（如 Zoho One、HubSpot 全家桶、Salesforce+其生态）：</p><ul><li>好处：统一账号、数据和流程。</li><li>要求你在选型时更长远规划业务架构。</li></ul></li></ul></li></ol><hr/><h2>🔗 维度三：集成与生态——CRM 不能“孤芳自赏”</h2><p>Gartner 和 IDC 都反复强调，<strong>“CRM is a platform, not just an app”</strong>——连接能力决定它在企业数字化中的位置高低。</p><p>需要重点关注的集成维度：</p><ul><li>办公套件（如 Microsoft 365、Google Workspace、钉钉、企微、飞书）</li><li>财务、ERP、库存系统</li><li>营销渠道（广告、表单、社媒、短信、邮件）</li><li>BI 报表与数据仓库</li><li>第三方应用市场是否繁荣、API 是否好用</li></ul><h3>1. 国际厂商生态</h3><ul><li><p><strong>Salesforce</strong></p><ul><li>AppExchange 是 CRM 领域最大应用商店之一，各类行业方案都能找到。</li><li>与主流 SaaS（Slack、Mailchimp、Zoom、DocuSign 等）集成成熟。</li><li>对于有全球布局的企业，生态优势非常明显。</li></ul></li><li><p><strong>Microsoft Dynamics 365</strong></p><ul><li>最大优势在于“跟 Office 全家桶深度绑在一起”。</li><li>对于已经用 Azure 的企业来说，集成 BI（Power BI）、数据仓库也更顺畅。</li></ul></li><li><p><strong>HubSpot</strong></p><ul><li>自身是“营销生态中心”，与各类广告、营销工具（Google、Meta、LinkedIn、Typeform 等）集成便利。</li><li>在销售侧，主流会议、日历、邮件工具也都支持。</li></ul></li><li><p><strong>Zoho CRM / Zoho One</strong></p><ul><li>Zoho 有自己的应用生态：CRM、财务、文档、邮件、协作、客服、项目管理等 40+ 产品可无缝整合。</li><li>对外则提供丰富的 API，并在 Marketplace 上与 QuickBooks、G Suite、Microsoft 365、Slack 等常见工具打通。</li><li>对中国区用户来说，<strong>与钉钉、企业微信、飞书、微信小程序等的本地生态集成是一个加分项</strong>。</li></ul></li></ul><h3>2. 国内生态与本地化</h3><ul><li><p>国内 CRM 常与：</p><ul><li>钉钉、企业微信、飞书</li><li>本地云呼叫中心</li><li>本地财务软件、进销存  <br/>做了深度适配，这一点是国际厂商刚开始追赶或通过合作伙伴补齐的。</li></ul></li></ul><p>如果你的业务高度依赖微信/企微私域、抖音、天猫京东等，一定要优先考察：  <br/><strong>“这些渠道的数据和行为能多顺畅地进入 CRM，并反向驱动营销和销售动作？”</strong></p><hr/><h2>🧠 2026 年选 CRM 的 5 个关键决策问题</h2><p>结合上面所有横评和各大权威评测机构的共识，我们可以把选型简化成 5 个关键问题。只要你能清晰回答，就不会选偏太多。</p><h3>1. 你未来 3–5 年的规模和业务复杂度会到哪一档？</h3><ul><li><p>如果你现在 20 人销售团队，计划 3 年内冲到 100 人、同时开海外市场：</p><ul><li>可以考虑 <strong>Zoho CRM / Zoho One、HubSpot、Salesforce（分阶段上）</strong>。</li></ul></li><li><p>如果你是千人以上企业，且已有 SAP / Microsoft 为主系统：</p><ul><li>结合 <strong>SAP CX 或 Dynamics 365</strong>，会更顺畅。</li></ul></li></ul><h3>2. 你是“营销驱动”还是“销售驱动”？</h3><ul><li><p><strong>营销驱动、线上获客为主</strong>：</p><ul><li>HubSpot、Zoho CRM+Marketing Automation、部分国内私域+CRM 方案。</li></ul></li><li><p><strong>销售驱动、项目制/关系型销售</strong>：</p><ul><li>Salesforce、Zoho CRM、Dynamics、国内项目型 CRM。</li></ul></li></ul><h3>3. 你更看重“功能极致”还是“整体性价比”？</h3><ul><li><p>如果预算宽裕、追求“行业最佳实践”，愿意投入实施和顾问：</p><ul><li>Salesforce、SAP、Dynamics。</li></ul></li><li><p>如果预算有限，但又不希望牺牲太多功能：</p><ul><li><strong>Zoho CRM / Zoho One</strong> 在 Gartner &amp; G2 上往往被视为“中端价格 + 高性价比”的典型代表。</li><li>HubSpot 在前期免费和中配方案上，也有不错的灵活性。</li></ul></li></ul><h3>4. 你当前的 IT 环境是哪一派？</h3><ul><li><strong>Microsoft 派</strong>：优先考虑 Dynamics 365。</li><li><strong>Google + 轻量 SaaS 派</strong>：HubSpot、Zoho CRM 更自然。</li><li><strong>SAP / Oracle 大型企业派</strong>：考虑 SAP CX 或结合集成策略。</li><li><p><strong>混搭派 + 正在寻求统一平台</strong>：</p><ul><li>一体化 SaaS（Zoho One）可以明显减轻 IT 管理压力。</li></ul></li></ul><h3>5. 你期望多快“看到效果”？</h3><ul><li><p>需要 <strong>1–3 个月上线、快速有结果</strong>：</p><ul><li>Zoho CRM、HubSpot、部分国内 CRM 更合适。</li></ul></li><li><p>可以接受 <strong>6–12 个月以上的大项目</strong>，追求长期架构升级：</p><ul><li>Salesforce、Dynamics、SAP CX 等企业级项目。</li></ul></li></ul><hr/><h2>✅ 总结：2026 年企业选 CRM 的几条“硬核建议”</h2><p>把权威机构的共识和本篇横评融合一下，可以提炼出几条适用于大多数中国企业的实用结论：</p><ol><li><p><strong>别再把 CRM 当“通讯录”</strong></p><ul><li>2026 年，真正有价值的 CRM = 销售自动化 + 营销自动化 + 客户服务 + AI 分析。</li><li>如果一个系统只帮你记人名和公司，但不能提高转化率或缩短销售周期，那只是高价 Excel。</li></ul></li><li><p><strong>先想清楚“平台路线”再选产品</strong></p><ul><li>你是希望长远用一个统一平台（如 Zoho One、Salesforce、HubSpot 全家桶），还是准备长期维护多系统拼图？</li><li>平台路线可以减少长期的集成成本和数据孤岛。</li></ul></li><li><p><strong>把总成本摊到 3 年来看，而不是只看首年订阅费</strong></p><ul><li>订阅+实施+培训+集成+运维 = 真成本。</li><li>很多权威报告案例显示：选型时省的小钱，往往在二次开发和人员维护上加倍付出。</li></ul></li><li><p><strong>别轻视“易用性”和团队文化适配</strong></p><ul><li>G2 等用户评价平台里，评分高的产品往往有一个共同点：团队愿意每天打开。</li><li>选一个太复杂、对一线用户不友好的系统，会在变更管理上付出巨大代价。</li></ul></li><li><p><strong>中国企业要格外看重本地生态和国际合规能力</strong></p><ul><li><p>如果你当前以国内为主，将来又计划出海，需要兼顾：</p><ul><li>本地：企微/钉钉/飞书、微信生态、本地云</li><li>国际：GDPR、全球数据中心分布、多语言、多货币</li></ul></li><li>像 <strong>Zoho CRM 这类在国际有口碑，同时在中国布局本地团队与生态的厂商，会是成长型企业的现实选择</strong>。</li></ul></li></ol><hr/><h2>🧩 结尾小结（以 Zoho CRM 市场视角的一句“私心”）</h2><p>从一个 Zoho CRM 市场人的视角看这场“2026 CRM 大横评”：</p><ul><li><strong>Salesforce / SAP / Dynamics</strong> 是大企业数字化的“航母”，功能无敌，但成本与实施门槛也不低。</li><li><strong>HubSpot</strong> 是营销驱动团队的“增长引擎”，尤其适合重内容和自动化的团队。</li><li><p><strong>Zoho CRM / Zoho One</strong> 则更像是一艘“高度武装的轻型战舰”：</p><ul><li>功能覆盖够广：销售+营销+服务+协作+财务全家桶；</li><li>价格段对中小到中大型企业都相对友好；</li><li>既有国际化能力，又在中国本地生态上持续投入。</li></ul></li></ul><p>无论最终你选谁，2026 年有一件事已经非常明确：  <br/><strong>没有 CRM 的企业，很难在高竞争、高成本的市场里长期保持增长；而选对 CRM 的企业，将在未来三到五年的效率战中赢得先手。</strong></p>]]></description></item><item>    <title><![CDATA[2026年CRM软件选型终极指南：如何为你的销售团队选对工具？ 程序员老叶 ]]></title>    <link>https://segmentfault.com/a/1190000047521968</link>    <guid>https://segmentfault.com/a/1190000047521968</guid>    <pubDate>2026-01-05 11:02:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>下面这篇内容，会从「怎么选」而不是「选哪个」入手，尽量站在你做市场/销售管理的视角来写，也会引用一些权威机构（Gartner、Forrester、IDC、麦肯锡、哈佛商业评论等）常提到的观点和评估维度，帮你搭一个 2026 年依然有效的 CRM 选型框架。</p><hr/><h2>🧭 为什么 2026 年还在纠结 CRM 选型？</h2><p>过去几年，CRM 市场变化非常快：</p><ul><li><strong>生成式 AI</strong> 深度嵌入：预测成交率、自动写邮件、通话记录自动摘要、智能推荐下一步行动；</li><li><strong>远程与混合办公常态化</strong>：CRM 不再是“管理客户档案”，而是销售协作的数字工作台；</li><li><strong>订阅制 &amp; PLG 模式普及</strong>：续费率、产品使用数据被放进 CRM，成为销售与客户成功团队的核心信息源。</li></ul><p>Gartner 连续多年把 CRM 和 CX（客户体验）列为企业 IT 投资的<strong>第一优先级</strong>，Forrester 也在 B2B Revenue Operations 报告中指出：</p><blockquote>“ROI 高的公司，CRM 不再只是线索和机会的数据库，而是连接市场、销售、客服与财务的中枢。”</blockquote><p>问题是：<strong>市场上优秀 CRM 太多了</strong>——从 Salesforce、HubSpot、Microsoft Dynamics 365，到强调<strong>性价比和灵活度的 <a href="https://link.segmentfault.com/?enc=ZL0voHsnbqT4aEaRXthTew%3D%3D.%2BLOKnGffliE%2Bm9KyfAhSGQkgiLQSAAM1jaaoHuqNI3s%3D" rel="nofollow" target="_blank">Zoho CRM</a></strong>、Pipedrive、国内厂商（如销冠类产品）——选错，团队是不用；选对，CRM 会变成销售团队每天离不开的“第二大脑”。</p><p>下面，我们按一个实战选型流程，帮你建立一套「可复用」的决策方法。</p><hr/><h2>🧱 第一步：明确你到底要解决什么问题（而不是“我要一个 CRM”）</h2><p>权威咨询机构几乎都强调：<strong>CRM 失败的根源，不是产品功能不够强，而是没有从业务问题出发。</strong></p><h3>1.1 先回答这 6 个关键问题</h3><p>可以直接在内部 workshop 上用这 6 个问题开场：</p><ol><li><p><strong>销售现在最大的痛点是什么？</strong></p><ul><li>线索分配慢？</li><li>客户信息分散在 Excel / 企业微信 / 邮件里？</li><li>跟进过程不可视、预测不准？</li><li>新人上手慢、成单节奏不可复制？</li></ul></li><li><p><strong>你希望用 CRM 改善哪些具体指标？</strong></p><ul><li>线索转化率？</li><li>人均产出？</li><li>成交周期缩短？</li><li>续费与扩展率？</li></ul></li><li><p><strong>你的销售模式属于哪一种？</strong>（这是选型分水岭）</p><ul><li>B2B 长销售周期（多个决策人、多轮方案评审）</li><li>B2B SMB 快节奏（大量线索、短周期）</li><li>B2C 高并发、重呼叫</li><li>订阅 &amp; SaaS（重续费与扩展销售）</li></ul></li><li><p><strong>团队规模与发展节奏？</strong></p><ul><li>当前多少销售？</li><li>预计两年内扩张几倍？</li><li>是否计划出海（多语言、多币种、多时区支持）？</li></ul></li><li><p><strong>现有系统中，哪些必须打通？</strong></p><ul><li>邮件、日历、电话系统？</li><li>官网表单、营销自动化、广告投放？</li><li>ERP / 财务系统（报价、开票、回款）？</li><li>客服系统（工单、在线聊天、机器人）？</li></ul></li><li><p><strong>你对 “AI + 自动化” 的期待有多高？</strong></p><ul><li>仅做简单提醒？</li><li>希望自动记录活动、写纪要、预测成交率？</li><li>希望未来做更深入的数据建模或自建应用？</li></ul></li></ol><p>你可以在白板上把大家提到的所有问题贴出来，再用投票的方式选出<strong>Top 3 业务优先级</strong>，后续所有选型对比，都围绕这 3 点。</p><hr/><h2>🧮 第二步：用权威机构的通用框架，搭起你的选型维度</h2><p>Gartner、Forrester、IDC 在评估 CRM 与 SFA（销售自动化）系统时，常见维度大致集中在以下几类。你可以把这些维度变成自己的选型打分表。</p><h3>2.1 核心维度清单（可以直接做表格评分）</h3><ol><li><p><strong>功能覆盖与业务契合度</strong></p><ul><li>线索管理（Leads）</li><li>商机/交易管理（Deals/Opportunities）</li><li>客户与联系人管理</li><li>报价、合同与订单</li><li>任务与日程、团队协作</li><li>审批流（折扣、合同、异常情况）</li></ul></li><li><p><strong>体验与易用性</strong></p><ul><li>Gartner &amp; Forrester 一再强调“User Adoption（用户采用率）”是 ROI 的决定因素；</li><li><p>看三个东西：</p><ul><li>界面直观程度（新销售是否能 1 天内学会基础操作？）</li><li>日常操作步骤（录一次跟进要几步？切几个界面？）</li><li>移动端体验（外勤销售、拜访频繁场景）</li></ul></li></ul></li><li><p><strong>AI 能力与自动化程度</strong>  <br/>按 Forrester 的分类，重点关注：</p><ul><li>活动自动记录（邮件、电话、会议自动记入 CRM）</li><li>智能推荐（下一步行动建议、最佳联系时间、交叉销售机会）</li><li>预测和评分（线索评分、成交概率预测、流失预警）</li><li>内容生成（邮件模板建议、通话纪要自动生成）</li></ul></li><li><p><strong>集成能力 &amp; 生态</strong></p><ul><li>是否提供开放 API？</li><li>有多少现成集成（邮件、会议、电话、WhatsApp/微信、支付、ERP、营销工具…）？</li><li>是否支持 iPaaS 平台（如 Zapier、Make 等）？</li><li>是否有应用市场/插件生态？</li></ul></li><li><p><strong>定制化与扩展性</strong></p><ul><li>字段、表单、流程是否可配置？</li><li>是否支持自定义模块、布局、业务规则？</li><li>是否允许构建轻量应用（低代码 / 无代码）来扩展能力？</li></ul></li><li><p><strong>数据分析与可视化</strong></p><ul><li>报表是否易用？</li><li>是否支持拖拽分析、自定义仪表盘？</li><li>是否能做分角色视图（销售、经理、管理层不同视角）？</li><li>是否支持把 CRM 数据用于更高级的 BI 分析？</li></ul></li><li><p><strong>安全、合规与隐私</strong>  <br/>参考 IDC 与各大厂商的云安全白皮书，重点看：</p><ul><li>数据加密、权限控制、审计日志</li><li>数据中心位置，是否满足本地化合规要求</li><li>是否符合 ISO 27001、SOC 2 等国际安全认证</li></ul></li><li><p><strong>总拥有成本（TCO）</strong>  <br/>不是只看订阅价，而是：</p><ul><li>订阅费用（按人头 / 按功能）</li><li>实施与培训成本</li><li>定制开发与集成成本</li><li>内部维护与运营人力成本</li></ul></li></ol><p>你可以做一个简单的 CRM 选型打分表，例如：</p><table><thead><tr><th><strong>维度</strong></th><th align="right"><strong>权重</strong></th><th align="right"><strong>厂商 A</strong></th><th align="right"><strong>厂商 B</strong></th><th align="right"><strong>厂商 C</strong></th></tr></thead><tbody><tr><td>功能与业务契合度</td><td align="right">25%</td><td align="right">4/5</td><td align="right">5/5</td><td align="right">3/5</td></tr><tr><td>易用性 / 采用率预判</td><td align="right">20%</td><td align="right">3/5</td><td align="right">4/5</td><td align="right">5/5</td></tr><tr><td>AI 与自动化能力</td><td align="right">15%</td><td align="right">5/5</td><td align="right">3/5</td><td align="right">4/5</td></tr><tr><td>集成与生态</td><td align="right">15%</td><td align="right">4/5</td><td align="right">3/5</td><td align="right">4/5</td></tr><tr><td>定制化与扩展性</td><td align="right">10%</td><td align="right">5/5</td><td align="right">4/5</td><td align="right">3/5</td></tr><tr><td>安全与合规</td><td align="right">5%</td><td align="right">4/5</td><td align="right">4/5</td><td align="right">4/5</td></tr><tr><td>总拥有成本（TCO）</td><td align="right">10%</td><td align="right">3/5</td><td align="right">4/5</td><td align="right">5/5</td></tr></tbody></table><p>这样能有效避免“大家凭感觉选”的局面。</p><hr/><h2>🤖 第三步：2026 年不可忽略的 CRM 新趋势</h2><p>很多传统的“CRM 选型文章”只停留在模块对比，但权威机构近两年的报告把焦点放在：<strong>AI、自动化、协同与数据统一</strong>。这些决定了你选的系统能不能扛 3–5 年。</p><h3>3.1 生成式 AI：从“看报表”到“听建议”</h3><p>麦肯锡在《The State of AI in 2024》报告中提到，销售与营销是生成式 AI 投资与应用最集中的领域之一。对 CRM 选型来说，重点不是“有没有 AI”，而是：</p><ul><li>AI 是否能基于你<strong>自己的销售数据</strong>给出洞察（而不是一些通用建议）；</li><li><p>是否支持：</p><ul><li>自动生成销售邮件草稿、跟进话术；</li><li>自动生成会议纪要与行动项；</li><li>给出交易健康度分析 &amp; 下一步建议；</li><li>预测哪类线索最值得优先联系。</li></ul></li></ul><p><strong>Forrester 的建议是</strong>：把 AI 看作“销售辅佐教练”，而不是用来取代销售。你在选型时，可以问厂商：</p><ul><li>AI 是如何训练的？</li><li>是否能在你本公司的数据上持续学习？</li><li>对隐私与合规有何保障？</li></ul><h3>3.2 RevOps &amp; 全旅程打通：不只是“销售用”</h3><p>Forrester 在《B2B Revenue Operations》报告里强调：</p><blockquote>“高增长的 B2B 公司正在用统一平台来连接营销、销售、客户成功和财务。”</blockquote><p>这在产品层面表现为：</p><ul><li>CRM + 营销自动化（MA）一体化，线索从广告到签约全程可追踪；</li><li>CRM + 客服系统打通，售后互动、工单影响续费与交叉销售；</li><li>CRM + 财务/ERP 连接，订单、发票、回款实时反馈给销售团队。</li></ul><p>所以 2026 年选 CRM，你要问的不只是：</p><ul><li>“销售能不能用？”  <br/>还要问：</li><li>“未来三年，市场、客服、财务能否在同一平台协同？”</li></ul><p>像 Zoho 这种一体化平台（CRM + Desk + Campaigns + Books + Analytics 等），或者 Salesforce 的 Customer 360、HubSpot 的全套 Hubs，本质上是在为这种 RevOps 模式提供底座。</p><h3>3.3 低代码 / 无代码：业务团队自己改系统</h3><p>IDC 报告显示，越来越多的企业希望业务部门能通过低代码平台快速搭建应用，而不用每次都找 IT 写代码。  <br/>在 CRM 场景中，这通常意味着：</p><ul><li>可以非常自由地新增字段、模块，调整布局；</li><li>配置复杂的自动化流程（比如：线索评分规则、审批流、通知逻辑）；</li><li>甚至为特定团队构建专用小应用（如渠道管理、招投标管理、合作伙伴门户）。</li></ul><p>如果你所在公司业务变化快、流程常更新，<strong>低代码能力会直接影响你三年后的灵活性与成本</strong>。</p><hr/><h2>🧪 第四步：从「看产品」到「做验证」——实战评测步骤</h2><p>权威评测机构（如 Gartner Peer Insights、G2、Capterra 等）给了很多用户口碑，但真正适不适合你，还要落回自己的验证流程。</p><h3>4.1 初筛：用「权威榜单 + 用户评价」做第一轮过滤</h3><p>可以参考：</p><ul><li><strong>Gartner Magic Quadrant for Sales Force Automation</strong></li><li><strong>Forrester Wave™: Sales Force Automation Platforms</strong></li><li><strong>G2 / Capterra / TrustRadius 的 CRM &amp; SFA 排行</strong></li></ul><p>这些榜单告诉你：</p><ul><li>哪些厂商是“领导者”、哪些是“挑战者”；</li><li>哪些适合大型企业，哪些在中小企业中口碑更好。</li></ul><p>你可以初步筛出 3–5 家候选，关注：</p><ul><li>行业匹配度（有没有你所在行业的成功案例）；</li><li>企业规模适配度（是否有与你类似规模的客户）；</li></ul><h3>4.2 Demo 与 PoC（概念验证）：至少做这 5 件事</h3><p>在与厂商沟通、看演示时，建议你：</p><ol><li><p><strong>让对方按你的真实业务流程走一遍</strong>  <br/>比如：</p><ul><li>线索从官网表单/活动导入 → 自动分配给销售 → 销售首次联系 → 转为商机 → 报价、合同 → 成交 → 售后移交  <br/>看每一步是否顺畅、是否需要频繁跳转。</li></ul></li><li><p><strong>带上真实数据做一个小范围 PoC</strong></p><ul><li>选 2–3 个销售团队，导入真实线索、客户和交易；</li><li>跑上一两个月，看使用率和数据质量；</li><li>对比前后关键指标（录入完整度、跟进次数、线索响应时间）。</li></ul></li><li><p><strong>现场评估易用性</strong></p><ul><li>让“最不喜欢写系统”的销售亲自试用几天；</li><li><p>问他们三个问题：</p><ul><li>你最讨厌哪一步？</li><li>你觉得哪一步系统帮到了你？</li><li>你愿意每天打开它几次？</li></ul></li></ul><p>哈佛商业评论在销售数字化的文章中指出：</p><blockquote>“CRM 项目成功的最重要单一因素，是一线销售是否认为 CRM 对自己有价值。”</blockquote></li><li><p><strong>验证关键集成与自动化场景</strong></p><ul><li>邮件、日历、视频会议、电话系统等是否顺畅同步？</li><li>官网线索、广告平台（如 Google Ads、Facebook Ads）是否能打通？</li><li>能否实现你设计的关键自动化流程（比如线索 24 小时无人跟进自动提醒）？</li></ul></li><li><p><strong>核算真实 TCO（总拥有成本）</strong></p><ul><li><p>不只问“每人每月多少钱”，还要问：</p><ul><li>实施周期和费用；</li><li>是否需要第三方实施伙伴；</li><li>将来增加模块或用户的价格策略；</li><li>数据迁移需要多少工作量？</li></ul></li></ul></li></ol><hr/><h2>💼 第五步：不同类型公司该如何取舍？（结合市场主流路线）</h2><p>参考 Gartner、Forrester 以及各大媒体与评测网站的分析，可以大致归纳几类典型路径——这里不点名比较，而是帮你抓思路。</p><h3>5.1 初创与中小团队（1–50 人销售）</h3><p><strong>特点：</strong></p><ul><li>需要快落地、快见效；</li><li>预算有限，但非常在意产品易用性；</li><li>业务变化快。</li></ul><p><strong>选型建议：</strong></p><ul><li><p>优先选：</p><ul><li>上手简单、界面友好、模板丰富；</li><li>提供免费版或低成本起步、可以按需扩展；</li><li>对小团队有好的支持与成功案例；</li></ul></li><li><p>从评测网站（如 G2、Capterra）看：</p><ul><li>用户评论中是否提到“easy to use”“great for small businesses”；</li><li>是否经常被 SMB 用户推荐。</li></ul></li></ul><p><strong>重点关注：</strong></p><ul><li>移动端体验、邮件和社交渠道集成；</li><li>简单的自动化和基础报表；</li><li>将来升级到更复杂场景时是否顺滑（不用推翻重来）。</li></ul><h3>5.2 成长型公司（50–300 人销售）</h3><p><strong>特点：</strong></p><ul><li>开始有多地区、多产品线；</li><li>强调业绩可预测、流程可复制；</li><li>希望一套系统支撑未来 3–5 年。</li></ul><p><strong>选型建议：</strong></p><ul><li><p>优先考虑：</p><ul><li>强大的流程管理和审批机制；</li><li>多团队协作、区域与配额管理；</li><li>较完善的自动化、线索打分和预测能力；</li><li>营销、客服与财务可以逐步打通。</li></ul></li></ul><p><strong>重点关注：</strong></p><ul><li>权限体系和多维度数据分析；</li><li>定制与低代码能力，能否跟上业务创新节奏；</li><li>集成生态：是否有你需要的常用工具插件。</li></ul><h3>5.3 大型与跨国企业（300+ 人销售）</h3><p><strong>特点：</strong></p><ul><li>组织复杂、层级多、流程长；</li><li>强调全球合规、安全与统一标准；</li><li>IT 架构复杂，已有大量企业系统。</li></ul><p><strong>选型建议：</strong></p><ul><li>通常会考虑 Gartner Magic Quadrant 里的“领导者”，比如传统意义上的大型 CRM 厂商；</li><li><p>强调：</p><ul><li>安全与合规（ISO、SOC、数据主权）；</li><li>跨地域、多语言、多币种支持；</li><li>与现有 ERP、HR、财务系统深度整合；</li><li>可扩展性与全球合作伙伴生态。</li></ul></li></ul><p><strong>重点关注：</strong></p><ul><li>大规模实施与变更管理经验；</li><li>供应商在你所在行业的标杆案例；</li><li>长期路线图和产品持续迭代能力。</li></ul><hr/><h2>📊 第六步：别忽略的“软因素”——成功实施比选对产品更难</h2><p>很多调研（包括哈佛商业评论和麦肯锡的案例研究）都指出：</p><blockquote>“CRM 项目失败，70% 原因是组织和管理问题，而不是技术。”</blockquote><p>所以，除了选产品，你还需要：</p><h3>6.1 高层背书与项目负责人</h3><ul><li>需要有一个对业务结果负责的“项目老板”（通常是销售 VP 或市场/营收负责人），而不是由 IT 单独驱动；</li><li><p>高层需要明确表达：</p><ul><li>“CRM 是公司的统一客户系统”；</li><li>“所有销售相关数据必须进入 CRM 才视为有效”；</li><li>“采用度将作为团队绩效管理的一个参考维度”。</li></ul></li></ul><h3>6.2 销售参与设计，避免“只为管理层服务的系统”</h3><ul><li>在流程设计和字段设置阶段，多邀请一线销售参与；</li><li><p>问他们：</p><ul><li>哪些字段他们愿意填？</li><li>哪些信息可以系统自动获取？</li><li>哪些页面布局最顺手？</li></ul></li></ul><p><strong>原则：</strong>  <br/>能自动采集就不让销售手工填；  <br/>能通过选项就不用自由文本。</p><h3>6.3 培训与持续优化机制</h3><ul><li>首周：集中培训 + 实战演练（用真实客户做操作演练）；</li><li>首月：每周收集使用反馈，调整字段、流程与自动化规则；</li><li><p>之后：</p><ul><li>每季度回顾一次——哪些报表没人看？哪些自动化没触发价值？</li><li>每年做一次升级评估——是否启用新的模块（如 CPQ、MA、客服）或 AI 能力。</li></ul></li></ul><hr/><h2>🧾 结语：2026 年好的 CRM，不只是“系统”，而是你的增长操作系统</h2><p>Gartner 把 CRM 定义为“支持客户关系生命周期管理的一整套能力”，而不仅仅是一个软件；Forrester 和 IDC 也在反复强调：<strong>真正有价值的 CRM，是将市场、销售、客户成功和财务连接在一起的营收中枢</strong>。</p><p>为你的团队选对 CRM，本质上是在回答三个问题：</p><ol><li><p><strong>它能否帮助销售更容易成交？</strong></p><ul><li>更少的录入，更多的洞察与提醒；</li><li>更清晰的节奏和下一步行动。</li></ul></li><li><p><strong>它能否让管理层看清收入机器的运行状态？</strong></p><ul><li>可预测的业绩；</li><li>找得到问题环节（线索质量？跟进频率？报价阶段？）。</li></ul></li><li><p><strong>它能否在未来三到五年支撑你的业务演化？</strong></p><ul><li>当你增加新产品、新区域、新团队时，不用推倒重来；</li><li>当你想用 AI、用自动化、用数据做更聪明的决策时，它已经准备好了。</li></ul></li></ol><p>如果把这篇“终极指南”浓缩成一句话，那就是：</p><blockquote><strong>先想清楚你要解决什么业务问题，再用权威评估维度做严谨对比，用小步试点验证，然后带着销售一起，把 CRM 变成整个团队的增长操作系统。</strong></blockquote><p>这样，无论你最终选的是哪一家厂商，你都能在 2026 年之后，持续从这套系统里，看到越来越清晰、越来越可复制的增长路径。</p>]]></description></item><item>    <title><![CDATA[良许的2025年：二次创业 良许 ]]></title>    <link>https://segmentfault.com/a/1190000047521971</link>    <guid>https://segmentfault.com/a/1190000047521971</guid>    <pubDate>2026-01-05 11:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>大家好，我是良许。</p><p>熟悉我的朋友都知道，每一年年末的时候我都会写年终总结，除了创业低谷的2024年</p><p>坐在这个130平的新办公室里，看着窗外福州的夜景，突然有种恍如隔世的感觉。2025年就这么过去了？我掐指一算，好像昨天还在那个10平米的"鸽子笼"里录课，今天就已经坐拥"豪华办公室"了。</p><p>人生啊，真的很奇妙。</p><h2>1. 二次创业</h2><p>2018年，我一边在500强上班一边写公众号，从此踏上了创业的道路。后来转战抖音直播，开始尝试知识付费。虽然有起有伏，但一切还算顺利。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521973" alt="" title=""/></p><p>前两年我跟另一位博主合作，两个人撸起袖子加油干。结果你懂的，合伙创业这事儿，就像谈恋爱，开始都是"我中有你，你中有我"，后来就变成了“你走你的阳关道，我过我的独木桥"。</p><p>所以，2025年，我又双叒叕创业了。</p><p>对，<strong>二次创业</strong>。</p><p>说实话，当时心里也慌。一个人扛着整个公司，压力大到每天早上醒来第一件事不是刷牙，而是看账户余额够不够发工资。但你知道吗？人有时候就是这么贱，越是压力大，越是想证明自己。</p><p>我就不信了，一个搞了这么多年技术的程序员，还能饿死在代码里？</p><p>跟合作者的两年合作以来，让我彻底摸清了知识付费的门道，再结合自己的专业技能，我决定继续深耕<strong>嵌入式知识付费</strong>这条赛道，让学生能以更低的成本学习嵌入式。</p><p>不搞那些花里胡哨的，就踏踏实实教技术。毕竟，程序员最懂程序员的痛——什么培训机构都说自己牛逼，结果学完了还是不会写代码。我要做的，就是让每个学员学完之后，能真正上手干活。</p><h2>2. 换办公场地</h2><p>说起办公室，我得好好吐槽一下。</p><p>原来那个10平米的地方，真的是小到什么程度呢？我坐在椅子上伸个懒腰，手能碰到对面的墙。团队开会？不存在的，最多站三个人就满了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521974" alt="" title="" loading="lazy"/></p><p>但说实话，那个小破地方，我还挺怀念的。</p><p>那时候就我和小伙伴们，挤在一起录课、剪视频、回答学员问题。累了就点个外卖，几个人围着一张小桌子，边吃边聊下一步怎么干。虽然挤，但很温馨。那种感觉，就像大学时候几个哥们挤在宿舍里通宵打游戏，穷但快乐。</p><p>后来业务慢慢上了正轨，我寻思着：不能总让兄弟们这么憋屈吧？</p><p>于是咬咬牙，换了个<strong>130多平的场地</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521975" alt="" title="" loading="lazy"/></p><p>第一次走进新办公室的时候，我都懵了：这么大？我们几个人怎么填得满？结果现在看，刚刚好。每个人都有自己的工位，录课有专门的录音室，开会有会议室，再也不用担心录课的时候隔壁同事打个喷嚏都能录进去。</p><p>不过说实话，我心里还有个更大的梦想：<strong>2026年，换400平的场地</strong>。</p><p>你可能觉得我在吹牛。但我就是这么个人，有梦想谁都了不起。万一实现了呢？到时候你们来福州，我请你们在我400平的办公室里喝茶。</p><h2>3. 课程增加</h2><p>2025年最累的事情是什么？</p><p><strong>录课</strong>。</p><p>年初的时候，我们只有一门STM32课程，322节课。我当时还挺自豪的，心想：这么多节课，够学员学大半年了吧？</p><p>结果学员们不干了："良许，能不能出个Linux的课？""良许，有没有全栈的课程？""良许，RTOS啥时候安排上？"</p><p>我一看，行吧，你们想学，我就教。</p><p>于是，整个2025年，我就像个陀螺一样转个不停。录课、剪辑、测试、上线，再录课、再剪辑、再测试、再上线……</p><p>到年底一统计，我自己都吓了一跳：<strong>16门课程，近1500节课</strong>。</p><p>1500节啊兄弟们！我算了一下，平均每天要录4节课。有时候录到嗓子冒烟，喝口水继续录；有时候录到半夜，困得眼睛都睁不开，但想到学员们在等，又硬撑着录完。</p><p>不过累归累，看到课程体系一点点完善，心里还是挺爽的。</p><p>现在我们的课程已经覆盖了<strong>嵌入式三个方向</strong>：</p><ul><li><strong>单片机方向</strong>：从入门到精通，手把手教你玩转单片机</li><li><strong>ARM-Linux方向</strong>：驱动开发、系统移植，样样精通</li><li><strong>全栈方向</strong>：单片机+Linux，做个嵌入式全栈工程师</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521976" alt="" title="" loading="lazy"/></p><p>说实话，这三个方向的课程录完，我感觉自己的技术又上了一个台阶。教别人的过程，其实也是自己学习的过程。每次为了讲清楚一个知识点，我都要翻大量的资料，做各种实验。</p><p>有时候我也会想：我这是何苦呢？</p><p>但每次看到学员们在群里说"良许，我找到工作了""良许，我升职加薪了"，我就觉得，值了。</p><h2>4. 2026年的规划</h2><p>说完2025年，再聊聊2026年的规划。</p><p>首先，<strong>完善课程</strong>。</p><p>三个方向的课程还没录完，2026年要继续肝。而且我还要加三个新方向：<strong>FOC（电机控制）、BMS（电池管理系统）、FPGA</strong>。</p><p>你可能要问了：良许，你疯了吗？已经这么累了还要加课？</p><p>我的回答是：对，我就是疯了。</p><p>但这种疯，是有理由的。嵌入式这个行业，技术更新太快了。你不学新东西，就会被淘汰。我希望我的学员们，学完我的课程之后，不管去哪个公司面试，都能底气十足地说："这个我会。"</p><p>其次，<strong>扩大流量</strong>。</p><p>目前我们主要是通过直播宣传课程。但说实话，直播这事儿，太累了。每次直播都要准备好几个小时，讲完了还要回答各种问题。而且直播的覆盖面有限，很多人根本不知道我们。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521977" alt="" title="" loading="lazy"/></p><p>所以2026年，我打算<strong>通过大量文章、短视频来分享知识</strong>。</p><p>一方面，可以让更多人了解我们的课程；另一方面，也能帮助更多的程序员学到真正有用的技术。毕竟，我做课程的初心，不是为了赚钱（当然赚钱也很重要），而是希望能帮助更多像我一样的程序员，在这个行业里站稳脚跟。</p><h2>5. 最后</h2><p>2025年，对我来说，是重新出发的一年。</p><p>从合伙到单干，从10平到130平，从322节课到1500节课，每一步都走得不容易。但回头看看，我不后悔。</p><p>因为我知道，<strong>只有不断折腾，才能不断成长</strong>。</p><p>如果你也是一个程序员，如果你也在为了梦想而奋斗，我想对你说：</p><p><strong>别怕失败，别怕重新开始。</strong></p><p>人生那么长，多试几次又何妨？就算摔了跟头，爬起来拍拍土，继续往前走。总有一天，你会感谢那个不放弃的自己。</p><p>2026年，我会继续录课、继续分享、继续折腾。</p><p>你呢？</p><p>要不要一起，<strong>再次出发</strong>？</p>]]></description></item><item>    <title><![CDATA[国产SSL证书申请步骤 南柯 ]]></title>    <link>https://segmentfault.com/a/1190000047521592</link>    <guid>https://segmentfault.com/a/1190000047521592</guid>    <pubDate>2026-01-05 10:09:00</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>1. 选择证书类型</strong><br/>根据需求选择合适的SSL证书类型：<br/>域名验证（DV）：适用于个人网站或博客。组织验证（OV）：适用于企业官网。扩展验证（EV）：适用于金融、电商等对安全性要求高的网站。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521594" alt="图片" title="图片"/></p><p><strong>2. 选择证书提供商</strong><br/>选择国内知名的SSL证书提供商。<br/>→<strong>国产SSL证书申请：打开JoySSL官网，填写注册码230976完成注册，获取证书。</strong></p><p><strong>3. 提交申请</strong><br/>在证书提供商官网提交申请，上传CSR文件并填写相关信息。</p><p><strong>4. 完成验证</strong><br/>根据证书类型，完成相应的验证流程：<br/>DV证书：验证域名所有权，通常通过DNS或邮件验证。OV证书：验证域名和组织信息，需提供营业执照等文件。EV证书：验证最为严格，需提供详细的组织信息和法律文件。</p><p><strong>5. 下载并安装证书</strong><br/>验证通过后，下载SSL证书文件，并在服务器上安装。常见的安装方式包括：<br/>Apache：配置httpd.conf文件。Nginx：配置nginx.conf文件。IIS：通过IIS管理器导入证书。</p><p><strong>6. 测试证书</strong><br/>使用SSL检测工具（如SSL Labs）测试证书是否正确安装，确保网站可通过HTTPS访问。</p><p><strong>7. 定期更新</strong><br/>SSL证书通常有效期为1年，需在到期前及时更新，确保持续的安全保护。</p><p><strong>总结</strong><br/>国产SSL证书申请流程简单，选择合适类型和提供商，生成CSR文件，完成验证并安装证书，即可提升网站安全性。<br/>注意：具体操作可能因服务器环境和证书提供商有所不同，建议参考官方文档或联系技术支持。</p>]]></description></item><item>    <title><![CDATA[2026热门CRM系统综合盘点，七强功能对比分析 正直的炒饭 ]]></title>    <link>https://segmentfault.com/a/1190000047521613</link>    <guid>https://segmentfault.com/a/1190000047521613</guid>    <pubDate>2026-01-05 10:08:10</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在数字化转型背景下，CRM（客户关系管理）已从“销售工具”升级为“企业全链路协同引擎”，覆盖<strong>客户</strong> <strong>全生命周期管理</strong> <strong>（</strong> <strong>CLM</strong> <strong>）、销售过程自动化（SFA）、数据决策、上下游协同、生产联动</strong>五大核心维度。本文选取<strong>超兔一体云、Salesforce、</strong> <strong>SAP</strong> <strong>、Microsoft Dynamics 365 CRM、金蝶、Zoho CRM、HubSpot CRM</strong>七大主流品牌，从专业深度视角展开横向对比，为不同场景企业提供选型参考。</p><h2>一、核心维度对比框架</h2><p>本文围绕CRM的“业务闭环能力”<strong>设计对比逻辑，聚焦以下五大维度的</strong>功能深度、行业适配性、协同效率：</p><table><thead><tr><th>维度</th><th>核心评估指标</th></tr></thead><tbody><tr><td>客户全生命周期管理</td><td>获客渠道覆盖、客户画像精度、培育-成交-售后链路完整性、复购激活能力</td></tr><tr><td>销售过程自动化</td><td>线索处理效率、流程自定义能力、AI辅助决策深度、财务-销售联动性</td></tr><tr><td>数据仪表盘与业务报表</td><td>数据整合能力、自定义自由度、实时性、异常预警能力</td></tr><tr><td>上下游管理</td><td>供应商/客户协同深度、采购-销售-库存联动、分销体系支持</td></tr><tr><td>生产管理</td><td>生产计划联动、报工-质检闭环、成品库存同步、销售-生产-仓储一体化</td></tr></tbody></table><h2>二、各维度深度对比</h2><h3>（一）客户全生命周期管理（CLM）：从“触点覆盖”到“精准运营”的较量</h3><p>CLM的核心是<strong>打通“获客-培育-成交-售后-复购”全链路数据</strong>，实现客户价值最大化。各品牌的差异在于<strong>渠道整合能力、行业适配功能</strong>：</p><h4>1. 超兔一体云：中小制造/贸易企业的“精准获客+深度运营”解决方案</h4><p>超兔的CLM围绕“B2B场景痛点”<strong>设计，核心优势是</strong>“渠道精准性+客户背景穿透”：</p><ul><li><strong>获客端</strong>：覆盖百度、抖音、微信、工商搜客等10+集客渠道，自动抓取线索（如巨量引擎注册表单），并通过<strong>手机号/</strong> <strong>IP</strong> <strong>归属地</strong>分配线索；</li><li><strong>培育端</strong>：支持<strong>自定义客户画像</strong>（如行业、规模、采购频率），自动补全工商信息（天眼查/百度接口）、微信/支付宝头像昵称，甚至工商地址经纬度标记；</li><li><strong>售后与复购</strong>：通过<strong>RFM</strong> <strong>分析</strong>（最近一次消费、消费频率、消费金额）精准回访，触发复购预警，维修工单与外勤联动，解决制造企业“售后响应慢”痛点。</li></ul><p><strong>流程图（超兔CLM链路）</strong> ：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521615" alt="" title=""/></p><pre><code>flowchart LR
    A[多渠道获客：百度/抖音/微信/工商搜客] --&gt; B[线索处理：自动抓取+查重+归属地分配]
    B --&gt; C[培育：客户画像+工商补全+客池分类（需求培养/有需求/上首屏）]
    C --&gt; D[成交：跟单模型（三一客/商机/项目）+合同订单]
    D --&gt; E[售后：客服总控+维修工单+外勤拜访]
    E --&gt; F[复购：RFM分析+流失预警+精准营销]</code></pre><h4>2. Salesforce：大型企业的“AI驱动全链路”解决方案</h4><p>Salesforce的CLM以“Einstein GPT+统一客户数据库”为核心，适合全球化、多业态企业：</p><ul><li><strong>统一视图</strong>：整合销售、营销、服务数据，形成360°客户画像，支持跨部门协同（如营销团队查看销售跟进记录）；</li><li><strong>AI赋能</strong>：Einstein GPT可自动生成客户互动建议（如“客户浏览了产品页3次，建议发送折扣邮件”），甚至预测客户 churn（流失）风险；</li><li><strong>渠道覆盖</strong>：支持全球多渠道（邮件、电话、社交媒体、线下活动），适合跨国企业的本地化运营。</li></ul><h4>3. SAP：制造/能源企业的“ERP联动全链路”解决方案</h4><p>SAP的CLM核心是“与ERP深度绑定”，解决大型企业“客户数据与供应链/财务割裂”的痛点：</p><ul><li><strong>数据联动</strong>：客户资料自动同步ERP的库存、财务数据（如客户信用额度与发货权限联动）；</li><li><strong>B2B适配</strong>：支持复杂B2B场景（如多部门协同跟进、长周期项目），线索分配与报价管理符合制造业标准化流程；</li><li><strong>售后协同</strong>：售后工单自动关联ERP的维修配件库存，避免“配件缺货导致售后延迟”。</li></ul><h4>4. 金蝶：成长型企业的“多类型客户覆盖”解决方案</h4><p>金蝶的CLM聚焦“国内中小企业的多样化客户场景” <strong>，支持</strong>消费客户、中间客户、公利客户三类群体管理：</p><ul><li><strong>多渠道获客</strong>：通过金蝶云星辰的“线索发现”工具挖掘潜在客户，整合微信、门店、电商渠道；</li><li><strong>客户价值分析</strong>：通过“客户分群”功能（如高价值客户、沉睡客户）推送个性化营销（如老客户专属折扣）；</li><li><strong>业财一体化</strong>：客户订单自动同步财务系统，实现“销售-收款-开票”闭环。</li></ul><h4>5. 其他品牌对比</h4><ul><li><strong>Microsoft Dynamics 365 CRM</strong>：全球化适配（多语言/多时区），支持多渠道线索整合（如LinkedIn、Outlook）；</li><li><strong>Zoho CRM</strong>：中小团队友好，360°视图整合沟通记录（邮件、电话、聊天），适合轻量级运营；</li><li><strong>HubSpot CRM</strong>：海外营销见长，整合Facebook、Twitter、SEO等渠道，适合跨境电商/ SaaS企业。</li></ul><h3>（二）销售过程自动化（SFA）：从“流程标准化”到“智能决策”的升级</h3><p>SFA的核心是<strong>减少“低价值人工操作”</strong> ，将销售精力集中在“高价值客户”上。各品牌的差异在于“流程自定义能力+行业场景适配”：</p><h4>1. 超兔一体云：小单快单与复杂项目的“双模型自动化”</h4><p>超兔的SFA围绕“不同单量场景”<strong>设计，核心是</strong>“三一客模型+智能应收”：</p><ul><li><strong>小单快单场景</strong>：独创“三一客模型”（三定：定性、定级、定量），跟踪关键节点自定义（如“客户3天未回复，提醒发送跟进短信”）；</li><li><strong>复杂项目场景</strong>：支持<strong>多方项目模型</strong>（如涉及供应商、客户、项目组的大型工程），在一个视图内管理项目进度、合同、采购、收支；</li><li><strong>财务联动</strong>：订单生成后自动触发<strong>智能应收</strong>（如签约/开票/发货触发应收，自动拆分多期金额），并关联客户信用度（信用不足限制发货）。</li></ul><p><strong>流程图（超兔SFA链路）</strong> ：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521616" alt="" title="" loading="lazy"/></p><pre><code>flowchart LR
    A[线索获取] --&gt; B[自动处理：转化为客户/待办/订单]
    B --&gt; C[分配提醒：自动通知销售]
    C --&gt; D[跟单自动化：三一客（小单）/商机（中长单）/项目（复杂单）]
    D --&gt; E[订单执行：自动锁库+采购计划+供应商直发]
    E --&gt; F[财务管控：应收触发+信用预警+回款联动]</code></pre><h4>2. Salesforce：大型企业的“低代码流程定制”解决方案</h4><p>Salesforce的SFA以“Flow Builder低代码工具”<strong>为核心，支持</strong>复杂流程自定义：</p><ul><li><strong>线索处理</strong>：通过Flow Builder设置“线索分配规则”（如“北京地区线索分配给销售A”），自动触发提醒（如“线索未处理24小时，通知销售经理”）；</li><li><strong>AI辅助</strong>：Einstein线索评分系统根据客户行为（如浏览产品页、下载白皮书）打分，优先处理高分线索；</li><li><strong>合同管理</strong>：支持电子签名（DocuSign集成），合同审批流程自动关联销售数据（如“合同金额超过10万，需销售总监审批”）。</li></ul><h4>3. SAP：B2B企业的“标准化流程”解决方案</h4><p>SAP的SFA聚焦“B2B长周期订单” <strong>，核心是</strong>“流程标准化+供应链联动”：</p><ul><li><strong>线索与报价</strong>：线索分配后自动生成报价单，支持<strong>多版本报价</strong>（如针对不同客户层级的折扣）；</li><li><strong>订单联动</strong>：销售订单自动同步ERP的库存数据（如“库存不足，提醒销售与客户沟通延迟发货”）；</li><li><strong>信用管理</strong>：根据客户历史回款情况设置信用额度，超过额度自动冻结订单。</li></ul><h4>4. 其他品牌对比</h4><ul><li><strong>Microsoft Dynamics 365 CRM</strong>：AI驱动的“跟进建议”（如“客户3天未联系，建议发送产品案例”），适合团队协作；</li><li><strong>Zoho CRM</strong>：“蓝图功能”设计复杂流程（如“线索-商机-订单”的阶段跳转），Zia AI自动发送跟进邮件；</li><li><strong>HubSpot CRM</strong>：线索评分系统+自动化邮件模板（如“客户下载白皮书后，自动发送跟进邮件”），适合海外营销场景。</li></ul><h3>（三）数据仪表盘与业务报表：从“数据展示”到“决策支撑”的跨越</h3><p>数据能力的核心是“整合多源数据+自定义分析+异常预警” <strong>，各品牌的差异在于</strong>“数据深度+易用性”：</p><h4>1. 超兔一体云：中小企业的“无技术门槛”数据分析</h4><p>超兔的报表系统围绕“业务人员友好性”<strong>设计，核心是</strong>“多表聚合+自定义卡片”：</p><ul><li><strong>数据引擎</strong>：支持<strong>多表聚合</strong>（如销售+采购+财务数据关联）、<strong>关联表复合查询</strong>（如“查询某客户的所有订单与对应的采购单”）；</li><li><strong>自定义仪表盘</strong>：通过“数字卡片+图表卡片”自定义关键指标（如销售额、签约客户数、市场活动转化率），实时更新；</li><li><strong>异常预警</strong>：通过“单日KPI引擎”监控关键指标（如“今日销售额低于目标20%，自动提醒销售团队”）。</li></ul><h4>2. Salesforce：大型企业的“深度数据挖掘”解决方案</h4><p>Salesforce的报表系统以“动态仪表盘+Einstein分析”为核心：</p><ul><li><strong>动态仪表盘</strong>：支持拖拽自定义，展示“销售额同比增长”“销售漏斗转化率”等关键指标；</li><li><strong>报表覆盖</strong>：提供70+可定制报表（如销售业绩表、营销效果表、客户服务表），支持导出Excel/PDF；</li><li><strong>AI预警</strong>：Einstein分析系统自动识别销售异常（如“某销售的成单率突然下降10%”），并给出建议（如“检查线索质量”）。</li></ul><h4>3. Microsoft Dynamics 365 CRM：“Power BI集成”的可视化分析</h4><p>Microsoft的报表系统核心是“Power BI深度集成”：</p><ul><li><strong>数据整合</strong>：整合CRM、ERP、Excel等多源数据，生成“销售趋势图”“客户分布地图”等可视化报表；</li><li><strong>实时性</strong>：Power BI仪表盘实时更新数据，支持“钻取”（如点击“销售额”查看具体客户订单）；</li><li><strong>自定义</strong>：通过Power Query工具清洗数据，生成符合企业需求的报表（如“按地区划分的销售业绩表”）。</li></ul><h4>4. 其他品牌对比</h4><ul><li><strong>金蝶</strong>：支持Excel可视化动态报表全自动生成，适合习惯用Excel的企业；</li><li><strong>Zoho CRM</strong>：内置BI工具，支持无技术门槛的自定义分析，Zia AI预测销售异常；</li><li><strong>HubSpot CRM</strong>：展示营销效果（如SEO带来的线索量）、销售绩效（如每个销售的成单率），适合轻量级分析。</li></ul><h3>（四）上下游管理：从“数据传递”到“全流程协同”的突破</h3><p>上下游管理的核心是<strong>打通“企业-供应商-客户”数据链路</strong>，实现“采购-销售-库存”协同。各品牌的差异在于“协同深度+行业场景适配”：</p><h4>1. 超兔一体云：中小制造企业的“OpenCRM共生平台”</h4><p>超兔的上下游管理以“OpenCRM平台”<strong>为核心，实现</strong>“供应商/客户直接参与业务”：</p><ul><li><strong>供应商协同</strong>：供应商可通过OpenCRM参与“询价比价”（上传报价单）、“采购单对账”（确认采购数量/金额），系统自动生成“供应商评级雷达图”（如价格、交货时间、质量）；</li><li><strong>客户协同</strong>：客户可通过OpenCRM查看订单进度（如“已发货，预计3天到达”）、确认收货、提交售后工单；</li><li><strong>三流合一</strong>：采购单、物流单、对账单一键关联，避免“数据不一致”问题。</li></ul><h4>2. SAP：大型制造企业的“ERP联动”解决方案</h4><p>SAP的上下游管理核心是“与ERP深度绑定”：</p><ul><li><strong>采购协同</strong>：销售订单自动触发采购计划（如“客户下单100台设备，自动生成采购100个零部件的计划”）；</li><li><strong>库存联动</strong>：库存数据实时同步到CRM（如“某产品库存不足，提醒销售与客户沟通延迟发货”）；</li><li><strong>供应商管理</strong>：通过ERP的“供应商主数据”管理供应商信息（如联系方式、付款条件），采购单自动关联供应商数据。</li></ul><h4>3. 金蝶：成长型企业的“全链路协同”解决方案</h4><p>金蝶的上下游管理以“金蝶云·星瀚平台”<strong>为核心，拉通</strong>“客户-物料-供应商”全链路：</p><ul><li><strong>数据协同</strong>：客户订单自动同步到生产计划、采购计划，避免“信息孤岛”；</li><li><strong>供应商管理</strong>：支持“供应商评分”（如质量、交货时间），采购单自动分配给高分供应商；</li><li><strong>分销管理</strong>：通过“金蝶云·星辰”支持“社交裂变分销”（如导购分享商品链接，成交后获得佣金）。</li></ul><h4>4. 其他品牌对比</h4><ul><li><strong>有赞</strong>：聚焦“供货分销”（社交裂变）与“跨境解决方案”（境外商品引入），适合电商企业；</li><li><strong>Salesforce/Zoho</strong>：主要通过生态集成（如SAP ERP、电商平台）实现协同，无专门上下游功能；</li><li><strong>HubSpot</strong>：不涉及上下游管理，侧重前端营销与销售。</li></ul><h3>（五）生产管理：从“订单联动”到“全闭环”的能力</h3><p>生产管理是<strong>制造企业CRM的核心差异化需求</strong>，要求“销售订单-生产计划-报工-质检-成品入库”全联动。各品牌的差异在于“生产模块原生性+与CRM的联动深度”：</p><h4>1. 超兔一体云：制造企业的“MES集成+全闭环”解决方案</h4><p>超兔的生产管理核心是“与MES系统联动” <strong>，实现</strong>“销售-生产-仓储-采购”一体化：</p><ul><li><strong>生产计划</strong>：销售订单自动生成生产计划（正排/倒排），系统根据“订单交付时间”安排工序（如“客户要求10天交付，从末道工序倒排计划”）；</li><li><strong>报工与质检</strong>：支持<strong>小组计件报工</strong>（班组长手机端提交），逐工序质检（记录合格/不合格数量、不良原因），仅合格成品可入库；</li><li><strong>库存同步</strong>：成品入库数量自动同步CRM库存，销售可实时查看“某产品库存”（如“库存有50台，可接受50台订单”）。</li></ul><p><strong>流程图（超兔生产管理链路）</strong> ：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521617" alt="" title="" loading="lazy"/></p><pre><code>flowchart LR
    A[销售订单] --&gt; B[生产计划：正排/倒排+工序安排]
    B --&gt; C[物料管理：自动计算领料数量+领料/退料]
    C --&gt; D[生产报工：小组计件+手机端操作]
    D --&gt; E[生产质检：逐工序质检+不良记录]
    E --&gt; F[成品入库：合格成品+库存同步]
    F --&gt; G[销售联动：库存更新+订单交付]</code></pre><h4>2. SAP：大型制造企业的“ERP生产模块”解决方案</h4><p>SAP的生产管理依赖“SAP ERP系统” <strong>，与CRM联动实现</strong>“销售需求-生产计划”同步：</p><ul><li><strong>生产计划</strong>：销售订单自动生成“主生产计划（MPS）”，系统根据库存数据调整生产数量（如“库存有20台，需生产80台”）；</li><li><strong>车间管理</strong>：支持“车间作业控制（SFC）”，跟踪每道工序的进度（如“工序1已完成，进入工序2”）；</li><li><strong>质量管控</strong>：通过“质量管理（QM）”模块记录质检数据，不合格产品自动触发“返工流程”。</li></ul><h4>3. 金蝶：成长型企业的“ERP生产管理”解决方案</h4><p>金蝶的生产管理通过“金蝶ERP系统”实现，与CRM联动：</p><ul><li><strong>生产计划</strong>：销售订单自动同步到生产计划，系统根据“销售预测”调整生产数量；</li><li><strong>物料管理</strong>：自动计算生产所需物料数量，生成“领料单”；</li><li><strong>成品入库</strong>：合格成品入库后，自动更新CRM库存，销售可实时查看。</li></ul><h4>4. 其他品牌对比</h4><ul><li><strong>Salesforce/Zoho/HubSpot</strong>：无原生生产管理功能，需第三方插件；</li><li><strong>Microsoft Dynamics 365 CRM</strong>：生产管理功能较弱，需集成第三方ERP。</li></ul>]]></description></item><item>    <title><![CDATA[国产SSL证书申请步骤指南 SSL证书的小韩 ]]></title>    <link>https://segmentfault.com/a/1190000047521622</link>    <guid>https://segmentfault.com/a/1190000047521622</guid>    <pubDate>2026-01-05 10:07:15</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img width="723" height="381" referrerpolicy="no-referrer" src="/img/bVdjw8M" alt="" title=""/></p><p><strong>1. 选择证书类型</strong></p><p>根据需求选择合适的SSL证书类型：</p><p><strong>域名验证（DV）</strong> ：适用于个人网站或博客。</p><p><strong>组织验证（OV）</strong> ：适用于企业官网。</p><p><strong>扩展验证（EV）</strong> ：适用于金融、电商等对安全性要求高的网站。</p><p><strong>2. 选择证书提供商</strong></p><p>选择国内知名的SSL证书提供商。</p><p>国产SSL证书申请：进入<strong>JoySSL</strong>证书服务商官网，<strong>注册账号</strong>，注册时可以填写<strong>注册码230959</strong>获取优惠券和技术服务。</p><p><strong>3. 提交申请</strong></p><p>在证书提供商官网提交申请，上传CSR文件并填写相关信息。</p><p><strong>4. 完成验证</strong></p><p>根据证书类型，完成相应的验证流程：</p><p><strong>DV证书</strong>：验证域名所有权，通常通过DNS或邮件验证。</p><p><strong>OV证书</strong>：验证域名和组织信息，需提供营业执照等文件。</p><p><strong>EV证书</strong>：验证最为严格，需提供详细的组织信息和法律文件。</p><p><strong>5. 下载并安装证书</strong></p><p>验证通过后，下载SSL证书文件，并在服务器上安装。常见的安装方式包括：</p><p><strong>Apache</strong>：配置httpd.conf文件。</p><p><strong>Nginx</strong>：配置nginx.conf文件。</p><p><strong>IIS</strong>：通过IIS管理器导入证书。</p><p><strong>6. 测试证书</strong></p><p>使用SSL检测工具（如SSL Labs）测试证书是否正确安装，确保网站可通过HTTPS访问。</p><p><strong>7. 定期更新</strong></p><p>SSL证书通常有效期为1年，需在到期前及时更新，确保持续的安全保护。</p><p><strong>总结</strong></p><p>国产SSL证书申请流程简单，选择合适类型和提供商，生成CSR文件，完成验证并安装证书，即可提升网站安全性。</p>]]></description></item><item>    <title><![CDATA[通配符证书申请指南：一站式守护您的子域名安全 才高八斗的杯子_dS2Fpp ]]></title>    <link>https://segmentfault.com/a/1190000047521653</link>    <guid>https://segmentfault.com/a/1190000047521653</guid>    <pubDate>2026-01-05 10:06:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在数字化时代，网站安全已成为企业生存的基石。当您的业务拓展到多个子域名时，传统SSL证书的管理可能变得繁琐且成本高昂。通配符证书（Wildcard SSL Certificate）正是为解决这一痛点而生的高效安全解决方案。本文将为您详细解析通配符证书的申请流程，助您轻松构建全面的网站安全防护网。</p><p>什么是通配符证书？<br/>通配符证书是一种特殊的SSL/TLS证书，它使用星号（）作为通配符，能保护一个主域名及其所有同级子域名。例如，一张针对“.example.com”的通配符证书，可以同时保护“shop.example.com”、“blog.example.com”、“mail.example.com”等无数个子域名。这种“一证多用”的特性，使其成为拥有多个子域名的组织的理想选择。</p><p>为什么选择通配符证书？<br/>与传统的单域名证书或多域名证书相比，通配符证书具有三大核心优势：</p><p>管理便捷性：只需申请、安装和更新一张证书，即可覆盖所有现有及未来新增的同级子域名</p><p>成本效益：长期来看，比分别为每个子域名购买独立证书更加经济</p><p>灵活扩展：业务扩展时无需重复申请证书，支持快速部署新子域名</p><p>通配符证书申请全流程<br/>第一步：选择证书颁发机构（CA）<br/>市场上有多种CA提供通配符证书，如DigiCert、Sectigo、Let's Encrypt（免费）等。选择时需考虑：</p><p>证书信任度（根证书的普及程度）</p><p>技术支持和服务水平</p><p>价格与预算匹配度</p><p>是否支持您需要的验证方式</p><p>第二步：生成证书签名请求（CSR）<br/>CSR是申请证书的核心文件，包含您的公钥和域名信息。生成步骤：</p><p>在您的服务器上使用OpenSSL等工具生成密钥对</p><p>创建CSR文件，其中Common Name字段应填写通配符格式，如“*.yourdomain.com”</p><p>妥善保管生成的私钥，切勿泄露</p><p>第三步：提交申请与域名验证<br/>向CA提交CSR后，需验证您对域名的所有权。常用验证方式包括：</p><p>DNS验证：在域名DNS记录中添加指定的TXT记录</p><p>文件验证：在网站根目录放置特定验证文件</p><p>邮箱验证：通过管理员邮箱接收验证邮件</p><p>第四步：证书审核与颁发<br/>CA完成验证后，通常需要1小时至数天进行审核（企业级OV/EV证书时间较长）。审核通过后，您将收到包含证书文件（通常为.crt或.pem格式）的邮件。</p><p>第五步：安装与配置证书<br/>将颁发的证书与之前生成的私钥一起安装到服务器。不同服务器的安装方式各异：</p><p>Apache：修改ssl.conf配置文件</p><p>Nginx：更新server块中的ssl_certificate指令</p><p>IIS：通过服务器证书管理器导入<br/>安装后务必重启服务器使配置生效。</p><p>第六步：测试与验证<br/>使用SSL检查工具（如SSL Labs的SSL Test）确认证书安装正确，确保所有子域名均受到保护。</p><p>重要注意事项<br/>通配符范围限制：一张通配符证书只能保护一级子域名。例如“*.example.com”不能保护“sub.sub.example.com”，如需保护多级子域名，需单独申请或使用多张证书。</p><p>安全风险提示：由于通配符证书的私钥可解密所有受保护子域名的通信，一旦私钥泄露，所有子域名都将面临风险。务必采取严格的私钥保护措施。</p><p>免费与付费选择：Let's Encrypt提供免费的通配符证书，但有效期仅90天，需频繁续期。付费证书通常提供1-2年有效期、保险保障和技术支持。</p><p>证书类型选择：根据安全需求选择DV（域名验证）、OV（组织验证）或EV（扩展验证）证书。OV和EV证书显示更详细的企业信息，增强用户信任。</p><p>最佳实践建议<br/>自动化管理：对于使用Let's Encrypt等免费证书的用户，建议使用Certbot等工具实现自动续期</p><p>密钥轮换：定期更换证书密钥，增强长期安全性</p><p>监控更新：建立证书到期提醒系统，避免因证书过期导致服务中断</p><p>分级保护：对核心业务子域名（如支付系统）考虑使用独立证书，实现安全隔离</p><p>通配符证书是现代企业网络安全架构中的高效工具，它能显著简化多子域名环境下的证书管理负担。通过遵循正确的申请流程和实施严格的安全管理措施，您可以构建既安全又高效的网站防护体系，让您的业务在安全的轨道上全速前进。</p>]]></description></item><item>    <title><![CDATA[[大厂实践] 告别微服务 俞凡 ]]></title>    <link>https://segmentfault.com/a/1190000047521671</link>    <guid>https://segmentfault.com/a/1190000047521671</guid>    <pubDate>2026-01-05 10:05:49</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><em>本文介绍了 Twilio Segment 团队将服务端事件转发基础设施从微服务架构迁移为单体架构的实践，介绍了迁移的背景、权衡和需要考虑的方面。原文：<a href="https://link.segmentfault.com/?enc=ZVrZTWU%2Bmtp13mG03VTbag%3D%3D.Tcd%2FbpksV2ND0Tvo2xOrFSbttHT40RyGhu%2Bk0qO%2B8FXETQcKPMWai8yQdpblKmuNnIwxUEk0%2FHJiarQ%2Fvxl50lmb5Fr758UM3EdE2%2FbPQ1b4mNSmUZBhE2SG9vg0SHQ5" rel="nofollow" title="Goodbye Microservices: From 100s of problem children to 1 superstar" target="_blank">Goodbye Microservices: From 100s of problem children to 1 superstar</a></em></blockquote><p>微服务是一种面向服务的软件架构，通过结合多种单一用途、低占用的网络服务构建服务端应用，其宣称的好处包括改进模块化、降低测试负担、更好的功能组合、环境隔离以及开发团队自主性。相反，单体架构将大量功能集中在单一服务中，作为整体进行测试、部署和扩展。</p><p>Twilio Segment 早期就采纳了这一做法，这在某些情况下很有帮助，但我们很快发现，在另一些情况下则不那么理想。</p><p>在 Twilio Segment 早期，<a href="https://link.segmentfault.com/?enc=LrceRCcoLtx9SBdOnG1FNA%3D%3D.iQDT6B%2FTYyp2MW%2BZ3ejpS4d3OhNS0FQrpXk6EFYy6iU%3D" rel="nofollow" title="Twilio Segment Product &quot;产品的核心部分" target="_blank">产品的核心部分</a>达到了临界点，感觉就像是从微服务的大树上掉了下来，撞上了每一根树枝。小团队不仅没有让我们加快速度，反而陷入了爆炸式增长的复杂性中，微服务架构的优势变成了负担。随着速度骤降，缺陷率爆炸式增长。</p><p>团队最终发现无法取得进展，三名全职工程师大部分时间都在维持系统的运转。必须做出改变，本文讲述了团队如何后退一步，采纳了一种产品需求和团队需求高度契合的方法。</p><h2>微服务为何有效</h2><p>Twilio Segment 的客户数据基础设施每秒接收数十万事件，并将其转发到合作伙伴 API，也就是 <strong>服务器端目的地</strong>。这些<a href="https://link.segmentfault.com/?enc=O%2BpMSiFDFzor%2B%2B0ZkSttvQ%3D%3D.scnde9qSCgp%2BjupOjikj7vDS%2FXzJDPsI5RZyu7uQPYSclXDYoOrh94J8NTAWVHxFeoEL2t23CkJeWEfYLm2CrA%3D%3D" rel="nofollow" title="Twilio Segment Destinations Catalog" target="_blank">目的地有一百多种类型</a>，比如 Google Analytics、Optimizely，或自定义 Webhook。 </p><p>多年前这款产品刚推出时，架构非常简单，有一个可以导入事件并将其转发到分布式消息队列的 API，事件是由网页或移动应用生成的 JSON 对象，包含用户及其操作信息。</p><p>消费队列中的事件时，会检查客户设置以决定哪些目的地应接收该事件，随后将其依次发送到每个目的地 API。这很方便，因为开发者只需将事件发送到单个端点 —— Twilio Segment 的 API，而无需对每一个都构建集成，Twilio Segment 会负责向每个目标端点发送请求。</p><p>如果某个请求失败，有时会在稍后尝试再次发送该事件。有些失败可以安全重试，而有些则不行。可重试错误是指目标方可能接受的错误，并且不需要更改请求。例如，HTTP 500、速率限制和超时。不可重试错误是指我们可以确定目的地永远不会接受的请求。例如，无效凭证或缺少必填字段的请求。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521673" alt="" title=""/></p><p>上图展示了队列包含最新事件以及可能的多次重试事件，涵盖所有目的地，导致 <a href="https://link.segmentfault.com/?enc=whXT0CKbBfUDDu8hA9mxVQ%3D%3D.VpZdVJuoLYokdrBKeQBqsRrleijhDuJx6KuMnzTaYnznl0t0tusjom%2FYsSiVH8f9ITRHMTh%2Fa1MEsOXWOtnG5A%3D%3D" rel="nofollow" title="队列头阻塞（head-of-line blocking）" target="_blank">队列头阻塞（head-of-line blocking）</a>。也就是说，在这种情况下，如果某个目的地变慢或宕机，重试会淹没队列，导致所有目的地都出现延迟。</p><p>想象一下，目的地 X 出现了临时问题，每个请求都会出错并超时。这不仅会造成大量尚未到达目的地 X 的请求积压，而且每个失败事件都会被重新放回队列中重试。虽然系统会根据负载自动扩容，但队列深度的突然增加会超过扩容能力，导致最新事件延迟。由于目的地 X 发生了短暂停机，造成所有目的地的发送时间都会增加。客户依赖交付的及时性，因此我们不能承受流水线中任何等待时间的增加。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521674" alt="" title="" loading="lazy"/></p><p>为了解决队列头阻塞问题，团队为每个目的地创建了独立的服务和队列。该新架构包含一个额外的路由进程，接收入站事件并将事件副本分发到每个选定的目的地。如果一个目的地出现问题，只有对应队列会积压，其他目的地不会受到影响。这种微服务式架构将目的地彼此隔离开来，这在某个目的地出现问题时至关重要。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521675" alt="" title="" loading="lazy"/></p><h2>独立仓库的理由</h2><p>每个目标 API 使用不同请求格式，需要自定义事件转换代码以匹配该格式，例如目的地 X 需要在负载中发送 <code>birthday</code> 作为 <code>traits.dob</code>，而我们的 API 则接受 <code>traits.birthday</code>。</p><p>许多现代目标端点采用了 Twilio Segment 的请求格式，使得某些转换相对简单。然而，转换也可能非常复杂，完全取决于目标 API 结构。例如，对于一些较老且规模很大的目的地，需要将数值塞入手工拼接的 XML 负载中。</p><p>最初，当目的地被划分为独立服务时，所有代码都存放在同一个仓库中。一个很大的问题是，如果某个测试失误导致所有目的地的测试都失败，当我们想部署变更时，即使这些失败与变更无关，我们也得花时间修复那个坏掉的测试。针对这一问题，团队决定将每个目的地的代码拆分到各自仓库中。由于所有目的地都已划分为独立的服务，因此这一过渡相当自然。</p><p>拆分到不同仓库让团队能够轻松隔离目标测试套件，这种隔离性使开发团队能够快速维护目的地。</p><h2>扩展微服务和仓库</h2><p>随着时间推移，我们新增了 50 多个目的地，也就是新增了 50 多个仓库。为了减轻开发和维护代码库的负担，我们创建了共享库，让通用转换和功能（如 HTTP 请求处理）可以在各目的地之间更简单、更统一的共享。</p><p>例如，如果我们想获取某个事件中的用户名，可以在任意目的地的代码中调用 <code>event.name()</code>。共享库会检查事件中的属性键名和名称，如果没有，就会检查 <code>firstName</code>、<code>first_name</code> 和 <code>FirstName</code> 这些属性。对姓氏的检查也一样，然后将两者合并成全名。</p><p>共享库让新目标的构建变得更快，统一的共享功能带来的熟悉感让维护工作不再那么麻烦。</p><p>然而新问题开始出现。对共享库的测试和部署变更影响了所有的目的地，维护起来需要大量时间和精力。为了改进库而做出的变更，必须测试和部署数十项服务，是一项风险极高的举动。在时间紧迫时，工程师只会将这些库的更新版本纳入单一目标代码库。</p><p>随着时间推移，共享库的版本开始在不同目标代码库中出现分裂，曾经的巨大好处开始逆转，最终不同服务都使用了共享库的不同版本。我们本可以开发自动化推送变更的工具，但此时不仅开发者生产力下降，我们还开始遇到微服务架构的其他问题。</p><p>另一个问题是，每个服务都有独特的负载模式。有些服务每天处理少量事件，而另一些则每秒处理数千事件。对于处理少量事件的目的地，在遇到意外负载激增时，运维人员必须手动扩大服务规模以满足需求。</p><p>虽然实现了自动扩展，但每个服务对 CPU 和内存资源的需求差异很大，使得调整自动扩展配置更像是艺术而非科学。</p><p>目的地数量持续快速增长，团队平均每月新增三个目的地，这意味着更多的仓库、更多的队列以及更多的服务。由于微服务架构，运维开销随着每个目的地的增加而线性增长。因此，我们决定后退一步，重新思考整个流程。</p><h2>放弃微服务和队列</h2><p>首先考虑的是将现已超过 140 个的微服务整合为单一服务。管理所有这些服务的开销对团队来说是巨大的负担。我们甚至无法睡觉，值班工程师经常被叫起来处理负载激增。</p><p>然而，当时的架构使得迁移到单一服务变得具有挑战性。如果每个目的地有独立队列，每个员工都必须检查每个队列的工作，这会给目的地服务增加复杂性，我们对此感到不放心。这正是 Centrifuge 的主要灵感来源，Centrifuge 将替换所有单独队列，负责将事件发送到单一服务。（注意，Centrifuge 成为了 <a href="https://link.segmentfault.com/?enc=DWgE0NCURYVjvwEva4qxKA%3D%3D.n78jckT7b8fYasNmUFpGa8vrfzIy07Yb82n2SDiDgQBN%2FqeLJDfc8U%2FuHm3KV88J" rel="nofollow" title="Twilow Segment Connections" target="_blank">Connections</a> 的后端基础设施。）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521676" alt="" title="" loading="lazy"/></p><h2>单体仓库迁移</h2><p>鉴于只有一个服务，将所有目标代码迁移到一个仓库中是合理的，这意味着将所有不同的依赖和测试合并到一个仓库中。</p><p>对于 120 个独特依赖，我们承诺为所有目的地提供一个版本。当我们迁移目的地时，会检查它使用的依赖，并更新到最新版本，并修复出现问题的目的地。</p><p>通过这次迁移，我们不再需要追踪依赖版本之间的差异，所有的目的地都使用同一个版本，大大降低了整个代码库的复杂性。维护目的地变得更省时、风险更低。</p><p>我们还希望有一个测试套件，能够快速轻松的运行所有目的地测试，而运行所有测试是之前更新共享库时的主要障碍之一。</p><p>幸运的是，目的地测试的结构都比较相似，有基本的单元测试来验证自定义转换逻辑是否正确，并会向合作伙伴端点执行 HTTP 请求，以验证事件是否如预期出现在目的地。</p><p>回想一下，最初将每个目标代码库分开到独立仓库的动机是为了隔离测试失败。然而，事实证明这是一种虚假的优势，发送 HTTP 请求的测试仍然经常失败。目的地被分开到各自的仓库，几乎没有动力去清理失败的测试。这种糟糕的习惯导致技术债务持续堆积，通常本应只需一两个小时的小变更，最终却需要几天到一周时间才能完成。</p><h2>构建强韧的测试套件</h2><p>测试运行期间向目标端点发出的 HTTP 请求是测试失败的主要原因。像过期证书这样无关的问题不应该让测试失败。我们也从经验中知道，有些目的地端点比其他端点要慢得多。有些目的地的测试时间长达 5 分钟。我们的测试套件覆盖 140 多个目的地，运行时间可能长达一小时。</p><p>为了解决这两个问题，我们基于 <a href="https://link.segmentfault.com/?enc=d7HnXSBfYcXkQ%2BKEMjTCeQ%3D%3D.HJb5aT13AMILsQlhTdUd1sQSmGVvTIImQygy0igW8fsQJSD2v6vj%2FwSo0X3UlnC%2B" rel="nofollow" title="yakbak" target="_blank">yakbak</a> 创建了 Traffic Recorder，负责记录和保存目的地的测试流量。每个测试首次运行时，所有请求及其对应的响应都会被记录到文件中。在后续测试中，文件中的请求和响应会被回放，而不用请求目标端点。这些文件会被记录在仓库中，确保每次变更的测试保持一致。现在测试套件不再依赖互联网上的 HTTP 请求，使得测试更有弹性，成为迁移到单一仓库的必备条件。</p><p>在集成 Traffic Recorder 后，完成所有 140 多个目的地的测试只需要几毫秒。而以前单单完成一个目的地的测试可能都需要几分钟时间。</p><h2>为什么单体有效</h2><p>一旦所有目的地代码都集中在一个仓库中，就可以合并成一个服务。随着每个目的地都集中在同一服务中，开发者生产力大幅提升。我们不再需要为某个共享库的变更部署 140 多个服务，一名工程师可以在几分钟内就完成部署。</p><p>变更速度也证明了这一点。在微服务架构时期，我们对共享库进行了 32 项改进。而在迁移为单体架构一年后，我们已经做了 46 项改进。</p><p>这一变化也优化了我们的运维。由于每个目的地都集中在一个服务中，使得 CPU 和内存密集型的目的地被良好组合在一起，从而让服务扩展更加容易。庞大的算力池能吸收负载峰值，因此团队不需要半夜被叫起来处理问题。</p><h2>权衡</h2><p>从微服务架构转向单体架构带来了巨大进步，但也需权衡利弊：</p><ol><li><strong>错误隔离很难</strong>。由于所有功能都运行在单体中，如果某个目的地出现了导致服务崩溃的 bug，所有目的地的服务都会崩溃。我们有全面的自动化测试，但测试只能做到一定程度。我们目前正在研发一种更为强大的方法，防止一个目的地造成整个服务瘫痪，同时保持所有目的地的整体状态。</li><li><strong>内存缓存效果较差</strong>。此前，每个目的地只提供一项服务，低流量目的地只有少数进程，意味着它们的内存缓存会保持控制平面数据的活跃状态。现在缓存分散在 3000 多个进程中，被命中的可能性大大降低。我们可以用 Redis 之类的工具来解决这个问题，但那又是另一个需要考虑的扩展点。最终，鉴于运维带来的显著收益，我们接受了效率的损失。</li><li><strong>更新依赖版本可能会导致多个目的地被破坏</strong>。虽然把所有东西迁移到一个仓库解决了之前的依赖问题，但意味着如果我们想使用最新版本的库，可能需要更新其他目的地以配合新版本。不过我们认为，值得为这一简单性付出代价。借助全面的自动化测试套件，我们可以快速查看新版本依赖中存在的问题。</li></ol><h2>结论</h2><p>最初的微服务架构曾经有效，通过隔离目的地解决了当时流水线的性能问题。但是随着规模扩大，当需要批量更新时，缺乏合适的工具来测试和部署微服务。结果，我们的开发者生产力迅速下降。</p><p>转向单体架构让我们摆脱了流程中的运维问题，同时显著提升了开发者生产力。不过这个转变绝非轻率，如果想要成功，必须考虑一些因素。</p><ol><li>需要坚实可靠的测试套件，把所有东西放进一个仓库。没有这些，我们会陷入当初决定分开他们时同样的境地。过去不断的测试失败影响了工作效率，我们不希望这种情况再次发生。</li><li>接受单体架构固有的利弊，并确保权衡了两者的优劣，我们必须接受变化带来的一些牺牲。</li></ol><p>在选择微服务还是单体架构时，需要考虑不同的因素。在我们基础设施的某些部分，微服务运行良好，但我们的服务器端目的地恰好说明了这一流行趋势实际上会损害生产力和性能。事实证明，适合我们的解决方案是单体架构。</p><hr/><blockquote>Hi，我是俞凡，一名兼具技术深度与管理视野的技术管理者。曾就职于 Motorola，现任职于 Mavenir，多年带领技术团队，聚焦后端架构与云原生，持续关注 AI 等前沿方向，也关注人的成长，笃信持续学习的力量。在这里，我会分享技术实践与思考。欢迎关注公众号「DeepNoMind」，星标不迷路。也欢迎访问独立站 <a href="https://link.segmentfault.com/?enc=WUG7brHT%2BlIpMKEbwx%2BrMw%3D%3D.CWZv5qMv03UZcZVWeU8niGGxmbe5pQ8RlGhGMakRmHA%3D" rel="nofollow" title="www.DeepNoMind.com" target="_blank">www.DeepNoMind.com</a>，一起交流成长。</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=CQZTPNS9LR8lUrQ1QWmOYQ%3D%3D.FjfP7KWT36EF8R2CQg2khXN0FkOWmt1q4BOwviSS4vM%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[轻量级部署：SpreadJS 包依赖优化与打包体积瘦身秘籍 葡萄城技术团队 ]]></title>    <link>https://segmentfault.com/a/1190000047521692</link>    <guid>https://segmentfault.com/a/1190000047521692</guid>    <pubDate>2026-01-05 10:05:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在前端工程化实践中，打包体积过大始终是困扰开发者的核心痛点：构建时间冗长影响开发效率、服务器存储与带宽成本飙升、浏览器加载延迟直接拉低用户体验。尤其当项目集成 SpreadJS 这类功能强大的表格组件时，全量依赖引入往往导致打包体积突破 26MB，在一定程度上会制约项目性能。</p><p>本文基于 SpreadJS V18.2.5 版本实测，整理出一套从基础优化到极致瘦身的完整方案，涵盖依赖剔除、子包拆分、CDN 加载三大核心方向，无需复杂配置即可实现体积缩减，兼顾实用性与可操作性，助力开发者快速落地生产。</p><h2>一、痛点直击：SpreadJS 全量依赖的体积困局</h2><p>SpreadJS 作为功能完备的前端表格组件，提供了表格编辑、图表、打印、导出、透视表等数多种扩展能力。但全量引入时的资源开销极为显著：</p><ol><li>全量依赖安装需引入 21 个 npm 包，打包体积高达 26.42MB。</li></ol><p>安装依赖：</p><pre><code class="JSON">npm install @grapecity-software/spread-sheets
npm install @grapecity-software/spread-sheets-vue
npm install @grapecity-software/spread-sheets-shapes
npm install @grapecity-software/spread-sheets-charts
npm install @grapecity-software/spread-sheets-datacharts-addon
npm install @grapecity-software/spread-sheets-slicers
npm install @grapecity-software/spread-sheets-print
npm install @grapecity-software/spread-sheets-barcode
npm install @grapecity-software/spread-sheets-pdf
npm install @grapecity-software/spread-sheets-pivot-addon
npm install @grapecity-software/spread-sheets-tablesheet 
npm install @grapecity-software/spread-sheets-ganttsheet
npm install @grapecity-software/spread-sheets-reportsheet-addon 
npm install @grapecity-software/spread-sheets-formula-panel
npm install @grapecity-software/spread-sheets-ai-addon
npm install @grapecity-software/spread-sheets-io
npm install @grapecity-software/spread-sheets-resources-zh
npm install @grapecity-software/spread-sheets-designer-resources-cn
npm install @grapecity-software/spread-sheets-designer
npm install @grapecity-software/spread-sheets-designer-vue
npm install @grapecity-software/spread-sheets-languagepackages</code></pre><p>引入资源：</p><pre><code class="JavaScript">import '@grapecity-software/spread-sheets';
import '@grapecity-software/spread-sheets-shapes';
import '@grapecity-software/spread-sheets-charts';
import '@grapecity-software/spread-sheets-datacharts-addon';
import '@grapecity-software/spread-sheets-slicers';
import '@grapecity-software/spread-sheets-print';
import '@grapecity-software/spread-sheets-barcode';
import '@grapecity-software/spread-sheets-pdf';
import '@grapecity-software/spread-sheets-pivot-addon';
import '@grapecity-software/spread-sheets-tablesheet';
import '@grapecity-software/spread-sheets-ganttsheet';
import '@grapecity-software/spread-sheets-reportsheet-addon';
import '@grapecity-software/spread-sheets-formula-panel';
import '@grapecity-software/spread-sheets-ai-addon';
import '@grapecity-software/spread-sheets-io';
import '@grapecity-software/spread-sheets-resources-zh';
import '@grapecity-software/spread-sheets-designer-resources-cn';
import '@grapecity-software/spread-sheets-designer';
import Designer from '@grapecity-software/spread-sheets-designer-vue'
import '@grapecity-software/spread-sheets-vue'</code></pre><ol><li>本地构建耗时超 26 秒，服务器存储与网络传输成本倍增。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521694" alt="img" title="img"/></p><p>2.浏览器加载时间长，内存占用高，首页渲染延迟直接影响用户留存。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521695" alt="img" title="img" loading="lazy"/></p><p>事实上，大多数场景仅需使用 SpreadJS 的核心功能（如表格编辑、基础计算），全量引入无疑造成了资源浪费。以下优化方案将按 "从易到难，从粗到细" 的顺序，逐步实现体积瘦身。</p><h2>二、五大优化方案：按需取舍，极致压缩</h2><h3>方案一：Designer最少量依赖</h3><p>@grapecity-software/spread-sheets-designer内部依赖了以下包：</p><ul><li>@grapecity-software/spread-sheets-barcode</li><li>@grapecity-software/spread-sheets-shapes</li><li>@grapecity-software/spread-sheets-charts</li><li>@grapecity-software/spread-sheets-languagepackages</li><li>@grapecity-software/spread-sheets-print</li><li>@grapecity-software/spread-sheets-pdf</li><li>@grapecity-software/spread-sheets-io</li></ul><p>那么，在install全量资源的情况下，import较少量的必要资源即可使用Designer。</p><ol><li>安装依赖：</li></ol><pre><code class="JSON">npm install @grapecity-software/spread-sheets
npm install @grapecity-software/spread-sheets-designer
npm install @grapecity-software/spread-sheets-designer-resources-cn
npm install @grapecity-software/spread-sheets-designer-vue
npm install @grapecity-software/spread-sheets-barcode
npm install @grapecity-software/spread-sheets-shapes
npm install @grapecity-software/spread-sheets-charts
npm install @grapecity-software/spread-sheets-languagepackages
npm install @grapecity-software/spread-sheets-print
npm install @grapecity-software/spread-sheets-pdf
npm install @grapecity-software/spread-sheets-io</code></pre><p>2.引入资源：</p><pre><code class="JavaScript">  import '@grapecity-software/spread-sheets-designer/styles/gc.spread.sheets.designer.min.css';
  import GC from '@grapecity-software/spread-sheets';
  import '@grapecity-software/spread-sheets-designer-resources-cn'
  import '@grapecity-software/spread-sheets-designer';
  import Designer from '@grapecity-software/spread-sheets-designer-vue';</code></pre><p>3.优化效果：</p><ul><li>打包后的体积由26.42MB减少至19.92MB，减小了6.5MB，优化效率为24.60%。</li><li>构建时间由26秒缩短至15秒。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521696" alt="img" title="img" loading="lazy"/></p><ul><li>浏览器加载时间从4.3秒缩短至268毫秒，提升约93%。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521697" alt="img" title="img" loading="lazy"/></p><h3>方案二：去除Designer依赖</h3><p>若项目仅需要表格渲染与编辑能力，无需工具栏编辑功能，可直接在全量依赖中剔除提供了工具栏功能的Designer相关依赖。</p><ol><li>安装依赖：</li></ol><pre><code class="JSON">npm install @grapecity-software/spread-sheets
npm install @grapecity-software/spread-sheets-vue
npm install @grapecity-software/spread-sheets-shapes
npm install @grapecity-software/spread-sheets-charts
npm install @grapecity-software/spread-sheets-datacharts-addon
npm install @grapecity-software/spread-sheets-slicers
npm install @grapecity-software/spread-sheets-print
npm install @grapecity-software/spread-sheets-barcode
npm install @grapecity-software/spread-sheets-pdf
npm install @grapecity-software/spread-sheets-pivot-addon
npm install @grapecity-software/spread-sheets-tablesheet 
npm install @grapecity-software/spread-sheets-ganttsheet
npm install @grapecity-software/spread-sheets-reportsheet-addon 
npm install @grapecity-software/spread-sheets-formula-panel
npm install @grapecity-software/spread-sheets-ai-addon
npm install @grapecity-software/spread-sheets-io
npm install @grapecity-software/spread-sheets-resources-zh</code></pre><p>2.引入资源：</p><pre><code class="JavaScript">  import '@grapecity-software/spread-sheets/styles/gc.spread.sheets.excel2013white.css';
  import GC from '@grapecity-software/spread-sheets';
  import '@grapecity-software/spread-sheets-shapes';
  import '@grapecity-software/spread-sheets-charts';
  import '@grapecity-software/spread-sheets-datacharts-addon';
  import '@grapecity-software/spread-sheets-slicers';
  import '@grapecity-software/spread-sheets-print';
  import '@grapecity-software/spread-sheets-barcode';
  import '@grapecity-software/spread-sheets-pdf';
  import '@grapecity-software/spread-sheets-pivot-addon';
  import '@grapecity-software/spread-sheets-tablesheet';
  import '@grapecity-software/spread-sheets-ganttsheet';
  import '@grapecity-software/spread-sheets-reportsheet-addon';
  import '@grapecity-software/spread-sheets-formula-panel';
  import '@grapecity-software/spread-sheets-ai-addon';
  import '@grapecity-software/spread-sheets-io';
  import '@grapecity-software/spread-sheets-resources-zh';
  import '@grapecity-software/spread-sheets-vue';
  import { GcSpreadSheets } from '@grapecity-software/spread-sheets-vue';
  GC.Spread.Common.CultureManager.culture('zh-cn');</code></pre><p>3.优化效果：</p><ul><li>打包后的体积由全量依赖26.42MB减少至18.36MB，减小了8.06MB，优化效率为30.51%。</li><li>构建时间由26秒缩短至20秒。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521698" alt="img" title="img" loading="lazy"/></p><ul><li>浏览器加载时间由4.3秒缩短至2.4秒，提升约44%。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521699" alt="img" title="img" loading="lazy"/></p><h2>方案三：仅使用SpreadJS</h2><p>不考虑图表、形状、各种插件的功能，在仅支持编辑的功能上，只需要@grapecity-software、spread-sheets相关依赖。</p><ol><li>安装依赖：</li></ol><pre><code class="JSON">npm install @grapecity-software/spread-sheets
npm install @grapecity-software/spread-sheets-resources-zh
npm install @grapecity-software/spread-sheets-vue</code></pre><p>2.引入资源：</p><pre><code class="JavaScript">  import '@grapecity-software/spread-sheets/styles/gc.spread.sheets.excel2013white.css';
  import '@grapecity-software/spread-sheets-vue';
  import GC from '@grapecity-software/spread-sheets';
  import '@grapecity-software/spread-sheets-resources-zh';
  import { GcSpreadSheets } from '@grapecity-software/spread-sheets-vue';
  GC.Spread.Common.CultureManager.culture('zh-cn');</code></pre><p>3.优化效果：</p><ul><li>打包后的体积由全量依赖26.42MB减少至5.74MB，减小了20.68MB，优化效率为78.27%。</li><li>构建时间由26秒缩短至5秒。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521700" alt="img" title="img" loading="lazy"/></p><ul><li>浏览器加载时间由4.3秒缩短至70毫秒，提升约98.37%。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521701" alt="img" title="img" loading="lazy"/></p><p>体积减少的同时，所能使用的SpreadJS功能也减少了。在这个基础表格能力基础上，再将需要使用的功能包引入，如搭建积木式按需引入。体积最大时即引入了除Designer外的其他依赖，与<a href="https://link.segmentfault.com/?enc=dFDN6D0Joks8%2BGqCaPPR1w%3D%3D.sUXJWhDyU7rIzG9TVYlZO9Q%2BwX%2BLqBKCFgUa%2BemGXV3NmazdWR73kIBXInIUz2lvrXpZsGcUi6lI1siuOKaiDMWW97T0iwXqOfLXunDlv%2F8wyGK%2FzARXYLqO1SyT5D2CuBQ3vPfxCmhbLKE9VYTZdA%3D%3D" rel="nofollow" target="_blank">去除Designer依赖</a>章节介绍的情况相同。</p><h2>方案四：按需加载子包</h2><p>@grapecity-software/spread-sheets提供了表格能力的基础功能，包括核心编辑、计算引擎、条件格式、数据验证等。在其内部，将这些功能模块化封装，进一步拆分出了相应的功能子包，请参考思维导图了解@grapecity-software/spread-sheets子包树形图：</p><p>暂时无法在飞书文档外展示此内容</p><p><a href="https://link.segmentfault.com/?enc=Ye0rICAlI7UmtnIbfIHslw%3D%3D.60rTdxK9Mo08BNz67gP%2BeXKNN7jucbsoGY%2BX5d%2FkMDjSok2AoDXKnqykT50zHbTIA54chfPo4CGmXrXl5abuAfpBLV5Wc5n9mB3DpXZcXts%3D" rel="nofollow" target="_blank">子包</a>：@grapecity-software/spread-sheets的子包。</p><h3>核心功能-只使用表格</h3><ol><li>安装依赖：</li></ol><pre><code class="JSON">npm install @grapecity-software/spread-common
npm install @grapecity-software/spread-sheets-core</code></pre><p>2.引入资源：</p><p>从@grapecity-software/spread-common导入GC。</p><pre><code class="JavaScript">import '@grapecity-software/spread-common/styles/gc.spread.sheets.excel2013white.css';
import GC from '@grapecity-software/spread-common';
import '@grapecity-software/spread-sheets-core';</code></pre><p>3.优化效果：</p><ul><li>打包后的体积由全量依赖26.42MB减少至2.06MB，减小了24.36MB，优化效率为92.20%。</li><li>构建时间由26秒缩短至约2秒。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521702" alt="img" title="img" loading="lazy"/></p><ul><li>浏览器加载时间由4.3秒缩短至45毫秒，提升约98.95%。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521703" alt="img" title="img" loading="lazy"/></p><h3>增持计算功能</h3><p>提供能力包括编辑、计算（普通计算函数和高级计算函数）、公式编辑框。</p><ol><li>安装依赖</li></ol><pre><code class="JavaScript">npm install @grapecity-software/spread-common
npm install @grapecity-software/spread-sheets-core
npm install @grapecity-software/spread-calc-engine
npm install @grapecity-software/spread-sheets-calc-engine
npm install @grapecity-software/spread-calc-engine-basic-functions
npm install @grapecity-software/spread-calc-engine-advanced-functions
npm install @grapecity-software/spread-sheets-formula-textbox</code></pre><p>2.引入资源：</p><pre><code class="Python">import '@grapecity-software/spread-common/styles/gc.spread.sheets.excel2013white.css';
import GC from '@grapecity-software/spread-common';
import '@grapecity-software/spread-sheets-core';
import '@grapecity-software/spread-calc-engine';
import '@grapecity-software/spread-sheets-calc-engine';
import '@grapecity-software/spread-calc-engine-basic-functions';
import '@grapecity-software/spread-calc-engine-advanced-functions';
import '@grapecity-software/spread-sheets-formula-textbox';</code></pre><p>3.优化效果：</p><ul><li>打包后的体积由全量依赖26.42MB减少至3.81MB，减小了22.61MB，优化效率为85.58%。</li><li>构建时间由26秒缩短约4秒。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521704" alt="img" title="img" loading="lazy"/></p><ul><li>浏览器加载时间由4.3秒缩短至169毫秒，提升约96.07%。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521705" alt="img" title="img" loading="lazy"/></p><h3>增持条件格式、数据验证、筛选和排序</h3><p>提供能力包括编辑、计算、条件格式、数据验证、筛选、排序。</p><ol><li>安装依赖：</li></ol><pre><code class="JSON">npm install @grapecity-software/spread-common
npm install @grapecity-software/spread-sheets-core
npm install @grapecity-software/spread-calc-engine
npm install @grapecity-software/spread-sheets-calc-engine
npm install @grapecity-software/spread-calc-engine-basic-functions
npm install @grapecity-software/spread-calc-engine-advanced-functions
npm install @grapecity-software/spread-sheets-conditional-formatting
npm install @grapecity-software/spread-sheets-filter
npm install @grapecity-software/spread-sheets-data-validation
npm install @grapecity-software/spread-sheets-formula-textbox</code></pre><p>2.引入资源：</p><pre><code class="JavaScript">import '@grapecity-software/spread-common/styles/gc.spread.sheets.excel2013white.css';
import GC from '@grapecity-software/spread-common';
import '@grapecity-software/spread-sheets-core';
import '@grapecity-software/spread-calc-engine';
import '@grapecity-software/spread-sheets-calc-engine';
import '@grapecity-software/spread-calc-engine-basic-functions';
import '@grapecity-software/spread-calc-engine-advanced-functions';
import '@grapecity-software/spread-sheets-data-validation';
import '@grapecity-software/spread-sheets-conditional-formatting';
import '@grapecity-software/spread-sheets-filter';
import '@grapecity-software/spread-sheets-formula-textbox';</code></pre><p>3.优化效果：</p><ul><li>打包后的体积由全量依赖26.42MB减少至3.85MB，减小了22.57MB，优化效率为85.43%。</li><li>构建时间由26秒缩短至2秒。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521706" alt="img" title="img" loading="lazy"/></p><ul><li>浏览器加载时间由4.3秒缩短至173毫秒，提升约95.98%。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521707" alt="img" title="img" loading="lazy"/></p><h2>方案五：CDN加载</h2><p>通过 CDN 从工程外部加载SpreadJS资源，不纳入本地打包，彻底消除其对工程体积的影响，同时提升构建与部署效率。</p><ol><li>优化效果：</li></ol><ul><li>打包体积为58.70KB，且不包含SpreadJS依赖。</li><li>构建时间由26秒缩短至214毫秒。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521708" alt="img" title="img" loading="lazy"/></p><ul><li>浏览器加载时间由全量依赖对应的4.3秒延时至8.4秒。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521709" alt="img" title="img" loading="lazy"/></p><p>CDN通过外部URL加载SpreadJS资源，不需要将SpreadJS资源打包到工程dist目录中，缩短了本地的构建时间，小体积上传服务器、CI/CD传输更快，还能节省服务器的存储资源。</p><p>CDN存在弊端：</p><ol><li>严重依赖网络环境，网络带宽会影响加载速度</li><li>CDN节点故障会导致SpreadJS资源加载失败，页面请求无法渲染表格，功能失效</li><li>企业内网环境无法访问外网资源，CDN节点访问无效。</li></ol><h3>CDN最少量加载</h3><p>必须依赖包括：</p><ul><li>gc.spread.sheets.all</li><li>gc.spread.sheets.shapes</li><li>gc.spread.sheets.charts</li><li>gc.spread.sheets.resources.zh</li><li>gc.spread.sheets.designer.resource.cn</li><li>gc.spread.sheets.designer.all</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521710" alt="img" title="img" loading="lazy"/></p><p>以上资源可确保Designer能正常加载使用，而且对于未被引入的依赖，工具栏中不会显示相关功能图标。特别地，虽然没有引入gc.spread.sheets.pdf和gc.spread.sheets.print依赖，但是文件选项卡依然显示了相关功能按钮。点击"打印"功能按钮，页面不响应，但也不抛异常。而点击"导出"选择导出为PDF文件，控制台会打印异常显示提示savePDF函数不存在。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521711" alt="img" title="img" loading="lazy"/></p><h2>三、优化效果汇总：不同场景的最优选择</h2><table><thead><tr><th>优化方案</th><th>适用场景</th><th>打包体积</th></tr></thead><tbody><tr><td>全量依赖</td><td>需使用所有功能</td><td>26.42MB</td></tr><tr><td>Designer最少量依赖</td><td>保留Designer核心功能，精简扩展功能</td><td>19.92MB</td></tr><tr><td>去除Designer依赖</td><td>无需工具栏</td><td>18.36MB</td></tr><tr><td>仅使用SpreadJS</td><td>仅使用表格核心功能（核心编辑、计算引擎、条件格式、数据验证等）</td><td>5.74MB</td></tr><tr><td>按需加载子包</td><td>功能明确，仅使用表格部分核心功能</td><td>2.06MB（仅核心编辑）、 3.81MB（核心编辑、计算引擎）、3.85MB（核心编辑、计算引擎、条件格式、数据验证、筛选和排序等）</td></tr><tr><td>CDN加载</td><td>公网环境，追求极速构建</td><td>0</td></tr></tbody></table><p>注：以上数据基于 SpreadJS V18.2.5 实测，不同版本可能存在细微差异。</p><h2>四、总结</h2><p>SpreadJS 作为一款高度模块化的表格组件，其体积优化的核心在于 "按需取舍"------ 无需为未使用的功能耗费体积成本。通过本文介绍的五种方案，开发者可根据项目场景灵活选择：</p><ul><li>快速优化：优先剔除无用依赖，零成本实现 70%+ 体积缩减；</li><li>性能优先：按需加载核心子包，在保留核心功能的同时实现 90%+ 瘦身；</li><li>效率优先：公网项目采用 CDN 加载，彻底消除 SpreadJS 对打包体积的影响。</li></ul><p>无需复杂的构建配置，仅通过依赖管理即可实现从 26.42MB 到 0MB 的极致优化，让 SpreadJS 在提供强大表格能力的同时，不成为项目性能的负担。</p><h2>参考资源</h2><ol><li><a href="https://link.segmentfault.com/?enc=BqZ6QK1PfKPDP280dalI%2Fw%3D%3D.rEq8BGDkGAUC80ySd8iJDlE6rQldgsNbdwaO9EIuAUo7pb78dmYxcUTb95t2O4Ovqaiiwfk7B%2BwQsfnYuPUMsfESX04Hs%2FwLyNZqX0jJOOo%3D" rel="nofollow" target="_blank">学习指南</a></li><li><a href="https://link.segmentfault.com/?enc=wu3kCrvyBtUDlRDI2D6JSA%3D%3D.3DA4C653%2Btz5roTbCyCUWH7HlYU7fwDHYmrqKEye8QaO9S1PRhEDVfoUpN2NBJ6VmHGDODuww81zs1hZv4NG6A%3D%3D" rel="nofollow" target="_blank">官网在线表格编辑器</a></li><li><a href="https://link.segmentfault.com/?enc=dFsS2BFezbvJyPFyHZqJFQ%3D%3D.kIMqXxhZ4D7LTCG%2BUJPRE6aEwTEiKhL34TSSOUy9K%2BOgKmaH7pWSlyRArz%2FgCrtT6kdTIRAWt9sLHGVWj3L41CNugDivjmEgP5OmibGoxOWErCBFAtGGyCNvMdpfXjFf" rel="nofollow" target="_blank">组件库</a></li><li><a href="https://link.segmentfault.com/?enc=hU4BKSfa1P%2Ft67DggPHE%2BA%3D%3D.dO%2FDu2EUZwIg1WDtJz9UOD0m%2Fukun0RndbbOp%2F7eGV18n3RCsKfB1CV8LuWsUSZL3Poan%2BnZxRraSFZmrAZKTQ%3D%3D" rel="nofollow" target="_blank">SpreadJS独立模块减少打包后的体积</a></li></ol><h2>声明</h2><p>本文基于SpreadJS V18.2.5版本测试，在不同版本表现可能不一致，请根据实际情况灵活参考。</p>]]></description></item><item>    <title><![CDATA[WebView容器化方案：低代码平台快速实现Web应用嵌入微信小程序 葡萄城技术团队 ]]></title>    <link>https://segmentfault.com/a/1190000047521736</link>    <guid>https://segmentfault.com/a/1190000047521736</guid>    <pubDate>2026-01-05 10:04:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>时代：遍地开花的微信小程序</h2><p>互联网时代，"快"已经成为这个时代发展不可或缺的因素。换句话说，效率创造价值。就拿微信小程序来说，打开微信，下拉，可以看到各式各样的微信小程序层出不穷。那么为了能跟上时代的脚步，我们就需要根据现有的业务状况，快速开发出可用、好用的微信小程序。</p><h3>什么是微信小程序</h3><p>这里借用官方的一句话简介：小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p><p>简单来说，小程序的出现，让移动端 Web 网页在微信中运行成为了可能。这种能力所带来的好处有：易用且安全的微信数据开放、高效和简单的开发等等。</p><h3>小程序与普通网页开发</h3><p>小程序的主要开发语言是 JavaScript，可以说小程序的开发和普通的网页开发有不少的相似之处。网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序账号、安装小程序开发者工具、配置项目等等过程方可完成。</p><h2>勿入：微信小程序开发的"坑"</h2><h3>开始</h3><p>开始开发微信小程序的第一步，需要提前准备：</p><ol><li>（需企业认证）微信小程序账号（<a href="https://link.segmentfault.com/?enc=34E7FNjN7s4HS0q85xcigQ%3D%3D.SQ74eGobs8nG8W1GHPNUe%2Fx%2FN7apHXlzKdsGqAHjUWyTFBr0%2FryZMjAswpa3fIpi8zZurqWrHcy6q5tewfnH6Q%3D%3D" rel="nofollow" target="_blank">点击进入注册链接</a>）</li><li>微信开发者工具（<a href="https://link.segmentfault.com/?enc=vbMcINTZL7ETCoPOyGF%2FLQ%3D%3D.jpjI5IYX%2BN2CrF2gBhzHx21fErbU3f4%2FtrAhFIIy8h8FMsE1lM5gBQIN6lCSG0qAfmo8ZGPIne%2BLx%2B%2Faw1AiTSpQJSehKGzofsJ5kCjaQG4%3D" rel="nofollow" target="_blank">点击下载</a>）</li></ol><h3>第一个小程序</h3><p>完成以上准备工作后，就可以打开微信开发工具，创建第一个微信小程序项目。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521738" alt="" title=""/></p><h3>小程序代码构成</h3><p>有过网页编程的开发者知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前页面结构，CSS 用来描述页面的样式，JS 通常是用于处理页面和用户的交互。</p><p>那么，在微信小程序中，也有相同的组合，如下表的对应关系：</p><table><thead><tr><th><strong>网页开发</strong></th><th><strong>小程序开发</strong></th></tr></thead><tbody><tr><td>HTML（超文本标记语言）</td><td>WXML 模板</td></tr><tr><td>CSS（层叠样式表）</td><td>WXSS 样式</td></tr><tr><td>JavaScript</td><td>同 JavaScript</td></tr></tbody></table><p>简单来说，就是微信小程序中的开发组合和网页编程的开发组合区别不大，可以说如果熟悉网页编程，那么小程序上手学习的难度不大。</p><h2>秘籍：快速将应用嵌入到微信小程序</h2><h3>小程序工程结构</h3><p>有了以上准备工作后，就可以开始启动对接微信小程序的工作，首先活字格服务团队提供相应封装好了的小程序代码工程，开始之前，先介绍一下工程的基本结构。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521739" alt="" title="" loading="lazy"/></p><ul><li>pages</li><li>agreement（用户服务协议页面）</li><li>grant（授权页面）</li><li>index（WebView 嵌入页面）</li><li>logs</li><li>privacy（隐私协议页面）</li><li>user-profile（用户信息页面）</li><li>resources</li><li>images</li><li>utils</li><li><strong>forguncyConfig.js（重点，配置活字格应用地址）</strong></li></ul><p>在这个微信小程序工程中，只需要关注一处，就是 forguncyConfig.js 文件，这里需要配置活字格应用地址，只需要在这里替换为自己的应用地址即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521740" alt="" title="" loading="lazy"/></p><h3>低代码平台介绍</h3><p>这里使用的是一款企业级低代码平台------活字格（<a href="https://link.segmentfault.com/?enc=VM1JQh5tyj6hyI80BQ%2FVfQ%3D%3D.lhChF9qbhG98aPFo8wbZgWlzx%2FgppAvzG7SklFRVjsnvXhXTtc%2BtgUfJudcVJCprGK207u0RRs3lE6YOTct6tQ%3D%3D" rel="nofollow" target="_blank">点击了解\&amp;下载</a>），活字格提供可视化设计器，让开发人员和业务人员可以快速构建美观、易用的<strong>Web应用程序</strong>，满足企业的个性化管理需求，并随需而变。使用者可以灵活拖动各个图形化控件，构建业务流程、逻辑和数据模型等，实现企业信息系统在 PC 端、移动端所需的各项功能。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521741" alt="" title="" loading="lazy"/></p><p>借助活字格快速开发出移动端应用，然后通过一键发布，即可部署在自己的服务器上。</p><h3>快速对接微信小程序</h3><p>部署好活字格应用后，活字格提供了<a href="https://link.segmentfault.com/?enc=v6LFIadFbxIz5Yr79z%2Bifw%3D%3D.5gyPS0lVGB8%2BrG%2FUUEIU%2F8amob2GiZ1AIKUIeqgJ940x61%2FSYCFU2n1IrkyR%2B%2BEfoAALJnGkgmbVG0Ly30XOriBvmCli6ePlyrR8SIvmjyE%3D" rel="nofollow" target="_blank">单点登录</a>功能，借助单点登录功能，通过用户授权，获取当前微信用户的手机号和 OpenID，将 OpenID 作为用户名，手机号作为用户全名，保存在活字格后台用户信息中，以便用户在下一次访问、登录时验证用户信息。</p><p>为了直观说明整个登录路程，以下是活字格对接微信小程序的登录流程：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521742" alt="" title="" loading="lazy"/></p><p>可以直接来看视频演示效果：</p><p><a href="https://link.segmentfault.com/?enc=eQ%2FwENXihgn8Ya4rHjxuww%3D%3D.El6n7APWzcms4REjS4PHi%2F%2Fw1hrywooBwz%2BPhJHKMXcZVoUxv%2BLjdWIZHIbRhF3BskV%2BofF4o8FfbBTvbHIytA%3D%3D" rel="nofollow" target="_blank">https://flowus.cn/preview/ce88c3fc-1576-4005-b002-6c0404235ccf</a></p><h3>需要注意的点</h3><ul><li>微信小程序规定使用web-view必须经过企业认证，<strong>个人类型的小程序暂时不支持使用</strong>。</li><li>活字格发布的应用需要有效的域名且绑定HTTPs证书，并且需要在微信小程序后台配置<strong>request合法域名</strong> 以及<strong>业务域名</strong>；</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521743" alt="" title="" loading="lazy"/></p><ul><li>如果在微信开发者工具使用个人类型小程序开发，可以先勾选不校验合法、web-view（业务域名）、TLS版本以及HTTPS证书；</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521744" alt="" title="" loading="lazy"/></p><h2>总结</h2><p>经过简单的配置，就可以快速将低代码开发出的Web应用嵌入到微信小程序中，从而实现了不依赖微信小程序开发语法就可以快速发布微信小程序，从一定程度上减少了开发工作量。这种创新模式打破了传统小程序开发的技术壁垒，让企业应用快速拥抱微信生态。</p><p>这种模式特别适合表单类、数据展示类和业务流程类应用，如企业OA系统、客户管理、库存盘点、活动报名等场景。通过活字格平台预先构建的业务逻辑和数据模型，结合微信小程序的用户触达能力，企业可以快速将自己的业务系统扩展到12亿微信用户群体，真正实现了"一次开发，多端分发"的现代应用开发理念。同时，后端业务逻辑维护只需在一个平台完成，避免了多端重复开发和维护的成本，让IT资源得到更高效的利用。</p><p>更重要的是，这种模式既保留了Web应用的开发灵活性，又获得了小程序的流量入口优势，为企业数字化转型提供了一条务实高效的路径。</p><h2>扩展链接</h2><p><a href="https://link.segmentfault.com/?enc=4VK5PwvygbhHzBg8eSgrRw%3D%3D.bXnzZw1MdEw7E%2Bnhv5LgXZDm753uVZlEBuEFv3evhJcE9k6OJDbG1oHPgWPlKcgjuu4doxmcaYj5jqDViR6PFQ%3D%3D" rel="nofollow" target="_blank">面向开发者的企业级低代码开发平台</a></p>]]></description></item><item>    <title><![CDATA[1024Foundation发起人冯雷出席《交大安泰AI应用（智能体）研讨会》：AI开发门槛极速降低]]></title>    <link>https://segmentfault.com/a/1190000047521753</link>    <guid>https://segmentfault.com/a/1190000047521753</guid>    <pubDate>2026-01-05 10:03:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>2025年12月28日，“交大安泰校友会第三届 AI 应用（智能体）研讨会”在沪成功举办，1024Foundation发起人、卡内基梅隆大学（CMU）上海校友会主席冯雷（Ray Von）受邀出席。本次研讨会以 “奔赴智能体新征程·锚定 AI 应用创业新蓝海” 为主题，通过多维度的深度分享、圆桌论道，全景展示了 AI 智能体从基础模型进化到垂直行业落地的无限可能基础。在备受关注的圆桌论坛环节，Ray 与来自智谱AI、极熵科技、上海有元人、普元信息的嘉宾围绕 “如何抓住AI智能体在 2B/2C 行业应用实践商机” 这一关键议题展开热烈讨论，碰撞思想火花。各方围绕智能体技术创新、场景落地、生态构建等核心议题展开深入交流，共同探讨AI智能体在产业升级中的核心价值，彰显了头部企业携手推动行业高质量发展的责任与担当。</p><p><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdnyIZ" alt="" title=""/><br/><em>圆桌讨论精彩瞬间</em></p><p>Ray在圆桌环节分享了他对智能体AI市场的信心，预测未来五年智能体企业市场将达万亿级规模。随着智能体时代的到来，人工智能的发展有效降低开发门槛。Ray 在圆桌讨论中分享了与高中生合作开发智能体的创新经验，用实际案例证明了AI开发门槛的急剧降低。由高中生创立的 CalAI，仅用4人初始团队便斩获1200万元创收，而平均年龄仅22岁的 MercorAI 公司，ARR已高达5千万美元。</p><p><img width="723" height="465" referrerpolicy="no-referrer" src="/img/bVdnyI1" alt="" title="" loading="lazy"/><br/><em>智能体创业团队趋年轻化，小规模化（来源：Dr.Li Nan report at Ortizpe）</em></p><p>1024Foundation发起AI4AI普及公益，赋能大众共享AI能力。其中AI4AI雏鹰计划，专为零基础高中生定制，通过系列AI主题演讲与动手实践项目等形式，带领各位“雏鹰”开启一场充满惊喜与挑战的人工智能探索之旅，为未来的学术研究或职场发展打下坚实基础。 目前，雏鹰计划已得到“杭州AI18罗汉”拓数派、中船海舟、中国电子等企业，以及CMU上海校友会、上海共青团、哈工大、国防科大、成都电子科技大学、西安电子科技大学、上海AMBA等学术机构的强力支持，在文绮汇点美高、上海市闵行中学等中小学，成功开展“{智能体AI+} 入门课程，合作落地西藏英语平台等实践智能体项目，通过「结对智能体开发」方法论，运用生动活泼、深入浅出的教学方法，引领学生们逐步踏入人工智能这一充满无限潜力与想象空间的奇妙世界，点燃了学生们对 AI 的浓厚兴趣与探索热情。</p><p><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdnyI2" alt="" title="" loading="lazy"/><br/><em>图为：1024Foundation 发起人冯雷</em></p><p>本次研讨会成功举办，不仅系统梳理了智能体在行业的实践与应用，更展望了其未来演进路径。随着技术不断成熟与场景持续深化，智能体必将更深层次地融入产业核心环节，推动业务流程重构与效率革命，为千行百业注入智能化新动能。未来，AI4AI将持续推动AI智能体技术的普及与深化，赋能大众共享AI。雏鹰计划将继续聚焦青少年 AI 教育领域，为 AI 领域源源不断地储备高素质后备人才，为人工智能行业的长远发展注入源源不断的新生力量。</p>]]></description></item><item>    <title><![CDATA[看板式反馈收集工具：低代码构建策略、技术实践与效能优化路径 Zoey的笔记本 ]]></title>    <link>https://segmentfault.com/a/1190000047521762</link>    <guid>https://segmentfault.com/a/1190000047521762</guid>    <pubDate>2026-01-05 10:02:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>看板式反馈收集工具：低代码构建策略、技术实践与效能优化路径</h2><p>在团队协作与项目管理中，反馈是推动持续改进和创新的核心动力。然而，当关键意见在零散的聊天记录、纷繁的邮件和断续的会议中被遗漏时，团队的响应能力和问题解决效率便大打折扣。这些痛点普遍存在于依赖传统反馈收集方式的组织中。本文将系统性地解析如何通过引入和优化“看板式反馈收集工具”，构建一个可视化、可追踪且高效的反馈管理体系，从而彻底改变这一协作困境。</p><h3>一、引言：团队协作的“无声地带”——反馈流失</h3><p>在任何需要协作的场景中，有效的反馈循环都是驱动成功的关键要素。它帮助团队校准方向、优化产出并提升客户满意度。然而，现实挑战往往不在于缺乏反馈，而在于反馈在收集、传递与处理过程中的大量“流失”。信息滞后、渠道分散、责任模糊与难以追踪，共同形成了一个“无声地带”，使得宝贵见解无法转化为有效行动。看板式反馈收集工具，正是为照亮这一地带而设计。它融合了源自精益生产与敏捷开发的“可视化”核心理念，旨在将杂乱无序的信息流，转变为清晰、可控且持续创造价值的工作流。</p><h3>二、症结剖析：传统反馈收集方式的四大短板</h3><p>要理解新工具的价值，必须先厘清旧模式的根本局限。传统反馈收集方式通常存在以下结构性缺陷：</p><ul><li><strong>信息滞后与遗漏</strong>：依赖不定期的会议或异步的邮件沟通，导致反馈无法实时进入处理流程。许多问题在非正式交流中被提及后便被遗忘，直至其影响扩大才被重新关注。</li><li><strong>渠道分散，难以整合</strong>：反馈来自四面八方：客服系统、客户关系管理（CRM）软件、协同文档、代码仓库等。这些信息孤岛使管理者难以获得全局视图并进行有效的优先级排序。</li><li><strong>责任模糊，无人跟进</strong>：“大家注意一下这个问题”这样的表述往往意味着没有明确的责任人（Owner）。反馈因此在讨论阶段热烈，却在执行环节消失无踪。</li><li><strong>过程不透明，缺乏闭环</strong>：反馈提交者如同向黑洞中投递信息，无从知晓其意见的状态、是否被采纳或何时解决。这种不确定性严重挫伤了持续提供反馈的积极性。</li></ul><h3>三、核心理念：什么是看板式反馈收集工具？</h3><p>看板式反馈收集工具，是一种将经典“看板方法”应用于反馈流程管理的数字化解决方案。其核心支柱在于<strong>可视化工作流</strong>、<strong>限制在制品（WIP）数量</strong>和<strong>主动管理流动效率</strong>。</p><ul><li><strong>可视化工作流</strong>：它将完整的反馈处理流程（例如：“待受理”→“分析中”→“处理中”→“待验证”→“已关闭”）以看板列的形式直观呈现。每一条反馈都成为一张独立卡片，在看板列间移动。</li><li><strong>明确状态与责任人</strong>：每张卡片清晰承载反馈内容、提交者、负责人、截止日期和当前状态。所有相关方能一目了然地掌握全局进展。</li><li><strong>促进持续流动</strong>：通过限制每一阶段（如“处理中”）的卡片数量，团队被迫优先完成现有工作，而非不断涌入新任务，从而确保反馈流顺畅、持续地走向闭环。</li></ul><h4>看板式工具带来的根本性转变：</h4><ul><li><strong>从混乱到有序</strong>：将散落各处的反馈统一归集，并纳入结构化的流程进行管理。</li><li><strong>从黑盒到透明</strong>：所有利益相关者都能实时追踪反馈进展，极大增强了团队信任与协作效率。</li><li><strong>从被动到主动</strong>：团队可以基于看板数据（如卡片在某一列的停留时间）主动识别流程瓶颈并进行优化。</li><li><strong>从任务到价值</strong>：聚焦于推动反馈卡片流向“完成”状态，确保每一条有价值的输入都能产生实际成果。</li></ul><h3>四、典型场景：看板式反馈工具在哪里能大显身手？</h3><p>该工具在以下多类协作场景中能显著提升效率与透明度：</p><ol><li><strong>产品迭代与用户反馈管理</strong>：将来自应用商店评论、用户访谈、调研问卷等多渠道的反馈，统一转化为看板卡片。产品经理可轻松进行归类（如“缺陷修复”、“功能请求”、“体验优化”）、设定优先级并分派至设计或开发团队，同时让用户能在产品更新中看到自己建议的落地。</li><li><strong>跨部门项目协作</strong>：在市场、研发、运营等多部门联动的项目中，依赖与评审需求频繁。使用看板，市场部提出的文案评审、运营部所需的技术支持，都能作为清晰卡片进入研发看板，状态实时同步，有效避免反复催问与信息错位。</li><li><strong>内部团队持续改进</strong>：团队内部的流程优化建议、技能提升需求乃至管理反馈，均可通过专属的“团队改进看板”来收集与处理。这有助于培育开放、透明的改进文化，确保每位成员的声音被听见和尊重。</li><li><strong>客户成功与技术支持</strong>：将客户成功经理收集的客户痛点与技术支持工单中的常见问题，系统性地汇总至产品改进看板。这确保了客户的声音能够直接、透明地驱动产品路线图的规划与调整。</li></ol><h3>五、构建体系：四步搭建你的反馈收集引擎</h3><p>成功实施看板式反馈工具，关键在于构建一个协同、可持续的完整体系，而非仅仅安装一个软件。</p><ol><li><p><strong>设计可视化工作流</strong></p><ul><li>首先，与团队成员共同梳理当前反馈处理的实际步骤，从创建到归档。将其精炼为4至7个核心状态，作为看板的基础列，例如：“待处理”、“已评估”、“计划中”、“进行中”、“待验证”、“已完成”。</li><li>为每一列明确“完成的定义”（Definition of Done），例如，卡片进入“已评估”列，必须已标注初步优先级和预估工作量。</li></ul></li><li><p><strong>制定明确的规则与职责</strong></p><ul><li>运用RACI责任分配矩阵等工具，为不同类型的反馈明确负责人（Responsible）、审批人（Accountable）、咨询方（Consulted）和知会方（Informed）。</li><li>建立统一的卡片创建规范，包括标题格式、必备标签（如所属模块、优先级、反馈类型）以及必须填写的描述字段，确保信息质量与一致性。</li></ul></li><li><p><strong>整合反馈入口，实现自动收集</strong></p><ul><li>将看板工具与团队现有工作系统（如邮箱、表单工具、即时通讯软件）进行连接。通过Zapier、Make或原生API，将表单提交、特定主题的邮件、频道内的特定消息自动创建为看板上的“待处理”卡片。这是打破渠道分散壁垒的关键一步。</li></ul></li><li><p><strong>建立反馈闭环与复盘机制</strong></p><ul><li>配置自动化通知规则：当卡片状态更新、被评论或接近截止日期时，自动通知提交者及相关责任人。</li><li>定期（如每两周）召开看板复盘会议，回顾已关闭的反馈，分析卡片在某一环节停留过久的原因，并基于数据持续优化工作流规则与团队协作方式。</li></ul></li></ol><h3>六、工具推荐与自动化实践</h3><table><thead><tr><th align="left">工具名称</th><th align="left">核心特点</th><th align="left">适用场景</th></tr></thead><tbody><tr><td align="left"><strong>Trello</strong></td><td align="left">极致简洁灵活，卡片与列表概念直观，Power-Ups插件生态丰富，上手极快。</td><td align="left">适用于小型团队、初创项目或任何需要快速搭建轻量级可视化管理的场景。</td></tr><tr><td align="left"><strong>Jira</strong></td><td align="left">功能极为强大，与软件开发流程（敏捷、Scrum）深度集成，定制化能力与项目报表非常专业。</td><td align="left">理想于中大型软件开发团队，需要将用户反馈直接关联到具体开发任务、缺陷（Bug）和版本迭代。</td></tr><tr><td align="left"><strong>Monday.com</strong></td><td align="left">界面现代美观，可视化能力出色，内置自动化工作流强大且易于配置，模板库丰富。</td><td align="left">非常适合跨职能团队（如市场、产品、研发协同），需要高度可定制化工作流和直观项目仪表板的场景。</td></tr><tr><td align="left"><strong>ClickUp</strong></td><td align="left">功能集成度极高，在一个平台内融合目标、文档、看板、甘特图等多种视图，力求All-in-One。</td><td align="left">适合希望整合多类工作流、减少工具切换、追求一体化工作平台的团队。</td></tr><tr><td align="left"><strong>板栗看板</strong></td><td align="left">国内代表性工具，专注于提供简洁、流畅、核心的看板体验，强调团队协作的直观性与易用性。</td><td align="left">适合寻求快速上手、注重核心看板功能、无需复杂配置的中小型团队或作为团队协作入门工具。</td></tr><tr><td align="left"><strong>国内集成平台</strong> (如钉钉Teambition、飞书项目)</td><td align="left">与国内主流办公生态（钉钉、飞书）无缝集成，账号互通、消息联动，协作极其便利，符合本地化使用习惯。</td><td align="left">深度依赖钉钉或飞书作为日常办公基础的中资企业或团队，追求生态内无缝协作体验。</td></tr></tbody></table><h4>自动化实现示例：智能分配与状态同步</h4><p>以下是一个简化的Python示例，演示如何根据预设规则自动分配反馈负责人并更新状态，模拟自动化工作流的关键环节：</p><pre><code class="python"># 定义反馈类型与处理规则的映射库
processing_rules = {
    "bug": {"default_owner": "后端工程师", "priority": "高", "target_column": "进行中"},
    "ui_optimization": {"default_owner": "前端工程师", "priority": "中", "target_column": "已评估"},
    "new_feature": {"default_owner": "产品经理", "priority": "需评审", "target_column": "待处理"}
}

def create_and_route_feedback(title, description, feedback_type):
    """根据反馈类型自动创建卡片并分配至相应看板列"""
    if feedback_type not in processing_rules:
        raise ValueError(f"未知的反馈类型: {feedback_type}。请检查类型定义。")
    
    rule = processing_rules[feedback_type]
    # 构建反馈卡片数据对象
    feedback_card = {
        "title": title,
        "description": description,
        "type": feedback_type,
        "assignee": rule["default_owner"],
        "priority": rule["priority"],
        "status": rule["target_column"], # 初始状态由规则决定
        "created_at": "2023-10-27"
    }
    
    # 此处应接入实际看板工具（如Jira、Trello）的API，创建卡片并设置属性
    # response = api.create_card(board_id='your_board', card_data=feedback_card)
    # print(f"API响应: {response.status_code}")
    
    print(f"[自动化日志] 反馈卡片已创建并分配：'{title}' -&gt; 负责人: {rule['default_owner']}, 初始状态: {rule['target_column']}")
    return feedback_card

# 模拟来自不同渠道的反馈自动创建过程
bug_report = create_and_route_feedback("登录页面响应超时", "用户报告在提交时遇到超过5秒的延迟...", "bug")
feature_request = create_and_route_feedback("提议增加数据导出功能", "许多用户需要将分析结果导出为Excel...", "new_feature")</code></pre><h3>七、避坑指南：常见误区与优化建议</h3><table><thead><tr><th align="left">误区</th><th align="left">表现</th><th align="left">优化建议</th></tr></thead><tbody><tr><td align="left"><strong>看板沦为摆设</strong></td><td align="left">团队沟通仍主要在线下进行，看板信息更新不及时，与实际工作脱节。</td><td align="left"><strong>领导以身作则</strong>：要求所有反馈相关的讨论、决策和状态更新都必须基于看板卡片进行，将更新看板作为任务完成的正式环节。</td></tr><tr><td align="left"><strong>卡片堆积成山</strong></td><td align="left">“待处理”列卡片数量无限增长，团队感到 overwhelmed 并逐渐麻木。</td><td align="left"><strong>实施WIP限制</strong>：为“进行中”等核心列设置严格的在制品数量上限。<strong>建立定期梳理（Refinement）机制</strong>，果断对低优先级需求进行归档或明确拒绝。</td></tr><tr><td align="left"><strong>流程过于复杂</strong></td><td align="left">看板列设置过多（超过10列），移动卡片需填写大量非必要字段，降低效率。</td><td align="left"><strong>坚守简洁原则</strong>：定期回顾，合并或删除使用率低的列。牢记工具是为流程服务，优化流程本身，而非被工具功能所绑架。</td></tr><tr><td align="left"><strong>缺乏数据分析</strong></td><td align="left">仅将看板用作任务板，从未利用其累积的数据进行回顾或量化改进。</td><td align="left"><strong>建立度量习惯</strong>：定期关注并讨论“平均解决周期”、“吞吐量”等核心效能指标。利用累积流图（CFD）等可视化报表分析瓶颈，实现数据驱动的流程改进。</td></tr></tbody></table><h3>八、结语：从反馈收集到价值交付</h3><p>引入看板式反馈收集工具，其深远意义远超于管理任务本身。它实质上是一场围绕工作方式与团队文化的渐进式变革。通过将隐性的协作成本、模糊的责任界定变得显性化、可视化，它将个人的零星抱怨与建议，转化为了团队共同关注、协力解决的改进机遇。最终，它致力于构建一个<strong>高度透明、权责清晰、响应迅速</strong>的现代协作环境。</p><p>一个真正高效的反馈系统，是智慧型组织不可或缺的神经网络。它确保信息不仅被“听见”，更能被有效“理解”、被及时“处理”，并最终被可靠地“转化”为切实的业务行动与客户价值。现在，正是将您团队中那些散落各处的宝贵“声音”，汇聚、梳理成推动组织持续前进的清晰信号与强大动力的时刻。</p>]]></description></item><item>    <title><![CDATA[【节点】[NormalFromTexture节点]原理解析与实际应用 SmalBox ]]></title>    <link>https://segmentfault.com/a/1190000047521777</link>    <guid>https://segmentfault.com/a/1190000047521777</guid>    <pubDate>2026-01-05 10:01:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><a href="https://link.segmentfault.com/?enc=uhYWMGJJNKh%2FljcHBXrGRg%3D%3D.VI%2B%2FtyfK%2FgWqxjAF3ZxNGvLFG1kD3jB%2F4W6DOCiLsKWlqNvPyA70IyrpWR9VrltOvLgLZRpmi2d5lNPuuQ%2FQQ5Slc39VtEoXG8nVVPMmDiTeO0CncEq6WG2i6i%2FnYRHpTSTJth8jXSJm35iUM2xXfgZ1NVls%2BIAfGBdxxmeETZUSL7vVstP6xQeEdRwiz3xFF%2BOl9gLllLOCJvFuJVT1VbuqTuRNOBBzCpzD%2FC%2FJFtQ%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong></blockquote><h2><strong>节点功能与核心价值</strong></h2><p>NormalFromTexture节点是URP管线中实现高度贴图到法线贴图转换的核心工具，其通过实时计算表面高度变化生成法线向量，为材质添加微观细节表现。该节点在实时渲染中具有独特优势：它能够动态响应高度数据变化，支持程序化内容生成，同时显著减少传统预计算法线贴图的内存占用。在移动端渲染优化中，这种实时计算特性尤为重要，因为它允许开发者根据设备性能动态调整细节精度。</p><h2><strong>端口系统与参数控制</strong></h2><h3><strong>输入端口体系</strong></h3><ul><li>‌<strong>Texture端口</strong>‌：接收高度贴图数据，要求灰度图像格式，亮度值直接对应表面高度。推荐使用RGBA32格式以保留足够精度，避免压缩导致的细节丢失。</li><li>‌<strong>UV端口</strong>‌：控制纹理采样坐标，未连接时默认使用UV0。通过连接自定义UV节点可实现动态平铺、偏移或世界空间映射，增强材质灵活性。</li><li>‌<strong>Sampler端口</strong>‌：定义纹理采样状态，通常保持默认设置。但在需要特殊过滤模式（如各向异性）或处理纹理数组时需自定义。</li><li>‌<strong>Offset参数</strong>‌：控制采样偏移距离，影响法线细节的尺度。数值范围建议0.001-0.1，过大会导致采样失真，过小则丢失宏观起伏特征。</li><li>‌<strong>Strength参数</strong>‌：作为结果乘数，调节法线强度。数值范围通常0.1-5.0，需根据材质类型（如金属需较高值）和光照环境（强光下需增强）动态调整。</li></ul><h3><strong>输出端口特性</strong></h3><ul><li>‌<strong>Out端口</strong>‌：输出切线空间中的归一化法线向量（Vector3），可直接用于光照计算。其分量范围[-1, 1]，确保与标准光照模型兼容。</li></ul><h2><strong>数学原理与实现机制</strong></h2><p>节点的核心算法基于Sobel算子原理，通过离散微分运算计算高度梯度：</p><ol><li>‌<strong>高度采样</strong>‌：在UV空间中对当前像素及相邻像素（OffsetU、OffsetV）进行采样，获取高度值差异。</li><li>‌<strong>梯度计算</strong>‌：基于采样结果构建切空间向量（va和vb），通过叉乘运算生成法线方向。</li><li>‌<strong>归一化处理</strong>‌：确保输出法线向量长度为1，避免光照计算异常。</li></ol><p>内部代码逻辑（简化示意）：</p><pre><code class="c">void Unity_NormalFromTexture_float(...) {
    Offset = pow(Offset, 3) * 0.1;  // 非线性偏移缩放
    float2 offsetU = float2(UV.x + Offset, UV.y);
    float2 offsetV = float2(UV.x, UV.y + Offset);
    // 高度采样与梯度计算
    float3 va = float3(1, 0, (uSample - normalSample) * Strength);
    float3 vb = float3(0, 1, (vSample - normalSample) * Strength);
    Out = normalize(cross(va, vb));  // 叉乘与归一化
}</code></pre><h2><strong>应用场景与实战案例</strong></h2><h3><strong>动态地形渲染</strong></h3><p>在程序化地形系统中，节点可实时生成法线：</p><ul><li>连接程序化高度数据，实现动态侵蚀效果的法线更新。</li><li>结合多高度图层混合法线，支持LOD系统的细节层次过渡。</li></ul><h3><strong>角色材质增强</strong></h3><p>应用于角色渲染时：</p><ul><li>基于皮肤高度图生成细节法线，模拟动态皱纹和肌肉变形。</li><li>通过Blend节点混合法线贴图，增强服装褶皱的真实感。</li></ul><h3><strong>水体渲染优化</strong></h3><p>用于水体波浪效果：</p><ul><li>实时响应风力参数变化，生成多尺度波浪法线。</li><li>结合Gerstner波算法，实现动态泡沫轨迹。</li></ul><h2><strong>性能优化与故障排除</strong></h2><h3><strong>计算效率优化</strong></h3><ul><li>‌<strong>采样控制</strong>‌：合理限制采样次数和偏移距离，减少计算开销。</li><li>‌<strong>移动端适配</strong>‌：在低端设备上考虑预计算法线，或降低Offset值以简化计算。</li></ul><h3><strong>常见问题解决</strong></h3><ul><li>‌<strong>纹理采样错误</strong>‌：检查纹理导入设置（如Mipmaps启用、过滤模式），确保UV坐标有效范围。</li><li>‌<strong>法线方向异常</strong>‌：验证Strength参数是否合理，避免过强导致不自然边缘。</li><li>‌<strong>锯齿边缘问题</strong>‌：通过增加Offset值或后期抗锯齿处理缓解。</li></ul><h3><strong>版本兼容性</strong></h3><ul><li>升级至Shader Graph 10.3+版本可解决自定义函数节点中的纹理采样错误。</li></ul><h2><strong>进阶应用与拓展</strong></h2><h3><strong>多节点协同</strong></h3><ul><li>与Normal Blend节点混合多个法线源，实现复杂材质效果。</li><li>通过Normal Strength节点进一步控制法线强度，增强艺术表现力。</li></ul><h3><strong>程序化内容生成</strong></h3><ul><li>实时生成地形法线贴图，支持动态磨损效果（如武器随使用时间变化）。</li><li>结合噪声扰动节点，创建风格化法线效果。</li></ul><h3><strong>自定义函数扩展</strong></h3><ul><li>开发特殊滤波算法，增强自然感（如模拟风蚀纹理）。</li><li>创建特定艺术风格的工具链，支持快速原型设计。</li></ul><hr/><blockquote><a href="https://link.segmentfault.com/?enc=le%2Bz2nLJhcX41USIfbqlUw%3D%3D.xCUVDgkN17%2FJJPB1QeGPG5qGQvXY4IbhANg04ikKDo8jOHHYI%2FlkH%2FFNZ9PlcnrWlUP%2Bw5yh8622YuRC%2F8tscnuNVQu%2BXKwRkeCQfc38kJeC6EF7VeO36ojI3QwgRozvoWC6%2BU3iL7P9RYK1cZNGcV9WGg1X4h4sJexHJV9i64lcufhCMObYOgae65D2jT%2F%2FBLW60qx660jfpF4c4Be8%2FQsn%2BVBw%2FLmHn0tUl%2F5Myf4%3D" rel="nofollow" target="_blank">【Unity Shader Graph 使用与特效实现】</a><strong>专栏-直达</strong><br/>（欢迎<em>点赞留言</em>探讨，更多人加入进来能更加完善这个探索的过程，🙏）</blockquote>]]></description></item><item>    <title><![CDATA[《ESP32-S3使用指南—IDF版 V1.6》第五十九章 人脸识别实验 正点原子 ]]></title>    <link>https://segmentfault.com/a/1190000047521779</link>    <guid>https://segmentfault.com/a/1190000047521779</guid>    <pubDate>2026-01-05 10:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>第五十九章 人脸识别实验</h2><p>人脸识别是一种基于人的脸部特征信息进行身份识别的一种生物识别技术。它使用摄像机或摄像头采集含有人脸的图像或视频流，并自动在图像中检测和跟踪人脸，进而对检测到的人脸进行脸部识别的一系列相关技术。本章，我们使用乐鑫AI库来实现人脸识别功能。<br/>本章分为如下几个部分：<br/>59.1 硬件设计<br/>59.2 软件设计<br/>59.3 下载验证</p><h3>59.1 硬件设计</h3><h4>1.例程功能</h4><p>本章实验功能简介：使用乐鑫官方的ESP32-WHO AI库对OV2640和OV5640摄像头输出的数据进行人脸识别。当长按BOOT按键时，录入当前对焦的人脸；当单击BOOT按键时，识别当前人脸，识别时需和人脸仓库中的人脸匹配；当双击BOOT按键时，删除当前人脸，但前提是这个张人脸之前已经在人脸仓库当中。</p><h4>2.硬件资源</h4><p>1）LED灯<br/>LED-IO1</p><p>2）XL9555<br/>IIC_INT-IO0（需在P5连接IO0）<br/>IIC_SDA-IO41<br/>IIC_SCL-IO42</p><p>3）SPILCD<br/>CS-IO21<br/>SCK-IO12<br/>SDA-IO11<br/>DC-IO40（在P5端口，使用跳线帽将IO_SET和LCD_DC相连）<br/>PWR- IO1_3（XL9555）<br/>RST- IO1_2（XL9555）</p><p>4）CAMERA<br/>OV_SCL-IO38<br/>OV_SDA- IO39<br/>VSYNC- IO47<br/>HREF- IO48<br/>PCLK- IO45<br/>D0- IO4<br/>D1- IO5<br/>D2- IO6<br/>D3- IO7<br/>D4- IO15<br/>D5- IO16<br/>D6- IO17<br/>D7- IO18<br/>RESET-IO0_5（XL9555）<br/>PWDN-IO0_4（XL9555）</p><h4>3.原理图</h4><p>本章实验使用的KPU为ESP32-S3的内部资源，因此并没有相应的连接原理图。</p><h3>59.2 软件设计</h3><h4>59.2.1 程序流程图</h4><p>程序流程图能帮助我们更好的理解一个工程的功能和实现的过程，对学习和设计工程有很好的主导作用。下面看看本实验的程序流程图：<br/><img width="576" height="431" referrerpolicy="no-referrer" src="/img/bVdnyJ2" alt="" title=""/><br/>图59.2.1.1 程序流程图</p><p>59.2.2 程序解析<br/>在本章节中，我们将重点关注两个文件：esp_face_recognition.cpp和esp_face_ recognition.hpp。其中，esp_face_recognition.hpp主要声明了esp_face_recognition函数，其内容相对简单，因此我们暂时不作详细解释。本章节的核心关注点是esp_face_recognition.cpp文件中的函数。<br/>接下来，我们将详细解析esp_face_ recognition_ai_strat函数的工作原理。</p><pre><code>/**
 * @brief       AI图像数据开启
 * @param       无
 * @retval      1：创建失败；0：创建成功
 */
uint8_t esp_face_recognition_ai_strat(void)
{
    /* 创建队列及任务 */
    xQueueFrameO = xQueueCreate(5, sizeof(camera_fb_t *));
    xQueueAIFrameO = xQueueCreate(5, sizeof(camera_fb_t *));
    xQueueKeyState = xQueueCreate(1, sizeof(int *));
    xQueueEventLogic = xQueueCreate(1, sizeof(int *));
    xMutex = xSemaphoreCreateMutex();
    /* 初始化按键 */
    esp_key_init(GPIO_NUM_0);
    /* 创建任务 */
    xTaskCreatePinnedToCore(esp_key_trigger,"esp_key_scan",1024,NULL,5, NULL,0);
xTaskCreatePinnedToCore(esp_event_generate, "event_logic",1024,NULL,
5, NULL,0);
xTaskCreatePinnedToCore(esp_camera_process_handler, "esp_camera_process ", 
4 * 1024, NULL, 5, &amp;camera_task_handle, 1);
xTaskCreatePinnedToCore(esp_ai_process_handler, "esp_ai_process_handler", 
6 * 1024, NULL, 5, &amp;ai_task_handle, 1);
xTaskCreatePinnedToCore(esp_task_event_handler, "esp_task_event_handler", 
4 * 1024, NULL, 5, NULL, 1);
    
    if (xQueueFrameO != NULL 
        || xQueueAIFrameO != NULL 
        || xQueueEventLogic != NULL
        || camera_task_handle != NULL 
        || ai_task_handle != NULL)
    {
        return 0;
    }

return 1;
}</code></pre><p>在上述函数中，我们创建了四个消息队列以递交消息，并设置了一个互斥锁来防止任务优先级翻转。此外，还定义了五个任务：检测KEY按键状态（用于判断按键处于哪种状态，如长按、点击和双击等）、事件任务、摄像头获取任务、AI处理任务和按键扫描任务任务。<br/>下面作者分为介绍这些任务的实现流程，如下：<br/>1，检测KEY按键状态任务</p><pre><code>/**
 * @brief       按键扫描(判断短按、长按及双击状态)
 * @param       ticks_to_wait：等待时间
 * @retval      返回按键状态
 */
int esp_key_scan(TickType_t ticks_to_wait)
{
    gpio_num_t io_num;
    BaseType_t press_key = pdFALSE;
    BaseType_t lift_key = pdFALSE;
    int64_t backup_time = 0;
    int64_t interval_time = 0;
    static int64_t last_time = 0;

    while (1)
    {
        xQueueReceive(gpio_evt_queue, &amp;io_num, ticks_to_wait);

        if (gpio_get_level(io_num) == 0)
        {
            press_key = pdTRUE;
            backup_time = esp_timer_get_time();
            interval_time = backup_time - last_time;
        }
        else if (press_key)
        {
            lift_key = pdTRUE;
            last_time = esp_timer_get_time();
            backup_time = last_time - backup_time;
        }

        if (press_key &amp; lift_key)
        {
            press_key = pdFALSE;
            lift_key = pdFALSE;

            if (backup_time &gt; LONG_PRESS_THRESH)
            {
                return KEY_LONG_PRESS;
            }
            else
            {
                if ((interval_time &lt; DOUBLE_CLICK_THRESH)&amp;&amp;(interval_time &gt; 0))
                    return KEY_DOUBLE_CLICK;
                else
                    return KEY_SHORT_PRESS;
            }
        }
    }
}

/**
 * @brief       按键任务
 * @param       arg：未使用
 * @retval      无
 */
static void esp_key_trigger(void *arg)
{
    arg = arg;
    int ret = 0;

    while (1)
    {
        ret = esp_key_scan(portMAX_DELAY);
        xQueueOverwrite(xQueueKeyState, &amp;ret);
    }

    vTaskDelete(NULL);
}</code></pre><p>在上述任务函数中，首先通过调用esp_key_scan函数获取按键的状态，包括长按、双击或点击等。然后，使用FreeRTOS API函数xQueueOverwrite将消息发送到事件任务中。<br/>2，事件任务</p><pre><code>/**
 * @brief       事件生成任务
 * @param       arg：未使用
 * @retval      无
 */
void esp_event_generate(void *arg)
{
    arg = arg;
    static key_state_t key_state;

    while (1)
    {
        /* 接收状态 */
        xQueueReceive(xQueueKeyState, &amp;key_state, portMAX_DELAY);
        /* 判断状态 */
        switch (key_state)
        {
            case KEY_SHORT_PRESS:   /* 短按状态 */
                recognizer_state = RECOGNIZE;
                break;

            case KEY_LONG_PRESS:    /* 长按状态 */
                recognizer_state = ENROLL;
                break;

            case KEY_DOUBLE_CLICK:  /* 双击状态 */
                recognizer_state = DELETE;
                break;

            default:
                recognizer_state = DETECT;
                break;
        }
        /* 发送状态 */
        xQueueSend(xQueueEventLogic, &amp;recognizer_state, portMAX_DELAY);
}
}</code></pre><p>上述任务函数调用xQueueReceive函数接收KEY的消息，然后根据消息判断处于哪个事件状态，最后调用xQueueSend函数发送事件消息至按键扫描任务处理。<br/>3，按键扫描任务</p><pre><code>/**
 * @brief       按键扫描任务
 * @param       arg：未使用
 * @retval      无
 */
static void esp_task_event_handler(void *arg)
{
    arg = arg;
    recognizer_state_t _gEvent;

    while (1)
    {
        xQueueReceive(xQueueEventLogic, &amp;(_gEvent), portMAX_DELAY);
        xSemaphoreTake(xMutex, portMAX_DELAY);
        gEvent = _gEvent;
        xSemaphoreGive(xMutex);
    }
}</code></pre><p>该任务函数就是为了防止优先级翻转问题。<br/>4，摄像头任务</p><pre><code>/**
 * @brief       摄像头图像数据获取任务
 * @param       arg：未使用
 * @retval      无
 */
static void esp_camera_process_handler(void *arg)
{
    arg = arg;
    camera_fb_t *camera_frame = NULL;

    while (1)
    {
        /* 获取摄像头图像 */
        camera_frame = esp_camera_fb_get();

        if (camera_frame)
        {
            /* 以队列的形式发送 */
            xQueueSend(xQueueFrameO, &amp;camera_frame, portMAX_DELAY);
        }
    }
}</code></pre><p>该任务函数最主要的作用是获取摄像头的图像数据，并发送图像数据至AI处理任务。<br/>5，AI处理任务函数</p><pre><code>/**
 * @brief       摄像头图像数据传入AI处理任务
 * @param       arg：未使用
 * @retval      无
 */
static void esp_ai_process_handler(void *arg)
{
    arg = arg;
    camera_fb_t *frame = NULL;
    HumanFaceDetectMSR01 detector(0.3F, 0.3F, 10, 0.3F);
    HumanFaceDetectMNP01 detector2(0.4F, 0.3F, 10);
    FaceRecognition112V1S16 *recognizer = new FaceRecognition112V1S16();

    show_state_t frame_show_state = SHOW_STATE_IDLE;
    recognizer_state_t _gEvent;
recognizer-&gt;set_partition(ESP_PARTITION_TYPE_DATA, 
ESP_PARTITION_SUBTYPE_ANY, "fr");
    recognizer-&gt;set_ids_from_flash();

    while(1)
    {
        xSemaphoreTake(xMutex, portMAX_DELAY);
        _gEvent = gEvent;
        gEvent = DETECT;
        xSemaphoreGive(xMutex);

        if (_gEvent)
        {
            bool is_detected = false;

            if (xQueueReceive(xQueueFrameO, &amp;frame, portMAX_DELAY))
            {
                std::list&lt;dl::detect::result_t&gt; &amp;detect_candidates = 
detector.infer((uint16_t *)frame-&gt;buf, {(int)frame-&gt;height, 
(int)frame-&gt;width, 3});
                std::list&lt;dl::detect::result_t&gt; &amp;detect_results = 
detector2.infer((uint16_t *)frame-&gt;buf, 
{(int)frame-&gt;height, 
(int)frame-&gt;width, 3}, 
detect_candidates);

                if (detect_results.size() == 1)
                    is_detected = true;

                if (is_detected)
                {
                    switch (_gEvent)
                    {
                        /* 注册 */
                        case ENROLL:
                            recognizer-&gt;enroll_id((uint16_t *)frame-&gt;buf, 
{(int)frame-&gt;height, 
(int)frame-&gt;width, 3}, 
detect_results.front().keypoint, 
"", true);
                            ESP_LOGW("ENROLL", "ID %d is enrolled", 
recognizer-&gt;get_enrolled_ids().back().id);
                            frame_show_state = SHOW_STATE_ENROLL;
                            break;
                        /* 识别 */
                        case RECOGNIZE:
                            recognize_result = recognizer-&gt;recognize(
(uint16_t *)frame-&gt;buf, 
{(int)frame-&gt;height, 
(int)frame-&gt;width, 3}, 
detect_results.front().keypoint);
                            print_detection_result(detect_results);
                            if (recognize_result.id &gt; 0)
                                ESP_LOGI("RECOGNIZE", "Similarity: %f, Match ID: %d", 
recognize_result.similarity, recognize_result.id);
                            else
                                ESP_LOGE("RECOGNIZE", "Similarity: %f, Match ID: %d", 
recognize_result.similarity, recognize_result.id);
                            frame_show_state = SHOW_STATE_RECOGNIZE;
                            break;
                        /* 删除 */
                        case DELETE:
                            vTaskDelay(10);
                            recognizer-&gt;delete_id(true);
                            ESP_LOGE("DELETE", "% d IDs left", 
recognizer-&gt;get_enrolled_id_num());
                            frame_show_state = SHOW_STATE_DELETE;
                            break;

                        default:
                            break;
                    }
                }

                if (frame_show_state != SHOW_STATE_IDLE)
                {
                    static int frame_count = 0;

                    switch (frame_show_state)
                    {
                        /* 删除图像 */
                        case SHOW_STATE_DELETE:
                            esp_rgb_printf(frame, RGB565_MASK_RED, 
"%d IDs left", 
recognizer-&gt;get_enrolled_id_num());
                            break;
                        /* 图像识别 */
                        case SHOW_STATE_RECOGNIZE:
                            if (recognize_result.id &gt; 0)
                                esp_rgb_printf(frame, RGB565_MASK_GREEN,
                                              "ID %d", 
recognize_result.id);
                            else
                                esp_rgb_print(frame, RGB565_MASK_RED, "who ?");
                            break;
                        /* 图像注册 */
                        case SHOW_STATE_ENROLL:
                            esp_rgb_printf(frame, RGB565_MASK_BLUE, 
"Enroll: ID %d", 
recognizer-&gt;get_enrolled_ids().back().id);
                            break;

                        default:
                            break;
                    }

                    if (++frame_count &gt; FRAME_DELAY_NUM)
                    {
                        frame_count = 0;
                        frame_show_state = SHOW_STATE_IDLE;
                    }
                }

                if (detect_results.size())
                {
                    draw_detection_result((uint16_t *)frame-&gt;buf, 
frame-&gt;height, frame-&gt;width, detect_results);
                }
            }

            if (xQueueAIFrameO)
            {

                xQueueSend(xQueueAIFrameO, &amp;frame, portMAX_DELAY);
            }
            else if (gReturnFB)
            {
                esp_camera_fb_return(frame);
            }
            else
            {
                free(frame);
            }
        }
    }
}</code></pre><p>上述任务函数主要负责处理图像数据，并将其提交给AI库进行处理。根据按键的不同状态，系统会执行不同的操作：<br/>1，如果长按按键，系统会将人脸数据传入分区表。<br/>2，如果点击按键，系统将当前识别的人脸与人脸库中的人脸进行对比。如果匹配成功，系统将提示人脸识别成功的信息。<br/>3，如果双击按键，系统同样会将当前识别的人脸与人脸库中的人脸进行对比。如果匹配成功，系统不仅会提示人脸识别成功的信息，还会从人脸库中删除匹配的人脸图像数据。</p><h3>59.3 下载验证</h3><p>如果在检测过程中发现人脸，需要长按BOOT按键，将人脸信息录入人脸存储区。当再次检测到人脸时，只需短按BOOT按键，系统就会识别当前的人脸（与存储区的人脸数据进行匹配）。如果识别成功，该系统会将人脸识别处理的图像数据显示在LCD上，否则，提示人脸识别失败，如下图所示。<br/><img width="337" height="568" referrerpolicy="no-referrer" src="/img/bVdnyKn" alt="" title="" loading="lazy"/><br/>图59.3.1 人脸识别效果图</p>]]></description></item><item>    <title><![CDATA[数据结构-堆 SevenCoding ]]></title>    <link>https://segmentfault.com/a/1190000047516534</link>    <guid>https://segmentfault.com/a/1190000047516534</guid>    <pubDate>2026-01-05 09:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>什么是堆</h2><p>堆是一种满足以下条件的树：</p><p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p><blockquote>大家可以把堆(最大堆)理解为一个公司，这个公司很公平，谁能力强谁就当老大，不存在弱的人当老大，老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。</blockquote><p><strong>!!!特别提示：</strong></p><ul><li>很多博客说堆是完全二叉树，其实并非如此，<strong>堆不一定是完全二叉树</strong>，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树，它们甚至都不是二叉树。</li><li>（<strong>二叉</strong>）堆是一个数组，它可以被看成是一个 <strong>近似的完全二叉树</strong>。——《算法导论》第三版</li></ul><p>大家可以尝试判断下面给出的图是否是堆？</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516536" alt="" title=""/></p><p>第 1 个和第 2 个是堆。第 1 个是最大堆，每个节点都比子树中所有节点大。第 2 个是最小堆，每个节点都比子树中所有节点小。</p><p>第 3 个不是，第三个中，根结点 1 比 2 和 15 小，而 15 却比 3 大，19 比 5 大，不满足堆的性质。</p><h2>堆的用途</h2><p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。例如<a href="https://link.segmentfault.com/?enc=lJgAbMMvu4paZVlRvHsU%2Fg%3D%3D.hPbDty7eXxrFuwz53IPjbeyBEu4gWqfYDJUeJI3Z7Ros4y25bt6JpbBh2Lil7pMXtIFZmGW25z9PojbLXgzWf94NLTiHWwsiAf%2FGxbo7fot2JRqx1tG0GYF9OCBdIsoj" rel="nofollow" target="_blank">Top K问题</a></p><p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 <code>O(nlog(n))</code>，查找最大值或者最小值时间复杂度都是 <code>O(1)</code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为 <code>O(n)</code>，即使是使用复杂度为 <code>O(log(n))</code> 的二分法找到要插入或者删除的数据，在移动数据时也需要 <code>O(n)</code> 的时间复杂度。</p><p><strong>相对于有序数组而言，堆的主要优势在于插入和删除数据效率较高。</strong> 因为堆是基于完全二叉树实现的，所以在插入和删除数据时，只需要在二叉树中上下移动节点，时间复杂度为 <code>O(log(n))</code>，相比有序数组的 <code>O(n)</code>，效率更高。</p><p>不过，需要注意的是：Heap 初始化的时间复杂度为 <code>O(n)</code>，而非<code>O(nlogn)</code>。</p><h2>堆的分类</h2><p>堆分为 <strong>最大堆</strong> 和 <strong>最小堆</strong>。二者的区别在于节点的排序方式。</p><ul><li><strong>最大堆</strong>：堆中的每一个节点的值都大于等于子树中所有节点的值</li><li><strong>最小堆</strong>：堆中的每一个节点的值都小于等于子树中所有节点的值</li></ul><p>如下图所示，图 1 是最大堆，图 2 是最小堆</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516537" alt="" title="" loading="lazy"/></p><h2>堆的存储</h2><p>之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为 1，那么对于树中任意节点 i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>）。</p><p>为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516538" alt="" title="" loading="lazy"/></p><h2>堆的操作</h2><p>堆的更新操作主要包括两种 : <strong>插入元素</strong> 和 <strong>删除堆顶元素</strong>。操作过程需要着重掌握和理解。</p><blockquote>在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置</blockquote><h3>插入元素</h3><blockquote>插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起</blockquote><p><strong>1.将要插入的元素放到最后</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516539" alt="" title="" loading="lazy"/></p><blockquote>有能力的人会逐渐升职加薪，是金子总会发光的！！！</blockquote><p><strong>2.从底向上，如果父结点比该元素小，则该节点和父结点交换，直到无法交换</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516540" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516541" alt="" title="" loading="lazy"/></p><h3>删除堆顶元素</h3><p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p><p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为"<strong>堆化</strong>"，堆化的方法分为两种：</p><ul><li>一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li><li>另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。</li></ul><h4>自底向上堆化</h4><blockquote>在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了</blockquote><p>首先删除堆顶元素，使得数组中下标为 1 的位置空出。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516542" alt="" title="" loading="lazy"/></p><blockquote>那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗</blockquote><p>比较根结点的左子节点和右子节点，也就是下标为 2,3 的数组元素，将较大的元素填充到根结点(下标为 1)的位置。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516543" alt="" title="" loading="lazy"/></p><blockquote>这个时候又空出一个位置了，老规矩，谁有能力谁上</blockquote><p>一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516544" alt="" title="" loading="lazy"/></p><p>这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。</p><h4>自顶向下堆化</h4><p>自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516545" alt="" title="" loading="lazy"/></p><p>然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516546" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516547" alt="" title="" loading="lazy"/></p><h3>堆的操作总结</h3><ul><li><strong>插入元素</strong>：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li><li><strong>删除堆顶元素</strong>：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</li></ul><h2>堆排序</h2><p>堆排序的过程分为两步：</p><ul><li>第一步是建堆，将一个无序的数组建立为一个堆</li><li>第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</li></ul><h3>建堆</h3><p>如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。</p><p>首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为 n，那么我们需要对 n/2 到 1 的节点进行自顶向下（沉底）堆化。</p><p>具体过程如下图：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516548" alt="" title="" loading="lazy"/></p><p>将初始的无序数组抽象为一棵树，图中的节点个数为 6，所以 4,5,6 节点为叶节点，1,2,3 节点为非叶节点，所以要对 1-3 号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从 3 号节点开始，一直到 1 号节点。<br/>3 号节点堆化结果：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516549" alt="" title="" loading="lazy"/></p><p>2 号节点堆化结果：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516550" alt="" title="" loading="lazy"/></p><p>1 号节点堆化结果：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516551" alt="" title="" loading="lazy"/></p><p>至此，数组所对应的树已经成为了一个最大堆，建堆完成！</p><h3>排序</h3><p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p><p>现在思考两个问题：</p><ul><li>删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？</li><li>取出的堆顶元素存在哪，新建一个数组存？</li></ul><p>先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。</p><p>机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。</p><p>详细过程如下图所示：</p><p>取出第一个元素并堆化：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516552" alt="" title="" loading="lazy"/></p><p>取出第二个元素并堆化：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516553" alt="" title="" loading="lazy"/></p><p>取出第三个元素并堆化：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516554" alt="" title="" loading="lazy"/></p><p>取出第四个元素并堆化：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516555" alt="" title="" loading="lazy"/></p><p>取出第五个元素并堆化：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516556" alt="" title="" loading="lazy"/></p><p>取出第六个元素并堆化：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047516557" alt="" title="" loading="lazy"/></p><p>堆排序完成！</p>]]></description></item><item>    <title><![CDATA[用changeset来管理你的npm包版本 稀饭52 ]]></title>    <link>https://segmentfault.com/a/1190000047520974</link>    <guid>https://segmentfault.com/a/1190000047520974</guid>    <pubDate>2026-01-05 08:02:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>简单介绍下，changeset是一个版本管理和生成更新日志的工具，超级适用于多包仓库，比如monorepo，可以在提交发布时，自动更新所有包的版本号，并且生成更新日志。</p><h2>一、安装</h2><p>进入项目之后执行命令，安装changeset，并且初始化</p><pre><code class="bash"> pnpm add -D @changesets/cli
 pnpm changeset init</code></pre><p>执行完之后，在项目中会新增一个<code>.changeset</code>目录，用于存放配置文件和<strong>临时的版本变更描述文件</strong>。</p><pre><code class="txt">.changeset/
 ├─ config.json
 └─ README.md</code></pre><h2>二、使用流程</h2><p>在通用的版本管理流程中，通常会区分为：</p><ul><li><strong>预发布版本</strong>（如alpha和beta）</li><li><strong>正式版本</strong></li></ul><h3>预发布版本</h3><p>预发布阶段的两级为alpha和beta，下面是大致区别：</p><table><thead><tr><th align="left">维度</th><th>alpha（内测）</th><th>beta（公测）</th></tr></thead><tbody><tr><td align="left"><strong>代码稳定性</strong></td><td>随时可能大改</td><td>功能基本锁定，不会有大的调整</td></tr><tr><td align="left"><strong>测试人群</strong></td><td>团队内部</td><td>灰度用户</td></tr><tr><td align="left"><strong>发布频率</strong></td><td>每天/每周都能出包</td><td>节奏稍慢，某个阶段的版本</td></tr><tr><td align="left"><strong>版本号示例</strong></td><td>1.0.0-alpha.0 ➜ 1.0.0-alpha.1 …</td><td>1.0.0-beta.0 ➜ 1.0.0-beta.1 …</td></tr><tr><td align="left"><strong>退出条件</strong></td><td>达到功能完备 → 进入beta</td><td>连续几天无阻塞Bug → 发布正式版</td></tr></tbody></table><p>相关命令：</p><pre><code class="bash">pnpm changeset pre enter alpha   # 进入alpha模式,
pnpm changeset version          # 版本变成0.0.1-alpha.0

pnpm changeset pre enter beta   # 进入beta模式
pnpm changeset version          # 版本变成0.0.1-beta.0

# 结束预发布
pnpm changeset pre exit
pnpm changeset version          # 版本变成0.0.1</code></pre><h3>正式版本</h3><p>当你完成某个包的开发，准备发版时，执行：</p><pre><code class="bash">pnpm changeset</code></pre><p>如果是多包仓库，终端会出现一个选择框，让你选择改过的包，</p><ol><li>按空格选中你改过的包（有星号就算选中）→ 回车，</li><li><p>选包的更新级别，会依次出现major和minor，回车到下一步，如果都没选中，就默认为patch，输入本次更新的描述回车</p><ul><li>patch：修复小bug（1.0.0→1.0.1）</li><li>minor：添加新功能（1.0.0→1.1.0）</li><li>major：破坏性的大版本调整，api级别的调整（1.0.0→2.0.0）</li></ul></li></ol><p>单包仓库就直接到了选择更新级别这一步，同样是输入描述，然后回车；</p><p>生成版本号，执行：</p><pre><code class="bash">pnpm changeset version</code></pre><p>你会发现<code>.changeset</code>文件夹中刚才生成的md文件都已经不见了，版本号也升好了。</p><h3>发布</h3><ul><li>登录npm</li></ul><pre><code class="bash">npm login</code></pre><ul><li>发版</li></ul><pre><code class="bash">pnpm changeset publish</code></pre><p>成功后，会在git创建对应的git tag，终端会给出每个包的版本号和 npm链接。</p>]]></description></item><item>    <title><![CDATA[2026年主流SRM管理系统推荐：哪款最适合您的行业？ SaaS圈老马 ]]></title>    <link>https://segmentfault.com/a/1190000047520807</link>    <guid>https://segmentfault.com/a/1190000047520807</guid>    <pubDate>2026-01-05 08:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>随着全球供应链格局的重构与数字经济的深度渗透，企业采购管理已从单纯的降本增效工具，演变为决定企业核心竞争力的战略枢纽。站在2025年末的视角回望，SRM系统即供应商关系管理系统，已经完成了从电子采购到数字化生态平台的跨越。对于中国企业而言，选择一款既能匹配当下业务需求，又能支撑未来数智化转型的SRM系统，是高层管理者面临的关键决策。</p><p>在当前国内市场上，SRM系统呈现出百花齐放的态势。从架构逻辑来看，主要分为业务导向型、ERP延伸型以及新兴的平台型SRM系统。在这里我们将深度剖析当前市场上极具代表性的6款主流SRM系统，为您提供一份深度的选型参考。</p><h2>一、2026年采购数字化转型的核心趋势与挑战</h2><p>在探讨具体系统之前，我们需要厘清当前企业采购管理面临的共性挑战。根据最新的行业洞察，传统采购管理依然受困于效率低、成本高、管控弱、规范差四大痛点。</p><p>从高层视角看，采购业务往往像是一个黑箱，数据滞后且准确性存疑，难以判断价格是否合理，更无法从战略层面进行供应链优化。从中层视角看，如何堵住管理漏洞、控制合规风险、实现业务全程可追溯是巨大的压力。而对于基层采购人员，大量的事务性工作占据了核心精力，与供应商的协同效率低下，且容易陷入推诿扯皮的困境。</p><p>因此，2026年的SRM选型不再仅仅关注功能是否覆盖，而是聚焦于系统是否具备平台化能力、是否拥有低代码带来的敏捷适应性、以及是否融合了AI智能决策能力。</p><h2>二、平台型SRM的领跑者：正远SRM深度解析</h2><p>在众多SRM产品中，<em>正远SRM</em>凭借其独特的平台型架构脱颖而出。不同于传统的套装软件，正远SRM是基于低代码平台架构设计的，这意味着它不仅是一套采购管理软件，更是一个具备生长能力的数字化底座。</p><h3>1、核心架构：低代码平台支撑的随需而变</h3><p>正远SRM最大的特色在于其底层架构的先进性。它采用了微服务架构与<em>低代码平台</em>深度融合的技术路线。这种架构带来的直接优势是系统极其轻量且灵活。</p><p>传统SRM系统往往功能冗余，逻辑复杂，牵一发而动全身，一旦企业业务调整，系统升级和改造的成本极高。而正远SRM通过可视化、拖拉拽式的开发与运维模式，让企业能够根据自身业务需求灵活配置流程、表单和权限。其标准功能设计简洁易用，而个性化需求则通过独立的项目平台实现，与核心产品代码分离。这一设计理念确保了系统主体始终保持轻量、稳定，且后续升级便捷，真正实现了量身定制与随需而变。<br/><img width="723" height="348" referrerpolicy="no-referrer" src="/img/bVdnyun" alt="" title=""/></p><h3>2、功能全景：端到端的全流程闭环</h3><p>正远SRM的功能覆盖了从供应商管理、价格管理、采购执行协同到采购商城的全业务链条，消除了业务断点。</p><h4>（1）供应商全生命周期管理</h4><p>系统实现了从供应商注册、潜在供应商认证、合格供应商准入、分级分类管理到绩效考核与优化的全生命周期闭环。特别是其多元化的引入机制，支持供应商自主注册与授权代注册双模式，并结合征信系统进行风险预警。在绩效评估方面，正远SRM构建了涵盖技术、质量、成本、交付、服务及ESG的全维度考核体系，支持定量数据自动抓取与定性主观打分结合，帮助企业构建健康的供应商生态。<br/><img width="723" height="326" referrerpolicy="no-referrer" src="/img/bVdnyup" alt="" title="" loading="lazy"/></p><h4>（2）价格管理与战略寻源</h4><p>针对企业最关心的成本控制，正远SRM提供了极其丰富的寻源工具。无论是标准的询比价、招投标，还是竞争激烈的竞价模式，系统都能完美支持。其亮点在于支持多轮在线磋商与密封报价机制，确保了寻源过程的公平与透明。特别是对于非标物资或复杂项目，系统支持技术标与商务标分离评审，并引入专家评分机制，实现了从单纯比价向价值采购的转变。此外，系统还支持线下比价的线上化补录，兼顾了业务的灵活性与合规性。<br/><img width="723" height="308" referrerpolicy="no-referrer" src="/img/bVdnyuw" alt="" title="" loading="lazy"/></p><h4>（3）采购执行协同</h4><p>这是连接企业与供应商的核心枢纽。正远SRM实现了订单、发货、收货、质检、对账、开票、付款的全链路在线协同。特别是VMI库存管理与供应商协同库存功能，打破了信息黑盒，让企业能实时掌握供应能力。在财务协同环节，系统以ERP入库数据为基准自动生成对账单，实现了四单合一的自动匹配与校验，极大地降低了财务风险与人工成本。<br/><img width="723" height="272" referrerpolicy="no-referrer" src="/img/bVdnyuy" alt="" title="" loading="lazy"/></p><h4>（4）采购商城</h4><p>针对低值易耗品与非生产性物资，正远SRM内置了采购商城模块。企业可建立内部超市，实现目录化、可视化的电商式采购体验。这不仅规范了零星采购，更通过数据沉淀为后续的集采议价提供了依据。</p><h3>3、技术底座：安全合规与信创适配</h3><p>在安全与合规日益重要的今天，正远SRM表现出了极高的水准。其基础平台已获得国家网络安全等级保护三级认证，并完全符合ISO20000信息技术服务管理体系标准。更重要的是，正远SRM深度适配信创生态，全面兼容国产操作系统、数据库、中间件及CPU架构，为央国企及对数据安全敏感的企业提供了自主可控的供应链管理解决方案。</p><h3>4、AI赋能：从数字化向智能化迈进</h3><p>正远科技在AI领域的布局也颇具前瞻性。其<em>AI平台</em>集成了通用大模型与行业垂直模型，为采购业务提供了智能比价助手、智能报表洞察、智能下单代理及自助客服等高阶能力。例如，系统能根据历史数据与市场行情自动分析价格趋势，识别潜在风险，并将采购人员从重复性工作中解放出来，专注于战略决策。<br/><img width="723" height="424" referrerpolicy="no-referrer" src="/img/bVdnyuz" alt="" title="" loading="lazy"/></p><h2>三、国内市场其他5款主流SRM系统盘点</h2><p>除了正远SRM，国内市场上还有几家极具影响力的厂商，它们各有千秋，占据了不同的市场生态位。</p><h3>1、SAP</h3><p>作为全球企业管理软件的巨头，SAP在中国市场依然拥有强大的影响力。</p><p>SAP的采购解决方案通常作为其庞大ERP体系的一部分或通过Ariba网络提供。其优势在于全球化的视野与极其严谨的流程逻辑。对于已经深度使用SAP ERP的跨国企业或大型集团而言，选择SAP的采购模块能够实现最无缝的数据集成。其功能极其强大，能够支撑极其复杂的全球供应链网络。</p><p>然而，SAP的劣势也同样明显。其系统架构庞大且封闭，实施周期长，费用高昂。面对中国企业灵活多变且具有中国特色的采购业务场景，SAP往往显得水土不服，且二次开发难度极大，难以响应快速变化的业务需求。</p><h3>2、用友</h3><p>作为国内ERP领域的领军者，用友在采购数字化方面有着深厚的积累。</p><p>用友的SRM系统通常与其强大的财务系统和供应链系统紧密集成。其最大的优势在于业财一体化，能够很好地满足财务部门对于采购支出、预算控制的严苛要求。用友拥有庞大的客户群体和成熟的实施服务网络，系统的稳定性与成熟度较高。</p><p>但是，用友的SRM更多是基于其ERP架构延伸而来的，属于典型的ERP延伸型产品。这意味着其业务逻辑往往受限于ERP的框架，灵活性相对不足。面对需要深度连接外部资源、强调供应商生态运营的场景时，其社交属性和协同便捷度略显不足，且系统整体较为厚重。<br/><img width="723" height="290" referrerpolicy="no-referrer" src="/img/bVdnyuA" alt="" title="" loading="lazy"/></p><h3>3、金蝶</h3><p>金蝶与用友类似，也是国内ERP市场的双子星之一。</p><p>金蝶的采购系统在中小企业市场有着广泛的基础，近年来在大型企业市场也发力迅猛。其苍穹平台展现了较强的技术实力。金蝶SRM的优势在于财务业务的融合度高，且界面交互相对友好。</p><p>不过，与用友类似，金蝶的采购模块核心逻辑依然服务于内部ERP的流转。在处理复杂的供应商全生命周期管理、尤其是深度的多级供应商协同与生态圈建设方面，相比于专业的SRM厂商，其功能的深度和细颗粒度管理能力仍有提升空间。<br/><img width="723" height="319" referrerpolicy="no-referrer" src="/img/bVdnyuB" alt="" title="" loading="lazy"/></p><h3>4、甄云科技</h3><p>甄云科技是国内较早专注于采购数字化管理的厂商，属于典型的SaaS化SRM代表。</p><p>甄云科技的产品标准化程度高，迭代速度快，能够快速部署。其优势在于专注于采购领域，对采购业务理解较深，且SaaS模式降低了企业的初始投入成本。其界面设计较为现代，用户体验较好。</p><p>但在面对大型集团企业复杂的个性化需求时，标准化的SaaS产品往往面临挑战。虽然甄云也提供PaaS平台，但在深度定制和私有化部署的灵活性上，相比于原生低代码平台架构的系统，仍存在一定的局限性。此外，SaaS模式下的数据安全与长期拥有成本也是大型企业需要考量的因素。<br/><img width="723" height="339" referrerpolicy="no-referrer" src="/img/bVdnyuC" alt="" title="" loading="lazy"/></p><h3>5、企企通</h3><p>企企通也是国内知名的SRM垂直厂商，专注于供应链协同与互联网采购。</p><p>企企通在工业制造与电子行业的供应链协同方面有着丰富的经验。其系统强调供应商之间的互联互通，致力于构建采购方的工业互联网入口。其在直接物料的采购协同、委外加工管理等方面有着较细致的功能设计。</p><p>然而，企企通的产品在平台化能力上相对正远SRM稍弱。在应对跨行业、多业态集团的复杂管理需求，特别是需要通过低代码进行大规模业务重构时，其系统的开放性和开发效率可能不如基于低代码底座的产品敏捷。<br/><img width="723" height="388" referrerpolicy="no-referrer" src="/img/bVdnyuE" alt="" title="" loading="lazy"/></p><h2>四、多维度横向对比：为什么正远SRM更具优势</h2><p>为了更直观地呈现各系统的差异，我们将从灵活性、集成能力、成本与交付四个维度进行深度对比，从而凸显正远SRM在低代码方面的独特价值。</p><h3>1、灵活性与定制化能力</h3><p>这是正远SRM的核心护城河。基于可视化表单引擎、流程引擎和视图引擎，正远SRM允许企业像搭积木一样构建应用。无论是字段的调整、流程的重组，还是全新业务模块的开发，都能通过零代码或低代码方式快速实现。相比之下，SAP、用友、金蝶等ERP延伸型系统，调整业务逻辑往往涉及到底层代码的修改，周期长且风险大。而甄云等SaaS产品虽然标准化程度高，但对个性化需求的响应往往受到多租户架构的限制。正远SRM真正做到了标准产品与定制开发的完美平衡，既享受了成熟产品的功能，又拥有了量身定制的贴合度。<br/><img width="723" height="433" referrerpolicy="no-referrer" src="/img/bVdnyuJ" alt="" title="" loading="lazy"/></p><h3>2、系统集成与生态开放性</h3><p>正远SRM通过iPaaS集成平台和统一API管理中心，展现了强大的连接能力。它不仅能无缝对接SAP、Oracle、用友、金蝶等主流ERP，还能打通PLM、MES、WMS、OA等异构系统。例如在海联金汇的案例中，正远SRM与SAP深度集成，实现了从需求到结算的端到端闭环。相比之下，ERP厂商的SRM系统往往优先适配自家产品，对接异构系统时可能存在壁垒。正远SRM的中立性与开放性，使其成为打破企业信息孤岛的最佳选择。<br/><img width="723" height="275" referrerpolicy="no-referrer" src="/img/bVdnyuL" alt="" title="" loading="lazy"/></p><h3>3、总体拥有成本TCO</h3><p>从长期来看，正远SRM具有显著的成本优势。一方面，其标准产品加低代码开发的模式，大幅缩短了实施周期，降低了交付成本。另一方面，企业IT团队可以依托低代码平台自主进行后续的运维与迭代，不再被厂商深度绑定，降低了长期的运维服务费用。相比之下，SAP等国际大厂的软件授权费与实施顾问费极为高昂，而SaaS产品虽然初期投入低，但长期的订阅费用累积下来也是一笔不小的开支。</p><h3>4、行业适配与落地深度</h3><p>正远SRM在建筑、制造、化工、新能源等行业积累了深厚的实践经验。例如在德才装饰案例中，针对建筑行业项目制管理、物料编码复杂、招投标频繁等痛点，正远SRM通过灵活配置完美适配。在浩宇集团案例中，面对多业态、多系统的复杂环境，正远SRM通过强大的集成能力实现了全链路管控。这种基于低代码平台的行业深度适配能力，是通用型SaaS软件难以比拟的。</p><h2>五、结语：选择适合您行业的数字化引擎</h2><p>2026年的SRM市场，正从标准化的软件功能比拼，转向平台化、生态化能力的较量。如果您是跨国巨头，且全球业务高度统一，SAP或许依然是稳妥的选择；如果您对财务管控要求极高，且内部已全员使用用友或金蝶ERP，那么其延伸的采购模块能提供不错的一体化体验；如果您追求快速上线且业务流程相对标准，甄云或企企通的SaaS产品值得考虑。</p><p>但是，如果您是一家处于快速发展期、业务形态复杂、对供应链管理的个性化与敏捷性有极高要求的企业，或者您希望构建一套完全自主可控、能够伴随企业成长不断进化的数字化采购平台，那么正远SRM无疑是最佳选择。正远SRM以低代码平台为核，以AI技术为翼，通过量身定制、随需而变的服务理念，正在重新定义采购数字化的未来。它不仅是一套系统，更是企业构建敏捷、高效、韧性供应链的强大引擎。</p>]]></description></item><item>    <title><![CDATA[2025年终总结：再次选择、沪漂、第一次演讲、相亲无果 卷福同学 ]]></title>    <link>https://segmentfault.com/a/1190000047521415</link>    <guid>https://segmentfault.com/a/1190000047521415</guid>    <pubDate>2026-01-05 00:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote>选择大于努力</blockquote><p>友友们，我是卷福同学，上次写2024年终总结的时候还在武汉，谁能想到一年之后会在上海写2025的年终总结。今年下半年经历的事情比较多，总结来说就是，人生经历又丰富了</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521417" alt="" title=""/></p><h2>1.再次选择</h2><blockquote>去一线大城市闯荡人生还是留在武汉岁月静好呢？</blockquote><h3>1月</h3><p>1月时候还在武汉国企里呢，彼时因为项目变少了，武汉人员要重新分配，没分到项目组的人要进资源池等候下一步安排。而我这个小组之前武汉是有2个人的，北京1个项目经理，给我分配了半个人的工时，另一个人直接让去资源池。关于这个项目经理，去年也写过吐槽的帖子。这个人在武汉的名声非常不好，就完全是对待牛马一样对待底下干活的人。</p><p>我想着以后的日子可能过得更难受，还不如直接进资源池算了。于是就和他说了，他倒也爽快，想着再从武汉随便捞个人进来呗，反正还有很多人没安排项目组的。没想到的是，他接连找了两个人，但是因为武汉的人都听说过他的名号，都表示不想去他的项目组。最后，他把项目给外包人员做了。武汉的人，宁愿待池子里，也不想跟着他干。。。</p><p>这让我想起以前上小学的时候，以前农村小学的老师，打学生都很厉害的。而打的原因不仅仅是因为调皮捣蛋，我那个班教数学的老师，就是其中打人最厉害的。上课的讲台两边会有两个座位嘛，每次她讲课的时候，都会从这两个座位的学生手里拿课后作业讲，要是讲的时候发现写错了，直接冲过去打头，提耳朵等等。有一次因为班上写错作业的人太多了，直接一节课没上，轮流上去扎马步。而我呢，又恰巧有一学期是坐在讲台旁边的座位，于是这学期每逢她的课必挨打，打到后面，居然在课上说，卷福坐在这，已经被我打肿了，你们再敢做错题试试。到第二学期开学的时候，大家选座位直接把前面两个位置空着了，有两个人宁愿在后面站着也不坐那位置。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521418" alt="" title="" loading="lazy"/></p><p>我感觉是不是历史又一次重演了呢？</p><p>现在回头看，当时没继续跟着他的选择是对的。在武汉，也没有岁月静好啊。</p><h3>再次选择</h3><p>虽然5月份的时候拿了上海的offer，但是等真的要走的时候，还是会纠结的。就和刚毕业的时候去北京一样，一切都要重头开始了。走的那天，出租屋里只有个保洁阿姨在打扫卫生，就和我刚回武汉的时候一样。不同的是，上次阿姨说的是房子很快就打扫好了，这次说的是，祝老板以后去上海了发大财啊</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521419" alt="" title="" loading="lazy"/></p><h2>2.沪漂</h2><h3>探索新事物</h3><p>上海就是机会多啊，休息日都会出去逛逛，探索些新事物。想想来上海之后，去周边城市参加徒步、参加ChinaJoy漫展、看了开心麻花的话剧《疯狂理发店》、还有市区内的一些公园、大学、图书馆、动物园、演唱活动等等，生活非常丰富多彩。</p><ul><li>徒步活动在小红书上找个团报就行，很多都是一天游，一半时间都在路上</li><li>漫展里的coser都美如画，非常适合集邮</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521420" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521421" alt="" title="" loading="lazy"/></p><h2>3.第一次演讲</h2><h3>3月</h3><p>今年参加的线下活动还比较多呢，3月份的时候受腾讯云社区的邀请去杭州参加线下的技术训练营活动，主要也是想趁机会多认识些大佬，说不定大佬招人，有内推机会。倒也认识了不少人，喵喵、小智，还有社区的泽敏姐。晚上一起吃饭交流的时候，泽敏姐说下次有机会让我上去演讲。当时只以为是说说而已，毕竟社区里大佬太多了</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521422" alt="" title="" loading="lazy"/></p><h3>9月</h3><p>9月份的时候收到社区的邀请，去深圳参加腾讯全球数字生态大会，作为讲师上去做分享。我是非常想去的，这样就能达成从学生到老师角色转变的目标，输入变输出。比较纠结的是分享什么内容比较好呢，想了一晚上，最后觉得分享自己用AI两年的经历、沉淀的一些使用心得体、还有变现方式会比较好。</p><p>现场的分享也是比较顺利，讲完下来的时候和小智老师沟通上台演讲体验，小智说我讲的非常干货，讲的很稳，刚才他自己讲的时候非常紧张，腿都在抖。我说，我也是啊，腿都在打颤，反而看你讲一点也不慌的样子。。。</p><p>第二天又和喵喵一起去腾讯数码大厦找泽敏姐，非常感谢泽敏姐的邀请，第一次到腾讯的大楼参观。期间见识到了超豪华的二次元工位，满墙的手办，非常震惊。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521423" alt="" title="" loading="lazy"/></p><h2>4.AI探索</h2><p>选择适合自己的方向比较重要，2024年投入了很多时间在AI视频、绘画上，虽然也有涨粉嘛，但是变现不行，一年下来也就三位数的收益。今年主要在写作还有AI编程方向投入，因为换工作的原因，其实投入精力没去年那么多。反而收益还更多了，有四位数的收益。也产出了百万阅读的文章和10w+播放量的视频</p><p>出爆款的诀窍就是追热点，这是普通人出爆款最容易的方式了。比如年初的Deepseek，国庆期间的sora2，趁着刚出来热度最高的时候，随便写点东西或者做个视频，流量都非常好的。那像现在再去写Deepseek，流量肯定不如之前了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521424" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521425" alt="" title="" loading="lazy"/></p><h3>11月</h3><p>11月看到小智老师发的华为鸿蒙线下编程活动的信息，拉着在上海的一个前同事一起去参加玩玩，前同事是我在北京阿里工作时同组的，后来来了上海后，我居然在一个公交站碰到他了，也是十分震惊，居然在上海遇到曾在北京的前同事。鸿蒙的编程活动都是基础的操作，正好也买了Codebuddy的会员，用AI编程轻松解决了，拿到个小礼品</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521426" alt="" title="" loading="lazy"/></p><h3>12月</h3><p>年底了，AI破局俱乐部在深圳举办行动家大会，我看分享嘉宾和内容挺干货的，也报名跑去深圳参加了，到现场才发现，高手云集，天下英雄如过江之鲫。我把这次参会了解的东西整理了下：</p><ul><li>AIPPT ：赵充老师以肯德基为例分享做产品不要做全家桶，用户只想要个甜筒（不要做大而全的产品，而是在垂直领域找到需求，在单点，堵上一切）</li><li>AI编程出海：老外付费意愿更强，大公司不愿意做的垂直小市场，才是个人最大的机会。</li><li>搜索流量比推荐流量更值钱：用户主动搜的，说明有明确需求。而平台推的，用户只是随便看看。获取搜索流量的方法：研究用户搜索的关键词，围绕关键词输出内容，时间久了，用户搜索这个关键词，自然就找到你了</li></ul><p>活动分享的内容挺多的啊，这里就不继续写了。</p><p>同样的听课，结果可能完全不同，会场的1000人，参加完会回去后，可能大部分人就是感慨一下，然后继续原来的生活</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521427" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521428" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521429" alt="" title="" loading="lazy"/></p><h2>5.相亲</h2><p>离开武汉前，和大学同学聚餐，聊了下发现同学要准备去女方家提亲了，问对象是从哪里找的，说了个相亲软件。不过也很难，同学相亲了十几个女生，才和现在这个走到谈结婚这一步。知道了相亲软件（青藤）后，我来上海也开始了相亲之旅，到目前为止，还没有一个相上的，简单说下相亲的几个女生吧：</p><ul><li>91年，初中老师。其实是在武汉相亲的，家里给介绍的。感觉年龄差的太大了，差不多5岁了，不过因为是家里介绍的，还是得见上一面。3月的时候，武大樱花还开着，便想去武大里逛逛聊聊。让她把身份证号发我，用校友通道预约。然后犹犹豫豫半天没有发我，说是个人隐私等等之类的，要自己预约。结果没约上，想再用校友通道时已经约满了，无奈只好约着去学校旁边一家冷锅鱼店吃饭好了，计划约的12点见面，我预估12点半应该能吃上饭（不知道为什么，武汉相亲的女生都迟到），没想到她直到1点多才到，迟到1个多小时，期间也就各种尬聊，回去后两人都没再发消息了，凉凉</li><li>93年，上海公务员。家里的亲戚介绍的，是我相亲过的最优秀的女生了。以前的高考文科状元，武大校友，长得像袁咏仪，聊天说话情商也很高。接触了一个月吧，期间也一起吃过饭，看过话剧。最后一次见面聊天说起她前男友，海归，年入百万，金融行业。长相没说啊，应该也不差，妥妥高富帅。我一听这条件，心里顿时凉凉，差距太大了。问起为什么分了呢，说是男的虽然有钱，但是不给女的花，什么事都要AA。就是网上那种观念：钱是给女人看的，不是给女人花的。这次聊完之后就结束了，又凉凉。</li><li>95年，幼师。在上海相亲的，青藤上找的，见面后感觉非常漂亮啊。不过性格比较强势，刚开始聊的还是开心的话题，突然画风一转，她就开始吐槽模式，吐槽支教的山里小学的领导等等，后半段全是听她吐槽，没再聊相亲的话题了。回去后又聊了几周，但是幼师可能时间太紧，也可能她同时聊的人太多，后面想再约见面就没时间了，于是凉凉</li><li>97年，互联网数据分析师。来上海后相亲的第一个女生，也是非常漂亮，加上好友，看了我动态后，说非常崇拜技术大佬（多写博客还是有好处的嘛），想请我吃饭。于是爽快赴约，期间聊分布式、高并发等等，最后吃完饭结束的时候，说感觉身高不够</li><li>00年，主业机械设计，副业自媒体。遇到同行了，聊天话题特别多，情绪价值拉满。约线下去CJ漫展玩，让她把身份证号发我来买票，本来还想着怎么解释说明的，下一秒就把身份证号和手机号发来了，没有任何犹豫。约好了早上9点半去会展中心，没想到她早早到我这边来等我一起过去，连零食和水都买好了。遂开心前往，妹子是第一次逛漫展，逛的非常开心。只不过回去后还是说了性格不合，只好当朋友了。后续还是保持联系，偶尔见面</li></ul><p>这里列出不同年龄段的相亲女生，其他还有一些都是软件上匹配了没说话，或者说两句话就不继续聊了的。给兄弟们做个负面教材的参考啊，今年的相亲就到此为止，明年再说吧。。。</p><h2>6.2026目标</h2><p>最后不都得展望下未来吗，2026年你们又给自己制定了哪些目标和规划呢，我给自己定下的目标，希望明年都能做到</p><ul><li>神山转山</li><li>樱花巡礼</li><li>新手上路</li><li>恰老外米</li></ul><p>最后，感兴趣的朋友可以同时关注我的公众号：卷福同学</p>]]></description></item><item>    <title><![CDATA[2025 年度总结：自我进化与生活回响 Robin ]]></title>    <link>https://segmentfault.com/a/1190000047521379</link>    <guid>https://segmentfault.com/a/1190000047521379</guid>    <pubDate>2026-01-04 23:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>2025 年度总结：自我进化与生活回响</h2><blockquote><strong>年度关键词</strong>：进化、自洽、脚踏实地</blockquote><h3>📊 2025 年度数据看板</h3><p><strong>认知输入</strong></p><ul><li>🎧 播客：147 天 × 108 集 = 77 小时的认知升级</li><li>🎵 音乐：5,524 首歌 × 509 小时，54% 新歌探索</li></ul><p><strong>习惯养成</strong></p><ul><li>🏃 番茄打卡：129 次坚持 = 42.5 小时的仪式感</li><li>💤 作息定律：12 点睡、7 点起，全年如一</li></ul><p><strong>健康成就</strong></p><ul><li>💪 脂肪肝：彻底消失 ✓</li><li>🧘 心态平和：甲状腺术后完全康复</li></ul><p><strong>工具投资</strong></p><ul><li>🛠️ AI 生态：Windsurf、Cursor、Claude、Readdy、Figma、Paraflow</li></ul><p><strong>关系突破</strong></p><ul><li>💑 零吵架：全年 365 天，与妻子实现沟通质变</li><li>👨‍👦 亲子成长：从互相推责到双向道歉</li></ul><p><strong>创作输出</strong></p><ul><li>🚀 Project Prompt 上线</li></ul><hr/><h3>一、 成长（Growth）：认知与内在的蜕变</h3><p><em>这一年，我完成了从“技术执行者”向“生活架构师”的思维跃迁。</em></p><ul><li><p><strong>年度认知觉醒：从小宇宙到“理生活”</strong></p><ul><li>2025 年，小宇宙里的《知行小酒馆》成了我打破“技术茧房”的推手。它让我意识到金融不再是冷冰冰的数字，而是一种观察生活的视角。我深刻理解了“理财即理生活”：每一笔资源的配置，本质上都是在为我想要的生活投票。这种跨界视角让我学会了延迟判断，理解了世界的复杂性，也放下了许多盲目的财务焦虑。<strong>全年共计在 147 天里听了 108 个播客单集，累计 77 小时。这些声音陪伴我通勤、散步、做家务，让碎片时间变成了认知升级的黄金时段。</strong></li></ul></li><li><p><strong>挑战与韧性：从 Coder 到 AI 指挥官</strong></p><ul><li>AI 时代的到来，既是挑战也是机遇。这一年，我完成了从"让 AI 写一行代码"到"指挥 AI 完成整个项目"的进化。我深刻理解了 AI 辅助编程的精髓：<strong>提问的能力比编码的能力更重要，架构的直觉比语法的记忆更关键。</strong> 这种能力的边界拓展，让我拥有了独立解决生活问题、创造有趣产品的底气。<strong>今年也是我真正拥抱 AI 工具生态的一年，先后订阅了 Windsurf、Cursor、Claude Code Max、Readdy、Figma、Paraflow 等工具。这些投入不仅是金钱成本，更是一种对新时代生产力工具的信心投票。</strong></li></ul></li><li><p><strong>硬核实战：<a href="https://link.segmentfault.com/?enc=fdFvTZLlhvs%2Fw3O5tTB%2B3A%3D%3D.lTlb04HebxLQ5sfqhFlryaEZMUH5TOKpQZZqL2WU9ts%3D" rel="nofollow" target="_blank">Project Prompt</a> 的诞生</strong></p><ul><li>我亲手打造并上线了这个产品，初衷是将模糊的想法转化为专业的提示词，让 AI 真正理解产品逻辑。这不仅是一个工具，更是我 2025 年“全栈创造者”身份的终极实战，证明了逻辑与工具结合后产生的巨大生产力.</li></ul></li><li><p><strong>自我的新发现：情绪的“收”与行动的“实”</strong></p><ul><li><strong>收住脾气</strong>：面对最亲近的妻子和孩子，我学会了"只讲道理，不发脾气"。今年最值得骄傲的是，和妻子实现了<strong>零吵架</strong>。这不是回避矛盾，而是学会了用更成熟的方式沟通——有分歧时先听再说，有情绪时先冷静再表达。这种温柔而坚定的力量，让家庭氛围变得更加稳固，也让婚姻关系进入了一个新的阶段。</li><li><strong>脚踏实地</strong>：我逐渐从过去的空想中走出来，让想法“脚沾地”。我越来越清楚自己真正喜欢的事物，不再被外界干扰。这种笃定感，是我今年最踏实的成长。</li></ul></li><li><p><strong>与孩子的双向成长：教养即自我修行</strong></p><ul><li>今年和孩子的相处方式发生了质的改变。我开始主动向孩子道歉，孩子也学会了主动道歉，家里再也不是互相推卸责任的战场。儿子也不再大吵大叫，而是学会了跟我们讲道理。这种互相影响、共同成长的感觉，让我意识到：<strong>教养不是单向输出，而是双向修行。</strong></li><li>更让我欣慰的是看到了孩子身上的责任心和主动性。今年他开始认字，我们只需要说一声"开始认字了"，他就会很自觉地去做。最难忘的是幼儿园讲故事比赛前，我们选了《钱王射潮》的故事，孩子自己进书房，对着视频一段一段地听、一段一段地背，直到记住整个故事。虽然现场讲的时候忘记了最后一句，但那几天他一直拉着我们听他讲，直到一字不差地全部背下来。<strong>那种对完美的执着和不服输的劲头，让我看到了他内在的力量。</strong></li></ul></li></ul><hr/><h3>二、 生活（Life）：具体的烟火与诗意</h3><p><em>生活不是为了赶路，而是为了感受路。</em></p><ul><li><p><strong>身心状态：一场由内而外的“重启”</strong></p><ul><li><strong>健康大捷</strong>：2025 年体检最开心的发现是<strong>脂肪肝彻底消失了</strong>！虽然体重下降不多，但肚子明显小了一圈。甲状腺手术后的康复配合心态的转变，让我整个人进入了前所未有的平和状态。</li><li><strong>作息定力</strong>：依然保持着“12点睡、7点起”的节奏，配合隔三差五的运动，身体的掌控感正在回归。</li><li><strong>习惯养成</strong>：今年开始使用番茄 TODO 打卡，养成了早晨听播客、午饭后散步二十分钟的习惯。全年坚持了 129 次，累计 42 小时 34 分钟。这些看似微小的仪式感，却让每一天都变得更加从容和充实。</li></ul></li><li><p><strong>生活的小确幸：镜头里的“附近”与“爱人”</strong></p><ul><li><strong>音乐的陪伴</strong>：今年共听了 5524 首歌，累计 509 小时，新歌占比 54%。音乐成了我生活中最忠实的陪伴者：通勤路上的提神剂、深夜工作的背景乐、散步时的思考伴侣。54% 的新歌占比，说明我依然对新鲜事物保持着好奇心，愿意走出舒适区去探索未知的旋律。</li><li><strong>镜头里的日常</strong>：入手运动相机后，我爱上了摄影。我的镜头里没有名山大川，却装满了最珍贵的日常：<strong>老婆的笑脸、孩子打闹的身影、家门口那棵随季节变色的树，以及散步过无数次的公园。</strong> 摄影让我学会了停下来观察，发现美不需要远行，它就在每天路过的风景里。</li><li><strong>行走的足迹</strong>：虽然发现"美不需要远行"，但今年也没有停下探索的脚步。去了丽水、南京、嘉兴、上海，每一座城市都留下了我们一家人的欢笑和回忆。旅行不是逃离日常，而是用新的视角重新看待生活，然后带着更丰富的体验回到日常。</li></ul></li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521401" alt="家门口那棵随季节变色的树 · 狮山公园" title="家门口那棵随季节变色的树 · 狮山公园"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521402" alt="秋日湖畔的红叶 · 公司旁的小河边" title="秋日湖畔的红叶 · 公司旁的小河边" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521403" alt="冬日晴空下的城市树影 · 公司旁的小河边" title="冬日晴空下的城市树影 · 公司旁的小河边" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521404" alt="散步过无数次的街区 · 嘉兴之旅" title="散步过无数次的街区 · 嘉兴之旅" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521405" alt="阳光明媚的日常 · 嘉兴之旅" title="阳光明媚的日常 · 嘉兴之旅" loading="lazy"/></p><hr/><h3>三、未竟之事：那些遗憾与反思</h3><p><em>真实的成长，包含完成与未完成。</em></p><ul><li><strong>阅读的遗憾</strong>：收藏夹里躺着一堆想看的书，但真正翻开的寥寥无几。从"想读"到"读完"之间，隔着的不是时间，而是行动力。</li><li><strong>吉他的搁置</strong>：曾经憧憬的指尖旋律，今年几乎没有练过。吉他静静地靠在墙角，提醒我有些热爱需要持续的投入才能开花。</li><li><strong>记录的缺失</strong>：对每一天的记录太少了。很多瞬间在当下觉得会记住，但时间一长就模糊了。生活需要更多的"定格"，才能在回望时更加清晰。</li></ul><p><strong>这些遗憾不是失败，而是 2026 年可以重新出发的起点。</strong></p><hr/><h3>四、 展望（Outlook）：2026 的序章</h3><p><em>不只是设定目标，更是设定“状态”。</em></p><ul><li><p><strong>2026 年度主题词：生长 (Growth &amp; Vitality)</strong></p><ul><li>2026 年是持续发力的一年。我希望在 2025 年夯实的土壤上，让事业和生活像植物一样，拥有向下扎根的深度和向上生长的力量。</li></ul></li><li><p><strong>想尝试的“第一次”：从“做功能”到“做产品”</strong></p><ul><li>2026 年，我期望实现从“开发者”到“产品人”的真正跨越。无论哪个项目，我的目标是<strong>第一次真正意义上积累起属于自己的用户群</strong>，让自己更懂得如何运营产品、创造价值。</li></ul></li><li><p><strong>理想生活片段</strong>：</p><ul><li>在 2026 年的一个周末下午，我坐在书桌前，看着产品后台增长的用户反馈。身边的运动相机里存满了家人欢笑的新素材。那一刻，事业的成就感与生活的烟火气完美交织。</li></ul></li><li><p><strong>给 2026 的寄语</strong>：</p><ul><li><em>“保持脚踏实地的定力，享受持续生长的喜悦。Robin，去创造那些真正有意思的东西吧！”</em></li></ul></li></ul>]]></description></item><item>    <title><![CDATA[前端年度盘点 2025：定义这一年的 10 个核心大事件 本文系翻译，阅读原文
https://bl]]></title>    <link>https://segmentfault.com/a/1190000047521305</link>    <guid>https://segmentfault.com/a/1190000047521305</guid>    <pubDate>2026-01-04 22:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote><p>原文：<a href="https://link.segmentfault.com/?enc=CnOPTwQF7%2BsJ%2FjBPzjFAYQ%3D%3D.ElsKhN4Osdv0EZ3DK6yoNkIViiHg7K5i8Ccbt7w8EDiEB5chDwsx2O2%2Fld1akoz08MaNdPeI6e4H4Ij9O4BZZw%3D%3D" rel="nofollow" target="_blank">Frontend Wrapped 2025: The 10 storylines that defined the year - LogRocket Blog</a></p><p>翻译：<a href="https://link.segmentfault.com/?enc=rw2G8oE9em2Rd266PyKAgQ%3D%3D.sr8lnpC%2FdG%2FeCh7bEZBXKvraaAuudJQtsQS072SkCVE%3D" rel="nofollow" target="_blank">嘿嘿</a></p><p>来源：<a href="https://link.segmentfault.com/?enc=oOvwbt4FcWzXlsoUUxpCvA%3D%3D.dgfHi8BKw27MqMg7u3rEkAq6l1G1HZME2BoymOb1nb3bZilnyZ3h2hVWEITCvBJXqwAB39oLzpETm3YyZ97xuw%3D%3D" rel="nofollow" target="_blank">前端周刊</a></p></blockquote><p>2025 年对前端开发者来说简直是一场情绪过山车。过去这一年里，我们见证了各个角落的疯狂改进、大规模安全漏洞，以及框架的重新发明。AI 霸占了头条，改变了我们构建应用的方式。一些大牌（TanStack、CSS、TypeScript）带来了重大更新，为 2026 年及以后开辟了新的可能性。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521307" alt="frontend wrapped top stories of 2025" title="frontend wrapped top stories of 2025"/></p><p>这次我不打算做传统的年度回顾，而是根据两个标准对今年最重大的前端事件进行排名：它们引发的热度以及对我们构建 Web 应用方式的持久影响。我们从第 10 位最重要的故事线开始，一路倒数到我认为最能定义 2025 年前端开发的那个事件。</p><h2>10. TypeScript 继续统治地位</h2><p>TypeScript 在 2025 年<a href="https://link.segmentfault.com/?enc=kIMzS%2BDMIpyqXBkYtHct6Q%3D%3D.wEyfnDnz%2Frz3M6YcpZNl5ivIpTNF9vTj6uvZDrjM8fpGOL36qKICbONAbg5q7MsGUwCGVXX%2FfxfNnHr51JV9yyGE6oGlmF5q7m67pf03V3H2RhIHgU0QGPYbr%2BW6rS0kZDnPbIg1UO0inkuhuqMyk87fSvgUD0B55In0Pc%2BxQmEUicssl6tVPG8EsKoujEc0dfCD9fUYEiu%2FRHNShZwYtQ%3D%3D" rel="nofollow" target="_blank">表现得太好了</a>：</p><p>-   npm 每周下载量达 6000 万次（2021 年为 2000 万次） -   420 万个 GitHub 仓库在使用 TypeScript -   前 100 个 npm 库中超过 80% 都附带 TypeScript 类型定义</p><p>TypeScript 并不是要取代 JavaScript；它就是开发者现在编写 JavaScript 的方式。大多数代码库都是用 TypeScript 编写，然后编译成 JavaScript（就像 Sass 编译成 CSS 一样）。你能获得类型安全、更好的工具、真正好用的自动补全，以及在有类型代码下性能提升 20% 的 AI 编码助手。</p><h2>9. Tailwind CSS 地位稳固</h2><p>Tailwind 在 2025 年获得了大规模采用，而 styled-components 和其他运行时 CSS 解决方案则失宠了。现在有超过 61.7 万个网站在使用 Tailwind，它已经成为现代 React 应用的默认样式选择。"写内联样式"的批评声彻底消失了；我觉得现在大家都默认用 Tailwind 了，这已经不是个需要争论的问题。</p><h2>8. 服务端渲染（SSR）无处不在</h2><p>SSR 在 2025 年不再是"锦上添花"，而是成了必需品。每个主流框架都全力投入：Next.js 将其设为默认，<a href="https://link.segmentfault.com/?enc=JLhwO8CFbCUo%2BxeEo5bOtA%3D%3D.iIrPv%2BmyhYrxVh%2F4%2FtDkYYy4Z6e927iSmhBZBCOajx%2FZFd%2BDPsf2Ai0jKOJk7vmjtAPXwMKn6V%2FJYjztpL9FOg%3D%3D" rel="nofollow" target="_blank">Remix</a>/React Router v7 围绕它构建一切，<a href="https://link.segmentfault.com/?enc=ZdZGMTYReK6H4aaLTIOFVw%3D%3D.rVNt%2BLJMpM%2FIdNjxvddpvgqEii0R6OGVz1azaUMJI0e3TTptT3%2BI6akL6GtA8n3kYuy%2B2c%2FmQCj2MxOx6Y1FLQ%3D%3D" rel="nofollow" target="_blank">TanStack Start</a> 开箱即带 SSR，就连 SvelteKit 和 Astro 也加倍押注服务器优先架构。</p><p>性能和 SEO 不再是可选项。Google 的 Core Web Vitals 变得更严格，用户期待页面秒开。但 2025 年的 SSR 不是 2015 年那种笨重的服务器渲染。</p><p>现代 SSR 很聪明：框架现在支持部分水合（只有交互部分需要 JavaScript）、流式 SSR（HTML 准备好就发送）和选择性水合（先水合可见部分）。React Server Components 更进一步，让你可以在服务器上获取数据，而不用把那些逻辑发送到客户端。</p><h2>7. Shai Halud npm 攻击事件</h2><p>React 在 2025 年末在安全方面遇到了麻烦（稍后会详细说）——但今年它们不是唯一的受害者。</p><p>npm 生态系统也遭遇了不少攻击。9 月份，攻击者发起了一场<a href="https://link.segmentfault.com/?enc=bkK%2FTs96DrIXjmWh%2FeLbPA%3D%3D.%2BBztjfUq94FUwLFSSFItLAALBvOyzp%2F54q7eRjbrtoDQ9DOz3OVBYv%2Fu65URVDe4" rel="nofollow" target="_blank">协同供应链攻击</a>，分两波展开。首先，9 月 8 日，chalk、debug 和 ansi-styles 等包——这些库每周总下载量达 26 亿次——通过对维护者账户的钓鱼攻击被攻陷。</p><p>注入的恶意软件针对加密货币交易。然后出现了 Shai Hulud 蠕虫（以《沙丘》中的沙虫命名）。这个自我复制的恶意软件攻击了超过 180 个包，窃取凭证并自动传播到被攻陷维护者控制的其他包。</p><p>与传统攻击不同，这是蠕虫式的：当它在环境中发现 npm token 时，会自动发布任何可访问包的恶意版本，无需人工干预就能指数级传播。可怕的是规模和自动化程度。</p><p>如果你在攻击窗口期运行 npm install，就可能拉取到恶意代码。npm 团队和维护者反应迅速，但损害已经造成；数千个项目暴露在风险中，整个生态系统花了几周时间审计依赖项和替换凭证。</p><h2>6. CSS 干掉了更多 JavaScript</h2><p>2025 年的 CSS 不再只是关于样式；它变成了一门编程语言。浏览器厂商全力投入原生 CSS API，这些 API 能消除整个 JavaScript 库的存在，说实话，早该如此了。口号很明确：<a href="https://link.segmentfault.com/?enc=TjPpSRzMkZ6oFqGpNIYBtg%3D%3D.H9h%2FHrim6JMddo0J4eO4X4Rf8qYUa8vl0ck2tseDOfMKka5j35%2Bnxw%2Bhdt6biSKtmT5waO%2Bk%2Fzo%2F5hIRJ1WMpg%3D%3D" rel="nofollow" target="_blank">少用 JavaScript，多用 CSS</a>。</p><h3><strong>Anchor Positioning（锚点定位）</strong></h3><p>Anchor Positioning 在 2025 年在 Safari 中达到生产就绪状态，加入了 Chrome 的现有支持。虽然 Firefox 还只是实验性支持，但该功能现在可以在支撑大部分 Web 的两个浏览器中使用。它允许开发者相对于其他元素定位工具提示、弹出框和下拉菜单，无需 JavaScript。</p><h3><strong>Scroll-Driven Animations（滚动驱动动画）</strong></h3><p><a href="https://link.segmentfault.com/?enc=iM8AAbh77nSGi8cRYbpYZQ%3D%3D.7P7H%2BQKqH7vbpnThCQf56MEmKT6sQSvmnX%2FJsobWkDzZjIBm3oLCUP9bNFSy78dC8pMOfxBG371UMUYrY7Mh3dlFQSZtRMTQ2Fwe0CUf6ao%3D" rel="nofollow" target="_blank">这些动画</a>在 2025 年显著成熟，在主线程外运行，实现丝滑的 60fps 性能。你不用再写 Intersection Observer JavaScript，可以使用 <code>animation-timeline: scroll()</code> 或 <code>view()</code> 将动画直接绑定到滚动位置。</p><p>Chrome 提供了完整支持，你甚至可以基于哪个元素被吸附或滚动器是否可滚动来制作动画，使用 Chrome 133 中引入的新 <code>@container scroll-state()</code> 查询。</p><h3><strong>Container Queries（容器查询）</strong></h3><p><a href="https://link.segmentfault.com/?enc=xkBHPD9hNvtQCLA4kXUPHA%3D%3D.NtA%2Bknv2NffAaIkHJi1bNozSv7%2BTYHHmoHK9ZKOeC7aHNxJHXPbeux6mydQ8G9XsWxE5eSlbGNU%2B8pEcWWDwOQ%3D%3D" rel="nofollow" target="_blank">容器查询</a>达到了 100% 的浏览器支持，成为基于组件设计的默认选择。组件现在可以响应<strong>父元素的宽度</strong>而不是视口宽度（<code>@container (min-width: 600px)</code>），使真正可复用的组件成为可能。再配合<strong>CSS 嵌套</strong>（现在所有浏览器都原生支持），你就能在不用 Sass 的情况下编写组件作用域样式。</p><h3><strong>CSS <code>if()</code> 函数</strong></h3><p>它<a href="https://link.segmentfault.com/?enc=D%2FyN1bHoZVW2xRwUz65Cfg%3D%3D.Ccp3d0xmEqJT6TevxhznT7wO0oja5cGGrEA%2BNPxmc0YVGlFpdB0R3H1Ho4hVghbthDdzvcQV%2B1hnLQ%2F4eWfIrR61asBj9sUXaIS1S8sKL0g%3D" rel="nofollow" target="_blank">终于来了</a>，将<strong>条件逻辑直接带入 CSS</strong>。你现在可以写 <code>background: if(style(--theme: dark), black, white)</code> 来根据自定义属性或样式查询有条件地应用值。</p><h2>5. Rust 的复兴</h2><p>前端工具在 2025 年经历了我所说的身份危机，而 Rust 就是我们需要的疗法。以前需要几分钟的构建工具现在几秒钟就完成了，因为生态系统意识到用 JavaScript 来构建 JavaScript 不够快。</p><p>始于 2024 年末的 Rust 浪潮在 2025 年成为标准。Rspack 在 2024 年 8 月发布 1.0 版本，构建速度提升 23 倍（Webpack 的 6.5 秒 → 282ms），在 2025 年获得了大规模企业采用。</p><p>Vercel 的 <a href="https://link.segmentfault.com/?enc=0F1GORwOIIngLPwBkrIMQA%3D%3D.X0C5vnzQEkyE0mfyjjd4TprgyGEzjz3YSPS9gELJNqljArCWIOPtEgqXFHQ%2Fq%2Buzw7nvweT3zuz1%2BRs1IbcnlA%3D%3D" rel="nofollow" target="_blank">Turbopack</a> 成为 Next.js 15 的默认选择，提供快 700 倍的 HMR。SWC 取代 Babel 成为默认转译器，编译速度快 20 倍。Biome 作为 ESLint 和 Prettier 的 Rust 驱动替代品出现，而 Oxc 提供了用于解析、检查、格式化和压缩的完整 Rust 工具链。</p><p>微软、亚马逊、Discord、TikTok 和抖音等公司在 2025 年都在生产环境中采用了这些工具。Rust 复兴不是选择；这是必然。当你的构建耗时，CI 流水线花钱时，你要么用 Rust 重写，要么接受现状。2025 年证明了，如果性能很重要，就会用 Rust 重写。欢迎来到锈化时代。</p><h2>4. TanStack 生态系统的崛起</h2><p>TanStack 在 2025 年悄悄接管了 React 开发，说实话，大多数开发者（包括我）甚至没看到它的到来。最初作为 React Query（一个数据获取库）起步的东西，演变成了一个完整的生态系统，现在正在取代 Redux、React Router 和开发者多年来一直使用的其他一堆工具。</p><p>TanStack 创建者 Tanner Linsley 两年前全力投入开源，这次押注大获成功。TanStack 现在有超过 40 亿次下载，涵盖从数据获取（TanStack Query）、路由（TanStack Router）、表格（<a href="https://link.segmentfault.com/?enc=EL8m4BrtnNHZ6WrrJ7fIiA%3D%3D.vbwFDzMDx%2FiHBZYctsKe7THjG%2FXsm7ZlPoc2gCntzcFHbllpSVeooekxvsTzaNGzSwIYXomcH%2F9YJ40mJhWQSg%3D%3D" rel="nofollow" target="_blank">TanStack Table</a>）、表单、虚拟化，甚至还有一个叫 <a href="https://link.segmentfault.com/?enc=tIyv4uGPX1RKVd2yixvUXA%3D%3D.LrHKhpuigVHJQg3odCjB3CvtCBsSN05NSKcIiDvTWiGenFKb3dbMdNWh%2BtDRHoZ3LZDqHvUZkR006sSD1LTV%2FQ%3D%3D" rel="nofollow" target="_blank">TanStack Start</a> 的全栈框架。</p><p>最疯狂的是什么？他们今年在路由匹配上实现了 20,000 倍的性能提升，只是通过追求正确性而非速度。每个库都是无头的、类型安全的、框架无关的，这意味着你能获得完全控制而不会被框架锁定。</p><p>到 2025 年底，TanStack 成为需要认真处理数据的 React 应用的默认推荐。Next.js 等框架仍然占主导地位，但如果你用 Vite 构建自定义技术栈或想完全控制架构，TanStack 就是新标准。要说 TanStack Router 的最大的问题，就是一旦你用过它，回到其他路由解决方案就会感觉很痛苦；你会被它的开发体验和类型安全宠坏。</p><h2>3. React 19.2 带来无处不在的异步</h2><p><a href="https://link.segmentfault.com/?enc=Aj2Wiik5sJUVSFYRWEzXTg%3D%3D.LbgSBlpIT1R8rCNBoP%2BxWC56DsLXspnPx1M%2Fo2eeDT7qyUmmjE9%2BsMerYIBAq5Oe" rel="nofollow" target="_blank">React 19.2 版本</a>引发了巨大关注，理由充分。在它发布之前，每一次表单提交、导航点击和搜索框都需要一套组合拳：用 <code>useState</code> 处理加载状态，用 try-catch 处理错误，用 <code>useEffect</code> 协调，然后祈祷你没制造出竞态条件。</p><p>React 19 <a href="https://link.segmentfault.com/?enc=j4CiWrHkecUko4VUNAnqpg%3D%3D.kh%2Fo8Kw854WNaZMSPKu4pul5JjdOEeupKo0bOb%2FzLH4DwZiJRUclUF%2B4S1zt9SquHuKlMAMRAM55zX9rGklaqA%3D%3D" rel="nofollow" target="_blank">彻底改变了游戏规则</a>。在 React Conf 2025 上，团队发布了"Async React"，这是一个使用 React 19 的新原语（如 <code>useTransition</code>、<code>useOptimistic</code> 和 <code>use()</code>）以及 React 18 的 Suspense 和并发特性来声明式处理异步操作的完整系统。</p><p>现在 Actions 自动跟踪异步工作（再见 <code>isLoading</code> 标志），乐观更新让 UI 在服务器请求后台运行时感觉即时响应，Suspense 处理加载状态而不会出现刺眼的加载动画闪烁，<code>useDeferredValue</code> 让搜索框即使在慢速连接下也保持流畅。<a href="https://link.segmentfault.com/?enc=DmSgKn3AAj8xJV1%2BSqpM2A%3D%3D.mPEKg4TJYOHRA%2F2B2QFk7TxYysvMibkZzf9kgO2j8lY%3D" rel="nofollow" target="_blank">Async React 演示</a>展示了其可能性：在任何网络速度下都有流畅的用户体验，零手动状态跟踪。</p><p>最棒的部分是框架为我们内置了这些。Next.js 现在默认将导航包装在 transitions 中。TanStack Query 内置了 Suspense 支持。设计系统开始暴露"action"属性，所以按钮和标签页能处理自己的乐观更新。</p><p>所有那些异步协调的复杂性从我们的代码转移到了框架层。我们从手动跟踪每个加载状态，变成只需描述应该发生什么，React 处理其余部分。大量样板代码就这么消失了，太疯狂了。我不知道为什么花了这么长时间，但说实话，我们不能否认<a href="https://link.segmentfault.com/?enc=7gHPFW2uyHyf46BJfNZK%2FQ%3D%3D.VjBJlNQtkXNwIdOIyOgm1IL7Cst6zm%2BkYpwAEZhQLkc%2BREeyqoeuc3h0wVD2mbfTHdLj5QzErFmRRIkPrkf3%2Bw%3D%3D" rel="nofollow" target="_blank">异步协调</a>终于感觉像是属于 2025 年的东西了。</p><h2>2. React2Shell 漏洞</h2><p>第二个最能定义这一年的故事是 <a href="https://link.segmentfault.com/?enc=1SqBtVp1o66%2FMi1CG42Lyg%3D%3D.j5XGKQtB1Nn6i3%2FdArSmlvxpn54Rmb%2B1YmYMhv%2FsQwESdLCWpFJSw8YAA2HsSc5k" rel="nofollow" target="_blank">React 2Shell</a>——也就是 CVE-2025-55182——漏洞。</p><p>React 经历了有史以来最糟糕的 12 月！11 月 29 日，安全研究员 Lachlan Davidson 在 React Server Components 中发现了一个严重漏洞，CVSS 评分达到完美的 <strong>10.0</strong>，这是可能的最高严重级别。这不是随机的：这是一个未经身份验证的远程代码执行（RCE）漏洞，让攻击者只需一个恶意 HTTP 请求就能在服务器上运行任意代码。</p><p>金融应用成为主要目标；一个精心制作的请求就能暴露敏感的银行信息、操纵交易或植入后门以持续访问。运行 React Server Components 的企业仪表板、医疗门户和 SaaS 平台突然成了活靶子。</p><p>React 19 的 Server Components 本应改变全栈开发。结果它们成了 React 有史以来最大的安全危机。整个生态系统在 2025 年的最后几天都处于紧急补丁模式。</p><p>教训？能力越大（Server Components）责任越大，而且永远、永远要更新你的依赖项。不过值得一提的是，React 团队行动如闪电：从报告到补丁只用了四天。到 12 月 3 日，修复已经发布。</p><h2>1. AI 编码工具的持续演进</h2><p>我们今年见证了超过 30 个 AI 模型发布：GPT 5、Claude Opus 4.5，以及最近的 Gemini 3 Pro，还有一波中国公司发布的 DeepSeek、Qwen、ByteDance 和 Moonshot。</p><p>还不止于此：<a href="https://link.segmentfault.com/?enc=XV3QdFq96i0tFkUqAnpm2A%3D%3D.rz9%2FSDSbi8bWYhw3QenUpZb9kzQDnhylqlbYjH8xTxAe5OxhEOKeutvljBIw%2FVIcU5pUwvZZ0NbjkGydax5gWxqvhzJ%2BhdmjCxq9HxissV4%3D" rel="nofollow" target="_blank">Windsurf 和 Cursor</a> 之间的智能体大战愈演愈烈，甚至引发了投资者之间的<a href="https://link.segmentfault.com/?enc=OmdG4mmx9%2F2xT4JFqYhqTw%3D%3D.EKyFOgBjO6aJbrd4ucwZPkFkrfJjCbL9Wf53xe45%2Fodc%2ByIcsFUNe1PwtRjs5Tt5zaBzLzCzkildniqMJQr3Iq%2FXPKWGVJvWsvBv5XgoqMTfZ6rhGCvs9cd2G5%2FcxbmE7kOm9CHubINF7mkug9rZ%2FA%3D%3D" rel="nofollow" target="_blank">竞价战</a>。</p><p>我们看到 <a href="https://link.segmentfault.com/?enc=y4Lgudq1cRzlsNhqpXi75A%3D%3D.bYotSwIgVlx%2F1GN8m8N53tp9ry4TfAfDw7JZkHgeSKKzG%2FKTvOx22gbmLYHgdiVAiy76IgpDxWf3seaCaIhItg%3D%3D" rel="nofollow" target="_blank">Bolt</a> 和 v0 引领了从编程到生产的一站式编码理念。我们的 <a href="https://link.segmentfault.com/?enc=qRBQDhyYuG0DZVq6Eqb2eA%3D%3D.64Z4S1xS8f6kAFDjpPdyXE9f6X50W4d%2F1g74ecOqJVIaQ8NBptQoSEyDGdmnnwbPY7y8bK37wSageuJJoegHQg%3D%3D" rel="nofollow" target="_blank">CLI</a> 也转变成了编码智能体。我们看到 Claude Code 主导了这个领域，还引入了 MCP 的使用。自然地，其他模型也跟进了：Gemini CLI、Qwen CLI、Kimi CLI 和 Codex。</p><p>这些行业在改变我们编写前端代码的方式上投入了最多的工作。今年我们几乎每隔一周就有 2 个模型发布，它们专门被增强来取代开发者。我不知道为什么它们这么想抢我们的饭碗，但说实话，我们不能否认它们让我们的生活更轻松了。就像 Spotify 等其他"年度总结"一样，你也得承认这些模型和工具是你今年最常用的 !😂</p><h2>结论</h2><p>2025 年真是不平凡的一年！</p><p>无论是 AI 进步、安全漏洞，还是不断演进的框架，我们经历了大量改变我们对 Web 开发思考方式的事件。</p><p>我漏掉了哪些故事？我的排名哪里不对？哪些故事会定义 2026 年？在评论区发声，让我知道你的看法。新年快乐！</p>]]></description></item><item>    <title><![CDATA[两年Java开发工作经验面试总结 技术站999it点top ]]></title>    <link>https://segmentfault.com/a/1190000047521214</link>    <guid>https://segmentfault.com/a/1190000047521214</guid>    <pubDate>2026-01-04 21:05:16</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>理解Java核心：从JVM底层原理到面试高频考点分析<br/>随着技术的飞速发展，Java作为一门重要的编程语言，在企业级应用中被广泛使用。要深入理解Java，尤其是备考相关面试时，了解JVM的底层原理和一些核心概念显得尤为重要。本文将从多个角度解析Java核心，帮助你更快、更有效地掌握这一领域的关键知识。<br/>一、Java与JVM概述<br/>Java是一种面向对象的编程语言，具有良好的跨平台性。在Java的执行过程中，JVM（Java Virtual Machine）扮演着关键角色。JVM负责将Java字节码转换为机器码，并进行执行，它提供了Java程序的运行环境。<br/>JVM的工作流程如下：</p><p>1.编译阶段：Java源代码被编译为字节码（.class文件）。<br/>2.类加载：JVM通过类加载器将字节码加载到内存。<br/>3.执行：JVM将字节码转换为机器可执行的代码，并进行运行。</p><p>二、JVM的内存管理<br/>JVM的内存管理是理解Java程序性能的重要方面。JVM的内存划分主要包括以下几个区域：</p><p>4.方法区：存储类的结构信息（如字段、方法、常量池等）。<br/>5.堆：存放对象的实例，是Java内存管理的重点区域。<br/>6.栈：每个线程都有自己的栈，用于存储局部变量和方法调用的状态。<br/>7.程序计数器：记录当前线程执行的字节码指令位置。</p><p>三、垃圾回收机制<br/>Java中的内存管理与垃圾回收紧密相关。JVM采用自动垃圾回收机制来处理无用对象的回收。常见的垃圾回收算法包括：</p><p>8.标记-清除：首先标记活着的对象，然后清除未标记的对象。<br/>9.复制算法：将内存分为两块，使用一块存储对象，另一块在需要时进行复制，减少碎片。</p><p>理解这些算法有助于深入思考Java应用的性能优化。<br/>四、Java的多线程与并发<br/>Java内置了对多线程的支持，并且提供了丰富的工具和库来处理并发。在Java中，线程是轻量级的执行单元。常见的并发工具包括：</p><p>10.synchronized关键字：用于方法和代码块的同步，确保同一时刻只有一个线程可以访问共享资源。<br/>11.Lock接口：提供了比synchronized更灵活的锁机制，可以实现公平锁和非公平锁的选择。<br/>12.Concurrent包：提供了一系列高效的并发集合和工具类，简化多线程编程的复杂性。</p><p>五、Java中的异常处理<br/>Java的异常处理机制使得错误处理更加规范与清晰。Java分为两类异常：检查异常（checked exceptions）和非检查异常（unchecked exceptions）。理解如何使用try-catch语句和throws关键字，以及自定义异常，可以帮助开发者更好地管理程序中的错误。<br/>六、Java的设计模式<br/>设计模式是对软件设计中常见问题的总结与固定方案，在Java中应用设计模式不仅能提高代码的复用性与可维护性，还能让程序员更好地解决复杂问题。常见的设计模式有：</p><p>13.单例模式：保证一个类只有一个实例，并提供一个全局访问点。<br/>14.工厂模式：定义一个创建对象的接口，让子类决定实例化哪个类。<br/>15.观察者模式：定义了一种一对多的依赖关系，让多个观察者类在主题状态变化时得到通知。</p><p>七、面试准备与高频考点<br/>在准备Java相关的面试时，需要关注以下高频考点：</p><p>16.JVM的运行机制：包括类加载过程、内存模型、垃圾回收机制等。<br/>17.不同线程模型下的并发编程：包括synchronized、Lock、原子变量等。<br/>18.常用设计模式和其应用场景：掌握设计模式的意图及用法有助于理解代码架构。<br/>19.Java基础知识：掌握面向对象编程、常用API和Java集合框架的使用。</p><p>结论<br/>掌握Java核心从JVM的底层原理到面试中的高频考点，是每个Java开发者的重要任务。通过深入理解JVM的工作机制、内存管理、线程模型以及常见的设计模式，你将能够更好地处理日常开发中的各种挑战，并在面试中展示出色的能力。希望这篇文章能帮助你更快、更有效地掌握Java的核心知识！</p>]]></description></item><item>    <title><![CDATA[AI 写真下半场：从「捏脸」到「控体」的维度跨越 飞奔的毛巾 ]]></title>    <link>https://segmentfault.com/a/1190000047521223</link>    <guid>https://segmentfault.com/a/1190000047521223</guid>    <pubDate>2026-01-04 21:04:43</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​在 AI 影像生成的狂飙突进中，我们似乎已经攻克了最难的山头：人物一致性。</p><p>通过 LoRA、FaceID 这些技术，那个虚拟模特终于长了一张稳定的脸。不管换什么场景，她都是她。但很快我就发现，这事儿没完——脸是活的，但身体是僵硬的。</p><p>只要你试图让她做一个稍微复杂点的动作，比如“回头递东西”或者“慵懒地靠在沙发上”，AI 往往会给你一个虽然符合人体工学、但毫无美感的姿势，或者干脆把手指画得像章鱼。</p><h3>工程师的“洁癖”</h3><p>作为技术出身的人，面对这种不可控，我的第一反应总是去寻找一把最精准的尺子。</p><p>那个时候，我觉得答案显而易见，就是 OpenPose。</p><p>这也是工程师的通病：总觉得要控制一个变量，就得把它参数化。OpenPose 给出的那些黑底彩线图，在我眼里就是最完美的参数。既然是为了做一套“工业级”的动作库，这套库里装的就应该是精准的骨架图，干净、体积小、像乐高一样可以随意拼凑。</p><p>我满心欢喜地构建了一套标准骨架库，觉得只要把这个丢给 AI，告诉它“照着这个画”，它就应该像个填色游戏一样，乖乖把肉体长在这些线条上。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521225" alt="图片" title="图片"/></p><h3>当 AI 指鹿为马</h3><p>然而，当我把这些精心打磨的骨架图，喂给 NanoBanana、Midjourney 甚至豆包这些云端大模型时，现实狠狠地给了我一巴掌。</p><p>AI 并没有像我预期的那样，把那些线条识别成人的骨骼。</p><p>在很多次生成的图片里，我的人物并没有做出指定的动作，背景里反而莫名其妙地出现了一堆彩色的霓虹灯管；或者完全没有收到动作图一样。</p><p>那一刻我才意识到这其中的荒谬：在这些靠“看图”长大的 AI 眼里，OpenPose 根本不是什么动作指令。它只看到了一张黑色的图片，上面画着彩色的线。但它压根没理解这是“人”。</p><p>我们试图用几何坐标去指挥一个学美术出身的 AI，这本身就是一种语言不通。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521226" alt="图片" title="图片" loading="lazy"/></p><h3>“脏”数据的胜利</h3><p>不信邪之下，死马当活马医，我试着换了一种完全不同的“脏”数据。</p><p>我找出一张随手拍的照片。那是一张很普通的摄影图，背景有点乱，光线也不完美，甚至人物的衣服还有点花哨。我把它作为动作参考图喂给了同一个 AI 模型。</p><p>结果，AI “开窍”了。</p><p>它不仅完美复刻了那个转身回头的动作，甚至连原图中因为转身而带动的肩膀耸起、重心偏移后微微弯曲的脊柱，那种很难用语言描述的“松弛感”，都完美地迁移到了我的虚拟角色身上。</p><p>这事儿在逻辑上其实挺讲不通的：按照常理，给 AI 的指令应该是越干净、越精准越好。 OpenPose 的图多纯粹啊，全是有效信息；而真人照片里全是背景噪音、衣服褶皱的干扰。</p><p>但在这个实验里，“噪音”反而变成了真正的高保真信号。</p><p>因为openpose骨架图丢掉了一个最重要的东西——重力。</p><p>几根线条是体现不出“用力”的感觉的。但是真人照片里，当一个人举起重物时，他的二头肌会隆起，身体会后仰以保持平衡，衣服会在腋下形成特定的褶皱。</p><p>AI 是很聪明的，它在学习了上百亿张照片后，建立了一种隐性的视觉关联：它看到肩膀耸起的轮廓，就知道这里应该配上手臂抬起的动作；它看到鞋底被压扁的变形，就知道这个人的重心完全在脚上。</p><p>这种“物理世界的压迫感”，是那几根轻飘飘的彩色线条永远无法传达的。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521227" alt="图片" title="图片" loading="lazy"/></p><h3>回归“物理真像”</h3><p>这个发现逼着我推翻了之前的技术路线。</p><p>如果所谓的“通用动作库”不能被主流的云端模型理解，那就毫无价值。既然现在的 AI 是基于视觉联想工作的，那我们就得顺着它的脾气来。</p><p>我决定放弃对 OpenPose 那种数学精度的执念，转而建立一套“真人实拍动作资产”。</p><p>我们不需要教 AI 怎么画骨头，我们只需要给它一面镜子，让它看清楚一个真实的、受重力约束的人，在做这个动作时究竟是什么样子。</p><p>其实有时候，承认“模糊”比“精准”更有效，是产品落地最关键的一步。</p><p>​</p>]]></description></item><item>    <title><![CDATA[编程项目慎重选择，避免浪费时间做价值不高的事情 cpp辅导的阿甘 ]]></title>    <link>https://segmentfault.com/a/1190000047521239</link>    <guid>https://segmentfault.com/a/1190000047521239</guid>    <pubDate>2026-01-04 21:04:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>我们在求职做简历的时候，写项目是不可避免的一个内容。</p><p>那写一个什么样的项目才能给简历加分，才能在面试中发挥出积极的效果，就需要我们进行慎重考量了。</p><p>之前在星球内部微信群看到了一位同学发的一个企业的筛选标准，如下图：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521241" alt="" title=""/></p><p>可能有些同学看到这个，就会开始吐槽，吐槽公司的标准。</p><p>但是，我们冷静下来分析想想，也是可以获得很多信息的：</p><p>（1）上述这些项目做的人很多，面试官都看腻了</p><p>（2）很多人简历写这些，面试官可能通过面很多人，对这些项目也非常熟悉了。这个时候如果些，自己对一些细节掌握的不是很好，很容易被问住</p><p>（3）项目本身含金量、难度非常低。尤其像些这种线程池、内存池等当作一个项目的，自己也非常不理解，这个东西怎么能当作一个项目呢。是具有什么实际落地的价值吗，是一套完整的服务吗，这就算做的复杂点，把各种场景都想到了（比如长短任务，优先级等等），那也充其量是个小组件而已。写这些，还不如写一个自己开发了斗地主项目呢</p><p>（4）简历些这些，也就是让自己简历勉强合格，满足基本书写要求。面试不会给面试官带来太多的惊喜，面试平平无奇，如果学历不是特别好，容易排序挂掉</p><p>那针对这自己应该怎么办？</p><p>如果时间不是特别紧急，比如才大一大二，做做也无所谓挺好的，多敲敲代码没有坏处</p><p>如果时间特别紧急，</p><p>（1）并且基础还很差（没怎么写过代码，全程都是在背诵），那也可以做做上面的，毕竟做的人多了，网上资料一搜一大堆，针对这项目问的问题，网上也一搜一大堆，可以轻松掌握。</p><p>（2）如果基础还好，自己上学期间还是敲过代码的，建议找找有含金量的点的，选一个做。争取做大化的发挥出自己时间的价值。不要浪费时间做一个demo，小组件，对自己找好工作没任何帮助，还浪费自己的时间</p><p>本文由<a href="https://link.segmentfault.com/?enc=0RKOSY3YqqbxG7y2z1qpfA%3D%3D.8ZTe3kvDNilb6zu1UvP31Hi3KPXEfvLzJJiLCFMttno%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[招聘逻辑迭代：AI重构HR工作新范式 爱跑步的香蕉_cKtiNz ]]></title>    <link>https://segmentfault.com/a/1190000047521257</link>    <guid>https://segmentfault.com/a/1190000047521257</guid>    <pubDate>2026-01-04 21:03:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>招聘逻辑迭代：AI重构HR工作新范式<br/>很多HR已经隐隐感觉到一件事：不是人不够努力，是招聘这套流程，正在变得不值得人亲自去做。<br/>简历一年比一年多，岗位一年比一年细。你筛得越认真，主观性越强；你想提高效率，就越容易漏人、错人。<br/>而现实是——越来越多企业，已经不再让HR从第一份简历开始“亲手干活”了。<br/>现在的招聘，已经悄悄换了一套逻辑。</p><p>招聘的“底层分工”，被AI重新拆解<br/>在越来越多企业里，招聘的第一阶段已经高度自动化：<br/>•规则先行：AI先用明确规则过滤硬条件，比如学历背景、年龄区间、基础经历；<br/>•模型排序：再基于技能标签与经验结构进行排序，比如Python年限、项目复杂度；<br/>•面试前置：两三千份简历被压缩到可控范围后，由AI面试工具进一步评估表达、逻辑与胜任力；<br/>•HR聚焦决策：HR不再逐个“聊”，而是重点看结构化报告，直接进入判断环节。<br/>入职后，聊天机器人24小时在线，持续承接员工问题；HRBP则开始用数据做一件过去很难做的事——提前预警谁可能流失。<br/>很多HR后来才意识到：自己正在从疲于奔命的“协调员”，变成一个真正的招聘设计师与决策者。<br/>而支撑这一切的核心，并不是“自动化”，而是打分到底准不准。<br/>招聘最难的不是效率，是“你敢不敢信这个分数”<br/>AI面试如果只是“帮你快一点”，价值非常有限。真正决定它能不能落地的，只有一个问题：这个评分，能不能直接支撑招聘决策？<br/>这需要AI面试工具的评分体系通过真实场景下的人机背靠背对比实验验证，同时经受住两项关键心理学指标考验：<br/>•效标效度（是不是在评真正重要的能力）<br/>•重测稳定信度（换时间、换场景，结果是否稳定）<br/>这意味着评分结果不是“辅助建议”，而是可以直接进入招聘决策链路的有效依据。<br/>精准，是贯穿招聘每一步的核心能力<br/>AI面试工具的“准”，体现在每一个招聘细节中：<br/>•一道题，不止评一道能力：一问多能，一道问题即可同步评估多项胜任力；HR初筛与技术复试自然衔接，整体评估效率提升50%以上。<br/>•像资深面试官一样追问：具备自由追问能力，根据候选人回答即时生成针对性问题；自动抓住模糊点、关键点，不遗漏核心能力。<br/>•简历不是“看过”，而是被彻底挖掘：自动识别简历中的关键信息与潜在风险；生成递进式提问，既防造假，也不放过优质人选。<br/>•适配多元岗位需求：既能评估沟通、协作等通用能力，也能针对编程、算法、工程、财务等专业领域精准出题。<br/>最终的结果是：HR和业务面试官，第一次不用靠“感觉”撑决策。<br/>候选人体验，成为招聘新分水岭<br/>AI面试的技术可行性之外，候选人体验同样关键，优质的AI面试工具会注重以下几点：<br/>•懂情绪的拟人化交互：能感知语速、情绪与表达状态，像真人HR一样引导候选人发挥。<br/>•无断点的对话流程：无需点击开始或结束，系统自动衔接问题，节奏自然。<br/>•更真实的视觉与语音体验：口型、语速、节奏高度匹配，告别“纸片人”式对话。<br/>•多轮互动答疑：候选人可随时提问，AI准确回答岗位、福利与企业信息。<br/>对候选人来说，这不再是一次“被机器审问”的过程，而是一场清晰、有尊重感的专业交流。<br/>招聘初筛进入“无人驾驶”模式<br/>除了AI面试，AI人才寻访工具也在重构招聘流程。它并非简单的自动回复工具，而是一整套能自动筛、自动聊、自动要简历的招聘执行系统：<br/>•30–60秒即启即用，无需人工值守；<br/>•按企业条件自动筛选简历；<br/>•拟人化沟通，自动判断是否继续；<br/>•主动索取简历，完整回收信息；<br/>•简历自动同步ATS，生成候选人档案。<br/>它的核心价值在于：把大量机械流程，彻底从HR工作中剥离出去，让招聘效率实现质的提升，本质是“人终于不用再做机器该做的事”。</p>]]></description></item><item>    <title><![CDATA[Google MusicFX 上手指南：零基础也能当 AI DJ？ blossom ]]></title>    <link>https://segmentfault.com/a/1190000047521264</link>    <guid>https://segmentfault.com/a/1190000047521264</guid>    <pubDate>2026-01-04 21:02:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>对于许多视频创作者或音乐爱好者来说，制作一段独一无二的 BGM 往往门槛极高。专业音乐软件（DAW）复杂的音轨和参数界面常令人望而却步。随着 AI 技术的进步，Google Labs 推出的 <strong>MusicFX</strong> 系列工具正在改变这一现状。</p><p>通过 <strong>MusicFX DJ</strong> 模式，用户无需识谱，无需昂贵的硬件设备，仅需简单的交互，即可体验实时控制音乐流动的乐趣。本文将深度解析 MusicFX DJ 的操作流程与进阶玩法。</p><h2>MusicFX DJ 是什么？</h2><p>不同于传统的“文生音频”工具（生成一段固定音频即结束），<strong>MusicFX DJ</strong> 是一个<strong>实时、无限流</strong>的生成式音乐工作台。它允许用户在音乐播放的过程中，动态添加乐器、调整风格、混合音轨，就像一位真正的 DJ 在现场即兴表演。</p><h2>操作指南：三步上手 AI DJ</h2><p>访问 MusicFX 网页后，首先需在界面右上角将模式切换至 <strong>"DJ Mode"</strong>。当界面转变为包含彩色滑块和底部控制面板的布局时，即表示已进入实时表演模式。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521266" alt="" title=""/></p><h3>第一步：添加音轨 (Add Tracks)</h3><p>MusicFX DJ 的核心驱动力来自提示词（Prompt）。在界面中部，可以找到 <strong><code>Add a prompt ...</code></strong> 输入区域，此处支持两种添加方式：</p><ol><li><strong>手动输入：</strong> 输入想要的风格或乐器名称（如 <code>Deep House</code> 或 <code>Jazz Saxophone</code>），点击右侧的 <strong>⊕ (加号)</strong> 或按回车键。</li><li><strong>随机灵感 (Random Prompt)：</strong> 点击输入框旁的<strong>随机图标</strong>（通常显示为刷新或骰子形状），AI 将自动生成一个风格建议，为创作带来意外惊喜。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521267" alt="" title="" loading="lazy"/></p><h3>第二步：管理音轨 (Manage Tracks)</h3><p>添加成功后，输入框上方会生成对应的<strong>彩色音轨控制条</strong>（例如绿色的 <code>hip hop beat</code> 或紫色的 <code>classical violin</code>）。用户可以对这些音轨进行实时管理：</p><ul><li><strong>开关控制 (Toggle)：</strong> 点击音轨条右侧的<strong>切换开关</strong>，可以随时静音该音轨或恢复播放。这在需要营造“突然安静”或“乐器切入”的效果时非常实用。</li><li><strong>删除音轨 (Delete)：</strong> 若不再需要某个声音元素，可以直接将其删除，保持界面的整洁和音乐的纯净。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521268" alt="" title="" loading="lazy"/></p><h3>第三步：实时控制 (Live Control)</h3><p>界面底部的深色控制面板是掌控全场氛围的关键区域。用户可以通过旋钮和按钮调整音乐的整体质感：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521269" alt="" title="" loading="lazy"/></p><ul><li><strong>左侧与中间面板：</strong></li><li><strong>Density (密度)：</strong> 控制音符的密集程度。</li><li><strong>Brightness (明亮度)：</strong> 调整音色的明暗色彩。</li><li><strong>Chaos (混乱度/随机性)：</strong> 这是一个有趣的参数，增加 Chaos 会让 AI 的演奏变得更加不可预测和即兴。</li><li><strong>右侧音量面板：</strong></li><li>独立控制 <strong>Drums (鼓点)</strong>、<strong>Bass (贝斯)</strong> 和 <strong>Other (其他乐器)</strong> 的音量配比。例如，在过门时关掉鼓点，在高潮时再推满，能制造强烈的节奏感。</li><li><strong>全局参数：</strong></li><li><strong>BPM：</strong> 调整音乐速度。</li><li><strong>KEY：</strong> 一键转调，确保所有生成的乐器都在同一个调式上，避免不和谐音。</li></ul><h2>进阶技巧：黄金配方与风格融合</h2><p>想要生成高质量的音乐流，建议尝试以下组合逻辑：</p><ol><li><strong>黄金提示词公式：</strong><br/><strong>风格 + 乐器 + 情绪</strong></li><li><em>示例：</em> <code>Upbeat acoustic folk</code> (风格) + <code>Ukulele</code> (乐器) + <code>Happy</code> (情绪)。</li><li><strong>风格大乱炖 (Genre Mashing)：</strong><br/>不要局限于单一风格。尝试在 <code>Hip Hop Beat</code>（嘻哈节奏）的基础上，叠加 <code>Classical Violin</code>（古典小提琴）和 <code>Video Game Sound Effects</code>（游戏音效）。这种强烈的反差感往往能创造出独特的听觉体验。</li></ol><h2>保存与分享</h2><p>当创作出一令人满意的旋律时，可以通过以下步骤保存作品：</p><ol><li>找到界面右下角的 <strong>分享图标 (&lt;)</strong>。</li><li>点击后，菜单中提供以下选项：</li><li><strong>下载 (Download)：</strong> 支持下载 <strong>60秒的纯音频</strong>，或带有酷炫可视化波形的<strong>视频</strong>文件，非常适合作为社交媒体素材发布。</li><li><strong>分享链接 (Share Link)：</strong> 生成一个专属链接。他人打开该链接后，将直接继承当前的“控制台”状态（包含所有已添加的音轨和参数设置），在此基础上继续 Remix（二创）。</li></ol><h2>总结</h2><p>MusicFX DJ 将复杂的音乐制作简化为直观的“添加”与“混合”操作。它不仅是一个 AI 音乐生成器，更是一个激发灵感的创意玩具。无论是为了寻找视频配乐，还是单纯享受控制声音的乐趣，它都提供了一个零门槛的入口。</p><p>本文由<a href="https://link.segmentfault.com/?enc=q%2FJNI5uVaO9FDGax2Bn2oQ%3D%3D.0oKyGgvQVlH%2FVomIc48kH6rHLpzN4N1UM3CzjgJJMNU%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[JAX性能优化实战：7个变换让TPU/GPU吃满算力 本文系转载，阅读原文
https://avoi]]></title>    <link>https://segmentfault.com/a/1190000047521276</link>    <guid>https://segmentfault.com/a/1190000047521276</guid>    <pubDate>2026-01-04 21:01:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>JAX跑得快的技巧其实很简单：通过组合变换让XLA能看到大块连续的计算，比如说批处理、融合、分片，让每一步在单设备或多设备同步时都像一个干净的kernel。</p><p>我们今天就来总结7个能够提高运行速度的JAX变换组合<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521278" alt="" title=""/></p><h2>1、 jit 优先，形状稳定</h2><pre><code>jit</code></pre><p>对函数做一次追踪后XLA负责融合算子，形状稳定、无副作用时，Python处理的开销就被分摊掉，可以提高运行速度。</p><p>形状创建和静态参数要么挪到step外部，要么显式标记为static。</p><pre><code>donate_argnums</code></pre><p>能让JAX复用缓冲区，省掉不必要的内存拷贝。step之间保持dtype和shape一致，trace结果才能被缓存下来。</p><pre><code> import jax, jax.numpy as jnp  

@jax.jit(donate_argnums=(0,))  
def sgd_step(params, batch, lr):  
    x, y = batch  
    def loss_fn(p):  
        preds = model_apply(p, x)  # pure function  
        return jnp.mean((preds - y) ** 2)  
    grads = jax.grad(loss_fn)(params)  
     return jax.tree_map(lambda p, g: p - lr * g, params, grads)</code></pre><p>每个(shape, dtype, static-arg)组合只追踪一次。频繁retrace多半是输入shape在变，或者Python逻辑泄漏进了计算图。</p><h2>2、vmap替换Python循环</h2><pre><code>vmap</code></pre><p>在leading axis上做向量化，XLA直接把batch融进kernel。for循环没了设备launch就少了，内存访问也更连续。</p><pre><code> # per-example loss  
 def example_loss(params, x, y):  
     pred = model_apply(params, x)  
     return jnp.mean((pred - y) ** 2)  
   
 # batch it without writing loops  
 batched_loss = jax.vmap(example_loss, in_axes=(None, 0, 0))  # params broadcasted</code></pre><p>嵌套</p><pre><code>vmap</code></pre><p>可以搞2D batch，比如time × batch，只要别超HBM容量。</p><pre><code>vmap</code></pre><p>适合做内层微批处理，比如ensemble或MC sampling这类场景，外层维度留给分片。</p><h2>3、长循环的融合利器Scan</h2><p>RNN、展开解码、迭代求解器，这些场景用</p><pre><code>scan</code></pre><p>比Python循环快。</p><pre><code>scan</code></pre><p>只编译一次循环体跑在XLA的while-loop里，Python开销基本为0，融合和内存复用也更激进。</p><pre><code> from jax import lax  

def rnn_cell(carry, x):  
    h = carry  
    h = jnp.tanh(W_hh @ h + W_xh @ x + b)  
    y = W_hy @ h  
    return h, y  # (carry, output)  

def rnn_forward(h0, xs):  
    hT, ys = lax.scan(rnn_cell, h0, xs)  # xs: [T, B, D]  
     return hT, ys</code></pre><p>循环状态用</p><pre><code>carry</code></pre><p>传递，body保持小而纯净，要注意保持形状不要变，比如：序列模型、diffusion step循环、定点迭代、beam解码（形状稳定时）都适用。</p><h2>4、remat可以用计算换内存</h2><p>批次大了TPU/GPU的FLOP利用率往往更高。</p><pre><code>remat</code></pre><p>（也叫checkpoint）会丢掉部分中间激活，反向时重算这样峰值显存下来batch就能开的更大。</p><pre><code> from jax import remat  

def block(params, x):  
    x = jax.nn.gelu(x @ params['w1'])  
    x = x @ params['w2']  
    return x  

fast_block = remat(block)  # checkpointed  

@jax.jit  
def forward(params, x):  
    for _ in range(6):  
        x = x + fast_block(params, x)  
     return x</code></pre><p>只包最重的子块就行，比如attention加MLP那几层。同时配合</p><pre><code>vmap</code></pre><p>或分片，全局batch能再往上拉。不过需要一些额外FLOPs，但如果换来1.3到2倍的batch increase，wall-clock往往更短。</p><h2>5、pmap单机多卡数据并行</h2><pre><code>pmap</code></pre><p>把函数复制到单主机的多个设备上（8卡工作站、单节点8核TPU），梯度可以自动all-reduce，并且每设备只编译一次。</p><pre><code> from jax import pmap, lax  

@pmap(axis_name='d')  
def train_step(params, batch, lr):  
    x, y = batch  # each device sees [local_B, ...]  
    def loss_fn(p):  
        pred = model_apply(p, x)  
        loss = jnp.mean((pred - y) ** 2)  
        return loss  
    loss, grads = jax.value_and_grad(loss_fn)(params)  
    loss = lax.pmean(loss, axis_name='d')  
    grads = lax.pmean(grads, axis_name='d')  
    params = jax.tree_map(lambda p, g: p - lr * g, params, grads)  
     return params, loss</code></pre><p>batch在leading axis分片，</p><pre><code>lax.pmean</code></pre><p>聚合loss和grads。单机场景下</p><pre><code>pmap</code></pre><p>简单可靠。跨主机扩展或者想做张量级细粒度分片可以成换</p><pre><code>pjit</code></pre><p>。</p><h2>6、pjit+ 命名分片：SPMD并行</h2><pre><code>pjit</code></pre><p>编译出单一SPMD程序可以跨设备跨主机运行。用mesh和</p><pre><code>PartitionSpec</code></pre><p>描述数组怎么切，JAX处理collective通信，这样数据并行、张量并行、混合并行都能做。</p><pre><code> import jax  
from jax.sharding import Mesh, PartitionSpec as P  
import numpy as np  

devices = np.array(jax.devices()).reshape(2, 4)  # 2 × 4 mesh (dp × mp)  
mesh = Mesh(devices, ('dp', 'mp'))  

@jax.jit  # jit is optional when using pjit; shown when composing  
def model_apply_sharded(params, x):  
    return model_apply(params, x)  

from jax.experimental.pjit import pjit  

with mesh:  
    in_shard  = (P('mp',), P('dp',))  # example; tailor to your shapes  
    out_shard = P('dp',)              # e.g., shard batch across dp  
    step = pjit(model_apply_sharded,  
                in_shardings=(P('mp',), P('dp',)),  
                out_shardings=out_shard)  
     y = step(params_sharded, x_sharded)</code></pre><p>一般都是batch轴走</p><pre><code>dp</code></pre><p>，大矩阵维度（hidden size、heads）走</p><pre><code>mp</code></pre><p>。分片数需要跟设备拓扑对齐，跨主机流量才少。</p><h2>7、value_and_grad的正确堆叠方式</h2><p>规范写法是</p><pre><code>jit(value_and_grad(loss, has_aux=True))</code></pre><p>，外面可以再套一层</p><pre><code>pmap</code></pre><p>或</p><pre><code>pjit</code></pre><p>。这样forward只跑一遍metrics留在aux里带出来。</p><pre><code> def loss_with_aux(params, batch):  
    x, y = batch  
    pred = model_apply(params, x)  
    loss = jnp.mean((pred - y) ** 2)  
    aux  = {'mse': loss, 'mean_pred': jnp.mean(pred)}  
    return loss, aux  

@jax.jit  
def train_step(params, opt_state, batch, lr):  
    (loss, aux), grads = jax.value_and_grad(loss_with_aux, has_aux=True)(params, batch)  
    updates, opt_state = optimizer_update(grads, opt_state, params, lr)  
    params = optax_apply(updates, params)  
     return params, opt_state, loss, aux</code></pre><pre><code>value_and_grad</code></pre><p>放</p><pre><code>jit</code></pre><p>里面，JAX会把forward和backward一起stage。返回</p><pre><code>(loss, aux)</code></pre><p>日志指标不用再跑一遍forward。</p><p>这套组合很灵活：</p><pre><code>vmap</code></pre><p>做微批次，</p><pre><code>scan</code></pre><p>跑时序循环，外面套</p><pre><code>pmap</code></pre><p>或</p><pre><code>pjit</code></pre><p>，</p><pre><code>donate_argnums</code></pre><p>标上buffer。</p><h2>总结</h2><p>变长序列pad加mask，shape稳定是前提条件。traced代码里不要添加Python随机性，比如PRNG key要在外面split好。矩阵乘用</p><pre><code>bfloat16</code></pre><p>，这样数值稳定性也够用，吞吐量在TPU/GPU上表现的也很好。性能profile要重点看warm-up之后的tokens/sec或samples/sec。日志只看标量aux metrics就行，每step把大数组传回host是性能杀手。</p><p>JAX的性能不是黑盒：</p><pre><code>jit</code></pre><ul><li>shape可以稳定打底，</li></ul><pre><code>vmap</code></pre><p>做batch，</p><pre><code>scan</code></pre><p>融合循环，</p><pre><code>remat</code></pre><p>回收显存，</p><pre><code>pmap</code></pre><p>或</p><pre><code>pjit</code></pre><p>做扩展，</p><pre><code>value_and_grad(..., has_aux=True)</code></pre><p>让每一步只跑一次forward一次backward。</p><p><a href="https://link.segmentfault.com/?enc=m0Z7QJhvPtMJmmUETO7PrA%3D%3D.RPIFS4mD%2FE7d%2FWjT8i%2BFqOPiq3OP87rb01qvaVw6m%2B4coTKdZI9k8MVdqeQ6pzHX6KwnzEkGQI6E6Fw3bpou0g%3D%3D" rel="nofollow" target="_blank">https://avoid.overfit.cn/post/84e4e28e3ca8473488a0e9248d1ec51b</a></p><p>作者：Nexumo</p>]]></description></item><item>    <title><![CDATA[MCP 与 Agent Skill：AI 能力扩展的双引擎 edagarli ]]></title>    <link>https://segmentfault.com/a/1190000047521300</link>    <guid>https://segmentfault.com/a/1190000047521300</guid>    <pubDate>2026-01-04 21:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2><strong>MCP 与 Agent Skill：AI 能力扩展的双引擎</strong></h2><p>在构建 AI 智能体时，开发者常常会面临一个选择：是为它安装一个“协议（MCP）”，还是教它一项“技能（Agent Skill）”？为了理清这两者的关系，我们可以将 AI 想象成一个<strong>厨师</strong>。</p><h3><strong>1. 核心定义：什么是 MCP 与 Skill？</strong></h3><h4><strong>MCP (Model Context Protocol) —— “万能插座”</strong></h4><p>MCP 是由 Anthropic 推出的一种开放标准。它像是一个 <strong>USB-C 接口</strong>或<strong>驱动程序</strong>。它的核心任务是<strong>连接性（Connectivity）</strong>。它定义了一套标准化的语言，让 AI 模型能够直接“插入”并访问外部数据库、本地文件系统或 Slack 等 SaaS 工具，而无需为每个工具编写特定的接口。</p><ul><li><strong>本质：</strong> 标准化的通信协议。</li><li><strong>解决的问题：</strong> AI 如何“够得着”外部数据？</li></ul><h4><strong>Agent Skill —— “操作手册”</strong></h4><p>Agent Skill（或称插件、Tools、Action）更像是<strong>专业知识的封装</strong>。它专注于<strong>能力（Capability）</strong>。它告诉 AI 在面对特定任务时，应该按照什么步骤、使用哪些逻辑去执行。它是一段包含逻辑、指令和特定参数的代码块。</p><ul><li><strong>本质：</strong> 领域知识与工作流的封装。</li><li><strong>解决的问题：</strong> AI 如何“学会”处理复杂任务？</li></ul><h3><strong>2. 深度对比：维度解析</strong></h3><table><thead><tr><th align="left">维度</th><th align="left">MCP (模型上下文协议)</th><th align="left">Agent Skill (智能体技能)</th></tr></thead><tbody><tr><td align="left"><strong>类比</strong></td><td align="left">USB 接口 / 打印机驱动</td><td align="left">烹饪菜谱 / 会计技能包</td></tr><tr><td align="left"><strong>侧重点</strong></td><td align="left"><strong>基础设施</strong>。让连接更简单、安全、标准。</td><td align="left"><strong>业务逻辑</strong>。让执行更专业、精准。</td></tr><tr><td align="left"><strong>复用性</strong></td><td align="left">极高。一个 MCP 服务可供所有兼容协议的 AI 使用。</td><td align="left">中等。通常绑定在特定的智能体框架内。</td></tr><tr><td align="left"><strong>交互深度</strong></td><td align="left">偏向于数据获取、资源列举、工具调用标准。</td><td align="left">偏向于多步推理、复杂计算、特定业务流。</td></tr><tr><td align="left"><strong>安全性</strong></td><td align="left">协议级控制。统一管理权限和机密。</td><td align="left">函数级控制。在代码逻辑内控制安全边界。</td></tr></tbody></table><h3><strong>3. 实例展示</strong></h3><h4><strong>场景：企业财务报表分析</strong></h4><ul><li>使用 MCP 的场景：  <br/>AI 通过 SQL MCP 服务器 连接到公司的财务数据库。它不需要知道怎么“计算”利润率，它只需要通过 MCP 协议发出请求：“请列出上季度的所有开支记录”。MCP 负责把数据库里的原始数据安全地“搬运”给 AI。</li><li>使用 Agent Skill 的场景：  <br/>AI 运行一个名为 “财务分析专家”的 Skill。这个 Skill 包含了计算 EBITDA（息税折旧摊销前利润）的复杂公式和分析逻辑。AI 获取数据后，调用这个 Skill 进行专业计算，并生成符合财务规范的报告。</li></ul><h3><strong>4. 总结：双剑合璧</strong></h3><p>在实际应用中，MCP 和 Skill 通常是<strong>互补</strong>的：</p><ol><li><strong>MCP</strong> 负责“手”和“眼”，让 AI 能看到数据、触碰到系统。</li><li><strong>Agent Skill</strong> 负责“大脑”，让 AI 知道拿到数据后如何思考和操作。</li></ol><p>未来的 AI 架构将是：<strong>通过 MCP 接入海量数据，通过丰富的 Skill 库执行专业任务。</strong></p>]]></description></item><item>    <title><![CDATA[IPD 阶段评审（TR）怎么做：流程、模板与评审要点全解析 研之有李 ]]></title>    <link>https://segmentfault.com/a/1190000047521089</link>    <guid>https://segmentfault.com/a/1190000047521089</guid>    <pubDate>2026-01-04 19:04:41</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>硬件研发最“昂贵”的问题就是在该冻结时没冻结、在该验证时没验证、在该拒绝时没拒绝：需求理解偏差、接口假设失真、DFx缺位，最终在试产或量产阶段集中爆雷。IPD 阶段评审（TR）的价值，是把风险前移，用“入口/出口标准 + 证据包 + 结论机制 + 闭环审计”把研发从“靠经验推进”升级为“靠证据决策”。</p><h2>要点速览</h2><ol><li>TR 是技术闸门：不是汇报会，而是关口判定（Go / Conditional Go / Recycle / Hold / Kill）+ 下一阶段授权。阶段门体系对“关口输出=明确决策+路径”有清晰要求。</li><li>TR 的核心对象：技术成熟度、可验证性、可制造/可测试/可靠性、供应链韧性，以及风险承诺是否可控。</li><li>最关键的落地抓手：Entry/Exit（入口/出口标准）+ Evidence（证据包）+ Closure（行动项可验收闭环）。NASA 的技术评审强调“入口与成功标准”的可裁剪与可审计性。</li><li>为什么要前移：缺陷越晚发现，平均修复成本趋势性上升；硬件里这种放大效应更直接。</li></ol><blockquote>你可能在搜索这些：IPD 阶段评审怎么做 / TR评审流程 / TR模板 / TR评审要点 / 阶段门管理 Go-Kill / 入口出口标准 Entry Exit</blockquote><h2>硬件研发最常见的三种“评审失效”</h2><p>很多企业不是没做评审，而是把评审做成了“形式正确、治理无效”。最常见的失效模式有三类：</p><p>1）评审变成“汇报会”</p><p>项目组讲进展、专家点评、纪要很长，但缺少两件决定性的东西，一是可判定的出口标准（达到/未达到，不靠感觉）；二是明确的关口结论（通过/返工/暂停/终止，以及下一步怎么走）。</p><p>2）风险发现得太晚</p><p>工程管理里有一个朴素但残酷的规律：缺陷发现越晚，修复成本越高。PMI 的解释也指出：缺陷被发现得越晚，平均修复成本呈指数式上升趋势。对硬件而言，这种放大不仅体现在研发工时，还体现在重打样、重新认证、供应链备料报废、产线节拍重算，甚至客户侧返修与品牌损失。</p><p>3）跨部门对齐失败</p><p>研发说“功能通了”，制造问“可测试吗？节拍算过吗？良率目标呢”？质量问“证据链在哪？可追溯吗”？供应链问“关键料有二供吗“？如果 IPD 阶段评审没有共同语言（条款库/证据形态/结论规则），就会退化成“谁嗓门大听谁的”。</p><h2>先把概念说清楚：TR 是“技术闸门”，不是“开个会”</h2><p>很多团队把 IPD 阶段评审理解为“技术评审会议”，这只对了一半。更准确的定义是：</p><p><strong>TR = 技术成熟度关口判定 + 下一阶段授权 + 风险承诺签署</strong></p><p>你可以把 TR 看作“技术侧的 Gate”：</p><ul><li>输入：阶段交付物 + 证据包（Evidence Package）</li><li>标准：入口/出口条款（Entry/Exit Criteria）</li><li>输出：结论（Go/Recycle/Hold/Kill）+ 通过条件 + 风险与行动项闭环</li></ul><p>NASA 在 NPR 7123.1 的 Appendix G 中，专门给出了生命周期与技术评审的“入口与成功标准”最佳实践，用来保证评审可判定、可复核。</p><p>工具实践：如果你希望把“关口结论、通过条件、豁免条款、证据链接”固定成可审计对象，实践里通常会把它们沉淀为标准化的工作流与文档模板。<a href="https://link.segmentfault.com/?enc=NP1Yw7g1p85yn1jsepm9%2Bg%3D%3D.A0TpAUf6KGzHb7LPOUfGwASoIVKz%2F%2FMuaZccco47R%2FY%3D" rel="nofollow" target="_blank">ONES 的 IPD 解决方案</a>就按阶段呈现了概念/计划/开发/验证/发布，并在计划阶段强调 TR2&amp;TR3 等技术评审对技术方案与子系统设计的一致性验证思路，可作为“阶段映射与评审节奏”参考。</p><h2>一个可复用的 TR 治理框架：3 个前提 + 2 套标准 + 1 个闭环</h2><p>要让 IPD 阶段评审不跑偏，我建议用“3-2-1”把 TR 制度化（最容易复制、最不依赖个人经验）。</p><h4>1）三个前提：基线、追溯、风险清单</h4><p>（1）基线（Baseline）：让评审结论有“落脚点”</p><p>硬件研发最怕“会议过了，但版本没定”：需求在变、接口在变、BOM 在变，评审结论无法落地。建议基线至少包含：需求版本、系统架构与关键接口、关键器件策略、验证策略与里程碑。基线化不是为了僵化，而是为了让变更可管理（有入口、有成本、有责任人）。</p><p>（2）追溯（Traceability）：让“满足需求”可被证明</p><p>TR 不检查你写了多少文档，而检查“证据链是否闭环”。典型的追溯矩阵（RTM）就是把需求与相关测试/工件关联起来，用于验证需求是否被满足、范围是否发生变化。落地上，至少要能回答：关键需求能否追到设计与测试证据？哪里断链？断链意味着什么风险？</p><p>工具实践：在执行层面，追溯最难的不是“理念”，而是“把关联关系做成日常动作”。例如 ONES Project 描述了需求池、需求状态/属性、迭代规划与缺陷管理在同一工作项体系内协同，能降低“追溯链靠手工拼表”的成本；同时 ONES TestCase 强调用例与需求/任务关联、并可从未通过用例一键创建缺陷，有助于把“证据链”自然长出来。</p><p>（3）风险清单（Risk Register）：让风险从“形容词”变成“行动项”</p><p>有用的风险条目必须包含：触发条件、影响面、缓解措施、应急预案、验证方式。如果风险没有“触发条件”和“验证方式”，它就无法在 TR 上被判定，只能沦为形容词。</p><h4>2）两套标准：Entry / Exit（入口/出口标准）</h4><p>很多 TR 失败，是因为标准写得像口号：“设计基本完成”“风险可控”。这种句子无法判定，也无法审计。更成熟的做法是像 NASA 技术评审那样——明确“入口与成功标准”的条款化表达（并按项目裁剪）。</p><p>条款写法模板（建议你直接沿用）</p><p><strong>条款 = 动词 + 对象 + 判定方式 + 证据形态</strong></p><p>例：“关键需求覆盖率 ≥95%（证据：需求-用例追溯矩阵/链接）”；“关键接口已冻结（证据：ICD版本 + 变更记录）”；“试产测试准备就绪（证据：治具清单 + 校准记录 + 脚本版本库）”。</p><h4>3）一个闭环：行动项必须可验收，否则TR只是“提出问题”</h4><p>TR 最常见的组织性浪费是：会上列了一堆行动项，回去没人验收，下一次评审又讨论同样的问题。建议把行动项写成“工程可验收语言”：</p><ul><li>Owner（负责人）</li><li>Due Date（到期时间）</li><li>验收证据（报告编号/版本链接/测试记录/变更单号）</li><li>关闭标准（什么状态算关闭）</li></ul><h2>TR 全流程怎么跑：会前—会上—会后（附可直接复用模板）</h2><p>TR 的流程看似简单，但要防止“走形”，建议加两道机制：资料预审与豁免机制。<br/>会前：定义评审范围、结论类型与“不可妥协条款”</p><p>把 TR 写进主计划，至少明确三件事：</p><ol><li>评审范围：本次 TR 覆盖哪些子系统/关键特性（电源、射频、结构散热、安全合规等）。</li><li>结论类型：Go / Conditional Go / Recycle / Hold / Kill。Stage-Gate 的典型输出就是 Go/Kill/Hold/Recycle，并要求对照预设标准与交付物来决策。</li><li>不可妥协条款（Hard Gate）：例如法规合规路径未明确、关键安全需求没有验证计划评审通过、关键长周期料无备选等——这些条款不满足，原则上只能 Recycle 或 Hold。</li></ol><p>经验提醒：宁可 Hard Gate 少，但必须执行。一旦“硬条款”被轻易豁免，TR 权威会快速坍塌。</p><h4>会前：TR Package（证据包）模板</h4><p>TR Package 的关键不是“写得多”，而是“证据能被追溯、能被复核”。建议固化以下结构：</p><ol><li>TR Package（可复制目录）</li><li>项目概览：目标/范围/版本/里程碑偏差</li><li>阶段交付物清单：完成度 + 证据链接 + 阻塞项</li><li>需求与范围基线：变化点 + 影响评估（成本/进度/质量）</li><li>系统架构与关键接口：ICD状态、兼容策略</li><li>关键技术成熟度证据：原型/实验数据/关键性能边界</li><li>验证与测试证据：覆盖率、缺陷分布、未关闭项与风险承诺</li><li>DFx评估：DFM/DFT/DFA、工艺窗口、治具策略</li><li>可靠性与合规：试验矩阵、认证路线、风险点</li><li>供应链与成本风险：长周期料、二供、备料策略</li><li>风险清单与对策：Top风险（触发条件+缓解+验证）</li><li>待决策问题：需要评审委员会拍板的关键取舍</li><li>行动项清单（预置）：便于会上直接确认 Owner 与验收方式</li></ol><p>工具实践：证据包最容易“散落在各处”。为了避免“评审前一晚到处找材料”，很多团队会把 TR Package 做成模板化文档，并要求每条证据都可点到来源、且可版本回滚。ONES Wiki 描述了文档模板库、版本可控与回滚、以及文档与任务/项目的关联能力，用来做 TR Package 与评审纪要的承载会比较顺手。</p><h4>会中：把会议做成“判定系统”，而不是“讨论系统”</h4><p>建议议程（90~120分钟）可以保持，但要用三条规则把它“钉住”：</p><p>规则1：先对照 Exit 标准，再讨论如何补齐——否则容易陷入“讨论很充分，但不知道是否过关”。</p><p>规则2：以证据作为共同语言——凡是“我觉得”“应该没问题”，都必须转换成：证据在哪里？如果没有证据，行动项怎么补？什么时候验收？</p><p>规则3：Conditional Go 必须绑定“豁免条款（Waiver）”——豁免不是放行，而是“显性承诺风险”：</p><ul><li>豁免条款是什么、风险是什么</li><li>如何监控、何时必须关闭</li><li>超期如何升级（到谁、用什么机制）</li></ul><h4>会后：两件事决定 TR 成败——关口签署 + 闭环审计</h4><p>（1）关口签署（建议固定纪要字段，方便审计与复盘）</p><p>TR 纪要固定字段（可复制）</p><ol><li>评审结论：Go / Conditional Go / Recycle / Hold / Kill</li><li>通过条件（如有）：必须在 X 日前关闭哪些条款</li><li>豁免条款（如有）：风险承诺、监控方式、升级机制</li><li>基线版本：需求/架构/ICD/BOM/测试策略版本号</li><li>行动项清单：Owner / Due / 验收证据 / 关闭标准</li></ol><p>（2）闭环审计（T+7 / T+14 的“抽检式复核”）</p><p>重点抽检两类：</p><ol><li>关键风险项是否进入受控闭环（而不是“口头说解决了”）</li><li>证据是否真实有效（不是“写了报告但没有数据”）</li></ol><h2>不同阶段 TR 该评什么</h2><p>你可以借用“成熟度问题清单”的思路：不同阶段评不同问题，否则 IPD 阶段评审会变成“每次都评同一套材料”。</p><p>NASA 的技术评审体系强调：应定义入口与成功标准，并按项目复杂度裁剪；同时也强调技术团队要为整体评审包提供技术输入。将其映射到企业硬件研发，可用以下焦点：</p><p>概念/立项前后（类似SRR）：需求可信、边界清晰、风险可陈述</p><ul><li>需求是否可验证？是否存在不可检验的形容词？</li><li>关键约束是否明确（功耗/尺寸/成本/法规/可靠性）？</li><li>Top风险是否具备触发条件与验证计划？</li></ul><p>方案/计划阶段（类似PDR）：架构合理、接口受控、关键假设有证据</p><ul><li>架构能否覆盖关键需求？是否存在单点失败？</li><li>ICD 是否冻结？兼容策略是否明确？</li><li>关键假设（热/EMC/性能上限）是否有实验或原型证据？</li></ul><p>详细设计阶段（类似CDR）：可实现、可制造、可测试</p><ul><li>设计是否足以支撑“做出正确的东西”：图纸/BOM/公差/关键器件策略是否完整？</li><li>DFx 是否闭环（DFM/DFT/DFA）？</li><li>关键器件是否具备二供或替代认证路径？</li></ul><p>集成与系统测试前（类似TRR）：测试准备就绪、数据可采、缺陷门禁清晰</p><ul><li>环境/治具/脚本/校准流程是否就绪并版本受控？</li><li>关键用例通过标准是否明确？采数与判定规则是否一致？</li><li>阻断缺陷门禁是否设定并执行？</li></ul><p>试产/量产前（类似PRR）：生产准备就绪、质量控制可执行、供应链可兑现</p><ul><li>工艺、工装、检验规程、质量控制计划是否就绪？</li><li>产线节拍与爬坡计划是否有数据支撑？</li><li>供应链交付能力与质量能力是否评估通过？</li></ul><h2>IPD 阶段评审（TR）最关键的 10 个检查维度</h2><p>这部分是“可直接变成企业TR条款库”的写法，也是最利于索引与复用的结构：</p><p>1.需求质量：需求是否可验证？是否有验收标准与边界？<br/>证据：需求规范版本 + 验收标准/用例清单 + 需求评审记录</p><p>2.端到端追溯：关键需求是否能追到设计与测试证据？断链在哪里？<br/>证据：追溯矩阵（需求→设计→用例→测试报告）</p><p>3.关键假设显性化：性能边界、环境条件、制造能力假设是否写清？哪些尚未验证？<br/>证据：假设清单 + 验证计划 + 实验数据</p><p>4.接口与集成风险：接口是否冻结？跨供应商接口如何验收？<br/>证据：ICD版本 + 变更记录 + 联调报告</p><p>5.技术成熟度证据：关键技术点有没有数据，而不是信心？<br/>证据：原型实验报告/曲线数据/环境测试记录</p><p>6.DFx（可制造/可测试/可维护）：可测试性是否覆盖关键失效模式？治具是否可复制？<br/>证据：DFx评审记录 + 治具方案 + 测试覆盖说明</p><p>7.可靠性与合规：可靠性指标如何分解？认证路线是否清晰？<br/>证据：可靠性计划/试验矩阵 + 合规路线图</p><p>8.供应链韧性：长周期料识别了吗？二供/替代料认证计划可执行吗？<br/>证据：关键料清单 + 风险评估 + 替代料验证计划</p><p>9.变更控制：重大变更是否评估影响并经批准？基线是否清晰？<br/>证据：ECR/ECO记录 + 影响评估 + 基线管理记录</p><p>10.风险与行动项闭环：Top风险是否都有“触发条件+缓解+验证”？行动项是否可验收？<br/>证据：风险登记册 + 行动项关闭记录</p><h2>让 TR 变成组织能力：三条治理建议</h2><p>1）标准化“条款库与证据形态”，减少对个人能力的依赖</p><p>评审委员会可以换人，但条款库、证据包、签署机制必须稳定。NASA 的入口/成功标准思想，就是在强调“评审可复制”。</p><p>2）把委员会做“轻”，把规则做“硬”</p><p>硬规则包括：资料预审不过不进会；Hard Gate 不满足原则上不得 Go；Conditional Go 必须绑定豁免条款与升级机制。这样 IPD 阶段评审才像“闸门”，而不是“建议会”。</p><p>3）用数据衡量 TR 有效性，而不是衡量“开了几次会”</p><p>建议至少跟踪四类指标，并明确“指标读法”：<br/>行动项按期关闭率：低 → 执行力与验收机制不足<br/>行动项复开率：高 → 标准不清或证据质量差<br/>TR 后逃逸缺陷：高 → 关键风险前移不足<br/>试产良率/返修工时趋势：恶化 → DFx/测试准备/供应链问题未被闸门拦住</p><p>工具实践：指标想持续跑起来，关键是“数据别靠手工汇总”。例如 ONES Performance 的定位是从统一入口查看多项目、多团队、多流程的效能表现，适合作为 TR 之后的改进度量面板；而 ONES IPD 解决方案也把效能管理、项目集管理等模块纳入方案组合，便于把“关口决策—交付节奏—效能度量”串起来。</p><h2>常见问题 FAQ</h2><p>Q1：IPD 阶段评审（TR）和 DCP/商业决策有什么区别？<br/>A：TR 更偏技术成熟度与工程可交付能力的关口判定；DCP 更偏商业价值与资源投资决策。实践中，TR 的风险结论往往是 DCP 的关键输入。</p><p>Q2：TR 最容易走形的地方是什么？<br/>A：两点：一是没有 Entry/Exit，导致只能“听汇报”；二是行动项不可验收，导致问题不闭环。</p><p>Q3：Conditional Go 可以频繁用吗？<br/>A：可以用，但必须绑定“豁免条款（Waiver）”：未满足条款是什么、风险是什么、如何监控、何时关闭、超期如何升级。否则 Conditional Go 就会变成“默认放行”。</p><p>IPD 阶段评审（TR）真正的价值，不在于材料有多漂亮，而在于把研发推进从“靠经验与乐观”转为“靠标准与证据”。当你建立起 Entry/Exit 标准、证据包、关口结论、豁免规则与闭环审计，TR 就不再是项目负担，而会沉淀为组织能力：更早暴露风险、更少返工、更稳定交付，推动研发体系从“流程合规”走向“治理有效”。</p>]]></description></item><item>    <title><![CDATA[阿里云ESA Pages 边缘开发大赛-将创意网页部署至您的第一朵前端云 阿里云ESA ]]></title>    <link>https://segmentfault.com/a/1190000047521093</link>    <guid>https://segmentfault.com/a/1190000047521093</guid>    <pubDate>2026-01-04 19:03:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img width="723" height="439" referrerpolicy="no-referrer" src="/img/bVdnyy8" alt="image.png" title="image.png"/></p><h3>1、赛事介绍</h3><p><a href="https://link.segmentfault.com/?enc=LOv0dh%2BdjRCoaPBvUq9brg%3D%3D.qVuVqI%2F57XQofrzsbgDqNIs2UPnbQOb0BKjG9XTAIwhgSR1CzkVGmVTtfOisRJ1C%2F6bi2OYLktfVlaMFphzYZTD64opjjlIbohDQx4iYjWMBchfL8kT9Nt1VG1bM6pBOr6oeSvvsCdkn92W9hkaK7A3kAICfUXMgqXKQuoeNwlo%3D" rel="nofollow" target="_blank">“阿里云ESA Pages 边缘开发大赛”</a>是阿里云边缘安全加速ESA依托阿里云天池举办的前沿技术赛事。聚焦边缘计算、AI与前端工程的深度融合，让代码和AI在边缘绽放。我们欢迎全球开发者一起在阿里云ESA Pages边缘开发平台上释放创意，构建实用、好用的边缘应用，共同探索AI原生时代下前端开发的边缘新范式。立即参赛，10万元奖池等你拿！</p><p>阿里云ESA Pages深度兼容React、Vue等主流前端框架，可快速托管部署您的网站并在全球提供加速和保护，快速了解阿里云ESA Pages。</p><h3>2、赛制说明</h3><p><strong>报名提交时间：2025年12月11日00:00:00——2026年01月20日 23:59:59</strong></p><ul><li>参赛者通过天池平台进行报名，确保报名信息准确有效，否则会被取消参赛资格及激励。参赛选手需在2026年01月20日 23:59:59前完成实名认证（ 实名认证入口：天池网站-个人中心-认证-支付宝实名认证），未按要求完成实名认证选手，将被取消参赛资格；</li><li>本次不支持多人组队，选手以个人模式参赛；</li><li>选手报名成功后，请按照赛题的提交说明，在左侧提交结果入口进行提交；</li><li>每人可提交多个作品参赛，每个作品均可独立评分领奖！</li></ul><p><img width="723" height="435" referrerpolicy="no-referrer" src="/img/bVdnyzc" alt="image.png" title="image.png" loading="lazy"/></p><h4>参赛规则</h4><ul><li>本赛道仅支持单人参赛。用淘宝或阿里云账号登录天池官网，完成个人信息注册，即可报名参赛。请确保报名信息准确有效。</li><li>本赛道面向全球高校学生、开发者、初创团队、企业工程师。大赛举办方，技术支持单位，以及其他有机会接触赛题背景的业务、产品、数据的工作人员，无参赛资格；阿里和蚂蚁集团（含集团内子公司）员工（包括实习生和外包员工），可参赛排名，但不参与评奖及奖金领取。</li><li>我们鼓励通过AI生成的方式生成您的作品。</li><li>网站应为参赛者原创，且不侵犯第三方版权、商标及隐私权。如发现抄袭、作弊、伪造信息等行为，主办方有权取消参赛资格。</li><li>内容应健康合规，不得含有违法、暴力、仇恨、误导等不当信息。</li><li><p>大赛主办和技术支持单位如有机会接触赛题背景业务、产品、数据的员工，则自动退出比赛，放弃参赛资格。<br/><img width="723" height="438" referrerpolicy="no-referrer" src="/img/bVdnyzd" alt="image.png" title="image.png" loading="lazy"/></p><h3>3.评选标准</h3><p>我们将对每个参赛作品从如下3个维度分别进行评分和排名，每个评选方向均设置了高额奖金，参赛作品只要在评选方向进入对应排名，即可获得对应奖励。每个参赛者可投递多个作品，且每个作品都有机会获奖。具体作品激励详见赛题页-赛制中作品激励奖：</p></li><li>创意卓越：想法和概念独特、让人眼前一亮，视觉效果美观。</li><li>应用价值：在生活和工作中有很好的实用价值。或具备快速传播的价值，使用者无需修改，部署即用。</li><li>技术探索：是否基于ESA完整的边缘生态产品（Pages+边缘函数+边缘存储+缓存）构建边缘应用，以及技术实现难度。</li></ul><h3>提交说明</h3><p>各参赛选手报名且完成Pages作品后，需要在天池赛题页左侧-【提交结果】入口提交如下资料:</p><ul><li>请将作品访问URL地址、Github仓库地址、作品说明写入1个TXT文件中并上传</li><li>本赛事支持投递多个作品参赛，每个作品信息的TXT文件请分开单独提交每人每天不限提交次数，每个作品均可独立评分领奖</li><li>提交多个参赛作品，我们将对作品从创意卓越、应用价值、技术探索三个评分方向分别评分和排名</li><li>同一个项目重复提交，请重点标注下优化点，如未标注优化点，同一项目作品重复提交分数则标记为0.01分（属于无效提交）。<br/> <img width="723" height="400" referrerpolicy="no-referrer" src="/img/bVdnyze" alt="image.png" title="image.png" loading="lazy"/></li></ul><h3>[快速入门]通过导入Github仓库创建Pages</h3><p>边缘安全加速 ESA支持直接导入Github仓库，可通过已有的仓库代码快速启动并部署项目。前提条件已开通函数和Pages服务。拥有一个可用的Github账号和代码仓库。操作步骤Pages 与代码管理系统无缝集成，使开发工作流与部署过程之间能顺畅同步。登录ESA控制台，在左侧导航栏选择边缘计算 &gt; 函数和Pages。在边缘函数页面，单击创建。选择导入Github仓库页签，单击添加Github账户。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521096" alt="图片" title="图片" loading="lazy"/><br/>登录Github账号后，在授权页面默认选择All repositories，单击Install &amp; Authorize完成仓库授权。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521097" alt="图片" title="图片" loading="lazy"/><br/>选择需要构建的对应仓库名，单击下一步。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521098" alt="图片" title="图片" loading="lazy"/><br/>填写构建信息，单击开始部署。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521099" alt="图片" title="图片" loading="lazy"/><br/>等待系统构建完成后，将为您生成一个公共域名访问链接，可直接访问预览效果<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521100" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521101" alt="图片" title="图片" loading="lazy"/></p><h3>赛事激励</h3><p><img width="723" height="435" referrerpolicy="no-referrer" src="/img/bVdnyzg" alt="image.png" title="image.png" loading="lazy"/><br/><img width="723" height="353" referrerpolicy="no-referrer" src="/img/bVdnyzh" alt="image.png" title="image.png" loading="lazy"/><br/><img width="723" height="432" referrerpolicy="no-referrer" src="/img/bVdnyzj" alt="image.png" title="image.png" loading="lazy"/></p><h3>赛事优秀作品</h3><p>赛事优秀作品查看：<a href="https://link.segmentfault.com/?enc=4%2FhoWr%2BZaHmEw28nnYmU%2FA%3D%3D.hOql9yVHd81vI9zoPwUofID4dEr6UlH7BExbRU7d%2BG4X%2BDyjY2EM948Jaylh%2FIwwSJ3kYp4LpvulT15XkDBvXQ%3D%3D" rel="nofollow" target="_blank">https://rank.event.alibabacloud-esa.com/#showcase</a><br/><img width="723" height="437" referrerpolicy="no-referrer" src="/img/bVdnyzn" alt="image.png" title="image.png" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[融云 2025 回顾:「韧性」生长，「邪修」破局 融云RongCloud ]]></title>    <link>https://segmentfault.com/a/1190000047521108</link>    <guid>https://segmentfault.com/a/1190000047521108</guid>    <pubDate>2026-01-04 19:02:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>2025 的进度条已经拉满，各个平台的年度词单也都如期而至了。从大洋彼岸权威词典的严肃定义，到中文互联网上脑洞大开的野生热梗；从传统媒体的时代注脚，到社交平台深夜刷屏的情绪共鸣。虽然语境不同、出处各异，但这些词一起描绘了当下的现实纹理，也讲述着我们在不确定性中寻找出口的生存智慧。相信当你看到它们时，也能感受到那份心照不宣的默契。</p><p>来吧，翻开这份词单，看看哪一个能精准击中你的 2025？</p><h2>01 社媒热词：邪修</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521110" alt="图片" title="图片"/></p><p>原指仙侠小说中的非正统流派，现指一种“反套路实用主义”的生活哲学。用看似离谱、实则高效的方法直击痛点，主打“过程不被定义，结果令人惊喜”。</p><h4>人生苦短，我选邪修💃</h4><h4>融云对话 Agent</h4><p>“邪修”的精髓在于“能成就行，姿势随意”。融云把对话 Agent 用在运营领域，正是这样一种跳出常规、务实有效的探索。</p><p>不纠结于“AI 是否必须扮演客服或娱乐伴侣”这个命题，而是直接切入“怎么用对话 AI 撬动用户响应、提升转化”的实际场景。</p><p>☑ 看着是平平无奇的聊天窗口，实则是精心设计的转化漏斗；<br/>☑ 在拟人化 AI 的沉浸式陪伴中，让商业变现无感落地。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521111" alt="图片" title="图片" loading="lazy"/></p><h2>02 剑桥词典：Parasocial</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521112" alt="图片" title="图片" loading="lazy"/></p><p>原指单方面投入的虚幻社交，现指对全天候在线和情绪价值拉满的 AI 产生了羁绊。虽然对象是虚拟的，但陪伴和需要是真实的。</p><h4>赛博陪伴，AI 解忧🤖</h4><h4>融云 AI 矩阵</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521113" alt="图片" title="图片" loading="lazy"/></p><p>在物理现实与数字生活深度交织的今天，AI 应用凭借持续且走心的对话交互，正与用户建立起深度的沉浸关系。这揭示了 Parasocial 所蕴含的巨大潜能，而对话式 AI 正是其关键引擎。融云将主流大模型能力与通信系统深度融合，辅以语音转写、智能翻译等能力，提供 AI 陪伴、AI 助聊等开箱即用的智能通信服务。这种无缝接入的智能化升级，让各类产品都能快速满足用户对线上陪伴和即时回应的深层需求。</p><h2>03 小红书：赛博对账</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521114" alt="图片" title="图片" loading="lazy"/></p><p>由于美国封禁 TikTok 而意外引起了中美网友在小红书上的一次“赛博握手”。互晒猫猫狗狗之后，大型比价活动就此展开🧾。这是 2025 年热度最高的文化切片之一。</p><h4>消除时差，全球比价🌏</h4><h4>融云全球本地化</h4><p>“赛博对账”的背后，是全球信息流动的加速。而处于深水区的全球化业务，面临的最大挑战正是如何抹平“体验摩擦”。</p><p>作为最早出海的通信云服务商，在与无数中国应用并肩征战全球的过程中，融云深谙网络参差不齐这一挑战的应对之道，致力于提供符合当地习惯的交互体验：</p><p>交互体验“零时差”：打造了一张覆盖全球的通信网并持续升级，在多年业务实践中积累技术、沉淀方案，确保消息必达、音视频流畅，让全球用户在体验上实现“零时差”。<br/>业务落地“零违和”：深耕中东、东南亚、拉美等核心地区，深入社交泛娱乐、游戏、电商、Web3 等业务腹地，提供适配当地终端机型、符合地缘合规要求及用户交互习惯的场景化方案。</p><ul><li>2025 全球数字经济大会首批「出海严选服务商」</li><li>创业邦「2025 中国企业全球化新势力 100 强·引领型」</li><li>2025 鲸鸣奖「年度卓越出海领军人物奖」</li></ul><h2>04 《咬文嚼字》杂志：韧性</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521115" alt="图片" title="图片" loading="lazy"/></p><p>本指物体受外力作用时，变形但不易折断的性质。近年来频繁出现在政府文件和媒体报道中，指在承受压力与冲击时保持核心稳定、快速适应恢复并持续发展的能力。</p><h4>表面头铁，实则满血💪</h4><h4>自主技术赋能全球</h4><p>这种韧性，外化为头铁硬刚的战略定力，内里实则是长期积淀的满血底气。创立十年，融云与中国互联网黄金时代共振，也在全球竞争和技术变革中自我迭代。逐步完成中国技术价值的外溢，将经过最大规模市场、大并发场景验证的中国方案输送至全球。</p><p><strong><em>融云十周年</em></strong></p><p>十周年之际，【浅黑科技】的深度文章很好地诠释了融云如何体系化锻造“韧性”——当年搞出了「飞信」的师傅，如今竟扛着 200 多个国家的聊天、弹幕和日常？（移步【融云全球互联网通信云】）</p><p>而在这个行业、技术和个人都立于时代十字路口的时刻，融云特别推出十周年献礼纪录片《十字路口》。用 5 期系列正片内容，以不同主题视角来探讨：面对时代变化，个体如何选择？</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521116" alt="图片" title="图片" loading="lazy"/><br/>【融云全球互联网通信云】查看视频</p><p>从传统互联网时期的小步快跑，到 AI 时代的持续交付，技术范式在变，但在实践中迭代的底层逻辑从未改变。务实专注又与时俱进，沿着专业价值日复一日地向前跋涉，构成了融云品牌价值主张的内核：相信持续精进的力量。而这，也是我们面对市场波动和周期演进的共同“答案”。</p><p><strong><em>中国技术赋能全球</em></strong></p><p>数字经济年初，DeepSeek-R1 的登场，让世界看到了中国创新在大模型层面的强劲突围。这不仅是算法的博弈，更是中国技术长跑的成绩。“韧性”不在于一刻高光，更源于向下扎根。融云从创办起就坚持自主可控，凭借自主知识产权的底层架构与私有化交付能力，从参与信创国产化适配，到首批支持鸿蒙原生开发，筑牢了政务与企业级通信的安全合规底座。2025 年，融云依然持续引领行业。</p><blockquote>即时通讯云市场占有率第一<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521117" alt="图片" title="图片" loading="lazy"/><br/>《北京日报》点赞助力数字丝路新范式<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521118" alt="图片" title="图片" loading="lazy"/><br/>荣登「铸基计划」年度全景图&amp;解决方案集三大核心板块<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521119" alt="图片" title="图片" loading="lazy"/><br/>4 款 SDK 首批通过 GIIC 鸿蒙生态评测<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521120" alt="图片" title="图片" loading="lazy"/></blockquote><p>同时，融云还将这份“中国方案”带向了全球。面对“一带一路”沿线国家对通信自主权的极高要求，融云推出了覆盖政务、企业及消费级全场景的“国家级安全通信平台”，并已在沙特等国家落地验证。这标志着融云的出海已超越了单纯的产品服务，升级为国家级数字基建的能力输出，验证了中国技术出海的长期生命力。</p><h2>05 a16z：玻璃鞋时刻</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521121" alt="图片" title="图片" loading="lazy"/></p><p>原指童话故事中只有灰姑娘合脚的玻璃鞋，a16z 报告中指 AI 应用从追求大而全转向“场景为王”的价值兑现点。当某个特定 AI 能力，刚好以零摩擦、零冗余的方式解决了真实痛点，用户会围绕该能力重构工作流程，最终将带来极高的用户粘性。</p><h4>看似魔法，全是章法</h4><h4>能落地的好 AI</h4><p>“灰姑娘玻璃鞋时刻”看似是瞬间的魔法适配，实则是漫长的工程打磨，是“持续精进”的结果。技术的终极价值永远在于应用，要真正融入业务场景、解决实际痛点。这也正是融云在 AI 浪潮中笃定的航向。泡沫和喧嚣终将退去，价值的沉淀会历久弥新。无论市场热潮如何变化，我们对底层技术的敬畏与对业务深度的钻研始终如一。</p><p>站在 2026 起始，融云将继续深耕不辍，致力于构建下一代智能原生的通信基座，让复杂的 AI 逻辑内化为简单的交互体验， 让每一次对话都触发业务回响。</p><p>毕竟，能落地的 AI，才是好 AI。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047521122" alt="图片" title="图片" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[调用与容错策略——重试、熔断、舱壁、降级的触发条件与副作用 南城 ]]></title>    <link>https://segmentfault.com/a/1190000047521144</link>    <guid>https://segmentfault.com/a/1190000047521144</guid>    <pubDate>2026-01-04 19:02:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><strong>写在前面，本人目前处于求职中，如有合适内推岗位，请加：lpshiyue 感谢。同时还望大家一键三连，赚点奶粉钱。</strong></p><blockquote>在分布式系统中，故障不是偶然事件而是常态，合理的容错策略需要在隔离故障与保障用户体验间找到精细平衡</blockquote><p>在明确了网关作为系统边界守护者的职责后，我们需要深入系统内部，探讨微服务之间的调用容错策略。当服务A调用服务B，而服务B出现故障或延迟时，如何避免这种故障像多米诺骨牌一样在整个系统中引发连锁反应？本文将深入解析重试、熔断、舱壁、降级四大核心容错策略的触发条件、实现机制与潜在副作用。</p><h2>1 重试策略：应对瞬时故障的第一道防线</h2><h3>1.1 重试的触发条件与适用场景</h3><p>重试是处理<strong>瞬时故障</strong>的首选策略，但必须精确识别哪些故障值得重试。有效的重试基于一个关键假设：故障是暂时的且可能自动恢复。</p><p><strong>应当重试的场景</strong>：</p><ul><li><strong>网络抖动</strong>：TCP连接超时、SSL握手失败</li><li><strong>服务短暂过载</strong>：HTTP 503（服务不可用）状态码</li><li><strong>资源临时锁定</strong>：数据库死锁、乐观锁版本冲突</li><li><strong>依赖服务启动中</strong>：服务刚重启尚未完全就绪</li></ul><p><strong>不应重试的场景</strong>：</p><ul><li><strong>业务逻辑错误</strong>：HTTP 400（错误请求）、认证失败（401/403）</li><li><strong>资源不存在</strong>：HTTP 404（未找到）</li><li><strong>非幂等操作</strong>：POST请求（可能产生重复业务数据）</li><li><strong>永久性故障</strong>：HTTP 501（未实现）、无效参数校验失败</li></ul><pre><code class="yaml"># 重试策略配置示例
retry:
  max-attempts: 3
  backoff:
    initial-interval: 1000ms
    multiplier: 2.0
    max-interval: 10000ms
  retryable-status-codes: 
    - 503
    - 504
    - 408</code></pre><h3>1.2 重试算法与参数调优</h3><p>简单的固定间隔重试可能加剧系统负担，智能重试算法能显著提升恢复效率：</p><p><strong>指数退避算法</strong>：重试间隔随尝试次数指数增长，避免对故障服务的集中冲击。</p><pre><code class="java">// 指数退避重试实现
public class ExponentialBackoffRetry {
    private static final long INITIAL_INTERVAL = 1000; // 1秒
    private static final double MULTIPLIER = 2.0;
    private static final long MAX_INTERVAL = 30000; // 30秒
    
    public long calculateDelay(int retryCount) {
        long delay = (long) (INITIAL_INTERVAL * Math.pow(MULTIPLIER, retryCount));
        return Math.min(delay, MAX_INTERVAL);
    }
}</code></pre><p><strong>随机化抖动</strong>：在重试间隔中加入随机因子，避免多个客户端同步重试导致的"惊群效应"。</p><pre><code class="java">// 带抖动的退避算法
public long calculateDelayWithJitter(int retryCount) {
    long delay = calculateDelay(retryCount);
    long jitter = (long) (Math.random() * delay * 0.1); // 10%抖动
    return delay + jitter;
}</code></pre><h3>1.3 重试的副作用与规避措施</h3><p>不当的重试策略会从自救机制变为<strong>自杀武器</strong>，主要副作用包括：</p><p><strong>资源耗尽</strong>：过度重试消耗客户端线程池、连接池资源，可能引发本地资源耗尽。<br/><strong>放大故障</strong>：对已故障的服务持续重试，相当于DDoS攻击，阻碍服务恢复。<br/><strong>请求重复</strong>：非幂等操作的重试导致业务数据重复，产生脏数据。</p><p><strong>规避措施</strong>：</p><ul><li><strong>严格限制重试次数</strong>：通常不超过3次，避免无限重试</li><li><strong>区分幂等性</strong>：仅为GET、PUT、DELETE等幂等操作配置重试</li><li><strong>超时设置</strong>：每次重试应有超时控制，避免长时间阻塞</li><li><strong>断路器集成</strong>：当断路器开启时跳过重试逻辑</li></ul><h2>2 熔断机制：快速失败的智能开关</h2><h3>2.1 熔断器的状态机与触发条件</h3><p>熔断器本质是一个<strong>状态机</strong>，通过监控调用结果动态决定是否允许请求通过。</p><p><strong>三种状态转换</strong>：</p><ul><li><strong>关闭（Closed）</strong>：请求正常通过，持续监控失败率</li><li><strong>开启（Open）</strong>：请求直接失败，不访问后端服务</li><li><strong>半开（Half-Open）</strong>：允许少量试探请求，检测服务是否恢复</li></ul><p><strong>触发条件</strong>：</p><pre><code class="yaml">circuit-breaker:
  failure-rate-threshold: 50    # 失败率阈值50%
  minimum-number-of-calls: 20   # 最小统计样本数
  sliding-window-size: 100      # 统计窗口大小
  wait-duration-in-open-state: 60s  # 开启状态持续时间
  permitted-number-of-calls-in-half-open-state: 10  # 半开状态允许请求数</code></pre><h3>2.2 熔断器的实现模式</h3><p><strong>基于失败率的熔断</strong>：当窗口内请求失败率超过阈值时触发，适合大多数场景。</p><pre><code class="java">// 失败率熔断器实现逻辑
public class FailureRateCircuitBreaker {
    private final double failureThreshold;
    private final int windowSize;
    private final Queue&lt;Boolean&gt; resultWindow = new LinkedList&lt;&gt;();
    
    public boolean allowRequest() {
        if (state == State.OPEN) {
            return false;
        }
        // 统计失败率逻辑
        return calculateFailureRate() &lt; failureThreshold;
    }
}</code></pre><p><strong>基于响应时间的熔断</strong>：当慢请求比例超过阈值时触发，适合对延迟敏感的场景。</p><pre><code class="java">// 响应时间熔断器
public class SlowCallCircuitBreaker {
    private final long slowCallThreshold; // 慢调用阈值(ms)
    private final double slowCallRateThreshold; // 慢调用比例阈值
    
    public boolean isSlowCall(long duration) {
        return duration &gt; slowCallThreshold;
    }
}</code></pre><h3>2.3 熔断器的副作用与应对</h3><p><strong>误熔断问题</strong>：由于统计偏差或网络波动，健康服务被错误熔断。<br/><strong>恢复延迟</strong>：熔断器从开启到半开需要等待固定时间，即使服务已快速恢复。<br/><strong>状态一致性问题</strong>：分布式环境中各客户端熔断状态可能不一致。</p><p><strong>应对策略</strong>：</p><ul><li><strong>动态调整阈值</strong>：根据系统负载动态调整熔断阈值</li><li><strong>分层熔断</strong>：为不同重要性的服务设置不同的熔断策略</li><li><strong>状态同步</strong>：通过广播或配置中心同步熔断状态（需谨慎使用）</li></ul><h2>3 舱壁隔离：故障隔离的艺术</h2><h3>3.1 隔离模式与实现机制</h3><p>舱壁模式将系统资源分隔成独立区间，防止单个服务的故障耗尽所有资源。</p><p><strong>线程池隔离</strong>：为每个依赖服务分配独立的线程池，确保资源互不影响。</p><pre><code class="java">// 线程池隔离实现
public class ThreadPoolBulkhead {
    private final ExecutorService dedicatedExecutor;
    private final int maxConcurrentCalls;
    
    public &lt;T&gt; CompletableFuture&lt;T&gt; execute(Supplier&lt;T&gt; supplier) {
        if (activeCount &gt;= maxConcurrentCalls) {
            throw BulkheadFullException("Thread pool exhausted");
        }
        return CompletableFuture.supplyAsync(supplier, dedicatedExecutor);
    }
}</code></pre><p><strong>信号量隔离</strong>：通过计数器控制并发数，轻量级但隔离性较弱。</p><pre><code class="java">// 信号量隔离
public class SemaphoreBulkhead {
    private final Semaphore semaphore;
    
    public &lt;T&gt; T execute(Supplier&lt;T&gt; supplier) {
        if (!semaphore.tryAcquire()) {
            throw BulkheadFullException("Concurrency limit exceeded");
        }
        try {
            return supplier.get();
        } finally {
            semaphore.release();
        }
    }
}</code></pre><h3>3.2 隔离粒度的选择策略</h3><p><strong>服务级别隔离</strong>：为每个外部服务设置独立的资源池，适合核心依赖服务。<br/><strong>用户级别隔离</strong>：按用户ID或租户隔离，防止恶意用户影响其他用户。<br/><strong>优先级隔离</strong>：区分高低优先级业务，确保关键业务不受非关键业务影响。</p><pre><code class="yaml"># 多级隔离配置示例
bulkhead:
  service-level:
    user-service: 
      max-concurrent-calls: 50
      max-wait-duration: 100ms
    order-service:
      max-concurrent-calls: 30
      max-wait-duration: 50ms
  user-level:
    max-concurrent-calls-per-user: 5
    max-wait-duration: 10ms</code></pre><h3>3.3 隔离的副作用与资源权衡</h3><p><strong>资源碎片化</strong>：过细的隔离导致资源分配零散，整体利用率降低。<br/><strong>管理复杂度</strong>：大量隔离配置增加系统复杂度和调试难度。<br/><strong>性能开销</strong>：线程池隔离涉及上下文切换，增加响应延迟。</p><p><strong>优化方向</strong>：</p><ul><li><strong>适度隔离</strong>：仅对关键路径和已知不稳定服务实施隔离</li><li><strong>动态调整</strong>：根据流量模式动态调整资源分配</li><li><strong>监控告警</strong>：实时监控隔离资源使用率，及时调整配置</li></ul><h2>4 服务降级：保障核心业务的底线思维</h2><h3>4.1 降级策略与触发条件</h3><p>降级是在系统压力或部分故障时，<strong>暂时关闭非核心功能</strong>，保障核心业务可用的策略。</p><p><strong>自动降级触发条件</strong>：</p><ul><li>熔断器开启状态持续超过阈值</li><li>系统资源使用率超过安全水位（CPU&gt;80%，内存&gt;85%）</li><li>依赖服务不可用或响应时间超过阈值</li></ul><p><strong>手动降级触发条件</strong>：</p><ul><li>预期的大流量活动（如双11、秒杀）</li><li>系统维护或紧急故障处理</li><li>业务优先级调整（临时关闭次要功能）</li></ul><h3>4.2 降级策略的实现方式</h3><p><strong>静态降级</strong>：返回预设的默认值或缓存数据。</p><pre><code class="java">// 静态降级示例
@Service
public class ProductService {
    @Fallback(fallbackMethod = "getProductFallback")
    public Product getProduct(Long id) {
        return productClient.getById(id);
    }
    
    public Product getProductFallback(Long id) {
        return Product.DEFAULT_PRODUCT; // 返回默认商品信息
    }
}</code></pre><p><strong>动态降级</strong>：从备用服务或简化流程获取数据。</p><pre><code class="java">// 动态降级：切换到备用服务
public class ProductServiceWithBackup {
    public Product getProduct(Long id) {
        try {
            return primaryProductClient.getById(id);
        } catch (Exception e) {
            // 主服务失败，切换到备用服务
            return backupProductClient.getById(id);
        }
    }
}</code></pre><p><strong>异步化降级</strong>：将同步调用转为异步处理，先返回接受状态。</p><pre><code class="java">// 异步化降级
public class OrderService {
    public OrderResult createOrder(Order order) {
        if (shouldDegrade()) {
            // 降级时异步处理，先返回接受状态
            asyncOrderProcessor.submit(order);
            return OrderResult.accepted("订单已提交，处理中");
        } else {
            // 正常同步处理
            return processOrderSync(order);
        }
    }
}</code></pre><h3>4.3 降级的副作用与用户体验平衡</h3><p><strong>功能损失</strong>：用户无法使用完整功能，可能影响用户体验。<br/><strong>数据不一致</strong>：降级期间数据可能不同步，恢复后需要修复。<br/><strong>恢复复杂性</strong>：降级容易开启但恢复困难，需要谨慎的恢复策略。</p><p><strong>降级治理原则</strong>：</p><ul><li><strong>明确降级层级</strong>：定义清晰的核心、重要、非核心功能边界</li><li><strong>用户透明沟通</strong>：通过UI提示告知用户功能受限状态</li><li><strong>自动化恢复</strong>：设置自动检测机制，条件满足时自动恢复</li><li><strong>降级演练</strong>：定期进行降级演练，确保降级策略有效</li></ul><h2>5 策略组合与协同工作</h2><h3>5.1 容错策略的执行顺序</h3><p>合理的策略组合能够形成<strong>防御纵深</strong>，各策略按特定顺序协同工作：</p><pre><code>请求进入 → 舱壁隔离检查 → 熔断器状态判断 → 执行原始调用 → 
   ↓（失败）        ↓（拒绝）           ↓（开启）
重试策略 → 熔断器状态更新 → 降级策略执行</code></pre><p><strong>组合配置示例</strong>：</p><pre><code class="java">@Bean
public Customizer&lt;Resilience4JCircuitBreakerFactory&gt; circuitBreakerFactoryCustomizer() {
    return factory -&gt; factory.configureDefault(id -&gt; {
        return Resilience4JConfigBuilder.of(id)
            .circuitBreakerConfig(CircuitBreakerConfig.custom()
                .failureRateThreshold(50)
                .waitDurationInOpenState(Duration.ofSeconds(60))
                .build())
            .bulkheadConfig(BulkheadConfig.custom()
                .maxConcurrentCalls(20)
                .build())
            .retryConfig(RetryConfig.custom()
                .maxAttempts(3)
                .waitDuration(Duration.ofMillis(500))
                .build())
            .build();
    });
}</code></pre><h3>5.2 策略参数联动调优</h3><p>各策略参数需要协同调整，避免相互冲突：</p><p><strong>超时时间协调</strong>：</p><pre><code>单次调用超时 &lt; 重试总超时 &lt; 熔断器统计窗口
示例：单次超时2s × 最大重试3次 = 总超时6s &lt; 熔断窗口10s</code></pre><p><strong>资源分配平衡</strong>：</p><pre><code class="yaml"># 资源分配示例
thread-pool:
  size: 100
  allocation:
    service-a: 30     # 核心服务，分配较多资源
    service-b: 20     # 重要服务
    service-c: 10     # 普通服务
    reserve: 40       # 保留资源，防止资源耗尽</code></pre><h3>5.3 分布式环境下的特殊考虑</h3><p>在分布式系统中，容错策略还需要考虑<strong>跨节点一致性</strong>问题：</p><p><strong>熔断状态同步</strong>：各实例的熔断状态可能不一致，需要谨慎处理。</p><pre><code class="java">// 分布式熔断状态同步（简化示例）
public class DistributedCircuitBreaker {
    public void onStateChange(CircuitBreaker.State newState) {
        // 通过消息总线或配置中心广播状态变更
        eventPublisher.publishEvent(new CircuitBreakerStateEvent(this, newState));
    }
}</code></pre><p><strong>全局限流协调</strong>：单机限流需与分布式限流结合，避免单点瓶颈。</p><pre><code class="java">// 分布式限流协调
public class DistributedRateLimiter {
    public boolean allowRequest(String serviceId) {
        // 本地限流检查
        if (!localRateLimiter.allowRequest()) {
            return false;
        }
        // 分布式限流检查（如Redis令牌桶）
        return redisRateLimiter.allowRequest(serviceId);
    }
}</code></pre><h2>6 监控与可观测性</h2><h3>6.1 关键指标收集</h3><p>有效的容错策略依赖完善的监控体系，需要收集以下关键指标：</p><p><strong>重试指标</strong>：</p><ul><li>重试次数分布（按服务、按结果）</li><li>重试成功率与重试贡献的额外延迟</li><li>重试放大系数（重试产生的额外请求比例）</li></ul><p><strong>熔断器指标</strong>：</p><ul><li>各熔断器状态（开启/关闭/半开）时间比例</li><li>请求拒绝数量与失败率趋势</li><li>状态转换频率与触发原因</li></ul><h3>6.2 告警策略设计</h3><p>基于监控指标建立<strong>分层告警</strong>体系：</p><p><strong>紧急告警</strong>（立即处理）：</p><ul><li>核心服务熔断器持续开启超过5分钟</li><li>系统整体资源使用率超过90%</li><li>多个关联服务同时出现异常</li></ul><p><strong>警告告警</strong>（当日处理）：</p><ul><li>单个非核心服务熔断器开启</li><li>重试率显著上升（超过基线50%）</li><li>平均响应时间明显恶化</li></ul><h2>总结</h2><p>重试、熔断、舱壁、降级四大容错策略构成了微服务架构的<strong>韧性基石</strong>。正确的策略应用能够使系统在面临各种故障时保持稳定，但需要深入理解各策略的触发条件、实现机制和潜在副作用。</p><p><strong>核心取舍原则</strong>：</p><ol><li><strong>重试</strong>是乐观策略，相信故障是暂时的，但需严防重试风暴</li><li><strong>熔断</strong>是保护策略，快速失败以避免资源耗尽，但可能误伤健康请求</li><li><strong>舱壁</strong>是隔离策略，防止故障扩散，但带来资源碎片化开销</li><li><strong>降级</strong>是底线策略，保障核心业务，但牺牲功能完整性</li></ol><p>在实际应用中，需要根据业务特点、资源约束和可用性要求，灵活组合和调优这些策略，找到最适合自己系统的容错方案。</p><hr/><p><strong>📚 下篇预告</strong><br/>《分布式事务方法论——2PC/TCC/SAGA与基于消息的最终一致性对照》—— 我们将深入探讨：</p><ul><li>⚖️ <strong>一致性光谱</strong>：从强一致性到最终一致性的业务场景取舍</li><li>🔄 <strong>2PC协议</strong>：两阶段提交的原子性保证与单点瓶颈分析</li><li>🛠️ <strong>TCC模式</strong>：Try-Confirm-Cancel的业务侵入性与补偿机制</li><li>🎻 <strong>SAGA架构</strong>：长事务的拆分策略与逆向补偿的复杂性治理</li><li>✉️ <strong>消息可靠性</strong>：基于消息队列的最终一致性实现与数据一致性保障</li></ul><p><strong>点击关注，掌握分布式事务的核心方法论！</strong></p><blockquote><p><strong>今日行动建议</strong>：</p><ol><li>评估现有系统的重试策略，识别非幂等操作的重试风险</li><li>检查熔断器配置，确保阈值设置符合业务容忍度</li><li>分析系统依赖关系，为关键服务设计合适的舱壁隔离方案</li><li>制定明确的降级预案，确保故障时能快速保障核心业务</li></ol></blockquote>]]></description></item><item>    <title><![CDATA[基于DataWorks Notebook+MaxCompute MaxFrame一站式构建AI数据处]]></title>    <link>https://segmentfault.com/a/1190000047521147</link>    <guid>https://segmentfault.com/a/1190000047521147</guid>    <pubDate>2026-01-04 19:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在大模型与 AI 应用快速落地的今天，企业对“数据准备 → 数据处理 → 模型训练”的端到端效率提出了更高要求。阿里云数据开发治理平台 DataWorks 联合云原生大数据计算服务 MaxCompute，为您提供一套开箱即用、安全合规、弹性可扩展的 AI 数据开发环境，特别适合需要处理 TB/PB 级结构化、半/非结构化数据的 AI 工程师、数据科学家与算法团队。</p><p>本文将带您快速了解如何基于阿里云两大核心产品——DataWorks（大数据开发与治理平台）、MaxCompute（云原生大数据计算服务）以及MaxFrame（分布式Python计算框架）—— 高效搭建一个支持 Notebook 交互式开发、任务调度与大规模并行计算的一体化 AI 数据处理环境。</p><h2>为什么选择这套组合？</h2><p><img width="723" height="241" referrerpolicy="no-referrer" src="/img/bVdnyAa" alt="image.png" title="image.png"/></p><p>优势总结：</p><ul><li>无需自建集群：全托管服务，分钟级开通</li><li>开发体验友好：Jupyter Notebook 风格，支持 Magic Command 快速连接计算资源</li><li>安全合规：天然集成 RAM 权限体系、VPC 网络隔离、敏感信息加密</li><li>成本可控：按量付费 + 包年包月，适合测试与生产混合场景</li></ul><h2>环境搭建四步走（核心流程）</h2><p>虽然底层涉及多个服务联动，但对用户而言，只需完成以下四个关键步骤，即可进入开发状态：</p><h4>第一步：开通 MaxCompute 项目</h4><p>作为计算与存储的核心，MaxCompute 项目是所有数据作业的资源底座。</p><ul><li>选择与业务一致的地域（如华东2-上海）</li><li>推荐使用按量付费模式（新用户可享受免费额度）</li><li>项目名称建议包含业务标识（如 ai_dedup_01），便于后续管理</li></ul><h4>第二步：创建 DataWorks 工作空间</h4><p>DataWorks 提供从开发到运维的完整工具链。</p><ul><li>选择基础版即可满足 Notebook 开发需求（免费）</li><li>创建通用型资源组（按量付费），并绑定VPC网络（若需访问 OSS、PAI 等内网服务）</li><li>指定空间管理员，并添加团队成员（支持 RAM 子账号）<br/>建议开启“新版数据开发（Data Studio）”，获得更流畅的 Notebook 体验。</li></ul><h4>第三步：绑定计算资源</h4><p>将 MaxCompute 项目“绑定”到 DataWorks 工作空间，实现开发与计算的打通。</p><ul><li>在工作空间管理页中，一键绑定已创建的 MaxCompute 项目</li><li>选择合适的资源组（用于任务调度与 Notebook 执行）</li><li>测试连通性，确保权限与网络配置正确<br/>安全提示：建议使用“阿里云主账号”作为默认执行身份，避免权限不足问题。</li></ul><h4>第四步：启动个人开发环境</h4><p>这是您编写代码的“云端工作站”。</p><ul><li>在 Data Studio 中新建一个个人开发环境实例</li><li>选择 CPU 规格（如 4 vCPU / 16 GiB）和预置镜像（如 dataworks-maxcompute:py3.11-ubuntu20.04:py3.11-ubuntu20.04-202504-1）</li><li>实例启动后，即可在 Notebook 中直接连通 MaxFrame 进行分布式计算<br/>注意：实例按CU*时长计费，不使用时请手动停止，避免产生额外费用。</li></ul><h2>开始开发：用 MaxFrame 处理海量数据</h2><p>一切就绪后，您可以在 Notebook 中像写 Pandas 一样处理亿级数据：</p><pre><code>
import maxframe.dataframe as md
import pyarrow as pa
import pandas as pd
from maxframe.lib.dtypes_extension import dict_

# 初始化 MaxFrame 会话（通过 Magic Command 自动连接 MaxCompute）
mf_session = %maxframe

# 构造 DataFrame（实际数据可来自 MaxCompute 表）
col_a = pd.Series(
    data=[[("k1", 1), ("k2", 2)], [("k1", 3)], None],
    index=[1, 2, 3],
    dtype=dict_(pa.string(), pa.int64()),
)
col_b = pd.Series(
    data=["A", "B", "C"],
    index=[1, 2, 3],
)
df = md.DataFrame({"A": col_a, "B": col_b})
df.execute()

# 自定义函数
def custom_set_item(df):
    for name, value in df["A"].items():
        if value is not None:
            df["A"][name]["x"] = 100
    return df

# 调用 apply_chunk 执行分布式计算
result_df = df.mf.apply_chunk(
    custom_set_item,
    output_type="dataframe",
    dtypes=df.dtypes.copy(),
    batch_rows=2,
    skip_infer=True,
    index=df.index,
).execute().fetch()

print(result_df)</code></pre><p><strong>亮点功能：</strong></p><ul><li>使用 %maxframe Magic Command，无需明文 AccessKey，快捷连通目标计算资源</li><li>输出中包含 Logview 链接，一键查看作业 DAG、耗时、失败原因</li><li>支持将结果写回 MaxCompute 表或导出至 OSS，无缝衔接下游模型训练</li></ul><h2>最佳实践建议</h2><p>为了让您的开发更高效、更稳定，推荐关注以下几点：</p><h4>1. 善用 Logview 2.0</h4><p>每次执行都会生成可视化作业追踪链接，帮助快速定位性能瓶颈或错误根源。</p><h4>2. 合理配置资源配额</h4><p>通过设置 options.session.quota_name 指定后付费/预付费 Quota，按业务需求灵活选择。</p><h4>3.敏感信息统一管理</h4><p>在 DataWorks 工作空间参数中配置 AK/SK 或数据库密码，代码中通过 ${workspace.工作空间参数名} 引用，杜绝明文泄露。</p><h4>4. 利用数据地图做元数据治理</h4><p>DataWorks 自动同步 MaxCompute 表结构，支持血缘分析、表预览、生命周期管理，提升团队协作效率。</p><h2>常见问题快速排查</h2><ul><li>Q：Notebook 中查不到 MaxCompute 表？<br/>A：确认 MaxCompute 项目已绑定到当前 DataWorks 工作空间，并检查账号是否有读权限；可在“数据地图”中手动刷新元数据。</li><li>Q：无法读写 OSS 数据？<br/>A：确保 RAM 用户拥有对应 Bucket 的读写权限，且个人开发环境实例（开发环境）和通用型资源组（生产环境）与 OSS 在同一 VPC 内（或已配置公网访问）。</li></ul><h2>下一步行动</h2><p>现在，您已经拥有了一个安全、弹性、高性能的 AI 数据处理平台。无论是进行数据去重、特征打标、日志清洗，还是为大模型准备高质量训练语料，这套组合都能为您提供强大支撑。</p>]]></description></item><item>    <title><![CDATA[Claude Code 最佳实践 东风微鸣云原生 ]]></title>    <link>https://segmentfault.com/a/1190000047520940</link>    <guid>https://segmentfault.com/a/1190000047520940</guid>    <pubDate>2026-01-04 18:08:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>Claude Code 最佳实践</h2><hr/><h3>1. 简介</h3><p>Claude Code 是 Anthropic 推出的命令行工具，旨在为工程师和研究人员提供一种低级别、无偏见的方式，将 Claude AI 无缝集成到编码工作流中。其设计哲学强调灵活性和可定制性，不强制特定工作流程，支持多种语言和环境，适合多样化的开发需求。</p><hr/><h3>2. 环境配置与优化</h3><h4>2.1 创建 CLAUDE.md 文件</h4><ul><li>CLAUDE.md 是 Claude Code 自动纳入上下文的关键文件，用于记录常用 Bash 命令、核心文件、代码风格指南、测试说明及仓库礼仪等。</li><li>文件应保持简洁、易读，推荐放置于仓库根目录并纳入版本控制，方便团队共享和持续更新。</li><li>通过 <code>/init</code> 命令可自动生成初始 CLAUDE.md，工程师可根据项目需求不断迭代优化。</li><li>该文件极大提升 Claude 对项目上下文的理解和指令遵循度。</li></ul><h4>2.2 权限预设</h4><ul><li>避免使用 <code>--dangerously-skip-permissions</code> 以降低风险，推荐通过 <code>/permissions</code> 命令预先允许明确安全的常用命令，减少权限提示干扰。</li><li>权限配置文件 <code>.claude/settings.json</code> 应提交至版本库，确保团队成员环境一致。 (参考文档: Claude Code作者亲授：13个让编程效率翻倍的神操作)</li></ul><hr/><h3>3. 工作流程与交互技巧</h3><h4>3.1 常见工作流程</h4><ul><li><strong>探索 → 规划 → 编码 → 提交</strong>：先让 Claude 阅读相关文件或资源，明确需求后再开始编码，避免盲目写代码。</li><li><strong>测试驱动开发（TDD）</strong>：先让 Claude 编写测试用例，确认测试失败后再实现功能代码，确保代码质量。</li><li><strong>基于视觉目标的迭代</strong>：通过粘贴设计截图或视觉模拟，指导 Claude 实现并反复迭代直至符合预期。</li></ul><h4>3.2 提示词设计</h4><ul><li>指令应具体明确，避免模糊描述，提升 Claude 理解准确率。</li><li>使用触发词如 “think”, “think hard”,  "think harder", “ultrathink” 等激活扩展思考模式。</li><li>利用 <code>/clear</code> 命令定期清理上下文，保持对话聚焦。</li><li>支持双击 Escape 键快速回溯历史提示，便于调整和重试。</li></ul><hr/><h3>4. 权限管理与工具集成</h3><ul><li>Claude Code 默认请求对可能修改系统的操作权限，用户可通过多种方式管理允许的工具列表，包括会话内选择、<code>/allowed-tools</code> 命令、编辑配置文件或 CLI 标志。</li><li>支持与 Bash、MCP、GitHub CLI 等多种工具集成，用户可在 CLAUDE.md 中记录工具用法，提升自动化能力。</li><li>通过自定义斜线命令（slash commands）实现重复工作流自动化，命令存放于 <code>.claude/commands/</code> 目录，支持参数传递。 (参考文档: Claude Code作者亲授：13个让编程效率翻倍的神操作)</li></ul><hr/><h3>5. 自动化与扩展功能</h3><h4>5.1 斜线命令与子代理</h4><ul><li>斜线命令用于封装常用提示模板，减少重复输入，提高效率。</li><li>子代理（Subagents）可拆分复杂任务，自动化处理 PR 常见工作流，如代码简化、端到端测试等。</li><li>结合 Hook 自动格式化代码，保证代码风格一致，避免 CI 失败。  (Claude Code作者亲授：13个让编程效率翻倍的神操作)</li></ul><h4>5.2 长时间任务处理</h4><ul><li>对于耗时任务，采用后台代理验证、Agent Stop hook 及插件辅助，确保任务完成的确定性和稳定性。</li><li>可在<strong>沙箱环境</strong>使用 <code>--permission-mode=dontAsk</code> 或 <code>--dangerously-skip-permissions</code> 以避免权限阻塞。  (参考文档: Claude Code作者亲授：13个让编程效率翻倍的神操作)</li></ul><hr/><h3>6. 多实例与并行工作</h3><ul><li>支持本地与云端多会话并行运行，终端中可同时开启多个 Claude Code 实例，利用系统通知管理输入时机。</li><li>通过 Git worktrees 或无头模式实现多实例并行，分别处理不同项目模块或任务，提升整体开发效率。</li><li>结合 Terminal 的标签页编号和通知机制，方便管理多个工作树和会话。  (参考文档: Claude Code作者亲授：13个让编程效率翻倍的神操作)</li></ul><hr/><h3>7. 验证与质量保障</h3><ul><li>关键实践是为 Claude 提供验证机制，如自动运行测试、构建和 UI 测试，形成闭环反馈，显著提升代码质量。</li><li>使用 Chrome 扩展或其他自动化工具对提交代码进行端到端验证，确保功能正确且体验良好。</li><li>采用“试错-回滚”策略，频繁提交检查点，支持实验性开发且风险可控。  (参考文档: Claude Code作者亲授：13个让编程效率翻倍的神操作)  (参考文档: How Anthropic teams use Claude Code)</li></ul><hr/><h3>8. 团队协作与知识共享</h3><ul><li>团队维护共享的 CLAUDE.md 文件，持续更新错误案例、命令和风格指南，提升团队整体效率和一致性。</li><li>代码评审时可通过 <code>@.claude</code> 自动将反馈内容补充至 CLAUDE.md，形成良性知识积累。</li><li>共享配置和工具集成文件（如 <code>.mcp.json</code>）实现环境统一，促进跨成员协作。  (参考文档: Claude Code作者亲授：13个让编程效率翻倍的神操作)  (参考文档: How Anthropic teams use Claude Code)</li></ul><hr/><h3>9. 典型应用场景</h3><ul><li><strong>代码库理解与导航</strong>：快速定位相关文件和调用关系，节省上下文构建时间。</li><li><strong>单元测试生成</strong>：自动覆盖边界条件，减轻测试设计负担。</li><li><strong>跨语言代码转换</strong>：无需掌握新语言即可实现功能验证。</li><li><strong>自动化重复任务</strong>：如 Slack 消息发送、BigQuery 查询、错误日志抓取等。</li><li><strong>快速原型设计</strong>：通过粘贴设计图生成可交互原型，缩短设计到实现周期。</li><li><strong>安全审查与合规</strong>：辅助法务和安全团队评估集成风险。  (参考文档: How Anthropic teams use Claude Code)</li></ul><hr/><h3>10. 进阶建议与总结</h3><ul><li><strong>保持提示具体且明确</strong>，避免模糊指令导致误解。</li><li><strong>利用多实例并行处理</strong>，实现任务拆分和上下文隔离。</li><li><strong>持续维护 CLAUDE.md</strong>，将经验和错误教训固化为团队资产。</li><li><strong>构建自动验证闭环</strong>，让 Claude 自我检测和修正，提升输出质量。</li><li><strong>勇于分享原型和实验成果</strong>，促进跨部门创新和协作。</li><li><strong>结合视觉输入</strong>，利用截图和设计稿提升交互效果和准确度。</li><li><strong>理解任务性质</strong>，区分异步可自动化任务与需同步监督的核心业务逻辑。  (参考文档: How Anthropic teams use Claude Code)  (参考文档: How Anthropic teams use Claude Code)</li></ul><hr/><h3>致谢</h3><p>本最佳实践总结基于 Anthropic 内部团队及社区用户的丰富经验，特别感谢 Boris Cherny、Daisy Hollman、Ashwin Bhat 等多位工程师的贡献。欢迎广大用户持续分享使用心得，共同推动 Claude Code 生态发展。</p><hr/><blockquote><p><strong>附录</strong></p><ul><li>官方文档地址：claude.ai/code</li><li><a href="https://link.segmentfault.com/?enc=v3uJqGDY6N6aYPPGRJM88w%3D%3D.aHXzb%2BuCs0IwQZ8TOjKcHC1SuvHvYpRzoa0FTBCBps%2FU%2FdaiybkGyEzmTT8%2FbtG%2BOW667SFNjfpjAowU%2FUh%2F8z0j6ZvX%2FWGpejqhFTFoRgn3ebci6%2BK6YAQ9t4pBkW7ptS69nrrB%2F5REyF8iZg8L3w%3D%3D" rel="nofollow" target="_blank">Just Talk To It - the no-bs Way of Agentic Engineering | Peter Steinberger</a></li><li><a href="https://link.segmentfault.com/?enc=DqL16cRCPxOtlgUWukljqw%3D%3D.Zr5PqWvvVnuFUa413m86yRHwppwI%2B8aSAhWSTnkFjaFWw%2B1gGYzybtY2ljhZ2uvzgGlsQj5vpNkZJvrm43e2tTS9jiNHyT8hwcdI0LImx6mWTeudghJcPHEVEaCYAlv5Lv23s34kwzNHDWZpsiWhveKIWGu8I3tcmAvxYQc0b4A%3D" rel="nofollow" target="_blank">How Anthropic teams use Claude Code | Claude</a></li><li><a href="https://link.segmentfault.com/?enc=NwLCK7nOZiQOk8oHq7sDiA%3D%3D.P3%2B2Vy6dNiGOilBxQNaNWP%2Ff%2F%2BHREbtg1mCg9rPqsj8pMj7FGYkdABPJH%2FHL9mgo84KV%2Fum5EyYgmGPMb5HWEg%3D%3D" rel="nofollow" target="_blank">Claude Code作者亲授：13个让编程效率翻倍的神操作</a></li><li><a href="https://link.segmentfault.com/?enc=Q7eR9DGO7PqxGNedefaScQ%3D%3D.JZEmdIJH%2FnIKGreHuv6y%2BeRUFe6NEhjbMkzReOHGnw1ciPZwzB0IyyR0BG48N%2FXJKaCEU5VZ4wW3j5coXGKFm%2FJ8CGlXXV6pnEbeZ1HtubhCgZXt4u%2BdTDFb9gcDe2RO" rel="nofollow" target="_blank">Claude Code Best Practices \ Anthropic</a></li></ul></blockquote>]]></description></item><item>    <title><![CDATA[SCALE | 数据库行业专家们的 AI 洞见 2025 回顾 爱可生开源社区 ]]></title>    <link>https://segmentfault.com/a/1190000047520967</link>    <guid>https://segmentfault.com/a/1190000047520967</guid>    <pubDate>2026-01-04 18:07:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyw1" alt="" title=""/></p><p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyw4" alt="" title="" loading="lazy"/></p><p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyw8" alt="" title="" loading="lazy"/></p><p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyw9" alt="" title="" loading="lazy"/></p><p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyxb" alt="" title="" loading="lazy"/></p><p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyxc" alt="" title="" loading="lazy"/></p><p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyxd" alt="" title="" loading="lazy"/></p><p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyxf" alt="" title="" loading="lazy"/></p><p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyxg" alt="" title="" loading="lazy"/></p><p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyxi" alt="" title="" loading="lazy"/></p><p><img width="723" height="978" referrerpolicy="no-referrer" src="/img/bVdnyxj" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[IvorySQL年度报告｜和开发者一起成长的 2025 IvorySQL ]]></title>    <link>https://segmentfault.com/a/1190000047520977</link>    <guid>https://segmentfault.com/a/1190000047520977</guid>    <pubDate>2026-01-04 18:06:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047520979" alt="1首页.jpg" title="1首页.jpg"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047520980" alt="2重大事件.jpg" title="2重大事件.jpg" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047520981" alt="3产品回顾.jpg" title="3产品回顾.jpg" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047520982" alt="4社区力量.png" title="4社区力量.png" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047520983" alt="5贡献者名单.jpg" title="5贡献者名单.jpg" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047520984" alt="6合作伙伴.jpg" title="6合作伙伴.jpg" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047520985" alt="7尾页.jpg" title="7尾页.jpg" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[构建低利用率云资源面板，观测云助力企业缩减云成本 观测云 ]]></title>    <link>https://segmentfault.com/a/1190000047520995</link>    <guid>https://segmentfault.com/a/1190000047520995</guid>    <pubDate>2026-01-04 18:05:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>背景</h2><p>随着公有云的广泛应用，企业普遍面临云资源利用率不足、资源配置不合理（如高配低用）等挑战，导致云支出持续居高不下。据行业报告显示，超过 90% 的用云企业存在明显的资源浪费现象，云资源投入与业务收益的匹配度不足已成为企业数字化转型中的核心痛点。在此背景下，云资源管理部门亟需对低利用率的云资源进行降配或关停。</p><p>观测云作为一款现代化的监控观测云服务，不仅能满足研发、运维团队的观测需求，也能站在「云中立」的角度帮助客户持续优化云资源成本。本文以 ECS 产品为例，向大家介绍如何在观测云上构建低利用率云资源面板。针对其他云产品，读者亦可参考该模式进行资源优化。</p><h2>构建低利用率云资源面板</h2><p>笔者近期在服务于某客户时了解到，该客户的 ECS 的月消费金额始终位于云消费总金额的首位，比第二名的云数据库（RDS）高出 5 倍还多。因此客户认为从 ECS 入手进行成本优化，其风险小收益大。因此在双方共同努力下，在观测云上构建了「低资源利用率 ECS 面板」，具体效果如下：</p><h3>第一部分：CPU、内存利用率蜂窝图</h3><p>作为仪表板的第一部分，蜂窝图能帮助用户一目了然看到当前有哪些 ECS 的利用率过低。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047520997" alt="图片" title="图片"/></p><p>以阿里云 ECS 为例，图表的 DQL 语句：</p><pre><code>CPU利用率P90

M::aliyun_acs_ecs_dashboard:(percentile(`CPUUtilization_Average`, 90)) BY `cloud_provider`, `cluster_name_k8s`,`instanceId`</code></pre><pre><code>内存利用率P90

M::aliyun_acs_ecs_dashboard:(percentile(`memory_usedutilization_Average`, 90)) BY `cloud_provider`, `cluster_name_k8s`,`instanceId`</code></pre><p>图表特点：</p><ul><li>选择 CPU 利用率和内存利用率 P90 指标，兼顾了高峰期资源利用率升高的场景；</li><li>采用蜂窝图，高密度展示各 ECS 的 CPU 和内存利用率，并按照云厂、k8s 集群、环境等标签进行分组展示；</li><li>将资源利用率分为红、黄、绿三个档次，用红色突出显示资源利用率很低的 ECS；</li><li>鼠标悬浮到单个蜂窝时，浏览器将显示该 ECS 的分组信息，如 instanceId，k8s 集群名称等，支持钻取到单台 ECS 进行下钻。</li></ul><h3>第二部分：CPU、内存利用率趋势图</h3><p>图表显示了 CPU 利用率 P90、CPU 利用率均值、内存利用率 P90、内存利用率均值，每个趋势图展示资源率最低的 Top20 ECS 的利用率曲线。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047520998" alt="图片" title="图片" loading="lazy"/></p><p>在蜂窝图上点击某个 instanceId 的蜂窝进行下钻，图表将过滤显示该 instanceId 的 CPU、内存利用率的 P90 趋势和均值趋势。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047520999" alt="图片" title="图片" loading="lazy"/></p><p>以阿里云 ECS 为例，图表的 DQL 语句：</p><pre><code>CPU利用率P90

M::aliyun_acs_ecs_dashboard:(percentile(`CPUUtilization_Average`, 90)) BY `cloud_provider`, `cluster_name_k8s`,`instanceId`</code></pre><pre><code>CPU利用率均值

M::aliyun_acs_ecs_dashboard:(avg(`CPUUtilization_Average`)) BY `cloud_provider`,`cluster_name_k8s`, `instanceId`</code></pre><pre><code>内存利用率P90

M::aliyun_acs_ecs_dashboard:(percentile(`memory_usedutilization_Average`, 90)) BY `cloud_provider`, `cluster_name_k8s`,`instanceId`</code></pre><pre><code>内存利用率均值

M::aliyun_acs_ecs_dashboard:(avg(`memory_usedutilization_Average`)) BY `cloud_provider`, `cluster_name_k8s`,`instanceId`</code></pre><p>图表特点：</p><ul><li>通过趋势图，反映 ECS 在一个较长周期内的资源利用率变化趋势，例如 30 天、180 天、360 天等；</li><li>同时提供 P90 和均值趋势，以评估 ECS 在日常使用和高峰期的资源使用率</li><li>支持与蜂窝图联动，当用户从蜂窝图上点击单个蜂窝时（例如代表资源利用率很低的红色蜂窝），趋势图将联动该过滤条件，仅显示该 ECS 的趋势图</li><li>在趋势图中，同时还展示了低水位基准线，以便反映 ECS 实际资源率和基准线的差异。</li></ul><h3>第三部分：ECS 资源列表</h3><p>通过前两部分的图表，用户可以明确某台 ECS 的资源利用率是长期处于低位的，而第三部分的 ECS 资源列表则将对应 ECS 的 instanceId、主机名、规格、CPU 和内存配置信息展示出来，用户无需登陆到云平台上进行二次搜索。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521000" alt="图片" title="图片" loading="lazy"/></p><p>以阿里云 ECS 为例，图表 DQL 如下：</p><pre><code>ECS资源列表

CO::aliyun_ecs:(`HostName`, `InstanceName`, `Cpu`, `Memory`, `Status`, `CreationTime`, `InstanceType`, `PublicIpAddress_IpAddress`) [1h] BY `InstanceId`</code></pre><p>图表特点：</p><ul><li>显示规格、CPU、内存等信息</li><li>支持与蜂窝图联动，从蜂窝图下钻到单台 ECS 后，资源列表也将同步过滤显示该 ECS 的规格情况</li></ul><h3>第四部分：汇报部分</h3><p>在开展云资源优化的工作并取得阶段性成果后，用户需要向管理层汇报优化工作的前后对比，例如本月的低资源利用率主机数量相对于上月的数量变化情况，因此需要直观的数据对比，这部分图表内容如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521001" alt="图片" title="图片" loading="lazy"/></p><p>图表 promQL：</p><pre><code>最近30天- CPU资源利用率P90小于20%的主机数

count(quantile_over_time(0.9, aliyun_acs_ecs_dashboard:CPUUtilization_Average[30d:1h])  &lt; 20)</code></pre><pre><code>上一个30天- CPU资源利用率P90小于20%的主机数

count(quantile_over_time(0.9, aliyun_acs_ecs_dashboard:CPUUtilization_Average[30d:1h])  &lt; 20) offset 30d</code></pre><pre><code>最近30天- 内存资源利用率P90小于40%的主机数

count(quantile_over_time(0.9, aliyun_acs_ecs_dashboard:memory_usedutilization_Average[30d:1h])  &lt; 40)</code></pre><pre><code>上一个30天- 内存资源利用率P90小于40%的主机数

count(quantile_over_time(0.9, aliyun_acs_ecs_dashboard:memory_usedutilization_Average[30d:1h])  &lt; 40)   offset 30d</code></pre><pre><code>最近30天- CPU资源利用率P90小于20%的主机明细表

quantile_over_time(0.9, aliyun_acs_ecs_dashboard:CPUUtilization_Average[30d:1h])  &lt; 20</code></pre><pre><code>最近30天- 内存资源利用率P90小于40%的主机明细表

quantile_over_time(0.9, aliyun_acs_ecs_dashboard:memory_usedutilization_Average[30d:1h])  &lt; 40</code></pre><p>图表特点：</p><ul><li>分周期展示低资源利用率的 ECS 数量，清晰且客观，方便汇报优化成果</li><li>支持导出为 CSV 文件，方便核查明细</li></ul><h2>云资源利用率指标采集的步骤</h2><p>在本章中我们将介绍绘制低利用率云资源面板所需要的一些前置条件和步骤，帮助大家轻松完成相关指标接入和指标管理。</p><h3>第一步，开启观测云「云账号管理」功能</h3><p>登陆到观测云工作空间后，进入「集成」-「云账号管理」，添加公有云账号，输入具有 readOnly 权限的 AK/SK。如企业无法提供云平台的 AK/SK 信息，可考虑通过在企业内网自建 Func 的方式，来进行云资源采集。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521002" alt="图片" title="图片" loading="lazy"/></p><h3>第二步，采集指定云产品的指标</h3><p>在配置完云账号之后，接下来是配置具体的云产品指标采集，选择 Region，添加关注的资源利用率指标后保存即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521003" alt="图片" title="图片" loading="lazy"/></p><h3>第三步，对指标集的存储时间配置为较长时间</h3><p>资源利用率相关的指标通常需要进行长期保存，因此用户可以在「指标」-「指标管理」中为相关指标集配置长期存储策略，如下图所示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521004" alt="图片" title="图片" loading="lazy"/></p><h2>总结</h2><p>在完成「低利用率 ECS 面板」的第二天，我们向该客户运维团队进行了演示汇报，对方认为这张仪表板完全满足他们对 ECS 进行成本优化的需求，并计划在下一步开展对 RDS、云硬盘等支出相对较高的云产品进行相同的分析和优化工作。大家还聊到了近期产业链上游硬件涨价的相关新闻。继内存、SSD 涨价引发市场震荡后，CPU 等其他硬件的价格上涨接踵而至，这无疑给明年的公有云价格体系带来了很大不确定性。企业尽早开始掌握分析、优化低利用率的云资源，就越能从容应对每月的云支出账单。</p>]]></description></item><item>    <title><![CDATA[十天取关24万？用数据解构蛋神 “凉了” 的真相 三_清 ]]></title>    <link>https://segmentfault.com/a/1190000047521021</link>    <guid>https://segmentfault.com/a/1190000047521021</guid>    <pubDate>2026-01-04 18:05:02</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>前言</h2><p>前段时间，抖音网红蛋神靠着「精确到秒级的评论」+「一天吃 40 个蛋」的噱头，短短几天涨粉 400 万，成了短视频圈的现象级网红。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521023" alt="蛋神爆火评论" title="蛋神爆火评论"/></p><p>但流量这东西，来得快去得也快。没过多久，「蛋神只火了 8 天」、「彻底凉了」的声音就在 B 站疯传。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521024" alt="B站相关视频的封面" title="B站相关视频的封面" loading="lazy"/></p><p>到底是真的崩盘了？还是蹭流量的恶意解读？我采集了蛋神从爆红初期到最新期视频的真实互动数据。</p><p>跑完数据后我发现：<strong>这或许不是一个人的爆红，而是一场平台对普通人的「造神试验」。</strong></p><h2>首发视频：平台的「造神计划」启动</h2><p>蛋神的第一期爆红视频，舆论环境极其&lt;span style="color: red;font-size: 16px"&gt;「欣欣向荣」&lt;/span&gt;。</p><p>数据显示：<strong>正面占比 46.01%，中立占比 49.79%，负面仅 4.2%。并且负面几乎没有针对蛋神本身的。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521025" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521026" alt="首期视频互动区情感分析结果" title="首期视频互动区情感分析结果" loading="lazy"/></p><p>这也印证了一个事实：<strong>在爆红初期，用户的注意力全被 “精准评论”“疯狂吃蛋” 的猎奇感吸引，没人质疑，只有围观和讨论，舆论环境完全是正面主导。</strong></p><p>但深层逻辑或许是：&lt;span style="color: red;font-size: 16px"&gt;平台需要一个草根样本&lt;/span&gt;。通过故意推流给一个看似「毫无背景」的普通人，营造出「人人都可爆红」的幻觉，以此激励更多普通人投入内容创作的中。</p><h2>8 天后的转折：当激励样本「过期」</h2><p>网传「蛋神只火了 8 天」，于是我提取了 8 天后一期视频的数据：<strong>正面下降至 37.14%，负面略升至 6.24%。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521027" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521028" alt="与第一期视频的对比" title="与第一期视频的对比" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521029" alt="8天后的视频互动区情感分析结果" title="8天后的视频互动区情感分析结果" loading="lazy"/></p><p>虽然负面有所上升，但并未“塌房”。此时，平台的「造神激励」任务已基本完成，流量开始向下一波「潜力草根」倾斜。</p><p>所谓&lt;span style="color: red;font-size: 16px"&gt;「8 天凉透，显然有待纠正」&lt;/span&gt;，更像是平台完成了对普通人的招安后，开始回收超额推流的自然现象。</p><h2>澄清视频：数据下的「集体观望」</h2><p>距离首发 14 天的澄清视频中，数据出现了剧变：<strong>中立情绪飙升至 71.03%，正面跌至 23.36%。</strong></p><p>当用户意识到爆红背后可能有「流量操控」时，逆反心理会催生负面评价。高达 71% 的中立说明大众不再盲从，开始理性审视这段被平台强推的「流水线人设」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521030" alt="12月18日的澄清视频" title="12月18日的澄清视频" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521031" alt="三者情感分析对比结果" title="三者情感分析对比结果" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521032" alt="情感分析结论" title="情感分析结论" loading="lazy"/></p><h2>一个月数据复盘：全面转向「高级黑」</h2><p>采集完最新一期视频的互动数据，我发现了一个更有趣的现象：<strong>负面评论占比虽然锁死在 5.60%，但评论区的「含金量」变了。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521033" alt="最新一期视频的舆论情感分布" title="最新一期视频的舆论情感分布" loading="lazy"/></p><p>如果说前三期是「严肃对线」，那这一期就是<strong>「全民找茬」</strong>：</p><ul><li><strong>讽刺艺术取代谩骂：</strong>评论区充斥著「我每天吃 500 个蛋、跑 1000 公里」这种高级反串。这些语义在数据上被识别为「中立」，但杀伤力极强，直接消解了博主的专业性。</li><li><strong>从「崇拜」到「解构」：</strong>观众开始拿放大镜看鸡蛋数量，吐槽煎蛋手艺，甚至封他为「水神」。</li><li><strong>人设符号化：</strong>网友已不再关心他到底吃不吃蛋，而是享受这种「参与毁神」的快感。</li></ul><p>&lt;span style="color: red;font-size: 16px"&gt;博主已从一个「生活博主」，转变成了一个「被网友围观的抽象符号」。&lt;/span&gt;</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047521034" alt="最新一期视频的舆论总结" title="最新一期视频的舆论总结" loading="lazy"/></p><h2>总结</h2><p>每隔一段时间，互联网这个巨大的&lt;span style="color: red;font-size: 16px"&gt;「盲盒机」&lt;/span&gt;都会选出一个幸运观众推上神坛。</p><p>爆红的原因向来百花齐放，但底层逻辑从未改变：&lt;span style="color: red;font-size: 16px"&gt;平台需要一个草根样本来维持「人人皆可成名」的幻觉。&lt;/span&gt;</p><p>蛋神只是这场造神运动中，刚好被算法选中的那个「样板间」。</p><ul><li><strong>对于平台：</strong>成功激励了无数普通人继续投入精力发视频，其战略目的早已达成。</li><li><strong>对于大众：</strong>经历了从猎奇崇拜到参与「毁神」解构的快感，情绪价值已消费完毕。</li><li><strong>对于博主：</strong>数据显示他没凉，但他已经从「神坛」跌落到了网友的「玩具盒」里，成为了一个被标签化的抽象符号。</li></ul><p>所谓的「凉了」，不过是这份过载的流量终于回到了它应有的水位。</p><blockquote>谁在负责造神？谁又能保持清醒？而我们，在流量实验里又是什么角色呢？</blockquote><p>本文由<a href="https://link.segmentfault.com/?enc=flvlhohEiFTYoylBUk69vA%3D%3D.SuX3A%2BmIdIwjF2mjsAHrKQ8yBEv8ydpWg%2BFB7lI6rus%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[从“可视”到“可智”——《“人工智能+”行动》下，数字孪生与 AI 的战略交汇机遇 数字冰雹 ]]></title>    <link>https://segmentfault.com/a/1190000047521049</link>    <guid>https://segmentfault.com/a/1190000047521049</guid>    <pubDate>2026-01-04 18:04:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在数字化转型的深水区，国家《“人工智能+”行动》的号角已然吹响。这不仅是技术路线的升级，更是产业智能化范式的根本性变革。从“互联网+”的连接万物，到“人工智能+”的赋能万物，其目标不再是简单的流程线上化，而是将人工智能作为通用目的技术，像水电一样融入各行各业的生产、决策、创新核心环节。</p><p>而数字孪生正从一项前沿技术，演进为承载“人工智能+”落地、实现价值闭环的关键载体。</p><p>数字孪生，通过构建物理实体的高保真、可交互、全生命周期的数字镜像，恰好为 AI 提供了这一理想的“操作台”。它不仅是物理世界的可视化“镜像”，更是 AI 模型所需的高质量数据池、决策逻辑的仿真验证环境、以及智能体与物理世界交互的统一接口。数字孪生将抽象的 AI 算法，锚定在具体的时空场景与业务对象上，使其决策变得“可观察、可解释、可干预”，从而打通 AI 赋能实体的“最后一公里”。</p><p>今天我们来解读这一战略交汇点，与您探讨 AI 与数字孪生融合如何重塑产业数字化转型路径。</p><h2>01.“人工智能+”如何重塑关键领域数字化转型</h2><p>“人工智能+”与数字孪生的融合，正在深刻重构工业制造、智慧城市、能源基建等关键领域的数字化转型内涵与路径。</p><h3>工业制造：从“智能制造”到“智能体协同制造”</h3><p>智能制造聚焦于自动化与信息化，数字孪生构建了从产线到整厂的虚拟映射，“人工智能+”的注入，驱动其向“智能体协同制造”演进。AI 算法能基于实时生产数据，进行工艺参数优化、设备预测性维护、柔性排产，实现全流程的可视化、可仿真、可调控。</p><p>例如，AI 可以模拟数以万计的生产参数组合，在数字孪生体中快速验证，找到最优解后，一键下发至物理生产线执行。这实现了从“经验驱动”到“数据+仿真驱动”的决策飞跃。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdnwZf" alt="" title=""/></p><h3>智慧城市：从“城市大脑”到“城市智能体”</h3><p>“城市大脑”实现了数据的汇聚与初步分析，数字孪生城市提供了“一屏统览、一网统管”的运营底座，而“人工智能+”下的“城市智能体”，则要求系统能自主感知、分析、决策甚至执行。</p><p>如 AI 赋能于交通信号实时优化、突发事件智能调度、公共资源动态配置。当AI识别到某路段拥堵趋势时，它可以在数字孪生城市中进行多套疏解方案的仿真推演，智能分析每套方案对全局路网的影响，并协同交通、警务等多个“部门智能体”执行最优方案，实现从“看见”到“预见”再到“高效处置”的闭环。<br/><img width="640" height="180" referrerpolicy="no-referrer" src="/img/bVdnoKN" alt="" title="" loading="lazy"/></p><h3>能源与基础设施：从“监控运维”到“智慧运营”</h3><p>在能源电网、水利管网等领域，数字孪生支撑起设备资产的全生命周期管理，将气象、地质、运行负荷等多源数据融合，“人工智能+”推动其走向“智能运营”，通过在虚拟空间中对设备健康度进行监测分析，对极端天气下的风险进行监测预警，AI 可实现电网潮流的动态优化调度、管网泄漏的早期识别与定位、建筑能耗的实时优化，实现从“被动响应”到“主动干预”的运营模式变革。<br/><img width="640" height="180" referrerpolicy="no-referrer" src="/img/bVdnyxO" alt="" title="" loading="lazy"/></p><h2>02.“数字孪生”成为 AI 价值闭环的关键环节</h2><p>纵观以上领域，一个共性需求凸显：AI 的决策必须在一个可信任、可回溯的环境中生成与验证。数字孪生提供的“仿真”能力，是AI模型训练、决策沙盘推演、避免“试错成本”高昂的物理实验的关键。通过数字孪生的“可视化”能力，将 AI 复杂的“黑箱”决策过程，以人类可直观理解的方式呈现，建立人机信任，实现人机协同。</p><p>数字孪生与AI的融合，远不止于表面结合，而是在数据、交互、决策等多个层面发生深刻的化学反应。</p><h3>数字孪生：为 AI 提供“可交互、可调试、可理解”的智能界面</h3><p>三维可视化是基础，但更重要的是其交互属性，数字孪生体成为 AI 模型输入（实时状态数据、空间关系）与输出（控制指令、预测结果）的自然载体，可以直观地调试AI 模型的决策逻辑，观察其在不同场景下的“思考”过程，实现 AI 模型的“可解释性”和“可调试性”。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdnyx7" alt="" title="" loading="lazy"/></p><h3>多源数据融合：构建AI训练的“高质量数据池”</h3><p>AI 的性能高度依赖于数据质量。数字孪生平台的核心能力之一，正是多源异构数据融合。它能将物联网传感器数据、业务系统台账、视频流、GIS 地理信息等多模态数据，进行标准化、时空对齐与语义关联，为 AI 训练提供标注清晰、上下文丰富的“高质量数据池”。</p><h3>低代码/零代码开发：降低“AI+数字孪生”应用门槛</h3><p>融合应用的开发不应是少数专家的专利，通过可视化编排工具，业务人员可以像搭积木一样，将 AI 分析模块（如预测模型、识别算法）与数字孪生场景中的对象、数据图层进行关联，快速构建智能应用。</p><p>数字冰雹 图观引擎 和孪易 IOC 的功能，均提供零代码/低代码开发模式。让用户低代码甚至无需编码，即可在孪易后台配置一个“基于 AI 视频识别的周界入侵告警”场景，当 AI 识别到异常，自动在三维场景中定位、高亮并触发处置流程。</p><h3>智能体与数字孪生的深度融合：从“感知”到“决策”再到“执行”</h3><p>这是融合的终极形态。AI 智能体作为数字孪生系统中的“智慧大脑”，其感知基于孪生体的实时数据，其决策在孪生体中进行仿真验证，其执行指令通过孪生体下发至物理对象。更进一步，多智能体协同可以在数字孪生中实现复杂场景的自主优化。例如，在一个智慧园区孪生体中，能源管理智能体、安防巡逻智能体、服务调度智能体可以相互通信、协商，共同完成“节能模式下保障重点区域安全”的复合目标。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdmRb7" alt="" title="" loading="lazy"/><br/>这背后，正是我司睿司智能体平台所赋能的场景：它为企业提供智能体集群的协同底座与可视化开发工具，让多智能体在数字孪生世界中有序协作。</p><h3>开放平台生态：构建“AI+数字孪生”应用的创新土壤</h3><p>真正的产业化需要生态。一个开放的数字孪生平台，通过提供丰富的 API、SDK和行业插件机制，能够吸引算法厂商、行业 ISV、开发者共同创新。开发者可以专注于开发垂直行业的 AI 算法，并像安装“APP”一样，将其便捷地集成到数字孪生平台中，快速形成场景化解决方案。数字冰雹的产品体系中，从图观的开发套件到孪易的行业插件库，均秉承开放生态理念，旨在共建繁荣的应用创新土壤。</p><h2>03.“AI+数字孪生”一体化平台成为新型基础设施</h2><p>技术融合正驱动平台形态发生根本性演变，一体化平台将成为企业数字化转型的“操作系统”。</p><p><strong><em>技术融合趋势</em></strong>：从“单点智能”到“系统智能”，从“静态孪生”到“动态智能体”未来，孤立的 AI 模型和静态的数字模型将逐渐转变为 “AI+仿真+数字孪生” 三位一体的平台，实现从对单一设备的预测性维护（单点智能），到对整个生产系统或城市运行进行持续优化（系统智能）的跨越。数字孪生也将从静态的历史镜像，演进为嵌入 AI 智能体、能够自主演化、主动服务的“动态智能体”。</p><p><strong><em>平台化趋势</em></strong>：一体化平台成为企业数字化转型的“操作系统”。企业需要一个统一的智能数字基座，而非一堆散落的工具。这个基座能够管理所有的数字孪生体、调度各类AI 能力、运行业务仿真，并向上支撑千行百业的智能应用。它如同智能时代的“操作系统”，向下封装了复杂的“AI+仿真+渲染”技术，向上提供标准、易用的开发接口。一个拥有大量开发者、丰富行业组件、持续迭代算法的开放生态，将显著降低智能应用的开发成本与周期，加速“人工智能+”在各行业的渗透。</p><p>面对上述趋势，<strong>数字冰雹已构建了 孪易 IOC、睿司智能体平台、图观开发套件 等产品的协同演进矩阵，致力于成为企业“人工智能+”转型的核心伙伴：</strong></p><ul><li>孪易 IOC：是面向运营层的“数字孪生+AI”智能中枢。无论是智慧城市、园区还是机房，孪易 IOC 都能快速集成业务数据与 AI 能力，构建起可视、可管、可控、可智的运营指挥平台。ProMAX 版更深度集成了智能助理、应急处突等高级功能，体现了数字孪生与 AI 的深度融合。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdnyyb" alt="" title="" loading="lazy"/></li><li>睿司智能体平台：是驱动孪生体的“智慧之心”。它为企业提供构建、管理和协同 AI智 能体的核心能力，通过低门槛的可视化编辑、多模型调度与企业知识库集成，让智能体技术真正为业务所用，并注入到数字孪生场景中。<br/><img width="723" height="347" referrerpolicy="no-referrer" src="/img/bVdnoKJ" alt="" title="" loading="lazy"/></li><li>图观数字孪生应用开发套件：是构建这一切的数字基座。其“端+流”双模渲染引擎、强大的场景编辑与零/低代码开发能力，以极高的性价比和灵活性，为孪易 IOC 和各类智能应用提高效支撑，大幅降低了构建“AI-Ready”数字孪生世界的技术门槛与成本。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdnyyF" alt="" title="" loading="lazy"/><br/>这三者协同，形成了从数字基座构建（图观）+ 智能体赋能（睿司）+ 运营指挥中枢（孪易 IOC） 的完整价值闭环，助力客户一站式拥抱“人工智能+”时代。</li></ul><h2>拥抱“人工智能+”时代</h2><h2>共筑数字孪生智能体新生态</h2><p>数字孪生与 AI 的融合不仅是技术趋势，更是产业升级的必然路径，是将宏观战略微观化、将技术潜能价值化的关键路径。它让AI有了“用武之地”，让数字孪生有了“智慧之心”，共同推动产业从数字化走向智能化。</p><p>我们愿以孪易 IOC、睿司智能体平台、图观开发套件为依托，与广大合作伙伴、客户及学界同仁一道，深入千行百业，破解融合应用中的挑战，共同探索与实践，携手构建一个更加可视、可管、可控、可智的数字孪生新世 界，让“人工智能+”的行动，结出惠及社会经济发展的丰硕果实。</p>]]></description></item><item>    <title><![CDATA[代理IP适合哪些场景或行业？ IPDEEP ]]></title>    <link>https://segmentfault.com/a/1190000047521053</link>    <guid>https://segmentfault.com/a/1190000047521053</guid>    <pubDate>2026-01-04 18:03:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在数字化时代，营销是所有企业都会做的事情，而在营销策略中，账号体系是最直接且最常用的一种营销模式，多账号营销推广已经是企业之间默认的一种有效推广模式。</p><p>随着账号体系审核的不断严格，代理IP已经不再是技术人员的“专属工具”，而是被广泛应用于营销、运营、数据采集等多个行业。</p><p>那么，代理 IP 到底适合哪些场景？不同行业又该如何选择和使用呢？下面就跟着小编一起来看看吧！</p><p><img width="723" height="366" referrerpolicy="no-referrer" src="/img/bVdnyyK" alt="代理IP时候哪些场景或行业" title="代理IP时候哪些场景或行业"/></p><p>一、跨境电商与多账号运营</p><p>适用程度：★★★★★</p><p>跨境电商是我们熟知的行业，也是代理 IP 使用最成熟、需求最稳定的行业之一。常见的平台有 Amazon、eBay、Shopee、Lazada、TikTok等。</p><p>主要用途：</p><p>多账号登录与管理</p><p>防止账号因 IP 重复导致关联封禁</p><p>配合指纹浏览器实现多账号安全隔离</p><p>推荐代理类型：</p><p>住宅代理 IP</p><p>移动代理 IP</p><p>提醒：跨境平台对账号环境风控比较严格，数据中心 IP 风险较高，更适合辅助性操作。</p><p>二、社交媒体营销与账号矩阵</p><p>适用程度：★★★★★</p><p>社交平台（比如 Facebook、Instagram、YouTube、WhatsApp、X）对账号异常行为极其敏感，IP 是核心识别因素之一。</p><p>主要用途：</p><p>多账号养号与日常登录</p><p>广告账户管理</p><p>社媒矩阵营销</p><p>推荐代理类型：</p><p>移动代理 IP（稳定性高）</p><p>高质量住宅 IP</p><p>提醒：代理 IP 必须 与账号注册地区、使用习惯保持一致，这样账号不易被风控。</p><p>三、数据采集与爬虫</p><p>适用程度：★★★★★</p><p>这是代理 IP 的强项，尤其是在信息聚合、价格监控、舆情分析等场景中尤为常见。</p><p>主要用途：</p><p>突破访问频率限制</p><p>分布式数据采集</p><p>访问地域限制内容</p><p>推荐代理类型：</p><p>数据中心 IP（高并发）</p><p>动态住宅 IP（反封能力强）</p><p>建议：高频采集 + 大规模并发时，代理池质量比数量更重要。</p><p>四、SEO 与搜索引擎优化</p><p>适用程度：★★★★☆</p><p>在SEO领域，代理 IP 更多的是用于数据分析和模拟搜索行为，而不是“刷排名”。</p><p>主要用途：</p><p>排名监控（Google / Bing / 百度）</p><p>竞争对手分析</p><p>模拟不同地区搜索结果</p><p>推荐代理类型：</p><p>数据中心 IP （性价比高）</p><p>定向国家 IP</p><p>注意：SEO 场景对匿名性要求不如账号场景高，但 IP 稳定性和速度更重要。</p><p>五、广告投放与测试</p><p>适用程度：★★★★☆</p><p>在广告投放前，很多团队会使用代理 IP 来测试素材和落地页在不同地区的真实展示情况。</p><p>主要用途：</p><p>反作弊检测验证</p><p>落地页加载测试</p><p>多地区广告效果对比</p><p>推荐代理类型：</p><p>住宅 IP</p><p>定向国家 / 城市 IP</p><p>注意：无需实际身处当地，也能获得接近真实用户的访问体验。</p><p>六、账号安全与风控测试</p><p>适用程度：★★★☆☆</p><p>部分安全团队或技术人员会通过代理 IP 来模拟异常登录行为，用于测试系统风控能力。</p><p>主要用途：</p><p>登录安全测试</p><p>异地登录模拟</p><p>风控策略验证</p><p>推荐代理类型：</p><p>数据中心 IP</p><p>测试环境专用代理</p><p>七、内容访问受限或地区限制的场景</p><p>适用程度：★★★☆☆</p><p>在某些地区或国家，部分网站或服务存在访问受限。</p><p>主要用途：</p><p>区域内容合规检查</p><p>访问海外网站或服务</p><p>测试多语言 / 多地区内容</p><p>提示：该场景应该遵守当地法律法规，合理合规使用代理 IP。</p><p>八、总结</p><p>代理 IP 本身并不是“万能工具”，关键在于是否用在合适的场景、选对了类型。对于账号类、风控敏感型业务，真实性和稳定性优先；对于数据和分析类业务，效率和成本更重要。</p>]]></description></item><item>    <title><![CDATA[什么是访答手机智能助理？ 火爆的伤痕_Ya4Gw ]]></title>    <link>https://segmentfault.com/a/1190000047521059</link>    <guid>https://segmentfault.com/a/1190000047521059</guid>    <pubDate>2026-01-04 18:02:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>什么是访答手机智能助理？</h2><p><strong>访答</strong>手机智能助理是一款专为移动端设计的轻量化多模态Agent工具。它通过视觉-语言大模型和ADB技术，实现“看懂屏幕→规划步骤→模拟操作”的自动化流程，帮助用户高效完成复杂任务。</p><h3>核心能力</h3><p><strong>访答</strong>具备多模态屏幕理解、智能任务规划和高精度动作执行能力。它能自动处理社交运营、电商比价、办公自动化等场景，支持50多款主流应用，如微信、淘宝、抖音等。</p><h3>使用指南</h3><p>用户可通过安卓模拟器或Android 7.0+设备启用<strong>访答</strong>。安装ADB Keyboard并配置输入法后，即可通过自然语言指令操控手机，大幅提升效率。</p><p><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdnyyQ" alt="" title=""/></p>]]></description></item><item>    <title><![CDATA[产品需求管理怎么做？从需求收集到优先级排序的管理实践指南 PM老周 ]]></title>    <link>https://segmentfault.com/a/1190000047521062</link>    <guid>https://segmentfault.com/a/1190000047521062</guid>    <pubDate>2026-01-04 18:01:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>需求永远比资源多，真正拉开差距的不是“谁更会写 PRD”，而是组织有没有一套能落地的产品需求管理机制：统一入口让需求可见，澄清流程让需求可比，分层决策让优先级可解释，承诺池与节奏管理让计划可兑现。本文用一套“需求漏斗 + 模型工具 + 治理底座”的方法，帮助中高层与 PMO 把争论变成决策，把排序变成交付。</p><blockquote>本文关键词：产品需求管理、需求收集、需求评审、需求池、需求优先级、需求优先级排序方法、产品路线图、版本规划、迭代计划、插单管理、承诺管理、WIP 限制、RICE 模型、WSJF、MoSCoW、Kano、Cost of Delay（延迟成本）</blockquote><p>从治理角度看，需求多并不可怕。可怕的是三件事不清楚：谁说了算、按什么算、算完怎么落地。所以，产品需求管理的核心不是“把需求排个序”，而是建立一套可解释、可承诺、可复盘的决策系统：让需求从“声音”变成“投资项目”，从“争抢”变成“组合管理”。</p><h2>把需求当作“投资项目”：产品需求管理的三步漏斗</h2><p>结论先说：先让需求“可见、可比”，再谈“可算、可做”。</p><p>我更愿意把需求管理称为“需求治理”。它关心的不只是做什么功能，而是如何在有限资源下持续把价值做出来。落地上，用“三步漏斗”把需求先处理成可管理对象。</p><h4>1）统一入口：先解决需求收集的可见性</h4><p>一句话定义：统一入口 = 任何需求都能提，但必须进入同一个需求池，并补齐最小信息集。</p><p>最怕的不是需求多，而是需求“散”。散意味着：口头承诺多、信息不完整多、隐性插队多，最后组织只能靠“拍板”维持运转。</p><p>最小信息集（建议强制）</p><ul><li>业务问题/机会：我们到底在解决什么？</li><li>用户与场景：谁在什么场景下遇到问题？</li><li>期望结果与衡量指标：上线后用什么证明“值”？</li><li>约束与依赖：合规/合同/窗口期/外部系统依赖</li><li>粗粒度投入：人周或相对点数即可</li></ul><p>再加一个“顾问式硬规则”：证据等级（让组织从“嗓门”走向“证据”）。</p><ul><li>A 级：有数据或实验（漏斗、转化、工单、A/B）</li><li>B 级：有系统化访谈/调研与一致性结论</li><li>C 级：有典型案例但样本较少</li><li>D 级：只有观点或转述</li></ul><p>工具实践：很多团队之所以“入口统一不了”，并不是流程写得不够，而是缺少一个能承载需求池、字段模板与状态流转的载体。以 <a href="https://link.segmentfault.com/?enc=zVtUhI%2BV8EMqYW9Ct5CCYQ%3D%3D.g0wNpB%2FjhN8xUbojRlMx%2F%2F7iTjkeVTR%2Fs9OWNaXGs8KBsaX344tCOUasm5CbeaGG" rel="nofollow" target="_blank">ONES Project</a> 为例，可以直接建立需求池，按团队习惯自定义需求状态与多种属性，并把需求及关联任务规划进迭代，做到“入口统一、信息可见”。</p><p><img width="723" height="446" referrerpolicy="no-referrer" src="/img/bVdnwjo" alt="" title=""/></p><h4>2）需求澄清：从“我要功能”到“我要结果”，再到“可验证假设”</h4><p>一句话定义：需求澄清 = 把功能语言翻译成结果语言，把结果语言翻译成可验证的假设。</p><p>很多企业在优先级排序阶段吵翻天，根因不是模型选错，而是需求没澄清：大家在比较“不同维度的东西”。一个是“要一个按钮”，一个是“要提升复购”，本来就没法放在同一条尺子上。</p><p>建议用 30~60 分钟做“轻量澄清”，重点问四个问题：</p><ul><li>问题是否真实存在：有没有数据、工单、访谈证据？</li><li>目标是否可衡量：上线后如何验证，否则就是“信仰型需求”。</li><li>是否有更便宜的解法：流程/配置/运营/培训，往往比开发快。</li><li>是否可拆分里程碑：把“大而全”拆成可交付的小批量，降低一次性失败风险。</li></ul><p><strong>可复用的假设模板（建议写进需求卡）</strong></p><blockquote>为了【目标人群】在【场景】达成【业务结果】，我们计划做【方案】；若成功，指标【X】在【周期】提升【Y】。</blockquote><p>当需求能用这句话讲清楚，优先级讨论就会从“立场对抗”转向“假设与证据对齐”。<br/>工具实践：澄清阶段常见的“信息散落”问题，是访谈纪要在文档里、决策记录在群里、需求卡在表格里。更稳的做法是把“证据与决策”沉淀到可关联的知识载体里——例如 <a href="https://link.segmentfault.com/?enc=SRRzowHYMnwdNCn6AMkrwA%3D%3D.D4GqfpVaiBWeRRQiUAztDyIwCcQJs9C9T%2FKWne77D1I%3D" rel="nofollow" target="_blank">ONES Wiki</a> 支持文档关联任务，并可在文档中插入 Project 的工作项列表，便于把证据、讨论、交付挂到同一条链路上。</p><p><img width="723" height="436" referrerpolicy="no-referrer" src="/img/bVdnurO" alt="" title="" loading="lazy"/></p><h4>3）需求定级：先同类化再排序，让优先级“可解释、可复盘”</h4><p>一句话定义：需求定级 = 先把需求放进同一类价值逻辑里，再比较先后。</p><p>优先级最怕“跨物种比较”。合规需求与增长需求放在一张表里算分，结论要么失真，要么引发不信任。</p><p><strong>建议先定级（治理层），再排序（方法层）：</strong></p><ul><li>合同/客户承诺类（有明确交付责任与窗口期）</li><li>合规/风险类（不做会出事）</li><li>增长/收入类（直接拉动业务指标）</li><li>体验/满意度类（影响留存与口碑）</li><li>效率/技术债类（影响交付能力与稳定性）</li></ul><p>同类排序才有意义；跨类用资源分桶解决（比如交付承诺/增长迭代/平台与技术债分别占一定容量），不要硬塞进同一套分数里。</p><h2>三、需求优先级排序的四类模型</h2><p>先说结论：模型解决“可比性”，机制解决“可执行性”。模型是算术，治理是制度。<br/>下面四类模型是企业最常用、也最容易落地的组合。</p><p>先给你一张对比表（更容易选型）</p><p><img width="723" height="156" referrerpolicy="no-referrer" src="/img/bVdnyyO" alt="" title="" loading="lazy"/></p><h4>1）RICE：适合增长与体验迭代的“可量化排序”</h4><p>定义句：RICE 用 Reach、Impact、Confidence、Effort 四个维度帮助比较难以直接对比的想法。 </p><p>适用场景：增长、体验优化、运营驱动迭代。</p><p>落地要点：</p><ul><li>Reach 用周期口径（如季度受影响用户数），避免口径漂移。</li><li>Confidence 绑定证据等级，否则就是“分数游戏”。</li><li>Effort 用相对估算即可（人周/点数），统一尺度比“精确”更重要。</li><li>结果要能复盘：分数不是裁判，而是讨论的起点（Intercom 也强调不要把分数当硬规则）。</li></ul><p>常见坑：把 RICE 当作“自动生成优先级”的裁判。</p><p>纠偏：RICE 负责“同类可比”，最终仍要回到战略窗口与承诺边界。</p><h4>2）WSJF：适合平台化与跨团队的“经济紧迫性排序”</h4><p>定义句：WSJF（Weighted Shortest Job First）在 SAFe 中常用“相对延迟成本 / 相对工作时长”来排序，以获得最大经济收益。 </p><p>它背后有个非常管理者视角的提醒：“如果只能量化一件事，就量化 Cost of Delay（延迟成本）。” </p><p>适用场景：平台能力、架构演进、研发效能、跨团队依赖多的需求。</p><p>落地要点：</p><ul><li>Cost of Delay 可拆成业务价值、时间紧迫性、风险降低等维度做相对打分。</li><li>WSJF 的一个重要优点是它“自动忽略沉没成本”，这对企业止损非常关键。</li></ul><p>常见坑：把 WSJF 变成“财务模型秀”，算得很精但没人信。</p><p>纠偏：WSJF 追求相对排序，用统一刻度即可，不必追求绝对准确。</p><h4>3）MoSCoW：适合版本范围控制与共识管理</h4><p>定义句：MoSCoW 把需求分为 Must/Should/Could/Won’t this time，用分类帮助管理优先级与交付预期。</p><p>适用场景：版本发布、MVP 定义、合同交付。</p><p>落地要点：</p><ul><li>Must 必须“数量受控”，否则等于没有优先级。</li><li>Won’t 不是拒绝，而是“这次不做”，要写清原因与复审时间点。</li><li>DSDM/Agile Business 强调：这种分类比简单 1、2、3 排序更能减少无谓争论。</li></ul><p>常见坑：Must 膨胀。</p><p>纠偏：给 Must 加一句判定标准——“缺了它版本是否失败/是否违法/是否违约”。不满足就不要叫 Must。</p><h4>4）Kano：适合体验与差异化的“满意度分层”</h4><p>定义句：Kano 将需求理解为不同层次的顾客期望（例如 expected/normal/exciting），强调特性对满意度的影响并非线性。</p><p>适用场景：体验升级、差异化创新、满意度提升。</p><p>落地要点：</p><ul><li>Kano 适合先做“结构判断”（基础/期望/魅力），避免把资源花在“做了也没人感谢”的地方。</li><li>再用 RICE 或 WSJF 在同类里排序，既有方向感又有可执行性。</li></ul><h2>四、从模型到落地</h2><p>结论先说：没有治理底座，任何优先级排序都会被插单击穿。</p><h4>1）明确决策权与节奏：把需求评审嵌入组织节拍</h4><p>建议建立固定节奏，而不是“有事再开会”：</p><ul><li>双周/每月需求评审会：决定承诺池（未来 1~2 个迭代/一个版本确定做什么）。</li><li>季度路线图校准：对齐战略与资源，调整资源分桶比例（交付承诺、增长迭代、平台与技术债各占多少容量）。</li></ul><p>评审会上只做两类决策：</p><ul><li>信息是否充分（不足则退回澄清）；</li><li>同类需求如何排序（按统一模型给出可解释结论）。</li></ul><p>这会把“临时拍板”变成“制度化决策”，减少个人意志对系统的破坏。</p><h4>2）三张清单：让“想做、承诺、在做”清清楚楚</h4><ol><li>需求池（Options）：任何人都能提，但不代表会做。</li><li>承诺池（Committed）：已评审、已排期、资源已锁定。</li><li>在建池（In Progress）：正在做的必须受 WIP 限制，避免多线程导致整体变慢。</li></ol><p>WIP 限制（Work In Progress Limits）是 Kanban 中常见的做法，它通过限制同时在做的工作数量，迫使团队更聚焦于“完成”而不是“开工”，从而改善流动与交付可预测性。对中高层而言，它还有更现实的价值：你可以用它解释“为什么不能同时满足所有人”——因为系统吞吐有限，增加并行只会让交付更慢。</p><p>工具实践：三张清单最怕变成“写在 PPT 上的概念”。如果工具层面能把需求—迭代—任务的关系可视化，执行会顺很多。比如 ONES Project 支持把需求与相关任务规划至迭代，并提供看板、燃尽图等视图来跟踪进度，更利于把“承诺池”落到可追踪的工作流上。</p><h4>3）插单治理三问：把“临时需求”变成“可承担的代价”</h4><p>插单无法彻底消灭，但可以治理。建议固化三问（并要求可追溯）：</p><ul><li>插单要挤掉承诺池里的哪一项？</li><li>被挤掉的业务代价是什么（收入/客户/风险/口碑）？</li><li>谁来签字承担这个代价（业务负责人/产品负责人/项目治理角色）？</li></ul><p>当插单需要显性代价，组织就会自然减少随意插单。</p><h4>4）指标闭环：用“结果”反向校准需求质量</h4><p>产品需求管理成熟与否，不看流程有多复杂，而看复盘是否持续回答三个问题：</p><ol><li>做完后，指标是否变好？</li><li>若没变好，是假设错了、执行不到位，还是指标选错？</li><li>这些结论如何进入下一轮排序（提升/降低 Confidence，修正 Impact，调整策略）？</li></ol><p>工具实践：闭环的关键是“用同一套口径持续看”。如果平台能提供可配置的度量视图（按项目/迭代/类型/负责人等维度），复盘会更像“经营”，而不是“讲故事”。以 <a href="https://link.segmentfault.com/?enc=DVHGroWs7UiLDh%2BMKvZkPw%3D%3D.0iHsDBLFxHJsETXH6tHOCbXq0%2FwhV%2B3CsTihysgAT41ow0LRHlrWe4NHNn5lCWcF" rel="nofollow" target="_blank">ONES Performance</a> 为例，其提供多种报表形态并支持自定义数据范围与维度，便于做持续度量。</p><p><img width="723" height="443" referrerpolicy="no-referrer" src="/img/bVdnyyT" alt="" title="" loading="lazy"/></p><h2>常见问题 FAQ：</h2><p>Q1：产品需求管理流程是什么？<br/>一个可落地的产品需求管理流程通常包括：需求收集（统一入口）→ 需求澄清（结果与假设）→ 需求定级（同类化）→ 优先级排序（模型辅助）→ 承诺管理（承诺池/WIP）→ 复盘闭环（指标校准）。</p><p>Q2：需求优先级怎么排才不会“吵架”？<br/>先把需求变得可比：统一口径、补齐信息、明确证据；再用模型做同类排序；最后把排序结果放进承诺池，并绑定插单治理规则。换句话说：先治理，再计算。</p><p>Q3：RICE 和 WSJF 我应该选哪个？<br/>RICE更适合增长与体验迭代，把“影响与投入”讲清楚（来自 Intercom 的实践总结）；WSJF更适合平台化与跨团队资源稀缺场景，强调“延迟的代价”。</p><p>Q4：领导/大客户插单怎么办？<br/>不建议靠“拒绝技巧”，而是靠机制：插单必须回答“挤掉谁、代价多少、谁签字承担”。把冲突从情绪层拉回到代价层，组织会更理性。</p><p>Q5：Must 太多怎么办？<br/>给 Must 一个可判定标准：缺了它版本是否失败/是否违法/是否违约。并且为 Must 设上限（例如一个版本 Must 不超过 30% 容量），否则 MoSCoW 会失效。</p><p>Q6：PMO 在需求优先级里到底做什么？<br/>PMO 的价值不在“帮产品排优先级”，而在搭治理底座：评审节奏、口径标准、承诺池机制、插单流程、复盘与指标口径，确保组织能持续兑现承诺。</p>]]></description></item><item>    <title><![CDATA[StarRocks + Paimon： 构建 Lakehouse Native 数据引擎 阿里云大数]]></title>    <link>https://segmentfault.com/a/1190000047521078</link>    <guid>https://segmentfault.com/a/1190000047521078</guid>    <pubDate>2026-01-04 18:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>继去年 Streaming Lakehouse Meetup 顺利举办后，<strong>Streaming Lakehouse Meetup · Online EP.2｜Paimon × StarRocks 共话实时湖仓</strong> 于12月10日重磅回归。在这场直播中，阿里云计算平台事业部开发工程师张庆玉聚焦 StarRocks 与 Apache Paimon 的深度集成实践，探讨如何构建真正意义上的 Lakehouse Native 数据引擎。</p><p>在数据湖已成为企业数字化转型重要基础设施的当下，如何在一个统一的计算引擎中高效处理多种数据源，成为业界关注的焦点。StarRocks 通过与 Paimon 的深度融合，正逐步构建一套完整的 Lakehouse Native 解决方案——不仅支持多源联邦分析，更在性能、功能与可观测性上实现系统性突破。</p><h2>StarRocks 数据湖总体架构：单一引擎，多源联邦分析</h2><p>StarRocks 与 Paimon 的结合，首先体现在统一的架构设计理念上。借助统一的 Catalog 机制，StarRocks 能够在一个引擎内同时管理内部表和外部数据湖（如 Paimon 表），并支持跨 Catalog 的联邦查询。</p><p>这种设计延续了 StarRocks 存算分离的核心思想。虽然数据存储在远端的数据湖中，但查询执行仍能充分利用 StarRocks 在 OLAP 场景下的全部优化能力——从底层的 CPU 指令集加速、向量化执行引擎，到 IO 层面的缓存策略与合并读取，都可无缝应用于 Paimon 表的查询过程。这使得数据湖不再只是“冷存储”，而真正成为高性能分析的一部分。<br/><img width="723" height="342" referrerpolicy="no-referrer" src="/img/bVdnyyX" alt="image.png" title="image.png"/></p><h2>StarRocks+Paimon 发展历程</h2><p>StarRocks 对 Paimon 的支持并非一蹴而就，而是经历了多个版本的持续打磨。</p><ul><li><strong>StarRocks 3.1</strong>: 首次引入 Paimon 外表，通过 JNI （Java Native Interface）实现基本读取能力，并支持 Paimon 物化视图加速查询和谓词下推。这一阶段主要解决“能不能用”的问题。</li><li><strong>StarRocks 3.2</strong>: 性能迎来显著提升—— FE 计划阶段引入 Metadata cache，缓存表分区和 manifests 等元数据，大幅加快计划生成；同时支持表级与列级统计信息采集，提升执行计划质量。3.2 版本还实现了物化视图的分区级别刷新功能，避免了全量刷新带来的资源浪费。此外，该版本进一步增强了对 Paimon DV 表的支持——StarRocks 查询引擎现在可以通过 Native Reader 直接读取 DV 表，相比之前基于 MOR（Merge-On-Read）表结构的 JNI 读取实现，读取性能获得大幅提升，尤其适用于高吞吐、低延迟的实时分析场景。</li><li><strong>StarRocks 3.3</strong>: 标志着 StarRocks 向 Lakehouse Native 迈出关键一步，多项核心特性相继落地——相关细节将在下文逐一展开。</li></ul><h2>StarRocks+Paimon 最新进展</h2><h3>功能增强</h3><ul><li><strong>Time Travel</strong>：StarRocks 现已支持通过 <code>VERSION AS OF</code> 或 <code>TIMESTAMP AS OF</code> 查询历史快照或指定时刻的数据。这一能力在数据审计、故障回滚、AB Test 等场景中具有重要价值，让数据湖具备了更强的时间维度管理能力。<br/><img width="723" height="169" referrerpolicy="no-referrer" src="/img/bVdnyyZ" alt="image.png" title="image.png" loading="lazy"/></li><li><strong>Paimon Format Table</strong>：作为 Paimon 的一种兼容 Hive 格式的表类型，它允许用户将现有 Hive 表直接迁移到 Paimon，而 StarRocks 能无缝识别并高效查询，极大降低了迁移成本。<br/><img width="723" height="391" referrerpolicy="no-referrer" src="/img/bVdnyy1" alt="image.png" title="image.png" loading="lazy"/></li></ul><h3>性能优化</h3><ul><li><strong>Native Reader/Writer</strong>: 在未开启 DV 的情况下，MOR 表需要在查询时实时合并多个版本的增量数据，只能通过 JNI 调用 Java 层处理，存在类型转换、行列格式转换、JVM GC 等开销，效率低下且易引发 OOM。如今，StarRocks 基于 Paimon CPP SDK，在 BE 的 C++ 代码中直接实现 Paimon Native Scanner，实测显示 MOR 表读取性能提升超过 5 倍。写入侧同样受益，Native Writer 显著提升了写入吞吐。<br/><img width="723" height="580" referrerpolicy="no-referrer" src="/img/bVdnyy2" alt="image.png" title="image.png" loading="lazy"/><br/>Paimon Native Reader</li></ul><p><img width="589" height="663" referrerpolicy="no-referrer" src="/img/bVdnyy3" alt="image.png" title="image.png" loading="lazy"/><br/>Paimon Native Writer</p><ul><li><strong>Distributed Plan</strong>: 面对超大规模表（数十万文件），manifest 解析曾是 FE 的性能瓶颈。为此，StarRocks 引入 <strong>Distributed Plan</strong> 机制，当 manifest 数量过多时，FE 将解析任务分发至多个 CN 节点并行执行，各节点完成本地谓词下推后返回所需文件列表。这一设计使 plan 阶段的解析能力随 BE 资源线性扩展，有效缓解单点压力。<br/><img width="723" height="479" referrerpolicy="no-referrer" src="/img/bVdnyy4" alt="image.png" title="image.png" loading="lazy"/></li><li><strong>DV Index Cache</strong>: 在高并发查询 Paimon 主键表时，index manifest 的全局反序列化会造成严重读放大——即使只查一个分桶，也要加载全量索引。于是，<strong>DV Index Cache</strong> 应运而生：按桶级别缓存 DV index 对象，避免重复解析。由于缓存的是 Java 对象而非序列化字节，还省去了反序列化开销。实测表明，该优化在高并发场景下 QPS 提升超 80%。<br/><img width="723" height="273" referrerpolicy="no-referrer" src="/img/bVdnyy5" alt="5278e573770b45a9bdccb093105fa438.png" title="5278e573770b45a9bdccb093105fa438.png" loading="lazy"/><br/>主键表点查在高并发下导致 FE CPU 和内存负载过高，主要因 Plan 阶段频繁从缓存读取 index manifest</li></ul><h3>可观测性：完善profile指标</h3><p>StarRocks 完善了 Profile 指标体系，覆盖 plan 与执行两个阶段。在 plan 阶段，用户可查看 manifest 缓存命中率、远程读次数、谓词下推效果及最终扫描文件数，用于判断是否需调大缓存或优化查询条件。在 BE 执行阶段，则能清晰区分 JNI 与 native 读取的比例——若 JNI 占比较高，可能提示需要对表进行 full compaction，或考虑切换至 DV 表模式。<br/><img width="723" height="625" referrerpolicy="no-referrer" src="/img/bVdnyy6" alt="image.png" title="image.png" loading="lazy"/></p><h2>未来规划：性能对齐内表</h2><p>StarRocks 团队的长期目标很明确：<strong>让查询 Paimon 的性能与体验对齐查询 StarRocks 本地表</strong>。</p><p>目前，BE 执行层的差距已不大——两者均基于列存格式（如 Parquet/ORC），具备类似索引结构，IO 优化策略也高度通用。真正的挑战在于 FE 的 plan 阶段：Paimon 的 manifest 解析可能因 cache miss 触发高延迟的远程读，导致 plan 耗时波动，影响整体查询稳定性。</p><p>未来工作将聚焦于消除 plan 阶段的 latency-sensitive IO，通过更智能的缓存预热、异步解析、元数据压缩等手段，使 Paimon 查询的延迟变得稳定、可预测，彻底告别“毛刺”。</p><h2>结语</h2><p>StarRocks 与 Paimon 的深度融合，代表了现代湖仓架构的重要演进方向。它不只是“能查数据湖”，而是真正“懂数据湖”——从架构统一、功能完善到性能极致优化，每一步都围绕真实业务场景展开。</p><p>这套 Lakehouse Native 方案已在阿里集团内部多个高并发、低延迟场景中落地验证，为电商、物流、金融等业务提供坚实支撑。随着社区生态的持续壮大，我们有理由相信，StarRocks + Paimon 将成为企业构建下一代实时数据平台的核心引擎。</p>]]></description></item>  </channel></rss>