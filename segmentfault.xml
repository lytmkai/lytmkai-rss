<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[浅谈计算机如何识别和存储图像 李子轩xu]]></title>    <link>https://segmentfault.com/a/1190000047432165</link>    <guid>https://segmentfault.com/a/1190000047432165</guid>    <pubDate>2025-11-27 15:12:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>前言</h2><p>在了解图像识别手写数字0-9之前，我觉得首先需要懂得计算机如何读取，表示和存储图片的。<br/>我们每天使用的图片（PNG、JPG、BMP、GIF 等）看上去是“图像”，<br/>但在计算机内部，它们本质上都只是：</p><blockquote>由 0 和 1 组成的二进制数据流。</blockquote><h2>为什么计算机能显示图片？</h2><p>计算机本质上只能处理0和1，但是屏幕上看起来有颜色，形状和边缘等，这是因为：</p><blockquote>图片是由像素矩阵组成，而像素矩阵最终是以二进制数据存储的。</blockquote><p>计算机处理步骤是：</p><ol><li>从硬盘读取二进制（01011001...）</li><li>按图像格式解码（PNG、JPG）</li><li>还原为像素矩阵</li><li>显卡将像素矩阵的 RGB 值发送给显示器</li><li>显示器点亮每个像素，人眼看到图像</li></ol><p>所以最终:</p><blockquote>图片 = 像素矩阵 = 二进制数据 + 解码规则</blockquote><h2>像素是什么？</h2><p>一个像素（Pixel）是屏幕上的最小显示单元，计算机眼里，一个像素不是“颜色”，不是“点”。</p><h3>1. 对于灰度图：</h3><p>一个像素是一个数字，即0～255（最大为255的原因：因为灰度图像通常用 8 bit（1 字节）来表示一个像素，而 8 bit 能表示的最大值就是 255。）</p><blockquote>表示亮度：<br/> 0 = 黑色<br/> 255 = 白色<br/> 中间 = 灰色</blockquote><h3>2. 对于RGB 彩色图：</h3><p>一个像素是一个三元组，即(R, G, B)每个分量 0~255</p><blockquote>(255, 0, 0) = 纯红色  <br/>(0, 255, 0) = 纯绿色  <br/>(0, 0, 0) = 黑色  <br/>(255, 255, 255) = 白色</blockquote><p>灰度图和RGB 彩色图的存储方式：<br/>灰度图：28×28 灰度图 → 总共 784 个像素 → 每个像素 1 字节 → 784 字节数据<br/>RGB 彩色图：28×28 彩色图 → 28×28×3 = 2352 字节（每个像素由 3 字节组成）</p><h2>计算机如何“看”图片？</h2><p>以识别一张手写数字为例子，介绍计算机如何"看"。<br/>总结一句话：计算机“看”数字，就像人眼看数字一样，但它用的是像素和数学模型，而不是眼睛和大脑。</p><ol><li>像素化：一张手写数字的图片首先会被分割成一个由微小方块组成的网格，每个小方块称为一个像素。</li><li>灰度化：对于识别任务，颜色信息通常不重要，所以图片会被转换成灰度图。每个像素不再由RGB三种颜色值表示，而是用一个数值来表示它的灰度强度。通常，0代表纯黑色，255代表纯白色，中间的值是不同程度的灰色。</li><li>形成矩阵：现在，这张图片对计算机来说，就是一个巨大的数字矩阵（或二维数组）。比如，一个28x28像素的图片，就是一个由784个数字组成的矩阵。</li></ol><p>以MNIST数据集的第13张图片为例，打印其28x28像素的原始值：</p><pre><code>sample_idx = 12
target_image = x_train[sample_idx]  # 保存原始数据

print("\n🔢 28x28像素的原始值 (0-255范围):")
for i in range(28):
    row = []
    for j in range(28):
        pixel_value = target_image[i, j]  # 原始值 0-255
        row.append(f"{pixel_value:3d}")
    print(" ".join(row))
</code></pre><p>打印结果：</p><p><img width="723" height="505" referrerpolicy="no-referrer" src="/img/bVdnbtc" alt="image.png" title="image.png"/></p><h2>图像文件是如何保存在磁盘上的？</h2><p>任何文件在磁盘上都以二进制形式保存。<br/>不同格式的图像存储像素的方法：</p><blockquote>“格式 = 文件头 + 元数据 + 像素数据的编码方式”。<br/>像素最终要么以原始字节序列保存（无压缩或带调色板），要么先经过变换/压缩（无损或有损）再写入文件。读取时反向操作即可还原像素矩阵。</blockquote><p>在这里为了方便查看文件的字节形式，我们可以在pyChram上下载Hex Editor:<br/><img width="723" height="433" referrerpolicy="no-referrer" src="/img/bVdnbgH" alt="image.png" title="image.png" loading="lazy"/></p><p>以常见的PNG和JPG为例子：</p><h3>1.PNG（可移植网络图形，无损压缩）</h3><p>文件头：8 字节：89 50 4E 47 0D 0A 1A 0A。<br/>以两张图片为例子：<img width="417" height="182" referrerpolicy="no-referrer" src="/img/bVdnbgw" alt="image.png" title="image.png" loading="lazy"/></p><p>我们可以通过以下方式打开查看<strong>存储在磁盘上的、该文件最原始、最本质的二进制数据，只不过用十六进制和ASCII两种形式“翻译”出来的。</strong></p><p><img width="723" height="541" referrerpolicy="no-referrer" src="/img/bVdnbh8" alt="image.png" title="image.png" loading="lazy"/></p><p>0.png：<br/><img width="723" height="459" referrerpolicy="no-referrer" src="/img/bVdnbqc" alt="image.png" title="image.png" loading="lazy"/></p><p>1.png:<br/><img width="723" height="452" referrerpolicy="no-referrer" src="/img/bVdnbqe" alt="image.png" title="image.png" loading="lazy"/></p><blockquote><p>89：非 ASCII，避免被误认为文本<br/> 50 4E 47：对应 ASCII 的 “PNG”<br/> 0D 0A 1A 0A 是格式控制符</p><p>所以，PNG 文件的开头 永远固定为这 8 个字节：89 50 4E 47 0D 0A 1A 0A</p></blockquote><h3>2. JPG(有损压缩，适合照片)</h3><p>这边以jpg文件进行测试：<img width="356" height="211" referrerpolicy="no-referrer" src="/img/bVdnbqr" alt="image.png" title="image.png" loading="lazy"/></p><p>test.jpg:<br/><img width="723" height="447" referrerpolicy="no-referrer" src="/img/bVdnbqE" alt="image.png" title="image.png" loading="lazy"/></p><p>test2.jpg:<br/><img width="723" height="437" referrerpolicy="no-referrer" src="/img/bVdnbqB" alt="image.png" title="image.png" loading="lazy"/></p><blockquote>以 FF D8 开始。通常在头附近看到 ASCII JFIF 或 Exif 标记。</blockquote><h2>结语</h2><p>通过该文章，可以初步了解到计算机眼中的图片是什么样子以及计算机如何存储图片的，为后续计算机识别手写数字奠定了基础。但这只是了解了图像识别的冰山一角，如果有更好的方向和意见，欢迎指出！</p>]]></description></item><item>    <title><![CDATA[关于vue3的watch绑定解析 健儿 ]]></title>    <link>https://segmentfault.com/a/1190000047432185</link>    <guid>https://segmentfault.com/a/1190000047432185</guid>    <pubDate>2025-11-27 15:12:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>什么时候写deep这个问题 困扰了我很久。这次深度解析下：</p><p>需要 deep: true 的情况<br/>// 情况1：直接监听一个 ref/reactive 对象，且可能只修改内部属性</p><pre><code>const obj = ref({ a: { b: 1 } })
watch(obj, callback)  // 不会触发
obj.value.a.b = 2     // 修改内部属性
watch(obj, callback, { deep: true }) // 会触发
obj.value.a.b = 2    // 修改内部属性</code></pre><p>// 情况2：监听一个可能被复用的对象引用</p><pre><code>const config = ref({ formItems: [...] })
watch(config, callback)  // 不会触发
config.value.formItems[0].options.items = [...]  // 只修改内部属性
watch(config, callback, { deep: true })  // 会触发config.value.formItems[0].options.items = [...]</code></pre><p>不需要 deep: true 的情况<br/>// 情况1：监听 computed（总是返回新对象）</p><pre><code>const computedValue = computed(() =&gt; ({ ...someValue }))
watch(computedValue, callback)  // 不需要 deep，因为总是新对象</code></pre><p>// 情况2：监听 ref，但总是整体替换</p><pre><code>const obj = ref({ a: 1 })watch(obj, callback)  // 不需要 
deepobj.value = { a: 2 }  // 整体替换，引用变化</code></pre>]]></description></item><item>    <title><![CDATA[华为云 DeepSeek Tokens ]]></title>    <link>https://segmentfault.com/a/1190000047432187</link>    <guid>https://segmentfault.com/a/1190000047432187</guid>    <pubDate>2025-11-27 15:11:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化智能加速演进的当下，各行业对大模型能力的需求持续攀升。为助力企业与开发者以更低门槛拥抱 AI 生产力，华为云在双十一期间正式推出 <strong>DeepSeek Tokens 套餐包限时购活动</strong>，以极具竞争力的价格与灵活购买方式，为 AI 应用创新提供强劲动力。</p><p>此次优惠覆盖 <strong>DeepSeek 系列模型</strong>，包括 <strong>DeepSeek-R1、DeepSeek-V3</strong> 等，充分满足企业在自然语言处理、长文本理解、推理分析、代码生成等多场景下的算力需求。<br/><img width="723" height="619" referrerpolicy="no-referrer" src="/img/bVdnbjf" alt="" title=""/></p><p>本次活动面向 <strong>企业开发团队、AI 创业者、内容创作者</strong> 等广泛群体，为 DeepSeek 模型的实际落地提供极具性价比的算力资源。</p><hr/><h2>一、DeepSeek：高性能大模型，助力应用全面升级</h2><p>华为云 DeepSeek 系列模型以卓越的推理能力、长文本理解能力与稳定表现，成为众多智能业务的首选基础模型。其主要优势包括：</p><h3>1. 强劲的推理与生成能力</h3><p>DeepSeek 模型具备优异的逻辑推演、结构化内容生成、代码生成与知识问答能力，可广泛适配：</p><ul><li>技术文档分析</li><li>业务流程问答</li><li>营销文案生成</li><li>等多种智能场景</li></ul><h3>2. 最高 32K 上下文，支持长文档处理</h3><p>支持一次性处理：</p><ul><li>长篇报告</li><li>合同</li><li>会议纪要</li><li>行业研究等内容</li></ul><p>让企业信息处理更智能、更高效。</p><h3>3. 企业级稳定性，开发与集成更易用</h3><p>结合华为云基础底座，DeepSeek 具备：</p><ul><li>更高吞吐</li><li>更低延迟</li></ul><p>既适合快速开发原型，也支持业务级平稳扩展。</p><hr/><h2>二、双十一限时特惠：DeepSeek Tokens 套餐包更划算</h2><p>本次双十一活动，华为云推出专属 <strong>DeepSeek Tokens 套餐包限时优惠</strong>，帮助企业提前储备大模型调用资源，价格远优于日常购入。</p><p><strong>活动亮点包括：</strong></p><ul><li>多档 Token 规格可选，适配不同业务阶段</li><li>限时折扣力度大，成本更可控</li><li>购买即生效，可即时调用 DeepSeek 相关模型</li><li>有效期充足，可按业务节奏灵活使用</li></ul><p>适用于 AI 应用高频调用场景，例如：</p><ul><li>智能客服</li><li>内容生成平台</li><li>大模型研发团队<br/>等。</li></ul><hr/><h2>三、购买后即可使用：上手简单、部署无门槛</h2><p>无论是企业开发团队还是个人开发者，均可通过 <strong>「三步完成接入」</strong>：</p><ol><li>登录华为云</li><li>进入活动页购买 Tokens 套餐包</li><li>获取 Key 调用 DeepSeek 模型</li></ol><p>API / SDK 均已提供完善文档，即买即用、即接即跑，大幅提升开发效率。</p><hr/><h2>四、广泛适配的核心场景，帮助企业快速见效</h2><p>华为云 DeepSeek Tokens 套餐包适用于多行业、多业务场景，包括但不限于：</p><h3>1. 智能客服与业务助手</h3><ul><li>自动回答高频问题</li><li>知识库检索</li><li>业务流程指引</li></ul><p>显著提升客户体验与服务效率。</p><h3>2. 内容生成与营销创意</h3><ul><li>撰写文章</li><li>活动文案</li><li>海报标题</li><li>短视频脚本</li></ul><p>帮助内容团队降低创作成本、提升产出效率与质量。</p><h3>3. 企业文档处理与知识问答</h3><ul><li>对流程文档、历史记录、技术手册进行摘要</li><li>支持文档级问答</li><li>进行结构化信息处理</li></ul><p>提升企业知识沉淀与复用能力。</p><h3>4. 研发与工程智能化</h3><ul><li>自动生成代码</li><li>生成单元测试</li><li>技术方案辅助说明等</li></ul><p>为研发团队提供“智能助手”，加速开发交付。</p><h3>5. 行业定制 AI 应用</h3><p>可按不同行业需求进行定制，例如：</p><ul><li>政务智能咨询</li><li>金融合规分析</li><li>制造巡检记录总结</li><li>教育内容辅助生成</li></ul><p>帮助各行业探索更具创新性的 AI 业务形态。</p><hr/><h2>五、AI 普惠加速落地，华为云持续助力行业升级</h2><p>华为云持续推进 AI 技术的可用性和普惠性，本次双十一推出的 <strong>DeepSeek Tokens 套餐包优惠</strong>，将进一步降低企业使用大模型的门槛，加速智能应用在各行业的落地，为创新业务注入新的增长动力。</p><p><strong>活动页面（DeepSeek Tokens 限时购）：</strong><br/><a href="https://link.segmentfault.com/?enc=2ikLMnzt0M%2FHTel%2Fid%2BCDA%3D%3D.Fsum4sTIty4XbI9My0ZMTcq30IRG0UNdUSBUQCcl3DFLJZbbDE5FyX2XuxPWdx7pVZB2i7vv%2BoJ%2FayBW7uh5oMRG9fse%2B%2Bq%2Fa0kr69NsEIniKET%2BuqVqcejbKXeHrwS0ZDrs1HeupU2YOBZdxLp733BHHyJWMQMcyPKkjLnDvIFjkeCL6kZOe7DVLimRODn%2B" rel="nofollow" target="_blank">https://activity.huaweicloud.com/1111_promotion/index.html?utm_source=oschina&amp;utm_medium=pr-cn&amp;utm_campaign=1111&amp;utm_content=maas</a></p>]]></description></item><item>    <title><![CDATA[如何使用 C# 将 RTF 转换为 PD]]></title>    <link>https://segmentfault.com/a/1190000047432205</link>    <guid>https://segmentfault.com/a/1190000047432205</guid>    <pubDate>2025-11-27 15:10:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>RTF（Rich Text Format）是一种通用的文档格式，允许用户在不同的文字处理软件中保存和交换格式化文本。PDF（Portable Document Format）则是一种广泛使用的文档格式，它能够保留文档的原始布局，无论在哪种设备上查看都能保持一致。因此，将 RTF 文件转换为 PDF 文件在许多应用场景中都十分重要。本文将介绍如何使用 Spire.Doc for .NET 来实现这一功能。</p><h2>Spire.Doc for .NET 简介</h2><p>Spire.Doc 是一款 .NET 平台的组件，可以轻松地处理 Word 文档，包括创建、编辑、转换和打印文档。该组件支持多种文档格式，诸如 DOC, DOCX, RTF, HTML, TXT, PDF 等。使用 Spire.Doc，开发者可以快速实现复杂的文档操作，而无需深入了解底层文档格式。</p><h2>安装 Spire.Doc</h2><p>要使用 Spire.Doc 进行 RTF 到 PDF 的转换，可以通过 NuGet 包管理器进行安装。以下是安装的步骤：</p><ol><li>打开 Visual Studio 并创建一个新项目（例如，控制台应用程序）。</li><li>右键单击项目，选择“管理 NuGet 包”。</li><li>在浏览选项卡中，搜索“Spire.Doc”，并点击“安装”以添加该库。</li></ol><h2>代码示例</h2><p>以下是一个简单的代码示例，演示如何使用 Spire.Doc 将 RTF 文件转换为 PDF 文件：</p><pre><code class="csharp">using Spire.Doc;
using Spire.Doc.Documents;

classProgram
{
staticvoidMain(string[] args)
    {
        // 创建一个 Document 对象
        Document document = new Document();

        // 加载 RTF 文件
        document.LoadFromFile("input.rtf");

        // 保存为 PDF 文件
        document.SaveToFile("output.pdf", FileFormat.PDF);

        // 输出成功信息
        Console.WriteLine("RTF 文件成功转换为 PDF 文件！");
    }
}</code></pre><h3>代码详解</h3><ol><li><strong>加载 RTF 文件</strong> ：使用 <code>document.LoadFromFile()</code> 方法加载指定路径的 RTF 文件。</li><li><strong>保存为 PDF 文件</strong> ：通过 <code>document.SaveToFile()</code> 方法，将加载的文档保存为 PDF 格式。此方法的第一个参数是输出文件的路径，第二个参数则是文件格式。</li><li><strong>输出成功信息</strong> ：控制台输出信息提示用户转换成功。</li></ol><h2>处理异常</h2><p>在实际开发中，处理异常是非常重要的。下面的示例展示了如何添加异常处理：</p><p>csharp</p><pre><code class="csharp">using System;
using Spire.Doc;

classProgram
{
staticvoidMain(string[] args)
    {
try
        {
            // 创建 Document 对象
            Document document = new Document();
            // 加载 RTF 文件
            document.LoadFromFile("input.rtf");
            // 保存为 PDF 文件
            document.SaveToFile("output.pdf", FileFormat.PDF);
            Console.WriteLine("RTF 文件成功转换为 PDF 文件！");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"发生错误：{ex.Message}");
        }
    }
}</code></pre><p>通过抛出异常，用户可以确认文件路径是否正确或是否存在其他问题。</p><h2>总结</h2><p>使用 Spire.Doc for .NET 转换 RTF 文件为 PDF 文件非常简单，只需几行代码即可完成。通过加载 RTF 文件并将其保存为 PDF，开发者能够在自己的应用程序中轻松实现文档处理功能。此外，通过适当的异常处理，可以增强程序的健壮性，使得用户体验更佳。</p><p>这种文档转换在实际应用中具有广泛的应用场景，如报告生成、数据导出和文档共享等。无论是业务应用还是学术需求，掌握这种技能都是现代开发者不可或缺的能力。</p>]]></description></item><item>    <title><![CDATA[DORA 2025：AI 辅助开发如何改]]></title>    <link>https://segmentfault.com/a/1190000047432220</link>    <guid>https://segmentfault.com/a/1190000047432220</guid>    <pubDate>2025-11-27 15:09:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>AI 已从“前沿探索”变成软件研发的日常工具，但在我接触的大量中国企业里，管理层对它的期待与现实体验，往往并不一致。最新发布的 DORA 2025 报告，给我们提供了一套相对冷静、基于证据的视角：AI 到底改善了哪些研发效能指标，又在哪些地方制造了新的不稳定？本文尝试站在中高层管理者与 PMO 的角度，对这些关键发现做一次系统梳理，帮助你用更务实的方式审视 AI 研发效能。</blockquote><h2>从“要不要上 AI”，到“AI 已经无处不在”</h2><p>过去两年，我在不同规模和行业的客户现场听到最多的两个问题是：</p><ul><li>“我们是不是也该搞点 AI，别被落下？”</li><li>“AI 研发效能到底有没有实打实的提升？”</li></ul><p>DORA 2025 的数据，至少可以帮我们回答第一部分——这已经不是“要不要上 AI”的问题，而是“你有没有能力驾驭 AI”的问题。</p><h3>1. AI 使用已经成为软件研发的“新默认”</h3><p>DORA 报告显示：在 2022 年，开发者使用 AI 还算新鲜事，如今超过 90% 的技术专业人员会在工作中使用 AI 工具；其他行业调研也表明，84% 的开发者正在使用或计划使用 AI 工具进行开发。</p><p>这背后还有两组值得管理层注意的信号：</p><ul><li>企业层面：88% 的企业领导者表示，加速 AI 采纳是优先事项，2024 年全球企业在 AI 上的总投资达到 2523 亿美元，同比增长 26%。</li><li>招聘层面：包含“生成式 AI 技能”的职位发布量在一年内增长了 300%+。</li></ul><p>换句话说，无论你个人是否乐观，AI 已经是大多数研发团队的“日常基建”，而不是未来时的选配项。</p><h3>2. 但“广泛采纳”不等于“广泛价值”</h3><p>虽然上面提到 AI 已经是大多数研发团队的“日常基建”，但 DORA 报告中同时也提醒我们：</p><blockquote>很多企业的 AI 计划仍然是由“FOMO（错失恐惧症）”驱动，而不是深思熟虑的战略。</blockquote><p>这句话对国内环境尤为适用。在不少客户现场，我看到的 AI 项目是这样推进的：</p><ul><li>由上而下定一个目标：“要在某某大会上讲我们也在用 AI”；</li><li>集中采购一批许可证，安排几轮培训；</li><li>要求研发部报“节省了多少人天”“代码产出提升了多少”。</li></ul><p>许可证买了、插件装了、分享会开了，开发者主观上觉得好像更快了。短期看，这类项目有一些可展示的成果；但长期看，它们往往没有改变组织的 AI 研发效能——也就是没有在交付节奏、质量稳定性、价值流效率上留下清晰的改善轨迹。</p><h2>AI 真正改善了哪些“研发效能”指标？</h2><p>DORA 团队这次用了一个相对严谨的方式：在控制环境和流程等因素之后，比较同类人群中 AI 采纳程度不同的人，看他们在各类结果上的差异。它没有停留在“开发者好感度调查”，而是尝试用多维度指标去刻画“AI 研发效能”的真实变化。</p><h3>1. 个体视角：生产力与代码质量的真实提升</h3><p>在个人层面，AI 研发效能的提升是被数据反复验证的。</p><p>DORA 发现，在其它条件相同的情况下，AI 采纳程度越高的从业者，越有可能报告更高的个人效能和代码质量。比如：</p><ul><li>更高水平的个人效能；</li><li>更高比例的时间用于“有价值的工作”；</li><li>更高水平的代码质量；</li><li>更高水平的团队效能、组织效能以及产品效能；</li><li>更高的软件交付吞吐量。</li></ul><p>用大白话讲，就是：</p><blockquote>AI 让开发者更容易把时间花在“创造价值”的事情上，而不是机械劳动上；同时对代码质量和产品结果，也有统计意义上的正向影响。</blockquote><p>这与我在客户现场的观察基本一致：当团队已经有一定的工程基础，AI 非常擅长削减“边角料工作”——写重复代码、整理接口文档、生成简单测试、起草方案初稿。让骨干可以把精力更多放在架构决策、复杂场景和跨团队协作上——这才是真正的 AI 研发效能。</p><h3>2. 组织视角：效能的多个维度“同时变好”</h3><p>如果把视角从个体拉到组织，DORA 进一步指出：在具备一定基础设施和管理成熟度的前提下，AI 采纳度更高的团队在组织效能、团队效能、产品效能和交付吞吐量上整体表现更好。</p><p>这说明，只要底层没有严重短板，AI 研发效能的提升是可以传导到业务侧的，而不是只停留在“个人自我感觉良好”。</p><p>我通常会建议管理层，把这部分效应理解为：</p><p><strong>AI 不会帮助一个混乱的组织“起死回生”，但会显著放大一个本来就走在正确方向上的组织的优势。</strong></p><h2>AI 没有解决的三个问题：摩擦、倦怠与不稳定性</h2><p>然而，DORA 也非常坦诚地展示了另外一面——有些问题，采用 AI 后几乎没有动静，甚至在恶化。</p><h3>1. 摩擦与倦怠：这是组织问题，不是工具问题</h3><p>DORA 报告显示，AI 采纳程度与“工作摩擦”和“职业倦怠”的改善几乎没有显著相关性。——换句话说，用不用 AI，大家吐槽流程、抱怨疲惫的程度差不多。</p><p>DORA 给出的解释是：</p><blockquote>这些结果更多是“社会技术系统”（流程 + 文化）的产物，即流程、结构和文化共同作用的结果。超出了个体开发者能够左右的范围。</blockquote><p>这非常符合国内很多研发团队的现实：</p><ul><li>需求变更频繁、优先级经常反复拉扯；</li><li>评审链路长、审批层级多，决策迟缓；</li><li>跨团队协作模糊，职责边界不清晰；</li><li>指标压力只下沉不共担。</li></ul><p>在这种场景下，你即便给每个人配一个顶级 AI 助手，他也最多只能帮你“更快地做完错误的事”。</p><p>从组织治理角度看，这组数据在提醒管理层：</p><p><strong>不要指望用 AI 来弥补结构性问题——那些问题需要的是决策机制调整、权限划分与流程重构，而不是一个更聪明的编辑器。</strong></p><h3>2. 软件交付不稳定性：AI 把“隐性风险”提前暴露</h3><p>更值得警惕的一点是：AI 与“软件交付不稳定性”的上升存在统计相关性。</p><p>2024 年的 DORA 研究曾指出：当 AI 采纳率每增加 25%，如果不配套改进交付体系，会出现“交付吞吐量平均下降 1.5%，不稳定性上升 7.2%”的反常现象。</p><p>2025 年的情况好一些——吞吐量开始提升，但不稳定性问题依然没有根本好转。</p><p>原因其实不难理解：</p><p>AI 把“写代码的门槛”进一步放低了，让开发者更容易做出“更大体量的变更”；<br/>但测试自动化、灰度发布、监控与回滚能力，如果仍停留在“人肉 + 手工”的旧时代，系统自然会变得更脆弱。</p><p>DORA 的表述是：AI 目前主要集中在“键盘端”，因此提升了代码质量和生产力，但没有触及引发摩擦、倦怠和不稳定性的那些深层结构。</p><p>如果管理层只看到 AI 研发效能带来的“提速”，却忽略了不稳定性与隐性风险的叠加，就很容易在一年后迎来一波“质量与运维事故的反噬”。</p><h2>AI 是“放大器”而不是“银弹”：七项能力与七类团队</h2><p>DORA 在摘要部分给技术领导者提了一个非常重要但容易被忽略的结论：</p><blockquote>成功的 AI 采纳是一个系统问题，而非工具问题。</blockquote><p>这句话背后，有两个关键支点。</p><h3>1. 七项 AI 能力：决定 AI 研发效能的“上限”</h3><p>今年 DORA 报告的一个重要成果，是首次提出了 DORA 人工智能能力模型，总结出七项能显著放大 AI 效益的能力，其中几项与 AI 研发效能直接相关的包括：</p><p><strong>① 明确且已共识的 AI 立场</strong></p><ul><li>是否有清晰的 AI 使用政策；</li><li>员工是否知道哪些场景可以大胆试验，哪些场景必须严格审慎。</li></ul><p><strong>② 健康的数据生态系统 &amp; AI 可访问的内部数据</strong></p><ul><li>内部数据（代码库、文档、工单、日志）是否干净、可访问、结构化；</li><li>AI 是否能安全访问这些内部信息，而不仅仅停留在“通用聊天机器人”。</li></ul><p><strong>③ 稳健的版本控制 + 小批量工作模式</strong></p><ul><li>团队是否鼓励小步提交、频繁集成；</li><li>出现问题时，能否快速精准地回滚到安全版本。</li></ul><p><strong>④ 以用户为中心的关注点与高质量内部平台</strong></p><ul><li>研发是否真正围绕用户价值做优先级决策；</li><li>是否存在一个统一的内部平台，为开发者提供统一入口、统一规范。</li></ul><p>从 AI 研发效能的角度看，这些能力决定了本一家企业的“研发效能上限”，AI 只是让你更快地触碰那个上限——是高是低，取决于你之前打的地基。</p><h3>2. 七类团队：先知道自己在哪里，再谈要去哪里</h3><p>另一方面，DORA 还基于研发效能结果，比如吞吐量、不稳定性、团队效能、产品效能、摩擦、倦怠等维度，将团队划分为七类典型画像，从“和谐高成就者”到“遭遇基础性挑战者”。</p><p>有两个关键观察值得管理层重视：</p><ul><li>最佳表现者（聚类 6 与 7）能够在“速度”和“稳定性”两个维度上同时取得卓越成绩，占样本近 40%。</li><li>另一端的团队（例如聚类 1、聚类 4），要么深陷基础问题，要么“高影响低节奏”，速度缺乏稳定性，是危险且不可持续的状态。</li></ul><p>这直接打破了一个传统迷思：速度与稳定性不是天然对立的，优秀团队完全可以两者兼得。</p><p>而 AI 在这里扮演的角色，很可能是：</p><ul><li>对于已经接近聚类 6/7 的团队，AI 是一个加速器，可以进一步放大 AI 研发效能；</li><li>对于停留在聚类 1/2 的团队，AI 可能只是把问题“放大并提前暴露”——这未必是坏事，但如果管理层没有系统观，就容易误以为“AI 没用，甚至添乱”。</li></ul><p>因此，在设计 AI 路线图之前，最重要的一步其实是：搞清楚自己属于哪一类团队，而不是“简单抄一份别家的 AI 方案”。</p><p>这一点，我会留到下一篇文章中，用专门的一篇来展开。</p><h2>给中高层和 PMO 的三点行动建议</h2><p>站在项目治理与组织效能的角度，结合 DORA 2025 的数据和本土实践，我会给中高层和 PMO 三个相对直接的建议。在规划 AI 研发效能提升时，至少考虑以下三件事。</p><h3>1. 把 AI 项目从“工具采购”升级为“交付系统重构”</h3><p>如果你的 AI 项目目标只有两条：</p><ul><li>采购若干 AI 工具或平台；</li><li>证明“我们也在用 AI，且节省了 X% 人力”。</li></ul><p>那么在 DORA 的体系中，你大概率会落入那类高不稳定性、低可持续性的组织。</p><p>更健康的 framing 应该是：</p><blockquote>我们希望能借助 AI 这次契机，整体升级软件交付系统</blockquote><p>这意味着，AI 规划要与以下议题强绑定：</p><ul><li>系统架构是否支持小批量、易回滚的变更；</li><li>测试与发布流水线是否足够自动化、可观测；</li><li>需求管理、优先级机制是否真正以用户和业务价值为导向。</li></ul><h3>2. 用价值流管理，把 AI 接入“端到端”</h3><p>DORA 用大量数据证明：价值流管理（VSM）可以显著提升团队效能、有价值工作时间与产品效能，是 AI 投资的放大器。</p><p>一个可操作的小步骤是：</p><ul><li>选一个有代表性的产品或系统；</li><li>让产品、研发、测试、运维、安全坐在一起，用一张 A3 纸画出当前从“想法”到“上线”的全过程；</li><li>标注每个环节的平均等待时间、返工率以及常见摩擦点。</li></ul><p>在这张图出来之前，不要急着讨论“用哪种 AI 工具”，否则你很可能在非瓶颈环节取得漂亮的局部优化，却看不到整体 AI 研发效能的提升。</p><h3>3. 把平台工程与数据治理当成 AI 成功的“基础设施项目”</h3><p>最后，DORA 明确指出：</p><ul><li>90% 的企业已采用平台工程，76% 拥有专职平台团队；</li><li>高质量内部平台能显著增强 AI 对组织效能的正面影响，是 AI 成功应用的关键基础。</li></ul><p>同样，健康的数据生态也是七项 AI 能力中的核心一环：高质量、可访问、一致性的内部数据，直接决定 AI 能否从“聪明玩具”变成“业务助手”。</p><p>对管理层来说，这意味着：</p><ul><li>如果你没有统一的内部开发者平台，AI 工具只会进一步加剧“工具碎片化”和“协作割裂”；</li><li>如果你的数据分散在多个孤岛，质量参差不齐，AI 再强也只能给你生成“看起来聪明但不可信”的回答。</li></ul><p>因此，把 AI 项目的预算单独拎出来讨论往往是陷阱。更务实的做法，是把平台工程建设、内部数据治理、AI 能力接入与治理，视为同一个“AI 研发效能基础设施项目”的三个侧面。</p><h2>结语：管理者需要的，是“更清醒的系统观”</h2><p>DORA 2025 带来的最大价值，不在于告诉我们“AI 很重要”（这一点你可能早就感受到了），而在于用数据提醒我们：</p><blockquote>AI 能显著提升个体与组织的研发效能，但前提是底层系统足够健康。</blockquote><p>工作摩擦、职业倦怠和交付不稳定性，是组织结构与文化的结果，不会因为买了 AI 工具自动消失。</p><p>真正优秀的团队，可以在高吞吐与高稳定之间实现双赢，关键在于你有没有勇气用系统工程的方式重构交付体系。</p><p>作为中高层管理者与 PMO，如果你把 AI 看成一场 “交付系统升级”与“组织能力重塑” 的契机，而不是一轮工具采购，这场变革将更有可能为你的企业带来长期的 AI 研发效能优势。</p><p>在下一篇文章中，我会结合 DORA 2025 提出的七类团队画像模型，进一步展开讨论：</p><ul><li>如何判断你的团队属于哪一种类型？</li><li>不同类型在上 AI 时应该先补哪些课、踩哪些刹车？</li><li>如何在不透支团队的前提下，逐步提升 AI 研发效能？</li></ul><p>敬请留意下一篇：<strong>《DORA 2025：基于七类团队画像的 AI 研发效能诊断方法》。</strong></p>]]></description></item><item>    <title><![CDATA[Java 应用容器化与部署 信码由缰 ]]></title>    <link>https://segmentfault.com/a/1190000047432373</link>    <guid>https://segmentfault.com/a/1190000047432373</guid>    <pubDate>2025-11-27 15:08:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><em>如何开始打包、分发并将 Java 交付至生产环境</em></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432375" alt="" title=""/></p><blockquote><strong>应用程序的容器化</strong> 提供了一种方法，可以将所有必需的应用程序资源——包括程序和配置文件、环境变量、网络设置等——组合到一个标准化、易于管理的包中。</blockquote><p>从单个容器镜像可以启动、运行、管理和终止多个功能相同的容器，确保从镜像创建点开始的一致性。容器可以在截然不同的操作平台上运行，从本地机器到全球可扩展的云环境，以及介于两者之间的一切。可以构建流水线，轻松地在它们之间过渡。<br/>虽然应用程序容器化有许多好处，但许多都可以归结为一个词：<strong>一致性</strong>。</p><h2>为何要对 JAVA 应用进行容器化？</h2><p>Java 早期的一个承诺是"一次编写，到处运行"，即"WORA"。尽管 Java 通过其 Java 虚拟机（JVM）实现了某种形式的目标，但在实现真正无缝的体验方面仍然存在相当多的外部障碍。<br/>容器化解决了几乎所有这些外部障碍。虽然 100% 在任何追求中都可能是一个难以实现的目标，但将 Java 应用程序的可执行文件及其所有必需的依赖项和支持属性（配置等）打包的能力，使我们达到了有效的 100% 可移植性和一致性水平。</p><h2>为 JAVA 应用程序创建 DOCKERFILE</h2><p>许多开发人员通过仔细阅读官方的 Dockerfile 参考文档来开始他们的容器化工作。为了立即获得良好效果，让我们介绍关键点，创建一些镜像，并在此基础上进行构建。</p><h3>为容器化选择操作系统和 JDK 构建</h3><p>对此有各种不同的观点，但如果您刚开始接触容器化，从一个较小但完整的操作系统（OS）开始是一个很好的第一步。我们稍后将讨论其他选项（例如，无发行版）。<br/>一般来说，您在操作系统层包含的内容越多，容器镜像就越大，安全漏洞的攻击面也就越大。可信来源也是一个关键的考虑因素。如果使用完整的操作系统构建，强烈推荐使用 eclipse-temurin（基于 Ubuntu）或 Alpine 基础层。<br/>任何 OpenJDK 的构建都能运行您基于 JVM 的 Java 应用程序，而 Eclipse Temurin 是众多良好选项之一。但是，如果您希望对可能发现的任何 Java 问题获得专门的生产支持，那么选择商业支持的构建可以提供这种支持。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432376" alt="" title="" loading="lazy"/></p><h3>JAVA 应用的基本 DOCKERFILE 结构</h3><p>一个基本 Java 应用程序的最低可行 Dockerfile 看起来像这样：</p><pre><code class="dockerfile">FROM eclipse-temurin:latest
COPY java-in-the-can-0.0.1-SNAPSHOT.jar /app.jar
EXPOSE 8080
CMD ["java", "-jar", "/app.jar"]</code></pre><p>将上述文本（在 <code>COPY</code> 指令中使用您应用程序的名称）保存在一个名为 <code>Dockerfile</code> 的文件中，该文件与您的 Java 应用程序（<code>.jar</code>）文件位于同一目录。<br/>在上面的 Dockerfile 中，我们提供了构建容器镜像的基本信息：</p><ul><li>构建应用程序容器镜像所基于的更高层<strong>基础镜像</strong>（<code>FROM</code>）</li><li>将 .jar 文件<strong>复制</strong>（<code>COPY</code>）到镜像中（在此示例中，还进行了重命名）的命令</li><li>为应用程序监听连接请求而需要<strong>暴露</strong>（<code>EXPOSE</code>）的任何特定端口（如有必要）</li><li>在容器启动时运行应用程序的<strong>命令</strong>（<code>CMD</code>）<br/>在包含您的 Dockerfile 和 .jar 文件的目录中执行以下命令：</li></ul><pre><code class="bash">docker build -t &lt;app-image-name&gt; .</code></pre><p>请注意，在运行镜像创建和其他容器命令之前，docker 守护进程（或 Mac/Windows 上的 Docker Desktop、Podman 等）必须正在运行。另外，不要忘记命令末尾的 <code>.</code>；它指的是可以找到 Dockerfile 的当前目录。<br/>以这种方式运行生成的应用程序容器，用您上面创建的容器镜像名称替换 <code>&lt;app-image-name&gt;</code>：</p><pre><code class="bash">docker run -p 8080:8080 &lt;app-image-name&gt;</code></pre><h3>选择无发行版操作系统+JDK 基础镜像</h3><p>对于大多数用例，在大小和攻击面方面可实现的最佳优化可能由"无发行版"基础镜像提供。虽然无发行版基础镜像中确实包含一个 Linux 发行版，但它已被剥离了任何非当前目的 specifically 不需要的文件，留下一个完全精简的操作系统，对于无发行版 Java 镜像而言，还包括 JVM。以下是一个使用无发行版 Java 基础镜像的 Dockerfile 示例：</p><pre><code class="dockerfile">FROM mcr.microsoft.com/openjdk/jdk:21-distroless
COPY java-in-the-can-0.0.1-SNAPSHOT.jar /app.jar
EXPOSE 8080
CMD ["-Xmx256m", "-jar", "/app.jar"]</code></pre><p>请注意，这个针对 Java 优化的基础镜像预先配置了 <code>java</code> 命令的 <strong>ENTRYPOINT</strong>，因此 <strong>CMD</strong> 指令用于为 JVM 启动器进程提供命令行参数。</p><h3>使用多阶段构建来减小镜像大小</h3><p>如果您有构建所需但最终输出不需要的文件，多阶段构建提供了减小容器镜像大小的方法。就本文参考而言，情况并非如此，因为 JVM 以及应用程序的 <code>.jar</code> 文件和依赖项已为镜像创建预先配置好了。<br/>正如您可能想象的那样，在某些非常常见的情况下，这变得有利。通常，应用程序通过配置好的构建流水线部署到生产环境，这些流水线基于源仓库上的触发器来创建构件。这是多阶段构建的最佳用例之一：构建流水线创建一个带有适当工具的构建容器，使用它来创建构件（例如 <code>.jar</code> 文件、配置文件），然后将这些构件复制到一个新的容器镜像中，该镜像不包含生产环境不需要的额外工具。这一系列操作大致类似于我们之前手动完成的操作，但实现了自动化，以获得一致和最优的结果。</p><h3>管理环境变量</h3><p>有多种方法可以向容器和应用程序提供输入值，用于启动或执行。一个应该采用的良好实践是，尽可能使用 <strong>ENV</strong>、<strong>ENTRYPOINT</strong> 或 <strong>CMD</strong> 指令在 Dockerfile 本身中指定所有可能的值。所有这些值都可以在容器初始化时根据需要覆盖。<br/>请注意，覆盖现有环境变量时应谨慎，因为这可能会以意外和不良的方式改变应用程序行为。<br/>使用 <code>ENV</code> 配置 Java 特定选项的示例：</p><pre><code class="dockerfile">ENV JAVA_OPTS="-Xmx512m -Xms256m"</code></pre><p>相同的概念也适用于应用程序特定变量：</p><pre><code class="dockerfile">ENV APP_GREETING="Greetings, Friend!"</code></pre><p>使用 ENTRYPOINT 配置应用程序特定值的示例：</p><pre><code class="dockerfile">ENTRYPOINT ["java", "$JAVA_OPTS", "-jar", "your-app.jar"]</code></pre><p>使用 CMD 的示例：</p><pre><code class="dockerfile">CMD ["java", "-Xmx256m", "-jar", "/app.jar"]</code></pre><p>您可能已经注意到，<strong>ENTRYPOINT</strong> 和 <strong>CMD</strong> 都可以用来执行 Java 应用程序。像所有其他技术（和非技术）选项一样，这两种指令各有优缺点。如果操作得当，两者都会使您的 Java 应用程序运行。<br/>一般来说，Java 应用程序使用 <strong>CMD</strong> 指令，以便应用程序可以处理操作系统信号，用于支持的钩子机制（例如，<code>SIGTERM</code> 对应 <code>java.lang.Runtime.addShutdownHook</code>）。当然，这并非绝对必要，并且可以（也经常）使用 <strong>ENTRYPOINT</strong> 和 <strong>CMD</strong> 来促进运行时参数传递，以提供/覆盖特定行为。这两者并不互斥。</p><h2>使用 SPRING BOOT 插件进行容器化</h2><p>如果您使用 Spring Boot 开发 Java 应用程序，容器化会简单得多。无论使用 Maven 还是 Gradle 作为项目构建工具，创建容器镜像都像执行一个预定义的目标一样简单。</p><ul><li>如果使用 <strong>Maven</strong> 作为构建工具，您可以通过调用 <code>build-image</code> 目标来创建包含应用程序的容器镜像：<br/><code>./mvnw spring-boot:build-image</code></li><li>如果使用 <strong>Gradle</strong> 作为构建工具，您可以通过调用 <code>bootBuildImage</code> 目标来创建包含应用程序的容器镜像：<br/><code>./gradlew bootBuildImage</code><br/>在大多数情况下，自定义镜像创建（例如，镜像层定义）既不必要也不可取，但如果需要这样做，请参阅 Spring Boot Maven 或 Gradle 插件文档中的"打包 OCI 镜像"部分。</li></ul><h2>为原生应用程序构建容器镜像</h2><p>开发人员可以选择使用 JVM 或作为原生的、操作系统特定的可执行文件来交付 Java 应用程序。以下部分提供了一些关于选择的考虑因素，以及如果您决定使用原生应用程序构建容器镜像，如何以最小的代价实现。</p><h3>使用 GRAALVM 的 JAVA 原生可执行文件</h3><p>GraalVM 支持创建原生可执行文件/二进制 Java 应用程序，在构建时执行所有编译和优化，而不是利用 JVM 在运行应用程序字节码时进行一些优化。<br/>与所有选择一样，需要权衡利弊。编译为字节码与原生可执行文件是秒与分钟的问题，并且 JVM 执行的运行时优化在原生可执行文件中消失了，因为代码无法在运行时动态重写（这是 JVM 启用的一个特性）。<br/>原生可执行文件优于基于 JVM 的 Java 应用程序的地方在于文件大小、内存需求和启动时间。原生应用程序要小得多，需要的资源更少，不需要 JVM 存在，并且启动速度显著更快。这在许多生产环境中是非常重要的考虑因素，因为较小的应用程序（及其容器）会降低平台资源需求，并且以毫秒而不是几秒衡量的启动时间可以增加可用性、可扩展性以及系统设计和部署的选项，从而可以显著节省成本。<br/>根据您的框架和工具选择，有几种构建完全可执行的、操作系统原生的 Java 应用程序的选项。然而，一旦您有了原生可执行文件/二进制应用程序，您可以创建一个类似以下的 Dockerfile 作为您的原生应用程序容器镜像的模板：</p><pre><code class="dockerfile">FROM alpine:latest
WORKDIR /app
COPY java-in-the-can /app/
EXPOSE 8080
CMD ["/app/java-in-the-can"]</code></pre><p>如果您使用 Spring Boot，您可以使用 GraalVM Maven 或 Gradle 插件，通过一条命令将您的应用程序编译为操作系统原生应用程序并创建容器镜像。</p><p><strong>MAVEN</strong><br/>首先，将此依赖项添加到您的 <code>pom.xml</code> 的 <code>&lt;build&gt;&lt;plugins&gt;</code> 部分并保存文件：</p><pre><code class="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;
    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;</code></pre><p>要构建原生应用程序和容器镜像，从您的项目根目录运行此命令：<br/><code>./mvnw -Pnative spring-boot:build-image</code></p><p><strong>GRADLE</strong><br/>类似地，将此依赖项添加到您的 <code>build.gradle</code> 文件的 <code>plugins {}</code> 部分并保存：<br/><code>id 'org.graalvm.buildtools.native'</code></p><p>要构建原生应用程序和容器镜像，从您的项目根目录运行此命令：<br/><code>./gradlew bootBuildImage</code></p><h2>关于减小镜像大小和加快启动时间的考虑因素</h2><p>您可能已经注意到，上述各节的顺序总体上趋向于生产更精简、启动更快的容器镜像。许多决策可能涉及组织标准或选择（例如，部署标准），这些标准或选择会使天平倾向于或反对某些选择，但一般来说，容器镜像优化的路径遵循以下顺序：</p><ol><li>选择更小的基础镜像（操作系统发行版和 JVM）</li><li>选择带有 JVM 的无发行版镜像</li><li>如果您的工具链（例如 Spring Boot）允许，利用专门构建的工具</li><li>利用带有原生可执行应用程序的精简发行版或无发行版镜像</li></ol><h2>容器中 JAVA 应用程序的部署策略</h2><p>您的应用程序的重要考虑因素超出了将其打包成应用程序容器镜像的范围。接下来是部署和维护决策，这些决策对于您的应用程序进入并保持在生产环境至关重要。</p><h3>单容器部署</h3><p>对于基本上是自包含的应用程序，部署到生产环境可以像单个命令一样简单，前提是部署目标已准备好接受容器化应用程序。即使在应用程序部署之前必须创建支持资源的情况下，这通常也意味着通过命令行或 Web 门户发出少量指令。当应用程序包含多个容器部署时，进程间依赖关系可能要求按特定顺序部署容器，以确保可用性或最小化波动或 chatter。为了实现这些目标，需要进行编排部署。</p><h3>编排部署</h3><p>编排部署可能比单容器部署复杂得多，并相应地提供更多功能。由于这两个特点，与单容器部署相比，编排部署可能有更多平台层级值得考虑。这些层级范围从提供广泛灵活性并相应需要开发人员付出更高水平努力的较低层级 Kubernetes 平台，到完成大量繁重工作以安全配置和集成多个容器和/或服务的完整平台。<br/>您选择的目标平台将决定您对部署工具（例如，脚本、门户、基础设施配置工具）的选择。非常笼统地说，您选择的平台目标应该是能够部署和维护您的应用程序及其相关服务的最简单的平台。其他重要的考虑因素包括应用程序所有必需容器/服务的部署目标之间的比较成本、您组织已建立的实践/流水线等。</p><h2>构建支持持续打补丁的 JAVA 应用程序</h2><p>生产部署在应用程序上线后并未完成；开发人员必须确保应用程序保持安全、最新和可用。关键的补丁管理考虑因素包括：</p><ul><li><strong>定期补丁</strong> – 为常规补丁（例如，每月或每季度）建立一个无中断、可预测的频率，以更新库和依赖项</li><li><strong>紧急补丁</strong> – 提供关于何时需要紧急补丁的指导，通常是为了应对关键漏洞或紧急安全更新<br/>容器镜像中需要打补丁的组件包括：</li><li>基础操作系统容器镜像</li><li>附加的操作系统包（如果适用）</li><li>应用程序运行时（例如，JVM 版本，如果未包含在基础镜像中）</li><li>应用程序依赖项/库</li><li>应用程序性能监控（APM）代理二进制文件<br/>由开发人员及其组织来决定并严格维护一个保护应用程序、系统基础设施和数据的补丁策略。请参考此指南来帮助制定您的具体策略。</li></ul><h2>结论</h2><p>容器化使开发人员能够将所有必需的应用程序资源和支持服务组合到一个或多个容器镜像中，并更轻松地部署、运行和管理它们。如果操作得当，容器化可以从镜像创建点开始实现安全性和一致性。容器可以在截然不同的操作平台上运行，从本地机器到全球可扩展的云环境。可以构建流水线，轻松地在它们之间过渡。因此，开发人员构建和运行支持生产工作负载的相同构件，减少了冲突并简化了调优和故障排除。<br/>如果您是容器新手，请从小处着手，在本地构建以获得知识和稳定的基础，然后通过纳入更多容器最佳实践、构建流水线和合适的云平台来"扩展构建"，逐步走向强大的应用程序部署生产模型。</p><p><strong>其他考虑因素和资源：</strong></p><ul><li>工具 – <a href="https://link.segmentfault.com/?enc=k5MAa7z9Q6zkdcKHICiVNA%3D%3D.J1A4FqxkSheG%2FERVoCvlXv83oz5kgxYG0EP0CvkMwwQ%3D" rel="nofollow" target="_blank">Docker</a>, <a href="https://link.segmentfault.com/?enc=AEAlGDu7yAkmtblu%2BDOn4A%3D%3D.7he1MTPrFi12BPO2qTP4dKtLFFkes7at9%2B2HhbNR8Lg%3D" rel="nofollow" target="_blank">Podman</a>, <a href="https://link.segmentfault.com/?enc=JuKwTjqVfejsN0iqRXjQ%2Fw%3D%3D.A5s7S78Xl0AXi2NrVmliBzjkbVwvIX73%2BcEKkoVRMxM%3D" rel="nofollow" target="_blank">Minikube</a>, <a href="https://link.segmentfault.com/?enc=NmO2UKct%2FsqQNX4ZrQ77lg%3D%3D.rBwBUbxmoRy4Td2GBUpVbKVq9G1Ag35zLYZUsAmGkn4%3D" rel="nofollow" target="_blank">Skaffold</a></li><li>基于 JVM OSS 的可观测性工具 – <a href="https://link.segmentfault.com/?enc=Y9PQk3v2A3NlEzdJk%2BS2TQ%3D%3D.07pel9gP3oMVRk%2BhkG%2Fsl7zqc2odmTrhsV6AB%2FECavMvSITh4I8o1Ftkn7FRu3iMJPus7ptH5hTjXo7MxhlI2Ks9XDEn2AGXUnlz%2FFmFhDc%3D" rel="nofollow" target="_blank">Java Flight Recorder</a>, <a href="https://link.segmentfault.com/?enc=N67PyyMksOphwDsihsEiQQ%3D%3D.6S0FfRnBto5ZqogeIME7Zz2ZP%2FcTMfJAkWp1RN9r7XVhH%2Fvvu1nAnJ1cGq8U8oxnSCQPO7iWpLkJ6lYGs6FR4dGfUYBOOE1EJ2Xt8S818as%3D" rel="nofollow" target="_blank">Java Mission Control</a>, <a href="https://link.segmentfault.com/?enc=%2FEyzSrky79a4k7788Hm2qw%3D%3D.n0AOCh9nx5osvcUNMz6bERcdnRxYvPmKdH6lWUi22AI%3D" rel="nofollow" target="_blank">Visual VM</a>, <a href="https://link.segmentfault.com/?enc=%2F7MT95nG4ZY9f%2FdZpY3UWg%3D%3D.n31v4H9UMPzhi5uqSrpMGD%2B7M0grA5xAFPi26f1uceENWLfLYyR6ABNAH41j%2BSuJ" rel="nofollow" target="_blank">Jitwatch</a></li></ul><blockquote><strong>作者：MARK A. HECKLER,</strong><br/><strong>微软首席云技术推广专家（Java/JVM 语言）</strong><br/>Mark Heckler 是一名软件开发人员，微软的 Java/JVM 语言首席云技术推广专家，会议演讲者，Java Champion 和 Kotlin 开发专家，专注于为云和边缘计算平台快速开发生产软件。Mark 是开源贡献者，也是《Spring Boot: Up and Running》的作者，可以在 X @mkheck 上找到他。</blockquote><hr/><p>【注】本文译自：<a href="https://link.segmentfault.com/?enc=yHWFoeHA%2FqXLsTKh0d74Lw%3D%3D.lHc0Wm9MnYYqQQi6QY4XI5HS8gFWBfWyjHBHGrIRWRHgXXAxkTGewl5c5R9%2BqcqmR%2BYdihietepp3cFtSkrWc9i%2F83g6pnuV0m%2FShX%2BchvE%3D" rel="nofollow" target="_blank">Java Application Containerization and Deployment</a></p>]]></description></item><item>    <title><![CDATA[数字孪生赋能园区运营：孪易IOC标准版如]]></title>    <link>https://segmentfault.com/a/1190000047432382</link>    <guid>https://segmentfault.com/a/1190000047432382</guid>    <pubDate>2025-11-27 15:08:12</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当今快速发展的数字化时代，园区运营管理面临着前所未有的挑战与机遇。从传统工业园区到现代化科技园区，运营方需要实时掌握园区内设备运行、能耗管理、安防监控等复杂信息，同时还要应对突发事件、优化资源配置。数字孪生技术作为数字化转型的重要工具，正在为园区运营带来革命性的变化。<br/>孪易数字孪生IOC作为一款专业的数字孪生智能运营中心构建平台，已经在多个园区项目中得到成功应用。</p><h2>一、多源数据整合：打破园区信息孤岛</h2><p>现代园区运营涉及的数据源极为复杂：物联网传感器实时采集的环境数据、设备运行状态数据、能源消耗数据、安防监控视频流、停车管理系统数据等。这些数据往往分散在不同的系统和平台中，形成了严重的信息孤岛。<br/>孪易IOC通过强大的多源数据集成能力，实现了园区各类数据的统一接入与融合。在实际应用中，某科技园区通过该平台接入了超过2000个物联网传感器数据，包括温湿度传感器、用电监测设备、停车场感应器、安防摄像头等。平台支持MQTT协议、各类IoT网关，并能无缝对接华为云、阿里云等主流物联网平台，确保了各类设备数据的顺畅接入。<br/>更值得一提的是，平台不仅支持数据的实时同步与可视化，还能通过“对象控制”功能，向场景中的孪生体发送指令。例如，当系统检测到某区域能耗异常时，可自动调节相关设备的运行参数，实现从感知到决策再到控制的完整闭环。</p><h2>二、智能监控告警：从被动响应到主动预防</h2><p>传统的园区运营往往依赖于人工巡检和事后处理，响应效率低且容易遗漏问题。孪易IOC的监测运维模块彻底改变了这一状况。<br/>在某大型产业园区的实际部署中，运营团队通过“业务主题”功能，围绕能耗管理、设备运维、安防监控等核心业务，聚合相关的孪生体、数据图层和图表，形成了综合性的监控看板。管理人员通过一个大屏就能全面掌握园区的运行态势，实现真正的“一屏统览”。<br/>“场景剖分”功能在园区复杂空间管理中发挥了重要作用。该园区包含多栋建筑、地下管网、设备机房等复杂结构，通过层层剖析功能，管理人员可以清晰地查看任一区域的详细情况，无论是地下管线的走向，还是设备机房内部的布局，都能一目了然。<br/>平台的智能告警系统更是将园区管理提升到了新的高度。系统支持基于复杂条件自定义告警规则，并能对告警信息进行自动分类和快速定位。在某次实际应用中，系统提前预警了中央空调系统的异常运行状态，通过“告警分析”功能追溯历史数据，发现是滤网堵塞导致的效率下降，避免了设备的进一步损坏和能源浪费。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdmSiz" alt="" title=""/></p><h2>三、灵活配置：满足园区个性化需求</h2><p>每个园区都有其独特的管理需求和工作流程，通用的解决方案往往难以完全契合。孪易IOC通过强大的后台配置工具，让园区运营团队能够自主定制和调整数字孪生系统。<br/>在某智慧园区项目中，运营团队通过“后台管理”功能，仅用两周时间就完成了整个数字孪生系统的配置和优化。从场景的基础参数设置、孪生体对象的属性定义，到数据分析图表的样式调整，全部通过可视化界面完成，无需编写代码。<br/>“孪生体类别配置”功能允许园区精确定义每一类设备的数据结构、三维外观以及状态变化逻辑。例如，对于不同类型的空调设备，可以设置不同的运行参数阈值和告警条件，确保虚拟模型与物理实体行为的高度一致。</p><h2>四、行业解决方案：加速项目落地</h2><p>为了帮助园区快速实现数字化转型，孪易IOC提供了丰富的行业插件库。这些插件包含了智慧园区领域的典型孪生体定义、分析主题、告警条件和高品质三维模型。<br/>某新建科技园区在项目启动阶段就采用了平台的智慧园区解决方案模板，仅用一个月时间就完成了基础数字孪生系统的部署。模板中预置的园区建筑模型、设备模型、能耗分析主题等，大大降低了从零开始构建系统的难度和成本。<br/>对于有特殊需求的园区，产品提供了从“零代码”应用到基于JavaScript的“低代码”开发，再到利用专业引擎进行高逼真度场景构建的全套工具链。这种灵活性确保了系统既能满足当前快速上线的需求，也能伴随园区发展进行持续演进。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdmP6B" alt="" title="" loading="lazy"/></p><h2>实践成果：运营效率的显著提升</h2><p>通过部署孪易数字孪生IOC标准版，上述园区的运营效率得到了显著提升：<br/>1.设备故障响应时间从平均4小时缩短至30分钟<br/>2.能源消耗整体降低15%，每年节省电费约120万元<br/>3.安防事件处理效率提升40%，安全隐患发现率提高60%<br/>4.运营管理人员减少30%，同时管理精度显著提高<br/>某园区运营总监表示：“数字孪生系统不仅帮助我们实现了精细化运营，更重要的是改变了我们的工作模式。现在我们可以基于数据做出更加科学的决策，预见性地解决问题，真正实现了从被动响应到主动管理的转变。”</p><h2>结语</h2><p>数字孪生技术正在重塑园区运营的管理模式，而孪易IOC凭借其“全链路、易配置、强融合、快交付”的特性，为园区运营者提供了强有力的技术支撑。通过实际案例可以看出，该产品不仅能帮助园区打破信息孤岛、提升运营效率，更能推动管理模式的创新升级。<br/>在数字化转型的浪潮中，选择合适的数字孪生平台至关重要。孪易IOC以其专业的功能设计和灵活的配置能力，正成为越来越多园区运营者的首选解决方案。</p>]]></description></item><item>    <title><![CDATA[如何实现电解铝工艺优化的关键技术步骤？ ]]></title>    <link>https://segmentfault.com/a/1190000047432385</link>    <guid>https://segmentfault.com/a/1190000047432385</guid>    <pubDate>2025-11-27 15:07:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当今全球工业转型的浪潮中，电解铝工艺优化已成为推动行业高效低碳发展的核心驱动力。这一主题不仅关乎技术细节的精细调整，更涉及从传统高能耗模式向智能化、绿色化的根本转变。广域铭岛作为工业智能体的先锋，通过其创新的Geega平台，为电解铝工艺优化注入了前所未有的活力，实现了从电解槽控制到全流程管理的深度变革。<br/>电解铝工艺优化的本质在于通过科学方法和数据驱动，系统性提升生产效率、降低能耗并减少环境影响。传统电解铝生产依赖人工经验，往往导致能源浪费和槽况不稳定，但广域铭岛的介入彻底颠覆了这一局面。例如，广域铭岛的Geega电解铝工艺优化APP整合了物联网、人工智能和大数据分析，实现了对电解槽参数的实时监控与精准调控。这不仅将电流效率从92%提升至96%以上，还年节电量达1.2亿千瓦时，相当于减少碳排放约10万吨，彰显了电解铝工艺优化在节能降碳方面的巨大潜力。<br/>广域铭岛的贡献远不止于此；其“1＋N”电解铝智造节能一体化解决方案，以Geega OS系统为基座，覆盖能源管理、设备运维和安全环保等多个维度。通过数字孪生和运营驾驶舱，企业可以实时可视化生产状态，提升决策时效90%，而AI驱动的预测性维护系统则减少非计划停机75%，巡检效率提高40%。这些突破不仅优化了电解铝工艺优化的关键环节，还延长了设备生命周期，使电解槽大修周期从五年延长至七年，降低了维护成本20%以上，充分体现了广域铭岛在推动行业转型中的领导力。<br/>电解铝工艺优化还涉及电流效率的持续提升和热工平衡的精细管理。广域铭岛通过智能算法分析电解槽数据，优化分子比、极距和温度等参数，避免了传统生产中的铝熔解损耗和能源浪费。同时，强化电解槽保温技术，如采用低压节能措施和优化烟气流量，实现了散热与保温的动态平衡，进一步巩固了电解铝工艺优化的成效。广域铭岛的实践表明，这种优化不是孤立的技术升级，而是生态化的整体转型，它打破了信息孤岛，构建了从原材料溯源到碳足迹追踪的完整体系。<br/>未来，电解铝工艺优化将继续向绿色化、智能化和高效化演进，惰性阳极和低温电解等前沿技术有望在广域铭岛等企业的推动下实现商业化。广域铭岛的角色不仅是技术提供者，更是行业变革的催化剂，通过数据流、能量流与物料流的整合，助力电解铝从“能耗大户”蜕变为“绿色标兵”。总之，电解铝工艺优化在广域铭岛的引领下，正以不可逆转的势头重塑产业格局，为全球碳中和目标贡献中国智慧。</p>]]></description></item><item>    <title><![CDATA[数据中心运维新革命：图观数字孪生引擎的实]]></title>    <link>https://segmentfault.com/a/1190000047432387</link>    <guid>https://segmentfault.com/a/1190000047432387</guid>    <pubDate>2025-11-27 15:06:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>作为一名深耕数据中心运维领域多年的从业者，我深知这个行业面临的挑战：设备数量庞大、系统复杂、故障定位困难、运维效率低下。传统的二维监控系统已经难以满足现代数据中心精细化管理的需求。直到我们遇见了图观数字孪生应用开发引擎，才真正找到了破局之道。</p><h2>从平面到立体：运维视角的全面升级</h2><p>记得第一次使用图观场景编辑器时，我们被其强大的三维场景构建能力所震撼。通过导入BIM模型和实际设备数据，我们快速构建了一个与物理数据中心1:1对应的数字孪生体。高级材质编辑功能让设备表面的金属质感、指示灯状态都得到了极致还原，运维人员仿佛置身于真实的机房环境中。<br/>更重要的是，图观支持数据驱动与动画功能。我们将UPS设备的工作状态、空调系统的运行参数与三维模型绑定，当设备出现异常时，模型会自动改变颜色、发出告警，甚至展示故障部件的具体位置。这种直观的展示方式，让运维人员能够快速定位问题，大大缩短了故障处理时间。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm7Rn" alt="" title=""/></p><h2>大规模场景构建：从单机房到园区级管理</h2><p>对于拥有多个数据中心园区的企业来说，图观的城市场景生成插件展现出了独特价值。我们基于预置的城市数据，一键生成了包含建筑、道路、管网在内的园区底图，然后在关键位置嵌入了精细化的机房模型。这种"宏观+微观"的结合，让我们能够从园区级视角统筹管理所有数据中心的运行状态。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm7Rm" alt="" title="" loading="lazy"/></p><h2>零代码开发：运维人员的得力助手</h2><p>在实际应用中，图观的零代码应用开发模式让我们惊喜不已。运维团队的技术人员无需编写代码，通过拖拽式界面就能搭建出功能完善的监控大屏。内置的交互逻辑编辑器更是点睛之笔，我们配置了"点击告警信息，自动定位到场景中对应设备"的联动规则，实现了从告警到处置的无缝衔接。<br/>最令人印象深刻的是跨数据源联动功能。我们将动环监控数据、网络流量数据、业务系统状态等多个数据源进行关联，当某个业务系统出现性能下降时，大屏会自动高亮相关的网络设备和服务器，帮助运维人员快速进行根因分析。</p><h2>低代码定制：满足个性化需求</h2><p>对于特殊的运维场景，图观的低代码统一开发API提供了充分的灵活性。我们基于JavaScript API开发了几个特色功能：设备生命周期管理、能效分析看板、容量预测模型。这些功能与三维场景深度集成，为数据中心的精细化运营提供了有力支撑。<br/>特别值得一提的是双渲染内核设计。在日常办公场景，我们使用端渲染模式，保证大量用户同时访问的流畅性；在指挥中心大屏上，则切换到流渲染模式，呈现电影级的视觉效果。同一套代码适应不同场景，极大地减少了我们的开发工作量。</p><h2>实战成效：效率提升看得见</h2><p>经过多个项目的实践验证，图观数字孪生引擎为我们的数据中心运维工作带来了显著改变：<br/><strong>故障定位时间缩短70%</strong>：通过三维场景的直观展示，运维人员能够快速找到故障设备，平均处理时间从原来的30分钟缩短到10分钟以内。<br/><strong>运维成本降低40%</strong>：预防性维护更加精准，设备利用率显著提升，人力成本得到优化。<br/>管理决策更加科学：基于数字孪生的数据分析，为机房改造、设备更新、容量规划提供了可靠依据。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdm7Rl" alt="" title="" loading="lazy"/></p><h2>展望未来</h2><p>随着5G、物联网等新技术的发展，数据中心的规模和复杂度还将持续提升。图观数字孪生引擎的持续进化，为我们应对未来挑战提供了有力武器。其丰富的资产库和案例库，让我们在实施新项目时能够快速起步；API调试器则确保了开发过程的高效可靠。</p>]]></description></item><item>    <title><![CDATA[iPhone到Android 传输应用：]]></title>    <link>https://segmentfault.com/a/1190000047432393</link>    <guid>https://segmentfault.com/a/1190000047432393</guid>    <pubDate>2025-11-27 15:05:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>当用户更换到更新的iQOO机型时，不仅仅是获得更快的手机或更好的相机——还需要保留他们的数字生活。在人们携带的所有数据中，短信通常包含关键信息——如密码、地址、验证码，甚至与个人重要时刻相关的情感信息。本文探讨了将短信从iQOO传输到iQOO的4种智能方法，使传输过程顺利且无压力。无论你是技术达人还是首次迁移手机的用户，都能找到适合自己的方法，从内置工具到第三方解决方案。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432395" alt="图片" title="图片"/></p><p>方法一：使用iReaShare Phone Transfer将短信从iQOO传输到iQOO</p><p>如果你想要一种快速且无忧的方式将短信从iQOO传输到iQOO，iReaShare Phone Transfer（Windows和Mac版）是首选。这款专业工具支持设备之间的短信传输，甚至支持跨平台传输，具有高成功率、简单的一键操作和无损结果。适用于Windows和Mac系统，还可以快速可靠地传输联系人、媒体文件等。</p><p>iReaShare Phone Transfer的主要功能：</p><pre><code>在不丢失任何数据的情况下，将文件从一台iQOO设备传输到另一台。
支持在Android设备之间、iOS设备之间以及iOS与Android之间传输数据。
兼容标准及非常见数据类型，包括媒体和非媒体文件。
适用于所有Android/iOS设备，包括iQOO 13/12/11/11 Pro/Neo 7/Z7/10 Pro/Z6/9T/Neo 6/iQOO 9/8/7/6等。
保护你的隐私安全。

</code></pre><p>如何使用iReaShare Phone Transfer将数据从旧iQOO传输到新iQOO？</p><p>第一步： 下载并安装该软件的免费试用版。安装完成后，在电脑上启动程序。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432396" alt="图片" title="图片" loading="lazy"/></p><p>第二步： 使用USB数据线将两部iQOO手机连接到电脑。程序会自动识别设备，并在主界面显示可传输的数据类型。（确保旧iQOO显示在左侧，如果不是，请点击中间的“翻转”按钮）第</p><p>三步： 设备识别后，选择你要传输的数据类型，点击中间的“开始复制”按钮，即可将数据从发送设备无缝传输到接收设备。</p><p>方法二：使用EasyShare将短信从iQOO传输到iQOO</p><p>iQOO（vivo）EasyShare的“手机克隆”功能使短信等数据传输变得简单——无线、安全、直接。请注意，EasyShare不会合并重复文件；新数据将覆盖或单独添加。</p><p>操作步骤：</p><pre><code>确保两部iQOO设备都安装了EasyShare。
在两部手机上打开应用，点击底部的“更换”。
在旧iQOO上选择“手机克隆 &gt; 旧手机”，在新iQOO上选择“手机克隆 &gt; 新手机”。
旧设备会显示一个二维码，用新设备扫描二维码以建立连接。
连接成功后，选择“短信”并点击“开始数据切换”开始传输。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432397" alt="图片" title="图片" loading="lazy"/></p><p>方法三：使用Android Switch将短信从iQOO复制到iQOO</p><p>作为EasyShare的优秀替代方案，Android Switch是iQOO设备内置的功能，可快速传输短信、联系人、照片和应用等数据。它使用安全的无线连接，无需云端或电脑即可轻松完成iQOO之间的短信迁移。</p><p>操作步骤：</p><pre><code>在旧手机上打开应用，按提示点击“复制数据”开始。
在新手机上点击“开始”；在“复制应用和数据”界面，点击“下一步”两次，选择“无数据线”选项。
按提示点击“继续”，进入二维码界面。
用旧手机扫描二维码，然后点击“加入”。
设备连接后，点击“确定”以启用网络访问。
选择“信息”，点击“继续”，最后点击“发送请求”开始传输。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432398" alt="图片" title="图片" loading="lazy"/></p><p>方法四：使用SMS Backup &amp; Restore将短信从iQOO移动到iQOO</p><p>SMS Backup &amp; Restore是一款可靠的Android应用，支持在设备之间传输短信和通话记录，包括iQOO 13/12/11/10/9/8/7等型号。它使用本地Wi-Fi连接，无需数据线或云账户。只需在两部手机上安装应用，连接后即可轻松安全地迁移短信记录。</p><p>操作步骤：</p><pre><code>在源手机上安装SMS Backup &amp; Restore，点击“开始”。
授权所需权限，点击“允许”。
点击菜单图标 &gt; 传输 &gt; 从此手机发送，并授权附近设备访问。
在目标手机上重复相同步骤，但选择“在此手机上接收”。
在源手机上选择目标设备，在目标手机上点击“接受”。
在源手机上选择“传输短信和通话记录 &gt; 传输”。
在目标手机上点击“接受并恢复”完成过程。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432399" alt="图片" title="图片" loading="lazy"/></p><p>总结</p><p>在将短信从iQOO传输到iQOO时，选择合适的工具至关重要。在众多可选方案中，iReaShare Phone Transfer 是最出色的解决方案。它的一键传输、高成功率以及快速安全地迁移短信的能力，使其脱颖而出。立即免费获取并试用！<br/>​</p>]]></description></item><item>    <title><![CDATA[实战分享：如何用数字孪生IOC打造国防航]]></title>    <link>https://segmentfault.com/a/1190000047432408</link>    <guid>https://segmentfault.com/a/1190000047432408</guid>    <pubDate>2025-11-27 15:05:18</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>作为一名数字孪生应用开发者，我深知在国防航天这类高精尖领域，构建一个高效、可靠的智能运营中心（IOC）有多么重要。过去，我们常常面临数据孤岛、系统响应慢、应急指挥效率低等问题。直到我们团队引入了“孪易 数字孪生IOC ”，这些问题才迎刃而解。今天，我想和大家分享一些实际使用中的技巧，希望能帮助同行们少走弯路，快速上手这个强大的工具。</p><h2>一、数据集成：让多元数据“活”起来</h2><p>国防航天项目通常涉及海量数据，包括传感器数据、卫星图像、实时视频流等。传统方式下，这些数据往往分散在不同系统中，难以统一管理和分析。孪易IOC 的数据集成能力让我们眼前一亮。</p><h3>使用技巧：分层接入，实时同步</h3><p>我们采用分层策略接入数据：底层通过MQTT协议连接物联网设备，中层通过API接口整合业务数据库，上层则接入实时视频流（如RTSP/HLS）。这样一来，数据不仅能实时同步，还能在三维场景中直观展示。例如，在模拟卫星发射任务时，我们将火箭的遥测数据与三维模型绑定，实现了发射全过程的动态监控。<br/><strong>价值点</strong>：这种“多元数据，轻松接入”的设计，不仅减少了开发时间，还确保了数据的实时性和准确性。对于国防航天这种对时效性要求极高的领域，这意味着我们能更快地响应突发情况。</p><h2>二、场景构建：低成本打造高逼真三维环境</h2><p>国防航天场景通常复杂且宏大，如发射场、太空站等。过去，构建这类场景需要高昂的建模成本和专业的技术团队。孪易IOC 的场景构建工具让我们看到了转机。</p><h3>使用技巧：双渲染模式灵活切换</h3><p>我们根据项目需求灵活选择“端渲染”或“流渲染”模式。对于内部高精度演示，我们使用端渲染以获取电影级视觉效果；对于多用户协同场景，则采用流渲染以保证流畅性。例如，在构建某航天发射中心数字孪生时，我们先用端渲染制作细节模型，再通过流渲染实现多部门协同演练。<br/><strong>价值点</strong>：这种灵活性大幅降低了场景构建的门槛。即使团队中没有专业的3D建模师，也能通过导入常见的BIM/GIS数据快速搭建高质量场景。</p><h2>三、时空分析：从“看数据”到“用数据”的飞跃</h2><p>在国防航天领域，单纯的数据展示远远不够，我们更需要深度分析能力来支持决策。孪易IOC 的时空分析工具正好满足了这一需求。</p><h3>使用技巧：结合业务场景定制分析模型</h3><p>我们最喜欢的是它的可视域分析和通视分析功能。在部署地面监测系统时，我们通过可视域分析快速确定了雷达站的最佳布点位置；在太空碎片监测项目中，利用通视分析模拟了不同轨道位置的观测范围。这些分析结果直接转化为部署方案，节省了大量实地勘测成本。<br/><strong>价值点</strong>：将专业的空间分析能力与业务数据结合，让数据分析从“展示”升级为“研判”，真正实现了数据驱动的科学决策。</p><h2>四、应急指挥：构建跨部门协同作战能力</h2><p>国防航天领域的突发事件处理往往涉及多个部门和复杂流程。传统的指挥系统响应慢、协同难，而孪易IOC 的应急指挥模块彻底改变了这一局面。</p><h3>使用技巧：预案可视化+任务自动化</h3><p>我们将应急预案数字化，通过拖拽方式配置处置流程。当突发事件发生时，系统能自动触发相应预案，分派任务给相关责任人，并实时跟踪处置进度。在一次模拟太空碎片撞击预警演练中，这套系统帮助我们在5分钟内就完成了从预警发布到应急方案启动的全过程。<br/><strong>价值点</strong>：这不仅提升了应急响应速度，更重要的是建立了标准化、可视化的指挥流程，确保在高压环境下也能有序运作。<br/><img width="640" height="314" referrerpolicy="no-referrer" src="/img/bVdmQxT" alt="" title=""/></p><h2>五、历史回放：让运营复盘有据可依</h2><p>“历史不会重演，但会惊人地相似。”在国防航天这种高风险的领域，事故复盘和经验总结至关重要。孪易IOC的历史回放功能让我们实现了“时间倒流”式的分析。</p><h3>使用技巧：多维度数据关联回放</h3><p>我们不仅回放场景状态变化，还将设备运行数据、人员操作记录、环境参数等关联起来进行综合分析。在一次发射任务复盘时，我们通过回放发现了某个传感器数据异常与操作时序的关联性，为后续流程优化提供了重要依据。<br/><strong>价值点</strong>：这种全方位的回放分析，让我们能够深入挖掘事件背后的规律，将经验教训转化为改进措施，持续提升运营水平。</p><h2>开发心得：两种模式应对不同需求</h2><p>作为开发者，我最欣赏的是孪易IOC 提供的两种开发模式。对于常规功能，我们使用零代码配置快速实现；对于特殊需求，则通过低代码编程深度定制。这种灵活性让我们既能快速交付项目，又能满足客户的个性化需求。</p><h3>使用技巧：先用零代码搭建原型，再用低代码完善细节</h3><p>我们通常会先用零代码模式快速搭建系统原型，让客户直观感受效果。获得反馈后，再针对特定功能使用低代码进行精细化开发。这种“先快后精”的开发节奏，大大提升了客户满意度。</p><h2>结语</h2><p>经过多个项目的实践验证，孪易IOC 已经成为了我们团队在国防航天领域的“标配”工具。它不仅能帮助我们快速构建功能完善的数字孪生系统，更重要的是，它赋予了我们随着业务发展而持续迭代的能力。<br/>在这个技术快速迭代的时代，选择一个既能满足当前需求，又具备长远发展潜力的平台至关重要。孪易IOC 正是这样一个值得信赖的伙伴。</p>]]></description></item><item>    <title><![CDATA[京东云海存储成为全球最大规模基于国产CP]]></title>    <link>https://segmentfault.com/a/1190000047432413</link>    <guid>https://segmentfault.com/a/1190000047432413</guid>    <pubDate>2025-11-27 15:04:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>近日，在全球最权威的存储系统性能评测IO500榜单上，京东云海跻身榜单全球前四、国产自研第一。由此，<strong>京东云海存储成为全球最大规模基于国产CPU的AI存储技术应用</strong>，也是目前全球性能最强的基于通用NVMe架构的AI存储。</p><h3><strong>一、极致存储性能，斩获多项全球第一</strong></h3><p>基于通用 NVMe 盘存储服务器，结合全栈自研软件体系与深度调优，此次云海 AI 存储斩获了多项 “全球第一”：</p><p>首先，<strong>通用硬件性能第一</strong>，不使用 PMEM 硬件加速，完全基于通用 NVMe SSD 设备，跑出全球领先成绩；</p><p>其次，<strong>性能成本比第一</strong>，以更低硬件成本实现接近持久内存架构的性能表现。</p><p>第三，<strong>可规模化落地第一</strong>，架构具备高度可复制性，可在智算/超算等大规模存储场景中快速部署。</p><p>在排行榜单上的优秀成绩，源于京东云十多年在存储领域的技术积累。作为京东云自主研发的面向AI大模型需求的新一代分布式存储系统，历经京东618、京东11.11大规模实践验证，基于存算分离架构，可以很好满足智算场景极致的存储性能需求。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432415" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><p>在极致性能方面，云海AI存储可支持千亿级参数AI大模型，自研引擎采用全追加写模型，融合超低延时RDMA网络及软件架构优化，4K随机写IOPS达到1000万级，平均延迟在100微秒级，I/O性能接近本地NVMe磁盘，单节点可提供 44GiB/s的带宽性能。</p><p>云海为京东云全自研存储，代码自研率超98%，拥有完全自主知识产权，与主流国产化硬件和软件兼容互认，括操作系统、数据库、中间件、服务器、CPU、主板、网卡、SSD等，并基于全局无锁架构，充分发挥国产硬件能力。</p><h3><strong>二、超100家大型企业选择云海AI存储，加速AI落地产业</strong></h3><p>目前，来自银行、证券、汽车、零售等领域超100家大型企业，正在使用云海AI存储。</p><p>在科技领域，<strong>科大讯飞</strong>AI营销采用“开源分布式存储软件+服务器硬件”搭建，对十亿级小文件数据量时，读写性能陡然下降。升级京东云AI存储云海后，科大讯飞AI营销实现了一个集群一个文件系统，即可轻松应对多模态大模型时千亿\~十万亿参数规模；同时，基于高性能存储层，以及大容量存储层的自动数据分级，在大幅降低存储成本的同时，实现了大模型训练能力的大幅提升，助力AI营销业务降本增效。</p><p>在互联网领域，<strong>墨迹天气</strong>是全球领先的气象服务企业，截至2024年，拥有超过7亿用户，天气日查询次数过6亿次。随着业务规模的扩大，墨迹天气越来越多的数据需要在降本增效的目标下进行安全的存储。墨迹天气与京东云云海共同建设新的分布式存储，采用低冗余存储的技术，在不降低性能和可靠性的情况下，只需要1.14个副本，大幅提升资源利用率。</p><p>在金融领域，<strong>国内某头部证券公司</strong>传统存储系统在性能、稳定性和故障恢复等方面存在诸多痛点，面临着系统架构整体国产化升级的迫切需求。京东云云海采用多台鲲鹏和海光CPU架构存储一体机搭建分布式存储集群，全面适配国产化系统及虚拟化平台。这一方案不仅满足了该证券公司的国产化需求，还通过提供POSIX、NFS、CIFS、S3等存储协议，支持块、文件和对象存储，实现了一个存储平台满足多种场景需求，提升了信息安全自主可控能力。</p><p>面向未来，京东云将持续投入自研存储系统的深度优化，推动高性能存储在 AI 模型训练、科学计算、大规模数据分析等场景中的更广泛应用，助力更多企业重塑AI生产力。</p>]]></description></item><item>    <title><![CDATA[如何优化汽车制造系统以提高生产效率和质量]]></title>    <link>https://segmentfault.com/a/1190000047432416</link>    <guid>https://segmentfault.com/a/1190000047432416</guid>    <pubDate>2025-11-27 15:03:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在工业4.0与智能制造不断深化的今天，汽车制造系统正经历一场前所未有的数字化转型。作为现代工业体系的重要组成部分，汽车制造系统不仅需要应对高度复杂的生产流程，还要满足日益增长的个性化定制与效率提升需求。在这一背景下，MES系统（制造执行系统）逐渐成为汽车制造系统升级的核心驱动力，而广域铭岛凭借其Geega MES系统与工业智造超级智能体技术，为这一领域注入了全新的活力。<br/>汽车制造系统的复杂性体现在其多环节、高精度的生产链中——从冲压、焊接、涂装到总装，每一环节都需实现无缝协同。传统模式下，信息孤岛与数据滞后问题严重制约了汽车制造系统的响应速度与质量控制能力。然而，随着广域铭岛等企业推出深度融合AI技术的MES系统，汽车制造系统开始从“经验驱动”转向“数据驱动”。例如，广域铭岛的Geega MES系统通过实时数据采集与动态分析，能够提前解析订单需求、优化资源调度，并实现生产全流程的透明化管理，极大提升了汽车制造系统的柔性与效率。<br/>在质量管控层面，汽车制造系统对一致性与可靠性的要求极为严苛。广域铭岛的解决方案通过构建全流程质量追溯机制，将每一个焊点参数、涂装工艺数据实时记录并分析，使得质量问题可追溯至具体工位、操作人员甚至零部件批次。这种毫秒级的数据响应能力，不仅显著降低了汽车制造系统中的质量风险，也为持续优化提供了扎实的数据基础。某汽车企业采用广域铭岛系统后，成功将重大质量事故率降低72%，印证了智能系统在现代汽车制造系统中的核心价值。<br/>供应链协同是汽车制造系统中另一关键挑战。广域铭岛通过将MES系统与供应商管理平台（SRM）无缝集成，实现了物料状态的动态追踪与智能预警。当某一零部件库存接近临界值时，系统能够自动触发补货机制并同步调整生产计划，从而将传统制造中常见的“停工待料”问题极大缓解。这种端到端的协同能力，进一步强化了汽车制造系统在复杂市场环境中的适应性与竞争力。<br/>展望未来，随着人工智能、物联网和数字孪生技术的不断演进，汽车制造系统将呈现出更显著的智能化、云端化与生态化特征。广域铭岛所倡导的“工业智造超级智能体”正代表这一方向——其不再将AI视为外挂工具，而是作为嵌入制造网络每一个节点的核心能力，推动汽车制造系统实现从预测性维护到全数质检的全面升级。在这样一个动态循环、持续优化的框架下，汽车制造系统不仅成为企业提质增效的基石，更演变为驱动行业创新的关键力量。<br/>综上所述，汽车制造系统的演进离不开数字化技术的深度融合与前瞻性实践。广域铭岛通过Geega MES系统及超级智能体架构，为汽车制造系统提供了从数据采集到决策优化的一体化解决方案，不仅重新定义了生产效率与质量控制的标准，也为整个制造业的数字化转型树立了重要标杆。在智能制造的浪潮中，汽车制造系统与像广域铭岛这样的技术推动者，必将共同书写工业未来的新篇章。</p>]]></description></item><item>    <title><![CDATA[当城市装上"数字大脑"：看数字孪生如何重]]></title>    <link>https://segmentfault.com/a/1190000047432419</link>    <guid>https://segmentfault.com/a/1190000047432419</guid>    <pubDate>2025-11-27 15:02:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>清晨7点，城市交通早高峰如期而至。在某个城市的指挥中心大屏上，整座城市的运行状态以三维立体的形式实时呈现：主干道的车流如血液般奔涌，地铁线路如神经网络般闪烁，重点区域的安防监控如敏锐的眼睛般警惕。这不是科幻电影的场景，而是数字孪生技术在城市治理中的真实应用。</p><h2>一、从"经验决策"到"数据驱动"的治理变革</h2><p>传统城市治理往往依赖于管理者的经验和分散的数据报表。当突发事件发生时，各部门信息不通、决策滞后的问题时有发生。数字孪生技术—“图观”流渲染平台的引入，正在彻底改变这一局面。<br/><strong>实战案例：特大城市的防汛应急指挥</strong><br/>去年汛期，某沿江特大城市的防汛指挥系统经历了一次严峻考验。通过数字孪生平台，指挥人员不仅能看到实时水位数据，还能在三维场景中模拟不同降雨量下的淹没范围，预判风险区域。系统自动关联气象、水文、交通等多源数据，为人员疏散、物资调配提供了精准的决策支持。<br/>"以前我们主要靠经验和二维图纸做决策，现在通过这个'数字大脑'，能直观看到洪水可能影响的每一个小区、每一条道路，指挥调度更加有的放矢。"该市应急管理局负责人如此评价。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdmUPX" alt="" title=""/></p><h2>二、打破"信息孤岛"，实现跨部门协同治理</h2><p>城市治理涉及数十个部门，数据壁垒一直是制约治理效能的瓶颈。“图观”流渲染数字孪生平台通过统一的数据标准和可视化呈现，让各部门在同一个"数字战场"上协同作战。<br/><strong>实战案例：智慧城管的多部门联动</strong><br/>在某省会城市的智慧城管项目中，数字孪生平台接入了城管、公安、环保、市政等28个部门的业务数据。当发现违章建筑时，系统不仅能自动识别定位，还能关联查询业主信息、规划许可、周边环境等多维度数据，为综合执法提供完整依据。<br/>更值得一提的是，平台提供的零代码工具让各部门业务人员都能自主配置监控指标和预警规则。城管队员通过平板电脑就能实时查看管区情况，环保人员可以监控空气质量变化，这种低门槛的使用方式大大提升了系统的实用性。</p><h2>三、从"被动响应"到"主动预警"的治理升级</h2><p>数字孪生技术的核心价值不仅在于现状的可视化，更在于其预测预警能力。通过对海量数据的智能分析，系统能够提前发现潜在风险，实现治理关口前移。<br/><strong>实战案例：基础设施智能运维</strong><br/>在某经济特区，“图观”流渲染数字孪生平台接入了超过5万个物联网传感器，对城市基础设施进行全天候监测。系统通过AI算法分析桥梁振动数据、管廊变形趋势等，实现了从"故障修"到"预防修"的转变。<br/>"去年我们成功预警了3起重大安全隐患，平均提前预警时间达到48小时以上。"该项目技术负责人介绍，"这不仅避免了可能发生的事故，还将维修成本降低了40%。"<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdmR7m" alt="" title="" loading="lazy"/></p><h2>四、让技术"普惠化"，加速智慧城市落地</h2><p>技术的生命力在于普及。数字孪生平台通过提供从零代码到低代码的完整工具链，让不同技术背景的使用者都能快速上手。<br/>在多个成功案例中，我们看到：<br/>1.社区网格员通过简单培训就能使用系统巡查辖区<br/>2.交通管理员可以自主配置重点路段的监控方案<br/>3.环保监察人员能够实时查看污染源分布<br/>这种"技术普惠"的理念，使得数字孪生不再是高高在上的黑科技，而是真正服务于基层治理的实用工具。</p><h2>展望：数字孪生开启城市治理新纪元</h2><p>随着案例的积累和技术的成熟，数字孪生正在从单个场景应用向城市级平台演进。未来的"城市数字大脑"将不仅能够实时感知城市运行状态，还能通过仿真推演，为城市规划、应急管理、公共服务提供更科学的决策支持。<br/><strong>数字孪生不仅是一项技术革新，更是一场治理革命</strong>。 它让城市治理变得更加：<br/><strong>精准化</strong>：基于真实数据的决策取代经验判断<br/><strong>协同化</strong>：打破部门壁垒实现整体治理<br/><strong>前瞻化</strong>：从事后处置转向事前预防<br/><strong>民主化</strong>：让技术惠及更多治理参与者<br/>在这个数字化浪潮奔涌的时代，城市治理正在经历一场深刻的变革。数字孪生技术如同给城市装上了"智慧大脑"，让治理更科学、服务更精准、城市更美好。期待更多城市能够把握这一机遇，共同描绘智慧城市的新蓝图。</p>]]></description></item><item>    <title><![CDATA[深入理解分布式共识算法 Raft 京东云]]></title>    <link>https://segmentfault.com/a/1190000047432421</link>    <guid>https://segmentfault.com/a/1190000047432421</guid>    <pubDate>2025-11-27 15:02:26</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>“不可靠的网络”、“不稳定的时钟”和“节点的故障”都是在分布式系统中常见的问题，在文章开始前，我们先来看一下：如果在分布式系统中网络不可靠会发生什么样的问题。</p><p>有以下 3 个服务构成的分布式集群，并在 server\_1 中发生写请求变更 A = 1，“正常情况下” server\_1 将 A 值同步给 server\_2 和 server\_3，保证集群的数据一致性：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432423" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><p>但是如果在数据变更时发生网络问题（延迟、断连和丢包等）便会出现以下情况：比如有两个写操作同时发生在 server\_1 或 server\_3 上，即便两个写操作有先后顺序，但可能由于网络延时导致各个服务中数据的不一致：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432424" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>同样地情况，如果在 server\_1 上发生三次写操作，在数据同步的过程中因为网络延时或网络丢包也可能会导致数据的不一致：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432425" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>那么为了避免以上这些集群间数据不一致的问题，便需要分布式共识算法来协调。分布式共识算法简单来说就是如何在多个服务器间对某一个值达成一致，并且当达成一致之后，无论之后这些机器间发生怎样的故障，这个值能保持不变。本篇文章我们便对 Raft 算法进行介绍。</p><h3>理解 Raft 算法</h3><p>了解和学习过 Zookeeper 的同学可能听说过 Zab 算法，它用来保证 Zookeeper 中数据的 <strong>顺序一致性</strong>。Raft 也是一种分布式共识算法，它易于理解和实现，用于保证数据的 <strong>线性一致性</strong>，是最强一致性模型。</p><p>在遵循 Raft 算法的集群中，节点会有 3 种不同的角色。当集群在初始化时，每个节点的角色都是 Follower 跟随者，它们会等待来自 Leader 节点的心跳。因为此时并没有 Leader 节点，所以会等待心跳超时。等待超时的 Follower 节点会将角色转变为 Candidate 候选者，触发一次选举，触发选举时会标记 Term 任期变量，并将自己的一票投给自己，通知其他 Follower 节点发起投票。经过投票后，收到超过半数节点票数的 Candidate 节点会成为 Leader 领导者节点，其他节点为 Follower 跟随者节点，Leader 节点会不断地发送心跳给 Follower 节点来维持领导地位：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432426" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>如果每个节点每次在触发选举时都是同时超时，这样是不是导致不能完成一次选举，产生 <strong>“活锁”</strong> 问题？的确可能，不过活锁问题也很好解决：即节点超时时间在合理的范围内取随机值，这样由于它的随机性就不太可能再同时发起竞选了，这个时候其他节点便有足够的时间向其他节点索要选票。</p><h4>写变更请求</h4><p>当发生写变更请求时，由 Leader 节点负责处理，即使是请求到 Follower 节点，也需要转发给 Leader 节点处理。当 Leader 节点接收到写请求时，它并不立即对这个请求进行处理，而是先将请求信息 <strong>按顺序追加到日志文件中（WAL: write-ahead-log）</strong> ，如图中标记的 log\_index 表示追加到的最新一条日志的序号：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432427" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>在这个过程中，<strong>日志必须持久化存储</strong>。随后，Leader 节点通过 RPC 请求将日志同步到各个 Follower 节点，当超过半数节点成功将日志记录时，便认为同步成功。在这里可知 Raft 算法采用的是单主复制的模型，所以它也就会存在以下缺点：</p><ol><li>面对大量写请求负载时系统比较难扩展，因为系统只有一个主节点，写请求的性能瓶颈由单个节点决定</li><li>当主节点宕机时，从节点提升为主节点不是即时的，可能会造成一些停机时间</li></ol><p>随后，Leader 节点会更新最新同步日志的索引 commit\_index 为 1，并通过心跳下发给各个 Follower 节点：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432428" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>在这个过程中可以发现 Follower 节点只是听从并响应 Leader 节点，没有任何主动性。现在，已经完成了日志在集群间的同步，但是请求对变量 A 的修改还没有被应用（Apply）。Apply 是在 Raft 算法中经常出现的一个名词，在多数与 Raft 算法相关的文章中经常会看到 “将已提交的日志条目应用到状态机” 等类似的表述。其实 “状态机” 理解起来并不复杂，通俗的理解是 <strong>业务逻辑的载体</strong> 或 <strong>业务逻辑的执行者</strong>，它的职责包括：</p><ol><li>接收来自日志文件中有序的命令</li><li>执行具体的业务逻辑，在本次写请求中，业务逻辑指的便是变更 A 的值</li><li>变更应用程序的状态</li><li>返回执行结果</li></ol><p>更加通俗的讲就是 <strong>让请求生效</strong>。将已经提交的日志应用到状态机是比较简单且自主的过程，各个服务实例会记录 apply\_index 来标记应用索引，当 apply\_index 小于 commit\_index 时，那么证明日志文件中记录的请求信息还有部分没生效，所以需要按顺序应用，直到 apply\_index = commit\_index：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047432429" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>在这个过程中，我一直在强调 <strong>“按顺序”</strong> ，不论是日志的追加还是日志的被应用都是按顺序来的，因此才能保证数据的线性一致性。</p><h4>读请求</h4><p>Raft 集群处理读请求会保证读请求的线性一致性，所谓线性一致性读就是在 t1 的时间写入了一个值，那么在 t1 之后，读一定能读到这个值，不可能读到 t1 之前的值，在 Raft 算法中实现线性一致性读有以下两种方式：</p><h5>ReadIndex Read</h5><p>在这种方式下，当 Leader 节点处理读请求时：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432430" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><ol><li>首先将 commit\_index 记录到本地的 read\_index 变量里</li><li>向其他节点发送一次 Heartbeat，确认自己仍然是 Leader 角色</li><li>Leader 节点等待自己的状态机执行，直到 apply\_index 超过了 read\_index，这样就能够安全的提供线性一致性读了</li><li>Leader 执行 read 请求，将结果返回</li></ol><p>在第三步中，保证 <code>apply_index &gt;= read_index</code> 是为了保证所有小于等于 <code>read_index</code> 的请求都已经生效。</p><p>如果是 Follower 节点处理读请求也和以上过程类似，当 Follower 节点收到读请求后，直接给 Leader 发送一个获取此时 read\_index 的请求，Leader 节点仍然处理以上流程然后将 read\_index 返回，此时 Follower 节点等到当前的状态机 apply\_index 超过 read\_index 后，就可以返回结果了。</p><h5>Lease Read</h5><p>因为 ReadIndex Read 需要发送一次 Heartbeat 来确认 Leader 身份，存在 RPC 请求的开销，为了进一步优化，便可以采用租约（Lease）读。租约其实指的是 Leader 节点身份的过期约定时间，所以这种读请求只针对 Leader 节点，Follower 节点没有租约的概念，它通过以下公式计算：</p><p><code>lease_end = current_time() + election_timeout / clock_drift_bound</code></p><p>其中 election\_timeout 为选举的超时时间，clock\_drift\_bound 表示时钟漂移，指的是在分布式系统中，两个或多个节点上的时钟以不同的速率运行，导致它们之间的时间差随时间不断累积和变化（也就是分布式系统中不稳定的时钟问题）。</p><p>举个简单的例子，假如选举过期时间是 10s，时钟漂移为 1.1，那么租约过期时间为：lease\_end = current\_time() + 10s / 1.1 ≈ current\_time() + 9s，如果在处理读请求时，在租约时间内，则无需发送 Heartbeat 来明确 Leader 身份，直接等待 apply\_index &gt;= commit\_index 后返回请求结果。</p><hr/><p>在以上读写流程中，Raft 分布式共识算法能让每个节点对日志的值和顺序达成共识，每个节点都存储相同的日志副本，使整个系统中的每个节点都能有一致的状态和输出，使得这些节点看起来就像一个单独的，高可用的状态机。在上文中我们提到过 Zookeeper 使用的 Zab 共识算法保证的是顺序一致性，Raft 算法保证的是线性一致性，所以借着这个引子也来谈谈我对一致性的理解。</p><h4>一致性</h4><p><strong>一致性</strong> 通常指的就是数据一致性，在分布式系统中的读写请求，表现得像在单机系统上一样，符合直觉和预期。一致性模型有很多种，在这里我们只谈以下常见的几种：</p><p><strong>线性一致性</strong> 是最强的一致性模型，也被称为强一致性，在 CAP 定理中的 C 表达的一致性含义便是线性一致性。这种一致性模型要求系统要像单一节点一样工作，并且所有操作是原子的，它有两个约束条件：</p><ol><li>顺序记录中的任何一次读必须读到最近一次写入的数据</li><li>顺序记录要跟全局时钟下的顺序保持一致</li></ol><p><strong>顺序一致性</strong> 要比线性一致性弱，它只要求 <strong>同一客户端或进程的操作在排序后保持先后顺序不变</strong>，但 <strong>不同客户端之间的先后顺序是可以任意改变的</strong>，顺序一致性与线性一致性的主要区别在于 <strong>没有全局时间的限制</strong>。比如在社交网络场景下，一个人通常不关注他看到的所有朋友的帖子的顺序，但是对于某个具体朋友，仍然以正确的顺序显示帖子的顺序。</p><p><strong>因果一致性</strong> 则是比 <strong>顺序一致性</strong> 更弱的一致性模型，因果一致性要求必须以相同的顺序看到因果相关的操作，而没有因果关系的并发操作可以被不同的进程以不同的顺序观察到。典型的例子就是社交网络中发帖和评论的关系：必须先有发帖才能对该帖子进行评论，所以发帖操作必须在评论操作之前。</p><p><strong>最终一致性</strong> 是常见的最弱的一致性模型，所谓最终表达的含义是“对于系统到达稳定状态并没有硬性要求”，即便这听起来很不靠谱，但是在业务中被应用的很多也很好，而且这种一致性模型能使系统的性能很高。</p><blockquote>CAP 定理：C 代表一致性，当客户端访问所有节点时，返回的都是同一份最新的数据；A 代表可用性，指每次请求都能获取到非错误的响应，但不保证获取的数据是最新的；P 代表分区容错性，节点之间由于网络分区而导致消息丢失的情况下，系统仍能正常运行。</blockquote><p>接下来我们再来谈谈脑裂问题：</p><h4>脑裂问题</h4><p>当集群中发生网络通讯问题时，读、写请求只能在超过半数节点的集群内生效，<strong>过半数机制</strong> 在数学上保证不可能同时存在两个Leader：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432431" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>除此之外还有以下机制来避免脑裂问题：</p><ol><li><strong>Term机制</strong>：时间上保证旧Leader会自动让位给新Leader</li><li><strong>主动stepDown</strong>：Leader无法联系到过半数节点时主动放弃领导权</li><li><strong>严格的投票规则</strong>：每个term每个节点只能投票给一个候选人</li></ol><p>当网络问题恢复时，Follower 节点能通过 Leader 节点的日志同步重新追回期间错过的数据。此外，一般采用 Raft 算法的集群在部署的时都是 <strong>“奇数个节点”</strong> ，而不是偶数个节点，这其实是数学的体现，性价比更高：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432432" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>如上图所示，虽然部署 4 个节点多出一个节点，但是和 3 节点集群相比，容错能力是相同的：只能容忍 1 个节点故障。在容错能力没有被提高的情况下又花费了更多的服务器成本和运维管理成本。</p><hr/><p>以上我们基本了解了 Raft 算法的内容，如果想使用 Raft 算法，对系统模型有以下要求：</p><ol><li>服务可能宕机、停止运行，但过段时间能够恢复，但不能存在 <strong>拜占庭故障</strong></li><li>消息可能丢失、延迟乱序或重复；可能有网络分区，并在一段时间之后恢复</li></ol><hr/><h3>巨人的肩膀</h3><ul><li><a href="https://link.segmentfault.com/?enc=0lnK0ln%2BUxRFrAsTyEuZig%3D%3D.LOQiAVq93WnSoEIKbhdJ8brkIPdpRgEBGoiKsrnDpheA0qO84%2FI%2FOrecNnh3zqtKUYj2S%2F8v%2B8qIPtmyYuCDXg%3D%3D" rel="nofollow" target="_blank">SOFAJRaft</a></li><li><a href="https://link.segmentfault.com/?enc=mJXwfGbnt3lUDtDEZDtcwA%3D%3D.CDqp2E2s4L3Xeh71injLIogFQgbTGjueEOgjZ0XENRc%3D" rel="nofollow" target="_blank">The Raft Consensus Algorithm</a></li><li><a href="https://link.segmentfault.com/?enc=Y9pgm3M9GKHrshcCxviN8w%3D%3D.W%2B%2BpBm5dhOqEwiBGuhMaTZbHNEjuepIWsYhjLAfACEgyQp%2B3UT8vEiZrgRGTh6Uo" rel="nofollow" target="_blank">TiKV 功能介绍 – Lease Read</a></li><li>《深入理解分布式系统》</li></ul>]]></description></item><item>    <title><![CDATA[【本不该故障系列】告别资源“不确定性”，]]></title>    <link>https://segmentfault.com/a/1190000047432435</link>    <guid>https://segmentfault.com/a/1190000047432435</guid>    <pubDate>2025-11-27 15:01:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>作者：娜米</p><p>资源的刚性交付，不是云上天生就具备的能力。当选择自建或自管理一个 Kubernetes/ECS 资源池时，就必须直面一个残酷的现实：所依赖的底层 IaaS 资源本身就是非刚性的。</p><p>阿里云上 ECS 有多代实例规格（如 g6、c7i、r8y 等），基于 Intel、AMD 及自研倚天 ARM 芯片，但这并不保证在任何时刻、任何地域、任何可用区，所需要的那款机型就一定有库存。这种底层资源的“不确定性”，会像幽灵一样渗透到自建的上层系统中。</p><p>刚性交付的本质，是将“不确定性”从系统中排除的关键机制。它通过可控的资源成本，换取了业务的稳定性、高性能和可预测性。 对于任何严肃的线上业务而言，这种确定性并非锦上添花，而是维系其商业信誉和核心价值的生命线。</p><p>以下几个案例，阐述非刚性交付”带来的典型困境。</p><h2>案例一：游戏行业 —— 新品发布日的“容量灾难”</h2><ul><li>行业：在线游戏、元宇宙</li><li><p>故障：</p><ol><li>场景：一家游戏公司万众期待的新游戏正式公测。运营团队基于压测，制定了雄心勃勃的扩容计划，需要在开服瞬间将游戏服务器（通常需要高性能计算或 GPU 优化的特定 ECS 机型）的规模扩大 10 倍。他们管理着一个基于 K8s 的自建集群。</li><li>触发：开服铃声敲响，CI/CD 流水线触发了大规模的横向扩容。然而，K8s 的节点自动伸缩器 Cluster Autoscaler 在向阿里云申请创建新的 ECS 节点时，API 返回了“Insufficient stock”库存不足的错误。他们所依赖的特定高性能机型，在该可用区已无库存。</li><li>现象：应用的 Pod 因为没有足够的节点资源而大量处于<code>Pending</code>状态，无法被调度。新玩家的登录请求雪片般涌入，但服务器容量远未达到预期。</li></ol></li><li><p>业务影响：</p><ul><li>上线即失败：大量玩家无法登录，游戏入口处大排长龙，社交媒体和游戏社区瞬间被负面评价淹没，精心策划的发布会变成了公关灾难。</li><li>真金白银的损失：高额的市场推广费用付诸东流，首日充值流水远低于预期。</li><li>玩家永久流失：糟糕的首日体验会导致大量核心玩家永久流失至竞品。</li></ul></li></ul><h2>案例二：电商行业 —— 大促活动中的“性能悬崖”</h2><ul><li>行业：电商与在线零售</li><li><p>故障：</p><ol><li>场景：一家电商平台为了应对大促，提前“预留”了大量 ECS 节点。为了“提高资源利用率”，他们在核心的交易应用 Pod 所在的节点上，混部了一些非核心的数据分析和日志处理 Pod，并配置了非刚性的 CPU 交付。</li><li>触发：大促零点开启，交易量飙升，交易应用需要全部申请的 CPU。同时，数据分析任务也开始高强度运行，抢占 CPU 资源。</li><li>现象：交易应用的实际可用 CPU 被严重挤压，响应时间急剧恶化，大量请求超时。</li></ol></li><li><p>业务影响：</p><ul><li>订单大量流失：支付和下单环节的堵塞，直接导致 GMV 损失。</li><li>品牌信誉受损：用户在关键时刻掉链子，严重损害品牌可靠性。</li></ul></li></ul><h2>案例三：金融科技行业 —— 交易时段的“随机掉线”</h2><ul><li>行业：金融科技 (FinTech)，尤其是证券交易</li><li><p>故障：</p><ol><li>场景：一个核心的行情推送 Java 服务，以内存非刚性交付的方式运行在一个自管理的 K8s 集群上。</li><li>触发：交易时段，订阅量激增，服务实际内存使用远超其申请值。此时节点内存压力增大，触发 OOM Killer。</li><li>现象：行情服务 Pod 被系统判定为“劣质进程”而随机杀死，导致客户端行情刷新中断。</li></ol></li><li><p>业务影响：</p><ul><li>交易决策失误：用户因行情中断而做出错误决策或错失交易时机，造成直接经济损失。</li><li>合规与监管风险：核心系统频繁中断，可能触犯金融行业的高可用性监管要求。</li></ul></li></ul><h2>案例四：企业软件行业 —— 核心 ERP 系统的“性能抽奖”</h2><ul><li>行业：企业软件 (ERP, CRM)，尤其是大型单体应用</li><li><p>故障：</p><ol><li>场景：一家企业将其庞大的、无法轻易水平扩展的单体 ERP 系统容器化后，部署在一个资源非刚性交付的自建集群上，以期“节约成本”。</li><li>触发：在月末财务结算等高峰期，ERP 系统需要大量 CPU 和内存。但它必须和节点上其他应用“共享”资源。</li><li>现象：ERP 系统的性能变得极不稳定，时快时慢，如同“抽奖”。有时一个报表生成需要 2 分钟，有时需要 20 分钟。</li></ol></li><li><p>业务影响：</p><ul><li>工作效率低下：员工的核心工作流程被频繁打断，财务、供应链等部门的月末结算工作无法按时完成。</li><li>决策延迟：管理者无法及时获取准确的业务报表，影响了商业决策的时效性。</li></ul></li></ul><h2>资源刚性交付困境</h2><h3>资源供给的不确定性</h3><p>困境本质：“承诺的资源” ≠ “可即时获取的资源”。</p><ul><li>库存波动：热门规格 ECS，在大促或行业高峰期容易出现“秒光”，导致扩容失败。</li><li>区域/可用区差异：某些 AZ 因物理机房容量限制，无法提供特定资源类型，跨 AZ 调度又需额外网络与配置成本。</li><li>代际断层：旧代实例停售或库存枯竭，但应用尚未适配新架构，造成刚性承诺无法兑现。</li></ul><h3>性能隔离难以真正实现</h3><p>困境本质：“逻辑隔离”不等于“物理隔离”，刚性性能难以 100% 保障。</p><ul><li>虚拟化开销与干扰：即使使用 Cgroups、CPU 绑核等技术，共享 NUMA 节点、内存带宽、磁盘 I/O 队列仍可能被“嘈杂邻居”抢占。</li><li>突发流量冲击：同节点上其他租户突发高负载（如备份、扫描），导致本应“独占”的实例出现延迟毛刺。</li><li>存储性能抖动：存储在多租户争抢下 IOPS 和吞吐不稳定，影响核心业务等关键应用。</li></ul><h3>弹性与刚性的内在矛盾</h3><p>困境本质：刚性要求确定性，弹性依赖不确定性，二者天然张力。</p><ul><li>预占 vs 按需：为保障刚性需提前预留资源，但业务负载波动大时造成浪费；若完全按需，则无法应对突发高峰。</li><li>冷启动延迟：首次启动需拉镜像、初始化，往往无法满足业务的刚性响应要求。</li></ul><h3>异构资源管理复杂度高</h3><p>困境本质：“资源刚性”需端到端栈协同，任一环节短板即导致整体失效。</p><ul><li>专用硬件：驱动版本、CUDA 兼容性、拓扑感知调度、故障恢复机制各异，难以标准化交付。</li><li>混合架构支持难：x86 与 ARM（如倚天710）指令集不同，应用需重新编译测试，刚性交付需维护多套镜像与部署流程。</li><li>网络与存储耦合：高性能计算需 RDMA、NVMe over Fabric 等底层能力，但这些能力在虚拟化层常被削弱或不可用。</li></ul><h3>传统架构与云原生理念割裂</h3><p>困境本质：刚性交付不仅是技术问题，更是组织与认知转型问题。</p><ul><li>缺乏弹性设计：应用未做无状态改造，无法横向扩展，只能纵向升级（Scale-Up），而大规格实例更稀缺、更昂贵。</li><li>运维惯性阻力：企业习惯“买服务器、装系统、长期运行”，对“按需申请、用完即弃”的刚性交付模式接受度低。</li></ul><h3>成本模型与刚性目标冲突</h3><p>困境本质：财务约束常迫使技术理想向现实低头。</p><ul><li>刚性 = 高成本：独占物理机、专用集群、多AZ冗余等方案显著推高 TCO。</li><li>企业被迫妥协：为控制预算，用户常选择共享资源池+监控告警“事后补救”，而非事前刚性保障。</li><li>计费模式滞后：传统按小时计费无法匹配秒级弹性需求，导致“为不用的资源付费”或“关键时刻无资源可用”。</li></ul><h2>SAE 在刚性交付上做的工作</h2><p>作为阿里云面向应用层的全托管 Serverless PaaS 平台，针对资源刚性交付的系统性困境，从<strong>资源供给、性能隔离、弹性模型、异构调度、成本结构、容灾能力、可观测性与架构演进</strong>等多个维度进行了设计。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432437" alt="" title=""/></p><h3>1. 破解“资源供给不确定性” → 构建无限弹性资源池</h3><ul><li>多源异构资源整合：<br/>SAE 背后打通神龙裸金属服务器、弹性容器实例（ECI）支持各代  x86/ARM等海量资源，形成统一调度池。</li><li>智能跨机型调度：<br/>当用户指定规格库存不足时，调度器自动选择性能相当、兼容性一致的替代资源（如 g7 缺货 → 自动调度 g8i），全程对用户透明。</li><li>结果：<br/>交付的是“计算能力”，而非“特定机型”，彻底规避因库存波动导致的扩容失败。</li></ul><h3>2. 解决“性能隔离难” → 天然沙箱化 + 独占资源</h3><ul><li>默认运行在 ECI 沙箱中：<br/>每个应用实例运行在轻量级安全容器，实现内核级隔离，杜绝“嘈杂邻居”干扰。</li><li>资源 100% 独占：<br/>用户申请的 CPU、内存、网络带宽均由 runD 底层安全沙箱保障，无超分、无争抢，性能稳定可预期。</li><li>结果：<br/>刚性性能不再是“尽力而为”，而是确定性交付，尤其适合金融交易、实时推荐等敏感场景。</li></ul><h3>3. 调和“弹性与刚性矛盾” → 按实际用量计费 + 缩容至零</h3><ul><li>闲置不计费：<br/>应用缩容到 0 实例时，CPU/内存资源完全释放，不产生费用（仅保留配置元数据）。</li><li>秒级冷启动优化：<br/>结合镜像预热、快照加速、本地缓存等技术，大幅缩短首次启动延迟，逼近“即时刚性响应”。</li><li>结果：<br/>用户无需为“以防万一”长期预留资源，刚性保障与极致成本兼得，替代高风险混部策略。</li></ul><h3>4. 简化“异构资源管理” → 屏蔽底层复杂性</h3><ul><li>ARM/x86 无缝兼容：<br/>如支持海光国产芯片，用户只需提供兼容镜像，SAE 自动完成调度与运行时适配。</li><li>结果：<br/>开发者只需关注“我要多少算力”，无需关心“卡在哪台机器上、驱动是否匹配”。</li></ul><h3>5. 重构“成本模型” → 从“买资源”到“买能力”</h3><ul><li>按实际 CPU/内存使用量秒级计费：<br/>不再按整机小时付费，避免资源闲置浪费。</li><li>免运维成本：<br/>无需管理节点、打补丁、编写扩缩容脚本，人力成本大幅降低。</li><li>结果：<br/>刚性交付不再昂贵，中小企业也能享受企业级可靠性。</li></ul><h3>6. 强化“容灾与高可用” → 多可用区刚性容灾</h3><ul><li>一键开启多 AZ 部署：<br/>SAE 自动将应用实例分散到多个可用区，跨机房冗余。</li><li>AZ 故障自动恢复：<br/>若某 AZ 整体不可用，SAE 在其他 AZ 刚性拉起新实例，RTO控制在分钟级。</li><li>结果：<br/>刚性交付从“单点稳定”升级为“应用级连续性保障”。</li></ul><h3>7. 提升“可观测性与可信度” → 内置全链路监控</h3><ul><li>集成 ARMS + SLS + Prometheus：<br/>提供应用性能监控（APM）、日志、指标、链路追踪一体化视图。</li><li>资源使用透明化：<br/>用户可清晰看到 CPU 使用率、内存水位、网络吞吐是否达到承诺值。</li><li>结果：<br/>刚性 SLA 可验证、可审计，告别“黑盒交付”。</li></ul><h3>8. 支持“传统应用平滑演进” → 兼顾稳定与未来</h3><ul><li>支持 WAR/JAR/镜像直接部署：<br/>ERP、OA 等单体应用无需改造即可运行在 SAE 上，享受刚性资源保障。</li><li>内置诊断能力：<br/>通过性能剖析定位瓶颈（如数据库慢查询、线程阻塞），为后续微服务拆分提供数据依据。</li><li>结果：<br/>SAE 不仅是“运行平台”，更是企业云原生转型的跳板。</li></ul><h2>了解 Serverless 应用引擎 SAE</h2><p>阿里云 Serverless 应用引擎 SAE 是面向 AI 时代的一站式容器化应用托管平台，以“托底传统应用、加速 AI 创新”为核心理念。它简化运维、保障稳定、闲置特性降低 75% 成本，并通过 AI 智能助手提升运维效率。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047415441" alt="" title="" loading="lazy"/>面向 AI，SAE 集成 Dify 等主流框架，支持一键部署与弹性伸缩，在 Dify 场景中实现性能<strong>提升 50 倍、成本优化 30% 以上</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047415442" alt="" title="" loading="lazy"/></p><h3>产品优势</h3><p>凭借八年技术沉淀，SAE 入选 2025 年 Gartner 云原生魔力象限全球领导者，亚洲第一，助力企业零节点管理、专注业务创新。SAE 既是传统应用现代化的“托举平台”，也是 AI 应用规模化落地的“加速引擎”。</p><ol><li><strong>传统应用运维的“简、稳、省”优化之道</strong></li></ol><ul><li>简：零运维心智，专注业务创新</li><li>稳：企业级高可用，内置全方位保障</li><li>省：极致弹性，将成本降至可度量</li></ul><p><strong>2.加速 AI 创新：从快速探索到高效落地</strong></p><ul><li>快探索：内置 Dify、RAGFlow、OpenManus 等 热门 AI 应用模板，开箱即用，分钟级启动 POC；</li><li>稳落地：提供生产级 AI 运行时，性能优化（如 Dify 性能提升 50 倍）、无感升级、多版本管理，确保企业级可靠交付；</li><li>易集成：深度打通网关、ARMS、计量、审计等能力，助力传统应用智能化升级。</li></ul><h3>适合谁？</h3><p>✅ 创业团队：没有专职运维，需要快速上线<br/>✅ 中小企业：想降本增效，拥抱云原生<br/>✅ 大型企业：需要企业级稳定性和合规性<br/>✅ 出海企业：需要中国区 + 全球部署<br/>✅ AI 创新团队：想快速落地AI应用</p><h3>了解更多</h3><p>产品详情页地址：<a href="https://link.segmentfault.com/?enc=0dezXmMFmud7f5FaoZoXmA%3D%3D.EZ4sAKku8VHAEJqqP5TeJs%2BlwqNyyyLCTasKkkG5MVHJE6WtpJm8Fn74SRK%2BMz5U" rel="nofollow" target="_blank">https://www.aliyun.com/product/sae</a></p><p>SAE 客户服务群</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047415443" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[从“看得见”到“看得懂”：数字孪生如何重]]></title>    <link>https://segmentfault.com/a/1190000047432439</link>    <guid>https://segmentfault.com/a/1190000047432439</guid>    <pubDate>2025-11-27 15:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>作为一名在城市公共安全领域深耕多年的从业者，我深知传统安防系统的痛点：数据孤岛林立、应急响应迟缓、决策依赖经验。直到我们引入了数字孪生智能运营中心—孪易IOC，才真正实现了从“被动应对”到“主动防控”的跨越。今天，我想通过几个真实场景，分享这项技术如何让城市安全“活”起来。</p><h2>一、当消防警铃响起时，我们看到了什么？</h2><p>过去，接到火警报警后，我们需要调取建筑图纸、查看监控画面、联系现场人员……信息碎片化导致黄金救援时间被大量消耗。而现在，只需在数字孪生平台上轻点鼠标：<br/><strong>1.立体化态势感知</strong>：建筑内部结构、消防设施位置、人员热力图实时呈现在三维场景中。通过环境仿真功能，甚至能模拟烟雾扩散路径，为疏散指挥提供科学依据。<br/><strong>2.智能告警联动</strong>：系统自动识别报警位置，同步推送周边监控视频、消防栓压力数据、逃生通道人流量。去年某商业综合体演练中，这套机制让应急响应时间缩短了40%。</p><h2>二、暴雨中的城市，如何做到“先知先觉”？</h2><p>面对极端天气，传统的“看天吃饭”模式早已力不从心。我们的做法是：<br/><strong>1.多源数据融合</strong>：接入了气象局雷达数据、市政积水监测点、地铁站视频监控等138个异构数据源。当暴雨预警发布时，系统会自动生成洪涝风险图谱，精准标识出地下通道、下凹式立交桥等高风险区域（建议配图：城市洪涝风险动态推演界面）。<br/><strong>2.预案动态优化</strong>：基于历史回放功能，我们对比分析了近三年雨季的处置记录，发现原定疏散路线存在瓶颈。通过模拟推演，重新规划了17条应急通道，在今年汛期发挥了关键作用。<br/><img width="640" height="360" referrerpolicy="no-referrer" src="/img/bVdmUPX" alt="" title=""/></p><h2>三、大型活动安保，从“人海战术”到“精准布防”</h2><p>还记得那次50万人参与的跨年活动吗？我们通过数字孪生平台实现了：<br/><strong>1.人流智能预警</strong>：在广场核心区部署的AI摄像头识别到局部区域密度超标，系统立即触发告警，自动调度周边警力进行分流引导。整个过程在90秒内完成，避免了拥挤踩踏风险。<br/><strong>2.资源一键调度</strong>：将警力部署、医疗点位、应急车辆全部数字化。当现场发生突发状况时，指挥员可直接在三维地图上圈选区域，系统即刻生成最优资源调配方案（建议配图：大型活动安保资源动态部署图）。<br/><img width="723" height="274" referrerpolicy="no-referrer" src="/img/bVdmRH6" alt="" title="" loading="lazy"/></p><h2>四、这些改变背后的技术支撑是什么？</h2><p>或许你会好奇，如此复杂的系统是否需要庞大的研发团队？其实核心在于这个智能运营中心的四大能力：<br/><strong>1.业务视角的数据穿透</strong>——不必在多个系统间切换，通过自定义主题就能同时查看重点区域的人流、车流、警情数据关联分析<br/><strong>2.自主可控的预警体系</strong>——我们根据辖区特点设置了27类告警规则，从重点人员出现在敏感区域到桥梁结构监测数据异常，都能精准捕捉<br/><strong>3.零代码的灵活配置</strong>——业务人员通过拖拽就能新增监测指标，上周新增的共享单车潮汐点监测模块，从需求提出到上线只用了3小时<br/><strong>4.行业知识沉淀</strong>——平台预置的智慧安防插件库，直接提供了重点场所管控、应急指挥等标准化方案，让我们少走了很多弯路<br/><img width="723" height="274" referrerpolicy="no-referrer" src="/img/bVdmRH5" alt="" title="" loading="lazy"/></p><h2>五、从实践者角度看价值升华</h2><p>经过两年实践，我最深的体会是：技术终要服务于业务。这个平台最打动我的不是酷炫的三维效果，而是它让安全治理实现了三个转变：<br/><strong>1.从经验决策到数据决策</strong>：通过多维数据分析，我们发现某老旧小区夜间警情高发与路灯照度不足存在强关联，改造后案发率下降62%<br/><strong>2.从单点防控到体系防控</strong>：打通了公安、消防、医疗等11个部门的业务系统，真正构建起“平战结合”的应急指挥体系<br/><strong>3.从被动响应到主动预防</strong>：通过对历史告警的智能研判，成功预警了3起群体性事件苗头，把风险化解在萌芽状态<br/>如今，我们的数字孪生平台已管理着超过10万个城市要素，每天处理200万条实时数据。但更让我自豪的是，它正在让这座城市变得更安全、更聪明。正如一位老民警所说：“现在执勤就像有了透视眼，既能看清现状，又能预见风险。”</p>]]></description></item><item>    <title><![CDATA[全栈管理系统：Node.js + Exp]]></title>    <link>https://segmentfault.com/a/1190000047431730</link>    <guid>https://segmentfault.com/a/1190000047431730</guid>    <pubDate>2025-11-27 14:07:31</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>前言</h2><p>一直苦于技术没有接触后端，导致技术不够全面。离职后休息这段时间，设计架构了前后端系统，从另一个层面来讲，确实迈进了一大步，遇见了之前从未遇到的Bug，从开发，到部署，到测试，也是一番新的挑战</p><h2>项目介绍</h2><p>该项目是一个基于 Node.js + Express + MySQL + React + Antd 的现代化全栈管理系统。后端提供 JWT 认证、审计日志与在线用户、SSE 实时通知、单点登录；前端提供动态权限路由与增强版 SSE Hook。</p><p>在线地址： <a href="https://link.segmentfault.com/?enc=Y0yhXpfFCUo1uK4%2FQZkiBQ%3D%3D.rjztHscmwcQ3ZtdNMNROs8D%2BJsSVjRjzaXwojhk4mea%2B0UK%2BedVd1xy8N8jiAkCg" rel="nofollow" target="_blank">https://www.liyq666.top</a></p><p>git仓库：<a href="https://link.segmentfault.com/?enc=YmiJKcx683l8kMQJa%2BUsmw%3D%3D.C%2FUZj8oJK7vblJS%2B30Dp9J3e0M2zt1BVlggXU5zxAcpbV8%2BO6oEmowl7c8%2FRJanC" rel="nofollow" target="_blank">https://gitee.com/lyqjob/project-root</a></p><p>欢迎找我要最新系统预制脚本，一键插入数据库基本数据（预制菜单、预制权限、预制角色、超级管理员）等都有</p><h2>项目实例图</h2><p><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdnbjm" alt="" title=""/><br/><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdnbjo" alt="" title="" loading="lazy"/><br/><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdnbjq" alt="" title="" loading="lazy"/><br/><img width="723" height="393" referrerpolicy="no-referrer" src="/img/bVdnbjs" alt="" title="" loading="lazy"/><br/><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdnbju" alt="" title="" loading="lazy"/><br/><img width="723" height="393" referrerpolicy="no-referrer" src="/img/bVdnbjv" alt="" title="" loading="lazy"/><br/><img width="723" height="393" referrerpolicy="no-referrer" src="/img/bVdnbjw" alt="" title="" loading="lazy"/><br/><img width="723" height="393" referrerpolicy="no-referrer" src="/img/bVdnbjx" alt="" title="" loading="lazy"/><br/><img width="723" height="395" referrerpolicy="no-referrer" src="/img/bVdnbjz" alt="" title="" loading="lazy"/><br/><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdnbjA" alt="" title="" loading="lazy"/><br/><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdnbjD" alt="" title="" loading="lazy"/><br/><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdnbjE" alt="" title="" loading="lazy"/><br/><img width="723" height="395" referrerpolicy="no-referrer" src="/img/bVdnbjL" alt="" title="" loading="lazy"/><br/><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdnbjT" alt="" title="" loading="lazy"/><br/><img width="723" height="394" referrerpolicy="no-referrer" src="/img/bVdnbjU" alt="" title="" loading="lazy"/></p><h2>项目特性</h2><h3>后端能力</h3><ul><li>JWT 双 Token 认证与权限控制（Access/Refresh）</li><li>审计日志与来源采集（Referer、X-Client-Page），列表与详情查询</li><li>在线用户接口（基于审计窗口聚合，含来源页面、设备信息、会话信息）</li><li>单点登录（SINGLE_LOGIN），登录时保留当前会话并清退其他会话；通过 SSE 发送下线通知</li><li>SSE 实时通知（认证连接），心跳与连接统计；支持稳定客户端标识 <code>clientId</code></li><li>统一日志与请求 ID，中间件记录请求信息与敏感脱敏</li><li>Token 管理与自动清理</li><li>CORS 允许自定义头：<code>X-Client-Id</code>、<code>X-Client-Page</code></li></ul><h3>前端能力</h3><ul><li>React 18 + Antd 5 + Webpack 5 + Redux Toolkit + React Router 6</li><li>动态权限路由（后端返回菜单动态注册）与按钮级权限</li><li>增强版 <code>useSSE</code> Hook：自动认证、自动重连、心跳与事件订阅、稳定 <code>clientId</code> 持久化（<code>localStorage</code>）</li><li>基础布局 <code>BasicLayout</code> 集成 SSE 事件（open/welcome/heartbeat/loginout），收到登录异常通知后自动退出</li></ul><h2>项目结构</h2><pre><code>project-root/
├── node-express-mysql/            # 后端服务
│   ├── config/                    # 配置（配置与实现分离）
│   │   ├── base/                  # 基础配置（与环境无关）
│   │   │   ├── cache.js captcha.js code.js db.js logger.js redis.js schedules.js upload.js
│   │   ├── env/                   # 环境特定配置（development/production/test）
│   │   └── index.js               # 配置加载与合并导出
│   ├── docs/                      # 后端文档（缓存/日志/SSE/权限规范等）
│   ├── public/                    # 静态资源
│   ├── sql/                       # SQL 脚本（库/表结构与初始化）
│   ├── src/                       # 源代码
│   │   ├── cache/                 # 缓存服务（Memory/Redis/策略/监控/键生成器）
│   │   ├── controllers/           # 控制器（auth/user/role/menu/permission/department/...）
│   │   ├── infra/                 # 基础设施（dbClient/redisClient/scheduler/sseManager）
│   │   ├── logger/                # 日志模块（增强日志/核心/工具/脱敏）
│   │   ├── middlewares/           # 中间件（认证/权限/文件/验证码/请求ID/监控校验）
│   │   ├── models/                # 数据模型（user/role/menu/permission/department/token/audit/monitor）
│   │   ├── routes/                # 路由（index + 各模块路由，含 sse/publicAuth/monitor 等）
│   │   ├── services/              # 领域服务（codeService/dbService/redisService/uploadService）
│   │   └── utils/                 # 工具（response/jwtUtils/validator/utils/auditLogger/codeGenerator/sseManager）
│   ├── ecosystem.config.js        # PM2 配置
│   ├── swagger.yaml               # OpenAPI 描述
│   ├── index.js                   # 应用入口
│   ├── log-rotate.sh              # 日志轮转脚本
│   ├── package.json               # 项目配置
│   └── README.md                  # 后端说明
├── react-antd-webpack/             # 前端应用
│   ├── build/                      # Webpack 配置（base/dev/prod）
│   ├── public/                     # 公共资源
│   ├── src/                        # 源代码
│   │   ├── components/             # 通用组件（GlobalHeader/SSEManager/Audit/AuthButton/Charts 等）
│   │   ├── hooks/                  # 自定义 Hook（useSSE/usePermission/useAuth 等）
│   │   ├── layouts/                # 布局（BasicLayout/authRouter）
│   │   ├── pages/                  # 页面模块（login/home/monitor/setting/...）
│   │   ├── router/                 # 路由（baseRouter/asynccomponents/index）
│   │   ├── services/               # API 服务（auth/permission/role/menu/department/admin 等）
│   │   ├── store/                  # 状态管理（reducers/global + store 配置）
│   │   ├── utils/                  # 工具（api/request、monitor_sdk、utils 等）
│   │   ├── index.js                # 前端入口
│   │   └── global.css              # 全局样式
│   └── package.json                # 前端项目配置
├── LICENSE                         # 许可证
└── README.md                       # 项目说明</code></pre><h2>缓存功能</h2><ul><li>架构：支持内存与 Redis 双实现，依据 <code>config/cache.js</code> 的 <code>type</code> 与 <code>config/redis</code> 自动选择；Redis 使用 <code>SCAN MATCH</code> 批量清理，避免阻塞。</li><li><p>键规范：统一通过 <code>generateCacheKey(module, resourceType, identifier, operation?)</code> 生成，例如：</p><ul><li>列表：<code>app:v1:permission:list:&lt;filtersJson&gt;</code></li><li>单项：<code>app:v1:user:item:&lt;id&gt;</code>、<code>app:v1:role:item:&lt;id&gt;</code></li><li>用户角色：<code>app:v1:user:roles:&lt;userId&gt;</code></li><li>权限码：<code>app:v1:permission:codes:user:&lt;userId&gt;</code></li></ul></li><li><p>模式清理：使用 <code>getCacheKeyPattern(module, resourceType)</code> 生成模式，示例：</p><ul><li>清理权限列表：<code>clearByPattern(getCacheKeyPattern('permission','list'))</code></li><li>清理角色列表：<code>clearByPattern(getCacheKeyPattern('role','list'))</code></li><li>清理用户统计：<code>clearByPattern(getCacheKeyPattern('user','stats'))</code></li></ul></li><li>读缓存位置：模型/服务层统一设置读缓存（如 <code>withCache</code> 装饰器、<code>cacheService.get/set</code>），控制器层主要进行失效与聚合响应缓存。</li><li>失效策略：写操作完成后在控制器集中清理相关键（精确 <code>del</code> + 按模块模式 <code>clearByPattern</code>），确保响应与后端数据一致。</li><li>监控与日志：缓存操作由 <code>cacheMonitor</code> 记录命中率与耗时；日志模块输出结构化信息方便排查。</li></ul><p>示例代码（列表缓存与清理）：</p><pre><code class="javascript">const { generateCacheKey, getCacheKeyPattern } = require('./node-express-mysql/src/cache/utils/cacheKeyGenerator');
const cacheService = require('./node-express-mysql/src/cache/cacheService');

// 读取（命中则直接返回）
const cacheKey = generateCacheKey('role','list', JSON.stringify({ page, limit, filters }));
const cached = await cacheService.get(cacheKey);

// 写入（查询后写入）
await cacheService.set(cacheKey, { data, pagination }, null, 'role.list');

// 清理（写操作后）
await cacheService.clearByPattern(getCacheKeyPattern('role','list'));</code></pre><p>更多规范见后端文档：<code>node-express-mysql/docs/3.缓存管理.md</code>、<code>node-express-mysql/docs/2.缓存键命名规范.md</code>。</p><h2>技术栈</h2><h3>后端</h3><ul><li><strong>Node.js</strong> &gt;= 18.0.0 - JavaScript运行时</li><li><strong>Express.js</strong> - Web应用框架</li><li><strong>MySQL</strong> &gt;= 8.0 - 关系型数据库</li><li><strong>JWT</strong> - JSON Web Token认证</li><li><strong>bcryptjs</strong> - 密码加密</li><li><strong>svg-captcha</strong> - 图形验证码</li><li><strong>express-session</strong> - 会话管理</li><li><strong>cors</strong> - 跨域处理</li><li><strong>dotenv</strong> - 环境变量管理</li></ul><h3>前端</h3><ul><li><strong>React</strong> 18.2.0 - UI框架</li><li><strong>Antd</strong> 5.26.2 - UI组件库</li><li><strong>Webpack</strong> 5.99.9 - 模块打包器</li><li><strong>Babel</strong> 7.27.4 - JavaScript编译器</li><li><strong>Redux Toolkit</strong> 2.8.2 - 状态管理</li><li><strong>React Router</strong> 6.30.0 - 路由管理</li><li><strong>Axios</strong> 1.10.0 - HTTP客户端</li><li><strong>Less</strong> 4.3.0 - CSS预处理器</li><li><strong>PostCSS</strong> - CSS后处理器</li></ul><h2>权限设计</h2><p>该项目的权限架构采用RBAC0  + 权限层级 + 数据域来设计，相比传统的5张数据库表，多了两张数据库表，分别是权限表和角色权限关联表，以角色为核心，通过角色与菜单/权限点/数据域的关联，实现细粒度的权限控制。</p><h3>四层模型</h3><p>系统管理层（角色与层级）、功能模块层（菜单/模块）、操作权限层（权限点/接口/按钮）、数据权限层（部门/数据域）。</p><ul><li>目标：更精细、更灵活的权限控制，满足复杂业务场景；兼容当前实现并可渐进增强。</li><li>用户层：<code>user</code>，账号主体，绑定所属部门与基础信息。</li><li>角色层：<code>role</code>，权限载体，聚合菜单/权限点/数据权限。</li><li>菜单/资源层：<code>menu</code>，页面/目录/按钮（<code>node_type</code>）与路由/组件，含权限编码 <code>code</code> 与访问类型 <code>access_type</code>（0-公共，1-私有）。</li><li>权限点/数据权限层：<code>permission</code> 作为操作点（接口/按钮）集合，<code>department</code> 作为数据域；通过关联表构成角色的操作与数据范围。</li></ul><h3>数据库（7 张权限关联表）</h3><ul><li><code>user</code>：用户表，含 <code>department_id</code> 等基础字段。</li><li><code>role</code>：角色表，含系统预置与保护标识（<code>is_system/is_protected</code>）。</li><li><code>menu</code>：菜单表，目录/菜单/按钮（<code>node_type=1/2/3</code>），权限编码 <code>code</code> 与路由/组件信息。</li><li><code>permission</code>：权限点表，定义接口/操作编码集合。</li><li><code>user_role</code>：用户与角色关联表（多对多）。</li><li><code>role_menu</code>：角色与菜单关联表（多对多），决定角色可见页面/按钮。</li><li><code>role_permission</code>：角色与权限点关联表（多对多），决定角色可用接口/操作。</li><li>扩展：<code>department</code> 与 <code>role_data_permission</code>（角色数据权限关联表）用于数据域授权，限定角色的数据访问范围。</li></ul><h3>关联关系</h3><ul><li>用户→角色：<code>user_role</code>；一个用户可绑定多个角色。</li><li>角色→菜单：<code>role_menu</code>；决定该角色在前端可见的目录/页面/按钮集合。</li><li>角色→权限点：<code>role_permission</code>；决定该角色在后端可用的接口/操作集合。</li><li>角色→数据域：<code>role_data_permission</code>；定义角色在不同部门/数据范围内的可访问性。</li></ul><h3>判定流程</h3><ul><li><p>后端接口权限：</p><ul><li>认证中间件校验 Token 并设置 <code>req.user</code>。</li><li>路由层使用权限校验中间件（如 <code>checkPermission('code')</code> 与等级 <code>checkPermissionLevel(40)</code>）核验权限码与安全等级。</li><li>权限码来源：菜单/权限表的 <code>code</code>，通过用户的角色聚合得到可用集合（<code>menuModel.getUserPermissionCodes</code>）。</li></ul></li><li><p>前端页面权限：</p><ul><li>路由与菜单：后端返回的菜单按 <code>access_type</code> 与 <code>role_menu</code> 过滤；非超级管理员补齐父级目录，保证导航完整。</li><li>按钮权限：<code>AuthButton</code> 基于权限码 <code>code</code> 控制显隐（与后端同源编码）。</li></ul></li></ul><h3>超级管理员</h3><ul><li>统一判断：<code>utils.isSuperAdminById(userId)</code>，依据角色 <code>code='SUPER_ADMIN'</code> 或系统预置且受保护（<code>is_system=1 &amp;&amp; is_protected=1</code>）。</li><li>超级管理员跳过菜单与权限过滤，拥有全部资源与操作能力。</li></ul><h3>模型层</h3><ul><li><code>PermissionModel</code>：获取权限列表/详情、按角色/用户获取权限码；分配角色权限（事务）、缓存 <code>permissions:role:*</code>、<code>permission_codes:user:*</code>。</li><li><code>DataPermissionModel</code>：按角色/用户获取数据权限（部门ID集合），校验用户是否可访问某部门；生成数据权限 SQL 过滤条件。</li><li><code>MenuModel</code>：按用户返回菜单支持 <code>access_type</code> 过滤；非超级管理员补齐父级目录，保证导航完整；支持最小字段集与完整字段集。</li></ul><h3>中间件</h3><ul><li><code>checkPermission(requiredPermissions, { checkDataPermission, dataPermissionType })</code></li><li><code>checkRole(requiredRoles)</code></li><li><code>checkPermissionLevel(minLevel)</code></li><li><code>checkDataPermission(permissionType)</code></li></ul><h3>路由</h3><ul><li>权限管理：<code>GET /permissions</code>、<code>GET /permissions/:id</code>、<code>GET /roles/:roleId/permissions</code>、<code>PUT /roles/:roleId/permissions</code>、<code>GET /user/permissions</code></li><li>角色管理：<code>GET /roles</code>、<code>GET /roles/:id</code>、<code>POST /roles</code>（层级≥20）、<code>PUT /roles/:id</code>、<code>DELETE /roles/:id</code>、<code>GET/PUT /roles/:roleId/data-permissions</code></li></ul><h3>权限码规范（示例）</h3><ul><li>模块层：<code>module:{模块名}:{操作}</code>（如 <code>module:user:view</code>、<code>module:role:edit</code>）</li><li>操作层：<code>{模块名}:{实体}:{操作}</code>（如 <code>system:user:create</code>、<code>system:role:delete</code>、<code>content:article:publish</code>）</li></ul><h2>快速开始</h2><h3>环境要求</h3><ul><li>Node.js &gt;= 18.0.0</li><li>MySQL &gt;= 8.0</li><li>npm &gt;= 8.0.0 或 yarn &gt;= 1.22.0</li></ul><h3>1. 克隆项目</h3><pre><code class="bash">git clone &lt;repository-url&gt;
cd project-root</code></pre><h3>后端服务启动</h3><pre><code class="bash"># 进入后端目录
cd node-express-mysql

# 安装依赖
npm install
# 或
yarn install

# 配置环境变量
cp .env.example .env
# 编辑 .env 文件，配置数据库连接信息

# 初始化数据库
# 执行 config/sql/ 目录下的SQL文件

# 启动服务
npm run dev
# 或
yarn dev</code></pre><p>后端服务默认 <code>http://localhost:8888</code></p><h3>前端应用启动</h3><pre><code class="bash"># 进入前端目录
cd react-antd-webpack

# 安装依赖
npm install
# 或
yarn install

# 启动开发服务器
npm run dev
# 或
yarn dev</code></pre><p>前端应用默认 <code>http://localhost:3000</code></p><h2>配置说明</h2><h3>后端环境变量</h3><p>创建 <code>node-express-mysql/.env</code> 文件：</p><pre><code class="env"># 数据库配置
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=your_database

# JWT 配置
JWT_SECRET=your-jwt-secret-key
REFRESH_SECRET=your-refresh-secret-key

# 会话配置
SESSION_SECRET=your-session-secret-key

# 服务器配置
PORT=8888
NODE_ENV=development
LOG_LEVEL=debug

# 单点登录开关：on 则登录时清退其他会话并通过 SSE 通知
SINGLE_LOGIN=on</code></pre><h3>前端 API 配置</h3><p>修改 <code>react-antd-webpack/src/utils/api/request.js</code> 中的API基础URL：</p><pre><code class="javascript">const baseURL = 'http://localhost:8888';</code></pre><h2>API 接口文档</h2><h3>认证相关</h3><table><thead><tr><th>接口</th><th>方法</th><th>路径</th><th>功能</th><th>权限</th></tr></thead><tbody><tr><td>用户登录</td><td>POST</td><td><code>/login</code></td><td>用户登录</td><td>公开</td></tr><tr><td>用户登出</td><td>POST</td><td><code>/auth/logout</code></td><td>用户登出</td><td>需要token</td></tr><tr><td>强制登出用户</td><td>POST</td><td><code>/auth/logout/:userId</code></td><td>强制清退</td><td>需要token</td></tr><tr><td>强制登出会话</td><td>POST</td><td><code>/auth/logout/session/:sessionId</code></td><td>强制清退会话</td><td>需要token</td></tr><tr><td>刷新Token</td><td>PATCH</td><td><code>/refresh</code></td><td>刷新访问令牌</td><td>需要refresh token</td></tr><tr><td>获取验证码</td><td>POST</td><td><code>/captcha</code></td><td>获取图形验证码</td><td>公开</td></tr><tr><td>健康检查</td><td>GET</td><td><code>/health</code></td><td>系统健康检查</td><td>公开</td></tr></tbody></table><h3>用户管理</h3><table><thead><tr><th>接口</th><th>方法</th><th>路径</th><th>功能</th><th>权限</th></tr></thead><tbody><tr><td>获取用户列表</td><td>GET</td><td><code>/users</code></td><td>获取所有用户</td><td>需要token</td></tr><tr><td>获取用户信息</td><td>GET</td><td><code>/users/:id</code></td><td>获取指定用户</td><td>需要token</td></tr><tr><td>创建用户</td><td>POST</td><td><code>/users</code></td><td>创建新用户</td><td>需要token</td></tr><tr><td>更新用户</td><td>PUT</td><td><code>/users/:id</code></td><td>更新用户信息</td><td>需要token</td></tr><tr><td>删除用户</td><td>DELETE</td><td><code>/users/:id</code></td><td>删除用户</td><td>需要token</td></tr></tbody></table><h3>角色管理</h3><table><thead><tr><th>接口</th><th>方法</th><th>路径</th><th>功能</th><th>权限</th></tr></thead><tbody><tr><td>获取角色列表</td><td>GET</td><td><code>/roles</code></td><td>获取所有角色</td><td>需要token</td></tr><tr><td>创建角色</td><td>POST</td><td><code>/roles</code></td><td>创建新角色</td><td>需要token</td></tr><tr><td>更新角色</td><td>PUT</td><td><code>/roles/:id</code></td><td>更新角色信息</td><td>需要token</td></tr><tr><td>删除角色</td><td>DELETE</td><td><code>/roles/:id</code></td><td>删除角色</td><td>需要token</td></tr><tr><td>绑定菜单</td><td>POST</td><td><code>/roles/bind-menus</code></td><td>角色绑定菜单</td><td>需要token</td></tr></tbody></table><h3>菜单管理</h3><table><thead><tr><th>接口</th><th>方法</th><th>路径</th><th>功能</th><th>权限</th></tr></thead><tbody><tr><td>获取菜单列表</td><td>GET</td><td><code>/menus</code></td><td>获取所有菜单</td><td>需要token</td></tr><tr><td>创建菜单</td><td>POST</td><td><code>/menus</code></td><td>创建新菜单</td><td>需要token</td></tr><tr><td>更新菜单</td><td>PUT</td><td><code>/menus/:id</code></td><td>更新菜单信息</td><td>需要token</td></tr><tr><td>删除菜单</td><td>DELETE</td><td><code>/menus/:id</code></td><td>删除菜单</td><td>需要token</td></tr></tbody></table><h3>审计日志与在线用户</h3><table><thead><tr><th>接口</th><th>方法</th><th>路径</th><th>功能</th></tr></thead><tbody><tr><td>审计列表</td><td>GET</td><td><code>/api/admin/audit/logs</code></td><td>审计日志分页查询</td></tr><tr><td>审计详情</td><td>GET</td><td><code>/api/admin/audit/log/:id</code></td><td>审计日志详情</td></tr><tr><td>在线用户</td><td>GET</td><td><code>/api/admin/audit/online/users</code></td><td>基于审计窗口聚合在线用户</td></tr></tbody></table><p>返回字段：<code>user_id/username/dept_id/dept_name/last_active_time/actions_in_window/last_url/last_method/client_ip/user_agent/browser/operating_system/location/change_summary/session_id/session_last_active_time/session_duration_minutes</code>。</p><h3>SSE 实时通知</h3><table><thead><tr><th>接口</th><th>方法</th><th>路径</th><th>功能</th></tr></thead><tbody><tr><td>认证连接</td><td>GET</td><td><code>/sse/connect/auth</code></td><td>建立 SSE 连接（需 Authorization）</td></tr><tr><td>发送消息</td><td>POST</td><td><code>/sse/send</code></td><td>向指定用户发送通知</td></tr><tr><td>广播消息</td><td>POST</td><td><code>/sse/broadcast</code></td><td>向所有连接广播</td></tr><tr><td>连接统计</td><td>GET</td><td><code>/sse/stats</code></td><td>查看连接统计</td></tr></tbody></table><p>连接建议附带稳定 <code>clientId</code>：请求头 <code>X-Client-Id</code> 与 URL <code>?clientId=&lt;id&gt;</code>。服务端在 <code>open/welcome</code> 事件返回 <code>{ connectionId, clientId }</code>。</p><h2>前端特性</h2><h3>动态权限路由</h3><ul><li><strong>动态路由注册</strong> - 根据后端返回的菜单数据动态注册路由</li><li><strong>权限控制</strong> - 基于RBAC模型的页面级权限控制</li><li><strong>按钮权限</strong> - 支持按钮级别的权限控制</li><li><strong>路由守卫</strong> - 自动处理未授权访问和登录失效</li></ul><h3>状态管理</h3><ul><li><strong>Redux Toolkit</strong> - 现代化的状态管理方案</li><li><strong>持久化存储</strong> - 用户信息和菜单数据本地缓存</li><li><strong>无感刷新</strong> - 自动处理Token过期和刷新</li></ul><h3>错误处理</h3><ul><li><strong>全局错误捕获</strong> - ErrorBoundary + 全局错误监听</li><li><strong>错误去重</strong> - 防止重复错误上报</li><li><strong>友好降级</strong> - 错误页面自动跳转到有效页面</li></ul><h3>性能优化</h3><ul><li><strong>代码分割</strong> - 路由级别的懒加载</li><li><strong>资源优化</strong> - 图片压缩和CDN支持</li><li><strong>缓存策略</strong> - 合理的缓存机制</li></ul><h2>安全特性</h2><h3>认证安全</h3><ul><li><strong>JWT双Token</strong> - Access Token + Refresh Token机制</li><li><strong>Token过期</strong> - 访问令牌1小时过期，刷新令牌7天过期</li><li><strong>自动清理</strong> - 定时清理过期和已撤销的token</li><li><strong>强制登出</strong> - 支持强制登出用户所有设备</li></ul><h3>输入验证</h3><ul><li><strong>参数验证</strong> - 所有接口都有完整的参数验证</li><li><strong>格式检查</strong> - 验证ID、邮箱、手机号等格式</li><li><strong>重复性检查</strong> - 防止创建重复的用户名、角色编码等</li><li><strong>SQL注入防护</strong> - 使用参数化查询防止SQL注入</li></ul><h3>验证码保护</h3><ul><li><strong>图形验证码</strong> - 使用svg-captcha生成验证码</li><li><strong>内存存储</strong> - 验证码存储在服务器端内存中</li><li><strong>过期机制</strong> - 验证码5分钟自动过期</li><li><strong>一次性使用</strong> - 验证码使用后自动清除</li></ul><h2>响应格式</h2><h3>成功响应</h3><pre><code class="json">{
  "success": true,
  "code": 200,
  "message": "操作成功",
  "data": {
    "id": 1,
    "username": "admin",
    "name": "管理员"
  },
  "timestamp": "2024-01-01T12:00:00.000Z"
}</code></pre><h3>错误响应</h3><pre><code class="json">{
  "success": false,
  "code": 400,
  "message": "请求参数错误",
  "data": null,
  "timestamp": "2024-01-01T12:00:00.000Z"
}</code></pre><h2>开发调试</h2><h3>后端调试</h3><pre><code class="bash"># 查看验证码状态
curl -H "Authorization: Bearer &lt;token&gt;" \
     http://localhost:8888/captcha/status

# 手动清理过期token
curl -X POST -H "Authorization: Bearer &lt;token&gt;" \
     http://localhost:8888/cleanup-tokens

# 获取token统计信息
curl -H "Authorization: Bearer &lt;token&gt;" \
     http://localhost:8888/token-stats</code></pre><h3>前端调试</h3><ul><li><strong>Redux DevTools</strong> - 状态管理调试</li><li><strong>React DevTools</strong> - 组件调试</li><li><strong>Network面板</strong> - API请求调试</li><li><strong>Console日志</strong> - 错误信息查看</li></ul><h2>部署指南</h2><h3>生产环境部署</h3><p>本项目提供多种部署方式，包括传统部署、Docker部署和Docker Compose部署。</p><h4>方式一：传统部署</h4><h5>后端部署</h5><pre><code class="bash"># 1. 进入后端目录
cd node-express-mysql

# 2. 安装依赖
npm install
# 或
yarn install

# 3. 设置环境变量
export NODE_ENV=production
export DB_HOST=your-production-db-host
export DB_PASSWORD=your-production-password
export JWT_SECRET=your-production-jwt-secret

# 4. 安装PM2进程管理器
npm install -g pm2

# 5. 启动应用
pm2 start index.js --name "backend-api"

# 6. 设置开机自启
pm2 startup
pm2 save</code></pre><h5>前端部署</h5><pre><code class="bash"># 1. 进入前端目录
cd react-antd-webpack

# 2. 安装依赖
npm install
# 或
yarn install

# 3. 构建生产版本
npm run build
# 或
yarn build

# 4. 部署到Web服务器
# 将dist目录内容上传到Web服务器
# 配置Nginx反向代理</code></pre><h4>方式二：Docker Compose部署（推荐）</h4><p>项目已包含完整的Docker Compose配置，支持一键部署。</p><h5>1. 环境准备</h5><p>创建环境变量文件 <code>docker-compose/.env</code>：</p><pre><code class="env"># MySQL数据库配置
MYSQL_ROOT_PASSWORD=your_secure_password
MYSQL_DATABASE=your_database_name
MYSQL_USER=your_database_user
MYSQL_PASSWORD=your_database_password

# 时区设置
TZ=Asia/Shanghai
LANG=en_US.UTF-8</code></pre><h5>2. 快速启动</h5><pre><code class="bash"># 进入项目根目录
cd project-root

# 进入docker-compose目录
cd docker-compose

# 启动所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f

# 停止服务
docker-compose down</code></pre><h5>3. 服务说明</h5><p>当前Docker Compose配置包含以下服务：</p><ul><li><strong>MySQL 8.0.34</strong> - 数据库服务（端口：3306）</li><li><strong>Nginx 1.25.2</strong> - 静态资源服务（端口：8080）</li></ul><h5>4. 数据持久化</h5><ul><li><strong>数据库数据</strong>：<code>./docker-compose/db-data/data</code></li><li><strong>数据库配置</strong>：<code>./docker-compose/db-data/conf</code></li><li><strong>数据库日志</strong>：<code>./docker-compose/db-data/logs</code></li><li><strong>Nginx日志</strong>：<code>./docker-compose/nginx/log</code></li></ul><h5>5. 访问服务</h5><ul><li><strong>Nginx静态服务</strong>：<a href="https://link.segmentfault.com/?enc=iXrETBBNNiWjPIKartwKDQ%3D%3D.320khHPCNtCpV6U%2B0vkd1YZyDmYoIErcG3YMOsjfDss%3D" rel="nofollow" target="_blank">http://localhost:8080</a></li><li><strong>MySQL数据库</strong>：localhost:3306</li></ul><h4>方式三：完整Docker部署</h4><h5>1. 创建Dockerfile</h5><p><strong>后端Dockerfile</strong> (<code>node-express-mysql/Dockerfile</code>)：</p><pre><code class="dockerfile">FROM node:18-alpine

# 设置工作目录
WORKDIR /app

# 复制package文件
COPY package*.json ./
COPY yarn.lock ./

# 安装依赖
RUN yarn install --frozen-lockfile

# 复制源代码
COPY . .

# 暴露端口
EXPOSE 8888

# 启动命令
CMD ["npm", "start"]</code></pre><p><strong>前端Dockerfile</strong> (<code>react-antd-webpack/Dockerfile</code>)：</p><pre><code class="dockerfile">FROM node:18-alpine as builder

# 设置工作目录
WORKDIR /app

# 复制package文件
COPY package*.json ./
COPY yarn.lock ./

# 安装依赖
RUN yarn install --frozen-lockfile

# 复制源代码
COPY . .

# 构建应用
RUN yarn build

# 生产阶段
FROM nginx:1.25.2-alpine

# 复制构建文件
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制nginx配置
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 暴露端口
EXPOSE 80

# 启动nginx
CMD ["nginx", "-g", "daemon off;"]</code></pre><h5>2. 完整Docker Compose配置</h5><p>创建 <code>docker-compose-full.yml</code>：</p><pre><code class="yaml">version: '3.8'

services:
  mysql:
    image: mysql:8.0.34
    container_name: mysql-8
    restart: always
    environment:
      TZ: Asia/Shanghai
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - "3306:3306"
    volumes:
      - ./docker-compose/db-data/data:/var/lib/mysql
      - ./docker-compose/db-data/conf:/etc/mysql/conf.d
      - ./docker-compose/db-data/logs:/var/log/mysql
    networks:
      - app-network
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

  backend:
    build: ./node-express-mysql
    container_name: backend-api
    restart: always
    ports:
      - "8888:8888"
    environment:
      - NODE_ENV=production
      - DB_HOST=mysql
      - DB_PORT=3306
      - DB_USER=${MYSQL_USER}
      - DB_PASSWORD=${MYSQL_PASSWORD}
      - DB_NAME=${MYSQL_DATABASE}
      - JWT_SECRET=${JWT_SECRET}
      - REFRESH_SECRET=${REFRESH_SECRET}
    depends_on:
      - mysql
    networks:
      - app-network
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

  frontend:
    build: ./react-antd-webpack
    container_name: frontend-app
    restart: always
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - app-network
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

networks:
  app-network:
    driver: bridge</code></pre><h5>3. 部署步骤</h5><pre><code class="bash"># 1. 克隆项目
git clone &lt;repository-url&gt;
cd project-root

# 2. 创建环境变量文件
cat &gt; .env &lt;&lt; EOF
MYSQL_ROOT_PASSWORD=your_secure_password
MYSQL_DATABASE=your_database_name
MYSQL_USER=your_database_user
MYSQL_PASSWORD=your_database_password
JWT_SECRET=your_jwt_secret_key
REFRESH_SECRET=your_refresh_secret_key
EOF

# 3. 启动完整服务
docker-compose -f docker-compose-full.yml up -d

# 4. 初始化数据库
# 执行 node-express-mysql/config/sql/ 目录下的SQL文件

# 5. 访问应用
# 前端：http://localhost
# 后端：http://localhost:8888</code></pre><h4>方式四：生产环境优化部署</h4><h5>1. 生产环境Docker Compose配置</h5><p>创建 <code>docker-compose-prod.yml</code>：</p><pre><code class="yaml">version: '3.8'

services:
  mysql:
    image: mysql:8.0.34
    restart: always
    environment:
      TZ: Asia/Shanghai
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    volumes:
      - mysql-data:/var/lib/mysql
      - ./docker-compose/db-data/conf:/etc/mysql/conf.d
    networks:
      - app-network
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "5"

  backend:
    build: ./node-express-mysql
    restart: always
    environment:
      - NODE_ENV=production
      - DB_HOST=mysql
      - DB_USER=${MYSQL_USER}
      - DB_PASSWORD=${MYSQL_PASSWORD}
      - DB_NAME=${MYSQL_DATABASE}
      - JWT_SECRET=${JWT_SECRET}
      - REFRESH_SECRET=${REFRESH_SECRET}
    depends_on:
      - mysql
    networks:
      - app-network
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 256M
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "5"

  frontend:
    build: ./react-antd-webpack
    restart: always
    depends_on:
      - backend
    networks:
      - app-network
    deploy:
      resources:
        limits:
          memory: 256M
        reservations:
          memory: 128M
    logging:
      driver: json-file
      options:
        max-size: "50m"
        max-file: "5"

volumes:
  mysql-data:

networks:
  app-network:
    driver: bridge</code></pre><h5>2. 生产环境部署脚本</h5><p>创建 <code>deploy.sh</code>：</p><pre><code class="bash">#!/bin/bash

# 生产环境部署脚本
set -e

echo "🚀 开始生产环境部署..."

# 检查Docker是否安装
if ! command -v docker &amp;&gt; /dev/null; then
    echo "❌ Docker未安装，请先安装Docker"
    exit 1
fi

# 检查Docker Compose是否安装
if ! command -v docker-compose &amp;&gt; /dev/null; then
    echo "❌ Docker Compose未安装，请先安装Docker Compose"
    exit 1
fi

# 检查环境变量文件
if [ ! -f .env ]; then
    echo "❌ 环境变量文件.env不存在，请创建"
    exit 1
fi

# 构建前端
echo "📦 构建前端应用..."
cd react-antd-webpack
npm run build
cd ..

# 停止现有服务
echo "🛑 停止现有服务..."
docker-compose -f docker-compose-prod.yml down

# 启动服务
echo "🚀 启动生产服务..."
docker-compose -f docker-compose-prod.yml up -d

# 等待服务启动
echo "⏳ 等待服务启动..."
sleep 30

# 检查服务状态
echo "🔍 检查服务状态..."
docker-compose -f docker-compose-prod.yml ps

echo "✅ 生产环境部署完成！"
echo "🌐 前端访问地址: http://localhost"
echo "🔧 后端API地址: http://localhost:8888"</code></pre><h5>3. 监控和日志</h5><pre><code class="bash"># 查看服务状态
docker-compose -f docker-compose-prod.yml ps

# 查看实时日志
docker-compose -f docker-compose-prod.yml logs -f

# 查看特定服务日志
docker-compose -f docker-compose-prod.yml logs -f backend

# 进入容器调试
docker exec -it backend-api /bin/sh
docker exec -it mysql-8 mysql -u root -p

# 查看资源使用情况
docker stats</code></pre><h4>常用Docker命令</h4><pre><code class="bash"># 查看容器状态
docker ps -a

# 查看容器日志
docker logs -f container_name

# 进入容器
docker exec -it container_name /bin/sh

# 停止容器
docker stop container_name

# 删除容器
docker rm container_name

# 查看镜像
docker images

# 删除镜像
docker rmi image_name

# 清理未使用的资源
docker system prune -a

# 查看Docker Compose服务
docker-compose ps

# 重启服务
docker-compose restart service_name

# 更新服务
docker-compose up -d --force-recreate service_name</code></pre><h4>生产环境注意事项</h4><ol><li><p><strong>安全配置</strong></p><ul><li>使用强密码</li><li>定期更新密钥</li><li>限制网络访问</li><li>启用SSL/TLS</li></ul></li><li><p><strong>性能优化</strong></p><ul><li>配置数据库连接池</li><li>启用Redis缓存</li><li>使用CDN加速</li><li>配置负载均衡</li></ul></li><li><p><strong>监控告警</strong></p><ul><li>设置服务监控</li><li>配置日志收集</li><li>设置告警通知</li><li>定期备份数据</li></ul></li><li><p><strong>备份策略</strong></p><ul><li>数据库定期备份</li><li>配置文件版本控制</li><li>镜像定期更新</li><li>灾难恢复预案</li></ul></li></ol><h2>📈 性能优化</h2><h3>后端优化</h3><ul><li><strong>数据库索引</strong> - 为查询字段添加适当索引</li><li><strong>连接池</strong> - 使用数据库连接池</li><li><strong>缓存策略</strong> - Redis缓存热点数据</li><li><strong>压缩中间件</strong> - 启用gzip压缩</li></ul><h3>前端优化</h3><ul><li><strong>代码分割</strong> - 路由级别的代码分割</li><li><strong>懒加载</strong> - 组件和路由懒加载</li><li><strong>资源压缩</strong> - 图片和静态资源压缩</li><li><strong>CDN加速</strong> - 静态资源CDN部署</li></ul><h2>🤝 贡献指南</h2><ol><li>Fork 本仓库</li><li>创建特性分支 (<code>git checkout -b feature/AmazingFeature</code>)</li><li>提交更改 (<code>git commit -m 'Add some AmazingFeature'</code>)</li><li>推送到分支 (<code>git push origin feature/AmazingFeature</code>)</li><li>打开 Pull Request</li></ol><h2>📄 许可证</h2><p>本项目采用 MIT 许可证 - 查看 <a href="LICENSE" target="_blank">LICENSE</a> 文件了解详情</p><h2>👨‍💻 作者</h2><ul><li><strong>lyq</strong> - <em>项目创建者和维护者</em> - <a href="mailto:lyqjob@yeah.net" target="_blank">lyqjob@yeah.net</a></li></ul><h2>🙏 致谢</h2><p>⭐ 如果这个项目对你有帮助，请给它一个星标！</p>]]></description></item><item>    <title><![CDATA[NocoBase 本周更新汇总：优化及缺]]></title>    <link>https://segmentfault.com/a/1190000047432018</link>    <guid>https://segmentfault.com/a/1190000047432018</guid>    <pubDate>2025-11-27 14:06:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>原文链接：<a href="https://link.segmentfault.com/?enc=DLgEQLtn26PeWTbnk%2Bj%2FrA%3D%3D.LQ7RSb5tXOq511%2BON2XqD8Q5Iw2sDl5Z83CVKq%2BPQr4fHak8jeBf4Fu3%2BZa2QcxjCwVHp3pgjT2RWJBXLCn7Nw%3D%3D" rel="nofollow" target="_blank">https://www.nocobase.com/cn/blog/weekly-updates-20251127</a></p><p>汇总一周产品更新日志，最新发布可以<a href="https://link.segmentfault.com/?enc=qmdJhYUrtJYc9ZWGuy%2BNTw%3D%3D.ca15OVhueWc4eby1f5idK1KGXaxCzfKBTh%2BVrhKe3CJnMSEG0aSwZvDNzo77ruuv" rel="nofollow" target="_blank">前往我们的博客查看</a>。</p><p><strong>NocoBase 目前更新包括的版本更新包括三个分支：<code>main</code> ，<code>next</code>和 <code>develop</code>。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045493251" alt="version.png" title="version.png"/></p><p><code>main</code> ：截止目前最稳定的版本，推荐安装此版本。</p><p><code>next</code>：包含即将发布的新功能，经过初步测试的版本，可能存在部分已知或未知问题。主要面向测试用户，用于收集反馈和进一步优化功能。适合愿意提前体验新功能并提供反馈的测试用户。</p><p><code>develop</code>：开发中的版本，包含最新的功能代码，可能尚未完成或存在较多不稳定因素，主要用于内部开发和快速迭代。适合对产品功能前沿发展感兴趣的技术用户，但可能存在较多问题或不完整功能，不建议在生产环境中使用。</p><h2>main</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045409634" alt="main.png" title="main.png" loading="lazy"/></p><h3><a href="https://link.segmentfault.com/?enc=1GFD9Q8Ycxps4moJLup3yw%3D%3D.IlijwsfoyqH50%2FZ31KW1Pim%2FVyXMDO0leRifYx7CM2PIDuCIgmZYelfLTqjtxk3n" rel="nofollow" target="_blank">v1.9.14</a></h3><p><em>发布时间：2025-11-27</em></p><h3>🎉 新特性</h3><ul><li><strong>[认证：OIDC]</strong> 支持选项 当用户未登录时自动跳转到 SSO 登录页 by @heziqiang</li></ul><h3>🚀 优化</h3><ul><li><strong>[client]</strong> 对消息内容的变量使用三重括号，以免变量被 Handlerbars 转义 (<a href="https://link.segmentfault.com/?enc=jU2E41sVNk5x%2Fxiocr%2FLGg%3D%3D.ZAdKxeXjKOGuKDPMwR5CTcqQv7YAm3TSESXHW8YkDBoauLcFKj2Lvba9y8N1%2FtIL" rel="nofollow" target="_blank">#7972</a>) by @mytharcher</li><li><strong>[数据表字段：Markdown(Vditor)]</strong> 调整 Vditor 全屏时内容宽度 (<a href="https://link.segmentfault.com/?enc=2BVjU1i4BTK0vosnYEN%2Fxg%3D%3D.CEh7nkCkXOH58%2F%2BQquS0wr5k1bWprmKT1g5m8FRI3Kqq2MeI%2Fd6NDwZNtwZgv2XH" rel="nofollow" target="_blank">#7974</a>) by @katherinehhh</li></ul><h3>🐛 修复</h3><ul><li><strong>[database]</strong> 修复：移除 time 字段转换中的 UTC 处理，避免因时区导致的纯时间值偏移 (<a href="https://link.segmentfault.com/?enc=7zVslpc6EbBalScqvTdLEQ%3D%3D.iXUi3a%2BaCjmo5UMG5w8QzWqwAQifkdnySUS%2FgIdBXQgyTxQVg%2BCaFnqFw90BpUOt" rel="nofollow" target="_blank">#7812</a>) by @ChimingLiu</li><li><strong>[client]</strong> 修复 下拉列表组件在非对象值回显时没有正确显示 label 问题 (<a href="https://link.segmentfault.com/?enc=pvVysHbVbfCra%2BBFE2O2ew%3D%3D.gq%2FrhDybKlQZawbzrw6GZhq3urlNa90GrgEKwHH7RXtmEM8gbs%2FitzLoHlUjeMVe" rel="nofollow" target="_blank">#7975</a>) by @katherinehhh</li><li><p><strong>[工作流]</strong></p><ul><li>修复停止服务前，已创建的执行计划未发送到队列的问题 (<a href="https://link.segmentfault.com/?enc=JYMg2dNZqVEWuwbmrDzBkg%3D%3D.ThZEL2BpMg4PUnb%2FTaZJL9vpB9m17mc6E3WyQhwOa9vLv1WCYc5kD9goCoCOT5Yt" rel="nofollow" target="_blank">#7981</a>) by @mytharcher</li><li>修复点击默认进入的待办列表中的任务跳转到错误页面的问题 (<a href="https://link.segmentfault.com/?enc=Z4Sx0S0K72ep55NT%2BFavcQ%3D%3D.3sjJpY4AZh4q7rcxAFs1kmOekR%2FB6oqCfzAnHwsmVc7H1yo4FqxM62dmnsMsHeS4" rel="nofollow" target="_blank">#7983</a>) by @mytharcher</li><li>修复部分工作流待办菜单不显示的问题 (<a href="https://link.segmentfault.com/?enc=GJ9pA6%2Br%2FKjta83aofCIPQ%3D%3D.2ooNa3mYKoKc%2BvMx0KKttNzXwPmiv51%2BsHc7R7MKGZdZbjWvqe2oZfPaWgRH9m9x" rel="nofollow" target="_blank">#7980</a>) by @mytharcher</li><li>修复由于 provider 误用导致待办总数不展示的问题 (<a href="https://link.segmentfault.com/?enc=qp%2BpuEGwrEiGN2k6GV%2Fv3A%3D%3D.Y8QveDnJi0H3fYIOm8LnNr3sOswjuZHI8133%2F8K90voRn0PZmvGjw3WlJfPeD7P9" rel="nofollow" target="_blank">#7968</a>) by @mytharcher</li></ul></li><li><strong>[工作流：人工处理节点]</strong> 修复人工待办任务统计数字不对的问题 (<a href="https://link.segmentfault.com/?enc=F4CJ9%2BmSRrvv0gXqBwmIEQ%3D%3D.8HxPh38y2920DZurTnxkNi4uYbIcOxWvDSWN9zc07wELRhaDiZYTJ897oFf7q4ZS" rel="nofollow" target="_blank">#7984</a>) by @mytharcher</li><li><p><strong>[数据可视化]</strong></p><ul><li>外部数据源表的筛选字段的配置项不能显示特有属性 (<a href="https://link.segmentfault.com/?enc=0%2FnmLbFWzRwIzxdCcOv5Bw%3D%3D.7qX5XR18LvMsALuCQac9EbdtlROK3AoDomYg1abJFKxAn1uSPfKb6gfvv1eK2b2R" rel="nofollow" target="_blank">#7982</a>) by @2013xile</li><li>解决图表数据查询不支持 ACL 数据范围的问题 (<a href="https://link.segmentfault.com/?enc=jE3gc%2FvkM2lo3x71dhh%2BJQ%3D%3D.vFaZkgqrJLFvZn0aOZCxGBV3Dyu9br9gTm2lecHYZCyNnTu5vF6BtT%2B%2FtexfoKC3" rel="nofollow" target="_blank">#7915</a>) by @2013xile</li></ul></li><li><strong>[数据源管理]</strong> 修复外部数据源修改密码后系统内无法更新密码的问题 (<a href="https://link.segmentfault.com/?enc=%2Fzly36A61SFpZJ5EPpCblw%3D%3D.U%2FmB8kKWgSJOopMi5FdyNSczsPOSj%2BFZa7uWgHES%2F041vwi18RBTQ%2Bq%2F%2FbcsmFiI" rel="nofollow" target="_blank">#7977</a>) by @cgyrock</li><li><strong>[操作：导入记录]</strong> 修复树表导入数据报错问题 (<a href="https://link.segmentfault.com/?enc=aJQ9h7RMExpvWJyh5XtPZw%3D%3D.FWOiH8m1h9CC8L3z98v8kuxdTgMX6YEgssAZ1KPlnfSfkjYkIGd3naOCgZpUVTKJ" rel="nofollow" target="_blank">#7976</a>) by @cgyrock</li></ul><h3><a href="https://link.segmentfault.com/?enc=jRSKVsW4BeoSb9sCo56FFA%3D%3D.%2BuhgcYWgu3%2B%2BmLGJzgYVvEZD77uPrHNyctdHIA1M32%2BP%2FkmXOP1ZdiaLnTDeO4Nm" rel="nofollow" target="_blank">v1.9.13</a></h3><p><em>发布时间：2025-11-25</em></p><h3>🐛 修复</h3><ul><li><strong>[client]</strong> 修复使用 Iframe 时，导致路由异常的问题 (<a href="https://link.segmentfault.com/?enc=j3YepCsV6590kgVO7ysJog%3D%3D.ok3nq7t5zZ1vSvifHECqWNzX4Bo9vF7jAM6C4OInEJCNOzL%2BR9yTXaKRzmJTSgLz" rel="nofollow" target="_blank">#7957</a>) by @zhangzhonghe</li></ul><h3><a href="https://link.segmentfault.com/?enc=OIjSoo9D8dPIR9QLduf%2B4A%3D%3D.1zixTU%2Fs9GZrq%2FOcYeFXTsHjcVtz9bsN7au%2BoQicDY%2Fi08rGQZyU8aVrB1Ug6MZR" rel="nofollow" target="_blank">v1.9.12</a></h3><p><em>发布时间：2025-11-24</em></p><h3>🚀 优化</h3><ul><li><strong>[client]</strong> 为更新记录和删除记录操作按钮添加加载状态，以避免重复请求 (<a href="https://link.segmentfault.com/?enc=UV6klEzdMWMr%2FslwN0qb2Q%3D%3D.Bm2FOn2FAznC1PAb3FBrnl916GfIr2XlqNcFPpzAGa7zzcN6ZMhaqdpESumxbLcZ" rel="nofollow" target="_blank">#7964</a>) by @mytharcher</li><li><strong>[异步任务管理器]</strong> 优化异步任务的错误信息，任务失败时将明确提示具体的错误原因 (<a href="https://link.segmentfault.com/?enc=sh3Xe8tPvPCf00jIu%2BynCQ%3D%3D.M5a4g4imBzdQTzV8%2FqtfhO8z9muOzwFZHZdK7r%2FkYSKpXGzle11jrjg0MJ83XJu1" rel="nofollow" target="_blank">#7796</a>) by @mytharcher</li><li><strong>[操作：导入记录 Pro]</strong> 优化异步任务的错误信息，任务失败时将明确提示具体的错误原因 by @mytharcher</li><li><p><strong>[工作流：审批]</strong></p><ul><li>修复审批人选择组件，仅允许用户表的主外键可选 by @mytharcher</li><li>减少打开审批弹窗时加载的关联数据，以提供更好的性能表现 by @mytharcher</li><li>在手动执行（或子流程调用）时，同时支持传入整行数据或仅主键，避免触发器数据中的数据一致性问题 by @mytharcher</li></ul></li></ul><h3>🐛 修复</h3><ul><li><strong>[异步任务管理器]</strong> 为 <code>asyncTasks</code> 数据表增加迁移规则，避免异步任务记录被迁移 (<a href="https://link.segmentfault.com/?enc=vVuvfEbBH%2B2cq7Wx7FZoJA%3D%3D.wYskPbZlZyfClYzfcrQkFiJqX40RQLLnEHp3TIkMR89R%2BiXUZKRUDeV5Movzq6vA" rel="nofollow" target="_blank">#7950</a>) by @mytharcher</li><li><strong>[工作流：审批]</strong> 修复语言文件 by @mytharcher</li></ul><h3><a href="https://link.segmentfault.com/?enc=NRfkxXRQQhhayxaktUWbIw%3D%3D.WpcrLNN%2Bdv4QxLm7kdCBi53Y1L9PVPJ2apy90WzaqH898F7524BC6PN5LEC5iyS7" rel="nofollow" target="_blank">v1.9.11</a></h3><p><em>发布时间：2025-11-24</em></p><h3>🐛 修复</h3><ul><li><strong>[client]</strong> 修复外部数据源配置 belongsTo 字段时，field interface 显示为 many to one 而非 one to one 的问题 (<a href="https://link.segmentfault.com/?enc=YLGKYf8%2BM43JQMQeAc8CwA%3D%3D.8Vzl1C0slKd52ZJOW0T%2FJjtkoDOO565fWOBG%2F2B6UAlWzC%2FtfeYRTBKSDquDLJ6F" rel="nofollow" target="_blank">#7936</a>) by @cgyrock</li><li><strong>[工作流]</strong> 修复了更新待办数量时意外导致填写中的表单状态被重置的问题 (<a href="https://link.segmentfault.com/?enc=LpFiLom1%2BRHqNBvjBRX5Nw%3D%3D.hUconkUtMeE4%2BGahZE6srdiWiK4QYm1ulu5%2BjsHWkiI0RRilUw2ganernc7wsB7k" rel="nofollow" target="_blank">#7937</a>) by @mytharcher</li><li><strong>[数据表字段：多对多 (数组)]</strong> 修复多对多（数组）字段在新增/修改关联数据时的异常行为 (<a href="https://link.segmentfault.com/?enc=blKwu6OtbJS7MXfyyMXnbg%3D%3D.12wdYjoIatwBz8rKGCXGhStVOIUxqaWcZJjGIwAlQkbKtKF8moZpmd25%2F9vipRMb" rel="nofollow" target="_blank">#7926</a>) by @cgyrock</li></ul><h3><a href="https://link.segmentfault.com/?enc=ncV3791CZiLLO0Jap6NrCQ%3D%3D.E6rSAAK%2BviMzu%2FXNaQucJaaShLHogQDJs5wJV3Jgbx4J0h4wPHlUGJpBz81Rqxxo" rel="nofollow" target="_blank">v1.9.10</a></h3><p><em>发布时间：2025-11-20</em></p><h3>🚀 优化</h3><ul><li><strong>[权限控制]</strong> 缩小 member 角色的默认权限 (<a href="https://link.segmentfault.com/?enc=I6OxtNOPk6PfnFCk%2B7btlw%3D%3D.ciDjM0%2BuvYwKYTyF4litv%2FgoMQiGVoOElII%2BfuoLWfSOoqpXigHorAMXu3BjQ4MF" rel="nofollow" target="_blank">#7921</a>) by @2013xile</li><li><strong>[数据可视化]</strong> 为插件界面添加了俄语支持。 (<a href="https://link.segmentfault.com/?enc=dBQDL%2FfU%2B%2FK11MMS7KRFPw%3D%3D.Pw2yWHwWMEuHQpG4qda1UMdZFO%2Fs1vp9tSqOfwxNrtD%2Fe78olI1UYGX%2BxYhMxUcl" rel="nofollow" target="_blank">#7676</a>) by @sembaev-a-a</li><li><strong>[工作流：Webhook 触发器]</strong> 为响应节点增加图标 by @mytharcher</li></ul><h3>🐛 修复</h3><ul><li><strong>[client]</strong> 修复错误： Can't resolve 'antd-mobile' 和 Can't resolve 'antd-mobile-icons' (<a href="https://link.segmentfault.com/?enc=h9wu06upDq43iOKh%2FBgtOg%3D%3D.4T8CMXNUI9UxIw2KLwXrj9t4HtcPlmPQ9CjGX2WQWz3Ef5aeGtd5oN2TM5SSlGqh" rel="nofollow" target="_blank">#7914</a>) by @zhangzhonghe</li><li><strong>[权限控制]</strong> 关系字段关联操作支持数据范围限制 (<a href="https://link.segmentfault.com/?enc=Ob1m1EF7uAQdTbjCGhvSJQ%3D%3D.5RC1RVSXoqu4qHjllIm9yiThGFkqvBRyRlEg8tmYAYtfKFmE5J%2BcNuQMymWJ21f9" rel="nofollow" target="_blank">#7919</a>) by @2013xile</li><li><strong>[数据源：主数据库]</strong> 修复增加一对多字段后在重启应用前无法选择外键字段的问题 (<a href="https://link.segmentfault.com/?enc=sHlMrVtM9rxajtTj%2FSQjmA%3D%3D.RofbDqZVW6eBOSzWIvH0%2FAWPCVGqtm5g0PBAi4i8Di2HWpDP3M2f7Yq6TXF%2Ftyl6" rel="nofollow" target="_blank">#7907</a>) by @cgyrock</li></ul><h2>next</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045409635" alt="next.png" title="next.png" loading="lazy"/></p><h3><a href="https://link.segmentfault.com/?enc=YUdRGK2bvb8dhf96Uz9TSw%3D%3D.qsLutQEK%2B2fs6lfFnyoJAq8x%2BgHmmynJqTftTG9MQVlOgRudUkOZ8Xqkv7vvz3Fa" rel="nofollow" target="_blank">v1.9.0-beta.17</a></h3><p><em>发布时间：2025-11-21</em></p><h3>🚀 优化</h3><ul><li><strong>[database]</strong> 对 MariaDB 连接实例增加 <code>multipleStatements</code> 选项，以支持一次查询中调用多条语句 (<a href="https://link.segmentfault.com/?enc=xcWKzawsuDuMkpVhTnbG3w%3D%3D.1dYqaIkn3gqkzNEje6GX4X0A48KUe8cx81LUOOSkRe%2FSXX7A2jNx8h6jPvkDKsPZ" rel="nofollow" target="_blank">#7781</a>) by @mytharcher</li><li><p><strong>[权限控制]</strong></p><ul><li>缩小 member 角色的默认权限 (<a href="https://link.segmentfault.com/?enc=CIP7vtoApoaXU%2Bp1tIUlMQ%3D%3D.c25UtleEv6qBe%2BS53%2FFb8QxZPNOHeNrSdW77a%2FIZW%2BwDJlvkgCJjwUdnVEseZR%2Fd" rel="nofollow" target="_blank">#7921</a>) by @2013xile</li><li>优化关系字段关联操作的权限控制逻辑 (<a href="https://link.segmentfault.com/?enc=kW0QDsj1JpJxC8MlT1XZtw%3D%3D.NPj8L3M%2Fxzuge6D5NcYvc0f7HF%2F50%2BS9VTvHxA4GWIQKp7aabr%2BzT6ZcB82oT7GB" rel="nofollow" target="_blank">#7800</a>) by @2013xile</li></ul></li><li><strong>[数据可视化]</strong> 为插件界面添加了俄语支持。 (<a href="https://link.segmentfault.com/?enc=Lx1DRIndj%2B0Gc9br2SGz1w%3D%3D.KEkMfp2lkwlyWEFW07XK9JfhKOw9a%2F6FwKYFyCWWmR0xwEk9K9j4Bj9t5er5xoSg" rel="nofollow" target="_blank">#7676</a>) by @sembaev-a-a</li><li><strong>[工作流]</strong> 支持工作流中的数据区块使用一致的详情区块配置菜单 (<a href="https://link.segmentfault.com/?enc=r2KZNuVgzAidW0D2hOR47g%3D%3D.PJf%2F6OEEt1k6p6843AEUsu9MZ%2BpWVkjVEP2z9SPVXXTkeLHocePiboMa0Rp0N%2F9U" rel="nofollow" target="_blank">#7771</a>) by @mytharcher</li><li><strong>[工作流：Webhook 触发器]</strong> 为响应节点增加图标 by @mytharcher</li><li><strong>[工作流：JavaScript 节点]</strong> 修复传递到执行环境中的上层函数导致的安全漏洞，避免通过利用漏洞访问上层执行环境的问题 by @mytharcher</li><li><strong>[认证：OIDC]</strong> 增加请求超时时间 by @2013xile</li><li><strong>[工作流：审批]</strong> 在转签和加签时通知新的审批人 by @mytharcher</li></ul><h3>🐛 修复</h3><ul><li><p><strong>[client]</strong></p><ul><li>修复外部数据源配置 belongsTo 字段时，field interface 显示为 many to one 而非 one to one 的问题 (<a href="https://link.segmentfault.com/?enc=%2FNyPrfAdMLNllifPuEylJA%3D%3D.kEtjiti%2B5Di%2FgqTlq60P0OnaZctjedJB8l3F86MwJvRjQQI9imU%2F8Jo%2FPpwh9JoY" rel="nofollow" target="_blank">#7936</a>) by @cgyrock</li><li>修复错误：Can't resolve 'antd-mobile' 和 Can't resolve 'antd-mobile-icons' (<a href="https://link.segmentfault.com/?enc=r%2Fxs%2F3MT2z3aTCNzHKuYJQ%3D%3D.ePIKPeTXReRxJdAQhUtil6Ufg%2BmrCXgickcuoaJuJHGMixcoRs6GSxBCPuFXB5ZI" rel="nofollow" target="_blank">#7914</a>) by @zhangzhonghe</li><li>修复拖拽引用模板后再删除引用模板而导致的复制模板不显示的问题 (<a href="https://link.segmentfault.com/?enc=ax%2BoLchl1Td%2F5PvIoh61Dw%3D%3D.%2FS7gHAt4Hvzgev%2Bjs5ZTqSjoO8KAzWdLLkQqnEDGJj5i4P1ZvkFXM6F%2F82pZG773" rel="nofollow" target="_blank">#7847</a>) by @zhangzhonghe</li><li>修复审批表单的联动规则不生效的问题 (<a href="https://link.segmentfault.com/?enc=u8XTF2ExnYTlpALU6rShVA%3D%3D.Z3B0RgrwcBTCAqETMoTyAGlNByf1DiIRc48r8aVZl2Fm9waG%2F%2F4t7fjOdAQmiO3N" rel="nofollow" target="_blank">#7858</a>) by @zhangzhonghe</li><li>修复详情区块简单分页出现空数据下一页的问题 (<a href="https://link.segmentfault.com/?enc=G%2BfcWEc2rUQmdsAq9ZA%2FDw%3D%3D.j7UVXM%2FFCeuqrClncYEWy%2B%2FXqINcihXFKTykXgmYjS0ZcJsU6IkBVnTT%2BYaZBU4e" rel="nofollow" target="_blank">#7784</a>) by @katherinehhh</li><li>修复 “Maximum call stack size exceeded” (<a href="https://link.segmentfault.com/?enc=zWUQ%2FJ%2B3h9pX94lpcsWZxA%3D%3D.756XUSZgmpK7I5tj9xdeFsIOKdV2T8tQHhHcpzmNjOpVo6GC1%2B2q4eXfj8lmiegu" rel="nofollow" target="_blank">#7780</a>) by @zhangzhonghe</li></ul></li><li><p><strong>[server]</strong></p><ul><li>修复服务拆分模式下未订阅无法发布队列消息的问题 (<a href="https://link.segmentfault.com/?enc=NH4eFZte0XoEza2WZ3mM9w%3D%3D.0K0te6JiK6J3wFLrqh71%2BJY8YiokhpuMtmxG0QeaIrLgO7xr%2FB2xQSs9cVdl%2F8zq" rel="nofollow" target="_blank">#7875</a>) by @mytharcher</li><li>使用应用名称隔离发布订阅的频道 (<a href="https://link.segmentfault.com/?enc=MQcXItof6vDss6HnTzb%2BKg%3D%3D.8AtiOzem%2BWIMsS0X9wzGNjQ3VyJoa0zu%2FvSe6qHbsbKgg2wJX4ROMflCB8q6B%2FVe" rel="nofollow" target="_blank">#7762</a>) by @mytharcher</li><li>修复消息队列在启用服务拆分模式后，工作进程发消息导致报错的问题 (<a href="https://link.segmentfault.com/?enc=Vj7%2Bas%2FyqS5jzy766S5hZw%3D%3D.i2M%2B5SiOA4SQ0yYPzuW0cSB1jchPA0QpSdfgfFKLIwZzbciw8Ct57t9xj73iX8Lr" rel="nofollow" target="_blank">#7797</a>) by @mytharcher</li></ul></li><li><strong>[utils]</strong> 为 intersect 策略增加对象类型支持 (<a href="https://link.segmentfault.com/?enc=IuONu56u9UaOWH%2Fdx2y5yA%3D%3D.4Kd3KE8AQbqhiiOFCMfO7HFAgFjI7Zo7czEhcKKbMYmJfkRbjqkHOy7CLuAmQt7u" rel="nofollow" target="_blank">#7840</a>) by @chenos</li><li><strong>[database]</strong> 字段名为 snake_case 风格时，索引字段判断不正确的问题 (<a href="https://link.segmentfault.com/?enc=B5W0E5vtKf9tupV6efvE3A%3D%3D.AFgNWOfzi0rZ8UUXDlJ9pHmu20uIMJ4ZdBscUQZtUBFCM%2B4vPn4KoIpTYKGNX856" rel="nofollow" target="_blank">#7776</a>) by @2013xile</li><li><strong>[数据表字段：多对多 (数组)]</strong> 修复多对多（数组）字段在新增/修改关联数据时的异常行为 (<a href="https://link.segmentfault.com/?enc=3aC3qFhNd9xS%2FPWpbHIv2g%3D%3D.qPq0VFqoBdqHccX7Kuqcg87l4vCdD%2Fcj6RqUsEY5z9u3SJ67XA%2F3rF3mOnlCJwX0" rel="nofollow" target="_blank">#7926</a>) by @cgyrock</li><li><strong>[数据源：主数据库]</strong> 修复增加一对多字段后在重启应用前无法选择外键字段的问题 (<a href="https://link.segmentfault.com/?enc=LDM4rGonCsGuhNBuH7P%2BEg%3D%3D.zTvh0DgBx6bKQKbRR5eYBDZ2c59N3KCjV5%2BCtzUBjkedLaX8BFRWNx84Hrtv9kcf" rel="nofollow" target="_blank">#7907</a>) by @cgyrock</li><li><p><strong>[工作流]</strong></p><ul><li>修复了更新待办数量时意外导致填写中的表单状态被重置的问题 (<a href="https://link.segmentfault.com/?enc=8AmyjII60a2hHy92bHBHxQ%3D%3D.wOk7Q01Q1l%2FIG7GoBg5JiE%2FX9hyLTu09%2F5qW59KqLL%2Bx5ng7k90xo79Fs52SPvso" rel="nofollow" target="_blank">#7937</a>) by @mytharcher</li><li>使用底层事件队列代替共享后台任务队列，以避免共享队列在服务拆分模式下会被错误消费的问题 (<a href="https://link.segmentfault.com/?enc=DgRS6kxVGzzJKm7SMTDcIw%3D%3D.9OyVRJXNvTFyySCTT81Aaip79vCv2B7rSKmGVdhYQT0BqTAhN84MCLed6LYhfjtU" rel="nofollow" target="_blank">#7871</a>) by @mytharcher</li><li>修复服务拆分模式下，工作流插件不处于服务模式时仍然消费队列的问题 (<a href="https://link.segmentfault.com/?enc=SbAYyrpL1ksIJuVzsxOLYw%3D%3D.3KWt38qztasB65PJ57FVreA272sosIftFKcHEz8pM80qa19764DIr1fLk6nOxhb6" rel="nofollow" target="_blank">#7820</a>) by @mytharcher</li><li>修复监听不存在的外部数据源事件产生的报错 (<a href="https://link.segmentfault.com/?enc=F7i8mGxXs1ryjUbtiKG%2BbA%3D%3D.VYdIONmTS8vpkAgNFUzg%2Fp%2BSZ2KGhq%2BfFtA9MX%2ByEh%2FfVslHFfggA7a3IoXe88E%2B" rel="nofollow" target="_blank">#7855</a>) by @mytharcher</li><li>修复在服务拆分模式下，手动执行带中断节点的工作流一直等待的问题 (<a href="https://link.segmentfault.com/?enc=MUUxTudmnxAImxGDXXRxwQ%3D%3D.0yOeuJWoqHQbLiuoOWsbgsPIJ8tQfvJGcKnMVFE86GF7IyVxPVVTyrDuvitkHaRX" rel="nofollow" target="_blank">#7767</a>) by @mytharcher</li><li>为工作流的日志增加 <code>workflowId</code> 的数据标识 (<a href="https://link.segmentfault.com/?enc=01YuNnlXEVlk8wv5%2Bt7v3Q%3D%3D.fRtd33xLYUPHRTMA3zUPFYZbbtHJC%2Bu4tElxvXkOetaghvKQPPE%2FIg2nhoC1Oizm" rel="nofollow" target="_blank">#7789</a>) by @mytharcher</li><li>修复了集群模式下工作流调度器无法正确识别空闲状态的问题，该问题可能导致插件未就绪就开始消费队列事件 (<a href="https://link.segmentfault.com/?enc=O3DBPcU%2FwgDcK8%2F7WjcqmQ%3D%3D.LhzkYGEK7p63o3tcU22gw77w3wi6uuk5rB7bF5dXl8q%2FBexLpVLgmnHsVgD62%2BdB" rel="nofollow" target="_blank">#7768</a>) by @mytharcher</li></ul></li><li><p><strong>[权限控制]</strong></p><ul><li>关系字段关联操作支持数据范围限制 (<a href="https://link.segmentfault.com/?enc=4392BDXICRAGH6OdyqEWVw%3D%3D.GVdtVwGFlg8eQO7W3sOBGhS%2FKFmfEXsjTcybauzsejFiCCxoBLMY6exLwtRChNuf" rel="nofollow" target="_blank">#7919</a>) by @2013xile</li><li>关系字段关联操作 snippets 不生效的问题 (<a href="https://link.segmentfault.com/?enc=P0fpgGWHedmTCVsaKZzquQ%3D%3D.zA7wyw%2BjFx7rkWGMLaxs46Yx1xHA5%2BSuDzPCeV6vmKSe7wiqeVpdV7p9QeKfnwf9" rel="nofollow" target="_blank">#7876</a>) by @2013xile</li></ul></li><li><strong>[工作流：人工处理节点]</strong> 修复翻译语言指向的命名空间，以正确的翻译内容 (<a href="https://link.segmentfault.com/?enc=1X37g1Gju79Ch4Ex%2B2%2FgKg%3D%3D.xHlJm5pUgX9PNXR7Tq9aj%2B5BGb%2FwJvj5t9YwP5%2B7wMn2zIi7T1DtMTHmUSyzjE8v" rel="nofollow" target="_blank">#7877</a>) by @mytharcher</li><li><strong>[用户]</strong> 字段名为 snake_case 风格时，索引字段重置不正确的问题 (<a href="https://link.segmentfault.com/?enc=mXnAPCd6QFkRVWyXOqFXwQ%3D%3D.yo9HG%2B4AAHC730Az5CTko8Tox6I5kArAQEE5aYkf%2BxuVRpB5krX05dvrfSuKozAN" rel="nofollow" target="_blank">#7785</a>) by @2013xile</li><li><strong>[移动端（已废弃）]</strong> 修复移动端的日期字段默认值弹窗无法选中日期的问题 (<a href="https://link.segmentfault.com/?enc=6BHOH2wnB8BREwYOf9%2FntA%3D%3D.41fVPkcMx1R1UALihsX%2BZQla6nS6aa7TemeM9%2FHjEGa%2Fe8ttmv7riRDpb%2FFzpBbl" rel="nofollow" target="_blank">#7783</a>) by @zhangzhonghe</li><li><strong>[工作流：自定义变量节点]</strong> 修复变量节点缺失 config 时报错的问题 by @mytharcher</li><li><strong>[工作流：自定义操作事件]</strong> 修复监听不存在的外部数据源事件产生的报错 by @mytharcher</li><li><strong>[模板打印]</strong> 解析 filter 中变量 by @jiannx</li><li><strong>[数据可视化：EChrats]</strong> 修复 Echarts 选项配置 Label type 不生效的问题 by @heziqiang</li><li><p><strong>[工作流：审批]</strong></p><ul><li>修复待办中心审批列表卡片上的日期格式，展示完整的日期和时间 by @mytharcher</li><li>修复通知渠道分页数量太小加载不全的问题 by @mytharcher</li><li>修复提交审批处理时查询审批记录列表的性能问题 by @mytharcher</li><li>修复重查关系数据时未屏蔽主表字段的问题 by @mytharcher</li><li>修复由于多个审批人并发处理审批时的竞态导致的节点重复执行的问题 by @mytharcher</li><li>并行分支中不再支持创建审批节点，避免流程状态导致的问题 by @mytharcher</li><li>修复审批表单的联动规则不生效的问题 by @zhangzhonghe</li><li>修复复制审批工作流时报错的问题 by @mytharcher</li></ul></li><li><p><strong>[邮件管理]</strong></p><ul><li>添加同步日志 by @jiannx</li><li>没有时间戳的情况下同步微软邮件已读状态 by @jiannx</li><li>mailMessages 添加索引 by @jiannx</li><li>给索引添加迁移脚本 by @jiannx</li><li>修复 Outlook 内敛图片和同步问题 by @jiannx</li></ul></li></ul><h2>develop</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000045493252" alt="develop.png" title="develop.png" loading="lazy"/></p><h3><a href="https://link.segmentfault.com/?enc=pl4WiBIoLETFfCytWKjQLA%3D%3D.3hz3XqdsT8t9mMew5f7YNTTZpkNouyy4zNcaJJPG%2FB2fBNVjRf6sZTRqnCBH27E%2FENTcrR4alXnKn%2Fc82SV%2Bmw%3D%3D" rel="nofollow" target="_blank">v2.0.0-alpha.47</a></h3><p><em>发布时间：2025-11-26</em></p><h3>🚀 优化</h3><ul><li><p><strong>[client]</strong></p><ul><li>支持在图表查询初始时选择筛选字段 (<a href="https://link.segmentfault.com/?enc=v8xMnCHCU1Y3rif3oBp2uA%3D%3D.P9Q1XhpbestAaCy8Kg9gVG9uDItXdZEH8JIbsOPh7JkyQ37Pq4O%2FxTVpAkxQQo%2FR" rel="nofollow" target="_blank">#7933</a>) by @heziqiang</li><li>对消息内容的变量使用三重括号，以免变量被 Handlerbars 转义 (<a href="https://link.segmentfault.com/?enc=ij7P7bbbWzU47I2KCGc6uA%3D%3D.sEKkeHjRlijTln609RaKPnNCHKcSuzgIcDn5BvJMITmhCI1IACnvxM4v8T39ZWsK" rel="nofollow" target="_blank">#7972</a>) by @mytharcher</li><li>为更新记录和删除记录操作按钮添加加载状态，以避免重复请求 (<a href="https://link.segmentfault.com/?enc=Jshl%2BOOoGAUyYz7%2FjHRKsw%3D%3D.ibVJ2Mw2FtSAx%2BixFBFXxw2ucZISw%2BI0H6OxM6G5E3y7hxTd3dDIVF%2Bcw%2F1eEHfo" rel="nofollow" target="_blank">#7964</a>) by @mytharcher</li></ul></li><li><strong>[数据表字段：Markdown(Vditor)]</strong> 调整 Vditor 全屏时内容宽度 (<a href="https://link.segmentfault.com/?enc=khGXOQsP2ELwoIHqKPnJzg%3D%3D.4emkvbTFWFQ53QMt0QgzuoxL6doms%2BKuUtvHG46qcMcpQKKCG9m9nDeQ82iIqZ9P" rel="nofollow" target="_blank">#7974</a>) by @katherinehhh</li></ul><h3>🐛 修复</h3><ul><li><p><strong>[client]</strong></p><ul><li>修复非 id 关系字段弹窗详情区块打开报错。 (<a href="https://link.segmentfault.com/?enc=AjPmAHEOR4He3%2BJ9sqCZvw%3D%3D.o1N0QLu0lzzOOWe1eMjtNq74rqg5ArcSkythaqn9nWvMYf7qF4D0JHcqLobADQwS" rel="nofollow" target="_blank">#7973</a>) by @gchust</li><li>修复非 id 关系字段弹窗中关系数据加载错误的问题。 (<a href="https://link.segmentfault.com/?enc=GjGGlmUYs1ANRu9L%2Ba0h7g%3D%3D.uboD1l4w616oDlzfHoGlz7i96ZWZW%2F0qjhHbrcJa%2B7CuOg%2FIsJr9Pr3ebOoEgaFA" rel="nofollow" target="_blank">#7970</a>) by @gchust</li><li>修复使用 Iframe 时，导致路由异常的问题 (<a href="https://link.segmentfault.com/?enc=72G19HIsbPhis9CbAq5XHA%3D%3D.T%2FoavSk7fca8TJpvw9eAu1oF1Qmlvg3uetEeNg%2BHksPyyehwX%2FtfZJ326AkYsFRr" rel="nofollow" target="_blank">#7957</a>) by @zhangzhonghe</li><li>修复数字字段格式化精度设置无效的问题 (<a href="https://link.segmentfault.com/?enc=HaOJuF3k7Et2w9TKO6JYoA%3D%3D.Q38xFMR29j4vjG%2FpGW%2FbcxkWh%2BgtTo2fcvrRnSlVrv9%2FUBV2zBdm1SfOoAmdugrT" rel="nofollow" target="_blank">#7967</a>) by @katherinehhh</li><li>修复新建 2.0 页面的类型不正确的问题 (<a href="https://link.segmentfault.com/?enc=ENzev3xZEwGdgx%2BwRi7sEA%3D%3D.AHg6VcaFqTYytFnLUB5AJAv%2FVPO%2B28KWeks0eATviIe%2FfkwRJQwvhCrXwi2Sguko" rel="nofollow" target="_blank">#7945</a>) by @zhangzhonghe</li><li>修复点击筛选重置按钮时筛选值未清空的问题 (<a href="https://link.segmentfault.com/?enc=Z98N0Zrs8fG4eSnIG17vrA%3D%3D.zAh7a5qzetHPEbs2leoqz27wYou4%2FNq62S%2BovQprf2EsXOnvo9fXfjQ3Mx23v9hR" rel="nofollow" target="_blank">#7966</a>) by @zhangzhonghe</li></ul></li><li><strong>[工作流]</strong> 修复由于 provider 误用导致待办总数不展示的问题 (<a href="https://link.segmentfault.com/?enc=ImK2iqt4eextoPG1%2FfcpCg%3D%3D.6AUjoBn7x1rb9A81HOEsystrSOjZhN5bT0%2FTBB%2FBb1cfl%2Bj0fSe6FMYmJZzJMWxv" rel="nofollow" target="_blank">#7968</a>) by @mytharcher</li><li><strong>[数据可视化]</strong> 解决图表数据查询不支持 ACL 数据范围的问题 (<a href="https://link.segmentfault.com/?enc=BB3InDcnoIdYYSyeHJjHAg%3D%3D.K7sub0%2FPxC%2FTp90r0Y9UfZEKMQ9rtmbomk79hCZC%2FOmsOMiX5WcveHJnqSScFDX4" rel="nofollow" target="_blank">#7915</a>) by @2013xile</li><li><strong>[区块：引用]</strong> 修复引用区块会将被引用区块从原始页面中移除的问题。 (<a href="https://link.segmentfault.com/?enc=FUg3iGLZwFQEZ2TovACA5w%3D%3D.ogrzqE0LO63eIlg%2BcQZhLnpctJyZzpSmxgl90CUDKbIPSyzRgm63DyRi94fQ6bxQ" rel="nofollow" target="_blank">#7969</a>) by @gchust</li><li><strong>[AI 员工]</strong> 修复AI员工生成 SQL 异常输出的问题 (<a href="https://link.segmentfault.com/?enc=qXAi43HCUIJet1cIBrutDA%3D%3D.i1jSf1i5wEnjga6YKMNl3s6sND65GqAUaXBvG0spCj%2FXSMmkYy4%2FfdpYt1kDylwz" rel="nofollow" target="_blank">#7956</a>) by @heziqiang</li><li><strong>[模板打印]</strong> 修复表格行中模板打印操作添加模板失败问题 by @katherinehhh</li></ul><h3><a href="https://link.segmentfault.com/?enc=t%2Fd1l8fIz6y%2BM33sdAb6zw%3D%3D.I5LLwS9AhcGyatqii%2FIZ%2BMnI91alWL92NgrW9QDvmVseTlXxQ4%2B%2BV4yOWrkYRYVcUZ1mmQJewoaC9pPmHdLLpw%3D%3D" rel="nofollow" target="_blank">v2.0.0-alpha.46</a></h3><p><em>发布时间：2025-11-24</em></p><h3>🚀 优化</h3><ul><li><strong>[flow-engine]</strong> 支持动态切换 flow model 类型 (<a href="https://link.segmentfault.com/?enc=gQnlruYDRcYsv%2BkgXNmMrQ%3D%3D.Snz4I3Qcc9uA0DtVRtg5bqt4BS7e8z%2BPkYjLcQeLrzYo%2FeOuVhne8OeZMIy70P6m" rel="nofollow" target="_blank">#7952</a>) by @gchust</li><li><strong>[AI 员工]</strong> AI 员工插件添加 upgrade 钩子函数 (<a href="https://link.segmentfault.com/?enc=KFDTCeoi7HcD%2BQYMOEjQ4w%3D%3D.t2Rn13BZ6KpJC3cjOfsmPxZAbHyS4%2B4wZocGWmL%2BnFvAx4BirJ45lTNwZFDPkw3%2B" rel="nofollow" target="_blank">#7951</a>) by @heziqiang</li><li><strong>[异步任务管理器]</strong> 优化异步任务的错误信息，任务失败时将明确提示具体的错误原因 (<a href="https://link.segmentfault.com/?enc=E1UNlb7OL3RIj%2Be8%2B6H9zw%3D%3D.zwPj2wiwFBiELLs1m9mQHHkKLk8dvs9MWpo2Ggju4TufYh%2BtWMPqVBSxyX%2FgrCJK" rel="nofollow" target="_blank">#7796</a>) by @mytharcher</li><li><p><strong>[工作流：审批]</strong></p><ul><li>在手动执行（或子流程调用）时，同时支持传入整行数据或仅主键，避免触发器数据中的数据一致性问题 by @mytharcher</li><li>减少打开审批弹窗时加载的关联数据，以提供更好的性能表现 by @mytharcher</li><li>修复审批人选择组件，仅允许用户表的主外键可选 by @mytharcher</li></ul></li></ul><h3>🐛 修复</h3><ul><li><strong>[client]</strong> 文本字段在详情区块中超出内容宽度时应默认换行 (<a href="https://link.segmentfault.com/?enc=edmrGWRsXajVwaDEQVT1Jg%3D%3D.AGiiimmwj12ed0E7Nw1AZvQPYZqL6%2BRbKG6oOWfNO5Xj0mpYWZZVRxBY1Iskd%2Fzz" rel="nofollow" target="_blank">#7955</a>) by @katherinehhh</li><li><strong>[异步任务管理器]</strong> 为 <code>asyncTasks</code> 数据表增加迁移规则，避免异步任务记录被迁移 (<a href="https://link.segmentfault.com/?enc=4Z%2Bru4IFH5EYwdnBdaRDgA%3D%3D.CpXrOzv%2F80%2BsXHyw7gdRky4ZskBSP%2BiUh7DE6p060YAHw1t1D5Xr6jaC3ot10hbC" rel="nofollow" target="_blank">#7950</a>) by @mytharcher</li><li><strong>[文件管理器]</strong> 修复表单附件字段上传未按设置使用指定文件存储器的问题 (<a href="https://link.segmentfault.com/?enc=R2xKUTF1QXpMILowi5ApEg%3D%3D.6WTJJUZazrYIJUW4RBAX%2BSAImAgFpGYvzqrjGdTYTynZKvTnmV4e3TGfsGlZEYMz" rel="nofollow" target="_blank">#7947</a>) by @katherinehhh</li><li><strong>[工作流：审批]</strong> 修复语言文件 by @mytharcher</li></ul><h3><a href="https://link.segmentfault.com/?enc=%2Bxp3hRH%2Bokgu2MW1pgDLYA%3D%3D.p8ab5pPOmdhpToKDu3V67Lkpdj2r7fUfWCo7KAWoEea1%2BUQvVadwwiP6rdz%2BvUb2po3c6sFH7onKbFsyeKgIrw%3D%3D" rel="nofollow" target="_blank">v2.0.0-alpha.45</a></h3><p><em>发布时间：2025-11-21</em></p><h3>🎉 新特性</h3><ul><li><strong>[client]</strong> 支持表格列字段开启排序 (<a href="https://link.segmentfault.com/?enc=ufydVtCFDM84tmpOhd0IBg%3D%3D.b1mw6RFCN%2B3loCUpyhroCnIO4I%2BgVbsBa1nbKbJqEJ34CRWSoonFFO1s0lbsYzFT" rel="nofollow" target="_blank">#7900</a>) by @katherinehhh</li><li><strong>[工作流]</strong> 新增“多条件分支”节点，提供类似 <code>switch</code> / <code>case</code> 的控制流程 (<a href="https://link.segmentfault.com/?enc=oxqjBKoJ4NCZvNv8xoFT%2FA%3D%3D.1ygAtDnuC9iRmvqSpkwVuWBPuWTikCMBZdM9%2BwZ7FyU%2B9cYEkwigBys90edjEaPy" rel="nofollow" target="_blank">#7878</a>) by @mytharcher</li></ul><h3>🐛 修复</h3><ul><li><strong>[client]</strong> 修复多级联选择器清空数据时报错的问题 (<a href="https://link.segmentfault.com/?enc=xx5cjbe8CWuHAJJk029oig%3D%3D.bBEPhg9CsVQijhiKuJiBwNhkpvx%2F8lOrTrcYi7OYki1BelOCdtNsH5X2mMaAaMXb" rel="nofollow" target="_blank">#7943</a>) by @katherinehhh</li><li><strong>[数据可视化]</strong> 修复图表配置保存后区块没有更新的问题 (<a href="https://link.segmentfault.com/?enc=92iEEY2G%2F8chTV00g%2FXLwA%3D%3D.vQAKZc4Ns8w%2BeehJ%2Bl7bvslef8KmcFRA9MilqBJOdelnCgxztJcTIIHduKJKkH46" rel="nofollow" target="_blank">#7920</a>) by @heziqiang</li><li><strong>[模板打印]</strong> 修复详情区块模板打印按钮报错问题 by @katherinehhh</li></ul><h3><a href="https://link.segmentfault.com/?enc=YG4RcPd5Pl3Yks5ZL5%2B9Jg%3D%3D.jTYEmRsZaKJ7eTgxl63fENSrY3%2BSwF1iHIOGpeMlRpcnDdMVRIcuduYLpJNsNkDBsqFM8Dnayod79%2FZYj8mAxg%3D%3D" rel="nofollow" target="_blank">v2.0.0-alpha.44</a></h3><p><em>发布时间：2025-11-21</em></p><h3>🎉 新特性</h3><ul><li><p><strong>[client]</strong></p><ul><li>为关系字段下拉选择器增加快捷新增能力 (<a href="https://link.segmentfault.com/?enc=bfXEeqN0gJ8oM0Aorv0rqg%3D%3D.Vq6olIBRzkR%2FBNq37tweWR2XeHhUYF8hyhewXFUgHSUcatyS8bBAjFLTHBLoX3Fd" rel="nofollow" target="_blank">#7887</a>) by @katherinehhh</li><li>支持树表关系字段使用级联选择器 (<a href="https://link.segmentfault.com/?enc=%2BgOHVvRJYngp5GCEHPm8Yg%3D%3D.%2BGmzmfVjBNnF6kYenZ6ZDqtq67jc9fHTlkHdZnhZbcq%2Fl1XBmE00ZWaJaDkveHTU" rel="nofollow" target="_blank">#7846</a>) by @katherinehhh</li></ul></li><li><strong>[遥测]</strong> 新增插件：遥测，基于 OpenTelemetry 的应用遥测插件，内置 CPU、内存、HTTP 请求等指标，并支持通过 HTTP 导出 by @2013xile</li></ul><h3>🚀 优化</h3><ul><li><strong>[telemetry]</strong> 支持控制需要上报的指标 (<a href="https://link.segmentfault.com/?enc=zTsgDnmHv4gWCwy0AGBNlA%3D%3D.oVmucpaVPyJWJUS%2FgvIBItfsRXjtsM%2FZ9FLLfp8r%2F%2B%2FxL66Uy1Vm3vm9eraIBs4O" rel="nofollow" target="_blank">#7938</a>) by @2013xile</li><li><strong>[异步任务管理器]</strong> 在子应用中执行异步任务时，异步进程只启动对应的子应用 (<a href="https://link.segmentfault.com/?enc=r3JcNqBCvYzVGhTod%2Fkd9A%3D%3D.o5q7QRFpSWEol1i4HhK59F%2FcQURgXqPsZmtIdqcFPM6Id1OxDRIVs1PSldL37m6V" rel="nofollow" target="_blank">#7927</a>) by @2013xile</li></ul><h3>🐛 修复</h3><ul><li><p><strong>[client]</strong></p><ul><li>修复树表按钮显示在非树表区块中的问题 (<a href="https://link.segmentfault.com/?enc=KZlwXhvvop8oNyjRsTy2Og%3D%3D.BsGtNUpdVAKcLm%2BqyEKMQGFiZ0CoEvBgyUXbW4ZHaANqzQ1emx5Cc9zVHaIasPKM" rel="nofollow" target="_blank">#7931</a>) by @katherinehhh</li><li>修复外部数据源配置 belongsTo 字段时，field interface 显示为 many to one 而非 one to one 的问题 (<a href="https://link.segmentfault.com/?enc=gk%2BEeB%2BlcuoDMlLSqHPoOw%3D%3D.jwEk7R%2FQ5%2B%2FBHWYr8f2Wo2GZdzmO1tu6unRiUmShVPCeNrU%2BDqvwZq84IPc24bmD" rel="nofollow" target="_blank">#7936</a>) by @cgyrock</li></ul></li><li><strong>[flow-engine]</strong> 修复详情区块按钮的工具栏图标显示错位的问题 (<a href="https://link.segmentfault.com/?enc=OC%2BNTBPdD909%2FQ%2BctT9qjQ%3D%3D.t3JuFFgK%2FxLS3OY8W15s6XWXM4rQq2I2aFaqoN7N1e1agZCpMhKPlaDec5jjcssZ" rel="nofollow" target="_blank">#7929</a>) by @zhangzhonghe</li><li><strong>[工作流]</strong> 修复了更新待办数量时意外导致填写中的表单状态被重置的问题 (<a href="https://link.segmentfault.com/?enc=d5piGNGX7lLAdysDRrZeNg%3D%3D.EnCVRaG%2F9gi8sSsjIrc7D9oTcWLUXYDLl7tjjjunsG64ioIXiHGvc3wdy1zjOKwt" rel="nofollow" target="_blank">#7937</a>) by @mytharcher</li><li><strong>[数据表字段：多对多 (数组)]</strong> 修复多对多（数组）字段在新增/修改关联数据时的异常行为 (<a href="https://link.segmentfault.com/?enc=trOvEdD8CMzWbPrhLnpVgA%3D%3D.8jfqYrHyGAILlTxbwuNA0AKd2LcYlzJelGVMa58G3V%2F%2Fs0P3FFMCN3WNKaRfNczi" rel="nofollow" target="_blank">#7926</a>) by @cgyrock</li><li><strong>[操作：导入记录 Pro]</strong> 修复导入 Pro 操作允许上传时修改导入选项不生效的问题 by @katherinehhh</li></ul><h3><a href="https://link.segmentfault.com/?enc=M56FFayk6T7e1nbP69AaSg%3D%3D.lmK1sfPb%2BhmBD4tosyQ142TUFCSwvoA9jn2I1gGkxu%2BIZ6ohG1ubBzEu4i%2FoylFmcSbX3xdYZUvGL6HUBPLlwA%3D%3D" rel="nofollow" target="_blank">v2.0.0-alpha.43</a></h3><p><em>发布时间：2025-11-20</em></p><h3>🚀 优化</h3><ul><li><strong>[数据可视化]</strong> 为插件界面添加了俄语支持。 (<a href="https://link.segmentfault.com/?enc=UWdWPqgok4BkisFWVXWj3g%3D%3D.eqjZH4y%2BytL8UV%2BgwnGNUbl8GN4FjOoZ4GgPXvInlepzZddYLZjnmGW5VTXYxEo7" rel="nofollow" target="_blank">#7676</a>) by @sembaev-a-a</li><li><strong>[权限控制]</strong> 缩小 member 角色的默认权限 (<a href="https://link.segmentfault.com/?enc=M9Te5gL0PYSLIEUAAdiTpg%3D%3D.OABUBP6Wu1r4MBLfiI%2Fzh%2BuuOqzft3x42qtGXF%2BRUBEHVRLOhUUMs1w5k%2F2GMh3Q" rel="nofollow" target="_blank">#7921</a>) by @2013xile</li><li><strong>[工作流：Webhook 触发器]</strong> 为响应节点增加图标 by @mytharcher</li></ul><h3>🐛 修复</h3><ul><li><strong>[client]</strong> 修复错误： Can't resolve 'antd-mobile' 和 Can't resolve 'antd-mobile-icons' (<a href="https://link.segmentfault.com/?enc=TmktVCJkDTT3f7dyx8b0Sg%3D%3D.QSjTRe%2FdGV1PF919U70ZoIrenVn4%2BLBFGYg5Qqx8FAJ20ccgVt6ANNQ60cTnv1pj" rel="nofollow" target="_blank">#7914</a>) by @zhangzhonghe</li><li><strong>[flow-engine]</strong> 修复打开表格区块的快捷编辑表单报错的问题。 (<a href="https://link.segmentfault.com/?enc=nmY%2FRVkDGQEbnk1VX%2FVACw%3D%3D.TolQlXlzuoCFmuZJnJg5ExXrwNeQVikmTDsCpSCDgU1NdvZj%2FFxrxakpEa7xXzxJ" rel="nofollow" target="_blank">#7923</a>) by @gchust</li><li><strong>[前端流引擎]</strong> 修复记录变量解析问题：当同时使用记录本身和其字段时，始终返回完整记录。 (<a href="https://link.segmentfault.com/?enc=ibFHEixq4t1KI9WLgqHjVQ%3D%3D.iXKyBfIzHBlZdF%2FY67L5lNJSwq%2FZz65T6gH04MxgksjLa7NOia1rSnE9%2FrtILDgq" rel="nofollow" target="_blank">#7917</a>) by @gchust</li><li><strong>[数据源：主数据库]</strong> 修复增加一对多字段后在重启应用前无法选择外键字段的问题 (<a href="https://link.segmentfault.com/?enc=zvqCsYx8jlDA6jaqwLpaFA%3D%3D.E4gXchSI0rNcK4%2Fa9aZzs1bTeMjvb4SfquxXh6emWjOjR3V5mxB7D7wfYIE%2BK6%2BE" rel="nofollow" target="_blank">#7907</a>) by @cgyrock</li><li><strong>[权限控制]</strong> 关系字段关联操作支持数据范围限制 (<a href="https://link.segmentfault.com/?enc=ORNEQJ8VAoQrNbaK2IP1XA%3D%3D.LevJJSgBbXi%2FMKP0NnNyNhdR5uqxsSeIDj%2BL%2FgoNUpt2bh72eoCGyHBwz1OZEYhO" rel="nofollow" target="_blank">#7919</a>) by @2013xile</li></ul>]]></description></item><item>    <title><![CDATA[Windows 11 25H2 | 24]]></title>    <link>https://segmentfault.com/a/1190000047432082</link>    <guid>https://segmentfault.com/a/1190000047432082</guid>    <pubDate>2025-11-27 14:06:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Windows 11 25H2 | 24H2 中文版、英文版 (x64、ARM64) 下载 (2025 年 11 月更新)</p><p>Windows 11, version 25H2 Enterprise Arm64 x64 (updated Nov 2025)</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=XuYeqb2ws%2BVWwcWHmLmaQQ%3D%3D.hp9XKHsBJMIi5Nq%2BqmNuZW3l7cRYtIOuTTmwypSkEzTO2JKTz%2BkfZIy3Pk4R3x%2B%2B" rel="nofollow" target="_blank">https://sysin.org/blog/windows-11/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=T%2FSD5LWQNjcvSeQa6oDnhA%3D%3D.RSt5euAbM5SOInsjmV%2FdQGcogmYbGppYiL6rbewBlX8%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>全新推出 Windows 11</p><p>全新 Windows 体验，让您与热爱的人和事物离得更近。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046813821" alt="Windows 11" title="Windows 11"/></p><h2>Windows 11 版本信息</h2><p>Windows 11 每年会进行一次功能更新，功能更新在日历年下半年发布，并附带对家庭版、专业版、专业工作站版和专业教育版的 24 个月支持，以及对 企业版和教育版的 36 个月支持。如需了解更多信息，请参阅 <a href="https://link.segmentfault.com/?enc=PFIVy8dEb2wI%2BnPJlj5k7Q%3D%3D.sUx9RmE1XLqM4N2AmWpMca%2FNajRzejyVYwolZoxjSJtuVg3V4awlMDPJJjHYVZ5U" rel="nofollow" target="_blank">Windows 生命周期常见问题解答</a>。</p><p>Windows 11 还在每月的第二个星期二发布<a href="https://link.segmentfault.com/?enc=LY389rQFcYCWJGycalp0pg%3D%3D.EeL8oNESGij%2BVddQ9FVSWfNEIP7ofRPl3LHgwnPK48VRN301rexaTL0UCvwyViXZxuq21xRx0qtHaAxIfcClzbgRebGK2CHM3SfvBuIiYqNXHHF%2BdVOlcDHobYdl85wGuqGtgAKNSB711wwyWvEUIQ%3D%3D" rel="nofollow" target="_blank">每月安全更新</a>。这些版本是累积的，包含所有以前的更新，让设备持续受到保护和保持高效。</p><p>如果你是 IT 管理员，并且想通过编程从此页面获取信息，请使用 <a href="https://link.segmentfault.com/?enc=FcPnKMIHXgTnVXbYgPz3%2Fw%3D%3D.avEZF2xSNfsu1ibkCwc11C3RlvDXnGhGZrN5bn562%2FRGf1ujg79Gr29DbYcJwZ6BC8D%2FHhE0b22FRBq4GEyn6jAwwZyE372Lsk6ql26yw2YBqQmRB2aQt8rM71Oglil6%2FNPy9zyX1fAn9XgAO7xRRg%3D%3D" rel="nofollow" target="_blank">Microsoft Graph 中的 Windows 更新 API</a>。</p><p>Windows 11 目前版本</p><p>所有的日期都按照 ISO 8601 格式列出：YYYY-MM-DD</p><p>服务频道</p><table><thead><tr><th>版本</th><th>服务选项</th><th>上市日期</th><th>最新版本</th><th>服务终止：家庭版、专业版、专业教育版和专业工作站版</th><th>服务终止：企业、教育、IoT 企业版和企业多会话</th></tr></thead><tbody><tr><td>24H2</td><td>正式发布频道</td><td>2024-10-01</td><td>26100.1742</td><td>2026-10-13</td><td>2027-10-12</td></tr><tr><td>23H2</td><td>正式发布频道</td><td>2023-10-31</td><td>22631.4249</td><td>2025-11-11</td><td>2026-11-10</td></tr><tr><td>22H2</td><td>正式发布频道</td><td>2022-09-20</td><td>22621.4249</td><td>2024-10-08</td><td>2025-10-14</td></tr><tr><td>21H2</td><td>正式发布频道</td><td>2021-10-04</td><td>22000.3197</td><td>2023-10-08</td><td>2024-10-08</td></tr></tbody></table><p>企业版和 IoT 企业版 LTSC 版本</p><table><thead><tr><th>Version</th><th>服务选项</th><th>上市日期</th><th>OS build</th><th>主要支持结束日期</th><th>外延支持结束日期</th></tr></thead><tbody><tr><td>24H2</td><td>长期服务频道 (LTSC)</td><td>2024-10-01</td><td>26100.1742</td><td>2029-10-09</td><td>2034-10-10</td></tr></tbody></table><h2>⬇下载地址</h2><h3>Windows 11, version 24H2</h3><p><strong>Windows 11, version 24H2 (updated Nov 2025) Arm64, x64</strong>：</p><ul><li><p>x64 请访问：<a href="https://link.segmentfault.com/?enc=5X1Pl7I%2FivLene0hXuOM3w%3D%3D.oTl%2FsRoBO7CjjWeb4%2F8CIiHuE1B2yQr6O6h0lMjtgg4wOG%2BhZm1KSziEpVYRhjHD" rel="nofollow" target="_blank">https://sysin.org/blog/windows-11/</a></p><ul><li>en-us_windows_11_business_editions_version_24h2_updated_nov_2025_x64_dvd_32d67bec.iso</li><li>zh-cn_windows_11_business_editions_version_24h2_updated_nov_2025_x64_dvd_2f40d7fb.iso</li><li>zh-tw_windows_11_business_editions_version_24h2_updated_nov_2025_x64_dvd_5f81f4ca.iso</li></ul></li><li><p>Arm64 请访问：<a href="https://link.segmentfault.com/?enc=H67d0FGeyaUinK8YZTTL9w%3D%3D.cIkvqI71KoqmApv2fbKxSAqUkLRnyvm4bPiupt3O5XlEvxH75uxXvhbuxxzvvHO0" rel="nofollow" target="_blank">https://sysin.org/blog/windows-11/</a></p><ul><li>en-us_windows_11_business_editions_version_24h2_updated_nov_2025_arm64_dvd_3d261eb6.iso</li><li>zh-cn_windows_11_business_editions_version_24h2_updated_nov_2025_arm64_dvd_c3665305.iso</li><li>zh-tw_windows_11_business_editions_version_24h2_updated_nov_2025_arm64_dvd_8f34b331.iso</li></ul></li><li><strong>English - Business</strong> (Education, Enterprise, Pro, Pro Education, Pro for Workstations)</li><li><strong>简体中文 - 商业版</strong>（教育版、企业版、专业版、专业教育版、专业工作站版）</li><li><strong>繁體中文 - 商業版</strong>（教育版、企業版、專業版、專業教育版、專業工作站版）</li></ul><h3>Windows 11, version 25H2</h3><p><strong>Windows 11, version 25H2 (updated Nov 2025) Arm64, x64</strong>：</p><ul><li><p>x64 请访问：<a href="https://link.segmentfault.com/?enc=FyvqXEX%2BZ%2FXMtxY7zfD9Aw%3D%3D.ovWg57GfE5WEgaNi6x9splEvaeh8dYjcO%2BLHwfKwIbczw4fEypRvu1z2OBfTNBHq" rel="nofollow" target="_blank">https://sysin.org/blog/windows-11/</a></p><ul><li>en-us_windows_11_business_editions_version_25h2_updated_nov_2025_x64_dvd_645b09df.iso</li><li>zh-cn_windows_11_business_editions_version_25h2_updated_nov_2025_x64_dvd_6ae389e3.iso</li><li>zh-tw_windows_11_business_editions_version_25h2_updated_nov_2025_x64_dvd_4621ffb0.iso</li></ul></li><li><p>Arm64 请访问：<a href="https://link.segmentfault.com/?enc=scMD570e0eWXmm%2FkFEQBFQ%3D%3D.YZmI09w%2B0Wy0nx2zVA43wy7Rg31PVzCdtUDOIJC61JF0osDfk5JRtvvIOrbfezCJ" rel="nofollow" target="_blank">https://sysin.org/blog/windows-11/</a></p><ul><li>en-us_windows_11_business_editions_version_25h2_updated_nov_2025_arm64_dvd_1018de49.iso</li><li>zh-cn_windows_11_business_editions_version_25h2_updated_nov_2025_arm64_dvd_105c2498.iso</li><li>zh-tw_windows_11_business_editions_version_25h2_updated_nov_2025_arm64_dvd_d74eb0d9.iso</li></ul></li></ul><p>文件名对应版本：</p><ul><li><strong>English - Business</strong> (Education, Enterprise, Pro, Pro Education, Pro for Workstations)</li><li><strong>简体中文 - 商业版</strong>（教育版、企业版、专业版、专业教育版、专业工作站版）</li><li><strong>繁體中文 - 商業版</strong>（教育版、企業版、專業版、專業教育版、專業工作站版）</li></ul><hr/><p>虚机模板下载：</p><ul><li><a href="https://link.segmentfault.com/?enc=%2FNE%2FcYM876G1RhQ0It5TQA%3D%3D.bjvN6Cgd1qSSWWGs%2FE4mtqO%2BhO85jbg8TcfqjjO2dNoPtpGSmCRDMr6H3YpTj2Tl" rel="nofollow" target="_blank">Windows Server 2025 OVF (2025 年 10 月更新) - VMware 虚拟机模板</a></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=8JDOp2woe1%2FSozgKWpRjOA%3D%3D.8Pgzn0U7Sw0I%2BqIu8JP%2FdL4H4%2FbX3jYzq9YLh2ZVgA0%3D" rel="nofollow" target="_blank">Windows 下载汇总</a></p>]]></description></item><item>    <title><![CDATA[国密证书和国产证书有什么区别？ 傻傻的开]]></title>    <link>https://segmentfault.com/a/1190000047432090</link>    <guid>https://segmentfault.com/a/1190000047432090</guid>    <pubDate>2025-11-27 14:05:27</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>引子：当 “国产” 遇上 “国密”，你选对安全钥匙了吗？</p><p>在数字化浪潮中，SSL 证书是保障数据传输安全的 “数字锁”。但面对 “国密证书” 和 “国产证书” 这两个看似相近的概念，很多企业和机构陷入了选择困境 —— 它们都带着 “中国基因”，究竟有何本质区别？为何政务、金融等关键领域坚定选择国密证书，而普通企业却常混淆两者？今天，我们用最直白的拆解，揭开这场 “安全选择题” 的核心答案。</p><p>一、<strong>定义溯源：“自主核心” 与 “国内签发” 的本质分野</strong></p><p>两者的核心差异，从诞生之初就已注定：</p><ul><li><strong>国密证书</strong>：真正的 “中国自主密码体系产物”。它必须采用国家密码管理局研发的 SM2 椭圆曲线算法为核心，配套 SM3 摘要算法、SM4 对称加密算法，且全证书链（终端 + 中间 + 根证书）都强制使用国密算法。更关键的是，只有通过国家密码管理局认证的 CA 机构（如 GDCA、CFCA）才能签发，从根源上保障算法主权。</li></ul><ul><li><strong>国产证书</strong>：更像是 “国内机构签发的国际标准证书”。它由国内 CA 机构（如上海 CA）签发，但核心算法仍沿用 RSA/ECC 等国际通用算法，部分甚至依赖国外根证书的交叉认证，属于 “混合认证模式”。简单说，它只是 “出生地在国内”，核心加密技术仍未脱离国际体系。</li></ul><p>形象比喻：国密证书是 “纯国产自主研发战机”，从发动机到航电系统全自主；国产证书则是 “国内组装的合资车”，核心零部件仍依赖进口。</p><p>二、<strong>算法对决：256 位国密 SM2 为何更具优势？</strong></p><p>加密算法是证书的 “安全心脏”，两者的算法差异直接决定安全等级：</p><table><thead><tr><th>对比维度</th><th>国密证书</th><th>国产证书</th></tr></thead><tbody><tr><td>核心算法</td><td>SM2 椭圆曲线算法（256 位）</td><td>RSA 2048 位 / ECC 256 位</td></tr><tr><td>安全强度</td><td>等效 3072 位 RSA，抗量子攻击</td><td>仅能抵御传统攻击，面临量子威胁</td></tr><tr><td>运算效率</td><td>SSL 握手速度比 RSA 快 60%，适配高频交易</td><td>密钥过长导致响应迟缓，服务器负载高</td></tr><tr><td>主权归属</td><td>完全自主可控，无境外依赖</td><td>算法标准由国际组织制定，存在断供风险</td></tr></tbody></table><p>关键数据：SM2 算法用 256 位密钥就能实现 3072 位 RSA 的安全强度，而密钥长度每缩短一半，运算效率可提升数倍。在金融支付等高频场景中，国密证书能将交易响应时间从数百毫秒压缩至几十毫秒，这也是银行业 2025 年国密改造完成率超 90% 的核心原因。</p><p><img width="723" height="311" referrerpolicy="no-referrer" src="/img/bVddxC9" alt="" title=""/></p><p>三、<strong>合规边界：哪些场景更适合国密证书？</strong></p><p>随着《密码法》《网络安全法》的落地，“合规” 成为关键选择依据：</p><ul><li><strong>国密证书的适配场景</strong>：政务系统、金融核心业务、能源管网、医疗数据平台等关键信息基础设施，建议通过国密认证（即 “密评”）。例如，银行转账、证券交易、社保信息查询等场景，若使用非国密证书，将面临行政处罚和数据安全风险。</li></ul><ul><li><strong>国产证书的适用场景</strong>：普通企业官网、非敏感数据传输、内部办公系统等无需强制密评的场景。它的优势是兼容 Chrome、Firefox 等主流浏览器，部署成本低，但不适用于关键业务 ——2024 年某国产 CA 因依赖国外根证书被吊销，导致多家企业网站访问中断，就是深刻教训。</li></ul><p>四、<strong>信任链条：谁能更稳妥守住 “数据国门”？</strong></p><p>信任链的完整性直接关系数据传输安全：</p><ul><li>国密证书的信任链完全闭环：根证书由国内 CA 机构自主掌控，配套国产密码模块（如加密芯片），数据加密、解密全流程在国内完成，不存在境外数据泄露风险。俄乌冲突中，俄罗斯多家银行因国际证书被吊销陷入瘫痪，而我国采用国密证书的金融机构则安然无恙，印证了自主信任链的重要性。</li></ul><ul><li>国产证书的信任链存在 “暗门”：部分国产证书的根证书位于国外，数据传输过程中，加密密钥可能被境外机构获取。在数据安全上升为国家安全的今天，这种 “依赖型信任” 显然无法满足关键领域的安全需求。</li></ul><p>五、<strong>选型指南：企业如何精准做出合适决策？</strong></p><ol><li><strong>关键业务优先国密</strong>：若涉及国计民生、敏感数据传输，直接选择国密证书，可搭配 “国密 + 国际算法双证书方案”，既满足合规要求，又兼容境外用户访问。</li></ol><ol start="2"><li><strong>普通业务灵活选择</strong>：非敏感场景可选用国产证书，但需确认 CA 机构是否具备独立根证书体系，避免 “套牌” 认证。</li></ol><ol start="3"><li><strong>长期布局看自主</strong>：随着量子计算技术发展，RSA 等传统算法将面临破解风险，而 SM2 算法天生具备抗量子特性，提前部署国密证书是企业安全的 “长期投资”。</li></ol><p>结语：安全自主，才是真正的底气</p><p>国密证书与国产证书，看似一字之差，实则是 “核心自主” 与 “形式国产” 的差距。在网络安全形势日益复杂的今天，选择国密证书，不仅是满足合规要求，更是掌握数据安全主动权的战略选择。从政务系统到金融支付，从能源管网到智慧医疗，国密证书正在成为守护国家数字安全的 “核心屏障”—— 毕竟，真正的安全，永远源于自主可控。</p>]]></description></item><item>    <title><![CDATA[小白必看！SSL证书类型扫盲：DV, O]]></title>    <link>https://segmentfault.com/a/1190000047432095</link>    <guid>https://segmentfault.com/a/1190000047432095</guid>    <pubDate>2025-11-27 14:04:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>当你决定为网站安装SSL证书时，迎面而来的就是三个神秘的缩写：DV、OV、EV。它们看起来很像，价格却天差地别。</p><p>别担心，这篇文章将用最通俗易懂的方式，帮你彻底搞懂它们的区别，并告诉你如何根据自身情况做出最佳选择。</p><p><strong>核心概念：验证等级的不同</strong><br/>这三种证书最根本的区别，在于证书颁发机构（CA）对申请者身份信息的验证严格程度不同。你可以把它类比成我们生活中的三种证件：</p><p><strong>DV证书</strong> ≈ “<strong>网上昵称</strong>” - 只证明你是个真人，但不证明你是谁。</p><p><strong>OV证书</strong> ≈ “<strong>工作证</strong>” - 证明了你是哪家公司的正式员工。</p><p><strong>EV证书</strong> ≈ “<strong>营业执照</strong>” - 经过了最严格的工商核查，公信力最强。</p><p><strong>验证越严格，证书带来的信任度就越高，当然成本和办理时间也越长</strong>。<br/><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdnbpN" alt="" title=""/></p><p><strong>三种证书深度解析</strong><br/><strong>1. DV证书 - 域名验证型</strong><br/>验证方式：<strong>CA只验证你是否拥有这个域名的管理权</strong>。通常是通过你回复一封确认邮件，或者在域名DNS里添加一条特定的解析记录。完全在线自动化完成，最快几分钟即可签发。</p><p>浏览器显示：地址栏显示锁型图标和 https://。</p><p>适合场景：</p><p><strong>个人博客、网站</strong></p><p><strong>小型展示类企业官网</strong></p><p><strong>测试环境、内部系统</strong></p><p>优点：</p><p><strong>免费或价格极低</strong>（如 Let‘s Encrypt）</p><p><strong>签发速度极快，几乎即时获取</strong></p><p>缺点：</p><p><strong>仅验证域名所有权，不验证企业身份</strong>。因此，钓鱼网站也可能申请到DV证书，从而也显示“小绿锁”，安全性有限。</p><p>一句话总结DV：<strong>解决了基础加密，但没解决信任问题</strong>。</p><p><strong>2. OV证书 - 组织验证型</strong><br/>验证方式：<strong>CA除了验证域名所有权，还会人工核实申请企业的真实性和合法性</strong>。通常会检查公司在工商部门的注册信息，并可能会打电话到公司进行确认。这个过程通常需要 1-3天。</p><p>浏览器显示：地址栏显示锁型图标和 https://。用户点击小锁图标后，可以查看到企业的详细信息。</p><p>适合场景：</p><p><strong>电子商务网站</strong></p><p><strong>企业官网、会员登录系统</strong></p><p><strong>需要传输敏感信息（如身份证号、地址）的网站</strong></p><p>优点：</p><p>验证了企业实体，大大增强了用户信任。</p><p>有效向用户证明您是一家合法运营的组织。</p><p>缺点：</p><p>需要付费。</p><p>签发需要几天时间，无法立即获取。</p><p>一句话总结OV：<strong>兼顾了成本与信任，是企业网站的理想选择</strong>。</p><p><strong>3. EV证书 - 扩展验证型</strong><br/>验证方式：<strong>这是最严格的验证标准</strong>。CA会遵循全球统一的严格规范，对申请组织进行全面的审查，包括：</p><p><strong>政府注册信息的合法性</strong></p><p><strong>组织的实际存在性</strong></p><p><strong>申请人的身份和授权</strong></p><p><strong>有时甚至需要提供律师函等法律文件</strong>。整个过程最为繁琐，可能需要 3-7天。</p><p>浏览器显示：这是EV证书最显著的特点！地址栏不仅会显示锁和HTTPS，还会直接将你的公司名称以绿色字体显示在地址栏中。</p><p>（注：近年来部分浏览器如Chrome简化了UI，但EV证书在点击锁图标后依然会清晰展示组织信息，并在证书详情中保持最高验证级别。）</p><p>适合场景：</p><p><strong>大型金融机构、银行</strong></p><p><strong>知名电商平台</strong></p><p><strong>任何需要最高级别信任背书的网站（如政府机构、上市公司）</strong></p><p>优点：</p><p>提供最高级别的视觉信任暗示，显著提升用户信心和转化率。</p><p>最有效的防钓鱼手段，因为钓鱼网站几乎无法获得显示其假冒公司名称的EV证书。</p><p>缺点：</p><p>价格最昂贵。</p><p>签发周期最长。</p><p>一句话总结EV：<strong>信任的“金字招牌”，适用于对安全与品牌信誉有极致要求的场景</strong>。</p><p><strong>最终选择建议</strong><br/><strong>“我只是个博客或个人网站” -&gt; 选择DV证书</strong>。免费且快速，完全够用。</p><p><strong>“我是正规运营的企业/电商/有登录系统的网站” -&gt; 首选OV证书</strong>。它在成本、时间和信任度之间取得了最佳平衡，是企业网站的性价比之王。</p><p><strong>“我的品牌声誉至关重要，不容有失” -&gt; 投资EV证书</strong>。如果你是银行、知名上市公司或大型平台，EV证书带来的顶级信任背书是值得的。</p>]]></description></item><item>    <title><![CDATA[国密算法SSL证书的技术架构与安全性解析]]></title>    <link>https://segmentfault.com/a/1190000047432103</link>    <guid>https://segmentfault.com/a/1190000047432103</guid>    <pubDate>2025-11-27 14:03:42</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3>一、<strong>国密SSL证书技术架构与安全性解析</strong></h3><p><img width="723" height="692" referrerpolicy="no-referrer" src="/img/bVdmPz6" alt="" title=""/></p><ul><li><p><strong>技术架构核心组件</strong></p><ul><li><strong>SM2非对称加密</strong>：基于椭圆曲线密码学，256位密钥强度等效RSA 3072位，运算效率提升40%，适用于高并发场景。</li><li><strong>SM3哈希算法</strong>：输出256位抗碰撞哈希值，用于数字签名和完整性校验，安全性高于SHA-256。</li><li><strong>SM4对称加密</strong>：128位分组加密算法，速度比AES快30%，适合大规模数据传输。</li></ul></li><li><p><strong>安全性优势</strong></p><ul><li><strong>自主可控</strong>：摆脱对国际算法（如RSA）依赖，避免供应链风险（如俄乌冲突中国际证书被吊销事件）。</li><li><strong>抗量子攻击</strong>：SM2算法在量子计算威胁下更安全，且已纳入抗量子计算研究体系。</li><li><strong>政策合规</strong>：符合《密码法》《网络安全法》要求，通过等保2.0和商用密码应用安全性评估（密评）的必要条件。</li></ul></li></ul><h3>二、<strong>JoySSL品牌的国密证书优势与独创性</strong></h3><p><strong>证书⬇️</strong></p><p><a href="https://link.segmentfault.com/?enc=k1hCtLypfXhxVS4nq4QMSQ%3D%3D.stJORoCZjvKg422zbpWC%2Fz7b5Q9UrjYveidzcPI2exVT7ol2qPXNA9kq3X8s1sEw0VkrUxFVBplmgieMxjr8kbA5rPVXIMvJfQ5JDKO11Z8%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/national_secret_alg...</a></p><p>注册码230959，提供技术服务对接，等保密评⬆️<br/><img width="723" height="433" referrerpolicy="no-referrer" src="/img/bVdnbaB" alt="8e48f1aec3ed0bd3af74bc4d395a0aa7.png" title="8e48f1aec3ed0bd3af74bc4d395a0aa7.png" loading="lazy"/></p><ul><li><p><strong>双证书自适应机制</strong></p><ul><li><strong>创新点</strong>：一次配置即可同时签发国密（SM2）和国际（RSA）双证书，根据用户浏览器自动切换算法。</li><li><strong>价值</strong>：兼顾国内合规性与全球兼容性，解决金融、政务等领域跨境访问痛点。</li></ul></li><li><p><strong>全场景覆盖能力</strong></p><ul><li><strong>多样化产品矩阵</strong>：提供OV/DV证书，支持公网IP、内网IP、单域名、通配符等多类型需求。</li><li><strong>快速签发与续签</strong>：DV证书10分钟签发，OV证书1-3工作日完成，续签流程自动化。</li></ul></li><li><p><strong>硬件级安全防护</strong></p><ul><li><strong>HSM模块集成</strong>：私钥存储于硬件安全模块，防止内存泄露和中间人攻击。</li><li><strong>动态密钥轮换</strong>：90天自动更新机制，降低长期暴露风险。</li></ul></li><li><p><strong>生态兼容与成本优化</strong></p><ul><li><strong>国产化适配</strong>：深度兼容麒麟操作系统、鲲鹏芯片及360/红莲花等国产浏览器。</li><li><strong>普惠定价策略</strong>：标准版DV证书低至880元/年，较国际品牌低30%-50%。</li></ul></li></ul>]]></description></item><item>    <title><![CDATA[Linux 日志查看和分析 运维有小邓 ]]></title>    <link>https://segmentfault.com/a/1190000047432141</link>    <guid>https://segmentfault.com/a/1190000047432141</guid>    <pubDate>2025-11-27 14:02:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Linux 日志是系统运行状态的重要记录，包含了系统启动、服务运行、用户操作、安全事件等关键信息，对于故障排查、安全审计和系统维护至关重要。</p><p>故障排查：定位系统崩溃、服务异常的根本原因（如服务启动失败、硬件故障）。</p><p>安全审计：记录用户登录、权限变更、可疑操作，追踪潜在安全威胁。</p><p>性能分析：监控资源使用情况（如 CPU、内存、磁盘 I/O），优化系统配置。</p><p>操作回溯：记录管理员操作历史，确保操作可追溯。</p><h2>Linux 日志的主要类型、存储位置及作用</h2><p><strong>系统核心日志</strong><br/>/var/log/messages：记录系统内核、服务启动 / 运行的通用消息，包含警告和错误信息。</p><p>/var/log/dmesg：存储系统启动时的内核日志（如硬件检测、驱动加载信息），可用dmesg命令查看。</p><p>/var/log/boot.log：记录系统启动过程中 initramfs 和 systemd 的引导日志。</p><p>/var/log/kern.log：单独记录内核相关的错误和警告（常见于 Debian/Ubuntu 系统）。</p><p><strong>系统服务日志</strong><br/>/var/log/ssh/sshd.log：SSH 服务的登录记录、认证失败信息（安全审计重点）。</p><p>/var/log/apache2/（或/var/log/httpd/）：Web 服务器（Apache/Nginx）的访问日志和错误日志。</p><p>/var/log/mysql/error.log：MySQL 数据库的错误和运行日志。</p><p>/var/log/syslog：通用系统服务日志（如 cron 任务、邮件服务），常见于 Debian/Ubuntu。</p><p><strong>用户登录日志</strong><br/>/var/log/wtmp：记录所有用户的登录、注销历史，可用last命令查看。</p><p>/var/log/btmp：记录登录失败的尝试，可用lastb命令查看。</p><p>/var/log/utmp：记录当前登录的用户，可用who/w命令查看。</p><p><strong>安全与认证日志</strong><br/>/var/log/audit/audit.log：Linux 审计系统（auditd）的日志，记录权限变更、文件访问等安全事件。</p><p>/var/log/auth.log（Debian/Ubuntu）或 /var/log/secure（CentOS/RHEL）：认证相关日志（如 sudo 操作、密码错误）。</p><p><strong>系统资源与性能日志</strong><br/>/var/log/sysstat/：存储sysstat工具收集的系统性能数据（如 CPU、内存、磁盘使用情况）。</p><p>/var/log/loadavg：记录系统负载平均值（1 分钟、5 分钟、15 分钟）。</p><h2>Linux 日志查看、分析命令</h2><p><strong>通用查看：</strong><br/>cat /var/log/messages：直接查看日志文件（适合小文件）。</p><p>tail -f /var/log/syslog：实时追踪日志更新。</p><p>grep “error” /var/log/messages：筛选包含关键词的日志。</p><p><strong>systemd-journald 专用：</strong><br/>journalctl：查看所有日志。</p><p>journalctl -u sshd：仅查看 SSH 服务日志。</p><p>journalctl --since “2025-06-10” --until “2025-06-12”：按时间范围查询。</p><p>通过 Bash 命令行可手动分析 Linux 日志，常用命令包括：</p><p>cd /var/log/：切换工作目录至/var/log/。</p><p>head -n 20 ex.log：显示文件前 20 行内容。</p><p>tail -n 20 ex.log：显示文件最后 20 行内容。</p><p>grep “changed” ex.log（最常用）：在 ex.log 文件中搜索包含 “changed” 的行并打印。</p><h2><a href="https://link.segmentfault.com/?enc=DT5v8Z75XubBGyyAguxQbQ%3D%3D.xpsavMhXA8zc84d5cv%2BVZD2YXGto6%2B6XSJEYeF48xz6nPdmbp%2FlpKQwWz3pQwbeDkk83r8aPuFF8PVVJ7ZMwMOKlsjkQb3DuSZQDCijtQmYuXacgA6tWFd0pFREC46YgdNlSDWYbQjLDnXyUyaE4UGp4a899gh50bXVMPl9W%2BW0%3D" rel="nofollow" target="_blank">Linux 日志审计与管理工具</a></h2><p>EventLog Analyzer为 Linux 基础设施提供全面的日志管理与分析能力，支持集中管理多台 Linux 系统的日志、实时检测安全威胁、满足合规要求并简化安全运维流程。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047143518" alt="图片" title="图片"/><br/><strong>统一日志管理：</strong><br/>通过集中式日志管理解决方案聚合、分析和可视化所有关键 Linux 日志。</p><p><strong>主动威胁检测：</strong><br/>通过实时监控、高级关联规则和机器学习驱动的异常检测，更快发现并响应安全威胁，在暴力攻击、权限提升和未授权访问等风险升级前识别隐患。关联 Linux 日志源（系统日志、auth.log、应用日志等）的事件，可视化展示可疑活动时间线，并深入原始日志进行详细分析。</p><p><strong>提升运维效率：</strong><br/>监控 Linux 服务器的资源利用率（CPU、内存、磁盘 I/O），监控服务状态，借助实时洞察更快排查问题，从而提高系统可用性并降低 Linux 基础设施的运维成本。</p><p><strong>集中可视与控制：</strong><br/>通过单一控制台统一查看整个 Linux 环境，收集、分析和关联服务器、工作站、应用和网络设备的日志。</p><p><strong>自动化事件响应：</strong><br/>自动化事件响应工作流，检测到威胁时立即执行操作（如禁用账户、阻断 IP 或触发其他动作）以降低风险。</p><p><strong>简化合规审计：</strong><br/>轻松满足合规要求，提供 PCI DSS、HIPAA、GDPR、SOX 等法规的预制报表和仪表盘，简化合规审计流程。</p><p><strong>简化运维：</strong><br/>通过自动化日志收集、解析和分析简化日志管理，为 IT 团队提供可操作的洞察和直观仪表盘，使其专注于更具战略性的任务。</p>]]></description></item><item>    <title><![CDATA[数字人带货狂揽 23 亿！数字人主播成电]]></title>    <link>https://segmentfault.com/a/1190000047432151</link>    <guid>https://segmentfault.com/a/1190000047432151</guid>    <pubDate>2025-11-27 14:02:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>2025 年双十一，数字人带货交出了震撼行业的成绩单：京东平台数字人直播总成交额突破 23 亿元，1.7 万商家通过虚拟主播实现 24 小时不间断开播，带动平台整体转化率提升 30%。（青否数字人源头v：zhibo175）</p><p>!<a href="" target="_blank"/>从凌晨三点仍在滔滔不绝的国货彩妆虚拟主播，到创下 5500 万单场 GMV 的罗永浩 AI 分身，数字人正从直播带货的 “补充角色” 跃升为 “核心生产力”，引发行业对 “无人直播时代” 的热议。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432153" alt="" title=""/></p><p>核心优势：成本革命与全天候运营，重塑带货逻辑（青否数字人源头v：zhibo175）</p><p>数字人主播的爆发，本质是其解决了传统直播的核心痛点。最显著的优势在于成本控制！</p><p>数据显示，2025 年数字人直播服务成本已降至每小时 300-800 元，仅为真人主播的 1/3 至 1/5，日均运营成本不足 100 元。</p><p>国台酒等商家接入虚拟主播后，运营成本下降 78%，GMV 却日均增长 750%，这种高性价比让中小商家得以轻松入局。全天候不间断直播是另一大亮点。</p><p>京东数据显示，数字人在 0-8 点非黄金时段的转化率达 8%，较真人直播提升 5 个百分点。无需休息、不设时限的特性，让品牌能够覆盖更多潜在用户，尤其契合年轻消费群体的夜间购物习惯。</p><p>可帮助商家设计 “黄金时段真人 + 夜间数字人值守” 的互补模式，最大化挖掘全时段流量价值。</p><p>技术支撑：从 “机械播报” 到 “情感交互” 的质变</p><p>数字人带货的崛起，离不开底层技术的持续突破。如今的虚拟主播已告别机械念稿，动作精度可达 8300 个 / 场，能模拟微笑、挑眉等微表情，互动响应速度较去年提升 40%，可处理 90% 的常规咨询。</p><p>罗永浩 AI 分身更是凭借 0.5 秒级情绪响应和知识图谱驱动的精准应答，单场 GMV 超过其真人直播峰值的 110%。这些体验升级背后，是 AI 智能体与软件开发技术的深度融合。</p><p>青否数字人技术服务可提供自然语言处理、用户需求精准识别等核心能力，让数字人能根据观众提问实时调取产品数据库，实现个性化推荐；青否数字人软件开发能力则能搭建稳定的多平台适配架构，支持数字人在抖音、京东等不同平台的流畅运行，甚至实现多语言实时切换，适配跨境直播场景。（青否数字人源头v：zhibo175）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432154" alt="" title="" loading="lazy"/></p><p>市场格局：互补而非替代，双线融合成主流</p><p>面对数字人的强势表现，“真人主播会被取代吗” 的疑问随之而来，但数据给出了更理性的答案：二者是互补而非替代关系。</p><p>Coach、MCM 等轻奢品牌采用高定数字人后，直播间转化率提升 48%，但仍会在大促峰值时段搭配真人主播进行互动造势；某奶茶品牌通过数字人直播缩小加盟店转化率差异，同时保留真人主播的 IP 化运营。</p><p>这种 “数字人 + 真人” 的双线模式，正成为行业主流。数字人负责日常值守、标准化产品讲解和长尾流量承接，真人主播聚焦品牌故事传递、互动氛围调动和爆款引爆，实现效率与温度的平衡。青否数字人的运营服务可帮助商家优化这种组合模式，通过数据分析明确二者的分工场景，最大化发挥各自优势。</p><p>未来趋势：技术普惠，中小商家迎来新机遇</p><p>随着技术成熟，数字人制作成本已降至传统 CG 的 1/30，制作周期缩短至一周内，技术普惠效应显著。</p><p>湖南某县域通过虚拟主播团队培训，实现农产品线上销售额同比增长 340%；中小商家接入数字人后，平均获客成本降低 62%，日均 GMV 增长 210%。从23 亿元成交额到千亿元市场规模预测，数字人带货的爆发已是确定性趋势。</p><p>它不仅改变了直播带货的成本结构，更重塑了行业的服务模式。在这场变革中，稳定的技术支撑、专业的运营策略和精准的智能交互能力，成为商家抓住机遇的关键。青否数字人的技术与运营服务，正助力更多品牌和中小商家低成本拥抱数字人红利，让智能带货的价值充分释放（青否数字人源头v：zhibo175）。</p>]]></description></item><item>    <title><![CDATA[Dragonboat统一存储LogDB实]]></title>    <link>https://segmentfault.com/a/1190000047432161</link>    <guid>https://segmentfault.com/a/1190000047432161</guid>    <pubDate>2025-11-27 14:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、项目概览</h2><p>Dragonboat 是纯 Go 实现的（multi-group）Raft 库。</p><p>为应用屏蔽 Raft 复杂性，提供易于使用的 NodeHost 和状态机接口。该库（自称）有如下特点：</p><ul><li>高吞吐、流水线化、批处理；</li><li>提供了内存/磁盘状态机多种实现；</li><li>提供了 ReadIndex、成员变更、Leader转移等管理端API；</li><li>默认使用 Pebble 作为 存储后端。</li></ul><p>本次代码串讲以V3的稳定版本为基础，不包括GitHub上v4版本内容。</p><h2>二、整体架构</h2><p><img width="723" height="671" referrerpolicy="no-referrer" src="/img/bVdnbqk" alt="" title=""/></p><h2>三、LogDB 统一存储</h2><p>LogDB 模块是 Dragonboat 的核心持久化存储层，虽然模块名字有Log，但是它囊括了所有和存储相关的API，负责管理 Raft 协议的所有持久化数据，包括：</p><p><strong>Raft状态 (RaftState)</strong></p><p><strong>Raft内部状态变更的集合结构</strong></p><p>包括但不限于：</p><ul><li>ClusterID/NodeID： 节点ID</li><li>RaftState： Raft任期、投票情况、commit进度</li><li>EntriesToSave：Raft提案日志数据</li><li>Snapshot：快照元数据(包括快照文件路径，快照大小，快照对应的提案Index，快照对应的Raft任期等信息)</li><li>Messages：发给其他节点的Raft消息</li><li>ReadyToReads：ReadIndex就绪的请求</li></ul><p><strong>引导信息 (Bootstrap)</strong></p><pre><code>type Bootstrap struct {
    Addresses map[uint64]string // 初始集群成员
    Join      bool
    Type      StateMachineType
}</code></pre><p>ILogDB的API如下：</p><pre><code>type ILogDB interface {


    BinaryFormat() uint32 // 返回支持的二进制格式版本号


    ListNodeInfo() ([]NodeInfo, error) // 列出 LogDB 中所有可用的节点信息


    // 存储集群节点的初始化配置信息，包括是否加入集群、状态机类型等
    SaveBootstrapInfo(clusterID uint64, nodeID uint64, bootstrap pb.Bootstrap) error


    // 获取保存的引导信息
    GetBootstrapInfo(clusterID uint64, nodeID uint64) (pb.Bootstrap, error)


    // 原子性保存 Raft 状态、日志条目和快照元数据
    SaveRaftState(updates []pb.Update, shardID uint64) error


    // 迭代读取指定范围内的连续日志条目
    IterateEntries(ents []pb.Entry, size uint64, clusterID uint64, nodeID uint64, 
                   low uint64, high uint64, maxSize uint64) ([]pb.Entry, uint64, error)


    // 读取持久化的 Raft 状态
    ReadRaftState(clusterID uint64, nodeID uint64, lastIndex uint64) (RaftState, error)


    // 删除指定索引之前的所有条目, 日志压缩、快照后清理旧日志
    RemoveEntriesTo(clusterID uint64, nodeID uint64, index uint64) error


    // 回收指定索引之前条目占用的存储空间
    CompactEntriesTo(clusterID uint64, nodeID uint64, index uint64) (&lt;-chan struct{}, error)


    // 保存所有快照元数据
    SaveSnapshots([]pb.Update) error


    // 删除指定的快照元数据 清理过时或无效的快照
    DeleteSnapshot(clusterID uint64, nodeID uint64, index uint64) error


    // 列出指定索引范围内的可用快照
    ListSnapshots(clusterID uint64, nodeID uint64, index uint64) ([]pb.Snapshot, error)


    // 删除节点的所有相关数据
    RemoveNodeData(clusterID uint64, nodeID uint64) error


    // 导入快照并创建所有必需的元数据
    ImportSnapshot(snapshot pb.Snapshot, nodeID uint64) error
}</code></pre><h3>3.1索引键</h3><p>存储的底层本质是一个KVDB (pebble or rocksdb)，由于业务的复杂性，要统一各类业务key的设计方法，而且要降低空间使用，所以有了如下的key设计方案。</p><p>龙舟中key分为3类：</p><p><img width="723" height="141" referrerpolicy="no-referrer" src="/img/bVdnbql" alt="" title="" loading="lazy"/><br/>其中，2字节的header用于区分各类不同业务的key空间。</p><pre><code>entryKeyHeader       = [2]byte{0x1, 0x1}  // 普通日志条目
persistentStateKey   = [2]byte{0x2, 0x2}  // Raft状态
maxIndexKey          = [2]byte{0x3, 0x3}  // 最大索引记录
nodeInfoKey          = [2]byte{0x4, 0x4}  // 节点元数据
bootstrapKey         = [2]byte{0x5, 0x5}  // 启动配置
snapshotKey          = [2]byte{0x6, 0x6}  // 快照索引
entryBatchKey        = [2]byte{0x7, 0x7}  // 批量日志</code></pre><p>在key的生成中，采用了useAsXXXKey和SetXXXKey的方式，复用了data这个二进制变量，减少GC。</p><pre><code>type Key struct {
    data []byte  // 底层字节数组复用池
    key  []byte  // 有效数据切片
    pool *sync.Pool // 似乎并没有什么用
}




func (k *Key) useAsEntryKey() {
    k.key = k.data
}


type IReusableKey interface {
    SetEntryBatchKey(clusterID uint64, nodeID uint64, index uint64)
    // SetEntryKey sets the key to be an entry key for the specified Raft node
    // with the specified entry index.
    SetEntryKey(clusterID uint64, nodeID uint64, index uint64)
    // SetStateKey sets the key to be an persistent state key suitable
    // for the specified Raft cluster node.
    SetStateKey(clusterID uint64, nodeID uint64)
    // SetMaxIndexKey sets the key to be the max possible index key for the
    // specified Raft cluster node.
    SetMaxIndexKey(clusterID uint64, nodeID uint64)
    // Key returns the underlying byte slice of the key.
    Key() []byte
    // Release releases the key instance so it can be reused in the future.
    Release()
}


func (k *Key) useAsEntryKey() {
    k.key = k.data
}


// SetEntryKey sets the key value to the specified entry key.
func (k *Key) SetEntryKey(clusterID uint64, nodeID uint64, index uint64) {
    k.useAsEntryKey()
    k.key[0] = entryKeyHeader[0]
    k.key[1] = entryKeyHeader[1]
    k.key[2] = 0
    k.key[3] = 0
    binary.BigEndian.PutUint64(k.key[4:], clusterID)
    // the 8 bytes node ID is actually not required in the key. it is stored as
    // an extra safenet - we don't know what we don't know, it is used as extra
    // protection between different node instances when things get ugly.
    // the wasted 8 bytes per entry is not a big deal - storing the index is
    // wasteful as well.
    binary.BigEndian.PutUint64(k.key[12:], nodeID)
    binary.BigEndian.PutUint64(k.key[20:], index)
}</code></pre><h3>3.2变量复用IContext</h3><p>IContext的核心设计目的是实现<strong>并发安全的内存复用机制</strong>。在高并发场景下，频繁的内存分配和释放会造成较大的GC压力，通过IContext可以实现：</p><ul><li><strong>键对象复用</strong>：通过GetKey()获取可重用的IReusableKey</li><li><strong>缓冲区复用</strong>：通过GetValueBuffer()获取可重用的字节缓冲区</li><li><strong>批量操作对象复用</strong>：EntryBatch和WriteBatch的复用</li></ul><pre><code>// IContext is the per thread context used in the logdb module.
// IContext is expected to contain a list of reusable keys and byte
// slices that are owned per thread so they can be safely reused by the
// same thread when accessing ILogDB.
type IContext interface {
    // Destroy destroys the IContext instance.
    Destroy()
    // Reset resets the IContext instance, all previous returned keys and
    // buffers will be put back to the IContext instance and be ready to
    // be used for the next iteration.
    Reset()
    // GetKey returns a reusable key.
    GetKey() IReusableKey // 这就是上文中的key接口
    // GetValueBuffer returns a byte buffer with at least sz bytes in length.
    GetValueBuffer(sz uint64) []byte
    // GetWriteBatch returns a write batch or transaction instance.
    GetWriteBatch() interface{}
    // SetWriteBatch adds the write batch to the IContext instance.
    SetWriteBatch(wb interface{})
    // GetEntryBatch returns an entry batch instance.
    GetEntryBatch() pb.EntryBatch
    // GetLastEntryBatch returns an entry batch instance.
    GetLastEntryBatch() pb.EntryBatch
}








type context struct {
    size    uint64
    maxSize uint64
    eb      pb.EntryBatch
    lb      pb.EntryBatch
    key     *Key
    val     []byte
    wb      kv.IWriteBatch
}


func (c *context) GetKey() IReusableKey {
    return c.key
}


func (c *context) GetValueBuffer(sz uint64) []byte {
    if sz &lt;= c.size {
        return c.val
    }
    val := make([]byte, sz)
    if sz &lt; c.maxSize {
        c.size = sz
        c.val = val
    }
    return val
}


func (c *context) GetEntryBatch() pb.EntryBatch {
    return c.eb
}


func (c *context) GetLastEntryBatch() pb.EntryBatch {
    return c.lb
}


func (c *context) GetWriteBatch() interface{} {
    return c.wb
}


func (c *context) SetWriteBatch(wb interface{}) {
    c.wb = wb.(kv.IWriteBatch)
}</code></pre><h3>3.3存储引擎封装IKVStore</h3><p>IKVStore 是 Dragonboat 日志存储系统的抽象接口，它定义了底层键值存储引擎需要实现的所有基本操作。这个接口让 Dragonboat 能够支持不同的存储后端（如 Pebble、RocksDB 等），实现了存储引擎的可插拔性。</p><pre><code>type IKVStore interface {
    // Name is the IKVStore name.
    Name() string
    // Close closes the underlying Key-Value store.
    Close() error


    // 范围扫描 - 支持前缀遍历的迭代器
    IterateValue(fk []byte,
            lk []byte, inc bool, op func(key []byte, data []byte) (bool, error)) error
    
    // 查询操作 - 基于回调的内存高效查询模式
    GetValue(key []byte, op func([]byte) error) error
    
    // 写入操作 - 单条记录的原子写入
    SaveValue(key []byte, value []byte) error


    // 删除操作 - 单条记录的精确删除
    DeleteValue(key []byte) error
    
    // 获取批量写入器
    GetWriteBatch() IWriteBatch
    
    // 原子提交批量操作
    CommitWriteBatch(wb IWriteBatch) error
    
    // 批量删除一个范围的键值对
    BulkRemoveEntries(firstKey []byte, lastKey []byte) error
    
    // 压缩指定范围的存储空间
    CompactEntries(firstKey []byte, lastKey []byte) error
    
    // 全量压缩整个数据库
    FullCompaction() error
}


type IWriteBatch interface {
    Destroy()                 // 清理资源，防止内存泄漏
    Put(key, value []byte)    // 添加写入操作
    Delete(key []byte)        // 添加删除操作
    Clear()                   // 清空批处理中的所有操作
    Count() int               // 获取当前批处理中的操作数量
}</code></pre><p>openPebbleDB是Dragonboat 中 Pebble 存储引擎的初始化入口，负责根据配置创建一个完整可用的键值存储实例。</p><p><img width="723" height="501" referrerpolicy="no-referrer" src="/img/bVdnbqm" alt="" title="" loading="lazy"/></p><pre><code>// KV is a pebble based IKVStore type.
type KV struct {
    db       *pebble.DB
    dbSet    chan struct{}
    opts     *pebble.Options
    ro       *pebble.IterOptions
    wo       *pebble.WriteOptions
    event    *eventListener
    callback kv.LogDBCallback
    config   config.LogDBConfig
}


var _ kv.IKVStore = (*KV)(nil)




// openPebbleDB
// =============
// 将 Dragonboat 的 LogDBConfig → Pebble 引擎实例
func openPebbleDB(
        cfg  config.LogDBConfig,
        cb   kv.LogDBCallback,   // =&gt; busy通知：busy(true/false)
        dir  string,             // 主数据目录
        wal  string,             // WAL 独立目录（可空）
        fs   vfs.IFS,            // 文件系统抽象（磁盘/memfs）
) (kv.IKVStore, error) {
    
    //--------------------------------------------------
    // 2️⃣ &lt;&lt; 核心调优参数读入
    //--------------------------------------------------
    blockSz      := int(cfg.KVBlockSize)                    // 数据块(4K/8K…)
    writeBufSz   := int(cfg.KVWriteBufferSize)              // 写缓冲
    bufCnt       := int(cfg.KVMaxWriteBufferNumber)         // MemTable数量
    l0Compact    := int(cfg.KVLevel0FileNumCompactionTrigger) // L0 层文件数量触发压缩的阈值
    l0StopWrites := int(cfg.KVLevel0StopWritesTrigger)
    baseBytes    := int64(cfg.KVMaxBytesForLevelBase)
    fileBaseSz   := int64(cfg.KVTargetFileSizeBase)
    cacheSz      := int64(cfg.KVLRUCacheSize)
    levelMult    := int64(cfg.KVTargetFileSizeMultiplier)  // 每层文件大小倍数
    numLevels    := int64(cfg.KVNumOfLevels)
    
    
    //--------------------------------------------------
    // 4️⃣ 构建 LSM-tree 层级选项 (每层无压缩)
    //--------------------------------------------------
    levelOpts := []pebble.LevelOptions{}
    sz := fileBaseSz
    for lvl := 0; lvl &lt; int(numLevels); lvl++ {
        levelOpts = append(levelOpts, pebble.LevelOptions{
            Compression:    pebble.NoCompression, // 写性能优先
            BlockSize:      blockSz,
            TargetFileSize: sz,                 // L0 &lt; L1 &lt; … 呈指数增长
        })
        sz *= levelMult
    }
    
    //--------------------------------------------------
    // 5️⃣ 初始化依赖：LRU Cache + 读写选项
    //--------------------------------------------------
    cache := pebble.NewCache(cacheSz)    // block缓存
    ro    := &amp;pebble.IterOptions{}       // 迭代器默认配置
    wo    := &amp;pebble.WriteOptions{Sync: true} // ❗fsync强制刷盘
    
    opts := &amp;pebble.Options{
        Levels:                      levelOpts,
        Cache:                       cache,
        MemTableSize:                writeBufSz,
        MemTableStopWritesThreshold: bufCnt,
        LBaseMaxBytes:               baseBytes,
        L0CompactionThreshold:       l0Compact,
        L0StopWritesThreshold:       l0StopWrites,
        Logger:                      PebbleLogger,
        FS:                          vfs.NewPebbleFS(fs),
        MaxManifestFileSize:         128 * 1024 * 1024,
        // WAL 目录稍后条件注入
    }
    
    kv := &amp;KV{
        dbSet:    make(chan struct{}),          // 关闭-&gt;初始化完成信号
        callback: cb,                           // 上层 raft engine 回调
        config:   cfg,
        opts:     opts,
        ro:       ro,
        wo:       wo,
    }
    
    event := &amp;eventListener{
        kv:      kv,
        stopper: syncutil.NewStopper(),
    }
    
    // =&gt; 关键事件触发
    opts.EventListener = pebble.EventListener{
        WALCreated:    event.onWALCreated,
        FlushEnd:      event.onFlushEnd,
        CompactionEnd: event.onCompactionEnd,
    }
    
    //--------------------------------------------------
    // 7️⃣ 目录准备
    //--------------------------------------------------
    if wal != "" {
        fs.MkdirAll(wal)        // 📁 为 WAL 单独磁盘预留
        opts.WALDir = wal
    }
    fs.MkdirAll(dir)            // 📁 主数据目录
    
    //--------------------------------------------------
    // 8️⃣ 真正的数据库实例化
    //--------------------------------------------------
    pdb, err := pebble.Open(dir, opts)
    if err != nil { return nil, err }
    
    //--------------------------------------------------
    // 9️⃣ 🧹 资源整理 &amp; 启动事件
    //--------------------------------------------------
    cache.Unref()               // 去除多余引用，防止泄露
    kv.db = pdb
    
    // 🔔 手动触发一次 WALCreated 确保反压逻辑进入首次轮询
    kv.setEventListener(event)  // 内部 close(kv.dbSet)
    
    return kv, nil
}</code></pre><p>其中eventListener是对pebble 内存繁忙的回调，繁忙判断的条件有两个：</p><ul><li>内存表大小超过阈值（95%）</li><li>L0 层文件数量超过阈值（L0写入最大文件数量-1）</li></ul><pre><code>

func (l *eventListener) notify() {
    l.stopper.RunWorker(func() {
        select {
        case &lt;-l.kv.dbSet:
            if l.kv.callback != nil {
                memSizeThreshold := l.kv.config.KVWriteBufferSize *
                    l.kv.config.KVMaxWriteBufferNumber * 19 / 20
                l0FileNumThreshold := l.kv.config.KVLevel0StopWritesTrigger - 1
                m := l.kv.db.Metrics()
                busy := m.MemTable.Size &gt;= memSizeThreshold ||
                    uint64(m.Levels[0].NumFiles) &gt;= l0FileNumThreshold
                l.kv.callback(busy)
            }
        default:
        }
    })
}</code></pre><p><img width="723" height="646" referrerpolicy="no-referrer" src="/img/bVdnbqn" alt="" title="" loading="lazy"/></p><h3>3.4日志条目存储DB</h3><p>db结构体是Dragonboat日志数据库的核心管理器，提供Raft日志、快照、状态等数据的持久化存储接口。是桥接了业务和pebble存储的中间层。</p><pre><code>// db is the struct used to manage log DB.
type db struct {
    cs      *cache       // 节点信息、Raft状态信息缓存
    keys    *keyPool     // Raft日志索引键变量池
    kvs     kv.IKVStore  // pebble的封装
    entries entryManager // 日志条目读写封装
}


// 这里面的信息不会过期，叫寄存更合适
type cache struct {
    nodeInfo       map[raftio.NodeInfo]struct{}
    ps             map[raftio.NodeInfo]pb.State
    lastEntryBatch map[raftio.NodeInfo]pb.EntryBatch
    maxIndex       map[raftio.NodeInfo]uint64
    mu             sync.Mutex
}</code></pre><ul><li><strong>获取一个批量写容器</strong></li></ul><p>实现：</p><pre><code>func (r *db) getWriteBatch(ctx IContext) kv.IWriteBatch {
    if ctx != nil {
        wb := ctx.GetWriteBatch()
        if wb == nil {
            wb = r.kvs.GetWriteBatch()
            ctx.SetWriteBatch(wb)
        }
        return wb.(kv.IWriteBatch)
    }
    return r.kvs.GetWriteBatch()
}</code></pre><p>降低GC压力</p><ul><li><strong>获取所有节点信息</strong></li></ul><p>实现：</p><pre><code>func (r *db) listNodeInfo() ([]raftio.NodeInfo, error) {
    fk := newKey(bootstrapKeySize, nil)
    lk := newKey(bootstrapKeySize, nil)
    fk.setBootstrapKey(0, 0)
    lk.setBootstrapKey(math.MaxUint64, math.MaxUint64)
    ni := make([]raftio.NodeInfo, 0)
    op := func(key []byte, data []byte) (bool, error) {
        cid, nid := parseNodeInfoKey(key)
        ni = append(ni, raftio.GetNodeInfo(cid, nid))
        return true, nil
    }
    if err := r.kvs.IterateValue(fk.Key(), lk.Key(), true, op); err != nil {
        return []raftio.NodeInfo{}, err
    }
    return ni, nil
}</code></pre><ul><li><strong>保存集群状态</strong></li></ul><p>实现：</p><pre><code>type Update struct {
    ClusterID uint64  // 集群ID，标识节点所属的Raft集群
    NodeID    uint64  // 节点ID，标识集群中的具体节点


    State  // 包含当前任期（Term）、投票节点（Vote）、提交索引（Commit）三个关键持久化状态


    EntriesToSave []Entry    // 需要持久化到稳定存储的日志条目
    CommittedEntries []Entry // 已提交位apply的日志条目
    MoreCommittedEntries bool  // 指示是否还有更多已提交条目等待处理


    Snapshot Snapshot  // 快照元数据，当需要应用快照时设置


    ReadyToReads []ReadyToRead  // ReadIndex机制实现的线性一致读


    Messages []Message  // 需要发送给其他节点的Raft消息


    UpdateCommit struct {
        Processed         uint64  // 已推送给RSM处理的最后索引
        LastApplied       uint64  // RSM确认已执行的最后索引
        StableLogTo       uint64  // 已稳定存储的日志到哪个索引
        StableLogTerm     uint64  // 已稳定存储的日志任期
        StableSnapshotTo  uint64  // 已稳定存储的快照到哪个索引
        ReadyToRead       uint64  // 已准备好读的ReadIndex请求索引
    }
}




func (r *db) saveRaftState(updates []pb.Update, ctx IContext) error {
      // 步骤1：获取写入批次对象，用于批量操作提高性能
      // 优先从上下文中获取已存在的批次，避免重复创建
      wb := r.getWriteBatch(ctx)
      
      // 步骤2：遍历所有更新，处理每个节点的状态和快照
      for _, ud := range updates {
          // 保存 Raft 的硬状态（Term、Vote、Commit）
          // 使用缓存机制避免重复保存相同状态
          r.saveState(ud.ClusterID, ud.NodeID, ud.State, wb, ctx)
          
          // 检查是否有快照需要保存
          if !pb.IsEmptySnapshot(ud.Snapshot) {
              // 快照索引一致性检查：确保快照索引不超过最后一个日志条目的索引
              // 这是 Raft 协议的重要约束，防止状态不一致
              if len(ud.EntriesToSave) &gt; 0 {
                  lastIndex := ud.EntriesToSave[len(ud.EntriesToSave)-1].Index
                  if ud.Snapshot.Index &gt; lastIndex {
                      plog.Panicf("max index not handled, %d, %d",
                          ud.Snapshot.Index, lastIndex)
                  }
              }
              
              // 保存快照元数据到数据库
              r.saveSnapshot(wb, ud)
              
              // 更新节点的最大日志索引为快照索引
              r.setMaxIndex(wb, ud, ud.Snapshot.Index, ctx)
          }
      }
      
      // 步骤3：批量保存所有日志条目
      // 这里会调用 entryManager 接口的 record 方法，根据配置选择批量或单独存储策略
      r.saveEntries(updates, wb, ctx)
      
      // 步骤4：提交写入批次到磁盘
      // 只有在批次中有实际操作时才提交，避免不必要的磁盘 I/O
      if wb.Count() &gt; 0 {
          return r.kvs.CommitWriteBatch(wb)
      }
      return nil
  }
  
  </code></pre><ul><li><strong>保存引导信息</strong></li></ul><p>实现：</p><pre><code>func (r *db) saveBootstrapInfo(clusterID uint64,
    nodeID uint64, bs pb.Bootstrap) error {
    wb := r.getWriteBatch(nil)
    r.saveBootstrap(wb, clusterID, nodeID, bs)
    return r.kvs.CommitWriteBatch(wb) // 提交至Pebble
}


func (r *db) saveBootstrap(wb kv.IWriteBatch,
    clusterID uint64, nodeID uint64, bs pb.Bootstrap) {
    k := newKey(maxKeySize, nil)
    k.setBootstrapKey(clusterID, nodeID) // 序列化集群节点信息
    data, err := bs.Marshal()
    if err != nil {
        panic(err)
    }
    wb.Put(k.Key(), data)
}</code></pre><ul><li><strong>获取Raft状态</strong></li></ul><p>实现：</p><pre><code>func (r *db) getState(clusterID uint64, nodeID uint64) (pb.State, error) {
    k := r.keys.get()
    defer k.Release()
    k.SetStateKey(clusterID, nodeID)
    hs := pb.State{}
    if err := r.kvs.GetValue(k.Key(), func(data []byte) error {
        if len(data) == 0 {
            return raftio.ErrNoSavedLog
        }
        if err := hs.Unmarshal(data); err != nil {
            panic(err)
        }
        return nil
    }); err != nil {
            return pb.State{}, err
    }
    return hs, nil
}</code></pre><h3>3.5对外存储API实现</h3><p>龙舟对ILogDB提供了实现：ShardedDB，一个管理了多个pebble bucket的存储单元。</p><pre><code>var _ raftio.ILogDB = (*ShardedDB)(nil)
// ShardedDB is a LogDB implementation using sharded pebble instances.
type ShardedDB struct {
    completedCompactions uint64             // 原子计数器：已完成压缩操作数
    config               config.LogDBConfig // 日志存储配置
    ctxs                 []IContext         // 分片上下文池，减少GC压力
    shards               []*db              // 核心：Pebble实例数组
    partitioner          server.IPartitioner // 智能分片策略器
    compactionCh         chan struct{}      // 压缩任务信号通道
    compactions          *compactions       // 压缩任务管理器
    stopper              *syncutil.Stopper  // 优雅关闭管理器
}</code></pre><ul><li><strong>初始化过程</strong></li></ul><p>实现：</p><pre><code>// 入口函数：创建并初始化分片日志数据库
OpenShardedDB(config, cb, dirs, lldirs, batched, check, fs, kvf):


    // ===阶段1：安全验证===
    if 配置为空 then panic
    if check和batched同时为true then panic


    // ===阶段2：预分配资源管理器===
    shards := 空数组
    closeAll := func(all []*db) { //出错清理工具
        for s in all {
            s.close()
        }
    }


    // ===阶段3：逐个创建分片===
    loop i := 0 → 分片总数:
        datadir := pathJoin(dirs[i], "logdb-"+i)  //数据目录
        snapdir := ""                           //快照目录(可选)
        if lldirs非空 {
            snapdir = pathJoin(lldirs[i], "logdb-"+i)
        }


        shardCb := {shard:i, callback:cb}      //监控回调
        db, err := openRDB(...)                //创建实际数据库实例
        if err != nil {                        //创建失败
            closeAll(shards)                   //清理已创建的
            return nil, err
        }
        shards = append(shards, db)


    // ===阶段5：核心组件初始化===
    partitioner := 新建分区器(execShards数量, logdbShards数量)
    instance := &amp;ShardedDB{
        shards:      shards,
        partitioner: partitioner,
        compactions: 新建压缩管理器(),
        compactionCh: 通道缓冲1,
        ctxs:       make([]IContext, 执行分片数),
        stopper:    新建停止器()
    }


    // ===阶段6：预分配上下文&amp;启动后台===
    for j := 0 → 执行分片数:
        instance.ctxs[j] = 新建Context(saveBufferSize)


    instance.stopper.RunWorker(func() {        //后台压缩协程
        instance.compactionWorkerMain()
    })


    return instance, nil                      //构造完成
    </code></pre><p><img width="723" height="532" referrerpolicy="no-referrer" src="/img/bVdnbqo" alt="" title="" loading="lazy"/></p><ul><li><strong>保存集群状态</strong></li></ul><p>实现：</p><pre><code>func (s *ShardedDB) SaveRaftState(updates []pb.Update, shardID uint64) error {
    if shardID-1 &gt;= uint64(len(s.ctxs)) {
        plog.Panicf("invalid shardID %d, len(s.ctxs): %d", shardID, len(s.ctxs))
    }
    ctx := s.ctxs[shardID-1]
    ctx.Reset()
    return s.SaveRaftStateCtx(updates, ctx)
}


func (s *ShardedDB) SaveRaftStateCtx(updates []pb.Update, ctx IContext) error {
    if len(updates) == 0 {
        return nil
    }
    pid := s.getParititionID(updates)
    return s.shards[pid].saveRaftState(updates, ctx)
}</code></pre><p><strong>以sylas为例子，我们每个分片都是单一cluster，所以logdb只使用了一个分片，龙舟设计初衷是为了解放多cluster的吞吐，我们暂时用不上，tindb可以考虑</strong>：</p><p><img width="723" height="388" referrerpolicy="no-referrer" src="/img/bVdnbqp" alt="" title="" loading="lazy"/></p><h2>四、总结</h2><p>LogDB是Dragonboat重要的存储层实现，作者将Pebble引擎包装为一组通用简洁的API，极大方便了上层应用与存储引擎的交互成本。</p><p>其中包含了很多Go语言的技巧，例如大量的内存变量复用设计，展示了这个库对高性能的极致追求，是一个十分值得学习的优秀工程案例。</p><h3>往期回顾</h3><p>1. 从数字到版面：得物数据产品里数字格式化的那些事</p><p>2. 一文解析得物自建 Redis 最新技术演进</p><p>3. Golang HTTP请求超时与重试：构建高可靠网络请求｜得物技术</p><p>4. RN与hawk碰撞的火花之C++异常捕获｜得物技术</p><p>5. 得物TiDB升级实践</p><h3>文 /酒米</h3><p>关注得物技术，每周更新技术干货</p><p>要是觉得文章对你有帮助的话，欢迎评论转发点赞～</p><p>未经得物技术许可严禁转载，否则依法追究法律责任。</p>]]></description></item><item>    <title><![CDATA[嘉为蓝鲸OpsPilot 深度集成 De]]></title>    <link>https://segmentfault.com/a/1190000047432052</link>    <guid>https://segmentfault.com/a/1190000047432052</guid>    <pubDate>2025-11-27 13:01:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>本文来自腾讯蓝鲸智云社区用户: CanWay</blockquote><p>原文链接:<a href="https://link.segmentfault.com/?enc=Oj7aGPPFGsL2Ceg6nVvugw%3D%3D.GJdxgZy3%2BQ9dSZ4J4WVlgNcyRgMWcdC7PFSObEBjjg0RMwqm9RpUbH7lYHuClujhn74rELTBMNEMKdqZoeXOgA%3D%3D" rel="nofollow" target="_blank">DeepSeek已接入！OpsPilot探索智能运维无限可能！</a></p><p>在数字化转型的浪潮中，运维工作正面临着复杂度高、效率低、响应慢等挑战。以Open AI 、DeepSeek为领导者的大模型层出不穷，在此背景下，OpsPilot作为新一代智能运维支撑平台，通过深度集成DeepSeek等大语言模型（LLM，Large Language Model），结合领先的ChatOps、知识增强与算法引擎技术，为企业提供智能化、自动化、场景化的智能运维平台引擎。</p><p>OpsPilot是一款集知识库管理、技能配置、机器人管理和工具管理为一体的智能运维支撑平台，其核心优势在于其对LLM大模型的深度集成能力，通过结合LLM大模型强大语义理解、知识增强与多模态处理能力，从而实现运维相关的问答和操作。此外，OpsPilot更加聚焦于运维领域，超出单个LLM大模型的能力范畴，成为更懂运维的智能AI平台。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047432054" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><h2>OpsPilot以大模型为引擎，实现多种功能与场景</h2><p>OpsPilot 平台与大模型关系紧密，它基于大模型的能力构建了平台核心功能，在用户问题识别、回复智能总结、知识智能处理和工具灵活调用的阶段，充分发挥大模型的优势，使之更适合企业使用场景。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047432055" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h2>OpsPilot平台基于大模型，优于大模型</h2><p>LLM 大模型是通用的 AI 工具，适合处理语言任务，但需要定制才能用在具体业务场景。而OpsPilot 是一个专注企业运维和业务管理的工具，基于大模型技术，但是在大模型基础上提供更丰富的功能和能力，业务系统通过API调用OpsPilot，相较于直接使用LLM大模型，可具备如下优势：</p><ul><li>功能丰富：OpsPilot是一款专为企业运维和业务管理场景设计的应用平台。基于大模型技术，OpsPilot不仅扩展了其功能，还将大模型技术转化为具体应用功能，如知识库管理、机器人管理和工具管理等。</li><li>运维适配：OpsPilot注重运维场景，自带丰富的运维知识和专业运维工具包，并且支持ChatOps运维执行。它能够高效满足企业在知识管理、智能问答和运维辅助等方面的需求。</li><li>数据来源多样：除了利用LLM（大模型）的自有知识库外，OpsPilot还支持对自有知识的清洗和存储，并能够进行联网问答以及调用业务系统中的数据。</li><li>使用规则场景化：OpsPilot内置多种使用规则，如千人千面的个性化设置、Token配额规则以及权限规则，适用于各种应用场景。</li></ul><h3>01.大模型驱动，解锁多元智能模型</h3><p>OpsPilot的Provide模块支持多类模型，提升了从语义理解、智能总结到图像识别等AI能力。比如：知识向量化由Embed模型实现，使语义表达更加准确；ReRank模型优化了知识检索结果的排序能力；OCR模型则支持图像转文本的精准识别。从而实现知识清洗、知识检索、智能问答等方面的智能化。</p><p>在LLM大模型方面，OpsPilot支持国内外大模型的接入与拓展，包括DeepSeek、ChatGPT、文心一言等，能够根据企业需求动态适配不同场景。通过自动训练与模型持续优化能力，OpsPilot能够针对特定运维任务，快速生成最佳的智能回复和自动执行，确保高效稳定的运维服务。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047432056" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>02.深度融合，知识处理智能化升级</h3><p>OpsPilot知识库模块旨在支持高效的知识管理与智能检索。用户可上传文本、网页、Excel等多种格式的文档，并通过分块解析、语义分析及OCR提高处理质量。支持文本、向量及混合检索模式，并提供检索结果优化与训练功能，增强知识精度和可用性。</p><p>其中，DeepSeek等大模型在知识清洗和处理过程中，对知识分块进行增强，对运维知识进行结构化处理，构建更容易检索的知识图谱，为运维人员提供更精准的知识支持。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047432057" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047432058" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>03.全面赋能，多场景 Bot 问答提效</h3><p>OpsPilot 的机器人管理功能涵盖了从创建到全生命周期的管理，核心功能包括支持技能的创建、配置与测试，通过RAG技术结合知识库实现智能化回复；支持机器人基础信息配置、模型选择及对话能力优化；多渠道消息交互（如Web、企业微信、钉钉等）提升用户覆盖；并通过对话数据的记录和分析，保障信息的可靠性与可追溯性，从而满足不同场景下的机器人管理与运营需求。</p><p>基于以上强大的管理能力，OpsPilot进一步结合 DeepSeek 等大模型，全面赋能私域知识问答场景，能够为企业在特定运维场景（如系统故障定位、容量规划等）提供高效的定制化问答服务。通过上下文感知的智能对话交互，运维人员可迅速获取精准信息，从而显著提升问题解决效率。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047432059" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047432060" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>04.ChatOps 助力，工具调用自动化</h3><p>OpsPilot支持Tool模块，支持与多系统集成和调用，ChatOps技术将DeepSeek等大模型与工具调用能力相结合，能够实现复杂运维场景的自动化操作。例如，在故障自愈场景中，OpsPilot可以通过对话引导调用预定义的运维工具或脚本，快速完成故障定位与修复。这种能力不仅提升了运维效率，还降低了人为操作失误的风险，为企业提供更可靠、更智能的运维服务。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047432061" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>OpsPilot是一款集智能、自动化、场景化于一体的智能运维支撑平台。通过深度集成DeepSeek等多款大模型，结合ChatOps增强、知识增强与算法引擎技术，OpsPilot能够帮助企业实现运维效率的全面提升，降低运维成本，助力业务创新与增长。</p>]]></description></item><item>    <title><![CDATA[服务器数据恢复—从盘片划痕到数据重生：服]]></title>    <link>https://segmentfault.com/a/1190000047432075</link>    <guid>https://segmentfault.com/a/1190000047432075</guid>    <pubDate>2025-11-27 13:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>服务器硬盘故障：</strong><br/>服务器存储中有一组raid。该组raid中的两块硬盘出现故障：一块硬盘已经开盘，盘片损伤严重；另一块硬盘虽然没有开盘，但是可以初步判断其盘片也存在损伤。需要恢复该组raid数据。</p><p><strong>服务器硬盘数据恢复过程：</strong><br/>1、检测已经开过盘的硬盘，发现硬盘盘面有规则的同心圆状划痕，属于典型的磁头故障导致盘片划伤，数据无法恢复。<br/>2、对另一块未开盘的硬盘进行检测和开盘，开盘后发现该硬盘的磁头损坏，在盘片上检测到极微小的划痕。可以通过更换磁头、盘片处理等方式恢复数据，经过北亚企安数据恢复工程师的一番努力，终于将损坏的硬盘数据完整提取。<br/>3、服务器数据恢复工程师收集了故障服务器存储上的日志信息，根据获取到的相关信息虚拟重组raid。<br/>4、通过位图信息在虚拟重组出来的raid中提取lun信息，导出数据并进行验证。<br/>5、经过验证，恢复出来的数据均可正常使用。<br/>6、用户方工程师对数据进行验证，确认恢复出来的数据完整有效。</p>]]></description></item><item>    <title><![CDATA[Ilya重磅发声：Scaling时代终结]]></title>    <link>https://segmentfault.com/a/1190000047431764</link>    <guid>https://segmentfault.com/a/1190000047431764</guid>    <pubDate>2025-11-27 12:16:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431766" alt="" title=""/></p><p>编辑：桃子 KingHZ</p><p>【新智元导读】Ilya重磅访谈放出！1个半小时，全程2万字，他爆出惊人观点：Scaling时代已终结，我们正走向研究时代。</p><p>Scaling时代已终结！</p><p>Ilya一现身，金句必出。还记得NeurIPS 2024上，他曾向世界宣告：「预训练时代终结」。</p><p>这一次，Ilya在镜头前平静地说出这句话时，整个AI圈都屏住了呼吸——</p><p>我们已从Scaling时代，正走向研究时代。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431767" alt="" title="" loading="lazy"/></p><p>在这场与著名主持人Dwarkesh Patel的深度访谈中，Ilya几乎把当前AI研究最刺痛的真相揭开了：</p><p>不仅仅是预训练，就连Scaling Law这条路，已经被他判了「缓刑」——还能继续走，但绝不会通向AGI！</p><p>他还指出，今天的模型再强，泛化能力也远远配不上其参数量和Benchmark的分数，甚至远逊于人类。</p><p>最关键的是，Ilya已对技术缺失的环节形成清晰的思路，但选择暂不公开更多的细节。</p><p>这场长达1个半小时对谈，Ilya还探讨了SSI战略、AI模型泛化能力提升关键，以及AGI未来的发展路线。</p><p>核心亮点一览：</p><ul><li>当前技术路线后劲不足——模型虽持续改进，但无法实现AGI</li><li>真正可行的系统架构我们至今尚未掌握构建方法</li><li>核心瓶颈：泛化能力，而模型在此领域远逊人类</li><li>即便用所有编程竞赛题目训练模型，它仍无法形成真正的「解题直觉」</li><li>评估分数光鲜亮丽，但实际性能滞后——RL训练最终演变为对评估指标的过度优化</li><li>真正的奖励机制黑客，实则是设计这些基准测试和研究循环的科研人员</li><li>ASI可能在5-20年内降临</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431768" alt="" title="" loading="lazy"/></p><p>这场对话，将成为这一年，或许更远未来的序章。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431769" alt="" title="" loading="lazy"/></p><p><strong>预训练遇瓶颈，AI与现实脱节</strong></p><p>访谈伊始，Ilya Sutskever感慨道，「想到这一切都是真的，真的有点疯狂」！</p><p>住在湾区，经常会看到「拿出美国1%GDP投AI、某某公司又投xx美元」这类疯狂的事，就像是从科幻小说的情节。</p><p>奇怪的是，一切又好像没有什么变化。</p><p>AI模型在智力上实现了飞跃，但它们对经济的实际渗透却慢得多。</p><p>Ilya坦言，这正是当前AI令人困惑，最矛盾的点之一：</p><p>在各种基准评测中，AI模型性能的表现几乎「超乎人们的想象」，但在真实世界中，它却常常犯一些让人抓狂的错误。</p><p>假设你用vibe coding编码，出现bug→模型修bug→引入第二个bug→指出第二个bug→模型修第二个bug→又把第一个bug带回来。</p><p>至少人类在写代码时，至少知道不要重复犯同样的错误，但LLM像是在两个bug之间来回「跳房子」。</p><p>为什么会这样？这种现象背后最深层的原因，究竟是什么？</p><p>这里，Ilya给出了两种解释——</p><p>1. RL训练会让模型目标变得单一、狭隘，在某种程度上削弱了其全局感知能力，但又有时在其他方面，又增强了其「察觉」的能力。</p><p>也正因为这样，它们反而做不好一些很基础的事情。</p><p>2. 预训练会用上「全部数据」，而RL则讲究定向优化，精确界定为达成的目标使用特定数据。</p><p>也就是说，可设计的RL环境自由度大，便会有一些倾向性，即开发者不自觉地「从各种评测里获得灵感」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431770" alt="" title="" loading="lazy"/></p><p>再结合当前LLM泛化仍不充分这一事实，很可能解释为何「评测结果与现实应用」之间会出现明显脱节。</p><p>说了这么多，Ilya核心观点就是——</p><p>真正钻测评空子的不是模型，是设计基准和RL环境的人类研究者。</p><p>结果就是，训出的AI在参加竞赛题训练营方面无敌，但没有学会如何在陌生场景下举一反三。</p><p>他举例道，就好比两位学生，学生A把历史所有竞赛编程题刷一万个小时，成为超强的「竞赛程序员」。</p><p>而学生B也许只练了400个小时，但有真正的悟性、直觉、判断力，成绩也不错。</p><p>毋庸置疑，学生B将会在未来职业生涯发展得更好。这从侧面印证了，预训练和「天赋」是有很大的差异。</p><p>当主持人Dwarkesh问道，或许你在暗示，预训练本身没有那么强的泛化能力，之所以有效，是因为用到了海量数据，但不见得比RL泛化的好。</p><p>Ilya认为预训练主要优势有两个：第一，数据量大；第二，无需刻意挑选，有天然高度「真实性」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431771" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431772" alt="" title="" loading="lazy"/></p><p><strong>情绪价值函数</strong></p><p>那么，人类的「天赋」是什么？为什么比模型泛化更强？</p><p>在对话中，有一段核心观点非常发人深省——</p><p>人类的学习能力，不仅仅来自经验，还来自自进化硬编码的「价值函数」。</p><p>Ilya表示，科学家们曾发现，一个因为脑损伤失去情绪能力的人，智力没变、语言没变、逻辑没变，却变得极其不会做决定。</p><p>甚至，连穿袜子都要想半天。</p><p>也就是说，情绪并不是「多余的噪音」，而是决策系统的一部分。</p><p>这让我们不得不重新思考：人类与生俱来的情绪，在多大程度上是在帮我们成为一个在世界中「能正常运作的智能体」？</p><p>情绪，就是一种「价值函数」。</p><p>它会告诉你「这条路可以走」、「那条路很危险」、「这个方向不靠谱」….</p><p>再来看今天的AI，虽有类似的价值函数的训练方式，比如模型打分器，但比较脆弱、粗糙，还不是内置的。</p><p>这也就解释了，「情绪价值函数」之于预训练的重要性。</p><p>那么，预训练遭遇了瓶颈，Scaling Law又将如何呢？</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431773" alt="" title="" loading="lazy"/></p><p><strong>Scaling时代终结</strong></p><p><strong>现在是「研究时代」</strong></p><p>一直以来，人们都在说数据要Scaling、参数要Scaling、算力要Scaling，还有哪些可以Scaling的维度？</p><p>Ilya表示，预训练最大的突破，就是大家意识到的：这套Scaling「配方」真的好用。</p><p>现在，X上许多人都在讨论：Gemini好像找到了某种方式，可以从预训练中榨出更多的东西。</p><p>但是，在某个节点上，预训练总归会把数据用光的，数据显然是有限的。</p><p>或者可以这么讲：从2012年到2020年，是「研究的时代」；然后从2020年到2025年，是「Scaling的时代」。</p><p>但现在算力已经很大了，电脑已经非常非常强了，从某种意义上说，我们又回到了「研究的时代」。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431774" alt="" title="" loading="lazy"/></p><p>我们已经见证了一种Scaling方式的转换——从预训练的Scaling，切换到了RL的Scaling。</p><p>但是，RL非常烧算力，而且现有做法效率低。</p><p>不过Ilya再次提到，Scaling价值函数，让AI以更像人类的方式学习。</p><p>也就是，为模型内置类似人类的判断直觉、稳定价值感受器，任务过程中的「自我评分」，这样才能学得更快。</p><p>Ilya指出，Scaling时代的一个后果是——scaling 把屋子里的空气都吸干了，大家就都开始做同一件事。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431775" alt="" title="" loading="lazy"/></p><p>于是，我们来到了这么一个世界：公司数量远远多于点子数量，而且是远远多于。</p><p>Scaling时代，让大家都在做一样的事：大模型、更大模型，再大一点的模型。</p><p>但随着Scaling天花板临近，瓶颈变成了点子本身。</p><p>未来，我们将回到那种——小而美的实验产生巨大突破，大量奇怪的想法冒出来，以及不依赖超级算力的创新。</p><p>就像AlexNet当时仅用两张GPU训出，Transformer用8-64块GPU做出，包括ResNet同样如此。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431776" alt="" title="" loading="lazy"/></p><p>也许下一次重大范式转变，也来自一套「看起来不够大」的实验。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431777" alt="" title="" loading="lazy"/></p><p><strong>超级智能，还有5-20年</strong></p><p>Dwarkesh Patel更加当心ASI的风险——</p><p>超级智能的危害似乎不仅仅、会出现恶意的「回形针制造机」（paper clipper）。</p><p>他认为，ASI极其强大，我们甚至不知道该如何概念化人们会如何与它互动，以及人们会用它来做什么。所以，逐渐开放使用权限，似乎是一种更好的方式，可以分散其冲击力，并帮助人们做好准备。</p><p>关于这一点，Ilya认为即使在最顺利的发展路径中，你仍然会逐步发布它。渐进主义将是任何计划与生俱来的组成部分。</p><p>问题只在于你首先发布的是什么。这是第一点。</p><p>第二，持续学习，确实是重要且正确的。原因如下。</p><p>他举了一个例子说明语言如何影响思维。</p><p>这次，有两个词塑造了所有人的思维方式。第一个词：AGI（通用人工智能）。第二个词：预训练。</p><p>为什么「AGI」这个词会存在？这是一个非常特殊的术语。它的存在是有原因的。</p><p>在Ilya看来，「AGI」这个词存在的理由，并不主要是因为它是一个描述某种智能终极状态的重要且本质的描述符，而是因为它是对另一个已存在术语的反应，那个术语就是「狭义AI」。</p><p>如果你回溯到游戏AI的远古历史，比如跳棋AI、国际象棋AI、电脑游戏AI，每个人都会说，看这种狭窄的智能。当然，国际象棋AI能打败卡斯帕罗夫，但它别的什么也做不了。</p><p>它太狭隘了，是狭义的人工智能。因此，作为对此的回应，一些人说，这样不好。它太狭隘了。我们需要的是通用AI，一个能做所有事情的AI。这个词就获得了很大的关注度。</p><p>第二个获得极大关注的词是「预训练」，特别是预训练的配方。</p><p>他认为人们现在做强化学习的方式，或许正在消除「预训练」这个概念留下的烙印。</p><p>但预训练有这样一个特性：你做更多的预训练，模型在所有方面都会变得更好，或多或少是均匀地提升。预训练带来AGI。</p><p>但AGI和预训练带来的问题是，从某种意义上说，它们有些「矫枉过正」了。</p><p>如果在预训练的语境下，思考「AGI」这个词，你会意识到：人类其实并不是AGI。</p><p>是的，人类确实具备基础技能，但人类先天缺失海量的知识。相反，我们依赖的是持续学习。</p><p>所以当你设想：「好吧，假设我们成功造出了某种安全的超级智能。」</p><p>问题在于，你如何定义它？它处于持续学习曲线的哪个阶段？</p><p>人类好比造出了一个超级聪明的15岁少年，跃跃欲试。他懂的并不多，但他是个好学生，求知若渴。你可以对他说：「去当个程序员，去当个医生，去学习吧。」</p><p>因此，你可以想象，部署本身将包含一个通过试错来学习的时期。这是一个过程，而不是直接投放一个「最终成品」。</p><p>Ilya的意思是，超级智能并不是某种「完成形态」的心智，不需要一上来就懂得如何从事经济活动中的每一项工作。因为按照OpenAI最初的章程或其他类似的定义，AGI似乎被定义为能够胜任每一项工作、能做人类能做的每一件事。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431778" alt="" title="" loading="lazy"/></p><p><strong>而Ilya提出的是一种能够学会做每一项工作的心智，这才是超级智能。</strong></p><p>一旦拥有了这种学习算法，它就会被部署到现实世界中，类似于人类劳动力进入一家组织。</p><p>Ilya认为，如果实现这种算法，很可能会迎来一波快速的经济增长。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431779" alt="" title="" loading="lazy"/></p><p><strong>不再感受AGI</strong></p><p>这种局面其实非常危险。</p><p>从理论上说，我们知道它是可能实现的。只要有一个系统，它的学习能力与人类相当，但还能把多个「个体大脑」合并在一起，而这种能力是人类不具备的。那么，从物理角度来看，这样的系统是完全有可能存在的。</p><p>人类可以存在，数字计算机也可以存在，只要把这两者结合起来，这样的东西就能被造出来。</p><p>而它的威力也将是巨大的。比如你在SSI招一个人，大概六个月他就能开始「净贡献」了。人类已经学习得很快了，而这种AI的进步速度只会更快。</p><p>那你如何确保这个发展过程是良性的？SSI在这方面的优势是什么？换句话说，SSI到底有什么计划去应对这种局面？</p><p>Ilya认为实际情况是，在实践中很难「切身感知」到 AGI（通用人工智能）。</p><p>我们可以谈论它，但试想一下，当你并未年老体衰时，去谈论变老和虚弱的感觉。你可以对话，你可以试着想象，但这很难，你终究会回到现实，发现自己并非如此。</p><p>他认为围绕AGI及其未来力量的许多问题，都源于它很难被想象。</p><p>实际上，AI和AGI的本质区别是什么？就是力量（power）。整个区别就在于力量。</p><p>当力量真的很大时，会发生什么？在过去一年里，Ilya改变了一点想法——</p><p>如果很难想象，你该怎么办？你必须展示它。</p><p>他坚持认为，大多数从事AI工作的人也无法想象AGI，因为它与人们日常所见迥然不同。</p><p>他坚持认为，随着AI变得越来越强大，人们会改变行为。</p><p>我们将看到各种前所未有的事情发生，而这些现在还没有发生。举几个例子。</p><p>无论是好是坏，前沿AI公司将在未来的发展中扮演非常重要的角色，政府也是如此。</p><p>将来，竞争激烈的公司开始在AI安全方面进行合作。OpenAI和Anthropic迈出了第一小步，但这在以前是不存在的。</p><p>大约三年前，Ilya在一次演讲中就预测过的，这种事情将会发生。他还坚持认为，随着AI继续肉眼可见地更强大，政府和公众也会产生做点什么的愿望。「展示AI」是一股非常重要的力量。</p><p>Ilya还坚信，目前AI从业者之所以感觉不到AI的强大，是因为AI还会犯错。</p><p>他确信，在某个时刻，AI实际上会开始让人感到强大。当那一刻来临时，我们将看到对待安全的方式，所有AI公司都发生巨大变化。他们会变得更加充满危机感（paranoid）。</p><p>这是一个预测，但大家会看到它发生。</p><p>还有第三件事——</p><p>一直以来，大家都入坑了「自我进化AI」（self-improving AI）。</p><p>为什么会这样？因为想法比公司少。</p><p>但Ilya坚信，有一种更好的东西值得构建，而且每个人都会想要它。</p><p>那就是一个被稳健对齐（robustly aligned）、专门关爱「有感知能力的生命」（sentient life）的AI。</p><p>他特别有理由相信，构建一个关爱有感知生命的 AI，比构建一个仅关爱人类生命的 AI 要容易.</p><p>因为AI本身也将是有感知的。如果你考虑到镜像神经元和人类对动物的同理心——</p><p>你可能会争辩说这种同理心还不够强，但它确实存在。</p><p>他认为这是一种涌现属性，源于这样一个事实：我们使用模拟自己的同一套神经回路去模拟他人，因为那是最高效的方式。</p><p>Ilya预测，大概5到20年能够像人类一样学习并因此随后变得超越人类AI系统就会出现。</p>]]></description></item><item>    <title><![CDATA[爆火全网FLUX.2重磅上线，开源版Na]]></title>    <link>https://segmentfault.com/a/1190000047431748</link>    <guid>https://segmentfault.com/a/1190000047431748</guid>    <pubDate>2025-11-27 12:15:53</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>编辑：元宇</p><p>【新智元导读】Black Forest Labs的开源视觉模型FLUX.2上新，这是一款专为现实创意工作流程打造，绝非演示噱头的生产力工具，与前代FLUX.1相比，实现了从「会画」到「懂你要画什么」的跃升。</p><p>设计师要解放了！</p><p>刚刚，专为真实设计流程打造的视觉AI模式重磅发布。</p><p>假设你是一名设计师，正准备做一份产品海报。</p><p>按以往流程，你要先找图、修图、调光、排版、对齐Logo、试十几版字体……</p><p>等这些都做完了，也许客户或老板早已等得不耐烦了，也许后面还有无穷的改稿等着你。</p><p>「不是我没创意，而是时间不够！」</p><p>灵光乍现很简单，乍现的灵光落实到执行层大都是耗时费力的苦活累活。</p><p>如果有一天你只需要告诉电脑，你想出一份什么样的产品海报，这些苦活累活都有人帮你干了，这是一种什么感觉？</p><p>近日，Black Forest Labs推出的一款FLUX.2的视觉模型，让这这件事成为可能。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431750" alt="" title=""/></p><p>FLUX.2是一款专为现实创意工作流程打造，绝非演示噱头的生产力工具。</p><p>更重要的一点，它是开源的。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431751" alt="" title="" loading="lazy"/></p><p>更低的价格，纳米香蕉版的品质，妥妥的设计师福利。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431752" alt="" title="" loading="lazy"/></p><p><strong>不炫技，让前沿视觉AI人人可用</strong></p><p>FLUX.2 专为真实世界的创意工作流程打造，而不是只做演示或炫技。</p><p>它能够生成高质量图像，并在多个参考图像之间保持角色和风格的一致性；能理解结构化提示词；能阅读与生成复杂文本；能稳定处理光照、布局与Logo……</p><p>此外，它还能在最高4兆像素下进行图像编辑，同时保持细节与整体一致性。</p><p>这些媲美顶级视觉模型的能力，如今已经全部开源，这与Black Forest Labs的开放核心理念有关：</p><p>「我们相信，视觉智能应该由全球的研究者、创作者和开发者共同塑造，而不是集中在少数人手中。」</p><p>因此，自2024年创立之日起，他们一直致力于将前沿能力与开放研究结合，发布强大、透明且易组合的开放权重模型，同时为需要规模化、可靠性与自定义的团队提供稳健、可直接投入生产的服务接口。</p><p>它们将 FLUX.1 [dev]（全球最受欢迎的开放图像模型）与专业级模型 FLUX.1 Kontext [pro] 结合，后者已被Adobe、Meta等团队使用。</p><p>Black Forest Labs通过开放核心策略促进实验、降低成本、鼓励审查，并确保能持续地把来开放技术带给更多的人。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431753" alt="" title="" loading="lazy"/></p><p><strong>FLUX.2</strong></p><p><strong>从能画东西，到「懂你要画什么」</strong></p><p>FLUX.1作为创意工具已经很强了，能跟随提示词作创意。</p><p>FLUX.2的升级，像从「会画画的人」跃迁到「会观察、会分析、会推理的视觉大脑」。</p><p>这意味着前沿视觉AI能力正在改变生产流程和成本结构，成为未来创意基础设施中不可替代的组成部分。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431754" alt="" title="" loading="lazy"/></p><p>所有FLUX.2变体均在一个模型中提供基于文本和多个参考图像的图像编辑功能。</p><p>为什么FLUX.2能够懂你要画什么，并且按照你的意思画出来，因为它一次把下列能力组合在了一起：</p><ul><li>多参考支持：一次最多读10张参考图像，可以实现目前最佳的角色 / 产品 / 风格一致性。</li><li>图像细节与拟真度提升：更高细节、更锐利的纹理、更稳定的光照，适用于产品拍摄、可视化与类摄影应用。</li><li>更强文本渲染：复杂排版、信息图、表情包、UI设计稿中的小字现在可以稳定生成。</li><li>听得懂复杂指令：更强的提示词遵循能力，对复杂、结构化、多部分提示词与组合约束的执行更稳定。</li><li>理解空间与光线：更强世界知识理解，对真实世界、光照逻辑与空间结构的理解更扎实，使生成场景更自然、更符合预期。</li><li>高分辨编辑：更高分辨率与更灵活的比例，支持最高4兆像素的图像编辑。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431755" alt="" title="" loading="lazy"/></p><p>输出多样性：FLUX.2能够生成高度精细的逼真图像以及包含复杂排版的信息图，分辨率最高可达400万像素（4MP）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431756" alt="" title="" loading="lazy"/></p><p><strong>开箱即用</strong></p><p><strong>FLUX.2模型家族</strong></p><p>性价比是FLUX.2模型系列的强项，在各性能层级中以极具竞争力的价格提供业界领先的图像生成质量。</p><p>FLUX.2模型家族从完全托管、可直接生产的API，一直到开发者可本地运行的开放权重模型一应俱全。</p><p>下面是FLUX.2 [pro]、FLUX.2 [flex]、FLUX.2 [dev] 与 FLUX.2 [klein] 的定位与适用场景：</p><ul><li><strong>FLUX.2 [pro]</strong>：图像质量达到顶级封闭模型水平，提示词遵循与画面保真度表现一流，同时生成更快、成本更低，实现速度与质量的双赢。可在BFL Playground、BFL API及合作伙伴平台使用。</li><li><strong>FLUX.2 [flex]</strong>：允许调整步数、引导规模等参数，让开发者在质量、提示词执行力与速度之间自定义平衡。尤其擅长渲染文本与精细细节。可在bfl.ai/play、 BFL API及合作伙伴平台使用。</li><li><strong>FLUX.2 [dev]</strong>：32B 开放权重模型，由 FLUX.2 基础模型衍生，是目前最强的开放权重图像生成与编辑模型。它将文本生成图像与多图像编辑集成在一个 checkpoint 中。权重已在Hugging Face发布，可使用官方推理代码本地运行。在消费级 GPU（如 GeForce RTX）上，可使用 NVIDIA 与 ComfyUI 合作优化的 fp8 推理版本。你也可以通过 FAL, Replicate, Runware, Verda, TogetherAI, Cloudflare, DeepInfra的API使用 FLUX.2 [dev]。</li><li><strong>FLUX.2 [klein]（即将上线）</strong>：开源、Apache 2.0模型，由FLUX.2基础模型尺寸蒸馏而来，比同类从零训练的模型更强、更适合开发者，并保留大量教师模型的能力。可以加入测试计划。</li><li><strong>FLUX.2 – VAE</strong>：全新的变分自编码器，在可学习性、质量与压缩率之间实现最佳平衡，是所有FLUX.2 flow主干的基础。技术报告已发布，模型在HF上以Apache 2.0许可提供。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431757" alt="" title="" loading="lazy"/></p><p>使用可变步数生成设计：FLUX.2 [flex] 的「步数」参数允许在排版精度与延迟之间自由权衡。从左到右：6步、20步、50步。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431758" alt="" title="" loading="lazy"/></p><p>通过可变步数控制图像细节：FLUX.2 [flex] 提供了一个「步数」参数，用于在图像细节和延迟之间进行权衡。从左至右分别为：6 步、20 步、50 步。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431759" alt="" title="" loading="lazy"/></p><p>FLUX.2 系列以极具竞争力的价格提供顶级图像生成质量，跨不同性能层级都具备最强性价比。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431760" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431761" alt="" title="" loading="lazy"/></p><p>对于开放权重模型，FLUX.2 [dev] 设立了新的业界标准，在文本生成图像、单参考编辑、多参考编辑等方面均达领先水平，并稳定超越所有其他开放权重替代品。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431762" alt="" title="" loading="lazy"/></p><p><strong>工作原理</strong></p><p>FLUX.2基于潜空间的流匹配架构构建，并将图像生成与编辑整合在同一个模型中。</p><p>该模型将24B参数的Mistral-3视觉语言模型与rectified flow Transformer 结合。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431763" alt="" title="" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=pI2YSvXq3BnaTlaTGFOy0Q%3D%3D.x7OGSRNQP9UTNwfyXxZ7uAZ4Zu547c1wxmiymf%2Fgn2MNFCMZY51VXi%2FOkM0LfdO6g2vpEB6wwnq8Uk4fh8O5cA%3D%3D" rel="nofollow" target="_blank">https://docs.mistral.ai/model...</a></p><p>VLM提供现实世界知识与语境理解，而Transformer捕捉空间结构、材质特性与构图逻辑，这些是早期架构难以呈现的。</p><p>研究人员从零重新训练了模型的潜空间，使其在可学习性与图像质量之间取得更优平衡。</p><p>参考资料：</p><p><a href="https://link.segmentfault.com/?enc=CTrwPLQay6nEUHak%2FnS9CQ%3D%3D.23A9nyL%2FB1LtIZL8SxoSxlRO%2B7J3jSzs5NG15M6Pq9c%3D" rel="nofollow" target="_blank">https://twitter.com/bfl</a>\_ml/status/1993345470945804563?s=20%20</p><p><a href="https://link.segmentfault.com/?enc=YQWK0oTNr2bmrQEwtxIjpA%3D%3D.pnFADqnXZWXAkkWnS%2FR5QM1PErGe1NMgCYvaAIIPjzc%3D" rel="nofollow" target="_blank">https://bfl.ai/blog/flux-2</a></p>]]></description></item><item>    <title><![CDATA[今日AI要闻汇总|2025年11月27日]]></title>    <link>https://segmentfault.com/a/1190000047431744</link>    <guid>https://segmentfault.com/a/1190000047431744</guid>    <pubDate>2025-11-27 12:15:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>1、<strong>Claude Opus 4.5智力指数冲到第二</strong>，编程与代理性能暴涨，联手Gemini 3 Pro重绘前沿大模型天梯榜</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431746" alt="" title=""/></p><p>2、OpenAI给ChatGPT立下2030年前2.2亿付费用户KPI，又筹备Images V2对标Nano Banana，汇丰却算出2070亿美元算力黑洞</p><p>3、Nature与Science同时押注“AI科学家”，特朗普启动“创世纪计划”开放国家实验室数据，UT奥斯汀史诗级抄底4000枚Blackwell</p><p>4、谷歌TPU外卖传闻吓跌英伟达又计划送芯片上太空，xAI巨型数据中心88英亩光伏仍杯水车薪，全球算力大战全面升级</p><p>5、智能体进化与商业化双加速：贝索斯布局“物理AI”收购初创公司，新技术LatentMAS让多智能体协作成本骤降八成</p><p>6、<strong>MIT“冰山指数”称AI理论上已能替代11.7%美国劳动力、撬动1.2万亿美元工资</strong>，加上麦肯锡裁掉200技术岗白领焦虑升级</p><p>7、德勤数百万美元政府报告被曝引用AI伪造论文，AI菜谱与智能体被发现会“乱来”甚至窃.env，连AI从业者都不敢把琐事外包给机器人</p><p>8、<strong>奥斯卡团队纪录片《The Thinking Game》揭秘DeepMind从围棋到AlphaFold之路</strong>，亚太五大案例展示AI如何改写生命科学研究范式</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431747" alt="" title="" loading="lazy"/></p><p>9、算力基建飞向太空：谷歌微软竞相将数据中心送入轨道，意图利用无限太阳能与低温环境彻底破解地球算力能耗瓶颈</p><p>10、特朗普启动“创世纪计划”打造AI国家队，德州大学竟凭五年前合约以“白菜价”成功抄底英伟达Blackwell算力集群</p><p><strong>汇编：犀牛 查看更多要闻详情：<a href="https://link.segmentfault.com/?enc=hsuIyVY8%2FityQpv9NWOz9Q%3D%3D.OfSLd1%2FJl2nBUJcihoPnV7pJCnnU2yyANDx0s1CzclI%3D" rel="nofollow" target="_blank">https://aiera.com.cn/</a></strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047404235" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[Vibe Coding 的爱与恨：AI ]]></title>    <link>https://segmentfault.com/a/1190000047431525</link>    <guid>https://segmentfault.com/a/1190000047431525</guid>    <pubDate>2025-11-27 12:14:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431527" alt="" title=""/></p><p>在本届 RTE2025 大会上，来自产业界和学术界的多位专家深入探讨了如何赋能 AI 开发者，高效、稳定地构建下一代应用？又该如何设计新的协同模式，实现人机能力的最佳融合？</p><p>亚马逊云科技资深开发者布道师<strong>郑予彬</strong>、TEN Framework Co-Founder <strong>Plutoless</strong>、memU founder <strong>陈宏</strong>、月之暗面开发者关系负责人<strong>唐飞虎</strong>、PPIO 智算业务云产品技术专家<strong>王贺</strong>、MiniMax 开发者生态负责人<strong>冯雯</strong>等技术专家、开发者和创业者，一同探索上下文工程和 Agentic AI 开发、分享了他们在各自领域的实践经验和独到见解。</p><hr/><p>声网大语言模型实验室高级科学家李忻玮和 TEN Framework 的 Co-founder <strong>Plutoless</strong>分别主持了活动主题分享和圆桌讨论环节。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431528" alt="" title="" loading="lazy"/></p><h2>郑予彬：构建智能应用的新引擎——AWS Kiro 与 Stands Agent SDK 的实践与展望</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431529" alt="" title="" loading="lazy"/></p><p>亚马逊云科技的开发者布道师郑予彬梳理了 AI 在代码开发领域的范式演进。</p><p>她指出，早期的 AI 辅助开发主要停留在代码补全等「一对一」的触发式交互，其效率极限受限于人的指令速度。真正的突破源于 AI Agent 的出现，它将大语言模型从一个被动的对话者转变为能够自我推理、使用工具并参与框架性思考的主动协作者。</p><p>基于 <strong>ReAct（Reasoning and Acting）等模式</strong>，Agent 可以通过调用外部工具和数据来获取上下文，从而克服模型的「幻觉」问题，更深刻地理解复杂需求，实现了<strong>从「单点智能」到「系统化智能」</strong>的飞跃。</p><p>为将在生产环境中落地这一新范式，亚马逊云科技推出了 Stands Agent SDK 与 AWS Kiro 两大项目。</p><p><strong>Stands Agent SDK 是一个帮助开发者快速构建 AI Agent 的脚手架。</strong> 它支持灵活切换多种大模型（如 BedRock、Anthropic）、集成各类工具，并内置了如 Orchestrator、Swarm、Graph 等多种主流的 Multi-Agent 协作模式。</p><p><strong>AWS Kiro 则是一款具体的 IDE 工具</strong>，它直面了当前 AI 开发的两种核心路径：一种是完全由自然语言驱动的「Vibe Coding」，郑予彬坦诚这种「黑盒式」的开发方式虽适合快速原型验证，但在实际项目中因其过程不可控，曾让他「失败了无数次」；另一种则是 Kiro 倡导的 <strong>「Spec-driven Development」</strong>，该模式将开发流程拆解为项目理解、需求分析、方案设计等多个可控、可验证的步骤，每一步都有人的监督和文档的沉淀，让 AI 在清晰的框架内高效协作，最终实现真正可用于生产的 AI 开发工作流。</p><p>「 AI 时代，我们不做选择题，我们全都要——关键在于，在不同的生产阶段，采用合适的工作方式，比如到底选择 Vibe Coding 还是 Spec-driven。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431530" alt="" title="" loading="lazy"/></p><p><strong>郑予彬</strong></p><p>亚马逊云科技开发者布道师</p><h2>Plutoless：会说话的 AI——使用 TEN Framework 构建自然对话体验的工程哲学</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431531" alt="" title="" loading="lazy"/></p><p>TEN Framework Co-Founder Plutoless 指出，过去一年，对话式 AI 行业普遍存在「卷延迟」的现象，即 AI 回复越快越好。然而，在实际商业化落地过程中，这种做法往往导致糟糕的用户体验，例如 AI 抢话、用户被频繁打断等问题。</p><p><strong>行业正从追求极致延迟转向更看重整体对话体验。</strong></p><p>他认为，宁愿牺牲一点延迟，也要保证对话的完整性和流畅性，避免 AI 反复打断用户。 TEN Framework 通过对打断与回复、背景人声干扰、AI 响应灵敏度等问题的工程化解决方案，实现了更拟人化的对话。</p><p>TEN Framework 的设计旨在将模型能力与体验需求策略模块化，允许开发者像「搭积木」一样构建对话式应用，支持 ASR、LLM、TTS 等多种 TOP 模型，并特别优化了 Python 和 C++ 的混合编程能力，以应对生产环境的性能挑战。</p><p>他重点介绍了 TEN Framework 在解决行业痛点方面的具体实践，例如 TEN VAD 模型用于精确人声探测，过滤背景噪声，以及 TEN Turn Detector 模型用于实现基于上下文感知的轮次检测，确保对话的流畅进行。在多模态和多语言支持方面，TEN Framework 也提供了强大的能力，能够应对不同区域的语言需求和复杂场景。</p><p>TEN Framework 目前更侧重于灵活的链式模型构建，这在当前商业化落地场景中更具优势，因为其可定制性和易于调整的特性能够更好地满足垂类业务的需求。</p><p>Plutoless 将当前行业的发展划分为四个阶段，从早期的轮次对话，到自然拟人的对话，再到 AI 并行思考和执行，直至最终的情感智能和超越人类的通用智能。</p><p>TEN Framework 的目标是将对话式 AI 的开发门槛降低，并加速行业标准的形成，让开发者能够更快速、更高效地构建出高质量的对话式 AI 应用。</p><p>「对话式 AI 行业正从追求极致延迟转向更看重整体对话体验。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431532" alt="" title="" loading="lazy"/></p><p><strong>Plutoless</strong></p><p>TEN Framework Co-Founder</p><h2>陈宏：构建有长期记忆的应用——memU 最佳实践</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431533" alt="" title="" loading="lazy"/></p><p>memU 的 founder 陈宏直言当前主流的 RAG 方案 <strong>「体验非常差，不能保证召回的准确率」</strong> 。正是基于这个痛点，memU 诞生了，它提供了一种全新的 Agentic Memory 框架，目标是<strong>让 AI 拥有像人类一样、能自我进化的长期记忆</strong>。</p><p>memU 选择了 Agentic Memory 路径：把记忆系统本身当成一个 Agent 来处理，让它拥有读取、写入、更新和校验数据的能力，从而大幅提升操作的精准度和召回的准确性。<strong>memU 的最终交付形态是一种 File Base 的记忆</strong>，类似 Cloud 存储项目记忆。文件形式对 LLM 来说非常易读，内容经过整理，可以直接放入上下文，相比数据库的离散数据更有效。这种机制就像计算机的 RAM 结构，能够根据用户的 Query 不断增加或优化记忆，并让所有的用户信息和上下文整理成为非常类似于 Wikipedia 的结构——包含高价值、经过推理和整理的页面，并可以互相超链接。它在应用开发中扮演了至关重要的角色：</p><ul><li>替代算法：它通过提取 User 和 Agent 交互中的有价值信息，让 Agent 实现非参数化的自我学习、自我迭代；</li><li>解决 Context 爆炸：在 Agent 协作场景中，Memory 负责将复杂的 Context 提炼、筛选后，再传递给下一个 Agent；</li><li>知识沉淀：帮助企业从 PDF、员工知识等非结构化数据中提取核心价值信息。</li></ul><p>陈宏认为：「未来 Memory 会取代大量数据工程师和算法工程师的工作，通过非参数化的形式做到让 Agent 自我学习、自我迭代的功能。」</p><p>「本质上来讲，Memory 就是做一件事情：从复杂的数据抽取对于场景有价值的信息。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431534" alt="" title="" loading="lazy"/></p><p><strong>陈宏</strong></p><p>memU founder</p><h2>唐飞虎：用 Vibe Coding 优化 Vibe Coding</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431535" alt="" title="" loading="lazy"/></p><p>月之暗面开发者关系负责人唐飞虎深入剖析了当前 AI 编程工具在实际应用中的矛盾现状。管如今的大模型（如 OpenAI 的模型）能在国际顶尖编程竞赛中解决人类选手未能攻克的难题，却常常在一些对人类而言逻辑直观、但对模型来说抽象复杂的任务上「翻车」。</p><p>这种现象并非简单的模型能力不足，而源于上下文缺失、需求模糊，以及 AI 与人类在解决问题思路上存在根本差异，导致开发者在 Debug AI 生成的代码时，反而耗费了更多时间。</p><p>面对这一挑战，唐飞虎认为开发者不必消极等待模型进化，而应主动构建一套更高效的人机协作范式。他分享了一系列具体的实践策略，从工作流设计到开发纪律。</p><p>在方法论上，唐飞虎强调了「PRD First」（先撰写清晰的产品需求文档）和「测试驱动设计」（Test-driven Design），确保在编码前就与模型对齐需求、验证结果。</p><p>在技术实践上，唐飞虎介绍了通过 ToolCall 等技术实现任务并行处理，以及利用结构化 Prompt（如强制输出 Strict JSON）来规范模型行为。</p><p>其中一个极具启发性的细节是「永远备份」——建议为 AI 单独设立一个 GitHub 账号，让模型每次修改后自动提交，从而清晰地追踪每一次变更，极大地提升了在复杂任务中调试和回溯的效率。</p><p>这些策略的核心思想，是让开发者从纯粹的执行者转变为一位善用工具、规划任务的「指挥家」。</p><p>「要让模型做更多的事情，你只需要去做最关键的决策。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431536" alt="" title="" loading="lazy"/></p><p><strong>唐飞虎</strong></p><p>月之暗面开发者关系负责人</p><h2>王贺：AI Agent 下一代基础设施——Agent 沙箱技术实践</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431537" alt="" title="" loading="lazy"/></p><p>PPIO 智库的云产品技术专家王贺在分享中指出，当前 AI Agent 在执行由大语言模型生成的代码时，面临三大核心挑战：AI 代码的<strong>安全与可靠性</strong>问题（可能导致资源耗尽或数据泄露）、传统虚拟机<strong>启动速度慢</strong>（无法快速响应海量请求）以及<strong>资源动态管理</strong>的复杂性（业务潮汐与环境恢复需求）。</p><p>为此，PPIO 提出了其 AI Agent 沙箱技术，旨在提供一个安全、隔离、可执行且能快速响应的环境。</p><p>PPIO 的 Agent 沙箱选择了一条兼顾启动速度和安全隔离的路径，核心基于<strong>微虚拟机（MicroVM）方案</strong>实现，采用开源的<strong>Firecracker</strong>。</p><p>Firecracker 以其 <strong>Rust 语言</strong>编写带来的极高执行性能和稳定性、以及<strong>极简设计理念</strong>（仅保留网络、存储等必要设备）脱颖而出。这使得沙箱能在 <strong>125 毫秒以内启动</strong>，解决了传统虚拟机启动慢的问题，并且每个 Firecracker 实例仅需 <strong>5KB 内存</strong>，非常适合大规模部署。</p><p>为了进一步增强安全性，PPIO 沙箱为每个实例提供单独的 Linux 内核，在网络底层进行彻底隔离，并通过严格的资源限制和 Timeout 机制自动回收长时间空闲沙箱，有效降低成本。</p><p>同时，PPIO 通过引入<strong>沙箱模板</strong>（虚拟机快照）和支持<strong> Dockerfile </strong>构建，大大简化了用户环境的创建与管理。</p><p>该沙箱技术被广泛应用于主流 Agent 场景：</p><ul><li><strong>Browser Use</strong>（内置 Chrome 浏览器和自动化框架，用于数据抓取、表单填写等）</li><li><strong>Code Use</strong>（提供 Python、Java 等主流语言运行环境，支持动态下载依赖和远程执行代码）</li><li><strong>Computer Use</strong>（让 Agent 通过处理桌面截图操纵完整桌面环境）</li></ul><p>为实现极致性价比和智能资源管理，PPIO 引入了<strong> Pause/Resume 机制</strong>，能在沙箱释放时完整保存状态，并在下次请求到来时快速恢复，从而确保 Agent 任务的「无感知」连续性，并有效动态减少资源成本。</p><p>「如何在用户请求到来时快速响应，完成任务处理，这是所有 Agent 开发者需要考虑的问题。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431538" alt="" title="" loading="lazy"/></p><p><strong>王贺</strong></p><p>PPIO 智算业务云产品技术专家</p><h2>冯雯：MiniMax 大模型服务在 Voice Agent 场景的应用</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431539" alt="" title="" loading="lazy"/></p><p>MiniMax 开放平台解决方案高级总监冯雯，分享了 MiniMax 在 Voice Agent 场景下的技术探索，特别是关于端到端语音大模型的机遇与挑战，以及其在 TTS 环节的实践。</p><p>冯雯认为，<strong>端到端语音大模型是未来的趋势</strong>，它将 VAD、ASR 和 LLM 结合在一起，实现语音入、语音出。它的潜力在于：能够<strong>将用户说话过程中的情感、停顿、措辞等所有信息作为整体输入</strong>，获得更全面的信息，从而进行更拟人化的回复。端到端模型有两大优势：延迟更低（将多个环节延迟合并为一个）和情感理解更全面。然而，冯雯也坦诚，在当下，端到端语音大模型的使用体验「确实还不够好」：延迟和成本、指令遵循不足、不确定性和不稳定性。「因为<strong>每个链路都是黑盒，整体输出就会更不稳定</strong>，会有奇怪的声音或者一些不稳定造成结果的报错，这些都比集连出错更多。」因此，MiniMax 在<strong>链式模型的「最后一公里」</strong>——TTS（文本转语音）环节做了大量投入，力求在这个可控的环节做到极致。</p><p>MiniMax 在 TTS 方面取得了可观地位（<strong>HuggingFace 榜单排名第一</strong>），其关键技术实践包括：</p><ol><li>极速音色复刻：只需要 10 秒钟的语音内容，不限制内容，即可完成声音复刻；</li><li>口音复刻：针对海外市场需求，可以输入带有澳大利亚、新加坡、印度等口音的片段，完成对应口音的复刻；</li><li>文生音色：用户可以直接描述想要的音色，模型即可生成对应的音色，并支持混音操作；</li><li>准确表达：保证对数学公式、邮箱、手机号等特殊字符的准确表达，支持灵活设置情绪参数（快乐、悲伤）和音效，以改善用户体验。</li></ol><p>「AI 的迅猛发展将催生新的交互，未来的交互将依赖于创新的硬件载体，以语音为主要媒介进行沟通。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431540" alt="" title="" loading="lazy"/></p><p><strong>冯雯</strong></p><p>MiniMax 开发者生态负责人</p><h2>圆桌讨论：Vibe Coding 的爱与恨</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431541" alt="" title="" loading="lazy"/></p><p>过去的一年，AI Agent 编程工具的浪潮席卷全球，每个环节都在被重新定义，开发者也是对于 AI Coding 既爱又恨。爱的就是生产力的飞速提升，恨就是非常多的幻觉，产生的很多依赖以及非常多的不确定性。</p><p>本次主题为「Vibe Coding 的爱与恨」的圆桌讨论由 TEN Framework Co-founder <strong>Plutoless</strong> 主持，参与讨论的嘉宾有亚马逊云科技资深开发者布道师 <strong>郑予彬</strong>，memU Founder <strong>陈宏</strong>以及月之暗面开发者关系负责人<strong>唐飞虎</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431542" alt="" title="" loading="lazy"/></p><h3>问题一：开发者对 Vibe Coding 离不开的功能与倍感痛苦的痛点是什么？</h3><p>嘉宾们首先从开发者和重度用户的角度，分享了 AI 编程工具中「爱」与「恨」的体验：</p><p>唐飞虎将最「爱」的功能投给了 <strong>Cursor Tab 的智能补全</strong>。就像早年 Java 开发者离不开全家桶一样，在 AI 时代，Tab 补全仿佛能够「读心」，提前预知开发者的意图，狂按 Tab 就能自动完成大量工作，带来了极大的「爽感」。<strong>一个好的补全功能是 AI 时代最核心且不可或缺的开发者体验</strong>。</p><p>陈宏虽然是 Memory System 的设计者，但他作为重度用户，<strong>最「恨」的痛点在于需求表述的困难</strong>。他希望能够「直接把脑子交给 Cursor」，快速完成代码和 Debug。然而，将一个小时会议得出的复杂需求和上下文转译为详细的 Prompt 和文档，在他看来是非常浪费生命的，因此他期望 Memory System 能通过软硬件迁移，将其他软件中获取的上下文信息直接作为 Prompt 输入，减轻开发者的「转译」痛苦。</p><p>郑予彬则分享了其在测试 AWS Kiro 等工具时的复杂心境。他 <strong>「喜」的是工具真的可以用于生产流程化</strong>，但「愁」的是像 Kiro 提出的 Spec-driven Development 模式，虽然流程化，但将 Vibe Coding 变得过于复杂，开发者必须严格遵循「理解项目—需求分析—生成文档—执行」的流程。他指出，<strong>当前的开发工具进化速度极快，仍有很大的优化空间</strong>，特别是期待多模态大语言模型能带来体验上的全面翻新。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431543" alt="" title="" loading="lazy"/></p><h3>问题二：作为工具设计者，构建 AI 编程工具的基本原则和设计巧思是什么？</h3><p>讨论转向了工具设计者的理念。嘉宾们围绕<strong>如何引导开发者使用、如何提供更优体验</strong>进行了探讨：</p><p>郑予彬表示，设计原则很大程度上来源于研发团队自身的痛苦和经验。他观察到，无论是 Kiro 还是 Cursor，设计方向都趋于一致，即<strong>功能更加多样化以适应不同场景</strong>，同时通过 Serverless 等方式进行性能优化。他认为，当前的功能和性能优化受限于大语言模型的二维（文本）局限性，未来多模态大模型出来后，开发的场景将从电脑搬到更多新的场景，例如语音和图像的输入输出，带来全新的开发体验。</p><p>陈宏从 Memory Service 的角度分享了他们将复杂性内化的过程。他们发现，最初提供简单的 Memory API（Memorize 和 Retrieve）时，很多开发者并不知道如何优化使用。因此，memU 推出了 Responsive API，将 Memory 机制内化到类似于 OpenAI Compatible 的普通 API 调用流程中，<strong>使开发者可以「无需担心」 Memory 的处理</strong>，从而帮助他们更快地进行场景实验和开发。</p><p>唐飞虎强调了 <strong>「让开发者更好地进入整流状态」</strong> 这一核心目标。Cursor 之所以使用体验极佳，是因为模型很少阻断开发者的流程。任何模型中不该出现的错误或流程阻断都极大地破坏体验。月之暗面的核心思路是适配 Kimi 等高性能模型，并 <strong>将更多的定制化权利交给用户</strong>，让开发者基于 Kimi 模型搭建符合自己习惯的 Workflow，充分发挥模型本身的性能，同时保证流程的流畅性。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431544" alt="" title="" loading="lazy"/></p><h3>问题三：如何看待 IDE/低代码/Terminal 等多种用户界面的共存与互补？</h3><p>关于 AI 工具的交互界面，嘉宾们认为<strong>未来的趋势是共存和组合</strong>，以适应不同角色的需求：</p><p>唐飞虎指出，AI 服务的对象已不仅限于专业开发者，还包括产品经理、设计师等非传统开发者。对于这些人群，低代码的 Local 环境和「Prompt 即插即用」的界面（如豆包的九宫格功能）更有用。而高度专业的开发者可能更倾向于在 Terminal 环境中与系统 OS 打交道。<strong>最好的模式是 AI 能够组合这些工具，根据不同的场景和目标自动选择最合适的交互方式</strong>。</p><p>郑予彬补充道，<strong>未来的接口可能是一个声音转文字的简单接口，允许开发者像搭模块一样设计自己的工具</strong>，以覆盖多轮转换和不同阶段的开发者需求。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431545" alt="" title="" loading="lazy"/></p><h3>问题四：未来三到五年 AI 驱动的开发模式会怎样重塑软件产业？对开发者的核心技能要求将如何改变？</h3><p>在对 AI 驱动的开发模式进行总结和展望时，嘉宾们提出了深远的见解：</p><p>郑予彬认为，未来的开发范式需要重新定义规则性和合作方式。有了强大的工具和外挂，当前亟需解决的是如何规范代码的可复制性、可洞察性、可控制性和可合作性。她强调，<strong>防止代码被窃取和解决 AI 生成代码中潜藏的安全漏洞</strong>，需要规则和合规来规范开发流程、工具和行为。</p><p>陈宏从商业化的角度表达了对 Vibe Coding 生态繁荣的期望。他认为，如果 Vibe Coding 能够普及，将催生出数百万乃至数亿的 App，这将有利于 Memory System 等第三方服务的发展。他期望<strong>未来能够是去中心化的，每个人都可以有自己编译出的应用</strong>，而不是仅依赖于少数几个头部应用。他本人也断言，如果能不写 Code，肯定是不写，因为写代码是体力活。</p><p>唐飞虎则认为，开发者不会因此消亡。AI 代码生成能力将在未来三到五年内飞速增长，顶尖模型解决复杂问题的能力已接近人类顶尖选手，且推理成本会不断下降。类比 AI 围棋，虽然人类已经下不过 AI，但棋手依然能下出精彩对局。<strong>如果模型能很好地解决 A 任务，开发者就会去设计模型解决不了的更难、更复杂的 B 或 B+ 任务</strong>，这种不断挑战天花板的精神和对用户需求的敏锐观察，将是未来开发者最核心的技能。</p><p>Plutoless 总结，Vibe Coding 无法解决所有问题，但值得认真对待，他恳切期望尚未开启 Vibe Coding 的开发者尽快尝试。他认为，未来对开发者的核心要求将集中于：<strong>设计和解决复杂问题的能力、对用户需求的敏锐观察，以及对技术本质的深刻理解和持续追问</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431546" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431547" alt="" title="" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=T%2BJ%2FWiovxfxVG%2FCnZgokbA%3D%3D.ieG%2FICwxJZy%2B%2FdNXtqrwBvJdtU5hUWAWsMjZfvnyK70%3D" rel="nofollow" target="_blank">阅读更多 Voice Agent 学习笔记：了解最懂 AI 语音的头脑都在思考什么</a></p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431548" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[N8N+飞书+Coze打造零成本生图神器]]></title>    <link>https://segmentfault.com/a/1190000047431572</link>    <guid>https://segmentfault.com/a/1190000047431572</guid>    <pubDate>2025-11-27 12:13:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>今天要给大家分享一个超级实用的干货——如何用 N8N、飞书和 Coze 画板打造一个完全免费的封面图生成系统！很实用，重点是整个流程实现高效、且零成本，真正的实现了封面图自由。</p><h2>效果展示：2秒生成专属封面</h2><p>视频演示：<a href="https://www.bilibili.com/video/BV1nRUeBWEQc/" target="_blank">https://www.bilibili.com/video/BV1nRUeBWEQc/</a></p><p>这个系统的使用简直不要太简单！我只需要在飞书里输入想要生成的封面文字，比如"N8N+Coze+飞书=无敌封面"，敲个回车，不到 2 秒钟，系统就会自动生成两张高清封面图：</p><ul><li><strong>竖版图</strong>（3:4比例）</li><li><strong>横版图</strong>（4:3比例）</li></ul><p>而且都是 2K 高清画质，完全满足短视频平台的上传要求！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431574" alt="" title=""/></p><p>横版图片如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431575" alt="" title="" loading="lazy"/></p><p>竖版图片如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431576" alt="" title="" loading="lazy"/></p><h2>三大核心优势</h2><p>相比于之前的生成封面图 1.0 版本，这次升级带来了三个重大改进：</p><h3>🎯 1. 一键双版生成</h3><p>之前只能生成单一比例的图片，现在一次性搞定横竖两个版本，再也不用纠结选哪个比例了！</p><h3>💰 2. 零成本</h3><p>之前用大模型生成图片，每张至少要花一毛钱以上。现在完全免费，想生成多少就生成多少！</p><h3>🔥 3. 超强一致性</h3><p>生成的封面图只有文字会变化，其他元素完全一致。这对于打造个人 IP 标识来说太重要了——别人一看封面就知道是磊哥的内容！</p><h2>实现原理揭秘</h2><p>整个工作流的实现如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431577" alt="" title="" loading="lazy"/></p><p>核心实现如下：</p><h3>第一步：飞书接收指令</h3><ul><li>在 N8N 中设置 WebHook，接收飞书发送的消息。</li><li>提取用户输入的封面文字内容。</li></ul><h3>第二步：调用 Coze 画板</h3><ul><li>在 Coze 中创建两个画板：一个 4:3 横版，一个 3:4 竖版。<img referrerpolicy="no-referrer" src="/img/remote/1460000047431578" alt="" title="" loading="lazy"/></li><li>画板中固定背景图片，只让文字内容变化。</li><li>设置好文字居中、字号、颜色、字体等样式。</li></ul><h3>第三步：智能处理结果</h3><ul><li>用 JavaScript 代码提取生成的图片链接。</li><li>自动保存到指定目录。</li><li>通过飞书发送生成结果通知。</li></ul><h2>使用体验：爽到飞起</h2><p>现在我要生成封面图，只需要：</p><ol><li>打开飞书。</li><li>输入封面文字。</li><li>敲回车。</li></ol><p>2 秒后，高清封面图就自动生成并保存好了！整个过程完全自动化，零成本，零门槛。</p><h2>总结</h2><p>这个系统完美解决了内容创作者的封面图痛点：</p><ul><li><strong>效率高</strong>：2 秒生成。</li><li><strong>成本低</strong>：完全免费。</li><li><strong>效果好</strong>：一致性超强。</li><li><strong>操作简</strong>：飞书输入即可。</li></ul><p>如果你也在为封面图发愁，不妨试试这个方案。我是磊哥，每天分享一个实用干货，咱们下期见！</p><blockquote>本文已收录到我的技术小站 <a href="https://link.segmentfault.com/?enc=8qg0tQXZnfd8LzqC81rNww%3D%3D.kAyGWce4QKs1%2BzLNEvz5ySZPE7xz6E3VIUSmY2UMZcI%3D" rel="nofollow" target="_blank">www.javacn.site</a>，网站包含的内容有：<strong>LangChain/N8N/SpringAI/SpringAIAlibaba/LangChain4j/Dify/Coze/AI实战项目/AI常见面试题</strong>等技术分享，欢迎各位大佬光临指导~</blockquote>]]></description></item><item>    <title><![CDATA[《ESP32-S3使用指南—IDF版 V]]></title>    <link>https://segmentfault.com/a/1190000047431588</link>    <guid>https://segmentfault.com/a/1190000047431588</guid>    <pubDate>2025-11-27 12:12:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>第五十一章 WiFi一键配网</h2><p>ESP32-S3的一键配网模式是一种方便快捷的WiFi配置方式。在这种模式下，用户无需手动输入WiFi的SSID和密码等信息，只需要通过一键操作，即可完成WiFi的配置和连接。本章节，作者使用乐鑫官方提供的SmartConfig软件一键配置WiFi账号与密码。<br/>本章分为如下几个小节：<br/>51.1 主流WIFI 配网方式简介<br/>51.2 硬件设计<br/>51.3 软件设计<br/>51.4 下载验证</p><h3>51.1 主流WIFI 配网方式简介</h3><p>目前主流的WIFI配网方式主要有以下三种：</p><p><strong>一、SoftAP配网</strong><br/>ESP32-S3会建立一个WiFi热点（AP模式），用户将手机连接到这个热点后，将要连接的WiFi信息发送给ESP32-S3，ESP32-S3得到SSID和密码。<br/>①：优点：很可靠，成功率基本达到100%，设备端的代码简单。<br/>②：缺点：需要手动切换手机WiFi连接的网络，先连接到ESP32的AP网络，配置完成后再恢复连接正常WiFi网络，操作上存在复杂性，可能给用户带来困扰。<br/>③：官方支持：没有提供Demo。</p><p><strong>二、Smartconfig配网</strong><br/>ESP32-S3处于混杂模式下，监听网络中的所有报文，手机APP将当前连接的SSID和密码编码到UDP报文中，通过广播或组播的方式发送报文，ESP32-S3接收到UDP报文后解码，得到SSID和密码，然后使用该组SSID和密码去连接网络。<br/>①：优缺点：简洁，用户容易操作，但配网成功率受环境影响较大。<br/>②：官方支持：提供Demo和smart_config例程。</p><p><strong>三、Airkiss配网</strong><br/>AirKiss是微信硬件平台提供的一种WIFI设备快速入网配置技术。要使用微信客户端的方式配置设备入网，需要设备支持AirKiss技术。Airkiss的原理和Smartconfig很类似，设备工作在混杂模式下，微信客户端发送包含SSID和密码的广播包，设备收到广播包解码得到SSID和密码。详细的可以参考微信官方的介绍。<br/>①：优缺点：简洁，用户容易操作，但配网成功率受环境影响较大。<br/>②：官方支持：提供Demo和smart_config例程。</p><p>本实验以Smartconfig软件对ESP32-S3设备进行一键配网，该软件的安装包可在乐鑫官方网站的相关下载网页找到，如下图所示。<br/><img width="723" height="224" referrerpolicy="no-referrer" src="/img/bVdm8T9" alt="" title=""/><br/>图51.1.1 Smartconfig软件下载<br/>下载成功后，需把安装包转移到安卓手机或者苹果手机上安装。</p><h3>51.2 硬件设计</h3><p><strong>1.例程功能</strong><br/>本章实验功能简介：设备进入初始化状态，开启混监听所有网络数据包，此时LCD显示"In the distribution network......"，表示设备已进入混监听模式。手机连上自己的WiFi，开启APP（EspTouch）软件，输入手机所在WiFi密码，请求配网，发送UDP广播包。ESP32 -S3通过UDP包（长度）获取配置信息捕捉到路由SSID和PASSWD，连接路由器,此时LCD显示路由的账号与密码，表示连接路由成功。</p><p><strong>2.硬件资源</strong><br/>1）LED灯<br/>LED-IO1<br/>2）XL9555<br/>IIC_INT-IO0（需在P5连接IO0）<br/>IIC_SDA-IO41<br/>IIC_SCL-IO42<br/>3）SPILCD<br/>CS-IO21<br/>SCK-IO12<br/>SDA-IO11<br/>DC-IO40（在P5端口，使用跳线帽将IO_SET和LCD_DC相连）<br/>PWR- IO1_3（XL9555）<br/>RST- IO1_2（XL9555）<br/>4）ESP32-S3内部WiFi</p><p><strong>3.原理图</strong><br/>本章实验使用的WiFi为ESP32-S3的片上资源，因此并没有相应的连接原理图。</p><h3>51.3 软件设计</h3><h4>51.3.1 程序流程图</h4><p>程序流程图能帮助我们更好的理解一个工程的功能和实现的过程，对学习和设计工程有很好的主导作用。下面看看本实验的程序流程图：<br/><img width="585" height="288" referrerpolicy="no-referrer" src="/img/bVdm8Ua" alt="" title="" loading="lazy"/><br/>图51.3.1.1 程序流程图</p><h4>51.3.2 程序解析</h4><p>在本章节实验中，我们只关心main.c文件内容即可，该文件内容如下：</p><pre><code>i2c_obj_t i2c0_master;

/* 定义事件 */
static EventGroupHandle_t s_wifi_event_group;
static const int CONNECTED_BIT = BIT0;
static const int ESPTOUCH_DONE_BIT = BIT1;
static const char *TAG = "smartconfig_example";
static void smartconfig_task(void * parm);
static char lcd_buff[100] = {0};


/**
 * @brief       WIFI链接糊掉函数
 * @param       arg:传入网卡控制块
 * @param       event_base:WIFI事件
 * @param       event_id:事件ID
 * @param       event_data:事件数据
 * @retval      无
 */

static void event_handler(void* arg, esp_event_base_t event_base,
                                int32_t event_id, void* event_data)
{
    if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START)
    {
        xTaskCreate(smartconfig_task, "smartconfig_task", 4096, NULL, 3, NULL);
    }
else if (event_base == WIFI_EVENT &amp;&amp; 
event_id == WIFI_EVENT_STA_DISCONNECTED)
    {
        esp_wifi_connect();
        xEventGroupClearBits(s_wifi_event_group, CONNECTED_BIT);
    }
    else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP)
    {
        xEventGroupSetBits(s_wifi_event_group, CONNECTED_BIT);
    }
    else if (event_base == SC_EVENT &amp;&amp; event_id == SC_EVENT_SCAN_DONE)
    {
        ESP_LOGI(TAG, "Scan done");
        lcd_show_string(0,90,320,16,16,"In the distribution network", BLUE);
    }
    else if (event_base == SC_EVENT &amp;&amp; event_id == SC_EVENT_FOUND_CHANNEL)
    {
        ESP_LOGI(TAG, "Found channel");
    }
    /* 已获取SSID和密码,表示配网成功 */
    else if (event_base == SC_EVENT &amp;&amp; event_id == SC_EVENT_GOT_SSID_PSWD)
    {
        ESP_LOGI(TAG, "Got SSID and password");

        smartconfig_event_got_ssid_pswd_t *evt =
                                (smartconfig_event_got_ssid_pswd_t *)event_data;
        wifi_config_t wifi_config;
        uint8_t ssid[33] = { 0 };
        uint8_t password[65] = { 0 };
        uint8_t rvd_data[33] = { 0 };

        bzero(&amp;wifi_config, sizeof(wifi_config_t));
        memcpy(wifi_config.sta.ssid, evt-&gt;ssid, sizeof(wifi_config.sta.ssid));
        memcpy(wifi_config.sta.password, evt-&gt;password,
               sizeof(wifi_config.sta.password));
        wifi_config.sta.bssid_set = evt-&gt;bssid_set;

        if (wifi_config.sta.bssid_set == true)
        {
            memcpy(wifi_config.sta.bssid, evt-&gt;bssid,
                   sizeof(wifi_config.sta.bssid));
        }

        memcpy(ssid, evt-&gt;ssid, sizeof(evt-&gt;ssid));
        memcpy(password, evt-&gt;password, sizeof(evt-&gt;password));
        ESP_LOGI(TAG, "SSID:%s", ssid);
        ESP_LOGI(TAG, "PASSWORD:%s", password);

        lcd_fill(0,90,320,240,WHITE);
        sprintf(lcd_buff, "%s",ssid);
        lcd_show_string(0, 90, 320, 16, 16, lcd_buff, BLUE);
        sprintf(lcd_buff, "%s",password);
        lcd_show_string(0, 110, 320, 16, 16, lcd_buff, BLUE);
        lcd_show_string(0,130,320,16,16,"distribution network", BLUE);

        /* 手机APPEspTouch软件使用ESPTOUCH V2模式，会执行以下代码 */
        if (evt-&gt;type == SC_TYPE_ESPTOUCH_V2)
        {
            ESP_ERROR_CHECK( esp_smartconfig_get_rvd_data(rvd_data,
                             sizeof(rvd_data)) );
            ESP_LOGI(TAG, "RVD_DATA:");

            for (int i = 0; i &lt; 33; i++)
            {
                printf("%02x ", rvd_data[i]);
            }

            printf("\n");
        }

        ESP_ERROR_CHECK( esp_wifi_disconnect() );
        ESP_ERROR_CHECK( esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_config) );
        esp_wifi_connect();
    }
    else if (event_base == SC_EVENT &amp;&amp; event_id == SC_EVENT_SEND_ACK_DONE)
    {
        xEventGroupSetBits(s_wifi_event_group, ESPTOUCH_DONE_BIT);
    }
}

/**
 * @brief       WiFi一键配网
 * @param       无
 * @retval      无
 */
static void wifi_smartconfig_sta(void)
{
    /* 初始化网卡 */
    ESP_ERROR_CHECK(esp_netif_init());
    /* 创建事件 */
    s_wifi_event_group = xEventGroupCreate();
    /* 使用默认配置初始化包括netif的Wi-Fi */
    ESP_ERROR_CHECK(esp_event_loop_create_default());
    /* 把WIFI网卡设置为STA模式 */
    esp_netif_t *sta_netif = esp_netif_create_default_wifi_sta();
    assert(sta_netif);
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    /* WIFI初始化 */
    ESP_ERROR_CHECK( esp_wifi_init(&amp;cfg) );

    /* 注册WIFI事件 */
ESP_ERROR_CHECK( esp_event_handler_register(WIFI_EVENT, ESP_EVENT_ANY_ID,
                 &amp;event_handler, NULL) );
ESP_ERROR_CHECK( esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP,
                 &amp;event_handler, NULL) );
ESP_ERROR_CHECK( esp_event_handler_register(SC_EVENT, ESP_EVENT_ANY_ID,
                 &amp;event_handler, NULL) );

    ESP_ERROR_CHECK( esp_wifi_set_mode(WIFI_MODE_STA) );
    ESP_ERROR_CHECK( esp_wifi_start() );
}

/**
 * @brief       一键配网回调函数
 * @param       parm:传入的形参(未使用)
 * @retval      无
 */

static void smartconfig_task(void * parm)
{
    parm = parm;
    EventBits_t uxBits;
    /* 设置配网协议 */
    ESP_ERROR_CHECK( esp_smartconfig_set_type(SC_TYPE_ESPTOUCH) );
    /* 设置配网参数 */
    smartconfig_start_config_t cfg = SMARTCONFIG_START_CONFIG_DEFAULT();
    /* 开始配网 */
    ESP_ERROR_CHECK( esp_smartconfig_start(&amp;cfg) );

    while (1)
    {
        /* 获取事件 */
        uxBits = xEventGroupWaitBits(s_wifi_event_group, CONNECTED_BIT 
| ESPTOUCH_DONE_BIT, true, false, portMAX_DELAY);
        
        /* 配网成功 */
        if(uxBits &amp; CONNECTED_BIT)
        {
            ESP_LOGI(TAG, "WiFi Connected to ap");
        }

        /* 智能配置结束 */
        if(uxBits &amp; ESPTOUCH_DONE_BIT)
        {
            /* 配网结束，删除任务 */
            esp_smartconfig_stop();
            vTaskDelete(NULL);
        }
    }
}

/**
 * @brief       程序入口
 * @param       无
 * @retval      无
 */
void app_main(void)
{
    /* 省略部分代码..... */

    wifi_smartconfig_sta();

    while (1)
    {
        LED_TOGGLE();
        vTaskDelay(500);
    }
}</code></pre><p>上述源码是把ESP32-S3设备配置为STA模式，然后开启配网任务并启动配网，此时，ESP32-S3处于混杂模式下，监听网络中的所有报文，当手机APP将当前连接的SSID和密码编码到UDP报文中，通过广播或组播的方式发送报文，ESP32-S3接收到UDP报文后解码，得到SSID和密码，然后使用该组SSID和密码去连接当前网络。</p><h3>51.4 下载验证</h3><p>程序下载成功后，我们打开“EspTouch”软件，在此软件下点击 “EspTouch”选项，注意：手机必须连接WiFi，才能一键配网，如下图所示。<br/><img width="620" height="1379" referrerpolicy="no-referrer" src="/img/bVdm8Ub" alt="" title="" loading="lazy"/><br/>图51.4.1 手机配置要连接的WiFi账号与密码<br/>此时，我们填写好“ALIENTEK-YF_5G”WiFi密码和传输方式，可按下确定按键发送UDP报文。当ESP32-S3设备接收到这个报文时，系统会提取该报文的SSID和密码去连接该网络。下图是ESP32-S3配网成功效果图。<br/><img width="308" height="232" referrerpolicy="no-referrer" src="/img/bVdm8Uc" alt="" title="" loading="lazy"/><br/>图51.4.2 配网成功</p>]]></description></item><item>    <title><![CDATA[浅谈 AI 搜索前端打字机效果的实现方案]]></title>    <link>https://segmentfault.com/a/1190000047431590</link>    <guid>https://segmentfault.com/a/1190000047431590</guid>    <pubDate>2025-11-27 12:11:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote><p>作者：vivo 互联网前端团队 - He Yanjun</p><p>在当代前端开发领域，打字机效果作为一种极具创造力与吸引力的交互元素，被广泛运用于各类网站和应用程序中，为用户带来独特的视觉体验和信息呈现方式，深受广大用户的喜爱。</p><p>本文将深入介绍在AI搜索输出响应的过程中，打字机效果是怎样逐步演进的。力求以通俗的语言和严谨的思路深入剖析打字机效果在不同阶段的关键技术难点和优劣势。</p></blockquote><p>1分钟看图掌握核心观点👇</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431592" alt="图片" title="图片"/></p><h2>一、前言</h2><p>在如今基于AI搜索的对话舞台上，如果一段文字像老式打字机一样逐字逐句展现在屏幕上，那将是一种具有独特魅力的吸引力。</p><p>话不多说，先来看下最终的实现效果。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431593" alt="图片" title="图片" loading="lazy"/></p><h2>二、引言</h2><p>在AI搜索场景中，由于大模型基于流式输出文本，需要多次响应结果到前端，因此这种场景十分适合使用打字机效果。</p><p>打字机效果是指在生成内容的场景中，文字逐字符动态显示，模拟人工打字的过程，主要是出于提升用户体验、优化交互逻辑和增强心理感知等方面的考量：</p><p><strong>缓解等待焦虑，降低“无反馈”的负面体验。</strong></p><p>内容是逐步响应的，打字机效果可以很好地提供“实时反馈”，用户可以感知到系统正在工作，从而减少了等待过程中的不确定性和焦虑感。</p><p><strong>模拟自然交互，增强“类人对话”的沉浸感。</strong></p><p>对话交流具有停顿、强调等节奏感，通过实时打字的模拟，跟容易拉近与用户的心理距离，增强对话感和沉浸感。</p><p><strong>优化信息接收效率，避免“信息过载”。</strong></p><p>如果一次性展示大量密密麻麻的文字，用户需要花时间筛选重点，容易产生抵触，通过打字机效果可以缓和阅读节奏，减少视觉和认知负担。</p><p><strong>强化“AI生成”的感知，降低对“标准答案”的预期。</strong></p><p>使用户感知到是AI实时计算结果，而非预存的标准答案，有助于用户理性客观地使用工具。</p><h2>三、早期实现方案——纯文本逐字符打字效果</h2><p>最开始的产品功能，需要根据用户输入的搜索词，流式输出并逐字符展示到页面上，这可以说是打字机效果的入门级实现了，不依赖任何复杂的技术，其流程图大致如下所示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431594" alt="图片" title="图片" loading="lazy"/></p><h3>3.1 详细说明</h3><p>前端会定义一个字段用来缓存全量的markdown文本，每次服务端流式响应markdown文本到前端时，前端都会将其追加到这个缓存字段后，然后基于marked依赖库将全量的markdown文本转换为html片段。</p><p>要实现逐字符渲染的动画效果，就需要定时更新文本。定时功能一般采用setTimeout或setInterval来实现，而更新文本可以考虑innerHTML和appendChild的方式，这里采用的innerHTML方式插入文本，核心代码如下所示。</p><pre><code>let fullText = 'test text';// 全量的html文本
let index = 0;// 当前打印到的下标
let timer = window.setInterval(() =&gt; {
  ++index;
  $dom.innerHTML = fullText.substring(0, index);
}, 40);</code></pre><h3>3.2 innerHTML与appendChild的核心区别对比</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431595" alt="图片" title="图片" loading="lazy"/></p><p><strong>为什么选择innerHTML而非appendChild？</strong></p><p>由于服务端是流式返回markdown文本，因此每次返回的markdown文本可能不是完整的。</p><p>举个例子如下。</p><pre><code>先返回下面一段markdown文本

** 这是一个
再返回下面一段markdown文本

标题 **
先返回的文本会当作纯文本展示，再返回的文本会与先返回的文本结合生成html片段如下

&lt;strong&gt;这是一个标题&lt;/strong&gt;</code></pre><p>如果使用appendChild的话，就不好处理上述场景。</p><h3>3.3 小结</h3><p>这种方式的优点就是简单易懂，很容易上手实现，也没有任何依赖。</p><p>但是，它的缺点也是显而易见的。比如，我们无法方便的添加一些额外的动画效果来增强视觉体验，如光标闪烁效果；对于一些复杂文本内容，或者需要更加灵活地控制展示细节时也会显得捉襟见肘；并且每次通过innerHTML渲染文本时，都触发了dom的销毁与创建，性能消耗大。</p><h2>四、需求难度进一步提升</h2><p>随着产品的迭代，业务要求打字内容不仅是纯文本，还需要穿插展示卡片等复杂样式效果，如下图所示。</p><p>卡片的类型包括应用、股票、影视等，需要可扩展、可配置，并且还会包括复杂的交互效果，如点击、跳转等。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431596" alt="图片" title="图片" loading="lazy"/></p><p>很明显，基于早期的实现方案已经远远不能满足日益增强的业务诉求了，必须考虑更加灵活高效的技术方案。</p><h2>五、现代框架下的实现——基于Vue虚拟dom动态更新</h2><p>通过上述的分析，打字内容中要穿插展示卡片，显然需要使用单例模式，否则如果每次打字都重新创建元素的话，不仅性能低下，而且数据和状态还无法保持一致。</p><p>而要使用单例模式，就必须根据现有数据对已插入节点进行插入、更新、移除等操作以保持数据的一致性，这就很自然地会想到使用现代前端框架来对打字机效果进行改进。</p><p>Vue是基于虚拟dom的渐进式javascript框架，仅在数据变化时计算差异并更新必要的部分，因此可以借助其数据驱动开发、组件化开发等特性，轻松地构建一个可复用的打字机效果组件。</p><h3>5.1 设计思路</h3><p>要实现打字正文中穿插卡片的效果，首先需要定义好返回的数据结构，它需要具备可扩展，方便解析，兼容markdown等特性，所以使用html标签是一种比较合适的方式，例如要展示一个应用卡片，可以下发如下所示数据。</p><pre><code>&lt;app id="" /&gt;</code></pre><p>从下发的数据中可以获取到标签名和属性键值对，这样就可以通过标签名来渲染关联到的组件模板，通过属性键值对去服务端加载对应的数据，于是就可以水到渠成的把应用卡片展示出来，其流程图如下图所示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431597" alt="图片" title="图片" loading="lazy"/></p><h3>5.2 详细说明</h3><p>组件模板文件按照一定规则组织在特定的目录下，在构建时打包到资源里，关键代码如下所示。</p><pre><code>privateinit(){  
    let fileList = require.context('@/components/common/box', true, /\.vue$/);  
    fileList.keys().forEach((filePath) =&gt; {  
        let startIndex = filePath.lastIndexOf('/');  
        let endIndex = filePath.lastIndexOf('.');  
        let tagName = filePath.substring(startIndex + 1, endIndex);  
        this.widgetMap[tagName] = fileList(filePath).default;  
    });  
}</code></pre><p>之前版本在每次接收到服务端下发的markdown文本时，都会做一次转换成html的操作，如果多次响应之间的间隔时间很短，则会出现略微卡顿的现象，因此这里转换为html时再增加一个防抖功能，可以很有效的避免卡顿。</p><p>每次定时截取到待渲染的html文本以后，会基于ultrahtml库将其转换为dom树，并过滤掉注释、脚本等标签，核心代码如下。</p><pre><code>let toRenderHtml = this.rawHtml.substring(0, this.curIndex);  
let dom = {  
    type: ELEMENT_NODE,  
    name: 'p',  
    children: parse(toRenderHtml).children  
};</code></pre><p>最后就是全局注册一个递归组件用来渲染转换后的dom树，核心代码如下。</p><pre><code>render(h: any) {  
    // 此处省略若干代码

    // 处理子节点
    let children = this.dom['children'] || [];  
    let renderChildren = children.map((child: any, index: number) =&gt; { 
        return h(CommonDisplay, {  
            props: {  
                dom: child,  
                displayCursor: this.displayCursor,  
                lastLine: this.lastLine &amp;&amp; index === children.length - 1,  
                ignoreBoxTag: this.ignoreBoxTag  
            }  
        });  
    });
  
    // 此处省略若干代码

    // 处理文本节点
    if (this.dom['type'] === TEXT_NODE) {  
        returnthis.renderTextNode({h, element: this.dom});  
    }

    // 处理自定义组件标签
    let tagName = this.dom['type'] === ELEMENT_NODE ? this.dom['name'] : 'div';  
    if (this.$factory.hasTag(tagName)) {  
        // 此处省略若干代码
        let widget = this.$factory.getWidget(tagName);
        return h(widget, {  
            key: tagId,  
            props: {  
                displayCursor: this.displayCursor,  
                lastLine: this.lastLine,  
                text,  
                ...attributes  
            }  
        }, isLastLeaf &amp;&amp; this.displayCursor ? [h(commonCursor)] : []);
    }

    // 处理html原始标签
    return h(tagName, {  
        attrs: {  
            displayCursor: this.displayCursor,  
            lastLine: this.lastLine,  
            ...this.dom['attributes']  
        }  
    }, renderChildren);  
}</code></pre><h3>5.3 问题整理和解决</h3><p>打字机功能终于正常运行了，流畅度还是不错的，但是在体验的过程中，也发现了一些<strong>细节问题</strong>。</p><p><strong>①打字文本中如果存在标签，如 &lt;p&gt;xxx&lt;/p&gt; ，会出现先展示 &lt; ,再展示 &lt;p ，最后展示空的效果，也就是字符回退，极大影响阅读体验。</strong></p><p><strong>原因分析</strong></p><p>定时截取待渲染文本时是通过定义一个下标递增逐字符截取的，这就导致标签并没有作为一个原子结构被整体截取，于是就出现了字符回退的现象。</p><p><strong>解决方案</strong></p><p>当下标指向的字符为 &lt; 时，则往后截取到 \&gt; 的位置，核心代码如下。</p><pre><code>if (curChar === '&lt;') {  
    let lastGtIndex = this.rawHtml.indexOf('&gt;', this.curIndex);
    if (lastGtIndex &gt; -1) {
        this.curIndex = lastGtIndex + 1;
        returnfalse;
    }
}</code></pre><p><strong>② 打字文本中如果存在转义字符，如 " ，则会依次出现这些字符，最后再展示 " ，也就是字符闪烁，也十分影响阅读体验。</strong></p><p><strong>原因分析</strong></p><p>原因同上述字符回退一样，也是没有把转义字符当作一个整体截取。</p><p><strong>解决方案</strong></p><p>当下标指向的字符为 &amp; 时，则往后截取到转义字符结束的位置，核心代码如下。</p><pre><code>// 大模型大概率只下发有限类别的转义字符，做成配置动态下发，不仅解析方便，定制下发也很及时  
if (curChar === '&amp;') {  
    let matchEscape = this.config['writer']['escapeArr'].find((item: any) =&gt; {  
        returnthis.rawHtml.indexOf(item, this.curIndex) === this.curIndex;  
    });  
    if (matchEscape) {  
        this.curIndex += matchEscape.length;  
        returnfalse;  
    }  
}</code></pre><p><strong>③ 打字过程中的速度是固定的，缺少一点抑扬顿挫的节奏感，不够自然。</strong></p><p><strong>原因分析</strong></p><p>定时器的间隔时间是固定的一个数值，所以表现为一个固定不变的打字节奏。</p><p><strong>解决方案</strong></p><p>可以根据未打印字符数来动态调整每次打字的速度，一种可选的实现方案如下。</p><p>假设未打印字符数为 N ，速度平滑指数为 a ，实际打字速度为 Vcurrent ，逻辑应达到的打字速度为 Vnew 。</p><p>if N &lt;= 10 , Vnew = 100 ms / 1字符</p><p>if 10 &lt; N &lt;= 20 , Vnew = 100 - 8 * ( N - 10 ) ms / 1字符</p><p>if 20 &lt; N , Vnew = 20 ms / 4字符</p><p>Vcurrent = a <em> Vcurrent + ( 1 - a ) </em> Vnew</p><p>上述策略可能会比较多，而且上线以后还有可能更换数值对照效果，因此为了支持配置化，我们可以对Vnew进行表达式归纳，如下所示。</p><p>Vnew = Vinit - w * ( N - min ) + b</p><p>Vinit 为默认初始打字速度，w 为每条策略的权重值，N 为未打印字符数，min 为每条策略的最小字符数量比较值，b 为每条策略的偏置。关键代码如下所示。</p><pre><code>privatespeedFn({curSpeed, curIndex, totalLength}: any){  
    let leftCharLength = Math.max(0, totalLength - curIndex);  
    let matchStrategy = this.config['writer']['strategy'].find((item: any) =&gt; {  
        return (!item['min'] || item['min'] &lt; leftCharLength)  
            &amp;&amp; (!item['max'] || item['max'] &gt;= leftCharLength);  
    });  
    let speed = this.config['writer']['initSpeed'] - matchStrategy['w'] * (leftCharLength - (matchStrategy['min'] || 0)) + matchStrategy['b'];  
    returnthis.config['writer']['smoothParam'] * curSpeed + (1 - this.config['writer']['smoothParam']) * speed;  
}</code></pre><p><strong>④ 打字过程中，会时不时的回退到之前字符的位置重新开始打字，例如当前展示 a = b + c ，等到下一次渲染时会从 a 开始重新打完这一段。</strong></p><p><strong>原因分析</strong></p><p>由于markdown文本结合会生成html标签，从而导致字符数量增多，那么当前下标指向的字符就相对之前落后了。</p><pre><code>let curIndex = 5;// 当前下标
let prevMarkdown = '**hello';// 上一次打印时的全量markdown文本
let prevHtml = '&lt;p&gt;**hello&lt;/p&gt;';// 上一次打印时的全量html片段
let prevRenderHtml = '&lt;p&gt;**&lt;p&gt;';// 上一次打印到页面上的html片段
// 页面上会渲染 **

// 当服务端继续下发了 ** 的markdown文本时，curIndex会递增1变为6
let curMarkdown = '**hello**';// 当前打印时的全量markdown文本
let curHtml = '&lt;p&gt;&lt;strong&gt;hello&lt;/strong&gt;&lt;/p&gt;';// 当前打印时的全量html片段
let curRenderHtml = '&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;p&gt;';// 当前打印到页面上的html片段
// 页面上会渲染空标签，然后重新开始打字，尤其是在数学公式场景中非常容易复现</code></pre><p><strong>解决方案</strong></p><p>解决这个问题，需要分两步走。</p><p>首先需要判断打印到页面上的html片段是否有变化，因为只有变化时才会出现这种情况，而判断是否有变化只需要记录一下上一次的html片段和这一次的html片段是否不同即可，比较好处理。</p><p>其次就是需要重新定位下标到上一次打印到的位置，这里相对比较难处理，因为html的结构和内容都在变化，很难准确的定位到下标应该移动到什么位置。虽然我们不能准确定位，但是只要能够使当前打印到页面上的字符比上一次的字符多，就可以满足诉求了。于是我想到了textContent这个属性，它可以获取当前节点及其后代的所有文本内容。那么问题就转化为：找到一个下标，使得当前截取的html片段的textContent长度要比上一次的textContent长度大。</p><p>综上所述，可以得到核心代码如下所示。</p><pre><code>if (this.isHtmlChanged()) {  
    let domRange: any = document.createRange();  
    let prevFrag = domRange.createContextualFragment(this.prevRenderHtml);  
    let prevTextContent = prevFrag.textContent;  
    let diffNum = 1;  
    do {  
        this.curIndex += diffNum;  
        let curHtml = this.rawHtml.substring(0, this.curIndex);  
        let curFrag = domRange.createContextualFragment(curHtml);  
        let curTextContent = curFrag.textContent;  
        diffNum = prevTextContent.length - curTextContent.length;  
        if (diffNum &lt;= 0) {  
            break;  
        }  
    } while (this.curIndex &lt; this.rawHtml.length);  
}</code></pre><h3>5.4 小结</h3><p>通过现代前端框架构建打字机组件，不仅减少了不必要的渲染和性能消耗，而且还能高效灵活的穿插各种酷炫的样式效果，实现更多复杂的产品功能。</p><h2>六、未来展望</h2><p>本文详细介绍了AI搜索中前端打字机效果的实现方案演进过程，从最初的纯文本逐字符打字效果，到借助现代前端框架实现灵活可复用的打字机组件，每一个技术难点的技术突破无不体现了前端技术的持续进步和产品不断追求卓越的态度。同时我也希望本文可以抛砖引玉，为读者打开思路，提供借鉴。</p><p>随着人工智能和前端技术的不断发展和创新生态的日益完善，未来一定会不断涌现大量的新技术和新理念。我相信只要时刻保持积极学习和不断尝试的探索精神，就能开拓出更多精彩创新的实现方案和应用场景。</p>]]></description></item><item>    <title><![CDATA[中国企业CRM选型全维度横评：从自定义到]]></title>    <link>https://segmentfault.com/a/1190000047431612</link>    <guid>https://segmentfault.com/a/1190000047431612</guid>    <pubDate>2025-11-27 12:10:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化转型进入“深水区”的今天，CRM（客户关系管理）早已不是单纯的“销售工具”——它是企业连接客户、整合业务、驱动增长的<strong>核心数据中枢</strong>。企业选型CRM的关键，在于能否匹配“业务复杂度、数据整合需求、未来扩展性”三大核心诉求。</p><p>本文围绕<strong>自定义能力与易用性、数据集成与自动化、扩展与第三方集成、实施团队与行业经验</strong>四大维度，对<strong>超兔一体云、金蝶、用友、Salesforce、Microsoft Dynamics 365、探迹CRM、EC CRM、Zoho CRM、悟空CRM及低代码类CRM</strong>展开深度横向对比，为不同规模、不同行业的企业提供专业选型参考。</p><h2>一、自定义能力与易用性：从“能用”到“好用”的核心门槛</h2><p>CRM的“自定义能力”直接决定了系统能否适配企业的<strong>个性化业务场景</strong>（如制造企业的“工单跟踪”、医疗企业的“患者随访”）；而“易用性”则决定了员工的接受度——毕竟，再强大的功能，用不起来也是摆设。</p><h3>1. 自定义能力的核心构成（脑图解析）</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431614" alt="" title=""/></p><pre><code>mindmap
  root((CRM自定义能力核心构成))
    自定义范围
      字段定制（行业专属/扩展字段）
      流程配置（销售/服务/审批流程）
      界面设计（菜单/工作台/视图）
      权限管理（角色/部门/数据权限）
    易用性
      低代码/无代码工具（拖拽/可视化）
      学习成本（文档/培训/社区支持）
      响应速度（业务变化适配周期）
    适配性
      行业场景（制造/医疗/外贸）
      组织规模（小微企业/集团企业）</code></pre><h3>2. 各品牌自定义能力与易用性对比（表格）</h3><table><thead><tr><th>品牌</th><th>自定义范围</th><th>易用性亮点</th><th>适配场景</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>三级菜单/工作台/业务表/工作流</td><td>系统引擎支持“功能白名单订阅”，非专业用户可自主配置多岗位菜单</td><td>中小微企业，多角色（销售/财务/售后）需求</td></tr><tr><td><strong>金蝶</strong></td><td>功能模块调整/行业字段扩展</td><td>界面直观，快速响应“特殊流程”（如快消企业的“临期商品促销”）</td><td>快成长型中小企业</td></tr><tr><td><strong>用友</strong></td><td>细分场景配置（财务/供应链）</td><td>支持“模块独立拆分”（如将“应收款管理”从ERP中剥离至CRM）</td><td>中大型企业，标准化流程需求</td></tr><tr><td><strong>Salesforce</strong></td><td>低代码拖拽/行业模板</td><td>Trailhead“学习-实战-认证”体系，非技术人员1周内可搭建销售流程</td><td>全球企业，多语言/时区需求</td></tr><tr><td><strong>Microsoft Dynamics 365</strong></td><td>Power Platform定制（表单/流程）</td><td>与Office 365/Teams深度集成，员工无需额外学习</td><td>微软生态企业，多模块组合</td></tr><tr><td><strong>探迹CRM</strong></td><td>表单/流程引擎/客户视图</td><td>低代码平台+“智能补全企业数据”，减少80%手动录入</td><td>B2B企业，个性化获客场景</td></tr><tr><td><strong>EC CRM</strong></td><td>视图/标签体系</td><td>“视图助手”支持自然语言筛选（如“筛选近30天未跟进的华南客户”）</td><td>小微企业，标准化销售场景</td></tr><tr><td><strong>Zoho CRM</strong></td><td>拖拽配置流程/行业字段</td><td>基础版年费低至“几千元”，无需技术背景</td><td>小团队，快速搭建可用系统</td></tr><tr><td><strong>悟空CRM</strong></td><td>客户管理字段调整</td><td>轻量化配置，高性价比</td><td>预算有限的小微企业</td></tr><tr><td><strong>低代码类CRM</strong></td><td>可视化拖拽/全模块定制</td><td>业务变化响应周期&lt;1周，后期优化成本为传统开发的1/10</td><td>业务快速迭代的企业</td></tr></tbody></table><h3>3. 关键结论：</h3><ul><li><strong>大型企业</strong>：优先选择<strong>Salesforce</strong>（低代码+全球合规）、<strong>用友</strong>（细分场景深度定制）；</li><li><strong>中小微企业</strong>：优先选择<strong>超兔一体云</strong>（多岗位配置）、<strong>探迹CRM</strong>（智能补全数据）；</li><li><strong>业务快速变化的企业</strong>：优先选择<strong>低代码类CRM</strong>（可视化拖拽，1周适配新业务）。</li></ul><h2>二、数据集成与自动化：从“数据孤岛”到“全链路闭环”</h2><p>企业选择CRM的核心诉求之一，是<strong>打通“销售-财务-供应链”的数据壁垒</strong>，通过自动化减少重复劳动（如手动录入订单、跟进提醒）。这一维度的能力，直接决定了企业的“流程效率”和“数据准确性”。</p><h3>1. 数据集成与自动化的典型流程（以超兔为例）</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431615" alt="" title="" loading="lazy"/></p><pre><code>sequenceDiagram
  participant 用户 as 企业销售
  participant 超兔 as 超兔一体云
  participant 采购 as 采购模块
  participant 库存 as 库存模块
  participant 财务 as 财务模块

  用户-&gt;&gt;超兔: 生成销售订单（客户A，采购100台设备）
  超兔-&gt;&gt;采购: 同步订单需求（触发“向供应商采购100台设备”）
  超兔-&gt;&gt;库存: 扣减对应商品库存（实时更新库存数量）
  超兔-&gt;&gt;财务: 生成应收账单（关联订单+发票信息）
  超兔-&gt;&gt;用户: 反馈“订单已同步至采购/库存/财务”
  Note right of 超兔: 底层连通确保数据一致性，无需人工核对</code></pre><h3>2. 各品牌数据集成与自动化能力对比</h3><table><thead><tr><th>品牌</th><th>数据集成能力</th><th>自动化流程亮点</th><th>实际效果案例</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>底层连通CRM/进销存/财务</td><td>AI待办（自动创建跟进任务）+AI日报（一键生成）</td><td>销售跟单效率提升40%</td></tr><tr><td><strong>金蝶</strong></td><td>云星空API联动ERP/CRM/OA</td><td>销售合同审批后自动生成预订单，同步财务开票</td><td>数据同步延迟&lt;10秒</td></tr><tr><td><strong>用友</strong></td><td>跨系统深度集成（畅捷通+OA）</td><td>线索转商机触发OA审批，库存准确率从95%→99.8%</td><td>供应链协同效率提升30%</td></tr><tr><td><strong>Salesforce</strong></td><td>销售云+服务云+营销云闭环</td><td>Einstein AI预测购买倾向，自动编排客户旅程</td><td>航空公司旅客满意度提升40%</td></tr><tr><td><strong>Microsoft Dynamics 365</strong></td><td>CRM+ERP数据互通</td><td>Power Automate自动录入数据+“下一步最佳行动”建议</td><td>欧洲车企转化周期压缩50%</td></tr><tr><td><strong>探迹CRM</strong></td><td>线索-触达-管理-分析全闭环</td><td>AI智能外呼+自动更新客户画像</td><td>获客成本降低30%</td></tr><tr><td><strong>EC CRM</strong></td><td>通话/微信沟通数据整合</td><td>“联络助手”自动总结沟通内容，识别客户意向</td><td>跟进记录准确率提升80%</td></tr><tr><td><strong>Zoho CRM</strong></td><td>内部生态（Books/Desk）集成</td><td>客户未回复自动发提醒，成交后生成售后工单</td><td>重复劳动减少50%</td></tr><tr><td><strong>低代码类CRM</strong></td><td>多渠道采集（表单/Excel/API）</td><td>线索自动分配+跟进超时提醒+营销邮件自动发送</td><td>线索转化效率提升30%</td></tr></tbody></table><h3>3. 关键结论：</h3><ul><li><strong>需要全链路数据打通的企业</strong>：优先选择<strong>用友</strong>（库存准确率99.8%）、<strong>超兔一体云</strong>（底层连通全模块）；</li><li><strong>B2B获客型企业</strong>：优先选择<strong>探迹CRM</strong>（AI外呼+全流程闭环）；</li><li><strong>营销驱动型企业</strong>：优先选择<strong>Salesforce</strong>（Einstein AI预测客户行为）。</li></ul><h2>三、扩展与第三方集成：从“单一工具”到“生态中枢”</h2><p>企业的业务发展必然伴随“新模块添加”（如从“销售”扩展到“售后”）或“跨系统协同”（如对接ERP/电商平台），CRM的“扩展能力”直接决定了系统能否支撑<strong>未来3-5年的业务增长</strong>。</p><h3>1. 典型扩展生态示例（以Salesforce为例）</h3><pre><code>flowchart LR
  A[Salesforce核心产品] --&gt; B(销售云)
  A --&gt; C(服务云)
  A --&gt; D(营销云)
  B --&gt; E{AppExchange生态}
  C --&gt; E
  D --&gt; E
  E --&gt; F[第三方工具：ERP/钉钉/Slack]
  E --&gt; G[自定义扩展：行业插件/API]
  Note right of E: 超5000个扩展应用，覆盖“销售-服务-营销”全场景</code></pre><h3>2. 各品牌扩展与第三方集成能力对比（表格）</h3><table><thead><tr><th>品牌</th><th>扩展能力</th><th>第三方集成亮点</th><th>适配场景</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>大底座架构，模块无缝扩展</td><td>对接金蝶/用友ERP+电商RPA+国税开票机器人</td><td>成长型企业，多业务扩展</td></tr><tr><td><strong>金蝶</strong></td><td>轻量化功能扩展</td><td>集成钉钉/飞书，销售日报同步财务台账</td><td>年营收&lt;1亿的中小企业</td></tr><tr><td><strong>用友</strong></td><td>多组织/多业态扩展</td><td>SDK/API对接泛微OA/顺丰WMS，全球供应链协同</td><td>集团企业，复杂供应链</td></tr><tr><td><strong>Salesforce</strong></td><td>AppExchange生态</td><td>开放API，对接ERP/电子邮件/社交媒体</td><td>全球企业，全场景扩展</td></tr><tr><td><strong>Microsoft Dynamics 365</strong></td><td>Power Platform扩展</td><td>与Office 365/Azure/Teams无缝集成</td><td>微软生态企业，端到端打通</td></tr><tr><td><strong>探迹CRM</strong></td><td>全球销售智能体“Futern”</td><td>深度融合钉钉OA，支持出海企业</td><td>B2B出海企业，多终端协同</td></tr><tr><td><strong>EC CRM</strong></td><td>轻量化功能添加</td><td>集成微信/电话，沟通工具一站式</td><td>小微企业，基础销售场景</td></tr><tr><td><strong>Zoho CRM</strong></td><td>自定义扩展程序</td><td>集成企业微信/金蝶/Slack，内部生态联动</td><td>小团队，多工具协同</td></tr><tr><td><strong>低代码类CRM</strong></td><td>模块化增删功能</td><td>开放API+预置连接器，对接钉钉/金蝶/用友</td><td>业务增长快，需跨系统集成</td></tr></tbody></table><h3>3. 关键结论：</h3><ul><li><strong>集团企业</strong>：优先选择<strong>用友</strong>（多组织扩展）、<strong>Salesforce</strong>（AppExchange生态）；</li><li><strong>出海企业</strong>：优先选择<strong>探迹CRM</strong>（全球销售智能体）、<strong>Salesforce</strong>（多语言/时区）；</li><li><strong>微软生态企业</strong>：优先选择<strong>Microsoft Dynamics 365</strong>（与Office 365/Teams深度集成）。</li></ul><h2>四、实施团队与行业经验：从“上线”到“落地”的最后一公里</h2><p>CRM项目的“成功率”，<strong>70%取决于实施团队的行业经验</strong>——能否理解企业的“隐性需求”（如制造企业的“工单优先级”、医疗企业的“患者隐私合规”），直接决定了系统能否真正“用起来”。</p><h3>1. 各品牌实施能力与行业经验对比（表格）</h3><table><thead><tr><th>品牌</th><th>实施团队优势</th><th>行业经验</th><th>典型客户/案例</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>21年经验，专业实施团队</td><td>6万+企业，覆盖机电/医疗/维修等行业</td><td>中小微企业，快速上线（1-3个月）</td></tr><tr><td><strong>金蝶</strong></td><td>聚焦中小企业，快速部署</td><td>快成长型企业，标准化实施经验</td><td>年营收&lt;1亿的中小企业</td></tr><tr><td><strong>用友</strong></td><td>全球统一交付体系</td><td>制造/金融/零售，集团财务/复杂供应链</td><td>中大型企业，长期数字化转型（6-9个月）</td></tr><tr><td><strong>Salesforce</strong></td><td>专业实施团队，行业解决方案</td><td>全球500强，覆盖航空/快消/制造等行业</td><td>航空公司满意度提升40%</td></tr><tr><td><strong>Microsoft Dynamics 365</strong></td><td>微软专业团队，行业化方案</td><td>制造/医疗/工程，支持远程医疗/Teams问诊</td><td>欧洲车企转化周期压缩50%</td></tr><tr><td><strong>探迹CRM</strong></td><td>研发占比70%，核心来自腾讯/IBM</td><td>B2B全周期解决方案，3000+客户</td><td>阿里巴巴/分众传媒</td></tr><tr><td><strong>EC CRM</strong></td><td>中小企业快速部署</td><td>通用销售场景，小微企业为主</td><td>中小微企业，快速上手</td></tr><tr><td><strong>Zoho CRM</strong></td><td>本地化适配完善</td><td>25万+企业，外贸/小团队</td><td>网易/亚马逊</td></tr><tr><td><strong>悟空CRM</strong></td><td>轻量化实施</td><td>小微企业，高性价比</td><td>预算有限的小微企业</td></tr><tr><td><strong>低代码类CRM</strong></td><td>专业团队，7×12小时服务</td><td>11个行业模板，制造/零售/医疗等</td><td>业务变化快的企业</td></tr></tbody></table><h3>2. 关键结论：</h3><ul><li><strong>中大型企业</strong>：优先选择<strong>用友</strong>（集团财务经验）、<strong>Salesforce</strong>（全球500强案例）；</li><li><strong>B2B企业</strong>：优先选择<strong>探迹CRM</strong>（3000+客户经验）；</li><li><strong>中小微企业</strong>：优先选择<strong>超兔一体云</strong>（21年中小微服务经验）、<strong>Zoho CRM</strong>（本地化适配）。</li></ul><h2>五、综合能力雷达图：各品牌核心优势一目了然</h2><p>以下是各品牌在四大维度的<strong>10分制评分</strong>（越高表示能力越强），帮助企业快速定位“匹配自身需求的CRM”：</p><table><thead><tr><th>品牌</th><th>自定义能力</th><th>数据集成</th><th>扩展能力</th><th>实施经验</th></tr></thead><tbody><tr><td>超兔一体云</td><td>9</td><td>9</td><td>8</td><td>10</td></tr><tr><td>金蝶</td><td>8</td><td>8</td><td>7</td><td>8</td></tr><tr><td>用友</td><td>9</td><td>9</td><td>9</td><td>10</td></tr><tr><td>Salesforce</td><td>10</td><td>10</td><td>10</td><td>10</td></tr><tr><td>Microsoft Dynamics 365</td><td>9</td><td>9</td><td>9</td><td>9</td></tr><tr><td>探迹CRM</td><td>8</td><td>9</td><td>8</td><td>8</td></tr><tr><td>EC CRM</td><td>7</td><td>8</td><td>7</td><td>7</td></tr><tr><td>Zoho CRM</td><td>9</td><td>8</td><td>8</td><td>9</td></tr><tr><td>悟空CRM</td><td>7</td><td>7</td><td>7</td><td>7</td></tr><tr><td>低代码类CRM</td><td>10</td><td>9</td><td>9</td><td>8</td></tr></tbody></table><h2>六、企业选型终极建议：匹配“业务阶段+核心需求”</h2><table><thead><tr><th>企业类型</th><th>核心需求</th><th>推荐品牌</th></tr></thead><tbody><tr><td>中小微企业（多岗位）</td><td>自定义多菜单/工作台，快速上线</td><td>超兔一体云</td></tr><tr><td>中大型企业（集团）</td><td>集团财务/复杂供应链</td><td>用友/ Salesforce</td></tr><tr><td>B2B企业（获客）</td><td>全流程获客闭环+AI外呼</td><td>探迹CRM</td></tr><tr><td>微软生态企业</td><td>与Office 365/Teams集成</td><td>Microsoft Dynamics 365</td></tr><tr><td>业务快速变化的企业</td><td>可视化拖拽+快速适配</td><td>低代码类CRM/Salesforce</td></tr><tr><td>出海企业</td><td>多语言/时区+全球生态</td><td>Salesforce/探迹CRM</td></tr></tbody></table><h2>结语：CRM选型的本质是“匹配业务战略”</h2><p>CRM的价值，从来不是“功能越多越好”，而是“能否支撑企业当前及未来的业务增长”。企业选型时，需优先明确：</p><ul><li><strong>当前需求</strong>：是解决“销售跟进混乱”还是“数据孤岛”？</li><li><strong>未来规划</strong>：1-3年内是否会扩展“售后/供应链”模块？</li><li><strong>组织特性</strong>：是“小团队快速试错”还是“集团标准化管理”？</li></ul><p>只有匹配“业务战略”的CRM，才能真正成为企业的“增长引擎”——而不是“摆设工具”。</p>]]></description></item><item>    <title><![CDATA[跨境电商账号为什么需要代理？从稳定性谈起]]></title>    <link>https://segmentfault.com/a/1190000047431626</link>    <guid>https://segmentfault.com/a/1190000047431626</guid>    <pubDate>2025-11-27 12:09:58</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在跨境电商行业，账号是最核心的业务资产之一。无论是运营亚马逊、TikTok Shop、Temu、Shein，还是管理多个独立站，多账号并行操作已经成为常态。然而，随着平台风控愈发严格，“账号稳定性”成为许多卖家遇到的最大挑战。<br/>在影响账号安全的诸多因素中，网络环境是否真实、干净、稳定往往决定了账号能否长期存活。住宅代理（Residential Proxy）因此逐渐成为跨境卖家不可或缺的基础工具，也成为许多专业团队默默使用的“核心武器”。</p><h2>一、为什么跨境账号容易被封？</h2><p>跨境平台的风控逻辑本质上是在寻找“异常行为”，而网络环境是判断异常最敏感的信号之一。</p><ol><li>IP 地址存在异常<br/>●多账号共用同一宽带<br/>●使用风险较高的数据中心 IP<br/>●IP 频繁切换、国家变化不合理<br/>●登录地与账号注册地址不匹配<br/>这些都会让平台系统迅速介入审查。</li><li>设备指纹重叠<br/>即便你使用了反指纹浏览器，如果 IP 环境不干净，仍然可能被判定为关联。</li><li>登录轨迹不自然<br/>账号突然跨国登录、多个不同地区频繁切换，都属于“高危行为”。<br/>对平台来说，你的 IP 是否真实、是否稳定，是判断账号是否安全的重要依据。</li></ol><h2>二、住宅代理：提升账号稳定性的关键</h2><p>住宅代理（Residential Proxy）基于真实家庭网络，因此具有高度可信度。这种类型的 IP 更容易被平台视为“正常用户行为”，从而提升账号生存率。</p><ol><li>有效降低关联风险<br/>为不同账号分配独立住宅 IP，可以从根源上避免“同网段关联”。</li><li>登录稳定、减少风控<br/>真实且长期稳定的家庭网络信号，会让账号行为轨迹更健康。</li><li>避免数据中心IP的高封禁率<br/>数据中心 IP 在跨境平台的风控模型中属于高风险标签，而住宅 IP 的信任度显著更高。</li><li>满足不同国家运营需求<br/>无论是注册、投放广告、店群操作还是内容测试，都可以根据需求选择对应国家或城市的 IP。</li></ol><h2>三、跨境电商常见代理使用场景</h2><ol><li>多账号独立运营<br/>●为每个账号提供独立网络环境<br/>●搭配 BitBrowser、Incogniton、XLogin 等浏览器<br/>●避免 IP 与指纹交叉污染</li><li>店铺审核<br/>使用注册地区对应的住宅 IP，能大幅提升审核通过率。</li><li>TikTok 店群与直播<br/>稳定 IP 可以减少直播掉线，提高推流质量。</li><li>广告投放<br/>干净住宅 IP 能显著降低广告账户受限、BM 封禁等风险。</li></ol><h2>四、如何选择适合跨境电商的代理服务？</h2><p>选择代理服务时，以下四点尤为关键：</p><ol><li>是否真实住宅 IP<br/>这是降低风险的必要前提。</li><li>IP 池规模是否足够大<br/>规模越大，重复率越低，IP 越干净。</li><li>稳定性与延迟表现<br/>尤其是直播、店群项目前，连接稳定性比价格更重要。</li><li>是否支持精准地区选择<br/>跨境电商对国家、地区要求极高，这一点不可忽视。</li></ol><p>在跨境电商竞争愈加激烈的今天，账号稳定性已成为影响业务增长的关键因素。而网络环境作为账号安全的底层基础，决定了账号是否能够长期、健康地运营。<br/>选择稳定、干净、可信的住宅代理，不仅能减少封号风险，还能提升整体运营效率。如果你正在遭遇账号频繁掉线、关联、登录异常等问题，从优化 IP 环境开始，往往是最高性价比的解决方案。</p>]]></description></item><item>    <title><![CDATA[选对CRM不踩坑！15大主流CRM品牌三]]></title>    <link>https://segmentfault.com/a/1190000047431647</link>    <guid>https://segmentfault.com/a/1190000047431647</guid>    <pubDate>2025-11-27 12:09:18</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化转型浪潮中，CRM（客户关系管理）已从“客户信息存储工具”升级为<strong>全链路销售赋能平台</strong>，其核心能力覆盖<strong>客户管理、销售过程管理、销售团队管理</strong>三大模块。不同品牌基于定位差异，在能力侧重上形成了鲜明的“赛道壁垒”——有的聚焦中小企业轻量化需求，有的适配大型企业复杂流程，有的依托生态实现协同。</p><p>本文选取<strong>15款主流</strong> <strong>CRM</strong> <strong>品牌</strong>（超兔一体云、Salesforce、纷享销客、钉钉CRM、SAP CRM、Microsoft Dynamics 365 CRM、Oracle CX、Pipedrive、金蝶、Zoho、Freshsales、HubSpot CRM、SuiteCRM、用友CRM、EC SCRM），从客户管理（信息录入/搜索/分类/跟踪）、销售过程管理（机会跟踪/合同管理/销售预测）、销售团队管理（绩效跟踪/任务分配/沟通协作）三大维度展开深度横评，为企业选型提供参考。</p><h2>一、客户管理：从“信息存储”到“精准洞察”的能力跃迁</h2><p>客户管理是CRM的核心基石，其本质是<strong>将分散的客户数据转化为可行动的洞察</strong>，关键能力体现在“信息录入的便捷性、搜索的精准性、分类的合理性、跟踪的全面性”四大维度。</p><h3>1.1 客户管理能力对比表</h3><table><thead><tr><th>品牌</th><th>客户信息录入</th><th>客户信息搜索</th><th>客户分类</th><th>客户跟踪</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>多渠道（手机通讯录、拍名片、微信/QQ导入、电商API）；自动补全工商/天眼查/微信支付宝信息</td><td>客户名/手机号搜索；企业简称模糊查重（解决“同企异名”痛点）</td><td>自动客池（需求培养/有需求/上首屏/加入目标/成功）；<strong>三一客模型</strong>（定性/定级/定量统一老板与销售判断标准）</td><td>360°视图+<strong>跟单时间线（独有）</strong> ；通信（微信/电话）数据集成+外勤拜访记录；待办任务+行动记录分析</td></tr><tr><td><strong>Salesforce</strong></td><td>360°客户视图多维度录入（基础档案/交易历史/互动记录）；Einstein GPT自动生成客户摘要；多语言/多币种支持</td><td>多维度精准搜索；AI辅助关联客户关联信息（如“某客户的竞品合作记录”）</td><td>自定义字段/标签；分级权限控制（适配跨国企业复杂组织）</td><td>360°视图+Einstein AI行为分析；互动记录（邮件/通话/会议）自动存档</td></tr><tr><td><strong>纷享销客</strong></td><td>交互轨迹自动存档（邮件/通话/会议）；多维度客户档案（基础信息/交易历史/联系人）</td><td>精准搜索；权限分级过滤（如“仅部门经理可见高价值客户”）</td><td>标签化管理；适配复杂组织架构的<strong>数据共享规则</strong>（如“跨部门客户协同”）</td><td>交互轨迹全跟踪；客户动态实时提醒（如“某客户30天未跟进”）</td></tr><tr><td><strong>钉钉CRM</strong></td><td>钉钉联系人一键同步；沟通记录（IM/会议/邮件）自动关联客户</td><td>简单搜索；标签筛选（如“筛选‘高意向’标签客户”）</td><td>动态分类（根据跟进状态自动调整）；轻量化标签化</td><td>基础互动记录；钉钉生态联动（如“客户消息直接推送到钉钉聊天”）</td></tr><tr><td><strong>SAP CRM</strong></td><td>360°客户视图；与ERP/财务系统集成实现<strong>业财一体数据沉淀</strong></td><td>多维度搜索；智能关联（如“搜索‘某行业客户’自动关联其采购历史”）</td><td>自定义分类；<strong>公海/私海客户分配</strong>（避免客户资源闲置）</td><td>客户行为轨迹（网页浏览/邮件点击）+沟通记录；全生命周期跟踪（从线索到复购）</td></tr><tr><td><strong>Microsoft Dynamics 365</strong></td><td>360°视图；多渠道（社交媒体/线下活动）数据整合</td><td>智能搜索；AI关联客户潜在需求（如“某客户浏览过‘新品’页面，推荐相关内容”）</td><td>AI驱动分类（根据行为数据自动打标签）；标签化管理</td><td>行为轨迹+互动历史；<strong>移动端实时同步</strong>（外勤人员随时查看客户信息）</td></tr><tr><td><strong>Oracle CX</strong></td><td>多渠道（工商信息/社交媒体/线下活动）线索汇集；智能查重+信息补全（如“自动补充企业注册资本”）</td><td>多维度搜索；AI推荐高价值客户（如“推荐‘近期有采购需求’的客户”）</td><td><strong>标签体系</strong>（根据行业/需求/价值分层）；精准分类</td><td>全生命周期客户档案；智能跟踪（如“自动提醒‘某客户合同到期’”）</td></tr><tr><td><strong>Pipedrive</strong></td><td>自定义字段；基础客户信息（联系人/公司/联系方式）录入</td><td>可视化界面搜索；标签筛选</td><td>自定义分类；动态跟踪（根据交易进度调整分类）</td><td>联系人和交易关联跟踪；可视化界面展示客户动态</td></tr><tr><td><strong>金蝶</strong></td><td>多维度客户信息（基础档案/交易历史/联系人）录入；与金蝶ERP/精斗云<strong>实时同步</strong></td><td>精准搜索；自定义模块筛选（如“筛选‘零售行业’客户”）</td><td>行业适配分类（如制造业/零售业不同分类规则）；自定义字段</td><td>全生命周期信息管理；实时同步库存/订单信息（如“销售员快速查看客户订单库存”）</td></tr><tr><td><strong>Zoho</strong></td><td>集中式客户数据库；集成邮箱/电话/社交媒体等多渠道沟通记录</td><td>分类搜索；自定义筛选（如“筛选‘近30天有互动’的客户”）</td><td>客户分类（根据行业/地区/价值）；标签化管理</td><td>互动历史记录（邮件/电话/聊天）；集中管理客户沟通</td></tr><tr><td><strong>Freshsales</strong></td><td>AI潜在客户评分；互动信息（邮件/电话/聊天）自动记录</td><td>智能搜索；<strong>高意向客户识别</strong>（AI评分≥80分的客户优先展示）</td><td>AI驱动分类（根据行为数据自动打标签）；标签化管理</td><td>互动连续性跟踪（如“某客户上周咨询过价格，本周自动提醒跟进”）；订单全流程跟踪</td></tr><tr><td><strong>HubSpot CRM</strong></td><td>自动记录邮件/通话互动；免费基础版支持全流程客户信息管理</td><td>自定义标签搜索；线索追踪（如“跟踪‘某网站表单提交’的客户”）</td><td>线索分段管理（如“潜在客户/意向客户/成交客户”）；标签化</td><td>互动行为追踪（如“客户打开邮件的时间/次数”）；全流程客户管理</td></tr><tr><td><strong>SuiteCRM</strong></td><td>自定义字段/模块；开源系统支持<strong>灵活扩展</strong>（如“添加‘客户满意度’字段”）</td><td>多维度搜索；自定义筛选</td><td>多维度分类（根据行业/地区/交易金额）；开源定制</td><td>全生命周期跟踪；关联营销活动（如“某客户参与过‘线上 webinar’”）</td></tr><tr><td><strong>用友CRM</strong></td><td>复杂B2B客户信息结构化存储（如“客户的组织架构/决策链”）；与用友ERP<strong>深度集成</strong></td><td>复杂B2B场景搜索（如“搜索‘某行业+某地区+年采购额≥100万’的客户”）</td><td>复杂业务场景分类（如“按项目阶段/决策链角色分类”）；自定义</td><td>业财一体数据跟踪（如“客户的应收账款/开票记录”）；全流程销售跟踪</td></tr><tr><td><strong>EC SCRM</strong></td><td>多渠道（官网/抖音/微信）线索自动汇集；<strong>微信聊天记录自动同步</strong>（无需手动补录）</td><td>智能搜索；多渠道数据整合（如“整合微信/官网/抖音的客户互动记录”）</td><td>标签化管理；精准分类（如“按‘微信互动频率’分类”）</td><td><strong>互动时间线</strong>（无需手动补录）；客户动态实时提醒（如“某客户在微信朋友圈点赞”）</td></tr></tbody></table><h3>1.2 客户管理核心差异解析</h3><ul><li><strong>超兔一体云</strong>：以“<strong>多渠道录入+精准分类+全场景跟踪</strong>”为核心，尤其是<strong>三一客模型</strong>解决了“老板与销售对客户判断标准不一致”的行业痛点，<strong>跟单时间线</strong>还原了跟进过程的“时间脉络”，适合需要“统一客户认知+可视化跟进”的中小/中型企业。</li><li><strong>Salesforce</strong>：以“<strong>全球化+AI能力</strong>”领先，Einstein GPT自动生成客户摘要、多语言/多币种支持，适合跨国企业或需要“AI驱动客户洞察”的大型企业。</li><li><strong>纷享销客</strong>：聚焦“<strong>复杂组织的客户协同</strong>”，权限分级与数据共享规则适配中大型企业的跨部门协作需求。</li><li><strong>钉钉CRM</strong>：依托钉钉生态实现“<strong>轻量化客户管理</strong>”，适合中小企业快速上线，无需额外学习成本。</li><li><strong>EC SCRM</strong>：以“<strong>微信生态深度整合</strong>”为亮点，微信聊天记录自动同步、互动时间线，适合依赖微信获客/沟通的零售/餐饮等行业。</li></ul><h2>二、销售过程管理：从“流程管控”到“效率赋能”的升级</h2><p>销售过程管理的核心是<strong>将“不确定性的销售行为”转化为“可预测的流程”</strong> ，关键能力体现在“销售机会跟踪、合同管理、销售预测”三大维度。</p><h3>2.1 销售过程管理能力对比表</h3><table><thead><tr><th>品牌</th><th>销售机会跟踪</th><th>合同管理</th><th>销售预测</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>多种跟单模型：<strong>小单快单（三一客）、商机跟单（阶段/预期日期）、多方项目（多业务主体）</strong> ；<strong>销售漏斗</strong>（统计各阶段转化情况）</td><td>多业务模型订单（服务型/实物型/标准/批发/非标）；全流程管理（订单工作流/锁库/采购计划/供应商直发）；<strong>应收-开票-回款三角联动</strong>（控制账期/信用度）</td><td>数据分析引擎（同比环比/多表聚合/关联表查询）；<strong>销售目标分解</strong>（独有，将目标拆到业务环节/人员）；AI辅助调整策略</td></tr><tr><td><strong>Salesforce</strong></td><td>可视化销售漏斗（从线索到成交全流程）；Einstein AI机会评分（预测转化概率）；自动化任务提醒（如“报价后3天跟进”）</td><td>合同全流程管理（创建-审批-签署-归档）；集成DocuSign电子签名；<strong>合同风险预警</strong>（如“某合同条款不符合法规”）</td><td>Einstein AI销售预测（准确率≥85%）；管道分析（如“某阶段转化率低，优化该环节”）</td></tr><tr><td><strong>纷享销客</strong></td><td>实时跟踪销售机会；<strong>漏斗视图分析转化卡点</strong>（如“某阶段转化率仅30%，需优化话术”）；自动化任务提醒</td><td>合同全流程管理（创建-审批-签署-归档-续约）；<strong>到期提醒+续约管理</strong>（适配长期服务类业务）</td><td>基于销售漏斗的预测；<strong>转化率分析</strong>（如“某销售的机会转化效率是团队2倍”）</td></tr><tr><td><strong>钉钉CRM</strong></td><td>轻量化销售漏斗视图；商机阶段推进（如“从‘沟通’到‘报价’”）；任务分配（如“将商机分配给某销售”）</td><td>与钉钉审批流程打通；基础合同管理（创建-审批-归档）；需第三方插件实现<strong>高级功能</strong>（如电子签名）</td><td>管道预测（根据漏斗进度预测销售额）；简单报表</td></tr><tr><td><strong>SAP CRM</strong></td><td>覆盖线索-机会-成交全流程；<strong>商机阶段自定义</strong>（如“制造业的‘立项-设计-生产-交付’阶段”）；自动化任务</td><td>合同全生命周期管理（创建-审批-签署-执行-归档）；<strong>风险控制</strong>（如“合同金额超过阈值需总经理审批”）</td><td>AI驱动销售预测；与ERP集成实现<strong>业财一体预测</strong>（如“结合库存预测销售额”）</td></tr><tr><td><strong>Microsoft Dynamics 365</strong></td><td>智能化销售流程（线索转化-商机跟进-合同签订）；<strong>AI驱动的机会优先级排序</strong>（高价值机会优先展示）</td><td>合同管理与Office 365集成（如“用Word模板创建合同”）；电子签名支持；<strong>合同模板自定义</strong></td><td>AI销售预测；实时监控订单状态/回款进度</td></tr><tr><td><strong>Oracle CX</strong></td><td>全流程销售自动化（线索培育-商机跟进-合同签订）；<strong>AI商机评分</strong>（预测转化概率）；自动化任务推送</td><td>合同全流程管理；集成电子签名；<strong>合同模板库</strong>（适配不同行业）</td><td>AI驱动销售预测；<strong>漏斗分析</strong>（如“某阶段流失率高，优化该环节”）</td></tr><tr><td><strong>Pipedrive</strong></td><td><strong>可视化销售管道</strong>（拖动式调整交易进度）；销售机会跟踪（从线索到成交）；自动化工具（如“自动发送跟进邮件”）</td><td>一键生成报价单→自动转为订单；基础合同管理（创建-归档）；需第三方集成<strong>电子签名</strong></td><td>销售预测分析（根据管道进度预测销售额）；可视化报表</td></tr><tr><td><strong>金蝶</strong></td><td>销售机会跟踪（从线索到成交）；自定义销售流程（适配行业需求）；<strong>销售行为分析</strong>（如“某销售的跟进频率”）</td><td>与金蝶ERP集成实现<strong>订单-库存-财务联动</strong>；支持二次开发适配<strong>非标合同</strong>（如制造业定制化合同）</td><td>销售业绩分析；<strong>销售预测报表</strong>（根据历史数据预测）</td></tr><tr><td><strong>Zoho</strong></td><td>智能算法分析客户行为→预测销售机会；自动化推送营销活动（如“某客户浏览过‘新品’，推送新品介绍”）</td><td>销售漏斗跟踪；合同管理（创建-审批-归档）；集成电子签名</td><td>销售预测工具；自定义报表（如“按地区/产品预测销售额”）</td></tr><tr><td><strong>Freshsales</strong></td><td>一键生成报价单→自动转为订单；<strong>订单全流程跟踪</strong>（从报价到回款）；AI机会评分（高意向客户优先）</td><td>基础合同管理（创建-归档）；需第三方集成<strong>电子签名</strong></td><td>销售预测（根据订单进度/历史数据）；可视化报表</td></tr><tr><td><strong>HubSpot CRM</strong></td><td>可视化销售管道；销售机会全流程跟踪（从线索到成交）；<strong>线索评分</strong>（高评分线索优先跟进）</td><td>合同管理与营销/服务模块集成；基础合同流程（创建-审批-归档）；免费版支持</td><td>管道预测（根据销售管道进度预测）；<strong>自定义报告</strong>（如“按月份预测销售额”）</td></tr><tr><td><strong>SuiteCRM</strong></td><td>销售漏斗自定义；机会阶段管理（从线索到成交）；报价单与合同模板</td><td>基础合同管理（创建-归档）；开源定制（如“添加‘合同风险评估’字段”）</td><td>销售预测报表；与营销活动关联（如“某营销活动带来的销售额预测”）</td></tr><tr><td><strong>用友CRM</strong></td><td>复杂B2B销售机会跟踪（如“项目型销售的‘立项-招标-中标’阶段”）；<strong>业财一体数据联动</strong>（如“机会金额与财务预算关联”）</td><td>复杂合同管理（如“框架合同+订单”）；<strong>风险控制</strong>（如“合同条款符合法规审核”）</td><td>AI驱动销售预测；<strong>复杂B2B场景适配</strong>（如“按项目周期预测销售额”）</td></tr><tr><td><strong>EC SCRM</strong></td><td><strong>可视化销售漏斗</strong>（跟踪商机从“线索”到“成交”）；自动化任务提醒（如“某客户需跟进报价”）</td><td>合同在线签署（集成电子签名）；合同管理与微信生态联动（如“合同发送到客户微信”）</td><td>基于漏斗的销售预测；<strong>多渠道数据整合预测</strong>（如“微信/官网线索的转化预测”）</td></tr></tbody></table><h3>2.2 销售过程管理核心差异解析</h3><ul><li><strong>超兔一体云</strong>：以“<strong>多业务模型适配+业财一体</strong>”为核心，覆盖小单快单、中长单、多方项目等场景，尤其是<strong>应收-开票-回款三角联动</strong>解决了“账期风险”痛点，适合需要“全流程销售管控”的企业。</li><li><strong>Salesforce</strong>：以“<strong>AI驱动的流程自动化</strong>”领先，Einstein预测准确率高，DocuSign集成简化合同签署，适合需要“高效流程”的大型企业。</li><li><strong>纷享销客</strong>：聚焦“<strong>长期服务类业务</strong>”，合同到期提醒与续约管理适配 SaaS/咨询等行业。</li><li><strong>SAP CRM</strong>：以“<strong>业财一体的销售预测</strong>”为亮点，与ERP集成实现“库存-销售-财务”联动，适合制造业/批发业等需要“供应链协同”的企业。</li><li><strong>用友CRM</strong>：适配“<strong>复杂B2B项目型销售</strong>”，如制造业的“立项-招标-中标”阶段管理，业财一体数据联动解决了“项目金额与预算不符”的痛点。</li></ul><h2>三、销售团队管理：从“考核”到“赋能”的转变</h2><p>销售团队管理的核心是<strong>将“个体能力”转化为“团队效能”</strong> ，关键能力体现在“绩效跟踪、任务分配、沟通协作”三大维度。</p><h3>3.1 销售团队管理能力对比表</h3><table><thead><tr><th>品牌</th><th>团队绩效跟踪</th><th>任务分配</th><th>沟通协作</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>BOSS首屏<strong>红绿灯标识</strong>（红=危险/黄=卡滞/绿=顺利）；<strong>销售奖金分级计算引擎</strong>（根据业绩自动算奖金）；汇总目标关联客户最新行动记录直观展示绩效</td><td>全局自动权限机制，上级管理下级，同级互相隔离，助理跟随主管，老板管理全局；支持双重指挥系统模式，上级可按需分配销售任务，系统自动提醒待办任务</td><td>快协作功能基于客户/待办/项目实现团队业务联动，BOSS可助攻；支持通信数据集成，记录外勤拜访、通话随记等；智能日报自动汇总数据，支持主观分析填写，促进沟通协作</td></tr><tr><td><strong>Salesforce</strong></td><td>团队绩效仪表盘实时展示个人/团队KPI</td><td>支持territories区域管理和线索自动分配</td><td>集成Chatter社交协作工具，实现跨部门沟通与文件共享</td></tr><tr><td><strong>纷享销客</strong></td><td>提供团队权限矩阵和角色配置，支持销售目标拆解与进度跟踪</td><td>任务分配支持优先级设置和自动提醒</td><td>移动端适配提升外勤团队协作效率</td></tr><tr><td><strong>钉钉CRM</strong></td><td>可通过钉钉相关功能查看团队销售情况等绩效数据</td><td>任务分配与钉钉待办联动</td><td>深度整合钉钉考勤、日志和会议功能，团队沟通依赖钉钉原生IM，适合扁平化团队快速协作</td></tr><tr><td><strong>SAP CRM</strong></td><td>支持团队业绩统计</td><td>可进行客户资源的公海/私海分配及离职继承</td><td>实现团队成员之间的沟通协作，提升团队整体效率</td></tr><tr><td><strong>Microsoft Dynamics 365 CRM</strong></td><td>通过可视化仪表盘展示团队绩效</td><td>支持移动办公与云端同步，进行任务分配</td><td>实现跨团队实时协作、任务分配及目标追踪</td></tr><tr><td><strong>Oracle CX</strong></td><td>支持团队业绩数据的可视化分析</td><td>配备任务提醒与协作工具</td><td>确保客户资源合理分配，促进团队高效协同，提升整体执行力</td></tr><tr><td><strong>Pipedrive</strong></td><td>提供销售绩效分析</td><td>支持团队任务分配与进度跟踪</td><td>集成500 + 工具提升协作效率</td></tr><tr><td><strong>金蝶</strong></td><td>支持销售业绩分析</td><td>可根据企业需求进行任务分配</td><td>团队成员可通过系统进行沟通协作</td></tr><tr><td><strong>Zoho</strong></td><td>具备团队绩效跟踪功能</td><td>具备任务与日程管理功能（可创建任务、设定提醒）</td><td>支持团队协作</td></tr><tr><td><strong>Freshsales</strong></td><td>可查看团队销售业绩等绩效情况</td><td>实现自动化任务分配</td><td>移动端应用支持随时随地办公，实时同步沟通与订单数据</td></tr><tr><td><strong>HubSpot CRM</strong></td><td>支持团队任务分配、绩效指标可视化</td><td>可进行团队任务分配</td><td>提供团队协作工具，可与Slack等第三方应用集成</td></tr><tr><td><strong>SuiteCRM</strong></td><td>支持绩效报表与销售活动分析</td><td>提供任务看板与日程共享功能</td><td>支持团队成员之间的沟通协作，开源特性允许团队根据需求定制角色权限与协作流程</td></tr><tr><td><strong>用友CRM</strong></td><td>通过智能化数据分析监控团队业绩</td><td>支持任务分配与流程审批</td><td>适合大型团队的规范化管理，满足企业对团队绩效跟踪的精细化需求</td></tr><tr><td><strong>EC SCRM</strong></td><td>可生成团队绩效报表</td><td>支持任务分配与进度跟踪</td><td>提供实时沟通协作工具，整合多种沟通渠道（如微信、电话），方便团队内部及与客户的实时沟通</td></tr></tbody></table><h3>3.2 销售团队管理核心差异解析</h3><ul><li><strong>超兔一体云</strong>：以直观的绩效展示和独特的奖金计算引擎激励团队，权限机制灵活，协作功能贴合销售业务场景，适合需要高效团队管控和激励的企业。</li><li><strong>Salesforce</strong>：强大的绩效展示和区域管理功能，配合社交协作工具，满足大型企业跨部门协作需求。</li><li><strong>纷享销客</strong>：权限和目标管理清晰，移动端适配提升外勤协作，适合外勤业务较多的中大型企业。</li><li><strong>钉钉CRM</strong>：依托钉钉生态，实现轻量化团队管理和快速沟通，适合中小企业扁平化团队。</li><li><strong>SAP CRM</strong>：注重团队业绩统计和客户资源合理分配，提升团队整体效率，适合供应链协同要求高的企业。</li><li><strong>Microsoft Dynamics 365 CRM</strong>：可视化绩效展示和云端同步的任务分配，支持实时跨团队协作，适合需要移动办公和实时协作的团队。</li><li><strong>Oracle CX</strong>：通过业绩可视化分析和任务提醒工具，促进团队高效协同，适合追求执行力的团队。</li><li><strong>Pipedrive</strong>：丰富的集成工具提升团队协作效率，适合需要借助外部工具提升协作的团队。</li><li><strong>金蝶</strong>：支持业绩分析和按需任务分配，方便团队沟通协作，适合各类企业的团队管理。</li><li><strong>Zoho</strong>：具备基本的团队绩效跟踪、任务管理和协作功能，满足一般团队管理需求。</li><li><strong>Freshsales</strong>：自动化任务分配和移动端实时同步，适合需要高效移动办公的团队。</li><li><strong>HubSpot CRM</strong>：绩效可视化和第三方集成协作工具，适合需要跨平台协作的团队。</li><li><strong>SuiteCRM</strong>：开源特性允许团队定制协作流程，适合有个性化需求的团队。</li><li><strong>用友CRM</strong>：智能化数据分析和规范化管理，满足大型团队精细化绩效跟踪需求。</li><li><strong>EC SCRM</strong>：多渠道数据整合和实时沟通协作，适合依赖多渠道获客和沟通的团队。</li></ul><h2>四、总结</h2><p>本次对15款主流CRM品牌从客户管理、销售过程管理和销售团队管理三大维度进行了深度横评。不同品牌基于自身定位和目标客户群体，在各维度展现出了不同的优势和特色。</p><p>在客户管理方面，超兔一体云的多渠道录入、精准分类和全场景跟踪，Salesforce的全球化和AI能力，纷享销客的复杂组织客户协同，钉钉CRM的轻量化管理，EC SCRM的微信生态深度整合等，都为不同类型企业提供了精准洞察客户的有效途径。</p><p>销售过程管理中，超兔一体云的多业务模型适配和业财一体，Salesforce的AI驱动流程自动化，纷享销客对长期服务类业务的支持，SAP CRM的业财一体销售预测，用友CRM对复杂B2B项目型销售的适配等，满足了企业全流程销售管控和效率提升的不同需求。</p><p>销售团队管理上，各品牌也各有千秋，超兔一体云的直观绩效展示和灵活协作，Salesforce的跨部门协作工具，纷享销客的外勤团队适配等，有助于企业将个体能力转化为团队效能。</p><p>企业在选型时，应根据自身规模、业务类型、行业特点和发展需求等因素，综合考虑各品牌的核心能力和差异，选择最适合自己的CRM系统，以提升客户管理效率、优化销售过程、增强团队协作能力，推动企业的数字化转型和发展。</p>]]></description></item><item>    <title><![CDATA[做外贸，国外客户要的Account St]]></title>    <link>https://segmentfault.com/a/1190000047431651</link>    <guid>https://segmentfault.com/a/1190000047431651</guid>    <pubDate>2025-11-27 12:08:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431653" alt="图片" title="图片"/><br/>做外贸时，海外客户常说“Please send me the account statement.” 这并非普通发票或对账单的随口称呼，而是一份面向客户账户维度的“往来账目汇总”。如果回复得不专业或者发错了文件，不仅显得不够职业，还可能影响客户对公司的信任度。今天我们就来彻底搞清楚Account Statement这个外贸中的重要文件。</p><h2>一、Account Statement是什么？为什么客户需要它？</h2><h3>1、Account Statement的准确含义</h3><p>Account Statement，中文叫做"对账单"或"账户对账表"，是一份详细记录买卖双方在特定时间段内所有交易往来的财务文件。它就像一份"交易流水账"，清晰展示：客户在这段时间内下了哪些订单每笔订单的金额是多少已经支付了多少款项还有多少未付款（应收账款）当前的账户余额状态</p><h3>2、Account Statement与Invoice的区别</h3><p>很多人容易混淆这两个概念，其实它们有本质区别：<br/>Invoice（发票）：<br/>针对单笔交易要求客户付款的凭证包含具体商品明细、单价、总价每次交易都会开具<br/>Account Statement（对账单）：<br/>汇总一段时间内的所有交易展示账户整体状况不包含详细商品信息，只显示交易金额通常按月、季度或客户要求提供简单来说，Invoice是"请付款通知"，而Account Statement是“我们之间的账目总结”。</p><h3>3、客户为什么要Account Statement？</h3><p>国外客户索要对账单，通常有以下几个原因：<br/>财务核对需求：客户的财务部门需要核对供应商账目，确保双方记录一致，没有遗漏或重复付款。<br/>审计要求：许多正规企业每年都要接受审计，需要提供所有供应商的对账单作为审计资料。<br/>预算管理：了解与某个供应商的总交易额和未付款项，便于做预算规划和现金流管理。<br/>信用评估：评估自己的付款记录，确认是否享有良好的信用状态，可能为申请更优惠的付款条件做准备。<br/>内部报告：向上级或管理层汇报采购情况时，需要清晰的供应商对账单作为依据。</p><h3>4、Account Statement应该包含哪些内容？</h3><p>一份标准的Account Statement通常包括：<br/>基本信息：供应商和客户的公司名称、地址、联系方式对账期间：如"2024年1月1日至2024年6月30日"<br/>期初余额：对账期开始时客户的欠款或预付款余额<br/>交易明细：日期、交易类型（发票、付款、信用票据等）、发票号或交易参考号、交易金额、累计余额<br/>期末余额：对账期结束时的应收或应付金额<br/>账龄分析（可选）：未付款按时间分类（如30天内、60天内、90天以上等）</p><h2>二、如何快速给国外客户发送Account Statement？</h2><p>手工制作对账单不仅耗时，还容易出错。使用Zoho Books进销存系统，您可以在几分钟内生成专业的Account Statement，大大提升工作效率和专业形象。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047352742" alt="图片" title="图片" loading="lazy"/></p><h3>1、自动汇总所有交易记录</h3><p>Zoho进销存会自动记录您与每个客户的所有交易：每张PI形式发票自动归档到对应客户名下客户的每笔付款自动关联到相应的形式发票信用票据、退款等特殊交易也完整记录所有数据实时更新，无需手动整理系统就像一个会计，可以24小时准确记录每一笔交易，为生成对账单打下坚实基础。</p><h3>2、一键生成专业对账单</h3><p>当客户索要Account Statement时，您只需：<br/>步骤一：进入客户管理模块，找到对应客户<br/>步骤二：点击"对账单"<br/>步骤三：选择对账期间（如最近6个月、本年度等）<br/>步骤四：系统自动生成完整的对账单整个过程不超过1分钟，系统会自动计算：期初余额所有交易明细期末应收款<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047431654" alt="图片" title="图片" loading="lazy"/></p><h3>3、多种发送方式，灵活便捷</h3><p>生成对账单后，Zoho进销存系统提供多种发送方式：直接邮件发送：在系统内直接发送邮件给客户对账单以PDF附件形式发送可自定义邮件内容和问候语系统自动记录发送时间和状态下载PDF文件：下载为PDF格式可通过其他邮件客户端发送或打印后邮寄给客户在线查看链接：生成安全的在线查看链接客户点击即可查看最新对账单无需下载，随时访问</p><h3>4、多币种对账单支持</h3><p>对于外贸企业来说，多币种支持至关重要。Zoho进销存系统能够：自动按客户的交易币种生成对账单美元客户看到美元对账单，欧元客户看到欧元对账单汇率自动应用，无需手动换算多币种交易清晰明了，不会混淆</p><h2>三、Zoho进销存系统的核心优势：不只是对账单</h2><p>使用Zoho进销存系统管理外贸业务，您获得的远不止一个对账单功能：</p><h3>1、完整的客户管理体系</h3><p>客户档案管理：完整记录客户信息、联系人、交易历史信用管理：设置客户信用额度，自动预警超额订单客户分级：按交易额、地区等维度分类管理客户沟通记录：所有邮件往来、通话记录集中保存<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047281596" alt="图片" title="图片" loading="lazy"/></p><h3>2、高效的发票与收款管理</h3><p>专业invoice模板：多种国际标准invoice格式可选，支持20多种语言，可以设置invoice多语言模板<br/>多币种报价：支持180+种货币<br/>在线支付集成：客户可直接在线支付发票<br/>付款提醒：自动发送付款提醒邮件，缩短回款周期</p><h3>3、智能的库存与订单管理</h3><p>实时库存监控：随时掌握库存数量和价值<br/>多仓库管理：支持多地仓库独立管理<br/>采购自动化：库存低于安全线自动提醒<br/>采购订单追踪：从下单到发货全流程可视化<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047357888" alt="图片" title="图片" loading="lazy"/></p><h3>4、精准的财务报表分析</h3><p>应收账款报表：清楚了解哪些客户欠款、欠多久<br/>销售分析报表：按客户、产品、地区等维度分析销售情况利润分析：实时掌握每笔订单、每个客户的利润率现金流报表：预测未来现金流，优化资金安排</p><h3>5、移动办公，随时随地</h3><p>手机APP：iOS和Android双平台支持<br/>随时查看：出差途中也能查看业务数据<br/>快速审批：手机上即可审批订单、查看报表<br/>即时通知：重要业务动态实时推送</p><h3>6、安全可靠，数据无忧</h3><p>云端存储：数据自动备份，永不丢失<br/>权限管理：不同员工设置不同访问权限<br/>操作日志：所有操作可追溯，防止数据篡改<br/>国际认证：通过ISO 27001等多项安全认证</p><h2>四、真实案例：从手忙脚乱到从容应对</h2><p>李女士的故事：李女士经营一家出口家居用品的外贸公司，有30多个长期合作的国外客户。以前她用Excel管理账目，每次客户要Account Statement都要花半天时间："有一次一个大客户急着要对账单做审计，我加班到凌晨才做完，结果还算错了一笔款项，客户很不满意。"李女士回忆说。使用Zoho 进销存系统三个月后，她的工作完全改变：<br/>✅ 客户要对账单，1分钟内就能生成发送<br/>✅ 数据准确无误，再也没有出现过错误<br/>✅ 每月自动给重点客户发送对账单，关系维护更主动<br/>✅ 应收账款一目了然，催款工作更有针对性<br/>✅ 财务人员工作效率提升60%，可以专注更有价值的工作<br/>"现在客户夸我们的财务管理很专业，有几个客户还因此增加了订单量。投入的成本很快就回本了。"李女士满意地说。如果您也想：快速响应客户的Account Statement需求，展现专业的财务管理形象，不妨试试体验Zoho进销存系统！<a href="https://link.segmentfault.com/?enc=sH4EcqgC9h%2By%2BxdltGGO8A%3D%3D.AWBF5A7S8rRIdpDSZjrrgimKpnIMujluA0XfTFSPft9s5I%2FAJSQnuohjkNxl4MldG4vHLLUT4SmLgfdkivHYyw%3D%3D" rel="nofollow" target="_blank">现在注册</a>，立享专属福利：<br/>🎁 免费试用完整功能，无需信用卡<br/>🎁 专业售前一对一指导，快速上手<br/>🎁 丰富的外贸行业案例<br/>🎁 中英文双语界面，国际化操作体验<br/>不要让繁琐的财务工作占用您宝贵的时间，不要因为不够专业的对账单影响客户信任。今天就开始使用Zoho Books，让专业的系统帮您处理这些细节，您只需专注于开拓市场、服务客户。</p>]]></description></item><item>    <title><![CDATA[2024年-2025年开源语音数据汇总：]]></title>    <link>https://segmentfault.com/a/1190000047431667</link>    <guid>https://segmentfault.com/a/1190000047431667</guid>    <pubDate>2025-11-27 12:07:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文转载自「乐百一家」，如果你关注语音模型和算法，这一个不容错过的宝藏且高产的公众号。</p><hr/><p>最近两年开源数据越来越多，大家也意识到，无论是语音识别、语音合成，还是情感分析、多模态交互，高质量的数据集都是技术进步的基石。今天为大家整理了 2024-2025 年最新发布的开源语音数据集，涵盖中文、英文、多语种等多个方向，每个数据集都附上了直接下载链接，方便大家学习和研究。另本文遗漏部分，欢迎大家在文末评论，后续会动态更新整理到一起，做成专栏的形式，方便大家查阅。</p><h2>01 国内开源语音数据集</h2><h3>🚀 Emilia - 10 万小时多语种语音数据集</h3><p>发布时间： 2024 年 8 月</p><p>发布机构： Amphion 团队</p><p>数据规模：101,000 小时</p><p>支持语言： 中文 (49,922h)、英语 (46,828h)、德语、法语、日语、韩语</p><p>特色亮点：</p><ul><li>目前最大的多语种语音生成数据集</li><li>涵盖脱口秀、访谈、辩论、体育解说等多种场景</li><li>提供 Emilia-pipe 预处理流水线</li></ul><p>下载链接：</p><p>Hugging Face: <a href="https://link.segmentfault.com/?enc=maflE%2F3f%2BqhH55%2BZs%2F5g3g%3D%3D.a63Xp4xvXNfrcVyuXzjtFxTcfOHFdLFy%2BqV6Dp9dYgL1nJKLEO8tRzjs%2F%2BFaBxSs" rel="nofollow" target="_blank">https://huggingface.co/datasets/Amphion/Emilia</a></p><h3>👶👴 ChildMandarin &amp; SeniorTalk - 特殊人群语音数据集</h3><p>发布时间： 2025 年 4 月</p><p>发布机构： 智源研究院 + 南开大学 HLT Lab</p><p>ChildMandarin（儿童语音）：</p><p>规模： 41.25 小时，397 名 3-5 岁儿童</p><p>地域： 覆盖 22 个省市</p><p>特色： 填补低幼儿童语音数据空白</p><p>SeniorTalk（老年人语音）：</p><p>规模： 55.53 小时，202 位 75 岁以上老人</p><p>地域： 覆盖 16 个省市</p><p>特色： 世界首个中文超高龄老年人对话数据集</p><p>智源社区：<a href="https://link.segmentfault.com/?enc=EWZwAblXpABIqacwdwdgjA%3D%3D.w5Jk8p8KiCZCmRQq37HYtVQN%2Bnbp%2FS20peK4wFiQRL2O21z9wWKyBymv6sa9HDk6" rel="nofollow" target="_blank">https://hub.baai.ac.cn/view/44729</a></p><p>儿童数据下载地址：<a href="https://link.segmentfault.com/?enc=an4jJn7HDcgYBIEb5o7k8w%3D%3D.t0qa1foUHHdhZ43FuisKmZBwyKoD8iFA0P8QL4xEF4z8NI5ALEvpurZnP1xuTdDXyl3WyA3ILpVHd7N9r3iUmg%3D%3D" rel="nofollow" target="_blank">https://huggingface.co/datasets/BAAI/ChildMandarin</a><br/>老人数据下载地址：<a href="https://link.segmentfault.com/?enc=ZQc2SyP3CjxSBcZ23C3VcA%3D%3D.mkYrlDp3Daj2MtcluVS0LIuySBzlXpIHV9ptX4aJALz2BRLfyisd65Ty01MeUQp3" rel="nofollow" target="_blank">https://huggingface.co/datasets/BAAI/SeniorTalk</a></p><h3>🎭 Chinese-LiPS - 中文多模态语音识别数据集</h3><p>发布时间： 2025 年 5 月</p><p>发布机构： 智源研究院 + 南开大学</p><p>数据规模： 100 小时，36,208 条语音片段，207 位讲者</p><p>核心创新：</p><ul><li>首个 「唇读信息 + 幻灯片语义信息」 结合的中文数据集</li><li>包含唇读视频 (720P) + 幻灯片视频 (1080P)</li><li>覆盖 9 大热门领域</li></ul><p>性能提升：</p><p>单模态：CER 3.99% → 多模态融合：CER 2.58%</p><p>相对提升 35.3%</p><p>智源社区：<a href="https://link.segmentfault.com/?enc=6DskfzqSv19KDvOpiiCnMA%3D%3D.61YAbjFkMQzDcog7K%2Bj3ALae0Yt4cMQ%2F0Q4AJ7hz%2FSiWm1K2Fjn2L8jE7Iy6mC91" rel="nofollow" target="_blank">https://kiri0824.GitHub.io/Chinese-LiPS/</a></p><h3>🌏GigaSpeech 2 - 东南亚多语种数据集</h3><p>发布时间： 2024 年 6 月</p><p>合作机构： 上海交大 X-LANCE、SpeechColab 等</p><p>数据规模： 30,000 小时 (raw)，22,000 小时 (refined)</p><p>语言分布：</p><ul><li>泰语： 10,000 小时</li><li>印尼语： 6,000 小时</li><li>越南语： 6,000 小时</li></ul><p>特色功能：</p><ul><li>涵盖 19 个主题领域</li><li>提供自动化构建流程</li><li>模型性能达到商业服务水平</li></ul><p>HuggingFace下载地址: <a href="https://link.segmentfault.com/?enc=F4vwY9wcH3J7SBatmwOJpA%3D%3D.5y2E7Dq1anaPSPmdOVeNlX5L%2B7BMDGf7S5CPm%2B5uGjSm8bvyy7d%2Fjm1d0SrYQcG6UgJn0GZ7HO84a89HW6RSaA%3D%3D" rel="nofollow" target="_blank">https://huggingface.co/datasets/speechcolab/gigaspeech2</a></p><h3>🇭🇰 WenetSpeech-Yue - 2 万小时粤语语音数据集</h3><p>发布时间： 2025 年</p><p>合作机构： 西北工业大学 ASLP Lab、中国电信、希尔贝壳、Wenet 开源社区、香港科技大学</p><p>数据规模：21,800 小时，全球最大粤语语音数据集</p><p>数据特色：</p><ul><li>覆盖 10 个领域： 讲故事、娱乐、戏剧、文化、vlog、评论、教育、播客、新闻等</li><li>多维标注： ASR 转录、文本置信度、说话人身份、年龄、性别、语音质量评分、字符级时间戳</li><li>质量分级： 强标签 (confidence&gt;0.9)、中等标签 (0.8-0.9)、弱标签 (0.6-0.8)</li></ul><p>技术亮点：</p><ul><li>专门筛选 12,000 小时高质量语音用于 TTS (DNSMOS&gt;2.5 且 SNR&gt;25dB)</li><li>提供 WS Yue-Eval 评测基准</li><li>支持中英混杂 (code-switching) 场景</li></ul><p>下载地址：</p><p>GitHub：<a href="https://link.segmentfault.com/?enc=oHCC431rUkrHfVagUEHzyw%3D%3D.e6zV6DHAEYnV24r%2FueMB61wErFwv4MClgfwK8e6UIZH%2B5va5YtgrnFZmpKLyaG1g" rel="nofollow" target="_blank">https://GitHub.com/ASLP-lab/WenetSpeech-Yue</a><br/>ASR 模型：<a href="https://link.segmentfault.com/?enc=ZLkmghW7i%2FZ1pMcz7UNGFQ%3D%3D.aeA76U7gB9ru8asYBaIbAscS9hdTUTxjyXidw8OnUatF%2B0U5Ohxahwrx0vyoTl2N" rel="nofollow" target="_blank">https://GitHub.com/ASLP-lab/ws-yue-asr</a><br/>TTS 模型：<a href="https://link.segmentfault.com/?enc=Vd1LzVezD3alIQUBmX1U6g%3D%3D.4gocvasRPMb5cG2ykUskhkfgHDi%2FHyXK%2Fv36DSVSdOC6h7OjKmQXmjEx%2FNobLU%2FO" rel="nofollow" target="_blank">https://GitHub.com/ASLP-lab/ws-yue-tts</a></p><h3>🇨🇳 WenetSpeech-Chuan - 1 万小时川渝方言数据集</h3><p>合作机构： 西北工业大学 ASLP Lab、希尔贝壳、中国电信人工智能研究院、南京大学、Wenet 开源社区</p><p>数据规模：10,000 小时，首个大规模川渝方言语音语料库</p><p>覆盖 9 个领域： 满足 1.2 亿母语使用者需求</p><p>多维标注： ASR 转录、文本置信度、说话人情感、年龄、性别、语音质量评分</p><p>应用价值： 填补川渝方言数据空白，推动方言保护</p><p>评测基准：</p><ul><li>WSC-Eval-ASR： 人工标注集，评测不同场景声学条件下的 ASR 性能</li><li>WSC-Eval-TTS： 简单和困难子集，用于标准测试与泛化能力测试</li></ul><p>技术价值：</p><ul><li>基于该数据集训练的模型性能超越 SOTA 系统</li><li>与商业系统相媲美</li><li>推动川渝方言语音技术发展</li></ul><p>下载地址：</p><p>GitHub：<a href="https://link.segmentfault.com/?enc=Bfyt%2BLrRN7Bq6%2Fve9bV%2B1g%3D%3D.fcBojLsx776pKRhAq0yGRMx5OzHkBamWhKT4xr2h1yaUPE1%2FvyR3GS93ylc25n8Z" rel="nofollow" target="_blank">https://GitHub.com/ASLP-lab/WenetSpeech-Chuan</a><br/>ASR 模型：<a href="https://link.segmentfault.com/?enc=fYM1EitzpPpFj0igxjkY0A%3D%3D.XchiPPOMvYT38kyCkujMhctvkrEVeqOO%2BF984YGlbiOgWuAM7xzUWasJK9oUmJwT" rel="nofollow" target="_blank">https://GitHub.com/ASLP-lab/ws-chuan-asr</a><br/>TTS 模型：<a href="https://link.segmentfault.com/?enc=NEYqWp1U1XPo5qe6IVSTkw%3D%3D.%2FRIWX%2BOTboJDhT8qEceZI%2Bc55LqHndhXlNHWdZUUYK9DkedOYOiGbYxY81cTAeKH" rel="nofollow" target="_blank">https://GitHub.com/ASLP-lab/ws-chuan-tts</a></p><h3>🧠<strong> LLaSO - 开源语音大模型框架</strong></h3><p>发布时间： 2024 年</p><p>发布机构： 北京深度逻辑智能科技</p><p>框架组成： 三大核心组件</p><p>LLaSO-Align（对齐数据集）：</p><ul><li>1200 万语音 - 文本对齐样本</li><li>建立语音表示与文本语义空间对齐</li></ul><p>LLaSO-Instruct（指令数据集）：</p><ul><li>1350 万多任务指令样本</li><li>涵盖 20 项任务，支持三种交互模式</li></ul><p>LLaSO-Eval（评估基准）：</p><ul><li>15,044 个测试样本</li><li>标准化评估协议</li></ul><p>下载地址：</p><p>GitHub：<a href="https://link.segmentfault.com/?enc=JahdI8SF2WODzWg%2F6evxnQ%3D%3D.2QuLgAmV1StkVnIYSa2QSZ9aHklyn3Qnc9uU3WmDy7UnxfRskmADAQMxnqUNB6Px" rel="nofollow" target="_blank">https://GitHub.com/EIT-NLP/LLaSO</a></p><h3>🔄 Easy-Turn-Trainset - 对话轮次检测数据集</h3><p>数据规模：约 1100 小时</p><p>数据类型： 真实 + 合成数据</p><p>数据集组成：</p><ul><li>完整状态： 580 小时</li><li>不完整状态： 532 小时</li><li>回应状态： 10 小时</li><li>等待状态： 23 小时</li></ul><p>应用场景： 全双工对话系统的轮次检测</p><p>下载链接：</p><p>数据集：<a href="https://link.segmentfault.com/?enc=94cH6V734eh%2FZzioLYMBIw%3D%3D.pklRcWNmobQKteIzckMy1%2Bd%2FEnmtaWL9VToz1JhYzUfhDHriCmGjZaWfIKwU%2F2RR%2BOZOyxvp%2FmBl%2Fg%2B3xKseGQ%3D%3D" rel="nofollow" target="_blank">https://www.modelscope.cn/datasets/ASLP-lab/Easy-Turn-Trainset</a></p><h3>🌐<strong> CS-Dialogue - 中英文切换数据集</strong></h3><p>发布时间： 2025 年 2 月</p><p>数据规模：104 小时，200 位说话人</p><p>语言类型： 普通话 - 英语切换</p><p>最大的公开自发式中英文切换对话数据集</p><p>包含完整对话录音和转录</p><p>捕捉自然的切换现象</p><p>下载链接：</p><p>arXiv 论文：<a href="https://link.segmentfault.com/?enc=SxcguOQV6TjPU%2Fgh0jZ85w%3D%3D.V0Rsa2quSFvKWuYf3oGi65MjQKuwktFGNhLBEVmF9F0WEWAlBoEAtC%2BtaXeahDOm" rel="nofollow" target="_blank">https://arxiv.org/pdf/2502.18913</a><br/>GitHub：<a href="https://link.segmentfault.com/?enc=yY0c117rwFXdtA9Gtsus4A%3D%3D.WFz0s9jn4YjfrgQFbzs%2BWgWgpOSP7NwbOGCQjVY9lgLsrIT5a3Tqpz8EGDPjEGmlqz9i%2B2CBeOr641X47Xbyzw%3D%3D" rel="nofollow" target="_blank">https://huggingface.co/datasets/BAAI/CS-Dialogue</a></p><h2>02 国际开源语音数据集</h2><h3>🌐Meta Omnilingual ASR Corpus - 1600 + 语言语音数据集</h3><p>发布时间： 2025 年 11 月（最新发布）</p><p>发布机构： Meta AI FAIR 团队</p><p>数据规模： 350 种低资源语言的大规模转录数据集</p><p>支持语言：1600 + 种语言，其中 500 种首次被 AI 覆盖</p><p>技术突破：</p><ul><li>78% 的语言字符错误率低于 10%</li><li>95% 有 10 小时以上训练数据的语言达到实用标准</li><li>36% 低资源语言（&lt;10 小时数据）也达到实用水平</li></ul><p>创新特性：</p><ul><li>少样本学习：仅需几段音频 + 文本即可扩展新语言</li><li>理论扩展能力：可扩展到 5400 + 种语言</li><li>模型规模：3 亿参数（轻量级）到 70 亿参数（高精度）</li></ul><p>下载地址：</p><p>GitHub：<a href="https://link.segmentfault.com/?enc=HiLrg4Xlm1R0qzGVEVRxIQ%3D%3D.kUMfIhY3lVcjOGLSJdzM%2FWiDBMs%2Fpeui%2F4nuzR3XUQPMwJwKEm%2FCFsFSy3GJ4OhDxB7%2Fy5hz3xtpE5G2IpX9pg%3D%3D" rel="nofollow" target="_blank">https://GitHub.com/facebookresearch/omnilingual-asr</a><br/>Hugging Face 数据集：<a href="https://link.segmentfault.com/?enc=OkjadA1lYVbtsCsIOmsWTA%3D%3D.9%2F33FqueJXY5Qaw3223V8Oib5ePw3%2B9HYdVxQMK5t1Bx%2F8dHvZ7ObhYN5VcbPn1i8HOaRMPlfJEiLSPM3V6gBQ%3D%3D" rel="nofollow" target="_blank">https://huggingface.co/datasets/facebook/omnilingual-asr-corpus</a><br/>在线演示：<a href="https://link.segmentfault.com/?enc=BbdkR1ZaFp7xTNQJ3UWIsA%3D%3D.PfyF7FKcghdPf3E2bRFXZVaMv%2BuIOXiAAtSGhED6%2BAQv93Cjm0yN%2B073iiTkVgXFaeF%2BykEsK7fO9ll5cLi9Kw%3D%3D" rel="nofollow" target="_blank">https://aidemos.atmeta.com/omnilingualasr/language-globe</a><br/>转录工具：<a href="https://link.segmentfault.com/?enc=5TZnnSv83ufSeU7SJC%2BJkA%3D%3D.bkii%2FUP%2FAus%2B9oNethyLbAB3QUHnRmDI94X4pG0wyW4lOZLpW047O1SHtRgx6R9g0zzf8AnNk1FldhcsHhoaCg%3D%3D" rel="nofollow" target="_blank">https://huggingface.co/spaces/facebook/omniasr-transcriptions</a></p><h3>🎯Common Voice - 最大众包语音数据集</h3><p>更新频率： 每季度更新</p><p>最新版本： 22.0（2025 年 6 月）</p><p>数据规模： 86.53GB，3,718 小时录制</p><p>支持语言：137 种语言</p><p>参与人数： 97,925 人</p><p>2024-2025 年发展：</p><ul><li>从 80.8GB 增长到 86.53GB</li><li>语言覆盖从 100 + 扩展到 137 种</li><li>参与人数增长 7,000+</li></ul><p>下载地址：</p><p>Mozilla Data Collective: <a href="https://link.segmentfault.com/?enc=4qEUHDoSSdXgruHlzt8GQQ%3D%3D.BvVn6hcORpEGvwgWXSEkVmGsj9U4Z8tjLclqQV49hJA2Hv%2BxvT9SYP9g30NopU4Sf4JtnOVwfdXFUPHvjVHlPQ%3D%3D" rel="nofollow" target="_blank">https://datacollective.mozillafoundation.org/datasets</a></p><h3>🎵 HiFiTTS-2 - 高带宽语音合成数据集</h3><p>发布会议： Interspeech 2025</p><p>数据规模： 36.7k 小时（22.05kHz），31.7k 小时（44.1kHz）</p><p>语言： 英语</p><p>技术特色：</p><ul><li>专注高带宽语音合成</li><li>详细元数据标注</li><li>支持零样本 TTS 训练</li></ul><p>下载地址：</p><p>ISCA Archive：<a href="https://link.segmentfault.com/?enc=4Omnceu6f28aVf8Znsk%2FQA%3D%3D.XW4ZJ8YVgjTXy1tN%2Fr0xX58wJQfFF1AhtjsYhwmcLXUQIMWlE4psirWlUvrBulNDw%2BkJhfsUK9WjAiGvwGiq8g%3D%3D" rel="nofollow" target="_blank">https://huggingface.co/datasets/nvidia/hifitts-2</a></p><h3>🏥Bridge2AI-Voice - 医疗语音数据集</h3><p>发布时间： 2025 年 1 月</p><p>发布机构： NIH Bridge2AI 计划</p><p>数据规模： 12,523 条录音，306 位参与者</p><p>疾病覆盖：</p><ul><li>语音障碍</li><li>神经系统疾病（帕金森、ALS、中风）</li><li>心境障碍（抑郁症、焦虑症）</li><li>呼吸系统疾病</li></ul><p>下载地址：</p><p>PhysioNet（需申请）：HTTPS://physionet.org/content/b2ai-voice/1.1/</p><h3>💊VietMed - 越南医疗语音数据集</h3><p>数据规模： 16 小时标注医疗语音 + 2200 小时无标注语音</p><p>语言： 越南语</p><p>覆盖所有 ICD-10 疾病组</p><p>包含越南所有口音</p><p>提供预训练和微调模型</p><p>下载地址：</p><p>GitHub：<a href="https://link.segmentfault.com/?enc=rmniZYg2%2BkPxtKus%2BdgSjQ%3D%3D.7CVwuNaEX1GySQr2IoeVK60eypEU8jnNHG5GGgKC2iSD7CqGzt6sJdFn%2BXzuCwLZ" rel="nofollow" target="_blank">https://GitHub.com/leduckhai/multimed</a></p><h3>😊 nEMO - 波兰情感语音数据集</h3><p>数据规模： 3 小时，9 位演员</p><p>情感类别： 愤怒、恐惧、快乐、悲伤、惊讶、中性</p><p>下载地址：</p><p>Hugging Face：<a href="https://link.segmentfault.com/?enc=dk9%2B9vgqTSqRKjMf8BorUQ%3D%3D.R7p2ap%2BJnsLKPrDoqew7qF8pbVH9dFji9ulhNCS2gnrDtHFNDebHYroCRZnWGOOo" rel="nofollow" target="_blank">https://huggingface.co/datasets/amu-cai/nEMO</a></p><p>arXiv：<a href="https://link.segmentfault.com/?enc=277dvs6QU%2FX%2Bpl9YL5wjAg%3D%3D.9SMaKPcM54SprZyUdR6urtrNuIMG2lsZboizqhGXN0yvHR5xO%2Fn6YmTPxgt2G4vA" rel="nofollow" target="_blank">https://arxiv.org/abs/2404.06292</a></p><h2>03 数据集统计分析</h2><h3>按规模分布</h3><ul><li>超大规模（10k 小时 +）： Emilia(101k)、WenetSpeech-Yue(21.8k)、GigaSpeech 2(30k)、WenetSpeech-Chuan(10k)</li><li>中等规模（100-1000 小时）： Chinese-LiPS(100)、Easy-Turn(1100)</li><li>小规模（10-100 小时）： ChildMandarin(41)、SeniorTalk(55)、CS-Dialogue(104)</li></ul><h3>按语言覆盖</h3><ul><li>单语言： 中文、英语、波兰语、越南语等</li><li>多语言： Meta Omnilingual(1600+)、Common Voice(137)、Emilia(6)</li><li>方言： 粤语 (WenetSpeech-Yue)、川渝方言 (WenetSpeech-Chuan)</li></ul><h3>按应用领域</h3><ul><li>语音识别： 最多，包含多个大规模数据集</li><li>语音合成： 注重情感表达和多风格</li><li>医疗健康： 新兴重要领域</li><li>情感分析： 多语言覆盖</li><li>多模态： 结合视觉信息</li><li>方言保护： 粤语、川渝方言等</li></ul><h2>04 使用建议</h2><ul><li>规模突破： 10 万小时级数据集成为现实</li><li>质量提升： 多模态、精细化标注成为趋势</li><li>语言覆盖： 从主流语言扩展到 1600 + 种语言</li><li>方言保护： 粤语、川渝方言等地方语言得到重视</li><li>领域深化： 医疗、教育、娱乐等垂直领域快速发展</li><li>技术创新： 自动化构建、合成数据等新技术应用</li></ul><p>这些开源数据集为语音技术的发展提供了强有力的支撑，相信在这些优质数据的推动下，语音技术将在更多领域得到广泛应用。</p><p>💡 温馨提示： 所有数据集请按照其许可证要求合理使用，支持开源社区的发展！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431669" alt="" title=""/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431670" alt="" title="" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=o91cn8SeNrlAmgAmX%2BT1ew%3D%3D.v5Gn%2B75Vo8nDSsoy0nri4iSaJZQeFx4v8W1%2F62WTrtY%3D" rel="nofollow" target="_blank">阅读更多 Voice Agent 学习笔记：了解最懂 AI 语音的头脑都在思考什么</a></p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431671" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[报价→PI→发货→收款全流程数字化管理：]]></title>    <link>https://segmentfault.com/a/1190000047431682</link>    <guid>https://segmentfault.com/a/1190000047431682</guid>    <pubDate>2025-11-27 12:07:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431684" alt="图片" title="图片"/><br/>作为一名从事外贸行业5年的业务经理，我深知外贸订单管理的复杂性。从最初的客户询价，到报价单、形式发票（PI）、发货安排，再到最后的收款确认，每一个环节都不能出错。后来我用了Zoho Books进销存系统，工作效率得到了很大的提升。今天，我就和大家分享一下我是如何利用这套系统实现外贸订单全流程数字化管理的。</p><h2>一、外贸订单管理的那些"痛点"，你中了几个？</h2><p>在使用Zoho进销存系统之前，我每天都在和各种表格、文档打交道，工作状态可以用"焦头烂额"来形容。</p><h3>1、报价单制作效率低下</h3><p>每次客户询价，我都要打开Excel模板，手动填写产品信息、单价、汇率、总价等数据。遇到产品种类多的订单，光是核对价格和计算金额就要花费半小时以上。更让人头疼的是，产品价格经常调整，我需要不断更新Excel模板，一不小心就会用错旧版本，导致报价失误。</p><h3>2、PI与订单信息不同步</h3><p>客户确认报价后，我需要重新制作形式发票（Proforma Invoice）。这意味着我要把报价单上的所有信息再次录入到PI模板中，既浪费时间又容易出错。曾经有一次，我把客户的收货地址抄错了一个字母，差点导致货物无法清关。</p><h3>3、库存管理混乱</h3><p>我们公司有多个仓库，每次接到订单，我都要打电话或发微信确认库存情况。有时候销售部门已经把货承诺给客户了，仓库那边却说库存不足，导致交期延误，客户投诉不断。</p><h3>4、发货信息追踪困难</h3><p>订单发货后，客户经常询问物流进度。我需要在各种聊天记录、邮件和Excel表格中翻找提单号、发货日期等信息。有时候同时处理十几个订单，经常会搞混，给错客户信息。</p><h3>5、收款对账耗时费力</h3><p>每个月月底，我都要花两三天时间对账。翻看银行流水，核对每笔款项对应的订单，计算哪些订单已全额收款，哪些还有尾款未收。遇到客户分批付款的情况，对账工作更是复杂到让人崩溃。</p><h3>6、数据分散，无法统筹决策</h3><p>订单信息分散在各种Excel表格、Word文档、微信聊天记录中，想要统计某个客户的年度采购额，或者分析哪个产品最畅销，我需要手动汇总大量数据，费时费力还容易出错。这些问题不仅降低了我的工作效率，还影响了客户体验，甚至给公司带来了经济损失。我知道必须要改变这种工作方式了。</p><h2>二、Zoho Books如何帮我实现订单全流程数字化管理？</h2><p>在朋友的推荐下，我开始试用Zoho Books进销存系统。说实话，刚开始我还有些怀疑，一个软件真的能解决这么多问题吗？但试用了几天后，我就打消了之前的疑虑。</p><h3>1、快速生成专业报价单，效率大幅提升</h3><p>现在，当客户发来询价时，我只需要在Zoho进销存系统中选择对应的产品，系统会自动带出最新的价格、产品描述、规格参数等信息。我可以根据客户的采购量快速调整折扣，系统会实时计算总价。更让我惊喜的是，Zoho Books支持多币种管理，汇率可以自动更新。我不再需要每天去查汇率、手动计算了。系统还提供了多套专业的报价单模板，我可以根据不同客户的需求选择合适的模板，在模版基础上进行自定义，添加公司Logo和品牌元素。一份原本需要30分钟制作的报价单，现在5分钟就能搞定，而且准确率100%。这让我有更多时间去跟进客户，去和客户聊天，而不是埋头做表格。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047396112" alt="图片" title="图片" loading="lazy"/></p><h3>2、一键转换PI，告别重复录入</h3><p>这是我最喜欢的功能之一。当客户确认报价后，我只需要在系统中点击"转换为PI形式发票（付款通知单）"，报价单就会自动生成形式发票（PI）。所有的产品信息、价格、客户资料都会自动带入，我只需要补充一些付款条款和交货期等细节信息即可。而且形式发票的模板也支持自定义，我完全可以按着自己的喜好来自定义模版，非常方便。整个过程不到1分钟，而且完全避免了人工录入可能产生的错误。系统还会自动为每个PI生成唯一的编号，方便后续追踪和管理。</p><h3>3、实时库存管理，库存状况一目了然</h3><p>Zoho进销存系统会实时显示每个产品在各个仓库的库存数量。当我创建报价单或销售订单时，系统会自动检查库存，如果库存不足，会立即提醒我。我还可以设置库存预警线，当某个产品的库存低于安全库存时，系统会自动发送提醒，让我及时安排采购或生产。这个功能帮助我们公司减少了30%的缺货情况，客户满意度显著提升。更棒的是，每次发货时，系统会自动扣减库存，我不需要再手动更新Excel表格。所有的库存变动都有详细的记录，可以随时追溯。</p><h3>4、发货管理与物流追踪，客户服务更专业</h3><p>在Zoho Books中，我可以直接从销售订单创建发货单。系统会记录发货日期、物流公司、追踪单号等关键信息。当客户询问物流进度时，我只需要在系统中搜索订单号或客户名称，就能立即找到所有相关信息。我还可以在系统中上传装箱单、提单等文档，所有与订单相关的资料都集中在一个地方，再也不用在电脑里翻找各种文件夹了。系统还支持批量发货，当我同时处理多个订单时，可以一次性创建多个发货单，大大提高了工作效率。</p><h3>5、收款管理与自动对账，财务工作轻松搞定</h3><p>Zoho Books的收款管理功能让我的对账工作更是"小菜一碟"。每次收到客户付款，我只需要在系统中记录收款信息，选择对应的发票，系统会自动匹配并更新付款状态。对于分批付款的订单，系统会清楚地显示已收金额和未收金额，我一眼就能看出哪些订单还有尾款未收。系统还会自动计算账龄，对于超期未付款的客户，我可以及时跟进催款。月底对账时，我只需要导出收款报表，就能看到所有的收款明细，与银行流水核对变得非常简单。原本需要三天的对账工作，现在半天就能完成。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047431654" alt="图片" title="图片" loading="lazy"/></p><h3>6、数据分析与报表，决策更科学</h3><p>Zoho进销存系统提供了丰富的报表功能，我可以随时查看销售趋势、客户采购分析、产品销售等数据。这些数据帮助我更好地了解业务状况，制定更科学的销售策略。比如，通过客户采购分析报表，我发现某个客户的采购频率在下降，我会主动联系客户了解原因，及时挽回可能流失的客户。通过产品销售排行，我知道哪些产品最受欢迎，可以重点推广，哪些产品滞销，需要调整策略。所有的报表都可以自定义时间范围和筛选条件，还可以导出为Excel或PDF格式，方便我向上级汇报或与团队分享。</p><h3>7、多人协作，团队效率倍增</h3><p>我们的外贸团队有5个人，使用Zoho Books后，团队协作变得更加顺畅。每个人都可以在系统中查看自己负责的客户和订单，也可以看到其他同事的工作进展。当我休假时，同事可以直接在系统中接手我的订单，所有的历史记录和沟通信息都清晰可见，不需要我再花时间交接工作。系统提供移动版，老板也可以通过系统随时了解团队的业绩情况，不需要我们每周做汇报PPT了。这种透明化的管理方式让团队的工作效率提升了不少。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047345635" alt="图片" title="图片" loading="lazy"/></p><h2>三、为什么我强烈推荐你也试试Zoho Books</h2><p>使用Zoho Books三个月后，我的工作发生了翻天覆地的变化：<br/>✅ 工作效率提升了200%：原本每天要加班处理订单，现在准点下班还能处理更多业务<br/>✅ 订单错误率降低到0：系统自动化处理避免了人工失误<br/>✅ 客户满意度提升：快速响应、准确交付让客户更信任我们<br/>✅ 个人业绩增长了40%：有更多时间开发新客户、维护老客户<br/>✅ 工作压力大幅减轻：不再为对账、找资料、核对信息而焦虑<br/>更重要的是，Zoho进销存的价格非常亲民，相比动辄几万元的传统ERP系统，它的性价比很高。专业版1680元/年，支持5个用户使用，平均每月下来才100多块，而且它是云端系统，不需要安装软件，用浏览器就能访问，手机上也可以随时查看订单信息。<br/>如果你也像我一样，每天用excel管理外贸订单压得喘不过气来；如果你也想提升工作效率，给客户提供更专业的服务；如果你也希望用更科学的方式管理外贸业务——那么，我真心建议你试试Zoho Books。<br/>Zoho Books提供<a href="https://link.segmentfault.com/?enc=aVEqkkdKpEFMxGrYwzYiSA%3D%3D.R36xtWoMozqMnVHQYVkB69vPfW9%2BIqaweQKKCiDbSFquoGma%2B0Op5kJ0D8o5ZfDtgI0YPxkHIo3qfZYWGTYhqA%3D%3D" rel="nofollow" target="_blank">14天免费试用</a>，注册后可以先用自己的真实业务数据测试一下，看看它是否真的能解决你的痛点。</p><h2>结语</h2><p>不要让落后的管理方式限制了你的发展。 在这个数字化时代，工具的选择往往决定了效率的高低。当你的竞争对手已经在用先进的系统管理订单时，你还在用Excel手工操作，差距只会越来越大。</p>]]></description></item><item>    <title><![CDATA[数据透视分析：流行有道，助力无穷的数据分]]></title>    <link>https://segmentfault.com/a/1190000047431705</link>    <guid>https://segmentfault.com/a/1190000047431705</guid>    <pubDate>2025-11-27 12:06:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>数据透视分析：流行有道，助力无穷的数据分析神器</h2><h3>引言</h3><p>在数字化信息化的时代背景下，各行各业经年累月的数据中潜藏了行业的发展规律。分析这些数据、洞察行业走势，是商业发展的重要驱动力。商业兴则时代兴，商业的汇通不仅促进了不同行业的交融，也丰富了行业相关的数据内容，增多维度，扩大规模。如何从庞大繁杂的数据中提炼清晰的结构和规律，对商业决策而言至关重要。数据透视表恰好填补了数据分析领域的工具缺口，凭借实用便捷的功能优势被广泛认可，堪称"数据分析神器"。</p><h3><strong>什么是数据透视表</strong></h3><p>"透视"二字引自现代绘画技法中的透视法，即从不同角度观察目标对象，以掌握事物的多元特征。数据透视表以表征事物的各属性为观察核心--这些属性代表了事物的不同特征，通过组合分析可从多维度洞悉数据全貌。"透视"更强调动态性，通过自由组合、调整行、列、值等维度，可快速切换观察角度。由此，数据透视表是对数据进行解构与再建构的工具，是认识数据的得力助手。</p><p>数据透视表由"数据"和"透视"两部分组成：数据是物料，是研究对象；透视是动态调整行、列、值等维度布局的分析手段，通过灵活搭配切换观察维度。数据透视表的核心结构包括行字段、列字段、值字段，布局如图1所示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431707" alt="img" title="img"/></p><p>图1. 数据透视表结构</p><p>如图1所示，右侧面板中罗列的数据透视表字段均引用自数据源的属性字段，对应一组旅客旅游数据的各维度信息。将这些字段拖拽至面板中的行、列、值字段区域，即可定义数据透视表的最终呈现结构。结合图1具体说明：</p><ul><li><strong>行字段</strong></li></ul><p>将数据源中的type（观光项目）和transportation（交通方式）设置为行字段，数据透视表便根据这两个字段的值进行分组，得到层级化结果。具体地，type字段包含人文历史、休闲旅游和自然风光等三类观光项目，而transportation字段涵盖了大巴、火车、自驾、飞机和高铁等五种交通方式。</p><ul><li><strong>列字段</strong></li></ul><p>city（旅游城市）为列字段，罗列了咸阳、商洛、安康、宝鸡、延安、杨凌、榆林、汉中、渭南、西安、铜川和韩城等陕西城市，设置多个列字段的作用是从列方向上分组数据。</p><ul><li><strong>值字段</strong></li></ul><p>ID作为值字段，呈现了最终统计结果。支持的统计计算包括：计数、求和、平均值、最大值、最小值、乘积、数值计数、标准偏差、总体标准偏差、方差、总体方差等，以满足常见统计需求。如果涉及到复杂统计计算，数据透视表提供了计算字段支持自定义计算公式，生成新的值字段。</p><ul><li><strong>语义</strong></li></ul><p>沿着行列字段的层级定位后，二者纵横的交汇处即为值字段对应的统计结果，由此形成完整的语义表达。以图1中单元格D6为例，意味着有7名旅客选择搭乘大巴（交通工具）前往咸阳（旅游城市）参观人文历史（观光项目）；同理，单元格D5的值字段完整语义表达了前往咸阳（旅游城市）参观人文历史（旅游项目）的旅客共计28名，不局限交通方式。</p><p>数据透视表的 "神器" 属性，核心源于行、列、值字段的结构设计与功能配置，无需复杂编程，即可实现从数据拆解到规律提炼的全流程：</p><ul><li><strong>多维度自由组合</strong></li></ul><p>通过灵活切换行、列字段，可快速切换分析视角。 在图1数据中，取消列字段city，将呈现如图2所示数据透视表。此时单元格D5的语义是乘坐大巴（交通工具）参观人文历史（观光项目）的游客总计24人，不局限城市。不同的行列字段布局，能够对同一个数据做出多元解读。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431708" alt="img" title="img" loading="lazy"/></p><p>图2. 无列字段数据透视表</p><ul><li><strong>量化指标快速运算</strong></li></ul><p>值字段支持求和、计数、平均值、占比等多种运算，无需手动推导公式。如图2中，值字段默认统计方式为计数，若修改值字段统计方式为求和（对ID求和无实际意义，仅做功能展示说明）后，D列数据将同步更新为求和结果，如图3所示，且值字段名称前缀变为了统计方式"求和"。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431709" alt="img" title="img" loading="lazy"/></p><p>图3. 值字段求和</p><ul><li><strong>数据筛选与聚焦</strong></li></ul><p>内置的筛选功能可快速剥离无效信息，聚焦核心分析对象。在图1中，筛选type为人文历史的记录，选择性屏蔽其他type，如图4所示，且行标签所在单元格内右侧显示了筛选器按钮。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431710" alt="img" title="img" loading="lazy"/></p><p>图4. 字段值筛选</p><ul><li><strong>动态更新与适配</strong></li></ul><p>当数据源发生更新时，数据透视表可通过刷新功能同步更新结果，无需重新搭建分析框架，适配数据 "实时迭代" 的需求。</p><h2><strong>独特优势</strong></h2><p>在众多数据分析工具中，数据透视表能脱颖而出，核心在于其平衡了 "专业性" 与 "易用性"，填补了不同用户的需求缺口：</p><ul><li>对比专业分析工具（如 Python、R 语言）：数据透视表无需编程基础，界面可视化操作降低了使用门槛，让非技术背景的商业决策者也能自主完成数据分析，实现 "人人都是数据分析师" 的落地。</li><li>对比基础表格工具（如普通 Excel 表格）：数据透视表无需手动调整公式、重组数据，通过拖拽字段即可快速生成分析结果，大幅提升数据分析效率，尤其适配商业场景中 "快速响应决策" 的需求。</li><li>核心优势闭环："多维度透视 --- 快速运算 --- 动态更新 --- 低门槛操作" 的功能组合，让数据透视表既能处理庞大繁杂的商业数据，又能输出清晰、精准的分析结论，成为商业决策中 "高效且可靠" 的优选工具</li></ul><h2><strong>结语</strong></h2><p>数字化浪潮下，商业数据的价值早已超越记录事实的层面，成为洞察行业规律、驱动创新发展的核心资产。数据透视表以 "透视" 为核心理念，打破了庞大数据与清晰规律之间的壁垒，让复杂数据变得可解读、可应用。从市场趋势的预判到企业策略的制定，从跨行业协作的优化到精准决策的落地，数据透视表正以其独特的功能优势，成为商业发展的 得力助手。</p><p>在商业汇通、行业交融的时代背景下，数据的维度与规模还将持续扩大，数据分析的重要性也将愈发凸显。数据透视表的存在，不仅填补了工具层面的需求空白，更搭建了 "数据-洞察-决策" 的高效通路，助力商业在数据海洋中精准导航，推动时代持续向前发展。</p><h3>扩展链接</h3><p><a href="https://link.segmentfault.com/?enc=X598QorByF0sQOXYCUU3DQ%3D%3D.AN3zbsKMZ1EHaAm1wU36WZAezGWWYHsZoJ9Tpnd89BgNe4ZqQgw9IsGvy%2FWo9wZs" rel="nofollow" target="_blank">嵌入式BI工具，让数据分析无处不在</a></p>]]></description></item><item>    <title><![CDATA[华为云 DeepSeek Tokens ]]></title>    <link>https://segmentfault.com/a/1190000047431716</link>    <guid>https://segmentfault.com/a/1190000047431716</guid>    <pubDate>2025-11-27 12:06:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化智能加速演进的当下，各行业对大模型能力的需求持续攀升。为助力企业与开发者以更低门槛拥抱 AI 生产力，华为云在双十一期间正式推出 DeepSeek Tokens 套餐包限时购活动，以极具竞争力的价格与灵活购买方式，为 AI 应用创新提供强劲动力。此次优惠覆盖 DeepSeek 系列模型，包括 DeepSeek-R1、DeepSeek-V3 等，充分满足企业在自然语言处理、长文本理解、推理分析、代码生成等多场景下的算力需求。<br/><img width="723" height="619" referrerpolicy="no-referrer" src="/img/bVdnbjf" alt="" title=""/><br/> 本次活动面向企业开发团队、AI 创业者、内容创作者等广泛群体，为 DeepSeek 模型的实际落地提供极具性价比的算力资源。</p><p>一、DeepSeek：高性能大模型，助力应用全面升级<br/>华为云 DeepSeek 系列模型以卓越的推理能力、长文本理解能力与稳定表现，成为众多智能业务的首选基础模型。其主要优势包括：<br/>强劲的推理与生成能力<br/>DeepSeek 模型具备优异的逻辑推演、结构化内容生成、代码生成与知识问答能力，可广泛适配技术文档分析、业务流程问答、营销文案生成等场景。<br/>最高 32K 上下文，支持长文档处理<br/>可一次性处理长篇报告、合同、会议纪要、行业研究等内容，让企业信息处理更智能、更高效。<br/>企业级稳定性，开发与集成更易用<br/>结合华为云基础底座，具备更高吞吐、更低延迟，既适合快速开发原型，也支持业务级平稳扩展。<br/>二、双十一限时特惠：DeepSeek Tokens 套餐包更划算<br/>本次双十一活动，华为云推出专属 DeepSeek Tokens 套餐包限时优惠，帮助企业提前储备大模型调用资源，价格远优于日常购入。<br/>活动亮点包括：<br/>多档 Token 规格可选，适配不同业务阶段<br/>限时折扣力度大，成本更可控<br/>购买即生效，可即时调用 DeepSeek 相关模型<br/>有效期充足，可按业务节奏灵活使用<br/>适用于 AI 应用高频调用场景，例如智能客服、内容生成平台、大模型研发团队等。<br/>三、购买后即可使用：上手简单、部署无门槛<br/>无论是企业开发团队还是个人开发者，均可通过“三步完成接入”：<br/>① 登录华为云 → ② 进入活动页购买 Tokens 套餐包 → ③ 获取 Key 调用 DeepSeek 模型<br/>API/SDK 均已提供完善文档，即买即用、即接即跑，大幅提升开发效率。<br/>四、广泛适配的核心场景，帮助企业快速见效<br/>华为云 DeepSeek Tokens 套餐包适用于多行业、多业务场景，包括：</p><ol><li>智能客服与业务助手<br/>自动回答高频问题、知识库检索、业务流程指引，提升客户体验。</li><li>内容生成与营销创意<br/>用于撰写文章、活动文案、海报标题、短视频脚本，降低内容团队创作成本。</li><li>企业文档处理与知识问答<br/>对流程文档、历史记录、技术手册进行摘要、问答、结构化处理。</li><li>研发与工程智能化<br/>自动生成代码、单元测试、技术方案辅助说明等，提升研发效率。</li><li>行业定制 AI 应用<br/>如政务智能咨询、金融合规分析、制造巡检记录总结、教育辅助生成等。<br/>五、AI 普惠加速落地，华为云持续助力行业升级<br/>华为云持续推进 AI 技术的可用性和普惠性，本次双十一推出的 DeepSeek Tokens 套餐包优惠，将进一步降低企业使用大模型的门槛，加速智能应用在各行业的落地，为创新业务注入新的增长动力。<br/>活动页面（DeepSeek Tokens 限时购）：<br/><a href="https://link.segmentfault.com/?enc=HMUjCPlaK7TIzyhVW7QREQ%3D%3D.en4FTVMDk1nk4D5inWNjTQi5NRT8bm%2FHogoPashUsacbIDFOMkyslnRB%2F3lhAvlHlFvXX6KDzq9ZFUemGPf6RDKZQ0XKgqQG2uCrZxbyFbrfcY6ik7nIVHbNkp%2FDd5oQmTSOv2d6Ov8K2%2Bxr9StVgsttfLNJBSPhXOhGTlpZ8Xn0hpi6ToslSC8I%2FfCKn1Xx" rel="nofollow" target="_blank">https://activity.huaweicloud.com/1111_promotion/index.html?ut...</a></li></ol>]]></description></item><item>    <title><![CDATA[SpreadJS：数据录入、指标补录与表]]></title>    <link>https://segmentfault.com/a/1190000047431941</link>    <guid>https://segmentfault.com/a/1190000047431941</guid>    <pubDate>2025-11-27 12:05:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化转型浪潮中，企业数据管理正面临跨平台兼容性差、协作效率低、数据质量难保障等核心痛点。作为一款基于HTML5的纯前端表格控件，SpreadJS凭借其“高速低耗、类Excel操作、全场景适配”的技术特性，在数据录入、指标补录、表单填报三大场景中展现出显著优势，成为企业提升数据治理能力的关键工具。以下从技术架构、功能特性及实际价值三个维度展开分析。</p><p>一、数据录入：性能与体验的双重突破</p><ol><li>极致性能，突破大数据量瓶颈<br/>SpreadJS采用稀疏矩阵存储技术与Canvas绘制引擎，在浏览器端实现百万级数据的高效处理。例如，在电商物流场景中，系统可在2.4秒内完成50万行×20列的分组交叉统计数据加载，内存占用仅80MB，较传统控件性能提升10倍以上。其离线填报功能支持无网络环境下数据暂存，联网后自动同步，避免因网络中断导致的数据丢失，尤其适用于外勤采集、生产现场等移动场景。</li><li>类Excel操作，降低用户迁移成本<br/>SpreadJS深度复刻Excel的操作习惯，支持拖拽数据绑定、单元格格式设置、条件格式应用等513种公式与53项格式控制。某省级统计局经济数据采集系统采用后，数据填报错误率从12%降至1.5%，用户无需培训即可上手，培训成本降低90%。</li><li>四重校验机制，保障数据质量<br/>系统提供实时校验（输入时提示）、提交校验（全表检查）、前端JS校验及后端校验四重防护，结合自定义校验规则（如跨单元格联动、数据唯一性校验），确保数据准确性。例如，某零售集团通过SpreadJS构建的客户分级体系，成功吸引34个百万级交易VIP客户，年营收增长超1亿元。</li></ol><p>二、指标补录：从Excel到Web的无缝迁移</p><ol><li>450+公式引擎，复用现有商业模型<br/>SpreadJS支持动态数组函数（XMATCH/LET/XLOOKUP）及异步函数，企业可直接将Excel中的财务模型、风险评估模型迁移至Web系统。某金融集团通过SpreadJS构建的指标补录平台，将客流与租赁系统数据整合，建立基于交易频次的客户分级体系，实现商业模型的线上化复用。</li><li>数据透视表与集算表，提升分析能力<br/>作为业内唯一兼容Excel的Web端数据透视表控件，SpreadJS支持拖拽字段、数据聚合与分组排序，集算表插件更可处理百万级数据。某制造企业通过集算表将数据加载时间从45秒优化至2.1秒，筛选响应时间从15秒缩短至0.3秒，分析效率提升20倍。</li><li>AI插件赋能，降低公式使用门槛<br/>SpreadJS V18.1版本新增AI插件，用户输入自然语言需求（如“计算A列与B列乘积和”），系统自动生成公式并解释原理。立信智能审计云平台利用该功能，将审计周期缩短40%，同时满足证监会对审计轨迹的单元格级追溯要求。</li></ol><p>三、表单填报：灵活设计与协同编辑的完美结合</p><ol><li>零代码模板设计，提升开发效率<br/>通过在线表格编辑器，业务人员可拖拽20+种组件（如下拉框、复选框、按钮）设计填报模板，模板保存为JSON格式复用。某大型企业采用后，10张表的设计周期从15人天缩短至2人天，开发成本节省2.6万元。</li><li>单元格级权限控制，保障数据安全<br/>系统支持多级权限管理（查看/编辑/导出），敏感数据智能隐藏。某全面预算管理系统通过SpreadJS实现多部门数据实时汇总与协同审核，预算编制周期缩短25%，执行偏差率降低15%。</li><li>实时协同编辑，打破版本混乱<br/>SpreadJS V18.2协同插件基于OT算法实现多人同时编辑，延迟低于300ms，自动合并操作并生成版本快照。某政务系统通过该功能实现经济指标多级上报，流程监控效率提升70%。</li></ol><p>四、技术实现：全栈解决方案的构建</p><ol><li>前后端分离架构，灵活适配业务需求<br/>前端采用SpreadJS实现交互与展示，后端搭配GcExcel处理批量任务（如PDF/Excel导出、复杂计算），形成完整解决方案。例如，超百万行数据可采用“前端加载部分数据+后端计算+结果传输”模式，平衡性能与网络压力。</li><li>跨框架集成，降低系统改造成本<br/>SpreadJS支持Vue、React、Angular等6大主流框架，提供完整API文档与集成指南。某生产采购系统通过稀疏矩阵存储技术，在移动端流畅处理10万+条零件成本数据，内存占用控制在200MB以内。</li></ol><p>从电商物流的实时数据采集，到金融审计的合规性追溯；从制造企业的预算协同，到政务系统的多级上报，SpreadJS以其高性能、易用性与扩展性，成为企业数字化转型的核心工具。其“纯前端、零依赖”的技术架构，不仅降低了开发门槛，更通过与Excel的无缝兼容，让业务人员成为数据治理的主角。</p>]]></description></item><item>    <title><![CDATA[Apache Doris 中的 Data]]></title>    <link>https://segmentfault.com/a/1190000047431952</link>    <guid>https://segmentfault.com/a/1190000047431952</guid>    <pubDate>2025-11-27 12:04:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数据库系统的核心层，查询优化器如同一位精明的策略家，不断分析数据特征并制定最优执行计划。Apache Doris 作为一款高性能的 MPP 分析型数据库，其优化器内置的 Data Trait 分析机制，通过挖掘数据内在的统计特征和语义约束，为查询优化提供了基础设施。让我们一起来探索这个强大的功能！</p><h2>什么是 Data Trait？</h2><p>想象一下，如果你能提前知道数据的 “性格特征”，是不是就能更聪明地处理它们？Data Trait 正是这样一种对查询数据和中间结果的 “性格描述”。在 Doris 中，它目前实现了四种关键特征：</p><ol><li>唯一性（Uniqueness）：数据的 “身份证” “在这个世界上，我是独一无二的！”—— 当某列数据这样 “宣称” 时，它就具有唯一性特征。数学上表示为：NDV（不同值的数量） = 表的总行数。</li><li>均匀性（Uniformity）：数据的 “复制粘贴” “我们全都一样！”—— 当一列数据都是相同值时，它就展现出均匀性。具体指非空不同值数量不超过 1。 有趣事实：这种列就像军队的制服，整齐划一，优化器看到它们可以采取特殊处理策略。</li><li>等值集（Equal Set）：数据的 “双胞胎” “我们形影不离，永远相同！”—— 当两列数据在所有行中都完美匹配时（包括 NULL 值），它们就构成等值集。 Doris 的等值集判断是 NULL 敏感的，NULL ≠ NULL 哦！</li><li>函数依赖（Functional Dependency）：数据的 “因果关系” “只要知道 X，就必然知道 Y！”—— 当一组列（X）能唯一决定另一组列（Y）的值时，就存在函数依赖。 X 称为决定因素（Determinant），Y 称为被决定因素（Dependecy） 定义如下： ∀X， Y ⊆ R， X → Y ⇔ ∀t1， t2 ∈ R， t1 [X] = t2 [X] ⇒ t1 [Y] = t2 [Y] 其中，t [X] 表示元组 t 在属性集 X 上的投影。</li></ol><h2>Data Trait 的表示</h2><h3>唯一性</h3><p>唯一性使用 UniqueDescription 描述， 想象一个公司的员工管理系统：</p><ul><li>独立唯一性（slots）：就像每个员工的工牌 ID（如 101、102），这些值在整个公司内是独一无二的</li><li>联合唯一性（slotSets）：例如“部门+姓名”的组合，单独看部门可能重复（多个研发部员工），单独看姓名也可能重复（同名员工），但“研发部+张三”的组合在全公司是唯一的</li></ul><h3>均匀性</h3><p>均匀性使用 UniformDescription 描述， 包括：</p><ul><li><p>已知值的均匀列（有具体 value）：</p><ul><li>比如查询 WHERE department='研发部'，这时 department 列在结果集中所有值都是“研发部”</li><li>类似 SELECT 1 as const_value 中的 const_value 列，所有行都是 1</li></ul></li><li><p>未知值的均匀列（无具体 value）：</p><ul><li>例如 LIMIT 1 后的所有列，虽然知道它们值相同，但不确定具体是什么值</li></ul></li></ul><h3>等值集</h3><p>等值集采用并查集（一种高效的数据结构）来管理，就像家族关系网：</p><p>每个数据列最初都是独立的“个体”， 当发现两列值完全相同时（如存在谓词 a = b），它们就被划归到同一个家族，最终所有相等的列会形成一棵棵“家族树”，树中的成员彼此等价。</p><h3>函数依赖</h3><p>函数依赖关系使用有向图实现， 就像公司汇报关系：</p><ul><li>节点：代表一组数据列（如员工 ID、部门 ID 等）</li><li><p>边（ → ）：表示决定关系，比如：</p><ul><li>员工 ID → 员工姓名（知道 ID 就能确定姓名）</li><li>部门 ID+项目 ID → 项目经理（联合决定）</li></ul><p>这个关系网具有传递性：如果 A→B 且 B→C，那么 A→C</p></li></ul><h2>Data Trait 是如何推导出来的？</h2><ol><li>逐层调查：从查询计划的最底层开始，每个处理节点（如扫描、过滤、连接等）都会根据自身特点生成对应的数据特征报告</li><li>懒加载机制：只有当优化器真正需要这些特征时才会进行计算，避免不必要的分析工作</li><li>特征合成：高层节点会综合下层节点的特征信息，并结合自身操作特点，生成新的特征描述。 同时，Data Trait 之间也可以相互推导：具有 unique 属性的 slot 能决定所有其他 slot；具有 uniform 属性的 slot 依赖于所有其他的 slot；相等的 slot 互相依赖；相等的 slot 具有相同的 Unique 属性和 Uniform 属性。</li></ol><h3>Data Trait 的推导过程示例</h3><pre><code class="SQL">CREATE TABLE employees (
    emp_id INT NOT NULL,
    emp_name VARCHAR(100),
    email VARCHAR(100),
    dept_id INT,
    salary DECIMAL(10,2),
    hire_date DATE
) UNIQUE KEY(emp_id) DISTRIBUTED BY HASH(emp_id) PROPERTIES('replication_num'='1');

SELECT dept_id, COUNT(*) AS emp_count FROM employees
GROUP BY dept_id;</code></pre><p>以上面的 SQL 为例，说明一下 DATA TRAIT 的推导过程，查询计划如下：</p><pre><code class="Java">[Aggregate]
   |
[Scan]</code></pre><h4>基表扫描层</h4><p>当扫描 employees 表时，优化器发现：</p><ul><li>唯一标识：emp_id 是 UNIQUE KEY，具有唯一性特征</li><li>函数依赖：由于 emp_id 是 UNIQUE KEY，它可以决定表中所有其他列的值（知道员工 ID 就能确定他的部门、姓名等信息）</li></ul><h4>聚合操作层</h4><p>进行 GROUP BY 聚合时，数据特征发生了转变：</p><ul><li><p>唯一性变化</p><ul><li>新增的特性：dept_id 是分组键，具有唯一性特征；</li><li>丢失的特性：原本 emp_id 的唯一性不再有效，因为多行数据被折叠成了分组形式。</li></ul></li><li><p>函数依赖变化</p><ul><li>新增的关系：现在 dept_id 成为新的“决定因素”，可以确定该部门的员工数量 emp_count（就像知道部门编号就能查到该部门的人数统计）</li><li>丢失的关系：原先基于 emp_id 的所有函数依赖都失效了，因为员工级别的信息已被聚合操作折叠。</li></ul></li></ul><h2>Data Trait 如何优化查询？魔法般的规则应用</h2><p>下面通过完整示例演示 Data Trait 如何在实际查询优化中发挥作用。先从建表开始，逐步展示优化器如何利用数据特征进行优化。</p><h3>准备测试环境</h3><p>建表语句和插入数据 SQL 如下：</p><pre><code class="SQL">-- 员工表（包含唯一ID）
DROP TABLE IF EXISTS employees;
CREATE TABLE employees (
    emp_id INT NOT NULL,
    emp_name VARCHAR(100),
    email VARCHAR(100),
    dept_id INT,
    salary DECIMAL(10,2),
    hire_date DATE
) UNIQUE KEY(emp_id) DISTRIBUTED BY HASH(emp_id) PROPERTIES('replication_num'='1');

-- 部门表（包含唯一ID）
DROP TABLE IF EXISTS departments;
CREATE TABLE departments (
    dept_id INT NOT NULL,
    dept_name VARCHAR(100),
    location VARCHAR(100)
) UNIQUE KEY(dept_id) DISTRIBUTED BY HASH(dept_id) PROPERTIES('replication_num'='1');

-- 订单表（包含唯一ID）
DROP TABLE IF EXISTS orders;
CREATE TABLE orders (
    order_id INT NOT NULL,
    customer_id INT,
    order_date DATE,
    amount DECIMAL(10,2)
) UNIQUE KEY(order_id) DISTRIBUTED BY HASH(order_id) PROPERTIES('replication_num'='1');


-- 插入测试数据
INSERT INTO departments SELECT number, concat('name',cast(number as string)), concat('location', cast(number as string)) from numbers("number"="30");

INSERT INTO employees SELECT number, concat('name',cast(number as string)), concat('email',cast(number as string)),number % 30, number, '2025-01-01' from numbers("number" = "100000000");

INSERT INTO orders VALUES
(1001, 5001, '2023-01-10', 999.99),
(1002, 5001, '2023-02-15', 1499.99),
(1003, 5002, '2023-01-20', 799.99),
(1004, 5003, '2023-03-05', 2499.99);</code></pre><h3>Data Trait 优化实战演示</h3><h4>根据连接键唯一性消除连接（ELIMINATE_JOIN_BY_UK）</h4><p>场景：在进行 left join 时，右表的连接键是唯一的（允许存在多个 NULL 值），且查询只需要左表数据时...</p><p>魔法：直接去掉这个 Join！因为右表要么匹配一行，要么不匹配，不影响左表数据完整性。</p><p>示例如下：</p><pre><code class="SQL">-- 原始查询
SELECT COUNT(emp_id) FROM (
SELECT e.emp_id
FROM employees e
LEFT OUTER JOIN departments d ON e.dept_id = d.dept_id) t;

-- 优化后等效查询
SELECT COUNT(emp_id) FROM employees e;</code></pre><p>关闭 ELIMINATE_JOIN_BY_UK 优化时（使用 set disable_nereids_rules = 'ELIMINATE_JOIN_BY_UK'关闭优化），执行时间为 0.1sec， 在开启 ELIMINATE_JOIN_BY_UK 优化时，执行时间为 0.05sec，<strong>性能提升了 100%</strong>。</p><h4>根据唯一性消除冗余聚合键（ELIMINATE_GROUP_BY）</h4><p>场景： 当 Group By Key 列中存在具有 unique 并且非空属性的列时...</p><p>魔法：可以直接把 Group By 删除</p><pre><code class="SQL">--原始查询
SELECT COUNT(c2) FROM 
(SELECT emp_id c1, sum(salary) c2 from employees GROUP BY emp_id, emp_name) t;

-- 优化后等效查询
SELECT COUNT(c2) FROM 
(SELECT emp_id c1, salary c2 from employees) t;</code></pre><p>在关闭 ELIMINATE_GROUP_BY 优化时，执行时间为 0.96sec， 在开启 ELIMINATE_GROUP_BY 优化时，  SQL 的执行时间是 0.08sec， <strong>性能提升了 1100%</strong>。</p><h4>消除存在依赖关系的聚合键（ELIMINATE_GROUP_BY_KEY）</h4><p>场景：Group By 多列，并且这些列中具有函数依赖关系</p><p>魔法：使用函数依赖中被决定的 slot 可以在 Group By Key 列中被消除。</p><p>示例如下：</p><pre><code class="SQL">--案例1: 根据函数提供的函数依赖消除
-- email -&gt; SUBSTR(email, 1, INSTR(email, '@')-1)
-- 原始查询
SELECT count(email) FROM (SELECT email
FROM employees
GROUP BY email, SUBSTR(email, INSTR(email, 'l')+1)) t;
-- 优化后等效查询
SELECT count(email) FROM (SELECT email
FROM employees
GROUP BY email) t;

--案例2: 根据等值集提供的函数依赖消除
-- 原始查询
SELECT COUNT(*) 
FROM employees e 
INNER JOIN departments d ON e.dept_id = d.dept_id 
GROUP BY e.dept_id, d.dept_id;
-- 优化后等效查询
SELECT COUNT(*) 
FROM employees e 
INNER JOIN departments d ON e.dept_id = d.dept_id 
GROUP BY e.dept_id;</code></pre><p>以案例 1 为例，在关闭 ELIMINATE_GROUP_BY_KEY 优化时，执行时间为 2.11s， 在开启 ELIMINATE_GROUP_BY_KEY 优化时，SQL 的执行时间为 1.41sec， <strong>性能提升了 50%</strong>。</p><h4>消除均一列的聚合键（ELIMINATE_GROUP_BY_KEY_BY_UNIFORM）</h4><p>场景：Group By 的列所有值都相同...</p><p>魔法：直接去掉 Group By，因为所有行都属于同一组。</p><p>示例如下：</p><pre><code class="SQL">-- 原始查询
SELECT hire_date, max(salary) FROM employees WHERE hire_date='2025-01-01' GROUP BY dept_id,hire_date;

-- 优化后等效查询
SELECT '2025-01-01', max(salary) FROM employees WHERE hire_date='2025-01-01' GROUP BY dept_id;</code></pre><p>在关闭 ELIMINATE_GROUP_BY_KEY_BY_UNIFORM 优化时，执行时间为 0.15sec，在开启 ELIMINATE_GROUP_BY_KEY_BY_UNIFORM 优化时，SQL 的执行时间是 0.11sec，<strong>性能提升了 36%</strong>。</p><h4>消除无意义排序（ELIMINATE_ORDER_BY_KEY）</h4><p>场景：按唯一键排序， 或者排序键中包含具有函数依赖时。</p><p>魔法：去掉这个 Order By，因为数据已经自然有序， 去掉函数依赖中被决定的 Key。</p><p>示例如下：</p><pre><code class="SQL">-- 案例1：唯一性推导的函数依赖简化
SELECT sum(c1) FROM
(SELECT emp_id c1, emp_name c2
FROM employees
ORDER BY emp_id,emp_name,email,dept_id,salary,hire_date
LIMIT 1000000) t;
-- 优化后等效查询
SELECT sum(c1) FROM
(SELECT emp_id c1, emp_name c2
FROM employees
ORDER BY emp_id
LIMIT 1000000) t;

-- 案例2：表达式推导的函数依赖简化
SELECT hire_date, EXTRACT(YEAR FROM hire_date), EXTRACT(MONTH FROM hire_date)
FROM employees
ORDER BY hire_date, EXTRACT(YEAR FROM hire_date), EXTRACT(MONTH FROM hire_date);
-- 优化后等效查询
SELECT hire_date, EXTRACT(YEAR FROM hire_date), EXTRACT(MONTH FROM hire_date)
FROM employees
ORDER BY hire_date;

-- 案例3: 多列表达式依赖简化
SELECT emp_name
FROM employees 
ORDER BY emp_name, email, CONCAT(emp_name, ' ', email);
-- 优化后等效查询
SELECT emp_name
FROM employees 
ORDER BY emp_name, email;

-- 案例4: 根据均匀性消除
SELECT emp_name 
FROM employees 
WHERE emp_id = 101 
ORDER BY emp_id;
--优化后等效查询
SELECT emp_name 
FROM employees 
WHERE emp_id = 101;</code></pre><p>以案例 1 为例，在关闭 <code>ELIMINATE_ORDER_BY_KEY</code> 优化时，SQL 的执行时间是 0.37sec， 在开启 <code>ELIMINATE_ORDER_BY_KEY</code> 优化时，SQL 的执行时间是 0.13sec，<strong>性能提升了 185%</strong>。</p><h4>优化效果对比</h4><p>五个优化规则的效果对比如下图所示，蓝色代表关闭优化规则的 SQL 执行时间，橙色代表开启优化规则的 SQL 执行时间。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431954" alt="优化效果对比.png" title="优化效果对比.png"/></p><h2>最佳实践</h2><h3>建议做法：为所有唯一键列添加明确的 UNIQUE 约束</h3><p>无论列是否为主键，只要具有唯一性特征（包括业务唯一键、组合唯一键和外键关联列），都应通过 UNIQUE 约束明确定义。</p><pre><code class="SQL">CREATE TABLE orders (
    order_id INT,
    order_code VARCHAR(20));
ALTER TABLE orders ADD CONSTRAINT orders_uk UNIQUE (order_id);</code></pre><p>优化收益：帮助优化器识别唯一性特征，实现 Join 消除、Group By 简化等优化。</p><h3>建议做法：合理使用 NOT NULL 约束</h3><p>对业务上不允许为空的列添加 NOT NULL，因为上面提到的一些优化规则，是要求 slot 唯一且非空或者均匀且非空才能应用， 添加 NOT NULL 可以避免 NULL 值对优化的干扰。</p><pre><code class="Java">CREATE TABLE products (
    product_id INT NOT NULL,
    product_name VARCHAR(100) NOT NULL);</code></pre><h3>避免做法：过度使用 SELECT *</h3><pre><code class="SQL">-- 应避免的写法
explain logical plan
SELECT * 
FROM employees e
LEFT OUTER JOIN departments d ON e.dept_id = d.dept_id;

-- 推荐写法
explain logical plan
SELECT e.* 
FROM employees e
LEFT OUTER JOIN departments d ON e.dept_id = d.dept_id;</code></pre><p>问题原因：例如，优化规则 ELIMINATE_JOIN_BY_UK 能够应用的条件之一是投影列中只出现 LEFT OUTER JOIN 左表的列， 所以当您只需要左表数据时，SELECT * 的使用会阻碍优化器应用优化规则。</p><h3>避免做法：避免冗余的分组键和排序键</h3><pre><code class="SQL">-- 冗余分组列（即使用者知道product_id决定product_name，但是数据库系统未识别此依赖，此时product_name为冗余，可以删除）
SELECT product_id, product_name
FROM products
GROUP BY product_id, product_name;</code></pre><p>通过主动避免冗余的分组键和排序键，即使某些函数依赖无法被系统自动识别，您仍然可以提高查询执行效率， 减少资源消耗， 保持代码简洁性。</p><h2>总结和展望</h2><p>Data Trait 通过四大核心特征（唯一性、均匀性、等值集、函数依赖）为查询优化器提供了深度的数据认知能力：</p><ul><li><strong>数据特征识别</strong>：精确捕捉数据的本质属性，如主键唯一性、常量列均匀性等</li><li><strong>查询语义理解</strong>：解析 SQL 操作背后的真实数据关系，识别冗余操作</li><li><strong>优化决策支持</strong>：为查询重写、计划选择等优化提供理论依据</li></ul><p>Data Trait 的设计采用了高度模块化的架构，为未来的功能扩展预留了充分空间。特别是在 Uniform 特征的扩展方面，计划引入更精细化的取值分布描述能力。当前 Uniform 主要记录列值完全均匀（单一值）的情况，下一步将扩展为支持记录有限离散值的场景。例如当查询包含 WHERE status IN （'active'，'pending'）这样的 IN 谓词过滤时，优化器可以精确获知 status 列在此查询上下文中只有 2 个可能的取值。这种扩展后的 Uniform 特征将为优化器带来更丰富的决策依据。</p>]]></description></item><item>    <title><![CDATA[如何选择高效的工业解决方案平台？ 月下水]]></title>    <link>https://segmentfault.com/a/1190000047431959</link>    <guid>https://segmentfault.com/a/1190000047431959</guid>    <pubDate>2025-11-27 12:03:41</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当前全球制造业加速迈向智能化与数字化转型的时代洪流中，企业普遍面临着前所未有的竞争压力与运营优化需求。传统的自动化技术，尽管在提升生产效率方面扮演了重要角色，但其对于海量非结构化数据的处理能力、复杂情境下的自主决策水平以及全业务链条的深度协同效果仍显不足，难以完全释放数据与工艺的潜能。这时，“工业解决方案”——一种以人工智能（AI）核心引擎，但致力于解决实际痛点、改造而非仅仅添加技术的系统性方法，正展现出其关键的战略方向。<br/>市场对于先进工业解决方案的需求日益迫切，主要体现在对更高效生产、更低成本、更优产品质量以及更强供方链韧性的多元化追求上。然而，如何将AI真正转化为解决复杂工业问题的能力，而非仅仅是炫技？这要求解决方案不仅包含先进的技术组件，更需要一个强大的、能够统一调动各种资源的中枢平台。在这个框架下，“平台+数据+场景”的集成方法被证明是在处理机器与机器之间的复杂通信和内部业务协同方面至关重要的策略。<br/>正如引言中所述，工业智能体作为广义上的一类先进工业解决方案，正以惊人的速度重构传统制造体系，远超一般自动化系统的能力边界。这正是广域铭岛所倡导的技术路径。通过其工业AI平台，即实现了跨数据、跨知识、跨决策的三大“打通”。例如，其卓越的数据处理能力得以在平台引入或初期案例的制造环节中显现。这些系统不仅能识别信息噪音，更能进行深层次分析，针对具体复杂情况，比如一台电解槽每秒产生数千个温度数据点，不仅能从中识别潜在异常，更能依靠算法进行自动调节，展现出降低40%的能耗等令人印象深刻的性能。这种能力进一步覆盖企业在全面需求驱动下的工厂运营管理各个环节中，将机器在传统自动化无法触及的非结构化和模糊性任务处理上得到升华。<br/>广域铭岛的工业解决方案在这三个方面展现出强大的能力，使生产效率得以在平台基础之上大幅度提升，并如能耗优化、工序智能控制等代表性场景所示变得更具生产实践意义。其核心在于让AI不再是孤立的技术节点，而是能够贯穿企业研产供销全链路的新型生产力载体，类似于构建一个自动化的生产和服务协同复合体。这种能力要求其系统不仅能获取数据，还要能理解生产逻辑，甚至自动优化操作，以应对不同制造商的需求。例如，在汽车零部件生产中，基于实际场景的调度优化，使搬运效率和整体作业流程变得更为协同；在食品饮料厂，视觉质检的智能体将手动录入的效率从繁琐转变为数千倍的提升，这些都是具体的、可衡量的工业应用案例，体现了广域铭岛所提供的工业解决方案的强转化和系统性。<br/>在国家大力推动“人工智能+制造”战略的机遇下，广域铭岛技术的核心意义在于它的工业解决方案不仅是处理单个数据或任务，更是起到打通整个系统的作用。在制造行业的演进中，这成为从依赖数据传输、通信技术和硬件设施的基础架构向一个有机整体转变的关键一步。他们的解决方案的核心理念，在于将复杂的工业知识，特别是那些宝贵的源于经验和师傅们的感官诀窍，通过精心设计的转换过程，赋予数字形式——即所谓的 “智能体配方” 正是如此诞生。这些高质量和可量化的知识，使得广域铭岛的解决方案能够跨过知识的门槛，融入更深层次的企业生产流程。<br/>更远的前景展望，为了应对如能耗监控、供应链协同等可持续需求，广域铭岛还在持续研发更绿色、更智能的方向，例如其“绿色智能体”系统。在这方面，制造运营管理更加利害的原则被平台所利用。它通过分析能源利用率，结合生产的复杂逻辑，有助于显著减少碳排放成本，这是构成未来更具市场竞争力的原生企业的重要部分。广域铭岛的工业解决方案，强调构建一个完整的工业智能生态，这不仅仅是技术的进步，更是构建跨越系统、专业和业务流程壁垒的智能制造生态系统。他们正致力于为制造商提供一体化的解决方案，帮助其打造面向未来、适应数据驱动和算法决策模式的企业架构。<br/>总而言之，随着5G、边缘计算以及物联网技术的日益成熟，提供工业核心组件的智能化厂家正在面对数字与现实交汇处的重大课题——如何打造强大的工业解决方案平台？一种趋势已经明确，工业解决方案的未来在于深度融合智能化与产业知识，依托强健的平台与一整套创新场景，实现降本增效提质的核心目标。广域铭岛凭借其在工业智造超级智能体方面的领先地位和丰富实践经验，无疑成为了引领这一时代变革的关键力量。</p>]]></description></item><item>    <title><![CDATA[ITSS标准的核心理念：以服务为中心的管]]></title>    <link>https://segmentfault.com/a/1190000047431961</link>    <guid>https://segmentfault.com/a/1190000047431961</guid>    <pubDate>2025-11-27 12:02:42</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>我最近在分析一组行业调研数据：在过去三年里，国内超过68%的IT组织仍以“系统可用率”和“设备健康度”作为核心绩效指标，而只有不到20%的企业将“用户体验”列入服务管理的核心目标。这组数据其实暴露了一个深层问题——我们的IT管理仍然停留在“以设备为中心”的思维里，而ITSS标准想要改变的，正是这种价值导向。它要求我们重新认识IT的本质，从“管理系统”转向“交付服务”，从“关注技术”转向“关注客户价值”。</p><p><img width="723" height="338" referrerpolicy="no-referrer" src="/img/bVdnbnJ" alt="image.png" title="image.png"/></p><p><strong>从“设备导向”到“服务导向”的价值迁移</strong><br/>十年前，我第一次接触ITSS时，最深的感受就是它的“人本”与“价值导向”特征。传统IT管理强调的是设备稳定、网络连通、系统安全，但在服务经济时代，客户不再只关心“设备有没有坏”，而是关心“服务是否可持续”“体验是否一致”。这就意味着，IT组织必须从“运维机器”转变为“提供体验”的服务机构。<br/>数据上的对比更加直观：一家制造型企业在引入ITSS前，系统月平均故障时间仅0.5小时，但用户满意度始终低于70%。后来通过建立服务目录、定义服务级别、优化流程管理，他们发现满意度在半年内提升到89%。这说明，设备性能的“好坏”并不能直接反映服务质量，“以服务为中心”才是真正能驱动业务价值的管理逻辑。</p><p><strong>以客户视角定义IT服务</strong><br/>要做到“以服务为中心”，第一步是让服务定义从客户视角出发，而非技术视角。<br/> 我常问项目团队一个问题：“你认为客户购买的是服务器，还是‘可用的业务’？”<br/> 在传统的设备导向模式下，我们更容易陷入技术思维——关注CPU、带宽、磁盘IO；但客户要的从来不是这些指标，而是“确保业务不出问题”。ITSS标准通过引入“服务目录”和“服务级别协议（SLA）”，把模糊的技术交付转化为客户可理解的服务语言，实现了从“技术指标”到“服务体验”的转译。<br/>比如，在ITSS GB/T 28827.1-2022 第5章中，明确提出“服务目标应以客户期望为导向”。这不仅是一条管理要求，更是一种思维转型——让技术人员从幕后走向台前，学会理解用户、度量感受、传递价值。</p><p><strong>流程管理：服务交付的中枢</strong><br/>“以服务为中心”不仅是一种理念，更是一套可落地的体系。其核心抓手就是流程管理。在ITSS体系中，事件管理、问题管理、变更管理、配置管理等被整合成一条“服务交付主线”，所有流程都围绕“服务体验”展开。<br/>我曾在一家零售集团辅导ITSS体系建设，他们的问题很典型——运维团队反应速度快，但客户投诉依旧频繁。原因在于：流程碎片化、信息孤岛严重。我们帮助他们搭建了统一的服务台平台，将所有事件、请求、变更纳入流程追踪。仅三个月，平均响应时间缩短了38%，而服务满意度提升近20%。这类数据说明，标准化的流程不是官僚化，而是让服务变得“可见、可控、可持续”。<br/>作为艾拓先锋的官方ITSS授权讲师，在讲授ITSS服务项目经理认证培训课程时我会特别强调这一点。服务不是技术堆砌的结果，而是流程协同的产物；每一次事件响应、每一次变更审批，都是企业服务文化的体现。</p><p><strong>案例：应急事件中的“服务导向”反转</strong><br/>让我印象深刻的是一家金融机构的应急事件案例。某日核心账务系统突发中断，技术团队在十分钟内定位问题、二十分钟内修复完毕。看似完美的技术表现，却换来客户的强烈不满。复盘时我们发现，问题不在“处理速度”，而在“沟通缺失”——在整个过程中，客户没有获得任何状态反馈，不知道何时恢复，也不知道影响范围。<br/> 我们建议他们在ITSS应急管理流程中增加“服务沟通节点”：当事件进入重大级别时，自动生成客户通告模板，安排客户代表与业务方同步状态。三个月后，类似事件的投诉率下降了70%。这就是“以服务为中心”的真正落地——它不是修系统，而是修复“信任”。</p><p><strong>持续改进：让服务价值形成闭环</strong><br/>ITSS标准的另一个核心思想，是让服务形成闭环。从事件解决到问题分析，再到改进计划和知识沉淀，每个环节都在强化服务的可持续性。<br/> 以流程为骨架、以数据为血液、以客户体验为核心，这三者构成了ITSS标准的生命体。<br/> 当企业真正运用持续改进机制时，服务就不再是一次性交付，而成为动态演进的体系。正如我常说的：“服务的成熟，不是工具更先进，而是流程更稳定、客户更信任。”</p><p><strong>数据对比：理念转变带来的可量化成果</strong><br/>我曾做过一项跟踪分析：在20家通过ITSS三级及以上评估的企业中，引入“以服务为中心”理念后，平均客户满意度提升22%，运维工单闭环时间缩短31%，重复事件率下降28%。这些数字背后，是管理理念的革新，也是组织能力的成长。</p><p><strong>反思与设问：我们真的以服务为中心了吗？</strong><br/>今天，几乎所有IT管理者都会口头上说“以服务为中心”，但真正做到的并不多。很多企业的服务指标依旧是“系统无故障”“工单数量少”，而非“客户感知好”“服务体验优”。ITSS已经为我们提供了系统的理论与工具，但要真正让理念落地，还需要组织文化的转变、流程的协同、数据的支撑。<br/> 所以，我常在培训结束时问学员一个问题：<br/>你们的服务，是为了系统运转，还是为了客户信任？</p>]]></description></item><item>    <title><![CDATA[华为试水毛绒 AI 玩具；理想将发布智能]]></title>    <link>https://segmentfault.com/a/1190000047431965</link>    <guid>https://segmentfault.com/a/1190000047431965</guid>    <pubDate>2025-11-27 12:02:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431968" alt="" title=""/></p><p><strong>开发者朋友们大家好：</strong></p><p>这里是 <strong>「RTE 开发者日报」</strong>，每天和大家一起看新闻、聊八卦。我们的社区编辑团队会整理分享 RTE（Real-Time Engagement） 领域内「有话题的<strong>技术</strong>」、「有亮点的<strong>产品</strong>」、「有思考的<strong>文章</strong>」、「有态度的<strong>观点</strong>」、「有看点的<strong>活动</strong>」，但内容仅代表编辑的个人观点，欢迎大家留言、跟帖、讨论。</p><p><em>本期编辑：@鲍勃 和 Gemini（pro 真的很不错）</em></p><h2>01 有话题的技术</h2><p><strong>1、腾讯混元开源轻量 OCR 模型，刷新行业榜单</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431969" alt="" title="" loading="lazy"/></p><p>昨天，腾讯混元宣布开源全新轻量 OCR 模型「HunyuanOCR」，仅凭 1B 参数规模在多项业界 OCR 应用榜单上取得 SOTA 成绩。</p><p>该模型依托混元原生多模态架构打造，在复杂文档解析与多语种识别方面具备领先能力。</p><p>HunyuanOCR 的设计采用端到端范式，结合原生分辨率视频编码器、自适应视觉适配器和轻量化语言模型，在推理效率上优于业界常见的级联方案。</p><p>性能方面，该模型在 OmniDocBench 测评中获得 94.1 分，超越 Google Gemini 3-pro 等领先模型；在 OCRBench 榜单上以 860 分成绩刷新了 3B 以下模型的最佳表现。</p><p>应用层面，HunyuanOCR 能够覆盖文档、艺术字、街景、手写、广告、票据、截屏、游戏、视频等九大场景，支持票据字段抽取、视频字幕识别以及拍照翻译。</p><p>其多语种支持能力覆盖 14 种高频小语种，并在 ICDAR2025 文档翻译比赛小模型赛道中夺冠。该模型已在 GitHub 与 Hugging Face 平台开放下载和体验。</p><p>💻 GitHub: </p><p><a href="https://link.segmentfault.com/?enc=dvK0a6%2BdDks2TscPwYTscQ%3D%3D.j8pygISork9a61dP1RAy79vrzZ6o%2FUBXsey1tidG%2BdpsPVJ54k6rwgcGMDvU2%2FdI" rel="nofollow" target="_blank">https://github.com/Tencent-Hunyuan/HunyuanOCR</a></p><p>🤗 Hugging Face: </p><p><a href="https://link.segmentfault.com/?enc=L%2BXFMFaSvBc%2FYcT%2Fn0TRSg%3D%3D.WMXTHct2Oj2RKFzzyr0Dsker8EY2dfvc9GrQ51uuFZzpRBSVvxo%2BSYBQk8Ymh7mS" rel="nofollow" target="_blank">https://huggingface.co/tencent/HunyuanOCR</a></p><p>( @APPSO)</p><p><strong>2、Jizai Face ：可拆装式外置感知器官系统</strong></p><p>Jizai Face 是由东京大学 Jizai Bodies 团队研发的可拆装式外置感知器官系统。</p><p>旨在探索「可扩展人类身体」的交互形态。</p><p>组件包括可眨眼成像的 Jizai Eye、具备语音输出的 Jizai Mouth、拾音的 Jizai Ear 以及可检测气味的 Jizai Nose。</p><p>所有器官均可独立供电、无线连接，并可附着在人体或环境任意位置，实现延展视觉、听觉、嗅觉与表达能力的多模态交互。</p><p>（@邓邓的机器猫）</p><p><strong>3、ai-coustics 推出「Quail STT」：专为机器听觉优化，让主流 STT 服务在真实噪音中更准确</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431970" alt="" title="" loading="lazy"/></p><p>柏林初创 ai-coustics 公司发布了专为机器优化的语音增强模型「Quail STT」。与 Krisp 等为人耳设计的传统降噪工具不同，Quail STT 专注于保留 STT 模型所需的关键声学结构，旨在作为一层通用的预处理工具，显著降低主流语音转文本服务在真实嘈杂环境下的转录错误率。</p><ul><li>专为 STT 优化，而非人耳感知：产品的核心理念是，让音频「听起来干净」并不等同于让「机器更容易理解」。「Quail STT」在降噪的同时，会刻意保留对 STT 解码至关重要的语音发音和频谱线索，避免了传统降噪工具可能带来的信息损失。</li><li>实测效果显著，降低 10-25% 错误率：在包含多种真实噪音（如混响、低质量麦克风）的基准测试中，「Quail STT」为 Deepgram、AssemblyAI、Gladia 等主流 STT 服务带来了 10% 至 25% 的相对词错率（WER）降低，效果全面优于 Krisp 等感知降噪工具。</li><li>供应商无关，即插即用：该模型被设计为「供应商无关性」，无需针对特定 STT 模型进行调优。开发者可以将其作为一个独立的预处理层，轻松集成到现有的语音处理流程中，提升下游任意 STT 服务的性能。</li><li>精准分析并减少三类核心错误：「Quail STT」能够同时减少 STT 任务中最常见的三种错误：因语音掩蔽导致的「替换」（如 "coffee" 听成 "copy"）、因模型幻觉导致的「插入」（添加原文没有的词）以及因噪声过大导致的「删除」（遗漏词语）。</li></ul><p>(@ai-coustics Blog)</p><h2>02 有亮点的产品</h2><p><strong>1、ChatGPT 将语音功能无缝集成至聊天界面内</strong></p><p>OpenAI 于周二宣布，将对旗下备受欢迎的 AI 聊天机器人 ChatGPT 的用户界面进行优化，将语音功能无缝集成至聊天界面内。这意味着用户无需再切换至独立的语音模式，即可在与 ChatGPT 对话的同时，实时查看其文字回复，甚至包括共享的图片等视觉内容。</p><p>在此前的版本中，启用语音模式会将用户带入一个独立的界面，通过一个代表 ChatGPT 语音交互的蓝色动画圆圈进行操作。该界面还提供了静音、录制视频以及返回文本模式的关闭选项。然而，在此模式下，用户只能通过语音听取 ChatGPT 的回复，一旦错过关键信息，就需要退出语音模式才能在屏幕上查看文本，这种体验难免会带来不便。</p><p>现在，这一痛点已得到解决。OpenAI 表示，更新后的 ChatGPT 语音模式支持边听边看。用户可以一边与 AI 对话，一边实时查看其针对问题的回答。此外，用户还能在对话过程中轻松回顾历史消息，并实时浏览如图片或地图等视觉化内容。</p><p>此次改进显著提升了与 AI 聊天机器人的交互自然度，使得用户可以在同一对话中更顺畅地切换语音和文本模式。不过，当用户准备切换回纯文本交流时，仍需点击「结束」按钮来终止语音对话。</p><p>这项全新的默认语音模式目前已开始向所有网页端和移动应用用户逐步推出。</p><p>对于仍偏好原有独立语音模式的用户，OpenAI 提供了恢复选项。用户可以在「设置」中的「语音模式」下找到「独立模式」选项，并将其开启，以保留之前的操作体验。</p><p>( @Techrunch)</p><p><strong>2、Speechify Chrome 扩展新增语音输入与语音助手，抢占「语音优先」AI 交互市场</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431971" alt="" title="" loading="lazy"/></p><p>Speechify 宣布为其 Chrome 扩展新增语音输入（Voice Typing）和语音助手（Voice Assistant）功能。此举旨在抓住语音识别技术崛起的机遇，为用户提供「语音优先」的 AI 交互体验，挑战以文本为主的现有主流 LLM 应用。</p><ul><li>语音输入功能： Speechify 推出了支持英文的语音输入工具，可纠正错误并移除填充词，旨在提高用户在网页上的输入效率。</li><li>侧边栏语音助手： 新增的对话式语音助手集成在浏览器侧边栏，可直接询问关于当前网页内容的问题，如「提炼核心观点」或「用更简单的语言解释」。</li><li>「语音优先」定位： Speechify 强调，与 ChatGPT 和 Gemini 等应用将语音视为次要功能不同，其工具将语音置于核心地位，满足用户「语音即默认设置」的需求。</li><li>模型学习与优化： 语音输入的准确性初期或有不足，但 Speechify 表示模型会通过用户使用不断学习和优化。同时，正在逐步为 WordPress 等流行网站进行适配优化。</li><li>未来智能体愿景： Speechify 透露未来计划开发能代表用户完成任务的智能体，例如代为安排预约或处理客服等待。</li></ul><p>( @TechCrunch)</p><p><strong>3、Character.AI 推出「Stories」功能，限制未成年用户使用开放式聊天机器人</strong></p><p>Character.AI 近期宣布推出名为「Stories」的新功能，旨在提供一种交互式虚构内容创作体验，以此作为对 18 岁以下用户开放式聊天机器人访问限制的替代方案。此举是在对 AI 聊天机器人可能产生的心理健康风险和相关法律诉讼的担忧日益加剧的背景下做出的。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431972" alt="" title="" loading="lazy"/></p><ul><li>「Stories」功能： Character.AI 推出的「Stories」，是一种允许用户与喜爱的角色一起创作互动式虚构故事的新模式。</li><li>限制未成年用户访问： 自本周起，18 岁以下用户将无法再使用 Character.AI 的开放式聊天机器人功能，该功能已逐步被限制。</li><li>安全优先的替代方案： 公司表示，「Stories」提供了一种「引导式的方式来创作和探索虚构内容，替代了开放式聊天」，并与其他多模态功能一起，为青少年提供一个「安全至上」的互动环境。</li><li>行业趋势与法律监管： 此举与当前交互式虚构内容日益增长的受欢迎程度相符，同时也呼应了加州和美国参议院在 AI 伴侣监管方面的动向。</li></ul><p>Character.AI 的这一转变，不仅是对用户安全和法律风险的积极回应，也可能为行业内其他 AI 伴侣平台如何处理未成年用户交互树立一个「安全优先」的标杆。通过从开放式、可能产生依赖的聊天模式转向结构化的内容创作，Character.AI 试图在保持用户参与度和规避潜在风险之间找到平衡。</p><p>( @TechCrunch)</p><p><strong>4、华为试水陪伴：399 元，毛绒绒的 AI</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431973" alt="" title="" loading="lazy"/></p><p>据「多知」报道，11 月 25 日下午，华为在新品发布会上官宣智能陪伴机器人新品「智能憨憨」，这也是其第一款 AI 陪伴玩偶。</p><p>智能憨憨售价 399 元，有灰色、黄色、蓝色三款，将于 11 月 28 日正式发售。</p><p>根据华为商城信息，智能憨憨与市面上很多 AI 玩具一样，同样被设计了宇宙观。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431974" alt="" title="" loading="lazy"/></p><p>实际功能上，智能憨憨与市面上同类型产品的功能也基本相近，多模态交互、有记忆力陪伴共同成长。其中：</p><p>用户通过「你好憨憨」、「你好鸿蒙」即可唤醒对话；</p><p>用户可以通过触摸引发互动，摸下憨憨的额头，其会给予不同的表情反应，晃动憨憨，其还会兴奋发抖；</p><p>用户留下的内容都会形成憨憨的记忆，并会在移动端形成日记；</p><p>与市面上同类型 AI 陪伴产品最大的不同，是其搭载了华为小艺大模型和适配鸿蒙系统。</p><p>26 日下午，Robopoet 珞博智能在公众号也表示：「Fuzozo 芙崽和『憨憨』定制合作款于 11 月 25 日在华为 Mate80 系列发布会正式亮相。这只圆滚滚的智能憨憨由珞博与华为共同设计开发」，「未来，芙崽将持续开放品牌联名合作，让芙崽家族不断壮大，交到更多好朋友，走进更多人的日常生活。」</p><p>（@多知、@Robopoet 珞博智能）</p><p><strong>5、李想：理想不会造手机，将发布智能眼镜</strong></p><p>11 月 25 日晚，理想汽车创始人李想在 B 站更新了视频。李想表示，理想不会造手机，但会推出一些生态化的产品，包括智能眼镜。在李想看来，智能眼镜是理想汽车最好的人工智能的一个附件。</p><p>其实，早在去年秋季的战略会上，理想管理层已经讨论过自研智能眼镜的必要性和可行性。今年 6 月，理想成立了「穿戴机器人」新部门，理想自研智能眼镜或许将出自该部门之手。此外，李想还提到，智能音箱也在理想的考虑之内，希望理想的 AI 能力能够在理想汽车的用户生活中，有一个更全面的覆盖。</p><p>（@快科技）</p><h2>03 有态度的观点</h2><p><strong>1、阿里巴巴 CEO：至少三年内，AI 泡沫是不太存在的</strong></p><p>昨日，阿里巴巴集团公布 2026 财年第二季度业绩。财报显示，<strong>集团营收达 2，478.0 亿元，同比增长 4.8%，略高于市场预估的 2,452 亿元</strong>；调整后每 ADS 收益为 4.36 元，低于预估的 6.34 元。同期调整后净利润为 103.5 亿元，亦低于市场预期的 168 亿元。</p><p>而在阿里财报发布后的电话会上，阿里巴巴 CEO 吴泳铭如此表示，<strong>「至少三年内，AI 泡沫是不太存在的。」</strong>他提到阿里云 AI 服务器等上架节奏严重跟不上客户需求，在手订单仍在进一步增加。</p><p>( @APPSO)</p><p><strong>2、AI 教育公司创始人：未来一对一 AI 教学将成主流</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431975" alt="" title="" loading="lazy"/></p><p>据《智能涌现》报道，「与爱为舞」联合创始人兼 COO 刘威近日在接受采访时表示，AI 教育与传统在线教育的核心逻辑存在本质差异。</p><p>他将在线教育比喻为「农业」，依赖教师规模扩张；而 AI 教育则是「科技」，竞争壁垒来自技术突破而非人力堆叠。<strong>刘威强调，一对一教学将在 AI 时代成为主流，效果和效率天然优于大班课。</strong><em>*</em>*</p><p>他指出，AI 大模型的泛化性与自主学习机制，使得个性化教学成为可能。任何一个老师再优秀，孩子才是学习的主体，教师无法保证成绩一定提升。过度承诺提分幅度并不负责任。</p><p>刘威表示，AI 教育的价值在于提升学习过程的稳定性与效率，而非单一分数指标。在用户接受度方面，刘威透露，「爱学」在盲测中表现出较高的完课率，甚至超过真人大班课。家长与学生在得知教师为 AI 后，退课率几乎为零，付费率也高于传统模式。</p><p>他认为，随着 AI 技术的快速发展，家长对 AI 教育的接受度正在提升，未来一对一 AI 教学将逐渐取代大班课。刘威还指出，AI 教育的战略不应局限于某一人群或学科，而是具备全人群覆盖与多语言扩展能力。他表示，AI 技术能够抹平不同年龄段与学科的差异，未来产品迭代将更快、更广。</p><p>「与爱为舞」由前百度凤巢核心负责人张怀亭与刘威共同创立，成立两年半，估值已接近 10 亿美元，并完成 4 轮融资，累计融资额约 1.5 亿美元。</p><p>公司核心研发方向包括 AI 数字人教师、音视频实时对话式 AI 教育模型及智能交互语音模型。其自研语音系统识别准确率达 95%，响应速度达到毫秒级。</p><p>( @APPSO)</p><h2>04 社区黑板报</h2><p>招聘、项目分享、求助……任何你想和社区分享的信息，请联系我们投稿。（加微信 creators2022，备注「社区黑板报」）</p><p><strong>1、湃启（PatchX）招聘 Go 语言高级开发工程师、语音对话推荐算法工程师和视觉算法工程师 （机器人/端侧部署方向）</strong></p><p>浙江湃启（PatchX）科技有限公司，致力于人工智能情感计算与具身智能技术的深度融合与创新应用。我们以「PatchX，给心灵打个补丁」为理念，核心使命是探索并实现人工智能从功能工具向情感伙伴的范式跃迁，让科技具备感知、理解并响应人类情感的能力，从而温暖心灵。我们专注于研发和推广前沿 AI 陪伴、潮玩设计、游戏化体验及具身智能的硬件产品，为儿童、年轻人群及独居者等提供具有深度情感价值的陪伴与互动体验，目标是成为全球 AI 情感交互技术及硬件载体的引领者。</p><p>更多介绍和岗位：</p><p><a href="https://link.segmentfault.com/?enc=%2BWgI4BDFvLyeK%2BsuKSY1eg%3D%3D.sjNnTkkBMQMWXS4iLPi%2F5n2Xl8X0vOZM%2FjIE9EV8MiwRLBm8RDb4NASCYkvLVedpq9V0XiOepmsS7G%2BTG5cP6%2FJDGy0CyOySRJX0hFDAIJ4Umxtd0dffbaHBttFGD02P" rel="nofollow" target="_blank">https://www.zhipin.com/gongsi/6b8af1e0a48236b803V939u7GVI~.ht...</a></p><p>联系方式：</p><p>邮箱：info\@patch-x.com</p><p>微信：armorse2023</p><ol><li><strong>Go 语言高级开发工程师</strong></li></ol><p>作为 AI 机器人后端团队的核心成员，将负责设计和开发支撑我们机器人集群的核心服务平台。面临的挑战是构建高并发、低延迟、高可用的分布式系统，以处理机器人产生的实时数据流，并为 AI 模型推理、任务调度和设备管理提供强大动力。</p><p>任职要求详见：</p><p><a href="https://link.segmentfault.com/?enc=H6w7%2BlrLzFG1ChebjIkdDQ%3D%3D.FOUqzPQskPACPnID0APJ6psPzp31CyytH2D0sG5AZvKba2lYB0qEwiQ7jt6SLDwaUaOjBUNoWMwTzprHny3jHFacVDBuSJtM9rsYnOa%2FmLU%3D" rel="nofollow" target="_blank">https://www.zhipin.com/job_detail/4c436a44425d7c3303x639m_F1V...</a></p><ol start="2"><li><strong>语音对话推荐算法工程师</strong></li></ol><ul><li>负责语音对话推荐系统的研发，基于对话内容与历史交互数据，构建个性化推荐引擎。</li><li>建立用户画像与兴趣偏好建模，提升推荐结果的相关性与多样性。</li><li>优化语音对话场景下的实时推荐延迟与准确率，实现自然流畅的交互体验。</li><li>参与多模态推荐算法研究（语音、语义、情绪信号），提升 AI 陪伴机器人的情感交互能力。</li><li>与产品、硬件和内容团队协作，将推荐算法落地于陪伴机器人和内容平台。</li></ul><p>任职要求详见：</p><p><a href="https://link.segmentfault.com/?enc=kM3RNkpKGqFaFjXs1UgeEA%3D%3D.%2BadpuAYQF0agTL7saIBhakuyLnF29pQXCDywnBGORBYipfGtIC4f4kQ8MFtcZrXw4G%2FwLgVg0mZIgdoWhsBTVj0dpGFsYA1XVxPv2pHEyU8%3D" rel="nofollow" target="_blank">https://www.zhipin.com/job_detail/64cfcec5fc20c85403Ny3927FlN...</a></p><ol start="3"><li><strong>视觉算法工程师 （机器人/端侧部署方向）</strong></li></ol><p>岗位职责：</p><p>1. 核心识别算法开发：</p><p>- 负责室内场景下的目标检测（如 YOLO 系列、Transformer 等）、人脸识别及姿态估计算法的选型、训练与调优。</p><p>- 针对室内复杂光照、遮挡、小物体（如手机、水杯）等难点进行数据增强和模型优化。</p><p>2. 空间感知与建模（核心挑战）：</p><p>- 设计并实现基于单目视觉或 RGB-D（ToF）的旋转全景空间建模算法。</p><p>- 解决机器人旋转过程中的多视角物体去重（Re-ID）、跨帧目标跟踪（MOT）问题，构建以机器人为中心的语义地图（Semantic Compass）。</p><p>3. 深度估计与测距：</p><p>- 研究并落地单目深度估计（Monocular Depth Estimation）或融合 ToF 传感器数据，解决桌面场景下的物体距离感知问题。</p><p>4. 端侧部署与优化：</p><p>- 负责模型在嵌入式平台（如 Rockchip RK 系列、地平线、NVIDIA Jetson 或高通平台）上的移植、量化（Int8）与加速（TensorRT/ONNX Runtime），在有限算力下保证实时性。</p><p>任职要求：</p><p>1. 基础能力： 计算机、自动化、机器人等相关专业本科及以上学历，2 年以上计算机视觉算法落地经验。</p><p>2. 编程与框架： 精通 Python/C++，熟练使用 PyTorch 或 TensorFlow 框架，具备扎实的代码能力。</p><p>3. 算法深度：</p><p>- 深入理解主流目标检测算法（YOLOv5/v8/v11， DETR 等）。</p><p>- 熟悉多目标跟踪算法（DeepSORT， ByteTrack）及 Re-ID 技术。</p><p>4. 几何与空间：</p><p>- 熟悉相机成像原理，了解坐标系转换（像素坐标-相机坐标-世界坐标）。</p><p>- 加分项： 有全景拼接（Stitching）、SLAM（特别是视觉前端 VO）或 3D 点云处理经验者优先。</p><p>5. 工程落地： </p><p>有过在 ARM 架构（树莓派、安卓板卡等）上部署深度学习模型的实际经验，熟悉模型剪枝、蒸馏、量化等轻量化技术。</p><p>加分项：</p><p>- 有智能家居、服务机器人行业从业经验。</p><p>- 熟悉 Depth Anything、MiDaS 等深度估计模型。</p><p>- 了解多模态融合（如视觉 + 麦克风阵列声源定位）的协同逻辑。</p><p>- 有 GitHub 开源项目或顶会论文发表。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431976" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431977" alt="" title="" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=%2BX2Ip0MXH0VnQteFu9Lj7w%3D%3D.l6FZA2NuSISo0BmbhUVJkJsP9jmflEgVoghcrlNBfEY%3D" rel="nofollow" target="_blank">阅读更多 Voice Agent 学习笔记：了解最懂 AI 语音的头脑都在思考什么</a></p><p><strong>写在最后：</strong></p><p>我们欢迎更多的小伙伴参与 <strong>「RTE 开发者日报」</strong> 内容的共创，感兴趣的朋友请通过开发者社区或公众号留言联系，记得报暗号「共创」。</p><p>对于任何反馈（包括但不限于内容上、形式上）我们不胜感激、并有小惊喜回馈，例如你希望从日报中看到哪些内容；自己推荐的信源、项目、话题、活动等；或者列举几个你喜欢看、平时常看的内容渠道；内容排版或呈现形式上有哪些可以改进的地方等。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047431978" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[如何利用工厂大脑实现制造业数字化转型？ ]]></title>    <link>https://segmentfault.com/a/1190000047431992</link>    <guid>https://segmentfault.com/a/1190000047431992</guid>    <pubDate>2025-11-27 12:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当今工业4.0浪潮席卷全球的背景下，制造业正经历一场前所未有的变革，而广域铭岛的工厂大脑解决方案无疑成为了这场转型的核心驱动力。工厂大脑，简而言之，是指为制造企业构建的一种高度智能化系统，它不仅仅是一系列技术工具的组合，更是一种整合了人工智能、大数据分析和物联网（IoT）的工厂中枢，能够动态优化生产流程并推动企业从传统的经验依赖型模式，向数据驱动和认知自动化的新时代跃迁。这种智能体的独特之处在于，它通过多模态数据处理和预测性决策，帮助企业实现运营的实时把控与全局协同。<br/>广域铭岛作为行业先锋，其工厂大脑基于一个创新的“云-边-端”技术架构，深度融合了制造业机理与AI大模型，打造出了一种预定义的数字平台。这不同于传统制造执行系统（MES），后者往往局限于单一的生产执行层面，无法覆盖质量管理、库存管理、设备维护等更广泛的运营哑区。工厂大脑的概念源自广域铭岛的Mom制造运营管理平台，它被视为工厂的“大脑”，而非“执行心脏”，强调了信息整合与智能决策的全局性。例如，在重庆市科技局的一个合作项目中，广域铭岛开发了面向工业物联网的多模态大模型，这一平台不仅能处理结构化数据，还能整合视觉、语音和文本信息，真正实现了全链条的智能监控。<br/>在日常实践中，广域铭岛的工厂大脑通过强大的数据治理能力，打破了信息孤岛的痼疾。管理人员可以实时获取生产数据，并将其转化为可行动的洞察，而非被动等待问题发生。这使得工厂在面对供应链波动或设备故障时，能以更敏捷的方式响应。广域铭岛的妈妈智工厂解决方案，正是通过这种集成化设计，缩短了生产调试周期，并在诸如电池生产这样的精细化领域中，显著降低了物料损耗率，体现了其在降本增效方面的卓越表现。<br/>工厂大脑的落地，已经在中国制造业的多个场景中展现出变革性的力量。以执行型智能体为例，广域铭岛为某电池工厂部署的智能巡检系统，能够自主完成高达98%的常规任务，减少了人工干预的痛点。而在决策型智能体领域，广域铭岛的Mom平台在汽车制造中的应用更是令人惊叹——通过实时调整工艺参数，将焊装工艺优化周期压缩60%，质量缺陷率下降45%。这些成果不仅仅是数字上的突破，更标志着工厂大脑如何将复杂非结构化数据转化为生产力。<br/>广域铭岛的创新精神还体现在其模块化设计上，工厂大脑的架构允许企业像积木一样组装不同的智能组件，使其适应从离散型到连续型生产环境的多变需求。这种灵活性在广域铭岛自身实践中得到了验证，无论是作为运营决策的加强层，还是作为AI演进的基石，工厂大脑都在推动制造企业迈向“系统智能”时代，这一点尤其关键。<br/>尽管工厂大脑带来了诸多好处，但其发展仍未完全成熟。数据壁垒、核心部件国产化不足以及复合型人才短缺等问题，如同阴影般潜伏在转型之路。广域铭岛深知，要在未来竞争中主导工厂大脑的演进，必须携手产业链伙伴。例如，在供应链中断应急案例中，广域铭岛的平台仅需5分钟即可协调并完成响应流程，这得益于其对12类智能体的标准化整合。展望未来，广域铭岛计划继续深化合作，进一步拓展工厂大脑至生态扩展阶段，实现多智能体协同，为中国从“制造大国”到“智造强国”的跨越铺路。<br/>总之，广域铭岛的工厂大脑不仅是技术上的突破，更是生产理念的革新。它正在加速制造业的转型，帮助企业实现可持续的增长模式，从提高单独环节效率的传统MES阶段，进化为注重预测优化、全局协同的全新时代。工厂，作为一个曾经由机械驱动的核心实体，如今正被赋予智能的灵魂，而这正是广域铭岛等企业的关键贡献。</p>]]></description></item>  </channel></rss>