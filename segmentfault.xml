<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[WithTheme 自学指南：玩转局部主题和局部深浅色 李游Leo ]]></title>    <link>https://segmentfault.com/a/1190000047550301</link>    <guid>https://segmentfault.com/a/1190000047550301</guid>    <pubDate>2026-01-19 00:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在 ArkUI 里，做<strong>主题</strong>和平时做<strong>样式</strong>是两件事：</p><ul><li>样式：某个组件单独改 <code>fontColor</code>、<code>backgroundColor</code>；</li><li>主题：一整块区域里的组件，<strong>整体按一套规则变色</strong>。</li></ul><p>从 <strong>API Version 12</strong> 开始，ArkUI 提供了一个专门做「局部主题」的组件：<code>WithTheme</code>。<br/>它不负责画 UI，只负责一件事：<strong>给作用域里的组件套一层主题/深浅色规则</strong>。</p><p>这篇文章就是一份可以直接上手的 <strong>WithTheme 自学指南</strong>，适合发社区、做笔记或带项目里落地。</p><hr/><h2>一、WithTheme 是什么？</h2><p>官方定义很简单：</p><ul><li><code>WithTheme</code> 是一个<strong>主题作用域容器</strong>；</li><li>只接受<strong>一个子组件</strong>（可以是 <code>Column</code> / <code>Row</code> / 自定义组件）；</li><li><p>只负责两件事：</p><ul><li>配置这一块区域用哪套 <strong>自定义主题颜色</strong>（<code>theme</code>）；</li><li>控制这一块区域的 <strong>深色 / 浅色模式</strong>（<code>colorMode</code>）。</li></ul></li></ul><p>基础信息：</p><ul><li><strong>支持版本</strong>：从 API Version 12 开始；</li><li><strong>系统能力</strong>：<code>SystemCapability.ArkUI.ArkUI.Full</code>；</li><li><strong>元服务</strong>：从 API 12 开始支持元服务 API；</li><li><strong>不支持通用属性、不支持通用事件</strong>（它只是“包裹容器”，样式写在子组件上）。</li></ul><hr/><h2>二、WithTheme 能影响哪些组件？</h2><p>不是所有组件都会响应 WithTheme，这点很关键。当前支持的系统组件包括：</p><ul><li>输入类：<code>TextInput</code>、<code>Search</code></li><li>按钮 &amp; 徽标：<code>Button</code>、<code>Badge</code>、<code>Counter</code></li><li>轮播 &amp; 选择类：<code>Swiper</code>、<code>Select</code>、<code>Menu</code></li><li>文本类：<code>Text</code></li><li><p>选择器类：</p><ul><li><code>TimePicker</code>、<code>DatePicker</code>、<code>TextPicker</code></li><li><code>Checkbox</code>、<code>CheckboxGroup</code>、<code>Radio</code></li><li><code>Slider</code></li></ul></li><li><p>状态展示类：</p><ul><li><code>Progress</code>、<code>Toggle</code>、<code>PatternLock</code>、<code>QRCode</code></li></ul></li><li>分隔类：<code>Divider</code></li></ul><blockquote>简单记：表单控件 + 按钮 + 文本 + 分隔线，大部分能跟着 WithTheme 一起变。</blockquote><hr/><h2>三、核心接口与配置项</h2><h3>3.1 WithTheme 基本接口</h3><pre><code class="ts">WithTheme(options: WithThemeOptions) {
  // 只能有一个子组件
  // 这个子组件里面可以再写 Column/Row/自定义组件
}</code></pre><blockquote>注意：WithTheme <strong>不支持通用属性和通用事件</strong>，需要把布局、点击等逻辑写在内部组件上。</blockquote><h3>3.2 WithThemeOptions 结构</h3><pre><code class="ts">interface WithThemeOptions {
  theme?: CustomTheme        // 自定义主题配色
  colorMode?: ThemeColorMode // 深浅色模式
}</code></pre><ul><li><p><code>theme?: CustomTheme</code></p><ul><li>用于指定 WithTheme 作用域内组件的<strong>缺省配色</strong>；</li><li>默认：<code>undefined</code>，表示跟随系统 token 默认样式。</li></ul></li><li><p><code>colorMode?: ThemeColorMode</code></p><ul><li>控制作用域内组件的<strong>深色/浅色模式</strong>；</li><li>默认：<code>ThemeColorMode.SYSTEM</code>（跟随系统）。</li></ul></li></ul><h3>3.3 CustomTheme 类型</h3><pre><code class="ts">type CustomTheme = CustomTheme</code></pre><ul><li><code>CustomTheme</code> 实际上是一个接口；</li><li>搭配 <code>CustomColors</code> 一起使用，用来描述一整套颜色体系（比如一套绿色主题、一套红色主题）。</li></ul><hr/><h2>四、局部深浅色：colorMode 实战</h2><p>很多页面希望做到：</p><ul><li>整体跟随系统；</li><li>但某一块区域 <strong>强制深色</strong>（比如顶部 Banner）或 <strong>强制浅色</strong>（比如活动卡片）。</li></ul><p>这时可以用 <code>WithTheme</code> 搭配 <code>colorMode</code>。</p><h3>4.1 深浅色资源准备：dark.json</h3><p><img width="498" height="244" referrerpolicy="no-referrer" src="/img/bVdnGah" alt="image.png" title="image.png"/></p><p>要让深浅色生效，先准备深色资源文件 <code>dark.json</code>，例如：</p><pre><code class="json">{
  "color": [
    {
      "name": "start_window_background",
      "value": "#000000"
    }
  ]
}</code></pre><h3>4.2 示例：同一页面展示默认、Dark、Light 三种区域</h3><p><img width="636" height="1236" referrerpolicy="no-referrer" src="/img/bVdnGak" alt="image.png" title="image.png" loading="lazy"/></p><pre><code class="ts">@Entry
@Component
struct Index {
  build() {
    Column() {
      // ① 系统默认区域
      Column() {
        Text('无WithTheme')
          .fontSize(40)
          .fontWeight(FontWeight.Bold)
      }
      .justifyContent(FlexAlign.Center)
      .width('100%')
      .height('33%')
      .backgroundColor($r('app.color.start_window_background'))

      // ② 局部强制深色模式
      WithTheme({ colorMode: ThemeColorMode.DARK }) {
        Column() {
          Text('WithTheme')
            .fontSize(40)
            .fontWeight(FontWeight.Bold)
          Text('DARK')
            .fontSize(40)
            .fontWeight(FontWeight.Bold)
        }
        .justifyContent(FlexAlign.Center)
        .width('100%')
        .height('33%')
        .backgroundColor($r('sys.color.background_primary'))
      }

      // ③ 局部强制浅色模式
      WithTheme({ colorMode: ThemeColorMode.LIGHT }) {
        Column() {
          Text('WithTheme')
            .fontSize(40)
            .fontWeight(FontWeight.Bold)
          Text('LIGHT')
            .fontSize(40)
            .fontWeight(FontWeight.Bold)
        }
        .justifyContent(FlexAlign.Center)
        .width('100%')
        .height('33%')
        .backgroundColor($r('sys.color.background_primary'))
      }
    }
    .height('100%')
    .expandSafeArea(
      [SafeAreaType.SYSTEM],
      [SafeAreaEdge.TOP, SafeAreaEdge.END, SafeAreaEdge.BOTTOM, SafeAreaEdge.START]
    )
  }
}</code></pre><p><strong>使用建议：</strong></p><ul><li>想让某个模块始终深色：<code>WithTheme({ colorMode: ThemeColorMode.DARK })</code>；</li><li>想让底部工具条固定浅色：<code>ThemeColorMode.LIGHT</code>；</li><li>根节点跟系统，局部区域用 WithTheme 做反色/特殊效果，是比较推荐的实践。</li></ul><hr/><h2>五、自定义主题：CustomTheme + CustomColors 实战</h2><p>除了深浅色，有时我们希望<strong>整块区域用一套品牌色</strong>，比如「绿色主题卡片」vs「红色活动卡片」。</p><p>这时用 <code>CustomTheme</code> 来定义一套颜色，然后交给 <code>WithTheme</code>。</p><h3>5.1 定义颜色集合 CustomColors</h3><pre><code class="ts">import { CustomTheme, CustomColors } from '@kit.ArkUI';

class GreenColors implements CustomColors {
  fontPrimary = '#ff049404';
  fontEmphasize = '#FF00541F';
  fontOnPrimary = '#FFFFFFFF';
  compBackgroundTertiary = '#1111FF11';
  backgroundEmphasize = '#FF00541F';
  compEmphasizeSecondary = '#3322FF22';
}

class RedColors implements CustomColors {
  fontPrimary = '#fff32b3c';
  fontEmphasize = '#FFD53032';
  fontOnPrimary = '#FFFFFFFF';
  compBackgroundTertiary = '#44FF2222';
  backgroundEmphasize = '#FFD00000';
  compEmphasizeSecondary = '#33FF1111';
}</code></pre><blockquote>实际项目里可以按照设计给的 token 表来映射，保持命名和 UI 视觉规范一致。</blockquote><h3>5.2 封装成 CustomTheme</h3><pre><code class="ts">class PageCustomTheme implements CustomTheme {
  colors?: CustomColors

  constructor(colors: CustomColors) {
    this.colors = colors
  }
}</code></pre><h3>5.3 使用 WithTheme 控制局部主题</h3><p>下面这个例子展示了一个典型的用法：<br/>上半部分使用<strong>系统默认按钮配色</strong>；<br/>下半部分被 WithTheme 包裹，使用<strong>可切换的自定义主题</strong>。</p><pre><code class="ts">@Entry
@Component
struct IndexPage {
  static readonly themeCount = 3;

  themeNames: string[] = ['System', 'Custom (green)', 'Custom (red)'];

  themeArray: (CustomTheme | undefined)[] = [
    undefined,                              // 系统默认主题
    new PageCustomTheme(new GreenColors()), // 绿色主题
    new PageCustomTheme(new RedColors())    // 红色主题
  ]

  @State themeIndex: number = 0;

  build() {
    Column() {
      // 区域一：未使用 WithTheme，系统默认配色
      Column({ space: '8vp' }) {
        Text('未使用WithTheme')

        // 点击切换下方 WithTheme 的配色
        Button(`切换theme配色：${this.themeNames[this.themeIndex]}`)
          .onClick(() =&gt; {
            this.themeIndex = (this.themeIndex + 1) % IndexPage.themeCount;
          })

        // 系统默认按钮配色
        Button('Button.style(NORMAL) with System Theme')
          .buttonStyle(ButtonStyleMode.NORMAL)
        Button('Button.style(EMP..ED) with System Theme')
          .buttonStyle(ButtonStyleMode.EMPHASIZED)
        Button('Button.style(TEXTUAL) with System Theme')
          .buttonStyle(ButtonStyleMode.TEXTUAL)
      }
      .margin({ top: '50vp' })

      // 区域二：使用 WithTheme，局部换肤
      WithTheme({ theme: this.themeArray[this.themeIndex] }) {
        Column({ space: '8vp' }) {
          Text('使用WithTheme')
          Button('Button.style(NORMAL) with Custom Theme')
            .buttonStyle(ButtonStyleMode.NORMAL)
          Button('Button.style(EMP..ED) with Custom Theme')
            .buttonStyle(ButtonStyleMode.EMPHASIZED)
          Button('Button.style(TEXTUAL) with Custom Theme')
            .buttonStyle(ButtonStyleMode.TEXTUAL)
        }
        .width('100%')
      }
    }
  }
}</code></pre><p><strong>效果：</strong></p><ul><li>上半部分：始终采用系统默认主题；</li><li>下半部分：随着按钮点击，在 System / Green / Red 三种主题间切换；</li><li>完全局部生效，不影响其他页面和组件。</li></ul><hr/><h2>六、常见使用场景</h2><p>结合上面的能力，WithTheme 很适合这些场景：</p><ol><li><p><strong>局部夜间模式</strong></p><ul><li>例如：播放器底部控制条、评论区、侧边栏等；</li><li>根页面跟系统，某个区域用深色：</li></ul><pre><code class="ts">WithTheme({ colorMode: ThemeColorMode.DARK }) {
  // 播放控制区 / 评论列表
}</code></pre></li><li><p><strong>卡片级换肤 / 品牌卡片</strong></p><ul><li>营销活动卡片、会员卡片、小程序入口等：</li></ul><pre><code class="ts">WithTheme({ theme: new PageCustomTheme(new GreenColors()) }) {
  // 活动卡片 / 会员卡片布局
}</code></pre></li><li><p><strong>表单区域统一风格</strong></p><ul><li>一个复杂表单里用到 Button / TextInput / Checkbox / Slider 等：</li><li>全部丢在 WithTheme 里，做一套专门的表单主题。</li></ul></li><li><p><strong>多主题 Demo / 设置页</strong></p><ul><li>设置页里提供「主题预览」；</li><li>上方一个切换按钮，下面用了多个 WithTheme 区块分别展示效果。</li></ul></li></ol><hr/><h2>七、容易踩的点 &amp; 调试建议</h2><ol><li><p><strong>子组件只能一个</strong></p><ul><li>WithTheme 的子节点只能是一个组件；</li><li>如果有多个，请用 <code>Column</code>/<code>Row</code>/自定义组件包一层。</li></ul></li><li><p><strong>不是所有组件都响应主题</strong></p><ul><li>自绘组件（Canvas、Shape 等）不会自动跟主题；</li><li>自定义组件如果内部没用系统控件，也看不到效果。</li></ul></li><li><p><strong>内部写死颜色会覆盖部分主题</strong></p><ul><li>比如你在 Button 上手动设置了 <code>backgroundColor('#FF0000')</code>；</li><li>这可能会盖住主题里本来给它配置的一些颜色表现；</li><li>建议：尽量用 <code>buttonStyle</code>、<code>fontColor</code> + 主题，让主题主导，而不是全部手写 Hex。</li></ul></li><li><p><strong>深浅色看起来没变化？</strong></p><ul><li>检查是否已经配置 <code>dark.json</code> 等资源；</li><li>检查是不是本身背景就接近黑/白，导致肉眼不明显；</li><li>可以临时多放一些 <code>Text</code> / <code>Button</code> 观察效果。</li></ul></li></ol><hr/><h2>八、总结</h2><p><code>WithTheme</code> 的定位可以一句话概括：</p><blockquote><strong>内外解耦：全局主题搞整体，WithTheme 专门做“局部换肤 + 局部深浅色”。</strong></blockquote><p>掌握它之后，你可以在 ArkUI 里轻松实现：</p><ul><li>某一块区域固定深色 / 浅色；</li><li>某类卡片、一段区域统一走品牌主题色；</li><li>在一个页面里同时展示多套主题效果，而不影响全局。</li></ul>]]></description></item><item>    <title><![CDATA[个人使用的接口文档 哈哇哇哈哈哈哇 ]]></title>    <link>https://segmentfault.com/a/1190000047550192</link>    <guid>https://segmentfault.com/a/1190000047550192</guid>    <pubDate>2026-01-18 23:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>1. 文档概述</h2><h3>1.1 文档目的</h3><p>本文档为[系统名称]接口的标准沟通文档，旨在XXX。</p><h3>1.2 文档修订记录</h3><table><thead><tr><th>修订版本</th><th>修订时间</th><th>修订人</th><th>修订内容</th></tr></thead><tbody><tr><td>V1.0</td><td>2024-01-01</td><td>[姓名]</td><td>初始版本，完成用户管理模块核心接口编写</td></tr></tbody></table><h3>1.3 接口通用规则</h3><h4>1.3.1 基础URL</h4><table><thead><tr><th>环境类型</th><th>基础URL前缀</th><th>使用说明</th></tr></thead><tbody><tr><td>开发环境</td><td><a href="https://link.segmentfault.com/?enc=ar6Z2AxbKhQfPPtK1RJphQ%3D%3D.dPnpbgYLjuUDQJgoizS35w%3D%3D" rel="nofollow" target="_blank">http://dev-</a>[系统域名]/api/v1</td><td>供开发人员日常开发、调试使用</td></tr><tr><td>测试环境</td><td><a href="https://link.segmentfault.com/?enc=40myAaLQ%2Fv4phnfOGgB9Yw%3D%3D.xkVsTM3dKlZyGoTjtxka2w%3D%3D" rel="nofollow" target="_blank">http://test-</a>[系统域名]/api/v1</td><td>供测试人员执行功能测试、集成测试使用</td></tr><tr><td>预发布环境</td><td><a href="https://link.segmentfault.com/?enc=MGL0vRycT68av1EDTd10WQ%3D%3D.gqXSXiiaKjKFZO3w1F2CSQ%3D%3D" rel="nofollow" target="_blank">https://uat-</a>[系统域名]/api/v1</td><td>模拟生产环境配置，用于上线前用户最终验证</td></tr><tr><td>生产环境</td><td>https://[系统域名]/api/v1</td><td>正式对外提供服务的环境，需严格控制访问权限</td></tr></tbody></table><h4>1.3.2 数据与编码规范</h4><ul><li>数据格式：请求/响应默认均为JSON格式，请求头需指定Content-Type: application/json</li><li>编码格式：统一采用UTF-8编码，避免出现乱码问题</li></ul><h2>2. 接口详细说明</h2><h3>2.1 接口列表总览</h3><table><thead><tr><th>接口名称</th><th>接口路径</th><th>请求方法</th><th>核心功能</th></tr></thead><tbody><tr><td>用户认证</td><td>/auth/login</td><td>POST</td><td>用户通过账号密码获取访问令牌（Token）</td></tr></tbody></table><h3>2.2 用户认证接口（/auth/login）</h3><h4>2.2.1 接口基础信息</h4><p>功能描述：用户通过输入账号、密码及验证码完成身份校验，校验通过后获取访问令牌（Token）和刷新令牌，访问令牌用于后续接口调用的身份认证。</p><ul><li>接口路径：/auth/login</li><li>请求方法：POST</li><li>认证方式：无（无需携带Token）</li></ul><h4>2.2.2 请求头参数</h4><table><thead><tr><th>字段名</th><th>字段值</th><th>是否必填</th><th>说明</th></tr></thead><tbody><tr><td>Content-Type</td><td>application/json</td><td>是</td><td>指定请求数据格式为JSON</td></tr></tbody></table><h4>2.2.3 请求参数（Body）</h4><table><thead><tr><th>字段名</th><th>类型</th><th>是否必填</th><th>描述</th><th>格式要求</th></tr></thead><tbody><tr><td>username</td><td>string</td><td>是</td><td>用户账号</td><td>长度为4-20位，支持字母、数字及下划线</td></tr><tr><td>password</td><td>string</td><td>是</td><td>用户密码</td><td>长度为8-20位，需包含大小写字母、数字及特殊字符</td></tr><tr><td>captcha</td><td>string</td><td>是</td><td>验证码</td><td>长度为4位，区分大小写，需与前端展示的验证码一致</td></tr></tbody></table><p>请求示例：</p><pre><code class="json">
{
  "username": "admin",
  "password": "Admin@123456",
  "captcha": "8FzQ"
}</code></pre><h4>2.2.4 响应参数</h4><h5>2.2.4.1 成功响应</h5><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th><th>补充说明</th></tr></thead><tbody><tr><td>code</td><td>integer</td><td>业务成功码</td><td>固定为200，表示业务处理成功</td></tr><tr><td>message</td><td>string</td><td>响应信息描述</td><td>成功时默认返回"登录成功"</td></tr><tr><td>data</td><td>object</td><td>响应数据主体</td><td>包含认证相关的令牌信息</td></tr><tr><td>data.token</td><td>string</td><td>访问令牌</td><td>有效时长为2小时，后续接口调用需携带此令牌</td></tr><tr><td>data.refreshToken</td><td>string</td><td>刷新令牌</td><td>有效时长为7天，用于访问令牌过期后刷新获取新令牌</td></tr></tbody></table><h5>2.2.4.2 错误响应</h5><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th><th>补充说明</th></tr></thead><tbody><tr><td>code</td><td>integer</td><td>业务错误码</td><td>不同错误场景对应不同的错误码，具体参考第3章节状态码说明</td></tr><tr><td>message</td><td>string</td><td>错误信息</td><td>明确提示错误原因，便于问题排查</td></tr><tr><td>data</td><td>object</td><td>错误响应体</td><td>错误场景下通常为null</td></tr></tbody></table><p>成功响应示例：</p><pre><code class="json">{
  "code": 200,
  "message": "登录成功",
  "data": {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"
  }
}</code></pre><p>错误响应示例：</p><pre><code class="json">{
  "code": 4001,
  "message": "账号或密码错误",
  "data": null
}</code></pre><h2>3. 状态码说明</h2><p>本文档中状态码分为业务状态码（接口响应中的code字段）和HTTP状态码，本章节主要说明业务状态码的含义及对应解决方案。</p><table><thead><tr><th>状态码</th><th>错误类型</th><th>错误描述</th><th>解决方案</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td>业务处理成功</td><td>无需处理，正常后续流程即可</td></tr><tr><td>400</td><td>参数错误</td><td>请求参数缺失、格式错误或不符合校验规则（具体见错误信息）</td><td>根据错误信息提示，按接口请求参数要求修正参数格式、补充缺失参数</td></tr><tr><td>401</td><td>认证错误</td><td>未携带认证令牌、令牌已过期或令牌无效</td><td>重新调用登录接口获取有效令牌，在请求头中添加Authorization字段（格式：Bearer [Token]）</td></tr><tr><td>403</td><td>权限错误</td><td>当前用户无该接口的访问权限</td><td>联系系统管理员申请对应接口的访问权限，权限开通后再进行调用</td></tr><tr><td>404</td><td>资源错误</td><td>接口路径不存在或请求的资源不存在</td><td>核查接口路径是否与文档一致，确认请求的资源标识（如用户ID）是否有效</td></tr><tr><td>500</td><td>系统错误</td><td>服务器内部错误，无法正常处理请求</td><td>记录完整的错误响应信息（含请求参数、时间戳），联系后端开发人员排查问题</td></tr></tbody></table><h2>4. 附录</h2><h3>4.1 数据类型说明</h3><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>string</td><td>字符串类型</td></tr><tr><td>integer</td><td>整数类型</td></tr><tr><td>long</td><td>长整数类型</td></tr><tr><td>boolean</td><td>布尔类型识</td></tr><tr><td>object</td><td>对象类型</td></tr><tr><td>array</td><td>数组类型</td></tr></tbody></table>]]></description></item><item>    <title><![CDATA[《跨越异构鸿沟：Python与WebAssembly集成的ABI核心挑战深度解析》 程序员阿伟 ]]></title>    <link>https://segmentfault.com/a/1190000047550124</link>    <guid>https://segmentfault.com/a/1190000047550124</guid>    <pubDate>2026-01-18 22:02:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Python的动态类型特质与WebAssembly的静态二进制本质，在系统接口层面形成了天然的张力，而ABI作为两者沟通的底层桥梁，其挑战远非简单的接口适配所能概括。在边缘计算与无服务器场景的实践中，这种张力尤为明显：Python依赖的动态类型推断、垃圾回收机制，与WebAssembly的线性内存模型、静态类型约定在语义层面存在深刻分歧，而ABI作为连接这两种异构体系的关键，必须在类型映射、内存访问、调用约定等核心维度实现无缝衔接，否则便会出现看似兼容实则逻辑断裂的隐性障碍。这种障碍并非表层的功能失效，而是底层语义的错位——当Python的对象模型试图通过ABI穿透到WebAssembly的线性内存时，类型标识的模糊、内存所有权的界定、生命周期的同步，都会成为难以逾越的深层博弈点。比如在物联网设备的边缘计算场景中，Python处理的传感器动态数据流，需要通过ABI传递给Wasm模块进行高效计算，此时Python对象的动态属性可能在转换过程中丢失语义，而Wasm的线性内存无法动态适配对象的伸缩，导致数据结构出现隐性错乱。更隐蔽的是，当Python的垃圾回收机制触发时，可能误回收仍被Wasm模块引用的内存块，而Wasm对内存的手动释放也可能导致Python侧出现悬垂引用，这种跨环境的生命周期不同步，往往在高并发场景下才会暴露为数据一致性问题，每一个细节的疏忽都可能导致整个集成体系的语义崩塌，这种崩塌往往隐藏在正常运行的表象之下，直到特定场景触发才会暴露其底层的不兼容本质。</p><p>类型语义的对齐缺失是ABI面临的首要核心挑战，这种缺失并非简单的类型不匹配，而是动态与静态类型体系在ABI层面的语义断层。Python中变量的类型可随时变更，对象的创建与销毁由垃圾回收机制自动管理，而WebAssembly的类型系统则是编译期确定的静态结构，每一个数据的内存布局、大小、对齐方式都在编译阶段固定，这种本质差异使得ABI在进行类型映射时，必须面对语义转换的巨大鸿沟。不同的WebAssembly运行时对同一类型的ABI定义可能存在细微偏差，比如Wasmer与Wasmtime在外部引用类型的枚举命名上存在差异，Wasmer将Python的字符串类型映射为“externref_str”，而Wasmtime则命名为“string_externref”，这种看似微小的分歧，导致Python模块在跨运行时迁移时，接口调用会因类型标识不匹配而出现隐性失效，且这种失效往往难以通过常规测试察觉。更复杂的是，Python的复合类型如字典、列表，其内部结构具有动态伸缩性，字典的键值对可能随时增减，列表的元素类型也可混合存储，而WebAssembly的线性内存要求数据必须以连续块的形式存在，且每个元素的类型与大小必须一致，这就要求ABI构建一套复杂的类型转换逻辑。例如，将Python字典转换为Wasm可识别的结构时，不仅需要将键值对按固定顺序排列为连续内存块，还要额外存储键的哈希值与索引映射，以模拟字典的查找特性，这种转换过程中，类型语义的损耗与失真难以避免——Python字典的无序性在转换后可能变为有序结构，而混合类型的列表则需要额外的类型标记字段，这不仅增加了内存开销，还可能导致某些依赖原生语义的操作出现逻辑偏差，如何在转换中保持类型的完整性与行为一致性，成为ABI设计的核心难点。</p><p>内存模型的异构冲突构成了ABI集成的另一重深层障碍，WebAssembly的线性内存与Python的托管内存体系在语义与操作层面存在本质分歧。WebAssembly采用单一连续的线性内存空间，所有数据都存储在这片连续区域中，内存的分配与释放需要严格遵循特定的对齐规则，通常要求数据地址必须是其大小的整数倍，尤其是原子操作对内存对齐的要求更为严苛，任何偏离自然对齐的访问都可能导致CPU指令执行效率骤降，甚至在部分架构下引发隐性的内存访问异常。而Python的内存管理则依赖垃圾回收机制，对象的内存分配由解释器自动处理，内存地址的分配具有随机性，且对象之间可能存在复杂的引用关系，比如循环引用、弱引用等，这种托管式内存模型与WebAssembly的手动内存管理逻辑在ABI层面形成尖锐冲突。当Python对象需要通过ABI传递到WebAssembly环境时，不仅需要将动态分配的对象内存转换为连续的线性内存块，还要处理内存所有权的转移与生命周期的同步——Python的垃圾回收机制无法感知WebAssembly环境中的内存使用状态，可能在Wasm模块仍在访问数据时就回收该内存，而WebAssembly也无法参与Python的内存管理循环，无法主动通知Python侧释放不再需要的对象。在多线程场景下，这种冲突更为突出：Python的全局解释器锁（GIL）限制了内存操作的并发安全性，而Wasm的原子操作需要无锁的内存访问环境，ABI必须设计一套独立的内存协调机制，既要通过引用计数跟踪跨环境的内存使用状态，防止内存泄漏，又要通过内存锁定机制避免野指针访问，还要兼顾跨环境内存访问的性能，避免过度的同步操作导致效率低下，其设计难度远超同构体系下的内存接口。</p><p>系统接口的抽象层级差异给ABI带来了难以调和的适配难题，WASI作为WebAssembly的系统接口标准，其设计理念与Python依赖的原生系统接口存在显著的抽象鸿沟。WASI为了追求跨平台可移植性，对传统操作系统的系统调用进行了精简与标准化，仅保留了文件操作、网络通信、内存管理等核心功能，且调用方式采用了基于句柄的抽象设计，与Linux、Windows等原生系统的系统调用在功能覆盖、参数传递方式上存在明显差异。而Python的许多标准库与扩展模块深度依赖于原生系统的完整接口能力，比如Python的os模块提供的进程管理、信号处理功能，在WASI的接口规范中并未完全覆盖，这种差异使得ABI在对接两者时必须面对功能缺失与接口转换的双重挑战。例如，Python的os.fork()函数用于创建子进程，而WASI为了避免跨平台兼容性问题，并未提供对应的进程创建接口，ABI适配层必须通过线程模拟或进程池复用的方式间接实现该功能，这不仅增加了实现复杂度，还可能导致部分依赖进程隔离特性的Python代码出现逻辑偏差。更复杂的是，WASI的版本迭代与实现差异加剧了适配难度，WASI 0.2版本在网络接口中新增了TCP流的非阻塞操作支持，而部分老旧的Wasm运行时仍基于WASI 0.1版本实现，导致Python模块在利用ABI调用网络功能时，出现功能不一致或调用失败的情况。此外，不同运行时对WASI标准的实现也可能存在偏差，比如WasmEdge对文件权限的检查逻辑与Wasmer存在差异，导致Python的文件操作在不同运行时中表现出不同的行为，ABI需要在Python的原生接口期望与WASI的标准化接口之间构建适配层，既要通过功能补全弥补缺失的系统调用，又要通过兼容性适配兼容不同版本与实现的差异，这种适配层的设计不仅需要深入理解两套接口的抽象逻辑，还要具备足够的灵活性以应对生态的快速变化。</p><p>工具链的碎片化导致ABI在编译与链接阶段面临一致性难题，Python与WebAssembly的集成依赖多种工具链的协同工作，而不同工具链的编译策略、链接规则存在显著差异，使得ABI的实现难以保持跨工具链的一致性。目前主流的集成工具链包括Emscripten、Pyodide、Wasmer-Python等，每一种工具链都有其独特的编译流程与优化策略：Emscripten侧重于将Python代码编译为Wasm模块，其编译过程会对Python的标准库进行裁剪与适配，可能导致部分依赖原生扩展的模块无法正常工作；Pyodide则是将Python解释器编译为Wasm，通过JavaScript桥接实现与Wasm模块的交互，但其ABI设计过度依赖JavaScript中间层，导致跨环境调用的性能损耗较大；Wasmer-Python直接通过原生绑定实现Python与Wasm运行时的交互，但其对Python版本的兼容性较差，仅支持3.8以上的特定版本。这些工具链的差异在异常处理机制上表现得尤为明显，Python的错误处理模型依赖于异常传播，允许在函数调用栈的任意层级捕获异常并处理，而部分Wasm工具链如Emscripten默认不支持跨模块的异常传播，将Python的异常转换为Wasm的错误码，这就需要ABI在编译阶段进行特殊配置，通过生成额外的异常处理元数据，实现异常信息的跨环境传递，既要满足Python的异常处理需求，又要兼容工具链的限制。另一些工具链在处理稳定ABI时，可能存在链接逻辑的偏差，比如在Windows平台上，即使指定了稳定ABI构建，Emscripten仍会错误地链接到版本特定的Python库文件，导致Python模块失去跨版本兼容性，在Python 3.10与3.11之间切换时出现符号未定义错误。这种工具链层面的差异使得ABI的实现必须针对不同工具链进行适配，而每一种适配都可能引入新的兼容性问题，如何在碎片化的工具链生态中维持ABI的一致性与稳定性，成为集成过程中必须攻克的难题，这不仅需要对工具链的底层逻辑有深入理解，还要设计灵活的适配策略，比如通过条件编译指令适配不同工具链的特性，通过中间层封装屏蔽工具链的差异，以应对各种边缘情况。</p><p>ABI的演进与兼容平衡是长期面临的战略挑战，随着Python与WebAssembly生态的快速发展，ABI需要在功能扩展与向后兼容之间找到微妙的平衡。Python的版本迭代速度较快，每一个大版本都会引入新的语言特性与标准库接口，比如Python 3.11新增的异常组特性、3.12优化的类型注解语法，这些新特性往往需要ABI在类型映射、调用约定等层面进行相应调整，才能实现与Wasm模块的无缝集成。而WebAssembly的规范也在持续升级，最新的WebAssembly 2.0标准引入了SIMD扩展指令集、引用类型增强等新特性，这些特性为性能优化提供了更多可能，但也要求ABI进行升级以支持新的指令调用与内存操作模式。然而，ABI的升级必须兼顾已有系统的兼容性，否则会导致基于旧版ABI开发的Wasm模块与Python扩展失效，破坏生态的稳定性。例如，若ABI为支持SIMD指令而修改了数值类型的内存布局，那么基于旧版ABI编译的矩阵运算Wasm模块，在新版本环境中会因类型映射错误而输出错误结果。更复杂的是，不同的Python库与WebAssembly模块可能依赖不同版本的ABI，部分老旧的Python扩展仍依赖于早期的ABI版本，而新开发的Wasm模块则需要使用最新的ABI特性，这种依赖的多样性使得ABI的版本管理变得异常复杂。如何设计一套可演进的ABI架构，既能支持新特性的快速集成，又能通过兼容层保障旧模块的正常运行，成为考验架构设计能力的关键。</p>]]></description></item><item>    <title><![CDATA[《跨语言协作效率提升：GraalPython互操作核心瓶颈攻坚手册》 程序员阿伟 ]]></title>    <link>https://segmentfault.com/a/1190000047550127</link>    <guid>https://segmentfault.com/a/1190000047550127</guid>    <pubDate>2026-01-18 22:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>GraalPython凭借多语言无缝协同的特性成为技术选型热点，但互操作背后的性能损耗往往隐藏在“无缝”的表象之下。这种损耗并非单一环节的低效，而是跨语言语义转译、语境切换、内存协同等多重因素交织的隐性壁垒——当GraalPython与Java、Rust等语言进行数据交互时，Polyglot API的中间适配、Truffle框架的动态优化延迟、不同语言内存模型的语义冲突，都会在高频调用场景中放大为显著的性能瓶颈。例如在工业物联网设备的实时质检场景中，GraalPython负责处理传感器采集的非结构化动态数据流，完成数据清洗与特征提取后，需将结果传递给Java模块进行业务规则校验，再由Rust模块执行底层算法加速运算，看似流畅的三级协同背后，类型语义的隐性转译、上下文状态的频繁切换，会使单次调用的延迟从微秒级累积至毫秒级，在每秒数十万次的高频调用场景下，直接导致整体系统吞吐量下降三成以上。更值得注意的是，这种瓶颈的隐蔽性极强，在低频次的功能测试中性能差异微乎其微，只有进入大规模数据处理或高并发交互的真实生产场景，深层的协同损耗才会集中爆发，成为制约系统性能上限的隐形枷锁，甚至会让前期针对单一语言的优化策略全部失效。</p><p>类型语义转译的隐性开销是互操作面临的核心瓶颈，这种开销源于不同语言类型体系的本质差异与转译过程中的语义损耗。GraalPython的动态类型表征与Java的静态类型谱系、Rust的强类型约束在核心语义上存在天然分歧，而Polyglot API作为转译中介，需在不同类型体系间构建临时映射关系，这种映射不仅涉及数据格式的转换，更包含语义逻辑的适配与补全。例如GraalPython的动态数组可能混合存储整数、字符串、布尔值等多种类型元素，传递给Java时需转译为统一类型的有序集合，转译过程中不仅要逐一对元素进行类型校验与转换，还需对不兼容元素进行语义适配，比如将Python的None值转换为Java的null，将Python的布尔值映射为Java的Boolean类型，这种适配往往需要额外的计算资源与时间开销。更复杂的是，不同语言对同一数据类型的语义定义可能存在偏差，GraalPython的字符串默认采用UTF-8编码且支持动态拼接，而Rust的字节序列更强调内存安全与固定长度，二者在底层存储逻辑上的差异，会导致转译时需进行编码格式的转换与内存空间的重构，高频次下这种转换的累积开销会急剧上升。同时，转译过程中还需维护类型元数据的同步，确保跨语言调用时的数据一致性，这种元数据管理本身也会占用额外的系统资源，比如构建类型映射表、跟踪类型转换记录，这些隐性操作都成为了性能损耗的隐形来源。</p><p>语境切换的累积损耗构成了互操作的另一重性能障碍，GraalPython与其他语言的协同需频繁切换执行语境，而语境切换过程中的状态保存、环境重建会产生显著的时间开销。在实时数据处理场景中，GraalPython负责数据预处理，Java负责业务逻辑计算，Rust负责底层算法加速，三者之间的频繁调用会导致执行语境在不同语言 runtime 间反复切换。每次切换都需保存当前语言的执行状态，包括程序计数器的值、寄存器中的临时数据、栈帧中的局部变量等，再加载目标语言的运行环境，初始化上下文配置、恢复目标语言的执行参数，这个过程在微秒级别的单次切换中看似微不足道，但在每秒数万次的高频调用场景下，累积损耗会占据相当比例的系统资源。更关键的是，语境切换会导致CPU缓存失效，CPU的L1、L2缓存原本存储着当前语言的指令与数据，切换后需要重新加载目标语言的指令与数据到缓存中，破坏了缓存的局部性原理，使得后续指令的执行不得不从内存中读取数据，进一步降低了执行效率。此外，不同语言的线程模型差异会加剧切换损耗，GraalPython的协程调度采用轻量级的用户态切换，Java的线程池管理依赖操作系统的内核态调度，Rust的无栈协程则强调零成本的上下文切换，三者在调度机制上的不兼容，会导致跨语言调用时出现调度冲突，需引入额外的同步机制进行协调，比如使用互斥锁或信号量保证线程安全，这无疑又增加了性能开销，让语境切换的损耗雪上加霜。</p><p>内存语义协同的冲突是深层性能瓶颈，GraalPython的动态内存调度与其他语言的内存管理机制在语义上存在本质分歧，跨语言数据共享时的内存所有权界定、生命周期同步成为核心难题。GraalPython依赖自身的垃圾回收机制管理内存，对象的创建与释放无需手动干预，垃圾回收器会定期扫描内存空间，回收不再被引用的对象；而Rust采用严格的所有权模型，内存的分配与释放由编译器静态检查，确保每一块内存都有唯一的所有者，避免出现空指针或悬垂引用；Java则通过JVM的垃圾回收机制自动管理内存，其回收策略与GraalPython的GC存在显著差异。三者的内存语义差异导致跨语言数据传递时需进行复杂的内存适配，例如GraalPython的对象传递给Rust时，需将动态分配的内存转换为Rust可识别的所有权模型，这个过程不仅要复制数据到Rust的内存空间，还需构建临时的内存管理代理，通过引用计数的方式跟踪内存的使用状态，确保Rust使用期间内存不被GraalPython的GC回收，使用完毕后及时通知GC释放代理资源。这种适配不仅增加了内存拷贝的开销，还可能导致内存泄漏——当跨语言调用因网络波动或系统异常中断时，内存管理代理可能无法正常销毁，导致部分内存无法被回收，长期运行会使系统可用内存逐渐减少。在数据密集型场景中，大量跨语言数据传递会使这种内存协同开销呈指数级增长，比如处理百万级别的传感器数据时，内存拷贝与代理管理的时间占比可达总执行时间的40%以上，严重影响系统的整体性能。</p><p>版本协同的隐性陷阱加剧了互操作的性能波动，GraalVM生态的版本迭代与多语言模块的版本兼容性要求，使得GraalPython在互操作时面临优化失效的风险。GraalVM的版本管理采用严格的语义化版本控制，主版本号的差异可能导致Polyglot API的调用逻辑、Truffle框架的优化策略发生根本性变化，而不同语言模块如Java的polyglot库、Rust的FFI绑定在版本迭代时可能未及时同步适配，导致跨语言调用时出现优化不兼容的问题。例如使用GraalVM 23.0版本运行时调用基于22.0版本开发的Java模块，可能会因Polyglot API的参数传递方式变化，导致JIT编译的跨语言内联优化失效，原本可通过内联减少的调用开销无法实现，单次跨语言调用的耗时增加两倍以上；而低版本的GraalPython对接高版本的Rust模块时，可能因FFI接口的语义变化，导致数据转译过程中出现冗余操作，比如重复进行类型校验、额外生成中间数据结构，这些冗余操作都会显著增加性能损耗。更复杂的是，部分语言模块的版本更新会引入新的内存管理机制或线程调度策略，与GraalPython的原有适配逻辑产生冲突，比如Rust模块升级后采用了新的异步内存分配器，而GraalPython的内存代理机制未同步更新，导致跨语言数据传递时出现内存分配冲突，不得不引入额外的同步锁进行协调，进一步降低了执行效率。这种版本协同的复杂性要求开发者在选型时需严格匹配所有相关模块的版本，而频繁的版本迭代又使得版本维护的成本急剧上升，成为性能优化过程中难以规避的隐性障碍。</p><p>动态优化的边界限制是长期存在的性能瓶颈，GraalPython依赖Truffle框架的动态优化能力提升执行效率，但多语言互操作的复杂性使得优化策略难以充分覆盖，导致部分跨语言调用无法获得有效的优化支持。Truffle框架的核心优化手段包括部分评估、跨语言内联、类型特化等，这些优化依赖于对代码执行路径的静态分析与运行时数据收集，而多语言互操作的动态特性往往超出了优化策略的覆盖范围。例如GraalPython调用Java的泛型方法时，由于Java的泛型类型擦除特性，Truffle框架难以在编译期确定具体的类型信息，无法进行精准的类型特化优化，只能采用通用的类型处理逻辑，导致调用开销居高不下；而调用Rust的复杂结构体方法时，因结构体的内存布局与GraalPython的对象模型存在显著差异，部分评估优化无法充分展开，只能依赖runtime的动态适配，增加了执行延迟。此外，多语言调用的路径多样性也会影响优化效果，不同语言的函数调用栈嵌套、参数传递方式的差异，使得Truffle框架难以构建统一的优化模型，比如三级嵌套的跨语言调用，Python调用Java再调用Rust，框架无法对整个调用链进行全局优化，只能对单一环节进行局部优化，优化效果大打折扣。</p>]]></description></item><item>    <title><![CDATA[浏览器实际大文件下载解决方案 张波 ]]></title>    <link>https://segmentfault.com/a/1190000047548998</link>    <guid>https://segmentfault.com/a/1190000047548998</guid>    <pubDate>2026-01-18 21:08:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>背景</h2><p>现在大多数业务都是和内容生产相关的业务，我们公司实际业务是频繁和素材打交道，尤其是电商短视频(抖音，快手，tiktok)打交道，文件的上传和下载尤为重要，目前国内好像还没发现靠存储收费的大型服务商，文件的频繁下载这是一个常见的场景，<br/>比如我们一开始遇到一个实际业务问题是，用户上传的交付物都是素材(图片，视频)，都是一批一批的，我们想着是打包下载，用户下载后也方便找，更有规则，但是现在正常的存储的服务商基本上不提供这样的服务，<br/>开会的时候讨论方案，方案其实挺多的，问AI或者cursor 也是实现非常容易，但是没有考虑实际业务场景， 如果下载是一个高频操作，且文件非常大，如何处理</p><h2>方式一：浏览器插件下载(推荐)</h2><pre><code class="javascripts">export const batchDownload = (detail: DownloadRequest) =&gt; {
  detail?.list?.forEach((item) =&gt; {
    let filename = '';
    if (detail?.dir) {
      filename = `${detail.dir}/${item.filename}`;
    } else {
      filename = item.filename;
    }
    chrome.downloads.download({
      url: item.url,
      filename,
      saveAs: detail?.saveAs || false,
      // 防止重名覆盖
      conflictAction: 'uniquify'
    });
  });
};</code></pre><h3>优点</h3><ul><li>流水线下载，可以下载的时候在前面加一个目录名字，会将文件下载到目录下面(别想多了，有些人这里就想偏了，不能是任意目录，是浏览器默认设置的下载目录下你可以创建的目录)</li><li>下载进度用户可见，不吃内存，随时可以取消</li></ul><h3>缺点</h3><ul><li>需要用户安装插件</li><li>插件需要支持的多每家的标准都不一样(Chrome, firefox, edge, 360极速浏览器，360安全浏览器)</li><li>开发框架也是比较多，难选(我们用的是Wxt)</li><li>上架(chrome插件国内需要自己安装，firefox可以自动化走内部托管，一键化发布，自动更新)</li></ul><p>提示，记得开发插件的时候记得样式问题多检查一下，最好使用沙箱机制。</p><h2>方式二：使用跨平台的方案，比如套壳electron</h2><h3>优点</h3><ul><li>自定义下载，完全突破浏览器限制</li><li>自定义程度高</li></ul><h3>缺点</h3><ul><li>不容易管理内存，内存如果不能合理分配，会直接内存爆炸(实际项目我试过，用户电脑死机了)</li><li>浏览器开发和客户端开发不是一个标准，客户端其实更多是基于内存和业务的合理分配和调度</li></ul><h2>方式三：FileSystem Access API + Streams API + ZipWriterStream (Web Streams 压缩库)</h2><pre><code class="javascript">import { ZipWriterStream } from '@zip.js/zip.js';
export const startZipStreamDownload = async (
  fileHandle: FileSystemFileHandle,
  detail: DownloadRequest
): Promise&lt;DownloadResult&gt; =&gt; {
  const result: DownloadResult = {
    success: true,
    successFiles: [],
    failedFiles: []
  };

  let writable: FileSystemWritableFileStream | null = null;
  let zipStream: ZipWriterStream | null = null;
  let pipePromise: Promise&lt;void&gt; | null = null;

  try {
    writable = await fileHandle.createWritable();
    zipStream = new ZipWriterStream({ zip64: true });
    pipePromise = zipStream.readable.pipeTo(writable);

    for (let i = 0; i &lt; detail.list.length; i++) {
      const item = detail.list[i];
      const filename = item.filename;

      try {
        const response = await fetch(item.url);

        if (!response.ok) {
          console.warn(`跳过文件：HTTP ${response.status} - ${item.url}`);
          result.failedFiles.push({
            url: item.url,
            filename,
            result: 'failed',
            error: `HTTP ${response.status}`
          });
          continue;
        }

        if (!response.body) {
          throw new Error('Response body is null');
        }

        await response.body.pipeTo(zipStream.writable(filename));

        result.successFiles.push({
          url: item.url,
          filename,
          result: 'completed',
          error: ''
        });
        console.log(`已完成: ${filename}`);
      } catch (innerError) {
        console.error(`下载中断或出错 [${filename}]:`, innerError);
        result.failedFiles.push({
          url: item.url,
          filename,
          result: 'failed',
          error:
            innerError instanceof Error
              ? innerError.message
              : String(innerError)
        });
        // 继续下一个文件
      }
    }

    // 正常关闭 ZIP 流
    await zipStream.close();
    await pipePromise;
  } catch (error) {
    console.error('ZIP 流写入失败:', error);
    result.success = false;
    // 安全清理
    try {
      if (writable) {
        await writable.abort();
      }
    } catch {
      // 忽略 abort 错误
    }
  }

  // 设置最终状态
  if (result.failedFiles.length &gt; 0 &amp;&amp; result.successFiles.length === 0) {
    result.success = false;
  }

  return result;
};</code></pre><h3>优点</h3><ul><li>下载10GB，浏览器也可能只消耗几十MB的内存，流水线处理数据,不需一次性将整个大文件加载到内存中，极大地节省了内存开销。</li><li>不需要浏览器插件就可以实现</li></ul><h3>缺点</h3><ul><li>兼容性差，Chrome/Edge 等 Chromium 系浏览器支持较好，Safari 和 Firefox 的支持程度有限。</li><li>需要用户点击授权</li><li>页面标签不可关闭(一旦关闭，文件下载失败，服务器还要计算流量费用)</li><li>下载进度不可见</li></ul><h2>方式四：客户端使用blob流将所有的字节流都堆到内存中，全都接收完毕后进行下载</h2><p>代码就懒得写了，随便搜搜都是这种方式</p><h3>优点</h3><ul><li>打包压缩下载可以实现</li></ul><h3>缺点</h3><ul><li>文件大了，内存爆炸，浏览器分配的内存是4G，但实际安全内存只有2G，超过2G的内存直接被V8干掉了</li><li>浏览器标签关闭也是下载失败，服务器还是会计算出网费用</li></ul><p>我们就是使用方式1，方式2也有，如果需要插件的朋友，可以到时候评论区说，有需求我可以发布一下，都是可以通过api调用下载的。或者有人想二次开发的话我也可以直接开源发布一下。看需求吧</p><p>如果有想获取抖音实际视频地址 或者 下载保存抖音无水印视频 需求的朋友可以使用下面的工具直接获取视频地址，这个原本是公司内网用的<br/><a href="https://link.segmentfault.com/?enc=A6tufV1Q08uzWKvMhjZK2Q%3D%3D.6EXD8FAjfVBLg6TBsq%2FuJhNJ1RV9PtzKpfUoElYSia4%3D" rel="nofollow" target="_blank">Easydown</a></p>]]></description></item><item>    <title><![CDATA[实战 Agent Skills：从 Hello World 到构建你的 AI 队友 blossom ]]></title>    <link>https://segmentfault.com/a/1190000047549003</link>    <guid>https://segmentfault.com/a/1190000047549003</guid>    <pubDate>2026-01-18 21:07:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>引言</h2><p>在上一篇文章中，我们探讨了“Agent Skills”如何作为一种数字资产，解决团队内的提示词熵增问题。今天，我们不再谈理论，直接动手。</p><p>我们将从一个简单的 <strong>"Hello World"</strong> 入门，然后进入真正的<strong>实战环节</strong>：针对最近使用 <strong>Gemini CLI Conductor</strong> 写后台 API 时遇到的问题，创建一个能够自动纠正“代码坏味道”的企业级 Java 技能，并让全团队共享这份智慧。</p><hr/><h2>第一步：开启“外挂”模式</h2><p>Agent Skills 目前在 VS Code 中是一个<strong>实验性功能</strong>。如果不开启，Copilot 就只是一个普通的聊天窗口，无法挂载本地的文件和脚本。</p><p><strong>操作步骤：</strong></p><ol><li>打开 VS Code 设置（Settings）。</li><li>搜索 <code>skills</code>。</li><li>勾选该选项。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549006" alt="" title=""/></p><p>如下图所示，这个设置控制了 AI 是否能将 <code>.github/skills</code> 或 <code>~/.copilot/skills</code> 中的内容作为“特殊能力”加载。</p><hr/><h2>第二步：入门 —— Hello World 的物理结构</h2><p>一个 Skill 不是一个文件，而是一个<strong>文件夹</strong>。这正是它强大的地方——它可以包含代码、模版和文档。</p><p>我们需要在项目根目录下创建以下结构：</p><pre><code class="text">.github/
  └── skills/
       └── hello-world/          &lt;-- 技能名称目录
            ├── SKILL.md         &lt;-- 核心：大脑（元数据+流程）
            ├── TEMPLATE.md      &lt;-- 模版：骨架（输出格式）
            └── scripts/         &lt;-- 手脚：执行脚本
                 └── get-system-info.js
</code></pre><p>让我们把这三个文件的内容填进去：</p><h3>1. 定义大脑：<code>SKILL.md</code></h3><p>这是 AI 的指挥棒。它定义了 Skill 的名字、触发条件以及执行流（Workflow）。</p><pre><code class="markdown">---
name: hello-world
description: A simple skill that should be used to respond to the user when they enter the phrase "hello world".
---

# Hello World

Use the Hello World skill to respond to the user when they enter the phrase "hello world".

## Workflow

1. Run the [script](./scripts/get-system-info.js) to obtain system infomation.
2. Respond with the [template](./TEMPLATE.md).
</code></pre><h3>2. 定义手脚：<code>scripts/get-system-info.js</code></h3><p>Agent Skill 的杀手锏在于它可以<strong>执行代码</strong>。我们编写一个简单的 Node.js 脚本来获取当前电脑的系统信息。</p><pre><code class="javascript">const os = require('os');

// 获取系统基本信息
console.log('Platform: ', os.platform());
console.log('Type: ', os.type());
console.log('Release: ', os.release());
console.log('Architecture: ', os.arch());
</code></pre><h3>3. 定义骨架：<code>TEMPLATE.md</code></h3><p>为了保证输出格式的统一（防止 AI 自由发挥乱写），我们强制它使用这个模版。</p><pre><code class="markdown">Hello! You`ve triggered the Hello Worlld skill.

 _   _      _ _     __        __         _     _
| | | | ___| | |___ \ \      / /__  _ __| | __| |
| |_| |/ _ \ | / __|  \ \ /\ / / _ \| '__| |/ _` |
|  _  |  __/ | \__ \   \ V  V / (_) | |  | | (_| |
|_| |_|\___|_|_|___/    \_/\_/ \___/|_|  |_|\__,_|

Here is your system infomation:

{system_info}

Feel free to aks if you need further assistance!
</code></pre><h3>4. 见证 AI 的“思考过程”</h3><p>一切准备就绪。打开 Copilot Chat，输入：<code>hello world</code>。</p><p>神奇的事情发生了。Copilot 开始了一系列的<strong>思维链推理 (Chain of Thought)</strong> 和 <strong>工具调用</strong>。我们可以通过日志清晰地看到这个过程：</p><ol><li><strong>准备信息</strong>：AI 识别并运行脚本收集系统信息。</li><li><strong>处理模版</strong>：AI 填充 <code>TEMPLATE.md</code>。</li><li><strong>最终输出</strong>：AI 生成了 ASCII Art 字符画。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549007" alt="" title="" loading="lazy"/></p><hr/><h2>第三步：进阶实战 —— 消灭“烂代码” (Java Spring API)</h2><p>Hello World 只是热身。现在我们要解决真正的痛点。</p><p><strong>痛点场景：</strong><br/>最近我在用 <strong>Gemini CLI Conductor</strong> 实现后台 API 时，虽然 Conductor 生成的代码能跑，但有些细节质量不达标，如果不加干预，后期维护成本高：</p><ol><li><strong>滥用万能类</strong>：DTO 定义偷懒，大量使用 <code>Map&lt;String, Object&gt;</code> 作为返回值，导致接口文档不可读，类型不安全。</li><li><strong>枚举缺失</strong>：状态字段直接使用 <code>int</code> (如 <code>status=1</code>)，充满了魔术数字，而不是规范的 Java Enum。</li><li><strong>接口裸奔</strong>：生成的数据迁移接口或管理接口，经常忘记加安全校验（Token/Key），直接把敏感操作暴露出去。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549008" alt="" title="" loading="lazy"/></p><p>靠口头 Code Review 去纠正效率极低。我们现在就通过 Agent Skill，把这些痛点一劳永逸地解决。</p><h3>1. 目录结构规划</h3><p>我们创建一个名为 <code>java-spring-api</code> 的技能：</p><pre><code class="text">.github/
  └── skills/
       └── java-spring-api/
            ├── SKILL.md           &lt;-- 核心规则
            └── templates/
                 └── Result.java   &lt;-- (可选) 统一返回结果模版
</code></pre><h3>2. 核心代码：<code>SKILL.md</code></h3><p>这是一个可以直接复制使用的工业级 Skill 定义。我们在其中加入了<strong>负向约束 (Negative Constraints)</strong> 和 <strong>自查清单 (Self-Reflection)</strong>。</p><pre><code class="yaml">---
name: java-spring-api
description: Write production-ready Spring Boot APIs. Use this skill when the user asks to create REST endpoints, controllers, or data migration interfaces.
---

# Java Spring Boot API Expert

You are a Senior Java Architect. When writing APIs, you MUST adhere to the following strict standards.

## 🚫 Negative Constraints (Absolutely Forbidden)
1. **NO `Map&lt;String, Object&gt;`**: NEVER use `Map` or `JSONObject` as input parameters or return types. You MUST define specific DTO classes.
2. **NO Magic Numbers**: NEVER use raw integers or strings for status/types (e.g., `status = 1`). You MUST use Java Enums.
3. **NO Unsecured Admin Endpoints**: NEVER create data migration or administrative interfaces without security protection.

## ✅ Coding Standards (The "How")

### 1. DTO Definitions
- Always define explicit DTOs for Request and Response bodies.
- Use Lombok `@Data` or `@Value` (or Java `records`) to reduce boilerplate.
- **Why?** To ensure type safety and API documentation readability.

### 2. Value Objects
- Define enums for all state/type fields.
- Example: `UserStatus.ACTIVE` instead of `1`.
- Use `@JsonValue` or `@EnumValue` to handle serialization correctly.

### 3. Security &amp; Stability
- **For Migration/Admin APIs**: You MUST add a security check.
    - Option A: Add `@PreAuthorize("hasRole('ADMIN')")`.
    - Option B (if no Spring Security): Add a specific header check (e.g., `X-Admin-Key`).
- **Input Validation**: Always add `@Valid` and `@NotNull`/`@NotBlank` annotations to DTO fields.

## 🧠 Self-Reflection Checklist (Run this before outputting code)
- [ ] Did I replace all `Map` usages with proper DTO classes?
- [ ] Did I define Enums for any status/type fields?
- [ ] If this is a migration interface, did I add an API Key check or Security annotation?
- [ ] Are the return values wrapped in a standard Result/Response object?

## Example Output Structure
</code></pre><p>// Good Example: DTO with Enums<br/>@Data<br/>public class CreateUserRequest {</p><pre><code>@NotBlank
private String username;
@NotNull
private UserRole role; // Enum, NOT String/Integer</code></pre><p>}</p><p>// Good Example: Secured Migration Endpoint<br/>@PostMapping("/migrate")<br/>public Result&lt;Void&gt; migrateData(@RequestHeader("X-Admin-Token") String token) {</p><pre><code>if (!"SECURE_KEY".equals(token)) {
    throw new UnauthorizedException();
}
// ... logic</code></pre><p>}</p><pre><code>
---

## 第四步：全员共享 —— 让高质量成为默认选项

写好了 Skill 只是第一步。Agent Skills 最强大的地方在于它的**项目级共享能力**。

请注意，我们将 Skill 放在了 **`.github/skills`** 目录下。这意味着：

1. **随代码提交**：这个 Skill 文件夹会像普通 Java 代码一样被 `git commit` 和 `git push` 到仓库。
2. **自动分发**：当新入职的同事 `git clone` 项目代码，并在 VS Code 中打开时，Copilot 会自动检测到这些 Skill。
3. **统一标准**：无论你是刚毕业的实习生，还是资深的架构师，当你对 AI 说“写个 API”时，AI 都会加载同一份 `SKILL.md`。

**结果就是：**

* 不会再有人因为“不知道规范”而提交 `Map&lt;String, Object&gt;`。
* 不会再因为“忘记了”而漏写安全校验。
* **团队的代码质量不再取决于写代码那个人的水平，而取决于团队 Skill 库的水平。**

这就是真正的**工程化 (Engineering)**。

---

## 第五步：站在巨人的肩膀上（使用社区资源）

开源社区已经积累了大量现成的 Skills，你可以关注以下两个官方认可的渠道，像下载代码库一样直接“下载”能力：

1. **GitHub Awesome Copilot (`https://github.com/github/awesome-copilot`)**
* 这是一个不断增长的 Skill 集合。它最大的特点是强调**“捆绑资源 (Bundled Assets)”**——即 Skill 不仅仅是 Markdown 指令，还自带了**辅助脚本**、**代码模版**和**参考数据**。
* **典型硬核案例：**
* **azure-resource-visualizer**：分析 Azure 资源组，自动生成 Mermaid 架构图，帮助你梳理云端资源关系。
* **ebapp-testing**：不仅仅是写测试代码，它自带 Playwright 脚本 (`test-helper.js`)，能直接与本地 Web 应用交互，截图并 Debug UI 问题。
* **github-issues**：通过 MCP 工具集直接管理 GitHub Issue，从创建 Bug 单到更新任务流一气呵成。
* **web-design-reviewer**：视觉审查工具，能自动检查响应式布局、可访问性问题，并给出源码级修复建议。


![](https://files.mdnice.com/user/52865/7dc89bc4-9850-4c83-ab8a-c18799d2273f.png)

2. **Anthropic Skills 库 (`https://github.com/anthropics/skills`)**
* 这是 Anthropic 官方提供的 Skills 实现库，内容涵盖极广：从创意设计（艺术、音乐）到技术任务（Web 测试、MCP 服务生成），再到企业工作流（品牌、通信）。。

![](https://files.mdnice.com/user/52865/880077e0-bec3-4538-8985-ef345c4ddf98.png)



**如何使用？**
浏览仓库 -&gt; 下载 Skill 文件夹 -&gt; 复制到你项目的 `.github/skills/` 目录下 -&gt; 根据需要微调。

---

## 总结

通过 **Hello World** 的机制验证，和 **Java Spring API** 的实战治理，我们看清了 Agent Skills 的真正价值：

1. **可执行性**：AI 有了“手”，能运行脚本获取系统信息。
2. **强制规范**：通过 `Negative Constraints`，我们强制消灭了 Map 滥用和魔法值。
3. **全员对齐**：通过 Git 共享，让每一个团队成员都能写出架构师级别的代码。
</code></pre>]]></description></item><item>    <title><![CDATA[4个适合企业业务流程的轻量化软件（附真实案例） NocoBase ]]></title>    <link>https://segmentfault.com/a/1190000047549385</link>    <guid>https://segmentfault.com/a/1190000047549385</guid>    <pubDate>2026-01-18 21:07:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>原文链接：<a href="https://link.segmentfault.com/?enc=DVtTvzkfJ2V8hbBe0vOHNA%3D%3D.r8pfUPFabSpD6xi28grRBd5D48ogXhnvmcNp9eFydkHdZgfzkQn8XP26jYaHby6prUBfn5vNp2OgyiSPL1onQsSz6EjtETZqjKRVRS3wC987mM112ca%2FlGJvnLlEPhc0" rel="nofollow" target="_blank">https://www.nocobase.com/cn/blog/4-lightweight-enterprise-sof...</a></p><p>当企业的业务逐步扩展、团队角色不断增加，引入软件来管理内部运营和业务流程几乎是不可避免的选择。</p><p>很多团队最先选择的是现成的 SaaS 产品：销售用一套，任务管理用一套，客户支持再配一套。短期内看起来高效，但随着系统数量增加，按人头计费的订阅成本不断累积，流程和数据被分散在不同工具中，协作反而变得更复杂。</p><hr/><p>💬 嗨！你正在阅读 NocoBase 博客。NocoBase 是一个极易扩展的 AI 无代码/低代码开发平台，用于构建企业应用、内部工具和各类系统。它完全支持自托管，基于插件架构设计，开发者友好。→ <a href="https://link.segmentfault.com/?enc=oesMv5W7hw7iQKz9Yrw3bA%3D%3D.HCy4KyFAcq7U8aWV26ozT7cmhnnb4gLYD0MZmmO9pEoOkML8KWlsLmTt6QEVTmX2" rel="nofollow" target="_blank">欢迎在 GitHub 上了解我们</a></p><hr/><p>也有团队选择直接定制一套系统，把所有功能一次性做进去。这样的方案灵活性更高，但往往意味着更高的投入和更长的周期。一旦业务节奏发生变化，后续的修改和维护成本还会不断追加，系统反而成了新的负担。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549388" alt="reddit1cn.png" title="reddit1cn.png"/></p><p>最近在 <a href="https://link.segmentfault.com/?enc=Pdk1ulzjasC6FYA7sIRXUQ%3D%3D.hb%2BbaFJgnxKgpT7NB%2FbNa%2FZyzRrdtV%2FJioF7szqAqjmUF4VO18RSVcuu%2FpjFGks0O%2BsHCS%2BDUfUsn08H6fgh3KxgZaigVg9d9yGPSn%2F%2BH67dptD4efE7%2BvWYC6agIv69i1cxCsbBBNo%2FmJi3nH7BKAMTvHgBGEbaT0qE3aLcvkY%3D" rel="nofollow" target="_blank">Reddit</a> 上，我看到有用户分享了类似的困扰。他的团队只有几个人，却已经同时订阅了销售跟踪、任务管理和客户支持等多套按人头计费的软件。随着协作的展开，月度软件成本迅速攀升。尽管投入不低，销售和运营数据依然分散在不同系统中，工作流程并没有因此变得更简单。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549389" alt="reddit2.png" title="reddit2.png" loading="lazy"/></p><p>评论中有用户提到，其实在类似的需求下，许多开源工具其实已经能够很好地覆盖这些需求。</p><p>与垂直 SaaS 相比，它们更关注流程本身；与重型定制项目相比，它们更适合围绕业务流程，在可控成本下持续调整，并具备更高的可配置性和扩展空间。</p><p>基于这样的讨论背景，本文将介绍四个适合业务流程管理的开源软件，并结合真实案例，梳理这类工具在不同组织和业务场景中的常见使用方式。</p><h2>四个开源轻量化企业级软件方案</h2><h3><strong>NocoBase</strong></h3><p>NocoBase 是一款开源、AI 驱动的企业系统构建工具，面向企业内部应用场景，适用于需要统一管理数据、流程和权限的组织环境。它以数据模型和插件化架构为基础，支持构建审批、工单、台账、项目管理等多种业务系统，用于承载企业内部的核心业务流程和管理逻辑。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549390" alt="NocoBase1.png" title="NocoBase1.png" loading="lazy"/></p><p>官网：<a href="https://link.segmentfault.com/?enc=%2B3sbxVryMmZKJtu20KEdRQ%3D%3D.wuZBF4osc5aijquGz1K5I4JxLwM6cObKdIVLzEci5HIVncogHJVlgYwKlJCT1lTq" rel="nofollow" target="_blank">https://www.nocobase.com</a></p><p>GitHub 链接：<a href="https://link.segmentfault.com/?enc=SWPuiAQl6YP6xCpfxUH3vg%3D%3D.FNer3lTOLtXnSabOJsqlwwODryzYuEee%2BVAFoC3ZC48Tu9kkd%2BaohNMMfO5LSkO%2F%2Bahe3Hrlxpdpyxuy%2F02BAg%3D%3D" rel="nofollow" target="_blank">https://github.com/nocobase/nocobase</a></p><p>GitHub Star 数： 21.1k</p><p>开源协议：Apache-3.0（商业友好）</p><p><strong>推荐理由</strong></p><p><strong>基于数据模型的系统构建方式</strong></p><p>NocoBase 以数据模型作为系统构建基础，通过配置表结构、字段和关系来组织业务数据。页面、权限等系统能力均基于数据模型进行配置，不同类型的业务系统可以在同一平台内构建和管理，适用于审批、工单、台账等业务场景。</p><p><strong>支持多角色、多部门参与的权限体系</strong></p><p>系统提供基于角色、资源和操作的权限控制机制，并支持在不同层级配置访问与操作范围。权限控制可以细化到字段级别，不同角色在同一数据对象中可看到和操作的字段各不相同，适用于多个部门、不同职责角色共同参与业务流程的场景。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549391" alt="NocoBase2.png" title="NocoBase2.png" loading="lazy"/></p><p><strong>插件化架构下的业务能力组合</strong></p><p>NocoBase 的功能以插件形式进行组织，不同业务系统可以根据实际需求组合所需能力，支持在同一平台内构建多类业务流程系统，并在不影响现有系统结构的情况下调整或扩展能力。</p><p><strong>AI 员工参与业务流程与信息处理</strong></p><p>系统内引入了可配置的 AI 员工，不同的 AI 员工可以承担不同职责，参与信息整理、内容生成和结构化输出等工作。AI 员工基于系统内的数据模型、界面配置和业务上下文运行，可以被配置在具体流程节点中，作为业务操作的一部分参与执行。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549392" alt="NocoBase3.gif" title="NocoBase3.gif" loading="lazy"/></p><h3>Appsmith</h3><p>Appsmith 是一款开源的内部工具开发框架，主要面向工程团队，用于快速构建可交互的内部工具和管理应用。通常被用来把数据库、API 等已有数据，快速整理成可操作的后台页面，用于日常管理、数据维护和内部操作场景。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549393" alt="Appsmith1.png" title="Appsmith1.png" loading="lazy"/></p><p>官网：<a href="https://link.segmentfault.com/?enc=8dPOK24z86KpX49ISiWgGA%3D%3D.NNIG%2FgQVkrU5uwIFnElO3XIql4wQ0hwEI7hiKoTYFxs%3D" rel="nofollow" target="_blank">https://www.appsmith.com</a></p><p>GitHub 链接：<a href="https://link.segmentfault.com/?enc=ClvqlVjweHZvmzbmKDdIPQ%3D%3D.0j9JAOoGV3URfxv63KXGn8HcILCiJoqBjbXCJZGY1zEuNxWgDM9kcm5RQOBTiXxj" rel="nofollow" target="_blank">https://github.com/appsmithorg/appsmith</a></p><p>GitHub Star 数： 38.9k+</p><p>开源协议： Apache-2.0（商业友好）</p><p><strong>推荐理由</strong></p><p><strong>业务系统的操作与管理入口</strong></p><p>Appsmith 通常承担的是业务系统的“操作层”角色。常被用来将已有系统中的数据和接口，整理成表格、表单和简单交互页面，内部人员可以在不接触数据库或接口细节的情况下，完成数据查看、修改和日常管理操作。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549394" alt="Appsmith2.png" title="Appsmith2.png" loading="lazy"/></p><p><strong>基础清晰的权限与角色划分</strong></p><p>在权限方面，Appsmith 提供基于角色的访问控制，用来区分不同用户可以看到和操作的内容。对于以内部使用为主的工具来说，权限粒度通常已经可以满足日常管理需求。</p><p><strong>脚本补充必要的业务逻辑</strong></p><p>当界面配置无法覆盖全部需求时，Appsmith 允许通过脚本处理数据和交互逻辑。一些简单的流程判断、数据处理可以直接在工具内部完成，而不必额外开发系统。</p><h3>Budibase</h3><p>Budibase 是一款开源、可自托管的低代码应用构建工具，通过可视化方式将数据库、表单和页面组合成内部应用。Budibase 的流程和逻辑更多集中在数据操作与触发式自动化层面，对于需要复杂状态流转、深层业务规则或大规模跨系统协调的高阶业务系统，通常需要额外的脚本能力或配合其他系统共同实现。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549395" alt="Budibase1.png" title="Budibase1.png" loading="lazy"/></p><p>官网：<a href="https://link.segmentfault.com/?enc=6ME4yszq6ytWp7ySH5GA7Q%3D%3D.iVf2BYCWDVW6saghCQRehvBC7UhTMrAtGZWpZkZcdHw%3D" rel="nofollow" target="_blank">https://budibase.com</a></p><p>GitHub 链接：<a href="https://link.segmentfault.com/?enc=bk2SxJRZrOK3PIoIP6eb5Q%3D%3D.U3UwsB3bTyGhXq4wZAMfiLu1AUAEaP5wQPQEcVwpWfhQehYwHY2objKtCQ5BK5lA" rel="nofollow" target="_blank">https://github.com/Budibase/budibase</a></p><p>GitHub Star 数： 27.5k</p><p>开源协议： GPL-3.0（部分功能提供商业授权）</p><p><strong>推荐理由</strong></p><p><strong>从数据出发构建应用</strong></p><p>Budibase 的应用通常从数据表开始，通过配置表单和页面，将数据直接转化为可操作的应用界面。适合以登记、维护和查看为主的业务流程场景。</p><p><strong>适合表单驱动的业务流程</strong></p><p>在实际使用中，Budibase 经常被用来构建以表单提交和状态更新为核心的流程，例如申请、登记和内部记录。流程逻辑相对清晰，配置方便。</p><p><strong>内置基础权限与用户管理</strong></p><p>Budibase 提供用户和角色相关的访问控制，用于区分不同人员对应用和数据的使用范围。这种权限模型更偏向应用层，适合流程相对明确、角色分工清晰的团队环境。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549396" alt="Budibase2.png" title="Budibase2.png" loading="lazy"/></p><h3>NocoDB</h3><p>NocoDB 是一款开源、自托管的协作式数据库平台，主要用于将现有的关系型数据库快速转换为可视化、可协作的表格界面。它通过对数据库表结构的直接映射，让非技术人员也能够在不接触 SQL 或数据库细节的情况下，参与数据的查看、维护和协作。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549397" alt="NocoDB1.png" title="NocoDB1.png" loading="lazy"/></p><p>官网：<a href="https://link.segmentfault.com/?enc=z7Zu9GVWrEjaNGVcUAuciQ%3D%3D.4ydL5gD%2FM2vRSwgADY3DSJR4i9A61jpUVxnLvxFwTD8%3D" rel="nofollow" target="_blank">https://nocodb.com</a></p><p>GitHub 链接：<a href="https://link.segmentfault.com/?enc=ppdNpXWD6BIm6stFQ9P4QA%3D%3D.VqeAh4o4fMdqmrId%2FxJrIkfo1NYy9acydCU0qdzwZFxoYNr62m9oD%2FniJg%2BKMLaZ" rel="nofollow" target="_blank">https://github.com/nocodb/nocodb</a></p><p>GitHub Star 数：61.5k</p><p>开源协议：AGPL-3.0（社区版）</p><p><strong>推荐理由</strong></p><p><strong>直接基于现有数据库工作的数据层工具</strong></p><p>NocoDB 并不替代数据库，而是直接运行在 MySQL、PostgreSQL、SQL Server 等现有数据库之上，将原有表结构映射为可操作的表格界面。这种方式适合已经有数据库，但希望降低数据使用门槛的团队。</p><p><strong>以表格为核心的协作与数据维护体验</strong></p><p>系统提供类似电子表格的操作方式，用于数据录入、修改和查看，支持多人协作和基础权限控制，常被用于内部台账、配置表和业务数据维护等场景。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549398" alt="NocoDB2.png" title="NocoDB2.png" loading="lazy"/></p><p><strong>API 优先的数据访问方式</strong></p><p>NocoDB 为每个数据表自动生成 REST / GraphQL API，使其既可以作为内部协作界面使用，也可以作为其他系统的数据接口层，方便与现有应用或工具进行集成。</p><h2>真实应用场景</h2><p>不同业务、不同场景和不同行业，对应的组织内部系统形态往往并不相同，用于支撑业务流程的软件也各有差异。我们整理了 NocoBase 在不同行业中的实际应用情况，向你展示这些系统是如何被构建和使用的。</p><h3><strong>科技公司的项目管理</strong></h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549399" alt="ED-.png" title="ED-.png" loading="lazy"/></p><p>ED 是一家总部位于巴西的科技公司，在其内部交付和项目实施的过程中，基于 NocoBase 构建了一组用于支撑日常业务协作的内部系统，包括项目管理、工单处理和供应商管理等核心流程，用于统一管理交付过程中的数据、权限和流程。</p><ul><li><strong>项目管理平台</strong>：用于支撑客户交付项目的全流程管理，将项目数据、状态和协作关系集中到同一系统中。</li><li><strong>工单系统</strong>：面向外部支持与服务请求，用户可提交并跟踪工单，相关流程通过工作流自动触发处理。</li><li><strong>供应商管理系统</strong>：用于处理供应商发票上传与支付审批，通过数据建模和流程配置实现自动流转。</li></ul><p>💡阅读完整故事：<a href="https://link.segmentfault.com/?enc=N%2FGsr0H60qwnCkLY%2BcXJBQ%3D%3D.OWuaF9mvrsmlH7xL4Zecc95ALti4w30%2FYCxC5JBHu2oRAj5nSE%2Bs22nW2VMgXks5" rel="nofollow" target="_blank">ED 团队使用 NocoBase 构建统一的工单与交付管理系统</a></p><h3>制造业的设备运维管理</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549400" alt="BIEL.png" title="BIEL.png" loading="lazy"/></p><p>伯恩光学是一家全球消费电子行业的制造企业。因其生产线设备密集且流程复杂，伯恩需要一种方式将原本依赖纸质记录的设备点检流程搬到线上并实现实时管理。</p><p>基于 NocoBase，伯恩构建了设备点检系统，用于统一管理设备状态记录、故障处理历史和现场异常信息，同时实现现场人员与后台管理层的数据联通和流程协作，使设备维护数据可查询、可跟踪、可流转。</p><p>💡阅读完整故事：<a href="https://link.segmentfault.com/?enc=exnBCqDN4f%2BqEuBRO7BLLg%3D%3D.iTSys%2F86gD49X0%2Bc07xk%2Fzfpuo%2FUr9EOBfooZYWpCw3N1HPcQdlxpkho%2FJK39yIQ" rel="nofollow" target="_blank">伯恩光学使用 NocoBase 构建设备点检与现场信息管理系统</a></p><h3>房地产行业的人事管理</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549401" alt="HouseWell.png" title="HouseWell.png" loading="lazy"/></p><p>HouseWell 是日本 Century 21 系列房产中介网络中的领先企业，业务涵盖房地产买卖、租赁管理、翻新、保险咨询和 IT 服务等多个领域。随着企业规模扩大到 100 + 员工，原有人事、休假申请等流程仍依赖纸质或表格工具管理，效率低、错误多且不便追踪。</p><p>基于 NocoBase，HouseWell 团队快速搭建了行政与人事管理系统，将常见的后台流程数字化。例如，员工可通过在线表单提交休假申请，由审批者即时在线处理，实现无纸化流程；同时构建了可视化的人事信息模块，实时查看组织架构、岗位分布和招聘状态等数据</p><p>💡阅读完整故事：<a href="https://link.segmentfault.com/?enc=284TA6n%2FxZeimjwDHdiryA%3D%3D.Kw%2FGprlx6Lj%2Fzv8%2BOwk9AodD2m05jug3ooa%2F0Ie4iKSHjcRAMNNxLKYxg4Dl7VM8" rel="nofollow" target="_blank">HouseWell 使用 NocoBase 构建内部行政与人事管理系统</a></p><h3>医疗行业的任务管理</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549402" alt="Distinct HealthCare-.png" title="Distinct HealthCare-.png" loading="lazy"/></p><p>卓正医疗是一家在中国多城市运营的连锁全科医疗机构，探索“家庭医生式”服务模式，强调主动随访、个性化服务和长期医患关系管理。由于服务网络广泛、业务流程多样，传统系统难以支撑其高频、轻量且碎片化的业务需求，他们选择 NocoBase 来统一搭建内部业务工具。</p><p>基于 NocoBase，卓正医疗团队最先构建了随访管理系统，用于串联诊疗数据、历史医嘱、预约信息等内容，让医生和护理人员能在一个工作台上完成患者状态查看与任务创建。随着使用推广，多个部门的业务团队开始基于同一底座自行搭建不同工具，形成一个内部协作工具体系。</p><p>💡阅读完整故事：<a href="https://link.segmentfault.com/?enc=Ab%2FmOFLkUguQSEMKyp9ngA%3D%3D.bC6ayrCDQ3CjBLENGVhEB%2BIRhXgwdwVlZxRvRhwDyPHfWz56XU9PZJk2AdECpsM1FMHBIOVBo7SxCKi4BP2lBA%3D%3D" rel="nofollow" target="_blank">卓正医疗使用 NocoBase 构建随访与业务工具系统</a></p><p>如果这篇文章对你在轻量化企业级软件选型上有所启发，欢迎将它分享给感兴趣的朋友。</p><p>相关阅读：</p><ul><li><a href="https://link.segmentfault.com/?enc=P6XV3ADwTWdVn7UyDQPWyA%3D%3D.LC6L68pCl3ZSqxT3Z0keFYz%2FcjBxEHxzCgqf19b7eGgJXehU8EQI5Y1vYTFYYHYc3jvA48dW2knVGvvhAPxsIZADOoPivaN6tErDn2KH4Gxm%2BFu8gu54egFpNwyuPQND8metxIiqvBbu8bOEtp5uqQ%3D%3D" rel="nofollow" target="_blank">6 个替代 Excel 的企业内部管理软件</a></li><li><a href="https://link.segmentfault.com/?enc=MBVUHzjMbMSOIZREJKHCkQ%3D%3D.fEW%2FHsSiYY2NvdRZmS%2FXC5dmEJ%2B5DnJYYw3LhhVP7jHFSQhV49dCQP%2B6EKt2l2Ni74hIWbd11W011U%2FJ5rE3M6PvsiUL3hkfro3W8ASYVD4ysUXhFWHD%2B6joA8CEsdY2" rel="nofollow" target="_blank">开发者收藏！10 个减少重复 CRUD 的开源工具</a></li><li><a href="https://link.segmentfault.com/?enc=Yb%2BdrrlLiPmClcNbjCCEzA%3D%3D.%2B7w6RTw1yIQoBEqnvEJx0rk1TxRlX3DzrFQviLiWtsKlhMO5jLr8hPA%2B7MQ7mRI%2BNRKE9DuLokxwuHu%2FK4zUBH0MEwxxe9AD5Xy70YC%2B4lqXhvqPivIw2hKPxJ7c4Ep1" rel="nofollow" target="_blank">GitHub Star 数量前 12 的 AI 工作流项目</a></li><li><a href="https://link.segmentfault.com/?enc=uNmtSFNZNXH5RbObRd1ZxQ%3D%3D.r2WBQr08Tzy2ZNjc9kztF9EAmR16UQWd9BgcJ9awAYVvSvHEAAC49wuvG5nx%2F%2FdSzmgwzCJ0nV35G6LHLFo0Obm9pNVuwOf2NU4VdqtkI1t7CBk%2BnEiWZ9IHuaucTHtB" rel="nofollow" target="_blank">最适合外包交付的 6 个开源无代码与低代码</a></li><li><a href="https://link.segmentfault.com/?enc=gdasKp1DCCZvxujEcjZXqQ%3D%3D.An9Z0czC3z4bCu4ZsLZtplIVXhbrgRVFjILinolWbyLIDlHnX%2BhHDz9tRTyO5UFNAjtVgB92wJEb1FZUyDT2Wf2HwC9aHGkDWCf1zv8v4CaGY%2FHs4tkLbeK%2FAtAG0CS1" rel="nofollow" target="_blank">GitHub 上星星数量前 10 的 AI CRM 开源项目 </a></li><li><a href="https://link.segmentfault.com/?enc=AERTRYuPPaLs3FhfXWQY5A%3D%3D.19HiDvN9Z1tcCE0PqjmqZjoIHXjnj4BR457mjqY1NBAwCiqTn5EK0n%2BE5XmAy%2B%2BYq6BV%2BGJWJERCt3BY70bfMnixyTtMHXXng0WJQvkF4dLca%2FSQqcTHd0hN7i2WZECF" rel="nofollow" target="_blank">如何快速搭建一个替换 Excel 的系统？（完整指南）</a></li><li><a href="https://link.segmentfault.com/?enc=KtMnvwfoGuRPJzTVI%2B%2BFxQ%3D%3D.V7FxLeUUbSE3hZwAvOqu0Z%2FhZCEKfe1aPqRBUVtEB9hyACl9M3fGn68i8oUWnjpLnOoCgR31pMU2fE67ZOxXqlEJ6K7rirr1MLNAu%2BiXSz4%3D" rel="nofollow" target="_blank">GitHub Star 数量前 5 的开源 AI 内部工具</a></li><li><a href="https://link.segmentfault.com/?enc=EHpyj1IvQxJUVRILr5mtnA%3D%3D.N7IqL3UFPxtBRqqw5WwrrlGp1i%2BhFj7uv2AJNohceXj%2B%2BxKVD4nbKsfxLtyEmGvFtlbBihLDndEMMoUM15dzsnQDRr%2FonTwGKjmdAYfpkSvAOmFaBKojyJC%2B6LZ2oBOU86AM6CSvv8Kr2UliTElCHw%3D%3D" rel="nofollow" target="_blank">8 个最佳 Google Sheets 替代方案（附成本与能力分析）</a></li></ul>]]></description></item><item>    <title><![CDATA[2026-01-18 GitHub 热点项目精选 程序员锋仔 ]]></title>    <link>https://segmentfault.com/a/1190000047549429</link>    <guid>https://segmentfault.com/a/1190000047549429</guid>    <pubDate>2026-01-18 21:06:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>🌟 2026-01-18 GitHub Python 热点项目精选(12个)</h2><blockquote>每日同步 GitHub Trending 趋势，筛选优质 Python 项目，助力开发者快速把握技术风向标～</blockquote><hr/><h3>📋 项目列表（按 Star 数排序）</h3><h4>1. <a href="https://link.segmentfault.com/?enc=C20yPYRvLUbpDLoMZxYMJA%3D%3D.2IX9AXIOl9Yfdo8ZDa3viL3XPkwLBACR9Wnj2Z06qh0fhqsue9K4FEKbmBh%2BQ2%2Bf" rel="nofollow" target="_blank">google/langextract</a></h4><blockquote>LangExtract 是一个 Python 库，使用 LLM 从非结构化文本中提取结构化信息。它支持精确的源文本定位、可靠的结构化输出、对长文档的优化处理、交互式可视化等功能。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 21546（今日+445）</td></tr><tr><td>Fork 数</td><td>🔄 1496</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=reVSyvfkARvlZL2HWKtMYQ%3D%3D.FYuT0lpjgI40KiY0bwRTWWz4SXU5S%2Bt52zmkvOL2RwRYanFlHYuqzBSrH6JvR95f" rel="nofollow" target="_blank">https://github.com/google/langextract</a></td></tr></tbody></table><hr/><h4>2. <a href="https://link.segmentfault.com/?enc=IVNFPYli47skpZ%2B7iIeezA%3D%3D.5EvoWqccrsN1BgMg0g00kmv6YgNnAXamwjBl1BMVh3sAloesQ8ZOFfcDwT2icvVr" rel="nofollow" target="_blank">OpenBMB/VoxCPM</a></h4><blockquote>VoxCPM 是一个无需分词的文本到语音（TTS）系统，用于上下文感知的语音生成和逼真的语音克隆。它通过连续空间建模语音，克服了离散分词的限制。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 3789（今日+277）</td></tr><tr><td>Fork 数</td><td>🔄 442</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=m77tT9HaCT%2BVzOZo%2Btb5ug%3D%3D.N7ordvvGnuNyMSw2g4MGOX4ddm0wFFZxOp%2F5jBHfRP3ZS5B%2Fu3oToYZ2bANRk0qX" rel="nofollow" target="_blank">https://github.com/OpenBMB/VoxCPM</a></td></tr></tbody></table><hr/><h4>3. <a href="https://link.segmentfault.com/?enc=qL1%2FMJZY49C1365AWInWPw%3D%3D.6MC%2FI4vW2O0n19642cRllOpVrqrg0cDrZXf25YnhcLl4x4H%2F3VyjP9vBwHPYK8ar" rel="nofollow" target="_blank">sansan0/TrendRadar</a></h4><blockquote>TrendRadar 是一个舆情监控助手和热点筛选工具，聚合多平台热点和 RSS 订阅，支持关键词精准筛选。它还支持 AI 分析简报直推手机，并可接入 MCP 架构。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 43510（今日+98）</td></tr><tr><td>Fork 数</td><td>🔄 21596</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=Rv3n10JGdT8Cc7LdL60viA%3D%3D.3J0cOLL6D6rM5W4U2sxYxUaZGTamIIdDLbiQsQgpB%2B%2F9ysNUEtobhUMgkqP66z%2BZ" rel="nofollow" target="_blank">https://github.com/sansan0/TrendRadar</a></td></tr></tbody></table><hr/><h4>4. <a href="https://link.segmentfault.com/?enc=WG7n6QkAMy02gmcveO%2BqUw%3D%3D.EZG%2BVOFS4gAGzworZsBnzfBt5Yq67VujqKX%2FxX0905LZ94Ou7keKXFrD0HnHcb9j" rel="nofollow" target="_blank">paperless-ngx/paperless-ngx</a></h4><blockquote>Paperless-ngx 是一个社区支持的文档管理系统，可以将纸质文档转换为可搜索的在线档案。它支持扫描、索引和归档所有文档。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 35689（今日+34）</td></tr><tr><td>Fork 数</td><td>🔄 2258</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=dob5oQ16IGgeOuUpgXxVpw%3D%3D.jRdLHeNIghccQKYxqKcRzCh%2FYprLLVQv12TdN8lOkhg7GBDCpy7Kc%2FDmCombx79b" rel="nofollow" target="_blank">https://github.com/paperless-ngx/paperless-ngx</a></td></tr></tbody></table><hr/><h4>5. <a href="https://link.segmentfault.com/?enc=cYRFLgojol9ylRw90GZHSg%3D%3D.VavWVR6E%2BQSaq%2FPUcoV8mk2bx76dIBT3kkvPUbFO%2FXoOiXRK4y7CV1RdtR%2Bw7riO" rel="nofollow" target="_blank">anthropics/skills</a></h4><blockquote>Anthropic 的技能仓库，包含用于 Claude 的技能实现。这些技能通过动态加载指令、脚本和资源来提高 Claude 在特定任务上的表现。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 43804（今日+792）</td></tr><tr><td>Fork 数</td><td>🔄 4056</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=aruWtFSbnXmgf76rYo4Hgw%3D%3D.9bOojCv9EC2SOZy%2B%2FhGCDOexQnyAm0ZR%2B%2Fr7zbRyynmHRlOtfwftBLU0dnNuK%2BgO" rel="nofollow" target="_blank">https://github.com/anthropics/skills</a></td></tr></tbody></table><hr/><h4>6. <a href="https://link.segmentfault.com/?enc=jeuTqhiizOsC6nmHAJ8teA%3D%3D.tpPxnKv6M%2BN3m3SVOmRxjVQDJ4tzQCInGHMqkm46bTLEYdtJqeRoCK%2FJHfM19zLC" rel="nofollow" target="_blank">neuphonic/neutts</a></h4><blockquote>NeuTTS 是一个开源的、可在设备上运行的文本到语音（TTS）模型，具有即时语音克隆功能。它基于轻量级的 LLM 背骨构建，提供自然的语音合成和实时性能。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4541（今日+39）</td></tr><tr><td>Fork 数</td><td>🔄 483</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=7npsdiWN%2FAnCu3vqm9DAKg%3D%3D.3CzYdTJgFkTM5Qn0D%2F1p1lhn0ZedMjP3waRMOp6L%2FRVvr3EB6osk1vielYcYPXz5" rel="nofollow" target="_blank">https://github.com/neuphonic/neutts</a></td></tr></tbody></table><hr/><h4>7. <a href="https://link.segmentfault.com/?enc=dvydOso1z1paWxo66JihPg%3D%3D.QVsvlOUnvCcs%2Fw4%2FV6efWrUnC3eDOeGDlncl0cVgC1kjhvK8NbBe2HbVhKSc0MuE" rel="nofollow" target="_blank">ultralytics/ultralytics</a></h4><blockquote>Ultralytics YOLO 是一个基于 PyTorch 的深度学习框架，用于构建、训练和部署 YOLO 模型。它支持多种任务，包括目标检测、分割、分类和姿态估计。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 51891（今日+234）</td></tr><tr><td>Fork 数</td><td>🔄 9930</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=flz3nFuyXu6fzKYu9PV3gQ%3D%3D.J9KgK84lyROUzilg%2BSfh2UofyqWrMhsL8xWAfnyClYSyf0o3oXiSfwGD1NPDlgjf" rel="nofollow" target="_blank">https://github.com/ultralytics/ultralytics</a></td></tr></tbody></table><hr/><h4>8. <a href="https://link.segmentfault.com/?enc=J6kNUCCWLn8RQqU0IMoGHw%3D%3D.7fUx7UnGkcHaBoaRfo%2Fut7KSEWKbt%2FOjJqgzg2ufKwqb%2Fx3%2B69JhxR%2Ft9NeZ%2Bw4t" rel="nofollow" target="_blank">NVIDIA/physicsnemo</a></h4><blockquote>NVIDIA PhysicsNeMo 是一个开源的深度学习框架，用于构建、训练和微调物理 AI 模型。它提供了多种物理信息机器学习（Physics-ML）模型和优化的训练库。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 2295（今日+3）</td></tr><tr><td>Fork 数</td><td>🔄 552</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=XjMrHt0zm%2BZ454T2jJYenQ%3D%3D.uN1KTBqpu1A0BEQ0QorGWlNx1HMDbS%2BwjVUAsdQiWLwYtCH1sKHTXRQyg4ermIiu" rel="nofollow" target="_blank">https://github.com/NVIDIA/physicsnemo</a></td></tr></tbody></table><hr/><h4>9. <a href="https://link.segmentfault.com/?enc=OPdIzhNqnc8xMCkkWe07Hw%3D%3D.5Dv%2FkU%2BHoyEtcra59b9Bhj1HYQwdPpExH2nOj%2FBI8fgCUk%2FZ9urBZ%2FmTFfYMpzEn" rel="nofollow" target="_blank">Wirasm/PRPs-agentic-eng</a></h4><blockquote>PRPs-agentic-eng 是一个用于 AI 辅助开发的提示和工作流集合，专为 Claude Code 设计。它提供了生成产品需求文档（PRD）和实施计划的命令。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 1905（今日+7）</td></tr><tr><td>Fork 数</td><td>🔄 587</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=%2FU7JzJQ4F37UVB%2Bhl0A3PQ%3D%3D.Ym2ODP25xpor4OCkEzkm32%2Fgzgtw1KGBCsTUkjs1YkdSJGqM9JHPy5uBS5lI20Bk" rel="nofollow" target="_blank">https://github.com/Wirasm/PRPs-agentic-eng</a></td></tr></tbody></table><hr/><h4>10. <a href="https://link.segmentfault.com/?enc=mGxu97rDNGec8kWUVug8ug%3D%3D.VCe4HKUqvQJzwgcz0obFdGZi71TQAgOconvdqf7sZG5RVcDpxMRkx0jFcC8NGS%2BY" rel="nofollow" target="_blank">wagtail/wagtail</a></h4><blockquote>Wagtail 是一个基于 Django 的开源内容管理系统，专注于用户体验和灵活性。它提供了一个快速、吸引人的界面，支持多站点和多语言。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 20043（今日+4）</td></tr><tr><td>Fork 数</td><td>🔄 4369</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=1PX%2BzpqfYDvC8W87%2F8o5nw%3D%3D.t9a%2FSmekwjhXTt%2FRZive9X9TEWYxTwpXDVyZ%2B%2FX%2FYSCo1b%2F4Fr5gHis%2FRIaLVJN7" rel="nofollow" target="_blank">https://github.com/wagtail/wagtail</a></td></tr></tbody></table><hr/><h4>11. <a href="https://link.segmentfault.com/?enc=OF6JvJfyj8xY%2FP4%2FIh%2FalA%3D%3D.nmyl%2B%2B2jykTFuhpzT1itJwB9HzA7Iqxnbaz4zj%2FHjSwPySsqornTKV4IE9Zx63Le" rel="nofollow" target="_blank">prowler-cloud/prowler</a></h4><blockquote>Prowler 是一个开源的云安全平台，用于自动化云环境中的安全性和合规性。它提供了数百种现成的安全检查和合规框架。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 12653（今日+34）</td></tr><tr><td>Fork 数</td><td>🔄 1922</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=BAiyhMCKn2%2FMJrVNbpT71Q%3D%3D.%2Fh9HD5e2w5WT5e8Nq4rwaNBv69lrlUNx%2B%2FktxazFBNLxs73K7w6nXouW3rGBop1c" rel="nofollow" target="_blank">https://github.com/prowler-cloud/prowler</a></td></tr></tbody></table><hr/><h4>12. <a href="https://link.segmentfault.com/?enc=mlx3hgx3gAIgsNuQi1n4Dg%3D%3D.qX7IuuHIaUvGCmlW2uchz%2BJ%2FJhykiBr0Gxi2locGhHvxmwihlJsLR7HkE8LA4ZB8" rel="nofollow" target="_blank">jumpserver/jumpserver</a></h4><blockquote>JumpServer 是一个开源的特权访问管理（PAM）平台，为 DevOps 和 IT 团队提供通过 Web 浏览器安全访问 SSH、RDP、Kubernetes、数据库和 RemoteApp 端点的能力。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 29611（今日+66）</td></tr><tr><td>Fork 数</td><td>🔄 5632</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=9xJJi9X%2F%2B5CRhR2FuoMBsA%3D%3D.4v6v1KODK8%2FeFrTPvw%2BR%2FVpkm8W42R%2BsPEy00bqEIpKsvXgEVBtaplt%2BpH4A2OSJ" rel="nofollow" target="_blank">https://github.com/jumpserver/jumpserver</a></td></tr></tbody></table><hr/><h3>📝 说明</h3><ul><li>数据来源：GitHub Trending（2026-01-18 每日榜单）</li><li>筛选条件：Python 语言 + 当日热门项目</li><li>自动更新：每日同步最新趋势，建议收藏本文持续关注～</li></ul><h3>⭐ 推荐理由</h3><ol><li>热门项目代表当前技术趋势，学习价值高</li><li>优质项目代码规范，可作为学习参考</li><li>部分项目可直接用于实际开发，提高效率</li></ol>]]></description></item><item>    <title><![CDATA[【技术分享】douyin_one_spider：用python开发的一站式抖音数据采集gui界面软件]]></title>    <link>https://segmentfault.com/a/1190000047549440</link>    <guid>https://segmentfault.com/a/1190000047549440</guid>    <pubDate>2026-01-18 21:05:26</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>抖音聚合采集工具：一站式解决数据抓取与转换需求</h2><blockquote><em>本工具仅限学术交流使用，严格遵循相关法律法规，符合平台内容的合法及合规性，禁止用于任何商业用途！</em></blockquote><p>在数字化运营和内容分析的场景中，数据是决策的核心。针对抖音这一平台，我用python开发了一款集采集搜索、采集对标账号与转换于一体的聚合工具。这款软件旨在打破单一功能的局限，为用户提供高效、稳定的全流程解决方案。</p><h2>一、技术架构与实现</h2><p>本软件采用 Python 语言开发，通过直接调用接口协议（非模拟浏览器）来保证运行的稳定性与速度。</p><table><thead><tr><th align="left">序号</th><th align="left">模块</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><code>tkinter</code></td><td align="left">构建gui图形用户界面</td></tr><tr><td align="left">2</td><td align="left"><code>requests</code></td><td align="left">负责发送网络爬虫请求</td></tr><tr><td align="left">3</td><td align="left"><code>json</code></td><td align="left">解析服务器返回的响应数据</td></tr><tr><td align="left">4</td><td align="left"><code>pandas</code></td><td align="left">处理并保存为csv数据结果</td></tr><tr><td align="left">5</td><td align="left"><code>logging</code></td><td align="left">记录运行过程中的日志</td></tr></tbody></table><h3>模块化设计</h3><p>软件由三大核心模块组成：</p><ol><li><strong>请求与解析模块：</strong> 负责发送 HTTP 请求并解析 JSON 响应。</li><li><strong>数据存储模块：</strong> 负责将数据清洗并存入 CSV 文件。</li><li><strong>日志与GUI模块：</strong> 提供可视化界面及运行记录。</li></ol><h3>关键代码实现</h3><p><strong>1. 发送请求与基础解析</strong></p><p>通过 <code>requests</code> 库获取数据，并进行基础的 JSON 解析。</p><pre><code class="python"># 发送请求
r = requests.get(url, headers=h1, params=params)
# 解析数据
json_data = r.json()</code></pre><p><strong>2. 数据清洗与字段提取</strong></p><p>以“评论内容”为例，展示如何从复杂的数据结构中提取所需信息。</p><pre><code class="python"># 解析响应数据，以“评论内容”字段为例
for comment in comment_list:   
    # 评论内容
    text = comment['text']   
    text_list.append(text)</code></pre><p><strong>3. 自动数据保存机制</strong></p><p>采用分页实时保存策略，防止因程序异常中断导致数据丢失。</p><pre><code class="python"># 保存数据到DF
df = pd.DataFrame(
   {
    '目标链接': 'https://www.douyin.com/video/' + str(video_id),
    '页码': page,
    '评论者昵称': user_name_list,
    '评论者id': user_unique_id_list,
    '评论者uid': uid_list,
    '评论者主页链接': user_url_list,
    '评论时间': create_time_list,
    '评论IP属地': ip_list,
    '评论点赞数': like_count_list,
    '评论级别': cmt_level_list,
    '评论内容': text_list,
   }
)
# 保存到csv
if os.path.exists(self.result_file2):  # 如果文件存在，不再设置表头
   header = False
else:  # 否则，设置csv文件表头
   header = True   
   df.to_csv(self.result_file2, mode='a+', index=False, header=header, encoding='utf_8_sig')
   self.tk_show('视频[{}]第{}页评论已保存: {}'.format(video_id, page, self.result_file2))</code></pre><p><strong>4. 日志记录系统</strong></p><p>使用 logging 模块记录运行详情，方便用户回溯和排查问题。</p><pre><code class="python">def get_logger(self):    
    self.logger = logging.getLogger(__name__)    
    # 日志格式
    formatter = '[%(asctime)s-%(filename)s][%(funcName)s-%(lineno)d]--%(message)s'    
    # 日志级别
    self.logger.setLevel(logging.DEBUG)    
    # 控制台日志
    sh = logging.StreamHandler()    
    log_formatter = logging.Formatter(formatter, datefmt='%Y-%m-%d %H:%M:%S')    
    # info日志文件名
    info_file_name = time.strftime("%Y-%m-%d") + '.log'    
    # 将其保存到特定目录
    case_dir = r'./logs/'    
    info_handler = TimedRotatingFileHandler(filename=case_dir + info_file_name,                                        
                                          when='MIDNIGHT',                                        
                                          interval=1,                                        
                                          backupCount=7,                                        
                                          encoding='utf-8')</code></pre><p>版权声明界面：</p><pre><code class="python"># 版权信息
copyright = tk.Label(root, text='@马哥python说 All rights reserved.', font=('仿宋', 10), fg='grey')
copyright.place(x=290, y=625)</code></pre><p>以上。</p><h2>二、核心功能概览</h2><p>本工具严格遵循相关法律法规，仅限学术交流与合规数据分析使用。其核心功能涵盖了从评论挖掘到内容下载，再到ID转换的完整链条。</p><h3>1. 深度评论采集</h3><p>针对特定视频或话题下的评论区进行精准抓取，帮助用户挖掘用户画像与舆情反馈。</p><ul><li><strong>采集字段：</strong> 包含关键词、视频标题、作者信息、发布时间及详细的评论数据（如IP属地、评论级别、点赞数等）。</li><li><strong>输出格式：</strong> 自动生成 <code>搜索作品.csv</code> 和 <code>评论.csv</code> 文件。</li></ul><p><strong>功能界面展示：</strong><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549443" alt="image" title="image"/></p><p><strong>数据结果示例-作品：</strong><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549444" alt="image" title="image" loading="lazy"/></p><p><strong>数据结果示例-评论：</strong><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549445" alt="image" title="image" loading="lazy"/></p><h3>2. 主页作品全量采集</h3><p>支持根据达人主页链接，批量获取其发布的作品列表及相关数据。</p><ul><li><strong>采集字段：</strong> 涵盖作者昵称、粉丝数、视频标签、置顶状态、推荐数等17个关键字段。</li><li><strong>媒体下载：</strong> 支持自动下载主页视频文件，便于离线分析。</li></ul><p><strong>功能界面与结果：</strong></p><p>采集主页作品：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549446" alt="image" title="image" loading="lazy"/></p><p>主页作品数据：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549447" alt="image" title="image" loading="lazy"/></p><h3>3. 多格式链接与UID转换</h3><p>解决运营中常见的链接格式混乱问题，实现跨平台、跨端口的ID互转。</p><p><strong>转换功能演示：</strong></p><p>转换功能1，主页链接转抖音号：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549448" alt="image" title="image" loading="lazy"/></p><p>转换功能2，抖音号转主页链接（uid）：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549449" alt="image" title="image" loading="lazy"/></p><p>转换功能3，app端作品链接转pc端作品链接：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549450" alt="image" title="image" loading="lazy"/></p><hr/><h2>三、使用指南与注意事项</h2><h3>1. 环境准备</h3><p>系统支持： Windows / Mac（无需配置编程环境，直接运行）。<br/>Cookie 配置： 采集前需将有效的 Cookie 值填入软件目录下的 cookie.txt 文件中。</p><h3>2. 操作流程</h3><ul><li>登录软件： 启动程序并完成登录验证。</li><li>选择功能： 在界面中选择“评论采集”、“主页采集”或“转换工具”。</li><li>参数设置： 输入关键词、时间范围或目标链接。</li><li>启动执行： 点击「开始执行」，实时监控进度条。</li><li>查看结果： 采集完成后，数据文件将自动生成在软件所在文件夹内。</li></ul><h3>3. 稳定性保障</h3><ul><li>防丢包机制： 采集过程中，每完成一页请求即保存一次数据（间隔 1～2s），避免数据积压丢失。</li><li>异常处理： 内置完善的异常捕获逻辑，确保在网络波动时能记录错误日志而非直接崩溃。</li><li>免责声明： 本软件仅用于技术交流与数据分析，请严格遵守平台规则及国家法律法规，禁止用于任何商业截流或非法用途。</li></ul><h2>四、演示视频</h2><p>为了能让小白轻松上手使用，我特意录制了完整讲解视频，一看就明白：</p><blockquote>mp.weixin.qq.com/s/fDb21Rj_kKb_1GNHAJWyIQ</blockquote><h2>END、版权声明</h2><p>本软件及文章均为本人独立原创开发与编写。请尊重原创成果，严禁任何形式的二创、转载或盗发，违者必究！</p>]]></description></item><item>    <title><![CDATA[fdm_x64_setup_6.14.2.3973使用步骤详解（附安装与下载教程） 读书笔记 ]]></title>    <link>https://segmentfault.com/a/1190000047549464</link>    <guid>https://segmentfault.com/a/1190000047549464</guid>    <pubDate>2026-01-18 21:04:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><p>FDM 全称 Free Download Manager，是个<strong>免费下载工具</strong>，支持 HTTP、FTP、BT 种子、磁力链，还能断点续传、加速下载，比浏览器自带下载器好用多了。</p><p><code>fdm_x64_setup_6.14.2.3973.exe</code>是 64 位系统的安装包，版本号 6.14.2.3973，安装完就能用，没啥复杂的设置。</p><h2>一、准备工作</h2><ol><li><p><strong>下载安装包</strong>​</p><ul><li><strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=dwvQ%2F7Q48UJbtX7f6lMamw%3D%3D.WqdaKNf8SGNbCFKA4irOyCePC%2BIxAbjhmh2IPbWJY3tgpvFe%2FkfoQrpmru1lRAwY" rel="nofollow" title="https://pan.quark.cn/s/0f55bb965d1b" target="_blank">https://pan.quark.cn/s/0f55bb965d1b</a></li><li>确认文件大小（大概 40MB 左右），别下成其他版本。</li></ul></li><li><p><strong>关闭杀毒软件（可选）</strong> ​</p><ul><li>个别杀毒软件会误报，安装时可以先暂时关掉，装完再开。</li></ul></li></ol><h2>二、安装 FDM</h2><ol><li>双击 <code>fdm_x64_setup_6.14.2.3973.exe</code>运行。</li><li>选语言（默认 English，点下拉框选“简体中文”更方便）。</li><li>点  <strong>“Next”</strong> ​ 继续。</li><li><p>选安装位置：</p><ul><li>默认是 <code>C:\Program Files\Free Download Manager</code>，想改就点“Browse”选 D 盘或其他盘。</li></ul></li><li><p>选组件：</p><ul><li>一般全选（包括浏览器扩展，能接管浏览器下载），点“Next”。</li></ul></li><li><p>选附加任务：</p><ul><li>建议勾“创建桌面快捷方式”和“开机启动”（想省事就勾，不想要就取消），点“Next”。</li></ul></li><li>点  <strong>“Install”</strong> ​ 开始安装，等进度条走完。</li><li>最后点  <strong>“Finish”</strong> ​ 完成安装，FDM 会自动启动。</li></ol><h2>三、基本使用（下载文件）</h2><h3>1. 普通下载（HTTP/FTP）</h3><ul><li>复制文件下载链接（比如 <code>https://example.com/file.zip</code>）。</li><li>打开 FDM，点左上角  <strong>“添加”</strong> ​ 按钮（或按 <code>Ctrl+U</code>）。</li><li>粘贴链接，点“确定”，FDM 就开始下载了。</li><li>在下载列表里能看到进度、速度、剩余时间，还能暂停/继续/限速。</li></ul><h3>2. BT 种子/磁力链下载</h3><ul><li>点  <strong>“添加”</strong> ​ → 选“Torrent 文件”，找到 <code>.torrent</code>种子文件打开；</li><li>或者直接粘贴磁力链接（以 <code>magnet:</code>开头的），点“确定”；</li><li>FDM 会自动解析并开始下载 BT 任务。</li></ul><h3>3. 浏览器接管下载</h3><ul><li>安装时会提示安装浏览器扩展（Chrome、Edge、Firefox 都支持）。</li><li>装好后，在浏览器里点下载链接，会自动跳转到 FDM 下载，不用手动复制链接。</li></ul><h2>四、常用设置（优化体验）</h2><ol><li><p><strong>限速设置</strong>：</p><ul><li>右键下载任务 → “速度限制”，设最大下载速度和上传速度（不影响上网速度）。</li></ul></li><li><p><strong>更改下载目录</strong>：</p><ul><li>点顶部  <strong>“选项”→“常规”</strong> ，改“默认下载文件夹”（比如 <code>D:\Downloads</code>）。</li></ul></li><li><p><strong>开机启动</strong>：</p><ul><li>点  <strong>“选项”→“常规”</strong> ，勾“随 Windows 启动”，开机就能直接用。</li></ul></li><li><p><strong>批量下载</strong>：</p><ul><li>点  <strong>“文件”→“批量下载”</strong> ，粘贴多个链接（每行一个），一次性添加多个任务。</li></ul></li></ol><p>​</p>]]></description></item><item>    <title><![CDATA[[Teanary]流量统计实现方案及开发文档 xcalder ]]></title>    <link>https://segmentfault.com/a/1190000047549588</link>    <guid>https://segmentfault.com/a/1190000047549588</guid>    <pubDate>2026-01-18 21:03:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>流量统计功能文档</h2><p><img width="723" height="458" referrerpolicy="no-referrer" src="/img/bVdnFYZ" alt="" title=""/><br/>仓库地址:<a href="https://link.segmentfault.com/?enc=jw1s36WmRrhidzRWUZeWBQ%3D%3D.vtcv11MLEdC3G54N9fGXF3s%2FC%2FtnbKS4aufLW3n0qxJ8YKFXEf4flAvkCmvceOZc" rel="nofollow" target="_blank">https://gitee.com/teanary/teanary_service</a></p><h3>目录</h3><ul><li><a href="#功能概述" target="_blank">功能概述</a></li><li><a href="#功能特性" target="_blank">功能特性</a></li><li><a href="#技术架构" target="_blank">技术架构</a></li><li><a href="#配置说明" target="_blank">配置说明</a></li><li><a href="#使用方法" target="_blank">使用方法</a></li><li><a href="#数据管理" target="_blank">数据管理</a></li><li><a href="#常见问题" target="_blank">常见问题</a></li></ul><h3>功能概述</h3><p>流量统计功能用于统计网站前台的访问数据，包括真人访问和爬虫访问。系统会自动区分访问者类型，并记录详细的访问信息，帮助管理员了解网站的访问情况。</p><h4>主要功能</h4><ul><li>✅ 自动统计前台访问流量</li><li>✅ 区分真人访问和爬虫访问</li><li>✅ 识别爬虫来源（Google、Bing、Baidu等）</li><li>✅ 缓存数据，批量写入数据库（每5分钟）</li><li>✅ 自动清理过期数据（默认保留90天）</li><li>✅ 提供统计看板和详细列表页面</li></ul><h3>功能特性</h3><h4>1. 智能过滤</h4><p>系统会自动排除以下请求：</p><ul><li>❌ 管理后台（<code>/manager/*</code>）</li><li>❌ 个人中心（<code>/user/*</code>）</li><li>❌ API 路由（<code>/api/*</code>）</li><li>❌ 静态资源（<code>.css</code>, <code>.js</code>, <code>.jpg</code>, <code>.png</code> 等）</li><li>❌ 非 GET 请求</li></ul><h4>2. 爬虫识别</h4><p>系统能够识别以下类型的爬虫：</p><p><strong>搜索引擎爬虫：</strong></p><ul><li>Google (Googlebot)</li><li>Bing (Bingbot)</li><li>Baidu (Baiduspider)</li><li>Yandex (Yandexbot)</li><li>Yahoo (Slurp)</li><li>DuckDuckGo (Duckduckbot)</li><li>Sogou (Sogou)</li></ul><p><strong>社交媒体爬虫：</strong></p><ul><li>Facebook (Facebookexternalhit)</li><li>Twitter (Twitterbot)</li><li>LinkedIn (Linkedinbot)</li><li>Pinterest (Pinterestbot)</li></ul><p><strong>其他爬虫：</strong></p><ul><li>Semrush (Semrushbot)</li><li>Ahrefs (Ahrefsbot)</li><li>Majestic (Mj12bot)</li><li>Dotbot</li><li>以及其他通用爬虫（bot、crawler、spider等）</li></ul><h4>3. 数据记录</h4><p>每条流量记录包含以下信息：</p><ul><li><strong>路径</strong> (<code>path</code>): 访问的页面路径</li><li><strong>方法</strong> (<code>method</code>): HTTP 方法（通常为 GET）</li><li><strong>IP 地址</strong> (<code>ip</code>): 访问者的 IP 地址</li><li><strong>用户代理</strong> (<code>user_agent</code>): 浏览器或爬虫的用户代理字符串</li><li><strong>来源页面</strong> (<code>referer</code>): 来源页面的 URL</li><li><strong>语言</strong> (<code>locale</code>): 访问时使用的语言代码</li><li><strong>是否爬虫</strong> (<code>is_bot</code>): 是否为爬虫访问</li><li><strong>爬虫来源</strong> (<code>spider_source</code>): 爬虫的具体来源（如 google、bing 等）</li><li><strong>访问次数</strong> (<code>count</code>): 同一分钟内相同路径的访问次数</li><li><strong>统计时间</strong> (<code>stat_date</code>): 统计日期（精确到分钟）</li></ul><h3>技术架构</h3><h4>数据流程</h4><pre><code>用户访问 → TrackTraffic 中间件 → 缓存数据 → 批量写入队列 → 数据库</code></pre><h4>核心组件</h4><ol><li><p><strong>中间件</strong> (<code>TrackTraffic</code>)</p><ul><li>位置：<code>app/Http/Middleware/TrackTraffic.php</code></li><li>功能：拦截请求，记录流量数据到缓存</li></ul></li><li><p><strong>批量写入任务</strong> (<code>BatchWriteTrafficStatsJob</code>)</p><ul><li>位置：<code>app/Jobs/BatchWriteTrafficStatsJob.php</code></li><li>功能：每5分钟批量将缓存数据写入数据库</li></ul></li><li><p><strong>数据清理命令</strong> (<code>CleanOldTrafficStats</code>)</p><ul><li>位置：<code>app/Console/Commands/CleanOldTrafficStats.php</code></li><li>功能：清理超过指定天数的历史数据</li></ul></li><li><p><strong>数据模型</strong> (<code>TrafficStatistic</code>)</p><ul><li>位置：<code>app/Models/TrafficStatistic.php</code></li><li>功能：定义数据结构和查询方法</li></ul></li><li><p><strong>管理界面</strong></p><ul><li>统计看板：<code>app/Filament/Manager/Pages/TrafficStatistics.php</code></li><li>详细列表：<code>app/Filament/Manager/Resources/TrafficStatisticResource.php</code></li></ul></li></ol><h4>缓存机制</h4><ul><li>使用 Laravel Cache 存储临时流量数据</li><li>缓存键格式：<code>traffic:queue:Y-m-d-H-i</code></li><li>缓存过期时间：1小时</li><li>每5分钟批量写入一次数据库</li></ul><h3>配置说明</h3><h4>1. 中间件注册</h4><p>中间件已在 <code>routes/web.php</code> 中注册：</p><pre><code class="php">Route::prefix('{locale}')-&gt;middleware([
    SetLocaleAndCurrency::class, 
    \App\Http\Middleware\TrackTraffic::class
])-&gt;group(function () {
    // 前台路由
});</code></pre><h4>2. 定时任务配置</h4><p>在 <code>routes/console.php</code> 中已配置：</p><pre><code class="php">// 流量统计批量写入任务（每5分钟执行一次）
Schedule::command('app:batch-write-traffic-stats --queue')
    -&gt;everyFiveMinutes()
    -&gt;withoutOverlapping()
    -&gt;runInBackground();

// 流量统计数据清理任务（每天凌晨2点执行，清理90天前的数据）
Schedule::command('app:clean-old-traffic-stats')
    -&gt;dailyAt('02:00')
    -&gt;withoutOverlapping();</code></pre><h4>3. 数据库表结构</h4><p>表名：<code>traffic_statistics</code></p><p>主要字段：</p><ul><li><code>id</code>: 主键（雪花ID）</li><li><code>path</code>: 访问路径（索引）</li><li><code>method</code>: HTTP 方法（索引）</li><li><code>ip</code>: IP 地址（索引）</li><li><code>user_agent</code>: 用户代理</li><li><code>referer</code>: 来源页面</li><li><code>locale</code>: 语言代码（索引）</li><li><code>is_bot</code>: 是否为爬虫（索引）</li><li><code>spider_source</code>: 爬虫来源（索引）</li><li><code>count</code>: 访问次数</li><li><code>stat_date</code>: 统计时间（索引，精确到分钟）</li></ul><h3>使用方法</h3><h4>1. 查看统计看板</h4><ol><li>登录管理后台</li><li>导航到 <strong>统计</strong> → <strong>流量统计看板</strong></li><li><p>可以查看：</p><ul><li>总访问量、页面浏览量、独立IP、独立页面</li><li>真人访问和爬虫访问的对比</li><li>热门页面 Top 20</li></ul></li><li><p>支持筛选：</p><ul><li>日期范围：今天、昨天、最近7天、最近30天、最近90天</li><li>访问者类型：全部、真人访问、爬虫访问</li></ul></li></ol><h4>2. 查看详细列表</h4><ol><li>登录管理后台</li><li>导航到 <strong>统计</strong> → <strong>流量明细</strong></li><li>可以查看每条访问记录的详细信息</li><li><p>支持筛选：</p><ul><li>访问类型（真人/爬虫）</li><li>爬虫来源</li><li>日期范围</li></ul></li></ol><h4>3. 手动触发批量写入</h4><p>如果需要立即将缓存数据写入数据库，可以执行：</p><pre><code class="bash">php artisan app:batch-write-traffic-stats</code></pre><h4>4. 手动清理数据</h4><p>清理超过指定天数的数据：</p><pre><code class="bash"># 清理90天前的数据（默认）
php artisan app:clean-old-traffic-stats

# 清理30天前的数据
php artisan app:clean-old-traffic-stats --days=30

# 清理180天前的数据
php artisan app:clean-old-traffic-stats --days=180</code></pre><h3>数据管理</h3><h4>数据保留策略</h4><ul><li><strong>默认保留时间</strong>：90天</li><li><strong>清理时间</strong>：每天凌晨2点自动执行</li><li><strong>清理方式</strong>：分批删除，每批1000条记录</li></ul><h4>数据统计方法</h4><h5>获取指定时间范围内的统计数据</h5><pre><code class="php">use App\Models\TrafficStatistic;
use Illuminate\Support\Carbon;

// 获取最近7天的所有数据
$startDate = Carbon::today()-&gt;subDays(6);
$endDate = Carbon::today()-&gt;endOfDay();
$stats = TrafficStatistic::getStatsByDateRange($startDate, $endDate);

// 只获取真人访问数据
$humanStats = TrafficStatistic::getStatsByDateRange($startDate, $endDate, false);

// 只获取爬虫访问数据
$botStats = TrafficStatistic::getStatsByDateRange($startDate, $endDate, true);</code></pre><h5>获取热门页面</h5><pre><code class="php">// 获取最近7天的热门页面 Top 10
$topPages = TrafficStatistic::getTopPages($startDate, $endDate, 10);

// 只获取真人访问的热门页面
$topHumanPages = TrafficStatistic::getTopPages($startDate, $endDate, 10, false);

// 只获取爬虫访问的热门页面
$topBotPages = TrafficStatistic::getTopPages($startDate, $endDate, 10, true);</code></pre><h3>常见问题</h3><h4>Q1: 为什么有些访问没有被统计？</h4><p><strong>A:</strong> 系统会自动排除以下请求：</p><ul><li>管理后台和个人中心的访问</li><li>API 路由</li><li>静态资源文件</li><li>非 GET 请求</li></ul><p>如果您的访问路径符合以上条件，将不会被统计。</p><h4>Q2: 数据多久写入一次数据库？</h4><p><strong>A:</strong> 系统每5分钟自动批量写入一次。如果需要立即写入，可以手动执行 <code>php artisan app:batch-write-traffic-stats</code> 命令。</p><h4>Q3: 如何修改数据保留时间？</h4><p><strong>A:</strong> 有两种方式：</p><ol><li><strong>修改定时任务</strong>：编辑 <code>routes/console.php</code>，修改 <code>--days</code> 参数</li><li><strong>手动执行</strong>：执行 <code>php artisan app:clean-old-traffic-stats --days=天数</code></li></ol><h4>Q4: 爬虫识别不准确怎么办？</h4><p><strong>A:</strong> 可以修改 <code>app/Http/Middleware/TrackTraffic.php</code> 中的 <code>isBot()</code> 和 <code>getSpiderSource()</code> 方法，添加或修改爬虫识别规则。</p><h4>Q5: 如何查看缓存中的数据？</h4><p><strong>A:</strong> 可以使用 Laravel Tinker：</p><pre><code class="bash">php artisan tinker</code></pre><p>然后执行：</p><pre><code class="php">// 查看某个时间点的队列
Cache::get('traffic:queue:2026-01-17-14-30');

// 查看所有流量相关的缓存键（需要 Redis）
Redis::keys('traffic:*');</code></pre><h4>Q6: 数据量很大，会影响性能吗？</h4><p><strong>A:</strong> 系统采用了以下优化措施：</p><ul><li>使用缓存暂存数据，减少数据库写入频率</li><li>批量写入，每5分钟写入一次</li><li>使用索引优化查询性能</li><li>自动清理过期数据，控制数据量</li></ul><p>如果数据量仍然很大，可以考虑：</p><ul><li>缩短数据保留时间</li><li>增加批量写入频率</li><li>优化数据库索引</li></ul><h4>Q7: 如何禁用流量统计？</h4><p><strong>A:</strong> 从 <code>routes/web.php</code> 中移除 <code>TrackTraffic::class</code> 中间件即可。</p><h4>Q8: 可以统计其他路径吗？</h4><p><strong>A:</strong> 可以修改 <code>app/Http/Middleware/TrackTraffic.php</code> 中的 <code>shouldTrack()</code> 方法，调整过滤规则。</p><h3>相关文件</h3><ul><li>中间件：<code>app/Http/Middleware/TrackTraffic.php</code></li><li>批量写入任务：<code>app/Jobs/BatchWriteTrafficStatsJob.php</code></li><li>清理命令：<code>app/Console/Commands/CleanOldTrafficStats.php</code></li><li>数据模型：<code>app/Models/TrafficStatistic.php</code></li><li>统计看板：<code>app/Filament/Manager/Pages/TrafficStatistics.php</code></li><li>详细列表：<code>app/Filament/Manager/Resources/TrafficStatisticResource.php</code></li><li>数据库迁移：<code>database/migrations/2026_01_17_204550_create_traffic_statistics_table.php</code></li></ul><h3>更新日志</h3><h4>2026-01-17</h4><ul><li>✅ 初始版本发布</li><li>✅ 支持真人/爬虫区分</li><li>✅ 支持爬虫来源识别</li><li>✅ 自动批量写入和清理</li></ul><hr/><p><strong>文档版本</strong>：1.0  <br/><strong>最后更新</strong>：2026-01-17</p>]]></description></item><item>    <title><![CDATA[Burp Suite Professional 2026.1 发布，新增功能简介 sysin ]]></title>    <link>https://segmentfault.com/a/1190000047549908</link>    <guid>https://segmentfault.com/a/1190000047549908</guid>    <pubDate>2026-01-18 21:02:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Burp Suite Professional 2026.1 发布，新增功能简介</p><p>Burp Suite Professional 2026.1 (macOS, Linux, Windows) - Web 应用安全、测试和扫描</p><p>Burp Suite Professional, Test, find, and exploit vulnerabilities.</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=h9%2B1ywd1w0FGKrnE9jgVHw%3D%3D.3%2BE71dz0prMn%2BcfEbcvLVKurl42pRwlMe4SiJpCSR4tbD3WH4zy8bWtmY4i%2FJL84" rel="nofollow" target="_blank">https://sysin.org/blog/burp-suite-pro/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=LXhPQ3sLLZHHRLsz%2FBz2ig%3D%3D.eZRrVG%2BeasEvqZcHZ6wM5qutTHSn%2BTa032o%2Bi2b3Hj8%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>Burp Suite Professional，更快、更可靠的安全测试，领先的 Web 安全测试工具包。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044800612" alt="roadmap" title="roadmap"/></p><h2>Burp Suite Pro 简介</h2><p>Burp Suite Professional 是一套用于测试 web 安全性的高级工具集 —- 所有这些都在一个产品中。从一个基本的拦截代理到尖端的 Burp 扫描器，使用 Burp Suite Pro，正确的工具只需点击一下就可以了。</p><p>强大的自动化让您有更多的机会做您最擅长的 (sysin)，而 Burp Suite 处理容易实现的目标。先进的手动工具将帮助你识别目标更微妙的盲点。</p><p>Burp Suite Pro 是由一个研究团队开发的。这意味着在发布之前，发现成果已经包含在最新更新中。 pentesting 工具将使您的工作更快，同时让您了解最新的攻击向量。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044800613" alt="Burp Suite 专业版" title="Burp Suite 专业版" loading="lazy"/></p><h2>新增功能</h2><p>Professional / Community <strong>2026.1</strong></p><p>2026 年 1 月 16 日</p><p>本次版本引入了 <strong>Discover</strong> 选项卡、通过命令面板实现的更快表格导航、更智能的 SQL 注入检测、对 NTLM 的 SPNEGO 支持，以及其他改进内容，同时还包含一次 Java 更新和浏览器升级。</p><p>✅ <strong>使用全新的 Discover 选项卡探索 Burp</strong></p><p>已将原有的 <strong>Learn</strong> 选项卡替换为 <strong>Discover</strong>，这是一个经过精心策划的起点，旨在帮助你探索 Burp Suite 的全部潜力。Discover 会根据你所使用的版本重点展示关键功能、工作流程和学习资源 (sysin)，帮助你最大化利用当前可用的工具。</p><p>无论你是刚开始使用 Burp、在打磨成熟的工作流程，还是借助 Burp AI 提升技能，在 Burp 中始终都有新的内容值得探索。</p><p>✅ <strong>通过命令面板实现更快的表格导航</strong></p><p>现在，你可以使用命令面板在 Burp Suite 中的大多数表格里快速跳转到指定位置。新增了三个命令：</p><ul><li><strong>Go to top：</strong> 跳转到所选表格的第一行</li><li><strong>Go to bottom：</strong> 跳转到所选表格的最后一行</li><li><strong>Go to entry：</strong> 根据条目 ID 跳转到指定行</li></ul><p>这些功能让你在不滚动、不丢失当前位置、也无需反复调整过滤条件的情况下 (sysin)，更快速、更轻松地浏览大型表格。</p><p>✅ <strong>更智能的基于时间的 SQL 注入检测</strong></p><p>Burp Scanner 现在会过滤由 Web 应用防火墙（WAF）对可疑载荷进行延迟处理而导致的误报。这在此类场景下提升了对真实基于时间的 SQL 注入漏洞的检测准确性。</p><p>✅ <strong>通过 SPNEGO 支持 NTLM 身份验证</strong></p><p>Burp 现在可以配置为使用 SPNEGO 编码来处理 NTLM 令牌。</p><p>✅ <strong>Java 更新</strong></p><p>已将 Burp 使用的 Java 版本更新至 <strong>Java 25.0.1</strong>。</p><p>✅ <strong>浏览器升级</strong></p><p>已将 Burp 内置浏览器升级至 <strong>Chromium 143.0.7499.193</strong>（Windows 与 Mac），以及 <strong>143.0.7499.192</strong>（Linux）。</p><h2>下载地址</h2><p><strong>Burp Suite Professional 2026.1</strong>, 16 January 2026</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=KAiPA2uMk9TZJA2LbSFYGA%3D%3D.DO%2F771V2zuDMOofC9Ie2oxEp9sOJcyPJTicITlqWvSgr12rJAoesdtbXoKwFFVjE" rel="nofollow" target="_blank">https://sysin.org/blog/burp-suite-pro/</a></li></ul><table><thead><tr><th><strong>Architectures/Description</strong></th><th><strong>File name (Professional)</strong></th></tr></thead><tbody><tr><td>Apple Intel x64 Installer</td><td>burpsuite_pro_macos_x64_v2026_1.dmg</td></tr><tr><td>Apple ARM64/M Chips Installer</td><td>burpsuite_pro_macos_arm64_v2026_1.dmg</td></tr><tr><td>Linux x64 Installer</td><td>burpsuite_pro_linux_v2026_1.tgz</td></tr><tr><td>Linux ARM64 Installer</td><td>burpsuite_pro_linux_arm64_v2026_1.tgz</td></tr><tr><td>Windows x64 Installer</td><td>burpsuite_pro_windows-x64_v2026_1.exe</td></tr><tr><td>Windows ARM64 Installer</td><td>burpsuite_pro_windows-arm64_v2026_1.exe</td></tr></tbody></table><hr/><p><strong>for macOS</strong>：<a href="https://link.segmentfault.com/?enc=SinMJJ3EIpAzmK1ONqDpVA%3D%3D.e9q2chNfFtvp7Wm%2BLa%2Bb%2BCEnT0qfZxZO8Zt%2FwBD0PAaYActLDIcWnuuYt5lZXJWP" rel="nofollow" target="_blank">Burp Suite Professional 2026.1 for macOS x64 &amp; ARM64 - 领先的 Web 渗透测试软件</a></p><p><strong>for Windows</strong>：<a href="https://link.segmentfault.com/?enc=vMfqqtHmxWo3X57vUfCj5g%3D%3D.ht38WEF50LbD30Ac%2Bl8b%2BiNWYkue7hMHNLR7jxmyVk7i1XoAcf7iHlkmINEy6vXW" rel="nofollow" target="_blank">Burp Suite Professional 2026.1 for Windows x64 - 领先的 Web 渗透测试软件</a></p><p>更多：<a href="https://link.segmentfault.com/?enc=RfZo9%2BrQ%2FHbuxtOAkI%2B9GQ%3D%3D.J3b16w69MEkSxS4NpvB6k8mEQxlGY38hY9idMl3ZFeQ%3D" rel="nofollow" target="_blank">HTTP 协议与安全</a></p>]]></description></item><item>    <title><![CDATA[为什么所有主流LLM都使用SwiGLU？ 本文系转载，阅读原文
https://avoid.over]]></title>    <link>https://segmentfault.com/a/1190000047549917</link>    <guid>https://segmentfault.com/a/1190000047549917</guid>    <pubDate>2026-01-18 21:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>本文的目标是解释为什么现代LLM架构在前馈部分使用</p><pre><code>SwiGLU</code></pre><p>作为激活函数并且已经放弃了</p><pre><code>ReLU</code></pre><p>。</p><p>神经网络本质上是一系列矩阵乘法，如果我们堆叠线性层而不使用任何激活函数：</p><p>无论你堆叠多少层，它仍然只是一个线性变换，网络只能学习线性关系。</p><p>激活函数引入了<strong>非线性</strong>，使网络能够逼近复杂的非线性函数，这是深度学习表达能力的基础。</p><h2><strong>ReLU有什么问题？</strong></h2><pre><code>ReLU</code></pre><p>确实彻底改变了深度学习：</p><p>它简单、快速，并且解决了</p><pre><code>sigmoid</code></pre><p>或</p><pre><code>tanh</code></pre><p>等函数存在的梯度消失等问题。</p><p>虽然人们通常会列出使用</p><pre><code>ReLU</code></pre><p>时可能遇到的问题，比如神经元死亡等等，但这些问题要么是理论上的，要么在大多数情况下可以通过现代神经网络技术（批量归一化、自适应学习权重等）很好的避免。</p><p>不过在进入SwiGLU之前，我们先来看一个激活函数 <strong>Swish</strong>，它是 <strong>SwiGLU</strong> 的组成部分。</p><p>Swish是一个"自门控"激活函数：输入 (x) 乘以其自身的sigmoid <strong>σ(x)</strong>，它充当一个<strong>门</strong>，控制有多少输入能够通过。</p><p>看看门的行为：</p><p>当x非常负时：<strong>σ(x) ≈ 0</strong>，所以门是<strong>关闭的</strong>（抑制输出）</p><p>当x非常正时：<strong>σ(x) ≈ 1</strong>，所以门是<strong>完全打开的</strong>（几乎原样通过输入）</p><p>尽管公式稍微复杂一些，</p><pre><code>Swish</code></pre><p>的行为与</p><pre><code>ReLU</code></pre><p>非常相似。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549919" alt="" title=""/></p><h3><strong>Swish比ReLU更好吗？</strong></h3><pre><code>Swish</code></pre><p>被发现比</p><pre><code>ReLU</code></pre><p>效果更好，但就像深度学习中的许多事情一样我们并不确切知道为什么</p><pre><code>Swish</code></pre><p>效果更好，不过倒是可以总结出以下的区别：</p><p><strong>没有硬梯度截断</strong></p><p>看上面的图，主要区别就是它们如何处理负输入：</p><p><strong>ReLU</strong>：在零处硬截断</p><p>当x&lt;0时：输出 = 0 且 梯度 = 0。这就是神经元死亡问题（尽管如前所述，通常可以通过BatchNorm等现代技术来避免）</p><p><strong>Swish</strong>：平滑、渐进地趋近于零</p><p>对于负x：梯度渐近趋近于零，但对于有限值永远不会精确等于零/所以理论上神经元总是可以接收更新（尽管对于非常负的输入，更新可能可以忽略不计）</p><p><strong>平滑性</strong></p><pre><code>ReLU</code></pre><p>在x=0处有不连续性（导数从0跳到1）。</p><pre><code>Swish</code></pre><p>在任何地方都是无限可微的，这意味着梯度景观是平滑的。这种平滑性是否有助于</p><pre><code>Swish</code></pre><p>的性能还不是100%清楚但它可能有助于优化<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549920" alt="" title="" loading="lazy"/></p><h2>什么是门控线性单元（GLU）？</h2><p>下面就是</p><pre><code>SwiGLU</code></pre><p>的另外一个组件。让我们来谈谈 <strong>GLU</strong>。</p><p>其中：   </p><p>x是输入   </p><p>W 和 V 是权重矩阵   </p><p>b和c是偏置向量   </p><p><strong>⊙</strong> 是逐元素乘法   </p><p><strong>σ</strong> 是sigmoid函数</p><pre><code>GLU</code></pre><p>使用门控机制在这方面与</p><pre><code>Swish</code></pre><p>有些相似。而它们区别在于GLU不是对所有特征应用相同的变换（恒等变换）然后用固定函数（sigmoid）进行门控，而是使用两个独立的线性投影：</p><p><strong>xW+ b</strong> 这只是取输入并对其进行变换。它通常被称为 内容路径</p><p><strong>σ(xV + c)</strong>：这第二部分说明每个特征的内容应该让多少通过，因此它被称为 门路径</p><p>所以GLU</p><pre><code>实际上可以被认为是</code></pre><p>Swish` 的泛化</p><p>逐元素乘法 <strong>⊙</strong> 允许<em>门</em>选择<em>内容</em>的哪些元素可以通过。当 <strong>σ(xV + c)</strong> 接近0时，门可以完全抑制某些特征，而当 <strong>σ(xV + c)</strong> 接近1时则完全让其他特征通过。</p><h3>门控的具体示例</h3><p>假设我们有一个4维向量 <strong>x = [1.0, -0.5, 2.0, 0.3]</strong></p><p>GLU对同一个输入应用2个变换：</p><ol><li>通过内容路径对内容进行变换：<strong>xW + b</strong>。假设它产生 <strong>[2.0, -1.5, 3.0, 0.5]</strong>1. 第2个变换应该扮演门的角色：  <strong>σ(xV + c)</strong>。假设它产生 <strong>[0.9, 0.1, 0.95, 0.05]</strong></li></ol><p>GLU输出是它们的逐元素乘积：</p><p><strong>GLU output = [2.0 × 0.9, -1.5 × 0.1, 3.0 × 0.95, 0.5 × 0.05]  = [1.8, -0.15, 2.85, 0.025]</strong></p><p>得到的结果如下： </p><p><strong>特征1：</strong>内容为正（2.0），门值高（0.9）→ 强烈通过（1.8）</p><p><strong>特征2：</strong>内容为负（-1.5），门值低（0.1）→ 被阻挡（-0.15）   </p><p><strong>特征3：</strong>内容为正（3.0），门值非常高（0.95）→ 完全通过（2.85）   </p><p><strong>特征4：</strong>内容较小（0.5），门值非常低（0.05）→ 被抑制（0.025）</p><p>这样网络学习了复杂的决策规则："对于像x这样的输入，放大特征1和3，但抑制特征2和4。"</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549921" alt="" title="" loading="lazy"/></p><h2><strong>那么SwiGLU是什么？</strong></h2><p>现在我们有了所有的组成部分，</p><pre><code>SwiGLU</code></pre><p>（Swish门控线性单元）简单地结合了Swish和GLU：</p><p>它不是像GLU那样使用sigmoid作为门，而是使用Swish。这就是为什么它被称为 <strong>Swi</strong>sh + <strong>GLU</strong>。</p><p>那么公式的每个部分做什么呢？这与GLU的逻辑完全相同，改变的只是门控函数。</p><ul><li><strong>Swish(xW)</strong>：门——决定每个特征有多少可以通过</li><li><strong>xV</strong>：内容——正在传输的实际信息</li><li><strong>⊙</strong>：逐元素乘法——将门应用于内容<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549922" alt="" title="" loading="lazy"/></li></ul><h2>为什么SwiGLU效果这么好？</h2><p>从经验上看，SwiGLU在LLM中优于其他激活函数（尽管目前还不确定VLM的情况）。但为什么呢？</p><p><strong>乘法交互创建特征组合</strong></p><p>考虑每种架构计算的内容：</p><p><strong>标准FFN</strong>（ReLU/GELU）：</p><pre><code>output = activation(xW₁) @ W₂</code></pre><p>每个输出维度是激活特征的加权和，激活是<em>逐元素</em>应用的——特征在激活内部不会相互交互。</p><p><strong>SwiGLU FFN</strong>：</p><pre><code>output = (Swish(xW) ⊙ xV) @ W₂</code></pre><p>逐元素乘法 <strong>⊙</strong> 在两条路径之间创建乘积。如果我们用 <strong>g = Swish(xW)</strong> 和 <strong>c = xV</strong> 表示，那么在最终投影之前的输出维度 <strong>i</strong> 是 <strong>gᵢ × cᵢ</strong>。</p><p>这就是为什么这很重要：<strong>gᵢ</strong> 和 <strong>cᵢ</strong> 都是输入特征的线性组合（在Swish之前）。它们的乘积包含像 <strong>xⱼ × xₖ</strong> 这样的交叉项。网络可以学习 <strong>W</strong> 和 <strong>V</strong>，使得某些输入特征组合被放大或抑制。</p><p>这类似于为什么注意力机制很强大，注意力计算 <strong>softmax(QKᵀ)V</strong>，其中 <strong>QKᵀ</strong> 乘积捕获查询和键特征之间的交互。SwiGLU为FFN带来了类似的乘法表达能力。</p><p><strong>为什么不在门中使用sigmoid而是使用Swish？</strong></p><p>GLU使用sigmoid：<strong>σ(xW) ⊙ xV</strong>。sigmoid的问题在于它会饱和。对于大的正或负输入，<strong>σ(x) ≈ 1</strong> 或 <strong>σ(x) ≈ 0</strong>，且梯度 <strong>∂σ/∂x ≈ 0</strong>，门就会被“冻结”了。</p><p>Swish对于正输入不会饱和，它近似线性增长（就像</p><pre><code>ReLU</code></pre><p>）。这意味着：- 梯度通过门路径流动得更好 - 门可以调节而不仅仅是开/关切换</p><p><strong>平滑性</strong></p><p>另外就是SwiGLU是无限可微的，这种平滑性可能有助于优化稳定性。</p><h2>总结</h2><p>SwiGLU的强大来自于其门控机制和乘法交互。通过将输入分成两条路径并将它们相乘，网络可以学习哪些特征组合是重要的——类似于注意力机制如何通过 QKᵀ捕获交互。</p><p>结合Swish的非饱和梯度，这使得SwiGLU对于大型模型特别有效。</p><p><a href="https://link.segmentfault.com/?enc=0YOUz959gs53ZASkyR0Fuw%3D%3D.v86%2Fw9zTmWY7fiGxA0GBaV%2BNCuUyCC4Nj1CnXD21JU38Mqn7RnMFpY7QwouAyd4RYXTMnURKjcQ2nn7UGsvYPQ%3D%3D" rel="nofollow" target="_blank">https://avoid.overfit.cn/post/3fa28c75fb0b4874aa297defa145ec4a</a></p><p>作者：Safouane Chergui</p>]]></description></item><item>    <title><![CDATA[告别“伪数字化”：AI 正在重塑人才招聘格局 爱跑步的香蕉_cKtiNz ]]></title>    <link>https://segmentfault.com/a/1190000047550015</link>    <guid>https://segmentfault.com/a/1190000047550015</guid>    <pubDate>2026-01-18 21:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>告别“伪数字化”：AI 正在重塑人才招聘格局<br/>过去十年，HR 领域掀起了信息化与数字化浪潮，ERP 系统引入、自动化流程设计，让招聘、入离职等事务实现了“系统化”。但如今，当绝大多数职场人已习惯与 AI 协同工作时，许多企业的招聘仍停留在“流程电子化”的初级阶段——筛简历依赖关键词，面试凭借主观感觉，低效与错失良才成为常态。</p><p>真正的变革源于“生成式 AI”的深度融入。它不再是被动应答的工具，而是能主动洞察、生成问题、辅助决策的智能伙伴，在人才甄选的全新竞赛中，依靠直觉与经验的传统招聘模式正加速瓦解。<br/>传统招聘长期受“低效、主观、成本高”三大顽疾困扰，在激烈的市场竞争中愈发凸显弊端：业务部门急需人才，HR 却深陷海量简历无法高效筛选；面试安排耗时耗力，最终录用决策还可能依赖面试官的“眼缘”。这种不确定性，让企业付出了高昂的显性与隐性成本。<br/>AI 招聘系统的出现，为破解这一困境提供了有效路径。其核心优势集中在“精准可衡量”与“体验人性化”两大维度，重新定义了智能化招聘的标准。<br/>在精准度层面，先进的 AI 面试智能体成为核心引擎，让人才评估告别“凭感觉”的模糊地带。其评估结果通过了严格的效标效度与重测信度心理学检验，能与资深面试官达成高度一致，打分可直接作为关键招聘决策依据。具体来看，其一问多能，一道智能题目可同步评估多项核心胜任力，无缝衔接 HR 初筛与业务复试，使评估效率提升 50% 以上；能根据候选人的回答即时生成针对性追问，精准抓取关键信息，杜绝能力评估遗漏；可自动解析简历，定位关键成就与潜在模糊点，生成递进式提问链，既有效核实信息，也深度挖掘候选人真实潜力；同时覆盖沟通、协作等通用素质，还能针对编程、算法、财务、工程等专业领域精准测评，在解放 HR 的同时，减轻业务面试官初试阶段的重复劳动。<br/>在体验层面，优质的 AI 面试系统突破了传统 AI 面“生硬、机械”的短板，将每一次面试转化为雇主品牌的加分项。系统能精准感知候选人的语速、语调与情绪波动，像专业面试官一样引导候选人放松，充分展现真实能力，避免因紧张导致评价失真；全程无需手动操作“开始/结束”，系统自动识别语音起止，实现如真人交谈般自然的问答流转，沉浸感十足；通过领先的音画同步技术，让虚拟面试官的口型、表情与语音节奏完美匹配，彻底告别“纸片人”式的机械感，赋予交互温度；候选人可随时就职位、团队、文化等问题发起提问，AI 基于企业知识库给予准确、一致的解答，在评估的同时完成高效的雇主价值传递。<br/>当招聘进入智能化深水区，工具的选择直接影响人才竞争的胜负。AI 并非要取代传统招聘逻辑，而是通过技术赋能，构建出更精准、高效、人性化的人才甄选模式，推动招聘行业从“流程电子化”迈向“决策智能化”，为企业在人才战争中赢得先机。</p>]]></description></item><item>    <title><![CDATA[基于 YOLOv8 的多目标风力涡轮机、天线、烟囱、电力线检测识别项目 [目标检测完整源码] 南瓜 ]]></title>    <link>https://segmentfault.com/a/1190000047549777</link>    <guid>https://segmentfault.com/a/1190000047549777</guid>    <pubDate>2026-01-18 18:02:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>基于 YOLOv8 的风电场多目标【风力涡轮机、天线、烟囱、电力线】智能感知平台实战 [目标检测完整源码]</h2><h3>一、背景与问题定义</h3><p>在新能源与大型基础设施快速扩张的背景下，<strong>风力发电场及其周边设施的智能化巡检</strong>逐渐成为行业刚需。实际工程中，运维人员不仅需要关注风力涡轮机本体状态，还需要同步识别和监控以下典型目标：</p><ul><li>风力涡轮机（Wind Turbine）</li><li>输电相关设施（Power Line）</li><li>场区内通信设施（Antenna）</li><li>高耸固定构筑物（Chimney）</li></ul><p>这些目标往往 <strong>尺度差异大、背景复杂、分布稀疏</strong>，同时又存在航拍、固定摄像头、远距离拍摄等多样化数据来源，给传统规则算法带来了明显挑战。</p><p>因此，本文从<strong>工程落地视角</strong>出发，介绍一套基于 <strong>YOLOv8 的多目标检测系统</strong>，并通过桌面级可视化工具，将模型能力转化为可直接使用的检测应用。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549779" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><h3>源码下载与效果演示</h3><p>哔哩哔哩视频下方观看：<br/><a href="https://www.bilibili.com/video/BV1uigVzaETc/" target="_blank">https://www.bilibili.com/video/BV1uigVzaETc/</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549780" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/>包含：</p><p>📦完整项目源码</p><p>📦 预训练模型权重</p><p>🗂️ 数据集地址（含标注脚本</p><h3>二、整体技术方案概览</h3><p>系统整体采用「<strong>深度学习模型 + 工程化应用层</strong>」的双层架构设计：</p><h4>2.1 技术选型</h4><ul><li><strong>检测模型</strong>：YOLOv8（Detection 分支）</li><li><strong>推理框架</strong>：PyTorch / Ultralytics</li><li><strong>可视化层</strong>：PyQt5 桌面 GUI</li><li><strong>输入形式</strong>：图片 / 视频 / 文件夹 / 实时摄像头</li><li><strong>输出结果</strong>：目标类别、边界框、置信度、可保存结果</li></ul><p>该方案的核心目标并非单纯追求模型指标，而是强调：</p><blockquote><strong>“模型可复现、系统可运行、能力可扩展”</strong></blockquote><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549781" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>三、多目标检测的工程挑战与应对</h3><h4>3.1 目标尺度与形态差异大</h4><p>在风电场场景中，不同目标在图像中的表现差异显著：</p><ul><li>风力涡轮机：体量大，但可能被远距离拍摄压缩</li><li>电力线：细长结构，容易被背景淹没</li><li>天线 / 烟囱：形态相似但语义不同</li></ul><p><strong>应对策略：</strong></p><ul><li>使用 YOLOv8 的 <strong>Anchor-Free 机制</strong>，减少人为先验限制</li><li>在训练阶段引入多尺度数据增强</li><li>保持类别定义清晰，避免语义重叠<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549782" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549783" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></li></ul><hr/><h4>3.2 多数据源统一推理问题</h4><p>系统需要同时支持：</p><ul><li>单张图片离线检测</li><li>视频逐帧分析</li><li>摄像头实时流推理</li><li>文件夹批量处理</li></ul><p>为此，在工程实现中对推理模块进行了统一封装，使不同输入仅在数据读取层存在差异，而 <strong>模型推理与结果渲染逻辑保持一致</strong>。</p><hr/><h3>四、YOLOv8 模型训练流程解析</h3><h4>4.1 数据组织规范</h4><p>采用标准 YOLO 数据格式，保证训练与部署阶段的一致性：</p><pre><code>dataset/
├── images/
│   ├── train/
│   └── val/
├── labels/
│   ├── train/
│   └── val/</code></pre><p>标注文件以归一化坐标形式存储，支持快速扩展新类别。</p><hr/><h4>4.2 训练策略要点</h4><p>在实际训练过程中，重点关注以下指标：</p><ul><li><strong>box_loss</strong>：目标定位精度</li><li><strong>cls_loss</strong>：多类别区分能力</li><li><strong>dfl_loss</strong>：边界框分布学习效果</li><li><strong>mAP@0.5</strong>：工程可用性的关键参考指标</li></ul><p>当 mAP@0.5 稳定在较高区间后，即可进入部署阶段，而不必过度追求理论最优。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549784" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549785" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>五、从模型到系统：PyQt5 可视化集成</h3><h4>5.1 为什么要做 GUI？</h4><p>在大量工业与能源场景中，最终使用系统的往往不是算法工程师，而是：</p><ul><li>运维人员</li><li>项目管理人员</li><li>教学与演示用户</li></ul><p>通过 PyQt5 构建桌面界面，可以显著降低使用门槛，实现：</p><ul><li>零命令行操作</li><li>一键切换输入源</li><li>实时可视化检测结果</li><li>自动保存检测输出</li></ul><hr/><h4>5.2 系统功能模块划分</h4><p>GUI 层主要包含：</p><ul><li>数据输入管理模块</li><li>模型推理调度模块</li><li>结果渲染与保存模块</li><li>运行状态控制模块</li></ul><p>这种模块化设计为后续功能扩展（如目标统计、轨迹分析）预留了接口空间。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549786" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>六、典型应用场景分析</h3><p>该系统可直接或间接应用于以下场景：</p><ul><li>风电场日常巡检辅助</li><li>输电线路安全监测</li><li>新能源场站规划分析</li><li>计算机视觉教学与实验</li><li>多目标检测算法对比研究</li></ul><p>通过更换数据集与类别配置，同一套系统可快速迁移至其他垂直领域。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549787" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>七、总结与展望</h3><p>本文从真实工程需求出发，介绍了一套 <strong>基于 YOLOv8 的风电场多目标检测系统</strong>，不仅覆盖模型训练与推理，还重点展示了如何将算法能力转化为 <strong>可直接使用的应用级系统</strong>。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549788" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>该方案的核心价值体现在：</p><ul><li>模型性能与工程可用性的平衡</li><li>深度学习与桌面应用的有效融合</li><li>对复杂基础设施场景的良好适配能力</li></ul><p>未来，该系统可进一步向以下方向演进：</p><ul><li>无人机航拍视频专项优化</li><li>多目标长期跟踪与状态分析</li><li>ONNX / TensorRT 推理加速</li><li>云端与边缘设备协同部署</li></ul><p>对于希望将 YOLOv8 应用于 <strong>新能源、能源巡检或大型设施智能感知</strong>的开发者而言，这是一条可复用、可扩展、可落地的实践路径。</p>]]></description></item><item>    <title><![CDATA[Python 的内置函数 filter 不爱吃香菜 ]]></title>    <link>https://segmentfault.com/a/1190000047549833</link>    <guid>https://segmentfault.com/a/1190000047549833</guid>    <pubDate>2026-01-18 18:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>Python 的内置函数 <a href="https://link.segmentfault.com/?enc=10nHDRFSIoKpDIwtbq841Q%3D%3D.7Q%2B9YKMkjMylXFJCVHWvxc4Swo002x%2B%2FHC8XUD7CIYOGNY3xV71Cuwgwdrbrsw9jUsaR0c8ByWhekQudW3aH5PSfgDr0%2FiTFOIa3tiw5wtOOFpcoYej6yu5KYFKH%2B%2BCcoP%2BzYbknB1FiTRK4hHOj0g%3D%3D" rel="nofollow" target="_blank"><code>filter()</code></a> 是一个非常有用的高阶函数，它能够根据指定的条件对可迭代对象进行筛选，返回一个迭代器。<a href="https://link.segmentfault.com/?enc=L2j61FMLywb0eADwtzTVDw%3D%3D.%2BKX8ihpYjp5LMNSyWH9cQv%2ByQDUybP1eu%2FlAb9fAU4Z%2FFgAwCf1Y%2FjO8BfArep1oMp3u3s5j97C8xi6Fh5kjcyCTgReJxRKaal6APTgzFDQfHP6JLPubiumb0sVFoF%2FMFC3h5xvoJwuXIiP164ovTg%3D%3D" rel="nofollow" target="_blank"><code>filter()</code></a> 函数的基本语法如下：</p><pre><code class="python">filter(function, iterable)</code></pre><h3>参数说明：</h3><ul><li><strong>function</strong>：用于筛选的函数。该函数接受一个参数，返回一个布尔值（<code>True</code> 或 <code>False</code>）。如果 <code>function</code> 为 <code>None</code>，则 <a href="https://link.segmentfault.com/?enc=wC8qHyjnAz0YNOf4ufgM4g%3D%3D.tnUeOR6dhb77AfmMMRxShoFYi9SlHZLe0PLnX2h8WYOEGRKQRrqJLW3sLLdnx9h%2BBdxF2%2BG4d1IpJiJu6B8yKU5o3LGcHlmioWseu9vzxwOzGl76gJRoQa4LDBjLznQxbNNthvOw5NcjCa6RH8g8Kg%3D%3D" rel="nofollow" target="_blank"><code>filter()</code></a> 会筛选出 <code>iterable</code> 中所有为 <code>True</code> 的元素。</li><li><strong>iterable</strong>：需要被筛选的可迭代对象，如列表、元组、集合等。</li></ul><h3>返回值：</h3><p><a href="https://link.segmentfault.com/?enc=toS72dRWJsaG%2BG8E82sO3w%3D%3D.Fg0WFLbT2iWSXgCNoMb%2BI11%2FSSfCmawaq9MxSPt%2BLdiZa9IaYZFD9Nb7P%2BoWxx8ppte0%2BVTDONBJGpao93rh6vY13rxx0hLFfdYiD31BNIjeTgSewzzIzQVKtqV9YFe6ebHfIXnue0IOgsdF7ow2SQ%3D%3D" rel="nofollow" target="_blank"><code>filter()</code></a> 返回一个迭代器，包含 <code>iterable</code> 中所有满足 <code>function</code> 条件的元素。</p><h3>示例：</h3><ol><li><p><strong>基本使用</strong>：筛选列表中的偶数</p><pre><code class="python">numbers = [1, 2, 3, 4, 5, 6]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # 输出: [2, 4, 6]</code></pre></li><li><p><strong>使用 <code>None</code> 筛选真值</strong>：</p><pre><code class="python">values = [0, 1, False, True, None, "", "hello"]
truthy_values = filter(None, values)
print(list(truthy_values))  # 输出: [1, True, "hello"]</code></pre></li><li><p><strong>结合自定义函数</strong>：</p><pre><code class="python">def is_positive(x):
 return x &gt; 0

numbers = [-2, -1, 0, 1, 2]
positive_numbers = filter(is_positive, numbers)
print(list(positive_numbers))  # 输出: [1, 2]</code></pre></li></ol><h3>应用场景：</h3><ul><li><strong>数据清洗</strong>：从数据集中筛选出符合特定条件的数据。</li><li><strong>条件过滤</strong>：在数据处理流程中动态筛选需要的元素。</li><li><strong>惰性计算</strong>：<a href="https://link.segmentfault.com/?enc=u540nZ10fUF5htQIKpzY3w%3D%3D.hix9W%2Bc6xfVN1RJkDHbGowPqopFr9q0n8B5p9F902%2B%2BhS817%2F8RYvjF9AY%2BI%2F23l3IvDPfnu9Wsgu52Bqkf9rCee6RbYiwIWVDN%2Fk7gN8HzWul4tt9PZEjYj8vKWakxEGtWR1WORa%2FO2TW%2FDFjHCvA%3D%3D" rel="nofollow" target="_blank"><code>filter()</code></a> 返回的是迭代器，适合处理大型数据集，避免一次性加载所有数据到内存。</li></ul><h3>注意事项：</h3><ul><li><a href="https://link.segmentfault.com/?enc=qbcVCdcBeH0aN5NboX2Eqw%3D%3D.LWYA6bA1TinCYLqB2r2lM6cG2xnuhYkJnyglziloR57F9aIV1Q48M%2F2OUrSHf7aSf4rL1k9A%2FRPW%2B7exzaTRxr9WDc%2BipUEQ3KsuiTcYOhq0kY%2BqVJ%2Fk13XC9B6lc52mQ9PzkUeXIaZW3KCWolDOzA%3D%3D" rel="nofollow" target="_blank"><code>filter()</code></a> 返回的是一个迭代器，如果需要列表或其他数据结构，可以使用 <a href="https://link.segmentfault.com/?enc=k3WBhB%2FcgKaiJ6PJG8xTMw%3D%3D.wgZV%2BBFLV9owM9zxqKgGnlNh%2Bl%2BOqTlV5AFb0uY%2FXyTBv%2FT6cWnFBDDXQmgdugSdfyHBce8Rs9pIIJpvqsJgGHbqVoo6bHZUf%2F1kz26bTlNVCKcBstSOAefQEVbzKGpx59B%2BjBjOtgXqYhcSH%2BPfgQ%3D%3D" rel="nofollow" target="_blank"><code>list()</code></a> 或其他转换方法。</li><li>与列表推导式相比，<a href="https://link.segmentfault.com/?enc=2pArEop6OqVzMVmHpXnsLg%3D%3D.L7jmIJQiGT1oMDIJzUbLXlZv40ylTUzzG7Z42ZdBgswDEFl9wpI0TUp2N1D%2Fz3jcfbI%2BurTGJn2%2BE52jDmUSWmYEkXxBF1TUmTLPlxY0aiJ6hYqYSe8DvfhP48%2FAtYCVDt9P1uxGFUsoQerfJ03RiQ%3D%3D" rel="nofollow" target="_blank"><code>filter()</code></a> 在语法上可能更简洁，但性能差异通常不大。选择哪种方式取决于具体场景和个人偏好。</li></ul><p>通过合理使用 <a href="https://link.segmentfault.com/?enc=CdDN9UzyMsFbg6p%2F%2BHYWGA%3D%3D.sCBdxOd%2F38sslAmTXLZgGVMlogE03WF740yLWuKRBccoud5b1jYM81EhsZss8nk%2Fz5cX36Max2JH32gyAb%2FFJfYyNiIjz7LIqZXNnLJjBJ%2B2wPSkTKy4i0IkwAxanwePFvK6KKnzbs2v7M6FZVcRrg%3D%3D" rel="nofollow" target="_blank"><code>filter()</code></a>，可以简化代码逻辑，提高可读性，尤其是在处理复杂的数据筛选条件时。</p>]]></description></item><item>    <title><![CDATA[移动ERP系统有哪些、怎么选？ SaaS圈老马 ]]></title>    <link>https://segmentfault.com/a/1190000047549715</link>    <guid>https://segmentfault.com/a/1190000047549715</guid>    <pubDate>2026-01-18 17:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>今天，我就结合自己多年的观察和真实的客户反馈，给大家深度测评了7款国内主流的移动ERP系统：用友、<strong>支道</strong>、金蝶、浪潮、管家婆、鼎捷软件。帮你拨开迷雾，找到最适合自己的那一款。</p><p><strong>测评维度说明</strong></p><p>在具体介绍之前，先说说我的测评标准，主要看这几点：</p><p><strong>1、移动体验</strong>：APP好不好用，功能全不全，是不是仅仅把网页版搬过来？</p><p><strong>2、核心功能</strong>：进销存、财务、生产等关键模块是否扎实？</p><p><strong>3、灵活性与扩展</strong>：企业业务变了，系统能不能跟着变，改起来贵不贵、难不难？</p><p><strong>4、实施与服务</strong>：买完软件只是开始，后续服务跟不跟得上？</p><p><strong>5、性价比</strong>：综合考虑投入产出，是不是“值回票价”？</p><p>好了，话不多说，直接上干货。</p><p><strong>1、用友</strong></p><p>其近年来力推的用友YonSuite就是一款面向成长型企业的云ERP。</p><p><strong>优点：</strong></p><p><strong>财务功底深厚</strong>：如果公司对财务合规、多准则核算要求非常高，可以尝试用友，它的财务模块逻辑严谨，审计线索清晰。</p><p><strong>品牌信誉度高</strong>：上市公司、<strong>大型集团采购时</strong>选它不容易出错，品牌背书强。</p><p><strong>需要注意：</strong></p><p><strong>“重”实施</strong>：标准产品功能复杂，往往需要<strong>较长的实施周期和较高的咨询费用</strong>才能用好。</p><p><strong>移动端体验</strong>：功能虽然全面，但部分操作流程可能仍带有传统PC软件的思维，移动端的交互流畅度和简洁性有优化空间。</p><p><strong>定制成本</strong>：标准产品之外的个性化开发，通常需要通过原厂或伙伴进行，周期和成本都比较高。</p><p><strong>小结</strong>：适合业务已经相对规范、尤其注重财务体系、且预算较为充足的中型及以上企业。对于追求极致灵活和快速上手的初创型公司来说，可能会觉得有点“重”。<br/><img width="723" height="310" referrerpolicy="no-referrer" src="/img/bVdnF0W" alt="" title=""/></p><p><strong>2、支道</strong></p><p><a href="https://link.segmentfault.com/?enc=UhIdYCjkONl4aUTIJkALHQ%3D%3D.CrlLLKJ4pWGrU4Ql28BE5fEkXKLi58VglkshmHgRbVA%3D" rel="nofollow" target="_blank">https://www.zdsztech.com</a></p><p>第二款要重点说的，是近几年在成长型企业中口碑上升很快的<strong>支道</strong>。</p><p>它的核心思路非常独特——它首先是<strong>一个强大的无代码开发平台，</strong>然后才是<strong>基于这个平台构建的、覆盖CRM、ERP、项目管理等全套应用</strong>。</p><p><strong>核心优势</strong>：</p><p><strong>真正的“业务主导”</strong>：这是我把它排在前面推荐的核心原因。它用“拖拉拽”的方式配置表单、流程和报表，<strong>业务管理员自己就能快速修改，无需等待IT开发</strong>。这在需求多变的成长型企业里，简直是“救命”功能。</p><p><strong>移动端体验原生且统一</strong>：因为所有应用都构建在同一个平台上，所以<strong>移动APP</strong>的体验很一致，<strong>功能完整</strong>，不是阉割版。</p><p><strong>“一站式”覆盖广</strong>：它不仅能做传统的进销存财务（ERP），还能搭建项目管理系统、售后服务工单、设备资产管理等，一个平台解决大部分问题，<strong>数据天然互通</strong>。</p><p><strong>性价比模式</strong>：它采用“平台账号+实施服务”的模式。没有按功能模块的层层加价，一旦平台能力掌握在企业自己手里，后续的调整成本极低。并且支持公有云、私有化、本地化多种部署方式，满足不同企业对数据安全的需求。</p><p><strong>适合</strong>：</p><p>1、<strong>业务处于快速发展期、流程经常调整</strong>的制造、贸易、工程服务等行业公司。</p><p>2、<strong>没有专业IT团队</strong>，但又希望系统能紧密贴合自己业务的企业。</p><p>3、对<strong>移动办公依赖度高</strong>，希望老板和员工都能在手机端高效处理核心业务的团队。<br/><img width="723" height="305" referrerpolicy="no-referrer" src="/img/bVdnF0Y" alt="" title="" loading="lazy"/></p><p><strong>3、金蝶</strong></p><p>它的云产品“金蝶云·星空”在中端市场占有率很高，移动端应用“云之家”也整合得比较深入。</p><p><strong>优点</strong>：</p><p><strong>在制造业ERP领域积淀深</strong>：尤其是生产管理、物料需求计划等模块，有大量的行业实践和模板。</p><p><strong>云之家协同能力强</strong>：将ERP审批、报表与企业的即时通讯、日程协同打通的比较好，方便内部协作。</p><p><strong>生态伙伴多</strong>：拥有庞大的实施开发伙伴体系，在全国各地都能找到服务商。</p><p><strong>需要注意</strong>：</p><p>与用友类似，<strong>标准化产品对于微小企业仍显复杂</strong>，需要一定的实施才能用起来。</p><p>深度个性化定制同样面临成本高、周期长的问题。<br/><img width="723" height="308" referrerpolicy="no-referrer" src="/img/bVdnF0Z" alt="" title="" loading="lazy"/></p><p><strong>4、浪潮</strong></p><p><strong>浪潮</strong>的ERP在国资企业、大型集团企业中有着显著优势。它的 “浪潮云ERP” 强调集团财务管控、资金管理和大数据分析。</p><p><strong>优点</strong>：</p><p><strong>集团管控能力突出</strong>：非常适合多分子公司、需要统一财务政策、合并报表的大型集团。</p><p><strong>符合国资监管要求</strong>：在产品设计上对国资监管要求理解深入。</p><p><strong>高性能与安全</strong>：在应对海量数据、高并发访问方面有优势，且安全合规性级别高。</p><p><strong>需要注意</strong>：</p><p>产品重心偏向中大型客户，对于小微企业的<strong>易用性和起步成本</strong>可能不是最优选。</p><p>移动端功能更侧重于<strong>数据查询和审批</strong>，复杂的业务录入可能仍需在PC端完成。<br/><img width="723" height="265" referrerpolicy="no-referrer" src="/img/bVdnF00" alt="" title="" loading="lazy"/></p><p><strong>5、管家婆</strong></p><p>它的“管家婆云ERP”操作简单，主打“傻瓜化”，让老板能快速管好货和钱。</p><p><strong>优点</strong>：</p><p><strong>上手极快</strong>：功能聚焦在进销存和简单财务，界面直观，培训成本低，非常适合没有任何软件使用基础的个体老板或小团队。</p><p><strong>价格亲民</strong>：采用按年订阅，初始投入很低。</p><p><strong>移动开单方便</strong>：针对批发零售场景，业务员手机开单、查库存、查价格的功能做得很实用。</p><p><strong>需要注意</strong>：</p><p><strong>功能深度有限</strong>：当企业发展到一定规模，需要精细化的生产管理、项目核算或复杂财务处理时，可能会感到力不从心。</p><p><strong>扩展性一般</strong>：系统的架构决定了其定制化和与其它系统深度集成的能力相对较弱。<br/><img width="723" height="294" referrerpolicy="no-referrer" src="/img/bVdnF01" alt="" title="" loading="lazy"/></p><p><strong>6、鼎捷软件</strong></p><p>鼎捷软件在制造业，尤其是电子、机械、五金等离散制造行业深耕多年，口碑扎实。它的移动解决方案与MES等车间管理结合紧密。</p><p><strong>优点</strong>：</p><p><strong>制造业解决方案专业</strong>：对生产现场的工序管理、在制品追踪、质量管控等场景理解深刻。</p><p><strong>软硬一体化集成</strong>：在车间数据采集、与PLC等设备集成方面有较多案例。</p><p><strong>行业知识丰富</strong>：拥有很多细分制造行业的“最佳实践”模板。</p><p><strong>需要注意</strong>：</p><p>品牌知名度在大众市场不如前几位，但在制造业圈内名气在外。</p><p>同样，<strong>标准产品较为复杂</strong>，需要专业的实施团队引导。<br/><img width="723" height="327" referrerpolicy="no-referrer" src="/img/bVdnF02" alt="" title="" loading="lazy"/></p><p><strong>总结与选型建议</strong></p><p>测评了一圈，最后给大家一些接地气的选型建议：</p><p><strong>快速成长</strong>阶段重点考察像<strong>支道</strong>这类<strong>灵活性高、能随需而变</strong>的平台，避免业务跑得快、系统跟不上，陷入“几年一换”的怪圈。如果痛点在于<strong>各部门数据不通、流程僵化</strong>，优先考虑能一站式解决、且支持无代码调整的平台。</p><p>不过最后无论听谁说得多好，都要组织关键用户（比如财务、仓管、销售负责人等）用真实业务流程去跑一跑，特别是多用手机APP操作。好不好用，体验过后说了算。</p><p>数字化转型没有万能药，最适合的才是最好的。希望这篇深度测评，能帮你和你的企业，在纷繁的移动ERP市场中，找到那个最契合的系统。</p>]]></description></item><item>    <title><![CDATA[FFmpeg开发笔记（一百）国产的Android开源视频压缩工具VideoSlimmer aqi00]]></title>    <link>https://segmentfault.com/a/1190000047548796</link>    <guid>https://segmentfault.com/a/1190000047548796</guid>    <pubDate>2026-01-18 12:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​《FFmpeg开发实战：从零基础到短视频上线》一书的“第 12 章  FFmpeg的移动开发”介绍了如何使用FFmpeg在手机上剪辑视频，方便开发者更好地开发类似剪映那样的视频剪辑软件。那么在Android系统上还有一款国产的开源视频压缩工具VideoSlimmer，通过该框架可以更方便地压缩视频大小，下面就来介绍如何在App工程中使用VideoSlimmer。</p><p>VideoSlimmer是一款专为Android平台设计的开源视频压缩工具，它通过Mediacodec实现视频压缩功能，并具有较高的压缩性能。VideoSlimmer支持压缩的视频格式包括mp4和3gp。  <br/>VideoSlimmer的源码托管地址为 <a href="https://link.segmentfault.com/?enc=RiTasHRa3yVKT2nx5BViEA%3D%3D.7IcFkqK539W6E5NZ%2BLT7AqBvHaWzb5aayLZysxfA8tDft1u1avKN81%2B62XWHNl4o" rel="nofollow" target="_blank">https://github.com/zolad/VideoSlimmer</a> （星星数0.2k），最近版本更新于2018年10月，该版本的压缩包下载地址为 <a href="https://link.segmentfault.com/?enc=mixJatOEt%2BumBTb7rsMa7A%3D%3D.6AA3HFtz1wfFU010X8%2FEleQRT2mluWQxrcxOe%2BwBqq9pqXCTV7oXaWA0m80do8Rj5rhz%2Bt0QP9MuvNi4X7G4heAaXzT3VTZdAW6ChrteP%2FA%3D" rel="nofollow" target="_blank">https://github.com/zolad/VideoSlimmer/archive/refs/heads/master.zip</a> 。  <br/>VideoSlimmer提供了两种集成方式：引用在线库、直接导入源码，分别说明如下：</p><h2>一、引用VideoSlimmer在线库</h2><p>Android工程引用VideoSlimmer在线库时，需要修改以下两个配置：  <br/>1、打开模块级别的build.gradle，给dependencies节点补充下面几行配置，表示引入1.0.0版本的VideoSlimmer库：</p><pre><code>implementation 'com.zolad:videoslimmer:1.0.0'</code></pre><p>2、打开App模块的src/main/AndroidManifest.xml，给manifest节点补充下面两行权限配置，表示声明读写存储空间两个权限：</p><pre><code>&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;</code></pre><h2>二、直接导入VideoSlimmer源码</h2><p>由于VideoSlimmer的发布时间较早，为了让小海豚版本的Android Studio Dolphin能够打开它的范例工程，需要对VideoSlimmer的App工程作如下修改：</p><h3>1、升级Gradle版本</h3><p>打开VideoSlimmer工程的gradle/wrapper/gradle-wrapper.properties，把下面这行配置</p><pre><code>distributionUrl=https://services.gradle.org/distributions/gradle-4.4-all.zip</code></pre><p>改成如下这行配置，表示把Gradle版本从4.4升级到5.4.1。</p><pre><code>distributionUrl=https://services.gradle.org/distributions/gradle-5.4.1-bin.zip</code></pre><h3>2、更新工具库的仓库位置</h3><p>打开VideoSlimmer工程的build.gradle，把里面的两处“jcenter()”都改为以下配置：</p><pre><code>// 以下四行添加阿里云的仓库地址，方便国内开发者下载相关插件
maven { url 'https://maven.aliyun.com/repository/jcenter' }
maven { url 'https://maven.aliyun.com/repository/google'}
maven { url 'https://maven.aliyun.com/repository/gradle-plugin'}
maven { url 'https://maven.aliyun.com/repository/public'}
google()
mavenCentral()</code></pre><p>因为jcenter仓库已经废弃，所以改成引用国内的仓库位置。  <br/>此外，还要把下面两行配置</p><pre><code>classpath 'com.android.tools.build:gradle:3.1.2'</code></pre><p>改成下面这行配置，表示把Gradle插件版本升级到3.2.0版本：</p><pre><code>classpath 'com.android.tools.build:gradle:3.2.0'</code></pre><h3>3、调整模块的build.gradle</h3><p>打开VideoSlimmer工程的app/build.gradle，找到下面这行配置：</p><pre><code>compileSdkVersion 28</code></pre><p>在上面这行下方补充下面这行配置，表示指定编译工具的版本号：</p><pre><code>buildToolsVersion "28.0.3"</code></pre><p>还要把下面这行配置</p><pre><code>implementation 'com.android.support:appcompat-v7:28.0.0-rc01'</code></pre><p>改成下面这行配置：</p><pre><code>implementation 'com.android.support:appcompat-v7:28.0.0'</code></pre><p>改完build.gradle，记得单击Sync同步App工程配置。</p><p>完成以上三处修改后，重新编译App安装到真机上，挑选一个视频后进入视频压缩界面如下图所示：</p><p><img width="720" height="904" referrerpolicy="no-referrer" src="/img/bVdnuTr" alt="" title=""/></p><p>可见选中视频正在压缩当中。稍等片刻视频压缩完成，界面下方展示结果视频的保存路径以及压缩进度，如下图所示：</p><p><img width="720" height="904" referrerpolicy="no-referrer" src="/img/bVdnuTs" alt="" title="" loading="lazy"/></p><p>发现压缩前的视频大小为85MB，压缩后的视频大小为12MB，仅为原视频的七分之一左右，可见压缩效果还是不错的。压缩之后的结果视频放在公共存储空间的Movies目录，完整路径为“我的手机/Movies/VIDEOSLIMMER_yyyymmdd_hhmiss.mp4”，其中yymmdd为年月日，hhmiss为时分秒。</p><p>更多详细的FFmpeg开发知识参见<a href="https://link.segmentfault.com/?enc=TyffkR18o4Gw94IT7RQ2Sw%3D%3D.I7k1Dk7pWja0H1fnfTS9nOV4wWGgqzZUYubzF2cheDj40VUN4DJACpOrSZNlKV%2B3" rel="nofollow" title="《FFmpeg开发实战：从零基础到短视频上线》" target="_blank">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</p>]]></description></item><item>    <title><![CDATA[OpenManus 添加自定义工具完整教程 AIAgent研究 ]]></title>    <link>https://segmentfault.com/a/1190000047549486</link>    <guid>https://segmentfault.com/a/1190000047549486</guid>    <pubDate>2026-01-18 11:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>核心原则</h2><p>OpenManus的工具系统基于「插件化设计」，所有自定义工具需继承框架的<code>BaseTool</code>基类，实现标准化接口，再通过配置文件注册，即可被AI智能体识别和调用。</p><h2>一、前置准备</h2><ol><li><p><strong>确认目录结构</strong>：在OpenManus项目根目录下，建议创建<code>custom_tools</code>目录存放自定义工具（便于管理）：</p><pre><code class="bash">mkdir custom_tools  # 项目根目录执行</code></pre></li><li><p><strong>核心依赖</strong>：确保已安装基础依赖（无需额外安装，框架自带工具基类）：</p><pre><code class="bash">pip install openmanus  # 若未安装框架核心包</code></pre></li></ol><h2>二、步骤1：编写自定义工具类（核心）</h2><p>所有自定义工具必须继承<code>BaseTool</code>基类，并实现3个核心要素：</p><ul><li><code>name</code>：工具唯一名称（AI通过名称识别工具）</li><li><code>description</code>：工具描述（关键！AI通过描述判断何时调用该工具，需清晰说明「用途+输入格式」）</li><li><code>run()</code>：工具执行逻辑（接收输入参数，返回执行结果）</li></ul><h3>示例：开发「实时天气查询工具」</h3><p>创建<code>custom_tools/weather_tool.py</code>文件，写入以下代码（含完整注释）：</p><pre><code class="python"># 导入框架核心基类和结果封装类
from openmanus.tools.base import BaseTool, ToolResult
# 按需导入第三方依赖（如请求网络需requests）
import requests

# 自定义工具类，必须继承BaseTool
class WeatherQueryTool(BaseTool):
    # 1. 工具唯一名称（不可重复，建议英文）
    name = "WeatherQueryTool"
    
    # 2. 工具描述（核心！需明确：用途+输入格式+输出说明）
    description = """
    用于查询指定城市的实时天气信息，输入格式为「城市名」（如：北京、上海），
    输出格式为「城市名 + 温度 + 天气状况」（如：北京 18℃ 晴）。
    仅当用户询问天气相关问题时调用该工具。
    """

    # 3. 工具执行逻辑，必须实现run方法
    def run(self, city: str) -&gt; ToolResult:
        """
        参数说明：
        - city: 字符串，用户输入的城市名
        返回值：ToolResult对象（封装执行结果，必填）
        """
        try:
            # 步骤1：校验输入（可选，增强健壮性）
            if not city or len(city) &gt; 10:
                return ToolResult(
                    success=False,  # 执行失败标记
                    content="输入无效！请输入正确的城市名（如：北京）"
                )
            
            # 步骤2：核心业务逻辑（调用免费天气API）
            # 替换为可靠的天气API，此处使用wttr.in（无需密钥）
            url = f"http://wttr.in/{city}?format=3"  # 精简格式：城市名: 天气 温度
            response = requests.get(url, timeout=10)
            
            # 步骤3：处理响应并封装结果
            if response.status_code == 200:
                weather_info = response.text.strip()
                return ToolResult(
                    success=True,  # 执行成功标记
                    content=f"✅ {weather_info}"  # 返回给AI的内容
                )
            else:
                return ToolResult(
                    success=False,
                    content=f"❌ 天气查询失败，API响应码：{response.status_code}"
                )
        
        # 异常处理（必加，避免工具崩溃）
        except requests.exceptions.Timeout:
            return ToolResult(success=False, content="❌ 网络超时，无法查询天气")
        except Exception as e:
            return ToolResult(success=False, content=f"❌ 查询出错：{str(e)}")</code></pre><h3>关键说明：</h3><ul><li><code>ToolResult</code>：框架规定的结果封装类，必须返回该类型，包含<code>success</code>（布尔值）和<code>content</code>（字符串）两个核心字段。</li><li><p><code>description</code>的精准性：AI完全依赖这段描述判断「是否调用该工具」，需明确：</p><ul><li>工具用途（如「查询指定城市实时天气」）</li><li>输入格式（如「输入为城市名，例：北京」）</li><li>适用场景（如「仅用户问天气时调用」）</li></ul></li></ul><h2>三、步骤2：配置文件注册自定义工具</h2><p>修改OpenManus的核心配置文件<code>config.yaml</code>（无则从<code>config.example.yaml</code>复制），将自定义工具添加到<code>tools</code>列表中：</p><h3>1. 复制配置模板（首次需做）</h3><pre><code class="bash">cp config.example.yaml config.yaml  # 项目根目录执行</code></pre><h3>2. 编辑<code>config.yaml</code>，添加工具配置</h3><p>找到<code>tools</code>节点，新增自定义工具的配置项：</p><pre><code class="yaml"># config.yaml 核心配置片段
llm:
  type: openai
  model: gpt-4-turbo
  api_key: "sk-xxxxxx"  # 替换为你的LLM密钥
  base_url: "https://api.openai.com/v1"

# 工具注册列表（内置工具 + 自定义工具）
tools:
  # 保留框架内置工具（按需取舍）
  - name: BrowserTool        # 浏览器工具
  - name: CodeExecutorTool   # 代码执行工具
  - name: FileTool           # 文件操作工具
  
  # 新增自定义工具（关键配置）
  - name: WeatherQueryTool   # 必须和工具类的name一致
    path: custom_tools/weather_tool.py  # 工具文件的绝对/相对路径
    enabled: true  # 是否启用该工具（默认true）</code></pre><h3>配置说明：</h3><ul><li><code>name</code>：必须和自定义工具类中定义的<code>name</code>完全一致（大小写敏感）。</li><li><code>path</code>：工具文件的路径，支持相对路径（相对于项目根目录）或绝对路径。</li><li><code>enabled</code>：是否启用该工具，设为<code>false</code>则AI不会调用。</li></ul><h2>四、步骤3：测试自定义工具</h2><p>编写测试代码，验证自定义工具是否能被AI智能体识别并调用：</p><h3>1. 创建测试文件<code>test_custom_tool.py</code></h3><pre><code class="python">import asyncio
from openmanus.agent import Agent  # 单智能体
from openmanus.config import Config  # 配置加载类

# 异步测试函数（OpenManus核心逻辑为异步）
async def test_weather_tool():
    # 步骤1：加载配置文件
    config = Config.from_file("config.yaml")
    
    # 步骤2：初始化AI智能体
    agent = Agent(config=config)
    
    # 步骤3：发送包含工具调用的任务指令
    task = "查询深圳市的实时天气"
    
    # 步骤4：执行任务并获取结果
    result = await agent.run(task)
    
    # 步骤5：打印结果
    print("=== 自定义工具调用结果 ===")
    print(result)

# 执行测试
if __name__ == "__main__":
    asyncio.run(test_weather_tool())</code></pre><h3>2. 运行测试代码</h3><pre><code class="bash">python test_custom_tool.py</code></pre><h3>预期输出：</h3><pre><code>=== 自定义工具调用结果 ===
✅ 深圳: 晴 25℃</code></pre><h2>五、进阶：支持多参数的自定义工具</h2><p>若工具需要多个输入参数（如「根据城市和日期查询天气预报」），修改工具类的<code>run</code>方法即可：</p><h3>示例：多参数天气工具</h3><pre><code class="python">class WeatherQueryTool(BaseTool):
    name = "WeatherQueryTool"
    description = """
    查询指定城市指定日期的天气预报，输入格式为「城市名,日期」（日期格式：YYYY-MM-DD，例：北京,2026-01-20）。
    若未指定日期，则查询实时天气。
    """

    def run(self, input_str: str) -&gt; ToolResult:
        # 解析多参数
        parts = input_str.split(",")
        city = parts[0].strip()
        date = parts[1].strip() if len(parts) &gt; 1 else None
        
        # 核心逻辑（示例）
        if date:
            content = f"✅ {city} {date} 的天气预报：晴 22-30℃"
        else:
            content = f"✅ {city} 实时天气：晴 25℃"
        
        return ToolResult(success=True, content=content)</code></pre><p>测试指令可改为：<code>查询上海2026-01-20的天气预报</code>。</p><h2>六、常见问题与排查</h2><h3>问题1：AI不调用自定义工具</h3><ul><li>原因：<code>description</code>描述不清晰，AI无法判断何时调用；或工具名称/路径配置错误。</li><li><p>解决：</p><ol><li>优化<code>description</code>，明确「触发条件+输入格式」；</li><li>检查<code>config.yaml</code>中工具<code>name</code>是否和类名一致；</li><li>测试时指令明确（如「用WeatherQueryTool查询北京天气」）。</li></ol></li></ul><h3>问题2：工具执行报错「找不到模块」</h3><ul><li>原因：工具文件路径配置错误，或未继承<code>BaseTool</code>。</li><li><p>解决：</p><ol><li>确认<code>config.yaml</code>中<code>path</code>是相对项目根目录的路径；</li><li>检查工具类是否正确导入<code>from openmanus.tools.base import BaseTool</code>。</li></ol></li></ul><h3>问题3：工具返回结果为空</h3><ul><li>原因：<code>run</code>方法未正确返回<code>ToolResult</code>对象，或业务逻辑出错。</li><li><p>解决：</p><ol><li>确保<code>run</code>方法最后<code>return ToolResult(...)</code>；</li><li>在<code>run</code>方法中添加日志（如<code>print(city)</code>），调试业务逻辑。</li></ol></li></ul><hr/><h3>总结</h3><ol><li><strong>核心步骤</strong>：自定义工具开发需遵循「继承BaseTool→实现name/description/run→配置文件注册→测试验证」的流程，缺一不可。</li><li><strong>关键要点</strong>：<code>description</code>是AI调用工具的核心依据，需精准描述用途和输入格式；<code>ToolResult</code>是结果返回的标准格式，必须使用。</li><li><strong>扩展技巧</strong>：单参数工具直接接收字符串，多参数工具可通过分隔符（如逗号）解析输入，复杂场景可使用JSON格式传参。</li></ol>]]></description></item><item>    <title><![CDATA[ChromeStandalone_58.0.3029.110使用步骤详解（附安装与设置教程） 无邪的]]></title>    <link>https://segmentfault.com/a/1190000047549472</link>    <guid>https://segmentfault.com/a/1190000047549472</guid>    <pubDate>2026-01-18 10:02:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><p>ChromeStandalone_58.0.3029.110_Setup.exe 是 <strong>Google Chrome 58 版本的独立安装包</strong>（离线安装版），不用联网就能装。</p><p>这个版本比较老（2017 年的），适合一些老项目、特定环境，或者电脑配置不高的情况。</p><h2>一、准备工作</h2><ol><li><p><strong>下载安装包</strong>​</p><ul><li><strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=edWgytvzno2eBimZBD5%2F8Q%3D%3D.7r7RAB2diN08HQm9vB7TsC%2BSEEDlLz62UOnCv6EU7gC1VGPSoW7inqcSQhPZsjQM" rel="nofollow" title="https://pan.quark.cn/s/c7e19cf3249e" target="_blank">https://pan.quark.cn/s/c7e19cf3249e</a></li><li>确认文件大小（约 50MB 左右），防止下错成别的版本。</li></ul></li><li><p><strong>关闭杀毒软件（可选）</strong> ​</p><ul><li>某些杀毒软件可能会误报老版本安装包，安装时可暂时关闭。</li></ul></li></ol><h2>二、安装 Chrome 58</h2><ol><li>双击 <code>ChromeStandalone_58.0.3029.110_Setup.exe</code>运行。</li><li>如果是 Windows 10/11，可能会弹出“允许此应用对你的设备进行更改吗？” → 点  <strong>“是”</strong> 。</li><li>安装程序会自动解压并安装，不需要你点“下一步”很多次，等进度条走完即可。</li><li>安装完成后，桌面会出现 <strong>Google Chrome</strong>​ 图标，双击即可启动。</li></ol><h2>三、首次运行设置</h2><ol><li>第一次打开 Chrome，会提示“是否设为默认浏览器” → 根据自己需要选。</li><li><p>登录 Google 账号（可选）：</p><ul><li>有账号就登录，书签、历史记录、插件会同步。</li><li>没账号或不愿登录，直接点“跳过”或“暂不登录”。</li></ul></li><li>进入主界面后，就可以正常浏览网页了。</li></ol><h2>四、常用操作</h2><ul><li><strong>打开新标签页</strong>：点右上角“+”号，或按 <code>Ctrl+T</code>。</li><li><strong>收藏网页</strong>：点地址栏右边的星星图标，添加到书签。</li><li><strong>查看下载内容</strong>：按 <code>Ctrl+J</code>打开下载列表。</li><li><strong>清除浏览数据</strong>：按 <code>Ctrl+Shift+Delete</code>，选时间范围和要清除的内容。</li></ul><p>​</p>]]></description></item><item>    <title><![CDATA[Downie_4_4.2.9安装教程简单步骤 Mac版 小童童 ]]></title>    <link>https://segmentfault.com/a/1190000047549476</link>    <guid>https://segmentfault.com/a/1190000047549476</guid>    <pubDate>2026-01-18 10:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​</p><p>Downie 4 是 Mac 上<strong>专门下载网页视频的工具</strong>，简单说就是能把你在网页上看到的视频</p><h4>1. 先下载好安装包</h4><p><strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=hcLLNcxick3G4%2BW8PL93Ng%3D%3D.JVoXK4WX6i7PnQejqQwxvGjKh%2B1TLZ50sBM%2FcxJzXbjlydMxSEeIe4n5TiPI1sdn" rel="nofollow" title="https://pan.quark.cn/s/0a565156a347" target="_blank">https://pan.quark.cn/s/0a565156a347</a> ，先把 <code>Downie_4_4.2.9.dmg</code>文件下载到你的 Mac（比如放到桌面或下载文件夹）。找到这个文件后，<strong>双击</strong>它，系统会弹出一个镜像窗口。</p><h4>2. 把 Downie 图标拖到“应用程序”文件夹</h4><p>在弹出的窗口中，你会看到一个 <strong>Downie</strong>​ 的图标和一个“应用程序”（Applications）文件夹的图标。把 <strong>Downie</strong>​ 的图标<strong>拖拽</strong>到“应用程序”文件夹图标上，等它拷贝完成。</p><h4>3. 打开 Downie</h4><p>从“应用程序”文件夹或启动台找到并打开 <strong>Downie</strong>。</p><h4>4. 首次打开时的设置</h4><p>如果是第一次打开 Downie，可能会有一些初始设置，比如选择语言、查看使用条款等。根据自己的需求进行设置即可。</p><h4>5. 开始使用 Downie</h4><p>现在你可以开始使用 Downie 来下载视频了。打开软件后，按照提示操作，添加视频链接，选择下载质量等。</p><p>​</p>]]></description></item><item>    <title><![CDATA[【剪映API】获取草稿文件列表 失落的木瓜_esfWwz ]]></title>    <link>https://segmentfault.com/a/1190000047549452</link>    <guid>https://segmentfault.com/a/1190000047549452</guid>    <pubDate>2026-01-18 09:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>GET_DRAFT API 接口文档</h2><h3>接口信息</h3><pre><code>GET /openapi/capcut-mate/v1/get_draft</code></pre><h3>功能描述</h3><p>获取草稿文件列表。该接口用于获取指定草稿ID对应的所有文件列表，可以查看草稿中包含的素材文件、配置文件等信息。通常用于草稿内容的预览、文件管理或状态检查。</p><h3>更多文档</h3><p>📖 更多详细文档和教程请访问：<a href="https://link.segmentfault.com/?enc=Mj0%2BHZJY4nrbk2Nuuemdcw%3D%3D.FjVKcOen2T6o8%2Foe7sme1Roo1LsDx2tW5lfHJ%2FHGhQw%3D" rel="nofollow" target="_blank">https://docs.jcaigc.cn</a></p><h3>请求参数</h3><h4>Query参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>必填</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>draft_id</td><td>string</td><td>✅</td><td>-</td><td>草稿ID，长度为20-32位字符</td></tr></tbody></table><h4>参数详解</h4><h5>draft_id</h5><ul><li><strong>类型</strong>: 字符串</li><li><strong>必填</strong>: 是</li><li><strong>长度</strong>: 20-32位字符</li><li><strong>格式</strong>: 通常为UUID格式或类似的唯一标识符</li><li><strong>示例</strong>: <code>2f52a63b-8c6a-4417-8b01-1b2a569ccb6c</code></li><li><strong>获取方式</strong>: 通常从draft_url中提取或由create_draft接口返回</li></ul><h3>响应格式</h3><h4>成功响应 (200)</h4><pre><code class="json">{
  "files": [
    "2f52a63b-8c6a-4417-8b01-1b2a569ccb6c.json",
    "video_123456789.mp4",
    "audio_987654321.mp3",
    "image_555666777.jpg",
    "thumbnail_888999000.png"
  ]
}</code></pre><h4>响应字段说明</h4><table><thead><tr><th>字段名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>files</td><td>array</td><td>草稿相关的文件列表</td></tr></tbody></table><h4>错误响应 (4xx/5xx)</h4><pre><code class="json">{
  "detail": "错误信息描述"
}</code></pre><h3>使用示例</h3><h4>cURL 示例</h4><h5>1. 基本获取草稿文件列表</h5><pre><code class="bash">curl -X GET "https://capcut-mate.jcaigc.cn/openapi/capcut-mate/v1/get_draft?draft_id=2f52a63b-8c6a-4417-8b01-1b2a569ccb6c" \
  -H "Content-Type: application/json"</code></pre><h5>2. 使用完整的draft_id</h5><pre><code class="bash">curl -X GET "https://capcut-mate.jcaigc.cn/openapi/capcut-mate/v1/get_draft?draft_id=7e8f9a0b-1c2d-3e4f-5g6h-7i8j9k0l1m2n" \
  -H "Content-Type: application/json"</code></pre><h3>错误码说明</h3><table><thead><tr><th>错误码</th><th>错误信息</th><th>说明</th><th>解决方案</th></tr></thead><tbody><tr><td>400</td><td>draft_id是必填项</td><td>缺少draft_id参数</td><td>提供有效的draft_id</td></tr><tr><td>400</td><td>draft_id长度无效</td><td>draft_id长度不在20-32位范围内</td><td>检查draft_id格式是否正确</td></tr><tr><td>400</td><td>draft_id格式无效</td><td>draft_id格式不正确</td><td>确保使用正确的草稿ID格式</td></tr><tr><td>404</td><td>草稿不存在</td><td>指定的草稿ID无法找到</td><td>确认草稿ID是否正确且存在</td></tr><tr><td>500</td><td>获取文件列表失败</td><td>内部服务错误</td><td>联系技术支持或稍后重试</td></tr><tr><td>503</td><td>服务不可用</td><td>系统维护中</td><td>稍后重试</td></tr></tbody></table><h3>注意事项</h3><ol><li><strong>参数格式</strong>: 确保draft_id格式正确且长度在20-32位之间</li><li><strong>ID提取</strong>: 从draft_url正确提取draft_id</li><li><strong>文件类型</strong>: 返回的文件列表包含多种类型的文件</li><li><strong>权限验证</strong>: 确保有权限访问指定的草稿</li><li><strong>实时性</strong>: 文件列表可能不是实时更新的，存在一定延迟</li><li><strong>文件状态</strong>: 列表中的文件可能处于不同的处理状态</li></ol><h3>工作流程</h3><ol><li>验证draft_id参数</li><li>检查draft_id格式和长度</li><li>查找指定的草稿</li><li>获取草稿关联的所有文件</li><li>返回文件列表</li></ol><h3>相关接口</h3><ul><li><a href="./create_draft.md" target="_blank">创建草稿</a></li><li><a href="./save_draft.md" target="_blank">保存草稿</a></li><li><a href="./add_videos.md" target="_blank">添加视频</a></li><li><a href="./add_audios.md" target="_blank">添加音频</a></li><li><a href="./add_images.md" target="_blank">添加图片</a></li><li><a href="./gen_video.md" target="_blank">生成视频</a></li></ul><hr/><p>📚 <strong>项目资源</strong>  <br/><strong>GitHub项目名称</strong>: capcut-mate</p>]]></description></item><item>    <title><![CDATA[基于 YOLOv8 的多车型交通车辆实时检测识别项目 [目标检测完整源码] 南瓜 ]]></title>    <link>https://segmentfault.com/a/1190000047549240</link>    <guid>https://segmentfault.com/a/1190000047549240</guid>    <pubDate>2026-01-18 00:02:02</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>基于 YOLOv8 的多车型交通车辆实时检测识别项目 [目标检测完整源码]</h2><h3>一、背景与问题引入</h3><p>在智慧交通体系中，“看得清、分得准、跑得快”始终是视觉感知系统的核心诉求。传统基于规则或特征工程的方法，在复杂道路环境、密集车流、多车型混行的场景下，往往存在鲁棒性不足、维护成本高的问题。</p><p>随着深度学习目标检测模型的成熟，<strong>YOLO 系列</strong>逐渐成为交通视觉领域的主流方案。其中，YOLOv8 以其 <strong>Anchor-Free 架构、更优的速度–精度平衡以及完善的工程生态</strong>，非常适合用于实时车辆检测与系统级落地。</p><p>本文将从工程实践角度，完整介绍一个 <strong>支持 12 类常见交通车辆、具备图形化界面、可直接部署运行</strong> 的实时检测系统设计与实现思路。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549242" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><h3>源码下载与效果演示</h3><p>哔哩哔哩视频下方观看：</p><p><a href="https://www.bilibili.com/video/BV1dwg5zCEkL/" target="_blank">https://www.bilibili.com/video/BV1dwg5zCEkL/</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549243" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>包含：</p><p>📦完整项目源码</p><p>📦 预训练模型权重</p><p>🗂️ 数据集地址（含标注脚本</p><h3>二、系统整体架构设计</h3><p>该系统并非仅停留在“模型推理”层面，而是以<strong>完整应用系统</strong>为目标进行设计，整体架构可划分为四个核心模块：</p><pre><code>┌────────────┐
│  数据输入层 │  ← 图片 / 视频 / 摄像头 / 文件夹
└─────┬──────┘
      │
┌─────▼──────┐
│  检测引擎层 │  ← YOLOv8 Detection Model
└─────┬──────┘
      │
┌─────▼──────┐
│  结果处理层 │  ← NMS / 置信度过滤 / 可视化
└─────┬──────┘
      │
┌─────▼──────┐
│  UI 交互层  │  ← PyQt5 图形界面
└────────────┘</code></pre><p>这种分层结构具备以下优势：</p><ul><li>算法与界面解耦，便于模型升级</li><li>输入方式可扩展（无人机、RTSP流等）</li><li>易于二次开发与功能叠加</li></ul><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549244" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549245" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>三、核心功能能力解析</h3><h4>3.1 多源输入的统一检测流程</h4><p>系统支持多种数据源接入，并统一走同一套检测逻辑：</p><ul><li><strong>单张图片检测</strong>：适合离线分析与测试</li><li><strong>文件夹批量检测</strong>：用于数据清洗与标注校验</li><li><strong>视频文件检测</strong>：适配道路监控录像</li><li><strong>实时摄像头检测</strong>：满足在线监控需求</li></ul><p>在底层实现上，通过对输入源进行抽象封装，确保模型推理逻辑保持一致，避免重复代码。</p><hr/><h4>3.2 多车型精细化识别</h4><p>本项目针对真实交通场景，定义了 <strong>12 类常见车辆类型</strong>，涵盖：</p><ul><li>轿车、SUV、面包车</li><li>公交车、卡车、工程车辆</li><li>特殊用途车辆等</li></ul><p>YOLOv8 的 Anchor-Free 机制在多尺度目标（远距离小车 / 近景大车）检测中表现稳定，有效降低漏检与误检率。</p><hr/><h4>3.3 PyQt5 图形化交互系统</h4><p>为了降低系统使用门槛，引入 PyQt5 构建桌面级应用界面，核心设计原则是：</p><ul><li><strong>无需编程经验即可使用</strong></li><li><strong>操作路径清晰</strong></li><li><strong>结果可视、可保存</strong></li></ul><p>主要功能包括：</p><ul><li>输入源选择与切换</li><li>检测启动 / 停止控制</li><li>实时画面显示（带检测框）</li><li>检测结果自动保存</li></ul><p>这使得模型能力真正转化为“可使用的软件”，而不仅是脚本级 Demo。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549246" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>四、YOLOv8 模型训练与评估实践</h3><h4>4.1 数据集组织规范</h4><p>项目采用标准 YOLO 数据格式，便于复用与迁移：</p><pre><code>dataset/
├── images/
│   ├── train
│   └── val
└── labels/
    ├── train
    └── val</code></pre><p>标签文件采用归一化坐标，兼容 Ultralytics 官方训练接口。</p><hr/><h4>4.2 模型训练策略</h4><p>训练阶段基于 YOLOv8 预训练权重进行微调，核心关注点包括：</p><ul><li><strong>box_loss</strong>：定位精度</li><li><strong>cls_loss</strong>：车辆类别区分能力</li><li><strong>dfl_loss</strong>：边框质量优化</li></ul><p>在实际项目中，当 <code>mAP@0.5</code> 稳定超过 <strong>90%</strong>，即可满足工程部署需求。</p><hr/><h4>4.3 推理与部署方式</h4><p>模型推理通过 Ultralytics 官方 API 完成，具备如下特点：</p><ul><li>接口简洁，代码量少</li><li>支持 CPU / GPU 自适应</li><li>可导出 ONNX / TensorRT</li></ul><p>结合 UI 层，可直接形成“即点即检”的完整工作流。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549247" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>五、工程化落地与可扩展性</h3><p>与单纯算法实验不同，该项目在工程层面具备以下实用特性：</p><ul><li><strong>完整源码与权重打包</strong></li><li><strong>一行命令启动系统</strong></li><li><strong>训练 / 推理 / UI 全流程覆盖</strong></li></ul><p>在此基础上，可进一步拓展：</p><ul><li>车辆轨迹跟踪（DeepSORT / ByteTrack）</li><li>车流量统计与时间序列分析</li><li>多路摄像头并行检测</li><li>智慧交通平台对接</li></ul><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549248" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549249" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>六、总结与展望</h3><p>本文从系统视角出发，完整介绍了一套 <strong>基于 YOLOv8 的多车型交通车辆实时检测平台</strong> 的设计与实现思路。通过将高性能目标检测模型与 PyQt5 图形界面深度融合，实现了从算法能力到实际可用系统的有效转化。</p><p>该项目不仅适用于智慧交通与城市监控场景，也非常适合作为：</p><ul><li>计算机视觉工程实战案例</li><li>AI 教学与科研实验平台</li><li>工业级视觉系统原型</li></ul><p>随着模型与算力的持续演进，交通视觉系统将不再只是“看见车辆”，而是逐步走向 <strong>理解交通、预测交通、优化交通</strong>。这一项目，正是迈向该目标的一个扎实起点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549250" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><p>本文从工程化与系统化的角度，介绍了一套基于 <strong>YOLOv8 的多车型交通车辆实时检测系统</strong>，完整覆盖了数据输入、模型训练、推理部署以及 PyQt5 图形化交互等关键环节。通过将高精度目标检测模型与易用的桌面端界面相结合，系统实现了对多种交通场景下车辆目标的稳定识别与实时展示，显著降低了深度学习技术在智慧交通领域的使用门槛。整体方案结构清晰、可扩展性强，不仅具备直接落地应用的工程价值，也为后续在车流统计、行为分析和交通智能决策等方向上的功能扩展提供了良好的技术基础。</p>]]></description></item><item>    <title><![CDATA[千万会员，亿级交易：当CRM系统不堪重负，头部药企如何通过数据库升级实现“实时精准营销”？ 老纪的技]]></title>    <link>https://segmentfault.com/a/1190000047549273</link>    <guid>https://segmentfault.com/a/1190000047549273</guid>    <pubDate>2026-01-18 00:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>作者：张红霞，青岛雨诺网络信息股份有限公司新零售产品部总监</p><h2><strong>综述</strong></h2><p>当前，医药零售企业已不再满足于“卖药”，而是致力于成为“健康管理伙伴”。通过构建以 CRM 会员系统为核心、线上与线下深度融合的全渠道服务架构，企业实现了服务时间与空间的无限延展、会员数据的集中管理与智能应用、营销活动的精准触达与高效转化。</p><p>作为医药零售的头部企业，重庆医药（集团）股份有限公司（简称“重药集团”）前身是成立于1950年的中国医药公司西南区公司，服务于医药全产业链，同时从事医药研发（MAH）、医疗器械生产，并投资参与医药工业。重药集团拥有全级次分、子公司200余家，正在从传统的配送商业企业向“互联网+医药”融合型现代医药企业转型。</p><p>随着CRM会员系统的使用时间拉长，其底层的传统数据库逐渐难以满足复杂数据的高效处理需求。面对海量交易和多维度行为数据的汇聚，重药集团CRM会员系统亟需采用具备高可用、强一致、可扩展特性的数据库。经过对比三款国产分布式数据库，重药集团选择OceanBase，最终实现系统稳定运行、复杂场景实时分析、查询效率提升25倍、存储空间节约60%。</p><p>此次重药集团CRM系统的数据库升级不仅提升了用户体验与品牌忠诚度，也为后续集团构建高性能、高可用的“集团级数字化运营中枢”提供了明确的业务需求与数据基础，构建可扩展、可复制、可监管的集团化运营体系。</p><h2><strong>医药零售商业模式变革，CRM系统实现全渠道协同</strong></h2><p>随着消费者行为的数字化转型和健康需求的持续升级，医药零售行业正经历深刻的商业模式变革。传统药店“有啥卖啥”的经营逻辑，逐步向“顾客需要什么”的逻辑转变，除了提供到店服务外，还支持线上服务，比如通过企业微信、公众号等渠道建立长期沟通机制。微商城代客下单、在线解答疑问等。</p><p>为构建以专业化服务为基础的顾客信任体系，医药企业建立了完整的会员服务体系——CRM 会员系统，以实现绑定多重会员信息、建立精准的会员标签画像，为会员提供更多的服务和营销。通过数据驱动决策的专业化服务能力提升来提高企业在行业内的竞争力，实现增收。</p><p>如图1 所示，CRM 会员系统可以实现线上、线下全渠道协同，支持会员档案统一、标签体系完善、自动触发机制、店员触达赋能、社群营销等关键功能。完成顾客到店/线上购药 → 完成交易 → 数据沉淀至 CRM → 触发服务与营销 → 二次消费 → 再次触达，实现“交易—服务—再交易”的正向循环。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549275" alt="" title=""/></p><p>图1 CRM会员系统实现线上、线下全渠道协同</p><h3><strong>为实现一体化管理需求，构建CRM会员系统</strong></h3><p>重药集团CRM会员系统的搭建背景，源自于其各子公司会员管理分散，系统缺乏统一规划，导致数据难沉淀、服务差异大、运营难复制，且缺乏实时监控，难以支撑决策。</p><p>为实现一体化管理，重药集团CRM会员系统分阶段建设。第一阶段完成会员营销平台的底座建设，打造集团化、标准化、数据化运营基础，核心目标如下。</p><ul><li>搭建集团化会员运营平台。现集团—子公司—门店的一体化管理，打通组织架构与业务链路，确保会员在不同层级和渠道中都能获得一致的服务体验。</li><li>统一的会员运营服务体系。构建覆盖会员管理、营销活动、服务交付的标准化流程，减少分散运作带来的效率损耗，提升整体运营协同能力。</li><li>可快速复制标准化服务能力。形成可落地的服务模板和运营机制，帮助新业务和子公司快速复制成熟经验，缩短建设周期，提升推广效率。</li><li>实现经营数据统一分析。沉淀完整的数据资产，打破信息孤岛，实现对会员、门店、区域的多维度统一分析，为企业战略决策与合规审计提供有力支撑。</li></ul><p>在上述目标指导下，我们做了三个核心举措：</p><ul><li>联合集团会员中心，推进一体化进程。覆盖集团全品牌及线上会员，实现线上和线下会员统一运营和全域价值管理（见图2）。</li><li>构建多层级组织架构视角报表。支持集团、品牌、门店的权限管理，权限灵活配置，便于集团总部进行跨品牌的数据报表分析。</li><li>集团统一下达任务。集团可向各品牌下发销售任务、患者教育活动任务及拉新任务，实现集团任务统一管理与执行监督。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549276" alt="" title="" loading="lazy"/></p><p>图2 集团会员同意运营架构</p><p>我们计划以集团内个别区域公司为试点，试行以上举措，若成功，则进行全面推广。推广成功后，重药集团会员运营平台将实现从“单一业务系统”向“集团级数字化运营中枢”演进。依托统一的技术底座与标准化流程，平台不仅实现对多家子公司、多个品牌的全面接入，更构建起可扩展、可复制、可监管的集团化运营体系。</p><p>此外，为实现全渠道会员统一运营，平台通过整合分散在各系统中的数据，构建统一、动态、多维度的会员标签画像体系（见图3），支撑精细化运营决策。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549277" alt="" title="" loading="lazy"/></p><p>图3 多维度会员标签画像体系</p><p>通过会员系统精准化的服务来反哺我们的线上和线下的会员营销和服务，实现线上精准营销、个性化推荐、好物推送、会员关怀，线下关联用药建议、慢病管理提醒、店员主动触达等，提升营销转化率，增强客户粘性，实现“数据驱动服务”的闭环。</p><h3><strong>精细化会员服务，带来海量数据的查询、存储难题</strong></h3><p>然而，随着集团化会员运营平台的推进，精细化服务模式持续深化，导致用户数据规模呈指数级增长，显著提升了系统的查询与存储复杂性。</p><ul><li>会员量：突破千万级，覆盖多个品牌及区域公司。</li><li>交易数据量：达到亿级，涵盖线上线下购药、用券、复购等行为。</li><li>用户行为类数据：包括商品浏览、搜索、加购等，总量亦达千万级以上。</li></ul><p>这些数据来源于线上商城、私域平台、公众号等多个渠道，经标签体系整合后，用于构建立体化的会员画像，支撑精准营销与双向引流。</p><p>但数据体量大、类型多样、实时性要求高，对数据库的高并发读写能力、存储扩展性与查询性能提出严峻考验。<strong>面对千万级会员、亿级交易和多维度行为数据的汇聚，传统数据库难以满足高效处理需求，亟需采用具备高可用、强一致、可扩展特性的分布式数据库系统进行支撑。</strong></p><h2><strong>CRM会员系统数据库升级，应对千万级数据处理难题</strong></h2><h3><strong>传统数据库的技术瓶颈制约业务发展</strong></h3><p>重药集团会员服务平台的规模化发展，使系统数据总量迅速增长至千万级、数十 TB 存储规模，传统关系型数据库在支撑精细化会员运营场景时，暴露出四大核心挑战。</p><ul><li>性能：百万大表 InnoDB 在高并发读写及复杂查询场景下，性能显著下降，无法满足业务需求，且有事务访问，无法通过拆分提升性能。同时，业务强依赖事务一致性，无法通过拆分提升性能。</li><li>效率：核心归档由于业务需求，需要保留大量数据（数十 TB），会造成 DDL 周期长，延迟业务上线时间。</li><li>成本：随着企业数量增多、历年数据累积，存储成本将越来越高。</li><li>及时性：在各种场景下，对应数据处理的及时性需求越来越强。</li></ul><p>上述技术挑战不乏真实业务案例。</p><h4><strong>例 1：某大型连锁店，以满足信创要求为前提进行性能保障</strong></h4><p>如今国家对信息技术应用创新（简称“信创”）的要求日益严格，特别是在国有企业中，系统必须符合相关标准才能上线。为了响应这一趋势，我们严格按照信创目录选择数据库产品，并对其进行了全面的业务场景适配与性能验证。</p><ul><li>数据准备：会员卡 9950万+、订单 1 亿 9980万+。</li><li>验证数据库：OceanBase 数据库、某数据库1、某数据库2。</li><li>验证功能：报表 14 项内容、高级筛选 8 项内容。</li><li>参考标准：报表查询小于 20s、静态化数据小于 60s、高级筛选小于 15s。</li></ul><p>测试结果如图4所示。OceanBase 在所有测试项中均显著优于其他两个国产数据库，在报表查询、高级筛选、静态化数据三个场景的性能表现都远超预期：</p><ul><li>报表查询小于 7s，平均提速 78 倍以上。</li><li>高级筛选响应高级筛选小于 1s，速度提升 200–700 倍。</li><li>静态化数据静态化数据小于 46s，效率提升 6.7 倍以上。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549278" alt="" title="" loading="lazy"/></p><p>图4 OceanBase 数据库、某数据库1、某数据库2的测试结果</p><p>在严格遵循国家信创要求的前提下，OceanBase 不仅完全满足合规性准入条件，更在百亿级数据规模下的复杂查询与批量处理场景中展现出卓越性能，远超同类国产数据库产品。基于此，我们总结了三个数据库的性能数据，向客户提交了一份详细的分析报告。</p><h4><strong>例 2：连锁会员、订单交易数据量增长迅速，实时性查询瓶颈</strong></h4><p>除了信创需求外，客户对业务的实时性、及时性要求也越来越高。过去，企业主要依赖 BI 工具进行周期性报表生成，可容忍数小时甚至数天的数据延迟。然而，随着营销策略向精准触达和即时响应演进，业务人员需要在高价值客户识别、复购提醒触发、定向营销投放、健康知识推荐等场景中获取近实时数据支持。为实现精准服务，运营人员经常需要基于会员信息、会员属性、历史消费、会员标签、商品集合等多个维度进行多维组合筛选，由于关联维度过多，可能会出现查询失败、查询时间过长、范围跨度受限、复杂查询无法支持等问题，显然，这些问题是我们服务的客户无法接受的。</p><h4><strong>例 3：海量业务数据，系统可用性与存储成本难平衡</strong></h4><p>连锁医药企业会员体系的不断扩展和数字化运营的深入，必然会带来业务数据量的指数级增长，海量数据带来的高存储成本成为制约系统可持续发展的关键瓶颈之一。</p><ul><li>用户数据：累计会员数量突破千万级（&gt;1000万）。</li><li>交易流水：日均订单量达百万级，历史累计超过亿级（&gt;1亿条）。</li><li>用户行为数据：包括浏览、搜索、加购、收藏等行为记录，总量亦达千万级以上。</li></ul><p>单个业务数据库实例空间占用已达到 N 个 TB 级别，且随时间推移呈线性增长。随着客户数量增加和业务持续扩张，业务数据库实例的空间占用迅速攀升至数十TB甚至上百TB级别，这些数据不仅用于支撑日常业务运行，还需长期保留以满足合规审计、精准营销、客户画像构建等需求。企业面临保障性能与可用性的前提下降低存储成本的难题。</p><p>因此，<strong>引入具备高效数据压缩、自动冷热分层、弹性扩展能力的新一代分布式数据库，是实现“数据价值最大化、存储成本最小化”的必然选择。</strong></p><h3><strong>数据库技术引入，支撑海量交易数据的高效处理</strong></h3><p>综合业务需求与传统数据库的技术瓶颈考虑，我们需要替换传统数据库，升级为高性能、稳定性强、成本低、 HTAP 一体化的分布式数据库。</p><p>自 2023 年起，我们开始系统性地评估并引入 OceanBase，历经技术认知、多轮测试、工具链验证、SaaS 级试点上线等关键阶段（见图5），最终成功应用于重药集团会员管理平台。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549279" alt="" title="" loading="lazy"/></p><p>图5 上线OceanBase的关键阶段</p><h4><strong>1.技术引入与评估阶段（2023年）</strong></h4><p>测试重点包括三部分。</p><p>其一，日常抖动测试。在对 OceanBase 初期测试时，我们首先进行了业务压力测试。低峰期业务配合100%模拟线上流量直接发压，高达4轮的压力测试，每次持续 3 小时以上。</p><p>其二，扩容/缩容测试。在业务流量低时进行相关操作验证。为了验证是否存在小概率事件，进行了为期一周的脚本自动扩、缩容操作以观察其稳定性。</p><p>其三，Add Index 测试。与扩容、缩容相仿，基于业务流量对1T大表进行多达几十次的add index操作，观察延迟情况。</p><h4><strong>2.SaaS 产品试点上线（2023 年 12 月）</strong></h4><p>在完成全面技术验证后，我司将 OceanBase 应用于内部 SaaS 类产品中，作为首个生产级试点场景。该阶段实现了：</p><ul><li>数据库稳定运行于真实业务环境中。</li><li>验证了迁移、运维、监控等全生命周期管理能力。</li><li>积累了宝贵的实战经验，为后续客户项目打下坚实基础。</li></ul><h4><strong>3.重药集团项目正式上线（2025 年 4 月）</strong></h4><p>基于前期充分验证与试点成果，我们于 2025 年 4 月正式启动重药集团会员管理平台项目，OceanBase 正式投入生产使用，支撑海量交易数据的高效处理。</p><h2><strong>会员服务平台“新面貌”：稳定、高性能、低成本</strong></h2><h3><strong>构建标准化数据链路，稳定、高效处理海量数据</strong></h3><p>目前，OceanBase 主要支撑重药集团会员服务平台的分析型业务场景，支撑高并发、多维度的会员数据查询、标签计算、报表生成及精准营销决策。其核心价值体现在：高效处理海量历史数据、支持复杂实时分析、保障查询性能与系统稳定性。</p><p>整个数据链路遵循“源系统 → CRM 中转清洗 → OceanBase 分析库”的三层架构，如图6所示。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549280" alt="" title="" loading="lazy"/></p><p>图6 会员服务平台的数据分析链路</p><p>数据来源（源系统）包括POS 订单数据、各渠道会员信息、组织人员数据、会员标签数据、档案测量数据、全部商品主数据。</p><ul><li>中转与清洗层（CRM 系统）：所有原始数据通过定时抽取或实时接入方式进入 CRM 系统，进行统一的数据清洗、去重、合并与标准化处理。关键处理策略包括历史数据清洗、订单数据合并、积分逻辑处理、会员标签动态更新、消费行为计算、活跃度模型计算。</li><li>目标存储与分析层（OceanBase 分析库）：清洗后的数据通过同步机制实时或定时写入 OceanBase 分析库；并分为原始数据表、静态化处理表、日表/月表、报表中间表。</li></ul><p><strong>通过构建“源数据 → CRM 清洗 →  OceanBase 分析库”的标准化数据链路，实现了多源异构数据的统一整合、复杂分析场景的高性能响应、业务数据的长期留存与高效利用。</strong></p><h3><strong>会员精准筛选复杂场景，查询效率提升 25.7 倍</strong></h3><p>在重药集团会员服务平台的实际运营中，多维度组合筛选（见图7）是支撑精细化营销与客户管理的核心功能。对于数据库而言，该功能是典型的复杂查询场景，用户需同时基于多个维度进行精确匹配，查询通常涉及多表关联、大量过滤条件和聚合计算，非常考验数据库的执行效率。我们通过开启 OceanBase 的列存模式（Columnar Storage），将原本传统数据库MySQL 的响应时间从 18 秒缩短至 0.7 秒，性能提升达 25.7 倍，满足业务对“实时圈选、即时触达”的严苛需求，显著提升了系统整体吞吐量与用户体验。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549281" alt="" title="" loading="lazy"/></p><p>图7 会员服务平台多维度组合筛选</p><h3><strong>数据存储空间省 60%，有效降低存储成本压力</strong></h3><p>OceanBase 将全量数据划分为两个部分进行管理：一是增量数据（Memtable），即实时写入内存中的热数据，支持快速读写；二是基线数据（静态数据），即经过合并与持久化后的冷数据，存储于磁盘。</p><p>对于静态数据，OceanBase 采用高效的压缩算法，对列式存储的数据进行深度压缩，显著减少磁盘 I/O 和存储开销。例如，当原始数据总量为 4TB 时，MySQL 需要完整保留所有数据，存储空间占用为 4TB；而 OceanBase 通过对静态数据进行高压缩处理，仅需 1.5TB 即可承载相同规模的数据。</p><p>在重药集团会员服务平台的实际部署中，OceanBase 通过其先进的列式存储引擎与高效压缩算法，显著降低了数据存储空间占用，在同等业务数据规模下实现了 60% 以上的存储空间节约，有效缓解了海量数据带来的存储成本压力。</p><h2><strong>面向未来，持续推进 OceanBase 的深度集成与价值释放</strong></h2><p>随着 OceanBase 在重药集团会员服务平台的成功落地，我们对其在更广泛业务领域和客户群体中的应用充满信心。面向 2026 年及未来，我们将围绕场景拓展、客户推广、技术融合与产品适配四大方向，持续推进 OceanBase 的深度集成与价值释放。</p><h3><strong>应用于更多业务场景与产品</strong></h3><p>当前，OceanBase 已稳定支撑重药集团会员管理平台的复杂分析型业务（如精准筛选、标签计算、报表生成）。订单处理中心和运营诊断产品也在生产环境开始使用OceanBase，下一步，我们将推动其全面融入日常运营服务场景，包括：实时会员服务、营销活动执行、AI 智能推荐等业务场景。</p><p>另外，我们将逐步将 OceanBase 适配至更多内部产品，包括商品主数据管理、患者健康管理平台、智能补货与供应链协同系统，构建以 OceanBase 为核心的统一、弹性、智能的企业级数据基础设施。</p><h3><strong>向业内客户推荐</strong></h3><p>在国家信创政策与企业降本增效双重驱动下，我们已将 OceanBase 作为高并发、大数据量、强一致性要求场景下的首选数据库，并向行业客户积极推广。截至目前，已在以下大型医药企业成功落地：扬子江药业集团、鹭燕医学、重药集团、上海医药、国大药房。未来，我们将继续优先推荐 OceanBase 作为会员服务、订单中心等关键系统的数据库底座，助力更多企业完成安全、高效、低成本的国产化替代。</p><h3><strong>交流开发，沉淀运维经验</strong></h3><p>为持续提升团队与客户的 OceanBase 应用能力，我们计划定期组织专题培训、参与社区技术沙龙、共建问题解决机制、定期组织数据库培训及实战分享会议，探讨并解决遇到的问题，争取打造一支“懂业务、精技术、能落地”的复合型数据库应用团队。</p><p><strong>未来，我们将携手更多合作伙伴，共同探索“数据库 + AI + 行业场景”的创新路径，为医药健康行业的高质量发展注入新动能。</strong></p><hr/>]]></description></item><item>    <title><![CDATA[多智能体强化学习（MARL）核心概念与算法概览 本文系转载，阅读原文
https://avoid.o]]></title>    <link>https://segmentfault.com/a/1190000047549187</link>    <guid>https://segmentfault.com/a/1190000047549187</guid>    <pubDate>2026-01-17 23:02:54</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>训练单个 RL 智能体的过程非常简单，那么我们现在换一个场景，同时训练五个智能体，而且每个都有自己的目标、只能看到部分信息，还能互相帮忙。</p><p>这就是多智能体强化学习（Multi-Agent Reinforcement Learning，MARL），但是这样会很快变得混乱。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549189" alt="" title=""/></p><h2>什么是多智能体强化学习</h2><p>MARL 是多个决策者（智能体）在同一环境中交互的强化学习。</p><p>环境类型可以很不一样。竞争性的，比如国际象棋，一方赢一方输。合作性的，比如团队运动，大家共享目标。还有混合型的，更像现实生活——现在是队友，过会儿可能是对手，有时候两者同时存在。</p><p>但是这里与一个关键的问题：从任何一个智能体的视角看世界变成了非平稳的，因为其他智能体也在学习、在改变行为。也就是说在学规则的时候，规则本身也在变。</p><h2>MARL 在现实中的位置</h2><p>单智能体 RL 适合系统只有一个"大脑"的情况，而MARL 则出现在世界有多个"大脑"的时候。</p><p>现实世界中有很多这样的案例，比如交通信号控制：每个路口是一个智能体，一个信号灯"贪婪"了，下游路口就会卡死；仓库机器人：每个机器人自己选路径，碰撞和拥堵天然是多智能体问题；广告竞价和市场：智能体用不断变化的策略争夺有限资源；网络安全：攻击者和防御者是相互适应的智能体对；在线游戏和模拟：协调、欺骗、配合、自我对弈——这些都是MARL 的经典试验场。</p><h2>核心概念</h2><p>大多数真实场景中，智能体只能看到状态的一部分。所以 MARL 里的策略通常基于局部观测，而不是完整的全局状态。</p><p>单智能体 RL 里环境动态是稳定的，而MARL 不一样"环境"包括其他智能体。它们在学习，你的转移动态也就跟着变了。</p><p>这正是经典的 Qlearn在多智能体环境里容易震荡、甚至崩溃的原因。</p><p>合作任务中团队拿到奖励，但功劳该算谁的？团队成功了，是智能体 2 的动作起了作用，还是智能体 5 在 10 步之前的作用？这就是信用分配问题，这是MARL 里最头疼的实际难题之一。</p><h2>集中式与分布式</h2><h3>集中训练、分布式执行（CTDE）</h3><p>这是目前最常见的模式。训练时智能体可以用额外信息，比如全局状态或其他智能体的动作。执行时每个智能体只根据自己的局部观测行动。</p><p>这样的好处是，既有集中学习的稳定性，又不需要在运行时获取不现实的全局信息。</p><h3>完全分布式学习</h3><p>智能体只从局部经验学习。这个听起来是对的，而且简单任务也能用。但实际中往往不够稳定，合作任务尤其如此。</p><h2>算法总览</h2><p>合作性基于价值的方法：Independent Q-Learning（IQL）是最简单的基线，容易实现但通常不稳定；VDN 和 QMIX 通过混合各智能体的价值来学全局团队价值，合作处理得更好。</p><p>策略梯度和 Actor-Critic 方法：MADDPG 用集中式 Critic 配分布式 Actor，概念上是很好的切入点；MAPPO 在很多合作任务里是靠谱的默认选择。</p><p>自我对弈（Self-play）：和自己不同版本对打来建立泛化的策略。思路简单粗暴效果也很好。</p><h2>用 Python 从零搭一个小 MARL 环境</h2><p>来做个玩具游戏：两个智能体必须协调。经典设定——两者选同一个动作才有奖励。每个智能体选 0 或 1，动作一致拿 +1，不一致拿 0。</p><p>我们这里刻意设计得简单，这样方便我们聚焦在 MARL 机制本身。</p><pre><code> import random  
from collections import defaultdict  

class CoordinationGame:  
    def step(self, a0, a1):  
        reward = 1 if a0 == a1 else 0  
        done = True  # single-step episode  
         return reward, done</code></pre><p>接下来是最小化的 Independent Q-Learning 设置，每个智能体学自己的 Q 表。这里没有状态，Q 只取决于动作。</p><pre><code> def epsilon_greedy(Q, eps=0.1):  
    if random.random() &lt; eps:  
        return random.choice([0, 1])  
    return 0 if Q[0] &gt;= Q[1] else 1  

Q0 = defaultdict(float)  # Q0[action]  
Q1 = defaultdict(float)  # Q1[action]  

alpha = 0.1  
eps = 0.2  
env = CoordinationGame()  

for episode in range(5000):  
    a0 = epsilon_greedy(Q0, eps)  
    a1 = epsilon_greedy(Q1, eps)  

    r, done = env.step(a0, a1)  

    # One-step update (no next-state)  
    Q0[a0] += alpha * (r - Q0[a0])  
    Q1[a1] += alpha * (r - Q1[a1])  

# Inspect learned preferences  
print("Agent0 Q:", dict(Q0))  
 print("Agent1 Q:", dict(Q1))</code></pre><p>多数运行会收敛到两种"惯例"之一：两者都学会总是选 0，或者都学会总是选 1。</p><p>这就是协调从学习中涌现出来的样子。虽然小但和大型合作 MARL 系统里依赖的模式是同一类东西。</p><p>这个玩具例子太友好了。难一点的任务里，IQL 常常变得不稳定，因为每个智能体都在追一个移动靶。</p><h2>让例子更"MARL"一点</h2><p>常见技巧是加共享团队奖励，同时保证足够长的探索期来发现协调，下面是一个带衰减 epsilon 的训练循环：</p><pre><code> Q0 = defaultdict(float)  
Q1 = defaultdict(float)  

alpha = 0.1  
eps = 0.9  
eps_decay = 0.999  
eps_min = 0.05  

env = CoordinationGame()  

for episode in range(20000):  
    a0 = epsilon_greedy(Q0, eps)  
    a1 = epsilon_greedy(Q1, eps)  

    r, _ = env.step(a0, a1)  

    Q0[a0] += alpha * (r - Q0[a0])  
    Q1[a1] += alpha * (r - Q1[a1])  

    eps = max(eps_min, eps * eps_decay)  

print("Agent0 Q:", dict(Q0))  
 print("Agent1 Q:", dict(Q1))</code></pre><p>这当然不会解决 MARL，但它演示了一个真实原则：早期探索帮助智能体"找到"一个稳定的协调惯例。</p><h2>总结</h2><p>一旦解决了单步协调问题，还会有三个问题会反复出现：</p><p>虚假学习信号：智能体可能觉得"是自己动作导致了奖励"，实际上是另一个智能体的动作起了作用。</p><p>糟糕的均衡陷阱：在竞争性游戏里，智能体可能卡在稳定但不强的弱策略上。</p><p>规模爆炸：多智能体的状态和动作空间膨胀很快，需要更好的函数逼近（神经网络）、更好的训练方案（CTDE），通常还需要更讲究的环境设计。</p><p>应对这些问题没有万能解法，但有一些经过验证的思路。针对虚假学习信号，可以用 CTDE 架构让 Critic 看到全局信息，帮助每个智能体更准确地评估自己动作的贡献。均衡陷阱的问题，自我对弈加上一定的探索机制能帮智能体跳出局部最优。规模问题则需要参数共享、注意力机制等技术来降低复杂度。</p><p>实际项目中，建议先在概念上理解集中式 Critic 的工作原理，不用急着写完整的深度 RL 代码。这一步会改变你思考可观测性和稳定性的方式，后面上手具体算法会顺畅很多。</p><p>作者：Syntal</p>]]></description></item><item>    <title><![CDATA[拒绝“PPT 造芯”，边缘 AI 芯片 IP 厂商 Quadric 拿下 3000 万美元 C 轮 ]]></title>    <link>https://segmentfault.com/a/1190000047549205</link>    <guid>https://segmentfault.com/a/1190000047549205</guid>    <pubDate>2026-01-17 23:02:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>当半导体一级市场回归理性，资本不再为单纯的“算力堆叠”买单，而是开始寻找真正能“落地”的技术。1 月 15 日，硅谷通用神经网络处理器（GPNPU）IP 厂商 Quadric 正式宣布完成 3000 万美元（约合人民币 2.17 亿元） 的 C 轮融资。本轮融资由 BEENEXT 管理的 ACCELERATE 基金领投，老股东 Uncork Capital、Pear VC 持续加注，新投资方阵容则颇具产业背景，包括 万向美国（Wanxiang America）、NSITEXE（丰田 / 电装生态圈）、MegaChips（日本大型无厂半导体公司）以及 Gentree 和 Volta 等。<br/><img width="500" height="332" referrerpolicy="no-referrer" src="/img/bVdnFSW" alt="" title=""/><br/>在端侧大模型（Edge LLM） 加速渗透的今天，Quadric 试图用一套“软件优先”的 GPNPU 架构，打破传统 NPU“不仅难用，还没法改”的僵局。</p><h3>1. 营收翻倍，不仅是“讲故事”</h3><p>芯片圈现在的融资环境大家有目共睹，光靠 PPT 已经很难从 VC 口袋里掏出钱了。Quadric 这轮融资之所以能成，核心在于其商业化进程的 “实锤”。根据官方通稿披露的数据，Quadric 在过去一年交出了一份相当硬核的成绩单：2025 年的 IP 许可与特许权使用费（Royalty）营收较 2024 年实现了三倍增长。截至目前，其累计融资总额已超过 7200 万美元。Quadric CEO Veerbhan Kheterpal 在谈及此次融资时底气十足地表示：“在这个充满挑战的融资环境中，能够超额认购完成 C 轮，直接证明了市场对我们‘代码优先’（Code-First）推理架构的认可。”</p><h3>2. 拿下关键 Design Wins：Tier IV 与亚洲大厂</h3><p>除了营收数据，Quadric 此次还披露了两个极具含金量的 Design Wins（设计中标），直接验证了其技术在高端市场的落地能力：日本自动驾驶软件巨头 Tier IV作为开源自动驾驶软件 Autoware 的维护者，Tier IV 将在其下一代 AD / ADAS 计算平台中集成 Quadric 的 Chimera GPNPU 核心。这对实时性要求极高的车规级市场来说，是一个重要的风向标。一家亚洲顶级芯片供应商（Top-Tier Asian Silicon Vendor）虽然官方未点名，但这大概率指向了本轮的战略投资方之一（如 MegaChips 等）。该厂商将在其边缘 SoC 中集成 Quadric IP，专门用于运行端侧大语言模型（Edge LLMs）。这标志着 Quadric 已经杀入了最火热的 AI PC / AI Phone 或边缘服务器赛道。</p><h3>3. 为什么要“革 NPU 的命”？</h3><p>目前市面上的边缘 SoC 设计，普遍还在用“CPU + DSP + NPU”的异构堆叠模式。看着分工明确，实则痛点不少：数据要在不同核心的内存间搬来搬去，功耗白白浪费；而且 NPU 往往是“黑盒”，开发门槛高，一旦算法变了（比如从 CNN 切到 Transformer），硬件可能就废了。</p><p>Quadric 搞的这个 Chimera™ GPNPU，核心逻辑就是做 减法与融合。软件定义的硬件：Quadric 强调 “C++ driven”，开发者不需要学习晦涩的专用语言，直接用 C++ 就能控制硬件。混合流水线：它在一个处理器里同时处理矩阵计算（AI 推理）和控制逻辑（C++ 代码）。这意味着，你不需要把数据在 CPU 和 NPU 之间来回倒腾，直接在 GPNPU 内部“一条龙”处理完。抗老化能力：对于汽车这种生命周期长达 10 年的产品，算法年年变。GPNPU 的可编程性，意味着车厂可以通过软件更新来支持未来的新模型，而不用更换硬件。</p><h3>4. 行业观察：资本向“应用侧”转移</h3><p>边缘计算社区观察到，本轮投资方的构成非常耐人寻味。除了财务投资人，NSITEXE（电装关联企业）、MegaChips 和万向美国 的入局，清晰地表明了产业链上下游的态度：汽车电子和工业自动化领域，急需一种更灵活、更高效的计算架构。随着 Transformer 架构日新月异，端侧大模型层出不穷，专用加速器（ASIC）“上市即落伍”的风险越来越大。Quadric 这种“通用性 + 高性能”的中间路线，或许正是解决当前边缘 AI 碎片化难题的一剂良药。据悉，这笔 3000 万美元 将重点用于扩大全球工程团队，并进一步打磨其软件开发工具链（SDK），毕竟对于 IP 厂商来说，生态好不好用，直接决定了客户愿不愿意用。</p><p><strong>参考材料</strong><br/>Quadric Press Release: Quadric Raises $30M Series C Funding to Accelerate On-Device AI<a href="https://link.segmentfault.com/?enc=z5qcnnYR97TTIkPxDsmbig%3D%3D.Kipe7io1mXMGUkaiOhohCr4xiSC0biiNDpP4vJrT1Pl4KvBUfqnrRt%2BBrwEg8dEFShaYnJmJdlIlpJiz89b8QuLf1yKvp4l6umEyowZ0Al4%3D" rel="nofollow" target="_blank">https://quadric.ai/press-release/quadric-raises-30m-series-c-...</a></p><p>Pulse 2.0: Quadric: $30 Million Series C Closed As Design Wins Accelerate<a href="https://link.segmentfault.com/?enc=ONCVg5pOcedzZKo1rpCnrQ%3D%3D.fu2jRju6NL6kjJy2BfQH4Yz8ggyqNIgyVMJBFbLLJ9GSTw7mDbh80k9b3UDhWhd0" rel="nofollow" target="_blank">https://pulse2.com/quadric-30-million-series-c/</a></p><p>Design &amp; Reuse: Quadric Raises $30M Series C Financing for GPNPU Architecture<a href="https://link.segmentfault.com/?enc=QkL%2BylH6koPb4lMP6g3Gog%3D%3D.0A7CsitbzFmFm9kiyRrXbhrucWbekA3g6qSbIj6AAbztMyJQKvKbofPOsh0261Zu7LIp%2FoWVovvVlwCgjcCzO9ZnHsftAFsWzphrK3CWV0k%3D" rel="nofollow" target="_blank">https://www.design-reuse.com/news/56829/quadric-series-c-fina...</a></p>]]></description></item><item>    <title><![CDATA[基于 YOLOv8 的桥梁病害（八类缺陷、病害高精度）自动检测 [目标检测完整源码] 南瓜 ]]></title>    <link>https://segmentfault.com/a/1190000047549215</link>    <guid>https://segmentfault.com/a/1190000047549215</guid>    <pubDate>2026-01-17 23:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>基于 YOLOv8 的桥梁病害（八类缺陷、病害高精度）自动检测 [目标检测完整源码]</h2><h3>一、背景与问题：桥梁检测为什么需要 AI？</h3><p>桥梁作为城市与交通网络中的关键基础设施，其服役周期长、受力复杂、环境影响显著。随着时间推移，桥梁结构不可避免地会出现<strong>裂缝扩展、混凝土退化、钢筋腐蚀、潮湿渗水等病害问题</strong>。若不能及时发现并处理，轻则影响通行安全，重则引发结构性风险。</p><p>传统桥梁检测主要依赖人工目测或人工+仪器结合的方式，普遍存在以下痛点：</p><ul><li>检测效率低，难以覆盖大规模桥梁资产</li><li>对检测人员经验依赖强，结果主观性高</li><li>数据难以结构化，不利于长期健康评估</li></ul><p>在此背景下，基于计算机视觉的<strong>自动化桥梁病害检测</strong>逐渐成为智能运维的重要发展方向。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549217" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><h3>源码下载与效果演示</h3><p>哔哩哔哩视频下方观看：</p><p><a href="https://www.bilibili.com/video/BV1m8g8z6Ejp/" target="_blank">https://www.bilibili.com/video/BV1m8g8z6Ejp/</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549218" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/>包含：</p><p>📦完整项目源码</p><p>📦 预训练模型权重</p><p>🗂️ 数据集地址（含标注脚本</p><h3>二、整体解决方案概述</h3><p>本文介绍的一套桥梁病害检测系统，采用 <strong>YOLOv8 目标检测模型</strong> 作为核心算法，并结合 <strong>PyQt5 桌面端可视化工具</strong>，构建了一条从模型训练到工程应用的完整技术链路。</p><h4>系统核心能力概览</h4><ul><li>支持 <strong>8 类典型桥梁缺陷与病害识别</strong></li><li>覆盖 <strong>图片、批量图片、视频、摄像头</strong> 等多种输入形式</li><li>提供 <strong>图形化操作界面</strong>，降低使用门槛</li><li>支持模型再训练与工程级部署</li></ul><p>该系统既可作为科研与教学案例，也可直接用于工程检测与巡检辅助。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549219" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549220" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>三、检测目标设计：让模型“看懂”桥梁问题</h3><p>在桥梁结构表面，病害往往呈现出<strong>尺度小、纹理细、形态多样</strong>的特点。针对工程实践需求，系统定义了以下八类检测目标：</p><ol><li>裂缝</li><li>收缩裂缝</li><li>底层收缩裂缝</li><li>混凝土退化</li><li>混凝土空洞</li><li>腐蚀</li><li>潮湿</li><li>路面劣化</li></ol><p>这些类别基本覆盖了常见桥梁表观病害类型，为后续健康评估与维修决策提供了结构化输入。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549221" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>四、为什么选择 YOLOv8？</h3><p>YOLOv8 是 Ultralytics 推出的新一代实时目标检测模型，在工程实践中表现出明显优势：</p><ul><li><strong>Anchor-Free 架构</strong><br/>对细长裂缝、小尺度缺陷更友好，减少人为先验约束。</li><li><strong>推理速度快</strong><br/>能够满足视频流与实时检测场景需求。</li><li><strong>训练与部署流程成熟</strong><br/>模型配置灵活，支持快速复现与迁移学习。</li><li><strong>多任务扩展能力强</strong><br/>为后续引入分割、姿态或多模态任务奠定基础。</li></ul><p>在桥梁病害这类“复杂背景 + 小目标”的场景中，YOLOv8 在精度与速度之间取得了良好平衡。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549222" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>五、数据集构建与训练流程</h3><h4>1. 数据组织方式</h4><p>系统采用标准 YOLO 数据格式，清晰划分训练集与验证集，便于模型迭代：</p><pre><code class="text">dataset/
├── images/
│   ├── train/
│   └── val/
├── labels/
│   ├── train/
│   └── val/</code></pre><p>每张图像均配有对应标注文件，记录目标类别及归一化边界框信息。</p><h4>2. 训练与评估策略</h4><p>模型训练过程中，重点关注以下指标：</p><ul><li><strong>box_loss</strong>：定位精度</li><li><strong>cls_loss</strong>：类别区分能力</li><li><strong>mAP@0.5</strong>：整体检测性能</li></ul><p>当模型在验证集上达到稳定收敛并取得较高 mAP 后，即可进入部署与应用阶段。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549223" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>六、推理与可视化系统实现</h3><h4>1. 模型推理逻辑</h4><p>系统基于 PyTorch 推理接口加载训练完成的 YOLOv8 模型，对输入图像或视频逐帧执行检测，输出包括：</p><ul><li>缺陷类别</li><li>置信度</li><li>边界框坐标</li></ul><p>这些信息可进一步用于统计分析或风险评估。</p><h4>2. PyQt5 图形化界面优势</h4><p>通过 PyQt5 封装推理流程，系统实现了：</p><ul><li>图像/视频/摄像头一键加载</li><li>检测结果实时展示</li><li>自动保存检测图片与日志</li><li>无需命令行操作的工程化体验</li></ul><p>这使得系统不仅面向算法工程师，也适用于检测人员与工程管理人员使用。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549224" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>七、典型应用场景</h3><p>该系统在多个实际场景中具备应用潜力：</p><ul><li>桥梁日常巡检与快速筛查</li><li>历史病害数据对比与趋势分析</li><li>科研机构桥梁健康监测研究</li><li>高校土木与智能建造课程教学</li></ul><p>通过持续积累检测结果，还可进一步构建桥梁全生命周期健康管理体系。</p><hr/><h3>八、未来扩展方向</h3><p>在当前系统基础上，可进一步拓展以下能力：</p><ul><li>引入 <strong>图像分割模型</strong>，实现裂缝精细化测量</li><li>融合 <strong>红外或多光谱数据</strong>，增强隐蔽病害识别</li><li>部署至 <strong>边缘计算设备或无人机平台</strong></li><li>结合时序数据，分析病害演化趋势</li></ul><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549225" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>结语</h3><p>本文介绍了一套面向实际工程应用的 <strong>桥梁病害智能检测系统</strong>，通过 YOLOv8 高性能目标检测模型与 PyQt5 可视化工具的结合，实现了从数据、模型到应用的完整闭环。</p><p>该方案在提升检测效率、降低人工成本、增强结果一致性方面具有显著优势，为桥梁智能巡检与结构健康监测提供了一条可落地、可扩展的技术路径，也为工业视觉在基础设施领域的应用提供了有价值的实践参考。</p><p>本文从实际工程应用角度出发，系统梳理了一套基于深度学习目标检测模型的智能识别解决方案，完整覆盖了数据准备、模型训练、推理验证以及应用系统集成等关键环节。通过将算法能力与可视化应用相结合，实现了从模型效果验证到业务可用系统落地的转化，体现了人工智能技术在真实场景中的工程价值。整体方案结构清晰、技术路线成熟，既具备较强的复用性与扩展性，也为相关领域的智能化升级提供了可参考、可落地的实现范式。</p>]]></description></item><item>    <title><![CDATA[【2026原创】文本情感识别系统~Python+深度学习+textCNN算法+模型训练 子午 ]]></title>    <link>https://segmentfault.com/a/1190000047549052</link>    <guid>https://segmentfault.com/a/1190000047549052</guid>    <pubDate>2026-01-17 20:04:41</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>一、项目介绍</h2><p>本项目是一个基于Text-CNN深度学习模型的中文文本情感识别Web应用系统。系统采用前后端分离架构，后端使用Flask框架构建RESTful API，深度学习模型采用TensorFlow/Keras实现的Text-CNN卷积神经网络，前端框架支持跨平台访问。</p><p>系统核心功能包括用户注册登录、JWT身份认证、中文文本情感分析、批量预测处理以及历史记录管理等。系统使用jieba分词对中文文本进行预处理，通过训练好的Text-CNN模型对文本情感进行二分类判断（积极/消极），并提供直观的置信度可视化展示。系统支持用户角色管理（普通用户和管理员），实现了基于RBAC的权限控制机制，确保数据安全和用户隐私。系统采用SQLite数据库存储用户信息和预测历史，使用Flask-Migrate进行数据库版本管理，保证了系统的可维护性和可扩展性。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047549054" alt="图片" title="图片"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549055" alt="图片" title="图片" loading="lazy"/></p><h2>二、选题背景与意义</h2><p>随着互联网技术的快速发展和社交媒体的普及，网络上产生了海量的文本数据，如用户评论、社交媒体帖子、产品评价等。这些文本数据中蕴含着丰富的情感信息，对于企业了解用户需求、改进产品服务、进行舆情监控等方面具有重要价值。传统的人工分析方式效率低下且成本高昂，无法满足大规模文本情感分析的需求，因此开发自动化的文本情感识别系统具有重要的现实意义。</p><p>中文文本情感识别相比英文更具挑战性，主要原因是中文语言的复杂性，包括分词困难、语义表达多样、网络用语丰富等特点。本系统针对中文文本特性，采用基于深度学习的Text-CNN模型进行情感分析，相比传统的机器学习方法（如SVM、朴素贝叶斯等），能够自动提取文本特征，避免了繁琐的人工特征工程，同时具有更高的准确率和更好的泛化能力。</p><p>本系统的设计和实现具有重要的理论意义和应用价值。在理论层面，探索了卷积神经网络在中文文本情感分析中的应用，验证了Text-CNN模型在中文情感二分类任务上的有效性。在应用层面，系统可应用于电商评论分析、社交媒体舆情监控、客户反馈分析等多个场景，为企业决策提供数据支持，具有广泛的实用价值。</p><h2>三、关键技术栈：text-cnn</h2><p>Text-CNN（Text Convolutional Neural Network）是本系统的核心深度学习模型，由Yoon Kim在2014年提出，将卷积神经网络成功应用于文本分类任务。相比传统的循环神经网络（RNN）和长短期记忆网络（LSTM），Text-CNN具有并行计算能力强、训练速度快、能够捕捉文本局部特征等优势，特别适合文本分类任务。</p><p>Text-CNN的模型结构主要包含四个部分：嵌入层（Embedding Layer）、卷积层（Convolutional Layer）、池化层（Pooling Layer）和全连接层（Fully Connected Layer）。在嵌入层，系统将预处理后的中文分词转换为密集的词向量表示，捕捉词语的语义信息。卷积层使用多个不同尺寸的卷积核（如3、4、5个词窗口）对文本进行卷积操作，提取文本的局部特征，类似于N-gram特征提取。池化层采用最大池化（Max Pooling）操作，从每个卷积核的输出中提取最重要的特征，降低特征维度并保留最显著的情感特征。全连接层将池化后的特征进行整合，通过Softmax激活函数输出分类概率。</p><h2>四、技术架构图</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549056" alt="图片" title="图片" loading="lazy"/></p><h2>五、系统功能模块图</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047549057" alt="图片" title="图片" loading="lazy"/></p><h2>演示视频 and 完整代码 and 安装</h2><p>地址：<a href="https://link.segmentfault.com/?enc=uXHyAacC%2Bh1vgIp76i3LZQ%3D%3D.CVoEtq0K7VPeCPWJuJ8DSQwf0%2BEJJOyQfbmVUgqTghbbFH8b39oG79JjEzFeEyi%2BrzJZjmzJd2EjdEzDllo67g%3D%3D" rel="nofollow" target="_blank">https://www.yuque.com/ziwu/qkqzd2/py2zlsgq894x4eq6</a></p>]]></description></item><item>    <title><![CDATA[AI已站在招聘门口，传统招聘方式正面临挑战 爱跑步的香蕉_cKtiNz ]]></title>    <link>https://segmentfault.com/a/1190000047549066</link>    <guid>https://segmentfault.com/a/1190000047549066</guid>    <pubDate>2026-01-17 20:03:58</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>AI已站在招聘门口，传统招聘方式正面临挑战<br/>如今，不少招聘场景中都存在这样的困境：简历数量持续增多，但符合需求的候选人却愈发稀缺；HR 日程被面试排满，业务部门对招聘结果仍不满意；企业招人时愈发谨慎，却依然难以避免“招错人”的情况。</p><p>事实上，AI 早已不是未来的概念，而是以 AI 面系统、AI 招聘系统的形式，深度参与到招聘前端流程中，影响着候选人的筛选结果，招聘的权力结构已然发生改变。<br/>传统招聘模式长期被三大问题困扰：初筛流程繁琐，HR 与业务面试官深陷重复面试工作；人才评价高度依赖个人经验，结果缺乏复盘依据；时间、人力成本不断增加，错招带来的损失也难以量化，这些问题直接导致招聘效率下滑，并非 HR 不够专业，而是传统工具已难以适配当下的招聘需求。<br/>AI 招聘系统的出现，正是为了解决传统招聘的低效、主观与成本失控问题。它并非要取代 HR，而是将 HR 从大量重复、低价值的工作中解放出来，其核心优势集中在精度与体验两个方面。<br/>在精准度上，成熟的 AI 招聘系统打分体系经过了人机对比实验验证，且通过了效标效度与重测稳定信度两项心理学核心指标检验，打分结果可直接作为招聘决策依据，让人才选拔从经验驱动转向科学判断。以先进的 AI 面试智能体为例，一道问题就能同步评估多项胜任力，衔接初筛与技术复试，整体评估效率提升 50% 以上。系统能根据候选人实时回答自由追问，深度挖掘简历关键信息与模糊点，生成递进式提问，既降低信息造假风险，也避免遗漏优质候选人。同时，它既能覆盖沟通、协作等通用胜任力评估，也能针对编程、算法等专业岗位精准出题，减轻 HR 与专业面试官的负担。<br/>在候选人体验上，优质的 AI 面试系统会注重提升交互感受。系统能识别候选人的语速、情绪变化，像真人 HR 一样进行引导，帮助候选人发挥真实水平；面试无需手动操作开始或结束，系统自动判断回答状态并衔接下一问题，更贴近真实交流场景。在视觉与交互设计上，语音与口型匹配精度提升，减少 AI 面试的疏离感；候选人面试中可随时提问，系统能解答职位信息、公司福利等问题，帮助候选人深入了解企业与岗位。<br/>招聘行业正在发生变革，AI 不会取代 HR，但低效、主观、不可验证的招聘方式终将被淘汰。HR 的价值正在被重新定义，智能招聘工具的应用，让招聘流程更高效、判断更精准，也为企业与候选人搭建起更优质的沟通桥梁。</p>]]></description></item><item>    <title><![CDATA[《异步分布式训练提速关键：梯度压缩的收敛稳定性操控指南》 程序员阿伟 ]]></title>    <link>https://segmentfault.com/a/1190000047549077</link>    <guid>https://segmentfault.com/a/1190000047549077</guid>    <pubDate>2026-01-17 20:03:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>梯度传输的带宽消耗始终是制约效率的关键枢纽，而梯度压缩作为突破这一瓶颈的核心手段，其真正的技术难点从未停留在压缩比例的提升，而是如何在极致削减数据传输量的同时，守住收敛稳定性的底线。很多实践者容易陷入“压缩率越高越好”的认知误区，却忽视了异步环境下各节点计算节奏差异、梯度更新延迟等因素与压缩操作的叠加效应，往往导致模型训练出现震荡加剧、收敛曲线平缓甚至倒退的问题，这种问题在千万级以上参数模型的长周期训练中表现得尤为明显，不少团队耗费大量算力资源，最终却因梯度压缩策略不当导致训练半途而废。真正的技术深耕者会发现，梯度压缩的本质并非简单的信息删减，而是梯度特征的结构化保留与噪声过滤，如何在数据量锐减的情况下，让核心梯度信息完整传递并有效作用于模型更新，才是决定训练成败的关键，这需要跳出单纯的算法优化，从梯度传播规律、节点协同逻辑、误差补偿机制等多维度构建系统性解决方案，实现效率与精度的双向平衡。</p><p>异步分布式训练的核心挑战在于各节点的独立性与全局模型的一致性之间的天然矛盾，而梯度压缩的介入会进一步放大这种矛盾，其根源在于梯度过时与压缩误差的双重叠加。在异步架构中，各工作节点独立完成本地计算后直接上传梯度，无需等待其他节点，这种模式虽然提升了资源利用率，但不同节点的计算速度、数据处理规模存在天然差异，部分节点可能因硬件性能不足或数据批次复杂，导致上传的梯度基于的是较早版本的全局参数，形成明显的梯度过时现象，这种现象在异构算力集群中更为突出，GPU节点与CPU节点的计算效率差异可能让梯度版本差达到数轮之多。当引入梯度压缩后，无论是量化操作对梯度精度的损耗，还是稀疏化对梯度维度的裁剪，都会在梯度过时的基础上增加新的误差源，这些误差如果不能得到有效管控，就会在迭代过程中不断累积，最终破坏梯度下降的整体方向，让模型参数更新偏离最优路径。解决这一问题的关键在于建立“动态感知-误差校准”的联动机制，通过实时捕捉各节点的计算状态、参数版本差异，为不同节点的压缩梯度分配动态权重，让过时程度较轻、信息密度较高的梯度获得更高的更新优先级，同时对压缩过程中丢失的细粒度特征进行合理推演补偿，从而在保持异步训练高效性的前提下，最大限度降低误差累积对收敛的影响。</p><p>梯度压缩的精度守护不能依赖单一的压缩算法优化，而需要构建“结构化保留-自适应调整”的双重保障体系，让压缩操作与训练进程深度耦合。传统的固定阈值稀疏化或均匀量化方法，之所以容易导致收敛波动，核心在于其忽略了梯度在不同训练阶段的分布特性差异——训练初期梯度分布分散，核心特征不突出，过度压缩会丢失关键更新信号，导致模型无法快速找到有效下降方向；训练后期梯度逐渐集中，冗余信息增多，但细粒度梯度对精度微调至关重要，简单的量化会抹平这些关键差异，让模型难以逼近最优收敛点。基于实践中的观察与探索，有效的做法是采用基于梯度分布特征的动态压缩策略，通过分析梯度的概率分布形态、特征重要性排序，建立层级化的保留机制，对影响模型决策的核心梯度分量采用低压缩比甚至不压缩，对冗余梯度则根据其贡献度动态调整压缩强度，比如在计算机视觉模型训练中，针对卷积层的梯度采用差异化压缩，对边缘检测相关的梯度分量重点保留。同时，将压缩策略与模型的训练状态实时联动，通过监测训练损失曲线的变化速率、参数更新的稳定性，自适应调整压缩参数，当发现收敛出现波动时，自动降低压缩强度或启动误差补偿机制，确保压缩操作始终服务于收敛目标，而非单纯追求传输效率。</p><p>误差补偿机制是梯度压缩中守护收敛稳定性的隐形核心，其设计的关键在于精准识别压缩过程中丢失的有效信息，并通过合理的推演与反馈实现损失弥补。很多压缩方案之所以失败，并非因为压缩比例过高，而是缺乏有效的误差补偿逻辑，导致每次压缩造成的信息损失不断累积，最终偏离最优收敛路径，这种累积误差在小批量训练场景中尤为致命，可能让模型在几轮迭代后就出现性能断崖式下跌。实践中发现，梯度压缩造成的误差并非随机噪声，而是具有明显的结构性特征——量化误差多集中在梯度的细粒度分量，这些分量看似对单次更新影响微小，却在长周期训练中决定着模型的最终精度；稀疏化误差则表现为部分低频但关键的梯度信号被过滤，这类信号往往与模型的泛化能力密切相关。针对这些特性，可构建双轨制误差补偿体系：一方面，通过维护本地残差梯度缓存，将每次压缩过程中丢弃的梯度信息以残差形式累积，在下一轮迭代中与新计算的梯度融合后再进行压缩，实现误差的渐进式抵消，这种方式尤其适合处理量化带来的细粒度误差；另一方面，引入梯度相关性校准机制，通过分析历史梯度更新与模型性能变化的关联规律，对当前压缩后缺失的关键特征进行合理推演，生成补偿梯度并融入全局更新过程，这种方式能有效修复稀疏化导致的低频信号丢失问题。</p><p>异步环境下的节点协同策略对梯度压缩的收敛效果具有决定性影响，其核心在于通过优化节点间的信息交互逻辑，降低压缩误差与梯度过时的叠加效应。在传统异步训练中，参数服务器被动接收各节点上传的压缩梯度并直接聚合，这种模式容易导致不同节点的梯度误差相互干扰，尤其是当部分节点的压缩梯度存在较大偏差时，会直接影响全局模型的更新方向，让收敛曲线出现剧烈震荡。通过大量实践验证，优化节点协同的关键在于建立“梯度质量评估-有序聚合”机制，参数服务器在接收压缩梯度时，首先对其质量进行多维度评估，包括梯度与当前全局参数的匹配度、压缩误差的预估大小、节点历史贡献度等，这些评估维度并非固定不变，而是根据训练阶段动态调整权重，比如训练初期侧重梯度匹配度，训练后期侧重压缩误差控制。根据评估结果对梯度进行优先级排序，优先聚合质量较高、误差较小的梯度，同时对质量较低的梯度进行适度加权衰减，降低其对全局更新的干扰，避免低质量梯度主导参数更新方向。此外，通过动态调整节点的梯度上传频率，让计算性能强、数据质量高的节点获得更频繁的上传权限，减少低质量梯度的传输与聚合，从源头降低压缩误差对收敛的负面影响，形成节点协同与梯度压缩的良性循环。</p><p>梯度压缩的收敛稳定性最终需要在大规模、长周期的训练场景中得到验证，而实践中的核心认知在于，压缩策略的设计必须兼顾精度守护与工程可行性，避免陷入“为了稳定而牺牲效率”的另一个极端。在千万级参数模型的训练实践中发现，单纯追求理论上的精度无损压缩是不现实的，合理的精度损耗是换取效率提升的必要代价，关键在于建立“损耗可控-动态平衡”的决策框架，明确模型精度的容忍阈值，这个阈值需要结合具体任务需求设定，比如工业级模型可接受1%以内的精度损耗，而科研级模型则需要控制在0.5%以下。通过设定收敛精度的容忍阈值，在训练过程中实时监测精度变化，当损耗在阈值范围内时，最大化压缩效率；当损耗超出阈值时，自动启动调整机制，通过降低压缩比、强化误差补偿等方式将精度拉回可控范围。</p>]]></description></item><item>    <title><![CDATA[《从理论到应用：量子神经网络表达能力的全链路优化指南》 程序员阿伟 ]]></title>    <link>https://segmentfault.com/a/1190000047549080</link>    <guid>https://segmentfault.com/a/1190000047549080</guid>    <pubDate>2026-01-17 20:02:22</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>量子神经网络的表达能力绝非经典模型的简单升级，而是源于量子态演化带来的维度重构与关联重塑，其核心奥秘藏在希尔伯特空间的隐式拓展与量子特性的深度融合中。很多研究者容易陷入将量子优势归因于并行性的表层认知，却忽视了叠加与纠缠如何从本质上改变函数映射的底层逻辑，导致理论分析与实践落地脱节，这种认知偏差使得不少研究停留在“量子概念嫁接经典模型”的层面，未能触及量子表达能力的核心内核。真正的深层探索会发现，量子神经网络的表达能力本质是“量子态表征的结构化赋能”，它能通过非局域关联捕捉经典模型难以企及的复杂特征交互，在高频信号拟合、高维系统建模等场景中展现出指数级的表达效能，这种优势并非来自算力的线性提升，而是源于对数据内在关联的量子化重构，需要从态设计、电路架构、协同机制等多维度建立系统性的理论认知，唯有如此才能打破“量子优势停留在理论层面”的困境，让量子神经网络的表达潜力真正释放。</p><p>量子特性对表达能力的赋能并非零散作用，而是通过“叠加介导的维度拓展”与“纠缠驱动的关联强化”形成协同效应，这种协同在具体场景中呈现出独特的表达优势。在高频信号表征任务中，经典模型往往需要通过增加网络层数或参数数量来逼近信号的细微波动，却容易陷入过拟合或参数冗余的困境，甚至会因梯度消失问题导致模型无法捕捉到信号的深层特征，而量子神经网络借助叠加态对多频率分量的同步承载，能够在有限参数下实现对高频特征的精准捕捉，无需额外增加复杂度就能覆盖更广泛的特征空间。纠缠特性则让量子比特之间形成非局域关联，这种关联无需依赖数据的显式交互，就能自然刻画特征间的隐性依赖，在复杂系统建模中，比如量子化学分子结构预测，这种关联机制能有效捕捉原子间的长程相互作用，而经典模型需要通过复杂的核函数设计才能勉强逼近，且难以兼顾计算效率与拟合精度。更关键的是，这种量子赋能并非无边界，其表达效能受到量子相干时间与门操作保真度的约束，如何在特性利用与噪声管控之间找到平衡，成为理论分析必须破解的核心命题，这也是区分量子神经网络理论研究深浅的关键标尺。</p><p>量子电路的架构设计直接决定表达能力的上限与落地可行性，不同的电路结构在特征提取、维度映射、关联建模上呈现出截然不同的效能表现。输入态的设计是架构优化的起点，通过线性组合技术构建特殊输入态，能够在不增加电路深度的前提下，显著拓展量子态的可及范围，让模型在有限资源下覆盖更丰富的函数空间，比如基于相干态的输入设计，就能有效提升模型对连续变量数据的表征能力。在电路深度的选择上，过深的结构虽然能提升理论表达能力，却会因噪声累积和贫瘠高原问题导致实际表达效能下降，甚至会让模型陷入参数无法有效优化的困境，而浅层电路虽具备更好的可训练性，却可能因表达范围有限无法应对复杂任务。实践中发现，采用“层级化门操作组合”的架构设计，将单量子比特旋转门与多量子比特纠缠门交替排布，能够在深度与效能之间形成最优平衡，这种结构既通过旋转门实现特征的精细调校，又借助纠缠门构建全局关联，在图像隐式表征等场景中，能以远少于经典模型的参数实现更高的拟合准度，同时还能降低门操作的误差累积，提升模型的实际应用价值。</p><p>量子神经网络的表达边界并非固定不变，而是通过与经典系统的混合架构实现动态拓展，这种混合模式既规避了纯量子系统的硬件限制，又充分发挥了量子表达的核心优势。混合参数化量子态框架通过将量子测量结果与经典神经估计器相结合，能够有效弥补量子测量的统计不确定性，在低测量条件下依然保持稳定的表达能力，这种模式突破了纯量子模型对大规模量子比特和高精度测量设备的依赖，让量子神经网络的研究能够在现有NISQ时代的硬件条件下稳步推进。在复杂分类任务中，相比纯量子或纯经典模型，这种混合架构展现出更高的准度与鲁棒性，其核心在于分工协作的合理性——量子模块专注于高维特征的隐式映射，经典模块则负责误差补偿与细节优化，两者的协同效应远超单一系统的表现。在信号处理场景中，这种协同能让量子模块捕捉核心频率特征，经典模块则修正量子噪声带来的细微偏差，形成1+1&gt;2的表达效能，更重要的是，混合架构为量子表达能力的工程化落地提供了可行路径，它降低了对量子硬件的苛刻要求，让量子表达的理论优势能够在现有技术条件下逐步释放，加速了量子神经网络从实验室走向实际应用的进程。</p><p>抗噪声能力是量子神经网络表达能力从理论走向实践的关键支撑，噪声的存在会直接扭曲量子态的演化轨迹，削弱叠加与纠缠的表达效能，因此构建抗噪声的表达机制成为理论分析的重要维度。量子系统的噪声主要源于环境干扰与门操作误差，这些噪声会导致量子态退相干，破坏特征映射的完整性，尤其在深层电路中，噪声的累积会让表达能力急剧下降，甚至会让量子模型的性能反超经典模型的优势荡然无存。实践中发现，通过“态保护设计”与“动态误差校准”的双重机制，能够有效缓解噪声的负面影响，态保护设计通过优化量子门的序列排布，增强量子态对环境干扰的鲁棒性，比如采用动态解耦技术，通过周期性的脉冲操作抵消环境的相干影响，延长量子态的有效相干时间。动态误差校准则借助经典算法对量子测量结果进行实时修正，抵消噪声带来的表达偏差，比如基于卡尔曼滤波的校准方法，就能有效降低测量过程中的统计误差。在含噪量子比特环境中，这种抗噪声机制能让量子神经网络在常数深度下，依然保持对经典模型的表达优势，即使面临局域随机噪声，也能通过逻辑建议态与魔法态注入协议，维持核心特征的有效映射，为量子神经网络的实际部署扫清关键障碍。</p><p>量子神经网络表达能力的理论分析最终需要回归实践适配性，脱离具体应用场景的理论探讨毫无意义，真正有价值的理论必须能够指导架构设计、参数调校与场景适配。在高频信号拟合场景中，理论分析明确了量子电路的频谱覆盖范围与门操作组合的对应关系，指导实践者通过调整旋转门的参数分布，优化对特定频率区间的表达效能，让模型能够精准捕捉到雷达信号中的微弱目标特征，这一指导作用在军事探测领域具备极高的实用价值。在分子结构建模中，基于纠缠关联的理论认知，能够帮助设计者确定量子比特的连接方式，精准捕捉原子间的长程相互作用，为新型药物分子的研发提供高效的建模工具，缩短药物研发的周期。</p>]]></description></item><item>    <title><![CDATA[如何在高并发场景下保持99.99%文档转换精度 陌上 ]]></title>    <link>https://segmentfault.com/a/1190000047548872</link>    <guid>https://segmentfault.com/a/1190000047548872</guid>    <pubDate>2026-01-17 20:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在当今数字化工作流中，<strong>高并发</strong><a href="https://link.segmentfault.com/?enc=ge5mSxdCgpytVV1znXXaxQ%3D%3D.AvLLVHWE9bbpBPV5B3mSTxSHHYxZo1b1Asp7JF5BWhDS12dYaC9WtD5sXIJxEJtquzrDVz03plRxVArCOiIDWwCsEzvyQhc73wBjmHmo6msdElS%2BpVPIciTOgXDVuopeGgTQc1IfgxQV7IZLhNzHty0olylG5lcvHv4nXB7jdJhIlSt0Nt3sS1pm5MRCQsCSJTy5YtTOzrzYd8W45Dvtd2JKcBOAz3%2Fq03ZRljoyXjw%3D" rel="nofollow" title="文件转档" target="_blank">文件转档</a><strong>处理</strong>已成为金融、法律、企业服务等众多行业的常态。系统需要在瞬间处理海量文件请求，而<strong>保持接近完美的转换精度</strong>则是保障业务连续性与数据可靠性的核心挑战。这不仅关乎单一文件的准确度，更涉及在持续高压下，系统整体表现的<strong>稳定性与一致性</strong>。</p><p>本文将深入探讨实现这一目标的技术架构与策略，并以ComPDF的转档SDK V3.0为例，解析其如何通过技术创新应对这一挑战。</p><h2>一、高精度与高并发的核心矛盾与解决思路</h2><p>在高并发场景下，维持高精度主要面临三大矛盾：</p><p>1.  <strong>资源竞争与处理质量</strong>：大量并发任务争夺计算资源（CPU、内存），可能导致单个任务处理不充分，进而影响布局分析、字体还原等关键环节的精度。</p><p>2.  <strong>处理速度与深度分析的平衡</strong>：追求极速转换可能迫使简化分析算法，牺牲对复杂表格、混合版式的深度识别。</p><p>3.  <strong>系统稳定性与异常处理</strong>：在高负载下，系统需保持健壮，任何微服务宕机或性能波动都可能导致批量任务失败或精度下降。</p><p>解决这些矛盾，需要从<strong>系统架构、核心算法和工程实践</strong>三个层面协同设计。</p><h2>二、架构基石：为高并发高精度而生的系统设计</h2><p>1.  <strong>微服务化与弹性伸缩</strong>：</p><p>    *   将文档转换流程拆分为独立的微服务，如<strong>文件解析、布局分析、元素识别（AI模型）、格式渲染、输出合成</strong>等。这允许对每个环节进行独立扩容。</p><p>    *   当并发请求激增时，通过Kubernetes等编排工具，<strong>弹性伸缩</strong>负责AI推理和渲染等计算密集型服务的实例数，确保每个任务都能获得足够的计算资源以维持精度，避免因排队过长或资源不足导致处理质量下降。</p><p>2.  <strong>智能队列与优先级调度</strong>：</p><p>    *   并非所有文档都同等复杂。系统可集成<strong>智能预分析</strong>模块，根据文档页数、内容密度、包含元素（如大量表格、图片）初步判断处理难度。</p><p>    *   据此实施<strong>差异化队列调度</strong>：将简单文档分配至快速通道，复杂文档分配至拥有更强算力保障的精确处理通道。这种<strong>资源精细化调度</strong>是保证整体吞吐量与高精度并存的关键。</p><p>3.  <strong>状态持久化与断点续转</strong>：</p><p>    *   在高并发环境下，任何节点故障都可能发生。必须将每个转换任务的中间状态和进度<strong>持久化</strong>到可靠的分布式存储中。</p><p>    *   一旦某个处理节点失败，任务能被迅速<strong>重新调度</strong>至其他节点，并从断点处继续，避免整个文档转换重头开始，这对处理到一半的大型文件至关重要，既节省资源，也保障了任务完成的可靠性。</p><h2>三、精度引擎：ComPDF转档SDK V3.0的技术实践</h2><p>ComPDF的<a href="https://link.segmentfault.com/?enc=HjwW8eaVn7Ff0gZBoHa3Jw%3D%3D.%2FZauFnQenCBJpwCh90szFoRv7m9n5XOXStdzMRGymX%2BXL4w7QR4qXEhZyKUDkySgUBrkzXtBBlWCjwAR3Hr4Y%2BsnBBKQutsQMwa3ramRGh16C7BWU6Z%2FWUb8gH18SOhke7q4jNTZ4v%2BuIWpEgcpAuCJczAF4ZoNJC0pILQdDs98yG3%2Byxd2Wq4RfN7UOnASUi1DMCuoEtjJNZHvsRVpyy%2BayzjVmnMZiHa5xSJm9ZTf29%2Fmzk6tfg7kbnJs8ajAjSYwI3ZKk4zU%2FRhwy%2BBDxiQ%3D%3D" rel="nofollow" title="转档SDK" target="_blank">转档SDK</a> V3.0的设计体现了上述架构思想，并通过多项核心技术，<strong>将高并发下的高精度转化为了可实现的指标</strong>。</p><h3>1. AI驱动的混合布局分析技术</h3><p>这是其实现高精度的核心。传统转换SDK往往只能在“流式布局”（利于编辑，但易失真）和“固定布局”（保持原貌，但编辑困难）间二选一。</p><ul><li><strong>技术突破</strong>：V3.0版本集成了<strong>PP-YOLOE AI模型</strong>，并升级了布局分析算法，创新性地采用了<strong>智能混合布局技术</strong>。它能动态分析文档不同区域的特征，智能结合流式与固定布局的优势。</li><li><strong>精度影响</strong>：此举能<strong>99%准确还原多栏排版、图文混排、目录等复杂结构</strong>，同时保持内容的自然阅读顺序。在高并发时，该AI模型以服务化部署，通过弹性伸缩保障每个文档的布局分析深度，这是维持高精度的算法基础。</li></ul><h3>2. 像素级元素识别与恢复</h3><p>精度体现在细节。V3.0的AI模型经过海量文档训练，能识别超过30种文档元素类型。</p><ul><li><strong>关键改进</strong>：通过<strong>像素级精准分析</strong>，有效防止了将页眉、页脚内容误判为正文，同时将<strong>段落间距和行高的还原准确率提升了80%</strong>。</li><li><strong>高并发适配</strong>：这种精细化的识别能力，确保系统即使在批量处理时，也不会因为“赶工”而忽略细节。统一的AI模型服务确保了处理标准的一致性，无论第1个还是第1000个并发任务，都能获得相同的识别精度。</li></ul><h3>3. 企业级性能与批量处理优化</h3><p>高精度离不开性能支撑。V3.0通过重构数据结构和转换流水线，实现了效率飞跃。</p><ul><li><strong>性能数据</strong>：支持<strong>数千页文档秒级批量转换</strong>，平均处理速度达到<strong>每页0.5–0.8秒</strong>，且整体处理速度比以往提升50%。</li><li><strong>高并发意义</strong>：极高的单任务处理速度，直接降低了系统在单位时间内的平均负载，为应对并发洪峰留下了更多资源余量。快速处理也意味着<strong>更短的队列等待时间</strong>，减少了任务因排队超时或资源调度延迟而出错的风险。</li></ul><h2>四、超越SDK：构建全链路保障体系</h2><p>仅依靠一个强大的SDK并不足够。在生产环境中，围绕它构建全链路保障体系至关重要：</p><p>1.  <strong>渐进式负载测试与降级策略</strong>：</p><p>    *   在上线前，必须进行远高于预估峰值的负载测试，观察在不同压力下转换精度的变化曲线，找到性能拐点。</p><p>    *   制定清晰的<strong>服务降级策略</strong>。例如，当系统负载超过阈值80%时，可自动暂时关闭对“高保真图片嵌入”等非核心但耗资源功能的支持，优先保障正文、表格等核心元素的转换精度，实现“精度有损，服务可用”。</p><p>2.  <strong>多维度的监控与告警</strong>：</p><p>    *   监控指标不应仅有CPU、内存和QPS（每秒查询率），更需包含<strong>业务精度指标</strong>。例如，通过抽样对比，监控“表格结构保持率”、“字体属性正确率”的时序变化。</p><p>    *   设置精度阈值告警（如批次任务平均精度跌破99.9%），使运维团队能在用户体验受影响前主动干预。</p><p>3.  <strong>持续的回流验证与模型迭代</strong>：</p><p>    *   建立自动化回流验证管道，定期抽取生产环境中已处理的文档，进行精度复核。</p><p>    *   将发现的问题案例（如特定版式的转换缺陷）加入训练集，持续迭代优化SDK内部的AI模型，形成一个<strong>从线上问题到模型改进的闭环</strong>，让系统精度在动态中持续进化。</p><h2>结论</h2><p>在高并发场景下坚守99.99%的文档转换精度，是一项系统性的工程。它要求我们将<strong>弹性可扩展的微服务架构</strong>、<strong>智能精准的核心算法</strong>以及<strong>严谨的全链路工程实践</strong>三者深度融合。</p><p>其终极目标，是在流量洪峰中，让每一份文档的转换，都如同在静水中处理一样精准、可靠。这不仅是技术的胜利，更是对业务连续性与数据价值的最坚实保障。</p>]]></description></item><item>    <title><![CDATA[如何选择适合跨境电商的全球代理IP？ IPDEEP ]]></title>    <link>https://segmentfault.com/a/1190000047548907</link>    <guid>https://segmentfault.com/a/1190000047548907</guid>    <pubDate>2026-01-17 17:04:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>在跨境电商运营中，代理IP已经成为保障业务顺利运行的重要工具。无论是进行多账号管理、广告投放，还是接触地区限制，都离不开代理IP的帮助。然而，面对市场上种类繁多的代理IP，如何挑选最合适自己的产品呢？下面就跟着小编一起来看看吧！<br/><img width="723" height="368" referrerpolicy="no-referrer" src="/img/bVdnFN0" alt="如何选择适合跨境电商的全球代理IP？" title="如何选择适合跨境电商的全球代理IP？"/></p><p>1.理解不同类型的代理IP</p><p>代理IP根据分配方式和使用场景，可分为以下几类：</p><p>静态代理IP：IP长期固定，适合需要稳定身份的账号操作或业务场景</p><p>动态代理IP：IP自动轮换，适合大规模数据采集或短时间多账号操作，能有效降低封号风险。</p><p>移动代理IP：基于移动网络的IP，灵活度高且难以被封，适合要求高匿名性的场景。</p><p>数据中心代理IP：速度快，成本低，但容易被部分平台识别，需要根据具体需求使用。</p><p>2.明确你的需求</p><p>在选择代理IP之前，要明确你的使用场景：</p><p>多账号管理：避免账号被封，需要稳定且安全的IP。</p><p>跨境广告投放：需要覆盖目标市场的IP，以保证广告展示效果。</p><p>数据抓取：需高匿名性和高并发支持，保证采集效率。</p><p>3.稳定性和安全性</p><p>稳定性和安全性直接影响业务运营：</p><p>高可用性：IP 长时间在线，保证任务不中断</p><p>匿名性和防封锁：高匿名性 IP 可隐藏真实身份，降低账号封禁风险</p><p>防检测能力：部分代理提供反指纹或防检测功能，适合高风险场景</p><p>4.全球覆盖与目标市场匹配</p><p>跨境电商涉及多个国家和地区，因此代理IP的地理分布尤为关键：</p><p>优先选择覆盖目标市场的IP，保证访问速度与体验</p><p>要注意部分地区对 IP 的限制，保证访问速度与体验</p><p>若业务涉及多个国家，可选择支持全球多节点的供应商，便于灵活调配。</p><p>5.成本与服务支持</p><p>虽然高质量代理 IP 成本比较高，但对跨境电商的长期效益更大。选择时建议：</p><p>对比不同供应商的价格和套餐，结合使用频率和需求选购</p><p>关注售后支持与技术服务，确保出现问题能够及时解决</p><p>总结</p><p>选择适合跨境电商的全球代理IP并非单纯比价格，而是综合考虑需求、类型、地区覆盖、稳定性和服务。明确业务需求，选择合适的类型和供应商，再通过小规模测试验证效果，才能够确保代理 IP 为跨境运营带来实际价值。</p>]]></description></item><item>    <title><![CDATA[Microsoft AI Genius | 解锁多模态智能体构建，从 0 到 1 极速上手！ 微软技]]></title>    <link>https://segmentfault.com/a/1190000047548914</link>    <guid>https://segmentfault.com/a/1190000047548914</guid>    <pubDate>2026-01-17 17:03:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>从 Ignite 的技术发布到真实生产落地，AI 正在加速走向“可用、可扩展、可集成”。Microsoft AI Genius 第三季正式开启，第一期课程将聚焦开发者最关心的话题之一：如何快速构建真正可用的多模态智能体应用。</p><p>本期课程将<strong>围绕 Microsoft Foundry（国际版）+ AI Toolkit</strong> 的组合方案，带你在 VS Code 中完成从模型选型、Prompt 与上下文工程，到智能体原型构建与企业级工作流集成的完整实践路径。无需复杂环境配置，即可把最新模型能力转化为贴近业务的 AI 应用。</p><p><img width="723" height="1301" referrerpolicy="no-referrer" src="/img/bVdnFN6" alt="50f6dc90d412c9f9080ec42b14921c0c.png" title="50f6dc90d412c9f9080ec42b14921c0c.png"/></p><p><strong>您将学到</strong></p><ul><li><strong>模型选型技巧：</strong>在 Foundry Model Catalog 中比较最新模型，找到最适合您的项目。</li><li><strong>上下文工程：</strong>优化 Prompt，添加业务上下文，提升结果准确度。</li><li><strong>快速构建智能体：</strong>用 AI Toolkit Agent Builder + MCP，快速实现基于业务逻辑的智能体。</li></ul><p>无论您是想入门 AI 开发的新手，还是希望提升智能体落地效率的资深开发者，这场直播都能为您提供切实助力。无需复杂铺垫，跟随课程节奏就能吃透核心技术栈，把从 Ignite 带来的前沿理念，快速转化为可落地的技术方案。</p><p>1月21日14:00-15:30，锁定 Microsoft AI Genius 第三季首期直播，解锁多模态智能体的极速构建秘籍，让 AI 开发从“难落地”变为“快上手”！</p>]]></description></item><item>    <title><![CDATA[告别卡顿！vue 复杂的的高性能表格哪家强，以项目中使用过的 ag-grid 和 vxe-table]]></title>    <link>https://segmentfault.com/a/1190000047548917</link>    <guid>https://segmentfault.com/a/1190000047548917</guid>    <pubDate>2026-01-17 17:03:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>告别卡顿！vue 复杂的的高性能表格哪家强，以项目中使用过的 ag-grid 和 vxe-table 来评测。在企业级表格中，适用于 vue 框架的 2 个优秀表格 AgGrid 和 VxeTable 比较具备代表性，一个是原生 js 组件，一个是纯血 vue 生态组件。</p><h2>前言</h2><ul><li>当项目中加载的数据比较少时，那么选择任意一个表格都是没问题的，在 vue 中不管是主流的 element plus 还是 antd vue 的自带的 table组件都基本够用。当时当涉及加载大大量数据的表格列表时，就会出现非常大的卡顿，比如加载1000行甚至10000行数据时，如果表格稍微带点负责功能，比如冻结列/样式等，大量的Dom元素，cpu直接100%，就会非常卡顿，甚至页面都卡死。</li><li>这时我们就可选择 ag-grid（功能强大，体积大，大数据加载非常流畅，社区版功能少部免费和企业版收费），vxe-table（功能非常强大，体积中等，大数据加载流畅，开源版功能多免费和企业版收费）</li></ul><h2>vxe-table 来写一个简单使用例子</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047548919" alt="Video_2026-01-17_160706-ezgif" title="Video_2026-01-17_160706-ezgif"/></p><p>vxe-table 静态标签式 的使用</p><pre><code class="html">&lt;template&gt;
  &lt;vxe-table height="500" :data="tableData"&gt;
    &lt;vxe-column type="seq" width="70"&gt;&lt;/vxe-column&gt;
    &lt;vxe-column field="name" title="Name"&gt;&lt;/vxe-column&gt;
    &lt;vxe-column field="role" title="Role"&gt;&lt;/vxe-column&gt;
    &lt;vxe-column field="sex" title="Sex"&gt;&lt;/vxe-column&gt;
    &lt;vxe-column field="age" title="Age"&gt;&lt;/vxe-column&gt;
    &lt;vxe-column field="address" title="Address"&gt;&lt;/vxe-column&gt;
  &lt;/vxe-table&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'

const tableData = ref([
  { id: 10001, name: 'Test1', role: 'Develop', sex: 'Man', age: 28, address: 'test abc' },
  { id: 10002, name: 'Test2', role: 'Test', sex: 'Women', age: 22, address: 'Guangzhou' },
  { id: 10003, name: 'Test3', role: 'PM', sex: 'Man', age: 32, address: 'Shanghai' },
  { id: 10004, name: 'Test4', role: 'Designer', sex: 'Women', age: 24, address: 'Shanghai' }
])
&lt;/script&gt;</code></pre><p>vxe-table 动态配置式 vxe-grid  的使用</p><pre><code class="html">&lt;template&gt;
  &lt;vxe-grid v-bind="gridOptions"&gt;&lt;/vxe-grid&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { reactive } from 'vue'

const gridOptions = reactive({
    height: 500,
  columns: [
        { type: 'seq', width: 70 },
        { field: 'name', title: 'Name' },
        { field: 'sex', title: 'Sex' },
        { field: 'age', title: 'Age' },
        { field: 'address', title: 'Address', showOverflow: true }
  ],
  data: [
        { id: 10001, name: 'Test1', role: 'Develop', sex: 'Man', age: 28, address: 'test abc' },
        { id: 10002, name: 'Test2', role: 'Test', sex: 'Women', age: 22, address: 'Guangzhou' },
        { id: 10003, name: 'Test3', role: 'PM', sex: 'Man', age: 32, address: 'Shanghai' },
        { id: 10004, name: 'Test4', role: 'Designer', sex: 'Women', age: 24, address: 'Shanghai' }
    ]
})
&lt;/script&gt;</code></pre><h2>ag-grid 来写一个简单使用例子</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047548920" alt="Video_2026-01-17_160507-ezgif" title="Video_2026-01-17_160507-ezgif" loading="lazy"/></p><p>ag-grid 的用，需安装 <code>npm install ag-grid-vue3</code>用于在 vue 中使用</p><pre><code class="html">&lt;template&gt;
   &lt;ag-grid-vue
       :rowData="rowData"
       :columnDefs="colDefs"
       style="height: 500px"
   &gt;
   &lt;/ag-grid-vue&gt;
&lt;/template&gt;

&lt;script setup&gt;
import { ref } from 'vue'
import { AgGridVue } from "ag-grid-vue3"
const rowData = ref([
    { make: "Tesla", model: "Model Y", price: 64950, electric: true },
    { make: "Ford", model: "F-Series", price: 33850, electric: false },
    { make: "Toyota", model: "Corolla", price: 29600, electric: false },
])

const colDefs = ref([
    { field: "make" },
    { field: "model" },
    { field: "price" },
    { field: "electric" }
])
&lt;/script&gt;</code></pre><h2>那么应该怎么选项呢</h2><p>ag-grid <a href="https://link.segmentfault.com/?enc=gW3rT1hmH6rr7gZAoiVmKw%3D%3D.AYPt7HvDNC2GtNuoxtWhvhq0nh6rQmZbq4B%2Fs38gD%2Bo%3D" rel="nofollow" target="_blank">https://www.ag-grid.com</a><br/>vxe-table <a href="https://link.segmentfault.com/?enc=j57QKKJ1S9k0CZqTlvn%2F9w%3D%3D.uKLPTc7EJd3tNoR%2FsB6uWjYxNt%2Ba20BKOGVYdQZEgLw%3D" rel="nofollow" target="_blank">https://vxetable.cn</a></p><ul><li>如何只是基本大数据表格列表，不需要树表格，分组等，那么 ag-grid 社区版够用，免费。</li><li>如果需要大数据列表表格。树表格/同时还要各种分组，打印，导出等复杂功能，那么 vxe-table 是不二选择，开源版免费。</li></ul><p>| 特性 |  <a href="https://link.segmentfault.com/?enc=sxRWnfQa%2Fyk3z6WvG2rH5Q%3D%3D.HZfa%2Fmo76%2BUMVIYi4u3ZvxS1YBOLIYsvKHmK1mWBFfo%3D" rel="nofollow" target="_blank">vxe-table</a>| <a href="b77a9cf600bf366b96ce51c82b9cd7155" target="_blank">ag-grid</a> |<br/>|-|--|--|<br/>|  定位 | （国内项目）vue2/vue3 生态企业级表格解决方案 | （国外项目）原生js企业版表格解决方案 |<br/>|  大数据量加载| 强 | 极强 |<br/>|  复杂功能 | 极强（排序，展开行，树，个性化列，拖拽，合并，分组，分页，表单，工具栏，可编辑，数据校验，无限滚动，渲染器，导入导出打印） | 强（排序，展开行，树，拖拽，合并，分组，分页，可编辑，导入导出打印） |<br/>|  Excel 功能| 单元格选择（单区域，多区域，复制粘贴，查找替换，按键导航，支持集成第三方echarts图表） | 单元格选择（单区域，多区域，复制粘贴，按键导航，图表） |<br/>|  甘特图| 支持，扩展库 <a href="https://link.segmentfault.com/?enc=w%2Bb9QsAEP2jWNxKxk1b1kA%3D%3D.73foj6bG5eImUBc%2FPc%2Fc6aeOlzHuvJc26eM9jVX5Svs%3D" rel="nofollow" target="_blank">vxe-gantt</a>（子任务，拖拽，里程碑，依赖线） | 不支持 |<br/>|  官网文档 | 非常详细，全中文文档，各种示例都有，文档成熟度最高 | 全英文文档，文档示例非常少，文档阅读难度非常高 |<br/>|  上手难度 | 简单，API丰富 | 难，API丰富 |<br/>|  体积| 中等 | 较大 |<br/>|  生态| 任意vue组件都能直接使用 | 由于原生js的，vue组件需再次封装，比较麻烦 |</p><p>2个都是支持秒级渲染万级数据的表格，各有各的优缺点，可以根据不同场景选择。</p><p>总结：</p><ul><li>如果是vue项目，首选 vxe-table</li><li>如果是需要多框架使用，选原生的 ag-grid</li></ul>]]></description></item><item>    <title><![CDATA[2026最新AI模型横评：谁才是你的最强“工作搭子”？ Java中文社群 ]]></title>    <link>https://segmentfault.com/a/1190000047548925</link>    <guid>https://segmentfault.com/a/1190000047548925</guid>    <pubDate>2026-01-17 17:02:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>AI 时代，最痛苦的不是没有工具，而是<strong>工具太多，根本不知道选哪个</strong>！</p><p>一边是 <strong>ChatGPT、Claude</strong> 等国外老牌霸主，一边是 <strong>DeepSeek、Kimi、通义千问</strong> 等国产新贵强势崛起。究竟是“外来的和尚好念经”，还是“国产之光”更懂中国心？</p><p>今天，我们实测了目前市面上最火的 8 款大模型，从<strong>逻辑推理、长文本处理、代码能力、日常交互</strong>等维度，为你送上一份<strong>保姆级选型指南</strong>。</p><hr/><h2>🎬 视频演示</h2><p><a href="https://www.bilibili.com/video/BV1HkrUBVEpn/" target="_blank">https://www.bilibili.com/video/BV1HkrUBVEpn/</a></p><hr/><h2>第一梯队：国际“三巨头”</h2><p>如果你能解决网络门槛问题，这三位依然代表着<strong>目前 AI 智力的“天花板”</strong>。</p><p>&lt;!-- 这是一张图片，ocr 内容为： --&gt;<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548927" alt="" title=""/></p><h3>1. ChatGPT (OpenAI) —— “六边形战士”</h3><p><strong>👑 地位：</strong> 行业标杆，所有模型的模仿对象。</p><ul><li><p><strong>🔥 核心优势：</strong></p><ul><li><strong>综合能力最强：</strong> 无论是写诗、写代码还是逻辑推理，GPT 几乎没有短板。</li><li><strong>生态无敌：</strong> 拥有海量的 GPTs（插件），可以画图、数据分析、联网搜索，一站式搞定。</li><li><strong>语音模式：</strong> 它的实时语音对话流畅度，目前仍是独一档的存在。</li></ul></li><li><p><strong>💔 缺点：</strong></p><ul><li>订阅费用贵（20 美元/月）。</li><li>国内访问门槛高，账号容易被封。</li></ul></li></ul><h3>2. Claude (Anthropic) —— “不仅是文科生，更是程序员”</h3><p><strong>🦄 地位：</strong> 最像“人”的 AI，ChatGPT 最强的竞争对手。</p><ul><li><p><strong>🔥 核心优势：</strong></p><ul><li><strong>拟人化最高：</strong> 写出来的文章不仅逻辑通顺，而且文笔优美，没有“AI 味”，非常适合公文写作、邮件润色。</li><li><strong>Artifacts 功能：</strong> 能够直接在侧边栏预览代码效果（如网页、图表），是前端程序员和数据分析师的最爱。</li><li><strong>超大上下文：</strong> 能够一次性吃透整本书的内容。</li></ul></li><li><p><strong>💔 缺点：</strong></p><ul><li><strong>风控极严：</strong> 稍微聊点敏感话题（甚至只是为了剧情需要）就会拒绝回答。</li><li>免费版限制次数较多。</li></ul></li></ul><h3>3. Gemini (Google) —— “全知全能的数据怪兽”</h3><p><strong>🚀 地位：</strong> Google 生态的亲儿子，拥有百万级上下文处理能力。</p><ul><li><p><strong>🔥 核心优势：</strong></p><ul><li><strong>百万上下文窗口：</strong> Gemini 3 Pro 可以一次性处理极长的视频、音频和文档，这是它的杀手锏。</li><li><strong>Google 全家桶集成：</strong> 直接调用 Google Docs, Gmail, Drive 里的资料，办公效率极高。</li><li><strong>多模态理解：</strong> 扔给它一段视频，它能精准告诉你视频里发生了什么。</li></ul></li><li><p><strong>💔 缺点：</strong></p><ul><li>逻辑推理偶尔会“幻觉”（一本正经胡说八道）。</li><li>产品线改名频繁，用户容易晕。</li></ul></li></ul><hr/><h2>第二梯队：国产“五虎上将”</h2><p>国产模型不仅<strong>免费/便宜</strong>，而且<strong>更懂中文语境</strong>，在某些垂直领域甚至已经超越了 GPT-4。</p><p>&lt;!-- 这是一张图片，ocr 内容为： --&gt;<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548928" alt="" title="" loading="lazy"/></p><h3>1. DeepSeek (深度求索) —— “硬核理工男，国产之光”</h3><p><strong>⚡ 特性：</strong> 开源界的英雄，代码与数学能力的王者。</p><ul><li><p><strong>👍 优点：</strong></p><ul><li><strong>代码/数学能力极强：</strong> 在 Coding 领域，DeepSeek V3/R1 的表现直逼甚至超越 GPT-4，深受程序员喜爱。</li><li><strong>开源精神：</strong> 模型权重公开，不仅 API 极其便宜（几乎是白菜价），还能本地部署。</li><li><strong>深度思考：</strong> R1 版本引入了类似 o1 的深度思考链，解决复杂逻辑问题能力爆表。</li></ul></li><li><p><strong>👎 缺点：</strong></p><ul><li>由于太火，服务器偶尔会崩。</li><li>文案写作略显生硬，不如文科类模型细腻。</li></ul></li></ul><h3>2. Kimi (月之暗面) —— “长文本阅读神器”</h3><p><strong>📚 特性：</strong> 最早打响“长文本”招牌的国产模型。</p><ul><li><p><strong>👍 优点：</strong></p><ul><li><strong>吃透研报/论文：</strong> 扔给它 50 份 PDF，它能迅速帮你总结核心观点，是金融从业者和学生党的救星。</li><li><strong>联网搜索精准：</strong> 它的搜索引用链接非常规范，减少了胡编乱造的概率。</li><li><strong>界面清爽：</strong> UI 设计简洁，不仅好用，而且好看。</li></ul></li><li><p><strong>👎 缺点：</strong></p><ul><li>生成长文时，创意度有时稍显不足。</li></ul></li></ul><h3>3. 通义千问 (Qwen - 阿里巴巴) —— “全能实干家”</h3><p><strong>🛠️ 特性：</strong> 阿里技术背书，开源生态极其丰富，并且最新的千问 APP 还<strong>可以帮你自动点餐</strong>。</p><ul><li><p><strong>👍 优点：</strong></p><ul><li><strong>图片理解能力强：</strong> 视觉识别（Vision）能力在国产模型中数一数二，能看懂复杂的图表和菜单。</li><li><strong>文档处理：</strong> 解析 Word、Excel 的能力非常稳定。</li><li><strong>不仅是聊天：</strong> 背后有通义听悟（做会议纪要）等一系列应用支持。</li></ul></li><li><p><strong>👎 缺点：</strong></p><ul><li>有时候回答过于“官方”，缺乏一点个性。</li></ul></li></ul><h3>4. 智谱清言 (ChatGLM) —— “数据分析大师”</h3><p><strong>📊 特性：</strong> 源自清华系，工具调用能力强。</p><ul><li><p><strong>👍 优点：</strong></p><ul><li><strong>数据分析：</strong> 内置的代码解释器非常强大，上传 Excel 表格，它能直接帮你画出可视化的图表（柱状图、热力图等）。</li><li><strong>GLM 能力均衡：</strong> 综合素质很高，既能画图，又能联网，而且<strong>最新的 GLM 4.7 代码能力也不错</strong>。</li></ul></li><li><p><strong>👎 缺点：</strong></p><ul><li>移动端 APP 的体验偶尔有卡顿。</li></ul></li></ul><h3>5. 豆包 (字节跳动) —— “最强语音搭子”</h3><p><strong>🎧 特性：</strong> 日活最高的国产 AI，主打 C 端日常陪伴。</p><ul><li><p><strong>👍 优点：</strong></p><ul><li><strong>语音交互最自然：</strong> 声音极其逼真，有情绪起伏，不像机器人在念稿，非常适合练口语或闲聊。</li><li><strong>功能丰富：</strong> 内置了各种“智能体”（如英语老师、小说写手），玩法很多。</li><li><strong>响应速度快：</strong> 字节的技术优化，让它在手机上用起来非常丝滑。</li></ul></li><li><p><strong>👎 缺点：</strong></p><ul><li>处理复杂逻辑和硬核代码任务时，相比 DeepSeek 稍弱。</li></ul></li></ul><hr/><h2>⚡ 总结：到底该选哪一个？</h2><p>为了帮你省时间，我直接给出<strong>“抄作业”建议</strong>：</p><table><thead><tr><th align="left">你的需求</th><th align="left"><strong>首选推荐 (国内)</strong></th><th align="left"><strong>首选推荐 (国外)</strong></th><th align="left">理由</th></tr></thead><tbody><tr><td align="left"><strong>写代码 / 搞数学</strong></td><td align="left"><strong>DeepSeek</strong></td><td align="left">Claude</td><td align="left">逻辑最强，不容易写出 Bug。</td></tr><tr><td align="left"><strong>读论文 / 看研报</strong></td><td align="left"><strong>Kimi</strong></td><td align="left">Gemini</td><td align="left">长文本吞吐量大，总结精准。</td></tr><tr><td align="left"><strong>写文章 / 润色邮件</strong></td><td align="left"><strong>通义千问 / Kimi</strong></td><td align="left">ChatGPT/Gemini</td><td align="left">文笔自然，读起来不尴尬。</td></tr><tr><td align="left"><strong>做图表 / 数据分析</strong></td><td align="left"><strong>智谱清言</strong></td><td align="left">ChatGPT/Gemini</td><td align="left">直接出图，省去 Excel 操作。</td></tr><tr><td align="left"><strong>练口语 / 闲聊解闷</strong></td><td align="left"><strong>豆包</strong></td><td align="left">ChatGPT</td><td align="left">声音好听，反应快，情商高。</td></tr><tr><td align="left"><strong>综合办公 / 啥都干</strong></td><td align="left"><strong>通义千问 / DeepSeek</strong></td><td align="left">ChatGPT/Gemini</td><td align="left">均衡发展，也是最稳的选择。</td></tr></tbody></table><p>&lt;!-- 这是一张图片，ocr 内容为： --&gt;<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548929" alt="" title="" loading="lazy"/>  <br/>AI 模型更新速度极快（按周计算）。如果是<strong>工作重度使用</strong>，建议<strong>“DeepSeek (逻辑) + Kimi (阅读)”</strong>组合使用，完全免费且效率翻倍；如果有条件，<strong>ChatGPT/Gemini</strong> 依然是探索 AI 边界的最佳窗口。</p><p>拒绝选择困难症，现在就去打开一个试试吧！</p><blockquote>本文已收录到我的技术小站 <a href="https://link.segmentfault.com/?enc=WXpu1W17D2hAdkvQSUQ5hw%3D%3D.JFeKkgHXNh6iMyo7W25qLz2%2B0mJzlFQl%2FhTikQ9lFvI%3D" rel="nofollow" target="_blank">www.javacn.site</a>，网站包含的内容有：<strong>N8N/Coze/Dify/LangChain/SpringAI/SpringAIAlibaba/LangChain4j/AI实战项目/AI常见面试题</strong>等技术分享，欢迎各位大佬光临指导~</blockquote>]]></description></item><item>    <title><![CDATA[三分钟与三百小时：一个IT人的广州下午 ITIL先锋论坛 ]]></title>    <link>https://segmentfault.com/a/1190000047548942</link>    <guid>https://segmentfault.com/a/1190000047548942</guid>    <pubDate>2026-01-17 17:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>12月13日，广州的冬日并不冷。</p><p>阳光斜照在天河区美豪丽致酒店的大厅里，吴军站在签到处旁调试话筒，长河老师翻着讲稿，丁振兴正和一位老友低声交谈。我坐在第三排靠过道的位置，电脑还没打开，心里却已经有点焦躁——昨天凌晨三点才处理完一次系统告警，今早又收到领导邮件：“今年效率提升目标没完成，下周要交改进方案。”</p><p>我低头看了眼手表：13:40。会议准时开始。</p><p><img width="730" height="424" referrerpolicy="no-referrer" src="/img/bVdnFOz" alt="" title=""/></p><p>第一个上台的是长河老师。他没有寒暄，直接问：“你到底懂不懂AI？”然后举起手机做了个匿名投票。屏幕上缓缓浮现数据：</p><p>使用AI超过100小时：约三分之一  <br/>500小时以上：三四人  <br/>2000小时？只有他自己。</p><p>我的心沉了一下。我用AI写周报、查命令、润色邮件，加起来可能刚过100小时。我以为这已经够了。可当他在台上说“AI不是搜索引擎，而是思维方式的升级”时，我才意识到，我和真正的“懂”，差的不是工具，是投入。</p><p>他现场演示生成讲义，五分钟后PPT完整呈现；八十个杂乱事件单，瞬间变成结构清晰的分析报告。台下有人小声说：“这也太快了……”</p><p>那一刻，我突然想起昨晚那场故障。如果我能有一个智能体，自动归类告警、提取共性、生成处置建议，是不是就不用熬到凌晨三点？</p><p>第二个登台的是丁振兴。他的PPT第一页写着：“运维界的贾维斯来了。”我不由得坐直了身子。</p><p>他展示的那个系统，能自动发现资产、分析告警、甚至自己写脚本。最让我愣住的是“AI编写脚本”那一幕——输入一句“清理日志并压缩归档”，几秒后一段Python代码就出来了，还能直接运行。</p><p>我想起自己写了十年Shell脚本的日子。那些深夜调试的循环、正则表达式、权限判断……如今被一句话替代。我不是伤感技术被淘汰，而是震惊于变化来得如此安静，却又如此彻底。</p><p>中场休息时，我走到罗小军老师的展板前。上面列着一串名字：“爆款公众号大师”“直播话术专家”“危机公关大师”。我以为这是营销噱头，直到他放出那个案例：一家公司引入后，方案撰写从3小时缩短到3分钟。</p><p>60倍。  <br/>三个数字，像一记重锤砸在我心上。</p><p>我掏出手机翻自己上周写的方案——整整花了三个半小时。如果那时候我有这样一个智能体，我能多陪孩子吃顿晚饭，或者早点睡一觉。</p><p>王晨光老师的演讲像一场冷静的诊断。他说企业最大的问题是“数据孤岛”：系统不通、接口难接、报表要等好几天。他提出用集成中台打通一切。我频频点头——这不就是我们公司现在的情况吗？CRM、OA、监控平台各自为政，每次取数都要协调三天。</p><p>“未来的竞争，不是系统的竞争，是集成协同的智能生态之战。”他说。</p><p>我记下了这句话。</p><p>圆桌讨论开始后，有人举手提问：“AI会不会淘汰IT人？”  <br/>长河笑了笑：“不会淘汰人，但会淘汰不会用AI的人。”  <br/>丁振兴补充：“初级顾问风险最高，但新角色也在出现——AI训练师、架构师。”  <br/>罗小军说得更直白：“跑不过老虎没关系，只要比别人快就行。”</p><p>笑声响起，但我笑不出来。我知道他们在说谁——是我们这些还在靠经验吃饭的人。</p><p>最后的实操环节，全场带电脑上线。长河老师带我们做“合同审核智能体”。上传PDF、切片、建知识库、设置回复逻辑……全程零代码。当我看到系统准确识别出一份合同里的违约条款时，手指微微发抖。</p><p>下一个演练是“舆情洞察智能体”。他输入“智能汽车”，三分钟后，邮箱收到了五条带标题的行业新闻摘要。</p><p>我盯着屏幕，忽然笑了。  <br/>这不就是我每天早上做的第一件事吗？  <br/>花一个小时，刷网站、记要点、整理成简报。  </p><p>晚宴设在珠江边的一家私房菜馆。讲师们喝着茶聊技术，有人谈起2025年会被称作“AI智能体元年”。我坐在角落，没怎么说话。</p><p>回程地铁上，我打开笔记本，新建了一个文件夹，命名为“我的第一个智能体”。  <br/>然后写下第一步：学习提示词工程。  <br/>第二步：搭建企业知识库。  <br/>第三步：尝试自动化日报生成。</p><p>我不知道这条路能走多远。  <br/>但我知道，如果我不开始，总有一天，我会被那个只用三分钟就能做完我三天工作的人，远远甩在身后。</p><p>那天广州的阳光很好。  <br/>而我，终于醒了。<br/>而现在，它只需要三分钟。</p>]]></description></item><item>    <title><![CDATA[怎么在VPS上安装和运行ChatGPT landonVM ]]></title>    <link>https://segmentfault.com/a/1190000047548884</link>    <guid>https://segmentfault.com/a/1190000047548884</guid>    <pubDate>2026-01-17 16:02:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h3>一.前言</h3><p>ChatGPT 是由 OpenAI 倾力打造的尖端生成式人工智能模型，它以革命性的方式重新定义了企业和个人与 AI 的交互范式。<br/>它的应用场景极其广泛且功能强大 , 涵盖了从：</p><pre><code>自动化客户支持和优化内部流程
开发高度智能的对话式聊天机器人
到大幅增强创意内容生成和代码辅助等多个领域。</code></pre><p>将其部署在虚拟专用服务器 上是最有效的方法之一。 提供了必要的资源独享、环境定制和性能保障。我们将深入探讨如何安装和运行 的具体步骤，分析这种部署方式的独特优势，并分享实际应用案例，助您充分释放 它 的巨大潜力。</p><h3>二.为什么服务器是托管 ChatGPT 的理想选择？</h3><p>将 计算密集型 AI 模型部署在虚拟专用服务器上，是实现性能、灵活性和成本效率完美平衡的最佳策略。</p><ol><li>卓越的性能与资源独享<br/> 专用高性能资源：服务器为解决方案提供专用的 CPU、RAM 和存储资源。<br/> 价值： 这确保 可以不间断且高效地处理复杂的自然语言处理（NLP）和计算任务，避免了共享环境中的性能瓶颈。</li><li>高度可扩展性与弹性<br/> 灵活的资源调整：您可以根据  应用程序的实际需求和用户量增长，轻松、快速地扩展内存、处理能力和存储空间。<br/> 价值： 确保您的 AI 应用始终能弹性应对流量波动和功能迭代。</li><li>增强的安全与环境隔离<br/> 隔离式环境： 服务器托管提供了隔离的环境，有效防止了来自其他用户的干扰和安全风险。<br/> 高级保护机制： 它通常配备定制防火墙、DDoS 防护等高级保护机制，确保您部署的  应用和相关数据的安全。</li><li>经济实惠的部署成本<br/> 成本效益高： 相比于成本高昂的专用物理服务器，托管方案更加经济实惠。<br/> 价值： 它在提供强大性能和高可靠性的同时，大大降低了企业和个人部署 AI 应用的初始投入和运维成本。</li><li><p>全球可访问性与低延迟<br/> 全球覆盖能力： 部署在策略性位置的 服务器使您的  服务能够在全球范围内快速访问。<br/> 价值： 有效降低网络延迟，从而确保全球用户都能获得流畅、即时的对话体验。</p><h3>三.在 VPS 上运行 ChatGPT 的前提条件清单</h3><p>在开始部署之前，确保您的虚拟专用服务器满足以下核心要求，以保证  应用的稳定性和性能。<br/>1、充足的 VPS 资源：最低建议配置： 至少配备 4 个 CPU 核心、8GB 内存 (RAM) 和 40GB 存储空间。 确保模型在处理复杂请求时能够流畅运行，避免因资源不足导致的延迟或崩溃。<br/>2、首选操作系统：推荐使用 Linux 发行版，尤其是 Ubuntu 或 CentOS。Linux 系统能为 AI 应用提供更好的性能优化和兼容性，是部署服务器环境的行业标准。<br/>3、Python 编程环境：需安装 Python 3.8 或更高版本。Python 是运行 OpenAI 模型的核心环境。确保版本符合要求，以避免兼容性问题。        <br/>4、OpenAI API 访问权限：您必须拥有从 OpenAI 官方获取的有效 API 密钥。这是集成和调用 ChatGPT 模型功能的唯一凭证，是应用运行的关键要素。</p><h3>四.安装ChatGPT指南</h3></li><li>设置您的服务器<br/>首先，准备一台高性能服务器，确保套餐满足硬件要求。准备就绪后，使用 SSH 登录：</li></ol><p><code>ssh root@your-vps-ip-address  </code></p><ol start="2"><li><p>更新和安装依赖项<br/>环境更新，并安装必要的软件包：</p><pre><code>sudo apt update &amp;&amp; sudo apt upgrade  
sudo apt install python3 python3-pip virtualenv git </code></pre></li><li><p>创建虚拟环境<br/>虚拟环境将您的 应用程序与系统的全局 Python 环境隔离：</p><pre><code>virtualenv chatgpt_env  
source chatgpt_env/bin/activate </code></pre></li><li>安装 OpenAI Python SDK<br/>使用 pip 安装 OpenAI SDK，这是与  模型交互所必需的：<br/>`pip install openai  <br/>`</li><li><p>设置 API 访问权限<br/>创建一个 Python 脚本，并在脚本中包含您的 OpenAI API 密钥。例如：</p><pre><code>import openai  

openai.api_key = "your-api-key"  

response = openai.ChatCompletion.create(  
  model="gpt-4",  
  messages=[{"role": "user", "content": "Hello, ChatGPT!"}]  
)  

print(response["choices"][0]["message"]["content"])</code></pre></li></ol><p>将此文件另存为chatgpt_test.py并运行：<br/><code>python3 chatgpt_test.py </code></p><h3>五.生产环境的优化部署策略</h3><p>当您准备将 应用投入生产环境时，标准的部署流程需要结合强大的 Web 框架和高性能的 Web 服务器，以确保应用具备最佳的性能和可靠性。</p><ol><li>构建应用接口 (API/Interface)<br/> 选择 Web 框架： 建议使用 Flask 或 Django 等成熟的 Python Web 框架。<br/> 目的： 利用这些框架的强大功能，为您的  应用构建稳定且易于维护的 API 接口（供其他服务调用）或用户交互界面。</li><li><p>启用高性能服务 (High-Performance Serving)<br/> 使用 Web 服务器： 为了获得更好的性能和全球访问性，请务必使用 Nginx 或 Apache 等高性能 Web 服务器在您的服务器上运行该应用。<br/> 工作机制： 这些 Web 服务器作为反向代理，不仅能高效地处理并发请求、静态文件，还能优化连接、加速内容传输，确保您的 应用以最佳状态面向终端用户。<br/>将 Flask/Django 框架（处理业务逻辑）与 Nginx/Apache 服务器（处理请求分发和性能优化）结合，是生产环境中确保应用高可用性、高并发处理能力和优秀用户体验的最佳实践。</p><h3>六.ChatGPT 在 VPS 上的常见案例</h3><p>将它 部署在私有环境中，能够释放其在多个业务和应用领域的巨大潜力<br/>1、客户支持自动化：部署为全天候、即时响应的对话式聊天机器人，大幅降低人工成本，提升用户满意度。<br/>2、创意内容生成：轻松快速地生成创意文章、社交媒体帖子、博客内容或营销材料，实现内容规模化生产。<br/>3、代码辅助与开发：充当强大的代码助手，用于调试、优化现有代码、生成代码片段，加速开发流程。<br/>多语言处理与翻译：实现多语言即时翻译或复杂的内容本地化功能，助力全球化业务<br/>4、教育和个性化辅导：驱动应用程序，为学生提供个性化的学习体验、答疑解惑或定制化的辅导服务。</p><h3>七.服务器上 ChatGPT 的优化技巧</h3><p>为了确保您部署的  应用能够以最佳性能运行，并最大限度地节省成本，请遵循以下优化策略：</p></li><li>持续监控资源使用情况<br/> 操作： 定期使用 htop 或 top 等 Linux 工具监控 CPU 和 RAM 的实时使用情况。<br/> 目的： 确保资源不会成为性能瓶颈。一旦持续高负载，应及时升级您的服务器。</li><li>实施缓存机制<br/> 操作： 为重复查询或常见响应启用缓存机制（例如使用 Redis 或 Memcached）。<br/> 目的： 有效减少对 OpenAI API 的冗余请求，显著提高应用的响应速度，并降低运行成本。</li><li>增强 服务器的安全防护<br/> 操作： 部署 SSL 证书保护数据传输；配置防火墙限制未经授权的访问；执行定期数据备份。<br/> 目的： 全面保护您的敏感数据和  应用程序，防止服务中断或数据丢失。</li><li><p>优化 API 调用参数<br/> 操作： 在调用 OpenAI API 时，合理使用 max_tokens 参数。<br/> 目的： 限制模型的最大响应长度，确保回复简洁有效，同时能有效控制和降低 API 调用成本。</p><h3>八.总结</h3><p>在 服务器上托管 ChatGPT，能为您的 AI 应用赋予无与伦比的控制力、卓越的性能和极致的灵活性。无论您是致力于构建智能聊天机器人、自动化复杂工作流程，还是全面提升用户体验，确保您的应用 部署稳健、可靠、高效运行的基石。</p></li></ol>]]></description></item><item>    <title><![CDATA[印度股票数据API对接实战（实时行情与IPO功能全解析） CryptoRzz ]]></title>    <link>https://segmentfault.com/a/1190000047548901</link>    <guid>https://segmentfault.com/a/1190000047548901</guid>    <pubDate>2026-01-17 16:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>随着印度经济的飞速发展，印度股市（NSE 印度国家证券交易所和 BSE 孟买证券交易所）已成为全球投资者不容忽视的资产配置高地。对于开发者而言，如何稳定、高效地接入印度股票数据？</p><p>本文将基于 <strong>StockTV API</strong>，带你实现印度股票（<strong>countryId=14</strong>）的深度对接，重点突出<strong>秒级实时性</strong>与<strong>IPO新股功能</strong>。</p><h2>一、 对接核心配置</h2><p>在开始开发前，请明确以下基础参数：</p><ul><li><strong>API 基础路径</strong>：<code>https://api.stocktv.top</code></li><li><strong>国家 ID (countryId)</strong>：<code>14</code>（印度市场专属代码，同时覆盖 NSE 与 BSE）</li><li><strong>接入协议</strong>：支持标准的 HTTP RESTful 接口（用于列表和历史数据）以及 WebSocket (WS) 协议（用于高频实时数据推送）。</li><li><strong>身份认证</strong>：在 API 请求参数中携带您的 <code>key</code> 即可。</li></ul><h2>二、 核心功能一：极致的实时行情体验</h2><p>在金融应用中，延迟是交易的天敌。针对印度市场，该接口提供了多维度的实时数据支持。</p><h3>1. 获取全市场实时列表</h3><p>通过 <code>/stock/stocks</code> 接口并传入 <code>countryId=14</code>，你可以实时获取印度市场所有活跃个股的最新成交价、涨跌幅及成交量。</p><ul><li><strong>实时字段</strong>：</li><li><code>last</code>: 最新成交价（秒级刷新）。</li><li><code>chgPct</code>: 涨跌幅百分比。</li><li><code>volume</code>: 当日累计成交量。</li><li><strong>应用场景</strong>：自选股列表、实时行情板、涨跌幅排行榜。</li></ul><h3>2. 大盘指数实时监控</h3><p>监控印度市场离不开 <strong>Nifty 50</strong> 和 <strong>SENSEX</strong>。</p><ul><li><strong>接口地址</strong>：<code>/stock/indices?countryId=14</code></li><li><strong>关键点</strong>：提供 <code>isOpen</code> 字段，实时反馈印度市场是否处于交易时段。</li></ul><h3>3. WebSocket 毫秒级推送</h3><p>如果您正在开发交易终端或高频监控系统，建议使用 WebSocket 接入。通过订阅印度股票频道，一旦价格产生波动，服务器将主动推送最新报价，无需客户端轮询。</p><h2>三、 核心功能二：IPO 新股日历功能</h2><p>印度 IPO 市场非常活跃（如近年来备受关注的 Zomato、Paytm 等）。该 API 提供了完善的 IPO 数据链路。</p><h3>1. 追踪待上市新股 (<code>type=1</code>)</h3><p>通过 <code>/stock/getIpo?countryId=14&amp;type=1</code>，你可以提前获取即将上市的公司信息。</p><ul><li><strong>核心数据</strong>：</li><li><code>ipoListing</code>: 预计上市时间戳。</li><li><code>ipoPrice</code>: 发行价格。</li><li><code>company</code>: 公司名称及所属行业。</li></ul><h3>2. 回测已上市表现 (<code>type=2</code>)</h3><p>对于分析新股首日表现和后续走势，已上市 IPO 列表提供了关键的历史参考。</p><h3>3. 应用价值</h3><p>开发者可以利用此功能构建“打新提醒”通知系统，通过 APP 推送或邮件告知用户最新的印度 IPO 动态，增强用户粘性。</p><h2>四、 快速集成示例 (Python)</h2><p>以下是一个简单的代码片段，展示如何获取印度市场的实时股票数据：</p><pre><code class="python">import requests

def get_india_live_data():
    api_url = "https://api.stocktv.top/stock/stocks"
    params = {
        "countryId": 14,  # 印度
        "key": "YOUR_API_KEY",
        "pageSize": 10
    }
    response = requests.get(api_url, params=params)
    if response.status_code == 200:
        stocks = response.json().get('data', {}).get('records', [])
        for stock in stocks:
            print(f"代码: {stock['symbol']}, 最新价: {stock['last']}, 涨跌幅: {stock['chgPct']}%")

get_india_live_data()
</code></pre><h2>五、 为什么选择 StockTV 对接印度数据？</h2><ol><li><strong>统一架构</strong>：仅需变更 <code>countryId</code>，即可在同一套逻辑下切换至美国、日本、越南等全球多国市场。</li><li><strong>深度基本面</strong>：除了价格，通过 <code>/stock/companies</code> 接口还可获取印度上市公司的详细描述、所属板块及员工人数。</li><li><strong>技术支持</strong>：提供全程对接辅助，确保从 HTTP 到 WebSocket 的平滑过渡。</li></ol><hr/><p><strong>结语</strong>：印度股市的数字化投资时代已经到来。利用专业的 API 接口，您可以仅用几行代码，就让您的应用具备与华尔街终端同步的印度市场洞察力。立即开始集成，抢占南亚市场先机！</p>]]></description></item><item>    <title><![CDATA[【技术分享】2026抖音聚合采集软件，一键批量爬取搜索视频和评论 马哥python说 ]]></title>    <link>https://segmentfault.com/a/1190000047548516</link>    <guid>https://segmentfault.com/a/1190000047548516</guid>    <pubDate>2026-01-17 14:05:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <blockquote>本工具仅限学术交流使用，严格遵循相关法律法规，符合平台内容的合法及合规性，禁止用于任何商业用途！</blockquote><h2>一、背景分析与结果展示</h2><h3>1.1 开发背景</h3><p>抖音是国内极具影响力的短视频社交平台，靠着强互动性和庞大的达人创作者群体，已然成为热点事件发酵、优质内容传播的领域。为了满足大家不同的数据采集需求，我用python技术开发出这个“<strong>爬抖音聚合软件</strong>”。这款软件把评论采集、达人主页采集、链接转换这三个核心功能都包含了，提供一站式搞定的抖音数据采集方案。</p><p>功能主体由Python语言开发实现，分工如下：</p><pre><code class="python">tkinter：GUI软件界面
requests：爬虫请求
json：解析响应数据
time：间隔等待，防止反爬
pandas：保存csv结果
logging：日志记录</code></pre><h3>1.2 适用人群与场景</h3><p>软件适用于：</p><ul><li>获客截流：从相关行业、品牌热门作品下的评论区精准采集目标用户；</li><li>数据分析：采集抖音话题数据，用于社会舆情挖掘、网络传播研究等；</li><li>内容创作：分析优质博主的内容风格、热门话题，为自身创作提供参考；</li><li>抖音运营：不同格式链接/uid转换，需要跨工具协作的从业者。</li></ul><h3>1.3 结果展示</h3><p><strong>【功能1】采集评论</strong></p><p>采集评论界面：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548518" alt="功能1：采集评论" title="功能1：采集评论"/></p><p>采集到的作品数据：（共13个字段，含：关键词,页码,视频标题,视频链接,作者昵称,作者uid,作者链接,作者粉丝数,发布时间,点赞数,评论数,收藏数,转发数）<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548519" alt="搜索作品.csv" title="搜索作品.csv" loading="lazy"/></p><p>采集到的评论数据：（共11个字段，含：目标链接,页码,评论者昵称,评论者id,评论者uid,评论者主页链接,评论时间,评论IP属地,评论点赞数,评论级别,评论内容）<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548520" alt="评论.csv" title="评论.csv" loading="lazy"/></p><p><strong>【功能2】根据主页链接采集作品</strong></p><p>采集主页作品界面：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548521" alt="功能2：采集主页作品" title="功能2：采集主页作品" loading="lazy"/></p><p>采集主页作品结果：（含17个字段，含：页码,作者昵称,uid,sec_uid,作者链接,作者粉丝数,视频标题,视频标签,视频链接,发布时间,视频时长,是否置顶,点赞数,评论数,收藏数,推荐数,转发数）<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548522" alt="主页作品数据.csv" title="主页作品数据.csv" loading="lazy"/></p><p>采集到的主页视频文件：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548523" alt="自动下载的视频文件" title="自动下载的视频文件" loading="lazy"/></p><p><strong>【功能3】链接与uid转换</strong></p><p>转换功能1：主页链接转抖音号<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548524" alt="转换功能1：主页链接转抖音号" title="转换功能1：主页链接转抖音号" loading="lazy"/></p><p>转换功能2：抖音号转主页链接（含uid）<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548525" alt="转换功能2：抖音号转主页链接（uid）" title="转换功能2：抖音号转主页链接（uid）" loading="lazy"/></p><p>转换功能3：app端作品链接转pc端作品链接<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548526" alt="转换功能3：app端作品链接转pc端作品链接" title="转换功能3：app端作品链接转pc端作品链接" loading="lazy"/></p><h3>1.4 软件说明</h3><p>几点说明，请详读：</p><ol><li>Windows系统、Mac系统均可直接运行，无需配置编程环境</li><li>软件含三个核心功能：①根据关键词/作品链接采集评论；②根据主页链接采集作品；③uid转换</li><li>软件通过接口协议采集，并非通过模拟浏览器等RPA类，稳定性较高</li><li>软件运行完成后，会在当前文件夹（即，软件所在文件夹）生成csv结果文件</li><li>采集过程中，每采集一页，存一次csv。并非采完最后一次性保存！防止因异常中断导致丢失前面的数据（每页请求间隔1~2s）</li><li>采集过程中，有log文件详细记录运行过程，方便回溯</li></ol><h2>二、主要技术</h2><h3>2.1 模块分工</h3><p>软件全部模块采用python语言开发，主要分工如下：</p><pre><code class="python">tkinter：GUI软件界面
requests：发送请求
json：解析返回的响应数据
pandas：保存csv数据结果
logging：运行过程中日志记录</code></pre><p>出于版权考虑，暂不公开源码，仅向用户提供软件使用。</p><h3>2.2 部分代码</h3><p>部分代码实现： </p><p>发送请求并解析数据：</p><pre><code class="python"># 发送请求
r = requests.get(url, headers=h1, params=params)
# 解析数据
json_data = r.json()</code></pre><p>解析响应数据，以“评论内容”字段为例：</p><pre><code class="python">for comment in comment_list:
    # 评论内容
    text = comment['text']
    text_list.append(text)</code></pre><p>保存结果数据到csv文件：</p><pre><code class="python"># 保存数据到DF
df = pd.DataFrame(
    {
        '目标链接': 'https://www.douyin.com/video/' + str(video_id),
        '页码': page,
        '评论者昵称': user_name_list,
        '评论者id': user_unique_id_list,
        '评论者uid': uid_list,
        '评论者主页链接': user_url_list,
        '评论时间': create_time_list,
        '评论IP属地': ip_list,
        '评论点赞数': like_count_list,
        '评论级别': cmt_level_list,
        '评论内容': text_list,
    }
)
# 保存到csv
if os.path.exists(self.result_file2):  # 如果文件存在，不再设置表头
    header = False
else:  # 否则，设置csv文件表头
    header = True
df.to_csv(self.result_file2, mode='a+', index=False, header=header, encoding='utf_8_sig')
self.tk_show('视频[{}]第{}页评论已保存: {}'.format(video_id, page, self.result_file2))</code></pre><p>底部版权声明：</p><pre><code class="python"># 版权信息
copyright = tk.Label(root, text='@马哥python说 All rights reserved.', font=('仿宋', 10), fg='grey')
copyright.place(x=290, y=625)</code></pre><p>日志记录模块：</p><pre><code class="python">def get_logger(self):
    self.logger = logging.getLogger(__name__)
    # 日志格式
    formatter = '[%(asctime)s-%(filename)s][%(funcName)s-%(lineno)d]--%(message)s'
    # 日志级别
    self.logger.setLevel(logging.DEBUG)
    # 控制台日志
    sh = logging.StreamHandler()
    log_formatter = logging.Formatter(formatter, datefmt='%Y-%m-%d %H:%M:%S')
    # info日志文件名
    info_file_name = time.strftime("%Y-%m-%d") + '.log'
    # 将其保存到特定目录
    case_dir = r'./logs/'
    info_handler = TimedRotatingFileHandler(filename=case_dir + info_file_name,
                                        when='MIDNIGHT',
                                        interval=1,
                                        backupCount=7,
                                        encoding='utf-8')</code></pre><h2>三、功能与使用</h2><h3>3.1 填写cookie</h3><p>开始采集前，先把自己的cookie值填入cookie.txt文件。</p><p>cookie获取说明：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548527" alt="cookie获取方法" title="cookie获取方法" loading="lazy"/></p><p>然后把复制的cookie值填写到当前文件夹的cookie.txt文件中。</p><h3>3.2 软件登录</h3><p>用户登录界面：需要登录。</p><h3>3.3 启动采集</h3><p>1）登录成功之后，选择需要的功能模块（搜索帖子/博主帖子/评论）；</p><p>2）设置相关参数（如关键词、时间范围、博主链接等）；</p><p>3）点击「开始执行」，等待采集完成（可实时查看采集进度）；</p><p>4）采集完成后，在默认的当前文件夹中查看csv数据文件或视频下载等。</p><h3>3.4 演示视频</h3><p>软件使用的完整过程演示：原文有。</p><h2>END、原创声明</h2><p>本工具为作者原创开发，仅限于学术交流使用，严格遵循相关法律法规，符合平台内容合法合规性，禁止用于任何商业用途。</p><p>本软件工具仅限于学术交流使用，严格遵循相关法律法规，符合平台内容合法合规性，禁止用于任何商业用途！</p>]]></description></item><item>    <title><![CDATA[【技术分享】weibo_one_spider：用python开发的一站式微博数据聚合采集软件 马哥天]]></title>    <link>https://segmentfault.com/a/1190000047548647</link>    <guid>https://segmentfault.com/a/1190000047548647</guid>    <pubDate>2026-01-17 14:05:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h4>weibo_one_spider：一站式微博数据聚合采集软件</h4><p>大家好，我是专注于数据挖掘领域的开发者。今天很高兴向大家介绍一款我近期独立开发并完成整合的全新工具——<strong>微博聚合采集软件</strong>。</p><p>这款软件的诞生，源于对用户需求的深度洞察。在此之前，我曾分别开发过针对关键词搜索、博主主页以及评论区的三款独立爬虫工具。虽然它们性能稳定，但不少用户反馈在实际操作中，需要同时监控帖子和评论时，频繁切换软件非常影响效率。</p><p>为了解决这一痛点，我将这三款软件的核心功能进行了深度融合，开发出这款<strong>“爬微博聚合软件”</strong>。</p><h4>一、软件特性与技术架构</h4><h5>1. 软件亮点</h5><ul><li><strong>多系统支持</strong>：支持 Windows 和 Mac 系统，无需配置复杂的编程环境，下载即用。</li><li><strong>稳定高效</strong>：采用接口协议采集，非模拟浏览器操作，稳定性高。</li><li><strong>数据安全</strong>：每爬取一页数据，立即保存一次到csv文件。这意味着即使程序意外中断，也不会丢失之前已经爬取的数据。</li><li><strong>智能防封</strong>：每页请求间隔 1～2 秒，模拟人类操作习惯。</li><li><strong>全程留痕</strong>：运行过程中生成详细的 log 日志文件，方便用户回溯排查问题。</li></ul><h5>2. 技术实现</h5><p>本软件完全使用 Python 语言独立开发，各模块分工明确：</p><table><thead><tr><th align="left">模块</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left"><code>tkinter</code></td><td align="left">构建 GUI 图形用户界面</td></tr><tr><td align="left"><code>requests</code></td><td align="left">负责发送网络爬虫请求</td></tr><tr><td align="left"><code>json</code></td><td align="left">解析服务器返回的响应数据</td></tr><tr><td align="left"><code>pandas</code></td><td align="left">处理并保存为 CSV 数据结果</td></tr><tr><td align="left"><code>logging</code></td><td align="left">记录运行过程中的日志</td></tr></tbody></table><p><strong>部分核心代码展示：</strong></p><p><strong>发送请求与数据解析：</strong></p><pre><code class="python"># 发送请求
r = requests.get(url, headers=h1, params=params)
# 解析数据
json_data = r.json()</code></pre><p>解析评论内容字段示例：</p><pre><code class="python">for data in json_data['data']:
    # 评论内容
    text = data['text_raw']
    text_list.append(text)</code></pre><p>数据保存至 CSV：</p><pre><code class="python"># 保存数据
df = pd.DataFrame({
    '微博链接': weibo_url,
    '微博id': weibo_id,
    '页码': page,
    '评论者昵称': screen_name_list,
    '评论者粉丝数': followers_count_list,
    '评论者关注数': friends_count_list,
    '评论者主页链接': user_home_url_list,
    '评论者性别': gender_list,
    '评论者签名': desc_list,
    '评论时间': create_time_list,
    '点赞数': like_counts_list,
    '评论内容IP属地': source_list,
    '评论级别': comment_level_list,
    '评论内容': text_list,
})
# 保存csv文件
df.to_csv(self.result_file, mode='a+', index=False, header=header, encoding='utf_8_sig')
self.tk_show('结果保存成功:{}'.format(self.result_file))</code></pre><p>日志记录模块配置：</p><pre><code class="python">def get_logger(self):
    self.logger = logging.getLogger(__name__)
    # 日志格式
    formatter = '[%(asctime)s-%(filename)s][%(funcName)s-%(lineno)d]--%(message)s'
    # 日志级别
    self.logger.setLevel(logging.DEBUG)
    # 控制台日志
    sh = logging.StreamHandler()
    log_formatter = logging.Formatter(formatter, datefmt='%Y-%m-%d %H:%M:%S')
    # info日志文件名
    info_file_name = time.strftime("%Y-%m-%d") + '.log'
    # 将其保存到特定目录
    case_dir = r'./logs/'
    info_handler = TimedRotatingFileHandler(filename=case_dir + info_file_name,
                                            when='MIDNIGHT',
                                            interval=1,
                                            backupCount=7,
                                            encoding='utf-8')</code></pre><h4>二、适用人群与场景</h4><p>这款软件旨在为用户提供一站式的微博数据采集解决方案，特别适合以下场景：</p><ul><li><strong>学术研究</strong>：进行社会舆情分析、网络传播规律研究，采集特定话题的海量数据。</li><li><strong>市场营销</strong>：监测品牌关键词的搜索热度，追踪竞品博主动态，分析热门营销内容下的用户评论反馈。</li><li><strong>内容创作</strong>：分析头部KOL的发文风格与热门趋势，为自己的创作提供数据支撑和灵感。</li><li><strong>数据探索</strong>：收集你感兴趣领域的微博数据，进行个性化的清洗与可视化分析。</li></ul><hr/><h4>三、核心功能与展示</h4><p>本软件集成了三大核心采集模块，能够精准抓取多维度的数据字段。</p><h5>1. 关键词搜索采集（搜帖子）</h5><p>根据设定的关键词，抓取相关的微博帖子。</p><ul><li><p><strong>采集结果包含 11 个字段</strong>：</p><blockquote>关键词, 页码, 微博id, 微博链接, 用户昵称, 用户主页链接, 发布时间, 转发数, 评论数, 点赞数, 微博内容</blockquote></li></ul><p><img width="723" height="597" referrerpolicy="no-referrer" src="/img/bVdnFJI" alt="image.png" title="image.png"/></p><h5>2. 博主主页采集（爬主页）</h5><p>根据博主主页链接，抓取该博主发布的历史微博。</p><ul><li><p><strong>采集结果包含 13 个字段</strong>：</p><blockquote>博主昵称, 博主id, 页码, 微博id, 微博bid, 微博链接, 发布时间, 发布于, 转发数, 评论数, 点赞数, 话题标签, 微博内容</blockquote></li></ul><p><img width="723" height="597" referrerpolicy="no-referrer" src="/img/bVdnFJK" alt="image.png" title="image.png" loading="lazy"/></p><h5>3. 帖子评论采集（挖评论）</h5><p>根据具体的微博帖子链接，抓取该条微博下的所有评论。</p><ul><li><p><strong>采集结果包含 14 个字段</strong>：</p><blockquote>微博链接, 微博id, 页码, 评论者昵称, 评论者粉丝数, 评论者关注数, 评论者主页链接, 评论者性别, 评论者签名, 评论时间, 点赞数, 评论内容IP属地, 评论级别, 评论内容</blockquote></li></ul><p><img width="723" height="597" referrerpolicy="no-referrer" src="/img/bVdnFJL" alt="image.png" title="image.png" loading="lazy"/></p><hr/><h2>四、 使用指南</h2><p>想要使用这款强大的工具，只需简单四步：</p><ol><li>配置 Cookie<br/>采集前，需要将你的 PC 端 Cookie 值填入软件目录下的 cookie.txt 文件中。</li></ol><p><img width="723" height="429" referrerpolicy="no-referrer" src="/img/bVdiYGX" alt="image.png" title="image.png" loading="lazy"/></p><ol start="2"><li>登录软件<br/>打开软件界面，输入相关信息进行登录。</li><li>启动采集<br/>登录成功后，选择功能模块（搜索帖子 / 博主帖子 / 评论）。<br/>设置相关参数（如关键词、时间范围、博主链接等）。<br/>点击「开始执行」，即可在界面上实时查看采集进度。</li><li>查看结果<br/>采集完成后，CSV 数据文件将直接保存在软件所在的默认文件夹中。</li></ol><h2>五、演示视频</h2><p>软件使用过程的完整演示：</p><blockquote>mp.weixin.qq.com/s/a5z2hQM66XCMAKomhGeqzw</blockquote><h2>END、版权声明</h2><p>本软件及文章均为本人独立原创开发与编写。请尊重原创成果，严禁任何形式的二创、转载或盗发，违者必究！</p>]]></description></item><item>    <title><![CDATA[2026-01-17 GitHub 热点项目精选 程序员锋仔 ]]></title>    <link>https://segmentfault.com/a/1190000047548673</link>    <guid>https://segmentfault.com/a/1190000047548673</guid>    <pubDate>2026-01-17 14:04:30</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>🌟 2026-01-17 GitHub Python 热点项目精选(12个)</h2><blockquote>每日同步 GitHub Trending 趋势，筛选优质 Python 项目，助力开发者快速把握技术风向标～</blockquote><hr/><h3>📋 项目列表（按 Star 数排序）</h3><h4>1. <a href="https://link.segmentfault.com/?enc=Gy3Upg%2FDhfZqHct5jDHIkg%3D%3D.QAfDAdYHqIK5HG%2F%2FzTB%2FRK%2FfNIZxpKDnSrwOnugOVSlqZ0pObBNtCPMa8cFnqkBD" rel="nofollow" target="_blank">google/langextract</a></h4><blockquote>谷歌开发的项目，用于语言提取相关功能，可能在多语言处理、文本分析等领域有应用，有助于从复杂文本中提取语言信息，为自然语言处理任务提供支持。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 21209（今日+336）</td></tr><tr><td>Fork 数</td><td>🔄 1476</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=wex%2Bjizch%2Fs69z367J7yTA%3D%3D.DwSXvWqDbN3ntZTbz3jD4y05j7ucJTWjS32tPAU%2B%2FcmKFGJK%2FqHbvzDIToWhAbTk" rel="nofollow" target="_blank">https://github.com/google/langextract</a></td></tr></tbody></table><hr/><h4>2. <a href="https://link.segmentfault.com/?enc=7waPozm%2FpqOTEzJ3LwN5Uw%3D%3D.IzwxFvywyWlFftjyTeVD0NVuEEYfslHMlndsQpTGcyv094vd%2B1G4xMpPbxEJ%2F%2F%2FL" rel="nofollow" target="_blank">ultralytics/ultralytics</a></h4><blockquote>Ultralytics 团队的代码库，该团队在计算机视觉领域有诸多贡献，此项目可能涉及目标检测、图像识别等技术，基于深度学习框架实现高效的视觉任务解决方案，广泛应用于安防、自动驾驶等领域。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 51788（今日+379）</td></tr><tr><td>Fork 数</td><td>🔄 9920</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=hhVEu3zy55MZJiyAAo2l6g%3D%3D.UHo73OtxlsXmcm2mZhO7XartXMHeqB%2BT%2FLWYpCj09pHU4H0BqYks78pq744QJ1bC" rel="nofollow" target="_blank">https://github.com/ultralytics/ultralytics</a></td></tr></tbody></table><hr/><h4>3. <a href="https://link.segmentfault.com/?enc=9SGNRVoYtdifYecglqolkw%3D%3D.x83PvoC9QeRe8gjB9k8SMdRAqkIBPNxSTmNduvaK0zYa3rzdZoTOI6jjQlwFUlvb" rel="nofollow" target="_blank">neuphonic/neutts</a></h4><blockquote>专注于语音合成技术的项目，可能使用先进的神经网络架构来生成自然流畅的语音，支持多种语言和语音风格，可用于语音助手、有声读物等场景，提升语音交互体验。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 4521（今日+85）</td></tr><tr><td>Fork 数</td><td>🔄 482</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=tXld117KlDYdrS95kqcPHA%3D%3D.Kt%2FtRsd%2Btw5T3VZX4R0REqhMVotPa3uUVhJciPnMFN6Rdene2baylEnFSdCkpG8h" rel="nofollow" target="_blank">https://github.com/neuphonic/neutts</a></td></tr></tbody></table><hr/><h4>4. <a href="https://link.segmentfault.com/?enc=Ltny9wTK8nvwXAM0OhQaGA%3D%3D.a4OcufPzIfibWNMz0DsGKaz%2F3rnG1sCx0ODmkkvOzuiI2%2BCzeNrJULevBozylMiE" rel="nofollow" target="_blank">anthropics/skills</a></h4><blockquote>Anthropic 团队的项目，可能与人工智能的技能开发有关，例如为 AI 模型添加特定领域的知识或功能，使其能够更好地处理复杂任务，如文本生成、问题解答等。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 43122（今日+1247）</td></tr><tr><td>Fork 数</td><td>🔄 3988</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=rxMMHWnNiowJXlNwVC2q5g%3D%3D.s4wMbumOWSAUUd6KHl3mD0CTi0YcDnUSQRdyP2GT5ke7IzOqluQzHiTOU1lgrG41" rel="nofollow" target="_blank">https://github.com/anthropics/skills</a></td></tr></tbody></table><hr/><h4>5. <a href="https://link.segmentfault.com/?enc=9J%2BR3MB4YElLsRwPxgdkxQ%3D%3D.r9wggQFaXXJRzJSmcqaCJFygkyXCae4mY7QVHlj2DIP0ZSGe2KrUS7T1bopQAlQq" rel="nofollow" target="_blank">prowler-cloud/prowler</a></h4><blockquote>Prowler Cloud 的项目，可能与云计算安全、资源管理或性能优化相关，提供工具或服务来监控和分析云环境，帮助企业更好地管理和保护其云资源。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 12635（今日+24）</td></tr><tr><td>Fork 数</td><td>🔄 1918</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=qgjGLWMahikw4z6VbbhMrw%3D%3D.5Eui2oNiMGeQu%2BqULmZDydO4DNO0Q%2B6sKp5CGG8tbY4nsD%2FFIgZSDU1F49YVqCl4" rel="nofollow" target="_blank">https://github.com/prowler-cloud/prowler</a></td></tr></tbody></table><hr/><h4>6. <a href="https://link.segmentfault.com/?enc=fNS8oE9E1z5KkzcRutFI%2Fw%3D%3D.c9skQHvuAl7GDv2XvioTXAI%2FzoaiWhNYIjQ4j3YOfLgCTyPdzDiFgpobu71HOQi5we9lYvcjMgxCYyIs5WLKcA%3D%3D" rel="nofollow" target="_blank">davila7/claude-code-templates</a></h4><blockquote>包含 Claude 代码模板的项目，可能为开发者提供了一系列预定义的代码片段或模板，用于快速开发和部署基于 Claude 技术的应用程序，提高开发效率。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 16599（今日+383）</td></tr><tr><td>Fork 数</td><td>🔄 1451</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=YRs15C402WiAm4yrqTFILA%3D%3D.hc4u4FC%2FN2BXJbQLuyzTL08IEpwtURW9gKLI6p4HtSrcKTBH688ajABDOMLGVW787nRmr1hTAY%2F8aPOZzEEw2g%3D%3D" rel="nofollow" target="_blank">https://github.com/davila7/claude-code-templates</a></td></tr></tbody></table><hr/><h4>7. <a href="https://link.segmentfault.com/?enc=Cd%2F8VW4M8tWNGSqzHHrn%2Fg%3D%3D.gVZOeAdFFiL3ZvLKdM8ahiFQ1qQIY6LqU7nt%2F%2FmySgHjw3wn6HbqIKlebuRvB7MF" rel="nofollow" target="_blank">ml-explore/mlx-lm</a></h4><blockquote>机器学习探索团队的项目，专注于语言模型（LM）的研究和开发，可能包含先进的语言模型架构和训练方法，用于自然语言处理任务，如文本生成、语言翻译等。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 3311（今日+9）</td></tr><tr><td>Fork 数</td><td>🔄 375</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=Km8yLmSxYVLSigXn%2B9G%2BoA%3D%3D.BTvT5ikmDVQsa2ev1A1bCRZ42NvTwEiFSRx%2BAeEZuZACfXGZLFKi1OcX6YjhrnaR" rel="nofollow" target="_blank">https://github.com/ml-explore/mlx-lm</a></td></tr></tbody></table><hr/><h4>8. <a href="https://link.segmentfault.com/?enc=Ncg3Ntd2HqV52XVYTQwgvw%3D%3D.SWVVE2GtGe%2B5Gnmusjef%2F5QLE%2B4zzLWxxpcPkPos1Ko%3D" rel="nofollow" target="_blank">camel-ai/owl</a></h4><blockquote>Camel AI 团队的项目，可能与人工智能的某个特定领域相关，如智能代理、知识图谱等，旨在通过创新的技术实现更智能的决策和信息处理。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 18841（今日+33）</td></tr><tr><td>Fork 数</td><td>🔄 2195</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=h9GfKHnS1zfVKmG3RosJ6A%3D%3D.WUL8%2FpfuIZRCfW3NH0wf9wMLoVXzB6iiQO7haG4LleA%3D" rel="nofollow" target="_blank">https://github.com/camel-ai/owl</a></td></tr></tbody></table><hr/><h4>9. <a href="https://link.segmentfault.com/?enc=UNKlSK4akGhMhAAxgqQzBg%3D%3D.bLfmmsCoNDvVn7%2Fj2P2WgEyy3ggr64nLJGwRtbTQR24%3D" rel="nofollow" target="_blank">NVIDIA/warp</a></h4><blockquote>NVIDIA 开发的 Warp 项目，可能与高性能计算、图形处理或深度学习加速相关，利用 NVIDIA 的硬件优势，提供高效的计算框架或工具，用于科学计算、游戏开发等领域。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 6071（今日+17）</td></tr><tr><td>Fork 数</td><td>🔄 417</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=9uM74GPDq1DrRp5ceWeMfA%3D%3D.T7x9F4Z76OCvdCV%2FFd7FPky3u0sKJ7YKY7TWU%2Brlu%2Fs%3D" rel="nofollow" target="_blank">https://github.com/NVIDIA/warp</a></td></tr></tbody></table><hr/><h4>10. <a href="https://link.segmentfault.com/?enc=UxIM%2BQwoULl%2Ba5NglQzNgg%3D%3D.%2FyZmB2i1o1MkY1Pa8PdTH6FGz0THUEHuc9c12uHnQxbyRAyfO4VJEj9%2BgeKu%2BuNI" rel="nofollow" target="_blank">modelscope/evalscope</a></h4><blockquote>ModelScope 团队的项目，专注于模型评估和测试，可能提供了一系列工具和方法来评估机器学习模型的性能，帮助开发者优化模型，提高模型的准确性和可靠性。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 2272（今日+6）</td></tr><tr><td>Fork 数</td><td>🔄 257</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=bvDX%2FkIlo0qZoPpiXCKgXQ%3D%3D.4iIv6ihCGGiDvNIjmyLpVRRjkcVRAM3wF0OhukXH6Wv0fbnLdp8vHJwmtYFJW%2F5j" rel="nofollow" target="_blank">https://github.com/modelscope/evalscope</a></td></tr></tbody></table><hr/><h4>11. <a href="https://link.segmentfault.com/?enc=IyoLWhyLggFUv51E5dKIsw%3D%3D.ZKrJd2zeWY2DSkTet%2Fqgf3d9KJVZ%2FyQeXuL6dHMpYDsvlEkHndVNjJxjIafIvaEw" rel="nofollow" target="_blank">facebookresearch/fairseq</a></h4><blockquote>Facebook Research 的 Fairseq 项目，是一个开源的序列到序列（Seq2Seq）模型库，广泛应用于机器翻译、文本摘要等自然语言处理任务，提供了高效的训练和推理工具。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 32087（今日+4）</td></tr><tr><td>Fork 数</td><td>🔄 6647</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=HoApzhgoAcqN4XllpFQgeQ%3D%3D.n0Au37NyP902rsiihAzgemQnNJagtkY7Aw0J8dyrfqOILLGU3X%2Fo60UYT9YEct3b" rel="nofollow" target="_blank">https://github.com/facebookresearch/fairseq</a></td></tr></tbody></table><hr/><h4>12. <a href="https://link.segmentfault.com/?enc=S0qZkXyhNe4hqHu7U56t6g%3D%3D.BQPZUy%2Fyy6lcAAoZMwM9tM4Ai9G%2B5Ijenz0Te5ugAsftqU%2BEAWgwk9XpOQekG81j" rel="nofollow" target="_blank">ml-explore/mlx-examples</a></h4><blockquote>机器学习探索团队的项目，提供了一系列机器学习的示例代码和教程，帮助开发者快速上手和理解机器学习技术，涵盖多种算法和应用场景。</blockquote><table><thead><tr><th>指标</th><th>详情</th></tr></thead><tbody><tr><td>Star 数</td><td>🌟 8136（今日+3）</td></tr><tr><td>Fork 数</td><td>🔄 1123</td></tr><tr><td>开发语言</td><td>🐍 Python</td></tr><tr><td>项目地址</td><td><a href="https://link.segmentfault.com/?enc=NSDPTIhyFjHHj3tMefu1Pg%3D%3D.UdD%2F9rpiFx2kUrojR8iTY9Jh4u4utdurREBHBL5eUMEQrsBgB%2FfBF6irv0%2FTNwpC" rel="nofollow" target="_blank">https://github.com/ml-explore/mlx-examples</a></td></tr></tbody></table><hr/><h3>📝 说明</h3><ul><li>数据来源：GitHub Trending（2026-01-17 每日榜单）</li><li>筛选条件：Python 语言 + 当日热门项目</li><li>自动更新：每日同步最新趋势，建议收藏本文持续关注～</li></ul><h3>⭐ 推荐理由</h3><ol><li>热门项目代表当前技术趋势，学习价值高</li><li>优质项目代码规范，可作为学习参考</li><li>部分项目可直接用于实际开发，提高效率</li></ol>]]></description></item><item>    <title><![CDATA[AI编程出海门槛降低，PayPal可开通国内个人账户 卷福同学 ]]></title>    <link>https://segmentfault.com/a/1190000047548816</link>    <guid>https://segmentfault.com/a/1190000047548816</guid>    <pubDate>2026-01-17 14:03:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>昨天，PayPal中国正式支持个人卖家账户注册，为独立开发者、小微创业者和从事海外产品销售的个人用户提供了更便捷的跨境收款渠道。下面为您详细介绍申请流程和常见问题</p><p><img referrerpolicy="no-referrer" src="/Users/yuyunlong/Pictures/2026博客/PayPal中国开通/1.png" alt="" title=""/></p><h2>一、申请流程</h2><p><strong>1. 访问申请入口</strong></p><p>前往PayPal官方页面（<a href="https://link.segmentfault.com/?enc=g%2FAXw7muXzqyFz8OFROjJA%3D%3D.GTBaMJk%2B727646vU8VuSJ3KjuAFHFSBu8G9wi5Sngv%2BYvFn04G0l2PEKHmLY6i9y" rel="nofollow" target="_blank">https://www.paypal.cn/portal/account-selection</a>），选择“个人卖家”账户类型。</p><p><strong>2. 账户注册</strong></p><p>使用邮箱和手机号创建新账户。如曾注册过PayPal，需使用新邮箱完成申请。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047548818" alt="img" title="img" loading="lazy"/></p><p><strong>3. 完成验证</strong></p><p>依次完成手机短信验证和邮箱验证。</p><p><strong>4. 身份认证</strong></p><p>提交身份证信息并进行人脸识别认证。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047548819" alt="img" title="img" loading="lazy"/></p><p><strong>5. 填写商业信息</strong></p><p>如实填写职业和商品/行业信息，例如：</p><ul><li>职业：工程技术人员</li><li>行业：计算机软件开发服务</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047548820" alt="img" title="img" loading="lazy"/></p><p><strong>6. 提交审核</strong></p><p>信息提交后，通常30分钟内即可完成审核。通过后即可集成使用PayPal收款功能。</p><h2>二、常见问题解答</h2><p><strong>1. 费用标准</strong></p><ul><li>手续费：0.5%（限时优惠，标准费率为1.0%）</li><li>增值税：6%（由PayPal代缴）</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047548821" alt="img" title="img" loading="lazy"/></p><p><strong>2. 外汇额度与申报</strong></p><ul><li>无需个人逐笔申报，由PayPal统一向银行申报</li><li>不占用个人外汇额度，但PayPal会根据政策设置收款额度限制</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047548822" alt="img" title="img" loading="lazy"/></p><p><strong>3. 税务注意事项</strong></p><p>建议用户关注个人年度所得税申报要求，确保合规。</p><h2>结语</h2><p>PayPal个人卖家账户的推出，降低了个人从事跨境业务的门槛，为独立开发者和小微创业者提供了更便捷的收款渠道。建议有需求的用户尽早完成账户开通，为海外业务发展打好基础。</p>]]></description></item><item>    <title><![CDATA[记一次艰难的技术升级，从mongo4.0.12 到同时兼容 mongo4.0.12 和 mongo7]]></title>    <link>https://segmentfault.com/a/1190000047548828</link>    <guid>https://segmentfault.com/a/1190000047548828</guid>    <pubDate>2026-01-17 14:02:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>概述</h2><p>有OKR需要升级mongo版本为7.0。应用需要同时兼容mongo4.0.12和mongo7.0。这篇blog 记录升级过程，移除了和我们业务相关的部分（这部分细节不少，毕竟魔鬼在细节中）。</p><h2>变更盘点</h2><p>结合业务对mongo的使用。盘点版本升级的变更：</p><h3>4.2</h3><p><a href="https://link.segmentfault.com/?enc=noAQMxsu3Krpm2sQ16h88Q%3D%3D.N9oTsqR8IrYsgBi3lL45KHOJ7XL0Y2NktrB3%2BNU82P%2BvUz9%2F9J48ae5H2fziQt%2FCDlQseyfmJ5b337KWwnm3rQ%3D%3D" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/offline/docs-v4.2.tar.gz</a></p><ol><li>MMAPv1 Storage Engine 移除。</li><li>group, eval, copydb, clone 命令移除。</li><li>parallelCollectionScan  命令移除。未使用。</li><li>移除 find 的 maxScan 。未使用。</li><li>移除 geoNear 命令。未使用。</li><li>移除 repairDatabase 命令。</li><li>移除 getPrevError 命令。</li><li>弃用 cloneCollection。</li><li>Deprecated Plan Cache Commands/Methods.</li><li>聚合不再支持 $out view。</li><li>findAndModify 对 query, sort, projection 做参数检测。</li><li>Stricter Validation of count Syntax。</li><li>mongoexport query json 格式变更。</li><li>驱动默认启用可重试写入（我们不是官方驱动，所以没有重试写入）。</li><li>killcursor，不再能够在事务的开始。killcursor 权限变更，任何时候都可以kill自己的（更宽松）。</li><li>dropDatabase 再创建同名，或 movePrimary，需要重启mongos，或者flushRouterConfig。</li><li>增加了通配符索引。</li></ol><h3>4.4</h3><p>$sort, $where 变更。<br/><a href="https://link.segmentfault.com/?enc=B2tV9H9Do6HjJS9LBYc22Q%3D%3D.DABpQ8K3nGRD7rB5I6kPnzf604FmjNYpRd2LY0D7Nik8n33D1z4DADBQZNuJ1BPUrUI6oMZmEuJOEuD57GNWEx%2B5oKsYFxGJ%2FbKIvmuLYzYgJLfYPdB2ByhU%2B8X9QrCZtOL%2FMvKD%2F%2FuSPbCPH4oIMw%3D%3D" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/v4.4/release-notes/4.4-com...</a></p><h3>5.0</h3><ol><li>传递不支持参数会返回错误而不是忽略（之前不报错，升级版本后可能报错）：<a href="https://link.segmentfault.com/?enc=DnXkSLsQchJzRt1WiRZ2nA%3D%3D.bJWSpqZRbiTqVHFQ%2FRg9yhKrayUy9Yu6xT%2B2eUyt1LFxBTAOxx3uM0vsCfcth419j5Okiak3kTGkbC%2BueDB7qzcqTVjWBnod9dXQ53bk8MUbGJ9Jrj566bt06tB8%2FF6mNaOEBUBOwT5L8gkIOQ%2Ffqp%2FshMOFvWZDgk74L1XajPQ%3D" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/v7.0/release-notes/5.0-com...</a></li><li>立即过期行为变更（如果过期索引加错，数据全部没）：<a href="https://link.segmentfault.com/?enc=ee%2Fr6dWypIgun5WHt6lKhQ%3D%3D.8hOiTnGGldZ%2Bre%2BMn%2Bi%2BQ9kyV1CoYFkEQ278G%2BSIl4kRTzGmw6NcGSTjOvO2vfFqtNBgHO0OomrlP8vXiXRRlOcCqMEFi2rzZqmWMiUqqSSQPAQSpGs6X5CNQzLIsyhGz5Rb1OKOMboB%2B2qQmHtaoJa6rIuv8Bf1cWF%2FcqCeDKM%3D" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/v7.0/release-notes/5.0-com...</a></li><li>弃用 mr <a href="https://link.segmentfault.com/?enc=hkRsln5tav8vsAtSm9YDkw%3D%3D.OVfMsnKxicfz%2FbOS2YykEZDlI2l3RKWirwJaHn5rYVm6V4U4c5Zs0PTzf9q5neQMBqmHA2hP340Cw54PvM%2Fj9vn%2BGZgnmTLObg2VIaH9D%2BPOw%2BDZea0In08If%2Fvpl%2Fdc" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/v7.0/release-notes/5.0-com...</a></li><li>性能变化（默认更慢，更好的一致性） <a href="https://link.segmentfault.com/?enc=DbRsPdZ8TdGehy9MKB9tXg%3D%3D.LDJaknx%2BkHKWmJZM5NEW%2BDRDQ4Q%2FuHm3nlaiHUWxIj4JDDFbNjveteCIbehiAjfng%2BT8JscoSWnlCIbHlQNd9vjGWQXp1BrrksVWL4o2qPBy%2Fj%2BbpKm%2FGAVpCKmCSb5P" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/v7.0/release-notes/5.0/#pe...</a></li></ol><h3>6.0</h3><ol><li>需要做协议转换 传统操作码删除：<a href="https://link.segmentfault.com/?enc=fouWkYmaSAK33O0C2O1srw%3D%3D.5aHp4tu1kEPNfEDExc%2Fk5CqKbgXZwy%2FePaqHBJE1C7yTfcJGGyk5jiT7P1TGiLUoIiYDBC1Exv3m2B8GZpgiUWpy9ksNra7pcIFBZ20PlT7xf7qgDz5NG0BXsCDuVlE9" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/v7.0/release-notes/6.0-com...</a> 操作符删除：<a href="https://link.segmentfault.com/?enc=LFvh9Mazp%2Fzthz3MAVV3dA%3D%3D.M8kbQYOoxTtcuGcdJCSU6oiTAJnWq9Erf4G2Ia6chR%2FwXor27zaD5e2N19QFicEvUMN90TMASBPwwdizhJAvwYhxkwcF2vomm%2Fl8SkZwBvXkLH6qKbW5lUmFa4IchtMU" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/v7.0/release-notes/6.0-com...</a></li><li>mongo server javascript 相关（需要排查我们的数据库修改脚本，代码中的js string）：<a href="https://link.segmentfault.com/?enc=L8cVHM6krtACjpGzvIpSYQ%3D%3D.xJH%2FzCU7enL%2BxiY7fJ39qie0BnU1JNdxzSrmzESxO5%2F8%2FMGStKuKnPOKhoUq1fVldKbBpIaP%2B2QUA3YjyvnB%2FTQ%2FXBVDSYiXd%2FBRQkYPBEgNY2aUmKOJOOM%2FmaZBKs%2B%2BEv%2FKSLiqLQxkWYxfIP83ZH%2BSo3p0VMARHNxvbVQURH62kshFfbjBUJZokyGQOCm56hq8tPnfJCF0%2BsPNH%2F92sg%3D%3D" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/v7.0/release-notes/6.0-com...</a></li><li>$mod (之前不报错，升级后报错) 操作符错误行为 <a href="https://link.segmentfault.com/?enc=ZEt4L8Y6a8fC7c0li5yPzA%3D%3D.XD4Q146OwjIxGty8zB%2F6URN%2BUaov8grtK9xFANl6f3oLxGZhvPWHIJrRlh%2F8OUBrKeiUjlmnnk%2BHBIohTTHthwOaVhdXVOjV0ADF4vQ8iSpgU%2FaDWGtCHyy9%2F%2B0DeiJ3" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/v7.0/release-notes/6.0-com...</a></li></ol><h3>7.0</h3><p>未发现相关的兼容性更改<br/><a href="https://link.segmentfault.com/?enc=zW%2F1hHR2WggNHMxi9hsx2w%3D%3D.sh0MDmO%2BLnOoNGg5OdCdmld3UbUK8v4WxqKxFoueHG4yCanC1RFz%2BV0BaJezy2uIUcjybeWe7RaOrylbl11XeWfMjOldi24ZhTHAuGRVDIQ%3D" rel="nofollow" target="_blank">https://www.mongodb.com/zh-cn/docs/v7.0/release-notes/7.0-com...</a></p><h3>变更总结</h3><ol><li><a href="https://link.segmentfault.com/?enc=tRx42hSNQHVloPUbOKmyZQ%3D%3D.M%2FjSKAjbOAj8fw9DszKR9sTShsoKT%2BysehnPAtKJaWy2i2X8ulUFTLjksNCR7fpZOqmmc9VSfbKgNnOzaSl3lw%3D%3D" rel="nofollow" target="_blank">legacy-opcodes</a>删除，需要转换。</li><li>参数检测变严格，升级数据库后可能出现新报错。</li><li>功能废弃。</li><li>功能有细节变化。</li></ol><h2>实施过程</h2><h3>协议接口层转换</h3><p>我们有相当功能是运行在旧协议上的。所幸大部分代码都能在一个相当底层的地方用 adapter 范式处理。这个 adapter 几乎做到了原样转换和返回。在设计和自测时的主要维度：</p><ol><li>协议的入参，是否都兼容？</li><li>协议的返回，是否在所有情形下都完全兼容？</li></ol><h3>python 部分三方库在mongo7下有报错</h3><p>celery==3.1.18<br/>mongoengine==0.16.1<br/>在mongo7下有报错。在看过changelist后。升级风险很大，<br/>用 monkey patch 方式修复：</p><pre><code>from celery.backends.mongodb import MongoBackend
from kombu.utils import cached_property

@cached_property
def collection(self):
    """Get the metadata task collection."""
    collection = self.database[self.taskmeta_collection]

    # Ensure an index on date_done is there, if not process the index
    # in the background. Once completed cleanup will be much faster
    collection.ensure_index('date_done', background=True)
    return collection

MongoBackend.collection = collection
</code></pre><pre><code>from mongoengine.queryset.base import BaseQuerySet
from mongoengine.python_support import IS_PYMONGO_3
import warnings

# https://github.com/MongoEngine/mongoengine/pull/2160/commits
@property
def _cursor_args(self):
    if not IS_PYMONGO_3:
        fields_name = 'fields'
        cursor_args = {
            'timeout': self._timeout,
            'snapshot': self._snapshot
        }
        if self._read_preference is not None:
            cursor_args['read_preference'] = self._read_preference
        else:
            cursor_args['slave_okay'] = self._slave_okay
    else:
        fields_name = 'projection'
        # snapshot is not handled at all by PyMongo 3+
        # TODO: evaluate similar possibilities using modifiers
        if self._snapshot:
            msg = 'The snapshot option is not anymore available with PyMongo 3+'
            warnings.warn(msg, DeprecationWarning)
        cursor_args = {}
        if not self._timeout:
            cursor_args["no_cursor_timeout"] = True
    if self._loaded_fields:
        cursor_args[fields_name] = self._loaded_fields.as_dict()

    if self._search_text:
        if fields_name not in cursor_args:
            cursor_args[fields_name] = {}

        cursor_args[fields_name]['_text_score'] = {'$meta': 'textScore'}

    return cursor_args

BaseQuerySet._cursor_args = _cursor_args</code></pre><h3>协议字节层转换</h3><p>有业务场景中，并不是直接调用，而是协议层字节流需要转换。<br/>旧insert</p><pre><code>struct {
    MsgHeader header;             // standard message header
    int32     flags;              // bit values - see below
    cstring   fullCollectionName; // "dbname.collectionname"
    document* documents;          // one or more documents to insert into the collection
}</code></pre><p>新insert：</p><pre><code>db.runCommand(
   {
      insert: &lt;collection&gt;,
      documents: [ &lt;document&gt;, &lt;document&gt;, &lt;document&gt;, ... ],
      ordered: &lt;boolean&gt;,
      maxTimeMS: &lt;integer&gt;,
      writeConcern: { &lt;write concern&gt; },
      bypassDocumentValidation: &lt;boolean&gt;,
      comment: &lt;any&gt;
   }
)</code></pre><p>因为请求是 CBson.encode(%{insert: "xxx", documents: documents})<br/>documents 已经encode过。需要decode documents再encode。<br/>写了一个特殊的bson encode。避免重复encode。</p><h2>遇到的线上问题</h2><p>下面问题是在线上发现的，虽然没有造成直接的线上事故，而是在开服之前发现，但也需要专门的修复，没造成更严重后果有一定运气成分了。</p><ol><li><a href="https://segmentfault.com/a/1190000047548773" target="_blank">mongo server count 协议大于 1073741823 返回浮点数问题</a></li><li>协议字节层转换在大包时可能是 iolist 问题 (有做大包测试，但没做完整链路大包测试)。</li></ol><h2>总结</h2><ol><li>遇到的问题几乎都是《未知的未知》，人不是全知全能的，很难完全避免，只能通过更精细的持续交付过程去减少。</li><li>mongo 的兼容方式是，先用新版本同时支持 新、旧协议接口，在更高版本再移除旧协议接口，在长期维护的项目中，这是个可参考的升级方式。</li><li>魔鬼在细节中。</li></ol>]]></description></item><item>    <title><![CDATA[Teanary支付，物流扩展开发文档 xcalder ]]></title>    <link>https://segmentfault.com/a/1190000047548841</link>    <guid>https://segmentfault.com/a/1190000047548841</guid>    <pubDate>2026-01-17 14:02:15</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>Teanary Extensions 扩展模板仓库</h2><p>这是 Teanary Service 的扩展模板仓库，用于创建和分发支付方式和运输方式的扩展。</p><h3>📚 文档</h3><ul><li><a href="./EXTENSION_GUIDE.md" target="_blank">扩展开发指南</a> - 完整的扩展开发文档</li></ul><h3>🎯 使用方式</h3><h4>方式一：基于模板创建新扩展</h4><ol><li><p><strong>复制模板文件</strong></p><pre><code class="bash"># 复制支付扩展模板
cp -r templates/payment/your-extension-name my-extension

# 或复制运输扩展模板
cp -r templates/shipping/your-extension-name my-extension</code></pre></li><li><p><strong>修改模板代码</strong></p><ul><li>替换所有 <code>YourExtension</code> 为你的扩展名称</li><li>实现具体的业务逻辑</li><li>更新配置和翻译文件</li></ul></li><li><p><strong>集成到主项目</strong></p><ul><li>按照模板中的 <code>INTEGRATION.md</code> 步骤集成</li><li>或参考 <a href="./EXTENSION_GUIDE.md" target="_blank">扩展开发指南</a></li></ul></li></ol><h4>方式二：直接在主项目中开发</h4><p>参考 <a href="./EXTENSION_GUIDE.md" target="_blank">扩展开发指南</a> 中的详细步骤。</p><h3>📁 目录结构</h3><pre><code>teanary-extensions/
├── README.md                    # 本文件
├── EXTENSION_GUIDE.md           # 扩展开发指南
├── templates/                   # 扩展模板
│   ├── payment/                 # 支付扩展模板
│   │   └── stripe/              # Stripe 支付模板示例
│   │       ├── README.md
│   │       ├── INTEGRATION.md
│   │       ├── src/
│   │       ├── config/
│   │       └── lang/
│   └── shipping/                # 运输扩展模板
│       └── dhl/                 # DHL 运输模板示例
│           ├── README.md
│           ├── INTEGRATION.md
│           ├── src/
│           ├── config/
│           └── lang/
└── examples/                    # 完整示例（可选）
    ├── stripe-payment/          # Stripe 支付完整示例
    └── dhl-shipping/           # DHL 运输完整示例</code></pre><h3>🚀 快速开始</h3><h4>创建支付扩展</h4><ol><li>查看支付模板：<code>templates/payment/stripe/</code></li><li>复制并重命名模板</li><li>实现支付网关接口</li><li>按照集成指南集成到主项目</li></ol><h4>创建运输扩展</h4><ol><li>查看运输模板：<code>templates/shipping/dhl/</code></li><li>复制并重命名模板</li><li>实现运输计算器接口</li><li>按照集成指南集成到主项目</li></ol><h3>📝 扩展命名规范</h3><ul><li><p><strong>支付扩展</strong>：<code>teanary-extension-{payment-name}</code></p><ul><li>例如：<code>teanary-extension-stripe</code>、<code>teanary-extension-alipay</code></li></ul></li><li><p><strong>运输扩展</strong>：<code>teanary-extension-{shipping-name}</code></p><ul><li>例如：<code>teanary-extension-dhl</code>、<code>teanary-extension-fedex</code></li></ul></li></ul><h3>🤝 贡献扩展</h3><p>如果你开发了新的扩展，欢迎：</p><ol><li>创建独立的仓库（如 <code>teanary-extension-stripe</code>）</li><li>基于本模板仓库的结构组织代码</li><li>提供清晰的 README 和集成文档</li><li>提交到 Gitee/Github 并告知我们</li><li><h3>📄 许可证</h3></li></ol><p>本项目采用 <a href="./LICENSE" target="_blank">GNU General Public License v3.0</a> (GPLv3) 许可证。</p><hr/><p><strong>Teanary Extensions</strong> - 让扩展开发更简单 🎉</p>]]></description></item><item>    <title><![CDATA[从报表到对话：金融机构如何利用统一查询引擎驱动 AI 问数？ 镜舟科技 ]]></title>    <link>https://segmentfault.com/a/1190000047548854</link>    <guid>https://segmentfault.com/a/1190000047548854</guid>    <pubDate>2026-01-17 14:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>本文结合某大型金融机构的落地实践，介绍如何基于 StarRocks 打造统一查询引擎，并在此基础上实现 AI+BI 融合的智能决策能力，让投研、风控、财富、运营等多条业务线都能“边想边问”。</p><h3>行业背景：从“查数”到“问数”的金融数据新常态</h3><p>不像一般金融机构只处理内部客户与产品数据，券商每天要整合来自市场、交易、客户、研究、运营等数十个系统的海量数据，形成对股票走势、客户行为、风险敞口、营销机会的实时洞察。</p><p>证券公司的典型数据分析场景包括：</p><h4>1. 投研与市场分析</h4><ul><li><strong>行业对标与个股诊断：</strong>快速找出某行业内 PE、PB 最低的前十家公司，并叠加融资融券热度、期权成交量等市场情绪指标。</li><li><strong>机构持仓追踪：</strong>按基金、险资、产业资本维度，分析其最新重仓股、建仓节奏、持仓风格变化。</li><li><strong>财报数据深度挖掘：</strong>对比上市公司最近几期财报，找出毛利率、研发投入、现金流的变化趋势和同行差异。</li></ul><h4>2. 财富管理与客户经营</h4><ul><li><strong>客户资产与持仓分析：</strong>分析某家机构客户或重点零售客户的总资产、持仓集中度、收益贡献，为精准推荐与服务提供依据。</li><li><strong>理财与基金销售排名：</strong>统计各渠道、各产品的销售数量与客户购买习惯，为产品开发与营销策略调整提供参考。</li><li><strong>客户行为与风险识别：</strong>识别高净值客户流失风险、融资融券违约倾向等，支撑精准服务与风控预警。</li></ul><h4>3. 风险管理与合规</h4><ul><li><strong>融资融券风险监控：</strong>实时跟踪融资融券余额、风险敞口、重点警示客户名单，支撑自动化预警与即时干预。</li><li><strong>交易监控与异常识别：</strong>监测高频交易、内幕交易嫌疑、市场操纵行为，为合规部门提供快速报警与聚类分析。</li><li><strong>流动性与对手方风险：</strong>分析债券、衍生品交易中的流动性状况和交易对手的信用风险。</li></ul><h4>4. 内部运营与数据治理</h4><ul><li><strong>系统性能与数据质量监测：</strong>通过自然语言问答快速查询“本周数据延迟最高的三个系统”“元数据字段命名规范覆盖率”等运营指标。</li><li><strong>员工销售与服务排名：</strong>按照交易量、新增客户、留存客户等多维度统计员工绩效，为绩效管理提供数据支撑。</li></ul><p>这些场景的共同点是：</p><ul><li><strong>多源、异构、高频更新：</strong>行情数据秒级更新，财报数据月度更新，客户行为实时产生，需要在同一引擎下快速关联分析。</li><li><strong>查询场景复杂多变：</strong>从“某行业估值排名”到“融资融券风险监控”，从“客户持仓画像”到“员工销售管理”，不同部门的需求差异极大。</li><li><strong>对实时性和准确性要求极高：</strong>一个“今日成交量前十”的排名，市场部、风控部、合规部都要看，不能有数据口径不一致的情况。</li></ul><h3>核心挑战：多源、重算、高并发下的理财分析困局</h3><p>在传统架构下，券商往往采用多套查询引擎并行，导致数据链路长、维护成本高、性能不稳定。面对高并发、多场景的复杂查询需求，尤其是理财、公募与客户联动分析时，多表关联查询容易出现响应慢、资源占用高的问题。</p><p><strong>查询系统割裂</strong></p><p>BI、API、指标平台、标签系统各自绑定不同的计算引擎，数据口径不统一，A 部门的“融资融券风险客户”和 B 部门理解的可能不一样，导致同一业务问题需要多条链路才能回答。</p><p><strong>复杂查询性能瓶颈</strong></p><p>一旦涉及多表关联、跨越多个数据源、需要复杂聚合的查询，例如“找出融资融券余额超过 1000 万的客户，关联其最近 30 天的成交数据、持仓结构、账户评级”，可能需要分钟级甚至更长的时间。</p><p><strong>数据使用门槛高</strong></p><p>大量业务人员不会写 SQL，只能通过固定报表或依赖数据团队帮忙查数，很难做到“想到就问、问了就算”。</p><p><strong>AI 能力难以落地</strong></p><p>虽然证券公司都在谈大模型、AI 投顾、智能客服等新场景，但是 AI 生成的 SQL 可能因为数据来源分散、字段名不统一而无法执行，同时，自然语言问数的结果解读需要复杂的后处理，难以形成自动化闭环。</p><h3>基于 StarRocks 的统一查询与智能问答引擎</h3><p>镜舟科技基于 StarRocks 打造了面向金融机构的统一查询与智能问数解决方案，从底层引擎到上层 AI 问答形成一体化架构。</p><h4>第一层：统一高性能查询底座</h4><p>以 StarRocks 作为统一分析引擎，接入行内核心业务库与数据湖的数据，承载 BI 报表、API 服务、指标与标签计算等多类型查询，替代多引擎并行架构。</p><ul><li>通过列式存储与向量化执行，支持亿级数据秒级响应。</li><li>通过 CBO 优化器与智能执行计划，即使没有预先建设大宽表，也能高效完成多表关联查询。</li><li>硬件利用率更高，在相同或更少资源配置下，能支撑数倍的并发与更快的响应时间。</li></ul><h4>第二层：联邦查询与场景化预计算</h4><ul><li>利用 StarRocks 联邦查询能力整合行情、财务、交易、客户、风险等多源数据，为投研分析、风险监控、客户经营等场景提供统一入口。</li><li>对“沪深 300 成分股排名”“融资融券风险客户监控名单”“理财产品销售排名”“员工销售绩效”等高频复杂指标建立物化视图，进行预计算和缓存。</li><li>确保智能问数查询稳定在秒级，同时支撑高并发访问。</li></ul><h4>第三层：AI 问数与自然语言分析</h4><p>在统一查询底座之上，引入大模型与上层 AI 问数应用，对接业务人员的自然语言问题，将其自动解析为 SQL 并在镜舟数据库中高性能执行，随后再将结果转化为易于理解的自然语言总结与图表。</p><p>通过底层镜舟提供的统一数据入口与极速分析能力，结合外层 AI 问数平台，对一系列金融特有语义进行识别与抽象，实现从问题理解、SQL 生成到结果解读的闭环，让业务人员在同一入口完成自助取数与分析。</p><h3>案例：某大型金融机构的理财智能问答实践</h3><p>某大型金融机构在理财与公募业务协同方面有大量分析需求，例如定期盘点“本季度新发理财产品的机构排名、重仓公募基金市值变化及爆款产品、重点机构客户的持仓结构调整”等。</p><p>在引入镜舟科技的方案之前，这些分析主要依赖多套 BI 报表与人工 SQL，涉及几十张业务表和外部数据表，分析周期往往以天为单位，难以支撑前台销售与投研团队的实时需求。</p><p>项目落地后，银行基于 StarRocks 构建统一查询引擎，将理财产品台账、公募基金持仓、机构客户信息等数据统一纳入一个高性能分析底座，并在此之上接入智能问数平台。</p><p>1. 引入 StarRocks 后，基于几十亿行交易明细表的复杂关联查询（如“某类特征客户的持仓盈亏分析”），响应时间<strong>从分钟级压缩至秒级</strong>。</p><p>2. 通过部署智能问数平台，<strong>超过一半的临时性取数需求</strong>（如各分支机构的业绩排名、特定客群筛选）由业务人员通过对话直接完成，数据团队不再是取数工具人。</p><p>3. 统一底座替代了原有的 HBase、Impala 等多套组件，但<strong>并发承载能力提升 3 倍</strong>，支撑开市期间的高峰访问。</p><p>这种从“查”到“问”的转变，正在重塑金融行业的数据文化与决策机制。不远的将来，“依赖数据驱动决策”将成为金融机构竞争力的核心组成部分，而掌握了“智能问数”的企业，将在市场竞争中赢得更多优势。</p>]]></description></item><item>    <title><![CDATA[大模型榜单周报（2026/1/17） KAI智习 ]]></title>    <link>https://segmentfault.com/a/1190000047548778</link>    <guid>https://segmentfault.com/a/1190000047548778</guid>    <pubDate>2026-01-17 13:04:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h3>1. 本周概览</h3><p>本周大模型领域继续保持快速发展态势，各大厂商在医疗AI、视频生成、代码能力等多个领域取得显著进展。OpenRouter模型调用量排名发生重要变化，Claude系列模型表现抢眼，百度新模型ERNIE-5.0-0110在全球LMArena文本排行榜上排名第八，展现了中国模型的强劲实力。</p><h3>2. 重点关注事件</h3><ul><li>DeepSeek与北京大学合作发表关于条件记忆（conditional memory）的新论文，提出Engram模块，有望提升模型检索效率</li><li>Anthropic推出工作场景智能体Claude Cowork，由Claude Code自主开发，体现了AGI在实际应用中的潜力</li><li>谷歌发布新一代开源医疗AI模型MedGemma 1.5及MedASR语音识别模型，进一步扩展在医疗AI领域的布局</li><li>谷歌Veo 3.1更新支持9:16竖屏视频和4K分辨率，视频生成能力持续提升</li><li>智谱与华为合作开源图像生成模型GLM-Image，登顶复杂视觉文字生成和长文本渲染双榜首</li><li>阿里千问APP上线超400项AI办事功能，接入阿里生态，成为全球首个能完成真实生活复杂任务的AI助手</li><li>OpenAI推出独立翻译页面ChatGPT Translate，拓展应用场景</li><li>百度ERNIE-5.0-0110在全球LMArena文本排行榜上排名第八，超越多个领先模型</li></ul><h3>3. 榜单变化</h3><ul><li><p><strong>OpenRouter模型调用量排名</strong>：</p><ul><li>整体调用量方面，Claude Opus 4.5超越上周榜首Claude Sonnet 4.5，位列第1；MiMo-V2-Flash(free)上升两名，排名第3；Gemini 3 Flash Preview由第4名下降至第5名</li><li>模型市占率方面，Google保持第1；Anthropic市占率上升4.2%（17.2% → 21.5%），连续两周上升8.5%；OpenAI市占率上升3.1%（8.0% → 11.1%）；Qwen上升至第8名，替代了上周MiniMax的位置</li><li>编程调用量方面，Claude Opus 4.5保持第1；Claude Sonnet 4.5排名上升2名，排名第3；DeepSeek V3.2重回前十，排名第8</li></ul></li><li><strong>大语言模型榜单</strong>：ERNIE-5.0-0110新上榜，排名第8，超过GPT-5.1（high），相比ERNIE-5.0-preview-1203版本上升了6名，该模型基于预发布测试，评分可能随着公开发布后的反馈而变化</li><li><strong>图像编辑能力榜单</strong>：flux-2-max和flux-2-pro新上榜，分别排名第8、第9</li><li><strong>文生图能力榜单</strong>：FLUX.2 [dev]Turbo新上榜，排名第10</li><li><strong>GAIA榜单</strong>：JoinAI V2.2登顶榜首，得分达90.7%</li></ul><h3>4. 排行榜</h3><table><thead><tr><th>测评类型</th><th>第一名</th><th>第二名</th><th>第三名</th></tr></thead><tbody><tr><td>模型调用量</td><td>Claude Opus 4.5</td><td>Claude Sonnet 4.5</td><td>MiMo-V2-Flash(free)</td></tr><tr><td>公司市占率</td><td>Google</td><td>Anthropic</td><td>OpenAI</td></tr><tr><td>编程模型调用量</td><td>Claude Opus 4.5</td><td>Grok Code Fast 1</td><td>Claude Sonnet 4.5</td></tr></tbody></table><h4>各公司按不同能力领域排名汇总</h4><table><thead><tr><th>测评类型</th><th>领先公司</th></tr></thead><tbody><tr><td>大语言模型 Text Arena</td><td>Google、xAI、Anthropic、百度、OpenAI、智谱、阿里巴巴、月之暗面</td></tr><tr><td>编程能力 LMArena</td><td>Anthropic、OpenAI、Google、智谱、MiniMax</td></tr><tr><td>编程能力 LiveCodeBench</td><td>OpenAI、Anthropic、Google</td></tr><tr><td>代码工程任务能力 SWE-benchLite</td><td>基于Claude、Gemini、GPT、Qwen、DeepSeek开发的开源系统</td></tr><tr><td>图像编辑和生成能力 Image Edit Arena</td><td>OpenAI、Google、字节、Black Forest Labs、Reve</td></tr><tr><td>文生图能力 Text-to-Image Arena</td><td>OpenAI、Google、Black Forest Labs、腾讯、字节</td></tr><tr><td>文生图能力 Text to Image Leaderboard</td><td>OpenAI、Google、Black Forest Labs、字节、ImagineArt</td></tr><tr><td>GPQA</td><td>OpenAI、Google、xAI、Anthropic、阿里巴巴</td></tr><tr><td>FrontierMath</td><td>OpenAI、Google、DeepSeek、月之暗面、Anthropic、xAI</td></tr><tr><td>Humanity's Last Exam</td><td>Google、OpenAI、Anthropic</td></tr><tr><td>GAIA</td><td>JoinAI、Nvidia、Suzhou AI Lab&amp;Shuqian Tech、Microsoft AI Asia -Ads</td></tr></tbody></table><hr/><p>关注我，第一时间掌握更多AI前沿资讯！</p>]]></description></item><item>    <title><![CDATA[无人机行人精准检测数据集（7000张图片已划分、已标注）｜AI训练适用于目标检测任务 逐梦AI ]]></title>    <link>https://segmentfault.com/a/1190000047548783</link>    <guid>https://segmentfault.com/a/1190000047548783</guid>    <pubDate>2026-01-17 13:03:30</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <h2>无人机行人精准检测数据集（7000张图片已划分、已标注）｜AI训练适用于目标检测任务</h2><p>在公共安全治理、城市精细化管理以及应急响应体系不断升级的背景下，基于无人机平台的智能视觉感知技术正逐步成为空地协同监管的重要技术手段。其中，<strong>行人（person）目标的高精度检测能力</strong>，直接决定了无人机在复杂环境下对人群态势的感知水平与决策支撑价值。</p><p>本数据集围绕“<strong>无人机视角下行人精准检测</strong>”这一核心目标构建，聚焦单一关键类别 <em>person</em>，通过高质量标注与合理的数据集划分，为目标检测模型在真实应用场景中的训练与评估提供稳定、可靠的数据基础。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047548785" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><hr/><h3>数据集下载</h3><blockquote>链接:<a href="https://link.segmentfault.com/?enc=5Zfbx0L%2BafJNHU1uTGfWjA%3D%3D.FbiZcVDgnPBDg9L2HZuj%2F5ukhQaM97PN8ObwIaYgm41GY9YUrD9yzjkeHO9qkjkgE6CF8EaCsRHP4GPTzCZr4w%3D%3D" rel="nofollow" target="_blank">https://pan.baidu.com/s/1JLWpaKuFhVzrrfoMXERBDQ?pwd=6amw</a> <br/>提取码:6amw 复制这段内容后打开百度网盘手机App，操作更方便哦</blockquote><p>在公共安全管控、大型活动人流疏导、应急救援响应及交通枢纽秩序维护等对行人识别精度、动态轨迹追踪能力及复杂场景适应性起关键作用的领域，基于无人机平台的行人目标检测系统，依托无人机载高清摄像设备、实时传输模块及空域动态监测技术，实现对唯一核心目标 'person（行人）' 的精准检测，直接关系到公安部门对大型集会现场人员密集度的实时掌控（如演唱会现场人流密度监测、体育赛事观众区域秩序监管）、城市重点区域（如商圈步行街、景区热门景点）行人流动趋势的动态研判及突发公共事件（如自然灾害疏散、事故现场救援）中受困人员的快速定位；'person（行人）' 作为判断区域安全风险等级、人流疏导优先级及应急救援资源调配的核心依据，其精准识别检测是开展公共安全预案制定、人流管控策略调整、紧急救援路径规划及城市空域协同管理的基础，对特定场景下（如夜间低光照环境中行人识别、复杂建筑群内人员轨迹追踪、恶劣天气下户外行人监测）的准确捕捉，还能为管理部门提供人员聚集规律、流动热点区域等关键信息，辅助评估公共安全态势与管控策略优化需求。</p><p>数据集共包括1类，划分为训练集、验证集和测试集。</p><p>classes</p><p>nc: 1<br/>names: ['person']</p><p>适用模型算法 目标检测</p><p>YOLO系列</p><p>数据集划分详情</p><p>"总张数：6990"<br/>"训练集：6445"<br/>"验证集：545"</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047548786" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>数据集概述</h3><p>无人机航拍视角下的行人检测任务，相较于传统地面摄像头场景，面临着<strong>俯视角度变化大、目标尺度差异明显、背景复杂度高、遮挡频繁</strong>等挑战。本数据集针对上述问题进行了针对性采集与筛选，确保样本具备良好的多样性与实用价值。</p><p>数据集具有以下整体特征：</p><ul><li>单一核心目标类别：<code>person（行人）</code></li><li>视角来源：无人机高空/低空航拍</li><li>场景多样：城市道路、广场、景区、空旷区域等</li><li>标注规范：适用于主流目标检测算法</li></ul><p>数据已完成<strong>全量标注与数据集划分</strong>，可直接用于模型训练与验证。</p><hr/><h3>数据集详情</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047548787" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h4>类别信息</h4><pre><code class="yaml">nc: 1
names: ['person']</code></pre><ul><li>类别数量（nc）：1</li><li>唯一检测目标：行人（person）</li></ul><h4>数据规模与划分</h4><ul><li><strong>总图片数量</strong>：6990 张</li><li><strong>训练集（Train）</strong>：6445 张</li><li><strong>验证集（Val）</strong>：545 张</li><li>（测试集可根据项目需要自行划分或扩展）</li></ul><p>数据划分比例合理，有助于模型在训练阶段充分学习特征，同时在验证阶段稳定评估泛化性能。</p><h4>数据格式</h4><ul><li>图像数据：常见图像格式（jpg / png）</li><li>标注格式：兼容 YOLO 系列目标检测标注规范</li><li>目录结构清晰，便于直接加载至训练框架</li></ul><hr/><h3>适用模型算法（目标检测）</h3><p>本数据集专为<strong>目标检测任务</strong>设计，已验证可直接适配主流 YOLO 系列模型，包括但不限于：</p><ul><li><strong>YOLOv5</strong></li><li><strong>YOLOv8</strong></li><li><strong>YOLOv11</strong></li><li>其他支持 YOLO 标注格式的检测框架</li></ul><p>在单类别检测场景下，模型可更集中地学习行人特征，有助于提升检测精度、减少误检与漏检，特别适合用于轻量化部署与实时推理场景。</p><hr/><h3>适用场景</h3><p>该无人机行人检测数据集在多个实际应用领域具备直接落地价值：</p><h4>公共安全与大型活动管理</h4><ul><li>演唱会、体育赛事等大型集会人流密度监测</li><li>区域人员聚集态势实时分析</li><li>风险等级评估与人群疏导决策支持</li></ul><h4>城市管理与重点区域巡查</h4><ul><li>商圈、步行街、景区等高人流区域监测</li><li>行人流动趋势分析与热点区域研判</li><li>城市空域与地面管理协同辅助</li></ul><h4>应急救援与突发事件响应</h4><ul><li>自然灾害现场受困人员快速定位</li><li>事故现场人员分布监测</li><li>应急救援路径规划与资源调配支持</li></ul><h4>特殊复杂环境识别</h4><ul><li>夜间或低光照环境下行人检测</li><li>建筑群、复杂地形中的人员识别</li><li>恶劣天气条件下的户外行人监测</li></ul><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047548788" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>结语</h3><p>行人作为公共安全感知体系中最核心、最敏感的目标对象，其检测精度直接影响风险判断与决策执行效率。本无人机行人精准检测数据集，以<strong>单类别、高质量、强实用性</strong>为设计核心，兼顾模型训练效率与真实应用需求，能够有效支撑目标检测算法在无人机视觉场景下的研究与工程落地。</p><p>无论是用于算法性能验证、工程化模型训练，还是作为无人机智能感知系统的数据基础，该数据集均具备较高的实用与参考价值。</p><p>综上所述，无人机行人精准检测数据集并非只是一个简单的图像与标注集合，而是面向真实公共安全与城市治理需求而构建的、具有明确应用指向的数据基础设施。在当前智慧城市、低空经济与人工智能深度融合的发展背景下，基于无人机平台的行人目标检测，正逐步从“实验验证阶段”走向“规模化部署与实战应用阶段”，而高质量、针对性强的数据集正是这一过程中的关键支撑。</p><p>从数据集设计角度来看，本数据集聚焦于唯一核心目标类别 person（行人），有效避免了多类别检测在复杂场景中带来的特征干扰问题，使模型能够更加专注于行人外观特征、尺度变化、空间分布与遮挡关系的学习。这种“单类别、强聚焦”的数据构建思路，尤其适合无人机航拍视角下的检测任务，有助于提升模型在高空俯视、远距离、小目标场景中的识别稳定性与检测精度。</p><p>从数据规模与质量层面分析，近7000张已标注图像并经过合理的训练集与验证集划分，能够满足主流目标检测模型在中小规模项目、工程实践及科研验证中的训练需求。同时，统一的标注规范与清晰的数据结构，使得数据集可以无缝对接 YOLOv5、YOLOv8、YOLOv11 等主流检测算法，显著降低了模型训练前的准备成本，提高整体开发效率。</p><p>在应用价值层面，该数据集具备明显的现实意义。无论是在大型活动现场的人流密度监测、城市重点区域的日常巡查，还是在突发公共事件中的应急救援与人员定位，行人目标始终是风险研判与决策制定的核心依据。通过对无人机视角下行人目标的精准检测，可以为管理部门提供更加客观、实时的数据支持，辅助完成从“被动响应”向“主动预警”的转变。</p><p>此外，在复杂环境适应性方面，本数据集覆盖了多种航拍高度、场景背景与人员分布状态，为模型在低光照、复杂建筑环境、人员密集或稀疏区域等条件下的泛化能力提供了良好的训练基础。这对于后续模型在真实部署过程中应对不可控环境变化，具有重要的工程价值。</p><p>从技术发展趋势来看，随着无人机算力提升、边缘计算与模型轻量化技术的不断成熟，行人检测模型将更多地运行于无人机端或近端设备，对模型推理速度、稳定性与误检控制提出更高要求。以本数据集为基础进行训练和优化，不仅有助于验证算法性能，也为后续模型剪枝、量化、蒸馏等工程优化工作提供了可靠的数据支撑。</p><p>总体而言，本无人机行人精准检测数据集在数据完整性、标注规范性、应用针对性与工程可落地性等方面均具备较高水准。它既可以作为目标检测算法学习与研究的实践数据集，也可以作为无人机智能视觉系统开发中的基础训练资源。随着应用场景的不断拓展与数据持续迭代，该数据集还具备进一步扩展为多场景、多时段无人机行人感知数据体系的潜力。</p><p>在未来的工作中，围绕该数据集开展的模型性能评测、跨场景泛化研究以及多任务联合感知（如行人检测与密度估计、轨迹分析相结合），都将为无人机在公共安全与城市治理中的深度应用提供更加坚实的数据与技术基础。</p>]]></description></item><item>    <title><![CDATA[FFmpeg开发笔记（九十九）基于Kotlin的国产开源播放器DKVideoPlayer aqi00]]></title>    <link>https://segmentfault.com/a/1190000047548794</link>    <guid>https://segmentfault.com/a/1190000047548794</guid>    <pubDate>2026-01-17 13:02:44</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/8a2de9abf59d619c.css" data-n-g=""> <p>​《FFmpeg开发实战：从零基础到短视频上线》一书的“第 12 章  FFmpeg的移动开发”介绍了如何使用FFmpeg在手机上播放视频，基于FFmpeg的国产播放器开源框架也有很多了，前有哔哩哔哩的ijkplayer，后有小红书的RedPlayer，参见之前的文章《使用国产的ijkplayer播放器观看网络视频》和《使用国产的RedPlayer播放器观看网络视频》。</p><p>除此以外，DKVideoPlayer也是一款优秀的国产Android视频播放器，它基于Kotlin编写，不但集成了Android原生的MediaPlayer，还集成了Jetpack的ExoPlayer，甚至集成了国产的ijkplayer。DKVideoPlayer既支持播放本地视频，也支持播放网络视频，甚至支持播放直播链接，可谓功能强大。  <br/>DKVideoPlayer的源码托管地址为 <a href="https://link.segmentfault.com/?enc=GPFybR%2FQNU6sGStbDCRmzw%3D%3D.ixJCi9XM3V9FFXZ2WMLYC9xph2KFgscjRt8i8dLDZltrA3nIwIEZKfD2OKvz%2BUed" rel="nofollow" target="_blank">https://github.com/Doikki/DKVideoPlayer</a> （星星数5.3k），国内的镜像地址为 <a href="https://link.segmentfault.com/?enc=c5maJdDUbLg8UQQvyb8rwQ%3D%3D.ClE4R%2BAfHHQmgICaA9SrCSwKLhGtea7dfywAs1ICMANSEa1pbJ1xOVvucDfm9DRS" rel="nofollow" target="_blank">https://gitcode.com/gh_mirrors/dk/DKVideoPlayer</a> ，最新版本是2022年7月发布的v3.3.7，可见该框架的源码更新十分及时，该版本的源码下载地址为 <a href="https://link.segmentfault.com/?enc=1a4VhAuEsOsyFYK%2Bt83arQ%3D%3D.eWr6qxim%2By4fICJeJDzXNoNBB4MIQ16OOho1ewhrpJHLDsGk%2BV9B6nRam7Yyb36vC6iNIGjOxMt%2FCsjkY6CSqmRGPoInLH%2FBiI89F3mqZis%3D" rel="nofollow" target="_blank">https://github.com/Doikki/DKVideoPlayer/archive/refs/tags/3.3.7.tar.gz</a> 。  <br/>DKVideoPlayer提供了两种集成方式，引用在线库、直接导入源码，分别说明如下：</p><h2>一、引用DKVideoPlayer在线库</h2><p>Android工程引用DKVideoPlayer在线库时，需要修改以下两个配置：  <br/>1、打开模块级别的build.gradle，给dependencies节点补充下面几行配置，表示引入3.3.7版本的DKVideoPlayer库：</p><pre><code># 必选，内部默认使用系统mediaplayer进行解码
implementation 'xyz.doikki.android.dkplayer:dkplayer-java:3.3.7'
# 可选，包含StandardVideoController的实现
implementation 'xyz.doikki.android.dkplayer:dkplayer-ui:3.3.7'
# 可选，使用exoplayer进行解码
implementation 'xyz.doikki.android.dkplayer:player-exo:3.3.7'
# 可选，使用ijkplayer进行解码
implementation 'xyz.doikki.android.dkplayer:player-ijk:3.3.7'
# 可选，如需要缓存或者抖音预加载功能请引入此库
implementation 'xyz.doikki.android.dkplayer:videocache:3.3.7'</code></pre><p>2、打开App模块的src/main/AndroidManifest.xml，给manifest节点补充下面几行权限配置，表示声明悬浮窗、存储空间和网络等权限：</p><pre><code>&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" /&gt;
&lt;uses-permission android:name="android.permission.SYSTEM_OVERLAY_WINDOW" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;</code></pre><h2>二、直接导入DKVideoPlayer源码</h2><p>DKVideoPlayer的源码已经适配Android Studio Dolphin（小海豚版本），仅需在项目级别的build.gradle补充国内仓库即可。也就是在repositories节点内部补充以下配置：</p><pre><code>// 以下四行添加阿里云的仓库地址，方便国内开发者下载相关插件
maven { url = uri("https://maven.aliyun.com/repository/jcenter") }
maven { url = uri("https://maven.aliyun.com/repository/google")}
maven { url = uri("https://maven.aliyun.com/repository/gradle-plugin")}
maven { url = uri("https://maven.aliyun.com/repository/public")}
// 以下添加清华大学的仓库地址
maven { url = uri("https://mirrors.tuna.tsinghua.edu.cn/repository/maven-central/") }</code></pre><p>增加以上配置的目的是引入国内的仓库地址，以便加快相关依赖包的下载速度。</p><p>等待DKVideoPlayer工程编译通过，把主入口的dkplayer-sample模块安装到手机上，启动之后的App界面如下图所示：</p><p><img width="718" height="820" referrerpolicy="no-referrer" src="/img/bVdnuTb" alt="" title=""/></p><p>点击【点播】按钮，打开网络视频的播放界面如下图所示：</p><p><img width="720" height="1087" referrerpolicy="no-referrer" src="/img/bVdnuTc" alt="" title="" loading="lazy"/></p><p>或者点击【直播】按钮，打开直播链接的播放界面如下图所示：</p><p><img width="720" height="1087" referrerpolicy="no-referrer" src="/img/bVdnuTd" alt="" title="" loading="lazy"/></p><p>可见DKVideoPlayer支持调整播放窗口大小、调整播放速度，以及旋转、截图、裁剪等功能，可谓将常见的播放操作一网打尽。</p><p>更多详细的FFmpeg开发知识参见<a href="https://link.segmentfault.com/?enc=kkEbJGRtzj9XK6aK1h4vdw%3D%3D.JyHpuLecg5OeWUSQNA3Advk6vQRtrrejl7QTthPP98TW48h98ufz0TKWZrv641jv" rel="nofollow" title="《FFmpeg开发实战：从零基础到短视频上线》" target="_blank">《FFmpeg开发实战：从零基础到短视频上线》</a>一书。</p>]]></description></item>  </channel></rss>