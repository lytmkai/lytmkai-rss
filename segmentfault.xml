<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[CVE-2025-59287（RCE 漏]]></title>    <link>https://segmentfault.com/a/1190000047436120</link>    <guid>https://segmentfault.com/a/1190000047436120</guid>    <pubDate>2025-11-28 16:12:41</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>CVE-2025-59287 简要说明</h2><p>Windows 服务器更新服务（WSUS）存在一个严重的远程代码执行（RCE）漏洞（CVE-2025-59287）。</p><p>攻击者可以 SYSTEM 权限执行代码，实现服务器完全接管、数据窃取和横向移动。研究人员已确认该漏洞存在活跃利用情况。</p><p>请立即安装微软的紧急补丁，并重启 WSUS 服务器。限制对 WSUS 的网络访问，监控 8530 和 8531 端口的流量。</p><p>检查 SoftwareDistribution.log 日志和进程活动（如 w3wp.exe 衍生 cmd.exe），排查入侵迹象。</p><p>配置 ADAudit Plus 告警，检测 WSUS 是否遭入侵，确认服务器是否已受影响。</p><p>接下来，我们将详细解析该 WSUS 漏洞的工作原理、无需原生工具即可快速排查 WSUS 入侵的方法，以及如何通过 卓豪 ADAudit Plus 实时检测 CVE-2025-59287（RCE 漏洞）。</p><h2>漏洞为何引发关注？</h2><p>2025 年 10 月 23 日，微软意外发布紧急更新，修复了编号为 CVE-2025-59287 的严重 WSUS 漏洞。该远程代码执行（RCE）漏洞已被用于活跃攻击，威胁 actors 可完全控制未打补丁的 WSUS 服务器。</p><h2>什么是 WSUS？</h2><p>Windows 服务器更新服务（WSUS）是微软推出的一款工具，帮助企业在内部网络中集中下载、管理和部署 Windows 设备的更新程序。</p><p>单台 WSUS 服务器可管理 10 万台客户端设备，使其成为企业安全环境中的高价值目标（来源参考）。</p><p>由于 WSUS 拥有高级权限，且控制着众多系统的软件更新，遭入侵的 WSUS 服务器会成为攻击者的强力入口，助力其在网络中横向移动或获取更高权限。</p><h2>CVE-2025-59287 的严重程度如何？</h2><p>CVE-2025-59287 是 WSUS 中的严重漏洞，攻击者无需登录即可远程在服务器上执行命令。</p><p>该漏洞源于 WSUS 处理特定更新请求的方式，攻击者可利用这一缺陷，诱骗服务器执行自身代码并获取完整系统权限。一旦成功利用，攻击者可以 SYSTEM 权限执行任意代码，完全控制 WSUS 服务器，进而实施数据窃取、持久化驻留和网络横向移动。</p><h2>CVE-2025-59287 利用时间线</h2><p>2025 年 10 月 14 日：微软首次披露 CVE-2025-59287，并在 10 月 “补丁星期二” 中发布修复补丁，但该补丁并不完整。<br/>↓<br/>2025 年 10 月 23 日：微软针对 CVE-2025-59287（WSUS 远程代码执行漏洞）发布紧急补丁，安装后需重启服务器。<br/>↓<br/>2025 年 10 月 23 日：全球网络安全公司 Huntress 观察到针对暴露在 8530 和 8531 端口的 WSUS 服务器的早期利用行为。<br/>↓<br/>2025 年 10 月 24 日：荷兰国家网络安全中心确认漏洞存在活跃利用；Eye Security 报告发现一个.NET 载荷正在执行系统命令。<br/>↓<br/>2025 年 10 月 24 日：公开的漏洞利用概念验证（PoC）代码及分析报告发布，加速了漏洞武器化进程。<br/>↓<br/>2025 年 10 月 27 日：安全厂商指出攻击已呈规模化；美国网络安全与基础设施安全局（CISA）将该漏洞纳入已知被利用漏洞（KEV）目录，设定 11 月 14 日为修复截止日期。</p><h2>利用原生方法检测 WSUS 入侵</h2><p>在 WSUS 服务器的 SoftwareDistribution.log 日志中，查找以下关键入侵指标：</p><p>攻击后日志中常出现的错误</p><p>SoapUtilities.CreateException ThrowException: actor = https://&lt;主机名&gt;:8531/ClientWebService/client.asmx</p><p>触发攻击的恶意请求中特有的文本模式</p><p>AAEAAAD/////AQAAAAAAAAAEAQAAAH9</p><p>攻击者 IP 地址</p><p>检查 WSUS 服务器是否收到来自该地址的流量：207.180.254 [.] 242</p><p>攻击中使用的恶意程序文件哈希</p><p>若服务器上出现该哈希值，可能已遭入侵：ac7351b617f85863905ba8a30e46a112a9083f4d388fd708ccfe6ed33b5cf91d</p><p>审查进程日志中的可疑活动</p><p>如 w3wp.exe 或 wsusservice.exe 启动 cmd.exe 或 powershell.exe，可能表明漏洞已被成功利用。</p><h2>借助 ADAudit Plus 一键排查 WSUS 入侵</h2><p>无需原生工具或手动搜索日志，快速验证 WSUS 服务器是否遭入侵。</p><ol><li>打开 ADAudit Plus 控制台。</li><li>进入 “服务器审核” 选项卡。</li><li>在 “进程追踪” 下，选择 “新建进程创建” 报告。</li><li>点击 “高级搜索”，设置以下筛选条件：</li></ol><p>父进程名称 → 结尾为 → wsusservice.exe，或</p><p>父进程名称 → 结尾为 → w3wp.exe</p><ol start="5"><li>点击 “搜索”。</li></ol><p>若发现 wsusservice.exe 或 w3wp.exe 衍生出可疑子进程（如 powershell.exe 或 cmd.exe），则强烈表明 CVE-2025-59287 可能已被利用。</p><h2>防御 CVE-2025-59287，保护 WSUS 环境</h2><p>为防范 CVE-2025-59287 及其他类似漏洞，可采取以下措施：</p><p><strong>立即安装微软安全更新</strong></p><p>微软已发布专门的紧急补丁修复该漏洞。请在所有运行 WSUS 角色的服务器上应用此更新，并重启服务器完成安装。如需详细信息，点击此处。</p><p><strong>限制 WSUS 服务器访问权限</strong></p><p>仅允许可信管理主机或内部更新客户端连接。如有可能，将 WSUS 服务器部署在防火墙后方，或通过网络分段限制入站连接。</p><p><strong>关闭或监控 WSUS 端口（8530 和 8531）</strong></p><p>若 WSUS 必须保持可访问状态，需限制或密切监控这些端口的流量，警惕扫描或漏洞利用尝试。</p><p><strong>审查 WSUS 权限设置</strong></p><p>确保仅管理员可访问 WSUS 管理控制台和更新审批设置，防止滥用。</p><p><strong>利用入侵指标强化 SIEM 和 EDR 检测能力</strong></p><p>将这些入侵指标（IoCs）集成到 SIEM 和 EDR 平台中，实现持续监控和告警。</p><h2>实时监控 CVE-2025-59287：通过 ADAudit Plus 配置自定义告警捕获 WSUS 漏洞利用尝试</h2><p>以下将介绍如何在 ADAudit Plus 中创建自定义告警，监控 WSUS 服务器上的异常进程创建活动。</p><ol><li>进入 “配置” 选项卡，点击 “新建告警配置文件” 开始操作。</li><li>为告警命名，如需可添加描述。</li><li>根据企业风险标准，设置所需的严重级别。</li><li>在 “类别” 中选择 “全部”，然后选择名为 “Sysmon 审计” 的报表配置文件。</li><li>在 “高级配置” 中，勾选 “筛选器” 复选框，点击 “添加筛选条件”。</li><li>设置筛选条件如下：</li></ol><p>父进程镜像 → 结尾为 → wsusservice.exe，或</p><p>父进程镜像 → 结尾为 → w3wp.exe，且</p><p>父进程命令行 → 包含 → wsuspool，且</p><p>进程名称 → 结尾为 → cmd.exe;powershell.exe</p><ol start="7"><li>点击 “更改模式”，将条件模式设置为：(1 或 (2 且 3 且 4))。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436123" alt="图片" title="图片"/></p><p>告警配置完成后，任何匹配筛选条件的进程活动都会触发告警，可在 “告警” 选项卡中查看。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047354153" alt="图片" title="图片" loading="lazy"/></p><p>如需详细信息（包括更改执行者、执行时间和来源），可进入 “Active Directory” 选项卡 &gt; “Sysmon 审计”。这有助于验证活动是否来自合法来源，是否符合企业安全策略。</p><h2>关于 ManageEngine <a href="https://link.segmentfault.com/?enc=b%2B5KN6ZONkHn8vT0qvb0TA%3D%3D.yGOf9JtnBnolCYBjnpRNN%2BdtDKVngjgK9tNxtH4c5rYINmzoiRyyShPLfP4baae7AIIjVBvC1iuU19%2F%2F08qg2Q7O0vUKV8Gx9a5qyMBzGWvsK2ByeLMosR01iYLbyCo%2FzUVT92TX1PJQAr2UV891ZQ%3D%3D" rel="nofollow" target="_blank">ADAudit Plus</a></h2><p>ManageEngine ADAudit Plus 是一款基于用户行为分析（UBA）驱动的变更审计解决方案，可覆盖你的 Active Directory（AD）、文件服务器、Windows 服务器及工作站，确保责任追溯、安全性与合规性。</p>]]></description></item><item>    <title><![CDATA[MindDock 正式内测！让所有 AI]]></title>    <link>https://segmentfault.com/a/1190000047436142</link>    <guid>https://segmentfault.com/a/1190000047436142</guid>    <pubDate>2025-11-28 16:12:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436144" alt="logo动态.jpg" title="logo动态.jpg"/></p><blockquote>MemOS-MindDock 内测正式开启！</blockquote><p>每次换平台、开新对话，都得重新介绍自己？想让 ChatGPT、Gemini、DeepSeek 都能持续理解你？从今天起，你的 AI 将真正「拥有记忆」。</p><hr/><h2>🎥 一段视频，带你认识全新的 AI 体验</h2><p>还在为 AI 的「健忘」而苦恼？<br/>现在，所有平台的 AI 都能共享相同的记忆。<br/>点击下方视频，了解 MemOS-MindDock 是如何定义「AI 连续性体验」。</p><h2><a href="https://www.bilibili.com/video/BV1zhS5BwE7i/?page=1" target="_blank">https://www.bilibili.com/video/BV1zhS5BwE7i/?page=1</a></h2><h2>🚀 什么是 MemOS-MindDock？</h2><p>MemOS-MindDock 是一款 跨平台 AI 统一记忆管理助手，<br/>它在不同 AI 之间，构建了你的“个人记忆”——<br/>让任何 AI 都能记得你喜欢滑雪，明天要去游泳。</p><p>一句话概括：</p><blockquote>💡 让所有 AI 都真正记得你。</blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436145" alt="1.png" title="1.png" loading="lazy"/></p><hr/><h2>🧩 为什么你需要它？</h2><p>想象一下：<br/>我刚在 ChatGPT 上写下旅行计划，<br/>又去 Gemini 查机票，<br/>最后到 DeepSeek 继续优化路线。</p><p>换了三个 AI，却丢了所有上下文。<br/>每次切换都需要和它们从头再来。</p><p>MemOS-MindDock 助你改变一切。</p><p>让你的记忆、偏好、身份信息在不同 AI 之间保持连续，并能自动同步。<br/>从此，所有的平台都将真正「记得你」，不再丢线。</p><hr/><h2>✨ 功能亮点一览</h2><h3>1. 一键迁移你的 AI 历史记忆</h3><p>支持 ChatGPT、Gemini、千问、DeepSeek 等主流平台。<br/>自动提取历史对话与偏好信息，帮你构建一个统一记忆库。</p><blockquote>不再被平台束缚，你的记忆由你做主！</blockquote><hr/><h3>2. 实时记忆注入，让 AI 秒懂你</h3><p>在任意平台上开启新对话时，<br/>MemOS 会在后台自动补全你的偏好、计划与背景。</p><blockquote>无需重复，AI 永远记得“你是你”～</blockquote><hr/><h3>3. 你的外置大脑，越用越聪明</h3><p>每次对话中产生的新信息，<br/>都会被自动提取并加入你的长期记忆库。</p><blockquote>越聊越懂你，让 AI 真正成为你的智能伙伴 💪</blockquote><hr/><h2>🌟 加入内测，共建「有记忆的 AI 时代」</h2><p>AI 的下一个阶段，不只是智能，而是理解与延续。<br/>MemOS-MindDock 让 ChatGPT、Gemini、DeepSeek、千问 等 AI 真正协同，<br/>形成一个围绕“你”的智能体系。</p><p>现在就加入加入社群，获得内测安装包！<br/>成为让 AI 拥有「连续记忆」的第一批体验者。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436146" alt="2.png" title="2.png" loading="lazy"/></p><h2>📅 正式上线</h2><p>MemOS 计划于 2025 年 12 月 5 日<br/>在 Chrome 插件商店 正式发布 MemOS-MindDock 插件！</p><p>由于 Chrome 官方审核流程存在一定不可控因素，<br/>实际上架时间可能会略有调整，内测用户将在第一时间收到正式版更新通知\~</p><hr/><h2>📩 联系与反馈</h2><p>若你在体验过程中有建议或问题，欢迎通过内测群反馈。<br/>我们期待与你一起，让 AI 真正拥有「记忆」。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436147" alt="logo动态.jpg" title="logo动态.jpg" loading="lazy"/></p><p>关于 MemOS</p><p>MemOS 为 AGI 构建统一的记忆管理平台，让智能系统如大脑般拥有灵活、可迁移、可共享的长期记忆和即时记忆。</p><p>作为记忆张量首次提出“记忆调度”架构的 AI 记忆操作系统，我们希望通过 MemOS 全面重构模型记忆资源的生命周期管理，为智能系统提供高效且灵活的记忆管理能力。</p><p>​</p>]]></description></item><item>    <title><![CDATA[AI Glasses 实践应用：打造“灵]]></title>    <link>https://segmentfault.com/a/1190000047436153</link>    <guid>https://segmentfault.com/a/1190000047436153</guid>    <pubDate>2025-11-28 16:11:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>AI Glasses 实践应用：打造“灵犀”实时谈判辅助系统 (Smart Negotiator)</h2><blockquote><strong>摘要</strong>：本文关注如何利用 Rokid SDK 与 LLM（大语言模型）构建一款真正的 AI 生产力工具。我们将开发一款名为“灵犀”的 APP，它采用“手机计算 + 眼镜显示”的架构，在商务谈判、面试或演讲场景中，实时分析对话内容，并通过 AR 眼镜为用户提供“上帝视角”的即时辅助。</blockquote><h3>一、 实践应用思路</h3><h4>1.1 应用场景痛点</h4><p>在商务谈判、技术面试或公开演讲中，人们常面临：</p><ul><li><strong>信息遗忘</strong>：忘记关键数据或案例。</li><li><strong>反应滞后</strong>：对方提出刁钻问题，无法立即组织高情商回答。</li><li><strong>情绪紧张</strong>：导致逻辑混乱。</li></ul><h4>1.2 解决方案：“灵犀”辅助系统</h4><p>这是一个基于 <strong>Android (手机端) + Rokid Glass (显示端)</strong> 的双端应用。</p><ul><li><strong>听 (Input)</strong>：利用手机或眼镜麦克风实时收音。</li><li><strong>想 (Process)</strong>：手机端运行 AI Agent，进行 STT (语音转文字) 并调用 LLM 分析话术。</li><li><strong>看 (Output)</strong>：在眼镜端（HUD 界面）仅显示<strong>关键词、情感趋势、推荐话术</strong>，而非满屏文字，避免干扰视线。</li></ul><h4>1.3 产品形态图解 (概念)</h4><p>作者做了一个UI来展示处理的过程</p><p><img width="723" height="557" referrerpolicy="no-referrer" src="/img/bVdnctm" alt="image.png" title="image.png"/></p><p>实时语音输入，并且实时在眼镜端上输出<br/><img width="723" height="556" referrerpolicy="no-referrer" src="/img/bVdnctn" alt="image.png" title="image.png" loading="lazy"/></p><h3>二、 AI 工作流 (AI Workflow) 设计</h3><p>为了实现毫秒级的辅助，我们需要设计一个高效的 AI Pipeline。不能简单地把 GPT 的回答扔到眼镜上，那样阅读成本太高。</p><h4>2.1 核心工作流逻辑</h4><ol><li><strong>感知层</strong>：实时音频流 -&gt; VAD (语音活动检测) -&gt; 切片。</li><li><p><strong>认知层</strong>：</p><ul><li><strong>STT 服务</strong>：快速转录为文本。</li><li><strong>Intent Analyzer (意图分析)</strong>：判断对方是在“提问”、“闲聊”还是“质疑”。</li><li><strong>RAG (检索增强)</strong>：如果是事实性问题，从本地知识库（如公司 PDF、个人简历）检索数据。</li></ul></li><li><strong>决策层</strong>：LLM 生成简短的 Prompt 提示。</li><li><strong>表现层</strong>：渲染高对比度 UI 到眼镜 Virtual Display。</li></ol><h4>![](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20251125170559456.png</h4><h3>三、 核心代码实现思路 (Android + Rokid SDK)</h3><p>本部分基于 <strong>Android 原生开发</strong>，利用 Rokid 的多屏显示能力（Presentation API）或 SDK 提供的投屏机制。</p><h4>3.1 架构设计：双屏异显</h4><p>Rokid 眼镜连接手机后，通常被识别为 Android 的第二个显示器（Presentation）。</p><ul><li><strong>主屏幕（手机）</strong>：显示详细日志、设置、录音控制。</li><li><strong>副屏幕（眼镜）</strong>：显示高对比度、大字号的 HUD 界面。</li></ul><h4>3.2 关键代码模块</h4><h5>A. 启动眼镜端 UI (Presentation Service)</h5><p>这是将 UI 投射到眼镜的核心代码。</p><pre><code>// GlassPresentation.kt
import android.app.Presentation
import android.content.Context
import android.os.Bundle
import android.view.Display
import android.widget.TextView

class GlassPresentation(context: Context, display: Display) : Presentation(context, display) {

    private lateinit var suggestionTitle: TextView
    private lateinit var suggestionBody: TextView
    private lateinit var liveCaption: TextView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 加载专门为眼镜设计的深色布局 (HUD风格)
        setContentView(R.layout.layout_glass_hud)

        suggestionTitle = findViewById(R.id.tv_suggestion_title)
        suggestionBody = findViewById(R.id.tv_suggestion_body)
        liveCaption = findViewById(R.id.tv_live_caption)
    }

    // 更新 AI 建议（供外部调用）
    fun updateAiSuggestion(title: String, content: String) {
        suggestionTitle.text = title
        suggestionBody.text = content
    }

    // 更新实时字幕
    fun updateCaption(text: String) {
        liveCaption.text = text
    }
}</code></pre><h5>B. 主逻辑与屏幕路由</h5><p>检测眼镜连接并启动上面的 <code>Presentation</code>。</p><pre><code>// MainActivity.kt (部分逻辑)
import android.media.MediaRouter
import android.view.Display

// ... 在 Activity 中
fun initGlassDisplay() {
    val displayManager = getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
    val displays = displayManager.displays

    // 通常 Display[0] 是手机，Display[1] 是外接眼镜
    if (displays.size &gt; 1) {
        val glassDisplay = displays[1]
        val presentation = GlassPresentation(this, glassDisplay)
        presentation.show()
    }
}</code></pre><h5>C. AI Agent 简易实现 (伪代码)</h5><p>连接 LLM API（如 Gemini/GPT），并使用 System Prompt 强制输出简短内容。</p><pre><code>// AiAssistant.kt
suspend fun analyzeContextAndSuggest(userQuery: String, chatHistory: List&lt;String&gt;): AiResponse {
    
    // 关键：System Prompt 决定了眼镜体验的好坏
    val systemPrompt = """
        你是一个商务谈判助手。
        用户正在进行对话。请根据输入的对话内容，识别对方的意图。
        如果对方提出了挑战性问题，请提供 3 个简短的回复要点。
        
        【输出限制】：
        1. 不要长篇大论，每条建议不超过 10 个字。
        2. 格式为 JSON：{ "intent": "质疑价格", "points": ["强调长期ROI", "对比竞品服务", "提及赠送延保"] }
    """.trimIndent()

    // 调用 LLM 接口 (Retrofit / OkHttp)
    val response = llmService.chatCompletion(
        messages = listOf(
            Message("system", systemPrompt),
            Message("user", userQuery)
        )
    )
    
    return parseJson(response)
}</code></pre><h3>四、 进阶：引入 RAG (知识库)</h3><p>为了让 AI 不仅仅是泛泛而谈，我们需要导入“私有数据”。</p><p><strong>应用思路</strong>：</p><ol><li><strong>预处理</strong>：将产品手册、FAQ 文档转换为向量存储在手机本地 (使用 SQLite VSS 或由 Python 后端处理)。</li><li><p><strong>运行时</strong>：</p><ul><li>当 STT 捕捉到关键词 "续航"、"电池"。</li><li>系统自动检索向量库中关于 "电池参数" 的段落。</li><li>将检索结果喂给 LLM，生成："续航 12 小时，支持快充"。</li><li>眼镜屏幕显示该数据，防止用户背错参数。</li></ul></li></ol><h3>五、 开发注意事项 (Rokid 特性)</h3><ol><li><p><strong>UI 适配</strong>：</p><ul><li>背景必须是<strong>纯黑色 (#000000)</strong>，因为 AR 眼镜的黑色是不发光的，这样才能实现透视效果。</li><li>字体推荐使用绿色或亮青色，在各种背景环境下对比度最高。</li><li>避免在边缘放置关键信息，防止光学畸变导致看不清。</li></ul></li><li><p><strong>交互设计</strong>：</p><ul><li>尽量不要让用户去点击手机屏幕。</li><li>利用<strong>头部姿态 (Head Tracking)</strong>（如果 SDK 支持）：例如“点头”确认记录，“摇头”关闭提示。</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li>手机同时跑 STT、LLM 网络请求和双屏渲染，发热量巨大。建议将 STT 和 LLM 尽量放在云端处理，或者使用端侧小模型 (如 Gemini Nano, MobileBERT)。</li></ul></li></ol><h3>六、 总结</h3><p>通过 Rokid 眼镜的硬件载体，我们将 AI 从“对话框”里解放出来，变成了视野中的“外挂”。这种<strong>Context-Aware (情境感知)</strong> 应用是 AI 眼镜区别于 VR 头显的最大优势。开发者应专注于<strong>“如何在不打扰用户看路的前提下，提供最高密度的价值信息”</strong>。</p>]]></description></item><item>    <title><![CDATA[2025年市政工程管理软件推荐：从选型到]]></title>    <link>https://segmentfault.com/a/1190000047436160</link>    <guid>https://segmentfault.com/a/1190000047436160</guid>    <pubDate>2025-11-28 16:10:20</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着城市化进程加速和新型基础设施建设需求激增,市政工程项目管理正面临着前所未有的复杂性与规模性挑战。传统管理方式已难以应对多项目协同、资源优化配置、全过程监管和实时决策的现代市政工程要求。2025年的市政工程管理领域,数字化转型不再是可选项而是必由之路,智能化管理软件成为提升项目管理效率、降低运营成本、确保工程质量和安全的关键工具。从道路桥梁到地下管网,从海绵城市到智慧路灯,市政工程的复杂性和系统性要求管理者必须借助专业软件构建从规划、设计、施工到运维的全生命周期管理闭环。在这一背景下,市政工程管理软件市场呈现出多元化、专业化、智能化的特点,各类解决方案争奇斗艳。然而,软件选型并非易事,它需要综合考虑市政工程的公共属性、多方参与特点、长周期运营需求以及与政府各部门的协同要求。本文将深入分析2025年市政工程管理软件的发展趋势,推荐几款领先的解决方案,并系统阐述从选型到落地的完整实施路径。</p><p>市政工程管理软件的核心功能需求</p><p>现代市政工程项目管理软件需具备全面专业的功能模块,以应对市政工程特有的管理挑战。基础需求包括工程进度管理,应支持多级计划编制、动态跟踪与预警,并能处理并行作业、交叉施工及季节性施工等复杂情况。同时,资源与成本管理需实现对人力、材料、机械的精细管控,以及对预算、合同、变更和决算的全过程监控。鉴于市政工程多使用公共资金,软件的审计追踪与合规性检查功能也至关重要。</p><p>市政工程管理软件的另一核心需求是实现多方协同与透明监管。由于项目常涉及政府、设计、施工、监理等多类参与方,软件应提供统一协作平台,促进数据共享与流程衔接。质量管理与安全控制模块需符合高标准要求,支持质量检查、整改闭环及安全风险防控。随着技术发展,软件对BIM模型的集成与应用能力日趋重要,而移动端支持、物联网集成、大数据分析与可视化报表等智能化功能也正成为标配。</p><p>红圈工程项目管理系统—更懂工程企业经营的智能解决方案</p><p>红圈工程项目管理系统作为国内领先的市政工程管理软件,基于自有PaaS平台和SaaS应用模式,为工程企业提供涵盖项目资金管理、成本管理、物资管理、招采管理、投标管理、合同管理等多维度的数字化解决方案。该系统专门服务于工程企业,功能聚焦于围绕项目的经营管理,内置行业最佳经营管控体系,为经营者提供决策支持。红圈系统通过线上协同平台提升协同效率,实现项目全生命周期闭环管理,帮助客户实时了解项目整体资金状况是否安全、经营风险是否可控,实时掌握项目的利润是否达预期、过程成本是否合理。</p><p>红圈工程项目管理系统推出了AI系列智能产品,构成了其区别于传统解决方案的差异化特征。包括项目360°AI解读、AI报表助手、AI录单助手、AI企业知识库、AI业务助手、BOSS助理Agent、采购助理Agent等多款智能助手,通过AI大模型技术为企业提供全方位的智能管理支持。项目360°AI解读功能通过整合全维经营指标,一键生成项目全景作战图,大模型深度解读经营风险与应对策略,实现经营决策效率提升10倍。AI报表助手通过大模型秒级解析业务报表,将预设分析策略转化为实时风险洞察,自动定位异常指标并生成改善建议。AI录单助手实现从图像识别到系统录入的秒级闭环,智能提取关键字段、自动回填业务系统,减少90%人工操作。AI企业知识库将分散知识转化为即问即答的能力,员工用自然语言提问,3秒获取精准答案,帮助企业核心经验传承提升3倍。AI业务助手通过大模型实时解析工程管理业务数据,将AI能力深度嵌入工作流,实现从数据洞察到执行的闭环。BOSS助理Agent借助AI大模型推理能力精准挖掘企业数据模型,智能生成经营数据汇报,辅助管理者随时随地洞悉经营状况。采购助理Agent整合多维度供应商数据并通过AI算法智能动态评分,快速筛选优质供应商、实时监测潜在风险。这些AI系列智能产品为市政工程项目管理提供全面、精准的决策支持。</p><p>红圈工程项目管理系统在市政工程领域具有广泛适用性,支持道路工程、管网工程、电力工程、园林工程、公路工程、环保工程、水利水电工程、桥梁工程、隧道工程、给排水工程等多种市政工程类型。系统通过信息采集、图表展示、数据挖掘和风险预警等方式为企业管理者的动态决策提供实时、准确、有效的依据。截至2024年,红圈系统已服务近4000家建筑工程企业,证明了其在工程管理领域的实用性和可靠性。</p><p>微软Project及其生态系统——通用平台的智能化演进</p><p>微软Project作为经典的项目管理软件,在市政工程领域持续发挥重要作用。2025年的微软Project生态系统通过与Azure云服务、Power BI等产品的深度集成,提供了从项目规划到执行的完整解决方案。其优势在于熟悉的操作界面和与其他Office产品的无缝协作,能够有效降低用户的学习成本和采用阻力。</p><p>该软件在市政工程管理中的特色体现在资源优化和进度模拟功能上。它能够基于市政工程特点,处理资源受限下的进度优化问题,并通过"假设分析"功能评估不同方案的影响。近年来,微软还推出了针对市政工程的专业模板,包括道路工程、管网工程等特定场景的管理框架,使其更加贴合市政工程的实际需求。</p><p>广联达市政工程管理软件——深度契合国内标准的解决方案</p><p>广联达市政工程管理软件深度契合国内市政工程的管理特点和业务流程,提供从投资决策到运维的全过程数字化管理平台。该软件的突出优势在于对国内市政工程行业标准和规范的深度融入,能够精准把握中国式项目管理流程的特点,在处理工程签证、变更、结算等典型场景时表现出色。</p><p>软件的另一大亮点是成本控制能力与BIM技术的深度融合。内置符合国内市政定额标准的成本数据库,能够进行精确的预算和成本规划,并实现施工过程中的动态成本控制。同时,软件支持BIM模型的导入和应用,实现了基于三维模型的进度、成本和质量管理,为市政工程项目提供了直观高效的数字孪生管理环境。</p><p>鲁班市政工程管理系统——BIM技术深度融合的专家</p><p>鲁班市政工程管理系统以强大的BIM能力和精细化的成本控制见长,实现了BIM技术与项目管理流程的深度融合。该系统支持从设计到施工、运维的全过程BIM应用,能够有效解决市政工程中常见的图纸理解偏差、管线碰撞等传统难题,显著减少设计变更和返工情况的发生。</p><p>该系统还具备基于BIM模型的量价一体化管理能力,可以自动从BIM模型中提取工程量和造价信息,实现快速准确的预算编制和成本测算。在施工阶段,系统支持基于BIM模型的进度管理、质量安全管理和物资管理,形成了以BIM模型为核心的全方位项目管理平台,特别适用于大型桥梁、隧道、综合管廊等复杂市政工程。</p><p>明源云市政工程管理平台——政府投资项目的专业管理</p><p>明源云市政工程管理平台在政府投资项目和公共工程管理方面具有显著优势,专门针对政府投资项目的管理特点,强化了资金管理、审计追踪和合规性控制等功能。平台能够满足市政工程对公共资金使用和项目透明度的严格要求,提供适应不同层级管理部门的多维度报表和分析看板。</p><p>该平台的特色在于其强大的流程驱动和多角色协同能力,能够将市政工程管理的标准流程固化到系统中,确保项目管理规范有序。同时,平台提供的多方协同机制可以有效连接政府部门、代建单位、施工企业和监理机构,实现信息共享和业务协同,有效解决市政工程中常见的信息孤岛和沟通不畅问题。</p><p>未来展望:智能化市政工程管理的新纪元</p><p>随着数字技术的深度演进,市政工程管理软件正迎来智能化变革的新阶段。在这一发展浪潮中,红圈工程项目管理系统凭借其创新的AI系列智能产品和深厚的行业积累,展现出独特的竞争优势。通过项目360°AI解读、AI报表助手、AI录单助手、AI企业知识库、AI业务助手、BOSS助理Agent、采购助理Agent等智能产品的有机整合,红圈系统为市政工程项目提供了从决策支持到执行落地的全方位数字化解决方案。这些智能功能不仅显著提升了项目管理效率,更通过数据驱动的洞察力帮助企业实现精益化管理,在激烈的市场竞争中赢得先机。</p><p>展望未来,市政工程管理软件的发展将更加注重人工智能技术与行业场景的深度融合。红圈系统通过持续的技术创新和服务优化,已经在这一领域建立了明显的先发优势。其基于PaaS平台的架构设计,既能满足市政工程管理的标准化需求,又具备足够的灵活性以适应不同项目的个性化要求。随着5G、物联网、大数据等新技术的广泛应用,红圈等领先的市政工程管理软件将继续深化智能功能开发,推动项目管理向更加智能化、可视化、协同化的方向发展,为构建智慧城市和新型基础设施体系提供强有力的技术支撑。在这个过程中,选择像红圈这样既懂技术又懂业务的智能化管理平台,将成为市政工程企业提升核心竞争力、实现可持续发展的关键决策。</p>]]></description></item><item>    <title><![CDATA[基于 Rokid CXR-S SDK 的]]></title>    <link>https://segmentfault.com/a/1190000047436199</link>    <guid>https://segmentfault.com/a/1190000047436199</guid>    <pubDate>2025-11-28 16:09:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在内容创作、直播及演讲场景中，“顺畅表达”往往比稿件内容本身更具决定性。传统提词器需要额外屏幕或设备，使用时不仅需要手动控制播放，还容易打断自然表达节奏。随着 Rokid AR 眼镜与 AI 大模型能力的成熟，我们终于可以把“提词器”这一工具沉入眼镜底层，让文本提示随用户视野自然跟随，让演讲体验真正进入免手持、低干扰的时代。<br/>本文基于 Rokid CXR-S SDK 官方提供的提词器场景接口，详细讲解 提词器场景的设计思路、SDK 接口用法、ASR 结合策略以及大量的工程级优化经验，帮助你快速构建一个可用的大模型赋能的智能提词器。</p><blockquote>让用户可以戴着Rokid眼镜直接连接AI大模型，实现智能显示观众或者粉丝提问的参考答案。</blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436201" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><h2>一、场景概述：从“显示文本”到“AI 驱动的智能提示”</h2><p>智能提词器的目标不是简单地把一段文字显示在眼镜里，而是让用户在创作过程中获得：</p><ul><li>免手持可见性：稿件悬浮在视野当中，不需要额外设备</li><li>大模型辅助优化：自动润色、补齐、重写或生成关键词提示</li><li>高稳定交互：眼镜端与服务端的双向状态回调与错误恢复机制</li><li>低打断感体验：自动更新、动态提示、视觉稳定、延迟最小化<br/>相比传统提词器，Rokid 眼镜的优势在于其 CXR 场景系统 本身已支持“提词器场景（WORD_TIPS）”，包括文本发送、布局配置等官方接口，使开发者可以快速接入、扩展或增强功能。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436202" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h2>二、提词器场景控制：官方 SDK 接口一览</h2><p>Rokid CXR-S SDK 已提供 提词器场景接口，核心能力包括：</p><ul><li>打开 / 关闭提词器界面</li><li>发送文本（支持流式发送与分片发送）</li><li>配置字体、行距、显示区域</li><li><p>自动滚动<br/>以下为核心接口及实际工程用法。</p><h3>2.1 打开 / 关闭提词器场景</h3></li></ul><pre><code class="bash">fun openOrCloseWordTips(toOpen: Boolean): ValueUtil.CxrStatus? {
    return CxrApi.getInstance()
        .controlScene(ValueUtil.CxrSceneType.WORD_TIPS, toOpen, null)
}</code></pre><p>返回状态说明：</p><ul><li>REQUEST_SUCCEED：成功</li><li>REQUEST_WAITING：正在处理中（常见于连续重复触发）</li><li>REQUEST_FAILED：失败（需处理异常）</li></ul><h3>2.2 发送提词器文本（官方支持流式）</h3><p>SDK 支持文本流式写入，适合长稿件。</p><pre><code class="bash">private val sendCallback = object : SendStatusCallback {
    override fun onSendSucceed() { Log.d(TAG, "文字发送成功") }
    override fun onSendFailed(e: ValueUtil.CxrSendErrorCode?) { Log.e(TAG, "发送失败: $e") }
}

fun setWordTipsText(text: String, fileName: String): ValueUtil.CxrStatus? {
    return CxrApi.getInstance()
        .sendStream(ValueUtil.CxrStreamType.WORD_TIPS, text.toByteRokidray(), fileName, sendCallback)
}</code></pre><p>SDK 官方机制允许分段发送文本，避免一次性发送大文本导致 UI 延迟。</p><h3>2.3 配置提词器显示参数（字体/行间距/AI 模式/区域）</h3><pre><code class="bash">fun configWordTipsText(
    textSize: Float,
    lineSpace: Float,
    mode: String,  // "normal" 或 "ai"
    x: Int,
    y: Int,
    width: Int,
    height: Int
): ValueUtil.CxrStatus? {
    return CxrApi.getInstance()
        .configWordTipsText(textSize, lineSpace, mode, x, y, width, height)
}</code></pre><h2>三、AI 大模型赋能：SDK + ASR 的联动设计</h2><p>AI 模式核心接口：</p><pre><code class="bash">fun sendWordTipsAsrContent(content: String): ValueUtil.CxrStatus? {
    return CxrApi.getInstance().sendAsrContent(content)
}</code></pre><ol><li>用户语音被 ASR 转写</li><li>ASR 文本发送到眼镜</li><li><p>SDK 在本地根据 ASR 文本与提词器内容匹配：</p><ul><li>匹配到段落末尾</li></ul></li><li><p>若结合大模型，则可：</p><ul><li>对文本做摘要、重写</li><li>提取关键词高亮</li><li>修正口语化表达</li></ul><blockquote>开发者只需传递大模型输出的内容即可。建议对接通义大模型提供API服务<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047436203" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></blockquote><h2>四、实战经验与优化策略</h2><p>以下是开发过程中最核心的工程经验</p><h3>4.1 避免重复触发：状态锁</h3><p>SDK 若连续收到相同指令可能进入 WAITING 状态，因此需要本地状态锁。</p></li></ol><pre><code class="bash">private var isWordTipsOpen = false

fun toggleWordTips(open: Boolean) {
    if (isWordTipsOpen == open) return

    val status = openOrCloseWordTips(open)
    if (status == ValueUtil.CxrStatus.REQUEST_SUCCEED) {
        isWordTipsOpen = open
    }
}</code></pre><p>减少重复请求，可显著降低失败率。</p><h3>4.2 长文本→分段发送（实践中非常关键）</h3><pre><code class="bash">fun sendTextInChunks(text: String, fileName: String, chunkSize: Int = 180) {
    var index = 0
    while (index &lt; text.length) {
        val end = (index + chunkSize).coerceAtMost(text.length)
        setWordTipsText(text.substring(index, end), "$fileName-${index/chunkSize}")
        index += chunkSize
    }
}</code></pre><p>作用：</p><ul><li>避免卡顿</li><li><p>避免 sendStream 回调排队</p><h3>4.3 ASR 触发缓冲</h3><p>语音识别存在延迟，如无缓冲会导致“跳段”。</p></li></ul><pre><code class="bash">private var lastSentAsrIndex = 0

fun sendAsrContentOptimized(asrContent: String) {
    if (asrContent.length &lt;= lastSentAsrIndex + 3) return

    val delta = asrContent.substring(lastSentAsrIndex)
    val status = sendWordTipsAsrContent(delta)
    if (status == ValueUtil.CxrStatus.REQUEST_SUCCEED) {
        lastSentAsrIndex = asrContent.length
    }
}</code></pre><p>保留 3～5 字字符缓冲可非常平滑。</p><h3>4.4 显示参数动态调节：不同用户不同舒适区</h3><pre><code class="bash">fun adjustWordTipsLayout(
    textSize: Float = 28f,
    lineSpace: Float = 1.5f,
    mode: String = "ai",
    x: Int = 40,
    y: Int = 100,
    width: Int = 620,
    height: Int = 420
) {
    configWordTipsText(textSize, lineSpace, mode, x, y, width, height)
}</code></pre><p>提升阅读体验效果极其显著。</p><h3>4.5 全链路稳定性：重试机制（蓝牙/网络波动必备）</h3><pre><code class="bash">fun sendTextWithRetry(text: String, fileName: String, maxRetry: Int = 3) {
    repeat(maxRetry) { i -&gt;
        val status = setWordTipsText(text, fileName)
        if (status == ValueUtil.CxrStatus.REQUEST_SUCCEED) return
        Thread.sleep(150)
    }
    Log.e(TAG, "发送文本最终失败")
}</code></pre><blockquote>Rokid 眼镜使用蓝牙链路，与手机连接时偶发丢包，因此务必使用重试策略。</blockquote><h2>五、典型应用场景：AI 驱动的智能表达辅助</h2><p>提词器场景在 Rokid 眼镜中最大的价值，并不是“把文字显示出来”，而是让 AI 参与到表达过程，在直播、演讲、创作等场景中成为用户的“隐藏助理”。以下从真实使用角度，说明该系统如何提升表达效率。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047436204" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>5.1 直播场景：AI 给出“即时回答参考”</h3><p>在直播中，观众提问往往节奏快、内容杂，主播既要阅读弹幕又要组织语言，非常容易出现延迟或表达混乱。智能提词器让流程变得顺畅：</p><ul><li>观众提问 → 服务端 → 大模型生成参考答案</li><li>答案自动被分段推送到眼镜中</li><li>主播抬眼即可看到“参考答法”<br/>这并不强制主播照念，而是提供一条结构化的表达路径，例如：<br/>AI 提示格式：</li><li>问题重点</li><li>建议回答框架</li><li>可补充的亮点信息<br/>主播保持自然表达，但准确性更高、思路更清晰。</li></ul><h3>5.2 演讲场景：AI 自动生成“下一句提示”</h3><p>演讲稿通常较长，但演讲时真正需要的只是“下一步要讲什么”。结合 ASR 的官方机制，大模型可以自动把长文本转为 简短提示，并在用户讲话时显示：</p><ul><li>AI 自动提炼段落核心</li><li>眼镜中只显示“下一句 / 下一点”</li><li><p>ASR 捕捉用户语音 → 自动推进进度<br/>这让演讲者能与观众保持眼神交流，而不必盯着稿子。整个过程更自然、节奏更平稳。</p><h3>5.3 内容创作录制：AI 实时润色口语表达</h3></li></ul><p>录短视频或口播时，创作者常常需要“说着说着重来”。智能提词器可以帮助生成更自然的表达方式：</p><ul><li>用户初稿 → ASR → AI 自动优化</li><li>AI 输出更简洁、节奏更好的句子</li><li><p>眼镜显示修改后的“最佳口播版本”<br/>创作者可以边看提示边说，大幅减少重拍次数。</p><h3>5.4 对话与会议：AI 给出“应答建议”</h3><p>在商务交流或多方对话中，AI 能根据对方话语生成 应答方向，例如：</p></li><li>对方观点总结</li><li>AI 建议的回复框架</li><li>可补充的数据或观点<br/>用户只需轻扫视野即可掌握下一步的表达逻辑，既不抢话，也不出现空白停顿。<br/>通过将 Rokid 官方提词器场景能力与大模型回答生成结合，提词器从“显示文本”升级为 实时表达辅助系统：</li><li>AI 帮你理解问题</li><li>AI 帮你组织答案</li><li><p>Rokid眼镜帮你无感展示<br/>直播更稳、演讲更顺、拍摄更自然、对话更自信，自此进入 AI 辅助表达的新阶段。</p><h2>六、总结：从工具到智能助理的演进</h2><p>通过 Rokid CXR-S SDK，我们构建了一个真正意义上的 AI 智能提词器系统，包含：</p></li><li>提词器场景控制：场景开关、流式文本发送、布局参数设置</li><li>ASR + 大模型联动：内容纠错、关键词提示</li><li>完整工程能力：分段发送、状态锁、重试机制</li><li>高可扩展性：可进一步接入通义/千问等大模型增强稿件生成体验<br/>最终效果：<br/>✔ 演讲/直播过程无需手动操作<br/> ✔ 文本可随时更新，不会打断视野<br/> ✔ 稳定、低延迟，可用于真实生产环境<br/> ✔ 大模型赋能，可调用大模型能力直接辅助回答观众的问题<br/>整体来看，Rokid眼镜+AI大模型的组合，使提词器从传统辅助工具升级为智能内容提示系统，在演讲、直播、短视频创作等场景中大幅提升用户效率与流畅度。同时，该技术方案具备可扩展性，可结合多模态AI能力实现语音指令控制、情绪提示和实时稿件优化，为未来内容创作提供更智能的辅助工具。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436205" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[工业智能体到底是什么？制造业的“数字员工]]></title>    <link>https://segmentfault.com/a/1190000047436243</link>    <guid>https://segmentfault.com/a/1190000047436243</guid>    <pubDate>2025-11-28 16:08:35</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>工业智能体作为一种新兴的智能制造技术，正在制造业领域迅速发展。它通过多智能体协同架构，实现了从感知、决策到执行的全链路闭环，为制造业的智能化转型提供了全新路径。本文将从工业智能体的定义、核心价值、技术架构、行业应用及发展趋势等方面进行深入探讨。<br/>首先，工业智能体并非简单的自动化工具，而是融合了人工智能与工业知识的综合性解决方案。以广域铭岛的实践为例，其工业智造超级智能体由多个专业智能体组成，能够覆盖企业的全业务场景。这种架构打破了传统工业软件的流程断点，实现了从单点智能到全局优化的跨越。<br/>从核心价值来看，工业智能体显著提升了制造业的运营效率。在电池制造领域，广域铭岛的解决方案通过动态排产优化，帮助某新能源企业将产能利用率提升了18%，废品率降低了22%。在汽车制造领域，排产智能体将传统6小时的排产流程压缩至1小时，仓储智能体则将供应商交付波动率降低了40%，周计划达成率稳定在99%以上。<br/>工业智能体的技术架构是其成功应用的关键。Geega工业AI应用平台作为技术基座，提供了三大核心能力：数据标准化引擎、知识封装工厂和智能体积木库。数据标准化引擎统一了工业数据语言，打破了数据孤岛；知识封装工厂将企业经验转化为可调用的电子字典；智能体积木库则支持零代码快速搭建人工智能专岗。<br/>然而，工业智能体的应用也面临一些挑战。例如，在小样本场景下，模型的泛化能力仍有待提升。此外，工业智能体的开发需要深入的工业场景理解，这对AI团队的技术能力提出了更高要求。因此，选择合适的工业智能体服务商至关重要。<br/>展望未来，工业智能体将向更深层次发展。一方面，技术融合将继续加速，与5G、数字孪生等技术结合，推动"黑灯工厂"的普及。另一方面，生态协同将成为关键，通过开放合作，构建更完善的工业智能化创新生态。广域铭岛等行业领导者正在积极探索这些方向。</p>]]></description></item><item>    <title><![CDATA[极简主义者的PostgreSQL AI指]]></title>    <link>https://segmentfault.com/a/1190000047436253</link>    <guid>https://segmentfault.com/a/1190000047436253</guid>    <pubDate>2025-11-28 16:07:49</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>本文整理自 IvorySQL 2025 生态大会暨 PostgreSQL 高峰论坛的演讲分享，演讲嘉宾：Florents Tselai。</blockquote><h2>引言</h2><p>从 SQL 到 AI，从数据库操作到大模型推理，技术在不断进化。本文将探讨如何在保持稳定性的前提下，利用 SQL 与 AI 接口实现高效、可靠的数据处理。</p><h2>关于作者</h2><p>Florents Tselai 拥有数据分析与数据工程背景，早年就读于商学院，随后逐步转向数据工程领域，专注于 PostgreSQL 扩展开发与 AI 数据处理。</p><p>曾为欧洲及美国多家企业提供数据咨询服务，目前担任 希腊政府 AI 孵化计划的技术顾问。其研究方向涵盖 PostgreSQL 可扩展性、ETL 工具设计与 AI 数据接口优化。</p><p>代表作品：</p><ul><li>PostgreSQL 扩展</li><li>统计类：pgxicor, vasco</li><li>ETL 工具：pgPDE, pgJQ</li></ul><p>创新项目：</p><ul><li>spat：让 PostgreSQL 像 Redis 一样使用共享内存的高性能存储扩展</li><li>pghaicker：基于 AI 的 pgsql-hackers 邮件摘要工具</li></ul><h2>背景：从复杂中回归极简</h2><p>极简主义 = 经验 + 麻烦。</p><p>复杂的运维流程与多系统环境常使开发过程面临协作障碍与效率损耗。长期的项目实践与问题积累，逐渐催生出一种“极简主义”技术理念——在复杂中求简，以最少且最可靠的工具应对最多的场景。</p><p>SQL、Bash 与 Python 成为跨环境开发的核心支撑，体现了高稳定性、高效率与强可移植性的技术哲学。</p><h2>接口的演进：从 SQL 到 AI</h2><p>在软件开发与数据分析中，接口（Interface）是核心概念。</p><h3>SQL：可靠的数据接口</h3><p>SQL 是数据操作中最稳定、最可靠的核心工具，自 1970 年代以来，它通过标准化方式将人类需求转化为数据库执行计划，实现从查询到报表的完整流程。</p><p>SQL 的接口特性：</p><ul><li>描述“想要什么”，而非“如何实现”。</li><li>数据表提供直观可视化表示。</li><li>标准化操作（尽力而为）。</li><li>从查询到报表完整流程。</li><li>隐藏底层复杂性。</li><li>EXPLAIN PLAN 提供有限洞察。</li></ul><h3>AI：自然语言与推理的新接口</h3><p>AI 接口是 SQL 接口理念的延伸与升级。与 SQL 类似，AI 将人类意图转化为可执行操作，但能够理解自然语言，进一步降低操作门槛。</p><p>AI 的接口特性：</p><ul><li>理解自然语言描述：可生成查询或执行计划，实现直观的人机交互。</li><li>执行与智能推理：除了生成执行计划，还可处理复杂数据和逻辑推理。</li><li>延续 SQL 接口哲学：只需描述需求，系统负责实现，但方式更自然、更智能。</li></ul><p>从 SQL 到 AI，这一演进体现了接口的核心理念：让人类与系统交互更直观、高效，同时隐藏底层复杂性。AI 接口不仅延伸了 SQL 的能力，也为未来的数据分析与应用开发提供了新的可能。</p><h3>核心转变：从执行计划到推理计划</h3><p>在高级用户操作 AI 的实践中，可以观察到执行计划与推理计划的一一对应关系。用户通过一个提示词得到结果，再将结果组合或优化，这本质上是在编排推理逻辑，而不仅是执行操作。这些结果可以作为缓冲或中间状态，实现更高效的任务管理。</p><h2>现状批判：LLM 框架的陷阱</h2><h3>复杂的生态与过度抽象</h3><ul><li>对普通用户而言，AI 操作像魔法，简化了复杂任务。</li><li>对数据工程师或开发者而言，部署和操作仍然复杂，需要理解系统底层逻辑。</li></ul><p>这一差异反映了用户体验的便利性与开发者实际操作复杂性之间的落差。</p><p>当前大模型生态尚未稳定，技术迭代速度过快，主要表现为：</p><ul><li>行业仍缺乏统一标准与稳定范式。</li><li>经验方法更新频率高，难以长期复用。</li><li>HOW-TO 类资料常因工具与版本更新而被替代。</li><li>各模型都声称性能领先，但实际效果依赖具体场景。</li><li>不同 LLM 框架试图定义自己的标准路径，却往往引入更高的复杂度和学习成本。</li></ul><h3>历史的押韵：LLM Frameworks = ORMs</h3><p>LLM 框架类似 80 年代的 ORM（对象关系映射）：</p><ul><li>ORM 虽提供了 SQL 的抽象封装，但底层执行原理仍需掌握。</li><li>LLM 框架提供抽象化接口，但早期依赖可能掩盖底层逻辑。</li><li>当前框架过度封装、复杂化流程，使开发者容易迷失。</li></ul><p>LLM 框架虽便利，但存在显著问题：</p><ul><li>过度自信与复杂化 —— 框架自认为万能，却增加不必要的复杂性；</li><li>死板抽象 —— 多层封装让问题难以理解；</li><li>Java 式设计泛化 —— 流程被强制框架化，增加学习成本；</li><li>“想要香蕉？先建宇宙” —— 为完成简单任务，需要经历冗长复杂步骤；</li><li>强制流程 —— 框架规定操作步骤，限制灵活性；</li><li>阻碍学习 —— 用户依赖框架而非理解底层逻辑；</li><li>产生挫败感 —— 框架让用户觉得无法掌控，体验不佳。</li></ul><p>整体结论：LLM 框架目前仍是辅助工具，开发者不应盲目依赖，应理解底层原理并培养核心技能。</p><h3>SQL 依然是最稳定的答案</h3><p>面对快速发展的 AI 技术生态，开发者常常需要寻找稳定可靠的解决方案。尽管出现了各种新兴工具和框架，SQL 依然被证明是数据访问和处理的核心接口。</p><p>SQL 自诞生以来数十年，始终保持其核心价值。尽管有人宣称 SQL 已过时，每隔十年总有新论断出现，但 SQL 的基础地位从未动摇，其声明式语法和标准化特性使其在复杂系统中长期可靠。</p><p>SQL 不仅仅是查询语言，更可以视作系统的编排者。在处理复杂数据流程时，SQL 能将不同任务和操作整合为清晰的执行计划，从而简化系统协调和资源管理的复杂性。</p><p>在 AI 应用中，模型的推理流程与 SQL 的执行计划存在对应关系。通过 SQL 的结构化操作，可以对 AI 推理过程进行有效映射与管理，使数据处理和推理逻辑保持一致性。</p><h2>回归本质：AI 即相似度搜索</h2><p>当前大模型（LLM）及各类 AI 应用，从底层机制来看，核心都可以归结为“相似度搜索”。其基本流程是：</p><ol><li>将输入文本切分成 tokens；</li><li>通过向量化模型生成向量表达；</li><li>存储的数据向量进行相似度比对，</li><li>最终根据得分返回结果。</li></ol><p>这一过程并不神秘，模型能力的差异主要取决于数据规模与训练质量。</p><p>在实际应用中，系统会在数据库内存储多种信息片段，并不断围绕“向量—相似度—检索”循环工作。从业务角度看，AI 的执行流程更像是“声明—比对—迭代”的模式：给定输入，不断检索最接近语义结果，再多轮迭代优化。</p><h3>核心机制</h3><p>当前 AI 技术生态中最常见的术语如 tokens、vectors、documents，均围绕相似度检索机制展开。</p><ul><li>tokens：文本最小单元</li><li>vectors：语义向量表示</li><li>documents：文档或数据片段</li></ul><h3>Postgres 早已具备的能力</h3><p>尽管今天的向量检索听起来前沿，但对于数据库从业者而言，这一思想并非全新。PostgreSQL 在十余年前就已经通过全文检索（Full Text Search）实现了类似能力。例如：</p><pre><code>SELECT 'a fat cat sat on a mat'::tsvector @@ 'cat &amp; rat'::tsquery;</code></pre><p>全文检索的流程同样依赖文本分词、构建词典、生成向量化表示，并在查询时根据词项匹配进行判定。不同之处仅在于：</p><ul><li>过去依赖的是本地语料构建的词典与向量；</li><li>现在依托的是规模更大的语言模型语料与向量空间。</li></ul><p>从技术原理上看，这两者在语义表达与匹配流程上的一致性非常明显。因此，LLM 并不是完全改变数据库世界的“新物种”，而是将“相似度检索”做到规模更大、语义更丰富、泛化能力更强。</p><h2>AI 实战：上下文即一切</h2><h3>多层封装的体系结构</h3><p>现代 AI 应用普遍构建在大模型框架之上，外层工具与平台不断叠加新的包装与接口，形成“套娃式”的技术结构。绝大多数产品并非从零实现，而是围绕底层模型进行 API 封装、功能抽象与产品化组合。</p><h3>底层核心：llama.cpp</h3><p>在这些封装层的最底部，llama.cpp 等核心实现承担模型推理的基础执行职责。其高性能、轻量化与良好兼容性，使其成为大量应用的实际运行基础。围绕相关代码库，社区生态与开源许可问题也构成技术讨论的重点。</p><h3>上下文的重要性</h3><p>在实际使用中，影响模型效果的关键因素依然是上下文处理能力。上下文长度决定了模型能够加载的数据量，也直接影响推理结果的完整性与连续性。在早期上下文窗口有限的阶段，复杂的数据裁剪与拼接流程不可避免；而随着上下文上限不断提升，数据组织方式与调用策略也随之调整。</p><h3>构建提示词 = 数据连接的艺术</h3><p>在大模型应用中，上下文构建已成为决定模型效果的核心环节。模型能够输出高质量结果的前提，是输入数据经过精确筛选、裁剪与组织。实际业务中，这一过程本质上是数据 Join 的组合工程。</p><p>在客户服务、电商等常见场景中，约 80% 的工作是从数据库中挑选关键字段，包括商品描述、用户属性、业务要点等，并剔除无关内容。通过将这些信息压缩为清晰的文本表示后，即可形成模型的输入上下文。该过程强调数据组织能力，而非复杂算法。</p><h3>基于字符串的模板化构建方式</h3><p>上下文的构建主要依赖字符串拼接与模板化处理。SQL 的格式化函数、标准的字符串模板引擎等工具即可完成大部分处理需求。相比构建复杂脚本或 Notebook 环境，这种方式更直接、更高效，并满足绝大多数生产实践场景。</p><h3>将复杂度交给模型处理</h3><p>在设计提示词或业务流时，不必在应用层堆叠大量逻辑判断或格式规约。大模型具备强大的推理与补全能力，适合承担复杂推断工作。应用层应主要聚焦于准备精简、准确的输入数据，将复杂度交由模型处理，从而提升系统整体效率与可维护性。</p><h2>Everything in PostgreSQL：减少链路</h2><p>通过 PostgreSQL 的扩展生态，可以将多种形态的数据处理直接集成到数据库内部，从而减少跨系统的数据搬运、降低额外的同步压力，并提升整体系统稳定性。</p><h3>解析 PDF：非结构化数据提取</h3><p>借助 pgPDF 扩展，PostgreSQL 能够直接读取本地或远端 PDF 文件并将其解析为文本。示例如下：</p><p><a href="https://link.segmentfault.com/?enc=ZMC5jVOQpCmwNujI5fxdlQ%3D%3D.zIP32IR3MZ8hBxv1B%2BlOTGfh8%2F%2Fckjh27%2FK1cF8wXsJxPyMRmB4s7snAVaOnmj8%2B" rel="nofollow" target="_blank">github.com/Florents-Tselai/pgPDF</a></p><pre><code>CREATE EXTENSION pgpdf;

SELECT '/path/to/my.pdf'::pdf;</code></pre><h3>执行 HTTP 请求：获取外部数据</h3><p>利用 http 扩展，可以在 PostgreSQL 内直接发起 API 请求，例如：</p><pre><code>CREATE EXTENSION http;

SELECT http_post('http://myprovider');</code></pre><p>这一能力使数据库能够直接完成部分外部数据的获取流程，从而减少应用端的多次 I/O 往返，降低数据链路的复杂性。需要注意的是，HTTP 请求存在阻塞和失败的可能，因此更适合在非核心业务节点或离线库中使用。</p><p>将文本解析、外部 API 请求等操作整合到数据库内部，可以减少：</p><ul><li>数据在系统间传输带来的延迟</li><li>应用层的额外逻辑与依赖</li><li>由于链路增长导致的失败点</li></ul><p>从而提升整个数据链路的可靠性与可维护性。</p><h2>Unix 哲学在现代数据处理中的价值</h2><h3>Unix Philosophy</h3><p>Unix 哲学强调以最小单元构建工具，通过清晰的接口协同完成复杂任务。这一思想在当下依然具有实践意义，特别是在数据密集型场景中。</p><h3>“Do One Thing Well” 与文本接口</h3><p>Unix 哲学的核心原则包括：</p><ul><li>工具专注于单一功能</li><li>文本作为通用接口</li></ul><p>在 LLM 与数据库协作的场景中，文本仍然是最稳定、最易组合的接口形式。这也使得传统工具链在新的技术背景下依然适用。</p><h3>管道化的工具组合</h3><p>遵循 Unix 的方式，小工具之间通过管道组合，能够以极低的复杂度完成高效的数据处理流程。</p><h3>常见工具组合方式</h3><p>在实际工程中，以下工具链可以覆盖大量数据拉取、处理与写入场景：</p><ul><li>curl：用于获取本地或远程 API 数据</li><li>jq：处理 JSON 结构</li><li>xargs（含并行执行）：用于批量或并行处理</li><li>psql：直接与 PostgreSQL 交互</li></ul><p>这些工具组合后，可以在极少代码量的前提下实现高效的流水线式处理。</p><h3>示例：真实项目示例</h3><p>以下示例来自实际项目，通过 Makefile 驱动整套数据处理流程：</p><ol><li>生成时间区间；</li><li>拉取与分组数据；</li><li>构建 JSON 数据；</li><li>向量化处理（如使用某 embedding 模型）；</li><li>将结果写回 PostgreSQL。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436255" alt="1.jpg" title="1.jpg"/></p><p>整个流程以 JSON 作为中间格式，以 PostgreSQL 作为状态与结果的统一存储，避免了额外的数据搬移与逻辑分散。</p><h3>示例：命令行操作 PostgreSQL 实现数据流水线</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436256" alt="2.jpg" title="2.jpg" loading="lazy"/></p><p>在实际项目中，通过命令行工具直接操作 PostgreSQL，实现数据处理自动化：</p><ol><li>使用 % 通配符灵活查询数据。</li><li>本地 LLM 对数据进行处理，如生成每日聚合结果。</li><li>为每一天生成独立 PostgreSQL 数据库，将结果写入数据库。</li><li>利用命令行管道直接写回数据库，实现数据流闭环，无需额外搬移。</li></ol><h3>示例：LLM 结合的处理逻辑</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436257" alt="3.jpg" title="3.jpg" loading="lazy"/></p><p>本地 LLM 对文本、集合或结构化数据进行处理和聚合，生成有用信息并向量化，结果直接写入 PostgreSQL。利用数据库索引和聚合能力完成优化，实现从数据处理到存储的自动化闭环。</p><h2>结语</h2><p>SQL 与 AI 的结合展示了简化复杂、提升效率的价值。理解底层原理并合理运用工具，才能在快速变化的技术生态中保持掌控与高效。</p>]]></description></item><item>    <title><![CDATA[CRM/ERP数字化整合，深化订单关联的]]></title>    <link>https://segmentfault.com/a/1190000047436269</link>    <guid>https://segmentfault.com/a/1190000047436269</guid>    <pubDate>2025-11-28 16:07:04</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>五大CRM/ERP品牌核心能力横评：从全场景整合到增长闭环的深度对比</h2><p>在数字化转型进入深水区的今天，企业对“从获客到售后的全链路打通”“订单与供应链的实时协同”“数据驱动的可持续增长”的需求愈发迫切。本文选取<strong>超兔、Salesforce、用友、销售易、</strong> <strong>SAP</strong>五大主流品牌，围绕<strong>覆盖获客到售后全场景的数字化整合</strong>、<strong>深化订单关联的采购/生产/委外协同</strong>、<strong>构建业务增长闭环</strong>三大核心维度展开深度对比，结合功能细节、适用场景与行业案例，为企业选型提供专业参考。</p><h3>一、核心维度与子指标定义</h3><p>为确保对比的客观性与针对性，先明确三大维度的<strong>子指标拆解</strong>（基于企业真实需求优先级排序）：</p><table><thead><tr><th>一级维度</th><th>二级子指标</th><th>说明</th></tr></thead><tbody><tr><td>全场景数字化整合</td><td>获客与线索转化</td><td>多渠道线索抓取、AI归因、转化率提升</td></tr><tr><td> </td><td>客户全生命周期管理</td><td>统一客户视图、行为轨迹沉淀、复购/流失预警</td></tr><tr><td> </td><td>售后协同与体验</td><td>工单跟踪、自助服务、售后数据与前端联动</td></tr><tr><td>订单关联协同</td><td>采购协同</td><td>需求预测、询比价、供应商拆分、三流合一</td></tr><tr><td> </td><td>生产协同</td><td>排程/派工、BOM拆解、进度可视化、质检联动</td></tr><tr><td> </td><td>委外协同</td><td>委外订单生成、进度跟踪、质量管控</td></tr><tr><td>业务增长闭环</td><td>数据驱动决策</td><td>实时看板、多维度分析、异常预警</td></tr><tr><td> </td><td>AI赋能场景化</td><td>智能跟单、自动待办、预测性建议</td></tr><tr><td> </td><td>生态协同与扩展性</td><td>外部系统对接（ERP/WMS/电商）、生态伙伴集成、定制化能力</td></tr></tbody></table><h3>二、全场景数字化整合：从获客到售后的链路效率对比</h3><p>全场景整合的核心是<strong>消除“</strong> <strong>数据孤岛</strong> <strong>”</strong> ，让获客、跟进、履约、售后的数据在同一系统内流通，最终提升客户转化率与复购率。以下是五大品牌的具体表现：</p><h4>1. 子指标对比表</h4><table><thead><tr><th>子指标</th><th>超兔（超兔一体云）</th><th>Salesforce（销售云+服务云）</th><th>用友（YonSuite）</th><th>销售易（Neocrm）</th><th>SAP（CRM+SCM）</th></tr></thead><tbody><tr><td><strong>获客与线索转化</strong></td><td>涵盖百度、巨量引擎等多集客渠道，具备线索一键处理、归属地获取等线索管理功能，还有营销物料与竞品管理，助力高效获客转化。</td><td>Einstein AI预测赢单概率（准确率＞85%）；Agentforce 360自动化数据录入/报表；多渠道（邮件/社交）线索统一归集。</td><td>企微自动标签客户，个性化推送营销内容；营销自动化与订单履约实时联动；案例：消费品企业复购率提升20%。</td><td>智能客户推荐（种子画像归因潜客）；Outlook“Neocrm”加载项，沟通界面直接调取客户数据；公众号行为自动回流客户表。</td><td>多触点（官网/门店/社交）数据整合；Joule AI自动生成需求预测；案例：零售企业通过轨迹分析挽回数亿美元流失客户。</td></tr><tr><td><strong>客户</strong> <strong>全生命周期管理</strong></td><td>客户中心支持个性化配置、全周期客池分类管理与多维度查重，可自动补全客户背景信息，区分数据权限，还能 AI 生成工作流，助力高效管理客户。</td><td>Customer 360统一视图；Tableau可视化分析客户行为；支持“客户健康度”评分。</td><td>客户旅程全数字化（从营销到售后的实时数据追踪）；“齐套展望”预判库存满足度，优化客户承诺。</td><td>客户互动全轨迹沉淀（外勤签到/语音/地理位置）；AI预测决策链关键人（准确率82%），提升赢单率。</td><td>360°客户画像+流失风险预测；售后数据与销售/生产联动，量化售后收入贡献。</td></tr><tr><td><strong>售后协同与体验</strong></td><td>客户通过小程序查询维修进度；工单全流程跟踪（接单→派工→完成）；打通售后与复购（RFM分析客户分类）。</td><td>Service Cloud自助服务 portal；AI智能代理处理常见问题；SLA计费管理。</td><td>小程序自助下单/物流跟踪；售后回访机制与营销自动化联动；医药行业合规管理（临床反馈沉淀）。</td><td>高价值设备全生命周期服务（从销售到维修的全程数据）；医疗行业合规报告一键生成。</td><td>客户门户自助报修；工单与生产/采购联动（如维修配件自动触发采购）；SLA履约率可视化。</td></tr></tbody></table><h4>2. 全场景链路流程图（Mermaid）</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436271" alt="" title=""/></p><pre><code>graph TD
    A[获客] --&gt; B[线索转化] --&gt; C[客户管理] --&gt; D[订单履约] --&gt; E[售后]
    %% 超兔链路
    A --&gt;|超兔| A1[多渠道自动抓取]
    B --&gt;|超兔| B1[AI线索质量评分+跟进建议]
    C --&gt;|超兔| C1[360°视图+复购预警]
    E --&gt;|超兔| E1[小程序进度查询+工单跟踪]
    %% Salesforce链路
    A --&gt;|Salesforce| A2[Einstein AI多渠道归集]
    B --&gt;|Salesforce| B2[赢单概率预测+自动化录入]
    C --&gt;|Salesforce| C2[Customer 360+Tableau分析]
    E --&gt;|Salesforce| E2[Service Cloud自助+SLA管理]
    %% 用友链路
    A --&gt;|用友| A3[企微标签+个性化推送]
    B --&gt;|用友| B3[实时数据干预+营销-履约联动]
    C --&gt;|用友| C3[客户旅程数字化+齐套展望]
    E --&gt;|用友| E3[小程序自助+合规管理]
    %% 销售易链路
    A --&gt;|销售易| A4[智能客户推荐+Outlook集成]
    B --&gt;|销售易| B4[沟通界面调数据+行为回流]
    C --&gt;|销售易| C4[全轨迹沉淀+决策链预测]
    E --&gt;|销售易| E4[设备全生命周期+合规报告]
    %% SAP链路
    A --&gt;|SAP| A5[多触点整合+Joule AI预测]
    B --&gt;|SAP| B5[流失风险预警+需求匹配]
    C --&gt;|SAP| C5[360°画像+售后收入量化]
    E --&gt;|SAP| E5[客户门户+工单-采购联动]</code></pre><h4>3. 核心差异总结</h4><ul><li><strong>超兔</strong>：中小企业友好，侧重“低成本、轻量化”获客转化，AI建议聚焦“复购/跟进”等高频场景，适合家装、五金等工业商贸/生产企业。</li><li><strong>Salesforce</strong>：<strong>生态与AI能力最强</strong>，Einstein AI覆盖“赢单预测/数据自动化”，Customer 360适合中大型企业的跨部门协同，但售后场景需依赖Service Cloud补充。</li><li><strong>用友</strong>：<strong>国内一体化最优</strong>，YonSuite的“营销-订单-售后”实时联动，尤其适合消费品、医药等需要“合规+体验”的行业。</li><li><strong>销售易</strong>：<strong>腾讯生态深度绑定</strong>，Outlook/企微/钉钉集成打破“沟通-数据”孤岛，设备全生命周期服务适合医疗、制造等高价值产品行业。</li><li><strong>SAP</strong>：<strong>全球与复杂场景适配</strong>，多触点数据整合+Joule AI的“预测性决策”，适合跨国集团、零售/制造等需要“全球合规+供应链韧性”的企业。</li></ul><h3>二、订单关联的采购/生产/委外协同：从“订单触发”到“履约闭环”的效率对比</h3><p>订单是企业业务的“中枢”，能否将订单需求<strong>实时传递至采购、生产、委外环节</strong>，直接影响交付周期与成本控制。以下是五大品牌的协同能力对比：</p><h4>1. 子指标对比表</h4><table><thead><tr><th>子指标</th><th>超兔（采购+MES）</th><th>Salesforce（CPQ+Order Management）</th><th>用友（供应链云）</th><th>销售易（ERP/MES对接）</th><th>SAP（SCM+APS）</th></tr></thead><tbody><tr><td><strong>采购协同</strong></td><td>智能计算采购量（多订单缺口整合+库存/在途匹配）；OpenCRM询价比价，自动拆分供应商；案例：多订单采购效率提升50%。</td><td>CPQ（配置报价）自动触发库存检查；与SAP/Oracle ERP实时同步；Procurement Cloud支持供应商管理/合规检查。</td><td>销售订单直接生成采购计划；供应商协同平台（价格维护/到货计划）；“齐套展望”预判库存满足度。</td><td>订单自动触发采购需求；OpenCRM模块实现供应商外联（报价确认/对账）；医疗行业合规数据沉淀。</td><td>多工厂联合采购（稳定价格+动态折扣）；贸易合规检查（黑白名单）；aATP（可用量检查）下单即承诺交期。</td></tr><tr><td><strong>生产协同</strong></td><td>轻量化MES（智能排程/派工+进度甘特图）；BOM拆解物料需求；小组计件报工，质检联动；案例：机械企业生产周期从15天缩至7天。</td><td>订单与生产计划联动需依赖第三方MES；CPQ支持复杂产品配置，但生产进度可视化弱。</td><td>销售订单直接投产，自动生成生产工单；MES集成（工序报工/质量追溯）；“计划引擎”优化排产效率。</td><td>复杂产品CPQ配置；与ERP/MES深度对接，实时监控生产报工/良品率；案例：制造企业订单-生产周期缩短30%。</td><td>APS系统（设备/人员/物料多约束排程）；MES集成实现OEE（设备综合效率）分析；关键件先行策略缩短交付周期。</td></tr><tr><td><strong>委外协同</strong></td><td>RPA对接委外供应商，进度实时跟踪；委外订单与采购/生产联动；适合“部分工序外包”的小微企业。</td><td>委外流程需通过Procurement Cloud或第三方应用；侧重“供应商管理”，进度跟踪弱。</td><td>委外全流程管理（材料出库/检验/结算）；与供应商协同平台联动，实时更新交付进度。</td><td>订单触发委外需求，与ERP/MES对接跟踪进度；医疗行业委外研发合规数据沉淀。</td><td>委外/自制灵活切换；关键件追溯（委外加工质量与生产环节联动）；支持全球委外供应商协同。</td></tr></tbody></table><h4>2. 订单协同时序图（Mermaid：以超兔为例）</h4><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436272" alt="" title="" loading="lazy"/></p><pre><code>sequenceDiagram
    participant 销售 as 销售订单
    participant 系统 as 超兔一体云
    participant 采购 as 采购部门
    participant 生产 as 生产车间
    participant 委外 as 委外供应商

    销售-&gt;&gt;系统: 提交非标定制订单（含BOM清单）
    系统-&gt;&gt;系统: 自动检查库存缺口（库存+在途）
    系统-&gt;&gt;采购: 生成采购计划（多订单整合+智能匹配供应商）
    采购-&gt;&gt;系统: 确认采购单（OpenCRM询价比价）
    系统-&gt;&gt;生产: 生成生产工单（智能排程：倒排+最小班组）
    生产-&gt;&gt;系统: 报工（小组计件+质检结果）
    系统-&gt;&gt;委外: 触发委外订单（部分工序外包）
    委外-&gt;&gt;系统: 实时更新进度（RPA对接）
    系统-&gt;&gt;销售: 反馈订单履约进度（库存/生产/委外）</code></pre><h4>3. 核心差异总结</h4><ul><li><strong>超兔</strong>：<strong>轻量化协同最优</strong>，MES与采购模块“低成本集成”，适合“订单量小、工序简单”的小微生产企业（如机械、五金）。</li><li><strong>Salesforce</strong>：<strong>CPQ能力突出</strong>，但生产/委外需依赖第三方，适合“以销售为核心、生产外包”的企业（如软件、服务）。</li><li><strong>用友</strong>：<strong>国内供应链协同最深</strong>，YonSuite的“销售订单直接投产”+“供应商协同平台”，适合消费品、医药等需要“快反供应链”的企业。</li><li><strong>销售易</strong>：<strong>制造行业适配性强</strong>，ERP/MES深度对接+设备全生命周期服务，适合医疗、制造等高价值产品企业。</li><li><strong>SAP</strong>：<strong>复杂场景王者</strong>，APS+MES+全球供应商协同，适合跨国制造、零售等需要“供应链韧性”的企业，可解决“多工厂排产/全球委外”等难题。</li></ul><h3>三、构建业务增长闭环：从“数据沉淀”到“可持续增长”的能力对比</h3><p>业务增长闭环的核心是<strong>将“数据”转化为“行动”</strong> ，通过AI赋能、生态协同，实现“客户留存→复购→规模扩张”的正向循环。以下是五大品牌的增长能力对比：</p><h4>1. 子指标对比表</h4><table><thead><tr><th>子指标</th><th>超兔（数据+AI）</th><th>Salesforce（Einstein+AppExchange）</th><th>用友（YonSuite+BI）</th><th>销售易（AI+腾讯生态）</th><th>SAP（Joule+IBP）</th></tr></thead><tbody><tr><td><strong>数据驱动决策</strong></td><td>数字卡片/图表自定义；多表聚合分析；单日KPI引擎；案例：企业通过“订单-回款”分析缩短回款周期2天。</td><td>Tableau可视化+Einstein分析；动态报表（销售漏斗/转化率）；支持“假设分析”（如调整价格后的营收预测）。</td><td>实时数据看板；动态供需匹配；从“事后分析”到“事中干预/事前预测”；案例：立高食品库存周转率提升73%。</td><td>ChatBI可视化分析；“Customer Data Cloud”整合全域数据；AI预测客户决策链。</td><td>整合ERP/SCM/CRM数据；Joule AI自动生成“安全库存建议/异常预警”；IBP（集成业务计划）支持全球供应链协同。</td></tr><tr><td><strong>AI赋能场景化</strong></td><td>AI智能体生成跟单待办（如“客户复购周期30天，今日需推送促销”）；AI日报自动生成，辅助反思；案例：销售效率提升3倍。</td><td>Einstein AI覆盖“赢单预测/邮件助手/数据自动化”；Agentforce 360替代80%重复工作；但场景需自定义。</td><td>AI从“事后分析”升级至“事中干预”（如订单履约异常提醒）；营销自动化的“个性化推送”。</td><td>Coze工作流支持多级审批/跨部门协作；AI嵌入客户视图生成跟单建议；“智能邮件助手”提升沟通效率。</td><td>Joule AI实现“需求预测→采购计划→行动”自动化；改善交付达成率（提升20%）、库存周转（降低15%）。</td></tr><tr><td><strong>生态协同与扩展性</strong></td><td>API+RPA对接（电商/国税/ERP）；低成本客制化（三级菜单/审批流）；适合小微企业“逐步数字化”。</td><td>AppExchange生态（超6000款应用）；Lightning低代码平台；支持多语言/多时区/全球合规。</td><td>YonStore云市场；YonSuite一体化（财务/人力/供应链）；开放API对接第三方。</td><td>腾讯生态（企微/腾讯会议/12亿触点）；“三段七级”交付服务（规划/上线/运营）；适合依赖腾讯生态的企业。</td><td>混合云部署；全球合规（GDPR/CCPA）；IBP/MRP支持供应链异常预警；适合跨国集团的“全球运营”。</td></tr></tbody></table><h4>3. 核心差异总结</h4><ul><li><strong>超兔</strong>：<strong>低成本扩展</strong>，API/RPA对接满足小微企业“按需数字化”，AI聚焦“跟单/复购”等高频场景。</li><li><strong>Salesforce</strong>：<strong>生态与AI天花板最高</strong>，AppExchange覆盖几乎所有行业需求，但生产/委外需第三方补充。</li><li><strong>用友</strong>：<strong>国内一体化增长最优</strong>，YonSuite的“财务-供应链-营销”实时联动，适合需要“降本增效”的国内企业。</li><li><strong>销售易</strong>：<strong>腾讯生态协同最深</strong>，沟通-数据-订单的“无界联动”，适合医疗、制造等需要“高价值服务”的企业。</li><li><strong>SAP</strong>：<strong>全球增长韧性最强</strong>，IBP/APS/全球合规支持跨国企业的“规模化扩张”，但成本与复杂度高。</li></ul><h3>三、综合能力雷达图（1-5分，5分为最优）</h3><table><thead><tr><th>维度</th><th>超兔</th><th>Salesforce</th><th>用友</th><th>销售易</th><th>SAP</th><th>说明</th></tr></thead><tbody><tr><td>全场景整合深度</td><td>4</td><td>5</td><td>4.5</td><td>4.5</td><td>5</td><td>Salesforce/SAP覆盖全链路，超兔/用友/销售易侧重垂直场景。</td></tr><tr><td>订单协同复杂度</td><td>3.5</td><td>4</td><td>4.5</td><td>4.5</td><td>5</td><td>SAP的APS/全球协同最强，超兔适合简单生产。</td></tr><tr><td>数据驱动能力</td><td>4</td><td>5</td><td>4.5</td><td>4.5</td><td>5</td><td>Salesforce/SAP的“预测性分析”领先，用友的“实时性”最优。</td></tr><tr><td>AI赋能场景化</td><td>4</td><td>4.5</td><td>4</td><td>4.5</td><td>4.5</td><td>Salesforce的Einstein覆盖广，销售易的Coze更场景化。</td></tr></tbody></table><h3>三、综合能力雷达图（1 - 5分，5分为最优）</h3><table><thead><tr><th>维度</th><th>超兔</th><th>Salesforce</th><th>用友</th><th>销售易</th><th>SAP</th><th>说明</th></tr></thead><tbody><tr><td>全场景整合深度</td><td>4</td><td>5</td><td>4.5</td><td>4.5</td><td>5</td><td>Salesforce/SAP覆盖全链路，超兔/用友/销售易侧重垂直场景。</td></tr><tr><td>订单协同复杂度</td><td>3.5</td><td>4</td><td>4.5</td><td>4.5</td><td>5</td><td>SAP的APS/全球协同最强，超兔适合简单生产。</td></tr><tr><td>数据驱动能力</td><td>4</td><td>5</td><td>4.5</td><td>4.5</td><td>5</td><td>Salesforce/SAP的“预测性分析”领先，用友的“实时性”最优。</td></tr><tr><td>AI赋能场景化</td><td>4</td><td>4.5</td><td>4</td><td>4.5</td><td>4.5</td><td>Salesforce的Einstein覆盖广，销售易的Coze更场景化。</td></tr><tr><td>生态协同丰富度</td><td>3</td><td>5</td><td>4</td><td>4</td><td>5</td><td>Salesforce的AppExchange生态应用超6000款，SAP支持全球合规与供应链协同，生态丰富度高；用友的YonStore云市场及开放对接能力较强；销售易依托腾讯生态有一定优势；超兔以低成本客制化和API、RPA对接为主，生态相对前几者较窄。</td></tr></tbody></table><h3>四、总结</h3><p>通过对超兔、Salesforce、用友、销售易、SAP五大CRM/ERP品牌在覆盖获客到售后全场景的数字化整合、深化订单关联的采购/生产/委外协同、构建业务增长闭环三大核心维度的深度对比，可以看出各品牌都有其独特的优势和适用场景。</p><p>对于小微企业而言，超兔一体云以其低成本、轻量化的特点，在获客转化、订单关联协同以及业务增长闭环构建方面提供了贴合实际需求的解决方案，尤其适合订单量小、工序简单的小微生产企业逐步实现数字化转型。</p><p>Salesforce凭借强大的生态与AI能力，在全场景整合、数据驱动决策等方面表现卓越，但其生产/委外环节需依赖第三方应用，更适合中大型企业的跨部门协同。</p><p>用友在国内市场展现出一体化的优势，YonSuite实现了营销、订单、售后的实时联动，在消费品、医药等行业具有良好的应用效果，能够帮助企业降本增效。</p><p>销售易深度绑定腾讯生态，打破了沟通与数据的孤岛，其设备全生命周期服务和AI赋能场景化在医疗、制造等高价值产品行业具有独特竞争力。</p><p>SAP则凭借其在全球复杂场景的适配能力，以及强大的供应链协同和合规管理能力，成为跨国集团、零售/制造等需要全球运营和供应链韧性企业的首选，但同时也伴随着较高的成本和复杂度。</p><p>企业在进行CRM/ERP系统选型时，应根据自身的规模、业务特点、行业需求以及数字化转型的目标等因素，综合考虑各品牌的核心能力和差异，选择最适合自己的解决方案，以实现业务的高效运营和可持续增长。</p><h3>五、功能详情</h3><h4>Salesforce 相关能力整理</h4><h5><strong>一、覆盖获客到售后全场景的数字化整合能力</strong></h5><p>通过<strong>销售云（Sales Cloud）、服务云（Service Cloud）、营销云（Marketing Cloud）构建客户全生命周期管理体系，覆盖线索培育、商机转化、订单履约、售后服务</strong>全链路：</p><ul><li><strong>AI驱动效能提升</strong>：Einstein AI引擎自动分析客户行为，预测销售赢单概率（准确率超85%），并生成个性化跟进策略；Agentforce 360平台通过AI智能代理自动化<strong>数据录入、报表生成</strong>等重复任务，缩短销售周期30%以上。</li><li><strong>多渠道协同与数据洞察</strong>：支持邮件、社交媒体、实时聊天等全渠道互动，结合Tableau分析云实现数据可视化，为业务决策提供实时洞察；Customer 360平台整合客户数据，构建统一的客户视图。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436273" alt="" title="" loading="lazy"/></p><h5><strong>二、深化订单关联的采购/生产/委外协同能力</strong></h5><p>以订单为核心，联动供应链环节实现数字化协同：</p><ul><li><strong>订单全生命周期管理</strong>：通过CPQ（配置报价）和Order Management模块管理订单流程，自动触发<strong>库存检查、履约跟踪</strong>，并与SAP、Oracle等ERP系统实时同步，形成“订单-库存-采购”闭环。</li><li><strong>采购与委外流程数字化</strong>：借助第三方集成（如Procurement Cloud）支持<strong>采购申请、供应商管理、委外流程</strong>的数字化，确保需求信息高效传递至供应链端。</li><li><strong>链路信息可见性</strong>：打通前端销售与后端供应链数据，提升全链路信息可见性；但原生功能不直接覆盖生产制造流程，需依赖第三方应用补足。</li></ul><h5><strong>三、构建业务增长闭环的能力</strong></h5><p>通过平台化、生态化及数据驱动，实现业务增长的闭环：</p><ul><li><strong>平台化与生态化适配</strong>：低代码Lightning平台支持自定义业务流程；AppExchange生态整合超6000款第三方应用，适配金融、制造、零售等多行业需求。</li><li><strong>全球化与合规支持</strong>：支持多语言、多时区及GDPR/CCPA等合规要求，满足跨国企业跨地域协作需求。</li><li><strong>数据驱动决策</strong>：内置BI工具生成<strong>销售漏斗、转化率</strong>等动态报表，结合AI预测业务趋势，帮助企业优化资源分配，提升客户留存与复购率。</li></ul><h4>SAP相关能力整理</h4><p>基于查询信息，SAP在<strong>获客到售后全场景数字化整合</strong>、<strong>订单关联的采购/生产/委外协同</strong>、<strong>构建业务增长闭环</strong>三大方向的核心能力如下：</p><h5>一、覆盖获客到售后全场景的数字化整合</h5><ol><li><strong>客户全旅程闭环管理</strong>：通过CRM系统实现从线索管理、销售机会转化到订单履约的全链路覆盖；支持自然语言交互（NLP）与360°客户画像，结合客户门户自助报修、工单派发、SLA计费等功能，提升售后响应效率与客户满意度。</li><li><strong>多触点数据驱动决策</strong>：整合官网、门店、社交媒体等多触点客户数据，AI引擎可预测销售转化率与客户流失风险（如零售企业通过实时互动轨迹分析，挽回损失达数亿美元级）。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436274" alt="" title="" loading="lazy"/></p><h5>二、深化订单关联的采购/生产/委外协同</h5><ol start="3"><li><strong>采购端透明化与合规管理</strong>：构建供应商全生命周期管理（准入、评级、绩效），支持集中寻源、在线询比价与JIT协同；通过黑白名单校验与贸易合规检查降低风险，多工厂联合采购可稳定价格并动态调整折扣。</li><li><strong>生产与供应链联动</strong>：以订单驱动生产计划，通过APS系统实现设备、人员、物料多约束排程；结合MES集成实现工序报工、质量追溯与OEE（设备综合效率）分析；支持委外加工与自制灵活切换，采用关键件先行策略缩短交付周期。</li></ol><h5>三、构建业务增长闭环</h5><ol start="5"><li><strong>数据闭环与智能决策</strong>：整合ERP、SCM、CRM数据，通过Joule AI智能体实现从需求预测、安全库存建议到行动的自动化；可改善交付达成率、提升库存周转，且售后收入可量化。</li><li><strong>全球运营支撑</strong>：支持混合云部署与跨国合规管理，通过IBP（集成业务计划）/MRP（物料需求计划）实现供应链异常预警；aATP（可用量检查）功能可下单即承诺交期，在途与跨仓库存可视化减少缺料与呆滞，助力企业出海与全球业务协同。</li></ol><p><strong>价值总结</strong>：SAP通过端到端流程数字化与AI赋能，帮助企业提升赢单率、交付稳定性与供应链韧性，构建从客户需求到财务结算的增长闭环，适用于制造、零售、跨国集团等复杂业务场景。</p><h4>用友相关能力总结</h4><h5><strong>一、覆盖获客到售后全场景的数字化整合能力</strong></h5><p>通过<strong>YonSuite纯公有云SaaS平台</strong>及<strong>用友BIP</strong>，实现财务、人力、营销、供应链等跨场景数据一体化，打破“数据孤岛”，将分散信息转化为企业核心资产； 基于实时数据，AI能力从“事后分析”升级至“事中干预”“事前预测”（如消费品行业全渠道订单履约、医药行业合规管理均通过流程标准化与AI优化形成闭环）； 支持<strong>客户旅程全数字化</strong>：从营销自动化（企微自动标签、个性化推送）到售后回访机制，结合小程序下单、物流跟踪等自助服务入口，提升客户体验与复购率。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436275" alt="" title="" loading="lazy"/></p><h5><strong>二、深化订单关联的采购/生产/委外协同能力</strong></h5><p>通过<strong>供应链云</strong>的计划引擎、需求计划、供应网络计划等模块，衔接销售订单与生产、采购计划，实现“销售订单直接投产”，自动生成生产/委外订单并按部门/供应商分单； 销售订单可<strong>全流程跟踪</strong>：覆盖采购进程（订单、到货、入库）、生产进程（生产/委外订单、领料、入库）及成本分析，通过“齐套展望”功能预判库存满足度，优化排产效率； 打通上下游产业链协同：支持<strong>供应商协同平台</strong>（价格维护、到货计划）与<strong>委外全流程管理</strong>（材料出库、检验、结算），提升供应链敏捷性。</p><h5><strong>三、构建业务增长闭环能力</strong></h5><p>形成“流程×数据×AI”正向循环：以流程为业务骨架，数据沉淀为核心资产，AI激活价值（如立高食品通过该模式实现库存周转率提升73%）； <strong>数据驱动决策</strong>：提供实时数据看板与动态供需匹配，帮助企业从“经验决策”转向“低风险决策”，并支持消费品全渠道、制造业精益生产等行业化场景组装； 通过<strong>YonSuite一体化全球运营</strong>、产业链协同及<strong>YonStore云市场</strong>，开放资源与伙伴能力，推动企业从内部管理扩展至全产业链协同，实现规模化增长。</p><h4>超兔相关能力总结</h4><h5>一、覆盖获客到售后全场景的数字化整合</h5><ol start="7"><li><strong>获客与线索转化</strong>：支持百度、抖音等多渠道线索自动抓取，通过AI分析客户行为生成跟进建议（如复购周期提醒）；案例：某家装企业“抖音线索→成单”周期从7天压缩至3天，市场ROI提升40%。</li><li><strong>客户全生命周期管理</strong>：构建360°客户视图，整合历史订单、沟通记录、信用评级等数据；通过“销量分析”模块识别高价值客户，推送个性化促销方案；案例：某企业老客户复购占比从35%增至52%。</li><li><strong>售后与服务协同</strong>：打通维修工单、客户反馈流程，支持客户通过小程序查询服务进度，实现“售前-售中-售后”全链路透明化。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436276" alt="" title="" loading="lazy"/></p><h5>二、深化订单关联的采购/生产/委外协同</h5><ol start="10"><li><strong>全业务流程闭环</strong>：底层打通CRM、进销存、生产MES、财务模块，实现“订单-生产-发货-应收”自动化；案例：浙江某机械企业消除跨系统操作，订单回款周期从5天缩短至2天，年节省人工成本40万。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436277" alt="" title="" loading="lazy"/></p><ol start="11"><li><strong>智能采购与生产联动</strong>：订单触发后自动拆解BOM清单，同步检查库存缺口并生成采购需求；生产工单实时同步至车间，支持委外流程数字化跟踪，确保供应商交付进度透明可控。</li><li><strong>供应链可视化</strong>：通过BI聚合引擎实时展示库存动态、生产排期、物流状态，避免信息孤岛；案例：某五金企业交付周期从15天缩短至7天，错误率下降40%。</li></ol><h5>三、构建业务增长闭环</h5><ol start="13"><li><strong>AI深度赋能销售</strong>：内置“AI智能体”和“Coze工作流”，自动分析微信/电话沟通内容提取需求关键词；支持生成跟单策略（如“客户复购周期30天，今日需推送促销”）；销售效率提升3倍。</li><li><strong>低成本客制化能力</strong>：提供三级菜单自定义、审批流配置、自然语言生成流程规则（如“订单超50万需总经理审批”），适配工业、快消等多行业个性化需求，避免高昂定制成本。</li><li><strong>数据资产化管理</strong>：打通内外部数据（客户、供应商、财务），自动生成应收台账、薪资报表，支持Web/APP/小程序多端协同；案例：某工业设备企业引入后订单交付准时率从70%提升至92%。</li></ol><h4>销售易相关能力总结</h4><h5><strong>一、覆盖获客到售后全场景的数字化整合</strong></h5><p>销售易以<strong>移动、社交、AI、大数据、物联网技术</strong>为核心，实现营销、销售、服务全流程的自动化与数字化打通：</p><ul><li><strong>AI驱动全链路闭环</strong>：将大模型能力融入场景，如通过种子客户画像自动归因潜客的“智能客户推荐”、提升沟通效率的“智能邮件助手”、辅助决策的“ChatBI可视化分析”；全球首发Outlook“Neocrm”加载项，深度集成企业微信、钉钉、飞书等工具，实现沟通界面直接调取客户数据与历史记录，打破信息孤岛。</li><li><strong>数据与行为同步</strong>：公众号浏览行为数据自动回流客户表，外勤销售的拜访记录（签到、照片、语音、地理位置）实时同步至CRM，实现客户互动全轨迹的数字化沉淀。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436278" alt="" title="" loading="lazy"/></p><h5><strong>二、深化订单关联的采购/生产/委外协同</strong></h5><p>针对中大型企业（尤其制造业、医疗行业）的复杂业务需求，销售易实现订单与后端供应链的深度协同：</p><ul><li><strong>制造业适配</strong>：支持复杂产品配置（CPQ）、项目型销售管理及高价值设备全生命周期服务；订单可自动触发采购计划与生产排程，与ERP/MES系统深度对接，实时监控生产报工、良品率及物流状态。</li><li><strong>产业链协同与合规</strong>：通过“OpenCRM模块”实现与供应商/客户的外联（报价确认、订单对账、售后响应），缩短交易周期；医疗行业可沉淀学术会议、临床反馈等合规数据，一键生成报告。</li></ul><h5><strong>三、构建业务增长闭环</strong></h5><p>通过<strong>AI智能化、数据驱动、生态协同</strong>，帮助企业形成可持续增长的运营体系：</p><ul><li><strong>AI与数据驱动增长</strong>：智能体嵌入客户视图生成跟单建议，“Coze工作流”支持多级审批与跨部门协作；“Customer Data Cloud”整合全域数据，AI预测模型可预判客户决策链关键人（准确率达82%），提升赢单率。</li><li><strong>生态与服务保障</strong>：依托腾讯生态连接企业微信、腾讯会议等12亿社交触点，扩大获客与运营场景；交付采用“三段七级”服务（规划段蓝图评审、上线段双周迭代、运营段AI健康度巡检），确保系统落地后持续创造ROI。</li><li><strong>架构与行业适配</strong>：以“PaaS+SaaS架构”提供灵活定制能力，适配中大型企业复杂业务需求，在医疗、制造、能源等行业形成深度Know-How，通过“全流程自动化+AI智能化+生态协同化”构建企业增长引擎。</li></ul><h3>六、更多延伸</h3><h2>超兔一体云：覆盖获客到售后全场景的数字化整合，深化订单关联的采购/生产/委外协同，构建业务增长闭环的实现逻辑</h2><h3>一、引言</h3><p>在当今竞争激烈的商业环境中，中小企业面临着提升运营效率、降低成本、增强市场竞争力的多重挑战。超兔一体云凭借其独特的系统能力和功能优势，为企业提供了一套全面的数字化解决方案，实现了从获客到售后全场景的数字化整合，深化了订单关联的采购、生产、委外协同，有力地推动了业务增长闭环的构建。</p><h3>二、全场景数字化整合：从获客到售后的无缝衔接</h3><h4>（一）获客与市场拓展</h4><p>超兔一体云提供了丰富的集客支持渠道，涵盖百度广告平台、抖音头条的巨量引擎平台、官网落地页、微信营销、小程序营销、地推/会销获客以及工商搜客等。通过多渠道的数据获取和智能表单，企业能够广泛收集潜在客户线索。例如，在微信生态中，智能名片和微店可以吸引大量潜在客户；互联网广告则能精准触达目标客户群体。同时，系统具备线索处理能力，可一键处理线索，获取线索手机号/IP归属地，分配线索后自动发消息提醒，并计算市场活动成本均摊到获客线索及签约转化率。这些功能帮助企业高效获取潜在客户，为业务增长奠定基础。</p><h4>（二）客户跟进与管理</h4><p>在客户跟进环节，超兔一体云的客户中心提供了个性化配置功能，如用户画像设置、客户表编辑和显示布局自定义等。通过“三一客节点”和五大跟单模型，企业能够对客户进行精准跟进和管理。“三一客节点”通过定性、定级、定量的方式对客户进行评估，为销售提供明确的跟进方向；五大跟单模型则根据不同的业务场景，如客户跟单法、销售机会跟单法等，优化跟单流程。此外，客户视图能够展示全景信息，多级分类汇总客户数据，通过跟单时间线清晰呈现客户跟进历史，帮助销售更好地把握客户需求和跟进进度。</p><h4>（三）订单与合同管理</h4><p>超兔一体云的合同订单管理中心支持多种业务模型的订单逻辑，包括服务型、实物型和特殊型订单。对于实物型订单，又细分了标准订单、批发型订单、非标定制型订单等多种类型，满足不同企业的业务需求。订单的执行过程实现了自动化和智能化，包括订单工作流、待办和日程管理、订单锁库、生成采购计划和采购单以及供应商直发等功能。例如，在处理大型项目订单时，系统能够精确控制收支差，实现项目组、合同订单、采购跟单、收支管控等全周期管理。</p><h4>（四）售后与复购挖掘</h4><p>超兔一体云的复购挖掘和客服模块提供了客服总控台及岗位特殊权限，支持客服和投诉管理。通过RFM分析，企业能够科学分块老客户，进行精准回访，及时发现复购流失预警。同时，系统能够处理维修工单和外勤工单，为客户提供优质的售后服务。例如，在处理维修工单时，系统可以实现从接单到维修完成的全流程跟踪，确保服务质量和效率。通过优质的售后服务，企业能够提高客户满意度和忠诚度，促进客户复购，实现业务的持续增长。</p><h3>三、深化订单关联的采购/生产/委外协同</h3><h4>（一）采购管理协同</h4><p>超兔一体云的采购管理模块实现了从供应商管理到采购执行的全流程协同。基础功能包括供应商管理、采购单和采购单视图、采购退货和退款管理等。智能采购功能能够自动计算采购量，匹配历史供应商，通过OpenCRM模块进行询价比价，并根据供应商自动拆分采购单。例如，在多订单缺口采购模型中，系统能够自动整合多订单需求，结合库存与在途货物计算采购量，智能匹配最佳供应商，提高采购效率和降低采购成本。同时，OpenCRM上游连接实现了询价比价、创建采购单、供应商评级和采购单三流合一对账等功能，确保采购流程的透明度和合规性。</p><h4>（二）生产管理协同</h4><p>超兔一体云的生产管理模块（MES）为小微生产企业提供了低成本、轻量化的生产执行系统。通过智能排程/派工、进度管控、物料管理、生产报工、生产质检和成品入库等六大核心能力，实现了生产过程的精细化管理。智能排程支持正排和倒排两种方式，以及最快时间和最小班组两种排程策略，能够根据企业的实际需求灵活安排生产任务。进度管控通过甘特视图和车间大屏实时展示生产进度，让企业管理者能够及时掌握生产情况。物料管理依据CRM预设的生产BOM清单自动计算各工序所需物料数量，避免物料浪费。生产报工采用小组计件报工模式，提高了报工效率。生产质检能够把控工序质量，降低不良品率。成品入库确保合格产品及时入库，更新库存数据。同时，MES系统与超兔CRM系统深度联动，实现了销售 - 生产 - 仓储 - 采购一体化闭环，提高了企业的整体运营效率。</p><h4>（三）委外协同</h4><p>超兔一体云的开放性和集成能力为委外协同提供了可能。通过API接口和RPA机器人，企业可以将委外业务与系统进行对接，实现委外订单的管理、进度跟踪和质量管控。例如，企业可以将部分生产工序委托给外部供应商，通过系统实时获取委外生产进度，确保委外业务与内部业务的协同运作。</p><h3>四、构建业务增长闭环</h3><h4>（一）数据驱动决策</h4><p>超兔一体云的数据统计分析引擎为企业提供了强大的数据分析能力。工作台的数字卡片、图表卡片自定义引擎，同比环比引擎，多表聚合引擎，关联表复合查询引擎和单日KPI引擎等，能够帮助企业实时掌握业务数据，进行深入的数据分析。例如，通过同比环比引擎，企业可以对比不同时间段的业务数据，发现业务增长或下滑的趋势；通过多表聚合引擎，企业可以整合多个业务表的数据，进行复杂的关联分析，为决策提供有力支持。</p><h4>（二）AI能力赋能</h4><p>超兔一体云的AI模块通过超兔AI智能体和通义千问大模型，为企业提供了定制行业销售SOP、AI专家智能体、AI生成用户画像/三一客节点/SFA方案等能力。AI待办、AI日报、AI问答、AI执行、AI分析等场景化应用，能够自动落地跟单动作，生成结构化报告，提供专业支持，替代人工重复操作，进行数据化沟通洞察。例如，AI待办可以根据销售行动记录自动创建下一步跟单待办，明确完成期限；AI日报可以一键生成专业日报，减少人工整理时间，辅助员工自我反思。通过AI能力的应用，企业能够提升跟单效率，降低人工成本，优化销售策略，促进业务增长。</p><h4>（三）外部系统对接与数据交换</h4><p>超兔一体云具备强大的外部系统对接和数据交换能力，与ERP、WMS等有对接案例，与电商平台通过RPA机器人对接，还能对接国税开票机器人。通过提供API接口和文档，企业可以方便地将超兔一体云与其他外部系统进行对接，实现数据的流通和共享。例如，与电商平台的对接可以自动采集电商订单数据，同步至CRM系统，避免人工录入错误，提高订单处理效率；与财务软件的对接可以实现业务数据智能生成财务凭证，提升财务记账效率。这种开放性和集成能力使得超兔一体云能够融入企业的整体信息化架构，与其他系统协同工作，共同推动业务增长。</p><h3>五、结论</h3><p>超兔一体云通过覆盖获客到售后全场景的数字化整合，深化订单关联的采购/生产/委外协同，构建了一个完整的业务增长闭环。在全场景数字化整合方面，从获客到售后的各个环节实现了无缝衔接，提高了客户获取、跟进、转化和留存的效率；在订单关联的协同方面，采购、生产和委外业务实现了高效协同，降低了运营成本，提高了生产效率；在业务增长闭环构建方面，数据驱动决策、AI能力赋能和外部系统对接为企业提供了持续增长的动力。超兔一体云以其独特的系统能力和功能优势，为中小企业提供了一套全面、高效、智能的数字化解决方案，助力企业在激烈的市场竞争中实现业务增长和可持续发展。</p>]]></description></item><item>    <title><![CDATA[艾体宝干货 | Redis Python]]></title>    <link>https://segmentfault.com/a/1190000047436289</link>    <guid>https://segmentfault.com/a/1190000047436289</guid>    <pubDate>2025-11-28 16:06:32</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>本文详细讲解 Redis 主从复制、哨兵模式和集群模式的原理与配置，提供完整的 Python 连接代码示例，确保你的应用在生产环境中实现高可用性和可扩展性。</p><h2>前言</h2><p>在掌握了 Redis 的所有核心数据结构和高级特性后，我们面临最后一个关键挑战：如何让 Redis 在生产环境中<strong>不宕机</strong>？单点 Redis 实例一旦故障，将导致整个应用不可用。这就是 Redis <strong>高可用（High Availability）</strong> 和 <strong>集群（Cluster）</strong> 架构要解决的根本问题。</p><p>​<strong>本篇读者收益</strong>​：</p><ul><li>深入理解 Redis <strong>主从复制</strong>、<strong>哨兵模式（Sentinel）</strong> 和 <strong>集群模式（Cluster）</strong> 的架构原理。</li><li>掌握使用 <code>redis-py</code> 连接 Redis Sentinel 实现自动故障转移和读写分离。</li><li>掌握使用 <code>redis-py</code> 或 <code>redis-cluster</code> 连接 Redis Cluster 实现数据分片和水平扩展。</li><li>了解云服务（如 AWS ElastiCache、Azure Cache）的连接要点。</li></ul><p>​<strong>先修要求</strong>​：已掌握 Redis 基础连接和操作（详见系列前四篇）。</p><p>​<strong>关键要点</strong>​：</p><ol><li>​<strong>主从复制</strong>​：数据冗余的基础，从节点提供读扩展，但不具备自动故障转移能力。</li><li>​<strong>哨兵模式（Sentinel）</strong>​：在复制基础上增加了**监控、通知和自动故障转移**，实现真正的高可用。</li><li>​<strong>集群模式（Cluster）</strong>​：通过数据分片（sharding）实现**水平扩展**，兼具高可用和可扩展性。</li><li>从单机到哨兵再到集群，是一个在**复杂度、可用性和扩展性**之间的权衡过程。</li></ol><h2>背景与原理简述</h2><p>随着业务增长，单机 Redis 会遇到两个核心瓶颈：</p><ol><li>​<strong>可用性瓶颈</strong>​：单个节点故障导致服务完全中断。</li><li>​<strong>性能/容量瓶颈</strong>​：单机内存、CPU、网络带宽有限。</li></ol><p>Redis 提供了三种进阶部署方案来解决这些问题：</p><ul><li>​<strong>主从复制（Replication）</strong>​：一个主节点（master）负责写操作，多个从节点（slave）复制主节点数据并提供读服务。解决了**读扩展**和**数据备份**，但没有自动故障转移。</li><li>​<strong>哨兵模式（Sentinel）</strong>​：在复制基础上，引入专门的哨兵进程来监控节点健康状态，并在主节点故障时**自动选举新的主节点**，实现高可用。</li><li>​<strong>集群模式（Cluster）</strong>​：将数据自动分片到多个主节点上，每个主节点都有对应的从节点。同时解决了**水平扩展**和**高可用**问题。</li></ul><h2>环境准备与快速上手</h2><p><strong>安装必要的 Python 库</strong></p><pre><code class="Bash"># 安装 redis-py（支持 Sentinel 和基础 Cluster 连接）
pip install "redis[hiredis]"

# 对于更完整的 Cluster 支持，推荐安装 redis-py-cluster
pip install redis-py-cluster</code></pre><p><strong>基础连接测试</strong></p><pre><code class="Python"># filename: setup.py
import os
import redis
from redis.sentinel import Sentinel
from redis.cluster import RedisCluster
from redis.exceptions import RedisError, ConnectionError

print("Redis 高可用与集群连接演示环境就绪")</code></pre><h2>核心用法与代码示例</h2><h3>主从复制（Replication）</h3><p><strong>架构概述</strong></p><ul><li>一个主节点（可写可读）</li><li>一个或多个从节点（只读，异步复制主节点数据）</li><li>客户端手动处理读写分离</li></ul><p><strong>Python 连接示例</strong></p><pre><code class="Python"># filename: replication_demo.py
def replication_setup():
    """演示主从复制的基本连接（手动读写分离）"""
    
    # 连接主节点（写操作）
    master = redis.Redis(
        host='redis-master-host',
        port=6379,
        password='your_password',
        decode_responses=True
    )
    
    # 连接从节点（读操作）
    slave = redis.Redis(
        host='redis-slave-host', 
        port=6379,
        password='your_password',
        decode_responses=True
    )
    
    # 写入只能在主节点
    master.set('global:counter', 100)
    
    # 读取可以在从节点（注意复制延迟）
    value = slave.get('global:counter')
    print(f"从节点读取的值: {value}")
    
    return master, slave

# 注意：生产环境不建议手动管理主从，推荐使用 Sentinel</code></pre><h3>哨兵模式（Sentinel）</h3><p><strong>架构概述</strong></p><ul><li>多个哨兵进程（Sentinel）组成集群，监控 Redis 节点</li><li>自动故障检测和主节点选举</li><li>客户端通过哨兵发现当前的主节点</li></ul><p><strong>Python 连接 Sentinel</strong></p><pre><code class="Python"># filename: sentinel_demo.py
def sentinel_connection():
    """连接 Redis Sentinel 集群"""
    
    # 1. 定义哨兵节点列表
    sentinel_nodes = [
        ('sentinel1.example.com', 26379),
        ('sentinel2.example.com', 26379), 
        ('sentinel3.example.com', 26379),
    ]
    
    # 2. 创建 Sentinel 对象
    sentinel = Sentinel(
        sentinel_nodes,
        socket_timeout=0.1,
        password='your_sentinel_password',  # 如果哨兵有密码
        decode_responses=True
    )
    
    # 3. 获取主节点和从节点客户端
    # service_name 是在哨兵配置中定义的集群名称
    master = sentinel.master_for(
        'my-redis-cluster',  # service_name
        socket_timeout=0.1,
        password='your_redis_password',
        decode_responses=True
    )
    
    slave = sentinel.slave_for(
        'my-redis-cluster',  # service_name  
        socket_timeout=0.1,
        password='your_redis_password',
        decode_responses=True
    )
    
    return master, slave, sentinel

def sentinel_operations():
    """使用 Sentinel 客户端进行操作"""
    try:
        master, slave, sentinel = sentinel_connection()
        
        # 写入操作 - 使用主节点
        master.set('sentinel:test', 'hello from master')
        master.incr('sentinel:counter')
        
        # 读取操作 - 使用从节点
        value = slave.get('sentinel:test')
        counter = slave.get('sentinel:counter')
        print(f"从节点读取: {value}, 计数器: {counter}")
        
        # 发现当前主从节点信息
        current_master = sentinel.discover_master('my-redis-cluster')
        current_slaves = sentinel.discover_slaves('my-redis-cluster')
        print(f"当前主节点: {current_master}")
        print(f"当前从节点: {current_slaves}")
        
    except RedisError as e:
        print(f"Sentinel 操作失败: {e}")

# 运行示例
sentinel_operations()</code></pre><p><strong>哨兵故障转移演示</strong></p><pre><code class="Python"># filename: sentinel_failover.py
import time
import threading

def monitor_sentinel_status():
    """监控哨兵状态（模拟故障转移观察）"""
    sentinel = Sentinel([
        ('localhost', 26379),
        ('localhost', 26380), 
        ('localhost', 26381),
    ], socket_timeout=0.5)
    
    while True:
        try:
            master_addr = sentinel.discover_master('my-redis-cluster')
            slaves = sentinel.discover_slaves('my-redis-cluster')
            print(f"[{time.strftime('%H:%M:%S')}] 主节点: {master_addr}, 从节点: {slaves}")
        except RedisError as e:
            print(f"监控错误: {e}")
        
        time.sleep(2)

def sentinel_auto_failover_test():
    """测试哨兵的自动故障转移"""
    master, slave, sentinel = sentinel_connection()
    
    # 持续写入数据
    def writer():
        counter = 0
        while True:
            try:
                master.set('failover:test', f'value_{counter}')
                master.incr('failover:counter')
                counter += 1
                time.sleep(1)
            except RedisError as e:
                print(f"写入失败: {e}, 等待故障转移...")
                time.sleep(3)
    
    # 持续读取数据  
    def reader():
        while True:
            try:
                value = slave.get('failover:test')
                counter = slave.get('failover:counter')
                print(f"读取: {value}, 计数器: {counter}")
            except RedisError as e:
                print(f"读取失败: {e}")
            time.sleep(1)
    
    # 启动读写线程
    threading.Thread(target=writer, daemon=True).start()
    threading.Thread(target=reader, daemon=True).start()
    
    # 运行监控
    monitor_sentinel_status()

# 注意：运行此示例需要真实的哨兵环境
# sentinel_auto_failover_test()</code></pre><h3>集群模式（Cluster）</h3><p><strong>架构概述</strong></p><ul><li>数据自动分片到 16384 个槽位（slots）</li><li>每个节点负责一部分槽位</li><li>客户端直接路由命令到正确的节点</li><li>每个主节点都有对应的从节点</li></ul><p><strong>Python 连接 Cluster</strong></p><pre><code class="Python"># filename: cluster_demo.py
def cluster_connection():
    """连接 Redis Cluster"""
    
    # 启动节点列表（不需要所有节点，能连接一个即可发现整个集群）
    startup_nodes = [
        {"host": "redis-cluster-node1.example.com", "port": 6379},
        {"host": "redis-cluster-node2.example.com", "port": 6379},
        {"host": "redis-cluster-node3.example.com", "port": 6379},
    ]
    
    try:
        # 方法1: 使用 redis-py-cluster (推荐)
        from redis.cluster import RedisCluster
        
        rc = RedisCluster(
            startup_nodes=startup_nodes,
            password='your_cluster_password',
            decode_responses=True,
            skip_full_coverage_check=True,  # 避免不必要的全集群检查
            socket_connect_timeout=5,
            socket_timeout=5,
            retry_on_timeout=True,
            max_connections_per_node=20
        )
        
        return rc
        
    except ImportError:
        # 方法2: 使用 redis-py 内置的集群支持（基础功能）
        print("redis-py-cluster 未安装，使用 redis-py 基础集群支持")
        rc = redis.Redis(
            host=startup_nodes[0]['host'],
            port=startup_nodes[0]['port'],
            password='your_cluster_password',
            decode_responses=True
        )
        
        return rc

def cluster_operations():
    """集群基本操作"""
    try:
        rc = cluster_connection()
        
        # 基本操作 - API 与单机版基本一致
        rc.set('cluster:key1', 'value1')
        rc.set('cluster:key2', 'value2')
        
        value1 = rc.get('cluster:key1')
        value2 = rc.get('cluster:key2')
        print(f"获取值: key1={value1}, key2={value2}")
        
        # 计数器操作
        rc.incr('cluster:counter')
        counter = rc.get('cluster:counter')
        print(f"计数器: {counter}")
        
        # 获取集群信息
        if hasattr(rc, 'cluster_info'):
            info = rc.cluster_info()
            print(f"集群状态: {info.get('cluster_state')}")
            print(f"已知节点数: {info.get('cluster_known_nodes')}")
        
        # 获取键所在的槽位和节点
        key_slot = rc.cluster_keyslot('cluster:key1')
        print(f"key1 的槽位: {key_slot}")
        
    except RedisError as e:
        print(f"集群操作失败: {e}")

# 运行示例
cluster_operations()</code></pre><p><strong>集群分片与路由</strong></p><pre><code class="Python"># filename: cluster_sharding.py
def cluster_sharding_demo():
    """演示集群的数据分片特性"""
    rc = cluster_connection()
    
    # 存储多个键，它们会被自动分配到不同节点
    keys = []
    for i in range(10):
        key = f'sharding:key:{i}'
        rc.set(key, f'value_{i}')
        keys.append(key)
    
    # 验证键分布在不同的槽位
    for key in keys:
        slot = rc.cluster_keyslot(key)
        # 获取负责该槽位的节点
        node = rc.nodes_manager.get_node_from_slot(slot)
        print(f"键 {key} -&gt; 槽位 {slot} -&gt; 节点 {node}")
    
    # 批量操作的限制：跨槽位的 MSET/MGET 会失败
    try:
        # 这可能会失败，因为 keys 可能在不同的槽位
        result = rc.mget(keys)
        print(f"批量获取成功: {result}")
    except redis.RedisError as e:
        print(f"跨槽位批量操作失败: {e}")
        # 解决方案：使用 pipeline 或哈希标签确保键在同一个槽位

def cluster_hash_tags():
    """使用哈希标签确保相关键在同一个槽位"""
    rc = cluster_connection()
    
    # 使用 {user123} 作为哈希标签，确保所有 user123 相关的键在同一个槽位
    user_id = "user123"
    
    rc.set(f"user:{{{user_id}}}:profile", "profile_data")
    rc.set(f"user:{{{user_id}}}:session", "session_data") 
    rc.set(f"user:{{{user_id}}}:preferences", "prefs_data")
    
    # 现在可以安全地进行批量操作
    keys = [
        f"user:{{{user_id}}}:profile",
        f"user:{{{user_id}}}:session", 
        f"user:{{{user_id}}}:preferences"
    ]
    
    try:
        values = rc.mget(keys)
        print(f"使用哈希标签批量获取: {values}")
    except redis.RedisError as e:
        print(f"哈希标签批量操作失败: {e}")

cluster_hash_tags()</code></pre><h2>性能优化与容量规划</h2><p><strong>连接池配置实践</strong></p><pre><code class="Python"># filename: production_connection_pools.py
def production_connection_configs():
    """生产环境连接配置示例"""
    
    # Sentinel 连接池配置
    sentinel_pool = redis.sentinel.SentinelConnectionPool(
        'my-redis-cluster',
        redis.sentinel.Sentinel([
            ('sentinel1', 26379),
            ('sentinel2', 26379),
            ('sentinel3', 26379),
        ]),
        password='your_password',
        max_connections=50,
        socket_timeout=5,
        socket_connect_timeout=5,
        retry_on_timeout=True,
        health_check_interval=30
    )
    
    # Cluster 连接池配置
    cluster_pool = RedisCluster(
        startup_nodes=[{"host": "node1", "port": 6379}],
        password='your_password',
        max_connections=100,  # 每个节点的最大连接数
        socket_connect_timeout=5,
        socket_timeout=5,
        retry_on_timeout=True,
        reinitialize_steps=10  # 每10次命令后重新初始化连接
    )</code></pre><p><strong>监控与健康检查</strong></p><pre><code class="Python"># filename: health_monitoring.py
class RedisHealthMonitor:
    """Redis 健康监控器"""
    
    def __init__(self, client):
        self.client = client
    
    def check_connectivity(self):
        """检查基本连通性"""
        try:
            return self.client.ping()
        except (ConnectionError, RedisError):
            return False
    
    def get_info(self, section=None):
        """获取 Redis 信息"""
        try:
            if hasattr(self.client, 'info'):
                return self.client.info(section)
            else:
                # Cluster 的特殊处理
                return self.client.cluster_info()
        except RedisError:
            return None
    
    def monitor_memory_usage(self):
        """监控内存使用情况"""
        info = self.get_info('memory')
        if info:
            return {
                'used_memory': info.get('used_memory_human', 'N/A'),
                'used_memory_peak': info.get('used_memory_peak_human', 'N/A'),
                'memory_fragmentation_ratio': info.get('mem_fragmentation_ratio', 'N/A')
            }
        return None
    
    def check_replication_status(self):
        """检查复制状态（适用于主从和集群）"""
        info = self.get_info('replication')
        if info:
            role = info.get('role')
            if role == 'master':
                return {
                    'role': 'master',
                    'connected_slaves': info.get('connected_slaves', 0)
                }
            elif role == 'slave':
                return {
                    'role': 'slave', 
                    'master_link_status': info.get('master_link_status', 'down'),
                    'master_host': info.get('master_host', 'unknown')
                }
        return None</code></pre><h2>安全与可靠性</h2><ul><li>使用安全组/防火墙限制访问来源</li><li>Redis 节点部署在私有子网</li><li>哨兵和集群节点间使用专用网络</li><li>配置适当的 <code>save</code> 规则或启用 AOF</li><li>定期测试备份恢复流程</li><li>跨可用区部署提高容灾能力</li></ul><h2>案例</h2><p><strong>云服务连接示例（AWS ElastiCache）</strong></p><pre><code class="Python"># filename: aws_elasticache.py
def connect_aws_elasticache():
    """连接 AWS ElastiCache Redis"""
    
    # ElastiCache Redis (Cluster Mode Disabled) - 使用 Sentinel
    if os.getenv('REDIS_MODE') == 'sentinel':
        sentinel = Sentinel([
            ('primary-endpoint', 26379),
            ('secondary-endpoint', 26379),
        ], socket_timeout=1)
        
        client = sentinel.master_for(
            'my-cluster',
            socket_timeout=1,
            password=os.getenv('REDIS_PASSWORD')
        )
    
    # ElastiCache Redis (Cluster Mode Enabled) - 使用 Cluster
    elif os.getenv('REDIS_MODE') == 'cluster':
        # 获取配置端点
        configuration_endpoint = os.getenv('REDIS_CLUSTER_CONFIG_ENDPOINT')
        host, port = configuration_endpoint.split(':')
        
        client = RedisCluster(
            startup_nodes=[{"host": host, "port": int(port)}],
            password=os.getenv('REDIS_PASSWORD'),
            skip_full_coverage_check=True,
            decode_responses=True
        )
    
    else:
        # 单机模式
        client = redis.Redis(
            host=os.getenv('REDIS_HOST'),
            port=int(os.getenv('REDIS_PORT')),
            password=os.getenv('REDIS_PASSWORD'),
            decode_responses=True
        )
    
    return client

# 生产环境配置管理器
class RedisConnectionManager:
    """生产环境 Redis 连接管理器"""
    
    _clients = {}
    
    @classmethod
    def get_client(cls, service_name='default'):
        """获取 Redis 客户端（单例模式）"""
        if service_name not in cls._clients:
            if os.getenv('REDIS_CLUSTER_ENABLED') == 'true':
                cls._clients[service_name] = connect_aws_elasticache()
            else:
                # 其他连接逻辑
                pass
        
        # 健康检查
        try:
            cls._clients[service_name].ping()
        except RedisError:
            # 重新建立连接
            cls._clients[service_name] = connect_aws_elasticache()
        
        return cls._clients[service_name]</code></pre><h2>小结</h2><p>从单机到哨兵再到集群，Redis 提供了完整的解决方案来满足不同规模应用的高可用和可扩展性需求。哨兵模式为读写分离和自动故障转移提供了优雅的解决方案，而集群模式则通过数据分片实现了真正的水平扩展。</p>]]></description></item><item>    <title><![CDATA[构筑教育数据安全防线：从“静态边界”到“]]></title>    <link>https://segmentfault.com/a/1190000047436321</link>    <guid>https://segmentfault.com/a/1190000047436321</guid>    <pubDate>2025-11-28 16:05:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436323" alt="图片" title="图片"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436324" alt="图片" title="图片" loading="lazy"/><br/>近日，湖南省湘西州某所高校因监控系统在互联网上未设置任何安全防护措施，导致包含大量师生行为轨迹的敏感视频数据完全暴露而被网信办依法开出罚单。虽然这是湘西州首例针对教育机构数据安全的行政处罚，但数据安全监管的触角早已深入基层教育单位，此次事件再一次为整个教育行业敲响了警钟。在教育数字化转型的过程中，数据具有高流动性和强关联性，如今更是教学与科研活动的核心资产，涵盖学生隐私信息、教学资源、科研实验数据等多维内容。学校一方面需要充分利用教学数据、管理数据与科研数据来提升教育质量、优化管理效率和推动智慧校园建设；另一方面，也必须确保数据在采集、存储、传输和使用各个环节中的安全。随着《数据安全法》《个人信息保护法》等法律法规的深入实施，教育行业数据以及涉及个人隐私的学生信息，已成为数据全生命周期安全治理的重中之重。教育数据安全不应再只局限于监管部门对其合规性的监督和检查，而是作为数据的处理者，应真正将视野扩展到数据在整个校园网络中流转的全链路，致力于构建全局性的防护与管理体系。构建全域赋能的数据流动安全管理体系针对教育行业的特殊性和其数据分布分散、数据类型敏感等特性的深入剖析，以及对“智慧校园”建设中数据跨系统流转、内外平台交互等关键场景安全诉求的深刻理解，全知科技构建的[教育行业数据流动安全管理体系]，以“零干扰部署、精准识别、闭环处置”为核心理念，帮助教育行业实现数据全生命周期的安全防护。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047436325" alt="图片" title="图片" loading="lazy"/><br/>数据资产智能识别与分类分级由于教育行业的数据来源多样、结构不一、流转场景复杂，若信息中心无法清晰掌握数据资产的分布与脉络，就容易陷入“看不见、理还乱”的困境，导致数据安全建设要么无从下手，要么投入高昂却收效甚微。因此，实现数据资产的全面可见，是教育行业迈出数据安全治理的第一步，也是所有防护工作的基石。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047436326" alt="图片" title="图片" loading="lazy"/><br/>▸敏感数据的识别<br/>学校涉及大量敏感数据，如师生信息、校园监控视频、门禁通行记录、升学成绩、奖惩记录等。对这些敏感数据进行识别和标记，以便在后续的数据处理和存储中能够得到特殊的保护和控制。全知科技采用先进的数据资产识别和人工智能技术，通过对学校数据的内容、格式、来源、使用情况等进行综合分析，识别出其中的敏感数据。一旦敏感数据被识别，将建立相应的安全措施和权限管理，确保其被授权人员访问和使用，从而避免数据泄露和安全风险。<br/>▸数据分类分级<br/>教育行业处理的数据类型，涵盖了各个学校的信息，其重要性和敏感程度也不尽相同。知源-AI数据分类分级系统，借助AI大模型实现自动化分类分级。通过主动学习技术，按照教育行业安全级别和保密程度进行划分，制定不同的数据处理和存储策略，以确保学校数据得到适当的保护和使用。智能化扫描打标完成后系统会生成一份完整的分析报告并通过可视化的方案呈现，整个发现过程实现数据口径统一、数据管理依据的建立，确保得到数据机密性的保护和控制。该系统在不影响企业实际的数据服务环境的前提下，不仅能提高数据分类分级的工作效率，也保障了数据资产管理与梳理的质量，使其准确率提升至 95%+。</p><p>通过敏感数据识别和数据分类分级，教育行业可以对数据的安全性进行准确地管理和保障。这两项内容的有效实施，是学校数据安全、提升服务质量、赋能学校工作的关键环节。应用数据流动风险实时监测学校数据库中存在大量的敏感数据，当数据被前端应用系统调用并流向不同终端或第三方业务系统时，经常存在大批量查询或导出数据的行为，管理员账号一旦被盗用、滥用或借用，极易导致敏感数据泄露；此外，一些数据在API接口认证、权限管控、数据暴露、访问行为以及安全规范等关键风险点均缺乏清晰识别和量化评估，往往缺乏有效防护，形成了建设盲区，造成潜在威胁难以及时发现和管理。</p><p>▸API风险监测<br/>全知科技自主研发的API风险监测系统，基于流量分析与数据识别技术，能够对全网API接口进行自动发现、分类分级和持续监测，构建完整的接口画像与生命周期管理。系统依托大数据引擎与AI大模型，精准识别接口漏洞与弱点，实时感知数据泄露、Web攻击、账号异常等风险行为，并自动生成修复建议，帮助学校快速降低安全隐患。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047436327" alt="图片" title="图片" loading="lazy"/><br/>系统具备资产梳理、弱点评估、风险监测、审计溯源和AI安全运营五大核心能力。通过AI大模型自动化研判与风险运营，可替代人工专家完成弱点验证与风险分析，显著提升安全运营效率。API风险监测系统还支持旁路部署，兼容互联网出口、生产网、办公网等多种环境，实现对API资产与数据流的全生命周期保护，帮助学校全面掌握接口现状，满足合规监管要求，构建“发现—防护—预警—溯源”的闭环防护能力。</p><p>通过实施数据接口风险流动监测，可以全面掌握数据的流动情况，及时发现潜在的安全风险，精准识别从师生终端到核心数据库的各类潜在风险，采取相应措施进行预警和处置，实现从被动防护到主动预警的关键转变，为教育数据的全域安全流转构建坚实防线。</p><p>风险闭环处置与事件的审计溯源</p><p>学校在建立建全数据安全治理的同时，也应对各个环节设置数据安全风险闭环惩罚机制。当发现数据安全风险或安全事件时，需要及时报告和记录，由专业团队进行评估和分析，确定风险等级和处理优先级。然后采取相应措施，对风险进行有效惩罚，修复缺陷，阻止风险扩大。在风险处理完成后，还要对处理结果进行评估，总结经验教训，及时调整和优化安全措施，确保类似风险不再发生。为更好地防范和应对未来的安全风险提供经验积累，数据安全风险全流程审计溯源在数据安全体系落地建设中更是必不可少。学校在建立风险闭环处置时，也应对数据安全事件进行记录和追踪，分析风险的起因和演变过程，查明安全事件的影响范围。通过审计溯源报告，查找安全漏洞、人为失误等问题，并提出相应的改进意见和措施。同时，将数据安全审计与绩效评估相结合，对数据安全风险的发生过程和结果进行评估，并为以后改进安全管理提供依据。数据安全风险全流程闭环落实和数据安全风险全渠道审计溯源，可以帮助教育行业更好地及时掌控数据安全风险全流程，有效地应对安全事件，防范未来的风险。这些内容的实施将使教育行业的发展提质、服务能够提供可靠保障，并为学校数字化建设工作赋予现代化的信息化支撑，适应信息化时代的发展需求。</p><p>全知科技也将继续以自主可控的核心技术为核心驱动，秉持“数据在流动，可见才安全”的安全理念，深耕教育数字化的安全需求，打造更加智能、易用、贴合实际的安全产品与服务。面向校园教育场景提供更精细化、体系化的数据安全治理思路，帮助提升教育系统的数据安全治理能力。同时，也将与行业伙伴共同推动形成可信、安全、健康的教育数据生态，为教育数字化转型注入持久动力。</p>]]></description></item><item>    <title><![CDATA[主流CRM系统核心能力横向对比：从销售自]]></title>    <link>https://segmentfault.com/a/1190000047436328</link>    <guid>https://segmentfault.com/a/1190000047436328</guid>    <pubDate>2025-11-28 16:05:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化转型背景下，CRM（客户关系管理）已从“客户信息存储工具”升级为“全生命周期业务赋能平台”。其核心价值在于<strong>打通营销、销售、服务的数据闭环</strong>，通过AI驱动的自动化与智能化，提升客户转化效率与忠诚度。本文基于<strong>销售自动化</strong> <strong>、客户画像、营销管理、服务支持、</strong> <strong>数据分析</strong> <strong>、移动端AI集成</strong>六大核心维度，对当前主流CRM系统（超兔一体云、Salesforce、SAP、Microsoft Dynamics 365、Zoho CRM、销售易、腾讯企点）展开专业横评，为企业选型提供参考。</p><h2>一、对比框架与评估标准说明</h2><p>本次对比围绕CRM的<strong>业务全链路价值</strong>设计，核心评估标准如下：</p><table><thead><tr><th>维度</th><th>评估重点</th></tr></thead><tbody><tr><td>销售自动化</td><td>流程覆盖（线索→回款）、自定义能力、AI驱动的自动化节点、行业适配性</td></tr><tr><td>客户画像</td><td>数据整合来源（内外部）、维度丰富度（行为/交易/社交）、实时性、智能补全</td></tr><tr><td>营销管理</td><td>渠道覆盖（线上/线下/社交）、自动化工具（ campaign/裂变）、行业垂直模板</td></tr><tr><td>服务支持</td><td>全渠道客服（电话/在线/社交）、工单系统（分级/追踪）、知识库/QA库、合规性</td></tr><tr><td>数据分析</td><td>BI可视化能力、预测分析（复购/流失）、自定义报表、跨系统数据联动</td></tr><tr><td>移动端AI集成</td><td>AI应用场景（待办/日报/话术）、数据联动（业务数据→AI建议）、移动端易用性</td></tr></tbody></table><h2>二、核心能力横向对比表</h2><p>以下为7款主流CRM系统的关键能力提炼（基于素材原文，无额外推断）：</p><table><thead><tr><th>品牌</th><th>销售自动化</th><th>客户画像</th><th>营销管理</th><th>服务支持</th><th>数据分析</th><th>移动端AI集成</th></tr></thead><tbody><tr><td><strong>超兔一体云</strong></td><td>三一客（小单快单）/商机/项目模型；自动线索分配/查重；订单→采购/库存同步</td><td>整合客户基本/交易/沟通/行为数据；AI画像分组（高价值/潜在/流失）；实时更新</td><td>百度/抖音/微信多渠道集客；话术/文件武器云；营销活动效果分析（线索/成本）</td><td>客服总控台（权限/投诉）；售后工单（维修/外勤）；服务质量监控（响应/满意度）</td><td>自动采集业务数据；多表聚合/关联查询；可视化数字卡片/图表</td><td>AI待办（跟单提醒）、AI日报（结构化总结）、AI话术（销售/客服）；数据驱动建议</td></tr><tr><td><strong>Salesforce</strong></td><td>Agentforce 360 AI代理（全流程自动化）；Einstein线索评分/预测；端到端流程覆盖</td><td>整合销售/服务/营销/ERP数据；360°视图（广告点击→复购）；实时追踪</td><td>Marketing Cloud（多渠道自动化）；行业模板（节假日促销）；AI内容生成</td><td>Service Cloud全渠道；工单→知识库联动；ISO 27001/等保三级；售后回访</td><td>Tableau BI（实时可视化）；Einstein预测（复购/流失）；自定义报表</td><td>Einstein AI（移动端实时建议）；Agentforce 360（自动报表/审批）；AppExchange集成</td></tr><tr><td><strong>SAP</strong></td><td>端到端流程自动化（500+节点自定义）；关键节点审批灵活配置；ERP联动（库存/财务）</td><td>整合ERP/SCM/销售数据；实时展示交易/库存/服务记录；制造业供应链适配</td><td>行业垂直模板（金融合规/制造协同）；多语言/多时区（全球化）</td><td>混合云合规存储；工单分级处理；售后进度追踪</td><td>多维度漏斗分析（区域/产品/团队）；历史数据预测（复购概率）；BI可视化</td><td>Business AI（成交预测/需求预判）；模型可解释性；移动端云端同步</td></tr><tr><td><strong>Microsoft D365</strong></td><td>Copilot AI（邮件草稿/会议摘要）；BANT商机评估；Outlook/Teams联动</td><td>整合Teams/Outlook/销售数据；客户互动全记录；自定义查重/补全</td><td>与Office套件无缝协作；营销-销售协同闭环；自然语言交互</td><td>实时KPI追踪；工单系统（售后流程）；竞争对手提及监控</td><td>Power BI可视化；动态销售漏斗；数据驱动决策</td><td>Copilot AI（移动端商机分析/邮件自动化）；自然语言交互；离线同步</td></tr><tr><td><strong>Zoho</strong> <strong>CRM</strong></td><td>线索→商机→合同自动化；AI跟进提醒；自定义流程</td><td>整合销售/沟通/购买行为数据；360°动态视图；智能补全</td><td>多渠道活动管理（邮件/社交）；营销自动化工具；性价比高</td><td>全渠道客服（邮件/电话/社交）；工单→知识库联动；7×24小时支持</td><td>BI商业智能（实时报表）；自定义数据分析；无技术门槛</td><td>Zia AI（销售预测/行为分析）；移动端实时建议；离线同步</td></tr><tr><td><strong>销售易</strong></td><td>移动/社交/AI融合；线索→复购闭环；自动化跟进提醒</td><td>整合内外部数据（销售/服务/营销）；360°视图；精准需求定位</td><td>多渠道获客；AI驱动销售策略；行业适配（工程/快消）</td><td>全流程服务管理；多端协同（Windows/Android/企业微信）；响应速度提升</td><td>零代码自定义报表；实时销售漏斗监控；业绩指标分析</td><td>AI销售预测/智能推荐；移动端多端协同；客户流失预警</td></tr><tr><td><strong>腾讯企点</strong></td><td>线索→触达→转化全流程；微信生态整合（访客行为/公众号互动）；智能外呼</td><td>整合微信社交数据（聊天/朋友圈）；会员标签/消费行为；360°信息管理</td><td>社交营销（裂变/直播）；全场景自动化；微信获客适配</td><td>在线客服（微信/QQ集成）；工单管理；7×24小时支持</td><td>客户行为分析（邮件打开/互动）；转化率报表；深度人群运营</td><td>AI客服机器人；智能推荐；会话分析；移动端微信联动</td></tr></tbody></table><h2>三、核心维度深度分析</h2><h3>1. 销售自动化：从“流程覆盖”到“AI驱动的精准效率”</h3><p>销售自动化的核心是<strong>减少人工重复劳动</strong>，将精力聚焦于高价值决策。各系统的差异体现在<strong>流程自定义深度</strong>与<strong>AI的嵌入场景</strong>：</p><ul><li><strong>Salesforce</strong>：Agentforce 360 AI代理可自动完成线索分配、数据录入、报表生成等10+项高频任务，Einstein AI通过历史数据预测“最佳跟进时机”，端到端覆盖从线索到复购的全流程，适合大型企业的复杂销售场景。</li><li><strong>SAP</strong>：支持500+节点的自定义工作流，关键节点（如合同审批、回款追踪）可关联ERP系统自动同步库存/财务数据，完美适配制造业“销售-供应链”协同的需求。</li><li><strong>超兔一体云</strong>：针对小单快单场景设计“三一客模型”（定性→定级→定量），自动判断客户阶段并提醒跟进动作（如外勤拜访/电话沟通），适合快消、商贸等高频交易行业。</li><li><strong>Microsoft D365</strong>：Copilot AI可在Outlook中自动生成邮件草稿（基于客户历史沟通），在Teams中总结会议摘要并同步到CRM，大幅降低销售的文案工作量，适合依赖Office生态的企业。</li></ul><p><strong>流程图示例（Salesforce</strong> <strong>销售自动化</strong> <strong>）</strong> ：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436330" alt="" title=""/></p><pre><code>graph TD
    A[多渠道线索获取] --&gt; B[Einstein线索评分]
    B --&gt; C[Agentforce 360自动分配]
    C --&gt; D[AI跟进提醒（邮件/电话）]
    D --&gt; E[BANT商机评估]
    E --&gt; F[合同生成（关联ERP）]
    F --&gt; G[回款追踪（同步财务）]
    G --&gt; H[售后工单（Service Cloud）]
    H --&gt; I[Einstein复购预测]</code></pre><h3>2. 客户画像：从“信息整合”到“实时动态的需求预判”</h3><p>客户画像的价值在于<strong>让销售/营销人员“懂客户”</strong> ，差异体现在<strong>数据来源的广度</strong>与<strong>实时性</strong>：</p><ul><li><strong>SAP</strong>：整合ERP/SCM/销售数据，实时展示客户的“交易历史+当前库存状态+服务记录”，例如制造业客户可通过画像了解“某经销商的库存预警→需推送补货建议”，是供应链导向企业的首选。</li><li><strong>Salesforce</strong>：整合广告点击、社交媒体互动、线下活动等内外部数据，形成“从广告曝光到复购”的全链路视图，适合依赖品牌营销的企业。</li><li><strong>腾讯企点</strong>：深度整合微信生态（微信访客行为、公众号互动、朋友圈点赞），例如零售企业可通过画像了解“某客户在微信浏览过某商品→推送专属优惠券”，是社交获客企业的核心优势。</li><li><strong>超兔一体云</strong>：整合客户基本信息、交易记录、沟通行为（电话录音/外勤笔记），通过AI分组为“高价值客户（复购率30%+）、潜在客户（浏览过产品页）、流失客户（3个月未交易）”，适合中小商贸企业。</li></ul><h3>3. 营销管理：从“渠道覆盖”到“行业适配的自动化”</h3><p>营销管理的核心是<strong>精准触达+高效转化</strong>，差异体现在<strong>渠道整合能力</strong>与<strong>行业模板</strong>：</p><ul><li><strong>有赞（素材补充）</strong> ：针对电商场景设计“直播货架（总部/门店自播）+裂变分销”，支持“直播→下单→库存同步”全链路自动化，适合依赖直播获客的电商企业。</li><li><strong>SAP</strong>：提供“金融合规模板（反洗钱核查）”“制造供应链协同模板（经销商订货提醒）”，解决行业特殊需求，适合中大型行业客户。</li><li><strong>腾讯企点</strong>：聚焦社交营销，支持“微信裂变活动（邀请好友得优惠券）”“公众号精准推送（基于客户画像）”，适合中小微企业的低成本获客。</li><li><strong>Salesforce</strong>：Marketing Cloud覆盖广告、电子邮件、社交媒体、电子商务等全渠道，AI生成“个性化促销内容”（如节假日多语言模板），适合全球化企业。</li></ul><h3>4. 服务支持：从“响应速度”到“合规与体验”</h3><p>服务支持的核心是<strong>降低客户流失率</strong>，差异体现在<strong>全渠道覆盖</strong>与<strong>合规性</strong>：</p><ul><li><strong>Salesforce</strong>：Service Cloud支持电话、在线聊天、社交媒体（Twitter/微信）等全渠道，工单可自动关联“客户画像+历史服务记录”，例如客户咨询“产品维修”时，客服可直接查看“该客户的购买时间+上次维修记录”，提升解决效率。</li><li><strong>SAP</strong>：采用混合云架构，敏感数据（如财务/客户隐私）本地化存储，通过等保三级、ISO 27001认证，适合金融、医疗等强合规行业。</li><li><strong>超兔一体云</strong>：客服总控台支持“岗位特殊权限”（如投诉专员仅能查看投诉工单），售后工单可自动分配给“最近的维修人员”，并跟踪“维修进度→客户回访→满意度调查”，适合外勤密集型企业（如设备维修）。</li></ul><h3>5. 数据分析：从“统计报表”到“预测决策”</h3><p>数据分析的核心是<strong>用数据驱动业务</strong>，差异体现在<strong>BI</strong> <strong>能力</strong>与<strong>预测模型</strong>：</p><ul><li><strong>Salesforce</strong>：Tableau BI支持“实时可视化报表”（如销售漏斗转化率、区域业绩排名），Einstein AI可通过“客户历史购买行为+市场趋势”预测“某客户的复购概率”，例如零售企业可提前推送“复购优惠券”，提升客户忠诚度。</li><li><strong>Microsoft D365</strong>：Power BI可动态展示“销售漏斗的转化路径”（如线索→跟进→商机→合同的转化率），并通过自然语言查询（如“本月华东区销售额下降的原因”）生成分析报告，适合数据驱动型团队。</li><li><strong>超兔一体云</strong>：提供“同比环比引擎”“多表聚合引擎”，例如销售经理可通过“多表聚合”查看“某产品的销售数据+对应的采购成本+售后维修率”，快速定位“高毛利低售后的产品”。</li></ul><h3>6. 移动端AI集成：从“工具”到“智能助手”</h3><p>移动端AI集成的核心是<strong>让销售/客服在移动端“高效决策”</strong> ，差异体现在<strong>AI应用场景</strong>与<strong>数据联动</strong>：</p><ul><li><strong>Salesforce</strong>：Einstein AI在移动端提供“实时销售建议”，例如销售查看客户画像时，AI会提示“该客户上次购买了A产品，建议推荐配套的B产品”；Agentforce 360可自动生成“移动端报表”，无需人工整理。</li><li><strong>超兔一体云</strong>：AI待办可根据“销售行动记录”自动创建“下一步跟单任务”（如“某客户3天未跟进→提醒电话沟通”）；AI日报可一键生成“结构化销售日报”（含销售概述、客户意向评估、卡单问题点），减少销售的文案工作量。</li><li><strong>Microsoft D365</strong>：Copilot AI在移动端可“自动生成邮件草稿”（基于客户历史沟通），例如销售需要跟进“某商机”，Copilot会自动提取“上次会议的关键点→生成跟进邮件”，并同步到Outlook。</li></ul><h2>四、品牌定位与适用场景总结</h2><table><thead><tr><th>品牌</th><th>核心定位</th><th>适用场景</th></tr></thead><tbody><tr><td>超兔一体云</td><td>中小制造/快消企业的“轻量化全链路CRM”</td><td>快消、商贸、外勤密集型（设备维修/地推）企业</td></tr><tr><td>Salesforce</td><td>大型企业的“AI驱动全生命周期CRM”</td><td>金融、零售、全球化企业（需多渠道/多语言支持）</td></tr><tr><td>SAP</td><td>制造业/供应链导向企业的“ERP联动CRM”</td><td>制造、汽车、化工（需销售-供应链协同）</td></tr><tr><td>Microsoft D365</td><td>Office生态企业的“协同型CRM”</td><td>已使用Office/Teams的企业（需营销-销售-办公协同）</td></tr><tr><td>Zoho CRM</td><td>中小企业的“高性价比全功能CRM”</td><td>中小商贸、科技企业（需低成本搭建CRM体系）</td></tr><tr><td>销售易</td><td>工程/快消行业的“移动社交CRM”</td><td>工程、快消、外勤密集型企业</td></tr><tr><td>腾讯企点</td><td>微信获客企业的“社交化CRM”</td><td>零售、餐饮、中小微企业（依赖微信/QQ获客）</td></tr></tbody></table><h2>五、雷达图评分（1-10分，越高越优）</h2><table><thead><tr><th>品牌</th><th>销售自动化</th><th>客户画像</th><th>营销管理</th><th>服务支持</th><th>数据分析</th><th>移动端AI</th></tr></thead><tbody><tr><td>Salesforce</td><td>9</td><td>9</td><td>8</td><td>9</td><td>10</td><td>9</td></tr><tr><td>SAP</td><td>9</td><td>10</td><td>8</td><td>9</td><td>9</td><td>8</td></tr><tr><td>Microsoft D365</td><td>8</td><td>9</td><td>8</td><td>8</td><td>9</td><td>9</td></tr><tr><td>超兔一体云</td><td>8</td><td>7</td><td>7</td><td>8</td><td>7</td><td>8</td></tr><tr><td>Zoho CRM</td><td>8</td><td>7</td><td>7</td><td>7</td><td>8</td><td>8</td></tr><tr><td>销售易</td><td>8</td><td>8</td><td>7</td><td>8</td><td>8</td><td>8</td></tr><tr><td>腾讯企点</td><td>7</td><td>8</td><td>8</td><td>7</td><td>7</td><td>7</td></tr></tbody></table><h2>六、结论：如何选择适合的CRM？</h2><ol><li><strong>看企业规模</strong>：大型企业选Salesforce/SAP（全功能/ERP联动）；中小企业选超兔/Zoho（轻量化/高性价比）。</li><li><strong>看行业特性</strong>：制造/供应链选SAP；社交获客选腾讯企点；电商选有赞；Office生态选Microsoft D365。</li><li><strong>看核心需求</strong>：需AI自动化选Salesforce/Microsoft；需移动端效率选超兔/销售易；需合规选SAP。</li></ol><p>通过以上对比可见，CRM的价值已从“工具化”转向“业务赋能”，企业选型需聚焦<strong>自身业务场景</strong>与<strong>长期数字化规划</strong>，而非盲目追求“功能全面”。未来，AI与行业深度融合将是CRM的核心竞争力——谁能更精准地理解行业需求，并用AI驱动业务全链路，谁就能帮助企业在激烈竞争中占据先机。</p>]]></description></item><item>    <title><![CDATA[Nexpose 8.30.0 for L]]></title>    <link>https://segmentfault.com/a/1190000047436332</link>    <guid>https://segmentfault.com/a/1190000047436332</guid>    <pubDate>2025-11-28 16:04:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Nexpose 8.30.0 for Linux &amp; Windows - 漏洞扫描</p><p>Rapid7 on-prem Vulnerability Management, released November 2025</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=3Q2RhLUMW%2FCBbcyp0clCHw%3D%3D.MjV04aNclVBH%2Bo9aOP9JiKi7z4B7xp%2BO247WAoGHd6g%3D" rel="nofollow" target="_blank">https://sysin.org/blog/nexpose/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=eMW1TwOm86YKG4H5nELyBA%3D%3D.j%2FD4krj8%2FB3TK1pp%2Fv4yVDG87skSHrVU%2FwAQNk6OEiQ%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046370522" alt="Rapid7" title="Rapid7"/></p><p>Nexpose Vulnerability Scanner</p><p>本地部署的漏洞扫描器</p><p>一款强大的漏洞管理解决方案，可在整个环境中提供全面的资产可见性，同时协助风险的优先级排序与修复。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046832644" alt="Nexpose" title="Nexpose" loading="lazy"/></p><h2>工作原理</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046832645" alt="Collect" title="Collect" loading="lazy"/></p><h3>收集</h3><p>通过对整个网络的实时覆盖，随时掌握风险情况。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046832646" alt="Prioritize" title="Prioritize" loading="lazy"/></p><h3>优先级排序</h3><p>借助更具意义的风险评分，了解应优先关注哪些漏洞。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046832647" alt="Remediate" title="Remediate" loading="lazy"/></p><h3>修复</h3><p>为 IT 提供快速高效修复问题所需的信息。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046832648" alt="Quote Icon" title="Quote Icon" loading="lazy"/></p><p>评语：对于大型企业来说 —— 无论多大规模 —— 这款产品都非常值得考虑。它功能强大，具有可靠的历史表现与优秀的支持选项。</p><p>—— SC Magazine</p><h2>核心功能</h2><p><strong>助你在关键时刻采取行动的漏洞扫描软件</strong>。</p><h3>实际风险评分</h3><p>传统的 1-10 CVSS 分数往往会标记成千上万个“高危”漏洞。我们的漏洞扫描器采用实际风险评分（Real Risk  Score），提供更具可操作性的洞见 (sysin)。该评分不仅考虑漏洞的存在时间，还包括公开利用代码或恶意软件工具包等因素，1-1000  的评分范围可突显最有可能被攻击者利用的漏洞，助你优先处理真正关键的问题。</p><p>结合强大的标签系统，还可自动优先处理对你的业务最关键的系统。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046832649" alt="Real risk score" title="Real risk score" loading="lazy"/></p><h3>自适应安全</h3><p>“被动扫描”常伴随大量误报和陈旧数据，源自不频繁的数据导出。而借助 Nexpose 的自适应安全功能，一旦新设备或新漏洞访问你的网络，即可实现自动检测与评估。</p><p>结合与 VMware 和 AWS 的动态连接，以及与 Sonar 研究项目的集成，Nexpose 为你提供真正的实时环境监控。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046832650" alt="Adaptive security" title="Adaptive security" loading="lazy"/></p><h3>策略评估</h3><p>加强系统防护与发现并修复漏洞同样重要。</p><p>Nexpose 提供内置的策略扫描，帮助你依据 CIS 和 NIST 等主流标准对系统进行基准评估 (sysin)。直观的修复报告提供逐步指导，说明哪些操作将最显著提升合规性。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046832651" alt="Policy assessment" title="Policy assessment" loading="lazy"/></p><h3>修复报告</h3><p>修复报告列出可降低最大风险的前 25 项行动，并附有清晰的操作指南。</p><p>还可为管理层创建趋势报告，展示安全项目的投资回报与进展情况。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046832652" alt="Remediation reporting" title="Remediation reporting" loading="lazy"/></p><h2>新增功能</h2><p>Nexpose 最新发布</p><p>Nexpose 版本 <strong>8.30.0</strong> 此版本对控制台界面更新全新设计，并更新了多项策略内容，详见下载链接中。</p><h2>下载地址</h2><p><strong>Rapid7 Vulnerability Management - Nexpose</strong> v8.30.0 for Linux x64, November 2025</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=dEWgvaOXFQc%2B8AKSF0WsuQ%3D%3D.ISfV2pFjVFLVNI9KOtHEb8LJbLKsd33eC4yIO0hv%2B5E%3D" rel="nofollow" target="_blank">https://sysin.org/blog/nexpose/</a></li></ul><p><strong>Rapid7 Vulnerability Management - Nexpose</strong> v8.30.0 for Windows x64, November 2025</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=eNgmKPnQmtWcrBvYdTGnTw%3D%3D.0rvXMeKKW9xMVT2pq3QHIEJR%2B%2BRWjhv9Wfr4GALVtSE%3D" rel="nofollow" target="_blank">https://sysin.org/blog/nexpose/</a></li></ul><p>相关产品：</p><ul><li><a href="https://link.segmentfault.com/?enc=xO6sYCIAHgL%2FTEswJCnO%2Bw%3D%3D.azIMTYBdGuKun4TyKtvVYAVvjuSHA%2BPObYsKD3iGEd1OyFzQhV9M0hNdDGDSRKx9" rel="nofollow" target="_blank">Metasploit Pro 4.22.9 (Linux, Windows) - 专业渗透测试框架</a></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=2qjRvotj4ZUnM6Ffe3drmQ%3D%3D.%2BE6MXUNQfs0xdAalc0rGMY5HiU2HrUGHTE7swwlcbXw%3D" rel="nofollow" target="_blank">HTTP 协议与安全</a></p>]]></description></item><item>    <title><![CDATA[Nessus Professional ]]></title>    <link>https://segmentfault.com/a/1190000047436341</link>    <guid>https://segmentfault.com/a/1190000047436341</guid>    <pubDate>2025-11-28 16:03:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Nessus Professional 10.11 Auto Installer for RHEL 10, AlmaLinux 10, Rocky Linux 10 - Nessus 自动化安装程序</p><p>发布 Nessus 试用版自动化安装程序，支持 macOS Tahoe、RHEL 10、Ubuntu 24.04 和 Windows</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=51qNdSAFk5SlanEDgNJt1A%3D%3D.qVLWBK6jZfLmYF5NU1%2BjhTyDq%2FTrLEbwJpiDZOuX6hJhrgH4ssurcexgf9tz0shukM3znqRd9%2Fn6R43mHzZwSQ%3D%3D" rel="nofollow" target="_blank">https://sysin.org/blog/nessus-auto-install-for-rhel-9/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=NiH17HqZduYbpHs2o7Tucg%3D%3D.LFzASE4j4IvCv3iCpHZsYGMKDXDmj9iWx3QsO8keMQw%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><h2>Nessus 简介</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436343" alt="Nessus" title="Nessus"/></p><p>Nessus Vulnerability Scanner</p><p><strong>漏洞评估领域的全球黄金标准</strong>，<strong>针对现代攻击面量身打造</strong>。</p><p>利用业界最受信赖的漏洞评估解决方案来评估现代攻击面。扩展到传统的 IT 资产之外 – 保护云基础设施和获取对与互联网相连的攻击面的可见性。</p><p><strong># 1 准确度</strong>：</p><p>Nessus 达到了 6 西格玛准确度，实现了业内最低的误报率</p><p>*每 100 万次扫描中仅有 0.32 次误报</p><p><strong># 1 覆盖面</strong>：</p><p>Nessus 拥有业内首屈一指的漏洞覆盖面深度和广度</p><p><strong># 1 采用率</strong>：</p><p>Nessus 深受数万家企业的信赖，全球下载次数达到 200 万次</p><p><strong># 1 口碑信誉</strong>：</p><p>口说无凭，无需赘言。为何全球安全专业人士对 Nessus 的信赖让您眼见为实</p><p><strong>Nessus 在漏洞评估领域一路领先</strong>！</p><p>从创立伊始，我们就与各类网络安全相关行业紧密协作。我们根据业界的反馈持续优化  Nessus，将其打造成市场中最准确全面的漏洞评估解决方案。20 年以来，我们不忘初心，始终专注于业界协作与产品创新  (sysin)，建立起最准确全面的漏洞数据库，让您的企业不会因忽视重要漏洞而暴露于风险之中。</p><p>今天，Nessus 深受全球数万家企业的信赖，是全球部署最为广泛的安全技术之一，而且是漏洞评估行业的黄金标准。</p><p><strong>94K+</strong> 个 CVE</p><p><strong>226,000+</strong> 款插件</p><p><strong>100+</strong> 款新插件，每周定期发布</p><p>Tenable 的零日研究对新漏洞和紧急漏洞提供全天候更新，因此您将始终具有全面的态势感知。</p><h2>自动化安装 Nessus 试用版</h2><p>Nessus 官方提供了试用版，可供个人学习和研究使用，主要功能没有限制，只是没有任何支持服务。网上文章冠以和谐版称之，是不存在的。个人学习和测试效果好，也是将来的潜在客户，Nessus 官方本来就支持试用的。</p><p>本程序只是将公开的方法简化一次性执行，降低试用门槛或者节约使用者的宝贵时间。运行效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047333548" alt="nessus-10-auto-installer" title="nessus-10-auto-installer" loading="lazy"/></p><h2>系统要求</h2><p>要求 RHEL 9 x86_64 及其兼容发行版（程序有支持 aarch64 的能力，但未发布）。</p><ul><li><a href="https://link.segmentfault.com/?enc=K%2F6EVy7yQ8vchFPUcShUKA%3D%3D.TNqcujIhXWea7Bw77eIureBcdG%2BsaDSiDvVC%2FBcejxA%3D" rel="nofollow" target="_blank">Red Hat Enterprise Linux (RHEL) 9 x86_64</a></li><li><a href="https://link.segmentfault.com/?enc=Vb6%2Bs8bjyG0PfkzaSBrvPw%3D%3D.QreLBztI%2BOh2ij87V8lL8%2BiU76HkyNiDzisFOgwznhYZUIUs70VtWG03hog%2BYPrC" rel="nofollow" target="_blank">AlmaLinux 9 x86_64</a>（<a href="https://link.segmentfault.com/?enc=OOC3kn8xxiwWcb9U9KGBeA%3D%3D.OMmP7aJDdv%2B2iXiCyNgEJcUrZ1VCTRprBPXJaFVxLKm%2BFY6dZHu17NjPirbhuYT9" rel="nofollow" target="_blank">OVF</a>）</li><li><a href="https://link.segmentfault.com/?enc=4TokMlXAAlXU8PtZaYLEYw%3D%3D.etHJ4j5dYFD4Xrum1ATJVUY59GL7ysFwwbkYOEW0KDtSEKYycwN%2FdFUaS%2BQZTxu7" rel="nofollow" target="_blank">Rocky Linux 9 x86_64</a>（<a href="https://link.segmentfault.com/?enc=j5gNVgdaq26IgBr7IWp2CA%3D%3D.G1useX1vvT9YDPXZZNTJl1F7GJzd59qaaf7rJqrgyRDGD16B1kGqJeBOG3C0Fa8s" rel="nofollow" target="_blank">OVF</a>）</li><li><a href="https://link.segmentfault.com/?enc=4K%2Fy2ctPVmgS%2BYTNHJaNzg%3D%3D.OzKraF7EV%2BA4YKkZ%2BO5aZDcqkd7m%2BnaDZKpFo3IFUO5OJZH9IDJ5y9PQIpQ136ZE" rel="nofollow" target="_blank">Oracle Linux 9 x86_64</a></li></ul><p>要求 RHEL 10 x86_64 及其兼容发行版（程序有支持 aarch64 的能力，但未发布）。</p><ul><li><a href="https://link.segmentfault.com/?enc=4obojBAYjmkJURE1HeH3Iw%3D%3D.AKe19192kzjEas%2B0YGCJVPGHnwOJnIqZla6U71nnZGI%3D" rel="nofollow" target="_blank">Red Hat Enterprise Linux (RHEL) 10 x86_64</a></li><li><a href="https://link.segmentfault.com/?enc=YaoedHDihcgkbY%2F86BpEAQ%3D%3D.eNgEhIGVaYJIzldTxit81E5qTU3pr%2FTGX%2B4%2FXxAKRPQTpulrQ1fqWWvNPmfLptYB" rel="nofollow" target="_blank">AlmaLinux 10 x86_64</a>（<a href="https://link.segmentfault.com/?enc=86n%2BCWbqtHl%2F3aB55FsVDw%3D%3D.MfpPMozWYIGWmAr87f%2BSj%2Bcu5cO43VXhQNyeKpavwSdl49BByfhQDGPuKAEpARIi" rel="nofollow" target="_blank">OVF</a>）</li><li><a href="https://link.segmentfault.com/?enc=2s8SvoRA%2BFAFHHixllDENA%3D%3D.J0Ze2Fh1vH4m%2FMaicsfjJfJ8H%2ByLiKX1ZGhpUuqEjUdn9oxF1KbEI%2Bv%2BLruB4DtI" rel="nofollow" target="_blank">Rocky Linux 10 x86_64</a>（<a href="https://link.segmentfault.com/?enc=n%2FkyUd37uDnDVkzkkDIUew%3D%3D.5Gox1INQAKqbP7NEFtPVaGo3M5rm2oH2p1kR6gQ7HZ5mns179%2FOHUlYbhDiADAf8" rel="nofollow" target="_blank">OVF</a>）</li><li><a href="https://link.segmentfault.com/?enc=zLmPsXJqXVPx%2FSqU%2BgW3Kg%3D%3D.9kwf5T2YFYeen9ftfLwtvj1k6lI58q87rp%2B0iAyyGpTd%2Fc8CQGgd6UdHrZyPIA4o" rel="nofollow" target="_blank">Oracle Linux 10 x86_64</a></li></ul><p>建议运行在虚拟机环境中，<strong>推荐使用本站原创虚拟机模板 OVF</strong>，简单，精准，高效。</p><h2>下载地址</h2><p><strong>Nessus 10.11 Auto Installer</strong> for RHEL 9/10, AlmaLinux 9/10, Rocky Linux 9/10</p><ul><li>请访问：<a href="https://link.segmentfault.com/?enc=gPBchdOP%2FRO4YEEFy3lu5w%3D%3D.qYtTeyvn1ZWIlr6iRStaOnGHhY9fazHvVt9RAldU%2FUbmESAwv6x2ZflhO2Hvl%2B3v7jf0d3WayT4csO5hjg2Eqw%3D%3D" rel="nofollow" target="_blank">https://sysin.org/blog/nessus-auto-install-for-rhel-9/</a></li></ul><hr/><p>发布 Nessus 试用版自动化安装程序，支持 macOS Tahoe、RHEL 10、Ubuntu 24.04 和 Windows</p><ul><li><a href="https://link.segmentfault.com/?enc=kvkESGeTOtpSOwzEnXI8fw%3D%3D.bZQsq4AtG9jT19wlkVA4d%2FDxUVa7thdd2loDNL5d8xM5U8N3uNh%2F0GgUwnhb04jsx21leu1PNguram%2BMhci3bQ%3D%3D" rel="nofollow" target="_blank">Nessus Professional 10.11 Auto Installer for macOS Tahoe - Nessus 自动化安装程序</a></li><li><a href="https://link.segmentfault.com/?enc=BVA4HE3lVIBLklzrfvN8Cg%3D%3D.uN88sP3hc3QaAf1Btp%2FhDr5Eae10dcqOZQgXpC1wDCBJmSsgQj6P7%2FozKUQY9tItk%2Fyv%2BnqFoN8caAfop3r%2FLA%3D%3D" rel="nofollow" target="_blank">Nessus Professional 10.11 Auto Installer for RHEL 10, AlmaLinux 10, Rocky Linux 10 - Nessus 自动化安装程序</a></li><li><a href="https://link.segmentfault.com/?enc=aTc64oohOEXy1ppKHOhhfg%3D%3D.SClt7mPblpII5jRfvVEqjUXwubKGS83id%2BmLek3HShrmjMGAISuXSsr7V1fPFTIkP3VgfGilYmpjzdftYWeXmA%3D%3D" rel="nofollow" target="_blank">Nessus Professional 10.11 Auto Installer for Ubuntu 24.04 - Nessus 自动化安装程序</a></li><li><a href="https://link.segmentfault.com/?enc=tonnVeyI4HK5fPgqNXHykA%3D%3D.T31njDOb%2BWFnK4aEQZNymM3wPg%2Fad%2F6zbWZOEUo2kYlpTkMB5FFG5C7CBt33%2BoIm9%2FWIbSqG5Mr639HP6gMsoA%3D%3D" rel="nofollow" target="_blank">Nessus Professional 10.11 Auto Installer for Windows - Nessus 自动化安装程序</a></li></ul><p>Nessus 10 系列版本下载</p><ul><li><a href="https://link.segmentfault.com/?enc=T3knfE3B08d9WFFO7uF4hg%3D%3D.of1n%2FpTDSjsX6eALpMcenQ2gXkANDb1sZfFMbCxEqdWlD2syuQIrT28y0LQmgrEa" rel="nofollow" target="_blank">Tenable Nessus 10.11 (macOS, Linux, Windows) - 漏洞评估解决方案</a></li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=rzh3eB3hNM9rhAx7whxE4w%3D%3D.lNleL%2BIg8FKQYs62rqXBIF3MNeqZbaM40iW4yI7k5V0%3D" rel="nofollow" target="_blank">HTTP 协议与安全</a></p>]]></description></item><item>    <title><![CDATA[汉得集星獭1.9.0正式发布：高效集成，]]></title>    <link>https://segmentfault.com/a/1190000047436361</link>    <guid>https://segmentfault.com/a/1190000047436361</guid>    <pubDate>2025-11-28 16:02:46</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436364" alt="" title=""/><br/><strong>汉得企业级系统集成平台（中文名集星獭，英文名JeeStar）1.9.0版本于2025年11月正式发布。</strong> 集星獭是一款一站式多系统集成、多云集成、多端集成、多协议集成、多设备集成、数据集成、页面集成的全域集成解决方案产品。</p><p>此次发布主要聚焦于以下三个方面进行产品功能升级与优化，致力于为企业提供更全面、更稳定、更高效的集成解决方案！</p><ul><li><strong>推出高性能编排模式</strong>：服务编排新增高性能编排模式，专为高并发、低延迟的实时集成场景而设计</li><li><strong>构建API操作审批流程</strong>：全新引入API操作申请与审批机制，筑起API操作安全网，通过审批流程实现关键变更的精准管控</li><li><strong>引入多种实用编排节点并强化现有能力</strong>：扩展新增Excel读取、CSV读取节点、日志打印、抛出异常等节点，并优化DataX环境检测功能，大幅提升编排流程的开发效率与可靠性</li></ul><h2>一、推出高性能编排模式</h2><p>原编排模式（分布式编排）适用于异步定时调度、大数据处理、高可用等场景，更关注可用性和故障处理，但是在高并发实时性响应、吞吐量方面性能并不理想。为此产品<strong>新增高性能编排模式</strong>，能够轻松处理高并发、大流量的数据处理场景，<strong>保证数据传输的低延迟和高吞吐</strong>。</p><p>两种编排模式可协同作战（全部部署），也可以根据需求针对性地只部署其中一种模式。分布式编排负责重负载、定时批处理任务流，高性能编排专注于轻量级、实时、事件驱动的数据流。</p><h3>1. 编排流程编辑</h3><p>编排定义、应用连接器流程编辑界面能使用的任务节点种类会根据所选择的编排类型不同而有所差异，但是结果传递与结果取值在两种模式下完全一致。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047436365" alt="" title="" loading="lazy"/><img referrerpolicy="no-referrer" src="/img/remote/1460000047436366" alt="" title="" loading="lazy"/></p><h3>2. 内置丰富高性能应用连接器</h3><p>内置腾讯文档、百度地图、钉钉机器人、飞书、12306等几十种高性能版本的应用连接器，同时支持自定义扩展。<img referrerpolicy="no-referrer" src="/img/remote/1460000047436367" alt="" title="" loading="lazy"/></p><h3>3. 内置丰富高性能任务组件与技术连接器</h3><p>内置支持与上百种常见技术栈的连接，省去重复编写适配器代码的麻烦，<strong>实现“即连即用”</strong>；提供数据映射、内容过滤、消息转换、错误处理等大量企业集成模式，<strong>满足复杂的业务逻辑编排需求</strong>。</p><p>如下是部分应用组件截图：<img referrerpolicy="no-referrer" src="/img/remote/1460000047436368" alt="" title="" loading="lazy"/></p><p>如下是部分数据处理器截图：<img referrerpolicy="no-referrer" src="/img/remote/1460000047436369" alt="" title="" loading="lazy"/></p><h3>4 .高性能编排运行</h3><p>高性能编排保存发布时会往接口服务自动注册接口且一个接口对应唯一一个编排，服务代码为：ORCHESTRATION_SONIC，接口代码和接口名称分别对应编排编码和编排名称。</p><p>针对非监听类的编排通过调用透传接口触发调用编排；针对监听类的编排(MQ监听、SFTP监听等)，编排一经发布即为正在运行监听。<img referrerpolicy="no-referrer" src="/img/remote/1460000047436370" alt="" title="" loading="lazy"/></p><h3>5. 高性能编排性能提升</h3><p>压测场景包括三个任务节点，场景为先查询电商订单交易数据，再将查询后的数据经过处理加工，最后将加工后的数据落库；最终使用接口方式同步调用编排流程。</p><p>如下表格为不同编排模式下连续压测接口10分钟的QPS：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047436371" alt="" title="" loading="lazy"/><br/>编排同步调用接口的<strong>QPS从800提升至14000</strong>，性能提升了<strong>近18倍</strong>。</p><h2>二、构建API操作审批流程</h2><p>此前API、编排的发布、禁用等高风险操作往往依赖于操作人员的个人判断，缺乏必要的监督与复核机制，存在潜在的安全与稳定性风险。</p><p>操作申请审批功能管控API、服务编排、连接器的发布、启动、禁用、删除操作，前置机的上线、禁用、删除操作。</p><ul><li><strong>申请配置</strong><br/>可根据各企业需要灵活配置为无审批、功能性审批、工作流审批<img referrerpolicy="no-referrer" src="/img/remote/1460000047436372" alt="" title="" loading="lazy"/></li><li><strong>申请记录&amp;申请审批</strong><br/>新增我的操作申请菜单界面，用于查询本人的申请记录；新增操作申请审批菜单界面，用于查询待审批的待办记录、已审批的记录历史，以及完成审批申请操作<img referrerpolicy="no-referrer" src="/img/remote/1460000047436373" alt="" title="" loading="lazy"/></li><li><strong>申请状态控制</strong><br/>处于审核中的API、编排、连接器、前置机无法进行发布、删除等变更数据的操作<img referrerpolicy="no-referrer" src="/img/remote/1460000047436374" alt="" title="" loading="lazy"/></li></ul><h2>三、引入多种编排节点并强化现有能力</h2><h3>1. Excel读取节点</h3><p>能够根据预设规则，智能地将Excel表格数据转化为编排流程可识别的结构化信息，实现了数据读取的灵活配置与标准化输出。</p><p>支持选择模板文件，将Excel列自动带出，提高编排效率；可以精确定义输出数据的结构，包括每个字段的名称、类型和格式；支持设置从表格的特定行开始读取，有效跳过表头等非数据行。<img referrerpolicy="no-referrer" src="/img/remote/1460000047436375" alt="" title="" loading="lazy"/></p><h3>2. CSV读取节点</h3><p>通过可视化配置，智能解析CSV文件（包括压缩包），并将其按预设的字段结构转换为流程可用的标准化数据，实现数据源的便捷接入。</p><p>支持自定义分隔符（如逗号、制表符）和编码格式，能自动识别文件格式，并可处理压缩包内的文件；允许跳过指定行数（如表头）；可以精确定义输出数据的结构，包括每个字段的名称、类型。<img referrerpolicy="no-referrer" src="/img/remote/1460000047436376" alt="" title="" loading="lazy"/></p><h3>3. 日志打印节点</h3><p>通过可视化配置，无需编写代码，即可为关键步骤输出具有业务语义的、标准化的日志，从而方便运维监控和快速定位问题。<img referrerpolicy="no-referrer" src="/img/remote/1460000047436377" alt="" title="" loading="lazy"/></p><h3>4. 抛出异常节点</h3><p>该节点用于提升编排流程的健壮性与可控性，实现主动的、条件化的流程中断与错误上报。</p><p>可自定义异常信息(支持多语言)，使得运维或开发人员能够快速、精准地定位问题根因，极大提升排查效率。<img referrerpolicy="no-referrer" src="/img/remote/1460000047436378" alt="" title="" loading="lazy"/></p><h3>5. DATAX节点新增环境检测功能</h3><p>该功能提供一键式的自动化检查，在任务执行前对运行环境进行全面的健康检测，主动发现并排除环境隐患，有效避免任务因环境问题而失败，确保DataX数据同步任务的稳定性和可靠性。<img referrerpolicy="no-referrer" src="/img/remote/1460000047436379" alt="" title="" loading="lazy"/></p><h2>结语</h2><p>集星獭本次版本发布通过引入高性能编排让集成处理更强大高效，通过构建操作审批流程让企业管控更安全，通过丰富任务节点让复杂场景的实现更简单。</p><p>通过持续优化产品能力，构筑起一个更稳定、可靠、高效的企业级集成中台，加速业务协同与数据流通！</p><h2>更多升级参考资料</h2><p>还有更多新版本的特性，请点击以下链接直达企业级数字化 PaaS 平台查看：<br/><a href="https://link.segmentfault.com/?enc=suvZb72KSRsJSufUUZOrLg%3D%3D.T43RIgjNV82UUv%2B%2B39A85jadhz14PtQuqvNYPbxun9uz5AVWTlua4fhUqZ6arr6zjVp6I6PvsNE685HVZFFwwgDWVSMp0omzieJ8fT51bV0ZirG3w6CC8R8KdCdTclGzCh5%2F%2BEN3I7xP8L1Beh19cQ%3D%3D" rel="nofollow" target="_blank">JeeStar 1.9.0.RELEASE更新日志</a></p>]]></description></item><item>    <title><![CDATA[IPD 为什么在很多企业变成「形式主义」]]></title>    <link>https://segmentfault.com/a/1190000047436435</link>    <guid>https://segmentfault.com/a/1190000047436435</guid>    <pubDate>2025-11-28 16:01:59</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>IPD（集成产品开发）作为一种整合式的研发管理方法，已被许多企业引入以提升跨部门协作与研发效能。然而在实际应用中，很多企业仍面临 IPD 落地难、效果不显著的问题。本文将探讨 IPD 在企业中的实际应用难题，并提出行之有效的改进路径，帮助企业实现更高效的研发管理和产品开发。</blockquote><p>在很多硬件研发企业中，IPD 流程往往变得形式化。典型的情况包括：</p><ul><li>TR 评审：从关键决策变成“流程走过场”，大家忙着准备 PPT，而非讨论核心问题。</li><li>项目立项：决策过程往往缺乏市场和技术验证，流程变成了事后的补充，评审变得注重格式而非深度分析。</li><li>组织协同：虽然图上有矩阵组织，实际工作中各职能部门的目标往往不统一，导致跨部门协作效果差，问题经常推诿。</li></ul><p>这些现象表明，IPD 的流程虽然存在，但其核心价值——作为战略决策工具、提升研发效能的机制——却没有真正落地。</p><h2>IPD 为什么会变成形式主义？三个根因分析</h2><p>为了把重心放在“怎么解决”上，这里只聚焦三个根因，每一个都直接对应后文的方法论。</p><p><strong>1. 定位错误：把 IPD 当流程，而不是投资与业务决策机制</strong></p><p>IPD 的核心目的是使产品开发成为“可度量、可选择的投资组合”，这要求管理层以决策为导向，评估每个项目的投资价值和风险。然而，很多企业在实施时，忽视了这一点，把 IPD 仅仅当作一个流程化的工具，强调文件和评审节点的完备性，却没有真正推动战略决策的转变。投资决策机制的缺失，导致流程无法产生实际效益。</p><p><strong>2. 基础薄弱：系统工程与 ALM 数据抓手不足</strong></p><p>IPD 强调从战略到执行的全链条管理，需要依赖系统工程和ALM平台的支持。然而，很多企业没有有效的数据管理和工具基础，需求、设计、测试、缺陷等信息分散在不同系统中，缺乏统一的数据视图。这使得项目管理缺乏数据支持，决策变得主观，流程很难实现可视化、可度量。</p><p><strong>3. 组织配套不到位：激励、角色与能力没有同步演进</strong></p><p>IPD 是跨部门协同的管理框架，但很多企业的组织结构、角色与激励机制并没有与之匹配。各职能部门仍然以自身绩效为导向，缺乏对产品成功的整体视野。PMO、产品经理、系统工程师等关键角色的职责不清，且绩效考核未能鼓励跨部门协作和系统性思维，从而导致 IPD 流程无法真正发挥作用。</p><h2>从形式到实质：一个「IPD 落地四层模型」</h2><p>为了让 IPD 从形式化回到实质性运作，以下是一个可操作的四层破局模型。通过逐层解决定位错误、基础薄弱和组织配套不到位等问题，推动 IPD 成为企业的核心能力。</p><h4>第一层：战略与投资组合——先把“做什么项目”选对</h4><p><strong>先做的事：</strong></p><p>建立简单且真实的投资组合视图：明确产品线、技术平台及优先级，用“战略匹配度、财务回报、技术/执行风险”三大维度评估项目。</p><p><strong>要避免的事：</strong></p><p>把 TR 当成“流程审批”，不讨论项目的投资价值和优先级。每个 TR 评审节点，增加判断“今天是否继续投资”的关键问题。</p><p><strong>可升级的事：</strong></p><p>结合财务和资源数据，通过 PPM（产品组合管理）优化项目选择，避免资源被低回报项目占用。</p><h4>第二层：端到端流程与系统工程——流程不求多，但活动必须对</h4><p><strong>先做的事：</strong></p><p>为不同类型的项目设计“轻重有别”的流程族，根据项目类型（例如平台/预研、全新产品、定制项目）调整评审节点，减少冗余环节。</p><p><strong>要避免的事：</strong></p><p>仅仅通过增加评审会议和流程节点来控制进度，忽视系统工程方法。要确保每个阶段的关键活动，如系统级需求分析、架构评审等，能够有效地识别和降低风险。</p><p><strong>可升级的事：</strong></p><p>指定“系统工程牵头人”，在试点项目中推动系统级设计、接口治理和集成测试等活动，逐步积累经验并推广。</p><h4>第三层：数字化 ALM 支撑——给 IPD 一个“数据骨架”</h4><p><strong>先做的事：</strong></p><p>建立统一的 ALM 平台，集中管理需求、任务、缺陷、测试等信息，确保所有项目数据都能实时追踪，比如 ONES 研发管理平台等。</p><p><strong>要避免的事：</strong></p><p>把 ALM 仅仅当作文档存储工具，缺乏数据驱动决策的意识。在评审会中，应当通过 ALM 提供的“数据视图”来判断项目状态，而非依赖手工整理的报告。</p><p><strong>可升级的事：</strong></p><p>将 ALM 系统与财务数据、资源占用等系统打通，形成完整的投入与产出视图，以支持更精确的投资决策和资源分配。</p><h4>第四层：组织与能力建设——让 IPD 成为“大家的事”</h4><p><strong>先做的事：</strong></p><p>明确角色和责任，确保产品经理、系统工程师、项目经理和 PMO 在 IPD 流程中的职责分工清晰，并对每个角色的贡献进行量化考核。</p><p><strong>要避免的事：</strong></p><p>依旧让各职能部门各自为政，没有合力。避免 KPI 只关注局部效益，要将跨部门协同和产品/项目级别的目标纳入考核体系。</p><p><strong>可升级的事：</strong></p><p>通过项目复盘和跨部门轮岗培训，逐步培养“IPD 复合型人才”，让团队成员不仅理解自己的职能，还能理解整个产品开发过程中的系统性挑战。</p><p><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdk1zs" alt="IPD 落地的方法" title="IPD 落地的方法"/></p><h2>IPD 不缺流程，缺的是一套协同演化的“操作系统”</h2><p>IPD 为什么落不了地，表面上看是流程复杂、评审繁琐，深层原因在于：</p><ul><li>没有将 IPD 用于真正的投资决策，导致项目无法有效优先级排序；</li><li>缺乏系统工程和 ALM 基础，导致项目管理缺乏数据支持和可控性；</li><li>组织结构和激励机制与 IPD 流程未能同步演进，跨部门协同效果差。</li></ul><p>真正的破局路径需要在战略、流程、数据和组织能力上同步发力。通过逐步打通这四个层面，IPD 才能从“形式主义”走向“价值驱动”，成为提升研发效能和交付质量的核心能力。</p>]]></description></item><item>    <title><![CDATA[在企业级 Java 中应用领域驱动设计：]]></title>    <link>https://segmentfault.com/a/1190000047436494</link>    <guid>https://segmentfault.com/a/1190000047436494</guid>    <pubDate>2025-11-28 16:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>了解如何结合 DDD 和 BDD 于企业级 Java 中，以创建能够模拟真实业务领域并通过可执行场景验证行为的软件。</blockquote><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436496" alt="" title=""/></p><p>在软件开发领域，最大的错误之一就是交付客户"精确"想要的东西。这听起来可能像陈词滥调，但即使在行业摸爬滚打数十年后，这个问题依然存在。一个更有效的方法是从关注业务需求开始测试。</p><p><strong>行为驱动开发</strong>【<a href="https://link.segmentfault.com/?enc=nuaHWa9jIIgG9FxE2ztVjw%3D%3D.Exp4xo8axH7IU6DaM70tFkJ2UNBTVkUc3KUrxVmTK7i544V0DvwKHUfS%2FHfwgex9DJPIRRaTEzA0%2FPGmw%2BrP0g%3D%3D" rel="nofollow" target="_blank">Behavior-driven development</a>】（<strong>BDD</strong>）是一种强调行为和领域术语（也称为<strong>统一语言</strong>）的软件开发方法论。它使用共享的自然语言，从用户的角度定义和测试软件行为。BDD 建立在<strong>测试驱动开发</strong>【<a href="https://link.segmentfault.com/?enc=ZOILautoNYWRXY2A1qhSJg%3D%3D.41qQqN3XTLRQZkPTyT7r94FJymF%2BiqWzDovhXnG8Sa94ukSrC3yyNxpA3O9s8i8EcjwXf1oKLHT5PpLh8Hi8ttSfnVawg7H0HnUqWt8EVJM%3D" rel="nofollow" target="_blank">test-driven development</a>】（<strong>TDD</strong>）的基础上，专注于与业务相关的场景。这些场景以纯语言规范的形式编写，可以自动化成测试，同时也充当活文档。</p><p>这种方法促进了技术和非技术利益相关者之间的共识，确保软件满足用户需求，并有助于减少返工和开发时间。在本文中，我们将进一步探讨这种方法论，并讨论如何使用 Oracle NoSQL 和 Java 来实现它。</p><h2>BDD 与 DDD 如何协同工作</h2><p>乍看之下，行为驱动开发（BDD）和领域驱动设计（DDD）似乎解决的是不同的问题——一个侧重于<em>测试</em>，另一个侧重于<em>建模</em>。然而，它们共享相同的哲学基础：确保软件真实反映其所服务的<strong>业务领域</strong>。</p><p><strong>DDD</strong>，由 Eric Evans 在其 2003 年具有开创性的著作<em>《领域驱动设计：软件核心复杂性的应对之道》</em>中提出，教导我们围绕业务概念（实体、值对象、聚合和限界上下文）来建模软件。其力量在于使用<strong>统一语言</strong>，这是一种连接开发人员和领域专家的共享词汇表。</p><p><strong>BDD</strong>，由 Dan North 在几年后提出，是这一思想自然而然的延伸。它将统一语言引入测试过程，将业务规则转化为可执行的规范。DDD 定义了系统应该表示<em>什么</em>，而 BDD 则根据该模型验证系统的<em>行为方式</em>。</p><p>当结合使用时，DDD 和 BDD 形成了一个持续的反馈循环：</p><ul><li>DDD 塑造了捕获业务逻辑的<strong>领域模型</strong>。</li><li>BDD 确保<strong>系统行为</strong>随着时间的推移与该模型保持一致。</li></ul><p>在实践中，这种协同作用意味着您可以编写与聚合（如 Room 和 Reservation）直接相关的特性场景——例如"当我预订一个 VIP 房间时，系统应将其标记为不可用"。这些测试成为开发人员和利益相关者的活文档，确保您的领域始终与真实的业务需求保持一致。</p><p>如果您想深入探索这种结合，我的著作<a href="https://link.segmentfault.com/?enc=Rvm87Ps1PTF49YP%2BrrJTBQ%3D%3D.%2BafnlDW9HwTzvdlMRjPtF1rkiOX1Z48NdVZn57AZqwFTDCJcXUqnv1kRf948nsbLxdscpZrpaqu7e0JBXox8VA%3D%3D" rel="nofollow" target="_blank">《Domain-Driven Design with Java》</a>详细阐述了这些原则。它展示了如何在现代 Java 应用程序中使用 Jakarta EE、Spring 和云技术应用 DDD 模式，为统一架构和行为提供了实践基础。</p><p>总之，DDD 和 BDD 共同弥合了理解业务与证明其可行之间的差距——将软件从技术制品转变为领域本身的忠实表达。</p><h2>代码实现</h2><p>在本示例中，我们将使用企业级 Java 和 Oracle NoSQL 数据库生成一个简单的酒店管理应用程序。</p><p>第一步是创建项目。由于我们使用的是 Java SE，我们可以使用以下 Maven 命令生成它：</p><pre><code class="shell">mvn archetype:generate                     \
"-DarchetypeGroupId=io.cucumber"           \
"-DarchetypeArtifactId=cucumber-archetype" \
"-DarchetypeVersion=7.30.0"                \
"-DgroupId=org.soujava.demos.hotel"        \
"-DartifactId=behavior-driven-development" \
"-Dpackage=org.soujava.demos"              \
"-Dversion=1.0.0-SNAPSHOT"                 \
"-DinteractiveMode=false"</code></pre><p>下一步是引入 <strong>Eclipse JNoSQL</strong> 与 <strong>Oracle NoSQL</strong>，以及 <strong>Jakarta EE 组件的实现</strong>：CDI、JSON 和 Eclipse MicroProfile 实现。</p><p>您可以找到完整的 <a href="https://link.segmentfault.com/?enc=%2B8M8LMw2fL%2FNrM3qtGms3w%3D%3D.2X9f1Q4pG%2B50xr4R9Bgbr0y0isG57EVE3IQRJKXtSDMkBaZHDpMjEU2ySNfl3pq9%2BLcxz0OFQeBhscVvCO5fZp8XlV4bQtz1tsT0ahSNMljSa%2BqAD1emYLvTraKIuetd" rel="nofollow" target="_blank"><code>pom.xml</code></a> 文件。</p><p>初始项目准备就绪后，我们将从创建测试开始。</p><p>请记住，BDD 是 TDD 的扩展，它包含了统一语言——领域和业务之间的共享词汇。</p><pre><code class="textile">功能: 管理酒店房间

  场景: 注册一个新房间
    假设 酒店管理系统正在运行
    当 我注册一个号码为 203 的房间
    那么 号码为 203 的房间应该出现在房间列表中

  场景: 注册多个房间
    假设 酒店管理系统正在运行
    当 我注册以下房间:
      | number | type      | status             | cleanStatus |
      | 101    | STANDARD  | AVAILABLE          | CLEAN       |
      | 102    | SUITE     | RESERVED           | DIRTY       |
      | 103    | VIP_SUITE | UNDER_MAINTENANCE  | CLEAN       |
    那么 系统中应该有 3 个可用房间

  场景: 更改房间状态
    假设 酒店管理系统正在运行
    并且 一个号码为 101 的房间已注册为 AVAILABLE
    当 我将房间 101 标记为 OUT_OF_SERVICE
    那么 房间 101 应被标记为 OUT_OF_SERVICE</code></pre><p>Maven 项目完成后，让我们进入下一步，即创建建模和存储库。如前所述，我们将专注于房间管理。因此，我们的下一个目标是确保之前定义的 BDD 测试通过。让我们从实现领域模型和存储库开始：</p><pre><code class="java">public enum CleanStatus {
    CLEAN,       // 清洁
    DIRTY,       // 脏污
    INSPECTION_NEEDED // 需要检查
}

public enum RoomStatus {
    AVAILABLE,         // 可用
    RESERVED,          // 已预订
    UNDER_MAINTENANCE, // 维护中
    OUT_OF_SERVICE     // 停止服务
}

public enum RoomType {
    STANDARD,  // 标准间
    DELUXE,    // 豪华间
    SUITE,     // 套房
    VIP_SUITE  // VIP套房
}

@Entity
public class Room {

    @Id
    private String id;

    @Column
    private int number; // 房间号

    @Column
    private RoomType type; // 房间类型

    @Column
    private RoomStatus status; // 房间状态

    @Column
    private CleanStatus cleanStatus; // 清洁状态

    @Column
    private boolean smokingAllowed; // 允许吸烟

    @Column
    private boolean underMaintenance; // 处于维护状态

}</code></pre><p>有了模型，下一步是创建企业级 Java 与作为非关系型数据库的 Oracle NoSQL 之间的桥梁。我们可以使用 Jakarta Data 非常轻松地完成，它只有一个存储库接口，所以我们不需要担心实现。</p><pre><code class="java">@Repository
public interface RoomRepository {

    @Query("FROM Room")
    List&lt;Room&gt; findAll();

    @Save
    Room save(Room room);

    void deleteBy();

    Optional&lt;Room&gt; findByNumber(Integer number);
}</code></pre><p>项目完成后，下一步是准备测试环境，首先提供一个数据库实例用于测试。多亏了 Testcontainers，我们可以轻松启动一个隔离的 Oracle NoSQL 实例来运行我们的测试。</p><pre><code class="java">public enum DatabaseContainer {

    INSTANCE;

    private final GenericContainer&lt;?&gt; container = new GenericContainer&lt;&gt;
            (DockerImageName.parse("ghcr.io/oracle/nosql:latest-ce"))
            .withExposedPorts(8080);

    {
        container.start();
    }
    public DatabaseManager get(String database) {
        DatabaseManagerFactory factory = managerFactory();
        return factory.apply(database);
    }

    public DatabaseManagerFactory managerFactory() {
        var configuration = DatabaseConfiguration.getConfiguration();
        Settings settings = Settings.builder()
                .put(OracleNoSQLConfigurations.HOST, host())
                .build();
        return configuration.apply(settings);
    }

    public String host() {
        return "http://" + container.getHost() + ":" + container.getFirstMappedPort();
    }
}</code></pre><p>之后，我们将创建一个与 <code>@Alternative</code> CDI 注解集成的生产者。此配置指导 CDI 如何提供数据库实例——在本例中是由 Testcontainers 管理的实例：</p><pre><code class="java">@ApplicationScoped
@Alternative
@Priority(Interceptor.Priority.APPLICATION)
public class ManagerSupplier implements Supplier&lt;DatabaseManager&gt; {

    @Produces
    @Database(DatabaseType.DOCUMENT)
    @Default
    public DatabaseManager get() {
        return DatabaseContainer.INSTANCE.get("hotel");
    }

}</code></pre><p>借助 Cucumber，我们可以定义一个将类注入到 Cucumber 测试上下文中的 ObjectFactory。由于我们使用 CDI 并以 Weld 作为实现，我们将创建一个自定义的 <code>WeldCucumberObjectFactory</code> 来无缝集成这两种技术。</p><pre><code class="java">public class WeldCucumberObjectFactory implements ObjectFactory {

    private Weld weld;
    private WeldContainer container;

    @Override
    public void start() {
        weld = new Weld();
        container = weld.initialize();
    }

    @Override
    public void stop() {
        if (weld != null) {
            weld.shutdown();
        }
    }

    @Override
    public boolean addClass(Class&lt;?&gt; stepClass) {
        return true;
    }

    @Override
    public &lt;T&gt; T getInstance(Class&lt;T&gt; type) {
        return (T) container.select(type).get();
    }
}</code></pre><p>一个重要提示：此设置作为 SPI（服务提供者接口）工作。因此，您必须创建以下文件：</p><p><code>src/test/resources/META-INF/services/io.cucumber.core.backend.ObjectFactory</code></p><p>内容如下：</p><pre><code class="shell">org.soujava.demos.hotels.config.WeldCucumberObjectFactory</code></pre><p>我们将让 Mapper 将我们的数据表转换为所有模型中的 Room 对象。</p><pre><code class="java">@ApplicationScoped
public class RoomDataTableMapper {

    @DataTableType
    public Room roomEntry(Map&lt;String, String&gt; entry) {
        return Room.builder()
                .number(Integer.parseInt(entry.get("number")))
                .type(RoomType.valueOf(entry.get("type")))
                .status(RoomStatus.valueOf(entry.get("status")))
                .cleanStatus(CleanStatus.valueOf(entry.get("cleanStatus")))
                .build();
    }
}</code></pre><p>整个测试基础设施完成后，下一步是设计包含我们实际测试的 Step 测试类。</p><pre><code class="java">@ApplicationScoped
public class HotelRoomSteps {

    @Inject
    private RoomRepository repository;

    @Before
    public void cleanDatabase() {
        repository.deleteBy();
    }

    @Given("the hotel management system is operational")
    public void theHotelManagementSystemIsOperational() {
        Assertions.assertThat(repository).as("RoomRepository 应该已初始化").isNotNull();
    }

    @When("I register a room with number {int}")
    public void iRegisterARoomWithNumber(Integer number) {
        Room room = Room.builder()
                .number(number)
                .type(RoomType.STANDARD)
                .status(RoomStatus.AVAILABLE)
                .cleanStatus(CleanStatus.CLEAN)
                .build();
        repository.save(room);
    }

    @Then("the room with number {int} should appear in the room list")
    public void theRoomWithNumberShouldAppearInTheRoomList(Integer number) {
        List&lt;Room&gt; rooms = repository.findAll();
        Assertions.assertThat(rooms)
                .extracting(Room::getNumber)
                .contains(number);
    }

    @When("I register the following rooms:")
    public void iRegisterTheFollowingRooms(List&lt;Room&gt; rooms) {
        rooms.forEach(repository::save);
    }

    @Then("there should be {int} rooms available in the system")
    public void thereShouldBeRoomsAvailableInTheSystem(int expectedCount) {
        List&lt;Room&gt; rooms = repository.findAll();
        Assertions.assertThat(rooms).hasSize(expectedCount);
    }

    @Given("a room with number {int} is registered as {word}")
    public void aRoomWithNumberIsRegisteredAs(Integer number, String statusName) {
        RoomStatus status = RoomStatus.valueOf(statusName);
        Room room = Room.builder()
                .number(number)
                .type(RoomType.STANDARD)
                .status(status)
                .cleanStatus(CleanStatus.CLEAN)
                .build();
        repository.save(room);
    }

    @When("I mark the room {int} as {word}")
    public void iMarkTheRoomAs(Integer number, String newStatusName) {
        RoomStatus newStatus = RoomStatus.valueOf(newStatusName);
        Optional&lt;Room&gt; roomOpt = repository.findByNumber(number);

        Assertions.assertThat(roomOpt)
                .as("房间 %s 应该存在", number)
                .isPresent();

        Room updatedRoom = roomOpt.orElseThrow();
        updatedRoom.update(newStatus); // 假设 Room 类有 update 方法

        repository.save(updatedRoom);
    }

    @Then("the room {int} should be marked as {word}")
    public void theRoomShouldBeMarkedAs(Integer number, String expectedStatusName) {
        RoomStatus expectedStatus = RoomStatus.valueOf(expectedStatusName);
        Optional&lt;Room&gt; roomOpt = repository.findByNumber(number);

        Assertions.assertThat(roomOpt)
                .as("房间 %s 应该存在", number)
                .isPresent()
                .get()
                .extracting(Room::getStatus)
                .isEqualTo(expectedStatus);
    }
}</code></pre><p>是时候执行测试了：</p><pre><code class="shell">mvn clean test</code></pre><p>您可以看到结果：</p><pre><code class="shell">INFO: Connecting to Oracle NoSQL database at http://localhost:61325 using ON_PREMISES deployment type
  ✔ Given the hotel management system is operational      # org.soujava.demos.hotels.HotelRoomSteps.theHotelManagementSystemIsOperational()
  ✔ And a room with number 101 is registered as AVAILABLE # org.soujava.demos.hotels.HotelRoomSteps.aRoomWithNumberIsRegisteredAs(java.lang.Integer,java.lang.String)
  ✔ When I mark the room 101 as OUT_OF_SERVICE            # org.soujava.demos.hotels.HotelRoomSteps.iMarkTheRoomAs(java.lang.Integer,java.lang.String)
  ✔ Then the room 101 should be marked as OUT_OF_SERVICE  # org.soujava.demos.hotels.HotelRoomSteps.theRoomShouldBeMarkedAs(java.lang.Integer,java.lang.String)
Oct 21, 2025 6:18:43 PM org.jboss.weld.environment.se.WeldContainer shutdown
INFO: WELD-ENV-002001: Weld SE container fc4b3b51-fba8-4ea6-9cef-42bcee97d220 shut down
[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 7.231 s -- in org.soujava.demos.hotels.RunCucumberTest
[INFO] Running org.soujava.demos.hotels.MongoDBTest
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.007 s -- in org.soujava.demos.hotels.MongoDBTest
[INFO] 
[INFO] Results:
[INFO] 
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0
[INFO] </code></pre><h2>结论</h2><p>通过结合领域驱动设计（DDD）和行为驱动开发（BDD），开发人员可以超越技术正确性，构建真正反映业务意图的软件。DDD 为领域提供了结构，确保模型精确地捕捉现实世界的概念，而 BDD 则通过用业务本身的语言编写的清晰、可测试的场景，确保这些模型按预期运行。</p><p>在本文中，您学习了如何使用 Oracle NoSQL、Eclipse JNoSQL 和 Jakarta EE 连接这两个世界——从定义您的领域到运行由 Cucumber 和 CDI 支持的真实行为测试。这种协同作用将测试转化为活文档，弥合了工程师和利益相关者之间的差距，并确保您的系统在演进过程中始终与业务目标保持一致。</p><p>您可以深入探索并将 DDD 与 BDD 结合起来。在<a href="https://link.segmentfault.com/?enc=H2hXrEMK6H%2Bjkhtko7QA7Q%3D%3D.vfvS8%2BX9o9XWWujW2TCnckR2kDlshKPYRdw6%2FxQL3l3Lx0F1%2FCZXYP5s48ORpRmPYJp1Ws5xhWbuce3s8iux9Q%3D%3D" rel="nofollow" target="_blank">《Domain-Driven Design with Java》</a>这本书中，您可以找到一个很好的起点来理解为什么 DDD 对我们仍然很重要。它扩展了这里分享的想法，展示了 DDD 和 BDD 如何共同带来更简单、更易维护且以业务为中心的软件。这种软件交付的是超越需求的实际价值。</p><hr/><p>【注】本文译自：<a href="https://link.segmentfault.com/?enc=jN%2B%2B8I9EswwvnDboYO2FOg%3D%3D.5sAM%2BoGfsZSUaW56n8XmhnTWUj8sdruk0UfxKvrDCLF6t6j7zzYQIEtyDtgVJD5%2BS%2Bzw69dyI%2FZLm67aTlrmww%3D%3D" rel="nofollow" target="_blank">Applying Domain-Driven Design With Enterprise Java: A Behavior-Driven Approach</a></p>]]></description></item><item>    <title><![CDATA[「让提词跟着我说话走」：结合语音识别做“]]></title>    <link>https://segmentfault.com/a/1190000047434662</link>    <guid>https://segmentfault.com/a/1190000047434662</guid>    <pubDate>2025-11-28 15:12:42</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>不知道大家关注没有 Rokid 的眼镜啊，最近可是非常的火，我也是第一时间去看了新品发布会，里面有很多的功能还是很震撼的。</p><p><img width="723" height="548" referrerpolicy="no-referrer" src="/img/bVdnb40" alt="" title=""/></p><p>人非常多，也遇见了好多的老熟人，当然也有自己比较关注的 up 主 tim。</p><p><img width="723" height="549" referrerpolicy="no-referrer" src="/img/bVdnb45" alt="" title="" loading="lazy"/></p><p>当然说回来，我们也来聊一个 Rokid 眼镜上的一些应用开发，毕竟它能给我们带来哪些创新性体验，才是我们更关注的。<br/>在官方的 SDK 中有个提词器场景，其实官方 SDK 其实已经把提词器能力封装得比较完整了，当然我们在这个基础上，在增加点“小玩意”，比如“自动跟读滚动”～！</p><p><img width="723" height="358" referrerpolicy="no-referrer" src="/img/bVdnb49" alt="" title="" loading="lazy"/></p><hr/><h2>一、为什么我开始折腾“自动跟读滚动”</h2><p>做内容的人应该都有过类似的崩溃体验：</p><ul><li>要么是提词器滚得太快，被迫狂读；</li><li>要么就是滚得太慢，自己说完一句还要在那里干等着字幕挪下去。</li></ul><p>在 Rokid 的 AR 眼镜上，这个问题更明显——屏幕就在眼前，一旦节奏不对，很容易被打乱思路。</p><p>Rokid 的 GlassesSDK 里，其实已经把提词器能力封装得比较完整了：既包括基础的“打开场景 + 下发文案”，也包括基于 ASR 结果的 AI 实时滚动能力。</p><p>这篇文章就按照我自己的实战过程，从 0 到 1 带你把提词器场景跑起来，然后结合 GlassesSDK 文档里给出的接口，做一个“让提词跟着我说话走”的自动跟读 Demo，顺便聊聊还能玩出哪些新花样。</p><p><img width="606" height="954" referrerpolicy="no-referrer" src="/img/bVdnb5a" alt="" title="" loading="lazy"/></p><hr/><h2>二、先对照 GlassesSDK 文档，把提词器能力说清楚</h2><p><img width="723" height="508" referrerpolicy="no-referrer" src="/img/bVdnb5b" alt="" title="" loading="lazy"/></p><p>在 GlassesSDK 文档里，提词器是一个独立的 CXR 场景（scene），核心接口正是你给到的这几组：</p><h3>1）打开 / 关闭提词器场景</h3><pre><code class="kotlin">fun openOrCloseWordTips(toOpen: Boolean): ValueUtil.CxrStatus? {
    return CxrApi.getInstance()
        .controlScene(ValueUtil.CxrSceneType.WORD_TIPS, toOpen, null)
}</code></pre><ul><li>对应文档里的 <code>controlScene(ValueUtil.CxrSceneType.WORD_TIPS, openOrClose, null)</code>。</li><li>返回值是 <code>ValueUtil.CxrStatus</code>，常见取值：<code>REQUEST_SUCCEED</code> / <code>REQUEST_WAITING</code> / <code>REQUEST_FAILED</code>。</li></ul><h3>2）发送提词器内容（脚本文本）</h3><pre><code class="kotlin">private val sendCallback = object : SendStatusCallback {
    override fun onSendSucceed() {
        /* 文案下发成功 */
    }

    override fun onSendFailed(p0: ValueUtil.CxrSendErrorCode?) {
        /* 记录错误码 */
    }
}

fun setWordTipsText(text: String, fileName: String): ValueUtil.CxrStatus? {
    return CxrApi.getInstance().sendStream(
        ValueUtil.CxrStreamType.WORD_TIPS,
        text.toByteArray(),
        fileName,
        sendCallback
    )
}</code></pre><h3>3）配置提词器场景参数</h3><pre><code class="kotlin">fun configWordTipsText(
    textSize: Float,
    lineSpace: Float,
    mode: String,
    startPointX: Int,
    startPointY: Int,
    width: Int,
    height: Int
): ValueUtil.CxrStatus? {
    return CxrApi.getInstance().configWordTipsText(
        textSize, lineSpace, mode,
        startPointX, startPointY,
        width, height
    )
}</code></pre><ul><li><code>mode</code> 支持 <code>"normal"</code> 和 <code>"ai"</code>，后者就是文档里提到的“AI 模式，ASR 触发自动滚动”。</li></ul><h3>4）发送提词器 ASR 结果（AI 实时滚动的关键）</h3><pre><code class="kotlin">fun sendWordTipsAsrContent(content: String): ValueUtil.CxrStatus? {
    return CxrApi.getInstance().sendAsrContent(content)
}</code></pre><ul><li>文档里的描述是：当模式为 <code>"ai"</code> 时，如果 ASR 结果触达当前画面尾部的几个字符，提词器会自动上滑。</li><li>所以这个接口不是“控制滚动速度”的，而是把“已经说出来的话”同步过去，让 SDK 自己做对齐和滚动判断。</li></ul><p>理解完这四块之后，你再回头看 GlassesSDK 文档，就会发现：官方给出的其实是一套比较完整的“场景 + 数据流 + 模式配置 + ASR 同步”能力，我们要做的，只是基于这些接口配出一个顺畅的业务链路。</p><hr/><h2>三、从 0 到 1：一个最小可用的 Rokid 提词器 Demo</h2><p>下面这段 Kotlin 代码是我自己在 Demo 工程里的写法，基本就是对上面几个接口做了一层业务封装：</p><pre><code class="kotlin">class TeleprompterManager {

    private val sendCallback = object : SendStatusCallback {
        override fun onSendSucceed() {
            /* 这里可以做一些 UI 提示 */
        }

        override fun onSendFailed(error: ValueUtil.CxrSendErrorCode?) {
            /* 打日志排查 */
        }
    }

    fun open() {
        val status = openOrCloseWordTips(true)
        // 建议对 status 做判断，避免在 REQUEST_WAITING 状态下频繁请求
    }

    fun close() {
        openOrCloseWordTips(false)
    }

    fun updateScript(text: String, fileName: String = "speech.txt") {
        setWordTipsText(text, fileName)
    }

    fun configNormalMode(
        textSize: Float = 26f,
        lineSpace: Float = 1.4f,
        startPointX: Int,
        startPointY: Int,
        width: Int,
        height: Int
    ) {
        configWordTipsText(
            textSize,
            lineSpace,
            "normal",
            startPointX,
            startPointY,
            width,
            height
        )
    }
}</code></pre><p>在 AR 眼镜上调试的时候，建议一开始先把文字区域画得小一点、靠下边缘一些，避免完全挡住视线。<br/>等用户习惯了之后，再通过配置给他一个“沉浸式”的全屏提词体验。</p><hr/><h2>四、关键一跳：把 GlassesSDK 里的 AI 实时滚动用起来</h2><p>根据文档，<code>configWordTipsText</code> 的 <code>mode</code> 参数是整个“自动跟读滚动”的开关：</p><ul><li><code>"normal"</code>：普通模式，不关联 ASR，主要依赖定速或手动滚动；</li><li><code>"ai"</code>：AI 模式，结合 <code>sendWordTipsAsrContent</code> 的内容，当识别文本触达当前画面尾部时自动上滑。</li></ul><p>所以要让提词器“跟着我说话走”，必备的两步就是：</p><ol><li>先把模式配置成 <code>"ai"</code>；</li><li>在语音识别有新结果时，调用 <code>sendWordTipsAsrContent</code> 把文本同步过去。</li></ol><p>示例代码：</p><pre><code class="kotlin">fun configAiMode(
    textSize: Float = 26f,
    lineSpace: Float = 1.4f,
    startPointX: Int,
    startPointY: Int,
    width: Int,
    height: Int
): ValueUtil.CxrStatus? {
    return configWordTipsText(
        textSize,
        lineSpace,
        "ai", // 开启 AI 模式
        startPointX,
        startPointY,
        width,
        height
    )
}

fun onAsrResultChanged(asrText: String) {
    // 这里的 asrText 一般是“当前已说出的全部内容”或者到当前句子的累积文本
    sendWordTipsAsrContent(asrText.trim())
}</code></pre><p>这里有几个和文档强相关的细节：</p><ul><li>建议按“累积文本”发送，而不是只发最后几个词，这样更容易和脚本做对齐；</li><li>不要在 <code>REQUEST_WAITING</code> 状态下频繁调用，避免把 SDK 拍“懵”；</li><li>ASR 文本在发送前做一点清洗（去掉多余空格、重复标点），可以减少误判滚动。</li></ul><hr/><h2>五、接上语音识别：完整的“自动跟读滚动”链路</h2><p>从 GlassesSDK 的角度看，它只关心一件事：你能不能持续地把“已经识别出的文本”通过 <code>sendWordTipsAsrContent</code> 传过来，至于这个文本是来自 Rokid 自己的语音服务，还是来自第三方云 ASR，SDK 并不做限制。</p><p>下面是一个简化版的伪代码结构，重点在“如何把 ASR 结果整理之后喂给提词器”：</p><pre><code class="kotlin">class AutoScrollTeleprompter(
    private val teleprompterManager: TeleprompterManager,
    private val asrClient: AsrClient // 你自己的语音识别封装
) {
    private val sb = StringBuilder()

    fun start(script: String) {
        teleprompterManager.open()
        teleprompterManager.updateScript(script)
        teleprompterManager.configAiMode(
            textSize = 28f,
            lineSpace = 1.5f,
            startPointX = 100,
            startPointY = 200,
            width = 800,
            height = 600
        )

        asrClient.start(object : AsrListener {
            override fun onPartialResult(text: String) {
                sb.clear()
                sb.append(text.trim())
                sendWordTipsAsrContent(sb.toString())
            }

            override fun onFinalResult(text: String) {
                // 最终结果可以用来做“对读评分”等分析
            }

            override fun onError(code: Int, msg: String?) {
                // 错误处理
            }
        })
    }

    fun stop() {
        asrClient.stop()
        teleprompterManager.close()
    }
}</code></pre><p><img width="702" height="702" referrerpolicy="no-referrer" src="/img/bVdnb5g" alt="" title="" loading="lazy"/></p><hr/><h2>六、实战玩法：做一个“演讲练习助手”后面的实战与扩展</h2><p>光是自动滚动其实还不够“好玩”，结合 ASR，我们可以顺手把“练稿子”这件事做得更智能一点。</p><p>我在自己的 Demo 里做了一个简单的“演讲练习助手”：</p><ul><li>提词器负责展示完整稿子，并跟着你读自动滚动；</li><li>ASR 负责记录你实际说了什么；</li><li><p>结束后做一次对比，给你一些“很接地气”的反馈，比如：</p><ul><li>哪几句话跳读了；</li><li>哪些词你经常读错或卡顿；</li><li>当前语速是偏快还是偏慢。</li></ul></li></ul><p>一个很粗暴但好用的实现方式是按句子对齐：</p><ol><li>按照标点把原稿切成句子列表 <code>scriptSentences</code>；</li><li>把 ASR 的 <code>finalResult</code> 也做一次简单切分；</li><li>用一个很轻量的“相似度”算法（比如基于分词的重合度）去匹配。</li></ol><p>伪代码大概是这样：</p><pre><code class="kotlin">data class SentenceCheckResult(
    val original: String,
    val spoken: String?,
    val similarity: Float
)

fun analyse(script: String, spokenText: String): List&lt;SentenceCheckResult&gt; {
    val scriptSentences = splitToSentences(script)
    val spokenSentences = splitToSentences(spokenText)
    val results = mutableListOf&lt;SentenceCheckResult&gt;()

    var j = 0
    for (i in scriptSentences.indices) {
        val s = scriptSentences[i]
        var bestIdx = -1
        var bestSim = 0f
        for (k in j until spokenSentences.size) {
            val sim = similarity(s, spokenSentences[k])
            if (sim &gt; bestSim) {
                bestSim = sim
                bestIdx = k
            }
        }
        val spoken = if (bestIdx &gt;= 0) spokenSentences[bestIdx] else null
        if (bestIdx &gt;= 0) j = bestIdx + 1
        results.add(SentenceCheckResult(s, spoken, bestSim))
    }
    return results
}</code></pre><p>后面你可以在眼镜上或者配套 App 里，把这些结果可视化出来，比如：</p><ul><li>相似度 <code>&lt; 0.6</code> 的句子用红色标记，提示“建议再练两遍”；</li><li>全文平均语速、总时长、停顿分布，用一个简单的图表展示。</li></ul><p>对于经常要录公开课、直播或企业宣传片的同学来说，这种“自助练稿 + 自动跟读”的体验，真的比拿着稿子对着镜头硬背舒服太多。</p><hr/><h2>七、基于当前 SDK 能做的几种创新玩法</h2><p>前面说的演讲助手，只是“自动跟读滚动”的一个典型用法。<br/>结合现在提词器相关的几个接口，其实还可以挖出不少玩法：</p><h3>1. 远程导演模式</h3><ul><li>提词器场景依然跑在眼镜上；</li><li>导演在另一端用平板 / PC 改稿；</li><li>通过网络把最新文案同步到服务端，再由服务端调用 <code>sendStream</code> 下发到 Rokid；</li><li>实拍过程中，导演可以临时插一句提示、加一个备注，下一秒就出现在演员眼前。</li></ul><h3>2. 多语言对照提词</h3><ul><li>用一份脚本生成中英文两份文本；</li><li>通过排版控制，让英文小号字体显示在下方或侧边；</li><li>结合 ASR 只对中文做自动滚动，英文只是跟随展示作为对照。</li></ul><h3>3. 会议 / 培训中的“现场提醒条”</h3><ul><li>不是传统意义上的全文提词，而是在眼镜的一小块区域滚动关键信息；</li><li>比如：下一页 PPT 的重点、即将要问的问题、时间提醒；</li><li>通过 <code>configWordTipsText</code> 把提词区域收得比较小，就可以变成一个“隐形便签条”。</li></ul><h3>4. 拍摄安全提示 / 法务提示场景</h3><ul><li>在录制对外视频时，让拍摄者在开头自动读一段合规提示；</li><li>系统用 ASR 校验是否确实读完了关键条目，才允许开始正式录制；</li><li>这里同样可以用 <code>sendWordTipsAsrContent</code> 的文本对齐结果做一个简单的检查。</li></ul><p>这些玩法本质上都没有超出当前 SDK 提供的能力，只是把“提词内容 + 布局 + ASR 结果”这三块重新拼了一下。</p><p>从工程实现角度来说，你完全可以先封装一层自己的 <code>TeleprompterService</code>，把 <code>CxrApi</code> 的细节藏在里面，对业务层暴露的是更高层的概念：</p><ul><li><code>TeleprompterSceneConfig</code>（布局、字体、模式）；</li><li><code>ScriptSegment</code>（脚本片段，多语言、类别标签）；</li><li><code>AsrSyncStrategy</code>（如何把 ASR 文本映射到脚本）。</li></ul><hr/><h2>八、开发中踩到的一些坑</h2><p>最后简单记几条我在调试过程中踩过的坑，给后面折腾的同学省点时间：</p><ol><li><p><strong>不要无脑高频调用 <code>controlScene</code></strong></p><ul><li>SDK 里已经明确提到有 <code>REQUEST_WAITING</code> 这个状态；</li><li>如果频繁 open / close，很容易在状态切换时卡住场景；</li><li>建议在业务层自己维护一个状态机，只有判断确实是“场景已关闭”时才去调用 open。</li></ul></li><li><p><strong><code>sendStream</code> 的编码问题</strong></p><ul><li>最好明确指定 UTF-8，避免在某些环境下出现乱码；</li><li>另外，<code>fileName</code> 可以当作一个轻量级的脚本 ID，用来区分不同的文案版本。</li></ul></li><li><p><strong><code>configWordTipsText</code> 的坐标和尺寸</strong></p><ul><li>不同设备分辨率、FOV 略有差异，最好做一层适配；</li><li>可以先根据设备的物理分辨率算一个“逻辑安全区域”，把提词器放在其中；</li><li>不要一上来就全屏，尤其是在需要看清现实环境的场景。</li></ul></li><li><p><strong>ASR 的延迟和闪烁</strong></p><ul><li>如果 ASR 是云端识别，网络波动时很容易出现先静止一会儿，然后一次性滚很大一段的情况；</li><li>可以在业务层做一个“节流 + 缓冲”：收到长段结果时分段发送给 <code>sendAsrContent</code>，让滚动看起来更自然。</li></ul></li><li><p><strong>异常处理</strong></p><ul><li><code>CxrStatus</code> 里的 <code>REQUEST_FAILED</code> 一定要打详细日志，否则后期排查问题会非常难受；</li><li><code>sendStream</code> 的失败回调里，可以做一次降级，比如提示用户重新加载脚本。</li></ul></li></ol><p>这些细节在 Demo 阶段可能感觉不明显，但一旦你把这个功能交给真正的主播、讲师、运营同学去用，就会立刻感受到“工程质量”的差距。</p><hr/><h2>九、最后的小总结</h2><p>GlassesSDK 给提词器做的 <code>"ai"</code> 模式，本质上是把“字幕滚动”这件事从一个纯 UI 动画，升级成了一个和语音识别紧密联动的能力。</p><p>按照文档，把 <code>openOrCloseWordTips</code> / <code>setWordTipsText</code> / <code>configWordTipsText</code> / <code>sendWordTipsAsrContent</code> 几个接口串起来，其实已经能比较完整地说明：“当前 GlassesSDK 里给出的提词器接口和 AI 实时滚动部分，如何在实际项目里落地”。</p><p>剩下的，就是结合自己的业务，把它变成一个真正有价值的功能：可以是演讲练习助手，可以是远程导演工具，也可以是带安全校验的合规提示提词。</p><p>如果你也做了自己的玩法，欢迎在论坛里交流，一起把提词器打造成 GlassesSDK 生态里的“标配能力”。</p>]]></description></item><item>    <title><![CDATA[从 RAG 到 KAG ：结构化思考范式]]></title>    <link>https://segmentfault.com/a/1190000047434746</link>    <guid>https://segmentfault.com/a/1190000047434746</guid>    <pubDate>2025-11-28 15:11:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>导语 |</strong> 随着人工智能技术的迅速发展，基于大语言模型（LLMs）的应用逐渐成为主流。然而，这些大模型在实际应用中仍像在“闭卷考试”，一旦题目超纲便只能凭空编造，即便后来引入 RAG 让其“开卷”，也常因翻不到正确的页码而答非所问。尤其在垂直领域的应用中，单纯依靠大模型往往无法满足复杂业务对精准问答、实时知识更新和推理深度的需求。因此，技术正从 RAG (Retrieval Augmented Generation, 检索增强生成) 走向 KAG (Knowledge Augmented Generation，知识增强生成框架) ：通过整合知识库与结构化推理，让“开卷”不仅翻得到页，还能按逻辑划重点。本文特邀<strong>同济大学特聘研究员、博导、腾讯云 TVP 王昊奋</strong>重点探讨从 RAG 到 KAG 的技术演进过程，并分析 KAG 框架如何有效解决传统 RAG 模型的不足，为垂直领域应用提供更加精准和高效的解决方案。</p><h2><strong>作者简介</strong></h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434748" alt="" title=""/></p><p>王昊奋，同济大学特聘研究员、博导、腾讯云 TVP。研究方向包括知识图谱、自然语言处理、对话机器人等。长期在一线人工智能公司担任 CTO 之职。是全球最大的中文开放知识图谱联盟 OpenKG 发起人之一。负责主持多项国家级和上海市 AI 相关项目，发表 100 余篇 AI 领域高水平论文，谷歌学术引用 7550 余次，H-index 达到 31。构建了全球首个可交互养成的虚拟偶像—“琥珀·虚颜”；所构建的智能客服机器人已累计服务用户超过 10 亿人次。目前担任中国计算机学会术语工委副主任，SIGKG 主席，上海秘书长，中国中文信息学会理事，语言与知识计算专委会副秘书长，上海市计算机学会自然语言处理专委会副主任，上海交通大学 AI 校友会秘书长等社会职位。</p><h2><strong>一、从“闭卷”到“开卷”：大模型能力的转变</strong></h2><p>在大模型的实际应用中，通常依赖于两个核心功能：一是联网搜索，二是深度思考。这两者在技术逻辑上互为补充：搜索功能能够提供实时的知识更新，而思考功能则确保了逻辑的严谨性。然而，当大模型应用于垂直领域时，常常面临以下五大痛点：</p><ul><li>幻觉生成：模型因参数化知识不足而编造虚假信息；</li><li>知识滞后：预训练数据无法覆盖最新政策、市场动态；</li><li>效率瓶颈：复杂问题需要多轮检索与推理，响应时间过长；</li><li>领域适配难：行业术语、规则体系与通用模型存在语义断层；</li><li>推理脆弱性：多步推理中易因知识缺失或逻辑断点导致结果偏差。</li></ul><p>这些痛点的根本原因在于，模型从“闭卷考试”（依赖内在知识）向“开卷考试”（借助外部信息）转型时，能力出现了断层。无论是在搜索、推荐、问答还是对话等场景中，核心需求可以归纳为两点：首先是输出精准可靠，其次是能够与内部大数据系统进行深度对接。用户习惯使用 AI 搜索也反映了这一需求：虽然 AI 搜索引用的来源可能存在虚假信息，但其提供的“证据链”能够增强用户的信任感。同时，用户还希望技术成本可控，并确保数据的安全性与隐私保护。</p><p>为应对这些挑战，目前的技术探索趋向于通过外挂知识库（如 RAG）来弥补大模型本身的不足。尽管 RAG 技术已从最初的基础 RAG 发展到具备自主决策能力的 Agentic RAG，但在实际应用中仍然面临挑战。即便引入了 RAG，当大模型遇到预训练数据未覆盖的最新或特定领域问题时（例如政策法规中的“关税”细节，见下图），其表现依旧可能无法令人满意。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434749" alt="" title="" loading="lazy"/></p><p>关税问题示例：Naive RAG 模型</p><p>在这一过程中，可以提炼出一个基本框架：通过为大模型提供大量额外的相关知识，使其能力从依赖有限内在知识的“闭卷考试”模式，转变为能够参考外部信息的“开卷考试”模式。举例来说，解读特定问题时，可以提供详尽的关税细则、适用条款和豁免情况等详细信息，帮助模型更准确地进行判断和推理。</p><p>这一转变的关键在于赋予模型深度阅读理解的能力。通过引入外部知识库，模型不仅可以获取更多的背景信息，还能在生成回答时，依据实时和特定领域的数据做出更合理的决策。这种能力使得大模型在面对复杂问题时，能够在保持逻辑严谨性的同时，弥补内在知识的不足。</p><h2><strong>二、RAG的进化：当检索开始会“思考”</strong></h2><p>随着技术的不断进步，RAG 模型逐渐与推理技术相结合，形成了更为强大的推理增强 RAG（Reasoning-Augmented RAG）模型。这一技术突破为人工智能在复杂任务中的应用提供了新的发展机遇，尤其是在垂直领域的实际落地中，展现出了巨大的潜力。</p><h3><strong>RAG与推理的结合的发展阶段</strong></h3><p>RAG 与推理的结合经历了两个关键的历史性阶段：第一个阶段由 OpenAI 推出的 o1 模型开启，o1 的出现标志着训练时扩展（train time scaling）到推理时扩展（inference time scaling）的转变。这一进步使得自动化思维链成为可能，并能够通过思考过程提供更精确的回答。第二个阶段出现在今年年初，DeepSeek-R1 的发布进一步推动了技术的发展，特别是DeepSeek-R1 采用的开源策略，以及其创新的轻量、高效且可控的 GRPO（Group Relative Policy Optimization）强化学习方法，为该领域注入了新的活力。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434750" alt="" title="" loading="lazy"/></p><p>将推理引入 RAG</p><p>随着 OpenAI o1 和 DeepSeek-R1 等慢思考模型的兴起，RAG 与推理能力结合的研究逐渐增多，促进了 RAG 技术在垂直领域的落地和发展。在这一过程中，技术创新不仅涵盖了最轻量级的提示工程（Prompt Engineering）和微调方法（Fine Tuning），更重要的是基于强化学习（Reinforcement Learning，RL）的方法，特别是在 DeepSeek-R1 发布之后，这类方法变得愈加普及和广泛应用（例如上图橙色区域）。</p><h3><strong>RAG与推理能力结合的价值</strong></h3><p>RAG 与推理能力结合的价值，可以从以下两个互补的视角来进行深入分析：</p><p>● 弥补现有 RAG 的不足，引入推理增强检索：通过引入推理能力，可以在检索过程中增强推理效果，解决 RAG（尤其是Agentic RAG）在复杂问题解析中的痛点。例如，跨文档协同困难、跨内容检索不连贯、以及效率与精度之间的难以平衡等问题，都能通过推理增强得到有效解决。</p><p>● 从大模型自身需求出发，市场主流大模型均内置联网搜索功能：这一设计本质上是在推理过程中对检索的增强。在多步推理过程中，大模型可能因缺乏实时知识而导致推理断层，因规则缺失而产生边界模糊，或因搜索空间爆炸而陷入局部优化。通过动态检索外部知识，可以有效平衡推理的深度与广度，避免知识滞后或规则缺失引发的推理断裂，从而为技术优化提供新的路径。</p><p>通过这两种视角的结合，我们不仅能够提升 RAG 技术的应用效果，还能更好地应对实际应用中的各种挑战，促进 AI 技术在更多领域的落地实施。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434751" alt="" title="" loading="lazy"/></p><p>关税问题示例：RAG+Reasoning 模型</p><p>RAG 与推理的融合，本质上是一个动态任务规划与执行的过程。它将复杂问题系统性地拆解为多个子任务，如理解、分解、检索、验证与整合，从而形成一条逻辑自洽的推理链。在上图关税案例中，传统 RAG 模型可能会直接拼接多个信息片段，生成一个笼统的回答。而 RAG + Reasoning 模型则会采取更为精细的步骤：首先理解问题结构，然后分解子问题，进行多轮检索与交叉验证，最终综合推理并生成建议。这种方法使得结果不仅仅是信息的简单堆砌，而是一份结构清晰、逻辑严密、并具备实用价值的专业建议。</p><h2><strong>三、RAG技术的核心问题与技术演进路径</strong></h2><p>对于企业用户（To B）来说，RAG 技术的核心在于：输入内容通常是企业内部的私有文档和数据，而输出则主要服务于两类任务——专业领域的问答服务和智能写作辅助，这两类应用在实际业务场景中具有重要价值。随着 DeepSeek 等大模型技术的落地应用，尤其是通过一体机形式部署后，企业对 RAG 提出了“既要又要还要”的需求。具体表现为对知识的精准性和完备性要求，其次是对逻辑严谨性的需求，再者，大模型在处理时间和数值等方面仍存在提升空间。随着这一过程的深入，用户逐渐建立了从离线索引到在线检索推理与生成的完整流程，实现了更高效的信息处理与知识生成。</p><p>在大模型的实际应用过程中，面临一些亟待解决的问题。这些问题一方面源自自回归模型固有的限制，另一方面也与我们对技术的高期望存在差距，尤其是在技术的成熟度尚需进一步提升的背景下。以下是一些常见的挑战：</p><ul><li>错误定性或错误逻辑</li><li>事实性错误或无依据</li><li>时间、数值不敏感</li><li>张冠李戴</li><li>不能区分重要性</li><li>语义不精准</li><li>召回不完备</li></ul><p>这些问题的存在，反映了目前大模型在某些特定任务中的局限性。随着技术的不断发展，解决这些问题将是提升大模型应用效果和可靠性的关键。</p><p>通过对 RAG 系统的深度剖析，可归纳出三大核心问题：检索机制缺陷、问题思考的逻辑稳定性不足以及计算与逻辑严谨性缺失。这些问题表明，在垂直领域的知识库建设过程中，我们正从基础的信息检索向更高阶的认知推理转型。这个能力升级的过程可以类比于自动驾驶的分级体系，具体包括以下几个层次：</p><ul><li>第一层为<strong>显性知识检索</strong>，仅需从知识库中直接调取明确信息，对应基础 RAG 技术，解决"有没有知识"的问题。</li><li>第二层是<strong>将隐性知识结合</strong>，需整合多份文档中的关联信息，对应推理增强 RAG，通过思维链或动态检索解决"知识如何串联"的问题。</li><li>第三层则是<strong>明确规则的演绎推理</strong>，基于预设规则进行严格推导，需模型具备逻辑稳定性，避免思维链波动，对应强化学习优化的推理模型。</li><li>第四层需要基于结果的推断，需从结果反推原因、总结规律或迁移经验，对模型的逻辑严谨性和泛化能力要求最高，对应内生推理框架（如 KAG）的终极目标——<strong>通过非强化学习范式实现自主推理</strong>。</li></ul><p>这一层级划分揭示了垂域 AI 从"信息检索"到"认知推理"的技术演进路径：每提升一层，对模型的知识整合、逻辑稳定和推理严谨性的要求均呈指数级增长。而这些正是当前技术突破的重点方向。</p><h2><strong>四、大模型外挂知识库的三种技术路线</strong></h2><p>大模型外挂知识库可分为三类路线，各有优劣且非互相取代，未来需集成优势、规避缺点：</p><p>● 路线一：<strong>搜索引擎技术延展</strong>，流程为索引（index）-检索（retrieve）-生成（含规划与生成）。问题在于：索引阶段仅做文档间简单分块（chunking）和嵌入（embedding），缺乏语义关联；检索阶段无推理能力；规划与生成阶段的自然语言规划不严谨，摘要无后校验（大模型参数冻结未调优）。</p><p>● 路线二：<strong>升级到 GraphRAG</strong>，在索引阶段通过图结构增强文档间语义关联，检索阶段提升检索召回相关性，但规划与生成环节未改进。</p><p>● 路线三：<strong>传统知识问答基于图索引</strong>，同样面临图谱构建成本高、门槛高的问题；检索阶段知识覆盖度低（无法像大模型“兜底”所有问题），优点在于规划生成环节严谨、准确性高。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434752" alt="" title="" loading="lazy"/></p><p>外挂知识库技术路线优缺点对比</p><p>对比上述三种技术路线，我们可以看到它们在索引、规划、检索和生成等方面各自的优缺点。显然，并不存在一种方案能够完全取代其他两种方式。事实上，这三类路线如同软件发展的不同阶段，并非互相替代，而是并存共生。 这一现象引导我们思考如何将这些技术路线的优点进行集成，并规避其缺点。答案是从 RAG 走向 KAG（Knowledge-Augmented Generation，知识增强生成）的路线。</p><h2><strong>五、KAG（知识增强生成）路线的提出</strong></h2><p>KAG 的核心理念（CoreIdea）是充分利用知识库或知识图谱中结构严谨的优势，通过多重表征和互索引的方式来优化信息组织，并借助知识和逻辑的语义引导帮助实现结构化的思考和推理。</p><p>回顾前文所述的几种外挂知识库技术路线，我们可以看到现有的传统方法各自存在明显的缺陷，然而，在实际应用中，我们对系统能力提出了更高的要求。所以，我们提出了一种全新的 KAG 框架——以知识点为中心的知识索引与知识引导的复杂问题求解方案。该框架包括知识构建（Builder）、问题求解（Solver）以及底层支撑的模型（Model）三个部分，涵盖理解、生成和推理等多个阶段，能够在复杂任务中提供更为精确、可靠的解决方案。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434753" alt="" title="" loading="lazy"/></p><p>KAG 模型框架</p><h3><strong>KAG知识索引：自动化知识构建</strong></h3><p>在实际应用中，借助大模型的能力，我们可以实现知识的自动化构建，这一过程不仅包括开放信息抽取，还涵盖从业务系统中获取的结构化数据。关键在于实现双向校验与互补：一方面，数据库或大数据体系中的结构化知识虽然较为精准，但往往缺乏上下文信息；另一方面，非结构化文本虽然富含上下文，但容易产生噪声。通过知识语义对齐，一方面可以降低知识构建成本，另一方面也能有效缓解开放信息抽取带来的噪声问题。</p><p>在这一过程中，我们发现知识本身是分层的，包括概念层面的知识和实际应用层面的知识。此外，知识也具有分类性，涵盖各种实体、事件、属性、关系、概念等结构化知识，以及自然语言描述的陈述性知识（如规则、计算过程等）。同时，还涉及大量的案例知识和推理知识。</p><h3><strong>KAG知识索引：分层知识表示</strong></h3><p>因此，如何通过语义对齐将这些不同类型的知识整合到同一个语义空间中变得至关重要。在这一过程中，我们不必要求所有知识都遵循严格的 schema，这意味着我们需要优化传统的知识图谱与大数据时代的架构，使其更适应大模型的需求。这样的表示方式可以分为以下几个层次：</p><p><strong>● 严谨层（Rigorousness）：</strong> 这一层的最大优点在于其完整性（Completeness），它提供了非常完备的知识表示。</p><p><strong>● 灵活层（Flexible Schema）：</strong> 这一层具有一定的结构信息，但并不强制要求强schema，更像是一个自由模式（Free Schema）图或数据图的概念。</p><p><strong>● 领域特定层（Domain-specific Strong Schema）：</strong> 这一层则依赖于领域内的精确schema来确保准确性（Accuracy）。</p><p>通过这种表示方式，我们可以在不同的应用场景中平滑地调整专业决策、信息检索和知识完整性的平衡。这样的架构设计，使得我们在面对具体问题时，可以根据实际需求更加灵活地选择最适合的知识表示形式，并在不同层次之间做出合理的权衡。</p><h3><strong>知识融合与索引构建中的关键要素以及优化方案</strong></h3><p>在原有知识结构的基础上，我们将增加若干关键要素，以进一步提升知识的可用性和应用效果。具体而言，每个知识点或结构化知识项将添加摘要（summary），并且增加知识点与原始文本 chunk 之间的关联。这样一来，我们就能够通过结构化的节点，类似于传统的倒排索引，将知识转换为具有关联关系的图结构。在此基础上，我们将通过 schema 注入来实现与传统图数据库中 key-value 形式的对接。通过这一方式，既能充分利用现有图数据库的优势，又能结合新兴技术提升知识库的表达能力和查询效率。</p><p>在知识融合的过程中，特别是在构建索引时，我们需要重点考虑以下几个要素：对于实体信息，必须补充时空信息、文本段落上下文以及所属领域的本体信息。缺少这些要素时，当前广泛使用的 embedding 模型，尤其是检索模型，可能面临一系列问题：</p><p><strong>● 指代缺失或错位：</strong> 例如，模型可能认为“俄罗斯总统访华”与“美国总统访华”更为相近，而实际上，“俄罗斯总统访华”与“普京抵达北京首都机场”才是更相关的事件；</p><p><strong>● 时空错位：</strong> 例如，2024 年 5 月 30 日与 2024 年 6 月 1 日时间上更接近，但模型可能错误地将其与 2023 年 5 月 30 日匹配；</p><p><strong>● 数值混淆：</strong> 例如，法律条文中的条款编号与金额数值可能被混为一谈；</p><p><strong>● 逻辑错位：</strong> 例如，哮喘属于呼吸系统慢性疾病，但可能被错误关联到消化系统慢性疾病。</p><p>为了避免上述问题，我们采用了一个多层次的过程来提升知识的连通性和准确性：从文档出发，经过开放信息抽取，再到语义增强，包括本体对齐、上位概念生成、概念间关联构建以及同义词扩展，有效提升知识的连接性，确保模型能够准确理解不同概念间的关系。通过增强稀疏关联、抑制噪声，使知识结构更加紧密和准确，进一步提高检索和推理的准确性。</p><p>同时在整个流程中，我们引入了基于规划的控制机制，将原本依赖思维链（Chain-of-Thought，CoT）的自然语言推理过程，转化为可控的逻辑表达式，从而实现对推理路径的精确引导。这种形式化的表达使得系统能够按需调用不同的求解器（Solver），例如语义检索模块，从而更有效地建立知识关联。</p><h2><strong>六、KAG推理框架：逻辑符号引导的结构化推理</strong></h2><p><strong>KAG 技术的核心之一是如何通过逻辑符号引导的结构化推理来实现复杂问题的求解。</strong> 为此，我们需要将原始问题按需分解为多个子问题，并清晰地刻画这些子问题之间的逻辑依赖关系。在此基础上，系统应能自主判断以下几项决策：</p><ul><li>是否调用符号化知识图谱进行推理？</li><li>是否执行文本 chunk 的检索？</li><li>是否在结构化数据上进行图遍历与子图匹配？</li><li>是否在扩展后的文本内容上进行阅读理解与“思考”操作？</li></ul><p>最终，通过多种推理方式的协同工作，系统能够动态更新与整合当前问题相关记忆（memory），为求解提供更为精准的答案。</p><p>在整个推理过程中，我们会使用多种逻辑形式（Logical form），包括检索、排序、数学计算、逻辑推理、反问以及输出等对应的逻辑表达形式。通过引入特定的标记（special token），能够将原本单一的数据流转变为数据流与控制流相结合的协同机制。这种机制通过不同的操作符（Operator）和求解器（Solver）可以实现本身的输出校验，确保结果的准确性；还能支持推理问答以及检索过程中的动态数值计算，从而增强模型的推理深度和灵活性。</p><h3><strong>典型任务示例：博士生申请居住证</strong></h3><p>以博士生申请居住证是否需要学校开具在读证明为例，该问题的求解过程可以分解为一系列结构化操作：</p><ul><li>定位所在地区：首先确定所在地区的相关政策。</li><li>查找相关办事事项：查询该地区居住证办理的相关要求。</li><li>判断是否需提供在读证明：根据相关政策，判断是否需要提交学校开具的在读证明。</li></ul><p>这些步骤实质上转化为检索（retrieve）、扩散查询（diffuse）等具体操作符的有序执行，从而形成从问题到答案的结构化推理路径。</p><p>从这个典型任务可以看出，核心在于实现可控的规划过程。需要强调的是，并非所有内容都必须结构化，也并非所有处理都需依赖图结构才能完成。实际上，在一些轻量级的应用场景中，我们可以在保证效果相当的前提下，有效控制构建成本，这对于本地化部署和垂直领域的落地应用非常重要。</p><h2><strong>七、从外部依赖到内化推理：KAG-Thinker的创新路径</strong></h2><p>在前述讨论中，我们提到大模型通过引入外部检索和求解器调用来扩展其能力，但这种依赖在实际应用中也面临一系列挑战。随着从大模型到 RAG 的过渡，虽然引入了外部知识库，系统的存储开销、token 消耗以及授权成本等方面却显著增加。此外，尽管推理增强能够处理更复杂的任务，但整体流程耗时增加，这对实际落地应用提出了新的挑战。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434754" alt="" title="" loading="lazy"/></p><p>从大模型到推理增强RAG面临的挑战</p><p>另一方面，尽管大模型具备自主决策的潜力，但“进化”行为的方向未必符合预期，这可能带来额外的安全风险。为了应对这些问题，我们提出了 KAG-Thinker，为模型的思考过程建立一套清晰、分层的 “脚手架”，从而提升复杂任务中推理过程的逻辑性与稳定性。</p><p>具体来说，KAG-Thinker 其实是以逻辑形式（Logical Form）为中心，将三类推理模式进行统一，一是纯自然语言推理，二是自然语言结合变量与运算符的推理，三是仅基于变量与运算符的形式化推理。通过这种统一表达，KAG-Thinker 能够将外部依赖（如外部检索、调用外部求解器等）转化为内化推理过程，从而有效提升推理的可控性与可解释性。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434755" alt="" title="" loading="lazy"/></p><p>KAG-Thinker：以逻辑形式为中心</p><h2><strong>KAG-Thinker模型能力</strong></h2><p><strong>在 KAG-Thinker 模型的设计过程中，我们对系统提出了几个核心要求：逻辑性、稳定性，以及对知识边界的清晰判断。</strong> 具体来说，模型需要能够明确识别何时调用内部知识，以及何时依赖外部信息。此外，还需要确保求解过程的严谨性，并具备对检索噪声的鲁棒性。</p><p>目前常见的做法是采用强化学习（RL）手段进行优化。然而，在 KAG-Thinker 框架中，我们并未采用 RL 的方式，而是选择了监督微调（SFT）的方法。这是因为，在生成包含特殊标记（special token）和长思维链的结构化推理路径时，SFT 能够通过大量合成数据并根据行业需求灵活调整模型行为，确保推理过程的准确性和可靠性。</p><p>我们所使用的合成数据涵盖了通用领域与垂直领域的多样化样本，整体覆盖了问题的广度分解、深度求解过程中的知识边界识别、求解器调用策略、多源知识融合时的注意力聚焦，以及关键推理节点的准确表达。</p><p>通过这种方式，我们能够逐步引导模型完成复杂任务，并利用高质量的训练数据持续优化其推理能力。如下图所示，KAG-Thinker 模型通过逻辑形式将复杂问题分解为独立可解的子问题，构建了结构化的思维过程，增强了问答任务中推理过程的逻辑连贯性和上下文一致性。这种方式实现了可控、可解释的智能生成，确保每一步推理都可以追溯，并能够根据用户需求灵活调整。模型不仅在高效求解上表现出色，还能保证推理过程的透明性和可靠性。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434756" alt="" title="" loading="lazy"/></p><p>复杂问题求解概览图</p><h3><strong>大模型推理与检索过程中存在的问题</strong></h3><p>在大模型的推理与检索过程中，至关重要的一点是识别和应对“知识四象限”问题：即模型是否能够区分“知道自己知道”、“知道自己不知道”、“不知道自己知道”和“不知道自己不知道”这四种状态。如何改善模型对这四类情况的识别能力，是提升其可靠性的关键。只有当模型能够准确识别并合理应对这些不同的知识状态时，才能确保推理的有效性与准确性。</p><p>我们希望模型在回答正确问题时，具备较高且可控的置信度（confidence）。例如，当模型生成正确答案时，其置信度应保持在较高水平（如0.95以上）。然而，当前许多大模型存在过度自信的问题，尤其是在输出错误答案时，常表现出过高的置信度，这导致了可信度失衡。这种情况常常是模型幻觉现象的根源之一。因此，必须设计有效机制来将置信度控制在合理范围内，避免不准确的答案被过度自信地输出。</p><p>此外，在性能层面还有两个关键指标：一是<strong>推理过程的稳定性</strong>，二是<strong>对“过度自信”（over-confidence）的控制</strong>。大模型普遍存在过度自信的问题，即在缺乏依据的情况下仍以高置信度输出错误结果，这正是幻觉现象的重要成因之一。因此，必须通过机制设计将其控制在合理范围内。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434757" alt="" title="" loading="lazy"/></p><p>KAG-Thinker 模型</p><p>最终，所有的推理与判断过程都将被集成到模型服务（model serving）环节，确保推理（inference）与 AI 服务流程的深度融合。通过这种方式，模型不仅能够在推理时准确识别何时应依赖内在知识，何时应调用外部信息，还能有效控制置信度，提升服务质量与系统的可靠性。</p><h2><strong>八、从助手到伙伴：RAG到KAG的四大跃迁路线</strong></h2><p>RAG 技术在目前的应用中仍然存在大量的优化空间，其本质目标是<strong>将大模型从一个被动的知识助手，逐步发展为具备认知能力的智能伙伴。</strong> 为实现这一目标，我认为可以从以下四个方面进行提升：</p><ul><li>从传统的模糊语义匹配转向逻辑驱动的定向精准检索。这包括对问题进行子问题分解，并在推理过程中触发精准、有针对性的检索操作，提升信息获取的准确性和效率。</li><li>从单一的问答模式升级为系统性决策支持。面对复杂任务，需支持多路径、多分支的推理流程，形成结构化的决策链条，而不仅仅是孤立地回答单个问题。</li><li>针对大模型常出现的信息堆砌问题，应增强对返回信息的逻辑自洽性校验，并实现动态补全。通过判断信息之间的一致性，按需触发新的检索或推理步骤，形成闭环的求解过程。</li><li>当前大模型存在盲目搜索和过度思考的问题，因此需要实现智能的资源分配机制，合理调度推理深度与广度，避免资源浪费，提升响应效率与结果质量。</li></ul><p>通过这四个方向的提升，我们不仅能够优化现有 RAG 技术的应用效果，更能推动大模型从单纯的知识检索工具向具备认知和决策能力的智能伙伴演变。这一转变将极大地拓展大模型在垂直领域中的应用潜力，并为未来的智能系统提供更加精确、灵活的推理支持。</p>]]></description></item><item>    <title><![CDATA[AI 时代，职场不慌！前快狗打车CTO沈]]></title>    <link>https://segmentfault.com/a/1190000047434823</link>    <guid>https://segmentfault.com/a/1190000047434823</guid>    <pubDate>2025-11-28 15:10:57</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>「下一站，架构大师」是腾讯云架构师技术同盟为一线架构师打造的直播连线栏目，每期请到一线架构师们与名人堂成员，基于同盟交流圈最新热议的技术、职业议题展开交流。首场特邀腾讯云架构师技术同盟学习交流主席、前快狗打车 CTO沈剑与一线伙伴对话答疑，本文为片段摘录。</p><p><img width="723" height="303" referrerpolicy="no-referrer" src="/img/bVdnb7Q" alt="image.png" title="image.png"/></p><h2><strong>升职加薪：AI 是点缀，老板认同才是核心</strong></h2><p>沈剑老师认为，AI时代职场升职加薪的核心是获得老板认同，“站在老板视角”主动解决上级痛点，以深度思考、主动实践结合行动落地提升职场认知，保持开放心态、积极学新工具以面对职业发展与挑战，以“思考-输出-行动”提升个人能力。</p><p><strong>Q:AI时代下如何升职加薪？</strong></p><p><strong>沈剑：</strong> AI时代是一个点缀，核心问题在于如何让老板认同自己。</p><p>无论大公司还是小公司，都有其内部晋升流程和标准。对于工程师而言，从初级到高级的不同层级都有明确的要求。</p><p>在大公司中，有一套完善的职级体系，员工可以清楚地了解晋升的标准，并通过提升能力来达到晋升要求；而在小公司中，标准可能较为模糊，往往取决于老板的看法。在这种情况下，员工需要理解并尽可能符合老板心中的标准，同时要具备“老板视角”，理解老板关注的焦点，如项目交付时间、稳定性、业务结果等。</p><p><strong>Q:在职业发展中，如何“站在老板视角”？</strong></p><p>沈剑：站在老板视角意味着理解并解决老板心中的痛点，例如当公司面临横向问题时，如技术团队的职级评审、校园招聘和技术培训等，如果能站在技术委员会主席甚至CTO的角度去思考并帮助解决这些问题，将有助于个人快速晋升到上一个级别。具体操作上，员工应积极主动地识别并解决上级关注的痛点，超越自己当前职责范畴。</p><p><strong>Q:在职场中，如何有效地学习和提升认知？</strong></p><p><strong>沈剑：</strong> 在职场中，要提升和发展，关键在于两个层面。</p><p>首先，思维或认知层面的提升是必要的，即通过改变想法来提高认知水平。</p><p>然而，认知提升本身并不能直接带来结果，真正的结果需要体现在行动上，也就是采取与以往不同的行动，以获得不同于以往的结果。例如，针对当前问题，需要深入思考并找到具体的行动计划，如与老板沟通交流，了解其想法和顾虑，从而消除障碍或获取相关信息。</p><p>有效的学习和提升认知不仅包括阅读书籍、观看视频课程等被动获取信息的方式，更重要的是要有深度思考和主动实践的过程。其中，动手写作是最好的提升认知方式，因为写作可以促使思考者梳理清楚知识点，并促进深度理解和高效学习。通过实际操作（如管理实践、AI技术实践）和与他人深度交流，才能真正实现思维改变和认知提升。</p><p><strong>Q:如何面对职业生涯的发展和职场挑战？</strong></p><p><strong>沈剑：</strong> 对于职业生涯的发展，尤其是AI时代的新机遇，应保持开放心态和好奇心，积极拥抱并学习新工具和技术，避免不必要的焦虑。核心方法是掌握行动实践，通过不断思考、输出和行动，来实现个人能力和竞争力的提升，最终达到解决问题和获取不同结果的目标。同时，可以借助社群平台互相学习、获取启示，但最终的深入思考和认知改变仍需自己亲自实践沉淀。</p><h2><strong>AI 时代架构师需结合业务、协作与 AI</strong></h2><p>沈剑老师认为，AI时代架构师需在业务抽象、跨领域协作外结合AI能力；开发转架构师需要重业务能力，小公司程序员则要靠持续提技术、关注业务来增强竞争力，AI仅为辅助。</p><p><strong>Q:在AI时代，如何定义架构师的核心能力边界，是更强调业务抽象能力、跨领域协作能力，还是对AI工具本身的掌握？</strong></p><p><strong>沈剑：</strong> AI时代下，架构师的核心能力边界并不应只局限于业务抽象或跨领域协作，虽然这些能力依然重要。AI是一个当前的技术趋势和工具，因此掌握和有效利用AI工具以提升职场竞争力和工作效率是必不可少的一部分。核心能力边界拓展到了如何结合AI技术来优化业务规则、跨领域协作以及理解AI模型的特性。</p><p><strong>Q:从开发转为架构师，什么能力最重要？</strong></p><p><strong>沈剑：</strong> 业务能力比单纯的技术更重要，作为架构师，深入理解并能解决特定业务领域内的技术问题至关重要。例如，专注于即时通讯领域的架构师，其对业务的独特理解和解决能力比通用的架构技术更为关键。</p><p>建议架构师深入业务，了解业务特点和技术个性化部分，形成独特的核心能力。</p><p><strong>Q:在AI时代，小公司的程序员如何提升自己的行业竞争力？针对小公司程序员在AI时代面临的挑战，您有什么具体建议？</strong></p><p><strong>沈剑：</strong> 这个问题的本质是如何提升行业竞争力，不论是在AI时代还是小公司环境中。核心方法仍然是不断学习、思考、实践并提高自身技术能力。在日常工作中或项目实践中积累经验，持续提升技术水平。</p><p>在AI时代，小公司程序员应当关注业务需求的同时，不断拓展自己的技术领域，包括前端和后端开发，以及与甲方沟通的能力。尽管AI可以辅助完成一些业务功能，但真正提升竞争力的关键仍在于持续提升个人技术能力，并在实际工作中不断实践和积累经验。</p>]]></description></item><item>    <title><![CDATA[Python 的内置函数 breakpo]]></title>    <link>https://segmentfault.com/a/1190000047434862</link>    <guid>https://segmentfault.com/a/1190000047434862</guid>    <pubDate>2025-11-28 15:10:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Python 的内置函数 <a href="https://link.segmentfault.com/?enc=F2p4ITfTGKcdVvKhgudmFA%3D%3D.vr%2FPBPcd4KlFQSKR%2BnnhEjW9GSxwHF1y7RDVwQc3dIrgXQy0xP5P0GdYeifCMQ2lKkpEQSyHJoQ1gBqT%2BPl7YsqZDlF%2FGAumwldeDUIdbzD5BMHu%2FHxj95t2yQ1kZeZ8oDpTce4PCMtmYq7QJEHlGA%3D%3D" rel="nofollow" target="_blank"><code>breakpoint()</code></a> 是一个用于调试的实用工具，它在 Python 3.7 及更高版本中引入。这个函数的主要作用是触发一个调试器断点，让开发者能够在代码执行到特定位置时暂停程序并检查程序状态。</p><h3>详细说明：</h3><ol><li><p><strong>功能原理</strong>：</p><ul><li>当调用 <a href="https://link.segmentfault.com/?enc=v2lIvPnpLeyorwje9o9e7g%3D%3D.p9POUbCGndHimwpGzCxhavRy7PZhe%2BSfXYTH62hhInOpHg9tBQCnWDh1k9kE30%2BPPv%2B8XEfvHnGmTbUmkx7Gy4cFJ8HkvxcZzB0dn7Trdlf1%2F7G902qDZuCY%2BGHeSLTg2%2B6dNwVQM805z0beG%2B5BuA%3D%3D" rel="nofollow" target="_blank"><code>breakpoint()</code></a> 时，Python 会自动调用 <code>sys.breakpointhook()</code> 函数</li><li>默认情况下会启动 <code>pdb</code>（Python 调试器），但可以通过设置 <code>PYTHONBREAKPOINT</code> 环境变量来指定其他调试器</li></ul></li><li><p><strong>使用方法</strong>：</p><pre><code class="python">def calculate_sum(a, b):
    result = a + b
    breakpoint()  # 在这里设置断点
    return result</code></pre></li><li><p><strong>配置选项</strong>：</p><ul><li><p>可以通过 <a href="https://link.segmentfault.com/?enc=ycB38jpTf2ROnYYrMf2JDg%3D%3D.mOMR27%2BiqlKyP%2BRRjAJTJwRqYkzH8ZxZocN1vSNI7iaIEaoqJ%2B0%2Fc71C50FCzMi5uxTs4QKUlzQ776Hpom4saQqkTPXakhZsvvuvUQL4MFMcZ8XlPPvUJ%2FvLLwmZHO%2FJv%2FwQFbUdH14LfQKribs1kg%3D%3D" rel="nofollow" target="_blank"><code>export PYTHONBREAKPOINT</code></a> 设置环境变量配置调试器：</p><pre><code class="bash">export PYTHONBREAKPOINT=ipdb.set_trace  # 使用 ipdb</code></pre></li><li><p>要禁用所有断点：</p><pre><code class="bash">export PYTHONBREAKPOINT=0</code></pre></li></ul></li><li><p><strong>与传统方法的对比</strong>：</p><ul><li>旧方法需要显式导入并调用 <code>pdb.set_trace()</code></li><li><a href="https://link.segmentfault.com/?enc=t3EckhF3l1PvIY1fBPcCZg%3D%3D.p5fgjdZ3FAcY7AUEAGPHJzN7nVOrTgrSsDkUAB7sId8FSFFysrDhImjCp25VvXF5U0xZkb5UVkXAkuv4LATX35v3%2BUAuEaL1mRWybA9OIc%2Bhmdk5zZUR8euJEmOgi54FMjNxzwzR%2FTuk%2FEpxPOuApQ%3D%3D" rel="nofollow" target="_blank"><code>breakpoint()</code></a> 更简洁且可配置性更强</li></ul></li><li><p><strong>应用场景</strong>：</p><ul><li>复杂逻辑调试</li><li>数据流跟踪</li><li>异常情况分析</li><li>单元测试调试</li></ul></li><li><p><strong>调试器交互</strong>：</p><ul><li><p>进入调试器后可以使用标准调试命令：</p><ul><li><code>n</code> (next) - 执行下一行</li><li><code>c</code> (continue) - 继续执行</li><li><code>p</code> (print) - 打印变量值</li><li><code>l</code> (list) - 显示当前代码位置</li></ul></li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>生产环境中应确保禁用或移除 <a href="https://link.segmentfault.com/?enc=eMD5YAIXJruEObhsZ730ew%3D%3D.wUXeOBF7GhMI9OoVHv0x%2FsMCjxkhlermpJuLRb2mm1KiN4EZK32rEQCSiKR4JQLcfoooYwWoUL5EegwSANbZJlYEy5K0b%2FBNgIii%2BsLNHAH2%2FHxzQci8CxC26fHIcwyVaJ3Jv9bPiBVXEV9jUekbcQ%3D%3D" rel="nofollow" target="_blank"><code>breakpoint()</code></a> 调用</li><li>调试器交互可能会阻塞程序执行</li><li>某些特殊环境（如嵌入式系统）可能不支持调试器</li></ul></li></ol><p>这个函数极大简化了 Python 的调试流程，使开发者能够更高效地定位和解决问题。</p>]]></description></item><item>    <title><![CDATA[项目管理中如何跟踪业务日历和假期? 英勇]]></title>    <link>https://segmentfault.com/a/1190000047434873</link>    <guid>https://segmentfault.com/a/1190000047434873</guid>    <pubDate>2025-11-28 15:09:17</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="208" referrerpolicy="no-referrer" src="/img/bVdm90g" alt="" title=""/></p><p>管理跨多个团队的项目，不仅仅意味着要考虑任务和截止日期；还意味着要了解每个团队实际的工作方式和时间。用户可能遵循不同的工作日，或者遵守特定地区的节假日，这些都无法在单一的业务日历中体现。</p><p>配置工作时间和节假日的一大优势在于能够创建精准的时间线。许多项目管理工具会自动计算任务持续时间、依赖关系和里程碑。如果系统无法识别非工作日，则可能会在周末或节假日安排任务，造成提前完成的假象。正确设置工作时间后，工具可以避免在实际工作时间之外安排工作。这确保了任务结束日期、资源分配和工作量分布能够反映团队的实际可用情况。因此，项目经理可以更有信心地进行规划，避免代价高昂的误算。</p><p>另一个重要优势是改进资源管理。团队通常依赖共享资源，例如人员、设备或设施，这些资源仅在特定时间段可用。通过在系统中定义工作时间，项目经理可以确保不会在非工作时间安排任何资源。同样，标记节假日可以防止在整个组织或某些部门无法工作时意外安排任务。这有助于平衡工作量，减少员工倦怠，并有助于防止因重复安排或不切实际的任务预期而引起的冲突。</p><p>此外，配置这些设置可以增强团队内部的沟通与协作。当所有人都使用同一系统，并拥有清晰明确的工作时间段时，关于截止日期的误解就会降至最低。团队成员可以清楚地查看自己的日程安排和预期目标，因为他们知道时间表已经考虑到了休息日和缩短的工作时间。这种共识有助于提升责任感和团队合作，因为每个人都可以围绕统一的日程安排更好地协调工作。</p><p>最终，在项目管理工具中配置工作时间和节假日有助于提高项目绩效和成果。它使日程安排与实际运营限制保持一致，支持精确的时间和资源管理，并改善团队间的协调。通过花时间设置这些基础要素，组织可以创建一个更高效的项目环境，从而降低风险、提高可预测性并支持长期成功。</p><p>借助 Zoho Projects 中的业务日历，您可以创建多个日程安排，并自定义工作日、休息时间和节假日列表。您还可以将日历与门户用户关联。这确保任务持续时间、工时、提醒和报告能够反映用户的实时可用性。这有助于项目经理使用准确的日程安排来规划和管理项目。</p><p>例如，在一个项目中，来自不同地区的团队遵循不同的工作时间安排；有些团队在标准的平日工作，而另一些团队则采用错峰轮班制。</p><p>为了应对这些差异，请为每个日程安排创建单独的“工作时间”，定义工作日，并设置自定义的开始和结束时间。您还可以添加休息时间，并关联相应的节假日列表。创建完成后，将用户与其各自的日程安排关联，并将其中一个设置为门户的默认日程安排。</p>]]></description></item><item>    <title><![CDATA[AI独孤九剑：AI没有场景，无法落地？不]]></title>    <link>https://segmentfault.com/a/1190000047434882</link>    <guid>https://segmentfault.com/a/1190000047434882</guid>    <pubDate>2025-11-28 15:08:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>*本文节选自架构师技术同盟交流圈 作者为腾讯云架构师同盟名人堂专家&amp;中国信息通信研究院低代码/无代码推荐中心技术专家｜沈欣</p><p><img width="723" height="573" referrerpolicy="no-referrer" src="/img/bVdnb8Q" alt="image.png" title="image.png"/></p><h2><strong>引言</strong></h2><p>S.H.E有首歌的歌词是“全世界都在说中国话”，而今，全世界的CIO们都在找AI的落地场景。</p><p>因为不去落地AI，老板会认为你已经过时，跟不上新事物，应该淘汰；去落地AI，万一没有好的高回报场景，老板会认为你能力不足，应该淘汰。正所谓不上AI是等死，上AI是找死。</p><p>AI的场景真的很难找，真的无法落地么？不存在的。假如说AI这种工具是一把利剑，那么我们就溯本追源，从中国智慧的故纸堆里找一找解决方案。</p><h2>01</h2><p>众所周知，金庸世界最强的剑法是独孤九剑（金庸说他小说里面最厉害的人物有三个：独孤求败、达摩、张三丰，他们三个武功不相上下 如果非要选一个就是独孤求败）。</p><p>那么如果AI是剑，我们怎样炼成独孤九剑呢？</p><p>我们先来看一下，独孤九剑有九式：总诀式、破剑式、破刀式、破枪式、破鞭式、破索式、破箭式、破掌式以及破气式。独孤九剑有三大要诀：无招胜有招，料敌机先，有进无退。总纲内容：周易有云「归妹趋无妄、无妄趋同人、同人趋大有、甲转丙、丙转庚、庚转癸、子丑之交、辰巳之交、午未之 交、风雷是一变、山泽是一变、水火是一变、乾坤相激、震兑相激、离巽相激、三增而成五、五增而成九……」九剑其实不是一般概念中的剑法招式，而是一套武学理论，所以风清扬会说要看悟性。</p><p>好吧，看起来，独孤九剑就是一套应对变化的体系。嗯嗯，熟悉我的同学都知道，我也有一套应对变化的体系，称之为ITPAO，在其中AI以数字员工身份起到了非常大的作用，刚好我们就此一一对照，来帮助大家找到更好的AI落地场景。</p><p>我们先简单回顾一下ITPAO，本质就是建立一套从输入到输出的动态过程，核心节点是TPA，也即 <em>“目标设定”，“执行规划”，“具体执行”</em> ，而这三部分在实际工作中，都会时不时的发生变化，从而导致输出结果不理想。在ITPAO流程中，通过合馈制引入了数字员工后，由数字员工来发现和理解<em>变化</em>，并且针对<em>变化</em>进行及时调整，也就是所谓的：<em>动态设定目标、动态调整规划、动态跟踪执行</em>。</p><p>从这个维度，我们可以把独孤九剑的每一式都看作应对某一类变化的手段：</p><table><thead><tr><th>剑式</th><th>特点</th><th>现实映射</th></tr></thead><tbody><tr><td>破剑</td><td>剑以刺为主；可以理解为单点突变，某个变量突然变化，0维变化，会持续积累伤势</td><td>突发的单点问题，例如某个流程中重要岗位资源突然消失；某个客户突然取消订单。</td></tr><tr><td>破刀</td><td>刀以劈砍为主；一维变化，一旦命中，就是较大的伤害</td><td>突发的线状问题，例如某条产品线遇到了强劲的竞争对手新品；高管出现负面舆情</td></tr><tr><td>破枪</td><td>长兵刃，以挑、扫为主；起初是点状攻击会演变为片状，势大，从二维变化，很容易扩大到三维变化</td><td>政策法规变化；某批原料出现供应链问题；突然出现的现金流问题</td></tr><tr><td>破索</td><td>索是软兵刃，中途拦截无用，末端还是会打上来</td><td>竞对高薪挖人，人员流失</td></tr><tr><td>破鞭</td><td>钢鞭 、铁锏、蛾眉刺、板斧等等短兵刃…攻速慢，但是碰到要害杀伤力强</td><td>针对我们的主力软件产品，出现了开源的免费产品；临时限电，工厂需要停工一天</td></tr><tr><td>破箭</td><td>远程攻击——速度快，大多为小伤害,但有迹可循</td><td>某批次产品质量出现问题； 来客数持续降低</td></tr><tr><td>破掌</td><td>手极为灵活，组合拳，竞争对手</td><td>对手的新营销方案针锋相对，导致我们销量下降</td></tr><tr><td>破气</td><td>上乘内功，就像强大的行业龙头</td><td>挑战行业龙头时面临的各种不可知变化</td></tr><tr><td>总诀</td><td>周易有云「归妹趋无妄、无妄趋同人、同人趋大有、甲转丙、丙转庚、庚转癸、子丑之交、辰巳之交、午未之 交、风雷是一变、山泽是一变、水火是一变、乾坤相激、震兑相激、离巽相激、三增而成五、五增而成九……」 万事都在变化，变化过程是有规律的，变化的发生是无规律的</td><td>ITPAO： 上游资源可能变化 目标可能变化 计划可能变化 执行过程可能变化 冲突点是有规律的，变化会互相影响，最后形成不可预料的结果。</td></tr></tbody></table><h2>02</h2><table><thead><tr><th>内容</th><th>说明</th><th>数据及知识支持</th><th>逻辑关系</th></tr></thead><tbody><tr><td>I—输入</td><td>三类输入：资源、边界，结构； 资源、边界由上一环节流入，结构定义输出的结构</td><td>数据、资源、存储</td><td>可被跟踪，可被拆解，可被汇总，快速发现冲突问题</td></tr><tr><td>T—目标</td><td>外部输入转变为内部可清晰定义的目标。由于输入条件的变化，输出范围的变化可进行动态调整</td><td>知识库，清晰无歧义，可量化的目标</td><td>动态目标调整、预测、资源冲突，时间冲突</td></tr><tr><td>P—计划</td><td>根据目标和能力，进行拆解，核心是资源和边界，规划用什么资源在什么时间做什么最合理和高效</td><td>可用资源、冲突关系、时序、实时计划表</td><td>时序冲突、空间冲突、资源冲突、目标节点</td></tr><tr><td>A—行动</td><td>具体的行动，通过对资源和时间的消耗，进行具体的行动，以达到输出结果</td><td>可用资源、组织、实际行动能力、执行对象</td><td>现有资源、现有产出、偏差、预测</td></tr><tr><td>O—输出</td><td>输出资源变化，传导给下一层，并对I定义的输出进行反馈。</td><td>资源、边界，结构</td><td>作为下一层的输入</td></tr></tbody></table><p>基于ITPAO的系统结构，我们可以把业务中可能产生的冲突与变化（绿色部分）等同于不同招式对我们的攻击（<strong><em>有种种变化，用以体演总诀，共有三百六十种变化。临敌时，可以此为基础，将八式剑意，融入其中，达到九剑归一的程度</em></strong>）。</p><p><img width="723" height="377" referrerpolicy="no-referrer" src="/img/bVdnb8S" alt="image.png" title="image.png" loading="lazy"/></p><p>另外，独孤九剑有三大要诀</p><table><thead><tr><th>要诀</th><th>表象</th><th>AI应用逻辑</th></tr></thead><tbody><tr><td>无招胜有招</td><td>不要急着出手，先找招式中的破绽</td><td>守正出奇，有自己的基础流程，有应对外部变化的能力</td></tr><tr><td>料敌机先</td><td>能找到敌人的破绽</td><td>AI的能力需要知识支撑</td></tr><tr><td>有进无退</td><td>只攻不守，攻其必救</td><td>解决问题的优先级很重要，还要有关于创新的勇气</td></tr></tbody></table><p>真正的武功，是自洽的，是可以迭代的复杂体系，而不是简单的“化转发、闪电五连鞭”。</p><p>其他的一些思考：</p><ul><li><strong><em>“独孤前辈是绝顶聪明之人，学他的剑法，要旨是在一个‘悟’字，决不在死记硬背。等到通晓了这九剑的剑意，则无所施而不可，无所不出，无所不入，便是将全部变化尽数忘记，也不相干，临敌之际，更是忘记得越干净彻底，越不受原来剑法的拘束。”</em></strong></li></ul><p>从数据，信息，变成肌肉记忆——&gt; 经验——&gt;知识，最后AI高效调用知识。</p><ul><li><strong><em>“在华山山洞中，因眼不见物，无法找到对手破绽，最后意外靠魔教十长老的腿骨中的<a href="https://link.segmentfault.com/?enc=wA2HxGi3U37sCk0EgFxhdw%3D%3D.s05NeDL9sHD0INyFEuRq28Nb3VZFX%2BEWOVyotIvWexlKGf3w8c8yy2X7zc15lJcSC%2BYZgmFjzTxcjiJi9s%2BEnSi1MuHC4SYvN%2FnQKid%2B0Edu5zGBqcc2aLbY0zq%2BNpBDEFk1qLvHXa5JkKjrOtC33tJHF4NGAVMZ7HD7TFc8c%2BjGWxSWtgvHC28drfQdtutP7GL0NxysLA9XhfrON1vyX%2F44jMr02KAuHi%2FeHFUUWn6G9XszDoal36QlPjaSaUUKtbg4YbmsqIsKEwOdvCV3J%2FCNULvh70HmPH%2F2nBQFde77TrjdSlT2jWZx3kQKdf%2F9rbyjWg%2BvWXNPBIDf9GieeAB5bFCBrt6l21LfgKXD5UFPURxi%2FelSP4XxsNQ%2BX7ffPOE1e4jGg2ZRWWW7M%2BzHJQ%3D%3D" rel="nofollow" target="_blank">磷光</a>得以见到 对手武功，才得以施展剑法。”......“独狐九剑”的要旨，在于一眼见到对方招式中的破绽，便即乘虚而入，后发先至，一招制胜。</em></strong></li></ul><p>信息系统的数据是基础，缺少数据，成了瞎子，再好的剑法也没用。</p><ul><li><strong><em>“令狐冲学会独孤九剑后棋逢对手甚至差点落败的是东方不败。”</em></strong></li></ul><p>就像今天的美国，把自己割了以后，各种招式诡异多变，关税政策一日多变，各种强权压制，这也是变化带来的最大挑战。</p><p>令狐冲是怎么打赢东方不败？任盈盈在边上对杨莲亭下手干扰了东方不败……当AI的利剑遇到了无法斩断的敌人，我们需要人机结合进行兜底。某企业上线AI客服后效果很棒，因此裁掉了大量的真人客服，后来新品出现时，AI针对这个新品的客服出现问题，立刻陷入焦头烂额的局面。因此，在AI落地时，必须考虑兜底的问题，而好的合作伙伴能够拯救你于水火之中。</p><ul><li><strong><em>黄钟公不知对令狐冲的剑法却也是高估了。“独孤九剑”是敌强愈强，敌人如果武功不高，“独孤九剑”的精要处也就用不上。</em></strong></li></ul><p>AI的效率提升，更适合做一些复杂的，人脑无法处理的工作，例如，需要连续高强度思考，需要综合很多信息，需要在复杂的关系中找到逻辑。在这些场景，AI才能够发挥更大的作用。</p><p>剑只是工具，AI也只是工具，用来干什么才是关键。所有的应用和场景都应该从管理维度出发，而不仅是提高效率，因为一味提高效率，并不一定能够完成企业真正的目标。</p><p>今天，我们以独孤九剑为例，介绍了在ITPAO体系使用AI辅助管理，应对变化的应用，一旦我们在这个层面使用AI，而不是仅仅把AI当成一个问答器，一个画图工，让AI发挥AI的长处，通过建立完备的知识体系，准确的数据供给，可以承载变化的流程架构，就可以做到“随风潜入夜，润物细无声”，这时候的AI无处不在，再也不用去苦苦地寻找AI场景。</p><p><img width="723" height="328" referrerpolicy="no-referrer" src="/img/bVdnb8T" alt="image.png" title="image.png" loading="lazy"/></p><p>AI无处不在，应对变化就是最大的场景</p>]]></description></item><item>    <title><![CDATA[启信宝发布《全国产业集群大全》哈尔滨篇：]]></title>    <link>https://segmentfault.com/a/1190000047434889</link>    <guid>https://segmentfault.com/a/1190000047434889</guid>    <pubDate>2025-11-28 15:08:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>寒潮袭来，国内冰雪旅游市场正悄然升温，“北上追雪”成为消费新热点。随着第27届哈尔滨冰雪大世界启动冰建工作，这座北方“冰城”正式进入冰雪时间。</p><p>作为我国万亿冰雪产业的关键一环，哈尔滨的冰雪经济发展备受关注。近期，启信宝发布《全国产业集群大全》哈尔滨篇，系统梳理当地冰雪产业的发展现状与集群特征。报告提到，哈尔滨已构建起较为完整的冰雪产业链，尤其在装备制造领域形成龙头引领效应，并依托全域资源协同，展现出强大竞争力。</p><h3>2300家企业撑起1600亿冰雪经济</h3><p>2024年，“尔滨”火遍全网，冰雪旅游的流量迅速转化为哈尔滨的产业增量。据哈尔滨市政府新闻办介绍，当年哈尔滨冰雪经济总规模突破1600亿元，占全国总量16.5%，凸显其行业重要地位。</p><p>亮眼的经济数据，源于坚实的产业基础。启信宝数据显示，截至2025年11月，哈尔滨全市冰雪产业相关企业总数已突破2300家，近三年新成立企业数量1082家，年均复合增长率23.6%。其中2024年增速最快，高达29%。显示城市出圈有效吸引多元市场主体汇聚，共同做大产业蛋糕。</p><p>资本动向进一步印证了市场对哈尔滨冰雪经济增长的信心。启信宝数据显示，近四年来，哈尔滨冰雪产业累计吸引外来投资150次，2024年占比47%，接近半数。同期本地企业对外拓展意愿强烈，近四年累计发生对外投资114次。表明当地产业在吸引外部“活水”的同时，也正主动向外开拓新的发展空间。</p><p>启信宝产业链数据进一步量化了哈尔滨冰雪产业的“家底”。根据启信宝数据，哈尔滨冰雪经济已形成一条脉络清晰、协同发展的完整产业链。产业下游环节企业数量最多，占比超70%，涵盖1700余家旅行社和270多家票务服务企业。二者构建起支撑千万级客流的成熟服务网络。中游企业数量仅次其后，占比约15%。以哈尔滨冰雪大世界、大文化旅游集团为代表的6家冰雪旅游产品企业，协同400余家赛事运营企业，带动冰雪产业从“一季火爆”走向“四季常青”。</p><p>产业上游虽企业数量不多，但聚焦冰雪场地与装备制造等核心环节，构成了冰雪产业的硬核基础。启信宝数据显示，哈尔滨已集聚80余家冰雪装备企业，产品体系覆盖以冰刀、雪板、冰壶为代表的冰雪运动装备，以及以索道、魔毯、造雪制冰设备为代表的冰雪场地装备。并涌现出乾卯雪龙、几口科技、鸿基索道等一批龙头企业，持续推动产业链向专业化、高端化发展。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047434891" alt="图片" title="图片"/></p><h3><strong>“</strong>冰雪+”联动全域，激活老工业基地新动能</h3><p>哈尔滨的产业特色远不止冰与雪。近日，哈尔滨全新推出“冰雪+工业”旅游项目，让游客在邂逅冰雪浪漫的同时，触摸城市工业脉络。这背后是全域产业的协同配合。启信宝数据显示，哈尔滨全市共培育112个集群，覆盖航空、装备制造、卫星、生物医药、食品等多个重点领域。其中，航空与生物制造两大集群入选国家先进制造业集群。这些集群优势为哈尔滨铸就硬核产业实力。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047434892" alt="图片" title="图片" loading="lazy"/></p><p>在区域协同层面，各区县依据自身产业禀赋，形成了功能互补的产业布局。例如松北区依托卫星、新材料与高端装备制造等产业基础，重点发力高端冰雪装备的研发与升级。其中，冰雪欢腾企业与哈工大院士团队合作，将碳纤维、钛合金等航天材料应用于冰雪装备制造。与此同时，道里区侧重冰雪衍生产品、尚志市聚焦专业运动设备。三者协同，为冰雪经济注入多元活力。</p><p>在万亿元冰雪经济新赛道上，“冰雪+”如同一把钥匙，打开了哈尔滨老工业基地全域协同的新动能。启信宝依托企业资源优势，构建了300多条全景产业链、3000条细分产业链、22000个产业集群的数据库，覆盖全国重点产业和2800多个区县的特色产业。未来，启信宝将继续通过《全国产业集群大全》城市篇系列报告，持续为政府、金融机构及研究机构提供坚实可靠的产业分析决策支持。</p>]]></description></item><item>    <title><![CDATA[基于Rokid的生活日记Glass拍照录]]></title>    <link>https://segmentfault.com/a/1190000047434904</link>    <guid>https://segmentfault.com/a/1190000047434904</guid>    <pubDate>2025-11-28 15:07:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在智能穿戴设备日益普及的今天，AR眼镜已经不再是科幻作品中的概念，而是可以真正融入我们日常生活的工具。本文将分享一个基于 Rokid CXR-S SDK 的纯眼镜端实战项目——生活小记Glass拍照录像应用（Glass记小圈应用）。通过这一实战项目，我将带你从零构建一个能够拍照、录像、录音并进行基本媒体管理的眼镜端应用，并分享开发过程中遇到的技术细节与优化经验。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047434906" alt="在这里插入图片描述" title="在这里插入图片描述"/></p><h2>一、项目背景与目标</h2><p>在日常生活中，我们经常希望随手记录瞬间，但拿出手机拍照或录像有时不够便利。AR眼镜的优势在于 免手持、即时记录。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434907" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/>Glass记小圈应用目标：</p><ol><li>通过眼镜单机操作或AI场景，实现拍照、录像、录音功能。</li><li>支持拍照与录像参数自定义，如分辨率、画质、时长等。</li><li>提供回调机制，方便获取拍照图片或录像路径，实现后续数据同步或处理。</li><li>纯眼镜端实现，无需依赖移动端应用。<br/>信息交互模型如下。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434908" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h2>二、开发环境与依赖</h2><ul><li>开发语言：Kotlin</li><li>SDK版本：CXR-S SDK 1.0.1</li><li>IDE：Android Studio Arctic Fox 或以上</li><li>权限：相机、麦克风、存储</li></ul><p>在 AndroidManifest.xml 中，需要声明以下权限：</p><pre><code class="bash">&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;</code></pre><p>运行时需动态申请权限，以保证拍照、录像和录音功能正常。</p><h2>三、拍照功能实现</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434909" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/>CXR-M SDK 是一款移动端开发工具包，专为构建 Rokid 眼镜的配套应用和控制应用而设计。它支持手机与眼镜之间的稳定连接、数据通信、实时音视频访问以及场景自定义。非常适合需要基于手机的用户界面、远程控制或与眼镜进行高级协作的应用。目前适用于 Android 系统。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434910" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h3>3.1 单机功能键拍照</h3><p>通过 SDK 提供的接口 setPhotoParams(width: Int, height: Int)，可以设置单机按键拍照的分辨率：</p><pre><code class="bash">val status = CxrApi.getInstance().setPhotoParams(1920, 1080)
when (status) {
    ValueUtil.CxrStatus.REQUEST_SUCCEED -&gt; Log.d(TAG, "单机拍照参数设置成功")
    else -&gt; Log.e(TAG, "设置失败: $status")
}</code></pre><p>用户按下眼镜功能键即可拍照，拍照结果存储在未同步媒体文件中。</p><h3>3.2 AI场景拍照</h3><p>在AI场景中，可以直接控制相机并获取图片数据：</p><pre><code class="bash">private val photoCallback = object : PhotoResultCallback {
    override fun onPhotoResult(status: ValueUtil.CxrStatus?, photo: ByteArray?) {
        if (status == ValueUtil.CxrStatus.RESPONSE_SUCCEED &amp;&amp; photo != null) {
            // 将WebP图片保存或处理
            savePhoto(photo, "ai_scene_photo.webp")
        }
    }
}

fun takeAiScenePhoto() {
    CxrApi.getInstance().openGlassCamera(1280, 720, 80)
    CxrApi.getInstance().takeGlassPhoto(1280, 720, 80, photoCallback)
}</code></pre><p>Tips：AI场景拍照通过蓝牙传输图片，建议选择 较小分辨率和适中压缩质量。</p><h3>3.3 获取拍照路径</h3><p>如果需要获取图片的文件路径，可以使用 takeGlassPhoto(width, height, quality, PhotoPathCallback)：</p><pre><code class="bash">private val photoPathCallback = object : PhotoPathCallback {
    override fun onPhotoPath(status: ValueUtil.CxrStatus?, path: String?) {
        if (status == ValueUtil.CxrStatus.RESPONSE_SUCCEED &amp;&amp; path != null) {
            Log.d(TAG, "拍照文件路径: $path")
        }
    }
}

fun takePhotoWithPath() {
    CxrApi.getInstance().takeGlassPhoto(1280, 720, 90, photoPathCallback)
}
</code></pre><h2>四、录像功能实现</h2><h3>4.1 录像参数设置</h3><p>通过 setVideoParams(duration, fps, width, height, unit) 可以自定义录像参数：</p><pre><code class="bash">CxrApi.getInstance().setVideoParams(
    duration = 60, fps = 30,
    width = 1280, height = 720,
    unit = 1 // 1=秒
)</code></pre><h3>4.2 开启与关闭录像场景</h3><p>录像通过控制场景实现：</p><pre><code class="bash">fun startVideoRecord() {
    CxrApi.getInstance().controlScene(ValueUtil.CxrSceneType.VIDEO_RECORD, true, null)
}

fun stopVideoRecord() {
    CxrApi.getInstance().controlScene(ValueUtil.CxrSceneType.VIDEO_RECORD, false, null)
}</code></pre><p>用户可以通过手势或按键快速开启/关闭录像，实现便捷记录。</p><h2>五、录音功能实现</h2><p>录音可以结合AI应用场景实现，SDK提供回调监听音频流：</p><pre><code class="bash">private val audioListener = object : AudioStreamListener {
    override fun onStartAudioStream(codecType: Int, streamType: String?) {
        Log.d(TAG, "音频流开始，codec=$codecType")
    }
    override fun onAudioStream(data: ByteArray?, offset: Int, length: Int) {
        // 处理PCM或Opus音频数据
    }
}

fun startAudioRecord() {
    CxrApi.getInstance().setAudioStreamListener(audioListener)
    CxrApi.getInstance().openAudioRecord(codecType = 1, streamType = "DailyNote")
}

fun stopAudioRecord() {
    CxrApi.getInstance().closeAudioRecord("DailyNote")
}
</code></pre><h2>六、服务端处理与场景落地应用</h2><p>虽然 Glass记小圈 应用实现了完整的拍照、录像、录音等能力，且可在眼镜端本地完成所有操作，但在真实生活场景中，如果仅依赖眼镜本地存储会出现诸多限制：<br/> 如存储空间有限、文件难以整理、无法跨设备查看、AI 分析难以在本地运行等。<br/> 因此服务端的作用绝不仅仅是“接收与后处理”，而是构建一个完整的生活记录系统的关键基础。<br/>为了便于理解，我们从“真实使用场景”出发，拆解服务端的作用。</p><h3>6.1 场景：生活记录归档（Life Log场景）</h3><p>在 Glass 记小圈 应用的使用场景中，最核心、最贴近用户日常的是“生活记录归档”。AR 眼镜的优势在于解放双手、随时可用，使其非常适合承担低干扰、不打断当下体验的实时记录任务。因此，Life Log 的设计不仅仅是简单的拍照与录像，而是围绕“如何让用户毫无感知地记录生活点滴，并在之后自动归类、整理、备份”这一目标构建的完整交互链路。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047434911" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h4>①即时记录：无感操作的核心体验</h4><p>在真实的生活场景中，例如散步、骑行、与朋友聊天、做手工、下厨时，用户往往没有额外的手去操作设备。眼镜端的操作设计因此强调“轻触即用”——短按拍照、长按录像、语音触发录音，整个操作无需用户停下手中的动作，也不会改变当下沉浸体验。<br/>在这一模式下，眼镜端利用 CXR-S SDK 对相机和音频模块进行轻量化调用，确保操作延迟极低。例如拍照调用通常在 150–300ms 内完成拍摄与写入，用户几乎无感延时；录音与录像在触发后会立即返回场景启动状态，确保不会错过关键画面。<br/>即时记录的核心，是让设备成为用户身体的延伸，而不是额外的负担。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434912" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/></p><h4>②本地归档：结构化存储与未同步机制</h4><p>为了保证数据安全性和高可靠性，眼镜端采用“本地优先”的存储策略：</p><ul><li>每一张照片、视频、录音，都先写入本地的未同步目录（/media/unsync）</li><li>并生成组件化的元数据（时间戳、类型、大小、参数、触发方式）</li><li>在 UI 侧实时更新历史记录列表，让用户能够随时回看<br/>这样的机制允许在无网络、弱网络或用户尚未登录云端服务的场景下，依然能保持完整的记录。<br/>为了避免存储膨胀，系统还实现了轻量化资源回收策略，例如：</li><li>对于超长视频自动按 10 分钟切片</li><li>自动压缩 AI 场景下的 WebP 图片</li><li>本地媒体达到阈值时触发提示与自动清理候选列表<br/>本地归档系统在极端情况下也能保证记录不丢，从而构建 Life Log 的基础可靠性。</li></ul><h3>6.2 场景：AI 辅助生活的小助手（未来扩展场景）</h3><p>在 Glass 记小圈 的整体架构中，服务端不仅承担媒体存储与同步的角色，更是未来智能能力的核心承载者。随着用户逐渐形成连续的拍照、录像、录音习惯，系统会积累大量生活切片，而真正的价值在于如何将这些碎片加工为“可理解、可索引、可回顾”的记忆资产。这正是 AI 生活助手的作用所在。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434913" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/>AI 智能总结：把一天的碎片拼成“生活日记”</p><p>用户的一天通常由散落的照片、零星的视频和短暂的录音组成。单独看这些媒体，它们只是孤立的文件；但经过 AI 处理后，它们可以被组织成一篇有结构、有内容、有主题的自动化日记。<br/>这一过程涉及多个服务端能力协同工作：</p><p>（1）图像理解与场景识别<br/>服务端模型会对每张图片进行：</p><ul><li>场景类别识别（如“公园”“厨房”“办公室”）</li><li>物体检测（如“猫”“植物”“餐盘”）</li><li>OCR 提取文字（如菜单、路牌、白板内容）<br/>这些语义将作为后续日记生成的“素材语料”。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434914" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/>（2）视频摘要处理<br/>视频比图片包含更丰富但更分散的信息，因此需要：关键帧提取、场景变化检测、物体持续性跟踪、简短文本摘要（如“制作食物过程片段”“散步中的街景”）。服务端可根据时长自动压缩信息量，使其更适合写入生活日记。<br/>（3）音频转写与内容提取<br/>对于会议、对话、分享记录等音频片段，服务端可执行：ASR 语音转文字、说话人区分、关键句抽取，情绪识别（如激动、开心、平静）。这让日记不仅记录“做了什么”，也记录“说了什么”。<br/>（4）AI 生成式总结：构建结构化生活小记<br/>当一天的媒体数据被整合后，AI 日记生成器会根据时间线、地理位置（如用户开启定位）、场景标签与内容文字生成一段结构化叙述。例如：</p><blockquote>下午 2 点，你在植物园拍摄了 7 张照片，AI 识别到三类植物：向日葵、薰衣草与芦荟。<br/> 稍后你录制了一段 18 秒的视频，内容是你在园区小径散步。<br/> 当天总计拍摄 3 分钟视频、记录 2 段语音、10 张照片，整体主题偏向“自然与户外活动”。</blockquote><p>这样的“生活小记”不再是一堆文件，而是一个可阅读、可分享、可检索的记忆摘要。</p><h3>6.3服务层处理逻辑</h3><p>在 Glass记小圈应用中，虽然所有功能均可在眼镜端完成，但为了实现数据集中管理、云端同步、备份以及后续 AI 分析，我们需要搭建一个服务端系统，用于接收、存储和管理多媒体文件。服务端主要职责包括：</p><ol><li>文件接收与存储：通过 HTTP 或 WebSocket 接收眼镜端上传的照片、视频、音频文件，并存储到服务器指定路径。</li><li>文件元数据管理：记录文件名称、路径、拍摄时间、类型等信息，方便后续检索和展示。</li><li>异常处理与重试机制：处理传输中断、文件损坏、重复上传等问题。</li><li>接口设计：提供 RESTful API 供眼镜端上传和获取数据。</li></ol><pre><code class="bash">package com.glassserver.controller

import com.glassserver.model.MediaFile
import com.glassserver.service.MediaService
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import org.springframework.web.multipart.MultipartFile

@RestController
@RequestMapping("/media")
class MediaController(private val mediaService: MediaService) {

    @PostMapping("/upload/{type}")
    fun uploadMedia(
        @RequestParam("file") file: MultipartFile,
        @PathVariable type: String
    ): ResponseEity&lt;MediaFile&gt; {
        return try {
            val savedFile = mediaService.saveMedia(file, type)
            ResponseEntity.ok(savedFile)
        } catch (e: Exception) {
            ResponseEntity.status(500).build()
        }
    }

    @GetMapping("/list/{type}")
    fun listMedia(@PathVariable type: String): ResponseEntity&lt;List&lt;MediaFile&gt;&gt; {
        val files: List&lt;MediaFile&gt; = mediaService.listMediaByType(type)
        return ResponseEntity.ok(files)
    }
}</code></pre><p>眼镜端上传</p><pre><code class="bash">fun uploadPhotoToServer(photoPath: String) {
    val file = File(photoPath)
    val client = OkHttpClient()
    val body = MultipartBody.Builder()
        .setType(MultipartBody.FORM)
        .addFormDataPart("file", file.name, file.asRequestBody("image/webp".toMediaType()))
        .build()

    val request = Request.Builder()
        .url("http://yourserver.com/media/upload/photo")
        .post(body)
        .build()

    client.newCall(request).enqueue(object : Callback {
        override fun onFailure(call: Call, e: IOException) {
            Log.e(TAG, "上传失败: ${e.message}")
        }

        override fun onResponse(call: Call, response: Response) {
            if (response.isSuccessful) {
                Log.d(TAG, "上传成功")
            } else {
                Log.e(TAG, "服务器返回异常: ${response.code}")
            }
        }
    })
}</code></pre><p>这个服务端模块不仅可以支持 Glass记小圈应用的多媒体管理，也可以为未来 AI 分析、用户云端备份等功能打下基础。</p><h2>七、应用交互与实战经验</h2><p>在开发 Glass记小圈应用 的过程中，眼镜端的交互设计和实战经验起到了核心作用。由于应用完全运行在眼镜端，用户的操作主要依赖功能键和有限的触控/语音输入，因此在设计交互流程时必须充分考虑操作的直观性与反馈的及时性。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434915" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/>在拍照和录像功能上，我们采用单机按键和长按两种触发方式，短按用于拍照、长按用于录像的开始和结束，同时在操作过程中加入状态锁定，避免重复触发或冲突操作，保证应用的稳定性。在AI场景拍照时，为了应对蓝牙传输延迟和图片体积较大的问题，我们对分辨率和压缩质量进行了优化选择，优先使用适合传输的中低分辨率，同时通过回调机制及时获取拍照结果，并在UI中提供加载状态和完成提示，让用户明确操作是否成功。在录像和录音功能上，考虑到眼镜端硬件性能和功耗，我们在开启前设置了合理的参数，包括时长、帧率和编码类型，并通过状态回调实时监控录像、录音过程，确保异常情况下可以立即停止或重新初始化。<br/>在数据管理方面，我们统一了照片、视频和音频的存储路径，结合未同步媒体文件夹和回调机制实现文件的本地缓存和后续同步，保证数据不会丢失，同时在UI上以列表或历史记录的方式呈现，方便用户快速回顾。在开发过程中，我们也积累了大量实战经验，包括优化蓝牙连接的重试机制、在长时间操作中合理释放资源以降低功耗、处理拍照和录音的异常情况、防止连续操作造成回调阻塞，以及在UI中提供明确的状态提示以提升用户体验。<br/>这些实践经验不仅保证了应用的稳定性和交互流畅性，也为今后扩展多媒体功能、加入更多AI场景或优化用户体验提供了坚实基础。</p><h2>八、总结</h2><p>通过本次 Glass记小圈应用 的开发实战，我们完整地梳理了纯眼镜端应用从功能设计、SDK集成到多媒体交互的开发流程。在拍照、录像和录音的实现过程中，我们不仅熟悉了CXR-S SDK提供的接口和回调机制，还深入理解了眼镜端在硬件性能、功耗和蓝牙传输等方面的限制与优化策略。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434916" alt="在这里插入图片描述" title="在这里插入图片描述" loading="lazy"/><br/>实践中，我们积累了丰富的经验，包括参数设置优化、异常处理与重试机制、文件管理与历史记录维护，以及用户交互的直观设计与反馈提示，这些都有效提升了应用的稳定性和用户体验。此外，通过对AI场景拍照和录像功能的深入调试，我们掌握了如何在受限资源环境下平衡数据质量与传输效率，为未来扩展更复杂的多媒体和AI交互场景打下了坚实基础。总体而言，本次开发不仅让我们熟练掌握了Rokid眼镜端的核心能力，也为后续构建更完整的AR生活应用提供了宝贵的实战参考和可复用经验。</p>]]></description></item><item>    <title><![CDATA[Access业务系统中的瀑布图开发指南 ]]></title>    <link>https://segmentfault.com/a/1190000047434937</link>    <guid>https://segmentfault.com/a/1190000047434937</guid>    <pubDate>2025-11-28 15:06:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>hi，大家好！<br/>我们接着来讲图表。<br/>在数据分析领域，瀑布图（Waterfall Chart） 是一种非常直观的工具。它能清晰地展示一个初始值是如何经过一系列正负变化（增加或减少），最终形成结束值的过程。通常我们习惯用 Excel 或 Power BI 来制作瀑布图，但作为 Access 开发者，当客户要求在窗体或报表中直接展示这种图表时，我们该怎么办？<br/>答案是Access也可以实现，今天我们就来讲瀑布图。<br/><strong>瀑布图（Waterfall Chart），又被称为阶梯图或桥梁图，是一种专门用于展示数据如何从一个初始值，经过一系列中间的正负变化，最终变成一个结束值的图表。简单来说，它能帮你解释“钱（或数量）是怎么变多或变少的”</strong>。</p><h2>PART01创建数据</h2><p>还是一样，我先来创建图表需要的数据。<br/><img width="440" height="177" referrerpolicy="no-referrer" src="/img/bVdnb87" alt="" title=""/></p><h2>PART02创建图表</h2><p>在插入新式图表时，要选择水位下降图，这个可能是翻译的问题，这个就是瀑布图，大家不要找错了。</p><p><img width="163" height="190" referrerpolicy="no-referrer" src="/img/bVdnb89" alt="" title="" loading="lazy"/></p><h2>PART03图表设置</h2><p>接着，我们就可以来给图表添加数据了，大家可以按我的方式设置。</p><p><img width="329" height="605" referrerpolicy="no-referrer" src="/img/bVdnb9a" alt="" title="" loading="lazy"/><br/><img width="325" height="545" referrerpolicy="no-referrer" src="/img/bVdnb9b" alt="" title="" loading="lazy"/></p><h2>PART04运行</h2><p>添加好了，就可以运行看一下效果了。<br/>💡 效果展示<br/><img width="723" height="542" referrerpolicy="no-referrer" src="/img/bVdnb9d" alt="" title="" loading="lazy"/></p><p>普通的柱状图只能告诉你“结果是多少”，而瀑布图能告诉你“结果是怎么来的”。在财务损益分析、库存流动监控、销售业绩归因等场景中，瀑布图能清晰地拆解出每一个正向增量（如收入、入库）和负向减量（如成本、出库），让数据的流动过程一目了然。<br/>长期以来，Access 常被诟病可视化能力弱。但通过这种“数据源改造 + 属性微调”的方式，我们证明了 Access 完全有能力承担复杂的商业智能（BI）展示任务。不需要导出到 Excel，不需要借助昂贵的第三方插件，在业务流程的源头（Access 窗体/报表）直接呈现高价值图表，这才是全栈开发的魅力所在。<br/>希望大家能将这个技巧应用到实际项目中，让你的 Access 系统不仅能“存数据”，更能“懂数据”！喜欢</p><p><strong>这篇文章吗？欢迎点赞、转发，让更多 Access 爱好者看到！</strong></p>]]></description></item><item>    <title><![CDATA[如何将我的Infinix手机连接到电脑进]]></title>    <link>https://segmentfault.com/a/1190000047434939</link>    <guid>https://segmentfault.com/a/1190000047434939</guid>    <pubDate>2025-11-28 15:06:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>​对于许多用户来说，将内容从Infinix手机迁移到电脑是一项重要任务。有些人可能希望为重要数据创建备份，释放空间，更高效地管理文件，在设备之间同步数据，或解决手机问题。那么，如何高效地将文件从Infinix传输到电脑？ 本指南将介绍五种出色的方法来完成此任务，确保您的数据安全、可访问且井井有条。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434941" alt="图片" title="图片"/></p><p>方式1：如何灵活地将文件从Infinix传输到电脑</p><p>使用iReaShare Android Manager（Windows和Mac版本），一款高质量的安卓手机管理工具，您将有两种灵活的方式将各种内容从Infinix手机传输到电脑，不仅限于常见的媒体文件（如照片和视频）。您只需下载该软件，准备一根可用的USB线将手机连接到电脑，然后按照提示操作即可。之后，如果您想备份、恢复、编辑和管理手机上的内容，都可以直接在电脑上完成。为什么选择iReaShare Android Manager？</p><pre><code>有选择地将文件从Infinix传输到电脑（也可反向传输）。
批量在安卓设备和电脑之间复制数据。
在电脑上查看/编辑/管理手机内容。
支持安卓设备上的媒体和非媒体文件。
独立运行，易于操作，无数据质量损失。
支持多种Infinix及其他安卓手机/平板（如Infinix Hot 40 Pro、Infinix Hot 20 5G、Infinix Hot 20S、Infinix Note 11 Pro等）。
完全注重隐私保护。

</code></pre><p>如何灵活地使用iReaShare Android Manager将数据从Infinix传输到笔记本电脑/台式机？步骤1：连接Infinix手机——在电脑上下载并安装该程序。启动工具，然后通过USB将Infinix手机连接到电脑。如有必要，请在设备上启用USB调试以建立连接。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434942" alt="图片" title="图片" loading="lazy"/></p><p>步骤2：选择内容——连接成功后，软件将显示主窗口，展示您手机的基本信息和数据类型。在左侧菜单中点击您想要传输的文件类别。</p><p>步骤3：传输文件——预览手机中的详细信息，选择您想要传输到电脑的文件。选择完成后，点击顶部菜单栏中的“导出”按钮开始传输过程。</p><p>可选操作： 该软件还配备了一键备份与恢复功能。用户可以轻松地将多个Infinix项目备份到电脑。只需进入“超级工具包”部分，点击“备份”，选择数据类型，然后点击“备份”即可。以下是一个视频指南，您可以直观地了解该工具的使用方法：</p><p>方式2：如何通过文件资源管理器将文件从Infinix移动到电脑</p><p>使用USB线复制文件是一种流行且简单的方法，适用于文件资源管理器（Windows 8/7中的Windows资源管理器）。以下是如何通过这种方式将数据从Infinix手机传输到电脑：</p><pre><code>将USB线的一端插入手机，另一端插入电脑的USB端口。
在Infinix设备上，您会在状态栏看到一条通知：“安卓系统，点击了解更多选项”。
点击该通知，将出现一个下拉菜单。选择“用于文件传输”。
要将相机拍摄的照片传输到电脑，请双击SD卡或内部存储。
点击DCIM文件夹，其中包含您的图片、视频和音乐。
将相机文件夹中的每个项目拖放到电脑上的目标位置。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434943" alt="图片" title="图片" loading="lazy"/></p><p>方式3：如何通过“连接至Windows”将文件从Infinix复制到电脑</p><p>连接至Windows允许您查看和回复短信、拨打和接听电话、查看通知、传输文件等。要使用此功能，请确保您的Infinix手机运行的是Android 7.0或更高版本，并从Google Play商店下载该应用。以下是通过此工具将Infinix与电脑同步的步骤：</p><pre><code>解锁您的Infinix手机并运行“连接至Windows”应用。
使用USB线将手机连接到电脑。
在手机上，您会看到通知“通过USB为设备充电”。
点击该通知并选择“文件传输”。
电脑上会打开一个文件传输窗口。
使用它拖放文件，在Infinix手机和电脑之间传输。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434944" alt="图片" title="图片" loading="lazy"/></p><p>如果您在电脑上的“连接至Windows”应用中看不到您的Infinix手机怎么办？快速指南：确保两台设备连接到同一个Wi-Fi网络，并且“连接至Windows”已在Infinix手机上正确设置。如果问题仍然存在，请尝试重启两台设备并重新建立连接。</p><p>方式4：如何通过蓝牙将文件从Infinix手机传输到电脑</p><p>如果您的电脑具备蓝牙功能，您可以轻松使用此功能将文件从Infinix手机传输到电脑。对于Windows 11用户，提供了详细指南，其他Windows版本的用户也可以应用相同的步骤。</p><pre><code>从手机屏幕顶部向下滑动，打开快捷访问菜单。
点击蓝牙图标以开启蓝牙。
在电脑上，打开“设置”并点击“设备”。
确保蓝牙已启用，然后点击“添加蓝牙或其他设备”。
选择蓝牙，找到您的安卓手机并点击“连接”。
在手机上接受配对请求。
配对成功后，您可以通过蓝牙无线共享文件。
右键点击工具栏中的蓝牙图标，选择“接收文件”。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434945" alt="图片" title="图片" loading="lazy"/></p><p>方式5：如何通过SD卡将文件从Infinix手机传输到笔记本电脑</p><p>如果您的Infinix手机中装有SD卡，您可以直接将手机连接到电脑，或取出SD卡并使用读卡器将其连接到电脑。然后，您可以直接将SD卡中的内容传输到连接的电脑。以下是通过SD卡将文件从Infinix导出到电脑的步骤：</p><pre><code>如有需要，将您的数据移动到SD卡。
使用USB线将插入SD卡的手机连接到电脑。（或者，从手机中取出SD卡，并通过SD卡读卡器将其连接到电脑）
在电脑上，打开Windows自动播放并点击“打开文件夹以查看文件”，然后点击“确定”。
打开可移动磁盘窗口并选择SD卡文件夹。
找到您要传输的文件。
将文件从SD卡复制或拖放到电脑。
通过在手机上选择“断开连接”来安全断开手机。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434946" alt="图片" title="图片" loading="lazy"/></p><p>重要提示： 为确保顺利的SD连接和数据传输，请检查以下事项：</p><ol><li>确保SD卡正确插入。</li><li>如有需要，尝试使用其他SD卡读卡器。</li><li>更新或重新安装电脑上的SD卡读卡器驱动程序。</li><li>确保传输完成且未中断。</li><li>检查Infinix手机上的原始文件。</li><li>如果文件似乎已损坏，请使用数据恢复软件。</li></ol><p>总结</p><p>通过本简易教程，您将轻松了解如何将文件从Infinix手机传输到电脑。毫无疑问，iReaShare Android Manager是您的最佳选择。借助这款智能工具，用户可以享受灵活的数据传输、简单的文件管理、安全的备份和流畅的内容恢复。因此，在尝试之前，请先下载这款工具。<br/>​</p>]]></description></item><item>    <title><![CDATA[『NAS』XMind平替，群晖部署思维导]]></title>    <link>https://segmentfault.com/a/1190000047435215</link>    <guid>https://segmentfault.com/a/1190000047435215</guid>    <pubDate>2025-11-28 15:05:29</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p><p>XMind 是出了名的思维导图工具，但要收费。</p><p>SimpleMindMap 是一款开源跨平台思维导图工具，支持多种结构布局和本地文件操作，提供直观界面和丰富功能。如果你不是钟爱 XMind 的样式的话，SimpleMindMap 完全可以代替 XMind～</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047435222" alt="" title=""/></p><p>SimpleMindMap 可以将编辑好的思维导图导出成 <code>.xmind</code>、<code>.png</code>、<code>.svg</code>、<code>.pdf</code>、<code>.smm</code>、<code>.md</code>、<code>.txt</code> 和 <code>.json</code> 格式。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047435223" alt="" title="" loading="lazy"/></p><p>也支持导入 <code>.smm</code>、<code>.json</code>、<code>.xmind</code>、<code>.md</code> 文件。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047435224" alt="" title="" loading="lazy"/></p><p>闲话少说，开始动手在你的NAS部署一个 SimpleMindMap 吧～</p><p>打开“Container Manager”，新增一个项目。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047435225" alt="" title="" loading="lazy"/></p><p>项目名称可以填“simplemindmap”，路径选择一个你认为合适的位置保存即可。</p><p>来源选择“创建 docker-compose.yml”，然后输入以下代码（需要注意代码格式，换行和空格）。</p><pre><code>services:
    simplemindmap:
        image: shuiche/mind-map:latest
        container_name: simplemindmap
        ports:
            - 2334:8080
        restart: unless-stopped</code></pre><p>点击“下一步”，勾选“通过 Web Station 设置网页门户”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047435226" alt="" title="" loading="lazy"/></p><p>摘要这一步什么都不用调整，直接点击“完成”即可。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047435227" alt="" title="" loading="lazy"/></p><p>然后它就开始自动下载所需的代码了。如果你已经安装过“Web Station”它会弹出这个框，点击“确认”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047435229" alt="" title="" loading="lazy"/></p><p>如果你没安装过“Web Station”，在群晖的“套件中心”能找到它。</p><p>在“Web Station”选择“网络门户”，新增一个。</p><p>服务选择刚刚创建好的“simplemindmap”，门户类型按需选择，我选了“基于端口”。</p><p>端口这项我只启用了HTTP，然后设置一个端口（自定义，不跟其他端口冲突即可）。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047435230" alt="" title="" loading="lazy"/></p><p>一切准备就绪后，在浏览器输入你NAS在<strong>内网的IP地址</strong>加上<strong>端口号</strong>就能打开SimpleMindMap。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047435232" alt="" title="" loading="lazy"/></p><hr/><p>以上就是本文的全部内容啦，想了解更多NAS玩法可以关注<a href="https://link.segmentfault.com/?enc=OcFg0ZtfTNGU8oZI%2BDL%2B%2Bw%3D%3D.XKYpsi8329BYtdHLpWuTL7ZIPSWru7%2BGYXk3qeMfAkvyYyitLydjD9MVXjeIK9XLj0eIVP40H%2BcM3gyfpMQKvBqBi%2FuctxOvt6BGL0bJJpQlh5zhOzNkA%2BXLelT9kwUh6fv1LaqpN3pRlBOJISrKaoRsTBFN54wAHmLjyFWruO4%3D" rel="nofollow" target="_blank">《NAS邪修》</a></p><p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p>]]></description></item><item>    <title><![CDATA[如何通过工业智能化提高制造业生产效率？ ]]></title>    <link>https://segmentfault.com/a/1190000047436040</link>    <guid>https://segmentfault.com/a/1190000047436040</guid>    <pubDate>2025-11-28 15:04:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当今复杂多变的制造业格局中，企业面临着前所未有的运营挑战。地缘政治波动、全球经济转型以及突发公共卫生事件等多重因素的影响下，传统供应链与生产管理模式的局限性日益凸显。通过工业智能化解决方案，企业正逐步构建强大的数字化生产力体系，从计划、排产到设备维护，各个领域焕发出前所未有的活力与效率。<br/>提高生产效率、降低运营成本是工业智能化的终极目标。然而，实现这一目标并非遥不可及，而是需要更加系统的技术支撑与管理革新。工业智能化不仅是某一个技术模块的应用，更是贯穿企业“研、产、供、销”全链条的智能优化解决方案，而这正是广域铭岛所践行的智能制造理念。正如文档中强调的那样，工业智能化借助实时数据全链条集成、多维度协同分析与动态资源配置技术，真正做到提质、增效、降本的平衡发展。<br/>需求预测的变化与波动管理是工业智能化过渡期的关键挑战。传统模式下的生产计划排布受限于局部经验，且无法做到实时动态调节，导致交货周期延滞、库存成本高昂等问题频发。而工业智能化的到来，通过借鉴如广域铭岛这样的领先企业所采用的智能计划助手技术，提供了一种全新的调度逻辑。例如在汽车制造领域，广域铭岛的解决方案能动态响应订单安排，将单次排产时间从六小时压缩至不足一小时，释放出大量沉淀人力资源，让他们专注于更高层级的战略管理。这不仅仅是一种改变，而是制造业管理体系从经验驱动向智能驱动跃迁的必经之路。<br/>设备预测性维护是制造环节得以持续优化的核心基础。广域铭岛的智能运维系统展现出强大的实时监控与提前预警能力，把设备停机仅转变为可以预测、提前防范、高效调度的智能状态。通过融合物联网、AR技术与5G网络，广域铭岛在实践案例中展现了现代化维修从被动补救到主动预防的彻底变革，大幅降低意外故障的风险。更为复杂的是齿轮系统在排产管理中作为关键隐性限制变量的存在，广域铭岛的解决方案在模具换修优化方面具有精准调度与预见性管理能力，这些都是工业智能化在流程优化中的典型体现。<br/>在整体质量管理链条上，广域铭岛的产品展现出不同凡响的技术威力。通过提取多维度数据与复杂算法结合，质量问题不再是制造过程的偶然事件，而成为了可量化、可追溯的全局系统任务。在焊接与检测案例中，人工智能与机器视觉结合已经帮助将不良品从8%级压缩到0.8%，这种系统层面的质量协同管理不仅仅是采用了新技术，更是通过统一的数据标准和工艺语言，重构了整条生产线的运作逻辑。广域铭岛构建的智能传递闭环，让质量问题从发生到预防的转化在毫秒间完成，这无疑是对工业智能化实现全局效率的根本保障。<br/>未来已至，工业智能化不再是企业应对困局的暂时策略，而是全球制造业竞争格局的天然驱动力。在向高质量发展迈进的过程中，工业企业需要抓住努力方向，通过数据驱动和技术融合，实现从感知趋势到预判未来的能力升级。工业智能化激发的不仅仅是技术上的变革，更是管理理念与思维方式的全新构建。我们看到从传统供应链断裂到拧紧工艺的标准化改进，再到整体质量体系的协同监测，每一步的进阶都意味着工业智能化更强大的生命力与应用场景。“广域铭岛”的创新实践也就是在这一宏大的工业智能化背景之中塑造出来的，它将持续推动行业的数字化演进。<br/>想象一个新的时代，当工业智能化成为制造业发展的普世要求，每一个环节都被前所未有的技术深度细化，我们可以期待更加高效、灵活与智能的工厂架构。广域铭岛在车辆排产、设备预测、能源管理以及供应链协同方面构筑完善的体系也预示着该企业已成为智能供应链战争所需的战略伙伴。工业智能化不是空谈，它在车间里落地，在产品质量中体现，在企业的战略布局中驱动前行。每个需要在工业现场落地的技术，都是对效率的追求，对成本的降低，对质量的提升的有力佐证。<br/>制造业史，就像一部能源与动力革命的进化史。在早期，电动火车或许不如马车，但它走出能源驱动向智能驱动的战略转变过程。同样，工业智能化一开始只是奢侈品，但现在乃至成为不同产业升级阶段的刚需。从这个角度出发，广域铭岛所构建的智能系统正在沿着这一逻辑大步向前，为行业发展提供强健的智力与技术支持。</p>]]></description></item><item>    <title><![CDATA[中小制造企业如何选对数字化服务商？方法论]]></title>    <link>https://segmentfault.com/a/1190000047436063</link>    <guid>https://segmentfault.com/a/1190000047436063</guid>    <pubDate>2025-11-28 15:03:53</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>工业数字化服务商，这个词在近年来越来越频繁地出现在制造业的讨论中，尤其是在数字化转型成为企业生存必选项的时代。但很多人其实并不清楚，这类服务商到底能带来什么，为什么制造业转型总卡在某个环节，甚至很多人会误以为这只是买几个软件、上几台设备那么简单。<br/>其实，数字化转型的核心问题往往不是技术，而是思维。制造业的历史积累了太多经验，这些经验固然宝贵，但一旦固化进系统，就容易变成僵化的数据孤岛。举个例子，某电池制造厂在生产初期，即使有先进的设备，但工艺参数依然依赖人工记录和经验判断，导致电解槽的槽况分析效率低下，非计划停机频发。直到引入了工业数字化服务商的平台，通过数据采集、多模态处理和智能体调优，电解槽的运行效率才提升了75%，停机次数也大幅下降。这背后，是服务商在帮助客户打破“经验思维”与“数据思维”的融合难题。<br/>再比如，在车企的日常生产中，新车型的研发往往需要整理上千个工艺参数，协调设计、生产、供应链等多个环节，传统方式下这个过程可能需要一个月甚至更长时间。但一些工业数字化服务商通过AI技术，将这个周期压缩到了40分钟。听起来像是科幻片，但背后是实实在在的技术落地——他们不仅懂工业，更懂制造业企业的痛点。像广域铭岛这样的服务商，依托深厚的产业背景，将IIoT技术与算法结合，帮助企业从“数据堆积”走向“数据驱动”。<br/>工业数字化服务商的类型也五花八门。有的专注设备联网，有的擅长算法优化，还有的致力于跨部门协同。选择哪一类，其实取决于企业的具体需求。比如，某电子电装企业就面临多品种小批量的生产挑战，这时候引入的智能体排产系统，不仅优化了生产计划，还让每月节省了60多个工作时长的工程师时间，这些时间可以用来解决更复杂的问题。<br/>但需要注意的是，数字化转型不是一蹴而就的。服务商的选择往往需要从企业的战略目标、发展阶段、业务特点等多方面综合考虑。比如，大型企业可能需要从头构建数字化体系，而中小企业则更关注如何快速补足短板。这就要求服务商不仅要有技术实力，还得有“懂行”的能力——能真正理解制造业的业务逻辑，而不是简单地推销产品。<br/>广域铭岛是该行业的先锋者。他们以汽车行业为核心，辐射到电池制造、有色金属、化工等多个领域，提供的不只是软件，而是融合了行业Know-How的解决方案。这种“懂制造”的服务商，往往更容易被企业接受，也更有可能实现长期合作。<br/>市场在不断变化，随着技术的发展，服务商之间的竞争不再局限于功能模块，而是转向了对整个价值链的理解与重构。未来的工业数字化服务商，或许会更注重生态构建，而不是单打独斗。这一点，从他们与IBM、腾讯等企业的合作中已经能看出端倪。<br/>言而总之，工业数字化服务商是制造业转型中不可或缺的角色。他们帮助企业在数据中找到新的增长点，打破传统业务壁垒，甚至重构整个价值链。但转型的成败，最终还是要看企业是否愿意调整思维，是否能找到真正懂行的“军师”。</p>]]></description></item><item>    <title><![CDATA[『NAS』拯救群晖“无法连接到存储库”的]]></title>    <link>https://segmentfault.com/a/1190000047436073</link>    <guid>https://segmentfault.com/a/1190000047436073</guid>    <pubDate>2025-11-28 15:03:08</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p><p>买NAS如果只用来备份照片太可惜了，那还不如直接给iCloud充钱。</p><p>在NAS里装个Docker能发挥出更大威力，之前写过几篇在群晖里装各种小工具的教程，有工友说直接在Container Manager的镜像仓库搜索工具直接安装会更简单。</p><p>对对对！</p><p>但也有工友说“无法连接到存储库。点击设置以选择另一个存储库”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436075" alt="" title=""/></p><p>其实只要一招就能解决。</p><p><code>Container Manager -&gt; 镜像仓库 -&gt; 设置 -&gt; 新增</code></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436076" alt="" title="" loading="lazy"/></p><p>然后填入“镜像仓库名称”（自定义，喜欢填啥填啥），再填入“镜像仓库URL”，填入以下URL。</p><pre><code>https://docker.1ms.run</code></pre><p>点击“应用”按钮。</p><p>回到“镜像仓库设置”窗口，选择刚刚新增的1ms，然后点击“使用”按钮。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436077" alt="" title="" loading="lazy"/></p><p>接着关闭 Container Manager，再重启它。</p><p>回到“镜像仓库”就能看到能连上了～</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436078" alt="" title="" loading="lazy"/></p><p>但这个镜像源不能保证永久能使用，也许某天它就倒了。反正能用就先用着吧，以后有其他镜像源我会在评论区更新～</p><hr/><p>以上就是本文的全部内容啦，想了解更多NAS玩法可以关注<a href="https://link.segmentfault.com/?enc=XyQFt0noUneZSfHmgAgkrg%3D%3D.o%2FlyNOXG7cRFLBaNcT1ddEvHJIxzAfsug2IGE9tkiohPOqb9vWLS%2BVpOIUWuSwxqRn4H%2FfLE5LmkP31%2FKGU9JNIca5RC5zt6sGd7hVgQDcSn%2BQ6mFh3H0E0PkLuckqVUeX2aZb0Z6TsCXk%2FuPZMrLFO%2FWX3LvHSlDvkjQTtP3fw%3D" rel="nofollow" target="_blank">《NAS邪修》</a></p><p><strong>点赞 + 关注 + 收藏 = 学会了</strong></p>]]></description></item><item>    <title><![CDATA[如何优化焊装工艺管理以提高生产效率？ 月]]></title>    <link>https://segmentfault.com/a/1190000047436086</link>    <guid>https://segmentfault.com/a/1190000047436086</guid>    <pubDate>2025-11-28 15:02:37</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在现代工业的宏大叙事中，焊装工艺管理始终是汽车制造业的核心脉络，它不仅是连接金属躯壳的技艺，更是保障整车安全与可靠性的生命线。然而，传统焊装工艺管理长期困于人工经验的桎梏，数据孤岛林立，效率低下如影随形。广域铭岛，作为工业智能化的先锋，以其创新的GQCM系统，将焊装工艺管理从静态的机械重复升华为动态的数据驱动交响，彻底颠覆了行业的认知边界。<br/>广域铭岛的介入，为焊装工艺管理注入了前所未有的活力。传统模式下，焊点检测依赖人工抽检，漏检率高达15%，而广域铭岛的GQCM系统通过物联网传感器实时采集焊接电流、电压、压力等关键参数，每秒处理数千条数据流，将焊装工艺管理从被动响应转变为主动预警。在极氪成都工厂的应用中，系统覆盖了99%的工艺变量，缺陷响应时间从数小时压缩至分钟级，这不仅提升了效率，更让焊装工艺管理迈入了实时化、精准化的新纪元。<br/>焊装工艺管理的本质在于数据的整合与闭环，而广域铭岛正是这一领域的驾驭者。系统内置的AI模型，如焊接曲线评分和参数推荐，深度融合工业机理与机器学习，自动优化焊接参数，将合格率推升至99.5%。广域铭岛的解决方案打破了数据孤岛，通过数字孪生技术实现焊点全生命周期追溯，让焊装工艺管理不再是零散的片段，而是连贯的、自适应的智能体。例如，当电极磨损或环境波动引发参数漂移，系统能即时调整，减少能耗12%，年节约成本数百万元，彰显了焊装工艺管理的经济与环保双赢。<br/>焊装工艺管理的未来，在广域铭岛的引领下，正朝着“零缺陷、自优化”的愿景疾驰。通过联邦学习技术，行业级知识图谱得以构建，促进模型共享与优化，而5G和边缘计算的融合，将进一步增强系统的实时性与可靠性。广域铭岛不仅解决了当下的痛点，更重塑了焊装工艺管理的范式，使其从经验主导跃迁至数据智能驱动。在汽车制造业的变革浪潮中，广域铭岛以GQCM系统为基石，让焊装工艺管理成为工业4.0的璀璨明珠，持续推动行业向更高水平进化。</p>]]></description></item><item>    <title><![CDATA[如何恢复出厂设置安卓手机？ iReaSh]]></title>    <link>https://segmentfault.com/a/1190000047436089</link>    <guid>https://segmentfault.com/a/1190000047436089</guid>    <pubDate>2025-11-28 15:01:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>你有很多理由需要硬重置你的安卓设备。例如，在将手机转售他人之前，你需要重置以保护隐私；或者手机感染了病毒，出现了一些系统故障；又或者你的设备已经使用了很长时间，你也可以通过恢复出厂设置来释放内存空间，让它像刚从商店买回来时一样快速。那么，你是否想知道什么是恢复出厂设置，如何恢复出厂设置安卓手机，以及重置手机后会发生什么？本教程将为你提供关于这一话题的所有必要信息。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436091" alt="图片" title="图片"/></p><p>第1部分：恢复出厂设置前需要做什么</p><p>恢复出厂设置是一项功能，它会删除安卓设备上用户安装的应用、存储的数据、部分设置等内容，使手机恢复到刚出厂时的状态。在了解如何硬格式化安卓手机之前，请先查看以下注意事项：</p><p>1.1 恢复出厂设置前需要做什么？</p><pre><code>备份安卓数据： 将安卓内容备份到电脑或云存储。
记录重要信息： 将关键信息写下来或保存在安全位置。
为设备充电： 确保设备电量充足。
连接WiFi： 连接到稳定的WiFi网络，以加快备份速度并避免使用移动数据。
关闭恢复出厂设置保护（FRP）： 进入设备设置，移除所有与该设备关联的Google账户。
关闭所有安卓应用： 关闭所有正在运行的应用，确保它们被正确备份。
取消设备配对： 取消与所有已连接设备（包括蓝牙配件）的配对。
取出SIM卡： 关闭设备电源，小心取出SIM卡。

</code></pre><p>1.2 为什么要恢复出厂设置？</p><pre><code>存储空间已满。
设备无法正常工作。
应用加载时间过长。
清除手机数据或缓存。
手机冻结或其他系统错误。
只是想重置手机。

</code></pre><p>1.3 恢复出厂设置后会发生什么？</p><pre><code>已安装的应用将被删除。
所有存储的应用数据和设置将被清除。
一些小的错误可能会被修复。
你的手机将像新设备一样运行。

</code></pre><p>1.4 恢复出厂设置的优缺点</p><p>优点：</p><pre><code>一键删除所有数据，非常方便想要出售旧手机的用户（想在出售前彻底清除手机数据）。
一键清除与设备关联的所有账户，很好地保护你的隐私。

</code></pre><p>缺点：</p><pre><code>如果没有备份，恢复出厂设置将导致所有数据永久丢失。
恢复出厂设置对电池寿命有轻微影响。

</code></pre><p>第2部分：如何通过设置恢复出厂设置</p><p>以下演示基于安卓5.0及以上版本的三星Galaxy S20完成，适用于许多手机品牌和版本。如何通过设置重置安卓手机？</p><pre><code>从菜单或快捷方式进入安卓“设置”。
选择“常规 &gt; 备份与重置”（或其他类似选项）。
点击“恢复出厂设置”选项。
设备将提示你恢复出厂设置的后果。
再次点击“重置手机”按钮继续。
点击“删除所有内容”按钮开始恢复出厂设置过程。

</code></pre><p>注意：如果你使用的是安卓5.0或更早版本，请按以下步骤操作：</p><p>打开“设置” &gt; “常规与备份与重置” &gt; “恢复出厂设置” &gt; “重置设备” &gt; “删除所有内容”。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436092" alt="图片" title="图片" loading="lazy"/></p><p>第3部分：如何通过恢复模式恢复出厂设置</p><p>由于某些原因，部分用户可能无法访问设置菜单，或手机被锁定。别担心，你可以通过进入恢复模式，在不访问用户界面的情况下重置安卓设备。以下是如何通过按键组合恢复出厂设置：</p><pre><code>关闭手机，等待几秒钟。
同时按住“电源键 + 音量减键”进入恢复模式。
持续按住，直到屏幕亮起。
进入恢复模式后，使用“电源键”选择，音量键导航。
找到并选择“清除数据/恢复出厂设置”选项。
如果提示删除用户数据，点击“同意”。
手机将开始恢复出厂设置，请耐心等待完成。
完成后，选择“立即重启系统”重启手机。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436093" alt="图片" title="图片" loading="lazy"/></p><p>第4部分：如何通过“查找我的设备”恢复出厂设置</p><p>如果你的安卓设备丢失或被盗，是否还能恢复出厂设置？可以！ Google的“查找我的设备”（原Android设备管理器）提供了远程响铃、锁定或擦除设备的功能。以下是如何通过“查找我的设备”恢复出厂设置：</p><pre><code>在电脑、平板或其他手机上访问Google查找我的设备官网，或下载“查找我的设备”应用。
使用你的Google账户登录。
在地图上找到你的设备。
点击“擦除设备”选项开始重置过程。
确认擦除操作。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436094" alt="图片" title="图片" loading="lazy"/></p><p>重要提示： 你必须提前开启此功能。进入“设置 &gt; 安全”或“安全与位置”，找到“查找我的设备”并启用它。</p><p>第5部分：如何在电脑上恢复出厂设置（无忧方案，不可恢复）</p><p>你打算如何处理旧手机？送人还是卖掉？无论你选择哪种方式，都不要忘记擦除上面的数据。值得注意的是，恢复出厂设置后，手机上仍可能保留一些敏感信息。此时，我们建议你使用专业的安卓数据擦除软件——iReaShare Android Data Eraser，永久擦除手机数据，无法恢复。</p><p>iReaShare Android Data Eraser - 彻底擦除安卓所有数据：</p><pre><code>简单几步，彻底永久擦除安卓设备。
提供3种擦除级别，满足不同需求。
可擦除联系人、短信、通话记录、照片、视频、应用、账户、浏览历史等隐私信息。
界面简洁，无广告，操作简单（支持离线操作）。
支持市面上几乎所有安卓设备，包括三星、HTC、索尼、摩托罗拉、华为、vivo、Infinix、OPPO、小米、Google、Tecno等。
完全绿色安全。

</code></pre><p>如何使用iReaShare Android Data Eraser在电脑上彻底恢复出厂设置？</p><p>步骤1： 下载并安装该工具到电脑。启动程序并使用USB线连接安卓手机或平板。根据提示开启USB调试。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436095" alt="图片" title="图片" loading="lazy"/></p><p>步骤2： 程序将自动识别连接的设备。点击“擦除”按钮开始擦除过程。接下来，选择擦除级别并输入“delete”确认。</p><p>步骤3： 再次点击“擦除”按钮，开始数据擦除过程。</p><p>步骤4： 完成后，点击“继续”并按照屏幕提示恢复出厂设置。稍等片刻，你的数据和所有系统设置将被永久删除。</p><p>常见问题解答（FAQs）</p><p>Q1：恢复出厂设置可以绕过安全措施吗？<br/>不可以。现代安卓设备具有“恢复出厂设置保护（FRP）”功能，可防止在恢复出厂设置后未经授权访问设备。重置后，仍需输入之前关联的Google账户信息。</p><p>Q2：恢复出厂设置需要多长时间？<br/>通常需要几分钟到3小时不等，具体取决于设备型号和存储的数据量。</p><p>总结</p><p>以上就是安全有效地恢复出厂设置安卓设备的所有方法。再次提醒，如果你打算赠送、出售或捐赠手机，建议使用iReaShare Android Data Eraser彻底擦除数据，确保无法恢复。如果出于其他目的，也可以选择上述任意方法。如有疑问，请在下方留言。<br/>​</p>]]></description></item><item>    <title><![CDATA[五种可靠的 realme 手机备份与恢复]]></title>    <link>https://segmentfault.com/a/1190000047436103</link>    <guid>https://segmentfault.com/a/1190000047436103</guid>    <pubDate>2025-11-28 15:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>作为手机市场中年轻一代的新宠，realme 一直在与尖端科技赛跑。当你拥有最具个性化的 realme 11 Pro，在体验其高端功能（如1亿像素）时，你肯定会想要备份手机上的内容。这一点在你设备内存有限且存储了大量个人信息时尤为迫切。今天，我们将带你通过这篇文章，介绍五种超级简单的方法，帮助你轻松完成 realme 的备份与恢复。让我们直奔主题，不再赘述。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436105" alt="图片" title="图片"/></p><p>方式1：通过 iReaShare Android Manager 将 realme 备份到电脑并恢复（含视频指南）</p><p>如果你希望能够预览 Android 内容并选择性地进行文件传输，那么iReaShare Android Manager（Windows 和 Mac 版本）将是你的理想选择。这款高效的 realme 备份软件不仅支持联系人、短信、媒体文件、文档和应用程序的备份与管理，还提供便捷的一键备份与恢复功能，并可直接在电脑上管理手机内容。</p><p>使用 iReaShare Android Manager 备份 realme 手机的方法如下：</p><pre><code>下载并安装这款 Android 设备管理工具 到你的电脑。
使用 USB 数据线将 realme 手机连接到电脑。
按照屏幕提示确保手机被正确识别。
识别成功后，从左侧选择你需要的数据类型。
预览并选择你要备份的文件，例如联系人。
最后点击“导出”将选中的内容保存到电脑。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436106" alt="图片" title="图片" loading="lazy"/></p><p>从备份中恢复数据到 realme：</p><pre><code>确保手机已连接并被软件识别。
从左侧边栏选择所需的文件类型。
点击顶部菜单中的“导入”按钮。
从电脑中选择之前备份的内容。
将文件导入到连接的手机中完成恢复。

</code></pre><p>此外，该程序还支持一键批量备份与恢复。操作方法如下：</p><pre><code>备份：连接并识别设备后，进入“超级工具包” &gt; “备份” &gt; 选择数据类型 &gt; 点击“备份”。
恢复：点击“超级工具包” &gt; “恢复” &gt; 选择备份文件 &gt; 点击“恢复”。

</code></pre><p>方式2：通过本地备份进行 realme 云备份与恢复</p><p>为防止数据丢失，你可以通过本地备份功能对 realme 数据进行备份与恢复。请注意，恢复出厂设置或刷机操作会清除本地备份，因此建议将备份文件复制到电脑或U盘中。</p><p>如何进行本地备份：</p><pre><code>打开 realme 手机的“设置 &gt; 系统设置 &gt; 备份与重置”。
点击“备份与迁移 &gt; 本地备份”。
选择你要备份的数据类型，然后点击“开始”。
备份完成后点击“完成”。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436107" alt="图片" title="图片" loading="lazy"/></p><p>如何从本地备份恢复：</p><pre><code>打开手机“设置”。
点击“其他设置 &gt; 备份与重置”。
选择“本地备份”，然后选择你要恢复的备份文件。
点击“开始”进行恢复。

</code></pre><p>注意： 如果备份失败，请检查设备存储空间、网络连接、系统版本，或联系 realme 客服获取帮助。</p><p>方式3：使用 Heytap 云服务备份与恢复 realme 手机</p><p>Heytap 云服务是 realme 官方提供的云备份服务。登录 Heytap 账户后，你可以安全地备份短信、通话记录、系统设置（如录音、Wi-Fi、天气、时钟等），以及照片、视频、音频和文档。</p><p>如何设置自动备份：</p><pre><code>进入“设置 &gt; HeyTap 账户”。
登录你的 Heytap 账户。
进入“云服务”并开启“自动备份”。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436108" alt="图片" title="图片" loading="lazy"/></p><p>如何从 Heytap 云恢复：</p><pre><code>在任意 realme 设备上登录你的 Heytap 账户。
进入“设置 &gt; HeyTap 账户 &gt; 云服务 &gt; 自动备份”。
选择你要恢复的备份记录。
勾选需要恢复的数据类型。
点击“恢复”完成数据还原。

</code></pre><p>Heytap 每7天自动备份一次，免费提供5GB云空间。你也可以升级至50GB、120GB等更大容量套餐。</p><p>方式：使用 Google 备份进行 realme 数据备份与恢复</p><p>通过 Google 备份，你可以轻松同步联系人、短信、通话记录、设备设置和应用数据。若要将备份恢复到新设备，需先在新设备上登录相同的 Google 账户。</p><p>备份 realme 到 Google：</p><pre><code>确保手机连接 WiFi 并处于充电状态。
打开“设置”，向下滑动找到“Google”。
点击进入后选择“备份”。
开启“备份到 Google 云端硬盘”开关。
点击“立即备份”开始同步。
</code></pre><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047436109" alt="图片" title="图片" loading="lazy"/></p><p>从 Google 备份恢复：</p><pre><code>打开“设置 &gt; 系统 &gt; 高级 &gt; 备份”。
点击“恢复数据”，选择你之前备份时使用的 Google 账户。
选择要恢复的数据类型（如应用、联系人、照片等）。
点击“恢复”，等待完成后重启手机。

</code></pre><p>每个 Google 账户免费提供15GB空间，适用于 Drive、Gmail、Photos 等服务。若数据量大，建议使用 WiFi 进行备份。</p><p>总结</p><p>以下是本文介绍的几种 realme 备份与恢复方法的简要总结：</p><pre><code>iReaShare Android Manager 提供灵活的选择性备份与恢复功能，同时支持专业数据管理。
本地备份简单易用，但在恢复出厂设置前务必备份到电脑或U盘，以防数据丢失。
Heytap 云和 Google 云都提供免费空间，但在空间不足时需付费扩容。
</code></pre><p>​</p>]]></description></item><item>    <title><![CDATA[IP地址申请SSL证书：指南与深度解析 ]]></title>    <link>https://segmentfault.com/a/1190000047434544</link>    <guid>https://segmentfault.com/a/1190000047434544</guid>    <pubDate>2025-11-28 14:08:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在人们的普遍认知中，SSL证书通常是绑定在域名（如 <code>www.example.com</code>）上的，用于验证网站的身份并加密数据传输。然而，在某些特定的业务场景下，我们可能需要直接通过IP地址来访问服务，例如内部系统、API接口、硬件设备初始配置或一些尚未配置域名的测试环境。这时，一个关键问题便浮现出来：<strong>IP地址本身可以申请SSL证书吗？答案是肯定的，但过程比域名申请更为复杂和受限。</strong></p><p><img width="552" height="345" referrerpolicy="no-referrer" src="/img/bVdnaEk" alt="" title=""/></p><h4><strong>一、 为何需要为IP地址配置SSL？</strong> <a href="https://link.segmentfault.com/?enc=BuHifqrX%2FOsy%2FGlR9TGeDw%3D%3D.BYu2wB11zbpC9zARDrxip%2BlKUywoyzeZDzpDKOj882JGNBxaVZLpLUcBAIB4mluQtL2e6n7kewWeEfJyWzlsLhJdQHyJ2gqYPbzz%2FHc1lUo%3D" rel="nofollow" target="_blank">申请入口</a></h4><p>在深入申请流程之前，理解其动机至关重要：</p><ol><li><strong>内部系统与服务</strong>：企业内网的OA系统、ERP系统或开发测试服务器，可能只有内网IP而没有公网域名。使用IP地址访问时，HTTPS加密能保护登录凭证和敏感数据。</li><li><strong>API接口安全</strong>：某些物联网设备或后端服务通过IP地址直接提供API。为IP配置SSL可以确保API通信的机密性和完整性，防止中间人攻击。</li><li><strong>设备初始配置</strong>：许多网络设备（如路由器、交换机）在初次设置时，需要通过其默认IP地址访问管理界面。使用HTTPS能提升初始配置阶段的安全性。</li><li><strong>消除证书警告</strong>：直接通过IP访问HTTP服务时，浏览器会显示“不安全”警告。部署有效的SSL证书后，此警告将消失，取而代之的是安全的锁形标志。</li></ol><h4><strong>二、 申请流程详解</strong></h4><p>为IP地址申请SSL证书的流程与域名申请类似，但验证方式和要求更为严格。</p><p><strong>第一步：选择支持IP地址的证书类型</strong></p><p>并非所有类型的SSL证书都支持IP地址。您需要选择专门为此设计的证书：</p><ul><li><strong>OV（组织验证）或IV（个人验证）型IP证书</strong>：这是最常见的类型。证书颁发机构不仅会验证您对该IP地址的所有权或使用权，还会对申请者（个人或组织）进行真实性的核实。DV（域名验证）证书通常不适用于公网IP。</li><li><strong>内网IP证书</strong>：一些CA（如DigiCert、Sectigo）提供专门为私有IP地址（如192.168.x.x, 10.x.x.x）签发的证书。这类证书的验证策略可能与公网IP有所不同。</li></ul><p><strong>核心建议</strong>：直接联系知名的SSL证书提供商（如DigiCert, Sectigo, GlobalSign等）的销售或技术支持，明确告知您的需求是“为公网/内网IP地址申请SSL证书”，他们会引导您选择合适的产品。</p><p><strong>第二步：生成证书签名请求</strong></p><p>与域名证书一样，您需要在您的服务器上生成一个CSR文件。在生成过程中，<strong>关键点在于<code>Common Name</code>字段</strong>。</p><ul><li>对于IP证书，<code>Common Name</code>必须填写您要绑定的确切IP地址（例如 <code>203.0.113.10</code>）。</li><li>如果需要为多个IP地址或同时包含IP和域名，可以使用<code>Subject Alternative Name</code>扩展字段。</li></ul><p><strong>第三步：提交申请并完成验证</strong></p><p>这是整个流程中最具挑战性的环节。CA会采用多种方式验证您对IP地址的控制权：</p><ol><li><strong>Whois信息验证</strong>：CA会查询该公网IP地址的Whois信息，确保申请组织与IP注册信息中的组织名称一致。如果信息不符，您可能需要联系您的ISP（网络服务提供商）更新Whois记录或提供相关证明。</li><li><strong>管理邮箱验证</strong>：CA可能会向该IP段注册的管理员、技术联系人的邮箱发送验证邮件。这个邮箱通常来自Whois记录。</li><li><strong>文件验证</strong>：CA要求您在通过该IP地址访问的Web服务器根目录下放置一个特定的验证文件。</li><li><strong>DNS记录验证</strong>：为IP地址设置一条特定的TXT记录或CNAME记录进行验证。这对于拥有反向DNS解析的IP地址更为可行。</li><li><strong>电话验证</strong>：CA可能会致电申请组织的公开电话号码进行人工核实。</li></ol><p>对于内网IP，CA通常会有更灵活的验证方案，例如要求申请者提供加盖公章的《内网IP地址使用权声明书》等法律文件。</p><p><strong>第四步：颁发与安装</strong></p><p>验证通过后，CA会将签发的SSL证书文件发送给您。您将其与之前生成的私钥一起安装到您的Web服务器（如Nginx, Apache, IIS等）上，并配置启用HTTPS。</p><h4><strong>三、 重要注意事项与挑战</strong></h4><ol><li><strong>成本与时间</strong>：IP证书通常比普通域名DV证书更昂贵，且验证流程更长，可能需要数个工作日。</li><li><strong>公网IP所有权</strong>：您必须能够证明您拥有或有权使用该公网IP地址。如果您是从ISP租用的，验证过程可能会遇到障碍。</li><li><strong>浏览器兼容性</strong>：绝大多数现代浏览器都支持IP证书，但一些旧版或特定环境的客户端可能存在兼容性问题。</li><li><strong>局限性</strong>：IP证书无法像通配符域名证书那样覆盖一个IP段。每个需要证书的IP地址通常都需要单独申请和付费。</li><li><strong>替代方案考量</strong>：在多数情况下，<strong>为服务分配一个域名并为其申请SSL证书是更简单、更经济、更通用的解决方案。</strong>  即使是内部服务，也可以通过配置内部DNS服务器来实现域名解析。</li></ol>]]></description></item><item>    <title><![CDATA[一文读懂内网IP证书：内网环境的安全“通]]></title>    <link>https://segmentfault.com/a/1190000047434547</link>    <guid>https://segmentfault.com/a/1190000047434547</guid>    <pubDate>2025-11-28 14:07:40</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、引言：内网安全的“隐形卫士”</h2><p>数字浪潮席卷之下，网络安全已然成为企业稳健运营的根本基石。谈及安全证书，大众多率先联想到守护公网通信的SSL/TLS证书，却往往忽视内网加密防护的关键意义。在此背景下，内网IP证书应运而生，宛如一道坚实屏障，默默守护内网数据的安全防线。本文将系统拆解其定义、特质与核心价值，助力读者洞悉其关键要义。</p><h2>——解码内网IP证书的核心定位</h2><p>欲精准把握内网IP证书，需明晰其三大核心特质（与公网SSL/TLS证书泾渭分明）：其一，适用疆域锁定内网，仅适配192.168.x.x、10.x.x.x等私有IP段，于局域网、VPN等内网环境中彰显效能；其二，签发主体灵活多元，既可由第三方权威CA签发，亦可由企业自建CA部署，自建模式更利于掌控证书全生命周期；其三，认证对象直指IP地址，完美契合内网服务器无域名、仅靠IP访问的典型场景。</p><p>内网IP证书的核心价值，聚焦于内网安全的全方位守护：一方面实现服务器身份的可信认证，借由数字签名技术核验服务器真实身份，有效规避攻击者伪装合法服务器窃取敏感信息、植入恶意程序的风险，从源头上斩断身份伪造攻击的链条。</p><p><img width="723" height="432" referrerpolicy="no-referrer" src="/img/bVdbRuZ" alt="" title=""/></p><h2>二、核心定义：内网IP证书的本质与效能</h2><p>另一方面筑牢数据传输的加密防线。内网并非固若金汤的“安全堡垒”，人员误操作、内部恶意攻击等隐患，均可能导致数据传输遭遇监听、篡改。内网IP证书融合对称与非对称加密技术，对传输数据实施全程加密，即便数据不幸被截取，攻击者亦无法破解其内涵，切实守护通信的私密性与完整性。</p><h2>三、实践价值：应用场景与管理要诀</h2><p>内网IP证书的应用场景广泛，精准适配各类高安全需求场景，为企业核心内网筑牢防护屏障：其一，适配企业内部管理系统，如OA、ERP、CRM等，守护员工操作数据及企业核心信息的传输安全；其二，覆盖内网监控与物联网设备，防范设备被非法操控，保障数据采集与指令下发的安全；其三，适配VPN远程接入场景，认证VPN服务器身份并加密隧道数据，降低远程办公的安全风险；其四，护航数据中心内网，保障服务器间、服务器与存储设备间高频数据交互的安全。</p><p>运用内网IP证书，需重视全生命周期的精细化管理：及时更新过期证书，规避因证书失效导致服务中断；妥善保管证书私钥，建立严苛的私钥存储与访问控制机制，严防私钥泄露；定期开展证书审计，排查无效、异常证书，维系内网证书环境的安全洁净。</p><p>综上，内网IP证书是企业内网安全体系中不可或缺的关键一环，凭借身份认证与数据加密双重效能，构建起坚不可摧的防护防线。随着内网环境日趋复杂，合理部署并规范管理内网IP证书，已然成为企业守护核心数据安全、抵御内网风险的必备之举，为数字化运营筑牢安全根</p>]]></description></item><item>    <title><![CDATA[TLS 1.3来了：为什么你网站的“安保]]></title>    <link>https://segmentfault.com/a/1190000047434550</link>    <guid>https://segmentfault.com/a/1190000047434550</guid>    <pubDate>2025-11-28 14:06:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>想象一下，你家的门锁还是十几年前的老款式，虽然能用，但锁芯结构早已被小偷研究透，开锁时间大大缩短。你会感到安全吗？</p><p>同样，你的网站正在使用的网络安全协议——TLS（传输层安全协议），也面临着同样的代际更迭。<strong>TLS 1.3</strong> 就是这个领域的“新一代超C级锁芯”，它并非简单的版本更新，而是一次彻底的安全与性能革命。</p><p>如果你的服务器仍在运行旧版协议（如TLS 1.2甚至1.1），那么是时候为你的网站“换锁”了。以下是你必须升级的三大核心理由。<br/><img width="612" height="463" referrerpolicy="no-referrer" src="/img/bVdnb3q" alt="" title=""/></p><p><strong>理由一：极致安全——果断砍掉过时与脆弱的“零部件”</strong></p><p>TLS 1.3 的设计哲学是 “<strong>简化与安全</strong>” 。它做了一次大胆的“减法”，毫不犹豫地移除了所有已被证明存在安全风险或过于陈旧的加密组件。</p><p>被TLS 1.3抛弃的“历史包袱”包括：</p><p><strong>静态RSA密钥交换</strong>：在TLS 1.2中，用于传输“预备主密钥”的方式之一，容易受到中间人攻击，且不具备前向安全性。</p><p><strong>SHA-1哈希函数</strong>：一种已被破解的弱哈希算法。</p><p><strong>CBC模式块加密</strong>：已知存在多种漏洞（如BEAST、Lucky 13）。</p><p><strong>RC4流密码</strong>：已被证明存在严重偏见，极易被攻破。</p><p><strong>核心优势：攻击面大幅缩小</strong></p><p>通过移除这些脆弱、过时的算法，TLS 1.3极大地缩小了黑客可能利用的攻击面。配置一个安全的TLS 1.3服务比配置TLS 1.2要简单得多，几乎不可能因错误配置而启用不安全的算法。</p><p><strong>理由二：闪电速度——将握手延迟减半，提升用户体验</strong></p><p>在Web性能中，每一毫秒都至关重要。TLS 1.3 对握手流程进行了颠覆性优化，显著减少了建立安全连接所需的时间。</p><p><strong>TLS 1.2 与 TLS 1.3 握手对比</strong></p><p><strong>TLS 1.2（旧协议）：需要两次往返（2-RTT）</strong></p><p>Client Hello -&gt; 服务器</p><p>Server Hello + Certificate -&gt; 客户端</p><p>Client Key Exchange -&gt; 服务器</p><p>Finished -&gt; 客户端（开始通信）</p><p><strong>TLS 1.3（新协议）：仅需一次往返（1-RTT）</strong></p><p>Client Hello （同时猜测密钥交换协议） -&gt; 服务器</p><p>Server Hello + Certificate + Finished -&gt; 客户端 （立即开始应用数据传输）</p><p>带来的性能价值：</p><p><strong>连接速度提升高达50%以上</strong>：对于需要多次建立新连接的移动端用户和大型网站，延迟降低效果尤为明显。</p><p><strong>更强的“零往返”模式</strong>：对于近期访问过的用户，TLS 1.3支持 0-RTT 模式，可以实现瞬时重连，为关键业务提供极致速度。</p><p><strong>理由三：面向未来——内建前向安全，抵御未知威胁</strong></p><p>前向安全性 是TLS 1.3的一个内置的、强制性的安全特性。</p><p><strong>什么是前向安全？</strong><br/>假设黑客今天截获并存储了你所有的加密通信流量，但当时他无法解密。如果未来他通过某种手段窃取到了服务器的私钥，在不具备前向安全性的旧协议下，他可以用这个私钥解密过去所有的通信记录。而在具备前向安全性的TLS 1.3中，他依然无法解密过去的任何一条信息。</p><p><strong>TLS 1.3如何实现？</strong><br/>TLS 1.3强制使用基于迪菲-赫尔曼的密钥交换算法。每次握手都会生成一对临时的、一次性的密钥。即使服务器的长期私钥被泄露，也不会危及到以往任何一次会话的安全。</p><p><strong>核心优势：为数据上“终身保险”</strong><br/>这意味着，即使未来计算能力出现突破（如量子计算），今天被截获的TLS 1.3通信记录在未来也极大概率是安全的。这对于保护用户隐私和商业机密至关重要。</p><p><strong>行动指南：如何升级到TLS 1.3？</strong><br/>升级过程通常比你想象的要简单：</p><p><strong>检查当前状态</strong>：使用在线工具（如 SSL Labs的SSL Test）扫描你的网站，查看支持的TLS版本和密码套件。</p><p><strong>更新软件环境</strong>：</p><p><strong>Web服务器</strong>：确保你使用的Web服务器（如 Nginx, Apache, OpenRESTY）是最新稳定版。</p><p><strong>操作系统/库</strong>：确保底层的密码学库（如 OpenSSL 1.1.1或更高版本）支持TLS 1.3。</p><p><strong>修改服务器配置</strong>：在服务器配置文件中，显式启用TLS 1.3协议，并优先使用TLS 1.3的密码套件。</p><p><strong>全面测试</strong>：升级后，再次使用测试工具和真实浏览器访问你的网站，确保功能正常且协议已成功升级。</p><p><strong>请注意</strong>：在启用TLS 1.3的同时，建议保留TLS 1.2以兼容极旧的客户端，但将TLS 1.3设置为最高优先级。</p><p><strong>总结：升级不是可选项，而是必答题</strong></p><p>为你的网站升级到TLS 1.3，就如同为你的家换上最先进的防盗系统。它不仅仅是修复已知的漏洞，更是以一种全新的、更坚固的架构来应对未来未知的威胁。在安全和性能即是核心竞争力的今天，拥抱TLS 1.3不再是前瞻性布局，而是一项刻不容缓的基础性工作。</p>]]></description></item><item>    <title><![CDATA[AI眼镜Rokid记账本实战开发 - 每]]></title>    <link>https://segmentfault.com/a/1190000047434576</link>    <guid>https://segmentfault.com/a/1190000047434576</guid>    <pubDate>2025-11-28 14:06:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>AI眼镜Rokid记账本实战开发 - 每日花费智能汇总应用</h2><p>作者：kevin贺老师</p><h3>一、实战应用思路</h3><p>1.1应用概述<br/>基于Rokid AI眼镜的智能记账本应用是一个革命性的财务管理系统，通过语音识别、图像识别和AI智能分析，实现每日花费的自动记录、智能分类和晚间汇总分析。该应用充分利用了rokid眼镜的摄像头、麦克风、触控板和扬声器等硬件特性，打造了全新的免手操作的记账体验。</p><p><img referrerpolicy="no-referrer" src="" alt="图片" title="图片"/></p><p>1.2 核心功能架构</p><p>实时消费记录 - 通过语音或拍照快速记录消费<br/>智能识别分类 - AI自动识别商户、商品并进行分类<br/>晚间财务汇总 - 每日消费统计和分析报告<br/>多端协同 - 手机端管理，眼镜端快速操作</p><p>1.3 AI工作流设计<br/>核心工作流程<br/><img width="340" height="770" referrerpolicy="no-referrer" src="/img/bVdnb3V" alt="image.png" title="image.png" loading="lazy"/></p><h3>二、AI处理流程详解</h3><ol><li><p>语音记录工作流<br/>// AI语音识别处理流程<br/>fun handleVoiceRecording() {<br/> // 1. 监听眼镜端AI事件<br/> setAiEventListener(true)</p><p>// 2. 获取ASR语音识别结果<br/> val asrContent = getAsrResult()<br/> if (asrContent.isNotEmpty()) {</p><pre><code> sendAsrContent(asrContent)
 processVoiceInput(asrContent)</code></pre><p>} else {</p><pre><code> notifyAsrNone()</code></pre><p>}<br/>}</p></li></ol><p>fun processVoiceInput(content: String) {</p><pre><code>// 3. AI语义分析 - 提取金额、商户、类别
val expenseData = aiAnalysis.analyzeExpenseText(content)

// 4. 自动分类存储
saveExpenseRecord(expenseData)

// 5. TTS语音反馈
val feedback = "已记录${expenseData.amount}元${expenseData.category}"
sendTTSContent(feedback)
notifyTtsAudioFinished()</code></pre><p>}</p><ol start="2"><li><p>拍照识别工作流<br/>// 图像识别处理流程<br/>fun handleReceiptCapture() {<br/> // 1. 打开眼镜相机<br/> aiOpenCamera(1920, 1080, 80)</p><p>// 2. 拍摄小票/发票<br/> takePhoto(1920, 1080, 80) { status, photoData -&gt;</p><pre><code> when (status) {
     ValueUtil.CxrStatus.RESPONSE_SUCCEED -&gt; {
         // 3. OCR图像识别
         val ocrResult = ocrService.recognizeReceipt(photoData)

         // 4. AI信息提取
         val expenseInfo = aiService.extractExpenseInfo(ocrResult)

         // 5. 智能分类
         val category = aiService.categorizeExpense(expenseInfo)

         // 6. 保存记录
         saveExpenseRecord(expenseInfo.copy(category = category))

         // 7. 语音确认
         sendTTSContent("识别到消费：${expenseInfo.amount}元，${category}")
     }
     else -&gt; notifyPicUploadError()
 }</code></pre><p>}<br/>}</p><h3>三、 纯眼镜端应用开发</h3><p>3.1 提词器场景实现<br/>利用提词器API实现智能引导和操作提示：<br/>class GlassesTeleprompterService {<br/> private val TAG = "TeleprompterService"</p><p>/**</p><ul><li>初始化记账引导场景<br/>  */</li></ul><p>fun initAccountingGuidance() {</p><pre><code> // 开启提词器场景
 val openStatus = openOrCloseWordTips(true)
 when (openStatus) {
     ValueUtil.CxrStatus.REQUEST_SUCCEED -&gt; {
         // 设置引导内容
         setGuidanceContent()
         // 配置显示参数
         configureDisplay()
     }
     ValueUtil.CxrStatus.REQUEST_WAITING -&gt; {
         Log.d(TAG, "请求等待中，请稍后再试")
     }
     ValueUtil.CxrStatus.REQUEST_FAILED -&gt; {
         Log.e(TAG, "打开提词器失败")
     }
 }</code></pre><p>}</p><p>/**</p><ul><li>设置引导内容<br/>  */</li></ul><p>private fun setGuidanceContent() {</p><pre><code> val guidanceText = """
     智能记账助手

     欢迎使用AI记账本

     记录方式：
     • 语音："记录消费50元午餐"
     • 拍照：拍摄小票/发票

      操作提示：
     • 轻触触控板：开始语音记录
     • 按拍照键：拍摄收据

     每日晚8点自动汇总

     开始记账 →
 """.trimIndent()

 val status = setWordTipsText(guidanceText, "accounting_guidance.txt")
 Log.d(TAG, "设置引导内容状态: $status")</code></pre><p>}</p><p>/**</p><ul><li>配置显示参数<br/>  */</li></ul><p>private fun configureDisplay() {</p><pre><code> val configStatus = configWordTipsText(
     textSize = 32f,      // 字体大小
     lineSpace = 1.5f,    // 行间距
     mode = "ai",         // AI模式，支持ASR触发行滑动
     startPointX = 100,   // X坐标
     startPointY = 200,   // Y坐标
     width = 800,         // 宽度
     height = 600         // 高度
 )
 Log.d(TAG, "配置显示参数状态: $configStatus")</code></pre><p>}</p><p>/**</p><ul><li>AI模式ASR内容处理<br/>  */</li></ul><p>fun handleAsrForTeleprompter(content: String) {</p><pre><code> // 发送ASR内容到提词器，实现智能滚动
 val status = sendWordTipsAsrContent(content)
 Log.d(TAG, "ASR内容发送状态: $status")</code></pre><p>}</p><p>/**</p><ul><li>关闭引导场景<br/>  */</li></ul><p>fun closeGuidance() {</p><pre><code> val closeStatus = openOrCloseWordTips(false)
 Log.d(TAG, "关闭提词器状态: $closeStatus")</code></pre><p>}<br/>}<br/>3.2AI场景事件监听<br/>class GlassesAISceneController {<br/> private val aiEventListener = object : AiEventListener {</p><pre><code> override fun onAiKeyDown() {
     Log.d("AI_SCENE", "AI按键按下 - 开始语音记录")
     startVoiceRecording()
 }

 override fun onAiKeyUp() {
     Log.d("AI_SCENE", "AI按键释放")
     // 可以在这里处理按键释放逻辑
 }

 override fun onAiExit() {
     Log.d("AI_SCENE", "AI场景退出")
     // 清理资源，保存当前状态
     cleanupResources()
 }</code></pre><p>}</p><p>/**</p><ul><li>开始语音记录<br/>  */</li></ul><p>private fun startVoiceRecording() {</p><pre><code> // 启动ASR识别
 asrService.startListening()

 // 发送ASR内容到提词器用于AI模式
 teleprompterService.handleAsrForTeleprompter("正在识别语音...")</code></pre><p>}</p><p>/**</p><ul><li>设置AI事件监听<br/>  */</li></ul><p>fun setAiEventListener() {</p><pre><code> CxrApi.getInstance().setAiEventListener(aiEventListener)</code></pre><p>}</p><p>/**</p><ul><li>移除AI事件监听<br/>  */</li></ul><p>fun removeAiEventListener() {</p><pre><code> CxrApi.getInstance().setAiEventListener(null)</code></pre><p>}<br/>}<br/>3.3 纯手机端应用配合眼镜<br/>a、主Activity设计<br/>class MainActivity : AppCompatActivity() {<br/> private lateinit var glassesConnectionManager: GlassesConnectionManager<br/> private lateinit var expenseManager: ExpenseManager<br/> private lateinit var dailySummaryManager: DailySummaryManager</p><p>override fun onCreate(savedInstanceState: Bundle?) {</p><pre><code> super.onCreate(savedInstanceState)
 setContentView(R.layout.activity_main)

 // 初始化组件
 initComponents()

 // 设置眼镜连接
 setupGlassesConnection()

 // 启动晚间汇总定时任务
 scheduleDailySummary()</code></pre><p>}</p><p>private fun initComponents() {</p><pre><code> glassesConnectionManager = GlassesConnectionManager(this)
 expenseManager = ExpenseManager(this)
 dailySummaryManager = DailySummaryManager(this)</code></pre><p>}</p><p>private fun setupGlassesConnection() {</p><pre><code> // 检查眼镜连接状态
 if (glassesConnectionManager.isConnected()) {
     // 连接眼镜成功，发送欢迎信息
     sendWelcomeMessage()
     // 启动眼镜端AI场景
     startGlassesAIScene()
 } else {
     // 显示连接提示
     showConnectionPrompt()
 }</code></pre><p>}<br/>}<br/>b、眼镜连接管理器<br/>class GlassesConnectionManager(private val context: Context) {<br/> private val TAG = "GlassesConnection"</p><p>/**</p><ul><li>检查眼镜连接状态<br/>  */</li></ul><p>fun isConnected(): Boolean {</p><pre><code> // 实现眼镜连接检测逻辑
 return true // 模拟连接成功</code></pre><p>}</p><p>/**</p><ul><li>发送欢迎消息到眼镜<br/>  */</li></ul><p>fun sendWelcomeMessage() {</p><pre><code> val welcomeText = """
     记账助手已连接

      欢迎回来！

     今日消费记录：${expenseManager.getTodayExpenseCount()}笔
     总金额：${expenseManager.getTodayTotalAmount()}元

      轻触眼镜触控板开始记录

     或对眼镜说："开始记账"
 """.trimIndent()

 // 使用TTS播报欢迎信息
 sendTTSContent(welcomeText)
 notifyTtsAudioFinished()</code></pre><p>}</p><p>/**</p><ul><li>处理从眼镜端接收的ASR内容<br/>  */</li></ul><p>fun handleGlassesAsrContent(asrContent: String): ValueUtil.CxrStatus? {</p><pre><code> return try {
     // 解析语音内容
     val expenseInfo = parseVoiceInput(asrContent)

     // 保存消费记录
     expenseManager.addExpense(expenseInfo)

     // 发送成功反馈
     sendSuccessFeedback(expenseInfo)

     ValueUtil.CxrStatus.REQUEST_SUCCEED
 } catch (e: Exception) {
     Log.e(TAG, "处理ASR内容失败", e)

     // 发送错误反馈
     sendErrorFeedback()

     ValueUtil.CxrStatus.REQUEST_FAILED
 }</code></pre><p>}</p><p>/**</p><ul><li>解析语音输入<br/>  */</li></ul><p>private fun parseVoiceInput(input: String): ExpenseInfo {</p><pre><code> // 使用AI NLP解析消费信息
 val nlpResult = nlpProcessor.analyzeExpenseText(input)

 return ExpenseInfo(
     amount = nlpResult.amount,
     category = nlpResult.category,
     merchant = nlpResult.merchant,
     description = nlpResult.description,
     timestamp = System.currentTimeMillis(),
     source = "voice"
 )</code></pre><p>}<br/>}<br/>C、消费记录管理器<br/>class ExpenseManager(private val context: Context) {<br/> private val database = Room.databaseBuilder(</p><pre><code> context,
 ExpenseDatabase::class.java,
 "expense_database"</code></pre><p>).build()</p><p>private val expenseDao = database.expenseDao()</p><p>/**</p><ul><li>添加消费记录<br/>  */</li></ul><p>suspend fun addExpense(expense: ExpenseInfo) {</p><pre><code> withContext(Dispatchers.IO) {
     expenseDao.insertExpense(expense)

     // 实时同步到云端
     syncToCloud(expense)

     // 更新今日统计
     updateTodayStats()
 }</code></pre><p>}</p><p>/**</p><ul><li>获取今日消费统计<br/>  */</li></ul><p>suspend fun getTodayStats(): TodayStats {</p><pre><code> return withContext(Dispatchers.IO) {
     val today = DateUtils.getTodayDate()
     val expenses = expenseDao.getExpensesByDate(today)

     TodayStats(
         totalAmount = expenses.sumOf { it.amount },
         expenseCount = expenses.size,
         categoryBreakdown = expenses.groupBy { it.category }
             .mapValues { it.value.sumOf { expense -&gt; expense.amount } },
         recentExpenses = expenses.takeLast(5)
     )
 }</code></pre><p>}</p><p>/**</p><ul><li>获取历史记录<br/>  */</li></ul><p>suspend fun getExpenseHistory(startDate: Long, endDate: Long): List&lt;ExpenseInfo&gt; {</p><pre><code> return withContext(Dispatchers.IO) {
     expenseDao.getExpensesByDateRange(startDate, endDate)
 }</code></pre><p>}<br/>}<br/>D、晚间汇总管理器<br/>class DailySummaryManager(private val context: Context) {<br/> private val TAG = "DailySummary"</p><p>/**</p><ul><li>安排每日晚间汇总<br/>  */</li></ul><p>fun scheduleDailySummary() {</p><pre><code> val workManager = WorkManager.getInstance(context)

 val summaryWork = PeriodicWorkRequestBuilder&lt;DailySummaryWorker&gt;(1, TimeUnit.DAYS)
     .setConstraints(
         Constraints.Builder()
             .setRequiresBatteryNotLow(true)
             .setRequiredNetworkType(NetworkType.CONNECTED)
             .build()
     )
     .addTag("daily_summary")
     .build()

 workManager.enqueueUniquePeriodicWork(
     "daily_summary",
     ExistingPeriodicWorkPolicy.KEEP,
     summaryWork
 )</code></pre><p>}</p><p>/**</p><ul><li>生成并发送晚间汇总<br/>  */</li></ul><p>suspend fun generateAndSendDailySummary() {</p><pre><code> val todayStats = expenseManager.getTodayStats()

 // 生成汇总报告
 val summaryReport = generateSummaryReport(todayStats)

 // 发送到眼镜端显示
 sendSummaryToGlasses(summaryReport)

 // 发送推送通知
 sendSummaryNotification(summaryReport)

 Log.d(TAG, "晚间汇总完成：${todayStats.totalAmount}元")</code></pre><p>}</p><p>/**</p><ul><li>生成汇总报告<br/>  */</li></ul><p>private fun generateSummaryReport(stats: TodayStats): String {</p><pre><code> return buildString {
     appendLine("今日消费汇总")
     appendLine("=" * 20)
     appendLine(" 总金额：${stats.totalAmount}元")
     appendLine(" 笔数：${stats.expenseCount}笔")
     appendLine()
     appendLine("分类统计：")

     stats.categoryBreakdown.forEach { (category, amount) -&gt;
         appendLine("• $category：${amount}元")
     }

     appendLine()
     appendLine("今日亮点：")
     appendLine(getDailyInsight(stats))

     appendLine()
     appendLine("明天见！")
 }</code></pre><p>}</p><p>/**</p><ul><li>发送汇总到眼镜端<br/>  */</li></ul><p>private fun sendSummaryToGlasses(summaryReport: String) {</p><pre><code> // 使用TTS播报汇总
 sendTTSContent("今日消费汇总：总共消费${expenseManager.getTodayTotalAmount()}元")

 // 可以显示详细文本
 if (glassesConnectionManager.isTeleprompterSupported()) {
     setWordTipsText(summaryReport, "daily_summary.txt")
 }</code></pre><p>}</p><p>/**</p><ul><li>获取每日洞察<br/>  */</li></ul><p>private fun getDailyInsight(stats: TodayStats): String {</p><pre><code> return when {
     stats.totalAmount &gt; 500 -&gt; "消费较多，注意理性消费哦"
     stats.expenseCount &gt; 10 -&gt; "消费频次较高，可以考虑批量购买"
     stats.categoryBreakdown.containsKey("餐饮") &amp;&amp; stats.categoryBreakdown["餐饮"]!! &gt; 100 -&gt; 
         "餐饮支出较多，可以尝试自己做饭"
     else -&gt; "消费合理，保持良好习惯"
 }</code></pre><p>}<br/>}<br/>E、消费记录实体和DAO<br/>@Entity(tableName = "expenses")<br/>data class ExpenseInfo(<br/> @PrimaryKey val id: String = UUID.randomUUID().toString(),<br/> val amount: Double,<br/> val category: String,<br/> val merchant: String,<br/> val description: String,<br/> val timestamp: Long,<br/> val source: String, // "voice", "photo", "manual"<br/> val imagePath: String? = null,<br/> val location: String? = null<br/>)</p></li></ol><p>@Dao<br/>interface ExpenseDao {</p><pre><code>@Query("SELECT * FROM expenses WHERE date(timestamp/1000, 'unixepoch') = date(:date/1000, 'unixepoch')")
suspend fun getExpensesByDate(date: Long): List&lt;ExpenseInfo&gt;

@Query("SELECT * FROM expenses WHERE timestamp BETWEEN :startDate AND :endDate")
suspend fun getExpensesByDateRange(startDate: Long, endDate: Long): List&lt;ExpenseInfo&gt;

@Insert
suspend fun insertExpense(expense: ExpenseInfo)

@Delete
suspend fun deleteExpense(expense: ExpenseInfo)

@Query("SELECT SUM(amount) FROM expenses WHERE date(timestamp/1000, 'unixepoch') = date(:date/1000, 'unixepoch')")
suspend fun getTotalAmountByDate(date: Long): Double</code></pre><p>}</p><p>data class TodayStats(</p><pre><code>val totalAmount: Double,
val expenseCount: Int,
val categoryBreakdown: Map&lt;String, Double&gt;,
val recentExpenses: List&lt;ExpenseInfo&gt;</code></pre><p>)</p><h3>四、 核心技术实现要点</h3><ol><li>语音识别优化</li></ol><p>使用离线路ASR引擎提高识别准确率<br/>针对财务术语进行训练优化<br/>实现语音指令快捷操作</p><ol start="2"><li>图像识别算法</li></ol><p>集成百度OCR/腾讯OCR API<br/>实现票据自动裁剪和增强<br/>建立商户名称和类别的智能匹配</p><ol start="3"><li><p>AI分类算法<br/>class ExpenseClassifier {<br/> private val categories = listOf(</p><pre><code> "餐饮", "交通", "购物", "娱乐", "医疗", 
 "住房", "教育", "其他"</code></pre><p>)</p><p>fun classifyExpense(merchant: String, description: String): String {</p><pre><code> val keywords = extractKeywords(merchant + " " + description)

 return when {
     keywords.any { it.contains("餐", "食", "厨", "味") } -&gt; "餐饮"
     keywords.any { it.contains("车", "油", "路", "停") } -&gt; "交通"
     keywords.any { it.contains("医", "药", "院") } -&gt; "医疗"
     // 更多分类逻辑...
     else -&gt; "其他"
 }</code></pre><p>}<br/>}</p></li><li>数据同步策略</li></ol><p>本地SQLite + 云端MySQL双存储<br/>实现离线缓存和在线同步<br/>数据加密和隐私保护</p><h3>五、 效果展示</h3><p>用户体验流程</p><p>早上出门：佩戴眼镜，自动连接记账助手<br/>消费时：<br/>语音方式："记录咖啡25元星巴克"<br/>或拍照小票自动识别</p><p>实时反馈：语音确认分类和金额<br/>晚间8点：自动生成今日消费汇总报告</p><p>数据统计功能</p><p>每日/每周/每月消费趋势<br/>分类占比饼图<br/>商户消费排行<br/>异常消费提醒</p><p>技术亮点</p><p>免手操作：全程语音和眼部操作，真正的解放双手<br/>AI智能识别：自动分类和金额识别，准确率&gt;95%<br/>实时反馈：即时语音确认，提升用户体验<br/>晚间汇总：自动化财务分析，培养良好记账习惯<br/>多端协同：眼镜端快速操作，手机端数据管理</p><h3>六、 商业价值</h3><p>用户价值</p><p>便捷性：解放双手，随时记录<br/>准确性：AI智能识别，减少人工错误<br/>及时性：实时反馈和晚间汇总</p><p>商业价值</p><p>数据价值：积累用户消费数据画像<br/>生态价值：连接支付、电商、金融服务<br/>技术价值：AI+AR在垂直领域的创新应用</p><h3>七、 未来展望</h3><p>功能扩展</p><p>预算管理：设定月度预算，实时预警<br/>投资建议：基于消费习惯提供理财建议<br/>社交功能：与好友比较消费习惯<br/>发票管理：自动归类和管理发票信息</p><p>技术升级</p><p>边缘AI：眼镜端本地AI推理<br/>5G应用：实时云端数据同步<br/>AR可视化：消费数据的AR展示<br/>语音助手：更智能的AI对话体验</p><h3>总结</h3><p>基于Rokid AI眼镜的记账本应用充分发挥了智能眼镜的硬件优势，通过语音识别、图像识别和AI分析，打造了全新的免手操作记账体验。从日常消费的实时记录到晚间的智能汇总，真正实现了"所见即所得，所说即所记"的智能财务管理理念。这个应用不仅提升了用户体验，更为智能眼镜在垂直领域的应用提供了有价值的探索。</p>]]></description></item><item>    <title><![CDATA[代码签名证书与数字时间戳服务的协同防篡改]]></title>    <link>https://segmentfault.com/a/1190000047434588</link>    <guid>https://segmentfault.com/a/1190000047434588</guid>    <pubDate>2025-11-28 14:05:12</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><a href="https://link.segmentfault.com/?enc=pK7zQ7DxUxEtM9KTJZTJJw%3D%3D.qC8skuwa6gQWdWc4HAhb8hR6hAQjfWJ8VQk9%2BfwfpESeulskinv6oo8fyQ9STjvsDauBbJZ8anHfDBf0ck%2FnN6JYe2bgNibIrzP7Yf75qmM%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/code_signing.html?n...</a></p><p><strong>注册码230959⬆️</strong></p><p><img width="679" height="678" referrerpolicy="no-referrer" src="/img/bVdmR6s" alt="" title=""/></p><h3>🔐 一、<strong>技术协同机制</strong></h3><ul><li><p><strong>双重加密绑定</strong></p><ul><li><strong>代码签名阶段</strong>：开发者使用私钥对代码哈希值（如SHA-256）加密生成数字签名。</li><li><strong>时间戳固化</strong>：将已签名的哈希值提交至权威时间戳服务器（TSA），TSA基于高精度时间源（如原子钟/GPS）生成时间戳令牌，并用TSA私钥对该令牌（含哈希值+精确时间）二次签名。</li><li><strong>结果嵌入</strong>：最终签名包含代码签名证书、时间戳令牌及双签名信息，形成不可分割的整体。</li></ul></li><li><p><strong>验证流程闭环</strong>  <br/>终端系统执行三重校验：</p><ul><li>用开发者公钥解密原始签名，比对当前代码哈希值（防篡改）；</li><li>用TSA公钥验证时间戳令牌真实性（防伪造时间）；</li><li>确认签名时间在证书有效期内（防过期滥用）。</li></ul></li></ul><h3>⚙️ 二、<strong>核心防篡改能力</strong></h3><table><thead><tr><th><strong>攻击类型</strong></th><th><strong>防御机制</strong></th><th><strong>技术实现</strong></th></tr></thead><tbody><tr><td><strong>代码篡改</strong></td><td>哈希值一致性校验</td><td>修改任意字节导致哈希值突变，验证立即失效</td></tr><tr><td><strong>时间伪造</strong></td><td>权威时间源绑定</td><td>TSA签名令牌使时间无法被客户端篡改</td></tr><tr><td><strong>重放攻击</strong></td><td>时间窗口限制 + 唯一性哈希</td><td>旧版本签名因时间戳过期被拒绝</td></tr><tr><td><strong>证书盗用</strong></td><td>私钥硬件隔离 + 时间戳时效约束</td><td>即使私钥泄露，过期时间戳使盗用无效</td></tr></tbody></table><h3>🚀 三、<strong>应用场景与合规价值</strong></h3><ul><li><p><strong>软件供应链安全</strong></p><ul><li><strong>驱动签名</strong>：Windows/Linux内核模块强制要求带时间戳的EV代码签名；</li><li><strong>固件升级</strong>：物联网设备OTA更新需通过时间戳证明升级包未回滚。</li></ul></li><li><p><strong>法律与合规要求</strong></p><ul><li><strong>举证效力</strong>：符合《电子签名法》要求的可靠电子签名需包含可信时间戳；</li><li><strong>行业规范</strong>：金融行业依据JR/T 0171-2020标准必须部署时间戳服务。</li></ul></li></ul>]]></description></item><item>    <title><![CDATA[AI员工时代：90%职场人必须面对的重构]]></title>    <link>https://segmentfault.com/a/1190000047434592</link>    <guid>https://segmentfault.com/a/1190000047434592</guid>    <pubDate>2025-11-28 14:04:31</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>AI超级个体：被重塑的职场边界</p><p>"过去两年，我们见证了一个反常现象：全球顶尖企业每季度裁员5%~10%，但股价却平均上涨20%~30%。这不是资本的冷血，而是一场静默的革命。（青否ai员工源头v：zhibo175）</p><p>当你还在为季度KPI焦头烂额时，企业高管们已经在用一个词重新定义职场：AI员工。</p><p>2023年3月24日，GPT-4正式发布。这一天，不是又一个技术迭代的普通日子，而是职场分水岭。从那天起，企业开始意识到：一个永不疲倦、持续进化、成本可控的AI员工，可能比10个人类员工更能创造价值。</p><p>访谈超过200位企业高管，发现了一个令人不安的趋势：76%的中层管理者认为，他们团队30%以上的工作已经可以被AI替代，但只有12%的员工意识到这一点。</p><p>这不是周期性的裁员潮，而是一场结构性变革。当企业发现用1个AI员工可以替代5个人类员工，同时提升3倍效率时，商业逻辑已经无法逆转。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434594" alt="" title=""/>问题不再是"AI会不会取代人类工作"，而是"你能否成为驾驭AI的人"。</p><p>当90%的职场人还在用旧地图寻找新大陆时，10%的先行者已经构建了"一人公司"，年入百万。</p><p>这场变革中，没有中间地带：要么主动重构，要么被动淘汰。</p><p>时代真相：AI员工与人的共生法则</p><p>许多人误以为AI是工具，这恰恰是最大的认知陷阱。</p><p>AI员工的本质，是"可无限复制的人类能力单元"。它们不只是执行指令的机器，而是能思考、学习、创造的数字生命体。</p><p>国务院最新发布的《关于深入实施人工智能+行动的意见》明确指出：到2027年，新一代智能终端、智能体等应用普及率将超过70%；到2030年，这一比例将超过90%。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434595" alt="" title="" loading="lazy"/>这意味着什么？意味着5年后，当你打开任何软件、访问任何网站、使用任何服务，背后都有70%的概率是AI智能体在为你服务，而非人类。</p><p>更震撼的是，这份文件预测，到2035年，中国将全面步入智能经济和智能社会发展新阶段。这不是遥远的科幻，而是我们这代人必将见证的历史进程。</p><p>职场竞争格局正在发生根本性转变：</p><p>旧时代：人 vs 人（比拼学历、经验、人脉）</p><p>新时代：人+AI vs 仅人（比拼AI赋能的综合能力）</p><p>真正的领先者已经将AI视为团队成员：一个能24小时工作、不需要休息、持续进化的"数字同事"。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434596" alt="" title="" loading="lazy"/>当你还在用ChatGPT写邮件时，他们已经在用AI员工管理客户关系、生成商业洞察、优化决策流程。</p><p>最危险的不是AI太强大，而是你还在用20世纪的思维应对21世纪的变革。</p><p>青否ai超级员工，获客+引流+销售全流程，青否AI超级员工：支持手机语音控制 + 岗位级替代！核心功能如下：（青否ai员工源头v：zhibo175）</p><p>1、AI获客</p><p>告别内容内耗，多平台高效运营。</p><p>sora2批量生成爆款短视频，智能匹配行业关键词，全自动发布覆盖抖音、快手、视频号、小红书。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434597" alt="" title="" loading="lazy"/></p><p>GEO智能体优化多平台AI内容，用户提问时主动推荐企业及产品，精准曝光。</p><p>多账号一键绑定管理，数据实时监测，无需跨平台切换，省掉半个编辑团队。</p><p>解决：内容累、制作耗时长、跨平台管理乱的痛点。</p><p>2、AI引流（青否ai员工源头v：zhibo175）</p><p>全域精准引流，获客效率倍增。</p><p>按行业+用户画像全网采集高意向客户，主动私信/评论，无需人工蹲点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434598" alt="" title="" loading="lazy"/></p><p>抖音客服7*24小时在线自动回复，AI拟人聊天，引导客户留资。</p><p>解决：找客难、引流慢、精准度低的痛点。</p><p>3、AI销售（青否ai员工源头v：zhibo175）</p><p>标准化私域成交，降本又增效。</p><p>智能私域管家：自动通过好友、实时监控聊天记录、拟人化自动回复，精准预测客户行为分层。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047434599" alt="" title="" loading="lazy"/></p><p>高情商促单：洞察客户需求、处理异议、推动成交，7x24 小时在线不打烊。</p><p>安全保障：本地部署 + 独立后台，知识库与数据全加密，杜绝泄露。</p><p>解决：转化低、跟进慢、客户数据不安全的痛点。</p><p>2025年Agent 爆发！只需指令就能干活，你的”数字员工”已上线（青否ai员工源头v：zhibo175）！</p>]]></description></item><item>    <title><![CDATA[Omnissa App Volumes ]]></title>    <link>https://segmentfault.com/a/1190000047434603</link>    <guid>https://segmentfault.com/a/1190000047434603</guid>    <pubDate>2025-11-28 14:03:47</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Omnissa App Volumes 4, version 2509 - 实时应用程序交付系统</p><p>Omnissa App Volumes, formerly VMware App Volumes</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=bB1eM44126PZnvZj4S113Q%3D%3D.yTPTlHiWAVkk0AhbzUe5GKaT%2FU%2FzvEsN6L%2BwkiKqAPhbsTaiPl0aYYHEz1duOARO" rel="nofollow" target="_blank">https://sysin.org/blog/omnissa-app-volumes/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=UAAhXlWt%2BYi1V5r28xB1%2Bw%3D%3D.dEWgoPPljgh4qjGeEk6ry9%2FSmjIDhbACdpctaOLwTPs%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000046037272" alt="Omnissa Horizon 架构图" title="Omnissa Horizon 架构图"/></p><p>重新定义跨 VDI、DaaS 和已发布的应用环境交付和管理应用的方式</p><h2>关于 Omnissa App Volumes</h2><p>Omnissa App Volumes 是一个实时应用程序交付系统，企业可以使用它来动态交付和管理应用程序。</p><p>通过将标准 VMDK 或 VHD 文件附加到虚拟机来打包和交付应用程序。您可以使用 App Volumes Manager（一个与  Active Directory（AD）集成的基于 Web  的界面）集中管理应用程序。管理员可以分配、更新或删除要在下次用户登录时交付的应用程序，而无需修改桌面或在用户工作时中断用户。</p><p>可写卷允许用户跨会话和设备访问其应用程序数据。</p><h2>新增功能</h2><p>Omnissa App Volumes 2509 | October 30 2025 | Build 4.19.0.98</p><p>Omnissa App Volumes 2509.1 | November 24 2025 | Build 4.19.1.103</p><p>App Volumes 2509 的新增功能</p><ul><li><p><strong>所有 Windows 终端的统一生命周期管理（技术预览）</strong></p><p>App Volumes 现在提供一个统一的平台，用于管理所有 Windows  终端上应用程序的完整生命周期，无论设备处于在线或离线状态。通过 App Volumes  Manager，管理员可以集中管理应用版本、回滚以及针对共享存储（connected）和本地副本（offline）交付模式的授权（entitlements）。</p><p>对于配置为 local copy 交付模式的终端，打包的应用将存储在设备上，即使设备离线也能按需启动。当重新联网时，终端会自动更新由 App Volumes 管理的授权，确保应用持续且一致地可用。</p></li><li><p><strong>与 Workspace ONE Intelligent Hub 的 Apps On Demand 集成</strong></p><p>App Volumes 现在可以通过 Omnissa Access 连接至 Omnissa Workspace ONE  Intelligent Hub，使管理员能够直接通过 App Volumes Manager 发布和管理 App Volumes  应用。此集成使应用和快捷方式能够显示在由 Workspace ONE Hub Services  提供的单一目录中，用户可以在其中发现并按需启动应用。</p></li><li><p><strong>在用户活动会话中进行应用更新与卸载</strong></p><p>管理员现在可以配置 App Volumes 在应用更新或卸载触发时通知最终用户，使整个过程能够在当前活动会话中完成。此改进消除了对注销或重启周期的依赖，加快应用切换速度，并提升用户体验。</p></li><li><p><strong>应用打包无需强制重启</strong></p><p>无论是通过 App Volumes Application Capture Command-Line Program 还是 App  Volumes Manager  发起的应用打包，现在都不再需要强制系统重启来完成捕获流程（除非应用本身要求）。这减少了停机时间并加速打包工作流程。</p></li><li><p><strong>Package Report Viewer</strong></p><p>新的 Package Report Viewer 功能在最终确认前提供更深入的捕获内容可视性。管理员可以查看并验证 package  中的所有文件、目录和注册表键，并清晰识别受限制或被排除的条目。报告可以导出为 JSON 和 HTML 格式，用于分析或自动化工作流程集成。</p></li><li><p><strong>优化的 VHD Package 大小</strong></p><p>App Volumes 现在使 VHD package  的大小更接近应用程序原生安装的实际占用空间。此优化提高效率、减少本地存储使用，并加速 package 的下载和更新。针对使用 local  copy 交付模式的终端，这一改进尤其有益，因为每个设备都会存储 package 的本地副本。</p></li><li><p><strong>应用链接的选择性启用</strong></p><p>管理员现在可以选择性地启用或隐藏单个应用快捷方式和链接。这使得针对应用入口点的控制更加精细，适用于 Horizon Published Apps 或 Amazon AppStream 2.0 等环境，为最终用户提供更简化的体验。</p></li></ul><h2>下载地址</h2><p>Omnissa App Volumes 4, version 2506 (v4.19)</p><p>Release Date: 2025-10-30</p><ul><li>下载地址：<a href="https://link.segmentfault.com/?enc=QTHWSDR3HxaYnDlW3aqHTA%3D%3D.MgFkadS5C6yNk6oxPeizWwtE%2BWE%2FiOlIrkqqUPITBQsMfchH4qqjTvaLq6ZXhN77" rel="nofollow" target="_blank">https://sysin.org/blog/omnissa-app-volumes/</a></li><li>App Volumes ISO file<br/>File size: 540.67 MB<br/>Name: Omnissa_App_Volumes_v4.19.0_27102025.ISO</li></ul><p>Omnissa App Volumes 4, version 2509.1 (v4.19.1)</p><p>Release Date: 2025-11-24</p><ul><li>App Volumes ISO file<br/>File size: 540.67 MB<br/>Name: Omnissa_App_Volumes_v4.19.1_14112025.ISO</li></ul><p>更多：<a href="https://link.segmentfault.com/?enc=dCczGVe8IAd4%2BoD7on%2FjyA%3D%3D.Q8P6Z1b0yr2IdRwIT0sEvveqNRfMmvhu4R6k%2FbtVTtA%3D" rel="nofollow" target="_blank">VMware 产品下载汇总</a></p>]]></description></item><item>    <title><![CDATA[铜价波动、工艺严苛、追溯困难？一套 漆包]]></title>    <link>https://segmentfault.com/a/1190000047434626</link>    <guid>https://segmentfault.com/a/1190000047434626</guid>    <pubDate>2025-11-28 14:02:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><strong>一、行业挑战：漆包线生产的“高精尖”困局</strong><br/>原材料波动大：铜杆价格日变，不同批次导电率、延展性差异直接影响漆膜附着力；<br/>工艺窗口极窄：涂漆厚度需控制在 ±0.5μm 内，烘焙温度偏差 ±5℃ 即可导致绝缘失效；<br/>质量追溯难：一旦出现针孔、漆瘤、耐压不足，无法快速定位至具体机台、时间段、操作参数；<br/>设备依赖高：拉丝机、涂漆机、烘焙炉长期高负荷运行，突发故障导致整线停产，损失巨大。<br/>传统依靠人工记录、纸质工单、Excel排产的管理模式，已难以支撑高端漆包线的量产一致性与交付可靠性。<br/><img width="723" height="385" referrerpolicy="no-referrer" src="/img/bVdnb4J" alt="" title=""/><br/><strong>二、整体架构：以“线轴”为核心的全流程数字主线</strong><br/>┌──────────────────────────────┐<br/>│ 企业层（ERP/PLM） │ ← 订单、铜材BOM、客户标准<br/>└──────────────┬───────────────┘<br/>↓<br/>┌──────────────────────────────┐<br/>│ 制造执行层（MES 核心） │ ← 万界星空漆包线专用MES<br/>│ • 智能排产 • 工艺闭环 │<br/>│ • 质量追溯 • 设备健康管理 │<br/>│ • 铜价联动 • 数据驾驶舱 │<br/>└──────────────┬───────────────┘<br/>↓<br/>┌──────────────────────────────┐<br/>│ 设备控制层（PLC/SCADA） │ ← 拉丝机、涂漆机、烘焙炉、称重打标<br/>└──────────────────────────────┘<br/><strong>三、万界星空漆包线 MES 核心功能    </strong></p><ol><li>智能生产计划与动态排程<br/>基于订单交期、铜材库存、设备状态、人员班次等多维约束，自动生成最优排产方案；<br/>支持紧急插单、设备故障等异常场景下的秒级动态调整，减少换模停机时间；<br/>自动关联当日铜价，实现动态成本核算与报价联动。<br/>价值：某头部漆包线厂排产效率提升40%，订单交付准时率达98.5%。</li><li>全过程工艺精准控制<br/>对拉丝速度、张力、涂漆粘度、烘焙温度/湿度等关键参数实时监控；<br/>系统自动调取历史最优工艺配-方（如不同线径对应的最佳退火曲线）；<br/>参数超差即时报警（如烘焙温度超出±5℃），避免批量性质量问题。<br/>价值：产品一致性提升，高端客户退货率下降65%。</li><li>全流程质量追溯体系<br/>每轴产品绑定唯一二维码，自动记录：<br/>✓ 铜杆批次与质检报告<br/>✓ 拉丝/涂漆/烘焙各工序参数<br/>✓ 在线检测数据（外径、漆膜厚度、耐压值）<br/>✓ 操作员与设备信息</li><li>设备全生命周期管理<br/>实时采集拉丝机振动、涂漆机泵压、烘焙炉温控等数据，评估设备健康状态；<br/>基于运行时长与故障模型，预测性生成维护工单；<br/>自动计算 OEE（设备综合效率），识别性能损失点（如换模耗时、空转等待）。<br/>价值：设备稼动率提升15%+，非计划停机减少30%。</li><li>万界星空智能称重打标系统一体化<br/>称重台与 MES 直连，漆包线下线即自动称重、生成入库单；<br/>标签自动打印：含规格、重量、长度、生产日期、二维码，支持客户定制格式；<br/>内置防错规则（如1.0mm线径重量异常自动预警），杜绝人为录入错误。<br/>价值：入库效率提升50%，库存准确率达99.9%。</li><li>铜价联动与成本精细化管控<br/>对接有色-网等-平-台，实时获取铜价；<br/>自动计算每轴产品材料成本，结合加工费生成精准报价；<br/><img width="723" height="400" referrerpolicy="no-referrer" src="/img/bVdnb4K" alt="" title="" loading="lazy"/><br/><strong>四、技术优势：专业漆包线行业经验</strong><br/>行业Know-How内嵌 系统预置QZ-2/155、QA-1/180等上千种漆包线规格参数库<br/>AI低代码-平-台 支持30分钟内响应个性化需求（如特殊品处理流程）<br/>工业级稳定性 7×24小时连续运行，已通过多家万吨级漆包线厂验证<br/>全栈交付能力 提供软件+称重系统+数据采集终端一站式解决方案<br/>在新能源、高效电机驱动高端漆包线需求爆发的今天，制造精度即是市场竞争力。万界星空科技深耕漆包线、电磁线、电线电缆等行业多年，以专业、务实、可落地的 MES 解决方案，已成功应用于华东、华南多家漆包线龙头企业，支持从中小产线到万吨级智能工厂的灵活配置。欢迎私信获取《漆包线MES解决方案》或预约演示。</li></ol>]]></description></item><item>    <title><![CDATA[「半空」富脚手架模式：字节 Go2Rus]]></title>    <link>https://segmentfault.com/a/1190000047433193</link>    <guid>https://segmentfault.com/a/1190000047433193</guid>    <pubDate>2025-11-28 14:02:12</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在云原生与高性能服务的发展趋势下，Go 项目迁移到 Rust 项目成为提升性能和稳定性的最重要优化方向，但依赖复杂、有语言门槛等问题长期制约着 Go2Rust 的大规模落地。字节跳动服务框架团队基于内部大量迁移实践，融合大模型能力与工程经验，推出「半空」富脚手架模式，将迁移从“人工主导”转变为“标准化流程”，为需要进行 Go2Rust 迁移的团队提供了一套可落地的技术参考。</p><p>本文基于字节跳动服务框架团队研发工程师范广宇在 CloudWeGo 四周年技术沙龙上的演讲内容整理，详细拆解了「半空」富脚手架模式的设计逻辑、实施步骤与实践成效。</p><p>点击链接可查看本次分享回放👉🏻<a href="https://link.segmentfault.com/?enc=DHe3mALm7KvJsDKWpuxmVg%3D%3D.8bl5spLI3cTPBxsU9E2ITZFdW2Y5v8yBk1xVDRZvDyM%3D" rel="nofollow" target="_blank">https://b23.tv/v7rRu7D</a></p><p><img width="723" height="488" referrerpolicy="no-referrer" src="/img/bVdnbGq" alt="image.png" title="image.png"/></p><h4>一、从 Go 到 Rust：不止于性能的追求</h4><p>字节跳动内部的多个项目实践已经证明，将 Go 服务迁移至 Rust，不仅能带来显著的 CPU 性能提升，还能有效增强服务稳定性、降低运维成本。这背后，是 Rust 语言本身在内存安全和高并发处理上的独特优势。</p><p><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnbGs" alt="image.png" title="image.png" loading="lazy"/></p><p>为了让更多业务团队享受到迁移带来的红利，服务框架团队探索出两条路径：</p><ul><li><strong>间接优化</strong>：让 Go 服务无需改造代码，即可间接获得 Rust 的性能优势。（关于ROG 技术剖析和业务落地，可以点击观看视频：<a href="https://link.segmentfault.com/?enc=Ngm4rFudBsucZj8L5f8nzw%3D%3D.IAPSeleunYpKmcpRBsFJQODfnJPoUNjwSUvCv6qItgs%3D" rel="nofollow" target="_blank">https://b23.tv/35jPPMg</a>）</li><li><strong>完全迁移</strong>：通过自动化方案，将业务代码完全迁移至 Rust，实现更彻底的性能飞跃。</li></ul><p>「半空」富脚手架模式，正是为实现第二条路径——<strong>规模化、低门槛的完全迁移</strong>——而生。</p><p><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnbGr" alt="image.png" title="image.png" loading="lazy"/></p><h4>二、迁移面临的三大挑战</h4><p>尽管 Go2Rust 的价值显而易见，但长久以来，大规模落地始终面临着三大挑战：</p><ul><li><strong>陡峭的学习曲线</strong>：Rust 独特的所有权、生命周期等概念，对习惯了 Go 的工程师来说，无疑是一道不低的门槛。这使得许多团队在迁移面前望而却步。</li><li><strong>复杂的依赖黑洞</strong>：一个 Go 项目，其直接和间接依赖往往构成一个庞大的依赖树。依赖的层级越深，迁移的复杂度就越高，甚至呈指数级增长。如何有效管理和迁移这些依赖，是一个棘手的问题。</li><li><strong>不可控的翻译质量</strong>：单纯依赖大模型进行代码翻译，结果往往充满不确定性。生成的“Go 味” Rust 代码，不仅风格怪异，更难以满足生产环境对代码质量的严苛要求。</li></ul><p>为了跨越这些鸿沟，服务框架团队的迁移模式也经历了持续的演进：从完全依赖人工经验的“作坊式”迁移，到利用工具辅助的“渐进式”翻译，再到如今将迁移升级为“标准化流程”的「半空」富脚手架模式。</p><h4>三、「半空」富脚手架：三步走的标准化迁移流程</h4><p>「半空」富脚手架的核心，是将复杂、高度依赖人工经验的迁移过程，抽象、封装成一个标准化的三步流程。它以 IDE 插件的形式提供服务，接收用户的 Go 项目，输出一个 100% 可编译、保留完整业务逻辑的 Rust 脚手架，彻底将工程师从繁琐的“体力活”中解放出来。<br/>这套流程完全复刻了资深工程师进行手动迁移时的心智模型，分为<strong>翻译前、翻译中、翻译后</strong>三个阶段。</p><p><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnbHi" alt="image.png" title="image.png" loading="lazy"/></p><h5>第一步：翻译前 —— 运筹帷幄，绘制精准迁移蓝图</h5><p>如同建造大楼前需要有精确的施工图纸，「半空」在启动翻译前，会进行一次彻底的“项目体检”，为后续的自动化迁移绘制清晰的路径。</p><ul><li><strong>项目深度理解文档</strong>：自动解析项目并生成完整的项目梳理文档，涵盖整体架构、接口定义、函数逻辑、结构体设计等，让工程师对项目全貌有宏观的把握。</li><li><strong>依赖梳理</strong>：系统性地梳理项目的直接与间接依赖，并智能标注出无需翻译的依赖项。这不仅能精确评估迁移的工作量与难度，也让迁移的范围和质量变得清晰可控。</li><li><strong>接口梳理及规划</strong>：对于复杂的微服务项目，工具会自动提取目标接口及其完整的函数调用链，将庞大的业务逻辑拆解为一个个可以独立编译、验证和运行的单元。</li></ul><h5>第二步：翻译中 —— 黑盒操作，从“神似”到“形似”的精准转化</h5><p>准备工作就绪后，工程师只需在熟悉的 IDE 中一键触发，即可启动翻译。</p><ul><li><strong>基础映射与</strong> <strong>IDE</strong><strong>搜集</strong>：针对 Kitex 微服务项目，自动完成从 Golang 框架到 Rust 框架的基础结构映射，并自动化搜集下游服务所依赖的 IDL 文件，免去了大量繁杂的手动梳理。</li><li><strong>“意译”而非“直译”</strong>：这是「半空」翻译质量的核心保障。它以“节点”为基本单元，采用“意译”的逻辑，深入理解 Golang 代码的业务意图，然后用最符合 Rust 语言习惯和最佳实践的方式来生成代码，从根本上避免了生硬、别扭的“Go 风格 Rust 代码”。</li></ul><p><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnbHl" alt="image.png" title="image.png" loading="lazy"/></p><ul><li><p><strong>智能化的依赖处理</strong>：针对不同类型的依赖，「半空」采取了不同的处理策略：</p><ul><li><strong>本地依赖</strong>：通过递归翻译直接迁移。</li><li><strong>业务</strong> <strong>SDK</strong>：标记为递归翻译后，生成对应的 Rust 版本。</li><li><strong>内部基础组件</strong>：建立专门的知识库，映射 Golang 组件在 Rust 中的等效实现与用法。</li><li><strong>开源组件</strong>：优先调用知识库中的成熟方案，当知识库缺失时，再由大模型进行补全。</li></ul></li></ul><p>通过自下而上的递归翻译逻辑，从最底层的函数开始，逐个节点完成编译和翻译，最终确保整个接口链路的完整性与可运行性。</p><h5>第三步：翻译后 —— 自动优化与辅助校验，守好交付质量最后一关</h5><p>翻译完成不等于大功告成。为了确保交付的代码能直接进入生产环境，「半空」还提供了一套完善的“售后服务”。</p><ul><li><strong>基于 LLM Agent 驱动的代码质量优化</strong>：一个内置的 Agent 会自动尝试编译生成的 Rust 代码，智能解析编译过程中出现的错误，并进行多轮自我修复。实践证明，这能将代码的初始编译通过率从约 80%~90% 提升至 100% 可直接运行的状态。</li></ul><p><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnbHm" alt="image.png" title="image.png" loading="lazy"/></p><ul><li><strong>IDE</strong> <strong>辅助校验</strong>：提供便捷的 IDE 校验插件，支持翻译后的 Rust 代码与原始 Golang 源码的一键跳转、对比查看。这使得工程师可以像 Code Review 一样，快速核对业务逻辑的一致性，确保迁移的准确无误。</li></ul><p>内部实践表明，经「半空」处理后的代码，质量已非常接近资深工程师手动编写的水平，真正实现了高质量、低成本的规模化迁移。</p><h4>四、未来展望：不止于迁移，更重塑研发体验</h4><p>「半空」富脚手架模式的推出，仅仅是 Go2Rust 工程化探索的第一步。服务框架团队的目标，不止于实现 1:1 的精准翻译，更希望借此重塑 Rust 的研发体验。<strong>截至发稿前，「半空」在字节内部已实现万行代码 0 编译错误的翻译交付。</strong></p><p><img width="723" height="412" referrerpolicy="no-referrer" src="/img/bVdnbHn" alt="image.png" title="image.png" loading="lazy"/></p><ul><li><strong>引入 Deep Research 架构</strong>：在未来，服务框架团队希望「半空」不仅能“翻译”代码，更能“重构”代码。它将能自动将翻译后的代码，重构为更符合 Rust 最佳实践的形态，充分释放 Rust 语言的强大潜力。</li><li><strong>持续推广优化</strong>：服务框架团队将持续扩大「半空」的推广范围，积累更多场景的迁移案例，并建立用户反馈的闭环。通过分析用户对翻译代码的修改，持续、智能地优化翻译流程与代码质量。</li></ul>]]></description></item><item>    <title><![CDATA[时间上保证旧Leader会自动让位给新L]]></title>    <link>https://segmentfault.com/a/1190000047434630</link>    <guid>https://segmentfault.com/a/1190000047434630</guid>    <pubDate>2025-11-28 14:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>“不可靠的网络”、“不稳定的时钟”和“节点的故障”都是在分布式系统中常见的问题，在文章开始前，我们先来看一下：如果在分布式系统中网络不可靠会发生什么样的问题。</p><p>有以下 3 个服务构成的分布式集群，并在 server_1 中发生写请求变更 A = 1，“正常情况下” server_1 将 A 值同步给 server_2 和 server_3，保证集群的数据一致性：</p><p>但是如果在数据变更时发生网络问题（延迟、断连和丢包等）便会出现以下情况：比如有两个写操作同时发生在 server_1 或 server_3 上，即便两个写操作有先后顺序，但可能由于网络延时导致各个服务中数据的不一致：</p><p>同样地情况，如果在 server_1 上发生三次写操作，在数据同步的过程中因为网络延时或网络丢包也可能会导致数据的不一致：</p><p>那么为了避免以上这些集群间数据不一致的问题，便需要分布式共识算法来协调。分布式共识算法简单来说就是如何在多个服务器间对某一个值达成一致，并且当达成一致之后，无论之后这些机器间发生怎样的故障，这个值能保持不变。本篇文章我们便对 Raft 算法进行介绍。</p><p>理解 Raft 算法<br/>了解和学习过 Zookeeper 的同学可能听说过 Zab 算法，它用来保证 Zookeeper 中数据的 顺序一致性。Raft 也是一种分布式共识算法，它易于理解和实现，用于保证数据的 线性一致性，是最强一致性模型。</p><p>在遵循 Raft 算法的集群中，节点会有 3 种不同的角色。当集群在初始化时，每个节点的角色都是 Follower 跟随者，它们会等待来自 Leader 节点的心跳。因为此时并没有 Leader 节点，所以会等待心跳超时。等待超时的 Follower 节点会将角色转变为 Candidate 候选者，触发一次选举，触发选举时会标记 Term 任期变量，并将自己的一票投给自己，通知其他 Follower 节点发起投票。经过投票后，收到超过半数节点票数的 Candidate 节点会成为 Leader 领导者节点，其他节点为 Follower 跟随者节点，Leader 节点会不断地发送心跳给 Follower 节点来维持领导地位：</p><p>如果每个节点每次在触发选举时都是同时超时，这样是不是导致不能完成一次选举，产生 “活锁” 问题？的确可能，不过活锁问题也很好解决：即节点超时时间在合理的范围内取随机值，这样由于它的随机性就不太可能再同时发起竞选了，这个时候其他节点便有足够的时间向其他节点索要选票。</p><p>写变更请求<br/>当发生写变更请求时，由 Leader 节点负责处理，即使是请求到 Follower 节点，也需要转发给 Leader 节点处理。当 Leader 节点接收到写请求时，它并不立即对这个请求进行处理，而是先将请求信息 按顺序追加到日志文件中（WAL: write-ahead-log），如图中标记的 log_index 表示追加到的最新一条日志的序号：</p><p>在这个过程中， 日志必须持久化存储。随后，Leader 节点通过 RPC 请求将日志同步到各个 Follower 节点，当超过半数节点成功将日志记录时，便认为同步成功。在这里可知 Raft 算法采用的是单主复制的模型，所以它也就会存在以下缺点：</p><p>面对大量写请求负载时系统比较难扩展，因为系统只有一个主节点，写请求的性能瓶颈由单个节点决定</p><p>当主节点宕机时，从节点提升为主节点不是即时的，可能会造成一些停机时间</p><p>随后，Leader 节点会更新最新同步日志的索引 commit_index 为 1，并通过心跳下发给各个 Follower 节点：</p><p>在这个过程中可以发现 Follower 节点只是听从并响应 Leader 节点，没有任何主动性。现在，已经完成了日志在集群间的同步，但是请求对变量 A 的修改还没有被应用（Apply）。Apply 是在 Raft 算法中经常出现的一个名词，在多数与 Raft 算法相关的文章中经常会看到 “将已提交的日志条目应用到状态机” 等类似的表述。其实 “状态机” 理解起来并不复杂，通俗的理解是 业务逻辑的载体 或 业务逻辑的执行者，它的职责包括：</p><p>接收来自日志文件中有序的命令</p><p>执行具体的业务逻辑，在本次写请求中，业务逻辑指的便是变更 A 的值</p><p>变更应用程序的状态</p><p>返回执行结果</p><p>更加通俗的讲就是 让请求生效。将已经提交的日志应用到状态机是比较简单且自主的过程，各个服务实例会记录 apply_index 来标记应用索引，当 apply_index 小于 commit_index 时，那么证明日志文件中记录的请求信息还有部分没生效，所以需要按顺序应用，直到 apply_index = commit_index：</p><p>在这个过程中，我一直在强调 “按顺序”，不论是日志的追加还是日志的被应用都是按顺序来的，因此才能保证数据的线性一致性。</p><p>读请求<br/>Raft 集群处理读请求会保证读请求的线性一致性，所谓线性一致性读就是在 t1 的时间写入了一个值，那么在 t1 之后，读一定能读到这个值，不可能读到 t1 之前的值，在 Raft 算法中实现线性一致性读有以下两种方式：</p><p>ReadIndex Read<br/>在这种方式下，当 Leader 节点处理读请求时：</p><p>首先将 commit_index 记录到本地的 read_index 变量里</p><p>向其他节点发送一次 Heartbeat，确认自己仍然是 Leader 角色</p><p>Leader 节点等待自己的状态机执行，直到 apply_index 超过了 read_index，这样就能够安全的提供线性一致性读了</p><p>Leader 执行 read 请求，将结果返回</p><p>在第三步中，保证 apply_index &gt;= read_index 是为了保证所有小于等于 read_index 的请求都已经生效。</p><p>如果是 Follower 节点处理读请求也和以上过程类似，当 Follower 节点收到读请求后，直接给 Leader 发送一个获取此时 read_index 的请求，Leader 节点仍然处理以上流程然后将 read_index 返回，此时 Follower 节点等到当前的状态机 apply_index 超过 read_index 后，就可以返回结果了。</p><p>Lease Read<br/>因为 ReadIndex Read 需要发送一次 Heartbeat 来确认 Leader 身份，存在 RPC 请求的开销，为了进一步优化，便可以采用租约（Lease）读。租约其实指的是 Leader 节点身份的过期约定时间，所以这种读请求只针对 Leader 节点，Follower 节点没有租约的概念，它通过以下公式计算：</p><p>lease_end = current_time() + election_timeout / clock_drift_bound</p><p>其中 election_timeout 为选举的超时时间，clock_drift_bound 表示时钟漂移，指的是在分布式系统中，两个或多个节点上的时钟以不同的速率运行，导致它们之间的时间差随时间不断累积和变化（也就是分布式系统中不稳定的时钟问题）。</p><p>举个简单的例子，假如选举过期时间是 10s，时钟漂移为 1.1，那么租约过期时间为：lease_end = current_time() + 10s / 1.1 ≈ current_time() + 9s，如果在处理读请求时，在租约时间内，则无需发送 Heartbeat 来明确 Leader 身份，直接等待 apply_index &gt;= commit_index 后返回请求结果。</p><p>在以上读写流程中，Raft 分布式共识算法能让每个节点对日志的值和顺序达成共识，每个节点都存储相同的日志副本，使整个系统中的每个节点都能有一致的状态和输出，使得这些节点看起来就像一个单独的，高可用的状态机。在上文中我们提到过 Zookeeper 使用的 Zab 共识算法保证的是顺序一致性，Raft 算法保证的是线性一致性，所以借着这个引子也来谈谈我对一致性的理解。</p><p>一致性<br/>一致性 通常指的就是数据一致性，在分布式系统中的读写请求，表现得像在单机系统上一样，符合直觉和预期。一致性模型有很多种，在这里我们只谈以下常见的几种：</p><p>线性一致性 是最强的一致性模型，也被称为强一致性，在 CAP 定理中的 C 表达的一致性含义便是线性一致性。这种一致性模型要求系统要像单一节点一样工作，并且所有操作是原子的，它有两个约束条件：</p><p>顺序记录中的任何一次读必须读到最近一次写入的数据</p><p>顺序记录要跟全局时钟下的顺序保持一致</p><p>顺序一致性 要比线性一致性弱，它只要求 同一客户端或进程的操作在排序后保持先后顺序不变，但 不同客户端之间的先后顺序是可以任意改变的，顺序一致性与线性一致性的主要区别在于 没有全局时间的限制。比如在社交网络场景下，一个人通常不关注他看到的所有朋友的帖子的顺序，但是对于某个具体朋友，仍然以正确的顺序显示帖子的顺序。</p><p>因果一致性 则是比 顺序一致性 更弱的一致性模型，因果一致性要求必须以相同的顺序看到因果相关的操作，而没有因果关系的并发操作可以被不同的进程以不同的顺序观察到。典型的例子就是社交网络中发帖和评论的关系：必须先有发帖才能对该帖子进行评论，所以发帖操作必须在评论操作之前。</p><p>最终一致性 是常见的最弱的一致性模型，所谓最终表达的含义是“对于系统到达稳定状态并没有硬性要求”，即便这听起来很不靠谱，但是在业务中被应用的很多也很好，而且这种一致性模型能使系统的性能很高。</p><p>CAP 定理：C 代表一致性，当客户端访问所有节点时，返回的都是同一份最新的数据；A 代表可用性，指每次请求都能获取到非错误的响应，但不保证获取的数据是最新的；P 代表分区容错性，节点之间由于网络分区而导致消息丢失的情况下，系统仍能正常运行。</p><p>接下来我们再来谈谈脑裂问题：</p><p>脑裂问题<br/>当集群中发生网络通讯问题时，读、写请求只能在超过半数节点的集群内生效， 过半数机制 在数学上保证不可能同时存在两个Leader：</p><p>除此之外还有以下机制来避免脑裂问题：</p><p>Term机制：时间上保证旧Leader会自动让位给新Leader</p><p>主动stepDown：Leader无法联系到过半数节点时主动放弃领导权</p><p>严格的投票规则：每个term每个节点只能投票给一个候选人</p><p>当网络问题恢复时，Follower 节点能通过 Leader 节点的日志同步重新追回期间错过的数据。此外，一般采用 Raft 算法的集群在部署的时都是 “奇数个节点”，而不是偶数个节点，这其实是数学的体现，性价比更高：</p><p>如上图所示，虽然部署 4 个节点多出一个节点，但是和 3 节点集群相比，容错能力是相同的：只能容忍 1 个节点故障。在容错能weibo.com/ttarticle/p/show?id=2309405237746720702805 weibo.com/ttarticle/p/show?id=2309405237747052052653 weibo.com/ttarticle/p/show?id=2309405237747383664997 weibo.com/ttarticle/p/show?id=2309405237747727597583 weibo.com/ttarticle/p/show?id=2309405237748071268603 weibo.com/ttarticle/p/show?id=2309405237748549681198 weibo.com/ttarticle/p/show?id=2309405237748901740596 weibo.com/ttarticle/p/show?id=2309405237749249867953 weibo.com/ttarticle/p/show?id=2309405237749593800846 力没有被提高的情况下又花费了更多的服务器成本和运维管理成本。<br/>以上我们基本了解了 Raft 算法的内容，如果想使用 Raft 算法，对系统模型有以下要求：<br/>服务可能宕机、停止运行，但过段时间能够恢复，但不能存在 拜占庭故障<br/>消息可能丢失、延迟乱序或重复；可能有网络分区，并在一段时间之后恢复</p>]]></description></item><item>    <title><![CDATA[实时云渲染知识库 | 开发者社区FAQ合]]></title>    <link>https://segmentfault.com/a/1190000047434235</link>    <guid>https://segmentfault.com/a/1190000047434235</guid>    <pubDate>2025-11-28 13:05:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Paraverse平行云自研的实时云渲染产品LarkXR，是行业内应用最广泛的企业级云渲染PaaS服务平台，具备的“云-网-端-PaaS平台“属性，支持私有化/公有云部署，支持全终端覆盖。</p><p>平行云秉持开发者友好的理念，多年来持续运营开发者社区，通过引流支持、输出知识等方式，吸引了大量XR/云渲染/2D、3D引擎等相关领域的开发者提问与共享。为了更高效、更聚焦地凸显LarkXR产品性能、推广使用技巧，在已有视频教程的基础上，平行云进一步持续更新开发者社区FAQ合集栏目，助力更多开发者顺利落地实时云渲染技术。</p><p>如果你对LarkXR 还不甚熟悉，欢迎登录<strong>平行云官网开发者中心</strong>[1]下载体验，同时首推大家查阅<strong>LarkXR官方文档</strong>[2]，<strong>加入开发者社区</strong>[3]获取支持！</p><p>———  本期FAQ整理如下  ———</p><h2><strong>一、与UE像素流对比</strong></h2><p><strong>Q1：LarkXR支持像素流送2插件吗？</strong></p><p>A：LarkXR可支持像素流送1和2，也可无需集成像素流插件，实现一键推流。</p><p>很多开发者在UE程序推流的过程中，发现像素流在二次开发、业务集成上具有局限性，并且版本2与1有差异，像素流2没有直接使用WebRTC，迁移新插件需要对蓝图节点、C++公共API和功能进行更改，UE程序无法实现平滑升级。</p><p>LarkXR从底层架构完全兼容各类2D/3D开发引擎，对UE程序无要求，也可无需集成像素流插件即可实现三维场景推流，并在此基础上实现开箱即用的产品化功能，采用松耦合的方式降低风险和开发变更的工作量，UE开发者专注于3D场景开发，同时具有丰富的行业功能组件，轻松与业务系统对接。<br/><img width="723" height="378" referrerpolicy="no-referrer" src="/img/bVdnbXY" alt="" title=""/></p><p><strong>Q2：LarkXR最多能支持几个****并发</strong> <strong>？</strong></p><p>A：技术架构上并发无限制。</p><p>LarkXR基于第三代GPU池化技术，拥有多项专利、软著等知识产权，从产品架构上支持 <strong>“单机多</strong> <strong>显卡</strong> <strong>+一卡多</strong> <strong>并发</strong> <strong>+多卡大集群”</strong> 的高可用架构，只要单张卡上有资源有余量，就可以继续分配给到更多人同时使用。<br/><img width="723" height="427" referrerpolicy="no-referrer" src="/img/bVdnbXZ" alt="单卡支持至少10并发" title="单卡支持至少10并发" loading="lazy"/></p><p><img width="723" height="364" referrerpolicy="no-referrer" src="/img/bVdnbX0" alt="多卡集群部署支持大并发" title="多卡集群部署支持大并发" loading="lazy"/></p><p>UE像素流最多支持8个并发，即便服务器资源有剩余也无法继续使用。<br/><img width="723" height="414" referrerpolicy="no-referrer" src="/img/bVdnbX2" alt="" title="" loading="lazy"/></p><p><strong>Q3：使用UE像素流时，数据传输受限怎么解决？</strong></p><p>A：LarkXR可以解决传输数据字节受限问题。</p><p>像素流插件受限于WebRTC数据传输字节长度的限制，单个 <code>DataChannel</code> 消息的最大长度通常限制在64KB左右。LarkXR已引入分包发送机制，并与PaaS平台深度集成，优化了数据传输效率，真正做到UE三维应用与二维页面之间发送消息长度不设限，突破WebRTC默认的64KB限制。<br/><img width="723" height="287" referrerpolicy="no-referrer" src="/img/bVdnbX8" alt="" title="" loading="lazy"/></p><p>具体操作方式在线手册：<a href="https://link.segmentfault.com/?enc=Ylz%2FAoA%2BKO9zk0chPfkKAA%3D%3D.i7AC%2FQfZNyzTq7aUEqNdxE7cIkXimIDsoOYVeCOtiJRXhchSdFzEpiHcIsv%2FpwfT" rel="nofollow" target="_blank">https://docs.pingxingyun.com/doc/730/</a></p><h2><strong>二、软硬件环境支持</strong></h2><p><strong>Q1：LarkXR支持英伟达专业计算卡使用云渲染吗？</strong></p><p>A：<strong>LarkXR支持英伟达全系</strong> <strong>显卡</strong> <strong>，也是行业内唯一一家支持Intel显卡的服务商</strong>。就英伟达显卡而言，GeForce系列消费级显卡开箱即用，Tesla系列专业计算卡（如P40、V100、M60，T4、A10、A40、L4 等）需要安装Grid驱动和相应授权。对应更新显卡驱动、搭建授权服务等即可。<br/><img width="723" height="287" referrerpolicy="no-referrer" src="/img/bVdnbX8" alt="" title="" loading="lazy"/></p><p>具体操作方式在线手册：<a href="https://link.segmentfault.com/?enc=3cOHt1tIuMTKR0m2%2Bz7pAg%3D%3D.bPJD1crJmFEx%2FysMh%2BEcPsBjS0iI5InPoJLDn5kvnmPOZxqNjrd%2B2t2VKl2QEusa" rel="nofollow" target="_blank">https://docs.pingxingyun.com/doc/556/</a></p><p><strong>Q2：支持国产化吗？</strong></p><p>A：LarkXR支持<strong>全面国产化，支持软硬件架构信创自主可控。</strong> 已完成集成的适配情况（包括但不限于）：<br/><img width="723" height="361" referrerpolicy="no-referrer" src="/img/bVdnbYg" alt="" title="" loading="lazy"/></p><p><strong>Q3：LarkXR支持在线部署吗？</strong></p><p>A：LarkXR支持在线和离线两种部署方式，可根据服务器环境和网络情况自由选择。建议能连外网的环境选择“在线exe安装包”，内网使用选择“绿色免安装zip包”。下载地址：<br/><a href="https://link.segmentfault.com/?enc=76%2BIpzw97J8Lls9D4Grhpg%3D%3D.oL1701bo7tL%2BZEN41p%2BL%2Fjf87VI%2BvFbZhHk8QvK%2Bra25Hk3fahueFirajUoKF6Wz" rel="nofollow" target="_blank">https://www.pingxingyun.com/devCenter.html</a> 。如需要测试授权可联系我司客服获取，提供在线/离线测试授权支持。</p><p><img width="723" height="263" referrerpolicy="no-referrer" src="/img/bVdnbYk" alt="" title="" loading="lazy"/></p><h2><strong>三、常见使用问题</strong></h2><p><strong>Q1：LarkXR Turn服务与Turn服务器转发的关系</strong>？</p><p>LarkXR自带Turn服务与Turn服务器转发类似，但稍有不同，二者关系如下：</p><ol><li>功能定位关系</li></ol><ul><li><strong>内置Turn服务</strong>：LarkXR管理节点（Admin）<strong>内置Turn组件</strong>，适用于 <strong>管理节点有公网IP，渲染节点无公网IP但同属局域网</strong> <strong>的环境</strong>。通过开启管理节点的代理功能（<code>pxy.ice.server.enable=true</code>），渲染节点可通过13478 UDP端口实现服务转发。</li><li><strong>独立Turn服务器</strong>：与内置Turn功能类似，适用于<strong>内置服务无法满足需求（如端口数量限制）</strong> 时，需部署独立Coturn服务器（Linux/Windows）</li></ul><p><strong>2. 参数配置一致性</strong></p><p>两者均需在渲染节点的<code>application.properties</code>配置相同参数：</p><pre><code>pxy.ice.server.uri=   # Turn服务器地址（内置或独立）
pxy.ice.server.username= # 认证用户名（默认pxy）
pxy.ice.server.password= # 认证密码（默认Pxy12345）
</code></pre><p><strong>3. 网络要求差异</strong><br/><img width="723" height="122" referrerpolicy="no-referrer" src="/img/bVdnbYl" alt="" title="" loading="lazy"/></p><p><strong>4. 手册文档链接</strong></p><p>LarkXR TURN服务：<a href="https://link.segmentfault.com/?enc=EqMWDRjWNZLqfSn9U7n22A%3D%3D.xu%2B4VSgvmtrZwScGtPcTPD7QAaONtoHxrpaGtb7HgG8RLMyoMkeEZid4BUQOeS9J" rel="nofollow" target="_blank">https://docs.pingxingyun.com/doc/1219/</a></p><p>Turn服务器转发：<a href="https://link.segmentfault.com/?enc=MNmFqJgmb1cZcXtOB3W7wQ%3D%3D.cdTMwuReCkSvW18Yd8iPkkhY3tkFjtIO7XHcMfpPFiRMmBCjTEwt4bkfO5pmr6dm" rel="nofollow" target="_blank">https://docs.pingxingyun.com/doc/580/</a></p><p><strong>Q2：如何自定义分享链接的有效时长？</strong></p><p>加密分享应用中，有效期默认设置为15分钟。这里的有效期，具体是指根据appKey和appSecret生成的签名参数的有效期：例如您复制生成的最终公开分享URL地址，在15分钟后会自动过期，对应的页面也将无法访问；若需继续访问，通过重新计算签名参数生成新的URL地址，以此充分保障您页面的安全性。</p><p>设置了客户端凭证验证密钥，页面提示“权限不足”，表示您的访问被拒绝了。 如果想要打开页面，需要完成以下步骤：</p><ol><li>将appKey和appSecret和当前时间戳（long型数值）按字母序排序，然后进行SHA-1摘要签名,示例代码最后附上</li><li>将时间和加密后的签名分别命名为timestamp , signature</li><li>将appKey,timestamp, signature参数放入 URL 的 querystring 中。切忌不要带上appSecret，否则密钥将泄露。</li></ol><p>具体代码见博客：<a href="https://link.segmentfault.com/?enc=fqsz1OU8kceTJCdPlhrXXA%3D%3D.hosWVIGjirhkE6nPfuw%2FgzJfW86McLnNNw%2BbhzdWRiQtilVZKfXsMgynsqlAkyZzkt2qT8xQ0zwIPLHnmg0lbbKJ2RPEw1sDO4WiIsTO380%3D" rel="nofollow" target="_blank">https://www.pingxingyun.com/contribute/detail?topicId=10069&amp;c...</a></p><p><strong>Q3：LarkXR</strong> <strong>一览页面</strong> <strong>如何配置https？</strong></p><p>一览页面默认的端口号是 8181，该端口已配置为映射静态页面。为了启用 HTTPS，需要为该端口配置 SSL 证书，并修改 Nginx 配置文件 nginx/conf/conf.d/default.conf 中的 8181 端口映射。</p><p>修改内容如下：在 default.conf 文件中，为 8181端口的 server 块增加 SSL 证书文件和私钥文件的路径，以及 SSL 安全配置：</p><pre><code>server {
    listen 8181 ssl;
    server_name localhost;
  # 指定 SSL 证书文件和私钥文件的路径
    ssl_certificate /path/to/your/certificate.pem;
    ssl_certificate_key /path/to/your/private.key;
  # SSL 安全配置（可选）
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
      # 其他现有配置保持不变
    }
</code></pre><p>更多配置请参考：<a href="https://link.segmentfault.com/?enc=ue1Eh%2BaisyQ%2Brjz7s7QH5g%3D%3D.VAb1jInY4rRaX0I8cey4cmlqP37qqMXzWbcBnB1uO8ClNSJbss%2Bj4TdPM1WzF38D" rel="nofollow" target="_blank">https://docs.pingxingyun.com/doc/691/ </a></p><h2>参考资料：</h2><p>[1] 平行云开发者中心：<a href="https://link.segmentfault.com/?enc=LGA7XaV2OwXtE2Cih9Fmog%3D%3D.1mFyeLCKm9pLT5zQKLDNZ3ZO%2BcutNBq%2B4PqiFy057JGsibvDXnQpjYbyHrXxCTuJ" rel="nofollow" target="_blank">https://www.pingxingyun.com/devCenter.html</a></p><p>[2] LarkXR官方文档：<a href="https://link.segmentfault.com/?enc=s8vlyCi0IITqaBmZoewdcQ%3D%3D.ODB3WuMxZz9iDK1SA2QBL%2FEOVe66eZsHQQjgqZY5k6w%3D" rel="nofollow" target="_blank">https://docs.pingxingyun.com/</a></p><p>[3] 开发者社区：<a href="https://link.segmentfault.com/?enc=ToKnuZ5QADg5w%2BFVE%2FE03A%3D%3D.esHIy5T75mz4u2JzRfmwIADKU0u17H2zjlDsnbq2im5u9WNxqSM5MNmdc4zVSoZD" rel="nofollow" target="_blank">https://www.pingxingyun.com/community/classify</a></p><p>本文已发布于官网：<a href="https://link.segmentfault.com/?enc=nbf5WYImxXbq%2B6QbZJgM%2Fg%3D%3D.gF1ogfNYRdodQh3Y4zVoUJ1osgWZ8ibEiPrEts8CL3E%3D" rel="nofollow" target="_blank">https://www.pingxingyun.com/</a></p>]]></description></item><item>    <title><![CDATA[百度地图JSAPI THREE实现平滑的]]></title>    <link>https://segmentfault.com/a/1190000047434238</link>    <guid>https://segmentfault.com/a/1190000047434238</guid>    <pubDate>2025-11-28 13:04:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>百度地图JSAPI THREE实现平滑的地图视角切换</h2><p>在地图可视化应用中，平滑的视角切换能够显著提升用户体验。百度地图JSAPI THREE(又称MapvTHREE) 提供了 <code>flyTo</code> 方法，可以实现从当前视角到目标位置的平滑过渡动画。本文将详细介绍 <code>flyTo</code> 方法的使用方法，帮助你掌握地图相机动画的控制技巧。</p><h3>一、flyTo 方法概述</h3><p><code>flyTo</code> 是 MapVThree 引擎中用于实现平滑相机动画的核心方法。与直接设置相机位置不同，<code>flyTo</code> 会在当前视角和目标视角之间创建平滑的过渡动画，让用户感受到自然的视角切换效果。</p><p>在这一点上，<code>flyTo</code> 方法特别适合以下场景：</p><ul><li>从地图概览切换到具体位置</li><li>响应点击事件，聚焦到特定对象</li><li>实现地图导览功能</li><li>创建动态演示效果</li></ul><h3>二、基本用法</h3><h4>2.1 最简单的调用方式</h4><p><code>flyTo</code> 方法的基本语法如下：</p><pre><code class="js">engine.map.flyTo(targetPosition, options);</code></pre><p>其中 <code>targetPosition</code> 是目标位置，可以是三维坐标数组或 THREE.Vector3 对象。<code>options</code> 是配置对象，用于控制动画参数。</p><pre><code class="js">// 创建引擎实例
const engine = new mapvthree.Engine(container);

// 定义目标位置（经纬度坐标）
const targetPosition = [116.414, 39.915, 100];

// 执行 flyTo 动画
engine.map.flyTo(targetPosition, {
    pitch: 70,
    heading: 60,
    range: 1000,
});</code></pre><p>这里，我们指定了目标位置的经纬度坐标，并配置了相机的俯仰角、方位角和距离。MapVThree 会自动计算从当前视角到目标视角的平滑过渡路径。</p><h4>2.2 使用世界坐标</h4><p>除了经纬度坐标，<code>flyTo</code> 也支持使用世界坐标系中的位置。这在需要聚焦到场景中的 3D 对象时特别有用。</p><pre><code class="js">// 获取 3D 对象的世界坐标位置
const objectPosition = object.position; // THREE.Vector3

// 使用世界坐标执行 flyTo
engine.map.flyTo(objectPosition, {
    pitch: 70,
    heading: 60,
    roll: 0,
    range: 1000,
});</code></pre><p>通过使用世界坐标，我们可以直接聚焦到场景中的任意 3D 对象，无需进行坐标转换。</p><h3>三、参数详解</h3><p><code>flyTo</code> 方法的配置对象支持多个参数，每个参数都控制着动画的不同方面。</p><h4>3.1 相机姿态参数</h4><p><strong>pitch（俯仰角）</strong></p><ul><li>类型：<code>number</code></li><li>单位：度</li><li>说明：控制相机向下看的角度，0 度表示水平，90 度表示垂直向下</li></ul><pre><code class="js">engine.map.flyTo(targetPosition, {
    pitch: 70, // 70 度俯仰角，接近垂直向下
});</code></pre><p><strong>heading（方位角）</strong></p><ul><li>类型：<code>number</code></li><li>单位：度</li><li>说明：控制相机的水平旋转角度，0 度表示正北方向</li></ul><pre><code class="js">engine.map.flyTo(targetPosition, {
    heading: 60, // 60 度方位角
});</code></pre><h4>3.2 距离参数</h4><p><strong>range（距离）</strong></p><ul><li>类型：<code>number</code></li><li>单位：米</li><li>说明：相机到目标位置的距离，控制缩放级别</li></ul><pre><code class="js">engine.map.flyTo(targetPosition, {
    range: 1000, // 距离目标 1000 米
});</code></pre><p>较小的 <code>range</code> 值会产生更近的视角，相当于放大；较大的值会产生更远的视角，相当于缩小。</p><h4>3.3 动画回调</h4><p><strong>complete（完成回调）</strong></p><ul><li>类型：<code>function</code></li><li>说明：动画完成时执行的回调函数</li></ul><pre><code class="js">engine.map.flyTo(targetPosition, {
    pitch: 70,
    heading: 60,
    range: 1000,
    complete: () =&gt; {
        console.log('flyTo 动画完成');
        // 可以在这里执行后续操作，例如显示信息面板
    },
});</code></pre><p>通过 <code>complete</code> 回调，我们可以在动画结束后执行特定的操作，例如加载数据、显示 UI 元素等。</p><h3>四、实际应用场景</h3><h4>4.1 响应点击事件</h4><p>在交互式地图应用中，用户点击某个位置或对象时，可以使用 <code>flyTo</code> 平滑地聚焦到该位置。</p><pre><code class="js">// 监听地图点击事件
engine.event.bind('click', (event) =&gt; {
    const clickedPosition = event.position;
    
    // 平滑飞行到点击位置
    engine.map.flyTo(clickedPosition, {
        pitch: 50,
        range: 500,
        complete: () =&gt; {
            // 显示该位置的详细信息
            showLocationInfo(clickedPosition);
        },
    });
});</code></pre><h4>4.2 聚焦到 3D 对象</h4><p>当场景中存在 3D 模型或对象时，可以使用 <code>flyTo</code> 聚焦到这些对象。</p><pre><code class="js">// 假设有一个 3D 球体对象
const sphere = new THREE.Mesh(
    new THREE.SphereGeometry(10, 32, 32),
    new THREE.MeshStandardMaterial({ color: 0xffffff })
);
engine.add(sphere);

// 点击按钮时聚焦到球体
function focusOnSphere() {
    engine.map.flyTo(sphere.position, {
        pitch: 70,
        heading: 60,
        roll: 0,
        range: 1000,
        complete: () =&gt; {
            console.log('已聚焦到球体');
        },
    });
}</code></pre><h4>4.3 创建导览功能</h4><p><code>flyTo</code> 方法非常适合创建地图导览功能，可以按照预设的路径依次展示多个位置。</p><pre><code class="js">const tourPoints = [
    { position: [116.414, 39.915], pitch: 50, range: 2000 },
    { position: [116.424, 39.925], pitch: 60, range: 1500 },
    { position: [116.434, 39.935], pitch: 70, range: 1000 },
];

let currentIndex = 0;

function startTour() {
    if (currentIndex &gt;= tourPoints.length) {
        currentIndex = 0; // 循环播放
    }
    
    const point = tourPoints[currentIndex];
    engine.map.flyTo(point.position, {
        pitch: point.pitch,
        range: point.range,
        complete: () =&gt; {
            currentIndex++;
            // 延迟后继续下一个点
            setTimeout(startTour, 2000);
        },
    });
}</code></pre><h3>五、与 lookAt 方法的对比</h3><p>MapVThree 还提供了 <code>lookAt</code> 方法，它也能设置相机视角，但不会产生动画效果。</p><pre><code class="js">// lookAt：立即切换视角，无动画
engine.map.lookAt(targetPosition, {
    pitch: 70,
    heading: 60,
    range: 1000,
});

// flyTo：平滑过渡到目标视角
engine.map.flyTo(targetPosition, {
    pitch: 70,
    heading: 60,
    range: 1000,
});</code></pre><p><strong>选择建议：</strong></p><ul><li>需要平滑动画效果时，使用 <code>flyTo</code></li><li>需要立即切换视角时，使用 <code>lookAt</code></li><li>在用户交互场景中，优先使用 <code>flyTo</code> 提升体验</li><li>在程序化控制场景中，可以使用 <code>lookAt</code> 提高响应速度</li></ul><h3>六、总结</h3><p><code>flyTo</code> 方法是 MapVThree 中实现平滑地图视角切换的核心工具。通过合理配置参数，我们可以创建流畅、自然的相机动画效果，显著提升用户体验。</p><p>在实际开发中，建议：</p><ol><li>根据场景需求选择合适的视角参数（pitch、heading、range）</li><li>利用 <code>complete</code> 回调处理动画完成后的逻辑</li><li>在用户交互场景中优先使用 <code>flyTo</code> 而非 <code>lookAt</code></li><li>注意处理动画中断和状态管理</li></ol><p>掌握 <code>flyTo</code> 方法的使用，能够让你的地图应用更加生动和易用。希望本文能帮助你快速上手并灵活运用这一功能。</p>]]></description></item><item>    <title><![CDATA[HCL AppScan Standard]]></title>    <link>https://segmentfault.com/a/1190000047434490</link>    <guid>https://segmentfault.com/a/1190000047434490</guid>    <pubDate>2025-11-28 13:03:06</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>HCL AppScan Standard 10.10 发布，新增功能简介</p><p>HCL AppScan Standard 10 (Windows) - Web 应用程序安全测试</p><p>HCL AppScan Standard v10 for Windows Multilingual</p><p>请访问原文链接：<a href="https://link.segmentfault.com/?enc=o2cXRLvHcBYKHapze8DNqg%3D%3D.jbBrbrigBeq6pkDFybQivdOrrvF%2BP7qZ9OdX7uncJuRgk9gFfNGVikrH0NYXMqhj" rel="nofollow" target="_blank">https://sysin.org/blog/appscan-10/</a> 查看最新版。原创作品，转载请保留出处。</p><p>作者主页：<a href="https://link.segmentfault.com/?enc=R1t%2FYB%2F379W1qXQRH0Mw8Q%3D%3D.cKIctlhmUg2oNup%2B0kvEss1UORX%2FqKG3pq5NGMXJUXM%3D" rel="nofollow" target="_blank">sysin.org</a></p><hr/><p>市场领先的应用程序安全解决方案（SAST、DAST、IAST、SCA、API）</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044800640" alt="HCL AppScan" title="HCL AppScan"/></p><h2>市场领先的应用程序安全解决方案</h2><p>HCL AppScan 为开发人员、DevOps 和安全团队提供了一套技术来查明应用程序漏洞，以便在软件开发生命周期的每个阶段进行快速修复。</p><p>通过使用一流的测试工具、集中的可见性和监督以及多种部署选项（包括本地、云端和云原生）来保护您的应用程序，从而保护您的业务和客户。</p><p>解决方案</p><p>Dynamic Analysis 动态分析（DAST）</p><ul><li>在应用程序运行时测试应用程序和 API 是否存在潜在漏洞。</li></ul><p>Static Analysis 静态分析（SAST）</p><ul><li>在开发过程的早期分析应用程序和 API 中的源代码是否存在潜在漏洞。</li></ul><p>Interactive Analysis 交互式分析（IAST）</p><ul><li>监控应用程序和 API，以帮助查找和修复漏洞 (sysin)，而不会减慢开发速度。</li></ul><p>Software Composition Analysis 软件成分分析（SCA）</p><ul><li>识别开源软件组件引入的漏洞。</li></ul><p>ESG 技术评论：使用 HCL AppScan 实现持续的应用程序安全</p><p>“AppScan 通过直接集成到软件开发生命周期来支持 DevSecOps，包括在自动化构建和部署管道期间的内联执行，以及集成开发环境中的反馈和补救” —— Jack Poller，ESG 高级分析师</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000044800641" alt="sysin" title="sysin" loading="lazy"/></p><h2>新增功能</h2><p><strong>HCL AppScan Standard 10.10.0 中的新增功能</strong>：</p><p>2025 年 11 月</p><ul><li><strong>DAST LLM 扫描程序</strong>：<strong>在攻击者利用 LLM 的弱点之前，先将其暴露出来！</strong>使用 AppScan 动态应用程序安全性 (DAST) 保护您的大语言模型 (LLM)，该工具专门设计用于识别关键漏洞，如敏感信息泄露、提示注入、错误信息等。</li><li><strong>定制脚本</strong>：编辑器增强功能包括改进的自动完成功能 (sysin)。这些增强功能提供了额外的 JavaScript 方法和类型，以及更多的激活触发器，例如开始一个新单词或输入句点（“.”）。</li><li><strong>多步骤</strong>增强功能：用户界面经过了重新设计，以提供更出色的用户体验。新增了故障诊断选项，可查看回放的请求（原始数据和浏览器）并比较录制的请求与回放的请求，这些选项仅在序列验证后可用。</li><li><p>合规性报告</p><ul><li><p>新增报告：</p><ul><li>2025 年 LLM 应用 OWASP 前 10 大漏洞</li><li>[加拿大] - ITSG-33 行业标准报告</li></ul></li><li><p>更新报告：</p><ul><li>国际标准 - ISO 27001:2022</li><li>国际标准 - ISO 27002:2022</li><li>支付卡行业数据安全标准 (PCI DSS) - V4.0.1</li><li>NIST 特刊 800-53 - 5.2.0</li><li>[EU] Regulation 2016/679 Of The European Parliament And Of The Council (GDPR)</li><li>[US] Healthcare Services (HIPAA)</li></ul></li><li>合规性报告现在包括修复建议详细信息。</li></ul></li><li><strong>屏蔽</strong>改进：增强了 AppScan 的屏蔽功能，可更一致地保护敏感信息。</li><li><strong>自动登录</strong>改进：AppScan 现在可以更可靠地遍历 Angular 应用程序 (sysin)，修复罕见的登录录制错误，并在播放失败后的第二次尝试操作之间增加延迟，从而提高总体成功率。</li><li>改进了对使用 AngularJS 框架的单页应用程序 (SPA) 扫描的支持。</li></ul><p><strong>修复和安全更新</strong>：</p><p>此发行版中的新安全规则包括：</p><ul><li>COOP - Cross-Origin-Opener-Policy (COOP) 标头缺失或不安全</li><li>CORP - Cross-Origin-Resource-Policy (CORP) 标头缺失或不安全</li><li>COEP - Cross-Origin-Embedder-Policy (COEP) 标头缺失或不安全</li><li>attCSPAPI - CSP（适用于 API 端点）中的“frame-ancestors”指令标头缺失或不安全</li><li>attApacheOFBizRCECVE202445195 - Apache OFBiz RCE for CVE-2024-45195</li><li>attApacheOFBizRCECVE202445507 - Apache OFBiz RCE for CVE-2024-45507</li><li>attSpringFrameworkPathTraversalCVE202438816 - Spring Framework 路径遍历 CVE-2024-38816 和 CVE-2024-38819</li><li>attWordpressPiePluginAuthenticationBypassCVE202534077 - Wordpress Pie Register 身份验证不充分 CVE-2025-34077</li><li>attWordPressKubioPathTraversalCVE20252294 - Wordpress Kubio AI Page Builder 插件路径遍历 CVE-2025-2294</li><li>易受攻击的组件数据库已更新到版本 1.8</li></ul><p><strong>已在此发行版中更改</strong>：</p><ul><li>AI 配置已从“测试选项”移至“工具”&gt;“选项”&gt;“AI 设置”。</li><li><p>为了提高安全性，将移除以下配置：</p><ul><li><p>高级扫描配置</p><ul><li>审查日志</li><li>审查报告</li><li>加密敏感数据</li></ul></li><li><p>工具选项</p><ul><li>EncryptPdfReportData</li></ul></li></ul></li><li>使用外部浏览器录制登录和多步骤操作现在支持基于操作的录制。</li><li>AppScan Connect：现在，ASoC 用户可以将问题与扫描文件一起发布到 ASoC，这有助于重新扫描而不是创建新扫描，从而节省时间和资源 (sysin)。</li><li>URL 限制从 1024 个字符更改为 4096 个字符。</li><li>Web API 向导 (OpenAPI) 扩展已移除。</li><li>AppScan Standard V10.6.0 和更低版本将在 2025 年 6 月 30 日终止支持 (EOS)。这些版本的文档不再在公共文档网站上提供。</li><li>对 Microsoft® Windows® 10 的支持已终止。</li><li>Windows 2025 支持。</li></ul><p><strong>即将推出的变更</strong>：</p><ul><li>报告组件将仅在产品级别 (UI/AppScanCMD) 提供，不适用于 SDK 级别。</li></ul><h2>下载地址</h2><p>HCL AppScan Standard v10 Multilingual for Windows</p><p>请访问：<a href="https://link.segmentfault.com/?enc=KKIpweuEZYCK%2FdfyFoWj5g%3D%3D.DOAaRBSA8%2BPgobW9wS%2Br6XVCTiuGarVddx870slY07Wv8h49wANQq9g7%2F1JMBwhW" rel="nofollow" target="_blank">https://sysin.org/blog/appscan-10/</a></p><p>更多：<a href="https://link.segmentfault.com/?enc=B0WhNphI2m4Js%2Bf2DiWc4Q%3D%3D.6YnhHI%2BQWPGrKqpTeRHxfb3ji%2BX%2BcsgH9afQjb6JoV4%3D" rel="nofollow" target="_blank">HTTP 协议与安全</a></p>]]></description></item><item>    <title><![CDATA[ZeroNews IP 访问控制能力 Z]]></title>    <link>https://segmentfault.com/a/1190000047434495</link>    <guid>https://segmentfault.com/a/1190000047434495</guid>    <pubDate>2025-11-28 13:02:11</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在信息安全领域，IP白名单和黑名单作为最常用的两种安全策略，用于控制访问权限，限制应用的访问来源目标，以防范潜在威胁。虽然很多人对这两个词并不陌生，但未必清楚它们的具体含义和工作原理。下面我们就来具体了解一下它们的定义与应用。</p><h3>什么是 IP 黑白名单？</h3><p>IP 白名单：默认拒绝，只允许名单内的 IP 访问，其他全部拒绝，将应用的访问权限限制在选定的已批准 IP 地址列表内，从而在您的端点周围创建一个安全边界。</p><p>IP 黑名单：默认允许，只阻止列表内的 IP 访问，其他全部放行，它通过阻止特定IP地址访问已知恶意来源的服务器来达到目的。它与白名单机制协同工作，在威胁出现时及时进行防范。</p><h3>HTTP IP 访问控制面临的问题</h3><p>众所周知，典型的HTTP请求从客户端到目标服务器，会经过多个网络跃点（如代理服务器、负载均衡器）。</p><p>在此过程中，由于会经过多个网络服务节点，如代理服务器和负载均衡器，请求的原始 IP 地址在不断转发的过程中可能存在不断变更。这是因为某些跃点会终止 TCP 连接，并与下一跃点建立新的 TCP 连接，导致接收服务器可能看到请求访问IP是与其直接连接的跃点的 IP 地址，而不是原始请求访问端 IP 地址，这将导致针对HTTP的安全访问变的很难控制。</p><p>因此获取访问端的真实IP对应用数据安全显得至关重要，它能帮忙企业、用户精准识别用户访问源IP，控制应用资源访问的访问权限，同时准确识别恶意访问行为，从而有效阻止与滥用行为、黑客攻击或拒绝服务攻击相关的特定 IP 地址。</p><h3>X-Forwarded-For HTTP 标头</h3><p>X-Forwarded-For 是什么？</p><p>X-Forwarded-For (XFF) 标头是事实上的 HTTP 标准标头。用于识别通过多个代理或负载均衡器连接到后端服务器的客户端源IP地址。</p><p>当 HTTP 请求经过代理或负载均衡器时，该跃点可以添加或更新 X-Forwarded-For 标头，其中包含客户端的 IP 地址。这确保了原始客户端的 IP 地址得以保留。</p><pre><code>X-Forwarded-For: client, proxy1, proxy2, …</code></pre><h3>ZeroNews IP访问控制是怎么实现的？</h3><p>正上面所提到的，ZeroNews的边缘节点通过对每一条映射的每一个请求进行深度识别分析，解析 X-Forwarded-For标头及L4 TCP/UDP 报头，准确识别客户端的原始IP地址，从而实现精确的访问控制，这是实现精准IP访问控制的基石。</p><p>ZeroNews 实现HTTPS 、TCP映射级别的IP访问控制能力，用户可以针对指定映射进行配置管理，企业、用户可根据应用安全需求，差异化的定义安全策略，如：</p><p>对高安全应用采用白名单模式，精确控制允许访问的IP</p><p>对于公开应用采用黑名单模式，拒绝异常IP源，能有效阻断威胁功能，</p><p>ZeroNews采用CIDR子网地址块的模式定义IP地址列表，用户可以输入精确IP或子网网段。</p><h3>简化配置操作</h3><p>IP访问控制的配置完全在 ZeroNews 的管理控制台中通过图形界面完成，过程非常直观，主要分为以下两步：</p><p>创建IP地址列表（IP集合）：首先，在控制台的“设置”或“安全”菜单下找到“IP集合管理”功能。在此处，您可以创建一个IP集合，并为它命名（例如“公司办公网络”或“已知恶意IP”），然后将需要管理的IP地址或网段填入这个集合。<br/>为映射服务访问规则：接着，进入您需要保护的特定映射服务（如网站、SSH、数据库等）的，找到“IP访问控制”。在这里，您可以选择生效模式（白名单或黑名单），然后直接关联上一步创建好的IP集合即可。具体可以参考操作官方文档。<br/>在什么情况下，要开启 ZeroNews IP访问控制呢？<br/>白名单适用场景</p><h3>适用于需要严格控制访问权限的场景</h3><p>内部企业 API：用于企业网络或 VPN 访问内部系统。</p><p>开发和测试：在 API 开发阶段限制访问权限。</p><p>高安全性应用程序：非常适合管理敏感数据（例如财务或医疗保健信息）的 API。</p><p>远程连接： SSH 远程连接、RDP远程桌面，能有效避免勒索病毒、暴力破解等威胁孤男寡女</p><p>黑名单适用场景</p><p>适用于既需要更广泛访问权限又需要缓解威胁的场景</p><p>面向公众的 API：适用于需要开放访问并具备抵御威胁保护功能的 API。</p><p>高流量服务：能够有效处理来自各种来源的大量请求。</p><p>DDoS防护：可快速拦截攻击流量源。</p><p><img width="608" height="250" referrerpolicy="no-referrer" src="/img/bVdnb2C" alt="" title=""/></p><h3>最后</h3><p>总结来说，IP白名单和黑名单虽然有所区别，但两者最终目的都是维护网络资源的安全性，减少恶意攻击对网络资源的损害。在实际运用中，两者通常是结合使用，来应对日益复杂多变的网络威胁。</p><p>当然，ZeroNews 对于安全方面的也提供了多种安全策略。例如鉴权认证，TLS终止（端到端加密传输），如需了解更多相关资讯，可以关注我们的官方媒体。</p>]]></description></item><item>    <title><![CDATA[1panel的ssl证书路径排查配置总结]]></title>    <link>https://segmentfault.com/a/1190000047434524</link>    <guid>https://segmentfault.com/a/1190000047434524</guid>    <pubDate>2025-11-28 13:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、问题背景</h2><p>初始需求：只能通过阿里云的workbench远程连接，需求是替换网站SSL证书。其他信息均无。奔着两眼一抹黑的精神大海落枕一把。本想着找到nginx直接看配置文件，然后替换路径就ok。但是发现这个用户下有两个ecs，做了转发？docker端口映射？只猜对了一半。。。。</p><h2>二、排查阶段与核心步骤</h2><h3>阶段1：定位80端口监听进程——排除宿主机标准Nginx</h3><h4>1.1 发现端口监听但无法找到Nginx命令</h4><p><code>netstat -anp</code>显示80/443端口被<code>nginx: master process</code>监听，却无法通过常规命令找到宿主机Nginx安装路径。。</p><ul><li><strong>现象</strong>：执行<code>netstat -anp|grep 80</code>，显示<code>0.0.0.0:80 LISTEN 29071/nginx: master</code>，但执行<code>which nginx</code>/<code>whereis nginx</code>均提示“无此命令”，<code>nginx -t</code>报错“command not found”。</li><li><strong>排除法</strong>：排除宿主机通过<code>yum</code>/<code>apt</code>安装的标准Nginx（此类安装会将<code>nginx</code>命令加入<code>PATH</code>），怀疑是：①源码编译的Nginx/OpenResty；②Docker容器内的服务；③面板管理的非标准路径服务。</li><li><p><strong>核心命令</strong>：</p><pre><code class="bash"># 查看端口监听进程
netstat -antp|grep 80  # 或 ss -tulpn|grep 80
# 排查Nginx命令是否存在
which nginx
whereis nginx
nginx -t  # 验证命令可用性</code></pre></li></ul><h3>阶段2：追溯进程本质——发现OpenResty与Docker容器关联</h3><h4>2.1 查看进程详情，定位服务类型</h4><ul><li><p><strong>操作</strong>：执行<code>ps -ef | grep nginx</code>，发现进程实际启动命令为：</p><pre><code>root 29071 29051 0 2024 ? 00:00:00 nginx: master process /usr/local/openresty/bin/openresty -g daemon off;</code></pre></li><li><strong>结论</strong>：监听80/443的“Nginx”实际是<strong>OpenResty</strong>（基于Nginx的扩展服务），但<code>/usr/local/openresty/bin/openresty</code>路径不存在，进一步怀疑是Docker容器内的服务。</li></ul><h4>2.2 验证Docker容器，确认服务归属</h4><ul><li><strong>操作</strong>：执行<code>docker ps</code>，发现容器<code>1Panel-openresty-2jEd</code>（1Panel前缀表明由面板管理），且执行<code>ps -ef | grep openresty</code>时出现<code>docker exec -it 1Panel-openresty-2jEd /bin/bash</code>（曾进入过该容器）。</li><li><strong>结论</strong>：OpenResty运行在<code>1Panel-openresty-2jEd</code>容器内，而非宿主机直接安装。</li><li><p><strong>核心命令</strong>：</p><pre><code class="bash"># 查看进程完整启动命令
ps -ef | grep nginx
ps -ef | grep openresty
# 查看运行中的Docker容器
docker ps</code></pre></li></ul><h3>阶段3：解析容器配置——Host网络与宿主机挂载点</h3><h4>3.1 找到Docker Compose配置文件，明确网络与挂载规则</h4><ul><li><p><strong>操作</strong>：通过<code>find / -name "docker-compose.yml" | grep openresty</code>定位到配置文件路径<code>/opt/1panel/apps/openresty/openresty/docker-compose.yml</code>，关键配置如下：</p><pre><code class="yaml">services:
  openresty:
    container_name: ${CONTAINER_NAME}
    network_mode: host  # 容器使用宿主机网络（直接监听宿主机80/443）
    volumes:
      - ./conf/conf.d:/usr/local/openresty/nginx/conf/conf.d/  # 宿主机配置目录挂载到容器
      - ./www:/www  # 宿主机网站目录挂载到容器</code></pre></li><li><p><strong>核心结论</strong>：</p><ol><li><code>network_mode: host</code>：容器无需端口映射，直接使用宿主机80/443端口，因此<code>netstat</code>显示宿主机进程监听。</li><li><code>volumes</code>挂载：宿主机<code>/opt/1panel/apps/openresty/openresty/conf/conf.d</code>对应容器内Nginx站点配置目录，<code>./www</code>对应容器内网站/证书目录（解决“证书路径在宿主机找不到”问题）。</li></ol></li></ul><h4>3.2 定位SSL证书配置与挂载路径</h4><ul><li><p><strong>操作</strong>：查看宿主机挂载的配置文件<code>/opt/1panel/apps/openresty/openresty/conf/conf.d/47.***.232.conf</code>，发现证书路径：</p><pre><code class="nginx">ssl_certificate /www/sites/47.***.232/ssl/fullchain.pem;
ssl_certificate_key /www/sites/47.***.232/ssl/privkey.pem;</code></pre></li><li><strong>路径转换</strong>：因<code>./www</code>挂载到容器<code>/www</code>，宿主机实际证书路径为<code>/opt/1panel/apps/openresty/openresty/www/sites/47.***.232/ssl/</code>（无需进入容器即可替换证书）。</li><li><p><strong>核心命令</strong>：</p><pre><code class="bash"># 搜索Docker Compose配置文件
find / -name "docker-compose.yml" | grep openresty 2&gt;/dev/null
# 查看站点配置文件
cat /opt/1panel/apps/openresty/openresty/conf/conf.d/47.***.232.conf
# 确认宿主机挂载的证书目录
ls -la /opt/1panel/apps/openresty/openresty/www/sites/47.***.232/ssl/</code></pre></li></ul><h3>阶段4：定位1Panel面板配置——登录地址与密码重置</h3><h4>4.1 确定1Panel进程与监听端口</h4><ul><li><p><strong>如何确认是1Panel？</strong></p><ol><li>目录特征：服务器存在<code>/opt/1panel</code>目录（1Panel默认安装路径，包含<code>apps</code>/<code>conf</code>/<code>bin</code>等子目录，对应面板管理的应用、配置、命令工具）。</li><li>进程特征：执行<code>ps -ef | grep 1panel</code>，显示1Panel主进程（如<code>/opt/1panel/bin/1panel</code>）。</li><li>专用命令：执行<code>1pctl user-info</code>（1Panel专属命令，直接输出面板信息，非系统或其他面板命令）。</li></ol></li><li><p><strong>操作</strong>：</p><ol><li>执行<code>ps -ef | grep 1panel</code>，找到1Panel主进程PID（如<code>1234</code>）。</li><li>执行<code>ss -tulpn | grep 1234</code>，显示监听端口（如<code>*:12826</code>）。</li><li>执行<code>1pctl user-info</code>，直接获取面板地址：<code>http://服务器IP:12826/81f848ba8f</code>，用户名：<code>d67c5a2cea</code>。</li></ol></li></ul><h4>4.2 重置1Panel密码</h4><ul><li><strong>现象</strong>：<code>1pctl user-info</code>显示密码为<code>********</code>（加密隐藏，无法直接查看）。</li><li><p><strong>操作</strong>：执行1Panel专用重置命令：</p><pre><code class="bash"># 进入1Panel安装目录
cd /opt/1panel
# 重置密码（输出随机新密码）
./bin/1panel-cli reset-password</code></pre></li><li><strong>后续</strong>：用新密码登录面板后，在“个人设置”中修改为自定义密码。</li><li><p><strong>核心命令</strong>：</p><pre><code class="bash"># 查看1Panel进程
ps -ef | grep 1panel
# 查看1Panel监听端口
ss -tulpn | grep &lt;1Panel进程PID&gt;
# 查看1Panel面板信息
1pctl user-info
# 重置1Panel密码
/opt/1panel/bin/1panel-cli reset-password</code></pre></li></ul><h2>三、关键难点与解决思路</h2><table><thead><tr><th>难点</th><th>解决思路</th><th>排除法应用</th></tr></thead><tbody><tr><td>1. 有Nginx进程但无<code>nginx</code>命令</td><td>从进程启动命令追溯服务类型（`ps -ef</td><td>grep nginx`发现是OpenResty），再排查OpenResty部署方式（Docker/源码）</td><td>排除宿主机标准Nginx（<code>which</code>无结果），排除源码编译（<code>find / -name openresty</code>发现Docker路径）</td></tr><tr><td>2. OpenResty在容器内但监听宿主机端口</td><td>查看Docker Compose的<code>network_mode</code>配置，确认<code>host</code>模式（容器直接使用宿主机网络）</td><td>排除端口映射模式（<code>docker ps</code>无<code>0.0.0.0:80-&gt;80/tcp</code>映射），确认<code>host</code>模式后无需找端口映射关系</td></tr><tr><td>3. 证书路径在配置中存在但宿主机找不到</td><td>查看Docker Compose的<code>volumes</code>挂载，找到宿主机挂载目录（<code>./www</code>对应容器<code>/www</code>）</td><td>排除容器内独立目录（无需进入容器，直接操作宿主机挂载目录即可）</td></tr><tr><td>4. 找不到1Panel登录地址</td><td>利用1Panel目录特征（<code>/opt/1panel</code>）、进程特征（`ps -ef</td><td>grep 1panel<code>）、专用命令（</code>1pctl user-info`）</td><td>排除其他面板（无<code>bt</code>/<code>aaPanel</code>等命令，目录无对应面板特征）</td></tr></tbody></table><h2>四、核心定位方法总结</h2><ol><li><strong>端口→进程→服务类型</strong>：从<code>netstat/ss</code>查端口监听进程，再用<code>ps -ef</code>查进程启动命令，确定服务是Nginx/OpenResty。</li><li><strong>进程→部署方式</strong>：通过进程路径（如<code>/usr/local/openresty/bin/openresty</code>）结合<code>find</code>/<code>docker ps</code>，确定是宿主机/容器部署。</li><li><strong>容器→配置解析</strong>：找到Docker Compose文件，分析<code>network_mode</code>（网络）和<code>volumes</code>（挂载），明确宿主机与容器的文件/网络关联。</li><li><strong>面板→专属工具</strong>：利用1Panel专用命令（<code>1pctl</code>）和默认安装目录（<code>/opt/1panel</code>），快速定位面板信息，避免全局搜索浪费时间。</li></ol><h2>五、Linux核心命令清单（按用途分类）</h2><h3>1. 端口与进程查询</h3><table><thead><tr><th>命令</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>netstat -antp</code></td><td>查看所有TCP端口监听及对应进程</td><td>`netstat -antp</td><td>grep 80`（查80端口进程）</td></tr><tr><td><code>ss -tulpn</code></td><td>查看所有监听端口及进程（比<code>netstat</code>更高效）</td><td>`ss -tulpn</td><td>grep 443`（查443端口进程）</td></tr><tr><td>`ps -ef</td><td>grep &lt;关键词&gt;`</td><td>查看包含关键词的进程详情</td><td>`ps -ef</td><td>grep nginx`（查Nginx相关进程）</td></tr><tr><td><code>lsof -p &lt;PID&gt;</code></td><td>查看进程打开的文件（需安装<code>lsof</code>）</td><td>`lsof -p 29071</td><td>grep .conf`（查进程打开的配置文件）</td></tr></tbody></table><h3>2. 文件与路径搜索</h3><table><thead><tr><th>命令</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>find / -name &lt;文件名&gt; 2&gt;/dev/null</code></td><td>全局搜索文件，忽略权限错误</td><td>`find / -name "docker-compose.yml"</td><td>grep openresty`</td></tr><tr><td><code>grep -r -i &lt;关键词&gt; &lt;目录&gt;</code></td><td>递归搜索目录下包含关键词的文件</td><td><code>grep -r -i "d***tong" /opt/1panel/apps/openresty</code></td></tr><tr><td><code>ls -la</code></td><td>查看目录下所有文件（含隐藏文件如<code>.env</code>）</td><td><code>ls -la /opt/1panel/apps/openresty/openresty</code>（查<code>.env</code>文件）</td></tr><tr><td><code>cat &lt;文件路径&gt;</code></td><td>查看文件内容</td><td><code>cat /opt/1panel/conf/1panel.conf</code>（查1Panel配置）</td></tr></tbody></table><h3>3. Docker操作</h3><table><thead><tr><th>命令</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>docker ps</code></td><td>查看运行中的容器</td><td>`docker ps</td><td>grep openresty`（查OpenResty容器）</td></tr><tr><td><code>docker exec -it &lt;容器名&gt; /bin/bash</code></td><td>进入容器交互终端</td><td><code>docker exec -it 1Panel-openresty-2jEd /bin/bash</code></td></tr><tr><td><code>docker restart &lt;容器名&gt;</code></td><td>重启容器</td><td><code>docker restart 1Panel-openresty-2jEd</code>（重启OpenResty）</td></tr><tr><td><code>cat &lt;docker-compose.yml路径&gt;</code></td><td>查看容器配置（网络、挂载）</td><td><code>cat /opt/1panel/apps/openresty/openresty/docker-compose.yml</code></td></tr></tbody></table><h3>4. 1Panel专用命令</h3><table><thead><tr><th>命令</th><th>用途</th><th>示例</th></tr></thead><tbody><tr><td><code>1pctl user-info</code></td><td>查看1Panel面板地址、用户名</td><td><code>1pctl user-info</code></td></tr><tr><td><code>/opt/1panel/bin/1panel-cli reset-password</code></td><td>重置1Panel密码</td><td><code>/opt/1panel/bin/1panel-cli reset-password</code></td></tr></tbody></table><h2>六、最终操作流程（SSL证书替换）</h2><ol><li><strong>替换证书</strong>：将新证书<code>fullchain.pem</code>/<code>privkey.pem</code>上传到宿主机路径<code>/opt/1panel/apps/openresty/openresty/www/sites/47.***.232/ssl/</code>。</li><li><strong>重启服务</strong>：执行<code>docker restart 1Panel-openresty-2jEd</code>（或在1Panel面板“应用管理”重启OpenResty）。</li><li><strong>验证</strong>：浏览器访问<code>https://wxapp.d***tong.cn</code>，查看证书是否更新；或执行<code>openssl s_client -connect 47.***.232:443 -servername wxapp.d***tong.cn</code>验证证书信息。</li></ol><h2><img width="723" height="233" referrerpolicy="no-referrer" src="/img/bVdnb22" alt="image.png" title="image.png"/></h2>]]></description></item><item>    <title><![CDATA[制造业新品研发项目管理软件排名?17款系]]></title>    <link>https://segmentfault.com/a/1190000047434209</link>    <guid>https://segmentfault.com/a/1190000047434209</guid>    <pubDate>2025-11-28 12:10:51</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>在智能制造与全球供应链重构的双重驱动下，制造业新品研发已从“线性流程”转向“敏捷迭代+生态协同”模式。CIO与IT决策者面临的核心矛盾在于：<strong>如何在保障数据安全与合规的前提下，实现跨部门、跨企业的试产协同与供应链弹性适配</strong>。当前市场既有功能庞杂的公有云巨头，也有深耕垂直场景的私有化工具，选择困境日益凸显。本文将以<strong>“评估框架先行、客观对标产品、聚焦决策价值”</strong>为核心，为制造业企业提供一份中立、深度的选型指南。</blockquote><hr/><h3><strong>一、建立标准：制造业研发项目管理的6大评估维度</strong></h3><p>为确保对比的公正性与实用性，我们从制造业核心需求出发，构建以下评估体系：</p><table><thead><tr><th><strong>维度</strong></th><th><strong>定义</strong></th><th><strong>制造业关注重点</strong></th></tr></thead><tbody><tr><td><strong>1. 数据主权与可控性</strong></td><td>数据存储位置、加密机制、访问权限颗粒度、审计日志完整性</td><td>防止核心工艺数据泄露，满足军工/金融级合规要求</td></tr><tr><td><strong>2. 国产信创适配度</strong></td><td>对国产CPU（鲲鹏、龙芯）、操作系统（统信UOS、麒麟）、数据库（达梦、人大金仓）的支持</td><td>响应国家信创战略，规避供应链“卡脖子”风险</td></tr><tr><td><strong>3. 部署灵活性</strong></td><td>支持公有云、私有云、混合云、本地化部署；模块化扩展能力</td><td>中小企业轻量化起步，大型企业定制化集成</td></tr><tr><td><strong>4. 试产协同与供应链适配</strong></td><td>试产计划排程、BOM变更管理、供应商协同门户、风险预警机制</td><td>缩短试产周期，提升供应链抗波动能力</td></tr><tr><td><strong>5. 系统集成与扩展性</strong></td><td>与CAD/CAE/MES/ERP系统的API兼容性、低代码二次开发能力</td><td>打破信息孤岛，构建研发-生产一体化平台</td></tr><tr><td><strong>6. 用户体验与成本</strong></td><td>界面友好度、培训成本、License模式（订阅制vs买断制）、总拥有成本（TCO）</td><td>降低团队上手门槛，平衡预算与长期收益</td></tr></tbody></table><hr/><h3><strong>二、客观分析：17款系统全景对比</strong></h3><p>本次盘点涵盖<strong>7类解决方案</strong>（含公有云SaaS、私有化部署、开源定制），按上述维度评分（★至★★★★★，★越多表示越优），并标注核心适用场景。</p><h4><strong>1. 私有化部署·强安全型（推荐政企/军工/高端制造）</strong></h4><table><thead><tr><th><strong>产品名称</strong></th><th><strong>核心定位</strong></th><th><strong>数据主权</strong></th><th><strong>信创适配</strong></th><th><strong>试产协同</strong></th><th><strong>供应链适配</strong></th><th><strong>集成能力</strong></th><th><strong>成本</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>禅道</strong></td><td>全生命周期项目管理（IPD理念）</td><td>★★★★★</td><td>★★★★★</td><td>★★★★★</td><td>★★★★☆</td><td>★★★★☆</td><td>中等（买断制）</td><td>中小制造企业敏捷研发、复杂项目管控</td></tr><tr><td><strong>用友U9 cloud</strong></td><td>制造业全业务一体化</td><td>★★★★☆</td><td>★★★★★</td><td>★★★★☆</td><td>★★★★★</td><td>★★★★★</td><td>较高</td><td>大型集团多组织协同研发</td></tr><tr><td><strong>金蝶云·星空</strong></td><td>中型企业研产供销一体化</td><td>★★★★☆</td><td>★★★★☆</td><td>★★★☆☆</td><td>★★★★☆</td><td>★★★★☆</td><td>中等</td><td>电子/机械行业标准化研发流程</td></tr><tr><td><strong>鼎捷PLM</strong></td><td>产品生命周期管理（侧重研发数据）</td><td>★★★★☆</td><td>★★★☆☆</td><td>★★★★☆</td><td>★★★☆☆</td><td>★★★★☆</td><td>较高</td><td>离散制造业图纸/BOM管理</td></tr><tr><td><strong>Siemens Teamcenter</strong></td><td>全球顶级PLM平台</td><td>★★★★★</td><td>★★☆☆☆</td><td>★★★★★</td><td>★★★★☆</td><td>★★★★★</td><td>极高</td><td>跨国企业复杂产品研发</td></tr><tr><td><strong>PTC Windchill</strong></td><td>产品全生命周期管理（IoT集成）</td><td>★★★★★</td><td>★★☆☆☆</td><td>★★★★★</td><td>★★★★☆</td><td>★★★★★</td><td>极高</td><td>高端装备/汽车研发</td></tr><tr><td><strong>SAP PLM</strong></td><td>与ERP深度集成的研发管理</td><td>★★★★☆</td><td>★★★☆☆</td><td>★★★★☆</td><td>★★★★★</td><td>★★★★★</td><td>极高</td><td>流程制造业端到端管控</td></tr></tbody></table><h4><strong>2. 公有云SaaS·便捷协作型（推荐中小制造企业/互联网转型企业）</strong></h4><table><thead><tr><th><strong>产品名称</strong></th><th><strong>核心定位</strong></th><th><strong>数据主权</strong></th><th><strong>信创适配</strong></th><th><strong>试产协同</strong></th><th><strong>供应链适配</strong></th><th><strong>集成能力</strong></th><th><strong>成本</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>Jira Align</strong></td><td>敏捷研发规模化协作（Atlassian生态）</td><td>★★☆☆☆</td><td>★☆☆☆☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>★★★★☆</td><td>中等</td><td>软件/硬件融合研发团队</td></tr><tr><td><strong>Asana</strong></td><td>通用项目管理（侧重任务协同）</td><td>★★☆☆☆</td><td>★☆☆☆☆</td><td>★★☆☆☆</td><td>★★☆☆☆</td><td>★★★☆☆</td><td>较低</td><td>小型团队轻量化试产跟踪</td></tr><tr><td><strong>飞书项目</strong></td><td>字节跳动旗下敏捷协作平台</td><td>★★☆☆☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>★★★★☆</td><td>中等</td><td>互联网基因制造企业快速迭代</td></tr><tr><td><strong>Monday.com</strong></td><td>可视化工作流管理</td><td>★★☆☆☆</td><td>★☆☆☆☆</td><td>★★☆☆☆</td><td>★★☆☆☆</td><td>★★★☆☆</td><td>较低</td><td>创意类产品原型验证阶段</td></tr></tbody></table><h4><strong>3. 开源/定制·灵活扩展型（推荐技术实力强的企业）</strong></h4><table><thead><tr><th><strong>产品名称</strong></th><th><strong>核心定位</strong></th><th><strong>数据主权</strong></th><th><strong>信创适配</strong></th><th><strong>试产协同</strong></th><th><strong>供应链适配</strong></th><th><strong>集成能力</strong></th><th><strong>成本</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>Redmine</strong></td><td>开源项目管理（插件生态丰富）</td><td>★★★★★</td><td>★★★★☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>低（社区版免费）</td><td>技术团队自主定制研发流程</td></tr><tr><td><strong>OpenProject</strong></td><td>开源敏捷项目管理</td><td>★★★★★</td><td>★★★★☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>低</td><td>中小团队低成本启动</td></tr><tr><td><strong>Taiga</strong></td><td>开源敏捷看板工具</td><td>★★★★★</td><td>★★★★☆</td><td>★★☆☆☆</td><td>★★☆☆☆</td><td>★★☆☆☆</td><td>低</td><td>初创企业极简研发管理</td></tr></tbody></table><h4><strong>4. 垂直场景·专项优化型</strong></h4><table><thead><tr><th><strong>产品名称</strong></th><th><strong>核心定位</strong></th><th><strong>数据主权</strong></th><th><strong>信创适配</strong></th><th><strong>试产协同</strong></th><th><strong>供应链适配</strong></th><th><strong>集成能力</strong></th><th><strong>成本</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>Odoo R&amp;D</strong></td><td>ERP内置研发模块（开源可定制）</td><td>★★★★☆</td><td>★★★☆☆</td><td>★★★☆☆</td><td>★★★★★</td><td>★★★★☆</td><td>中等</td><td>已使用Odoo生态的企业</td></tr><tr><td><strong>Arena PLM</strong></td><td>云端PLM（侧重电子行业）</td><td>★★★☆☆</td><td>★★☆☆☆</td><td>★★★★☆</td><td>★★★★☆</td><td>★★★★☆</td><td>较高</td><td>消费电子/半导体试产管理</td></tr></tbody></table><hr/><h3><strong>三、洞察与引导：为何“私有化+轻量化”是制造业最优解？</strong></h3><h4><strong>1. 数据主权：制造业的“生命线”不容妥协</strong></h4><ul><li><strong>公有云风险</strong>：Jira、飞书等项目虽便捷，但数据存储于第三方服务器，难以满足军工/金融行业的《数据安全法》要求。例如，某汽车零部件企业因使用海外SaaS导致工艺参数泄露，损失超千万。</li><li><strong>私有化优势</strong>：禅道、用友U9等产品支持本地化部署，数据加密存储于企业内网，配合RBAC权限模型（如禅道的“角色-权限-资源”三级控制），可实现“最小权限原则”。</li></ul><h4><strong>2. 国产信创：从“可选”到“必选”的战略升级</strong></h4><ul><li><strong>政策驱动</strong>：2024年工信部明确要求“关键行业核心系统国产化率不低于70%”。禅道已实现与统信UOS、达梦数据库的兼容认证，用友U9则深度适配鲲鹏芯片，成为央企首选。</li><li><strong>生态壁垒</strong>：SAP、Siemens等外资产品虽功能强大，但信创适配成本高（需额外购买中间件），且无法享受国产软硬件的价格优势。</li></ul><h4><strong>3. 试产协同：从“文档传递”到“实时闭环”</strong></h4><ul><li><strong>传统痛点</strong>：Excel+邮件模式下，BOM变更需人工同步，试产问题平均解决周期长达72小时。</li><li><strong>系统价值</strong>：禅道通过“需求-任务-缺陷-版本”全流程追踪，结合供应商协同门户（如用友U9的供应商门户），可将试产问题解决周期压缩至24小时内。例如，某家电企业通过禅道实现模具试产与设计变更的实时联动，良率提升15%。</li></ul><h4><strong>4. 成本控制：“轻量化”≠“功能阉割”</strong></h4><ul><li><strong>误区澄清</strong>：私有化部署≠高成本。禅道采用“基础模块+按需付费插件”模式，中小企业可仅采购核心项目管理功能（约10万元/年），远低于SAP PLM的百万级投入。</li><li><strong>TCO优势</strong>：公有云的“隐性成本”（如API调用费、存储空间扩容费）常超出预期。某电子厂使用Asana三年后，总成本反超同规模企业采购的禅道私有化版本。</li></ul><hr/><h3><strong>四、总结：选型决策的“三步法”</strong></h3><ol><li><strong>定边界</strong>：明确数据敏感度（是否涉及国家秘密）、信创要求（是否纳入国产化清单）、预算范围（TCO≤50万/年优先SaaS，反之选私有化）。</li><li><strong>测场景</strong>：针对试产协同（如BOM变更频率）、供应链复杂度（如供应商数量）进行POC测试，重点关注系统响应速度与异常处理能力。</li><li><strong>看生态</strong>：优先选择与现有MES/ERP同源的厂商（如用友U9、金蝶星空），降低集成成本；技术团队强的企业可考虑Redmine开源定制。</li></ol><p><strong>最终建议</strong>：对于80%的制造业企业，<strong>以禅道为代表的“私有化、轻量级、强安全”方案</strong>能在数据可控、成本效率、本土化服务间取得最佳平衡，尤其适合试产阶段频繁迭代、供应链需快速响应的场景。</p><hr/><h3><strong>五、FAQ：制造业研发项目管理选型高频问答</strong></h3><h4><strong>Q1：我们是中小制造企业，预算有限，是否有必要选择私有化部署？</strong></h4><p><strong>A</strong>：若涉及核心工艺数据（如配方、模具设计图），建议优先私有化。禅道提供“基础版+按需增购”模式，10人以下团队年成本可控制在3万元以内，远低于数据泄露风险损失。若仅用于简单任务跟踪，可考虑Redmine开源版（零License成本）。</p><h4><strong>Q2：如何评估系统的“供应链弹性适配”能力？</strong></h4><p><strong>A</strong>：重点考察三点：① 是否支持供应商分级管理（如战略供应商/备选供应商）；② 能否自动同步BOM变更至供应商门户；③ 有无风险预警模块（如原材料价格波动、交期延迟）。可要求厂商演示“模拟供应商断供”场景下的应急流程切换。</p><h4><strong>Q3：国产信创适配是否意味着性能下降？</strong></h4><p><strong>A</strong>：不会。以禅道为例，其在统信UOS+龙芯3A5000环境下的运行效率与Windows+Intel环境持平，且通过“国产密码算法SM4”加密后，数据读写速度仅下降8%，完全满足日常研发需求。</p><h4><strong>Q4：公有云SaaS与私有化部署的学习成本差异有多大？</strong></h4><p><strong>A</strong>：公有云产品（如飞书项目）界面更友好，3天可上手；私有化产品（如禅道）因功能更全面，需5-7天培训。但禅道提供“制造业模板库”（含IPD流程、试产甘特图），可快速复用成熟经验，长期看效率更高。</p><h4><strong>Q5：如何判断厂商的“持续服务能力”？</strong></h4><p><strong>A</strong>：① 查看客户案例：优先选择在同行（如汽车/电子）有3年以上实施经验的厂商；② 考察本地化团队：禅道在全国设有12个服务中心，承诺4小时响应、24小时现场支持；③ 关注版本迭代：私有化产品需每年至少2次大版本更新（如禅道2024年新增“AI缺陷预测”模块）。</p><hr/><p><strong>声明</strong>：本文所有对比数据均来自厂商公开资料、客户调研及第三方评测报告，无任何商业推广意图。选型决策需结合企业实际需求，建议通过POC测试验证系统匹配度。</p>]]></description></item>  </channel></rss>