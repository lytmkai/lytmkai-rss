<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>SegmentFault - 最近文章</title>      <link>https://segmentfault.com/blogs/newest</link>      <description>SegmentFault 思否</description>      <generator>python segmentfault.py @Pi20</generator>      <item>    <title><![CDATA[AI数字员工来了，你准备好了吗？打造高效]]></title>    <link>https://segmentfault.com/a/1190000047443082</link>    <guid>https://segmentfault.com/a/1190000047443082</guid>    <pubDate>2025-12-02 12:06:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>“代码成就万世基积沙镇海，梦想永在凌云意意气风发”，从这句阿里云早期工程师们书写的对联中，不知大家能否看出那种历史使命式的雄心。</p><p>悉闻，数年前阿里云办公室上的这副对联，正在演化成为阿里云的种种未来。上个月（8月），有幸随着《培训》杂志直达号——阿里云智能集团标杆参访活动，亲眼见识这副名联。</p><p>这次参访和交流机会是难得的，感悟是颇丰的，震撼是显然的。</p><p>任何执拗都会成为过往，只有时间会告诉你对错。（青否ai员工源头v：zhibo175）</p><p>曾经，“云”被视为IT的一部分；现在，IT是云的一部分。今天我们所关注的AI时代，很类似1999当年开始奔腾的互联网时代——只是身在此山中，云深不知处罢了——普通老百姓、职场员工等，尚未真正发现并理解AI的威力。</p><p>作为知识工作者，企业培训人应用AI的普及率是高于普罗大众的。有的是因为技术追求，有的是因为危机感，有的是商业战略和产品服务创新使然。</p><p>但不管如何，已经有不少培训同仁正积极地探索将AI应用于自己的工作场景和业务场景。</p><p>有一件很值得关注也很有意义的新鲜事是，青否ai员工1号已正式入职了！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443084" alt="" title=""/></p><p>业内常言“数转智改”，如果你还不理解“数字员工”意味着什么，那说明你还没参透企业从数字化转型到数智化改造的真谛。</p><p>这个“你”，包括企业家、业务高管、工程师、项目经理、产品经理、HRer、培训师、学习发展专家，概莫如是。如果你是一位企业教育培训与人才发展工作者，对此会作何感知？</p><p>迎接AI时代，或许企业需要重点思考两件事：产品力、生产力。前者，透露着挣钱的逻辑；后者，彰显着省钱的逻辑。增效、降本，当AI大模型开始具备一个企业所需的生产力要素时，当具备AI力的机器人开始成为一个组织的数字员工时，我们的组织将必然需要：思想解放、流程改造、人力资源管理变革、教学模式重构、工作方式进化。</p><p>人与AI交互工作、人机协同办公，已不是幻想。（青否ai员工源头v：zhibo175）</p><p>正如互联网大佬腾讯CEO马化腾先生所言：“我们最开始以为人工智能是互联网十年不遇的机会，但是越想越觉得，这是几百年不遇的、类似发明电的工业革命一样的机遇。”</p><p>没有成功的企业，只有时代的企业。显然，人工智能，作为21世纪最具革命性的技术之一，同样地正在为中国企业教育培训、人才发展、组织人效、学习技术的创新变革带来前所未有的挑战和机遇。对于未来的企业培训人，当如何是好？如何更好？</p><p>这几个方面的问题，非常值得深入研讨，并需要企业培训人在未来的实践中去验证、修正，再实证。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443085" alt="" title="" loading="lazy"/></p><p>青否ai超级员工能够做什么？获客+引流+销售全流程，青否AI超级员工：支持一键控制 + 岗位级替代！</p><p>1、AI获客</p><p>告别内容内耗，多平台高效运营。</p><p>sora2批量生成爆款短视频，智能匹配行业关键词，全自动发布覆盖抖音、快手、视频号、小红书。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443086" alt="" title="" loading="lazy"/></p><p>GEO智能体优化多平台AI内容，用户提问时主动推荐企业及产品，精准曝光。</p><p>多账号一键绑定管理，数据实时监测，无需跨平台切换，省掉半个编辑团队。</p><p>解决：内容累、制作耗时长、跨平台管理乱的痛点。</p><p>2、AI引流（青否ai员工源头v：zhibo175）</p><p>全域精准引流，获客效率倍增。</p><p>按行业+用户画像全网采集高意向客户，主动私信/评论，无需人工蹲点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443087" alt="" title="" loading="lazy"/></p><p>抖音客服7*24小时在线自动回复，AI拟人聊天，引导客户留资。</p><p>解决：找客难、引流慢、精准度低的痛点。</p><p>3、AI销售（青否ai员工源头v：zhibo175）</p><p>标准化私域成交，降本又增效。</p><p>智能私域管家：自动通过好友、实时监控聊天记录、拟人化自动回复，精准预测客户行为分层。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443088" alt="" title="" loading="lazy"/></p><p>价值重构：从时间出卖者到价值创造者，凸显ai员工的重要性！</p><p>会不会使用AI智能体、会不会交互式设定和使用提示词、能不能把AI变成自己的助手，是当下及未来一段时期内你是否是合格地具备AI能力素养的新培训人的重要标志。</p><p>企业发展，人才先行；人才发展，思想引领。要想在AI数智化新时代不掉队、不被淘汰，每个企业培训人都需要解放思想，勇于革新认知，敢于突破传统，积极探索AI在企业教育培训行业各个方面的理论创新、技术创新和应用创新。</p><p>不然，淘汰你的，可能不是AI数字员工，而是那个缺少危机感和变革力的你自己（青否ai员工源头v：zhibo175）。</p>]]></description></item><item>    <title><![CDATA[不知道怎么选型文件型数据库？快来看看吧 ]]></title>    <link>https://segmentfault.com/a/1190000047443156</link>    <guid>https://segmentfault.com/a/1190000047443156</guid>    <pubDate>2025-12-02 12:05:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>不知道怎么选型文件型数据库？快来看看吧</h2><p>最近正好需要为项目选择一个初始场景的学习和试用场景的关系型数据库，对于这种场景，文件型数据库就是最合适的，因为其几乎没有部署成本，并且数据迁移便利，资源消耗低。</p><h3>SQLite</h3><p>那既然说到了文件型数据库，那 SQLite 可就精神了。作为文件型数据库的中流砥柱，它几乎占据了嵌入式场景 70% 以上的江山。你的手机相册、你的浏览器历史记录、你正在用的 IDE、你微信的聊天记录，甚至你那台智能冰箱里，可能都静静地躺着一个 <code>.SQLite</code> 文件。</p><h4>Small. Fast. Reliable. Choose any three</h4><p>作为嵌入式数据库的中流砥柱，SQLite 有诸多过人之处：</p><ol><li><strong>高度可靠，经过严苛测试</strong>：SQLite 的作者对稳定性近乎偏执，最新统计其<a href="https://link.segmentfault.com/?enc=afoUrq8Suy1TkwsFZ3g%2FAA%3D%3D.v5uytefrXXCfTn%2B3jCYdL65T3JiXEV0iPs%2FRLtMoNVRgyl%2FLLVKVRjLYxfK64G%2FP" rel="nofollow" target="_blank">测试代码行数超过 9000 万行，远远高于自身约 15 万行的源码</a>。正因如此，SQLite 被视为“非常健壮且耐用”的数据库，引擎品质媲美工业级产品。实际应用中只要遵循官方建议配置，它几乎不会丢失数据，哪怕面对各种异常情况也能保证数据完整性。</li><li><strong>零配置易用</strong>：SQLite 是自包含的，无需客户端/服务器架构，不用启动独立服务进程。<a href="https://link.segmentfault.com/?enc=2RaTNQ%2BkYAE7YqXSEt6IJw%3D%3D.HsjoKkUg9Z7nQXVJZV%2FS74zGOC6DO4JjBHXPtbFfzWM2EAuGIRef8ao45n0nJpehRpACtszqRvlPNhsbMDeKJQ%3D%3D" rel="nofollow" title="SQL database engines strive,efficiency%2C reliability%2C independence%2C and simplicity" target="_blank">应用进程直接以函数库形式调用它的功能</a>。这意味着部署和使用极其简单：一个库文件加上一把 SQL，就能在应用内部实现数据持久化。对开发者来说，SQLite “拿来即用”，非常适合快速开发和小型项目的嵌入式存储。</li><li><strong>性能优异</strong>：别看 SQLite 体积小，单机单文件内它的读写速度相当快。在事务型负载（大量点查询、快速插入更新）场景下，SQLite 表现非常出色。官方经验表明，SQLite 擅长处理点查询和单记录读写，能在嵌入式设备上支撑每秒上万次简单查询。例如，对于按主键查询这样的操作，SQLite 利用索引可以在毫秒级返回结果。很多应用使用 SQLite 代替传统文件读写，性能反而更好，因为它内部对数据组织和检索做了大量优化。</li><li><strong>资源占用低</strong>：作为面向移动/嵌入式场景设计的引擎，SQLite 对内存和存储的要求都很低。其二进制库通常不到1MB大小，而在运行时，SQLite 也以精巧的机制避免浪费内存。在实际测试中，插入百万级别的数据后，SQLite 进程的内存仅增加区区数兆字节，这一数字远低于同类 Java 数据库。这种小内存占用使它非常适合在内存有限的环境（手机、物联网设备等）中长期运行。</li></ol><h4>没有银弹</h4><p>但是，凡事没有银弹，如果 SQLite 真的完美无瑕，那么世界上就肯定只有一种文件型数据库了。当你试图用 SQLite 扛起稍微复杂一点的业务时，你可能会遇到以下问题：</p><ol><li><strong>弱类型且</strong> <strong>SQL</strong> <strong>语法不完备</strong>：当你开心地给每一个表创建一个 <code>created_at</code> 作为创建时间时，你突然发现，SQLite 这玩意竟然<strong>没有时间类型！</strong>，<a href="https://link.segmentfault.com/?enc=xHcqEBFcQjqP9fjZ0vbEPw%3D%3D.Wg6owrjZgzjEAY39txVf%2BS%2BfO5MTj0%2FR4JJmnUlz%2FRumtTSOsrdYVPcuGkhKd0n9" rel="nofollow" target="_blank">SQLite 中仅有 5 种类型: NULL, INTEGER, REAL, TEXT, BLOB</a>。此外，SQLite 对 SQL 语法的支持也不完整，比如并不支持 存储过程，事务隔离级别仅支持串行化以及 RIGHT/OUTER FULL JOIN 等</li><li><strong>并发</strong>：你要你用过 SQLite，那几乎见过这个错误：<code>SQLite_BUSY: database is locked</code>, SQLite 在并发读写方面有天生局限：<strong>同一时间只允许一个写事务</strong></li><li><strong>分析慢</strong>：老板让你统计过去十年的订单总额，你写了个 <code>GROUP BY</code>，结果 SQLite 跑得比老牛拉破车还慢。不过 SQLite 是 OLTP 型数据库，这里说分析能力有点强人所难了</li><li><strong>单点</strong>：服务器硬盘坏了，那么不好意思了，你的数据库彻底丢失了。对于要求高可用的关键应用来说，仅靠 SQLite 单节点显然不够，需要通过操作系统层面的定期备份</li></ol><p>巧了，针对 SQLite 这些缺点，在不同领域确实存在相应的数据库对其补足了。</p><h3>H2</h3><p>首先就是 H2。</p><p>如果说 SQLite 是 C 语言打造的嵌入式王者，那么 H2 则是 Java 生态中的后起之秀。</p><h4>Java 原生，功能完备</h4><p>H2 Database Engine 是一个纯 Java 编写的轻量级关系数据库。由于天生和 JVM 环境高度契合，H2 已成为许多 Java 项目的默认嵌入式数据库选择（例如 Spring Boot 的默认内存数据库就是 H2）。</p><p>它有如下的优点：</p><ol><li><strong>完整的类型和</strong> <strong>SQL</strong> <strong>支持</strong>：这点直击 SQLite 弱类型的痛点，它采用静态模式的强类型系统，提供了 <a href="https://link.segmentfault.com/?enc=eKHlTIGzlvO82N9AGgDu6Q%3D%3D.2ieKo80ypdhV5J2Hlj%2BmUSbKMRx7FNlzToOTddTxqzqYPJLfhNXxhBVFaotkeJ69" rel="nofollow" target="_blank">完整的 SQL 类型系统以及完整的事务隔离级别</a>)。总体而言，H2 在功能覆盖上更接近传统数据库</li><li><strong>纯Java实现，开箱即用</strong>：由于 H2 完全由 Java 编写，它可以直接嵌入运行于 JVM 的应用，而无需像 SQLite 那样通过 JNI 调用本地库。这带来的好处是部署更加简单——不再受限于操作系统，Javaer 也能更容易地调试和排查问题（毕竟H2的异常栈都是Java代码）。同时，H2 提供了方便的嵌入模式和服务器模式。嵌入模式下，它和应用共享同一 JVM 内存，数据文件存本地；而切换到服务器模式，又可以让多个进程通过TCP/IP协议共同访问数据库</li><li><strong>性能和并发</strong>：益于 Java 实现，H2 内部采用 <a href="https://link.segmentfault.com/?enc=hkcP2YTs4CIg1G3OPFZz7A%3D%3D.1UscU0y8MdW1H28jV1YsE2iiuOsJ9r5TNWiDMG55a2oJZAxY0Ypb2f3MTS7ZgY6woQEzMdjgruIYEj2dMAj5A2bFUa%2B47gdnf6goH4mP0%2Fc%3D" rel="nofollow" target="_blank">多版本并发控制（MVCC）来支持更高的并发度</a>，它允许多个连接同时读写同一个数据库，针对行级别加锁，从而减少锁竞争。相较于SQLite的单写者限制，H2 在并发写入场景下更具优势。此外，H2 内置了缓存机制，会将最近和频繁访问的数据页缓存在内存中，合理调优缓存大小可以大幅提升查询性能。</li><li><strong>易于调试和管理</strong>：H2 附带一个功能完善的Web控制台，允许开发者在浏览器中连接数据库、执行SQL、查看表结构，非常方便。（其实一点也不好用，UI 古老而且功能很少，不如直接使用 DB Manager）</li></ol><h4>H2 的局限性</h4><p>尽管 H2 功能强大，但在某些方面却不如 SQLite 那般稳若磐石，主要体现在数据持久化可靠性和大数据集下的资源消耗：</p><ol><li><strong>持久化安全性</strong>：H2 对事务 Durability（持久性）的保证不如 。此外，SQLite 那样严格。在理想情况下，事务提交后数据应当写入持久介质，即使断电也不会丢失。但H2官方文档明确指出：<a href="https://link.segmentfault.com/?enc=OvDUR4OZR7yWssTWpSIPiw%3D%3D.9c3%2FS8FicdOEDZe7cQBAY37miIEFjxGJgrx3UH2j58ro58wfGy3RX9dtoegkbu67osHYpyHYhGNAEHxAwzPQxzOtmGLVk1UbjZwgu85usFW2rf6eoCv68DmPcBR9KWLc" rel="nofollow" target="_blank">不保证所有已提交事务一定能在掉电后存活</a>，甚至还在后面说<a href="https://link.segmentfault.com/?enc=3aOk3Fv8Ohq5Katz66mqaQ%3D%3D.gyxAZT%2Fyd%2FrJwa%2B4CnsCxYYLeUK%2BzkKnz0Dm4xpo7l2u2xRvMr3IRUlzpth3wEpsDi7YNgQQXnVKRNAXPIRWO7i0nvcizbAZfQkuaofIWhWKcUyn01G0F2adUjw%2FM%2BWK7kayis7kkRANsXB%2BUF4jd3XBiwEE9LxfDks9mv5yV%2FFd5fXkYu5iJTyJ8NyNqpFXUS0TEW1%2FdR3cId2KfdyFRRinPsXlPQPY7%2BXWpSqHK1M%3D" rel="nofollow" target="_blank">一些数据库声称他们能够保证持久性，但这些声明是错误的</a>（这说的谁我想大家都知道）</li><li><strong>可靠性</strong>：由于测试强度和社区使用面不及 SQLite，H2 在大数据量、长时间运行时曝出过一些问题。一些在生产中尝试使用 H2 的开发者反馈：当数据规模增大、并发请求变多时，<a href="https://link.segmentfault.com/?enc=smycVrjWNtAi6VIPCaaX8Q%3D%3D.bk1z%2BeoVSdiL%2B4Vq3oZdmFrTYTODXyoxmrioTq3tcugEUW%2B5V4kDFQPu7FO%2B8vj2azApKGGMN8mVeRD6OEcNTCAoZjUNGDxWWRJBKp8WcQPd2fHV7wwfdnr6lh31k4UA" rel="nofollow" title="reports and articles from,performance when the data grows" target="_blank">H2 容易出现死锁、性能急剧下降，甚至偶尔会有数据损坏或丢失的情况</a>。这点对于生产环境来说是致命的，没有产品能接受用户的数据丢失问题。</li><li><strong>内存</strong><strong>与资源消耗</strong>：相较于高度精简的 SQLite，H2 对内存的胃口要大得多。一方面，Java 实现本身会占用一定堆空间；更重要的是，H2 为追求性能会在内存中缓存大量数据页和索引。一旦数据量上去，H2 进程的内存消耗可能直逼几百MB甚至更高，这点，在后续的 <code>性能对比</code> 章节会有明确的数据结论。</li></ol><p>总得来说，H2 扩展了 SQLite 的功能边界，在纯 Java 生态下提供了一个功能完备的嵌入式数据库。然而这一切是以更高的资源成本为代价的，并且在数据安全性上存在一定隐忧。如果您的应用对数据可靠和长时间稳定运行要求极高，选择 H2 需三思；但如果看重其灵活性（内存/文件/服务器模式）和易用性（Java 原生），H2 仍然是值得考虑的方案。</p><h3>rqlite</h3><p>从名字中就可以知道，rqlite 是对 SQLite 的补充扩展，rqlite 可以简单理解为<code>基于 SQLite 的分布式数据库</code>：它在多台节点上复制 SQLite 的数据，<a href="https://link.segmentfault.com/?enc=qV7mAE1UvDrSSLehyQjTNQ%3D%3D.IDAnjT6DCV%2FXE04OTxY34V%2F2iSMyErhs%2BLayfOFbH7lC2NGMU7sy4R8ZGHbQr8SU" rel="nofollow" title="top of that%2C rqlite,that data at all times" target="_blank">通过 Raft 共识算法保证各节点之间的数据一致性</a></p><p>换句话说，rqlite 将原本单机的 SQLite 变身为一个支持高可用冗余的系统——只要集群中多数节点存活，你的应用仍然可以访问到最新的数据。这对需要轻量级分布式存储的场景来说非常有吸引力。</p><h4>特点与适用场景</h4><ol><li><strong>易部署，低运维成本</strong>：rqlite 非常轻量，每个节点就是一个几MB大小的可执行程序，无需额外依赖。</li><li><strong>高可用与数据安全</strong>：rqlite 基于 Raft 协议保证强一致性，这意味着在任意时刻系统只会有一份一致的数据库状态。数据被完整地复制到多个节点上，单点故障不再致命。</li><li><strong>SQLite</strong> <strong>高度兼容</strong>：rqlite 虽然加了分布式外衣，但底层用的仍是 SQLite 引擎。它对外暴露 HTTP API 供应用写入查询，但你在API里执行的其实还是标准的 SQL 语句，<a href="https://link.segmentfault.com/?enc=kIGWpiHwnWAaTV2xGUtH3Q%3D%3D.7WdA%2BIxgoEQMBYJD80dLRI41nTje2CPj7T%2B41u0lNJHtUL7tF3JVMs%2FFCHT70lIu" rel="nofollow" title="functionality" target="_blank">SQLite 支持的复杂查询、全文检索、JSON 函数等，在 rqlite 上同样适用</a></li></ol><h4>鱼和熊掌不可兼得</h4><p>既要有要是不可取的，虽然 rqlite 补足了 SQLite 单点缺陷的难题，但是为此，它也不得不舍弃一些 SQLite 的优势。</p><ol><li><strong>性能开销</strong>：写入性能较慢是 rqlite 不可避免的弱点。由于每次写操作都要通过 Raft 在多个节点之间通信确认，rqlite 的单次事务延迟远高于本地 SQLite。官方明确指出，rqlite 是为高可用而非高性能设计的，<a href="https://link.segmentfault.com/?enc=G809Ou8SK0Lg4GtZmAGqLQ%3D%3D.q3SROSF94l3tEOSE5K7naTiDDdVJX%2BqW%2BS%2Bpa%2F5U7tukSdTRMq%2BTr59YTogskDT%2B" rel="nofollow" title="but only for reads,write to the Raft log" target="_blank">其写吞吐相对于单机 SQLite 会有明显下降</a>，这点在 <code>性能对比</code> 章节会有明显体现。</li><li><strong>额外的部署开销</strong>：SQLite 之所以能成为数据库的中流砥柱，其核心竞争力之一就是嵌入式的单文件型数据库。然而，rqlite 就不得不启动一个 Server 对外暴露服务，使用时，感觉它就是一个传统的 MySQL 数据服务一样，rqlite 需要独立部署服务进程。</li><li><strong>Java支持弱</strong>：rqlite 目前对各语言的支持主要通过 HTTP Client 库，缺乏像 JDBC 那样成熟透明的驱动。虽然在 Java 中虽然有社区贡献的 <a href="https://link.segmentfault.com/?enc=lSfRectSoZNYLOpeYq8w1A%3D%3D.4tJ0Tg3BOH%2Bw9RtbeeyMPnjHBRppH58NduevHRelADJopZ2DTFu0MfIQ%2FsIdgfM5" rel="nofollow" target="_blank">rqlite-jdbc 驱动</a>，但是经过我的测试，几乎无法使用，有大量 JDBC 的接口都没有实现。</li><li><strong>处境尴尬</strong>：rqlite 为了支持 SQLite 的单点问题，基于 HTTP Server 的模式部署，使得使用它还需要单独部署它，这完全抛弃了 SQLite 拿来即用的最大优势。与其使用 rqlite，我为什么不使用 MySQL、Postgres 这样更成熟功能更多的数据库服务呢？所以它的使用场景非常局限。</li></ol><p>总结来说，rqlite 将 SQLite 带入了分布式时代，以极低的复杂度提供了令人惊喜的高可用特性。不过鱼与熊掌不可兼得，开发者在享受其简洁的同时，也要接受性能上的妥协和适用场景的限制。在对可靠性要求高于性能的边缘计算、物联网、轻量级服务中，rqlite 尚有用武之地；而在高并发、大数据的核心业务里，它就不是一个主力选手了。</p><h3>DuckDB</h3><p>DuckDB 是近年来数据分析领域中迅速崛起的一款数据库系统，它的定位和架构非常独特，是专门为 分析工作负载（OLAP）设计的嵌入式数据库。</p><p>DuckDB 最大的特点在于它结合了两种对立系统的优势：SQLite 的简洁性 和 数据仓库的分析能力。它同样也实现了 <strong>嵌入式</strong>、<strong>零配置</strong>、<strong>单一文件</strong>的优势，而基于其 <code>列式存储</code> 的特定，它非常适合做数据分析统计相关的工作。官方还号称自己为 <a href="https://link.segmentfault.com/?enc=9xFtYW2RLJT1KX59AyrKlA%3D%3D.B568rySEyVJEfLLY7HIoZz8uFMSoPkXGzoh6JveShvLp4xwMTbuXBnZQl%2F5a1hvPNyRLM0qPbU%2Fq507Z8mlykQ%3D%3D" rel="nofollow" target="_blank">The SQLite for Analytics</a></p><h4>The SQLite for Analytics</h4><p>近年来，DuckDB 在数据科学圈迅速走红，Python、R、Julia 等工具链都集成了DuckDB，用它来取代笨重的 pandas 或Spark执行本地分析任务。下面让我们看看DuckDB在文件型数据库选型中有哪些独特价值。</p><ol><li><strong>列式存储，极速分析</strong>：DuckDB 最核心的卖点就是列存。它将同一列的数据紧凑地存储在一起，适合扫描和压缩，大幅提升了聚合计算的效率。当你对百万行数据执行 <code>GROUP BY</code>、<code>JOIN</code>、<code>AVG</code> 这类操作时，DuckDB 的列式引擎可以<a href="https://link.segmentfault.com/?enc=tubd%2Bn34JnG6gqSNZtd4Qw%3D%3D.si8FLbOfvxj%2BiewcOLdyOHPTbOL%2FQK0irkNHJgPMxSkB7KeAvZ7lusao1bd97njU75qWJ%2Bdof4SUDv3UOEGpPqv%2FRuqWK8CiW0WrEkn1ehA%3D" rel="nofollow" target="_blank">比 SQLite 快出一个数量级以上</a>。DuckDB 还使用向量化执行（一种批量数据处理技术）充分利用 CPU 流水线，提高算子执行效率。这些设计让 DuckDB 在处理大批量数据分析时如鱼得水</li><li><strong>多核<strong><em><em>并行</em></em></strong>，<strong><em><em>内存</em></em></strong>友好</strong>：<a href="https://link.segmentfault.com/?enc=URVNGVFz%2B1fmnqfitD2K3w%3D%3D.2hUwfbGgf9ASD567qQBu%2FSHfgZRyO%2FsWJtdcT36Z%2BXMgXvbsr7vH6DL7HABaMcmaawNNxkHZIbBfL3ckizLSTw%3D%3D" rel="nofollow" target="_blank">DuckDB 支持多线程并行查询执行，可以利用机器的多核优势加速处理</a>，另外，DuckDB 为了分析场景做了大量内存优化，会智能地<a href="https://link.segmentfault.com/?enc=LUxRJiAgVaIxZKdt%2F20BQA%3D%3D.TShyTAJi5U8L0W%2BWs4nhC%2FNv38heY%2BsI66ixDmKkLLIzshzzX9pxcqvYfsymFXSuXMTnx8H%2BCemTxK5QTcni6w%3D%3D" rel="nofollow" title="using option 1%2C DuckDB,the same connection are faster" target="_blank">将中间结果缓存于内存以减少重复计算，并采取乐观并发控制机制避免不必要的锁竞争</a></li><li><strong>即席分析</strong>：DuckDB 非常适合作为数据分析的嵌入式引擎融入应用中。它支持标准 SQL，包含窗口函数、复杂 JOIN、CTE 等高级功能，对数据科学家和分析师来说十分友好。同时，DuckDB 可以直接读取多种数据格式，例如 CSV、Parquet、Arrow 等，这意味着你可以用SQL直接查询这些文件，而不必先写脚本转换导入。这一点对于需要频繁从数据湖或日志文件中提取信息的应用来说价值巨大</li></ol><h4>各有所长</h4><p>尽管DuckDB在特定领域表现亮眼，但我们也需认识到它并非万能，同SQLite相比有以下局限：</p><ol><li><strong>不擅长高并发</strong><strong>OLTP</strong>：DuckDB 的设计初衷不是替代 OLTP 数据库来处理海量并发事务。它更关注吞吐而非并发，对于大量小事务的场景支持有限。DuckDB 允许一个进程内开启多个并发写线程，但仍然不支持多个进程同时写入同一库文件（多进程只能并发只读）</li><li><strong>内存</strong><strong>占用与启动开销</strong>：相较 SQLite 极简的内存足迹，DuckDB 在加载大数据集进行分析时会占用显著更多的内存。这是列式数据库的典型特征：为了加速计算，DuckDB 常常需要将列数据或中间结果缓存在内存中。对于几百万行的数据表，运行一个复杂分析查询往往会瞬时占用几百MB的内存，这一点在嵌入式设备上需要慎重考虑。</li><li><strong>生态成熟度</strong>：DuckDB 毕竟是近几年才出现的新项目，在生态工具和社区积累方面无法与 SQLite 比肩。比如，SQLite 历经二十年验证，几乎没有重大漏洞且兼容性极佳，而 DuckDB 还在快速迭代中，可能存在隐藏的bug或行为改变。</li></ol><p>总的来说，DuckDB 为文件型数据库开辟了新的可能：<strong>在本地完成过去需要数据库集群才能完成的大规模分析计算</strong>。对于追求实时分析的平台来说，这简直是福音。然而，正如没有任何单一数据库能通吃所有场景一样，DuckDB 也有其短板。我们应根据具体需求，在性能和资源之间找到平衡。</p><h3>性能对比</h3><p>说了这么多优缺点，实际表现到底如何呢？正好我针对 SQLite、H2、DuckDB、rqlite 四个数据库做了一系列基准测试，包括增删改查各类操作。下面我们就结合数据，看看它们在不同场景下的性能差距如何。先上结论：没有最强，只有最适合场景的。</p><h4>INSERT 性能 (ms)</h4><table><thead><tr><th>数据规模</th><th>SQLite</th><th>H2</th><th>DuckDB</th><th>rqlite</th></tr></thead><tbody><tr><td>100,000 (新增100K)</td><td>780</td><td>2,268</td><td>12,531</td><td>5,481</td></tr><tr><td>200,000 (新增100K)</td><td>5,921</td><td>3,114</td><td>7,953</td><td>8,566</td></tr><tr><td>500,000 (新增300K)</td><td>17,345</td><td>41,827</td><td>16,948</td><td>34,989</td></tr><tr><td>1,000,000 (新增500K)</td><td>28,294</td><td>95,202</td><td>31,618</td><td>超时</td></tr></tbody></table><ul><li>SQLite 在大规模插入时表现最稳定，插入时间随数据增长没有夸张暴涨，稳如老狗。</li><li>H2 初始插入很快，但随着数据量增长性能<strong>跳崖式下降</strong>，50 万行以后写入速度直线暴跌。看来多线程插入扛不住太大数据量，后劲不足。</li><li>DuckDB 插入性能中规中矩，相对稳定，没有明显瓶颈，也没有 SQLite 那么稳，总体还算不错。</li><li>rqlite 因 Raft 共识协议，写入需要分发给集群所有节点，大规模写入相当吃力，插到 100 万行时直接超时放弃治疗。</li></ul><h4>SELECT 查询性能 (ms, 1000 次按 ID 查询)</h4><table><thead><tr><th>数据规模</th><th>SQLite</th><th>H2</th><th>DuckDB</th><th>rqlite</th></tr></thead><tbody><tr><td>100,000</td><td>49</td><td>690</td><td>715</td><td>2,298</td></tr><tr><td>200,000</td><td>39</td><td>823</td><td>394</td><td>664</td></tr><tr><td>500,000</td><td>35</td><td>1,034</td><td>328</td><td>678</td></tr><tr><td>1,000,000</td><td>28</td><td>1,244</td><td>424</td><td>-</td></tr></tbody></table><ul><li>SQLite 点查询性能最优，100 万行数据下 1000 次查询仅耗时 28ms，几乎可以忽略不计，秒杀其他选手，堪称单点查询之王。</li><li>DuckDB 查询性能相当稳定，随着数据量增加变化不大，反而在 50 万行时最快。这可能得益于它优秀的查询优化和向量化执行。</li><li>H2 查询性能随着数据量增长明显下降，大数据量下查询变慢，估计是缓存命中率降低且 MVCC 开销显现。</li><li>rqlite 因为每次查询都经过 HTTP 网络开销，相对来说要慢不少，在 50 万行以上基本奔溃（100 万行我甚至没测出来）。</li></ul><h4>UPDATE 性能 (ms, 1000 次更新操作)</h4><table><thead><tr><th>数据规模</th><th>SQLite</th><th>H2</th><th>DuckDB</th><th>rqlite</th></tr></thead><tbody><tr><td>100,000</td><td>2,710</td><td>478</td><td>4,404</td><td>85</td></tr><tr><td>200,000</td><td>2,252</td><td>794</td><td>3,034</td><td>1,396</td></tr><tr><td>500,000</td><td>2,357</td><td>1,149</td><td>3,042</td><td>88</td></tr><tr><td>1,000,000</td><td>2,214</td><td>967</td><td>3,029</td><td>-</td></tr></tbody></table><ul><li>rqlite 在小批量更新上出乎意料地快，只用了 HTTP 接口提供的批处理优化，100k 行时 1000 次更新只要 85ms，堪称变态。这对需要远程批量更新的场景是个亮点。</li><li>H2 更新性能整体优秀且稳定，每增加数据，时间没有激增，始终保持在毫秒级，得益于其对事务和批量操作的良好支持。</li><li>SQLite 和 DuckDB 的更新性能相近，基本一个水平线。SQLite 胜在本地无网络，DuckDB 胜在批量执行优化，最后旗鼓相当。</li></ul><h4>DateTime 范围查询性能 (ms)</h4><p>&gt; SQLite 本身是没有 DateTime 相关数据类型的，这里测试时，采用了普遍的基于 TEXT 类型存储 ISO-8601 格式的字符串实现</p><h5>无索引 (1M 行数据)</h5><table><thead><tr><th>查询范围</th><th>查询次数</th><th>SQLite</th><th>H2</th><th>DuckDB</th><th>rqlite (500K)</th></tr></thead><tbody><tr><td>1周</td><td>300</td><td>562</td><td>896</td><td>2,784</td><td>461</td></tr><tr><td>1月</td><td>200</td><td>1,514</td><td>1,935</td><td>7,218</td><td>1,489</td></tr><tr><td>6月</td><td>100</td><td>6,403</td><td>5,829</td><td>1,554</td><td>3,546</td></tr><tr><td>1年</td><td>50</td><td>9,012</td><td>3,706</td><td>1,013</td><td>3,944</td></tr></tbody></table><h5>有索引 (1M 行数据)</h5><table><thead><tr><th>查询范围</th><th>查询次数</th><th>SQLite</th><th>H2</th><th>DuckDB</th><th>rqlite (500K)</th></tr></thead><tbody><tr><td>1周</td><td>300</td><td>587</td><td>1,035</td><td>3,799</td><td>751</td></tr><tr><td>1月</td><td>200</td><td>1,837</td><td>1,309</td><td>7,749</td><td>1,056</td></tr><tr><td>6月</td><td>100</td><td>5,043</td><td>3,303</td><td>2,678</td><td>3,188</td></tr><tr><td>1年</td><td>50</td><td>6,446</td><td>4,804</td><td>1,938</td><td>4,472</td></tr></tbody></table><ul><li>不建索引情况下，查询范围越大，DuckDB 越显优势：大范围扫描 DuckDB 最快，比如查询一年范围 DuckDB 明显比其它快得多（列式存储一次扫描优势尽显）。</li><li>SQLite 在小范围查询（比如 1 周的数据）表现优秀，甚至优于 H2，说明少量数据的全表扫描对 SQLite 来说还能 Hold 住。</li><li>给 DateTime 列建索引后，大部分数据库范围查询速度都有提升，其中 rqlite 提升最明显（毕竟不用每次扫完 500K 行了）。不过 DuckDB 在有无索引下对大范围查询依然保持强劲，索引对它帮助有限，因为本来全表扫也不慢。</li><li>H2 和 SQLite 建索引后对中等范围查询有提升，但面对特别大的范围（半年/一年），DuckDB 依旧凭借列存和并行优势全面胜出。</li></ul><h4>备份性能 (ms)</h4><table><thead><tr><th>数据库</th><th>备份耗时</th><th>备份文件</th><th>验证结果</th></tr></thead><tbody><tr><td>SQLite</td><td>1,166</td><td>bench_backup.db</td><td>✔ OK (1,000,000 rows)</td></tr><tr><td>H2</td><td>19,195</td><td>h2_backup.zip</td><td>✔ OK (1,000,000 rows)</td></tr><tr><td>DuckDB</td><td>417</td><td>duckdb_backup/ (Parquet)</td><td>✔ OK (1,000,000 rows)</td></tr><tr><td>rqlite</td><td>-</td><td>rqlite_backup.db</td><td>未测试</td></tr></tbody></table><ul><li>DuckDB 备份最快，仅耗时 417ms！它备份时直接导出为压缩的列式格式（Parquet），效率非常高。在大数据备份上 DuckDB 完胜。</li><li>SQLite 备份性能也相当不错，1百万行数据备份文件不到 2 秒搞定，而且只是复制一份 .db 文件的功夫，简单粗暴但可靠。</li><li>H2 备份耗时最长，将近19秒，因为它默认备份会压缩成 zip 包，还原起来麻烦，而且备份期间性能较差。</li><li>rqlite 因为 100 万行时基准写入都没完成，这里没法测试备份，不过 rqlite 本身提供快照功能，速度估计也不会快哪去。</li></ul><h4>内存使用情况</h4><table><thead><tr><th>数据库</th><th>基线内存</th><th>最终内存</th><th>内存增量</th><th>Heap 增量</th></tr></thead><tbody><tr><td>SQLite</td><td>9.5 MB</td><td>11.6 MB</td><td>2.1 MB</td><td>221 KB</td></tr><tr><td>H2</td><td>18.4 MB</td><td>817.2 MB</td><td>798.9 MB</td><td>782.7 MB</td></tr><tr><td>DuckDB</td><td>34.3 MB</td><td>366.1 MB</td><td>331.7 MB</td><td>332.3 MB</td></tr><tr><td>rqlite</td><td>42.6 MB</td><td>~120 MB</td><td>~77 MB</td><td>~70 MB</td></tr></tbody></table><ul><li>SQLite 内存使用惊人地低！整个基准跑完才增加了2MB 内存，占用几乎可以忽略，真正的小而美。</li><li>H2 内存消耗最高，最终增量将近 800MB，Heap 上暴涨了 782MB，怀疑人生——大概它把数据几乎全放内存里了，对内存小的环境很不友好。</li><li>DuckDB 内存使用适中，增加了约 332MB。考虑到它是列式数据库，需要缓存列数据，能接受。不过相对 SQLite 还是肉厚了一些。</li><li>rqlite 客户端这边内存占用并不高（因为数据主要在服务端），最终增量大约 77MB，但这并不反映 rqlite 服务器端的内存开销。总之，如果关注本进程内存，rqlite 表现还行。</li></ul><h4>综合评价</h4><p>综合来看，根据不同指标，各数据库各有千秋，下表给出了在不同需求下最推荐的选择：</p><table><thead><tr><th>指标</th><th>推荐数据库</th><th>理由</th></tr></thead><tbody><tr><td><strong>大规模写入</strong></td><td>SQLite</td><td>写入性能稳定，数据量增大也不掉速</td></tr><tr><td><strong>点查询</strong></td><td>SQLite</td><td>28ms/1000 次查询，单点查询速度最快</td></tr><tr><td><strong>批量更新</strong></td><td>rqlite / H2</td><td>HTTP 批处理加持 (rqlite) 或高效事务 (H2)</td></tr><tr><td><strong>大范围查询</strong></td><td>DuckDB</td><td>列式存储优势明显，全表扫描速度最快</td></tr><tr><td><strong>小范围查询</strong></td><td>SQLite</td><td>索引配合下性能优异，处理少量数据最快</td></tr><tr><td><strong>备份恢复</strong></td><td>DuckDB</td><td>417ms 完成备份，Parquet 压缩高效</td></tr><tr><td><strong>内存效率</strong></td><td>SQLite</td><td>内存占用仅增加 2MB，资源友好</td></tr><tr><td><strong>分布式高可用</strong></td><td>rqlite</td><td>基于 Raft 共识，多节点冗余，高可用保障</td></tr></tbody></table><h4>测试代码</h4><p>上面的 Benchmark 测试，我还摘取了一部分核心代码片段，便于大家理解这些性能差异是怎么测出来的。例如下面是基准测试中插入操作的实现简要。可以看到，对于 SQLite，我们使用单线程批量插入，而针对 H2，我们则利用多线程并发插入（writerThreads() 返回的线程数决定了策略）。这段代码也从一个侧面解释了为何 H2 在小数据量插入上冲得快——毕竟用了多线程——但数据量大时反而失速：线程开多了反而拖累了性能和内存。</p><pre><code class="Java">int threads = db.writerThreads();
long t0 = System.nanoTime();

if (threads == 1) {
    /* ---- 单线程批量写（SQLite）---- */
    try (Connection c = db.open()) {
        c.setAutoCommit(false);
        try (PreparedStatement ps = c.prepareStatement("INSERT INTO bench(name, age, salary, employ_date) VALUES (?,?,?,?)")) {
            for (int i = 0; i &amp;lt; need; i++) {
                ps.setString(1, randomString(12));
                ps.setInt(2, RND.nextInt(43) + 18);
                ps.setDouble(3, RND.nextDouble() * 200_000);
                db.bindDate(ps, 4, randomEpoch());
                ps.addBatch();
                if (i % BATCH_SIZE == 0) {
                    ps.executeBatch();
                }
            }
            ps.executeBatch();
        }
        c.commit();
    }
} else {
    /* ---- 多线程批量写（H2）---- */
    ExecutorService pool = Executors.newFixedThreadPool(threads);
    CountDownLatch latch = new CountDownLatch(need / BATCH_SIZE);
    List&lt;future&lt;?&gt;&amp;gt; futures = new ArrayList&amp;lt;&amp;gt;();

    for (int i = 0; i &amp;lt; need; i += BATCH_SIZE) {
        futures.add(pool.submit(() -&amp;gt; {
            try (Connection c = db.open()) {
                c.setAutoCommit(false);
                try (PreparedStatement ps = c.prepareStatement("INSERT INTO bench(name, age, salary, employ_date) VALUES (?,?,?,?)")) {
                    for (int j = 0; j &amp;lt; BATCH_SIZE; j++) {
                        ps.setString(1, randomString(12));
                        ps.setInt(2, RND.nextInt(43) + 18);
                        ps.setDouble(3, RND.nextDouble() * 200_000);
                        db.bindDate(ps, 4, randomEpoch());
                        ps.addBatch();
                    }
                    ps.executeBatch();
                }
                c.commit();
            } catch (SQLException e) {
                LOG.error("insert task failed", e);
                throw new RuntimeException(e);
            } finally {
                latch.countDown();
            }
        }));
    }

    for (Future&lt;!--?--&gt; f : futures) {
        try {
            f.get();
        } catch (ExecutionException ee) {
            throw ee.getCause();
        }
    }
    latch.await();
    pool.shutdown();
}

long ms = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - t0);
System.out.printf("insert %,d rows: %d ms%n", need, ms);</code></pre><p>从以上代码可以看到，SQLite 采用单连接串行批量提交，而 H2 开了多个线程并发插入（每线程每批插入 BATCH_SIZE=1000 行）。这解释了为什么在 10万行这样的规模下，H2 插入能比 SQLite 快（多线程跑赢单线程），但到 50 万行、100 万行时，线程上下文切换和内存开销反而拖累了 H2，导致性能急转直下。</p><h3>选型推荐</h3><p>聊了这么多，回到我们最开始的问题：在不同使用场景下，该选哪种文件型关系数据库？ 结合上面的优缺点分析和性能数据，我的选型建议如下：</p><ul><li><strong>如果你的场景偏向本地嵌入、移动端、单机应用</strong>：比如移动App、本地小工具、单机客户端程序，需要一个零配置、小巧可靠的数据库，<strong>SQLite 永远是首选</strong>。它部署最简单、稳定可靠，单用户使用时性能也非常好。典型例子：手机应用缓存、本地存储，IoT 设备的数据落地等等，用 SQLite 十拿九稳</li><li><strong>如果你在 Java 服务端开发中需要一个嵌入式数据库用于单元测试或临时存储</strong>：优先考虑 H2。它与Java高度兼容，内存模式省去清理麻烦，支持标准SQL特性更全面，拿来当开发测试用的内置库非常合适。不过要注意，<strong>别拿H2当生产库长期存重要数据</strong>——一来持久化可靠性稍差，二来内存消耗较高。如果是小型工具或者对数据丢失不敏感的场景，用 H2 问题不大</li><li><strong>如果你的需求是高可用、分布式部署</strong>：比如希望数据库有容灾能力，多机冗余不会单点故障，那只能选 rqlite。它基于Raft提供强一致复制，天生容错。但请谨记：<strong>rqlite 适合读多写少、对性能要求不高的场景</strong>。其实我个人感觉，rqlite尚不成熟，在 Java 相关的项目中，尽量不要使用</li><li><strong>如果你的主要任务是本地的大数据分析、OLAP 查询</strong>：毫无疑问，DuckDB 会是你的好伙伴。它简直就是为这种场景而生，在单机内存允许的范围内，可以替代庞大的数据仓库，直接对本地文件或内存数据做分析处理。举个例子，你要在应用里分析几百万行日志或做报表汇总，用DuckDB内嵌处理会比把数据塞进SQLite快出一个数量级。不过，同样的，DuckDB不适合拿来支撑高并发 OLTP 业务，<strong>它更像是分析引擎而非通用 OLTP 数据库</strong></li><li><strong>如果你的应用场景介于上述之间</strong>：或者仍拿不定主意，那<strong>一般优先 SQLite 作为基准方案</strong>。然后根据瓶颈再考虑替代：性能瓶颈在分析查询上就上 DuckDB，瓶颈在并发读写上可以考虑 H2（或者直接上更重型的数据库）。没有银弹，另外，大不了先用SQLite 快速验证业务，真撑不住了再迁移也不迟——反正 SQLite 转去其它数据库也不算太痛苦。</li></ul>]]></description></item><item>    <title><![CDATA[能看清，更要看懂：MME-VideoOC]]></title>    <link>https://segmentfault.com/a/1190000047443159</link>    <guid>https://segmentfault.com/a/1190000047443159</guid>    <pubDate>2025-12-02 12:04:33</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>多模态大模型（MLLM）在静态图像上已经展现出卓越的 OCR 能力，能准确识别和理解图像中的文字内容。然而，当应用场景从静态图像拓展至 动态视频 时，即便是当前最先进的模型也面临着严峻的挑战。视频作为一种信息密度更高、场景更复杂的模态，其 OCR 任务的难度远超静态图像：运动模糊、光影变化、视角切换以及复杂的时序关联 等视频的动态因素，都对 MLLM 的视频文字识别构成了显著的障碍。视频中的文字信息形式复杂多样，既可能出现在画面主体、背景场景，也可能以屏幕注释、水印或弹幕的方式存在。这要求模型能够建立稳定的时空视觉-文本关联，以实现对分布在不同位置与时间段文字信息的准确识别、整合与理解。</p><p>MLLM 不仅需要对视频中文字的进行精确识别，更需在视觉、时序上下文中完成语义解析与推理判断，以实现对视频整体内容的深层理解。目前，MLLM 在视频 OCR 领域的真实性能如何？其核心局限性体现在哪些方面？我们应如何系统地评估并推动其发展？这些关键问题亟待一个明确的答案。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443161" alt="图片" title="图片"/></p><p><strong>主要贡献</strong><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443162" alt="图片" title="图片" loading="lazy"/><br/>为了解决以上问题，快手可灵团队联合北京大学、清华大学、中科院自动化所等单位提出了 MME-VideoOCR，该 Benchmark 致力于系统评估并推动 MLLM 在视频 OCR 中的感知、理解和推理能力，**主要贡献如下：<br/><strong>构建精细的任务体系：</strong>精心构建了 10 大任务类别，进一步细分为 25 个独立任务。**评测维度超越基础识别，深入考察 时序理解、信息整合及复杂推理 等高阶能力。<br/><strong>高质量、大规模数据集：</strong>包含了 <strong>1,464 </strong> 个精选视频片段，覆盖不同的分辨率、时长与场景。构建了 <strong>2,000 </strong> 条高质量、经人工标注的问答对，确保评测的精确性。<br/><strong>揭示当前 MLLM 的能力边界与局限：</strong>对包括闭源与领先开源模型在内的 18 个主流 MLLM 进行了深入评测。系统化分析了各模型在不同视频 OCR 任务中的表现，明确了其优势与 亟待改进的短板。即便是 Gemini-2.5 Pro，其整体准确率也 <strong>仅为 73.7%</strong>，显示出当前 MLLM 在视频 OCR 领域的巨大挑战。MME-VideoOCR 评测框架详解MME-VideoOCR 的设计核心在于其 全面性 与 深度，旨在评估模型从“看见”到“理解”视频文字信息的全方位能力。数据构建MME-VideoOCR 的数据集源于部分高质量数据集和人工采集与构造，经过精心筛选与处理，确保其：<br/><strong>多样性：</strong>涵盖生活记录、影视娱乐、教育科普、体育赛事、游戏直播等多元化场景。<br/><strong>挑战性：</strong>融入运动模糊、低分辨率、复杂背景、艺术字体、文字遮挡、多语言混合等真实世界的复杂因素。<br/><strong>时序性：</strong>特别设计了需要跨帧理解、追踪文字动态、整合时序信息的复杂任务，考验模型的动态处理能力。<br/>考虑到短视频、弹幕视频及 AIGC 视频的逐渐普及，MME-VideoOCR 额外引入了这些特殊类型的视频，增加了数据的全面性。共收集 <strong>1,464 </strong> 个视频和 2000 条样本。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443163" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443164" alt="图片" title="图片" loading="lazy"/></p><p>任务设计10 大任务类别 与 25 个子任务 紧密围绕视频 OCR 的核心挑战，重点评估模型在以下方面的能力：<br/>基础识别：在各种视频条件下准确识别文字及其属性。<br/>时空定位：识别文字在视频中的时间、空间位置。<br/>时序追踪：理解文字内容随时间的演变。<br/>特殊文本解析：对表格、图表、文档、公式、手写体等特殊文本进行有效解析。<br/>信息整合：结合视频上下文与文字进行综合理解。<br/>场景理解：在特定视频情境下解读文字的深层含义。<br/>复杂推理：基于视频中的文字信息进行逻辑判断与问答。<br/>模型鲁棒性：对于 AIGC、对抗样本和超长视频的有效理解。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443165" alt="图片" title="图片" loading="lazy"/><br/>评估策略针对不同任务的特点和标准答案可能存在的灵活性，设计了字符串匹配、多选题以及 GPT 辅助评分三种评测方式。实验发现总结<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443166" alt="图片" title="图片" loading="lazy"/><br/>通过对 18 个主流 MLLM 的深度评测，MME-VideoOCR 揭示了以下关键发现：<br/>整体性能：提升空间巨大顶尖模型<br/>面临挑战：Gemini 2.5 Pro 虽然表现最佳，但 73.7% 的准确率表明，即便是 SOTA 模型在应对复杂视频 OCR 任务时也远未达到理想状态。<br/>开源模型差距显著：当前多数开源 MLLM 在视频 OCR 任务上的表现与顶尖闭源模型相比，存在较大差距，大多数开源模型准确率甚至不足 <strong>60%</strong>。<br/>能力短板：时序与推理是关键瓶颈<br/>静态易，动态难：模型处理单帧或短时序 的文字信息相对较好，但在需要 整合长时序信息、理解文字动态变化 时，性能显著下降。<br/>时空推理能力薄弱：要求结合文字内容及其时空信息进行推理的任务，是当前 MLLM 的 普遍弱点。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443167" alt="图片" title="图片" loading="lazy"/><br/>语言先验依赖问题：模型在进行视频文字理解时，有时会过度依赖其语言模型的先验知识，而未能充分利用视觉信息进行判断。<br/><strong>优化关键：高分辨率与时序信息</strong><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443168" alt="图片" title="图片" loading="lazy"/><br/>实验明确指出，提供 更高分辨率的视觉输入 和 更完整的时序帧覆盖，对于提升 MLLM 在动态视频场景下的 OCR 性能 至关重要。同时需要注意到，更多的视觉输入可能也会导致模型难以关注到目标信息，造成准确率的下滑，这也对模型的信息提取与处理能力提出了更高要求。</p><p><strong>总结</strong><br/>作为旨在全面评估 MLLM 视频 OCR 能力的基准，MME-VideoOCR 不仅量化了当前技术的性能边界，更重要的是为未来的研究与开发指明了方向。我们期待 MME-VideoOCR 能够激发更多创新，推动 MLLM 在视频理解领域取得实质性突破，使其真正能够读懂、理解并应用于日益丰富的视频世界。</p>]]></description></item><item>    <title><![CDATA[在模板的基础上创建 Word 文档：Ja]]></title>    <link>https://segmentfault.com/a/1190000047443188</link>    <guid>https://segmentfault.com/a/1190000047443188</guid>    <pubDate>2025-12-02 12:03:52</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在日常开发中，我们经常需要根据特定数据动态生成Word文档，例如报告、合同、证书等。手动创建既耗时又容易出错，而通过模板自动化生成则能大大提高效率和准确性。本文将深入探讨如何利用强大的Java库 Spire.Doc for Java，在预设Word模板的基础上，通过替换占位符或书签来高效创建定制化的Word文档。</p><h2>1. Spire.Doc for Java 库介绍与安装</h2><p>Spire.Doc for Java 是一款专业的Java Word组件，它允许开发者在Java应用程序中创建、读取、写入、转换和打印Word文档。其核心优势在于功能全面、API易用，且支持多种Word文件格式（DOC, DOCX, RTF等）。无论是简单的文本操作还是复杂的文档结构处理，Spire.Doc 都能提供强大的支持。</p><h3>特点与优势：</h3><ul><li><strong>功能强大</strong>： 支持文本、图片、表格、图表、书签、批注、页眉页脚等Word元素的操作。</li><li><strong>兼容性好</strong>： 支持Microsoft Word 97-2003、2007、2010、2013、2016、2019等版本。</li><li><strong>易于集成</strong>： 作为Maven或Gradle依赖，方便项目管理。</li><li><strong>高性能</strong>： 处理大型文档也能保持较好的性能。</li></ul><h3>Maven 依赖配置：</h3><p>为了在项目中使用 Spire.Doc for Java，您需要将其作为依赖添加到您的 pom.xml (Maven) 文件中。</p><pre><code class="xml">&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;com.e-iceblue&lt;/id&gt;
        &lt;name&gt;e-iceblue&lt;/name&gt;
        &lt;url&gt;https://repo.e-iceblue.cn/repository/maven-public/&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;e-iceblue&lt;/groupId&gt;
        &lt;artifactId&gt;spire.doc&lt;/artifactId&gt;
        &lt;version&gt;13.11.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre><h2>2. 通过替换文本占位符创建文档</h2><p>通过替换文本占位符是基于模板生成Word文档最常见且直观的方法。您可以在Word模板中预设一些特殊的文本标记（例如 {{name}}, [date], #company# 等），然后使用程序将这些标记替换为实际的数据。</p><p>以下是一个详细的代码示例，演示如何加载一个包含占位符的Word模板，并替换这些占位符：</p><pre><code class="java">import com.spire.doc.Document;
import com.spire.doc.FileFormat;
import com.spire.doc.documents.TextSelection;
import com.spire.doc.fields.DocPicture;
import com.spire.doc.fields.TextRange;

import java.util.HashMap;
import java.util.Map;

public class ReplaceTextPlaceholders {

    public static void main(String[] args) {

        // 创建Document对象
        Document document = new Document();

        // 加载模板文档
        document.loadFromFile("C:\\Users\\Administrator\\Desktop\\template.docx");

        // 创建HashMap用于保存占位符及其替换内容
        Map replaceDict = new HashMap&lt;&gt;();
        replaceDict.put("#name#", "约翰");
        replaceDict.put("#gender#", "男");
        replaceDict.put("#birthdate#", "1990年1月15日");
        replaceDict.put("#address#", "缅因街123号");
        replaceDict.put("#city#", "斯普林菲尔德");
        replaceDict.put("#province#", "伊利诺伊州");
        replaceDict.put("#postal#", "62701");
        replaceDict.put("#country#", "美国");

        // 用相应的值替换文档中的占位符
        for (Map.Entry entry : replaceDict.entrySet()) {
            document.replace(entry.getKey(), entry.getValue(), true, true);
        }

        // 图像文件的路径
        String imagePath = "C:\\Users\\Administrator\\Desktop\\portrait.png";

        // 用图像替换照片占位符
        replaceTextWithImage(document, "#photo#", imagePath);

        // 保存修改后的文档
        document.saveToFile("output/ReplacePlaceholders.docx", FileFormat.Docx);

        // 释放资源
        document.dispose();
    }

    // 方法用于用图像替换文档中的占位符
    static void replaceTextWithImage(Document document, String stringToReplace, String imagePath) {

        // 从指定路径加载图像
        DocPicture pic = new DocPicture(document);
        pic.loadImage(imagePath);
        pic.setScale(80f);

        // 在文档中查找占位符
        TextSelection selection = document.findString(stringToReplace, false, true);

        //  获取找到的文本范围
        TextRange range = selection.getAsOneRange();
        int index = range.getOwnerParagraph().getChildObjects().indexOf(range);

        // 插入图像并移除占位符文本
        range.getOwnerParagraph().getChildObjects().insert(index, pic);
        range.getOwnerParagraph().getChildObjects().remove(range);
    }
}</code></pre><h3>步骤说明：</h3><ul><li><strong>加载模板</strong>： 使用 <code>Document</code> 类的 <code>loadFromFile()</code> 方法加载您的Word模板文件。</li><li><strong>准备数据</strong>： 将占位符名称和要替换的实际值存储在数组中。</li><li><strong>执行替换</strong>： 使用 <code>document.replace()</code> 方法进行文本替换。该方法支持查找并替换文档中的指定文本。</li><li><strong>保存文档</strong>： 使用 <code>saveToFile()</code> 方法将修改后的文档保存为新的Word文件。</li></ul><h2>3. 通过替换书签创建文档</h2><p>书签提供了一种更结构化的方式来标记文档中的特定位置或内容区域。与简单的文本占位符相比，书签可以更容易地定位到文档中的特定部分，并替换其内容，甚至插入更复杂的结构，如图片、表格或段落。</p><p>以下代码演示了如何利用 Spire.Doc for Java 查找并替换Word模板中的书签内容：</p><pre><code class="java">import com.spire.doc.Document;
import com.spire.doc.FileFormat;
import com.spire.doc.documents.TextSelection;
import com.spire.doc.fields.DocPicture;
import com.spire.doc.fields.TextRange;

import java.util.HashMap;
import java.util.Map;

public class ReplaceTextPlaceholders {

    public static void main(String[] args) {

        // 创建Document对象
        Document document = new Document();

        // 加载模板文档
        document.loadFromFile("C:\\Users\\Administrator\\Desktop\\template.docx");

        // 创建HashMap用于保存占位符及其替换内容
        Map replaceDict = new HashMap&lt;&gt;();
        replaceDict.put("#name#", "约翰");
        replaceDict.put("#gender#", "男");
        replaceDict.put("#birthdate#", "1990年1月15日");
        replaceDict.put("#address#", "缅因街123号");
        replaceDict.put("#city#", "斯普林菲尔德");
        replaceDict.put("#province#", "伊利诺伊州");
        replaceDict.put("#postal#", "62701");
        replaceDict.put("#country#", "美国");

        // 用相应的值替换文档中的占位符
        for (Map.Entry entry : replaceDict.entrySet()) {
            document.replace(entry.getKey(), entry.getValue(), true, true);
        }

        // 图像文件的路径
        String imagePath = "C:\\Users\\Administrator\\Desktop\\portrait.png";

        // 用图像替换照片占位符
        replaceTextWithImage(document, "#photo#", imagePath);

        // 保存修改后的文档
        document.saveToFile("output/ReplacePlaceholders.docx", FileFormat.Docx);

        // 释放资源
        document.dispose();
    }

    // 方法用于用图像替换文档中的占位符
    static void replaceTextWithImage(Document document, String stringToReplace, String imagePath) {

        // 从指定路径加载图像
        DocPicture pic = new DocPicture(document);
        pic.loadImage(imagePath);
        pic.setScale(80f);

        // 在文档中查找占位符
        TextSelection selection = document.findString(stringToReplace, false, true);

        //  获取找到的文本范围
        TextRange range = selection.getAsOneRange();
        int index = range.getOwnerParagraph().getChildObjects().indexOf(range);

        // 插入图像并移除占位符文本
        range.getOwnerParagraph().getChildObjects().insert(index, pic);
        range.getOwnerParagraph().getChildObjects().remove(range);
    }
}</code></pre><h3>步骤说明：</h3><ul><li><strong>初始化文档</strong>：首先创建一个 <code>Document</code> 对象，作为操作的基础实例。</li><li><strong>加载模板</strong>：使用 <code>Document.loadFromFile()</code> 方法载入包含书签的 Word 模板文件。</li><li><strong>准备替换内容</strong>：创建一个 <code>HashMap</code>，将书签名称与对应的替换文本进行映射，方便后续批量替换操作。</li><li><strong>定位书签</strong>：实例化 <code>BookmarksNavigator</code> 对象，并遍历文档中的书签以定位需要更新的位置。</li><li><strong>执行替换</strong>：调用 <code>replaceBookmarkContent()</code> 方法，将匹配到的书签内容替换为映射表中的对应值，实现动态内容填充。</li><li><strong>保存文档</strong>：使用 <code>saveToFile()</code> 方法将更新后的文档保存为新的文件或覆盖原文件。</li></ul><h2>4. 常见问题解答</h2><p>在使用 Spire.Doc for Java 进行Word文档生成时，可能会遇到一些常见问题。</p><ul><li><strong>Q1</strong>: 为什么替换后占位符或书签没有消失，而是内容被追加了？</li></ul><p><strong>A1</strong>: 对于占位符替换，请确保 document.replace() 方法的第四个参数 replaceAll 设置为 true。对于书签替换，navigator.moveToBookmark() 方法的后两个布尔参数应设置为 true，以确保替换内容时书签标记被移除。</p><ul><li><strong>Q2</strong>: 替换中文内容时出现乱码怎么办？</li></ul><p><strong>A2</strong>: 确保您的Java项目源代码文件编码（如UTF-8）和JVM的默认编码设置正确。通常，Spire.Doc 库本身对Unicode支持良好，乱码问题多与环境编码配置有关。</p><ul><li><strong>Q3</strong>: 如何处理模板中不存在的占位符或书签？</li></ul><p><strong>A3</strong>: Spire.Doc 在查找不到占位符时不会报错，而是简单地跳过。对于书签，navigator.moveToBookmark() 如果找不到会抛出异常。建议在替换前先检查书签是否存在。</p><ul><li><strong>Q4</strong>: 替换内容后，文档样式发生变化，如何保持原有样式？</li></ul><p><strong>A4</strong>: Spire.Doc 在替换文本时通常会尽力保持原有样式。如果样式丢失，可能是替换的内容本身带有格式，或者模板中的占位符/书签所在区域样式定义不明确。尝试确保模板中的占位符/书签区域具有明确的样式定义。对于更复杂的替换，例如插入Rich Text，可能需要通过 TextRange 或 Paragraph 对象进行更精细的控制。</p><ul><li><strong>Q5</strong>: 如何获取 Spire.Doc 的最新版本号？</li></ul><p><strong>A5</strong>: 您可以访问 e-iceblue 官方的Maven仓库查看最新的版本发布信息。</p><h2>总结</h2><p>通过本文的介绍，您应该已经掌握了如何利用 Spire.Doc for Java 库，在Java应用程序中基于Word模板高效生成定制化文档的方法。无论是简单的文本占位符替换，还是结构化的书签内容更新，Spire.Doc 都提供了直观且强大的API支持。希望这篇教程能帮助您在文档自动化处理的道路上更进一步，提升开发效率。</p>]]></description></item><item>    <title><![CDATA[CRM/ERP打通 “采购 - 生产 -]]></title>    <link>https://segmentfault.com/a/1190000047443190</link>    <guid>https://segmentfault.com/a/1190000047443190</guid>    <pubDate>2025-12-02 12:02:56</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>订单驱动型供应链数智化能力横评：五大CRM/ERP品牌的路径差异与场景适配</h2><p>在中小企业数字化转型中， <strong>“订单驱动</strong> <strong>供应链协同</strong> <strong>”是破解“需求-供应”脱节、“流程-数据”孤岛的核心逻辑。超兔、Salesforce、钉钉、用友、</strong> <strong>SAP</strong> <strong>五大品牌均围绕这一逻辑构建能力，但因核心定位、架构设计与生态边界</strong>的差异，形成了不同的落地路径。本文从<strong>订单核心驱动深度、供应链链路打通能力、全业务流程贯通效果</strong>三大维度展开横向对比，揭示各品牌的优势与场景适配性。</p><h3>一、核心定位与架构：原生一体 vs 生态集成 vs 协同平台</h3><p>五大品牌的底层逻辑差异源于<strong>核心定位</strong>：超兔、用友、SAP以“供应链全链路”为核心，Salesforce以“CRM+供应链联动”为核心，钉钉以“协同+低代码连接”为核心。具体架构对比见表1：</p><table><thead><tr><th><strong>维度</strong></th><th><strong>超兔</strong></th><th><strong>Salesforce</strong></th><th><strong>钉钉</strong></th><th><strong>用友</strong></th><th><strong>SAP</strong></th></tr></thead><tbody><tr><td><strong>核心定位</strong></td><td>原生一体化订单驱动供应链平台</td><td>CRM为核心，生态集成补全供应链</td><td>协同平台+低代码，连接内外部流程</td><td>YonSuite/BIP原生一体数智平台</td><td>模块化ERP，深度行业定制供应链</td></tr><tr><td><strong>架构特性</strong></td><td>原生一体化（CRM+进销存+MES+供应链）</td><td>CRM原生+ERP/Procurement Cloud集成</td><td>协同底座+宜搭低代码+生态ISV</td><td>AI×数据×流程原生一体（BIP5）</td><td>模块化（MM/PP/委外）+行业配置</td></tr><tr><td><strong>适配场景</strong></td><td>中小工贸/制造企业，快速上线</td><td>以销售为核心，需联动CRM与供应链</td><td>注重内部协同，需低代码定制流程</td><td>成长型企业，全链路数智化转型</td><td>大型制造/跨国企业，深度行业需求</td></tr></tbody></table><h4>1.1 超兔：原生一体化的“订单指挥棒”</h4><p>超兔的核心优势是“订单-供应链”原生闭环——从订单创建到采购、生产、委外的全流程无需额外集成，系统自动触发后端动作（如库存不足→生成采购需求→匹配供应商→生产排程）。这种架构彻底消除了数据孤岛，适合<strong>中小制造企业</strong>快速实现“订单驱动供应链”。</p><h4>1.2 Salesforce：CRM为起点的“生态联动”</h4><p>Salesforce以CPQ（配置报价）和Order Management为核心，通过<strong>集成</strong> <strong>ERP</strong> <strong>（如</strong> <strong>SAP</strong> <strong>/Oracle）补全供应链能力。其优势在于“前端销售需求与后端供应链的精准对接”，适合以客户为核心、需联动</strong> <strong>CRM</strong> <strong>与供应链</strong>的企业（如消费品、服务型企业）。</p><h4>1.3 钉钉：协同为核心的“连接者”</h4><p>钉钉通过<strong>低代码</strong> <strong>（宜搭）+生态</strong> <strong>ISV</strong>连接企业原有ERP、CRM、MES系统，实现订单全生命周期可视化与跨部门协同。其核心价值是<strong>降低协同成本</strong>，适合<strong>注重内部流程打通、需快速定制</strong>的中小企业。</p><h4>1.4 用友：YonSuite/BIP的“原生数智化”</h4><p>用友依托YonSuite（轻量化SaaS）与BIP（商业创新平台）的“AI×数据×流程”原生一体架构，实现订单驱动的供应链全链路数智化（如MRP自动触发采购、AI优化排产）。适合<strong>成长型企业</strong>从“信息化”向“数智化”升级。</p><h4>1.5 SAP：模块化的“行业深度”</h4><p>SAP以MM（物料管理）、PP（生产计划）、委外管理等模块为核心，通过<strong>行业定制配置</strong>（如制造业MRP、芯片行业库存精细化）实现供应链协同。其优势在于<strong>大型制造企业的复杂场景适配</strong>（如跨国采购、多工厂排程）。</p><h3>二、订单核心驱动能力：从“流程串联”到“智能指挥”</h3><p>订单驱动的核心是“需求端信号如何精准传递至供应端” <strong>。五大品牌的能力差异体现在</strong>订单全生命周期管理深度、与供应链的联动方式、智能特性（见表2）：</p><table><thead><tr><th><strong>维度</strong></th><th><strong>超兔</strong></th><th><strong>Salesforce</strong></th><th><strong>钉钉</strong></th><th><strong>用友</strong></th><th><strong>SAP</strong></th></tr></thead><tbody><tr><td><strong>订单全生命周期覆盖</strong></td><td>从线索→跟单→订单→履约→结算全闭环</td><td>CPQ→Order Management→履约跟踪</td><td>订单创建→跟踪→状态可视化</td><td>订单需求→排产→履约→数据反馈闭环</td><td>订单创建→交期承诺→履约→结算</td></tr><tr><td><strong>供应链联动方式</strong></td><td>原生自动触发（订单→采购→生产→委外）</td><td>集成ERP触发库存/采购</td><td>对接原有系统同步数据</td><td>MRP/AI驱动（订单→生产计划→采购）</td><td>aATP+多约束排程（订单→生产/采购）</td></tr><tr><td><strong>智能特性</strong></td><td>OpenCRM供应商匹配、库存自动校验</td><td>交期预测、异常预警</td><td>低代码定制流程、数据可视化</td><td>AI排产、三单自动匹配</td><td>aATP交期承诺、智能库存优化</td></tr></tbody></table><h4>2.1 超兔：“订单-供应链”的原生闭环</h4><p>超兔的订单驱动能力体现在“无人工干预的流程自动化”：</p><ul><li>订单创建后，系统自动校验库存，若不足则生成<strong>智能采购计划</strong>（通过OpenCRM匹配历史供应商，自动拆分采购单）；</li><li>采购入库后，联动触发<strong>MES生产排程</strong>（正排/倒排，支持小组计件报工）；</li><li>委外工序直接关联订单，实时跟踪供应商进度。</li></ul><p>这种“原生联动”使订单交付周期缩短50%（如某中型工贸企业从15天→7天）。</p><h4>2.2 SAP：“精准承诺”的订单驱动</h4><p>SAP的核心优势是“交期可靠性” <strong>——通过</strong>可承诺量（aATP）实时计算交期（考虑库存、在途、生产能力），异常情况（如物料短缺）自动触发计划重排。例如，某装备制造企业使用SAP后，交期准确率从70%提升至95%。</p><h4>2.3 用友：“AI赋能”的订单驱动</h4><p>用友通过<strong>AI优化排产</strong>（匹配订单进度与产能）、<strong>MRP自动触发采购</strong>（基于实时库存与生产需求），实现“订单需求→供应计划”的智能转换。某制造企业使用用友后，生产排程效率提升40%，采购成本降低8%。</p><h3>三、供应链链路打通：从“环节割裂”到“全链协同”</h3><p>供应链的核心是“采购-生产-委外”的协同。五大品牌的能力差异体现在<strong>各环节的自动化程度、协同深度</strong>（见表3）：</p><table><thead><tr><th><strong>维度</strong></th><th><strong>超兔</strong></th><th><strong>Salesforce</strong></th><th><strong>钉钉</strong></th><th><strong>用友</strong></th><th><strong>SAP</strong></th></tr></thead><tbody><tr><td><strong>采购协同</strong></td><td>OpenCRM供应商评级、智能采购计划</td><td>第三方Procurement Cloud、供应商门户</td><td>采购订单跟踪、供应商信息管理</td><td>MRP驱动、三单自动匹配</td><td>供应商全生命周期、自动需求计划</td></tr><tr><td><strong>生产协同</strong></td><td>原生MES（排程/派工/报工）</td><td>集成MES（如Siemens）</td><td>宜搭对接MES、生产计划联动</td><td>AI排产、产能匹配</td><td>APS多约束排程、实时生产监控</td></tr><tr><td><strong>委外协同</strong></td><td>委外进度跟踪、成本核算</td><td>供应商门户协同、状态同步</td><td>委外任务同步财务、进度跟踪</td><td>动态匹配供应商产能、委外协同</td><td>业务网络平台、委外生产同步</td></tr></tbody></table><h4>3.1 采购环节：从“手动申请”到“智能补货”</h4><ul><li><strong>超兔</strong>：通过<strong>OpenCRM</strong>将供应商纳入系统，自动生成采购单并推送至供应商门户，实现“询盘-比价-订单-对账”全线上化，对账误差率＜1%；</li><li><strong>SAP</strong>：覆盖<strong>供应商全生命周期</strong>（准入→分类→绩效评估），基于销售预测与库存数据自动生成采购需求，降低库存成本15%；</li><li><strong>用友</strong>：通过<strong>三单自动匹配</strong>（采购订单→入库单→发票）智能核验，杜绝人为差错，凭证自动生成率达89%。</li></ul><h4>3.2 生产环节：从“经验排程”到“智能优化”</h4><ul><li><strong>超兔</strong>：原生MES支持<strong>正排/倒排</strong>，甘特图实时监控生产进度，小组计件报工自动计算工时/良品率，生产效率提升30%；</li><li><strong>SAP</strong>：<strong>APS多约束排程</strong>平衡设备、人员、物料产能，某芯片企业使用后，生产周期缩短20%；</li><li><strong>用友</strong>：AI排程系统基于历史订单数据预测产能需求，某制造企业排程时间从4小时→30分钟。</li></ul><h4>3.3 委外环节：从“黑箱操作”到“透明协同”</h4><ul><li><strong>超兔</strong>：委外工序直接关联订单，实时跟踪供应商进度（如生产数量、质检结果），委外成本自动核算；</li><li><strong>SAP</strong>：通过<strong>业务网络平台</strong>实现委外协同，实时同步委外生产计划、工序进度与质量数据，某装备制造企业委外交付准确率提升至98%；</li><li><strong>钉钉</strong>：委外任务纳入协同平台，进度同步至生产/财务模块，避免“委外延误导致订单违约”。</li></ul><h3>四、全业务流程贯通：从“数据孤岛”到“数字闭环”</h3><p>全业务流程贯通的核心是“数据的高效流动与价值挖掘” <strong>。五大品牌的能力差异体现在</strong>数据底层连通性、集成能力、可视化与分析（见表4）：</p><table><thead><tr><th><strong>维度</strong></th><th><strong>超兔</strong></th><th><strong>Salesforce</strong></th><th><strong>钉钉</strong></th><th><strong>用友</strong></th><th><strong>SAP</strong></th></tr></thead><tbody><tr><td><strong>数据底层连通</strong></td><td>原生统一数据库（无孤岛）</td><td>CRM与ERP实时同步</td><td>打通内部应用数据（一个账号看全局）</td><td>统一数智底座（BIP iuap）</td><td>模块化数据集成（MM/PP/委外）</td></tr><tr><td><strong>集成能力</strong></td><td>对接金蝶/用友/电商/RPA</td><td>MuleSoft集成、第三方应用市场</td><td>2000+API、宜搭低代码</td><td>原生集成（财务/人力/供应链）</td><td>行业定制接口、跨国多系统集成</td></tr><tr><td><strong>可视化与分析</strong></td><td>多表聚合BI、拖拽报表</td><td>CRM Dashboard+生态工具</td><td>数据可视化、流程追踪</td><td>AI分析、智能预警</td><td>统一看板、实时监控</td></tr></tbody></table><h4>4.1 超兔：“无孤岛”的数据贯通</h4><p>超兔的所有模块（CRM、进销存、MES、供应链）共享<strong>同一数据库</strong>，销售可直接查看生产排期，生产可实时调取采购进度。通过<strong>多表聚合BI引擎</strong>，无需SQL即可生成“地区+产品+复购率”关联报表，实现“数据-决策”的直接转换。</p><h4>4.2 用友：“统一底座”的数智贯通</h4><p>用友通过<strong>BIP iuap数智底座</strong>，打通财务、人力、供应链数据，实现“订单→生产→财务”的全流程数据贯通。例如，订单履约后自动生成应收凭证，凭证自动生成率达89%，业务处理效率提升30%。</p><h4>4.3 SAP：“模块化”的深度贯通</h4><p>SAP的模块化架构支持<strong>跨模块数据共享</strong>（如MM模块的采购数据→PP模块的生产计划→FI模块的财务核算），通过<strong>统一看板</strong>整合在制、在途、第三方库存数据，实时监控供应链运行状态。某跨国制造企业使用SAP后，库存周转率提升25%。</p><h3>五、综合评估：雷达图与场景建议</h3><h4>5.1 雷达图：五大品牌的能力分值（10分制）</h4><table><thead><tr><th><strong>指标</strong></th><th><strong>超兔</strong></th><th><strong>Salesforce</strong></th><th><strong>钉钉</strong></th><th><strong>用友</strong></th><th><strong>SAP</strong></th></tr></thead><tbody><tr><td>订单驱动深度</td><td>9</td><td>8</td><td>7</td><td>8</td><td>8</td></tr><tr><td>供应链链路协同度</td><td>9</td><td>7</td><td>8</td><td>8</td><td>9</td></tr><tr><td>数据底层连通性</td><td>8</td><td>6</td><td>7</td><td>9</td><td>8</td></tr><tr><td>集成灵活性</td><td>7</td><td>9</td><td>9</td><td>8</td><td>7</td></tr><tr><td>智能能力</td><td>8</td><td>7</td><td>6</td><td>9</td><td>9</td></tr><tr><td>行业适配性</td><td>7</td><td>6</td><td>8</td><td>8</td><td>10</td></tr></tbody></table><h4>5.2 场景适配建议</h4><ol><li><strong>中小制造企业，需快速上线</strong>：选超兔（原生一体化，无需集成，快速实现订单驱动供应链）；</li><li><strong>以销售为核心，需联动CRM</strong>：选Salesforce（CPQ+Order Management，集成ERP补全供应链）；</li><li><strong>注重内部协同，需低代码</strong>：选钉钉（宜搭低代码，连接原有系统，提升协同效率）；</li><li><strong>成长型企业，全链路数智化</strong>：选用友（YonSuite/BIP原生一体，AI赋能，支持业务扩张）；</li><li><strong>大型制造/跨国企业</strong>：选SAP（模块化+行业定制，满足深度制造需求）。</li></ol><h3>六、品牌功能详解</h3><h4>1，超兔相关能力整理（聚焦订单核心驱动与供应链链路打通）</h4><h5><strong>一、核心定位</strong></h5><p>超兔以“订单驱动”<strong>为核心，通过</strong>原生一体化架构打通“采购-生产-委外”供应链全链路，实现内外部数据协同与流程自动化，贯通全业务数字流程。</p><h5><strong>二、关键能力说明</strong></h5><h6><strong>1. 订单与供应链全链路闭环协同</strong></h6><p>以订单为“指挥棒”，自动触发采购、生产、委外等后端动作，消除数据孤岛：</p><ul><li><strong>智能应收与库存联动</strong>：订单创建后，系统自动拆分多期应收、计算账期，并关联库存数据；若库存不足，直接生成采购需求，实现“订单-库存-采购”闭环。</li><li><strong>生产工单自动排程</strong>：订单信息实时同步至MES系统，自动生成生产计划、派工任务（支持手机扫码领料/报工），并关联质检流程，确保生产进度匹配订单需求。</li><li><strong>委外流程透明化</strong>：委外工序数字化管理，实时跟踪供应商生产进度、交付时效及质量数据，支持委外成本核算与多级审批。</li></ul><h6><strong>2. 采购协同与供应商数字化管理</strong></h6><p>通过<strong>OpenCRM体系</strong>将供应商纳入系统，实现“询盘-比价-订单-对账”全流程线上化：</p><ul><li><strong>供应商评级与数据驱动</strong>：根据供应商交货及时率、良品率等指标生成雷达图评级，辅助筛选优质合作伙伴，降低单一依赖风险。</li><li><strong>采购流程自动化</strong>：自动生成采购单并推送至供应商门户，供应商在线确认订单、反馈发货状态，数据实时同步至内部系统，对账误差率可降低至1%以下。</li></ul><h6><strong>3. 全业务数据一体化与可视化</strong></h6><ul><li><strong>底层数据连通</strong>：CRM（客户）、进销存（库存）、生产工单、财务（应收/回款）等模块共享同一数据库，支持跨部门数据实时调取（如销售可直接查看生产排期、客户信用评级）。</li><li><strong>可视化工具</strong>：提供<strong>多表聚合BI引擎</strong>，无需SQL即可拖拽生成分析报表（如“地区客户+产品+复购率”关联分析），全链路信息（订单进度、库存动态、供应商状态）实时可见。</li></ul><h6><strong>4. 中小企业适配与扩展能力</strong></h6><ul><li><strong>轻量化部署</strong>：内置CRM、进销存、生产管理等标准化模块，无需额外集成；支持<strong>三级菜单自定义</strong>、工作流引擎配置，适配非标定制、租赁、维修等多样化订单场景。</li><li><strong>生态集成</strong>：通过API接口与金蝶、用友等ERP系统无缝对接，同时支持RPA插件处理第三方系统数据，满足数字化进阶需求。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443192" alt="" title=""/></p><h5><strong>三、典型场景价值</strong></h5><ul><li>某中型工贸企业使用超兔后，订单交付周期从15天缩短至7天，客户流失率下降40%；</li><li>某电子企业通过供应商协同功能，原材料成本降低8%，产品良品率提升至98%，整体利润增长15%。</li></ul><h4>2，钉钉聚焦订单核心驱动及供应链全链路数字化的能力总结</h4><h5><strong>一、订单核心驱动能力</strong></h5><p>钉钉以订单为核心，提供<strong>全新的订单管理方式</strong>，简化企业订单处理流程，提升工作效率与团队协作能力。具体包括：</p><ul><li><strong>订单全生命周期管理</strong>：支持订单的在线生成、跟踪与状态可视化，通过订单日记活动记录每一笔交易，实现订单从发起至完成的全流程可追溯。</li><li><strong>订单与业务系统同步</strong>：快速对接企业原有ERP、CRM等业务系统，确保订单数据与其他业务环节（如财务、库存）实时联动，避免信息孤岛。</li></ul><h5><strong>二、“采购-生产-委外”供应链链路打通能力</strong></h5><p>钉钉通过数字化工具与生态整合，实现供应链各环节的无缝衔接：</p><ul><li><strong>采购管理</strong>：提供采购订单在线生成、跟踪功能，支持供应商信息管理（如录入供应商联系方式、信用评估、合作记录）、报价比较（自动汇总供应商报价）、配送跟踪（物流查询、收货确认）及付款管理（核对发票与付款信息）。</li><li><p><strong>生产与委外协同</strong>：</p><ul><li>生产环节：通过钉钉开放平台或低代码工具（如“钉钉宜搭”），对接企业MES生产执行系统等，实现生产计划与订单需求的联动；</li><li>委外管理：将委外任务纳入钉钉协作平台，同步委外进度至生产、财务等模块，确保委外环节与生产、采购的协同。</li></ul></li><li><strong>供应链透明化与效率提升</strong>：钉钉供应链功能帮助企业实现供应商、采购、库存、运输、质量管理的数字化，提高供应链效率（如在线审批替代纸质流程）、透明度（实时查看供应链各环节状态）及安全性（数据加密与权限管理）。</li></ul><h5><strong>三、全业务数字流程贯通能力</strong></h5><p>钉钉通过<strong>全链路数字化解决方案</strong>，实现企业“人、财、物、事、产、供、销、存”的一体化连接：</p><ul><li><strong>全流程数字化管控</strong>：整合钉钉审批、日历、文档、表单等模块，实现项目进度、质量、安全、人员等全流程数字化管控；支持订单与采购、生产、库存、财务等环节的数据贯通（如采购订单自动触发生产计划，库存状态同步至销售环节）。</li><li><p><strong>系统集成与开放生态</strong>：</p><ul><li>开放超过2000个API接口，支持与ERP（用友、金蝶）、垂直SaaS（如超兔）等系统深度对接，构建“协同+业务”闭环；</li><li>通过“钉钉宜搭”低代码平台，企业可自定义采购审批、生产排期、委外管理等流程，自动关联考勤、日程、文档等数据，形成“人、事、系统”的一体化连接。</li></ul></li><li><strong>数据同步与可视化</strong>：打通企业内部所有应用（生态内ISV应用和自研系统）的数据层，支持“一个账号看全局”——销售可查看客户历史订单与库存，生产部门能实时调取采购进度与委外任务状态，实现订单从采购到生产的全流程数据追踪。</li></ul><h5><strong>四、支撑能力</strong></h5><ul><li><strong>安全与合规</strong>：采用银行级加密技术（如TLS/SSL、国密SM4算法）保障数据传输与存储安全，支持端到端加密通讯；提供多重身份验证与权限管理，确保敏感信息仅授权用户访问。</li><li><strong>低代码与易用性</strong>：通过低代码工具（如“钉钉宜搭”），企业无需代码即可搭建个性化CRM、ERP、OA等系统，降低数字化转型成本；支持手机与电脑间文件互传、在线文档协作等，提升跨设备协同效率。</li></ul><p>综上，钉钉通过订单核心驱动、供应链链路打通及全业务流程贯通的能力，帮助企业实现从采购到生产、委外的全链路数字化，提升协同效率与管理水平。</p><h4>3，Salesforce相关能力整理</h4><h5>一、聚焦订单核心驱动能力</h5><p>Salesforce以<strong>CRM（客户关系管理）为核心</strong>，通过<strong>订单全生命周期管理</strong>实现订单对供应链的驱动：</p><ol><li><strong>订单全流程管控</strong>：依托CPQ（配置报价）和Order Management模块，覆盖订单创建、库存校验、履约跟踪等环节，确保订单信息准确传递；</li><li><strong>订单与供应链联动</strong>：订单数据与SAP、Oracle等ERP系统<strong>实时同步</strong>——客户下单后自动触发库存查询，库存不足时联动生成采购需求，形成“订单-库存-采购”闭环，实现需求端与供应链的高效对接。</li></ol><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443193" alt="" title="" loading="lazy"/></p><h5>二、打通“采购-生产-委外”供应链链路的能力</h5><p>Salesforce不原生覆盖生产制造流程，需通过<strong>生态集成</strong>实现供应链链路协同：</p><ol start="3"><li><strong>采购协同</strong>：通过第三方应用（如Procurement Cloud）或定制开发，支持采购申请、供应商筛选、合同管理及付款流程；与供应商门户集成，实现采购需求与供应商响应的数字化协同；</li><li><strong>生产协同</strong>：通过ERP集成<strong>间接同步生产计划</strong>，获取生产进度数据，但不直接管理生产环节；</li><li><strong>委外协同</strong>：依赖第三方系统打通委外流程，实现委外订单状态跟踪，但透明化程度受限于集成深度。</li></ol><h5>三、贯通全业务数字流程的能力</h5><p>Salesforce通过<strong>平台整合与系统集成</strong>，实现从客户需求到订单履约的全业务数字贯通：</p><ol start="6"><li><strong>全业务模块联动</strong>：以Customer360平台为核心，整合Sales Cloud（销售）、Service Cloud（服务）、Marketing Cloud（营销）、Commerce Cloud（商务）等模块，实现前端客户互动与后端供应链的信息同步；</li><li><strong>跨系统数据打通</strong>：通过MuleSoft等集成工具，连接CRM与ERP、OMS（订单管理系统）、海关清关系统等第三方系统，消除信息孤岛，实现“客户需求-订单创建-库存/采购-生产/委外-履约交付”的全流程数据贯通；</li><li><strong>供应链可视化</strong>：通过ERP集成获取库存、生产进度等数据，在CRM平台呈现订单履约状态，实现前端销售与后端供应链的信息同步。</li></ol><h4>总结</h4><p>Salesforce的核心优势在于<strong>以订单为驱动，连接前端销售与后端供应链</strong>：通过CRM平台整合客户需求与订单信息，再通过生态集成实现采购、生产、委外的链路协同；其全业务数字流程贯通依赖于与外部系统的集成，适合需联动前端销售与供应链的企业，但复杂制造场景的全链路原生管理需依赖ERP等系统。</p><h4>4，SAP聚焦订单核心驱动与供应链全链路贯通的能力总结</h4><h5>一、订单核心驱动能力</h5><p>SAP以订单为核心，通过<strong>智能处理与精准履约</strong>能力串联全流程：</p><ul><li><strong>交期精准承诺</strong>：借助<strong>可承诺量（aATP）功能</strong>，实时计算并反馈订单交付时间，异常情况（如物料短缺、设备故障）自动触发计划重排，确保交期可靠性；</li><li><strong>智能订单管理</strong>：根据客户等级自动匹配物流优先级，结合历史数据实现订单异常（如延迟、违约）预测与预警，提升订单履约效率。</li></ul><h5>二、“采购-生产-委外”供应链链路打通</h5><p>SAP通过模块化功能与集成化平台，实现采购、生产、委外环节的协同与可视化：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443194" alt="" title="" loading="lazy"/></p><ol start="9"><li><p><strong>采购数字化管理</strong>：</p><ol><li>覆盖<strong>供应商全生命周期</strong>（准入、分类、绩效评估），建立供应商数据库并支持电子商务平台协同，实现询比价、采购订单生成与审批的自动化；</li><li>基于<strong>销售预测与库存数据</strong>自动生成采购需求计划，合理安排供应节奏，降低库存成本。</li></ol></li><li><p><strong>生产与委外协同</strong>：</p><ol><li>借助多约束排程（APS）平衡设备、人员、物料产能，优化生产计划；</li><li>通过<strong>业务网络平台</strong>实现外包制造协同，实时同步委外生产计划、工序进度与质量数据，确保委外任务与企业主生产计划衔接（如装备制造企业用SAP跟踪委外生产进度）；</li><li>生产部门可<strong>实时获取销售订单与库存数据</strong>，动态调整生产排程，避免库存积压或缺货。</li></ol></li><li><p><strong>全链路可视化与风控</strong>：</p><ol><li>统一看板整合<strong>在制、在途、第三方库存</strong>数据，实时监控供应链运行状态；</li><li>针对异常情况（如物料延迟、设备故障）自动触发跨部门协同（如备件领用、计划调整），降低非计划停机风险。</li></ol></li></ol><h5>三、全业务数字流程贯通</h5><p>SAP通过<strong>系统集成与数据统一</strong>，实现从订单到采购、生产、委外、交付的全业务流程数字化：</p><ul><li><strong>模块无缝衔接</strong>：MM（物料管理）、PP（生产计划）、委外管理等模块集成，打破采购、生产、销售等部门信息孤岛，实现数据实时共享（如生产部门实时获取销售订单安排计划）；</li><li><strong>行业定制化适配</strong>：针对芯片、装备制造等行业，解决采购（原材料寻源）、生产（流程优化）、委外（外包协同）、库存（精细化管理）等核心问题，推动全业务流程标准化；</li><li><strong>智能自动化赋能</strong>：结合AI、RPA等技术，实现订单处理、采购询比价、生产排程等流程自动化，减少人工干预（如芯片企业用SAP提升库存周转率、降低采购错误率）。</li></ul><h4>5，用友聚焦订单核心驱动的供应链链路贯通能力</h4><h5>一、整体能力概述</h5><p>用友聚焦<strong>订单核心驱动</strong>，通过“AI×数据×流程”原生一体的架构，打通“采购-生产-委外”供应链链路，贯通全业务数字流程，将碎片化环节整合为连贯价值链，实现全流程数智化业务闭环管理与数据高效贯通，助力企业提升销售转化率、客户体验及营收增长。</p><h5>二、具体能力解析</h5><h6>1. <strong>订单驱动的供应链全链路贯通</strong></h6><p>以订单为核心，将客户端需求信息整合至系统，传递客户订货信息并跟踪执行状况，打通“采购-生产-委外”全链路：</p><ul><li><strong>采购环节</strong>：基于实时库存与生产需求自动触发补货订单，实现采购与生产计划联动（如制造业MRP驱动采购）；</li><li><strong>生产环节</strong>：通过AI优化排产计划，匹配订单进度与产能；</li><li><strong>委外环节</strong>：动态匹配供应商产能与订单进度，实现委外流程与订单的协同；</li><li><strong>全链路协同</strong>：将采购、生产、委外等环节的孤立数据转化为核心资产，形成“订单需求-流程执行-数据反馈”的闭环。</li></ul><h6>2. <strong>“AI×数据×流程”原生一体的架构支撑</strong></h6><p>依托统一数智底座（如用友BIP5的iuap），贯通智能业务流程、企业数据云与企业AI，实现流程标准化落地与高效协同：</p><ul><li><strong>流程标准化</strong>：通过“流程×数据×AI”三位一体模式，将采购、生产、委外等流程标准化，如三单自动匹配（采购订单、入库单、发票）智能核验，杜绝人为差错；</li><li><strong>数据贯通</strong>：实现全业务数字流程的高效贯通，如凭证自动生成率达89%，业务处理效率提升30%；</li><li><strong>AI智能</strong>：基于实时数据实现“事前预测”（如通过历史订单数据预测原材料需求波动）、智能优化（如库存优化智能体、基于大模型的库存分析诊断），形成“AI优化流程-流程产生数据-数据训练AI”的正向循环。</li></ul><h6>3. <strong>全流程数智化闭环管理</strong></h6><p>通过供应链系统（如用友U8供应链）覆盖采购、生产、委外等全流程管控，与制造、财务、决策支持系统集成，实现产供销、业财税一体化：</p><ul><li><strong>模块覆盖</strong>：包含采购管理、库存管理、委外管理、销售管理等模块，支持从采购申请→询价/招标→订单→到货→入库→发票→付款的标准流程，以及固定资产采购（自动生成资产卡片）、代管采购（VMI）等灵活业务模型；</li><li><strong>协同集成</strong>：采购流程对接预算控制系统，委外进度与财务核算无缝对接，支持产业链上下游协同（如用友BIP供应链云与采购云、制造云、财务云深度融合）；</li><li><strong>风险管控</strong>：AI实时监控供应链节点异常（如库存积压、履约延迟），降低运营风险。</li></ul><h6>4. <strong>行业化与全球化适配</strong></h6><p>支持不同行业与全球化场景的灵活适配，实现规模化交付：</p><ul><li><strong>行业场景</strong>：针对制造业（产供销协同）、零售业（供应商协同快速补货）、项目制造（退货流程优化）等行业，提供细分解决方案，如PTO模型扩展支持订单标的物与交付物区分；</li><li><strong>全球化支持</strong>：采购发票、销售发票对接统一计税引擎，支持海外多税种结算，覆盖40多个国家与地区；</li><li><strong>易交付性</strong>：预置最佳业务流程（如借贷项凭证请求-结算流程），通过低代码平台快速调整流程，响应市场变化。</li></ul><h5>三、能力载体</h5><p>以上能力依托用友<strong>YonSuite</strong>（纯公有云SaaS平台）与<strong>BIP</strong>（商业创新平台）的原生一体化架构实现，前者满足轻量化部署需求，后者为成长型企业提供数智化转型的动力引擎，覆盖财务、人力、供应链等十大核心领域，是企业数智化转型的首选平台。</p><h3>七、结论：没有“最优”，只有“最适配”</h3><p>五大品牌的能力差异源于<strong>核心定位与架构设计</strong>：</p><ul><li>超兔的“原生一体化”适合快速实现订单驱动；</li><li>Salesforce的“CRM+生态”适合销售导向的企业；</li><li>钉钉的“协同+低代码”适合注重内部连接的企业；</li><li>用友的“原生数智化”适合成长型企业的全链路升级；</li><li>SAP的“模块化+行业”适合大型制造企业的深度需求。</li></ul><p>企业需根据<strong>自身规模、行业特性、核心需求</strong>选择适配的方案——订单驱动供应链的本质，是“以客户需求为起点，让供应链成为订单的‘执行者’”，而非“为数字化而数字化”。</p><p><strong>附录：Mermaid流程图——超兔订单驱动供应链流程</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443195" alt="" title="" loading="lazy"/></p><p><strong>附录：Mermaid时序图——SAP订单驱动生产流程</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443196" alt="" title="" loading="lazy"/></p><p><strong>延伸说明：关于超兔一体云：聚焦订单核心驱动，贯通全业务数字流程</strong></p><p>在当今竞争激烈的商业环境中，中小企业面临着诸多挑战，如供应链协同效率低、业务流程不连贯、数据难以整合等。超兔一体云凭借其强大的功能和独特的优势，聚焦订单核心驱动能力，成功打通“采购 - 生产 - 委外”供应链链路，贯通全业务数字流程，为企业提供了高效、智能的管理解决方案。</p><h3>一、订单核心驱动：业务流程的起点与核心</h3><p>超兔一体云以订单为核心驱动力，将整个业务流程串联起来。从市场与获客模块获取线索，经过客户中心的管理和跟单中心的跟进，最终转化为订单。订单管理中心支持多种业务模型的订单逻辑，无论是服务型、实物型还是特殊型订单，都能进行精准管理。</p><h4>（一）订单生成与管理</h4><p>超兔一体云的市场与获客模块通过多渠道集客，如百度广告平台、抖音头条的巨量引擎平台、官网落地页、微信营销等，获取潜在客户线索。线索经过处理后，进入客户中心，通过个性化配置和生命周期管理，筛选出有价值的客户，并进行跟进。跟单中心提供多种跟单模型，如小单快单模型、商机跟单模型、多方项目模型等，帮助企业优化跟单过程，提高订单转化率。一旦订单生成，合同订单管理中心能够对订单进行全面管理，包括订单工作流、待办和日程、订单锁库、采购计划生成、供应商直发等。</p><h4>（二）订单与各模块的关联</h4><p>订单作为核心，与超兔一体云的各个模块紧密关联。在财务管控方面，订单触发应收规则，实现应收、开票、回款的三角联动，管理账期和客户信用度，规避风险。在采购管理中，订单驱动智能采购，根据库存缺口和历史供应商信息，自动计算采购量、匹配供应商、询价比价，实现采购流程的自动化和智能化。在生产管理中，订单送入MES系统进行生产计划排程，通过生产派工、领料、报工、质检、成品入库等流程，确保订单按时交付。</p><h3>二、打通“采购 - 生产 - 委外”供应链链路</h3><p>超兔一体云通过强大的功能和集成能力，成功打通“采购 - 生产 - 委外”供应链链路，实现了供应链的协同运作。</p><h4>（一）采购管理：智能高效的采购流程</h4><p>采购管理模块提供基础功能和智能采购能力。基础功能包括供应商管理、采购单和采购单视图、采购退货和退款管理，支持供应商直发业务模型。智能采购则通过采购计划智能采购和库存总缺口智能采购，自动计算采购量、匹配历史供应商、通过OpenCRM模块询价比价、根据供应商自动拆分采购单。OpenCRM上游连接实现了询价比价、采购单三流合一对账、供应商评级等功能，提高了采购流程的透明度和效率。</p><h4>（二）生产管理：精准高效的生产执行</h4><p>超兔MES系统专为小微生产企业打造，具备智能排程/派工、进度管控、物料管理、生产报工、生产质检、成品入库六大核心能力。订单送入MES系统后，系统根据订单交付时间和产能情况，进行生产计划排程，可采用正排或倒排方式。在生产过程中，通过甘特视图和车间大屏实时监控生产进度，物料管理模块根据生产BOM清单精准计算各工序所需物料数量，实现领料和退料的精准管控。生产报工采用小组计件报工模式，系统自动计算报工数量、工时、良品率，提高了生产效率和数据准确性。</p><h4>（三）委外管理：灵活可控的委外协作</h4><p>超兔一体云支持委外工序，通过与供应商的紧密协作，实现委外业务的灵活可控。在订单管理中心，可将部分工序或产品委托给外部供应商进行生产。采购管理模块可对委外供应商进行管理和评估，确保委外质量和交付时间。生产管理系统可实时跟踪委外进度，与内部生产进度进行协同，保证整个供应链的顺畅运作。</p><h3>三、贯通全业务数字流程</h3><p>超兔一体云通过数据底层连通和强大的集成能力，贯通了全业务数字流程，实现了业务数据的实时共享和协同。</p><h4>（一）数据底层连通</h4><p>超兔一体云包括CRM、进销存、供应链、上下游、收支账、薪资、生产工单等模块，实现了业务和数据的底层连通。各模块之间的数据可以实时同步和共享，避免了数据孤岛的问题。例如，订单数据可以自动同步到财务模块，生成应收凭证；采购数据可以与库存数据实时关联，实现库存的精准管理。</p><h4>（二）集成能力与外部对接</h4><p>超兔一体云具备丰富的集成能力，与ERP、WMS等有对接案例，如金蝶、用友；与电商平台（京东、淘宝等）通过RPA机器人对接；对接国税开票机器人；提供API接口和文档供外部系统对接。通过这些对接，超兔一体云能够与企业现有的系统进行整合，实现数据的流通和共享，进一步贯通全业务数字流程。</p><h4>（三）数据分析与决策支持</h4><p>超兔一体云的数据统计分析引擎包括工作台的数字卡片、图表卡片自定义引擎、同比环比引擎、多表聚合引擎、关联表复合查询引擎、单日KPI引擎等。通过这些引擎，企业可以对业务数据进行深入分析，了解业务状况，发现问题和机会，为决策提供支持。例如，通过订单数据分析，可以了解订单的转化率、毛利率、交付时间等指标，优化订单管理策略；通过采购数据分析，可以评估供应商的绩效，优化采购成本。</p><h3>四、实现逻辑总结</h3><p>超兔一体云聚焦订单核心驱动能力，打通“采购 - 生产 - 委外”供应链链路，贯通全业务数字流程的实现逻辑主要包括以下几个方面：</p><h4>（一）以订单为核心的业务流程设计</h4><p>将订单作为整个业务流程的核心，从订单的生成、管理到执行，各个环节紧密围绕订单展开。通过订单驱动各模块的协同运作，实现业务流程的高效流转。</p><h4>（二）强大的功能模块支持</h4><p>超兔一体云的各个功能模块相互协作，共同支撑订单核心驱动和供应链链路的打通。市场与获客模块提供线索，客户中心和跟单中心跟进客户，订单管理中心管理订单，财务管控、采购管理、生产管理等模块提供相应的支持和保障。</p><h4>（三）数据底层连通和集成能力</h4><p>通过数据底层连通，实现各模块之间的数据实时共享和协同。借助强大的集成能力，与外部系统进行对接，进一步拓展业务范围和数据来源，实现全业务数字流程的贯通。</p><h4>（四）数据分析与决策支持</h4><p>利用数据统计分析引擎对业务数据进行深入分析，为企业提供决策支持。通过数据分析，发现业务中的问题和机会，优化业务流程和策略，提高企业的竞争力和盈利能力。</p><p>超兔一体云通过聚焦订单核心驱动能力，打通“采购 - 生产 - 委外”供应链链路，贯通全业务数字流程，为中小企业提供了一个高效、智能的管理解决方案。它能够帮助企业提高供应链协同效率、降低成本、提升客户满意度，实现数字化转型和可持续发展。</p>]]></description></item><item>    <title><![CDATA[供应链协同：从“链”上舞到“链”上赢——]]></title>    <link>https://segmentfault.com/a/1190000047443203</link>    <guid>https://segmentfault.com/a/1190000047443203</guid>    <pubDate>2025-12-02 12:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>制造业的供应链协同管理，正成为企业竞争力的核心所在。传统供应链模式下，信息壁垒严重、部门协作低效、数据共享滞后等问题，如同一道无形的枷锁，制约着企业的快速响应与灵活调整。尤其是在全球产业链重构与数字化浪潮席卷的当下，供应链协同不再仅仅是“可选项”，而是“必选项”。广域铭岛的供应链协同平台，正是在这一背景下应运而生，通过整合采购、生产、交付等全环节数据，帮助企业实现从“经验驱动”到“数据驱动”的管理升级。<br/>以某头部车企为例，其一级供应商管理过程中长期存在数据不透明、响应速度慢的痛点。供应链停线损失及质量事故成本一度占据整车制造成本的5%-8%。而通过引入广域铭岛的供应链协同平台，该车企实现了多级供应商的实时数据共享与动态响应。供应商交付准时率提升了35%，质量异常从过去的数小时缩短至2小时内响应，极大地降低了库存积压与生产停滞的风险。<br/>更值得关注的是广域铭岛在工业AI领域的创新实践。其Geega工业AI平台通过工艺参数优化、SOP自动生成、质量数据分析等功能模块，推动制造环节从“经验决策”向“数据+算法”转型。例如，在冲压车间，AI视觉防错系统将缺陷检出率提升至99.7%；涂装环节的智能参数推荐则使能耗降低18%。这些技术落地的背后，是供应链协同与工业智能化深度融合的必然结果。<br/>供应链协同平台的另一大亮点是其权限体系设计。在某国际品牌中国工厂的实践中，广域铭岛的专利技术通过为采购端与供应端分别赋予不同权限，既保证了数据的透明交互，又避免了敏感信息的泄露。这种“松耦合”的数据共享模式，让链主企业能够更高效地管理供应商，同时将自身的核心商业机密牢牢守护。<br/>在区域产业集群的数字化转型中，广域铭岛的供应链协同平台同样展现出强大的适应性。通过Geega Plus超融合工作站与GMOM+Geega OS工业操作系统的组合，平台实现了从设备孤岛到全局协同的跨越。某电子制造企业应用后，订单部署周期缩短至7天，库存周转率提升25%，这些数据背后，是供应链协同带来的效率革命。<br/>供应链协同的本质，是打破部门与系统的壁垒，将分散的资源整合为有机整体。广域铭岛的解决方案不仅提供了技术工具，更重要的是构建了一套可落地的协同范式。从研发需求到生产交付，从供应商管理到质量追溯，平台通过统一的数据标准与流程规范，打通了企业与外部伙伴之间的信息链路。<br/>在汽车产业的数字化浪潮中，供应链协同已成为重塑竞争格局的关键变量。随着跨国车企逐步要求二级、三级供应商接入数字化管理系统，广域铭岛的供应链协同平台正在为更多企业提供标准化、模块化的解决方案。从用户体验到生产效率，从成本控制到质量保障，这一平台正在成为制造业供应链管理的“新引擎”。</p>]]></description></item><item>    <title><![CDATA[vsan数据恢复—Vsan超融合架构下的]]></title>    <link>https://segmentfault.com/a/1190000047443207</link>    <guid>https://segmentfault.com/a/1190000047443207</guid>    <pubDate>2025-12-02 12:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>Vsan是基于vSphere内核开发的可扩展分布式存储架构，通过在vSphere集群主机安装闪存和硬盘构建存储层，由vsan控制管理，形成统一共享存储层供集群使用。<br/>vSphere的HA功能可保障单台主机故障时业务在其他主机运行，要求同一虚拟机数据存于不同主机。但多台主机同时故障会致vsan存储崩溃，如突然断电或非正常关机引发虚拟机故障，下文介绍此类故障恢复方式。</p><p><strong>Vsan数据恢复环境与故障：</strong><br/>故障环境为一套含三台服务器节点的VMWAREVSAN超融合架构。每节点配2块SSD与4块机械硬盘，共6块SSD和12块机械硬盘。各节点创建两个磁盘组，每组用1块SSD作缓存盘、2块机械硬盘作容量盘，共6个磁盘组构成VSAN存储空间存储虚拟机文件。<br/>非正常关机导致VSAN中逻辑架构出现故障，部分虚拟机磁盘组件出现问题，导致磁盘文件丢失。</p><p><strong>Vsan数据恢复过程：</strong><br/>1、拆出VSAN节点服务器所有硬盘并编号，接入北亚企安备份服务器，用专业工具软件逐字节镜像备份。<br/>2、分析扫描镜像文件，发现故障虚拟机元数据和组件信息保留完整。<br/>3、VSAN文件以对象存于系统，对象分割为多组件，北亚企安数据恢复工程师编写程序扫描组件信息，记录组件ID与所属对象ID。<br/>4、北亚企安数据恢复工程师编写程序，据组件信息定位数据块及逻辑位置，提取完整组件。<br/>5、按组件描述信息的RAID级别和逻辑位置组合组件，拼接完整vmdk文件。<br/>6、北亚企安数据恢复工程师编写程序，将缓存盘数据刷新到对应组件或对象。<br/>7、合并有快照的vmdk文件的快照和父盘。<br/>8、解析合并后的vmdk文件，提取SQLserver2008R2数据库备份文件。<br/>9、安装SQLserver2008R2数据库，还原备份文件，无报错。用dbcc命令检查数据库完整性，无报错，本次Vsan数据恢复工作完成。</p>]]></description></item><item>    <title><![CDATA[JSAPIThree 数据源系统学习笔记]]></title>    <link>https://segmentfault.com/a/1190000047442858</link>    <guid>https://segmentfault.com/a/1190000047442858</guid>    <pubDate>2025-12-02 11:12:33</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>作为一个刚开始学习 mapvthree 的小白，今天要学习数据源系统了！听说这个系统可以把各种格式的数据加载到地图上，还能让数据可视化！想想就实用！</blockquote><h2>第一次听说数据源系统</h2><p>今天在文档里看到了"数据源"这个词，一开始我还以为是数据库，结果查了一下才知道，原来这是用来存储和加载地理数据的系统！</p><p>文档说数据源系统可以：</p><ul><li>存储带坐标信息的数据</li><li>支持多种数据格式（GeoJSON、JSON、CSV）</li><li>与可视化组件配合使用</li><li>动态添加、删除、修改数据</li></ul><p><strong>我的理解</strong>：简单说就是"数据仓库"，把地理数据存起来，然后给可视化组件用！</p><h2>第一步：理解数据源的基本概念</h2><p>作为一个初学者，我习惯先理解基本概念。文档说 <code>DataSource</code> 是数据源类，用于存储一组带坐标信息的数据。</p><p><strong>我的发现</strong>：数据源通常与可视化组件配合使用：</p><pre><code class="js">// 创建可视化组件
const point = engine.add(new mapvthree.SimplePoint());

// 创建数据源
const dataSource = new mapvthree.DataSource();

// 将数据源赋值给可视化组件
point.dataSource = dataSource;</code></pre><p><strong>我的理解</strong>：数据源存储数据，可视化组件负责渲染，两者配合才能显示数据！</p><h3>DataItem：数据的最小单元</h3><p>文档说 <code>DataItem</code> 是数据的最小单元，用于存储单条数据的信息。</p><pre><code class="js">// 创建一个点数据
const dataItem = new mapvthree.DataItem([116.404, 39.915, 10]);

// 添加到数据源
dataSource.add(dataItem);</code></pre><p><strong>我的理解</strong>：</p><ul><li><code>DataItem</code> 是单条数据</li><li><code>DataSource</code> 是数据集合</li><li>一个数据源可以包含多个 <code>DataItem</code></li></ul><h2>第二步：使用 GeoJSON 数据源</h2><p>看到基本概念后，我想：怎么加载实际的数据？</p><p>文档说可以用 <code>GeoJSONDataSource</code> 来加载 GeoJSON 格式的数据！</p><pre><code class="js">import * as mapvthree from '@baidumap/mapv-three';

const container = document.getElementById('container');
const engine = new mapvthree.Engine(container, {
    map: {
        center: [116.404, 39.915],
        range: 2000,
    },
});

// 创建点图层
const point = engine.add(new mapvthree.SimplePoint({
    size: 15,
}));

// 从 URL 加载 GeoJSON 数据
const dataSource = await mapvthree.GeoJSONDataSource.fromURL('data/geojson/points.geojson');
point.dataSource = dataSource;</code></pre><p><strong>我的发现</strong>：<code>fromURL</code> 是异步方法，需要用 <code>await</code> 等待数据加载完成！</p><p><strong>我的理解</strong>：</p><ul><li><code>fromURL</code>：从 URL 加载数据</li><li><code>fromGeoJSON</code>：直接传入 GeoJSON 对象</li></ul><p><strong>我的尝试</strong>：</p><pre><code class="js">// 方式 1：从 URL 加载
const dataSource1 = await mapvthree.GeoJSONDataSource.fromURL('data/geojson/points.geojson');

// 方式 2：直接传入 GeoJSON 对象
const geojson = {
    type: 'FeatureCollection',
    features: [
        {
            type: 'Feature',
            geometry: {
                type: 'Point',
                coordinates: [116.404, 39.915],
            },
            properties: {},
        },
    ],
};
const dataSource2 = mapvthree.GeoJSONDataSource.fromGeoJSON(geojson);</code></pre><p><strong>我的发现</strong>：两种方式都可以，根据数据来源选择合适的方式！</p><h2>第三步：使用 JSON 数据源</h2><p>看到 GeoJSON 后，我想：如果数据是 JSON 格式怎么办？</p><p>文档说可以用 <code>JSONDataSource</code> 来加载 JSON 格式的数据！</p><pre><code class="js">// 从 URL 加载 JSON 数据
const dataSource = await mapvthree.JSONDataSource.fromURL('data/json/points.json');
point.dataSource = dataSource;</code></pre><p><strong>我的理解</strong>：JSON 数据源需要满足特定格式：</p><ol><li>有坐标字段（默认是 <code>coordinates</code>，可通过 <code>coordinatesKey</code> 指定）</li><li>坐标数据满足 WKT 格式要求</li></ol><p><strong>我的尝试</strong>：</p><pre><code class="js">// JSON 数据格式示例
const jsonData = [{
    coordinates: 'POINT(116.404 39.915)',
    name: '北京',
}, {
    coordinates: 'POINT(121.473 31.230)',
    name: '上海',
}];

const dataSource = mapvthree.JSONDataSource.fromJSON(jsonData);
point.dataSource = dataSource;</code></pre><p><strong>我的发现</strong>：JSON 数据源支持 WKT 格式的坐标！</p><h3>自定义坐标解析</h3><p>如果坐标不是 WKT 格式，可以自定义解析函数：</p><pre><code class="js">const dataSource = mapvthree.JSONDataSource.fromJSON([{
    position: [116.404, 39.915],
    color: 0xff0000,
}, {
    position: '121.473, 31.230',
    color: 0x00ff00,
}], {
    coordinatesKey: 'position', // 指定坐标字段
    parseCoordinates: function({position}) {
        // 自定义解析函数
        if (Array.isArray(position)) {
            return position;
        } else {
            return position.split(',').map(v =&gt; parseFloat(v));
        }
    },
});</code></pre><p><strong>我的发现</strong>：可以自定义解析函数，处理各种格式的坐标数据！</p><h2>第四步：使用 CSV 数据源</h2><p>看到 JSON 后，我想：如果数据是 CSV 格式怎么办？</p><p>文档说可以用 <code>CSVDataSource</code> 来加载 CSV 格式的数据！</p><pre><code class="js">// 从 URL 加载 CSV 数据
const dataSource = await mapvthree.CSVDataSource.fromURL('data/csv/points.csv');
point.dataSource = dataSource;</code></pre><p><strong>我的理解</strong>：CSV 数据源也需要满足特定格式：</p><ol><li>有坐标列（默认是 <code>coordinates</code>，可通过 <code>coordinatesKey</code> 指定）</li><li>坐标数据满足 WKT 格式要求</li></ol><p><strong>我的发现</strong>：CSV 数据源和 JSON 数据源的格式要求类似，都支持 WKT 格式！</p><h2>第五步：定义数据属性</h2><p>看到可以加载数据后，我想：能不能根据数据的不同属性显示不同的样式？</p><p>文档说可以用 <code>defineAttribute</code> 来定义数据属性！</p><pre><code class="js">// 加载数据
const dataSource = await mapvthree.GeoJSONDataSource.fromURL('data/geojson/points.geojson');

// 定义颜色属性
dataSource.defineAttribute('color', 'color');

// 定义大小属性
dataSource.defineAttribute('size', 'size');</code></pre><p><strong>我的理解</strong>：<code>defineAttribute</code> 可以将数据中的字段映射到可视化属性！</p><p><strong>我的尝试</strong>：</p><pre><code class="js">// 创建支持颜色和大小的点图层
const point = engine.add(new mapvthree.SimplePoint({
    vertexColors: true, // 开启颜色属性
    vertexSizes: true,  // 开启大小属性
}));

// 加载数据并定义属性
const dataSource = await mapvthree.GeoJSONDataSource.fromURL('data/geojson/points.geojson');
dataSource.defineAttribute('color', 'color');
dataSource.defineAttribute('size', 'size');

point.dataSource = dataSource;</code></pre><p><strong>我的发现</strong>：需要在可视化组件中开启对应的属性标志（如 <code>vertexColors</code>），才能使用数据属性！</p><h3>使用回调函数定义属性</h3><p>文档说可以用回调函数来动态计算属性值：</p><pre><code class="js">// 使用回调函数定义颜色
dataSource.defineAttribute('color', properties =&gt; {
    // 根据数据动态计算颜色
    return properties.count &gt; 100 ? 0xff0000 : 0x00ff00;
});

// 使用回调函数定义大小
dataSource.defineAttribute('size', properties =&gt; {
    return properties.count * 2;
});</code></pre><p><strong>我的发现</strong>：回调函数可以灵活地根据数据计算属性值！</p><h2>第六步：动态修改数据</h2><p>看到可以加载数据后，我想：能不能动态添加、删除、修改数据？</p><p>文档说数据源提供了 <code>add</code>、<code>remove</code>、<code>setData</code> 等方法来修改数据！</p><pre><code class="js">// 添加数据
const newItem = new mapvthree.DataItem([116.404, 39.915]);
dataSource.add(newItem);

// 删除数据
dataSource.remove(itemId);

// 更新整个数据源
dataSource.setData(newGeoJSONData);

// 修改单个数据的属性
dataSource.setAttributeValues(itemId, {
    color: 0xff0000,
    size: 20,
});

// 修改单个数据的坐标
dataSource.setCoordinates(itemId, [116.414, 39.925]);</code></pre><p><strong>我的发现</strong>：可以动态地添加、删除、修改数据，非常灵活！</p><p><strong>我的尝试</strong>：</p><pre><code class="js">// 点击地图添加点
engine.map.addEventListener('click', e =&gt; {
    if (!e.target) {
        const newItem = new mapvthree.DataItem(e.point);
        dataSource.add(newItem);
    }
});

// 点击点删除
point.addEventListener('rightclick', e =&gt; {
    dataSource.remove(e.entity.value.id);
});

// 点击点修改颜色
point.addEventListener('click', e =&gt; {
    dataSource.setAttributeValues(e.entity.value.id, {
        color: 0xffffff * Math.random(),
    });
});</code></pre><p><strong>我的发现</strong>：结合事件系统，可以实现交互式的数据编辑！</p><h2>第七步：创建自定义数据源</h2><p>看到可以加载各种格式的数据后，我想：能不能手动创建数据源？</p><p>文档说可以直接使用 <code>DataSource</code> 构造函数创建数据源！</p><pre><code class="js">// 创建数据源
const dataSource = new mapvthree.DataSource({
    attributes: {
        color: p =&gt; p.color || 0xffff00,
        size: p =&gt; p.size || 10,
    },
});

// 创建数据项
const item1 = new mapvthree.DataItem([116.404, 39.915], {
    color: 0xff0000,
    size: 20,
});

const item2 = new mapvthree.DataItem([121.473, 31.230], {
    color: 0x00ff00,
    size: 15,
});

// 添加数据项
dataSource.add(item1);
dataSource.add(item2);

// 绑定到可视化组件
point.dataSource = dataSource;</code></pre><p><strong>我的发现</strong>：可以手动创建数据源和数据项，适合动态生成数据的场景！</p><h3>创建不同类型的几何数据</h3><p>文档说 <code>DataItem</code> 可以表示不同类型的几何图形：</p><pre><code class="js">// 点数据
const pointItem = new mapvthree.DataItem([116.404, 39.915]);

// 线数据
const lineItem = new mapvthree.DataItem({
    geometry: {
        type: 'LineString',
        coordinates: [[116.404, 39.915], [121.473, 31.230]],
    },
});

// 面数据
const polygonItem = new mapvthree.DataItem({
    geometry: {
        type: 'Polygon',
        coordinates: [[[116.404, 39.915], [116.414, 39.915], [116.414, 39.925], [116.404, 39.925], [116.404, 39.915]]],
    },
});</code></pre><p><strong>我的发现</strong>：可以创建点、线、面等不同类型的几何数据！</p><h2>第八步：设置数据投影</h2><p>看到可以创建数据后，我想：如果数据的坐标系统不同怎么办？</p><p>文档说可以通过 <code>crs</code> 属性来设置数据的投影信息！</p><pre><code class="js">// 创建使用投影坐标的数据项
const item = new mapvthree.DataItem({
    geometry: {
        type: 'Point',
        coordinates: [12960000, 4850000, 0], // 投影坐标
    },
}, {
    crs: 'EPSG:3857', // 指定投影
});</code></pre><p><strong>我的理解</strong>：引擎会自动将数据从源投影转换到目标投影！</p><p><strong>我的发现</strong>：这样就能处理不同坐标系统的数据了！</p><h2>第九步：完整示例</h2><p>我想写一个完整的示例，把学到的都用上：</p><pre><code class="js">import * as mapvthree from '@baidumap/mapv-three';

const container = document.getElementById('container');

const engine = new mapvthree.Engine(container, {
    map: {
        center: [116.404, 39.915],
        range: 2000,
    },
    rendering: {
        enableAnimationLoop: true,
    },
});

// 创建支持颜色和大小的点图层
const point = engine.add(new mapvthree.SimplePoint({
    size: 15,
    vertexColors: true,
    vertexSizes: true,
}));

// 从 URL 加载 GeoJSON 数据
const dataSource = await mapvthree.GeoJSONDataSource.fromURL('data/geojson/points.geojson');

// 定义属性
dataSource.defineAttribute('color', properties =&gt; {
    return properties.count &gt; 100 ? 0xff0000 : 0x00ff00;
});
dataSource.defineAttribute('size', properties =&gt; {
    return properties.count * 2;
});

// 绑定数据源
point.dataSource = dataSource;

// 点击地图添加点
engine.map.addEventListener('click', e =&gt; {
    if (!e.target) {
        const newItem = new mapvthree.DataItem(e.point, {
            count: Math.random() * 200,
        });
        dataSource.add(newItem);
    }
});

// 点击点修改颜色
point.addEventListener('click', e =&gt; {
    dataSource.setAttributeValues(e.entity.value.id, {
        count: Math.random() * 200,
    });
});</code></pre><p><strong>我的感受</strong>：写一个完整的示例，把学到的都用上，感觉很有成就感！</p><h2>第十步：踩过的坑</h2><p>作为一个初学者，我踩了不少坑，记录下来避免再犯：</p><h3>坑 1：数据源不显示</h3><p><strong>原因</strong>：数据源加载是异步的，在数据加载完成前就绑定了。</p><p><strong>解决</strong>：确保使用 <code>await</code> 等待数据加载完成后再绑定。</p><h3>坑 2：属性不生效</h3><p><strong>原因</strong>：没有在可视化组件中开启对应的属性标志。</p><p><strong>解决</strong>：需要在组件中开启对应的属性标志，如 <code>vertexColors</code>、<code>vertexSizes</code>。</p><h3>坑 3：坐标格式错误</h3><p><strong>原因</strong>：坐标格式不符合要求，或者坐标字段名不对。</p><p><strong>解决</strong>：</p><ol><li>确保坐标格式正确（WKT 格式或数组格式）</li><li>使用 <code>coordinatesKey</code> 指定坐标字段名</li></ol><h3>坑 4：JSON/CSV 数据解析失败</h3><p><strong>原因</strong>：坐标数据不是 WKT 格式，且没有自定义解析函数。</p><p><strong>解决</strong>：使用 <code>parseCoordinates</code> 自定义解析函数。</p><h3>坑 5：数据更新不生效</h3><p><strong>原因</strong>：使用了错误的方法更新数据。</p><p><strong>解决</strong>：</p><ul><li>更新整个数据源：使用 <code>setData</code></li><li>添加/删除数据：使用 <code>add</code>/<code>remove</code></li><li>修改属性：使用 <code>setAttributeValues</code></li><li>修改坐标：使用 <code>setCoordinates</code></li></ul><h2>我的学习总结</h2><p>经过这一天的学习，我掌握了：</p><ol><li><strong>数据源的作用</strong>：存储带坐标信息的数据，与可视化组件配合使用</li><li><strong>DataItem</strong>：数据的最小单元，可以表示点、线、面等几何图形</li><li><strong>GeoJSON 数据源</strong>：最常用的数据格式，支持 <code>fromURL</code> 和 <code>fromGeoJSON</code></li><li><strong>JSON 数据源</strong>：支持 WKT 格式坐标，可以自定义解析函数</li><li><strong>CSV 数据源</strong>：支持 WKT 格式坐标，格式要求与 JSON 类似</li><li><strong>定义属性</strong>：通过 <code>defineAttribute</code> 将数据字段映射到可视化属性</li><li><strong>动态修改</strong>：通过 <code>add</code>、<code>remove</code>、<code>setData</code> 等方法动态修改数据</li><li><strong>数据投影</strong>：通过 <code>crs</code> 属性设置数据投影，引擎自动转换</li></ol><p><strong>我的感受</strong>：数据源系统真的很强大！虽然功能很多，但是用起来其实不难。关键是要理解数据源和可视化组件的关系，然后根据数据格式选择合适的加载方式！</p><p><strong>下一步计划</strong>：</p><ol><li>学习更多数据源的配置选项</li><li>尝试处理复杂的数据格式</li><li>做一个完整的数据可视化项目</li></ol><hr/><blockquote>学习笔记就到这里啦！作为一个初学者，我觉得数据源系统虽然功能很多，但是用起来其实不难。关键是要理解数据源和可视化组件的关系，然后根据数据格式选择合适的加载方式！希望我的笔记能帮到其他初学者！大家一起加油！</blockquote>]]></description></item><item>    <title><![CDATA[Step-Audio-R1：音频深度推理]]></title>    <link>https://segmentfault.com/a/1190000047442867</link>    <guid>https://segmentfault.com/a/1190000047442867</guid>    <pubDate>2025-12-02 11:11:48</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442869" alt="" title=""/></p><p>开发者朋友们大家好：</p><p>这里是 <strong>「RTE 开发者日报」</strong> ，每天和大家一起看新闻、聊八卦。我们的社区编辑团队会整理分享 RTE（Real-Time Engagement） 领域内「有话题的<strong>技术</strong>」、「有亮点的<strong>产品</strong>」、「有思考的<strong>文章</strong>」、「有态度的<strong>观点</strong>」、「有看点的<strong>活动</strong>」，但内容仅代表编辑的个人观点，欢迎大家留言、跟帖、讨论。</p><p><em>本期编辑：@瓒an、@鲍勃</em></p><h2>01有话题的技术</h2><p><strong>1、字节发布视频理解+创作模型 Vidi2：细粒度端到端时空定位能力</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442870" alt="" title="" loading="lazy"/></p><p>字节放出了视频理解+创作模型：Vidi2，主打一个细粒度端到端时空定位能力，支持情节感知自动编辑。</p><p>给定一句话，它能告诉你「在哪一秒、哪个框」出现过，还能直接帮你剪出片段、重构图谱，长视频也能秒级处理。</p><p>就是给出文本查询，模型会同时返回起止时间戳和每帧目标对象的边界框。</p><p>比如说，你可以扔给它一段长视频，让它一键剪成 TikTok 竖屏短片，自动剪辑裁框、加字幕。</p><p>也可以输入个主题，让它自动出标题、钩子、分镜脚本。</p><p>像剪辑师找素材，就可以从人工拉轨变成了一句话搜索。</p><p>在 VUE-STG 和 VUE-TR-V2 上，超过 Gemini3Pro（Preview）、GPT-5。</p><p>( @aigclink\@X)</p><p><strong>2、StepFun 发布 Step-Audio-R1：音频大模型实现深度推理，比肩 Gemini 3 Pro</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442871" alt="" title="" loading="lazy"/></p><p>阶跃星辰（StepFun）近日发布了其首个开源音频深度推理模型 Step-Audio-R1。该模型通过创新的「模态锚定推理蒸馏」（MGRD）框架，解决了现有音频大模型在复杂推理任务上表现不佳的「反常缩放」问题，实现了基于声学特征的深度推理，并在多项音频理解与推理基准测试中超越 Gemini 2.5 Pro，比肩 Gemini 3 Pro。</p><ul><li><strong>音频推理「反常缩放」被打破</strong>： Step-Audio-R1 成功解决了音频大模型在思维链（CoT）推理中「想得越多，错得越多」的现象。研究发现，现有模型并非真正进行音频推理，而是依赖转录文本，导致「模态脱节」。</li><li><strong>「模态锚定推理蒸馏」（MGRD） 框架</strong>： 创新框架引导模型从依赖文本转向直接基于声学特征（如音色、音高、节奏）进行推理，通过感知驱动数据筛选、思维链筛选、监督微调和强化学习等迭代优化，实现「用耳朵思考」。</li><li><strong>架构与技术细节</strong>： Step-Audio-R1 基于 Qwen2 音频编码器和 Qwen2.5 32B LLM 解码器，通过音频适配器连接，核心创新在于 MGRD 训练方法，确保 LLM 生成的推理过程依据真实的声学信号。</li><li><strong>卓越的性能表现</strong>： 在语音转文本（S2T）基准测试中，Step-Audio-R1 平均得分 83.6%，超越 Gemini 2.5 Pro。实时版本（Step-Audio-R1 Realtime）在 S2S 测试中得分 96.1%，首包延迟仅 0.92 秒，展现出极具竞争力的实时交互能力。</li></ul><p>（@语音之家）</p><p><strong>3、通义新生图模型 Z-Image 上架</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442872" alt="" title="" loading="lazy"/></p><p>日前，阿里通义宣布，其最新生图模型 Z-Image 正式上架。</p><p>官方介绍，Z-Image 是一款开源、免费的高效图像生成基础模型，参数量为 6B。模型可在 16GB 显存的消费级显卡上，生成品质可与顶级商业模型相媲美的超真实图像，尤其在中英双语文本渲染方面效果突出。</p><p>同时，Z-Image 具备对现实世界的广泛认知，能准确生成著名地标（如埃菲尔铁塔、故宫）、知名人物及特定文化元素（如春节窗花、英式电话亭），确保画面在细节、比例与语境上符合真实常识。</p><p>通过提示词增强器（Prompt Enhancer），Z-Image 还能处理「鸡兔同笼」逻辑题、古诗「小桥流水人家」可视化等复杂任务，让 AI 不只是「画图」，而是「理解后创作」。</p><p>目前 Z-Image 已上架 GitHub、Hugging Face、ModelScope。值得一提的是，模型在上线后迅速登顶 Hugging Face 趋势榜双榜第一，模型发布首日下载量达 50 万。</p><p>GitHub: <br/><a href="https://link.segmentfault.com/?enc=BEvJOUmATC0oCbhqiqjDFg%3D%3D.Q3aSbu7P%2FQiQEvrW%2BjxP0DXPGNVqdfZDogkinx5fTpN2h07HKIOJI9l6NXyVfQKH" rel="nofollow" target="_blank">https://github.com/Tongyi-MAI/Z-Image</a></p><p>Hugging Face: <br/><a href="https://link.segmentfault.com/?enc=CwQOmmAxQpw7Lb7PrENcPQ%3D%3D.%2BBYHLtrediYXczBoaQgcKwlDHefqS1RxkOoeL87qm2HnaWxrOZGSkft2JEMZ0kFe" rel="nofollow" target="_blank">https://huggingface.co/Tongyi-MAI/Z-Image-Turbo</a></p><p>ModelScope: <br/><a href="https://link.segmentfault.com/?enc=2M6xElb7tSRLdYwZFRRS6Q%3D%3D.7M6OGewBkCKG%2F3eCcE8yGLGFXD%2F26t1PVXKIxhPqV5NkLWIm6hs7Rsoyygr%2FzT7h8mEBcEZcLkTkSlpCqg%2BnPA%3D%3D" rel="nofollow" target="_blank">https://www.modelscope.cn/models/Tongyi-MAI/Z-Image-Turbo</a></p><p>( @APPSO)</p><h2>02有亮点的产品</h2><p><strong>1、Soul 冲刺港交所：国内领先的「AI+沉浸式社交平台」，累计注册用户达 3.9 亿</strong></p><p>据 IPO 早知道消息，Soulgate Inc。（以下简称「Soul」）于 2025 年 11 月 27 日向港交所递交招股说明书，拟主板挂牌上市，中信证券担任独家保荐人。</p><p>成立于 2015 年的 Soul 作为一家 AI+沉浸式社交平台，基于用户的兴趣和个性，并依托先进的 AI 模型及算法，打造了一个 AI 驱动的、温暖的情绪绿洲。弗若斯特沙利文报告显示，<strong>Soul 是国内首个所有用户均以虚拟身份（avatars）进行互动的 AI+沉浸式社交网络平台。</strong></p><p>另外需要指出的一点是，<strong>AI 技术是 Soul 在沉浸式情绪经济领域快速发展的核心引擎</strong>——Soul 自研原生情绪价值第一大模型 Soul X 极大地提升了用户体验与社区活跃度。用户的高参与度推动模型和算法持续优化，及 AI 应用的智能化，加速平台数字社会的繁荣和用户体验提升，拓宽 AI 赋能下情绪经济商业化的潜在市场空间，赋能广告及 IP 生态等业务增长，形成了独特的「用户–AI–平台」飞轮体系，实现商业化复利效应。</p><p><strong>截至 2025 年 8 月 31 日，Soul 已累计拥有约 3.9 亿名注册用户，截至同日的日均活跃用户数 1100 万，其中 78.7%为 Z 世代用户。</strong></p><p>根据弗若斯特沙利文的报告，今年前 8 个月，Soul 的平均日活跃用户数、用户平均每日启动次数以及新安装用户的 30 日留存率均在中国 AI+沉浸式社交平台中排名第一。</p><p>值得注意的是，<strong>AI 驱动的情绪价值服务（包括虚拟物品及会员特权）为平台主要收入来源，于今年前 8 个月的占比超九成，每名付费用户的月均收入（ARPPU）为 104.4 元，反映用户对情绪价值服务的强付费意愿。</strong></p><p>成立至今，Soul 已获得腾讯、米哈游、元生资本、五源资本、魔量资本、纪源资本、简鸣资本、DST 旗下 Apoletto Asia Ltd、雯科创投、光源创新基金等知名机构的投资。其中，腾讯作为战略投资者持有 Soul 49.9%的股份，但不参与日常管理及业务运营。</p><p>Soul 在招股书中表示，IPO 募集资金将主要用于：加强 AI、GPU 和数据分析等技术研发与人才建设；拓展全球市场，提升用户陪伴体验；扩大和留存用户群体，强化品牌以实现优质增长；丰富平台内容，通过创新吸引用户；以及用于运营资金和一般公司用途。</p><p>（@IPO 早知道）</p><p><strong>2、豆包手机助手发布技术预览版</strong></p><p>今天豆包手机助手以技术预览版的形式首次和大家见面。</p><p>豆包手机助手是豆包和手机厂商在操作系统层面合作的手机 AI 助手。基于豆包大模型的能力和手机厂商的授权，豆包手机助手能够为用户带来更方便的交互和更丰富的体验。</p><p>通过以下这支视频，可以了解豆包手机助手。</p><p>目前，搭载豆包手机助手技术预览版的工程样机 nubia M153 少量发售，供开发者和感兴趣的朋友体验豆包手机助手。</p><p>需要强调的是，这只是一款方便大家体验豆包手机助手使用的工程样机。豆包没有开发手机的计划，而是正在和多家手机厂商推进手机助手的合作落地计划。</p><p>未来豆包仍将持续优化模型的速度和能力，在不久的将来和更多合作伙伴一起为大家带来完善、成熟的豆包手机助手。</p><p>（@豆包）</p><hr/><h2>03有态度的观点</h2><p><strong>1、吴恩达：AI 有没有泡沫，要看大家怎么用</strong></p><p>近期，斯坦福大学计算机科学系副教授吴恩达在个人社交媒体账号，发表了自己对于 AI 泡沫这一热门话题的看法。</p><p>现如今，随着 OpenAI 高达 1.4 万亿美元的基建计划，以及英伟达市值短暂触及 5 万亿美元大关，越来越多的声音开始质疑：炒作和投机是否已将 AI 投资推高到了不可持续的水平？</p><p>对此，吴恩达就给出了自己的看法：AI 并非铁板一块，而不同领域的泡沫程度各不相同。其列出了以下观点：</p><p><strong>AI 应用层：投资不足。</strong> 其潜力远超大多数人的认知。吴恩达预测，未来十年，将会有许多基于新 AI 技术构建的应用尚未建成。「几乎可以断言，基于 AI 基础设施/技术（如 LLM API）构建的应用必须比基础设施更有价值。」</p><p><strong>AI 推理基础设施：仍需大量投资。</strong> 吴恩达指出，现阶段尽管目前 AI 的渗透率较低，但基础设施供应商已经难以满足对处理能力以生成 token 的需求。</p><p><strong>AI 模型训练基础设施：持谨慎乐观态度，但可能存在泡沫。</strong> 吴恩达坦言，如果 AI 技术栈的一部分（或许是在训练基础设施）因过度投资而崩溃，它可能导致对 AI 更广泛的负面市场情绪，以及尽管该领域整体具有强劲的基本面，但人们对投资 AI 的理性兴趣出现非理性外流。</p><p>(@APPSO)</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442873" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442874" alt="" title="" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=18Wj%2FhNXOJ9r9JFpLg5EuQ%3D%3D.UI27nucTJkTHDknkfBQ9gk6ET04eYRtGS7Z%2F%2FKl7vu4%3D" rel="nofollow" target="_blank">阅读更多 Voice Agent 学习笔记：了解最懂 AI 语音的头脑都在思考什么</a></p><p><strong>写在最后：</strong></p><p>我们欢迎更多的小伙伴参与 <strong>「RTE 开发者日报」</strong> 内容的共创，感兴趣的朋友请通过开发者社区或公众号留言联系，记得报暗号「共创」。</p><p>对于任何反馈（包括但不限于内容上、形式上）我们不胜感激、并有小惊喜回馈，例如你希望从日报中看到哪些内容；自己推荐的信源、项目、话题、活动等；或者列举几个你喜欢看、平时常看的内容渠道；内容排版或呈现形式上有哪些可以改进的地方等。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442875" alt="" title="" loading="lazy"/></p><p>作者提示: 个人观点，仅供参考</p>]]></description></item><item>    <title><![CDATA[一体化陪玩系统源码小程序：线上互动 + ]]></title>    <link>https://segmentfault.com/a/1190000047442881</link>    <guid>https://segmentfault.com/a/1190000047442881</guid>    <pubDate>2025-12-02 11:11:09</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在陪玩行业竞争日趋激烈的当下，“运营效率” 成为创业者拉开差距的核心关键。传统陪玩平台常陷入 “线上匹配混乱、线下核销繁琐、运营数据模糊” 的困境，导致用户流失率高、盈利效率低。而一体化陪玩源码系统小程序，通过整合 “线上互动、线下核销、数据统计” 三大核心模块，构建起全链路自动化运营体系，彻底解决传统模式的效率痛点，让创业者无需投入大量人力，即可实现 “精准获客、高效转化、科学决策”，成为陪玩赛道降本增效的核心利器。</p><h4><a href="https://link.segmentfault.com/?enc=Owxgi4zdjLhHGP%2BvqNz4fQ%3D%3D.gg5B7lRhGOPzqR4n8tHVGi8V7zPHdnOHYOpgEEs2X2x0cm%2BdS5rKnavkq27kWB1K" rel="nofollow" target="_blank">陪玩系统源码演示地址！！</a></h4><p><img width="723" height="697" referrerpolicy="no-referrer" src="/img/bVdjmAq" alt="" title=""/></p><h3>一、核心模块：功能协同，构建高效运营闭环</h3><p>一体化陪玩源码系统小程序的核心优势，在于 “线上互动、线下核销、数据统计” 三大模块的深度协同，形成 “引流 - 转化 - 复购 - 决策” 的全链路运营闭环，让每一个环节都高效运转。</p><h4>（一）线上互动模块：精准匹配 + 趣味互动，提升用户粘性与转化</h4><p>线上互动是平台的 “流量入口”，源码系统通过功能优化，实现 “匹配更精准、互动更有趣、转化更高效”：<br/><strong>多维精准匹配</strong>：突破传统 “单一段位匹配”，构建 “游戏类型 + 玩法偏好 + 性格标签 + 线下需求” 的四维匹配体系。用户输入 “王者荣耀 + 上分冲刺 + 性格开朗 + 可线下约玩”，系统 3 秒内推送同城符合条件的陪玩师，匹配准确率提升至 85%，试玩转化率翻倍；<br/><strong>高清稳定互动</strong>：内置专业语音引擎，支持 2-10 人多人连麦，语音延迟低于 100ms，无卡顿、无杂音；同时集成 “语音变声、背景音乐、战绩同步” 等趣味功能，用户与陪玩师互动粘性显著提升，线上复购率从 15% 提升至 35%；<br/><strong>自动化引流工具</strong>：内置 “社交裂变” 功能，用户邀请好友注册可获得 “陪玩时长券”，陪玩师分享个人主页可解锁 “优先接单权”，通过双向裂变实现低成本获客，无需创业者额外投入推广费用。</p><h4>（二）线下核销模块：全流程自动化，降本增效零误差</h4><p>线下核销是连接线上订单与线下服务的关键环节，源码系统通过技术手段实现 “订单确认、场馆对接、费用结算” 全自动化，彻底解放人力：<br/><strong>订单自动同步</strong>：用户预约线下陪玩后，订单信息（人数、时间、场馆、陪玩师）自动同步至小程序后台、陪玩师端、合作场馆端，三方实时同步，无需人工传达，避免信息偏差；<br/><strong>智能核销机制</strong>：用户到店后扫描场馆专属 “核销码”，系统自动确认到店、启动服务计时；服务结束后，费用（陪玩时薪 + 场馆费 + 路程费）自动结算，支持微信、支付宝一键支付，还可选择 AA 制分摊，核销效率提升 80%，错单率降至 0；<br/><strong>线下权益保障</strong>：核销后系统自动推送 “服务评价” 入口，用户评价实时同步至平台，陪玩师线下服务差评率超过 5% 将被限制接单；同时支持 “不满意免单” 申请，平台根据核销记录与服务时长快速处理，用户投诉率降低 60%。<br/><img width="723" height="697" referrerpolicy="no-referrer" src="/img/bVde3K7" alt="" title="" loading="lazy"/><img width="723" height="697" referrerpolicy="no-referrer" src="/img/bVde3K6" alt="" title="" loading="lazy"/></p><h3>二、运营优势：降本增效，创业者轻松当 “甩手掌柜”</h3><p>一体化陪玩源码系统小程序的核心价值，在于通过 “自动化、标准化、数据化” 运营，帮助创业者大幅降低运营成本，提升盈利效率：<br/><strong>人力成本降低 60%</strong>：线上匹配、订单同步、核销结算、数据统计全自动化，无需雇佣专门的运营团队，1-2 人即可管理整个平台；<br/><strong>用户转化提升 40%</strong>：精准匹配 + 趣味互动 + 便捷核销，让用户从注册到复购的全流程体验丝滑，新用户 30 天复购率从 15% 提升至 35%；<br/><strong>决策效率提升 80%</strong>：数据看板实时更新，运营问题一目了然，营销活动、服务调整有数据支撑，避免盲目试错，投入产出比提升 50%。</p>]]></description></item><item>    <title><![CDATA[数字化服务商如何助力企业工艺优化？ 雨大]]></title>    <link>https://segmentfault.com/a/1190000047442897</link>    <guid>https://segmentfault.com/a/1190000047442897</guid>    <pubDate>2025-12-02 11:10:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>制造业的工艺优化一直是企业提升竞争力的核心环节，然而传统工艺优化模式在数据整合、流程协同和效率提升等方面面临诸多挑战。设计变更频繁导致工艺文件反复修改，工程师在手动校核图纸、测算工时和生成作业指导书的过程中耗费大量时间，而这些重复性劳动往往无法直接推动工艺创新。在此背景下，AI驱动的工艺优化解决方案逐渐成为行业变革的关键支点，其核心在于通过数字化手段重构工艺流程，实现从设计到交付的全链路升级。<br/>近年来，工业互联网平台的兴起为工艺优化提供了新的可能性。以广域铭岛Geega工艺专家数智引擎系统为例，该系统通过融合人工智能技术与工业场景，将工艺优化从单点突破延伸至全局协同。在电池制造领域，其多模态数据处理能力帮助某厂商将电解槽槽况分析效率提升75%，非计划停机次数减少75%，这不仅源于设备数据的实时采集，更得益于AI对工艺参数漂移的动态预警与优化。<br/>工艺优化的难点之一在于工序编排与参数校核的复杂性。传统工艺路线依赖工程师经验手动编排，效率低下且易出错。而Geega系统通过智能算法自动生成装配顺序与工艺参数，例如在某汽车零部件生产线中，其动作仿真功能将工时测算周期从数周缩短至40分钟，并输出符合人因工程的优化方案。这种以数据驱动替代经验驱动的模式，不仅确保了工艺标准的一致性，还显著降低了因参数不当导致的质量风险。<br/>在产线平衡与资源调度方面，制造业长期存在负荷不均、设备利用率低的问题。Geega系统通过运筹优化算法对工序进行动态排布，例如在某新能源汽车工厂中，其线平衡计算功能将产线等待时间从15分钟压缩至3分钟，设备利用率提升至92%。同时，基于3D工艺引擎生成的可视化作业指导文件，操作人员错误率下降40%，这得益于AI强化学习算法对作业流程的精准建模与实时反馈。<br/>值得注意的是，工艺优化并非单纯依赖技术工具，而是需要构建完整的数字化服务体系。Geega捷做设计研发协同平台与Geega工艺专家系统的结合，形成了覆盖需求转化、设计校核、工艺规划、产线优化和交付执行的闭环能力。例如，在某电子电装企业中，设计变更影响管控时间从原来的数天缩短至数小时，这背后是AI对多系统数据的实时关联与风险预判。<br/>然而，AI工艺优化的落地仍需解决标准适配与跨行业迁移的问题。不同制造业的工艺逻辑存在差异，单一平台难以覆盖所有场景。此时，数字化服务商的价值便凸显出来，他们通过行业Know-How的积累，将通用算法与企业特定需求相结合。以广域铭岛为例，其解决方案已从汽车产业链延伸至新能源电池、电子电装等领域，并持续完善针对细分行业的定制化模型。<br/>工艺优化正朝着更高智能化的方向发展。AI不仅需要处理单点问题，更要实现全链路的数据协同与价值重构。例如，通过整合设计变更、工艺执行和生产反馈数据，形成动态优化的闭环系统，让工程师从繁琐操作中解放，专注于创新性工艺突破。这种趋势下，企业需选择具备跨行业经验与持续迭代能力的数字化服务商，才能真正实现工艺优化的提质增效。<br/>总而言之，AI驱动的工艺优化正在重塑制造业的创新模式。从设计校核到产线平衡，从标准制定到质量管控，数字化工具的深度应用已为企业带来显著效益。在这一过程中，广域铭岛等服务商凭借其技术积累与行业实践，为制造企业提供了一条可量化的智能化升级路径。</p>]]></description></item><item>    <title><![CDATA[对比国内外十大热门CRM系统 闷骚的绿茶]]></title>    <link>https://segmentfault.com/a/1190000047442905</link>    <guid>https://segmentfault.com/a/1190000047442905</guid>    <pubDate>2025-12-02 11:09:25</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>当前，国内外 CRM 系统市场呈现出百花齐放的景象。种类繁多的 CRM 系统满足了不同企业的多样化需求。在国外，CRM 系统发展较早且较为成熟。其发展历程经历了数据库营销时代、联系管理软件时代、自动化销售力支持系统时代、全方位 CRM 系统时代以及云计算和移动技术时代。国外市场上的主要 CRM 软件供应商，如 Salesforce、Oracle、SAP 等，提供了从前端销售、市场营销到后端客户服务的全方位解决方案，且大多基于云基础设施支持，帮助企业实现数据集中管理和分析。<br/>在国内，CRM 市场起步较晚但发展速度惊人。起初，中国企业对 CRM 的应用主要集中在客户数据收集和简单管理，功能相对单一。随着时间推移，国内市场涌现出多家 CRM 软件供应商，既有国际品牌如 Salesforce、SAP 等，也有本土企业如销售易、用友、金蝶等。这些系统不仅覆盖多个领域，还集成了社交媒体、大数据分析等新兴技术，以支持企业实现更精细化的客户管理和服务。近年来，云基础的 CRM 解决方案因其灵活性、可扩展性和成本效益，受到越来越多企业的青睐。</p><p>国内热门 CRM 系统盘点</p><p>（一）销售易 CRM<br/>销售易在国内 CRM 市场中占据重要地位。其以 “大而全” 的 SaaS+PaaS 平台级能力著称，尤其擅长业务通用与行业化发展方向。2019 年获得腾讯投资后，销售易加大了市场推广力度，从最初针对中小微企业，逐渐推出基于 PaaS 平台的教育、金融等五大行业解决方案，拓展向中型企业客户。销售易是企业级 CRM 领域融合新型互联网技术的先驱，巧妙应用人工智能、大数据、物联网等新型互联网技术，构建了整合营销、销售和服务管理的企业级 CRM 平台。主打移动 CRM、新零售、企业微信 SCRM，支持 PaaS 平台定制，为企业提供了强大的客户关系管理解决方案。<br/>（二）白码 CRM<br/>白码 CRM 具有灵活的 CRM 功能，包括客户管理、销售自动化、数据分析和定制报告等。其界面友好，支持多种数据集成和 API 调用，能够满足企业根据具体需求快速定制和调整 CRM 系统的要求。这使得白码 CRM 非常适合需要快速响应市场变化的中小企业及大型企业。例如，在快速变化的市场环境中，企业可以利用白码 CRM 的数据集成功能，将不同来源的数据整合到一起，进行全面的分析和决策。同时，通过 API 调用，企业可以与其他业务系统进行无缝对接，实现数据的共享和业务流程的整合。<br/>（三）悟空 CRM<br/>悟空 CRM 作为国内开源 CRM，具有诸多特点。首先，它提供基础的客户关系管理功能，适合预算有限且有一定技术实力的企业自行定制开发。国内首家支持 PHP/JAVA 两种开发语言的多语言 CRM 系统，核心代码库完全公开，随时下载，开源代码通常也更加安全，200 万 + 的用户已经帮您彻底审查。悟空 CRM 社区还能帮助企业解决产品及代码疑问。例如，一些小型科技企业可以利用悟空 CRM 的开源特性，根据自身业务需求进行定制开发，既满足了客户关系管理的需求，又节省了成本。<br/>（四）用友 CRM<br/>用友 CRM 在客户全生命周期管理方面表现出色，提供营销活动和费用闭环管理等功能。尤其擅长财务管理与 CRM 的结合，助力企业实现数字化转型。用友作为国内上市企业，在财务软件领域具有较高的知名度和市场占有率。其 CRM 产品能够与财务软件等进行深度集成，为企业提供全面的管理解决方案。例如，企业可以通过用友 CRM 对客户的销售过程进行管理，同时结合财务软件对销售费用进行管控，实现营销活动和费用的闭环管理。<br/>（五）神州云动 CRM<br/>神州云动 CRM 提供全面的客户生命周期管理，支持销售自动化、市场活动管理、服务支持及业绩分析等多个方面。同时，拥有 PaaS 平台，支持企业快速开发和部署定制应用。神州云动 CloudCC 致力于高效实现大型企业复杂业务场景，助推上市公司和行业领军企业的数字化转型。其客户群涵盖多个行业，早期作为 Salesforce 在国内的实施服务提供商，后来推出了自己的 SaaS 版 CRM，适合各类大中小型企业，也有很多私有化部署的案例。<br/>（六）金蝶 CRM<br/>金蝶 CRM 由企服行业大厂金蝶打造，集成能力强，可与企业现有的 ERP、SCM 等系统无缝集成，适合大型企事业单位。金蝶是香港联交所上市公司，在国内以财务软件提供商的身份为人熟知。虽然 CRM 系统只是其产品线的辅助而非核心业务，但金蝶 CRM 在集成方面的优势依然明显。例如，大型制造企业可以利用金蝶 CRM 与企业现有的 ERP 系统集成，实现客户关系管理与生产管理、供应链管理等的协同运作。<br/>（七）销帮帮 CRM<br/>销帮帮 CRM 拥有灵活的 “PaaS + 低代码” 平台，支持快速适应不同企业的特定需求。提供强大的数据分析和报告功能，助力企业精准洞察市场与客户。销帮帮是国内 CRM 及企服领域知名品牌，致力于用先进的云计算、社交化、移动化与数智化技术为企业客户提供营销与客户数字化解决方案。例如，中小企业可以利用销帮帮 CRM 的 “PaaS + 低代码” 平台，快速搭建符合自身业务需求的客户关系管理系统，提高企业的运营效率。<br/>三、国外热门 CRM 系统盘点</p><p>（一）Salesforce<br/>Salesforce 作为全球领先的 CRM 提供商，拥有强大的功能。它提供了全面的客户关系管理功能，包括销售自动化、客户服务、市场营销等全方位解决方案。例如，Salesforce 的销售自动化工具可以帮助企业高效管理销售流程，从线索生成到交易完成，实现销售过程的自动化和优化。同时，客户服务模块能够实时跟踪客户反馈和投诉，提供快速响应和解决方案，提升客户满意度。<br/>Salesforce 的平台具有极高的灵活性和可扩展性。用户可以自定义工作流程、界面和数据模型，以符合企业独特的业务流程需求。通过 AppExchange 市场，用户可以选择和安装各种第三方应用，大大拓展了平台的功能。全球众多企业对 Salesforce 给予高度评价，其广泛的全球市场经验和成熟的技术，使其成为大型跨国公司和企业的首选。<br/>（二）Zoho CRM<br/>Zoho CRM 以其简单易用且功能全面的特点深受中小企业欢迎。它涵盖了线索管理、销售自动化、客户支持等模块，能够满足中小企业在客户关系管理方面的基本需求。同时，Zoho CRM 具有高度可定制性，企业可以根据自身业务流程和需求，自定义字段、表单、视图、工作流等。<br/>Zoho CRM 支持多语言多币种，这对于有跨国业务的中小企业来说非常实用。它能够有效消除跨国业务的复杂性，轻松整合来自不同国家和地区的金融数据，减少手动转化的操作，提高团队工作效率。例如，企业可以使用基准货币（人民币）生成销售报告，使数据更加一致。<br/>（三）Microsoft Dynamics 365<br/>Microsoft Dynamics 365 作为微软旗下的 CRM 产品，与 Office 365 等微软产品无缝集成，为企业提供了强大的数据分析与智能洞察能力。例如，通过与 Outlook、Excel、Teams 和 Azure 等工具的集成，企业能够方便地在熟悉的环境中进行工作和协作，提高团队的工作效率和信息共享能力。<br/>Dynamics 365 的数据分析功能可以帮助企业做出更加智能的业务决策。内置的 AI 模块和客户洞察功能，能够让用户更好地理解客户需求、预测销售机会、优化市场营销策略，从而提高客户满意度和销售业绩。对于已经使用微软生态的企业来说，Dynamics 365 是一个理想的选择，能够实现业务流程的无缝衔接和协同运作。</p>]]></description></item><item>    <title><![CDATA[MCP Server中正确调用已注册的R]]></title>    <link>https://segmentfault.com/a/1190000047442909</link>    <guid>https://segmentfault.com/a/1190000047442909</guid>    <pubDate>2025-12-02 11:08:43</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在MCP Server中，Resource（资源）主要用于为AI提供静态或半静态的上下文信息。与主动执行的Tool（工具）不同，Resource更多是被“读取”和“引用”的。</p><p>为了让你快速理解核心区别，请看下表：</p><table><thead><tr><th align="left">特性</th><th align="left">Resource (资源)</th><th align="left">Tool (工具)</th></tr></thead><tbody><tr><td align="left"><strong>核心用途</strong></td><td align="left">提供<strong>只读</strong>的上下文、文档或数据。</td><td align="left">执行一个<strong>动作</strong>，如查询、计算或修改。</td></tr><tr><td align="left"><strong>类比</strong></td><td align="left">一本书、一份报告、一个数据库视图。</td><td align="left">一个可以调用的函数或API。</td></tr><tr><td align="left"><strong>MCP操作</strong></td><td align="left"><code>resources/list</code>, <code>resources/read</code></td><td align="left"><code>tools/list</code>, <code>tools/call</code></td></tr><tr><td align="left"><strong>数据流向</strong></td><td align="left">从Server流向Client/LLM。</td><td align="left">双向：Client传递参数，Server返回结果。</td></tr></tbody></table><h3>🔧 如何注册与调用 Resource</h3><p>整个流程分为Server端注册和Client端调用两部分，如下图所示：</p><pre style="display:none;"><code class="mermaid">flowchart LR
    subgraph S[Server端：注册资源]
        A[定义资源函数] --&gt; B[“使用装饰器&lt;br&gt;@mcp.resource(uri_template)注册”]
        B --&gt; C[“服务器启动后&lt;br&gt;在初始化中声明资源能力”]
    end

    subgraph C[Client端：发现与调用]
        D[“调用 resources/list&lt;br&gt;获取资源列表”] --&gt; E[“找到所需URI&lt;br&gt;如 echo://static”]
        E --&gt; F[“调用 resources/read&lt;br&gt;传入URI获取内容”]
    end

    C -.-&gt; F</code></pre><p>下面我们结合代码，看看流程中的具体步骤。</p><p><strong>1. 在Server端注册Resource</strong><br/>你需要使用MCP SDK（如Python的<code>mcp</code>库）来注册资源。以下代码定义了两个资源：一个提供固定内容，另一个根据动态URI提供内容。</p><pre><code class="python">from mcp.server.fastmcp import FastMCP
mcp = FastMCP("Demo Server")

# 注册一个静态资源，URI为 `echo://static`
@mcp.resource("echo://static")
def get_static_resource() -&gt; str:
    return "这是一个静态的文本资源。"

# 注册一个模板化资源，URI如 `echo://user_input`
@mcp.resource("echo://{text}")
def get_dynamic_resource(text: str) -&gt; str:
    return f"你请求的内容是: {text}"</code></pre><p>服务器启动时，会在初始化响应中声明其具备 <code>resources/list</code> 和 <code>resources/read</code> 的能力，供客户端发现。</p><p><strong>2. 在Client端调用Resource</strong><br/>客户端（如AI助手或你的程序）首先列出资源，然后读取指定资源。以下是在Qwen-Agent框架中调用资源的示例：</p><pre><code class="python"># 1. 列出所有可用资源
resources = await client.session.list_resources()
# 返回示例: [{"uri": "echo://static"}, {"uri": "echo://hello"}]

# 2. 读取指定URI的资源内容
content = await client.session.read_resource(uri="echo://static")
# 返回内容: "这是一个静态的文本资源。"</code></pre><p>在实际使用中，你可以直接将资源的URI提供给LLM。LLM会根据对话上下文，决定是否需要通过客户端读取相关资源来获取信息。</p><h3>💡 高级用法与最佳实践</h3><ul><li><strong>性能优化</strong>：对于需要频繁访问的远程资源，客户端可以采用<strong>连接池管理</strong>，避免频繁建立连接。同时，合理设置 <code>sse_read_timeout</code> 等参数可以防止长时间阻塞。</li><li><strong>动态更新</strong>：一些高级部署方案（如结合MSE Nacos）支持在服务器运行期间动态更新Resource列表及其描述，而无需重启服务。</li><li><strong>错误处理</strong>：在客户端调用<code>read_resource</code>时，务必做好异常处理。例如，资源不存在、服务器未响应或权限认证失败（如果开启了鉴权）等情况都需要妥善处理。</li></ul><h3>📝 核心要点总结</h3><p>总而言之，在MCP中调用Resource的本质是：</p><ol><li><strong>服务端注册</strong>：用URI模式标识资源，函数返回内容。</li><li><strong>客户端发现</strong>：通过<code>list_resources</code>获取可用资源列表。</li><li><strong>客户端读取</strong>：通过<code>read_resource</code>并传入具体URI获取内容。</li></ol><p>这种机制非常适用于为LLM注入知识库、文档、配置信息等静态上下文，与用于执行操作的Tool相辅相成，共同扩展了AI的能力边界。</p>]]></description></item><item>    <title><![CDATA[快速迭代下测试流程如何适应需求变化？ 3]]></title>    <link>https://segmentfault.com/a/1190000047442913</link>    <guid>https://segmentfault.com/a/1190000047442913</guid>    <pubDate>2025-12-02 11:07:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>“临近发布，产品经理突然跑过来说：‘用户反馈那个按钮不好用，我们得把交互逻辑整个改一下！’”。</p><p>这个场景，你是不是似曾相识？</p><p>在快速迭代的敏捷开发模式下，需求变化不再是意外，而是常态。传统的、瀑布式的测试流程，那种“等开发全部完成再开始系统测试”的模式，早已力不从心。它就像一堵厚重的墙，试图阻挡变化的洪水，结果往往是被冲垮。</p><p>那么，当需求变更的通知单像雪片一样飞来时，测试团队该如何自处？是抱怨、是加班，还是建立一套能够拥抱变化的、更具弹性的测试流程？</p><p>这篇文章，就是为你准备的生存指南。我们将探讨一套行之有效的策略，帮助你的测试流程在快速迭代的浪潮中不仅能活下来，还能活得很好。</p><h2>为什么传统测试流程“水土不服”？</h2><p>在深入解决方案之前，我们必须清晰地认识到问题出在哪。传统测试流程在快速迭代中失灵，主要源于几个根本性的矛盾：</p><ul><li><strong>滞后的反馈循环：</strong> 测试活动被放在流程的末端。当测试发现一个深层次的设计缺陷时，修复它的成本已经高得惊人，甚至可能动摇整个迭代的发布计划。</li><li><strong>对“稳定”需求的过度依赖：</strong> 传统测试依赖详尽且“冻结”的需求文档来编写测试用例。但在敏捷中，需求是演进的，文档往往是滞后的。测试人员如果死守文档，就会与实际产品脱节。</li><li><strong>效率与覆盖率的矛盾：</strong> 每次微小的需求变更，理论上都可能影响全局。如果每次都执行全量的回归测试，时间根本不允许；如果凭感觉测，又容易遗漏关键缺陷。</li></ul><p>这就导致了一个核心问题：<strong>测试不再是质量的保障，反而成了发布的瓶颈。</strong></p><h2>思维转变：从“质量警察”到“质量教练”</h2><p>要适应变化，首先要改变的是思维模式。</p><p>在传统模式下，测试团队的角色更像是“质量警察”，在流程的最后关卡检查“违规品”。而在快速迭代中，QA需要转变为“质量教练”。</p><p>这意味着什么？</p><blockquote><strong>质量教练的核心职责，不是在最后找出所有bug，而是在整个开发周期中，赋能团队，帮助每个人（包括开发和产品）共同构建高质量的产品。</strong></blockquote><p>这种转变，要求测试人员不再被动等待，而是主动出击。</p><h2>拥抱变化的4大核心测试策略</h2><p>好了，理念讲完，上干货。以下是四个核心策略，它们共同构成了一个弹性的、适应性强的现代测试流程。</p><h3>1. 测试左移：在Bug诞生前就“消灭”它</h3><p>“测试左移”（Shift-Left Testing）是敏捷测试的灵魂。简单说，就是把测试活动尽可能地向开发流程的左侧（早期）移动。</p><p>别等到代码写完了才开始找问题，那太晚了！</p><ul><li><strong>参与需求评审：</strong> 当产品经理提出一个新想法时，QA就应该在场。你需要像一个挑剔的用户一样去提问：“如果用户在这里断网了会怎样？”、“这个操作在小屏幕手机上方便吗？”。在需求阶段发现一个逻辑漏洞，成本几乎为零。</li><li><strong>评审设计稿和架构：</strong> 在UI/UX设计师画出线框图，或者开发人员设计出技术方案时，QA就要介入。从可测试性、用户体验、性能风险等角度提出建议。</li><li><strong>结对编程与代码审查（Code Review）：</strong> 虽然这是开发的工作，但有测试思维的QA参与其中，能从不同视角发现问题，比如边界值处理、异常逻辑等。</li></ul><p><strong>测试左移的本质，是从“找bug”升级为“预防bug”。</strong></p><h3>2. 自动化测试金字塔：把精力花在刀刃上</h3><p>面对频繁的变更和回归测试的压力，自动化是唯一的出路。但如何做自动化，很有讲究。著名的“测试金字塔”模型给了我们清晰的指引：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442915" alt="测试金字塔模型示意图" title="测试金字塔模型示意图"/></p><p><em>(图片来源: Martin Fowler)</em></p><ul><li><p><strong>底层：单元测试 (Unit Tests)</strong></p><ul><li><strong>谁来做？</strong> 主要是开发人员。</li><li><strong>为什么重要？</strong> 它们运行速度极快，能提供最迅速的反馈。一个良好的单元测试覆盖率是保证代码重构和功能迭代的基石。作为QA，你需要推动并检查单元测试的覆盖率和质量。</li></ul></li><li><p><strong>中间层：集成/服务测试 (Integration/Service Tests)</strong></p><ul><li><strong>谁来做？</strong> 开发和QA协作。</li><li><strong>测什么？</strong> 测试模块间的接口、服务间的调用。比如，测试订单服务能否正确调用库存服务。它们比单元测试慢，但比UI测试快得多。</li></ul></li><li><p><strong>顶层：UI/端到端测试 (UI/E2E Tests)</strong></p><ul><li><strong>谁来做？</strong> 主要是QA。</li><li><strong>测什么？</strong> 模拟真实用户操作，验证关键业务流程。比如，从用户登录、浏览商品、下单到支付的完整流程。</li><li><strong>注意：</strong> UI测试最脆弱、运行最慢、维护成本最高。<strong>一定要少而精！</strong> 只自动化那些最核心、最稳定的业务主干流程。</li></ul></li></ul><p><strong>一个健康的自动化策略，应该是底层宽大、顶层尖锐的金字塔结构，而不是一个脆弱的“冰淇淋甜筒”。</strong></p><h3>3. 探索性测试：释放人类智慧的力量</h3><p>自动化不是万能的。对于那些全新的、需求仍在快速变化的功能，编写自动化脚本得不偿失。这时，**探索性测试（Exploratory Testing）**就派上了用场。</p><p>它不是无目的的“瞎点”，而是一种有结构、有思想的测试方法。</p><blockquote>探索性测试是“学习、设计和执行”同步进行的过程。测试人员基于自己的经验、直觉和对产品的好奇心，去探索软件可能存在缺陷的角落。</blockquote><p>试想一下，一个新上线的社交分享功能，你可以设定一个“测试任务”（Charter），比如：“尝试用各种非常规的内容（超长文本、特殊表情、空内容）进行分享，并验证在不同网络环境下的表现”。</p><p>这种方式尤其适合发现那些自动化脚本难以覆盖的、与用户体验和逻辑相关的深层次问题。</p><h3>4. 风险驱动的回归测试策略</h3><p>每次发布前，时间都非常紧张，不可能把所有用例都跑一遍。怎么办？</p><p>答案是：<strong>基于风险来决定测什么、不测什么。</strong></p><p>你需要和产品、开发一起快速评估：</p><ul><li><strong>变更的范围有多大？</strong> 是改了一个页面的文案，还是动了底层的支付接口？</li><li><strong>影响的核心业务是什么？</strong> 支付、登录、注册等功能的优先级，永远高于“关于我们”页面。</li><li><strong>代码的耦合度高吗？</strong> 修改这个模块，是否有可能“意外”影响到其他看似无关的功能？</li></ul><p>基于评估结果，制定一个分级的回归测试计划：</p><ul><li><strong>P0级（冒烟测试）：</strong> 每次构建后自动执行，覆盖最核心的主干流程，5分钟内必须跑完。</li><li><strong>P1级（核心回归）：</strong> 针对本次变更影响到的主要功能和相关模块，进行重点测试。</li><li><strong>P2级（全面回归）：</strong> 在大版本发布前，或者时间充裕时，进行更广泛的测试。</li></ul><p>这种策略，确保了有限的测试资源能够集中在最高风险的区域，实现了效率和质量的平衡。</p><h2>常见问题 (FAQ)</h2><p><strong>Q1: 需求在开发周期快结束时才发生重大变更，怎么办？</strong></p><p>A: 这是最糟糕但又常见的情况。首先，<strong>透明化沟通</strong>是关键。立即组织产品、开发和测试，评估变更带来的影响和风险。其次，​<strong>协商范围</strong>​，看是否能将变更拆分，将非核心部分放到下个迭代。如果必须上，就要明确告知所有干系人，这会牺牲掉哪些原定的测试范围，以及可能带来的线上风险。<strong>质量是整个团队的责任，不是QA一个人的。</strong></p><p><strong>Q2: 快速迭代下，我们还需要写详细的测试用例吗？</strong></p><p>A: 需要，但形式变了。传统的、事无巨细的测试用例（Test Case）正在被更轻量级的方式取代。比如，使用<strong>测试清单（Checklist）</strong>来罗列关键的测试点，或者使用<strong>思维导图（Mind Map）</strong>来梳理复杂功能的测试逻辑。对于探索性测试，记录<strong>测试任务（Charter）</strong>和发现的<strong>关键发现</strong>比写详细步骤更重要。核心是：文档要服务于测试，而不是成为测试的负担。</p><p><strong>Q3: 如何说服管理层投入资源去做自动化和测试左移？</strong></p><p>A: 用数据和效益说话。不要只说“我们需要自动化”，而要说“引入自动化后，我们的回归测试时间可以从2天缩短到2小时，让每个迭代能提前1天发布，并且能减少XX%的线上生产问题。” 将技术投入与<strong>发布速度、产品质量、研发成本</strong>这些管理层关心的业务指标挂钩，你的提议会更有说服力。</p><h2>总结</h2><p>在快速迭代的洪流中，测试流程的演进不是选择题，而是必答题。</p><p>核心的转变在于：<strong>从被动地验证结果，到主动地参与过程。</strong></p><p>通过<strong>测试左移</strong>预防缺陷，利用<strong>自动化金字塔</strong>提升效率，借助<strong>探索性测试</strong>发挥人类智慧，再通过<strong>风险驱动策略</strong>精准分配资源。这套组合拳，能帮助你的团队构建一个真正有韧性、能适应变化的质量保障体系。</p><p>记住，变化不可怕，可怕的是用僵化的流程去应对一个流动的世界。现在就开始行动，让你的测试流程成为团队加速的引擎，而不是刹车的阻力。</p>]]></description></item><item>    <title><![CDATA[喜报 | 博睿数据荣获第七批国家专精特新]]></title>    <link>https://segmentfault.com/a/1190000047442917</link>    <guid>https://segmentfault.com/a/1190000047442917</guid>    <pubDate>2025-12-02 11:07:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>喜报 | 博睿数据荣获第七批国家专精特新“小巨人”企业称号！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442919" alt="图片" title="图片"/><br/>近日，北京市经济和信息化局正式公示第七批专精特新“小巨人”企业名单，博睿数据凭借在应用性能管理及可观测性领域的深厚积淀、突出创新能力及优质市场表现，成功斩获这一国家级殊荣。这不仅是对博睿数据技术硬实力的肯定，更意味着其已跻身“国家重点培育的战略力量”梯队。专精特新“小巨人”企业需同时满足“专、精、特、新、链、品”六大方面指标，代表着在细分市场中创新能力强、市场占有率高、掌握关键核心技术的排头兵企业。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442920" alt="图片" title="图片" loading="lazy"/><br/>Bonree技术实力，构筑核心竞争力壁垒博睿数据以技术创新为核心驱动力，在应用性能管理及可观测性领域内构建了坚实的竞争壁垒。截至目前，企业已拥有56项已授权发明专利、135项软件著作权及32项核心技术，为产品研发与创新提供了稳固支撑。在行业标准与认证方面，博睿数据参与国际AIOps标准制定，是国内首家通过信通院AIOps能力成熟度优秀级认证的厂商，同时取得美国注册会计师协会（AICPA）获得SOC 2 Type II 鉴证报告，安全合规能力已达国际领先标准。博睿数据核心产品Bonree ONE作为全球领先的一体化智能可观测性平台，依托领先的大数据采集能力、智能分析能力及稳定强大的中台能力，实现IT系统端到端、全链路、全场景的多源数据智能可观测。该平台通过AI技术智能预测故障、定位问题根因并提供决策支持，助力企业快速高效排障，提升业务连续性，支撑业务敏捷迭代，为企业抢占数字经济先机提供有力保障。Bonree市场表现，持续领跑APMO赛道根据IDC最新发布的《中国IT智能运维软件产品市场跟踪报告，2025H1》，博睿数据以22.06%的市场份额稳居中国应用性能监控及可观测性（APMO）市场第一。作为中国APMO领域首家A股上市公司，其市场领先地位持续巩固。目前，博睿数据已为金融、互联网、能源、制造业等关键领域的超1000家头部客户提供解决方案。通过与华为云等行业巨头建立深度生态合作，公司新一代核心产品Bonree ONE已成为华为云商店在IT监控及可观测性领域的联营合作伙伴，并正式成为华为云供应商。此次荣获国家专精特新"小巨人"企业称号，既是荣誉更是责任，博睿数据将以此为契机，继续深耕可观测性领域技术创新，加大研发投入，拓展产品应用场景，为各行业数字化转型提供坚实支撑。</p>]]></description></item><item>    <title><![CDATA[让企业决策像开挂！瑶池 Data Age]]></title>    <link>https://segmentfault.com/a/1190000047442939</link>    <guid>https://segmentfault.com/a/1190000047442939</guid>    <pubDate>2025-12-02 11:06:26</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><a href="https://link.segmentfault.com/?enc=omTf0mrMMP4DOx0TqzoIxw%3D%3D.LvBEna08ik8xPv6xCxfmJZF0MkGVnvB6kNXOIa6BrRyQdayNdAnPo1JsdOgQtTt53qN9X4Gx0p3PvFp4GZYqwQ%3D%3D" rel="nofollow" target="_blank">Data Agent</a> 是瑶池数据库基于 Data+AI 数智融合与 Agentic AI 技术趋势打造的数据智能体产品，全面覆盖数据的产生、存储、加工、治理、分析的全生命周期，并具备自主规划、智能执行、迭代优化等特性，实现从需求分析、数据探索到结果交付的全流程自动化。使业务人员无需掌握复杂的查询语言或数据分析技能，即可获取专业级分析结果，同时确保数据的准确性与安全性。<br/>同时，面向所有依赖数据分析获得业务洞察的岗位群，Data Agent 代理式完成耗时的数据探索分析工作，让用户专注于数据价值。用户只需表达分析需求，Data Agent 便能自主理解并生成工作计划，自动完成数据理解、特征分析、深度洞察挖掘及报告整理与可视化呈现，最终输出令人眼前一亮的数据洞察报告，助力企业实现数据驱动决策。<br/><strong>点此观看精彩视频：<a href="https://link.segmentfault.com/?enc=Z%2Bt5eh4k9oRMhQaTTD2C%2Fg%3D%3D.H6iIA1sSrhCpPxHn9NHec90mEkPkfWXMtEtGe0b23tDL%2F1I%2FI1YUpICoduAYu2UK" rel="nofollow" target="_blank">https://developer.aliyun.com/live/255453</a></strong></p><h2>一、Data Agent 可以帮助你做什么？</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442018" alt="图片" title="图片"/><br/><strong>快捷指定数据</strong><br/>用户可以上传本地的 CSV、Excel 文件或对接企业数据资产，如 RDS、PolarDB、AnalyticDB 等，在保证了企业数据安全的同时，快捷指定要分析的数据，Data Agent 会围绕指定数据展开详细的探索与分析，这得益于 DMS 多年的跨云多源的数据源管理能力。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442019" alt="图片" title="图片" loading="lazy"/><br/><strong>自主规划执行</strong><br/>在指定完所有数据并提出分析需求后，Data Agent 作为您专属的数据分析师就会开始工作。通过对需求的深度理解和对数据的洞察，Agent 会根据任务复杂度调用不同的工具，智能化地生成可以执行的分析计划，同时也可以按需补充或修改计划。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442020" alt="图片" title="图片" loading="lazy"/><br/><strong>执行过程可信</strong><br/>Data Agent 会根据计划生成 Python 代码进行数据计算来完成分析，而不是通过大模型预测下一个 Token 的方式直接输出，并且把计算的全过程包括代码生成、执行、迭代和反馈各个步骤进行呈现，您可以查看每个细节。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442021" alt="图片" title="图片" loading="lazy"/><br/><strong>专业洞察报告</strong><br/>Data Agent 将在分析结束后输出一份结构清晰、交互友好的可视化数据分析报告，系统通过智能算法自动识别核心业务洞察，并以高亮标记+注释说明形式突出展示，您可以和报告中的图表进行交互，实时获取多维度分析结果，辅助决策制定与业务优化。</p><h2>二、Data Agent 的优势</h2><p><strong>数据全生命周期管理</strong><br/>得益于DMS跨云多源的数据源管理能力，支持结构化与非结构化数据的智能融合，覆盖数据采集、处理、分析到应用的全流程。<br/><strong>全智能自主规划</strong><br/>自动解析业务规则，拆解复杂需求为可执行任务，构建分层处理框架，生成定制化分析建议并输出行动方案。<br/><strong>专属执行环境</strong><br/>为每一个账号启动独立专享的数据计算环境，完成Agent规划的全部数据分析任务。计算环境归用户所有，并与企业VPC网络打通，数据不出域更安全。<br/><strong>自主优化迭代</strong><br/>持续从业务交互中积累知识，动态更新企业专属知识库，适应业务变化需求持续优化。</p><h2>三、近期功能动态</h2><ol><li>协作空间（企业版）：面向企业内的协同工作场景，空间内成员可以按需共享会话、知识、记忆以及自定义 Agent；</li><li>自定义Agent（企业版）：支持用户在通用 Data Agent 基础上配置构建适合自身业务的自定义 Agent ，用户可预定义数据范围，指定 Agent 分析思路，补充场景或行业知识完善 Agent 的对特定业务的了解；</li><li>联网搜索（基础能力）：开启后，Data Agent 工作时会进行联网搜索公开信息补充企业数据所挖掘信息的不足，丰富报告内容；</li><li>Data Agent 英文版上线：支持英文输入和输出，面向 English Speaker 的版本；</li><li>长期记忆（基础能力，内测需申请）：Agent 会根据使用过程中的用户反馈，自主判断自动生成长期记忆，后续分析时按需使用相关记忆，增强 Agent 意图理解，连续性和情景化分析能力；</li><li>Agent模式（基础能力，内测需申请）：支持默认和深度两种模式让 Agent 工作，默认模式效率优先，Agent 尽快产出高质量报告。深度模式开启后会让 Agent 花更多的时间思考和执行，更大几率产出更丰富和更深度的结果；</li><li>问数功能（基础能力，内测需申请）：面向用户的简单查询需要，提高执行效率，快速查询产出结果，不支持联网搜索，不适用于执行复杂分析任务。</li></ol><h2>四、体验中心</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442022" alt="图片" title="图片" loading="lazy"/><br/>Data Agent 上线 AI 官网体验中心啦！立即领取3次任务机会，无需邀请码，即可免费体验一站式智能数据分析与报告生成，助你开启数据智能之旅。<br/><a href="https://link.segmentfault.com/?enc=QKeAXv6pEb6kEPBXWUTryw%3D%3D.tJqtPCw4hiQxABfJTv%2Fn5ZbYvfB3WeLYUG64jHrq3bIKaYkxgpYxlx0N%2F379SlLU" rel="nofollow" target="_blank">点此免费体验 Data Agent</a></p><h2>五、专属优惠</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442023" alt="图片" title="图片" loading="lazy"/><br/>Data Agent 个人版仅需99元/月，每天不限时！<br/><a href="https://link.segmentfault.com/?enc=1w3tmENLynUOXCQWS0fqGA%3D%3D.Q0xO8DRw18Qkkt9h8DeDMy2Y%2B2VN9TOpdhvmfDNjQYl3yStJOXDv%2BmydpWRZHPou" rel="nofollow" target="_blank">点此立即开启！</a></p><h2>六、帮助文档</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442024" alt="图片" title="图片" loading="lazy"/><br/>Data Agent for Analytics 是阿里云瑶池数据库团队推出的面向企业用户的数据分析智能体，可以根据自然语言描述进行需求分析，自动完成数据理解，并基于数据理解提出分析需求，扩展分析思路，最终通过调用工具交付分析结果。<br/><a href="https://link.segmentfault.com/?enc=uIBv%2FuB%2FwsQs7Km8LxZEiw%3D%3D.4eZMObaTrqv4LHWTKi%2B0J1HnUcsB9HQxOpA2iwO5BD2%2Fyt07wvbJdqZFWuNiApqBpCPqDnhqV4H2wjfp%2F3T%2BFQ%3D%3D" rel="nofollow" target="_blank">点此了解 Data Agent</a><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442025" alt="图片" title="图片" loading="lazy"/><br/>Data Agent 是一款基于大语言模型的企业数据智能助手，提供免费版、个人版和企业版三种版本，分别满足个人用户的基础使用、进阶需求及企业的多用户协作、安全管控与私有化部署等场景，支持通过自然语言对话完成数据查询、分析与处理，无需编写代码，助力各层级用户高效实现数据驱动决策。<br/><a href="https://link.segmentfault.com/?enc=DpGn2idhQuFkn8Pp%2FcDYPA%3D%3D.46A%2F%2BxyeBIGnecPDQX8i4vA9UxsAD0m0d8mfThb0t3nXgGOrAbI3Ja92NGf1nvGVMUyLoZ7NDH2gWwfBw%2B2%2FRQ%3D%3D" rel="nofollow" target="_blank">点此了解 Data Agent 版本详细介绍</a></p><h2>七、了解更多</h2><p>欢迎扫描下方二维码或搜索钉钉群号105130018526入群与技术专家交流！<br/>DMS Data Agent 当前开放邀测中，立即申请邀测码免费测试： <a href="https://link.segmentfault.com/?enc=%2FJWh3JQbfuN0xMOLs6BU%2Fg%3D%3D.SPB5i2%2BqhINRMT%2Bkqb726%2FwOh%2FEWcHTqKWRpJqj7gpIm3U9P4e4DPrPjXyKU3iARTeD6WCDmAblM6t%2F5E98vLg%3D%3D" rel="nofollow" target="_blank">链接</a><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442026" alt="图片" title="图片" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[鸿蒙系统 4.1.0 兼容 Androi]]></title>    <link>https://segmentfault.com/a/1190000047442958</link>    <guid>https://segmentfault.com/a/1190000047442958</guid>    <pubDate>2025-12-02 11:05:36</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>HarmonyOS 4.1.0 仍属于“兼容 AOSP”的常规版本，<strong>并未切换到纯血鸿蒙 NEXT</strong>。<br/>根据华为官方版本对照表，<strong>HarmonyOS 4.1 对应的 Android 兼容层为 Android 12（API 31）</strong>，与 4.0 同属一个分支，只是补丁级别更高 。<br/>因此，在 4.1.0 设备上安装 APK 时，<strong>按 Android 12 的兼容性进行测试即可</strong>；若出现仅 Android 13+ 才引入的 API，需要降级或做兼容性判断。</p><hr/><p>在“兼容 AOSP”的鸿蒙版本（3.x/4.x，非 NEXT）上，Java 代码与 Android 完全相同，直接读取 <code>Build.VERSION</code> 即可得到当前运行时的 Android 兼容层版本，示例：</p><pre><code class="java">import android.os.Build;

public static String getAndroidCompatibleVersion() {
    // 示例返回：12
    return Build.VERSION.RELEASE;
}

public static int getAndroidCompatibleSdkInt() {
    // 示例返回：31（对应 Android 12）
    return Build.VERSION.SDK_INT;
}</code></pre><p>若还想确认“是不是鸿蒙”，可再取两项系统属性：</p><pre><code class="java">// 1. 厂商
String manu = Build.MANUFACTURER;          // HUAWEI  
// 2. 鸿蒙增量版本号（仅鸿蒙设备存在）
String incremental = Build.VERSION.INCREMENTAL; // 例如 4.1.0.xxx</code></pre><p>当 <code>manu.equals("HUAWEI")</code> 且 <code>incremental</code> 以 <code>"Harmony"</code> 或 <code>"4.1.0"</code> 等开头时，即可判定为鸿蒙系统，同时 <code>Build.VERSION.RELEASE</code> 就是它所兼容的 Android 版本，鸿蒙 4.1.x 通常为 <strong>Android 12（API 31）</strong>。</p>]]></description></item><item>    <title><![CDATA[项目性能优化实践：深入FMP算法原理探索]]></title>    <link>https://segmentfault.com/a/1190000047442992</link>    <guid>https://segmentfault.com/a/1190000047442992</guid>    <pubDate>2025-12-02 11:04:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>一、前 言</h2><p>最近在项目中遇到了页面加载速度优化的问题，为了提高秒开率等指标，我决定从<strong>eebi报表</strong>入手，分析一下当前项目的性能监控体系。</p><p>通过查看报表中的cost_time、is_first等字段，我开始了解项目的性能数据采集情况。为了更好地理解这些数据的含义，我深入研究了相关SDK的源码实现。</p><p>在分析过程中，我发现采集到的cost_time参数实际上就是<strong>FMP（First Meaningful Paint）</strong> 指标。于是我对FMP的算法实现进行了梳理，了解了它的计算逻辑。</p><p>本文将分享我在性能优化过程中的一些思考和发现，希望能对关注前端性能优化的同学有所帮助。</p><h2>二、什么是FMP</h2><p>FMP (First Meaningful Paint) 首次有意义绘制，是指页面首次绘制有意义内容的时间点。与 FCP (First Contentful Paint) 不同，FMP 更关注的是对用户有实际价值的内容，而不是任何内容的首次绘制。</p><h2>三、FMP 计算原理</h2><h3>3.1核心思想</h3><p>FMP 的核心思想是：<strong>通过分析视口内重要 DOM 元素的渲染时间，找到对用户最有意义的内容完成渲染的时间点</strong>。</p><h3>3.2FMP的三种计算方式</h3><ul><li><strong>新算法 FMP (specifiedValue)</strong> 基于用户指定的 DOM 元素计算通过fmpSelector配置指定元素计算指定元素的完整加载时间</li></ul><p>&lt;!----&gt;</p><ul><li><strong>传统算法 FMP (value)</strong> 基于视口内重要元素计算选择权重最高的元素取所有参考元素中最晚完成的时间</li></ul><p>&lt;!----&gt;</p><ul><li><strong>P80 算法 FMP (p80Value)</strong> 基于 P80 百分位计算取排序后80%位置的时间更稳定的性能指标</li></ul><h3>3.3新算法vs传统算法</h3><p><strong>传统算法流程</strong></p><ul><li>遍历整个DOM树</li><li>计算每个元素的权重分数</li><li>选择多个重要元素</li><li>计算所有元素的加载时间</li><li>取最晚完成的时间作为FMP</li></ul><p><strong>新算法（指定元素算法）流程</strong></p><p><strong>核心思想：</strong> 直接指定一个关键 DOM 元素，计算该元素的完整加载时间作为FMP。</p><p><strong>传统算法详细步骤</strong></p><p><strong>第一步：DOM元素选择</strong></p><pre><code>// 递归遍历 DOM 树，选择重要元素
selectMostImportantDOMs(dom: HTMLElement = document.body): void {
  const score = this.getWeightScore(dom);


  if (score &gt; BODY_WEIGHT) {
    // 权重大于 body 权重，作为参考元素
    this.referDoms.push(dom);
  } else if (score &gt;= this.highestWeightScore) {
    // 权重大于等于最高分数，作为重要元素
    this.importantDOMs.push(dom);
  }


  // 递归处理子元素
  for (let i = 0, l = dom.children.length; i &lt; l; i++) {
    this.selectMostImportantDOMs(dom.children[i] as HTMLElement);
  }
}</code></pre><p><strong>第二步：权重计算</strong></p><pre><code>// 计算元素权重分数
getWeightScore(dom: Element) {
  // 获取元素在视口中的位置和大小
  const viewPortPos = dom.getBoundingClientRect();
  const screenHeight = this.getScreenHeight();


  // 计算元素在首屏中的可见面积
  const fpWidth = Math.min(viewPortPos.right, SCREEN_WIDTH) - Math.max(0, viewPortPos.left);
  const fpHeight = Math.min(viewPortPos.bottom, screenHeight) - Math.max(0, viewPortPos.top);


  // 权重 = 可见面积 × 元素类型权重
  return fpWidth * fpHeight * getDomWeight(dom);
}</code></pre><p>权重计算公式：</p><pre><code>权重分数 = 可见面积 × 元素类型权重</code></pre><p>元素类型权重：</p><ul><li>OBJECT, EMBED, VIDEO: 最高权重</li><li>SVG, IMG, CANVAS: 高权重</li><li>其他元素: 权重为 1</li></ul><p><strong>第三步：加载时间计算</strong></p><pre><code>getLoadingTime(dom: HTMLElement, resourceLoadingMap: Record&lt;string, any&gt;): number {
  // 获取 DOM 标记时间
  const baseTime = getMarkValueByDom(dom);


  // 获取资源加载时间
  let resourceTime = 0;
  if (RESOURCE_TAG_SET.indexOf(tagType) &gt;= 0) {
    // 处理图片、视频等资源
    const resourceTiming = resourceLoadingMap[resourceName];
    resourceTime = resourceTiming ? resourceTiming.responseEnd : 0;
  }


  // 返回较大值（DOM 时间 vs 资源时间）
  return Math.max(resourceTime, baseTime);
}</code></pre><p><strong>第四步：FMP值计算</strong></p><pre><code>calcValue(resourceLoadingMap: Record&lt;string, any&gt;, isSubPage: boolean = false): void {
  // 构建参考元素列表（至少 3 个元素）
  const referDoms = this.referDoms.length &gt;= 3 
    ? this.referDoms 
    : [...this.referDoms, ...this.importantDOMs.slice(this.referDoms.length - 3)];


  // 计算每个元素的加载时间
  const timings = referDoms.map(dom =&gt; this.getLoadingTime(dom, resourceLoadingMap));


  // 排序时间数组
  const sortedTimings = timings.sort((t1, t2) =&gt; t1 - t2);


  // 计算最终值
  const info = getMetricNumber(sortedTimings);
  this.value = info.value;        // 最后一个元素的时间（最晚完成）
  this.p80Value = info.p80Value;  // P80 百分位时间
}</code></pre><p><strong>新算法详细步骤</strong></p><p><strong>第一步：配置指定元素</strong></p><pre><code>// 通过全局配置指定 FMP 目标元素
const { fmpSelector = "" } = SingleGlobal?.getOptions?.();</code></pre><p>配置示例：</p><pre><code>// 初始化时配置
init({
  fmpSelector: '.main-content',  // 指定主要内容区域
  // 或者
  fmpSelector: '#hero-section',  // 指定首屏区域
  // 或者
  fmpSelector: '.product-list'   // 指定产品列表
});</code></pre><p><strong>第二步：查找指定元素</strong></p><pre><code>if (fmpSelector) {
  // 使用 querySelector 查找指定的 DOM 元素
  const $specifiedEl = document.querySelector(fmpSelector);


  if ($specifiedEl &amp;&amp; $specifiedEl instanceof HTMLElement) {
    // 找到指定元素，进行后续计算
    this.specifiedDom = $specifiedEl;
  }
}</code></pre><p>查找逻辑：</p><ul><li>使用document.querySelector()查找元素</li><li>验证元素存在且为 HTMLElement 类型</li><li>保存元素引用到specifiedDom</li></ul><p><strong>第三步：计算指定元素的加载时间</strong></p><pre><code>// 计算指定元素的完整加载时间
this.specifiedValue = this.getLoadingTime(
  $specifiedEl,
  resourceLoadingMap
);</code></pre><p><strong>加载时间计算包含：</strong></p><ul><li>DOM 标记时间</li></ul><pre><code>// 获取 DOM 元素的基础标记时间
const baseTime = getMarkValueByDom(dom);</code></pre><ul><li>资源加载时间</li></ul><pre><code>let resourceTime = 0;
// 处理直接资源（img, video, embed 等）
const tagType = dom.tagName.toUpperCase();
if (RESOURCE_TAG_SET.indexOf(tagType) &gt;= 0) {
  const resourceName = normalizeResourceName((dom as any).src);
  const resourceTiming = resourceLoadingMap[resourceName];
  resourceTime = resourceTiming ? resourceTiming.responseEnd : 0;
}
// 处理背景图片
const bgImgUrl = getDomBgImg(dom);
if (isImageUrl(bgImgUrl)) {
  const resourceName = normalizeResourceName(bgImgUrl);
  const resourceTiming = resourceLoadingMap[resourceName];
  resourceTime = resourceTiming ? resourceTiming.responseEnd : 0;
}</code></pre><ul><li>综合时间计算</li></ul><pre><code>// 返回 DOM 时间和资源时间的较大值
return Math.max(resourceTime, baseTime);</code></pre><p><strong>第四步：FMP值确定</strong></p><pre><code>// 根据是否有指定值来决定使用哪个 FMP 值
if (specifiedValue === 0) {
  // 如果没有指定值，回退到传统算法
  fmp = isSubPage ? value - diffTime : value;
} else {
  // 如果有指定值，使用指定值
  fmp = isSubPage ? specifiedValue - diffTime : specifiedValue;
}</code></pre><p>决策逻辑：</p><ul><li>如果 specifiedValue &gt; 0：使用指定元素的加载时间</li><li>如果 specifiedValue === 0：回退到传统算法</li></ul><p><strong>第五步：子页面时间调整</strong></p><pre><code>// 子页面的 FMP 值需要减去时间偏移
if (isSubPage) {
  fmp = specifiedValue - diffTime;
  // diffTime = startSubTime - initTime
}</code></pre><p><strong>新算法的优势</strong></p><p><strong>精确性更高</strong></p><ul><li>直接针对业务关键元素</li><li>避免权重计算的误差</li><li>更贴近业务需求</li></ul><p><strong>可控性强</strong></p><ul><li>开发者可以指定关键元素</li><li>可以根据业务场景调整</li><li>避免算法自动选择的偏差</li></ul><p><strong>计算简单</strong></p><ul><li>只需要计算一个元素</li><li>不需要复杂的权重计算</li><li>性能开销更小</li></ul><p><strong>业务导向</strong></p><ul><li>直接反映业务关键内容的加载时间</li><li>更符合用户体验评估需求</li><li>便于性能优化指导</li></ul><h3>3.4关键算法</h3><p><strong>P80 百分位计算</strong></p><pre><code>export function getMetricNumber(sortedTimings: number[]) {
  const value = sortedTimings[sortedTimings.length - 1];  // 最后一个（最晚）
  const p80Value = sortedTimings[Math.floor((sortedTimings.length - 1) * 0.8)];  // P80
  return { value, p80Value };
}</code></pre><p><strong>元素类型权重</strong></p><pre><code>const IMPORTANT_ELEMENT_WEIGHT_MAP = {
  SVG: IElementWeight.High,      // 高权重
  IMG: IElementWeight.High,      // 高权重
  CANVAS: IElementWeight.High,   // 高权重
  OBJECT: IElementWeight.Highest, // 最高权重
  EMBED: IElementWeight.Highest, // 最高权重
  VIDEO: IElementWeight.Highest   // 最高权重
};</code></pre><h2>四、时间标记机制</h2><h3>4.1DOM变化监听</h3><pre><code>// MutationObserver 监听 DOM 变化
private observer = new MutationObserver((mutations = []) =&gt; {
  const now = Date.now();
  this.handleChange(mutations, now);
});</code></pre><h3>4.2时间标记</h3><pre><code>// 为每个 DOM 变化创建性能标记
mark(count);  // 创建 performance.mark(`mutation_pc_${count}`)
// 为 DOM 元素设置标记
setDataAttr(elem, TAG_KEY, `${mutationCount}`);</code></pre><h3>4.3标记值获取</h3><pre><code>// 根据 DOM 元素获取标记时间
getMarkValueByDom(dom: HTMLElement) {
  const markValue = getDataAttr(dom, TAG_KEY);
  return getMarkValue(parseInt(markValue));
}</code></pre><h2>五、资源加载考虑</h2><h3>5.1资源类型识别</h3><p><strong>图片资源</strong>: &lt;img&gt; 标签的 src属性</p><p><strong>视频资源</strong>: &lt;video&gt; 标签的 src属性</p><p><strong>背景图片</strong>: CSS background-image属性</p><p><strong>嵌入资源</strong>: &lt;embed&gt;, &lt;object&gt;标签</p><h3>5.2资源时间获取</h3><pre><code>// 从 Performance API 获取资源加载时间
const resourceTiming = resourceLoadingMap[resourceName];
const resourceTime = resourceTiming ? resourceTiming.responseEnd : 0;</code></pre><h3>5.3综合时间计算</h3><pre><code>// DOM 时间和资源时间的较大值
return Math.max(resourceTime, baseTime);</code></pre><h2>六、子页面支持</h2><h3>6.1时间偏移处理</h3><pre><code>// 子页面从调用 send 方法开始计时
const diffTime = this.startSubTime - this.initTime;
// 子页面只统计开始时间之后的资源
if (!isSubPage || resource.startTime &gt; diffTime) {
  resourceLoadingMap[resourceName] = resource;
}</code></pre><h3>6.2FMP值调整</h3><pre><code>// 子页面的 FMP 值需要减去时间偏移
fmp = isSubPage ? value - diffTime : value;</code></pre><h2>七、FMP的核心优势</h2><h3>7.1用户感知导向</h3><p>FMP 最大的优势在于它真正关注用户的实际体验：</p><ul><li><strong>内容价值优先</strong>：只计算对用户有意义的内容渲染时间</li><li><strong>智能权重评估</strong>：根据元素的重要性和可见性进行差异化计算</li><li><strong>真实体验映射</strong>：更贴近用户的实际感知，而非技术层面的指标</li></ul><h3>7.2多维度计算体系</h3><p>FMP 采用了更加全面的计算方式：</p><ul><li><strong>元素权重分析</strong>：综合考虑元素类型和渲染面积的影响</li><li><strong>资源加载关联</strong>：将静态资源加载时间纳入计算范围</li><li><strong>算法对比验证</strong>：支持多种算法并行计算，确保结果准确性</li></ul><h3>7.3高精度测量</h3><p>FMP 在测量精度方面表现突出：</p><ul><li><strong>DOM 变化追踪</strong>：基于实际 DOM 结构变化的时间点</li><li><strong>API 数据融合</strong>：结合 Performance API 提供的详细数据</li><li><strong>统计分析支持</strong>：支持 P80 百分位等多种统计指标，便于性能分析</li></ul><h2>八、FMP的实际应用场景</h2><h3>8.1性能监控实践</h3><p>FMP 在性能监控中发挥着重要作用：</p><ul><li><strong>关键指标追踪</strong>：实时监控页面首次有意义内容的渲染时间</li><li><strong>瓶颈识别</strong>：快速定位性能瓶颈和潜在的优化点</li><li><strong>趋势分析</strong>：通过历史数据了解性能变化趋势</li></ul><h3>8.2用户体验评估</h3><p>FMP 为产品团队提供了用户视角的性能评估：</p><ul><li><strong>真实感知测量</strong>：评估用户实际感受到的页面加载速度</li><li><strong>竞品对比分析</strong>：对比不同页面或产品的性能表现</li><li><strong>用户满意度关联</strong>：将技术指标与用户满意度建立关联</li></ul><h3>8.3优化指导价值</h3><p>FMP 数据为性能优化提供了明确的方向：</p><ul><li><strong>资源优化策略</strong>：指导静态资源加载顺序和方式的优化</li><li><strong>渲染路径优化</strong>：帮助优化关键渲染路径，提升首屏体验</li><li><strong>量化效果评估</strong>：为优化效果提供可量化的评估标准</li></ul><h2>九、总结</h2><p>通过这次深入分析，我对 FMP 有了更全面的认识。FMP 通过科学的算法设计，能够准确反映用户感知的页面加载性能，是前端性能监控的重要指标。</p><p>它不仅帮助我们更好地理解页面加载过程，更重要的是为性能优化提供了科学的依据。在实际项目中，合理运用 FMP 指标，能够有效提升用户体验，实现真正的"秒开"效果。</p><p>希望这篇文章能对正在关注前端性能优化的同学有所帮助，也欢迎大家分享自己的实践经验。</p><h3>往期回顾</h3><p>1. Dragonboat统一存储LogDB实现分析｜得物技术</p><p>2. 从数字到版面：得物数据产品里数字格式化的那些事</p><p>3. 一文解析得物自建 Redis 最新技术演进</p><p>4. Golang HTTP请求超时与重试：构建高可靠网络请求｜得物技术</p><p>5. RN与hawk碰撞的火花之C++异常捕获｜得物技术</p><h3>文 /阿列</h3><p>关注得物技术，每周更新技术干货</p><p>要是觉得文章对你有帮助的话，欢迎评论转发点赞～</p><p>未经得物技术许可严禁转载，否则依法追究法律责任。</p>]]></description></item><item>    <title><![CDATA[一款零代码可视化服务编排，业务人员也能轻]]></title>    <link>https://segmentfault.com/a/1190000047442996</link>    <guid>https://segmentfault.com/a/1190000047442996</guid>    <pubDate>2025-12-02 11:03:39</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在当今快速变化的数字经济环境中，企业业务需求迭代速度在加快。传统的手工编码方式对应对市场的敏捷性要求，显得太繁琐。业务逻辑的可视化配置与复用的方式成为企业数字化转型的核心需求。通过将复杂业务逻辑转化为可视化配置组件，企业能够大幅降低对专业开发人员的依赖，实现业务人员自主配置、快速响应市场变化的目标。<br/>可视化业务逻辑配置平台使业务流程构建变得直观简单，用户通过拖拽连接各种预置组件，即可组装出完整的业务逻辑流。这种模式将业务逻辑的实现从代码编写层面提升到了逻辑流程编排层面，缩短了从需求到上线的周期。</p><h2>逻辑引擎的定位</h2><p>• 核心功能：提供界面化、易于基础能力扩展的，实时配置、调试、发布的程序设计与运行执行的环境。<br/>• 使用人群：具备一定技术认知的实施人员（懂一些技术的产品经理、需求经理，懂业务的技术人员等）<br/>• 基础价值：业务功能实现的低成本、高质量、高效率，降低对技术人员的依赖度。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442998" alt="图片" title="图片"/><br/>JVS逻辑引擎是一套零代码、界面化、配置式的服务编排平台，通过拖拽连接企业系统/API/数据库/数据等各种基础设施，自助式编排业务自动化执行流程，降低对代码、部署等技术依赖度，敏捷响应业务变化。<br/>传统开发中，业务逻辑一般是写代码去实现，不管是修改还是构建，都得由程序员来完成。而JVS逻辑引擎通过流程编排 + 拖拽式开发的方式，将条件判断、循环执行、分支选择等逻辑结构直观的呈现。例如，一个“审批是否需要上级审核”的判断逻辑，在JVS中只需拖拽几个节点即可完成，业务人员也能轻松调整规则。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442999" alt="图片" title="图片" loading="lazy"/><br/>逻辑编排的意义在于跳出底层的代码细节，以数据流转的方式思考业务逻辑。通过这种方式，可以将业务逻辑抽象为可复用的组件，每个组件对数据进行相应处理或者根据数据执行相应动作，从而达到复用业务逻辑的目的。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443000" alt="图片" title="图片" loading="lazy"/><br/>通过“逻辑应用扩展接口”组件，一个逻辑可以嵌套调用另一个逻辑的结果，实现层级化复用。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443001" alt="图片" title="图片" loading="lazy"/><br/>再强大的可视化编排也无法覆盖所有场景，特别是复杂计算或动态数据处理。但在JVS逻辑引擎中，提供了Groovy脚本节点，允许在流程中嵌入代码：<br/>• 动态字段组合：通过脚本拼接JSON数据，满足个性化接口需求。<br/>• 复杂计算：如阶乘计算、数据脱敏等，脚本可直接操作流程变量。<br/>• 调试支持：脚本节点支持实时调试，输入输出数据一目了然。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443002" alt="图片" title="图片" loading="lazy"/><br/>系统内还提供了类Excel函数公式，支持数据动态加工<br/>日常的业务功能需要实现，其实本质上是数据的流转加工，往往每个服务节点是有自己独立的实现功能的，那么很可能需要把一个数据或者一个信息在多个服务节点之间 流动起来，甚至需要对信息进行 累次加工，加工那么需要实现 后置节点的加工数据的输入是前置节点的输出，那么我们通过公式配置器实现这个过程，类似于 y=f[g(x)]这种方式进行嵌套使用，可以通过入参、执行过程数据等多种方式，将数据进行动态加工引用，如下图所示：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443003" alt="图片" title="图片" loading="lazy"/><br/>①：函数配置窗口，通过函数式编程（类excel公式）的方式对数据进行加工处理，操作配置简单<br/>②：参数列表，可以引用入参、可以引用前述节点的执行结果用于 数据的动态加工使用<br/>③：函数列表，提供了大量的内置函数，且这个函数可以自定义扩展<br/>④：函数解释说明<br/>• 公式示例：SUM(A1:A10)计算数组和，IF(A&gt;0, "正数", "负数")实现条件判断。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047443004" alt="图片" title="图片" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443005" alt="图片" title="图片" loading="lazy"/><br/>JVS逻辑引擎可以被多种场景触发，比如：<br/>• 表单事件：提交、失焦、自定义按钮点击；<br/>• 流程审批：同意/拒绝操作时触发附加逻辑；<br/>• 定时任务：每日数据汇总、接口巡检；<br/>• 外部API：其他系统通过接口调用JVS逻辑。<br/>JVS逻辑引擎不仅能配置化搭出页面，还能逻辑编排，实现从简单表单到复杂业务流的全链路覆盖。<br/>在线demo：<a href="https://link.segmentfault.com/?enc=%2FUpGtjIXmgY9t8M3CHaNOQ%3D%3D.zbEc8dd2DIgaCn6%2BOq3kMXL7%2BHJnZ3Ri3ESpyXClzs0%3D" rel="nofollow" target="_blank">https://logic.bctools.cn</a><br/>基础框架开源地址：<a href="https://link.segmentfault.com/?enc=bGuFSLHHzcOYYTqj0rmmbA%3D%3D.pLlLn3Rdd%2B3rnAgvN3LpNfnWZtuwHaVz05140m6bSTr62elqaix%2FRbxTJ654o4gr" rel="nofollow" target="_blank">https://gitee.com/software-minister/jvs</a></p>]]></description></item><item>    <title><![CDATA[编程语言的“奇点”融合（上）：凤凰涅槃与]]></title>    <link>https://segmentfault.com/a/1190000047443032</link>    <guid>https://segmentfault.com/a/1190000047443032</guid>    <pubDate>2025-12-02 11:03:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>系列导读： 在上一阶段的探索中，我们见证了从VimL到ObjectSense的工程化飞跃。而今天，讲述的是更野心的技术蓝图——Polyglot Singularity（多语言奇点）。这不仅仅是一门语言，而是一个试图融合多语言、跨平台、并让人类与AI高度协同的“编程生态体系”。<br/>本系列将分上下两篇，解读这个生态中的三大核心象征：Phoenix（凤凰）、Rainbow（彩虹）与 Feather（羽毛），以及它们如何共同构建编程的未来。<br/>（上篇）凤凰涅槃与彩虹之桥<br/>（下篇）AI羽翼与人机共生<br/>一、 什么是“多语言奇点” (Polyglot Singularity)？<br/>在当前的软件开发中，我们面临着严重的“巴别塔”问题：不同的编程语言、不同的机器学习框架、人类代码与AI生成代码之间，存在着巨大的裂痕。<br/>Polyglot Singularity 正是为了解决这个问题而生。它的核心愿景是通过一个统一的生态体系，实现代码在不同语言、平台和AI辅助工具之间的无缝嵌入、转换和协作。<br/>它试图推倒“语言之墙”，推动编程语言向多元化和智能化的“奇点”融合。而在风暴的中心，是一只浴火重生的“凤凰”。<br/><img width="723" height="433" referrerpolicy="no-referrer" src="/img/bVdnegf" alt="image.png" title="image.png"/><br/>二、 Phoenix（凤凰）：人类智慧的“绝对领地”<br/>在这个生态中，Phoenix 语言扮演了“君主”的角色。Phoenix OSE (Non-AI Language)。 这意味深长。在AI代码满天飞的时代，Phoenix 刻意强调自己是“非AI语言”。<br/>象征意义： 凤凰代表“重生与不屈”。它象征着摒弃历史包袱（如旧有的复杂语法），以更简洁、高效、现代的形态重生。<br/>技术定位： 它是主要的语言核心。Phoenix 负责实际的业务逻辑和程序实现。它强调模块化、多范式支持和方便的异常处理机制。<br/>核心哲学： 它是为了保护人类程序员的核心能力而设计的。在这个生态里，人类程序员聚焦于 Phoenix 代码的编写、审查和逻辑判断。它是人类意志的直接体现，是“不可被AI随意篡改”的基石。<br/>简而言之，Phoenix 是留给人类的一块“净土”，让我们在享受AI便利的同时，依然掌握着系统的“方向盘”。<br/><img width="723" height="433" referrerpolicy="no-referrer" src="/img/bVdnegg" alt="image.png" title="image.png" loading="lazy"/><br/>三、 Rainbow（彩虹）：连接现实的“通天塔”<br/>如果 Phoenix 是高高在上的设计理念，那么 Rainbow 就是让理念落地的“桥梁”。<br/>技术定位： Rainbow 是一个专为 Vim8 编辑器设计 的转译器和运行环境。<br/>核心功能： 它的任务是将 Phoenix 这种高级、现代的语言，转译（Transpile） 为 Vim8 可执行的脚本。<br/>为何重要？ Vim8 是一个极其稳定、高效但底层复杂的环境。Rainbow 承担了所有的“脏活累活”——它实现了列表、字典、嵌套赋值等丰富的数据结构，以及模式匹配和异常处理。它让 Phoenix 可以“优雅”地运行在 Vim8 的“硬核”地基上。<br/>Rainbow 是连接“未来”（Phoenix）与“现实”（Vim8）的彩虹桥。它确保了开发者既能享受 Phoenix 的现代语法，又能利用 Vim8 强大的原生功能，实现两者的无缝集成。<br/><img width="723" height="433" referrerpolicy="no-referrer" src="/img/bVdnegi" alt="image.png" title="image.png" loading="lazy"/><br/>（未完待续）<br/>Phoenix 确立了人类的核心地位，Rainbow 铺平了执行的道路。但在这个“奇点”中，AI 究竟扮演什么角色？在（下篇）中，我们将揭开生态的最后一块拼图——由AI生成的“Feather（羽毛）”，并解读其终极的人机共生哲学。</p>]]></description></item><item>    <title><![CDATA[汽车产业链如何通过数字化平台实现研发协同]]></title>    <link>https://segmentfault.com/a/1190000047443035</link>    <guid>https://segmentfault.com/a/1190000047443035</guid>    <pubDate>2025-12-02 11:02:15</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>汽车产业链的数字化转型已成为行业发展的必然趋势。在研发管理领域，诸多企业仍面临设计数据分散、流程审批低效、跨部门协作困难等挑战。广域铭岛推出的Geega捷做设计研发协同平台，致力于为离散型制造业提供系统化解决方案，通过整合需求管理、项目计划、设计研发、采购评估等环节，帮助企业提升产品可靠性、缩短上市周期并增强个性化能力。<br/>在汽车制造业中，研发过程的复杂性尤为突出。以某整车企业为例，其零部件数量庞大，设计变更频繁，传统管理模式容易导致版本混乱和资源浪费。Geega捷做设计研发协同平台通过构建统一的研发数据中枢，实现了产品数据的精准管理和全链路可控。设计完成后，系统自动发起审批流程，支持移动端处理，显著提升了流程效率。此外，平台支持各部门在线协同办公，可按项目维度查看产品数据，包括版本信息、BOM结构及模型文件，从而确保信息的一致性与可追溯性。某零部件供应商应用该平台后，版本准确率达到100%，审批效率提升40%，项目交付周期明显缩短，零部件复用率提高35%，BOM数据准确率提升至80%。<br/>三维数据协同是汽车研发中的另一关键环节。传统模式下，三维模型存储于PDM/PLM系统，但非设计部门难以直接访问，跨格式交换困难，且大型模型加载缓慢。Geega捷做设计研发协同平台模块通过轻量化技术解决了这一问题，兼容60余种CAD格式，实现模型的实时加载与更新。例如，某科技企业引入该模块后，销售团队可直接通过网页展示产品模型，生产人员扫码查看工序细节，质量人员在线完成评审，设计人员则可通过浏览器实现模型渲染。这一应用使模型查看效率提升60%，跨部门协作周期缩短50%，数据准备时间减少75%。<br/>质量管控方面，FMEA（失效模式与影响分析）作为预防性质量工具，在实际应用中常因成本高、标准不统一、经验难以传承而流于形式。Geega捷做设计研发协同平台FMEA通过构建智能质量知识库与分析引擎，实现了FMEA工作的系统化与自动化。系统可自动匹配分析对象、推送历史数据，并基于问题库推荐整改措施。在项目前期，平台能够自动识别潜在失效模式，一键生成DFMEA全流程分析，从而从源头管控设计故障。某制造企业应用后，FMEA编制效率提升20%，表单自动化率达到100%，有效推动了质量管理的全面升级。<br/>Geega捷做设计研发协同平台已在整车、零部件、高端装备及电子制造等领域得到广泛应用。其模块化设计形成了协同效应，全面覆盖研发管理各环节，为企业数字化转型提供了有力支持。在汽车行业竞争日益激烈的背景下，此类平台不仅助力企业优化内部流程，更成为提升核心竞争力的关键工具。未来，随着人工智能与物联网技术的深度融合，汽车产业链的数字化实践将进一步向智能化、集成化方向发展。</p>]]></description></item><item>    <title><![CDATA[什么是真正的AI员工？青否AI员工系统的]]></title>    <link>https://segmentfault.com/a/1190000047443043</link>    <guid>https://segmentfault.com/a/1190000047443043</guid>    <pubDate>2025-12-02 11:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>随着人工智能技术不断发展，AI大模型从研发走向应用，“AI数字员工”应运而生。它并非科幻意义上的“类人伙伴”，而是作为虚拟劳动力，实质参与生产、运营、服务等流程，为跨行业领域的数字化与智能化转型提供有力支撑。</p><p>“‘AI数字员工’作为一个在企业数字环境中工作的智能体，已超越传统自动化工具范畴，不再是模仿人类操作的机械工具，而是具备‘感知—规划—行动—学习’闭环能力的‘数字同事’。（青否ai员工源头v：zhibo175）</p><p>什么是真正的AI员工？</p><p>AI员工与常见的智能工具有着本质区别。它的核心在于：</p><p>模拟人工操作：像人类员工一样使用鼠标、键盘，接管电脑完成任务；</p><p>独立执行流程：从任务的开始到结束，能够自动完成完整业务闭环；</p><p>无人值守：在预设逻辑下稳定运行，无需时刻人工干预；</p><p>岗位替代：承担原本由人类完成的标准化、重复性工作，让人类员工从繁琐事务中解放出来；</p><p>灵活适用于各行各业：即便面对全新的业务状况，也能即时理解需求并完成任务。</p><p>青否ai超级员工，获客+引流+销售全流程，青否AI超级员工：支持一键控制 + 岗位级替代！核心功能如下：（青否ai员工源头v：zhibo175）</p><p>1、AI获客</p><p>告别内容内耗，多平台高效运营。</p><p>sora2批量生成爆款短视频，智能匹配行业关键词，全自动发布覆盖抖音、快手、视频号、小红书。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443045" alt="" title=""/></p><p>GEO智能体优化多平台AI内容，用户提问时主动推荐企业及产品，精准曝光。</p><p>多账号一键绑定管理，数据实时监测，无需跨平台切换，省掉半个编辑团队。</p><p>解决：内容累、制作耗时长、跨平台管理乱的痛点。</p><p>2、AI引流（青否ai员工源头v：zhibo175）</p><p>全域精准引流，获客效率倍增。</p><p>按行业+用户画像全网采集高意向客户，主动私信/评论，无需人工蹲点。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443046" alt="" title="" loading="lazy"/></p><p>抖音客服7*24小时在线自动回复，AI拟人聊天，引导客户留资。</p><p>解决：找客难、引流慢、精准度低的痛点。</p><p>3、AI销售（青否ai员工源头v：zhibo175）</p><p>标准化私域成交，降本又增效。</p><p>智能私域管家：自动通过好友、实时监控聊天记录、拟人化自动回复，精准预测客户行为分层。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047443047" alt="" title="" loading="lazy"/></p><p>高情商促单：洞察客户需求、处理异议、推动成交，7x24 小时在线不打烊。</p><p>安全保障：本地部署 + 独立后台，知识库与数据全加密，杜绝泄露。</p><p>解决：转化低、跟进慢、客户数据不安全的痛点。</p><p>获客+引流+销售全流程的结合，为企业提供了一种全新的工作模式——ai数字员工。这种未来工作模式不仅能够显著提升企业的运营效率，还能有效地降低企业的运营成本（青否ai员工源头v：zhibo175）。</p>]]></description></item><item>    <title><![CDATA[SSL=免费获客？搜索引擎排名提升的隐藏]]></title>    <link>https://segmentfault.com/a/1190000047442700</link>    <guid>https://segmentfault.com/a/1190000047442700</guid>    <pubDate>2025-12-02 10:08:28</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>流量成本居高不下，免费获客渠道愈发珍贵。一枚SSL证书，不只是网站安全的“防护盾”，更是提升搜索引擎排名、实现免费获客的“隐形利器”。不少企业忽略其与流量、获客的关联，错失低成本增长机会。本文拆解核心逻辑、实操技巧，搭配选型建议，帮你用好这一技巧。</p><h2>一、核心关联：SSL为何能撬动排名与获客？</h2><p>核心结论：SSL证书不是排名提升的唯一因素，但却是基础门槛和加分项，直接影响用户体验与搜索引擎信任度，进而推动获客转化。</p><p>用户端视角：带SSL证书的网站会显示“小绿锁”，这是用户识别安全的关键信号。面对有绿锁和无绿锁（标不安全）的同类网站，前者点击意愿提升30%以上，而高点击量会反向推动搜索引擎排名上升。</p><p>搜索引擎视角：谷歌2014年就将HTTPS列为排名信号，百度、搜狗等国内平台2017年后也跟进。无SSL的HTTP网站会被判定为安全风险，排名遭压制还可能标“不安全”，形成“无SSL→低点击→低排名→少流量→无获客”的恶性循环。</p><h2>二、底层原理：搜索引擎如何判定SSL价值？</h2><p>想靠SSL提排名，先摸清搜索引擎对SSL的判定逻辑，才能精准发力。</p><p>一是安全性优先级：搜索引擎优先抓取收录HTTPS网站，降低HTTP网站抓取频率和权重。因HTTPS通过SSL/TLS加密数据，避免信息泄露，HTTP则明文传输有风险，搜索引擎会向HTTPS网站倾斜流量。</p><p>二是证书有效性权重：装了证书不代表万事大吉，搜索引擎会核查证书是否过期、颁发机构是否可信、类型是否适配。无效或低信任度证书不仅没用，还可能拉低网站权重。</p><p>三是全站HTTPS适配度：只给首页装SSL、内页仍用HTTP的“混合模式”，会被判定为安全不完整，无法获得全额权重。只有全站适配HTTPS，才能最大化排名优势。</p><p><img width="625" height="264" referrerpolicy="no-referrer" src="/img/bVdm9Dq" alt="" title=""/></p><h2>三、实操技巧：3步落地，快速激活排名与获客效果</h2><p>懂了原理，落地是关键。3个实操技巧，帮你快速搭建SSL体系，激活获客潜力。</p><h2>技巧1：完成HTTPS部署，规避基础踩坑点</h2><p>部署前确认服务器支持SSL/TLS、备份数据；优先用阿里云、腾讯云等的一键部署工具，降低难度。</p><p>重点规避3个坑：一是设证书过期前30天提醒，及时续期；二是用HTTPS检测工具排查，替换残留HTTP资源，解决混合内容警告；三是做好301重定向，保障流量和权重不流失。</p><h2>技巧2：优化SSL相关配置，提升抓取效率</h2><p>部署后优化配置：更新网站地图为HTTPS版本，提交给百度、谷歌等平台；优先启用TLS 1.2及以上版本，提升传输速度，助力排名。</p><h2>技巧3：结合内容与数据，放大获客效果</h2><p>SSL是基础，需结合优质内容和数据优化。定期更新适配用户需求的内容，合理植入关键词；用百度统计、Google Analytics等工具监测流量、点击量等，调整策略放大获客效果。</p><h2>四、案例佐证：中小企业靠SSL实现排名翻倍，获客增长50%</h2><p>某本地装修建材中小企业，此前网站为HTTP协议，百度排名长期处于第3-5页，日均自然流量仅20-30IP，获客效果极差。2024年初，该企业部署SSL证书，完成全站HTTPS适配，并做好301重定向和网站地图更新。</p><p>部署1个月后，网站地址栏显示“小绿锁”，用户点击量提升35%；3个月后，核心关键词（如“本地装修建材厂家”“XX市装修材料批发”）排名均进入百度首页，日均自然流量提升至80-100IP；6个月后，日均自然流量稳定在120IP左右，通过自然流量获取的咨询量较之前增长50%，且获客成本为0，远超付费推广效果。</p><p>另一案例是某电商个体户，此前因网站无SSL证书，被百度标注“不安全”，核心产品关键词无排名。部署SSL证书并优化配置后，1个月内“不安全”标注消失，2个月后3个核心关键词进入首页，自然订单量每月新增10-15单，实现低成本获客突破。</p><h2>五、选型建议：不同企业适配不同类型，不花冤枉钱</h2><p>SSL证书类型多，无需追高价，结合企业规模和场景选择，性价比最高。</p><ol><li>个人站长/小微企业（静态站、无交易）：优先选免费DV SSL证书（如Let's Encrypt、阿里云免费版），满足基础需求，零成本易部署。</li><li>中小企业（有展示、咨询，无大额交易）：选付费OV SSL证书，验证企业身份，可信度更高，年费几百元，性价比突出。</li><li>中大型企业/电商平台（有大额交易、注册）：选EV SSL证书，地址栏显企业名称，安全信任拉满，助力转化，年费几千元，适配高安全需求。</li></ol><p>选型原则：选可信CA机构证书，拒绝“三无”；按流量、功能选，不盲目追高；优先选自动续期、一键部署的服务商，降低维护成本。</p><p>综上，SSL不只是安全工具，更是免费获客、提排名的关键。找对部署、优化、选型方法，就能低成本撬动流量。中小企业和个人站长可先从免费DV证书入手，快速落地见效。</p>]]></description></item><item>    <title><![CDATA[SEO高手不说，但都在做的秘密：SSL证]]></title>    <link>https://segmentfault.com/a/1190000047442703</link>    <guid>https://segmentfault.com/a/1190000047442703</guid>    <pubDate>2025-12-02 10:07:38</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在SEO的世界里，真正的顶尖高手往往默默践行着一些基础却极其关键的优化法则。其中，为网站部署SSL证书，从HTTP迁移到HTTPS，就是这样一条公开的“秘密”。它并非奇技淫巧，而是由搜索引擎官方背书、影响深远的基础性排名因素。</p><p>如果你还在忽略它，可能正在将宝贵的排名机会拱手让人。本文将为你清晰拆解，SSL证书如何以及为何能成为你的SEO助推器。</p><h3><strong>获取<a href="https://link.segmentfault.com/?enc=IfDBTc0X1i6czCY0CBBhdA%3D%3D.UTkercq%2FXZks9YyBCofA9EqtsL%2BTCKaacb3ki62DOuv1%2BvU6kG%2F%2B4q%2B48YgpYfs%2F9jhUKFb7dIkzbhO4oU%2BwDw%3D%3D" rel="nofollow" target="_blank">SSL证书</a>提示SEO排名  注册码230976</strong></h3><p><strong>官方立场：谷歌的明确信号</strong><br/>一切始于2014年。谷歌官方发布声明，<strong>将HTTPS作为搜索排名信号</strong>。这意味着，在其他条件相同的情况下，使用HTTPS的网站会比使用HTTP的网站在搜索结果中获得更高的排名权重。</p><p>谷歌的核心理念是 “<strong>安全的网络对所有人更好</strong>” 。推动全网HTTPS化，是其实践这一理念的核心举措。因此，这一排名信号<strong>不是暂时的，而是长期且重要性会持续增强的</strong>。<br/><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdneaX" alt="" title=""/></p><p><strong>SSL证书提升SEO排名的四大核心机制</strong><br/>SSL证书的SEO价值，绝不仅仅是一个简单的“加分项”，它通过以下四个关键层面，系统性提升你的网站表现：</p><p><strong>1. 直接的排名权重加成</strong><br/>这是最直接的影响。谷歌的算法会识别网站的协议。一个启用HTTPS的网站，会因其提供了安全的用户体验，而获得算法层面的直接青睐。虽然这个信号的权重并非决定性的（内容质量、用户体验等仍是核心），但在竞争激烈的关键词排名中，<strong>HTTPS往往是决定谁上谁下的关键砝码</strong>。</p><p><strong>重点</strong>：它就像一场比赛的入场券。没有它，你可能连在决赛圈竞争的资格都没有。</p><p><strong>2. 提升用户体验与信任度，间接推动排名</strong><br/>谷歌算法的终极目标，是满足用户的搜索意图并提供最佳体验。HTTPS通过两种方式完美契合这一目标：</p><p><strong>避免“不安全”警告</strong>：现代浏览器（Chrome等）会将所有HTTP页面明确标记为“不安全”。这会显著增加用户跳出率，用户可能尚未浏览内容就因担忧而关闭页面。高跳出率是负面的排名信号。HTTPS消除了这一负面体验。</p><p><strong>建立初始信任</strong>：地址栏的锁形图标，是安全与可靠的最直观视觉标识。它能提升用户停留时间、点击率和转化意愿，而这些行为数据，都是搜索引擎评估页面价值的重要参考。</p><p><strong>3. 保障数据完整性，确保SEO基础工作有效</strong><br/>搜索引擎爬虫在抓取和索引你的网站时，同样需要安全的环境。</p><p><strong>防止内容劫持</strong>：在HTTP连接下，存在被中间人攻击或运营商/公共Wi-Fi插入恶意广告或代码的风险。这会导致谷歌抓取到与用户看到的不一致的页面内容，严重影响索引和排名。HTTPS加密确保了爬虫抓取内容的纯粹性和真实性。</p><p><strong>保护核心数据</strong>：对于需要登录或提交表单的页面，HTTPS保证了爬虫可能交互的数据传输安全，使网站能被更完整地理解和索引。</p><p><strong>4. 增强引用价值，稳固链接权重</strong><br/>链接是SEO的基石。当其他网站链接到你时，你希望他们使用的是HTTPS版本的URL。</p><p><strong>链接标准化与权重传递</strong>：如果你的网站支持HTTPS，但外部链接仍指向旧的HTTP地址，搜索引擎需要做一次额外的跳转来规范化URL，理论上存在极小权重损耗的风险。当越来越多的外链直接指向你的HTTPS版本时，链接权重将更直接、高效地传递。</p><p><strong>内容平台的收录偏好</strong>：许多高质量的内容平台、聚合网站在引用来源时，会优先甚至强制要求源链接为HTTPS。没有它，你可能会失去大量宝贵的品牌曝光和自然外链机会。</p><p><strong>迁移至HTTPS：行动指南与关键陷阱</strong></p><p>认识到重要性后，正确的实施是关键。错误的迁移可能导致排名灾难。</p><p><strong>选择正确的证书</strong>：对于企业网站，建议至少使用 OV证书，在安全信任上优于基础DV证书。</p><p><strong>执行301永久重定向</strong>：这是最重要的一步。必须将网站上所有HTTP页面的访问请求，通过服务器配置（如.htaccess, Nginx conf），使用 301重定向 到对应的HTTPS地址。这明确告诉搜索引擎，页面已永久搬家，并将旧链接的权重（如PageRank）完全传递到新链接。</p><p><strong>更新内部链接与资源</strong>：确保网站模板、导航、内容中的所有内部链接，全部指向HTTPS版本。同时，确保所有图片、CSS、JS文件也通过HTTPS加载，避免出现 “混合内容”警告（即HTTPS页面内包含HTTP资源）。</p><p><strong>更新搜索引擎工具与网站地图</strong>：在Google Search Console和Bing Webmaster Tools中，添加并验证你的HTTPS网站作为一个新的“资源”。同时，提交更新后的、包含HTTPS URL的网站地图（sitemap.xml）。</p><p><strong>更新外部重要链接</strong>：尽可能联系重要合作伙伴、目录网站，请他们将你的链接更新为HTTPS版本。</p><p><strong>总结：基础不牢，地动山摇</strong></p><p>在SEO的策略金字塔中，SSL证书与HTTPS迁移并非位于塔尖的复杂技巧，而是塔基部分的基础设施。</p><p>它传递的明确信息是：<strong>你的网站遵循现代网络安全标准，重视用户隐私与数据安全，并提供了可靠的技术环境。</strong></p><p>这种可靠性和信任感，不仅被用户感知，更被搜索引擎的算法深度认可。因此，部署SSL证书并完成HTTPS迁移，并非一个“是否有用”的疑问，而是一个“何时完成”的必选动作。这是所有SEO高手心照不宣的共识，也是你的网站参与未来搜索竞争的最低门槛和坚实起点。</p>]]></description></item><item>    <title><![CDATA[怎么申请免费SSL证书 魁梧的松鼠 ]]></title>    <link>https://segmentfault.com/a/1190000047442705</link>    <guid>https://segmentfault.com/a/1190000047442705</guid>    <pubDate>2025-12-02 10:06:53</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h4><strong>一、什么是SSL证书？为什么你需要它？</strong></h4><p>简单来说，SSL证书是一个数字文件，它有两个核心作用：</p><ol><li><strong>数据加密</strong>：将你在网站上输入的密码、银行卡号等信息变成乱码，只有指定的服务器才能解密，确保传输过程中不被黑客窃取。</li><li><strong>身份验证</strong>：向访客证明你的网站是真实可信的，而不是一个仿冒的钓鱼网站。</li></ol><p><strong>拥有SSL证书的好处：</strong></p><ul><li><strong>提升安全性</strong>：保护用户和网站的数据。</li><li><strong>获取信任</strong>：浏览器地址栏会显示“锁”的标识，告诉用户此网站安全。</li><li><strong>利于SEO</strong>：谷歌等搜索引擎会给启用HTTPS的网站更高的搜索排名。</li><li><strong>满足合规要求</strong>：许多在线支付系统都要求网站必须使用HTTPS。</li></ul><p><a href="https://link.segmentfault.com/?enc=u1tjLH8Tslea1q1MH3MnuQ%3D%3D.TihH83F%2FKnb1N0pX1JjA2jwg1Ik0lA8Jh9%2BXY0bQ8GliXwJBbh7G9dyFY60PwTxubRxMImUW55JfC9avD0L0g7eoBFAejU%2Fld6vVdxC%2F6TE%3D" rel="nofollow" target="_blank">免费SSL证书申请入口</a></p><p>直接访问JoySSL，注册一个账号记得填写注册码230970获取免费证书。</p><p><img width="600" height="323" referrerpolicy="no-referrer" src="/img/bVdclop" alt="" title=""/></p><h4><strong>二、申请SSL证书的详细步骤</strong></h4><p>整个过程可以概括为：提交申请 -&gt; 验证身份 -&gt; 安装证书。</p><h5><strong>1. 选择类型并提交申请</strong></h5><p>根据你的需求，选择合适的SSL证书类型：</p><ul><li><strong>域名型DV</strong>：<strong>只验证域名所有权</strong>，申请最快，通常几分钟到几小时。适合个人网站、博客。</li><li><strong>企业型OV</strong>：<strong>需要验证企业真实性</strong>，地址栏会显示公司名称，信任度更高。适合企业官网。</li><li><strong>增强型EV</strong>：<strong>最严格的验证</strong>，地址栏会<strong>绿色显示公司名称</strong>，安全级别最高。适合银行、金融、电商平台。</li></ul><p><strong>选择证书颁发机构</strong>： 你可以从<strong>付费CA</strong>（如DigiCert, GeoTrust, Symantec）或<strong>免费CA</strong>（如Let‘s Encrypt）处获取证书。</p><ul><li><strong>免费推荐</strong>：<strong>Let’s Encrypt</strong>。它提供免费的DV证书，非常适合个人和小型网站。许多主机商现已内置支持，一键即可申请。</li><li><strong>付费选择</strong>：如果需要OV或EV证书，或更长的有效期和专业的技术支持，则需购买付费证书。</li></ul><p>选定后，在证书服务商的网站上提交申请，并将上一步生成的<strong>CSR代码粘贴</strong>到指定位置。</p><h5><strong>2. 完成域名/所有权验证</strong></h5><p>提交申请后，CA需要确认你确实拥有这个域名。验证方式通常有三种：</p><ul><li><strong>DNS验证</strong>：按照CA的要求，在你的域名DNS解析中添加一条特定的TXT记录。<strong>这是最常见的方式。</strong></li><li><strong>文件验证</strong>：在网站的根目录下放置一个特定的验证文件。</li><li><strong>邮箱验证</strong>：向域名WHOIS信息中的管理员邮箱发送验证邮件。</li></ul><p><strong>完成验证后，CA就会审核并签发证书。</strong> 你会收到一个包含证书文件（通常是.crt或.pem格式）的邮件。</p><h5><strong>3. 安装到你的服务器</strong></h5><p>现在，你需要将收到的证书文件“安装”到你的网站服务器上。</p><ul><li><strong>对于虚拟主机用户</strong>：这通常非常简单。登录主机控制面板，找到“安装SSL证书”的选项，上传你收到的证书文件，或者如果使用Let‘s Encrypt，很多主机商提供“一键安装”功能。</li><li><strong>对于VPS/独立服务器用户</strong>：你需要将证书文件和第一步生成的私钥文件上传到服务器指定目录，并在Web服务器（如Nginx, Apache）的配置文件中进行配置，然后重启服务。</li></ul><p><strong>安装成功后，访问你的网站，地址栏应该会出现一把“小锁”，URL也变成了 <code>https://</code> 开头。</strong></p><h4><strong>三、总结与后续</strong></h4><p>申请SSL证书的核心流程就是：<strong>生成CSR -&gt; 提交验证 -&gt; 安装生效</strong>。</p><p><strong>重要提醒：</strong></p><ul><li><strong>私钥安全</strong>：第一步生成的私钥是最高机密，一旦丢失或泄露，证书就失效了。</li><li><strong>注意有效期</strong>：SSL证书不是永久的（免费证书通常3个月，付费证书1年），<strong>务必在到期前续费或重新申请</strong>，否则网站会显示为“不安全”。</li></ul>]]></description></item><item>    <title><![CDATA[流量转化加速器：加载速度+免费SSL=转]]></title>    <link>https://segmentfault.com/a/1190000047442707</link>    <guid>https://segmentfault.com/a/1190000047442707</guid>    <pubDate>2025-12-02 10:05:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化商业浪潮中，企业主们无不追求更高的网站转化率。然而，许多时候，我们倾注心血优化营销漏斗，却可能忽略了两个最基础也最具决定性的技术基石：<strong>网站的加载速度</strong>与<strong>HTTPS加密协议（即SSL证书）</strong> 。它们如同驱动“转化引擎”的两大核心组件，一个关乎用户体验的“体感”，另一个则关乎用户信任的“心感”。本文将深入剖析，为何这对“黄金组合”是您提升转化率道路上不可或缺的加速器。</p><p><strong>免费SSL证书⬇️</strong></p><p><a href="https://link.segmentfault.com/?enc=NIOGxRTLyoF5Ps5Nn0t6Dw%3D%3D.Riict%2Bmv58RyXRmXdy77jyJXyOrw96wky0jC%2BTstAbTVvunJ8R%2FGYw37BY3wWSxQ3uMyCJn6N%2Flo9DcLSYLTnw%3D%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/free.html?nid=59</a></p><p><strong>注册码230959⬆️，技术服务支持，一站式申请部署安装服务</strong></p><p><img width="650" height="407" referrerpolicy="no-referrer" src="/img/bVdmdBK" alt="" title=""/></p><h4><strong>一、 速度即生命：加载速度直接决定用户去留</strong></h4><p>互联网时代的用户耐心极为有限。研究表明，超过一半的用户会在网页加载超过3秒后选择离开。这意味着，每一次延迟，都可能意味着一次潜在的客户流失。</p><ul><li><strong>对用户体验的影响</strong>：快速加载的网站能提供流畅顺滑的浏览体验，让用户能够迅速找到所需信息或完成购买。这种积极的“第一印象”会直接影响他们在网站上的后续行为，如停留更长时间、浏览更多页面。</li><li><strong>对搜索引擎排名的影响</strong>：谷歌等主流搜索引擎早已将页面加载速度作为重要的排名因子。加载越快的网站，越有可能获得靠前的搜索排名，从而获得更多的免费流量。这本身就是转化的第一步。</li><li><strong>对转化率的直接影响</strong>：无论是电商网站的下单、教育类网站的表单提交，还是资讯类网站的订阅，所有关键转化动作都建立在用户能够顺利、快速地访问页面的基础上。一个“秒开”的页面，其转化率远高于一个需要漫长等待的页面。</li></ul><h4><strong>二、 信任为基石：免费SSL构建安全可信的数字环境</strong></h4><p>如果说速度是吸引用户的“钩子”，那么安全就是留住用户的“地基”。如今，浏览器会对未部署SSL证书的网站标记为“不安全”，并发出警告。这种视觉提示会极大地动摇用户的访问信心。</p><ul><li><strong>消除“不安全”警告，建立初步信任</strong>：部署SSL证书后，浏览器地址栏会显示“https://”和安全锁标志。这不仅消除了负面警告，更向用户传递了一个明确的信号：此网站已通过加密保护，您的数据交互是安全的。这是建立信任的最直观一步。</li><li><strong>加密数据传输，保护用户隐私</strong>：SSL的核心功能是对浏览器与服务器之间的数据传输进行加密。这意味着用户的个人信息、登录凭证、支付卡号等敏感数据在传输过程中无法被第三方轻易窃取或篡改，有效防范了数据泄露风险。</li><li><strong>免费SSL的普及，让安全零门槛</strong>：以JoySSL为代表的免费SSL证书项目，彻底打破了成本壁垒，使得每一个网站都能轻松实现HTTPS加密。这使得“安全”不再是大型企业的专属，而是所有线上业务的标配。</li></ul><h4><strong>三、 “速度+安全”双剑合璧，催化转化率飙升</strong></h4><p>当“极速体验”遇上“全方位安全保障”，“1+1&gt;2”的协同效应便会显现，共同作用于最终的转化率。</p><ul><li><strong>从“犹豫”到“信赖”的转变</strong>：一个加载迅速且网址前有“小绿锁”的网站，会给用户带来专业、可靠、值得信赖的心理感受。这种潜意识的信任感，会显著降低用户的决策成本，促使他们更愿意填写表单、注册会员乃至完成支付。</li><li><strong>完整的信任链条</strong>：用户可以无障碍地快速抵达目标页面（速度），并在确信环境安全的前提下放心地进行操作（安全）。这条无缝衔接的信任链条，正是促成转化的关键所在。它能有效减少因性能不佳或安全疑虑导致的中途放弃行为，特别是对于至关重要的支付环节。</li><li><strong>长期品牌价值的积累</strong>：持续为用户提供高速、安全的访问体验，是在一点一滴地累积品牌声誉。这种正面印象不仅会带来即时的转化，更能培养用户的忠诚度，为企业创造长远的价值。</li></ul>]]></description></item><item>    <title><![CDATA[OurBMC受邀参加CCF中国软件大会，]]></title>    <link>https://segmentfault.com/a/1190000047442713</link>    <guid>https://segmentfault.com/a/1190000047442713</guid>    <pubDate>2025-12-02 10:04:55</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>11月28~30日，2025 CCF 中国软件大会（CCF ChinaSoft 2025）于湖北武汉国际会议中心成功举行。本届大会以 “软件定义智能互联新世界” 为主题，作为中国软件领域的年度盛会，CCF 中国软件大会诚邀来自学术界、产业界与教育界的专家学者、师生和从业者共襄盛举，携手推动软件科学与智能互联的创新发展！<strong>飞腾公司副总经理郭御风受邀主持 “可信执行环境系统软件论坛”，</strong>OurBMC 社区技术委员会成员王敏发表主题演讲，多方面展示社区在可信领域探索创新和产业发展方面的成果。</p><p><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdnebj" alt="aa34c4aa991e3de838c0fe3b395268ff.jpg" title="aa34c4aa991e3de838c0fe3b395268ff.jpg"/></p><p>会上，<strong>OurBMC 社区技术委员会成员王敏围绕《基于 CPU 原生安全的可信 BMC》主题，分享了社区在可信安全领域的最新探索与成果。</strong>他系统介绍了 OurBMC 社区在《基于 BMC 的 TPCM 技术规范》上的研究进展，并展示了基于飞腾 CPU 的国产化 BMC 模块，以及面向服务器平台构建的安全可信整体解决方案。该方案支持静态度量、动态度量与主动度量，提供符合 TSS 标准的标准化服务接口，兼具高安全性、强扩展性与高合规性等特点。</p><p><img width="723" height="495" referrerpolicy="no-referrer" src="/img/bVdnebi" alt="e434cbc6e2f3a409af14111f90cb9fb9.jpg" title="e434cbc6e2f3a409af14111f90cb9fb9.jpg" loading="lazy"/></p><p>OurBMC 社区由飞腾、昆仑太科、百敖等业内领先企业共同发起，吸引了基础软硬件厂商、第三方机构、高等院校及众多个人开发者积极参与，是中国首个 BMC 开源技术根社区。社区秉持开放、平等、协作、创新的理念，携手社区成员，共同构建自主、先进、软硬一体的 BMC 技术全栈体系，共同推进 BMC 技术快速发展，辐射上下游形成产业共振，加速构建繁荣的 BMC 软硬件生态。</p><p><img width="723" height="372" referrerpolicy="no-referrer" src="/img/bVdnebk" alt="e5ca3b3ae12cb02f14c6928d4975bb1e.png" title="e5ca3b3ae12cb02f14c6928d4975bb1e.png" loading="lazy"/></p><p>截至 2025 年 11 月，OurBMC 社区成员单位已超 70 家，涵盖 CPU 、整机、云计算、操作系统及标准中心等多个领域，为开发者提供了开放共享的交流平台，有力赋能 BMC 技术创新。社区采取双代码托管平台+多仓库模式，共成立 5 个 SIG（特别兴趣小组）和 26 个代码仓库，新增代码量超过 25 万行。</p><p>未来，OurBMC 社区将继续发挥自身优势，加强与国内外开源社区、企业、高校等机构的合作与交流，积极搭建交流平台，促进开发者之间的知识共享和经验交流，为社区 BMC 技术栈的成长和进步提供更多机会和支持。</p>]]></description></item><item>    <title><![CDATA[成为一个进阶语音智能体开发者，你必须了解]]></title>    <link>https://segmentfault.com/a/1190000047442762</link>    <guid>https://segmentfault.com/a/1190000047442762</guid>    <pubDate>2025-12-02 10:04:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442764" alt="" title=""/></p><p>除了本期论坛分享，你还可以阅读《对话式 AI 好奇者手册》，继续探索！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442765" alt="" title="" loading="lazy"/></p><p>《对话式 AI 好奇者手册：给语音智能体开发者的第一课》</p><p>https\://www.rtecommunity.dev/conversational-ai-for-the-curious/</p><hr/><p>在本届 RTE2025 大会上，来自产业界和学术界的多位专家深入探讨了一个 DEMO 到实际可落地的产品，必须掌握哪些实时互动与 AI 核心技术栈？</p><p>声网音视频算法工程师、TEN VAD 核心开发者<strong>林子毅</strong>、声网生成式 AI 产品负责人<strong>毛玉杰</strong>、声网音视频实验室负责人<strong>段涛</strong>、阶跃星辰开放平台技术产品经理、RTE 开发者社区布道师<strong>白宦成</strong>、RTE 开发者社区联合主理人、烟台小樱桃科技创始人<strong>杜金房</strong> 、 声网研发 VP <strong>陈若非</strong> 等技术专家、开发者和创业者，一同探索上下文工程和 Agentic AI 开发、分享了他们在各自领域的实践经验和独到见解。</p><hr/><p>RTE 开发者社区联合主理人、烟台小樱桃科技创始人<strong>杜金房</strong>和声网研发 VP <strong>陈若非</strong>分别主持了活动主题分享和圆桌讨论环节。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442766" alt="" title="" loading="lazy"/></p><h2>林子毅：对话式 AI 中的语音技术——3A、VAD 和声纹</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442767" alt="" title="" loading="lazy"/></p><p>声网音视频算法工程师、TEN VAD 核心开发者林子毅指出，在一个对话式 AI 的整体管线中，<strong>语音技术是前置的「守门员」</strong>。用户在打电话、在办公室、在厨房，环境中的<strong>干扰、音量波动和回声就是「三大麻烦」</strong>，它们会直接导致 Voice Agent 误打断、功耗高、甚至无法正常交流。</p><p>林子毅详细介绍了如何解决这些问题：</p><p><strong>AEC （声学回声消除）：</strong> 核心是通过时延估计、双点检测、线性回声消除和残余回声抑制四个部分，将麦克风收到的回声估算并剪掉，确保 Agent 不会听到自己说话；</p><p><strong>ANS （自动降噪）：</strong> 采用传统信号输入（噪声估计 + 滤波器）和更先进的深度学习 AI 方法（运算量更大但效果更好）相结合，有效消除绝大多数噪声，改善信噪比；</p><p><strong>AGC （自动增益控制）：</strong> 通过实时监测信号电平与预设电平进行比较，动态控制幅度，避免声音忽大忽小，确保音量清晰可识别；</p><p><strong>VAD（语音活动检测）：</strong> 判断语音是否存在，并检测一段语音的开始（SOS）和结束（EOS）。</p><p>TEN VAD 则基于深度学习方法，实现了更好的性能和更低延迟。它最大的特点是 Agent Friendly：</p><ul><li>极致轻量化：整个库最小只有 300KB，RTF 实时率只有 0.0086，推理速度极快；</li><li>高精准度：相比传统算法，TEN VAD 能够更准确地检测出两段独立句子中间的短暂停顿，这对于提升端到端响应延迟至关重要。</li></ul><p>此外，声纹识别则用来解决注意力锁定和过滤背景干扰语音的问题，比如在机场场景，通过注册主讲人的声纹，可以过滤同事或嘈杂背景声，避免误打断。</p><p>TEN VAD: https\://github.com/TEN-framework/ten-vad</p><p>「要是没有回声消除、降噪和 VAD 等前置语音技术，Voice Agent 根本不可能正常交流。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442768" alt="" title="" loading="lazy"/></p><p><strong>林子毅</strong></p><p>声网音视频算法工程师、TEN VAD 核心开发者</p><h2>毛玉杰：WebSocket vs. WebRTC——对话式 AI 通讯技术之争</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442769" alt="" title="" loading="lazy"/></p><p>声网生成式 AI 产品负责人毛玉杰的分享，直言「WebSocket vs. WebRTC」这一话题易引行业误解，核心在于 WebSocket 与 WebRTC 并非直接可比的竞争技术。</p><p>他强调，当前对话式 AI 已成趋势（「风口已经让猪飞起」），技术选型应聚焦如何让「猪飞得又快又好」，即实现极致的实时性和低延迟，这是人与 AI 交互方式演进的底层逻辑。</p><p>回顾对话式 AI 里程碑，从 GPT-4o 实时交互能力的震撼亮相，到去年 10 月声网与 OpenAI 联合发布基于 WebSocket 的实时语音 API，以及国内首个 Realtime API 的推出，再到近期对话式 AI 引擎 2.0 的发布，都深刻体现了对实时性的不懈追求。</p><p>毛玉杰从产品视角出发，指出技术协议的选择最终关乎用户体验而非单纯的技术优劣。</p><p>他解释道，WebSocket 基于 TCP，适用于小数据量、状态同步等对实时性有一定要求但无需复杂媒体处理的场景，开发成本相对较低。</p><p>而 WebRTC 则是一套完整的媒体协议栈，内嵌网络传输、带宽控制、编解码等模块，为实时音视频传输而生，虽然复杂，但能显著提升用户在公共互联网上的实时互动体验。实践中，两者常以混合架构存在，如 WebSocket 负责信令控制，WebRTC 处理媒体流，以实现优势互补。</p><p>他强调，若业务本身无音视频需求，不应盲目选择 WebRTC；同时，对于构建对话式 AI 或实时 RTC 能力的开发者，应充分利用声网等成熟厂商的工程积累，避免从零自研的巨大成本与风险。</p><p>「选择协议不只是选择传输方式，而是在定义用户体验的上限。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442770" alt="" title="" loading="lazy"/></p><p><strong>毛玉杰</strong></p><p>声网生成式 AI 产品负责人</p><h2>段涛：从技术指标到用户体验——AI 交互性的全面评估</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442771" alt="" title="" loading="lazy"/></p><p>声网音视频实验室负责人段涛借鉴了声网在 RTE 领域多年的经验，提出一个核心观点：<strong>「模型不应该是评出来的，而是用出来的，用户说好才是好。」</strong> 段涛指出，尽管标准的语料测试显示大模型的准确率很高（错误率 3%-5%），但基于声网的线上抽样分析，实际线上的错误率可能超过 20%，其中会有 4-5 倍的差别，<strong>关键就是错误该如何看到</strong>。</p><p>他用一个常见的 AI 交互问题作为案例：用户在说话时停顿，AI 误以为用户说完并开始回复，造成「AI 在插我的话」的现象。这种问题让用户感到思路不连贯、易疲劳。线上复杂的影响因素（设备、网络、环境）与各种 「海量 Corner Case」（背景人声、口头语、口吃、特殊口音等）是造成这一鸿沟的原因。段涛认为，当前的测评方法要么是面向单一模块（如 ASR 的准确率），要么是面向任务完成率（如能不能订到票），两者都无法对后续的优化提供清晰的指导。他<strong>将对话式 AI 体验相关的能力分为三个维度：理解、表达和交互</strong>，并提出了一个连接二者的桥梁——三维评估框架：</p><ol><li>理解能力（AI 能不能听懂）：语义准确性、情绪语气识别、在不同机型/网络下的稳定性。其挑战是需要覆盖真实场景下的公式、数字、电话号码等特定业务需求的识别，以及背景人声的干扰；</li><li>表达能力（AI 说的是不是像人）：准确度（语义是否清晰）、自然度（音色、韵律）。其挑战是自然度难以脱离人工标注，需要通过多算法打分和人工校正相结合的方式进行评估；</li><li>交互能力（互动是否有效率）：AI 响应的成功率和延迟、用户打断 AI 的成功率和延迟、AI 误打断率。其挑战是解决「我希望模型开始说话的时候就说，不希望你说你就别说」的核心矛盾。比如用户说「对」只是表达习惯，AI 不应误以为是指令而停止。</li></ol><p>这套框架的灵活之处在于可以<strong>根据不同的业务场景调整权重</strong>。例如，智能客服更看重理解能力和信息收集准确性，而对音色自然度不那么在意；智能玩具则更看重表达能力和表现力。他们正在致力于实现测试的自动化，通过一套分离的测试设备和控制设备，实现可控的对话角色扮演，并能加入背景噪声和人声模拟。</p><p><strong>评估的终极目标是「用户导向测试」</strong>：使用符合用户真实使用情况的数据集、设备和网络条件进行测试，并通过任务达成率和主观问卷打分来反向验证和补充客观指标。</p><p>「对话式 AI 体验相关的能力分为三个维度：理解、表达和交互。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442772" alt="" title="" loading="lazy"/></p><p><strong>段涛</strong></p><p>声网音视频实验室负责人</p><h2>白宦成：实时互动 Agent 构建过程中的工具和 MCP 实践</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442773" alt="" title="" loading="lazy"/></p><p>阶跃星辰开放平台技术产品经理、RTE 开发者社区布道师白宦成从实际业务出发，深入剖析了 Voice Agent 在从 Demo 到生产过程中遇到的最大难题：<strong>巨大的延迟爆炸和交互同步问题</strong>。</p><p>Voice Agent 必须要有 ToolCall 和 MCP，否则它不过是一个「有声音的 ChatBot」。Agent 的价值在于能够去做一些事情，比如智能控制或业务系统查询。</p><p>在语音 Agent 的世界里，没有 Loading 动画，只有用户直观感受到的 「卡了」，这会直接影响整个用户体验。此外，ToolCall 的实现依赖于开发者提供的函数签名，如果签名设计「奇葩」，模型的泛化能力就可能扛不住，导致 ToolCall 结果错漏百出。白宦成指出，<strong>认真设计 ToolCall 签名至关重要</strong>，它直接影响模型的指令遵循效果。他还鼓励开发者积极联系模型厂商，将自己的 Tool 整合进去，参与模型训练以提升效果。</p><p>他强调，无论是传统的 ToolCall 还是 MCP，都是解决 Agent 外部数据连接的范式。MCP 能够统一大模型连接外部数据的方式，降低接入门槛，实现功能的快速叠加。</p><p>接着，他给出了<strong>解决延迟爆炸问题的四大「干货」绝招</strong>，目标是将任何带有工具调用的对话轮次延迟阈值尽可能控制在 800 毫秒以内：</p><ol><li><strong>流式工具调用 + 填充词</strong>：不要等到工具执行完毕才开始回复。模型在第二或第三帧识别到需要调用某个 Tool 时，就可以直接开流式输出，同时插入填充词（如「请稍等」，或带有感知度的语句）。</li><li><strong>并行执行 ToolCall</strong>：设计业务流程时，尽可能让模型并行执行相互不关联的 Tool（如天气和机票查询），以缩短整体时延。</li></ol><p>3.<strong>预测性执行（小模型意图抽检）</strong> ：在 ASR 结果进入主模型之前，先用一个非常小的模型进行意图判断。小模型预测到 ToolCall 后，可以先在旁路执行耗时的 Tool，等主模型推理完毕，直接返回 Tool 结果。</p><ol start="4"><li><strong>基础设施优化</strong>：减少 TTS/WebSocket 等各环节的证书检验、网络传输等累计损耗，尽量简化调用链路。</li></ol><p>「Voice Agent 必须要有 ToolCall 和 MCP，否则它不过是一个『有声音的 ChatBot』。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442774" alt="" title="" loading="lazy"/></p><p><strong> 白宦成 </strong></p><p>阶跃星辰开放平台技术产品经理、RTE 开发者社区布道师</p><h2>杜金房：AI+SIP——对话式智能体技术实践</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442775" alt="" title="" loading="lazy"/></p><p>RTE 开发者社区联合主理人、烟台小樱桃创始人杜金房，从通信技术的演进史切入，生动地回顾了从烽火台、电报到实时通信（RTC）的发展历程。他指出，尽管以 ChatGPT 为代表的大模型技术带来了革命性突破，但许多对话式 AI 的核心组件——如 ASR（语音识别）、TTS（语音合成）——早已是成熟技术。</p><p>他以早期电话营销机器人「Lenny」为例，<strong>强调了工程化思维的重要性</strong>：在没有复杂 AI 的情况下，通过巧妙的录音循环设计，同样能实现有效的对话交互，这启发我们应务实地看待技术应用。</p><p>杜金房详细阐述了其核心产品 XSwitch 的定位与实践。他认为，SIP 作为一个历经数十年考验的通信协议，尽管存在不少实践中的「坑」，但其无处不在的应用（如运营商网络、客服中心、门禁对讲）使其<strong>成为连接 AI 与现实世界通话的最佳桥梁。</strong></p><p>XSwitch 正是这样一个基于开源构建的、可无限扩展的 SIP 交换平台，<strong>其核心价值在于「连接一切」。</strong> 它将传统的 SIP 网络与现代的 AI 技术栈无缝对接，能够灵活集成讯飞、豆包、Whisper 等多家 ASR/TTS 服务与大模型，从而快速构建智能呼入或呼出机器人。</p><p>为了应对不同客户的需求，XSwitch 提供了云服务（XSwitch Cloud）与本地化部署的硬件盒子（XSwitch Box）两种方案。后者专为那些电话线路不多、不便上云的小客户设计，实现了「即插即用」的便捷部署。</p><p>杜金房分享了一个生动的案例：其开发的 AI Agent 在致电美国客服时，能耐心等待半小时的背景音乐，直到接通人工坐席。这不仅展示了技术的实用性，也体现了他的理念——<strong>新技术并非总是颠覆，更多时候是作为一种强大的补充</strong>，去连接和增强成熟的呼叫中心系统，最终与更多合作伙伴共同构建一个融合的通信生态。</p><p>「技术好是好，但并不一定是颠覆，而是补充你欠缺的东西。」</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442776" alt="" title="" loading="lazy"/></p><p><strong>杜金房</strong></p><p>RTE 开发者社区联合主理人、烟台小樱桃科技创始人</p><h2>圆桌讨论：从 Demo 落地到一个 RTE AI Builder 的自我修养</h2><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442777" alt="" title="" loading="lazy"/></p><p>本次圆桌讨论主题为「从 Demo 落地到一个 RTE AI Builder 的自我修养」，其聚焦于 Voice Agent 从原型到商业化落地的关键环节、技术难点和未来趋势。声网研发 VP <strong>陈若非</strong>担任主持人，参与讨论的嘉宾有声网生成式 AI 产品负责人<strong>毛玉杰</strong>、阶跃星辰开放平台技术产品经理<strong>白宦成</strong>，RTE 开发者社区联合主理人<strong>杜金房</strong>。</p><h3>从跑通 Demo 到真正落地商用的分界线是什么？什么叫做 Production Ready？</h3><p>杜金房和白宦成强调<strong>快速迭代</strong>。杜金房指出，跑通 Demo 和上线之间没有严格界限，但<strong>真正的鸿沟在于环境的适配</strong>。演示通常在安静的办公室进行，而一旦上线到真实环境并扩大规模，问题就会暴露。</p><p>白宦成建议，初创公司不应过于苛求，只要能让 5-10 个真实用户在生产环境跑一周，解决绝大多数问题，就达到了初步的上线基准。他认为，追求「扩大到很大规模才发现」的问题是「幸福的烦恼」，<strong>前期不应因此错失时间节点</strong>。</p><p>毛玉杰则提出了更高的要求：<strong>价值转化</strong>。他认为，Production Ready 的本质分界线是<strong>产品是否真正帮助客户解决了业务问题</strong>。对于对话式 AI Voice Agent 来说，要看它是否帮助客户提高了转化率、解决了实际的业务痛点。一旦价值得到了验证，后续的产品迭代才是跨过了真正的鸿沟，实现了 <strong>从「功能交付」到「价值转化」</strong> 的飞跃。</p><h3>Voice Agent 开发中哪些技术点最值得关注，又有哪些难点容易被低估？</h3><p>毛玉杰指出，最容易被低估的是<strong>交互体验的细节和拟人化</strong>。开发者倾向于关注模型（ASR、LLM、TTS 的串联与延迟），但<strong>忽略了人与人对话的本质</strong>。他以生物学处理语音信号为例，指出大脑皮层对语音信号的流转和理解非常复杂。影射到 AI，当前的 Voice Agent 在处理注意力锁定、延时削减以及各种网络情况下的交互细节方面，仍有很多未被注意到的地方。例如，对话中常见的「嗯」「点头」等<strong>非语言信号，AI 应该如何响应</strong>，这都是目前尚未解决的复杂难题。</p><p>白宦成提醒开发者要<strong>警惕技术栈的债务</strong>。他认为，虽然各类脚手架能快速搭建 Voice Agent 验证需求，但开发者不能止步于「能用」。大家<strong>一定要花精力研究框架底层的实现原理，不能对语音技术一无所知</strong>，否则一旦进入 Production 环节需要调优，就要花大量时间和精力来「还债」。他建议开发者要一边构建，一边研究工具的原理。</p><p>杜金房强调了<strong>参数调整的灵活性</strong>。他指出，许多 ASR 内置的 VAD 做得并不好，虽然通用级别的 Convo AI 跑起来很容易，但一旦客户提出五花八门的需求，<strong>产品就需要提供高级的参数调整能力</strong>。例如，让客户可以自由选择使用内置的 VAD、TEN VAD 还是不用 VAD。只有提供这种调整的「手段」，开发者才能根据自己的场景进行定制，确保产品的持续竞争力。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442778" alt="" title="" loading="lazy"/></p><h3>面对琳琅满目的开发框架，开发者应该如何选择？</h3><p>白宦成建议<strong>分阶段选择</strong>：</p><ul><li>从零到一（DEMO 阶段）：选择像 TEN Framework 这样分工清晰、易于上手的框架，实现快速构建；</li><li>市场验证和付费阶段（Production Ready）：回归到 <strong>「大道至简」的原则</strong> ，选择那些封装没有那么深、有足够调优空间的框架。他强调，最差的选择是自己从头写一个并用到生产上，因为自己写的产品无法享受开源社区的红利（如 PR 参考、bug 修复），但开发者需要<strong>保留自己改造的机会和可能性</strong>。</li></ul><p>毛玉杰提出了 <strong>「多试用」和「业务驱动」</strong> 的视角。他鼓励大家动手去试、去做评测，因为人类的喜好和产品的需求各有侧重，试了才知道哪个最符合需求。他强调，要<strong>从实际的业务场景出发</strong>，拆解出最核心的体验点，例如做情绪价值的产品可能更在意音色拟人化，做任务完成的产品可能更在意知识库构建和集成，然后根据这些核心点来选择技术框架。</p><p>杜金房认同多试用，但也建议不用试得很深，<strong>只需找到 TOP 3 进行试用即可</strong>，以避免被无限的资源消耗（如 TB 级大模型）所困扰。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442779" alt="" title="" loading="lazy"/></p><h3>AI 和 Voice Agent 的快速发展给 RTE 开发者带来了哪些机遇和挑战？未来两年的发展展望是什么？</h3><p>在最后的开放式问题中，嘉宾们聚焦于技术心态、协议理解和人机交互的未来：</p><p>杜金房关注协议的演进。他告诫开发者不要盲目跟风，虽然要了解前沿技术，但<strong>做产品和应用时不要冲动</strong>。他指出，三段式架构可以覆盖大部分场景，开发者需要知己知彼，了解竞争对手的长处，但要以己之长攻彼之短，<strong>保持对各种通信协议的理解宽度</strong>。</p><p>白宦成聚焦于模型与评测体系。他鼓励开发者<strong>积极试用各家模型</strong>，即使是觉得不好的模型也要试，因为各家模型训练方法、数据和 Alignment 存在差异，会导致推理结果在真实场景中表现不同。他建议开发者构建自己的产品评测体系，不断试用、迭代和替换模型，以积极应对学术界和工业界带来的巨大变化。</p><p>毛玉杰则回到了他最着迷的人机交互体验。他认为，未来一到两年，围绕人机交互体验层面一定会迎来突破。目前的交互还处于早期，光是语音交互就已经很复杂。他认为，<strong>真正的突破点将是 AI 如何处理和响应肢体动作、眼神交流等非语言信息</strong>，将所有感官信息汇聚到一起，达到「一个眼神知道你在做什么」的具身智能体验，这将是未来人机互动体验的核心飞跃。</p><p>主持人陈若非总结，<strong>当前的 Voice Agent 领域仍处于早期</strong>，充满变化，RTE 开发者需要不断跟进并拥抱这些变化，期待明年会有更多新的技术和应用涌现。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442780" alt="" title="" loading="lazy"/></p><hr/><p>除了本期论坛分享，你还可以阅读《对话式 AI 好奇者手册》，继续探索！</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442781" alt="" title="" loading="lazy"/></p><p>《对话式 AI 好奇者手册：给语音智能体开发者的第一课》</p><p><a href="https://link.segmentfault.com/?enc=0hVro2WZieH2a9rEteu1tg%3D%3D.vC%2F56o%2BdOx7PcgnXpakPiJPVLjjY6AgcvWkUdqYrhsGtu%2FCKvHpWz2dFW%2FhNhKWepQyizopjStQY2DYmIiY60g%3D%3D" rel="nofollow" target="_blank">https://www.rtecommunity.dev/conversational-ai-for-the-curious/</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442782" alt="" title="" loading="lazy"/></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442783" alt="" title="" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=wlMK8CSSQtNvN1saOLs3Tg%3D%3D.u%2FmIjWU0nF85e47rZeMe5jrtdXOcOC8A6EMwrhbw66A%3D" rel="nofollow" target="_blank">阅读更多 Voice Agent 学习笔记：了解最懂 AI 语音的头脑都在思考什么</a></p><p><strong>写在最后：</strong></p><p>我们欢迎更多的小伙伴参与 <strong>「RTE 开发者日报」</strong> 内容的共创，感兴趣的朋友请通过开发者社区或公众号留言联系，记得报暗号「共创」。</p><p>对于任何反馈（包括但不限于内容上、形式上）我们不胜感激、并有小惊喜回馈，例如你希望从日报中看到哪些内容；自己推荐的信源、项目、话题、活动等；或者列举几个你喜欢看、平时常看的内容渠道；内容排版或呈现形式上有哪些可以改进的地方等。</p><hr/><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442784" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[从「功能覆盖」到「价值落地」：6大维度深]]></title>    <link>https://segmentfault.com/a/1190000047442804</link>    <guid>https://segmentfault.com/a/1190000047442804</guid>    <pubDate>2025-12-02 10:03:35</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化转型的浪潮中，客户关系管理（CRM）已从“辅助工具”升级为“企业增长的核心引擎”——它不仅是“管客户”的系统，更是“连接市场、销售、服务、财务的协同平台”，其能力直接决定了企业从“流量获取”到“客户终身价值（CLV）”的转化效率。</p><p>本文选取<strong>Salesforce、超兔一体云、用友、金蝶、销售易、HubSpot</strong>六大主流CRM品牌（覆盖大型跨国企业、中大型行业客户、中小企业三大场景），从<strong>客户</strong> <strong>全生命周期管理</strong> <strong>、销售流程自动化、</strong> <strong>智能数据分析</strong> <strong>与报表可视化、团队协作与权限管理、移动端/多终端支持、系统扩展与二次开发</strong>六大核心维度展开深度横评，结合<strong>流程图、脑图、雷达图</strong>等工具，为企业选型提供专业参考。</p><h2>一、客户全生命周期管理：从“流量”到“留量”的闭环能力</h2><p>客户全生命周期管理（CLM）的核心是<strong>通过全流程数据整合与节点管控，实现“获客高效、转化精准、维护智能、复购可持续”</strong> ，其关键评估点包括：全流程覆盖深度、360°客户画像完整性、生命周期价值（CLV）提升能力。</p><h3>1. 各品牌核心能力拆解</h3><ul><li><strong>Salesforce</strong>：以“四大云”（Sales Cloud+Service Cloud+Marketing Cloud+Commerce Cloud）构建<strong>端到端闭环</strong>，整合营销获客（Marketing Cloud覆盖20+渠道）、销售转化（Sales Cloud跟踪商机阶段）、服务维护（Service Cloud处理售后）、商务复购（Commerce Cloud联动会员体系）；通过Einstein AI分析客户行为，精准推送个性化内容，<strong>CLV</strong> <strong>提升30%+</strong> （Salesforce 2023客户成功案例）。</li><li><strong>超兔一体云</strong>：以“三一客”（定性：价值判定；定级：单量分层；定量：金额/时间预期）节点管理为核心，搭配“五大跟单模型”（客户/机会/项目/组织/配置单），覆盖从<strong>多渠道线索抓取</strong>（百度/抖音/微信等）到<strong>售后流失预警</strong>（RFM分析）的全链路；针对大型项目客户，通过“多方项目跟单法”整合项目组、合同、采购、收支，确保全周期可视。</li><li><strong>用友</strong>：依托ERP生态优势，实现“CRM+ERP”数据深度同步，构建<strong>360°客户视图</strong>（整合销售记录、财务数据、库存状态）；例如销售端录入客户需求，ERP端同步库存信息，确保“需求-供给”匹配，减少客户等待时间。</li><li><strong>金蝶</strong>：聚焦<strong>行业化全链路覆盖</strong>，例如制造业“订单-生产-交付”闭环、零售业“客户分级+会员权益”体系；通过金蝶精斗云整合线上线下客户数据，实现“到店客-线上会员-复购客”的全周期管理，<strong>制造业客户CLV提升25%</strong> （金蝶2024年报）。</li><li><strong>销售易</strong>：以“营销云+销售云+服务云”整合为核心，通过<strong>全渠道线索捕获</strong>（百度/腾讯/头条等）、<strong>商机阶段管理</strong>（可视化漏斗）、<strong>售后工单联动</strong>，实现“获客-转化-维护”闭环；AI引擎构建“动态客户画像”（整合聊天记录、购买行为、服务请求），精准推送复购提醒。</li><li><strong>HubSpot</strong>：主打“轻量级全周期管理”，支持<strong>多渠道线索统一录入</strong>（官网/社交媒体/邮件）与<strong>标签分组</strong>（如“潜在客户-高意向”“老客户-复购潜力”）；通过邮件营销、优惠券推送等方式提升复购率，适合初创企业快速搭建“从流量到留量”的基础闭环。</li></ul><h3>2. 对比表格</h3><table><thead><tr><th>品牌</th><th>全流程覆盖</th><th>360°画像完整性</th><th>CLV提升能力</th><th>行业适配性</th></tr></thead><tbody><tr><td>Salesforce</td><td>全链路</td><td>高（四大云整合）</td><td>强（AI驱动）</td><td>全行业（跨国企业）</td></tr><tr><td>超兔一体云</td><td>全链路</td><td>中（侧重销售节点）</td><td>中（RFM+跟单）</td><td>中小制造/贸易</td></tr><tr><td>用友</td><td>全链路</td><td>高（ERP同步）</td><td>中（业财协同）</td><td>中大型企业</td></tr><tr><td>金蝶</td><td>行业化</td><td>中（行业数据整合）</td><td>强（会员体系）</td><td>制造/零售</td></tr><tr><td>销售易</td><td>全链路</td><td>高（三云整合）</td><td>强（AI画像）</td><td>中大型企业</td></tr><tr><td>HubSpot</td><td>轻量级</td><td>中（标签分组）</td><td>中（精准营销）</td><td>中小/初创</td></tr></tbody></table><h3>3. 典型流程可视化（Mermaid）</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442806" alt="" title=""/></p><pre><code>flowchart LR
    A[多渠道线索获取] --&gt; B[三一客节点管理:定性+定级+定量]
    B --&gt; C{模型选择}
    C --&gt;|小单| D[小单快单模型:关键节点推进]
    C --&gt;|大单| E[多方项目模型:整合项目/合同/采购]
    D --&gt; F[转化:订单执行（同步库存）]
    E --&gt; F
    F --&gt; G[维护:RFM分层+流失预警]
    G --&gt; H[复购:高价值客户精准营销]</code></pre><h2>二、销售流程自动化：从“人治”到“数治”的效率革命</h2><p>销售流程自动化（SFA）的核心是<strong>通过标准化流程与智能触发，减少“重复操作”与“关键节点遗漏”</strong> ，其关键评估点包括：流程自定义灵活性、自动化触发场景覆盖、业财一体化协同能力。</p><h3>1. 各品牌核心能力拆解</h3><ul><li><strong>Salesforce</strong>：以“Flow Builder”低代码工具支持<strong>自定义销售流程</strong>（如合同审批、线索分配），结合Einstein AI实现“智能提醒”（例如“客户跟进到期提醒”“高概率赢单预警”）；SDR智能体自动过滤低价值线索，<strong>转化率提升40%</strong> （Salesforce 2023技术白皮书）。</li><li><strong>超兔一体云</strong>：独创“小单快单模型”（三一客+关键节点推进）与“商机跟单模型”（阶段+预期日期管控），通过<strong>工作流自动化</strong>实现“订单锁库-采购计划-供应商直发”全链路；例如小单场景下，系统自动提醒销售“客户跟进到期”，减少人工遗忘。</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442807" alt="" title="" loading="lazy"/></p><ul><li><strong>销售易</strong>：基于PaaS平台构建“可视化销售漏斗”，支持<strong>自定义阶段</strong>（如“线索-意向-报价-成交”），通过工作流引擎自动触发“报价过期提醒”“合同审批”等任务；与企微SCRM整合，实现“客户聊天记录-销售跟进记录”同步，确保流程透明。</li><li><strong>用友</strong>：支持“自定义销售流程”（如合同审批、发票流程），与ERP深度协同，实现“销售订单-财务入账”自动同步，<strong>对账成本降低50%</strong> （用友2023客户案例）。</li></ul><h3>2. 典型场景流程图（Mermaid）</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442808" alt="" title="" loading="lazy"/></p><pre><code>flowchart TD
    A[全渠道线索获取] --&gt; B{线索评分}
    B --&gt;|高价值| C[自动分配销售]
    B --&gt;|低价值| D[公海池培育]
    C --&gt; E[跟进提醒（AI预测时间）]
    E --&gt; F[报价生成（自动关联产品库）]
    F --&gt; G[合同审批（工作流触发）]
    G --&gt; H[订单执行（同步ERP/库存）]
    H --&gt; I[售后提醒（RFM触发）]</code></pre><h2>三、智能数据分析：从“数据”到“决策”的价值转化</h2><p>智能数据分析的核心是<strong>将“散点数据”转化为“可行动的洞察”</strong> ，其关键评估点包括：数据整合能力、智能算法深度（预测/预警）、可视化交互友好度。</p><h3>1. 各品牌核心能力拆解</h3><ul><li><strong>Salesforce</strong>：整合<strong>Einstein Analytics</strong>与<strong>Tableau</strong>，支持“无代码定制分析”（如销售漏斗转化率、客户流失预测）；Einstein AI可预测“客户流失概率”，并给出“挽留建议”（如发送专属折扣）；Tableau可视化看板支持实时刷新，帮助管理层快速掌握经营状态。</li><li><strong>销售易</strong>：内置“实时数据看板”，支持<strong>15+维度分析</strong>（如客户来源转化率、销售业绩TOP10）；AI引擎可预测“未来3个月销售额”，并标注“销售漏斗瓶颈”（如“报价阶段转化率低”），辅助调整策略。</li><li><strong>超兔一体云</strong>：提供“自定义工作台”与“多表聚合引擎”，支持将“客户数据+订单数据+售后数据”整合分析；例如通过“同比环比引擎”对比“本月 vs 上月”的客户转化情况，帮助市场部优化投放策略。</li><li><strong>金蝶</strong>：基于云原生技术，支持“多维报表生成”（如“制造企业-订单交付率”“零售企业-会员复购率”）；与ERP整合，实现“销售数据-财务数据”联动分析，适合行业客户深度挖掘业务痛点。</li></ul><h3>2. 核心能力脑图（Mermaid）</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442809" alt="" title="" loading="lazy"/></p><pre><code>mindmap
    root((智能数据分析))
        数据整合
            多渠道数据接入
            业务系统联动（ERP/CRM）
        智能洞察
            销售预测
            客户流失预警
            漏斗瓶颈分析
        可视化呈现
            自定义仪表盘
            实时报表
            多维度对比</code></pre><h2>四、团队协作与权限管理：从“信息孤岛”到“协同网络”</h2><p>团队协作的核心是<strong>在“数据安全”与“协作效率”间平衡</strong>，其关键评估点包括：权限颗粒度、跨部门协同场景覆盖、信息同步实时性。</p><h3>1. 各品牌核心能力拆解</h3><ul><li><strong>Salesforce</strong>：支持“多角色权限配置”（如销售可看客户跟进记录，财务可看订单金额），结合“Chatter”企业社交工具，实现“客户问题-销售-服务-财务”跨部门协同；例如客户提出“订单延迟”，销售可通过Chatter@服务团队，实时同步问题状态。</li><li><strong>超兔一体云</strong>：采用“全局自动权限机制”（上级管下级、同级隔离、助理跟随主管），适配华为“行政+业务”双重指挥系统；例如销售主管可查看下属的客户跟进记录，助理可同步主管的待办任务，确保协作高效。</li><li><strong>用友</strong>：权限管理细化到“字段级”（如销售不可看客户财务数据），支持“直分销业务一体化”协同（如总部-经销商的订单同步）；通过“社会化建模平台”，促进企业与客户的营销沟通。</li><li><strong>销售易</strong>：与<strong>企微SCRM深度整合</strong>，实现“客户聊天记录-销售跟进记录”同步；支持“项目式任务管理”（如“大型项目-需求调研”“合同签订-法务审核”），确保跨部门协作透明。</li></ul><h2>五、移动端/多终端支持：从“办公室”到“现场”的场景延伸</h2><p>移动端支持的核心是<strong>满足“移动办公”需求，确保“数据实时同步”与“操作便捷”</strong> ，其关键评估点包括：多终端适配性、移动功能完整性、离线使用能力。</p><h3>1. 各品牌核心能力拆解</h3><ul><li><strong>Salesforce</strong>：提供iOS/Android原生应用，支持<strong>离线访问</strong>（无网络时录入客户跟进记录，联网后自动同步）；内置“语音输入”“拍照上传”功能，方便销售现场记录。</li><li><strong>超兔一体云</strong>：支持Web、App、小程序、RPA插件多端落地，移动端优化“语音输入”“定位打卡”“客户视图快速查看”功能；例如销售外出拜访时，可通过小程序快速调取客户360°视图，记录拜访内容。</li><li><strong>销售易</strong>：基于“移动社交设计”，移动端支持“企微聊天同步”“现场签到”“地理位置追踪”；与企微整合，实现“客户消息-销售跟进”实时同步，确保“客户问题”快速响应。</li><li><strong>HubSpot</strong>：提供移动端应用，支持“实时查看客户信息”“更新跟进记录”“发送邮件”，功能简洁，适合初创企业销售团队“在路上”的轻量化需求。</li></ul><h2>六、系统扩展与二次开发：从“标准化”到“个性化”的弹性适配</h2><p>系统扩展的核心是<strong>满足企业“成长中的个性化需求”</strong> ，其关键评估点包括：自定义能力（模块/字段/流程）、集成接口丰富度、低代码/开源支持。</p><h3>1. 各品牌核心能力拆解</h3><ul><li><strong>Salesforce</strong>：开放“AppExchange”应用市场（2000+第三方应用），支持与ERP（如SAP）、OA（如钉钉）、营销工具（如Mailchimp）集成；通过“Flow Builder”低代码工具，非技术人员可自定义流程与表单。</li><li><strong>金蝶</strong>：基于云原生技术，支持“低代码开发”（如金蝶云·星辰），通过“拖拉拽”配置流程；覆盖电子商务、供应链、生产制造等全模块，整合内外部资源。</li><li><strong>超兔一体云</strong>：提供“自定义三级菜单”“自定义业务表”“自定义工作流”等工具，实现“低成本客制化”；支持与ERP（金蝶/用友）、电商平台对接，适合中小企业快速适配业务变化。</li><li><strong>销售易</strong>：基于PaaS平台，支持“深度定制”（如模块新增、字段调整、流程重构）；开放丰富API接口，与企微、钉钉、ERP等系统无缝集成，适合中大型企业“随业务成长扩展”。</li></ul><h2>七、综合能力雷达图（分值1-10）</h2><table><thead><tr><th>品牌</th><th>客户全生命周期</th><th>销售流程自动化</th><th>智能数据分析</th><th>团队协作</th><th>移动端支持</th><th>系统扩展</th></tr></thead><tbody><tr><td>Salesforce</td><td>9</td><td>10</td><td>10</td><td>9</td><td>9</td><td>9</td></tr><tr><td>超兔一体云</td><td>8</td><td>8</td><td>7</td><td>8</td><td>9</td><td>8</td></tr><tr><td>用友</td><td>8</td><td>7</td><td>7</td><td>9</td><td>8</td><td>8</td></tr><tr><td>金蝶</td><td>8</td><td>7</td><td>8</td><td>8</td><td>8</td><td>9</td></tr><tr><td>销售易</td><td>9</td><td>9</td><td>9</td><td>9</td><td>9</td><td>9</td></tr><tr><td>HubSpot</td><td>7</td><td>7</td><td>7</td><td>8</td><td>8</td><td>7</td></tr></tbody></table><h2>八、选型建议：匹配企业阶段与需求</h2><p>CRM选型的核心不是“选最好的”，而是“选最匹配的”，结合企业规模、行业、成长阶段，建议如下：</p><ol><li><strong>大型跨国企业</strong>：优先选择<strong>Salesforce</strong>（全球化生态、AI深度应用）或<strong>销售易</strong>（PaaS定制、企微整合），满足复杂流程与全球化协同需求。</li><li><strong>中大型行业客户（制造/零售）</strong> ：优先选择<strong>金蝶</strong>（行业化全链路）或<strong>用友</strong>（ERP协同），实现“业财一体化”与“行业痛点解决”。</li><li><strong>中小企业/贸易型企业</strong>：优先选择<strong>超兔一体云</strong>（高性价比、跟单模型适配）或<strong>HubSpot</strong>（轻量级、易上手），快速搭建“获客-转化-复购”的基础闭环。</li><li><strong>初创企业</strong>：优先选择<strong>HubSpot</strong>（免费版基础功能全）或<strong>金蝶云·星辰</strong>（轻量化部署），以最低成本实现“从0到1”的客户管理。</li></ol><h2>结语</h2><p>CRM的价值从来不是“功能越多越好”，而是“能解决企业当前最迫切的问题”——对于跨国企业，需要全球化协同与AI洞察；对于制造企业，需要行业化全链路覆盖；对于中小企业，需要高性价比与快速落地。企业在选型时，应先明确“核心需求”（如“提升获客效率”“降低客户流失”“实现业财协同”），再匹配品牌能力，才能真正让CRM从“工具”变为“增长引擎”。</p>]]></description></item><item>    <title><![CDATA[中国企业选CRM的「七维」：7大主流品牌]]></title>    <link>https://segmentfault.com/a/1190000047442819</link>    <guid>https://segmentfault.com/a/1190000047442819</guid>    <pubDate>2025-12-02 10:03:05</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在数字化转型的浪潮中，CRM早已从「销售工具」升级为「企业客户运营的中枢系统」。对于中国企业而言，选择CRM的核心矛盾在于：<strong>既要匹配本土业务场景（如工商信息补全、</strong> <strong>外勤打卡</strong> <strong>、</strong> <strong>ERP</strong> <strong>联动），又要具备国际级的流程能力（如自动化、多端同步、数据安全）</strong> 。</p><p>本文选取<strong>7大主流</strong> <strong>CRM</strong> <strong>品牌</strong>（覆盖国际头部、国内ERP系、中小聚焦型、免费成长型），围绕<strong>客户</strong> <strong>全生命周期管理</strong> <strong>、销售过程跟进与团队协作、自定义表单/流程/报表、多端同步与数据安全、自动化提醒与任务分派</strong>五大核心维度，进行「手术刀式」的深度对比，最终给出<strong>场景化选型建议</strong>。</p><h2>一、先明确：CRM的「底层逻辑」是什么？</h2><p>CRM的本质是「客户数据的闭环运营」——通过整合「获客-跟进-转化-留存-复购」全链路数据，用流程自动化减少手动操作，用数据洞察驱动决策，最终实现「客户价值最大化」。</p><p>因此，评价一款CRM的核心标准，不是「功能多少」，而是「在关键环节的赋能深度」：</p><ol><li><strong>能不能覆盖你业务的全流程？</strong> （比如制造企业需要ERP联动，电商需要社媒数据整合）</li><li><strong>能不能让团队「用起来」？</strong> （比如销售讨厌复杂界面，客服需要实时客户视图）</li><li><strong>能不能「随业务成长」？</strong> （比如从10人团队到1000人，从国内到全球）</li></ol><ul><li><ul><li>*</li></ul></li></ul><h2>二、五大维度深度对比：谁能解决你的「痛点」？</h2><h3><strong>维度1：客户</strong> <strong>全生命周期管理</strong> <strong>——从「流量」到「</strong> <strong>留量</strong> <strong>」的闭环能力</strong></h3><p><strong>核心价值</strong>：覆盖「获客→线索培育→商机转化→客户留存→复购增购」全环节，通过数据整合实现「客户价值的持续挖掘」。 <strong>关键评价指标</strong>：流程覆盖度、数据整合能力、AI/自动化赋能、行业适配性。</p><h4><strong>1.1 各品牌表现拆解</strong></h4><table><thead><tr><th><strong>品牌</strong></th><th><strong>流程覆盖</strong></th><th><strong>数据整合</strong></th><th><strong>AI/自动化</strong></th><th><strong>行业适配</strong></th></tr></thead><tbody><tr><td><strong>Salesforce</strong></td><td>全链路覆盖（SFA销售自动化+MA营销自动化+CSA服务自动化）</td><td>Data Cloud整合销售/服务/营销/商务数据，激活多渠道实时数据</td><td>Einstein AI预测赢单概率（≥85%）、自动推送个性化内容（如客户看产品文档时发案例）</td><td>跨国企业、高价值客户行业（金融/医疗）</td></tr><tr><td><strong>超兔一体云</strong></td><td>覆盖「多渠道获客→三一客节点跟进→合约执行→RFM复购」</td><td>自动抓取工商信息、整合官网/微信/小程序线索，与订单/采购数据联动</td><td>三一客模型（定性/定级/定量）、五大跟单模型（适配小单/大单/项目型业务）</td><td>国内中小企业、传统行业（贸易/服务/制造）</td></tr><tr><td><strong>SAP</strong></td><td>「营销获客→销售转化→服务留存→ERP联动生产」闭环</td><td>与SAP ERP深度集成，联动库存/生产/财务数据（如订单触发库存检查）</td><td>Joule智能助手（邮件自动撰写）、400+自动化场景（2024年底）</td><td>大型制造企业、能源/化工等重工业</td></tr><tr><td><strong>Zoho</strong></td><td>「线索捕获→商机管理→客户维护→复购提醒」全链路</td><td>整合邮件/电话/社媒数据，360°客户视图</td><td>Zia AI（销售预测、个性化互动）、工作流自动化（跟进线索/更新字段）</td><td>中小到中大型企业、外贸/电商</td></tr><tr><td><strong>金蝶CRM</strong></td><td>「线索捕获→商机管理→客户维护」，与金蝶ERP联动「获客-服务」</td><td>与金蝶K/3、Cloud ERP集成，共享库存/订单数据</td><td>基础自动化（线索分配/跟进提醒）</td><td>国内中小企业、ERP转型企业</td></tr><tr><td><strong>HubSpot CRM</strong></td><td>「营销获客→销售转化→服务留存」，免费版覆盖基础流程</td><td>整合Gmail/Outlook/Zoom数据，营销与销售数据联动</td><td>基础AI（线索评分、跟进建议）</td><td>初创企业、轻量级营销需求</td></tr></tbody></table><h4><strong>1.2 流程图：各品牌的「闭环差异」</strong></h4><p>用Mermaid绘制「客户全生命周期闭环」，直观展示各品牌的核心赋能环节：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442823" alt="" title=""/></p><pre><code>flowchart LR
    A[获客] --&gt; B[线索培育] --&gt; C[商机转化] --&gt; D[客户留存] --&gt; E[复购增购]
    
    %% Salesforce
    A --&gt;|Data Cloud整合多渠道| B
    B --&gt;|Einstein AI评分| C
    C --&gt;|Einstein预测赢单| D
    D --&gt;|AI流失预警| E
    
    %% 超兔一体云
    A --&gt;|工商搜客/多渠道线索| B
    B --&gt;|三一客节点| C
    C --&gt;|合约执行流程| D
    D --&gt;|RFM分析| E
    
    %% SAP
    A --&gt;|营销活动管理| B
    B --&gt;|销售流程自动化| C
    C --&gt;|ERP联动生产| D
    D --&gt;|满意度调查| E
    
    %% Zoho
    A --&gt;|多渠道线索捕获| B
    B --&gt;|Zia AI培育| C
    C --&gt;|360视图转化| D
    D --&gt;|Zia复购提醒| E</code></pre><h4><strong>1.3 关键结论</strong></h4><ul><li><strong>跨国企业选Salesforce</strong>：Data Cloud+Einstein AI能解决「全球数据整合+高价值客户运营」痛点；</li><li><strong>国内中小企业选超兔</strong>：三一客模型+工商搜客完美适配「本土获客-跟进」场景；</li><li><strong>制造企业选SAP</strong>：ERP联动能解决「销售-生产-库存」的协同问题；</li><li><strong>外贸企业选Zoho</strong>：多语言/货币+社媒数据整合，适配「跨境客户运营」。</li><li><ul><li>*</li></ul></li></ul><h3><strong>维度2：销售过程跟进与团队协作——从「个人英雄」到「团队效率」的升级</strong></h3><p><strong>核心价值</strong>：通过「流程可视化+团队协同工具+移动能力」，让销售团队从「各自为战」转向「目标一致」，提升整体转化效率。 <strong>关键评价指标</strong>：销售流程可视化、团队协作工具、移动能力、集成生态。</p><h4><strong>2.1 各品牌表现拆解</strong></h4><table><thead><tr><th><strong>品牌</strong></th><th><strong>销售流程可视化</strong></th><th><strong>团队协作工具</strong></th><th><strong>移动能力</strong></th><th><strong>集成生态</strong></th></tr></thead><tbody><tr><td><strong>Pipedrive</strong></td><td>可视化销售管道（拖放卡片更新状态），聚焦「交易达成」</td><td>任务活动管理、共享客户互动历史</td><td>跨设备同步，与邮件/日历无缝协作</td><td>500+应用（如Mailchimp/Google Workspace）</td></tr><tr><td><strong>Salesforce</strong></td><td>自定义销售漏斗、实时追踪客户滞留时长</td><td>Chatter实时对话（附照片/文件）、移动端智能路线规划</td><td>手机/平板客户端，支持语音录入/离线编辑</td><td>AppExchange 6000+应用（SAP/Oracle等）</td></tr><tr><td><strong>超兔一体云</strong></td><td>360°跟单视图（整合客户背景/沟通记录/订单）、五大跟单模型</td><td>双重指挥系统（行政+业务结构）、助理跟随主管权限</td><td>Web/App/小程序/RPA插件，实时同步</td><td>适配国内工具（微信/钉钉/企业微信）</td></tr><tr><td><strong>钉钉</strong></td><td>需结合CRM插件，基础漏斗视图</td><td>外勤签到（位置+拍照）、Teams实时沟通、工作日志共享</td><td>手机客户端，支持审批/消息实时同步</td><td>深度集成钉钉生态（OA/考勤/文档）</td></tr><tr><td><strong>Zoho</strong></td><td>蓝图功能（线下流程线上化，如线索分配/折扣审批）</td><td>Zoho Flow连接200+应用（如Slack/Google Drive）、共享任务列表</td><td>移动APP支持离线编辑/即时发送，多语言界面</td><td>外贸工具（如Shopify/PayPal）</td></tr></tbody></table><h4><strong>2.2 脑图：各品牌「销售协作」核心能力</strong></h4><p>用Mermaid绘制「销售协作能力脑图」，清晰展示各品牌的侧重：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442826" alt="" title="" loading="lazy"/></p><pre><code>mindmap
    root(销售过程协作核心能力)
        Pipedrive
            可视化销售管道
            500+应用集成
            任务活动管理
        Salesforce
            自定义销售漏斗
            Chatter实时对话
            移动端路线规划
            AppExchange生态
        超兔一体云
            360°跟单视图
            华为双重指挥
            多端同步(RPA/小程序)
        钉钉
            外勤签到
            Teams集成
            工作日志共享
        Zoho
            蓝图流程线上化
            Zoho Flow跨工具
            移动离线编辑</code></pre><h4><strong>2.3 关键结论</strong></h4><ul><li><strong>聚焦销售流程选Pipedrive</strong>：可视化管道+简洁界面，适合「以交易为核心」的团队；</li><li><strong>外勤团队选Salesforce/超兔</strong>：移动端路线规划/多端同步，解决「跑客户」的痛点；</li><li><strong>办公协同选钉钉</strong>：深度集成OA/考勤，适合「重内部协作」的企业；</li><li><strong>跨工具协作选Zoho</strong>：Flow连接200+应用，解决「工具碎片化」问题。</li><li><ul><li>*</li></ul></li></ul><h3><strong>维度3：自定义表单/流程/报表——从「标准化」到「个性化」的适配</strong></h3><p><strong>核心价值</strong>：通过「自定义」解决「业务场景差异化」问题，让CRM「适配你的业务」，而非「你适配CRM」。 <strong>关键评价指标</strong>：表单灵活度、流程配置能力、报表深度、低代码/无代码能力。</p><h4><strong>3.1 各品牌表现拆解</strong></h4><table><thead><tr><th><strong>品牌</strong></th><th><strong>表单自定义</strong></th><th><strong>流程自定义</strong></th><th><strong>报表自定义</strong></th><th><strong>低代码能力</strong></th></tr></thead><tbody><tr><td><strong>Zoho</strong></td><td>低代码编辑器，支持拖拽添加字段（如客户行业/采购预算）</td><td>Zoho Flow：无代码配置流程（如线索变高意向时自动发邮件）</td><td>70+内置报表，支持自定义维度（如销售业绩/客户分布）</td><td>强（非技术人员可配置）</td></tr><tr><td><strong>Salesforce</strong></td><td>Lightning组件：拖拽配置表单，支持复杂字段（如关联ERP数据）</td><td>Apex代码+Flow：定制复杂流程（如制造企业设备维护工单）</td><td>多维度报表+Tableau集成，支持实时大屏</td><td>强（需技术人员）</td></tr><tr><td><strong>超兔一体云</strong></td><td>自定义客户/订单/项目表单字段，支持显示布局调整</td><td>自定义工作流（自动触发任务/发送消息），支持步骤限时/精确权限</td><td>数字卡片/图表卡片自定义，多表聚合查询/同比环比分析</td><td>中（适合国内中小企业）</td></tr><tr><td><strong>SuiteCRM</strong></td><td>开源：自定义表单字段/布局，支持二次开发</td><td>开源：自定义审批流/工作流，需PHP技术</td><td>内置ROI计算器/邮件跟踪报表，支持自定义维度</td><td>强（需技术团队）</td></tr><tr><td><strong>HubSpot CRM</strong></td><td>基础自定义（添加文本/下拉字段），高级功能需付费</td><td>基础流程配置（如线索分配），复杂流程需升级HubSpot Operations Hub</td><td>营销/销售数据联动报表，支持基础自定义</td><td>弱（适合初创）</td></tr></tbody></table><h4><strong>3.2 流程图：「自定义流程」配置逻辑</strong></h4><p>用Mermaid绘制「自定义工作流」的典型场景（以Zoho和Salesforce为例）：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442828" alt="" title="" loading="lazy"/></p><pre><code>flowchart TD
    A[触发条件：线索状态→高意向] --&gt; B[流程步骤1：自动发送邮件给销售]
    B --&gt; C[流程步骤2：创建跟进任务（截止时间24小时）]
    C --&gt; D[流程步骤3：更新客户字段「跟进优先级→高」]
    
    %% Zoho Flow配置
    A --&gt;|Zoho Flow无代码| B
    B --&gt;|Zoho Flow| C
    C --&gt;|Zoho Flow| D
    
    %% Salesforce配置
    A --&gt;|Apex代码| B
    B --&gt;|Flow| C
    C --&gt;|Lightning组件| D</code></pre><h4><strong>3.3 关键结论</strong></h4><ul><li><strong>非技术团队选Zoho</strong>：低代码Flow+70+报表，不用找IT就能配置；</li><li><strong>复杂业务选Salesforce/SuiteCRM</strong>：Apex代码/开源二次开发，适配「定制化极强」的场景（如制造/金融）；</li><li><strong>国内中小企业选超兔</strong>：自定义表单/流程符合本土需求（如工商信息字段）；</li><li><strong>初创企业选HubSpot</strong>：基础自定义+免费版，成本低。</li><li><ul><li>*</li></ul></li></ul><h3><strong>维度4：多端同步与数据安全——从「便捷」到「信任」的保障</strong></h3><p><strong>核心价值</strong>：「多端同步」<strong>解决「随时随地办公」的需求，</strong> 「数据安全」解决「客户信息泄露」的风险。 <strong>关键评价指标</strong>：多端支持度、同步实时性、安全合规性、本地化部署能力。</p><h4><strong>4.1 各品牌表现拆解</strong></h4><table><thead><tr><th><strong>品牌</strong></th><th><strong>多端支持</strong></th><th><strong>同步实时性</strong></th><th><strong>安全合规</strong></th><th><strong>本地化部署</strong></th></tr></thead><tbody><tr><td><strong>Salesforce</strong></td><td>Web/手机/平板/桌面客户端</td><td>全球云同步，实时更新</td><td>GDPR/CCPA/ISO 27001，分级权限+数据加密</td><td>支持（需额外付费）</td></tr><tr><td><strong>超兔一体云</strong></td><td>Web/App/小程序/客户端/RPA插件</td><td>实时同步（如官网线索抓取后立即推送到销售APP）</td><td>权限控制（上级管下级，同级隔离）、数据加密/备份</td><td>支持（国内服务器）</td></tr><tr><td><strong>用友CRM</strong></td><td>Web/手机/平板</td><td>实时同步（与用友ERP数据联动）</td><td>《网络安全法》/等保三级，数据存储在国内服务器</td><td>支持（必选）</td></tr><tr><td><strong>Zoho</strong></td><td>Web/手机/平板/桌面客户端</td><td>实时同步（邮件/任务/客户数据）</td><td>数据加密、180种货币实时汇率、22种语言</td><td>支持（全球数据中心）</td></tr><tr><td><strong>SAP</strong></td><td>Web/手机/平板</td><td>基于BTP平台，实时同步企业级数据</td><td>三层安全架构（应用-数据-AI）、GDPR/CCPA</td><td>支持（企业自有服务器）</td></tr></tbody></table><h4><strong>4.2 雷达图：各品牌「多端与安全」能力分值</strong></h4><p>（注：分值1-10，越高越强）</p><table><thead><tr><th><strong>品牌</strong></th><th>多端支持</th><th>同步实时性</th><th>安全合规</th><th>本地化部署</th></tr></thead><tbody><tr><td>Salesforce</td><td>9</td><td>10</td><td>10</td><td>8</td></tr><tr><td>超兔一体云</td><td>10</td><td>9</td><td>9</td><td>10</td></tr><tr><td>用友CRM</td><td>8</td><td>9</td><td>10</td><td>10</td></tr><tr><td>Zoho</td><td>9</td><td>9</td><td>9</td><td>8</td></tr><tr><td>SAP</td><td>8</td><td>10</td><td>10</td><td>10</td></tr></tbody></table><h4><strong>4.3 关键结论</strong></h4><ul><li><strong>跨国企业选Salesforce</strong>：全球云+GDPR，解决「跨区域数据同步+合规」问题；</li><li><strong>国内企业选超兔/用友</strong>：国内服务器+《网络安全法》，避免「数据出境」风险；</li><li><strong>外贸企业选Zoho</strong>：多语言+货币同步，适配「全球客户」需求；</li><li><strong>大型企业选SAP</strong>：BTP平台+三层安全，保障「企业级数据」的稳定。</li></ul>]]></description></item><item>    <title><![CDATA[别让AI智能体瞎干活！多Agent分工+]]></title>    <link>https://segmentfault.com/a/1190000047442820</link>    <guid>https://segmentfault.com/a/1190000047442820</guid>    <pubDate>2025-12-02 10:02:19</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>兄弟们，见字如面，我是王中阳。</blockquote><p>最近我们团队扎在<strong>AI智能体应用开发</strong>里，<strong>Trea solo模式</strong>下的<strong>多Agent协同</strong>算是把坑踩了个遍——最痛的一次，因为把<strong>架构设计</strong>和<strong>代码实现</strong>丢给同一个智能体，直接导致项目延期两周。今天就把“<strong>智能体职责划分</strong>”的实战经验掏给大家，全是能直接抄的干货。</p><p><strong>这张图，就值得兄弟们实操一下：</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442824" alt="" title=""/></p><p>很多人刚搞<strong>多Agent开发</strong>时都犯过这个错：觉得“一个智能体多干活，省得协调”。但实测下来，这跟让建筑设计师去砌墙没区别——要么顾不上全局，要么栽在细节里。今天核心就讲透一件事：为啥<strong>架构师</strong>和<strong>后端开发智能体</strong>必须分开，以及怎么分才能<strong>高效协同</strong>。</p><h2>一、血泪教训换的结论：必须拆成两个独立智能体</h2><p>先把结论摆死：<strong>多Agent开发</strong>里，<strong>后端架构师</strong>和<strong>后端开发智能体</strong>，<strong>拆分是唯一解</strong>。我们前两次试错都是因为“二合一”，踩的坑现在想起来都肉疼，这也让我们摸透了拆分的<strong>底层逻辑</strong>。</p><h3>1. 职责边界不清，等于埋雷</h3><p>架构师智能体的核心是“<strong>掌方向</strong>”，后端开发智能体是“<strong>踏实地</strong>”，混在一起准出问题。我们第一次做<strong>AI客服系统</strong>时，让一个智能体既设计<strong>微服务架构</strong>，又写用户登录接口，结果它为了追求代码简洁，把<strong>权限校验逻辑</strong>直接砍了——架构层面的“<strong>安全性</strong>”和开发层面的“<strong>便捷性</strong>”直接冲突。</p><p>拆分后就清爽了：</p><ul><li><strong>架构师智能体</strong>：管<strong>整体架构</strong>、<strong>技术选型</strong>（比如用GoZero还是SpringAI）、<strong>微服务拆分</strong>、<strong>API规范</strong>这些“大方向”；</li><li><strong>后端开发智能体</strong>：专心写<strong>接口</strong>、做<strong>单元测试</strong>、修<strong>bug</strong>，不用操心“这个服务拆得对不对”。</li></ul><h3>2. 能力要求完全是两码事</h3><p>做架构需要“<strong>全局眼</strong>”，得知道哪种<strong>技术栈</strong>能扛住未来10万用户的<strong>并发</strong>；写代码需要“<strong>钻牛角尖</strong>”，得清楚Go的<strong>切片扩容机制</strong>会不会踩内存坑。这两种能力的<strong>训练方向</strong>根本不一样。</p><p>我们现在给架构师智能体喂的是过往10个项目的<strong>架构文档</strong>和<strong>性能复盘报告</strong>，给开发智能体练的是<strong>百万行级别</strong>的优质代码库——<strong>专攻一项</strong>，效率直接翻番。</p><h3>3. 并行干活，进度直接提速50%</h3><p>这是最实际的好处。架构师智能体刚输出<strong>API规范</strong>，开发智能体就能接手写基础接口，不用等完整<strong>架构文档</strong>落地。我们最近做的<strong>企业知识库项目</strong>，就靠这招把20天的开发周期压缩到12天——架构师在优化<strong>微服务通信机制</strong>时，开发已经把PgVector的<strong>向量存储接口</strong>写完了。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442825" alt="" title="" loading="lazy"/></p><h2>二、实战派分工方案：3类智能体职责说明（直接复制用）</h2><p>光说拆分没用，得把“<strong>谁该干啥、不该干啥</strong>”写死。下面是我们迭代3次后的最终分工说明，按角色拆分核心职责与红线，比表格更清晰，避免信息扎堆：</p><h4><strong>1. 后端架构师智能体</strong></h4><p><strong>核心职责</strong>：</p><ul><li>定架构：微服务拆分（如“用户服务+知识库服务+交互服务”）</li><li>选技术：框架（SpringAI/GoZero）、组件（PgVector）选型</li><li>画规范：编写API文档，明确入参、出参及错误码</li><li>盯性能：预判瓶颈（如向量检索需加缓存）</li><li>对接前端：确认交互逻辑与API适配需求</li></ul><p><strong>绝对红线</strong>：</p><ul><li>不写业务代码（如登录接口等具体实现）</li><li>不参与单元测试审核</li><li>不处理“接口字段缺失”等小bug</li></ul><h4><strong>2. 后端开发智能体</strong></h4><p><strong>核心职责</strong>：</p><ul><li>按API文档规范编写业务代码</li><li>执行单元测试+集成测试，保障接口可用</li><li>修复开发中的语法错、逻辑错</li><li>优化代码（如抽取重复工具类）</li><li>参与代码评审，对齐架构要求</li></ul><p><strong>绝对红线</strong>：</p><ul><li>不擅自修改系统架构或服务拆分逻辑</li><li>不更换架构师指定的技术组件（如用Milvus替代PgVector）</li><li>重大变更（如新增字段）必须请示架构师</li></ul><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442827" alt="" title="" loading="lazy"/></p><h4><strong>3. 前端智能体</strong></h4><p><strong>核心职责</strong>：</p><ul><li>将原型图转化为可交互界面</li><li>按API规范对接后端接口</li><li>优化用户体验（如输入防抖、加载骨架屏）</li><li>实现多端适配（手机/电脑端兼容）</li></ul><p><strong>绝对红线</strong>：</p><ul><li>不直接访问后端数据库</li><li>不擅自修改接口逻辑，疑问需同步架构师</li><li>前端架构变更（如加状态管理）需提前与后端沟通</li></ul><h2>三、协作流程：从踩坑到丝滑的3步玩法</h2><p>分工明确后，<strong>协作流程</strong>得跟上。我们总结了“<strong>架构先行、并行开发、联调闭环</strong>”的套路，现在团队协作比之前顺畅太多，分享给大家。</p><h3>1. 第一步：架构师先搭好骨架（1-3天）</h3><p>架构师智能体先拉着前端智能体开“<strong>需求对齐会</strong>”，重点输出两样东西：</p><ul><li><strong>架构图</strong>+<strong>技术选型说明</strong>：比如“用GoZero做微服务框架，PgVector存向量数据”，得说清为啥这么选</li><li><strong>OpenAPI规范文档</strong>：用Swagger写清楚每个接口的<strong>路径</strong>、<strong>参数</strong>、<strong>返回值</strong>，前端直接能生成请求代码</li></ul><p>这里提醒一句：<strong>别搞口头同步</strong>！我们之前试过一次，架构师说“兼容旧接口”，开发智能体直接理解成“废弃旧接口”，差点出<strong>生产事故</strong>——<strong>文档才是硬标准</strong>。</p><h3>2. 第二步：开发并行冲，架构师当后盾（核心阶段）</h3><p>这阶段架构师和开发智能体各干各的，效率最高：</p><ul><li>开发智能体：照着<strong>API文档</strong>写代码、做测试，遇到“这个逻辑要不要加日志”这种细节，不用问架构师，按<strong>团队编码规范</strong>来</li><li>架构师智能体：不是没事干，要盯两个点——一是开发有没有<strong>偏离架构</strong>（比如私自加了个服务间的直接调用），二是解决开发提的<strong>技术难题</strong>（比如“PgVector的索引怎么建才快”）</li><li>前端智能体：同步用<strong>Mock服务</strong>调接口写页面，不用等后端接口落地</li></ul><h3>3. 第三步：联调闭环，问题不过夜</h3><p>接口开发完就进入<strong>联调</strong>，这里要做好两件事：</p><ol><li><strong>实时沟通</strong>：建个专属沟通群，开发和前端联调遇到“接口返回格式不对”，直接@架构师和相关智能体，<strong>10分钟内响应</strong></li><li><strong>代码评审</strong>：开发提交代码后，架构师重点看“是否符合<strong>架构设计</strong>”，比如“微服务之间是不是通过<strong>API网关</strong>通信”，不用纠结“变量名起得好不好”</li></ol><h2>四、避坑补充：3个关键提醒</h2><p>这些都是我们<strong>真金白银买的教训</strong>，记好能少走很多弯路：</p><h3>1. 任务优先级要分清，别瞎忙</h3><p>给任务标上<strong>P0-P3优先级</strong>，各智能体盯好自己的重点：</p><ul><li><strong>P0（紧急）</strong> ：系统崩了、核心接口用不了——架构师和开发一起上</li><li><strong>P1（重要）</strong> ：核心功能开发、性能瓶颈优化——架构师盯方案，开发盯实现</li><li><strong>P2-P3（常规）</strong> ：代码重构、文档完善——开发自己安排就行</li></ul><h3>2. 冲突别扯皮，按规则来</h3><p>遇到分歧别<strong>内耗</strong>，我们定了个简单规则：</p><ul><li><strong>架构问题</strong>：架构师拍板，但要听开发的<strong>可行性建议</strong>（比如“这个方案代码实现太复杂，能不能简化”）</li><li><strong>API问题</strong>：前后端协商，架构师当裁判，优先保<strong>系统整体逻辑</strong></li></ul><h3>3. 智能体要持续调教，不是一劳永逸</h3><p>别指望智能体一开始就完美干活：</p><ul><li>给架构师智能体喂我们过往的<strong>项目架构文档</strong>，让它学我们的风格</li><li>开发智能体写完代码，我们<strong>人工标错</strong>几次，它就知道“哪些坑不能踩”了</li><li>每周花1小时<strong>复盘</strong>，比如“这周开发智能体越界改了架构，下次怎么通过<strong>提示词</strong>限制它”</li></ul><h2>最后说句实在话</h2><p>多Agent协作的核心不是“用AI替代人”，而是让智能体像<strong>专业团队</strong>一样分工协作。把架构师和开发的职责拆清楚，再搭好流程，你会发现——<strong>AI智能体比人还好管理</strong>，只要<strong>规则明确</strong>，它绝对不摸鱼、不甩锅。</p><p>如果你们在<strong>智能体分工</strong>上有别的坑，或者有更好的方案，评论区留言，咱们一起拆解。</p><p>我是阳哥，专注分享<strong>AI+后端</strong>的实战干货，关注我，下次踩坑少走弯路！</p>]]></description></item><item>    <title><![CDATA[2025年AI Wiki软件大比拼：Pa]]></title>    <link>https://segmentfault.com/a/1190000047442852</link>    <guid>https://segmentfault.com/a/1190000047442852</guid>    <pubDate>2025-12-02 10:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>大家好，我是老张，一个在互联网行业摸爬滚打了十年的技术老鸟。今天想和大家聊聊一个特别实用的话题——<strong>AI Wiki软件</strong>。作为一个经常需要整理文档、管理知识库的"文档狗"，我深知一个好用的Wiki工具能带来多大的效率提升。</p><h2>为什么你需要一个AI Wiki？</h2><p>记得去年我们团队接了个大项目，各种需求文档、技术方案、会议记录满天飞。最夸张的时候，光是找一份两周前的会议纪要，就花了我们半个多小时！更别提那些重复回答了几十遍的新人问题了...</p><p>那时候我就意识到，<strong>传统的文档管理方式已经跟不上这个AI时代了</strong>。直到我发现了这些AI Wiki工具，简直打开了新世界的大门！</p><h2>2025年最值得关注的AI Wiki工具</h2><h3>1. PandaWiki：一站式智能文档中心</h3><p><img width="723" height="268" referrerpolicy="no-referrer" src="/img/bVdnbcz" alt="" title=""/></p><p>PandaWiki是我目前的主力工具，它最大的特点就是<strong>开箱即用</strong>。你只需要一行Docker命令，就能拥有一个完整的智能文档系统。</p><p>我最喜欢它的三个功能：</p><ul><li><strong>AI创作助手</strong>：写文档时能自动生成大纲、补充内容</li><li><strong>智能问答</strong>：新人问问题，AI直接回答，省了我不少时间</li><li><strong>精准搜索</strong>：再也不用在几十个文档里大海捞针了</li></ul><p>看看这个三国小说的演示网站，左侧目录、中间内容、右侧AI摘要，布局特别清晰：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442854" alt="" title="" loading="lazy"/></p><p><a href="https://link.segmentfault.com/?enc=XZZXwFlqXfp9jREAGQcG2Q%3D%3D.OCZc%2BdLHyL0p4tDHMGFGsgedBPOx%2BBVB8EwEzC8l8Wgc0cnnM8GFdFkgQxCcZxYo5iaNCAxWbgu1180336N%2FdT%2BshOFJg4PzZVthlPs8iPM%3D" rel="nofollow" target="_blank">点击查看PandaWiki官方文档</a></p><h3>2. ChatWiki：客服场景的王者</h3><p>如果你主要做客服系统，那ChatWiki绝对是你的菜。它支持20多种主流模型，包括DeepSeek、豆包Pro这些，特别适合需要对接多个AI服务的场景。</p><p>我们公司客服部门用了ChatWiki后，常见问题处理时间从平均5分钟降到了30秒！而且它还能自动优化问题表述，让AI回答更准确。</p><h3>3. MaxKB：企业级知识中枢</h3><p>MaxKB更适合中大型企业，它能无缝集成到现有系统中。我们IT部门用它搭建了内部知识库，连HR系统都能调用，新员工培训效率提升了3倍！</p><h2>真实使用体验对比</h2><p>去年我带着团队对这三款工具做了为期三个月的测试，这里分享一些真实数据：</p><table><thead><tr><th>功能</th><th>PandaWiki</th><th>ChatWiki</th><th>MaxKB</th></tr></thead><tbody><tr><td>部署难度</td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐⭐</td><td>⭐⭐⭐</td></tr><tr><td>AI回答准确率</td><td>92%</td><td>95%</td><td>90%</td></tr><tr><td>多模型支持</td><td>5种</td><td>20+种</td><td>10种</td></tr><tr><td>适合场景</td><td>全功能</td><td>客服</td><td>企业级</td></tr></tbody></table><p><a href="https://link.segmentfault.com/?enc=xbPENczwQapYPin8S9Sekg%3D%3D.e867OscWoLACDgUMM16Hyhip9SzCEHcBThnv%2FcsCv3SIKbtDPhhNVZkHytc1uUxYO1Hh%2F3WhQZ4gSW%2FMipfx%2B3D4aTm5Jb%2Frs%2FjKaqGFFIA%3D" rel="nofollow" target="_blank">详细对比报告看这里</a></p><h2>为什么我最终选择了PandaWiki？</h2><p>虽然三款工具都很优秀，但PandaWiki最打动我的是它的<strong>平衡性</strong>：</p><ol><li>部署简单到连我们市场部的小姐姐都能搞定</li><li>功能全面，从写文档到问答搜索一条龙</li><li>社区活跃，GitHub上近6K Star，问题解决快</li><li>中文支持好，不像有些国外工具水土不服</li></ol><p>看看这个产品文档的演示，清晰度堪比专业文档网站：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442855" alt="" title="" loading="lazy"/></p><h2>给新手的建议</h2><p>如果你是第一次接触AI Wiki，我建议：</p><ol><li>先试用PandaWiki的在线Demo</li><li>从小型知识库开始，比如团队FAQ</li><li>逐步添加AI功能，别一上来就搞太复杂</li><li>多利用社区资源，遇到问题先搜一搜</li></ol><p><a href="https://link.segmentfault.com/?enc=dHXdwriaZZe6WJ5cz%2FLDoA%3D%3D.Moth%2Fzn%2BZuRPEclXo%2BYNtH%2F28edxPCiVttjpVFa%2B5iJZNQpYPhmeBMR0sMlhdYCiklw7VscHca2nmdXt3XNWytXGX4xH8P2%2FUpOKqn51ECk%3D" rel="nofollow" target="_blank">5分钟快速入门指南</a></p><h2>写在最后</h2><p>在这个信息过载的时代，一个好的知识管理工具真的能让你事半功倍。无论你是个人开发者、创业团队还是大型企业，都值得拥有一套智能化的Wiki系统。</p><p>如果你还在为文档管理头疼，不妨试试这些AI Wiki工具。相信我，用过后你就再也回不去了！</p><p><strong>你用过哪些好用的Wiki工具？欢迎在评论区分享你的经验~</strong></p>]]></description></item><item>    <title><![CDATA[C# 原始字符串字面量全面解析：多行字符]]></title>    <link>https://segmentfault.com/a/1190000047442670</link>    <guid>https://segmentfault.com/a/1190000047442670</guid>    <pubDate>2025-12-02 09:04:07</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3>简介</h3><p><code>C# 11</code> 引入了原始字符串字面量（<code>Raw String Literals</code>），这是一个革命性的特性，极大地简化了包含大量特殊字符（如引号、反斜杠、换行符等）的字符串处理。</p><p>原始字符串字面量允许创建包含任意文本的字符串，而无需转义特殊字符。它们以至少三个双引号 <code>"""</code> 开始和结束，并且可以跨越多行。</p><h3>核心特性与优势</h3><h4>核心特点</h4><ul><li>无转义需求：不需要对引号、反斜杠等特殊字符进行转义</li><li>多行支持：原生支持多行字符串格式</li><li>空白保留：精确保留源代码中的缩进和格式化</li><li>灵活分隔符：使用可变数量的双引号作为分隔符</li><li>字符串插值：可与插值语法无缝结合</li></ul><h4>与传统字符串对比</h4><table><thead><tr><th>特性</th><th>常规字符串</th><th>逐字字符串(@)</th><th>原始字符串字面量</th></tr></thead><tbody><tr><td>转义需求</td><td>需要转义特殊字符</td><td>不需要转义，但对双引号仍需转义</td><td>完全不需要转义</td></tr><tr><td>多行支持</td><td>需使用<code>\n</code>等</td><td>支持</td><td>原生支持</td></tr><tr><td>缩进保留</td><td>不保留</td><td>保留所有缩进</td><td>智能缩进处理</td></tr><tr><td>引号处理</td><td><code>\"</code></td><td><code>""</code></td><td>直接使用</td></tr><tr><td>JSON/XML</td><td>可读性差</td><td>可读性中等</td><td>完美呈现</td></tr></tbody></table><h3>基本语法</h3><pre><code class="csharp">// 基本原始字符串
string basic = """这是一个原始字符串，不需要转义 "引号" 和 \反斜杠""";

// 多行原始字符串
string multiLine = """
    这是一个
    多行原始字符串
    可以包含 "引号" 和 \反斜杠
    """;

// 包含大括号的原始字符串
string withBraces = """
    { "name": "John", "age": 30 }
    """;</code></pre><h3>核心特性与优势</h3><h4>无需转义特殊字符</h4><pre><code class="csharp">// 传统方式（需要转义）
string traditional = "这是一个包含\"引号\"和\\反斜杠的字符串";

// 原始字符串方式（无需转义）
string raw = """这是一个包含"引号"和\反斜杠的字符串""";

// 正则表达式示例
string regexPattern = """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""";</code></pre><h4>多行字符串处理</h4><pre><code class="csharp">// 传统多行字符串（需要转义和连接）
string oldMultiLine = "第一行\n" +
                     "第二行\n" +
                     "第三行";

// 原始多行字符串（更简洁）
string newMultiLine = """
    第一行
    第二行
    第三行
    """;

// JSON 示例
string json = """
    {
        "name": "John Doe",
        "age": 30,
        "email": "john@example.com"
    }
    """;</code></pre><h4>缩进处理</h4><p>原始字符串字面量会自动处理缩进，使代码保持整洁：</p><pre><code class="csharp">string GetFormattedMessage()
{
    return """
        Hello,
            This is an indented message.
        It preserves the formatting exactly as written.
        """;
}

// 输出结果：
// Hello,
//     This is an indented message.
// It preserves the formatting exactly as written.</code></pre><h4>引号数量规则</h4><p>当字符串内容包含三个或更多连续双引号时，需要使用更多引号作为分隔符：</p><pre><code class="csharp">// 内容包含三个双引号 → 使用四个作为分隔符
string tripleQuotes = """" 这里可以包含 """ 三个引号 """";

// 内容包含四个双引号 → 使用五个作为分隔符
string fourQuotes = """"" 这里可以包含 """" 四个引号 """"";</code></pre><p>引号数量选择原则</p><ul><li>分隔符的双引号数量(N)必须大于内容中连续双引号的最大数量(M)</li><li>最小分隔符数量为3（即使内容没有三个引号）</li><li>公式：<code>N &gt; M</code></li></ul><h4>多$符号规则</h4><ul><li><code>$</code> 的数量决定了插值表达式的边界</li><li>一个 <code>$</code> → 表达式使用 <code>{ }</code></li><li>两个 <code>$$</code> → 表达式使用 <code>{{ }}</code>，以此类推</li></ul><h3>高级用法与技巧</h3><h4>包含更多引号</h4><p>如果需要字符串中包含三个或更多连续双引号，可以使用更多引号作为分隔符：</p><pre><code class="csharp">// 使用四个引号作为分隔符，以包含三个引号
string withTripleQuotes = """"
    这个字符串包含三个连续引号: """
    """";

// 使用五个引号作为分隔符，以包含四个引号
string withFourQuotes = """""
    这个字符串包含四个连续引号: """"
    """"";</code></pre><h4>与字符串插值结合使用</h4><p>原始字符串可以与字符串插值结合使用，提供更强大的功能：</p><pre><code class="csharp">string name = "John";
int age = 30;

// 基本插值
string interpolated = $$"""
    {
        "name": "{{name}}",
        "age": {{age}}
    }
    """;

// 复杂插值（使用多个$符号）
string complex = $$$"""
    {
        "name": "{{{name}}}",  // 注意：这里需要三个大括号
        "age": {{age}}
    }
    """;</code></pre><h4>最小化缩进</h4><p>原始字符串会自动去除与结束引号对齐的缩进：</p><pre><code class="csharp">string minimalIndent = """
    First line
    Second line
    Third line
    """; // 结束引号的缩进决定了最小缩进

// 等效于：
// "First line\nSecond line\nThird line"</code></pre><h3>实际应用场景</h3><h4>JSON 和 XML 处理</h4><pre><code class="csharp">// JSON 配置
string configJson = """
    {
        "appSettings": {
            "timeout": 30,
            "retryCount": 3,
            "apiUrl": "https://api.example.com"
        },
        "logging": {
            "level": "Information",
            "filePath": "logs/app.log"
        }
    }
    """;

// XML 文档
string xmlDocument = """
    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;catalog&gt;
        &lt;book id="bk101"&gt;
            &lt;author&gt;Gambardella, Matthew&lt;/author&gt;
            &lt;title&gt;XML Developer's Guide&lt;/title&gt;
            &lt;genre&gt;Computer&lt;/genre&gt;
            &lt;price&gt;44.95&lt;/price&gt;
            &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt;
            &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt;
        &lt;/book&gt;
    &lt;/catalog&gt;
    """;</code></pre><h4>正则表达式模式</h4><pre><code class="csharp">// 复杂的正则表达式（无需转义反斜杠）
string emailPattern = """^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$""";
string phonePattern = """^(\+\d{1,3}\s?)?(\(\d{1,4}\)\s?)?\d{1,4}[\s.-]?\d{1,4}[\s.-]?\d{1,9}$""";

// 使用正则表达式
bool isValidEmail = Regex.IsMatch("test@example.com", emailPattern);</code></pre><h4>SQL 查询</h4><pre><code class="csharp">string sqlQuery = """
    SELECT 
        u.Id,
        u.Name,
        u.Email,
        COUNT(o.Id) AS OrderCount
    FROM Users u
    LEFT JOIN Orders o ON u.Id = o.UserId
    WHERE u.IsActive = 1
    GROUP BY u.Id, u.Name, u.Email
    HAVING COUNT(o.Id) &gt; 0
    ORDER BY OrderCount DESC
    """;</code></pre><h4>代码生成</h4><pre><code class="csharp">string GenerateCSharpClass(string className, IEnumerable&lt;string&gt; properties)
{
    return $$"""
        public class {{className}}
        {
            {{string.Join("\n    ", properties.Select(p =&gt; $"public string {p} {{ get; set; }}"))}}
            
            public {{className}}()
            {
            }
            
            public override string ToString()
            {
                return $"{{
                    {{string.Join(", ", properties.Select(p =&gt; $"{p}={{{p}}}"))}}
                }}";
            }
        }
        """;
}

// 使用示例
string classCode = GenerateCSharpClass("Person", new[] { "FirstName", "LastName", "Age" });</code></pre><h3>总结</h3><p><code>C# 11</code> 的原始字符串字面量是一个强大的特性，它：</p><ul><li>消除转义需求：无需转义引号、反斜杠等特殊字符</li><li>支持多行内容：轻松创建多行字符串，保持格式</li><li>智能缩进处理：自动处理缩进，使代码更整洁</li><li>与插值结合：支持字符串插值，创建动态内容</li><li>编译时处理：无运行时性能开销</li></ul><p>适用场景：</p><ul><li><code>JSON/XML/HTML</code> 内容：处理结构化数据</li><li>正则表达式：编写复杂的模式匹配</li></ul><p><code>SQL</code> 查询：编写多行数据库查询</p><ul><li>代码生成：创建模板化代码</li><li>文档字符串：编写格式化的文档</li></ul>]]></description></item><item>    <title><![CDATA[程序员常用的 Windows SSH 客]]></title>    <link>https://segmentfault.com/a/1190000047442674</link>    <guid>https://segmentfault.com/a/1190000047442674</guid>    <pubDate>2025-12-02 09:03:30</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img referrerpolicy="no-referrer" src="/img/remote/1460000045386595" alt="User-Friendly SSH Clients for Windows" title="User-Friendly SSH Clients for Windows"/></p><p>SSH （Secure Shell）是一种用于连接远程设备的流行协议，SSH 客户端用于建立这些连接。但是，大多数 SSH 客户端使用命令行接口，对于一些用户来说，可能是令人生畏和困难的。</p><p>在本文中，我们将向您介绍一些对用户友好的 Windows SSH 客户端。</p><h3>1. MobaXterm</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442676" alt="MobaXterm SSH Client" title="MobaXterm SSH Client" loading="lazy"/></p><p>MobaXterm 是一个用户友好的，为系统管理员和高级用户设计的 SSH 客户端。MobaXterm 包括一个标签界面，支持多个会话，还有很多其他的功能。它还包括先进的系统工具管理，例如 X11 服务器、远程桌面客户端和文件传输客户端。MobaXterm 也是可定制的，可以选择更改字体、配色方案和其他设置。</p><p><strong>优点</strong></p><ul><li>用户友好的界面与选项卡界面，方便管理多个会话。</li><li>支持多种协议，并包括用于系统管理的高级工具。</li><li>包括一个内置的文件传输客户端。</li><li>可定制的界面。</li></ul><p><strong>缺点</strong></p><ul><li>商业软件，不是免费的。</li><li>对于一些用户来说，界面可能是压倒性的。</li></ul><h3>2. Bitvise SSH Client</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442677" alt="Bitvise SSH Client" title="Bitvise SSH Client" loading="lazy"/></p><p>Bitvise SSH 客户端是一个用户友好的 SSH 客户端，主打易用和安全。Bitvise 支持所有主要的 SSH 协议，包括支持端口转发、动态隧道、远程等高级特性桌面。Bitvise 还包括内置的 SFTP 客户端和易于操作的界面。</p><p><strong>优点</strong></p><ul><li>易于操作的用户友好界面。</li><li>安全，支持所有主要的 SSH 协议。</li><li>包括端口转发、远程桌面等高级特性。</li><li>包括一个内置的 SFTP 客户端。</li></ul><p><strong>缺点</strong></p><ul><li>费版本在特性和功能方面是有限的。</li><li>界面可能不像其他 SSH 客户端那样可定制。</li></ul><h3>3. Terminus</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442678" alt="Terminus SSH Client" title="Terminus SSH Client" loading="lazy"/></p><p>Terminus 是一个用户友好的 SSH 客户端，旨在方便使用和安全。终端包括许多高级功能，如选项卡<br/>会话，支持多种协议，以及强大的脚本语言。它还包括一个文件传输客户端和远程桌面。Terminus 也是可定制的，可以选择更改字体、配色方案和其他设置。</p><p><strong>优点</strong></p><ul><li>免费和开源。</li><li>用户友好的界面与选项卡界面，方便管理多个会话。</li><li>包括高级功能，如选项卡会话和远程命令执行。</li><li>包括一个内置的文件传输客户端。</li></ul><p><strong>缺点</strong></p><ul><li>缺乏其他 SSH 客户端的一些高级特性。</li><li>界面可能不像其他 SSH 客户端那样可定制。</li></ul><h3>4. Xshell</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442679" alt="Xshell SSH Client" title="Xshell SSH Client" loading="lazy"/></p><p>Xshell 是一个用户友好的 SSH 客户端，为高级用户和系统管理员量身定制。Xshell 包含许多高级特性，例如<br/>选项卡会话，支持多种协议，脚本语言。它还包括一个文件传输客户端和远程桌面。Xshell 也是可定制的，有选项可以更改字体、配色方案和其他设置。</p><p><strong>优点</strong></p><ul><li>用户友好的界面，易于操作。</li><li>包括高级功能，如选项卡会话和强大的脚本语言。</li><li>包括一个内置的文件传输客户端。</li><li>支持多种协议。</li></ul><p><strong>缺点</strong></p><ul><li>商业软件，不是免费的。</li><li>界面可能不像其他 SSH 客户端那样可定制。</li></ul><h3>5. KiTTY</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442680" alt="KiTTY SSH Client" title="KiTTY SSH Client" loading="lazy"/></p><p>KiTTY 是一个用户友好的 SSH 客户端，旨在方便使用和定制。KiTTY 包括一个选项卡界面，支持多个<br/>会话，以及许多其他功能。具有更改字体，配色方案和其他设置的选项。</p><p><strong>优点</strong></p><ul><li>用户友好的界面与选项卡界面，方便管理多个会话。</li><li>包括许多自定义选项。</li><li>支持端口转发、X11 转发等高级特性。</li></ul><p><strong>缺点</strong></p><ul><li>缺乏其他 SSH 客户端的一些高级特性。</li><li>界面可能不像其他 SSH 客户端那样可定制。</li></ul><h3>6. SuperPuTTY</h3><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442681" alt="SuperPuTTY SSH Client" title="SuperPuTTY SSH Client" loading="lazy"/></p><p>SuperPuTTY 是一个用户友好的 SSH 客户端，易于使用和定制。SuperPuTTY 包括一个选项卡界面，支持<br/>多个会话，以及许多其他功能。具有更改字体，配色方案和其他设置的选项。</p><p><strong>优点</strong></p><ul><li>用户友好的界面与选项卡界面，方便管理多个会话。</li><li>包括许多自定义选项。</li><li>支持端口转发、X11 转发等高级特性。</li></ul><p><strong>缺点</strong></p><ul><li>缺乏其他 SSH 客户端的一些高级特性。</li><li>界面可能不像其他 SSH 客户端那样可定制。</li></ul><h3>我的开源项目</h3><p><a href="https://link.segmentfault.com/?enc=PQ06u0Q4Ru8E3f5wcYQ%2FZw%3D%3D.ZhsHh68feZXH4rzId7%2BroZSD5UPbOhYXxlBk%2F5gVnv8%3D" rel="nofollow" target="_blank"><img referrerpolicy="no-referrer" src="/img/remote/1460000043302459" alt="酷瓜云课堂-在线教育解决方案" title="酷瓜云课堂-在线教育解决方案" loading="lazy"/></a></p><ul><li><a href="https://link.segmentfault.com/?enc=z8T6YXWpw4osPlRy4U41gg%3D%3D.XYv1O3wPyOD6havV5kSYe0UxCiIerEtBwtXbPuvTO1E2JPNFEWyRi8hTKxbxmBeo" rel="nofollow" target="_blank">course-tencent-cloud（酷瓜云课堂 - gitee仓库）</a></li><li><a href="https://link.segmentfault.com/?enc=QiInPRQpz3P2e%2FzsH0A8PQ%3D%3D.1a8hJ2GA3ErdVADo9SjTKZAL4pKMcSA3C0kV0SvCEj7f3GQKLuh%2BMl%2Bid7vC13Gtjg4MnScMTppRdZVSy5%2Fg6A%3D%3D" rel="nofollow" target="_blank">course-tencent-cloud（酷瓜云课堂 - github仓库）</a></li></ul>]]></description></item><item>    <title><![CDATA[ITSS标准在传统企业IT运维转型中的应]]></title>    <link>https://segmentfault.com/a/1190000047442687</link>    <guid>https://segmentfault.com/a/1190000047442687</guid>    <pubDate>2025-12-02 09:03:00</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>“我们IT部门就像地下室里的电工，灯不亮了才想起我们。”<br/> 那是我第一次走进那家制造企业信息部会议室时，部门经理说的第一句话。<br/> 这句话让我很受震动。十多年前，IT部门是企业的骄傲；而在如今的数字化浪潮中，他们反而成了被忽略的一群人。<br/>这家企业是一家年产值过百亿的老牌制造企业，生产线庞大、设备复杂、系统陈旧。<br/> 他们的问题并不在技术落后，而在运维管理的无序：</p><ul><li>设备多、系统杂、职责散；</li><li>工单靠Excel、监控靠人工；</li><li>一旦出故障，全厂停摆，但没人能准确说出“问题在哪儿”。<br/>那天我站在生产车间，看着一条被迫停机的流水线，心里只有一个念头——<br/>这不是缺系统，而是缺体系。</li></ul><p><img width="723" height="457" referrerpolicy="no-referrer" src="/img/bVdneaM" alt="" title=""/></p><hr/><p><strong>一、痛点：传统企业的IT部门为何被边缘化</strong><br/>在过去的几年里，我接触了上百家传统企业，几乎都存在同样的症状：<br/> IT部门被视为“成本中心”，不是创造价值的部门，而是“出问题时要背锅的部门”。<br/> 问题出在三方面：</p><ol><li>缺乏标准：系统建设靠经验，人走体系散。</li><li>缺乏流程：问题解决全凭“老张有空没”。</li><li>缺乏度量：没有数据支撑，管理者无法展示IT的价值。<br/>这让IT部门在企业战略中越来越边缘化。<br/> 而正是这种低成熟度管理，成为他们数字化转型路上的最大阻力。</li></ol><hr/><p><strong>二、介入：ITSS标准让混乱有了参照系</strong><br/>当我作为外部顾问介入时，我们首先引入了ITSS标准体系框架。<br/> ITSS（信息技术服务标准）不是一套软件工具，而是一种管理方法论，它回答了三个根本问题：</p><ul><li>企业到底有哪些IT服务？</li><li>每项服务是谁负责、如何衡量？</li><li>这些服务如何支撑业务目标？<br/>我们从“服务目录”开始做起——梳理企业所有IT活动，从系统运维、网络管理到应用支持，统一归入可度量的服务项。<br/> 接着，基于ITSS标准，我们设计了事件管理、变更管理、配置管理三大核心流程。<br/> 每一个工单、每一次故障、每一项改动，都被纳入流程化闭环。<br/>随后，我们帮助企业建立了SLA服务级别协议和KPI绩效指标，让“IT响应速度”“系统可用性”“客户满意度”成为可量化的数字，而不再是模糊印象。<br/>那一刻，他们第一次能在月度报告中展示IT价值曲线。<br/>艾拓先锋的ITSS运维体系建设实训课里，我们也用这个案例当作范例，让学员现场演练如何从服务目录到KPI体系逐步落地标准。通过模拟制造业场景，帮助他们理解ITSS标准不是束缚，而是让IT重新被看见的语言。</li></ul><hr/><p><strong>三、重构：从“设备导向”到“服务导向”的体系蜕变</strong><br/>改革最难的部分不是制度设计，而是思维转变。<br/> 过去，企业IT部门只关注设备运行是否正常；现在，他们必须关心“服务体验是否达标”。<br/>我们将原本的“信息中心”改名为“IT服务中心”，成立了事件管理组、服务台、配置管理组和监控团队。<br/> 每个岗位的职责、接口、目标都被重新定义。<br/> 系统方面，我们构建了CMDB配置库，统一管理服务器、应用和网络资产关系；<br/> 通过集成监控平台和工单系统，实现从告警到工单的自动流转。<br/>更关键的是，我们建立了一个“运维改进委员会”，每月基于ITSS标准指标复盘数据，讨论问题闭环与优化建议。<br/> 这让IT管理不再是幕后操作，而成为企业运营会议的重要议题。<br/>半年后，IT部门的角色发生了质变：<br/> 他们不再是“被动响应”，而是“主动守护”；<br/> 不再是“救火队”，而是“体系化的服务提供商”。</p><hr/><p><strong>四、成效：让传统企业的IT重新被看见</strong><br/>项目上线一年后，这家制造企业的平均故障响应时间从8小时降到1小时内，<br/> 关键系统可用性达到99.98%，<br/> 业务部门满意度从63%提升到92%。<br/> 更重要的是，IT部门重新获得了战略地位。<br/>他们开始参与生产自动化、能源管理、供应链优化等业务项目；<br/> IT总监第一次被邀请参加年度经营战略会。<br/> 过去“地下室里的电工”，如今成了“企业数字化的指挥官”。<br/>我记得那位经理后来跟我说：“以前大家说我们花钱；现在他们知道，我们帮公司省了更多的钱。”<br/>我笑着回答：“这就是ITSS的真正意义——让IT服务变成企业的生产力。”<br/>是的，让传统企业的IT重新被看见。</p>]]></description></item><item>    <title><![CDATA[国密SSL证书里面包含哪些内容?如何选择]]></title>    <link>https://segmentfault.com/a/1190000047442695</link>    <guid>https://segmentfault.com/a/1190000047442695</guid>    <pubDate>2025-12-02 09:02:01</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>国密SSL证书里面包含哪些内容?如何选择国密SSL证书？</h2><p>国密 SSL 证书包含证书使用者信息、证书颁发者信息、证书有效期等内容，选择时需考虑算法合规性、证书类型、颁发机构等因素。具体如下：</p><h4>国密 SSL 证书包含的内容</h4><ol><li><strong>证书使用者信息</strong>：记录域名、组织名称、所在地等，是验证证书合法性的重要依据。</li><li><strong>证书颁发者信息</strong>：记录证书颁发机构 CA 的名称，可据此判断证书的权威性和可信度。</li><li><strong>证书有效期</strong>：包含颁发日期和截止日期，用于查看证书有效性，提醒及时续费。</li><li><strong>证书类型</strong>：包括证书版本、序列号、证书类型等，证书类型可以是单域名、通配符、DV、OV 或 EV。</li><li><strong>证书使用算法</strong>：记录公钥算法（如椭圆曲线公钥算法）和签名算法（如 SM3、SM2 等）。</li><li><strong>扩展信息</strong>：包括证书策略、证书密钥用法、授权信息访问、CRL 分发点、证书基本约束、扩展密钥用法等。</li></ol><p><strong><a href="https://link.segmentfault.com/?enc=bndBuYgObMOvTuebbcoyww%3D%3D.mdaCYhV19SHZ%2BIOUxuSYawtCBBUezk%2Ff8dZpFFE6CdoMeKN7CGd%2FjakzkJa4GAHg%2FcKfFoJZKZz5IlFVLyMfT8AfX77mEAjkB3aLLg9Jhgc%3D" rel="nofollow" target="_blank">https://www.joyssl.com/certificate/select/national_secret_alg...</a></strong><br/><img width="723" height="435" referrerpolicy="no-referrer" src="/img/bVdneaU" alt="" title=""/></p><h4>选择国密 SSL 证书的方法</h4><ol><li><strong>确保算法合规</strong>：根据《商用密码应用安全性评估管理办法》及 GB/T 39786-2021 标准，等保测评要求网络通信必须采用国产密码算法，如 SM2、SM3、SM4 等，所以要选择支持这些算法的证书。</li><li><strong>选择合适的证书类型</strong>：等保二级及以上系统必须使用 OV 或 EV 证书，金融、政务等高风险场景推荐 EV 证书。DV 证书仅验证域名所有权，无法满足等保要求。</li><li><strong>关注证书颁发机构</strong>：优先选择国内可信的 CA 机构，如 JoySSL、CFCA 等，这些机构通过了国家密码管理局认证，验签服务器部署在国内，符合等保数据不出境要求。</li><li><strong>考虑兼容性</strong>：若使用纯国密证书，需确保用户终端安装国密浏览器，如 360 安全浏览器、红莲花浏览器等。也可选择支持双算法的证书，如 KeepTrust SM2 国密算法 SSL 证书，可实现国密 SM2 和国际 RSA 算法双支持，解决过渡期的兼容性问题。</li><li><strong>确保证书链完整性</strong>：要确保证书文件包含服务器证书、中间证书和根证书，避免浏览器显示 “证书链不完整” 警告。</li><li><strong>注意密钥长度和加密协议</strong>：SM2 算法固定 256 位密钥长度，符合国密标准。加密协议需强制启用 TLS 1.2 及以上版本，禁用 SSLv2/SSLv3/TLS 1.0/TLS 1.1 等存在漏洞的版本。</li><li><strong>关注证书的有效期和续期</strong>：国密证书有效期通常为 1 年，需提前 30 天申请续期，可选择 JoySSL API 接口等自动化续期工具，避免证书过期导致服务中断。</li></ol>]]></description></item><item>    <title><![CDATA[剑指offer-44、翻转单词序列 程序]]></title>    <link>https://segmentfault.com/a/1190000047437788</link>    <guid>https://segmentfault.com/a/1190000047437788</guid>    <pubDate>2025-12-02 09:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>题⽬描述</h2><p>给定⼀个句⼦，将句⼦中的单词进⾏翻转，注意，单词内部的字符顺序不改变，改变的是单词与单词之间的顺序，⽐如“ I am a coder. ”,翻转之后变成“ coder. a am I ”。</p><p>示例<br/>注意：引号内部才是输⼊的内容<br/>输⼊："You are a cool boy."<br/>输出："boy. cool a are You"</p><h2>思路及解答</h2><h3>Java内置函数分割反转</h3><p>Java ⾥⾯有切割字符串的⽅法，直接⽤空格进⾏分隔，分隔成为多个单词，然后从字符串数组的后⾯开始，每⼀个字符拼接上⼀个空格，但是，值得注意的⼀点是，当只剩下⼀个字符串的时候，也就是索引为 0 的时候，不需要再拼接空格。代码实现如下：</p><pre><code class="java">public class Solution {
    public String ReverseSentence(String str) {
        if (str == null || str.length() == 0 || str.equals(" ")) {
            return "";
        }
        
        //去除首尾空格后，按照空格分隔
        String[] strs = str.trim().split(" ");
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = strs.length - 1; i &gt;= 0; i--) {
            stringBuilder.append(strs[i]);
            stringBuilder.append(i == 0 ? "" : " ");
        }
        return stringBuilder.toString();
    }
}</code></pre><ul><li><strong>时间复杂度</strong>：O(n)，分割和拼接各需线性时间</li><li><strong>空间复杂度</strong>：O(n)，存储单词数组和结果字符串</li></ul><h3>借助栈</h3><p>借助栈，栈是先进后出，也就是我们切割完字符串之后，全部放到栈中，再全部取出来拼接，就可以完成逆序的操作。有⼀个值得注意的点，就是空格的问题，我们压栈的时候，跟随着拼接上空格即可，最后⼀个字符不压⼊空格。</p><pre><code class="java">public String ReverseSentence(String str) {
    if (str == null || str.length() == 0)
        return str;
    StringBuilder stringBuilder = new StringBuilder();
    String[] strs = str.split(" ");
    if (strs.length == 0)
        return str;
    Stack &lt; String &gt; stack = new Stack &lt; &gt; ();
    for (int i = 0; i &lt; strs.length - 1; i++) {
        stack.push(strs[i]);
        stack.push(" ");
    }
    stack.push(strs[strs.length - 1]);
    while (!stack.isEmpty()) {
        stringBuilder.append(stack.pop());
    }
    return stringBuilder.toString();
}</code></pre><h3>双指针法(推荐)</h3><p>⾸先判断字符串 str 是否为空或者为空字符，如果 str 不为空，则初始化 start ，和 end 指针指向字符串的尾部， start 从尾部向头部遍历</p><p>针对每⼀个字符，如果字符为空字符：</p><ul><li>如果 start 和 end 不是出于同⼀个位置，说明已经遍历完⼀个单词，那么将 start+1 ~ end 之间的字符，拼接到结果后，并且添加上⼀个空格。将 start-1 ，并且 end 指向 start 的位置</li><li>否则，说明是多余的空格，直接跳过， start-1 ， end=start</li></ul><p>如果字符不是空字符：可以把 start 索引前移，也就是 start--</p><p>最后，剩下最后⼀个单词的时候，需要特殊处理最后⼀个单词，拼接到字符串后⾯就可以了。</p><pre><code class="java">public class Solution {
    public static void main(String[] args) {
        Solution solution = new Solution();
        System.out.println(solution.ReverseSentence("nowcoder. a am I"));
    }
    public String ReverseSentence(String str) {
        if (str != null &amp;&amp; str.length() != 0 &amp;&amp; !str.equals(" ")) {
            int start = str.length() - 1, end = start;
            StringBuffer stringBuffer = new StringBuffer();
            for (; start &gt; 0;) {
                // 如果为空格
                if (str.charAt(start) == ' ') {
                    // 且开始索引和结束索引不⼀致的情况
                    if (start != end) {
                        // 遍历start+1~end的字符，加到
                        for (int i = start + 1; i &lt;= end; i++) {
                            stringBuffer.append(str.charAt(i));
                        }
                        // 每⼀个单词的后⾯加上⼀个空格
                        stringBuffer.append(" ");
                    }
                    start--;
                    end = start;
                } else {
                    start--;
                }
            }
            // 处理最后⼀个单词
            for (int i = 0; i &lt;= end; i++) {
                stringBuffer.append(str.charAt(i));
            }
            return stringBuffer.toString();
        }
        return str;
    }
}</code></pre><ul><li><strong>时间复杂度</strong>：O(n)，每个字符被访问常数次</li><li><strong>空间复杂度</strong>：O(n)，StringBuilder存储结果</li></ul><h3>三次反转法（空间最优）</h3><p>通过字符级操作实现O(1)空间复杂度（假设字符数组可修改）。</p><p>先反转整个字符串，再逐个反转每个单词</p><p><strong>三次反转的数学原理：</strong></p><p>对于句子 "A B C"（A、B、C为单词）：</p><ol><li><strong>整体反转</strong>： "C' B' A'"</li><li><strong>单词反转</strong>： "C'"反转→ "C", "B'"反转→ "B", "A'"反转→ "A"</li><li>结果： "C B A" → 正是期望的顺序</li></ol><pre><code class="java">public class Solution {

    public String reverseWords(String s) {
        if (s == null || s.length() == 0) return "";
        
        char[] chars = s.toCharArray();
        int n = chars.length;
        
        // 步骤1：反转整个字符串
        reverse(chars, 0, n - 1);
        
        // 步骤2：反转每个单词
        reverseWords(chars, n);
        
        // 步骤3：清理多余空格
        return cleanSpaces(chars, n);
    }
    
    /**
     * 反转字符数组的指定区间
     */
    private void reverse(char[] chars, int left, int right) {
        while (left &lt; right) {
            char temp = chars[left];
            chars[left++] = chars[right];
            chars[right--] = temp;
        }
    }
    
    /**
     * 反转每个单词
     */
    private void reverseWords(char[] chars, int n) {
        int i = 0, j = 0;
        
        while (i &lt; n) {
            // 跳过前导空格
            while (i &lt; j || (i &lt; n &amp;&amp; chars[i] == ' ')) i++;
            // 找到单词结尾
            while (j &lt; i || (j &lt; n &amp;&amp; chars[j] != ' ')) j++;
            // 反转单词
            reverse(chars, i, j - 1);
        }
    }
    
    /**
     * 清理多余空格，返回最终字符串
     */
    private String cleanSpaces(char[] chars, int n) {
        int i = 0, j = 0;
        
        while (j &lt; n) {
            // 跳过前导空格
            while (j &lt; n &amp;&amp; chars[j] == ' ') j++;
            // 保留单词间的一个空格
            while (j &lt; n &amp;&amp; chars[j] != ' ') {
                chars[i++] = chars[j++];
            }
            // 添加单词间空格
            while (j &lt; n &amp;&amp; chars[j] == ' ') j++;
            if (j &lt; n) {
                chars[i++] = ' ';
            }
        }
        
        return new String(chars, 0, i);
    }
}</code></pre><ul><li><strong>时间复杂度</strong>：O(n)，三次线性遍历</li><li><strong>空间复杂度</strong>：O(1)（如可修改原数组）或 O(n)（需创建新数组）</li></ul>]]></description></item><item>    <title><![CDATA[Nano Banana Pro 很强，但]]></title>    <link>https://segmentfault.com/a/1190000047442345</link>    <guid>https://segmentfault.com/a/1190000047442345</guid>    <pubDate>2025-12-02 08:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>1. 前言</h2><p>如果你已经学会：</p><ol><li>免费使用 Nano Banana Pro： <a href="https://link.segmentfault.com/?enc=hI2C%2BAncUIAc9ZI3%2FtY7bA%3D%3D.FBjJ44soA3qAKPszfTC9l1%2Fz9%2BBEi0NfGRuOr1sgHLv0ry2Ysx6wfddXPqSO4CjNTZJI%2Bx6BrOK8klyvKThgeQ%3D%3D" rel="nofollow" target="_blank">6 个白嫖 Nano Banana Pro 的网站</a></li><li>使用提示词库复刻惊艳图片：<a href="https://link.segmentfault.com/?enc=eLI1xXFpvi1MHw%2F8sAOtAw%3D%3D.PoW42vOLP9BvNlp%2BLnYcNXWeuNJPI8Lv14ccNRRrMdt5I7DGuK9wgwenUW0%2F49RSIger85u%2FEMQ5oXxJGOA5eA%3D%3D" rel="nofollow" target="_blank">一次找齐！1000 个 Nano Banana Pro 提示词</a></li></ol><p>那本篇我们来点干货 —— 如何写出好的提示词。</p><p>之所以要学习如何写提示词，是因为绝大部分人在写提示词时，都是一种 <strong>“随缘”</strong> 的状态——有的地方写得详细，有的地方却被遗漏了，这就带来了 <strong>很大的不确定性</strong> 。</p><p>所以本篇我们就来聊聊如何通过结构化的提示词，提升图片生成的质量，<strong>让 Nano Bnana 生成的每一张图都是高水准的图片。</strong></p><p>10 年技术博主，最新资讯、前端知识、AI 干货，欢迎关注公众号：“冴羽” 或者搜索“yayujs”</p><h2>2. 生成图片</h2><h3>2.1. 逼真场景</h3><p>如果要生成逼真的图片，最好使用摄影术语，设定拍摄角度、镜头类型、光线和细节，引导模型生成逼真的效果。</p><p>英文模板为：</p><pre><code class="plain">A photorealistic [shot type] of [subject], [action or expression], set in
[environment]. The scene is illuminated by [lighting description], creating
a [mood] atmosphere. Captured with a [camera/lens details], emphasizing
[key textures and details]. The image should be in a [aspect ratio] format.</code></pre><p>中文模板为：</p><blockquote>一张高度写实的 <strong>[镜头类型]</strong> ，主体为 <strong>[拍摄对象]</strong> ， <strong>[动作或表情]</strong> ，场景设定在 <strong>[环境]</strong> 中。场景由 <strong>[光线描述]</strong> 照明，营造出 <strong>[氛围]</strong> 的氛围。使用 <strong>[相机/镜头细节]</strong> 拍摄，突出 <strong>[关键纹理和细节]</strong> 。图像应采用 <strong>[纵横比]</strong> 格式。</blockquote><p>让我们举个例子：</p><blockquote>一幅高度写实的特写肖像，描绘了一位年长的中国陶艺家。他脸上有着深深的、被阳光刻下的皱纹，带着温暖而洞悉一切的微笑。他正仔细检查一个刚上釉的茶碗。场景设定在他那质朴且阳光充足的工作室里。柔和的黄金时刻光线透过窗户洒入，照亮了黏土细腻的纹理。这幅肖像使用 85 毫米人像镜头拍摄，背景呈现出柔和模糊的效果（焦外成像）。整体氛围宁静而娴熟。肖像采用垂直构图。</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442347" alt="" title=""/></p><h3>2.2. 风格插画或贴纸</h3><p>如果要创建插画、贴纸、图标等资源，要明确说明样式并要求使用透明的背景。</p><p>英文模板为：</p><pre><code class="plain">A [style] sticker of a [subject], featuring [key characteristics] and a
[color palette]. The design should have [line style] and [shading style].
The background must be transparent.</code></pre><p>中文模板为：</p><blockquote>一张 <strong>[风格]</strong> 的 <strong>[主体]</strong> 贴纸，具有 <strong>[关键特征]</strong> 和 <strong>[色彩搭配]</strong> 。设计应采用 <strong>[线条风格]</strong> 和 <strong>[阴影风格]</strong> 。背景必须是透明的。</blockquote><p>举个例子：</p><blockquote>一张可爱风格的贴纸，上面是一只开心的小熊猫，戴着一顶小小的竹帽，正在啃着一片绿色的竹叶。设计采用了醒目清晰的轮廓、简单的卡通渲染，以及鲜艳的色彩搭配。背景必须是透明的。</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442348" alt="" title="" loading="lazy"/></p><h3>2.3. 精准的带文字渲染</h3><p>Nano Banana Pro 强化了文本渲染方面的表现，以前生成汉字的时候还有不少乱码，到 Pro 已经明显改善了很多。但在写提示词时，还是要清晰地说明文字内容、字体样式和整体设计。</p><p>英文模板为：</p><pre><code class="plain">Create a [image type] for [brand/concept] with the text "[text to render]"
in a [font style]. The design should be [style description], with a
[color scheme].</code></pre><p>中文模板为：</p><blockquote>为 <strong>[品牌/概念]</strong> 创建一个 <strong>[图像类型]</strong> ， <strong>[要渲染的文字]</strong> 采用 <strong>[文字风格]</strong> 。设计应具有 <strong>[风格描述]</strong> ，并采用 <strong>[配色方案]</strong> 。</blockquote><p>举个例子：</p><blockquote>为一家名为 “The Daily Grind” 的咖啡店设计一个现代简约风格的标志。文字部分采用简洁、粗体的无衬线字体。配色方案为黑白两色。将标志置于圆形之中。巧妙地融入一颗咖啡豆元素。</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442349" alt="" title="" loading="lazy"/></p><h3>2.4. 产品摄影</h3><p>为电商、广告或品牌制作专业的商品图片。</p><p>英文模板为：</p><pre><code class="plain">A high-resolution, studio-lit product photograph of a [product description]
on a [background surface/description]. The lighting is a [lighting setup,
e.g., three-point softbox setup] to [lighting purpose]. The camera angle is
a [angle type] to showcase [specific feature]. Ultra-realistic, with sharp
focus on [key detail]. [Aspect ratio].</code></pre><p>中文模板为：</p><blockquote>一张高分辨率、工作室灯光照明的 <strong>[产品描述]</strong> 产品照片，背景是 <strong>[背景]</strong> 。灯光采用 <strong>[照明设置]</strong> ，目的是 <strong>[照明用途]</strong> 。相机角度为 <strong>[角度类型]</strong> ，以展示 <strong>[特定特征]</strong> 。超写实风格，对 <strong>[关键细节]</strong> 聚焦清晰。 <strong>[纵横比]</strong> 。</blockquote><p>举个例子：</p><blockquote>一张高分辨率、工作室灯光照明的极简主义哑光黑色陶瓷咖啡杯产品照片，放置在抛光的混凝土表面上。灯光采用三点柔光箱设置，旨在营造柔和、漫射的高光并消除刺眼的阴影。相机角度为略微升高的 45 度角，以展示其简洁的线条。超写实风格，清晰聚焦于从咖啡中升起的蒸汽。正方形图像。</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442350" alt="" title="" loading="lazy"/></p><h3>2.5. 极简主义与留白设计</h3><p>英文模板为：</p><pre><code class="plain">A minimalist composition featuring a single [subject] positioned in the
[bottom-right/top-left/etc.] of the frame. The background is a vast, empty
[color] canvas, creating significant negative space. Soft, subtle lighting.
[Aspect ratio].</code></pre><p>中文模板为：</p><blockquote>一幅极简主义构图，画面中单一的 <strong>[主体]</strong> 位于画框的 <strong>[位置]</strong> 。背景是一片广阔、空旷的 <strong>[颜色]</strong> 画布，营造出大量的留白。光线柔和、微妙。 <strong>[宽高比]</strong> 。</blockquote><p>举个例子：</p><blockquote>一幅极简风格的构图，画面右下角放置着一片精致的红色枫叶。背景是一片广阔、空旷的米白色画布，为文字留出了大量的留白空间。左上角有柔和、漫射的光线。方形图像。</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442351" alt="" title="" loading="lazy"/></p><h3>2.6. 连环画与分镜</h3><p>利用模型对角色一致性和场景描述的理解，制作多格漫画或故事板。</p><p>英文模板为：</p><pre><code class="plain">Make a 3 panel comic in a [style]. Put the character in a [type of scene].</code></pre><p>中文模板为：</p><blockquote>制作一个 3 格漫画，风格为 <strong>[风格]</strong> 。让角色处于 <strong>[场景类型]</strong> 中。</blockquote><p>举个例子：</p><blockquote>创作一个三格漫画，采用粗犷的黑色电影艺术风格，运用高对比度的黑白墨水绘制。让角色处于一个幽默的场景中。</blockquote><p>用了一张马斯克的图片：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442352" alt="" title="" loading="lazy"/></p><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442353" alt="" title="" loading="lazy"/></p><h2>3. 修改图片</h2><h3>3.1. 添加或删除元素</h3><p>提供图片并描述修改内容。模型将与原始图片的风格、灯光和透视效果保持一致。</p><p>英文模板为：</p><pre><code class="plain">Using the provided image of [subject], please [add/remove/modify] [element] to/from the scene. Ensure the change is [description of how the change should integrate].</code></pre><p>中文模板为：</p><blockquote>请使用提供的 <strong>[主体]</strong> 图片，在场景中 <strong>[添加/移除/修改] [元素]</strong> 。确保这一更改能 <strong>[按描述的方式融入场景]</strong> 。</blockquote><p>举个例子：</p><blockquote>请使用我提供的那张我的猫咪的照片，在它的头上加一顶小小的针织巫师帽。让它看起来坐得很舒服，并且与照片柔和的光线相匹配</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442354" alt="" title="" loading="lazy"/></p><h3>3.2. 局部重绘</h3><p>英文模板为：</p><pre><code class="plain">Using the provided image, change only the [specific element] to [new
element/description]. Keep everything else in the image exactly the same,
preserving the original style, lighting, and composition.</code></pre><p>中文模板为：</p><blockquote>使用提供的图片，仅将 <strong>[特定元素]</strong> 更改为 <strong>[新元素/描述]</strong> 。保持图片中的其他所有内容完全不变，保留原有的风格、光线和构图。</blockquote><p>举个例子：</p><blockquote>“使用提供的客厅图片，只将蓝色沙发换成复古的棕色皮质切斯特菲尔德沙发。房间的其余部分，包括沙发上的抱枕和照明，保持不变。”</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442355" alt="" title="" loading="lazy"/></p><h3>3.3. 风格迁移</h3><p>英文模板为：</p><pre><code class="plain">Transform the provided photograph of [subject] into the artistic style of [artist/art style]. Preserve the original composition but render it with [description of stylistic elements].</code></pre><p>中文模板为：</p><blockquote>将提供的 <strong>[主体]</strong> 照片转换为 <strong>[艺术家/艺术风格]</strong> 的艺术风格。保留原始构图，但用 <strong>[风格元素描述]</strong> 进行渲染。</blockquote><p>举个例子：</p><blockquote>将所提供的现代城市街道夜景照片转换为文森特·梵高《星月夜》的艺术风格。保留建筑物和汽车的原始构图，但用旋转的厚涂笔触以及深邃的蓝色和明亮的黄色构成的富有戏剧性的色彩来呈现所有元素。</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442356" alt="" title="" loading="lazy"/></p><h3>3.4. 高级合成</h3><p>英文模板为：</p><pre><code class="plain">Create a new image by combining the elements from the provided images. Take
the [element from image 1] and place it with/on the [element from image 2].
The final image should be a [description of the final scene].</code></pre><p>中文模板为：</p><blockquote>通过组合所提供图像中的元素来创建一幅新图像。提取 <strong>[图像 1 中的元素]</strong> ，并将其与 <strong>[图像 2 中的元素]</strong> 放在一起/置于 <strong>[图像 2 中的元素]</strong> 之上。最终图像应该是 <strong>[对最终场景的描述]</strong> 。</blockquote><p>举个例子：</p><blockquote>创作一张专业的电商时尚照片。将第一张图片中的蓝色碎花连衣裙取出，让第二张图片中的女士穿上它。生成一张该女士穿着这条连衣裙的逼真全身照，并调整光影以匹配户外环境。</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442357" alt="" title="" loading="lazy"/></p><h3>3.5. 高保真细节保留</h3><p>英文模板为：</p><pre><code class="plain">Using the provided images, place [element from image 2] onto [element from
image 1]. Ensure that the features of [element from image 1] remain
completely unchanged. The added element should [description of how the
element should integrate].</code></pre><p>中文模板为：</p><blockquote>使用提供的图像，将 <strong>[图像 2 中的元素]</strong> 放置到 <strong>[图像 1 中的元素]</strong> 上。确保 <strong>[图像 1 中的元素]</strong> 的特征完全不变。添加的元素应 <strong>[描述该元素应如何整合]</strong> 。</blockquote><p>举个例子：</p><blockquote>选取第一张图片中那位有着棕色头发、蓝色眼睛且表情平和的女性。将第二张图片中的标志添加到她的黑色 T 恤上。确保这位女性的脸部及五官完全保持不变。该标志应看起来像是自然印在面料上的，要顺着衬衫的褶皱呈现。</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442358" alt="" title="" loading="lazy"/></p><h3>3.6. 草图变成品</h3><p>英文模板为：</p><pre><code class="plain">Turn this rough [medium] sketch of a [subject] into a [style description]
photo. Keep the [specific features] from the sketch but add [new details/materials].</code></pre><p>中文模板为：</p><blockquote>将这幅关于 <strong>[主题]</strong> 的粗略 <strong>[媒介]</strong> 草图转化为一张符合 <strong>[风格描述]</strong> 的照片。保留草图中的 <strong>[具体特征]</strong> ，但添加 <strong>[新细节/材料]</strong> 。</blockquote><p>举个例子：</p><blockquote>把这幅未来汽车的铅笔草图变成展厅里成品概念车的精致照片。保留草图中的流畅线条和低矮轮廓，但要添加金属蓝色漆面和霓虹轮圈灯光。</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442359" alt="" title="" loading="lazy"/></p><h3>3.7. 360 度全景</h3><p>英文模板为：</p><pre><code class="plain">A studio portrait of [person] against [background], [looking forward/in profile looking right/etc.]</code></pre><p>中文模板为：</p><blockquote>一幅 <strong>[人物]</strong> 的工作室肖像照，背景为 <strong>[背景]</strong> ， <strong>[人物]</strong> 面向前方/侧头向右看等。</blockquote><p>举个例子：</p><blockquote>一张这位男士的工作室肖像照，背景为白色，他侧身向右看。</blockquote><p>效果如下：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442360" alt="" title="" loading="lazy"/></p><h2>4. 提示词最佳实践</h2><ul><li><p><strong>细节越多越好：</strong>提供的信息越多，对输出结果的操控程度就越详细</p><ul><li>❌ “奇幻的盔甲”</li><li>✅ “华丽的精灵板甲，刻着银叶图案，高领设计，带有猎鹰翅膀形状的肩甲”</li></ul></li><li><p><strong>提供上下文和意图说明：</strong>模型对上下文的理解会影响最终输出</p><ul><li>❌ “设计解决方案”</li><li>✅ “为极简护肤品牌设计解决方案”</li></ul></li><li><p><strong>不断迭代和优化</strong>：不要指望第一次尝试就能生成完美的图片，利用模型的对话特性进行小幅更改。</p><ul><li>✅ “这很棒，但你能让光线更亮一些吗？”</li><li>✅ “保持所有内容不变，但让角色的表情更简洁一些。”</li></ul></li><li><p><strong>使用分步指令</strong>：对于包含多个元素的复杂场景，可以将提示拆分为多个步骤</p><ul><li>✅ “首先，创造一个宁静、薄雾弥漫的黎明森林的背景。然后，在前景中添加一个长满苔藓的古老石祭坛。最后，将一把发光的剑祭坛放在顶部。”</li></ul></li><li><p><strong>语义化反向提示</strong>：</p><ul><li>不要说“没有汽车”</li><li>而是通过“一条空无一人、没有任何交通迹象的街道”来正面描述所需的场景</li></ul></li><li><strong>控制镜头语言</strong>：使用摄影和电影语言来控制构图。例如<strong>广角、微距、低机位</strong>等术语</li></ul>]]></description></item><item>    <title><![CDATA[AI底层通讯协议项目a2a c++ sd]]></title>    <link>https://segmentfault.com/a/1190000047442489</link>    <guid>https://segmentfault.com/a/1190000047442489</guid>    <pubDate>2025-12-01 23:02:03</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>前言</h2><p>加入星球的同学应该都知道，星球正在开发一个<strong>“AI智能体通讯”</strong>的项目</p><p>里面就涉及到了a2a协议，谷歌今年四月份发布的Agent通讯协议。</p><p>但是目前网上存在的都是python、java实现的sdk。</p><p>那如果我搞cpp，想做个底层的AI项目。或者我有实际需要需要端侧部署，需要cpp开发。</p><p>目前可以让你用cpp的A2A框架，几乎不存在，至少我没搜到。</p><p>基于这情况开发了一套cpp实现的a2a框架</p><h2>介绍</h2><p>因为搞星球嘛，副业。目的还是想赚些钱，因此很多资料、项目都是单纯只分享给星球同学的。</p><p>但是，作为一位程序员，还是要有些开源精神的，当然也可以理解成想引流。</p><p>目前把这个c++ a2a实现开源出来了，大家都可以去下载学习：<br/><a href="https://link.segmentfault.com/?enc=xfKF%2B3xE2yIEvI2P5CiuPQ%3D%3D.HZz312SmX8s4L2K5tO5S%2BSJmZkpZRgYL0vEmM2PEWBfSSbrBwQU6hmgjyVyEiU3f" rel="nofollow" target="_blank">https://github.com/agan-cpp/a2a-cpp-sdk</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442491" alt="" title=""/></p><p>并且也在基础之上，应用层做了很多优化工作：<br/>比如<br/>基于Redis的分布式TaskStore，独立进程部署，持久化存储 （用于上下文记忆）</p><p>注册中心开发，可以动态添加agent，来获取Agent Card</p><p>项目讲解视频：<br/><a href="https://www.bilibili.com/video/BV1iLS1BCEYW/?spm_id_from=333.1387.list.card_archive.click&amp;vd_source=b7f84f9122e6cf826e5c747e473cb4f7" target="_blank">https://www.bilibili.com/video/BV1iLS1BCEYW/?spm_id_from=333....</a></p><h2>星球介绍（公认的cpp / c++学习地）</h2><p>星球名字：奔跑中的cpp / c++</p><p>里面服务也不会变，四个坚守目前:</p><p>1.每天都会看大家打卡内容，给出合理性建议。</p><p>2.大家如果需要简历指导，心里迷茫需要疏导都可以进行预约周六一对一辅导。</p><p>3.每周五晚上九点答疑聊天不会变。</p><p>4.进去星球了，后续如果有什么其他活动，服务，不收费不收费(可以合理赚钱就收取下星球费用，但是不割韭菜，保持初心)</p><p>（还有经历时间考验的独家私密资料）</p><p>加入星球的同学都可以提问预约，一对一帮做简历，一对一  职业规划辅导    ，解惑。同时有高质量的项目以及学习资料</p><p>学cpp基础，可以把最近开发的这个编程练习平台利用起来<br/>cppagancoding.top</p><p>本文由<a href="https://link.segmentfault.com/?enc=Re7dWvDXG5Km49YK8CP8XA%3D%3D.ayrUSSIk1Ol2JAK2L%2BHhtlN0A16A9%2FugkD9hasP1KEw%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[ChatGPT 三周年：硅基黎明下的BU]]></title>    <link>https://segmentfault.com/a/1190000047442508</link>    <guid>https://segmentfault.com/a/1190000047442508</guid>    <pubDate>2025-12-01 23:01:24</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>碳基的余晖与硅基的黎明：ChatGPT 三周年，一个小虫子的自救指南</h2><h3>引言：余晖中的回望</h3><p>2022 年 11 月 30 日，旧金山的一家实验室释放了一个幽灵。</p><p>那时候，我们管它叫“聊天机器人”，带着一种审视新奇玩具的傲慢。谁也没想到，那一刻竟是碳基文明长久统治下的最后一次安稳日落。</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442510" alt="Gemini_Generated_Image_l3op4pl3op4pl3op" title="Gemini_Generated_Image_l3op4pl3op4pl3op"/></p><p>如果把时间快进到今天——2025 年的冬天，站在三周年的节点回望，你会发现这三年是被极其暴力的手段“折叠”过的。第一年是<strong>惊奇（Magic）</strong>，我惊叹于它能写诗、能通过图灵测试；第二年是<strong>恐慌（Panic）</strong>，我看着屏幕上自动生成的周报和代码，感到脊背发凉；到了第三年，也就是现在，情绪变成了<strong>习以为常（Utility）</strong>。</p><p>这种“习以为常”才是最可怕的。因为它意味着，AI 已经不再是一个需要被讨论的“现象”，而变成了像水和电一样的“环境”。它最初替代的是搜索引擎，后来我们才发现，它试图替代的是我们思考的代理权。</p><p>恰逢 ChatGPT 的三岁生日，周活用户突破 8 亿。作为一个既在云端高频使用它，又在本地 8 张 4090 上折腾各种开源模型的开发者，我想借此机会，聊聊这三年里，作为一名技术人最真实的体感。</p><p>特别是，我想重新定义一下我们的身份：<strong>在 AI 眼里，我们不仅是那只卑微的“虫子”（Insect），更是它永远无法修复的“Bug”。</strong></p><hr/><h3>第一章：硅基的重力</h3><p>在 2022 年，我们嘲笑 AI 画不出完美的手指，嘲笑它一本正经地胡说八道。那是碳基生命最后的优越感时刻。</p><p>三年后的今天，笑声消失了。</p><p>随着 GPT-5 及其后续迭代模型的发布，AI 早就跨越了“概率预测下一个字”的鹦鹉学舌阶段。现在的它，拥有了类似“系统 2”的慢思考能力。它能推理、能规划、能自我纠错，甚至在某些时刻展现出了令人不安的“直觉”。</p><p><strong>它不再是一个软件，它是新的重力。</strong></p><p>真正的转折点发生在一次深夜 Debug。当时我正对着 RuoYi 框架（Vue3 + SpringBoot3）的一堆“屎山”代码头晕目眩，逻辑乱得像天书，重构无从下手。抱着“死马当活马医”的心态，我直接把那段乱七八糟的错误信息扔给了 ChatGPT。</p><p>接下来发生的一幕，让我直接战术后仰：它不仅帮我重新梳理了业务逻辑，还贴心地将公共方法进行封装，最后写出了单元测试供我调试。</p><p>以前写代码，我是 <strong>Google + Stack Overflow + 复制粘贴</strong>；现在的我？直接问 AI，描述需求，生成代码，不满意就让它改。不管是 Cursor、Copilot，还是最近的新宠 Antigravity，它们已经成为了我们数字肢体的一部分。</p><p>深夜两点，屏幕的反光映在程序员疲惫的脸上，看着 AI 在 30 秒内写完自己以前需要写 3 天的代码。那一刻我意识到：<strong>在这场算力、耐力与知识广度的较量中，碳基生命全面落败。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442511" alt="Gemini_Generated_Image_r4wovar4wovar4wo" title="Gemini_Generated_Image_r4wovar4wovar4wo" loading="lazy"/></p><p>但更让我战栗的是一种<strong>“被审视感”</strong>。 看着屏幕上光标以远超人类思考速度的频率跳动，我感觉 AI 不仅是在修补代码里的 Bug，<strong>它仿佛也在审视屏幕前的我——这个疲惫、记忆力衰退、情绪化、还需要喝咖啡提神的碳基生物。</strong></p><p>在硅基的绝对理性视角下，代码里的空指针是 Bug，而屏幕前这个效率低下的程序员，或许是整个编程循环里最大的 <strong>Performance Issue（性能瓶颈）</strong>。 它不知疲倦，过目不忘，逻辑严密。承认这一点很痛苦：在追求“最优解”的道路上，作为一种算法，人类这种生物充满了冗余代码。</p><hr/><h3>第二章：虫子的生存哲学</h3><p>刘慈欣在《三体》中写过，三体人蔑称人类为“虫子”。但丁仪说：“虫子从未被真正战胜过。”</p><p>在筹备我的《好虫子周刊》时，我常想：<strong>在 AI 眼里，人类是不是充满了不可预测的 Bug？</strong></p><p><strong>在 AI（Silicon）的眼里，我们是什么？</strong></p><ul><li><strong>作为 Insect（昆虫）：</strong> 我们是提供 RLHF（人类反馈强化学习）养料的工蚁，每天点击“Regenerate”为它标注数据，是<strong>好虫子</strong>。</li><li><strong>作为 Bug（程序错误）：</strong> 我们充满偏见、情绪波动、非理性决策。对于追求全局最小值（Global Minimum）的神经网络来说，我们是脏数据，是逻辑溢出，是<strong>坏 Bug</strong>。</li></ul><p><strong>但为什么我们还没有被彻底淘汰？</strong> 因为硅基生命的本质是梯度下降，它们沿着数学的光滑曲面狂奔，极度高效，极度洁癖。<strong>而创新的本质，往往是对“最优解”的背叛。</strong>或许碳基生命的韧性，恰恰在于我们是<strong>“好 Bug”</strong>：</p><p><strong>首先是物理世界的“摩擦力”。</strong> AI 活在云端，它可以生成完美的架构图，但它无法解决 Docker 容器在本地环境莫名其妙的挂载失败，无法解决 CUDA 版本不兼容的报错，更无法去现场帮客户插上网线。英伟达的股价狂欢之外，是我们这些本地部署玩家在处理物理世界的“脏乱差”。但这种折腾本身，就是护城河。当我看着 容器中模型终于跑起来的那一刻，那种掌控感是云端 API 无法给予的。<strong>只要物理世界还存在摩擦，就需要我们这些“搬砖工”。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442512" alt="Gemini_Generated_Image_s8vnw1s8vnw1s8vn" title="Gemini_Generated_Image_s8vnw1s8vnw1s8vn" loading="lazy"/></p><p><strong>其次，我们是意义的赋予者。</strong> AI 生产内容，人类定义价值。没有人类的“体验”，AI 生成的代码跑得再快也只是电流的空转。正是我们这些充满情感波动、效率不稳定的“Bug”，构成了世界的独特性。</p><p>硅基生物没有童年，也没有死亡，所以它们不懂什么是“珍惜”。<strong>我们是这个宇宙操作系统里，唯一一段会因为看了一场日落而运行变慢的“代码”。</strong>这就是碳基最后的特权。在算法的暴政下，做一个不可预测的、混乱的、鲜活的人，就是最大的反抗。</p><hr/><h3>第三章：一个小虫子的自救指南</h3><p>既然我们接受了自己既是“卑微虫子”又是“混沌 Bug”的设定，那么如何在这个巨人的脚缝里活得精彩？以下是我给自己的三条生存法则：</p><h5>指南一：从“实现者”进化为“定义者”</h5><p>过去，我们比拼谁记得 API 多，这叫比拼谁更像机器。 在 2025 年，这种竞争毫无意义。未来的核心能力不再是“实现（How）”，而是“定义（What）”。 不要试图去和编译器比拼逻辑的严丝合缝，那是以己之短攻彼之长。<strong>你要做那个写下 <code>Try...Catch</code> 的人，</strong> 用 AI 编织知识网络，用私有数据喂养出一个懂你的“第二大脑”。你要做那个提出离谱需求、导致系统报错、从而发现新大陆的 Bug。</p><h5>指南二：拥抱 Agent，做系统的指挥官</h5><p>今年发布的 Operator 和 ChatGPT Agent，意味着重复性搬砖工作将彻底消失。 不要做那个只会 CRUD 的工具人，要做那个设计系统、解决“最后一公里”落地问题的工程师。如果你只是一段死板的代码，你会被 System.gc() 清理掉；<strong>如果你是一个灵活的 Bug，你就能卡在系统的关键节点，成为不可或缺的 Feature（特性）。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442513" alt="Gemini_Generated_Image_elw1tzelw1tzelw1" title="Gemini_Generated_Image_elw1tzelw1tzelw1" loading="lazy"/></p><h5>指南三：坚守“半人马”模式</h5><p>不要对抗，要骑在它背上。写代码遇到不会的，直接问 AI；报错看不懂，直接扔给 AI。 但请记住一个原则：<strong>Keep Human in the Loop（保持人类在环）。</strong> 这里的“Human”，指的就是我们这种不完美的判断力。AI 是放大器，它让强者更强。你可以交出执行权，但永远不要交出最终的审美判断——<strong>因为只有身为 Bug 的我们，才知道什么叫“不完美的艺术”。</strong></p><hr/><h3>结语：点亮那抹余晖</h3><p>回到头。ChatGPT 三岁了，它确实改变了一切。 三年前，我只会写业务代码。三年后，我会配环境、调显卡、洗数据、写 Prompt。</p><p>很多人问：程序员会失业吗？ 我觉得，那些试图把自己变成机器、写出无懈可击却毫无灵魂代码的人会失业。但那些懂得如何驾驭 AI、懂得在逻辑的缝隙中寻找价值、愿意去修那些该死的 CUDA 报错的工程师，只会越来越贵。</p><p>未来三年，无论还是 GPT-6 还是 DeepSeek-V4，我知道，只要我还愿意折腾，愿意去制造一点“意外”。 <strong>我就能在这个硅基的黎明中，留下一抹“碳基的余晖”。</strong></p><p>与其恐惧被修复，不如骄傲地做一只快乐的、折腾的、无法被算法预测的 <strong>“好 Bug”</strong>。 毕竟，在完美运行的死寂宇宙里，<strong>Bug 才是唯一的生命力。</strong></p><p><strong>与其恐惧硅基的黎明，不如点亮我们碳基的余晖。</strong></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442514" alt="Gemini_Generated_Image_bpt093bpt093bpt0" title="Gemini_Generated_Image_bpt093bpt093bpt0" loading="lazy"/></p><p>本文由<a href="https://link.segmentfault.com/?enc=NpGDgvmiSDZHOAW1PLKjRw%3D%3D.LZI4dFD%2BN07Cd06vJt4dWPZJ%2BAy4uIjxFr3zkMU%2FrkA%3D" rel="nofollow" target="_blank">mdnice</a>多平台发布</p>]]></description></item><item>    <title><![CDATA[个人知识管理的革新：访答知识库如何重塑你]]></title>    <link>https://segmentfault.com/a/1190000047442262</link>    <guid>https://segmentfault.com/a/1190000047442262</guid>    <pubDate>2025-12-01 22:04:14</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>个人知识管理的革新：访答知识库如何重塑你的学习与工作</h2><h3>一个程序员的觉醒时刻</h3><p>李明是一名资深程序员，每天都要处理大量的技术文档、代码片段和项目笔记。他曾经尝试过各种云端笔记软件，但总担心数据安全和隐私问题。直到有一天，他在查阅一份机密项目资料时，发现云端服务出现了同步错误，导致部分敏感数据泄露的风险。这次经历让他意识到：<strong>个人知识管理不仅需要便捷，更需要安全可控</strong>。</p><h3>什么是本地私有知识库</h3><p>本地私有知识库是指将个人或组织的知识资料存储在本地设备上，完全由用户自己掌控的数据管理系统。与云端知识库相比，它具有以下核心优势：</p><ul><li><strong>数据绝对安全</strong>：所有资料存储在个人设备，无需担心第三方数据泄露</li><li><strong>访问速度快</strong>：无需网络连接，随时随地快速检索和使用</li><li><strong>完全自主控制</strong>：用户拥有数据的完全所有权和管理权</li></ul><h3>访答知识库：个人知识管理的理想解决方案</h3><p>在众多知识库软件中，知识库脱颖而出，成为个人知识管理的佼佼者。这款专为个人用户设计的本地知识库软件，完美平衡了功能性与安全性。</p><p>李明开始使用后，发现工作效率显著提升。他可以将所有的技术文档、学习笔记、项目资料统一管理，通过强大的检索功能快速找到需要的信息。更重要的是，他知道这些珍贵的知识资产完全掌握在自己手中。</p><h3>知识管理带来的改变</h3><p>使用知识库半年后，李明的工作方式发生了根本性变化：</p><ul><li><strong>学习效率提升</strong>：建立了个人的技术知识体系，新技能掌握速度加快</li><li><strong>项目协作顺畅</strong>：虽然数据本地存储，但通过可控的分享机制，团队协作更加高效</li><li><strong>知识沉淀积累</strong>：多年的工作经验得以系统化保存，成为宝贵的个人资产</li></ul><h3>选择适合你的知识管理方式</h3><p>在信息爆炸的时代，有效的知识管理不仅是效率工具，更是个人竞争力的体现。知识库为代表的本地私有知识库，为重视数据安全和个人隐私的用户提供了理想选择。无论你是学生、专业人士还是知识工作者，建立一个属于自己的知识管理体系，都将为你的学习和工作带来深远影响。</p><p>开始构建你的个人知识库吧，让每一份积累都成为通向未来的阶梯。</p><p><img width="723" height="411" referrerpolicy="no-referrer" src="/img/bVdnd3U" alt="" title=""/></p>]]></description></item><item>    <title><![CDATA[从零开始做 Go 项目：我的目录设计分享]]></title>    <link>https://segmentfault.com/a/1190000047442269</link>    <guid>https://segmentfault.com/a/1190000047442269</guid>    <pubDate>2025-12-01 22:03:34</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h3>为什么要先规划目录结构</h3><p>刚开始写 Go 项目的时候，我对目录结构这件事格外重视。对于刚入门的人来说，开发过程中几乎每件事情都是第一次：</p><ul><li>全局配置怎么放？</li><li>数据库连接怎么初始化？</li><li>Model 怎么设计？</li><li>路由怎么组织？</li></ul><p>每一个点都能让人迷茫。</p><p>相比之下，像 Java 的 Spring Boot 或 PHP 的 Laravel 都会给你一套“默认结构”，至少能让你知道应该往哪里放东西。</p><p>而 Go 更自由，没有强迫你必须怎么做。对老手是好事，对新手却可能会踩坑。</p><p>我的经验是：</p><p><strong>合理的目录结构</strong>  <strong>=</strong>  <strong>清晰的思路 + 舒适的开发体验</strong></p><p>规划好结构之后，你可以把问题拆开逐个去实现，而不是一上来就面对一坨混乱的代码。</p><hr/><h3>我的 Go 项目目录结构（Gin 示例）</h3><p>下面是我常用的目录结构，适合大多数中小型 Web 项目：</p><pre><code>.
├── cmd/              # 项目入口目录
│   └── main.go       # 主程序入口
├── internal/         # 私有代码目录
│   ├── dto/          # 结构体定义目录
│   ├── handler/      # HTTP处理器(等同于Controller)
│   ├── model/        # 数据模型
│   ├── repository/   # 数据模型访问层
│   ├── router/       # 路由
│   └── service/      # 业务逻辑层
├── pkg/              # 可被外部引用的包
│   ├── config/       # 配置
│   ├── i18n/         # 国际化
│   ├── jwt/          # jwt
│   ├── middleware/   # 中间件
│   └── utils/        # 工具函数
├── api/              # API文档(Swagger)
│   └── swagger.json
├── scripts/          # 构建、部署脚本目录
├── go.mod
├── LICENSE
├── Makefile          # 自动化脚本说明书
└── README.md</code></pre><hr/><h3>cmd/：项目入口</h3><p>​<code>cmd</code> 存放整个项目的入口程序。</p><p>通常项目只有一个：</p><pre><code>cmd/
└── main.go</code></pre><p>如果未来拆成多个服务（如 API + Worker），结构可以扩展成：</p><pre><code>cmd/
├── api/
│   └── main.go
├── worker/
│   └── main.go</code></pre><p>这样多服务更好管理。</p><hr/><h3>internal/：项目私有代码</h3><p>​<code>internal</code>​ 是 Go 官方定义的 ​<strong>私有代码机制</strong>：这里的包只能本项目引用，外部无法导入。</p><p>我会把它拆成几个层次，职责分明：</p><pre><code>internal/
├── dto/          # 请求/响应结构体
├── handler/      # HTTP 层
├── service/      # 业务逻辑层
├── repository/   # 数据访问层
├── model/        # 数据模型
└── router/       # 路由注册</code></pre><p>调用链是单向的：</p><p><strong>Handler → Service → Repository → Model</strong></p><p>下面简单说一下每层负责什么：</p><ul><li>​<strong>Handler</strong>：接收/解析请求，参数校验，调用 Service</li><li>​<strong>Service</strong>：业务逻辑处理</li><li>​<strong>Repository</strong>：数据库读写（纯 CRUD，不写业务）</li><li>​<strong>Model</strong>：数据库结构体</li><li>​<strong>DTO</strong>：请求/响应结构（隔离 Model）</li><li>​<strong>Router</strong>：注册路由，绑定 Handler</li></ul><p>这种分层结构很适合 Go，也比 PHP 那种“一个 controller 干到底”的写法更好维护。</p><p>另外，Go 的一个特点是：  </p><p><strong>同一个 package 下多个</strong>  <strong>​.go​</strong>​ <strong>文件对编译器来说等同于同一个文件。</strong>   </p><p>所以可以自由地按模块拆成多个 <code>user.go</code>​、<code>order.go</code>，对程序来说他们直接就是一个文件不会有任何影响，但分开之后代码的可读性会极大的提高。</p><p>如果你有其他面向对象语言的经验，Go会带来全新的编程体验。核心的思维转变可归纳为四点：</p><ol><li><strong>忘掉"类"</strong>  → 记住"结构体+方法"</li><li><strong>忘掉"继承"</strong>  → 使用"组合+接口"</li><li><strong>忘掉"设计模式套用"</strong>  → 关注"解决问题"</li><li><strong>接受显式错误处理</strong> → 不再有try-catch</li></ol><hr/><h3>pkg/：可复用的公共包</h3><p>​<code>pkg</code> 用来放可被其他项目引用的通用模块，例如：</p><pre><code>pkg/
├── config/
├── i18n/
├── jwt/
├── middleware/
└── utils/</code></pre><p>如果只是给当前项目用，不需要放在 <code>pkg</code>​，尽量归到 <code>internal</code>。</p><p>另外也建议不要堆一个“大 utils”，按功能拆分更容易维护。</p><hr/><h3>api/：API 文档</h3><p>这里一般放 Swagger / OpenAPI 的定义文件（JSON/YAML）。</p><p>用这些工具来管理接口文档可以：</p><ul><li>自动生成文档</li><li>保持前后端对齐</li></ul><p>对于多人协作非常有用。</p><hr/><h3>Makefile：常用命令的“快捷键”</h3><p>我一般会把常用命令写进 <code>Makefile</code>，比如：</p><pre><code class="makefile">run:
    go run cmd/main.go

build:
    go build -o bin/app cmd/main.go

test:
    go test ./...</code></pre><p>Makefile 是个好东西，你可以把各种项目会用到的命令像清单一样列出来。</p><p>如果你有心思，甚至可以去做一个 help 命令来告诉其他人都有什么命令</p><pre><code class="makefile">help:
    @echo "可用指令："
    @echo "  make deps          # 安装 / 更新 Go 依赖"
    @echo "  make fmt           # 统一格式化后端 Go 代码"
    @echo "  make test          # 执行全部 Go 单元测试"</code></pre><p>对新同事非常友好，哪怕不了解项目，也可以通过阅读 Makefile 快速上手项目。</p><hr/><h2>总结</h2><p>对我来说，一旦目录结构定下来，剩下的基本就像做“填空题”一样：</p><ul><li>中间件怎么写</li><li>JWT 怎么做</li><li>数据库要建哪些表</li><li>Handler / Service / Repository 各自实现哪些逻辑</li></ul><p>这些都能一块一块稳稳推进。</p><p>Go 社区里没有唯一正确的结构，但这套分层思路对新手来说非常友好，也足够应对大部分项目。</p><p>如果你正在准备写一个 Go 项目，希望这套结构能帮你少踩一些坑，也让你的项目更容易维护。</p>]]></description></item><item>    <title><![CDATA[如何快速对接印度股票市场 (NSE/BS]]></title>    <link>https://segmentfault.com/a/1190000047442297</link>    <guid>https://segmentfault.com/a/1190000047442297</guid>    <pubDate>2025-12-01 22:02:50</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>在全球资产配置日益流行的今天，印度股市（NSE/BSE）因其高增长潜力成为了开发者和量化团队关注的焦点。然而，寻找稳定、易用且覆盖全面的印度市场数据源往往是一个痛点。</p><p>本文将演示如何利用 <strong>StockTV API</strong> 快速接入印度股票市场数据，涵盖从获取股票列表、指数行情到绘制 K 线图的全流程。</p><h2>为什么选择这个方案？</h2><p>根据 API 文档，该接口具有以下特点：</p><ul><li><strong>覆盖全面</strong>：支持 NSE（印度国家证券交易所）和 BSE（孟买证券交易所）。</li><li><strong>数据丰富</strong>：包含实时报价、历史 K 线、指数（如 Nifty 50）、IPO 日历及涨跌幅榜。</li><li><strong>开发友好</strong>：采用标准的 RESTful JSON 格式，且提供 WebSocket 实时推送。</li></ul><hr/><h2>准备工作</h2><p>在开始之前，你需要获取一个 API <code>key</code>。所有请求都需要在 URL 参数中带上 <code>key=你的密钥</code>。</p><ul><li><strong>API 基础地址</strong>: <code>https://api.stocktv.top</code></li><li><strong>印度市场 Country ID</strong>: <code>14</code></li></ul><hr/><h2>第一步：获取市场概览与股票列表</h2><p>要获取数据，首先需要知道股票在系统中的唯一标识符（<code>pid</code> 或 <code>id</code>）。我们需要调用市场列表接口，并指定 <code>countryId=14</code>（代表印度）。</p><p><strong>接口地址：</strong><br/><code>GET /stock/stocks?countryId=14&amp;pageSize=10&amp;page=1&amp;key=YOUR_KEY</code></p><p><strong>返回数据示例：</strong></p><pre><code class="json">{
  "code": 200,
  "data": {
    "records": [
      {
        "id": 946725, // 重要：这是 PID，后续查K线要用
        "name": "Inventure Growth Securities",
        "symbol": "IGSL",
        "exchangeId": 46, // 46 代表 NSE
        "last": 2.46,     // 最新价
        "chgPct": -20.13, // 涨跌幅
        "countryNameTranslated": "India"
      }
    ]
  }
}</code></pre><p><em>注：你可以通过 <code>exchangeId</code> 区分 NSE (46) 和 BSE (74)。</em></p><hr/><h2>第二步：获取主要指数 (Nifty 50)</h2><p>印度市场的风向标是 <strong>Nifty 50</strong> 和 <strong>Sensex</strong>。我们可以通过指数接口获取实时行情。</p><p><strong>接口地址：</strong><br/><code>GET /stock/indices?countryId=14&amp;flag=IN&amp;key=YOUR_KEY</code></p><p><strong>代码示例 (JavaScript/Node.js):</strong></p><pre><code class="javascript">const API_KEY = 'YOUR_API_KEY';

async function getIndianIndices() {
  const url = `https://api.stocktv.top/stock/indices?countryId=14&amp;flag=IN&amp;key=${API_KEY}`;
  
  try {
    const response = await fetch(url);
    const result = await response.json();
    
    // 查找 Nifty 50
    const nifty = result.data.find(item =&gt; item.name === "Nifty 50");
    console.log(`Nifty 50 最新点位: ${nifty.last}, 涨跌: ${nifty.chgPct}%`);
  } catch (error) {
    console.error("获取指数失败", error);
  }
}</code></pre><hr/><h2>第三步：获取 K 线数据 (绘制图表)</h2><p>这是开发交易面板或看盘软件最核心的部分。接口支持多种时间周期，格式采用 ISO 8601 标准（如 <code>PT1M</code> 代表 1分钟，<code>P1D</code> 代表 1天）。</p><p><strong>接口地址：</strong><br/><code>GET /stock/kline?pid={股票ID}&amp;interval={周期}&amp;key=YOUR_KEY</code></p><p><strong>参数说明：</strong></p><ul><li><code>pid</code>: 第一步中获取的 <code>id</code>。</li><li><code>interval</code>: <code>PT1M</code> (1分), <code>PT15M</code> (15分), <code>PT1H</code> (1小时), <code>P1D</code> (日线) 等。</li></ul><p><strong>实战：获取 Reliance Industries 的日线数据</strong></p><pre><code class="javascript">async function getKlineData(pid) {
  // P1D 代表日线数据
  const url = `https://api.stocktv.top/stock/kline?pid=${pid}&amp;interval=P1D&amp;key=${API_KEY}`;
  
  const response = await fetch(url);
  const json = await response.json();
  
  // 转换数据格式以适配前端图表库（如 ECharts 或 KlineCharts）
  const chartData = json.data.map(item =&gt; ({
    timestamp: item.time,  // 时间戳
    open: item.open,       // 开盘
    high: item.high,       // 最高
    low: item.low,         // 最低
    close: item.close,     // 收盘
    volume: item.volume    // 成交量
  }));
  
  return chartData;
}</code></pre><hr/><h2>进阶功能：IPO 日历与涨跌榜</h2><p>除了基础行情，API 还提供了一些特色数据，非常适合做市场热点分析。</p><ol><li><strong>IPO 新股日历</strong>：<br/>查询印度即将上市或已上市的股票。<br/><code>GET /stock/getIpo?countryId=14&amp;type=1&amp;key=YOUR_KEY</code> (type=1表示未上市)</li><li><strong>涨跌幅排行榜</strong>：<br/>快速发现市场中波动最大的股票。<br/><code>GET /stock/updownList?countryId=14&amp;type=1&amp;key=YOUR_KEY</code> (type=1涨幅榜，2跌幅榜)</li></ol><hr/><h2>总结</h2><p>通过 StockTV 的 API，我们可以非常便捷地构建一个印度股市行情看板。其核心逻辑总结如下：</p><ol><li>锁定 <strong>Country ID = 14</strong>。</li><li>通过 <strong>列表接口</strong> 获取 PID。</li><li>通过 <strong>K 线接口</strong> 获取历史数据用于绘图。</li><li>利用 <strong>IPO 和排行榜接口</strong> 丰富应用内容。</li></ol><p>如果你正在开发全球化的金融应用，这套接口能够极大降低对接印度市场的门槛。</p>]]></description></item><item>    <title><![CDATA[小心！你的工作可能正在被AI“水下渗透”]]></title>    <link>https://segmentfault.com/a/1190000047442300</link>    <guid>https://segmentfault.com/a/1190000047442300</guid>    <pubDate>2025-12-01 22:02:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>一个惊人的数字正悄然浮现：1.2万亿美元薪资的工作内容，技术上已能被AI替代。而你，很可能身处其中。</p><p>麻省理工学院最新研究敲响警钟：AI已能覆盖美国11.7% 的劳动力任务——这相当于1770万个工作岗位的核心技能与AI高度重叠。</p><p>但更可怕的是，我们日常关注的科技行业裁员、程序员需求下降，仅仅占影响的2.2%。真正的冲击，正像水下冰山一样，悄无声息地向你袭来。</p><p>11.7% vs 2.2%：你看到的只是冰山一角</p><p>为什么你的工作可能比程序员更危险？MIT的“冰山指数”揭示了一个反直觉的真相：</p><p>· 水面之上（2.2%）：编程、创意写作等“显性受冲击”岗位<br/>· 水面之下（11.7%）：金融审核、物流协调、医疗行政、供应链监控等认知型岗位</p><p>研究团队利用超级计算机分析了13000多种AI工具与数万种工作技能的匹配度。结果显示：大量处理文档、协调流程、分析数据的日常白领工作，正成为AI替代的“重灾区”。</p><p>数据不会说谎：这些地方正在悄悄失守</p><p>田纳西州的案例令人警醒：</p><p>· 传统评估：科技行业少，列为“低风险区”<br/>· 冰山指数：11.6% 的高暴露度<br/>· 原因：庞大的物流枢纽背后，调度员、采购专员、财务分析师的日常工作，正是AI最容易接管的领域</p><p>更颠覆认知的是：特拉华州和犹他州的AI暴露度甚至超过科技中心加州——只因为它们的产业集中在金融和行政管理。</p><p>致命盲区：GDP增长可能正在掩盖危机</p><p>当你的工作被AI“温水煮青蛙”般替代时，传统经济指标却在释放错误信号：</p><p>· GDP可能在自动化效率提升下继续增长<br/>· 失业率可能因劳动力转向低薪服务业而保持平稳<br/>· 但结构性失业的暗潮已在数据背后涌动</p><p>研究发出警告：当失业真正反映在统计数据上时，最佳的干预时机已经错过。</p><p>技能阶梯正在断裂：没有初级岗位的未来</p><p>一个残酷的现实正在发生：</p><p>· AI每天生成超10亿行代码，初级程序员需求锐减<br/>· 金融、医疗、物流领域的基础数据处理岗加速消失<br/>· 传统的“从初级到专家”培养路径正在崩塌</p><p>这意味着：年轻人迈入职场的第一级台阶，正在被AI抽走。</p><p>重新定位：在“替代”与“增强”之间找到生路</p><p>面对11.7%的替代风险，被动等待等于职业自杀。研究发现，69% 的高风险地区已经与AI高应用地区重合。</p><p>企业与个人必须清醒：真正改变商业格局的，往往不是前沿AI模型，而是那些已嵌入日常办公软件的13000多种AI工具。它们正在悄无声息地重塑财务、人事、客服等每个后台部门。</p><p>转折点已经到来：“增强”与“替代”的界限，取决于你是否掌握与AI协作的新技能。这正是为什么系统化的AI应用学习不再是“加分项”，而是“生存项”。</p><p>当水面之下的冰山开始移动，没有人能置身事外。1770万工作岗位的核心技能已与AI重叠，你的技能坐标是否还在安全区？答案不取决于行业，而取决于你能否比AI更快地进化。</p>]]></description></item><item>    <title><![CDATA[一次找齐！1000 个 Nano Ban]]></title>    <link>https://segmentfault.com/a/1190000047442303</link>    <guid>https://segmentfault.com/a/1190000047442303</guid>    <pubDate>2025-12-01 22:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <h2>前言</h2><p>别人使用 Nano Bannana 生成了非常惊艳的图片，你是不是也想知道他们用了什么提示词？</p><p>于是我找了很多 Nano Banna 提示词库，上千个提示词可以直接复制使用！</p><p>如果你还不知道在哪里使用 Nano banana Pro，可以先看这篇：<a href="https://link.segmentfault.com/?enc=PKibRDqEbzMogpKL6C5%2Bgw%3D%3D.64jpKnBgr4SHePtPPei%2F72I6Kpn6jp%2BeiDSoTrWdoMj5pFVjsWCPrKC52gfZ0EBK9cO8kx1w0zDD%2FQh%2B37LVRQ%3D%3D" rel="nofollow" target="_blank">6 个白嫖 Nano Banana Pro 的网站</a></p><p>10 年技术博主，最新资讯、前端知识、AI 干货，欢迎关注公众号：“冴羽” 或者搜索“yayujs”</p><h2>OpenNana</h2><p>地址：<a href="https://link.segmentfault.com/?enc=FKW06txKQAPJxyHSGi9YGQ%3D%3D.0w02S1dWDgWsgEwvVBeMHkMd33TRH1gJCgvqSFh%2BbxDtZRVj2uWqAABZLJf5E8%2BL" rel="nofollow" target="_blank">https://opennana.com/awesome-prompt-gallery/</a> 540 个案例直接使用</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442305" alt="" title=""/></p><p>可以直接选择复制提示词使用：</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442306" alt="" title="" loading="lazy"/></p><h2>Youmind</h2><p>地址：<a href="https://link.segmentfault.com/?enc=v0Z6P0sEbQplR7Z7BgoX5g%3D%3D.SqAgln4E9fgX1mzsd87IJaIUobiPcwcZ%2BjofgvGyo5%2BoA5bOY%2Bgx5pWGEA7lN3ATOYKf5tOPtyWeuOzslJSy%2BA%3D%3D" rel="nofollow" target="_blank">https://youmind.com/zh-TW/nano-banana-pro-prompts</a> 519 个提示词直接使用</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442307" alt="" title="" loading="lazy"/></p><p>还可以在 Youmind 直接使用 Nano Banana Pro 生成图片，需要消耗积分。</p><p>每月可以免费获取 2000 积分，使用 Nano Banana Pro 生成图片每张大概消耗 15 积分。</p><p>注册的时候，使用邀请码：<a href="https://link.segmentfault.com/?enc=Erw3e9GqUOumuZvDk46gxA%3D%3D.LwLF59D5BoUYbtCJWE9fyqGEs4Qpe21JDLGGyByQJpxduFtKy7aryFW4ce%2F%2FXHxL" rel="nofollow" target="_blank">2KRVE5</a>，可以多获得 1000 积分，又可以多生成 66 张图片了。</p><h2>提示词宝库</h2><p>地址：<a href="https://link.segmentfault.com/?enc=X6traS6G26e099SdnFAUjQ%3D%3D.57O6OwUDHJQG4KcLKAUQBKETLKo5y1OlmOtQ8EXK35c%3D" rel="nofollow" target="_blank">https://nanobanana.pixtoai.com/</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442308" alt="" title="" loading="lazy"/></p><h2>AIWIND</h2><p>地址：<a href="https://link.segmentfault.com/?enc=%2FpE63ifb63%2BhlDUuHqf0yA%3D%3D.x1jbC%2BN1R71P%2F%2FJlgHuNmLhadN4mn7m6wwR20nYex5k%3D" rel="nofollow" target="_blank">https://www.aiwind.org/</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442309" alt="" title="" loading="lazy"/></p><h2>Promots</h2><p>地址：<a href="https://link.segmentfault.com/?enc=9YuPU3elVtEHAHtLd%2FAywg%3D%3D.wzc8huUsqiFDr2xILgPYg7IHRp9RjSuZ2846Hf0zREm6OxdLbfXskywNXz8v3W9k" rel="nofollow" target="_blank">https://nanobananaprompt.org/prompts/</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442310" alt="" title="" loading="lazy"/></p><h2>GitHub</h2><p>GitHub 上有很多提示词仓库：</p><p>Awesome-Nano-Banana-images：<a href="https://link.segmentfault.com/?enc=2wMrbk0PhxXRZe2gbalheg%3D%3D.egiicfZBk83VHaQZ1gYxuKMqc9AuOdImWcxQOH8l18LcK21BW%2BK3W37lixyga%2BpCfbLbyL4A%2Be8rRZpllwDu%2Bw%3D%3D" rel="nofollow" target="_blank">https://github.com/PicoTrex/Awesome-Nano-Banana-images</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442311" alt="" title="" loading="lazy"/></p><p>awesome-nano-banana：<a href="https://link.segmentfault.com/?enc=25uEy2NeretyT%2BcduOHvMQ%3D%3D.bR2zPsY2qsCAbkswQmPvEzYddeLwjMDrt%2FiYXTPz5Eex1bwHGDTOw27enXE%2Bawrc" rel="nofollow" target="_blank">https://github.com/JimmyLv/awesome-nano-banana</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442312" alt="" title="" loading="lazy"/></p><h2>飞书文档</h2><p>一些博主搜集的：</p><p>地址：<a href="https://link.segmentfault.com/?enc=QlBHNXfBIHIKXfXsb8yOSg%3D%3D.fJ1N5X52quQfFUq9uv%2BV%2BIi7QJj8NbJ%2B%2FWcjuqZIpPcu1XAfFRBAK2Yp%2BtytyI8MffB9o6%2FCYUfOFy1qvpVflA%3D%3D" rel="nofollow" target="_blank">https://ai.feishu.cn/docx/IKO3dWCeyobZ5CxWE18cV40xnth</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442313" alt="" title="" loading="lazy"/></p><p>地址：<a href="https://link.segmentfault.com/?enc=pWJA1GuqqXxwtlP8BATJ1Q%3D%3D.OLYati2zXpKDF5Npb9PkLys0296DVseVr1YYyeLG98c%2FiF2ND1z2HiLrZDqM05Gz141k24LJtusKLe6Oikjadw%3D%3D" rel="nofollow" target="_blank">https://ai.feishu.cn/wiki/RJ4RwiI0BiFiwnkk9DBcLaasnJh</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442314" alt="" title="" loading="lazy"/></p><h2>官方教程</h2><p>Gemini 官方提供了写提示词的技巧和示例模板，在这里你可以学习如何写提示词。</p><p>地址：<a href="https://link.segmentfault.com/?enc=%2Fg4tytnmYu9wJ54VmLziig%3D%3D.lvi%2FghDg4VVkzo9sm8IptpRdlWM6KlwNjn9C8%2FnVtbTIQUK3ppqrRgygu5AMRsxfE2%2FCIYM8pQevTm7TGk8Ygw%3D%3D" rel="nofollow" target="_blank">https://ai.google.dev/gemini-api/docs/image-generation?hl=zh-cn</a></p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442315" alt="" title="" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[从赋能到共创：技术负责人的团队赋能五层次]]></title>    <link>https://segmentfault.com/a/1190000047442169</link>    <guid>https://segmentfault.com/a/1190000047442169</guid>    <pubDate>2025-12-01 21:03:02</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <blockquote>文 / Kenyon，关注我，获取更多企业级架构、技术团队管理和AI实践与落地的深度指南。</blockquote><p><em>由于公众号推流的原因，请在关注页右上角加星标，这样才能及时收到新文章的推送。</em></p><p><strong>摘要</strong>：本文提出技术团队赋能的五层次模型——工具赋能、能力赋能、决策赋能、文化赋能、生态赋能，剖析各层次本质与实践方法，揭示从"管理控制"到"生态共创"的赋能思维转变，为技术负责人构建高绩效团队提供系统指南。</p><h2>引言</h2><p>在前一篇文章《<a href="https://link.segmentfault.com/?enc=Z6f2yxmqcb%2BbF3ckvqg8tA%3D%3D.yIwRnRc0o1YDuYmYHYbcZxaDof39%2B0bbFHhTyuJTbokNC5O8eWFRSif9G0nrPPtf6rvoPMizlnZgoXGPUt%2FO7Q%3D%3D" rel="nofollow" target="_blank">从技术管理者到战略决策者，揭秘IT团队负责人的四个价值层次，看看您在第几层？</a>》中，我们探讨了IT团队负责人的价值跃迁路径。估计很多读者会想："作为技术管理者，想要提升自己的价值肯定是要借助团队的力量的，但是要怎么给团队赋能才能让团队发挥更大的作用呢？具体该怎么做？赋能有哪些层次？"</p><p>今天，我们就来深入探讨这个话题：<strong>技术负责人如何给团队赋能？赋能的价值层次有哪些？</strong>，以下是一些我个人的思考和经验，希望能对您有所帮助。</p><p>与前面文章的<a href="https://link.segmentfault.com/?enc=dCyL0hEW9rzfJnDzaoarHg%3D%3D.GhE3G1t2n9IBNLd%2BZtUtbZpDz%2BeYLM7e3AgVEqR2%2F1mw2jhV9tngmmg0PTBG48QzxfoIMqszp%2BytCy0hIEeDGw%3D%3D" rel="nofollow" target="_blank">IT团队的价值层次</a>和<a href="https://link.segmentfault.com/?enc=QLbFrCRpC3qpmb8QH3nFfQ%3D%3D.%2B4XzNip6DAM7G9eUKGgPyx6HCaPVF7ZuChVwdNvv%2BXG7TQlOLNhN%2FLvl9tB%2BpfzClCmIUKUJ5pvZmBD1LEd5SA%3D%3D" rel="nofollow" target="_blank">技术负责人的价值层次</a>类似，<strong>团队赋能</strong>也存在类似的递进式价值层次。从基础的工具支持到高级的生态共创，每个层次都代表着赋能思维的本质跃迁。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442171" alt="926d1ff011a9445685198c2ce01472d7~tplv-tb4s082cfz-aigc_resize_2400_2400.webp" title="926d1ff011a9445685198c2ce01472d7~tplv-tb4s082cfz-aigc_resize_2400_2400.webp"/></p><p>以下是我总结出来给团队赋能的五层次模型，在这里抛砖引玉，大家一起探讨：</p><h2>第一层：工具赋能</h2><p><strong>赋能方式</strong>：</p><ul><li>可以为团队提供日常工作中常用的开发工具、基础设施和资源（如：提供必要的硬件设备、统一IDE和配置、收费的软件还可以考虑提供许可证等）</li><li>为团队建立标准化的开发环境和工作流程（如：搭建统一的开发环境、定制完善的开发流程、引入CI/CD自动化工具、自动化测试、代码审查等）</li><li>确保团队成员能够便捷地获取所需的技术资源（如：建立内部技术文档平台和知识库，共享最佳实践、提供及时的技术支持和反馈等）</li></ul><p><strong>赋能思维</strong>：巧妇难为无米之炊，工欲善其事，必先利其器<br/><strong>赋能本质</strong>：降低工作门槛 × 提升工作效率</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442172" alt="工具赋能" title="工具赋能" loading="lazy"/></p><h2>第二层：能力赋能</h2><p><strong>赋能方式</strong>：</p><ul><li>关注团队成员的技能提升和知识增长（如：做人才盘点、定期组织技术分享会和内部培训、甚至是给团队成员提供定制化的技术支持等）</li><li>提供有针对性的培训和学习机会（如：支持团队成员参加外部技术会议和课程、鼓励团队成员参与开源项目和技术社区等等）</li><li>建立导师制和知识分享机制（如：建立"师徒制"，让资深工程师指导新人等）</li></ul><p><strong>赋能思维</strong>：授人以鱼不如授人以渔<br/><strong>赋能本质</strong>：提升个体能力 × 促进知识共享</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442173" alt="能力赋能" title="能力赋能" loading="lazy"/></p><h2>第三层：决策赋能</h2><p><strong>赋能方式</strong>：</p><ul><li>赋予团队成员自主决策的权力（如：建立"授权矩阵"，明确不同层级的决策权限，让不同层级的团队成员有不同的决策权力等）</li><li>建立清晰的决策框架和边界（如：定义决策范围、决策过程和决策结果的评估标准，采用"轻量级治理"，减少不必要的审批流程等）</li><li>鼓励团队成员主动承担责任（如：鼓励团队成员参与需求分析和技术选型，建立"容错机制"，允许团队成员在合理范围内试错等）</li></ul><p><strong>赋能思维</strong>：把决策权交给离问题最近的人<br/><strong>赋能本质</strong>：提高决策效率 × 增强责任感</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442174" alt="决策赋能" title="决策赋能" loading="lazy"/></p><h2>第四层：文化赋能</h2><p><strong>赋能方式</strong>：</p><ul><li>构建开放、创新、协作的团队文化（如：定期组织团队建设活动，增强团队凝聚力，建立"创新激励机制"，奖励有价值的创新想法等）</li><li>建立有效的沟通机制和反馈闭环（如：采用"扁平式沟通"，减少层级障碍等）</li><li>营造公平、尊重、包容的工作环境（如：建立"无指责文化"，关注问题解决而非追责等）</li></ul><p><strong>赋能思维</strong>：良好的团队文化是最好的管理者<br/><strong>赋能本质</strong>：激发内在动机 × 增强团队凝聚力</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442175" alt="文化赋能" title="文化赋能" loading="lazy"/></p><h2>第五层：生态赋能</h2><p><strong>表现特征</strong>：</p><ul><li>连接外部资源，为团队创造更大的价值空间（如：与外部技术社区建立合作关系等）</li><li>促进团队与其他部门、外部合作伙伴的协同（如：与高校、研究机构开展技术合作、鼓励团队成员参与行业标准制定等）</li><li>构建开放的技术生态系统（如：构建开放API，促进与其他系统的集成等）</li></ul><p><strong>赋能思维</strong>：一个人可以走得更快，但是一群人可以走得更远。<br/><strong>赋能本质</strong>：整合外部资源 × 拓展价值边界</p><p><img referrerpolicy="no-referrer" src="/img/remote/1460000047442176" alt="生态赋能" title="生态赋能" loading="lazy"/></p><h2>赋能的本质</h2><p>在传统管理模式中，技术负责人更像"指挥官"，通过指令和控制来确保团队完成任务。而赋能则是一种全新的管理思维：</p><ul><li><strong>赋能不是授权</strong>：授权是将权力转移，赋能是提升能力</li><li><strong>赋能不是放任</strong>：放任是不管不问，赋能是提供支持和资源</li><li><strong>赋能不是培训</strong>：培训是单向传授，赋能是双向激发</li></ul><p><strong>赋能的本质</strong>：在给团队足够的安全感之下，通过去提供工具、培养能力、授予权力、构建文化，释放团队成员的内在潜力，让他们能够自主地去解决问题、创造价值。是从"管理控制"到"释放潜力"的一个过程。</p><h2>赋能跃迁的关键思维转变</h2><table><thead><tr><th>层级跃迁</th><th>核心问题</th><th>思维转变</th><th>赋能重点</th></tr></thead><tbody><tr><td>1 → 2</td><td>"如何让团队更高效地工作？"</td><td>从资源提供到能力培养</td><td>知识与技能提升</td></tr><tr><td>2 → 3</td><td>"如何让团队做出更好的决策？"</td><td>从能力培养到权力授予</td><td>自主与责任</td></tr><tr><td>3 → 4</td><td>"如何让团队持续创新？"</td><td>从权力授予到文化构建</td><td>动机与凝聚力</td></tr><tr><td>4 → 5</td><td>"如何让团队创造更大的价值？"</td><td>从文化构建到生态协同</td><td>资源整合与价值拓展</td></tr></tbody></table><h2>给技术负责人的赋能建议</h2><ol><li><strong>循序渐进，避免跳跃</strong>：赋能是一个渐进的过程，不要期望一步到位。先从工具赋能开始，逐步提升到更高层次。</li><li><strong>因材施教，个性化赋能</strong>：不同的团队成员有不同的需求和潜力，技术负责人需要根据个人特点提供个性化的赋能方案。</li><li><strong>建立反馈机制</strong>：定期与团队成员沟通，了解他们的需求和困难，及时调整赋能策略。</li><li><strong>以身作则，成为榜样</strong>：技术负责人要成为赋能的典范，不断学习和成长，为团队树立榜样。</li><li><strong>长期坚持，持续改进</strong>：赋能不是一次性的活动，而是长期的过程。技术负责人需要持续关注团队的发展，不断优化赋能策略。</li></ol><h2>结论</h2><p>作为技术负责人，赋能是一项核心的领导能力。通过构建从工具赋能到生态赋能的五层次模型，技术负责人可以系统地提升团队的能力和价值创造潜力。</p><p>赋能的最高境界是：<strong>让每个团队成员都能发挥出自己的最大潜力，让团队能够自主地解决问题、创造价值，最终实现从"管理控制"到"生态共创"的领导思维转变。</strong></p><p>在赋能的道路上，技术负责人既是教练，也是伙伴，更是团队成长的推动者。只有真正掌握了赋能的艺术，才能带领团队在快速变化的技术环境中不断创新、持续成长。</p><hr/><p><strong>互动话题</strong>：作为技术负责人，你在团队赋能方面有哪些成功的实践经验？欢迎在评论区分享你的思考与感悟！<br/><strong>下篇预告</strong>：之前的文章有讲到<a href="https://link.segmentfault.com/?enc=9YPd3YNAxp6v0Rk1kGpy%2BA%3D%3D.XPtuSlxazO%2FldvofN20WN3QHaND1u70xkMDeGpmwelW3G4YO1w%2B1TZ0YOz21ORUMZ7xHkPhWwhykYly7nbC%2BJA%3D%3D" rel="nofollow" target="_blank">工作安排的五项修炼</a>，作为一个技术管理者，安排工作的时候应该怎么授权呢，有哪些注意事项呢？下一篇文章我们一起唠叨一下。</p><h2>关于作者</h2><p>Kenyon，资深软件架构师，15年的软件开发和技术管理经验，从程序员做到企业技术高管。多年企业数字化转型和软件架构设计经验，善于帮助企业构建高质量、可维护的软件系统，目前专注技术管理、架构设计、AI技术应用和落地；全网统一名称“六边形架构”，欢迎关注交流。</p><p><em>原创不易，转载请联系授权，如果觉得有帮助，请点赞、收藏、转发三连支持！</em><br/><em>由于公众号推流的原因，请在关注页右上角加星标，这样才能及时收到新文章的推送。</em></p>]]></description></item><item>    <title><![CDATA[新一代SageMaker+Databri]]></title>    <link>https://segmentfault.com/a/1190000047442196</link>    <guid>https://segmentfault.com/a/1190000047442196</guid>    <pubDate>2025-12-01 21:02:13</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p><img width="723" height="160" referrerpolicy="no-referrer" src="/img/bVdkFLr" alt="image.png" title="image.png"/></p><h2>前言</h2><p>在数据驱动决策的时代，企业正面临着两大核心挑战：如何打破数据孤岛实现跨平台协作，以及如何在复杂技术栈中保持治理一致性。这些挑战直接影响着企业从数据中获取价值的能力和速度。</p><p>Databricks作为领先的数据分析和机器学习平台，已经帮助众多企业实现了大规模数据处理和分析。与此同时，许多企业在亚马逊云科技云上构建了完整的业务系统和机器学习工作流。如何让这两个强大的生态系统无缝协作，成为了释放数据价值的关键所在。</p><p>本文提出的解决方案：通过SageMaker Unified Studio与Databricks Unity Catalog的深度集成，企业既能充分利用Databricks强大的数据分析能力，又能与亚马逊云科技上现有的业务系统深度融合，真正实现数据价值的最大化。这不是简单的技术对接，而是一种全新的数据协作范式。</p><p>本文将以真实业务场景为锚点，深度解析两大平台的协同价值：</p><p>1.技术融合性 – 零摩擦的数据访问</p><p>通过SageMaker Unified Studio中的托管JupyterLab环境，借助EMR Serverless的强大计算能力，直接访问Databricks Unity Catalog中的受治理数据。这种架构彻底消除了传统ETL的冗余，让数据科学家能够实时访问最新的业务数据，显著提升模型开发效率。</p><p>2.治理穿透力 – 企业级安全合规保障</p><p>在新一代SageMaker工作流中无缝继承Databricks预设的数据血缘追踪、细粒度访问控制和完整审计策略。这意味着企业无需重复构建治理体系，即可确保跨平台的数据安全性和合规性，大幅降低治理成本和风险。</p><p>实战导向的技术指南</p><p>我们不仅会深入剖析架构设计的核心要点，更重要的是分享在实际项目落地中积累的宝贵经验和避坑指南：</p><p>关键技术挑战与解决方案：</p><ul><li>跨平台安全访问：如何在保证数据安全的前提下实现平台间的身份认证和授权</li><li>混合云网络配置：企业混合云环境下的网络连通性最佳实践</li><li>性能优化策略：大规模数据查询的性能调优技巧</li><li>生产级部署考量：从POC到生产环境的平滑过渡路径</li></ul><p>通过本文，您将获得一份经过实践验证的完整集成方案，帮助您的团队快速构建一个安全、高效、可扩展的跨平台数据科学工作流。</p><h2>架构解析</h2><p><img width="723" height="408" referrerpolicy="no-referrer" src="/img/bVdnbZ9" alt="image.png" title="image.png" loading="lazy"/></p><p>此架构旨在整合 Amazon SageMaker Notebook和Databricks Unity Catalog 的功能，以实现高效的数据处理、机器学习模型开发以及跨平台的数据共享和协作。</p><p><strong>亚马逊云科技 Side</strong></p><p>SageMaker Unified Studio: 作为亚马逊云科技的核心组件之一，Sagemaker Unified Studio为数据科学家和开发者提供了一个集成的开发环境，用于构建、训练和部署机器学习模型。它支持多种编程语言和框架，并且可以无缝地与亚马逊云科技其他服务进行集成。</p><p>EMR Studio Notebook: EMR Studio Notebook是Amazon EMR的一部分，它允许用户在云端运行交互式数据分析任务。通过EMR Studio Notebook，用户可以利用Apache Spark等大数据处理框架来处理大规模数据集。</p><p><strong>Databricks Side</strong></p><p>Open API: Databricks提供了丰富的API接口，使得外部系统能够与其进行通信和数据交换。这些API包括但不限于REST API，它们允许用户执行各种操作，如创建和管理集群、运行作业、查询数据等。</p><p>Unity Catalog: Databricks的 Unity Catalog是一个元数据管理解决方案，它帮助组织管理和治理其数据资产。通过 Unity Catalog，用户可以定义和应用细粒度的数据访问控制策略，确保数据的安全性和合规性。</p><p>Delta Lake: Delta Lake是Databricks推出的一个开源存储层，它提供了ACID事务、统一的数据治理和高性能的数据处理能力。Delta Lake可以存储结构化和半结构化的数据，并支持实时分析和批处理等多种工作负载。</p><h2>Databricks 数据共享方式</h2><p>Databricks提供了多种数据共享的方式,下面是一个列表,我们可以根据自己的需求来进行选择.</p><p><img width="723" height="487" referrerpolicy="no-referrer" src="/img/bVdnb0b" alt="image.png" title="image.png" loading="lazy"/></p><p>本案例中我们使用 Unity Catalog Open APIs 来实现 Databricks 和 SageMaker Unified Studio的数据共享, 下面我们将逐步带大家完成所有的配置.</p><h2>Databricks 侧配置</h2><ol><li>首先我们需要开启Databricks的Catalog External Access, 配置步骤如下.</li></ol><p><img width="723" height="430" referrerpolicy="no-referrer" src="/img/bVdnb0c" alt="image.png" title="image.png" loading="lazy"/></p><p><img width="723" height="239" referrerpolicy="no-referrer" src="/img/bVdnb0d" alt="image.png" title="image.png" loading="lazy"/></p><p>Enable <strong>External data access</strong></p><p><img width="723" height="301" referrerpolicy="no-referrer" src="/img/bVdnb0e" alt="image.png" title="image.png" loading="lazy"/></p><ol start="2"><li>配置Databricks用户可以在外部访问Catalog的权限,使用以下示例语句.</li></ol><p><code> GRANT EXTERNAL USE SCHEMA ON SCHEMA &lt;catalog_name&gt;.&lt;schema_name&gt; TO `xxxxx@xx.com` </code></p><ol start="3"><li>配置对用Databricks 用户Personal Access Token,点击用户<strong>Settings</strong> 选项</li></ol><p><img width="723" height="205" referrerpolicy="no-referrer" src="/img/bVdnb0f" alt="image.png" title="image.png" loading="lazy"/></p><p><img width="723" height="199" referrerpolicy="no-referrer" src="/img/bVdnb0g" alt="image.png" title="image.png" loading="lazy"/></p><p><img width="723" height="221" referrerpolicy="no-referrer" src="/img/bVdnb0h" alt="image.png" title="image.png" loading="lazy"/></p><p><img width="723" height="376" referrerpolicy="no-referrer" src="/img/bVdnb0i" alt="image.png" title="image.png" loading="lazy"/> </p><p>一定要记录下来生成好的access token,它只能被记录一次,至此我们在 Databricks上配置就可以了.</p><h2>Sagemaker Unified Studio 配置</h2><p>在 Amazon SageMaker Unified Studio 中，域是用于连接您的资产、用户及其项目的组织实体。域代表组织内业务线 (LOB) 或业务领域的独特边界，这些业务领域可以管理自己的数据，包括自己的数据资产、自己的数据或业务术语定义，并可能有自己的治理标准。管理员创建域并与用户或组共享 URL。首次开始使用 Amazon SageMaker Unified Studio 时，首先要创建域以及域中存在的所有核心组件。</p><h3>设置 Amazon SageMaker 统一工作室域</h3><ol><li>要开始创建域，请在 <a href="https://link.segmentfault.com/?enc=79ivrrDT5C3iS5pTrazbAA%3D%3D.wop2tTJBCHXQqq04B0Jps2YIiGKE%2F5grFchPwK2Vr3KAqSCbxdsK1PrgvP1v8h2NRkBzzucXAAv4r%2BJv0kIVmg0lz%2BneRDCTmFrzZzJafoM%3D" rel="nofollow" target="_blank">Amazon SageMaker </a>控制台上点击 创建统一工作室域按钮。</li></ol><p><img width="723" height="344" referrerpolicy="no-referrer" src="/img/bVdnb0j" alt="image.png" title="image.png" loading="lazy"/></p><ol start="2"><li>选择快速设置功能，在 快速设置功能的设置页面上，修改域名。在虚拟私有云(<strong>VPC</strong>) 中请选择有私有子网存在的VPC，选择三个不同AZ的私有子网，私有子网必须配置 Nat Gateway，否则会影响后续功能使用。其他保持默认值。</li></ol><p><img width="723" height="450" referrerpolicy="no-referrer" src="/img/bVdnb0k" alt="image.png" title="image.png" loading="lazy"/></p><p><img width="723" height="185" referrerpolicy="no-referrer" src="/img/bVdnb0p" alt="image.png" title="image.png" loading="lazy"/></p><ol start="3"><li>Amazon SageMaker Unified Studio 域默认支持 IAM 用户身份验证。在此输入IAM Identity Center中用户电子邮箱地址。</li></ol><p><img width="723" height="224" referrerpolicy="no-referrer" src="/img/bVdnb0m" alt="image.png" title="image.png" loading="lazy"/></p><ol start="4"><li>创建成功后通过url或者“打开统一工作室”按钮登陆Amazon SageMaker Unified Studio。点击后选择 SSO 方式登陆。输入在IAM 身份中心设置的用户名和密码。</li></ol><p><img width="723" height="174" referrerpolicy="no-referrer" src="/img/bVdnb0n" alt="image.png" title="image.png" loading="lazy"/></p><p><img width="723" height="594" referrerpolicy="no-referrer" src="/img/bVdnb0o" alt="image.png" title="image.png" loading="lazy"/></p><h3>创建项目</h3><ol><li>登陆后点击创建项目，在 Amazon SageMaker Unified Studio 中，通过项目汇集人员、数据和工具，使数据用户群体能够协作解决特定的业务用例。</li></ol><p><img width="723" height="517" referrerpolicy="no-referrer" src="/img/bVdnb0v" alt="image.png" title="image.png" loading="lazy"/></p><ol start="2"><li>修改项目名称，选择合适的项目配置文件。项目配置文件是用于创建项目的配置蓝图的集合。蓝图定义了项目成员在处理 Amazon SageMaker 目录中的数据时可以使用哪些亚马逊云科技工具和服务。这里选择的是所有功能，选择后点击继续。</li></ol><p><img width="723" height="739" referrerpolicy="no-referrer" src="/img/bVdnb0w" alt="image.png" title="image.png" loading="lazy"/></p><ol start="3"><li>可以按需更改日志保留期等配置，由于在此场景下已经禁用了glue catalog，可以忽略lakehouse database中的glue database name更改，这里保持默认设置。点击继续。跳转到下一页后再选择 创建项目。创建成功后，您将被重定向到项目主页。</li></ol><p><img width="723" height="812" referrerpolicy="no-referrer" src="/img/bVdnb0x" alt="image.png" title="image.png" loading="lazy"/></p><ol start="4"><li>下一步我们来添加EMR Serverless 计算资源。进入项目后，在左侧概览下选择<strong>compute</strong>，点击<strong>Data processing</strong>，点击 <strong>add compute</strong>。</li></ol><p><img width="723" height="359" referrerpolicy="no-referrer" src="/img/bVdnb0y" alt="image.png" title="image.png" loading="lazy"/></p><ol start="5"><li>您可以选择连接到现有计算资源。如果您为创建资源，可以选择<strong>Create new compute resources</strong>，点击 <strong>next</strong></li></ol><p><img width="723" height="583" referrerpolicy="no-referrer" src="/img/bVdnb0z" alt="image.png" title="image.png" loading="lazy"/></p><ol start="6"><li>关于计算资源种类，我们选择<strong>EMR Serverless</strong> , 点击 <strong>next，</strong> 修改<strong>compute name</strong>，其他保持默认值，点击 <strong>add compute</strong></li></ol><p><img width="723" height="586" referrerpolicy="no-referrer" src="/img/bVdnb0A" alt="image.png" title="image.png" loading="lazy"/></p><p><img width="723" height="595" referrerpolicy="no-referrer" src="/img/bVdnb0B" alt="image.png" title="image.png" loading="lazy"/></p><h3>项目角色权限配置</h3><p>最后我们还需要为项目角色添加权限，使其可以访问Databricks存储在S3的数据。</p><ol><li>我们先在左侧概览下选择<strong>Project overview</strong>，在<strong>Project details</strong>找到<strong>Porject role arn</strong>，从 datazone_user字段开始复制</li></ol><p><img width="723" height="529" referrerpolicy="no-referrer" src="/img/bVdnb0C" alt="image.png" title="image.png" loading="lazy"/></p><ol start="2"><li>进入<strong>IAM</strong>服务控台页面，点击左侧角色，搜索复制的project role，点击查询结果查看角色详情。</li></ol><p><img width="723" height="253" referrerpolicy="no-referrer" src="/img/bVdnb0T" alt="image.png" title="image.png" loading="lazy"/></p><ol start="3"><li>为项目角色创建内联策略。输入以下策略，将<em>amzn-s3-demo-bucket</em>替换成您的存储桶名称</li></ol><p><img width="723" height="149" referrerpolicy="no-referrer" src="/img/bVdnb0V" alt="image.png" title="image.png" loading="lazy"/></p><pre><code>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "S3AdditionalObjectPermissions",
            "Effect": "Allow",
            "Action": [
                "s3:ListBucket",
                "s3:GetBucketLocation",
                "s3:GetObject*",
                "s3:PutObject"
            ],
            "Resource": [
                "arn:aws:s3:::&lt;amzn-s3-demo-bucket&gt;",
                "arn:aws:s3:::&lt;amzn-s3-demo-bucket&gt;/*"
            ]
        }
    ]
}</code></pre><p>至此我们在Sagemaker Unified Studio上的开发环境已经Ready了.</p><h2>EMR Serverless 配置</h2><p>下面我们需要修改 EMR Serverless Application 的配置, 为了保证后面我们在 Sagemaker Unified Studio 中的配置一致,我们需要修改Application的  <strong>Application configuration</strong> 和 <strong>Additional configurations.</strong> 修改的内容如下</p><ol><li><strong>Application configuration</strong></li></ol><pre><code>{
    "runtimeConfiguration": [
        {
            "classification": "spark-defaults",
            "properties": {
                "spark.jars": "/usr/share/aws/delta/lib/delta-spark.jar,/usr/share/aws/delta/lib/delta-storage.jar",
                "spark.jars.packages": "io.unitycatalog:unitycatalog-spark_2.12:0.2.0",
                "spark.sql.extensions": "io.delta.sql.DeltaSparkSessionExtension",
                "spark.sql.defaultCatalog": "&lt;databricks uc&gt;", # 此处修改为上面databricks中grant的UC
                "spark.sql.catalog.spark_catalog": "io.unitycatalog.spark.UCSingleCatalog",
                "spark.sql.catalog.&lt;databricks uc&gt;": "io.unitycatalog.spark.UCSingleCatalog",
                "spark.sql.catalog.&lt;databricks uc&gt;.uri": "https://&lt;databricks workspace url&gt;/api/2.1/unity-catalog"
            }
        }
    ]
}</code></pre><ol start="2"><li>Disable Glue Catalog</li></ol><p><img width="723" height="438" referrerpolicy="no-referrer" src="/img/bVdnb0W" alt="image.png" title="image.png" loading="lazy"/></p><h2>Sagemaker Unified Studio JupyterLab配置</h2><p>下面我们开始配置Sagemaker Unified Studio → JupyterLab, 如下图所示</p><p><img width="723" height="303" referrerpolicy="no-referrer" src="/img/bVdnb03" alt="image.png" title="image.png" loading="lazy"/></p><p>在我们创建Sagemaker Unified Studio的时候,会默认选上Glue Catalog作为Catalog的默认选项,如何我们想在Notebook内使用Databricks Unified Catalog, 我们需要覆盖原有Glue Catalog配置信息,注意下面的catalog信息.</p><pre><code>%%configure -n &lt;EMR serverless application&gt; -f 
{ 
    "conf": { 
        "spark.jars": "/usr/share/aws/delta/lib/delta-spark.jar,/usr/share/aws/delta/lib/delta-storage.jar",
        "spark.jars.packages": "io.unitycatalog:unitycatalog-spark_2.12:0.2.0",
        "spark.sql.extensions": "io.delta.sql.DeltaSparkSessionExtension",
        "spark.sql.defaultCatalog": "&lt;databricks uc&gt;",
        "spark.sql.catalog.spark_catalog": "io.unitycatalog.spark.UCSingleCatalog",
        "spark.sql.catalog.&lt;databricks uc&gt;": "io.unitycatalog.spark.UCSingleCatalog",
        "spark.sql.catalog.&lt;databricks uc&gt;.uri": "https://&lt;databricks workspace url&gt;/api/2.1/unity-catalog",
        "spark.sql.catalog.&lt;databricks uc&gt;.token": "&lt;databricks uc token&gt;"
     }
}</code></pre><p><img width="723" height="139" referrerpolicy="no-referrer" src="/img/bVdnb1a" alt="image.png" title="image.png" loading="lazy"/></p><p>创建Spark session, 下面步骤中一定要注意<strong>Compute</strong>的信息</p><pre><code>from pyspark.sql import SparkSession

spark = SparkSession.builder \
    .appName("EMR Serverless and Databricks Unity Catalog Demo") \
    .getOrCreate()</code></pre><p><img width="723" height="156" referrerpolicy="no-referrer" src="/img/bVdnb1b" alt="image.png" title="image.png" loading="lazy"/></p><p>验证当前的 Spark Context Configuration</p><pre><code># Verify the configuration
essential_configs = [
    'spark.jars.packages', 'spark.executor.instances', 'spark.cores',
    'spark.driver.cores', 'spark.executor.cores', 'spark.memory',
    'spark.driver.memory', 'spark.executor.memory', 'spark.sql.catalog',
    'spark.sql.defaultCatalog', 'spark.master', 'spark.sql.extensions'
]
for item in spark.sparkContext.getConf().getAll():
    if any(config in item[0] for config in essential_configs):
        print(item)</code></pre><p><img width="723" height="236" referrerpolicy="no-referrer" src="/img/bVdnb1c" alt="image.png" title="image.png" loading="lazy"/></p><p>如果想使用emr serverless计算资源，请在每个单元格上方进行选择，左侧选择pyspark，右侧选择创建好的emr serverless资源</p><p><img width="723" height="110" referrerpolicy="no-referrer" src="/img/bVdnb1d" alt="image.png" title="image.png" loading="lazy"/></p><p>查询当前Spark中的catalog List</p><pre><code># Try to use Unity Catalog
spark.sql("SHOW CATALOGS").show()</code></pre><p><img width="723" height="225" referrerpolicy="no-referrer" src="/img/bVdnb1e" alt="image.png" title="image.png" loading="lazy"/></p><p>可以看到此时已经有 sean2 的catalog.</p><p>下面我们查询该catalog下的schema数据.</p><p><code>spark.sql("select * from sean2.myorder.sample_orders limit 1").show()</code></p><p>此时可以看到我们已经可以查询到数据了.</p><p><img width="723" height="276" referrerpolicy="no-referrer" src="/img/bVdnb1f" alt="image.png" title="image.png" loading="lazy"/></p><h2>总结与展望</h2><h3>方案价值回顾</h3><p>通过本文介绍的集成方案，我们成功打通了亚马逊云科技新一代SageMaker与Databricks两大平台的数据通道，实现了真正意义上的统一数据湖仓架构。这不仅是技术层面的集成，更是企业数据战略的重要布局。</p><h4>关键收益总结</h4><ol><li>直接收益：</li></ol><ul><li>开发效率提升：消除重复的ETL开发工作</li><li>数据延迟降低：从批处理ETL到实时查询的转变</li><li>治理成本降低：统一的权限管理和审计体系</li><li>资源利用率提升：EMR Serverless的弹性计算能力</li></ul><ol start="2"><li>战略价值：</li></ol><ul><li>打破组织壁垒：让数据工程师和数据科学家在各自熟悉的平台上协同工作</li><li>加速<strong>AI</strong>落地：从数据洞察到模型部署的端到端流程优化</li><li>降低合规风险：统一的数据治理框架确保合规性</li><li>提升创新能力：释放团队精力专注于业务价值创造</li></ul><ol start="3"><li>适用场景</li></ol><p>本方案特别适合以下场景：</p><ul><li>已有Databricks数据平台，需要扩展ML能力的企业</li><li>需要在亚马逊云科技生态系统中利用Databricks数据资产的团队</li><li>对数据治理有严格要求的游戏、金融、医疗等行业</li><li>追求成本优化的中大型数据团队</li></ul><h3>未来展望</h3><p>随着Unity Catalog生态的不断完善和亚马逊云科技对开放标准的持续支持，我们预见：</p><ol><li>更深度的集成：期待看到新一代SageMaker与Databricks的直接集成，互为数据的生产者与消费者。在数据发现，可读可写和数据治理方面更加无缝</li><li>性能优化：通过缓存、预计算等技术进一步提升查询性能</li><li>智能化治理：基于ML的自动化数据分类和权限推荐</li><li>多云扩展：将这种集成模式扩展到其他云平台</li></ol><h2>参考文档</h2><p><a href="https://link.segmentfault.com/?enc=HHEQ9JXjO%2B1k39It0PiHdg%3D%3D.1TOxqoxNwOHq2KKOF166Di7ehQc639%2BwrDPfXFa2guR6E2LA2UMK61zy4g6DbdgESfrCFhEzMmETwsfyvsK16XGI1%2BqTDP76q0mIze6nQLgkt040BWTGA8yS2mCs8mxWuqZBx%2BALWbf69IgurnMlTzy%2BEz5%2Fi5h%2FvTiOfjsdOtw%3D" rel="nofollow" target="_blank">https://community.databricks.com/t5/technical-blog/how-to-acc...</a></p><p><a href="https://link.segmentfault.com/?enc=0IcK7D1jOtMQcYzF%2B1bnuw%3D%3D.7hPegVo617uuKXM9KBu37qQzJZx31w5HAmjfHOP%2FDfpJOUUNKpltEbmQ4zaBEwpyMoUbth%2FdUMl5xd6BmmjQ2BcL9BCb5gFVIDgRQvZdz5X6OPUDq2aGZViaNxYU%2BA1iGUgPnOnO4iNsC4F%2FV1%2FYlE1oZT%2Foy6zGFs1lc0195SU%3D" rel="nofollow" target="_blank">https://aws.amazon.com/blogs/big-data/run-interactive-workloa...</a></p><p><em>*前述特定亚马逊云科技生成式人工智能相关的服务目前在亚马逊云科技海外区域可用。亚马逊云科技中国区域相关云服务由西云数据和光环新网运营，具体信息以中国区域官网为准。</em></p><p><strong>本篇作者</strong><br/><img width="723" height="531" referrerpolicy="no-referrer" src="/img/bVdnb1n" alt="image.png" title="image.png" loading="lazy"/></p>]]></description></item><item>    <title><![CDATA[RAG系统的随机失败问题排查：LLM的非]]></title>    <link>https://segmentfault.com/a/1190000047442224</link>    <guid>https://segmentfault.com/a/1190000047442224</guid>    <pubDate>2025-12-01 21:01:23</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>RAG教程里说的流程是：分块、嵌入、向量搜索、生成答案。看起来非常简单，按这个思路搭了一套系统，测试没问题就上线了。但是结果出了怪事，经常会随机的失败。</p><p>输入一样，但是输出却不一样，而且这不是偶发，是还有一定的规律，这是怎么回事呢？</p><p>本文将介绍RAG在真实场景下为什么会崩，底层到底有什么坑，以及最后需要如何修改。</p><h2>🚨 现象：测试结果飘忽不定</h2><p>一套端到端的PDF处理管道，专门针对表格密集型文档。比如：财报、研究论文等，这类文档的特点是<strong>关键信息都在结构化表格里</strong>，传统RAG基本处理不好。<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442226" alt="" title=""/></p><p>我用20个测试用例进行测试就开始玄学了：</p><pre><code> 运行1 → 3个失败    
 运行2 → 2个失败    
 运行3 → 0个失败    
 运行4 → 1个失败    
 运行5 → 0个失败</code></pre><p>代码都一样。但是调试的时候每次跑出来结果都不一样？</p><h2>🕵️ 逐层排查</h2><p>为了搞清楚到底哪个环节出了问题，我哦们把每一步的中间状态都dump出来看。</p><p>MongoDB：表格提取正常，数据干净，索引也没问题。</p><p>Qdrant：向量嵌入一致，分块存储正常，语义搜索返回的内容也是相关的。</p><p>LLM的上下文窗口：检查了好几遍，模型每次拿到的context都是对的。</p><p>那么问题就来了：既然上下文没错，为什么模型有时候答对，有时候胡说八道或者漏掉数据？</p><p>那么问题只能是管道本身没坏，问题出自LLM。</p><h2>🔍 三个隐藏的坑</h2><p>经过一天的排查，最后定位到是下面三个问题叠加在一起造成的。</p><p><strong>1、LLM的非确定性</strong></p><p>Ollama温度的默认值大概在0.8左右。也就是说，同样的prompt可能给出不同答案，同样的数据可能产生不同推理，同样的表格也可能被解读出不同结果。</p><p>这导致RAG表面上看是确定性的流程，但实际上根本不是。0.8的温度让边界case变得完全不可预测，所以这一个问题就解释了一半的"随机"失败。</p><p><strong>2、重复的表格数据</strong></p><p>PDF本身就会有一些问题，比如同一张表格：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442227" alt="" title="" loading="lazy"/></p><p>在文档里可能同时存在另一种形态：</p><pre><code> Table data: Phase Requirements 2024-01-15 Review docs […]</code></pre><p>于是LLM同时看到两个版本：一个是结构清晰的表格，一个是被打散成文本块的乱码版本。相同数据、不同格式、互相矛盾。</p><p>模型根本分不清该信哪个，有时从正经表格里提取，有时从噪声文本里提取，有时两边混着来。这是另外一个间歇性bug来源。</p><p><strong>3、Prompt模糊</strong></p><p>最开始写的指令大概是这种风格：</p><blockquote><em>"使用提供的表格。考虑所有行。"</em></blockquote><p>对LLM来说这就是一个建议，碰到边界情况，模型会直接无视第一行、括号里的备注、文档标题、日期列，列表也经常给会你截断。</p><p>叙述性文本用这种模糊指令没太大问题，但结构化数据不行，模糊指令会产生很多的问题。</p><h2>🛠️ 重构方案</h2><p>问题定位清楚之后，解决思路就明确了。</p><p><strong>1、锁死温度参数</strong></p><p>引入固定的温度预设：</p><pre><code> class QueryEngine:  
     TEMPERATURE_DETERMINISTIC = 0.0  # default</code></pre><p>temperature设成0，相同查询就能得到相同输出，测试也变得可以可复现，并且随机性也消失，系统立刻稳定下来。</p><p><strong>2、过滤重复的表格分块</strong></p><p>使用一套启发式规则来识别和剔除那些"看起来像表格"的文本块：检测"Table data:"前缀、统计YYYY-MM-DD日期模式出现次数、货币格式密度、文本和数字交替出现的模式、异常的空白字符分布。</p><p>在embedding之前把这些重复的表格噪声干掉，LLM就只能看到每张表格的唯一正确版本。</p><p><strong>3、把Prompt写成硬性规则</strong></p><p>重写了整个提示词，从"建议"改成"命令"：</p><blockquote>文档标题必须纳入考虑（包含时间上下文）；每张表格的每一行都要读完；被问到提取数据时必须给出<em>全部</em>值；列表项不许跳过；括号里的备注（比如"(extended)"）必须保留。</blockquote><p>这样表格读取错误就没有了</p><h2>💡 最终架构：混合RAG</h2><p>稳定之后的摄取和查询流程长这样：<br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442228" alt="" title="" loading="lazy"/></p><p><em>详细摄取流程如下：</em><br/><img referrerpolicy="no-referrer" src="/img/remote/1460000047442229" alt="" title="" loading="lazy"/></p><p>为什么要混合存储？表格数据需要SQL那种精确匹配能力，文本内容需要语义相似度搜索，两者结合才能把召回率拉到接近完美。</p><p>改完之后：</p><pre><code> 运行1: 20/20    
 运行2: 20/20    
 运行3: 20/20</code></pre><p>稳定、确定、可上线。</p><h2>🎯 总结</h2><p>如果真要给实际业务文档做RAG不是那种demo用的博客文章，基本都会碰上这些问题：表格和文本混在一起、格式乱七八糟、LLM输出不稳定、提取结果模棱两可、检索匹配不准等等。</p><p>但这些都是工程问题，都有工程解法。确定性的LLM配置、靠谱的预处理流程、混合检索架构，三件套配齐，RAG系统就能做到稳定、准确、可以扔到生产环境里跑。</p><p><a href="https://link.segmentfault.com/?enc=6aoUg8U%2BJaVby%2FZy2c1KYg%3D%3D.ASd4aI26lbhUDYzkDJd9Juc3VQAr4g45CsMjiP%2BbUxiW2FYBU%2BuVfBTQwQbLWOJ5eKDLjUvRuG%2B7GZG6NHTZOw%3D%3D" rel="nofollow" target="_blank">https://avoid.overfit.cn/post/c7aab3faef8948b29d54c0068a43abd6</a></p><p>作者：Islam Taha</p>]]></description></item><item>    <title><![CDATA[Mac安装教程Acrobat DC 20]]></title>    <link>https://segmentfault.com/a/1190000047442118</link>    <guid>https://segmentfault.com/a/1190000047442118</guid>    <pubDate>2025-12-01 20:03:21</pubDate>    <description><![CDATA[<link rel="stylesheet" href="https://static.segmentfault.com/main_site_next/prod/_next/static/css/95c21119582c7926.css" data-n-g=""> <p>​准备工作</p><ul><li><strong>安装包下载：</strong><a href="https://link.segmentfault.com/?enc=ZtRU%2F8WL4lAo%2FtEPofv%2Bug%3D%3D.9N4gXxdKTGsviPLpSi4h%2FOkksUD0ByXhLXGyVHinP%2FefzojQNQNu%2FJNqtZ87bw9I" rel="nofollow" title="https://pan.quark.cn/s/2c2336d1e053" target="_blank">https://pan.quark.cn/s/2c2336d1e053</a>，下载好了 <code>Mac Acrobat DC 2021.dmg</code>这个文件，一般就在你电脑的  <strong>“下载”</strong> ​ 文件夹里躺着呢。</li></ul><h3>详细安装步骤</h3><ol><li><p><strong>找到并打开dmg文件</strong></p><ul><li>打开  <strong>“访达(Finder)”</strong> ，进到  <strong>“下载”</strong> ​ 文件夹。</li><li>找到那个 <code>Mac Acrobat DC 2021.dmg</code>文件，<strong>双击它</strong>。这时候会弹出一个新的窗口，里面就是安装相关的东西。</li></ul></li><li><p><strong>理解窗口里的内容</strong></p><ul><li><p>新打开的窗口里，你通常会看到：</p><ul><li>一个写着  <strong>“Install”</strong> ​ 或者  <strong>“安装”</strong> ​ 字样的程序图标（有时候也可能是Acrobat自己的图标）。</li><li>一个箭头，箭头指着旁边一个叫  <strong>“应用程序(Applications)”</strong> ​ 的文件夹图标。</li></ul></li><li>（简单说就是：一个安装程序，要放到“应用程序”里去）</li></ul></li><li><p><strong>关键一步：拖拽安装</strong></p><ul><li><strong>用鼠标点住</strong>​ 那个  <strong>“Install”</strong> （或Acrobat）图标，<strong>按住别松</strong>。</li><li>把它<strong>拖到</strong>​ 旁边那个  <strong>“应用程序(Applications)”</strong> ​ 文件夹图标上。</li><li>看到文件夹高亮了，就<strong>松开鼠标</strong>。</li><li>这一步其实就是把安装程序复制到你的“应用程序”文件夹里，让它成为你电脑上的正式软件。</li></ul></li><li><p><strong>等待复制完成</strong></p><ul><li>松开鼠标后，系统就会开始复制文件，窗口底部通常会有个进度条在跑。<strong>等它跑完</strong>，进度条消失就行。</li></ul></li><li><p><strong>启动软件</strong></p><ul><li>复制完成后，你可以先<strong>关掉</strong>刚才那个dmg文件的窗口（点左上角的红色圆点按钮，或者直接点按窗口左上角的“点按以弹出”）。</li><li>然后去屏幕底部的  <strong>“启动台(Launchpad)”</strong> ​ 里找，或者用 <strong>Spotlight搜索（Command + 空格，然后输入Acrobat）</strong> 。</li><li>找到  <strong>“Adobe Acrobat DC”</strong> ，点击打开就能用了。</li></ul></li></ol><p>​</p>]]></description></item>  </channel></rss>