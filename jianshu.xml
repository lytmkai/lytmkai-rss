<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">  <channel>      <title>简书 - 最新收录</title>      <link>https://www.jianshu.com/techareas/frontend</link>      <description>简书 - 最新收录</description>      <generator>python jianshu.py @Pi20</generator>      <item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/d75cc8b60613</link>    <guid>https://www.jianshu.com/p/d75cc8b60613</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/8faa1cbcf03a</link>    <guid>https://www.jianshu.com/p/8faa1cbcf03a</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/f6fa6759e747</link>    <guid>https://www.jianshu.com/p/f6fa6759e747</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/0f61c6c73bdd</link>    <guid>https://www.jianshu.com/p/0f61c6c73bdd</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/e89ff7bfd5e6</link>    <guid>https://www.jianshu.com/p/e89ff7bfd5e6</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/6914842a0c50</link>    <guid>https://www.jianshu.com/p/6914842a0c50</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/33d2f9201835</link>    <guid>https://www.jianshu.com/p/33d2f9201835</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/777cc491818f</link>    <guid>https://www.jianshu.com/p/777cc491818f</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/4dfdca34f725</link>    <guid>https://www.jianshu.com/p/4dfdca34f725</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/8c63d580dad3</link>    <guid>https://www.jianshu.com/p/8c63d580dad3</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/aaa710cdfcd2</link>    <guid>https://www.jianshu.com/p/aaa710cdfcd2</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/140c677b2d46</link>    <guid>https://www.jianshu.com/p/140c677b2d46</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/07ab44531aab</link>    <guid>https://www.jianshu.com/p/07ab44531aab</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/183d40e267c2</link>    <guid>https://www.jianshu.com/p/183d40e267c2</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/b7ee69f465d9</link>    <guid>https://www.jianshu.com/p/b7ee69f465d9</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/a4809efa041f</link>    <guid>https://www.jianshu.com/p/a4809efa041f</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/3ab117c83d0b</link>    <guid>https://www.jianshu.com/p/3ab117c83d0b</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/84ca2edc80e8</link>    <guid>https://www.jianshu.com/p/84ca2edc80e8</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/f2b8a10e9ee8</link>    <guid>https://www.jianshu.com/p/f2b8a10e9ee8</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/ca4ad11d1f9a</link>    <guid>https://www.jianshu.com/p/ca4ad11d1f9a</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/959df0eb423a</link>    <guid>https://www.jianshu.com/p/959df0eb423a</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/2cac57888886</link>    <guid>https://www.jianshu.com/p/2cac57888886</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/46d376893ee6</link>    <guid>https://www.jianshu.com/p/46d376893ee6</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/5d86f999bf38</link>    <guid>https://www.jianshu.com/p/5d86f999bf38</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/6d49dbef338f</link>    <guid>https://www.jianshu.com/p/6d49dbef338f</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/3bb5fd7640c6</link>    <guid>https://www.jianshu.com/p/3bb5fd7640c6</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/03613e4226b0</link>    <guid>https://www.jianshu.com/p/03613e4226b0</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/569f1a5b8d8a</link>    <guid>https://www.jianshu.com/p/569f1a5b8d8a</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/0c06ebe6dc3b</link>    <guid>https://www.jianshu.com/p/0c06ebe6dc3b</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/3620b4139d1d</link>    <guid>https://www.jianshu.com/p/3620b4139d1d</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/01798530e687</link>    <guid>https://www.jianshu.com/p/01798530e687</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/48b5b7c319ca</link>    <guid>https://www.jianshu.com/p/48b5b7c319ca</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/baec20f2a465</link>    <guid>https://www.jianshu.com/p/baec20f2a465</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/121fa6d68abf</link>    <guid>https://www.jianshu.com/p/121fa6d68abf</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/3e0242a9d5f9</link>    <guid>https://www.jianshu.com/p/3e0242a9d5f9</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/7ab31d365c85</link>    <guid>https://www.jianshu.com/p/7ab31d365c85</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/381fc9d373e7</link>    <guid>https://www.jianshu.com/p/381fc9d373e7</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/6221ba0f2067</link>    <guid>https://www.jianshu.com/p/6221ba0f2067</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/36e8da737a88</link>    <guid>https://www.jianshu.com/p/36e8da737a88</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/9942ec1dfd6c</link>    <guid>https://www.jianshu.com/p/9942ec1dfd6c</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/8b3ef3ad3cc6</link>    <guid>https://www.jianshu.com/p/8b3ef3ad3cc6</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[]]></title>    <link>https://www.jianshu.com/p/6dbb16c02afc</link>    <guid>https://www.jianshu.com/p/6dbb16c02afc</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku"/><article class="_2rhmJa"/><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[Android library native 代码不能调试解决方法汇总]]></title>    <link>https://www.jianshu.com/p/2a83e90738ba</link>    <guid>https://www.jianshu.com/p/2a83e90738ba</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku">Android library native 代码不能调试解决方法汇总</h1><article class="_2rhmJa"><p>android native开发会碰到native代码无法调试问题，而app主工程中的native代码是可以调试的。如果项目中存在多个module，那么在application模块中依赖library模块，并且library模块中有native代码的时候，当debug library模块中的这些native代码时可能会发现断点打不进去。导致这个问题的根本原因是因为即使在运行application模块的debug构建时，其依赖的library模块并不是以debug构建，而是以release构建。</p>
<h3>方法一</h3>
<p>在library模块和application模块中加入忽略strip的正则匹配，如下</p>
<pre><code>android {
    //...
   if (isDebug()) {
        packagingOptions {
            doNotStrip "*/armeabi/*.so"
            doNotStrip "*/armeabi-v7a/*.so"
            doNotStrip "*/arm64-v8a/*.so"
            doNotStrip "*/x86/*.so"
            doNotStrip "*/x86_64/*.so"
            doNotStrip "*/mips/*.so"
            doNotStrip "*/mips64/*.so"
            //...
        }
    }
}
</code></pre>
<p>ibrary模块和application模块中的gradle都需要加入。但是打正式release包的时候是需要剔除so的符号表的，防止so被破解。因此，最好配置一个开关，且这个开关不会被提交到git中去，因此local.properties是最合适的。isDebug方法写在顶层的build.gradle中，这样各个module里边都可以引用。</p>
<pre><code>boolean isDebug() {
    boolean ret = false
    try {
        Properties properties = new Properties()
        File file = project.rootProject.file('local.properties')
        if (!file.exists()) {
            return false
        }
        properties.load(file.newDataInputStream())
        String debugStr = properties.getProperty("debug")
        if (debugStr != null &amp;&amp; debugStr.length() &gt; 0) {
            ret = debugStr.toBoolean()
        }
    } catch (Throwable throwable) {
        throwable.printStackTrace()
        ret = false
    }
    project.logger.error("[${project.name}]Debug:${ret}")
    return ret
}
</code></pre>
<p>然后在local.properties中加入debug=true，修改packagingOptions配置,增加判读逻辑isDebug()。</p>
<p>如果使用上述方式还不行，将主app也添加cmake，包含native代码。gradle参考配置如下：</p>
<pre><code>plugins {
    id 'com.android.application'
}

android {
    compileSdk 32

    defaultConfig {
        applicationId "com.example.app2"
        minSdk 21
        targetSdk 32
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"

        externalNativeBuild {
            cmake {
                arguments '-DANDROID_TOOLCHAIN=clang', '-DANDROID_ARM_MODE=arm', '-DANDROID_STL=c++_static'
                cppFlags "-std=c++11 -frtti -fexceptions"
            }
        }

        ndk {
            abiFilters "arm64-v8a"
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.18.1"
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }

    if(isDebug()){
        packagingOptions {
            doNotStrip "*/armeabi/*.so"
            doNotStrip "*/armeabi-v7a/*.so"
            doNotStrip "*/arm64-v8a/*.so"
            doNotStrip "*/x86/*.so"
            doNotStrip "*/x86_64/*.so"
            doNotStrip "*/mips/*.so"
            doNotStrip "*/mips64/*.so"
            //...
        }
    }

}
</code></pre>
<h3>方法二</h3>
<p>在Run -&gt; Edit Configuration的配置页面，Debugger -&gt; Symbol Directories里面添加第一步生成debug aar的代码目录。</p>
<p><strong>gradle中的task未显示问题：</strong></p>
<p>解决方法： 依次点击：File -&gt; Settings -&gt; Experimental -&gt; 取消勾选 “Do not build Gradle task list during Gradle <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3Dsync%26spm%3D1001.2101.3001.7020" target="_blank">sync</a>”，如下图所示 最后，sync 一下即可。</p>
<p><strong>debug aar的生成：</strong><br/>
</p><div class="image-package">
<div class="image-container" style="max-width: 478px; max-height: 321px;">
<div class="image-container-fill" style="padding-bottom: 67.15%;"/>
<div class="image-view" data-width="478" data-height="321"><img src="https://upload-images.jianshu.io/upload_images/13958217-c790d25c5076f24b.png" data-original-width="478" data-original-height="321" data-original-format="image/png" data-original-filesize="31862"/></div>
</div>
<div class="image-caption">image.png</div>
</div><br/>
点击执行assembleDebug。<br/>
然后配置Symbol Directories中的符号表目录。<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 333px;">
<div class="image-container-fill" style="padding-bottom: 34.22%;"/>
<div class="image-view" data-width="973" data-height="333"><img src="https://upload-images.jianshu.io/upload_images/13958217-85fd2c2d402430ce.png" data-original-width="973" data-original-height="333" data-original-format="image/png" data-original-filesize="50144"/></div>
</div>
<div class="image-caption">image.png</div>
</div><p/>
<h3>方法三</h3>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 441px;">
<div class="image-container-fill" style="padding-bottom: 49.89%;"/>
<div class="image-view" data-width="884" data-height="441"><img src="https://upload-images.jianshu.io/upload_images/13958217-cc43511e4f7e87fe.png" data-original-width="884" data-original-height="441" data-original-format="image/png" data-original-filesize="53167"/></div>
</div>
<div class="image-caption">image.png</div>
</div><br/>
<p>在Project Structure中，对应module的Debuggable和Jni Debuggable置为true。</p>

<h3>参考资料</h3>
<p><a href="https://www.jianshu.com/p/76957970545e/" target="_blank">https://www.jianshu.com/p/76957970545e/</a></p>
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Ffucknmb.com%2F2017%2F05%2F11%2FAndroid-Studio-Library%25E6%25A8%25A1%25E5%259D%2597%25E4%25B8%25ADNative%25E4%25BB%25A3%25E7%25A0%2581%25E8%25BF%259B%25E8%25A1%258Cdebug%25E7%259A%2584%25E4%25B8%2580%25E4%25BA%259B%25E5%259D%2591%2F" target="_blank">https://fucknmb.com/2017/05/11/Android-Studio-Library%E6%A8%A1%E5%9D%97%E4%B8%ADNative%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8Cdebug%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</a></p>
<p><a href="https://www.jianshu.com/p/7f80be68f99b" target="_blank">https://www.jianshu.com/p/7f80be68f99b</a></p>
<p><a href="https://www.jianshu.com/p/76957970545e/" target="_blank">https://www.jianshu.com/p/76957970545e/</a></p>
</article><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[拼接贴图接缝问题的解决方案 烦人的接缝 原因和解决方案 Textrue2DArray 创建资源 Texture2DArray的使用]]></title>    <link>https://www.jianshu.com/p/b315a50968f6</link>    <guid>https://www.jianshu.com/p/b315a50968f6</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku">拼接贴图接缝问题的解决方案</h1><article class="_2rhmJa"><h1>烦人的接缝</h1>
<p>游戏中经常会用到在一个区域平铺某个贴图的需求，比如用碎石铺就的广场，我们通常会根据 顶点/像素 的世界坐标动态的计算UV值，达到贴图密度可调的目的。URP下Shader代码如下:</p>
<pre><code>    float gridScale = 0.5;
    float2 roadUV = abs(frac(input.positionWS * gridScale).xz);
    surfaceData.albedo = SAMPLE_TEXTURE2D(_RoadTex, sampler_RoadTex, roadUV).rgb;
</code></pre>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 413px;">
<div class="image-container-fill" style="padding-bottom: 58.91%;"/>
<div class="image-view" data-width="2020" data-height="1190"><img src="https://upload-images.jianshu.io/upload_images/13524317-229e163e4f487d10.png" data-original-width="2020" data-original-height="1190" data-original-format="image/png" data-original-filesize="1715145"/></div>
</div>
<div class="image-caption">广场</div>
</div><br/>
<p>细心的你一定注意到了，广场整体效果看起来还可以，但是有的地方有接缝的感觉，特别是摄像机移动或者旋转的过程中，尤其明显。（如红色箭头所指的地方）。</p>

<h1>原因和解决方案</h1>
<p>造成这个现象的原因主要由两个，一个是贴图的Mipmap,一个是贴图的过滤方式。我们导入贴图，一般默认是产生Mipmap, 过滤方式默认双线性过滤。<br/>
这种过滤方式会采样距离当前像素最近的四个纹素，然后根据像素到四个纹素点的距离进行插值来确定最终颜色，但是当UV值到达边缘值0或者1的时候，由于边缘像素对应的纹素少了一边或者两边，造成采样到的颜色和中间的像素颜色不一样，从而出现接缝现象。<br/>
Mip map 是根据距离摄像机远近不同，采用不同分辨率的贴图，而确定用哪个级别的贴图，需要用到UV的偏导数，而我们的UV是通过像素的世界坐标frac得到的，会导致偏导数不连续，从而采用了错误的Mipmap等级，使接缝变的更加明显。详见<a href="https://links.jianshu.com/go?to=http%3A%2F%2Foldking.wang%2Fc0f2bc60-dfdd-11e8-8fdc-4de39fa72006%2F" target="_blank">Unity Shader 关于tex2D中 dx dy 的猜想</a><br/>
知道了原因，我们就去修改一下试试效果，选中贴图，把Generate Mip Maps后面的勾选去掉，Filter Mode改成Point.别忘了点击Apply按钮应用设置。<br/>
</p><div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 543px;">
<div class="image-container-fill" style="padding-bottom: 77.46%;"/>
<div class="image-view" data-width="1136" data-height="880"><img src="https://upload-images.jianshu.io/upload_images/13524317-a2c03ec1b4a9d45f.png" data-original-width="1136" data-original-height="880" data-original-format="image/png" data-original-filesize="100234"/></div>
</div>
<div class="image-caption">设置贴图</div>
</div><br/>
再来看看效果:<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 410px;">
<div class="image-container-fill" style="padding-bottom: 58.550000000000004%;"/>
<div class="image-view" data-width="2029" data-height="1188"><img src="https://upload-images.jianshu.io/upload_images/13524317-1fa003ecffc0241e.png" data-original-width="2029" data-original-height="1188" data-original-format="image/png" data-original-filesize="1822833"/></div>
</div>
<div class="image-caption">效果</div>
</div><br/>
仔细观察刚才有接缝的地方，现在果然没有接缝了。<p/>
<blockquote>
<p>"就这样就好了吗？这也太简单了点吧？"</p>
</blockquote>
<p>你的直觉是对的，事情肯定不是这么简单。<br/>
一般我们的地面会有多种材质，比如有石头路面，沙地，草地等等，怎么做呢？一般我们会把几种贴图合成到一张贴图中，类似Atlas,然后根据Mask贴图做混合，具体的可以研究一下<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fcandycat1992.github.io%2F2016%2F11%2F28%2Fblend-terrain-textures%2F" target="_blank">刷地表</a>的功能，这里主要讲接缝，就不展开了，我们为了实验，把两种贴图合成到一块看看会出现什么效果:<br/>
</p><div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 975px;">
<div class="image-container-fill" style="padding-bottom: 139.17%;"/>
<div class="image-view" data-width="1131" data-height="1574"><img src="https://upload-images.jianshu.io/upload_images/13524317-aa18d9cfb77234ef.png" data-original-width="1131" data-original-height="1574" data-original-format="image/png" data-original-filesize="408578"/></div>
</div>
<div class="image-caption">合成图片</div>
</div><br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 411px;">
<div class="image-container-fill" style="padding-bottom: 58.58%;"/>
<div class="image-view" data-width="2016" data-height="1181"><img src="https://upload-images.jianshu.io/upload_images/13524317-6552cf0395a5a0ba.png" data-original-width="2016" data-original-height="1181" data-original-format="image/png" data-original-filesize="1228183"/></div>
</div>
<div class="image-caption">效果</div>
</div><br/>
看起来不错，也没有接缝。以为万事大吉，可是等打包到手机平台，你就会发现还是出现了明显的接缝。<br/>
我分析可能是因为点过滤方式的采样，是取距离像素最近的纹素进行采样，像素落在两张贴图中间的时候(U值0.5的时候)，会采样到另一侧的像素，所以接缝处有点土黄色，所以有一个解决方案是把每个贴图都外扩一定的像素，再合成一张贴图，然后对采样UV做一个clamp.这里就不详细介绍了，感兴趣的同学可以参考: <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fcandycat1992.github.io%2F2016%2F11%2F28%2Fblend-terrain-textures%2F" target="_blank">地形纹理合并</a><p/>
<h1>Textrue2DArray</h1>
<p>今天我们要说的是另一种解决方案： Texture2DArray, 贴图数组，可以把它直接传给Shader，采样的时候可以指定index,然后就像采样单张贴图一样，系统会自动根据FilterMode,WrapMode处理采样中的各种问题,不会出现上面的两张贴图接缝处采样到另一边的问题，处理UV也简单很多。<br/>
详细文档地址: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.unity.cn%2FManual%2Fclass-Texture2DArray.html" target="_blank">Texture2DArray</a><br/>
</p><div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 347px;">
<div class="image-container-fill" style="padding-bottom: 22.24%;"/>
<div class="image-view" data-width="1560" data-height="347"><img src="https://upload-images.jianshu.io/upload_images/13524317-87ed582139d5162c.png" data-original-width="1560" data-original-height="347" data-original-format="image/png" data-original-filesize="69755"/></div>
</div>
<div class="image-caption">支持平台</div>
</div><br/>
可见该技术对平台有一定的要求，可以在运行时通过SystemInfo.supports2DArrayTextures来判断是否支持，不支持的可以按照之前的做法用拼图方式进行处理，不过随着硬件的发展，大部分设备都能够支持了。<p/>
<h1>创建资源</h1>
<p>Texture2DArray没有办法通过Potoshop创建，也没有办法通过Unity Create菜单直接创建，只能通过脚本创建,所以需要写一个工具类，放到Editor文件夹下:</p>
<pre><code class="C#">using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnityEditor;
using UnityEngine;

//创建Texture2DArray

public class TextureArray : EditorWindow
{
    public int PropertyNum = 10;

    public List&lt;Texture2D&gt; textures = new List&lt;Texture2D&gt;();

    [MenuItem("Tools/Texture2DArray")]
    static void Init()
    {   
        TextureArray window = (TextureArray)EditorWindow.GetWindow(typeof(TextureArray), false, "TextureArray", true);
        window.Show();
    }
    

    private float spaceNumber = 10f;

    private void OnGUI()
    {   
        GUILayout.Space(spaceNumber);
        EditorGUILayout.BeginHorizontal();
        GUILayout.FlexibleSpace();
        EditorGUILayout.LabelField("要合成的贴图:", GUILayout.Width(100), GUILayout.Height(30));
        GUILayout.FlexibleSpace();
        EditorGUILayout.EndHorizontal();
        for (int i=0; i&lt;textures.Count; i++)
        {
            EditorGUILayout.BeginHorizontal();
            textures[i] = (Texture2D)EditorGUILayout.ObjectField(textures[i], typeof(Texture2D), true, GUILayout.Width(64), GUILayout.Height(64));
            if (GUILayout.Button("-", GUILayout.Width(30), GUILayout.Height(30)))
            {
                textures.RemoveAt(i);
                i--;
            }
            EditorGUILayout.EndHorizontal();
        }
        

        GUILayout.Space(spaceNumber);
        EditorGUILayout.BeginHorizontal();
        if (GUILayout.Button("+", GUILayout.Height(30)))
        {
            textures.Add(null);
        }
        EditorGUILayout.EndHorizontal();

        GUILayout.Space(spaceNumber);
        EditorGUILayout.BeginHorizontal();
        if (GUILayout.Button("创  建", GUILayout.Height(30)))
        {
            CreateTextureArray();
        }
        EditorGUILayout.EndHorizontal();
    }

    public void CreateTextureArray()
    {
        //如果没有指定要合成的贴图，或者都为空，则直接返回
        textures.RemoveAll(tex =&gt; tex == null);
        if (textures.Count == 0)
        {
            Debug.LogError("Please select textures for combine");
            return;
        }

        Texture2D firstTex = textures[0];

        //Create texture2DArray
        Texture2DArray texture2DArray = new Texture2DArray(firstTex.width,firstTex.height, textures.Count, firstTex.format, false, false);
        // Apply settings
        
        //texture2DArray.filterMode = firstTex.filterMode;
        //texture2DArray.wrapMode = firstTex.wrapMode;

        texture2DArray.filterMode = FilterMode.Point;
        texture2DArray.wrapMode = TextureWrapMode.Clamp;

        int index = 0;
        foreach(Texture2D tex in textures)
        {
            for (int m = 0; m &lt; tex.mipmapCount; m++)
            {
                Graphics.CopyTexture(tex, 0, m, texture2DArray, index, m);
            }
            index++;
        }

        

        //Save 
        string path = EditorUtility.SaveFilePanel("Save As", "Assets", "texArray", "asset");
        if (path.Length &gt; 0)
        {
            path = path.Substring(Application.dataPath.Length - 6);

            AssetDatabase.CreateAsset(texture2DArray, path);
        }
    }
}
</code></pre>
<p>然后Unity菜单中点击 Tools-&gt;Textrue2DArray,会弹出一个窗口，点击加号按钮，把要合成的贴图拖到对应的框内，等把所有要合成到一起的贴图全部处理好，点击合成按钮，选择位置，文件名，就会创建出一个Texture2DArray的资源了。<br/>
这里要注意的是，合成在一起的所有贴图要有一样的大小，格式，Import选项。<br/>
另外由于法线贴图都是线性空间的而不像普通贴图的gamma空间，所以要用这个工具处理法线贴图，请在new texture2DArray的时候，最后一个参数传true（表示线性空间）。最好自己加个参数，给用户选择。</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 459px;">
<div class="image-container-fill" style="padding-bottom: 62.45%;"/>
<div class="image-view" data-width="735" data-height="459"><img src="https://upload-images.jianshu.io/upload_images/13524317-892645d6fc5dda45.png" data-original-width="735" data-original-height="459" data-original-format="image/png" data-original-filesize="59111"/></div>
</div>
<div class="image-caption">创建窗口</div>
</div>
<h1>Texture2DArray的使用</h1>
<p>资源有了，现在就是怎么使用了，给要使用的Shader添加代码:</p>
<pre><code>    Properties
    {
        ...
        _RoadTex("Road texture", 2DArray) = "" {}
     }
    SubShader
    {
      ...
      Pass
      {
         ...
        //声明变量
        TEXTURE2D_ARRAY(_RoadTex);  SAMPLER(sampler_RoadTex);
        ...
        half4 LitPassFragment(Varyings input) : SV_Target 
        {
            int index = 1;  //贴图索引，请根据项目需求自行设置，这里只是演示，固定取索引1
            //计算UV坐标
            float gridScale = 0.25;
            float2 roadUV = abs(frac(input.positionWS * gridScale).xz);
            //采样
            surfaceData.albedo = SAMPLE_TEXTURE2D_ARRAY(_RoadTex, sampler_RoadTex, roadUV, 1).rgb;
            ...
        }
      }
   }
</code></pre>
<p>Shader准备好以后，把刚才创建的Array资源拖到材质面板的Road texture字段处，运行项目，看看效果吧:</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 411px;">
<div class="image-container-fill" style="padding-bottom: 58.699999999999996%;"/>
<div class="image-view" data-width="2024" data-height="1188"><img src="https://upload-images.jianshu.io/upload_images/13524317-692b664d593e2cba.png" data-original-width="2024" data-original-height="1188" data-original-format="image/png" data-original-filesize="1126648"/></div>
</div>
<div class="image-caption">效果</div>
</div><br/>
<p>完全看不到接缝了，打包到手机，同样完美。</p>

<p>感谢您的阅读，如果有什么意见建议欢迎联系我，共同进步。</p>
<hr/>
<p>最后给出项目地址 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fduanoldfive%2FFirstGame%2Freleases%2Ftag%2Ftexture2dArray" target="_blank">接缝项目</a></p>
</article><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[iOS tabbar动画-CYLTabBarController]]></title>    <link>https://www.jianshu.com/p/ad2f13fad836</link>    <guid>https://www.jianshu.com/p/ad2f13fad836</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku">iOS tabbar动画-CYLTabBarController</h1><article class="_2rhmJa"><ul>
<li>GitHub 源码: <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FChenYilong%2FCYLTabBarController" target="_blank">CYLTabBarController</a>
</li>
<li>Star: 6.1k</li>
</ul>
<blockquote>
<p>【中国特色 TabBar】一行代码实现 Lottie 动画 TabBar，支持中间带 + 号的 TabBar 样式，自带红点角标，支持动态刷新。【iOS13 &amp; Dark Mode &amp; iPhone XS MAX supported】。</p>
</blockquote>
<h2>前言</h2>
<p>首先：不仅仅是一行代码！</p>
<p>官方声称的 "一行代码实现 Lottie 动画 TabBar" 其实有虚晃一枪的嫌疑，让你听起来误以为用<strong>一行代码</strong>就可以实现淘宝「闲鱼」那种既带 ➕ 号按钮又带 Lottie 动画的 TabBar 了。其实折腾下来还是要写个几百行代码的。正确的描述应该是：集成 CYLTabBarController 之后，再导入所需的 JSON 文件（该文件用于描述 TabBar 的 Lottie 动画），并添加一行代码，即可让 TabBar 实现 Lottie 动画。</p>
<p>因此，所谓的 "一行代码实现 Lottie 动画”，其实就是配置方法里面再加一个 key 值为 <code>CYLTabBarLottieURL</code> 的属性，它的值是一个 <code>NSURL</code> 链接，指向你项目中描述 Lottie 动画的 JSON 文件。你还是需要自己提前准备好 Lottie 的 JSON 文件的，所以说，所谓的一行代码就是，当涉及到 Lottie 动画时，你给系统传一个带 Lottie 动画的 URL 文件（既然“一行代码”是这个意思的话，我是不是可以说一行代码实现一个全套 Google 搜索引擎功能呢？打开一个 google.com 的 HTML 5 页面不就实现了嘛）。</p>
<p>另外，一看见 <strong>CYLTabBarController</strong> 这个框架是国人写的，而且 README 文档是中文的，真的是喜极而泣😹，让我误以为花个 5 分钟便可以从入门到精通，最终折腾了好几天，下载了好几个 Demo 才算弄明白。</p>
<p>鉴于官方 README.md 文档的“含糊不清”，与配套 Demo 写法上也存在很大的出入，还是让一开始初入了解该框架的同学造成了很大的困扰。</p>
<p>接下来，我会通过实现一个模仿「闲鱼」TabBar 动画的 Demo 来让大家重新了解它。</p>
<h2>开始使用</h2>
<h3>准备：新建 Xcode 项目</h3>
<p>在 Xcode 11 环境下新建一个 <strong>Single View App</strong> 项目，打开这个新的项目，可以看到系统除了会自动生成 <code>AppDelegate</code> 文件外，还会自动生成一个名为 <code>SceneDelegate</code> 的类文件。</p>
<div class="image-package">
<div class="image-container" style="max-width: 268px; max-height: 286px;">
<div class="image-container-fill" style="padding-bottom: 106.72%;"/>
<div class="image-view" data-width="268" data-height="286"><img src="https://upload-images.jianshu.io/upload_images/2648731-96d242f1e9c75fb2.png" data-original-width="268" data-original-height="286" data-original-format="image/png" data-original-filesize="108073"/></div>
</div>
<div class="image-caption">image</div>
</div>
<p>⚠️ <code>SceneDelegate</code> 是 iOS 13 下的新特性，查看 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Fvideos%2Fplay%2Fwwdc2019%2F423%2F" target="_blank">WWDC 2019: Optimizing App Launch</a> 可以知道这到底是啥，但是 <strong>CYLTabBarController</strong> 还未适配该特性（截止 1.28.3 版本），基于 <code>SceneDelegate</code> 集成该框架应用会崩溃！所以我们要先把 <code>SceneDelegate</code> 特性删除才行。</p>
<p>步骤：</p>
<ol>
<li>首先打开 <code>Info.plist</code> 文件，找到下面这两个属性并删除。</li>
</ol>
<div class="image-package">
<div class="image-container" style="max-width: 524px; max-height: 119px;">
<div class="image-container-fill" style="padding-bottom: 22.71%;"/>
<div class="image-view" data-width="524" data-height="119"><img src="https://upload-images.jianshu.io/upload_images/2648731-c42e739b0f6cca40.png" data-original-width="524" data-original-height="119" data-original-format="image/png" data-original-filesize="19207"/></div>
</div>
<div class="image-caption">image</div>
</div>
<ol start="2">
<li>删除 <code>SceneDelegate</code> 类文件，其实可删可不删，但既然我们用不到就删了吧。</li>
<li>修改 <code>AppDelegate.h</code> 文件，加上 <code>UIWindow</code> 属性。</li>
</ol>
<pre><code>#import &lt;UIKit/UIKit.h&gt;

@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;

@property (strong, nonatomic) UIWindow * window;

@end

</code></pre>
<ol start="4">
<li>修改 <code>AppDelegate.m</code> 文件，设置 <code>UIWindow</code> 设置主窗口，并<strong>删除多余的 &lt;UISceneSession&gt; 代理协议</strong>。</li>
</ol>
<pre><code>#import "AppDelegate.h"
#import "ViewController.h"

@interface AppDelegate ()

@end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    // 设置根视图控制器
    ViewController *controller = [[ViewController alloc] init];
    // 窗口根视图控制器
    self.window.rootViewController = controller;
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];

    return YES;
}

// 下面多余的代码请删除

@end

</code></pre>
<p>运行项目，无报错则继续往下。</p>
<h3>第一步：使用 CocoaPods 导入 CYLTabBarController</h3>
<p>可以很良心的说，README.md 文档中在 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FChenYilong%2FCYLTabBarController%23%25E7%25AC%25AC%25E4%25B8%2580%25E6%25AD%25A5%25E4%25BD%25BF%25E7%2594%25A8cocoapods%25E5%25AF%25BC%25E5%2585%25A5cyltabbarcontroller" target="_blank">第一步使用 CocoaPods 导入 CYLTabBarController</a> 一章算是描述地最详尽的了，它居然还教你如何安装 CocoaPods，堪比 CocoaPods 环境搭建教程了。</p>
<p>但是，有一点需要提醒的是，安装 CocoaPods 请勿使用 <code>sudo gem install cocoapods</code> 这个命令，如果运行该命令提示存在权限问题：</p>
<pre><code># 错误示例
$ sudo gem install cocoapods
Password:
Fetching cocoapods-1.8.4.gem
Fetching cocoapods-core-1.8.4.gem
Successfully installed cocoapods-core-1.8.4
ERROR:  While executing gem ... (Gem::FilePermissionError)
    You don't have write permissions for the /usr/bin directory.
# Mac OS 系统升级之后，系统把 /usr/bin 目录的写入权限禁用了，因此我们需要指定安装到别的目录下。

# 正确示例，需要安装 cocoapods 到指定目录下
$ sudo gem install cocoapods -n /usr/local/bin
Successfully installed cocoapods-1.8.4
Parsing documentation for cocoapods-1.8.4
Installing ri documentation for cocoapods-1.8.4
Done installing documentation for cocoapods after 2 seconds
1 gem installed

</code></pre>
<p>另外，Podfile 示例文件如下：</p>
<pre><code># Uncomment the next line to define a global platform for your project
platform :ios, '9.0'

target 'CYLTabBarControllerDemo' do
  # Comment the next line if you don't want to use dynamic frameworks
  # use_frameworks!

  # Pods for CYLTabBarControllerDemo
  pod 'CYLTabBarController', '~&gt; 1.28.3'        # 默认不依赖Lottie
  pod 'CYLTabBarController/Lottie', '~&gt; 1.28.1' # 依赖Lottie库
  pod 'ChameleonFramework'                      # 颜色框架
  pod 'YYKit'                                   # 会用到几个辅助方法

end

</code></pre>
<h3>第二步：新建 AppDelegate 分类文件，初始化并设置 CYLTabBarController</h3>
<p>如果你查看 CYLTabBarController 框架的 README.md 文档，作者会让你把很多配置方法写在 <code>AppDelegate</code> 这个类中。</p>
<p>但实际应用场景中，有很多配置方法都要写在这个文件里面，比如日志框架的配置、推送通知框架、第三方支付回调配置...还有一大堆工具类配置。</p>
<p>所以我习惯上会把不同的配置文件单独写在各自的分类（Category）中。</p>
<p>具体原因可以去看看《Effective Objective-C 2.0 编写高质量 iOS 与 OS X 代码的 52 个有效方法 》一书中的第 24 条建议。</p>
<p>因此，我们需要新建一个 <code>AppDelegate</code> 分类文件，然后把所有与初始化 CYLTabBarController 框架相关的代码都写在 <code>AppDelegate+CYLTabBar</code> 文件里面，保持代码整洁，方便修改。</p>
<ol>
<li>
<p>新建一个 <code>AppDelegate</code> 分类文件。</p>
<p>点击 Xcode 导航栏 — File — New — File...— 选择 iOS Source 列表下的「Objective-C File」，新建文件类型和文件名如下：</p>
<div class="image-package">
<div class="image-container" style="max-width: 442px; max-height: 115px;">
<div class="image-container-fill" style="padding-bottom: 26.02%;"/>
<div class="image-view" data-width="442" data-height="115"><img src="https://upload-images.jianshu.io/upload_images/2648731-8305d743e309068b.png" data-original-width="442" data-original-height="115" data-original-format="image/png" data-original-filesize="11536"/></div>
</div>
<div class="image-caption">image</div>
</div>
</li>
<li><p>在 Assets.xcassets 资产库中导入你所需要的图片文件。</p></li>
<li><p>在分类中新建一个方法，用于配置主窗口：</p></li>
</ol>
<pre><code>#import "AppDelegate.h"

NS_ASSUME_NONNULL_BEGIN

/// 这是 AppDelegate 的分类，用于配置 CYLTabBarController
@interface AppDelegate (CYLTabBar)

/// 配置主窗口
- (void)hql_configureForTabBarController;

@end

NS_ASSUME_NONNULL_END

</code></pre>
<p>然后我们在 .m 文件中实现它，设置 <code>CYLTabBarController</code> 的两个数组：控制器数组和配置 tabBar 外观样式的属性数组：</p>
<pre><code>@implementation AppDelegate (CYLTabBar)

#pragma mark - Public

- (void)hql_configureForTabBarController {
    // 设置主窗口，并设置根视图控制器
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];

    // 初始化 CYLTabBarController 对象
    CYLTabBarController *tabBarController =
        [CYLTabBarController tabBarControllerWithViewControllers:[self viewControllers]
                                           tabBarItemsAttributes:[self tabBarItemsAttributes]];
    // 设置遵守委托协议
    tabBarController.delegate = self;
    // 将 CYLTabBarController 设置为 window 的 RootViewController
    self.window.rootViewController = tabBarController;
}

#pragma mark - Private

/// 控制器数组
- (NSArray *)viewControllers {
    // 首页
    HomeViewController *homeVC = [[HomeViewController alloc] init];
    homeVC.navigationItem.title = @"首页";
    CYLBaseNavigationController *homeNC = [[CYLBaseNavigationController alloc] initWithRootViewController:homeVC];
    [homeNC cyl_setHideNavigationBarSeparator:YES];

    // 同城
    MyCityViewController *myCityVC = [[MyCityViewController alloc] init];
    myCityVC.navigationItem.title = @"同城";
    CYLBaseNavigationController *myCityNC = [[CYLBaseNavigationController alloc] initWithRootViewController:myCityVC];
    [myCityNC cyl_setHideNavigationBarSeparator:YES];

    // 消息
    MessageViewController *messageVC = [[MessageViewController alloc] init];
    messageVC.navigationItem.title = @"消息";
    CYLBaseNavigationController *messageNC = [[CYLBaseNavigationController alloc] initWithRootViewController:messageVC];
    [messageNC cyl_setHideNavigationBarSeparator:YES];

    // 我的
    AccountViewController *accountVC = [[AccountViewController alloc] init];
    accountVC.navigationItem.title = @"我的";
    CYLBaseNavigationController *accountNC = [[CYLBaseNavigationController alloc] initWithRootViewController:accountVC];
    [accountNC cyl_setHideNavigationBarSeparator:YES];

    NSArray *viewControllersArray = @[homeNC, myCityNC, messageNC, accountNC];
    return viewControllersArray;
}

/// tabBar 属性数组
- (NSArray *)tabBarItemsAttributes {
    NSDictionary *homeTabBarItemsAttributes = @{
        CYLTabBarItemTitle: @"首页",
        CYLTabBarItemImage: @"home_normal",
        CYLTabBarItemSelectedImage: @"home_highlight",
    };
    NSDictionary *myCityTabBarItemsAttributes = @{
        CYLTabBarItemTitle: @"同城",
        CYLTabBarItemImage: @"mycity_normal",
        CYLTabBarItemSelectedImage: @"mycity_highlight",
    };
    NSDictionary *messageTabBarItemsAttributes = @{
        CYLTabBarItemTitle: @"消息",
        CYLTabBarItemImage: @"message_normal",
        CYLTabBarItemSelectedImage: @"message_highlight",
    };
    NSDictionary *accountTabBarItemsAttributes = @{
        CYLTabBarItemTitle: @"我的",
        CYLTabBarItemImage: @"account_normal",
        CYLTabBarItemSelectedImage: @"account_highlight",
    };

    NSArray *tabBarItemsAttributes = @[
        homeTabBarItemsAttributes,
        myCityTabBarItemsAttributes,
        messageTabBarItemsAttributes,
        accountTabBarItemsAttributes
    ];
    return tabBarItemsAttributes;
}

@end

</code></pre>
<ol start="4">
<li>最后，我们回到 <code>AppDelegate.m</code> 文件，导入上一步新建的分类头文件 :</li>
</ol>
<pre><code>#import "AppDelegate+CYLTabBar.h"

</code></pre>
<ol start="5">
<li>然后一行代码调用配置主窗口的方法：</li>
</ol>
<pre><code>#import "AppDelegate.h"
#import "AppDelegate+CYLTabBar.h" // 导入的分类文件

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

    // 调用分类文件中的配置主窗口方法：
    [self hql_configureForTabBarController];

    return YES;
}

@end

</code></pre>
<ol start="6">
<li>至此，常见的带 4 个 TabBarItem 的应用框架就搭建好啦：</li>
</ol>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 501px;">
<div class="image-container-fill" style="padding-bottom: 44.529999999999994%;"/>
<div class="image-view" data-width="1125" data-height="501"><img src="https://upload-images.jianshu.io/upload_images/2648731-f190d0fef0b9c364.jpg" data-original-width="1125" data-original-height="501" data-original-format="image/jpeg" data-original-filesize="120141"/></div>
</div>
<div class="image-caption">image</div>
</div>
<p>小结：将 <code>CYLTabBarController</code> 实例化为窗口的根视图控制器即可。</p>
<h3>第三步：添加不规则加号按钮</h3>
<p>创建一个继承自 <code>CYLPlusButton</code> 的子类对象 <code>CYLPlusButtonSubclass</code>。</p>
<h4>
<code>CYLPlusButtonSubclass.h</code> 声明遵守 <code>&lt;CYLPlusButtonSubclassing&gt;</code> 协议</h4>
<pre><code>#import "CYLPlusButton.h"

NS_ASSUME_NONNULL_BEGIN

@interface CYLPlusButtonSubclass : CYLPlusButton &lt;CYLPlusButtonSubclassing&gt;

@end

NS_ASSUME_NONNULL_END

</code></pre>
<h4>
<code>CYLPlusButtonSubclass.m</code> 中实现创建按钮的方法和遵守的协议方法</h4>
<pre><code>#import "CYLPlusButtonSubclass.h"

@implementation CYLPlusButtonSubclass

#pragma mark - Lifecycle

- (instancetype)initWithFrame:(CGRect)frame {
    if (self = [super initWithFrame:frame]) {
        self.titleLabel.textAlignment = NSTextAlignmentCenter;
        self.adjustsImageWhenHighlighted = NO;
    }
    return self;
}

//上下结构的 button
- (void)layoutSubviews {
    [super layoutSubviews];

    // 控件大小,间距大小
    // 注意：一定要根据项目中的图片去调整下面的0.7和0.9，Demo之所以这么设置，因为demo中的 plusButton 的 icon 不是正方形。
    CGFloat const imageViewEdgeWidth   = self.bounds.size.width * 0.7;
    CGFloat const imageViewEdgeHeight  = imageViewEdgeWidth;

    CGFloat const centerOfView    = self.bounds.size.width * 0.5;
    CGFloat const labelLineHeight = self.titleLabel.font.lineHeight;
    CGFloat const verticalMargin  = (self.bounds.size.height - labelLineHeight - imageViewEdgeHeight) * 0.5;

    // imageView 和 titleLabel 中心的 Y 值
    CGFloat const centerOfImageView  = verticalMargin + imageViewEdgeHeight * 0.5;
    CGFloat const centerOfTitleLabel = imageViewEdgeHeight  + verticalMargin * 2 + labelLineHeight * 0.5 - 1;

    //imageView position 位置
    self.imageView.bounds = CGRectMake(0, 0, imageViewEdgeWidth, imageViewEdgeHeight);
    self.imageView.center = CGPointMake(centerOfView, centerOfImageView);

    //title position 位置
    self.titleLabel.bounds = CGRectMake(0, 0, self.bounds.size.width, labelLineHeight);
    self.titleLabel.center = CGPointMake(centerOfView, centerOfTitleLabel);
}

#pragma mark - IBActions

- (void)clickPublish {
    // 如果按钮的作用是触发点击事件，则调用此方法
}

#pragma mark - CYLPlusButtonSubclassing

+ (id)plusButton {
    CYLPlusButtonSubclass *button = [CYLPlusButtonSubclass buttonWithType:UIButtonTypeCustom];
    // 图片尺寸：56*56、67*66、49*48（凸出 15）
    UIImage *normalButtonImage = [UIImage imageNamed:@"post_normal"];
    UIImage *hlightButtonImage = [UIImage imageNamed:@"post_highlight"];
    [button setImage:normalButtonImage forState:UIControlStateNormal];
    [button setImage:hlightButtonImage forState:UIControlStateHighlighted];
    [button setImage:hlightButtonImage forState:UIControlStateSelected];

    // 设置背景图片
//    UIImage *normalButtonBackImage = [UIImage imageNamed:@"tabBar_post_back"];
//    [button setBackgroundImage:normalButtonBackImage forState:UIControlStateNormal];
//    [button setBackgroundImage:normalButtonBackImage forState:UIControlStateSelected];

    // 按钮图片距离上边距增加 5，即向下偏移，按钮图片距离下边距减少 5，即向下偏移。
    //button.imageEdgeInsets = UIEdgeInsetsMake(5, 0, -5, 0);
    [button setTitle:@"发布" forState:UIControlStateNormal];
    [button setTitleColor:[UIColor grayColor] forState:UIControlStateNormal];

    button.titleLabel.font = [UIFont systemFontOfSize:10 weight:UIFontWeightBold];
    [button sizeToFit]; // or set frame in this way `button.frame = CGRectMake(0.0, 0.0, 250, 100);`

    //自定义宽度
    button.frame = CGRectMake(0.0, 0.0, 59, 59);
    // button.backgroundColor = [UIColor redColor];

    // if you use `+plusChildViewController` , do not addTarget to plusButton.
    // [button addTarget:button action:@selector(clickPublish) forControlEvents:UIControlEventTouchUpInside];
    return button;
}

// 用来自定义加号按钮的位置，如果不实现默认居中。
+ (NSUInteger)indexOfPlusButtonInTabBar {
    return 2;
}

// 实现该方法后，能让 PlusButton 的点击效果与跟点击其他 TabBar 按钮效果一样，跳转到该方法指定的 UIViewController
+ (UIViewController *)plusChildViewController {

    UIViewController *v = [[UIViewController alloc] init];
    return v;
}

// 该方法是为了调整 PlusButton 中心点Y轴方向的位置，建议在按钮超出了 tabbar 的边界时实现该方法。
// 返回值是自定义按钮中心点 Y 轴方向的坐标除以 tabbar 的高度，小于 0.5 表示 PlusButton 偏上，大于 0.5 则表示偏下。
// PlusButtonCenterY = multiplierOfTabBarHeight * tabBarHeight + constantOfPlusButtonCenterYOffset;
+ (CGFloat)multiplierOfTabBarHeight:(CGFloat)tabBarHeight {
    return  0.3;
}

// constantOfPlusButtonCenterYOffset 大于 0 会向下偏移，小于 0 会向上偏移。
+ (CGFloat)constantOfPlusButtonCenterYOffsetForTabBarHeight:(CGFloat)tabBarHeight {
    return (CYL_IS_IPHONE_X ? - 6 : 4);
}

@end

</code></pre>
<h4>在 <code>AppDelegate+CYLTabBar.m</code> 中注册该按钮</h4>
<p>在初始化 <code>CYLTabBarController</code> 对象步骤之前注册按钮：</p>
<pre><code>- (void)hql_configureForTabBarController {
    // 设置主窗口，并设置根视图控制器
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];

    // 💡💡💡 注册加号按钮
    [CYLPlusButtonSubclass registerPlusButton];

    // 初始化 CYLTabBarController 对象
    CYLTabBarController *tabBarController =
        [CYLTabBarController tabBarControllerWithViewControllers:[self viewControllers]
                                           tabBarItemsAttributes:[self tabBarItemsAttributes]];
    // 设置遵守委托协议
    tabBarController.delegate = self;
    self.window.rootViewController = tabBarController;
}

</code></pre>
<p>自此，加号按钮也添加完成啦。</p>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 378px;">
<div class="image-container-fill" style="padding-bottom: 33.6%;"/>
<div class="image-view" data-width="1125" data-height="378"><img src="https://upload-images.jianshu.io/upload_images/2648731-b001656d5b36994f.jpg" data-original-width="1125" data-original-height="378" data-original-format="image/jpeg" data-original-filesize="121559"/></div>
</div>
<div class="image-caption">image</div>
</div>
<h3>第四步：设置自定义 TabBar 样式</h3>
<p>自定义 TabBar 字体、背景、阴影。</p>
<p>在 <code>AppDelegate+CYLTabBar.m</code> 文件中新增一个方法，用于设置 TabBar 样式：</p>
<pre><code>/// 自定义 TabBar 字体、背景、阴影
- (void)customizeTabBarInterface {
    // 设置文字属性
    if (@available(iOS 10.0, *)) {
        [self cyl_tabBarController].tabBar.unselectedItemTintColor = [UIColor cyl_systemGrayColor];
        [self cyl_tabBarController].tabBar.tintColor = [UIColor cyl_labelColor];
    } else {
        UITabBarItem *tabBar = [UITabBarItem appearance];
        // 普通状态下的文字属性
        [tabBar setTitleTextAttributes:@{NSForegroundColorAttributeName: [UIColor cyl_systemGrayColor]}
                              forState:UIControlStateNormal];
        // 选中状态下的文字属性
        [tabBar setTitleTextAttributes:@{NSForegroundColorAttributeName: [UIColor cyl_labelColor]}
                              forState:UIControlStateSelected];
    }

    // 设置 TabBar 背景颜色：白色
    // 💡[UIImage imageWithColor] 表示根据指定颜色生成图片，该方法来自 &lt;YYKit&gt; 框架
    [[UITabBar appearance] setBackgroundImage:[UIImage imageWithColor:[UIColor whiteColor]]];

    // 去除 TabBar 自带的顶部阴影
    [[self cyl_tabBarController] hideTabBarShadowImageView];

    // 设置 TabBar 阴影，无效
    // [[UITabBar appearance] setShadowImage:[UIImage imageNamed:@"tabBar_background_shadow"]];

    // 设置 TabBar 阴影
    CYLTabBarController *tabBarController = [self cyl_tabBarController];
    tabBarController.tabBar.layer.shadowColor = [UIColor blackColor].CGColor;
    tabBarController.tabBar.layer.shadowRadius = 15.0;
    tabBarController.tabBar.layer.shadowOpacity = 0.2;
    tabBarController.tabBar.layer.shadowOffset = CGSizeMake(0, 3);
    tabBarController.tabBar.layer.masksToBounds = NO;
    tabBarController.tabBar.clipsToBounds = NO;
}

</code></pre>
<p>然后在该文件的配置方法中调用：</p>
<pre><code>- (void)hql_configureForTabBarController {
    // 设置主窗口，并设置根视图控制器
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    self.window.backgroundColor = [UIColor whiteColor];
    [self.window makeKeyAndVisible];

    // 注册加号按钮
    [CYLPlusButtonSubclass registerPlusButton];

    // 初始化 CYLTabBarController 对象
    CYLTabBarController *tabBarController =
        [CYLTabBarController tabBarControllerWithViewControllers:[self viewControllers]
                                           tabBarItemsAttributes:[self tabBarItemsAttributes]];
    // 设置遵守委托协议
    tabBarController.delegate = self;
    self.window.rootViewController = tabBarController;

    // 💡💡💡 自定义 TabBar 字体、背景、阴影
     [self customizeTabBarInterface];
}

</code></pre>
<p>另外，不规则加号按钮的背景图片需要在 <code>CYLPlusButtonSubclass.m</code> 文件的 <code>+ (id)plusButton</code> 中设置：</p>
<pre><code>// 设置背景图片
UIImage *normalButtonBackImage = [UIImage imageNamed:@"tabBar_post_back"];
[button setBackgroundImage:normalButtonBackImage forState:UIControlStateNormal];
[button setBackgroundImage:normalButtonBackImage forState:UIControlStateSelected];

</code></pre>
<p>下面是自定义后的 TabBar 样式示例：</p>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 388px;">
<div class="image-container-fill" style="padding-bottom: 34.489999999999995%;"/>
<div class="image-view" data-width="1125" data-height="388"><img src="https://upload-images.jianshu.io/upload_images/2648731-3fe681eb822e9f7b.jpg" data-original-width="1125" data-original-height="388" data-original-format="image/jpeg" data-original-filesize="62117"/></div>
</div>
<div class="image-caption">image</div>
</div>
<h3>第五步：添加点击旋转动画</h3>
<p>当点击 TabBarItem 时，为它设置旋转动画，需要让 AppDelegate 遵守 <code>&lt;CYLTabBarControllerDelegate, UITabBarControllerDelegate&gt;</code> 委托协议，以监听点击触发事件：</p>
<pre><code>// 💡💡💡 声明遵守委托协议
@interface AppDelegate () &lt;CYLTabBarControllerDelegate, UITabBarControllerDelegate&gt;

@end

@implementation AppDelegate (CYLTabBar)

- (void)hql_configureForTabBarController {

        // 省略...

    // 初始化 CYLTabBarController 对象
    CYLTabBarController *tabBarController =
        [CYLTabBarController tabBarControllerWithViewControllers:[self viewControllers]
                                           tabBarItemsAttributes:[self tabBarItemsAttributes]];
    // 💡💡💡 设置让 AppDelegate 遵守委托协议
    tabBarController.delegate = self;
    self.window.rootViewController = tabBarController;
}

</code></pre>
<p>接下来是让 AppDelegate 实现委托协议方法，点击 TabBarItem 时触发旋转动画，点不规则加号按钮时触发放大动画：</p>
<pre><code>- (BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController {
    // 确保 PlusButton 的选中状态
    [[self cyl_tabBarController] updateSelectionStatusIfNeededForTabBarController:tabBarController shouldSelectViewController:viewController];
    return YES;
}

- (void)tabBarController:(UITabBarController *)tabBarController didSelectControl:(UIControl *)control {
    UIView *animationView;
    NSLog(@"🔴\n 类名与方法名：%@，\n 第 %@ 行，\n description : %@，\n tabBarChildViewControllerIndex: %@， tabBarItemVisibleIndex : %@", @(__PRETTY_FUNCTION__), @(__LINE__), control, @(control.cyl_tabBarChildViewControllerIndex), @(control.cyl_tabBarItemVisibleIndex));

    // 即使 PlusButton 也添加了点击事件，点击 PlusButton 后也会触发该代理方法。
    if ([control cyl_isPlusButton]) {
        UIButton *button = CYLExternPlusButton;
        animationView = button.imageView;
        // 为加号按钮添加「缩放动画」
        [self addScaleAnimationOnView:animationView repeatCount:1];
    } else if ([control isKindOfClass:NSClassFromString(@"UITabBarButton")]) {
        for (UIView *subView in control.subviews) {
            if ([subView isKindOfClass:NSClassFromString(@"UITabBarSwappableImageView")]) {
                animationView = subView;
                // 为其他按钮添加「旋转动画」
                [self addRotateAnimationOnView:animationView];
            }
        }
    }
}

/// 缩放动画
- (void)addScaleAnimationOnView:(UIView *)animationView repeatCount:(float)repeatCount {
    //需要实现的帧动画，这里根据需求自定义
    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @"transform.scale";
     animation.values = @[@1.0,@1.3,@0.9,@1.15,@0.95,@1.02,@1.0];
    animation.duration = 0.5;
    animation.repeatCount = repeatCount;
    animation.calculationMode = kCAAnimationCubic;
    [animationView.layer addAnimation:animation forKey:nil];
}

/// 旋转动画
- (void)addRotateAnimationOnView:(UIView *)animationView {
   [UIView animateWithDuration:0.32 delay:0 options:UIViewAnimationOptionCurveEaseIn animations:^{
       animationView.layer.transform = CATransform3DMakeRotation(M_PI, 0, 1, 0);
   } completion:nil];

   dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
       [UIView animateWithDuration:0.70 delay:0 usingSpringWithDamping:1 initialSpringVelocity:0.2 options:UIViewAnimationOptionCurveEaseOut animations:^{
           animationView.layer.transform = CATransform3DMakeRotation(2 * M_PI, 0, 1, 0);
       } completion:nil];
   });
}

</code></pre>
<p>实现效果：</p>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 432px;">
<div class="image-container-fill" style="padding-bottom: 48.43%;"/>
<div class="image-view" data-width="892" data-height="432"><img src="https://upload-images.jianshu.io/upload_images/2648731-339621d58978d7e3.gif" data-original-width="892" data-original-height="432" data-original-format="image/gif" data-original-filesize="143860"/></div>
</div>
<div class="image-caption">image</div>
</div>
<h3>第六步：添加 Lottie 动画</h3>
<p>参考：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FChenYilong%2FCYLTabBarController%2Fissues%2F341" target="_blank">https://github.com/ChenYilong/CYLTabBarController/issues/341</a></p>
<p>首先，为方便演示，我们从官方 Demo 中获取 Lottie 动画的 JSON 文件和相关资源文件。</p>
<div class="image-package">
<div class="image-container" style="max-width: 470px; max-height: 598px;">
<div class="image-container-fill" style="padding-bottom: 127.23%;"/>
<div class="image-view" data-width="470" data-height="598"><img src="https://upload-images.jianshu.io/upload_images/2648731-4e7c5b6c952d63e4.png" data-original-width="470" data-original-height="598" data-original-format="image/png" data-original-filesize="45606"/></div>
</div>
<div class="image-caption">image</div>
</div>
<p>然后，修改配置 tabBar 属性数组的方法 <code>- (NSArray *)tabBarItemsAttributes</code>，把 Lottie 文件的 URL 路径加上：</p>
<pre><code>/*
 * tabBar 属性数组，带 Loggie 动画
 * 参考：&lt;https://github.com/ChenYilong/CYLTabBarController/issues/341&gt;
 *
 * 与上面的配置相比，需要再多设置两个属性：
 *   CYLTabBarLottieURL: 传入 lottie 动画 JSON 文件所在路径
 *   CYLTabBarLottieSize: LottieView 大小，选填
 *
 */
- (NSArray *)tabBarItemsAttributes {
    NSDictionary *homeTabBarItemsAttributes = @{
        CYLTabBarItemTitle: @"首页",
        CYLTabBarLottieURL : [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@"tab_home_animate" ofType:@"json"]],
        CYLTabBarLottieSize: [NSValue valueWithCGSize:CGSizeMake(33, 33)],
    };
    NSDictionary *myCityTabBarItemsAttributes = @{
        CYLTabBarItemTitle: @"同城",
        CYLTabBarLottieURL : [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@"tab_search_animate" ofType:@"json"]],
        CYLTabBarLottieSize: [NSValue valueWithCGSize:CGSizeMake(33, 33)],
    };
    NSDictionary *messageTabBarItemsAttributes = @{
        CYLTabBarItemTitle: @"消息",
        CYLTabBarLottieURL : [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@"tab_message_animate" ofType:@"json"]],
        CYLTabBarLottieSize: [NSValue valueWithCGSize:CGSizeMake(33, 33)],
    };
    NSDictionary *accountTabBarItemsAttributes = @{
        CYLTabBarItemTitle: @"我的",
        CYLTabBarLottieURL : [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@"tab_me_animate" ofType:@"json"]],
        CYLTabBarLottieSize: [NSValue valueWithCGSize:CGSizeMake(33, 33)],
    };

    NSArray *tabBarItemsAttributes = @[
        homeTabBarItemsAttributes,
        myCityTabBarItemsAttributes,
        messageTabBarItemsAttributes,
        accountTabBarItemsAttributes
    ];
    return tabBarItemsAttributes;
}

</code></pre>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 432px;">
<div class="image-container-fill" style="padding-bottom: 48.43%;"/>
<div class="image-view" data-width="892" data-height="432"><img src="https://upload-images.jianshu.io/upload_images/2648731-b225044326301ed4.gif" data-original-width="892" data-original-height="432" data-original-format="image/gif" data-original-filesize="160550"/></div>
</div>
<div class="image-caption">image</div>
</div>
<p>自此，我们通过 CYLTabBarController 框架实现了一个仿「闲鱼」TabBar 动画的应用。</p>
<p>Demo：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FAndy0570%2FiOS-Samples%2Ftree%2Fmaster%2FHQLTableViewDemo" target="_blank">HQLTableViewDemo</a></p>
<p>原文链接：<a href="https://www.jianshu.com/p/50735aa8a9f2" target="_blank">https://www.jianshu.com/p/50735aa8a9f2</a></p>
</article><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[android9.0 硬件加速HWUI经验分享 一.硬件加速初始化 二.资源地图集服务 三. android4.4 hwui 四.DisplayList的构建过程 五.绘制过程介绍]]></title>    <link>https://www.jianshu.com/p/974ef4bbe416</link>    <guid>https://www.jianshu.com/p/974ef4bbe416</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku">android9.0 硬件加速HWUI经验分享</h1><article class="_2rhmJa"><h1>一.硬件加速初始化</h1>
<p>Canvas API用来绘制应用程序的UI元素，在硬件加速渲染环境中，这些Canvas API调用最终会转化为Open GL API调用（转化过程对应用程序来说是透明的）。因此，新的Activity启动的时候初始化好Open GL环境（又称Open GL渲染上下文）尤为重要。<br/>
下面展示下hwui 过程图：</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 271px;">
<div class="image-container-fill" style="padding-bottom: 35.52%;"/>
<div class="image-view" data-width="763" data-height="271"><img src="https://upload-images.jianshu.io/upload_images/12767017-7e32d678420a4011.png" data-original-width="763" data-original-height="271" data-original-format="image/png" data-original-filesize="21236"/></div>
</div>
<div class="image-caption">hwui过程.png</div>
</div><br/>
<p>一个Activity在OpenGL环境中对应一个ANativeWindow，ANativeWindow从SF中dequeueBuffer得到GraphicBuffer之后通过OpenGL绘制完成后queueBuffer到SF进行合成显示。</p>

<blockquote>
<p>1） Open GL渲染上下文只能与一个线程关联，避免多线程冲突，与只能在UI线程中更新UI一个意思，因此，初始化过程任务之一就是要创建一个Render Thread；<br/>
2） 一个Android应用程序可能存在多个Activity组件，当Main Thread向Render Thread发出渲染命令时，Render Thread要知道当前要渲染的窗口是哪个，因此，初始化任务之二就是要告诉Render Thread当前要渲染的窗口是哪个。</p>
</blockquote>
<p>下面就从这2个方面介绍hwui 初始化过程：</p>
<h2>1.RenderThread初始化</h2>
<h3>1.1 java层分析</h3>
<p>从ViewRootImpl的setView函数开始说起。在该函数内部会判断有些不会走hwui，比如：canvas api不支持转换成opengl函数的；还有些不需要hwui绘制的（因为hwui会增加内存开销）。</p>
<pre><code class="java">frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
...
// If the application owns the surface, don't enable hardware acceleration
                if (mSurfaceHolder == null) {
                    // While this is supposed to enable only, it can effectively disable
                    // the acceleration too.
                    enableHardwareAcceleration(attrs);
</code></pre>
<p>SurfaceView是完全由应用程序自己来控制自己的渲染,因此不需要开启硬件加速。</p>
<pre><code class="java">frameworks/base/core/java/android/view/ViewRootImpl.java
private void enableHardwareAcceleration(WindowManager.LayoutParams attrs) {
...
// Don't enable hardware acceleration when the application is in compatibility mode
        if (mTranslator != null) return;
// Try to enable hardware acceleration if requested
        final boolean hardwareAccelerated =
                (attrs.flags &amp; WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED) != 0;

        if (hardwareAccelerated) {
           if (!ThreadedRenderer.isAvailable()) {
                return;
            }

            // Persistent processes (including the system) should not do
            // accelerated rendering on low-end devices.  In that case,
            // sRendererDisabled will be set.  In addition, the system process
            // itself should never do accelerated rendering.  In that case, both
            // sRendererDisabled and sSystemRendererDisabled are set.  When
            // sSystemRendererDisabled is set, PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED
           // can be used by code on the system process to escape that and enable
            // HW accelerated drawing.  (This is basically for the lock screen.)

            final boolean fakeHwAccelerated = (attrs.privateFlags &amp;
                    WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED) != 0;
            final boolean forceHwAccelerated = (attrs.privateFlags &amp;
                    WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED) != 0;

            if (fakeHwAccelerated) {
                // This is exclusively for the preview windows the window manager
                // shows for launching applications, so they will look more like
                // the app being launched.
                mAttachInfo.mHardwareAccelerationRequested = true;
            } else if (!ThreadedRenderer.sRendererDisabled
                    || (ThreadedRenderer.sSystemRendererDisabled &amp;&amp; forceHwAccelerated)) {
...
mAttachInfo.mThreadedRenderer = ThreadedRenderer.create(mContext, translucent,
                        attrs.getTitle().toString());
</code></pre>
<blockquote>
<p>兼容模式下不走hwui；<br/>
硬件需要支持hwui，通过isAvailable体现；<br/>
fakeHwAccelerated（true）代表的是“Starting Window xxx” layer；<br/>
sRendererDisabled（true）代表Persistent进程（一般系统级别的应用可以在Manifest中配置persistent属性），sSystemRendererDisabled &amp;&amp; forceHwAccelerated代表锁屏场景，即当既不是Persistent进程，或者是system进程（其中有很多线程是需要显示UI的，但是这些UI一般都是比较简单的）但是是锁屏场景的话会走hwui。</p>
</blockquote>
<pre><code class="java">    ThreadedRenderer(Context context, boolean translucent, String name) {
      ...
        long rootNodePtr = nCreateRootRenderNode();
        mRootNode = RenderNode.adopt(rootNodePtr);
        mRootNode.setClipToBounds(false);
        mNativeProxy = nCreateProxy(translucent, rootNodePtr);
        nSetName(mNativeProxy, name);
        ProcessInitializer.sInstance.init(context, mNativeProxy);
        loadSystemProperties();
    }
</code></pre>
<p>java层的ThreadedRenderer初始化主要完成native层renderthread线程的创建以及RenderProxy的创建，后者主要用于向renderthread中post消息，具体过程如下：</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 646px;">
<div class="image-container-fill" style="padding-bottom: 92.27%;"/>
<div class="image-view" data-width="1242" data-height="1146"><img src="https://upload-images.jianshu.io/upload_images/12767017-eb7d852cf328f6ba.jpg" data-original-width="1242" data-original-height="1146" data-original-format="image/jpeg" data-original-filesize="193907"/></div>
</div>
<div class="image-caption">ThreadedRenderer.jpg</div>
</div>
<h3>1.2 native层分析</h3>
<p>根据上图，可以发现：此时renderthread线程已经起来了，继续往下分析，在分析之前看下androirdP上新增的WorkQueue，在RenderProxy、RenderThread和CanvasContext之间增加了WorkQueue机制，具体工作原理如下：</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 541px;">
<div class="image-container-fill" style="padding-bottom: 77.16%;"/>
<div class="image-view" data-width="1226" data-height="946"><img src="https://upload-images.jianshu.io/upload_images/12767017-c3fa37c170ea4e01.jpg" data-original-width="1226" data-original-height="946" data-original-format="image/jpeg" data-original-filesize="173692"/></div>
</div>
<div class="image-caption">WorkQueue.jpg</div>
</div>
<blockquote>
<p>RenderThread线程起来后首先会设置线程优先级，然后会初始化一些对象，下面看下initThreadLocals做了哪些初始化动作：</p>
</blockquote>
<pre><code class="C++">299bool RenderThread::threadLoop() {
300    setpriority(PRIO_PROCESS, 0, PRIORITY_DISPLAY);
301    if (gOnStartHook) {
302        gOnStartHook();
303    }
304    initThreadLocals();
305
306    while (true) {
307        waitForWork();
308        processQueue();
309
310        if (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) {
311            drainDisplayEventQueue();
312            mFrameCallbacks.insert(mPendingRegistrationFrameCallbacks.begin(),
313                                   mPendingRegistrationFrameCallbacks.end());
314            mPendingRegistrationFrameCallbacks.clear();
315            requestVsync();
316        }
317
318        if (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) {
319            // TODO: Clean this up. This is working around an issue where a combination
320            // of bad timing and slow drawing can result in dropping a stale vsync
321            // on the floor (correct!) but fails to schedule to listen for the
322            // next vsync (oops), so none of the callbacks are run.
323            requestVsync();
324        }
325    }
326
327    return false;
328}
</code></pre>
<p>在initThreadLocals做了一些animation的动作、初始化EglManager、RenderState、VulkanManager以及CacheManager。<br/>
下面主要分析下initThreadLocals过程，具体如下：</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 520px;">
<div class="image-container-fill" style="padding-bottom: 74.16%;"/>
<div class="image-view" data-width="1010" data-height="749"><img src="https://upload-images.jianshu.io/upload_images/12767017-52d5ebe16ca7dcf6.jpg" data-original-width="1010" data-original-height="749" data-original-format="image/jpeg" data-original-filesize="105485"/></div>
</div>
<div class="image-caption">andorid_9.0_hwui_initThreadLocals.jpg</div>
</div><br/>
<p>1）创建的DisplayEventReceiver用于请求和接收vsync，与Choreographer中提及到的java层DisplayEventReceiver应该是一个用处 -&gt;std::make_unique&lt;DisplayEventReceiver&gt;；<br/>
2）创建的DisplayEventReceiver对象所关联的文件描述符被注册到了Render Thread的消息循环中     -&gt;addFd；<br/>
优点：surfaceflinger分发vsync的时候会借助fd去唤醒renderthread线程，接着调用displayEventReceiverCallback；<br/>
3）紧接着Renderthread::drainDisplayEventQueue去处理vsync： 通过DisplayEventReceiverWrapper对象获取最近一次的vsync时间，&gt;0的话表示有效的vsync，然后将mVsyncRequested置为false，表示上次上传的vsync已经接收到了。接下来看DispatchFrameCallbacks 的task(9.0之前有很多task，如：drawFrameTask等，9.0就没有了，可以简单的理解为WorkQueue替换了TaskQueue)是否已经添加了，如果添加了mFrameCallbackTaskPending就等于true，就不会执行RenderThread::dispatchFrameCallbacks。<br/>
而dispatchFrameCallbacks主要用来干嘛的呢？答：用来显示动画的～</p>

<blockquote>
<p>下面研究下dispatchFrameCallbacks函数</p>
</blockquote>
<p>定义一个指向IFrameCallback的set mPendingRegistrationFrameCallbacks，<br/>
在post的时候向其中插入数据，在pushBack中也向其中插入数据，唯一的不同的会删除“前者”mFrameCallbacks中的callBack，可以把mPendingRegistrationFrameCallbacks理解为“Back Buffer”，mFrameCallbacks理解为“Front Buffer”。在remove的时候删除“前后对象”中的数据，后面会有交换过程分析。</p>
<pre><code class="C++">std::set&lt;IFrameCallback*&gt; mPendingRegistrationFrameCallbacks;
frameworks/base/libs/hwui/renderthread/RenderThread.cpp
330void RenderThread::postFrameCallback(IFrameCallback* callback) {
331    mPendingRegistrationFrameCallbacks.insert(callback);
332}
333
334bool RenderThread::removeFrameCallback(IFrameCallback* callback) {
335    size_t erased;
336    erased = mFrameCallbacks.erase(callback);
337    erased |= mPendingRegistrationFrameCallbacks.erase(callback);
338    return erased;
339}
340
341void RenderThread::pushBackFrameCallback(IFrameCallback* callback) {
342    if (mFrameCallbacks.erase(callback)) {
343        mPendingRegistrationFrameCallbacks.insert(callback);
344    }
345}
</code></pre>
<p>在RenderThread等到有处理的task的时候会处理callback，将mPendingRegistrationFrameCallbacks中的数据全部copy到mFrameCallbacks中去，同时会清空mPendingRegistrationFrameCallbacks中数据。</p>
<pre><code class="C++">310        if (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) {
311            drainDisplayEventQueue();
312            mFrameCallbacks.insert(mPendingRegistrationFrameCallbacks.begin(),
313                                   mPendingRegistrationFrameCallbacks.end());
314            mPendingRegistrationFrameCallbacks.clear();
315            requestVsync();
316        }
</code></pre>
<p>那么mFrameCallbacks作用是什么呢？<br/>
将mFrameCallbacks数据交换到临时变量callbacks中去，如果有数据的话就会取出来调用doFrame，那么mFrameCallbacks中保存的是什么呢？<br/>
搜索发现只有CanvasContext会继承IFrameCallback，那么回到前面看下什么时候post和pushBack的～</p>
<pre><code class="C++">274void RenderThread::dispatchFrameCallbacks() {
275    ATRACE_CALL();
276    mFrameCallbackTaskPending = false;
277
278    std::set&lt;IFrameCallback*&gt; callbacks;
279    mFrameCallbacks.swap(callbacks);
280
281    if (callbacks.size()) {
282        // Assume one of them will probably animate again so preemptively
283        // request the next vsync in case it occurs mid-frame
284        requestVsync();
285        for (std::set&lt;IFrameCallback*&gt;::iterator it = callbacks.begin(); it != callbacks.end();
286             it++) {
287            (*it)-&gt;doFrame();
288        }
289    }
290}
</code></pre>
<p>简单说post进的数据都是借助于CanvasContext：<br/>
在prepareTree的时候会postFrameCallback，上层即Java层注册一个动画类型的Render Node到Render Thread时，一个类型为IFrameCallback的回调接口就会通过RenderThread类的成员函数postFrameCallback；<br/>
在notifyFramePending会调用pushBackFrameCallback，上层的触发处在scheduleTraversals中。</p>
<blockquote>
<p>总结下:<br/>
1）displayEventReceiverCallback主要用于处理动画，将动画的每一帧同步到Vsync信号来显示；<br/>
2）renderthread此处渲染的是下一帧数据，即还未显示的；<br/>
3）在接收到本地的vsync后会做doFrame，然后请求下一个vsync。</p>
</blockquote>
<p>继续往下走：看下RenderProxy还干了什么？<br/>
创建完renderthread后，开始创建CanvasContext，即窗口的画布，后期会分析怎么关联到窗口上，其中主要是确定pipline方式～<br/>
有没有思考过new RenderThread后才会new CanvasContext，那么之前分析会用到CanvasContext，怎么回事呢？</p>
<h2>2.绑定窗口到RenderThread</h2>
<p>一旦Render Thread知道了当前要渲染的窗口，它就将可以将该窗口绑定到Open GL渲染上下文中去，从而使得后面的渲染操作都是针对被绑定的窗口的。</p>
<h3>2.1 java层分析</h3>
<p>上面分析基于ViewRootImpl的setView的基础上，现在开始到了真正的绘制阶段了，即ViewRootImpl的performTraversals函数中，执行measure、layout、draw动作。在绘制之前要获取一个surface，获取成功后再绑定到对应的renderThread线程中去。</p>
<pre><code class="java">frameworks/base/core/java/android/view/ViewRootImpl.java
392    public final Surface mSurface = new Surface();
...
1676    private void performTraversals() {
...
2083                if (!hadSurface) {
2084                    if (mSurface.isValid()) {
...
2092                        newSurface = true;
2093                        mFullRedrawNeeded = true;
2094                        mPreviousTransparentRegion.setEmpty();
2095
2096                        // Only initialize up-front if transparent regions are not
2097                        // requested, otherwise defer to see if the entire window
2098                        // will be transparent
2099                        if (mAttachInfo.mThreadedRenderer != null) {
2100                            try {
2101                                hwInitialized = mAttachInfo.mThreadedRenderer.initialize(
2102                                        mSurface);
...
2301            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
...
2320            performLayout(lp, mWidth, mHeight);
...
2477        if (!cancelDraw &amp;&amp; !newSurface) {
...
2485            performDraw();
</code></pre>
<p>如果这个Surface是新创建的，那么会将该surface(mSurface)通过initialize将它绑定到Render Thread中去，绑定完成后才会做measure、layout、draw的动作。</p>
<h3>2.2 native层分析</h3>
<p>下面主要从C++层分析下绑定窗口的过程：</p>
<pre><code class="C++">frameworks/base/core/jni/android_view_ThreadedRenderer.cpp
689static void android_view_ThreadedRenderer_initialize(JNIEnv* env, jobject clazz,
690        jlong proxyPtr, jobject jsurface) {
691    RenderProxy* proxy = reinterpret_cast&lt;RenderProxy*&gt;(proxyPtr);
692    sp&lt;Surface&gt; surface = android_view_Surface_getSurface(env, jsurface);
693    proxy-&gt;initialize(surface);
694}

frameworks/base/libs/hwui/renderthread/RenderProxy.cpp
85void RenderProxy::initialize(const sp&lt;Surface&gt;&amp; surface) {
86    mRenderThread.queue().post(
87            [ this, surf = surface ]() mutable { mContext-&gt;setSurface(std::move(surf)); });
88}
</code></pre>
<p>直接将上层的surface通过setSurface函数经过workQueue传到CanvasContext中去，成功的话返回true，即拥有了一个新的surface。</p>
<pre><code class="C++">frameworks/base/libs/hwui/renderthread/CanvasContext.cpp
186void CanvasContext::setSurface(sp&lt;Surface&gt;&amp;&amp; surface) {
187    ATRACE_CALL();
188
189    mNativeSurface = std::move(surface);
190
191    ColorMode colorMode = mWideColorGamut ? ColorMode::WideColorGamut : ColorMode::Srgb;
192    bool hasSurface = mRenderPipeline-&gt;setSurface(mNativeSurface.get(), mSwapBehavior, colorMode);
193
194    mFrameNumber = -1;
195
196    if (hasSurface) {
197        mHaveNewSurface = true;
198        mSwapHistory.clear();
</code></pre>
<p>CanvasContext::setSurface有systrace 标签，通过systrace可以看出具体过程来，如下：</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 318px;">
<div class="image-container-fill" style="padding-bottom: 20.44%;"/>
<div class="image-view" data-width="1556" data-height="318"><img src="https://upload-images.jianshu.io/upload_images/12767017-690bce7168c46b6d.png" data-original-width="1556" data-original-height="318" data-original-format="image/png" data-original-filesize="29259"/></div>
</div>
<div class="image-caption">setSurface.png</div>
</div><br/>
<p>再往下到具体的Pipeline去setSurface，这里以默认的Pipeline介绍：<br/>
首先判断EglSurface是否已经存在，如果存在先destroy，然后再去create一个EglSurface，该mEglSurface表示的是一个绘图表面，有了这个mEglSurface之后，当执行Open GL命令的时候，就可以知道这些命令是作用在哪个窗口上的了。</p>

<pre><code class="C++">frameworks/base/libs/hwui/renderthread/OpenGLPipeline.cpp
146bool OpenGLPipeline::setSurface(Surface* surface, SwapBehavior swapBehavior, ColorMode colorMode) {
147    if (mEglSurface != EGL_NO_SURFACE) {
148        mEglManager.destroySurface(mEglSurface);
149        mEglSurface = EGL_NO_SURFACE;
150    }
151
152    if (surface) {
153        const bool wideColorGamut = colorMode == ColorMode::WideColorGamut;
154        mEglSurface = mEglManager.createSurface(surface, wideColorGamut);
155    }
156
157    if (mEglSurface != EGL_NO_SURFACE) {
158        const bool preserveBuffer = (swapBehavior != SwapBehavior::kSwap_discardBuffer);
159        mBufferPreserved = mEglManager.setPreserveBuffer(mEglSurface, preserveBuffer);
160        return true;
161    }
162
163    return false;
164}
</code></pre>
<p>在EglManager中createSurface中首先会调用EglManager::initialize（关键哦～），其中完成EGL的初始化动作（eglGetDisplay、eglInitialize、eglChooseConfig、eglCreateContext、eglCreatePbufferSurface、eglMakeCurrent、eglSwapInterval），在makeCurrent的时候首先看是不是surface没有改变，如果是的话就不需要重新eglMakeCurrent了，此处makeCurrent的是当前的mPBufferSurface。然后才是真正的创建当前surface的eglCreateWindowSurface；最后调用eglSurfaceAttrib。<br/>
在EglManager中setPreserveBuffer如果不是SwapBehavior::Preserved就直接返回false了，目前很多平台应该都是SwapBehavior::BufferAge。<br/>
那么问题来了，前面创建的surface什么时候设置到上下文环境中的呢？<br/>
查看代码发现：<br/>
DrawFrameTask::syncFrameState -&gt; CanvasContext::makeCurrent -&gt;OpenGLPipeline::makeCurrent<br/>
bool haveNewSurface = mEglManager.makeCurrent(mEglSurface, &amp;error); //mEglSurface就是前在setSurface中绑定的surface<br/>
这样的话就绑定到了前面创建的surface了。</p>
<p>继续看下EglManager::makeCurrent发现：<br/>
1）在OpenGLPipeline::onStop、EglManager::destroySurface的时候设定上下文surface为EGL_NO_SURFACE<br/>
2）在EglManager::initialize时候会绑定PBSurface（前面已经介绍了）<br/>
3）在EglManager::beginFrame时候会绑定传入的surface，此处值得深入跟踪下，<br/>
mEglManager.beginFrame(mEglSurface) //mEglSurface就是前在setSurface中绑定的surface<br/>
CanvasContext::draw -&gt;OpenGLPipeline::getFrame -&gt;EglManager::beginFrame-&gt;makeCurrent(surface)<br/>
因此，将当前surface设置到OpenGL渲染上下文中总共做了2次,在syncFrameState做1次，在CanvasContext::draw时做1次。在makeCurrent的实现的地方会判断if (isCurrent(surface)) return false; 也就是说后面1次的makeCurrent可能直接返回false。<br/>
总结下：初始化过程中会通过eglCreateWindowSurface创建上层surface对应的底层surface（EglSurface），makeCurrent当前的PBSurface，然后在syncFrameSate时会makeCurrent之前创建的底层surface（EglSurface），最后在draw的时候同样也会makeCurrent一次，但是直接返回了，没有执行真正的eglMakeCurrent。</p>
<blockquote>
<p>到此，RenderThread线程已经run了，OpenGL、EGL环境也已经准备就绪，上层Surface也已经创建完成并成功绑定到HWUI层pipeline中mEglSurface。</p>
</blockquote>
<h1>二.资源地图集服务</h1>
<p>以下内容描述都是7.0平台上的，androidO上开始已经没有Asset Atlas Service。不清楚androidO上叫什么～有知道的同学回复呀～<br/>
Android启动的时候会预加载一些资源，方便应用的后期快速访问，同时达到共享目的。hwui中做了进一步优化，将预加载资源合成为一个纹理上传到GPU去，并且能够在所有的应用程序之间进行共享。<br/>
资源预加载发生在Zygote进程的，然后Zygote进程fork了应用程序进程，这样就保证了资源的共享，但是在hwui中，如果每个应用都去使用预加载的资源的话，那么每个应用都要将资源作为纹理传入到GPU中，这样太浪费GPU内存了，这块是不是有问题需要优化呢，这就是本节的重点。<br/>
Zygote进程将预加载的资源作为texture传到system进程中去，System进程中运行了一个Asset Atlas Service，该service就是上面提到的将预加载资源合成为一个纹理上传到GPU去。这样的话，app的renderthread线程直接请求Asset Atlas Service得到纹理即可，无需单独上传纹理到GPU。</p>
<h2>1.Zygote</h2>
<blockquote>
<p>加载资源<br/>
启动system_server<br/>
接收AMS的请求创建应用进程</p>
</blockquote>
<p>下面主要分析加载资源环节,preloadClasses、preloadResources、nativePreloadAppProcessHALs、 preloadOpenGL、preloadSharedLibraries、preloadTextResources，主要分析preloadResources。<br/>
而在preloadResources中会分别调用preloadDrawables（对应R.array.preloaded_drawables）和preloadColorStateLists（对应R.array.preloaded_color_state_lists），主要跟踪preloadDrawables。<br/>
mResources.getDrawable加载所有drawable～<br/>
Zygote预加载的Drawable将会被运行在System进程里面的Asset Atlas Service合成一个地图集，最后作为纹理上传到GPU去，因此，接下来我们就继续分析Asset Atlas Service的实现。</p>
<h2>2. system_server</h2>
<p>Zygote进程启动System进程，System进程会加载系统服务，其中就包括Asset Atlas Service。<br/>
在system进程启动服务之前会进行一些属性的设置，在startOtherServices函数中会启动Asset Atlas Service，Asset Atlas Service是一个非系统服务，工厂模式下不会启用。<br/>
注：7.0、7.1还存在AssetAtlasService，到8.0开始就已经取消了～<br/>
AssetAtlasService计算将所有预加载的Drawable资源合成在一张图片中所需要的最小宽度和高度值，有了这两个值之后创建一块Graphic Buffer。然后将Drawable渲染到该Buffer中去。最后上传到GPU中去。</p>
<h1>三. android4.4 hwui</h1>
<p>这边插一章节介绍下旧版本hwui的实现过程，相对比较简单，主要过程如下：</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 309px;">
<div class="image-container-fill" style="padding-bottom: 29.21%;"/>
<div class="image-view" data-width="1058" data-height="309"><img src="https://upload-images.jianshu.io/upload_images/12767017-2632a8f9fdba50e2.png" data-original-width="1058" data-original-height="309" data-original-format="image/png" data-original-filesize="29628"/></div>
</div>
<div class="image-caption">android4.4_setView.png</div>
</div>
<h2>3.1 hardware draw</h2>
<p>下面主要分析下hardware draw过程，引用一个大神的图，关键的几个步骤做简单分析：</p>
<blockquote>
<p>1）beginFrame主要完成EGLDisplay(用于显示) 和一个EGLSurface（OpenGL将在这个Surface上进行绘图），然后eglBeginFrame主要是校验参数的合法性；<br/>
2）buildDisplayList主要完成录制过程，构建native层的DisplayList；<br/>
3）prepareFrame完成dirtyRegion的构建；</p>
</blockquote>
<p>4）onPostDraw会进行OpenGLRenderer的finish过程；<br/>
5）swapBuffer完成对buffer向SurfaceFlinger的递交，注意在java层调用的哦～</p>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 519px;">
<div class="image-container-fill" style="padding-bottom: 74.09%;"/>
<div class="image-view" data-width="1594" data-height="1181"><img src="https://upload-images.jianshu.io/upload_images/12767017-1d89f3906a444613.png" data-original-width="1594" data-original-height="1181" data-original-format="image/png" data-original-filesize="129787"/></div>
</div>
<div class="image-caption">android4.4_draw.png</div>
</div>
<h1>四.DisplayList的构建过程</h1>
<p>在上面初始化过程中会调用performTraversals，然后调用initialize完成初始化过程，之后在performTraversals中会调用performMeasure、performLayout、performDraw，本节主要介绍performDraw过程：</p>
<pre><code class="java">frameworks/base/core/java/android/view/ViewRootImpl.java
private boolean draw(boolean fullRedrawNeeded) {
    ...
    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) {
            if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) {
        ...
         mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this, callback);
    } else {
        ...
        if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,
                        scalingRequired, dirty, surfaceInsets)) {
                    return false;
        }
    ...
}

frameworks/base/core/java/android/view/ThreadedRenderer.java
    void draw(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks) {
        ......
 
        updateRootDisplayList(view, callbacks);
        ......
 
        if (attachInfo.mPendingAnimatingRenderNodes != null) {
            final int count = attachInfo.mPendingAnimatingRenderNodes.size();
            for (int i = 0; i &lt; count; i++) {
                registerAnimatingRenderNode(
                        attachInfo.mPendingAnimatingRenderNodes.get(i));
            }
            attachInfo.mPendingAnimatingRenderNodes.clear();
            // We don't need this anymore as subsequent calls to
            // ViewRootImpl#attachRenderNodeAnimator will go directly to us.
            attachInfo.mPendingAnimatingRenderNodes = null;
        }
        ...
        int syncResult = nSyncAndDrawFrame(mNativeProxy, frameInfo, frameInfo.length);
        if ((syncResult &amp; SYNC_LOST_SURFACE_REWARD_IF_FOUND) != 0) {
            ...
            attachInfo.mViewRootImpl.invalidate();
        }
    }
    ...
}
</code></pre>
<p>下面主要分析updateRootDisplayList：<br/>
可以看到在该函数中存在“Record View#draw()”的trace tag，首先完成updateViewTreeDisplayList，稍后分析；然后判断rootNode是否有更新或者rootNode是否无效。<br/>
那么什么时候isValid为true呢？mRootNode.end结束时候该值会被置为true，详细分析下面会有介绍。</p>
<pre><code class="java">frameworks/base/core/java/android/view/ThreadedRenderer.java 
private void updateRootDisplayList(View view, DrawCallbacks callbacks) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Record View#draw()");
        updateViewTreeDisplayList(view);

        if (mRootNodeNeedsUpdate || !mRootNode.isValid()) {
            DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);
            try {
                final int saveCount = canvas.save();
                canvas.translate(mInsetLeft, mInsetTop);
                callbacks.onPreDraw(canvas);

                canvas.insertReorderBarrier();
                canvas.drawRenderNode(view.updateDisplayListIfDirty());
                canvas.insertInorderBarrier();

                callbacks.onPostDraw(canvas);
                canvas.restoreToCount(saveCount);
                mRootNodeNeedsUpdate = false;
            } finally {
                mRootNode.end(canvas);
            }
        }
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
</code></pre>
<p>mRootNode.isValid值来自于native层，当第一次设置的时候RenderNode中displayList不为空，因此isValid值为true；当renderNode被destroy时该值为false。</p>
<pre><code class="java">frameworks/base/core/java/android/view/RenderNode.java
public void end(DisplayListCanvas canvas) {
    long displayList = canvas.finishRecording();
    nSetDisplayList(mNativeRenderNode, displayList);
    canvas.recycle();
}
frameworks/base/core/jni/android_view_RenderNode.cpp
static void android_view_RenderNode_setDisplayList(JNIEnv* env,
        jobject clazz, jlong renderNodePtr, jlong displayListPtr) {
    RenderNode* renderNode = reinterpret_cast&lt;RenderNode*&gt;(renderNodePtr);
    DisplayList* newData = reinterpret_cast&lt;DisplayList*&gt;(displayListPtr);
    renderNode-&gt;setStagingDisplayList(newData);
}

frameworks/base/libs/hwui/RenderNode.cpp
void RenderNode::destroyHardwareResources(TreeInfo* info) {
    ...
    setStagingDisplayList(nullptr);

frameworks/base/libs/hwui/RenderNode.cpp
void RenderNode::setStagingDisplayList(DisplayList* displayList) {
    mValid = (displayList != nullptr);
    mNeedsDisplayListSync = true;
    delete mStagingDisplayList;
    mStagingDisplayList = displayList;
}
</code></pre>
<p>好了，下面开始分析DisplayList的构建过程中重要的几个环节：</p>
<h2>1.updateViewTreeDisplayList</h2>
<p>view.updateDisplayListIfDirty();</p>
<h2>2.start</h2>
<p>start时候会在native层创建RecordingCanvas、DisplayList，而9.0默认使用skiagl，那么native层就对应SkiaRecordingCanvas、SkiaDisplayList。</p>
<pre><code class="java">frameworks/base/core/java/android/view/RenderNode.java
public DisplayListCanvas start(int width, int height) {
    return DisplayListCanvas.obtain(this, width, height);
}
</code></pre>
<p>接下来是对应的canvas做save操作，在RecordingCanvas逻辑中会创建对应的Snapshot，在skiagl中走的是SkiaCanvas::save，最终会设置到SkCanvas中。<br/>
后面的translate函数和上面的save效果类似。</p>
<h2>3.drawRenderNode</h2>
<p>在drawRenderNode的前后分别insertBarrier目的是创建一个新的chunk，然后向displayList中加入RenderNodeOp，而skiagl中会走SkiaRecordingCanvas::drawRenderNode。</p>
<h2>4.end</h2>
<p>得到native层的DisplayList对象地址displayList，最后将displayList设置到mStagingDisplayList。</p>
<pre><code class="java">frameworks/base/core/java/android/view/RenderNode.java
public void end(DisplayListCanvas canvas) {
        long displayList = canvas.finishRecording();
        nSetDisplayList(mNativeRenderNode, displayList);
        canvas.recycle();
    }
</code></pre>
<h2>5.addOp</h2>
<p>将addOp单独拉出来讲，因为上面drawRenderNode以及在updateViewTreeDisplayList中的drawBitmap都会往DisplayList中写入对应的Op。<br/>
当上层触发drawColor、drawRect等操作时会调用native层的addOp（具体可参见之前博客：<a href="https://www.jianshu.com/writer#/notebooks/29645998/notes/34965214" target="_blank">HWUI绘制系列——从java到C++</a>），传入对应的op参数进来，下面就详细分析下addOp函数，因为该函数为后面渲染做铺垫。<br/>
可以将op理解为一个人，首先判断这个人的rect是否为空，然后得到当前的DisplayList中的ops的last值的索引，将当前的op加到ops中去。<br/>
判断mDeferredBarrierType，研究下该值，初始化的时候该值为DeferredBarrierType::None，当resetRecording时会重置为DeferredBarrierType::InOrder，还有就是在insertReorderBarrier时会进行重新赋值。那么有什么意义呢？</p>
<blockquote>
<p>1）刚初始化renderthread的时候会new RecordingCanvas，这样会resetRecording，表示要重新建一个Chunk了，还有就是进程再次obtain也会强制做resetRecording；<br/>
2） 在updateViewTreeDisplayList结束后，在drawRenderNode前后会分别调用insertReorderBarrier（true）和insertInorderBarrier（false）进行mDeferredBarrierType重置，也就是说drawRenderNode时会新建一个chunk。<br/>
3）大小关系：ops &gt; chunk &gt; children &gt; op</p>
</blockquote>
<pre><code class="C++">frameworks/base/libs/hwui/RecordingCanvas.cpp
int RecordingCanvas::addOp(RecordedOp* op) {
    // skip op with empty clip
    if (op-&gt;localClip &amp;&amp; op-&gt;localClip-&gt;rect.isEmpty()) {
        // NOTE: this rejection happens after op construction/content ref-ing, so content ref'd
        // and held by renderthread isn't affected by clip rejection.
        // Could rewind alloc here if desired, but callers would have to not touch op afterwards.
        return -1;
    }

    int insertIndex = mDisplayList-&gt;ops.size();
    mDisplayList-&gt;ops.push_back(op);
    if (mDeferredBarrierType != DeferredBarrierType::None) {
        // op is first in new chunk
        mDisplayList-&gt;chunks.emplace_back();
        DisplayList::Chunk&amp; newChunk = mDisplayList-&gt;chunks.back();
        newChunk.beginOpIndex = insertIndex;
        newChunk.endOpIndex = insertIndex + 1;
        newChunk.reorderChildren = (mDeferredBarrierType == DeferredBarrierType::OutOfOrder);
        newChunk.reorderClip = mDeferredBarrierClip;

        int nextChildIndex = mDisplayList-&gt;children.size();
        newChunk.beginChildIndex = newChunk.endChildIndex = nextChildIndex;
        mDeferredBarrierType = DeferredBarrierType::None;
    } else {
        // standard case - append to existing chunk
        mDisplayList-&gt;chunks.back().endOpIndex = insertIndex + 1;
    }
    return insertIndex;
}

void RecordingCanvas::insertReorderBarrier(bool enableReorder) {
    if (enableReorder) {
        mDeferredBarrierType = DeferredBarrierType::OutOfOrder;
        mDeferredBarrierClip = getRecordedClip();
    } else {
        mDeferredBarrierType = DeferredBarrierType::InOrder;
        mDeferredBarrierClip = nullptr;
    }
}

frameworks/base/core/java/android/view/DisplayListCanvas.java
    static DisplayListCanvas obtain(@NonNull RenderNode node, int width, int height) {
        if (node == null) throw new IllegalArgumentException("node cannot be null");
        DisplayListCanvas canvas = sPool.acquire();
        if (canvas == null) {
            canvas = new DisplayListCanvas(node, width, height);
        } else {
            nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode,
                    width, height);
        }

frameworks/base/core/java/android/view/ThreadedRenderer.java
    private void updateRootDisplayList(View view, DrawCallbacks callbacks) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Record View#draw()");
        updateViewTreeDisplayList(view);

        if (mRootNodeNeedsUpdate || !mRootNode.isValid()) {
            DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);
            try {
                final int saveCount = canvas.save();
                canvas.translate(mInsetLeft, mInsetTop);
                callbacks.onPreDraw(canvas);

                canvas.insertReorderBarrier();
                canvas.drawRenderNode(view.updateDisplayListIfDirty());
                canvas.insertInorderBarrier();

                callbacks.onPostDraw(canvas);
                canvas.restoreToCount(saveCount);
                mRootNodeNeedsUpdate = false;
            } finally {
                mRootNode.end(canvas);
            }
        }
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
</code></pre>
<h1>五.绘制过程介绍</h1>
<h2>1.syncFrameState</h2>
<p>应用主线程向RT线程的workQueue中post消息并等待消息处理完毕唤醒UI线程，等到RT 执行该消息时会回调run方法，虽然回调了但是不会立刻唤醒UI线程。<br/>
DrawFrameTask中只有两处持锁，下面会分析什么时候会调用unblockUiThread，当unblockUiThread时会唤醒UI线程继续往下执行～<br/>
先剧透下：当syncFrameState完成后会唤醒UI线程，还有就是本次draw完后会唤醒（但是这种情况是不理想的，不应该存在的）～</p>
<pre><code class="C++">frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp
void DrawFrameTask::postAndWait() {
    AutoMutex _lock(mLock);
    mRenderThread-&gt;queue().post([this]() { run(); });
    mSignal.wait(mLock);
}

void DrawFrameTask::unblockUiThread() {
    AutoMutex _lock(mLock);
    mSignal.signal();
}
</code></pre>
<p>下面看下syncFrameState过程：<br/>
1）首先同步当前vsync到TimeLord中的mFrameTimeNanos，即更新上一次的vsync时间；<br/>
2）然后是makeCurrent，当VRI发出setStop的时候会停止makeCurrent，也就停止渲染，否则一直往EglManager去makeCurrent，此处会判断当前的surface是不是已经makeCurrent过了，如果已经makeCurrent了，那么就不去调用eglMakeCurrent，或者没有surface的话会makeCurrent pbSurface。那么看下makeCurrent的位置有哪些？<br/>
a.EglManager::initialize时候makeCurrent(mPBufferSurface)；<br/>
b.EglManager::beginFrame时候makeCurrent(surface)，而beginFrame是在CanvasContext::draw时候调用的；<br/>
c.EglManager::destroySurface时候makeCurrent(EGL_NO_SURFACE)。<br/>
因此，正常情况下在初始化RT时候会OpenGLPipeline::setSurface将当前待渲染的surface设置进来，然后在syncFrameState时候将surface设置为opengl上下文中。<br/>
3）unpinImages主要是为了提高hwui精度的，对每个object做cache，然后让cache去unpin：caches.textureCache.resetMarkInUse(this);前面一步应该也有这个过程；</p>
<pre><code class="C++">frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp
std::vector&lt;sp&lt;DeferredLayerUpdater&gt; &gt; mLayers;
Rect mContentDrawBounds;
bool DrawFrameTask::syncFrameState(TreeInfo&amp; info) {
    ATRACE_CALL();
    int64_t vsync = mFrameInfo[static_cast&lt;int&gt;(FrameInfoIndex::Vsync)];
    mRenderThread-&gt;timeLord().vsyncReceived(vsync);
    bool canDraw = mContext-&gt;makeCurrent();
    mContext-&gt;unpinImages();

    for (size_t i = 0; i &lt; mLayers.size(); i++) {
        mLayers[i]-&gt;apply();
    }
    mLayers.clear();
    mContext-&gt;setContentDrawBounds(mContentDrawBounds);
    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);
    ...
    if (info.out.hasAnimations) {
        if (info.out.requiresUiRedraw) {
            mSyncResult |= SyncResult::UIRedrawRequired;
        }
    }
    if (!info.out.canDrawThisFrame) {
        mSyncResult |= SyncResult::FrameDropped;
    }
    // If prepareTextures is false, we ran out of texture cache space
    return info.prepareTextures;                                       //构造TreeInfo的时候赋值的：true
}
</code></pre>
<p>4）处理layer，在TextureLayer中会将layer借助于ThreadedRenderer传到native层的DrawFrameTask中并用mLayers保存起来。<br/>
是不是很想知道DeferredLayerUpdater类中是否有保存layer的name呢？很可惜没有，只有getWidth()和getHeight() 。</p>
<pre><code class="C++">frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp
void DrawFrameTask::pushLayerUpdate(DeferredLayerUpdater* layer) {
    LOG_ALWAYS_FATAL_IF(!mContext,
                        "Lifecycle violation, there's no context to pushLayerUpdate with!");

    for (size_t i = 0; i &lt; mLayers.size(); i++) {
        if (mLayers[i].get() == layer) {
            return;
        }
    }
    mLayers.push_back(layer);
}

void DrawFrameTask::removeLayerUpdate(DeferredLayerUpdater* layer) {
    for (size_t i = 0; i &lt; mLayers.size(); i++) {
        if (mLayers[i].get() == layer) {
            mLayers.erase(mLayers.begin() + i);
            return;
        }
    }
}

frameworks/base/core/java/android/view/ThreadedRenderer.java
void pushLayerUpdate(TextureLayer layer) {
    nPushLayerUpdate(mNativeProxy, layer.getDeferredLayerUpdater());
}
</code></pre>
<p>5）然后再看下layer的apply过程：<br/>
a.首先mCreateLayerFn创建一个layer，该为函数指针，在pipeline中传入的，那么就会调用OpenGLPipeline的createLayer方法，根据传入的变量去生成纹理（glActiveTexture、glGenTextures）。<br/>
b.在setRenderTarget的时候glBindTexture(target, texture)同时glTexParameteri<br/>
到此，layer纹理也绑定结束了～</p>
<pre><code class="C++">frameworks/base/libs/hwui/DeferredLayerUpdater.cpp
Layer* mLayer;
CreateLayerFn mCreateLayerFn;
void DeferredLayerUpdater::apply() {
    if (!mLayer) {
        mLayer = mCreateLayerFn(mRenderState, mWidth, mHeight, mColorFilter, mAlpha, mMode, mBlend);
    }

    mLayer-&gt;setColorFilter(mColorFilter);
    mLayer-&gt;setAlpha(mAlpha, mMode);

    if (mSurfaceTexture.get()) {
        if (mLayer-&gt;getApi() == Layer::Api::Vulkan) {
            if (mUpdateTexImage) {
                mUpdateTexImage = false;
                doUpdateVkTexImage();
            }
        } else {
            LOG_ALWAYS_FATAL_IF(mLayer-&gt;getApi() != Layer::Api::OpenGL,
                                "apply surfaceTexture with non GL backend %x, GL %x, VK %x",
                                mLayer-&gt;getApi(), Layer::Api::OpenGL, Layer::Api::Vulkan);
            if (!mGLContextAttached) {
                mGLContextAttached = true;
                mUpdateTexImage = true;
                mSurfaceTexture-&gt;attachToContext(static_cast&lt;GlLayer*&gt;(mLayer)-&gt;getTextureId());
            }
            if (mUpdateTexImage) {
                mUpdateTexImage = false;
                doUpdateTexImage();
            }
            GLenum renderTarget = mSurfaceTexture-&gt;getCurrentTextureTarget();
            static_cast&lt;GlLayer*&gt;(mLayer)-&gt;setRenderTarget(renderTarget);
        }
        if (mTransform) {
            mLayer-&gt;getTransform().load(*mTransform);
            setTransform(nullptr);
        }
    }
}

frameworks/base/libs/hwui/renderthread/OpenGLPipeline.cpp
DeferredLayerUpdater* OpenGLPipeline::createTextureLayer() {
    mEglManager.initialize();
    return new DeferredLayerUpdater(mRenderThread.renderState(), createLayer, Layer::Api::OpenGL);
}
static Layer* createLayer(RenderState&amp; renderState, uint32_t layerWidth, uint32_t layerHeight,
                          sk_sp&lt;SkColorFilter&gt; colorFilter, int alpha, SkBlendMode mode,
                          bool blend) {
    GlLayer* layer =
            new GlLayer(renderState, layerWidth, layerHeight, colorFilter, alpha, mode, blend);
    Caches::getInstance().textureState().activateTexture(0);
    layer-&gt;generateTexture();
    return layer;
}

frameworks/base/libs/hwui/renderstate/TextureState.cpp
void TextureState::activateTexture(GLuint textureUnit) {
    LOG_ALWAYS_FATAL_IF(textureUnit &gt;= kTextureUnitsCount,
                        "Tried to use texture unit index %d, only %d exist", textureUnit,
                        kTextureUnitsCount);
    if (mTextureUnit != textureUnit) {
        glActiveTexture(kTextureUnits[textureUnit]);
        mTextureUnit = textureUnit;
    }
}

frameworks/base/libs/hwui/GlLayer.cpp
void GlLayer::generateTexture() {
    if (!texture.mId) {
        glGenTextures(1, &amp;texture.mId);
    }
}
</code></pre>
<p>6）再往下setContentDrawBounds设置绘制区域大小，初始化时mContentDrawBounds(0, 0, 0, 0)，在VRI中updateContentDrawBounds时会设置bounds。</p>
<pre><code class="C++">frameworks/base/libs/hwui/renderthread/CanvasContext.h
void setContentDrawBounds(const Rect&amp; bounds) { mContentDrawBounds = bounds; }

frameworks/base/libs/hwui/renderthread/DrawFrameTask.h
void setContentDrawBounds(int left, int top, int right, int bottom) {
        mContentDrawBounds.set(left, top, right, bottom);
}

frameworks/base/core/java/android/view/ThreadedRenderer.java
public void setContentDrawBounds(int left, int top, int right, int bottom) {
    nSetContentDrawBounds(mNativeProxy, left, top, right, bottom);
}
</code></pre>
<p>7）最后一步就是prepareTree过程了,这一步主要完成每个renderNode的prepareTree过程：</p>
<pre><code class="C++">frameworks/base/libs/hwui/renderthread/CanvasContext.cpp
void CanvasContext::prepareTree(TreeInfo&amp; info, int64_t* uiFrameInfo, int64_t syncQueued,
                                RenderNode* target) {
    mRenderThread.removeFrameCallback(this);
    for (const sp&lt;RenderNode&gt;&amp; node : mRenderNodes) {
        // Only the primary target node will be drawn full - all other nodes would get drawn in
        // real time mode. In case of a window, the primary node is the window content and the other
        // node(s) are non client / filler nodes.
        info.mode = (node.get() == target ? TreeInfo::MODE_FULL : TreeInfo::MODE_RT_ONLY);
        node-&gt;prepareTree(info);
        GL_CHECKPOINT(MODERATE);
    }
    ...
    freePrefetchedLayers();
    ...
    } else {
        info.out.canDrawThisFrame = true;
    }
    ...
}
</code></pre>
<p>a.prepareTree过程，首先看下mRenderNodes是如何构建起来的，在CanvasContext初始化时将rootRenderNode加进来，之后通过addRenderNode加入，通过removeRenderNode移除。</p>
<pre><code class="C++">//加入rootRenderNode
frameworks/base/libs/hwui/renderthread/CanvasContext.cpp
CanvasContext::CanvasContext(...RenderNode* rootRenderNode,...){
    ...
    mRenderNodes.emplace_back(rootRenderNode);
    ...
}
frameworks/base/core/jni/android_view_ThreadedRenderer.cpp
static jlong android_view_ThreadedRenderer_createRootRenderNode(JNIEnv* env, jobject clazz) {
    RootRenderNode* node = new RootRenderNode(env);
    node-&gt;incStrong(0);
    node-&gt;setName("RootRenderNode");
    return reinterpret_cast&lt;jlong&gt;(node);
}

void CanvasContext::addRenderNode(RenderNode* node, bool placeFront) {
    int pos = placeFront ? 0 : static_cast&lt;int&gt;(mRenderNodes.size());
    node-&gt;makeRoot();
    mRenderNodes.emplace(mRenderNodes.begin() + pos, node);
}
void CanvasContext::removeRenderNode(RenderNode* node) {
    node-&gt;clearRoot();
    mRenderNodes.erase(std::remove(mRenderNodes.begin(), mRenderNodes.end(), node),
                       mRenderNodes.end());
}
</code></pre>
<p>在pushStagingDisplayListChanges中调用syncDisplayList，在该函数中取走mStagingDisplayList（mDisplayList = mStagingDisplayList;），该displaylist在setDisplayList中赋值的。<br/>
这样的话displayList就取到了。</p>
<pre><code class="C++">frameworks/base/libs/hwui/RenderNode.cpp
void RenderNode::prepareTreeImpl(TreeObserver&amp; observer, TreeInfo&amp; info, bool functorsNeedLayer) {
    ...
    if (info.mode == TreeInfo::MODE_FULL) {
        pushStagingPropertiesChanges(info);
    }
    ...
    if (info.mode == TreeInfo::MODE_FULL) {
        pushStagingDisplayListChanges(observer, info);
    }
    ...
}
</code></pre>
<p>b.清空mPrefetchedLayers中保存的RenderNode，那么什么时候insert呢？答案：CanvasContext::buildLayer(RenderNode* node)，java层触发。</p>
<pre><code class="C++">frameworks/base/libs/hwui/renderthread/CanvasContext.cpp
std::set&lt;RenderNode*&gt; mPrefetchedLayers;
void CanvasContext::freePrefetchedLayers() {
    if (mPrefetchedLayers.size()) {
        for (auto&amp; node : mPrefetchedLayers) {
            ALOGW("Incorrectly called buildLayer on View: %s, destroying layer...",
                  node-&gt;getName());
            node-&gt;destroyLayers();
            node-&gt;decStrong(nullptr);
        }
        mPrefetchedLayers.clear();
    }
}
</code></pre>
<h2>2.现在看下是draw之前的deferLayers，</h2>
<pre><code class="C++">frameworks/base/libs/hwui/FrameBuilder.cpp
void FrameBuilder::deferLayers(const LayerUpdateQueue&amp; layers) {
    // Render all layers to be updated, in order. Defer in reverse order, so that they'll be
    // updated in the order they're passed in (mLayerBuilders are issued to Renderer in reverse)
    for (int i = layers.entries().size() - 1; i &gt;= 0; i--) {
        RenderNode* layerNode = layers.entries()[i].renderNode.get();
        // only schedule repaint if node still on layer - possible it may have been
        // removed during a dropped frame, but layers may still remain scheduled so
        // as not to lose info on what portion is damaged
        OffscreenBuffer* layer = layerNode-&gt;getLayer();
        if (CC_LIKELY(layer)) {
            ATRACE_FORMAT("Optimize HW Layer DisplayList %s %ux%u", layerNode-&gt;getName(),
                          layerNode-&gt;getWidth(), layerNode-&gt;getHeight());

            Rect layerDamage = layers.entries()[i].damage;
            // TODO: ensure layer damage can't be larger than layer
            layerDamage.doIntersect(0, 0, layer-&gt;viewportWidth, layer-&gt;viewportHeight);
            layerNode-&gt;computeOrdering();

            // map current light center into RenderNode's coordinate space
            Vector3 lightCenter = mCanvasState.currentSnapshot()-&gt;getRelativeLightCenter();
            layer-&gt;inverseTransformInWindow.mapPoint3d(lightCenter);

            saveForLayer(layerNode-&gt;getWidth(), layerNode-&gt;getHeight(), 0, 0, layerDamage,
                         lightCenter, nullptr, layerNode);

            if (layerNode-&gt;getDisplayList()) {
                deferNodeOps(*layerNode);
            }
            restoreForLayer();
        }
    }
}
</code></pre>
<p>1）是不是很想知道传入的参数const LayerUpdateQueue&amp; layers从哪里得到的？很诱人吧，来来来，我们来揭晓下：<br/>
先看下LayerUpdateQueue类，发现它有成员变量mEntries，表示保存所有的layer信息（RenderNode<br/>
和damage）。<br/>
现在来分析下参数的由来，当RenderNode::pushLayerUpdate（最开始是prepareTree）时会传入RenderNode对象和待更新区域dirty，这样赋值给LayerUpdateQueue中的mEntries。</p>
<pre><code class="C++">//LayerUpdateQueue类定义处：
class LayerUpdateQueue {
public:
    struct Entry {
        Entry(RenderNode* renderNode, const Rect&amp; damage)
                : renderNode(renderNode), damage(damage) {}
        sp&lt;RenderNode&gt; renderNode;
        Rect damage;
    };
    LayerUpdateQueue() {}
    void enqueueLayerWithDamage(RenderNode* renderNode, Rect dirty);
    void clear();
    const std::vector&lt;Entry&gt;&amp; entries() const { return mEntries; }
private:
    std::vector&lt;Entry&gt; mEntries;
};
//参数的由来
void RenderNode::pushLayerUpdate(TreeInfo&amp; info) {
    ...
    info.layerUpdateQueue-&gt;enqueueLayerWithDamage(this, dirty);  //有很多RenderNode，但是只有一个info.layerUpdateQueue
    ...
}
frameworks/base/libs/hwui/LayerUpdateQueue.cpp
void LayerUpdateQueue::enqueueLayerWithDamage(RenderNode* renderNode, Rect damage) {
    ...
    if (!damage.isEmpty()) {
        for (Entry&amp; entry : mEntries) {
            if (CC_UNLIKELY(entry.renderNode == renderNode)) {
                entry.damage.unionWith(damage);
                return;
            }
        }
        mEntries.emplace_back(renderNode, damage);
    }
}
</code></pre>
<p>2）再看下renderNode中OffscreenBuffer对象的由来，同样在RenderNode::pushLayerUpdate（最开始是prepareTree）且在1）之前会构建OffscreenBuffer对象，在OpenGLPipeline中创建并通过setLayer设置到renderNode中去，然后deferLayers就可以通过getLayer得到得到RenderNode的成员变量mLayer，下面列举了RenderNode的部分成员变量：</p>
<pre><code class="C++">class RenderNode : public VirtualLightRefBase {
    String8 mName;
    DisplayList* mDisplayList;
    DisplayList* mStagingDisplayList;
    OffscreenBuffer* mLayer = nullptr;
    RenderProperties mProperties;
    RenderProperties mStagingProperties;
}
frameworks/base/libs/hwui/RenderNode.cpp
void RenderNode::pushLayerUpdate(TreeInfo&amp; info) {
    LayerType layerType = properties().effectiveLayerType();   //softlayer不做处理，直接返回
    ...
    if (info.canvasContext.createOrUpdateLayer(this, *info.damageAccumulator, info.errorHandler)) {
        damageSelf(info);
    }

    if (!hasLayer()) {
        return;
    }

    SkRect dirty;
    info.damageAccumulator-&gt;peekAtDirty(&amp;dirty);
    info.layerUpdateQueue-&gt;enqueueLayerWithDamage(this, dirty);     //构建LayerUpdateQueue中的成员变量mEntries

    // There might be prefetched layers that need to be accounted for.
    // That might be us, so tell CanvasContext that this layer is in the
    // tree and should not be destroyed.
    info.canvasContext.markLayerInUse(this);
}
frameworks/base/libs/hwui/renderthread/OpenGLPipeline.cpp
bool OpenGLPipeline::createOrUpdateLayer(RenderNode* node,
                                         const DamageAccumulator&amp; damageAccumulator,
                                         bool wideColorGamut,
                                         ErrorHandler* errorHandler) {
    RenderState&amp; renderState = mRenderThread.renderState();
    OffscreenBufferPool&amp; layerPool = renderState.layerPool();
    bool transformUpdateNeeded = false;
    if (node-&gt;getLayer() == nullptr) {
        node-&gt;setLayer(
                layerPool.get(renderState, node-&gt;getWidth(), node-&gt;getHeight(), wideColorGamut));
        transformUpdateNeeded = true;
    } 
</code></pre>
<p>3）继续往下，对layerDamage做交集处理，保证damage的区域在layer范围内。然后计算每个renderNode的ordering。再继续map 当前的light center到renderNode坐标空间中。<br/>
接下来调用saveForLayer，看起来应该不错，那就看一下呗。<br/>
mCanvasState.save会构建一个SnapShot，然后在writableSnapshot时获取该snapshot，每一个renderNode对应一个snapShot，然后将参数设置到snapshot中去。<br/>
将当前的mLayerBuilders个数加入到mLayerStack中（只有2个值，一个0，一个size），那么是不是想知道mLayerBuilders之前怎么构建出来的呢？<br/>
那么你就来对地方了，看下FrameBuidler的构造函数就知道了，会构建一个fbo0的LayerBuilder。<br/>
继续往下看：<br/>
重新构建一个LayerBuilder，再加入到mLayerBuilders中，那么此时mLayerBuilders就有1个fbo0和N个renderNode对应的LayerBuilder。而mLayerStack对应它们的索引，是不是很神奇呢？</p>
<pre><code class="C++">frameworks/base/libs/hwui/FrameBuilder.cpp
void FrameBuilder::saveForLayer(uint32_t layerWidth, uint32_t layerHeight, float contentTranslateX,
                                float contentTranslateY, const Rect&amp; repaintRect,
                                const Vector3&amp; lightCenter, const BeginLayerOp* beginLayerOp,
                                RenderNode* renderNode) {
    mCanvasState.save(SaveFlags::MatrixClip);
    mCanvasState.writableSnapshot()-&gt;initializeViewport(layerWidth, layerHeight);
    mCanvasState.writableSnapshot()-&gt;roundRectClipState = nullptr;
    mCanvasState.writableSnapshot()-&gt;setRelativeLightCenter(lightCenter);
    mCanvasState.writableSnapshot()-&gt;transform-&gt;loadTranslate(contentTranslateX, contentTranslateY,
                                                              0);
    mCanvasState.writableSnapshot()-&gt;setClip(repaintRect.left, repaintRect.top, repaintRect.right,
                                             repaintRect.bottom);

    // create a new layer repaint, and push its index on the stack
    mLayerStack.push_back(mLayerBuilders.size());
    auto newFbo = mAllocator.create&lt;LayerBuilder&gt;(layerWidth, layerHeight, repaintRect,
                                                  beginLayerOp, renderNode);
    mLayerBuilders.push_back(newFbo);
}
//1.save的过程就是构建一个Snapshot过程：
frameworks/base/libs/hwui/CanvasState.cpp
int CanvasState::save(int flags) {
    return saveSnapshot(flags);
}
int CanvasState::saveSnapshot(int flags) {
    mSnapshot = allocSnapshot(mSnapshot, flags);
    return mSaveCount++;
}
Snapshot* CanvasState::allocSnapshot(Snapshot* previous, int savecount) {
    void* memory;
    if (mSnapshotPool) {
        memory = mSnapshotPool;
        mSnapshotPool = mSnapshotPool-&gt;previous;
        mSnapshotPoolCount--;
    } else {
        memory = malloc(sizeof(Snapshot));
    }
    return new (memory) Snapshot(previous, savecount);
}
frameworks/base/libs/hwui/CanvasState.h
inline Snapshot* writableSnapshot() { return mSnapshot; }

frameworks/base/libs/hwui/FrameBuilder.h
LinearStdAllocator&lt;void*&gt; mStdAllocator;
LinearAllocator mAllocator;
LsaVector&lt;size_t&gt; mLayerStack;
LsaVector&lt;LayerBuilder*&gt; mLayerBuilders;
FrameBuilder::FrameBuilder(const SkRect&amp; clip, uint32_t viewportWidth, uint32_t viewportHeight,
                           const LightGeometry&amp; lightGeometry, Caches&amp; caches)
        : mStdAllocator(mAllocator)
        , mLayerBuilders(mStdAllocator)
        , mLayerStack(mStdAllocator)
        , mCanvasState(*this)
        , mCaches(caches)
        , mLightRadius(lightGeometry.radius)
        , mDrawFbo0(true) {
    // Prepare to defer Fbo0
    auto fbo0 = mAllocator.create&lt;LayerBuilder&gt;(viewportWidth, viewportHeight, Rect(clip));
    mLayerBuilders.push_back(fbo0);
    mLayerStack.push_back(0);
    mCanvasState.initializeSaveStack(viewportWidth, viewportHeight, clip.fLeft, clip.fTop,
                                     clip.fRight, clip.fBottom, lightGeometry.center);
}
//如果FrameBuilder中没有指定viewportWidth、viewportHeight和clip，那么选择1替代：
auto fbo0 = mAllocator.create&lt;LayerBuilder&gt;(1, 1, Rect(1, 1));
</code></pre>
<p>4）接下来看下getDisplayList动作，我们知道在end的时候会将之前创建的DisplayList对象设置到mStagingDisplayList，（具体可参见之前博客：<a href="https://www.jianshu.com/writer#/notebooks/29645998/notes/34965214" target="_blank">HWUI绘制系列——从java到C++</a>），这边得到的就是该displayList对象。</p>
<pre><code class="C++">frameworks/base/libs/hwui/RenderNode.h    
    DisplayList* mDisplayList;
    DisplayList* mStagingDisplayList;
    const DisplayList* getDisplayList() const { return mDisplayList; }

frameworks/base/libs/hwui/RenderNode.cpp
void RenderNode::prepareTreeImpl(TreeObserver&amp; observer, TreeInfo&amp; info, bool functorsNeedLayer) {
    ...
    pushStagingDisplayListChanges(observer, info); 
    ...
    pushLayerUpdate(info);
    ...
}
void RenderNode::pushStagingDisplayListChanges(TreeObserver&amp; observer, TreeInfo&amp; info) {
    if (mNeedsDisplayListSync) {
        mNeedsDisplayListSync = false;
        // Damage with the old display list first then the new one to catch any
        // changes in isRenderable or, in the future, bounds
        damageSelf(info);
        syncDisplayList(observer, &amp;info);
        damageSelf(info);
    }
}
void RenderNode::syncDisplayList(TreeObserver&amp; observer, TreeInfo* info) {
    // Make sure we inc first so that we don't fluctuate between 0 and 1,
    // which would thrash the layer cache
    if (mStagingDisplayList) {
        mStagingDisplayList-&gt;updateChildren([](RenderNode* child) { child-&gt;incParentRefCount(); });
    }
    deleteDisplayList(observer, info);
    mDisplayList = mStagingDisplayList;
    mStagingDisplayList = nullptr;
    if (mDisplayList) {
        mDisplayList-&gt;syncContents();
    }
}

void RenderNode::setStagingDisplayList(DisplayList* displayList) {
    mValid = (displayList != nullptr);
    mNeedsDisplayListSync = true;
    delete mStagingDisplayList;
    mStagingDisplayList = displayList;
}
</code></pre>
<p>介绍几个大神的博客：<br/>
<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fguoqifa29%2Farticle%2Fdetails%2F45131099" target="_blank">http://blog.csdn.net/guoqifa29/article/details/45131099</a><br/>
<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fwind_hzx%3Fviewmode%3Dcontents" target="_blank">http://blog.csdn.net/wind_hzx?viewmode=contents</a><br/>
<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.tuicool.com%2Farticles%2FbEjYbqN" target="_blank">http://www.tuicool.com/articles/bEjYbqN</a>（android 5.0）(简书地址：<a href="https://www.jianshu.com/p/bc1c1d2fadd1" target="_blank">http://www.jianshu.com/p/bc1c1d2fadd1</a>)<br/>
<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.csdn.net%2Fjinzhuojun%2Farticle%2Fdetails%2F54234354" target="_blank">http://blog.csdn.net/jinzhuojun/article/details/54234354</a>（android 7.0）</p>
</article><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[adb常用命令]]></title>    <link>https://www.jianshu.com/p/3fee1c9d51ae</link>    <guid>https://www.jianshu.com/p/3fee1c9d51ae</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku">adb常用命令</h1><article class="_2rhmJa"><h2>引言</h2>
<p>本文为小编学习总结的一些adb的常用命令，可能一些命令有待验证，更多内容可以参考<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fmzlogin%2Fawesome-adb%23%25E6%258C%2587%25E5%25AE%259A-adb-server-%25E7%259A%2584%25E7%25BD%2591%25E7%25BB%259C%25E7%25AB%25AF%25E5%258F%25A3" target="_blank">adb用法大全</a></p>
<h2>基本用法</h2>
<h4>语法命令</h4>
<p>adb 命令的基本语法如下：<br/>
adb [ -d| -e| -s &lt;sericalNumber&gt;] &lt;command&gt;<br/>
如果只有一个设备/模拟器连接时，可以省略掉[ -d| -e| -s] &lt;sericalNumber&gt;] 这一部分，直接使用adb &lt;command&gt;。</p>
<h4>为命令指定目标设备</h4>
<p>如果有多个设备/模拟器,则需要为命令指定目标设备</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td style="text-align:left">指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td style="text-align:left">指定当前唯一运行的模拟器为目标命令</td>
</tr>
<tr>
<td>-s&lt;serialNumber&gt;</td>
<td style="text-align:left">指定相应 serialNumber 号的设备/模拟器为命令目标</td>
</tr>
</tbody>
</table>
<h2>常用版</h2>
<h3>查看adb版本号</h3>
<p>adb version</p>
<h3>查看已连接设备</h3>
<p>adb devices</p>
<h3>查看手机序列号</h3>
<p>adb get-serialno<br/>
如返回127.0.0.1:7555</p>
<h3>查看日志</h3>
<p>adb logcat</p>
<blockquote>
<p>adb logcat -c 清除日志<br/>
adb logcat | grep "tag" 过滤日志 这里的tag就是你打印日志的时候需要设置的第一个参数TAG，通过TAG我们可以很轻松的过滤出我们想要的日志，轻松高效。</p>
</blockquote>
<h3>安装apk</h3>
<p>adb install [apk文件的路径]</p>
<blockquote>
<p>adb install douyin.apk</p>
</blockquote>
<ul>
<li>多个设备安装apk<br/>
adb -s [设备号] install [apk文件的路径]</li>
</ul>
<blockquote>
<p>adb -s 127.0.0.1:7555 install douyin.apk</p>
</blockquote>
<ul>
<li>如果apk已经存在，需要覆盖安装</li>
<li>adb install -r [apk文件的路径]</li>
</ul>
<blockquote>
<p>adb install -r douyin.apk</p>
</blockquote>
<p>adb install后面可以跟一些可选参数来控制安装APK的行为，可选参数及含义如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td style="text-align:left">将应用安装到保护目录 /mnt/asec</td>
</tr>
<tr>
<td>-r</td>
<td style="text-align:left">允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td style="text-align:left">允许安装AndroidMainfest.xml里application指定<code>android:testOnly="true"</code>的应用</td>
</tr>
<tr>
<td>-s</td>
<td style="text-align:left">应用安装到sdcard</td>
</tr>
<tr>
<td>-d</td>
<td style="text-align:left">允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td style="text-align:left">授予所有运行时权限</td>
</tr>
<tr>
<td>--abi abi-identifier</td>
<td style="text-align:left">为特定ABI强制安装apk，abi-identifier可以是armeabi-v7a、arm64-v8a、v86、x86_64 等</td>
</tr>
</tbody>
</table>
<h3>卸载apk</h3>
<ul>
<li>普通卸载</li>
<li>adb uninstall [apk文件的路径]</li>
</ul>
<blockquote>
<p>adb uninstall douyin.apk</p>
</blockquote>
<ul>
<li>卸载但是保留数据</li>
<li>adb uninstall -k [apk文件的路径]</li>
</ul>
<blockquote>
<p>adb uninstall -k douyin.apk</p>
</blockquote>
<h3>以root权限运行adbd</h3>
<blockquote>
<p>adb的运行原理是PC端的adb server 与手机端的守护进程adbd  建立连接，然后PC端的adb client通过adb server转发命令，adbd接收命令后解析运行。<br/>
所以如果adbd以普通权限执行，有些需要root权限才能执行的命令无法直接用<code>adb xxx</code>执行。这时可以<code>adb shell</code> 然后 <code>su</code>后执行命令,也可以让adbd以root权限执行，这个就能随意执行高权限命令了。</p>
</blockquote>
<p>adb root<br/>
正常输出：restarting adbd as root<br/>
现在再运行 adb shell，看看命令行提示符是不是变成 # 了？<br/>
有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。<br/>
相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。</p>
<h3>连接不稳定时需要挂载</h3>
<p>adb remount</p>
<h3>重启手机</h3>
<ul>
<li>正常重启<br/>
adb reboot</li>
<li>重启手机到recovery<br/>
adb reboot recovery</li>
<li>重启到bootloader界面<br/>
adb reboot bootloader</li>
</ul>
<h3>通过slideload更新系统</h3>
<p>如果我们下载了Android设备对应的系统更新包到电脑上，那么可以通过adb来完成更新 。<br/>
以Recovery模式下更新为例：<br/>
1.重启到Recovery模式。<br/>
命令：</p>
<pre><code>adb reboot recovery
</code></pre>
<p>2.在设备的Recovery界面上操作进入<code>Apply update-Apply from ADB</code>。<br/>
注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。<br/>
3.通过adb上传和更新系统。<br/>
命令：</p>
<pre><code>adb sideload &lt;path-to-update.zip&gt;
</code></pre>
<h3>关闭adb服务</h3>
<p>adb kill -server</p>
<h3>启动adb服务</h3>
<p>adb start -server</p>
<h3>查看手机设备型号</h3>
<p>adb shell getprop ro.product.model<br/>
如返回MI 8</p>
<h3>查看设备的Android版本</h3>
<p>adb shell getprop ro.build.version.release</p>
<h3>获取手机厂商名称</h3>
<p>adb shell getprop ro.product.brand<br/>
如返回Xiaomi</p>
<h3>获取手机SDK版本</h3>
<p>adb shell getprop ro.build.version.sdk</p>
<h3>查看手机分辨率</h3>
<p>adb shell wm size</p>
<h3>查看屏幕密度</h3>
<p>adb shell wm density<br/>
<strong>修改屏幕密度</strong><br/>
adb shell wm density 160<br/>
<strong>恢复原屏幕密度</strong><br/>
adb shell wm density reset</p>
<h3>查看手机的mac地址</h3>
<p>adb shell cat /sys/class/net/wlan0/address</p>
<h3>查看电池信息</h3>
<p>adb shell dumpsys battery</p>
<h3>查看进程</h3>
<p>adb shell ps</p>
<h3>查看CPU使用情况</h3>
<p>adb shell top</p>
<h3>CPU信息</h3>
<p>adb shell cat /proc/cpuinfo</p>
<h3>内存信息</h3>
<p>adb shell cat /proc/meminfo</p>
<h3>查看应用的安装路径</h3>
<pre><code>adb shell pm path &lt;packagename&gt;
</code></pre>
<p>我手机QQ的安装路径</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 86px;">
<div class="image-container-fill" style="padding-bottom: 8.94%;"/>
<div class="image-view" data-width="962" data-height="86"><img src="https://upload-images.jianshu.io/upload_images/20123021-f60141e64ef07ba4.png" data-original-width="962" data-original-height="86" data-original-format="image/png" data-original-filesize="16399"/></div>
</div>
<div class="image-caption">image.png</div>
</div>
<h3>查看手机上所有安装的app包名</h3>
<p>adb shell pm list packages</p>
<blockquote>
<p>adb shell pm list packages -s 查看所有系统app的包名<br/>
adb shell pm list packages -3 查看所有第三方app的包名<br/>
adb shell pm list packages | grep [包名] 使用grep筛选所有满足要求的app包名</p>
</blockquote>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:left">显示列表</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td style="text-align:left">所有应用</td>
</tr>
<tr>
<td>-f</td>
<td style="text-align:left">显示应用关联的apk文件</td>
</tr>
<tr>
<td>-d</td>
<td style="text-align:left">只显示disabled的应用</td>
</tr>
<tr>
<td>-e</td>
<td style="text-align:left">只显示enabled的应用</td>
</tr>
<tr>
<td>-s</td>
<td style="text-align:left">只显示系统应用</td>
</tr>
<tr>
<td>-3</td>
<td style="text-align:left">只显示第三方应用</td>
</tr>
<tr>
<td>-i</td>
<td style="text-align:left">显示应用的installer</td>
</tr>
<tr>
<td>-u</td>
<td style="text-align:left">包含已卸载应用</td>
</tr>
<tr>
<td><code>&lt;FILTER&gt;</code></td>
<td style="text-align:left"><code>包名包含&lt;FILTER&gt; 字符串</code></td>
</tr>
</tbody>
</table>
<h3>查看应用详细信息</h3>
<pre><code>adb shell dumpsys package &lt;packagename&gt;
</code></pre>
<h3>清除应用数据</h3>
<p>adb shell pm clear &lt;packagename&gt;</p>
<blockquote>
<p>当你只是想要清除一个apk的某些数据来复现某些操作的时候，这个命令就显得额外重要。它可以避免我们重装apk来完成这个操作。</p>
</blockquote>
<h3>获取某个应用包名的启动入口</h3>
<ul>
<li>adb shell dumpsys package com.ss.android.ugc.aweme|findstr activity</li>
<li>com.ss.android.ugc.aweme/com.ss.android.sdk.activity.BootstrapActivity 这个就是抖音的入口</li>
</ul>
<blockquote>
<p>adb shell dumpsys package com.ss.android29111 com.ss.android.ugc.aweme/com.ss.android.sdk.activity.BootstrapActivity</p>
</blockquote>
<h3>屏幕截屏</h3>
<p>adb shell screencap [保存路径]</p>
<blockquote>
<p>adb shell screencap /sdcard/screen.png</p>
</blockquote>
<p>也可以使用（adb版本太老的话，需要更新adb）</p>
<pre><code>adb exec-out screencap  &gt; sc.png
</code></pre>
<h3>录制视频</h3>
<p>adb shell screenrecord [保存路径]</p>
<h3>上传文件到手机</h3>
<p>adb push [电脑文件路径] [手机文件保存路径]</p>
<blockquote>
<p>adb push douyin.apk sdcard/douyin.apk</p>
</blockquote>
<h3>从手机端下载文件</h3>
<p>adb pull [手机上文件路径]<br/>
<strong>注意：</strong>此时没有指定上传到电脑的路径，会默认上传到adb程序所在的路径</p>
<blockquote>
<p>adb pull sdcard/douyin.apk</p>
</blockquote>
<p>指定上传路径：adb pull [手机上文件的路径] [电脑文件的路径]</p>
<blockquote>
<p>adb pull /storage/emulated/0/app/txt.mp4 D:/ADB/tet.mp4</p>
</blockquote>
<h3>模拟屏幕点击事件</h3>
<p>adb shell input tap x坐标轴 y坐标轴</p>
<blockquote>
<p>adb shell input tap 500 1450</p>
</blockquote>
<h3>模拟手势滑动事件</h3>
<p>adb shell input swipe 开始x轴 开始y轴 结束x轴 结束y轴 过程持续时间</p>
<blockquote>
<p>adb shell input swipe 100 500 100 1450 100</p>
</blockquote>
<h3>模拟点击键盘按钮</h3>
<p>adb shell input keyevent [key值]</p>
<blockquote>
<p>adb shell input keyevent 25</p>
</blockquote>
<p>一些常用的keyevent键值信息</p>
<table>
<thead>
<tr>
<th>keyevent</th>
<th style="text-align:left">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td style="text-align:left">Home键</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:left">返回键</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:left">拨号键</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:left">挂机键</td>
</tr>
<tr>
<td>19</td>
<td style="text-align:left">向上</td>
</tr>
<tr>
<td>20</td>
<td style="text-align:left">向下</td>
</tr>
<tr>
<td>21</td>
<td style="text-align:left">向左</td>
</tr>
<tr>
<td>22</td>
<td style="text-align:left">向右</td>
</tr>
<tr>
<td>24</td>
<td style="text-align:left">音量加</td>
</tr>
<tr>
<td>25</td>
<td style="text-align:left">音量减</td>
</tr>
<tr>
<td>26</td>
<td style="text-align:left">电源</td>
</tr>
<tr>
<td>27</td>
<td style="text-align:left">拍照（需要在相机应用里）</td>
</tr>
<tr>
<td>64</td>
<td style="text-align:left">打开浏览器</td>
</tr>
<tr>
<td>66</td>
<td style="text-align:left">回车键</td>
</tr>
<tr>
<td>67</td>
<td style="text-align:left">退格键</td>
</tr>
<tr>
<td>82</td>
<td style="text-align:left">菜单键</td>
</tr>
<tr>
<td>84</td>
<td style="text-align:left">搜索键</td>
</tr>
<tr>
<td>85</td>
<td style="text-align:left">播放/暂停键</td>
</tr>
<tr>
<td>86</td>
<td style="text-align:left">停止播放</td>
</tr>
<tr>
<td>87</td>
<td style="text-align:left">播放上一首</td>
</tr>
<tr>
<td>88</td>
<td style="text-align:left">播放下一首</td>
</tr>
<tr>
<td>92</td>
<td style="text-align:left">向上翻页</td>
</tr>
<tr>
<td>93</td>
<td style="text-align:left">向下翻页</td>
</tr>
<tr>
<td>112</td>
<td style="text-align:left">删除键</td>
</tr>
<tr>
<td>115</td>
<td style="text-align:left">大写锁定键</td>
</tr>
<tr>
<td>122</td>
<td style="text-align:left">光标移动到开始键</td>
</tr>
<tr>
<td>123</td>
<td style="text-align:left">光标移动到末尾键</td>
</tr>
<tr>
<td>164</td>
<td style="text-align:left">静音</td>
</tr>
<tr>
<td>168</td>
<td style="text-align:left">放大键</td>
</tr>
<tr>
<td>169</td>
<td style="text-align:left">缩小键</td>
</tr>
<tr>
<td>176</td>
<td style="text-align:left">打开系统设置</td>
</tr>
<tr>
<td>187</td>
<td style="text-align:left">切换应用</td>
</tr>
<tr>
<td>220</td>
<td style="text-align:left">降低屏幕亮度</td>
</tr>
<tr>
<td>221</td>
<td style="text-align:left">提高屏幕亮度</td>
</tr>
<tr>
<td>223</td>
<td style="text-align:left">系统休眠</td>
</tr>
<tr>
<td>224</td>
<td style="text-align:left">点亮屏幕</td>
</tr>
<tr>
<td>231</td>
<td style="text-align:left">打开语音助手</td>
</tr>
</tbody>
</table>
<h3>向屏幕输入一些信息</h3>
<ul>
<li>db shell input text [字符串信息]</li>
<li>%s是空格</li>
</ul>
<blockquote>
<p>db shell input text "insert%stext%shere"</p>
</blockquote>
<h3>查看前台Activity</h3>
<p>同时小编也是通过这种方式获取到应用包的入口<br/>
adb shell dumpsys activity activities | findstr mResumedActivity<br/>
获取到了QQ的启动入口</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 83px;">
<div class="image-container-fill" style="padding-bottom: 6.819999999999999%;"/>
<div class="image-view" data-width="1217" data-height="83"><img src="https://upload-images.jianshu.io/upload_images/20123021-1584e1eac4dde441.png" data-original-width="1217" data-original-height="83" data-original-format="image/png" data-original-filesize="19032"/></div>
</div>
<div class="image-caption">image.png</div>
</div>
<h3>查看正在运行的Services</h3>
<pre><code>adb shell dumpsys activity services [&lt;packagename&gt;]
</code></pre>
<p><code>&lt;packagename&gt;</code> 参数不是必须的，指定 <code>&lt;packagename&gt;</code>表示查看与某个包名相关的 Services，不指定表示查看所有 Services。<br/>
<code>&lt;packagename&gt;</code> 不一定要给出完整的包名，比如运行 <code>adb shell dumpsys activity services org.example</code>，那么包名 <code>org.example.demo1、org.example.demo2</code> 和 <code>org.example123</code> 等相关的 Services 都会列出来。</p>
<h3>启动某个app</h3>
<p>adb shell am start -n [包名]/[启动入口]</p>
<blockquote>
<p>adb shel am start -n com.ss.android.ugc.aweme/com.ss.android.sdk.activity.BootstrapActivity<br/>
Strating:Intent{cmp=com.ss.android.ugc.aweme/com.ss.android.sdk.activity.BootstrapActivity}</p>
</blockquote>
<p>启动qq</p>
<blockquote>
<p>adb shell am start -n com.tencent.mobileqq/.activity.SplashActivity</p>
</blockquote>
<p>启动有道词典</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 74px;">
<div class="image-container-fill" style="padding-bottom: 6.47%;"/>
<div class="image-view" data-width="1143" data-height="74"><img src="https://upload-images.jianshu.io/upload_images/20123021-307c3a0c81650606.png" data-original-width="1143" data-original-height="74" data-original-format="image/png" data-original-filesize="16293"/></div>
</div>
<div class="image-caption">image.png</div>
</div>
<h3>发送广播</h3>
<p>adb shell am broadcast -a "broadcastactionfilter"</p>
<blockquote>
<p>adb shell am broadcast -a "broadcastactionfilter"</p>
</blockquote>
<h3>使用自带浏览器打开网页</h3>
<p>adb shell am start -a [浏览器包名] -d [网址]</p>
<blockquote>
<p>adb shell am start -a "android.intent.action.VIEW" -d <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.google.com" target="_blank">https://www.google.com</a></p>
</blockquote>
<h3>获取手机内部存储信息</h3>
<p>adb shell df /data</p>
<h2>无线连接（需要借助USB连接线）</h2>
<p>除了可以通过USB连接设备与电脑来使用adb，也可以通过无线连接——虽然连接过程中也有需要USB的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱USB连接线的束缚了！</p>
<h3>操作步骤</h3>
<p>1.将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。<br/>
2.将设备与电脑通过 USB 线连接。<br/>
应确保连接成功（可运行 adb devices 看是否能列出该设备）。<br/>
3.让设备在 5555 端口监听 TCP/IP 连接：</p>
<pre><code>adb tcpip 5555
</code></pre>
<p>4.断开 USB 连接。<br/>
5.找到设备的 IP 地址。</p>
<blockquote>
<p>一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fmzlogin%2Fawesome-adb%23ip-%25E5%259C%25B0%25E5%259D%2580" target="_blank">查看设备信息 - IP 地址</a> 一节里的方法用 adb 命令来查看。<br/>
6.通过 IP 地址连接设备。</p>
</blockquote>
<pre><code>adb connect &lt;device-ip-address&gt;
</code></pre>
<p>device-ip-address&gt;你设备的ip地址<br/>
7.确认连接状态</p>
<pre><code>adb devices
</code></pre>
<p>如果能看到</p>
<pre><code>&lt;device-ip-address&gt;:5555 device
</code></pre>
<p>说明连接成功<br/>
如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 <code>adb connect &lt;device-ip-address&gt;</code> 那一步；<br/>
如果还是不行的话，通过 <code>adb kill-server</code> 重新启动 adb 然后从头再来一次试试。</p>
<h3>断开无线连接</h3>
<pre><code>adb disconnect &lt;device-ip-address&gt;
</code></pre>
<h2>关于ADB IDEA</h2>
<p>AS插件ADB IDEA，装了这款插件可以直接在AS中快速操作一些ADB命令</p>
<h3>使用方式</h3>
<p>1、双击shift -&gt; 点击action -&gt;搜索adb</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 375px;">
<div class="image-container-fill" style="padding-bottom: 31.569999999999997%;"/>
<div class="image-view" data-width="1188" data-height="375"><img src="https://upload-images.jianshu.io/upload_images/20123021-5f962d67d5267c67.png" data-original-width="1188" data-original-height="375" data-original-format="image/png" data-original-filesize="108034"/></div>
</div>
<div class="image-caption">image.png</div>
</div>
<p>2、Ctrl + Shift + A，快捷键直接调用</p>
<br/>
<div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 441px;">
<div class="image-container-fill" style="padding-bottom: 38.31%;"/>
<div class="image-view" data-width="1151" data-height="441"><img src="https://upload-images.jianshu.io/upload_images/20123021-0cb20333cd5ab9ca.png" data-original-width="1151" data-original-height="441" data-original-format="image/png" data-original-filesize="166412"/></div>
</div>
<div class="image-caption">image.png</div>
</div>
<h2>一些琐碎小问题</h2>
<h4>不知应用包的入口Activity如何启动应用包</h4>
<p>1.通过category</p>
<pre><code>adb shell monkey -p &lt;packagename&gt; -c android.intent.category.LAUNCHER 1
</code></pre>
<ol start="2">
<li>
</li>
</ol>
<p><a href="https://www.jianshu.com/p/150139c8295a" target="_blank">adb获取应用包入口的方案</a></p>
<h4>adb shell input text无法响应中文输入的问题</h4>
<p><a href="https://www.jianshu.com/p/e7ff05e2f2aa" target="_blank">adb shell input text不能输入中文的解决方案</a></p>
<h2>adb部分总结</h2>
<p><a href="https://www.jianshu.com/p/f6fa6759e747" target="_blank">adb部分总结</a></p>
</article><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[uniapp人脸识别解决方案]]></title>    <link>https://www.jianshu.com/p/adcdbf83e1ff</link>    <guid>https://www.jianshu.com/p/adcdbf83e1ff</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku">uniapp人脸识别解决方案</h1><article class="_2rhmJa"><p>APP端：<br/>
因为APP端无法使用uni的camera组件，最开始考虑使用内嵌webview的方式，通过原生dom调用video渲染画面然后通过canvas截图。但是此方案兼容性在ios几乎为0，如果app只考虑安卓端的话可以采用此方案。后面又想用live-pusher组件来实现，但是发现快照api好像需要真实流地址才能截取图像。因为种种原因，也是安卓ios双端兼容性不佳。最终决定采用5+api实现。经实测5+api兼容性还算可以，但是毕竟是调用原生能力，肯定是没有原生开发那么丝滑的，难免会出现一些不可预测的兼容性问题。所以建议app和手机硬件交互强的话还是不要用uni开发了。不然真的是翻文档能翻死人。社区也找不到靠谱的解决方案。</p>
<p>5+api 文档<br/>
<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.html5plus.org%2Fdoc%2Fzh_cn%2Fvideo.html%23plus.video.createLivePusher" target="_blank">https://www.html5plus.org/doc/zh_cn/video.html#plus.video.createLivePusher</a><br/>
</p><div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 650px;">
<div class="image-container-fill" style="padding-bottom: 92.83%;"/>
<div class="image-view" data-width="935" data-height="868"><img src="https://upload-images.jianshu.io/upload_images/21286321-101fd189291493ce.png" data-original-width="935" data-original-height="868" data-original-format="image/png" data-original-filesize="57126"/></div>
</div>
<div class="image-caption">image.png</div>
</div><p/>
<p>就是使用这个api调用原生的camera完成。并且可以直接在预览模式下完成快照，也不需要真实的推流地址。</p>
<pre><code>&lt;template&gt;
    &lt;view class="content"&gt;
        &lt;view class="c-footer"&gt;
            &lt;view class="msg-box"&gt;
                &lt;view class="msg"&gt;
                    1、请保证本人验证。
                &lt;/view&gt;
                &lt;view class="msg"&gt;
                    2、请使头像正面位于画框中。
                &lt;/view&gt;
                &lt;view class="msg"&gt;
                    3、请使头像尽量清晰。
                &lt;/view&gt;
                &lt;view class="msg"&gt;
                    4、请保证眼镜不反光，双眼可见。
                &lt;/view&gt;
                &lt;view class="msg"&gt;
                    5、请保证无墨镜，口罩，面膜等遮挡物。
                &lt;/view&gt;
                &lt;view class="msg"&gt;
                    6、请不要化浓妆，不要戴帽子。
                &lt;/view&gt;
            &lt;/view&gt;
            &lt;view class="but" @click="snapshotPusher" v-if="!cilckSwitch"&gt;采集本人人脸&lt;/view&gt;
        &lt;/view&gt;
    &lt;/view&gt;
&lt;/template&gt;

&lt;script&gt;
    import permission from '../../util/permission.js'
    export default {
        data() {
            return {
                type: '', //是否是补签拉起的人脸识别
                imgData: '',
                pusher: null,
                scanWin: null,
                faceInitTimeout: null,
                snapshTimeout: null,
                uploadFileTask: null,
                cilckSwitch: false, //防止多次点击
            };
        },
        methods: {
            //人脸比对
            handleFaceContrast(param) {
                uni.hideLoading()
                this.$http({
                    url: '/API_AUTH/AppIaiFace/faceContrast.api',
                    data: {
                        ...param,
                        userid: uni.getStorageSync('userInfo').id
                    }
                }).then(res =&gt; {
                    console.log(res)
                    if (res.data.compareResult == 1) {
                        let pages = getCurrentPages(); //获取所有页面栈实例列表
                        let nowPage = pages[pages.length - 1]; //当前页页面实例
                        let prevPage = pages[pages.length - 2]; //上一页页面实例
                        if (this.type == 'signOut') {
                            prevPage.$vm.signOutXh = param.xh;
                            prevPage.$vm.signOutPhotoPath = param.path
                        } else {
                            prevPage.$vm.xh = param.xh;
                            prevPage.$vm.photoPath = param.path
                        }
                        uni.navigateBack()
                    } else {
                        uni.showToast({
                            title: '人脸比对不通过，请重试',
                            icon: 'none'
                        })
                        this.cilckSwitch = false
                    }
                }).catch(err =&gt; {
                    uni.showToast({
                        title: '人脸比对不通过，请重试',
                        icon: 'none'
                    })
                    this.cilckSwitch = false
                })
            },
            //初始化
             faceInit() {
                 uni.showLoading({
                    title: '请稍后...'
                 })
                this.faceInitTimeout = setTimeout(async () =&gt; {
                    //创建livepusher
                    if (uni.getSystemInfoSync().platform === 'android') {
                        const data1 = await permission.requestAndroidPermission(
                            "android.permission.RECORD_AUDIO")
                        const data2 = await permission.requestAndroidPermission("android.permission.CAMERA")
                        console.log(data1,data2,1111)
                        if (data1 == 1 &amp;&amp; data2 == 1) {
                            this.pusherInit();
                        }
                    } else {
                        this.pusherInit();
                    }
                    //覆盖在视频之上的内容，根据实际情况编写
                    // this.scanWin = plus.webview.create('/hybrid/html/faceTip.html', '', {
                    //  background: 'transparent'
                    // });
                    //新引入的webView显示
                    // this.scanWin.show();
                    //初始化上传本地文件的api
                    this.initUploader()
                }, 500);
            },
            //初始化播放器
            pusherInit() {
                const currentWebview = this.$mp.page.$getAppWebview();
                this.pusher = plus.video.createLivePusher('livepusher', {
                    url: '',
                    top: '0px',
                    left: '0px',
                    width: '100%',
                    height: '50%',
                    position: 'absolute',
                    aspect: '9:16',
                    muted: false,
                    'z-index': 999999,
                    'border-radius': '50%',
                });
                currentWebview.append(this.pusher);
                //反转摄像头
                this.pusher.switchCamera();
                //开始预览
                this.pusher.preview();
                uni.hideLoading()
            },
            //初始化读取本地文件
            initUploader() {
                let that = this
                this.uploadFileTask = plus.uploader.createUpload(
                    "完整的接口请求地址", {
                        method: "POST",
                        headers: {
                            // 修改请求头Content-Type类型 此类型为文件上传
                            "Content-Type": "multipart/form-data"
                        }
                    },
                    // data：服务器返回的响应值 status: 网络请求状态码
                    (data, status) =&gt; {
                        // 请求上传文件成功
                        if (status == 200) {
                            console.log(data)
                            // 获取data.responseText之后根据自己的业务逻辑做处理
                            let result = JSON.parse(data.responseText);
                            console.log(result.data.xh)
                            that.handleFaceContrast({
                                xh: result.data.xh,
                                path: result.data.path
                            })
                        }
                        // 请求上传文件失败
                        else {
                            uni.showToast({
                                title: '上传图片失败',
                                icon: 'none'
                            })
                            console.log("上传失败", status)
                            that.cilckSwitch = false
                            uni.hideLoading()
                        }
                    }
                );
            },
            //快照
            snapshotPusher() {
                if (this.cilckSwitch) {
                    uni.showToast({
                        title: '请勿频繁点击',
                        icon: 'none'
                    })
                    return
                }
                this.cilckSwitch = true
                uni.showLoading({
                    title: '正在比对，请勿退出'
                })
                let that = this
                this.snapshTimeout = setTimeout(() =&gt; {
                    this.pusher.snapshot(
                        e =&gt; {
                            // this.pusher.close();
                            // this.scanWin.hide();
                            //拿到本地文件路径
                            var src = e.tempImagePath;
                            this.uploadImg(src)
                            //获取图片base64
                            // this.getMinImage(src);
                        },
                        function(e) {
                            plus.nativeUI.alert('snapshot error: ' + JSON.stringify(e));
                            that.cilckSwitch = false
                            uni.hideLoading()
                        }
                    );
                }, 500);
            },
            //调用原生能力读取本地文件并上传
            uploadImg(imgPath) {
                this.uploadFileTask.addFile('file://' + imgPath, {
                    key: "file" // 填入图片文件对应的字段名
                });
                //添加其他表单字段（参数） 两个参数可能都只支持传字符串
                // uploadFileTask.addData("参数名", 参数值);
                this.uploadFileTask.start();
            },
            //获取图片base64
            getMinImage(imgPath) {
                plus.zip.compressImage({
                        src: imgPath,
                        dst: imgPath,
                        overwrite: true,
                        quality: 40
                    },
                    zipRes =&gt; {
                        setTimeout(() =&gt; {
                            var reader = new plus.io.FileReader();
                            reader.onloadend = res =&gt; {
                                var speech = res.target.result; //base64图片
                                console.log(speech.length);
                                console.log(speech)
                                this.imgData = speech;
                            };
                            reader.readAsDataURL(plus.io.convertLocalFileSystemURL(zipRes.target));
                        }, 1000);
                    },
                    function(error) {
                        console.log('Compress error!', error);
                    }
                );
            },
        },
        onLoad(option) {
            //#ifdef APP-PLUS
            this.type = option.type
            this.faceInit();
            
            //#endif
        },
        onHide() {
            console.log('hide')
            this.faceInitTimeout &amp;&amp; clearTimeout(this.faceInitTimeout);
            this.snapshTimeout &amp;&amp; clearTimeout(this.snapshTimeout);
            // this.scanWin.hide();
        },
        onBackPress() {
            // let pages = getCurrentPages(); //获取所有页面栈实例列表
            // let nowPage = pages[pages.length - 1]; //当前页页面实例
            // let prevPage = pages[pages.length - 2]; //上一页页面实例
            // prevPage.$vm.xh = '11111';
            // prevPage.$vm.photoPath = '22222' 
            this.faceInitTimeout &amp;&amp; clearTimeout(this.faceInitTimeout);
            this.snapshTimeout &amp;&amp; clearTimeout(this.snapshTimeout);
            // this.scanWin.hide();
        },
        onUnload() {
            this.faceInitTimeout &amp;&amp; clearTimeout(this.faceInitTimeout);
            this.snapshTimeout &amp;&amp; clearTimeout(this.snapshTimeout);
            // this.scanWin.hide();
        },
    };
&lt;/script&gt;

&lt;style lang="scss" scoped&gt;
    .but {
        margin: 50rpx auto 0;
        border-radius: 10px;
        width: 80%;
        height: 100rpx;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #008AFF;
        font-size: 16px;
        color: #FFFFFF;
    }

    .c-footer {

        width: 100%;
        position: fixed;
        top: 50%;
        left: 0;
        z-index: 10;
        padding: 30rpx 0;

        .msg-box {
            width: 80%;
            margin: 0 auto;
            text-align: left;

            .msg {
                margin-bottom: 15rpx;
                font-size: 13px;
                color: #666;
            }
        }
    }

    .img-data {
        width: 100%;
        height: auto;
    }

    .content {
        background-color: #fff;

    }
&lt;/style&gt;

</code></pre>
<p>以上是完整的包含逻辑的代码。</p>
<pre><code>关键代码
//初始化播放器
            pusherInit() {
                const currentWebview = this.$mp.page.$getAppWebview();
                this.pusher = plus.video.createLivePusher('livepusher', {
                    url: '',
                    top: '0px',
                    left: '0px',
                    width: '100%',
                    height: '50%',
                    position: 'absolute',
                    aspect: '9:16',
                    muted: false,
                    'z-index': 999999,
                    'border-radius': '50%',
                });
                currentWebview.append(this.pusher);
                //反转摄像头
                this.pusher.switchCamera();
                //开始预览
                this.pusher.preview();
                uni.hideLoading()
            },

 //快照
            snapshotPusher() {
                if (this.cilckSwitch) {
                    uni.showToast({
                        title: '请勿频繁点击',
                        icon: 'none'
                    })
                    return
                }
                this.cilckSwitch = true
                uni.showLoading({
                    title: '正在比对，请勿退出'
                })
                let that = this
                this.snapshTimeout = setTimeout(() =&gt; {
                    this.pusher.snapshot(
                        e =&gt; { 
                            //拿到本地文件路径
                            var src = e.tempImagePath;
  //这里因为接口参数需要加密，用base64的话加密出来的参数太大了，所以选择了直接读取本地文件上传文件流的方式。
                            this.uploadImg(src)
                            //获取图片base64
                            // this.getMinImage(src);
                        },
                        function(e) {
                            plus.nativeUI.alert('snapshot error: ' + JSON.stringify(e));
                            that.cilckSwitch = false
                            uni.hideLoading()
                        }
                    );
                }, 500);
            },
            //获取图片base64
            getMinImage(imgPath) {
                plus.zip.compressImage({
                        src: imgPath,
                        dst: imgPath,
                        overwrite: true,
                        quality: 40
                    },
                    zipRes =&gt; {
                        setTimeout(() =&gt; {
                            var reader = new plus.io.FileReader();
                            reader.onloadend = res =&gt; {
                                var speech = res.target.result; //base64图片
                                console.log(speech.length);
                                console.log(speech)
                                this.imgData = speech;
                            };
                            reader.readAsDataURL(plus.io.convertLocalFileSystemURL(zipRes.target));
                        }, 1000);
                    },
                    function(error) {
                        console.log('Compress error!', error);
                    }
                );
            },
            //初始化读取本地文件
            initUploader() {
                let that = this
                this.uploadFileTask = plus.uploader.createUpload(
                    "完整的接口请求地址", {
                        method: "POST",
                        headers: {
                            // 修改请求头Content-Type类型 此类型为文件上传
                            "Content-Type": "multipart/form-data"
                        }
                    },
                    // data：服务器返回的响应值 status: 网络请求状态码
                    (data, status) =&gt; {
                        // 请求上传文件成功
                        if (status == 200) {
                            console.log(data)
                            // 获取data.responseText之后根据自己的业务逻辑做处理
                            let result = JSON.parse(data.responseText);
                            console.log(result.data.xh)
                            that.handleFaceContrast({
                                xh: result.data.xh,
                                path: result.data.path
                            })
                        }
                        // 请求上传文件失败
                        else {
                            uni.showToast({
                                title: '上传图片失败',
                                icon: 'none'
                            })
                            console.log("上传失败", status)
                            that.cilckSwitch = false
                            uni.hideLoading()
                        }
                    }
                );
            },
     //调用原生能力读取本地文件并上传
            uploadImg(imgPath) {
                this.uploadFileTask.addFile('file://' + imgPath, {
                    key: "file" // 填入图片文件对应的字段名
                });
                //添加其他表单字段（参数） 两个参数可能都只支持传字符串
                // uploadFileTask.addData("参数名", 参数值);
                this.uploadFileTask.start();
            },
</code></pre>
<p>以上就是关键的代码。<br/>
接下来补充几个坑的地方。创建出来的livepusher层级很高，无法在同一页面被别的元素遮挡。所以想要在他上面写样式是行不通了。只能再创建一个webview。然后将这个webview覆盖在livepusher上，达到人脸识别页面的样式。</p>
<pre><code>//覆盖在视频之上的内容，根据实际情况编写
                     this.scanWin = plus.webview.create('/hybrid/html/faceTip.html', '', {
                      background: 'transparent'
                     });
                    //新引入的webView显示
                   this.scanWin.show();
                   //新引入的webView影藏
                     this.scanWin.hide();

</code></pre>
<p>这种方案在ios基本没问题。至少目前没遇到过。但是安卓就一言难尽了。首先这个组件默认调起的是后置摄像头，这显然不符合我们的需求。但是官方提供的文档里也没有明确支持可以配置优先调起哪个摄像头。好早提供了一个switchCamera的api可以翻转摄像头。</p>
<p>但是在安卓系统上，尤其是鸿蒙系统，调用这个api就会导致程序闪退，而且发生频率还特别高。这个问题至今不知道该怎么解决。</p>
<p>除了闪退问题，安卓还存在一个麻烦事儿，那就是首次进入app，翻转摄像头的api没有用，拉起的还是后置摄像头。但是后续再进入app就无此问题了。后面折腾来折腾去，发现好像是首次进入拉起授权弹窗的时候才会出现这种问题。<br/>
然后写了个定时器做测试，五秒之后再拉起摄像头再去翻转摄像头。然后再五秒内赶紧把授权给同意了。结果发现翻转竟然生效了。<br/>
然后决定再渲染推流元素之前先让用户通过权限授权，然后再拉起摄像头。 也就是上文完整代码中的</p>
<pre><code> //创建livepusher
                    if (uni.getSystemInfoSync().platform === 'android') {
                        const data1 = await permission.requestAndroidPermission(
                            "android.permission.RECORD_AUDIO")
                        const data2 = await permission.requestAndroidPermission("android.permission.CAMERA")
                        console.log(data1,data2,1111)
                        if (data1 == 1 &amp;&amp; data2 == 1) {
                            this.pusherInit();
                        }
                    } else {
                        this.pusherInit();
                    }

</code></pre>
<p>具体的意思就不过多赘述了，自行看permission的文档。或者看他的代码。很简单<br/>
permission下载地址<br/>
<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fext.dcloud.net.cn%2Fplugin%3Fid%3D594" target="_blank">https://ext.dcloud.net.cn/plugin?id=594</a><br/>
以上就是调用原生能力拉起摄像头实现快照功能的所有内容了。</p>
<p>下面也记录一下web端如果实现这种功能，毕竟当时搞出来也不容易，但是最终还是败在了兼容性上</p>
<p>方案的话大致有两种，一种是借助tracking js 有兴趣的可以了解一下，一个web端人脸识别库。他可以识别画面中是否出现人脸。以及一下更高级的功能我就没有去探索了。有需要的可以自行研究</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;title&gt;人脸识别&lt;/title&gt;
        &lt;script src="../html/js/tracking-min.js"&gt;&lt;/script&gt;
        &lt;script src="../html/js/face-min.js"&gt;&lt;/script&gt;
        &lt;style&gt;
            video,
            canvas {
                position: absolute;
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class="demo-container"&gt;
            &lt;video id="video" width="320" height="240" preload autoplay loop muted&gt;&lt;/video&gt;
            &lt;canvas id="canvas" width="320" height="240"&gt;&lt;/canvas&gt;
        &lt;/div&gt;
        &lt;script&gt;
            window.onload = function() {
                console.log(123123123)
                // 视频显示
                var video = document.getElementById('video');
                //   绘图
                var canvas = document.getElementById('canvas');
                var context = canvas.getContext('2d');
                var time = 10000;
                var tracker = new tracking.ObjectTracker('face');
                //   设置识别的放大比例
                tracker.setInitialScale(4);
                //   设置步长
                tracker.setStepSize(2);
                //   边缘密度
                tracker.setEdgesDensity(0.1);
                //   启动摄像头，并且识别视频内容
                var trackerTask = tracking.track('#video', tracker, {
                    camera: true
                });
                var flag = true;
                tracker.on('track', function(event) {
                    if (event.data.length === 0) {
                        console.log('未检测到人脸')
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else if (event.data.length &gt; 1) { 
                        console.log('检测到多张人脸')
                    } else {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        event.data.forEach(function(rect) {
                            context.strokeStyle = '#ff0000';
                            context.strokeRect(rect.x, rect.y, rect.width, rect.height);
                            context.fillStyle = "#ff0000";
                            //console.log(rect.x, rect.width, rect.y, rect.height);
                        });
                        if (flag) {
                            console.log("拍照");
                            context.drawImage(video, 0, 0, 320, 240);
                            saveAsLocalImage();
                            context.clearRect(0, 0, canvas.width, canvas.height);
                            flag = false;
                            setTimeout(function() {
                                flag = true;
                            }, time);
                        } else {
                            //console.log("冷却中");
                        }
                    }
                });
            };

            function saveAsLocalImage() {
                var myCanvas = document.getElementById("canvas");
                // here is the most important part because if you dont replace you will get a DOM 18 exception.  
                // var image = myCanvas.toDataURL("image/png").replace("image/png", "image/octet-stream;Content-Disposition: attachment;filename=foobar.png");  
                var image = myCanvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
                // window.location.href = image; // it will save locally  
                // create temporary link  
                return
                var tmpLink = document.createElement('a');
                tmpLink.download = 'image.png'; // set the name of the download file 
                tmpLink.href = image;

                // temporarily add link to body and initiate the download  
                document.body.appendChild(tmpLink);
                tmpLink.click();
                document.body.removeChild(tmpLink);
            }
        &lt;/script&gt;

    &lt;/body&gt;

&lt;/html&gt;


</code></pre>
<p>另外一种就是纯video+canvas截取一张视频中的画面。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;人脸采集&lt;/title&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;link rel="stylesheet" type="text/css" href="./css/index.css" /&gt;
        &lt;script src="./js/jq.js" type="text/javascript" charset="utf-8"&gt;&lt;/script&gt;
        &lt;!-- uni 的 SDK --&gt;
        &lt;script type="text/javascript" src="https://js.cdn.aliyun.dcloud.net.cn/dev/uni-app/uni.webview.1.5.2.js"&gt;
        &lt;/script&gt;
        &lt;script src="https://cdn.bootcdn.net/ajax/libs/vConsole/3.0.0/vconsole.min.js" type="text/javascript"
            charset="utf-8"&gt;&lt;/script&gt;
        &lt;script&gt;
            // init vConsole，app中查看
            var vConsole = new VConsole();
            // console.log('Hello world');
        &lt;/script&gt;
        &lt;style&gt;
            .mui-content {
                margin: 0 auto;
                text-align: center;
                border: 0px solid red;
            }
            /*摄像头翻转180度*/
            video {
                transform: rotateY(180deg);
                -webkit-transform: rotateY(180deg);
                /* Safari 和 Chrome */
                -moz-transform: rotateY(180deg);
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body class='body'&gt;
        &lt;div class="mui-content"&gt;
            &lt;div style="margin: 40px auto;"&gt;
                &lt;!-- &lt;input type="file" id='image' accept="image/*" capture='user'&gt; --&gt;
                &lt;video id="video" style="margin: 0 auto; border-radius: 150px;"&gt;&lt;/video&gt;
                &lt;canvas id='canvas' width="300" height="300"
                    style="border: 0px solid red;margin: auto; display: none;"&gt;&lt;/canvas&gt;
            &lt;/div&gt;
            &lt;div class="msg-box"&gt;
                &lt;div class="msg"&gt;
                    1、请保证本人验证。
                &lt;/div&gt;
                &lt;div class="msg"&gt;
                    2、请使头像正面位于画框中。
                &lt;/div&gt;
                &lt;div class="msg"&gt;
                    3、请使头像尽量清晰。
                &lt;/div&gt;
                &lt;div class="msg"&gt;
                    4、请保证眼镜不反光，双眼可见。
                &lt;/div&gt;
                &lt;div class="msg"&gt;
                    5、请保证无墨镜，口罩，面膜等遮挡物。
                &lt;/div&gt;
                &lt;div class="msg"&gt;
                    6、请不要化浓妆，不要戴帽子。
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div style="width: 80%; position: absolute; bottom: 20px; left: 50%; transform: translate(-50%, -50%);"&gt;
                &lt;div class="but" id="start"&gt;采集本人人脸&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script type="text/javascript"&gt;
        var video, canvas, vendorUrl, interval, videoHeight, videoWidth, time = 0;
        // 获取webview页面数据
        // var data = JSON.parse(getUrlParam('data'))
        // var info = data.info;
        // var userInfo = data.userInfo;
        // const userId = data.userId; // 当前登录用户id
        $(function() {
            // 初始化
            initVideo()
            // uni.app事件
            document.addEventListener('UniAppJSBridgeReady', function() {
                uni.getEnv(function(res) {
                    console.log('当前环境：' + JSON.stringify(res));
                });
                setInterval(() =&gt; {
                    uni.postMessage({
                        data: {
                            action: 'postMessage'
                        }
                    });
                }, 1000)
            });
        })
        // 获取url携带的数据
        function getUrlParam(name) {
            var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)");
            var r = window.location.search.substr(1).match(reg);
            if (r != null) return unescape(r[2]);
            return null;
        }
        // 摄像头初始化
        function initVideo() {
            console.log('摄像头初始化')
            video = document.getElementById("video");
            videoHeight = 300
            videoWidth = 300
            setTimeout(() =&gt; {
                console.log(navigator)
                navigator.mediaDevices
                    .getUserMedia({
                        video: {
                            width: {
                                ideal: videoWidth,
                                max: videoWidth
                            },
                            height: {
                                ideal: videoHeight,
                                max: videoHeight
                            },
                            facingMode: 'user', //前置摄像头
                            // facingMode: { exact: "environment" }, //后置摄像头
                            frameRate: {
                                ideal: 30,
                                min: 10
                            }
                        }
                    })
                    .then(videoSuccess)
                    .catch(videoError);
                if (
                    navigator.mediaDevices.getUserMedia ||
                    navigator.getUserMedia ||
                    navigator.webkitGetUserMedia ||
                    navigator.mozGetUserMedia ||
                    navigator.mediaCapabilities
                ) {
                    console.log('调用用户媒体设备, 访问摄像头')
                    //调用用户媒体设备, 访问摄像头
                    getUserMedia({
                            video: {
                                width: {
                                    ideal: videoWidth,
                                    max: videoWidth
                                },
                                height: {
                                    ideal: videoHeight,
                                    max: videoHeight
                                },
                                facingMode: 'user', //前置摄像头
                                // facingMode: { exact: "environment" }, //后置摄像头
                                frameRate: {
                                    ideal: 30,
                                    min: 10
                                }
                            }
                        },
                        videoSuccess,
                        videoError
                    );
                } else {}
            }, 300);
        }
        // 获取用户设备
        function getUserMedia(constraints, success, error) {
            if (navigator.mediaDevices.getUserMedia) {
                //最新的标准API
                navigator.mediaDevices
                    .getUserMedia(constraints)
                    .then(success)
                    .catch(error);
            } else if (navigator.webkitGetUserMedia) {
                //webkit核心浏览器
                navigator.webkitGetUserMedia(constraints, success, error);
            } else if (navigator.mozGetUserMedia) {
                //firfox浏览器
                navigator.mozGetUserMedia(constraints, success, error);
            } else if (navigator.getUserMedia) {
                //旧版API
                navigator.getUserMedia(constraints, success, error);
            }
        }
        // 开始有画面
        function videoSuccess(stream) {
            //this.mediaStreamTrack = stream;
            console.log("=====stream")
            video.srcObject = stream;
            video.play();
            //$("#max-bg").css('background-color', 'rgba(0,0,0,0)')
            // 这里处理我的的东西
        }

        function videoError(error) {
            alert('摄像头获取错误')
            console.log('摄像头获取错误')
            setTimeout(() =&gt; {
                initVideo()
            }, 6000)
        }
        // 单次拍照
        function getFaceImgBase64() {
            canvas = document.getElementById('canvas');
            //绘制canvas图形
            canvas.getContext('2d').drawImage(video, 0, 0, 300, 300);
            //把canvas图像转为img图片
            var bdata = canvas.toDataURL("image/jpeg");
            //img.src = canvas.toDataURL("image/png");
            return bdata.split(',')[1]; //照片压缩成base位数据
        }
        $('#start').on('click', function() {
            time = 0;
            console.log("开始人脸采集，请正对屏幕");
            faceGather();
        })
        // 人脸采集
        function faceGather() {
            const faceImgBase64 = getFaceImgBase64();
            console.log(faceImgBase64);
        }
    &lt;/script&gt;
&lt;/html&gt;

</code></pre>
</article><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item><item>    <title><![CDATA[开源IM项目OpenIM单聊及万人群压测报告]]></title>    <link>https://www.jianshu.com/p/174ecdf584f9</link>    <guid>https://www.jianshu.com/p/174ecdf584f9</guid>    <pubDate>None</pubDate>    <description><![CDATA[<div style="margin: 10px;"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/commons.d40cf249.chunk.css"><link rel="stylesheet" href="https://cdn2.jianshu.io/shakespeare/_next/static/css/styles.bf51618c.chunk.css"> <h1 class="_1RuRku">开源IM项目OpenIM单聊及万人群压测报告</h1><article class="_2rhmJa"><p><b>单聊压测结论：</b></p><p>华为云主机s3一台：8核16G内存，网络带宽10Mb，普通磁盘（非SSD）</p><p>同时在线及压测客户端数量：1万</p><p>每秒钟发送消息量：2300条；</p><p>从发送到对方接收平均消息延时：5秒</p><p><b>群聊压测结论：</b></p><p>华为云主机s3一台：8核16G内存，网络带宽10Mb，普通磁盘（非SSD）</p><p>群规模：1万人</p><p>同时在线人数：1千人</p><p>每秒发送消息量：500条；</p><p>从发送到对方接收平均消息延时：6秒</p><p>注：（1）客户端和服务端在同一台机器，不消化网络带宽；（2）未使用nginx反向代理</p><p>服务器资源</p><p>华为云主机s3一台：8核16G内存，网络带宽10Mb，普通磁盘（非SSD）</p><div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 595px;">
<div class="image-container-fill" style="padding-bottom: 50.0%;"/>
<div class="image-view" data-width="1190" data-height="595"><img src="https://upload-images.jianshu.io/upload_images/26766306-5e9473a38ef4cf37.png" data-original-width="1190" data-original-height="595" data-original-format="image/png" data-original-filesize="89615"/></div>
</div>
<div class="image-caption"/>
</div><p>OpenIM配置信息</p><p>（一）服务端配置调整 config/config.yaml 以8核16G为例</p><p>（1）openImMessagePort: [ 10130, 10131, 10132, 10133, 10134,10135 ]</p><p>（2）openImPushPort: [ 10170, 10171, 10172, 10173 ]</p><p>（3）remainLogLevel: 3</p><p>（4）chatpersistencemysql: false</p><p>(5) dbMaxOpenConns: 100</p><p>    dbMaxIdleConns: 10</p><p>    dbMaxLifeTime: 5</p><p>（二）调整path_info.cfg中msg_transfer_service_num=4</p><p>（三）kafka分区调整</p><p>（1）设置ws2ms_chat为8个分区 msg_transfer_service_num的2倍</p><p>（2）设置msg_to_mongo为8个分区 msg_transfer_service_num的2倍</p><p>（3）设置ms2ps_chat为8个分区 openImMessagePort的2倍</p><p>（四）mysql服务端设置最大连接数为2000</p><p>（五）etcd kafka redis mongo都是单机部署</p><p>启动单聊压测</p><p>（1）启动1万个压测客户端，发送1000万消息，出现[send msg begin ] 表示初始化连接及登录完毕，开始发送消息</p><p>./press_open_im  -sn 10000 -mn 1000 -t 4000</p><p>（2）查看连接数约2万个连接，由于压测客户端在本机，所有连接数乘2</p><p>（3）查看消息收发量，每秒2377条消息压测</p><p>tail -f OpenIM.log.all.2022-09-02  |grep "msg_gateway sendMsgCount"</p><p>（4）启动消息延时检测程序，在此压力下，消息从发送方发出到接收方成功接收大概需要5秒</p><p>./msg_delay_open_im -sn 2 -mn 100 -t 100</p><p>单聊压测结论</p><p>华为云主机s3一台：8核16G内存，网络带宽10Mb，普通磁盘（非SSD），在每秒收发2377条单聊消息时，消息平均延时在5秒左右。</p><p>cpu 100%， 内存80% （压测程序占用了15%内存），消息入库会导致redis/mongodb内存增加</p><div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 579px;">
<div class="image-container-fill" style="padding-bottom: 45.23%;"/>
<div class="image-view" data-width="1280" data-height="579"><img src="https://upload-images.jianshu.io/upload_images/26766306-4eae2bb35c6bbb5d.png" data-original-width="1280" data-original-height="579" data-original-format="image/png" data-original-filesize="78323"/></div>
</div>
<div class="image-caption"/>
</div><div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 576px;">
<div class="image-container-fill" style="padding-bottom: 45.0%;"/>
<div class="image-view" data-width="1280" data-height="576"><img src="https://upload-images.jianshu.io/upload_images/26766306-4e9f5d69d4f32e69.png" data-original-width="1280" data-original-height="576" data-original-format="image/png" data-original-filesize="66190"/></div>
</div>
<div class="image-caption"/>
</div><div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 607px;">
<div class="image-container-fill" style="padding-bottom: 47.42%;"/>
<div class="image-view" data-width="1280" data-height="607"><img src="https://upload-images.jianshu.io/upload_images/26766306-10f892af01addaf1.png" data-original-width="1280" data-original-height="607" data-original-format="image/png" data-original-filesize="89200"/></div>
</div>
<div class="image-caption"/>
</div><p>启动万人群聊压测</p><p>（1）创建一个万人群组</p><p>./create_work_group_open_im -gmn 10000</p><p>创建完毕，groupID为3282359177</p><p>（2）模拟群3282359177中1000个成员登录并往群里发送消息，每秒发送500条消息。出现[send msg begin ] 表示初始化连接及登录完毕，开始发送消息</p><p>./press_open_im -gid 3282359177 -sn 1000 -mn 1000 -t 2000</p><p>（3）查看消息收发量，每秒500条消息</p><p>tail -f OpenIM.log.all.2022-09-02  |grep "msg_gateway sendMsgCount"</p><p>（4）启动消息延时检测程序，在此压力下，消息从发送方发出到接收方成功接收大概需要6秒</p><p>./msg_delay_open_im -gid 3282359177  -mn 100 -t 100</p><p>万人大群压测结论</p><p>华为云主机s3一台：8核16G内存，网络带宽10Mb，普通磁盘（非SSD），群成员1万人，同时在线 1千人，每秒往群内发送500条消息，，消息平均延时在6秒左右。</p><p>cpu 45%， 内存70% （压测程序占用了15%内存），消息入库会导致redis/mongodb内存增加</p><p>关于OpenIM</p><p>OpenIM是由IM技术专家打造开源即时通讯组件，也是目前最受欢迎的开源IM项目之一，开发者通过集成OpenIM组件，并私有化部署服务端，可以将即时通讯、实时通讯能力快速集成到自身应用中，并确保业务数据的安全性和私密性。github社区活跃，star近万，排名遥遥领先，开发者万人，OpenM力争开源IM项目No1，打造开源IM第一社区。</p><p>开源IM OpenIM最近更新如下，请各位知悉：1、pc端允许开多个实例，即一台电脑可以同时登陆多个不同的账号；2、app发现页后台动态配置url；3、pc在多台电脑上同时登录同一个账号不互踢， 手机端统一平台互踢；4、后台给全员发送广播消息，触达所有用户；5、网络重连提示、消息同步开始和结束提示；6、后台客户IP显示查询功能，可拉黑指定IP ，可查询相同ip账户注册量 ；拉黑ip不能注册，也不能登录系统；7、后台可设置注册成功自动添加指定好友;8、指定账号可设置指定多个IP才能登录；9、未读数多端同步，卸载重装未读数同步，解决多端在线时未读数实时同步问题，解决多端离线再登录后未读数同步同步</p><p>github地址：https://github.com/OpenIMSDK/Open-IM-Server</p><p>开发者中心：https://doc.rentsoft.cn/#/</p><div class="image-package">
<div class="image-container" style="max-width: 700px; max-height: 601px;">
<div class="image-container-fill" style="padding-bottom: 64.97%;"/>
<div class="image-view" data-width="925" data-height="601"><img src="https://upload-images.jianshu.io/upload_images/26766306-5219949fafc37a7a.png" data-original-width="925" data-original-height="601" data-original-format="image/png" data-original-filesize="84703"/></div>
</div>
<div class="image-caption"/>
</div><p>单聊压测程序</p><p>仓库地址</p><p>https://github.com/OpenIMSDK/Open-IM-SDK-Core/tree/v2.3.0release/single_test</p><p>代码说明</p><p>press_open_im.go 压测消息发送，但发送者不校验是否完成接收到</p><p>msg_delay_open_im.go 检测消息发送和接收，在大压力情况下，消息的可靠性和时延测试</p><p>使用说明</p><p>（1）修改../test/config.go TESTIP和SECRET</p><p>（2）go build press_open_im.go</p><p>./press_open_im -sn 10000 -mn 1000 -t 100</p><p>参数sn 10000表示：启动10000个压测客户端；</p><p>参数mn 1000表示：每个客户端发送消息数量为1000条；</p><p>参数t 100表示：每次发送一条消息后，休眠100毫秒；如果是1万客户端，算起来大概是每秒钟发送10万条消息；</p><p>（3）go build msg_delay_open_im.go</p><p>./msg_delay_open_im -sn 2 -mn 1000 -t 100</p><p>参数sn 2 表示：启动2个客户端消息收发检测；</p><p>参数mn 1000表示：每个客户端发送1000条消息；</p><p>参数t 100表示：每次发送一条消息，休眠100毫秒；</p><p>群聊压测程序</p><p>仓库地址</p><p>https://github.com/OpenIMSDK/Open-IM-SDK-Core/tree/v2.3.0release/work_group_test</p><p>代码说明</p><p>create_work_group_open_im.go 创建测试群</p><p>press_open_im.go 压测消息发送，但发送者不校验是否完成接收到</p><p>msg_delay_open_im.go 检测消息发送和接收，在大压力情况下，消息的可靠性和时延测试</p><p>使用说明</p><p>（1）修改../test/config.go TESTIP和SECRET</p><p>（2）go build create_work_group_open_im.go</p><p>./create_work_group_open_im -gmn 10</p><p>参数gmn表示：创建群成员为10的测试群，实际会创建13个成员。</p><p>（3）go build press_open_im.go</p><p>./press_open_im -gid 1510503557 -sn 10 -mn 1000 -t 100</p><p>参数gid 1510503557 表示：压测群聊groupID</p><p>参数sn 10表示：压测客户端数量，要小于等于群成员数</p><p>参数mn 1000表示：每个客户端发送消息数量为1000条；</p><p>参数t 100表示：每次发送一条消息，休眠100毫秒；</p><p>（4）go build msg_delay_open_im.go</p><p>./msg_delay_open_im -gid 1510503557 -mn 100 -t 100</p><p>参数gid 1510503557 表示：压测群聊groupID</p><p>参数mn 100表示：每个客户端发送消息数量为100条；</p><p>参数t 100表示每次发送一条消息，休眠100毫秒；</p></article><div/><div class="_19DgIp" style="margin-top:24px;margin-bottom:24px"/></div>]]></description></item>  </channel></rss>